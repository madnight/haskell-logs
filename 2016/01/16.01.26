00:00:44 <EvanR> Lokathor: yurg... a TVar with a Map of TVars, which no doubt might contain more TVars in StateThings
00:00:53 <EvanR> this is an antipattern even in closure ;)
00:01:10 <Lokathor> StateThing doesn't contain deeper TVar :P
00:03:59 <Lokathor> EvanR, the problem space is a server TVar mapping room names to tvars of room contents
00:04:12 <Cale> Lokathor: Where are the Map operations in this?
00:04:21 <EvanR> that sounds like an solution to some problem, not the space
00:04:21 <Cale> I see you're importing Data.Map.Strict as M
00:04:39 <Cale> (I don't really know why it would have to be Data.Map.Strict if your maps just have TVars in them anyway...)
00:05:10 <Lokathor> Cale, which map operations?
00:05:16 <Cale> But a search for "M." turns up nothing
00:05:27 <Lokathor> in Data.hs i use M.lookup and M.alter
00:05:39 <Lokathor> i ended up not using them in WebSocket.hs
00:05:58 <Cale> oh, I see
00:06:46 <Lokathor> EvanR, well, the problem space is that, conceptually, there's a server managing the contents of several rooms, each with a name
00:07:16 <Lokathor> the contents are a list of active clients "in" the room, as well as a sequence of lines reprisenting the current text of the room
00:07:42 <Lokathor> users send edit commands, it updates the room data, and is forwarded to all other users
00:08:31 <EvanR> Lokathor: sure... its just a simpler implementation to have the state as one value in a single MVar or TVar
00:08:37 <EvanR> popular in clojure
00:09:06 <Lokathor> i was concerned about contention if the map itself was being updated with renewed room entries on every update
00:09:24 <Lokathor> might have over-engineered
00:09:27 <Cale> Wait, wtf
00:09:29 <EvanR> maps were made to be updated!
00:09:35 <Cale> lineSender doesn't terminate
00:09:43 <Cale> But it's... in a withAsync
00:09:51 <Cale> What???
00:09:52 <Lokathor> yes, it runs on an async thread
00:10:11 <Cale> async is for computations which compute a result that you need later
00:10:38 <Lokathor> once the user disconnects, the async is canceled automatically by withAsync
00:10:40 <Cale> You use forkIO to create new threads that just run
00:10:49 <Cale> uhhh
00:10:50 <Cale> hmm
00:10:54 <Lokathor> at least, if i understand how withAsync works correctly that's how it works
00:11:13 <Cale> That feels like a horrible abuse to me... it might work
00:11:26 <Lokathor> it might be a horrible abuse
00:11:31 <Cale> Are you sure the other thread doesn't just kill itself because 'a' is garbage collected?
00:11:43 <Lokathor> "withAsync is like async, except that the Async is automatically killed (using cancel) if the enclosing IO operation returns before it has completed."
00:13:40 <Lokathor> the docs suggest that you can built a thread tree using it
00:13:58 <Cale> I thought that part of the point of Async was that if you didn't end up waiting on an Async after all, the thread kills itself.
00:14:36 <Cale> Maybe I'm mistaken about that...
00:15:02 <Lokathor> cancelation is not automatic
00:15:16 <Cale> So lineSender seems to continue running?
00:15:28 <Lokathor> yeah it runs as long as the user is connected
00:15:34 <Cale> okay, fine then
00:18:44 <Cale> okay, so sendRoomData runs once at the beginning, and then once again at the end of the test
00:18:48 <Lokathor> users for sure get the initial update. but they don't seem to share updates with each other any more
00:19:39 <Lokathor> Cale, where are you seeing it run a second time?
00:19:48 <Cale> http://lpaste.net/150890#line16
00:19:49 <Lokathor> oh right
00:19:55 <Lokathor> that was a 2nd user joining
00:19:55 <Cale> seems like two?
00:19:57 <Cale> okay
00:20:00 <Lokathor> it runs once per join
00:20:25 <Cale> are you sure roomName is the exact same?
00:21:17 <Lokathor> yep, exact same
00:23:16 <Lokathor> i suppose I could just adjust it to not nest TVars
00:23:30 <Cale> That shouldn't be a problem, but it is weird
00:24:09 <Lokathor> oh
00:24:11 <Lokathor> oh oh
00:24:13 <Lokathor> i am an idiot
00:24:19 <Cale> ?
00:24:37 <Lokathor> maybe?
00:24:37 <Lokathor> hmm
00:25:11 <Lokathor> no, i was thinking since it was me logged in via two tabs, it'd be the same ClientInfo both times
00:25:40 <Lokathor> but the Unique on the ClientConnection should keep it distinct, so people should still get updates sent around and such
00:56:21 * hackagebot aeson-extra 0.3.0.1 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.3.0.1 (phadej)
01:11:21 * hackagebot cgrep 6.5.15 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.15 (NicolaBonelli)
01:37:46 <saurabhnanda> I have a string (or bytestring, or lazy-bytestring, I don't know) and I need to feed it to http://hackage.haskell.org/package/json-rpc-0.7.0.2/docs/Network-JsonRpc.html#g:3
01:38:20 <saurabhnanda> how do I convert a String (or ByteString) to a Conduit that can be fed to Network.JsonRpc.decodeConduit ?
01:40:14 <kqr> saurabhnanda, looking at the documentation for conduit (https://hackage.haskell.org/package/conduit-1.2.6.1/docs/Data-Conduit.html)
01:40:45 <kqr> saurabhnanda, there's a function called yield with the description "Send a value downstream to the next component to consume"
01:41:07 <kqr> saurabhnanda, it appears to take an argument which represents the output value and then return a conduit
01:41:12 <kqr> saurabhnanda, perhaps that's what you want
01:41:48 <saurabhnanda> kqr: I was trying sourceList
01:41:54 <merijn> saurabhnanda: Note that a String and a ByteString (lazy or strict) are VERY different things
01:42:01 <saurabhnanda> kqr: and I'm stuck with so many string representations
01:42:16 <merijn> Despite the historical accident in the name there's nothing Stringy about ByteString
01:42:18 <kqr> yeah bystestring is not a string at all, it's binary data
01:42:21 <MasseR> Even though ByteString is not a string implementation
01:42:38 <kqr> are you dealing with human text or are you dealing with data from a file/network etc?
01:42:41 <merijn> saurabhnanda: Pretend the last "ring" isn't there and it's just called "Bytes"
01:45:02 <saurabhnanda> kqr: on ghci I'm dealing with human readable text. When this gets plugged into my code, it's a JSON coming over the network.
01:45:12 <saurabhnanda> kqr: JSON coming over a websocket, to be precise
01:45:52 <kqr> saurabhnanda, json coming over a websocket counts as binary data, and as such you should use ByteString for it
01:46:00 <apsod> question: is the functor (Rep f, a) w.r.t. a always the left adjoint to a representable functor f?
01:46:13 <saurabhnanda> kqr: how do I try it out on the ghci in that case?
01:46:28 <kqr> saurabhnanda, run ":set -XOverloadedStrings"
01:46:39 <kqr> saurabhnanda, that will turn GHCi into a mode where "blah" is a bytestring
01:47:19 <saurabhnanda> "a" :: Data.String.IsString a => a
01:47:29 <kqr> saurabhnanda, sure, and "a" :: ByteString will typecheck
01:47:30 <saurabhnanda> kqr: already done that. seems to make strings really weird
01:47:41 <saurabhnanda> okay done that now
01:48:07 <kqr> strings become a little weird, but that means they automatically get converted to bytestrings
01:48:39 <kqr> and i'm not saying you should use bytestrings for json data to be mean, i'm just saying it so you don't have to be confused about all the different string types
01:48:54 <saurabhnanda> RPC.encodeConduit $ DL.sourceList "Saurabh"  -------------Couldn't match expected type ‘DC.ConduitM i0 a0 m1 () -> t’ with actual type ‘DC.ConduitM j0 ByteString m0 ()’
01:49:09 <jophish> Often a packages dependencies grow just for the package to add instances for classes defined in the dependencies. Is this a problem that backpack is hoping to address?
01:49:18 <saurabhnanda> Relevant bindings include it :: t (bound at <interactive>:45:1) Relevant bindings include it :: t (bound at <interactive>:45:1), but its type ‘DC.Conduit j0 m0 ByteString’ has none
01:49:23 <jophish> It seems related to backpack's goals, but not exactly the same
01:50:39 <merijn> jophish: No, I think this is an annoying problem, but I wouldn't know how to solve it without orphan instances and I don't think people understand how to make sane behaviour happen with orphans
01:52:06 <cocreature> we just pretend that orphans don’t exist and don’t admit that we all use them
01:52:21 <saurabhnanda> any help?
01:53:44 <merijn> cocreature: That's a good way to produce code with horrifically hard to find bugs
01:54:03 <jophish> merijn: I think I've come up with a solution, but perhaps there's something I've not considered: I have package MyPackage which implements an instance of a class found in package C. In the 'build-depends' section of the .cabal file the dependency on package C is marked as 'optional'. When MyPackage is being compiled as a dependency C is only compiled and used if it's a non-optional dependency of any other
01:54:09 <jophish>  package included in the compile
01:54:18 <jophish> The problem with that is that standalone compiling packages doesn't mesh well
01:54:29 <jophish> but it fixes things for one use case
01:54:56 <cocreature> merijn: I wasn’t being completely serious, but I think there is some truth to that statement
01:55:00 <jophish> This can be implemented at the moment rather clumsily with flags, but then conflicts arise if MyPackage is included with different flags
01:55:41 <jophish> cocreature: I think the only place I'm 'happy' using orphans is in small executable code, such as tests
01:55:54 <merijn> jophish: Except that will horrifically break because now you API changes based on a flag
01:56:01 <merijn> jophish: And cabal assumes that that cannot happen
01:56:41 <merijn> jophish: So you install something that uses your typeclass instance, GHC sees you have dependency C already installed (doesn't notice you didn't compile it with the optional instances), continues compiling and fails horribly
01:57:07 <merijn> This isn't just a haskell problem, Rust has the exact same difficulties dealing with orphans
01:57:09 <jophish> cabal and ghc would have to be wise to the plan of course
01:57:18 <cocreature> jophish: I’m never happy to use them, but that doesn’t mean I never use them.
01:58:42 <jophish> merijn: if I compile MyPackage with a dependency on C, perhaps it could go into the package database as MyPackage+C. a dependency on MyPackage by a package without a non-optional dependency on C would be satisfied by MyPackage or MyPackage+C
01:59:16 <jophish> But if the dependent package has a non-optional dependency on C and MyPackage then it's only satisfied by MyPackage+C
01:59:37 <jophish> (Let's not think about the exponential number of packages this would lead to)
01:59:43 <merijn> jophish: This requires quite a lot of engineering and no one is sure if it's actually a good idea
02:00:33 <jophish> merijn: sure, but hopefully it would be nicer than packages depending on the world, or mypackage-c-orphans packages
02:00:53 <jophish> This just doesn't seem to be a conversation I see many people having
02:01:36 <kqr> saurabhnanda, you "connect" conduits
02:01:55 <saurabhnanda> kqr: I'm not sure what I'm doing hee
02:01:59 <kqr> saurabhnanda, so something like runConduit (DL.sourceList "Saurabh" $$ RPC.encodeConduit)
02:02:04 <saurabhnanda> the type signature of decodeConduit is not what I think it is
02:02:19 <merijn> jophish: They are, but it's a hard problem. See my mention of Rust earlier
02:02:19 <kqr> saurabhnanda, where $$ is the operator to connect a source to a sink (a source sends out data, a sink receives it and returns a final value)
02:02:25 <saurabhnanda> wow, more syntax. What is $$ for?
02:02:35 <kqr> it's not syntax, it's a function of conduit
02:02:37 <merijn> jophish: They've had like a 6 or so month mailing list discussion about orphan isntances
02:02:49 <merijn> jophish: And they still didn't come up with an adequate solution
02:03:05 <kqr> saurabhnanda, if you dislike operators, you can also do something like runConduit (connect (DL.sourceList "Saurabh") RPC.encodeConduit)
02:03:13 <kqr> saurabhnanda, where connect is just a synonym for $$
02:03:48 <saurabhnanda> and why is runConduit required?
02:03:55 <saurabhnanda> why doesn't $$ alone work?
02:04:35 <kqr> maybe it does
02:04:38 <kqr> yeah never mind the runConduit stuff
02:04:43 <kqr> $$ alone should work
02:05:12 <kqr> (I think the connect/$$ operator has a runConduit built into itself or something)
02:05:54 <saurabhnanda> not working, still struggling with type issues
02:06:03 <saurabhnanda> let y = (DL.sourceList "Saurabh" DC.$$ (RPC.decodeConduit RPC.V2))
02:06:24 <kqr> what is DL.sourceList?
02:06:25 <saurabhnanda> Couldn't match type ‘Either                           RPC.Response aeson-0.9.0.1:Data.Aeson.Types.Internal.Value’                   with ‘Data.Void.Void’    Expected type: DC.Sink ByteString m ()      Actual type: DC.Conduit                     ByteString                     m                     (Either RPC.Response aeson-0.9.0.1:Data.Aeson.Types.Internal.Value)    In the second argument of ‘(DC.$$)’, namely      ‘
02:06:37 <kqr> also decodeConduit may not be a sink
02:07:34 <saurabhnanda> kqr: DL.sourceList is documented at http://haddock.stackage.org/lts-5.0/conduit-1.2.6.1/Data-Conduit-List.html
02:07:58 <saurabhnanda> kqr: decodeConduit is documented at http://hackage.haskell.org/package/json-rpc-0.7.0.2/docs/Network-JsonRpc.html#g:3
02:08:12 <kqr> saurabhnanda, that means a call like DL.sourceList "Saurabh" will become a producer that produces one character at a time
02:08:24 <kqr> saurabhnanda, so the first character will be 'S', the second will be 'a', the third will be 'u' and so on
02:08:28 <kqr> saurabhnanda, is this really what you are looking for?
02:09:45 <saurabhnanda> kqr: all I'm trying to do is take a JSON received from a websocket and feed it to the correct function in JSON-RPC and get a haskell object out.
02:10:20 <kqr> saurabhnanda, do you need JSON-RPC specifically, or are you dealing in arbitrary json?
02:10:46 <kqr> saurabhnanda, if you just want to decode json, Aeson is the commonly used library
02:10:50 <saurabhnanda> kqr: it's JSON RPC
02:11:00 <kqr> yeah but is that different from regular JSON?
02:11:06 <saurabhnanda> kqr: fallback option is to hand-code something using Aeson
02:11:10 <kqr> ah okay
02:11:18 <kqr> well
02:11:28 <saurabhnanda> kqr: it's regular JSON with more semantics on top of it
02:11:34 <kqr> yeah I understand
02:11:41 <kqr> well
02:11:46 <kqr> https://hackage.haskell.org/package/conduit-extra-1.1.9.2/docs/Data-Conduit-Network.html
02:11:50 <kqr> that library has a sourceSocket function
02:11:59 <kqr> which takes a socket and returns a Producer of bytestring
02:15:25 <kqr> so you'd want something like (sourceSocket connection =$= decodeConduit V2 $$ ???)
02:15:37 <kqr> where ??? is something that takes all the results from the pipeline and returns them as a value
02:17:21 <kqr> maybe consume
02:17:27 <saurabhnanda> kqr: before I wire it up with the network, I want to try how it works on the ghci
02:17:53 <kqr> sure, just replace sourceSocket with some other Producer of bytestrings
02:17:55 <kqr> like yield
02:18:06 <kqr> yield "{'special': 'json'}"
02:18:11 <kqr> I guess
02:18:13 <kqr> or read a file
02:18:15 <kqr> or whatever
02:18:25 <haskell406> I am doing the monad challenges and have completed the task from http://mightybyte.github.io/monad-challenges/pages/ex2-3.html the function gives the correct results but on page http://mightybyte.github.io/monad-challenges/pages/ex2-4.html it says "If you solved the last challenge correctly, your function has no fewer than three case expressions. There are four points where the computation can fail and you need to check all of th
02:18:32 <haskell406> my code http://lpaste.net/150894
02:19:10 <haskell406> my code has four case statements which two can I chain together ?
02:19:12 <kqr> haskell406, you have four, which is no fewer than three, so you win a cake
02:19:41 <kqr> actually yours has five depending on how you view it
02:20:06 <haskell406> it says "two of them fail or succeed together"
02:20:29 <merijn> haskell406: You want ">>="
02:20:43 <merijn> > Nothing >>= Just . (+1)
02:20:46 <lambdabot>  Nothing
02:20:51 <merijn> > Just 2 >>= Just . (+1)
02:20:55 <lambdabot>  Just 3
02:21:08 <merijn> > Just 2 >>= \_ -> Nothing
02:21:13 <lambdabot>  mueval-core: Time limit exceeded
02:21:13 <haskell406> Ithis is part of the build up to that you can't use those yet it is using a custom prelude
02:22:18 <liste> yeah, >>= is basically the `link' in that exercise
02:23:25 <liste> haskell406 hint: (Just (Just x)) is a pattern
02:23:27 <frerich> haskell406: Originally, the text actually said 'no fewer than five case expressions'. I filed that as an issue at https://github.com/mightybyte/monad-challenges/issues/7 and the author changed it. But maybe the 'three' is an off-by-one again. :-)
02:24:54 <liste> haskell406 have you encountered a function with signature "(a -> b) -> Maybe a -> Maybe b" in that course?
02:25:39 <haskell406> liste not yet
02:26:14 <frerich> liste: No, actually, the course uses a trimmed down prelude which doesn't include support for a lot of stuff (e.g. head, tail, maximum and a whole slew of others). I'm not sure whether fmap woudl be avilable.
02:26:36 <frerich> liste: I think the idea is that you can use the trimmed prelude and functions you defined yourself in earlier exercises, but not more.
02:31:23 <haskell406> frerich fmap isn't available
02:43:09 <John[Lisbeth]> foo@(bar:baz)
02:43:18 <John[Lisbeth]> what does @ do?
02:43:41 <tdammers> it allows you to refer to the pattern as a whole
02:43:49 <julianleviston> John[Lisbeth]: matches the whole value.
02:43:58 <kqr> John[Lisbeth], it saves everything in the foo variable and the head in bar and the tail in baz
02:44:10 <Taneb> John[Lisbeth]: if that pattern matches, foo will be the same as bar:baz
02:44:27 <tdammers> so when you match foo@(bar:baz) on [1, 2, 3], you'll have bar == 1, baz == [2, 3], and foo == [1,2,3]
02:45:36 <John[Lisbeth]> does it only work for lists?
02:45:55 <julianleviston> no
02:46:53 <John[Lisbeth]> can I do foo@(bar :: baz) and have foo be syntactic sugar for (bar :: baz)?
02:47:52 <kqr> no
02:47:58 <kqr> only for patterns
02:48:12 <John[Lisbeth]> is pattern a typeclass or?
02:48:36 <kqr> a pattern is the thing you can write for function arguments
02:48:41 <kqr> and branches in a case…of
02:49:31 <julianleviston> John[Lisbeth]: patterns are a way to match variables to pieces of data, and to “deconstruct” them into pieces… like you did with the list.
02:50:23 <julianleviston> > let (a:b:c:[], 5) = ([1,2,3], 5) in b
02:50:26 <lambdabot>  2
02:50:52 <julianleviston> > let ([a,b,c], 5) = ([1,2,3], 5) in c
02:50:54 <lambdabot>  3
02:50:56 <John[Lisbeth]> what about [0,1,2] !! 2
02:51:07 <julianleviston> that’s just a function application...
02:51:23 <Taneb> John[Lisbeth]: !! is an (infix) function, not a pattern
02:51:27 <julianleviston> applying the operator (function) named (!!) to the argument [0,1,2] and 2
02:51:47 <Taneb> : is a data constructor, which is a special kind of function which is also a pattern
02:51:47 <julianleviston> I’ll butt out and let you guys continue for brevity sake
02:52:43 <John[Lisbeth]> thanks guys
03:06:25 * hackagebot process 1.4.2.0 - Process libraries  https://hackage.haskell.org/package/process-1.4.2.0 (MichaelSnoyman)
03:10:09 <kqr> tee hee butt
03:26:26 * hackagebot resourcet 1.1.7.1 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.7.1 (MichaelSnoyman)
03:31:00 <nomeata> Darn, now I am also hit by the 7.10 generics performance bug, after adding a few data types, I cannot compile my code in reasonable time any more :-(
03:32:02 <srhb> nomeata: Which bug is that, and how bad is the worsening?
03:32:55 <nomeata> https://ghc.haskell.org/trac/ghc/ticket/9630 likely. and GHC fills my RAM...
03:33:31 <srhb> Thanks.
03:33:53 <bergmark> srhb: https://github.com/bos/aeson/pull/335
03:37:33 * nomeata tries aeson from git
03:41:58 <Franciman> Hello
03:43:34 <nomeata> hmm, not much better. darn.
03:43:49 <liste> hello Franciman
03:43:58 <Xnuk> >> tailMay []
03:44:01 <Xnuk> > tailMay []
03:44:04 <lambdabot>  Nothing
03:44:07 <Franciman> A question on the edge between C and Haskell
03:44:18 <Franciman> If I have a C function char *getMyData
03:44:29 <Franciman> and use FFI
03:44:40 <Franciman> to export it to haskell
03:44:50 <Franciman> then if I define it like
03:45:57 <Franciman> getMyData :: IO (Ptr Int)
03:46:23 <Franciman> will my getMyData result be correctly interpreted as an array of ints?
03:46:48 <balor> My cabal seems to fail to install *everything* http://lpaste.net/150902  I've done an `rm -r ~/.cabal ~/.ghc` and I've also pulled down the stackage cabal conf.  I'm sure I'm doing something stupid....but I can't tell what.
03:47:15 <srhb> balor: It seems you do not have Cabal the library installed.
03:47:29 <srhb> balor: Or it cannot be found at compile time anyway
03:47:41 <balor> ah
03:47:55 <liste> Franciman at least IO (Ptr Word8) should be interpreted correctly
03:47:59 <liste> not sure about Int
03:48:33 <Franciman> I see
03:48:36 <Franciman> ok thank
03:48:39 <balor> srhb, much obliged.
03:49:56 <Franciman> Now, my real problem. I am using a library that extracts samples from an audio file. But the format of samples is given by an enum. All I extract from the audio file is just an array of chars. How can I manage the interpretation of the samples in the correct format haskell-side?
03:51:56 <liste> Franciman you could write something like "f :: Array Int Word8 -> Array (Int,Int) Int" to convert the format if you want to do it in Haskell
03:52:32 <liste> what do you want to do with the data? write it out using the same library you read with?
03:54:06 <Franciman> liste, display a waveform
03:54:30 <bjz_> merijn: at least with Rust they have forbidden orphan instances :)
03:54:57 <bjz_> merijn: can be annoying at times, but I'm glad it is like that
03:55:36 <liste> Franciman then I guess a peekArray + fold could work (:
03:55:59 <Franciman> ok, thanks
03:56:11 <liste> https://hackage.haskell.org/package/base-4.8.2.0/docs/Foreign-Marshal-Array.html#v:peekArray
03:56:30 <srhb> bjz_: How on earth do they deal with that?
03:57:59 <bjz_> srhb: you can't implement traits from external packages on external types
03:58:13 <srhb> Huh, okay.
04:00:21 <bjz_> srhb: The idea is that crates (packages) should be composable. If it typechecks on its own, it should typecheck when used with other crates. I doubt it is very well tested though.
04:01:15 <bjz_> by 'very well' I mean 'extensively'
04:02:38 <nomeata> Is there any downside to using the Data.Aeson.TH instead of the generics-based approach? Can these two be used interchangeably?
04:02:58 <bergmark> nomeata: they should be interchangeable
04:03:06 <jdnavarro> is there any OS/distro using GHC-7.8.3 by default?
04:03:56 <jdnavarro> AFAIK Debian stable is using ghc-7.6.3 but testing goes directly to ghc-7.10.3
04:04:12 <tdammers> jdnavarro: use stack :x
04:04:44 <tdammers> (seriously, it's the easiest way to install the GHC you want, or multiple GHC's next to each other)
04:05:28 <jdnavarro> tdammers: are older lts versions still maintained? like lts-2?
04:06:04 <tdammers> not sure
04:07:06 <bergmark> jdnavarro: no, we can release new minor versions of older LTSes, but we mostly don't since it gets more time consuming each time
04:07:49 <srhb> jdnavarro: I think that might be the default GHC on NixOS
04:07:53 <srhb> Stable, I mean.
04:08:08 <jdnavarro> bergmark: it's understandable
04:08:10 <srhb> jdnavarro: Unstable is 7.10.3
04:08:49 <jdnavarro> srhb: that's an important one
04:09:04 <jdnavarro> so I guess I'll still support 7.8
04:09:19 <srhb> jdnavarro: You'd have to check to be absolutely sure :-)
04:09:33 <nomeata> With automatic aeson instaces, there is no way to tell it when to use inline list style, and when to use the multiline list style, right?
04:09:35 <srhb> Besides, considering how pluggable Haskell architecture is on Nix, it might not be important.
04:10:47 <Syver> has anyone else experienced a bug in ghc-mod/emacs that crashes emacs when importing as qualified (on Windows)?
04:11:24 <joeyh> is there any way to make a cabal file build with -O2 by default, but let cabal configure --disable-optimization work?
04:12:27 <fr33domlover> joeyh, maybe ~/.cabal/config can help?
04:12:36 <fr33domlover> set GHC options there etc.?
04:15:42 <yfix> :t on
04:15:44 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
04:15:50 <yfix> :t insert
04:15:51 <lambdabot> Ord a => a -> [a] -> [a]
04:15:57 <yfix> :t elem
04:15:58 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
04:16:46 <yfix> @pl (\a x->if elem x a then (a,[]) else (insert x a,[x])) empty
04:16:47 <lambdabot> ap (flip if' (empty, []) . flip elem empty) (ap ((,) . flip insert empty) return)
04:16:56 <yfix> @pl (\a x->if elem x a then (a,[]) else (insert x a,[x]))
04:16:56 <lambdabot> ap (ap . ap (flip . (if' .) . flip elem) (flip (,) [])) ((`ap` return) . ((,) .) . flip insert)
04:17:57 <yfix> could the above be coded nicely, with some Alternative or something?
04:19:54 <yfix> :t (\a x->if elem x a then (a,[]) else (insert x a,[x])) empty
04:19:56 <lambdabot> Ord t => t -> ([t], [t])
04:20:06 <yfix> :t (\a x->if elem x a then (a,[]) else (insert x a,[x]))
04:20:08 <lambdabot> Ord t => [t] -> t -> ([t], [t])
04:20:55 <yfix> @djinn Ord t => [t] -> t -> ([t], [t])
04:20:56 <lambdabot> Error: Undefined type []
04:21:20 <yfix> @djinn Ord t => f t -> t -> (f t, f t)
04:21:21 <lambdabot> Error: Class not found: Ord
04:21:33 <yfix> @djinn f t -> t -> (f t, f t)
04:21:34 <lambdabot> f a _ = (a, a)
04:22:29 <yfix> if somebody's here, could (\a x->if elem x a then (a,[]) else (insert x a,[x])) be coded nicely with some Alternative?
04:24:42 <yfix> NAMES #haskell
04:27:31 <vkt> mikeplus64
04:36:29 * hackagebot moesocks 1.0.0.41 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-1.0.0.41 (JinjingWang)
04:42:42 <letrec> hello! is there any variant of the continuation monad that can wire different continuations from cont to cont? I mean binding different continuations in bind?
04:44:31 <letrec> hmm indexed continuation monad maybe? i have to read about indexed monads
04:50:43 <christiann> Xandaros, are u here?
04:51:17 <liste> letrec indexed monads sound about right
04:53:53 <letrec> thx @liste
05:11:32 <Xandaros> christiann: I am, but I'm in a meeting atm
05:30:42 <knupfer> Is TH run before rewrite rules, and if yes, is it possible to generate rewrite rules with TH?
05:33:54 <badmash> hell there -- is there way to set -Werror as the default option for compilation in GHC?
05:34:38 <merijn> badmash: If you use cabal, then yes
05:34:40 <frerich> badmash: I'm not aware of anything. In a .cabal file there's a section called "ghc-options" which lets you do that.
05:34:52 <frerich> badmash: Or maybe, if you are on Linux/OS X, you could alias 'ghc' to 'ghc -Werror'
05:35:18 <merijn> 'alias typecheck = ghc -Werror -fno-code -O0' ;)
05:35:24 <badmash> frerich: ah, that's right ... i am using OS X, so i can do that
05:35:35 <bernalex> frerich: alias-ing ghce to ghc -Werror is probably a bit safer.
05:35:52 <merijn> cabal will refuse to upload with -Werror in your cabal file
05:35:57 <merijn> So it's ok
05:36:06 <bernalex> saves a few seconds of headscratching in the future before you remember to escape aliases.
05:36:26 <bernalex> merijn: really? why?
05:36:36 <merijn> bernalex: Brittle for the future
05:36:50 <merijn> bernalex: People downloading your package have it randomly break when future GHC adds new warnings
05:36:57 <bernalex> merijn: so is [insert anything a developer can do ever]. I think it's a bit arbitrary to limit that specific thing.
05:37:10 <badmash> one more question -- is the Nix-like package handling coming to cabal in GHC 8.0?
05:37:49 <bernalex> haskell packages are often an utter nightmare to package, because everyone has very strict upper bounds, and then a holiday happens, and everyone and his dog decides to bump their packages, and so everything everywhere breaks even if nothing is actually broken.
05:39:09 <badmash> bernalex: i know ... but there was post in reddit from ezyang -- i don't who he really is -- but he was non-committal and gave all kinds of reasons for its delay
05:39:22 <bernalex> badmash: wat?
05:39:34 <bernalex> badmash: IDK what you are talking about at all. but I know Edward.
05:40:02 <badmash> bernalex: i am talking about a nix-like package management in cabal -- a supposedly new feature
05:40:09 <merijn> badmash: Edward's a phd students, I'd expect progress to depend on lots of external factors and not wanting to commit to anything
05:40:15 <knupfer> Propably he's talking of the potential coexistance of different lib versions with cabal.
05:40:40 <bernalex> badmash: oh. I wouldn't want that. cabal isn't a package manager and people should not use it outside of sandboxes.
05:40:46 <merijn> Hacking takes the backseat to hitting your paper deadlines :)
05:41:20 <christiann> Xandaros, okay, I dont want to disturb you :)
05:41:50 <badmash> merijn: i suppose so ... that's one of the things i see in haskell ecosystem ... things kind of go on for long time
05:41:59 <bernalex> merijn: and both take the backseat to computer games ime. :]
05:42:30 <merijn> badmash: Maybe, but if you compare the amount of new features in GHC releases it's staggering, compared to, say, Python, Ruby, JS, java, C, or basically any other language :p
05:42:43 <merijn> badmash: So I'm not sure "things go on for a long time" is really true
05:42:46 <badmash> bernalex: i am not sure why you are saying that ... lots of people want cabal to be able to uninstall things
05:43:04 <bernalex> badmash: they should stop using cabal for that.
05:43:27 <badmash> merijn: sorry if i have come across the wrong way, but i sort felt like that
05:43:45 <badmash> bernalex: and use what else instead?
05:44:08 <knupfer> badmash: nix
05:44:08 <bernalex> badmash: whatever their environment uses. ports, apt-get, portage, yum, whatever.
05:44:14 <bernalex> even nix, yeah.
05:44:38 <knupfer> badmash: you want nix like featuers in cabal, why not use the "original"?
05:45:17 <bernalex> I've heard of people using nix in Gentoo Prefix in Mac OS X. no clue how well that turned out though.
05:45:47 <ner0x652> Hi @all
05:47:16 <knupfer> > Hi@all
05:47:18 <lambdabot>  <hint>:1:3: parse error on input ‘@’
05:49:06 <ner0x652> I am involved in a computer programming club for kids, so I am interested to know if somebody has experience in using Haskell as the first language to teach programming?
05:49:50 <byorgey> ner0x652: yes, check out https://github.com/google/codeworld
05:50:04 <Lowl3v3l> ner0x652, i have, but not to kids. For kid's , my usual approach has been racked so far which is also functional and worked well :)
05:50:31 <ner0x652> I read not a single time that using functional languages as Common Lisp, Scheme as a primary language brings better results than using C++ or python
05:50:53 <ner0x652> byorgey: thank you :)
05:51:04 <Lowl3v3l> ner0x652, depends on the people you teach it to. and depends on "result" :D
05:51:24 <clintm> imo, it depends significantly on the teacher.
05:51:46 <ner0x652> Lowl3vel: absolutely, "result" is ambiguos in education
05:52:03 <ner0x652> right, the teacher has an important role
05:52:17 <knupfer> and it isn't clear what should be learned
05:52:47 <ner0x652> But I want to know how do kids respond to such languages
05:53:20 <Lowl3v3l> ner0x652, well up to my mind, they responded well on racket( and on ruby) especially. 
05:53:32 <ner0x652> such as Haskell
05:53:33 <knupfer> I would say better than to imperative languages, they've at least math in school.
05:53:49 <m1dnight_> I have started using the guards in monad in haskell. I am using the StateT (Either String) monad. Is it possible to make a failing guard return a string instead of ""?
05:53:58 <m1dnight_> Or do I have to copy/paste and modify the guard code?
05:54:28 <knupfer> can't you use: Left "foobar"?
05:54:36 <ggVGc> ner0x652: what other languages are "like haskell" except literal implementations of haskell?
05:54:37 <ner0x652> Lowl3v3l: thank you for your help
05:54:52 <knupfer> ggVGc: math
05:54:56 <ggVGc> or direct descendants of it
05:54:58 <ggVGc> knupfer: fair
05:55:12 <ner0x652> ggVGc: I do not know
05:55:22 <knupfer> ggVGc: Idris, Agda...
05:55:33 <knupfer> but Agda for kids, I don't know...
05:55:36 <ggVGc> knupfer: I wouldn't say they are very much like Haskell, from what I know of them
05:55:42 <newlifer> Haskell for kids?
05:55:44 <ggVGc> they are different enough
05:55:50 <ggVGc> maybe not
05:55:51 <ner0x652> Kids are >= 12 years old
05:56:06 <ggVGc> is taht a fact?
05:56:14 <newlifer> Too young, i think
05:56:30 <ggVGc> I'd like to still be a kid and I'm 26
05:56:32 * hackagebot BlogLiterately 0.8.1.5 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.1.5 (BrentYorgey)
05:56:56 * newlifer works on type theory course for kids.
05:58:49 <exio4> newlifer: sup with the age?
05:58:59 <ner0x652> Do you know about some experiments, research done on how programming languages influence learners(beginners)?
05:59:00 <newlifer> 15 and more
05:59:25 <newlifer> They have to know logic somehow
05:59:32 <exio4> newlifer: I don't really see how this changes much, you can learn the very basics, at a much slower-pace sure, but you can.
06:00:19 <newlifer> exio4, i plan use basics from what they already learned in school
06:00:28 <OverCoder> Say I have [1,2,3,4,5]
06:00:50 <OverCoder> How do I double every second number from right to left? ex. result is [1,4,3,8,5]
06:01:03 <exio4> OverCoder: this is homework, isn't it?
06:01:08 <opqdonut> OverCoder: write a recursive function
06:01:13 <OverCoder> exio4, yeah
06:01:17 <ner0x652> or use foldr?
06:01:20 <knupfer> ner0x652: http://www.tandfonline.com/doi/abs/10.1300/J025v04n03_11?journalCode=wcis20#.Vqd7-LkaqCg
06:01:20 <knupfer> "The Effect of the BASIC Programming Language on Problem-Solving Skills and Computer Anxiety"
06:01:21 <knupfer> :)
06:01:24 <opqdonut> ner0x652: same thing :)
06:01:32 <OverCoder> well I tried to use foldr but idk I couldn't think of the algorithm
06:01:37 <opqdonut> oh ok, there is actually a simple solution using library functions too
06:01:37 <exio4> OverCoder: you could ask in #haskell-beginners (they basically know more about the course and how it's supposed to go)
06:01:47 <OverCoder> exio4, ooh, okay
06:02:30 <opqdonut> OverCoder: but anyway, I recommend writing a function that pattern matches the first _two_ elements of the input list, like "f (x:y:xs) = something something (f xs)"
06:02:50 <knupfer> opqdonut: that's dangerous
06:02:56 <opqdonut> OverCoder: you need some other equations for f as well
06:03:03 <exio4> opqdonut: will that do it? right-to-left is not left-to-right ;) 
06:03:14 <opqdonut> oh, right to left
06:03:17 <opqdonut> interesting twist
06:03:44 <exio4> newlifer: depends on the country and the kid, then :p
06:04:17 <newlifer> exio4, Russia
06:04:39 <exio4> newlifer: you'll see there are young kids that will love Haskell and those that won't get it at all, no matter how basic you go 
06:04:40 <knupfer> OverCoder: zipWith ($) (cycle [id,(*2)]) [1..5]
06:04:40 <knupfer>  
06:04:50 <exio4> why do you give him solutions?
06:05:12 <knupfer> exio4: sry, I got excited
06:05:14 <exio4> let him deduce them by himself, using what he learnt from CIS194
06:05:15 <OverCoder> knupfer, ayyyy kinda too complicated to me haha, I'll make my own simpler solution
06:05:32 <opqdonut> knupfer: that's also left-to-right
06:05:45 <opqdonut> knupfer: (and zipWith (*) is simpler)
06:06:08 <knupfer> yeah
06:09:07 <Xandaros> OverCoder: You can define two functions that are mutually recursive. One that does every other starting with the first and one starting at the second
06:09:50 <OverCoder> Xandaros, two functions? hm, that'd work, but if it's in a single function would be better, I think I might use where
06:10:35 <Xandaros> OverCoder: In general, don't use where if your definition can stand on its own. You just needlessly lock things away that could potentially be useful in the future
06:10:48 <knupfer> OverCoder: You could reverse your list, make tuples with [1..] and multiply every even ...
06:11:23 <knupfer> Xandaros: How so?
06:11:25 <OverCoder> hmmmm
06:11:33 <OverCoder> knupfer, neat idea
06:11:38 <frerich> OverCoder: Another thought - doubling every second number from the right is the same as doubling every second number from the left - for lists with an odd number of arguments. And for lists with an even number of elements, you can consider what to do with the first elmement and then the tail is odd-numbered again.
06:12:02 <Xandaros> Oh, I didn't realise the "from the right" part, sorry
06:12:23 <knupfer> that "from the right" is easily solved with reverse...
06:12:36 <OverCoder> frerich, hm, lot of thinking :p
06:12:36 <knupfer> (albeit not efficient)
06:12:39 <OverCoder> But yeah also neat solution
06:13:41 <knupfer> OverCoder: I suggest that you look at the cycle function
06:14:04 <knupfer> :t cycle
06:14:06 <lambdabot> [a] -> [a]
06:14:13 <knupfer> > cycle [1,2]
06:14:15 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
06:17:46 <knupfer> OverCoder: I would try to avoid recursions, they are often verbose and may not terminate.
06:18:08 <OverCoder> hm
06:18:18 <frerich> knupfer: That sounds like a general criticism of computer programs. Or discussions with your fiancee :-)
06:19:00 <knupfer> I would try to avoid (I would try to avoid (...), they are often verbose
06:19:00 <knupfer>           and may not terminate.), they are often verbose and may not terminate.
06:19:24 <knupfer> OverCoder: look at the map function for example
06:19:44 <knupfer> it terminates (in most cases)
06:19:50 <tdammers> > "I would try to avoid " ++ fix ("avoiding " ++) ++ " because it doesn't terminate"
06:19:54 <lambdabot>  "I would try to avoid avoiding avoiding avoiding avoiding avoiding avoiding ...
06:20:01 <merijn> > fix error
06:20:03 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
06:20:07 <tdammers> that one is awesome
06:20:08 * OverCoder squeezes
06:20:08 <OverCoder> wat
06:20:12 <Xandaros> LOL
06:20:16 <tdammers> :t fix
06:20:17 <christiann> Hey guys I have a little Problem
06:20:17 <knupfer> > fix "OverCoder"
06:20:18 <lambdabot> (a -> a) -> a
06:20:18 <tdammers> :t error
06:20:19 <lambdabot>      Couldn't match expected type ‘a -> a’ with actual type ‘[Char]’
06:20:19 <lambdabot>      In the first argument of ‘fix’, namely ‘"OverCoder"’
06:20:19 <lambdabot>      In the expression: fix "OverCoder"
06:20:20 <lambdabot> [Char] -> a
06:20:23 <merijn> :t fix
06:20:24 <lambdabot> (a -> a) -> a
06:20:35 <knupfer> > fix (const "OverCoder")
06:20:36 <merijn> knupfer: Fix is the name of anonymous recursion
06:20:37 <lambdabot>  "OverCoder"
06:21:10 <tdammers> > fix ("Over" ++) ++ "Coder"
06:21:12 <lambdabot>  "OverOverOverOverOverOverOverOverOverOverOverOverOverOverOverOverOverOverOve...
06:21:14 <knupfer> merijn: Yeah, the Y, but I'm still not getting my head around it.
06:21:19 <merijn> knupfer: You can implement any recursive function as a non-recursive function + fix
06:21:25 <merijn> knupfer: Maybe this example helps: https://gist.github.com/merijn/b86649a6aa21bd140803
06:21:35 <OverCoder> hm, this fix function seems nice, haven't tried it though
06:21:37 <knupfer> fix ([1,2]++)
06:21:37 <srhb> > fix (\f x -> if x > 10 then x else f (x+1)) 1
06:21:40 <lambdabot>  11
06:21:41 <OverCoder> s/tried/learned about/
06:21:44 <knupfer> > fix ([1,2]++)
06:21:46 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
06:21:50 <frerich> knupfer: https://www.vex.net/~trebla/haskell/fix.xhtml made me 'get it'
06:21:53 <christiann> I have a String called "v" in my Input. I have an own data structure, where this is: data Statement = Assign String AExp  (last not important). Why it gives ma a parse error, if I call Assign(v AExp)?
06:21:57 <srhb> (I like to terminate it, seems less magicalto me :-P)
06:22:05 <knupfer> frerich: Thanks.
06:22:13 <Xandaros> OverCoder: Avoid it until you are comfortable with Haskell
06:23:36 <merijn> christiann: You're applying the string 'v' to AExp
06:23:38 <knupfer> merijn: Thank you for the gist!
06:23:45 <OverCoder> Xandaros, hm, okay
06:23:48 <merijn> christiann: Perhaps you mean "Assign v AExp"?
06:24:58 <frerich> christiann: If you write it like that, it considers 'v AExp' a function application.
06:25:19 <letrec> (completely irrelevant but the call by value fix is called Landin's Knot, right?)
06:25:31 <m1dnight_> https://www.refheap.com/114080 <- this ism y first attempt in wrapping guard to return an error function but Im kind of stuck on the case form.
06:25:44 <m1dnight_> Because the returntype of the gaurd is indeed `()`, but it is actually `Left ()`, no?
06:26:01 <quchen> merijn: That's a type error, not a parse error, as claimed.
06:26:06 <christiann> thanks guys
06:26:16 <christiann> Should have seen that..
06:29:46 <m1dnight_> I guess i would need something like the inverse of lift?
06:29:59 <m1dnight_> The either value is in the State monad, so i should be able to get that one out?
06:34:10 <merijn> m1dnight_: No, the return type of guard is () there
06:36:33 * hackagebot type-combinators 0.2.2.1 - A collection of data types for type-level programming  https://hackage.haskell.org/package/type-combinators-0.2.2.1 (KyleCarter)
06:36:35 * hackagebot type-combinators-quote 0.1.0.1 - Quasiquoters for the 'type-combinators' package.  https://hackage.haskell.org/package/type-combinators-quote-0.1.0.1 (KyleCarter)
06:39:56 <mniip> hmm
06:40:28 <mniip> how do I restrict the set of functions of the type forall a. [a] -> [a] to ones that return some tail of the argument, using the typesystem
06:41:10 <mniip> oh wait hm, that's wrong
06:41:23 <mniip> that's not the right question
06:44:47 <coconut> how to call pandoc in a haskell program ?
06:44:57 <MasseR> The executable or API?
06:45:09 <coconut> both
06:45:17 <coconut> the simplest way
06:45:28 <coconut> i want to mass convert a directory of epub to txt
06:45:36 <MasseR> System.Process probably
06:45:41 <tdammers> that might be easier from the shell
06:45:54 <MasseR> And true, shell would most likely be the easiest
06:46:09 <coconut> for learning's sake
06:46:19 <coconut> is there a pandoc library M
06:46:20 <coconut> ?
06:46:22 <tdammers> yes
06:46:31 <coconut> i need to process those converted txt files
06:46:40 <tdammers> http://hackage.haskell.org/package/pandoc
06:46:54 <coconut> ok
06:47:06 <tdammers> this module documents basic usage: http://hackage.haskell.org/package/pandoc-1.16.0.2/docs/Text-Pandoc.html
06:48:22 <coconut> pandoc itself does not support mass convert right? something like *.epub -o *.txt
06:49:45 <m1dnight_> merijn: but it returns Left "", right?
06:49:51 <m1dnight_> Im a bit confused.
06:50:26 <tdammers> coconut: no, but it doesn't have to, because you're either using a shell (where you can automate this better than pandoc could), or you're using pandoc as a library, in which case you can also do it better from outside than pandoc could do it itself
06:51:04 <merijn> m1dnight_: "guard b" returns () if 'b' is true (and continues on to your code) if 'b' is NOT true, it returns "Left """ *AND* never reaches your code
06:51:29 <merijn> m1dnight_: Do notation uses >>= internally and 'Left "" >>= \_  -> foo" just returns 'Left ""'
06:51:56 <mniip> wait Either is a MonadPlus?
06:52:12 <quchen> No, it has no mzero
06:52:18 <m1dnight_> But I should be able to implement somehting like this myself no?
06:52:25 <m1dnight_> I tried before but that didnt work due to laziness :<
06:52:35 <mniip> that's what I was thinking too
06:52:42 <merijn> mniip: mniip hmm, no, apparently not
06:52:52 <quchen> mniip: (Either a) is a MonadPlus for pointed a
06:52:54 <OverCoder> man, I had to squeeze my brain to get up with my own solution http://p.samuraimanpurse.com/I8a3wUBC.txt
06:52:57 <m1dnight_> If not, I will have the most ugly nesting in my cod, which is exactly what I was trying to avoid.
06:52:57 <merijn> mniip: I was just blindly trusting the code sample from earlier :p
06:52:58 <mniip> it could with a monoidal constraint
06:53:16 <merijn> quchen: Not Pointed, monoid
06:53:26 <mniip> oh but then what is mplus (Right x) (Right y)
06:53:50 <merijn> mniip: Irrelevant, like Just
06:53:55 <mniip> ah right
06:53:57 <merijn> > mplus (Just 1) (Just 2)
06:53:58 <lambdabot>  Just 1
06:54:00 <mniip> make ssense
06:54:16 <quchen> merijn: I meant *p*ointed, and Monoid is an example of that
06:54:37 <OverCoder> (Or honestly with the help of frerish)
06:54:40 <quchen> AKA "stuff with a special element"
06:56:18 <frerich> OverCoder: You could simplify 'even $ length (x:xs)' to 'odd (length xs)'. And the other guard could be just 'otherwise'. And those parentheses (parenthesis?) are unneeded around the arguments of ':'.
06:56:58 <OverCoder> frerich, hm, why would I simplify $ to ()? I thought $ simplifies ()
06:57:14 <OverCoder> also, yeah true about the otherwise thing, I'll fix it
06:57:30 <m1dnight_> merijn: I understand that, but I should be able to make it `Left string` instead of `Left ""`, no?
06:57:33 <frerich> OverCoder: I was rather getting at the idea that if 'x:xs' is of even length, then 'xs' is of odd length.
06:57:47 <m1dnight_> I just want the guard to give me a `Left customstring` instead of `Left ""`
06:59:18 <frerich> OverCoder: Another thought - as it is, your definition is somewhat inefficient because on every recursive step, your 'doubleEverySecondNumberR' function has to consider whether the length of the list is even or odd. You really only need to do that once and then the actual 'double every second element from the left' function can be much simpler.
07:01:15 * frerich sees that 'OverCoder' is 'part of the Elite' and thus has no doubts that he will come up with a glorious solution. =)
07:05:44 <SX> Hello!
07:06:22 <SX> Help me, please. Is there any way to make serializable exceptions, catch them and, well, serialize?
07:06:46 <OverCoder> frerich, hm, part of the Elite? :p
07:07:03 <EvanR> SX: sure
07:07:26 <EvanR> you can make a data type, make it an exception (Exception class) and make it serializable (Binary class)
07:07:33 <OverCoder> frerich, ah right, the bouncer has set that message hahaha
07:07:44 <frerich> OverCoder: My IRC client says so, so it must be true!
07:07:53 <OverCoder> haha
07:08:43 <SX> EvanR: Then how do I catch it? If I have some hierarchy of such serializable exceptions.
07:10:03 <SX> Should I make existential like SomeSerializableException with one more constraint?
07:11:13 <olmanmike> Question: I've got a conduit pipeline handling network packets that are part of a stateful protocol, and I want to deserialize and handle a bytestring differently based on the state the protocol is in. What's the best way to approach this?
07:14:39 <dramforever> olmanmike: one write function per state maybe?
07:15:19 <dramforever> *one function
07:15:47 <SX> olmanmike: You want to deser to different data types?
07:15:51 <olmanmike> That's what I did before using conduits
07:16:49 <badmash> when i run ghc -Wall Werror, it skips checking for incomplete patterns
07:16:52 <olmanmike> SX: Yes, and pass them down a conduit pipeline that treats these different types as one unified type
07:16:54 <EvanR> SX: to make hierarchies of exceptions, use sum types
07:17:22 <badmash> ghc -Wall -Werror --> skips incomplete patterns checking
07:17:26 <badmash> why is that?
07:17:30 <olmanmike> Like Either a b c
07:17:37 <badmash> yeah
07:18:08 <SX> EvanR: with forall, right?
07:18:18 <EvanR> no
07:18:32 <badmash> but if i run just ghc -Wall, it does just check for incomplete patterns
07:18:44 <EvanR> SX: well read this before continuing https://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Exception.html
07:19:11 <EvanR> SX: apparently i mean existential types (forall)
07:20:32 <badmash> so how can i run ghc and check for all warnings and error out if there any, including incomplete patterns?
07:21:14 <SX> EvanR: like SomeSerializableException?
07:21:35 * hackagebot bifunctors 5.2.1 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.2.1 (EdwardKmett)
07:22:15 <SX> olmanmike: well, you need to either use existential type or wrap it in data type.
07:22:35 <EvanR> SX: what exactly are you trying to do
07:22:38 <olmanmike> existential types?
07:22:47 <EvanR> serialization typically cant fail
07:22:49 <badmash> appreciate any help
07:22:55 <EvanR> so whats the point
07:23:22 <SX> EvanR: I need to catch user exceptions and send them to client
07:23:33 <EvanR> what user exceptions
07:23:36 <SX> EvanR: it's for RPC
07:24:06 <bergmark> badmash: -fwarn-incomplete-patterns -fwarn-incomplete-uni-patterns?
07:24:10 <SX> EvanR: errors from calls for server methods
07:24:39 <EvanR> make type(s) for all those errors
07:24:45 <EvanR> doesnt need to be a hierarchy
07:24:57 <badmash> bergmark: i want to run all warns that come with -Wall option and use -Werror to error out if any warnings arise
07:25:22 <badmash> bergmark: how can this be done?
07:25:24 <EvanR> and sounds like it doesnt need to be exceptions
07:25:37 <bergmark> badmash: -Wall -Werror, but you seem to be asking two different things then
07:25:37 <Lokathor> Cale, https://github.com/Strifepad/strifeserver/commit/fb006364f8092f5a0e510f9b265f8b3018bb492a something in this update here is what stopped it working
07:25:48 <badmash> bergmark: i see
07:26:16 <badmash> bergmark: yeah, i am a little confused by the behavior of -Werror
07:27:07 <badmash> bergmark: is there a way to generate all warnings and not let ghc compile the code at all?
07:27:36 <SX> Well, yes, it could be just a set of data types (indefinite) with IsRpcError typeclass. Then just require all user functions to be Either SomeRpcError a
07:27:37 <badmash> bergmark: i mean, not generate compiled code if there are any warnings
07:27:52 <EvanR> SX: huh
07:28:25 <bergmark> badmash: what do you mean by "all warnings"? Certain warnings are not part of -Wall because they are too opinionated, but any warning that triggers will turn into an error with -Werror
07:28:27 <xnil> why does cabal-update take up so much disk space? i just want to install cabal-sandbox, is there any way to do that without updating ALL the other packages, but only the ones cabal-sandbox depends on?
07:28:51 <EvanR> SX: which sides of the RPC are you writing, what side is called "user" side, who is the user, and what is doing serialization
07:28:59 <badmash> bergmark: *all warnings* => warnings generated by -Wall
07:29:12 <christiann> Can someone explain, what this @ means?  evalStmt env s@(While _ _) = evalStmt env (unfoldWhile s)
07:29:44 <SX> EvanR: Server side. User of library. Server is doing serialization
07:29:56 <EvanR> so the user is writing server code
07:30:04 <bergmark> badmash: do you have an example of a warning generated with -Wall that doesn't error out with -Werror?
07:30:18 <EvanR> the user will be implementing an rpc server
07:30:18 <SX> EvanR: it receives request, calls user function, serializes error or result and sends response
07:30:19 <geekosaur> christiann, it lets you match a pattern while naming the whole pattern. ("as-pattern")
07:30:43 <xnil> christiann: 
07:30:49 <vkt> haskell
07:31:02 <EvanR> SX: alright then. so you dont know what the errors will be, so you should parameterize it
07:31:13 <xnil> s@(While _ _) means "bind the whole of whatever matches (While _ _) pattern to the name 's'"
07:31:35 * hackagebot pinchot 0.8.0.0 - Build parsers and ASTs for context-free grammars  https://hackage.haskell.org/package/pinchot-0.8.0.0 (OmariNorman)
07:31:38 <christiann> Okay, thanks :)
07:31:48 <SX> EvanR: yes. MsgPack RPC spec doesn't tell anything about errors. So it should be serializable to msgpack, that's all
07:32:13 <EvanR> is that just a string, or what
07:32:16 <EvanR> or is it like json
07:32:18 <xnil> no problem. feel free to ask if you have any more questions!
07:32:39 <ahihi> bergmark: non-exhaustive pattern match warnings, apparently
07:32:49 <ahihi> just tried myself and it appears this is indeed the case
07:32:50 <ahihi> seems like a bug
07:33:07 <xnil> why does cabal-update take up so much disk space? i just want to install cabal-sandbox, is there any way to do that without updating ALL the other packages, but only the ones cabal-sandbox depends on?
07:33:09 <EvanR> if some MsgPark datastructure is expected make that the error type
07:33:22 <EvanR> let the user construct it how they want
07:34:21 <SX> EvanR: hmm, then user should catch all IO exceptions, handle them and serialize an error the way he wants, right?
07:34:41 <SX> Then the type would be Either Object a
07:34:55 <EvanR> IO exceptions from stuff they do with IO you have no idea about?
07:35:03 <bergmark> ahihi: worksforme
07:35:31 <ahihi> bergmark: which ghc version?
07:35:40 <EvanR> no, constructing an Object is not serialization
07:36:30 <badmash> sorry got disconnected
07:36:45 <SX> EvanR: well, yes, it's not, but this Object type is serializable for sure. It's MsgPack Object type.
07:36:46 <bergmark> ahihi: 7.8 and 7.10
07:37:06 <EvanR> they should catch IO errors that they think makes sense, and convert them to error data to satisfy the library
07:37:20 <EvanR> SX: fine but creating an Object shouldnt be thought of as serialization
07:37:46 <badmash> bergmark: when i run ghc -Wall, it does generate warnings (including incomplete patterns), but it also produces an executable
07:38:37 <badmash> bergmark: i actually don't want ghc to generate an executable if any warnings arise in -Wall.  how can this be done?
07:38:39 <EvanR> SX: IO (Either Object a) is going to be better with EitherT, or really a more specific monad made for this RPC server
07:38:54 <EvanR> one that can error out on command
07:38:54 <ahihi> badmash: did you run -Wall -Werror immediately after -Wall?
07:39:07 <badmash> ahihi: yes
07:39:09 <ahihi> because in that case, ghc will just skip compilation
07:39:21 <ahihi> unless you change the file in between
07:39:36 <badmash> ahihi: it skips compilation, but doesn't catch incomplete patterns
07:39:47 <SX> EvanR: I don't know if I really need something more than EitherT. User's code should never access server's data. It's passive.
07:39:54 <christiann> I have problems with a task about an own data structure and work with it. Would someone maybe help me a bit with it?
07:40:03 <EvanR> SX: heh, you want it to do IO
07:40:08 <christiann> Sitting for 4 Hours on it now and dont get it :/
07:40:12 <EvanR> so it can technically do anything
07:40:13 <ahihi> badmash: yeah, because it doesn't do any work at all, since the source has already been compiled
07:40:25 <ahihi> try modifying the file and doing -Wall -Werror
07:40:32 <badmash> ahihi: so how can this be done?
07:40:58 <ahihi> use -Wall -Werror from the start :)
07:41:24 <SX> EvanR: I don't have a choice here, It's just RPC. Server methods could be anything.
07:41:28 <badmash> ahihi: i have done that, yet ghc doesn't generate a warning about incomplete patterns
07:42:22 <badmash> anyone out there can help?
07:42:36 <EvanR> SX: a monad which lets the user instantly crash and smoothly return an error would be cool
07:42:41 <ahihi> works for me on 7.10
07:42:51 <badmash> i use 7.8.3
07:43:09 <EvanR> :t throw
07:43:10 <lambdabot> Exception e => e -> a
07:43:13 <badmash> ahihi: does it warn about incomplete patterns as well?
07:43:19 <EvanR> :t throwM
07:43:21 <lambdabot>     Not in scope: ‘throwM’
07:43:21 <lambdabot>     Perhaps you meant one of these:
07:43:21 <lambdabot>       ‘throw’ (imported from Control.Exception),
07:43:59 <SX> EvanR: I actually use MonadThrow m, MonadIO m instead of plain IO
07:44:13 <EvanR> alright then
07:44:58 <ahihi> badmash, http://sprunge.us/iUMC
07:45:03 <EvanR> you have to use exceptions then
07:45:54 <EvanR> even though the error value can only be one type
07:46:01 <EvanR> so
07:46:06 <jarandaf> :t viewClosure
07:46:07 <lambdabot> Not in scope: ‘viewClosure’
07:46:20 <badmash> ahihi: it works because you have only 1 warning
07:46:37 <EvanR> SX: theres also
07:46:53 <EvanR> throwError :: MonadError e m => e -> m a
07:46:54 <badmash> ahihi: see if you have a whole host of warnings whether it catches incomplete patterns
07:47:05 <ahihi> badmash: do you have an example?
07:47:53 <EvanR> you could set e to be Object, but this class comes with a catch which is kind of off topic
07:48:46 <ahihi> badmash: never mind, I see now
07:48:47 <EvanR> SX: for a more targeted interface youd expose throw :: Object -> MyMonad a
07:49:22 <kurt11> How do I convert a Real to a Double? How would I search for such a function without asking irc
07:49:33 <EvanR> :t readToFrac
07:49:35 <lambdabot>     Not in scope: ‘readToFrac’
07:49:35 <lambdabot>     Perhaps you meant ‘realToFrac’ (imported from Prelude)
07:49:37 <EvanR> :t realToFrac
07:49:38 <lambdabot> (Fractional b, Real a) => a -> b
07:50:03 <EvanR> @hoogle (Fractional b, Real a) => a -> b
07:50:06 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
07:50:06 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:50:06 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:50:07 <kurt11> I want a double, not a Fractional
07:50:16 <EvanR> Double is Fractional
07:50:20 <Dr4ke63> Hello everybody
07:50:24 <frerich> kurt11: You can search for e.g. 'Real a => a -> Double' on Hoogle or Hayoo to find this kind of information.
07:50:58 <EvanR> kurt11: Real and Fractional arent types, but classes
07:51:04 <SX> EvanR: MonadExcept then? 
07:51:24 <EvanR> realToFrac is generic, returns whatever Fractional you want
07:51:45 <kurt11> EvanR: thank you. I knew Fractional was a class, not a direct type. I guess that is all I need
07:52:27 <EvanR> SX: dunno if that exists
07:52:48 <EvanR> MyMonad can be constructed however you want behind the scenes
07:53:02 <EvanR> the imporant part is what you expose
07:53:25 <SX> EvanR: Monad.Except, i mean
07:53:27 <ahihi> badmash: I'd guess that warnings are promoted to errors per compilation stage, so if one stage errors, the next one is never reached
07:53:32 * frerich just learned that Marvin Minsky passed away two days ago :-(
07:53:49 <ahihi> but I don't know enough about ghc internals to say for sure
07:53:53 <EvanR> SX: huh
07:54:20 <SX> EvanR: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
07:54:35 <EvanR> exactly what in here are you referring to
07:55:00 <EvanR> ExceptT?
07:55:06 <SX> Yup
07:55:56 <EvanR> that adds MonadError e m methods 
07:56:08 <EvanR> throwError...  ok
07:56:16 <EvanR> also catchError
07:56:41 <EvanR> seems like it would work
07:56:46 <badmash> ahihi: see http://lpaste.net/150927
07:58:08 <badmash> ahihi: try compiling the code i pasted ... i get all kinds of warnings except the warning for incomplete pattern
07:58:42 <ahihi> badmash: yes, see my comments above
07:59:40 <badmash> ahihi: i saw, but the incomplete pattern is right at the top and it still doesn't catch
07:59:58 <badmash> ahihi: anyway, thanks for your help
08:00:08 <SX> EvanR: anyway, MonadError is a good option imo. Thanks for your help!
08:00:47 <ahihi> badmash: #ghc might be able to tell you whether the behavior you want is possible
08:01:13 <EvanR> SX: not to disagree, just through id throw a monkey wrench for giggles
08:01:15 <EvanR> https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices
08:01:22 <EvanR> your plan is officially an anti-pattern ;)
08:01:31 <EvanR> (but makes sense to me nonetheless)
08:01:44 <OverCoder> Say I have [[1],[2],[3,4],[5,6]], how do I unpack those inner lists so it becomes [1,2,3,4,5,6]
08:02:06 <exio4> with concat
08:02:14 <exio4> > concat [[1], [2], [3,4], [5,6]] 
08:02:17 <lambdabot>  [1,2,3,4,5,6]
08:02:59 <SX> EvanR: Well, I could use MonadError directly with Object as error type..
08:03:30 <EvanR> whichever way you do it, the blog post says its wrong
08:03:43 <OverCoder> ay um, idk I think I got disconnected any my message wasn't received
08:03:49 <EvanR> because its ExceptT wrapping IO
08:03:51 <OverCoder> I was saying: Say I have [[1],[2],[3,4],[5,6]], how do I unpack those inner lists so it becomes [1,2,3,4,5,6]
08:04:18 <athan> OverCoder: Check out `concat`!
08:04:22 <athan> :t concat
08:04:24 <lambdabot> Foldable t => t [a] -> [a]
08:04:31 * OverCoder tries it
08:04:42 <athan> :t join :: [[a]] -> [a]
08:04:44 <lambdabot> [[a]] -> [a]
08:04:44 <OverCoder> yup, awesome, thanks
08:04:49 <athan> :)
08:05:00 <SX> EvanR: I need to handle IO exceptions anyway. msgpack-rpc spec requires server to send Response regardless of situation, so I need to report ANY error..
08:05:27 <SX> So yeah, that would be either Exception or Exception + MyErrorType..
08:05:53 <EvanR> catching any error sounds bad
08:08:09 <SX> EvanR: but I really need to. Or server would crash, which I really don't need.
08:08:59 <EvanR> thats the users fault
08:10:58 <EvanR> SX: https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions ;)
08:11:09 <xnil> OverCoder: hi! learning haskell?
08:11:54 <OverCoder> xnil, ooh, you're here? didn't notice :D, but yeah
08:11:54 <xnil> why does cabal-update take up so much disk space? i just want to install cabal-sandbox, is there any way to do that without updating ALL the other packages, but only the ones cabal-sandbox depends on?
08:12:01 <mrlase> What might be wrong with the signature for calculateBalance? https://gist.github.com/acrognale/31c2b23fd9aeff0f30f6 I'm using Database.Persist.TH for Transaction in this case
08:12:02 <OverCoder> I've juuuuuust done my first homework :>
08:12:04 <xnil> i apologize for asking repeatedly but nobody is responding to my question
08:12:19 <mrlase> I'm trying to foldr over all [Transaction] and calculate inflow - outflow for each, sum together
08:12:22 <xnil> OverCoder: your school uses haskell?
08:12:50 <OverCoder> xnil, um, so much disk space? cabal update doesn't seem to take anything on my pc :o
08:13:04 <xnil> i have very limited disk space to work with here
08:13:24 <xnil> Is there any Haskell98 implementation that is currently maintained? Hugs98 is not an option as it's dead.
08:14:00 <EvanR> SX: i was actually about to suggest what this article suggests, run the request in a worker thread. which would also improve concurrency
08:15:26 <merijn> xnil: UHC?
08:15:58 <merijn> http://foswiki.cs.uu.nl/foswiki/UHC
08:16:07 <xnil> thanks, merijn.
08:16:09 <fractalsea> Is there a way I can hoist functiors over QuickCheck `Property`s to work in `PropertyM`. I’m specifically wanthing to use `(===)`
08:18:38 <SX> EvanR: well, all of those articles suggest to use Exceptions
08:18:42 <xnil> where does cabal-update store everything
08:19:26 <SX> EvanR: then it's once again a Exception vs. Either MyError
08:22:59 <nitrix> That moment when the network doesn't work at your company and you have 4k people working on their side projects.
08:23:06 <nitrix> The day just turned into a giant hack-a-thon.
08:23:32 <xnil> nitrix: beautiful
08:23:40 <xnil> but the better question is
08:23:45 <xnil> why isn't the network running on haskell?
08:24:08 <OverCoder> xnil, lolno what school
08:24:23 <xnil> "homework"
08:24:36 <OverCoder> xnil, our school barely teaches us anything, and about computer? well nothing
08:24:50 <OverCoder> You can easily predict what a syrian war school like
08:24:52 <OverCoder> bbl anyways
08:30:10 <xnil> why is my cabal-install not installing cabal-sandbox? i've run cabal-update
08:30:14 <xnil> i can install other packages
08:30:20 <xnil> it can't find cabal-sandbox at all.
08:31:13 <monochrom> is there even such a package? visit http://hackage.haskell.org/package/cabal-sandbox to find out
08:31:19 <xnil> w0w
08:31:26 <glguy> xnil: Do you mean "cabal sandbox"?
08:31:29 <xnil> yes
08:31:31 <glguy> cabal command with sandbox argument
08:31:56 <nitrix> xnil: cabal isn't built as many executable composably like git. "sandbox" is an argument.
08:32:11 <xnil> i'll try to update cabal
08:32:25 <xnil> let's see where that gets us.
08:32:55 <geekosaur> upgrade cabal-install. "hash -r" in your shell so it will look for the newly installed one instead of continuing to use the one it knows about
08:33:01 <nitrix> Sandbox wasn't in the earlier versions. If you're using ubuntu, that could be why.
08:33:01 <monochrom> do you need a "new" version? cabal-install has had sandboxing for years
08:33:18 <nitrix> monochrom: Yeah but ubuntu and some others are years behind...
08:33:20 <geekosaur> make sure $HOME/.cabal/bin is before /usr/bin etc. in $PATH
08:33:39 <geekosaur> yeh, debian-oldtable/ubuntu/mint still ship ancient cabal-install
08:33:46 <geekosaur> *oldstable
08:33:52 <geekosaur> duno about newstable
08:35:25 <xnil> nitrix: i'm forced to use ubuntu.
08:35:43 <xnil> thanks for the help guys
08:35:51 <nitrix> It's fine. Some people are masochists.
08:35:52 <xnil> <3
08:36:00 <xnil> ubuntists particularly
08:36:07 <xnil> if it were up to me i would use nothing but freebsd ever
08:36:16 <nitrix> Anyway it's not really the topic.
08:36:23 <nitrix> Does it works now?
08:36:36 <geekosaur> every OS/distro spends some amount of time with a paper bag over its head...
08:36:50 <monochrom> choice of linux distro still does not imply choice of ghc and cabal-install. you don't have to "apt-get install ghc"
08:37:16 <nitrix> I personally updated cabal enough until it could install stack.
08:37:17 <monochrom> in particular I use ubuntu too but I still enjoy ghc 7.10.3
08:37:18 <xnil> monochrom: on this system i did
08:37:21 <nitrix> Then all the problems went away.
08:37:23 <xnil> they come pre-built.
08:37:30 <xnil> nitrix: yup it does
08:38:15 <geekosaur> xnil, https://launchpad.net/~hvr/+archive/ubuntu/ghc/
08:38:30 <xnil> no
09:04:20 <Strukks> can someone explain "foldr" with 2 arguments to me? Like "foldr (\x y -> (x+y)/2) 1 [2,3,4])"
09:04:50 <Strukks> I don't understand what goes to x and y 
09:05:31 <Freundlich> Strukks: One of these is "the current value" while the other is the "current list element". Can't remember which one is which though. It should be obvious from the type signature, however.
09:06:10 <Freundlich> :t foldr
09:06:12 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:06:15 <schell> Strukks: with foldl the accumulator is on the left, with foldr the accumulator is on the right
09:06:19 <Strukks> I've tried adding it up in my head 10 different ways, but the interpreter solution is always different
09:07:09 <Freundlich> Strukks: + is commutative, so it doesn't even matter in your case.
09:07:16 <schell> :t (foldl, foldr)
09:07:18 <lambdabot> (Foldable t, Foldable t1) => ((b -> a -> b) -> b -> t a -> b, (a1 -> b1 -> b1) -> b1 -> t1 a1 -> b1)
09:07:43 <Strukks> Freundlich: it gives me a different answer for those same arguments with foldl
09:08:01 <Strukks> > foldr (\x y -> (x+y)/2) 1 [2,3,4]
09:08:03 <lambdabot>  2.375
09:08:08 <Strukks> > foldl (\x y -> (x+y)/2) 1 [2,3,4]
09:08:10 <lambdabot>  3.125
09:08:54 <Strukks> If someone could just tell me the equations it does with "1 [2,3,4]" to reach 2.375 or 3.125 I could get it from there
09:09:00 <andromeda-galaxy> Does anyone know of a (semi)-standardized Unicode/LaTeX/lhs2TeX symbol for fmap's <$> synonym?  \circledast seems to be good for Applicative (It looks like the Data.Applicative.Unicode), but there doesn't seem to be a Data.Functor.Unicode...
09:09:36 <schell> Strukks: the equation it’s running is the one you’re giving (the first parameter)
09:10:01 <Strukks> schell: what?
09:10:28 <Freundlich> Strukks: I didn't mean to say that the order doesn't matter for the computation. It doesn't matter for the types.
09:11:00 <monochrom> > foldr f z [a, b, c]
09:11:03 <lambdabot>  f a (f b (f c z))
09:11:12 <monochrom> Strukks: the above should get you started
09:11:24 <Strukks> Can someone tell me as like (2+3)/2= 2,5 (2,5+4)/2=.. .... = 2.375?
09:12:00 <makalu> "stack build --enable-executable-profiling --enable-library-profiling" takes A LOT of time, even on the second invocation. Is it supposed to be really slow?
09:12:18 <tremon> Strukks: try replacing foldl with scanl to see its progression
09:12:33 <liste> > foldl (\x y -> (x+y)/2) x [y,z]
09:12:35 <lambdabot>  ((x + y) / 2 + z) / 2
09:12:41 <liste> > foldr (\x y -> (x+y)/2) x [y,z]
09:12:43 <lambdabot>  (y + (z + x) / 2) / 2
09:12:50 <schell> tremon: that’s a good tip
09:13:21 <schell> > scanl (\x y -> (x+y)/2) 1 [2,3,4]
09:13:23 <lambdabot>  [1.0,1.5,2.25,3.125]
09:13:46 <schell> > scanr (\x y -> (x+y)/2) 1 [2,3,4]
09:13:49 <Strukks> tremon: I think this will help me crack it
09:13:50 <lambdabot>  [2.375,2.75,2.5,1.0]
09:15:27 <Strukks> Ok, I still don't get it, ehh
09:15:55 <tremon> foldr works the list in reverse order. 2.5 = (4 + 1)/2
09:17:08 <schell> Strukks: since 1 is a small number, in the case of foldr it reduces the result of the biggest number in your list, and then accumulates that toward the other smaller numbers
09:17:39 <schell> in the case of foldl the accumulator grows until reaching the last element
09:17:40 <Strukks> tremon: now I get it
09:17:56 <Ygg> I use debian stable and I can use sandboxes.
09:17:58 <Strukks> that's what I've been asking the entire time, just what numbers go where, now I'm good
09:18:06 <schell> ahhh
09:18:07 <Ygg> by default
09:18:31 <Ygg> ./join haskell-fr
09:19:07 <Ygg> ... bash habit
09:33:25 <makalu> what's a CAF (as in -fprof-cafs)?
09:33:42 <johnw> "constant applicative form"
09:33:50 <geekosaur> "constant applicative form" aka a "function" without parameters
09:33:50 <johnw> ?
09:33:53 <johnw> https://wiki.haskell.org/Constant_applicative_form
09:34:14 <geekosaur> (roughly)
09:34:42 <makalu> thank you
09:37:36 <RandomFriendlyGu> Wow this chat is so dead.
09:37:52 <RandomFriendlyGu> I won't even bother spamming and flooding this place.
09:38:02 <bitemyapp> shapr: if you have feedback, we need more context than that.
09:38:15 <bitemyapp> shapr: please email us if you have something http://haskellbook.com/support.html
09:38:49 <bitemyapp> shapr: yes our higher kinded types material is split, this is intentional, but you may have noticed an unintentional overlap. It will take us less time if you send us the passage(s) you believe overlap.
09:40:58 <quchen> I've got a small function `:: (a -> Maybe a) -> a -> a` which repeatedly applies a function to a value, and stops if there's a `Nothing`. Stuff like this is often worker/wrapper transformed to get better sharing, but is it a good idea to do this in general? Looking at the core I don't see much difference, apart from an additional allocation for the `go` value. http://lpaste.net/150939
09:42:09 <quchen> The lack of a difference is due to the example of course, but is there a general rule that tells me whether or not to put stuff into its own sub-definition?
09:42:25 <quchen> (Hm, worker/wrapper might not have been accurate. Float into a 'where' block is what I meant.)
09:42:40 <srhb> How does unfoldr do it?
09:43:22 <quchen> srhb: fold/build fusion around a `go` wrapper
09:43:30 <quchen> http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.OldList.html#unfoldr
09:44:39 <srhb> Hm.
09:44:47 <mjhoy> what's the relationship between regex-compat and regex-posix?
09:45:38 <Wizek> Hello, Can `stack` support compiling a project with two different compilers one after the other? Both ghc and ghcjs. I f
09:46:39 * hackagebot gitHUD 1.3.1 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.3.1 (gbataille)
09:46:46 <Wizek> Or is the best way to have two stack files -- one for ghc and one for ghcjs?
09:47:17 <luigy> there is a compiler flag you can pass to stack that would override it from the stack yaml
09:49:27 <Wizek> I've managed to make both compilers compile by commenting these lines https://github.com/Wizek/Yesod-And-GHCJS-Example/blob/master/stack.yaml#L20-L21
09:49:52 <Wizek> luigy, so you'd do it something like this: `stack build && stack build --compiler ghcjs-0.2.0.20151001_ghc-7.10.2` ?
09:51:19 <felixsch> What xml libray would you recommend (need to parse 200mb big xml files)? hexpat?
09:55:41 <srhb> Depends how they look and how you want to parse them.
09:55:49 <balor> I can't install yesod-auth or happstack-server using cabal (I have `cabal install cabal-install`) on Fedora 23. Many other things install fine. Is anyone else having build failures on Linux? i.e. is it my problem?
09:55:59 <balor> d'oh...double post...sorry
09:59:19 <crough> it's been all right for me... what are the errors? 
09:59:21 <srhb> balor: More details will probably be helpful to people that know about those libraries.
09:59:32 <srhb> balor: You could lpaste.net your build failure, for starters.
10:00:23 <balor> crough, Probably my issue then.
10:00:33 <balor> srhb, http://lpaste.net/150940 is one of the errors
10:01:06 <balor> Not something I'd expect from cabal & looks like an issue in Warp, so I was wondering if others were having errors.
10:01:30 <bergmark> balor: you struck some combination of versions that are incompatible
10:01:35 <srhb> balor: More context needed. It's probably some mutually exclusive versions.
10:01:51 <srhb> balor: Especially the constraints solver at the top might help.
10:03:44 <bergmark> i'm trying to build the latest version of them together in a clean sandbox
10:06:48 <balor> bergmark, They fail for me individually.  Which is why I tried both..am currently happy to go with the first one that builds ;P
10:07:34 <crough> balor: pinning to an LTS may help
10:07:48 <balor> crough, that's the stackage route right?
10:12:33 <crough> yup
10:12:51 <crough> they're basically guarenteed to work together... else you can pin your packages to more compatible versions
10:13:00 * joeyh stares at this code: mapM foo <$> ioaction
10:13:27 <joeyh> that really wanted to be mapM foo =<< ioaction.. instead, I got back a list with one mempty in it
10:13:30 <joeyh> urgh!
10:14:48 <mnoonan> does anybody know of a library for reading PDB debug information on Windows? The DWARF story looks good for elf and coff/pe, but I haven't found a coff+pdb solution yet.
10:15:28 <joeyh> AMP :/
10:15:38 <bitemyapp> crough: hi
10:15:40 <bitemyapp> joeyh: :(
10:16:00 <crough> bitemyapp: heyo!
10:16:11 <bitemyapp> joeyh: that was FTP tho right?
10:16:16 <bitemyapp> crough: how you doing?
10:16:30 <joeyh> yeah, FTP right
10:16:40 * hackagebot pandoc-crossref 0.1.6.5 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.6.5 (lierdakil)
10:16:56 <bergmark> balor: i'd guess that passing --constraint='wai==3.2.*' --constraint='warp==3.2.*' will solve the build error you posted
10:17:13 <joeyh> so, that's my first bug that FTP caused that's so bad I have to immediately spin a release for it.
10:17:32 <joeyh> well, "FTP caused" meaning I made some changes pretty late at night and didn't notice of course
10:17:34 <bitemyapp> joeyh: :(
10:17:34 <bergmark> both happstack-server and yesod-auth build with the latest version of all packages, so the problem must be because of pre-installed older versions
10:17:47 <balor> bergmark, thanks
10:20:34 <felixsch> srhb: What do you mean by how the files look?
10:22:48 <felixsch> srhb: Because of the size of the files and that I only need a few informations out of it I tought sax style parser would do it
10:24:29 <f00f00> hi
10:24:42 <f00f00> how do I install a source package directly from Github?
10:24:47 <f00f00> i.e. without going through cabal?
10:25:13 <dcoutts> f00f00: do a git clone, cd the package dir, and cabal install ./
10:25:21 <statusfailed> Using trifecta's buildExpressionParser, why does this give "ambiguous parse": "(1 + 2 *-3)" but this doesn't: "(1 + 2 * -3)" ?
10:25:33 <f00f00> dcoutts: thanks!
10:25:40 <statusfailed> using pretty much the same example as in the docs: https://hackage.haskell.org/package/trifecta-0.46/docs/Text-Trifecta-Parser-Expr.html except without the ++ postfix and + prefix operators
10:25:43 <kadoban> f00f00: You can directly specify them as dependencies using 'stack' instead of cabal-install, if you just want to use it in another project.
10:25:57 <statusfailed> is that a bug, or did I fail to understand parsing again? :-)
10:27:48 <dcoutts> f00f00, kadoban: I think some people think it's better practice to make such deps git submodules. In which case they're available as local dirs, and then that'll work fine with both stack and with cabal sandboxes.
10:29:33 <geekosaur> statusfailed, it sounds like it's using the rules that Haskell does: any sequence of operator characters is a distinct operator
10:29:50 <geekosaur> so `2 *-3` is the operator (*-) applied to 2 and 3
10:29:53 <statusfailed> Ah I see
10:30:03 <geekosaur> Parsec's expression parer also does this but there's a knob to turn it off
10:30:36 <balor> Thanks all, this stack thing seems to work :)
10:31:09 <statusfailed> geekosaur: I shall have a poke around in the docs to see if I can find a similarly-shaped knob
10:31:14 <kadoban> dcoutts: submodules tend to be pretty easily misunderstood and they annoy a lot of people, I'm not sure I'd do that in general. Is that really going to work well with cabal-install anyway? Wouldn't you still have to tell people how to manually go through and install the thing as a dependency?
10:32:46 <dcoutts> kadoban: well that's what sandboxes do, and it's what the new cabal nix-local-build branch does by default (picks up other local packages)
10:33:07 <geekosaur> I dont see one in that module, at least. parsec uses a LanguageDef record with a bunch of tunable values, not just an operator table
10:33:11 <dcoutts> kadoban: I have no strong opinion on git submodules, I'm just repeating what people tell me
10:33:43 <statusfailed> geekosaur: I think I linked to an old version of the docs actually
10:34:03 <dcoutts> kadoban: and the point is you'd check in to the top repo a thing to say "use these deps in these local dirs", which are the sub-modules
10:34:03 <osa1> this is not valid Haskell, right? \x -> | guard1 -> ... | guard2 -> ...    
10:34:23 <geekosaur> not currently, it's been suggested as a future extension
10:34:37 <geekosaur> well, without the first ->
10:34:43 <dcoutts> kadoban: anyway, it's ok either way, cabal nix-local-build branch will also support specifying git repos, for people who prefer that workflow
10:35:02 <osa1> got it
10:35:06 <statusfailed> geekosaur: I think this might be it: https://hackage.haskell.org/package/parsers-0.12.3/docs/Text-Parser-Token-Style.html (at the bottom)
10:35:07 <geekosaur> I don't think you can currently use guards with lambdas at all? because that's part of multiple pattern support iirc
10:35:21 <dcoutts> kadoban: I guess the submodule approach will work better when you're editing those submodules often, rather than just taking a static snapshot of someone else's repo
10:36:22 <geekosaur> sounds like it, yes. would like mroe documentation there but oh well
10:36:23 <kadoban> dcoutts: Yes, in that case I'd use git subtree (I've done this before and it works pretty well).
10:36:41 <dcoutts> kadoban: subtree vs submodule?
10:36:49 * dcoutts is not a git expert at all
10:37:34 <kadoban> dcoutts: They work pretty differently, it's hard to say one is better or worse than the other, but I like subtree more. It's conceptually much easier for people who use my repo, I think (it's just … stuff in the repo, they don't have to do submodule commands themselves).
10:37:54 <geekosaur> maybesomeone can figure out how to phrase good documentation in terms of lenses and then it'll be documented better >.>
10:38:11 <dcoutts> kadoban: ok, interesting I'd not heard of subtrees. I've certainly found submodules annoying, the way they don't update automatically on pull etc.
10:39:16 <greymalkin> Copilot question: What is the purpose of the 'context' variable in externW8, etc?
10:40:26 <kadoban> dcoutts: Yeah it definitely avoids that. I used to use submodules a decent amount any time I released anything using it, the *only* questions I'd get were related to the submodules :-/ It has its own small drawbacks though, and it's a bit harder to find information on comparatively.
10:41:32 <dcoutts> kadoban: interesting, thanks
10:53:25 <chasm> confused about arrays: http://lpaste.net/150943 - what type signatures do I need to make this work? thanks!
10:54:17 <glguy> > listArray (0,4) "hello" :: Array Int Char
10:54:19 <lambdabot>  array (0,4) [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
10:54:26 <glguy> The problem is that it doesn't know what the index type should be
10:54:32 <Cale> chasm: Try specifying the type of '3'
10:54:45 <Cale> hello ! (3 :: Integer)
10:54:48 <Cale> perhaps
10:54:55 <jrobie> what do you call a function created as a result of partial function application?  is there a term for that kind of function?
10:55:40 <Cale> jrobie: A partial application?
10:56:07 <Cale> jrobie: Usually just "a function" :)
10:56:10 <johnw> jrobie: well, it's a closure, since it lexically bound the partially applied argument
10:56:21 <Cale> It may be implemented by a closure
10:56:21 <johnw> actually, scratch that
10:56:28 <johnw> that's just an argument, so it's really just a function
10:56:39 <johnw> depends on how you model it
10:56:41 <jrobie> we've added this feature to xquery
10:56:41 <clintm> Do any of you happen to know if you can make stack use a local version of the metadata for the setup command?  I submitted a PR for it but I feel really weird submitting a PR that I haven't tested.  I asked in #haskell-stack, but I thought maybe someone here might know as well.
10:56:46 <Cale> It's dangerous to talk about closures at this level.
10:56:52 <johnw> Cale: agreed, I retract
10:56:53 <jrobie> currently, we call the process of creating one of these things "partial function application"
10:56:53 <Cale> Because they're really an implementation detail
10:57:09 <jrobie> and i need a term to describe that kind of function
10:57:39 <Cale> jrobie: You could say "a partially applied function", or "a partial application"
10:57:42 <jrobie> in xquery, i need to distinguish that kind of function from others because they are evaluated slightly differently
10:57:53 <jrobie> a partially applied function seems very clear, thanks
10:58:44 <fsochade> I'm a programming novice, and know HTML, CSS, JS, some Java/C#, and very little C. I know the answer will be biased, but should I give Haskell a go?
10:59:07 <Bor0> I think the answers given to you will be that you're probably the best candidate for Haskell
10:59:19 <fsochade> Bor0, really?
10:59:21 <cocreature> fsochade: sure learning new things widens your horizon which is a good thing
10:59:39 <chasm> glguy: thx yes it needed an array type constraint - (Array Int Char) works
10:59:44 <Bor0> fsochade, yes. there was this saying that knowing OOP to much can make a little harder to learn Haskell :)
11:00:08 <syncopy> yes, you should certainly try it. 
11:00:43 <fsochade> OOP in Java seems really unnecessary to me, especially in the class I'm taking. It seems like there's a lot of extra stuff that could be done away with.
11:00:49 <fsochade> Where should I get started?
11:01:02 <Bor0> ,lyah
11:01:08 <Bor0> oh, what was that command
11:01:14 <Ankhers> @learnhaskell
11:01:15 <lambdabot> Unknown command, try @list
11:01:19 <Bor0> @lyah
11:01:19 <lambdabot> Unknown command, try @list
11:01:21 <Ankhers> @where learnhaskell
11:01:22 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:01:50 <fsochade> So, in like a sentence or so, what do you all like about Haskell?
11:01:53 <marchelzo> fsochade: Java got OOP wrong
11:02:31 <Ankhers> I'm using Java right now for an android app... It isn't fun.
11:02:41 <Bor0> composability, the type system and the options it gives you to abstract things, lambda calculus
11:03:35 <joeyh> bitemyapp: huh, that's not really caused by FTP at all.
11:03:36 <marchelzo> Haskell is like the antithesis of C when it comes to abstraction mechanisms.
11:04:11 <Bor0> then there's laziness,... I think you should go through the book, it's really entertaining http://learnyouahaskell.com/
11:04:14 <fsochade> Okay, cool. I'm installing GHC right now.
11:05:32 <joeyh> just the monad instance for lists
11:05:49 <fsochade> The school wifi is just atrocious, so I'll have to download it at home.
11:05:53 <clintm> Resisting the urge to link Wadler's Propositions as Types talk.  That might scare fsochade away heh.
11:06:00 <fsochade> I'm excited, though. This looks fun.
11:07:26 <fsochade> Is there a package I can install from my distro repo? I'm running Kali 2.0
11:08:05 <cocreature> fsochade: you might want to let stack manage your ghc installations http://haskellstack.org/ it makes it significantly hander to break your installation
11:08:07 <marchelzo> haskell-stack if it's available
11:08:28 <marchelzo> not familiar with Kali's package respository
11:08:45 <fsochade> I'm installing haskell-stack now.
11:09:09 <fsochade> I can come here if I have any issues, though?
11:09:32 <cocreature> sure
11:09:39 <marchelzo> there's also #haskell-beginners
11:16:35 <JonReed> What would be a way to have type-safe list of strings at compile time without declaring a constructor for each of them. Something like, `type Theme = "themeName" | "otherThemeName" ` and a function like `toString :: Proxy Theme -> String`.
11:17:21 <JonReed>  I know it be done like "data Theme = ThemeName | SomeOtherTheme", but introducing unnecessary additional names does not look great 
11:18:30 <frerich> JonReed: You could generate something with Template Haskell. Or you do 'newtype Theme = Theme String' and then a smart constructor which only generates 'valid' Theme values.
11:18:40 <frerich> i.e. 'mkTheme :: String -> Maybe Theme'.
11:18:43 <bitemyapp> joeyh: just the Monad instance? You knocked your forehead on a weird one.
11:20:26 <JonReed> frerich: Hm, I was hoping there was some way to do it with dependent like types
11:21:52 <joeyh> yeah, mapM (++ "hi") []
11:22:25 <joeyh> aka return [] :: [String]
11:27:16 <crough> JonReed: `class StringRep a where stringRep :: Proxy a -> String ; data StringA; instance StringRepr StringA where stringRep Proxy = "http://someurl or other thing you want to store"`
11:28:02 <enthropy> JonReed: GHC.TypeLits has a Symbol kind
11:28:22 <enthropy> > symbolVal (Proxy :: Proxy "foobar")
11:28:24 <lambdabot>  Not in scope: ‘symbolVal’
11:28:52 <JonReed> enthropy: Yeah, I know. But the closest I've got to was this: http://lpaste.net/150947 
11:29:17 <JonReed> crough: Will try that out, thx
11:29:45 <crough> JonReed: you construct a proxy like this `Proxy :: Proxy ThemeOne`
11:29:57 <crough> JonReed: then you can use enthropy's suggestion
11:32:37 <enthropy> JonReed: I don't think you get a good error message for (Theme "something else"): as far as I know ghc doesn't complain that it can never be reduced
11:35:20 <enthropy> I think using a class gives you errors earlier. Or you can do something like https://mail.haskell.org/pipermail/haskell-cafe/2013-November/111549.html
11:38:27 <snhmib> where does cabal do its work? i get a compilation error when i do cabal install, but i have no idea where the source files are hiding?
11:39:03 <johnw> snhmib: does cabal install -v help?
11:40:29 <snhmib> oi in /tmp
11:40:53 <statusfailed> snhmib: stack is worth trying if you haven't already
11:40:54 <JonReed> enthropy: Thx again, your suggestion about how to use proxy worked. I'm still stuck trying to generalize `getThemeName` tried any type combination I could image and it did not compile. but `getNeoThemeName` works :O
11:41:07 <JonReed> enthropy: http://lpaste.net/150948 Here is what I ended up with
11:41:21 <snhmib> i haven't, what is it?
11:42:21 <kadoban> snhmib: An alternative to cabal which is much friendlier to use.
11:42:39 <snhmib> i just need to tell cabal to stop between unpacking and compiling so i can add the missing import >.<
11:42:56 <snhmib> i'll have a look at it
11:42:58 <dcoutts> snhmib: cabal unpack $pkgname; cd $pkgname; cabal install
11:42:59 <enthropy> JonReed: getThemeName :: (KnownSymbol th, th ~ Theme th) => Proxy th -> String -- or something like that
11:43:27 <snhmib> whoey cool dcoutts thanks :D
11:43:27 <dcoutts> snhmib: insert: "edit the offending file" step in between :-)
11:43:33 <snhmib> :)
11:44:10 <dcoutts> if you're already using a cabal sandbox, add that local src dir to the sandbox so it'll be used automatically
11:44:24 <JonReed> enthropy: O wow. I wouldn't have figured it out. It works.
11:45:13 <JonReed> enthropy: Would it be possible to get all theme names somehow without template haskell or it's impossible with this solution?
11:46:12 <enthropy> JonReed: you could start with type Theme1 = '["neo", "night"]
11:47:37 <enthropy> then have some Elem :: [Symbol] -> Symbol -> Symbol, so you could write "type Theme x = Elem Theme1 x" instead of your current definition
11:47:58 <enthropy> @src elem
11:47:58 <lambdabot> elem x = any (== x)
11:48:04 <codedmart> I have a aeson Value `String "text"` when I encode that I get "\"text\"". Why the extra \" and is there something in aeson to just get back "text" or do I need to handle that?
11:49:02 <geekosaur> codedmart, it sounds like you are using "show" on it
11:49:10 <geekosaur> > show "foo"
11:49:12 <lambdabot>  "\"foo\""
11:49:21 <geekosaur> > text "foo" -- this is a hack to avoid show
11:49:23 <lambdabot>  foo
11:49:38 <JonReed> enthropy: I initially started with that definition, but was confused about how to write `getThemeName` even more than in the last case.
11:49:50 <Strukks> What is "hSetEcho stdout False" supposed to do? Not display characters I enter?
11:50:10 <geekosaur> Strukks, yes
11:50:33 <codedmart> geekosaur I am just doing this `let v = toJSON "test" :: Value; encode v`
11:51:14 <geekosaur> then how do you know what it is? *something* is evidently printing the value to you
11:51:15 <Strukks> geekosaur, why does it not work in my gchi-7.10.3? http://lpaste.net/150949 I noticed it didn't work with other programs as well before
11:51:22 <synergistics> How can I check the type of a value I got from the read command?
11:51:32 <geekosaur> if that somethin is ghci, it will be invoking show on it unless you use putStrLn explicitly
11:51:43 * hackagebot git-annex 6.20160126 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160126 (JoeyHess)
11:52:20 <geekosaur> synergistics, you don't. you get the type that you specify or is inferred by how you use it. it is not "dynamic" in the sense that it gives you a String or an Int or etc. based on what it reads
11:52:32 <geekosaur> > read 5 :: Int
11:52:34 <lambdabot>      No instance for (Num String) arising from the literal ‘5’
11:52:35 <lambdabot>      In the first argument of ‘read’, namely ‘5’
11:52:35 <lambdabot>      In the expression: read 5 :: Int
11:52:41 <geekosaur> whoops, dh
11:52:45 <geekosaur> read "5" :: Int
11:52:49 <geekosaur> > read "5" :: Int
11:52:51 <lambdabot>  5
11:52:53 <geekosaur> doing good today :(
11:52:56 <geekosaur> > read "5" :: String
11:52:58 <lambdabot>  "*Exception: Prelude.read: no parse
11:53:11 <crough> haha wut
11:53:19 <geekosaur> it does not decide based on what "5" is there, it decides based on the requested type
11:53:30 <crough> right and the duality to show
11:53:31 <synergistics> geekosaur: So if I wanted to parse JSON, how would I decide how to parse data of a specific type if I won't know what that is ahead of time
11:53:39 <geekosaur> (Haskell, unlike many other languages has return type polymorphism)
11:53:50 <geekosaur> synergistics, that is why JSON wraps stuff in a Value
11:53:51 <crough> > read "\"5\"" :: String
11:53:54 <lambdabot>  "5"
11:54:19 <kasbah> is there an easy way to increase to upper bounds of all your dependencies in a package using cabal-install?
11:54:37 <kasbah> i.e. build with the latest versions and put that in the .cabal
11:54:46 <synergistics> geekosaur: I'll have to look up what that is, but I mean from reading in a .json file as a string and then converting it to a JSON datum I made
11:55:10 <geekosaur> presuming this is aeson, you generally pattern match on it
11:55:17 <kasbah> i found `cabal --allow-newer`
11:55:18 <dcoutts> kasbah: you can edit the .cabal file and remove all the upper bounds and re-run the solver
11:55:38 <geekosaur> case aValue of { String t -> ...; Number n -> ..; ... }
11:55:39 <dcoutts> kasbah: note that --allow-newer strips off the upper bound on all packages that use it, not just your local package
11:55:58 <kasbah> dcoutts: is there a way to put the current versions as the new upper bounds though?
11:55:59 <geekosaur> http://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson-Types.html#t:Value
11:56:34 <dcoutts> kasbah: not automatically, but if you strip them off, find out what the latest versions are that work by running the solver, and put those back on
11:56:44 <dcoutts> kasbah: cabal configure -v reports what versions it picked
11:56:59 <kasbah> ok, thanks very much dcoutts 
11:57:20 <dcoutts> kasbah: and use --upgrade-dependencies
11:57:21 <Strukks> Why doesn't "hSetEcho stdout False" work here?  http://lpaste.net/150949
11:57:43 <synergistics> geekosaur: Thanks for the help
11:57:53 <dcoutts> kasbah: ie do something like cabal install --only-dependencies --upgrade-dependencies [--dry-run]
11:57:57 <JonReed> enthropy: Hm, I don't get how to write an Elem. I assume something like `Elem :: [Symbol] -> Symbol -> Symbol; Elem x = any (== x)`? Does it need some language extensions? (enabled TypeOperators already).
11:58:04 <dcoutts> kasbah: having edited your .cabal file to remove the upper bounds
11:58:31 <dcoutts> kasbah: then with the above with --dry-run it'll tell you want it'll try, and if that works you can paste back in those upper bounds
11:59:00 <dcoutts> kasbah: but note that most packages follow the PVP, so you can also take advantage of that
11:59:15 <ReinH> JonReed: that doesn't make sense
11:59:16 <enthropy> JonReed: don't use any. I was hoping @src would print something like   elem x (x' : xs) = (x == x') || elem x xs; elem x [] = False
11:59:23 <ReinH> Elem must be a data constructor
11:59:32 <enthropy> which you can translate into a closed type family
11:59:45 <ReinH> JonReed: you seem to be mixing upper- and lowercase freely in various places. You can't do that.
12:00:08 <enthropy> type family Elem x xs where Elem x (x ': xs) = x; Elem x (y ': xs) = Elem x xs -- or so
12:00:09 <vitalij>  Can you please provide a group contact to #freenode staff?
12:00:22 <enthropy> or maybe FindElem is a better name
12:00:35 <ReinH> enthropy: what?
12:00:50 <ReinH> you can't do that
12:01:01 <enthropy> ReinH: the type family?
12:01:08 <ReinH> Elem x (x ': xs)
12:01:19 <ReinH> You can't just use x twice and expect GHC to test whether they are the same
12:01:30 <enthropy> ReinH: it works that way for closed type families
12:01:37 <ReinH> eh?
12:01:38 <enthropy> just the same as it does for instances
12:01:44 * hackagebot publicsuffix 0.20160126 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160126 (wereHamster)
12:01:55 <ReinH> It doesn't work at all.
12:02:02 <JonReed> ReinH: It actually compiles. The only problem I'm having now is that " The first argument of `Elem' should have kind `*',       but `ThemeList' has kind `[Symbol]"
12:02:25 <ReinH> How is [Symbol] a kind?
12:02:51 <enthropy> :k ["hi","reinH"]
12:02:53 <lambdabot> [GHC.TypeLits.Symbol]
12:02:57 <ReinH> Ah.
12:03:37 <ReinH> Oh, this is type-level stuff and x is a type variable.
12:03:52 <ReinH> Right
12:04:21 <JonReed> ReinH: Here is full code if you're curious: http://lpaste.net/150952
12:04:34 <ReinH> I was confused becaue above Elem was used at value level.
12:04:39 <ReinH> *because
12:05:16 <ReinH> I don't really understand why this should be done at the type level in the first place.
12:05:38 <ReinH> Generally haskell is better at value-level programming than type-level programming.
12:06:03 <bollu> I want to create a grid in diagrams - what's the neatest way?
12:06:10 <shapr> bitemyapp: Yeah, I'll dig into the book and see if I saw any flagrant overlaps. I thought I saw duplication of content, but I'll confirm it.
12:06:14 <JonReed> Theme list is static anyway. It's better it fails at compile time than runtime.
12:06:20 <geekosaur> Strukks, echo is part of stdin, not stdout
12:06:22 <ReinH> @google haskell diagrams grid
12:06:23 <lambdabot> http://projects.haskell.org/diagrams/haddock/Diagrams-TwoD-Layout-Grid.html
12:06:23 <lambdabot> Title: Diagrams.TwoD.Layout.Grid
12:06:26 <ReinH> bollu: did you try googling for it?
12:06:41 <ReinH> JonReed: if it's static then you can use a sum type
12:07:45 <bollu> ReinH: whoops, I guess I didn't RTFM right, thank you!
12:07:49 <f-a> http://hackage.haskell.org/package/lentil <-- I have this package where build failed on a dependency, but the dependency itself compiles succesfully http://hackage.haskell.org/package/optparse-applicative . Is there a way to retrigger the build?
12:07:52 <JonReed> ReinH: Like data Theme = ThemeOne | ThemeTwo" ? I don't like it because "themeone" matching the actually string looks better to me than introducing constructors
12:08:00 <JonReed> just to represent a string
12:08:04 <geekosaur> echo is something done by the kernel when it receives a character on a terminal-like device. if stdout happens to be referencing the same terminal-like device as stdin, that might work...
12:08:07 <ReinH> f-a: retrigger the build where?
12:08:14 <f-a> on hackage, ReinH 
12:08:30 <f-a> I am talking about the "build reports"
12:08:39 <ReinH> JonReed: I don't think introducing a bunch of unnecessary type-level programming is better than using a sum type
12:08:43 <Strukks> geekosaur: thanks, the book author made a mistake there, then.. 
12:08:52 <ReinH> I think you should learn to appreciate sum types
12:09:12 <geekosaur> likely. as I said, if it happens to be pointing the same place, it would work, at least on most unixlikes (on Windows? no clue)
12:09:14 <ReinH> because you are not, in fact, introducing the stirng 
12:09:19 <ReinH> the string "themeone"
12:09:19 <mjhoy> i'm running into "<<loop>>" output from running debug trace, what should i be looking out for?
12:09:24 <JonReed> ReinH: Well, on one level I want to learn more type level programming, so I'm trying to use it more
12:10:03 <geekosaur> mjhoy, something that is calling itself immediately. let f = f in f -- f calls itself immediately, this should trigger <<loop>>
12:10:49 <Strukks> geekosaur: could you also tell me why ghci doesn't let me ":r" that code twice? Second time I load it and enter "main" it says Exception: <stdin>: hGetContents: invalid argument (Bad file descriptor) 
12:11:01 <geekosaur> but sometimes it can be a lot more subtle than that... basically it's when it his itself as part of the first reduction, so if f calls g calls h calls f and nothing else is reduced before that, you also get <<loop>>
12:13:14 <mjhoy> geekosaur: hmm. ok, thanks. i do basically have f a b c d e = f a b' c d' e'
12:13:24 <mjhoy> something must not be reducing
12:13:30 <geekosaur> yeh, that will <<loop>>
12:14:37 <geekosaur> if you are using that as part of a sequence of patterns, you may need to rewrite things to use a helper and invoke the helper with the reordered parameters
12:15:31 <mjhoy> and the helper is g b d e = g b' d' e' ?
12:17:10 <geekosaur> I'm not sure what you are doing here, but the idea is that if that is a catch-all after other patterns that retries things with the parameters permuted, you write the actual function as the helper (call it f' maybe) and then your f calls f' to do the actual work, with the permute case invoking f' with the permuted parameters
12:19:57 <geekosaur> Strukks, I *think* that is a terminal device behavior. Terminals don't have an actual end-of-file (aside from closing the terminal window, or dropping DTR or DCD for actual terminal / modem) so it is faked to avoid confusing programs that expect EOF to remain true after it is hit
12:20:12 <w3pm> hi all, functional programming question here: i have a list of items [k,v] with unique keys but duplicated values. i'd like to find the list of all duplicated values... what's the best way to do this using map/fold/etc?
12:20:33 <w3pm> i can find some really kludgly ways of doing it but it feels like it should be simple
12:20:35 <geekosaur> unfortunately, that means after interact hits EOF, stdin is useless. (ghci's command mode is not using the same terminal mode and won't see this)
12:21:13 <Strukks> geekosaur: I think I found a way around it with "take 10" and then reloading, seems to work for now
12:21:33 <geekosaur> Strukks, it is *possible* that using :main instead of main will cause ghci to reset something so it will work right the next time
12:22:03 <Strukks> geekosaur: I'll try that, also what does "hSetBuffering stdin NoBuffering" do?
12:23:13 <geekosaur> turns off line buffering, both in ghc's runtime and in the terminal driver
12:23:30 <\[0_o]\> ohai. How do I write OR in esqueleto?
12:23:53 <\[0_o]\> like, select * from table where this = 1 OR that = 2;
12:23:55 <Strukks> What does line buffering mean?
12:24:20 <geekosaur> the default behavior for terminals is that characters are buffered (and can be line-edited) until you hit return, then are sent all at once to the program
12:24:34 <vijaykiran> hello - I've a noob question - https://gist.github.com/vijaykiran/3a57f9fe9df52bedf48e < how do I "abstract" away the middle part of these functions, so that they are "composable"
12:25:33 <Strukks> geekosaur: okay and what happens when you turn linebuffering off? 
12:25:45 <vijaykiran> e.g., I'd like to define "pipeline" of these kind of functions in any combination - remove -> swap -> repeat or repeat -> swap -> remove  .. etc.
12:25:46 <geekosaur> characters are sent immediately to the program as they are typed
12:26:04 <geekosaur> open a new terminal window and run "cat" (without a filename)
12:26:14 <Strukks> geekosaur: okay, that makes sense, that doesn't work as well for some reason
12:26:39 <geekosaur> type a line ( it will be echoed back as you type). then press return and you will get the whole line printed again; that's "cat" printing it back as it gets it (the line all at once)
12:26:54 <geekosaur> type control-d to get the prompt back
12:27:05 <geekosaur> enter:  stty -icanon; cat; stty icanon
12:27:14 <Strukks> geekosaur: http://lpaste.net/150954 , I have buffering off, but it still buffers
12:27:21 <geekosaur> enter a line and watch both the terminal and cat echo characters back to you as you type
12:27:59 <geekosaur> press control-d at the start of a line to exit back to the shell; if that doesn't work (can depend on OS) type control-c and then type "stty icanon" at the shell prompt
12:28:13 <geekosaur> that said, you are running this from ghci, you said
12:28:20 <Strukks> Yes!
12:28:30 <geekosaur> ghci likes to do all its input with haskeline, and that will cause the terminal to behave oddly
12:28:40 <geekosaur> basically haskeline controls those things instead of your program
12:28:52 <geekosaur> either compile it, or try using runghc instead
12:29:52 <Strukks> alright!
12:29:53 <geekosaur> (we would use readline, but (a) same problem (b) no readline on windows, incompatible readline on OS X, sigh)
12:34:52 <mtesseract> Hi
12:36:11 <dmj> mtesseract: hi
12:36:11 <dmj>  
12:37:23 <django_> hey
12:37:31 <django_> do you most of you focus primarily on haskell?
12:38:22 <shapr> django_: as opposed to what?
12:38:37 <shapr> django_: I like lots of subjects surrounding Haskell too
12:38:47 <django_> Any other language? All ive regarding haskell is its use in academia 
12:38:52 <django_> heard*
12:38:57 <bitemyapp> shapr: much appreciated
12:39:01 * geekosaur spends most of his time in perl and C, since that's what $employer uses (providing third party support for applications, so rewriting them in Haskell isn't a thing)
12:39:05 <shapr> django_: I've seen lots of use outside of academia, facebook, AT&T, Intel, etc
12:39:47 <shapr> django_: I've seen lots of small companies using Haskell to produce mid-sized software with a very small team.
12:39:58 <django_> cool
12:40:10 <lambda-11235> vijaykiran: Put the first argument [a] as the last arg and do > repeat idxs n $ swap ps $ remove midxs $ xs
12:40:12 <shapr> django_: I've even had jobs writing Haskell, though at the moment I'm writing Python,Ruby, and Go for work.
12:40:18 <geekosaur> bu there are places that do use Haskell, and even a company (fpcomplete.com) selling those companies software and support
12:40:57 <shapr> django_: I was surprised to hear that people make money writing Go. I think it's that way for every unfamiliar language, "Oh, people are getting paid to write that?"
12:41:10 <shapr> django_: What languages do you write for money?
12:41:40 <shapr> Last year I wrote a bunch of Python that wrote LaTeX, I got paid for that.
12:41:49 <\[0_o]\> shapr: i know a few guys who write in go for living
12:41:58 <\[0_o]\> most of them work for google though
12:42:25 <shapr> \[0_o]\: I know several companies here in Atlanta that use Go. I've heard of one or two Haskell jobs in Atlanta.
12:42:33 <lambda-11235> go go power programmers.
12:42:38 <django_> shapr, none im  new to this industry haha
12:42:51 <django_> i need an  internship though, if you need a remote intern :D
12:42:54 <shapr> django_: oh! Welcome! You have many amazing adventures ahead of you!
12:43:14 <shapr> django_: My company doesn't do remote interns, but if you're in Atlanta, you can apply.
12:43:27 <APic> Companies ♥
12:43:37 <django_> aww
12:43:42 <django_> im in south FL
12:43:45 <shapr> Golly, how many users on #haskell these days?
12:44:10 <shapr> django_: I don't know of any jobs there, sorry.
12:44:19 <mjhoy> geekosaur: found it, finally! i had defined basically (a', b') = f a' b instead of f a b.
12:44:41 <shapr> django_: but if you want to get a head start, create a github.com account and create something cool to show off in future interviews.
12:44:51 <shapr> mjhoy: quickcheck?
12:45:11 <mjhoy> shapr: loop
12:46:34 <vijaykiran> lambda-11235: thanks! will give it a try
12:47:52 <django_> shapr, yeah i have one lol
12:48:30 <mnoonan> I have a stack project that I'm working on, and I need to make a minor change to a library that it depends on. What's the best way to do this?
12:48:36 <bollu> can I have some help with typing errors when using diagrams? I'm getting errors that I've (literally) never seen before: https://gist.github.com/bollu/a6a90d0e5c28482ca70c
12:50:57 <lyxia> bollu: > Use FlexibleContexts to permit this
12:51:21 <lyxia> oh wait its on
12:51:29 <bollu> lyxia: yeah, it is
12:51:48 <mtesseract> I am trying to implement the ReaderT Monad transformer, but ghc seems to dislike my monad instance definition for MyReaderT. Code and ghc error message can be found at http://pastebin.com/XY0rCGyD. Would be happy to learn why ghc is complaining about missing Applicative instances, when all I am trying to do is to implement Monad (MyReaderT r m). Thanks!
12:52:25 <geekosaur> mtesseract, as of ghc 7.10 every Monad must be an instance of Applicative
12:52:25 <bollu> mtesseract:it's because of AMP. Any Monad must have a valid applicative instance
12:52:26 <mizu_no_oto> mtesseract: Monad is now a superclass of Applicative
12:52:39 <bollu> mtesseract: you can use your monad instance to write an applicative instance though,if that helps
12:52:40 <geekosaur> mizu_no_oto, backwards
12:52:47 <mizu_no_oto> >_<
12:52:56 <mizu_no_oto> thats what I get for typing quickly
12:53:13 <bollu> lyxia:any more ideas as to what I can do?
12:53:19 * geekosaur has been brainfarting enough today that he had to stop and think about it...
12:53:19 <bollu> diagrams types are.. hard to read
12:54:02 <lyxia> bollu: you're LANGUAGE pragma should be at the top
12:54:04 <lyxia> your
12:54:30 <bollu> lyxia:ohh, I see!
12:54:45 <bollu> lyxia:stil have compile errors. It's now asking for TypeFamilies / GADT's
12:54:49 <bollu> I really think that is overkill
12:54:50 <mtesseract> I see, thank you. I have been following http://hackage.haskell.org/package/mtl-1.1.0.1/docs/src/Control-Monad-Reader.html, which -- if I understand the problem correctly -- is then outdated in that it is not valid code for recent versions of ghc?
12:55:33 <lyxia> bollu: I think they are reasonable extensions to work with. :/
12:55:55 <mizu_no_oto> mtesseract: yes
12:55:56 <bollu> lyxia:I suppose :) I've never reached for them personally, so I have this "threshold of too much power/magic" in my head for them
12:56:19 <geekosaur> mtesseract, that's an old version
12:56:21 <geekosaur> current is mtl-2.2.1
12:56:52 <bollu> lyxia:cool, it complies :D
12:56:54 <mtesseract> Okay, dunno why google spit out that old version.
12:57:05 <geekosaur> because old stuff has more collected links
12:57:21 <mizu_no_oto> The AMP happened a year or so ago, I think
12:57:29 <geekosaur> and I think the hackagefolks added the metadata that google itselfsays will cause it to index the current one instead, but it doesnt work
12:58:14 <mizu_no_oto> and it looks like 1.1.0.1 was uploaded in 2008?
12:58:18 <geekosaur> yep
12:58:36 <hpc> ugly idea
12:58:52 <hpc> when hackage detects a googlebot visit, redirect it to the most recent upload within the same major version
12:59:03 <hpc> side bonus, making people use the PVP properly
12:59:17 <mizu_no_oto> Fortunately, defining an Applicative instance is pretty trivial: http://stackoverflow.com/questions/9098247/how-to-show-that-a-monad-is-a-functor-and-an-applicative-functor
12:59:21 <mtesseract> Note to self: use hoogle directly.
13:00:25 <bollu> how do you figure out what types to give diagrams expressions?
13:00:27 <bollu> example code: https://gist.github.com/bollu/a6a90d0e5c28482ca70c
13:00:41 <bollu> I'm really unsure as to what type to give, say, `cellToDiagram`
13:00:48 <bollu> I know that I can load it in ghci
13:00:56 <bollu> but that sort of kills the point of types IMO
13:01:03 <bollu> can you guys intuitively figure out the types for diagrams classes?
13:05:19 <sm> bollu: usually you can figure it out by looking at the haddock docs for the components you're using
13:05:37 <bollu> sm: I see, I'll start doing that then
13:05:45 <bollu> also, is there anyway to store haskell documentation locally?
13:05:53 <sm> also, when in doubt add explicit type declarations everywhere in your program
13:06:02 <Welkin> bollu: yes, all of it is
13:06:17 <bollu> Welkin:wait, what?
13:06:20 <bollu> how do I access it
13:06:20 <bollu> ?
13:06:25 <Welkin> using haddock
13:06:29 <Welkin> oh
13:06:32 <Welkin> use your web browser
13:06:33 <noteventime> bollu: You can tell cabal (and presumably Stack too) to generate haddock docs 
13:06:37 <Welkin> it's in file/// something
13:07:15 <sm> https://www.reddit.com/r/haskell/comments/42l6q1/local_documentation/ is some recent discussion. On mac, some people like dash
13:07:16 <noteventime> ~/.cabal/share/doc if you're of the unix persuation 
13:07:42 <sm> I mostly use a browser custom url keyword to jump to the hackage page
13:07:53 <bollu> oh cool, thanks!
13:07:55 <noteventime> I think anyway
13:08:09 <bollu> and if I use stack to install my packages? does it use cabal behind the scenes and share versions?
13:08:41 <dcoutts> bollu, sm: btw, hackage search provides a opensearch so you can plug that into your browser
13:09:02 <noteventime> bollu: My guess would be somewhere in ~/.stack but I'm not sure
13:09:11 <bollu> whoa, hoogle is slick
13:09:34 <bollu> dcoutts: what exactly do you mean by "plug that into my browser"?
13:10:01 <dcoutts> bollu: like a custom search engine provider, google, bing, wikipedia, hackage...
13:10:08 <bollu> oh, right. gotcha
13:10:37 <sm> ah! dcoutts I think you just cleared up a mystery
13:10:45 <sm> I've been trying to figure out why "h PKG" works in safari just as in my firefox
13:10:47 <Welkin> the mystery machine!
13:10:48 <Welkin> zoinks!
13:11:31 <bollu> I'd like to maybe redesign the hackage theme
13:11:42 <sm> right-click on the hackage search field reveals the "safari keyword search settings" 
13:11:46 <bollu> is there a formal RFC spec or something
13:11:49 * hackagebot tagged 0.8.3 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  https://hackage.haskell.org/package/tagged-0.8.3 (EdwardKmett)
13:11:49 <bollu> ?
13:11:50 <bollu> for hackage?
13:12:22 <dcoutts> bollu: for what aspect exactly?
13:13:12 <dcoutts> bollu: if you want to help out improve the hackage web ui that'd be great. It now uses templates for more things so that should be easier, and some people have sketched some nicer designs
13:13:18 <bollu> dcoutts: make it slightly more reactive for one. It doesn't really feel polished on phones
13:13:27 <bollu> oh that's cool :)
13:13:30 <bollu> so how do I get involved?
13:14:16 <dcoutts> bollu: join #hackage and look at the github 
13:14:24 <bollu> cool :)
13:14:58 <jle`> why did GHC drop reproxy?
13:17:11 <monochrom> Data.List's dropWhileEnd is nice
13:21:49 * hackagebot semigroups 0.18.1 - Anything that associates  https://hackage.haskell.org/package/semigroups-0.18.1 (EdwardKmett)
13:21:51 * hackagebot process-extras 0.3.3.8 - Process extras  https://hackage.haskell.org/package/process-extras-0.3.3.8 (DavidFox)
13:31:49 * hackagebot kicad-data 0.2.0.0 - Parser and writer for KiCad files.  https://hackage.haskell.org/package/kicad-data-0.2.0.0 (kasbah)
13:43:18 <jgertm> im trying to make a constructor of variable arity, determined by the first argument. however, i am not sure such a thing is even possible with the syntax i used. can somebody please help me out?
13:43:41 <Cale> I can help you. Don't try to do that ;)
13:43:43 <jgertm> http://lpaste.net/150956
13:44:14 <jgertm> Cale: can you elaborate?
13:45:57 <Cale> Well, it's just going to be a horrible pain, and you'll end up needing computation at the type level and will get frustrated when GHC doesn't as much computation to unify things as a dependent type checker might.
13:46:13 <Cale> I dunno, it doesn't seem worth the trouble in most cases to me.
13:46:25 <jgertm> Cale: thats exactly where i got stuck now ;-)
13:47:30 <Cale> If you're really persistent, you can get many things to happen, but not before your code turns into kind of a mess.
13:47:49 <jgertm> Cale: have you looked at my lpaste?
13:47:53 <Cale> yeah
13:52:34 <Cale> jgertm: Well, your first problem here is that the Operation type class doesn't have any functional dependencies
13:53:15 <Cale> jgertm: So, when it sees (Operation Abs ar), there's no way from this to determine what ar ought to be
13:53:26 <jgertm> Cale: you mean | op -> n ?
13:53:31 <Cale> yeah
13:54:30 <jgertm> Cale: i tried that, however then i get a conflict between the two derivations
13:55:00 <jgertm> since it doesnt know that the typeclasses Function and Binary are mutually exclusive
13:55:02 <Cale> Oh, yes
13:55:09 <jgertm> is there a way to express that?
13:55:10 <Cale> Operation op 1
13:55:13 <Cale> and Operation op 2
13:55:16 <Cale> are clearly overlapping
13:55:51 <Cale> The class constraints you put on instances only apply *after* the instance has been selected and committed to
14:00:10 <Cale> jgertm: http://paste.lisp.org/display/305954
14:01:18 <jgertm> Cale: very nice. 
14:02:02 <jgertm> is there such a thing as a type class synonym?
14:02:23 <Cale> You can use type aliases for it
14:02:47 <exio4> ConstraintKinds + type synonyms 
14:02:54 <Cale> yeah
14:03:14 <jgertm> yes. but for the instantiation. id like to avoid spelling out Operation for all functions and binary ops
14:03:28 <exio4> also, do you really want a type class there?
14:04:00 <jgertm> exio4: what do you mean?
14:04:09 <Cale> A type family might make more sense
14:04:15 <Cale> But it's the same thing
14:04:41 <Cale> I don't really understand what this Arity family is all about
14:05:13 <Cale> (Arity 2 (Expr d)) ~ (Expr d -> Expr d -> Expr d) -- is this really what you want?
14:05:16 <jgertm> Cale: it constructs the part of the type signature for the arguments
14:05:33 <jgertm> maybe theres an off by one error in there
14:05:39 <Cale> It constructs a function argument here
14:05:40 <koz_> I'm trying to write a PR for mono-traversable. Currently, http://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-Sequences.html#t:Textual has unwords and unlines defined as going [t] -> t, but I'm trying to make it 'any MonoFoldable thing of t -> t', but am not sure how to write it.
14:06:10 <exio4> jgertm: if I was doing this, I'd keep the arity as a phantom type of the operation
14:06:15 <Cale> jgertm: You're not allowed to write something like  Application :: (Operation op ar) => op -> Arity ar (Expr d)
14:06:46 <exio4> jgertm: data Expr d where Literal :: d -> Expr d ; Application :: op n -> Arity n (Expr d) -> Expr d
14:06:50 <pikajude> is this possible? http://lpaste.net/150958
14:07:04 <Cale> If I were doing this, I wouldn't bother with type level numbers at all, and just make more constructors.
14:07:28 <exio4> you'd then define operations like data Addition (n :: Nat) where Addition :: Addition 2 -- or something like this
14:07:41 <acertain> koz_, `unwords :: (Element seq ~ t, IsSequence seq) => seq -> t`?
14:08:03 <koz_> acertain: Thank you - I knew I was missing something.
14:08:07 <Cale> pikajude: Is what possible?
14:08:11 <pikajude> Cale: to make it typecheck
14:08:18 * exio4 meant "doing type hackery, I'd do it differently"
14:09:03 <jgertm> Cale: what do you mean by "not allowed"? arent class constraints allowed inside GADTs?
14:09:53 <Cale> jgertm: I mean, the result type in that line I gave isn't explicitly Expr d for some d
14:10:28 <tomus> how to run a one-liner from a comand line?
14:10:41 <tomus> (haskell one)
14:10:42 <Cale> jgertm: all the constructors of a GADT have to explicitly result in something of a type which is constructed by the type constructor being defined.
14:10:57 <Cale> jgertm: You can't compute a type which just happens to do that
14:11:56 <jgertm> Cale: i see. so what youre saying is that the type im going for is impossible?
14:12:01 <Cale> yeah
14:12:41 <jgertm> so type constructors cannot be variadic?
14:12:55 <Cale> data constructors can't be variadic
14:13:15 <jgertm> very well. so i suppose uncurrying would be a way around this?
14:13:34 <Cale> Even if you could convince the type system to give them to you, I'm not sure they'd work... they're implemented by fixed size records in memory...
14:14:06 <Cale> I'd just introduce constructors for each of the arities I cared about
14:14:25 <Cale> Or perhaps do something Applicative-like
14:14:46 <Cale> like...
14:14:50 <jgertm> Cale: i used to have individual constructors but was displeased with the repetition
14:14:51 <exio4> well, you can! you just need more type-hackery! and using tuples!
14:15:39 <jgertm> exio4: thats what i meant by uncurrying. is there a way to construct the n-tuple type similarly to my current Arity type family?
14:15:56 <Cale> Perhaps:  Ap :: Expr (a -> r) -> Expr a -> Expr r
14:16:30 <exio4> jgertm: a n-tuple will need you to hardcode cases up to 63
14:16:43 <Cale> and then you have things like  Literal abs :: Expr (Integer -> Integer)
14:16:47 <exio4> jgertm: you could use a list with the length tracked at compile-time 
14:17:00 <exio4> but, I don't really think you want -any- of this :P
14:17:07 <Cale> Ap (Literal abs) (Literal (-5)) :: Expr Integer
14:17:42 <Cale> Ap (Ap (Literal (+)) (Literal 2)) (Literal 3) :: Expr Integer
14:18:06 <Cale> and of course, you don't necessarily have to use Literal like that
14:18:59 <Cale> jgertm: Does something like that make sense?
14:19:06 <jgertm> Cale: interesting approach. i think it would make pattern matching very verbose though
14:19:18 <jgertm> it makes sense though
14:20:08 <Cale> Well, I don't know if the language you're implementing is higher order or anything, but in a lot of cases, you'd want such a function application constructor anyway
14:20:43 <Cale> You could make a kinda-bad Applicative instance
14:20:45 <jgertm> exio4: so wrapping a list in a newtype with a phantom?
14:21:01 <Cale> instance Applicative Expr where pure = Literal; (<*>) = Ap
14:21:28 <Cale> and then write things like  pure (*) <*> pure 2 <*> pure 3
14:22:31 <exio4> jgertm: no, data Vec (n :: Nat) a where Nil :: Vec 0 a ; Cons :: a -> Vec n a -> Vec (1+n) a -- might work better with peano numbers :P 
14:26:09 <Bruuuuuno> Hi, I'm using the socket-io package and I want to use the 'on' function with a FRP framework. Is it possible? https://hackage.haskell.org/package/socket-io-1.3.4/docs/Network-SocketIO.html#g:1
14:26:20 <Bruuuuuno> I can't get my head around the second argument
14:29:27 <Cale> Bruuuuuno: sigh, why do people do things like that...
14:29:51 <Cale> Bruuuuuno: I guess we have to go digging for the OnArgs class which is unfortunately not documented because it's internal...
14:30:27 <Bruuuuuno> class OnArgs a r | a -> r where   parseArgs :: Aeson.Array -> a -> Maybe r
14:30:54 <Cale> instance OnArgs a a
14:30:57 <Cale> instance (Aeson.FromJSON a, OnArgs b r) => OnArgs (a -> b) r
14:31:59 <Cale> So... I guess you're meant to pass a function whose arguments are instances of FromJSON and whose result is an (EventHandler a)
14:32:53 <Bruuuuuno> type EventHandler a = ReaderT Socket IO a
14:33:03 <Cale> yeah
14:34:51 <Bruuuuuno> reactive banana provide an "AddHandler"
14:34:52 <Bruuuuuno> http://hackage.haskell.org/package/reactive-banana-1.1.0.0/docs/Control-Event-Handler.html#t:AddHandler
14:35:02 <Bruuuuuno> register :: Handler a -> IO (IO ())
14:35:14 <Cale> yeah, that type makes infinitely more sense
14:35:27 <Bruuuuuno> Why?
14:35:38 <Bruuuuuno> I don't get the IO (IO ())
14:35:58 <Cale> Did you see the example there?
14:36:23 <Cale> The action of type IO (IO ()) will register the handler, and at the same time return an action you can use to unregister it later.
14:37:05 <Bruuuuuno> okay
14:37:09 <crough> IO (IO ()) means that it took an IO action to make an inner handler of type IO () that you can run later
14:37:19 <Cale> uh
14:37:22 <crough> if it just returned IO, it would execute immediately
14:37:35 <Cale> crough: Using the word "handler" there is potentially confusing though :)
14:37:42 <Cale> (just because of context)
14:37:50 <crough> cale: yeah, the "handler" is the deregister function, sorry haha
14:38:08 <crough> basically it did an IO action and it's giving you a way to preform a dependent IO action later
14:38:14 <crough> (is action a bit clearer?)
14:38:17 <Cale> yeah
14:38:52 <Cale> You can just ignore the result of type IO () if you have no need of ever unregistering the handler of course.
14:39:40 <Bruuuuuno> okay that make sense
14:40:20 <Cale> and the other thing which makes it more sensible is that it explicitly says which type the argument to the handler is, rather than saying indirectly via an undocumented type class that it can be a function of arbitrarily many arguments (but don't get the number wrong or your handler will do nothing)
14:40:34 <Cale> that the handler can be*
14:42:52 <jgertm> i think ill try to go on with the dependent lists from exio4. is there a way to convert to and from conventional lists?
14:43:33 <exio4> to is just a recursive function, from requires existential types or some way to know the length at compile-time
14:43:41 <Strukks> I have a number and a list of functions, and I need to evaluate that number for each function, for example = "0 [(^0),(+1),(*5)] = [0^0,0+1,0*5] = [1,1,0]", any pointers on what I should be using for that?
14:43:45 <Bruuuuuno> so if I want to make a custom handler from the socket-io EventHandler a, how would I do it?
14:44:16 <exio4> Strukks: map ($ 0) [f,g,h]
14:44:18 <crough> Strukks: fmap ($ x) [f1, f2, f3]
14:44:31 <jle`> Strukks: [f1,f2,f3] <*> [x]
14:44:44 <Strukks> kek
14:44:54 <crough> (all of these are exactly the same!) 
14:45:25 <exio4> [f,g,h] <*> pure x
14:45:28 <jle`> the reason i prefer the <*> version is becuase it maintains a nicer order, functions before values
14:45:36 <jle`> but, yeah, they're all exactly the same
14:45:50 <Strukks> what does ($ 0) or ($ x) mean?
14:45:57 <jle`> :t ($)
14:45:59 <lambdabot> (a -> b) -> a -> b
14:45:59 <crough> it means apply
14:46:08 <jle`> oops
14:46:10 <jle`> @src ($)
14:46:11 <lambdabot> f $ x = f x
14:46:17 <jle`> Strukks: f $ x = f x
14:46:33 <Strukks> alright! Thanks!!
14:46:35 <jle`> so ($ x) is a section that partially applies ($), "waiting" for the function
14:46:39 <jle`> > (+ 3) 10
14:46:41 <lambdabot>  13
14:46:42 <jle`> > (/5) 100
14:46:44 <lambdabot>  20.0
14:46:51 <jle`> > ($10) negate
14:46:53 <lambdabot>  -10
14:47:06 <jle`> ^ negate $ 10 = -10
14:48:14 <Strukks> This is very heplful!
14:48:52 <jle`> we're here all week!
14:49:16 <Strukks> I know, I've been spamming #haskell for a week now already, preparing for an exam :D
14:49:32 <jle`> good luck :)
14:49:41 <Strukks> People here are really nice and helpful
14:49:52 <crough> Of course! Glad to help
14:52:29 * hackagebot MonadCompose 0.8.4.0 - Methods for composing monads.  https://hackage.haskell.org/package/MonadCompose-0.8.4.0 (JamesCandy)
14:54:33 <johnw> should "pure" always be injective?
14:55:13 <shachaf> No.
14:55:34 <exio4>  pure = Const mempty
14:55:43 <johnw> thanks
14:55:45 <exio4> er, pure _ = Const mempty -- here
14:56:02 <exio4> a nice example of an Applicative which doesn't have an injective pure :P
15:07:29 * hackagebot mappy 0.1.0.1 - A functional programming language focused around maps.  https://hackage.haskell.org/package/mappy-0.1.0.1 (mjgpy3)
15:08:53 <dustmote> do people still use Data.Conduit.Binary? It seems to no longer exist in the `conduit` package..
15:09:22 <crough> a lot of people use Cereal for binary iteration now
15:10:12 <Axman6> they do?
15:10:47 <Axman6> I haven't heard of many people using either much lately, guess it's no longer a hot topic
15:10:56 <Cale> I seem to recall that binary now does everything extra that cereal did...
15:11:39 <crough> Axman6: I dont think binary parsing and iteration is crazy common is all... most people deal with text
15:11:57 <Axman6> I'm still waiting for dcoutts' CBOR based binary library with baited breath
15:12:07 <Axman6> yeah
15:12:19 <dcoutts> Axman6: it's on github atm
15:12:27 <dcoutts> and in production with one of our clients
15:12:33 <Cale> Oh, maybe the strict vs. lazy bytestring divide between the two still exists
15:12:42 <Cale> So it probably depends on which sort of bytestrings you want to write
15:12:49 <dcoutts> Cale: no, both libs do both
15:13:12 <Axman6> dcoutts: I know, I reported a potentially disasterous bug on it =)
15:13:22 <dcoutts> Axman6: oh?
15:13:28 * dcoutts looks...
15:13:32 <Axman6> the encoding of Either which would go into an infinite loop
15:13:47 <Axman6> decoding*
15:13:51 <dcoutts> oh that yes
15:13:55 <dcoutts> PR applied iirc
15:13:56 <dustmote> i'm dealing with text; but i need to read from a handle..
15:14:01 <Axman6> yep
15:14:11 <dcoutts> thanks :-)
15:14:34 <Axman6> no worries, I was just reading through the code and happened to spot it
15:14:57 <dustmote> condit-extra has what i'm looking for
15:14:58 <dustmote> thanks!
15:15:06 <dcoutts> Cale: the cereal strict bytestring thing was never any cleverer than concat . toChunks
15:15:13 <Cale> ah
15:15:17 <Axman6> do you know if there are plans to replce Binary with it at any stage? your original slides seemed to imply as much
15:15:31 <dcoutts> Axman6: yes, eventually
15:16:00 <dcoutts> Axman6: the main thing I need to do before a release is the Generics support
15:16:13 <dcoutts> but I've been kind of busy recently making cabal not suck :-)
15:16:16 <Axman6> ah yes, that would be useful
15:16:35 <jle`> johnw: pure = const Proxy
15:16:44 * dcoutts advertises for beta testers for cabal's nix-local-build branch
15:17:54 <jle`> dcoutts: should I be using cereal or binary for new projects?
15:18:07 <jle`> i have this weird arrangement where half of my projects use cereal and half of them use binary
15:18:15 <dcoutts> jle`: I'd use binary at this point, cereal doesn't provide anything extra
15:18:20 <jle`> to interop with the types that the libraries they depend on
15:18:41 <dcoutts> jle`: yes that's annoying, I hope we can eliminate this divergence eventually
15:18:43 <jle`> hm, unfortunately, cereal works better with the safecopy library
15:18:45 <jle`> which is awesome
15:18:56 <jle`> maybe i can write a patch to safecopy or provide an alternative safecopy
15:18:57 <dcoutts> right
15:19:12 <Axman6> yeah safecopy/acid-state are pretty awesome
15:19:27 <jle`> i wonder how this happened
15:19:31 <jle`> this divergence
15:19:34 <dcoutts> actually I'm not so fond of safecopy, at least how it works. The idea is good, as is acid-state
15:19:53 <jle`> it works as a nice plug-in-and-go solution for a lot of my serialization issues
15:20:01 <dcoutts> jle`: at some stage cereal prototyped an incremental continuation approach to input, which was good
15:20:08 <jle`> but i'd be open for other solutions
15:20:33 <dcoutts> jle`: the binary cbor stuff is designed to address the safecopy use case (eventually)
15:20:43 <jle`> is this still in development?
15:20:54 <dcoutts> the cbor gives us a way to do the versioning encoding more directly, rather than as an extra layer
15:21:17 <jle`> do you mean https://hackage.haskell.org/package/CBOR ?
15:21:20 <dcoutts> jle`: the safe copy bit is not yet implemented in the cbor lib
15:21:28 <dcoutts> no, https://github.com/well-typed/binary-serialise-cbor
15:22:09 <jle`> i see
15:22:11 <dcoutts> so ideally I'd like to redo acid-state with the cbor lib, using that approach to do the transparent versioning
15:22:21 <jle`> if only ~
15:22:23 <dcoutts> so same idea, just an implementation I'd be happier with
15:22:29 <Axman6> dcoutts: how are you guys finding it in production? 
15:22:41 * jle` imagines a perfect ecosystem
15:22:42 <dcoutts> Axman6: works well, much faster, much lower memory use
15:22:52 <Axman6> great =)
15:23:07 <jle`> a perfect ecosystem would be an impossible ideal, but we can all strive to leave it better than how we found it
15:23:13 <dcoutts> aye
15:23:24 <dcoutts> that's what people working at the bottom of the stack have to believe :-)
15:24:56 <jle`> heh
15:56:10 <broma0> Does anyone have a specific (or general, i guess) strategy for determining a module/code layout for an arbitrary system? I'm starting to think more compositionally, and I feel like I'm lacking when it comes to the planning/design phase of a system written in haskell
15:56:59 <broma0> In OOP, there's plenty of class diagrams and the like, but I never see something similar for a more functional design
15:57:21 <SrPx> Hi! Simplest library to curl a site? "curl :: IO String" would do! :)
15:57:27 <SrPx> Woops. "curl :: String -> IO String"
15:57:55 <crough> SrPx: http-client, but wreq is very nice
15:58:20 <maerwald> SrPx: openURI :: String -> IO (Either String ByteString)
15:58:28 <maerwald> @hackage download-curl
15:58:28 <lambdabot> http://hackage.haskell.org/package/download-curl
15:58:45 <crough> broma0: module layout matters a bunch less than in OOP where everything references everything else ad nauseum. I typically just write some types and primitives on those, rinse, repeat.
15:59:33 <broma0> crough: the classic "Types.hs" and "Prim.hs"?
15:59:43 <SrPx> thanks!
16:00:05 <crough> broma0: I actually group things like "SomeType.hs" with all of that types primitives
16:01:01 <crough> I /do/ often have a 'Datatypes.hs', though, for non-polymorphic record types that don't really do anything but hold data, though. All of em go in there.
16:01:07 <crough> Datatypes are boring though :)
16:01:19 <broma0> crough: ah, i see.. i usually do the same, but when it comes to the meat of the program (the logic that uses those primatives) I yearn for principles regarding how to model the hierarchy of logic
16:01:39 <broma0> i guess there really isnt one answer though
16:02:33 <crough> broma0: Yeah. FP is much simpler than OOP and it's really just what you feel like. I tend to try to encode my logic in my types where possible though, so spliting up control types into modules gets me 80% of the way
16:03:15 <broma0> "so spliting up control types into modules gets me 80% of the way" -- i'd like to explore that
16:03:22 <broma0> control types, specifically
16:03:56 <crough> That's what everything in `transformers' is, along with FreeT and a lot of lenses :)
16:04:02 <broma0> so in a task list system we might have User and Task primative types, but what would these control types be? custom monads that encode the db stuff etc?
16:04:06 <broma0> ah i see
16:04:34 <crough> Yep. Things that represent logic *outside* of values themselves.
16:06:42 <broma0> crough: do you know of / have any examples illustrating the use of FreeT's in a side-effect heavy system?
16:07:46 * hackagebot mappy 0.1.0.2 - A functional programming language focused around maps.  https://hackage.haskell.org/package/mappy-0.1.0.2 (mjgpy3)
16:08:39 <crough> broma0: No. I actually dislike them a bit because I can't get a proper `Profunctor` out of them.
16:08:59 <crough> (which I need at my job very badly)
16:11:35 <dobq> broma0: does CoFree count?
16:12:10 <dobq> Cofree*
16:12:45 <broma0> dobq: I haven't yet gone down the co* rabbit hole :|
16:13:55 <dobq> broma0: (also, i agree with crough regarding module structuring. just do what is easiest for development. you usually end up exposing the interesting bits in some kind of master module anyway.)
16:14:08 <dobq> (and then users end up implementing all your other crap explicitly anyway)
16:14:08 <crough> If you say Cofree Costate Comonad in a mirror three times Edward Kmett shows up :/
16:14:40 <dobq> crough: well there's Rand which is a cofree comonad ?
16:15:17 <broma0> dobq: but I am the user!
16:15:48 <broma0> my question regarding structure/design is not coming from the library writer perspective
16:16:19 <broma0> that side of development is relatively simple since, like you said, you can do whatever you want and simply have a master module that exposes the good stuff
16:17:15 <dobq> broma0: well if the question is "where can i find <x>", i don't think anyone can help you
16:17:47 <broma0> we may have some sort of miscommunication, but that's alright, the brief conversation got some ideas flowing
16:17:53 <broma0> thank you!
16:21:14 <broma0> on another note, got a favorite template haskell book/article/tut/etc. ?
16:32:54 <chu> a/win 25
16:37:30 <shachaf> chu: Are you all about Chu spaces?
16:37:55 <chu> I'm not, I'm sorry.
16:38:16 <shachaf> Oh. Well, Chu spaces are pretty nifty.
16:39:25 <chu> lol
16:45:30 <codebje> @pl \a s -> show a ++ " !: " ++ s
16:45:31 <lambdabot> (. (" !: " ++)) . (++) . show
16:47:56 <clintm> shachaf: thanks for the indirect pointer to Chu spaces.  They are, indeed, pretty nifty.
16:48:20 <shachaf> Oh man, you have no idea.
16:48:40 <clintm> I suspect not, but I'm developing one. :)
16:54:00 <EyeJoy> is there something like "Java Content Repository/JCR" package in haskell  ?
17:08:01 * hackagebot wai-middleware-content-type 0.4.0 - A simple WAI library for responding with content.  https://hackage.haskell.org/package/wai-middleware-content-type-0.4.0 (athanclark)
17:10:04 <Sonarpulse> is there a module for file IO with byestrings that uses maybe/either instead of exceptions?
17:10:13 * Sonarpulse hates syncronous exceptions
17:11:01 <athan> Sonarpulse: just bracket it bro
17:11:07 <athan> :P
17:11:11 <dmj> Sonarpulse: just bracket it bro
17:11:23 <luigy> Sonarpulse just bracket it bro
17:12:03 <Sonarpulse> b-b-but...
17:12:18 <dmj> Sonarpulse: bro...
17:13:03 <Sonarpulse> there must be a meme i missed
17:13:18 <dmj> do you even bracket bro
17:13:19 <EvanR> Sonarpulse: the function try converts exceptions to Either, but is less convenient than bracket
17:13:58 <Sonarpulse> dmj: never heard "just lift it bro" though
17:14:13 <Sonarpulse> EvanR: fine, i'll conform
17:14:42 <dmj> Sonarpulse: I saw something on twitter today, "Do you even liftM bro?"
17:14:50 <Sonarpulse> hahaha
17:28:01 * hackagebot MonadCompose 0.8.4.1 - Methods for composing monads.  https://hackage.haskell.org/package/MonadCompose-0.8.4.1 (JamesCandy)
17:29:07 <will__> I'm new to haskell and trying to figure out what the function "go" does and am having a really hard googling it and hoogle just brings up goa
17:29:20 <will__> does anyone know where I could read about this function?
17:29:59 <shachaf> It's not a standard function.
17:30:12 <shachaf> Sometimes people write things like "x = ...go... where go = ..."
17:31:37 <montanonic> will__: yeah, it's just a common name that people give to a function that they define inside of another function
17:32:01 <montanonic> will__: I think `go` is almost always used in the context of recursion
17:32:07 <will__> oh
17:32:30 <will__> no wonder I can't find any documentation on it haha
17:32:42 <geekosaur> it's often used with https://wiki.haskell.org/Worker_wrapper
17:33:11 <geekosaur> that page uses names like "revWorker", etc., but in actual code you often see "go" instead
17:33:14 <will__> yea I'm looking at it here http://en.literateprograms.org/Merge_sort_(Haskell) in an implementation of merge sort
17:34:15 <will__> it's in the split function
17:35:00 <geekosaur> yes, so you'll note: split xs = go xs xs where
17:35:11 <geekosaur> and go is defined on the next two lines, with pattern cases
17:35:39 <geekosaur> the first case is when the first parameter is a nonempty list, the second case is for the empty list
17:35:40 <montanonic> will__: the reason you define another function inside is to add more information, for example, you might write a sum function like this
17:36:32 <montanonic> will__: http://lpaste.net/150969
17:38:02 <montanonic> will__: using an inner function like that makes it so that we can use state without mutating or side-effects
17:38:46 <will__> Thanks for that, I think it get it now
17:38:48 <montanonic> will__: but it also adds an extra parameter to the function, and we don't want the caller of our function to have to write `sumUpTo 5 0`
17:39:06 <montanonic> will__: you're welcome
17:41:28 <montanonic> will__: also, consider joining #haskell-beginners as well if you haven't already; there's no haskell question you can't ask in this channel, but sometimes it's nice to have two places to seek help from
17:41:52 <will__> alright I will, thanks
17:42:00 <will__> one question
17:42:30 <will__> I can't quite figure out what the first line after "where" is doing: go 0 total = total
17:42:50 <montanonic> will__: right, so: that's haskell's pattern-matching in action
17:43:11 <montanonic> will__:  it means that if the first parameter passed to go, which is a number, happens to be 0
17:43:17 <will__> so if x = 0 then it matches that?
17:43:22 <montanonic> will__: yes
17:43:42 <montanonic> will__: then whatever value the `total` value is, it will return that
17:43:43 <will__> oic
17:44:14 <Sonarpulse> ErrorT EitherT ExceptT yay
17:44:17 <will__> its like pattern matching and a function definition?
17:44:28 <montanonic> will__: so sumUpTo 0 will turn into: go 0 0, which will turn into: 0, since the `total` at that point is 0
17:45:02 <synergistics> Is running compiled haskell code faster than interpreted code from ghci?
17:45:08 <montanonic> will__: yes, the function definition itself is pattern matching; you can define a function multiple times, and it will evaluate whichever is the first version to "match" the data
17:46:07 <montanonic> so I could also add: go 13 total = -1, if for some reason I wanted the value of go to equal -1 anytime x was 13 or greater
17:46:24 <montanonic> synergistics: yes
17:46:55 <will__> oic, I never thought of it like that
17:47:46 <barrucadu> synergistics: Yes
17:47:49 <will__> thanks montanonic, that helped a lot
17:49:33 <montanonic> will__: np; come join us in the beginners channel too; I and others will be happy to help whenever we're available
17:59:40 <Lokathor> is hlint a little dodgy? http://lpaste.net/150967 it says to eta reduce line 21, but not line 7
17:59:53 <Lokathor> seems like it should either say to eta reduce both or neither
18:06:22 <kadoban> Lokathor: It's usually pretty consistent. I'm not sure what's going on there. It sometimes will only tell you one step of stuff to fix at a time, though I can't see how that would apply there.
18:06:58 <Lokathor> i'm just discovering nothing but corner cases this week it seems
18:08:24 <kadoban> Lokathor: If you're interested, try fixing it and see what it tells you next.
18:09:36 <Lokathor> told me about another eta reduce in partClient, but still doesn't care about joinClient, http://lpaste.net/150967
18:13:24 <dzdcnfzd> I just installed https://github.com/begriffs/haskell-vim-now and I ran into an issue where I couldn't infer types. The documentation says I should use the cabal flag --enable_tests -- is there a stack equivalent?
18:15:25 <Strukks> If I have "Data = monthnames..." and it's "deriving (Enum)" I can go fromEnum to get from the month name to a number on the list, how do I reverse this? Make the number to a month name?
18:16:12 <Strukks> ie "fromEnum January"  is 0
18:16:28 <EvanR> :t fromEnum
18:16:30 <lambdabot> Enum a => a -> Int
18:16:47 <EvanR> :t toEnum
18:16:49 <lambdabot> Enum a => Int -> a
18:17:08 <Strukks> toEnum doesn't work, since it doesn't know what I'm talking about? Does a type signature fix this?
18:17:18 <mgsloan> dzdcnfzd: "--test"
18:17:45 <dzdcnfzd> mgsloan: where do I specify that?
18:17:56 <dzdcnfzd> do I put it in a config file somewhere?
18:17:57 <mgsloan> When invoking "stack build"
18:18:13 <mgsloan> Also, "stack test" is an alias for "stack build --test"
18:19:02 <dzdcnfzd> Okay. thanks a lot
18:19:09 <mgsloan> welcome!
18:19:34 <mgsloan> We've got some pretty decent docs here: http://docs.haskellstack.org/en/stable/GUIDE.html
18:20:41 <dzdcnfzd> mgsloan: this is a bit out of your purview but how would you interpret the statement in the link above (https://github.com/begriffs/haskell-vim-now)
18:20:59 <dzdcnfzd> sorry: https://github.com/begriffs/haskell-vim-now/wiki/Installation-Troubleshooting
18:21:09 <EvanR> Strukks: top level type sigs help disambiguate, yes
18:21:13 <dzdcnfzd> namely: Vim uses ghc-mod to analyze types in your source files. This relies on your project being built with Cabal's --enable-test flag. You may need to recreate your sandbox and rebuild with this option."
18:21:35 <EvanR> Strukks: otherwise post the code and error
18:22:46 <mgsloan> dzdcnfzd: That seems like very specific advice for a problem that could be caused by many different things
18:23:25 <mgsloan> If you aren't trying to get types from modules that are in the tests, then that isn't the issue
18:23:44 <mgsloan> Also, stack doesn't really have the "configure" step that cabal does, so we can't run into these misconfiguration issues
18:24:23 <mgsloan> (as long as ghc-mod is invoking stack properly)
18:24:27 <dzdcnfzd> I'm sort of stuck because when I first ran into cabal problems, people gave me the advice to just switch to stack. It was great advice, but I now have no idea how to interpret any advice that presumes I'm using cabal
18:24:33 <mgsloan> ghc-mod's stack integration could use some work
18:25:32 <luigy> yeah the setup can be troublesome 
18:26:07 <mgsloan> Yeah, editor support based on stack is still a bit WIP.  Considering that work on stack started only 8 or 9 months ago, I think we're doing pretty good
18:26:09 <Strukks> EvanR: How do you do type signatures for things that don't take any input?
18:29:41 <EvanR> Strukks: if you put a top level type sig, it will likely infer the Enum instance youre dealing with
18:30:01 <EvanR> paste an example code code that needs a type sig
18:30:59 <Strukks> EvanR: http://lpaste.net/150985
18:31:41 <dannny> Strukks just [Kuu],
18:31:54 <dannny> tagurpidiAasta :: [Kuu]
18:31:59 <EvanR> Strukks: do this, [Detsember..Jaanuar]
18:32:27 <Strukks> danny, yeah! :D thanks!
18:32:31 <EvanR> but literally your question, ??? -> should just not be there
18:32:32 <dannny> [Jaanuar..Detsember] actually :)
18:32:45 <EvanR> no he wants it to go backwards
18:32:50 <dannny> ah
18:32:58 <dannny> that will just give [] though
18:33:01 <Strukks> the task was to make a list that has all the month names from the end of the year to the front :D
18:33:17 <dannny> > [9..1]
18:33:19 <lambdabot>  []
18:33:21 <EvanR> frag
18:33:26 <dannny> :P
18:33:30 <EvanR> Strukks: syntax [A..Z] is sugar for
18:33:34 <EvanR> :t enumFromTo
18:33:35 <lambdabot> Enum a => a -> a -> [a]
18:33:44 <EvanR> > ['A'..'Z']
18:33:45 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
18:34:05 <EvanR> so use that and reverse
18:34:22 <Strukks> well the map toEnum works as well now
18:34:42 <dannny> [maxBound .. minBound] would have worked as well
18:34:53 <Strukks> but the solution you suggested is indeed prettier :D
18:34:55 <EvanR> Strukks: extra points for less code ;)
18:35:11 <exio4> > ['Z', 'Y'..'A']
18:35:13 <lambdabot>  "ZYXWVUTSRQPONMLKJIHGFEDCBA"
18:35:21 <exio4> no reverse needed
18:35:23 <Strukks> I'm not getting any points from these tasks sadly ^^
18:35:30 <Strukks> cramming for an exam
18:35:41 <dannny> > [maxBound .. minBound] :: Char
18:35:43 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[t0]’
18:35:43 <lambdabot>      In the expression: [maxBound .. minBound] :: Char
18:35:51 <dannny> > [maxBound .. minBound] :: [Word8]
18:35:54 <lambdabot>  []
18:36:00 <dannny> i am dumb
18:36:09 <Strukks> > [1 ..]
18:36:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:36:16 <Strukks> I had to try
18:36:23 <exio4> > [maxBound , pred maxBound ... minBound] :: [Char] 
18:36:25 <lambdabot>      Couldn't match type ‘p0 a0 (f0 b0) -> s0 -> f0 t0’ with ‘Char’
18:36:26 <lambdabot>      Expected type: Char
18:36:26 <lambdabot>        Actual type: Over p0 f0 s0 t0 a0 b0
18:36:40 <EvanR> barf
18:36:48 <dannny> Strukks it is an infinite list too I think because it defaults to Integer
18:37:06 <exio4> > [maxBound , pred maxBound .. minBound] :: [Word8] 
18:37:09 <lambdabot>  [255,254,253,252,251,250,249,248,247,246,245,244,243,242,241,240,239,238,237...
18:37:23 <EvanR> Strukks: [1 ..] is sugar for
18:37:25 <dannny> cool
18:37:29 <EvanR> :t enumFrom
18:37:31 <lambdabot> Enum a => a -> [a]
18:38:39 <Strukks> Mhm, I just read about Enum on Hoogle before I asked here :D
18:39:30 <dannny> > ['\0'..]
18:39:32 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
18:43:04 * hackagebot spatial-math 0.2.6.0 - 3d math including quaternions/euler angles/dcms and utility functions  https://hackage.haskell.org/package/spatial-math-0.2.6.0 (GregHorn)
18:43:06 * hackagebot casadi-bindings 2.4.1.7 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.7 (GregHorn)
18:47:44 <dmj> anyone here use opaleye w/ AWS redshift?
18:53:00 <hellertime> the 7.10.3 official haskell docker image can't come soon enough. my companies build server has locked down outbound conns, even to the pgp keyservers! :(
18:53:47 <coconut> any library that permits to traverse directory tree and process each file with my function ?
18:54:13 <dmj> hellertime: use stack on CircleCI
18:54:31 <dmj> coconut: what is your function?
18:54:38 <bitemyapp> dmj: I gave up Opaleye due to boilerplate fatigue.
18:54:44 <dmj> bitemyapp: yea?
18:54:50 <dmj> what about opaleye-sot
18:54:52 <luigy> opaleye-sot no?
18:54:54 <luigy> yeah
18:54:57 <bitemyapp> we tried that
18:54:59 <dmj> yea?
18:55:02 <coconut> for example, i want to do words histogram on txt files
18:55:04 <bitemyapp> hairy & noisy still
18:55:11 <bitemyapp> Back to Persistent+Esqueleto.
18:55:29 <hellertime> @dmj no. using jenkins
18:55:29 <lambdabot> no . using jenkins
18:55:34 <dmj> bitemyapp: maybe it needs a type level DSL
18:55:52 <dmj> hellertime: why not use stack and let it download ghc-7.10.3
18:55:53 <luigy> servantify all the things
18:55:53 <bitemyapp> I don't think it needs more bling
18:56:03 <bitemyapp> maybe I'm wrong
18:56:07 <bitemyapp> I gave up Servant too
18:56:15 <dmj> bitemyapp: really?
18:56:24 <dmj> why
18:56:25 <bitemyapp> hitting a brick wall with "set a cookie" set off my alarms
18:56:40 <bitemyapp> we're building a product for a business, I'm not a grad student with time to burn.
18:57:38 <hellertime> @dmj: _all_ outbound conns are banned, except to the nexus server and to the apt-cache mirror … and to the docker registry proxy :)
18:57:39 <lambdabot> Unknown command, try @list
18:57:42 <bitemyapp> because if setting cookies is, "oh maybe the next major version", then I am now worried about literally everything else I'm going to need to be able to do with the library.
18:57:51 <dmj> bitemyapp: you should've hit me up, I could give you a header combinator for set-cookie
18:57:55 <bitemyapp> it's unfortunate because it seemed really nice and like where things should head
18:58:14 <bitemyapp> dmj: that doesn't dispose with the concern I detailed, but I do appreciate it.
18:58:40 <dmj> bitemyapp: it does though, since Set-Cookie belongs on outbound headers
18:59:08 <bitemyapp> you're not reading what I'm saying then
19:02:03 <dmj> bitemyapp: I mean, there isn't (in 4.0) a function like "setCookie" to my knowledge
19:02:49 <dmj> but it wouldn't be bad to write one
19:04:16 <dmj> bitemyapp: it's a header though right
19:05:10 <Welkin> bitemyapp: persistent :P
19:05:14 <Welkin> it's what I use and prefer too
19:16:34 <Lokathor>  Expected type: ServerRoom -> STM ServerRoom
19:16:35 <Lokathor>       Actual type: ServerRoom -> ServerRoom
19:16:50 <Lokathor> which of the billion utility functions should i use in this situation? I forget
19:18:17 * hackagebot yesod-markdown 0.11.0 - Tools for using markdown in a yesod application  https://hackage.haskell.org/package/yesod-markdown-0.11.0 (PatrickBrisbin)
19:18:27 <Lokathor> return .
19:18:30 <Lokathor> nice
19:19:26 <bitemyapp> Welkin: :D
19:23:17 * hackagebot spatial-math 0.2.7.0 - 3d math including quaternions/euler angles/dcms and utility functions  https://hackage.haskell.org/package/spatial-math-0.2.7.0 (GregHorn)
19:23:18 <dmj> bitemyapp: I still recommend giving servant another shot
19:28:31 <Lokathor> montanonic, this module seems good enough for now, https://github.com/Strifepad/groupedit/blob/master/src/Groupedit/Data.hs
19:28:49 <Lokathor> now to work on weaving it all together with some websocket magic
19:37:50 <Shockk> hello, I'm getting an error that I don't really understand and it's for the code in the happstack-foundation example video (which works in the video)
19:38:05 <Shockk> I've got: newtype ObjectId = ObjectId { unObjectId :: Integer } deriving SafeCopy
19:38:31 <Shockk> but I get the following compilation error from that:
19:38:38 <Shockk> https://gist.github.com/shockkolate/c7140c3bb0b0acbe9d1b
19:43:16 <Sonarpulse> will dependent haskell allow us to write type class instances like "the composition of two functors is also a functor" ?
19:43:17 <pavonia> Shockk: Seems to be a bug https://github.com/acid-state/safecopy/issues/12
19:43:19 <geekosaur> I think I see where it comes from, but have no idea what it is trying to tell you aside from "there's something wrong with SafeCopy"
19:44:00 <Sonarpulse> i.e. instances for type-level lambdas
19:44:26 <bitemyapp> liking something is different from it making business sense.
19:44:50 <ReinH> Sonarpulse: we can already do that without dependent types.
19:44:53 <Shockk> ahh I see, thanks 
19:45:02 <ReinH> https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html
19:45:56 <geekosaur> ...actually I wonder if just making it specify the role as representational would work
19:46:15 <geekosaur> (change has to be made to SafeCopy, not to your code)
19:46:20 <Shockk> oh
19:46:23 <Shockk> I was about to ask lo
19:46:25 <Shockk> lol*
19:47:08 <byorgey> ReinH: perhaps Sonarpulse means doing that *without* having to make a newtype
19:47:31 <ReinH> byorgey: would dependent haskell help us do that?
19:48:19 <geekosaur> I'm not sure it's the right fix, though, just one that would make it work. (in older ghc there was no such concept and that meant you could do unsafe things. so roles were added to let it know when it was safe and when not. what I don't know is if it is actually safe or if SafeCopy was taking advantage of a hole in the type system that got closed
19:48:49 <byorgey> No, I don't think it would.  The fact is that type-level lambdas make type inference undecidable.  Adding dependent types doesn't really help.
19:50:51 <montanonic> Thanks Lokathor, I'll be consulting that shortly.
19:54:07 <dolio> If the composition of Functors is a Functor without a newtype designating it, what does `fmap (\x -> (x, x)) [Just 1, Nothing]` do?
19:57:34 <jle`> i'm not a huge fan of this notation for the documentation
19:57:36 <jle`> (Functor f, Functor g) => Functor (Compose * * f g)
19:57:51 <jle`> maybe once explicit type application hits we can do Compose @* @* f g
19:59:05 <jle`> wait that's wrong too
19:59:13 <jle`> oh wait no that should be right
20:00:06 <pavonia> Is that a bug in haddock?
20:00:35 <jle`> i'm not sure if it's a bug because this sort of notation happens everywhere
20:00:52 <crough> jle`: Isn't it packages that have kind signatures turned on?
20:01:04 <geekosaur> yeh, it;'s rewriting kind signatures into that
20:01:13 <Reshi> If I download a package (like llvm-general) from its git repository and want to install it into my ~/.cabal pkg database, I should use runhaskell Setup configure..build..install, right ?
20:01:14 <geekosaur> IIRC it's technically correct? but hard to understand
20:01:43 <geekosaur> Reshi: cabal install, run in the directory with the cabal file and without a package name
20:01:44 <jle`> Compose * * f g is suposed to be a type signature, and it's a bit weird because Compose takes two arguments
20:01:50 <jle`> it makes sense if you interpret it as Compose @* @* f g
20:02:02 <Sonarpulse> byorgey yeah, without newtype is exactly what i mean
20:02:05 <geekosaur> you could do it the other way but you need: runhaskell Setup.hs configure --user
20:02:28 <geekosaur> and it won't install dependencies, just whine and die
20:02:29 <jle`> actually, nevermind, Compose isn't poly-kinded, so that interpretation doesn't make sense
20:02:34 <jle`> i don't understand at all anymore
20:02:52 <crough> jle`: it's a constraint on the kind that can be given to f and g (which is 0th)
20:03:07 <Reshi> geekosaur: Oh thanks! Didn't know a simple 'cabal install' would work too.
20:03:29 <jle`> i had thought that it was Compose :: forall a b c. (b -> c) -> (a -> b) -> (a -> c) or something
20:03:42 <crough> naw, it composes functors
20:03:42 <jle`> crough: oh i see, only c is determined ...
20:03:49 <crough> so that fmap . fmap just becomes fmap for a whiile
20:03:49 <Sonarpulse> byorgey as i understand it, we don't really have type-level lambdas today, but we must with dependent haskell
20:03:56 <jle`> so it's Compose :: forall a b. (b -> *) -> (a -> b) -> (a -> *)
20:04:01 <Sonarpulse> so maybe it will work with UndecidableInstances?
20:04:26 <EvanR> wouldnt type level lambdas make type level turing complete
20:04:29 <crough> jle` nothing to do with functions though 
20:04:39 <crough> jle` it's not function composition, it's functor composition
20:04:50 <jle`> crough: yeah, that's the kind signature
20:04:54 <jle`> :k Compose
20:04:57 <lambdabot>     Not in scope: type constructor or class ‘Compose’
20:05:04 <jle`> @let import Data.Functor.Compose
20:05:06 <lambdabot>  Defined.
20:05:09 <jle`> :k Compose
20:05:11 <lambdabot> (* -> *) -> (* -> *) -> * -> *
20:05:12 <crough> jle` but I don't think it's using data kinds, is it?
20:05:17 <jle`> huh it fixes it to * here
20:05:18 <crough> sorry, polykinds
20:05:35 <Sonarpulse> EvanR: depends what sort of recursion is allowed, not sure what the plan is
20:05:39 <jle`> well, when what does the * * mean when it says Compose * * f g ?
20:06:05 <jle`> it must be poly-kinded, and for that instnace, a and b are * and *
20:06:23 <jle`> hm on my ghci it's not polykinded so now i'm confused
20:06:29 <crough> yeah so am i
20:06:30 <crough> haha
20:07:33 <jle`> i wonder how to check what transformers version i have installed
20:09:40 <jle`> oh i'm on 0.4.2.0
20:09:45 <geekosaur> ghc-pkg list transformers
20:10:07 <ReinH> EvanR, Sonarpulse: Haskell's type level is already turing complete https://wiki.haskell.org/Type_SK
20:10:09 <jle`> ah hah! https://hackage.haskell.org/package/transformers-0.4.2.0/docs/Data-Functor-Compose.html
20:10:46 <jle`> @let data Comp f g a = Comp (f (g a))
20:10:48 <lambdabot>  Defined.
20:10:51 <jle`> :k Comp
20:10:53 <ReinH> Well, GHC's with some extensions is.
20:10:54 <lambdabot> (k -> *) -> (k1 -> k) -> k1 -> *
20:10:56 <jle`> ah haaaah
20:11:00 <EvanR> i knew undecidable instances was the secret ingredient
20:11:09 <ReinH> EvanR: of course it is :)
20:11:27 <ReinH> I mean, it's right there in the name ;)
20:11:58 <jle`> @let data Comp :: (b -> *) -> (a -> b) -> (a -> *) where Comp :: f (g a) -> Comp f g a
20:12:00 <lambdabot>  Defined.
20:12:05 <jle`> :k Comp
20:12:07 <lambdabot> (k -> *) -> (k1 -> k) -> k1 -> *
20:12:09 <jle`> aw
20:12:12 <EvanR> i wonder what practical shenanigans, i mean problems you can solve with undecidable instances
20:13:34 * geekosaur suddenly thinks of the guy in SCS who was infamous for abusing C++ templates
20:17:12 <Sonarpulse> EvanR: if one could do type lambda instances, that would be enormously practical
20:17:24 <Sonarpulse> no more lift . lift
20:17:27 <Sonarpulse> fmap . fmap
20:17:39 <jle`> Sonarpulse: enourmously impractical
20:17:43 <jle`> because sometimes you want fmap to mean fmap
20:18:04 <Sonarpulse> i mean it still will
20:18:07 <jle`> there's a reason why we have both fmap and fmap.fmap
20:18:22 <jle`> if fmap automatically meant fmap.fmap, then we're in a lot of trouble, practicality-wise
20:19:03 <Sonarpulse> other than the issues of undecidable instances itself, and perhaps a few more type annotations
20:19:06 <montanonic> what would be nice is a `fmapN` function
20:19:06 <Sonarpulse> i don't see a downside
20:19:12 <montanonic> that takes an int
20:19:14 <jle`> fmap (\x -> (x, x)) [Just 1, Nothing]   -- should that be [Just (1,1), Nothing], or [(Just 1, Just 1), (Nothing, Nothing)] ?
20:20:09 <Sonarpulse> might be clear from context
20:20:27 <montanonic> `fmapN 2 (+1) [ [], [3,4], [5] ]` = [ [], [4,5], [6] ]
20:20:29 <EvanR> montanonic: er... not sure if that can be well typed
20:20:39 <montanonic> EvanR: wouldn't it be with dependent typing?
20:20:41 <jle`> Sonarpulse: i think it makes more sense to be explicit about what we want
20:20:56 <jle`> that's why we have / and div, separately
20:20:56 <EvanR> montanonic: maybe with enough prior setup
20:20:59 <Sonarpulse> i suppose with fmap i am sympathetic
20:21:05 <EvanR> but not comparible with existing functor types
20:21:09 <Sonarpulse> but the effects crowd already says lift as noise
20:21:11 <EvanR> compatible
20:21:11 <montanonic> EvanR: okay, fair point
20:21:13 <Sonarpulse> *sees
20:21:13 <jle`> we have / and div because they do two different things, and we want to specify when we want one behavior over the other
20:21:36 <jle`> taht's why we don't have a Num a => Num [a] instance by default
20:21:47 <EvanR> montanonic: kind of like the "i want a variable length tuple" vs HList thing
20:21:49 <jle`> [1,2,3] + [2,3,4], should that be liftA2 (+), or zipWith (+) ?
20:22:00 <montanonic> EvanR: right
20:22:20 <montanonic> why do people even use lift . lift; why not just define lift2 = lift . lift and so on
20:22:27 <montanonic> same with fmap
20:22:38 <EvanR> possible
20:22:52 <montanonic> it's one-time boilerplate
20:22:56 <EvanR> but people like to compose stuff on the spot
20:23:14 <Sonarpulse> montanonic: if you stick it in a library I'll use it :)
20:23:34 <montanonic> Sonarpulse: :) ; I guess I just don't understand why those aren't *already* library features
20:23:36 <EvanR> [1,2,3]+[2,3,4] = [1,2,3,2,3,4] obv
20:23:59 <montanonic> if there's something I'm missing; we enumerate the crap out of tuples, don't see why we don't for fmap and lift as well.
20:24:14 <Sonarpulse> jle well there is only one way to compose functors
20:24:28 <Sonarpulse> just like there is only one way to define a functor for a type
20:24:37 <glguy> montanonic: You wouldn't need dependent types to do fmapN 2 if you did it as type level application: fmapN @2
20:24:43 <EvanR> montanonic: theres kind of no other way to write the tuple functions
20:24:50 <glguy> montanonic: dependent types would come in if you wanted to pick the level of fmap at runtime
20:25:00 <jle`> Sonarpulse: i meant, choosing to say what you mean explicitly is better, implicit coersion is sort of not the best thing
20:25:08 <jle`> Sonarpulse: in the fmap (\x -> (x,x)) [Just 1, Nothing] example
20:25:17 <Sonarpulse> yeah i like that example better
20:25:22 <jle`> it's like implicitly coercing the fmap to be (fmap.fmap)
20:25:29 <jle`> but what if i really did want fmap?
20:25:41 <montanonic> glguy: interesting; and I've seen something on SO where they did a type-level thing like that, though I can't remember the thread
20:25:46 <EvanR> ah right haskell has a lot of depdent-ish type level stuff already
20:25:49 <jle`> if i want fmap, i can say fmap, and if i want (fmap.fmap), i can say (fmap.fmap)
20:25:49 <Sonarpulse> well `/\t. F (G t)` IS a functor
20:26:01 <Sonarpulse> we're not coericing it to a functor
20:26:14 <Sonarpulse> we're just creating the instance that could have existed all along
20:26:29 <jle`> yeah, but which instance would we want to use in the situation here?
20:26:50 <Sonarpulse> 1-1 mapping between instance and type of expression
20:27:04 <Sonarpulse> so if you want to be term level explicit
20:27:16 <Sonarpulse> can always do :: <something>
20:27:57 <Sonarpulse> to put it different, we are infereing a dictionary which has only one inhabitant
20:28:13 <Sonarpulse> I am not ok with infering non-injective coersions
20:28:41 <Sonarpulse> I am slightly more ok, but still against, infering injective but not surjective coersions
20:28:51 <Sonarpulse> I am even more slightly ok with inferring isomorphisms
20:29:12 <Sonarpulse> I am definitely ok with infering the sole inhabitants of types
20:29:25 <Sonarpulse> jle` that is my spooky implicit hierarchy :)
20:29:57 <EvanR> -XSpookyImplicitHierarchy
20:30:05 <Sonarpulse> -XScala
20:30:57 <fsochade> If any of you remember me, I'm that guy that was asking about Haskell earlier today. I know HTML/CSS, JavaScript, some Python, some Java/C#, very little C?
20:31:27 <montanonic> fsochade: it will be like learning to program again
20:32:00 <EvanR> learn to program all over again... this summer: Haskell
20:32:40 <fsochade> I installed haskell-stack and am so pumped to dig into Yorgey's CIS 194 course
20:32:59 <Lokathor> fsochade, make sure you use the Spring13 version
20:33:06 <Lokathor> the other version is a lot more confusing
20:33:30 <fsochade> I am
20:33:38 <fsochade> http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
20:33:44 <Lokathor> yep yep
20:33:47 <fsochade> Awesome.
20:33:50 <montanonic> woot
20:33:52 <montanonic> have fun
20:34:01 <jle`> Sonarpulse: what about a Functor instance for \t -> (t, a) ?
20:34:02 <fsochade> Just trying to think about functional programming hurts my brain
20:34:12 <Lokathor> For those who care to have a look, https://github.com/Strifepad/groupedit, a group text editing websocket thingy, fresh off the presses. Feel free to file issues on how i don't use enough MonadTransformers :P
20:34:19 <fsochade> I've had OOP knocked into my head for so long
20:34:20 <jle`> Sonarpulse: what about fmap (+2) (5,6) :: (Int, Int) ?
20:34:29 <montanonic> fsochade: don't forget, #haskell-beginners is specifically catered to helping out noobs; though you can ask anything here as well
20:34:30 <EvanR> fsochade: soon it will be the opposite
20:34:45 <jle`> Sonarpulse: if we had a Functor instance for (,a), then it would be either (7, 6) or (5, 8)
20:34:50 <jle`> even with a type signature, it doesn't help
20:35:16 <EvanR> and then you can start the long road back to OOP, with a different perspective
20:35:25 <jle`> Sonarpulse: but, there is only one unique "functor" for (,a)
20:35:41 <Lokathor> jle`, can you even write an instance for (,a) like that? doesn't it have to be (a,) ?
20:35:43 <fsochade> Someone said earlier today that Java did OOP wrong. What do you think they meant by that?
20:36:19 <Lokathor> fsochade, there's lots of ways to envision OOP, and Java does one of them. inevitably someone will think it's wrong somehow :P
20:36:28 <EvanR> Lokathor: newtype Foo t a = Foo (\t -> (t,a))
20:36:39 <Lokathor> oh hmm
20:36:50 <jle`> Lokathor: that's the point
20:36:51 <EvanR> instance Functor (Foo t) where
20:36:53 <jle`> of the discussion, at least
20:36:53 <fsochade> Lokathor, I guess you're right. I didn't know if Haskell did it some radically different way.
20:37:03 <jle`> Lokathor: we were talking about "what if it was okay that we had (,a)"
20:37:15 <jle`> or, that we had type leval lambdas, like \t -> (t, a)
20:37:31 <jle`> and i'm saying that bad things happen! :O
20:37:33 <Lokathor> fsochade, Haskell doesn't do OOP at all. You could make OOP-ish things in Haskell, but you often wouldn't want to just because it wouldn't be the "natural" way to do things
20:37:59 <EvanR> Lokathor fsochade: not necesarily
20:38:17 <EvanR> you can express the interface-implemntation pattern using records
20:38:26 <EvanR> and functions
20:38:27 <Lokathor> jle`, i'll trust. type level stuff is where i start to get squirrly and clutch onto ghc like a safety blanket
20:39:06 <EvanR> you can express concurrent communicating (message passing) processes using concurrent haskell
20:39:25 <EvanR> it kind of forces you to decide what OOP is
20:39:43 <EvanR> subtyping is out though
20:40:09 <Lokathor> hmm
20:40:24 <Lokathor> could you use a very complex typeclass tree as your class/subclass tree?
20:40:39 <EvanR> thats a bad antipattern
20:40:43 <montanonic> EvanR: isn't using records and functions that way the same thing as using typeclasses?
20:40:56 <montanonic> like, not exactly the same of course, but, you know
20:40:56 <EvanR> not practically
20:41:34 <EvanR> you can only implement a type class one way for a given type, but with a record, you dont even care what the hidden type is, if any
20:42:16 <EvanR> you can mix and match implemntations at will, imagine the different between using a Show constraint, and accepting a String argument
20:42:50 <EvanR> the string argument is more flexible
20:43:04 <mgsloan> Or rather, the (a -> String) argument
20:43:19 <EvanR> () -> String is just String in haskell
20:43:23 <EvanR> cuz lazy
20:43:44 <EvanR> if the "show" functionality were in a record interface, youd just use String
20:43:45 <Lokathor> anyway, when you take away the superclassing/subclassing, a lot of the "patterns" of OO are pretty simple higher-order functions in Haskell
20:43:48 <montanonic> EvanR: I see, thank you 
20:43:58 <Lokathor> like visitor or strategy or what have you
20:44:02 <mgsloan> Yeah, (forall a. Show a => a) is also roughly equivalent to 'String' (modulo showsPrec / showList)
20:45:21 <EvanR> whatever creates the String could use Show machinery behind the scenes if it wants
20:45:42 <nitrix> Is it possible to have a class `Foo (f :: *)` ?
20:45:54 <jle`> or, that we had type leval lambdas, like \t -> (t, a)
20:45:58 <nitrix> If so, what would be an example of such class?
20:46:17 <ggVGc> montanonic: what's the real difference between subclassing and just f(g(x)) where f "inherits" g
20:46:40 <EvanR> subclassing is kind of an import mechanism
20:46:53 <montanonic> ggVGc: I never learned OOP; sorry. Haskell is my first language.
20:47:13 <ggVGc> ah right
20:47:16 <ggVGc> cool
20:47:31 <ggVGc> EvanR: I don't see the practical difference
20:54:03 <EvanR> ggVGc: between what, I'm not sure how f(g(x)) is inheritance
20:55:13 <ReinH> how would f "inherit" g?
20:55:35 <ggVGc> EvanR: uhm, the way I see it if A is a type and B is a type that inherits, then calling A on some argument gives you an instance of A, and B, given an instance of A, returns an instance of B
20:56:12 <ggVGc> if both A and B are constructors for some object, then it's inheritance
20:56:15 <EvanR> A(_) being the cons
20:56:17 <ggVGc> the way I see it
20:56:20 <EvanR> tructor
20:56:43 <EvanR> ok, so "object/class composition"
20:58:19 <ggVGc> I'm just saying I think inheritance in OO languages is pretty much type level function calls
21:02:10 <EvanR> ggVGc: the way its used is like... import myModule (and perhaps get "private globals")
21:14:08 <glguy> montanonic: Are you still around?
21:14:35 <montanonic> glguy: yeah; I don't remember what I was talking about though
21:14:57 <glguy> http://lpaste.net/150987
21:15:11 <glguy> montanonic: Sketch of the fmapN thing being discussed earlier
21:15:23 <montanonic> glguy: oh, dope; looking
21:15:29 <jle`> fmapN would be nice
21:15:48 <montanonic> glguy: I have *NO* idea what Proxy does
21:15:49 <glguy> it's a little rough, wouldn't recommend actually using that code, but that's where I got to just now
21:15:58 <glguy> montanonic: ignore it
21:16:03 <montanonic> okay :)
21:16:16 <glguy> there, I deleted it, I wasn't actually using it
21:16:25 <montanonic> haha
21:16:26 <xnil> When is it preferred to use a $ b $ c $ d over a . b . c $ d ?
21:16:35 <jle`> i can't imagine when it would be preferred
21:16:47 <jle`> oh, when you have some Rank-N type shenanigans
21:16:55 <xnil> ok! thanks. i thought so too but see it far too often
21:16:59 <jle`> then (a . b . c) wouldn't typecheck
21:17:20 <xnil> sometimes you run into issues, though
21:17:20 <jle`> but a $ b $ c $ d would
21:17:23 <glguy> xnil: I'll use chains of $ sometimes when lining up things under the $ vertically
21:17:33 <jle`> but, in general, (a . b . c) d makes more sense .......
21:17:38 <jle`> but this is a personal style choice       ...
21:17:40 <xnil> glguy: what do you line up vertically?
21:17:47 <glguy> a (b c) is pretty cool
21:17:51 <jle`> but    ..  .      ... peope have strong opinions
21:18:14 <bitemyapp> popes usually do
21:18:22 <xnil> popinions
21:18:23 <glguy> http://lpaste.net/150989 xnil
21:18:47 <xnil> why not this, glguy? http://lpaste.net/150989
21:19:06 <glguy> xnil: I don't find the inconsistency to be an improvement
21:19:15 <xnil> it's more consistent than your solution.
21:19:24 <xnil> it's not a "special case"
21:19:27 <glguy> xnil: If I find   a . b . c . d $ x, I'm more likely to want to name the a.b.c.d part
21:19:28 <xnil> and say you have:
21:19:32 <glguy> and then apply that named thing to x
21:19:53 <glguy> xnil: I'm not interested in debating the topic, though
21:19:55 <xnil> http://lpaste.net/150989
21:20:00 <glguy> You just asked when people do it
21:20:10 <xnil> i'm trying to find the reason underlying
21:20:23 <xnil> i believe i see your side and disagree, but am just making sure that's what your side is
21:22:43 <Cale> I'm a fan of the  f . g . h $ x  style fwiw
21:23:06 <Cale> It has the nice property that as many substrings as possible are also effectively subexpressions because of the associativity of (.)
21:23:14 <xnil> ^
21:23:16 <glguy> I'll use that too, I draw the line at   f . g $ x   over f (g x)
21:23:24 <xnil> but you also get this nasty
21:23:42 <xnil> a . b . c $ d = a $ b $ c d
21:23:47 <xnil> >c d
21:23:50 <Cale> Yeah, if it's just two functions being composed, it's debateable.
21:23:50 <glguy> I've never struggled to change a $ to a . to extract a substring and name it
21:24:04 <glguy> I'm pretty good at vim, though :-p
21:24:05 <jle`> a $ b $ c d    i personally can't stand, but
21:24:09 <xnil> same, jle` 
21:24:11 <Cale> I just don't like relying on the fact that ($) has the wrong associativity :)
21:24:32 <xnil> wow, #rekt
21:25:16 <bitemyapp> #Caled
21:26:00 <Cale> It would be nice if it were the other way, because for one, there would be more cases where you could avoid parens, but more importantly, if both ($) and ($!) were left associative, strict application with multiple parameter functions would be less annoying
21:28:57 <Cale> Also, including function application itself, function-application-like stuff just always has a tendency to associate to the left. (<*>) associates to the left, for instance. I still regard it as kind of a weird accident that ($) happened to be defined infixr
21:31:49 <EvanR> Bob the Monadic Lover
21:32:06 <EvanR> what in the world
21:32:44 <julianleviston> haha 
21:32:48 <julianleviston> it’s a bit odd isn’t it?
21:35:26 <EvanR> "This is especially true with a kind of a type like our Bob, whose activity can be quite difficult to track."
21:38:22 * hackagebot ChannelT 0.0.0.1 - Generalized stream processors  https://hackage.haskell.org/package/ChannelT-0.0.0.1 (pthariensflame)
21:40:00 <julianleviston> EvanR: what a character, that bob ;)
21:43:09 <EvanR> its kind of turning into a bad Functor tutorial
21:46:00 <julianleviston> I found that tutorial really opaque.
21:46:13 <julianleviston> like tricky to understand. But that’s probably just me.
21:46:27 <coconut> when should we use sequence instead of list ?
21:46:44 <coconut> i know that sequence has fast append operations
21:46:45 <jle`> do you mean Data.Sequence ?
21:46:49 <coconut> yes
21:46:51 <julianleviston> I think s/he does.
21:47:01 <jle`> well, Seq can't have infinite lists
21:47:04 <julianleviston> coconut: there’s a function called sequence, too.
21:47:04 <jle`> er, infinite itsems
21:47:05 <coconut> jle`, Data.Sequence in the containers package
21:47:27 <jle`> so lists are useful for "streaming" interfaces, where you want to lazizily generate the rest of the list one item at a time
21:47:35 <jle`> that's pretty much the only time lists are useful
21:47:45 <julianleviston> jle`: and for learning! :)
21:47:46 <jle`> so any other time, Sequence probably makes more sense
21:47:49 <jle`> lazizily
21:47:49 <coconut> jle`, wow
21:48:08 <coconut> jle`, so all this time i can use sequence over lists...
21:48:10 <jle`> or well, Sequence, or Vector, or IntMap, etc.
21:48:12 <EvanR> well Sequence also has more overhead than list for prepend, pop
21:48:20 <julianleviston> jle`: although I’m actually not super convinced list is better for learning.
21:48:26 <coconut> they should put it in the i wish i had knew tutorial
21:48:28 <EvanR> so if you just want a stack, use list
21:48:47 <jle`> yeah, lists are really good at acting like "streams", repeatedly popping from a lazy list of values
21:49:11 <jle`> and yeah, pushing is also nicer
21:49:12 <julianleviston> coconut: I guess it’s implied you’ll know that a list is a singly-linked list… and that you’ll know what that’s used for.
21:49:40 <jle`> well, the thing is that there aren't *too* many situations where Sequence is better than list, but Vector isn't better than Sequence
21:49:59 <jle`> Seq is kind of in an awkward space, which is why it isn't super common
21:50:02 <crough> jle` foldr fusion though!
21:50:23 <julianleviston> oh yeah list fusion.
21:50:39 <coconut> jle`, i was learning a directory walk code and it says: Traverses a directory tree, just like 'pathWalk'.  The difference
21:50:40 <coconut> -- is that each callback returns a 'Monoid' value, all of which are
21:50:40 <coconut> -- accumulated into the result.  Note that this uses 'WriterT' and
21:50:40 <coconut> -- thus frequently appends to the right of the monoid.  Be careful to
21:50:40 <coconut> -- avoid accidental quadratic behavior by using a data structure that
21:50:41 <coconut> -- supports fast appends.  For example, use Data.Sequence instead of a
21:50:43 <coconut> -- list.
21:51:27 <julianleviston> hey are there any other types like list that do the surrounding thing? as in… 
21:51:40 <julianleviston> Just 5 :: Num a => (Maybe a)
21:51:49 <EvanR> julianleviston: lol... the relevation when bob starts with whatever number of "times" but an empty set of names, reminds the author of a philosopher who "talked about this stuff all alone" ... namely Leibniz and his "Monads"
21:51:55 <julianleviston> versus [5] :: Num a => [a]
21:52:07 <julianleviston> versus the rewritten [5] :: Num a => [] a ?
21:52:13 <kadoban> julianleviston: I think it's the only one.
21:52:15 <julianleviston> is list special there?
21:52:21 <julianleviston> yeah I couldn’t think of a case either. hm ok
21:52:22 <jle`> yeah, list is actually specially syntactic sugar there
21:52:47 <jle`> that's why you won't find a data [] a = [] | a:[a] anywhere, i think
21:53:07 <julianleviston> jle`: huh? isn’t that actually the way it’s described?
21:53:16 <jle`> it's not syntactically valid
21:53:22 <jle`> it has to be magical
21:53:27 <EvanR> data [a] = [] | a:[a]
21:53:28 <jle`> @let dat [] a = [] | a:[a]
21:53:29 <lambdabot>  Parse failed: Parse error: |
21:53:31 <EvanR> hehe
21:53:32 <jle`> @let data [] a = [] | a:[a]
21:53:32 <lambdabot>  Parse failed: Illegal data/newtype declaration
21:53:34 <julianleviston> jle`: ok. 
21:53:46 <julianleviston> eternal noobie :)
21:53:55 <jle`> that's actually the way it's described, yeah, and you can imagine it's like that
21:54:06 <julianleviston> but it’s not haskell without sugar. gotcha
21:54:06 <jle`> but you can't actually implement it that way within haskell
21:54:19 <jle`> it has to be built into the compiler, unfortunately
21:54:24 <kadoban> julianleviston: Well it's pretty fair that you don't know this … it's about as magical as anything gets in haskell AFAIK.
21:54:34 <julianleviston> EvanR: haha I thought that was slightly the point… about Monads… but I’m not sure. It’s been a while since I’ve read that.
21:54:40 <kadoban> I guess tuple is kind of magic too? That's all that comes to mind.
21:54:56 <julianleviston> kadoban: well I did kinda know it was magic, I was just wondering if there were others.
21:55:12 <magic> Programmers talk a surprising amount about magic
21:55:22 <julianleviston> LOL
21:55:28 <julianleviston> sugar is magic.
21:55:31 <julianleviston> where does it come from? :)
21:57:30 <EvanR> julianleviston: its funny to bring up leibniz though, hundreds of years before categories
21:57:36 <crough> tuple and list are magic because they're very, very old 
21:58:13 <julianleviston> magic: I can’t hear the word magic these days without thinking of shia labeof: https://www.youtube.com/watch?v=m1wKxHQmBAg
21:58:22 * hackagebot ChannelT 0.0.0.2 - Generalized stream processors  https://hackage.haskell.org/package/ChannelT-0.0.0.2 (pthariensflame)
21:59:03 <EvanR> julianleviston: also, you can create your own syntax sugar with something like idris, during the parse phase generate new parsers and store them for the next round of parsing
21:59:23 <EvanR> making it arguably less magical
21:59:31 <julianleviston> EvanR: one day I’ll look at that language… 
21:59:58 <jle`> read the book, it's awesome :O
22:00:35 <jle`> magic: so you're the reason why the word 'magic' is highlighted whenever someone writes it, heh
22:01:22 <kadoban> jle`: Your client highlights any nicknames? Hmm … how can I use this information for evil *ponders*
22:01:42 <jle`> yes, the weirdest words get highlighted sometimes, heh
22:01:46 <jle`> well, it's a plug-in i have instaled
22:04:31 <lethjakman-l> is there a built in "(#) :: a -> (a -> b) -> b"?
22:05:09 <jle`> yeah
22:05:16 <jle`> Data.Function.&
22:05:30 <jle`> it has different fixity than # from diagrams, i think, though
22:06:26 <lethjakman-l> Ahhh yeah, it's 1
22:07:35 <lethjakman-l> Thank you!
22:08:16 <jle`> np!
22:13:01 <coconut> any haskell tool to modify Excel file? such as append a line to an excel file
22:15:09 <qmm> why is Traversable is a Foldable and Functor, but a Foldable isn't a Functor?
22:15:50 <Cale> qmm: Well, because there are a bunch of instances which can't be.
22:15:55 <Cale> Like Set
22:17:41 <qmm> is a Set Foldable? where would Set fit within this diagram? https://wiki.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png
22:18:35 <shachaf> Data.Set.Set is Foldable but not Functor or Traversable
22:19:00 <shachaf> You can find out about instances with :info in ghci.
22:20:27 <Axman6> coconut: there's a few packages: https://hackage.haskell.org/packages/search?terms=excel I haven't used any so you may need to read the docs and experiment
22:22:16 * CoconutCrab grabs coconut and runs away
22:35:54 <qmm> https://wiki.haskell.org/Do_notation_considered_harmful "jas" should be "has"
22:50:20 <qmm> https://github.com/ghc/ghc/blob/master/compiler/ghci/GHCi.hs#L161 are people generally okay with functions being this long?
22:51:29 <qmm> the functions from l232 to l284 seem to be what i would expect looking at haskell source code: concise
22:57:34 <liste> a <20 line function being considered long is a testament to Haskell's conciseness (:
22:59:51 <SX> wow, it is not long at all
23:00:22 <qmm> if my functions ever get 20 lines long, i'm refactoring
23:01:06 <SX> you could split, but what's the point?
23:01:29 <mgsloan> I wouldn't call that function long.  When we get into mutation / exception handling / interaction with the outside world, things get long
23:01:58 <mgsloan> Sometimes splitting things up makes things less clear, because you need to chase around definitions and then substitute them in your head to figure out what's actually happening
23:02:30 <SX> mgsloan: that's right. IO is generally complex and requires a lot of code to be correct.
23:04:09 <SX> qmm: do you actually write some real world code? with IO and stuff.
23:04:58 <qmm> SX: all the time
23:06:16 <qmm> this guy's presentation does a good job of explaining why i keep it short: https://www.youtube.com/watch?v=CQyt9Vlkbis
23:06:21 <SX> then how would you refactor some encryption function, where you need to generate a lot of data for algorithm? 
23:08:28 <qmm> SX: i don't have familiarity with that
23:12:50 <mgsloan> One advantage of splitting things up is more opportunity for testing, and more opportunity for usage with ghci.  That said, I still often prefer long functions, usually due to long do blocks
23:18:58 <kadoban> When I have a ParsecT String () (Writer Whatever) a,  is the right way to do 'tell':  lift $ tell Something , or am I missing some reason I should be able to just use tell on its own? Is this necessary because there's no MonadWriter instance for the combined ParsecT whatever I guess?
23:20:31 <liste> kadoban you're correct
23:21:37 <kadoban> Okay, thanks. Is it easy to say why there's no instance for that? Just oversight/nobody cared, or?
23:22:40 <liste> good question, there's MonadError, MonadReader and MonadState
23:23:03 <liste> (and MonadIO and MonadCont)
23:23:34 <kadoban> Yeah, MonadCont especially made me wonder, hha.
23:28:56 <lightandlight> Is there a good way to use quickcheck to test parsers?
23:30:32 <lightandlight> I was making an Arbitrary instance that created the input and expected output at the same time, but I was essentially recoding all my parser logic
23:31:27 <jle`> kadoban: looks like an oversight to me
23:33:53 <kadoban> Okay, thanks. I'll see later if there's an easy way to contribute a patch.
23:34:05 <lightandlight> I felt like I was repeating myself too much so I wrote a bunch of examples, but that's also repetitive
23:41:51 <Saizan> lightandlight: parsers are a pain/are easy because they are essentially their own specification, so i guess real worldish test cases is probably the way to go
23:46:06 <kadoban> lightandlight: If you're lucky you at least have available something like a bunch of valid and invalid examples of input. You can just test that the parse fails/succeeds on those.
23:48:29 <lightandlight> kadoban: Yeah, that's basically all I've got right now
