00:07:39 * hackagebot http2 1.4.3 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.4.3 (KazuYamamoto)
00:07:39 * hackagebot hpqtypes 1.4.4 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.4.4 (arybczak)
00:17:45 <frerich> Hm, the support duration of an LTS Haskell series is 3 months at minimum? Maybe I misunderstood what 'LTS' means, but that doesn't seem particularly Long to me.
00:19:09 <fr33domlover> hello! I updated cabal-install-1.24 and now it fails to read .cabal/config
00:19:15 <fr33domlover> anyone has this issue?
00:19:21 <fr33domlover> i'm using hvr's PPA
00:21:59 <fr33domlover> ah, problem solved
00:22:20 <fr33domlover> there was a config format change, it seems
00:22:58 <quchen> What's a Foldable that is not Traversable?
00:24:03 <liste> quchen Set ?
00:24:19 <mniip> ooh that's a good one
00:24:24 <quchen> Oh, right.
00:25:45 <zd234> when using nixos+haskell; is there a way to say "generate docs for all packages nixos installs" ?
00:32:34 * hackagebot postgresql-binary 0.7.5.1 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.5.1 (NikitaVolkov)
00:35:00 <ReinH> quchen: data Store f a b = Store (f a) (a -> b) is Foldable when f is Foldable, but is not Traversable.
00:35:31 <ReinH> quchen: er, that's Coyoneda
00:35:45 <ReinH> oh, no, it isn't existentially quantified
01:07:40 <fr33domlover> Q: My code has a Config type and the user defines an instance of it. That type has a field that should be a list/array/vector of length 16. It's used just once so I don't care whether it's a linked-list or an array, but I'd like to make sure the size is 16 at compile time. I lookd at fixed length array packages and I'm not sure how to use them or which one to pick. Anyone has recommendations?
01:08:48 <fr33domlover> in practicular, all those packages with peano numbers don't provide examples and have scary types :P
01:10:19 <MasseR> fr33domlover: You could probably create a simple vector wrapper for this
01:11:00 <MasseR> Ah, damn, I don't have time to give an example, sorry :<
01:11:39 <fr33domlover> There are already packages that provide fixed-length vector-like types
01:11:50 <fr33domlover> I can just use one of the, just not sure which and how
01:22:54 <srhb> fr33domlover: If it always has length 16, why not just create a custom data type for it?
01:23:03 <srhb> fr33domlover: Even a 16-tuple seems simpler
01:24:55 <fr33domlover> srhb, wheel reinvention. I need to traverse that type and that won't work with tuples. Since my use case is so simple, I think I'll use either 'array' or 'fixed-list' packages
01:25:11 <fr33domlover> but I wish I understood the ones with type-level numbers
01:28:51 <quicksilver> I would just use a list, but hide the constructor
01:29:04 <quicksilver> and force construction via something which checks the length at compile time
01:32:46 <frerich> fr33domlover: I concur with quicksilver, I'd go with something which some people call a 'smart constructor': https://wiki.haskell.org/Smart_constructors
01:37:20 <fr33domlover> frerich, thanks! good link
01:38:26 * hackagebot typelits-witnesses 0.1.2.0 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.1.2.0 (jle)
01:43:27 * hackagebot path-io 0.1.1 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-0.1.1 (mrkkrp)
01:43:29 * hackagebot debian-build 0.9.1.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.9.1.0 (KeiHibino)
01:48:27 * hackagebot persistent-postgresql 2.2.2 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.2.2 (MichaelSnoyman)
02:03:27 * hackagebot optparse-applicative 0.12.1.0 - Utilities and combinators for parsing command line options  https://hackage.haskell.org/package/optparse-applicative-0.12.1.0 (huw)
02:05:49 <Heather> any cabal people around?
02:06:23 <fr33domlover> Heather, just ask your question :-)
02:07:13 <Heather> seems like following code need changes for new Cabal, as far as I understand
02:07:14 <Heather> testDeps :: ComponentLocalBuildInfo -> ComponentLocalBuildInfo -> [(InstalledPackageId, PackageId)]
02:07:14 <Heather> testDeps xs ys = nub $ componentPackageDeps xs ++ componentPackageDeps ys
02:07:31 <Heather> Expected type: [(InstalledPackageId, PackageId)]
02:07:38 <Heather> Actual type: [(Distribution.Package.UnitId, PackageId)]
02:08:59 <Heather> oh just changing InstalledPackageId to UnitId fixes problem but I guess I should guard it with Cabal version
02:11:33 <JamesJRH> Hi. What is the flag to start GHCi with something already imported?
02:12:30 <Heather> how to guard cabal version?
02:13:18 <Heather> #if MIN_VERSION_Cabal ?
02:13:27 * hackagebot typelits-witnesses 0.1.3.0 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.1.3.0 (jle)
02:13:33 <JamesJRH> I don't see it here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html
02:13:58 <merijn> JamesJRH: Just put the import command in your .ghci?
02:14:21 <merijn> JamesJRH: i.e. like: https://github.com/merijn/dotfiles/blob/master/dotfiles/ghci
02:14:26 <JamesJRH> This is a one-off, though.
02:15:00 <merijn> JamesJRH: You can have .ghci files in working directory too
02:15:29 <JamesJRH> Also, I'm actually using -ignore-dot-ghci anyway in this instance.
02:18:27 <Heather> {-# OPTIONS_GHC -Wall -cpp #-} - does it enable LANGUAGE CPP?
02:18:27 * hackagebot typelits-witnesses 0.2.0.0 - Existential witnesses, singletons, and classes for operations on GHC TypeLits  https://hackage.haskell.org/package/typelits-witnesses-0.2.0.0 (jle)
02:19:17 <fr33domlover> Heather, iirc {-# LANGUAGE CPP #-}
02:19:39 <Heather> fr33domlover will it work with runhaskell
02:20:00 <fr33domlover> Heather, idk, give it a try
02:20:21 <Heather> error: missing binary operator before token "("
02:20:21 <Heather> #if MIN_VERSION_Cabal(1, 23, 0)
02:20:27 <Heather> fr33domlover ^
02:24:23 <Heather> with some reason I can't add {-# LANGUAGE CPP #-} to Setup.lhs :S
02:24:31 <JamesJRH> Oh, I've just remembered that I can one-off use things without importing them. E.g.:
02:24:37 <JamesJRH> > Text.Printf.printf "%.5f\n" pi
02:24:39 <lambdabot>      No instance for (Show a0)
02:24:39 <lambdabot>        arising from a use of ‘show_M78651005785495468886685’
02:24:39 <lambdabot>      The type variable ‘a0’ is ambiguous
02:24:55 <JamesJRH> Hmm.
02:25:04 <jle`> you need to  :: String
02:25:10 <jle`> it's polymorphic
02:25:30 <jle`> or at least give some way for GHC to infer that you want it to be a String
02:25:41 <fr33domlover> Heather, you tried putting that in the .hs files? Or specify CPP in the .cabal file (if you wrote one)
02:25:48 <JamesJRH> It worked for me, though, without that: Prelude> Text.Printf.printf "%.5f\n" pi
02:25:48 <JamesJRH> 3.14159
02:26:04 <jle`> JamesJRH: that's because ghci attempts to infer things as IO a
02:26:10 <JamesJRH> > Text.Printf.printf "%.5f\n" pi :: String
02:26:10 <jle`> and so it gets `IO String`
02:26:12 <lambdabot>  "3.14159\n"
02:26:38 <jle`> er i mean, it infers it to be IO () in ghci
02:26:52 <JamesJRH> jle`: Yeah, GHCi printed it as IO.
02:27:05 <Heather> fr33domlover posted to SO http://stackoverflow.com/questions/34874315/set-language-cpp-in-setup-lhs
02:27:08 <jle`> yeah, it inferred it to be an IO action which prints that to stdout, so it executed it
02:27:12 <JamesJRH> Not quoted; no ‘\n’.
02:27:26 <jle`> you can infer it to be the same IO action here, too
02:27:41 <jle`> > Text.Printf.printf "%.5f\n" pi :: IO ()
02:27:42 <lambdabot>  <IO ()>
02:27:48 <jle`> but lambdabot doesn't execute IO actions
02:27:48 <Heather> it's so boring w/o twitter
02:27:54 <JamesJRH> > putStrLn "Hello world."
02:27:55 <lambdabot>  <IO ()>
02:28:01 <JamesJRH> Ah.
02:28:03 <JamesJRH> :-)
02:28:04 <jle`> it just evaluates them enough to 'show' them
02:28:51 <JamesJRH> 10:27:25 < jle`> but lambdabot doesn't execute IO actions  ← I didn't realise that.
02:28:56 <jle`> if you did (blah blah :: String) in ghci you'll get the same behavior
02:29:04 <JamesJRH> I know.
02:29:23 <jle`> but yeah, ghci gives GHC a hint as to what type to infer it to be --- and it infers it/concretizes it to IO ()
02:29:39 <jle`> JamesJRH: yeah, lambdabot only evaluates expressions and Show's them
02:30:06 <jle`> so if your expression's result is a String, it'll show the string
02:30:08 <jle`> > "hello"
02:30:09 <lambdabot>  "hello"
02:36:54 <fr33domlover> does Data.Array have O(1) indexing?
02:37:19 <fr33domlover> I tried indexing an billion-element array and GHCI went crazy memory-wise
02:38:03 <dramforever> fr33domlover: how crazy?
02:38:16 <ChristianS> fr33domlover: that's probably because your array doesn't fit into memory, independently of indexing
02:38:29 <fr33domlover> ChristianS, yeah it may be irrelevant
02:38:36 <zd234> is there a nice way to say: "get me the sourece code of everything lsited in "cabal list --installed" " ?
02:38:38 <fr33domlover> but does Array have O(1) indexing regardess?
02:39:04 <dramforever> sizeof_pointer * 1 billion = 8G on 64-bit machines
02:40:00 <fr33domlover> even if it's O(1) it could need to build the entire array before it would index its last element to get me the content etc.
02:40:10 <fr33domlover> the docs just don't say whether or not it's O(1)
02:40:35 <lelf> I've never used any kind of generics. Is there a way to write boilerplate-free iso :: (A->B,B->A) where A and B are different ADTs, but with a similar shape?
02:41:42 <dramforever> fr33domlover: well, you see you need O(n) time to build the array, right?
02:41:53 <fr33domlover> dramforever, that's fine
02:42:03 <fr33domlover> the question is what about the indexing itself
02:42:09 <fr33domlover> after i built the array
02:42:15 <ChristianS> fr33domlover: i'd check out Data.Vector, i think it's recommended over Array these days. and it explicitly states that indexing is O(1).
02:43:58 <fr33domlover> ChristianS, I don't need any size changes so Array provides the simple minimal requireements I have. I /can/ use vector but I thought I'd try Array since it's simple and does everything I need: build an array and then index into it all the time in the applications' event loop
02:44:37 <ChristianS> fr33domlover: vector is simple too
02:44:46 <dramforever> fr33domlover: what do you mean by size changes? If you mean stuff like increasing the size then no, that's not what vectors do
02:44:51 <fr33domlover> ChristianS, I mean vector is way more powerful
02:45:33 <dramforever> if you mean slicing...well yeah
02:46:23 <ChristianS> fr33domlover: that won't hurt you, and it also aims to be efficient which seems to be relevant for your use case
03:04:59 <KaiJia> 说句中文试试水
03:06:52 <dramforever> 这里中国人应该还是有一些的
03:08:02 <frerich> Yeah.. what he said!
03:08:11 * frerich slowly scoots backwards
03:08:23 <Heather> fr33domlover about Setup.lhs I will post in blog, I can't make change optional because it's "before" cabal
03:08:27 <dramforever> xkcd reference?
03:08:43 <dramforever> forget about it, stop this off-topic random stuff
03:09:08 <dcoutts> fr33domlover, Heather: Caba-1.24 allows conditional compilation in Setup.hs
03:09:48 <Heather> dcoutts wow
03:10:00 <Heather> dcoutts cabal 1.24?
03:10:23 <Heather> dcoutts version: 1.23.1.0 is master version
03:10:35 <Heather> monadic version XD
03:12:45 <dcoutts> Heather: right, it's due out any day now
03:12:56 <dcoutts> Heather: along with ghc-8, but it'll work with older too
03:13:20 <movedx> http://www.seas.upenn.edu/%7Ecis194/spring13/lectures/01-intro.html -- how I do I follow the examples in GHCI? Sadly this hasn't been covered that this point. It's putting me off these (otherwise excellent) lectures.
03:13:43 <Heather> dcoutts how to do it?
03:13:54 <Heather> dcoutts I'm using master - may you point me
03:14:28 <Heather> dcoutts setup.lhs is using dropped types and doesn't work for newer cabal - fix will break it for older cabal
03:14:45 <Heather> dcoutts MIN_VERSION_Cabal is a macro from cabal_macros.h that is generated by Setup.lhs
03:18:26 <Heather> dcoutts do you consider changing of cabal types as such as broken cabal abstraction?
03:18:47 <dcoutts> Heather: what types ooi?
03:19:36 <Heather> dcoutts https://github.com/ekmett/distributive/issues/15
03:20:14 <mjrosenb> movedx: where are you stuck?
03:22:16 <lyxia> this tutorial doesn't explain that you must type "let" to define variables in the REPL...
03:26:01 <Heather> dcoutts https://github.com/haskell/cabal/pull/2987
03:26:12 <Heather> what's happening around :D
03:26:49 <Heather> what is pattern synonym
03:28:14 <wz1000> I need a function that runs a command and returns the stdout, returning the empty string in case of failure. Is simply returning the second element of the tuple from System.Process.readProcessWithExitCode a good idea?
03:30:09 <ner0x652> Hi!
03:30:12 <ner0x652> I am going through a haskell book, in lists introduction there's an explanation about concatenation operator on lists
03:32:05 <ner0x652> it says that the left operator is evaluated every time, so from performance point of view it's O(n)
03:32:39 <ner0x652> it also says that cons operator is faster, which makes sense
03:32:42 <fr33domlover> By the way http://stackoverflow.com/questions/13102775/array-in-haskell says arrays have O(1) indexing once the thunk is built
03:32:55 <cocreature> wz1000: that won’t allow you to differentiate between a failed process and a process which didn’t write anything to stdout. if that’s fine for you, then it seems like the right thing to use
03:33:21 <ner0x652> from that I understand that concatenating a list of 10 elements and a list of 2 million elements is O(1), is that right?
03:34:01 <cocreature> ner0x652: it’s O(10) (assuming the list of 10 elements comes first) and that’s the same as O(1) (since it’s a constant)
03:34:20 <ner0x652> why does the second operand of ++ is not evaluated?
03:34:44 <cocreature> @src (++)
03:34:44 <lambdabot> []     ++ ys = ys
03:34:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
03:34:44 <lambdabot> -- OR
03:34:44 <lambdabot> xs ++ ys = foldr (:) ys xs
03:34:46 <lyxia> O(10) is O(1) and is misused here anyway
03:35:00 <cocreature> it never needs to deconstruct ys
03:35:15 <ner0x652> that is clear for me that O(10) is the same as O(1) from algorithm analysis point of view
03:35:24 <dcoutts> Heather: so with Cabal-1.24 one can have a custom-setup stanza with a field setup-depends:
03:35:42 <dcoutts> Heather: but note that if you use this, it does then need the latest Cabal to build
03:36:07 <Heather> dcoutts okay I need rework my patch to repair backward compatibility for this type using PatternSynonyms... I'm reading about it now
03:37:04 <ner0x652> so ++ function is cons(under the hood :p)
03:37:45 <Heather> dcoutts it's damn complicated!
03:38:47 <cocreature> ner0x652: yep one cons for every element in the first list
03:39:54 <ner0x652> understood, thanks
03:40:55 <merijn> dcoutts: 1.24 has setup-depends? :D
03:41:00 * merijn throws a tiny party
03:41:07 <dcoutts> yep
03:41:49 <dcoutts> merijn: and once you opt in, you must specify all deps, but then cabal-install will install them for you, and you get to use cpp
03:42:19 <Heather> dcoutts should it be alike pattern InstalledPackageId = App "UnitId" ? how to use those pattern synonyms?
03:42:42 <merijn> dcoutts: I guess this means that make Setup depend on the library for say alex/happy will mean we can finally rely on those being installed before building the main package, right?
03:42:55 <dcoutts> Heather: not sure, check the ghc user guide
03:43:22 <dcoutts> merijn: your Setup.hs script cannot require pre-processors, has to be .hs or .lhs
03:43:57 <dcoutts> merijn: if you mean hacks to depend on a tool being installed, you can do that now with ordinary build-depends
03:44:17 <dcoutts> until we teach the solver to handle build-tools depends
03:44:46 <merijn> dcoutts: I guess alex/happy is not a problem case, but it didn't work for, say, c2hsc where the tool is needed by Setup.hs
03:46:14 <dcoutts> merijn: iirc, the glib etc packages have Setup.hs scripts that use an extra custom lib. It'll certainly help there.
03:46:36 <dcoutts> but doesn't help with ensuring build tools are available
03:48:37 * hackagebot stack-run 0.1.0.3 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.0.3 (yamadapc)
03:50:24 <JamesJRH> Is there a way to printf a number without trailing zeros when exact?
03:50:29 <JamesJRH> > Text.Printf.printf "%.5f\n" 1.5 :: String
03:50:31 <lambdabot>  "1.50000\n"
03:50:48 <JamesJRH> So that would be "1.5\n".
03:53:00 <JamesJRH> Also, can this be done given the numerator and denominator, bypassing Float?
03:53:37 * hackagebot stack-run 0.1.0.4 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.0.4 (yamadapc)
03:55:28 <JamesJRH> E.g.: 15/10 -> "1.5"; 1500001/1000000 -> "1.50000".
04:02:28 <Heather> isInt (App "Int" []) = True - what doeas this [] even mean there?
04:02:32 <Heather> it's complicated!
04:02:45 <sbrg> Heather: empty list
04:02:55 <Heather> lol
04:03:03 <Heather> thanks cap
04:03:24 <sbrg> i guess I wandered into something without reading the backlog
04:03:32 <JamesJRH> I should be able to do it with ‘dropWhileEnd (=='0')’ (http://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text.html#v:dropWhileEnd ) and using ‘mod’ to determine the cases where the number is exact.
04:04:10 <Heather> is App "Int" [] - default matching for it but what [] means there
04:04:34 <JamesJRH> Exact to fewer than the desired number of decimal places, that is.
04:05:35 <mjrosenb> JamesJRH: so you want to strip all trailing zeros?
04:06:03 <Heather> btw does pattern matching works on types?
04:06:10 <Heather> afaik it should
04:06:12 <sbrg> JamesJRH: modulo on floating point numbers? 
04:06:18 <sbrg> Heather: types? Algebraic data types?
04:06:21 <sbrg> if so, yes. 
04:06:29 <Heather> sbrg types alike Int
04:06:43 <quchen> No, you cannot patter-match on types.
04:06:48 <sbrg> are you talking about values that inhabit that type or the type itself?
04:07:12 <quchen> That would break parametricity and throw out most (all?) of the guarantees the Haskell type system provides you with.
04:07:35 <Heather> type itself
04:07:42 <Heather> alike isInt Int = true?
04:08:06 <sbrg> you are mixing values and types there. 
04:08:06 <merijn> quchen: You can a little bit, if you count Typeable :p
04:08:23 <Heather> sbrg I'm learning pattern synonims!
04:08:55 <Heather> sbrg quchen and seems like (App "Int" []) is matching Int but I just can't understand how does it work for now
04:09:11 <sbrg> "Int" is a string
04:09:15 <Heather> pattern synonims description is poor, I can't understand it just by looking on example
04:09:24 <Heather> sbrg cap, thanks again
04:09:43 <sbrg> it isn't matching on a type. it's matching on a string.
04:09:47 <sbrg> that is the answer.
04:09:54 <Heather> it does actually match type
04:10:07 <Heather> isInt (App "Int" []) = True
04:10:18 <Heather> pattern Int = App "Int" []
04:10:19 <aweinstock> :t "Int"
04:10:20 <lambdabot> [Char]
04:10:23 <Heather> isInt Int = True
04:10:29 <Heather> :t App "Int" []
04:10:30 <aweinstock> :t Int
04:10:30 <lambdabot>     Not in scope: data constructor ‘App’
04:10:30 <lambdabot>     Perhaps you meant variable ‘app’ (imported from Control.Arrow)
04:10:31 <lambdabot>     Not in scope: data constructor ‘Int’
04:10:31 <lambdabot>     Perhaps you meant one of these:
04:10:31 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
04:10:38 <Heather> :t (App "Int" [])
04:10:40 <lambdabot>     Not in scope: data constructor ‘App’
04:10:40 <lambdabot>     Perhaps you meant variable ‘app’ (imported from Control.Arrow)
04:10:41 <aweinstock> :t GHC.Types.Int
04:10:42 <lambdabot> Not in scope: data constructor ‘GHC.Types.Int’
04:10:50 <aweinstock> :t GHC.Prim.Int
04:10:51 <lambdabot> Not in scope: data constructor ‘GHC.Prim.Int’
04:11:07 <sbrg> Heather: It isn't matching on a type. It's matching on a data constructor App  which has a string parameter and a list parameter. 
04:11:13 <sbrg> and that pattern matches App "Int" []
04:11:15 <sbrg> it's not a type.
04:11:20 <Heather> aweinstock we need aslo LANGUAGE PatternSynonyms  if you want it here
04:11:34 <aweinstock> :t Data.Int.Int
04:11:35 <lambdabot> Not in scope: data constructor ‘Data.Int.Int’
04:11:42 <liste> pattern synonym is basically just an alias
04:11:53 <Heather> it's not haskell even, it's GHC extension
04:12:03 <sbrg> aweinstock: you can't ask for the type of a type. you can do something like :kind Int
04:12:04 <aweinstock> huh, lambdabot doesn't seem to want to tell me about Int primitives
04:12:04 <sbrg> :kind Int
04:12:09 <sbrg> :k Int
04:12:10 <lambdabot> *
04:12:14 <liste> so that if there's pattern Int = App "Int" [], then isInt Int would be equivalent to isInt (App "Int" [])
04:12:20 <aweinstock> sbrg: I know, I was looking for the Int constructor
04:12:29 <sbrg> aweinstock: those are the numbers.
04:12:29 <merijn> aweinstock: It's not exported by default
04:12:30 <aweinstock> :t Data.Int.I#
04:12:32 <lambdabot> Not in scope: data constructor ‘Data.Int.I#’
04:12:32 <sbrg> oh
04:12:35 <sbrg> that one
04:12:41 <Heather> liste yes I've got it
04:12:49 <aweinstock> does lambdabot not have -XMagicHash?
04:12:50 <merijn> aweinstock: It's Int#, but only exposed from GHC's voodoo modules :)
04:12:56 <Heather> liste I only need to understand what is (App "Int" [])
04:13:08 <KaneTW> :t 0#
04:13:09 <lambdabot> GHC.Prim.Int#
04:13:12 <merijn> aweinstock: Pretty sure lambdabot doesn't export the internal modules
04:13:13 <KaneTW> ^
04:13:51 <merijn> :t GHC.Exts.I# -- test?
04:13:52 <lambdabot> GHC.Prim.Int# -> Int
04:13:57 <merijn> oh, I guess it does exist
04:13:59 <aweinstock> merijn: I thought it allowed them for :t, but not for > (because otherwise people could memorycorruptionexploit lambdabot)
04:14:08 <merijn> > GHC.Exts.I# 1#
04:14:10 <lambdabot>  Not in scope: data constructor ‘GHC.Exts.I#’
04:14:19 <aweinstock> > 1#
04:14:20 <lambdabot>      Couldn't match kind ‘*’ with ‘#’
04:14:20 <lambdabot>      When matching types
04:14:20 <lambdabot>        a0 :: *
04:14:26 <liste> Heather it's defined in https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
04:14:31 <liste> "https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms"
04:14:39 <liste> "    data Type = App String [Type]"
04:14:41 <liste> there
04:14:48 <liste> it's just used as an example
04:14:58 <aweinstock> so MagicHash is on, but you can't do anything with it because every (# -> *) is unsafe?
04:15:07 <Heather> liste so App is type constructor?
04:15:21 <aweinstock> App is a value constructor
04:15:25 <liste> no, Type is the type constructor and App is the data constructor
04:15:36 <merijn> aweinstock: They're not all unsafe, but yeah I think the reasoning is "why both to figure out which is safe if no one should really need them in lambdabot"
04:15:39 <liste> (or a value constructor)
04:15:40 <aweinstock> (presumably for some algebraic datatype representing a syntax tree)
04:16:21 <liste> Types are not types, they're *representations* of types
04:16:27 <liste> i.e. values
04:21:18 <dramforever> I just thought we could probably allow some unsafe stuff in typechecking (:t)
04:21:40 <merijn> dramforever: It did allow that
04:21:46 <merijn> :t GHC.Exts.I#
04:21:47 <lambdabot> GHC.Prim.Int# -> Int
04:21:50 <merijn> :t GHC.Exts.I# 0#
04:21:52 <lambdabot> Int
04:22:02 <dramforever> Oh, good to know :P
04:33:52 <aweinstock> :t Unsafe.Coerce.unsafeCoerce -- dramforever, it doesn't get worse than this
04:33:54 <lambdabot> a -> b
04:35:47 <dramforever> yeah indeed
04:36:18 <quchen> aweinstock: accursedUnutterablePerformIO wants to have a word with you
04:36:46 <quchen> https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L527
04:37:16 <dramforever> Arrgh, so template haskell can't use something defined with TH in the same module
04:37:39 <dramforever> and somehow persistent generates instances with calls to function in hidden modules...
04:38:42 <merijn> quchen: :)
04:38:48 <merijn> I love that function name :p
04:40:36 <cocreature> and I thought reallyUnsafePtrEquality was the worst
04:41:35 <tdammers> I think I encountered absolutelyUnsafeCommitCrimeAgainstHumanity somewhere once
04:45:28 <Heather> dcoutts will this work fine https://github.com/haskell/cabal/pull/3067 ?
04:46:28 <crossroads1112> The wiki says the exception monad is in Control.Monad.Error, but when I import that I get the message that this module is depricated and to use Control.Monad.Except, but when I import the latter, it gives the same error about Control.Monad.Error being depricated
05:10:16 <python476> hello again
05:10:38 <python476> Trying to reimplement the Maybe Monad (on my own renamed types). I don't understand the error here http://dpaste.com/3VEVABQ
05:11:17 <merijn> python476: The monad class requires that types that instance it also instance Applicative
05:11:22 <MasseR> python476: Since ghc 7.8 (or 7.10) you need to implement applicative instance as well
05:11:30 <merijn> python476: (And Applicative requires the a type instances Functor)
05:11:59 <python476> that escalated slowly
05:12:20 <python476> with the pleasures old tutorials
05:12:33 <python476> on to App and Fun
05:14:15 <merijn> hmm, I was gonna link to the hackage docs, but apparently hackage decided I don't need to load those >.>
05:14:26 <merijn> python476: Ah, here we go: https://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Monad
05:15:21 <merijn> python476: If you look at the class declaration you see "class Applicative m => Monad m where" having a constraint like that on a class is called a superclass and translates to "only allow types to instance this if they satisfy the constraint"
05:16:01 <python476> I understand the notation, it's just that I was living in the past decade
05:16:10 <merijn> The inferior decade ;)
05:16:19 <python476> depends on the ordering
05:16:23 * python476 is a passeist
05:16:30 <quchen> crossroads1112: http://hackage.haskell.org/package/transformers-0.5.0.0/docs/Control-Monad-Trans-Except.html
05:17:00 <quchen> ?quote error.*incompatible
05:17:00 <lambdabot> kmc says: Haskell is a language where the community observes that there are 50 incompatible error handling monads, and the response is 50 incompatible packages for generically handling all error handling monads
05:18:18 <merijn> I think transformers deprecated ErrorT for ExceptT, but I think there was a problem like MonadError's interface breaking if you update it, so mtl still exports deprecated ErrorT things too?
05:20:40 <quchen> merijn: The long road to the right EitherT
05:21:06 <tdammers> quchen: pun intended?
05:21:20 <quchen> No! What's the pun?
05:21:37 <tdammers> the Right EitherT
05:21:38 <quchen> Although I like ExceptT more than EitherT, since Either has two Applicatives, and Validation (concatenating Lefts) is fairly useful too, so I don't like "EitherT" to mean "short-circuit on Left".
05:21:54 <quchen> tdammers: Oh. Unintended. :-)
05:22:06 <tdammers> unintended, but very welcome
05:22:16 <merijn> quchen: That's why edwardk's either package has a Validation newtype :p
05:25:39 <benzrf> i need valition
05:25:41 <benzrf> *validation
05:38:12 <Strukks> Hi, can someone tell me why this function only works correctly the second time I use it, first time it wrongly lets me enter 3 lines, after that it works correctly letting me enter 2 http://puu.sh/mBuNP/f43b09746e.png
05:38:35 <python476> aren't Applicative and Functor very gradually related? 
05:39:05 <python476> I mean to declare the Monad instance, you'll leverage the superclasses functions ?
05:39:42 <Forsaken> test
05:42:11 <lyxia> Strukks: what three/two lines are you giving it
05:42:55 <lyxia> Strukks: You could try printing the stuff you read to see exactly what it does
05:44:14 <Strukks> lyxia, just random symbols
05:45:26 <dramforever> Strukks: your code is strange to me. Can you explain what it's supposed to do?
05:45:33 <Strukks> http://puu.sh/mBvbK/f91f541869.png
05:45:56 <Strukks> It's supposed to show the difference of the encoding value between two symbols
05:46:12 <lyxia> Prefer using paste services
05:46:16 <dramforever> Ah, okay, so it's because of buffering of the input of the haskell program
05:46:34 <Strukks> like if 'A' is 65 and 'C' is 67, then it should output 2
05:47:37 <dramforever> getLine 1.1: reads A and newline, getChar 1.1: reads B, getLine 1.2: reads newline, getChar 1.2: reads C
05:48:12 <dramforever> getLine 2.1: reads newline, getChar 2.1: reads C, getLine 2.2: reads newline, getLine 2.2: reads B and newline
05:48:54 <jmcarthur> python476: As they are defined, there is a little redundancy, but a different set of basis functions is possible.
05:49:32 <jmcarthur> python476: That is, right now pure and return are exactly the same, and fmap can be used in the implementations of (<*>) and (>>=)
05:50:19 <dramforever> Strukks: the rule for getLine is "read until and including the next newline" and for getChar it's "whatever next character". Somehow the GHCi input and the haskell program's input are isolated, but that seems intuitive enough
05:50:21 <merijn> You can use >>= in your implementation of fmap :p
05:50:32 <jmcarthur> Yes, that too.
05:50:46 <jmcarthur> return and (>>=) can implement all the others.
05:51:10 <dramforever> :t liftM -- merijn, jmcarthur
05:51:12 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
05:51:20 <dramforever> with return and (>>=)
05:51:21 <jmcarthur> that's right
05:51:35 <python476> jmcarthur merijn dank u
05:51:44 <merijn> python476: Note that superclasses, unlike inheritance, don't form an ACTUAL hierarchy, so something is not "Functor first, Monad after", it's just "if it is a Monad it has to be a Functor too", it's not required that you implement Functor without using Monad functions
05:53:14 <python476> I kinda see
05:53:28 <dramforever> implication does not imply dependency
05:53:33 <python476> You mean that it's a logical deduction
05:53:57 <python476> ( Functor ... (Monad...)  ) if you're in the Monad class, you're thus in the Functor Class.
05:54:02 <python476> Am I wrong or what
05:54:46 <Strukks> dramforever: so how would I go about fixing that? :D
05:55:24 <merijn> python476: No, I'm saying that when GHC see "instance Monad Foo" it just checks if it can find "instance Functor Foo", but it doesn't say "Functor has to be defined "first"", since typeclasses have no ordering
05:55:47 <dramforever> Strukks: just use two getLine's, and pattern match to get out the char, perhaps?
05:55:53 <merijn> python476: And if you use ">>=" inside the definition of Functor, GHC is perfectly ok with that, as long as it finds "instance Monad Foo" somewhere
05:56:03 <merijn> (which it then uses to call >>=)
05:56:15 <dramforever> merijn: does interpreting it as "logical implication" make sense?
05:56:19 <merijn> Now, if your >>= happens to also use fmap, THEN you get an infinite loop, obviously
05:56:41 <python476> merijn: ha, funky
05:56:43 <dramforever> Monad m -> Functor m
05:57:13 <python476> so it's .. unified ?
05:57:31 <python476> as long as all the pieces satisfies all the needs, no matter where they were defined
05:57:37 <merijn> python476: It's like "class Eq a where (==) = (/=); (/=) = (==)", if you implement one of the two you get the other "for free" from the default implementation, but if you implement neither it infinite loops
05:57:40 <python476> (without loops indeed)
05:57:41 <merijn> python476: Right
05:58:03 <merijn> Because == calls /= calls == calls /= calls ==, etc.
05:58:07 <python476> damn interesting
05:58:29 <Strukks> dramforever, thank you very much, got it working now!
05:58:29 <merijn> You just need to break the cycle somewhere and GHC is perfectly happy. (Actually, GHC is also happy if you don't break the cycle, but you won't be :p)
05:58:31 <python476> you interesting haskellers with your interestings
05:58:41 <dramforever> Strukks: you're welcome
05:59:01 <python476> Guaranteed Happy Compiler
06:01:50 <cheater> Strukks: i know what your issue was
06:02:02 <Strukks> cheater, yeah?
06:02:14 <m1dnight_> Is it possible to include patternmatching into a function composition?
06:02:15 <cheater> Strukks: try your original program, but put putStrLn "" after each getChar. you'll see what you were doing wrong.
06:02:40 <m1dnight_> E.g., `(foo . bar . baz) (Quux vals)`
06:02:53 <m1dnight_> I want the functions to work on vals, instead of on (Quux vals)
06:03:13 <tdammers> m1dnight_: not directly; you'll need to use one of the constructs that cause pattern matching
06:03:16 <dramforever> m1dnight_: (\(Quux vals) -> vals) perhaps? Also consider using records
06:03:26 <m1dnight_> ohhhh
06:03:31 <m1dnight_> exactly. just use records!
06:03:45 <tdammers> protip: you can even use records on newtypes
06:03:49 <m1dnight_> many thanks :)_
06:05:00 <Strukks> cheater, I don't think that helped, http://puu.sh/mBw4C/b0707cde1a.png, if I understood you correctly
06:05:17 <cheater> why aren't you using a text pastebin??????????
06:05:28 <python476> lol
06:05:54 <python476> cheater: fear of buffer overflow maybe
06:06:14 <Strukks> cheater, lol, sorry, http://pastebin.com/2CCgRfkW
06:06:23 <cheater> yeah like this
06:06:24 <cheater> anyways
06:06:32 <Strukks> I can't copy paste the interpreter output to pastebin :D
06:06:42 <python476> I expected an url to the image in that pastebin ...
06:06:53 <cheater> even on windows you should be able to select from the terminal?
06:07:02 <cheater> i dunno though
06:07:06 <python476> its nontrivial under cmd.exe
06:07:13 <Strukks> I can't, on win 10, ghci 7.10.3
06:07:15 <merijn> Pro-tip: Install powershell and use the powershell terminal instead of cmd.exe
06:07:25 <merijn> The powershell terminal is actually semi-decent
06:07:26 <python476> there's clink 
06:07:31 <cheater> it was the last time i checked but that was on windows xp, you'd just right click and select some menu option or other
06:07:39 <cheater> either way..
06:07:42 <m1dnight_> C-space w p I think, in windows and you can select. That is far from `non-trivial`..
06:07:49 <python476> clink is a very very thin layer on top of cmd.exe which gives you 80% of the important parts
06:08:13 <Strukks> You're right, I got it enabled from options
06:08:19 <cheater> with your original program, what i entered was for example "tx[enter]dsx[enter]z" and then the variables contained "tx", 'd', "sx" and 'z' respectively
06:08:57 <cheater> what you were doing was probably you pressed enter after inputting the char for getChar
06:09:00 <cheater> which is wrong
06:09:23 <cheater> getChar means "enter one keystroke" not "enter one line that contains one character plus one newline character by pressing enter"
06:09:38 <cheater> once you've pressed a single character key, that's it, getChar is done, and passes onto getLine after
06:10:21 <Strukks> ohh
06:10:23 <cheater> so if you're on that getChar and do something like press x and then press enter, you'll send the x to the getChar and the enter to the getLine that's after the getChar, therefore the getLine receives an empty line.
06:10:40 <geekosaur> except that if the terminalis in line mode you need to press returnfor the char to be sent to the program :/
06:10:47 <cheater> it IS however bizarre that, at least on my computer, i need to press enter after the last getChar.
06:10:51 <cheater> that i do not understand
06:10:55 <geekosaur> (unix)
06:10:56 <merijn> cheater: Change the buffering of stdin
06:11:06 <cheater> geekosaur: you mean if it's in local echo mode.
06:11:10 <Strukks> cheater, just deleting one getLine worked for me
06:11:12 <merijn> cheater: No
06:11:38 <Strukks> Cheater, this works perfect http://pastebin.com/ynYmMAzc
06:11:40 <merijn> cheater: Terminals have three buffering modes, two of which don't send input to the program until you enter a new line
06:11:58 <merijn> cheater: You want to put the terminal in "raw" or "unbuffered" mode, so it doesn't buffer input until new line
06:12:34 <merijn> cheater: You want "hSetBuffering stdin NoBuffering"
06:12:53 <cheater> merijn: if i do unbuffer ./foo.hs it completely breaks the program :-   D
06:13:53 <geekosaur> this is where conflating input buffering and "stty icanon" state like ghc does leads to trouble :/
06:14:12 <merijn> geekosaur: Hmm? In what way?
06:14:34 <geekosaur> because they only want -icanon for the getChar, not the following getLine
06:14:35 <cheater> yeah with the buffering turned off it's much better :))
06:15:02 <cheater> what is "icanon"? hmm..
06:15:17 <geekosaur> it's why your "local echo" comment was off the mark
06:15:19 <merijn> cheater: canonical mode
06:16:11 <cheater> yeah, reading up http://linux.die.net/man/3/termios
06:16:21 <cheater> thanks
06:17:21 <dramforever> hey, I thought Strukks was on windows...
06:17:21 <m1dnight_> Another quick question if I may: How can I implement `++` on a custom data type? I have `data F = F [(String, String)]` and I want to be able to concat them.
06:17:26 <m1dnight_> I thought functor, but that is not it.
06:17:45 <quchen> ++ is monoid, not functor.
06:17:46 <Strukks> dramforever: I am
06:17:50 <merijn> cheater: See also the terminal chapter of Advanced Programming in the Unix Environment: http://poincare.matf.bg.ac.rs/~ivana//courses/ps/sistemi_knjige/pomocno/apue.pdf
06:17:57 <quchen> m1dnight_: Can you implement (++) for lists?
06:18:12 <m1dnight_> well sure. its super easy? :p
06:18:13 <dramforever> m1dnight_: What do you want to do? Like overload (++)?
06:18:48 <m1dnight_> Yes. So I dont have to call a specific function. I can just do `x ++ y where x = F xs  y = F ys`
06:18:58 <Hafydd> m1dnight_: note: mconcat :: Monoid a => (a, a) -> (a, a) -> (a, a).
06:19:04 <quchen> m1dnight_: Can you write a function "F -> [(String, String)]"?
06:19:26 <m1dnight_> quchen: sure, just a pattern match...
06:19:32 <quchen> Exactly.
06:19:35 <m1dnight_> let (F xs) = f in xs :p
06:19:36 <dramforever> m1dnight_: Short answer: you can't overload (++), that's not how polymorphism works in haskell
06:19:44 <quchen> m1dnight_: No, that's not right.
06:19:54 <quchen> Oh, if "f" is your given value.
06:20:00 <m1dnight_> yeah, it is
06:20:00 <quchen> Strange name. Okay, it's right.
06:20:14 <python476> #haskell, your work has paid http://dpaste.com/1FW13KY
06:20:14 <m1dnight_> okay maybe my sitatuion is a bad smell, ill check it out
06:20:16 <m1dnight_> thanks though.
06:20:36 <python476> here's one imaginary bitcoin for you ... ($)
06:20:37 <dramforever> You could make your type an instance of Monoid, which list types happen to be instances of it too http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html
06:20:37 <quchen> Alright, now you have the "xs" in the first "F"'s content. You can now get the "ys" from the other "F".
06:20:53 <merijn> python476: Side note, you can write the definition of operators infix too
06:20:56 <dramforever> and exactly for concatenation-like stuff
06:21:30 <quchen> m1dnight_: You now have two lists (xs) and (ys), and you can concatenate them with (++).
06:21:32 <merijn> python476: i.e., like http://lpaste.net/150257
06:21:38 <quchen> m1dnight_: And what's left is re-wrapping them in an "F".
06:22:03 <merijn> python476: For bonus points, see if you can check/proof whether your implementations obey the laws :)
06:22:42 <quchen> m1dnight_: You can then inline the pattern matching and everything into a single line and you'll end up with `F xs +++ F ys = F (xs ++ ys)`.
06:23:46 <python476> merijn: yeah, I knew about syntax it's just secondary to the understanding
06:24:05 <python476> monadic laws and proofs do be are valuable though
06:25:22 <python476> I'm now trying to transfer this bit of knowledge to a Concurrent data type (again, monadic poor man's concurrency)
06:28:00 <python476> mixing CPS style with typeclasses functions is mind bending
06:30:23 <Strukks> Really dumb question, How do I add strings and Ints together to form a sentence, like x = 5; "The number is" ++ x
06:30:54 <adamCS> Strukks: "The number is" ++ show x
06:31:32 <Strukks> adamCS, that's what I thought, must be something else giving the error then : /
06:32:07 <quchen> Strukks: Paste your code
06:32:43 <Strukks> I'm still doing the same excersise, http://pastebin.com/vuyvWHMT
06:32:43 <geekosaur> wrote someting like `putStrLn "The number is " ++ show x` ? (which is trying to concatenate with the result of putStrLn)
06:32:49 <geekosaur> *guessing&
06:32:59 <geekosaur> yep
06:33:03 <Strukks> hahaha
06:34:07 <Strukks> Thanks
06:35:52 <dramforever> MildlyInteresting thing before I go to sleep: Today I was chatting about common languages used in programming contests, and when I mentioned Pascal, one of them heard Haskell.
06:36:34 <Strukks> "ask hell"
06:36:38 <dramforever> i.e. reversed https://redd.it/3s4qqm
06:40:03 <Strukks> God, :D, Why does casting the "value" to abs break my IF? http://pastebin.com/D6TWtJG4
06:40:11 <Strukks> and how do I fix it?
06:40:14 <dramforever> www.haskell.org/pipermail/haskell-cafe/2008-January/038756.html
06:40:57 <Strukks> Why does using abs while printing the value also change it for the previous uses?
06:43:07 <srhb> Strukks: What's the problem?
06:43:10 <jewels> Hi there, I am defining a ZadehMembership type which contains a Double value. I want to avoid to instance the Num class for the ZadehMembership type which is needed by the "map1" function when I pass a function that requires a Num constraint (see lines 40-44). Should I use a Functor to generalize this function? Here is the code: http://lpaste.net/150258
06:43:57 <srhb> Strukks: Also, there is no casting. Only explicit conversion.
06:44:01 <Strukks> srhb, I want to print out the absolute value, but my if checks if it's bigger or smaller than 0 before, but if I cast it to abs while printing, it also changes it for IF
06:44:37 <Strukks> Sorry, my IT English isn't very good, since we learn in our native language
06:44:52 <srhb> Strukks:What do you expect the type of value to be?
06:45:01 <srhb> Strukks: You would probably benefit from annotating your programs.
06:45:46 <Strukks> Integer
06:46:37 <srhb> Strukks: And why do you think it's changing values?
06:47:15 <Strukks> Everything works fine if I print the real value, but if I print the absolute value, in the IF it also goes to absolute value 
06:47:55 <Strukks> I think
06:48:16 <srhb> Strukks: No, that isn't happening.
06:48:27 <dramforever> what do you mean by cast?
06:48:59 <Strukks> ehh, I want to just show absolute value
06:49:05 <Strukks> cast might be the wrong term here
06:49:15 <srhb> Strukks: Then your code is working as intended.
06:49:38 <Strukks> Yep, you're right
06:50:58 <srhb> Strukks: Those dos in "then" and "else" are superfluous, by the way.
06:51:16 <Strukks> ?
06:51:22 <Ankhers> They are not necessary.
06:51:40 <Ankhers> You do not need a `do' when it is followed by only a single command.
06:51:53 <codedmart> If I have a `(HTTP.Method -> Req)` how do I get it to just `Req`?
06:51:58 <Strukks> Oh
06:52:05 <Ankhers> main = putStrLn "Hello" is the same as main = do putStrLn "Hello"
06:52:21 <merijn> codedmart: Apply it to a HTTP.Method?
06:52:28 <Strukks> It's my second day learning Haskell ^^
06:52:36 <dramforever> codedmart: try asking yourself, what's that (HTTP.Method -> Req)?
06:52:42 <dramforever> what's it supposed to do?
06:53:40 <codedmart> dramforever Isn't is a function from HTTP.Method to Req?
06:54:06 <dramforever> yep, so just apply it to a Method :P
06:54:26 <codedmart> Thanks!
06:55:24 <jewels> Hi there, I am defining a ZadehMembership type which contains a Double value. I want to avoid to instance the Num class for the ZadehMembership type which is needed by the "map1" function when I pass a function that requires a Num constraint. Should I use a Functor to generalize this function? http://lpaste.net/150258
06:57:33 <Ankhers> jewels: I think you can use the NewtypeDeriving langauge pragma to create the Num instance for you. https://prime.haskell.org/wiki/NewtypeDeriving -- a bit of information there.
06:59:51 <jewels> Ankhers: Is there a standard way to do that? If possible I want to avoid external functionalities. I have tried to use a Functor but I'm not able to impose the Double constraint.
07:00:59 <codedmart> dramforever I guess I am missing something. HTTP.Method is just `type Method = ByteString`
07:01:28 <Ankhers> jewels: It shouldn't add any external libraries. You should just add `{-# LANGUAGE NewtypeDeriving #-}' to the top of your file, then you can add `deriving (Num)' to your type definition.
07:03:02 <python476> if you wrap CPS form ((a -> r) -> r) in a type K, does it makes sense to have fmap ?
07:03:18 <dramforever> codedmart: ok then pass it a bytestring :P 
07:03:23 <jewels> Ankhers: I don't need to derive from Num. I want that the Haskell interpreter is able to automatically evaluate operations on the Double values contained in the ZadehMembership type. So I should be able to do that without defining the Num class functions.
07:03:25 <dramforever> You can use http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Char8.html#v:pack
07:03:40 <python476> fmap (a -> b) (K a) .. fmap (a -> b) ((a -> r) -> r) ... or maybe fmap (r -> r') ?
07:03:45 <dramforever> or the OverloadedStrings extension to allow a string literal to be a bytestring
07:04:22 <dramforever> @hoogle -- can be really handy
07:04:24 <lambdabot> Unknown flag: -- can be really handy
07:04:30 <dramforever> @where hoogle
07:04:30 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
07:12:32 <Ankhers> jewels: using the derive, you do not need to define it yourself. It will automatically create the instances for you.
07:18:29 <Ankhers> jewels: I annotated your paste. I don't know if it will compile, but that is the general idea of how NewtypeDeriving works. It gets rid of a bunch of your instance definitions.
07:20:30 <Ankhers> assuming your wrapped type, in this case Double, already has an instance of the classes you are trying to derive.
07:22:27 <jewels> Ankhers: But in this way a ZadehMembership is not limited in the range [0,1]. Anyway, thank you for your help, I have solved using GeneralizedNewTypeDeriving :)
07:24:37 <Ankhers> jewels: Glad you got it working.
07:29:11 * hackagebot fswatcher 0.2.0 - Watch a file/directory and run a command when it's modified  https://hackage.haskell.org/package/fswatcher-0.2.0 (ErlendHamberg)
07:39:54 <JamesJRH> sbrg: No, on Integrals.
07:40:36 <JamesJRH> 12:05:12 < mjrosenb> JamesJRH: so you want to strip all trailing zeros?  ← Yes. Sorry, I went quiet for a bit because I realised that the Data.Text module wasn't available on my system and I was already in the middle of experimenting with how NixOS makes Haskell packages available to GHC.
07:41:15 <JamesJRH> I now fully understand the new method (which is cleaner and makes a great deal of sense) and have installed base64Bytestring, random, text, and most of the Haskell Platform packages listed at https://haskell.org/platform/contents.html using the new method.
07:43:52 <JamesJRH> mjrosenb: Anyway, now that I have Data.Text.dropWhileEnd, I can't get it to work. I don't know the difference between String and Text, other than something to do with fast optimisation mechanisms.
07:44:07 <JamesJRH> > Data.Text.dropWhileEnd (=='0') "1.500"
07:44:08 <lambdabot>      Not in scope: ‘Data.Text.dropWhileEnd’
07:44:08 <lambdabot>      Perhaps you meant one of these:
07:44:08 <lambdabot>        ‘Data.List.dropWhileEnd’ (imported from Data.List),
07:45:14 <JamesJRH> I get a type error (snippet):     Couldn't match expected type ‘Data.Text.Internal.Text’
07:45:17 <JamesJRH>                 with actual type ‘[Char]’
07:46:27 <JamesJRH> > import Data.List.dropWhileEnd
07:46:28 <lambdabot>  <hint>:1:1: parse error on input ‘import’
07:46:38 <JamesJRH> > import Data.List
07:46:40 <lambdabot>  <hint>:1:1: parse error on input ‘import’
07:46:51 <JamesJRH> Dah.
07:47:04 <JamesJRH> > import Data.Text
07:47:05 <lambdabot>  <hint>:1:1: parse error on input ‘import’
07:47:20 <JamesJRH> Does lambdabot have a way to import stuff?
07:47:47 <Hafydd> JamesJRH: no; that would probably be a security flaw.
07:48:16 <JamesJRH> Hmm.
07:49:38 <Hafydd> Oh, apparently, you can, but:
07:49:42 <Hafydd> @let import qualified Data.Text as T
07:49:43 <lambdabot>  .L.hs:113:1:
07:49:43 <lambdabot>      Data.Text: Can't be safely imported!
07:49:43 <lambdabot>      The package (text-1.2.1.3) the module resides in isn't trusted.
07:49:53 <JamesJRH> Ah.
07:50:02 <JamesJRH> I thought that I'd seen it done before.
07:50:24 <JamesJRH> Okay.
07:50:42 <JamesJRH> Also, it's crazy how I barely read the error messages anymore.
07:51:08 <JamesJRH> Why does GHCi have to spew-out so much crap?
07:51:25 <JamesJRH> Quite often pages of type errors.
07:51:25 <KaneTW> you can't really shorten them without losing information
07:52:13 <Hafydd> Heh. I think you can, as about 50% of them are clarifying the nested sequence of expressions where the error occurred; but that would probably make them take longer to investigate, on average.
07:52:20 <fr33domlover> Transformers advice needed: There is a common pattern where a program connects to some server (e.g. SQL or X display server) and all the functions involving it take some sort of Context/Connection parameter. I'm writing a library that works like that. Would it be a good idea to create a monad transformer (that is really a wrapper of StateT) which holds that Connection detail to avoid explicity passing it
07:52:23 <fr33domlover> around all the time?
07:52:51 <Hafydd> fr33domlover: that sounds like ReaderT, rather than StateT.
07:52:53 <fr33domlover> because then programs will likely have StateT twice: the one I provide and the program's additional state on top
07:52:54 <JamesJRH> KaneTW: Well omitting the blank lines would be a headstart.
07:53:00 <JamesJRH> ;-)
07:53:02 <fr33domlover> Hafydd, hmm right, ReaderT
07:53:20 <JamesJRH> fr33domlover: Hi. \o
07:53:28 <fr33domlover> JamesJRH, o/ :)
07:53:46 <fr33domlover> same question but for ReaderT, then :P
07:54:08 <Hafydd> fr33domlover: you're changing it to "because then programs will likely have ReaderT twice"?
07:54:35 <fr33domlover> yeah. I don't know if that's ok because what if a program uses mtl
07:54:37 <merijn> fr33domlover: You could use ReaderT with an IORef/MVar
07:54:43 <JamesJRH> fr33domlover: Me? I don't know about Haskell transformers yet.
07:55:09 <fr33domlover> merijn, I can use plain ReaderT, no problem :P
07:55:09 <merijn> fr33domlover: If you wrap it in a newtype you can hide the MonadReader for the pool from end users
07:55:23 <fr33domlover> merijn, ah
07:55:25 <fr33domlover> right cool
07:55:31 <fr33domlover> that solves it
07:55:47 <fr33domlover> but otherwise, is it overall a good idea to do in a library?
07:56:16 <merijn> fr33domlover: Sure, everyone does
07:56:16 <fr33domlover> i just never used these much so i'm not sure it's a common idiom except for bits of code isee here and there
07:56:45 <fr33domlover> My case is a library that uses Xlib / XHB
07:57:07 <fr33domlover> So I'll be "hiding" the X display in the ReaderT
07:57:34 <fr33domlover> JamesJRH, they are very useful!
07:57:46 <lyxia> A question about type signatures and ST: http://lpaste.net/150263
07:57:59 <JamesJRH> fr33domlover: Hiding the X display? That sounds very curious.
07:58:32 <fr33domlover> JamesJRH, not hiding. Making is implictly accessible
07:58:45 <fr33domlover> i.e. no need to explicitly pass it to every function
07:58:55 <fr33domlover> Like, imagine you had to pass stdout to every IO action
07:59:15 <fr33domlover> with Xlib, you have to pass the display all the time
07:59:21 <Eduard_Munteanu> lyxia, ST s ()
07:59:33 <JamesJRH> fr33domlover: What I mean is, I'm curious about what you're doing with X. Anything to do with XMonad?
07:59:41 <merijn> Eduard_Munteanu: Can't "s is a rigid skolem type variable" :)
07:59:50 <fr33domlover> JamesJRH, writing a terminal emulator
07:59:58 <JamesJRH> COOL!!!!
08:00:15 <merijn> lyxia: You could bind the action in a top level binding and use ScopedTypeVariables
08:00:15 <Eduard_Munteanu> Er, forall s. ST s () should do.
08:00:16 <fr33domlover> JamesJRH, hold on with that until you see results :P
08:00:40 <JamesJRH> fr33domlover: I'll be using it as soon as it's workable!
08:00:42 <Eduard_Munteanu> incr should be polymorphic and get instantiated below.
08:00:43 <lyxia> Eduard_Munteanu: try it :)
08:01:05 <lyxia> The problem is that incr is not polymorphic in s, it is bound by the use of r.
08:01:15 <merijn> lyxia: That should work
08:01:18 <Eduard_Munteanu> Oh, duh.
08:01:23 <merijn> oh, lpaste is broken
08:01:26 <merijn> http://lpaste.net/150263
08:01:58 <lyxia> ahh that's nice merijn 
08:02:22 <Eduard_Munteanu> Then ScopedTypeVariables is what you want.
08:02:23 <merijn> Warning, I haven't tested that :p
08:02:45 <JamesJRH> So how do I strip the trailing zeros from a String if not ‘Data.Text.dropWhileEnd (=='0')’?
08:02:52 <lyxia> I didn't either, but I got the idea anyway. Thanks :)
08:03:29 <Eduard_Munteanu> JamesJRH, reverse . dropWhile (== '0') . reverse?
08:04:12 * hackagebot ghc-tcplugins-extra 0.2 - Utilities for writing GHC type-checker plugins  https://hackage.haskell.org/package/ghc-tcplugins-extra-0.2 (ChristiaanBaaij)
08:04:29 <JamesJRH> > reverse . dropWhile (== '0') . reverse $ "1.500"
08:04:31 <lambdabot>  "1.5"
08:04:43 <JamesJRH> Eduard_Munteanu: Oh yeah. :-)
08:04:50 <JamesJRH> Thank you.
08:06:38 <Eduard_Munteanu> JamesJRH, or maybe   unpack . Data.Text.dropWhileEnd (== '0') . pack
08:06:58 <Eduard_Munteanu> (qualify pack and unpack as well)
08:19:12 * hackagebot HUnit 1.3.1.1 - A unit testing framework for Haskell  https://hackage.haskell.org/package/HUnit-1.3.1.1 (AdamBergmark)
08:24:51 <jewels> Hi there. I want to create an instance for the Functor class for a type that I have defined. Here is the code: http://lpaste.net/150265
08:25:56 <latk> I want to use haskell for a simple rest api, using servant. Last time I built something in haskell I remember getting irrationally pissed off with the fact that record field names cannot be the same across different data types. Are there any ways around this? For the application I am thinking of, there is likely to be a lot of redundancy, record names wise.
08:27:08 <bergmark> jewels: The key is that the Functor instance only takes a type with one type argument so `FuzzySet' can not be a Functor but `FuzzySet i` can
08:28:22 <bartavelle> latk, the lens machinery alleviates the problem with the "makeClassy" template haskell machinery, but AFAIK there will be the first part of a solution in GHC 8
08:28:40 <byorgey> latk: see https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
08:28:40 <jewels> I wrote this: instance Functor (FuzzySet i) but It gives me an error: Illegal instance declaration for ‘Functor (FuzzySet i)’
08:28:55 <jewels> bergmark: Any ideas?
08:28:57 <byorgey> jewels: you probably just need to enable the FlexibleInstances extension
08:28:59 <bartavelle> latk, there are other libraries to tackle the record problem too
08:29:15 <byorgey> jewels: put {-# LANGUAGE FlexibleInstances #-} at the top of your file
08:29:15 <latk> bartavelle: makeClassy sounds interesting. How would it work with, e.g., aeson instances? Would I have to write them all myself?
08:29:41 <bartavelle> latk, oh, if your problem is aeson instances, then you should learn about the Options type!
08:29:51 <bartavelle> gimme a sec
08:29:52 <bergmark> jewels: i also notice that FuzzySet is a type alias, not a newtype
08:29:56 <latk> bartavelle: Ah, okay!
08:30:07 <jewels> byorgey: Can I avoid it?
08:30:14 <jewels> bergmark: Is it a problem?
08:30:14 <bartavelle> latk, https://github.com/agrafix/elm-bridge/blob/master/src/Elm/Derive.hs#L61-L65
08:30:26 <latk> bartavelle: It is good to see that GHC8 will sort some of these issues, but I don't think I can wait on it for this project.
08:30:28 <bartavelle> latk, see the example just above
08:30:41 <latk> bartavelle: Taking a look now, thanks.
08:31:02 <bartavelle> latk, this solves the "my aeson instances are ugly" problem, but does nothing on the Haskell side
08:31:07 <byorgey> jewels: as for FlexibleInstances, it is completely benign and there is no particular reason to avoid it.
08:31:26 <latk> bartavelle: I assume it would be possible to combine makeClassy and Options somehow?
08:31:37 <byorgey> jewels: as for the type alias though, you cannot make type class instances for type aliases by default
08:31:54 <byorgey> jewels: and Map.Map already has a Functor instance anyway
08:31:55 <bergmark> jewels: yes it's a problem because you don't have a *new* type, you have just aliased an existing one that already has a Functor instance - you can't add yet another one
08:32:13 <bartavelle> latk, IIRC makeClassy has a kind of pattern built in so that if you do Foo { fooA :: Int } if will generate a lens "a"
08:32:29 <latk> bartavelle: Right. Awesome!
08:32:38 <byorgey> jewels: you probably want to make a newtype, like  newtype FuzzySet i m = FuzzySet (Map.Map i m)
08:32:39 <jewels> bergmark: Even if we use the suggested extension we need to define FuzzySet as a newtype?
08:32:53 <bergmark> jewels: if you want to write your own functor instance, yes
08:33:33 <bartavelle> latk, lookup http://haddock.stackage.org/nightly-2016-01-16/lens-4.13/Control-Lens-TH.html
08:33:49 <bartavelle> latk, it seems that you have to use the "makeLensesWith" function and have manual rules
08:35:19 <bartavelle> latk, also it seems I am wrong, there are no built in rules except for the removal of the leading "_"
08:35:36 <latk> bartavelle: It looks like the two would combine pretty easily, though.
08:36:02 <bartavelle> yeah, I usually don't mind the longer names for the lenses, so I usually just work on polishing the aeson instances
08:39:13 * hackagebot ghc-typelits-natnormalise 0.4 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.4 (ChristiaanBaaij)
08:42:46 <mnoonan> statusfailed: I was tinkering around with your Expr t problem some more last night, and it looks like Data.Bifunctor has some template magic that could be used to derive a Bifunctor instance for your ExprF.  And once you have that, you can get a functor instance on Expr t that does what you want.
08:47:20 <jeeger> Greetings! How do I go from an Except a b monad to an ExceptT a IO b monad? Is that possible in a succinct manner?
08:50:23 <bergmark> jeeger: ExceptT . return . runExcept
08:52:29 <bergmark> jeeger: you could also use mapExceptT
08:53:55 <obadz> jeeger: http://hoogle.haskell.org/?hoogle=Monad+m+%3D%3E+Except+a+b+-%3E+ExceptT+a+m+b&scope=set%3Astackage
08:55:53 <fr33domlover> anyone has suggestions for a name for a monad (transformer) for X11? Something that would make the monadic action types look readable. Examples: "X IO ()" ; 
08:56:02 <fr33domlover> "X11 IO ()"
08:56:16 <happy0> Xtreme IO ()
08:56:17 <obadz> How come hackage seems to be lacking documentation? For instance: https://hackage.haskell.org/package/errors-2.1.1/docs/Control-Error-Util.html
08:56:17 <rom1504> XIO
08:56:24 <fr33domlover> "X11T IO ()" ; "DisplayT IO ()"
08:56:29 <Hafydd> XXX IO ()
08:56:33 <bergmark> obadz: the doc builder gets overwhelmed at times...
08:56:40 <happy0> XtremeMonadicAction IO ()
08:56:44 <rom1504> I vote for XXX IO
08:56:44 <happy0> sorry, fr33domlover =p
08:56:47 <obadz> bergmark: ah
08:57:16 <johnw> XT IO?
08:57:50 <fr33domlover> hmmm actually it will /have/ to be on top of IO :P So it's not a transformer after all, just a monad that is an instance of MonadIO
08:57:52 <bergmark> obadz: i meant to ask in #haskell-infrastructure, i'll do that now
08:58:00 <fr33domlover> so e.g. "X ()" or "X11 ()"
08:58:03 <johnw> XIO
08:58:52 <fr33domlover> thanks for the suggestions everyone
08:59:22 <hexagoxel> 11 == XI, right? :D
08:59:24 <Hafydd> (Serious answer: following the style of Language.Haskell.TH.Q, which is a monad also in which IO actions can be embedded, I think just X would be a reasonable choice, as long as it doesn't become ambiguous.)
08:59:29 <johnw> hexagoxel: haha
08:59:30 <Aruro> XIO +1
08:59:32 <Hafydd> Hahah.
08:59:53 <Aruro> or IOX
09:00:37 <fr33domlover> johnw, what do you think about Hafydd's idea?
09:00:43 <sm> X11
09:01:00 <johnw> fr33domlover: just X makes sense too
09:03:35 <fr33domlover> hmmmm since the 11 there doesn't add much meaning I think X and XIO are the best ones
09:04:05 <johnw> plus, you're insulated against the day when X12 comes out :)
09:04:30 <fr33domlover> johnw, exactly ;) in the unlikely event it happens
09:04:37 <Hafydd> In my opinion, the "IO" part lends too much weight to the fact that it's a MonadIO instance. What if it becomes an instance of some other monad, too?
09:04:51 <jewels> Hi there again. How do I fix this code? http://lpaste.net/150265 I reported the question inside the code. Thank you very much!
09:05:26 <fr33domlover> I could also pick Display but it feels a bit too general
09:05:31 <dfeuer> I hacked up an implementation of zippers for sequences late last night. The code's a bit yucky. Does anyone have any suggestions for cleaning it up? http://lpaste.net/150271
09:06:19 <python476> hi again, since I can't redefine the List Monad because of duplicate conflicts is http://dpaste.com/1B4T1C4 sound ?
09:06:33 <python476> (and maybe I should head to #haskell-beginners ?)
09:07:01 <fr33domlover> Hafydd, i get your point, but on the other hand many monads are transformers while in my case it's specifically a monad that wraps IO
09:07:25 <dfeuer> python476, no, none of that is sound.
09:07:30 <Hafydd> fr33domlover: but it obviously isn't a transformer itself.
09:07:44 <Hafydd> (Because of its kind.)
09:07:58 <dfeuer> python476, you should define your own list type,   data List a = Nil | Cons a (List a) , and play with that.
09:08:10 <jewels> bergmark: Can you have a look to this http://lpaste.net/150265?
09:08:31 <python476> dfeuer: so obvious when read. Thanks a lot
09:08:34 <dfeuer> python476, not a single one of your instance definitions there will typecheck, and the first one won't even parse.
09:09:38 <fr33domlover> hmmm. ok, thanks for all the input, i'll go write that code now :P
09:10:50 <python476> dfeuer: the `::` instead of `:` ?
09:11:12 <dfeuer> python476, that's the reason for the parse error, but you have at least two more in that instance.
09:11:27 <Vyn> Hullo, quux
09:11:32 <Vyn> Oops
09:12:24 <python476> yeah, I meant the parse error only, the type errors I am still learning. Syntax would annoy me much more
09:14:09 <bergmark> jewels: you can't map over the first type variable, you will need to switch their order in the newtype definition. And same as before in the Functor instance:`FuzzySet' takes two type arguments but Functor requires something that only takes one
09:21:16 <bergmark> jewels: you may want to look at the functor instances for Map and tuples, this is also relevant https://www.youtube.com/watch?v=87re_yIQMDw
09:28:12 <python476> Nothing tops haskell to turn your brain into a sugar dissolving machine.
09:30:28 <tommd> Because there's so much syntactic sugar?
09:31:03 <python476> tommd: heh not bad
09:31:39 <python476> it's more that to break down typeclass polymeres you need physical sugar 
09:32:13 <Cale> python476: The arguments to fmap are backward, and just a single colon is used for list cons
09:32:33 <Cale> In the Applicative instance, (<*>) is not supposed to be (++)
09:32:44 <Cale> and in the Monad instance (>>=) is not fmap
09:32:57 <python476> Cale: yeah, I realized I didn't 'get' fmap 
09:33:06 <Cale> python476:  fs <*> xs = [f x | f <- fs, x <- xs]
09:33:16 <python476> now rebuilding it all with a fake Lis data type
09:33:22 <Cale> and  xs >>= f = concat (map f xs)
09:33:27 <python476> slow down sir
09:33:54 <python476> btw, <*> :: f (a -> b) ... <= this type gives me headaches
09:34:22 <python476> it's instanciating a Functor over a function type
09:34:34 <python476> alas, the eureka will come
09:34:54 <Cale> Well, if f is the type constructor for lists...
09:35:01 <Cale> (<*>) :: [a -> b] -> [a] -> [b]
09:35:11 <Cale> So it's taking a list of functions a -> b
09:35:15 <Cale> and a list of values of type a
09:35:42 <python476> that's a very loose idea though
09:35:43 <Cale> and it forms a list of values of type b, by picking a function, and an argument in all possible ways from the lists
09:35:53 <Cale> and applying the function to the argument
09:35:56 <python476> many way to "realize" these types
09:36:13 <Cale> Well, there are only a few which are really natural
09:36:16 <python476> each f on one a, or each f on each a
09:36:35 <ReinH> It has to abide the laws
09:36:41 <Cale> yeah, there's the version which basically zips the lists
09:36:44 <python476> ReinHocop
09:37:09 <python476> or is it Dredd.. anyways
09:40:14 <oisdk_> Is there an equivalent to <=< for <$> ?
09:40:44 <Cale> oisdk_: I'm not sure what that would mean
09:40:47 <johnw> yeah, me either
09:41:41 <Cale> oisdk_: It certainly isn't possible to write (<=<) using (<$>) alone
09:41:43 <oisdk_> If <=< is (kind-of) the points-free version of =<<, is there a similar points-free version of <$>
09:41:54 <Cale> uh...
09:41:57 * oisdk_ I've 
09:42:01 <Cale> What type is the operation you want?
09:42:20 <oisdk_> Functor f => (b -> c) -> (a -> f b) -> a -> f c
09:42:22 <johnw> f <$> x.  Dropping the point it's fmap f
09:42:45 <johnw> oisdk_: that would be fmap (fmap f)
09:42:58 <johnw> where the first fmap is using the (->) a instance
09:43:16 <bergmark> oisdk_: there's not an infix version of it, i would like one to use together with <=<!
09:44:14 <dfeuer> I repeat myself: can anyone help me improve this sequence zipper thing? http://lpaste.net/150271
09:44:53 <johnw>   improve how?  does it not work?
09:45:49 <dfeuer> johnw, I think it does work, but it's ugly as hell.
09:46:04 <johnw> dfeuer: in the end, the best reason for abstraction ;)
09:46:06 <dfeuer> I'm wondering if I've missed something.
09:46:49 <dfeuer> Like if I can align things differently somehow to avoid some of the mishmash.
09:47:26 <dfeuer> I seriously should just draw some diagrams of this bloody thing.
09:47:41 <oisdk_> Thanks, those make sense. I just find myself writing functions like "f x = g <$> h x" often; I'd like a way to just write "f = g ??? h"
09:48:09 <johnw> f = fmap g . h
09:48:28 <Cale> ^^ yeah, that's what I'd write
09:48:43 <Cale> I don't tend to use <$> very much unless it's in conjunction with <*>
09:48:43 <bergmark> oisdk_: i have called it <$< in the past, but sometimes i just do `return . f <=<'
09:48:57 <monochrom> dfeuer: if you're saying, pr' and sf' are mirror images of each other, can they be unified? then the answer is yes, lens can unify them. (does not need the lens library, just roll your own.)
09:49:00 <johnw> i'm not sure an operator here makes things clearer
09:49:17 <johnw> fmap g . h says just what it does: call h with the argument, then fmap g over the result
09:49:30 <bergmark> dfeuer: i think just adding empty lines between the where declarations would improve readability
09:49:32 <Cale> Yeah, operator symbols are only useful insofar as you can deal with remembering what they mean
09:49:44 <johnw> also, in this case, fmap g . h = fmap (fmap g) h
09:49:52 <dfeuer> monochrom, I think, sort of. You're right that that's a pretty good bit of code duplication to attack.
09:49:59 <monochrom> ??? is a great operator name. it means I can't remember what it's for :)
09:50:54 <dfeuer> I'm *more* worried about the unreachable errors; I'm going to see if I can shift alignment to avoid that. Messy.
09:51:20 <ReinH> idk ??? whatever
09:52:32 <johnw> icanhazresult ??? kthxbai
09:52:44 <bergmark> dfeuer: minor, but \z -> maybe z id = fromMaybe
09:53:15 <Cale> dfeuer: What is this for btw?
09:53:24 <dfeuer> Cale, trying to learn about zippers.
09:53:56 <Cale> dfeuer: I'd expect this to perform worse than a list-based zipper, at least until you introduce new operations for moving larger distances.
09:54:16 <dfeuer> Cale, yeah, those are definitely in my brain; just not in the code.
09:54:34 <dfeuer> That's where they shine.
09:56:23 <dfeuer> Cale, actually, I guess this came ultimately from trying to understand/improve the boxes code, which does some nasty stuff with lists. I got side-tracked.
10:00:51 <mightybyte> Announcing: The Monad Challenges - http://mightybyte.github.io/monad-challenges/
10:01:00 <mightybyte> A new take on an old theme
10:02:57 <ocharles_> Anyone got a link to the GHC 8 manual with the new formatting?
10:03:05 <ocharles_> mightybyte: nice!
10:04:16 * hackagebot hscope 0.4.3 - cscope like browser for Haskell code  https://hackage.haskell.org/package/hscope-0.4.3 (BorisSukholitko)
10:04:25 <ocharles_> got it - https://downloads.haskell.org/~ghc/master/users-guide/
10:07:20 <mightybyte> ocharles_: Thanks
10:09:23 <monochrom> ocharles_: I suggest an expansion of this to cover the whole Functor-Applicative-Monad hieararchy
10:09:33 * hackagebot state-plus 0.1.2 - MonadPlus for StateT  https://hackage.haskell.org/package/state-plus-0.1.2 (BorisSukholitko)
10:09:38 <monochrom> err, not ocharles_, misread
10:09:46 <ocharles_> monochrom: you meant mightybyte, I think. or you're just really presumptious of my free time ;)
10:09:47 <monochrom> mightybyte: I suggest an expansion of this to cover the whole Functor-Applicative-Monad hieararchy
10:09:49 <ocharles_> hehehe
10:10:10 <ocharles_> https://downloads.haskell.org/~ghc/master/libraries/base-4.9.0.0/GHC-Stack.html argh
10:10:47 <Ankhers> mightybyte: Can I suggest adding a stack.yaml file so people can use stack? (I can send a PR if you want)
10:11:02 <mightybyte> Ankhers: There's really no need.
10:11:03 * ocharles_ just reads the source
10:11:09 <mightybyte> It has no dependencies.
10:11:55 <mightybyte> Ankhers: So assuming your GHC is installed correctly it should never fail.
10:12:10 <bergmark> i'm leaning towards never adding stack.yaml to repositories if normal stack init calls work
10:12:37 <Ankhers> Fair enough.
10:13:04 <mightybyte> Btw, I posted it to Hacker News.  It's still on the New page if anyone cares to upvote.
10:13:09 <kadoban> Using something like that with stack should be more about just throwing it in a subdirectory of where you want to work and adding it as an extra-dep or whatever.
10:13:17 <mightybyte> I think it's particularly suited to that crowd.
10:13:39 <kadoban> Or I guess you should be able to just directly specify it from git too.
10:14:33 * hackagebot cabal-helper 0.6.3.1 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.6.3.1 (DanielG)
10:14:35 * hackagebot test-simple 0.1.8 - Simple Perl inspired testing  https://hackage.haskell.org/package/test-simple-0.1.8 (BorisSukholitko)
10:15:43 <sm> mightybyte: HN link ?
10:16:19 <sm> got it: https://news.ycombinator.com/item?id=10932484
10:16:51 <kadoban> mightybyte: Was it intentional that you made the gh-pages the default branch on the github thing? It sounded from the page like people were just supposed to download the repo to get the MCPrelude module, but it includes a lot more than that.
10:17:02 <kadoban> The master branch appears to include some of the page stuff as well.
10:19:07 <hiptobecubic> mightybyte, neato. I hadn't seen the crypto challenges either.
10:19:33 * hackagebot pure-cdb 0.1.2 - Another pure-haskell CDB (Constant Database) implementation  https://hackage.haskell.org/package/pure-cdb-0.1.2 (BorisSukholitko)
10:21:54 <mightybyte> sm: I've observed that HN seems to discount upvotes from people who went directly to the link.
10:22:06 <fr33domlover> I agree with "Monads must be discovered", I only understood them truly once I used RWST in an IRC bot I wrote
10:22:27 <fr33domlover> So trying them helped me undertand how to really use them
10:22:40 <mightybyte> kadoban: Yeah, Github suggests that you make gh-pages the default branch when you're using Github Pages.
10:23:33 <mightybyte> kadoban: I suppose I could give a different link for the clone instructions, but then it would have a tendency to get out of date when changes are made.
10:24:09 <mightybyte> hiptobecubic: Yeah, I did a few of the crypto challenges awhile back and thought it was a really good model.
10:24:43 <kadoban> mightybyte: Well, up to you I guess. It just seems a little odd to have that much extra stuff in the repo for what's essentially a library, though I guess it doesn't really hurt anything either.
10:26:23 <frerich> mightybyte: It looks nice! Small usability suggestion: it would be convenient to have a 'Next' link in each exercise.
10:28:54 <mightybyte> frerich: Thanks!  I thought about that.  I'm out of the country on vacation right now, so I probably won't be able to get to it any time soon.
10:29:58 <mightybyte> frerich: I was thinking about adding some more smarts to hakyll so it knows about the set/exercise structure and can automatically generate the link markup on the set pages.  It seems like this kind of a change would go really well with an automatically generated next button.
10:30:09 <mightybyte> frerich: Pull requests welcome though!  :)
10:30:18 * frerich nods
10:30:34 <frerich> mightybyte: Well first let me do the exercises :-)
10:31:02 <frerich> I always like re-learning stuff I think I knew already, usually there's a nice new perspective on things I hadn't considered before.
10:31:41 <mightybyte> frerich: Cool.  I look forward to your feedback.
10:32:14 <sm> mightybyte: really ? interesting
10:32:29 <twel> @undo do ; x <- [3,4] ; return ((+) x 1)
10:32:29 <lambdabot> [3, 4] >>= \ x -> return ((+) x 1)
10:32:55 <mnoonan> Is there a version of cata that preserves sharing?  (or does cata already? how could I tell?)
10:33:13 <sm> and now you're gone from https://news.ycombinator.com/newest .. did we miss our chance ? :-O
10:34:53 <ReinH> mightybyte: what are you doing here? You're on vacation! Go away! :D
10:39:51 <mightybyte> sm: I think it's still possible.  It's on page 2 of Newest.
10:40:12 <mightybyte> sm: I've seen stories of mine that I thought were way too far down make a comeback and end up on the front page.
10:40:38 <frerich_> mightybyte: On http://mightybyte.github.io/monad-challenges/pages/ex1-3.html I think 'rand :: Gen Char ' should be 'randLetter :: Gen Char'
10:40:42 <sm> cool. Thanks for the exercises, they look nice
10:40:54 <mightybyte> frerich_: Cool, can you send a pull request?
10:41:01 <Ankhers> the mods will also resubmit something if they think it should be seen more.
10:41:05 <frerich_> mightybyte: Sure
10:42:36 <frerich_> mightybyte: I do have a 'content' question though, maybe I misread the text...
10:43:19 <frerich_> mightybyte: I guess I'll submit that as an 'Issue' via Github
10:43:44 <mightybyte> frerich_: Yeah, that would be great.  Thanks.
10:44:15 <Th30n> Is there a function like this: (a -> b) -> (a, a) -> (b, b) ?
10:44:45 <Ankhers> @hoogle (a -> b) -> (a, a) -> (b, b)
10:44:45 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:44:45 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
10:44:45 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
10:45:23 <geekosaur> looks arrowy to me
10:45:34 <Th30n> It does, but not quite.
10:45:46 <Th30n> I guess I could do fun1 *** fun1 $ arg
10:45:56 <Ankhers> :t f g (a, a') = (g a, g a')
10:45:57 <lambdabot> parse error on input ‘=’
10:46:13 <geekosaur> gott aphrase it as a lambda
10:46:18 <Ankhers> right.
10:46:29 <Ankhers> :t \f g (a, a') -> (g a, g a')
10:46:30 <lambdabot> r -> (t -> t1) -> (t, t) -> (t1, t1)
10:46:39 <Ankhers> :t \g (a, a') -> (g a, g a')
10:46:40 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
10:58:59 <mnoonan> Th30n: if you are using lens, you can do "over both"
10:59:30 <johnw> using bifunctors, you can "bimap g g"
10:59:49 <mnoonan> :t \f (x,y) -> over both f (x,y)
10:59:50 <lambdabot> (a -> b) -> (a, a) -> (b, b)
11:00:17 <Ankhers> :t bimap
11:00:18 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
11:01:19 <Th30n> mnoonan: Oh, that's right. Thanks
11:03:54 <geoffreyiy> @pl \x -> x `rem` 5 == 0 && x `rem` 3 == 0
11:03:55 <lambdabot> ap ((&&) . (0 ==) . (`rem` 5)) ((0 ==) . (`rem` 3))
11:14:35 * hackagebot pusher-http-haskell 0.3.0.1 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-0.3.0.1 (willsewell)
11:19:19 <johnw> all ((== 0) . rem x) [3 5]
11:27:11 <ReinH> geoffreyiy: if you just want to use lambdabot for your own purposes, please use a private message
11:27:30 <ReinH> We get a lot of people who join, query lambdabot a few times, and then quit. It's frustrating.
11:28:02 <ReinH> You can also install the pointfree utility or even lambdabot locally.
11:36:19 <dedgrant> ReinH: a thought for admins-- can lambdabot be configured to reply via PM unless some explicit notation is given?
11:38:56 <Clint> that sounds terrible
11:41:05 <kadoban> dedgrant: I don't think that would help as much as it sounds like initially.
11:41:33 <dedgrant> yea just off the cuff
11:41:40 <Ankhers> We would get half the spam :P
11:42:31 <dedgrant> there may be a ux solution somewhere given enough effort
11:42:54 <the_2nd> what does the $= operator mean?
11:42:57 <geoffreyiy> spam from one user is managable
11:43:14 <Hijiri> :t ($=)
11:43:15 <lambdabot>     Not in scope: ‘$=’
11:43:16 <lambdabot>     Perhaps you meant one of these:
11:43:16 <lambdabot>       ‘$!’ (imported from Prelude), ‘/=’ (imported from Data.Eq),
11:43:30 <kadoban> the_2nd: What's it from?
11:43:42 <geoffreyiy> @hoogle $=
11:43:42 <lambdabot> No results found
11:43:53 <Hijiri> looks like it's from OpenGL package
11:43:56 <ReinH> geoffreyiy: yes, it's managed by asking them to stop.
11:44:22 <geoffreyiy> ReinH: I mean about lambdabot 
11:44:38 <ReinH> So do I.
11:44:42 <Hijiri> actually it's from StateVar
11:44:44 <Hijiri> https://hackage.haskell.org/package/StateVar-1.1.0.3/docs/Data-StateVar.html
11:45:05 <Clint> i thought it was from conduit
11:45:32 <Hijiri> looks like it's in conduit too
11:45:56 <Hijiri> and snap, iteratee, some other random things
11:46:38 <Hijiri> so it depends where it comes from
12:03:53 <ksj> ubuntu 16.04 is bretty good
12:04:04 <ksj> wait this was the wrong channels sorry
12:04:37 * hackagebot ghc-mod 5.5.0.0 - Happy Haskell Programming  https://hackage.haskell.org/package/ghc-mod-5.5.0.0 (DanielG)
12:10:16 <geoffreyiy> @pl (\x -> (x, f x))
12:10:16 <lambdabot> ap (,) f
12:11:41 <geoffreyiy> @pl (\x -> (f x,x))
12:11:41 <lambdabot> (,) =<< f
12:19:37 * hackagebot djembe 0.1.0.0 - Hit drums with haskell  https://hackage.haskell.org/package/djembe-0.1.0.0 (ReedRosenbluth)
12:22:11 <frerich_> mightybyte: I filed a couple of issues for the MC, it seems quite nice! Alas, I got too distracted after the second set. I sent you my notes.
12:24:37 * hackagebot djembe 0.1.1.0 - Hit drums with haskell  https://hackage.haskell.org/package/djembe-0.1.1.0 (ReedRosenbluth)
12:25:48 <fabian__> I found a VERY wierd haskell bug
12:25:50 <fabian__> The value of a variable changes if I print it
12:26:06 <navyer> Hi
12:26:22 <kadoban> fabian__: Sounds interesting. Is the code small enough to share?
12:26:26 <exio4> fabian__: code, please.
12:26:26 <ggVGc> fabian__: doubtful
12:26:28 <navyer> what's the point of Coyoneda?
12:26:50 <monochrom> how do you know that the wording "the value changes" is right for what you saw?
12:27:31 <fabian__> http://pastebin.com/Rbx6dvVH
12:27:46 <fabian__> compile run and notice output, then remove the commend and run again
12:27:52 <monochrom> could you tell pastebin.com to kill its double-spacing and its redactions?
12:28:09 <fabian__> yes
12:28:43 <monochrom> is it done now?
12:28:53 <kadoban> fabian__: Which one are we supposed to remove or not?
12:29:32 <fabian__> kadoban: If i run the program with the last line commented out, the output is 9183
12:29:35 <fabian__> 6413
12:29:38 <fabian__> 2770
12:30:06 <fabian__> if I include the --, the output is 6413
12:30:07 <fabian__> 6413
12:30:07 <fabian__> 0
12:30:07 <fabian__> True
12:31:10 <kadoban> fabian__: Oh. It should be because you don't have a type annotation on list2, so it's defaulting to [Integer] unless you compare it to list1, which is always [Int]
12:31:50 <sm> nice one :)
12:31:53 <kadoban> fabian__: So if you include that line, list2 *must* by type [Int], because you're comparing it with list1. But if you don't, then it's [Integer]
12:32:09 <monochrom> wait, you mean it is not the printing as said?
12:32:32 <fabian__> oh
12:32:59 <kadoban> monochrom: By the way, I always just click the "raw" link on pastebin.com . That should just be their default interface XD
12:33:41 <monochrom> yes, but I want people who choose pastebin.com to know how ridiculous it is.
12:33:47 <kadoban> Well, true.
12:34:02 <monochrom> it is approximately the 2nd worst paste bin out there.
12:34:12 <kadoban> There's a worse one?
12:34:39 <monochrom> 2nd only to the kind that gives you a pic not text.
12:34:41 <koala_man> we have the same problem in #bash. I have a bot there whose sole purpose is to post the raw link whenever it sees one
12:34:47 <kadoban> monochrom: Oh haha.
12:35:13 <kadoban> koala_man: Nice.
12:35:40 <kadoban> One of the channel I used to be in used to automatically copy pastes to the channel-favorite pastebin and announce the link.
12:35:58 <monochrom> lambdabot used to do it here, too. a long time ago.
12:36:00 <orion> What can I expect from GHC 8.0.1?
12:36:09 <monochrom> no, wait, it's mauke's bot, not lambdabot
12:36:09 <geekosaur> actually it was a mauke bot
12:36:31 <geekosaur> orion, https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1#LandedinHEAD
12:36:41 <orion> geekosaur: thanks
12:37:21 <monochrom> what is recursive superclass?!  <scared>
12:37:41 <roelof> Hello, I have this code to print some data in a tabular form : http://lpaste.net/150278. But I heard it's not good to use datastructures as arguments for functions. I could better use functions for passing the right argument.
12:37:50 <roelof> How can I do that ?
12:37:57 <monochrom> MonadFail is nice, of course
12:38:27 <Rembane> roelof: Why is it bad?
12:38:32 <kadoban> monochrom: The GHC ticket for that one has an example … which I didn't understand. I filed it away under "GHC stuff I probably don't need to use ever"
12:38:41 <monochrom> stack traces in ghci sounds good
12:38:47 <roelof> Someone told me that when reviewing my code 
12:38:59 <Rembane> roelof: Did they say why?
12:39:25 <monochrom> roelof, there is going to be a huge grey area for this
12:40:02 <roelof> Rembane: nope, and they told me also not a better way, The only what they told me that this way is brittle 
12:40:08 <suppi> should I read the new GHC users guide?
12:40:20 <Rembane> roelof: Interesting. Lets see... *reads code*
12:40:59 <kadoban> I think the most interesting ghc8 stuff for me is Applicative Do, MonadFail and the stack traces stuff. Also the OverloadedRecordFields or whatever should be cool once that's all done.
12:42:15 <Rembane> roelof: I suppose you could inline a lot of stuff, and remove most of the functions.
12:42:55 <suppi> kadoban, also strictdata maybe
12:43:10 <roelof> inline : you mean inside the calling function ? Rembane 
12:43:15 <monochrom> the floor is lava!
12:43:20 <kadoban> Yeah StrictData sounds kind of sometimes useful.
12:44:03 <Rembane> roelof: Yes. Put the code inside the calling function. On the other hand, inlining your code removes composability. And composability is nice to have.
12:45:01 <Rembane> roelof: I think your code is fine. And I think you should ask the one that gave you feedback what you can do about it to make it better by their standards.
12:45:23 <roelof> Rembane:  I did make a seperate function because I use it on multiple functions 
12:45:34 <Rembane> roelof: That's good stuff.
12:45:43 <roelof> Rembane:  thanks
12:46:18 <roelof> monochrom:  what is your oponion about this ? Can I leave it this way or is there a better way of doing this ? 
12:46:19 <Rembane> roelof: No worries, good luck!
12:47:20 <ReinH> roelof: well, it could be improved by using your own ADT instead of a tuple.
12:47:38 <roelof> ReinH:  ADT ??
12:47:55 <ReinH> an algebraic data type, e.g., data PrintItem = PrintItem Name Amount
12:49:11 <ReinH> other than that, I don't see an issue with it.
12:50:25 <roelof> ReinH: oke, so instead of a type make it a data type ? 
12:50:29 <ReinH> right
12:50:41 <ReinH> generally you should prefer making data types to making type synonyms.
12:51:36 <roelof> ReinH:  thanks, I will try it that way 
12:52:27 <Peaker> Sum types, recursive types, and product types are all great. I've grown to dislike their mishmashing into an all encompassing Algebraic data type
12:52:45 <Peaker> there are benefits to be had from distinguishing the 3 constructs
12:52:48 <ReinH> type synonyms don't improve type safety, and in fact can reduce it. e.g., type Amount = Int; type Account = Int; withdraw :: Account -> Amount -> (Account, Amount) doesn't prevent you from passing an amount instead of an account and vice versa.
12:53:24 <ezyang> Is there a "state-sponsored" way of parsing strings with escape sequences in attoparsec? 
12:53:29 <ReinH> well, that withdraw function isn't super useful, but you get the ideaa
12:53:48 <ezyang> The obvious approach using 'many' doesn't really work because you get a [Char] which you then need to convert back into a ByteString 
12:54:02 <roelof> ReinH:  that not good.  If I change it to a datatype  then I do not get that problem 
12:54:20 <ezyang> (as in, it does work, but it goes through an annoyingly inefficient representation first) 
12:54:21 <ReinH> roelof: right, newtype Amount = Amount Int; newtype Account = Account Int does not have that problem
12:55:19 <ReinH> It also makes sense to derive Num for Amount (so you can add and subtract amounts) but not accounts (which are identifiers, not numbers with arithmetic operations)
12:55:24 <ReinH> etc
12:55:36 <roelof> ReinH:  I will study the newtypes.  I have not learned it so far 
12:55:45 <ReinH> @google haskell wiki newtype
12:55:46 <lambdabot> https://wiki.haskell.org/Newtype
12:55:58 <monochrom> ezyang: to some extent the two choices are a state machine or a lot of lookaheads
12:56:14 <Jinxit> does deriving Num just apply the operators to all types?
12:56:29 <ezyang> monochrom: OK... well, that's fine for me to implement, but that's very hard to explain to a beginner! 
12:56:52 <kadoban> Jinxit: You usually can't derive Num. Are you talking about in GeneralizeNewtypeDeriving ?
12:56:57 <monochrom> perhaps don't inflict "parse escape sequences!" on beginners. I know I wouldn't.
12:57:04 <ReinH> Jinxit: deriving Num is enabled by GeneralizedNewtypeDeriving, and applies to the thing you derive num for.
12:57:13 <ezyang> monochrom: Haha, tell that to "Implementing Functional Systems in Haskell" 
12:57:15 <Jinxit> ah
12:57:39 <Jinxit> but for a "Thing Int Float" it would distribute over the Int and Float?
12:57:45 <monochrom> is that a book? I want to complain to the author.
12:57:57 <ezyang> It's a class running at Stanford right now 
12:58:06 <ReinH> bos's class
12:58:14 <ezyang> It's ostensibly about "Real" Haskell, so you gotta use ByteStrings 
12:58:18 <ezyang> but this is just really annoying 
12:58:19 <monochrom> ok, I guess Stanford gets to make it hard
12:58:41 <ReinH> Bryan generally speaking will do whatever Bryan wants. :)
12:58:43 <ezyang> I mean, the RIGHT approach is that your tokenizer would have dealt with it for you 
12:59:10 <kadoban> Jinxit: That doesn't sound like a newtype, so I'm not sure what you mean. GND wouldn't work on that, so it won't do anything.
12:59:11 <ReinH> ezyang: I hardly see a separate lexing phase any more for most parser tutorials.
12:59:19 <ezyang> sigh 
12:59:24 <Jinxit> oh, only newtypes, derp
12:59:30 <ReinH> kadoban: that could be a newtype
12:59:42 <ReinH> er no, sorry
12:59:42 <monochrom> I know how to do it right within one single pass of using parsec or attoparsec, but it is not going to be a naive as "I can use many"
12:59:46 <ReinH> misread
13:00:27 <kadoban> Jinxit: Right. In which case the translation is pretty conceptually trivial "unwrap, do thing, rewrap".
13:00:56 <monochrom> actually, you can still use many. just don't say "many char".
13:00:56 <Jinxit> yeah
13:01:30 <monochrom> define a "token" parser, and henceforth, define everything else in terms of it. for example "many token" is fine.
13:03:15 <monochrom> and token is something like: satisfy ('\\' /=) <|> (some piece of code here that parses one escape sequence)
13:03:40 <monochrom> so that's how you can sanely collapse two layers (one tokenizing, one CFGing) into one
13:04:21 <ezyang> monochrom: Well, you only want that inside quoted strings 
13:04:22 <monochrom> I think this is a trick you can explain to beginners and they will thank you. but they won't invent themselves. I certainly didn't.
13:04:54 <monochrom> ok but you want to uniformly do it for the whole thing for sanity and discipline.
13:05:14 <monochrom> s/it/something alone this line/
13:06:26 <monochrom> I am essentially saying what I learned from parsec's Text.Parsec.Token and the spirit behind it
13:06:37 <ezyang> Fair enough :) 
13:06:50 <sphinxo> I'm split between using elm and purescript for a web project. Which one do people most recommend? 
13:09:03 <suppi> sphinxo, what kind of a project?
13:09:39 * hackagebot cassava 0.4.5.0 - A CSV parsing and encoding library  https://hackage.haskell.org/package/cassava-0.4.5.0 (HerbertValerioRiedel)
13:10:16 <sphinxo> canvas graphics stuff
13:12:06 <suppi> sphinxo, both will work. elm will probably be easier to learn, I like purescript better :)
13:12:14 <sphinxo> ok, thanks :)
13:13:13 <suppi> sphinxo, elm has a dsl for graphics stuff, purescript has canvas bindings, so elm will probably be easier in that domain (at least at first)
13:21:23 <dfeuer> I would never have guessed that   instance Functor ((,,,) a b)  would prove to be controversial. o.O
13:22:25 <johnw> the simplest things usually are
13:23:04 <Cale> Why controversial?
13:23:20 <Cale> The instance itself shouldn't be... it's pretty much unique
13:23:25 <johnw> tuples are evil, tuples are bad, nobody should ever use tuples as functors, etc.
13:23:42 <Cale> I guess 4-tuples are pretty rare as it is
13:23:43 <johnw> oh, fmap on an n-tuple isn't like a list of n elements
13:23:57 <dfeuer> Cale, I sent the proposal to the library list, and there's been a firestorm.
13:23:57 <johnw> I still don't quite follow that logic, but I've heard it a few times
13:24:13 <Cale> Well, a moment's thought about that should make it clear why fmap on a tuple isn't like fmap on a list
13:24:25 <Cale> But huh
13:24:28 <johnw> Cale: yeah, huh
13:24:35 <dfeuer> Mostly it's what johnw said, that tuples with more than two elements are pretty much evil, and using them as functors would usually be a mistake. 
13:24:39 <dfeuer> Which is ... whatever.
13:24:44 <Cale> There is the question about whether it's really worth having the instance for 4-tuples, since they come up so rarely
13:24:46 <dfeuer> *sigh*
13:25:09 <dfeuer> It's not terribly expensive in the grand scheme of things.
13:25:17 <Cale> But hey, the same could be applied to 4-tuples generally
13:25:38 <Cale> Or any of the other instances
13:26:01 <Cale> I would tend to think that Functor instance for (,,,) should be *about* as controversial as the Eq instance for it.
13:29:10 <jle`> perhaps the people against the Functor instance were also against the Eq instance
13:29:22 <jle`> but they weren't around to resist
13:30:00 <dfeuer> All I know is that I reached for Functor ((,,) a b)  in a weird foldr form and it just wasn't there.
13:30:45 <jle`> i still am waiting for Monoid w => Monad ((,) w)
13:31:58 <ralu> i am waiting for (a, (b, c)) -> (a, b, c)
13:32:51 <shachaf> Tell me when I can get instance Comonoid e => Monad (e ->)
13:33:11 <dfeuer> jle`, why isn't that one here yet?
13:34:17 <adamCS> Cale:  Gotta run but thanks again.  Van Laarhoven Free Monad works, in the sense that I can separate the Layout DSL from the implementation/interpreter.  I've got a simple one which does FreeVL Layout a -> State (Rose String) a, and results in the correct Rose tree.  So that's good.  Now I'll see if I can wrap the monad widget version, probably by an interpreter to MonadWidget t m=>StateT (Rose LayoutInfo) m.  
13:34:40 <Cale> adamCS: cool
13:35:09 <monochrom> if 4-tuples are "no one should use them", then giving it a Functor instance consistent with math ideals harms no one, no?
13:35:21 <dfeuer> shachaf, whoa. something like   join f e = uncurry f (split e)    ?
13:35:36 <python476> hell, I managed to reimplement the List monad, but I'm so not on par with the subject I don't know how to use it yet. Them noobs.
13:35:59 <Gurkenglas> mauke, http://mauke.ath.cx/stuff/haskell/fun.hs doesn't work, is it somewhere else now?
13:36:07 <adamCS> Cale:  Since the VL Free Monad is isomorphic to the "normal" one, there must be a way to do it that way but I'm not quite sure where the State (Rose String) or whatever would come from.  Anyway, questions for another time.
13:36:35 <monochrom> python476: when you use the List monad, you will feel like you're merely writing list comprehensions in a different notation. this is ok. it is meant to be that way, no more.
13:36:49 <Cale> adamCS: Yeah, there will be, it's just kind of tricky to figure out what it is :)
13:37:43 <monochrom> example: [ x+1 | b<-[1,2,3], x<-[b, b+2] ] = do { b<-[1,2,3]; x <- [b, b+1]; return (x+1) } = [1,2,3] >>= \b -> [b, b+1] >>= \x -> return (x+1)
13:38:19 <mauke> Gurkenglas: http://lpaste.net/150281
13:38:25 <python476> monochrom: I was still trying to map the do notation with actual monadic functions
13:38:40 <x_pilot> hey does anyone know how to pass --extra-lib-dirs to runhaskell?
13:38:43 <monochrom> ah right. it is not hard. just spend some time practicing.
13:38:48 <python476> say let xs = mylistrange ... in x >>= ???
13:38:59 <python476> so far monadicvalue >>= pure is alright ~_~; don't laugh
13:39:16 <x_pilot> I have a .so in a nonstandard location and it isn't being found
13:39:26 <python476> haskell is funny, it's like live templated java, thinking in abstract generic interfaces only
13:39:32 <python476> (do not laugh again)
13:39:32 <monochrom> monadicvalue >>= pure  =  do { x <- monadicvalue; pure x }
13:39:49 <monochrom> that is a fair impression actually
13:39:58 <python476> monochrom: yeah, the syntactic transforms I do get, it's monadic thinking. 
13:40:10 <python476> like composing monadic functions, it still makes me dizzy
13:40:27 <monochrom> "let" stays as let with little change when converting to-or-from do-notation
13:40:31 <zigschots20> I've just been learning about lenses, from the lens over tea article, and they make some sense. I've looked around, and noticed the general approach seems to be to think about them as a generalised modifier
13:40:49 <zigschots20> or, as a unification of getters, setters, traversals etc...
13:41:00 <monochrom> there is a tiny change but it's still "let", no new >>= or something. (only a difference of having or not having an "in")
13:41:05 <python476> for instance : x >>= (myrepeat 3) . (+1) works, and I didn't expect it to work. I don't want to be in guess mode
13:41:34 <zigschots20> which im sure is great once you're clear on what they are. I thought however, at least to begin with, it makes some sense to think of them as lifting functions
13:41:47 <monochrom> well, I would first write that as: x >>= \v -> myrepeat 3 (v + 1)
13:42:13 <zigschots20> at least it makes, the name clear. I wrote a little about it, since I couldn't find this way of describing it in a quick google search. I'd be interested as to thoughts
13:42:20 <zigschots20> https://thehackysack.wordpress.com/2016/01/19/lens-refocused-or-why-parentheses-matter/
13:42:34 <python476> monochrom: right. Still took me 30 seconds to grasp your code
13:42:51 <monochrom> and if necessary, even this verbose thing: x >>= \v -> myrepeat 3 (v + 1) >>= \y -> return y
13:43:14 <monochrom> do notation: do { v <- x; y <- myrepeat 3 (v+1); return y }
13:43:46 <monochrom> 30 seconds is fast. you are doing good.
13:44:00 <python476> again going from mv <- mf ; mg mv => mf >>= (\mv -> mg mv) I think I got
13:44:02 <monochrom> even 1 minute is pretty fair
13:44:15 <monochrom> yes
13:44:18 <python476> monochrom: how long people do spend on Fun App and Monad ?
13:44:34 <python476> before being able to think without fumbling
13:44:39 <crossroads1112> Is there a way to get the source of a function similar to lambdabot's @src from ghci?
13:44:46 <monochrom> I spent 2-3 months, I think? a long time ago, it's hazy now
13:44:52 <Gurkenglas> <monochrom> if 4-tuples are "no one should use them", then giving it a Functor instance consistent with math ideals harms no one, no? <- It would harm the ones who read code using the instance. (I disagree with "no one should use them", though :P)
13:44:55 <geekosaur> no (and @src lies)\
13:45:01 <suppi> python476, everyone have their own pace
13:45:06 <crossroads1112> geekosaur, why do you say that?
13:45:12 <python476> suppi: sure, just getting a feel of an average
13:45:22 <geekosaur> (@src just looks up text in a database, some of it was culled from ancient sources or the h'98 report)
13:45:24 <python476> and the structure of progression
13:45:36 <python476> linear, plateau + log
13:45:48 <monochrom> Gurkenglas: me too, it's why I put it in quotes.
13:46:27 <crossroads1112> geekosaur: Oh, I understand. It would be feasible to write something up that, if I had the Haskell source downloaded, did something similar right? Or would there be some hurdle that I'm missing?
13:46:50 <Gurkenglas> I thought so, which is why I felt the need to clarify that I agree with your position, but not your logic
13:47:20 <geekosaur> https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source is where @src pulls from
13:47:47 <monochrom> well, I am refuting the inference "no one should use 4-tuples, therefore no Functor instance should be given"
13:48:14 <geekosaur> note that ghci does not remember the source for anything you enter at the REPL, nor keep close track of anything loaded from files, nor *anything* about source from libraries it loads as .o/.hi files
13:48:45 <monochrom> and I don't feel like arguing over the premise "no one should use 4-tuples".
13:49:20 <geekosaur> at least one standard function does (createProcess)
13:49:40 * hackagebot accelerate-cuda 0.15.1.1 - Accelerate backend for NVIDIA GPUs  https://hackage.haskell.org/package/accelerate-cuda-0.15.1.1 (TrevorMcDonell)
13:49:59 <geekosaur> ...hard to avoid tuples to return multiple values hat aren't logically related such that an ADT would make sense
13:50:33 <geekosaur> but it's really the only use for them, and you should pattern match the components into local bindings and forget the tuple
13:51:41 <monochrom> translating from recursive-do to mfix uses a lot of tuples
13:51:50 <geekosaur> crossroads1112, that said, you might look into a local hoogle instance, which can be hooked into ghci (not sure what the current preferred way is)
13:52:13 <geekosaur> ut it till won't index stuff entered at the prompt or :load-ed, only installed packages
14:34:41 * hackagebot tasty-silver 3.1.8.1 - A fancy test runner, including support for golden tests.  https://hackage.haskell.org/package/tasty-silver-3.1.8.1 (PhilippHausmann)
14:39:43 <James123> Hello, does anyone know a good resource to understand monads? I am really confused :(
14:40:08 <mauke> I'd just ignore monads
14:40:11 <crossroads1112> James123: Generally I'd stay away from the monad tutorials
14:40:50 <crossroads1112> LYAH is pretty good, as is the Typeclassopedia on the wiki
14:40:52 <Cale> James123: Do you understand IO already?
14:41:03 <sm> understand enough to invent/build them, or to use them ?
14:41:27 <Cale> James123: I would recommend trying to understand a few examples of monads before trying to understand what Monad is generally -- it's really just a pattern which shows up in various libraries
14:41:35 <James123> Cale: Very basic IO stuff, just to print
14:41:43 <Cale> and we abstract over it in order to be able to not have to write some common functions over and over
14:41:48 <crossroads1112> Cale: I don't know if anyone else has had this experience, but for me, understanding other monads like Reader, Writer, State, Maybe etc. were much easier to grasp than IO because I could see the implementations
14:42:26 <Cale> crossroads1112: Sure, the reason I asked is also just because sometimes people ask about monads when they really want to ask about IO :)
14:42:35 <sphinxo> James123: this is perfectly normal, don't worry about monads, just learn about other functional things for the moment
14:42:39 <crossroads1112> Cale: ahh I understand
14:42:41 <frerich_> James123: Actually, earlier today somebody announced http://mightybyte.github.io/monad-challenges/ :-)
14:42:58 <James123> sphinxo: Ok, thank you
14:43:01 <crossroads1112> James123: I agree with sphinxo. Maybe start with functors or applicatives
14:43:01 <Cale> Actually, the example which really made the purpose of the Monad class click for me originally was Parser
14:43:06 <sm> James123: perhaps https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/3-pure-functions-laziness-io
14:43:07 <James123> frerich_: I will give a try much much later :)
14:43:32 <frerich_> James123: I can't tell how useful it is, but it's it says 'We are trying to guide you down the path to a fully internalized working knowledge of monads. ' :-]
14:43:44 <sphinxo> James123: Look at list comprehensions, fmap for a good start
14:43:56 <sphinxo> then maybe have a glance at foldl
14:44:02 <sphinxo> ( fold left )
14:44:05 <sm> or https://wiki.haskell.org/Introduction_to_IO
14:44:32 <Cale> James123: If you have a look at Parsec, which is a library for building parsers, it defines a Parser type constructor, such that a value of type Parser t represents something which will try to eat the beginning of a String and produce some result of type t.
14:44:48 <sphinxo> James123: Have you done any functional programming before?
14:45:01 <Cale> James123: and there are various ways of chaining these together so that each one will eat the rest of the input which was left after the last
14:45:16 <Cale> James123: One of the ways is an operation:
14:45:24 <James123> sphinxo: Yes, but in Ocaml where I used some side effects!
14:45:25 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
14:45:41 <sphinxo> James123: ahh ok
14:46:04 <sphinxo> Something that really made me understand fp in general much more is:
14:46:16 <Cale> such that the parser x >>= f will parse the beginning of the input using the parser x :: Parser a, and then take the result of that parser, and apply f to it in order to get a parser for parsing the remainder of the input, and do that. 
14:46:19 <sphinxo> in fp you say what something is
14:46:39 <Cale> James123: make sense? The result of the combined parser here is the result of that second parser.
14:46:44 <crossroads1112> Getting functors first with fmap was really helpful to me
14:46:58 <sphinxo> whereas in other languages you are doing things sequentially
14:47:09 <zachk> is the Parser Monad kind of a State Monad? 
14:47:18 <sphinxo> James123: Haskell is a pure language
14:47:25 <Cale> zachk: It's sort of like StateT String [], if you know what that means :)
14:47:48 <James123> sphinxo: Yes, that is the reason I got interested and by its elegance :)
14:47:53 <Cale> (because parsers can parse things in multiple ways for the sake of backtracking)
14:48:04 <sphinxo> James123: have you heard of memoization?
14:48:06 <James123> Cale: Thank you for the explanation, I think I got it
14:48:14 <zachk> you the [] allows it to handle nondeterminism? 
14:48:27 <James123> sphinxo: Yes, is is where we store things we used quite a lot?
14:48:57 <sphinxo> yep :) one of the nice "side effects" of all functions being pure. 
14:48:58 <Cale> James123: Another little piece which we end up capturing is the simple function  return :: a -> Parser a  which makes a parser that always succeeds without eating any of its input, and just results in the given value
14:49:05 <crossroads1112> Cale: I thought StateT took something of kind (* -> *) first?
14:49:24 <crossroads1112> Ohhh no, just checked, that's second
14:49:39 <Cale> James123: For various type constructors m, operations  return :: a -> m a  and  (>>=) :: m a -> (a -> m b) -> m b  show up in various different libraries.
14:50:03 <Cale> (they might not always be named that if we didn't have the Monad class around)
14:50:27 <James123> Cale: So we basically abstract these and end up in Monads, right?
14:50:30 <Cale> But yeah, this is a pattern that shows up when we're working with libraries that consist of "basic computations" and then "ways to glue computations together"
14:50:43 <Cale> Yeah, Monad is a type class:
14:50:47 <Cale> class Monad m where
14:50:51 <Cale>   return :: a -> m a
14:50:57 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
14:51:14 <Cale> (roughly, leaving out some details which are not as important)
14:51:41 <Cale> and then in terms of this return and (>>=), we can write a whole bunch of control-structure-like things
14:51:52 <Cale> and use those with all the libraries which implement such operations
14:52:04 <Cale> You can look in Control.Monad for a bunch of them
14:52:06 <Cale> But for example
14:52:16 <Cale> sequence :: Monad m => [m a] -> m [a]
14:52:33 <Cale> takes a list of "actions" of some monad m
14:52:52 <Cale> and produces an action which will "run them all" and collect a list of the results
14:53:34 <Cale> Before we get to implementing sequence, it might be good to introduce do-notation, just because it's a little easier to read than nested lambdas that show up when you use (>>=) a whole lot
14:54:18 <Cale> do-notation is just syntax sugar, and we can translate it away recursively as follows
14:54:18 <monochrom> oh, I should bookmark mightybyte's new monad exercises
14:54:37 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
14:54:56 <monochrom> http://mightybyte.github.io/monad-challenges/
14:55:20 <Cale> do { x ; <stmts> } = x >> do { <stmts> }  where  x >> y = x >>= (\k -> y)
14:55:21 <James123> Cale: It makes more sense to me now :) Thank you for you nice explanation!
14:55:48 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
14:55:52 <Cale> and as a base case
14:55:55 <Cale> do { x } = x
14:56:10 <Cale> So, let's write sequence:
14:56:33 <Cale> sequence [] = return [] -- if the list of actions to run is empty, produce the action which "does nothing" and gives an empty list as its result
14:56:51 <Cale> sequence (x:xs) = -- if the list of actions to run is not empty...
14:57:06 <Cale> sequence (x:xs) = do v <- x; ... -- run the first one, getting some result v
14:57:22 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- then run the rest, getting a list of results vs
14:57:37 <Geraldus> hi folks!
14:58:04 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- finally, run the action which does nothing except to produce (v:vs) as its result (and the result of the last action here is always the result of the combined one)
14:58:18 <Geraldus> Does anyone know what is the minimal OS X version to run GHC 7 (and upcoming 8) with stack?
14:58:22 <Cale> James123: Does that make sense?
14:58:56 <Cale> James123: We can desugar that do-block in terms of (>>=):
14:59:02 <Cale> @undo do v <- x; vs <- sequence xs; return (v:vs)
14:59:02 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
14:59:08 <James123> Cale: Yes, it started making sense from the point you said that monads are a typeclass.
14:59:26 <Cale> yeah, or Monad is, and monads are the type constructors which are instances of it
14:59:56 <Cale> So, because we can implement a sensible return and (>>=) for Parser, we say that Parser is a monad
15:00:01 <Cale> We can also do it for lists
15:00:06 <Cale> instance Monad [] where
15:00:10 <Cale>   return v = [v]
15:00:19 <Cale>   xs >>= f = concat (map f xs)
15:00:30 <Cale> So here  return :: a -> [a]
15:00:38 <Cale> and  (>>=) :: [a] -> (a -> [b]) -> [b]
15:00:58 <Cale> So what does it mean to "run" a list? Well it turns out it's like "pick an element from it (in all possible ways)"
15:01:12 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
15:01:14 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
15:01:29 <Cale> and because we have that Monad instance, we get things like sequence for free:
15:01:36 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
15:01:38 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
15:02:00 <Cale> We don't have to go to the trouble of making that function for lists, it's already there once we bother to define return and (>>=)
15:02:36 <James123> Cale: So list comprehensions in haskell could be/have been implemented like this
15:02:40 <Cale> yep
15:03:08 <Cale> and in fact, there's a MonadComprehensions extension which you can turn on which makes list comprehension syntax available for other monads as well.
15:03:59 <Cale> (it's really about the same thing as the do-notation, except you have the extra boolean guards, which require mzero to represent failure, which isn't part of the Monad class, but something called MonadPlus)
15:04:48 <Cale> There's also simple things like
15:05:00 <Cale> liftM2 f x y = do u <- x; v <- y; return (f u v)
15:05:21 <scshunt> local hoogle is the best thing ever
15:05:26 <Cale> "Make the action which will run these two actions and combine their results with f"
15:05:44 <Cale> which are just endlessly handy to have around
15:06:10 <Cale> and we'd end up writing hundreds of times across many libraries if Monad weren't there, even though they're really simple, it does add up
15:06:56 <Cale> So Monad isn't a huge deal - we'd get by pretty much fine without it, but it is a nice concept, and it saves us writing a bunch of code.
15:07:02 <scshunt> is there a way to get a complete offline docs package for stackage?
15:07:40 <James123> Cale: Really nice explanation. Maybe you should write a tutorial sometime, I liked the way you tackled it in different ways
15:08:01 <Cale> James123: I did write https://wiki.haskell.org/Monads_as_containers
15:08:15 <Cale> and more importantly https://wiki.haskell.org/Monads_as_computation
15:08:29 <Cale> I gave you the monads as computation view there
15:09:08 <Cale> You can sort of think of monads as being like container types abstractly, but your notion of what a container is generally has to be willing to bend a good bit farther than most people seem comfortable with
15:09:27 <scshunt> why does 'guard' require an Alternative? it doesn't actually need monoid structure, just a zero
15:09:29 <Cale> So I no longer usually point people at that one first :)
15:09:44 <scshunt> you get shit like the Maybe "monoid" as a result
15:09:56 <Cale> scshunt: That is an excellent point
15:10:09 <Cale> It actually used to have a MonadZero constraint
15:10:20 <Cale> back in Haskell 1.4 (before Haskell 98)
15:10:33 <James123> Cale: Thanks! For the time been, I think I am more than covered on the topic :) 
15:11:11 <Cale> But in writing Haskell 98, for some reason, they had the questionable idea that since all the instances of MonadZero *in the standard library* were also instances of MonadPlus, why not just merge the two classes?
15:11:46 <Cale> Well, this happened after de-generalising list comprehensions to only apply to lists instead of needing MonadZero
15:12:02 <Cale> (because someone's students were confused about the MonadZero type errors)
15:12:24 <Cale> So... yeah. guard ended up with a MonadPlus constraint when that merge happened
15:12:27 <scshunt> why was Maybe an instance of MonadPlus?
15:12:32 <scshunt> that's the first mistake :P
15:12:56 <Cale> Well, there's a decent instance -- and one which even is quite handy a lot of the time
15:13:17 <Cale> But yeah, Alternative and Applicative are both much newer
15:13:34 <Cale> However, history aside...
15:13:35 <scshunt> I'm assuming that the Maybe instance of MonadPlus is the same as the Alternative instance
15:13:56 <Cale> There is a good argument that without <|> it's hard to express what laws the zero should satisfy
15:14:16 <Cale> yeah, it is
15:14:34 <scshunt> (I mean, nowadays, the very existince of MonadPlus is just for compatibility anyway)
15:14:39 <scshunt> *existence
15:14:47 <Cale> Kinda
15:14:49 <scshunt> The point about the laws is fair
15:17:14 <Cale> If we were doing it all again, we might want to keep something along the lines of MonadPlus, but define it as a simple subclass of Monad and Alternative with no methods.
15:17:31 <Cale> I don't know
15:18:49 <scshunt> Cale: just as a typeclass alias, really?
15:18:54 <Cale> yeah, pretty much
15:19:05 <scshunt> or because something might have Monad and Alternative instances that don't align?
15:19:18 <Cale> Well...
15:19:22 <Cale> Actually, hah
15:19:48 <Cale> There was an old, somewhat reasonable proposal to have two classes with similar-shaped operations
15:19:52 <Cale> But different laws
15:19:56 <scshunt> hah
15:20:10 <Cale> https://wiki.haskell.org/MonadPlus_reform_proposal
15:20:16 <scshunt> you could just let Constraint kinds do that if you just wanted an alias, couldn't you? MonadPlus a = (Alternative a, Monad a)
15:20:33 <Cale> There are two common ways in which (<|>) / mplus interact with (>>=)
15:20:42 <Cale> and it might be nice to know which one you were dealing with
15:21:07 <Cale> also, some types (especially lists) can get you both behaviours, and we don't have a name for one of them at present
15:21:46 <Cale> i.e. [] `orElse` ys = ys; xs `orElse` ys = xs
15:22:31 <scshunt> right
15:24:43 * hackagebot GPipe 2.1.6 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1.6 (TobiasBexelius)
15:39:44 * hackagebot logging-effect 1.0.0 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.0.0 (OliverCharles)
15:49:12 <toblerone> Hi all, which xml parsing library would you recommend? I've used HXT in the past but wasn't very happy with it. Is XML-Conduit a good choice?
15:49:16 <toblerone> Any other options?
16:10:43 <Geraldus> Hey people! (: Does anyone tried to use stack on guest os?  I have an issue when `stack setup` stucks while downloading GHC
16:11:46 <Axman6> Geraldus: what os is "guest os"?
16:16:21 <kadoban> Maybe they mean in a VM? But I know that works fine.
16:24:46 <KaiJia> morning
16:35:23 <fr33domlover> Advice needed: I'm defining a monad that wraps IO. Right now it's just ReaderT on top of IO, but I'm realizing many functions allocate resources so I'd like to also use ContT, i.e. ContT=>ReaderT=>IO monad stack. Is it a good idea to use the ContT like that where the monad is newtype-wrapped so the user doesn't see the ContT and may decide to wrap it further with their own ContT etc.?
16:35:56 <fr33domlover> I understood it's no issue to have ReaderT used "secretly" under the newtype, just want to make sure the same applies to ContT
16:36:57 <fr33domlover> (I'm using transformers here btw, not mtl)
16:51:23 <obadz> i'm a n00b so take it for what it's worth
16:51:38 <obadz> but all the functions you're going to expose will talk to your "newtype"
16:52:17 <obadz> so as far as anyone outside of your stack is concerned, your MT layers are fused into that newtype
16:52:27 <obadz> and only accessible via the api that you chose to expose
16:53:26 <obadz> callers can still put more MT layers above your newtype (or below and access them via `lift`)
16:54:36 <obadz> so afaik, it doesn't matter how many, or which type of layers you have fused into the newtype
16:54:46 * hackagebot derive-monoid 0.0.0 - derive Semigroup/Monoid/IsList  https://hackage.haskell.org/package/derive-monoid-0.0.0 (sboo)
16:59:39 <RGamma> Hello, there. Can someone hint me to resources that might explain why "(\x -> (if x == 0 then x else x)) (0==)
16:59:52 <RGamma> " type-checks, but it's beta-reduced form does not?
17:00:24 <RGamma> :t (\x -> (if x == 0 then x else x)) (0==)
17:00:27 <lambdabot> (Eq a, Eq (a -> Bool), Num a, Num (a -> Bool)) => a -> Bool
17:00:39 <RGamma> :t if (0==) == 0 then (0==) else (0==)
17:00:42 <lambdabot>     Could not deduce (Num a0) arising from the literal ‘0’
17:00:42 <lambdabot>     from the context (Eq a, Num a)
17:00:42 <lambdabot>       bound by the inferred type of it :: (Eq a, Num a) => a -> Bool
17:01:46 <RGamma> This seems really counterintuitive to me :(
17:03:10 <RGamma> point*
17:07:22 <fr33domlover> RGamma, you are passing (==0) which is a function to the lambda, so it should work only if (a -> Bool) is really an instance of Eq - which isn't the case iirc?
17:07:36 <fr33domlover> maybe that is relevant, i dunno :P
17:08:17 <fr33domlover> ah, also this:
17:08:34 <fr33domlover> you compare (==0) which is a function, with the number 0
17:09:30 <fr33domlover> once again this only type checks under the constraint that (a->Bool) is a Num instance, which it isn't
17:09:55 <fr33domlover> for some reason that is checked in the 2nd case (which results with False) but not in the 1st case
17:10:46 <n0va545> hi
17:10:53 <fr33domlover> obadz, thanks. I realize that, just wanted some community feedback in case I'm doing bad practice there
17:10:59 <RGamma> fr33domlover: Yes, my question is what "some reason" is
17:11:44 <fr33domlover> RGamma, maybe laziness in the type checker? :P
17:11:49 <fr33domlover> i dunno, sorry
17:12:17 <RGamma> fr33domlover: Probably something implementation-dependenant or something fundamental?
17:12:25 <RGamma> dependant*
17:12:35 <geekosaur> I suspect the inferred type of 0 is the confusion here?
17:12:49 <leftylink> hi I just wanted to say I came across lenses in the past day or so and they are pretty cool. that they can just compose like that
17:12:54 <leftylink> that's all I got
17:12:57 <geekosaur> numeric literals get fromInteger wrapped aroudn them implicitly, so they can become ay type that has a nUm instance
17:13:03 <RGamma> geekosaur: The beta-reduction influencing the type-inference is
17:13:22 <fr33domlover> RGamma, either way the results don't contadict: in one case it makes assumptions, in the other it checks them to discover they don't hold
17:13:28 <geekosaur> so a literal 0 can be a function if a function instance of Num is inerred
17:13:30 <fr33domlover> so the difference is technical
17:13:39 <geekosaur> *inferred
17:15:25 <RGamma> So, the type-checker doesn't look "far enough"?
17:15:34 <RGamma> (in the first case)
17:16:12 <fr33domlover> You can't define new instances for (->) without GHC extensions iirc so in the 2nd case it allows itself to assume (a->Bool) isn't a Num, but generally when building haskell code it looks at your code and tries to find instances
17:16:33 <fr33domlover> if it fails, /then/ it concludes a->Bool isn't a Num and type checking fails
17:17:06 <fr33domlover> In the case of GHCi's :t perhaps the difference is just implementation detail?
17:17:27 <RGamma> Might be. I haven't tried any other implementation
17:17:36 <geekosaur> oh, I see I didn't get the right question, sigh
17:17:36 <RGamma> Anyway, thanks for your input
17:17:45 <RGamma> geekosaur: ?
17:17:46 * geekosaur is thinking somehow monomorphism restriction
17:17:58 <lethjakman-l> So...stack has ghc 7.10.2 installed, but when I run stack ghci it uses 7.8.4
17:18:05 <lethjakman-l> Does anyone know where that config setting is?
17:18:08 <geekosaur> so the first one is allowed to be polymorphic but the second tries to fix a type
17:18:18 <RGamma> geekosaur: This is on 7.8.4 (Ubuntu build)
17:19:10 <geekosaur> (the fact that the second one cites the internal-to-ghci binding of `it` makes me think it's applying monomorphism to that)
17:20:32 <RGamma> geekosaur: That's supposed to be turned off since 7.8.1
17:21:57 <RGamma> lethjakman-l: That seems like a question to #stack?
17:22:26 <RGamma> Or #haskell-stack or whatever it is called
17:23:10 <Axman6> lethjakman-l: are you inside a stack project? by default it will use whatever version the resolver set in ~/.stack/config.yaml uses
17:23:44 <geekosaur> some cases yes, some no. It depends on whether `it` is considered a let-binding (despite the fact that the syntax uses "let", normal assignment in ghci is not a let-binding).
17:24:14 <geekosaur> see the MonoLocalBinds extension which will be turned on in some cases and is independent of (No)MonomorphismRestriction
17:25:09 <lethjakman-l> Axman6: I'm not in a project
17:25:11 <geekosaur> sometimes this kind of interaction gets screwy :/
17:25:16 <lethjakman-l> I'm just experimenting with ghci. 
17:25:23 <lethjakman-l> Oh, I didn't realize that was a channel
17:25:34 <Axman6> lethjakman-l: then you need to set your resolver to at least LTS-3 in the global config
17:26:00 <lethjakman-l> Axman6: What is that resolver?
17:26:09 <Axman6> what do you mean?
17:26:23 <geekosaur> (tbh I am a little surprised that a `:t` binds `it` at all...)
17:26:38 <lethjakman-l> How do I know what version of haskell that will set me to?
17:26:49 <Axman6> you check stackage.org
17:26:57 <Axman6> and then you go and read all the stack documentation =)
17:27:09 <Axman6> (which is on haskellstack.org IIRC)
17:27:17 <RGamma> geekosaur, fr33domlover: Either way, I learned to watch out for something new, thanks :)
17:28:10 <lethjakman-l> Ohhh, long term support. 
17:28:50 <lethjakman-l> Well that makes sense now
17:28:53 <lethjakman-l> Thank you!
17:31:55 <julianleviston> Where would one report that this page is down ? https://www.haskell.org/news
17:32:24 <RGamma> geekosaur, fr33domlover: (yet it would've been surprising if you pointed me to some paper to how beta-reduction could "falsify" type-inference)
17:33:11 <RGamma> julianleviston: Right here I imagine, that seems really severe
17:33:41 <geekosaur> there are cases where beta reduction can cause ghc to infer something different, I think, although those are often considered to be bugs. (there are some corner cases where ghc "shortcuts" will cause it and are just accepted because the price of fixing it is too high, though)
17:33:45 <julianleviston> Well the main page is fine, so I dunno if I’d use the word severe, but it’s not ideal
17:34:01 <geekosaur> julianleviston, #haskell-infrastructure\
17:34:14 <x_pilot> anyone have experience with GPipe or lambdacube?
17:34:40 <RGamma> geekosaur: Any concrete links to GHC bugs (out of interest)?
17:34:49 <geekosaur> not off the top of my head
17:34:59 <julianleviston> geekosaur: thanks.
17:40:17 <geekosaur> btw if I recall correctly one case where beta reduction can lead ghc to an incorrect result is that if you use something like Text.Printf then beta reduction and/or eta expansion can cause ghc to try to compare arities as a shortcut and get it wrong because printf's arity isn't fixed. that shouldn;t be what's happening here though?
17:40:47 <geekosaur> (omsthing like tat; actual ghc devs probably got a headache from that butchered description >.> )
17:41:37 <geekosaur> and that's a case tat is accepted because it makes the common cases much faster and things like printf are considered somewhat evil anyway
17:42:13 <geekosaur> (clever, but evil)
17:46:45 <monochrom> oh, talking about down, is lpaste.net good again?
17:47:19 <monochrom> ah, it is
17:52:07 <RGamma> geekosaur: Yeah, implementation details of GHC elude me, this is just some undergraduate speaking...
17:53:59 <geekosaur> anyway you could try that test on ghc 8.1 rc1 and see if it still fails, and if so report a bug
17:55:04 <geekosaur> hvr packages ghc for ubuntu including the release candidate, https://launchpad.net/~hvr/+archive/ubuntu/ghc/
17:56:47 <Lokathor> http://pastebin.com/SprkWueS in this (largeish) function, i get the error message that cc, defined on line 21, isn't in scope at line 52
17:56:57 <Lokathor> (sorry it's not lpaste but that seems to be down at the moment)
17:57:15 <Lokathor> OH
17:57:23 <Lokathor> because it is a where clause
17:58:41 <monochrom> it is why I support tibbe's style guide, even though I disagree with "data should be strict by default".
17:59:11 <geekosaur> (irc: good for rubber-duck debugging)
17:59:16 <monochrom> it has the benefit of causing you to indent the where-block to the left of the do-block. not to the right, not even same level.
17:59:20 <Lokathor> really, NONE of that arrangement is how i want it to look long term :P
17:59:55 <monochrom> because it is also what the compiler sees.
18:00:53 <Lokathor> "where" is 2 space offside? i'll give this a try
18:01:35 <monochrom> it is quite unfortunate that the layout rules have a notwithstanding clause that allows the where-block to be to the right of the do-block and the compiler will sort it out for you.
18:02:25 <monochrom> but yeah, if you have do-block at +4 and where-block at only +2, it reflects the true hierarchy.
18:05:09 <Lokathor> monochrom, http://pastebin.com/Ux6kbWJc is how i rearranged it for now
18:05:17 <Lokathor> seems to be what you're suggesting
18:09:49 * hackagebot cryptol 2.3.0 - Cryptol: The Language of Cryptography  https://hackage.haskell.org/package/cryptol-2.3.0 (AdamFoltzer)
18:11:18 <Lokathor> I was getting some odd ConnectionClosed errors the other day, despite my use of the try blocks
18:11:24 <Lokathor> but none today
18:12:31 <EvanR> connection closed... might be related to SIGPIPE when trying to write to a socket after it was closed
18:12:43 <EvanR> signals being distinct from exceptions
18:13:33 <Lokathor> yeah i imagine that the write thread could still have a pending write when the read thread sees the connection close and returns, causing the library to close the websocket
18:13:52 <Lokathor> then when it becomes active, it's trying to write the pending message to a closed websocket
18:27:12 <julianleviston> What’s in Prelude seems so randomly selected
18:28:34 <zoku> can I apply a function to the first element of a tuple?
18:28:38 <zoku> without completely unpacking it?
18:28:51 <EvanR> the whole standard libs organization is kind of arbitrary
18:28:59 <zoku> i want to return the whole tuple with a function applied only to the first element
18:29:31 <EvanR> > fmap (+1) (1, 2)
18:29:32 <lambdabot>  (1,3)
18:31:20 <Lokathor> zoku, apToFirst f (a,b) = (f a,b)
18:31:24 <Lokathor> that's about the best you can get
18:31:42 <Lokathor> plus or minus a better name for it :P
18:31:44 <EvanR> you could make a newtype for pairs which operates on the opposite site
18:31:54 <EvanR> not that much better though
18:31:54 <zoku> hehe
18:32:36 <julianleviston> zoku: define “without unpacking it” lol!
18:32:45 <Lokathor> EvanR, you mean an (a,a) pair with a Functor instance? And then the fmap would affect one side but not the other?
18:32:48 <Lokathor> how scandalous
18:32:48 <julianleviston> zoku: applying something within something else implies “unpacking"
18:32:49 <EvanR> no
18:33:00 <zoku> haha yea, i know it has to be done in some way
18:33:03 <EvanR> just take the other copmonent
18:33:06 <zoku> just the way i found is not very compact
18:33:06 <zoku> randLetter seed = (toLetter randVal, newSeed) where (randVal, newSeed) = rand seed
18:33:06 <EvanR> anyway
18:33:12 <julianleviston> zoku: then what do you mean? :)
18:33:18 <zoku> that seems kinda verbose
18:33:20 <julianleviston> zoku: ah
18:33:37 <EvanR> @djinn (a -> b) -> (a,c) -> (b,c)
18:33:38 <lambdabot> f a (b, c) = (a b, c)
18:33:49 <Lokathor> zoku, i recently wrote an article that perhaps you'd like to glance at https://lokathor.gitbooks.io/haskell-stuff/content/state.html
18:33:58 <Lokathor> all about state and using RNGs in haskell
18:34:03 <EvanR> @pl \f a (b,c) -> (a b, c)
18:34:03 <lambdabot> const ((`ap` snd) . (. fst) . ((,) .))
18:34:07 <EvanR> ^
18:34:20 <zoku> ah, thanks Lokathor 
18:34:31 <zoku> this is part of a "challenge
18:34:31 <zoku> "
18:34:40 <Lokathor> ohhh?
18:34:56 <EvanR> actually unpacking and repacking for RNGs and manual state threading kind of makes it easier sometimes
18:35:05 <EvanR> but you can also use monads
18:35:32 <Lokathor> i find it simpler to use replicateM 10 than to unpack/repack 10 times
18:35:39 <zoku> yea this is the "monad challenge"
18:35:44 <EvanR> yes
18:35:47 <zoku> I suspect they're hoping to show how this is much easier with monads
18:35:57 <Lokathor> zoku, i'm not familiar with that challenge
18:36:41 <zoku> http://mightybyte.github.io/monad-challenges/
18:36:45 <`Guest00000> what is current state of writing for android in haskell?
18:36:59 <EvanR> but when you want low level control over what happens to the RNG state, or to the world state in a game
18:37:48 <Lokathor> EvanR, isn't falling back to direct use of get/put the same?
18:37:58 <EvanR> no
18:38:14 <exio4> EvanR: which kind of stuff would you need to "work directly" that way?
18:38:26 <exio4> EvanR: if you really, -really- need to do so, you can just use state
18:38:28 <EvanR> when the functions return a tuple ;)
18:38:44 <exio4> you can lift those to State easily
18:38:53 <Lokathor> you mean some sort of... s -> (a,s) funciton?
18:38:56 <Lokathor> hmm >_>
18:39:01 <EvanR> yes if youre whole program in set up to use monads and transformers
18:39:05 <`Guest00000> i also want to be cross-platform and use same code for compiling to android and to desktop (windows)
18:39:34 <EvanR> and you have the layers set up for convenient access to the state
18:39:37 <Lokathor> `Guest00000, sounds like perhaps some sort of OGL program might be the only way to go for you
18:40:05 <exio4> @type state
18:40:06 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
18:40:36 <EvanR> but if its a simple situation it might be easier and less code to just do (x, w') =
18:40:45 <Lokathor> runOneTurn :: PlayerInput -> GameWorldState -> (PlayerView,GameWorldState)
18:40:45 <EvanR> and then decide whether to use w or w'
18:41:03 <EvanR> its more of a functional style
18:41:14 <exio4> if you are doing ir more than once, then I'd go with flip execStateT w $ do .... or so
18:41:47 <`Guest00000> Lokathor: OGL = OpenGL?
18:41:58 <EvanR> yeah i just get annoyed with the expansion of code, support, and thinking that comes with transformers
18:42:14 <`Guest00000> what if i try to use C backend? maybe, if it works, it will allow me to use sdl and compile somehow using NDK
18:42:21 <julianleviston> This page says there’s a function called applyM which seems to just be (=<<)… except it’s not in the source, or in prelude if I ask for its type in GHCi… https://www.haskell.org/onlinereport/prelude-index.html
18:42:32 <Lokathor> `Guest00000, yes. most android apps that also build for windows have to use opengl or sdl or something like that, as far as I know. I don't know about haskell on android specifically
18:42:47 <julianleviston> What is applyM?
18:44:22 <`Guest00000> can i generally use the C backend?
18:44:50 <EvanR> haskell's FFI works
18:45:00 <geekosaur> `Guest00000, no, if you try it should tell you that it does nothing and will be removed in a later version
18:45:03 <test> Hello, sorry, I have a question. What Haskell web framework do you recommend?
18:45:06 <EvanR> you can call C code, have C callback to haskell, or call haskell from C
18:45:47 <EvanR> im not sure how much work has been put into wrapping the android API via C
18:46:09 <julianleviston> Guest91043: it depends on how much experience the person asking has...
18:46:14 <EvanR> there is however java-bridge, but not sure how nice that would been to use for that
18:46:20 <monochrom> geekosaur: does that happen to every version by induction? :)
18:46:40 <geekosaur> the C backend was horrid, required an even more horrid perl script (called the Evil Mangler) to postprocess the C compiler's output, and was generally a nightmare. ghc these days uses a native code generator backend or LLVM
18:46:53 <julianleviston> Guest91043: … and also, it depends what kind of web application they’re trying to build, and what its requirements are.
18:47:24 <julianleviston> Guest91043: snap or servant are overkill if all you want to do is respond to two requests, for example.
18:47:26 <geekosaur> there's still a "C backend" in there, but it's only useful for the initial port to a new platform: it generates highly portable but dog-slow code 
18:47:44 <julianleviston> Guest91043: (two URLs)
18:47:52 <`Guest00000> well.
18:47:54 <julianleviston> Guest91043: so, an you give some more context?
18:48:16 <`Guest00000> too bad i can't have everything and now
18:48:23 <`Guest00000> (yet)
18:48:34 <Axman6> julianleviston: that sounds like the perfect situation to use servant :\
18:48:51 <julianleviston> Axman6: it does, if you know servant.
18:48:56 <julianleviston> Axman6: but he clearly doesn't.
18:49:02 <Axman6> this is true =)
18:49:04 <Guest91043> julianleviston: I'm a Haskell beginner, but for web services I have experience in PHP and NodeJS
18:49:13 <Axman6> oh dear :(
18:49:14 <julianleviston> Guest91043: ok, I thought so.
18:49:24 <julianleviston> Guest91043: Scotty is what I’d recommend then
18:49:24 <EvanR> forget everything you ever knew
18:49:31 <monochrom> you need more experience in Haskell instead
18:49:38 <Axman6> yeah scotty is probably the easiest starting place
18:49:41 <julianleviston> yes.
18:49:49 <julianleviston> you can get by in Scotty without much Haskell
18:50:00 <Axman6> but you need to know more than basic haskell to use any web framework
18:50:07 <monochrom> for the purpose of "build a web app but has to use Haskell", Haskell experience is the hard part. web experience is the easy part.
18:50:17 <julianleviston> Guest91043: you should defnitely heed the warnings of people here though. This is NOT programming that you’re used to.
18:50:27 <monochrom> web concepts take half a day to pick up. Haskell concepts take weeks.
18:50:47 <Guest91043> julianleviston: Well I know the basics and concepts of Haskell, the only bad part is just remembering the syntax. I definitely know web concepts, I've been doing that stuff for a bit now.
18:51:31 <Axman6> have you used monad and understood transformers?
18:51:40 <Axman6> uh, used and understood monad*
18:51:44 <julianleviston> Guest91043: ok cool… so you understand that Haskell doesn’t have the same concept of requencing instructions unless you’re in IO then...
18:51:49 * Axman6 didn't go back far enough with his edit >_<
18:51:52 <julianleviston> Guest91043: (to put it simply)
18:52:17 <Guest91043> Axman6: I've been screwing around with monads for the past few weeks, although I definitely wouldn't say that I know them.
18:52:57 <`Guest00000> so
18:52:58 <julianleviston> Guest91043: but you know that in Haskell you define terms and relate them, you don’t generally sequence instructions, unless you’re talking about composing actions together?
18:53:17 <`Guest00000> LLVM (in one sense) is an intermediate representation?
18:53:28 <Axman6> that's exactly what it is
18:53:29 <monochrom> yes I think so
18:53:34 <Axman6> well, the LLVM IR is anyway
18:53:42 <Guest91043> julianleviston: Yes, and I understand that Monads typically have so-called unsafe code that also happens to be more procedural-like
18:53:58 <julianleviston> Guest91043: it’s not unsafe.
18:54:03 <Axman6> Guest91043: that is untrue for all monads except IO ;)
18:54:37 <monochrom> IO is safe. for example getLine and putStrLn are saf.e
18:54:38 <Guest91043> Axman6> Hm.
18:54:38 <julianleviston> Guest91043: you use pure haskell expressions and functions to construct monadic actions that are later executed.
18:55:00 <Guest91043> julianleviston: Yes, I understand that.
18:55:11 <Axman6> (and IO is only unsafe when interpreted)
18:55:23 <EvanR> julianleviston: i beg to differ, what do you think `sequence` does ;)
18:55:31 <Guest91043> Axman6: Oh that's interesting
18:55:39 <julianleviston> EvanR: here we go.
18:55:43 <EvanR> jk
18:55:53 <julianleviston> EvanR: what does sequence do? :)
18:56:00 <EvanR> sequences instructions ""
18:56:08 <monochrom> it builds a bigger action
18:56:13 <Axman6> t (m a) -> m (t a)
18:56:14 <orion> Is the data-default package the de-facto way of providing default values for types?
18:56:19 <julianleviston> EvanR: how is that not exactly what I just said? :)
18:56:41 <Axman6> orion: yes, de facto would be the correct way to caracterise it
18:56:51 <julianleviston> Guest91043: as long as you understand that and some Haskell syntax, you should be able to tackle Scotty reasonably easily.
18:57:08 <EvanR> julianleviston: i guess i only read the first half
18:57:16 <julianleviston> EvanR:  ah ok.
18:57:32 <julianleviston> EvanR: Maybe I only just read the first half, too.
18:57:39 <Guest91043> julianleviston: Great, sounds good. How does Scotty handle routing? (just curious since NodeJS and PHP both handled routing very differently in general)
18:57:41 <julianleviston> EvanR: you *did* wink, after all. :)
18:57:54 <julianleviston> Guest91043: https://github.com/scotty-web/scotty/wiki
18:58:00 <julianleviston> Guest91043: that explains it all better than I could.
18:58:12 <Guest91043> Thanks
18:58:38 <julianleviston> Guest91043: this is pretty telling: https://github.com/scotty-web/scotty-starter/blob/master/Controllers/Home.hs
18:59:15 <EvanR> man the routing DSLs, the killer apps, im thinking it wouldnt really be that hard to just do a case on decomposed request URL.. though i guess CGI people tried that and had had it
18:59:24 <Guest91043> julianleviston: That is pretty simplistic
18:59:43 <julianleviston> Guest91043: like I said, it depends on what you need to do with it as well.
19:00:14 <EvanR> its not like people writing web apps will be spared from writing actual code pretty soon after you open the request handler
19:00:33 <Guest91043> julianleviston: Mhm. I was thinking of building a data-base heavy website that requires some analytics (which was why I thought I'd utilize Haskell)
19:00:46 <julianleviston> Guest91043: I don’t know what that means, sorry.
19:01:02 <julianleviston> Guest91043: if you need advanced routing, then you probably need one of the heavier lifters, like servant.
19:02:30 <julianleviston> Guest91043: snap is good for building interlocking modular architectures… servant is good for constructing things around routes primarily, and yesod is good if you want typesafe URLs and a bunch of well thought-through defaults, assuming they’re the ones you’d choose.
19:03:02 <Guest91043> julianleviston: Ah, that helps quite a bit. Thanks a ton, you've been extremely helpful.
19:03:15 <julianleviston> Guest91043: it’s very exciting! :)
19:03:19 <Axman6> Guest91043: there's several good libraries for interracting with Postgres (I haven't decided which one I like best yet, they're all lacking something I've needed sadly)
19:03:34 <EvanR> postgres-simple
19:03:47 <julianleviston> Axman6: which one have you used? I use Groundhog, but it’s so much overkill for most applications I’d say.
19:03:59 <Axman6> doesn't handle big datatypes well, we have some types with 60+ fields
19:04:11 <Axman6> haven't even heard of groundhog
19:04:23 <EvanR> 60-field records?
19:04:27 <EvanR> gross
19:04:34 <julianleviston> Axman6: https://hackage.haskell.org/package/groundhog
19:05:02 <julianleviston> there’s a tute on fpcomplete: https://www.schoolofhaskell.com/user/lykahb/groundhog
19:05:05 <Axman6> I've used persistant, postgre-simple, esqueleto and I played with opaleye but couldn't understand it. Arrow syntax is weird
19:05:24 <julianleviston> Axman6:  its types can be a little confusing at first.
19:05:39 <Axman6> julianleviston: hmmm, very interesting, i'll have to check it out
19:06:06 <julianleviston> Axman6:  took me ages to work out how to do what I’d consider simple things: get a piece of data out by primary key...
19:06:32 <Axman6> one of out apps currently uses persistant because it worked well for defining the huge datatypes without needing to write lots of boilerplate every time we wanted to do a SELECT
19:08:09 <EvanR> Axman6: postgres-simple couldnt do that?
19:08:39 <Axman6> not as far as I recall
19:08:50 <Axman6> it doesn't even provide a mapping between rows and datatypes does it?
19:09:29 <Axman6> hmm, maybe ToRow
19:09:57 <Axman6> avoiding writing SQL is one of the benefits of using persistent though
19:10:28 <EvanR> well there should be a typeclass for converting results to real types
19:10:52 <EvanR> though i can see that definition getting annoying for large records
19:11:48 <Axman6> should be mostly mechanical, but without TH very booring to write =)
19:14:51 * hackagebot http2 1.4.4 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.4.4 (KazuYamamoto)
19:21:17 <b1nery> Had a problem with Data.ConfigFile - was calling ‘get “App” “apiKey”’ and it was failing with an error “get (App/apikey)” where it was *forcing* the key to lowercase. The case in the cfg file itself matched the parameter I supplied, so appears correct. This is more than a bit confusing; the documentation says “option names are not” case sensitive. But this does not really describe the actual behaviour.
19:22:44 <b1nery> So is this a WAD ’feature’, a documentation failure or a bug with the implementation? I can’t see why the lib itself would mangle the supplied parameter when it already matched the data (and the intent).
19:24:52 * hackagebot ghc-imported-from 0.2.1.0 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.2.1.0 (CarloHamalainen)
19:27:22 <Lokathor> if i want to sequence Either based actions within IO, and to a "main" thing in the case of Right, and a cleanup thing in the case of Left, but the cleanup isn't the same from Left to Left, i'm kinda screwed in terms of not being able to really make it a normal ExcepT, aren't i?
19:28:47 <EvanR> it could be Left TypeSayingWhichCleanuptoDo
19:29:17 <EvanR> which would have to be lifted from things that dont know how to do that
19:30:16 <EvanR> or put finalizers at each sequence point and rethrow
19:30:24 <Lokathor> hmmmm
19:31:29 <Lokathor> well it's intermixing the e types, is i guess my problem
19:31:56 <Lokathor> i'm using an (Either WS.ConnectionException Text) and at one point also using an (Either Text ClientInfo)
19:32:03 <Lokathor> guess no sane way to really smush them
19:32:19 <EvanR> so settle on one type and lift each one injectively into the wrapper e
19:32:47 <EvanR> would be the most generic
19:32:48 <Lokathor> "lift each one injectively" ?
19:33:18 <EvanR> data ErrorWrapper = ErrorText Text | ClientInfoError ClientInfo
19:33:34 <EvanR> then Either Foo ErrorWrapper
19:34:06 <EvanR> but for your real case you might need need it to be so flexible
19:35:15 <EvanR> if you need to do specific cleanup at speicfic points, put those in the local catch, then rethrow a generic error like Left () to quit
19:35:53 <Lokathor> hmm
19:38:15 <Lokathor> http://lpaste.net/150286 right now it's this ugly thing
19:38:26 <Lokathor> which is just begging for some ReaderT cleanup and such
19:39:25 <EvanR> transformer hell :(
19:39:51 <Lokathor> yeah
19:39:59 <Lokathor> more like a weekend project than a hectic evening thing
19:41:31 <EvanR> maybe theres a one-monad-to-rule-them-all which you just use without thinking and it magically has all these features already
19:41:47 <EvanR> RWST IO + exceptions
19:41:51 <EvanR> T
19:42:21 <Cale> Lokathor: I wouldn't be too too unhappy with the case expressions there... if that's what you're referring to.
19:42:57 <Lokathor> bitemyapp's book says to avoid RWS as I recall :P
19:43:26 <EvanR> RWST IO + exceptions T can really be replaced with ReaderT IO
19:43:48 <Cale> Does RWS even solve this problem?
19:44:15 <crossroads1112> Hello all
19:44:16 <MarcelineVQ> Lokathor: I doubt it would specifically advise against something as a whole
19:44:23 <Cale> (I don't believe that it helps)
19:44:52 <MarcelineVQ> Lokathor: I read what you said wrong so nvm :>
19:44:53 <Cale> But you *could* for instance, construct an IO exception type, and throw/catch exceptions
19:45:06 <Cale> Might be a little nicer if the way you're handling them is all very uniform...
19:47:01 <Cale> I see at least two occurrences of  case err of WS.ParseException str -> ...; _ -> return ()  which look like they could be unified.
19:47:08 <Cale> (just by defining a function)
19:47:40 <Lokathor> well there's to basic errors to deal with. A connection error, and an authentication error
19:48:09 <Lokathor> the "text" error should probably be an enum type, for simplicity
19:49:04 <Cale> oh, and then you have this stateTVar that you're manipulating...
19:49:24 <Cale> You may prefer to make a record of methods for manipulating it, and pass that instead
19:50:20 <Cale> (that abstracts away from the fact that you're using a TVar while handling these operations like adding and removing users)
19:50:57 <Lokathor> well the stateTVar is the (Map RoomName RoomUsers) reprisenting all the rooms
19:51:05 <Cale> and then if you want to log changes to the state later, that becomes easier :)
19:51:33 <Cale> (because all the code which updates the TVar you create near the top level of your program is in one place)
19:51:53 <Cale> Does that make sense? I could be a little more explicit about what I mean there
19:56:10 <Lokathor> hmm
19:56:29 <Lokathor> sorry, distracted becaue the other guy is also asking for adjustments as i chat here
19:57:14 <exio4> Lokathor: what are you trying to solve? 
19:57:33 <exio4> Lokathor: I barely checked this, but it looks like some function like .. catch .. would do the trick? 
19:58:23 <Lokathor> exio4, well i need to merge two different exception types so that the Either e can be consistent as I go
19:59:08 <Lokathor> Cale, i'm not clear on what you mean by a record of functions that updates the TVar, i'm not clear on how that would make things simpler
20:03:31 <Cale> Lokathor: I mean, something like  data StateOps = SO { addUser :: Room -> Name -> IO (), removeUser :: Room -> Name -> IO (), currentState :: IO (Map ...) }
20:04:00 <Cale> (you can probably come up with a better set of operations given what you end up doing with the state TVar throughout your code)
20:04:38 <Lokathor> ah, well i sorta have that
20:04:46 <Lokathor> you can see the complete module, https://github.com/Strifepad/strifeserver/blob/master/src/Strife/WebSockets.hs
20:13:17 <exio4> Lokathor: I meant something like catch' :: ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a
20:14:22 <Lokathor> that looks like it lets you easily convert e into e'
20:17:56 <Lokathor> that's not quite what i want, i think
20:18:15 <lpsmith> Axman6:  you can write a FromField parser that would turn each row into a hashmap or the like,  keyed on column name
20:18:54 <lpsmith> Of course, you'd also need to decode each value into a uniform type,  so perhaps a discriminated union.
20:19:14 <EvanR> doesnt sound very type safe
20:19:23 <lpsmith> no, unfortunately not
20:19:52 <lpsmith> but... it's rather cumbersome to be type safe with records that wide.
20:20:19 <lpsmith> Anyway, the hashmap approach is what I use in one case where I'm dealing with records with ~40 fields.
20:20:34 <EvanR> TH / something like type providers which produce the record types from schema online
20:21:04 <EvanR> read the schema at compile time
20:21:23 <EvanR> that still only gets you so far, since you probably dont literally want to use SQL types
20:22:10 <lpsmith> yeah, that's one approach, that has it's own tradeoffs.  Might not be a bad way to go for my 40-some column table.
20:22:59 <lpsmith> (The schema is all but dictated by third-party standards... in practice we only care about a dozen fields or so, but we still deal with all of them so we can say we are standards-compliant.)
20:25:19 <Cale> Lokathor: Right, you have the pure operations which act on the TVar -- whether it's actually worth abstracting over the IO for interacting with the TVar is another question.
20:26:35 <Lokathor> at the momemt it looks like the map of room name to room will need to be mutable, and each room will need a list of who's in the room along with the room's state
20:27:26 <Lokathor> the room's state will change a whole lot, usually write only. it only needs to be read from when a new user goes to join and needs to get the full current room state
20:29:01 <Cale> Lokathor: Whenever I'm passing around a bare IORef or TVar or something like that, I always ask myself if I'd rather have a record of operations around it -- even if it's just "read" and "write" -- sometimes that will turn out to be useful later for purposes of logging or recording changes, or changing the mechanism of storing the state.
20:31:26 <Lokathor> yeah, that does sound handy
20:34:02 <Lokathor> http://lpaste.net/150288
20:34:31 <Lokathor> i think those might end up being my data types
20:34:55 <Lokathor> and then i can have a record of operations that work on ServerState and such be passed around
20:35:36 <Axman6> lpsmith, EvanR you're basically homingin on the solution offered by persistent btw :P
20:39:26 <zd234> is there a way to get cabal to just download the source of a package without installing it?
20:39:34 <zd234> I just want to download the tgz / hs files so I can grep through them
20:39:39 <Lokathor> uhm, "fetch" ?
20:39:51 <Lokathor> "cabal help" should list all the options
20:40:22 <zd234> nice, I was looking at cabal install --help, not cabal --help
20:43:51 <lambdafan> any yesod people here? I followed the quickstart instructions only to find that devel.hs no longer gets included with yesod-bin
20:44:08 <lambdafan> has something changed?
20:44:27 <Axman6> I think #yesod is probably a better place to ask (though my experience is it's usually very quiet)
20:45:33 <lambdafan> no worries
20:45:40 <lambdafan> I think I may have figured it out
20:45:50 <lambdafan> I think I just need a newer version of yesod-bin
20:46:19 <gfixler> is there any way to get the path of an imported module?
20:46:56 <gfixler> :path Data.Set, e.g.
20:47:05 <gfixler> and have it spit out the file path
20:47:10 <Axman6> gfixler: path or the package it comes from? I usually just google "haskell <package name>" =)
20:47:25 <gfixler> Axman6: path
20:47:25 <Lokathor> think they mean the file on disk
20:47:30 <gfixler> yep
20:47:35 <Axman6> the file path seems kind of not like something you should need
20:47:40 <gfixler> I've been thinking how odd it is that so much information isn't available to me
20:47:54 <Axman6> since it will usually be a compiled object (with the source sitting around somewhere)
20:48:02 <gfixler> it would be interesting to see where it looks for things, e.g. :path with no args would kick out a list of paths
20:48:03 <Axman6> like what?
20:48:17 <gfixler> like :source foo
20:51:26 <lingxiao> hey all
20:51:32 <lingxiao> is anyone around familiar with coq?
20:51:54 <Axman6> have you tried #coq today?
20:56:43 <lingxiao> yup on there now
20:56:50 <lingxiao> jrw has responded kinda
21:08:20 <dalastboss> if a class (say monad) is defined to inherit from another (say functor) are super class functions automatically defined for it?
21:08:38 <dalastboss> eh actually that makes no sense
21:08:50 <Axman6> no, that's a constraint saying that they must be defined before you can implement the "child" class
21:09:16 <Axman6> so to be an Applicative you must first have a Functor, and to have a Monad, you must first have an Applicative
21:09:21 <dalastboss> right, that makes more sense
21:09:47 <qmm> what are some exercises that would help me to get a better grasp on fold?
21:09:49 <Axman6> so Monads are a subset of Applicatives which are a subset of Functors
21:10:01 <qmm> i don't understand what exactly foldMap does
21:10:14 <Axman6> qmm: trying to reimplement all the list functions in the prelude using foldr is a good way to do that
21:10:33 <Axman6> oh, different fold... what do yuo mean by "fold" in this case
21:10:38 <Axman6> :t foldMap
21:10:40 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
21:11:08 <Axman6> > foldMap (:[]) (Just 7)
21:11:10 <lambdabot>  [7]
21:11:24 <Axman6> > foldMap (:[]) (Right 7)
21:11:26 <lambdabot>  [7]
21:11:30 <Axman6> > foldMap (:[]) (Left 7)
21:11:31 <lambdabot>  []
21:11:32 <qmm> Axman6: foldr, foldl, etc.
21:11:42 <qmm> but i also don't understand what a foldMap does
21:11:43 <Lokathor> actually, as i recall, as long as all the instances are in the same module, can't you define monad, and then define applicative in terms of that, for example?
21:11:58 <Lokathor> pure = return, instead of the usual way around?
21:12:14 <Axman6> qmm: foldMap just lets you take all the a's in a thing that's foldable, turn them into some type which is a Monoid, and join them all together
21:12:28 <Axman6> Lokathor: I believe so
21:14:47 <Axman6> qmm: to understand foldr better, doing what I said above (implementing all prelude list functions in terms of foldr) is a great start
21:15:12 <Axman6> for example: length = foldr (\_ n -> n + 1) 0
21:15:53 <Lokathor> \_ !n i hope :P
21:16:04 <Axman6> some functions can be more efficiently written using foldl'
21:16:35 <Axman6> Lokathor: that doesn't help, (+) is already strict. foldr is just the wrong thing to use for length (and sum/product) unless you have lazy (+)
21:17:49 <Lokathor> but without !n, wouldn't it stay as n + 1 being passed to the next iteration? building up a thunk that way without evaluating that it was using (+)?
21:18:06 <Axman6> yiou can't avoid that problem with foldr anyway
21:18:06 <Lokathor> honestly i'm pretty fuzzy on a lot of how that all interacts
21:18:21 <Axman6> you can't compute any subresult here without reaching the end of the list
21:18:38 <Lokathor> true true
21:19:34 <Axman6> the top level value will be (foldr *(\_ n -> n+1) 0 (tail xs)) + 1 no matter whether you use !n or not
21:19:52 <Axman6> which is why we implement length/sum/product using foldl'
21:22:29 <qmm> thank you for the information, i'm sorry i have to run. i'm going to be reviewing and joining again with more questions
21:22:35 <qmm> maybe fun code even!
21:45:04 <neuroserpens> So... I hear there is an undo thing that shows you how to desugar haskell code... Could anyone tell me a little bit more about it and how to use it i nghci?
21:45:27 <johnw> it's only in lambdabot
21:45:50 <neuroserpens> only here then?
21:45:52 <johnw> @undo do { x <- f; return x }
21:45:52 <lambdabot> f >>= \ x -> return x
21:45:55 <johnw> only if you /query lambdabot
21:45:59 <johnw> s/only/or
21:46:11 <neuroserpens> Nice... I'll just use it here then whenever I need help
21:46:15 <johnw> you can locally install lambdabot too, if you're adventurous
21:46:32 <neuroserpens> johnw: I'll just use it here. Thanks.
21:47:20 <neuroserpens> johnw: I don't know why, but I really don't like do notation and think the desugarized code looks so beautiful...
21:49:57 <Axman6> you'll learn you're wrong in time :P
21:50:09 <ReinH> neuroserpens: if you're going to use this lambdabot for personal stuff, please use a private message
21:50:15 <neuroserpens> Axman6: If you give me a good reason why...
21:50:25 <johnw> neuroserpens: do have fun with desugarized while you like it :)
21:50:31 <neuroserpens> ReinH: Should I just /msg it?
21:50:36 <ReinH> Yep.
21:50:48 <johnw> neuroserpens: you can also do "/query lambdabot" to carry on a conversation with it
21:50:53 <Axman6> seeing "foo >>= $ \a ->" is slightly more noisy than "a <- foo"
21:50:54 <neuroserpens> ReinH: Good to know. Thanks. I prefer to do it privately.
21:51:05 <neuroserpens> Axman6: Not to me. Nope.
21:51:28 <ReinH> Well, it's objectively more noisy.
21:51:34 <Axman6> whatever floats your boat, but you won't find anyone else using that style =)
21:51:38 <neuroserpens> Axman6: and really, i'm not interested in personal opinions. i got what i wanted. thanks
21:51:47 <neuroserpens> Axman6: and I'm only using haskell for personal projects anyway
21:51:48 <Axman6> ok :\
21:51:50 <johnw> yeah, there's no reason to tell neuroserpens he shouldn't like what he likes
21:51:59 <ReinH> Axman6: Well, SPJ uses braces and semicolons
21:52:21 <Axman6> that I can understand, sort of
21:52:44 <Axman6> johnw: I never did
21:52:55 <ReinH> neuroserpens: to be fair, you literally asked him to give you his opinion
21:53:05 <Axman6> being wrong and liking it is fine :P
21:53:59 <neuroserpens> ReinH: okay bye
21:54:35 <ReinH> o/
21:59:07 <`Guest00000> @djinn a -> a
21:59:07 <lambdabot> f a = a
21:59:11 <`Guest00000> @djinn a -> b
21:59:11 <lambdabot> -- f cannot be realized.
22:00:23 <`Guest00000> @unmtl State Int Int
22:00:23 <lambdabot> Int -> (Int, Int)
22:00:29 <`Guest00000> nice
22:27:58 <Lokathor> f = unsafeCoerce  :S
22:29:58 * hackagebot binary-search 1.0 - Binary and exponential searches  https://hackage.haskell.org/package/binary-search-1.0 (TakayukiMuranushi)
22:35:52 <neuroserpens> http://pastebin.com/XLQM8Ff8
22:36:16 <Lokathor> http://www.seas.upenn.edu/~cis194/spring13/lectures.html you may care for this
22:36:21 <neuroserpens> Really, more lines are the noise to me
22:37:19 <Lokathor> neuroserpens, you're strange
22:37:30 <neuroserpens> Lokathor: So I've been told
22:39:04 <kadoban> neuroserpens: I'm okay with your 'process', though I prefer the one above. You left out some functionality of the original for 'main', so it's not a fair comparison … and I already prefer the one above.
22:39:46 <neuroserpens> kadoban: what functionality? it's just using id... I could just create another function up there and call it instead.
22:40:29 <kadoban> neuroserpens: Well I mean you seemingly meant it to be a comparison of 'do' vs. desugared, but … it's not a good comparison because you changed how it's implemented.
22:40:38 <neuroserpens> kadoban: ok wait
22:42:08 <neuroserpens> kadoban: http://pastebin.com/2azrSJtJ
22:42:10 <neuroserpens> there
22:42:12 <neuroserpens> rofl
22:42:46 <kadoban> That appears to be the same thing?
22:43:05 <neuroserpens> kadoban: it's the only "functionality" I left out. Being able to just replace a "function"
22:43:37 <`Guest00000> process iFile oFile = readFile iFile >>= writeFile oFile . whateverfunc
22:43:48 <`Guest00000> also, LambdaCase
22:43:57 <neuroserpens> `Guest00000: Great suggestion
22:44:10 <neuroserpens> `Guest00000: thats cool
22:44:28 <nineonine> hi all
22:44:36 <nineonine> im having issues running compiled program
22:44:47 <joash> do notation and desugared have different strengths and weaknesses.
22:44:57 <nineonine> it says that  No such file or directory
22:44:58 <neuroserpens> joash: please elaborate
22:45:19 <neuroserpens> joash: I'd like to learn more if you have any cool insights
22:45:19 <kadoban> neuroserpens: Yes, but … what's the point of comparing two styles if you aren't implementing the same thing in both styles? It's like you purposely made the one you don't like worse than it had to be, or cleaned it up specially for the one you like …
22:45:38 <ReinH> neuroserpens: if you like >>= \foo -> case foo of, you'll love LambdaCase
22:45:40 <neuroserpens> kadoban: What? How is it not the same thing?
22:45:48 <nineonine> i guess it is something with linking
22:45:55 <nineonine> i already had this issue
22:46:03 <neuroserpens> ReinH: I'll google lambdacase
22:46:04 <nineonine> and someone told me to run some command in terminal
22:46:06 <nineonine> which helped
22:46:10 <kadoban> neuroserpens: You're trying to compare 'do' with the desugared version, correct?
22:46:12 <ReinH> If I were going to hand pick an example where I prefer (>>=) to do notation, I would have picked something like yours
22:46:18 <ReinH> So I'm not surprised that you prefer it there
22:46:28 <joash> well, if you're just threading through one argument to the next function, it can be easier to just use desugared. It's similar to writing pointfree, you don't need to name the intermediate variables
22:46:35 <ReinH> And I don't really understand why everyone's giving you a hard time for prefer it
22:46:48 <neuroserpens> ReinH: I think the main reason I like it way more is because it reduces lines and compact code gives me an eyegasm
22:47:00 <ReinH> When you start having more than one or two bound variables, do notation starts to seem more attractive
22:47:20 <neuroserpens> kadoban: Tell me how they're not the same thing.
22:47:20 <joash> but with more variables do notation makes more sense
22:47:39 <joash> luckily you can mix both syntaxes where it makes sense!
22:47:43 <ReinH> neuroserpens: LambdaCase lets you say ma >>= \case rather than ma >>= \foo -> case foo of
22:47:57 <neuroserpens> ReinH: wow. awesome
22:48:09 <Cale> neuroserpens: well, if you have enough code, do-notation is more compact
22:48:21 <ReinH> I like to use that even inside do notation for immediate case scrutinization of the bound value
22:48:22 <kadoban> neuroserpens: The one with 'do' has a useless 'myFunction' and 'id' and such that you left out. It's not a direct comparison. That's totally unnecessary for the code you have, yet you left it in to one and took it out of the other. It makes the comparison not very good.
22:48:26 <Cale> Because you'll probably be writing stuff like
22:48:31 <Cale> foo >>= \x ->
22:48:37 <Cale> bar >>= \y ->
22:48:39 <ReinH> otherwise you have to use a variable that seems completely unnecessary
22:48:43 <Cale> quux x y
22:48:45 <Cale> or whatever
22:48:58 <ReinH> Cale: yeah I sort of said that too :)
22:49:01 <neuroserpens> kadoban: That's why I made the second pastebin with whateverfunc = id and the comment
22:50:07 <kadoban> Oh, my browser didn't load the second so I was still looking at the original XD
22:50:17 <kadoban> My bad.
22:50:21 <neuroserpens> kadoban: ROFL. you suck. xD
22:50:33 <kadoban> ;)
22:52:20 <ReinH> Cale: I sometimes wonder what Haskell would look like without do notation. I think we'd see far less of the "20 line long main do block ROFL" style that I see with worrying frequency.
22:52:40 <ReinH> (Well, its unsugared replacement, at least)
22:52:46 <Cale> Only 20 lines?
22:52:49 <ReinH> Cale: ;)
22:53:11 <jle`> i think there are definitely places where do notation lets you express what you want to say nicer, and when normal functions express waht you want to say nicer
22:53:18 <jle`> it's not like do notation always gives nicer code no matter what
22:53:28 <ReinH> I'm just saying that you can make a coherent argument that do notation enables a poor style
22:53:31 <jle`> i could give contrived examples where do notation definitely does not give you nicer code
22:54:06 <jle`> there is no thing that doesn't enable poor code style :o
22:54:26 <ReinH> Consider the arguments that you would probably bring against 20 line long list comprehensions.
22:54:33 <ReinH> They apply to do notation too. Search your feelings, you know it to be true.
22:55:54 <neuroserpens> ReinH: Your ma >>= \ case thingy does not compile >:C
22:56:21 <`Guest00000> neuroserpens: did you add {-# LANGUAGE LambdaCase #-} to beginning?
22:56:25 <ReinH> neuroserpens: well, did you enable LambdaCase?
22:56:38 <neuroserpens> `Guest00000 ReinH rofl I didn't even know it existed until now
22:58:19 <ReinH> Oh. I thought you might have googled it or something.
22:59:21 <neuroserpens> ReinH: Now I did xD
22:59:59 * hackagebot stackage-types 1.2.0 - Shared data types between various Stackage packages  https://hackage.haskell.org/package/stackage-types-1.2.0 (MichaelSnoyman)
23:01:01 <neuroserpens> Good stuff
23:04:59 * hackagebot binary-search 1.0.0.1 - Binary and exponential searches  https://hackage.haskell.org/package/binary-search-1.0.0.1 (TakayukiMuranushi)
23:08:46 <dfeuer> SPACE TOURIST.
23:10:47 <zd234> with cabal
23:11:04 <zd234> with cabal, is there a way to specify a directory different from ~/.cabal ?
23:20:41 <chunts> any sr devs/managers here?
23:35:00 * hackagebot file-embed 0.0.9.1 - Use Template Haskell to embed file contents directly.  https://hackage.haskell.org/package/file-embed-0.0.9.1 (MichaelSnoyman)
23:41:42 <johnw> chunts: asking it as a Haskell question will likely get a better answer
23:42:02 <chunts> johnw: i would like to work as a developer, but i lack the knowledge
23:42:18 <johnw> read, write, ask, repeat
23:42:32 <johnw> that's how all of us started, unless you have higher education available
23:42:33 <chunts> would it be possible to work for a company for a low salary while they train me and get me up to speed?
23:42:44 <chunts> i have a ged
23:42:56 <johnw> chunts: anything is possible, but you'd have to locate such an opportunity
23:43:07 <johnw> are you wanting to work in Haskell?
23:43:15 <chunts> where should i go?
23:43:19 <johnw> I don't know
23:43:28 <chunts> well that's not good
23:43:47 <johnw> I can answer questions about the Haskell programming language; I'm not so good at job searches
23:45:03 * hackagebot cgi 3001.2.2.3 - A library for writing CGI programs  https://hackage.haskell.org/package/cgi-3001.2.2.3 (cheecheeo)
23:46:52 <ReinH> dfeuer: space tourist?
23:48:26 <dfeuer> ReinH, someone came in with a nick of Tourist.
23:48:45 <ReinH> dfeuer: I prefer to think it was a nethack reference.
23:49:10 <dfeuer> ReinH, I'm just a few years too young for nethack.
23:49:25 <jle`> i prefer rogue
23:49:49 <jle`> rogue today is still my favorite roguelike ...
23:51:40 <nineonine> anyone familiar with compiling procedures ? my compiled program does not run
23:51:50 <nineonine> when i try to compile it 
23:51:59 <nineonine> i get that
23:52:00 <nineonine> http://lpaste.net/150292
23:52:12 <nineonine> and when i try to run program
23:52:23 <nineonine> it just says No such file or directory
23:52:43 <cocreature> “Main.main not exported; not linking.”
23:52:46 <cocreature> that’s probably the problem
23:52:58 <nineonine> so what should i do ?
23:53:02 <nineonine> i have main
23:53:21 <Hijiri> what is the name of the module it's in?
23:53:22 <cocreature> the module needs to be called Main too (or have no module name)
23:53:26 <cocreature> and it needs to be exported
23:53:27 <dfeuer> I just figured out that    mapWithIndex = (runIdentity .) #. traverseWithIndex .# coerce
23:53:31 <nineonine> Day6.hs
23:53:39 <Hijiri> the module name is at the top of the file
23:53:48 <Hijiri> Where it says module ModuleName where
23:54:04 <Hijiri> if the module name is Main, it doesn't necessarily correspond with the file name
23:54:30 <nineonine> so I should rename module into Main.hs ?
23:54:34 <Hijiri> no
23:54:40 <Hijiri> you can keep the file as Day6.hs
23:54:43 <dfeuer> Sometimes you have to though, I think?
23:54:43 <nineonine> k
23:55:06 <Hijiri> nineonine: What is the line near the top of your file starting with "module" (if there is one)
23:55:09 <cocreature> nineonine: you probably have a line such as "module … where" at the top of your file
23:55:25 <nineonine> module Day6 where
23:55:34 <cocreature> change that to module Main where
23:55:34 <Hijiri> try changing that to module Main where
23:55:40 <nineonine> ok
23:56:18 <nineonine> it worked
23:56:26 <nineonine> thanks !
23:56:30 <cocreature> yw
23:56:34 <nineonine> so whats the trick here ?
23:56:45 <cocreature> the main function needs to be in a module called Main
23:56:48 <cocreature> that’s all
23:57:43 <nineonine> so Main is a mandatory program entry point with function main ? right ?
23:58:20 <jle`> nineonine: you can also just leave the `module ... where` off completely
23:58:30 <jle`> the module doesn't need to be called Main
23:58:51 <jle`> the module or text file can be named anyhting, it doesn't have to be Main.hs or called Main
23:59:01 <jle`> i usually actually have my executables not be named Main and not have any module
23:59:28 <jle`> nineonine: your file can have a lot of IO actions, but GHC will compile the IO action specifically called "main"
23:59:34 <ReinH> jle`: I'm a big fan of dungeon crawl stone soup
23:59:59 <nineonine> got it ! thanks for explanation
