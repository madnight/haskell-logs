00:00:38 <adam_> I bet its also possible to actually just take the keys that somebody types in, then check if there is nothing typed but backspace
00:00:43 <adam_> in that case do thing a
00:00:51 <adam_> otherwise treat it like a regular backspace
00:01:08 <adam_> dont ask me how
00:01:24 <puregreen> adam_: if you start doing all that, it's probably easier to just switch to haskeline
00:02:02 <adam_> http://trac.haskell.org/haskeline
00:02:08 <adam_> i stole your idea and googled it
00:02:40 <puregreen> or at least “you won't get some interesting bug that people who work with console IO a lot know about, but you don't”
00:02:54 <JamesJRH> puregreen: Why does it work without forever without that then?
00:03:11 <JamesJRH> Oh wait, it doesn't.
00:03:16 <puregreen> yeah, exactly
00:03:34 <puregreen> (I was surprised too for some reason)
00:04:08 <JamesJRH> These behave differently and I didn't notice until just now:
00:04:09 <JamesJRH> Prelude> putStrLn =<< getLine
00:04:13 <JamesJRH> $ ghc -ignore-dot-ghci -e 'putStrLn =<< getLine'
00:04:29 <JamesJRH> The latter backspace works for.
00:04:41 <JamesJRH> And ^D.
00:05:26 <puregreen> I think GHCi uses char-by-char reading mode so that stuff like Ctrl-T would work
00:05:50 <puregreen> and programs executed non-interactively use line buffering 'cause it's faster
00:06:07 <puregreen> * Tab, not Ctrl-T
00:06:12 <JamesJRH> Same for: $ ghc -ignore-dot-ghci -e 'Control.Monad.forever (putStrLn =<< getLine)'
00:06:15 <JamesJRH> <interactive>: <stdin>: hGetLine: end of file
00:09:49 <puregreen> meanwhile, repeating my question from yesterday: what's the simplest network library there is? I need just 2 things: “serve :: Port -> (Request -> Response) -> IO ()” and “send :: Address -> Request -> IO Response”, nothing else
00:10:24 <JamesJRH> “    Not in scope: ‘<<’”? Really?
00:10:38 <puregreen> JamesJRH: yep, (<<) doesn't exist
00:11:21 <puregreen> JamesJRH: you can use <* but it will still execute the 1st action before the 2nd
00:12:16 <JamesJRH> Prelude> let (<<) = flip (>>) in Control.Monad.forever (putStrLn =<< getLine) << System.IO.hSetBuffering System.IO.stdin System.IO.LineBuffering
00:12:20 <JamesJRH> *** Exception: <stdin>: hGetLine: end of file
00:12:23 <JamesJRH> \o/
00:12:29 <JamesJRH> Got it. :-)
00:13:09 <mniip> why not just use >>
00:13:14 <mniip> aaand >>=
00:13:37 <JamesJRH> That was immediately followed by a ^D to demonstrate that it works, that's the “* Exception: <stdin>: hGetLine: end of file”.
00:13:59 <JamesJRH> mniip: Because that is the opposite way round to (.).
00:14:09 <mniip> right
00:14:17 <puregreen> JamesJRH: you have to detect EOF by yourself, it's not going to stop your loop automatically
00:14:21 <JamesJRH> It seems confusing to mix the directions.
00:14:42 <mniip> while you do have a point << just seems odd to me
00:14:42 <JamesJRH> puregreen: It does, though, with the Exception.
00:15:27 <puregreen> well, it stops the whole program as opposed to just stopping the loop, but okay, you're right
00:15:29 <JamesJRH> mniip: It makes sense to me. :-)
00:15:38 <JamesJRH> puregreen: Ah, I see.
00:16:25 <puregreen> JamesJRH: http://lpaste.net/150484
00:17:13 <puregreen> hm, interesting, I didn't know that “isEOF” existed and I didn't have to use “hIsEOF”
00:18:47 <puregreen> JamesJRH: by the way, here's the simplest “cat” for you: «ghc -e 'interact id'»
00:20:24 <nyon> puregreen: This is assuming that stdout is line-buffered, right?
00:20:38 <JamesJRH> mniip: I usually don't like infix, either, but it's pretty easy for me to mentally convert it to: “flip (>>) (Control.Monad.forever (putStrLn =<< getLine)) (System.IO.hSetBuffering System.IO.stdin System.IO.LineBuffering)”
00:23:52 <puregreen> nyon: yep, but ghc -e sets line buffering
00:24:30 <puregreen> nyon: also, it doesn't matter what the stdout's mode is in this situation
00:27:42 <nyon> puregreen: Ah, nice!
00:35:43 * hackagebot adler32 0.1.0.0 - An implementation of Adler-32, supporting rolling checksum operation  https://hackage.haskell.org/package/adler32-0.1.0.0 (MariosTitas)
00:40:43 * hackagebot slug 0.1.2 - Type-safe slugs for Yesod ecosystem  https://hackage.haskell.org/package/slug-0.1.2 (mrkkrp)
00:44:32 <jle`> it's pretty awesome that pandoc is written in haskell
00:44:49 <jle`> makes life so much simpler
00:46:50 <jle`> JamesJRH: it's not obvious what (<<) would be
00:47:20 <jle`> because it is arguable that (<<) to be to (<*) what (>>) is to (*>)
00:51:05 <JamesJRH> jle`: Just ‘flip (>>)’, like ‘(=<<)’ is ‘flip (>>=)’.
00:51:55 <jle`> yeah, there are two equally valid things it could be
00:52:13 <jle`> so it's not obvious which one is the more intuitive/useful/better oen
00:54:13 <JamesJRH> jle`: Have I remembered this equivalence correctly (not counting the fmap/liftM detail)?:
00:54:17 <JamesJRH> Prelude Control.Monad> :t (=<<)
00:54:19 <JamesJRH> (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:54:22 <JamesJRH> Prelude Control.Monad> :t \a -> join . fmap a
00:54:26 <JamesJRH> \a -> join . fmap a :: (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
00:54:44 <jle`> yes, yes, (=<<) is flip (>>=)
00:54:51 <jle`> f =<< x = x >>= f
00:55:31 <JamesJRH> Then I believe that (<<) would be:
00:55:31 <JamesJRH> Prelude Control.Monad> :t flip (>>)
00:55:31 <JamesJRH> flip (>>) :: Monad m => m b -> m a -> m b
00:55:32 <JamesJRH> Prelude Control.Monad> :t \a -> join . fmap (\_ -> a)
00:55:32 <JamesJRH> \a -> join . fmap (\_ -> a) :: (Functor m, Monad m) => m a -> m a1 -> m a
00:56:20 <JamesJRH> That's roughly how I think of arrows, at least.
00:56:40 <jle`> that's one interpretation
00:56:58 <jle`> but it would also make sense as (>>) should be (*>), (<<) should be (<*)
00:57:23 <JamesJRH> I always try to think in terms of fmap, join, and return – the category theory view, because it's the only way I was able to grasp monads.
00:57:26 <jle`> >> and << make sense as the monadic counterparts to *> and <*
00:57:47 <jle`> similar to how we have return is monadic pure, liftM is monadic liftA, etc.
00:57:55 <jle`> so >> is a monadic *>, << is a monadic <*
00:58:11 <JamesJRH> I'm not familiar with (<*) and (*>) yet.
00:59:04 <JamesJRH> I'm also not familiar with pure and liftA.
00:59:20 <JamesJRH> So much to learn. :-)
00:59:25 <jle`> ah; pure is just return generalized for all Applicatives, not just Monads
00:59:35 <JamesJRH> Okay.
00:59:36 <jle`> liftA is `fmap`, but implemented in terms of Applicative methods
00:59:40 <jle`> :t pure
00:59:42 <lambdabot> Applicative f => a -> f a
00:59:46 <jle`> :t liftA
00:59:47 <lambdabot> Applicative f => (a -> b) -> f a -> f b
00:59:53 <jle`> :t (*>)
00:59:54 <lambdabot> Applicative f => f a -> f b -> f b
00:59:57 <jle`> ^ it's like (>>)
01:00:00 <jle`> :t (<*)
01:00:02 <lambdabot> Applicative f => f a -> f b -> f a
01:00:18 <jle`> (*>) sequences two actions, and the result is the result of the second
01:00:25 <jle`> (<*) sequences two actions, and the result is the result of the first
01:00:44 * hackagebot bini 0.1.5 - A collection of various methods for reading and writing bini files.  https://hackage.haskell.org/package/bini-0.1.5 (TWeise)
01:00:52 <JamesJRH> I don't like to think of it that way.
01:02:11 <JamesJRH> I think of it as a liftA followed by a… what's the Applicative version of join?
01:02:29 <jle`> there is no Applicative version of join, becuase join doesn't make sense for all Applicatives
01:02:40 <JamesJRH> Oh. :-/
01:02:44 <JamesJRH> Hmm.
01:04:12 <jle`> to me, Applicative sort of represents the notion of sequencing, so if you think of it in terms of liftA2 f x y, which sequences x and y and returns `f` applied to both results
01:04:20 <jle`> then (*>) = liftA2 (\_ y -> y)
01:04:28 <jle`> and (<*) = liftA2 (\x _ -> x)
01:04:34 <JamesJRH> jle`: So there's nothing of the form: (<*) = \a -> ???? . liftA (\_ -> a)
01:04:37 <JamesJRH> Oh.
01:05:10 <jle`> i think of liftA2 as the fundamental action of Applicative, like what join is for monads.  but that's just me :)
01:05:28 <jle`> join :: m (m a) -> m a
01:05:46 <jle`> uncurry (liftA2 (,)) :: (m a, m a) -> m (a, a)
01:05:58 <EvanR> can you implement pure with liftA2
01:06:00 <jle`> er
01:06:07 <jle`> liftA2 (,) :: m a -> m a -> m (a, a)
01:06:28 <JamesJRH> I'll have to think about this for quite a while and read about Applicatives.
01:06:47 <jle`> monad lets you "squish" towers of m (m (m ... a))), where Applicative lets you sequence/squish lists of m a's,  m a -> m a -> m a -> ...
01:07:13 <jle`> people say monad is monoidal in the 'vertical' direction, where applicative is monoidal in the 'horizontal' direction
01:07:24 <JamesJRH> Ah!
01:07:29 <JamesJRH> Yes, I've heard that.
01:07:36 <JamesJRH> I se.e
01:07:40 <JamesJRH> see.*
01:08:28 <jle`> but anyways, my point at the beginning is that people use *> and <* regularly and they're pretty common
01:08:36 <jle`> and people expect *> and >> to behave the same
01:08:45 <jle`> so it wouldn't be too big of a jump to expect <* and << to behave the same, as well
01:09:22 <JamesJRH> Right, indeed.
01:11:25 <jle`> Const is my favorite example of an Applicative that you can't make a Monad no matter how hard you try
01:15:23 <JamesJRH> Anyway, back to the thing about directions again, assuming that consistent direction is preferred (I prefer it), a reason to prefer the direction of ($), (.), (=<<), flip (>>), and (<*) over flip ($), flip (.), (>>=), (>>), and (*>) is that it is lazy in the normal left-to-right reading direction.
01:16:23 <JamesJRH> So in ‘putStrLn =<< getLine’ it can be thought of like: Okay, ‘putStrLn’, what do I need to do to do that? ‘getLine’
01:16:23 <jle`> yeah, that's one of my favorite parts about (.) and ($) over (>>>) and (&); control is driven from left to right
01:16:29 <JamesJRH> That sort of thing. :-)
01:16:39 <anohigisavay> hi
01:16:39 <JamesJRH> Yep.
01:16:40 <jle`> (take 3 . filter even . map (^2))
01:16:43 <jle`> take 3 drives the evaluation
01:16:49 <JamesJRH> Hi.
01:17:01 <jle`> filter even is the next step in controling the evaluation, etc
01:17:06 <anohigisavay> how do i mark the end of a hex unicode char so that the remaining are regular characters?
01:17:13 <jle`> unfortunately, this doesn't really apply to (=<<), though
01:17:25 <anohigisavay> \x1234 for example, i want \x123 ++ 4
01:18:10 <jle`> JamesJRH: for monadic code, effects drive evaluation
01:18:53 <JamesJRH> jle`: Well I see it very similar to fmap, so what do you have to say about fmap?
01:19:00 <mniip> ooh
01:19:08 <mniip> I only just now figured out what that phrase means
01:19:33 <jle`> JamesJRH: x >>= y >>= z >>= etc;, evaluation is determined by effects/execution
01:19:42 <jle`> so using >>= lets you reason about effects
01:20:10 <jle`> x might determine whether or not y ever gets executed or not
01:20:26 <jle`> and for things like IO, reasoning about order of effects is pretty important
01:20:26 <JamesJRH> > "\x123" ++ "4"
01:20:39 <JamesJRH> Someone do that for me please.
01:20:47 <JamesJRH> > 1 + 1
01:20:55 <mniip> > "ping"
01:20:56 <lambdabot>  "ping"
01:21:08 <mniip> huh
01:21:10 <jle`> anohigisavay: hm, i remember there was a character for this
01:21:29 <JamesJRH>  int-e: Why is lambdabot still not working for me?
01:21:34 <mniip> JamesJRH, the thing you're looking for is called \&
01:21:41 <mniip> "\1234\&5"
01:21:44 <anohigisavay> woa thanks guys
01:21:55 <anohigisavay> the zero-width magic char
01:22:26 <anohigisavay> thank you guys :)
01:22:27 <JamesJRH> mniip: You mean "\x123\&5"?
01:22:39 <mniip> that works too
01:22:55 <JamesJRH> mniip: 09:17:02 < anohigisavay> \x1234 for example, i want \x123 ++ 4
01:23:17 <mniip> well then
01:23:51 <jle`> so, picking the direction of your function composition/application to me is a matter of what aspect you want to emphasize/make it easier to reason about.  for things like IO, reasoning about the order of effects is typically very important, so >>=, >>, etc. make more sense for IO
01:24:13 <jle`> but for typical non-monadic code, reasoning about lazy evaluation and how evaluation is driven is important
01:24:32 <jle`> so (f . g . h) x makes more sense, emphasizes the right things, etc
01:25:13 <mniip> but f $ g $ h x
01:25:14 <jle`> effects even have the ability to determine evaluation, so you don't get any indication about evaluation from (>>=)/(=<<)
01:25:51 <jle`> whenever you use >>=/>> etc. and you want to reason about evaluation, you always have to look into the specific monad/applicative you're using it with
01:26:59 <jle`> but say, for monads with commutative effects, "order of effects" isn't very meaningful or something cool to emphasize
01:27:09 <JamesJRH> mniip: Is it actually a character? Please say: > "\x123\&5"
01:27:19 <jle`> so, like, Maybe, for instance
01:27:20 <JamesJRH> I'm expecting ‘ģ5’.
01:27:30 <JamesJRH> I'm expecting ‘"ģ5"’.*
01:27:50 <mniip> > "a\&b"
01:27:51 <JamesJRH> I.e. with no ‘\&’.
01:27:52 <lambdabot>  "ab"
01:27:57 <JamesJRH> I see.
01:27:58 <mniip> > "\123" ++ "5"
01:28:00 <lambdabot>  "{5"
01:28:03 <mniip> er
01:28:04 <mniip> > "\1234" ++ "5"
01:28:05 <jle`> Maybe is a monad/type with commutative effects, so I often use (=<<) because f =<< x aligns well with (f $ x) or (f x) :o
01:28:06 <lambdabot>  "\1234\&5"
01:28:20 <JamesJRH> Nice. :-)
01:28:30 <jle`> > text "\x123\&5"
01:28:31 <lambdabot>  ģ5
01:28:36 <JamesJRH> Never noticed this before.
01:28:41 <JamesJRH> jle`: Thanks.
01:31:30 <Guest00000> "control is driven from left to right", hm, never thought that way..
01:31:47 <JamesJRH> jle`: Interesting. So, hmm, much to think about…
01:33:12 <JamesJRH> jle`: What about function application? E.g. ‘fmap a b’.
01:33:24 <JamesJRH> Which drives what there?
01:33:55 <jle`> it depends on `b`
01:33:59 <jle`> or, what type `b` is
01:35:10 <jle`> for example, b could be a Functor/type where "everything is strict, and evaluated eagerly", so the `a` function mapped over it doesn't really have any say in evaluation
01:39:11 <jle`> (by that, i mean that `Foo a` might represent a computation using strict semantics that prodices an a, for instance)
01:41:15 <jophish> which array type is best for just wrapping a ForeignPtr with a length. Storable.MVector?
01:55:00 <ggVGc> man, array types in haskell confuse the shit out of me
01:56:31 <tsahyt> ggVGc: Why?
01:58:07 <tsahyt> Is there a library that implements local search algorithms?
01:58:35 <tsahyt> Oh, local-search...
01:58:43 * tsahyt should ask hackage before asking #haskell
01:58:50 <ggVGc> tsahyt: because there are so many, depending on what you want to do
01:59:04 <ggVGc> and because arrays by definition don't fit well in a pure FP context
01:59:56 <tsahyt> They fit decently well for read-only situations at least. But yeah, overall I think tree based solutions are preferable for FP
02:00:46 <tsahyt> I'm using (some kind of) Vector rather often when I need fast lookups of something that I can just compute in advance.
02:01:28 <tsahyt> Once the thing starts mutating, I'd rather use Data.Map instead and sacrifice some of the lookup time for reasonably fast pure updating.
02:01:43 <tsahyt> Actually, Data.IntMap usually.
02:02:36 <dsub> About that. What differs betwean Data.Map and Data.IntMap?
02:02:46 <dsub> in performance
02:03:04 <tsahyt> IntMap has this nice O(min(n,W)) lookup, insertion, member, etc. complexity
02:03:16 <tsahyt> W is the word size of your architecture
02:03:29 <tsahyt> So basically, once you have enough data, you get constant time lookups
02:03:54 <tsahyt> It's reasonably fast in practice, although slower than C arrays.
02:04:36 <dsub> Ah, ok. So the abount of data is a deciding factor for Map/IntMap?
02:04:37 <tsahyt> Data.Map has O(log(n)) for most of these things. But the upside is that you can have arbitrary (up to Ord constraint) keys.
02:05:33 <tsahyt> That and the type of key. If you have Int keys, IntMap is usually the better choice.
02:05:42 <tsahyt> I haven't benchmarked it for small maps though
02:06:01 <tsahyt> log(n) < n after all, so Map might actually be faster for less than 32/64 elements, depending on architecture.
02:06:44 <kadoban> I never actually benchmarked it, but my impression is that the constants are noticeably worse on Data.Map, comparatively.
02:07:19 <dsub> Hmm, ok. Good to know
02:07:23 <kadoban> So even at small sizes I'd expect IntMap to be better. (though again I haven't benchmarked it, it's possible I'm wrong)
02:07:31 <m1dnight_> Is there a function [a] -> [a] -> Bool that checks if two lists are the same, except order?
02:07:37 <m1dnight_> I have hoogled a bit but couldnt find anything.
02:07:51 <m1dnight_> basically this: (all (`elem` allowed) offered && all (`elem` offered) allowed)
02:07:56 <tsahyt> kadoban: Could it be that for sizes that small, a simple list would actually perform just as well?
02:07:59 <kadoban> m1dnight_: Are they Ord?
02:08:07 <m1dnight_> No
02:08:23 <kadoban> tsahyt: I wouldn't be surprised at all, especially for really tiny stuff.
02:08:37 <tsahyt> I should do some benchmarks one day
02:08:41 <m1dnight_> Oh you are implying sort and then ==? I could implement Ord real quick.
02:08:42 <kadoban> tsahyt: But I don't tend to do that kind of thing, because … it has a tendency to bite when stuff gets bigger and I forget I did it.
02:08:53 <kadoban> m1dnight_: Right, sorting makes it a trivial problem.
02:09:22 <tsahyt> kadoban: Right, I always assume that my problems will get larger, unless I find myself having some kind of static dataset inside of some algorithm.
02:09:58 <kadoban> tsahyt: Right, exactly.
02:10:25 <kadoban> :t (==) `on` sort -- for your golfing pleasure, if you're into that kind of thing.
02:10:27 <lambdabot> Ord a => [a] -> [a] -> Bool
02:14:46 <tsahyt> Oh nice there're even complete CSP solver libraries. That kinda takes the fun out of my weekend project though
02:15:47 * hackagebot persistable-record 0.3.0.0 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.3.0.0 (KeiHibino)
02:21:07 <tsahyt> What's the preferred web scraping library? scalpel?
02:27:28 <jophish> I have a custom script which generates an object file I'd like to link with my haskell program, how should I go about putting this info in Setup.hs and the cabal file?
02:33:24 <danza> tsahyt, this might help for scraping https://github.com/bos/wreq
02:33:44 <danza> didn't know about scalpel... neat!
02:36:21 <fractalsea> What the best way of transforming a list of indices (e.g. [3,7,8]) into a list [1, 1, 1, 2, 2, 2, 2, 3] i.e. a monotonic list where the number of times a number is repeated is the difference between the numbers in the original list
02:38:16 <tsahyt> danza: Yeah scalpel seems pretty cool, as it includes all the parsing via tagsoup too. I think I'll go with that if I actually end up realizing the idea I have.
02:39:02 <tsahyt> I've been thinking about writing something to automate my class scheduling for a while now, and the actual scheduling part isn't too hard (to implement, optimal scheduling is NP-hard of course), but the scraping part always put me off
02:43:18 <danza> i understand your concern, scraping with Haskell might seem scary because with a naive approach you would have to declare the data structure of scraped resources, having a library can help a lot. Good luck!
02:43:51 <tsahyt> Thanks, now I just gotta figure out what the actual CSP to solve would look like.
02:45:33 <puregreen> fractalsea: I'd first turn it into a list of differences and then use replicate
02:45:53 * hackagebot relational-query 0.8.0.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.0.0 (KeiHibino)
02:46:34 <puregreen> @let diffs (x:xs) = x : zipWith (-) xs (x:xs)
02:46:36 <lambdabot>  Defined.
02:46:52 <puregreen> > concat $ zipWith replicate (diffs [3,7,8]) [1..]
02:46:54 <lambdabot>  [1,1,1,2,2,2,2,3]
02:48:15 <fractalsea> puregreen, Ah nice. I was going to use this: snd $ foldl' (\(prevI, rest) i -> (i, i - prevI : rest)) (0, []) input
02:48:22 <fractalsea> puregreen, that’s much nice. Thanks
02:49:01 <dsub> or "difflst lst@(l:ls) = zipWith (\a b -> replicate (b - a) b ) lst ls"
02:49:05 <fractalsea> puregree, that offsetting of the same list by one and using zipWith is a nice way of being able to reference the previous value without needing a fold
02:50:01 <puregreen> it's a common trick
02:50:24 <puregreen> > let fibs = 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
02:50:28 <lambdabot>  mueval-core: Time limit exceeded
02:50:46 <puregreen> uh
02:51:02 <fractalsea> puregreen, makes sense. I’ve used haskell for a lot ofmore imperetive stuff, but this list transformation stuff is pretty new to me
02:51:05 <puregreen> > let fibs = 1 : 1: zipWith (+) fibs (tail fibs) in take 10 fibs
02:51:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
02:56:17 <Nadrieril> @pl \f g a b -> f (g a b)
02:56:17 <lambdabot> (.) . (.)
02:57:14 <liste> @src (.:)
02:57:14 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:03:20 <joco42> can someone comment on this ? http://stackoverflow.com/questions/34945044/what-is-a-roundabout-proof-in-propositions-as-types-by-p-wadler
03:05:02 <jophish> How can I link my executable with an object file, adding --ld-options="myobject.o" doesn't seem to work
03:06:43 <liste> jophish from ghc --help:
03:06:44 <liste>     # link three .o files into an executable called "test":
03:06:44 <liste>     % ghc -o test Foo.o Bar.o Baz.o
03:06:49 <liste> does that work for you?
03:06:59 <liste> don't know how to tell that to Cabal though
03:08:20 <jophish> liste: at the moment I'm fiddling with BuildFlags in Setup.hs without any success
03:09:05 <tsahyt> Couldn't you just add it to the ghc-options field?
03:09:13 <tsahyt> There's probably a cleaner way though
03:09:53 <jophish> tsahyt: I'll give that a try, thanks for the suggestion
03:10:07 <jophish> although I only really want to add it for the link stage
03:12:19 <liste> can you package the object file(s) into an .a ?
03:13:35 <jophish> liste: I suppose so
03:13:55 <jophish> although I don't know how portable that'll be
03:14:44 <liste> well, .o's aren't portable either AFAIK
03:15:02 <liste> when you have a library (.a), you can use Extra-Libraries
03:15:17 <jophish> sorry, I meant: calling ar might not be portable to windows
03:15:26 <jophish> although this is going to be such a nightmare on windows anyway
03:15:42 <jophish> liste: I think that's the best option, compiling to a static library. Thanks
03:24:30 <jophish> liste: please excuse me for being dense, but I can't seem to figure out how to link with a .a file in the source directory? I think it's because the -lmylib flag is being put after -dynamic in the linker command line
03:25:55 * hackagebot relational-query 0.8.0.1 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.0.1 (KeiHibino)
03:26:20 <liste> jophish try if this helps: http://codinginfinity.me/post/2015-04-18/haskell_and_cpp
03:35:51 <jophish> liste: that did the trick, it was simply extra-lib-dirs missing
03:35:54 <jophish> thanks for the help!
03:36:26 <liste> yw (:
03:41:05 * hackagebot path-io 0.2.0 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-0.2.0 (mrkkrp)
03:41:07 * hackagebot relational-schemas 0.1.2.2 - RDBMSs' schema templates for relational-query  https://hackage.haskell.org/package/relational-schemas-0.1.2.2 (KeiHibino)
03:46:39 <m1dnight_> Is there a particular reason why only (,) is foldable and not (,,) or larger?
03:48:09 <frerich> m1dnight_: See https://mail.haskell.org/pipermail/libraries/2016-January/026579.html
03:48:49 <m1dnight_> Ah, thanks! :)
03:52:47 <Gurkenglas> Does some lensy stuff allow me to zip a 2-argument function over two "zippy" containers?
03:58:26 <tremon> what's the recommended way to determine a file's size without opening it? So far I've only found hFileSize, which takes a Handle instead of a FilePath (or String)
03:59:33 <Gurkenglas> Are you Hualet? I was just reading that thread :D https://www.reddit.com/r/haskell/comments/41olkr/retrieve_the_size_of_a_file/
03:59:52 <tremon> lol. no, am not :)
04:00:01 <Gurkenglas> Why do you need the file's size?
04:00:05 <liste> @hackage unix-compat -- tremon System.PosixCompat.Files here
04:00:05 <lambdabot> http://hackage.haskell.org/package/unix-compat -- tremon System.PosixCompat.Files here
04:00:31 <liste> it has getFileStatus and fileSize
04:01:06 * hackagebot relational-query-HDBC 0.5.0.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.5.0.0 (KeiHibino)
04:01:49 <tremon> thanks. For now, I was just looking at generating a directory listing. For that I'll probably need the rest of stat() as well, but iirc stat() doesn't port to Windows interfaces
04:02:06 <tremon> so it's more out of curiosity than direct need
04:02:41 <liste> that unix-compat package is supposed to emulate POSIX calls on Windows
04:02:49 <liste> not sure how far it goes in that regard
04:02:53 <Gurkenglas> Ah, if you want to actually work with filesystem data for it's own sake, my suspicion of a code smell falls flat.
04:02:56 <tremon> ah. another problem solved then :)
04:04:42 <tremon> I'm actually working on a (http) file browser, simply to get a feel for writing haskell web servers. It's just a throwaway project
04:05:29 <dsub> tremon: Is it on github? Would be nice to see how it looks :)
04:06:54 <tremon> no it's not :) I'm still kinda bashful when it comes to my own code :)
04:07:33 <dsub> you're not alone... :)
04:12:06 <movedx> It's always good to get feedback. A good engineer embraces her flaws and grows beyond them.
04:36:41 <maerwald> I wouldn't call it "embrace"... recognizing is enough ;)
04:45:18 <hodapp> 'embracing' flaws sounds too much like the retrospective fake-modesty thing some people do.
04:46:08 * hackagebot servant-swagger 0.1.1 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-0.1.1 (NickolayKudasov)
04:52:59 <JamesJRH> > 1 + 1
04:53:28 <JamesJRH> >:-(
04:53:29 <Wizek> Can I search on hackage for libraries in a particular category and sort them by number downloads/votes?
04:54:55 <JamesJRH> What is the tool that simplifies and converts things to point-free form?
04:55:09 <maerwald> plz don't use it
04:55:18 <JamesJRH> Is it something like ‘pl’?
04:55:31 <Wizek> @pl \a-> a + 1
04:55:31 <lambdabot> (1 +)
04:55:45 <JamesJRH> That's the one, thanks.
04:55:59 <maerwald> if you can't figure out the point-free form by yourself, don't use it
04:56:07 <Wizek> maerwald, Why not?
04:56:09 <maerwald> chances are the next guy reading it won't understand it either
04:58:36 <JamesJRH> maerwald: It's not that, it's that I think that I can reduce some things if I convert the expresion in question to point-free form.
04:59:12 <JamesJRH> @pl \f -> (=<<) (flip g f) m
04:59:51 <maerwald> in my experience, most of what the pointfree tool throws at you makes things harder to understand, regardless of whether it's reduced or not (sometimes the line gets longer even)
04:59:53 <JamesJRH> Please can someone that lambdabot doesn't have a grudge against repeat that?
05:00:28 <JamesJRH> Well we'll see.
05:00:35 <maerwald> I'd say it makes more sense to ask other people on how to reduce something instead of that tool.
05:00:35 <JamesJRH> It may or may not help.
05:00:52 <Wizek> @pl \f -> (=<<) (flip g f) m
05:00:52 <lambdabot> (m >>=) . flip g
05:01:19 <JamesJRH> Ahh, that helps actually.
05:01:24 <JamesJRH> Wizek: Thanks.
05:01:36 <aweinstock> @unpl (m >>=) . flip g
05:01:36 <lambdabot> (\ h -> m >>= \ d -> g d h)
05:01:45 <aweinstock> @. do unpl (m >>=) . flip g
05:01:45 <lambdabot> (\ h -> do { d <- m; g d h})
05:02:03 <JamesJRH> Urgh, not /do/!!!
05:02:28 <JamesJRH> Do is syntactic salt. :-P
05:02:38 <Wizek> heh, didn't know about `@.`, nice.
05:02:42 <aweinstock> I'm just illustrating that lambdabot can go both ways
05:02:54 <aweinstock> @. pl undo (\ h -> do { d <- m; g d h})
05:02:54 <lambdabot> (m >>=) . flip g
05:03:10 <maerwald> JamesJRH: why does that matter? You don't compile it by hand do you?
05:03:15 <JamesJRH> aweinstock: Thanks. It's good to know.
05:03:29 <Wizek> @ pl . undo $ "(\ h -> do { d <- m; g d h})"
05:03:46 <JamesJRH> Hey, undo? Now that's /really/ nice!
05:04:11 <Wizek> hmm, shame that lambdabot dosn't follow haskell semantics in its commands
05:04:30 <JamesJRH> Heh.
05:04:43 <JamesJRH> maerwald: What matter?
05:04:57 <maerwald> JamesJRH: whether you use syntactic sugar or not
05:05:25 <Wizek> JamesJRH, Btw, does lambdabot hold a grudge against you even if you query it in private?
05:06:50 <JamesJRH> maerwald: I find do-notation very difficult to understand without converting to be in terms of arrows, fmap, join, return, etc..
05:06:57 <JamesJRH> Wizek: Yes.
05:07:23 <JamesJRH> And still yes. (Just tried again now.)
05:07:29 <maerwald> JamesJRH: that's weird. If you write heavy IO code without do notation you will end up with unmaintainable code.
05:08:04 <Wizek> maerwald, Maybe he writes relatively few io operations? :)
05:08:15 <maerwald> Wizek: that wasn't the point
05:08:35 <maerwald> it's an important thing to be able to handle
05:08:41 <JamesJRH> Wizek: Few IO operations at present, indeed. I try to keep as much as possible pure-functional.
05:08:50 <maerwald> IO is pure-functional
05:09:25 <JamesJRH> maerwald: I start with fmap/join/return, then arrows, then do if necessary.
05:09:31 <JamesJRH> I know it is.
05:09:57 <JamesJRH> But it doesn't feel like it in do-notation.
05:10:01 <maerwald> as long as you don't use @pl in order to avoid do-notation, I think it's fine
05:10:51 <JamesJRH> Plus, do-notation looks like imperative code but works entirely differently, so is not good for beginners coming from imperative programming.
05:11:25 <maerwald> that's why good lectures start with monads and bind operator before do notation
05:11:39 <maerwald> after that, it's pretty easy
05:11:49 <JamesJRH> Yes, I agree with that.
05:12:19 <maerwald> although... the other day, some student came here and asked about do notation, until people figured out he didn't really know what monads were
05:12:25 <maerwald> so it seems some teach it wrong
05:13:22 <JamesJRH> When I first looked at monads, do-notation was the entry point and I never could grasp it. It wasn't until I found the ‘category theory entry point’ that I started to get it.
05:16:04 <ahihi2> I'd expect a beginner would have an easier time understanding the *intent* behind a do-block, than code written in terms of fmap/join/return...
05:16:39 <JamesJRH> Ah, lambdabot flipped the arrow. I was expecting it to be on the other side and it is without the arrow flipped.
05:17:05 <JamesJRH> I.e.: (=<< m) . flip g
05:17:36 <JamesJRH> Or just ‘(=<< m) . flip f’ now that there's no other function.
05:27:32 <geekosaur> > text "\x123\&5" -- beware of Show
05:27:33 <lambdabot>  ģ5
05:28:26 <liste> does `text' make lambdabot show strings as-is ?
05:28:44 <liste> > text "mot\x308orhead"
05:28:47 <lambdabot>  moẗorhead
05:29:15 <liste> > text "na\x308ıve"
05:29:17 <lambdabot>  näıve
05:29:31 <liste> awesome
05:29:34 <geekosaur> it's a bug in the Show instance of Doc from one of the pretty-printing libraries, which is unfixed because it's helpful to avoid the usual Show instance behvaior of lambdabot
05:29:52 <geekosaur> :t text ""
05:29:53 <lambdabot> Doc
05:30:10 <pavonia> geekosaur: What's a bug?
05:30:46 <opqdonut> > read (show (text "na\x308ıve")) :: Doc -- this is the bug
05:30:48 <lambdabot>      No instance for (Read Doc) arising from a use of ‘read’
05:30:48 <lambdabot>      In the expression: read (show (text "na\776\305ve")) :: Doc
05:30:54 <opqdonut> oh, there is no Read instance
05:30:55 <geekosaur> Show istances are not supposed to be pretty, they're supposed to provide some combination of "resembles source code" and "proides eough info to debug oddness"
05:30:56 <opqdonut> oh well
05:31:03 <geekosaur> useful, not pretty
05:31:18 <geekosaur> but here we let it be pretty because it'sthe only way to get pretty out of thebot >.>
05:31:30 <pavonia> Ah, I see
05:31:45 <geekosaur> (the oroer render instances for such things all involve IO, so can't be run in the bot)
05:31:53 <geekosaur> s/oroer/proper/
05:32:03 <Xandaros> Technically, there is nothing wrong with pretty printing in a Show instance as long as it is parsable in the Read instance or it doesn't have a Read instance
05:32:05 <Xandaros> :P
05:32:51 <geekosaur> technically, no, but there is a lot to be aid for not having to feed the output of show through a hex dumper to make sure what the real contents are
05:32:59 <geekosaur> *be said
05:33:46 <Xandaros> I actually abuse Show quite a bit in executables. But I know I'm abusing it and I'd never do that in a library
05:33:52 <Xandaros> Still, it can sometimes be useful for debugging
05:34:56 <JamesJRH> liste: In Unicode (NFD), the modifier comes after the modified character.
05:35:45 <liste> > text "moto\x308rhead"
05:35:46 <lambdabot>  motörhead
05:36:10 <liste> now that's even more metal
05:36:24 <Xandaros> > "ö"
05:36:25 <lambdabot>  "\246"
05:36:40 <Xandaros> gotta love Show Char :D
05:37:02 <liste> it should escape only unprintables
05:37:06 <JamesJRH> Also, that's interesting: U+0131 LATIN SMALL LETTER DOTLESS I
05:37:08 <liste> why it doesn't :<
05:37:42 <JamesJRH> I forgot about that and so my Normalisation Form D that I did yesterday must have been incorrect.
05:38:04 <Xandaros> > "äöüß²³¼½→€←→øæå"
05:38:06 <lambdabot>  "\228\246\252\223\178\179\188\189\8594\8364\8592\8594\248\230\229"
05:38:12 <Xandaros> Not even €? ...
05:38:26 <geekosaur> because it's using a defintion of "unprintables" from the 1990s when the programming world still didn't like acknowledging that there was intelligent life outside of the US
05:38:55 <liste> > text "double na\x308ive"
05:38:56 <lambdabot>  double näive
05:39:08 <liste> the "predator" i
05:39:17 <Xandaros> > text "äöüß²³¼½→€←→øæå"
05:39:18 <lambdabot>  äöüß²³¼½→€←→øæå
05:39:56 <John[Lisbeth]> oh lord what is this unicode
05:40:21 <John[Lisbeth]> window 9
05:40:46 <JamesJRH> liste: It should be ‘naïve’ (in NFC); the diaeresis replaces the dot on the ‘i’.
05:41:35 <liste> JamesJRH so my text rendering renders it incorrectly as a  triple-dot 'i' ?
05:41:53 <liste> or does normalization remove the extra dot
05:42:25 <JamesJRH> I don't have a way to type for NFD, but it would be: na\x131\x308ve
05:43:02 <liste> > "ı"
05:43:03 <lambdabot>  "\305"
05:43:28 <liste> > text "na\x131\x308ve"
05:43:29 <lambdabot>  naı̈ve
05:43:35 <Xandaros> lol
05:43:59 <Xandaros> > "ï"
05:44:01 <lambdabot>  "\239"
05:44:07 <JamesJRH> liste: No, my example yesterday was incorrect for I. It would have been fine for the other vowels but I forgot about the I dot.
05:44:39 <JamesJRH> > '\x131' == '\305'
05:44:40 <kqr> does makeLenses do anything when the type does not follow the underscore convention?
05:44:53 <kqr> ah there's makeLensesFor for that
05:45:32 <JamesJRH> Let's try another instance of myself…
05:46:04 <Xandaros> kqr: My personal favourite is declareLenses, though you can run into issues using that
05:47:59 <JRHaigh> > '\x131' == '\305'
05:48:01 <lambdabot>  True
05:48:19 <kqr> Xandaros, declareLenses looks cool, but in this case I'm creating lenses for a datatype I've imported from a third-party library
05:49:08 <Xandaros> kqr: Ah, I see
05:49:55 <kqr> (why don't all third party libraries create lenses for their types...)
05:50:52 <JRHaigh> > "\x123\&5"  -- Expecting: "ģ5"
05:50:53 <lambdabot>  "\291\&5"
05:51:07 <JRHaigh> Oh, of course.
05:51:09 <int-e> JamesJRH: might work again... I'm not logging lambdabot's ignore commands.
05:51:31 <Xandaros> kqr: Because not everybody uses lenses and creating them by hand is annoying. To make use of the TH machinery, they'd have to add lenses as a dependency, adding a lot of compile time (30 minutes of my machine, just for lens)
05:51:52 <jophish> I couldn't find a function for this, but I'm sure it's above the fairbairn threshold. I'm looking for a function :: m (Maybe a) -> Source a m
05:51:53 <JamesJRH> It was just mentioned that Show is stuck in the 1990s.
05:51:55 <jophish> for conduit
05:52:03 <kqr> Xandaros, is it really *that* bad creating them manually?
05:52:14 <jophish> so it repeats the action which supplies a Maybe value until it returns nothing
05:52:31 <JamesJRH> So the ģ gets escaped again.
05:52:37 <JamesJRH> > 1 + 1
05:52:38 <lambdabot>  2
05:52:39 <jophish> obviously it's not too hard to do, but I can't help feeling that it ought to be in Conduit
05:52:45 <JamesJRH> int-e: Thank you.
05:52:57 <JamesJRH> Do you know what went wrong?
05:52:58 <liste> how'd you get ignored in the first place?
05:53:53 <JamesJRH> PM still doesn't work, though.
05:53:53 <Xandaros> kqr: It's not *that* bad, but it's annoying. And unnecessary bloat since most users probably won't be using lens
05:53:57 <int-e> JamesJRH: well you did issue a lot of long lambdabot commands around that time; I suspect you annoyed some lb admin (not me) and they told lambdabot to ignore you.
05:54:24 <jophish> I suppose it would be similar to :: Applicative m => m (Maybe a) -> m [a]
05:55:14 <JamesJRH> int-e: I wondered if it was that. But other people said it didn't work for them either. Also, they didn't work by PM after I took it there.
05:55:43 <JamesJRH> int-e: Is lambdabot's ignore feature automatic?
05:56:40 <JamesJRH> Because if not, it was inconsiderate to have not told me that I was manually set to be ignored.
05:56:42 <int-e> JamesJRH: no it's not; not on lambdabot's side anyway. and unfortunately there isn't currently an "ignore public messages" only ignore feature in lb.
05:57:14 <int-e> anyway... will at least start logging those commands so assigning blame becomes easier.
05:57:56 <Xandaros> Talking about lambdabot - I'm running my own instance. How difficult would it be to go from nick based to host based authentication?
05:57:59 <JamesJRH> Hmm, lambdabot still hasn't replied to my PM.
05:58:29 <JamesJRH> Yet you say that it doesn't distinguish PM/publish, so…
05:58:34 <JamesJRH> > 1 + 1
05:58:35 <lambdabot>  2
05:58:41 <JamesJRH> Hmm, weird.
05:58:50 <JamesJRH> Just not PM, now.
05:59:09 <geekosaur> Xandaros, not that difficult but host based isn't necessarily more secure. I looked at using freenode registration for auth but that looked more difficult because it'd need an extra round trip
05:59:09 <int-e> JamesJRH: did you include the > ?
05:59:27 <JamesJRH> Did now.
05:59:29 <jewels> Hi there. How can I define a Functor with constraints? http://lpaste.net/150509
05:59:35 <JamesJRH> I just realised that.
05:59:56 <Xandaros> geekosaur: I was thinking about requiring people with authentication to use a cloak. That should be quite secure, I think
06:00:20 <geekosaur> hm,actually I think that requires an extra roundtrip too
06:00:26 <geekosaur> whic makes it painful
06:00:34 <Xandaros> More than nick, that's for sure. At the moment, I added a plugin which adds a command that sets you on the admin list if you supply a password. Not ideal
06:00:40 <Xandaros> Yeah, that's what I thought :/
06:00:47 <JamesJRH> int-e: Some REPL bots omit the prompt when interacting by PM, and I forgot that lambdabot doesn't do that.
06:01:13 <geekosaur> jewels: can't do it with Functor itself (or Monad). take a look at http://hackage.haskell.org/package/rmonad though
06:01:53 <jewels> geekosaur: where can I find some examples? Maybe can you write me an example?
06:02:19 <Xandaros> geekosaur: hmm, actually...
06:02:23 <geekosaur> no, I probably can't. I'm aware of the problem, I don;t generally run into it myself though
06:02:41 <geekosaur> (it's the "why Map/Set aren't Monad-s" question that comes up fairly often)
06:03:05 <JamesJRH> Also, sorry everyone for the large volume of errors yesterday that triggered whoever it was to set lambdabot to ignore me.
06:03:16 <Xandaros> geekosaur: http://i.imgur.com/bd8Cxzl.png
06:03:51 <Xandaros> Looks like the host gets sent to the client with every message
06:04:11 <geekosaur> whoever did that, btw, really should have said something --- in #haskell-ops if not in here
06:04:32 <geekosaur> or at absolute minimum should have notified the bot owner (int-e)
06:06:46 <JamesJRH> int-e: There are quite a few things that work for me in GHCi and then don't work with lambdabot, so, lesson learnt, what I'll so in future when I'm not reasonably sure that it'll work is: GHCi → lambdabot via PM → lambdabot in-channel
06:08:08 <JamesJRH> s/I'll so in/I'll do in/
06:09:07 <geekosaur> note that lb does not offer a number of things that ghci does, most notably :info
06:09:53 <Xandaros> Well, it is pretty spammy
06:10:14 <jewels> geekosaur: Anyway, rmonad seems to have a dependency (suitable) which doesn't compile with GHC
06:10:52 <geekosaur> yep. it'd be a tradeoff between the bot getting kicked for flooding or requiring a lot of @more from the user, ultimately it's just too annoying to bother with
06:17:43 <gameer> hello
06:22:07 <gameer> hey guys
06:22:24 <gameer> I have a type like (String -> [Int]
06:22:26 <gameer> )
06:22:47 <gameer> Now I want to give in the console x the value [1,2] and y the value [20,30]
06:23:16 <gameer> I tried this
06:23:58 <gameer> function (\_ -> { case of "x" -> [1,2]; "y" -> [20,30]})   but there is a mistake i cant find
06:24:51 <JamesJRH> 13:41:12 < liste> JamesJRH so my text rendering renders it incorrectly as a  triple-dot 'i' ?  ← I'm thinking that it is correct to render "i\x308" with a triple dot. What is not correct is the use of lowercase I rather than the dotless version. However, neither that article you linked yesterday or the relevant Wikipedia articles clarify the issue.
06:25:29 <Xandaros> gameer: First of all - do you really want to use a lambda for that?
06:25:37 <geekosaur> this is going to be up to the font rendering machinery and to the font definition itself
06:26:06 <frerich> gameer: 'case of "x"' is a syntax error. Did you really mean to ignore the argument? Maybe you meant '\s -> case s of ...'?
06:26:08 <gameer> Xandaros: It was explained to me yesterday in this way
06:26:39 <geekosaur> I wonder if they actually wanted you to use the LambdaCase extension, but that doesn't match what you showed either
06:26:56 <gameer> It is simpler, without lambdas?
06:29:03 <domen> where are instructions for installing stack on linux mint?
06:29:28 <gameer> frerich: I never worked with "case of" before
06:29:45 <gameer> And I forgot unfortunately to notice the correct input
06:29:51 <frerich> gameer: You could also use an 'if' in case you feel more comfortable with that.
06:30:00 <Xandaros> gameer: You can do something like this: http://tcp.mniip.com/selq
06:30:14 <Xandaros> If you use ghci, you need to put "let " in front of each line
06:30:38 <JamesJRH> 13:41:30 < liste> or does normalization remove the extra dot  ← I'd say that converting from NFC "ï" (single codepoint; "\xef") to NFD should not combine with the dotted I but instead be "\x131\x308" (dotless I + combining diaeresis). But I guess that maybe this is what the Haskell UTF library is all about. Otherwise it'd have no benefit over Data.Text, so perhaps we can test it…
06:30:45 <Xandaros> Actually, it won't work in ghci like that
06:31:17 <tremon> ghci requires it all on one line, with one let and semicolons
06:31:28 <JamesJRH> Btw., this is the Wikipedia article that I mentioned: https://en.wikipedia.org/wiki/Unicode_equivalence
06:31:45 <geekosaur> JamesJRH, Haskell has no control over that, it is up to the font rendering machinery (which will depend on what program is displaying the font) and to some extent on the font definition itself
06:32:18 <geekosaur> that is, details like how the base character is modified to allow for modifiers are usually specified in the .ttf or .otf containing the font
06:32:45 <geekosaur> so if your font is dropping dots, consider switching fonts
06:33:16 <JamesJRH> liste: Ahah: http://hackage.haskell.org/package/unicode-normalization
06:33:26 <JamesJRH> geekosaur: ^
06:33:49 <geekosaur> yes, and?
06:33:56 <JamesJRH> geekosaur: Yes, font rendering is a different issue.
06:34:32 <JamesJRH> I'm curious about the correct NFD form of ‘ï’.
06:34:34 <geekosaur> "i\308" does not say "replace the 'i' with 'ı'", normalization libraries do not say to do that, the font definition does
06:34:44 <JamesJRH> Not that I ever use it, mind.
06:35:50 <JamesJRH> liste: Btw., NFC seems to be always preferred where there exists the desired character, and NFD used to construct characters that don't have an NFC form.
06:36:12 <geekosaur> whatever is doing the font rendering may also try to do that (since I use hexchat it'd be the Pango library, for text-based IRC it will be your terminal emulator) but it should not be making that call itself
06:36:33 <geekosaur> it most certainly is not controlled by, or even visible to, ghci or lambdabot
06:37:03 <JamesJRH> I've only ever used NFD for putting macrons and tildes over digits as part of a mathematical notation.
06:38:00 <JamesJRH> geekosaur: That is not what I'm talking about.
06:38:37 <geekosaur> [22 14:30] <JamesJRH> 13:41:30 < liste> or does normalization remove the extra dot  ← I'd say that converting from NFC "ï" (single codepoint; "\xef") to NFD should not combine with the dotted I but instead be "\x131\x308" (dotless I + combining diaeresis). But I guess that maybe this is what the Haskell UTF library is all about. Otherwise it'd have no benefit over Data.Text, so perhaps we can test it…
06:38:40 <geekosaur> sure sounds like it is
06:38:57 <geekosaur> you do not do this modification at this level
06:39:30 <geekosaur> or you will have horrible problems every time you switch fonts
06:39:34 <jewels> Hi there. I've defined a custom functor which can use multiple parameters. But I'm not able to use it properly: http://lpaste.net/150510. I'm not able to use Rmonad for two reasons: 1) It doesn't compile; 2) Doesn't support applicative functors (I will need it)
06:39:46 <JamesJRH> "ï" is NFC and is rendered however. liste was talking about NFD and I reckon that that character in NFD is "\x131\x308", but haven't yet found confirmation.
06:41:05 <geekosaur> I reckon it is not and the font definition does it, because otherwise Unicode rendering becomes something that only a few specialized programs can do and those programs must have custom support for each font they might use
06:42:06 <geekosaur> which pretty much makes the whole thing pointless and drops us back in the bad old days (and don't even bother trying to support Unicode in a terminal program)
06:42:20 <tremon> jewels: if I'm reading that right, DFunctor takes three arguments and Fuzzyset takes two. So your "DFunctor FuzzySet" should have five type variables
06:44:36 <jewels> tremon: So how can I fix it?
06:45:41 <tremon> I think your DFunctor should only have one type argument (class DFunctor f where)
06:46:26 <Unhammer> Text.XML.parseLBS_ doesn't seem to come with any documentation, but does anyone know if it puts the whole document in memory?
06:47:12 <Unhammer> (my simple program that reads through a huge xml file seems to use a lot of memory, but I never feel completely confident in what step is keeping the memory …)
06:47:26 <JamesJRH> geekosaur: Normalisation is separate from font rendering.
06:47:48 <geekosaur> ...
06:47:59 <geekosaur> never mind yes, fix it at the wrong level and do a lot more work in every program
06:48:01 <jewels> tremon: I need to define a custom functor which can allow to me to obtain a "FuzzySet j m" from a "FuzzySet i m"
06:49:14 <JamesJRH> geekosaur: I'm basically pretty sure that a function ‘fromNFCtoNFD’ applied to "ï" will produce "\x131\x308". /Not/ "i\x308".
06:49:42 <geekosaur> Yes, I noticed that you are sure of that
06:50:25 <JamesJRH> Also, I didn't say anything was broken.
06:50:27 <tremon> ah... in that case you really need to declare your isntance as a DFunctor FuzzySet i m j m
06:50:34 <geekosaur> I also noted that that design is not maintainable, and makes assumptions about the font and the device it is rendered to (for rendering to high resolution stuff, like printers, it should not be modified)
06:51:39 <tremon> ehm no, that's not correct. Not i m j m, likely i m i j
06:51:58 <jewels> tremon: If I do this: "DFunctor FuzzySet i m j m", I got this error: "DFunctor is applied to too many arguments"
06:52:13 <tremon> argh. let me try :)
06:52:25 <JamesJRH> 14:41:43 < geekosaur> which pretty much makes the whole thing pointless and drops us back in the bad old days (and don't even bother trying to support Unicode in a terminal program)  ← For terminals, there is NFKC, which works nicely with fixed-width fonts where the font has no control over the matter anyway: http://unicode.org/reports/tr15/#Norm_Forms
06:52:34 <geekosaur> sigh
06:52:41 <geekosaur> ok, my point is completely lost. do what you will
06:52:42 <jewels> tremon: Thank you :)
06:53:21 <geekosaur> make sure anyone using it knows that high resolution devices are not properly supported and that programs may need to bemodified for use with some fonts
06:53:32 <geekosaur> or, dont bother with such issues and let the users find out the hard way
06:54:10 <JamesJRH> I generally just stick to NFC.
06:54:29 <JamesJRH> Which is the one where the font does the work.
06:55:50 <JamesJRH> Or not so much ‘work’ but as in it is defined there.
06:58:08 <JamesJRH> geekosaur: Nevertheless, the Unicode specification defines normalisation and so a question about it has a determinable answer, regardless of whether I use the other normalisation forms, which I don't. It was just a matter of curiosity. I'm not doing anything wrong as I'm not doing that which you are saying is wrong.
06:59:38 <JamesJRH> At least, I've never used NFKD and NFKC, and have only used NFD where NFC does not support the character that I wanted.
07:00:02 <tremon> jewels: lots of functions not in scope for me, but "instance (Ord i, Ord j) => DFunctor (FuzzySet i) i j where" typechecks for me
07:00:39 <tremon> jewels: btw "Ord f" already implies "Eq f", no need to specify both
07:01:02 <jewels> tremon: Thank you for your suggestions :)
07:02:36 <JamesJRH> I'd much rather it if ‘monospace’ fonts/terminals would actually be a bit more versatile and allow some special characters to occupy integer widths greater than 1 so that they are easier to read.
07:03:07 <Xandaros> That wouldn't be monospaced, though, would it? :P
07:04:27 <geekosaur> some terminals do support that. I don't think I've seen one on Linux that does so, though
07:04:58 <geekosaur> that said, *you* try hacking proper support for that into ncurses.
07:05:10 <JamesJRH> geekosaur: For example, ‘⋙’ displays terribly in my terminal whereas it would be much better displayed as triple-width.
07:05:30 <geekosaur> remember that it now has to know what font the terminal emulator is using and details of how it renders particular characters
07:06:01 <JamesJRH> geekosaur: I've seen so double-width characters, but the support isn't great.
07:07:04 <JamesJRH> geekosaur: Well that's why NFKC or NFKD avoids that issue by normalising ‘⋙’ to ‘>>>’.
07:07:38 <JamesJRH> But yeah, I'd prefer this be done by the font.
07:07:45 <geekosaur> also detail like what happens when you select it and can the user actually tell the difference between them
07:07:58 <JamesJRH> Indeed.
07:08:04 <geekosaur> and again, supporting using those in e.g. ncurses
07:08:18 <LeCamarade> The problem is that we are still programming for terminals so old that you only actually run simulators thereof.
07:09:23 <JamesJRH> Correct selection, copy, and paste would be broken in NFKC and NFKD, and the user would not be able to tell the difference.
07:09:35 <JamesJRH> LeCamarade: Indeed.
07:10:39 <Xandaros> LeCamarade: Yeah... I wouldn't mind a reform of terminals. Like actually adding things like return could be handy... (Return is actually just ctrl-m for those who don't know)
07:10:55 <LeCamarade> :-o
07:11:01 <LeCamarade> I didn’t know about C-m!
07:11:25 <LeCamarade> Wow.
07:11:53 <kqr> hi! I have a set of things from which I want to draw one thing at a time, removing it from the set of things. is there a data structure for this that is set-like in that it does not allow duplicate elements?
07:11:54 <JamesJRH> LeCamarade: Also, REPLs are pretty inconvenient, though this is an independent issue because they could be replaced with a better model without improving the terminal, and terminals can be improved without replacing REPLs. I'd like it if both were improved.
07:12:25 <kqr> I could elemAt followed by deleteAt but it feels silly
07:12:34 <kqr> especially since elemAt is partial
07:12:57 <JamesJRH> Xandaros: What's special about ^M?
07:13:32 <Xandaros> JamesJRH: Nothing. It's just that it is synonymous with return, which I find very unfortunate)
07:13:49 <Xandaros> There are a few of those and it means you can't use those combinations for anything else
07:13:58 <LeCamarade> Me, I am thinking of a 100% vector terminal.
07:13:58 <JamesJRH> Ah.
07:14:00 <JamesJRH> I see.
07:14:12 <JamesJRH> Xandaros: Yes, that is annoying.
07:14:49 <LeCamarade> I am no longer into REPLs, because I am no longer into line input. I am thinking Smalltalk-80 style kind of environment. Every other _kind_ of dynamic runtime else is a hack.
07:14:56 <Xandaros> It's especially great when you have something like emacs which actually distinguishes between the two and doesn't recognize the actual return key (since it gets mapped to C-m)
07:15:07 <JamesJRH> I knew about return but didn't realise that issue, but wait a minute…
07:16:14 <LeCamarade> But, really, carriage return as an escape sequence? And it is the biggest button on my keyboard? That’s a weird one.
07:17:06 <LeCamarade> Also, regarding terminals, I like the rather simple BitBlt of Plan 9.
07:17:26 <LeCamarade> (Although it makes their editor—sam, I think—rather dodgy to use.)
07:18:46 <srhb> kqr: What's wrong with Set?
07:18:48 <JamesJRH> Xandaros: Anything that you can do with ‘stty eol CHAR’? See ‘stty -a’ and the stty manpage.
07:19:14 <srhb> kqr: Or if you need the index, perhaps IxSet?
07:19:23 <JamesJRH> Xandaros: I've had a little play just now but didn't manage to change the behaviour.
07:19:28 <srhb> That might be a bit overkill though
07:20:26 <kqr> srhb, if I tell Set "hey, give me an element" it goes "wuh which element" and I'm like "I don't care, just throw one at me and give me a version of yourself without it" and it's like "uhh, you want the first element? are you sure? i'm gonna crash if it doesn't exist"
07:20:49 <kqr> but I think i'll implement the specific type I want with Set though
07:22:27 <JamesJRH> 15:13:35 < LeCamarade> Me, I am thinking of a 100% vector terminal.  ← I'm interested in the notion of graphical terminals and interactive environments that are not REPLs.
07:23:09 <frerich> JamesJRH: I have to ask - what kind of IRC client are you using which implements responding to people by copy & pasting the entire message, then adding a fancy Unicode left-arrow and then your message?
07:23:40 <LeCamarade> My day-to-day would interest you. I am working on very low-end point-of-sale terminals. Dot matrix displays. This one is 128*64 dots only, and I am putting a REPL on it as we speak! :-D
07:23:48 <JamesJRH> LeCamarade: This is a shining example of the style of interface that I'd like to see REPLs replaced with: http://pengines.swi-prolog.org/apps/swish/
07:24:13 <JamesJRH> frerich: Me.
07:24:27 <JamesJRH> frerich: It is nothing to do with Irssi.
07:24:31 <LeCamarade> JamesJRH: Oh, nice!
07:24:49 <JamesJRH> Well, me and X.
07:24:51 <frerich> JamesJRH: I was afraid you'd say that. =)
07:25:33 <JamesJRH> I triple-click the line and middle click when the cursor is where I want it, after typing the reply.
07:25:49 <LeCamarade> JamesJRH: See, this and the recent interface from FP Complete are a good step in the right direction. I am actually trying to code exclusively on FP Complete, but I still find it clunky because I need to use Vim when I code.
07:26:02 <JamesJRH> And I type the left arror with <Alt Gr>+y on my keyboard layout.
07:26:07 <JamesJRH> arrow*
07:26:26 <JamesJRH> frerich: Lol.
07:27:12 <JamesJRH> LeCamarade: The only trouble is that I want it to be offline/local and to be for Haskell.
07:28:18 <geekosaur> re 100% vector terminals: xterm ha a rarely used tektronix 4014 emulation
07:29:47 <domen> guys, what is preferred way to install ghc? Haskell platform or Stack?
07:29:49 <JamesJRH> LeCamarade: The Chess one is a very nice demonstration of the graphical capability of where Prolog's equivalent to Show can be used to display things more naturally: http://pengines.swi-prolog.org/apps/swish/example/queens.pl
07:30:13 <srhb> domen: I install it via NIx. Before that I installed the binary package from the ghc page. I think most people prefer Stack now.
07:30:52 <domen> there are no instructions to install Stack on Linux Mint
07:31:33 <JamesJRH> LeCamarade: Yet, the interface allows toggling displaying as text and as a graphic Chess board.
07:31:47 <LeCamarade> JamesJRH: If you are deploying with FP Complete (as I may, with my finished web app), it may make more sense to stay in the browser. My only problem is that I had no Vim, and the Firefox plugin that allowed some vimming is dead these days.
07:32:23 <Xandaros> domen: I don't see the point in stack. By all means, use it if it helps you (many people swear by it), but I personally wouldn't bother
07:32:52 <JamesJRH> LeCamarade: Browser or no browser, having locally-running code is an important freedom issue.
07:32:53 <LeCamarade> JamesJRH: how do I toggle and see the graphics on the queens code?
07:33:01 <JamesJRH> And reliability issue.
07:33:13 <domen> so what is an alternative? haskell platform?
07:33:25 <Xandaros> I just went with bare ghc and cabal, but that's just me
07:33:47 <LeCamarade> domen: On Arch, the Haskell Platform is very native.
07:33:48 <Xandaros> (Keep in mind that I'm an arch linux user. We tend to have a certain mentality)
07:33:52 <JamesJRH> LeCamarade: There's a drop-down at the top-left corner of the chess board value.
07:34:09 <LeCamarade> domen: Stack is actually very new; the platform is as stable and reliable as it is possible to be.
07:34:40 <domen> ok thank you all for you replys
07:35:04 <domen> i will need a package manager because i'll need that repa package for arrays
07:35:30 <domen> on reddit a saw a debate that stack is better than cabal
07:35:46 <LeCamarade> domen: I think you will have no problems at all going with the Haskell Platform. Myself, starting end of last year, I use only Stack. But it is probably still inferior.
07:35:46 <Xandaros> People do say that
07:36:43 <LeCamarade> Stack is ultimately better by far than anything else that is comparable; it is just not _yet_ better than some. One or two. Cabal and maybe one other (CPAN?).
07:36:45 <Xandaros> As far as I can tell, stack solves a few issues, which allows you to not sandbox everything. Which I suppose is a good thing for a new user...
07:37:09 <Xandaros> Though said issues have been fixed in GHC, cabal just needs to update accordingly (or so I've heard)
07:37:46 <JamesJRH> frerich: Btw., I find IRC difficult in that respect. Difficult to refer to specific messages. Hence why I often quote messages.
07:40:03 <Xandaros> JamesJRH: People tend to assume that you are replying to their last message in the conversation with you. If you replying to that one, no need to make your whole message unreadable ;)
07:40:35 <ahihi> I find stack very pleasant. I'm just not smart/disciplined enough to avoid cabal hell
07:40:51 * geekosaur does quote stuff sometimes but the more common conventon is to copy-paste with the nick <foo> quotehere
07:41:01 <geekosaur> and then another IRC message after with the reply
07:41:10 <geekosaur> but yes, IRC is terrible at threading conversations
07:41:28 <geekosaur> sometimes I really miss zephyr
07:41:47 <frerich> There are surely IRC clients which have some heuristics for that, so that they cna group 'related' messages?
07:42:11 <geekosaur> it's been attempted but there are no conventions so heuristics mostly fail
07:42:20 <geekosaur> or need to be tuned for every channel / community
07:42:46 <frerich> I suspect there are a few PhDs worth of research in there...
07:43:12 <geekosaur> note for comparison that all the various twitter things like @nick #hashtag .@nick-mention etc. all started out as conventions that caught on
07:43:28 <geekosaur> IRC never had anything catch on as a common convention for this
07:43:45 * frerich imagines a nice visualisation and a dynamic clustering algorithm showing how discussion threads are forked and joined.
07:44:18 <frerich> geekosaur: I guess the only thing would be '<nick>: <message>'
07:44:30 <geekosaur> right, which is too limited
07:46:57 <codedmart> I seem to be having some trouble figuring out how to represent this as a data type? https://gist.github.com/codedmart/b3cca1dd1fbde70f5bad. Filters has conditions and conditions can be nested in conditions.
07:48:48 <LeCamarade> geekosaur: The Tektronix 4041 is very under-documented, on the Web. I am surprised to learn that it is apparently an IEEE standard.
07:49:39 <LeCamarade> codedmart: Then conditions must be a recursive data type, analogous to List.
07:50:24 <LeCamarade> And that being the case, you can make List contain the Conditions.
07:50:45 <frerich> codedmart: https://gist.github.com/codedmart/b3cca1dd1fbde70f5bad#gistcomment-1677579 might be a start.
07:50:54 <LeCamarade> So that either your type is analogoes to List, or your type uses List. These are equivalent.
07:51:08 <the_2nd> I have a list of elements [a] which I want to call an IO function in sequence upon
07:51:17 <the_2nd> what's the best way of doing that?
07:51:20 <LeCamarade> frerich: +1
07:51:32 <the_2nd> just define a recursive function? Or are there built-ins?
07:51:48 <codedmart> Thanks guys
07:51:49 <LeCamarade> the_2nd: mapM putStrLn []
07:51:54 <LeCamarade> the_2nd: mapM_ putStrLn []
07:52:09 <LeCamarade> sequenceW_
07:52:11 <LeCamarade> sequenceM_
07:52:16 <JamesJRH> frerich, geekosaur: I'm not a fan of heuristics, but as for actually what would be nice to have, the sort of thing that chat.SE have is nicely done, except that it's proprietary and centralised. Even if IRC just had timestamps attached by the first server that the sending client is connected to, that would make things massively nicer.
07:52:41 <dalastboss> Is there no safe way to promise haskell that impurity in some function call is contained?
07:52:48 <frerich> JamesJRH: Yes, I think the ideas in the SE chat are quite nice. I just can't stand web chats. :-}
07:52:59 <dalastboss> like if im writing a function compile :: String -> Text
07:53:04 <JamesJRH> And would allow referrencing specific times without risk that others would have a differing timestamp due to network lag.
07:53:04 <LeCamarade> the_2nd:sequence_
07:53:25 <geekosaur> zepjyr gave every message a freeform "instance" field that could be used to group conversations
07:53:26 <srhb> dalastboss: Yes, unsafeXXX functions.
07:53:27 <the_2nd> LeCamarade, I guess mapM_ is what I need in my case
07:53:44 <dalastboss> this is considered bad practice im assuming?
07:53:53 <srhb> dalastboss: It depends.
07:53:55 <JamesJRH> frerich: Those features in an open standard protocol and a local libre software client, would be very nice.
07:54:02 <srhb> dalastboss: It's necessary for some things. :)
07:54:22 <geekosaur> dalastboss, depending on what you are asking, you may want runST
07:54:44 <dalastboss> My goal is to write a function which takes the source (as a String) for some program
07:54:52 <dalastboss> And returns the assembly
07:55:02 <dalastboss> Externally it should appear to be pure
07:55:10 <dalastboss> But maybe it uses, say, a hashtable at some point
07:55:23 <srhb> dalastboss: That doesn't even sound impure so far.
07:55:24 <geekosaur> right, so look at ST
07:55:44 <dalastboss> geekosaur: will do
07:56:03 <JamesJRH> frerich: The other main thing that SE chat has which IRC doesn't is collective scrollback – one can be sure that things that are referrenced are visible to everyone who can see the referrence, because they see all the existing scrollback even if they've just joined.
07:56:14 * hackagebot hasql 0.19.3.2 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.3.2 (NikitaVolkov)
07:56:15 <dalastboss> srhb: I don't know of a way to make a persistent hashtable that still gets O(1) expected access
07:56:18 <geekosaur> it gives you a container of sorts where you can use mutable data, which must be tagged so it can't escape; the result is pure but you get to use e.g. mutation while in runST
07:56:45 <srhb> dalastboss: Yeah, ST, as geekosaur says, if you want contained mutation :)
07:56:53 <dalastboss> awesome
07:56:55 <dalastboss> thank you
07:57:15 <JamesJRH> That's the other reason why I quote stuff – so that people who've just joined can see what I'm replying to from a while ago.
07:57:52 <JamesJRH> And I frequently get behind, so I often reply to things from a while back.
08:00:06 <geekosaur> (People often get confused by the name ST because it sounds like it's related to threads; conceptually it is related, but only in the sense of "thread local storage". I could argue that Docker is a better comparison...)
08:01:04 <Darwin226> Hey guys. I'm experiencing a weird error with GADTs and DataKinds. The code is here and the error is at the bottom http://lpaste.net/150511
08:01:30 <Darwin226> the line in question is the LoginSubmit contructor, but if I comment it out then it errors on the next one
08:02:33 <geekosaur> doesn't that need to be something like '[LoggedIn] or '['LoggedIn]?
08:02:45 <JamesJRH> 15:14:26 < LeCamarade> I am no longer into REPLs, because I am no longer into line input. I am thinking Smalltalk-80 style kind of environment. Every other _kind_ of dynamic runtime else is a hack.  ← What is that environment like? It sounds interesting. Also, note the you can have a line-input interface that isn't a Read Evaluate Print Loop.
08:03:11 <geekosaur> since the former has an obvious lexical conflict I think the former is what it uses; after all, if youve indicated the list is promoted, its contents must also be promoted
08:03:15 <JamesJRH> LeCamarade: That Swish interface is line-input but not a REPL.
08:03:32 <geekosaur> er. since the latter has...
08:03:55 <Darwin226> geekosaur: I literally get a parse error if I try to put a tick in front of a type level list that isn't empty
08:04:42 <JamesJRH> Also, this Irssi interface has the same thing that I like about the Swish interface – waiting for replies doesn't block input.
08:05:24 <JamesJRH> I have a separate input line/box in both that and this interface.
08:05:40 <JamesJRH> GHCi, however, I hate the REPL interface.
08:06:17 <JamesJRH> Because when it is in the evaluate part, I can't begin to type the next thing until it has printed.
08:06:40 <geekosaur> sounds like you want ihaskell
08:06:47 <JamesJRH> Oh?!!
08:07:09 <geekosaur> http://hackage.haskell.org/package/ihaskell
08:07:10 <Darwin226> geekosaur: It works when I write ('LoggedIn ': '[]) but not ['LoggedIn] or '['LoggedIn]
08:07:11 <JamesJRH> geekosaur: Does it have a separate input line like with Irssi?
08:07:20 <geekosaur> basically haskell for ipython/jupyter
08:08:09 <geekosaur> Darwin226, might have to do that then. I thought type level lists were smarter but our kind error suggests they aren't
08:08:28 <Darwin226> geekosaur: But the parse error surely has to be a bug in the parser, right?
08:08:49 <Darwin226> geekosaur: I mean, can you see any reason why '['LoggedIn] should fail to parse?
08:09:16 <geekosaur> quick, is '[' a Char literal at type level or part of a type levellist?
08:10:48 <geekosaur> lexing that is trickier than you think
08:11:21 <Darwin226> geekosaur: Yeah, I see what you mean. Still, it inferred the correct kind for the other type level lists
08:11:23 <geekosaur> especially if you are not to get a bizarre error if what you had was actually a typo involving a type level Char\
08:12:55 <Darwin226> geekosaur: So ['LoggedIn, 'LoggedIn] works, but ['LoggedIn] doesn't. Any reason for this?
08:13:26 <Darwin226> geekosaur: I'm guessing that it's because it tries to parse it as an [a]
08:14:55 <geekosaur> probably something like that, have to ask someone who knows the implementation better
08:16:54 <JamesJRH> geekosaur: Yes, the interface that I see here (https://try.jupyter.org/ ) under ‘Welcome to Haskell.ipynb’ is an excellent replacement for the REPL interface that I so desparately want to escape from. However, can I run this locally and offline?
08:17:19 <geekosaur> that's what that package is for
08:17:27 <Darwin226> JamesJRH: Not on Windows, but yes in general
08:17:32 <synergistics> Any vim users: What plugins do you use to make vim better for haskell?
08:17:34 <csd__> I'm trying to perform this exercise but it's conflicting with Prelude with respect to Maybe, Just, Nothing, and show... even adding `import Prelude()` to the top of my file won't work in getting rid of the ambiguous `show` definition for some reason
08:17:38 <csd__> http://mightybyte.github.io/monad-challenges/pages/ex2-1.html
08:17:46 <geekosaur> you canbuild jupyter locally and then build that iHaskell package and plug it into the local jupyter
08:17:57 <qsx> has any of you ever heard of tmux breaking ghci?  when i press return, nothing happens. when i press control-j (\n), it works
08:17:58 <JamesJRH> geekosaur: Oh, I see.
08:18:09 <qsx> when i launch ghci directly in ghci, return key works as well
08:18:21 <Clint> synergistics: no plugins, but au FileType haskell setlocal modeline expandtab
08:19:07 <JamesJRH> geekosaur: I can't find a screenshot of the offline version though.
08:21:17 <tremon> csd__: that's probably because instances are imported implicitly. You can't avoid importing them. You could try import Prelude hiding (Maybe(..)), or name your type Perhaps?
08:21:24 <synergistics> Clint: A bit confused on modelines. What do those do?
08:22:02 <JamesJRH> geekosaur: Is it basically that I run the Jupyter server locally and connect to it in my browser, rather than there being a GUI application?
08:22:04 <csd__> tremon: even then i get ambiguous usage of `show` though
08:22:58 <Clint> synergistics: introduce a security attack vector
08:23:11 <tremon> csd__: yeah, had expected that, which is why I suggested to rename your data type
08:23:18 <csd__> oh
08:23:49 <csd__> tremon: because when i decode the hex hints the page provides, they still refer to the type as Maybe et al
08:23:52 <tremon> (assuming "even then" meant "when I use import hiding", of course)
08:24:08 <geekosaur> JamesJRH, it supports multiple kinds of clients. I see a CLI interface, a GUI client written in python, and the web interface
08:24:32 <csd__> maybe i'm being too literal though
08:24:35 <tremon> csd__: the page also refers to MCPrelude, not GHC's base Prelude
08:25:03 <JamesJRH> geekosaur: NICE!
08:25:09 <csd__> yeah i know; i'm importing MCPrelude as my only import and running in ghci
08:25:14 <JamesJRH> Gimme gimme gimme!…
08:25:29 <csd__> tremon: not much to MCPrelude https://github.com/mightybyte/monad-challenges/blob/gh-pages/src/MCPrelude.hs
08:25:40 <JamesJRH> (I'm currently looking for the NixOS package attributes…)
08:26:05 <JamesJRH> haskellPackages.ihaskell is the iHaskell bit.
08:26:19 <tremon> csd__: ah, ok. I haven't seen it before, I was expecting it to have its own interpreter somewhere. Not sure how they intend it to work with regular ghci
08:27:01 <JamesJRH> Can't find Jupyter.
08:27:09 <csd__> hrm ok thanks
08:27:23 <SomeT> I need some help I written the following code: http://hastebin.com/ikayiwekeh.hs trying to run it in WinGhci with no luck, it comes up with error when running in main modules: <interactive>:23:1: Not in scope: ‘Chapter2.hs’
08:29:17 <tremon> csd__: the introductory page (http://mightybyte.github.io/monad-challenges/) doesn't mention ghci at all, seems like they expect each challenge to be compiled only
08:34:45 <m1dnight_> Im trying to use the 'cloneLens" thing here to be able to use it multiple times but I really cant figure out for the life of me how to do it.
08:34:48 <m1dnight_> Can I get some pointers?
08:35:37 <m1dnight_> https://www.refheap.com/113964
08:35:53 <m1dnight_> This is what I have been trying. I have based myself on this post: http://stackoverflow.com/questions/20626963/haskell-lenses-getters-and-setters
08:45:03 <codedmart> Trying different data types. How can I do something like this: https://gist.github.com/codedmart/9f36412b683f5b76cad9#file-types-hs-L3
08:46:04 <codedmart> Basically I want the conditions attr of the Filters data type to be a List of either Condition or Filters. So it could have both. 
08:46:29 <ggole> [Either Condition Filters]
08:46:44 <domen> yeah, use either
08:47:46 <domen> that's what Either is for - to form disjoint union of types
08:48:11 <mnoonan> or more generally, define a data type to wrap the possibilities: "data Stuff = C Condition | F Filter | A AnotherPossibility"
08:48:20 <mnoonan> then do [Stuff]
08:49:39 <codedmart> mnoonan I tried that, but ran into issues. So it could be [C condition, F filters] <- kinda like that?
08:50:32 <mnoonan> no, do "data MyWrapper = C Condition | F Filters", then give your conditions field the type [MyWrapper]
08:50:50 <mnoonan> (but I agree to use Either if you really just want two options)
08:56:16 * hackagebot generics-eot 0.2 - A library for generic programming that aims to be easy to understand  https://hackage.haskell.org/package/generics-eot-0.2 (SoenkeHahn)
09:12:23 <JamesJRH> puregreen: I have this: Control.Monad.forever $ ((=<< System.IO.isEOF) . flip unless) (putStrLn =<< getLine)
09:12:41 <JamesJRH> But I think that Control.Monad.forever isn't quite right.
09:14:20 <JamesJRH> That line handles the EOF, now, avoiding the exception, but aways starts again due to the forever.
09:14:35 <geekosaur> yep. forever does what it says on the tin
09:15:04 <geekosaur> you'd have to use System.Exit.exitSuccess or throw an exception to get out
09:15:20 <SrPx> I have added `reflex-dom-0.2` to my extra-deps, but stack still can't find the library. Why?
09:16:00 <SrPx> Does it have something to do with the fact it is for GHCJS and I'm using GHC? I want to have only a single .stack/.cabal file for this project, not split into a GHCJS and a GHC directory
09:16:13 <JamesJRH> Ah, that should actually be: Control.Monad.forever $ ((=<< System.IO.isEOF) . flip Control.Monad.unless) (putStrLn =<< getLine)
09:16:25 <geekosaur> still.
09:16:33 <SrPx> maybe a conditional inside `.cabal` that only included a lib if compiler was GHCJS?
09:16:43 <JamesJRH> I had Control.Monad imported and forgot that unless was only from it.
09:16:53 <johnw> JamesJRH: do-notation would make that expression infinitely more readable
09:16:54 <geekosaur> http://hackage.haskell.org/package/monad-loops
09:17:41 <geekosaur> untilM may be what you're looking for, in particular
09:18:02 <johnw> or even just: Control.Monad.forever $ System.IO.isEOF >>= \eof -> Control.Monad.unless eof $ getLine >>= putStrLn
09:18:04 <JamesJRH> johnw: So would defining functions. ‘(=<< System.IO.isEOF) . flip Control.Monad.unless’ would be better-off as a single name.
09:20:02 <JamesJRH> 17:17:19 < geekosaur> untilM may be what you're looking for, in particular  ← Ah, yes, I was about to ask whether there was an until-like replacement for the forever.
09:22:52 <HairyDude> Is there a cabal-install command to generate only the Paths module?
09:23:03 <HairyDude> I mean, do nothing except generate it
09:23:24 <HairyDude> for use while developing
09:25:51 <JamesJRH> geekosaur: Probably untilM_.
09:26:06 <JamesJRH> http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:untilM_
09:26:20 * hackagebot elm-bridge 0.2.1.0 - Derive Elm types from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.2.1.0 (AlexanderThiemann)
09:30:18 <codedmart> domen mnoonan OK so either compiles fine but when I toJSON it includes the Left's and Right's? Do I need to write manual (To/From)JSON instances to handle that?
09:32:57 <mnoonan> codedmart: if you are generating and reading the json, just stick with the what the default implementation gives you (Lefts and Rights etc)
09:33:52 <mnoonan> codedmart: if you need to interact with somebody who isn't expecting that, then maybe try using your own datatype and To/FromJSON instances
09:35:10 <codedmart> mnoonan I only need to generate and I need to remove them so I will do my own instances. Thanks!
09:35:24 <mnoonan> sure, no problem
09:36:33 * hackagebot wai-middleware-content-type 0.3.0 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.3.0 (athanclark)
09:45:08 <JamesJRH> This is what I come-up with but I'm out-of-space to install haskellPackages.monadLoops right now, so currently untested: flip Control.Monad.Loops.untilM_ System.IO.isEOF $ putStrLn =<< getLine
09:45:50 <JamesJRH> And with the line-by-line setting (also untested): let (<<) = flip (>>) in (flip Control.Monad.Loops.untilM_ System.IO.isEOF $ putStrLn =<< getLine) << System.IO.hSetBuffering System.IO.stdin System.IO.LineBuffering
09:46:20 <geekosaur> there comes a point where pointfree = incomprehensible and unmaintainable...
09:56:08 <biglama> hi guys, when reading a CSv with cassava, is it possible to avoid writing the datatype ?
09:56:19 <biglama> in other terms, can Haskell deduce a datatype from the CSV ?
09:56:43 <tommd> No.  That would require the type to depend on the value.
09:57:51 <biglama> okay, so it can be painful when reading a CSV with 15 columns for example
10:00:06 <geekosaur> one could imagine a script to read a CSV and output a data type for you. or maybe TH, but arguably if you don't know the type beforehand you're going to have trouble doing much sensible with it
10:00:11 <sleblanc> biglama, hazarding a guess, you could wrap all the types in a generic interface, since in a sense they are all String -> something
10:01:54 <biglama> geekosaur: yeah, at the moment, I only use a Vector of Vector and then use indices to work on the data
10:02:30 <biglama> sleblanc: I'm not sure how to do that. Could you write a small example (if possible) ?
10:03:12 <JamesJRH> I cannot proceed until I sort-out my space problem by offloading some stuff onto another drive and seeing about reärranging my partitions to accomodate for my Nix store gradually consuming more gigabytes as I install and update stuff, even after garbage collecting. It's now using about 24GiB of my 128GiB SSD. :-/ So I'll come back later or tomorrow.
10:03:35 <JamesJRH> Bye for now. \o
10:03:57 <sleblanc> biglama, I can't, sorry. What I really mean is if you can't encode the types, maybe you don't need them; if it fits your purpose, you could treat them all as plain strings instead and convert them (deserialize) later
10:04:58 <biglama> sleblanc: at the moment, i'm working on a vector of vector of bytestring
10:05:08 <biglama> sleblanc: is it the same thing you are saying ?
10:05:26 <sleblanc> biglama, yes
10:06:57 <biglama> ideally, something resembling pandas would be nice :)
10:07:03 <JamesJRH> (Btw., I'm to be known as *JRHaigh* soon.)
10:08:13 <JamesJRH> That was just a temporary Freenode Webchat.
10:08:39 <JamesJRH> Identified as me.
10:10:32 <sleblanc> biglama, maybe this could be helpful: Data.Dynamic (https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Dynamic.html)
10:14:00 <ReinH> biglama: take a look at the frames library
10:14:00 <domen> has anyone ever tried to do an extension to repa library similar to numpy?
10:14:11 <ReinH> biglama: https://hackage.haskell.org/package/Frames
10:14:41 <ReinH> "The type of each row of data is inferred from data, which can then be streamed from disk, or worked with in memory.
10:14:43 <ReinH> "
10:24:24 <SrPx> I have a Haskell library that can be compiled with both GHC and GHCJS. One of the exposed modules doesn't work with GHC - it depends on reflex-dom, which depends on gtk, which isn't installed on my machine.
10:24:44 <SrPx> How can I have a conditional on `.cabal` so that, if the used compiler is GHC, then it doesn't include that module?
10:25:39 <bergmark> if impl(ghcjs) exposed-modules: Foo
10:33:49 <ReinH> SrPx: look at the way reflex-dom doe sit
10:33:55 <ReinH> *does it
10:35:05 <SrPx> Oh, I see now. I'm so glad that exists, thanks.
10:42:39 <dfeuer> My GHC/cabal installation is old (GHC 7.8) and needs to be replaced. But I don't remember how to set anything up.
10:45:09 <ReinH> dfeuer: stack?
10:45:36 <dfeuer> ReinH, I still haven't figured out how that goes exactly. I've used it, but I don't understand it.
10:45:51 <Cale> dfeuer: One possible answer to that is just to use stack, apparently. Otherwise, I would usually recommend getting the appropriate binary package from the GHC website, and then grabbing a tarball of cabal-install from Hackage
10:46:33 <Cale> http://docs.haskellstack.org/en/stable/README.html has instructions on installing stack
10:47:05 <Cale> (stack will install ghc for you if you need it)
10:47:20 <dfeuer> Cale, I'm happy to try the stack route. I just have to figure out how it all goes. And whether it's going to be too annoying when I'm not working on a proper project.
10:47:25 <sm> "stack setup" will install a ghc 7.10.3 that stack can see - you probably have to add symlinks to your usual PATH to use it apart from stack
10:48:35 <kadoban> dfeuer: It has the ability to work outside of an actual project quite well, but you have to learn a couple of extra commands.
10:49:08 <dfeuer> Ah.
10:49:17 <dfeuer> kadoban, where do I find those?
10:49:18 <cocreature> there is stack ghci and stack ghc
10:49:35 <dfeuer> How can I run stack ghci *on a source file*?
10:49:40 <dfeuer> stack ghci Foo      doesn't work.
10:49:49 <cocreature> try stack ghci -- Foo
10:49:54 <OverCoder> hm okay so I was playing with 'main = do' with I/O
10:50:23 <OverCoder> um, so do automatically loops over and over?
10:50:40 <ahihi> it does not
10:50:52 <OverCoder> I know it's meant to be for I/O operations, but I noticed my application is looping
10:50:58 <OverCoder> ah wait omg
10:51:02 <OverCoder> I am using 'forever'
10:51:05 * OverCoder slaps himself
10:51:07 <dfeuer> BBL
10:51:07 <ahihi> :)
10:56:11 <Sonolin> after almost 6 months of haskell I'm finally starting to understand xmonad stackset
10:56:14 <Sonolin> :D
10:56:48 <SrPx> way to automatically add missing dependencies to the cabal file?
10:56:51 <SrPx> is there any *
10:57:29 <Dr4ke63> Hello
10:57:44 <breadmonster> Hello.
10:57:50 <breadmonster> When is ghc 8.0 coming out?
10:58:38 <Dr4ke63> I don't know. Sorry.
11:00:06 <Dr4ke63> Hello Zekka.
11:00:07 <Cale> breadmonster: There's a release candidate already
11:00:18 <breadmonster> Cale: That's not the same thing :(
11:00:40 <Dr4ke63> @Breadmonster That's waiting then :P
11:00:40 <lambdabot> Unknown command, try @list
11:01:03 <Dr4ke63> @list
11:01:03 <lambdabot> What module?  Try @listmodules for some ideas.
11:01:04 <Cale> breadmonster: If you scroll down here, you can see what the open issues are on RC1 https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1
11:01:31 <`Guest00000> hello
11:01:34 <Dr4ke63> Wow Skype is doing the update of the year lol
11:01:37 <johnw> SrPx: yeah, there's a hacky way
11:01:46 <`Guest00000> i have class C t where type family F t :: *
11:01:51 <johnw> SrPx: hack #1: move the .cabal file, and use cabal init to make a new one. copy it's dependencies over
11:02:01 <johnw> actually, that's the only one I know
11:02:07 <SrPx> lol
11:02:17 <SrPx> well, okay... thanks 
11:02:22 <`Guest00000> how do i require that for any t, if F t is defined, then it is instance of class D ?
11:02:46 <sm> johnw: I like that :)
11:03:57 <Dr4ke63> How does the new update of Skype work?
11:04:33 <breadmonster> Has anyone written low latency stuff in Haskell before?
11:04:48 <breadmonster> Any talks or books or otherwise crowdsourced wisdom?
11:05:09 <monochrom> class D (F t) => C t where type F t :: *
11:05:15 <monochrom> requires FlexibleContexts
11:06:08 <andromeda-galaxy> monochrom: halfway through typing that...
11:06:14 <johnw> `Guest00000: you could use "class Num a => F a", but I not sure how you test for "if it's defined"
11:06:40 <monochrom> do not test. insist. which is what I did
11:06:56 <johnw> although, a function with constraint F t => will only accept t's which are Nums, so maybe that's the test
11:07:05 <`Guest00000> monochrom: oh, right, thank you.
11:07:38 <johnw> monochrom: ah, thanks
11:07:48 <`Guest00000> johnw: really? would defining a new class with same name as type family would work that way?
11:08:08 <johnw> `Guest00000: don't trust my untested suggestion until you've tried it
11:08:13 <andromeda-galaxy> `Guest00000: see monochrom's solution, I'm pretty sure that does what you want
11:08:16 <biglama> sleblanc: thanks for the link
11:08:30 <Dr4ke63> Cya everybody!
11:08:32 <biglama> ReinH: frames looks much more into what I need, will look into it
11:08:34 <biglama> ReinH: thanks
11:16:49 <yyyyy> is pattern matching against the product of some configuration types an OK approach to choose some context-dependent function to evaluate?
11:17:18 <yyyyy> I'm choosing handlers for a route based on multiple parameters and that's how I solved the problem, but it looks hacky: http://lpaste.net/150517
11:17:44 <yyyyy> (the real service has error handling, this is for explanatory purposes)
11:19:41 <monochrom> it is ok.
11:21:36 * hackagebot niagra 0.2.1 - CSS EDSL for Haskell  https://hackage.haskell.org/package/niagra-0.2.1 (natesymer)
11:21:38 * hackagebot stack-run 0.1.0.5 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.0.5 (yamadapc)
11:22:20 <yyyyy> monochrom: thanks :) is there a better way, though?
11:22:25 <ski> yyyyy : i think you don't need the brackets to the left of `<-' in the calls to `param'
11:22:52 <monochrom> no, unless fAX, fBX, fAY etc are unifyable
11:24:18 <mnoonan> yyyyy: What about adding a layer of (predicate, handler) pairs and dispatching to the first handler whose predicate matches the configuration?
11:24:24 <yyyyy> ski: you mean i could do `a :: T <- f`? i guess you're right, but the syntax highlight in the editor i'm using gets lost when that happens. it's mildly annoying, so i'm leaving it.
11:24:45 <ski> if you want to be able to dynamically change which combinations maps to which action, then perhaps you could use an array (or map or something). otherwise i dunno
11:27:36 <yyyyy> mnoonan: wouldn't that be larger? i can see this being better if i have conditions for which a simple pattern match wouldn't be enough, but otherwise overkill?
11:29:17 <yyyyy> monochrom: in this case you'd merge the matches? (when the right-hand side is unifiable)
11:30:14 <monochrom> that depends on what kind of unification I can get
11:31:58 <yyyyy> monochrom: can you point to some literature or examples? seems interesting.
11:32:29 <yyyyy> ski: true. that might be a good option in the future. :)
11:32:32 <tromp_> off topic: the number of legal Go positions has been computed; http://tromp.github.io/go/legal.html
11:32:42 <mnoonan> tromp_: !
11:32:59 <tromp_> and it was done using Haskell !!!!
11:33:09 <monochrom> I only have Kolmogorov complexity in mind.
11:33:11 <tromp_> well, not the main computation, just the Chinese remaindering:(
11:33:25 <Cale> tromp_: whoooooa
11:33:57 <Cale> tromp_: That's something I'd never really expected to see done.
11:34:20 <tromp_> see the top program at https://github.com/tromp/golegal
11:34:43 <scshunt> that's awesome!
11:38:08 <monochrom> Cale: and apparently, moreover, done by someone in the same IRC channel you go to :)
11:40:09 <tromp_> also made it to the Hacker News front page https://news.ycombinator.com/
11:42:35 <tromp_> Cale: back in 2005, after doing 16x16 I predicted it would take about 10 years to get to 19x19
11:42:45 <Cale> haha, good prediction :)
11:43:07 <tromp_> yes, the computation actually finished late last year
11:45:24 <sleblanc> tromp_, how long does it take to run it?
11:47:14 <Cale> "For running an L19 job, a beefy server with 15TB of fast scratch diskspace, 8 to 16 cores, and 192GB of RAM, is recommended. Expect a few months of running time."
11:54:26 <csd__> I have a nested case expression where one function returns a Maybe a, and then a successive function takes an Integer. How can I tell type hint to ghc that I only ever expect `a` to be Integer?
11:54:28 <sm> tromp: really impressive :)
11:55:12 <sm> a 2x2 Go board allows "hundreds of billions" games ? how on earth.. ?
11:55:18 <ski> csd__ : please show the code (or a relevant simplification of it) in question
11:55:20 <ski> @paste
11:55:21 <lambdabot> Haskell pastebin: http://lpaste.net/
11:55:31 <t0by> go is weird
11:56:09 * geekosaur remmebers lookig at go once and deciding chess was way easier
11:56:13 <csd__> ski: http://lpaste.net/9203533814842785792
11:56:54 <csd__> ski: part of a solution to http://mightybyte.github.io/monad-challenges/pages/ex2-3.html
11:57:07 <geekosaur> that code looks like it should be able to infer an appropriate type?
11:57:12 <sm> still. How can a 2x2 board - that's 4 positions - allow 386356909593 games ??
11:57:27 <johnw> headMay a :: Maybe Int
11:57:49 <csd__> geekosaur: here are my compiler errors http://lpaste.net/9099900875375116288
11:57:56 <ski> csd__ : how is `GreekData' defined ?
11:58:18 <csd__> type GreekData = [(String, [Integer])]
11:58:22 <geekosaur> hmmmmmm
11:58:33 <csd__> the other type signatures are here http://mightybyte.github.io/monad-challenges/pages/ex2-2.html
11:58:36 <geekosaur> are lines 51 and 52 indented enough?
11:58:47 <scaroo_> hi. I am looking for a lib parsing socalled FDO Desktop entries (the .desktop files used by gnome, kde and co storing invocation and metadata info about an application). So far, I cant find anything in hackage. Do any of you know about it?
11:59:22 <geekosaur> or is this doing something silly like making line 50 an empty case and folding 51 and 52 into the outer one, giving you fromIntegral on a Integral n => Maybe n  
11:59:47 <geekosaur> (enable compiler warnings and consider renaming that second 'a')
11:59:50 <ski> csd__ : `fromIntegral a' should be `Just (fromIntegral a)', probably
12:00:16 <ski> csd__ : you're missing the `in'-part of that `let'. i'm assuming it's something like `in n'
12:00:28 <csd__> yeah sorry that was an excerption
12:00:54 <csd__> trying also to respect the problem author's wishes not to publish a solution *shrug*
12:04:01 <csd__> geekosaur: as i see it, the problem is that ghc expects headMay to throw off a Maybe a, and my code assumes it to be Maybe Integer
12:04:15 <ski> csd__ : assuming the missing part is `in n', you're returning `n', which is declared to have type `Maybe Double'. the first two branches of the `case'(s) return `Nothing', which can have this type. the last branch had `fromIntegral a', which expects to return some element of a numeric type (a type that is a member of the type class `Num'). therefore the error is complaining about not finding `Num (Maybe a0)'
12:04:42 <ski> csd__ : and the cause of that, in this case, is forgetting to convert from `Double' to `Maybe Double' with `Just'
12:04:42 <x_pilot> hey does anyone know why the Const datatype defined in Control.Applicative isn't polykinded?
12:04:50 <geekosaur> csd__, "No instance for (Num (Maybe a0))" means you called fromIntegral on some Maybe x instead of an x
12:05:06 <ski> csd__ : `headMay' isn't really related to the problem here
12:05:08 <geekosaur> so it is looking for a Num instance that covers Maybe
12:05:12 <x_pilot> newtype Const a b = Const a should be polykinded in b
12:05:38 <ski> @type fromIntegral
12:05:40 <lambdabot> (Integral a, Num b) => a -> b
12:05:53 <geekosaur> oh, result, not parameter
12:05:56 <geekosaur> ok
12:06:12 <geekosaur> same thing in reverse then
12:06:25 <geekosaur> you are producing a number where a Maye number is wanted
12:06:43 <geekosaur> so it's looking for a Num instance that is shaped like Maybe something
12:07:05 <csd__> hrm
12:07:14 <csd__> i wonder whether i have a scoping issue in my case statements
12:07:21 <geekosaur> line 49 produces a Maybe something
12:07:34 <geekosaur> line 52 produces the result of fromInteger, without a Just
12:07:45 <geekosaur> so fromInteger must be producing a Num n => Maybe n
12:08:03 <ski> it's good to remember that you need to explicitly convert between `X' and `Maybe X'. `Maybe X' isn't (exactly) "like `X', but with a `null'/`NULL'-value added to it". the `X'-values are wrapped (so that you can also have `Maybe (Maybe X)' with `Nothing' and `Just Nothing' as distinct values)
12:08:19 <geekosaur> as ghc sees it. more practically it means you forgot to wrap the reuslt in Just
12:08:25 <csd__> geekosaur: i think i see the problem
12:08:40 <ski> csd__ : i see no scoping issue in the pasted snippet
12:09:06 <csd__> here's the full fn http://lpaste.net/4636258831997861888
12:09:07 <geekosaur> rright, I tossed the scoping thing out early, was split attention
12:09:10 <csd__> i think the problem is line 60
12:09:18 <ski> csd__ : you have shadowing (of `a'), which might perhaps be considered confusing for a human reader, but is no scoping problem per se
12:09:24 <csd__> expects Ints and receives Ints and Nothings
12:09:31 <geekosaur> anyway if line 49 produces Nothing then line 52 should be producing Just (fromIntegral ...)
12:09:57 <geekosaur> andbecause it doesnt ghc thhinks fromIntegral must be capable of producing Nothing or Just something
12:10:11 <geekosaur> thus the weird Num instance
12:10:28 <ski> csd__ : `divMay n d' won't work, it can accept `Double's, but not `Maybe Double's as inputs
12:10:37 <csd__> yeah
12:10:45 <csd__> writing functions this way is a PITA :-/
12:11:09 <ski> csd__ : using `case' on `xs' twice is dedundant there
12:11:10 <geekosaur> this looks like a case for the Monad instance of Maybe
12:11:32 <geekosaur> let >>= handle shortcircuiting the Nothings for you
12:11:33 <csd__> geekosaur: this is part of a series of exercises
12:11:37 <csd__> working to that
12:11:48 <ski> geekosaur : .. i suspect that is the end goal of this exerice :)
12:11:54 <geekosaur> probably
12:12:09 <geekosaur> so you'll have to do it the long ugly way and hope you reach the end of the series soon :)
12:12:29 <ski> csd__ : anyway, if you really wanted, you could do another `case' (on `n' and `d') after the `in' .. but that's bothersome
12:12:59 <ski> csd__ : to avoid some of the bother, i'd just not define `n' and `d' at all inside the `let', and head straight to this `case' instead
12:13:44 <csd__> to which case?
12:13:59 <monochrom> pig latin: oodgay orningmay. pig haskell: headMay divMay
12:14:09 <ski> starting with `case xs of' as before (but only once, not twice or more times)
12:14:47 <ski> (personally i'd also refrain from naming `xs' at all. but that's more about style)
12:15:32 <csd__> so id be defining the let bindings inside the case stmt?
12:16:04 <ski> csd__ : more or less, the best you can get here, without doing something more "clever", is to have a *single* nested `case'-"chain" (in your paste, you had one for `n' and another separate one for `d')
12:16:32 <ski> csd__ : you could possibly have some `let's inside the `case'-*expression*, yes, if you feel like it
12:16:34 <monochrom> theorem: suppose you define a non-recursive thing and then use it only once. then you can legally inline it and have no definition to begin with.
12:16:44 <csd__> well since n and d require seperate steps to compute i didnt see how i could put them in the same chain without something that seemed like too much effort
12:17:28 <csd__> oh wait i guess i could if you can access the scope outside the immediate statement
12:17:36 <csd__> i'm still not totally clear on the scope rules
12:18:14 <ski> csd__ : well, the issue as i see it there isn't so much effort, but ugliness (iow, you have to nest one inside the other, which means you have to make an arbitrary decision of which should be outer and which should be inner, which is the ugly part)
12:19:36 <ski> csd__ : if you have `let xs = ... in ...', then `xs' is in scope everywhere in the (possibly complicated) expression `...' (the latter one). in fact, because `let'-bindings are recursive, `xs' would also be in scope in the former `...', but that's not really useful in your case
12:20:20 <ski> csd__ : if you have `case xs of Nothing -> ...; Just a -> ...', then `a' is in scope everywhere inside the latter `...' subexpression
12:22:17 <ski> csd__ : when i say "everywhere", i really mean : unless "shadowed" by an "inner binding" with the same name. iow in `case xs of Nothing -> ...; Just a -> (case headMay a of Nothing -> ...; Just a -> ...)', then any `a' in the last `...' refers to the *nearest* binding of `a'
12:23:01 <ski> csd__ : there are two distinct variables named `a' here. one bound by the `Just a' pattern in the outer `case' (on `xs'), and another bound by the `Just a' pattern in the inner `case' (on `headMay a')
12:23:05 <ski> csd__ : does this help ?
12:23:08 <csd__> and yet, IIRC, you can't shadow functions; i think that's why i was confused
12:23:12 <csd__> yes thank you
12:23:42 <ski> "you can't shadow functions" suggests a misunderstanding
12:23:56 <ski> functions are values, just like lists, pairs, numbers, &c.
12:24:15 <ski> sometimes you're referring to values via names/variables
12:24:20 <monochrom> > let {f x = x+x} in let {f _ = ()} in f 5
12:24:22 <lambdabot>  ()
12:24:25 <monochrom> shadowed
12:24:28 <ski> `headMay' is a variable as much as `a' is a variable
12:25:56 <ski> in monochrom's example, there's two distinct variables, which both happens to be spelled `f', and the values they refer to both happen to be functions
12:26:49 <ski> csd__ : ok ?
12:27:10 <csd__> i was thinking of shadowing imports but yes point made and very helpful, thanks
12:27:44 <monochrom> I have never seen shadowing imports. can you demo it?
12:28:28 <csd__> well thats what i mean, i didnt think you could => why i was confused about how shadowing works in general
12:28:42 <monochrom> I see
12:29:40 <obadz> Anyone understand how System.FSNotify.watchTree is implemented? I'm particularly interested in the performance on a very large and deep directory tree (though with relatively few changes) and also guarantees: if a new directory gets created and an events happens inside it right after, is there a race situation were it would get missed by System.FSNotify?
12:29:45 <ski> csd__ : .. anyway, i suspect that you will not need any "inner" `let' here
12:35:55 <Cale> sm: Capture removes pieces from the board, and you basically end up exhausting a good portion of the space of 57 possible states, perhaps twice over depending on what your rules are.
12:36:12 <athan> What's your favorite library for calling other shell functions?
12:36:27 <athan> Other than process :v
12:36:47 <Cale> sm: at that size, games basically become trying to force your opponent into a position where they have no legal moves because they'd have to repeat a previous board position.
12:37:21 <Cale> (or you get 2 stones diagonally and insta-win, but your opponent usually won't let you do that)
12:37:47 <Cale> athan: process
12:37:48 <Cale> lol
12:37:52 <athan> :(
12:38:06 <Cale> What's wrong with process?
12:38:25 <monochrom> I like process.
12:38:34 <tobiasBora> Hello,
12:38:44 <tobiasBora> In this page (and many others) : http://hackage.haskell.org/package/alsa-seq-0.6.0.5/docs/Sound-ALSA-Sequencer.html#t:T
12:38:54 <tobiasBora> I cannot understand the meaning of "data T mode".
12:38:56 <tobiasBora> Who is mode ?
12:39:05 <athan> I don't know, I just don't like to have to depend on a PATH environment variable
12:39:11 <athan> I think I'm just thinking about this wrong
12:39:17 <athan> thanks :)
12:39:19 <Welkin> god
12:39:26 <Welkin> I wasted so many hours trying to update xcode
12:39:30 <tobiasBora> Same thing with : get :: T mode -> T -> IO T
12:39:31 <Welkin> I even called customer support
12:39:42 <athan> tobiasBora: mode is probably a variable
12:39:44 <athan> a type variable
12:39:49 <monochrom> tobiasBora: I don't know ALSA. but when you see "data Maybe a" the "a" is a type variable. same for "data Maybe mode".
12:39:51 <athan> Welkin: just use gentoo
12:39:57 <athan> or linux from scratch
12:40:04 <Welkin> lol athan 
12:40:16 <Welkin> I only need it for a work project to submit an ios app
12:40:21 <Welkin> otherwise I wouldn't touch it
12:40:59 <tobiasBora> monochrom: And I cannot have any information on the waited type of "mode" ?
12:41:02 <Cale> tobiasBora: It looks like many things expect it to be an instance of OpenMode, which means that it'll be one of DuplexMode, InputMode, or OutputMode
12:41:19 <ski> tobiasBora : try `:kind T' in the interactor ?
12:41:59 <`Guest00000> is it possible to write a program which can be extended by writing other modules in haskell which define new typeclass instances and let main program use them by loading modules dynamically?
12:42:23 <Cale> tobiasBora: Also, I'm so sorry that you're using a Henning Thielemann library which calls everything T, making the documentation almost impossible to read
12:43:03 <tobiasBora> ski: It doesn't help me here : :kind Sound.ALSA.Sequencer.T
12:43:04 <tobiasBora> Sound.ALSA.Sequencer.T :: * -> *
12:43:06 <geekosaur> tobiasBora, `open` in that module actually tells you how they're liinked
12:43:18 <geekosaur> mode is an instance of OpenMode
12:43:22 <monochrom> https://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo
12:43:56 <Welkin> is that like　カバカバカバカバカバカバカバ？
12:44:03 <monochrom> probably
12:44:27 <Welkin> oh lol
12:44:29 <tobiasBora> Why it couldn't be one of Output mode ?
12:44:31 <geekosaur> the instances ofOpenMode are OutputMode, InputMode, and DuplexMode
12:44:36 <Welkin> no, it is more like the chinese poem of the lion in the stone den
12:44:42 <Welkin> shi shi shi shi shi shi shi shi shi
12:44:49 <Welkin> all different words with different tones
12:44:52 <Welkin> but all still shi
12:44:55 <SavinaRoja> in what sense are abstract data types and algebraic data types opposites? https://wiki.haskell.org/Algebraic_data_type
12:45:01 <sleblanc> Welkin, yup, not bakabaka…
12:45:36 <geekosaur> it is encoding the read/write permission of the handle in its type
12:46:07 <ski> SavinaRoja : in no sense at all, i'd say. however one is abstract and the other is concrete ..
12:46:18 <monochrom> perhaps they are not opposites. an algebraic data type can implement an abstract data type, too.
12:46:53 <monochrom> what is "opposite"?
12:46:54 <tobiasBora> geekosaur: Oh I think I got it... Thank you !
12:47:01 <Cale> SavinaRoja: ... maybe not exactly opposites? But algebraic data types place an emphasis on how values are to be constructed (and deconstruction goes by pattern matching on the way that things were built up), while abstract data types place an emphasis on how values are to be used.
12:48:07 <SavinaRoja> thanks for the perspectives
12:48:21 * ski would say record types (which would also be concrete) place an emphasis on how values are to be used/deconstructed
12:48:44 <SavinaRoja> I was definitely a bit confused by that statement, since algebraic data types and abstract data types seem to overlap
12:49:01 <Cale> Yeah, records of functions especially can do a good job of modelling object types.
12:49:15 <ski> which abstract data types is about not specifying a concrete implementation at all of the type, only specifying an interface of operations, some of which could be considered to be "constructions" or "deconstructions", or indeed both
12:49:33 <ski> s/which abstract/while abstract/
12:50:14 <Cale> ski: Yeah
12:50:54 <aweinstock> SavinaRoja: http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf "On understanding data abstraction, revisited" goes into detail about the differences
12:51:36 <ski> one common use of abstract data types is to simulate subtypes, or quotient/factor types (or both at the same time)
12:51:45 <`Guest00000> equivalently, i want to be able to write external haskell code with existential types
12:51:47 <ski> aweinstock : hehe, i was thinking about that paper
12:52:04 <aweinstock> wait, that's between abstract data types and objects, not {algebraic,abstract} data types
12:52:25 <SavinaRoja> aweinstock: looks like something I should read regardless
12:52:30 <geekosaur> tobiasBora, this is one case where I think if DataKinds had existed when the library was written, it'd be clearer --- instead of that unidentified "mode" it could have (mode :: OpenMode)
12:53:13 <geekosaur> and it'd be easier to figure out that it means, for example the open modes and not the blocking mode
12:53:18 <`Guest00000> data X = MyClass t => X t, i want to be able to write functions which take and/or return values of type X, export them in dynamic library, and use them in another program. would that work?
12:53:36 <ski> SavinaRoja : if you haven't yet, perhaps you should first read (or at least skim) it's "prequel" : "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
12:53:54 <monochrom> once upon a time, there was an ARM chip. its hardware interface and programmer model were well-document. it was sold at a good price. a lot of makers swore by it for hacklab projects. it was the hallmark of freedom and openness.
12:55:34 <acertain> does anyone have ideas what typesystem features would be needed to allow `withDict :: DictOf c -> (c => r) -> r` (where DictOf is essentially a compiler-generated data family), but forbid `\x -> withDict x Dict :: DictOf c -> Dict c`?
12:55:43 <aweinstock> it looks like "on understanding data abstraction, revisited" calls a combination of (algebraic data types + ML modules) abstract data types, and objects are defined in terms of (fix (\this -> {- record of functions -}))
12:55:46 <SavinaRoja> ski: will do
12:56:03 <monochrom> then one day, Apple noticed that nice chip and decided to use it. wrapped and encapsulated it under a lot of layers, the whole final product known as the iPhone. it was the hallmark of proprietory and closedness and walled garden.
12:56:21 <acertain> where `data Dict (c :: Constraint) where Dict :: c => Dict c`
12:57:10 <monochrom> the concept of "opposite" is very powerful. (not the predictive power kind.) you can take the same thing and add some packaging, and suddenly it becomes "the opposite".
12:58:09 <geekosaur> ...and that's ignoring the whole part where Intel got a legal hold of ARM specs by buying the remains of DEC's intellectual property, and then tried to find ways to "steal" ownership of ARM from the corporation created to protect them and keep them open
12:59:18 <geekosaur> (majority owned by the British government so it would have a computer chip guaranteed not to be controlled by a single hardware vendor)
12:59:32 <tobiasBora> geekosaur: I see...
12:59:51 <tobiasBora> Does anyone knows enough the alsa-seq lib to know how I could change/get the instrument ?
13:00:36 <tobiasBora> I saw the MidiVoices in Port.Info, but I can't find a fonction that takes a port and gives me the info...
13:01:39 <geekosaur> wait, a Henning library where the classes have useful names?!
13:01:53 * hackagebot imagemagick 0.0.4.1 - bindings to imagemagick library  https://hackage.haskell.org/package/imagemagick-0.0.4.1 (AlexanderVershilov)
13:02:10 <monochrom> :)
13:02:43 <geekosaur> tobiasBora, did you see http://hackage.haskell.org/package/alsa-seq-0.6.0.5/src/examples/list-ports.hs ? (unpack the source distribution and look in examples/)
13:02:55 <geekosaur> other examples also in there
13:03:00 <tobiasBora> geekosaur: All of you seems to like Henning's way of coding ^^
13:03:19 <geekosaur> tobiasBora, that type named T is kinda his signature
13:03:39 <monochrom> no, most of us are against his way
13:03:43 <geekosaur> every type is T, every class is usually C, and you're supposed to import thisg fully qualified and use the qualified name to distinguish
13:04:05 <tobiasBora> geekosaur: Yes, that's how I found how to play a simple melody. But I can't find an example that change the instrument.
13:04:25 <geekosaur> which, among other thigs, means the API docs are impenetrable because every type is T and you have to hover over it to see *which* T from the link
13:04:26 <geekosaur> x.x
13:04:53 * geekosaur has oficially requested a Henning mode from haddock that expands the type and class names
13:04:55 <monochrom> while I disbelieve in meaningful names, I still believe in mnemonic names. and this still implies agreeing that a comfortable edit distance helps
13:05:23 <ski> it ought to be possible to make haddock disambiguate (explicitly) ..
13:05:47 <Cale> That, or we need a Henning Task Force which runs around editing his packages into better shape
13:05:52 <monochrom> and comfortable edit distance implies using more than one letter
13:06:22 <Cale> He writes a lot of good-looking code apart from that really obnoxious feature
13:07:05 <monochrom> there is a small scale version of this problem in aeson doc. there are two different ByteString's and two or three different Parser's
13:08:10 <tobiasBora> I have a question is quite different...
13:09:44 <tobiasBora> What is the position of Haskell with Object Oriented Programming ? Is it supposed to be integrated in a few years ? Is it "useless" for you ? I really like some things of POO (especially for doing big project with hundred of developpers)
13:09:59 <tobiasBora> and I'm wondering what haskell's programmers things about that.
13:10:26 <monochrom> it is not very useful to me, but it needs no further integration. when I want to use it, I do what Cale says.
13:10:36 <geekosaur> you can generally do OOP type things with records of functions
13:10:48 <geekosaur> there was a proof of concept OOHaskell at one point, also
13:10:59 <ski> i suppose it depends on what you mean by OOP
13:11:01 <davean> I'm greatly enjoying the lack of OO
13:11:05 <ski> @where object-oriented
13:11:05 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
13:14:16 <ski> tobiasBora : commonly OOP is associated with subtyping. subtyping isn't likely to ever appear in Haskell (it complicates type inference). (you could check out Timber, perhaps ..)
13:15:29 <ski> tobiasBora : another related (but distinct) concept is (implementation) inheritance, which probably won't appear in Haskell either (you can simulate it though, to some extent)
13:17:02 <tobiasBora> Ok... It's too bad I think, OOP can sometime be quite clear.
13:17:14 <ski> tobiasBora : if you're after "letting objects themselves decide how they want to respond to a message", then you can already do this by having a record of (usually) functions (this is a sense in which "FP", algebraic data types (or really variant/sum types), are dual ("opposite") to "OO", record types)
13:17:15 <geekosaur> sometimes. sometimes it can be anything but
13:17:23 * hackagebot binary 0.8.0.1 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.0.1 (LennartKolmodin)
13:18:24 <tobiasBora> ski: Data types are like baby objects, but it's not that easy to use
13:18:33 <ski> tobiasBora : if you're after being able to have "heterogenous collections", where the elements have "different types" but share the same interface, then you can also do this by the last option above, or otherwise via "existential data types" (a language extension)
13:19:15 <davean> tobiasBora: Its usually not affective to try to learn something by trying to make it waht you already know. You expectations just mislead you.
13:19:39 <ski> tobiasBora : it's not clear if you mean specifically *algebraic* data types (or sum/variant types) by "Data types"
13:20:43 <ski> tobiasBora : perhaps you can elaborate on some example you were thinking about, that you think is relatively nicely expressible in some OOPL ?
13:22:56 <geekosaur> OOP can be more expressive in some ways and simultaneously less expressive in others. Consider that you need to resort to generics or templates to do things that Haskell can do without special language facilities via polymorphism
13:23:34 <geekosaur> ...and tbh templates do nothing whatsoever for clarity, especially clarity of error messages
13:23:59 <`Guest00000> what are good tutorials for making dynamic libraries in haskell to use from haskell? i only find tutorials for usage from C
13:25:26 <kazagistar> Generics can be pretty nice error-wise, but subtyping makes even limited type inference a PITA to debug. I am missing haskell error messages a lot when debugging Java Streams…
13:26:25 <davean> `Guest00000: Theres things like http://hackage.haskell.org/package/plugins though I've never used them and I'm not sure why one would.
13:26:59 <`Guest00000> davean: to extend your program with plugins?
13:27:48 <geekosaur> davean, lambdabot used to be implemented via plugins
13:27:52 <davean> `Guest00000: Why though? That seems a silly way to structure it, its easy to extend without them unless it can't restart when doing it
13:28:12 <davean> geekosaur: I'm aware, and I've heard nothing but bad stories of it :)
13:28:41 <geekosaur> well, many of those stories related to shortcomings in ghc-api, such that you had to manually parse .hi files to get interface information
13:28:47 <tobiasBora> davean: Well, I know that, that's why I try to understand how Haskell can be efficient...
13:29:20 <tobiasBora> You asked me an example
13:29:22 <tobiasBora> Well
13:29:28 <geekosaur> and ghc-api couldn't unload modules, and various other shortcioings that plugins was basically a collection of hacky workarounds for
13:29:31 <`Guest00000> davean: not quite understood your message
13:30:07 <tobiasBora> I think that inherance is a good example where I can't find any Haskell solution. 
13:30:35 <geekosaur> inheritance is a good example of where OO's solutions are often problems...
13:30:52 <tobiasBora> geekosaur: Why ?
13:31:07 <`Guest00000> i want to update / let users update main program and plugins independently
13:31:18 <geekosaur> (note how many OOP languages only offer interface inheritance, or warn you that you sould only use interface inheritance. experience has shown that class inheritance causes more problems than it solves)
13:31:19 <davean> `Guest00000: Is not restarting the app on reconfiguration a core part of the design? And do the plugins work on a shared state directly? If no to either of those I have no idea why using plugins would be a good way of accomplishing your goal.
13:31:56 <davean> `Guest00000: Then why not make an interface to extend and make the different code a parameter?
13:32:22 <davean> `Guest00000: Take xmonad for example
13:32:31 <geekosaur> and yet class inheritance came first and was one of the widely touted features of OOP early on
13:33:14 <davean> `Guest00000: and perhaps http://hackage.haskell.org/package/dyre
13:36:16 <tobiasBora> geekosaur: Well, how would you design for example a code that would translate a OOP code which define a Vehicle class, that has a current speed, a max speed..., another class Moto that has a given color, and a brand... How would you provide to Moto objects the same functions as the ones in Vehicle in a pretty way ?
13:37:18 <davean> tobiasBora: So, not fully considering it, why is that not an interface Vehical (terrible name)?
13:37:30 <davean> class Vehical v where ...
13:38:51 <davean> (Nether of these seems like appropriate objects to me)
13:41:41 <Black0range> Hey guys! Does type families have any kind of performance impact? 
13:41:47 <maerwald> geekosaur: it's just that most ppl use OOP in the sense of SOP, where S means mutable state... and then they have to design how objects communicate, account for invalid states between objects in implicitly create protocols
13:42:22 <geekosaur> did you mean me there, or tobiasBora?
13:43:27 <`Guest00000> davean: i don't get - does Dyre inclure interpreter/compiler to execute Haskell code?
13:43:30 <`Guest00000> i don't need that...
13:44:08 * geekosaur doesn't OOP much, tbh. most ocmmonly working in Haskell, C, or Perl; of those only Perl has any real support for OO (yes, I am aware of the gtk and Xt style hacks for "OO") and it'seither deficient (native) or slow (Moose)
13:45:28 <maerwald> geekosaur: what I was trying to say is that OOP is not OOP. Imagine the majority of haskellers wouldn't care if their functions are IO tainted and don't try to delay IO as long as possible. Then at least some benefits would be gone, although you still have them on paper. That's what happened to OOP partly, IMO.
13:46:22 <geekosaur> I think I captured part of that with the whole deprecation of class inheritance
13:46:45 <maerwald> and then it ends up forcing you to think in state, instead of trying to avoid state... because state often means complexity
13:46:50 <geekosaur> I had a few other cmments I was going to make in that general area but had trouble phrasing them sensibly :(
13:47:26 <maerwald> but the same could happen to haskell, if ppl don't care and do everything within IO, then you can potentially have stateful stuff everywhere via IORefs and whatnot
13:47:52 <maerwald> so it's more a matter of teaching
13:47:57 <geekosaur> that said, I am probabl ot the ideal person t talk about OO because Ive realized that I never actually think in OO
13:48:07 <maerwald> me neither :D
13:48:26 <geekosaur> when I started thinking about tobiasBora's Vehicle example, I suddenlly realzied that I;d started out by decomposing it into 3NF >.>
13:48:30 <hpc> it might be arguable that haskell should be taught in that "i don't care about purity" mindset
13:48:39 <hpc> at least the first semester or so
13:48:51 <hpc> even without purity you gain a lot
13:48:54 <lpsmith> obadz, there's almost certainly a race condition at least on standard Linux filesystems
13:48:56 <maerwald> hpc: uh?
13:49:24 <lpsmith> obadz, filesystems are very racy beasts
13:49:30 <tobiasBora> geekosaur: 3NF ?
13:49:34 <monochrom> that is an interesting experiment to try
13:49:36 <geekosaur> obadz, when I lookeed into the various filesystem notification services, they all had race conditions and resource management issues, different for each one and generally unavoidable
13:49:47 <geekosaur> tobiasBora, I was thinking in relational database, not OOP
13:50:09 <lpsmith> At least on Linux,  you can't sanely avoid that particular race condition,  rather you have to write your code to be tolerant of it.
13:50:32 <hpc> maybe design the class specifically for IO
13:50:45 <maerwald> Purity in terms of haskell is mostly a thing that is nice formally, but has little practical relevance for the programmer. What matters is how expressive type signatures are. If all of your functions are IO tainted and do IORef stuff, then they are technically still pure, but how does that matter now? It's still a mess.
13:50:55 <hpc> write a REST server/client, write a chat client, implement an oauth pairing, etc
13:50:59 <hpc> like an APIs class
13:51:00 <tobiasBora> geekosaur: Wow I would'nt have such idea ^^
13:51:23 <Zekka|Sigfig> tobiasBora: You might if you work more with relational DBs than with object-oriented programming languages
13:51:30 <`Guest00000> wtf... does 'plugins' package ALSO depend on compiler
13:51:32 <geekosaur> thing is, database normalization levels are not a bad way to think in terms of interfaces
13:51:33 <monochrom> well, I took your "don't care" to mean "use unsafePerformIO as you see fit"
13:51:44 <hpc> monochrom: oh, that'd be a terrible idea ;)
13:51:47 <geekosaur> as distinct from objects
13:51:53 <lingxiao> hey all
13:51:55 <obadz> lpsmith / geekosaur - that's too bad :(
13:51:56 <monochrom> because without that, you still have to care, it is forced by the types.
13:52:01 <Zekka|Sigfig> everyone will see a design and relate it to designs they’re already familiar with as part of learning
13:52:04 <lingxiao> does anyone want to answer some coq questions over at #coq?
13:52:17 <monochrom> if you only mean "have IO early", Hudak already does that.
13:52:30 <monochrom> or rather, did. he is no longer with us.
13:52:33 * hackagebot generics-eot 0.2.1 - A library for generic programming that aims to be easy to understand  https://hackage.haskell.org/package/generics-eot-0.2.1 (SoenkeHahn)
13:52:37 <lpsmith> So, if you see a directory being created,  you have to start watching that directory,  then look inside that directory for new files.   Which means you can't necessarily get some of the other events like file open/file close,  and that you'll probably need your actions that you trigger based on file creation to be idempotent.
13:52:55 <monochrom> his course and his textbook have "draw fractal pictures" early one
13:52:56 <obadz> lpsmith / geekosaur - I think we could eliminate some of these using the fanotify API instead of inotify
13:52:59 <monochrom> s/one/on
13:53:09 <hpc> monochrom: maybe a language extension for teaching that tries unsafePerformIO-ing type errors automatically
13:53:14 * tobiasBora try to think. Actually it's pretty hard today.
13:53:17 <hpc> purely for teaching
13:53:31 <hpc> in this experiment class
13:54:14 <Zekka|Sigfig> Why teach Haskell instead of something eager, then?
13:54:20 <Zekka|Sigfig> Like ML or something
13:54:22 <lpsmith> obadz, quite possibly,  fanotify is a much larger sledgehammer,  but it can do a few things that you can't really do robustly with inotify.
13:54:52 <tobiasBora> For example here is a simple example : I just take the haskell documentation : http://paste.debian.net/367332
13:54:53 <hpc> Zekka|Sigfig: laziness is different than purity
13:54:59 <maerwald> there are already ideas of a haskell environment where you can unlock language features, but I'm not sure there's something ready yet
13:55:07 <tobiasBora> Let's imagine I build thousands of functions.
13:55:08 <Zekka|Sigfig> hpc: I know. But unsafePerformIO will cause your IO to occur in unpredictable order
13:55:12 <hpc> Zekka|Sigfig: but yeah, ML might be better if it wasn't also old
13:55:23 <maerwald> e.g. in order to unlock the do notation feature, first master the bind operator
13:55:34 <hpc> Zekka|Sigfig: oh wait, you're right
13:55:51 <hpc> Zekka|Sigfig: i was thinking extension that automatically lifts into IO
13:55:53 <monochrom> the two issues are pretty much tied
13:55:53 <Zekka|Sigfig> It wouldn’t be right if your program just coincidentally led to Haskell accessing an IORef before (or never) setting it
13:56:16 <monochrom> I have no interest in arguing against ML or Racket.
13:56:30 * tobiasBora is saying bulshit. Sorry !
13:56:35 <monochrom> but I am interested in what will happen if we teach Haskell in this heretic way
13:56:58 <hpc> mostly i just like IO
13:57:12 <maerwald> it should be the last thing a new haskeller learns
13:57:20 <obadz> in http://hoogle.haskell.org/?hoogle=Char+-%3E+Int how come chr comes up first and ord is like 6 down from the top? Shouldn't ord be a higher seeing how it's a perfect match and chr isn't?
13:57:22 <Zekka|Sigfig> My prediction based on the last guy I saw in the channel who was intent on doing this:  if you add automatic unsafePerformIO, people will get upset because the language is literally not doing what they ask it to, for reasons they don't understand
13:57:44 <hpc> Zekka|Sigfig: it'd be a language extension, opt-in
13:57:50 <monochrom> is getting upset bad?
13:57:55 <hpc> definitely not a default feature
13:58:04 <`Guest00000> ffi: "Warning: GHC does not support passing structures as values yet."  god...
13:58:13 <Zekka|Sigfig> If you add automatic lifting to IO, they will probably be upset by type errors they don’t understand when the lifting fails (e.g. they have a list of effectful values and the lifter doesn’t anticipate that they want sequence) but their program will at least work if it compiles
13:58:21 <`Guest00000> i hoped i could use existential type values...
13:58:32 <Zekka|Sigfig> monochrom: It’s not bad to get upset, but the feedback they get will not give them something obvious to do about it
13:58:34 <monochrom> if you want to recommend against X, the best strategy is still to pretend to teach X, and make sure the students get upset.
13:59:04 <Zekka|Sigfig> I think “laziness is stupid” is a more likely takeaway than “let’s manage all our effects using types”
13:59:11 <dexterph> obadz: at the top of the page it does say 'alpha version : type search doesn't work', maybe eventually it should give better results
13:59:17 <geekosaur> `Guest00000, *C* didnt support structs as values for a long time
13:59:19 <maerwald> I think it's a pretty terrible idea. You can't properly explain "and now we remove the automatic unsafeperformio lifting". Ppl will be seriously confused.
13:59:30 <geekosaur> it was a late addition to K&R (pre-ANSI) C
13:59:41 <hpc> monochrom: oh, somewhat related theory: beginners' uni classes that favor certain "easy" languages select against people who would otherwise be good at other languages
13:59:59 <Zekka|Sigfig> (of course, I think a lot of people are right not to want to use types to manage effects, and I think laziness is a means to the end of homemade flow control operators, not an end in itself)
14:00:06 <hpc> like the old @quote about that astronomy student who accidentally wrote perfect haskell while planning out a C++ program
14:00:07 <geekosaur> in the 80s you could still find C compilers that didn't support it
14:00:12 <`Guest00000> geekosaur: C everywhere. what about Haskell shared libraries to use in other Haskell programs?
14:00:17 <monochrom> heh
14:00:33 <maerwald> Zekka|Sigfig: yeah, it can get terrible with huge monad stacks that have an awful API
14:00:45 <hpc> so it would follow that to make the best programmers, you teach the best language first to select for it in later classes
14:00:49 <maerwald> and navigating becomes difficult
14:00:56 <geekosaur> I wouldn't be using FI structs for that, but serialization via binary or cereal
14:01:24 <Zekka|Sigfig> hpc: FWIW, I have a lot of sympathy for Haskell, but I think it’s a mistake to call it “best”
14:01:44 <Zekka|Sigfig> there are a lot of domains it doesn’t have very much penetration is and a lot of the reasons people say Haskell is excellent seem to be based on theory, not on practice
14:01:59 <`Guest00000> geekosaur: how would i serialize typeclass dictionaries?.......
14:02:10 <`Guest00000> hopeless
14:02:14 <Zekka|Sigfig> I often enjoy working in it but I don’t think there’s that much empirical evidence that it leads to better software or it makes for better programmers
14:02:23 <Zekka|Sigfig> very much penetration in*
14:02:34 * hackagebot herf-time 0.2.2 - haskell time manipulation in a 'kerf like' style.  https://hackage.haskell.org/package/herf-time-0.2.2 (scottmurphy09)
14:02:42 <geekosaur> usually you don't. but you can't create structs for them either
14:02:53 <davean> `Guest00000: Why aren't you just linking them in? You still haven't explained why you're making it dynamic
14:03:24 <maerwald> Zekka|Sigfig: I never heard anyone claim that in a scientific way, so asking for empirical evidence is a bit weird :)
14:03:24 <`Guest00000> davean: i don't want to recompile program -- i don't want forcing users to recompile program to use a new plugin
14:03:39 <geekosaur> not unless you avoid the language typeclass implementation and use a records-of-functions (manual and explciit) implementation for typeclasses
14:03:40 <maerwald> we don't even know how to determine a "good programmer"
14:04:00 <Zekka|Sigfig> maerwald: Well, I suspect more people should run experiments! But I don’t think that’s realistically possible — really I’m not arguing “there’s not evidence of a scientific standard” but “there’s not really that much evidence at all”
14:04:16 <Zekka|Sigfig> er, evidence that’s on a scientific standard*
14:04:20 <maerwald> I think it doesn't make sense to scientifically talk about "good programmers".
14:04:32 <geekosaur> `Guest00000, to see what level of complexity you're trying to evoke, you might want to look at Cloud Haskell and its restrictions
14:05:01 <lpsmith> obadz,  anyway, if these sorts of issues are important to you,  you _may_ be interested in writing to a particular OS's fs notification system directly;  if you are interested in Linux/inotify,  you may be interested in my much thinner and more direct binding: https://hackage.haskell.org/package/linux-inotify
14:05:03 <maerwald> it certainly requires you to think about problems in a different way... and that alone is a good thing
14:05:08 <geekosaur> (one of its objectives being to pass data etc. between compute nodes, whether local or in the cloud or transferring between them)
14:05:19 <maerwald> being diverse in language paradigms
14:05:25 <davean> `Guest00000: I really think you should go play with xmonad a bit
14:05:44 <lpsmith> Alternatively,  fanotify bindings and/or reimplementing some of the "higher level" fs notification bindings in terms of fanotify might be very interesting.
14:06:10 <lpsmith> I haven't looked into fanotify very deeply myself though.
14:06:34 <andromeda-galaxy> `Guest00000: seconded, it sounds like dyre or halive are the closest you can get to what you want (unless you want to use the ghc api directly to load other haskell objects, but that's annoying...)
14:07:20 <`Guest00000> dyre depends on having compiler available
14:07:20 <geekosaur> yes. I think hint has wrappers for that though?
14:07:43 <geekosaur> you are headed straightinto a world of hurt right there, I think
14:07:57 <davean> `Guest00000: Pretty inherantly everything that links code requires having a linker available
14:08:08 <davean> `when you do it dynamicly its still there, just included in the program
14:08:08 <geekosaur> wait until you find out how version skew affects things, thanks to ghc's cross-module optimization
14:12:04 <`Guest00000> i remember having done a similar thing years ago in Delphi. i wrote a class in main program, then wrote a dynamic library which returned object of that class, but internally it was an object of child class with overriden methods. then, in main program, i just called that function to get object, then called the methods. child's methods worked...
14:12:16 <`Guest00000> (this might be non-portable... but i don't care)
14:12:37 <`Guest00000> (across deplhi compilers / dialects)
14:13:11 <`Guest00000> so, Delphi has it. Haskell doesn't.
14:14:40 <geekosaur> that's ;less to do wit the language and more to do with how the implementation represents things. ghc's is more complex than Delphi's, with reason
14:14:49 <ggVGc> maerwald: good programmers produce satisfactory programs within budget
14:14:59 <maerwald> not sure I agree
14:15:00 <ggVGc> I tink that's the most common definition
14:15:10 <maerwald> and it's pretty vague
14:15:53 <maerwald> A terrible php programmer who hacks all day long unmaintainable code might fit that criteria.
14:16:06 <maerwald> because the boss says "that's satisfactory"
14:16:08 <maerwald> too vague
14:17:18 <Zekka|Sigfig> I’m just suspicious of stronger claims about a language than “I like it.”!
14:17:36 <Zekka|Sigfig> “It’s popular” and “They wrote some good programs in it” are good claims too.
14:17:44 <Zekka|Sigfig> Ooh, and features a language objectively has are allowed.
14:18:08 <Zekka|Sigfig> like “Haskell has type inference, which I really like”
14:18:13 <maerwald> popularity is not important for the language per se, but for working with it
14:18:36 <obadz> Zekka|Sigfig: H4sk3|| is d4 b3st!!!
14:18:43 <maerwald> there can be a language which is unpopular and doesn't have any useful libraries... but can still blow your mind, because the concept is superior
14:18:45 <Zekka|Sigfig> maerwald: Popularity is the pretty valid reason my boss rejected my suggestion we use Prolog
14:18:50 <maerwald> it will just be a pain to work with
14:19:10 <maerwald> sure, but those are business problems again
14:19:12 <Zekka|Sigfig> I *really like* Prolog, but there is not a lot of evidence out there that anyone other than me will be more productive or happier if we use prolog
14:19:33 <maerwald> I don't consider them scientifically too relevant when talking about a _language_
14:20:20 <Zekka|Sigfig> Well,c like managers, most programmers also don’t trust other programmer’s theoretical estimates about what makes them more productive
14:20:49 <Zekka|Sigfig> I know I’m suspicious when a C++ programmer says he’s just as efficient in C++ as I am in the plethora of technologies I use other than C++, and he’s suspicious of me too.
14:21:18 <Zekka|Sigfig> I think these are just problems that come up when a bunch of people have experiences, all those experiences are different, and they have to reconcile them
14:21:33 <Zekka|Sigfig> (It wasn’t just management that rejected my suggestion we use Prolog, although it was management that officially rejected it)
14:23:28 <Zekka|Sigfig> Of course, unlike non-programmers,  if someone says “you should try X technology and you might like it,” you can actually do that and maybe end up on common ground. (my experience is that this doesn’t typically happen — the guys in my office who love Scala told me I should use Scala and I would love it, and I ended up really disliking it)
14:24:52 <ggVGc> Zekka|Sigfig: it's pretty good compared to java though, wouldn't you say?
14:24:58 <`Guest00000> so, is there no way for me if i don't want to bundle ghc with my program?
14:25:39 <Zekka|Sigfig> ggVGc: If you’re choosing between Java and Java-flavored Scala, I prefer Java-flavored Scala
14:25:52 <Zekka|Sigfig> A lot of the Scala I’ve seen was confusing enough I would prefer the Java though
14:26:23 <`Guest00000> also, licensing...
14:33:05 <Cale> `Guest00000: what are you trying to do?
14:33:15 <ggVGc> Zekka|Sigfig: I feel scala is one of thise things where you just have to avoid 60% of it and then it's pretty good
14:33:54 <Zekka|Sigfig> ggVGc: Yeah. I’m admittedly preferential towards “reliably pretty bad” to “good but occasionally really terrible” most of the time
14:34:05 <`Guest00000> Cale: i need to extend my program with dynamic libraries, without depending on ghc
14:34:08 <Zekka|Sigfig> it’s one of the reasons I used to be really hot on Prolog but simmered down a little bit towards it
14:34:51 <`Guest00000> i need those libraries to be able to pass into my programs values of existential types
14:34:58 <`Guest00000> with typeclass dictionaries
14:35:32 <Cale> `Guest00000: Without depending on having GHC installed, or without depending on GHC-as-a-library?
14:36:03 <Cale> Using GHC-as-a-library (or one of the various higher level interfaces to that) is probably the simplest way.
14:36:05 <rschnck> I'm reading Real World Haskell, and it's talking about foldl and thunking (http://book.realworldhaskell.org/read/functional-programming.html) and how foldl should be avoided for that reason, and foldl' used instead.
14:36:10 <rschnck> Why doesn't foldr have this problem?
14:36:33 <Cale> rschnck: Well, foldr does... kind of.
14:36:45 <rschnck> Why only kind of?
14:36:47 <Cale> rschnck: The control flow is very different with foldr.
14:36:53 <Cale> It's hard to make the comparison
14:36:56 <Cale> @src foldl
14:36:57 <lambdabot> foldl f z []     = z
14:36:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:37:03 <rschnck> Right, I just wrote it myself.
14:37:13 <Cale> foldl does nothing but apply itself to new arguments until it reaches the end of the list
14:37:17 <Cale> @src foldr
14:37:17 <lambdabot> foldr f z []     = z
14:37:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:37:19 <rschnck> But you still end up building something that looks like (say for addition (1 + (2 +(3 +0)))
14:37:21 <rschnck> Seems like a thunk to me.
14:37:22 <Cale> foldr passes control to f
14:37:50 <Cale> and then only if f needs (pattern matches on) its second argument will the foldr proceed further
14:38:24 <Cale> So, with addition, which is strict in both its arguments, you end up with a similar performance problem with foldr
14:38:35 <Cale> foldr (+) 0 [1,2,3]
14:38:41 <Cale> -> 1 + foldr (+) 0 [2,3]
14:38:43 <rschnck> Wait, not sure I understood "and then only if f needs (pattern matches on) its second argument will the foldr proceed further"
14:38:57 <Cale> Remember that lazy evaluation is outermost-first
14:39:13 <Cale> So the next thing which gets to evaluate in  f x (foldr f z xs)  is *f*
14:39:27 <Cale> those arguments (unevaluated, as expressions), get passed to f
14:39:33 <rschnck> Oh, right.
14:39:37 <Cale> only if f pattern matches on them will the evaluation continue
14:39:47 <Cale> This is why foldr can deal with infinite lists
14:39:50 <rschnck> Wiat, no I'm still confused :(
14:39:58 <Cale> > foldr (\x xs -> 2 * x : xs) [] [1..]
14:39:59 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
14:40:02 <rschnck> When you say "if f pattrn matches" what exactly do you mean?
14:40:43 <Cale> rschnck: At some level, the only reason that anything ever gets evaluated is in order to determine if an expression matches a pattern
14:40:58 <rschnck> Okay
14:41:00 <Cale> (and which of the patterns matches)
14:41:08 <marchelzo> is megaparsec better than parsec?
14:41:23 <Cale> and in order to do that, the expression needs to evaluate up to the point at which it's a data constructor applied to some arguments
14:41:56 <rschnck> " at which it's a data constructor applied to some arguments" I don't  understand that at all.
14:42:35 * hackagebot base 4.8.2.0 - Basic libraries  https://hackage.haskell.org/package/base-4.8.2.0 (HerbertValerioRiedel)
14:42:44 <Cale> rschnck: Well, say you wanted to determine if some expression for a list matches the pattern (x:xs)
14:42:44 <rschnck> Can you maybe give me an example of what you're talking about?
14:42:48 <rschnck> Maybe in the context of the infinite list?
14:42:51 <Cale> sure
14:43:03 <Cale> > case foldr (\x xs -> 2 * x : xs) [] [1..] of (x:xs) -> x
14:43:04 <lambdabot>  2
14:43:04 <rschnck> Because, my gut would say that you couldn't do that foldr on the infinite list
14:43:10 <rschnck> Seems like you'd have to get to the end of it :P
14:43:15 <Cale> So, this works, let's try to figure out why
14:43:18 <`Guest00000> okay
14:43:28 <Cale> @src foldr
14:43:28 <lambdabot> foldr f z []     = z
14:43:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:43:37 <Cale> So, our expression,
14:43:40 <Cale> foldr (\x xs -> 2 * x : xs) [] [1..]
14:43:46 <Cale> is not immediately in the form
14:43:50 <Cale> x : xs
14:43:54 <Cale> for some expressions x and xs
14:44:05 <Cale> and foldr is not a data constructor
14:44:11 <Cale> so the pattern still might match
14:44:14 <Cale> right?
14:44:23 <Cale> But we need to evaluate in order to decide that
14:44:35 <Cale> So, we look at the definition of foldr
14:44:49 <`Guest00000> i will just make interface for using plugins written in any language
14:44:55 <Cale> Well, first, I should say, this pattern match goes on the stack
14:45:11 <rschnck> Your use of "data constructor" confuses me.
14:45:16 <Cale> oh?
14:45:21 <rschnck> I only know that term in the context of like data Color = Red | Green | Blue.
14:45:24 <Cale> right
14:45:34 <Cale> Data constructors are the things that patterns match against
14:45:36 <rschnck> So for me at the moment it's intimately linked with type constructors.
14:45:43 <Cale> (:)
14:45:46 <Cale> is a data constructor
14:45:48 <Cale> as well as []
14:46:07 <rschnck> I'll just say "ok" for now and see if it becomes clear :P
14:46:15 <Cale> and any value whose name starts with an uppercase letter is a data constructor
14:46:18 <`Guest00000> no existentials.. one function per method, one instance per library.
14:46:30 <rschnck> Oh, wait. I think I see.
14:46:35 <Cale> and any infix function whose name starts with a colon ':' is a data constructor
14:46:48 <rschnck> Okay. I haven't seen any of those yet.
14:46:48 <Cale> e.g. you can define a new datatype which uses :-> as an infix data constructor
14:47:04 <Cale> but yeah
14:47:12 <rschnck> So [] is a data constructor because it creates an empty list?
14:47:52 <tremon> without the becuase :) -- [] is a (the) data constructor that creates an empty list
14:48:02 <rschnck> Wait, if I wanted to make the list [5]
14:48:03 <Cale> Yeah, well, not just for that reason. It's built-in and has special syntax, but the real reason is that it's represented in memory in a special way
14:48:06 <rschnck> could I write (:) 5 []?
14:48:09 <Cale> yes
14:48:11 <rschnck> Ohhhh
14:48:13 <rschnck> I see :)
14:48:19 <Cale> and when you write [5] it really means (:) 5 []
14:48:25 <Cale> [5] is syntax sugar
14:48:31 <rschnck> Right :D
14:49:20 <rschnck> Okay, back to foldr :D
14:49:24 <Cale> okay, so using the definition of foldr, we try to match  foldr (\x xs -> 2 * x : xs) [] [1..]  against the pattern  foldr f z []
14:49:48 <Gurkenglas> Some and many should have as laws not that its implementation be the least defined fixed point of its default implementation, but that its implementation be either more or less defined than every fixed point of its default implementation(, and aspire to be as defined as possible). (Any of the marked points on http://sketchtoy.com/66510198 )
14:49:58 <Cale> so f can be bound to (\x xs -> 2 * x : xs)
14:50:08 <Cale> and z can be bound to []
14:50:16 <rschnck> Cale: Wait, why not foldr f z (x:xs)?  Would  foldr f z [] fail since [1..] can't match against []?
14:50:16 <puregreen> marchelzo: I think it is; a while ago I wrote the announcement of Megaparsec that lists things that are wrong with Parsec, you can see it here: https://notehub.org/w7037#what-s-wrong-with-original-parsec (and I don't see many reasons why you'd want to use the original Parsec unless you are parsing a language that's exactly like Haskell and so you'd be able to use the sorta Haskellish lexing module that Parsec has)
14:50:24 <Cale> that's true
14:50:30 <Cale> we will eventually try that pattern
14:50:34 <Cale> but pattern matches are in order :)
14:50:37 <rschnck> Oh, you're just running down the oder.
14:50:39 <rschnck> Order*
14:50:40 <rschnck> Right :)
14:51:02 <Cale> So, we try to match [] against [1..] which is really syntax sugar for enumFrom 1
14:51:25 <Cale> and then we need to evaluate enumFrom 1 a bit to be able to see if it matches
14:51:53 <rschnck> Well, but not really, right?
14:51:53 <Cale> So, well, I won't bother with the definition of enumFrom 1, but we end up with  1 : enumFrom 2
14:52:03 <rschnck> I'd imagine you'd just call something like null (enumFrom 1).
14:52:08 <Cale> nope
14:52:08 <Gurkenglas> In particular, many (Maybe x) has as fixed points _|_ and repeat x, and should be the latter.
14:52:10 <rschnck> :O
14:52:11 <rschnck> Oh.
14:52:17 <Gurkenglas> *many (Just x)
14:52:32 <Gurkenglas> Just (repeat x), dammit
14:52:39 <Cale> This expression 1 : enumFrom 2 in memory is represented by a cell for the (:)
14:52:53 <Cale> which has an integer tag saying which of [] and (:) it is
14:53:03 <Cale> and pointers to code for the expressions that (:) is applied to
14:53:26 <Cale> The actual implementation will check the integer tag, and figure out which branch of the case to take
14:53:42 <Cale> So, in this case [] will not match 1 : enumFrom 2
14:54:12 <Cale> Cool? I know it's all a bit vague :)
14:54:36 <rschnck> Yeah, that's neat.
14:54:43 <Cale> There are lots of ways to implement this stuff, but it usually suffices to stay at the level where you imagine that expressions are sitting around in memory at runtime, and being rewritten into other expressions
14:54:53 <rschnck> So the : and [] constructors are distinguished by an integer?
14:54:56 <Cale> (by evaluation)
14:54:58 <Cale> yeah
14:55:18 <rschnck> That's a cool way to check if something is null or not.
14:55:25 <rschnck> Esp. in context of infinite lists. :)
14:56:12 <Cale> (there's also funky pointer tagging nonsense which goes on that will distinguish already-evaluated expressions that are being pointed to by a code pointer using the low-order bits, because proper code pointers are aligned to multiples of 4 or 8 bytes in memory, so the low-order bits can be siphoned off for another purpose
14:56:33 <Cale> but that's a whole other story)
14:56:52 <Cale> So yeah, we stop evaluating when we hit a data constructor, in this case, it's (:)
14:56:58 <Cale> and so [] doesn't match
14:57:11 <Cale> but the pattern foldr f z (x:xs) will
14:57:13 <rschnck> So you have 3 bits to decide the evaluation state of an expression based off of the pointer?
14:57:23 <Cale> yeah
14:57:27 <rschnck> haha that's so janky :D
14:57:36 <Cale> Well, it's also optional
14:57:53 <nolrai2> I thought that wasn't done anymore?
14:57:57 <Cale> you can also jump to the pointer, and if the thing was already evaluated, you go to a short piece of code which returns the value immediately
14:58:13 <rschnck> Where can you learn about Haskell in that sort of depth? Or is it pretty much "read the source"?
14:58:23 <Cale> rschnck: There are a bunch of papers...
14:58:27 <rschnck> Oh.
14:58:32 <Cale> The first one which I'd recommend...
14:58:34 <rschnck> Maybe I'll look once I finished RWH.
14:58:41 <rschnck> finish*
14:58:58 <shachaf> You can also learn by looking at the code that GHC generates.
14:59:04 <Cale> here's a pdf... http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
14:59:08 <nshepperd> the secret sauce is STG, isn't it?
14:59:14 <rschnck> Cale: Neat, thanks.
14:59:27 <rschnck> Okay, foldr. foldr f z (x:xs) matches.
14:59:29 <Cale> part 1 of that paper "Exploring the design space" in particular is a good overview
14:59:32 <Cale> okay
14:59:33 <Cale> yeah
15:00:10 <Cale> So, f is bound to (\x xs -> 2 * x : xs), z is bound to [], x is bound to 1, and xs is bound to (effectively) [2..]
15:00:15 <Black0range> Could someone explain this error to me? http://lpaste.net/150527
15:00:33 <Cale> and then the right hand side of the equation is
15:00:41 <Cale> f x (foldr f z xs)
15:00:44 <Cale> which is
15:00:57 <jle`> Black0range: do you have the instance written somewhere?
15:01:05 <Black0range> Nope 
15:01:11 <Cale> (\x xs -> 2 * x : xs) 1 (foldr (\x xs -> 2 * x : xs) [] [2..])
15:01:17 <jle`> then where is the error coming from?
15:01:27 <Black0range> oh wait sorry forgot that
15:01:29 <Cale> and we're still not done because this lambda is not a data constructor
15:01:32 <jle`> it looks like you were writing an instance for Bytestring
15:01:34 <monochrom> Black0range: you're talking about, the type of toURLPath is: Path p => a -> p
15:01:51 <Black0range> http://lpaste.net/150527
15:01:54 <Black0range> here 
15:01:54 <Cale> and its patterns are trivial variables, so no evaluation of the arguments is needed
15:02:08 <jle`> Black0range: ah, yeah
15:02:12 <Cale> we match x with 1 and xs with (foldr (\x xs -> 2 * x : xs) [] [2..])
15:02:16 <jle`> toURLPath should be a -> Bytestring
15:02:20 <Cale> and the thing evaluates to
15:02:26 <jle`> as in, it should be able to turn something of *any* type into a Bytestring
15:02:32 <Cale> (2 * 1) : (foldr (\x xs -> 2 * x : xs) [] [2..])
15:02:34 <jle`> but, as you have implemented it, it can only turn other bytestrings into bytestrings
15:02:42 <Cale> ahaha! We have a data constructor, (:)
15:02:49 <Cale> and so we are done evaluating here!
15:02:53 <jle`> Black0range: what's what something of type (a -> Fo) means
15:02:59 <EvanR> isn't a -> ByteString either bottom or a constant bytestring?
15:03:02 <jle`> "give me something of any type, and i'll return a Foo"
15:03:07 <Cale> We go back up the stack, and match our original (x:xs) pattern
15:03:16 <Cale> x matches (2 * 1) (still not calculated!)
15:03:22 <Black0range> jle´: yeah but thats what i want? :(  
15:03:24 <Cale> and xs matches (foldr (\x xs -> 2 * x : xs) [] [2..])
15:03:32 <jle`> Black0range: which one do you want?
15:03:37 <Cale> cool?
15:03:43 <jle`> if you want an (a -> ByteString), then id isn't what you want
15:03:45 <Cale> and so the original case expression
15:04:00 <Cale> > case foldr (\x xs -> 2 * x : xs) [] [1..] of (x:xs) -> x
15:04:01 <lambdabot>  2
15:04:06 <Cale> evaluates to 2 * 1
15:04:24 <Cale> and then, well, the thing which is trying to turn this into a string is still not satisfied and forces the evaluation further
15:04:38 <jle`> Black0range: if you had an (a -> ByteString), it should be able to take Ints, Bools, Strings, Doubles, etc.
15:04:46 <jle`> Black0range: but the function you gave only takes ByteStrings
15:04:49 <rschnck> Okay, I mostly understand.
15:04:59 <Cale> and eventually we get 2, well, internally, we get some data constructor of the Integer type applied to some internal data nonsense for 2
15:05:21 <rschnck> So is having a data structure a natural point to end evaluation because, well, you "create data" from it?
15:05:25 <rschnck> If that makes sense
15:05:41 <rschnck> I'm just trying to better understand the "quest for the data structure" in that evaluation sequencee.
15:05:45 <Cale> Well, it's a natural place to end because it's the first place at which we can potentially succeed in matching a pattern
15:05:45 <jle`> Black0range: if you had class Path p where toURLPath :: ByteSTring -> p, that would work
15:05:58 <nshepperd> *data constructor
15:06:01 <rschnck> Because patterns are matched against data constructors. 
15:06:07 <Cale> and the compiler will actually transform all your case expressions so that they match on one constructor at a time
15:06:12 <Cale> yeah
15:06:16 <rschnck> So is the integer 1 a data constructor?
15:06:20 <jle`> Black0range: but i'm not exactly sure what you're trying to accomplish
15:06:28 <Cale> You can think of it as one, and reason correctly
15:06:31 <Cale> It might as well be
15:06:33 <nshepperd> the usual case of case matching is just asking 'which data constructor is here'
15:06:41 <rschnck> Well I see it as type Integer = 1 | 2 | 3 | 4 ...
15:06:44 <Cale> yeah
15:06:50 <Cale> that's basically an okay picture
15:06:54 <rschnck> Okay, good.
15:07:06 <Cale> okay, gotta eat dinner, be back shortly
15:07:15 <rschnck> Cale: Hey, thanks a lot. super helpful.
15:07:19 <EvanR> rschnck: data Integer =...
15:07:30 <rschnck> EvanR: Oh, right. Derp.
15:07:36 <EvanR> though with that pattern woull never enumerate the negatives!
15:07:44 <rschnck> I was just thinking about that :P
15:07:50 <rschnck> Maybe data N = 1 | 2 |3 |4 ... :P
15:08:00 <Black0range> jle`: i want to be able to convert a string (any kind) to something that could be concidered a path such as String -> [String], String -> Vector String etc 
15:08:03 <EvanR> can i haz 0
15:08:26 <rschnck> EvanR: Well, not everyone agrees on that heh
15:08:31 <Black0range> jle`: where i concider a String to be a subclass of Path itself 
15:09:00 <EvanR> 1 out of 1 Dr EvanR agree that zero is a nat, though with 0 and without 0 are isomorphic
15:09:14 <acertain> Black0range, maybe you want `toURLPath :: String a => a -> p`?
15:09:29 <monochrom> there is no "String a"
15:09:40 <dzdcnfzd> Would people here recommend HUnit for unit testing? Thoughts on it via Quickcheck? Also, is there any way to test IO side effects?
15:09:43 <Black0range> i assume you mean IsString and... same error :(
15:09:48 <acertain> for some `class String a` that is 
15:09:51 * rschnck Hasn't taken abstract algebra and feels inadequate 
15:09:57 <dzdcnfzd> like, for instance, verify a putStrLn does what you think it does
15:10:15 <EvanR> rschnck: enough haskell and youll get through osmosis
15:10:28 <nshepperd> EvanR: isomorphic under what algebra, punk?
15:10:29 <monochrom> it looks to me as "class Path p where { one_direction :: String -> p; the_other_direction :: p -> String }"
15:10:35 <johnw> dzdcnfzd: I think you just asked three distinct questions...
15:10:44 <EvanR> nshepperd: the structure of NNO
15:10:52 <EvanR> z and s
15:10:54 <dzdcnfzd> johnw: two, depending on how you look at it
15:11:09 <Black0range> jle`: do you think this is even possible to do? 
15:11:23 <jle`> monochrom's solution seems the most natural
15:11:36 <rschnck> EvanR: I hope so :D
15:11:44 <nshepperd> noses
15:12:04 <jle`> or evel cass Path p where fromFilePath :: FilePath -> p; toFilePhat :: p -> FilePath
15:12:07 <jle`> s/evel/even
15:12:12 <nshepperd> 'data Integer = Zero | Positive N | Negative N' works better without zero in N though
15:12:16 <synergistics> Is there any function that gets the portion of a list that's been evaluated (i.e. not a thunk)? Something like init, but going to the last evaluated in the list, not the last overall
15:12:17 <jle`> file phat -.-
15:12:21 <jle`> that ssh lag
15:12:43 <Black0range> ;)
15:12:53 <monochrom> synergistics, there is none
15:12:59 <EvanR> nshepperd: yeah data P = One | I P | O P, Integer = Zero | Plus P | Neg P
15:13:43 <synergistics> monochrom: Ah ok. Time to think up a new solution!
15:13:45 <EvanR> and get your "non zero natural number type" for free
15:13:47 <synergistics> monochrom: Thanks
15:14:22 <jle`> any packages that implement quotient types?
15:14:49 <jle`> searching hackage for 'quotient' reveals 0 packages
15:14:54 <jle`> which never happens for me
15:16:49 <sm> do you mean like http://hackage.haskell.org/package/base-4.8.2.0/docs/Data-Ratio.html ?
15:16:50 <koz_> I have strange typechecker behaviour: http://paste.rel4tion.org/226
15:17:17 <johnw> jle`: best notes I can find so far are http://jozefg.bitbucket.org/posts/2014-10-17-quotients.html
15:17:43 <andromeda-galaxy> sm: I think he means https://en.wikipedia.org/wiki/Quotient_type
15:17:51 <jle`> sm: i mean like quotient types in algebra; types with a defined equivalence relationship, like Z / mod 6 being the integres 0-5
15:17:53 <sm> oh, thanks
15:18:09 <mpickering> koz_: see, the monomorpism restriction 
15:18:13 <jle`> i guess Ratio is technically a type of a quotient type
15:18:15 <EvanR> jle`: seems like you need dependent types to say what a quotient type is in general?
15:18:17 <ski> <ski> one common use of abstract data types is to simulate subtypes, or quotient/factor types (or both at the same time)
15:18:21 <koz_> mpickering: Oh, so *that* is what happens...
15:18:27 <ski> jle` ^
15:18:28 <jle`> that's kind of cute
15:18:29 <koz_> mpickering: How do I work around this?
15:18:53 <jle`> ski: yes, we have Set whish sort of acts like a quotient over lists on their contained elements
15:18:59 <jle`> but is there a general library?
15:19:18 <ski> i'm not sure a general library would be possible in Haskell
15:19:27 <mpickering> Add the NoMonomorphismRestriction pragma 
15:19:36 <koz_> mpickering: Thanks.
15:19:59 <jle`> things have changed
15:20:07 <jle`> we have practical refinement types now :o
15:20:18 <koz_> I guess I should just set myself up a template with all my pragmas when creating new Haskell source files...
15:20:21 <jle`> and a lot of DT stuff going on.  maybe it's worth re-evaluating
15:21:22 <EvanR> a subset type is really an injection
15:21:26 <monochrom> Ratio is a quotient type in both sesnse.
15:21:27 <ski> jle` : you form a quotient type from (a) a representation type `R'; and (b) an equivalence relation on `R' (or, you can take any binary relation on `R', and then implicitly use the finest equivalence relation "spanned" by that)
15:21:39 <EvanR> so that could be your interface, and theres no way to enforce the law
15:21:55 <monochrom> it has a numerator and denominator. and it identifies 2/4 with 1/2
15:22:09 <mpickering> koz_: the report has an explanation for the restriction if you are interested 
15:22:29 <mpickering> And you only have three extensions :p
15:22:31 <ski> (iirc, the latter approach is used in Bart Jacobs "Categorical Logic and Type Theory")
15:23:00 <jle`> yeah.  but can we turn that into a general library?
15:23:29 <ski> you'd have to be able to incorporate the equivalence relation into a type
15:23:38 <jle`> we were talking about getting Z from N earlier.  instead of data Z = Neg Nat | Pos Nat, we could do data Z = (Nat, Nat) / -
15:23:49 <ski> which means, i think, that you'd have to "generate the type dynamically" (existentials)
15:24:04 <monochrom> a relation is a value. you are mapping values to types?
15:24:26 <ski> perhaps something similar to the `reflect' package approach could be used. i don't know
15:24:37 <EvanR> jle`: id like to be able to say all these implementations of Z are isomorphic, and have the compiler / runtime do the conversions for me 
15:24:44 <Black0range>  jle`: type families solved my problem :D 
15:24:50 <EvanR> or just use the most efficient
15:24:58 <ski> monochrom : that would be required for the general case, no ?
15:25:17 <monochrom> yeah. it's a dependent type thing
15:25:32 <ij> How can HaTeX parse LaTex? Is its syntax that simple?
15:25:50 <jle`> i'm justa little surprised there isn't a single pcakage on hackage with 'quotient' in the name or description
15:25:51 <ski> either that, or some kind of HoTT-inspired great extension of algebraic data types .. which i'm not sure won't amount to embracing DT anyway
15:26:10 <jle`> we could fake quotient types the same way refine fakes refinement types
15:26:19 <rschnck> I'm defining a function   f = g where g = foo. But I have two patterns to match again (i.e. f [] = -1*g where g = foo and f x = g where g = foo) where both gs are equal to the same foo. Is there a good way to avoid writing two identical where statements aside from just defining g outside of the function?
15:26:28 * ski hasn't seen `refine'
15:26:55 <jle`> it's basically a libray of utilities for working over Tagged
15:27:23 <jle`> so you create a "refinement", and define (as a typeclass) how to check it in order to use it in a smart constructor
15:27:26 <koz_> mpickering: I'll just always use the pragma. And that list is getting longer - I use classy-prelude heavily, which means TypeFamilies also gets involved frequently.
15:27:34 <ski> rschnck : unfortunately, Haskell has no SML-like `local'-`in' construction. you have to either define `g' (if possible) outside `f', or use a `case'
15:27:50 <jle`> *refined
15:27:59 <monochrom> quotient types are why math is so rich and full of non-free objects
15:28:05 * ski notes that Mercury has some affordance for quotient types
15:28:11 <jle`> ski: it's pretty simple http://hackage.haskell.org/package/refined-0.1.1.0/docs/Refined.html
15:28:23 <rschnck> ski: Bummer. Alright. Thanks :)
15:28:24 <ski> (in, imho, a better way than Haskell)
15:28:43 <EvanR> monochrom: how exactly does that generate those?
15:28:47 <jle`> refine :: forall p x. Predicate p x => x -> Either String (Refined p x)    -- Refined is Tagged
15:29:13 <jle`> Predicate has one method, validate :: p -> x -> Maybe String
15:29:29 <monochrom> by generating quotient types
15:29:29 <jle`> and there are some cute combinators for combinding predicates with and/or, simple numeric ones, etc.
15:29:38 <ski> rschnck : ftr, `local <decls> in <other decls> end' is a declaration that "exports" the identifiers defined in `<other decls>', while the identifiers defined in `<decls>' are local (visible in `<other decls>')
15:29:41 <EvanR> er ok
15:30:07 <EvanR> you start with the free version and do quotient by some = and get some weird thing
15:30:22 <monochrom> Z/5Z is not a free ring. it is a quotient ring.
15:30:27 <echo-area> foo : (a b : Rational) -> Either (reduce a == reduce b) (reduce a /= reduce b)   <-- Which language is this written in?
15:30:30 <ski> jle` : the string is an error message ?
15:30:51 <EvanR> why is Z/5Z not free?
15:30:54 <jle`> apparently
15:31:13 <monochrom> it has the extra equation 4+1=0
15:31:46 <EvanR> er, why is Z free?
15:31:54 <ski> jle` : afaics, that's more or less "(comprehension) subset types" ?
15:32:22 <EvanR> surely it has some extra properties than just "a ring"
15:32:37 * hackagebot mustache 1.0 - A mustache template parser library.  https://hackage.haskell.org/package/mustache-1.0 (justus)
15:32:42 <ski> EvanR : it's the free ring on the empty set of generators
15:32:45 <monochrom> be careful. property != equation
15:32:59 <monochrom> indeed, Z has the extra property that it doesn't have extra equations.
15:33:32 <EvanR> uh
15:33:51 <EvanR> what about the ring of reals
15:34:03 <EvanR> is it also free
15:34:13 <monochrom> all confusions are caused by incorrect quotienting :)
15:35:16 <monochrom> the reals are probably a free ring too
15:35:17 <jle`> one thing about making a faked quotient library is that you can't really enforce equivalence relatinoships are lawful
15:35:32 <johnw> The first rule of quotient club... is in a class with all the other rules of quotient club.
15:35:44 <monochrom> haha
15:36:35 <EvanR> so i guess since reals arent isomorphic to Z, then reals wouldnt have zero generators ;)
15:37:01 <ski> EvanR : the free "Foo" (being some kind of (type of) algebraic structure, in the sense of universal algebra) on a set `G' of generators has as elements only the expressions that can be built from the elements of `G', and all the (abstract signature) operations of "Foo", and two such expressions are to be considered equal only to the extent forced by the laws of "Foo"
15:38:30 <jle`> im' going to make a faked quotient type library
15:39:27 <ski> in Mercury, you can provide a custom binary relation as the equivalence relation on the representation type which is implementing *equality* on the quotient type
15:39:51 <ski> (you have to promise that it is an equivalence relation, otherwise UB)
15:40:13 <koz_> OK, suppose I have two types Foo and Bar. I would like to create a new type Baz, which is nothing more than a wrapper around (Foo, Bar). Normally, I would just create a type synonym with 'type', but then I can't give Baz a custom implementation of Show. I could write 'data Baz' etc etc, but then I have to do a lot of tedious unwrapping. Is there a way to avoid said tedious unwrapping, but still allow a
15:40:14 <koz_> custom Show?
15:40:47 <Cale> nope
15:40:50 <ski> a data constructor for such a type is not injective, and hence pattern-matching on the representation is non-deterministic
15:40:56 <Cale> But it shouldn't be *too* tedious
15:41:06 <Cale> I mean, it's exactly *as* tedious as using a pair
15:41:24 <ski> typically, at some point in the program you promise that the non-determinism doesn't actually affect the result anymore
15:42:02 <koz_> Cale: If the type is something like 'data Baz = Baz (Foo, Bar)', that's a layer of unwrapping I have to do to get at the (Foo, Bar) inside it. With 'data Baz = Baz Foo Bar', I guess that's OK.
15:42:18 <Cale> Right, I was thinking you'd use the latter
15:42:25 <koz_> I suppose that's what I'll do then.
15:42:32 <ski> koz_ : why do you want a custom `Show' instance ? if you want a custom "pretty-printing", then why not make a separate function (or class, if needed) ?
15:42:58 <Cale> Oh, yeah, usually most of the time you shouldn't be writing Show instances by hand.
15:43:28 <Cale> You want the Show instance to produce valid Haskell code for constructing the values, typically, because that's what makes it easiest to try things while working in GHCi
15:43:38 <andromeda-galaxy> custom show often implies show.read /= id
15:44:02 <andromeda-galaxy> that's why we have things like pretty
15:44:04 <Cale> If you want to print values in some other way, just define other functions, usually.
15:44:06 <ski> koz_ : `Show' is mainly intended for debugging purposes, so that `show' generates a valid Haskell expression that when evaluated (in a suitable environment) will result in an equal value. if you want something else, then i'd suggest not using `Show' for this
15:44:06 <andromeda-galaxy> @hackage pretty
15:44:06 <lambdabot> http://hackage.haskell.org/package/pretty
15:44:33 <koz_> ski: OK, so does this mean I have to have show-read symmetry if I define a custom Show?
15:44:41 <johnw> you don't *have* to
15:44:49 <johnw> but you usually do want to, it's up to you though
15:44:51 <koz_> johnw: But I guess it's a good idea.
15:45:15 <johnw> also, nothing says you have to use 'show', unless a library is requiring it
15:45:19 <johnw> you can just write myFooShow
15:45:32 <ski> koz_ : there are some cases where you may want a custom `Show' instance (which still generates a valid string representing a Haskell expression) .. e.g. for an abstract data type, where you may want to generate (a string representing) an expression calling some interface function
15:45:45 <koz_> ski et al: I see.
15:45:55 <ski> > listArray (0,3) [2,3,5,7]  -- is an example
15:45:57 <lambdabot>  array (0,3) [(0,2),(1,3),(2,5),(3,7)]
15:46:43 <koz_> andromeda-galaxy: Is there an example of how to use pretty somewhere I can read?
15:50:22 <andromeda-galaxy> koz_: honestly, I can't remember, sorry.
15:52:03 <koz_> andromeda-galaxy: No worries - I'll learn the hard way.
15:52:05 <andromeda-galaxy> koz_: there're actually lots of pretty printing libraries, I'm not sure which one's best
15:52:16 <andromeda-galaxy> (that's just the one that I've heard of lots before)
15:52:33 <koz_> andromeda-galaxy: Maybe someone on here might chime in.
15:52:46 <andromeda-galaxy> indeed! if you don't need anything too fancy, just defining a simple printFoo function isn't a horrible approach either, I just thought I'd mention the possibilities
15:53:34 <andromeda-galaxy> (pretty is apparently part of the boot module set, which is why it's so widely used)
15:54:27 <koz_> Which would make sense. However, I'd like to see what other options are out there first.
15:54:39 <andromeda-galaxy> probably a good idea
15:55:26 <koz_> I'm still new to Haskell, so a lot of library learnin'.
15:55:34 <koz_> But I've mostly made sense of attoparsec.
15:55:45 <koz_> Which has allowed me to write something in Haskell which I have *never* written in any other language.
15:56:28 <andromeda-galaxy> that's nice, parser combinator style libraries are awesome (and, in my experience, a good way to cement an understanding of Functor/Applicative/Monad)
15:56:50 <andromeda-galaxy> and they're way easier to learn that Bison (no reduce/reduce conflicts!)
15:57:42 <koz_> andromeda-galaxy: I agree on that much - Bison is still very operational.
15:57:48 <koz_> While attoparsec is like, super-duper declarative.
15:58:29 <Zekka|Sigfig> koz_: Check out string scanning in Icon! (an imperative language where backtracking is a main feature)
15:58:42 <andromeda-galaxy> koz_: that's a nice way of putting it.
15:58:53 <andromeda-galaxy> Zekka|Sigfig: I should check out icon one of these days, thanks for the reminder
15:59:24 <Zekka|Sigfig> Prolog also has backtracking-flavored parsing through dcgs, although I don’t enjoy working with dcgs
15:59:27 <koz_> Hmm, it seems pretty is very much about formatting bricks of text.
15:59:38 <koz_> I basically want type-based pretty prints.
15:59:49 <andromeda-galaxy> koz_: pretty-show, then?
15:59:57 <andromeda-galaxy> @hackage pretty-show
15:59:57 <lambdabot> http://hackage.haskell.org/package/pretty-show
16:00:12 <koz_> Wow, Haskellers have thought of everything!
16:00:26 <andromeda-galaxy> koz_: "the ppsh tool uses the library to produce human-readable versions of Show instances"
16:00:50 <Zekka|Sigfig> (I just feel obligated to pop my head in and point out that Haskell didn’t invent backtracking, when someone talks it up. I like Parsec more than any other parser library I’ve used though)
16:00:56 <johnw> just watch out, it can be very slow with large outputs, because it does indentative formatting
16:01:47 <koz_> As an aside - I will awesome-haskell actually engaged in curation rather than just be a bunch of Hackage links.
16:01:52 <koz_> s/will/wish
16:02:56 <andromeda-galaxy> koz_: wow, I somehow didn't know about awesome-haskell until now.  that would be nice, indeed.
16:03:37 <koz_> andromeda-galaxy: It's my first port of call when learning a new language. I also happen to be the maintainer of awesome-c. :P
16:03:42 <koz_> (well, the original)
16:04:28 <andromeda-galaxy> koz_: ah, that makes sense.  I'll have to look into those lists more next time I learn a new language (and I'll definitely check out the C one)
16:04:45 <koz_> andromeda-galaxy: https://notabug.org/koz.ross/awesome-c <-- for future refence ;)
16:04:54 <koz_> And there's a *lot* of variety in quality.
16:05:05 <koz_> Some awesome-* lists are very good, others are ... less so.
16:05:32 <andromeda-galaxy> seems like it.  awesome-c looks really nice, thanks for the link
16:05:49 <koz_> andromeda-galaxy: You're welcome! Hopefully it comes in useful. :)
16:06:11 <andromeda-galaxy> indeed, I'm sure it will :)  Hopefully I've been some help to you as well..
16:06:33 <koz_> andromeda-galaxy: You've been a *lot* of help actually.
16:07:04 <andromeda-galaxy> great, glad to be able to help (and I hope that youy have a nice time in Haskell-land).
16:08:00 <koz_> I am having a *great* time in Haskell-land. The community here is awesome.
16:09:20 <andromeda-galaxy> koz_: great! come back if you have any other questions, someone will answer them.
16:10:54 <koz_> andromeda-galaxy: It's what's been happening a lot. For me, the difficulties are mostly library-related these days.
16:13:12 <huylv> could someone plz explain this: reverse' xs = foldr (\x fId empty -> fId (x : empty)) id xs []
16:14:02 <koz_> huylv: It basically rebuilds the list from its conses, starting from the last.
16:14:07 <koz_> The 'foldr' part is key.
16:14:25 <huylv> I can't seem to understand the anonymous func
16:14:36 <huylv> why does it take 3 args instead of 2?
16:14:50 <koz_> huylv: Currying - it leaves the last one free.
16:15:15 <huylv> some where does the last one come from?
16:15:26 <koz_> There's three arguments after the lambda.
16:16:23 <koz_> Also, the lambda takes three arguments because foldr expects a 3-argument function.
16:16:26 <koz_> :t foldr
16:16:27 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:17:28 <huylv> foldr take 3 args, the 1st one is the anon func, the 2nd is the id func, the 3rd is the array
16:17:34 <huylv> right?
16:18:00 <huylv> and the 4th, i suppose, should be what would be filled
16:18:12 <koz_> foldr takes 3 args, yes. The first one is the function it uses to 'fold', the second is the starting point, the last is the thing you want folded.
16:18:13 <huylv> after a series of transformation, returned by the foldr
16:18:15 <koz_> For example:
16:19:48 <koz_> foldr (\x y -> x + y) 0 [1, 2, 3]
16:20:48 <johnw> koz_: or just foldr (+) 0 [1, 2, 3], or just sum [1,2,3]
16:21:39 <huylv> I understand the foldl/r things
16:21:52 <huylv> what I don't get is the 3rd arg inside the anon func
16:22:15 <Enigmagic> the return type?
16:22:28 <huylv> reverse' xs = foldr (\x fId empty -> fId (x : empty)) id xs []
16:22:36 <huylv> the 'empty' one
16:22:38 * hackagebot trivial-constraint 0.4.0.0 - Constraints that any type, resp. no type fulfills  https://hackage.haskell.org/package/trivial-constraint-0.4.0.0 (leftaroundabout)
16:23:31 <huylv> how should I translate the whole function?
16:24:24 <andromeda-galaxy> @ty foldr
16:24:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:24:27 <Zekka|Sigfig> huylv: Maybe you should try to find the type of the function inside, and see what that tells you
16:24:35 <Zekka|Sigfig> :t (\x fId empty -> fId (x: empty))
16:24:36 <lambdabot> a -> ([a] -> r) -> [a] -> r
16:24:55 <andromeda-galaxy> = a -> ([a] -> r) -> ([a] -> r)
16:25:07 <Zekka|Sigfig> :t foldr `asAppliedTo` (\x fId empty -> fId (x: empty))
16:25:08 <lambdabot> Foldable t => (a -> ([a] -> t1) -> [a] -> t1) -> ([a] -> t1) -> t a -> [a] -> t1
16:25:21 <Zekka|Sigfig> (pretend t is [])
16:25:25 <andromeda-galaxy> huylv: that's the same as (\x fId -> (\empty -> fId (x : empty)))
16:25:51 <huylv> alright, thanks andromeda-galaxy 
16:26:00 <huylv> I'm stupid to not see that :D
16:26:36 <andromeda-galaxy> kuylv: everyone has lots of type confusions of that kind at first.  glad to be able to help!
16:27:18 <huylv> couldn't think it would be so helpful here
16:27:33 <huylv> will write these down on paper to see how far I can get :D
16:29:09 <`Guest00000> hmmm... importing foreign functions without IO tag on result type...
16:29:18 <`Guest00000> is kinda like performIO, right?
16:29:29 <Zekka|Sigfig> Well, do those functions do IO?
16:29:45 <Zekka|Sigfig> (or more broadly, would they have to be tagged with IO if they had been written in pure Haskell?)
16:30:07 <`Guest00000> Zekka|Sigfig: they aren't *supposed* to...
16:33:52 <`Guest00000> Zekka|Sigfig: aren't those same things?
16:34:17 <Zekka|Sigfig> `Guest00000: Well, there’s an argument that random number generation isn’t literally IO, because it’s confined to your program
16:34:30 <Zekka|Sigfig> IO is basically a grab bag for things that are hard to account for — it just happens that IO is an example of that sort of thing
16:34:55 <Zekka|Sigfig> it just happens that input/output is an example*
16:35:11 <monochrom> to be sure, IORef is also confined to your program
16:35:40 <Zekka|Sigfig> Yeah, IORef is also an example of “not literally doing input/output, but marked IO"
16:35:49 <monochrom> the problem is that Haskell 2010's IO is really interact-with-outside I/O stuff. at least 99%.
16:35:51 <Zekka|Sigfig> (random number generation is probably implemented in terms of IORef, in fact!)
16:36:25 <monochrom> I'm of course making up the number 99%.
16:38:48 <ski> 99% of all statistics used in conversation is made up
16:39:40 <monochrom> just add "studies find that" and you're super awesome :)
16:40:03 <monochrom> but did you know of a cute quote of mine?
16:40:03 <maerwald> that sounds scientific
16:40:11 <monochrom> @quote monochrom Kripke
16:40:12 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
16:42:16 <ski> i'm interested in learning more about these "damn truths" (the other being more familiar)
16:42:22 <monochrom> haha
16:42:48 <monochrom> damn truths are the dual of damn lies. that's all.
16:43:18 <hpc> truths, damn truths, and measurements
16:44:01 * ski would rather have assumed that "damn" was a modal operator, probably of the "necessary"-type
16:44:17 <hpc> @let damn = error
16:44:18 <lambdabot>  Defined.
16:44:20 <hpc> > damn "i broke it"
16:44:22 <lambdabot>  *Exception: i broke it
16:44:22 <johnw> I'm wondering if damn is free or forgetful
16:46:20 <hpc> we could make a haskell version of the carp module for uselessly arcane error management
16:46:29 <hpc> damn, whoops, dang, gadzooks
16:46:38 <hpc> and the inline version, ?$%!
16:47:01 <monochrom> :)
16:47:22 <monochrom> do they use unsafePerformIO?
16:47:37 <hpc> i hope so!
16:47:48 * hackagebot nano-erl 0.1.0.0 - Small library for Erlang-style actor semantics  https://hackage.haskell.org/package/nano-erl-0.1.0.0 (TomMurphy)
16:48:20 <monochrom> reallyUnsafeInterleavePtrEqualityPerformIO
16:48:33 <hpc> one of my coworkers was at one point a big proponent of carp because he couldn't handle perl's lack of exceptions
16:48:59 <hpc> monochrom: reallyUnsafeInterleaveDupablePtrEqualityPerformIO
16:49:08 <monochrom> yeah
16:49:21 <hpc> :: ST s a -> s
16:49:32 <monochrom> whee!
16:50:34 <hpc> man, if only i could find an excuse to make it look like Prelude and stick it in acme-php
16:50:48 <Xe> acme-php?
16:50:54 <hpc> oh are you in for something
16:51:02 <Xe> oj no
16:51:04 <Xe> oh no*
16:51:09 <hpc> http://hackage.haskell.org/package/acme-php-0.0.3/docs/src/Prelude-PHP.html
16:51:17 * ski . o O ( `newState# :: exists s. State# s' )
16:51:35 <Xe> hpc: are you insane
16:52:02 <monochrom> I am.
16:52:14 <hpc> no  you aren't, i am insane
16:52:16 <hpc> you be something else
16:52:24 <shachaf> @quote unsafeCoerce#.is
16:52:24 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
16:52:34 <monochrom> haha
16:52:46 <monochrom> I guess it's kind of hard to break kinds.
16:53:09 <monochrom> what does it mean to convert Monad to Monoid?
16:53:28 <hpc> unsafePerformCategoryOfEndofunctors
16:53:29 <monochrom> I guess we actually know
16:53:30 <ski> how to coerce a `Maybe Foo' into an `Int#', then ?
16:53:34 <monochrom> yeah, like that :)
16:54:16 <ski> (coercing into/from an unboxed tuple seems stranger)
16:55:38 <hpc> wasn't there talk of ghc getting the ability to keep a call stack?
16:55:45 <monochrom> yes
16:55:52 <hpc> does it exist yet?
16:56:08 <monochrom> I think yes. but I haven't tried.
16:56:27 * hpc is tempted to make an acme-carp that's just a direct port of perl's carp with nothing changed
16:56:32 <ski> for foreign stuff ?
17:01:36 <maerwald> whenever I hear perl, I shudder
17:01:59 <hpc> i say this completely seriously, perl is my favorite functional language
17:02:05 <hpc> haskell is my favorite imperative language
17:02:13 <maerwald> oh my
17:02:40 <hpc> haskell's IO is just fantastic, and perl allows a lot of convenient shennanigans
17:02:47 <maerwald> that sounds awful, tbh
17:02:49 * hackagebot nano-erl 0.1.0.1 - Small library for Erlang-style actor semantics  https://hackage.haskell.org/package/nano-erl-0.1.0.1 (TomMurphy)
17:03:02 <rcyr> hpc: Perl is not functional though...
17:03:05 <maerwald> haskells IO is awkward and nowhere near fantastic
17:03:39 <hpc> rcyr: there's an entire book on functional programming in perl
17:03:59 <rcyr> And? If the language doesn't encourage FP, then it's not a FP language.
17:04:00 <maerwald> yeah, let's try OOP in prolog... why not, you can probably hack up something
17:04:26 <Zekka|Sigfig> maerwald: google logtalk
17:04:27 <ski> maerwald : "Pillow" ?
17:04:40 <rcyr> I mean... I wrote a small FP lib for PHP... but I would never say that it is a FP language.
17:04:57 <hpc> it is if you use it as one
17:04:58 <maerwald> you can do FP-like stuff in Swift, but it's not FP either
17:05:03 <hpc> it may not be a good one, but it works
17:05:32 <maerwald> hpc: I suggest you use the language what its good at instead
17:05:38 <Zekka|Sigfig> What’s not FP-like about swift? I thought it was basically an ML flavor with imperative syntax
17:05:46 <hpc> that's how javascript can be "multi-paradigm"
17:05:48 <Zekka|Sigfig> (I am not primarily, or even secondarily a Swift programmer)
17:05:54 <hpc> maerwald: perl is very good at FP
17:06:08 <maerwald> no
17:06:14 <hpc> yes?
17:06:18 <maerwald> Zekka|Sigfig: are we talking about the same Swift? The Apple thing? If so... no, it's not FP
17:06:22 <geekosaur> swift is compiled javascript with some type concepts lifted from the MLs
17:06:30 <geekosaur> emphasis on *some*
17:06:54 <Zekka|Sigfig> Maybe I’ve got a conceptual gap here
17:06:58 <hpc> i have used perl to good effect when writing functional code
17:07:07 <hpc> ergo it can be a good functional language
17:07:15 <geekosaur> that it does type inference owes less to ML than it does to efficiently compiling a dynamically typed language
17:07:23 <johnw> swift bills itself as "multi-paradigm": OO, FP, imperative, block structured
17:07:25 <hpc> that's how javascript gets away with being "multi-paradigm"
17:07:31 <maerwald> I've done programming in Swift and if you want to do serious FP... then you end up recreating a whole lot yourself. And in the end, you still have no real currying and everything is just a pain.
17:07:39 <hpc> it's capable of doing well in several styles
17:08:05 <maerwald> johnw: it's almost a lie, I'd say...
17:08:07 <hpc> lisp has no real currying either ;)
17:08:11 <Zekka|Sigfig> Because it doesn’t seem like “fp” means “avoids side effects” or else most flavors of Lisp aren’t one — it doesn’t mean “evaluation order is generally unimportant” or else Prolog is out — it doesn’t mean “strongly typed for safety” or else most lisps are out again. It might mean you define your own flow control — that doesn’t seem to exclude anything too big
17:08:11 <Black0range> Are there any way i can make haskell understand that these two are diffrent? http://lpaste.net/150527
17:08:19 <maerwald> they like to sell it that way, but FP-wise, it's a joke
17:08:36 <rcyr> Lisp isn't a FP language.
17:08:38 <Zekka|Sigfig> There’s a few ostensible FP languages that don’t even try to imitate the lambda calculus
17:08:39 <maerwald> and you have literally _no_ FP-like library
17:08:42 <johnw> maerwald: does it at least have closures?
17:08:46 <geekosaur> um? many do reject the idea that Lisp is FP. as for Prolog, I couldn't call it FP, I'd call it a logic language
17:08:47 <maerwald> yeah
17:08:48 <hpc> Zekka|Sigfig: it's tricky because programming style is... well style
17:08:55 <geekosaur> s/couldnt't/wouldn't really/
17:08:59 <hpc> Zekka|Sigfig: not really a checklist but a way of thinking about a problem
17:09:02 <maerwald> johnw: you can write your own curried functions, but you have to do that manually every time
17:09:03 <johnw> maerwald: are functions first class values?
17:09:03 * ski . o O ( Prolog is a Logic Programming language )
17:09:19 <hpc> btw haskell's type system is a logic language
17:09:22 <Zekka|Sigfig> I’m trying to *very strongly suggest* that this nomenclature is spretty arbitrary
17:09:24 <hpc> haskell's type system is part of haskell
17:09:27 <hpc> haskell is a logic language
17:09:30 <maerwald> johnw: I don't think so
17:09:34 <ski> hpc : except no back-tracking :(
17:09:41 <rcyr> ski: I never used Prolog... always wondered if it was worth learning
17:09:45 <hpc> ski: unification!
17:09:46 <ski> rcyr : imho, it is
17:09:54 <maerwald> johnw: depends on what you mean by that maybe
17:10:04 <Zekka|Sigfig> Let’s throw more crap into the mix: is Erlang a functional programming language or an imperative one?
17:10:10 <hpc> prolog is a different type of language, learning it will make you a better programmer
17:10:11 <maerwald> there are like 3 different ways to define a function in swift
17:10:13 <hpc> Zekka|Sigfig: yes
17:10:23 <`Guest00000> ski: list monad
17:10:34 * geekosaur agrees with hpc re erlang
17:10:39 <rcyr> ski: It is mindblowing like learning Haskell when you've only done mainstream languages?
17:10:40 <Black0range> Will try again! Are there any way i can make haskell understand that these two are diffrent? http://lpaste.net/150527? 
17:10:42 <`Guest00000> looks like that to me..
17:10:45 <ski> rcyr : it has lots of flaws, but i still think it's worth it. after learning it, you can tackle Mercury, which has less flaws, and has borrowed some things from FP and Haskell
17:10:49 <geekosaur> in many ways these things are not mutually incompatible
17:10:56 <ski> `Guest00000 : list monad doesn't give you logic variables
17:11:10 <ski> (iow, what hpc called "unification")
17:11:28 <geekosaur> Black0range, not without a newtype
17:11:43 <hpc> Black0range: you're really getting swallowed by more contentious arguments, but it's at the very least not encouraged
17:11:54 <ski> someones one groups Functional Programming and Logic Programming together under the umbrella of Declarative Programming
17:11:58 <Zekka|Sigfig> rcyr: My personal experience: most of the things I have ever excused as “I don’t need to know this, I already know a thing that supercedes it” turned out to be different from what I thought they were
17:12:01 <hpc> you can't prove ClassA and ClassB are mutually exclusive, so the instances overlap
17:12:22 <hpc> and even in an ideal world, which it would pick is arbitrary
17:12:31 <hpc> in the cases where overlap can happen
17:12:44 <Black0range> hpc: theres no way to say "i promise there will be no overlapsies!"?
17:12:57 <ski> rcyr : "It is mindblowing ..." -- imho, yes
17:13:11 <rcyr> Zekka|Sigfig: I know, it's just that my time is limited... and I'm still learning the Haskell world :/
17:13:14 <hpc> there's probably ways, but i am too into this language theory stuff to switch gears and think of them
17:13:28 <Zekka|Sigfig> ski: Then you mention CHR — a vaguely logical language (only in the sense that it supports unification) with no inbuilt notion of a function, all about manipulating global state!
17:13:34 <hpc> type families, maybe?
17:13:46 <Black0range> hpc: tried, doesn't work :(
17:13:48 <hpc> or newtype the list as a hack
17:13:58 <hpc> newtype ClassBWrapper a = Wrap [a]
17:14:09 <hpc> and instance that
17:14:19 <ski> rcyr : perhaps to a lesser extent than Haskell (including all the type stuff), but still very different from traditional Imperative Programming, and so worth learning
17:14:21 <hpc> as geekosaur suggests
17:14:34 <Black0range> was hoping for something less hacky :/
17:14:41 <hpc> yeah
17:14:54 <rcyr> ski: It's on my... already long list, of things to learn :P
17:15:01 <rcyr> *now on
17:15:08 <Black0range> But don't let me interupt your arguments! By the way why isn't lisp a functional language? 
17:15:12 <hpc> classes are a very hard place to put most types of logic, due to their "global" and "unique" nature
17:15:49 <Zekka|Sigfig> Black0range: A lot of people claim that Lisp is not functional because lisp dialects historically make a lot of use of mutation and most of them don’t have static type systems
17:15:50 <hpc> Black0range: arguably, because it has mutability, special syntax for functions-as-values, no currying, distinction between macros and functions, etc
17:15:55 <ski> Black0range : Scheme is more used as an FPL, imho
17:16:06 <hpc> distinction between macros and functions is the big one
17:16:21 <rcyr> Lisp doesn't encourage FP programming, the escape hatch to mutability is too easy to use.
17:16:22 <ski> hpc : imho, the "distinction between macros and functions" point is moot
17:16:29 <hpc> it can be used as a functional language, but that's the first point where most people go "fuck this"
17:16:43 <Zekka|Sigfig> I don’t like saying “Lisp is not a functional programming language” because usually that’s a prelude to “I don’t want to consider it because it doesn’t match my prejudices which I call FP"
17:17:08 <hpc> ultimately, for all the checkboxes lisp doesn't check
17:17:14 <Black0range> Should realy "its easy to mutate" be an agrument if a language is functinal or not? It's still based on lambda calculus 
17:17:28 <hpc> it makes you think to at least some extent in terms of code as data
17:17:32 <maerwald> Black0range: yeah, I think mutability is somewhat orthogonal
17:17:32 <ski> Zekka|Sigfig : imho, the static type system part is not that important here
17:17:35 <Zekka|Sigfig> For instance, there are people even in this channel who think that languages with easy mutation cannot be placed under the FP umbrella!
17:17:38 <hpc> which is a pale cousin of functions as values
17:18:01 <hpc> (it's at a syntactic level rather than a semantic level, but services the same need)
17:18:13 <hpc> fwiw, haskell has easy mutation
17:18:18 * ski nods
17:18:23 <hodapp> I do think that a whole lot of FP is rather incomplete when mutation and side effects are that easy.
17:18:23 <hpc> IORef is a piece of cake to use, just in specific places
17:18:31 <`Guest00000> Black0range: from what i've learned recently, "instance A (F x) => B (G x)" doesn't just say "if there is A (F x), then also B (G x)"; rather, "there is B (G x) for ALL x, and there MUST also be A (F x) if you use B's methods"
17:18:39 <hpc> or MVar, or Chan, or TVar
17:18:42 <hpc> or ST
17:18:47 <Zekka|Sigfig> ski: I’m just regurgitating claims I’ve seen previously by people who had imho a really opinionated definition of FP as well as a lot of prejudice against things falling outside that boat
17:19:00 * ski nods
17:19:09 <hpc> under this "how the programmer thinks" umbrella, some other things of note:
17:19:12 <geekosaur> people are still people, film at 11
17:19:23 <hpc> C is a high-level assembly language
17:19:31 <hpc> java is still only object-oriented
17:19:44 <hpc> bash is a file language
17:19:50 <maerwald> and perl is the ultimate FP language, yeah yeah
17:20:02 <hpc> ppsh, perl is terrible for FP
17:20:04 <Black0range> `Guest00000: thats a pretty good explanation
17:20:14 <EvanR> and haskell is the best imperative language, or is that the topic already
17:20:20 <hpc> :P
17:20:21 <maerwald> haskell is terrible at FP
17:20:24 <maerwald> err
17:20:26 <maerwald> imperative
17:20:32 <hpc> haskell for president
17:20:34 <`Guest00000> Black0range: also, you can't really promise that these don't overlap, because of Haskell's "open world assumption"
17:20:40 <EvanR> it literally has do in the syntax
17:21:01 <`Guest00000> : even if your modules don't have these instances, mthey mightbe defined somewhere else.
17:21:20 <maerwald> when you've used a LOT of imperative style C bindings in haskell, then you realize it's not pleasent after all and you don't get any real benifit. Some things get way more ugly
17:21:30 <aib> hmm, I thought any covering set of (==, /=, <=, <, >, >=) definitons would've given me a complete Ord definition. Turns out it doesn't (A < B = True, A == B = False, A <= B does not halt). Why not?
17:21:30 * hpc blatantly totally changes the topic back to "languages that make you a better programmer"
17:21:35 <hpc> excel formulas are good to learn in depth
17:21:56 <Black0range> hpc: Java!!!
17:21:58 <hpc> they're a good example of reactive programming, which is the first step to FRP
17:22:04 <Black0range> hpc: makes me love anything else! 
17:22:30 <hpc> @src (<=)
17:22:30 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
17:22:33 <maerwald> FRP is not there yet, too complicated in some areas, not really mature on implementation level
17:22:36 <hpc> @src compare
17:22:36 <lambdabot> compare x y | x == y    = EQ
17:22:36 <lambdabot>             | x <= y    = LT
17:22:36 <lambdabot>             | otherwise = GT
17:22:38 <geekosaur> aib: the minimal definition of Ord is (==) (from the Eq dependency) and either compare or <=
17:22:51 <Zekka|Sigfig> I’m not entirely convinced I know what FRP is
17:22:53 <hpc> aib: looping through (<=) and compare
17:23:04 <hpc> aib: (<) isn't part of the minimal complete definition
17:23:06 <geekosaur> compare is defined in terms of (<=) and (==), eerything else is defined in terms of those
17:23:09 <EvanR> Zekka|Sigfig: no one is, anymore
17:23:11 <Zekka|Sigfig> People increasingly label things eihter “reactive” or “FRP” and I don’t know why they fall into that bucket
17:23:18 <hodapp> Zekka|Sigfig: try asking conal, as he coined the term.
17:23:21 <Zekka|Sigfig> Yeah, I used to think I was pretty sure because I saw a conal talk
17:23:32 <hodapp> and also has a strange tendency to appear at random when FRP is mentioned
17:23:35 <ski> aib : paste your code ?
17:23:35 <hpc> Zekka|Sigfig: it's an odd bucket, but a fairly specific one
17:23:37 <Zekka|Sigfig> I don’t know if conal controls the definition at this point. (I think I liked his version)
17:23:52 <maerwald> hodapp: is it really random then?
17:24:16 <Zekka|Sigfig> hpc: Let me actually ask a prelude question. Is there more than one bucket masquerading as one bucket?
17:24:34 <Zekka|Sigfig> Because my gutfeeling is that there’s probably a few pretty specific designs that people are clustering around — I don’t think it’s literally just a buzzword
17:24:36 <conal> i think paul hudak coined the term. i was calling it "reactive behavior modeling" or some such when i met paul.
17:25:10 <EvanR> as far as haskell is about "no compromise", most FRPs out there are a big comprimise inspired by FRP
17:25:15 <aib> hmm, I guess my question is, couldn't the cyclic definition of <= and compare have included <, and maybe > and >= ?
17:25:21 <hpc> Zekka|Sigfig: i haven't totally mastered FRP because i have other things to do, but it's on my list and there's really just one big point
17:25:23 <EvanR> which sucks
17:25:33 <hpc> Zekka|Sigfig: which is defining changing values in terms of other changing values
17:25:37 <Zekka|Sigfig> Evan	R: Seemsl ike there’s a uniting feature of “we don’t want to have to write our own callback function”?
17:25:46 <hpc> so like, you define a cell in excel that's the sum of column B
17:25:53 <maerwald> hpc: and now get the "regular" programmer to understand it... not there yet, on a lot of levels
17:25:59 <EvanR> Zekka|Sigfig: i guess if FP is about not wanting to have to write for loops... then ok
17:26:00 <hpc> and then any change in column B automatically updates that sum
17:26:09 <hpc> because there's a known dependency
17:26:13 <hodapp> In general, when a term becomes so substantially watered-down that it begins to encompass anything (like 'OOP'), I tend to defer to older definitions that are more strict.
17:26:15 <Zekka|Sigfig> hpc: Yeah, that’s pretty consistent with most of the designs I’ve seen which were labeled that
17:26:35 <ski> aib : it would be nice to be able to give alternate default definitions, and have suitable ones picked (preferably automatically) in an instance ..
17:26:43 <hpc> that tracking the dependencies and updates is what FRP-style libraries hide away
17:27:00 <hpc> and you're able to define just the formulas and have some contraption behind the scenes change things
17:27:14 <hpc> there's applications all over the place, a particularly neat one is in games
17:27:24 <hpc> though i am not sure how far that's come, i stopped keeping track
17:27:38 <EvanR> "purely function GUI" is what im interested in
17:27:46 <EvanR> functional*
17:27:47 <geekosaur> aib, the more interdependencies like that, the harder it is to come up with a minimal definition that doesn't end up being the whole class
17:27:56 <EvanR> FRP promises to be all about that
17:27:58 * ski . o O ( Fudgets )
17:28:00 <EvanR> to solve that
17:28:03 <aib> hmm
17:28:21 <hodapp> EvanR: I'm interested in that too
17:28:24 <aib> ski: is that a "yes, that would be nice" answer? like how nice it is with == and /= ?
17:28:30 <hodapp> I worked with Qt, but only via C++ and Python
17:28:33 <hpc> it's in that weird Monad space where it's got uses everywhere but can't really be explained except by just learning how to use it and the "what" will reveal itself in time
17:28:34 <geekosaur> also note that you cannot provide a different default definitionfor one method based on what other methods were defined
17:28:36 <ski> aib : basically
17:28:37 <hodapp> I've not attempted to make any UIs in Haskell
17:28:40 <EvanR> Qt, GTK, etc are al awful
17:28:54 <Zekka|Sigfig> I used Elm for a while but I didn’t enjoy it — I am not an authority on the gui situation in Haskell
17:28:56 <hpc> hodapp: i have attempted, it's really hard
17:28:57 <hodapp> I didn't mind Qt much but I felt it went to huge lengths to work around C++'s... C++ness
17:29:04 <hpc> hodapp: though for myself it might be because i work on windows
17:29:27 <`Guest00000> hodapp: what would be C++-ness?
17:29:36 <hpc> that should be changing once i need a new machine though, new windows versions have made me a linux guy ;)
17:29:50 <maerwald> haskell doesn't have a useful GUI library that is really haskell-ish, yeah
17:29:57 <geekosaur> hodapp: the KDE devs I've talked to (granted, a very sall subset, maybe 3 of them) would agree with you
17:30:48 <aib> geekosaur: sorry, still thinking
17:30:48 <hodapp> `Guest00000: in this sense, the things like templates and much of the use of the type system, and instead they built an extensive meta-object protocol atop this that other languages could interface with a bit better
17:30:59 <hodapp> geekosaur: good to know
17:31:19 <hodapp> at least, I *think* meta-object protocol is what I mean
17:31:27 <hodapp> I don't have a great intuitive definition in my head for MOP
17:31:46 <EvanR> meta protocol object
17:31:50 <EvanR> object meta protocol
17:31:50 <hpc> http://hop.perl.plover.com/ -- from earlier
17:32:44 <hpc> from a haskell perspective it's pretty shallow (but then, so is even SICP)
17:32:48 <hpc> but it gets the idea across
17:32:59 <hodapp> I have liked SICP so far
17:33:10 <hpc> it's a good book, but not state of the art
17:33:21 <hodapp> I like how it goes about presenting examples that give the point of different kinds of abstraction
17:33:25 <hpc> it's one of the books that made me a good programmer
17:33:36 <hodapp> I'm still reading it myself
17:33:57 <EvanR> i would have liked if SICP talked about type safety and the implications of dynamic typing 
17:34:01 <EvanR> in retrospect
17:34:27 <aib> geekosaur: so it's not possible to define < <= >= > all in terms of eachother? I mean in a way where the library would have the default definitions and the user would only have to give one (in addition to == or /=)
17:34:29 <EvanR> i.e. how someone with experience with static types would/could use the system despite itself
17:34:52 <ski> @quote Sarah
17:34:52 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
17:34:52 <hpc> i have this weird hole in my memory where i remember reading SICP and what was in it, but not when i read it or where i was
17:34:54 <geekosaur> aib, not without knowing whch ones have actual definitions
17:35:05 <geekosaur> as opposed to depending on you being defined
17:35:30 <hpc> it was definitely pre-haskell though
17:35:35 <geekosaur> unless you reduce it to a minimal set. either (<=) or (>=) would have done there, I don't know why they picked (<=)
17:36:02 <hpc> geekosaur: i guess they didn't want to write a ring of 3 mutual definitions
17:36:33 <aib> geekosaur: convention, I think. -- anyway, yeah, that makes sense
17:36:39 <hpc> it has to be a ring too, in order to loop back to one of them
17:36:42 <ski> aib : one'd have to be able to give multiple alternative definitions
17:36:42 <hpc> from each
17:37:10 <ski> (in the general case, at least)
17:37:12 <aib> I'd always thought there was a prolog-esque logic to how haskell let you define either == or /= , either compare or <= .
17:37:42 <`Guest00000> ...
17:37:43 <ski> it's just breaking the cycle of mutual recursion, as in open recursion
17:37:55 <`Guest00000> in a dependently typed language, would types exist at runtime?
17:38:00 <aib> turns out it was a simple 2-long cyclic definition, and it's up to the user to break one of the chains
17:38:11 <`Guest00000> since they are first-class
17:38:11 <aib> links*
17:38:34 <hodapp> I don't know that dependent typing means that types are first-class
17:38:58 <hpc> afaik agda is an example of type erasure in DT languages
17:39:03 <EvanR> `Guest00000: if you are interpreting a program its useful to retain everything so evaluation can stop and show you where it was at
17:39:11 <hpc> it compiles to haskell and i can't think of a reason for the types to stick around
17:39:12 <ski> `Guest00000 : i suppose it would depend on whether you can distinguish types at run-time
17:39:15 <EvanR> but youd want to erase types for compilation
17:39:36 <hodapp> Agda compiles to Haskell?
17:39:47 <hpc> hodapp: not pretty haskell, i can tell you that
17:39:52 <hodapp> :P
17:40:10 <hpc> actually agda might keep some type information at runtime
17:40:28 <hpc> since it can express type parameters as actual parameters
17:40:29 <ski> `Guest00000 : cf. "The universe is indiscrete" by Martín Escardó,Thomas Streicher in 2013-11-16 at <http://www.cs.bham.ac.uk/~mhe/papers/universe-indiscrete.pdf>
17:40:36 <EvanR> `Guest00000: when "types" means static types, i think of types being definitely not a runtime concept
17:40:47 <hpc> someone who has kept better track than me will have to answer
17:41:16 <hpc> EvanR: types that don't get enforced before code is executed are enums ;)
17:41:42 <EvanR> runtime classification, tagged data, dynamic typing
17:42:13 <aib> what if we had a magical "oneOf" function, [a] -> a and did: compare x y = | oneOf([x <= y, (x < y) && (x /= y), not (x >= y), not (x > y) && (x /y)]) = LT | etc. -- would that work?
17:42:44 <hpc> sounds like spoon
17:42:58 <hpc> but it would be the bad kind of magic
17:43:32 <gfixler> Non type-variable argument in the constraint: Num (Expr a)
17:43:40 <gfixler> eval :: Num a => Expr a -> a
17:43:50 * hpc should probably sleep
17:44:01 <gfixler> how is there a non type-variable argument in the constraint?
17:44:06 <gfixler> is it the Expr?
17:44:11 <diggle> What's the difference between stack install x and adding x to stack.yaml?
17:44:35 <EvanR> where do you see Num (Expr a)
17:45:03 <gfixler> I'm not sure I follow
17:45:12 <mgsloan> diggle: "stack install x" means "build x and if there are any executables, copy them"
17:45:25 <EvanR> eval :: Num a => Expr a -> a, doesnt contain Num (Expr a)
17:45:55 <lostman_> hi all. I'm getting a strange build error on Windows and I'm not quite sure how to tackle it: "can't load .so/.DLL for: stdc++.dll (addDLL: could not load DLL)". This is a build on AppVeyor via stack. Started to happen after I added formatting as dependency
17:46:06 <diggle> mgsloan: Hm. Is there any difference from doing stack install x and adding it to stack.yaml? I mean does it add it to stack.yaml for me?
17:46:11 <gfixler> EvanR: that's from the error in GHCi
17:46:17 <gfixler> for eval (Add 7 3)
17:46:43 <EvanR> try replacing 7 with (7 :: Int)
17:47:14 <gfixler> lols
17:47:15 <mgsloan> diggle: There are a few different ways to add something to a stack.yaml - I suggest reading the docs at haskellstack.org
17:47:18 <gfixler> I knew it was some dumb thing
17:47:20 <gfixler> EvanR: thanks
17:47:24 <gfixler> brain glitch
17:47:26 <EvanR> no idea what the error was about
17:47:36 <gfixler> yeah
17:47:41 <EvanR> or eval (Add 7 3) :: Int
17:47:43 <`Guest00000> dependent types are really awesome...
17:47:49 <gfixler> it wants me to use FlexibleContexts
17:47:53 <gfixler> which fixes the error
17:47:55 <mgsloan> If by adding x, it's doing someting like adding "x-1.0" to the extra-deps section of the config, then that just specifies the version of the package that will be installed if that package needs to be installed
17:48:04 <gfixler> but that's supposed to be for using concrete types in constraints
17:48:07 <gfixler> I'm not using any
17:48:13 <mgsloan> In other words, adding x to "extra-deps" does not even necessarily mean that x will be built
17:48:19 <gfixler> e.g. Num Int => etc
17:48:26 <EvanR> i guess some supporting thing with Expr uses Num (Expr a) somewhere
17:48:29 <gfixler> but I'm using Num a
17:48:36 <aib> geekosaur: could I bother you one more time? could you check my last message to channel? (I can repeat it)
17:48:46 <EvanR> which requires FlexibleContexts
17:48:51 <mgsloan> If it's in your "packages" list, then this means that it's one of the packages that make up your project, and will be built when you run "stack build"
17:49:16 <diggle> mgsloan: Oh, thanks. also, now that there's someone who can actually respond to my questions about stack :)...is there a way to make stack pull from hackage instead from stackage? I want to make a playground thing where I can pull random packages in and it wouldn't use the lts or nightly builds
17:49:25 <aib> geekosaur: I'm just wondering if it's technically possible. try all the different m.c.d. combinations, use the first one that works.
17:49:27 <geekosaur> aib, the problem is that that definition is magical. (it's more or less what I said, some way to know what definitions were actually supplied)
17:49:46 <geekosaur> but you cant just try one until you find one that works because "doesn't work" is usually nonterminating
17:49:53 <geekosaur> (see: halting problem)
17:50:25 <geekosaur> you could probably provide such a function for Ord, for most types.
17:50:42 <ski> maybe it could work with some kind of `lub'/`unamb' thing ..
17:51:12 <mgsloan> diggle: You can add the packages you want to use to your extra-deps list.  There are good reasons not to have a mode that just uses the latest from hackage, namely, that it's likely not to work
17:51:28 <aib> geekosaur: that's where I'm at. if we had a halting-safe "any" function, where any (nonhalting, True, nonhalting) = True?
17:52:53 <geekosaur> I have doubts about being able to do "halting-safe" in a truly general way
17:53:02 <conal> ski: that's my inclination
17:53:09 <conal> The semantics of lub is very simple and is at the heart of what recursion means.
17:53:23 <diggle> mgsloan: Hm, you're right, but that's annoying when a package has lots and lots of dependencies. Maybe I could use stack solver though. Off to read the docs.
17:53:37 <aib> geekosaur: breadth-first evaluation of multiple threads, so to speak
17:54:01 <EvanR> geekosaur: thats where domain specific languages come in
17:54:21 <aib> geekosaur: it's totally fine if the function doesn't halt if none of the inputs do. we wouldn't be any worse off, seeing as how my incomplete definition with < and == isn't halting, either.
17:54:22 <EvanR> we just need a culture of being able to make disposable DSLs
17:54:32 <ski> conal : .. however, i'd probably still long for a way to give multiple alternative default implementations :)
17:54:34 <conal> threads trash semantics, unlike lub.
17:55:19 <shachaf> lub is all you need
17:55:39 <conal> :)
17:55:48 <conal> pretty much
17:56:01 <aib> btw, can we use 'undefined' to represent a non-halting computation? and/or _|_ ?
17:56:51 <aib> sorry, google answered that
17:56:58 <EvanR> undefined = _|_
18:00:14 <hodapp> conal: what is lub?
18:00:27 <hodapp> (baby don't hurt me, don't hurt me, no more....... but seriously)
18:00:34 <conal> hodapp: least upper bound in information ordering.
18:01:15 <conal> hodapp: bottom (undefined) is called "bottom" because it's the bottom of this order.
18:01:33 <conal> i.e., no information at all.
18:02:06 <Ankhers> Using either Chan or TChan, how would I be able to mark it as no longer sending information to it?
18:02:40 <aib> so, given a "magicAny :: [a] -> a" which returns some non-bottom element if it exists, it should be possible to define compare/</<=/>=/>/==/(/=) all in terms of all of the others and have any user-defined covering set work, no?
18:03:27 <hodapp> conal: how's this relate to threads, though?
18:04:07 <conal> hodapp: in having a simple & precise denotation, unlike threads. 
18:04:40 <conal> threads are an imperative notion even in haskell, and they give rise to nondeterminism.
18:04:54 <EvanR> aib: yes
18:05:35 <EvanR> of course you still might get bottom, or you might never find out if it wouldnt return bottom
18:05:43 <EvanR> experimentally
18:05:44 <conal> which means models for them are complex. too complex for practical, dependable/rigorous reasoning. 
18:06:37 <conal> And haskell doesn't have a denotational model for IO (unlike most of the rest of the language), because of this complexity.
18:06:43 <`Guest00000> are there general books on type systems?
18:08:57 <aib> EvanR: of course. it's the problem inherent in magicAny. inherent in computation.
18:10:13 <aib> still, something to think about. I remember thinking Haskell did something along these lines (with Eq and Ord) and telling people how such a thing might change the way we think about programming
18:11:27 <aib> gotta ask those people what exactly that change was. I don't remember :S
18:13:27 <`Guest00000> is  (1, _|_) `unamb` (_|_, 2)  fine / not fine?
18:14:04 <conal> `Guest00000: the arguments are compatible, so that combo is fine (meets the applicability condition).
18:14:31 <conal> `Guest00000: oh, wait. use lub, not unamb. 
18:14:50 <`Guest00000> so, is this unamb usage not ok?
18:15:21 <aib> "the value of unamb u v is the more terminating of u and v" <-- I laughed too hard at this. Must be time to sleep :S
18:15:23 <conal> `Guest00000: right. unamb is lub for *flat* types, like Bool & Int. 
18:15:57 <`Guest00000> is the more terminating of you and me
18:15:57 * ski . o O ( domains )
18:16:01 <conal> There's a different lub definition for pairs, another for functions, etc.
18:17:05 <conal> since info ordering is defined differently on those non-flat constructions
18:18:14 <`Guest00000> does unamb 'check' only if the whole value is bottom?
18:18:48 <conal> `Guest00000: it can't (undecidable), and it needn't.
18:18:59 <conal> (so it doesn't)
18:19:24 <`Guest00000> no, i mean something different
18:20:34 <`Guest00000> hm...
18:20:46 <`Guest00000> in what sense are (1, _|_) and (_|_, 2) unequal?
18:25:12 <Cale> `Guest00000: fst (1, _|_) = 1, while fst (_|_, 2) = _|_, and I think we can agree that 1 is not equal to _|_ ?
18:26:19 <`Guest00000> 1 not being equal to _|_ is hard for me to understand
18:26:39 <`Guest00000> like, (1 == _|_ )  != False
18:27:42 <conal> `Guest00000: are you talking about computable equality, where the answer might be _|_? 
18:29:13 <`Guest00000> i've never thought of _|_ as a value
18:29:46 <`Guest00000> as a concrete value
18:30:25 <`Guest00000> but as a placeholder for 'any'
18:30:29 <`Guest00000> or something
18:31:03 <johnw> `Guest00000: it's an "inhabitant without meaning"; if you use it any context that requires it to mean something, it's undefined what happens
18:32:00 <conal> johnw: it's not about "happens" (doing). it's a well-defined value (being).
18:32:31 * ski tends to think of it as "no information"
18:32:39 <ski> (possibly adding a "yet", if you prefer)
18:33:06 <bitemyapp> #haskell-philosophy
18:33:16 <conal> ski: in the denotation, there's no "yet". 
18:33:16 <bitemyapp> #haskell-alfred-whitehead
18:33:30 <`Guest00000> so, how 1 can be not equal to _|_?
18:33:43 <conal> if a value is _|_, it will always be _|_, since values don't change.
18:34:07 <bitemyapp> I think it's a bit hard to dance around what bottom is and isn't unless you talk about proofs and judgments.
18:34:19 <bitemyapp> otherwise it gets into this weird semantic game about what bottom means
18:34:26 <bitemyapp> you could even make it about turing machines and halting
18:34:32 <conal> `Guest00000: it's true by definition. but you can't verify computably.
18:35:19 <`Guest00000> is _|_ magically non-equal to anything?
18:35:24 <ski> conal : with domains as a structure, there's clearly no "yet"
18:35:26 <conal> bitemyapp: there's a clear definition of bottom, without any reference to proof theory.
18:35:42 <bitemyapp> there are a few different angles you could take
18:35:45 <conal> `Guest00000: no more magically than 1 /= 2.
18:35:53 <ski> also, it probably helps here to distinguish between (propositional) equality, and equality checking
18:35:57 <bitemyapp> what angle is more salient or takes less time/effort to convey depends on the audience's background
18:36:14 <`Guest00000> this all is weird
18:36:17 <bitemyapp> if you haven't asked them what they do/do not know and don't care to, then the safe bet is to assume the most common background for IRC users
18:36:23 <bitemyapp> Cale: hey remember our conversation?
18:36:26 <bitemyapp> Cale: bingo ^^
18:36:48 <`Guest00000> i thought that equalness between 1 and _|_ was kinda undefined
18:36:58 <conal> `Guest00000: i'm talking about math equality on the domain of the meaning of Int/Integer in languages like Haskell. not computable equality.
18:37:13 * ski recalls some paper that used increasing sequences in domains to express "how much information do we have on the value yet ?"
18:37:53 <`Guest00000> i thought that equality wasn't defined for bottoms
18:38:04 <ski> `Guest00000 : two different kinds of equality
18:38:21 <conal> ski: sure. recursion is defined as a limit of a stream of monotonically non-decreasing partial values. you could think of that stream as a notion of time/yet I guess.
18:38:30 <`Guest00000> i mean "math equality"
18:38:35 <conal> `Guest00000: It's perfectly well defined, just not computable.
18:38:59 <conal> `Guest00000: _|_ == _|_ and is unequal to all of the non-bottom integers
18:39:26 <bitemyapp> conal: that's a fact that arises from some set of premises, not an explanation of what bottom is or means.
18:40:05 <bitemyapp> conal: I just checked /lastlog, doesn't seem like you've asked `Guest00000 anything about their background or what domains/explanations might be easiest for them to understand. Maybe that would help?
18:40:07 <conal> bitemyapp: agreed. i mean "bottom" from domain theory, as in the denotation of programming languages.
18:40:29 <`Guest00000> i have no background haha
18:40:35 <bitemyapp> conal: I don't think I've ever seen you ask someone if they know something before rattling off facts at them on IRC
18:40:47 <`Guest00000> i learn from internet
18:40:49 <bitemyapp> conal: most people on here are coming from, at best, a very poor undergrad CS education.
18:40:59 <bitemyapp> conal: MANY are self-learners with no background in anything formal at all
18:41:08 <conal> bitemyapp: i assume that `Guest00000 is adult enough to steer me in a way that's most useful.
18:41:21 <bitemyapp> conal: you aren't even giving them enough keywords to know what to ask about
18:41:41 <bitemyapp> conal: you're machine-gunning conclusions from unspoken, unnamed premises from domains and fields you haven't said you're leaning on
18:41:55 <conal> bitemyapp: okay. thanks for the feedback.
18:41:55 <bitemyapp> conal: like I said, I checked the lastlog. I know what you've said to them. It's not about being adult or not.
18:42:32 <conal> `Guest00000: what do you mean by "_|_"? perhaps we're talking about different things.
18:43:02 <johnw> conal: that's a very good point, thank you
18:43:54 <conal> bitemyapp: i mean that if someone would like a different sort of response, or to ask for definitions, etc, I assume they'll say something. that's what i meant by "adult" -- i.e., respectfully.
18:44:13 <bitemyapp> 02:38 < conal> `Guest00000: _|_ == _|_ and is unequal to all of the non-bottom integers
18:44:28 <bitemyapp> conal: what are they supposed to interrogate there?
18:44:43 <bitemyapp> conal: they probably know what each of those words individually mean.
18:44:48 <johnw> 18:40 <bitemyapp> conal: I don't think I've ever seen you ask someone if they know
18:44:49 <johnw>           something before rattling off facts at them on IRC
18:44:53 <bitemyapp> conal: they can probably take what you're saying for granted as a fact
18:44:55 <johnw> bitemyapp: that's needless inflammatory
18:44:58 <conal> bitemyapp: e.g., "oh -- what do you mean by _|_?" for instance.
18:45:09 <bitemyapp> conal: they probably cannot formulate a question that would necessarily go anywhere.
18:45:10 <conal> bitemyapp: are you thinking that `Guest00000 was somehow painful or discouraging. 
18:45:17 <conal> ?
18:45:42 <bitemyapp> I'm thinking your style is unnecessarily intimidating and doesn't do enough interrogation of what explanation would be helpful to the individual specifically
18:45:50 <bitemyapp> I don't think `Guest00000 has done anything wrong at all.
18:45:59 <johnw> bitemyapp: if you keep attacking conal for helping according to his style, I will devoice you
18:46:11 <conal> bitemyapp: wow. i had no idea someone would react that way. 
18:46:18 <conal> `Guest00000: is bitemyapp guessing correctly?
18:46:37 <Ygg> Hey
18:46:39 <Ygg> http://lpaste.net/4240616778381656064
18:46:44 <Ygg> Wat do
18:46:47 <bitemyapp> conal: do you understand my point about, "facts follow from premises, premises totally unspoken, no surface area that could lend itself to a question"?
18:46:48 <conal> bitemyapp: I mean my style as respectful, not talking down to people. not at all as intimidating.
18:46:55 <bitemyapp> conal: I know your intent
18:46:58 <bitemyapp> conal: that's not the point.
18:47:43 <bitemyapp> conal: if you're going to assume they know a particular field, at least name the field/domain you're leaning on before putting out facts that follow from a particular model or understanding of the concept at hand.
18:47:48 <johnw> Ygg: I haven't seen that in so long, I've forgotten the usual answers
18:47:52 * hackagebot beam 0.3.0.0 - A type-safe SQL mapper for Haskell that doesn't use Template Haskell  https://hackage.haskell.org/package/beam-0.3.0.0 (TravisAthougies)
18:48:06 --- mode: ChanServ set +o johnw
18:48:06 --- mode: johnw set -o johnw
18:48:11 --- mode: ChanServ set +o johnw
18:48:26 --- mode: ChanServ set +q *!*@198.199.80.102
18:48:43 <huylv> question about reverse' xs = foldr (\x fId -> (\xs' -> fId (x : xs'))) id xs [] ...(again)
18:48:49 <Ygg> At least it's reassuring that there ARE usual answers :D
18:48:55 * ski would like to hear what `Guest00000 thinks ..
18:49:36 <huylv> my understanding is that reverse' will apply id function to xn-1:xn-2...:x1:[]
18:49:53 <huylv> but that's obviously wrong
18:49:57 <conal> bitemyapp: i don't make that assumption. rather that someone will ask for definitions when they need them. here, it's my best guess that people mean by "_|_" the same as I do. i could be wrong, but i respect the other person enough to ask questions about definitions etc. especially if they used a term.
18:50:10 <Ygg> but it's kinda bumming me out since I'd really like to use OpenAL
18:50:18 --- mode: johnw set +b *!~callen@198.199.80.102
18:50:18 --- mode: ChanServ set +o johnw
18:50:18 --- kick: bitemyapp was kicked by johnw (Rudeness)
18:50:18 --- mode: johnw set -o johnw
18:50:27 <conal> `Guest00000: still here? 
18:51:00 <conal> sigh. i assume bitemyapp has the best intentions for the community, as i do.
18:51:30 <geekosaur> bitemyapp is ... enthusiastic. and not always with the self-control
18:51:47 <huylv> hi there, could someone answer my question?
18:52:59 <Clint> huylv: are you asking how foldr works?
18:53:30 <huylv> no, I'm asking why it doesn't return [1,2,3...,xn] instead
18:53:58 <Ygg> am I doomed ? 
18:55:08 <ski>   reverse' xs = foldr (\x fId empty -> fId (x : empty)) id xs []
18:55:20 <ski>      reverse' (0:1:2:[])
18:55:22 <huylv> from my understanding, it should apply the id function to 1:2:3:..:xn, since each iteration, next element from the RIGHT is prepended to the argument
18:55:51 <ski>   =  foldr (\x fId empty -> fId (x : empty)) id (0:1:2:[]) []
18:57:23 <ski>   =  (\empty -> foldr (\x fId empty -> fId (x : empty)) id (1:2:[]) (0:empty)) []
18:57:34 <ski>   =  foldr (\x fId empty -> fId (x : empty)) id (1:2:[]) (0:[])
18:57:49 <ski>   =  (\empty -> foldr (\x fId empty -> fId (x : empty)) id (2:[]) (1:empty)) (0:[])
18:57:58 <ski>   =  foldr (\x fId empty -> fId (x : empty)) id (2:[]) (1:0:[])
18:58:08 <ski>   =  (\empty -> foldr (\x fId empty -> fId (x : empty)) id [] (2:empty)) (1:0:[])
18:58:18 <ski>   =  foldr (\x fId empty -> fId (x : empty)) id [] (2:1:0:[])
18:58:20 <huylv> give me a second to think :D
18:58:24 <ski>   =  id (2:1:0:[])
18:58:28 <ski>   =  2:1:0:[]
18:58:55 <ski> that's skipping some details, but should be basically it
18:59:09 <ski> @src foldr
18:59:09 <lambdabot> foldr f z []     = z
18:59:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:59:46 <ski> note that `fId' above will become the recursive call `foldr f z xs' in the definition of `foldr'
19:00:03 <huylv> hold on
19:00:20 <huylv> looks like I misunderstood about the order of execution
19:00:55 <adam_> a good way to think about it is like this
19:01:17 <adam_> > foldr (\x y y-> concat ["(",x,"+",y,")"]) "0" $ map show [1..5]
19:01:18 <lambdabot>      Conflicting definitions for ‘y’
19:01:19 <lambdabot>      Bound at: <interactive>:1:11
19:01:19 <lambdabot>                <interactive>:1:13
19:01:24 <adam_> whoops
19:01:30 <adam_> > foldr (\x y-> concat ["(",x,"+",y,")"]) "0" $ map show [1..5]
19:01:31 <lambdabot>  "(1+(2+(3+(4+(5+0)))))"
19:02:02 <adam_> its a right associative fold
19:02:07 <adam_> im not sure if that helps at all
19:02:23 <ski> > foldr (\x s -> concat ["(",show x," + ",s,")"]) "0" [2,3,5,7]  -- variant of the same thing
19:02:25 <lambdabot>  "(2 + (3 + (5 + (7 + 0))))"
19:03:05 <ski> huylv : expanding in more detail :
19:03:25 <ski>      foldr (\x fId empty -> fId (x : empty)) id (1:2:[]) (0:[])
19:03:41 <huylv> ski: why in the first iteration, 0 is picked?
19:03:53 <huylv> but not the last one?
19:04:08 <ski>   =  (\x fId empty -> fId (x : empty)) 1 (foldr (\x fId empty -> fId (x : empty)) id (2:[])) (0:[])
19:04:17 <ski>   =  (\fId empty -> fId (1 : empty)) (foldr (\x fId empty -> fId (x : empty)) id (2:[])) (0:[])
19:04:20 <adam_> huylv: look at what we did above right
19:04:40 <adam_> it was (2 + (3 + (5 + (7 + 0))))
19:04:54 <adam_> its right associative
19:05:03 <adam_> > foldl (\x s -> concat ["(",show x," + ",s,")"]) "0" [2,3,5,7] 
19:05:05 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘2’
19:05:05 <lambdabot>      In the expression: 2
19:05:05 <lambdabot>      In the third argument of ‘foldl’, namely ‘[2, 3, 5, 7]’
19:05:10 <ski>   =  (\empty -> foldr (\x fId empty -> fId (x : empty)) id (2:[]) (1 : empty)) (0:[])
19:05:20 <ski> adam_ : the other way around
19:05:36 <adam_> no I wanted to show how foldr and foldl differ
19:05:46 <divVerent> question about the Num typeclass
19:05:53 <divVerent> what algebraic structure does it require?
19:06:01 <divVerent> i.e. are there any assumptions about e.g. its associativity?
19:06:09 <ski> huylv : because `foldr f z (x:xs) = f x (foldr f z xs)' picks the first element `x' of the argument list `x:xs' ?
19:06:20 <ski> huylv : i'm not sure i understood your question
19:06:26 <divVerent> or does GHC not make any such assumptions for optimization
19:06:45 <adam_> ask ski :P
19:06:58 <huylv> ski, let me think about adam_ 's code
19:07:05 <huylv> I'm confusing here
19:07:46 <Ygg> (just in case someone knows someting about this : http://lpaste.net/4240616778381656064, I'll check the logs tomorrow
19:07:55 <Ygg> good night peeps
19:09:13 <adam_> do you want to elobrate on what exactly your struggling with?
19:09:20 <adam_> folds are hard to wrap your mind around
19:09:32 <ski> huylv : i assume you've seen a "reduction trace" of an "ordinary" use of `foldr', to compare with ?
19:10:40 <ski> > foldl (\s x -> concat ["(",s," + ",show x,")"]) "0" [2,3,5,7]  -- adam_, fwiw, this is what i meant by "the other way around"
19:10:41 <lambdabot>  "((((0 + 2) + 3) + 5) + 7)"
19:10:52 <huylv> alright
19:10:58 <huylv> I think I get it
19:11:13 <huylv> to the calls are actually executed backwards
19:11:23 <ski> (iow, with `foldl', the first argument to the "callback" is the accumulator (here a string), and the second is the current list element, opposite to the case with `foldr')
19:11:23 <huylv> because they're recursive
19:11:25 <huylv> right?
19:11:43 <huylv> yea, the callbacks
19:11:48 <ski> i'm not sure what you mean
19:12:16 <adam_> nice one ski
19:12:23 <adam_> foldl (\s x -> concat ["(",s," + ",show x,")"]) "0" [2,3,5,7] 
19:12:35 <huylv> I meant the acc is executed as a series of callbacks
19:12:46 <adam_> > foldr (\x s -> concat ["(",show x," + ",s,")"]) "0" [2,3,5,7]
19:12:47 <lambdabot>  "(2 + (3 + (5 + (7 + 0))))"
19:12:58 <adam_> > foldl (\s x -> concat ["(",s," + ",show x,")"]) "0" [2,3,5,7]
19:13:00 <lambdabot>  "((((0 + 2) + 3) + 5) + 7)"
19:13:01 <adam_> both next to each other
19:14:15 <ski> adam_ : it can be good to message lambdabot privately an example, to make sure one gets it right the first time (or at least the second time), thereby cluttering the discussion less with error messages
19:15:23 <ski> huylv : i can show another way to think about the current example, that perhaps can also help
19:15:40 <huylv> thanks, ski
19:15:54 <huylv> the examples with 'show' actually helped
19:15:59 <ski>      reverse' (0:1:2:[])
19:16:06 <huylv> I understand it now :D
19:16:24 <huylv> obviously I didn't think about it recursively
19:16:41 --- mode: ChanServ set +o Saizan
19:16:59 <huylv> many thanks, adam_ and ski 
19:17:06 --- mode: Saizan set -b *!~callen@198.199.80.102
19:17:12 <huylv> I'm going to bed now, cya guys :D
19:17:37 <codedmart> Anyone that can help with a FromHttpApiData instance?
19:17:38 --- mode: Saizan set -o Saizan
19:17:51 <ezyang> Can anyone recommend me a library for DFA minmization? 
19:18:07 <ski> huylv : ok
19:18:36 <ezyang> I've found HaLeX and hDFA 
19:30:04 <Cale> Whoa whoa, lots of drama
19:30:07 <Cale> anyway
19:30:35 <Cale> `Guest00000: did you actually get your questions about _|_ sorted out? Did anyone bother to explain things?
19:32:12 <adam_> I think he dipped
19:41:34 <Lokathor> http://lpaste.net/150542 if one is writing a multi-user live editing program, are there any obvious flaws in how I've setup my core data types so far?
19:45:51 <Adeon> nothing obviously wrong
19:46:10 <Adeon> I think I would take out websocket connection out and abstract it more so the types are not coupled with the presence of websockets
19:46:19 <Adeon> some people might further decouple STM but I probably wouldn't go that far
19:46:35 <Lokathor> how would you suggest pulling out the websocket element?
19:46:36 <Adeon> you can derive Typeable and Generic at least for anything
19:46:46 <Adeon> well one example
19:47:07 <Adeon> instead of having WS.Connection, you could have something like (IO ByteString, ByteString -> IO ())
19:47:17 <Lokathor> hmm
19:47:24 <Adeon> that's pretty low-level though
19:47:38 <Adeon> in practice I've had things like (m MessageFromClient, MessageToClient -> m ())
19:47:41 <Lokathor> actually, i guess i don't need it
19:47:53 <Adeon> also I wouldn't worry about things too much if you can keep your API somewhat refactorable
19:47:53 <Lokathor> all other threads need to see is the TChan so they can write to a client's out channel
19:48:06 <Adeon> you probably are not going to use other protocols than websocket for the foreseeable future, right?
19:48:13 <Lokathor> corerct
19:48:24 <Adeon> haskell's pretty good at abstracting so I usually abstract anyway if it doesn't slow me down much
19:48:44 <Lokathor> a webpage connects to this via websocket, so i must stick with websocket because javascript can't use real sockets, for example
19:49:33 <Lokathor> I'll put a note to possibly remove the Connection from things though
19:49:46 <Adeon> I think you are totally fine with the types you already have
19:50:36 <Adeon> might want to give Ord to ConnectedClient as well if you can give it Eq
19:50:48 <Adeon> if you give things Ord you can put them in ordered containers
19:51:12 <Adeon> doesn't matter which order as long as it's some deterministic order, I would just give Ord to anything that can auto-derive it
19:51:21 <Lokathor> yeah true
19:51:23 <Adeon> but you could have Set ConnectedClient instead of [ConnectedClient]
19:51:25 <Adeon> if you do that
19:51:30 <Lokathor> same reason that Erlang has ordering even beween types
19:54:52 <Adeon> one trick I sometimes use
19:55:13 <Adeon> if I'm wrapping some foreign resource that comes out of an IO action, e.g. makeResource :: IO Resource
19:55:38 <Adeon> my Resource might look like data Resource = Resource { foreignThing :: Thing, uniqueIndex :: Unique }
19:55:55 <Adeon> I implement Eq and Ord on the uniqueIndex
19:56:21 <Lokathor> and then the Resource can do the same, based on the Unique
19:56:22 <Lokathor> good plan
19:56:24 <Adeon> you can create uniques anywhere and because I'm the sole producer of Resources I know the instances cannot be messed up
19:56:48 <Lokathor> i was thinking i might have to do such a thing eventually
19:56:57 <Adeon> you can also use top-level IORefs but the uniques are in 'base' and I think they actually are implemented as top-level IORef
19:58:09 <Lokathor> so here's the question i sorta had
19:58:36 <Lokathor> because the ServerRoom values are kept inside a TVar each, a change to a room won't affect the ability of another room to also change, right?
19:58:52 <Lokathor> since they don't modify the ServerState itself, they won't be conflicting transactions?
19:58:54 <Adeon> if they are separate TVars then yeah they won't interfere with each other
19:59:06 <Lokathor> perf
20:16:06 <mag____> hello
20:18:21 <mag____> before anything I would like to say that, Haskell has been a humbling experience for me
20:18:24 <mag____> that said
20:18:46 <mag____> Why the following line hangs ?
20:18:51 <mag____> head $ foldl (\acc x -> (x+1):acc) [] [1..]
20:19:07 <mag____> Given the lazy nature of Haskell, it should return right way
20:19:52 <verement> @src foldl
20:19:52 <lambdabot> foldl f z []     = z
20:19:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:20:05 <mag____> *away
20:20:28 <geekosaur> laziness only helps if something produces a partial result before the entire result is computed
20:20:55 <geekosaur> if you look at the definition of foldl that verement just asked the bot to show, if the list is not empty foldl immediately calls itself again
20:21:22 <geekosaur> so you can;t get anything until it has traversed the whole (very large, for a 64-bit GHC) list
20:21:38 <mag____> I see, in other words, I don't understand how laziness works in haskell
20:22:25 <verement> > head $ foldr (\x acc -> (x+1):acc) [] [1..]
20:22:26 <lambdabot>  2
20:22:34 <verement> @src foldr
20:22:34 <lambdabot> foldr f z []     = z
20:22:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:22:42 <scshunt> mag____: let's look at the definition of head
20:22:45 <scshunt> @src head
20:22:45 <lambdabot> head (x:_) = x
20:22:45 <lambdabot> head []    = undefined
20:22:45 <geekosaur> well, to return the first element of a list, you have to be able to get that first element
20:22:55 * hackagebot Gifcurry 0.1.0.1 - Create animated GIFs, overlaid with optional text, from movies.  https://hackage.haskell.org/package/Gifcurry-0.1.0.1 (lettier)
20:23:17 <scshunt> mag____: When you apply head to an expression, Haskell attempts to pattern match on it
20:23:36 <scshunt> in order to do this, it needs to determine if the expression uses the (:) constructor or the [] constructor
20:24:02 <scshunt> (both (:) and [] are data constructors, just like, say, True and Just)
20:24:52 <scshunt> When Haskell tries to reduce foldl, it ends up with another expression that starts with foldl
20:25:07 <scshunt> that isn't reduced enough to determine which constructor it uses, so it repeats
20:25:38 <scshunt> When it tries to reduce foldr, by contrast, the foldr in the reduction occurs inside a subexpression
20:26:11 <HEGX64> @src foldl
20:26:12 <lambdabot> foldl f z []     = z
20:26:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:26:19 <HEGX64> @src foldr
20:26:20 <lambdabot> foldr f z []     = z
20:26:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:26:23 <scshunt> the expression that needs to be evaluated in your case is "f x (foldr f z xs)", which works out to (x+1):(foldr f z xs)
20:26:39 * mag____ reading
20:26:43 <scshunt> In this case, Haskell knows right away that it uses the (:) constructor, and so it binds the pattern and can proceed with evaluation
20:26:59 <scshunt> Let me know if that covers it, or if you'd like a bit more explanation. I sort of assumed you know or can infer what reduction is.
20:29:30 <jle`> mag____: try manualy evaluating foldl (\acc x -> (x+1):acc) [] [1..] manully, with pencil and paper
20:29:35 <jle`> and try to get the first item in the list that way
20:29:39 <jle`> it's actually impossible :O
20:29:53 <jle`> or well, you'll go on forever and never be able to know what the first item is
20:30:41 <jle`> let's try!
20:31:15 <jle`> foldl (\acc x -> (x+1):acc) [] (1:[2..])
20:31:41 <mag____> ok
20:32:05 <jle`> > foldl (\acc x -> (x+1):acc) [1] [2..]
20:32:10 <lambdabot>  mueval-core: Time limit exceeded
20:32:11 <jle`> what's the first item of that?  it's impossible to tell
20:32:16 <jle`> so we go further
20:32:29 <jle`> foldl (\acc x -> (x+1):acc) [2,3] [3..]
20:32:45 <jle`> foldl (\acc x -> (x+1):acc) [2,3,4] [4..]
20:32:58 <jle`> you'll never be able to get (x:xs) from that, no matter how far you go
20:33:20 <jle`> if your list was [1..5], you'll eventually get to this step:
20:33:28 <jle`> foldl (\acc x -> (x+1):acc) [2,3,4,5,6] []
20:33:31 <monochrom> > [120 .. ] :: Int8
20:33:33 <lambdabot>      Couldn't match expected type ‘Int8’ with actual type ‘[Integer]’
20:33:33 <lambdabot>      In the expression: [120 .. ] :: Int8
20:33:36 <jle`> which ==> = [2,3,4,5,6]
20:33:40 <monochrom> oops
20:33:41 <jle`> which you can get the first item on
20:33:46 <monochrom> > [120 .. ] :: [Int8]
20:33:47 <lambdabot>  [120,121,122,123,124,125,126,127]
20:35:31 <mag____> > maxBound :: int8
20:35:32 <lambdabot>      No instance for (Bounded int1) arising from a use of ‘maxBound’
20:35:32 <lambdabot>      Possible fix:
20:35:32 <lambdabot>        add (Bounded int1) to the context of
20:35:40 <monochrom> capital I
20:35:46 <mag____> > maxBound :: Int8
20:35:48 <lambdabot>  127
20:37:15 <mag____> scshunt, scshunt thank you
20:37:24 <mag____> I understand now
20:39:29 <HEGX64> So why isn't foldl defined as `foldl f z (x:xs) = f (foldl f z xs) x`
20:39:30 <mag____> but, that means, the way I program a function will allow me to do some things or not
20:39:50 <monochrom> that would not be what people mean by foldl
20:39:57 <Lokathor> mag____, when operating with a list, imagine that the elements of the list are the elements you'd iterate over during a for loop
20:40:04 <Lokathor> or a while loop, or other such loop
20:40:16 <Cale> HEGX64: That looks like a serious type error to me.
20:40:17 <Lokathor> if the list is infiniate, with no way to "break" from the loop, it's just an infinite loop
20:40:31 <Cale> er
20:40:33 <Cale> oh, no
20:40:40 <Cale> HEGX64: sorry, I misread
20:40:53 <mag____> jle`,  opss sorry,  I meant   you and scshunt
20:40:54 <HEGX64> let foldl' f z (x:xs) = f (foldl' f z xs) x; foldl' _ z [] = z
20:40:59 <monochrom> @type let {foldl f z (x:xs) = f (foldl f z xs) x} in foldl
20:41:00 <lambdabot> (t2 -> t1 -> t2) -> t -> [t1] -> t2
20:41:06 <Cale> HEGX64: That's more like a right fold on flip f
20:41:10 <Cale> than a left fold
20:41:55 <Cale> @src foldr
20:41:55 <lambdabot> foldr f z []     = z
20:41:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:42:18 <Cale> You're just supplying the arguments to f in the opposite order
20:42:29 <HEGX64> Are there cases where you want a left fold? I thought that's all foldl was used for
20:42:44 <Cale> Both foldl and foldr preserve the order of arguments in the list in the constructed expression
20:42:56 <Cale> > foldl f z [1,2,3,4,5] -- magic?
20:42:57 <lambdabot>      Ambiguous occurrence ‘f’
20:42:57 <lambdabot>      It could refer to either ‘L.f’,
20:42:57 <lambdabot>                               defined at /tmp/mueval2694553061703964683.hs:157:1
20:43:01 <Cale> awww
20:43:09 <Cale> @undefine
20:43:09 <lambdabot> Undefined.
20:43:11 <Cale> > foldl f z [1,2,3,4,5] -- magic?
20:43:12 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
20:43:19 <Cale> > foldr f z [1,2,3,4,5] -- more magic
20:43:20 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
20:43:48 <Cale> The difference is how the expression is associated
20:44:08 <Cale> foldr preserves the structure of the original list, while foldl is sort of backward about it
20:44:14 <Cale> foldl is quite good for defining reverse
20:44:25 <Cale> > foldl (flip (:)) [] [1..5]
20:44:26 <lambdabot>  [5,4,3,2,1]
20:44:36 <Cale> (but the flip is needed there)
20:45:07 <`Guest00000> why don't definitions undefine automatically after some time?
20:45:07 <Cale> But it would be confusing for foldl and foldl' to follow a different convention
20:45:11 <Cale> `Guest00000: eh, they just don't
20:45:28 <`Guest00000> why did nobody implement this
20:45:29 <Cale> `Guest00000: lambdabot doesn't keep track of them separately either
20:45:39 <Cale> `Guest00000: you just have to undefine everything at once
20:45:41 <monochrom> because you can run a bot that issues "@undefine" periodically
20:45:45 <Cale> haha
20:46:09 <monochrom> I keep saying that. but I'm too lazy to do it myself
20:46:49 <monochrom> two things I keep saying I want to do but procrastinate:
20:47:08 <HEGX64> Cale: Wow, I thought foldl and foldr were the same. Thanks for explaining
20:47:10 <monochrom> 1. write and run some background program to periodically @undefine
20:47:51 <monochrom> 2. drink two shots of whiskey then go delete that "IO is a state-passing monad" page from the haskell wiki
20:48:06 <Cale> HEGX64: There is a very important difference between them in Haskell - foldl can never work on an infinite list, while foldr can.
20:48:12 <Cale> @src foldr
20:48:12 <lambdabot> foldr f z []     = z
20:48:12 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:48:16 <Cale> @src foldl
20:48:17 <lambdabot> foldl f z []     = z
20:48:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:48:37 <Cale> foldl does nothing but apply itself greedily to new arguments until it reaches the end of the list
20:48:48 <Cale> foldr immediately passes control to f
20:48:50 <monochrom> example: foldr (||) False (repeat True)
20:49:13 <mag____> I'm seriously thinking why should I use foldl over foldr
20:49:20 <Cale> and only if f pattern matches on its second argument will the recursion proceed
20:49:50 <Cale> (or f might put that second argument into some data structure and something else will come along later and evaluate it to make the recursion continue)
20:50:08 <Cale> Usually you either want foldr or you want foldl'
20:50:33 <Cale> foldl' is a variant of foldl which forces the evaluation of the accumulated argument to occur on each step
20:50:58 <HEGX64> You mean foldl1?
20:50:59 <Cale> Often the compiler will automatically optimise foldl to foldl', but ehhh... it's scary to rely on that if it counts
20:51:04 <Cale> nope
20:51:07 <Cale> @src foldl'
20:51:07 <lambdabot> foldl' f a []     = a
20:51:07 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:51:08 <`Guest00000> monochrom: what is that page?
20:51:11 <Cale> It's in Data.List
20:53:04 <mag____> Well, thank you to all of you
22:59:03 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
22:59:03 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
22:59:03 --- names: list (clog doomlord vektorweg1 python476 puregreen favetelinguis Reshi conal bjz martin-t dmj badon yfeldblum howdoi T0BI obadz sssilver srajendra lyuha nut_ platz andjjj23 godel_ acertain pavonia montanonic eis Rizy pacak darkf rardiol cpup crough gfixler athan justanotheruser Ziltrum castlelore kansi Rennex1 sgfltx cipher___ astrofog demilux PatrickRobotham magine HylianSavior otto_s_ drostie andyo mauke no-n wedify baweaver lritter jack_rabbit LordBrain agjacome)
22:59:03 --- names: list (sbrg1 orb Dykam watabou clynamen saml_ Goplat yrdz bitemyapp pawelbx`` e verement mea-culpa triliyn hnagamin hucksy_ jle` SrPx heurist dan_f tripped roconnor Zekka phileas oldmanmike tabemann austinkeeley lostman_ cdepillabout hilquias al-damiri dashed KaiJia HEGX64 tlevine it3rc3pt aib tristanp xnil grouzen angerman Quashie_ cleamoon bb010g vili_ hexagoxel exferenceBot lspitzner nakal mceier mitchty jedws hackebeilchen predator217 markus1199 augur alunduil)
22:59:03 --- names: list (vqrs cads obihann jud mach MorpheusB koz_ synergistics dexter-tzu yorick nshepperd TDJACR nyuszika7h Black-Wolf kilderkin MoALTz __rlp Lokathor ]OLI[ LnL Sigyn Tehnix aarvar pgiarrusso tristero Coldblackice sleblanc SavinaRoja erkin richardiii fedorafan `Guest00000 zariuq a3Dman_ Jesin dsantiag_ lambda-11235 brixen dfeuer fizbin FreeFull alexa_ bobvh SenpaiSilver rwiggins dented42 rschnck Denommus AntiSpamMeta ski wolfcub psy_ irishsultan Lord_of_Life felixn)
22:59:03 --- names: list (thimoteus joco42 ed7b narendraj9 eyck Unhammer darkbolt the-kenny thunderrd gienah cic nek0 bencryption nottc drbean ahihi rickerbh noddy2OOO proteusguy proteusguy_satri Wamanuz Tinchos nidr0x cognominal KorriX cheater djellemah_ Majiir monochrom erikd Voldenet moei ph88 greves freekevin araujo gniourf grantus_ humanbsd wolfcore juhp hellwolf shanemikel_ Amnez777- psacrifice Klumben SolarAquarion alem0lars xacktm zv rcsgns dextertzu bind tomboy64 CoconutCrab)
22:59:03 --- names: list (boj kini dmiles_afk bluetux Encapsulation blckbit10 isocliff_ cbm80 pinkythepig_ solrize c-rog _ashbreeze_ radens yarou whaletechno tswett justin_smith dan64 rotaerk Sgeo stoopkid lamilami goodboy albel727 ixian Hammy_Work Mon_Ouie opios FledRebel mrlase bergey Johannes13 brainproxy alevy wookiehangover ElderFain sebboh ttuegel __name__ dxtr cargill sz0 besenwesen theorbtwo DenSchub MindlessDrone padre_angolano jakutis woffy rvncerr EvanR hydraz phaskell)
22:59:03 --- names: list (jo____ cross cipher__ khisanth_ Ewout synthmeat wedens luxbock joko qnikst dmwit julmae keteim keix alinab niko SegFaultAX Cr8 acfoltzer drewdavis infinity0 tv pie_ parisianSummer MrWoohoo xinming hackagebot CurryWurst dhrosa eazar001 ninegrid tobiasBora clintm dseitz robogoat graycoder ali_bush dlundy kyren vishesh anohigisavay dolio Church- _6a68 Philonous mj12` marienz warc liyang xaimus FireFly vikraman shirt__ eikke Eagle_Erwin tgeeky Reiser anders0)
22:59:03 --- names: list (fnordbert _janne cursork kungp saulzar_ thomie killtheliterate alanz cbaines dutchie sunfun saep ixti mjo catsup mrowe subleq mirsal acomminos Guest3764 friden iross kfpratt Xorlev l3dx marcel drmoob sbjorn gaustin MelodyKH3 tremon mietek lattenwald Belgarion0 chris2 m0li rofer buoto arianvp Dtgr edwtjo mnoonan myme happy0 khole leat haskellbr-slack glckr Nimatek japesinator gsingh93 bydo Niamkik_ sclv Factionwars Willis_ Akii StoneToad lyddonb RageD Ankhers)
22:59:03 --- names: list (moredhel_ yamadapc Twey shwouchk_ Elsi_ huonw_ jameseb aloiscochard Xnuk taksuyu TimWolla dpn` max-m chelfi1 MitchW_ kmicu rje_li Kaini_ neobrain` Laney zenzike extropic-engine dino-_ pfeyz_ rikkus kriztw knyppeldynan brezel roark Ralith net4all serutsub1 argoneus earthy Saizan petercommand tomjagua1paw SHODAN rom1504 sternenseemann ppnkk klugez andrewsw quicksil1er mrd_ Rembane tsx_ jaaket_ tismith anachrome Myrl-saki kosmikus pompolic nrk- plazmoni1 Tehnix`)
22:59:03 --- names: list (z-nexx_ dibblego haBuu^ Keel ebird OverCoder Adios_ abra0 fergusnoble Phyx- PHO TallerGhostWalt_ chattered niteria reynir sdx32 quaestor lodin__ kosorith unknownloner SaidinWoT thomas chu so orzo DylanJ wunki ollef_ Amigant Flonk svp_ kvieta kloeri irclogger_com Boreeas Ring0` linduxed introom RouxTheDay ortmage marmalodak zimp1 fold3 sarlalian tych0 low-profile sparr hbar kalloc dtulig rdema nexsja domenkozar ephess_ epta ReinH geppettodivacin Oxyd urdh)
22:59:03 --- names: list (majjoha vifon saruta dbeacham Fullma APic lyxia ChristianS solirc milena exio4 Chousuke guios leftylink Jellydog rphillips s4msung ddima zxq9 slikts sujeet TseiTsei amiller_ lukky513 pharaun _ari nitrix yeltzooo9 plhk catern brisbin_ spion lf94_ M-david1 gnusosa_ Saimeidae Watcher7_ dju surtn vin-ivar deni dxld_ Purlox swhalen_ ahf Jello_Raptor_ cnr noplamodo nurupo jamiis_ dunj3 gcollins zudov owa julienXX luzie Vq jlewis_ fengshaun Natch kier_ Meths)
22:59:03 --- names: list (JPohlman1 stelleg_ wto ClaudiusMaximus ByronJoh1son Matajon_ amontez_ M2tias_ Jaak_ nopf opqdonut mmaruseacph2 earldouglas bsermons_ mrshoe_ jotrk Excedrin cfloare_ fmapE_ leino gdsx_ bolmar lenstr stomp_ shteou_ zyoung_ Phillema1n Drezil_ isomorph1smes hiredman duairc_ Guest10495 KitC_ comboy lvh_ alynn_ sgronblo_ RlyDontK1ow agjohnst z16_ xou_ Fubar^ jnes_ tedkorni1h klapku_ numberten Hafydd stvc_ pleiosau1 gpampara- sdboyer Bigcheese brolin_empey)
22:59:03 --- names: list (joeytwiddle_ tjr benmos vodkaInf1rno tromp__ DustyDin1o pontus wayne thesnowdog2 horatiohb ernst burp martingale techiewickie orbital hrnz noctux joeyh MasseR PinealGlandOptic Tourist monokqr gseitz mephx Spaceghost dzack __main__ SolitaryCypher s_e nont_ bcoppens pieter_ sLite luite statusbot m1dnight_ hamishmack sokoll kakos hpd luis icedev joshc ousado jzl fyolnish M-mistake mak` heath yyyyy nomicflux bartavelle M-davidar M-radix t0m0 noteventime)
22:59:03 --- names: list (sword_smith Pamelloes pikajude wagle adlan Internet13 kennyp segmond ThePhoeron spaceships tusj wamaral cryzlr Cale Nik05 marko srcerer obiwahn joehillen edofic tomaw bgyss sephiap zpconn__________ movedx cstrahan ggherdov_ ocharles_ mankyKitty thoughtpolice tarcwynne_ hansihe borkdude tharper xnyhps solidsnack jroesch_ kseo _klm carter_cloud koray qguv etrepum kipd nkpart lohkey Tritlo etcinit lexi-lambda mniip greeny dario` lstrano fractalcat xanadu_ ikke)
22:59:03 --- names: list (asjo maerwald da-x inr OutlawStar fr33domlover benonsoftware Intensity penberg parsnip okoks9011 igniting bjobjo ghorn Xandaros Nadrieril kolko metaf5 condy RGamma magthe derekv2 josgraha gciubot neshmi Kavec troydm Axman6 BillyIII M-ou-se josephle munki dqd xplat donwilliam jokleinn johnw denimuser Maxdamantus georgew rossberg Nivim Polarina sanitypassing sunnymilk stass sw1nn ibid canta majoh tg leather nbouscal AlainODea folsen stux|RC-only trig-ger hodapp)
22:59:03 --- names: list (shennyg lindenk cogrendel Draggor jackhill unsymbol sajith RevJohnnyHealey taruti jmct Bane^ pyrtsa benley flux wsandin hpc cschneid dexterph mikeizbicki IanKelling funrep ajp zxtx xplat|work Heero arcanine robertk seanparsons bkolera sbauman mbrcknl kjnilsson arnihermann sewilton mindos_cloud____ S11001001 danclien kaol grol ChongLi davl tzaeru coddinkn CARAM__ Guest87996 YP-Cloud_ katymoe PotatoGim grassass tippenein psyq Brando753 byorgey Moto-chan)
22:59:03 --- names: list (l3france Ov3rload robtaylor otterdam shapr mero Bez_ pranz LordDeath ninzine thorkilnaur bd_ Starfire aweinstock magicman RaceCondition hvr vpm Sornaensis Ke DrCode staffehn ploopkazoo jb55 abrar jokester nwf dustinm jbalint scshunt whiteline LoganG santosh_ ljhms tessier Tril hiratara edwardk `0660 pmade n__dles nuuit Shandy John[Lisbeth] Athas Biohazard mtesseract elgot hemite cyberlard gratimax adarqui GGMethos jayne usr JamesJRH eamelink orion ps-auxw)
22:59:03 --- names: list (eatman maxmo ThreeOfEight juri_ moop async_prince eagleflo Pucilowski cow-orker bergmark horlicks_ cYmen_ kaste DDR lb5tr CindyLinz Plastefuchs Taneb arrdem dcoutts jgertm timothyh Boney tomku|two Tesseraction mimi_vx Cetusx jrslepak mikeplus64 teeteewhy simony raid mokus_ DANtheBEASTman SuperTux88 kwantam shachaf davidthomas sm codehero MorTal1ty acro ManiacTwister jojotus ljw jang Shapeshifter jorj themagician skrio gridaphobe vigs nekomune amharc Atlanis)
22:59:03 --- names: list (wjm davesilva pdxleif ent Erebe tdammers Moyst case39 osfameron RazorX spacebug saiam sevas jstolarek ziman ackthet Neseth spindas omilu lambdahands bigs frelux tjpeden spicydonuts zph askarpo carlw2 bitonic paf31 jonrh sublimate zrl puzza007 pkogan nrw nolrai2 yaknyasn rstone fabianvf shans_ cleichner mpickering wizonesolutions ajmccluskey harmchop chriswk alexlord jlyndon vikram______ stasku_ kyagrd pootler_ wyvern tazjin Scorchin zmanian_ lancetw jfokkan__)
22:59:03 --- names: list (fuziontech Raynos johtso caasih TabAtkins aristid rslima_ shelling__ alphonse23_ akahn dstockwell posco milessabin runeks glowcoil andreypopp si14 jorendorff prefork_ jonathanj__ phuu naudiz avdi NemesisD pchiusano dmoon1221 stephe yminsky OliPicard placer14 joedevivo grandy psftw banjiewen mno2 reem dkua amatecha jessicah` timloh mvr_ fboyer tim_s007 absence Hijiri chishiki tromp_ Rovanion jnoah andreass koomi iliastsi cdidd zaquest tippenei1 Kneiva glguy)
22:59:03 --- names: list (coeus Paks Xack solidus-river ckw xxpor gbarboza tnks hive-mind hongminhee Simson-san vic_ Nickeeh Jaxan xiaolin_ mountaingoat ahungry andreas303 dfranke hyPiRion ft dsop danieli zyla_prati dixie yusukesuzuki sea-gull little_monster fingerzam1 dh marens ggVGc nesqi Freundlich darxun froztbyte cods Guest26796 rfk wanderer mrvdb cjay zerokarmaleft pdgwien dschoepe zerowidth GaveUp pikhq negatratoron tjbp_ sys9mm carter Ornedan cmn bernalex Deewiant lassulus)
22:59:03 --- names: list (haasn xintron monsieurp lispy honkfest1val Cerise kjanosz IanMalcolm meretrix topi fryguybob lokydor Eiam relrod sleezd [swift] RayNbow`TU spill3 siddhu eL_Bart0 BrianHV drdo klarrt martinbjeldbak AustinMatherne ironChicken Vbitz tortal finninde zyla bshelden peddie defanor darkstalker syntacticNaCl lambdabot abh- Speed d3lxa mechairo` pingu__ Ferdirand demize benzrf thalleralexander thebnq Nahra``` WarzoneCommand zeroskillor Adeon jasaarim atomi capisce cjh`)
22:59:03 --- names: list (bogdanteleaga bananagram arkarth andromeda-galaxy cjwelborn skarn Shoggoth keko-2 Enigmagic cin dlandau Walther idupree SwashBuckla anoe tumdedum Sonderblade obcode_ Bashmetim jyc Tene stoned fall_ tokik MarcelineVQ jaj rbocquet Ptival chirpsalot Chobbes seagreen DigitalKiwi jvd mjrosenb Fuuzetsu MK_FG cdk mt Ravana callumacrae DistantStar Xe rubber-soul slick SoupEvil descender tommd Profpatsch notdan SLi itscaleb lpsmith lpaste cartwright integral mudfog)
22:59:03 --- names: list (imalsogreg_ karls Zemyla hausdorff bjs Lutin` dilinger lachenmayer abbe zhulikas k1io- eyenx Baughn avn geekosaur orcus zomg sohum perrier_ statusfailed LeaChim kqr qz barrucadu hanDerPeder supki jlouis tekacs lnx Igloo dreamdust esssing boxfire zymurgy Clint jgornick reactormonk shadowdaemon ArcticMonkey nisstyre ido fredcy Sam__ Ongy niklasb jrp6 Ezku Mandus minad arkeet codebje THE_BOULDER greymalkin rieper|net selckin KaneTW geal dredozubov aatxe)
22:59:03 --- names: list (ephemeron aaronm04 Didac Desoxy deavid whoops carc valdyn Fuco sivoais noexcept mathu Jamazia jrib flori arw bbee kristjansson itsmonktastic Shockk nille sekrit lauren ion jinblack jcreekmore regicidal o`connor Reyu gothos CosmicRa` phadej flan seliopou ndeine- TheSpect1e abk7 pm5 alpounet krgn keemyb Tristan-Speccy oberstein spwhitt_ sleepynate Frankablu lhynes Yaiyan alang Liskni_si brt1 mads- XMunkki_ Eliel_ xaotuk_ pwned phaazon adimit Rodya betawaffle)
22:59:03 --- names: list (davean luigy tolt octophore aparent averell hc ircbrowse kipras monty bgamari Jonno_FTW gabiruh sku1d tsani gargawel jix otulp fionnan larsen solatis _flow_ cocreature squisher brotknust Ulrar chrzyki impure_hate richi235 c_wraith divVerent Blkt codebam Forkk themaste- Tiktalik zopsi kaictl sevcsik code_crimes_ jstimpfle pfoetchen eddsteel cynick chaptastic Ashy pi__ saurik nemesit|znc myfreeweb technomad Tazca nathyong karshan henrytill int-e optocoup1er)
22:59:03 --- names: list (uwap Gothmog_ niluje dicioccio indiffernet liste tero- wting avocado sivs mgaare sellout hegge Sagi ricardo82 srhb Geekingfrog frontendloader wolf_mozart wrengr_away theDon zemm bsmt lieven mendez PierreM koala_man asm89 apo_ Cathy capybara @ChanServ Diabolik jcurbo newsham)
23:09:39 <platz> considering the functions 'maybe' and 'either', in which each argument corresponds to a case of a sum type:  are these folds?  there's some relation to church encoding but they aren't encoded themselves.. it seems more like a specific kind of fold
23:10:04 <ski> they are folds/catamorphisms, yes
23:11:11 <ski> (folds in the sense of `foldr', `foldTree', &c., not in the sense of `foldl',`foldMap',`fold',`Foldable')
23:11:11 <`Guest00000> is there a fold for natural numbers?
23:11:29 <`Guest00000> foldNat :: Int -> a -> (a -> a) -> a
23:11:42 <ski> you can define it, `foldNat :: o -> (o -> o) -> Nat -> o'
23:11:48 <ski> yes
23:11:58 <`Guest00000> yes, is there one in some library?
23:12:13 <`Guest00000> when there is something available in a library, i so much like it
23:12:40 <`Guest00000> i don't have to write another copy of definition... i can just import it
23:12:50 <ski> you'll have to decide which type you want to use for the naturals. there's probably some packages defining some variation of it
23:13:11 <`Guest00000> Int would be fine
23:14:13 <ski> i wouldn't be surprised, but i don't recall any
23:14:17 <platz> but there are many folds for those types.. there seem something special about the ones that have a 1-to-1 correspondence w/ the constructurs
23:14:53 <`Guest00000> also, it looks like evaluating power of monoid
23:14:54 <adam_> Guest I think that you can use the Word type
23:15:02 <adam_> its like an Int that can only be positive
23:15:03 <`Guest00000> where monoid is (a -> a)
23:15:29 <`Guest00000> mpower :: Monoid m => m -> Int  -> m
23:15:33 <adam_> toss a import Data.Word 
23:15:49 <adam_> then you can say like Word64 as a 64 bit "natural number"
23:16:46 <`Guest00000> foldNat n z s = (getEndo mpower (Endo s) n) z, hm...
23:17:04 <`Guest00000> those wrappers get in way :/
23:18:56 <`Guest00000> s/getEndo/getEndo $/
23:19:19 <ski> platz : "fold" in this sense is defined in correspondence with the constructors
23:19:58 <`Guest00000> :t getEndo
23:19:59 <lambdabot> Not in scope: ‘getEndo’
23:20:01 <platz> ski: ah, ok - thanks
23:20:03 <`Guest00000> :t runEndo
23:20:04 <lambdabot> Not in scope: ‘runEndo’
23:20:53 <`Guest00000> huh
23:21:00 <nut_> what's the difference between the two http client libraries: wreq and http-conduit?
23:21:15 <nut_> in terms of functionality
23:21:21 <nut_> and features
23:22:56 <`Guest00000> oh 
23:23:39 <`Guest00000> it's appEndo
23:23:58 <`Guest00000> how do i remember those wrappers ields names?
23:24:43 <`Guest00000> i remember that monoidish things are getXXX
23:25:02 <`Guest00000> but Endo is appEndo...
23:25:43 <ski>   endoThing `appEndo` inputArgument
23:43:05 <nut_> anyone use sublime text inside a cabal sandbox ?
