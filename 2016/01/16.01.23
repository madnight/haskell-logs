00:07:38 * hackagebot Gifcurry 0.1.0.1 - Create animated GIFs, overlaid with optional text, from movies.  https://hackage.haskell.org/package/Gifcurry-0.1.0.1 (lettier)
00:07:38 * hackagebot cmark 0.5.1 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.1 (JohnMacFarlane)
00:09:51 <jle`> presto appendo
00:25:29 <tekkkz> guys, cant i use symbols like ◊ for function names?
00:27:46 <ski> > isLetter '√ó'
00:27:48 <lambdabot>  False
00:27:52 <ski> > let (√ó) = (*) in 2 √ó 3
00:27:54 <lambdabot>  6
00:28:03 <ski> > isSymbol '√ó'
00:28:05 <lambdabot>  True
00:28:08 <ski> tekkkz ^
00:28:53 <tekkkz> ahh okay
00:29:34 <tekkkz> nice ty
00:31:08 <ski> > let (√ó) = liftA2 (,) in [0,1] √ó [0,1,2]
00:31:10 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
00:32:24 <jle`> what are some interesting quotient types yall can think of
00:32:32 <jle`> to test out my quotient type library
00:33:05 <jle`> i already have / Z6, [a] / elems (Set), (Natural, Natural) / difference
00:33:16 <jle`> i guess Ratio is one but that's already in base
00:35:35 <ski> i suppose unordered pair
00:36:32 <ski> cycle
00:37:40 <ski> tensor
00:39:41 <EvanR> whats tensor as a quotient type?
00:39:58 <jle`> hm thanks
00:41:08 <ski> well, if `u' and `v' are vectors in vector spaces `U' and `V', then `tensor(u,v)' is a vector in `Tensor(U,V)'. if `k' is a scalar, then `tensor(k*u,v) = tensor(u,k*v)'
00:44:13 <ski> in general, an element of `Tensor(U,V)' is a (finite) sum (associative, commutative, as usual) of basic elements of the shape `tensor(u,v)'. `tensor' also satisfies the laws : `tensor(u0 + u1,v) = tensor(u0,v) + tensor(u1,v)' and `tensor(u,v0 + v1) = tensor(u,v0) + tensor(u,v1)'
00:44:55 <EvanR> so which type do you do a quotient on
00:45:50 <ski> the free vector space on the cartesian product of the carrier sets of `U' and `V'
00:47:30 <ski> iow, you take each pair of two vectors (not necessarily basis vectors) from `U' and `V' as a *basis* vector for this new free vector space (so it's quite large, in comparision to `U' and `V')
00:47:55 <EvanR> and the equivalence are these laws?
00:48:43 <ski> iow, basically you have "lists" of such pairs, except you can also scale the pairs with any scalar (including with `-1', "negating" it)
00:49:12 <ski> obviously `tensor(u,v) + (-1)*tensor(u,v)' should be the zero vector
00:49:36 <ski> (and since vector addition is commutative, the order in the list doesn't matter either)
00:50:25 <ski> then, if you can show that two such "lists" of scaled pairs are equal, possibly also using the additional three laws above, they are to be considered the same element of the quotient type
00:53:01 <ski> i suppose you can think of the free vector space construction as a quotient itself. of `data FreeVectorSpace basis = BaseVector basis | Scale Double (FreeVectorSpace basis) | Add (FreeVectorSpace basis) (FreeVectorSpace basis)', under the vector space laws for `Scale' and `Add'
00:54:23 <ski> (replace `Double' with whatever type you want to use for the scalars)
00:54:40 <EvanR> fascinating
00:56:09 <ski> there's something similar for abelian groups. possibly slightly more simple
00:56:55 <ski> note that `Tensor(Double,Double)' should be iso to just `Double'
00:57:39 <ski> (the vector space of the scalars is the neutral element to `Tensor')
00:57:43 <EvanR> whoa https://en.wikipedia.org/wiki/Penrose_graphical_notation
00:57:47 <EvanR> crazy pictures
00:58:41 <koz_> I'm a little confused about newtype. If I declare something like 'newtype Foo = Foo [Int]', does that allow me to use 'Foo' instead of [Int]? So could I do something like 'map (1+) bar' where bar is a Foo?
00:58:41 <ski> hm, that looks fun
00:59:12 <ski> koz_ : no. you have to explicitly use the constructor (constructing or pattern-matching)
00:59:17 <koz_> ski: Ah.
00:59:22 <koz_> Well, that explains it.
01:00:08 <koz_> I guess I could just instantiate all the typeclasses on Foo that I need to do the forwarding.
01:00:22 <koz_> Which I will probably do.
01:00:41 <ski> koz_ : you could try using the extension `GeneralizedNewtypeDeriving' for that
01:00:53 <koz_> ski: I'll investigate.
01:01:38 <koz_> Also - if I instantiate typeclasses on my type that depend on each other, does the order matter? For instance, if I have an instance of Show Foo relying on Foo being a Functor, do I have to instantiate Foo as a Functor *before* I instantiate it as a Show?
01:02:01 <ski> koz_ : order of top-level definitions doesn't matter
01:02:29 <koz_> ski: Oh, cool. Figured as much, but asking never hurts.
01:02:45 <ski> that's what we're here for :)
01:03:01 <koz_> Also, ski, I just looked up GeneralizedNewtypeDeriving, and a *lot* of people on the internet say that it's profoundly unsafe. Should I be concerned
01:03:04 <koz_> ?
01:03:32 <ski> it can be unsafe in conjunction with some other extensions
01:03:41 <jle`> i haven't had much problems with GeneralizedNewtypeDeriving, just avoid DeriveAnything
01:03:48 <jle`> i mean, even the name sounds scary
01:04:05 <koz_> jle`: Well, yeah. Semantically at least.
01:04:24 <jle`> it's like five kinds of magic bottled into one evil extension
01:04:30 <ski> jle` : anyway, cycles could be a fun example
01:04:53 <jle`> yeah, cycles on tuples would be a nice example
01:04:54 * ski ponders what could be useful operations on a cycle
01:05:07 <koz_> jle` and ski: So if I use GeneralizedNewtypeDeriving, would it 'forward' something like 'newtype Foo = Foo [Int]' and define Foo as a functor, applicative, monad, traversible etc etc etc?
01:05:20 <jle`> well, Foo can't be any of those
01:05:22 <ski> hmm .. i suppose you can represent a permutation by a set of cycles
01:05:36 <ski> and then you can add and multiply such sets of cycles
01:05:39 <jle`> koz_: but, newtype Foo a = Foo [a] should work
01:05:45 <ski> (and, in fact, exponentiate as well :)
01:05:57 <koz_> jle`: Why would it work on a general type, but not a specific one?
01:06:08 <jle`> wrong kind
01:06:08 <koz_> Surely everything that an [a] can do, an [Int] can *also* do?
01:06:24 <jle`> [a] is not a Monad.  [] is a Monad
01:06:38 <koz_> Ah, same goes for functor, traversible etc?
01:06:38 <ski> with `newtype Foo = Foo [Int]', `Foo :: *'. with `newtype Foo a = Foo [a]', `Foo :: * -> *'
01:06:41 <jle`> mhm
01:06:50 <ski> `Functor' want a `* -> *' thing, not a `*' thing
01:07:03 <jle`> but it should be able to derive Monoid
01:07:07 <jle`> if you're into that sort of stuff
01:07:07 <koz_> I see.
01:07:13 <koz_> Well, I guess I'm hand-forwarding then.
01:07:20 <koz_> Not a huge issue - just kinda annoying.
01:07:29 <ski> iow, `Functor' requires the "container type" being *generic* in the type of elements
01:07:50 <jle`> koz_: it wouldn't really make sense for Foo to be a Functor, anyway
01:07:55 <jle`> what would the type of fmap be?
01:07:57 <koz_> jle`: Yeah, that's a bad example.
01:09:10 <koz_> I guess I'll just have to unwrap that thing and *then* use fmap or whatever.
01:09:58 <EvanR> what :(
01:10:17 <EvanR> make it an instance of functor and dont do that
01:11:11 <EvanR> oh Foo [Int]
01:11:15 <koz_> EvanR: jle` and ski just told me that 'newtype Foo = Foo [Int]' can't be made a functor.
01:11:19 <koz_> And I get why.
01:11:25 <EvanR> youll need to make a special Foo-map then
01:11:44 <EvanR> which takes a Int -> Int
01:11:46 <jle`> you can make it a MonoFunctor
01:11:57 <koz_> jle`: My thoughts *exactly*.
01:11:58 <jle`> and GeneralizedNewtypeDeriving should be able to get you the free MonoFunctor instance
01:12:05 <jle`> you just need to add the type family
01:12:49 <koz_> jle`: You mean the Element one, right?
01:12:51 <EvanR> oh wow Monofunctor
01:12:56 <jle`> yeah
01:13:02 <koz_> Ah, that'd be why it's complaining.
01:14:19 <koz_> One more reason why I love classy-prelude.
01:14:29 <koz_> Even if it forces me to play with a lot of Haskellisms.
01:14:57 <koz_> Hmm, jle`, it doesn't *seem* to autoderive me a MonoFunctor.
01:15:03 <ski> hm, is a mono-functor a functor whose domain is a full subcategory on some singleton object set ?
01:15:31 <koz_> ski: http://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html#t:MonoFunctor
01:15:34 <koz_> If it helps any.
01:19:35 <koz_> OK, I *must* be doing *something* wrong here, because this complains: http://paste.rel4tion.org/228
01:20:38 <jle`> koz_: omap f x :: [Feature]
01:20:46 <jle`> but you want to return an Antecedents
01:21:10 <ski>   omap f (Antecedents x) = Antecedents (..f..x..)
01:22:03 <koz_> Ah, derp. Thanks.
01:22:35 <koz_> That makes sense. I blame being tired after a 3-hour hike.
01:26:43 <magrathean> I needed some help on split: "a/b/c","a/b/c/d","a/b/e/f","a/b/e/d" should be split on alphabetical sort into chunks ["a/b/c","a/b/c/d"] and ["a/b/e/f","a/b/e/d"]
01:27:42 <magrathean> That is split on the first change in a sorted list.
01:28:17 <Gurkenglas> Can you give another example? perhaps shorter
01:28:57 <Gurkenglas> > groupBy (<) [1,2,3,2,3,4,1,3,5]
01:28:59 <lambdabot>  [[1,2,3,2,3,4],[1,3,5]]
01:29:16 <Gurkenglas> (Oh wait that compares to the current one)
01:29:26 <Gurkenglas> *to the first not the current one wtf brain
01:30:46 <magrathean> The / was extraneous, sorry - ["abc","abcd","abef","abed"] to ["abc","abcd"] and ["abef","abed"]
01:31:38 <Gurkenglas> Yea but like another example :D I have the feeling there's an implicit assumption in that example if I ask you to give one that uses one-digit numbers
01:31:57 <Gurkenglas> *"that disappears if" where are my subsentences going :(
01:33:00 <ocharles_> Given  newtype Dropper a m = Dropper (a -> m (Dropper a m))  with mkDropper n = Dropper (\_ -> pure (mkDropper (n - 1))  - does anyone know how to rewrite that using Mu?
01:33:02 <ocharles_> (or Nu)
01:33:15 <Gurkenglas> Why not Fix?
01:33:19 <ocharles_> That is currently written as basically using Fix inlined, but I'm wondering if Mu has different performance characteristics
01:33:30 * hackagebot relational-query 0.8.0.2 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.0.2 (KeiHibino)
01:33:41 <ocharles_> That is Fix (Compose (a ->) m)), I want to try Mu (Compose (a -> ) m)
01:34:46 <jle`> you want to inline the Mu?
01:35:03 <ocharles_> don't really care to inline Mu, but I can't work out how to construct mkDropper using Mu
01:35:13 <ocharles_> the important thing is that I can unwrap this structure one "level" at a time, as I can with Fix
01:35:24 <ocharles_> maybe that's not possible with Mu, because it basically seems to take a whole fold function up front
01:36:40 <ocharles_> I use this Dropper type to construct something like     \_ -> return $ \_ -> return $ \_ -> return $ let go = \a -> yield in fmap go . yield   - this dropper ignores it's argument 3 times, then repeatedly calls yield. I use this inside a StateT computation
01:36:49 <jle`> looks like ListT without Nil
01:37:01 <jle`> StreamT
01:42:14 <Gurkenglas> ocharles_, is there a condition to abort that recursion, or does n just continue into negative infinity?
01:42:48 <ocharles_> base case is at n <= 0, at which point mkDropper is mkDropper n | n <= 0 = let yielder = Dropper (\a -> yielder <$ yield a) in yielder
01:44:15 <saurabhnanda> hey, can anyone help me with: http://lpaste.net/150553
01:45:31 <saurabhnanda> I understand that (x :: Either e String) whereas (try (return (read i :: Integer))) :: (Either e Integer)
01:45:40 <Gurkenglas> Use (Left e) instead of x in the return
01:46:10 <saurabhnanda> but why can't the compiler understand that one branch of the case will ALWAYS return an error and the other an IO (Integer)
01:46:41 <jle`> i'm not sure what you mean by that
01:47:02 <jle`> the first branch of the case returns whatever you chooose for it to return
01:47:07 <jle`> it can return Right 10
01:48:21 <saurabhnanda> jle`: but it's static code right. At compile-time can't the compiler figure this out?
01:48:29 <jle`> figure what out?
01:48:42 <jle`> "one branch of the case will always return an error"
01:48:49 <jle`> what error is being returned?
01:48:55 <saurabhnanda> Gurkenglas: replaced it with (return (Left e)) and now stuck with this -- No instance for (GHC.Exception.Exception e) arising from a use of ‚Äòtry‚Äô
01:49:27 <jle`> in that case, you have to specify what type of Exception you are catching with try
01:49:37 <saurabhnanda> jle`: (Left e) -> return x ---- where x is the original (Either a b) being pattern matched
01:49:57 <Gurkenglas> saurabhnanda, paste the full error please
01:50:16 <jle`> saurabhnanda: are you expecting ghc to do implicit/automatic type conversion?
01:50:23 <jle`> that's usually a bad idea in general;
01:50:44 <jle`> if i use a String where i want an Int, but GHC automatically coerces the types to match up without telling you?
01:51:07 <jle`> you return an (Either e String) where you wanted an (Either e Int), it's clearly a compile-time type error
01:51:08 <saurabhnanda> Gurkenglas: http://lpaste.net/150553
01:51:35 <jle`> it's good for GHC to catch when you use the wrong type in the wrong situation :)
01:51:40 <jle`> that's the whole point of the type system :O
01:52:01 <saurabhnanda> jle`: I understand that one branch is IO (Either e String) and the other is IO (Either e Integer), but the former branch is guaranteed to always have 'e' and not String
01:52:18 <Gurkenglas> saurabhnanda, try the error's advice: Replace the type signature by "readIntegralFromFile :: GHC.Exception.Exception e => String -> IO (Either e Integer)"
01:52:54 <jle`> saurabhnanda: yes, but do you really want GHC to automatically coerce type errors away implicitly?
01:53:15 <jle`> have you ever worked with phantom types before?
01:53:15 <saurabhnanda> Gurkenglas: can you please explain why I need to do that? Should't type inference figure it out?
01:53:35 <EvanR> to use a lot of Either e for errors, you might want to just agree on an error type across he board to simplify
01:53:45 <jle`> saurabhnanda: the way your type is written, String -> IO (Either e Integer), it means that you can return *any* e that the caller asks for
01:53:46 <EvanR> but youre in IO so you might also want to just use exceptions
01:53:58 <jle`> saurabhnanda: so, if the caller asks for an IO (Either Bool Integer), it typechecks
01:54:03 <saurabhnanda> jle`: actually, I understand that if the compiler is being pedantic about it, then yes, it's a type coercion. But the program flow can tell it otherwise.
01:54:04 <Gurkenglas> If you left out the line with the type signature, it would; but you told it what type signature your program ought to have, and it couldn't verify that and complained
01:54:08 <jle`> if the caller asks for an IO (Either String Integer), etc, it typechecks
01:54:30 <jle`> but, `try` only works when the result is an instance of Exception
01:54:35 <EvanR> saurabhnanda: yeah what you think should happen is contradicting the type sig
01:54:44 <jle`> saurabhnanda: let's say you had a function foo :: Int -> a; foo x = x
01:54:46 <EvanR> that you wrote, thats what its complaining about
01:54:55 <jle`> > let foo :: Int -> a; foo x = x in foo 10
01:54:56 <Gurkenglas> try can't generate any e as you claimed, only the Exception ones. If the type signature said "readIntegralFromFile :: a", it would also complain, because your program doesn't belong into every type. This is good.
01:54:57 <lambdabot>      Couldn't match expected type ‚Äòa1‚Äô with actual type ‚ÄòInt‚Äô
01:54:57 <lambdabot>        ‚Äòa1‚Äô is a rigid type variable bound by
01:54:57 <lambdabot>             the type signature for foo :: Int -> a1 at <interactive>:1:12
01:55:15 <jle`> saurabhnanda: ^ the problem there is that "Int -> a" means, "give me an Int, and i can return a value of *any* type you ask for"
01:55:24 <jle`> i could do foo 10 :: Bool, foo 10 :: String, foo 10 :: Void, etc.
01:55:49 <jle`> but the way i implemented, the only `a` i return is Int
01:56:17 <EvanR> also instead of try you might want to use catch or bracket or finally or something else
01:56:22 <jle`> so, if your function is String -> Either e Integer, that means that your function should be able to return *any* e that your caller asks for
01:56:42 <jle`> but, `try` can't do this, `try` only works if the return type is asking for an instance of Exception
01:56:48 <jle`> see why this breaks:
01:57:01 <jle`> > let readAnything :: String -> a; readAnything = read in read "123" :: Int
01:57:04 <lambdabot>      No instance for (Read a) arising from a use of ‚Äòread‚Äô
01:57:04 <lambdabot>      Possible fix:
01:57:04 <lambdabot>        add (Read a) to the context of
01:57:11 <saurabhnanda> Hang on, foo :: Int -> a; foo x = x won't work?
01:57:18 <EvanR> no
01:57:26 <saurabhnanda> can't type-inference figure out that 'a' HAS TO BE only Int?
01:57:30 <Gurkenglas> saurabhnanda, http://lpaste.net/150553
01:57:31 <EvanR> what if a = String
01:57:42 <jle`> saurabhnanda: if you left the type signature off, it will be okay
01:57:46 <saurabhnanda> EvanR: I get that. But type-inference?
01:58:01 <EvanR> you have to consider the use case
01:58:02 <jle`> when you give a type signature, you're stelling type inference to shut up
01:58:13 <jle`> and you give the type you want
01:58:19 <saurabhnanda> so, does it mean that when we give a type-signature then the type-inference engine takes a "step back"?
01:58:20 <jle`> `Int -> a` *is* a type, and it has a meaning
01:58:41 <EvanR> saurabhnanda: if someone said, putStrLn (foo 3), what would happen
01:58:44 <jle`> yeah, it's like if you said x :: Bool, that tells the compiler that you want x to be a Bool
01:58:51 <jle`> and it doesn't do type inference to figure out what type x should be
01:59:00 <jle`> because you told it that it should be a Bool
01:59:02 <Gurkenglas> "foo :: Int -> a" is desugared to "foo :: forall a. Int -> a", meaning that you can provide any a for an Int. It is not desugared to something like "foo :: exists a. Int -> a".
01:59:20 <jle`> saurabhnanda: a type signature like (Int -> a) has a specific meaning, it's a specific type signature
01:59:31 <jle`> it's not a partially-inferred type signature
01:59:33 <saurabhnanda> Gurkenglas: about the parantheses, I"m coming from a Lisp background. not completely used to $
01:59:51 <jle`> saurabhnanda: do you know how type variables work, in type signatures?
01:59:54 <jle`> :t map
01:59:56 <lambdabot> (a -> b) -> [a] -> [b]
02:00:07 <EvanR> saurabhnanda: in case of putStrLn (foo 3) type inference does determine that a = String, but your implementation didnt
02:00:14 <jle`> a and b are type variables here, which means that you can get a monomorphic version of 'map' for whatever choice of a and b you want
02:00:19 <EvanR> return a String
02:00:22 <jle`> so, i could have map :: (Int -> Bool) -> [Int] -> [Bool]
02:00:34 <jle`> or, i can have map :: (String -> Double) -> [String] -> [Double]
02:00:36 <jle`> etc.
02:00:44 <jle`> pick anything for a and b, and i can give you a map specialized for that
02:00:54 <EvanR> saurabhnanda: but the user of the function was expecting to get a String, since they chose a = String
02:00:59 <jle`> so let's see what something of type `foo :: Int -> a` would mean ---
02:01:00 <saurabhnanda> jle`: and monomorphic is better because it's statically dispatched?
02:01:25 <jle`> `foo :: Int -> a` means, pick anything for a, and i can give you foo specialized for that
02:01:37 <jle`> so, i can give you a foo :: Int -> String, foo :: Int -> Bool, foo :: Int -> Double, etc.
02:01:51 <jle`> but the way it's implemented, this isn't true; if you wrote foo x = x, this clearly is a misimplementation of that type
02:01:52 <saurabhnanda> jle`: got it, thans
02:01:54 <EvanR> Int -> a means caller picks which a to use, as in length :: [a] -> Int
02:01:57 <saurabhnanda> EvanR: thanks, got it.
02:02:23 <EvanR> an example where you can randomly put a in the return type is error :: String -> a
02:02:45 <EvanR> because it will crash, satisfying the expectation that a value of "any type" will be returned, in this case bottom
02:03:11 <saurabhnanda> Not in scope: type constructor or class ‚ÄòGHC.Exception.Exception‚Äô
02:03:17 <jle`> you probably have to import it
02:03:29 <jle`> import GHC.Exception
02:03:40 <saurabhnanda> jle`: but I've already given it the entire dotted notation.
02:03:40 <EvanR> this sounds like an inconvenient way to handle exceptions
02:04:02 <jle`> ah
02:04:07 <EvanR> and also unsafe since its like "all exceptions"
02:04:11 <jle`> you want it from Control.Exception
02:04:54 <jle`> that's kind of a weird error
02:05:55 <saurabhnanda> okay, I'm royally confused with the number of Exception classes
02:05:57 <jle`> oh, GHC.Exception.Exception should work
02:06:14 <EvanR> you dont know the half of it ;)
02:06:20 <jle`> :k GHC.Exception.Exception
02:06:22 <lambdabot> * -> Constraint
02:06:31 <jle`> i wonder why it's not showing up for you
02:07:14 <saurabhnanda> ‚ÄòSomeException‚Äô is applied to too many type arguments
02:07:30 <saurabhnanda> In the type signature for ‚ÄòreadIntegralFromFile‚Äô:  readIntegralFromFile :: SomeException e =>String -> IO (Either e Integer)
02:08:25 <jle`> SomeException is not a typeclass
02:08:28 <jle`> it's a type
02:08:49 <EvanR> Exception e => ?
02:08:51 <jle`> but hm, why didn't Exception e => String -> IO (Either e Integer) work?
02:09:56 <jle`> saurabhnanda: by the way, if we take a step back like EvanR suggested from a higher level, the best thing you can do here is just provide an IO Integer
02:09:58 <saurabhnanda> ah
02:10:01 <jle`> instead of an IO (Either e Integer)
02:10:10 <jle`> it makes more sense here for the caller to handle the error
02:10:17 <jle`> so they can use try, catch, etc, however they want
02:10:18 <saurabhnanda> SomeException is a concrete class whereas GHC.Exception.Exception is a trait (or whatever it's called in haskell)
02:10:23 <EvanR> im not sure how youre going to implement a function of type Exception e => IO (Either e String)
02:10:45 <EvanR> er Whatever -> IO (Either e String
02:11:01 <jle`> saurabhnanda: i would do readIntegralFromFile :: String -> IO (Maybe Integer); readIntegralFromFile fname = fmap readMaybe (readFile fname)
02:11:19 <jle`> saurabhnanda: if it's an IO error, it makes more sense for the eventual caller to handle the exception, not this small helper file
02:11:44 <EvanR> now that i realize which direction this is going, yeah, just let the exception be thrown
02:11:45 <jle`> because `read` is a "pure" function that could error, it makes more sense to handle it by just returning (Maybe Integer)
02:11:49 <saurabhnanda> jle`: that's exactly what I was trying to do
02:12:02 <saurabhnanda> jle`: by return Either e Integer)
02:12:14 <jle`> which part were you trying to do?
02:12:16 <EvanR> you have to choose e
02:12:33 <jle`> it makes more sense for the eventual caller of readIntegralFromFile to handle the IO error
02:12:34 <EvanR> as far as reads exception, its not the kind of thing youre supposed to catch
02:12:43 <EvanR> use a read that returns a Maybe in the first place
02:12:50 <jle`> so returning IO (Maybe Integer)   -- where Maybe means a bad parse -- makes the most sense
02:13:02 <jle`> if it's an IO error (a disk read error, maybe), then propagate it up and let the caller handle it
02:13:11 <jle`> the Maybe just means if it was parsed or not, not if it was read or not
02:13:28 <saurabhnanda> hmm
02:13:32 <saurabhnanda> let me think about that a bit
02:13:35 <jle`> readIntegralFromFile fname = do i <- readFile fname; return (readMaybe i)
02:14:06 <jle`> the way haskell exceptions are set up, things work together really well if you just let IO actions propagate to wherever you eventually use them
02:14:11 <EvanR> alternatively, on Nothing, thrown an exception
02:14:41 <EvanR> and the return type would be IO Integer
02:14:54 <saurabhnanda> jle`: actually I have a philosophical question. Why are their Exceptions in haskell that need to be wrapped in try?
02:15:04 <EvanR> you usually dont use try
02:15:09 <saurabhnanda> why isn't everything handled by Either/Maybe
02:15:19 <jle`> exceptions in haskell are a tool provided by the runtime system for you to use in IO
02:15:25 <EvanR> IO exceptions are more convenient for exceptions that happen in IO, usually
02:15:53 <EvanR> connection disappeared, database barfed, out of memory
02:16:02 <EvanR> permission denied
02:16:04 <jle`> you can think of it like, a built in message passing system between threads and IO actions
02:16:29 <saurabhnanda> so, I was reading an integer from a file and the program compiled well. First-run it crashed, because the file didn't except. If, instead of exceptions, Haskell had forced me to pattern-match the result of a Maybe operation, I would've handled the case during compile-time itself.
02:16:37 <EvanR> for pure code something like a datatype for parser results is better than an exception
02:17:04 <EvanR> you wouldnt have handled it during compile time
02:17:10 <EvanR> checking Maybes is still runtime
02:17:35 <saurabhnanda> EvanR: but still enforced compile time
02:17:47 <EvanR> in pure code when you know nothing can fail, you dont use Maybe and you handle it no time (checked by the compiler)
02:18:25 <jle`> saurabhnanda: this chapter in this book here gives a nice explanation of how exceptions work, and their motivation, and why the system gives us more power in building better abstractions -- http://chimera.labs.oreilly.com/books/1230000000929/ch08.html#sec_exceptions
02:18:43 <EvanR> a simple way to deal with your question is to read the file (IO), then use a parsing function that does not use IO and returns a Maybe or Either
02:18:58 <EvanR> separate the two concerns
02:19:33 <EvanR> you typically dont want to do your entire program in IO
02:19:44 <jle`> saurabhnanda: it's also impossible to enforce that all IO exceptions are caught at compile-time
02:19:53 <jle`> IO exceptions can come from anywhere, that's the reality of doing IO
02:20:27 <jle`> asynchronous errors can come from unexpected places, or nowhere in your thread at all
02:20:44 <saurabhnanda> EvanR: I'm not sure why people keep saying that IO is so special. My entire code is littered with do blocks. Everything seems like IO for me.
02:20:58 <EvanR> well thats probably the lisp talking
02:21:16 <EvanR> haskell is a pure functional language so we like to sequester IO only in places its necessary
02:21:17 <jle`> what the Exception system provides is a powerful dynamic system you can use to handle IO exceptions as they fundamentally happen during the process of execution
02:21:33 <jle`> you can say that Maybe, Either, etc., are good for describing errors that might happen through evaluation
02:21:47 <jle`> but things that can come up during execution, that's a whole other world
02:22:27 <jle`> when you build an IO action, you're essentially building something that will be executed, so you need a system for managing all sorts of errors that might happen during IO execution
02:22:54 <jle`> returning Maybe's and Either's just isn't enough to really meaningfully work with IO errors that come up during execution
02:23:06 <EvanR> well thats what C does ;)
02:23:10 <EvanR> basically
02:23:16 <EvanR> but it can also crash via signals
02:23:17 <jle`> they work well when you're talking about functions, and evaluating values and functions on values, etc.
02:23:47 <EvanR> and the C way is popular in other trendy systems
02:23:53 <EvanR> exceptions are way better
02:24:31 <jle`> things definitely also get more complicated when you talk about parallelism and multi-core execution, etc
02:24:45 <saurabhnanda> jle`: why were you saying that let the error propagate upwards
02:25:04 <EvanR> that is how the exception workflow works
02:25:10 <jle`> and also Haskell has some quirky things with lazy IO, so readFile :: String -> IO (Maybe a) might be a complete lie
02:25:25 <jle`> readFile only opens the handle, the actual reading of the file happens later
02:25:37 <jle`> so even if you match and get a Just, the file might be gone by the time you actually read it
02:25:49 <jle`> execution of IO is weird!
02:25:50 <EvanR> write a function loadMyFile :: Path -> IO String and just use it. then operate on the String you get without worrying about if you actually get it
02:25:59 <jle`> saurabhnanda: let the error propagate upwards so the caller can choose how to handle it
02:26:10 <jle`> instead of enforcing a specific style of handling it'
02:26:17 <EvanR> if then you decide to worry about particular ways the reading of the file could crash, put a catch somewhere earlier in the code where its convenient
02:26:48 <saurabhnanda> EvanR: isn't that readFile?
02:26:50 <EvanR> none of the intervening code needs to know to propagate the error manually
02:27:01 <saurabhnanda> readFile :: FilePath -> IO String
02:27:32 <EvanR> dont use readFile, its "lazy IO"
02:27:47 <jle`> well, readFile sort of works here
02:27:53 <EvanR> >_>
02:28:07 <saurabhnanda> EvanR: what's strict IO then?
02:28:15 <EvanR> i would suggest System.IO.Strict readFile
02:28:35 <EvanR> readFile is a magic special command among only a few that do lazy IO
02:28:51 <EvanR> that is your IO activity will be interleaved with evaluating the rest of the program
02:29:03 <EvanR> so IO errors will crash you in apparently odd times
02:29:43 <EvanR> if you want to read the file completely into memory in 1 step, then do the parsing in the another step, you need "strict IO" which is the defaul
02:30:08 <EvanR> its the default except for readFile, getContents
02:30:21 <EvanR> and unsafeInterleaveIO
02:31:07 <saurabhnanda> okay, I'll read a bit about that
02:31:17 <saurabhnanda> but I'm stuck with compiling https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs right now
02:32:04 <EvanR> readIntegralFromFile :: String -> IO Integer
02:32:05 <saurabhnanda> error: http://lpaste.net/150557
02:32:20 <EvanR> change the sig to that and then try again ;)
02:32:34 <EvanR> hint you will then need to remove the try
02:33:02 <EvanR> (and possibly the version of readFile, if you want to control the lazy/strictness of IO)
02:34:18 <EvanR> that much will get it to compile assuming this is your only problem
02:37:19 <EvanR> after that you can modify the type again to force you to think about parse failure
02:37:55 <nut_> in Wreq, how do we define several param ?
02:38:18 <nut_> let opts = defaults & param "foo" .~ ["bar", "quux"]
02:38:51 <nut_> what if i want to add more parameter "q" .~ ["queryterm"]
02:41:03 <jle`> you can param "foo" %~ ("queryTerm":) i suppose, but i'm not sure if there's a nicer way
02:41:28 <jle`> > ([1,2,3],4) & _1 %~ (0:)
02:41:30 <lambdabot>  ([0,1,2,3],4)
02:42:02 <jle`> oh, you can use <>~
02:42:36 <jle`> oh, are "foo" and "q" the params?
02:42:44 <jle`> i misread and thought that you meant add more items to the list
02:43:09 <nut_> yes
02:43:14 <jle`> i feel like defaults & param "foo" .~ ["bar", "quuz"] & param "q" .~ ["queryterm"] should work
02:43:25 <nut_> foo=something&q=queryterm
02:43:29 <nut_> in the URl
02:43:46 <jle`> > (0,0) & _1 .~ "hello" & _2 .~ "world"
02:43:48 <nut_> jle`, no it doesn't
02:43:48 <lambdabot>  ("hello","world")
02:43:55 <jle`> what's the error?
02:44:06 <nut_> really complicated
02:44:11 <jle`> can you paste it?
02:44:34 <jle`> becuase of param "q" is a setter, it should work
02:45:35 <nut_> let me check again
02:47:12 <nut_> sorry it did work
02:47:14 <nut_> thanks
02:47:17 <jle`> np!
02:48:40 <nut_> jle`, what does the params do btw ?
02:49:19 <nut_> at first sight i thought it sets multiple parameters
02:51:16 <jle`> nut_: the one you gave for foo would give you somethjing like http://blahblah/get?foo=bar&foo=quux
02:51:46 <jle`> that `params "foo"` actually *is* is a lens into  the "foo" parameters of the Option
02:52:03 <jle`> so you can use it to set the "foo" parameters, or modify them, or retrieve them, etc.
02:52:40 <nut_> ok understood
02:53:10 <jle`> you can think of it as just a value that tells .~ and %~, etc. "how" to look up/modify "foo" in the Option
02:53:28 <jle`> like an address to where "foo" exists inside Option, sorta
02:54:36 <nut_> jle`, do people use Wreq to directly parse JSON from websites?
02:55:00 <jle`> i do; well, Wreq's json capabitilies are simply a wrapper around aeson
02:55:11 <nut_> I'm pulling articles from the Guardian webiste with Haskell API already
02:55:15 <jle`> a lot of times people use aeson directly; wreq just sort of automates it for you
02:55:30 <nut_> but today i found out about Wreq that seems to be able to directly achieve this
02:55:32 <jle`> automates the HTTP part and ties it to json
02:55:49 <jle`> yeah, wreq ties together aesom with http stuff so make a more convenient workflow
02:56:29 <nut_> so with Wreq its usually no longer necessary to use those API provided by some websites
02:56:45 <jle`> is there really a guardian haskell api?
02:56:50 <nut_> yes
02:56:51 <nut_> haha
02:56:56 <jle`> haha
02:57:13 <nut_> not offically
02:57:15 <jle`> well, a lot of times, haskell api's will give you nice data types that the json would parse into
02:57:17 <nut_> but still
02:57:32 <jle`> if you just use wreq alone, you'll have to make your own data types to parse the data into
02:57:47 <jle`> or work with just plain map-with-key-strings-and-lists raw json
02:58:15 <nut_> ok so a set of haskell api still make life a bit easier
02:58:36 <jle`> the preferred workflow of using aeson to work with json is to create a normal haskell data type that represents the data you want to get, and then use aeson's tools to generate/create a way to turn json into the object you want
02:58:53 <jle`> the process is pretty streamlined and works well, thanks to how aeson is set up
02:59:11 <nut_> guardian api did just that
02:59:27 <jle`> yeah, so this is what a haskell API library would be helpful with; you wouldn't have to make it yourself
03:00:01 <jle`> but you can combine their data type with wreq, as well, and use the FromJSON instance they defined with wreq, to integreate the HTTP aspect
03:00:39 <jle`> with aeson you can also work with "raw json", if you are looking to hack together something quickly, so you wouldn't need to make a custom data type or use one from an api
03:01:13 <jle`> so say if you just wanted to know an article author's name, you could just work with the raw json using aeson+wreq and get it there.  but this isn't really recommended except for hacky one-offs
03:01:33 <jle`> well, aeson+wreq+lenses
03:01:45 <EvanR> working with raw json is kind of like using dynamic typing in haskell
03:01:48 <Wizek> Can a cabal flag be queried from within a .hs file with `#ifdef`?
03:02:08 <EvanR> it can work, but youre not always going to be sure
03:02:36 <jle`> i actually do work with raw json sometimes when i really only want one or two fields in the json object i'm receiving and that's all i'll ever need, so it'd be overkill to make an entire data type and write the FromJSON etc. instances
03:02:55 <EvanR> i guess so, and when the field is not found?
03:03:01 <jle`> and, using the lenses from aeson-lens that are re-exported by wreq makes it pretty simple/fast to use, almost like in javascript
03:03:08 <hexagoxel> Wizek: no, but you can add the CPP defs conditionally manually.
03:03:10 <nut_> EvanR, good question
03:03:46 <Wizek> hexagoxel, how so?
03:03:46 <EvanR> well, when all the relevant fields are not all found
03:04:02 <jle`> well, the lenses work well to propagate Nothing's to the top, so you just get a giant Maybe a that you can choose to handle at the time.  it's not the ideal workflow and it's not maintainble, but it works as a fast hack :)
03:04:13 <EvanR> nice
03:04:44 <EvanR> Nothing is haskell's nil ;)
03:05:19 <jle`> but at least it's encoded in the type :O
03:05:35 <EvanR> more like using Nothing as if it were nil
03:06:41 <EvanR> im now trying to comprehend the semantics of unsafeInterleaveIO, is it really unsafe, in what sense is it safe anyway, in what practical sense does it suck...
03:07:01 <EvanR> 99% of comments say dont use it
03:07:15 <EvanR> but i wonder if its technically not any more unsafe than normal
03:07:15 <hexagoxel> Wizek: something like https://github.com/haskell/cabal/blob/master/cabal-install/cabal-install.cabal#L258-L260
03:07:51 <hexagoxel> Wizek: if flag(my-flag) { cpp-options: { -DMYFLAG }}
03:08:01 <Gurkenglas> Some and many should have as laws not that its implementation be the least defined fixed point of its default implementation, but that its implementation be either more or less defined than every fixed point of its default implementation(, and aspire to be as defined as possible). (Any of the marked points on http://sketchtoy.com/66510198 )
03:09:01 <EvanR> Gurkenglas: whoa was this to me?
03:09:26 <Gurkenglas> It was kinda into the channel, so sure :P
03:09:46 <EvanR> or accidentally execution of your scott topology chat script 
03:09:49 <Wizek> hexagoxel, thanks, giving that a try! Might there be other ways to query the cabal flag than through the CPP, e.g. at run time?
03:10:07 <Gurkenglas> Unrelated to the previous discussion, and a repost from yesterday when nobody reacted to it because they were busy explaining... IO, I think?
03:10:22 <hexagoxel> Wizek: i don't think so.
03:10:34 <EvanR> :t some
03:10:35 <lambdabot> Alternative f => f a -> f [a]
03:10:39 <EvanR> :t many
03:10:41 <lambdabot> Alternative f => f a -> f [a]
03:11:33 <Gurkenglas> Yea, its documentation of "one or more" and "zero or more" is not that nice, I only just recently got what they're for in the alternatives that behave like Maybe and List and MaybeT and ListT
03:12:24 <Gurkenglas> It's an unfold, for Maybe-like alternatives it returns the results of the longest chain of applications that doesn't fail
03:14:02 <Gurkenglas> Except that the default implementation is unfortunately too strict. For Maybe, the fixed points of many (Just x) are _|_ and Just (repeat x), and I'm saying that the implementation should behave like the latter, and the laws should say that
03:14:17 <EvanR> oh wow the docs now have laws, it used to just say "a monoid on applicatives"
03:15:07 <nut_> jle`, http-conduit and Wreq are both http client library. how to you choose?
03:15:19 <jle`> i use wreq
03:15:20 <EvanR> > many (Just 3) :: Maybe [Int]
03:15:24 <lambdabot>  mueval-core: Time limit exceeded
03:15:27 <EvanR> wtf
03:15:59 <jle`> nut_: wreq is more than just an http client library; it integrates a lot of things together that gives you a smoother workflow for doing normal stuff
03:16:11 <Gurkenglas> _|_ is a fixed point of many (Just 3), and repeat 3 is another. _|_ is the least fixed point, so lambdabot gives you _|_.
03:16:29 <jle`> i'd use http-conduit if it's a part of a larger, more disciplined infrastructure
03:16:39 <nut_> ok
03:16:44 <EvanR> Maybe is specifically implemented like this because its the law?
03:17:05 <EvanR> or it was just left as default
03:17:15 <nut_> Wreq is almost like curl
03:18:00 <Gurkenglas> Was left as default
03:18:28 <Gurkenglas> @let manyLazy v = Just $ fromJust $ someLazy v <|> pure [] where someLazy v = (:) <$> v <*> manyLazy v -- Here, let's gurantee that _|_ is not a fixed point
03:18:30 <lambdabot>  Defined.
03:18:37 <Gurkenglas> > manyLazy (Just 3)
03:18:39 <lambdabot>  Just [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
03:19:24 <Gurkenglas> (That fromJust reflects the fact that since many gives the maximum chain of computations that dont fail, it doesn't fail.)
03:20:29 <EvanR> the maximum chain idea is from parsers?
03:21:03 <Gurkenglas> Yes. I guess somebody figured out it only needs applicative terms to define, and put it into Alternative.
03:21:07 <Gurkenglas> 'Alternative
03:21:44 <EvanR> > some (Just 3)
03:21:48 <lambdabot>  mueval-core: Time limit exceeded
03:22:00 <EvanR> > some Nothing
03:22:02 <lambdabot>  Nothing
03:22:31 <EvanR> > many Nothing
03:22:33 <lambdabot>  Just []
03:22:50 <EvanR> huh
03:23:43 <EvanR> > many (Just 0)
03:23:47 <lambdabot>  mueval-core: Time limit exceeded
03:23:56 <Gurkenglas> Alternative could get another method like "assertNotEmpty :: f a -> f a" that unsafely promises that the argument isnt empty (default implementation id) to enhance laziness, and use it in many as I did fromJust
03:23:56 <EvanR> where is it getting Just []
03:23:57 <statusfailed> Is "Either" a "coproduct" ?
03:24:15 <EvanR> yes
03:24:31 <Gurkenglas> EvanR, the longest chain of applications of Nothing that doesn't fail is the empty chain.
03:24:34 <statusfailed> thanks
03:25:14 <EvanR> how does it know that if Maybe didnt define anything especailly for that case
03:26:24 <Gurkenglas> The default implementation says so. many Nothing = some Nothing <|> pure [] = ((:) <$> Nothing <*> many Nothing) <|> pure [] = Nothing <|> pure [] = pure []
03:27:15 <EvanR> ok not talking about default impl of Alternative
03:27:32 <Gurkenglas> ??? That's what Maybe uses
03:27:44 * EvanR checks
03:28:19 <Gurkenglas> Like it didn't define anything to overwrite the default implementation, so it is used by default
03:29:06 <EvanR> looks like it has an impl now https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#Alternative
03:29:16 <EvanR> and its not bottom (unless you pass in bottom)
03:29:38 <EvanR> oh nevermind
03:30:10 <EvanR> it defined <|> thats how it works
03:30:35 <Gurkenglas> Right, just like you don't have to define foldr if you define foldMap.
03:30:43 <Gagis> Hello! Haven't had a chance to work with Haskell in ages so now that I am working on a project of my own I might tro to do it functionally. I need tips for available libraries or packages that could make my work easier. Building a baby monitor from a raspberry pi zero running raspbian and ...
03:30:48 <Gagis> ... connected to a usb microphone and usb temp. and humidity sensor. Need to write an application that analyzes the temp and hum data that I can get via command line tool or C library that would need to be wrapped and also monitor the microphone for if audio levels go over a treshold. Plan is to ...
03:30:53 <Gagis> ... feed this data to a web page hosted on the device and to transfer audio only when voice activation is active. alternative is wifi via some protocol to an android app.
03:30:57 <Gagis> are there are suitable libraries for any of the steps that could get me a headstart?
03:31:32 <EvanR> Gurkenglas: hmmm. Just [3,3,3,3,3,... would make more sense why?
03:31:41 <EvanR> not crashing is good but
03:34:13 <Gurkenglas> Because it's an unambigous greater definition (In http://sketchtoy.com/66510198 , undefined would be at the root and Just (repeat 3) above the split (nevermind that there are only two fixed points in this case))
03:35:56 <Gurkenglas> Another way to look at it is: for MaybeT m instead of Maybe, you can have many x = MaybeT (m (Just xs)) where xs is a list of any length, but it's still strict, so if xs would be infinite, we bottom out instead. It should be lazy, stream the infinite list, and thus so should Maybe.
03:37:18 <Gurkenglas> > evalStateT (many $ StateT uncons) [1..5]
03:37:19 <lambdabot>  Just [1,2,3,4,5]
03:37:23 <Gurkenglas> > evalStateT (many $ StateT uncons) [1..]
03:37:25 <lambdabot>  *Exception: stack overflow
03:37:44 <Gurkenglas> (Not sure if the StateT one could be made lazy.)
03:38:34 * hackagebot threepenny-gui 0.6.0.5 - GUI framework that uses the web browser as a display.  https://hackage.haskell.org/package/threepenny-gui-0.6.0.5 (HeinrichApfelmus)
03:41:41 <Gagis> Awesome. threepenny is exactly what I need for output
03:43:57 <EvanR> lol
03:44:19 <EvanR> only the bot can help you now
03:44:44 <EvanR> Gagis: people in #electronics are really helpful for projects like this
03:46:39 <Gagis> EvanR: haha yeah that was a pretty damn fitting coincidence and thanks, I'll check out #electronics, after I first get the baby to sleep
03:50:03 <dobq> am i the last one to learn about -fdefer-type-errors ?
03:50:45 <ggVGc> I don't know what it does
03:50:55 <ggVGc> but I've been using haskell seriously for maybe a few weeks
03:51:13 <dobq> it tells ghc to do type checking at runtime
03:51:32 <ggVGc> why do you want that?
03:51:33 <dobq> so if your code has type errors, it will compile and run
03:51:35 <dobq> developing
03:51:38 <EvanR> sup Walt, still not sure how i can recognize despite that weird ass nick
03:51:41 <ggVGc> weird
03:51:49 <ggVGc> EvanR:  :)
03:51:55 <ggVGc> EvanR: how are you?
03:52:37 <EvanR> awake at 5:52AM for no reason
03:52:58 <ggVGc> dobq: for me the beauty of haskell is that I can sit in my editor and run the compiler until it works out, and when in doubt I ask what type an expression is so I can get guided to what I need to do. So, for developing haskell software I don't see why I would want to defer type checking
03:53:21 <ggVGc> EvanR: I'm currently in a cycle of falling asleep after 6am every day and getting up between 2pm and 4pm ...
03:53:24 <ggVGc> pretty much shit
03:53:24 <EvanR> its for a certain kind of debugging i think
03:53:34 <EvanR> yeah, its shit
03:53:39 <ggVGc> yesterday I spent 6 hours too long finishing a stupid SVG/CSS/JS thing for work
03:53:48 <dobq> ggVGc: e.g. if you're restructuring a big project, you don't want to wait until all of it compiles until you can see if it does what you intend it to do. sometimes you want to run intermediary dev states
03:54:12 <ggVGc> dobq: hm, but if it doesn't type check, how will you see how it runs>
03:54:13 <EvanR> https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/defer-type-errors.html
03:54:39 <ggVGc> ah yeah, that makes
03:54:40 <ggVGc> sense
03:54:42 <EvanR> ggVGc: youre hoping the parts that dont type check dont actually run
03:54:48 <ggVGc> I didn't think about it that way
03:54:52 <ggVGc> but that definitely is valid
03:54:58 <ggVGc> and I've been in that situation
03:55:06 <dobq> instead of having to cut out all code you haven't worked on yet
03:55:15 <ggVGc> I ususally solve it by commenting out stuff, but deferring type checking is nicer
03:55:22 <ggVGc> cool, I'll keep it in mind
03:55:55 <EvanR> i used to put undefined in, but then your type errors go away forever (until you remember to go delete undefined and put something that doesnt type check)
04:00:47 <EvanR> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/icfp12.pdf
04:05:44 <EvanR> this technology is freakin awesome
04:07:53 <Gurkenglas> http://lpaste.net/150561
04:08:03 <Gurkenglas> > evalStateT (manyLazy $ StateT uncons) [1..]
04:08:05 <lambdabot>  Just [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
04:09:56 <Gurkenglas> Why are MaybeT and ListT not MonadT Maybe and ListT List?
04:10:04 <Gurkenglas> *MoandT List
04:10:10 <Gurkenglas> *MonadT [] lol
04:14:13 <EvanR> isnt that related to the impossibility of arbitrary monad composability
04:14:18 <ski> Gurkenglas : there is no `IOT'
04:15:02 <Gurkenglas> The result wouldn't satisfy the monad laws in general, but why not? IOT m a = m (IO a)
04:16:05 <ski> `StateT s m a' is not `m (State s a)'
04:16:24 <Gurkenglas> StateT s m a is not MonadT (State s a) m
04:16:36 <Black0range> Are there any way to get around this problem? http://lpaste.net/150568 
04:16:50 <Gurkenglas> I said MaybeT and ListT, not StateT :P
04:17:24 <ggVGc> EvanR: I was just thinking.. People say python is good for learning programming, and that a large part of it has to do with clean syntax and being interpreted(so you don't also need to deal with learning to deal with a compiler). With deferred type checking maybe haskell can live up to that too?
04:17:59 <Black0range> ggVGc: I'm pretty sure teaching haskell to new programmers is a terrible idea :)
04:18:02 <EvanR> i wouldnt suggest deferred type errors to new people learning haskell
04:18:07 <ggVGc> Black0range: why so sure?
04:18:22 <Gurkenglas> EitherT e should be MonadT (Either e) though.
04:18:49 <EvanR> but if it were an interactive evaluation of source code (like the idrid repl) i think that would help a situation without type safety
04:19:06 <EvanR> it just gets stuck at some point instead of crashing
04:19:09 <Gagis> depends on the target audience I'd say. typical programmers and engineers have a lot of trouble with functional languages but Haskell is really damn intuitive for mathematicians and theoretical physicists wh o write their everyday work notes in a syntax that is practically identical to haskell :P
04:19:26 <ski> Gurkenglas : well, you can define `newtype MonadT m n a = MkMT (n (m a))', if that's want you want. but then i'd say that in my eyes the `MonadT' looks misleading (under the interpretation that `MonadT m' would be a reasonable "transformer version" of `m')
04:19:54 <ski> Gurkenglas : quite possibly i was reading too much into what you were sayign
04:20:17 <Black0range> ggVGc: Well to keep it short: I think it would be hard to find motivation to learn more when you kind of require a certain level of knowledge to do anything "useful" in haskell
04:20:17 <EvanR> Gagis: haskell as a first language is an interesting topic and ive heard positive reviews about it
04:20:53 <Black0range> ggVGc: meanwhile in python for example you can just do about anything, sure it crashed and you're sad but you actually ran a program 
04:21:00 <ggVGc> EvanR: haha, reading the informal description in this paper on deferred type checking, I actually chucled. It's a pretty sweet hack
04:21:07 <EvanR> yeah
04:21:10 <ggVGc> " Usually the constraint solver would immediately reject
04:21:10 <ggVGc> such a constraint as insoluble, but with -fdefer-type-errors
04:21:10 <ggVGc> we take a different course: we generate ‚Äúevidence‚Äù for Char ‚àº
04:21:10 <ggVGc> Bool, but ensure that if the (bogus) evidence is ever evaluated it
04:21:12 <ggVGc> brings the program to a graceful halt"
04:21:14 <ggVGc> that's great
04:21:17 <EvanR> pretty brilliant
04:21:48 <Gagis> EvanR: yeah it would be interesting to see some research on it. problem with my mathematical scenario is that all existing software, libraries and research projects are written in Fortran or C++, so youd have absolutely no one to collaborate with. Thats why I have never gotten to really use ...
04:21:53 <Gagis> ... haskell even though I work in computational nanoscience
04:22:34 <ggVGc> Black0range: yeah, but I don't think that is necessarily true. That's more cultural, and because of haskell being so mature now with so many experiments in it. If you take a subset of it, you have a fairly simple language with clean syntax and which is quite intuitive to read
04:23:00 <EvanR> ggVGc: theres no runtime overhead, like dynamic type checking
04:23:07 <ggVGc> Black0range: I've been messing with Elm the past months, and it's made it clear to me how Haskell without the more advanced stuff is actually very simple and easy to get into
04:23:30 <ggVGc> so I think you could definitely use a "dynamic haskell" as a teaching platform for completely new programmers
04:23:38 <EvanR> i should say, unlike dynamic type checking
04:23:43 <Black0range> ggVGc: But remember people starting to program doesn't know what programming is. They don't know if they like it. Throwing a few hundered pages in their faces saying "read this" wouldn't be good for morale
04:23:44 <ggVGc> you just need to treat it differently than the current haskell community does
04:23:45 <EvanR> and reflection
04:24:02 <ggVGc> Black0range: yeah that;s why you don't do that
04:24:13 <ggVGc> I don't think it's true you need all this theory before you can work in haskell
04:24:16 <EvanR> ggVGc: on the subject of "interpreted" being easier for people, well ghci is a REPL
04:24:17 <ggVGc> again, Elm is a great example of that
04:24:27 <EvanR> the code gets interpreted ;)
04:24:44 <ggVGc> EvanR: yeah, but it doesn't feel as a hands-on as running a python file
04:24:58 <EvanR> really?
04:25:10 <Black0range> Any ways anyone wanna help me with this? :D http://lpaste.net/150568 Are there any way i can make haskell know the difference between String and [a] ? 
04:25:10 <ggVGc> well, maybe it does. I honestly haven't done that much in ghci
04:25:19 <Gurkenglas> ski, at the least we could then do "instance Monad m => Monad (MonadT Maybe m)" and the like, and I could in http://lpaste.net/150561 do "instance (Monad m, AlternativeLazy m, Monad n) => AlternativeLazy (MonadT m n)"
04:25:24 <EvanR> it needs colors, but no one is being paid to do that
04:25:46 <ggVGc> Gagis: how do I get into computational nanoscience?
04:25:48 <ggVGc> sounds great
04:26:08 <EvanR> Black0range: well one is a specialization of the other
04:26:11 <EvanR> where a = Char
04:26:18 <EvanR> so there is kind of no diff
04:26:31 <ggVGc> wonder if EvanR is an instance of Monad
04:27:02 <EvanR> no
04:27:21 <Black0range> arrows maybe?
04:27:21 <Gagis> ggVGc: study science in one of the many universities around the world that have a nanoscience focus. most groups in the field probably SHOULD hire some real programmers or computer scientists too, but no one wants to dole out the funds for it :P
04:27:45 <EvanR> Black0range: type instance PathElement [a] = a
04:27:52 <EvanR> this doesnt work
04:27:58 <ggVGc> Gagis: I actually did study theoretical physics for a while, and I had plans to get into nanoscience for several years, but life brought me elsewhere
04:28:01 <ggVGc> still might happen
04:28:13 <Black0range> EvanR: it works :P 
04:28:32 <EvanR> String = [Char], so path element = Char ?
04:28:48 <EvanR> for String
04:29:11 <Black0range> EvanR: http://lpaste.net/150568 theres an instance that got the be in as well  
04:29:33 <EvanR> you might have to give up on defining this support for String
04:30:29 <Black0range> EvanR: Hmm would that be acceptable for a public module? 
04:31:19 <ski> Gurkenglas : hmm. that paste reminds me of some tricks i've played
04:31:24 <ruf> i'm struggling a bit with http://mightybyte.github.io/monad-challenges/pages/ex1-6.html - anyone familiar with ¬´The Monad Challenges¬ª and can help me out?
04:31:31 <EvanR> im not sure your toUrlPath types make sense
04:31:35 <ski> (also cf. `mfix')
04:31:50 <EvanR> (IsString p) => p -> p, with default impl = id
04:32:04 <ski> Gurkenglas : are you using `someLazy' and `manyLazy' in recursive knots ?
04:33:01 <Black0range> EvanR: well trying to make a class for data that could generally be described as a "path"
04:33:19 <Gurkenglas> ski, no, I'll be using manyLazy as an unfold so I can use monad transformers instead of monad-loops
04:33:24 <EvanR> Black0range: right theres probably a better way 
04:33:41 <vektor> Does anyone here know what's the current status of LambdaCube? Is it already mature enough to start making game prototypes in?
04:33:49 <EvanR> how about an interface where it can convert to and from a list of strings
04:34:07 <Gurkenglas> ski, although I'm not sure that that is not this "recursive knots" thing you speak of ^^
04:34:19 <EvanR> and this inteface could be a type class, or really a record with those two functions in it
04:34:53 <ski> @src Maybe mfix
04:34:54 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
04:35:25 <ski> Gurkenglas : elaborate on the "unfold" ?
04:35:55 <Gurkenglas> Oh, and line 18 was wrong.
04:36:05 <Gurkenglas> (Didnt update the comment)
04:36:39 <Gurkenglas> > evalStateT (manyLazy $ StateT uncons) [1..] -- Here, StateT uncons is unfolded, ie done until it doesnt work.
04:36:41 <lambdabot>  Just [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
04:38:04 <ski> and the issue is that you want it to work on infinite lists, ok
04:38:25 <ski> can you ever get `Nothing' ?
04:38:31 <Gurkenglas> Not with many.
04:38:42 <Gurkenglas> That's the point, that's why I can use unsafeAssertNotEmpty
04:39:27 <Gurkenglas> Well, not just infinite lists. many on Maybe-like monads can't return anything until it finds the failure point. This makes space leaks and breaks streaming.
04:40:24 <ski> (fwiw, i would have called it something like `promiseNonempty')
04:40:58 <Gurkenglas> :t liftM (fromJustNote "many") . runMaybeT . manyLazy . MaybeT -- https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:unfoldM
04:41:00 <lambdabot> Monad m => m (Maybe a) -> m [a]
04:41:11 <Gurkenglas> Sure why not I just wrote it.
04:42:48 <ski> (it's just a personal preference to try to state what you as a programmer is promising to the implementation, rather than vaguely stating that something is unsafe in some or other way. Mercury uses this convention (as language pragmas, not ordinary functions))
04:45:04 <Gurkenglas> I don't see the difference between promise and assert, and unsafe just says that it has non-functional side effects
04:47:12 <Gurkenglas> (You sure about that noncapitalization of empty?)
04:53:48 <ski> Gurkenglas : i had to check to make sure i wasn't imagining things, or possibly applying the conventions of one natural language to another one (english). but it indeed looks to me like "nonempty" is in use (as well as "non-empty", and obviously also "not empty"), at least judging from various math-related WP articles
04:54:50 <ski> i suppose "assert" could work in place of "promise". i'm not sure what the "non-functional side effects" would be here. perhaps you just mean the partiality
04:55:01 <Gurkenglas> Right, that.
04:56:59 <ski> personally i wouldn't use "unsafe" for that, wanting to reserve that for cases which can break equational reasoning (if you fail to satisfy preconditions), or worse(?), type safety
04:57:44 <ski> (which is part of the reason why i think "unsafe" in `unsafeInterleaveIO' is undeserved)
04:58:20 <EvanR> i was justing trying to square that one away
04:58:58 <EvanR> its not really any more unsafe than IO normally
04:59:50 <EvanR> but it does radically alter the way we think IO is usually executed
04:59:53 <Gurkenglas> https://hackage.haskell.org/package/transformers-0.5.1.0/docs/src/Control-Monad-Trans-Error.html#line-94 is wrong right? Because empty is not a left identity
05:00:34 <EvanR> its effects will be actually executed during a totally different action
05:02:05 <EvanR> its a bit hard to explain what the IO Whatever returned from unsafeInterleaveIO actually does "when executed"
05:02:15 <EvanR> which ostensibly is immediately
05:06:25 <EvanR> unsafe might be the wrong word but the behavior is farther outside the haskell narrative than normal
05:06:34 <ski> one model might be "spawn a thread which waits an indeterminate amount of time before executing the action and putting the result in a private slot that is only accessed when demanding the value of the result of the original action (blocking, say, if it's not available yet" ?
05:06:56 <ski> (compare with `IVar's)
05:07:57 <ski> EvanR : i think i would agree with that
05:08:19 <EvanR> the thread+ivar doesnt seem to explain it properly
05:10:37 <EvanR> maybe if you pull in the literal implementation of ghc into the explanation it would fit into the IO narrative
05:10:57 <EvanR> and pull in the implementation of say lazy bytestring
05:11:33 <ggVGc> I would never let my employess use haskell, because who would want their software to be lazy
05:11:36 <ggVGc> sounds crap
05:11:37 <EvanR> its the kind of information i think i need in clojure, though isnt really available there either
05:11:47 <ggVGc> we want proactive and intelligent software
05:12:41 <EvanR> you sound like haskell CEO
05:14:56 <ski> @quote enterprise.industry
05:14:56 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment. Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
05:15:19 <EvanR> lol
05:17:20 <ggVGc> I've taken lazy IO to the level of me not implementing features until I get bug reports that they don't work
05:28:37 * hackagebot dixi 0.6.0.5 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6.0.5 (LiamOConnorDavis)
05:38:08 <mahe2> Hi, what's the best way to compile a Haskell program for an environment running a different glibc version?
05:40:41 <SrPx> Hello. If anyone is up to a challange, I think I'll have something very cool to post if I figure this out: http://stackoverflow.com/questions/34964144/how-to-generate-a-bit-string-that-loops
05:42:24 <quchen> That's a pretty convoluted question.
05:42:25 <quchen> √ºq lambdabot 
05:42:46 <quchen> > replicateM 3 "01"
05:42:49 <lambdabot>  ["000","001","010","011","100","101","110","111"]
05:50:57 <gameer> mauke: Bist du da?
05:54:26 <Geff22> Hello! I have a couple of silly questions. Does anyone know state of development of GLFW-b? And secondly, I have problem with GLFW-b and GHCi. When I call init function in REPL I get "GHC.exe crashed". I find in the internet that -fno-ghci-sandbox flag can help. I add them to my cabal file and also call :set -fno-ghci-sandbox in REPL. But after calling init it crash again. After many attempts I finally managed to make it work. Today I again lunch REPL, 
05:54:26 <Geff22> write some code. Is sounds stupid but after some executions REPL began to crash again. I back to my old code but this doesnt help. I have tried recompile project and dependencies but but that did not help me too. I really do not know how to solve this problem or at least understand the reason for its occurrence. So my question is, does anyone faced a similar problem and how it can be solved?
05:55:01 <dobq> SrPx: i'm pretty sure there's a mistake in your question
05:55:10 <SrPx> sure? dobq 
05:55:10 <dobq> SrPx: you're not starting on 010 011
05:55:55 <SrPx> dobq: true, thanks for pointing it
05:56:29 <dobq> SrPx: you should view your problem as a group-theoretic one. you are looking for an 8-cycle permutation.
05:56:54 <dobq> (or 2^n-cycle where n is the number of bits)
05:58:06 <FUZxxl> Gurkenglas: http://codegolf.stackexchange.com/q/69926/134
06:00:40 <dobq> SrPx: the problem with your gray_seqs is that i generates the product of two 1-cycles, a 2-cycle, and a 4-cycle
06:00:48 <dobq> s/i/it/
06:01:24 <dobq> (here talking about cycle notation)
06:01:28 <SrPx> Yes, that looks right!
06:01:45 <SrPx> I need something that always generates a complete 8 cycle (or 16, 32, etc, depending on the index)
06:02:05 <dobq> SrPx: yes, so any permutation of the 8 elements would work
06:02:15 <dobq> iow there exist (2^n)! solutions
06:02:22 <dobq> no, that's not true
06:02:30 <dobq> some of them are equal
06:02:45 <SrPx> Problem is, how do I generate it as an infinite list like that?
06:03:05 <dobq> what do you mean?
06:03:26 <dobq> is your question: how do i represent permutation groups in haskell?
06:06:24 <dobq> the number of solutions is (2^n - 1)!, where n is the number of bits
06:06:34 <SrPx> ... no
06:06:52 <SrPx> See, there is the function generating an infinite list of bitstrings
06:07:27 <SrPx> How do you replace it with another function that also generates an infinite list of bitstrings, except that one has the desired property?
06:08:17 <dobq> SrPx: so your question is: how can i generate an n-cycle for any n
06:08:21 <SrPx> I know there is a large number of tables that satisfy the criteria, I can easily draw one by hand (000 001, 001 010, 010 011 ... already satisfies it, for example) but I also need a *simple* function that generates that table. That is the problem.
06:08:39 <dobq> SrPx: i don't know what "simple" means in this context
06:08:49 <dobq> i think your example is quite simple
06:09:02 <SrPx> dobq: if if is called an n-cycle, yes. But more like: "how can I generate an n-cycle for any `n` by using `n` applications of a non-accumulating fold over a binary tree."
06:09:37 <SrPx> do, for example, I have: "data Tree a = Bin (Tree a) (Tree a) | Leaf a".
06:09:43 <dobq> SrPx: sounds like you might want to play around with destructing n-cycles into 2-cycles
06:10:11 <dobq> (any n-cycle is the product of (not necessarily disjoint) 2-cycles)
06:11:14 <SrPx> and the usual fold, "foldTree". I need a definition of `bin`, `leaf` and `init` such that `foo = foldTree bin leaf`, and `apply_n_times foo (Leaf init)` === the code I want 
06:11:33 <SrPx> I'll google about n-cycles now, thanks
06:12:40 <SrPx> I think it is a very complicated question to explain, but it might not be that hard to answer
06:13:15 <SrPx> I used lists on the SO question because if I defined the binary tree datatype, the fold over it, the flatten function for visualization, etc., the question would become too big
06:13:39 <dobq> SrPx: well maybe the question is big
06:13:52 <dobq> it's only after 10 minutes of discussion here that i understand the real question
06:14:06 <SrPx> well, fair enough
06:14:34 <dobq> but it smells like what you want to do is possible, and that you can construct an answer by thinking about permutation groups
06:16:45 <dobq> SrPx: did you try: next seqs = map ('1':) seqs ++ map ('0':) seqs ?
06:17:00 <SrPx> ... really? let me see
06:17:04 <dobq> (that probably doesn't do what i hope it does)
06:17:19 <dobq> (yeah no)
06:17:31 <SrPx> ah nope
06:17:32 <SrPx> heh
06:18:12 <SrPx> most things I try end up with 4 elems long chains, most
06:18:39 <dobq> next seqs = map ('0':) (init seqs) ++ ['1' : last seqs] ++ map ('1':) (init seqs) ++ ['0' : last seqs]
06:18:48 <dobq> except that that function looks bad
06:19:04 <SrPx> lol. yep, that works
06:19:30 <SrPx> *but* defining "init" on the binary tree above isn't possible with a single non-accumulating fold
06:19:45 <dobq> well yeah so clean up that function and treeify it
06:19:47 <SrPx> I think that is the problem with this question, to be honest. it is very hard to make precise what is not allowed
06:19:54 <SrPx> but great solution nether less, I didn't get so far
06:20:05 <SrPx> dobq: I'm doing that
06:21:20 <dobq> gtg
06:21:45 <lornaevo> Hi
06:21:50 <lornaevo> Good Morning All
06:22:47 <gameer> hey
06:23:05 <lornaevo> How are you?
06:23:10 <lornaevo> It's snowing here in nyc
06:28:44 <SrPx> good morning!
06:29:02 <SrPx> Well, I updated the question but he's left :( oh well
06:40:47 <thomie> What are people's opinions on this proposal: https://ghc.haskell.org/trac/ghc/ticket/11482 ("Turn -fdefer-typed-holes on by default")
06:43:21 <codedmart> If I have a data type like this https://gist.github.com/codedmart/a583e6664043f44072ba
06:44:20 <codedmart> How do I write a FromJSON instance for it. The JSON I expect wont contain the (I, T, or S)?
06:46:38 <bergmark> codedmart: impossible with that ToJSON instance, unless you promise that a, b, and c always have unambiguous ToJSON instances
06:47:29 <codedmart> bergmark OK what if they will always be ConditionValues Int Text String. Or something like that.
06:47:45 <bergmark> codedmart: Text and String have the same json representations...
06:48:16 <pavonia> If they really always have these types, you don't need the type parameters
06:48:40 * hackagebot pandoc-crossref 0.1.6.4 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.6.4 (lierdakil)
06:49:19 <codedmart> bergmark Maybe there is a better what, but here is my goal with ConditionValues. I want values in this data type to be either Int Text or SValue http://lpaste.net/150582
06:49:29 <codedmart> Is there a better way to handle that?
06:49:55 <codedmart> pavonia What do you mean?
06:50:49 <pavonia> codedmart: Do you use ConditionValues with different type arguments in your code?
06:51:06 <pavonia> other than "ConditionValues Int Text SValue" I mean
06:51:29 <codedmart> No I only made the data type so values could be one of those 3.
06:52:19 <pavonia> But why the type parameters?
06:52:47 <pavonia> Why not "data ConditionValues = I Int | T Text | S SValue"?
06:52:58 <codedmart> pavonia Right ok
06:54:05 <MarcelineVQ> thomie: interesting idea, was this prompted by people talking about -fdefer-type-errors earlier? I just tried it out and my tools inform me just as well when it's a warning instead of an error so personally I'm for it. It's still early though, you'll probably have better luck with feedback for that later in the day.
06:54:21 <Black0range> If I'm creating a new class A that has two methods, say: (String -> A b) and (A b -> String) what do you think is the best name for these methods? fromString, toString or toA, fromA?  
06:55:39 <codedmart> pavonia ok so if I use `data ConditionValues = I Int | T Text | S SValue` how do I parseJSON which one it is?
06:56:06 <thomie> MarcelineVQ: I didn't see the earlier discussion, but came across https://ghc.haskell.org/trac/ghc/ticket/8064 (Warning out when "undefined" value has been used.)
06:56:31 <pavonia> codedmart: I think you can use <|> to try another parser if the first failed
06:56:47 <codedmart> Ah right
06:57:38 <codedmart> Thanks
07:01:42 <OverCoder> Okay um, just a thought, wouldn't we end up having tons of variables just due to variables being immutable?
07:02:26 <OverCoder> I mean, I have just made a simple TODO list manager (nothing special, reads from a file, splits on newlines, and asks the users what to do and then does the job), but I felt like using too many variables
07:03:17 <OverCoder> I've compared it to the snipped in the tutorial and it looked almost the same, I am not having any kind of problem here, for now, but I can imagine if I build something medium to big sized the amount of variables will exceed +Inf >.>
07:04:15 <Ankhers> Anyone familiar with Esqueleto that would be able to help me figure out what is wrong with this query? http://lpaste.net/150584
07:04:15 <suppi> OverCoder, that's kinda hard to answer because you don't give a lot of information
07:04:29 <OverCoder> suppi, What kind of information I should give?
07:04:36 <OverCoder> I can paste the snippet if you like
07:05:06 <suppi> OverCoder, show a snippet, say what is wrong with it in your opinion, say how you'd make it better
07:05:19 <OverCoder> Okay
07:07:13 <OverCoder> Here's my paste http://pastebin.com/gcNQYNuH , the thing is that if I wanted to do this in imperative languages, I can reuse some variables, also variables being immutable means that whenever I bind the readFile to handle, handle can never be changed, and when I want to open another file, I'd have to use another name, and thus spamming the global namespace!
07:08:40 <OverCoder> Say here, for the sake of example, this is just part of a program, now handles as well as the temporary variables I created to manage the TODO list are all unneeded, I can't even delete them, and thus some sort of a memory leak all other the session, huh?
07:09:49 <suppi> OverCoder, first, you are not spamming the global namespace because the only thing defined in the module namespace is `main`
07:10:26 <suppi> second, you are writing a long program as one giant main, this is not good practice in any language
07:10:36 <OverCoder> Ah wait, so 'main' can simply act as a function in imperative languages? because iirc the tutorial says it's just some place we can do I/O
07:11:03 <suppi> main is a function and the entry point of your program
07:11:28 <scshunt> OverCoder: main is the only function that can ultimately do IO. Any other uses of IO need to be linked back to main
07:11:31 <suppi> just like void main() {} in C or something
07:11:46 <OverCoder> ahh, then there's nothing wrong then
07:11:58 <OverCoder> Thank you both
07:12:16 <hexagoxel> main is not the only function that "can do IO"
07:12:32 <scshunt> hexagoxel: unsafePerformIO doesn't exist lalalalala
07:12:34 <suppi> OverCoder, which tutorial is this?
07:12:37 <hexagoxel> it is the only IO value that actually gets executed, though.
07:12:40 <OverCoder> suppi, LYAH
07:12:45 <hexagoxel> not talking about unsafe stuff
07:12:48 <suppi> oh :(
07:12:59 <maerwald> that's an implementation detail and shouldn't be said
07:13:00 <scshunt> You can write functions that do IO actions, but they need to be linked back to main
07:13:06 <hexagoxel> but you can write "main :: IO (); main = foo; foo :: IO (); foo = print 42"
07:13:07 <hexagoxel> just fine
07:13:10 <scshunt> right
07:13:19 <OverCoder> o
07:13:32 <OverCoder> Hm, okay then, thanks, again
07:13:37 <scshunt> @t putStr
07:13:37 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
07:13:40 <hexagoxel> (i think OverCoder was mistake about that thing, amiright?)
07:13:42 <scshunt> @type putStr
07:13:44 <lambdabot> String -> IO ()
07:13:50 <scshunt> there's an excellent example :)
07:14:17 <suppi> OverCoder, so yeah, you can break your main into more functions. that's never a problem
07:14:33 <scshunt> What you can't do is do IO in a function that doesn't have a result type with IO in it
07:14:36 <OverCoder> suppi, hm, I just wonder, who executes code out of the main function?
07:14:47 <scshunt> OverCoder: The language environment does
07:14:53 <scshunt> no different from any other language
07:15:05 <OverCoder> hm
07:15:22 <OverCoder> Ah right, gotcha
07:15:33 <maerwald> "language environment"?
07:15:41 <scshunt> maerwald: which may just be the OS ;)
07:15:44 <maerwald> do you mean the RTS?
07:15:51 <OverCoder> So basically nobody forces you to use main, but generally eveybody uses main as the entry point, huh?
07:16:22 <scshunt> OverCoder: main is the standard entry point, but oftentimes the compiler will have a flag to pick a different one
07:16:39 <scshunt> OverCoder: The actual restriction on doing IO in IO functions only exists at the type level.
07:17:13 <scshunt> It's not a magic property of the runtime; you just can't make code compile unless that code has your IO functions called from other IO functions
07:17:29 <scshunt> does that make sense?
07:17:33 <OverCoder> hmm
07:17:39 <OverCoder> A LOT of sense
07:17:49 <OverCoder> Things has been much more emphasized to me
07:18:12 <OverCoder> Awesome, thanks
07:19:15 <hexagoxel> OverCoder: maybe some real code: https://github.com/haskell/cabal/blob/master/cabal-install/Main.hs#L180-L192
07:19:51 <maerwald> scshunt: it's the runtime system
07:19:52 <hexagoxel> the interesting stuff is only the last line. note that getArgs and mainWorker are both IO as well.
07:20:04 <maerwald> and that is compiled into the binary
07:20:09 <maerwald> not really part of the "OS"
07:20:28 <LiteLight> hi, how can I convert IO Int to Int?
07:21:05 <scshunt> LiteLight: Only through the use of the bind operator (>>=) or things that call it indirectly
07:21:06 <LiteLight> I'm currently making a randomize (like this : http://lpaste.net/150585) but I cant really use it because it gives me IO Int instead of int back
07:21:17 <LiteLight> hmm
07:21:48 <hexagoxel> OverCoder: you see how it sets up some stuff, then forwards to the "mainWorker", which, internally forwards to more IO functions (like `printGlobalHelp`).
07:22:08 <scshunt> LiteLight: Once you're in the IO monad, you can't get out. Your random number generator is an IO function, so it needs to be treated like one.
07:23:00 <scshunt> (the *reason* that getStdRandom is an IO function is because it has global state, so it isn't always going to give you the same results from the same input)
07:24:54 <geekosaur> >>= will give you an Int from an IO Int --- as long as you put it back in IO when you're done
07:25:58 <LiteLight> what does it mean by 'as long as you put it back in IO when you're done' exactly?
07:26:41 <geekosaur> if your function gets something from IO with >>=, then it must produce an IO something, not just a something
07:26:51 <LiteLight> scshunt : so (base on my code), is it better to randomize the number in my botFindMove instead of seperate it right?
07:26:58 <maerwald> :t  (>>=)
07:26:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:27:04 <maerwald> that's what it means
07:27:58 <scshunt> LiteLight: botFindMove requires access to the RNG state at some point
07:29:11 <scshunt> you could pass that in as an argument, e.g. botFindMove :: (RandomGen g) => g -> String -> String -> (String, g)
07:29:37 <scshunt> or you can do it through a monad. In your case, IO is sufficient e.g. botFindMove :: String -> String -> IO String
07:30:16 <scshunt> in more advanced code, I would use a random monad and then fill that in later. botFindMove :: (MonadRandom m) => String -> String -> m String
07:30:25 <scshunt> (MonadRandom is in the library of the same name)
07:31:28 <mazur> is the build of ghc 7.10.3 much bigger than 7.8.4?
07:32:02 <scshunt> LiteLight: Did that make any sense
07:32:22 <codedmart> I am trying to use <|> with http-api-data. What does this error mean? http://lpaste.net/150586
07:33:52 <geekosaur> looks like you are not getting Alternative's <|>
07:35:18 <codedmart> geekosaur Not sure I understand what you mean?
07:35:54 <geekosaur> the code you wrote expects the "standard" <|> which is from Alternative.
07:36:01 <geekosaur> it would not produce that error
07:36:11 <geekosaur> you are getting some other definition of <|>
07:36:52 <geekosaur> there isn't enough information in your paste for me to figure out what <|> it is getting
07:37:30 <codedmart> geekosaur Hmm... ok I have import Control.Applicative ((<|>))
07:37:37 <codedmart> Thanks I will see.
07:39:18 <knupfer> I have a seemingly easy problem, but I can't find how to add days to an UTCTime, anybody knows?
07:39:49 <LiteLight> scshunt : I'm still trying to understand your suggestion. I dont really get it
07:40:04 <LiteLight> scshunt: I'm still trying to understand your suggestion. I dont really get it
07:40:04 <scshunt> LiteLight: Ok.
07:40:15 <tsahyt> knupfer: addUTCTime?
07:40:19 <tsahyt> :t addUTCTime
07:40:21 <lambdabot> Not in scope: ‚ÄòaddUTCTime‚Äô
07:40:31 <scshunt> LiteLight: Consider the signature of botFindMove. What information does the bot have available to decide what to do?
07:40:32 <tsahyt> :t Data.Time.Clock.addUTCTime
07:40:34 <lambdabot> time-1.5.0.1:Data.Time.Clock.UTC.NominalDiffTime -> time-1.5.0.1:Data.Time.Clock.UTC.UTCTime -> time-1.5.0.1:Data.Time.Clock.UTC.UTCTime
07:40:35 <scshunt> It only has two strings
07:40:49 <codedmart> geekosaur Would it have anything to do with `parseUrlPiece :: Text -> Either Text a`
07:41:14 <scshunt> If you want it to behave randomly, it needs to also have access to a random number generator
07:41:21 <knupfer> tsahyt: addUTCTime needs a NominalDiffTime, which I don't know where to get it.
07:41:25 <saurabhnanda> is there a gentle introduction to EitherT somewhere?
07:41:45 <scshunt> In particular, a random number generator has some state attached to it so that it doesn't always give the same number
07:41:50 <maerwald> LiteLight: try to do this homework to get into MonadRandom https://www.seas.upenn.edu/~cis194/spring13/hw/12-monads.pdf
07:42:18 <saurabhnanda> I understand the motivation and advantage of the second-to-last piece of code at http://lpaste.net/150553 ,but I'm unable to understand how exactly it works
07:42:34 <LiteLight> maerwald: Thanks. definitely gonaa see it
07:42:35 <tsahyt> knupfer: It has a Num instance, so you can just write an integer literal to denote seconds
07:42:36 <saurabhnanda> I tried reading the code of either package, but it doesn't seem to have any code.
07:42:42 <scshunt> LiteLight: yeah, that link looks great
07:42:54 <saurabhnanda> Most importantly EitherT or runEitherT doesn't have any code. It's a data constructor.
07:43:13 <LiteLight> scshunt: yeah, that's what i m trying to achieve. So, I guess it s better to build the randomize inside of botFindMove?
07:43:25 <scshunt> LiteLight: But if you do that, it will be the same randomness each time
07:43:25 <knupfer> tsahyt: ahh, thank you!
07:43:42 <LiteLight> scshunt: Hmm
07:44:00 <scshunt> https://xkcd.com/221/ comes to mind ;)
07:45:05 <geekosaur> codedmart, I wouldn't have said so because Applicative/Alternative <|> doesn't use Error. but that would really be up to whatever Applicative you're working in
07:45:56 <nshepperd> saurabhnanda: have a read of the Functor / Monad instance for EitherT
07:46:11 <nshepperd> saurabhnanda: that'll tell you how it composes things
07:46:17 <codedmart> geekosaur I am trying to use this https://hackage.haskell.org/package/http-api-data-0.2.2/docs/Web-HttpApiData.html#t:FromHttpApiData
07:47:18 <codedmart> geekosaur Thanks for the help :)
07:47:50 <geekosaur> however I will note that the standard Error is Error String, and the documentation says for anything else you need to provide an instance yourself (that is, Error Text is not defined by either Control.Monad.Error or by Data.Text)
07:49:45 <nshepperd> saurabhnanda: btw (try $ return (read i :: Integer)) won't work: `try` only picks up IO errors, not pure errors like `read` produces
07:52:09 <exio4> nshepperd: well, to be honest, it'll work if you evaluate read
07:53:39 <SavinaRoja> I keep getting thrown off by capitalization conventions...
07:53:52 <SavinaRoja> they seem really out of place
07:55:21 <quchen> SavinaRoja: How so?
07:55:42 <quchen> Type/data constructors are capitalized, everything else is not
07:56:10 <SavinaRoja> capitalization is such a very arbitrary idea, why should the compiler have an opinion about it
07:56:51 <exio4> makes it easier to identify constructors in patterns
07:57:09 <nshepperd> yep, and then the next problem is figuring out what sort of exception is produced by read and setting e to that
07:57:21 <SavinaRoja> am I mistaken in my recollection that you can use full unicode in haskell source?
07:57:36 <exio4> in GHC
07:58:09 <geekosaur> how do you propose that patterns distinguish between constructors and variables?
07:58:09 <JonReed> Hi, let's say that I have a type like `type MyType = Int -> Int`. Now I can have a function like `fromMyType :: MyType -> Int -> Int`. I'm completely blanking on how to actually create MyType. `toMyType :: Int -> Int -> MyType; toMyType = ???`
07:58:28 <quchen> SavinaRoja: You're right. Well, you have to use alphanumeric characters for names, but those can be arbitrary unicode characters that satisfy this.
07:58:31 <SavinaRoja> so does ghc handle capitalization in all languages, and what does it do for those that don't?
07:58:39 <geekosaur> (remember, that's the *point* of patterns. you describe the structure of a value, which means its constructors)
07:59:06 <quchen> JonReed: fromMyType = id
07:59:07 <quchen> :-)
07:59:11 <glguy> SavinaRoja: Unicode codepoints have an upper case and a lower case attribute (possibly neither), GHC distinguishes between things that are lower case and things that are not lowercase
07:59:50 <quchen> JonReed: Remember, type defines type synonyms. Everywhere you have MyType, you can as well write (Int -> Int).
08:00:01 <quchen> So "fromMyType :: (Int -> Int) -> Int -> Int"
08:00:22 <quchen> toMyType :: (Int -> Int) -> MyType; toMyType = id
08:00:37 <quchen> There is no need for "conversion", since you're converting between identical things
08:00:47 <geekosaur> well, also remembering that -> associates rightward, so that is (Int -> Int) -> (Int -> Int)
08:01:54 <JonReed> quchen: I already wrote fromMyType = id, the only I'm struggling with is toMyType
08:02:06 <geekosaur> it's also id
08:02:11 <JonReed> strange
08:02:12 <geekosaur> there is no conversion needed.
08:02:16 <geekosaur> type is a *synonym*
08:02:17 <JonReed> It was failing for some reason
08:02:24 <quchen> JonReed: Your parentheses are wrong.
08:02:42 <JonReed> quchen: Ahh
08:02:45 <quchen> You want "toMyType :: Int -> Int -> MyType", which means ":: Int -> (Int -> MyType)".
08:02:56 <JonReed> quchen: I get it now
08:02:57 <quchen> But what you should want is ":: (Int -> Int) -> MyType".
08:03:50 <SavinaRoja> geekosaur: could there be a standard token at the start of a constructor, what the capital does essentially
08:04:12 <quchen> Sure.
08:04:41 <quchen> You could prefix all constructors with "%" instead of using capitalization, for example.
08:05:13 * geekosaur has in fact expressed a wish for that for caseless languages
08:05:26 <quchen> geekosaur: Idris? :-√æ
08:05:39 <quchen> It's case-lesser at least.
08:06:12 <geekosaur> s/languages/character sets/
08:06:49 <geekosaur> you can't write constructor names in Japanese, Chinese, Korean, Arabic, ...
08:06:53 <glguy> You can already prefix all constructors with an arbitrary capital letter
08:07:24 <glguy> or even a non-lowercase non-letter
08:08:04 <SavinaRoja> geekosaur: I keep seeing that "s/<thing>/<thing>...", what is that?
08:08:24 <SavinaRoja> emacs?
08:08:27 <geekosaur> "sed" (or vim) syntax for changing something
08:08:43 <geekosaur> specifically replacing a mistake in whatever you last typed
08:09:14 <SavinaRoja> ah, haven't explored that area of vim yet, thanks
08:09:16 <geekosaur> there are often extensions for IRC clients (but not web IRC clients generally) that will actually see that and do the replacement...
08:23:53 <zomg> geekosaur: there are? Interesting, always thought someone should write one but never occurred to actually check if anyone did that already :P
08:24:49 <codedmart> geekosaur I wrote a Error Text instance and that seems to work, but I get these warnings now: http://lpaste.net/150587
08:29:43 <scshunt> I should write an acme-random-pure library
08:37:21 <tsahyt> Can anyone help me figure out why this doesn't type check? I'm probably missing something obvious. It complains about not being able to match the p parameter in the function from the where clause with the parameter in the top level type. http://lpaste.net/8354408678660505600
08:38:44 * hackagebot extensible-effects 1.11.0.1 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-1.11.0.1 (shergill)
08:39:14 <Yuras> tsahyt: you probably need ScopedTypeVariables
08:39:24 <tsahyt> I do have them enabled though
08:41:17 <Cale> tsahyt: ScopedTypeVariables only applies to type variables which you explicitly forall somewhere
08:41:46 <Cale> tsahyt: So you need  simulatedAnnealing :: forall m p. (MonadRandom m, StateProblem p) => ...
08:41:50 <tsahyt> Cale: Thank now it compiles!
08:41:53 <tsahyt> Thanks*
08:44:20 <tsahyt> On a sidenote though, is this a somewhat valid use case for type families/associated types? I'm really just brainstorming how to make this as polymorphic as I can and this was just the first solution that I came up with
08:46:00 <csd_> how do I use show on a Char and have the quotes be omitted?
08:47:18 <ski> > show '\n'
08:47:20 <lambdabot>  "'\\n'"
08:47:21 <ski> > showLitChar '\n' ""
08:47:23 <lambdabot>  "\\n"
08:47:30 <glguy> csd_: You can use   showLitChar
08:47:55 <glguy> if you just want to turn a Char into a String, though, you can use [_]
08:48:01 <glguy> ['a']
08:48:10 <ski> > ['\n']
08:48:12 <lambdabot>  "\n"
08:48:24 <glguy> > text (showLitChar '\0' "")
08:48:26 <lambdabot>  \NUL
08:48:35 <glguy> showLitChar will escape things using Haskell's syntax
08:54:20 <csd_> how could i do it if i didnt have showLitChar
08:55:48 <geekosaur> with Show? you don't
08:56:11 <geekosaur> Show is not for prettyprinting
08:57:03 <tsahyt> Yes, depending on the use-case an actual pretty printing library may be a good choice
08:58:45 * hackagebot crackNum 1.5 - Crack various integer, floating-point data formats  https://hackage.haskell.org/package/crackNum-1.5 (LeventErkok)
08:59:47 <csd_> i see, thanks
09:00:26 <geekosaur> Show is not toString. Show is for debugging or for low-rent serialization
09:01:42 <anohigisavay> hi. how can i put an arbitrary data value in an unboxed vector?
09:01:57 <anohigisavay> enum-like data
09:03:00 <tsahyt> anohigisavay: It's a bit of a pain but you have to write your own Unbox instance to use your own types in an unboxed vector
09:03:09 <tsahyt> https://hackage.haskell.org/package/vector-th-unbox-0.2.1.3/docs/Data-Vector-Unboxed-Deriving.html has an example
09:03:30 <tsahyt> There's also a TemplateHaskell solution which can help with the boilerplate
09:03:32 <tsahyt> https://hackage.haskell.org/package/vector-th-unbox-0.2.1.3/docs/Data-Vector-Unboxed-Deriving.html
09:04:16 <anohigisavay> tsahyt: cool! thanks :)
09:08:05 <Gurkenglas> Perhaps http://lpaste.net/150561 should define a Prism' (f a) (g a) instead so the result of many can be free of redundancy
09:08:19 <Gurkenglas> (instead of defining assertNonempty)
09:10:54 <statusfailed> What does it mean to declare the fundep "class Foo a b | b -> b"? Isn't that trivially true?
09:11:01 <statusfailed> oh wait
09:11:11 <statusfailed> yeah what's going on there :|
09:11:15 <Cale> typo?
09:11:31 <monochrom> hehe
09:11:35 <statusfailed> heh
09:11:40 <monochrom> does the compiler accept it?
09:11:42 <statusfailed> yes
09:11:44 <statusfailed> and weirdly
09:11:47 <monochrom> \‚à©/
09:11:49 <statusfailed> it even gets rid of some overlapping instance warnings
09:11:54 <statusfailed> errors*
09:13:28 <statusfailed> ah, maybe it just effectively removes the fundep
09:17:55 <nshepperd> sounds like a bug if that's accepted but does something :O
09:23:45 * hackagebot engine-io 1.2.12 - A Haskell implementation of Engine.IO  https://hackage.haskell.org/package/engine-io-1.2.12 (OliverCharles)
09:24:26 <statusfailed> nshepperd: I think it just removes the functional dependency; "| t -> t" is just saying "t uniquely determines t" which is always true, even without the fundep, right?
09:24:42 <statusfailed> I dunno how you would check that though
09:27:32 <anohigisavay> is it possible to group some case conditions into one?
09:27:41 <anohigisavay> pretty much like case without break in other languages
09:28:17 <statusfailed> anohigisavay: maybe with guards ?
09:28:37 <statusfailed> anohigisavay: do you want a "catch all" case, or do you want multiple groups?
09:28:46 * hackagebot conceit 0.4.0.0 - Concurrent actions that may fail with a value.  https://hackage.haskell.org/package/conceit-0.4.0.0 (DanielDiazCarrete)
09:28:50 <Cale> anohigisavay: Not really, it's sort of tricky because the patterns can bind different sets of variables. Some languages do it and give you the intersection of the variables occurring in each pattern
09:28:59 <Gurkenglas> Is there a shorthand for (%~ id)?
09:29:21 <Cale> :t (%~ id)
09:29:22 <lambdabot> Setting (->) s t b b -> s -> t
09:29:35 <anohigisavay> yea that makes sense
09:30:07 <anohigisavay> statusfailed: multiple groups. most cases are single value, few are groups
09:31:53 <statusfailed> anohigisavay: I'm not sure if guards would really solve your problem, but you could write a predicate for which cases are in a group and use that?
09:32:48 <Cale> also, you can always put something in the where clause
09:32:54 <Cale> and use it in multiple branches
09:33:18 <Cale> (with guards)
09:33:34 <statusfailed> anohigisavay: http://lpaste.net/7079690349739769856
09:33:38 <statusfailed> but I'm not sure that saves much
09:47:39 <asjo> I am trying to make a simple website using Spock, Lucid and PostgreSQL.Simple, using https://github.com/meiersi/HaskellerZ/blob/master/meetups/20150529-ZuriHac2015_Oliver_Charles-Web_Programming/ as a guide. Unfortunately Spock has changed API since, and I can't figure out how to connect to PostgreSQL within Spock. Anyone have a link to a newer example?
09:58:36 <Gurkenglas> http://hackage.haskell.org/package/lens-4.13.1/docs/Control-Lens-Iso.html#v:mapping <- is there something like this to lift any Prism into an arbitrary Functor?
10:02:27 <Gurkenglas> Ah I see that's why not how unfortunate.
10:03:51 <Gurkenglas> I still need a prismlike for that case though, at least to lift into monads - the information about whether the prism applies is allowed to be monadic too
10:03:52 <bollu> which is a "real" total functional language?
10:04:01 <bollu> "real" in the sense of "exists with compiler / interpreter"
10:07:43 <tsahyt> bollu: Total as in the compiler refuses any non-total program?
10:07:57 <mazur> if i just upgraded from ghc 7.8.4 -> 7.10.3 should i wipe my .cabal directory?
10:11:29 <geekosaur> mazur, shouldn't matter
10:11:47 <geekosaur> don't even need to wipe .ghc because it uses a separate package db for each ghc version
10:12:22 <k0ral> mazur: you can selectively wipe the old database to save disk space, if you don't intend to use the old GHC version anymore
10:12:26 <geekosaur> (and .ghc is what really matters there, .cabal is working storage except for .cabal/config which you almost certainly want to keep)
10:13:48 <mazur> it's for the disk space; i don't intend to go back
10:14:03 <mazur> it sounds like i don't want to completely wipe .cabal though
10:15:43 <mazur> 2.6G, the biggest subdirectories are ./share (981M), ./lib (966M) ./packages (425M)
10:15:45 <k0ral> no you want to wipe the folder with the old ghc version in its name
10:16:09 <mazur> oh, so if i delete those old directories in .ghc, then cabal will clean up?
10:16:15 <k0ral> I don't have it at the moment so I can't tell you exactly which one it is
10:16:27 <geekosaur> sigh
10:17:21 <geekosaur> k0ral and mazur: it is .ghc that has the stuff that you are worried about. .cabal has stuff like downloaded package source that you will likely want if you need to reinstall those under the new ghc
10:17:42 <geekosaur> (unless you know you need a newer version or you don't mind re-dowloading it all)
10:22:23 <mazur> oh, looks like there are subdirectories in ./lib ./share for each of the ghc versions; i'll leave ./packages alone then
10:23:12 <monochrom> mazur: see my http://www.vex.net/~trebla/haskell/sicp.xhtml for which directory has what
10:24:18 <mazur> monochrom: ty :]
10:30:57 <TallerGhostWalt_> anyone know of an AT command library for haskell?
10:50:22 <k3d3> Like, the windows scheduler thing?
10:50:56 <monochrom> AT command? is that for dial-up modems? I knew some of them.
10:51:35 * geekosaur had that thought initially as well...
10:52:40 <haskell539> I'm trying to use a module (https://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen) that I installed using cabal. How can I update the source code? -> When I run `locate` on my box, I only get binary ".hi" files
10:53:57 <monochrom> use "cabal get" to download and unpack the source tree. do your work. rebuild and reinstall.
10:54:16 <monochrom> the risks of reinstalling applies
10:54:46 <breadmonster> I'm going through RTS code ><
10:55:01 <haskell539> monochrom: how do i rebuild / reinstall? (very new to cabal)
10:55:32 <monochrom> usually a simple "cabal install" while you're inside the source tree is enough
10:56:01 <monochrom> for more fine-grained steps, see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install
10:56:30 <haskell539> thanks!
10:59:17 <puregreen> is there some standard conduit that splits a bytestring into chunks of certain length?
11:06:39 <nshepperd> some hobbyist bluetooth modules use this AT command stuff. i guess it probably is from dial up modems
11:07:32 <nshepperd> I think one should probably just implement the protocol manually, since i don't think it's very standardised
11:08:08 <puregreen> and another question: why does this conduit client/server seem to output lines simultaneously and not in order? http://paste.ubuntu.com/14614745/
11:14:48 <mjhoy> hmm. is there no way to abstract build dependencies for both executable and test suite?
11:14:52 <mjhoy> (in a cabal file)
11:15:18 <crough> I don't think so...
11:15:38 <crough> But, for me, the fewer the dependencies the more complete my API is in the test suite...
11:15:56 <crough> It gives you a good idea of that, I guess!
11:16:23 <mjhoy> wouldn't all my dependencies need to be there anyway?
11:17:00 <mjhoy> or should i build a library that the executable uses
11:17:47 <hexagoxel> mjhoy: yes; library+exe+tests is the usual approach afik.
11:18:01 <hexagoxel> (although the tests still might need some deps)
11:19:02 <mjhoy> ah. ok. and i don't need to install the library, right, cabal will build it locally?
11:19:36 <hsk3> hey
11:20:02 <hexagoxel> mjhoy: yes.
11:20:24 <hsk3> Not really a haskell question but: Let's say I wanna create a space for people to talk about my product. A public forum. Is there any good reason why I should spend my time making my own forum on my own domain instead of simply creating a subreddit? I can do the latter in a matter of seconds.
11:20:29 <hsk3> Your thoughts?
11:22:16 <sleblanc> hsk3, usually, reddit as a whole shuns astro-turfed subreddits, i.e. those who belong and are run by first parties
11:26:54 <hsk3> sleblanc: ok thanks
11:29:05 * hackagebot microlens-mtl 0.1.7.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.7.0 (Artyom)
11:30:57 <codedmart> How do I pattern match list or tuple in a case?
11:31:07 <codedmart> Seem to be drawing a blank.
11:31:40 <puregreen> > case (1,2) of (1,x) -> x
11:31:43 <lambdabot>  2
11:32:23 <codedmart> puregreen of wait I am going about this wrong.
11:32:27 <codedmart> Sorry, thanks!
11:34:05 * hackagebot microlens-platform 0.2.2.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.2.2.0 (Artyom)
11:57:10 <mjhoy> so for a library+executable set up, the executable should not have the same load path as the library? (hs-source-dirs)
11:58:37 <bergmark> mjhoy: if you want to only compile the modules once, no
11:58:57 <bergmark> the downside is that you have to expose all modules you want to use in the exe
11:59:04 <mjhoy> bergmark: right, i wanted to only dependencies once too.
11:59:09 <mjhoy> *list
11:59:35 <Dr4ke63> Hello everybode
11:59:39 <Dr4ke63> Y*
12:00:05 <Dr4ke63> Every IRC is dead lol
12:00:30 <Dr4ke63> So cya 
12:00:33 <mjhoy> bergmark: plus i need to expose them all anyway for my test suite, i think
12:00:48 <Dr4ke63> Mjhoy hello
12:01:00 <mjhoy> Dr4ke63: hi
12:01:02 <Dr4ke63> Why is noone talking?
12:01:25 <mjhoy> everyone on the east coast is shoveling? dunno
12:01:41 <Dr4ke63> Lol
12:02:31 <hiptobecubic> probably not shoveling yet
12:03:50 <mjhoy> it's a beautiful day in minneapolis, and i'm jealous.
12:07:21 <zomg> some mayor or something tweeted some nonsense about how if you're going out to play in the snow with kids you should be really careful
12:07:53 <zomg> and like, don't go out for long, wait for a sunny day
12:08:19 <zomg> I don't know how I survived childhood in a country where you get tons of snow for several months a year!
12:08:22 <zomg> :p
12:14:06 * hackagebot pipes-transduce 0.3.0.1 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.3.0.1 (DanielDiazCarrete)
12:16:26 * dwigton looks up and realizes that it is a beautiful day in Minneapolis
12:20:49 <mjhoy> dwigton: it snuck up on us.
12:36:05 <marchelzo> If you're writing a package that defines some types, and most (if not all) of the modules use those types, is it common practice to define them in a module named Foo.Types (where Foo is the package name, of course)?
12:37:09 <ReinH> marchelzo: yes
12:38:47 <EvanR> it also lets the types be recursive without having to do hsboot files
12:39:44 <begriffs> Question about CI best practices. For development my project uses Stack, but I set up continuous integration on Circle prior to Stack's existence. Tests have been running fine there until a new branch I'm working on. I get a cabal error about dependency conflicts. Should switch CI to Stack as well, or keep it vanilla cabal to ensure the package works for non-Stack users?
12:40:49 <begriffs> Wondering if the plain cabal problems should be considered a thing of the past or if it's a good idea to ensure things work for the old way.
12:41:21 <ReinH> begriffs: you should do CI in the same way that you expect your software to be deployed
12:41:38 <ReinH> begriffs: if you expect users to install using cabal, you should do that
12:41:58 <ReinH> if you expect to deploy your software by building with stack, you should do that
12:42:14 <ReinH> s/way/ways
12:43:07 <begriffs> The primary use case is a binary that someone would either download pre-built or build themselves (the docs illustrate how to do it with Stack). But the binary contains modules which could conceivably be used in other packages. And I thought not everyone uses Stack and would have a hard time including my library.
12:43:25 <ReinH> It's up to you and your use case(s).
12:43:42 <ReinH> If you don't test cabal builds, you won't have any guarantee that cabal builds work.
12:43:50 <ReinH> If you don't care about cabal builds, this won't matter. If you do, it does.
12:43:59 <begriffs> I guess my reasoning has been that if caba
12:44:08 <begriffs> if cabal builds work then stack builds will work too
12:44:29 <ReinH> Not necessarily.
12:44:52 <ReinH> cabal can build with dependencies that are not on stackage.
12:46:11 <begriffs> For completeness then I should probably build the app and run the test suite with Stack on CI. But include another "test" which is that cabal build succeeds.
12:47:05 <ReinH> Yeah, you should test each scenario.
12:48:30 <begriffs> In fact I should probably run other things like `cabal check` and `stack haddock` to ensure everything checks and docs build. Is there a reference online somewhere of the "Ultimate Circle CI Haskell Config?"
12:48:49 <ReinH> probably not :D
12:49:07 * hackagebot EdisonCore 1.3.1 - A library of efficent, purely-functional data structures (Core Implementations)  https://hackage.haskell.org/package/EdisonCore-1.3.1 (RobertDockins)
12:49:27 <begriffs> Hmm maybe I'll do some research and make a gist or blog with what I can find.
12:49:43 <begriffs> Thanks for talking it through with me!
13:14:28 <John[Lisbeth]> every time I run "cabal install cabal" I crash
13:15:03 <Bor0> @pl \y -> x : y
13:15:03 <lambdabot> (x :)
13:24:51 <`Guest00000> are c++ templates as powerful as dependent types?
13:25:13 <fr33domlover> @pl \ x -> (x, y)
13:25:13 <lambdabot> flip (,) y
13:25:54 <Cale> `Guest00000: Well, they're Turing complete, so in some sense, they're "more powerful", but as soon as you consider usability or suitability for any particular task, things look much different.
13:25:57 <ggVGc> what does @pl do?
13:26:11 <fr33domlover> ggVGc, makes code point-free iirc
13:26:18 <Cale> ggVGc: Tries to find a points-free form of a lambda term
13:26:21 <Bor0> it stands for pointless. -> can be thought as the point in lambda calculus
13:26:25 <`Guest00000> it seems that i mean other notion of 'power' but can't clearly express
13:26:35 <ggVGc> Cale: are you saying we should implement haskell in C++ templates? Because that's how I read it!
13:26:43 <ggVGc> ah, yeah, thanks (regarding @pl)
13:26:55 <Cale> The term "points-free" comes from topology
13:26:55 <hexagoxel> @hackage pointfree
13:26:55 <lambdabot> http://hackage.haskell.org/package/pointfree
13:27:13 <Cale> where it made more sense, because you were talking about functions between spaces made up of individual points
13:27:41 <Cale> and a points-free description of a function was one which was specified without saying what it did on individual points
13:28:02 <ggVGc> yeah, I know what pointfree means
13:28:07 <Cale> (e.g. by describing it as a composite of other existing functions, or through some universal property that it had)
13:28:08 <ggVGc> I jsut didn't know what the @pl command did for the bot
13:28:29 <markus3> question related to declareFields with lens: having multiple data types in the same TH declaration block causes to declare a class (e.g HasId) multiple times
13:29:02 <markus3> seems like something that could be easily avoided?
13:30:00 <Cale> `Guest00000: I would usually much rather have plain parametric polymorphism like in Haskell than C++ template polymorphism, and I would *very* much rather have dependent types in practically all the other cases.
13:30:10 <Bor0> I noticed that Haskell is much readable than Scheme is, by doing one of the exercises from SICP. what are other (dis)advantages to Lisp? besides obviously the type system
13:31:21 <Cale> Bor0: I mean, those are the main things. Of course, the answers vary depending on which lisp you're talking about
13:32:57 <Bor0> Cale, I see. I should've stated "to Scheme" instead, since Scheme is the only Lisp I know and care about at the moment :) but thanks
13:33:04 <ski> Bor0 : i suppose meta-/staged programming, and macros (but also see MetaML/MetaOCaml)
13:33:07 <Cale> Lazy evaluation by default is pretty nice for composability of programs.
13:33:35 <Cale> Yeah, Scheme has a somewhat nicer metaprogramming story than Haskell
13:33:47 <Cale> and its simple-ish syntax helps it there
13:34:08 <Cale> (scheme's syntax is more complicated than it looks, but still perhaps simpler than Haskell's)
13:34:19 <Bor0> sounds good. I know Scheme has lazy evaluation too but I still haven't reached there yet. I can see SICP going towards it tho
13:34:56 <Cale> Yeah, but the thing about lazy evaluation is that when you're combining programs, it's like a recessive trait -- if one of the programs is too strict, the result will be too strict.
13:35:09 <rvxi> what's a good entrypoint to write a client to consume rest services. servant, wreq? can spock be used to write clients?
13:35:24 <Cale> So not having it be the default results in libraries filled with things which are too strict, and which can't necessarily be composed in the way you want.
13:35:45 <Bor0> I see what you're saying, yeah
13:36:02 <dolio> It's not just that combining things can go wrong.
13:36:48 <dolio> When you have to intentionally make things lazy, people tend to not do it. So if you use anything written by anyone else, it's common for it not to work the way you want it to.
13:37:12 <Cale> right, that's basically what I'm trying to say :)
13:37:18 <Bor0> haha, yeah that's how I understood it
13:37:38 <conal> dolio: nice point.
13:38:27 <Bor0> how do they compare with DSLs?
13:38:50 <Bor0> I'm still at the early start of SICP, but have no experience with that in Haskell either
13:39:05 <Bor0> well probably not too early start. mid 2nd chapter
13:39:47 <Bor0> (and of course saying it like this I assume you guys must've gone through it already. my next question was gonna be what do you think of it in general)
13:40:12 <dolio> Scheme's macros let you create better syntax for embedded DSLs, but Haskell's nicer inherent syntax means that it's less necessary to create nicer syntax.
13:40:32 <Cale> Bor0: There are some abstractions we like to use to help capture the similarities between embedded domain specific languages (type classes like Functor, Applicative, Monad, Arrow, etc.) which are difficult to abstract over in Scheme
13:40:42 <Cale> At least, in a way which isn't painful to use
13:41:01 <Cale> You need type classes to make those things work well.
13:41:32 <markus3> rvxi: from what you've mentioned wreq can do it, others are for writing server sides (afaik)
13:41:39 <Bor0> ok, I can see how the type system plays its role there
13:42:18 <Cale> The type system in Haskell starts paying you back and making it possible to save code at the value level via type classes.
13:42:35 <Cale> So it's not just about safety, but also convenience at a point.
13:43:17 <Cale> But you'll see a lot of patterns in SICP which have since that time been incorporated as language features in Haskell
13:43:41 <Cale> For example, pattern matching and indeed stuff like lazy streams
13:44:01 <Bor0> yeah, those more interesting stuff looks to be after chapter 2 :)
13:44:09 * hackagebot hsdev 0.1.5.3 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.5.3 (AlexandrRuchkin)
13:44:25 <Bor0> chapter 1 and 2 are basically about recursion, how data is code and vice-versa and how to generalize and capture patterns with higher order functions, etc
13:46:17 <Bor0> but I didn't want to skim through because I like the difficulty of the exercises. they're not only about programming, but also involve for example interval arithmetic, calculating errors, and yeah I liked the way they explained fixed points with the examples
13:46:17 <`Guest00000> Cale: what cases?
13:46:25 <`Guest00000> i didn't understand
13:46:53 <Cale> `Guest00000: Cases where I want the type of my program to depend on a value.
13:47:28 <dfeuer> @type \c n i g -> foldr (c . g) n $ [0..(i-(1::Int))]
13:47:29 <lambdabot> (b1 -> b -> b) -> b -> Int -> (Int -> b1) -> b
13:48:46 <Cale> `Guest00000: Usually templates get used to abstract programs over the choice of a type, and Haskell's type system is just way nicer and cleaner there in a lot of ways. You get nice type inference both for individual expressions and at the level of declarations. It's easy to combine things which are polymorphic to get new polymorphic things. You can easily abstract over type constructors...
13:51:22 <Cale> `Guest00000: For cases where you want to have types depending on values (which is usually regarded as template metaprogramming in C++, and is a bit less common), dependently typed systems are just a whole lot more pleasant again. You may not get nice type inference at the declaration level, but you *do* get quite a bit at the expression level. You can easily do computation at the type level *in the same language you're
13:51:22 <Cale>  using at the value level*...
13:52:29 <Cale> Nevermind the fact that the concrete syntax of templates is just a pain with all the angle brackets which you have to be careful don't touch each other...
13:53:25 <`Guest00000> Cale: in a recent c++ version  '>>' was allowed in place of "> >"
13:53:32 <Shockk> Cale: that was fixed in 11 but it is still kind of ugly to look at template syntax yes
13:53:36 <Cale> ah, well, at least they fixed that...
13:53:37 <Cale> yeah
13:54:01 <Cale> But yeah, that's mostly just a cosmetic detail.
13:54:35 <dfeuer> Remind me:   foldl f b xs = foldr (flip f) b (reverse xs), right?
13:54:44 <vkad> hey guys, how do you keep ghci extensions in sync with the project, seems wrong/treacherous to perpetually edit .ghci as you switch from one project to another
13:55:28 <meditans> vkad: I think actually the .ghci file can be project specific
13:55:36 <Cale> The more important thing is that proper dependently typed languages let you do computations at the type level using ordinary expressions *even with variables in them*
13:56:23 <Cale> Like the usual hello-world-ish example:  append :: Vector n a -> Vector m a -> Vector (n+m) a
13:56:26 <vkad> meditans how so does stack ghci find .ghci file at the top level of the project directory?
13:57:01 <meditans> vkad: let's try that, I was looking in the ghc user guide
13:57:02 <dolio> And your runtime values can show up in the types.
13:57:10 <Cale> dolio: indeed
13:57:11 <dolio> So you can actually prove things about them.
13:57:19 <meditans> vkad: try setting overloaded strings, and see if works
13:57:24 <vkad> trying now
13:57:30 <dolio> Instead of proving things that you hope correlate with runtime properties.
13:57:44 <Shockk> I do like some of the new features coming to C++ recently in C++14 and C++17 to do with templates, but the biggest thing that always gets me is how difficult it is to do something as simple as the equivalent of `data Number = Whole Integer | Fract Rational` (just for example)
13:57:48 <vkad> meditans not working for me. have the added complication of launching stack ghci from within spacemacs
13:57:54 <dfeuer> > foldl (flip (:)) [] . map (*2) $ [0..5]
13:57:55 <Shockk> or the optional type too
13:57:56 <lambdabot>  [10,8,6,4,2,0]
13:58:23 <dfeuer> > foldr ((:) . (*2)) []  [0..5]
13:58:25 <lambdabot>  [0,2,4,6,8,10]
13:58:32 <meditans> vkad: wait, doing a quick search
13:58:34 <Shockk> I'm probably off-topic but it was semi related to haskell because that's one of the things I love about haskell
13:58:34 <dfeuer> > foldr ((:) . (*2)) []  [5..0]
13:58:36 <lambdabot>  []
13:58:43 <dfeuer> > foldr ((:) . (*2)) []  [5,4..0]
13:58:45 <lambdabot>  [10,8,6,4,2,0]
13:59:11 <meditans> vkad: here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-dot-files.html
13:59:15 <Cale> Yeah, my knowledge of C++ is mostly from ~2000 or so, it's been a long time since I really had to use it in a significant way.
13:59:26 <meditans> vkad: search for 'Placing a .ghci file in a directory'
14:00:32 <Bor0> that example can be "simulated" with OOP classes, but I guess your question was about C++ templates
14:00:38 <Cale> dfeuer: yeah, your equation there is correct
14:01:18 <dfeuer> Cale, I'm writing some more fusion rules for Data.Sequence. The fromFunction function in particular can fuse with *lots* of things.
14:02:16 <Shockk> Bor0: if that was in response to me: it can, it's just that it's pretty ugly to do, in comparison to how uncluttered it is in Haskell
14:02:20 <vkad> meditans seems to work in the shell. i wonder what directory spacemacs launches stack ghci from
14:02:28 <Bor0> Shockk, yeah, I agree on that part
14:02:31 <meditans> vkad: so it may well be the stack ghci thing, I don't think it's spacemacs
14:02:33 <Shockk> it's actually one of the features I'm hoping comes to the strongly typed enums in the future
14:02:55 <Cale> dfeuer: heh, I wish I still had our code from one of the ICFP contests long ago which used Sequence extensively, and didn't perform all that well -- maybe all your efforts would actually have made quite a difference!
14:03:08 <dfeuer> Cale, I think this is right:   foldl f b (fromFunction i g) = foldr (flip f . g) b [(i-1),(i-2)..0]
14:03:32 <meditans> vkad: I don't know about that, you should try asking in the #haskell-stack channel, or in the issue tracker
14:04:31 <vkad> meditans ah it works
14:04:43 <dfeuer> Cale, eh.... Data.Sequence has inherent constant-factor issues. If you used a lot of zipWith or mapWithIndex or (especially) the Applicative Seq instance, that would have.
14:04:47 <vkad> now to change my global .ghci ... hopefully i don't super confuse myself
14:04:47 <meditans> vkad: did you change anything in order for it to work?
14:05:39 <Cale> dfeuer: iirc, it was mostly lots of chopping and splicing things back together, rearranging chunks.
14:05:53 <vkad> meditans no, i put it in the top level of the project. it's slightly confusing because print statements as it's launching show up in a shell but not in spacemacs.
14:06:09 <vkad> but i was able to confirm it loaded with a :def fooby \x -> return $ ":!echo foo"
14:06:41 <dfeuer> Cale, yeah, I didn't touch any of that stuff. That's super-hairy code (much of it computer-generated) and it's probably about as efficient as possible already, given the types.
14:07:43 <dfeuer> Well, not hairy so much as ... large and very boring.
14:12:24 <vkad> meditans one problem which remains though is that extensions are per source file, but .ghci is presumably per project
14:12:51 <vkad> so there's still some edit-juggling to  keep ghci synced with a particular file...
14:12:55 <vkad> that one is working on
14:16:47 <OverCoder> Um, I don't seem to understand the difference between ByteString and ByteString.Lazy
14:16:55 <OverCoder> I've read them in my tutorial twice, but I couldn't
14:16:58 <ggVGc> OverCoder: one is lazy
14:17:05 <ggVGc> it's as simple as that
14:17:26 <OverCoder> hm, okay and so I'll be using the Lazy one all the time?
14:17:32 <OverCoder> What's the point of the other?
14:17:33 <ggVGc> depends on your use case
14:17:41 <ggVGc> usually the Lazy one is the commonlu used
14:17:46 <ggVGc> but sometimes you want an eager bytestring
14:17:56 <OverCoder> hmm
14:18:00 <ggVGc> OverCoder: well, sometimes you want to have a bunch of bytes that are actually all there right now
14:18:06 <ggVGc> but mostly you don't
14:18:20 <OverCoder> ooh, so /mainly/ that's the difference?
14:18:43 <ggVGc> OverCoder: if you want to store a whole file in memory, you'd probably not use the lazy version, but if you're streaming a file from disk(which would be more common), you'll probably have a function that returns a lazy bytestring and only reads te bytes you access
14:18:53 <meditans> vkad: I usually enable in the .ghci the union of all extensions I use in the files.. are you developing something particular extension-heavy?
14:19:16 <OverCoder> Ow, ah right... now I gotcha
14:19:20 <OverCoder> Bunch of thanks
14:19:56 <OverCoder> So one acts just like if I were to read bytes in imperative languages, loads everything to the memory, and the other, is just lazy, i.e. as we just expect it to
14:20:13 <vkad> meditans no but i did get bitten by confusion a while back when i had overloadedstrings in my source and it wasn't on in ghci. the wierd thing is that i think haskell mode does some magic
14:20:36 <vkad> to load extensions in the source, but it didn't seem to work this one time
14:20:48 <vkad> i'm also playing with servant now which is a bit extension heavy
14:21:05 <FernandoBasso> "Beginner questions are still welcome on IRC, as always." <-- Won't you say rtfm?
14:21:31 <Cale> FernandoBasso: hm?
14:21:49 <Cale> FernandoBasso: We try not to... or at least, we'll link you to the right part of the manual :)
14:21:49 <FernandoBasso> Cale: "This FAQ is based on actual frequently-asked questions from #haskell IRC. The goal is simply to collect and edit some common answers. Beginner questions are still welcome on IRC, as always."
14:21:56 <jmcarthur> If somebody says rtfm, they will usually at least provide a link to tfm or some help finding the right place.
14:21:59 <FernandoBasso> Ah, okay :)
14:22:34 <FernandoBasso> Cale: That is great. Some irc channels are useless. Everything is off-topic, and if by any means, something is on-topic, it is on the docs anyway.
14:23:21 <vkad> haskell has some of the most useful irc channels. i just wish it wasn't as fragmented
14:23:36 <vkad> there are the same 30 people in like 20 different channels
14:23:54 <jmcarthur> Some of the channels make sense to have.
14:24:10 <FernandoBasso> My experience is primarily with php/sql/html/css/js. Every time I have a problem, is a mix of more than one technology. And in any of those channels, my question is off-topic.
14:24:40 <arw> vkad: haskell is also very high traffic, so some split is necessary
14:25:39 <Gurkenglas> Which channels are these? I know haskell, haskell-blah, -game, -stack, -beginner, -refactorer, -lens, -web, -ide, -in-depth
14:26:00 <vkad> gurkenglas there's also http://ircbrowse.net/
14:26:10 <jmcarthur> I like that there is at least #haskell-blah and specialty channels like #haskell-game. The former for obvious reasons: 1549 people don't want to listen to you talking about that politician you aren't a fan of. The latter kind of channel is good as a motivator for people deeper into that topic. #haskell is not the place to talk about the intricacies of OpenGL or even the finer details of getting some
14:26:12 <jmcarthur> game-related FFI thing to work, for example, but it's still on topic in #haskell-game.
14:26:32 <jmcarthur> I dislike channels like #haskell-in-depth and #haskell-beginners
14:26:38 <jmcarthur> *#haskell-beginner
14:26:49 <vkad> jmcarthur unfortunately game dev in haskell is dead-ish now so haskell-game is depressingly idle :(
14:26:51 <jmcarthur> I think they only fragment, with no obvious gain.
14:27:06 <jmcarthur> vkad: It has the occasional burst of activity for a few weeks at a time.
14:27:14 <jmcarthur> vkad: Mostly idle, yes.
14:27:31 <Gurkenglas> Is there a way to view ircbrowse without all the join/part messages?
14:27:34 <vkad> gurkenglas there's also #servant #yesod ... uh
14:27:57 <jmcarthur> Ah, and project-specific channels also make good sense to me. I don't see that as fragmentation, just specialization.
14:28:07 <vkad> #numerical-haskell which carter refuses to make a haskell-
14:28:16 <carter_cloud> er?
14:28:26 <carter_cloud> well, it sounds better :)
14:28:30 <mgsloan> Gurkenglas: Not as far as I know, I agree that'd be nice.  Maybe open a PR on https://github.com/chrisdone/ircbrowse ?
14:28:32 <vkad> carter_cloud talkin about haskell irc channel fragmentation :)
14:28:40 <carter_cloud> lol
14:28:59 <carter_cloud> its more like "the carter channel of coollness"
14:29:02 <carter_cloud> ish
14:29:37 <sphinxo> Hi, i'm implementing functor for my parser
14:29:38 <Cale> I'm frequently frustrated at how many subchannels there are now
14:29:51 <sphinxo> and I'm wondering how to destructure a monad? is that the right term?
14:29:54 <carter_cloud> my fix is to just use ircloud and be on all of them
14:29:59 <carter_cloud> ;)))
14:30:26 <Cale> sphinxo: Uh, probably not the right term, I don't know what you mean
14:30:31 <ReinH> carter_cloud: o/
14:30:46 <vkad> carter_cloud haven't tried ircloud talking about https://www.irccloud.com/ ?
14:30:52 <carter_cloud> yes
14:31:00 <Cale> sphinxo: You should never expect to take apart a value whose type is built by some monad which you don't know what it is.
14:31:00 <carter_cloud> though i also have a znc bouncer
14:31:15 <sphinxo> I want to apply a function to a in newtype Parser a = Parser (String -> [(a,String)])
14:31:21 <Cale> sphinxo: If you know which type constructor it is, then the fact that it's a monad also won't help you
14:31:42 <sphinxo> yeah you're right
14:31:45 <Cale> (well, maybe it would help you here, you could implement fmap as liftM)
14:31:53 <Cale> however, that's cheating :)
14:32:05 <Cale> Let's look at what you're really trying to write
14:32:13 <Cale> fmap :: (a -> b) -> Parser a -> Parser b
14:32:39 <Cale> fmap f p = ...
14:33:16 <Cale> We have two options: we can turn p :: Parser a there into a pattern match, matching a function of type String -> [(a,String)]
14:33:47 <Cale> or you probably have a function lying about something like runParser :: Parser a -> String -> [(a, String)]
14:33:56 <Cale> and we could use that function
14:34:11 <Cale> But regardless, we know that we want to produce something of type Parser b
14:34:44 <Cale> and if we don't have lots of ways to build parsers yet, the simplest way to get started is to just use the data constructor  Parser :: (String -> [(b,String)]) -> Parser b
14:34:52 <Cale> fmap f p = Parser ...
14:35:11 <sphinxo> (\inp -> case parse p inp of (v, rest) => ((f v), rest) ?
14:35:12 <Cale> and now the "..." we have to fill in has type String -> [(b,String)], so it might as well be a lambda
14:35:16 <sphinxo> something ish
14:35:29 <Cale> fmap f p = Parser (\inp -> ...)
14:35:43 <Cale> Now, we have  f :: a -> b
14:35:47 <Cale> and p :: Parser a
14:35:51 <Cale> and inp :: String
14:36:00 <sphinxo>  yes
14:36:05 <Cale> We can get  runParser p inp :: [(a,String)]
14:36:09 <frerich> sphinxo: In the words of Dr. Seuss (I only learned who Dr. Seuss is after my first son was born...): A parser of things/is a function of strings/to lists of pairs/of things and strings.
14:36:41 <Cale> and then we just need to apply the function f to each of the first components in the resulting list
14:36:51 <Cale> An easy way to do that would be to use a list comprehension
14:36:55 <Cale> Or of course, we could use map
14:37:26 <Cale> fmap f p = Parser (\inp -> [(f v, inp') | (v,inp') <- runParser p inp])
14:37:46 <sphinxo> ahh yes
14:37:52 <sphinxo> Wonderful thank you
14:37:53 <Cale> fmap f p = Parser (\inp -> map (\(v,inp') -> (f v, inp')) (runParser p inp))
14:38:58 <sphinxo> Excellent explanation :)
14:39:19 * hackagebot mappy 0.1.0.0 - A functional programming language focused around maps.  https://hackage.haskell.org/package/mappy-0.1.0.0 (mjgpy3)
14:40:43 <Gurkenglas> I'm reading https://github.com/chrisdone/ircbrowse/blob/18f359fd30ffba7101741c78c4bcd7c8eb3b1cac/src/Ircbrowse/Controllers.hs to figure out what to change to hide the join/part messages. Is there a way to browse such code such that I can click on a word and see where it is defined (or even used?)
14:41:14 <ReinH> Gurkenglas: an editor that supports ctags can do that
14:41:21 <ReinH> Maybe not on click, but there will be some affordance.
14:42:33 <`Guest00000> what is compile-time performace of dependently typed langs?
14:43:30 <ReinH> It depends.
14:44:45 <`Guest00000> on what?
14:44:52 <ReinH> Which language and what you're doing with it.
14:46:27 <ReinH> FWIW, Edwin Brady's thesis talks about the practical performance implications of dependent types https://eb.host.cs.st-andrews.ac.uk/writings/thesis.pdf
14:47:36 <pavonia> I have a GUI with a text input field which I would like to add syntax highlighting for the typed text to. For parsing the input I'm using Parsec. The problem is, that doesn't allow me to highlight partial inputs because the parser fails for these inputs and I don't get an AST which could be used for the highlighting. Any ideas on a general approach to such "highlight-as-you-type" widgets?
14:49:24 <`Guest00000> mappy language...
14:49:39 <`Guest00000> doesn't google, github page link on hackage dead
14:49:53 <ReinH> @hackage highlighting-kate
14:49:53 <lambdabot> http://hackage.haskell.org/package/highlighting-kate
14:49:57 <ReinH> @hackage illuminate
14:49:58 <lambdabot> http://hackage.haskell.org/package/illuminate
14:49:59 <ReinH> pavonia: ^
14:50:20 <`Guest00000> @hackage agfsghfgdf
14:50:21 <lambdabot> http://hackage.haskell.org/package/agfsghfgdf
14:50:44 <`Guest00000> @hackage abc#abc
14:50:45 <lambdabot> http://hackage.haskell.org/package/abc#abc
14:50:51 <Bor0> @hackaeg SoRandomItShouldn'tBeUsedAsAPackageName
14:50:52 <lambdabot> http://hackage.haskell.org/package/SoRandomItShouldn'tBeUsedAsAPackageName
14:50:52 <ReinH> `Guest00000: please don't
14:51:00 <ReinH> If you want to test lambdabot, use a privmsg
14:51:09 <Bor0> oh, I even mispelled hackaeg and it caught that. but it doesn't seem to be validating package names
14:51:14 <`Guest00000> ok, will learn..
14:51:23 <Bor0> and I misspelled "misspelled", too
14:51:29 <ReinH> It's stupid about package names.
14:51:41 <ReinH> But lambdabot does try to correct commands for you
14:51:48 <ReinH> which is sometimes a misfeature
14:52:03 <pavonia> ReinH: Are these packages only limited to a fixed set of languages? Because I'm using a custom language
14:52:13 <ReinH> pavonia: Yes, but you asked for a general approach
14:52:23 <ReinH> Which is embodied in their implementations.
14:52:54 <pavonia> Aha okay, I'll look into the code then
14:55:00 <ReinH> pavonia: the general way to highlight a known language is to parse it into tokens, not an AST
14:55:36 <pikajude> is it just me or is hackage suuuuper slow recently
14:55:44 <ReinH> you don't care about the tree structure, you just care about identifying the syntax highlighting class of each token
14:56:50 <ReinH> So you're just writing a lexer, really
14:57:32 <pavonia> ReinH: Unfortunately, this isn't enough, because I want to distinguish e.g. file names and other strings which are lexically identical
14:59:14 <ReinH> how would you do that?
14:59:20 * hackagebot eventloop 0.7.0.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  https://hackage.haskell.org/package/eventloop-0.7.0.0 (sebaslafleur)
14:59:22 * hackagebot twentefp-eventloop-trees 0.1.2.2 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree  https://hackage.haskell.org/package/twentefp-eventloop-trees-0.1.2.2 (sebaslafleur)
15:00:03 <t0by> Hi, I'm sorry... what's so funny about "data Funny f a = Funny a (f a)" from  http://www.seas.upenn.edu/~cis194/spring13/lectures/09-functors.html? I can't see the funny part
15:00:45 <Cale> t0by: It's not exactly hilarious
15:00:59 <Cale> t0by: it might even be useful sometimes
15:01:17 <t0by> Cale, please go on :)
15:01:31 <Cale> I don't know what else to say about it
15:01:35 <sphinxo> a <*> b = Parser (\cs -> [(f a, s') | (f, s) <- a cs, (a, s') <- b s])
15:01:41 <Cale> The definition should be self-explanatory...
15:01:49 <t0by> it's actually not
15:01:53 <pavonia> ReinH: I don't know, that's why I'm asking :)
15:01:56 <t0by> (newbie here, please bear with me)
15:02:15 <ReinH> pavonia: I m ean, how would you statically distinguish a file name from other strings?
15:02:18 <sphinxo> is this correct when implementing applicative?
15:02:19 <Cale> t0by: Ah, I guess it might be the first example of a type constructor which is itself parameterised on the choice of another type constructor
15:02:33 <EvanR> ReinH: context?
15:02:49 <ReinH> EvanR: ?
15:03:13 <ReinH> EvanR: pavonia wants to write a syntax highlighter that highlights file names differently from other strings.
15:03:13 <Cale> t0by: So for example, you can write  Funny 5 (Just 8) :: Funny Maybe Integer
15:03:13 <EvanR> if its parsing text, filenames could be inside (), others inside []
15:03:15 <pavonia> ReinH: By the position/context they appear in the input
15:03:20 <EvanR> ah
15:03:27 <ReinH> pavonia: can you be more specific?
15:03:31 <t0by> Cale, I'm scratching my head, looking at the above sentence, which parses just fine, but I can't get an "a-ha"
15:03:34 <Cale> t0by: Or  Funny "hello" getLine :: Funny IO String
15:03:38 <t0by> that can't be good
15:03:38 <t0by> oh
15:03:40 <EvanR> computer vision ;)
15:03:41 <ReinH> I don't see why a lexer can't do that
15:03:44 <t0by> now I'm a-haing
15:04:16 <t0by> Wait, no
15:04:59 <Cale> It might help clear things up if we made it  data Funny f a = Fun a (f a)  or something so that the data constructor and type constructor aren't named the same thing
15:05:06 <Cale> So then we have
15:05:10 <ReinH> t0by: in data Funny f a = MkFunny a (f a), f is a type constructor of kind * -> *, e.g., Maybe, []. a is some concrete type of kind *, e.g., Int, Char.
15:05:15 <Cale> Fun :: a -> f a -> Funny f a
15:05:42 <ReinH> t0by: so you can have values like: MyFunny 1 [1,2,3]. Can you tell me what f is for that value?
15:05:47 <ReinH> *MkFunny
15:05:50 <pavonia> ReinH: e.g. ``load "foo.xml" as "bar"¬¥¬¥ <-- the first one is a file name, the second one a normal string. If I'm only lexing tokens, how could I distinguish both?
15:05:54 <Cale> @let data Funny f a = MkFunny a (f a)
15:05:56 <lambdabot>  Defined.
15:06:19 <Cale> > MkFunny 1 [1,2,3]
15:06:20 <lambdabot>      No instance for (Show (Funny [] a0))
15:06:21 <lambdabot>        arising from a use of ‚Äòshow_M7119852941891680887950‚Äô
15:06:21 <lambdabot>      In the expression:
15:06:23 <Cale> oh, of course
15:06:31 <ReinH> pavonia: because parsers can be context sensitive.
15:06:44 <Cale> @let deriving instance (Show a, Show (f a)) => Show (Funny f a)
15:06:46 <lambdabot>  Defined.
15:06:49 <Cale> > MkFunny 1 [1,2,3]
15:06:51 <lambdabot>  MkFunny 1 [1,2,3]
15:07:05 <Cale> > MkFunny 1 (Just 6)
15:07:07 <lambdabot>  MkFunny 1 (Just 6)
15:07:49 <Cale> :t MkFunny 1 (Just 6)
15:07:50 <lambdabot> Num a => Funny Maybe a
15:08:02 <t0by> ReinH, I was about to say \x -> x:x+1:x+2:[]
15:08:05 <ReinH> e.g., do token "load"; fn <- string; token "as"; n <- string; return (FileName fn, String n)
15:08:25 <pavonia> ReinH: By parsing you here mean regular languages?
15:08:39 <Bor0> :t MkFunny 1 (Just (6 :: Int)) -- this might read easier
15:08:41 <lambdabot> Funny Maybe Int
15:08:42 <ReinH> pavonia: Er. I mean parsing?
15:09:19 <pavonia> I'm confused. To me, parsing and lexing are completely different things
15:10:21 <ReinH> I think you're using a more specialized definition of parsing.
15:10:24 <ReinH> A lexer is a kind of parser.
15:12:35 <ReinH> I understand that you mean a parser to be something that produces a syntax tree.
15:12:43 <ReinH> Haskellers use a more general definition.
15:13:14 <ReinH> i.e., "A parser for things is a function from strings to lists of pairs of things and strings"
15:13:28 <ReinH> This is rather annoying, I admit.
15:14:20 * hackagebot simple-log 0.3.3 - Simple log for Haskell  https://hackage.haskell.org/package/simple-log-0.3.3 (AlexandrRuchkin)
15:15:13 <pavonia> Okay, but still I don't see how that would help to solve my problem
15:16:02 <pavonia> Like in your last code example, the parsing would fail if the "as" part still is missing
15:16:17 <nshepperd> I think you can even consider a lexer to be a parser producing a syntax tree. It's just a shallow tree with many children of the root (ie. a list).
15:16:27 <ReinH> nshepperd: A degenerate tree :)
15:16:46 <ReinH> pavonia: Well, the usual solution in this case is to incorporate a state machine into your parser
15:17:22 <ReinH> so that reading a "load" token causes the state machine to transition to a state where it tries to accept a string
15:20:16 <pavonia> Hhm
15:22:23 <ReinH> the alternative is to do a lot of backtracking
15:24:38 <pavonia> Most of the commands can actually be described as a regular language, so such a lexer would cover most of the input. Maybe I should care about the context-free parts later (if at all)
15:25:23 <yetanothernewbie> Hi. How do I check if a list of integers contains only unique values?
15:25:31 <pavonia> ReinH: Okay, thanks for the input so far
15:26:11 <ReinH> yetanothernewbie: the usual plan is xs == nub xs, which checks that removing duplicate values doesn't change the list
15:26:51 <ReinH> If you're using ints, it's better to use the nub from Data.List.Ordered, which is linear instead of quadratic
15:28:31 <yetanothernewbie> thanks!
15:29:06 <ReinH> an alternative is  any (\xs -> length xs > 1) . group . sort, which groups equal values together and checks if any of the groups have more than one member
15:30:44 <yetanothernewbie> ReinH: you're really good at explaining how code works
15:31:05 <yetanothernewbie> I'd read a book written by you, just saying :)
15:31:45 <ReinH> :)
15:32:00 <ReinH> These have different performance characteristics, so which one you choose will depend on what sort of inputs you give it
15:32:25 <MitchellSalad> \xs -> length xs == length (Set.fromList xs)
15:32:32 <yetanothernewbie> I've only got 4 digits
15:32:34 <yetanothernewbie> a PIN number
15:33:28 <ReinH> xs == nub xs should be faster for length 4.
15:33:56 <ReinH> at one point there was a whole thread about it on haskell-cafe https://mail.haskell.org/pipermail/haskell-cafe/2010-February/073658.html
15:35:31 <gseg> Sorry for barging in, but ReinH, have you checked that new haskell book? I am interested in your opinion.
15:35:39 <ReinH> The other plan is to insert elements into a Set as you go and check each new element for membership.
15:35:47 <ReinH> gseg: bitemyapp's? It's really good.
15:35:57 <ackthet> gseg: i can confirm its amazing and worth the price
15:35:59 <gseg> Yes, that one.
15:36:08 <gseg> Actually, I bought it few hours ago.
15:36:10 <ackthet> hes put a ton of work and content into it
15:36:14 <ackthet> oh nice :)
15:36:25 <ackthet> gseg: #haskell-beginners is the place to be to discuss it
15:36:32 <gseg> I am there. :)
15:36:34 <ackthet> more SNR
15:44:22 <Gurkenglas> Can I look at what an expression looks like after ghc is done inlining?
15:47:10 <mgsloan> Gurkenglas: "-ddump-inlinings", the info will be in the Core language, not Haskell.  Use "-dsuppress-all" to cut down on the info overload
15:48:57 <`Guest00000> so, i have this idea of a program. with this program you'll be able to define expressions in a functional language. a document defines some definitions, including 'main', which has type similar to bytestring. you can "render" a document to a file - evaluate 'main' and write that bytestring to the file
15:49:50 <sphinxo> Why do I sometimes see empty = mzero in instance Alternitive? 
15:49:59 <sphinxo> *alternative
15:50:44 <`Guest00000> the twist is this program is a visual editor - you can use 'forms' to define parts of expressions. a form is a piece of gui which can return a value of some type(s) in this language
15:51:33 <Cale> sphinxo: Because if you have an instance of MonadPlus, you can make an instance of Alternative from it pretty easily by defining empty like that and (<|>) = mplus
15:51:46 <sphinxo> ahh
15:51:46 <`Guest00000> so, for example, there can be a form which returns a 2d bitmap - it would accept mouse input to draw
15:52:00 <Cale> sphinxo: There's little difference between the two classes except that MonadPlus requires an instance of Monad, and has been around longer
15:52:37 <sphinxo> How would I implement empty for my Parser?
15:52:45 <`Guest00000> what should i do? i have two options: implement a language, or make my program a wrapper for generating Haskell code
15:52:57 <monochrom> empty and mzero should represent the simplest kind of parse error
15:53:00 <orzo> I really don't get the Alternative class
15:53:02 <Cale> sphinxo: Well, empty should probably be the parser which always fails, independently of the input
15:53:37 <sphinxo> ah ok, that makes sense
15:53:44 <Cale> i.e. it should always produce an empty list of parses
15:54:12 <sphinxo> Thank you
15:54:15 <Cale> sphinxo: and p <|> q should be a parser which runs both p and q, and combines their lists of results (appending them)
15:54:48 <sphinxo> wait what?
15:55:15 <sphinxo> I thought that was like try p and if p fails then q?
15:55:27 <Cale> You could do it that way too
15:55:50 <Cale> But you'll get better backtracking (though perhaps worse performance) if you append
15:55:53 <monochrom> it's up to you whether you like biased choice or symmetric choice
15:56:02 <sphinxo> actually you're way seems much cleaner
15:56:09 <sphinxo> *your
15:57:04 <sphinxo> But what happens if p runs successfully?
15:57:15 <Cale> Yeah, my way, it's easier to get the results you usually want, whereas being able to drop the second parser if the first one ever succeeds is a good way to save memory, but will result in situations where you have to be careful
15:57:32 <monochrom> q will also be run
15:57:52 <monochrom> if both are successful, you are effective saying you allow an ambiguous grammar
15:57:53 <sphinxo> Maybe i've misunderstood <|>
15:58:02 <Cale> Lazy evaluation will ensure that the search is depth first anyway if you just append
15:58:04 <Gurkenglas> mgsloan, http://lpaste.net/3729365913237979136 (or without the to-file thing, where does the dump go?)
15:58:46 <monochrom> stdout or stderr
15:58:53 <monochrom> I think it's stdout
15:58:53 <jle`> orzo: there's nothing "more" to it than that <|> is associative, and empty is the identity
15:59:02 <Cale> But if you only run q in the case where p produces an empty list of results, then you have to worry about what happens when all the parses from p cause future parsers to fail
15:59:26 <Cale> and maybe q would have had the result which made the future parsers succeed
15:59:33 <jle`> orzo: you also get some nice properties from parametricity, becuase <|> has to work for `f a`'s of *all* a's, so it can't depend on anything about the a itself, only the f
15:59:49 <jle`> but yeah, other than that, Alternative is just <|> that's associative, where empty is the identity
16:00:03 <jle`> orzo: different types are free to implement it however they want
16:00:26 <Cale> But yeah, if you only ever run q when p's list of results is empty, then as soon as p produces a result, q gets to be garbage collected, which can be nice
16:00:31 <mrlase> does anyone know the secret incantation for installing persistent? I'm getting Database.Persist.TH is not found despite making it a depedency in stack
16:00:42 <jle`> orzo: Alternative itself makes no reference to how <|> etc. should behave under <*>, so it's basically like a Monoid class, but * -> * instead of *
16:01:15 <jle`> orzo: things are a little trickier when you talk about MonadPlus, because there are some expected ways that mzero and mplus should behave w/ (>>=)
16:02:14 <jle`> but, if you "get" Monoid and monoids, you should get Alternative, too; the only thing different is that your implementations are restricted by parametricity
16:02:59 <Cale> mrlase: That module is in the persistent-template package
16:03:12 <mrlase> ah! thanks much :)
16:03:34 <`Guest00000> huh, i thought MonadPlus and Alternative were same thing
16:03:47 <`Guest00000> only with different superclass
16:04:19 <jle`> MonadPlus gives laws
16:04:30 <jle`> (that Alternative doesn't)
16:04:47 <`Guest00000> why Alternative doesn't give these laws too?
16:04:48 <Cale> Are the laws actually in the documentation yet?
16:04:56 <jle`> of course, if your type is both Alternative and MonadPlus, it's expected that (<|>) = mplus and empty = mempty
16:05:12 <k0ral> Hello
16:05:13 <jle`> `Guest00000: Alternative can't talk about >>=
16:05:17 <Cale> `Guest00000: because Alternative doesn't depend on Monad, so it doesn't make so much sense to talk about laws involving <|> and >>=
16:05:28 <`Guest00000> but at least >>
16:05:30 <jle`> Cale: there are laws for mzero in the documentation
16:05:58 <jle`> but mplus "laws" are sort of floating around as a collective understanding
16:06:07 <jle`> even though there are some different interpretations of what those laws should be >_>
16:06:09 <`Guest00000> *> = >> (right?)
16:06:37 <k0ral> looking at the 'path' package, I'm intrigued as to why it seems impossible to write a generic 'parse :: MonadThrow m => FilePath -> m (Path a b)'
16:07:05 <`Guest00000> so, we could give: "empty *> a = empty" and "a *> empty = empty"
16:07:34 <k0ral> ythe API is nice in the way it only allows operations that make sense given the kind of path one is manipulating
16:09:17 <k0ral> but wouldn't that be great if one could parse a path without knowing in advance what kind of 'Path b t' it is ?
16:09:41 <k0ral> could someone please explain to me why that's not possible ?
16:10:23 <Cale> k0ral: Well... you'd need some sort of existential type, where you wouldn't be able to assume you knew which types b or t were in all the code which followed
16:10:39 <Cale> k0ral: I'm unfamiliar with the library
16:11:01 <Cale> k0ral: But generally, it's important to remember that types don't exist at runtime
16:11:29 <Cale> So, things whose type depends on the runtime value of something aren't generally possible in Haskell.
16:12:43 <k0ral> Cale: existential types do exist through some GHC extension right ? Would that allow my dreams to come true ? :)
16:12:58 <Cale> k0ral: maybe, though you might find it immediately frustrating
16:13:32 <Cale> k0ral: when you unwrap your values of type Path b t for b and t which are unknown, and not be able to apply many operations to them because you've forgotten which types b and t are
16:13:34 <`Guest00000> so. my question unanswered, why Alternative doesn't give at least "empty *> a = empty" and vice versa?
16:13:42 <Cale> (but maybe not... I don't know this library)
16:13:45 <sphinxo> k0ral: ExistentialQuantification is the extension you're probably looking for
16:13:55 <Cale> Yeah
16:14:05 <sphinxo> https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
16:14:05 <k0ral> sphinxo: that requires newtype/data wrapping that is really cumbersome
16:14:21 <Cale> yes, that's the other downside
16:14:37 <Cale> (but it's less important)
16:14:43 <k0ral> Cale: I understand that, but here for example, there is a "isParentOf :: Path b Dir -> Path b t -> Bool" function, and the second operand does not need to be known
16:15:16 <k0ral> Cale: what if I want to parse some string into a Path b t, regardless of which "b" and "t" it matches, and use it as 2nd operand for "isParentOf" ?
16:15:18 <Cale> k0ral: you need to know that whatever type b is, it matches the b type in the Path you give
16:15:46 <Cale> k0ral: So you'd basically not be able to use that operation unless you also unpacked the Path b Dir from the same existential
16:16:23 <k0ral> Cale: no, my intent was to use the unknown path as 2nd operand only
16:16:48 <k0ral> Cale: say the 1st operand was statically parsed as Path b Dir
16:16:52 <Cale> k0ral: yes, which is going to be a problem, because its 'b' type can be anything and might not match the 'b' type in the Path you provide
16:17:05 <Cale> Maybe if you have something which is polymorphic
16:17:13 <k0ral> aaahhh right, b must be the same for both
16:17:13 <Cale> Like, if you have x :: forall b. Path b Dir
16:17:16 <Cale> then you'd be fine
16:19:14 <k0ral> ok so given the API of 'path', there is no use case where parsing a generic 'Path b t' would make sense
16:19:32 <k0ral> since no operation would be allowed on the result
16:19:49 <k0ral> except toFilePath which "unparses" it...
16:24:54 <daan> .
16:25:46 <daan>     /set irc.server.freenode.autojoin "#haskell"
16:37:21 <nolrai2> @pl \ f (x,y) -> (f x, f y)
16:37:22 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
16:38:00 <nolrai2> @pl \ f x y -> (f x, f y)
16:38:00 <lambdabot> flip =<< (((.) . (,)) .)
16:38:08 <nolrai2> @pl \ x y -> (f x, f y)
16:38:09 <lambdabot> (. f) . (,) . f
16:39:03 <nolrai2> @pl \ x y z w -> (f x z, f y w)
16:39:04 <lambdabot> (. f) . flip . (((.) . (,)) .) . f
16:39:35 <maerwald> I'll hunt you down if you use that in real world code.
16:39:51 <maerwald> :/
16:41:40 <`Guest00000> actually
16:42:19 <`Guest00000> f *** f
16:42:27 <`Guest00000> :t f *** f
16:42:29 <lambdabot> (Arrow a, FromExpr (a b c), FromExpr (a b' c')) => a (b, b') (c, c')
16:42:33 <`Guest00000> ugh
16:43:02 <Gurkenglas> What sort of thing like a Prism would allow me to go from Monad m => m (Just a) to m a?
16:43:07 <`Guest00000> :t f *** f  :: (a -> b) -> (a, a) -> (b, b)
16:43:09 <lambdabot>     Couldn't match type ‚Äò((), ())‚Äô with ‚Äòa1 -> b1‚Äô
16:43:10 <lambdabot>     Expected type: (a1 -> b1) -> (a1, a1) -> (b1, b1)
16:43:10 <lambdabot>       Actual type: ((), ()) -> (c0, c'0)
16:43:19 <jle`> :t \f -> bimap f f   -- nolrai2 
16:43:21 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
16:44:16 <nolrai2> jle`: thanks, though I was miss reading my own code. >.<
16:44:59 <maerwald> pointfree is not a refactoring tool, most of the time it gives dumb answers
16:45:05 <nolrai2> Yes.
16:45:17 <nolrai2> Was hoping it wouldn't.
16:45:25 <nolrai2> Was a forlorn hope.
16:45:48 <nolrai2> I think I know all the functions it does, so its not really useful to me anymore.
16:48:46 <nolrai2> :t foldl'
16:48:47 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
16:50:33 <`Guest00000> :t f
16:50:35 <lambdabot> FromExpr a => a
16:50:37 <`Guest00000> heh
16:50:40 <`Guest00000> > f
16:50:42 <lambdabot>      No instance for (Show a0)
16:50:42 <lambdabot>        arising from a use of ‚Äòshow_M39465411904000396383129‚Äô
16:50:42 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
16:51:03 <Gurkenglas> @let phi f x = return x <|> (f x >>= phi f) -- Find a better way?
16:51:05 <lambdabot>  Defined.
16:51:06 <geekosaur> lambdabot has simple-reflect installed
16:58:23 <jle`> i wonder why there's no Integral n => Integral (Sum n) instance
16:58:24 <nolrai2> What is the most ideomatic way of producing \ n x -> f n (f (n-1) (f (n -2) ..f 0 x)))))?
16:58:26 * jle` wonders
16:58:54 <jle`> nolrai2: foldr f x [1..n], probably
16:59:06 <jle`> or rather, [n,n-1..0]
16:59:25 <nolrai2> Thanks I should have seen that.
16:59:40 <jle`> > foldr f x [5,4,3,2,1]
16:59:42 <lambdabot>  f 5 (f 4 (f 3 (f 2 (f 1 x))))
17:01:08 <`Guest00000> > fix f
17:01:11 <lambdabot>      No instance for (Show a0)
17:01:11 <lambdabot>        arising from a use of ‚Äòshow_M70041356865488789953434‚Äô
17:01:11 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
17:01:39 <`Guest00000> hm
17:02:39 <`Guest00000> i thought lambdabot could do magic stuff
17:02:56 <jle`> > fix (f :: Expr -> Expr)
17:02:57 <geekosaur> again, that's simple-reflect
17:02:59 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
17:03:09 <geekosaur> you can install that locally, even
17:03:14 <glguy> or just: fix f :: Expr
17:03:15 <geekosaur> @hackage simple-reflect
17:03:15 <lambdabot> http://hackage.haskell.org/package/simple-reflect
17:03:24 <`Guest00000> ok will look into that, thank you
17:03:48 <jle`> > fix (f . g) :: Expr
17:03:50 <lambdabot>      No instance for (Show b0) arising from a use of ‚Äòf‚Äô
17:03:50 <lambdabot>      The type variable ‚Äòb0‚Äô is ambiguous
17:03:50 <lambdabot>      Note: there are several potential instances:
17:03:54 <`Guest00000> that looks cool
17:04:08 <nolrai2> And if I wanted to do the equivalent of a 'break' then I should use throwE?
17:04:25 <glguy> jle`: It can't guess the result of f / argument of g that way
17:04:32 <glguy> err, otherway around :)
17:04:44 <glguy> result g / arg f
17:04:49 <jle`> > fix ((f :: Expr -> Expr) . (g :: Expr -> Expr))
17:04:52 <lambdabot>  f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g...
17:04:54 <geekosaur> right. it's not as magical as it looks, just clever
17:05:05 <geekosaur> but not quite clever enough :)
17:07:13 <orzo> thanks jle` .  What I don't get though is why more than how.  I take it from your description that it really is just a general monoid interface for * -> * types, but then we also have this "some" and "many" stuff
17:07:41 <jle`> yeah, some and many only make sense for certain instances, and i think it's best to understand them on a per-instance basis
17:08:09 <jle`> > let xs = f : g : zipWith (.) xs (tail xs) in xs !! 5 $ x
17:08:11 <lambdabot>  g (f (g (f (g (g (f (g x)))))))
17:08:26 <orzo> it's looking like this type class isn't a very compelling abstraction
17:08:27 <nolrai2> Like I have "f n input = if <big expensive check> then complicatedOutput else input" and if I want to get the input that is passed in the first time the big expensive check fails, (because once it fails nothing changes). Then "f n input = if <check> then pure complicatedOutput else throwE input" makes sense, no?
17:08:51 <Tekmo> orzo: The `Alternative` class is mainly to work around limitations in Haskell's type class system
17:09:03 <jle`> oh hi Tekmo 
17:09:07 <Tekmo> Hi!
17:09:46 <orzo> Because <|> is so general, it's also sort of useless.  It obfuscates what's interesting rather than cutting away distracting detail
17:09:46 <jle`> every time i accidentally spend three hours on irc instead of doing work i remember the advice you gave me and my hubris for disregarding it, and then i do it again the next day :3
17:09:46 <Tekmo> orzo: Reason #1. Haskell doesn't have a good way to express a constraint like `(forall a . Monoid (f a)) => ...`
17:09:49 <Gurkenglas> some and many are unfolds, they take an Alternative and apply it in the longest chain that doesn't fail. They are also a little more strict than necessary so they don't work for some easy examples, but I fixed that. http://lpaste.net/150561
17:09:51 <nolrai2> Isn't Alternative for parsers and nondeterminaism?
17:10:05 <Gurkenglas> @letlpaste 150561
17:10:07 <lambdabot>  Defined.
17:10:21 <Gurkenglas> > manyLazy (Just 2)
17:10:23 <lambdabot>  Just [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
17:10:29 <sm> jle`: share this useful advice ?
17:10:48 <sm> "turn off irc" was it ?
17:10:48 <Tekmo> orzo: Reason #2.  An `Alternative f => ...` constraint is nicer than a `Monoid (f a), Applicative f => ...` constraint, the latter of which requires `FlexibleConstraints`
17:10:50 <jle`> orzo: well, because of parametric polymorphism, <|>'s implementations are even more limited and restricted than <>
17:11:11 <Tekmo> orzo: Reason #3, what `jle` just said (`Alternative` reduces the space of valid instances, which is good)
17:12:34 <Gurkenglas> > evalStateT (manyLazy $ StateT uncons) [1..5] -- It applies StateT uncons, which takes the first element out of a list state. If there's no element left, StateT uncons fails.
17:12:36 <lambdabot>  Just [1,2,3,4,5]
17:14:22 <acertain> does anyone know of references on row polymorphism + dependent types (inductive/dependent row types or such)?
17:14:59 <ReinH> nolrai2: alternative is for lots of things.
17:15:03 <ReinH> Tekmo: o/
17:15:04 <Gurkenglas> It essentially does (... <|> replicateM 6 (StateT uncons) <|> replicateM 5 (StateT uncons) <|> replicateM 4 (StateT uncons) <|> ...), taking the first one that works. (except that this "essentially" term, even if it wasn't infinite, would execute the monadic effects multiple times, which doesn't happen in the real implementation of many)
17:15:13 <Tekmo> ReinH: o/
17:15:35 <orzo> well those reasons sound good, but I'll still probably never think to use Alternative for anything until I see some other guru use it in a way that brings home to me the power.  I'd sooner be growing my own type classes, probably.
17:15:49 <Gurkenglas> > evalStateT (someLazy $ StateT uncons) [] -- some does the same thing, except that it fails if the maximum chain that works would be empty.
17:15:51 <lambdabot>  Nothing
17:16:07 <Tekmo> orzo: Lots of examples of the use of `Alternative` in this tutorial: http://hackage.haskell.org/package/turtle-1.2.5/docs/Turtle-Tutorial.html
17:18:11 <saurabhnanda> hey, I've spent more than a day trying to wrap my head around EitherT, but I'm completely stuck. What does https://github.com/ekmett/either/blob/master/src/Control/Monad/Trans/Either.hs#L168-L170 exactly do? What's the difference between EitherT and runEitherT?
17:18:20 <ReinH> In the same sense that much of the utility of Monad comes from being able to write things like sequence, much of the utility of Alternative comes from being able to write things like msum.
17:18:39 <jle`> saurabhnanda: have you looked at their types?
17:18:53 <ReinH> er, asum
17:19:20 <jle`> data EitherT e m a = EitherT { runEitherT :: m (Either e a) }
17:19:25 <Tekmo> saurabhnanda: The type of `EitherT` is `EitherT :: m (Either a b) -> EitherT a m b`.  The type of `runEitherT` is `runEitherT :: EitherT a m b ->  (Either a b)`
17:19:31 <jle`> do you know how record accessors work?
17:19:33 <ReinH> jle`: newtype, but yes
17:19:35 <jle`> and constructors work?
17:19:36 <Tekmo> saurabhnanda: In other words, those two functions are inverses of each other
17:19:47 <ReinH> Tekmo: missing an m
17:19:59 <Tekmo> Oops, the last one should have been `runEitherT :: EitherT a m b -> m (Either a b)`
17:20:02 <ReinH> If anyone else needs small, pedantic corrections, I'll be right here.
17:20:06 <Tekmo> Haha
17:20:19 <jle`> saurabhnanda: so something like EitherT . foo . runEitherT will unrap the EitherT wrpaper, apply foo to the m (Either e a) inside, and then add the rwapper back in
17:20:30 <saurabhnanda> is it like creating a record-type for Person, where firstName takes a Person object and return it's firstname
17:20:38 <jle`> you could have written fmap like fmap f (EitherT et) = EitherT (f et)
17:20:43 <saurabhnanda> similarly runEitherT takes and EitherT and returns what?
17:20:46 <jle`> um, EitherT (fmap f et)
17:21:05 <jle`> saurabhnanda: yeah, EitherT is a record with one field, an m (Either e a)
17:21:38 <jle`> dat Person = Person { firstName :: String }, and we have EitherT e m a = EitherT { runEitherT :: m (Either e a) }
17:21:40 <jle`> same deal
17:22:03 <saurabhnanda> how come :t EitherT works, but :t Either doesn't? 
17:22:16 <jle`> because type works for value constructors
17:22:19 <jle`> there is no Either constructor
17:22:24 <jle`> Either is a type constructor
17:22:34 <jle`> > Either 7
17:22:36 <lambdabot>      Not in scope: data constructor ‚ÄòEither‚Äô
17:22:36 <lambdabot>      Perhaps you meant variable ‚Äòeither‚Äô (imported from Data.Either)
17:23:00 <jle`> saurabhnanda: try :t Left, :t Right
17:23:30 <jle`> but yeah, a clearer way to write the code you linked to would be fmap f (EitherT et) = EitherT (liftM (fmap f) et)
17:23:30 <saurabhnanda> okay, got it. But haven't internalized it completely.
17:23:41 <jle`> if that makes more sense to you
17:24:15 <DuncanKeith> Hey. Has anyone here incoporated Haskell code into an iPhone application?
17:24:16 <jle`> it basically applies (fmap f) on the Either e a "inside" the m
17:24:16 <ReinH> And now that AMP has passed, fmap f (EitherT et) = EitherT (fmap (fmap f) et)
17:24:30 <saurabhnanda> so, going back to basics, fmap is basically fmap :: (a->b) -> f a -> f b
17:25:00 <jle`> saurabhnanda: so if et :: m (Either e a), then fmap f :: Either e a -> Either e b, and fmap (fmap f) applies that to "inside" the m
17:25:41 <jle`> f :: (a -> b), fmap f : Either e a -> Either e b, fmap (fmap f) :: m (Either e a) -> m (Either e b)
17:26:16 <saurabhnanda> i'm lost again
17:26:41 <saurabhnanda> for https://github.com/ekmett/either/blob/master/src/Control/Monad/Trans/Either.hs#L168-L170 what's the data type of the first argument?
17:26:54 <jle`> f :: (a -> b)
17:26:54 <saurabhnanda> EitherT e IO String ?
17:27:14 <jle`> fmap for EitherT is fmap :: (a -> b) -> EitherT e m a -> EitherT e m b
17:27:15 <saurabhnanda> just to put some concrete types to make things clearer?
17:27:29 <jle`> so the first argument is (a -> b), the second argument is EitherT e m a
17:27:51 <jle`> or well, i guess there's no second argument in the way it's written
17:27:58 <ReinH> (note that EitherT has at this point been obsoleted by ExceptT in transformers/mtl, which is the same thing with a different name)
17:28:02 <saurabhnanda> so, is EitherT a container for a, b, or (Either e a)
17:28:55 <saurabhnanda> and that's the other problem I'm running into. Some literature around either, some around errors, some around mtl.
17:29:32 <saurabhnanda> so, EitherT is a container for a an not (Either e a) ?
17:29:46 <Tekmo> saurabhnanda: `EitherT a m b` is a container for a `m (Either a b)`
17:30:20 <ReinH> EitherT e m a is a wrapper around an action of type m (Either e a)
17:30:26 <jle`> saurabhnanda: no, an EitherT is a container for only an m (Either e a)
17:30:26 <jle`> so an EitherT e IO a is a wrapper around an IO (Either e a)
17:30:26 <jle`> so, to "fmap" an EitherT e m a, you take out the m (Either e a) inside, and you fmap (fmap f) over it, and you wrap it back into the EitherT wrapper
17:30:30 <saurabhnanda> Tekmo: can you give an example without the variables?
17:30:39 <saurabhnanda> Tekmo: using IO, String, Integer, etc?
17:30:45 <adas> im using the split function from Data.Bytestring. I try split '-' "2015-10" but I get a type error saying '-' is a Char when a Word8 is expected.
17:30:54 <adas> I already have set OverloadedStrings
17:30:57 <jle`> EitherT String IO Bool is a wrapper around IO (Either String Bool)
17:31:04 <Tekmo> saurabhnanda: `EitherT String IO Int` is a 1-element container holding a `IO (Either String Int)`
17:31:37 <saurabhnanda> just to be clear, it's NOT EitherT String (IO Int)
17:31:58 <Tekmo> saurabhnanda: That's right.  It is `((EitherT String) IO) Int`
17:32:18 <adas> anyone?
17:32:21 <saurabhnanda> okay, given the container class, fmap then needs a function that can convert (Either String Int) -> what?
17:32:38 <Tekmo> adas: Import `Data.ByteString.Char8`
17:32:40 <jle`> adas: overload strings won't help if you have a Char, heh
17:32:46 <jle`> or, wait,d oes it do that?
17:33:10 <jle`> saurabhnanda: fmap takes an (a -> b)
17:33:17 <jle`> and returns an EitherT e m a -> EitherT e m b
17:33:23 <Tekmo> `fmap` has a different type depending on the context in which it is invoked
17:33:45 <Tekmo> The general type of `fmap` is just: `fmap :: Functor f => (a -> b) -> f a -> f b` where `f` can be one of many type constructors
17:33:47 <saurabhnanda> jle`: is that right? doesn't that violate the fmap definition?
17:33:52 <Tekmo> For example, `f` could be `EitherT String IO`
17:34:02 <saurabhnanda> fmap :: (a->b) -> [a] -> [b]
17:34:03 <Tekmo> But `f` could also be `Either String`, too
17:34:08 <jle`> fmap :: (a -> b) -> EitherT e m a -> EitherT e m b
17:34:09 <saurabhnanda> here [] is a container on a's and b's 
17:34:19 <jle`> fmap works on more than just containers
17:34:34 <jle`> here, (EitherT e m) is your functor, f
17:34:35 <Tekmo> saurabhnanda: The precise term for that is "type-constructor"
17:35:20 <jle`> fmap :: (a -> b) -> (EitherT e m) a -> (EitherT e m ) b
17:36:52 <Tekmo> saurabhnanda: In the code that you linked to the type of the `fmap` on the left-hand side is `fmap :: (a -> b) -> EitherT e m a -> EitherT e m b`.  The type of the `fmap` on the right-hand side is `fmap :: (a -> b) -> Either e a -> Either e b`
17:37:32 <Tekmo> saurabhnanda: The compiler knows which one is which by the inferred type at the context where they are used
17:41:00 <saurabhnanda> sorry, had a short power outage
17:42:24 <saurabhnanda> so, basically is my "container" analogy breaking down. I should be thinking of fmap in terms of type-constructors and not containers?
17:43:06 <saurabhnanda> fmap :: (a-> b) -> EitherT e m a -> EitherT e m b
17:43:25 <EvanR> saurabhnanda: yes
17:43:57 <saurabhnanda> why do I need EitherT for saner error handling? Why can't I keep stringing stuff with fmap::(a->b)->(Either e a)->Either(e b)
17:44:15 <jle`> you never need EitherT
17:44:34 <Tekmo> saurabhnanda: You don't need `EitherT` for saner error handling.  It's merely a convenience.  If you feel comfortable explicitly threading `Either` values around then that's okay
17:44:39 <jle`> it's only useful for simplyifying awy a bunch of pattern matching
17:44:48 <jle`> and for using generic polymorphic functions, too
17:45:40 <Tekmo> saurabhnanda: Here is a small example to illustrate where `EitherT` sometimes comes in handy
17:46:16 <Tekmo> saurabhnanda: Suppose that you have an action of type `IO (Either String Int)` and you want to repeat the action 10 times and collect all the results if they all succeed.  In other words, you want the final result to have type `IO (Either String [Int])`
17:46:41 <Tekmo> saurabhnanda: That would be a bit tricky if you were to write out that loop by hand
17:46:59 <Tekmo> saurabhnanda: But you could greatly simplify it by first wrapping the action in `EitherT`
17:47:08 <jle`> saurabhnanda: if you think of an EitherT e m a as, "a computation in m that can either succeed with an e or fail with an a", then fmap means taking a computation that can succed with an a and turning it into a computation that can succeed with a b.  that's what it "means", and so EitherT's Functor instance portrays that
17:47:11 <Tekmo> saurabhnanda: So suppose that we call this action `io :: IO (Either String Int)`
17:47:23 <Tekmo> saurabhnanda: Then `EitherT io :: EitherT String IO Int`
17:47:39 <Tekmo> saurabhnanda: Then `replicateM 10 (EitherT io) :: EitherT String IO [Int]`
17:47:53 <Tekmo> saurabhnanda: Then `runEitherT (replicateM 10 (EitherT io)) :: IO (Either String [Int])`
17:48:41 <Tekmo> saurabhnanda: Now suppose that we had not wrapped the action in `EitherT` and we instead just used `replicateM` directly, like this:
17:48:56 <Tekmo> saurabhnanda: `replicateM 10 io :: IO [Either String Int]`
17:49:32 <Tekmo> saurabhnanda: That is a slightly different result.  We still have 10 results, but now we have to go through all 10 of them to see if there are any errors and collect the successful results if there were no errors
17:51:55 <saurabhnanda> Tekmo: I think I'll need a little more time to digest that :)
17:52:05 <saurabhnanda> I'm staring at "EitherT $ try $ return $ read i" and trying to make sense of it
17:52:06 <Tekmo> saurabhnanda: Alright :)
17:52:28 <Tekmo> saurabhnanda: Whenever you try to digest something, work through the types one sub-expression at a time
17:52:30 <saurabhnanda> try $ return $ (read "1") :: :: (Read r, Exception e) => IO (Either e r)
17:52:54 <Tekmo> saurabhnanda: That looks like a mistake in that code, though
17:53:11 <saurabhnanda> so, is EitherT being applied to something of type IO (Either e r) ?
17:53:30 <Tekmo> saurabhnanda: If I understand that code correctly, it is trying to read a string like "Right 1"
17:53:37 <Tekmo> saurabhnanda: If you try to read a string like "1" it will fail
17:54:03 <Tekmo> You also shouldn't be using `read` at all since it is partial and will throw an unchecked exception that is difficult to catch if parsing fails
17:54:27 <EvanR> not designed to be caught exception
17:54:31 <Tekmo> saurabhnanda: Use `readEither` instead: https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readEither
17:54:31 <saurabhnanda> :t try $ return $ (read "1")
17:54:33 <lambdabot> (Read r, Exception e) => IO (Either e r)
17:54:40 <EvanR> it throws the UseMaybeInstead exception
17:54:41 <Tekmo> I understand that, but your code is still incorrect
17:54:58 <saurabhnanda> Tekmo: which is why it's wrapped in a `try`?
17:55:11 <EvanR> using IO to catch a read failure :(
17:55:14 <Tekmo> saurabhnanda: That `try` is not helping you at all
17:55:31 <Tekmo> There are two separate errors in that code
17:56:02 <Tekmo> The first error is that `read` is not trying to deserialize an `Int` from the string.  It's trying to deserialize an `Either e Int` from the string`
17:56:23 <Tekmo> So if you supply `read` with the string "1" then the deserialization will fail
17:56:54 <Tekmo> It's easier to see if you add this type annotation to your code
17:57:29 <Tekmo> EitherT (try (return (read "1" :: Either e Int)))
17:58:09 <saurabhnanda> :t try $ return $ (read "1"::Int) :: Exception e => IO (Either e Int)
17:58:11 <lambdabot> Exception e => IO (Either e Int)
17:58:13 <saurabhnanda> okay, got error #1
17:58:32 <saurabhnanda> Tekmo: what's the second error?
17:58:46 <saurabhnanda> btw, for greater context, here's what I'm trying to solve: https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs#L198-L203
17:58:57 <saurabhnanda> I wrote that code and realized that it felt too imperative.
17:59:03 <Cale> saurabhnanda: uh, return will never ever throw an exception
17:59:17 <saurabhnanda> someone on #haskell pointed me to an EitherT version of that code and I've been trying to wrap my head around it since then
17:59:21 <Cale> saurabhnanda: So that try is essentially pointless
17:59:32 <Cale> Because it's never going to have anything to catch
17:59:59 <saurabhnanda> Cale: read with throw an exception, right? It'll bubble up to the try?
18:00:15 <Cale> return won't cause the read to be evaluated
18:00:25 <Cale> If you want to handle parse failure, you shouldn't use read
18:00:30 <Cale> Use readMaybe or reads
18:00:40 <Cale> :t readMaybe
18:00:43 <lambdabot> Not in scope: ‚ÄòreadMaybe‚Äô
18:00:48 <Cale> ah, not imported
18:00:54 <jle`> @let import Data.Text
18:00:56 <lambdabot>  .L.hs:167:51:
18:00:56 <lambdabot>      Ambiguous occurrence ‚Äòuncons‚Äô
18:00:56 <lambdabot>      It could refer to either ‚ÄòData.List.uncons‚Äô,
18:00:59 <jle`> :(
18:01:09 <jle`> wrong one
18:01:10 <Cale> It's in Text.Read anyway
18:01:12 <jle`> @let import Text.Read
18:01:16 <lambdabot>  Defined.
18:01:23 <Cale> :t readMaybe
18:01:28 <lambdabot> Read a => String -> Maybe a
18:01:35 <Cale> :t reads
18:01:37 <lambdabot> Read a => ReadS a
18:01:50 <Cale> I really wish that type synonym weren't there :P
18:02:08 <Cale> anyway, ReadS a = String -> [(a,String)]
18:02:29 <nolrai2> @hoogle Either a a -> a
18:02:31 <Cale> So you give it a String and it gives you a list of options for parses (which will usually have 0 or 1 elements)
18:02:32 <lambdabot> Data.Either rights :: [Either a b] -> [b]
18:02:33 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
18:02:33 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
18:02:44 <jle`> saurabhnanda: but yes, EitherT, Either, etc. are unrelated to IO exceptions and runtime exceptions in haskell.  in fact, I think many people consider EitherT e IO a to be an anti-pattern
18:02:54 <Cale> :t either id id
18:02:55 <lambdabot> Either c c -> c
18:02:58 <Cale> nolrai2: ^^
18:02:59 <adas> So Data.ByteString allows manipulation of a set of bytes. It makes no guesses about how the bytes are interpreted. Whereas Data.ByteString.Char8 provides the same set of operations but assumes that the bytes it is manipulating are perfectly valid unicode chars in the 0-255 codepoint range? Am I correct in that difference?
18:03:08 <nolrai2> Cale++
18:03:20 <jle`> :t id ||| id
18:03:21 <lambdabot> Either c c -> c
18:03:24 <Cale> adas: Yeah, well, ASCII chars
18:03:56 <EvanR> adas: Char8 will mangle your unicode characters that are out of range
18:03:59 <Cale> adas: Also, the data structure is the same type between the two modules, only the functions are different
18:04:01 <EvanR> silently
18:04:03 <nolrai2> Really? Shouldn't that be Char7?
18:04:22 <saurabhnanda> jle`: what's the idiomatic way to handle the error cases in https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs#L198-L203 ?
18:04:27 <`Guest00000> hm... is there no read parse error exception?
18:04:36 <Cale> The point is to be convenient in cases where you know that the characters will be in range
18:04:39 <jle`> saurabhnanda: i think i answered this last night
18:04:50 <EvanR> `Guest00000: use a function that returns Maybe or Either instead
18:05:00 <saurabhnanda> jle`: but you're saying EitherT IO is an anti-pattern
18:05:02 <Cale> So, it would defeat the purpose to have some other Char-like type
18:05:05 <jle`> readIntegralFromFile :: String -> IO (Maybe Int); readIntegralFromFile fname = readMaybe <$> readFile fname
18:05:12 <saurabhnanda> http://lpaste.net/150553 // not recommended?
18:05:12 <adas> thanks for the clarification. so in concise, I shouldn't be using Data.ByteString.Char8 if I am not sure that the bytes I am manipulating are not strictly in ASCII range
18:05:17 <Cale> adas: yeah
18:05:28 <jle`> or readIntegralFromFile fname = do file <- readFile fname; return (readMaybe file)
18:05:30 <Cale> adas: Use Data.Text if you want to manipulate unicode text
18:05:42 <jle`> saurabhnanda: yes
18:05:46 <EvanR> `Guest00000: readMaybe in Data.Text.Read
18:05:47 <jle`> definitely a bad idea
18:05:59 <saurabhnanda> (readFile fname) throws an error if the file does not exist. 
18:06:07 <saurabhnanda> I don't want the calling function to catch errors.
18:06:10 <jle`> yes, which can be handled by whoever calls readIntegralFromFile
18:06:16 <saurabhnanda> Probably the calling function can just deal with Maybe or Either
18:06:19 <EvanR> er Text.Read
18:06:33 <jle`> the person who uses readIntegralFromFile should know that there could be an IO exception that hapens in the process
18:06:44 <EvanR> saurabhnanda: that kind of exception is really better to ignore
18:07:05 <EvanR> unless you dont want to
18:07:12 <`Guest00000> yes, i guess that's better, but i asked if it exists
18:07:14 <jle`> that way, they can choose how to handle the exception when the time comes
18:07:16 <jasonkuhrt> Hi, this might be a silly question but I'm learning QuickCheck and Haskell right now and am curious how people generate at the type level (as opposed to the term level)
18:07:27 <jle`> instead of forcing them to handle it as an Either e a, which they might not have even wanted
18:07:34 <saurabhnanda> so, this function is going to be used to read a PID from a file. If it returns Nothing then the PID file doesn't exist and a process needs to be spawned and the PID file needs to be created.
18:07:35 <EvanR> `Guest00000: there is an exception
18:07:38 <nolrai2> > [5 , 4 .. 0]
18:07:41 <lambdabot>  [5,4,3,2,1,0]
18:07:41 <EvanR> > read "1" :: Char
18:07:43 <lambdabot>  *Exception: Prelude.read: no parse
18:07:49 <`Guest00000> uh, i meant
18:07:52 <jle`> saurabhnanda: no, it returns Nothing if the PID file exists and cannot be parsed
18:07:58 <`Guest00000> a type which is in Exception
18:07:59 <jle`> it returns (Just i) if it exists and can be parsed
18:08:07 <jasonkuhrt> My motivation is for the same reason that we want to generate at the term level. Sometimes the type does not matter as much as it be any type that implements a certain Type Class.
18:08:16 <jle`> saurabhnanda: and, if the file doesnt' exists, throws an IO error
18:08:22 <jasonkuhrt> For example in this property test of the `sort` function https://github.com/jasonkuhrt/hpfp-answers/blob/master/chapter-14/QuickCheckTests/QuickCheckTests.hs#L37
18:08:33 <andromeda-galaxy> any type level wizards around here know of a decent way to say "type instance (Constraint a) => FamilyName a a = b"?
18:08:51 <jasonkuhrt> I have hardcoded arbitrary to :: Gen [Float]
18:08:59 <saurabhnanda> jle`: what's the downside of return a Nothing in both the conditions -- IO Error AND parse error?
18:09:05 <jasonkuhrt> But the Float type is arbitrary, I just need a type that implements the Ord Type Class
18:09:07 <jle`> IO errors are very different than parse errors
18:09:27 <jle`> IO exceptions are easier to deal with using the exception mechanisms in the haskell runtime
18:09:27 <EvanR> `Guest00000: it appears to be the same kind of exception as the one from error, which isn't the kind of really want to catch
18:09:31 <jasonkuhrt> Any tips/advice appreciated! Thanks
18:09:38 <EvanR> @src error
18:09:38 <lambdabot> error s = throw (ErrorCall s)
18:09:53 <EvanR> hrm
18:09:53 <`Guest00000> ah
18:09:55 <jle`> haskell's runtime exception system is well-suited for handling dynamic runtime exceptions in ways that Maybe/Either can't
18:10:04 <`Guest00000> interesting
18:10:06 <jle`> that is, IO exceptions that happenw hen executing IO
18:10:10 <EvanR> can't or would be really annoying
18:10:23 <`Guest00000> hm, also, we can get error string
18:10:24 <`Guest00000> nice
18:10:26 <jle`> you have a whole infrastructure that makes this easy to handle, so there's no need to use Nothing here for something it's not meant for
18:10:31 <`Guest00000> ok, thanks
18:10:33 <jle`> and when there are better tools for dealing with it
18:10:56 <mrlase> I'm trying to handle a POST url with scotty and persistent: I have a `createAccount` function which is supposed to insert it in the db, but I'm not entirely sure what it's type is supposed to be: https://gist.github.com/acrognale/d4a3796e41a0f1d033ef#file-api-hs-L48
18:10:58 <EvanR> to be fair theres a large number of ways to deal with errors and it can be confusing
18:11:19 <EvanR> it aint as simple as good old C return -1
18:11:43 <saurabhnanda> jle`: that's exactly what I'm not getting. I'm approaching haskell as a way to convert many run-time scenarios to compile-time scenarios. Handling exception => runtime. Handling Maybe/Either => compile time.
18:12:11 <Tekmo> saurabhnanda: I believe the term you are looking for is checked versus unchecked exceptions
18:12:43 <Tekmo> saurabhnanda: `IO` is analogous to checked exceptions and `EitherT/Either/MaybeT/Maybe` is analogous to checked exceptions
18:12:45 <EvanR> saurabhnanda: handling Maybe Either is still runtime
18:12:45 <Tekmo> Oops
18:12:53 <Tekmo> I meant `IO` is like unchecked exceptions
18:13:00 <saurabhnanda> Tekmo: right, got it.
18:13:04 <EvanR> saurabhnanda: to handle errors at compile time, you have to make them impossible at runtime
18:13:13 <EvanR> with proper types
18:13:29 <saurabhnanda> so, why are unchecked exceptions better? The reason I'm trying Haskell is to make lesser run-time errors
18:13:37 <jle`> there's always a trade-off, it's not always better and always worse
18:13:39 <saurabhnanda> get the compiler to baby-sit all the edge cases for me
18:13:51 <EvanR> getting genuine IO to never have a runime error is not easy
18:14:06 <jle`> for errors that arise during evaluation, Maybe and Either work very well.
18:14:06 <EvanR> which is why you want to keep as little code in IO as possible
18:14:15 <jle`> for errors that arise during execution ... things are complicated
18:14:17 <k4pod> :EvanR the number of diffrent to handle errors is frustrating sometime. And ghc 8.0.1 is adding MonadError...
18:14:21 <Tekmo> saurabhnanda: I think you would be interested in the `unexceptionalio` package, specifically the `fromIO` function in that package: https://hackage.haskell.org/package/unexceptionalio-0.3.0/docs/UnexceptionalIO.html#v:fromIO
18:14:25 <EvanR> k4pod: sweet
18:14:32 <`Guest00000> hrm
18:14:38 <EvanR> the more the merrier
18:14:42 <`Guest00000> :t try $ return undefined :: IO (Either SomeException a)
18:14:44 <lambdabot> IO (Either SomeException a)
18:14:49 <Tekmo> saurabhnanda: That basically has a `UIO` type which is like `IO` except that it can't throw any unchecked exceptions.  The package forces all exceptions to be checked
18:14:51 <`Guest00000> > try $ return undefined :: IO (Either SomeException a)
18:14:53 <lambdabot>      No instance for (Typeable a0)
18:14:53 <lambdabot>        arising from a use of ‚Äòshow_M67693698827654106065061‚Äô
18:14:53 <lambdabot>      In the expression:
18:15:00 <`Guest00000> ^ why does that happen?
18:15:08 <`Guest00000> ahhhh
18:15:13 <`Guest00000> i'm stupid
18:15:15 <jle`> literally every single IO action ever can throw an IO exception, and all of different types, and of different types of data you'd want to get from the exception...it's not practical for every IO action to explicitly declare what ecxeptions it can throw, and it's also often a lie -- async eceptions can come from *anywhere*
18:15:46 <saurabhnanda> Tekmo: hang on, installing unexceptionalIO
18:15:50 <jle`> that's why EitherT e IO a is considerd an anti-pattern in a lot of situations --- it tries to say that it's an IO action that can error with an error type `e`
18:16:02 <Ankhers> If I have ghc-options: -threaded -rtsopts -with-rtsopts=-N in my cabal file, will that automatically run the application with max cores, or should I still be specifying that manually? 
18:16:03 <jle`> but that's a lie --- it can error with a *lot* more things than just `e`
18:16:11 <jle`> no matter what e you pick, no type will be descriptive enough to handle all possible errors
18:16:25 <jle`> what if you have an out of memory error?  a thread killed error?  an async exception?  a disk error?
18:16:28 <Tekmo> jle`: That's why there is the `unexceptionalio` package
18:16:40 <Tekmo> I think checking all `IO` exceptions is reasonable
18:17:04 <EvanR> jle`: even with a constraint i dont see how that could be implemented
18:17:38 <saurabhnanda> jle`: in this case, the reason I was getting an IO Exception as runtime was because the PID file didn't exist. That's a very common scenario which I ALWAYS want to handle at compile-time. How do I catch FileNotFoundException and "lift" the scenario into the type system?
18:17:43 <EvanR> `Guest00000: instead of try, look at catch, bracket, and finally
18:18:31 <EvanR> also IRL you don't really want to catch SomeException
18:19:10 <jle`> saurabhnanda: you can specifically catch FileNotFoundException using try, and then handle it purely, i suppose
18:19:21 <jle`> try or catch
18:19:56 <jle`> you can use try/catch to catch specific errors, and ignore all other kinds
18:20:26 <andromeda-galaxy> I've got an associated type family for a typeclass that's specialized on a few instances, but want to be able to provide a "default" behavior for (Eq a) types.  Using fundeps for this causes ambiguous functional dependencies (since, IIRC, we don't have any reasonable way of basically combining fundeps and OverlappingInstances) and using associated type familes results in conflicting family instance declarations...
18:22:38 <saurabhnanda> how do I get a list of exceptions that readFile can raise -- http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#t:IOError
18:28:12 <saurabhnanda> I'm in ghci
18:28:13 <saurabhnanda> let x = try $ readFile "/tmp/a"
18:28:22 <saurabhnanda> how do I see the value of x?
18:28:38 <saurabhnanda> show isn't defined for (Show (IO (Either e0 String)))
18:29:06 <Tekmo> andromeda-galaxy: You might want to check this out; it's pretty evil, though: https://github.com/mikeizbicki/ifcxt
18:29:11 <jle`> you have to execute an IO action to get the result
18:29:49 <jle`> try _ <- catch (readFile "/tmp/a") (\e -> show (e :: IOException))
18:30:12 <saurabhnanda> jle`: so, at this point everything is lazy. The IO hasn't happened yet?
18:30:19 <jle`> this is unrelated to laziness
18:30:30 <jle`> an IO action is a description of an action
18:30:38 <Tekmo> saurabhnanda: A value of type `IO` is still just a value
18:30:55 <Tekmo> saurabhnanda: The only way to get an `IO` value to *do* anything is to assign it to `main`
18:31:17 <andromeda-galaxy> Tekmo: thanks, that looks interesting.... I'm not sure if it'll work for this exact use case, but I'll keep it in mind
18:31:40 <shachaf> This is like saying "the only way to get C code to do anything is to put it in main()".
18:32:28 <saurabhnanda> void (readFile "/tmp/a") `catch` (\e -> putStrLn $ "ERROR: " ++ (show (e :: SomeException)))
18:32:34 <saurabhnanda> how do I see the type of e?
18:32:46 <saurabhnanda> I'm trying to get a list of exceptions thrown by readFile
18:32:49 <jle`> typeOf
18:33:14 <saurabhnanda> jle`: which package is it in?
18:33:20 <jle`> oh wait, typeOf won't help, sorry
18:33:36 <saurabhnanda> Data.Typeable?
18:33:46 <jle`> but i can tell you that it's an IOException if the file isn't found
18:33:54 <Tekmo> shachaf: To be pedantic, the difference between Haskell and C is that in Haskell the order of side effects is independent of the order of evaluation (modulo cheating)
18:33:56 <saurabhnanda> right, but WHICH IOException?
18:34:16 <jle`> there's only one IOException type
18:34:19 <EvanR> youll have to look at the source or cause the error
18:34:22 <jle`> oh
18:34:27 <shachaf> That's true but it doesn't have much to do with the main thing.
18:34:29 <jle`> :t GHC.IO.Exception.ioe_type
18:34:30 <lambdabot> IOException -> GHC.IO.Exception.IOErrorType
18:34:31 <saurabhnanda> jle`: for my use-case, I want to make sure that FileNotFoundExceptions are being handled at compile-time
18:34:54 <shachaf> If you want code to be executed when you run the program, in the end, you have to put it in main.
18:35:11 <shachaf> Or in something that main eventually executes.
18:35:20 <shachaf> This is true in Haskell but it's also true in every other language that has main. :-)
18:35:46 <Tekmo> shachaf: Except Python
18:35:47 <jle`> saurabhnanda: and IOErrorType has a bunc of constructors, look at :brwose GHC.IO.Exception to see them all, on ghci
18:35:59 <shachaf> Python doesn't have main.
18:36:13 <Tekmo> shachaf: It does have the morally equivalent `__main__` idiom
18:36:30 <glguy> morals have no place in pedantry
18:36:47 <Tekmo> There's also static initialization blocks in Java
18:37:00 <EvanR> morally correct vs pedantically correct
18:37:44 <saurabhnanda> jle`: so, probably this is what I"m looking for? GHC.IO.Exception.NoSuchThing
18:38:57 <EvanR> these are not the errors youre looking for
18:39:36 <shachaf> If you do I/O in a TH block in Haskell, it'll get executed outside of main too.
18:40:26 <saurabhnanda> EvanR: please explain. I'm trying to "catch" only the file-not-found exception
18:41:53 <EvanR> i dont see it in https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO-Error.html
18:43:13 <saurabhnanda> EvanR: thanks, these seem like publicly accessible predicates, NoSuchThing seems like a private implementation detail
18:43:36 <glguy> isDoesNotExistError :: IOError -> Bool
18:43:44 <EvanR> ah
18:47:35 <k4pod> saurabhnanda: I think you want catchJust. The docs have a pretty good example that does nearly exactly what you want.
19:02:36 <EvanR> is every type automatically Typeable now?
19:08:37 <saurabhnanda> VICTORY: https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs#L209-L211
19:10:32 <saurabhnanda> jle`: thank you for your help
19:10:40 <saurabhnanda> EvanR: thanks for the help
19:10:47 <saurabhnanda> Tekmo: thanks for the help
19:13:06 <saurabhnanda> btw, does that seem right: https://github.com/vacationlabs/nightwatch/blob/master/nightwatch.hs#L209-L211
19:14:51 <k4pod> IO (Either IOError (Maybe Integer)) is a little crazy - what about something like IO (Either MyError Integer)?
19:14:55 <EvanR> its way too complex
19:15:16 <EvanR> but at least you got it to compile
19:18:02 <Bor0_> not sure how that token can be used, but it's not the usual practice to embed it within the code. how about reading it from System.Environment or something
19:22:52 <jle`> saurabhnanda: hm, EitherT doesn't do anything there ...
19:25:38 <jle`> saurabhnanda: you can just use try, and pattern match on Either
19:26:23 <jle`> EitherT is sort of just like redundant noise here, it doesn't help...also, if you ever do use EitherT, use ExceptT from transformers instead, EitherT is deprecated :)
19:27:01 <saurabhnanda> jle`: following doesn't compile -- fmap readMaybe $ tryJust (\e -> if isDoesNotExistError e then (Just e) else Nothing) $ readFile fname
19:27:16 <jle`> pattern match on the either result
19:27:22 <saurabhnanda> jle`: I realized that I'm creating an EitherT just to call runEitherT at the end
19:27:30 <jle`> mhm
19:27:54 <jle`> well, the only difference it makes is that `fmap` works, but fmap might not be the most readable thing here anyways
19:27:59 <jle`> res <- tryJust blah blah
19:28:01 <jle`> case res of
19:28:08 <jle`>   Left _ -> blah blah
19:28:27 <saurabhnanda> can't I fmap a function into the IO (Either IOError  String) space?
19:28:35 <jle`> yes, but you need to double fmap, heh
19:28:44 <jle`> fmap (fmap f)
19:29:04 <saurabhnanda> jle`: or liftIO?
19:29:06 <jle`> the only thing that EitherT adds is you can write fmap readMaybe instead of fmap (fmap readMaybe)
19:29:23 <jle`> liftIO doesn't really do that
19:29:53 <jle`> liftIO doesn't lift functions :O
19:30:02 <jle`> it's a bit unrelated here
19:30:49 <saurabhnanda> so double fmap worked
19:30:57 <saurabhnanda> once to go inside IO and once to go inside Either
19:30:59 <saurabhnanda> right?
19:31:07 <jle`> mhm
19:31:27 <saurabhnanda> mhm?
19:31:32 <jle`> yes :)
19:31:51 <saurabhnanda> http://www.urbandictionary.com/define.php?term=mhm
19:32:18 <jle`> yes, this is how i convorsate
19:32:58 <saurabhnanda> great, thanks. Now let me figure out how to make this readIntegralFromFile :: String -> IO (Either PIDFileError Integer)
19:33:16 <jle`> in that case, ditch fmap, just pattern match :)
19:33:23 <jle`> like what i wrote earlier
19:33:41 <saurabhnanda> data PIDFileError = PIDFileNotFoundError | PIDFileParseError
19:34:23 <Hafydd> saurabhnanda: I suggest that you don't need the "Error" suffix for those constructors.
19:34:28 * hackagebot ghc-imported-from 0.2.1.1 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.2.1.1 (CarloHamalainen)
19:34:32 <Hafydd> Er... well, for the first one, at lest.
19:34:37 <EvanR> saurabhnanda: so as you start to care about all these details you might want to make your own result type
19:34:43 <EvanR> but also, this is really the job of exceptions
19:34:44 <jle`> res <- tryJust blah blah; return (case res of Left _ -> Left PIDFileNotFoundError; Right i -> maybe (Left PIDFileParseError) Right (readMaybe i)
19:35:29 <EvanR> data FileLoadResult = Success Integer | FileNotFound | Huh
19:36:03 <EvanR> and he funcion is String -> IO FileLoadResult
19:36:20 <EvanR> or just -> IO Integer and use exceptions
19:36:37 <EvanR> :t throwIO
19:36:39 <lambdabot> Exception e => e -> IO a
19:42:06 <cestdiego> hello folks
19:42:14 <cestdiego> anyone using NixOS for haskell development?
19:52:48 <k4pod> Interesting FP Complete coding standards document that recommends the use of MonadThrow for error handling thoughts? https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices
20:15:04 <_benj> so they say that this is one of the coolest channels on IRC...
20:15:21 <_benj> cool people and stuff... is it true?
20:15:23 <lingxiao> hey anyone care to join me at #coq?
20:15:30 <lingxiao> i have a couple of questions about the language
20:15:31 <lingxiao> :)
20:16:03 <EvanR> wtf, MonadThrow, MonadError, MonadExcept, MonadCatch
20:16:33 <EvanR> ErrorT, EitherT
20:16:45 <scshunt> EvanR: yep
20:16:53 <scshunt> error handling is a sorry mess
20:17:00 <EvanR> its getting worse
20:17:10 <scshunt> more or less
20:17:30 <_benj> I just have one question
20:17:42 <_benj> I heard that Haskell can compile to JS
20:18:00 <nocturne777> do most projects use classy-prelude these days ?
20:18:01 <EvanR> ExceptT
20:18:15 <_benj> disclamer... I love JS but I'm open to discover new things...
20:18:22 <_benj> would haskell be worth it?
20:18:34 <jle`> nocturne777: i think it's safe to say no, they don't
20:18:37 <jle`> _benj: i think it's worth it :)
20:18:51 <_benj> jle`: why?
20:19:27 <nocturne777> jle`: would you consider using it in a new project ?
20:19:27 <jle`> it's a good language to practically use for several reasons, and it's a good language to learn to help learn a bit more about different ways of thinking
20:20:11 <_benj> let me paint the picture a little clearer
20:20:14 <jle`> nocturne777: i might, but i haven't had too many problems with normal prelude, i don't see myself using it in the future.  i do use specific packages/libraries that classy-prelude exports
20:20:47 <_benj> as a web developer there are a bunch of JS frameworks... would I benefit at all from leraning haskell?
20:20:57 <_benj> I'm not skeptic but curious
20:21:15 <jle`> well, one benefit is that you can *use* haskell to do your front end work, which is already pretty nice :)
20:22:08 <jle`> but haskell can help you learn new ways to structure your js code too, design principles, etc., and take a part in a lot of the new javascript libraries coming out with innovations that came from haskell
20:22:57 <_benj> so you are saying that haskell would sort of a good academic excersise?
20:23:32 <jle`> well, i said two things
20:23:43 <jle`> the good exercise in learning is the second thing
20:24:04 <jle`> haskell as a practical language that gives you a lot of benefits, advantages, etc. is also a pretty big deal
20:24:18 <_benj> yes... I was looking at Yesod... seems interesting
20:24:34 <jle`> and that wouldn't be for "academic exercises", it'd be for building more maintainable, correct software
20:24:48 <jle`> with more powerful abstractions
20:24:56 <jle`> (than possible in javascript)
20:25:15 <jle`> if you ever decide to use haskell for backend work, you also get a lot of performance benefits, too
20:25:46 <jle`> haskell code is the most maintainable, refactorable code in the world
20:25:54 <_benj> ok then, to what resource would you point me to?
20:26:10 <_benj> I'm looking at "Learn You a Haskell for Great Good"
20:26:13 <jle`> @where learnhaskell
20:26:13 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:26:21 <Twernmilt_> Hello, I've been trying to solve this build error for quite a while. This library says that it needs version 7.0.0 of libffi, and as far as I can tell that's what version I have, but it still gets rejected saying I have version 1.0.0
20:26:27 <Twernmilt_> Here is the output from otool and stack build: https://gist.github.com/MichaelBaker/79673ffe6e098fe48416
20:26:28 <jle`> a lot of people have spoken out against Learn you a haskell recently, but
20:26:33 <Twernmilt_> Any advice?
20:28:42 <_benj> jle`: that github link looks interesting
20:28:55 <_benj> I'll take a look, thank jle` !
20:40:34 <nocturne777> jle`: do you think it is a good idea to export commonly used modules such as Control.Applicative, Control.Functor, etc from Types.hs? 
20:40:50 <nocturne777> or is it better to be explicit in each file ?
20:41:19 <geekosaur> Twernmilt_, dunno why but it's seeing the wrong libffi.dylib
20:41:31 <geekosaur> 	/usr/lib/libffi.dylib (compatibility version 1.0.0, current version 1.0.0)
20:42:51 <Twernmilt_> When I have it expand rpath it says it's looking at the correct one.
20:46:58 <Twernmilt_> Well, I replaced the one in /usr/lib and it seems like it might be working. Any idea how I can configure my build to specify which libffi path to use?
20:47:38 <Twernmilt_> I can't figure this out because either the tools are giving me misleading information or I'm misunderstanding the output.
20:47:44 <geekosaur> ... that could well break Apple stuff
20:47:57 <Twernmilt_> I backed up the old one.
20:48:08 <Twernmilt_> I just wanted to prove that you were correct.
20:48:24 <Twernmilt_> Which I have.
20:48:32 <Twernmilt_> So thank you for that.
20:50:12 <geekosaur> unfortunately I don't know enough about what it is doing there. at a guess, it is putting the @rpath-based reference into the executable but not actually adding the RPATH entry properly to the executable, so when run it would only work when run from .stack-work/dist/x86_64-osx/Cabal-1.22.5.0/build/LLVM/General/Internal/
20:50:27 <geekosaur> whereas during the configure step it is likely running it from .stack-work/dist/x86_64-osx/Cabal-1.22.5.0/build
20:51:30 <Twernmilt_> Hmm. I tried using install_name_tool to manually set the rpath, but that didn't seem to help.
20:52:33 <geekosaur> I think at this point I'd be putting DYLD_PRINT_LIBRARIES in the environment
20:52:56 <Twernmilt_> I did DYLD_PRINT_RPATHS
20:53:00 <Twernmilt_> Which told me: RPATH successful expansion of @rpath/libffi.dylib to: /Users/michaeltbaker/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/bin/../rts/libffi.dylib
20:53:05 <geekosaur> but debugging these things is annoying and it's far too easy to gets tuff wrong (there was at least one Platform release with the wrong rpath info so it couldn't find any of its libraries)
20:53:07 <Twernmilt_> Which is why I thought it was using the correct version.
20:54:33 <geekosaur> yes, but the message after implies that that was while making Setup, not while making LibraryFunction_hsc_make
20:55:03 <Twernmilt_> Ah, ok, let me try that.
20:57:16 <Twernmilt_> Ok, so DYLD_PRINT_LIBRARIES correctly showed me that it's getting libffi from /usr/lib
20:57:41 <Twernmilt_> So that finally makes sense.
20:58:05 <Twernmilt_> Now the question is how can I configure it correctly.
20:58:11 <geekosaur> unfortunately I dont know where to go from here because I have no idea at what point LibraryFunction_hsc_make is built much less how to force it to have the right RPATH loader command
20:58:26 <Twernmilt_> Gottcha
20:58:39 <Twernmilt_> Well thanks for getting me this far.
20:58:41 <geekosaur> and I ca't go digging into the llvm-general build right now
20:59:12 <Twernmilt_> Sure, no problem.
21:01:16 <shachaf> So in the actual Hask category (with bottoms), every type has the fixed point property.
21:01:47 <shachaf> Very different from Set.
21:01:55 <shachaf> I guess the rest of the discussion should go in #-blah.
21:13:16 <wolfcub> is there any way to integrate haskell into V$?
21:17:04 <Twernmilt_> For the record, building with DYLD_LIBRARY_PATH=<path to directory with libffi.dylib> solved my problem. I don't know if that's a good solution or not though.
21:25:47 <EvanR> wolfcub: through FFI
21:27:48 <wolfcub> thanks EvanR, will look into it
21:30:19 <wolfcub> hm.. what i meant is, use visual studio as a haskell interface, tho its also nice to know how to interface c++ and haskell
21:30:30 <wolfcub> as a haskell IDE*
21:39:01 <_benj> @where learnhaskell
21:39:01 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:43:36 <lethjakman-l> This type signature is really confusing me: https://gist.github.com/lethjakman/149303d7ca1329c37ad9
21:43:58 <lethjakman-l> I'm returning the second part of it, but it's supposed to be a MForm with two values, right?
21:44:13 <lethjakman-l> Where is the first value coming from?
21:44:33 <lethjakman-l> The reason I'm asking is that Auth is actually an App and I can't seem to figure out why. 
21:50:27 <Chobbes> When working with Accelerate are you supposed to create instances of Elt? https://hackage.haskell.org/package/accelerate-0.15.0.0/docs/Data-Array-Accelerate.html#t:Elt
21:50:57 <Chobbes> It seems that way, but I also can't find the documentation for it, so I'm not sure what all of the methods are supposed to be?
22:02:30 <peddie> Chobbes: usually if it doesn't export the methods of the class, it's because you aren't meant to make your own instances
22:19:53 <pdxleif> Is gitlib the preferred method for working w/ git from Haskell? The docs (that I could find) all seem bitrotted
22:29:33 <pdxleif> Here's what I've been able to figure out of its API so far: https://gist.github.com/LeifW/f973c0b7f123a5d94306
22:49:43 * hackagebot gore-and-ash 1.1.0.1 - Core of FRP game engine called Gore&Ash  https://hackage.haskell.org/package/gore-and-ash-1.1.0.1 (NCrashed)
23:21:55 <jle`> it's slightly bitrotted but it seems fairly comprehensive
23:22:02 <jle`> or well, the documentation is, at least
23:22:07 <jle`> but the library itself is in active development
23:22:31 <jle`> i think the library works well, but there are some more 'one-off' git libraries, like libgit, but i've run into some bugs with that when using it
23:23:00 <jle`> gitlib sems to do the job pretty well and is actively maintained/developed (as of the past few months at least), but that's as far as i know
23:24:44 * hackagebot gore-and-ash-logging 1.1.0.0 - Core module for gore-and-ash with logging utilities  https://hackage.haskell.org/package/gore-and-ash-logging-1.1.0.0 (NCrashed)
23:29:45 * hackagebot gore-and-ash-sdl 1.1.0.0 - Gore&Ash core module for integration with SDL library  https://hackage.haskell.org/package/gore-and-ash-sdl-1.1.0.0 (NCrashed)
23:29:47 * hackagebot gore-and-ash-actor 1.1.0.0 - Gore&Ash engine extension that implements actor style of programming  https://hackage.haskell.org/package/gore-and-ash-actor-1.1.0.0 (NCrashed)
23:54:45 * hackagebot gore-and-ash-network 1.1.0.0 - Core module for Gore&Ash engine with low level network API  https://hackage.haskell.org/package/gore-and-ash-network-1.1.0.0 (NCrashed)
