00:03:39 <koz_> How can I tell Cabal that 'cabal clean' needs to remove more files?
00:07:39 * hackagebot hspec 2.2.2 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.2.2 (SimonHengel)
00:07:39 * hackagebot lens 4.13.1 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.13.1 (EdwardKmett)
00:07:51 <pavonia> koz_: What files, from where?
00:17:34 * hackagebot configurator-export 0.1.0.0 - Pretty printer and exporter for configurations from  the "configurator" library.  https://hackage.haskell.org/package/configurator-export-0.1.0.0 (jle)
00:27:50 <koz_> pavonia: I have a .html that I build from a .md using some Haskell code in my project. I want 'cabal clean' to remove the .html if it's there.
00:31:30 <pavonia> koz_: There seems to be extra-tmp-files
00:33:27 <koz_> pavonia: Thanks!
00:35:59 <koz_> pavonia: Do you happen to know if GHC has an option similar to -Os in GCC (i.e. optimize for small binaries)?
00:36:33 <pavonia> I don't know, sorry
00:36:47 <koz_> pavonia: Figured I'd try asking. :)
00:41:07 <Lokathor> pandoc handles every format under the sun it seems
00:41:12 <Lokathor> but not RTF
00:41:38 <koz_> Lokathor: Are you the same Lokathor who hangs out on TGD sometimes?
00:41:43 <Lokathor> yes
00:41:48 <Lokathor> for whatever reason, it can write RTF, but not read RTF
00:41:51 <koz_> In that case, hai!
00:42:01 <koz_> Lokathor: That *is* a rather bizarre asymmetry.
00:42:13 <koz_> Might be worth asking its maintainers what's up with that.
00:42:14 <Lokathor> guess what the SRD's native format is :P
00:42:24 <koz_> Lokathor: Why am I not even *remotely* surprised...
00:42:34 <koz_> Well, assuming you don't wanna HTML-strip the SRD.
00:42:59 <Lokathor> I have latex forms for most of it, so i can use panoc to get latex->markdown
00:42:59 <koz_> And that's a kind of soup I'd not wish on my worst enemy.
00:43:38 <Lokathor> my new target format is markdown, https://www.gitbook.com/book/lokathor/supertome/details
00:43:50 <koz_> Lokathor: An interesting choice.
00:44:21 <Lokathor> not as refined as using latex to make a PDF, but gitbook shows up far better on mobile devices, which i value greatly when at the game table
00:44:53 <koz_> Lokathor: LaTeX can be compiled into epubs with minimal effort, provided you don't mind some Calibre in your toolchain.
00:45:06 <koz_> But yeah, I hear you on the mobile devices thing.
00:45:31 <Lokathor> gitbook makes the epub and PDF version as well for you with every repo push
00:45:46 <koz_> Ah, fair enough. I assume that uses Github-flavoured Markdown?
00:45:50 <Lokathor> yep
00:46:19 <Lokathor> other than the fact that inter-linking is a little more verbose, it's servicable for a game reference
00:46:43 <koz_> Lokathor: You could just write some code to autogen links and spew the resulting Markdown if it's too much of a pain manually.
00:47:28 <Lokathor> it's just that i have to remember where a link is going. In latex you can declare the ref you want to link to, and the compiler figures what page that ref is on
00:47:39 <Lokathor> and you can hide it all behind nice macros too
00:47:45 <koz_> Ah, I see.
00:47:51 <koz_> Well, LaTeX is ridiculously extensible.
00:48:04 <koz_> As the huge number of packages for it evidence.
00:48:05 <Lokathor> so you write something like \linkskill{apprise} instead of [Appraise](skills/appraise.md)
00:49:40 <koz_> Well, if Markdown works for you, and makes a better book, so much the better, really.
00:50:47 <koz_> I'm just setting up a project of mine to render some Markdown using a Haskell helper script. It's amazing to write that in like, 3 lines. :P
00:52:09 <Lokathor> well the beauty of pandoc would be that, if markdown ends up not working out, i can convert most of the markdown back to latex relatively quickly
00:52:20 <koz_> Yes indeed.
01:05:06 <Adeon> can STM 'atomically' block be interrupted by asynchronous exception inside mask if I can guarantee nothing will invoke retry in that block
01:05:20 <Adeon> I would say no but I'm not 100% sure
01:08:08 <Lokathor> Adeon, i don't know for sure, but i think the idea is that exception happens either before or after the atomically block actually fires
01:08:12 <Adeon> I know there was a list somewhere that can be interrupted but I can't remember if that was in user guide or somethere in base docs
01:08:15 <Lokathor> not during
01:08:52 <Adeon> I'm interested in the case where I have mask_ $ something >> atomically blah >> more
01:09:07 <Adeon> I expect that it's guaranteed I run 'something' and 'more' if I don't 'retry' inside 'blah'
01:09:22 <Adeon> that is, even if someone is trying to 'throwTo' to my thread in the middle of something
01:10:11 <Lokathor> if the STM action is sure to never retry, it's kinda like any other IO action at that point i guess, so the normal "you're in a mask" rules apply
01:10:13 <Adeon> ah, found the list of interruptible things
01:10:29 <Lokathor> oh, please do link. i should also bookmark such a list
01:10:31 <Adeon> "STM transactions that do not use retry" are in the list
01:10:41 <Adeon> https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception.html search for "interruptible operations"
01:11:15 <Adeon> er, technically NOT interruptible things
01:13:15 <Lokathor> so your'e safe
01:13:19 <Adeon> yep
01:22:48 <SusWombat> Hey everyone
01:25:58 <SusWombat> learnyouahaskell is a good first learning ressource right?
01:26:20 <plazmonii> SusWombat: yep
01:26:39 <kadoban> SusWombat: No. It crucially lacks exercises and doesn't actually teach you to program, practically.
01:26:40 <Lokathor> SusWombat, nope nope nope
01:26:59 <schaurian> help
01:27:12 <Lokathor> http://www.seas.upenn.edu/~cis194/spring13/lectures.html start here. it will say to read LYAH, but it will also give you homework problems to work on
01:28:17 <SusWombat> kadoban, ok thanks
01:28:27 <SusWombat> Lokathor, Thanks *
01:28:39 <SusWombat> plazmonii, also thjanks :D
01:29:34 <Adeon> is LYAH no longer considered good starting resource?
01:29:57 <SusWombat> Also propably supid question .... Do i need to be good in "math"? 
01:29:58 <Lokathor> cis194 has you read parts of LYAH, but LYAH does not stand on its own
01:30:13 <Adeon> you don't need to be good at math
01:30:16 <kadoban> SusWombat: No, not particularly.
01:30:22 <Lokathor> SusWombat, nope, no special math skills required, beyond the normal "think logically to solve problems" that all programming needs
01:30:31 <SusWombat> Okay thanks
01:30:33 <Adeon> well if your program is about mathematics then you might need
01:30:37 <Adeon> some
01:30:37 <SusWombat> :D
01:30:54 <Freundlich> Lokathor: Isn't that what being "good at math" is all about?
01:31:02 <plazmonii> kadoban: Lokathor why nope
01:31:13 <plazmonii> I find it quite good at least for start
01:31:28 <plazmonii> as in introduces the specifics in a nice way
01:31:43 <plazmonii> of course you'll need other exercises 
01:31:48 <Lokathor> Freundlich, math is a particular sub-kind of logical thinking that takes extra background knowledge about equational rules and such
01:32:19 <SusWombat> maybe i should have said "complex math stuff"
01:32:33 <plazmonii> Lokathor: that looks nice
01:32:39 <plazmonii> the course
01:32:40 <Lokathor> plazmonii, http://bitemyapp.com/posts/2014-12-31-functional-education.html covers most of what i'd say about LYAH
01:33:03 <kadoban> plazmonii: I mentioned why. "other exercises" isn't a trivial problem that a beginner can just say "oh I'll go find exercises now", both because learners don't typcially do that, they read the book they're reading, but also because figuring out what exercises are useful at a certain point is going to be basically impossible for a beginner.
01:34:10 <kadoban> plazmonii: So even if a go-getter goes out there and tries finding exercises, odds are good they'll get frustrated because what they try to do isn't appropriate from what they've learned, and they'll just give up. Or they'll do really easy stuff that doesn't teach them anything and they'll get stuck later.
01:35:06 <plazmonii> Lokathor: right, I haven't yet started with functors and monads
01:35:14 <plazmonii> so, I guess, you're right
01:35:39 <kadoban> You don't teach someone programming by having them read a bunch of stuff and not program. They must actually solve problems themselves, use what they're being taught, etc.
01:36:07 <Adeon> the first program I tried to do in haskell was chess
01:36:10 <plazmonii> yes, but introduces the idea and makes, imho, good analogies
01:36:10 <Adeon> it didn't quite work out
01:36:18 <SusWombat> Im not 100% new to programming. But i guess haskell is going to be something completely new
01:36:48 <plazmonii> what do you mean by new? SusWombat 
01:37:08 <SusWombat> plazmonii, all this pure functional stuff i mean
01:37:21 <plazmonii> I don't think it's new, is it
01:37:27 <plazmonii> or define new, ofc
01:37:48 <plazmonii> as in if you mean the last 5 years, then perhaps yes
01:39:36 <plazmonii> I'm not aware of haskell's history 
01:39:57 <plazmonii> or functional progrmming 
01:40:03 <plazmonii> oerall
01:40:29 <plazmonii> so why I' typing, well trying to find someone that can oppose me and actually point it out
01:40:55 <SusWombat> plazmonii, i meant new to me
01:40:56 <plazmonii> ain't no tiem for reading about that right now
01:40:59 <kadoban> plazmonii: Well, haskell is well over 20 years old. Functional programming itself is old as sin.
01:41:01 <plazmonii> ah, irght
01:41:20 <SusWombat> plazmonii, sry if i was unclear on that im not a native englishe speaker
01:41:22 <plazmonii> je, I know it derives from haskell curry
01:41:24 <plazmonii> in a way
01:42:00 <plazmonii> SusWombat: no problem, sometimes I need very little to get confused :-)
01:42:35 <SusWombat> plazmonii, :D
01:43:40 <plazmonii> SusWombat: you can do procedural programming in haskell as well if dealing with IO, afaik
01:43:46 <plazmonii> but otherwise it makes no sense
01:45:19 <SusWombat> plazmonii, im not aiming too :D Firstly i just want to get a picture of haskell :) Im a noob in programming but i understand the "basics" i think (im bad at rating my "knowledge"). So atm i just to see whats haskell about and how i do like pure functional programming.
01:46:01 <SusWombat> Is haskell a "general purpose" language?
01:47:33 <pavonia> Yes
01:47:44 <SusWombat> Thats cool
01:48:24 <SusWombat> Also the haskell logo is Very nice
01:49:07 <SusWombat> brb
01:51:24 <SusWombat> back
01:52:37 * hackagebot effect-handlers 0.1.0.7 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  https://hackage.haskell.org/package/effect-handlers-0.1.0.7 (edofic)
01:52:45 <plazmonii> SusWombat: haskell logo is operator
01:52:48 <plazmonii> in haskell
02:01:27 <diggle> So reading some stuff, I see it's not really advisable to install hp...so if not, should I get barebones ghc or get the stackage package?
02:03:19 <SusWombat> diggle, could you elaborate wgy its not advisable? Cause im at the poinmt i would need an compiler and LYAH recommends HP
02:03:55 <plazmonii> SusWombat++
02:03:56 <diggle> https://mail.haskell.org/pipermail/haskell-community/2015-September/000014.html
02:05:35 <SusWombat> diggle, thx
02:14:38 <ph88> anyone know how i can get this derive to work?  http://lpaste.net/388805651091947520
02:25:12 <jle`> SusWombat: the stackage home page lists a few reasons why it's not advisable
02:25:23 <jle`> in general people recommend against HP these days
02:25:52 <jle`> diggle: getting `stack` should just be fine :)  it can install ghc for you
02:26:50 <SusWombat> jle`, okay. I just installed ghc for now
02:27:06 <jle`> hm, how did you install ghc?
02:27:17 <SusWombat> jle`, my linux distros packagemanager
02:27:30 <jle`> ah; there's a good chance that it's very out of date
02:27:35 <jle`> what is ghc -v ?
02:27:40 <SusWombat> GHCi, version 7.10.3
02:27:44 <jle`> oh nice
02:27:48 <SusWombat> oh wait thats ghci 
02:27:49 <jle`> what distro do you use?
02:27:54 <SusWombat> jle`, arch
02:28:12 <jle`> that's cool that they are up to date
02:28:18 <jle`> but oyu'll run into problems as soon as you want to install any packages
02:28:35 <wedens> what library can I use for terminal UI?
02:28:48 <Adeon> 'ansi-terminal'
02:29:07 <Adeon> it gives you color and stuff but not many UI elements if you are looking for that
02:29:16 <SusWombat> jle`, isnt that what "cabal" and this cabal sandboxes are for?
02:29:21 <Adeon> but if you just want to give colored terminal output ansi-terminal can do that for you
02:29:40 <SusWombat> jle`, im just starting to learn haskell sry
02:30:06 <wedens> Adeon: I want some ncurses-like ui
02:30:29 <Adeon> then I'm not sure if there are any packages
02:30:36 <SusWombat> jle`, so should i just choose stack?
02:30:38 <Adeon> there is at least package called 'ncurses' if you to use the actual ncurses
02:30:40 <jle`> SusWombat: yeah, but the interface to the cabal utility w/ sandboxes isn't too clean and can be cumbersome to use sometimes, and it's fairly easy to mess things up
02:30:53 <wedens> Adeon: there are many, but I know nothing about them
02:31:09 <jle`> as in, accidentally ruin the state of your global packages/local packages
02:31:32 <wedens> Adeon: brick, vty-ui, ncurses, etc
02:31:35 <SusWombat> jle`, so stack?
02:31:41 <jle`> SusWombat: i'd recommend stack :)
02:31:54 <jle`> but it's not a huge deal for now
02:32:05 <jle`> it's just that it's pretty easy to get stack and set up ghc, so there isn't too much reason not to
02:33:18 <SusWombat> wow it has alot of dependencies :D
02:33:23 <sanotehu> what does the (..) mean in `import package (something(..))'?
02:33:25 <SusWombat> Atleast the package imn installing
02:33:49 <sanotehu> it seems to be needed for something I'm doing, and my code is working now, but I don't understand what it's doing
02:33:55 <wedens> sanotehu: import all constructors of 'something'
02:34:36 <sanotehu> why would I need it to access an infix operator?
02:35:32 <sanotehu> infix constructor?
02:35:36 <wedens> operator can be constructor
02:35:40 <jle`> you need it to access the constructor
02:35:50 <sanotehu> makes sense now, thanks
02:35:51 <jle`> an infix constructor is a constructor :O
02:37:26 <wedens> "The abbreviated form T(..) names the type and all its constructors and field names that are currently in scope (whether qualified or not)." from haskell2010 report
03:09:37 <badmash> hello there
03:11:27 <badmash> are function compositions tail recursive? 
03:13:40 <badmash> if you have, say, some function f, and it calls itself recursively like this -- f . g . h -- is this tail recursive?
03:15:43 <badmash> appreciate any help
03:17:02 <Freundlich> By this definition it is: https://wiki.haskell.org/Tail_recursion
03:18:33 <badmash> Freundlich: yeah, i read that page, but i didn't see that it says some thing like f . g . h is tail recursive.  have i missed something?
03:19:11 <ReinH> badmash: why do you want to know?
03:20:03 <badmash> ReinH: if you have, say, some function f, and it calls itself recursively like this -- f . g . h -- is this tail recursive?
03:20:14 <ReinH> Yes, I heard you.
03:20:58 <badmash> ReinH: i read the link https://wiki.haskell.org/Tail_recursion, but i am still not clear about it
03:21:02 <Freundlich> I think I was wrong. f is actually a parameter to (.).
03:21:59 <Freundlich> If f occurs on any right-hand side of an application, then it's not tail-recursive.
03:22:03 <badmash> Freundlich: i think something like f . g . h isn't tail recursive, but i want to confirm
03:22:32 <Freundlich> The page only talks about applications "t0 t1". You can rewrite f . g . h in prefix notation.
03:22:43 <badmash> Freundlich: yes
03:22:59 <Freundlich> Then (.) is on the left-hand side and f somewhere in the right-hand side.
03:23:05 <badmash> yes
03:23:10 <Adeon> x = compose f (compose g h)
03:23:43 <badmash> Adeon: so thisn't tail recursive, i suppose?
03:23:47 <Adeon> I'm not actually sure
03:23:51 <Adeon> I don't even think about these things
03:23:58 <badmash> i see
03:24:01 <Adeon> I think because of laziness and stuff tail recursiveness may not be so obvious
03:24:06 <ReinH> what function specifically are you asking about?
03:24:17 <ReinH> tail recursion doesn't matter very much in Haskell
03:24:18 <Adeon> O
03:24:23 <badmash> Adeon: why is that? i am not fully clear on it
03:24:24 <Adeon> er, oops
03:24:29 <Adeon> me neither really
03:24:48 <badmash> ReinH: why does tail recursion not matter in haskell?
03:25:07 <badmash> GHC does tail optimisation, as far as i know
03:25:12 <ReinH> No, it does not.
03:25:34 <ReinH> GHC does leftmost outermost redex reducton
03:25:41 <ReinH> on all calls, recursive or otherwise
03:26:17 <ReinH> GHC does not have a call stack to optimize via TCO
03:26:34 <badmash> ReinH: for example, see https://www.reddit.com/comments/6xnk5/ive_got_two_weeks_of_vacation_coming_up_should_i/c055b9w
03:26:44 <Freundlich> Tail recursion isn't very useful in a call-by-name model.
03:27:04 <badmash> ReinH: don stewart talks there about GHC doing tail recursion
03:27:18 <badmash> i am sorry, tail optimization
03:28:56 <ReinH> Yes, ghc does leftmost outermost redex reducion
03:29:05 <ReinH> it does not have a call stack to optimize via TCO
03:29:37 <badmash> ReinH: the link i psted seems to say otherwise; have i misunderstood something?
03:29:58 <ReinH> dons says this a lot, and I think it's misleading
03:30:18 <badmash> ReinH: i see
03:30:40 <ReinH> He talks about "stack-free" direct jumps, but he neglects to mention what stack he's talking about
03:31:02 <ReinH> This might lead someone to believe that GHC is performing TCO to avoid allocating frames on a call stack
03:31:08 <ReinH> as is what is usually meant by TCO
03:31:14 <ReinH> this is not happening because GHC does not have a call stack
03:31:33 <badmash> ReinH: yes, so even thunk evaluation does not happen on a stack?
03:31:57 <ReinH> There is a stack
03:32:00 <ReinH> It is not a call staack.
03:32:09 <badmash> ReinH: i see
03:32:25 <ReinH> GHC performs a "loopification optimization" on things like dons's "go"
03:32:50 <badmash> ReinH: but thunk evaluationshould be happening in some multiple stack frames, something like a recursive call, right?
03:33:20 <ReinH> The stack in GHC is a "pattern matching" stack, used for evaluation.
03:33:56 <badmash> ReinH: but is it fundamentally different from a call stack? 
03:34:23 <badmash> ReinH: you could still run out of space in stack in thunk evaluation, right?
03:34:44 <ReinH> Yes, it is fundamentally different from a call stack
03:35:36 <badmash> ReinH: could you elaborate?
03:42:10 <saurabhnanda> hi, I'm trying to wrap-up my telegram bot. Written in Haskell. For a weekend hackathon. I'm stuck at writing a function which has the following signature fn IO [(String, String)
03:42:19 <ReinH> GHC is based on an abstract machine called the STG machine, short for Spineless Tagless G-Machine.
03:42:33 <saurabhnanda> sorry, fn IO [(String, String)] -> IO (String)
03:42:46 <ReinH> badmash: the STG stack stores function arguments and continuations
03:43:20 <ReinH> i.e., the stack frames which are executed when a function returns
03:43:26 <saurabhnanda> here's where i'm stuck: http://lpaste.net/149847
03:43:30 <saurabhnanda> can anyone please help me
03:43:40 <badmash> ReinH: i see
03:44:01 <saurabhnanda> the input is basically a key-value pair of the type [(String, String)] which I need to convert a single String
03:45:04 <badmash> ReinH: so regardless of whether you have tail recursion or not, GHC uses the same model for computation?
03:45:08 <ReinH> badmash: the particular variant of STG machine currently used by GHC is called eval/apply and is described at http://research.microsoft.com/en-us/um/people/simonpj/Papers/eval-apply/eval-apply.ps
03:45:39 <badmash> ReinH: thanks, i will check it out
03:47:43 <ReinH> badmash: by the time the optimization dons is talking about occurs, Haskell has been compiled into Core, which has been compiled into STG, which is now being compiled into Cmm. At this point, everything as been transformed into continuation passing style. Loopification happens at this point, and turns recursive calls into goto statements.
03:47:54 <ReinH> The optimization is described in detail in http://research.microsoft.com/en-us/um/people/simonpj/tmp/wos-diss-draft.pdf
03:48:38 <badmash> ReinH: i see
03:48:40 <ReinH> I suppose you can call this tail call optimization, and it's obviousl. yimportant that GHC is able to optimize loops into jumps.
03:49:21 <saurabhnanda> kinda stuck with the problem.
03:49:38 <ReinH> the thing that specifically annoys me about calling it TCO
03:49:52 <ReinH> is that just transforming the recursive call into a jump doesn't actually do anything
03:50:02 <badmash> ReinH: i see
03:50:13 <ReinH> the resulting assembly with and without this particular transformation would be basically the same
03:50:27 <saurabhnanda> help would be appreciated. anyone with a better knowledge of monads than me ?
03:50:36 <badmash> ReinH: some people -- i read Brent Yorgey -- talks about guarded recursion -- what exactly is that?
03:50:38 <ReinH> more work has to be done to actually make this optimization beneficial
03:50:54 <ReinH> > head $ foldr (:) [] [1..]
03:50:56 <lambdabot>  1
03:51:20 <ReinH> under evaluation, the recursive call to foldr is *guarded* by the (:) constructor
03:51:25 <ReinH> @src foldr
03:51:25 <lambdabot> foldr f z []     = z
03:51:25 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:51:44 <ReinH> foldr (:) [] (x:xs) = x : foldr (:) [] xs
03:51:55 <badmash> ReinH: i see
03:52:27 <badmash> ReinH: so how is this guarded recursion beneficial?
03:52:38 <ReinH> A pattern match that doesn't scrutinize the tail of the list won't evaluate the rest of the recursion
03:52:43 <ReinH> @src head
03:52:43 <lambdabot> head (x:_) = x
03:52:43 <lambdabot> head []    = undefined
03:52:48 * hackagebot set-cover 0.0.7 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  https://hackage.haskell.org/package/set-cover-0.0.7 (HenningThielemann)
03:53:29 <badmash> ReinH: so this is helpful in lazy evaluation, i suppose
03:53:35 <ReinH> yes
03:54:27 <badmash> ReinH: shouldn't this kind of thing apply in general to all data constructors?
03:54:36 <ReinH> Yes, it does.
03:54:42 <badmash> ReinH: i see
03:56:30 <badmash> ReinH: one other question i had regarding lazy evaluation
03:57:17 <badmash> something like f . g . h where f, g, h are functions -- are function compositions too lazily evaluated?
03:57:44 <ReinH> Yes.
03:57:50 <MarcelineVQ> saurabhnanda: the function itself doesn't use any IO so I'd probably change the signature to `aria2StatusToString :: [(String, String)] -> String` then it's simpler to work with and you'd be able to just write something like: `aria2StatusToString = concatMap (\(k,v) -> k ++ ": " ++ v)`
03:58:22 <ReinH> Evaluation is driven by case scrutinization
03:58:37 <ReinH> so pattern matching and case stataements (which are equivalent)
03:59:17 <saurabhnanda> MarcelineVQ: thanks a lot. The function which calls this particular function, obtains the [(String, String)] value bound to an  IO Monad. How do I "take it out of the IO Monad" before passing it to this function?
03:59:48 <badmash> ReinH: so in this case, f . g . h would be evaluated only during the actual function application? 
03:59:59 <ReinH> Yes.
04:00:17 <ReinH> > let x = undefined . undefined . undefined in 1
04:00:19 <lambdabot>  1
04:00:30 <ReinH> nothing demands x
04:00:44 <badmash> ReinH: i see
04:02:01 <MarcelineVQ> You can fmap to it, like you already were trying to do here but where it's being called instead. By using fmap to apply this function you don't need to get the value out, you're sending the function in. Does that make sense at all?
04:02:07 <badmash> ReinH: but what about the actual creation of the function composition itself -- i mean f . g . h -- this too is delayed until function application?
04:02:53 <ReinH> Yes, a thunk is placed on the heap that represents f . g . h. At some point it may be evaluated.
04:03:28 <badmash> ReinH: i see
04:03:37 <ReinH> badmash: here's a nice explanation of the heap and thunks (including cute cartoons) http://blog.ezyang.com/2011/04/the-haskell-heap/
04:04:25 <badmash> ReinH: thanks ... i read through it casually before, but i will take a closer look
04:05:02 <MarcelineVQ> saurabhnanda: I'm not very good at writing examples like the other people here so if it doesn't make sense lpaste/link your code where you're using aria2StatusToString and we'll work from there
04:05:44 <saurabhnanda> MarcelineVQ: thanks for the tip. it seemed to have work. Let me try it now
04:07:04 <badmash> ReinH: one quick clarification -- when GHC runs out space during huge thunk evaluation, that's basically a stack overflow, right?
04:08:07 <ReinH> yes, the stack is used for evaluation.
04:08:11 <ReinH> @where lazy
04:08:11 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
04:08:25 <ReinH> Is an excellent read on lazy evaluation
04:08:55 <badmash> ReinH: thanks
04:10:27 <Black0range> Hey guys, whats a good name for a class of data that can both be encoded and decoded?
04:10:41 <Black0range> such as URL Encoding 
04:10:58 <badmash> ReinH: haskell is quite interesting to learn ... unlike other languages, you have to dig in and understand a lot of things, which i find very cool
04:11:22 <ReinH> Black0range: cereal uses Serialize, binary uses Binary
04:11:37 <ReinH> badmash: well, you don't have to understand all of this to write haskell
04:11:42 <ReinH> but it is pretty cool
04:12:49 <badmash> ReinH: thanks a lot for your time.  you cleared up a lot of things for me, and pointed me to some great papers and articles.  thanks a bunch, indeed.
04:13:22 <ReinH> badmash: yw
04:14:02 <Phyx-> ReinH: hmm useful link!
04:29:32 <nut_> i have a cabal sandbox in /path1, now i create a new project which i'd like to use /path1 sandbox, how to do that?
04:30:09 <nut_> cabal sandbox --sandbox /path1 ?
04:31:45 <ReinH> cabal sandbox init --sandbox /path1
04:31:48 <ReinH> iirc
04:33:41 <pavonia> Bah, packages misusing show for pretty-printing are so annoying :S
04:35:27 <ph88> anyone know how i can get this derive to work?  http://lpaste.net/388805651091947520
04:36:47 <nut_> ReinH, will this command contaminate /path1 /
04:36:49 <nut_> ?
04:39:36 <maerwald> pavonia: why is that? I think it's fine as long as (read . show) works
04:39:58 <nut_> ReinH, ok i just did that. but when i build, it still can't use the packages already installed in /path1
04:40:07 <Franciman> Hello
04:40:17 <Franciman> What is the most mature GUI lib for haskell?
04:40:28 <maerwald> none, they are all bindings
04:40:39 <maerwald> there are bindings to gtk+ and qt
04:41:17 <pavonia> maerwald: Beacause it makes debugging extra hard when you don't see the actual Haskell result of a a function but some "user-firendly" format
04:41:32 <maerwald> pavonia: you mean it hides information?
04:41:43 <pavonia> Yes
04:41:53 <maerwald> then (read . show) doesn't hold I guess
04:41:56 <maerwald> but that's another thing
04:42:47 <Franciman> maerwald, then, what's the most mature binding?
04:43:21 <pavonia> maerwald: There isn't even a Read instance
04:44:03 <maerwald> Franciman: there are not different bindings for the same library last I checked so your decision isn't haskell specific
04:44:48 <maerwald> you may also want to check https://wiki.haskell.org/Applications_and_libraries/GUI_libraries
04:45:00 <maerwald> but a lot of those are not really mature
04:45:52 <maerwald> so you pretty much end up using those from the "Medium-level" section
04:46:21 <maerwald> which boils down to: gtk bindings, qt bindings or wxwidgets bindings
04:46:37 <maerwald> GUI programming in haskell is not nice
04:47:02 <Franciman> I see, ok thanks
04:51:16 <castlelore> how about for 3d graphics
04:52:37 <jgt> nooby question: I have a simple Yesod app running on EC2. When I visit mysite.com, it redirects to www.mysite.com. How do I have it the other way around?
04:52:46 <jgt> does Warp have something for this?
04:55:39 <maerwald> castlelore: you mean like opengl? those are just bindings as well
04:57:28 <maerwald> creating a high-level haskell API around such a powerful library isn't really trivial. Creating one from scratch is even harder and certainly not going to happen
05:04:31 <hsk3> Can a program ever have a function like this?
05:04:32 <hsk3> f :: (a -> b) -> b
05:05:09 <hsk3> Does there exist an implemention of f?
05:05:54 <ggole> Other than undefined, no
05:06:02 <hsk3> ok thanks
05:06:02 <Ferdirand> f g = g undefined
05:06:23 <Ferdirand> if g is not strict in its argument, it is distinguishable from undefined
05:07:47 <ggole> Good point
05:09:01 <t0by> hsk3, ggole, wait
05:09:21 <t0by> oh nevermind
05:09:23 <t0by> brainfarted
05:09:29 <efkf> has anyone gotten haskell-mode and stack to play nice together?
05:12:51 <hsk3> ggole, Ferdirand, what about   f :: ((a -> b) -> c) -> c   ?
05:13:04 <hsk3> I guess it's same
05:13:13 <hsk3> Only possible using   f g = g undefined   where g has the correct type?
05:14:42 <Ferdirand> any implementation of forall a,b: (a -> b) -> b should also be valid for forall a,b,c: ((a -> c) -> b) -> b, i think
05:15:20 <mauke> g (const undefined)
05:15:27 <Ferdirand> yeah, that
05:16:30 <hsk3> mauke: what's const?
05:16:56 <ggole> @src const
05:16:57 <lambdabot> const x _ = x
05:17:17 <ggole> Or perhaps more intuitively:
05:17:23 <ggole> >map (const 0) [1,2,3]
05:17:58 <ggole> Oh, do I need the space?
05:18:08 <ggole> > map (const 0) [1,2,3]
05:18:10 <lambdabot>  [0,0,0]
05:24:13 <danilo2> Hello guys! I've got a VERY strange GHC / HS issue here. Namely I've got a very complex typeclass (class Foo a where foo :: a -> String) which resolves for a given argument type (like Int) during compilation in 10 seconds. I've got a function (foo' :: Int -> String; foo' = foo) which compiles these 10 seconds BUT when I use it, every use of foo' takes additional 1 - 2 seconds during compilation
05:24:39 <danilo2> How it could be possible? I've put NOINLINE pragma on foo', it is fully typed, still when I use it, the compilation time increases lineary
05:27:11 <felixonmars> hi all. the current version of mono-traversable doesn't build with comonad 5. i have tried to remove all references to the removed Coproduct functor, and it builds after the change. how can i check if the other modules i have didn't make use of them? the three lines are "type instance Element (Coproduct f g a) = a" "instance (Functor f, Functor g) => MonoFunctor (Coproduct f g a)" and "instance (Comonad f, Comonad g) => MonoComonad 
05:28:28 <Wizek> With stack, is it possible to build+run the whole project? `stack runghc` looks like it only tries to run a single .hs file. IIRC `cabal run` ran the whole project as it was set up.
05:30:09 <danilo2> Wizel: stack exec <execname>
05:32:05 <Wizek> danilo2, do you mean like this? `stack build && stack exec <bin-name>`?
05:32:30 <danilo2> Wizek: eactl
05:32:37 <danilo2> Wizek: exactly
05:33:56 <Wizek> I see. I guess that's still quite a bit better than `stack build && .stack-work/install/x86_64-linux/lts-4.1/7.10.3/bin/<bin-name>`, but I was hoping there was an even more concise `stack run` that I wasn't finding.
05:36:23 <hsk3> ggole, Ferdirand, I still don't get why const was brought up.
05:36:24 <hsk3> We established above that the only valid implementation of f :: (a -> b) -> b is f g = g undefined.
05:36:25 <hsk3> Then we established that the only valid implementation of f :: ((a -> c) -> b) -> b is also f g = g undefined.
05:36:26 <hsk3> Where does const come into play?
05:36:30 <Wizek> danilo2, Thanks for letting me know about exec though! I'm thinking of making a little script/shell function that combines build + exec.
05:36:56 <hsk3> No wait!
05:37:04 <mauke> > let f :: ((a -> c) -> b) -> b; f g = g (const undefined) in ()
05:37:06 <lambdabot>  ()
05:37:13 <danilo2> Wizek: :)
05:37:34 <hsk3> Ok, so you're saying the the only valid implementation of f :: ((a -> c) -> b) -> b is actually f g = g (const undefined) ?
05:37:40 <mauke> no
05:37:52 <ggole> There are a few possible implementations (all of which involve undefined in various places)
05:38:04 <ggole> undefined, g undefined, g (const undefined)
05:38:11 <ggole> (Did I miss any?)
05:39:18 <wedens> any users of stack on arch linux? I have some problems with update. stack installed via AUR, but it tries to update from community repo
05:39:23 <hsk3> ggole: Ok, so the only possible implementations of   f :: (a -> b) -> b   are   f _ = undefined   and   f g = g undefined     right?
05:39:50 <mauke> hsk3: no, f = undefined
05:40:49 <hsk3> mauke: ok so these three: f = undefined, f _ = undefined, and  f g = g undefined   ?
05:44:19 <danilo2> Hello guys! I've got a VERY strange GHC / HS issue here. Namely I've got a very complex typeclass (class Foo a where foo :: a -> String) which resolves for a given argument type (like Int) during compilation in 10 seconds. I've got a function (foo' :: Int -> String; foo' = foo) which compiles these 10 seconds BUT when I use it, every use of foo' takes additional 1 - 2 seconds during compilation
05:44:24 <danilo2> How it could be possible? I've put NOINLINE pragma on foo', it is fully typed, still when I use it, the compilation time increases lineary
05:44:39 <danilo2> The coertions count is exploding
05:44:47 <EVIL7> 有人吗?
05:45:33 <EVIL7> k
05:45:43 <EVIL7> 
05:45:49 <EVIL7> q
05:47:46 <efkf> is there an alternative to takeWhile that takes one more element? ie the first one that _doesn't_ satisfy the predicate?
05:47:52 * hackagebot avers-api 0.0.1 - Types describing the core and extended Avers APIs  https://hackage.haskell.org/package/avers-api-0.0.1 (wereHamster)
05:48:44 <efkf> this is handy for doing something until some convergence condition
05:49:19 <mauke> wouldn't you use dropWhile for that?
05:49:27 <ralu> you can use span
05:50:56 <efkf> mauke dropWhile will get me the answer but the behavior is a little different because i don't get the preceding sequence
05:53:25 <ralu> takeWhilePus1 f xs = a ++ take 1 b where (a.b) 
05:53:42 <ralu> takeWhilePus1 f xs = a ++ take 1 b where (a,b) = span f xs
05:54:37 <mauke> takeWhilePlus n f xs = a ++ take n b where (a, b) = span f xs
05:55:13 <ralu> even better
05:55:33 <efkf> that works, was hoping there's something cleaner
05:58:17 <kassav> hello everybody,
05:58:45 <kassav> did anyone used artificial intelligence programming using haskell?
05:58:57 <danilo2> Hello! Is there anyone who could explain to me what exaclty are COERTIONS in GHC? And why a fully typed function when used multiple times can increase drastically the number of coertions? I would be so, so thankful for any explanation! :)
06:08:22 <edwardk> @tell felixonmars Data.Functor.Coproduct has been replaced with just using Data.Functor.Sum from transformers + transformers-compat
06:08:22 <lambdabot> Consider it noted.
06:11:39 <efkf> two simple implementations for iterating until a solution of x s.t.  x = f(x): http://lpaste.net/149852
06:12:18 <efkf> any suggestions for how this might be done better?
06:12:55 * hackagebot rethinkdb-client-driver 0.0.22 - Client driver for RethinkDB  https://hackage.haskell.org/package/rethinkdb-client-driver-0.0.22 (wereHamster)
06:14:05 <quchen> efkf: Do you really want to feed (f x - x) into the recursion, not just (f x)?
06:16:12 <anohigisavay> hi. does {-# UNPACK #-} always go together with the strict mark?
06:16:23 <efkf> quchen isn't that how it's done mathematically? (i don't actually do this much myself)
06:16:36 <efkf> quchen if i feed f x, it fails for cases like (\x -> 1/x)
06:18:00 <efkf> of course there are still other failure cases
06:18:21 <quchen> You're trying to find the fixed point of "f" given a certain tolerance here, and that's done by repeatedly applying "f" and comparing consecutive values for whether they're at most "tol" apart.
06:18:38 <quchen> There is no recursion involving a minus in there. The minus is just the termination predicate.
06:19:49 <efkf> quchen ah maybe i communicated this wrong. I'm trying to solve for x such that
06:19:58 <efkf> quchen x = f x
06:22:24 <efkf> hm
06:22:27 <efkf> maybe you're right
06:23:34 <efkf> yeah i guess you're right
06:24:01 <quchen> efkf: Try (findEq 0.0001 cos 1)
06:24:20 <quchen> That won't terminate, although (iterate cos 1) will converge
06:27:29 <quchen> ?define converge tol f x | abs (f x - x) < tol = x | otherwise = converge tol f (f x)
06:27:31 <lambdabot>  Defined.
06:27:37 <quchen> > converge 0.0001 cos 1
06:27:39 <lambdabot>  0.7391301765296711
06:27:46 <quchen> > cos (converge 0.0001 cos 1)
06:27:47 <lambdabot>  0.7390547907469174
06:27:55 * hackagebot avers 0.0.13 - empty  https://hackage.haskell.org/package/avers-0.0.13 (wereHamster)
06:28:20 <hodapp> and this isn't Haskell, but SICP devotes some time to showing fixed-points in detail and how they're useful for solving
06:29:18 <quchen> Repeatedly applying "f" probably isn't a very good algorithm anyway.
06:29:27 <quchen> Newton's method is already much better in most cases.
06:31:18 <efkf> quchen im not actually using this, friend was asking how it would be implemented
06:34:16 <quchen> efkf: Well, then try using Newton.
06:37:52 <efkf> ok how's this? http://lpaste.net/149852
06:38:13 <efkf> quchen they were asking specifically about function iteration
06:42:05 <quchen> efkf: That computes each (f x) twice.
06:42:54 <quchen> efkf: Here's one semi-optimized version. http://lpaste.net/149860
06:43:26 <haskell-learner> hi
06:44:05 <haskell-learner> I've got a question if someone can help :)
06:44:32 <Jeanne-Kamikaze> hallo
06:44:57 <haskell-learner> I'm trying to create a function to split a list into two sublists
06:45:00 <haskell-learner> on n
06:45:06 <haskell-learner> so I tired this
06:45:16 <haskell-learner> splittt :: Int -> [Int]-> ([Int],[Int])
06:45:27 <haskell-learner> splittt n [a] = (take n [a], drop n [a]) 
06:45:37 <haskell-learner> when I try it i get this error
06:45:49 <haskell-learner>  Non-exhaustive patterns in function splittt
06:46:34 <defanor> haskell-learner: in the pattern `splittt n [a]`, what do you think `[a]` is doing?
06:47:19 <haskell-learner> I don't understand
06:47:37 <defanor> haskell-learner: the problem is in `[a]` there
06:47:59 <haskell-learner> could you explain please
06:48:08 <defanor> haskell-learner: it matches on a list of a single element, `a`, and bind it to `a`
06:48:09 <efkf> quchen thanks. doesn't the haskell runtime "remember" previous identical functions evaluations automatically? or is that only in particular cases?
06:48:18 <defanor> haskell-learner: while what you want, is to get the whole list in `a`
06:48:26 * hackagebot irc-client 0.2.6.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.2.6.0 (barrucadu)
06:48:31 <defanor> s/bind/binds/
06:49:01 <haskell-learner> oh so [a] is a list of a single element 
06:49:04 <haskell-learner> how stupid of me
06:49:10 <defanor> haskell-learner: and then you get non-exhaustive patterns, because [a] only covers a single element
06:49:26 <defanor> *a single-element list
06:49:37 <haskell-learner> thanks man :)
06:49:44 <defanor> yw
06:59:48 <hexagoxel> when i want a strict datatype, what do i use in stead of [] ?
07:00:47 <maerwald> Data.Map.Strict?
07:04:43 <defanor> Data.Sequence may also be suitable for that
07:06:11 <defanor> though they don't really replace lists
07:07:26 <defanor> hexagoxel: it might help if you'd describe the goal of that
07:07:31 <maerwald> I guess you could also just make your own list data type that is strict
07:10:05 <defanor> well, since regular lists can be infinite, it makes it impossible to get such a list that is strict. though depends on whether we're talking about the whole list being strict, or just its elements
07:10:12 <hexagoxel> defanor: i basically want to make sure that lazyness is not messing with my profiling results. because currently the results don't make much sense.
07:10:15 <hexagoxel> the lists are finite.
07:10:27 <hexagoxel> there is no strict vector somewhere, is there?
07:10:53 <hexagoxel> > Seq.fromList [False, undefined] `seq` True
07:10:54 <lambdabot>  True
07:11:09 <hexagoxel> ^ meh
07:14:09 * hexagoxel uses a wrapper around Data.Vector.Vector for now, where <fromList [bottom] `seq` True> is bottom.
07:17:21 <maerwald> hexagoxel: you probably know that, but keep in mind that time complexity is different there, so not sure how useful that is if you do profiling and switch the data structure like that
07:20:16 <hexagoxel> maerwald: yeah, i am aware. i basically just want to see if the change shifts hotspots to different functions. it is more of a "make sense of profiling output" than actual profiling / optimizing.
07:28:39 * hackagebot gl 0.7.8.1 - Complete OpenGL raw bindings  https://hackage.haskell.org/package/gl-0.7.8.1 (EdwardKmett)
07:38:39 * hackagebot avers-server 0.0.1 - Server implementation of the Avers API  https://hackage.haskell.org/package/avers-server-0.0.1 (wereHamster)
07:48:40 * hackagebot transformers 0.5.1.0 - Concrete functor and monad transformers  https://hackage.haskell.org/package/transformers-0.5.1.0 (RossPaterson)
07:51:00 <sanotehu> ok I've either uncovered a bug or I'm doing something very silly
07:51:26 <sanotehu> in ghci: let t = read "2016-01-01 12:00:00 UTC" :: UTCTime
07:51:38 <sanotehu> map (\x -> addUTCTime x t) [1, 2]
07:51:50 <sanotehu> produces the result: [2016-01-16 12:00:01 UTC,2016-01-16 12:00:02 UTC]
07:52:03 <haskell-learner> hi
07:52:12 <haskell-learner> another noobie question >_<
07:52:18 <sanotehu> never mind, I think I've figured it out...
07:52:26 <haskell-learner> signumm :: Num a =>a -> a 
07:52:33 <haskell-learner> signumm n  = if n > 0 then 1 else 0
07:52:39 <haskell-learner> it's giving me this
07:52:57 <haskell-learner> Could not deduce (Ord a) arising from a use of ‘>’     from the context (Num a)       bound by the type signature for signumm :: Num a => a -> a       at new  28.hs:46:12-25     Possible fix:       add (Ord a) to the context of          the type signature for signumm :: Num a => a -> a     In the expression: n > 0     In the expression: if n > 0 then 1 else 0     In an equation for ‘signumm’: signumm n = if n > 0 the
07:53:00 <wedens> you need `Ord a`
07:53:34 <haskell-learner> even with Ord a
07:53:42 <haskell-learner> i still get an error
07:53:56 <haskell-learner> Could not deduce (Num a) arising from the literal ‘0’     from the context (Ord a)
07:54:06 <wedens> :t \n -> if n > 0 then 1 else 0
07:54:07 <lambdabot> (Num a, Num a1, Ord a) => a -> a1
07:54:32 <wedens> (Num a, Ord a) => a -> a
07:54:49 <haskell-learner> can you explain that notation please
07:57:10 <wedens> haskell-learner: it's a class constraint. restricts type 'a' to types with instances of typeclasses Num and Ord
07:58:07 <haskell-learner> so why didn't it work with Num only?
07:59:21 <nut__> im writing a function that pulls articles from the web, how to i wait 5sec before running it again? im inside a forM_
07:59:38 <wedens> :t (>)
07:59:40 <lambdabot> Ord a => a -> a -> Bool
07:59:55 <wedens> haskell-learner: (>) function requires Ord typeclass
08:00:27 <haskell-learner> but it didn't work with Ord alone
08:00:44 <puregreen> nut__: use threadDelay
08:00:47 <squall> Can anyone help me understand the Haskell list type, i know the cons operation is used in a recursion relation for (>>=) with fold, but I can't figure out what would happen if cons took three arguments...
08:01:04 <nut__> puregreen, thx. any one liner ?
08:01:41 <squall> :t threadDelay
08:01:42 <lambdabot> Not in scope: ‘threadDelay’
08:01:51 <nut__> ok
08:02:03 <puregreen> for_ ... $ \x -> do whatever; threadDelay 5000000;
08:02:04 <nut__> i'll do the homework
08:03:01 <wedens> haskell-learner: you need both typeclasses. Num to work with numbers and Ord to compare things
08:03:36 <haskell-learner> okey thanks a lot :)
08:04:02 <wedens> haskell-learner: (Num a, Ord a) means it's a numeric value that you can order/compare
08:04:19 <wedens> "it's" is type 'a'
08:05:08 <squall> :t (<3)
08:05:09 <lambdabot> (Num a, Ord a) => a -> Bool
08:05:58 <squall> :t 3
08:05:59 <lambdabot> Num a => a
08:06:55 <haskell-learner> okey got it
08:07:55 <squall> So if cons took three arguments, and I write a MonadPlus instance for it, what have I done!?
08:09:37 <squall> I was imagining the additional list would be a list of neighbors and it would be a tree, is that right?
08:10:03 <exio4> an additional list? that's more data than what we had before
08:10:11 <exio4> also, a monadplus instance for cons? :P
08:10:28 <squall> No, rewriting List
08:10:49 <squall> :t Cons
08:10:50 <lambdabot>     Not in scope: data constructor ‘Cons’
08:10:50 <lambdabot>     Perhaps you meant one of these:
08:10:50 <lambdabot>       ‘Const’ (imported from Control.Lens),
08:11:19 <squall> :t (:)
08:11:20 <lambdabot> a -> [a] -> [a]
08:12:09 <nut__> when inside a forM loop how to find the current iteration number?
08:12:39 <puregreen> nut__: you can zip elements with indexes
08:12:51 <puregreen> for_ (zip [1..] xs) $ \(index, x) -> ...
08:13:16 <exio4> or [0..] if you want to index some other vector or so, based on the current index
08:13:42 <puregreen> or you can use zipWithM
08:13:47 <nut__> this is what haskellers often do? or the common way ?
08:13:51 <puregreen> hm, no
08:13:57 <puregreen> zipWithM has bad argument order
08:14:18 <puregreen> anyway, I always use the for_ + zip thing, but I don't really know what others use
08:14:52 <nut__> puregreen, thanks
08:15:11 <puregreen> there's also ifor and ifor_ in lens, but they are, well, in lens
08:15:45 <exio4> nut__: just write code the way you want to do it, you'll be able to nitpick on those things later
08:16:13 <exio4> nut__: forM_ (zip [1..] xs) $ \(index,x) -> is perfectly readable to me, too 
08:16:15 <feurra> salve
08:16:20 <feurra> !list
08:18:16 <squall> @define data Tree' a = Nil | Cons a (Tree a) (Tree a)
08:18:18 <lambdabot>  .L.hs:149:1:
08:18:18 <lambdabot>      Multiple declarations of ‘Tree'’
08:18:18 <lambdabot>      Declared at: .L.hs:146:1
08:18:46 <squall> @define data Tree'' a = Nil | Cons a (Tree a) (Tree a)
08:18:47 <lambdabot>  .L.hs:149:17:
08:18:47 <lambdabot>      Multiple declarations of ‘Nil’
08:18:47 <lambdabot>      Declared at: .L.hs:146:16
08:18:59 <squall> Sorry!!
08:19:27 <squall> @define data Tree'' a = Nil'' | Cons'' a (Tree'' a) (Tree'' a)
08:19:28 <lambdabot>  Defined.
08:19:58 <squall> And then with a MonadPlus instance
08:20:31 <squall> Ok so far?
08:21:59 <achernyak> it would make more sense to put Cons'' (Tree'' a) a (Tree'' a)
08:22:23 <achernyak> this resembles more closely how the tree actually looks with a left and right side.
08:22:39 <squall> Thanks
08:23:41 * hackagebot exp-extended 0.1.1.1 - floating point with extended exponent range  https://hackage.haskell.org/package/exp-extended-0.1.1.1 (ClaudeHeilandAllen)
08:25:09 <squall> I can see how cons works with list, but how do we interpret these two trees if we write the MonadPlus instance to treat this, rather than as a binary tree, but with one tree as the container of the neighbors (a kTree), and the other as some kind of internal list... I can't quite grasp this
08:27:41 <squall> @define data Tree''' a = Nil''' | Leaf''' a | Cons''' (Tree''' a) (Tree''' a)
08:27:41 <achernyak> squall, It's pretty similar to how you would define a Monoid instance for it.
08:27:42 <lambdabot>  Defined.
08:28:47 <FunkToFunky> Hi all, got a quick question
08:29:28 <squall> Here mzero and return are trivial, but there seems to be a choice for mplus
08:29:39 <FunkToFunky> If you want to find if a substring is contained in a list you can use isInfixOf, so like '"def" `isInfixOf` "abcdefghi"' will return true
08:30:41 <squall> Go on
08:30:44 <FunkToFunky> But what if you want to find if a substring is in a list of lists? So '"def `isInfixOf` ["ab", "cdefg", "hi"]"?
08:30:49 <achernyak> squall, you are correct. Think about how and Int has two multiple instances (e.g. Sum and Product) a tree can have the same type of behavior. This is why there are implementations for different cases.
08:31:27 <squall> Can't something bigger than MonadPlus handle both?
08:31:56 <FunkToFunky> You can do use "map ("def" `isInfixOf`) ["ab", "cdefg", "hi"]", which will return a list of bools with the second being 'true', but I feel there will be an easier way I'm missing here
08:32:16 <achernyak> if something can I haven't seen it. I've always seen a tree implemented different ways. Maybe someone else can chime in.
08:33:18 <puregreen> FunkToFunky: maybe “any” would be useful here
08:33:20 <puregreen> :t any
08:33:21 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:33:40 <puregreen> > any ("def" `isInfixOf`) ["ab", "cdefg", "hi"]
08:33:41 <lambdabot>  True
08:33:46 <nut__> can mongodb run haskell code? i write a filter or query in haskell that selects only certain text data stored in mongodb
08:34:02 <FunkToFunky> That is exactly what I was looking for! It seems obvious now!
08:34:07 <FunkToFunky> Thank you! :)
08:34:20 <nut__> i dont want to learn mongodb language to translate the haskell code into mongodb code
08:38:04 <squall> nut__, you probably you need help from the mongodb end
08:39:20 <achernyak> nut__, There is a library that generalizes mongodb functions that I have used in the past https://hackage.haskell.org/package/mongoDB-2.0.10/docs/Database-MongoDB-Query.html
08:39:38 <squall> (squall) @define data Tree''' a = Nil''' | Leaf''' a | Cons''' (Tree''' a) (Tree''' a)
08:39:53 <achernyak> but keep in mind, no matter what DB you connect the library for it can't be 100% generalized.
08:40:55 <nut__> im using that library to connect and insert etc. I dont know that it offers the possibility to write queries in Haskell
08:41:03 <nut__> let me take a closer look
08:41:13 <squall> With this, one tree can be viewed as neighbors, the other, in the trivial case is where an element would go as in a ktree, else, it is a tree, as if it were a list of lists
08:42:28 <squall> But I now have 2 directions to fold in...
08:42:52 <squall> Join and bind have similar ambiguity
08:44:02 <achernyak> right, but one you decide how you want to implement fold for example all of them kind of fall into place. Because you want consistent behavior.
08:44:03 <squall> But perhaps I'm mistaken because there can only be one valid definition obeying the laws
08:44:28 <achernyak> not for fold
08:44:39 <squall> But the resulting bind
08:44:57 <achernyak> yes for bind it has to have only one.
08:45:17 <squall> And I would write bind using fold I'm sure
08:46:06 <squall> Maybe I'm forced to fold both directions at once...
08:46:55 <squall> :t join
08:46:56 <lambdabot> Monad m => m (m a) -> m a
08:47:19 <achernyak> in order to define fold you do have to fold both directions
08:48:19 <squall> @define data Tree'''' a = Nil'''' | Leaf'''' a | Cons'''' (Tree'''' a) [Tree'''' a]
08:48:21 <lambdabot>  Defined.
08:48:36 <squall> Probably more like that actually....
08:49:35 <squall> Is that a thing?
08:50:10 <squall> I think it's isomorphic to Free KTree
08:50:49 <squall> Which is Haskell’s Data.Tree
08:51:13 <squall> KTree is...
08:51:26 <squall> Sorry...
08:53:18 <squall> It's the next most simple recursive type I can write a MonadPlus instance for, am I missing something?
08:59:44 <scshunt> ugh, hackage, why you no docs
09:00:15 <achernyak> take a look at this for a fold sample https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Foldable.html
09:03:03 <squall> What about it?
09:03:04 <nut__> how to keep only odd index number element from a list
09:03:31 <nut__> i mean take only the 1rst, 3rd, 5th ... element
09:03:57 <liste> :t zip [1..] -- nut__ this may come handy
09:03:58 <lambdabot> (Enum a, Num a) => [b] -> [(a, b)]
09:04:21 <liste> > zip [1..] [5,76,5,2,42,4,6236,24,21,5,25]
09:04:22 <lambdabot>  [(1,5),(2,76),(3,5),(4,2),(5,42),(6,4),(7,6236),(8,24),(9,21),(10,5),(11,25)]
09:04:34 <squall> No, the presence of the a in the third constructor makes this a binary tree, mine has a list of Tree so is a KTree
09:05:01 <nut__> liste, i dont get it
09:05:17 <liste> that annotates each element in the list with their index numbers
09:05:39 <liste> so you can do filter etc. based on index numbers too
09:05:47 <nut__> ok i see liste 
09:05:51 <ner0x652> hi @all
09:06:33 <ner0x652> I am having fun with a simple program, it reads arguments from command line
09:06:40 <squall> So your idea of "both directions" is slightly different to mine...
09:07:05 <ner0x652> exactly 2 numbers, I want to add those two, then output the result, I need to use read function and show function
09:07:06 <liste> nut__ in the specific case of dropping only even/odd numbers, it may be overkill though
09:07:15 <squall> Which is isomorphic to Free Data.Tree
09:07:39 <achernyak> squall, it's the same idea. Just you are going in both directions inside of your Cons instead of a node
09:07:41 <ph88> anyone know how i can get this derive to work?  http://lpaste.net/388805651091947520
09:07:55 <achernyak> you would run a fold on each one and then mappend them together
09:08:15 <ner0x652> mainly my function is main = do args <- getArgs num <- read args !! 0 num2 <- read args !! 1
09:08:50 <ner0x652> is that correct? how to use show for number to string conversion?
09:09:09 <squall> I guess I'm grumbling because while folding both directions in a binary tree, through symmetry, is the only viable option, but here I could actually do two distinct things
09:09:27 <glguy> ph88: You'll need to make separate Generic and Out instances
09:09:41 <ph88> glguy, what do you mean by that ?
09:10:47 <glguy> deriving instance Generic This; deriving instance Generic That; instance Out HsModule; instance Out a => Out (ParseResult a)
09:10:48 <liste> ner0x652 you're missing the semicolons/newlines, but otherwise it looks ok (IF you ignore error cases)
09:10:50 <glguy> something like that
09:10:52 <kadoban> ner0x652: Well, there's a couple of things I'd probably complain about from a style perspective, and an error-handling one, but it should basically work.
09:11:00 <kadoban> ner0x652: Are you having issues with it?
09:11:10 <squall> And with these two distinct folds, I think I'm expecting two different kinds of bind...
09:11:16 <glguy> ph88: You can't just lump all the instances you want into one deriving line
09:12:06 <squall> And an struggling to find the right superclass, but can't tell if I'm confused and MonadPlus has everything I need...
09:13:12 <squall> It depends if this idea of two binds makes sense over this structure, and then I'm wondering how to write the superclass or if it exists
09:16:10 <ph88> glguy, i have no idea what i'm doing and i don't understand these compiler messages
09:16:39 <ner0x652> kadoban: i do not know how to use show to output to stdout
09:17:03 <t0by> I'm sorry, what's wrong with this (not particularly useful) code and what are the compiler messages actually trying to tell me? http://lpaste.net/7267446769229758464
09:17:08 <monochrom> show just builds the string, you need putStrLn to get it out
09:17:11 <squall> A key thing is that we cannot consider this example using List instead of Tree, because Free List ==== List, basically... This Free Data.Tree like object is the smallest one I can describe
09:18:06 <ner0x652> ok, then if result is a number, I must write: putStrLn(show result)
09:18:07 <ner0x652> ?
09:18:13 <monochrom> yes
09:18:37 <monochrom> t0by: what is "g x = 2" doing there?
09:19:01 <liste> > Free [Pure 1,Pure 2,Free [Pure 3,Pure 4],Pure 5] -- Free [] is a tree
09:19:03 <lambdabot>  Not in scope: data constructor ‘Free’    Not in scope: data constructor ‘Pure’
09:19:03 <lambdabot>      Perhaps you meant variable ‘pure’ (imported from Control.Applicative)   ...
09:19:03 <lambdabot>      Perhaps you meant variable ‘pure’ (imported from Control.Applicative)Not...
09:19:10 <shirt> how do i create a list containing the integers n till 0?
09:19:12 <t0by> monochrom, absolutely nothing useful, it's a function t -> Integer for some t that for all choice of x gives 2.
09:19:23 <monochrom> yes, but why is it not "f x = 2"?
09:19:33 <monochrom> err nevermind
09:19:38 <lambda-11235> t0by: Line 10, is there supposed to be a print statement or return there?
09:19:38 <t0by> monochrom, because I'm a stupid dick and I forgot to declare g
09:19:51 <monochrom> that g will be unused anyway
09:19:57 <t0by> monochrom, make it
09:19:57 <t0by> f :: t -> Integer
09:19:57 <t0by> f x = 1
09:19:57 <t0by> g :: t -> Integer
09:19:57 <t0by> g x = 2
09:19:59 <thejohnfreeman> putStrLn . show == print, btw
09:20:03 <monochrom> what is the type of randomRs?
09:20:14 <ner0x652> I am doing something wrong, here is the code http://pastebin.com/6xNTyt4h, can you please take a look
09:20:17 <squall> :(
09:20:46 <ner0x652> the compiler error is couldn't match type '[Char]' with 'Char'
09:21:00 <hexagoxel> ner0x652: read args !! 0  ===  (read args) !! 0
09:21:01 <t0by> monochrom, I would say [t], with t = 1 | 0
09:21:03 <thejohnfreeman> I think you need $ after 'read'
09:21:06 <ph88> glguy, in other words: teach a man to fish :P
09:21:22 <t0by> monochrom, actually [Integer]
09:21:26 <t0by> if http://haddock.stackage.org/lts-4.1/Yampa-0.10.4/FRP-Yampa-Random.html#v:randomRs is to be believed
09:21:43 <monochrom> ok, change the "coin <-" line to "let coin = head (randomRs ('0', '1') g)", since it does not perform IO stuff.
09:22:01 <squall> Is anyone following my discussion?
09:22:22 <monochrom> lastly, when you say "g 1", it doesn't use the "g x = 2" definition outside. totally not. you have a local g.
09:22:34 <lambda-11235> t0by: Line 10 has the wrong type of Integer instead of IO (), you need a print or return statement.
09:22:36 <t0by> doh
09:22:55 <thejohnfreeman> Howdy everyone. I'd call myself a beginner/intermediate Haskeller, and I'm looking for review of my Advent of Code solutions. Please open issues with any advice you have: https://github.com/thejohnfreeman/advent-2015
09:22:58 <ner0x652> hexagoxel: that didn't change anything
09:23:06 <monochrom> and yeah, what lambda-11235 says
09:23:55 <hexagoxel> ner0x652: of course it did not; i told you the implicit parenthesis as "seen" by the compiler.
09:24:21 <ner0x652> oh, so it should be read (args !! 0) 
09:24:22 <ner0x652> ?
09:24:27 <hexagoxel> right!
09:24:46 <squall> Am I on to something? Does what I'm saying make sense?
09:24:48 <t0by> monochrom, lambda-11235 what now? http://lpaste.net/149875
09:24:50 <thejohnfreeman> ner0x652: https://gist.github.com/anonymous/f56d0bf71d37c606afdb
09:25:38 <hexagoxel> ner0x652: (or use the ($) trick to avoid additional parentheses)
09:26:05 <ner0x652> thejohnfreeman: Ok :) The second example is nice, simpler I think, thanks
09:26:32 <thejohnfreeman> ner0x652: even better: main = getArgs >>= print . sum . map read
09:27:06 <ner0x652> probably, for now I do not understand that
09:27:10 <hexagoxel> first learn the basic language :p
09:27:16 <thejohnfreeman> yes, good advice
09:27:29 <ner0x652> hexagoxel: true, this is what I am doing :) thanks
09:27:52 <lambda-11235> t0by: Change coin == 1 to coin == '1'.
09:28:53 <t0by> lambda-11235, or actually ('0', '1') to (0,1) I guess?
09:28:59 <t0by> (I mean, I don't want a string there)
09:30:23 <lambda-11235> t0by: Either one works, but I'd change ('0', '1') to (0, 1) like you said.
09:32:14 <t0by> lambda-11235, why   let coin = randomR (0, 1) g wouldn't work?
09:37:03 <lambda-11235> t0by: Haskell can't deduce what type coin is, let coin = fst $ randomR (0, 1) g :: Int
09:38:27 <lambda-11235> That should work, you have to give the type since it's ambiguous.
09:46:58 <squall> Would anyone be interested in checking a formal presentation of this Free Tree thing to help me figure out what it's doing?
09:48:34 <Gurkenglas> You're not supposed to ask that kind of thing without giving the full problem description
09:52:30 <squall> Ok
09:52:39 <squall> I'll compile that
09:53:28 <squall> I was hoping for some intuition to help me be clear, but until I am I can't receive this
09:54:14 <Gurkenglas> Compile? I was expecting that you have some lines of code you don't understand. You can't "receive" what?
09:54:32 <squall> data Tree'''' a = Nil'''' | Leaf'''' a | Cons'''' (Tree'''' a) [Tree'''' a] seems to be "the next most complex free structure"
09:55:31 <Gurkenglas> This is either the empty tree, or a leaf containing one piece of data, or a nonempty list of trees. "next" after what? Why the "'"s?
09:56:22 <squall> I took 4 stages in my derivation of it above, and have no name for the structure
09:58:44 <squall> The list of trees should be viewed as "horizontal" neighbors but the tree stored is "descended" through in the sense of Free...
09:59:30 <Gurkenglas> How do you know that? (Can you paste the code on lpaste.net ?)
10:00:02 <squall> It represents trees with trees as elements, potentially infinity as in Free, like a list of list of list etc
10:00:51 <Gurkenglas> Are the Trees in the list also "descended through"?
10:00:56 <squall> I could do that for tomorrow and return if it's the only way to communicate what I mean
10:01:13 <Gurkenglas> Why not now?
10:01:21 <squall> The ones in the list are neighbors in the normal tree sense
10:01:26 <squall> Hunger
10:01:50 <ph88> pizza ?
10:02:06 <Gurkenglas> Do you know what the code means because you wrote it or because it says it?
10:03:22 <liste> squall isn't "Nil''''" with "Cons'''' (Tree'''' a) [Tree'''' a]" isomorphic to "Trees'''' [Tree'''' a]" ?
10:03:28 <squall> This seems to be the only way i can derive a structure exhibiting this kind of behaviour. Free [] being isomorphic to List
10:03:29 <scshunt> I see stackage lets you download a hoogle database for a given resolver
10:03:38 <scshunt> does it also let you download all of the documentation?
10:03:41 <liste> squall Free [] is isomorphic to tree
10:03:45 * hackagebot crackNum 1.4 - Crack various integer, floating-point data formats  https://hackage.haskell.org/package/crackNum-1.4 (LeventErkok)
10:04:07 <Gurkenglas> No, that's Cofree []
10:04:32 <Gurkenglas> liste, he's allegedly treating the trees in the list and the one outside it differently
10:05:59 <squall> Otherwise I would have a redundant over prescription
10:06:01 <squall> I may still have...
10:07:45 <liste> Gurkenglas isn't "Free [Pure 1, Pure 2, Free [Pure 3, Pure 4], Pure 5]" a tree? am I missing something?
10:08:13 <Gurkenglas> liste, I thought we both meant https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Tree.html
10:09:06 <liste> yes
10:09:11 <liste> ohg
10:09:12 <liste> oh*
10:09:13 <liste> I see
10:09:36 <liste> Data.Tree is always non-empty
10:09:55 <liste> Free [] can be empty
10:10:48 <squall> Interesting
10:11:03 <Gurkenglas> http://sketchtoy.com/66480165 squall, on the left is a member of your structure, on the right is what happens when you store all the neighbors of the node in the parent node instead (and thus have to have a list of nodes at the root)
10:12:38 <squall> Cool! Not quite following, I'll watch again
10:12:51 <Gurkenglas> The 5 lines at the end are just showing what is what
10:12:58 <Gurkenglas> You can use the slider at the bottom to go back and forth
10:13:10 <squall> It's a nice tool
10:13:27 <Gurkenglas> "data Forest a = Leaf a | Node (Forest a)" would be whats on the right
10:13:42 <Gurkenglas> Wait no dropped the [] somewhere
10:14:08 <Gurkenglas> "data Forest a = [Tree a]; data Tree a = Leaf a | Node (Forest a)" and Forest is whats on the right
10:14:19 <squall> Yes that makes sense I think, that's kind of how I was figuring what was isomorphic
10:14:48 <Gurkenglas> -"data Forest"+"type Forest"
10:14:58 <Gurkenglas> Where Node [] is what you had as Nil
10:15:14 <squall> No!
10:15:42 <squall> Ok your certainly doing something differently to me, I need both those base cases
10:16:22 <Gurkenglas> Huh? Tell me a member of Tree'''' a and Ill tell you the corresponding member of Forest a, or vice versa
10:16:32 <squall> return a = Cons' (Cons' (Cons' ....
10:17:01 <Gurkenglas> And what's the second argument to the top-level Cons'?
10:17:18 <squall> []
10:17:55 <Gurkenglas> return a = [Node (return a)]
10:18:30 <squall> A single element would have no neighbors, but without the leaf basecase you are forced to put it at the bottom of Free
10:20:15 <squall> Your return returns a list, it should be returning something like \a -> Cons' (Leaf' a) []
10:20:17 <Gurkenglas> ( http://sketchtoy.com/66480211 )
10:20:34 <Gurkenglas> My return is a -> Forest a
10:20:53 <Gurkenglas> I meant that your Tree'''' a is isomorphic to my Forest a
10:21:55 <squall> To prevent this, the list is non empty
10:22:25 <Gurkenglas> What list is nonempty?
10:22:38 <squall> Your forest can be empty
10:23:18 <Gurkenglas> And your Tree'''' can be Nil''''
10:23:49 <squall> data Tree' a = Nil' | Leaf' a | Cons' (Tree' a) [Tree' a]
10:24:21 <squall> Oh!!!
10:25:45 <squall> Nope, still can't write a non infinite return without using leaf
10:26:55 <squall> I think yours collapses because Cons' must take an additional argument for the recursion in the Free sense to yield a unique structure
10:28:19 <Gurkenglas> Rephrase please. (Can you give an example where my isomorphism breaks?)
10:29:48 <ralu> Why is Cons'  (Tree' a) [Tree' a]
10:29:54 <squall> It's about the fact that expanding out a Free datatype cannot result in more than List without this additional direction
10:30:48 <squall> ralu, it is like a kind of Tree that has this kind of Tree as elements
10:31:07 <Gurkenglas> You don't need the additional direction of "nodes to the right of this one" if you just give all nodes to the right of this one as additional nodes below this node's parent
10:31:50 <ralu> Why is this better than just [Tree a]
10:31:58 <squall> The directions well be folded using different functions
10:32:17 <squall> foldFree and foldTree
10:32:28 <Gurkenglas> Will the first child of a tree be treated differently than its neighbors?
10:32:38 <Gurkenglas> (The neighbors of the first child)
10:33:36 <squall> For example the internal Tree could be a fine grained representation
10:33:49 <ralu> i think that  (Tree a) [Tree a] is isomorphic to [Tree a]
10:34:05 <squall> If we had a line, made of segments which are lines, but with branches
10:34:25 <roelof> hello, I now have one big library file which contains functions to add and delete a account, making a deposit and making a withdrawal  
10:34:42 <roelof> Now I want to refractor this.
10:34:49 <Gurkenglas> ralu, the (Tree a) is one level further down, the elements of the [Tree a] are on the same level. But even if that wasnt the case, what's the partner to [] from the right side?
10:35:28 <squall> Traversing the neighbour list would be like taking a shortcut, not having to traverse the internal Tree to its endpoint, having stored a pointer to it as a neighbour
10:35:31 <roelof> What is better. one file for pure functions and one for the io stuff or making a library for accounts , one for transactions and one for reports
10:35:36 <ralu> Nill ?
10:36:30 <squall> ralu, ensuring the list is non empty stops it being a nice base case
10:36:43 <Gurkenglas> > fromJust $ (1:) <$> undefined -- Why isn't this "[1*Exception: Prelude.undefined"?
10:36:45 <lambdabot>  *Exception: Prelude.undefined
10:37:14 <puregreen> > fromJust $ (1:) <$> Nothing
10:37:16 <lambdabot>  *Exception: Maybe.fromJust: Nothing
10:37:28 <puregreen> because it's not necessarily a Just
10:37:49 <puregreen> > (1:) <$> Nothing
10:37:51 <lambdabot>  Nothing
10:38:16 <Gurkenglas> Right. I expected it to assume it would be just because I promised that with fromJust
10:39:13 <puregreen> well, it'd work like this if Just was a newtype (which it can't be)
10:39:29 <puregreen> > runIdentity $ (1:) <$> undefined
10:39:30 <lambdabot>  [1*Exception: Prelude.undefined
10:41:25 <squall> Are we at the point where we can see if MonadPlus is insufficient to fully abstract out the functionality of this structure, or is there still a debate about redundancy?
10:41:52 <Gurkenglas> The latter.
10:43:34 <squall> Admittedly if there was a contraction possible it would "collapse" but that by including the additional terms allows for a more complex structure.
10:44:34 <squall> That is, there exists a functionality over this structure which cannot be contacted
10:44:37 <ralu> i can imagine how you Plus non isomorphic trees
10:44:43 <ralu> can't
10:44:52 <squall> Contracted*
10:45:10 <Gurkenglas> squall, by the way are Cons' Nil' [Cons' Nil' [Nil']] and Cons' Nil' [Cons' Nil' [], Nil'] supposed to be equal?
10:45:53 <squall> ralu, one thing pointing me towards biMonad is that there seems to be two distinct types of plus
10:47:42 <squall> Gurkenglas, I guess not. They have different shape, and would be different if maped over
10:49:41 <squall> I guess I'd like to use applicative and pure to turn each of those identifiably different basecase objects to a different function over integers or something
10:50:17 <roelof> no one who can answer my refractor question ?
10:50:43 <squall> I can pattern match, even though supposedly no information should be present..
10:51:13 <squall> Just like how the length of Free represents the integers
10:52:08 <Gurkenglas> puregreen, I woulda hoped Haskell could propagate promises. Like, in f . g, if f has an unrefutable pattern match on g's output type, and g has a pattern analysis only one case of which can output something to match the unrefutable pattern match, then it automatically gets unrefutably matches that case
10:52:40 <Gurkenglas> Because that'd make "liftM fromJust . runMaybeT . many . MaybeT" lazy
10:53:24 <squall> So it looks like until I can show this thing is unique, we can't move forward, wouldn't it be ok to accept that without this additional structure it certainly wouldn't be possible, but that the additional terms permit the possibility to represent a more complex structure
10:53:25 <squall> ?
10:54:42 <Gurkenglas> If you treat the two examples I gave differently, then there is no isomorphism to my Forest.
10:55:08 <squall> Great
10:55:52 <squall> So it can be made to be more complex than a MonadPlus. What superclass would capture this?
10:56:25 <squall> Right?
10:56:31 <Gurkenglas> Note that (MonadPlus a) is for all intents and purposes exactly (Alternative a, Monad a)
10:57:15 <squall> Alternative is like Monoid?
10:57:25 <Gurkenglas> yep
10:58:03 <squall> Is it a biMonad?
10:58:06 <Gurkenglas> Well, it's more like Applicative is like Monoid and since Alternatives must already be Applicatives, Alternative is kinda like rings I think?
10:58:31 <Gurkenglas> Someone help me out here
10:58:40 <squall> Or through Free is it more like an infinityMonad
10:59:26 <squall> Thanks by the way Gurkenglas, your the first person iv had confirm they understand me
11:00:03 <squall> Rings is fine, I'll check out Alternative
11:00:08 <Gurkenglas> It is pretty hard. Where'd I confirm that :D?
11:01:06 <squall> You got that I Need to treat other direction differently
11:01:33 <squall> The*
11:02:31 <roelof> As I want to put things in seperate libraries. Is it better to put functions on the same subject on seperate function or is it moer the haskell way to seperate pure and io functions  in seperate functions ? 
11:02:54 <squall> You get the basic idea of adjacent neighbors and Free like recursion on the mandatory element
11:05:36 <hexagoxel> shouldn't the "total alloc (excluding prof. overheads)" number in .prof equal the +RTS -s total alloc output when not profiling?
11:06:25 <ryantrinkle> i have a use of reallyUnsafePtrEquality#; would anyone be willing to help review that code?
11:06:39 <hexagoxel> because i have a ~20% difference there.
11:06:51 <ryantrinkle> it helps performance, and my use looks safe to me, but I don't feel that I fully understand that primitive
11:08:09 <monochrom> hexagoxel: I think one of them is from a periodic sampling and is known to be inexact
11:08:54 <ryantrinkle> the use of reallyUnsafePtrEquality# is here: https://github.com/ryantrinkle/reflex/blob/85d8c1c7dedec94a04457c001b7bf73220f720e5/src/Data/IORef/Maybe.hs#L32
11:15:10 <Gurkenglas> (That looks like it should by Any -> Maybe Any)
11:15:14 <Gurkenglas> *Be
11:17:46 <ryantrinkle> Gurkenglas: it's actually much more dangerous that that :P
11:17:48 <ryantrinkle> (on purpose)
11:17:59 <ryantrinkle> basically I'm using IORef a to represent IORef (Maybe a)
11:18:10 <ryantrinkle> with a special value (nothingSurrogate) to represent the Nothing case
11:18:26 <ryantrinkle> this reduces the memory usage (no extra Maybe constructors floating around)
11:18:40 <ryantrinkle> and also eliminates a pointer indirection (no need to traverse the Just constructor to get to the value)
11:19:26 <Gurkenglas> Wouldn't the bit sequence used by nothingSurrogate collide with the bit sequence space used by the just values?
11:20:15 <ryantrinkle> Gurkenglas: i'm not sure, but I don't think it should: the CAF I'm using should never be in the same place in the heap as any Just constructor
11:20:46 <ryantrinkle> i believe the IORef has a pointer inside it
11:21:03 <ryantrinkle> if somehow you managed to writeIORefMaybe r (Just (unsafeCoerce nothingSurrogate))
11:21:09 <ryantrinkle> then that would pop out as Nothing
11:21:26 <ryantrinkle> but nothingSurrogate won't be exported when i'm done with this module
11:21:32 <ryantrinkle> so i think that should be safe
11:22:38 <qmm> data Point = Point { x :: Int, y :: Int }
11:22:51 <hexagoxel> does reallyUnsafePtrEquality force its (first) argument?
11:22:52 <qmm> let p = Point { x = 1, y = 2 }
11:22:55 <Gurkenglas> This sounds like something ekmett mentioned in one of his talks. Invoke his true name?
11:23:04 <qmm> is there a field accessor for p?
11:23:36 <ryantrinkle> Gurkenglas: yeah, definitely seems like his kind of thing :)
11:23:46 <qmm> or is there a recommended way for accessing fields, with or without records
11:24:49 <geekosaur> qmm: x p? not quite sure what you're asking
11:25:13 <hexagoxel> well if you only ever feed the result from readIORef into toMaybe i guess it does not matter..
11:25:25 <hexagoxel> but then why is it a separate function in the first place :p
11:26:13 <ryantrinkle> hexagoxel: that's a good point; it was a separate function because i was trying to write atomicModifyIORef, which would also use it
11:26:23 <ryantrinkle> but that didn't end up being possible :P
11:28:49 <Gurkenglas> Let me guess, https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-IORef.html#v:atomicModifyIORef is the wrong way round for historical reasons?
11:31:06 <ryantrinkle> Gurkenglas: actually, it's even crazier than that!
11:31:25 <ryantrinkle> basically, because it's atomic, i don't think it's *possible* for it to support IORefMaybe
11:31:38 <ryantrinkle> because it would need to know whether the function is gonna produce a Nothing or a Just
11:31:43 <ryantrinkle> but it can't know that fast enough
11:36:57 <ryantrinkle> Gurkenglas, hexagoxel: thanks for taking a look :)
11:37:01 <Gurkenglas> :t zoom _Just (undefined :: StateT s m a) -- "fast enough"? I'd think you could just modify your a-modifier like so and throw it at atomicallyModifyIORef
11:37:02 <lambdabot> (Monad m, Monoid c) => StateT (Maybe a) m c
11:37:53 <ryantrinkle> Gurkenglas: i think the thing is that atomicModifyIORef is doing something really low-level to make it atomic
11:38:03 <ryantrinkle> so it's not actually evaluating your first result value
11:38:25 <ryantrinkle> so even though that value *would* evaluate to nothingSurrogate
11:38:30 <Gurkenglas> Ah, so atomic actually means something and I don't even know what we're optimizing for :3
11:38:32 <ryantrinkle> it doesn't actually evaluate it
11:38:46 <ryantrinkle> yeah, it has to do with concurrent memory access
11:39:02 <Gurkenglas> Ah, something that can't be interrupted by another thread
11:39:06 <ryantrinkle> exactly
11:39:16 <ryantrinkle> and i think that actually *evaluating* the function would not work
11:46:40 <qmm> geekosaur: x p -- wow
11:46:44 <qmm> geekosaur: how?
11:46:48 <qmm> how does that work
11:47:12 <qmm> how does the compiler / repl know x is a field of p?
11:47:30 <mauke> because that's how you defined it?
11:47:46 <liste> @let data Point = Point { x :: Int, y :: Int } -- this defines the type Point, the data constructor Point and two functions, x :: Point -> Int and y :: Point -> Int (among other things)
11:47:47 <lambdabot>  Defined.
11:47:50 <liste> :t x
11:47:51 <lambdabot>     Ambiguous occurrence ‘x’
11:47:52 <lambdabot>     It could refer to either ‘L.x’,
11:47:52 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:160:20
11:47:55 <mauke> @undefine
11:47:55 <lambdabot> Undefined.
11:47:55 <liste> :t L.x
11:47:57 <lambdabot> Not in scope: ‘L.x’
11:48:42 <geekosaur> this , btw, is why you can;t reuse field names
11:49:23 <qmm> oh, x is a function
11:49:24 <geekosaur> it's *not* being clever
11:49:53 <geekosaur> (sorry, was afk when you sent that)
11:50:35 <athan> ralu: I made a few different implementations in rose-trees:
11:50:40 <athan> @hackage rose-trees
11:50:40 <lambdabot> http://hackage.haskell.org/package/rose-trees
11:50:55 <athan> oh jeez that was a long time ago since you posted that, sorry
11:51:01 <qmm> thanks geekosaur and liste
11:51:01 <athan> my irc client lags implicitly >.>
11:52:51 <ralu> :D i still got it
11:53:31 <liste> btw is L the module things you @define go into?
11:54:43 <qmm> data Point = Point { x :: Int, y :: Int } p = Point { x = 1, y = 2 }
11:55:35 <qmm> i was about to state that this is very basic, and then ask for some more interesting things to do with ADTs
11:55:47 <qmm> but then i realized i could look at the tutorial
11:55:57 <qmm> i think the next step is to play with classes
11:57:02 <fjordrunner> hi,...please how do I specify in Persist * (all)? I'm trying to get count of total records,...but not so lucky so far
11:57:23 <geekosaur> liste, L is sort of the "Prelude" for lambdabot. it has the @let stuff, and pre-imported modules, and other things that the bot maintainer wants in scope for :t, @run, etc.
11:58:05 <geekosaur> and @undefine causes the bot to copy the default L.hs back into place, which removes anything that was @let
11:58:34 <fjordrunner> I'm tring,..,   count [User ==.*],  but returns syntax error
11:58:38 <fjordrunner> trying
12:00:36 <sphinxo> Could someone explain what this error is and how would I fix it? http://lpaste.net/149880
12:00:55 <sphinxo> ' Couldn't match expected type ‘Word8’ with actual type ‘n’'
12:01:58 <ralu> athan: I am not sure that what we were talking about was rose tree
12:02:19 <puregreen> sphinxo: lastByte has type “n” but should have type Word8, so convert it
12:02:32 <puregreen> bytes i = fromIntegral lastByte : bytes rest
12:02:43 <ralu> It had Cons (Tree a) [Tree a ] insted of Cons a [Tree a]
12:03:00 <puregreen> sphinxo: also, you probably want “quotRem i 256”, not “quotRem i 8”
12:03:23 <sphinxo> Thank you puregreen 
12:07:00 <sphinxo> puregreen: are you sure about 256 rather then 8?
12:07:22 <puregreen> each byte is a number from 0 to 255
12:07:32 <puregreen> > quotRem 10 8
12:07:34 <lambdabot>  (1,2)
12:07:57 <puregreen> quotRem i 8 would return numbers from 0 to 7
12:08:00 <puregreen> so, 3 bits, not 8
12:08:09 <puregreen> quotRem ≠ shift
12:08:15 <sphinxo> hmm
12:08:43 <puregreen> similarly, if you wanted Word32s, you'd do division module 2^32, not 32
12:09:31 <Cale> heh, that's one way to avoid dealing with the difference between quotRem and divMod :D
12:09:48 <sphinxo> ahh yes, you're totally right puregreen 
12:09:51 <Cale> (using WordN types, so there are no negative values to be concerned with)
12:11:21 <Cale> @check (\n m -> divMod n m == quotRem n (m :: Word8))
12:11:23 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test and 1 shrink):
12:11:23 <lambdabot>  1 0
12:11:36 <Cale> @check (\n m -> m /= 0 ==> divMod n m == quotRem n (m :: Word8))
12:11:36 <lambdabot>  : -1: -1:Ambiguous infix expression
12:11:48 <Cale> @check (\n m -> (m /= 0) ==> divMod n m == quotRem n (m :: Word8))
12:11:50 <lambdabot>  Couldn't match expected type ‘Test.QuickCheck.Safe.SProperty’
12:11:50 <lambdabot>  with actual type ‘(Word8, Word8)’ In the second argument of ‘(==)’, namely ‘...
12:11:58 <Cale> oh, haha
12:12:03 <Cale> @check (\n m -> (m /= 0) ==> (divMod n m == quotRem n (m :: Word8)))
12:12:04 <lambdabot>  +++ OK, passed 100 tests.
12:12:37 <sphinxo> How can I pass in a [Word8], rather then a Word8, like so? http://lpaste.net/149885
12:12:54 <sphinxo> oh wait
12:13:05 <sphinxo> silly mistake
12:20:09 <joshkirklin> debugging the type errors that happy produces has to be just about the most painful thing I've done in haskell. does anyone have any tips to ease the process?
12:28:13 <Wizek> Hey! A quick question! Anyone knows if with Haste it is possible to call into the Client code just like calling into Server code through its RPC API?
12:34:21 <efkf> hmm if I use Frames to open more than one CSV with the same column header, the script won't compile due to multiple declarations
12:36:18 <Yuras> efkf: it is pretty common for "type safe" packages...
12:36:53 <efkf> Yuras drat what do people do about this usually?
12:37:47 <dzdcnfzd> I've got this application that makes a bunch of http requests to the same site (reddit). I've been using Network.HTTP.Conduit's simpleHttp function till now, but now I want to start reusing connections. I'm trying to figure out if I should be wrapping everything in the ResourceT monad, or passing connections managers via function calls, or what
12:37:53 <Yuras> efkf: I usually just switch to better tools
12:37:59 <dzdcnfzd> I have some code up here: http://lpaste.net/149886
12:38:23 <efkf> Yuras the python scripters are going to laugh at me when I tell them that my template metaprogramming type safe magic only lets me analyze 1 csv at a time
12:38:57 <efkf> Yuras better tools such as?
12:40:08 <Yuras> efkf: and your "MonadRedis m => m a" lets you use only one redis connection. and your "MonadLogger m => m a" lets you use only one logger...
12:40:45 <efkf> Yuras MonadRedis? are you talking to someone else?
12:40:50 <Yuras> efkf: IIRC cassava packages works better, though I don't remember the last time I used it
12:41:07 <liste> efkf in cases where a library generates two types with conflicting fields, I usually generate them in different modules
12:41:56 <liste> (works for defining records with conflicting field names in general)
12:42:02 <Yuras> efkf: MonadRedis is just an example of other "type safe" API design with the same issue. sorry, not actually related to your case
12:42:18 <efkf> liste yeah, but these are just CSVs i'm loading for data analysis.
12:42:54 <efkf> liste seems a bit overkill to build multiple modules because loading two CSV files is giving me a name clash
12:46:57 <efkf> Yuras seems like insane impractical design. lot of good type safety does when i can't get my data loaded :P
12:47:27 <efkf> i think there's some new record thing in the next GHC that's supposed to fix the name clashes right?
12:48:46 <Cale> efkf: What's Frames?
12:49:01 <Cale> oh, a library on hackage
12:49:11 <Cale> Why not just use another CSV library which doesn't do such things?
12:49:50 <Cale> If you want simple CSV reading, there are much simpler libraries for that :P
12:50:06 <bitemyapp> efkf: just use cassava
12:50:12 <Cale> yeah
12:50:14 <efkf> how do you use the prelude/base module explicitly? Anything better than "import Prelude as P"?
12:50:22 <efkf> Cale acowley's data frame thing
12:50:24 <bitemyapp> efkf: http://howistart.org/posts/haskell/1
12:50:40 <efkf> Cale was promising but doesn't seem like it's maintained developed now
12:50:55 <Cale> Sorry which?
12:51:00 <efkf> Cale particularly to keep up with the flexibility of things like dplyr happening in R
12:51:08 <Cale> (I think you autocompleted my name instead of typing the name of a package)
12:51:16 <efkf> https://github.com/acowley/Frames
12:51:35 <hexagoxel> lyxia: i think that the high alloc/time numbers for (>>=) are indeed false; my current approach is to put any new monad into its own module and put {-# OPTIONS_GHC -fno-prof-auto -fno-prof-cafs #-} just for that module.
12:51:46 <efkf> there was a popular talk on it a while back https://www.youtube.com/watch?v=2-JFkv9-JOQ
12:51:59 <Cale> ah
12:52:10 <Cale> efkf: Do you have ridiculously large CSV files or something?
12:52:57 <Cale> I would normally look at a library like this, and see things like:
12:52:59 <Cale> meltRow' :: forall proxy vs ts ss. (vs ⊆ ts, ss ⊆ ts, vs ~ RDeleteAll ss ts, Disjoint ss ts ~ True, ts ≅ (vs ++ ss), ColumnHeaders vs, RowToColumn vs vs) => proxy ss -> Record ts -> [Record (("value" :-> CoRec Identity vs) : ss)]
12:53:13 <Cale> and be like "haha, nope, let's try something else for now!"
12:53:15 <efkf> "while back" by haskell standards. Also "popular" by haskell standards...
12:53:34 <efkf> Cale sometimes. I mean it's not uncommon to work with things with hundreds of columns
12:53:34 <sphinxo> Say I have a list of corrosponding datatypes to numbers
12:53:46 <Cale> efkf: Hundreds of columns is not a problem
12:53:47 <sphinxo> eg RAX = 0, RBX = 1, etc
12:54:02 <Cale> efkf: It's more like, do your CSV files fit in RAM?
12:54:04 <efkf> Cale shouldn't be, but it is if I'm defining ADTs by hand
12:54:08 <sphinxo> What is the most idiomatic way of storing this infomation and in haskell?
12:54:15 <sphinxo> s/and//
12:54:16 <efkf> Cale yes they do. Frames is meant for in-memory anyway.
12:54:30 <liste> sphinxo are RAX, RBX types or values?
12:54:51 <efkf> Cale at least most of these do for now... there may be cases down the line where they don't. but for now i'm looking for drop-in workflow alternative to python pandas or  R data frame + dplyr
12:54:52 <sphinxo> types I think? as data Register = RAX | RBX 
12:54:53 <liste> so is it "data RAX = RAX; data RBX = RBX" or "data Register = RAX | RBX" ... ?
12:54:55 <Cale> Well, this "streamed from disk" feature you probably won't get in the simpler CSV libraries
12:55:02 <liste> sphinxo they are values
12:55:06 <sphinxo> Oh :)
12:55:13 <liste> (data constructors to be exact)
12:55:15 <Cale> (though there is cassava-conduit)
12:55:26 <liste> Register is the type
12:55:30 <Cale> http://hackage.haskell.org/package/cassava
12:55:33 <sphinxo> Ahh ok, makes sense
12:55:40 <liste> sphinxo then look to Enum type class
12:55:45 <liste> and maybe Bounded
12:55:50 <efkf> Cale Yeah I'm looking at cassava. I don't get that notation you were doing with meltRow. What was that?
12:55:53 <Cale> It's very simple, no type-level computation BS to deal with :)
12:56:02 <Cale> That was a type signature of something from Frames
12:56:11 <liste> @let data Register = RAX | RBX deriving (Show, Enum, Bounded)
12:56:13 <lambdabot>  Defined.
12:56:20 <liste> > fromEnum RAX
12:56:22 <lambdabot>  0
12:56:23 <Cale> I don't actually know what it means (I could probably figure it out, but I don't want to right now)
12:56:24 <liste> > fromEnum RBX
12:56:26 <lambdabot>  1
12:56:52 <sphinxo> What about if I have something like data Register = RAX | EAX  | AX | AH |  AL | etc
12:57:00 <sphinxo> oh wait
12:57:19 <sphinxo> I've got to implement enum for each value?
12:57:25 <sphinxo> that makes sense
12:57:30 <liste> deriving Enum does the trick
12:57:45 <Cale> efkf: But they're basically doing a bunch of type level computation hackery
12:58:02 <sphinxo> Problem is it doesn't work 1, 2, 3, 4
12:58:02 <Cale> efkf: Of the sort which you'd more expect to see in a dependently typed language
12:58:13 <efkf> Cale i get the feeling these terms like "row polymorphism" or "liquid haskell" might be useful for these data-derived record things, but I haven't learned what they are yet.
12:58:17 <Cale> efkf: You can sorta get away with it in Haskell, but it'll make you lose your hair
12:58:28 <hodapp> what if you have none?
12:58:38 <hodapp> does it mean that I don't have to shave beforehand?
12:58:44 <Cale> haha
12:58:56 <liste> sphinxo if you want 1,2,3... instead of 0,1,2... you can define your own "registerNumber :: Register -> Int; registerNumber x = fromEnum x + 1
12:58:56 <Cale> If you have no hair, maybe you start losing teeth instead, I don't know
12:59:13 <hodapp> ...oh
12:59:22 <sphinxo> liste: it doesn't follow any pattern( not ordered)
12:59:30 <sphinxo> eg 1, 4, 5, 1 maybe
12:59:45 <liste> sphinxo then you need to just implement the function yourself
13:00:08 <sphinxo> ahh ok
13:00:09 <efkf> different question. Is there a good way to do lattice charts like https://geokook.files.wordpress.com/2012/12/rlpspec_allbench.png?w=560&h=560 in haskell?
13:00:51 <Cale> I don't know if there's something which is already built to do that particular type of chart...
13:00:51 <efkf> other than FFI to python or R?
13:01:22 <Cale> However, there is a diagrams backend for the library called Chart
13:01:34 <efkf> it's more of a general class of chart in which dimensions is mapped to facets
13:01:58 <Cale> Chart does a bunch of various types of charts, and diagrams is a very general library for composing drawings however you'd like
13:02:12 <Cale> So I'd expect combining together a bunch of charts like that into a grid wouldn't be too hard
13:02:19 <efkf> Chart has the right syntax (composability), but I haven't seen that it's feasible to do chart faceting like that
13:03:31 <Cale> You might have to build something, but the part you have to build shouldn't be very many lines of code.
13:04:13 <Cale> (like, under 10 lines, I expect)
13:10:02 * hackagebot mvc 1.1.1 - Model-view-controller  https://hackage.haskell.org/package/mvc-1.1.1 (GabrielGonzalez)
13:18:09 <ReinH> Cale: o/
13:19:05 <ReinH> Well, Chart is built on diagrams, and diagrams has functionality for grids of things iirc
13:20:02 * hackagebot lifted-async 0.8.0.1 - Run lifted IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/lifted-async-0.8.0.1 (MitsutoshiAoe)
13:20:19 <efkf> ReinH sure. haven't seen any examples of faceted charts though. mostly fractals...
13:20:38 <efkf> although i'm sure it's doable in theory
13:23:12 <Cale> ReinH: yes
13:25:04 <ReinH> well yes, no examples of faceted charts, but examples of charts and exameples of putting diagrams into grids...
13:26:10 <ReinH> Similarly, I've never seen that sentence before, but I have examples of words and I have examples of English grammar...
13:26:49 <ReinH> on a serious note, this sort of compositionality is exactly why diagrams is such a good library
13:47:29 <efkf> has anything happened with TDNR with ghc 7.10+ or 8+?
13:47:45 <wdav> efkf: what's the difference between a lattice chart and a simple line graph?
13:49:36 <efkf> wdav a lattice chart has multiple graphs with a selected dimension mapping either to the horizontal or vertical layout of graphs
13:49:46 <efkf> alternatively, the faceting can represent a single dimension
13:50:12 <geekosaur> efkf, the closest thing to TDNR that has happened is https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/OverloadedLabels (8.0)
13:50:14 <efkf> see how they're specified compositionally in R http://docs.ggplot2.org/0.9.3.1/facet_grid.html
13:50:22 <efkf> wdav and http://docs.ggplot2.org/0.9.3.1/facet_wrap.html
13:51:48 <efkf> geekosaur darn i'm on 7.10.3 still
13:52:41 <geekosaur> 8.0 is only available in a release candidate with known problems including a severe performance issue with guards
13:54:00 <efkf> geekosaur yeah i'm staying away for now
13:54:38 <efkf> too bad. data munging a few CSVs still carries some overhead..
13:59:45 <wdav> efkf: is this what you mean by faceting: In geometry, faceting (also spelled facetting) is the process of removing parts of a polygon, polyhedron or polytope, without creating any new vertices.
14:00:24 <wdav> maybe i should spend time with R to become familiar with this terminology
14:04:58 <efkf> wdav no not that kind of faceting
14:05:33 <efkf> wdav see http://docs.ggplot2.org/0.9.3.1/facet_grid.html
14:14:21 <AleXoundOS> Hi. How can I get started with Haskell on MIPS architecture?
14:20:05 * hackagebot swish 0.9.1.6 - A semantic web toolkit.  https://hackage.haskell.org/package/swish-0.9.1.6 (DouglasBurke)
14:22:36 <Axman6> AleXoundOS: you probbly can't, unless one of the non-GHC compilers is available for it
14:23:04 <AleXoundOS> Axman6, I have GCC for MIPS
14:23:38 <Axman6> that doesn't help, GHC can't compile Haskell
14:23:51 <geekosaur> you mean gcc, I presume
14:24:15 <Axman6> uh, yes =)
14:24:18 <geekosaur> for mips I think you'd have to do the long form cross-compile to get a (slow unregisterised) ghc
14:24:28 <Axman6> I definitely write GHC much more often than GCC :P
14:24:43 <geekosaur> yeh, I make that typo rather a lot too
14:25:27 <geekosaur> anyway you'd need to build a custom ghc on a supported platform, in unregisterised mode; it will write out portable (and dog slow) ANSI C that can be compiled on the target
14:25:54 <geekosaur> then you run it on itself to get a stage1 compiler as C source
14:26:26 <geekosaur> it's moderately painful and the resulting compiler will be missing a number of features (including ghci)
14:26:35 <AleXoundOS> I found some debian packages related to ghc and haskell for mips. Will these packages suffer same performance issue?
14:27:05 <AleXoundOS> https://packages.debian.org/search?suite=default&arch=mips&searchon=names&keywords=ghc
14:27:10 <geekosaur> oh, llvm supports mips, you can use that way to get a somewhat smarter crossbuild
14:27:20 <vikingofrock> So is there an equivalent to "maybe" for dealing with empty lists? Something like b -> ([a] -> b) -> [a] -> b. So someFunc 0 head [] would be 0, and someFunc 0 [1,2,3] would be 1
14:27:22 <geekosaur> take a look at how people use llvm to build for arm
14:27:39 <vikingofrock> it'd be easy enough to define, but I don't want to reinvent the wheel if its already a well-known function
14:27:56 <Axman6> vikingofrock: foldr is the list equivanent to maybe
14:28:08 <Axman6> both are catamorphisms
14:28:21 <Axman6> :t foldr
14:28:23 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:28:44 <Axman6> (replace t a with [a] there)
14:29:20 <vikingofrock> Hmmm interesting. So how would you write the head example?
14:29:21 <Axman6> > foldr const 0 []
14:29:22 <ReinH> vikingofrock: you can use fromMaybe x . listToMaybe or write your own
14:29:24 <lambdabot>  0
14:29:27 <Axman6> > foldr const 0 [1,2,3]
14:29:29 <lambdabot>  1
14:29:32 <acertain> is there a `ST s a -> State# s` function somewhere? I'd like to use ST with MutVar#
14:29:35 <AleXoundOS> geekosaur, I didn't know about performance issue on MIPS. Will LLVM compiled haskell be slow on MIPS? The MIPS machine I have has only 16m of ram and slow processor.
14:29:37 <ReinH> That's nice though
14:29:46 <vikingofrock> welp my mind is blown. Thanks!
14:29:48 <johnw> > foldr const 0 (Just 10)
14:29:49 <lambdabot>  10
14:29:57 <acertain> or does UNPACK work on STRefs?
14:30:18 <Axman6> acertain: at should work on STRefs
14:30:24 <Ultra> Hi there, I have legacy code to run, am not familiar with Haskell - is it good place to ask for help?
14:30:43 <Axman6> but remember that's just unpacking th pointer to the value, not the value itself
14:30:59 <vikingofrock> Axman6: mind if I submit that to /r/haskelltil?
14:31:16 <geekosaur> AleXoundOS, Iwould expect llvm cross-compile to be reasonable. it's the old-style (unregisterised) cross-build that would be very slow
14:31:17 <Axman6> vikingofrock: if you like, it's quite well known though =)
14:31:41 <geekosaur> there *are* still issues with getting llm to produce optimal code, but it still does better than unregisterised
14:31:51 <Axman6> AleXoundOS: that machine sounds like a very bad machine to be running haskell programs on, you'll almost certainly need more RM than that
14:31:54 <Axman6> RAM*
14:32:37 <geekosaur> (LLVM IR works best with clang, and it doesn't really know how to optimize native codegen for ghc's STG-based output)
14:32:57 <Ultra> Please help with "not in scope: mconcat" http://lpaste.net/149950
14:33:03 <AleXoundOS> ok, so maybe it would be better for me to stick to some DSL based on haskell to generate fast C
14:33:12 <Axman6> Ultra: import Data.Monoid (mconcat)
14:33:27 <Ultra> >>  (mconcat) thats what I've forgot to add
14:33:47 <Axman6> AleXoundOS: yep, there's a few really nice ones - Copilot, Atom, Ivory and Tower are some examples used for real0time embedded systems
14:34:07 <AleXoundOS> Axman6, geekosaur, ok, thank you
14:34:09 <Axman6> Ultra: you can leave off the (mconcat) bit if you like
14:34:36 <Ultra> @Axman6 without it it was giving error
14:34:36 <lambdabot> Unknown command, try @list
14:34:44 <Axman6> that's strange
14:34:53 <Ultra> Axman6: wanna see it?
14:35:07 <Axman6> because leaving it off just says import everything - maybe there was a naming conflict
14:35:12 <Axman6> nah I believe you =)
14:35:51 <Ultra> amatecha: my bad, it works without (mconcat)
14:36:01 <Ultra> Axman6: my bad, it works without (mconcat)
14:39:57 <Ultra> Anyone had problem " failed during the final install step." probably due to lack of licence files?
14:41:13 <Axman6> can you paste the error on lpaste?
14:41:17 <Axman6> @where lpaste
14:41:17 <lambdabot> http://lpaste.net/
14:43:47 <vikingofrock> Axman6: I thought about the foldr thing a little more--what happens if I have a function which doesn't fold nicely? Like what if I want someFunc 0 geometricMean [1,3,9] == 3, and someFunc 0 geometricMean [] == 0?
14:46:00 <Axman6> > let mean x (sm, cnt) = (xm+x,cnt+1) in (\(sm,cnt) -> if cnt == 0 then 0 else  sm/cnt) $ foldr mean (0,0) []
14:46:02 <lambdabot>      Not in scope: ‘xm’
14:46:02 <lambdabot>      Perhaps you meant one of these:
14:46:02 <lambdabot>        ‘x’ (line 1), ‘sm’ (line 1),
14:46:11 <Axman6> > let mean x (sm, cnt) = (sm+x,cnt+1) in (\(sm,cnt) -> if cnt == 0 then 0 else  sm/cnt) $ foldr mean (0,0) []
14:46:13 <lambdabot>  0.0
14:46:18 <Axman6> > let mean x (sm, cnt) = (sm+x,cnt+1) in (\(sm,cnt) -> if cnt == 0 then 0 else  sm/cnt) $ foldr mean (0,0) [1,2,3]
14:46:20 <lambdabot>  2.0
14:46:59 <Axman6> > let mean x (sm, cnt) = (sm+x,cnt+1) in map (\(sm,cnt) -> if cnt == 0 then 0 else  sm/cnt) $ scanr mean (0,0) [1,2,3]
14:47:01 <lambdabot>  [2.0,2.5,3.0,0.0]
14:47:10 <Axman6> > let mean x (sm, cnt) = (sm+x,cnt+1) in map (\(sm,cnt) -> if cnt == 0 then 0 else  sm/cnt) $ scanr mean (0,0) [1..10]
14:47:12 <lambdabot>  [5.5,6.0,6.5,7.0,7.5,8.0,8.5,9.0,9.5,10.0,0.0]
14:47:38 <Axman6> (scanl is probably more useful here, giving the running average)
14:51:08 <vikingofrock> let geomean x (sm, cnt) = (sm*x, cnt+1) in map (\(sm,cnt) -> if cnt == 0 then 0 else sm^^(1/cnt)) $ scanr geomean (0,0) [1,3,9]
14:51:54 <vikingofrock> > let geomean x (sm, cnt) = (sm*x, cnt+1) in map (\(sm,cnt) -> if cnt == 0 then 0 else sm^^(1/cnt)) $ scanr geomean (0,0) [1,3,9]
14:51:55 <lambdabot>      Could not deduce (Eq b0) arising from a use of ‘==’
14:51:56 <lambdabot>      from the context (Fractional b)
14:51:56 <lambdabot>        bound by the inferred type of it :: Fractional b => [b]
14:56:15 <bharathmr> Hi I was trying to stack build a project and I end up with the following error . http://lpaste.net/149990
14:56:48 <bharathmr> The contents of the stack.yaml is also in lpaste
14:57:44 <bharathmr> Can somebody help me figure out whats going wrong?
15:00:39 <geekosaur> the nightly you are pointing at does not have the specified versions of those packages
15:02:13 <ReinH> bharathmr: any particular reason you're using a nightly from three months ago?
15:02:14 <geekosaur> if you're going to specify a resolver then you must either use the package versions in that resolver or point to later versions in stack.yaml so it won't get them from the resolver... but that can break other packages that you *do* get from the resolver
15:02:14 <bergmark> extra-deps overrides that, but bharathmr it looks like some important files got deleted or corrupted
15:03:24 <bharathmr> The build dependencies are part of a homework and they are using the nightly from 3 months ago.
15:03:58 <ReinH> Well, that does seem like a particular reason.
15:04:29 <bharathmr> @ReinH :)
15:04:29 <lambdabot> Unknown command, try @list
15:04:54 <bergmark> bharathmr: i would delete .stack-work, try again, and if that doesn't help, delete ~/.stack
15:05:32 <ReinH> and if that doesn't work, delete ~ (don't do this)
15:05:46 <bharathmr> i am trying to understand the problem. THe reason it is failing is because there is a version mismatch?
15:05:54 <ReinH> and if that doesn't work, throw your computer in the dumpster and set it on fire.\
15:05:58 <bharathmr> i.e. the versions are not constrained enough?
15:06:17 <ReinH> bharathmr: it appears that you have extra-deps whose transitive dependencies are not included in the resolver's list
15:06:23 <ReinH> perhaps because they are a newer version
15:06:45 <bergmark> ReinH: i don't think that's it, those error messages don't look like that
15:06:50 <ReinH> bergmark: no? Ok
15:09:07 <bharathmr> Let me try delete .stack-work and try again
15:09:25 <haskell-learner> hi
15:09:29 <bergmark> incosistent dependencies look something like this: http://lpaste.net/149991 next to impossible to debug :-(
15:09:35 <haskell-learner> can anyone explain this syntax to me
15:09:41 <haskell-learner> map (map (+1))[[1,2,3],[4,5]]
15:09:53 <ReinH> haskell-learner: what part is confusing?
15:10:11 <haskell-learner> how are those functions applied
15:10:21 <haskell-learner> what function is applied first
15:10:28 <ReinH> map (map (+1)) [[1,2,3], [4,5]]
15:10:35 <ReinH> = (map (map (+1))) [[1,2,3], [4,5]]
15:10:57 <bharathmr> Is there something that I can do that can help to understand what is going wrong. I did run it with a -v option, but it does not give any more information
15:11:01 <M-radix> is anyone aware of a practical example of usage of makeClassy? The lens Turtle example uses it but I'm not sure it's actually making use of the typeclasses in any meaningful way
15:11:02 <ReinH> function application is left-to-right.
15:11:29 <M-radix> wait. no. I just noticed the instance HasPoint for Turtle.
15:11:36 <ReinH> M-radix: https://github.com/ekmett/quine/blob/07dcf213172eabdc07a53eecffb549aba58ee604/src/Quine/Options.hs#L38
15:11:41 <haskell-learner> so the first map
15:11:44 <ReinH> M-radix: Ed makes pretty heavy use of makeClassy throughout that project
15:11:54 <M-radix> ReinH_: Oh, thanks. more examples help :)
15:11:59 <haskell-learner> puts map (+1) inside the array
15:12:10 <haskell-learner> then the second map
15:12:24 <haskell-learner> maps (+1) to the elements inside
15:12:30 <ReinH> map (map (+1)) changes map (+1) :: Num a -> [a] -> [a] into Num a -> [[a]] -> [[a]]
15:12:38 <ReinH> :t map (+1)
15:12:40 <lambdabot> Num b => [b] -> [b]
15:12:42 <ReinH> :t map (map (+1))
15:12:43 <lambdabot> Num b => [[b]] -> [[b]]
15:13:14 <haskell-learner> my head is aching >_<
15:13:25 <ReinH> it lifts a function that maps (+1) on list elements to a function that maps (mapping (+1) on list elements) on list elements, so it maps (+1) on the elements inside the lists inside the list.
15:13:37 <ReinH> I'm pretty sure that did not help.
15:13:49 <ReinH> Another way to look at it is:
15:13:51 <ReinH> :t map
15:13:52 <lambdabot> (a -> b) -> [a] -> [b]
15:13:54 <ReinH> :t map . map
15:13:55 <lambdabot> (a -> b) -> [[a]] -> [[b]]
15:14:01 <ReinH> map (map f) maps f twice
15:14:07 <ReinH> onto elements inside lists inside lists
15:14:19 <ReinH> map . map . map maps onto elements inside lists inside lists inside lists
15:14:21 <ReinH> and so on
15:14:29 <haskell-learner> >_< 
15:14:30 <johnw> i wouldn't really say it maps 'f' twice...
15:14:42 <ReinH> sure
15:14:48 <johnw> it maps 'map f', and that maps 'f'
15:14:52 <ReinH> that's true
15:15:19 <ReinH> M-radix: btw it's also a ridiculously cool project
15:15:39 <M-radix> ReinH: Quine is, you mean?
15:16:04 <ReinH> M-radix: yeah
15:17:23 <M-radix> Yeah, I have looked at the screenshots before, but never the code
15:17:24 <M-radix> they're pretty :)
15:18:08 <suzu> hi all, i'm looking for some help getting stack to work. anybody around?
15:18:12 <haskell-learner> I still can't get it
15:18:15 <haskell-learner> i feel stupid now
15:18:26 <ReinH> suzu: you should just ask your question
15:18:41 <suzu> okay
15:18:52 <suzu> so i made a new project with stack. nothing in it. it builds and executes fine
15:19:03 <ReinH> haskell-learner: map f takes f :: a -> b and turns it into a function [a] -> [b] that is applied ot each element of the list
15:19:07 <suzu> i try `stack test` and that works too
15:19:17 <suzu> so now i go and add quickcheck to the cabal file
15:19:21 <suzu> and try stack test again
15:19:43 <suzu> and it says it can't find quickcheck anywhere
15:19:54 <suzu> and gives me no recommendation on what to do
15:20:00 <suzu> adding quickcheck to extra-deps in the stack.yaml doesnt help
15:20:02 <haskell-learner> that much i get it
15:20:04 <haskell-learner> then?
15:20:16 <suzu> am i doing something wrong?
15:20:55 <ReinH> haskell-learner: map (map f) takes that function [a] -> [b] and turns it into a function [[a]] -> [[a]] that applies map f to each element of a list
15:21:10 <ReinH> map f applies to a list, map (map f) applies to a list of lists
15:21:17 <haskell-learner> okey :) thanks
15:21:53 <ReinH> suzu: well, the package name is QuickCheck, notquickcheck
15:21:56 <ReinH> *not quickcheck
15:23:32 <suzu> lol im a dumbass
15:23:35 <suzu> thanks a lot ReinH !
15:23:38 <suzu> that fixed it
15:23:39 <suzu> <_<
15:23:39 <ReinH> yw
15:24:03 <WarDaft> Any wizards about? I'm working on a pet project that requires some very unsafe things be done with arrays, and two hours of digging through the array docs has convinced me I need to ask for help.
15:24:07 <ReinH> We should create a package alias, which I suppose would involve creating the package aliasing feature...
15:24:28 <suzu> would it be bad to send a PR to add a reminder to check the casing when stack can't find a package?
15:24:34 <ReinH> WarDaft: the sooner you actually ask your question, the sooner you people can answer it
15:25:03 <ReinH> suzu: Well, you can certainly send the PR.
15:25:31 <ReinH> If you wanted to work a bit harder, you could suggest packages within a small edit distance as alternatives ;)
15:25:40 <ReinH> s/you people/people
15:25:52 <suzu> haha idk if i could even write that yet
15:25:58 <suzu> still climbing newbie mountain here
15:26:06 <WarDaft> Well, I need to purely obtain a mutable array, and the same token has to be able to create multiple distinct mutable arrays. I need to write to it purely, but I think I've got that.
15:26:36 <ReinH> suzu: sounds like a fun problem. You could start with just a function that sorts a word list by edit distance from another word :)
15:26:41 <exio4> WarDaft: you probably want to work with Vector 
15:27:01 <suzu> hmmmMM
15:27:05 <suzu> ill maybe try that later
15:27:10 <suzu> right now i want to play with this quickcheck thing
15:27:15 <suzu> :D
15:27:20 <ReinH> suzu: which involves sortBy and editDistance, one of which exists and the other you could write. It would be fun :)
15:27:32 <ReinH> suzu: *QuickCheck thing
15:27:34 * ReinH ducks
15:27:41 <suzu> QuickCheck thing*
15:27:41 <WarDaft> I'm pretty sure that's not a good fit, I'm trying to build something like a hash table, so I need to write to it in O(1)
15:28:06 <ReinH> WarDaft: any particular reason for reinventing this wheel?
15:28:32 <WarDaft> I'm going to embed all of the keys solely in the type, so that it's a free perfect hash.
15:28:33 <Gurkenglas> :t liftM fromJust . runMaybeT . many . MaybeT -- How could this unfold be made lazy?
15:28:34 <lambdabot> Monad m => m (Maybe a) -> m [a]
15:30:35 * hackagebot ncurses 0.2.15 - Modernised bindings to GNU ncurses  https://hackage.haskell.org/package/ncurses-0.2.15 (JohnMillikin)
15:31:07 <fr33domlover> Suppos I need to allocate 256 resources of the same type. If I use 'bracket' for that I get 256 nested functions, is that generally an issue with the call stack having O(n) size? e.g. what if I had 1000 resources etc. If yes, does ResourceT solve this problem?
15:31:34 <WarDaft> I'm pretty sure I can make it O(1) read and write to both new and old references to the table.
15:34:33 <bharathmr> I removed .stack-work and ran the build again. I end up with the error again. The full output is here -> http://lpaste.net/150010
15:34:44 <bharathmr> anything I can do to fix this?
15:35:49 <suzu> maybe check what /Users/bharathmr/pr/acads/pl/hw1/.stack-work/logs/GLFW-0.5.2.4.log says?
15:36:31 <bharathmr> suzu: Nothing. Its the same error. 
15:36:36 <suzu> oh :(
15:36:51 <bharathmr> suzu: http://lpaste.net/150015
15:39:08 <glguy> bharathmr: The state for that resolver is in this path /Users/bharathmr/.stack/snapshots/x86_64-osx/nightly-2015-09-24/7.10.2/pkgdb/
15:39:43 <johnw> fr33domlover: ResourceT or SafeT would make that pattern a bit easier
15:40:01 <bharathmr> glguy: newbie here. What should I look for in the folder?
15:42:17 <glguy> bharathmr: You could check which packages are broken: ghc-pkg -f $THATPATH check
15:42:23 <glguy> and then unregister the broken ones
15:42:43 <glguy> ghc-pkg -f $THATPATH unregister some-package-name
15:43:12 <glguy> It's possible that deleting the whole snapshot could work, but I don't have a lot of experience debugging stack either way
15:44:44 <bharathmr> glguy: I am only using stack. So instead of ghc-pkg -f $THATPATH check, I ran stack exec ghc-pkg -f $THATPATH check
15:44:58 <bharathmr> I am not able to find ghc-pkg 
15:47:24 <glguy> It looks like the "stack path" command will tell you where your GHC is hidden
15:47:48 <bharathmr> glguy: http://lpaste.net/150034
15:48:04 <glguy> bharathmr: the haddock issues don't matter
15:48:20 <bharathmr> glguy: yeah. there is no other error
15:49:16 <fr33domlover> johnw, thanks. I also found the 'managed' packages but it seems to be a pretty way to do things the bracket way, so I think it would fill the stack the same way bracket could :P
15:49:36 <bharathmr> glguy: Should I have something installed through homebrew to make sure OpenGL compiles?
15:49:44 <fr33domlover> That's the only issue, I have a solution for the aesthetic aspect
15:49:50 <johnw> fr33domlover: the ResourceT way fills a Map inside an IORef, and only has one exception handler
15:51:59 <glguy> bharathmr: I'm surprised at some of the things you have listed in your extra-deps
15:52:07 <glguy> bharathmr: arent some of those already in stackage?
15:52:07 <aweinstock> :t let substitutionDistance xs ys = length . filter id $ zipWith (==) xs ys in sortBy (compare `on` substitutionDistance)
15:52:08 <lambdabot> (Eq a, Ord ([a] -> Int)) => [[a]] -> [[a]]
15:52:45 <bharathmr> glguy: They were given as part of a homework :). Is there something wrong with them?
15:52:46 <aweinstock> :t let substitutionDistance xs ys = length . filter id $ zipWith (==) xs ys in sortBy (compare `on` substitutionDistance) . zip
15:52:47 <lambdabot>     Couldn't match type ‘[b0] -> [(a1, b0)]’ with ‘[[a]]’
15:52:47 <lambdabot>     Expected type: [a1] -> [[a]]
15:52:47 <lambdabot>       Actual type: [a1] -> [b0] -> [(a1, b0)]
15:53:29 <glguy> bharathmr: were you given that exact resolver and set of extradeps?
15:54:38 <bharathmr> glguy: http://lpaste.net/150035. This was the stack.yaml given
15:55:17 <dzdcnfzd> Looking at the documentation for Network.HTTP.Client.Conduit.withManager, I see that the type is withManager :: MonadIO m => ReaderT Manager m a -> m a
15:55:37 <dzdcnfzd> and the description of the function is Get a new manager with defaultManagerSettings and construct a ReaderT containing it.
15:55:39 <glguy> bharathmr: It lists some packages that are already in that resolver and then also alternate versions of packages in that resolver
15:55:45 <dzdcnfzd> here: https://hackage.haskell.org/package/http-conduit-2.1.8/docs/Network-HTTP-Client-Conduit.html
15:56:21 <dzdcnfzd> How does that function result in a ReaderT if it takes a ReaderT and returns an m a?
15:56:42 <geekosaur> dzdcnfzd, that's not quite the right way to read that
15:56:55 <geekosaur> the key is that a ReaderT is effectively a *function*
15:57:14 <aweinstock> :t let substitutionDistance xs ys = length . filter id $ zipWith (==) xs ys in (\z -> sortBy (compare `on` substitutionDistance z)) -- suzu
15:57:15 <lambdabot> Eq a => [a] -> [[a]] -> [[a]]
15:57:16 <geekosaur> so it's withManager :: (a computation in ReaderT) -> (the result of that computation)
15:57:41 <dzdcnfzd> Ah, I see, so it's supplying the manager for the computation
15:57:47 <bharathmr> glguy: I am sorry. I have to read up on how resolver works. Is there some way I can figure out what are the alternate versions and delete them?
15:58:02 <geekosaur> withManager $ do { here you do stuff in the ReaderT }
15:58:17 <aweinstock> > let substitutionDistance xs ys = length . filter id $ zipWith (==) xs ys in (\z -> sortBy (compare `on` substitutionDistance z)) "this" ["these", "are", "a", "bunch", "of", "words"]
15:58:19 <lambdabot>  ["are","a","bunch","of","words","these"]
15:58:39 <glguy> bharathmr: everything listed on this page is provided by that resolver already http://www.stackage.org/nightly-2015-09-24
16:00:52 <dzdcnfzd> geekosaur: Thanks a lot. I think I can write this thing now.
16:01:00 <geekosaur> also compare
16:01:03 <geekosaur> :t runReaderT
16:01:05 <lambdabot> ReaderT r m a -> r -> m a
16:01:31 <geekosaur> the ReaderT r m a is a function, r is the environment, m a is the result
16:01:54 <geekosaur> @unmtl ReaderT Manager m a
16:01:54 <lambdabot> Manager -> m a
16:02:19 <bharathmr> glguy: So I should remove those from the external dependencies?
16:02:25 <dzdcnfzd> geekosaur: so It's literally just constructing the manager and feeding it in
16:02:36 <geekosaur> yes
16:02:46 <dzdcnfzd> Okay. I see. 
16:03:02 <geekosaur> but feeding it as the environment of a ReaderT, so you'd use `ask` to get it
16:03:13 <glguy> bharathmr: I just did a test build here and it doesn't seem to matter that they're there. I was able ot build the whole set of packages
16:03:17 <glguy> bharathmr: it's just not normal
16:03:24 <dzdcnfzd> Yes
16:03:35 <glguy> so I think you're environment is just in a bad state, but that file ought to work
16:03:38 <glguy> your*
16:04:01 <bharathmr> glguy: Ah! I did delete ~/.stack once and tried installing again
16:04:18 <dzdcnfzd> :t ask
16:04:20 <lambdabot> MonadReader r m => m r
16:04:21 <bharathmr> glguy: Still fails at the same point
16:04:43 <geekosaur> :t do { v <- ask; return $ v + 1 }
16:04:44 <lambdabot> (Num r, MonadReader r m) => m r
16:05:14 <geekosaur> there's some additional cleverness oing on there, ReaderT is an instance of MonadReader
16:06:17 <dzdcnfzd> geekosaur: I successfully put together my first transformer yesterday (ExceptT + IO) without any pain but now I feel I'm going to start seeing some type confusion
16:06:28 <dzdcnfzd> In terms of hoisting and so on
16:06:34 <geekosaur> you might well; it takes some getting used to
16:11:23 <fr33domlover> johnw, ResourceT can work in my case indeed :) But I'm curious, is there a way that doesn't use IORefs or other impure methods? If ConT builds a function gradually then it won't fill the stack while building, but could fill it while running. I don't know enough about this topic to tell how exactly it really works :P
16:13:03 <bharathmr> glguy: Thanks for all the help. let me try uninstalling stack completely and run stack build again.
16:14:49 <johnw> fr33domlover: also, don't assume that Haskell programs use a "stack" in the same way; you'd need to test some of these assumptions by looking at generated code.
16:23:43 <codedmart> How parse a Value with aeson?
16:25:04 <Axman6> codedmart: decode <bytestring> :: Maybe Value IIRC
16:25:25 <dmj> codedmart: fromJSON :: FromJSON a => Value -> Result a
16:25:42 <codedmart> No I have a Value now and want to parse it for some fields.
16:26:03 <Axman6> then dmj has the answer
16:26:14 <codedmart> ok thanks!
16:26:20 <Axman6> (IMO it's not parsing once you already have a Value)
16:26:48 <dmj> Axman6 is right, it's just lookups at that point. codedmart, where are you getting the Value from? 
16:27:20 <few94g> hey does anyone remember that really accessible lens video that was posted on the haskell reddit a few weeks ago?
16:27:28 <few94g> had an example with eye color...
16:27:33 <few94g> i can't seem to find it now
16:31:37 <codedmart> dmj I am wrapping a API but I don't really care about the types in most cases so I use Value, but I do want to get a few fields out of the user (Value).
16:31:57 <dmj> codedmart: ah I see, cool
16:38:40 <dzdcnfzd> I'm struggling to make a function which promotes values into my ReaderT monad
16:38:52 <dzdcnfzd> The inner monad is ExceptT String IO
16:39:31 <dzdcnfzd> and I previously made a hoistExcept = ExceptT . return to get values from IO into that
16:39:35 <Axman6> what do you mean by promote?
16:40:08 <dmj> dzdcnfzd: can you paste your entire stack on lpaste?
16:40:11 <dmj> @where paste
16:40:11 <lambdabot> Haskell pastebin: http://lpaste.net/
16:40:15 <dzdcnfzd> I want to get values that are either IO or ExceptT String IO into ReaderT a (ExceptT String IO)
16:40:53 <Axman6> listIO and lift?
16:40:55 <Axman6> liftIO*
16:40:58 <codedmart> dmj So I need to do fromJSON to get a result then do lookups and fromMaybes?
16:41:14 <codedmart> This seems like a hassle :)
16:41:49 <Gurkenglas> dzdcnfzd, for this kind of question, you can avert much confusion by immediately saying the type signature you want
16:41:50 <dmj> codedmart: yea, it is a bit, something like case result of { Success x -> ..; Partial _ -> ..; Error msg -> ... }
16:42:00 <dzdcnfzd> http://lpaste.net/150071
16:42:14 <dzdcnfzd> dmj: ^
16:43:40 <Gurkenglas> "liftIO", "either throwError return" and "lift", respectively.
16:45:43 <dmj> Gurkenglas: +
16:45:53 * hackagebot stack 1.0.2 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.0.2 (borsboom)
16:46:15 <dzdcnfzd> Gurkenglas: how does the second work?
16:46:19 <dzdcnfzd> I don't get that at all
16:46:44 <Gurkenglas> :t either
16:46:45 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
16:47:08 <Gurkenglas> :t either throwError return -- Which part is not to get?
16:47:10 <lambdabot> MonadError e m => Either e a -> m a
16:47:25 <dmj> it might not be obvious but 'c' there is of kind * -> *
16:47:28 <dzdcnfzd> I don't get how that results in a reader monad
16:47:39 <dzdcnfzd> Oh...
16:47:59 <dzdcnfzd> whaaaa?
16:48:53 <dmj> dmj: well, in the case 'either throwError return' it is
16:49:34 <Gurkenglas> Ah. Any stack that has State or Except or Maybe or Reader or IO in it can lift the stuff that monad provides to the top of the stack using the typeclasses MonadState, MonadError, Alternative, MonadReader and MonadIO, which all the monad transformers are made to pass up the stack they construct
16:50:30 <suzu> whats the current wisdom on trying to make a single page webapp with haskell?
16:50:32 <suzu> is that even a thing
16:50:36 <Gurkenglas> The arbitrary naming is due to a historical clusterfuck :).
16:50:45 * Cale would be super happy if people just stopped using the term "stack" altogether with reference to monad transformers ;)
16:51:32 <Cale> suzu: There are a lot of things you can do. I can give a pretty solid recommendation to using reflex-dom, though the documentation is still quite rough around the edges (we're working on it!).
16:51:36 <Gurkenglas> But it is so alluring! Give us a better word for a chain of monad transformers
16:51:54 <suzu> ok! how do i install it?
16:51:58 <dmj> Cale: the new 'stack' tool should help with this :)
16:52:07 <suzu> (i have stack and ghcjs-0.2.0.20151001_ghc-7.10.2 installed)
16:52:26 <Cale> suzu: see the readme here (just scroll down) https://github.com/ryantrinkle/try-reflex
16:52:44 <suzu> this uses nixos
16:52:54 <suzu> oh wiat no it uses nix only
16:53:12 <suzu> do i need to have nix? i thought stack should be good enough to get anything set up
16:53:18 <Cale> suzu: Yeah, it just uses nix to make sure you have a consistent environment that'll work, since building your own ghcjs is kind of a hassle
16:53:25 <Cale> But you don't have to use nix
16:53:35 <suzu> stack seems to have build ghcjs for me
16:53:41 <suzu> built*
16:53:45 <suzu> and that worked ok
16:54:04 <Cale> (I recommend using try-reflex at first regardless though, just because it's quick and easy to get to the point of being able to do the tutorial and such)
16:54:56 <suzu> is nix going to fuck my system up lol
16:55:18 <Cale> nope
16:55:30 <suzu> hmm, why not?
16:55:43 <Cale> All you have to do to remove it is delete /nix
16:56:04 <Gurkenglas> dzdcnfzd, for example https://hackage.haskell.org/package/transformers-0.5.0.0/docs/Control-Monad-Trans-Maybe.html shows what classes it lifts up its chain of monad transformers (and, if you click on source, how). Notably, it introduces Alternative, and if you look at how the other transformers lift it, you can see that if your chain has MaybeT in it anywhere, you can invoke "empty", as defined by Alternative, to 
16:56:04 <Gurkenglas> lift MaybeT's abortion feature to the top of your chain
16:56:40 <Gurkenglas> (Shows it in the instances block right above mapMaybeT)
16:56:52 <Cale> Gurkenglas: Well, it's actually more about not thinking of the successive application of monad transformers in quite that way. You can form a monad transformer which is a composition of many others...
16:57:23 <Cale> Gurkenglas: But if you're constantly thinking of this "stack" of monads which are being formed as you apply transformers, probably your code is a mess.
16:57:33 <Cale> (or if you feel compelled to think about them)
16:57:40 <dzdcnfzd> Gurkenglas: I'm trying to get this -- just staring at type signatures for a bit
16:57:47 <suzu> is it going to rebuild ghcjs?
16:57:50 <suzu> thats going to take ages
16:57:50 <suzu> T_T
16:57:55 <Cale> suzu: It should get it from the cache...
16:58:01 <suzu> oh ok
16:58:02 <suzu> good
16:58:03 <suzu> !
16:58:10 <suzu> im installing nix atm
16:58:20 <Cale> If it starts building ghcjs, then let me know and we'll figure out why :)
16:58:48 <Cale> (well, more likely I'll whine to Ryan that it's doing this, and he'll figure out why, since I'm hopeless when it comes to nix)
17:00:14 <Cale> suzu: Also note, there's #reflex-frp in case you have any questions later and I don't notice :)
17:06:03 <Gurkenglas> What do you think of the idea of propagating irrefutable pattern matches as far as possible? i.e. when some code says fromJust (f x) and the definition of f only returns Just in one of the cases, then skip matching that pattern. It would make stuff more lazy.
17:10:01 <Cale> Gurkenglas: I'm not 100% sure what you mean about that, if you're evaluating fromJust (f x), then you'll need to evaluate f x
17:11:31 <Gurkenglas> Yes but in the evaluation of f x you can assume that it will produce a Just value and you could use that assumption to rule out some of the lines of the definition of f and save a pattern match
17:13:30 <suzu> Cale: nix shat itself
17:13:37 <Cale> suzu: what's up?
17:13:38 <dzdcnfzd> Well, guys, my code compiles, and it's all thanks to me writing "lift" wherever I got a type error
17:13:44 <dzdcnfzd> or, failing that, return
17:14:01 <suzu> Cale: http://lpaste.net/7002372662009790464
17:14:18 <suzu> im using Arch Linux btw
17:14:34 <Gurkenglas> > fromJust $ uncons undefined -- Like, this should output "(*Exception: Prelude.undefined"
17:14:35 <lambdabot>  *Exception: Prelude.undefined
17:15:16 <dmj> suzu: have you tried stack install reflex-dom ?
17:15:17 <suzu> forkIO undefined
17:15:20 <ryantrinkle> suzu: i've seen that on Arch before
17:15:46 <suzu> ryantrinkle: any ideas?
17:16:01 <suzu> is that an issue internal to nix?
17:16:01 <ryantrinkle> i'll try to find the solution
17:16:15 <ryantrinkle> no, it's something to do with locales
17:16:25 <suzu> oh.. interesting.
17:16:30 <Cale> https://bbs.archlinux.org/viewtopic.php?pid=1551839#p1551839
17:16:42 <python476> don't kick me, I'm searching for the origin of the term `return` (monad).
17:17:10 <Cale> python476: Why would you get kicked for that?
17:17:31 <suzu> how can i 'reset' the try-reflex script?
17:17:34 <suzu> it seems to think nix worked
17:17:47 <Cale> uh, it should be possible to just run it again
17:17:59 <suzu> nope :/
17:18:06 <dzdcnfzd> does anybody know how to view syntastic errors that take more than one line in vim?
17:18:10 <Cale> If it's put you in a weird-looking shell, quit out of that shell
17:18:19 <suzu> nope, didn tget into a weird shell
17:18:23 <dzdcnfzd> as in, I keep getting these lint errors that I can't really view because they get cut off at the end of the line
17:18:27 <python476> Cale: I fear lots of people complained about the name collision with imperative function call/return
17:18:31 <Cale> suzu: also, check my link
17:18:40 <Cale> python476: Well, it's semi-intentional.
17:18:44 <suzu> yep i saw the link
17:18:56 <suzu> first i want to clean up the weird state broken-nix left
17:19:07 <maerwald> dzdcnfzd: you can't fix it afair, I read that on an issue somewhere... I think they blame each other
17:19:08 <Cale> python476: return v after all, is the action which does nothing except to return v, so it's not a terrible name for it
17:19:22 <dzdcnfzd> maerwald: thanks
17:19:27 <ryantrinkle> suzu: the resolution last time didn't involve nix - it was just an environment variable that had to be added
17:19:32 <Cale> python476: It's just that it doesn't have the control behaviour that the return keyword has in imperative languages (calling the continuation of the function)
17:19:34 <suzu> tossing out /nix/ worked
17:19:39 <ryantrinkle> oh, weird
17:19:49 <ryantrinkle> is try-reflex working now?
17:20:14 <maerwald> dzdcnfzd: unless I misunderstood you... if you do :Err you get ofc the whole error, but the linebreaking is all messed up
17:20:16 <suzu> it's re-dling nix now
17:20:26 <suzu> so we'll see soon
17:20:43 <suzu> is all this haskell stuff worth it :<
17:20:46 <python476> Cale: return to the Monad I guess
17:20:56 <python476> to me it looks like an `InDomain`
17:21:00 <python476> or a project
17:21:02 <ryantrinkle> suzu: well, to be fair, this issue only happens on Arch :P
17:21:11 <python476> a return would escape the Monad
17:21:14 <python476> but it's all relative
17:21:20 <suzu> haha ok :D
17:21:27 <Cale> python476: hm? No. The monad isn't like some sort of "context" which you can be in or not.
17:21:41 <suzu> ryantrinkle: is there no stack build process for try-reflex?
17:21:45 <suzu> i have stack and a ghcjs in it working
17:21:45 <Cale> python476: Values of type M t are like programs whose result would have type t when executed.
17:21:48 <maerwald> dzdcnfzd: https://github.com/scrooloose/syntastic/issues/317
17:21:56 <fr33domlover> hmmm wikipedia says CPS with TCO means no call stack is even required
17:22:00 <suzu> thought i would guess having the nix setup has the most reproducibility?
17:22:10 <fr33domlover> so 1000 nested calls to withFile don't grow the call stack?
17:22:11 <Cale> python476: So, return :: t -> M t  takes a value, and produces the program which does nothing except to result in that value when you execute it
17:22:53 <hexagoxel> Gurkenglas: but `undefined :: (Bool, Bool)` does not print "(" either. you would not only be asking the compiler to switch around the pattern matching, but also to "invent" the data constructor.
17:23:10 <ryantrinkle> suzu: you can definitely use stack
17:23:18 <ryantrinkle> there shouldn't be anything unusual about using it
17:23:20 <Cale> python476: The difference between values of type, say, IO String and values of type String, is very much like the difference between /bin/ls and a list of files in your home directory
17:23:30 <ryantrinkle> i prefer nix personally, because (as you said) it is more reproducible
17:23:42 <ryantrinkle> but reflex should work completely with stack
17:23:48 <hexagoxel> so "for any one-constructor type, instead of pattern matching on the constructor, allocate a new constructor, and let its contents be filled by lazy pattern matching on the original value"
17:24:02 <suzu> nix broke again with the same error
17:24:03 <suzu> :/
17:24:12 <ryantrinkle> suzu: i have the solution from last time
17:24:20 <Cale> suzu: Did you do the locale-gen stuff?
17:24:24 <ryantrinkle> export LOCALE_ARCHIVE=&quot;/nix/store/w5is4fda72mrq9pzi51inp9ylp9hbwwx-glibc-locales-2.21/lib/locale/locale-archive
17:24:27 <suzu> yep i regen my locale
17:24:28 <ryantrinkle> that's what the other guy ran to make it work
17:24:31 <Cale> oh, huh
17:24:35 <hexagoxel> Gurkenglas: seems to be a terrible idea regarding allocations.. (and lazy?)
17:24:37 <ryantrinkle> basically, you need a valid LOCALE_ARCHIVE in your environment
17:24:40 <suzu> okay ill try that
17:25:07 <ryantrinkle> export LOCALE_ARCHIVE="/nix/store/w5is4fda72mrq9pzi51inp9ylp9hbwwx-glibc-locales-2.21/lib/locale/locale-archive"
17:25:12 <ryantrinkle> sorry, pasted wrong last time
17:25:16 <ryantrinkle> also, that path may not be right
17:25:27 <ryantrinkle> but surely your system must have a valid locale archive somewhere :P
17:25:36 <Gurkenglas> That's right about the ( not being printed (tho hmm inventing data constructors does seem related), what I'm actually hoping to work if this existed is:
17:26:18 <hexagoxel> Gurkenglas: yeah, i guess you might see it as "more lazy", but it loses the "sharing" property
17:26:32 <suzu> kk trying it
17:26:38 <suzu> its reeeedownloading nix again
17:26:38 <suzu> wee
17:27:12 <ryantrinkle> suzu: you don't need to delete /nix for this; i think it's an error that occurs when constructing the sandbox, after all the nix store stuff is already totally set up
17:27:17 <hexagoxel> ah you mean, if you inline the show instance
17:27:27 <Gurkenglas> > liftM fromJust . runMaybeT . many . MaybeT $ Identity (Just 1)
17:27:31 <lambdabot>  mueval-core: Time limit exceeded
17:27:46 <Gurkenglas> (Which should print [1,1,1...)
17:28:01 <Gurkenglas> *Identity in front of the [
17:28:55 <suzu> hmm
17:29:03 <suzu> ryantrinkle: how do i get stack to work with try-reflex?
17:29:05 <ryantrinkle> suzu: i have a more permanent fix that I think might be good
17:29:12 <ryantrinkle> could you try adding this line to shell.nix?
17:29:21 <ryantrinkle>   LOCALE_ARCHIVE = "${this.nixpkgs.glibcLocales}/lib/locale/locale-archive";
17:29:29 <ryantrinkle> right before the line with: } ""
17:29:30 <suzu> sure. where do i find shell.nix?
17:29:35 <ryantrinkle> in try-reflex
17:29:37 <suzu> oh
17:29:39 <suzu> its in the repo
17:29:40 <suzu> yup
17:29:40 <suzu> ok
17:29:48 <ryantrinkle> this way i won't have to set up an Arch system to test on :P
17:30:03 <ryantrinkle> that *should* override your locale archive with one that's guaranteed to work
17:30:30 <ryantrinkle> if not, i'll have to get set up with an arch vm and hunt the issue down myself
17:30:31 <Gurkenglas> (That composition is unfoldM) As in, this shouldn't wait for the Nothing at the end of the list to invalidate the Just (repeat 1), since thatll just end the unfold instead of nothingifying the result.
17:32:40 <Gurkenglas> > fromJust $ (1:) <$> undefined -- hexagoxel, how about 'Why isn't this "[1*Exception: Prelude.undefined"?'
17:32:42 <lambdabot>  *Exception: Prelude.undefined
17:33:31 <ctrlaltv> Hello Guys. I am pretty new to Haskell and i got a headache trying to do a uni assignment. Regarding State Monad, are there any catches when I use run/eval/execState inside another runState?
17:33:47 <ctrlaltv> Hello Guys. I am pretty new to Haskell and i got a headache trying to do a uni assignment. Regarding State Monad, are there any catches when I use run/eval/execState inside another runState computation*?
17:33:49 <suzu> ryantrinkle: didnt help
17:33:55 <ryantrinkle> suzu: dang
17:34:15 <ryantrinkle> well, can you give me the details on the version of Arch you're using, etc?
17:34:19 <suzu> im pretty sure its occuring in the nix install
17:34:20 <Cale> ctrlaltv: nope, that should be okay, however, usually you wouldn't want to do that
17:34:29 <ryantrinkle> hmm, ok
17:34:42 <suzu> like
17:34:50 <Cale> ctrlaltv: usually you would combine the actions that you want to run using bind (i.e. (>>=)) or do-notation
17:34:51 <ctrlaltv> Cale: thx for the response, why is that?
17:34:54 <suzu> there are no nix* binaries in my path afterwards
17:34:56 <suzu> there's just a /nix/ folder
17:35:07 <Cale> ctrlaltv: and it will thread along the state for you, so you don't have to pass it by hand
17:35:16 <suzu> nor do i even have a ~/.nix-profile dir
17:35:17 <Cale> (that's the whole point of using the State monad)
17:35:38 <suzu> im pretty sure it's nix failing for some reason..
17:35:41 <ryantrinkle> suzu: yeah, perhaps it's failing at the point of creating the .nix-profile directory
17:36:00 <suzu> and then afterwards it deletes the nix tarball it dled
17:36:02 <suzu> :(
17:36:09 <ryantrinkle> that part is OK
17:36:11 <suzu> so i cant try different things to get the nix install to complete
17:36:15 <suzu> without having to redl the thing every time
17:36:20 <ryantrinkle> sure you can :)
17:36:22 <ryantrinkle> just leave /nix in place
17:36:23 <suzu> !
17:36:31 <ryantrinkle> it's fine to retry the install without blowing that away
17:36:37 <ryantrinkle> nix is good at that kind of stuff :)
17:36:38 <suzu> how do i try retrying?
17:36:43 <suzu> just run ./try-reflex again?
17:36:45 <ryantrinkle> yeah
17:36:56 <suzu> > ./try-reflex  If you have any trouble with this script, please submit an issue at https://github.com/ryantrinkle/try-reflex/issues /home/user/experiments/try-reflex/common-setup.sh: line 42: /home/user/.nix-profile/etc/profile.d/nix.sh: No such file or directory
17:36:58 <ryantrinkle> or how about this
17:36:59 <lambdabot>  <hint>:1:1: parse error on input ‘./’
17:37:00 <suzu> lol
17:37:05 <ryantrinkle> let's try the official nix installation instructions
17:37:15 <ryantrinkle> https://nixos.org/nix/download.html
17:37:32 <suzu> curl a script and pipe it to ssh.......
17:37:35 <suzu> sh *
17:37:53 <ctrlaltv> Cale: I am trying to label a Tree in a bfs manner and I am using a State [Int] Monad
17:38:17 <ryantrinkle> suzu: yeah, not my favorite either - that's why i copied that script and put it in try-reflex
17:38:19 <Cale> ctrlaltv: yeah, nothing about that suggests to me that you should have more than one occurrence of runState
17:38:21 <suzu> ryantrinkle: arch has an unofficial nix package that i can install
17:38:29 <ryantrinkle> suzu: yeah, that might work
17:38:42 <ryantrinkle> i've heard about people having trouble with it, though
17:39:02 <suzu> gonna try it
17:39:08 <ctrlaltv> Cale: Does this apply to execState too?
17:39:28 <Cale> ctrlaltv: yes
17:39:33 <ryantrinkle> suzu: in the mean time, if you let me know what version of Arch to get, i'll try it out here
17:39:45 <Cale> ctrlaltv: you should have at most one of runState/execState/evalState in your code
17:40:01 <Cale> ctrlaltv: and just one occurrence of it :)
17:40:12 <suzu> sure
17:40:36 <Cale> ctrlaltv: consider doing something like   label = do (v:vs) <- get; put vs; return v
17:40:37 <suzu> im using Arch 4.3.3-2, on x86_64
17:40:50 <suzu> that's the latest stable version
17:40:56 <ryantrinkle> ok, cool
17:41:07 <Cale> ctrlaltv: (you may want to do something different there if the list of Ints is empty)
17:41:20 <ctrlaltv> Cale: I tried that and it works, if I am not mistaken, in a depth first rather than breadth first manner
17:42:06 <suzu> ryantrinkle: installing the arch nix pkg worked
17:42:10 <Cale> ctrlaltv: ah, then all that's wrong is how you're doing the tree traversal :)
17:42:17 <ryantrinkle> suzu: great; can you get into try-reflex?
17:42:33 <suzu> nope, it thinks i dont have nix and tries dling it
17:42:46 <ryantrinkle> do you have a ~/.nix-profile directory?
17:42:54 <suzu> lol. no
17:43:04 <suzu> i have all the nix bins in my path though
17:43:11 <ryantrinkle> weird
17:43:17 <suzu> is there something i need to run to bootstrap it?
17:43:19 <ryantrinkle> lemme check how it does that detection
17:43:26 <ctrlaltv> Cale: :p Maybe. I implemented a foldTree function that maps a function all over a tree and I must use this one to traverse the tree :/
17:43:41 <Cale> ctrlaltv: ah, okay
17:43:57 <ryantrinkle> suzu: you have a /nix, though, right?
17:43:58 <ctrlaltv> Cale: anyways, really appreciate your help!
17:44:09 <suzu> lol no i dont even have that!
17:44:12 <Cale> ctrlaltv: If you want, I can have a quick look at that
17:44:15 <suzu> i guess all it did was install the bins
17:44:22 <ryantrinkle> suzu: huh...
17:44:31 <Cale> ctrlaltv: It might be that we have to use the state in some more clever way
17:44:33 <ryantrinkle> do they work if you run them?
17:44:48 <ryantrinkle> like, type: nix-shell -p nodejs
17:45:02 <ryantrinkle> it should drop you into a prompt with node
17:45:06 <suzu> seems to need root
17:45:18 <ctrlaltv> Cale: if that's easy for you to have quick look at, I'd be grateful. How can I share the codE?
17:45:19 <suzu> and then no it doesnt even work
17:45:20 <suzu> warning: the group ‘nixbld’ specified in ‘build-users-group’ does not exist error: file ‘nixpkgs’ was not found in the Nix search path (add it using $NIX_PATH or -I), at (string):1:13
17:45:24 <Cale> lpaste.net
17:45:33 <sunnymilk> why does Foldable take a type variable of kind * -> *? and why isnt there a Foldable instance for forall a. a? its foldr could just return its z by default
17:45:37 <ryantrinkle> suzu: ok, yeah, so i think the try-reflex version got a lot further
17:45:41 <ctrlaltv> Cale: I am on it
17:45:42 <ryantrinkle> this one seems pretty messed up :P
17:46:02 <suzu> https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=nix
17:46:12 <suzu> this is what the nix pkg does
17:46:45 <Cale> sunnymilk: Because it's for container structures which are parameterised over the type of elements they contain
17:47:04 <ryantrinkle> suzu: i'll see if i can get the try-reflex installer working on arch
17:47:18 <suzu> ok. is there anything i could try in the meantime?
17:47:25 <suzu> any instructions on how to get this working with stack?
17:47:35 <Cale> sunnymilk: and to the second point, because 1) you can't have an instance for a polytype, and 2) that polytype has the wrong kind to be an instance
17:47:37 <sunnymilk> Cale it seems unnecessary, if it wasnt there you could implement an instance for eg Integer
17:47:41 <ryantrinkle> i don't have instructions for working with stack, but i don't think there's anything unusual necessary
17:47:47 <Cale> sunnymilk: Except you couldn't.
17:47:55 <suzu> just throw reflex-dom into deps and build?
17:47:57 <sunnymilk> sure you could, just have foldr return its zero
17:48:01 <Cale> sunnymilk: The operations involve both the type and its parameter
17:48:05 <ryantrinkle> suzu: i would think so :)
17:48:10 <suzu> ok, ill try that
17:48:19 <Cale> sunnymilk: What would the type of foldr look like?
17:49:45 <hexagoxel> Gurkenglas: i understand the idea, but you need either some aggressive inlining or give up sharing to make that work.
17:50:01 <ctrlaltv> Cale: http://lpaste.net/150072
17:50:04 <sunnymilk> for Integer, (a -> b -> b) -> b -> Integer -> b
17:50:12 <hexagoxel> and "aggressive" ~ "potentiall turning bottoms into non-bottoms"
17:50:46 <hexagoxel> "head $ fromJust $ (1:) <$> undefined"
17:51:28 <ctrlaltv> Cale: the code also has the dfs function, which hopefully works, as well an implementation of the dfs without monads, as given by the professor
17:52:39 <hexagoxel> Gurkenglas: if you give up sharing, you pretty much lose control over bottom vs non-bottom, depending on how lucky your inlining is.
17:54:19 <hexagoxel> and i doubt you could provide any decider when to stop inlining or how non-strict you actually are.
17:55:16 <hexagoxel> s/or how/or say how/
17:55:58 <Cale> ctrlaltv: ah, I see
17:56:38 <suzu> either stack isnt working out or im dumb
17:57:37 <hexagoxel> Gurkenglas: what should `undefined `seq` True` be? :p
17:57:50 <suzu> ryantrinkle: does this look sane to you? ￼￼http://lpaste.net/7002372662009790464
17:58:06 <Adeon> I have a new haskell pet peeve
17:58:08 <Cale> ctrlaltv: So right, we're supposed to use the state list like a stack I suppose, pushing enough labels on to it when we visit a root in order to be able to label all the children
17:58:11 <Adeon> libraries that don't attach finalizers to foreign resources
17:58:24 <Adeon> so if you don't manually free them they'll leak
17:58:31 <ctrlaltv> Cale: I suppose so
17:58:52 <Cale> ctrlaltv: does it have to be just [Int]? I think it may be easier if we can also keep track of the next available label separately
17:58:55 <ctrlaltv> Cale: I took me some time to get my head around the "simplier" impoementation
17:59:24 <ctrlaltv> Cale: no, I just thought that was the way to go
17:59:39 <Cale> oh, I guess we can just follow along with what bfn is doing
18:00:28 <hexagoxel> Gurkenglas: but i may be completely wrong here, or i shy away too much from anything affecting (seemingly ~randomly) bottomness.
18:01:42 <fr33domlover> Question about CPS: If I use 1000 nested calls to withFile, is the call stack suppsed to grow? does CPS here result with TCO which eliminates (or can eliminate) stack growth?
18:03:07 <Hijiri> there's no call stack
18:04:55 <ctrlaltv> Cale: well I was trying to imitate the given function, but I don't think I get how state monad works really well
18:05:06 <geekosaur> @where stg
18:05:07 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
18:05:30 <Cale> ctrlaltv: okay, let me do the exercise and I'll step you through it in a moment :)
18:06:19 <ryantrinkle> suzu: i think that's your old lpaste
18:06:30 <ctrlaltv> Cale: ok :), I ll try mybest to solve it as well
18:06:32 <suzu> oops
18:06:34 <suzu> http://lpaste.net/6568342963796049920
18:06:34 <suzu> here
18:06:54 <suzu> maybe my ghcjs is too old .. ?
18:06:59 <suzu> i just noticed it's the october snapshot
18:07:23 <Cale> ctrlaltv: okay, done
18:07:29 <ctrlaltv> Cale: haha
18:08:01 <ryantrinkle> suzu: actually, i think you need a newer reflex-dom
18:08:04 <Cale> Though I haven't yet used foldTree, just stepped through and translated carefully to using the State monad
18:08:08 <ryantrinkle> check out the ghcjs-improved-base-2 branch
18:08:13 <ryantrinkle> it'll be released soon, but it isn't yet
18:08:43 <suzu> oh is this because i'm using the improved ghcjs or whatever
18:08:44 <suzu> ?
18:08:54 <ryantrinkle> suzu: yep
18:09:00 <suzu> should i.. not be?
18:09:03 <ctrlaltv> Cale: hmm, I have to use it tho, and only call it once, but it's ok I ll figure out how to merge the solutions
18:09:03 <ryantrinkle> no, it's good now
18:09:22 <ryantrinkle> i just had to do a lot of testing before rolling it out to my customers, who rely on try-reflex
18:09:30 <Cale> ctrlaltv: yeah, that'll be the next step
18:09:35 <suzu> try-reflex is WEBSCALE?!
18:09:36 <suzu> :o
18:09:45 <ryantrinkle> suzu: you bet! :P
18:09:48 <suzu> ~*WEBSCALE*~
18:10:01 <suzu> is this branch on stackage/hackage?
18:10:10 <ryantrinkle> no, just on github
18:10:11 <suzu> how do i get this branch down into my build?
18:10:18 <suzu> is there some yaml magic
18:10:22 <ryantrinkle> i'm pretty sure there's a way with stack to specify a git repo
18:10:26 <ryantrinkle> but unfortunately i don't know what it is
18:10:26 <suzu> ok, ill look for it
18:10:29 <suzu> np
18:10:52 <Cale> ctrlaltv: okay, come to #haskell-overflow so that it'll be quiet
18:12:27 <geekosaur> fr33domlover, read http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729 it is a little out of date but still essentially correct. Haskell doesn't work like the languages you;re used to, and your question is kinda meaningless in STG
18:14:04 <fr33domlover> geekosaur, the bottom line is: i need to allocate ~1000 resources in my code which stay allocated for the entire program execution and i want to know whether it's okay in the stack size sense etc.
18:14:20 <geekosaur> they don't come off thestack
18:14:27 <geekosaur> there is no stack in the sense you are talking about
18:14:31 <fr33domlover> i.e. can i use 1000 nested bracket and not worry about it :P
18:17:58 <fr33domlover> geekosaur, i see
18:18:01 <geekosaur> STG compiles to jumps, not calls, and needs no call stack. all values are allocated on the heap, and last until all references to them go away.
18:18:25 <ryantrinkle> suzu: i added an issue to track your installation problem: https://github.com/ryantrinkle/try-reflex/issues/51
18:18:56 <fr33domlover> geekosaur, so 1000 nested calls are no risk and no different than 1000 heap variable allocations essentially ?
18:19:02 <geekosaur> right.
18:19:05 <suzu> ok awesome!
18:20:14 <geekosaur> there *is* a pattern match stack which was artificially restricted in size in older ghc versions; there is a runtime option to raise that limit. this "stack" is itself a bunch of heap pointers, not really a stack, and it is used to keep track of evaluation of lazy values, not calls.
18:20:45 <geekosaur> I don't know offhand if bracket uses that
18:22:27 <fr33domlover> a blind wild guess would be no, since bracket doesn't do any pattern matches, it just applies functions to arguments, but of course this is a wild guess :P
18:36:09 <MarcelineVQ> geekosaur: where does the stack people typically think of come into play? The one that overwflows on nonstrict folds of long lists for instance.
18:37:56 <geekosaur> that is the pattern match stack, because it's piling up incomplete patterns that need the next iteration to continue. and it happens less often now because the completely arbitrary and unnecessary restriction on it was removed, because it's not really a stack in the normal sense
18:39:45 <geekosaur> basically if you build up a chain of (1 + (1 + ( 1 + .....))), each (+) invocation has two patterns and will have to "stack" the 2nd pattern (right hand parameter) until it is evaluated. but evaluating it stacks another incomplete pattern for another (+)
18:40:16 <geekosaur> actually I think I have that reversed, it's the left case that is difficult?
18:40:22 * geekosaur is getting too tired, sigh
18:40:48 <suzu> ryantrinkle: ive got the package dep in for the new branch, but it doesnt seem to know how to build it
18:40:56 <geekosaur> in any case, the problem with foldl is one of laziness vs. strictness (which is why the strict foldl' is preferred)
18:41:07 <Axman6> they're both difficult since (+) is strict in both its arguments for most instances
18:41:09 <geekosaur> and lainess is what brings the pattern match "stack" into play
18:41:23 <Axman6> the problem comes from the depth of thunks that need to be evaluated
18:41:34 <suzu> it shows me this when building:
18:41:36 <suzu> No .cabal file found in directory /home/user/experiments/web/.stack-work/downloaded/2c21c6e6e7b928e6d220195501e6635c1825c90d1811c86281685a178dbb724f/
18:41:41 <suzu> i assume it dled and then doesnt know wtf to do
18:45:08 <MarcelineVQ> Interesting, so what determines a stack overflow if the arbitrary limit was changed/removed?
18:45:23 <fr33domlover> geekosaur, iirc StateT essentially wraps a series of functions which pass the state between them, i.e. a series of nested (tail) calls. If a long StateT computation is OK, perhaps I can assume the only issue with nested brackets would be the lack of tail calls and whatever that entails?
18:45:36 <geekosaur> ...
18:45:42 <geekosaur> stop thinking about tail calls
18:45:54 <geekosaur> there are no calls. there are *jumps*
18:46:16 <geekosaur> in other words, if you insist on thinking of Von Neumann execution, *every* "call" is TCOd
18:46:17 <Axman6> it's all tail calls!
18:46:20 <Axman6> >_>
18:46:28 <fr33domlover> i see
18:46:46 <fr33domlover> geekosaur, i suppose i just need to get used to this STG thing :P
18:47:13 <fr33domlover> university only ever mentioned call stacks, even when we wrote a Scheme compiler
18:48:00 <fr33domlover> so.... anyone sees any potential for trouble in 1000 or 10000 nested bracket/withFile ?
18:48:08 <geekosaur> Haskell is graph reduction, not Von Neumann execution. the only "stack" keeps track of partially computed lazy expressions ("thunks" in the implementation's parlance). evaluation consists of creating a tree of expressions on the heap, then replacing nodes on the tree with their result as they are needed
18:48:46 <fr33domlover> i see
18:49:07 <geekosaur> nothing needs to call in this paradigm, you could think of it as every possible call is unrolled togeher into a single large loop if it helps
18:50:12 <geekosaur> a loop that jumps around a lot
18:50:37 <fr33domlover> so 10000 nested calls would just build a "long leg" in that graph which is in the heap?
18:50:50 <geekosaur> it's a very different style of execution, and it wont really start to make sense until you read the STG paper to see how it works
18:50:57 * hackagebot statestack 0.2.0.5 - Simple State-like monad transformer with saveable and restorable state  https://hackage.haskell.org/package/statestack-0.2.0.5 (BrentYorgey)
18:51:13 <Axman6> how do exceptions fit into this (quite relevant since bracket is being used)
18:52:26 <geekosaur> you could say the entire branch of the tree that the exception was thrown from is chopped off at the point where it is caught (and if it's not caught it chops the whole tree down)
19:03:42 <lingxiao> hey all
19:03:50 <lingxiao> anyone familiar with coq here?
19:03:54 <lingxiao> #coq is quiet
19:04:01 <johnw> you didn't ask anything in #coq
19:04:40 <lingxiao> oh ok i'll ask now
19:06:10 <lingxiao> anyone else?
19:06:52 <Axman6> I would guess the highest concentration of peoplr who know coq are in #coq...
19:06:55 <Cale> lingxiao: I'm familiar with it in a strange way
19:07:15 <lingxiao> ok great im unfamilar period so could I ask you a couple of qustions?
19:07:23 <Cale> I didn't ever really learn Coq, so much as I just woke up one morning and realised that I already knew how to program in it.
19:07:30 <Cale> haha, sure
19:07:45 <lingxiao> ok I'd like to prove this
19:08:10 <lingxiao> http://lpaste.net/150112
19:08:24 <lingxiao> so I should have:
19:08:58 <lingxiao> [f (f b) = f b] ==> [f b = b]  by the fact that [f b = b]
19:09:12 <lingxiao> then I have [f b = b] ==> [b = b] by the previous fact again
19:09:17 <adu> Cale: that sounds strange
19:09:23 <lingxiao> but I can't express that in coq
19:09:38 <lingxiao> so far I have Proof. intros f x b. Qed.
19:09:57 <Axman6> can you take this to #coq please?
19:10:05 <Cale> yeah, let's talk about it there
19:10:07 <lingxiao> yup Cale can I ask you there?
19:11:05 <lingxiao> great thanks!
19:25:18 <suzu> k nvm im an idiot
19:25:20 <suzu> reflex dom is building now
19:25:40 <ryantrinkle> suzu: awesome :)
19:25:55 <suzu> i was specifying the try-reflex repo
19:25:55 <suzu> ~_~
19:26:01 <ryantrinkle> ahh
19:26:19 <suzu> ahhh wtf
19:26:51 <suzu>     setup-Simple-Cabal-1.22.4.0-ghcjs-0.2.0.20151001_ghc-7.10.2: The program     'ghcjs' version >=0.1 is required but the version of     /home/user/.stack/programs/x86_64-linux/ghcjs-0.2.0.20151001_ghc-7.10.2/bin/ghcjs
19:27:07 <suzu> could not be determined
19:27:19 <ryantrinkle> weird
19:27:38 <Axman6> it's like, right there, in the name. get with it cabal!
19:27:45 <suzu> apparently.. this is a nodejs issue
19:27:45 <suzu> ?
19:27:51 <suzu> or so the interweb claims
19:27:54 <ryantrinkle> suzu: weird!
19:27:59 <suzu> seems to fixed by a nodejs downgrade
19:28:01 <suzu> lol
19:28:01 <suzu> ill try that
19:28:17 <Axman6> urgh, node
19:28:19 <suzu> yeah that fixed it
19:28:19 <suzu> lol
19:28:23 <suzu> js like
19:28:27 <suzu> objectively is bad
19:28:32 <suzu> as a language
19:28:41 <suzu> but damn theres so much good stuff people have written for it
19:29:04 <kadoban> If only there were a way to write haskell and use that instead of JS
19:29:17 <ryantrinkle> kadoban: if only ;)
19:34:09 <suzu> sometimes i think computers suck.
19:34:47 <xkle> how can i get a list of functions corresponding to a record's field names?
19:35:22 <ryantrinkle> suzu: haha, well, this kind of stuff is why i've switched to nix
19:35:32 <ryantrinkle> i hate having to redo work just because time has moved forward
19:35:41 <xkle> ryantrinkle as an OS?
19:36:04 <ryantrinkle> i've been using NixOS on my laptop for 2 years and in production for a year and a half
19:36:12 <ryantrinkle> it's phenomenal for servers
19:36:30 <ryantrinkle> i can build my *entire system* - application, configuration, operating system, etc. - on my build server
19:36:41 <ryantrinkle> everything's 100% locked down in git
19:36:54 <ryantrinkle> it deploys rsync-style with binaries and without re-copying existing stuff
19:36:57 <xkle> why aren't more people using NixOS as opposed to i don't know linux mint ... or using docker containers
19:36:58 <ryantrinkle> then atomically switches over
19:37:06 <suzu> Module ‘GHCJS.Types’ does not export ‘JSVal(..)’
19:37:08 <suzu> fffff
19:37:17 <ryantrinkle> xkle: nix is kinda hard to get into
19:37:30 <ryantrinkle> i pretty much had to just read the docs straight through before i felt fully comfortable
19:37:46 <ryantrinkle> suzu: that sounds like your ghcjs is too old
19:37:55 <suzu> ok. i'll try the dec snapshot
19:38:06 <suzu> how do i remove the current one?
19:38:15 <ryantrinkle> i don't know, sorry :-/
19:38:28 <ryantrinkle> (with nix they all just get installed side-by-side :D)
19:38:40 <xkle> i want to do something like http://stackoverflow.com/questions/8457876/get-a-haskell-records-field-names-as-a-list-of-strings except get a list of functions instead of function names
19:38:45 <xkle> is that even possible?
19:39:01 <ryantrinkle> xkle: yes, it should be possible
19:39:13 <xkle> ryantrinkle any idea how?
19:39:22 <suzu> stack will install them side-by-side too
19:39:39 <suzu> but i dont enjoy having rpollution on my system
19:39:43 <suzu> pollution *
19:39:46 <ryantrinkle> xkle: i think if you can get names for them, you should be able to just emit a list literal
19:39:50 <ryantrinkle> like
19:40:12 <ryantrinkle> with (VarE labelName) in each element
19:40:25 <ryantrinkle> now, if the names aren't in scope at the splice site, that's trickier
19:40:34 <ryantrinkle> but if they are, i think that would work
19:41:09 <ryantrinkle> you can use reify to get one of these for the type: https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info
19:41:17 <ryantrinkle> then you can dig around in there to find the record labels
19:41:30 <xkle> i haven't had much experience with TH
19:41:41 <ryantrinkle> and then basically return $ ListE $ map VarE theNames
19:41:56 <ryantrinkle> xkle: what's your ultimate goal with this?
19:42:27 <xkle> ryantrinkle I want to write a generic record printer which formats fields in a different way
19:42:35 <ryantrinkle> ah, ok
19:42:40 <ryantrinkle> well, your options are basically TH or Generics, in that case
19:42:50 <ryantrinkle> i'm not sure which would be easier to work with for this specifically
19:42:59 <ryantrinkle> but i'm sure they'd both be reasonable
19:43:09 <xkle> will given i haven't used TH yet, how would i do it with generics?
19:43:48 <ryantrinkle> xkle: basically, you have to write instances for the representation types: https://wiki.haskell.org/GHC.Generics
19:44:29 <ryantrinkle> take a look at the GSerialize class on that page
19:45:12 <suzu> btw ryantrinkle your reflex-dom slides are down
19:45:28 <ryantrinkle> suzu: yeah, sorry about that
19:45:47 <ryantrinkle> i've pretty substantially rebuilt the obsidian.systems site recently
19:45:58 <suzu> is it is it is it in HASKELL
19:46:02 <ryantrinkle> yes, of course :)
19:46:06 <ryantrinkle> it's a reflex-dom app
19:46:17 <suzu> how realistic is doing normal shit in haskell
19:46:18 <suzu> like
19:46:32 <suzu> i could build a webapp in like 2 hrs with python or rails or some other thing
19:46:40 <suzu> hs seems kinda .. immature
19:46:41 <suzu> :/
19:46:49 <xkle> suzu you could build a webapp pretty fast in haskell
19:46:56 <exio4> what's that web app doing?
19:47:05 <ryantrinkle> i could build a webapp in 2 hours in haskell, easily :P
19:47:06 <suzu> so is it just the case that im not good enough at haskell to do things quickly yet?
19:47:16 <ryantrinkle> but, that's what i do all day long
19:47:25 <ryantrinkle> i think a better question is
19:47:26 <xkle> it's the supporting ecosystem that's weak
19:47:40 <ryantrinkle> xkle: i totally disagree
19:47:47 <ryantrinkle> i've *heard* a lot about how weak the haskell ecosystem is
19:47:54 <ryantrinkle> but i've never actually run into the problem myself
19:48:01 <xkle> ryantrinkle yeah probably not for your domain
19:48:03 <ryantrinkle> maybe i'm just doing stuff that doesn't run afoul of some gaps
19:48:25 <xkle> ryantrinkle i'm doing data science / scientific & numerical computing
19:48:39 <ryantrinkle> xkle: yeah, that could certainly stand to be a bit better
19:48:40 <suzu> does BLAS and LAPACK work
19:48:41 <suzu> ?
19:48:44 <xkle> ryantrinkle and i am slogging through it but it is painful...
19:48:56 <ryantrinkle> suzu: i think the right question is: how long would it take you to make an MVP that is good enough to start getting feedback from real users?
19:49:09 <xkle> suzu yeah. but ecosystems like python and R consist of much more than BLAS and LAPACK bindings
19:49:16 <ryantrinkle> i've seen rails shops that can't get done in 18 months what obsidian can get done in 3 weeks
19:49:19 <exio4> also, what do you define as `normal shit`? 
19:49:27 <suzu> idk all of this is ill defined
19:49:33 <suzu> i just find that i take forever to get things done
19:49:44 <suzu> i dont know if thats my own inexperience or haskell
19:49:47 <exio4> I use Haskell as other programmers seem to use Python
19:49:50 <suzu> im assuming its the first
19:49:51 <Adeon> 'normal shit' depends on your application area
19:49:53 <ryantrinkle> well, it takes a while to learn how to apply haskell well
19:49:56 <Adeon> web stuff is pretty common
19:50:00 <Adeon> haskell is good at that
19:50:17 <exio4> ryantrinkle: how long have you been writing Haskell? :) 
19:50:18 <ryantrinkle> i had a project recently where we had 3 people each on JS and on haskell
19:50:21 <xkle> suzu how long have you been working with haskell?
19:50:28 <ryantrinkle> all the people were good, but the JS side had 10x the bugs
19:50:36 <suzu> maybe like ~3 months?
19:50:43 <ryantrinkle> exio4: 10 years
19:50:47 <suzu> just learning it and doing little projects and stuff
19:50:59 <exio4> suzu: ehm, I don't think anybody here was really fast in Haskell after 3 months :)
19:50:59 * hackagebot postgresql-binary 0.7.5 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.7.5 (NikitaVolkov)
19:51:14 <exio4> ryantrinkle: oh, nice! :P 
19:51:15 <ryantrinkle> yeah, 3 months would be pretty fast
19:51:22 <ryantrinkle> exio4: :) it's been nice
19:51:37 <ryantrinkle> i've been lucky enough to focus on it professionally for the last 6 years
19:51:50 <suzu> yeah maybe 3mo is a bit aggressive
19:51:57 <suzu> for haskell
19:51:59 <exio4> I knew a little bit of FP, etc, when I started writing Haskell
19:52:15 <xkle> ryantrinkle ... ecosystem example -  i'm trying to learn generics/TH just to write a function so i can print records in a readable way for data analysis. something i'd probably skip in julia/python/r/etc.
19:52:18 <exio4> I started feeling comfortable in certain domains after a year and half 
19:52:19 <suzu> i think people could make things with 3mo of python or ruby xp though
19:52:41 <ryantrinkle> i haven't seen people with that little experience in any language who have been able to write code i'd feel comfortable shipping
19:52:46 <ryantrinkle> (without lots of oversight)
19:52:46 <exio4> and there are certain things I have barely looked at (web stuff, mostly)
19:53:08 <suzu> hmm
19:53:09 <suzu> thats true
19:53:16 <xkle> suzu what are you using to learn. please not learn you a haskell. i can sympathsize though, i am at literally ~ 1% of my usual productivity in haskell right now.
19:53:28 <xkle> but i'm in it for the longer haul...
19:53:37 <suzu> i read LYAH
19:53:39 <exio4> well, it also depends, what are you working on?
19:53:45 <suzu> i dont think its all that great
19:53:46 <xkle> suzu forget LYAH it sucks.
19:53:54 <suzu> then i read Real World Haskell
19:53:55 <ryantrinkle> xkle: hmm, well, if you're not already quite comfortable in Haskell, TH and Generics will probably take quite a while
19:53:56 <xkle> suzu in fact, i'd say it's negatively beneficial
19:54:05 <ryantrinkle> xkle: what kind of format are you trying to arrive at?
19:54:12 <suzu> which was pretty good except its got a lot of mistakes in it now
19:54:25 <exio4> as soon as you need to work with a tree you could easily pattern match... :P 
19:54:25 <suzu> then like the hs series on wikibooks and stuff
19:54:31 <xkle> suzu RWH is out of date
19:54:40 <xkle> suzu this is your problem. read haskellbook.com and come back
19:54:46 <exio4> or you need to do concurrency, or things where Haskell (or FP as a whole) shines!
19:54:58 <xkle> suzu you're going down the wrong learning path. unfortunately most people do
19:55:04 <exio4> heck, I write my shell scripts in Haskell 
19:55:05 <ryantrinkle> exio4: or FRP ;)
19:55:25 <suzu> this book costs $59?
19:55:26 <exio4> ryantrinkle: I can't really say much about FRP, haven't played with it, but reflex looked really cool 
19:55:33 <ryantrinkle> exio4: thanks :)
19:55:40 <exio4> why thanks?
19:55:48 <ryantrinkle> reflex is my lib
19:56:00 <exio4> oh, nice work then hah
19:56:16 <Axman6> he's THE Ryan Trinkle
19:56:17 <ryantrinkle> FRP is the first thing that has given me that "haskell feeling", where i'm pretty sure something is bug-free
19:56:24 <ryantrinkle> Axman6: hahaha
19:56:46 <ryantrinkle> *in the GUI domain, i mean
19:56:55 <Axman6> "I'm Ryan Trinkle, you may have heard of me *shades*"
19:56:58 <ryantrinkle> lol
19:57:05 <exio4> s/may// 
19:57:13 <xkle> ryantrinkle see http://seananderson.ca/2014/09/13/dplyr-intro.html under "looking at the data" the standard view and the glimpse() view
19:57:36 <suzu> xkle: do you have any other resources
19:57:38 <ryantrinkle> xkle: is that tab-separated values?
19:57:49 <xkle> suzu haskellbook.com it's what everyone is reading now
19:58:08 <coconut> ryantrinkle, hi i'm making a startup using haskell. so far i plan to use mongodb + yesod. may i contact you for consulting service?
19:58:23 <ryantrinkle> coconut: absolutely; ryan.trinkle@gmail.com
19:58:25 <xkle> ryantrinkle well the first is fixed width, the second shows one field per row to show as much as possible
19:58:33 <ryantrinkle> or ryan@obsidian.systems if you feel like being more professional :P
19:58:34 <coconut> ryantrinkle, thanks
19:58:40 <Axman6> mongo-- :(
19:58:40 <suzu> is it worth $59?
19:58:50 <xkle> suzu yes
19:59:00 <coconut> why the sad face ?
19:59:04 <Axman6> coconut: are you working on a service to protect user's data by making it is never retained in the database?
19:59:16 <xkle> suzu considering you'll learn in 4 weeks what would otherwise take you 18-24 months
19:59:24 <coconut> you mean it still keep losing data ?
19:59:33 <Axman6> mongo is notorious for data loss, which still hasn't been fixed long after the reports were given
19:59:39 <Axman6> last I heard yes
19:59:57 <Axman6> but, I don't use it myself. Check Aphyr's blog to see if it's still true
20:00:04 <jle`> but people who use mongo are people who are okay with data loss ... right?
20:00:05 <coconut> i'm in a state of prototyping
20:00:12 <ryantrinkle> btw, is anyone here planning to come to Compose?
20:00:14 <xkle> suzu time is too precious to waste fake-learning with LYAH and the like
20:00:15 <jle`> if you care about data loss then you wouldn't be using mongo in the first place, hopefully! :O
20:00:16 <coconut> Axman6, any other suggestions ?
20:00:25 <suzu> ok so LYAH is trash yes
20:00:29 <Axman6> anything else at all? :P
20:00:30 <suzu> but RWH seemed ok
20:00:31 <hiptobecubic> I don't understand why mongo is still so popular. Everyone I talk to has universally decried how unreliable it is, and yet it still seems like the most popular nosql.
20:00:42 <hiptobecubic> suzu, I wouldn't say "trash"
20:00:42 <ryantrinkle> coconut: i typically use Postgres unless there's a specific reason to use something else
20:00:48 <jle`> suzu: if the price is an issue, you can email the authors, they are very reasonable with working out things for people in need :)
20:00:59 <Axman6> I hear good things about tiak, but haven't used either enough to even know if they're suitable alternatives for each other
20:01:37 <xkle> hiptobecubic i would, considering it leads newcomers like suzu to false starts dead ends.
20:01:37 <jle`> the main thing i'd caution about RWH is that a lot of the practical real-world examples are out of date and take some work to make work on a modern system
20:01:44 <Axman6> I have a good reason to not use postgres, but haven't found something that does its job better. it can't optimise some of our queries annoyingly
20:01:59 <jle`> it'd be nice one day when books can come out and say, "we are using lts-5 of stackage!" so everyone instantly can get a package environment that works with the book
20:02:02 <ryantrinkle> Axman6: ah, that's unfortunate
20:02:24 <ryantrinkle> xkle: if you can get by with CSV or tab-separated values, i think there's a good library for you
20:02:32 <ryantrinkle> https://hackage.haskell.org/package/cassava
20:02:52 <xkle> ryantrinkle  heh i'm using it already
20:03:05 <glguy> jle`: That probably won't help a lot as the version of GHC move on and the older ones don't always work on news OSs
20:03:06 <ryantrinkle> ahh
20:03:09 * Axman6 is streaming postgre data straight into cassava based CSV's
20:03:14 <Axman6> postgres*
20:03:21 <ryantrinkle> Axman6: nice :)
20:03:46 <ryantrinkle> jle`, glguy: that would *exactly* work with nix
20:03:53 <ryantrinkle> that's why i use try-reflex
20:03:57 <Axman6> I've been looking at DynamoDB because it should be able to store our data in a way we can get the performance we need
20:04:04 <coconut> ryantrinkle, my app is doing some text frequency analysis algorithm. so far they are in haskell. by using db do i have to port them all in db language, be it mongodb or somethign else
20:04:06 <jle`> glguy: hm, wouldn't stack be able to nail down the ghc version for you, too?
20:04:07 <ryantrinkle> it provides the LTS release to obsidian's clients, as well as a sandbox for beginners
20:04:18 <glguy> ryantrinkle: Maybe, but Nix isn't relevant to the larger userbase trying to learn Haskell
20:04:30 <ryantrinkle> glguy: yeah, definitely not
20:04:31 <xkle> ryantrinkle cassava is good, but it's a long climb back up to get interactive analysis workflows competitive with otherwise inferior languages like python or R
20:04:45 <ryantrinkle> glguy: but i'd say that, for the exact reason you mentioned, stack doesn't quite knock the problem out either
20:04:48 <glguy> jle`: Yeah, but for example as the latest OS X came out 7.8 stopped working without significant effort
20:04:59 <glguy> stack or not
20:05:10 <kadoban> That's unfortunate.
20:05:22 <ryantrinkle> hm, i have a project that uses 7.8 in nix on mac os
20:05:28 <exio4> ryantrinkle: have you done any tutorial on a "full-stack haskell setup" or similar? (you see, Haskell in the backend, reflex on the frontend, sharing types, etc) :P
20:05:29 <Axman6> glguy: I use stack --docker when I need to test with 7.8 on OS X
20:05:36 <ryantrinkle> there was definitely some significant work the nix guys put in to make nix stuff work on mac os
20:05:44 <ryantrinkle> on el capitan
20:05:55 <ryantrinkle> exio4: not yet, but i'd like to!
20:06:10 <ryantrinkle> right now my focus is on the frontend, because that's where I see the most pain
20:06:24 <jle`> glguy: i see
20:06:26 <ryantrinkle> snap, yesod, servant, etc. have done a great job on the backend
20:06:31 <glguy> the point isn't about any particular glitch, jsut that things move on and it's not going to be as simple as picking a resolver
20:06:38 <ryantrinkle> my next step would be to improve the integration between reflex and those
20:06:53 <ryantrinkle> glguy: yeah, absolutely
20:07:13 <ryantrinkle> i definitely try to make try-reflex as isolated as possible, though
20:07:18 <ryantrinkle> it has everything from glibc up
20:07:27 <glguy_> Neat
20:07:33 <ryantrinkle> so no matter what linux you're running, you're golden
20:07:38 <ryantrinkle> unless your ABI is ancient
20:07:47 <ryantrinkle> on mac os, it's more of a fight to stay current
20:07:55 <ryantrinkle> but i support the latest 2 OS X versions
20:08:26 <exio4> ryantrinkle: that sounds cool! nice to know you have that in your todo list!
20:08:33 <ryantrinkle> usually nixpkgs fixes any issues within a few weeks
20:09:08 <ryantrinkle> exio4: :)
20:13:44 <dfeuer> Hmm.. There's ryantrinkle. Interesting. I just watched a few of his presentations.
20:13:52 <ryantrinkle> dfeuer: howdy :)
20:14:10 <Axman6> Hmm, there's dfeuer, talking about people present in the third person :P
20:14:44 <glguy_> Dfeuer: the point of that blog post was that the existing <= could be used
20:14:53 <ryantrinkle> Hmm, there's Axman6 talking about dfeuer talking about people in the third person in the third person
20:15:00 <dfeuer> ryantrinkle, I was puzzled by the absence of a currentTime behavior in reflex, that being left to other packages.
20:15:08 <dfeuer> glguy, what blog post?
20:15:15 <glguy_> Not that a new one would be defined. Also I think it was just a cute observation
20:15:23 <ryantrinkle> dfeuer: ah, yup
20:15:29 <glguy_> Dfeuer the one linked in the email you just replied to
20:15:40 <dfeuer> Ah, I didn't see a link in it.
20:15:46 <ryantrinkle> well, basically, the question becomes, "Which current time?"
20:16:18 <ryantrinkle> what works in music at 44.1khz isn't going to work in a browser at 60hz
20:16:30 <ryantrinkle> and what about apps with multiple notions of time?
20:16:50 <ryantrinkle> e.g. a video game has a game clock, which can be paused, but it also has a UI animation clock
20:17:06 <dfeuer> ryantrinkle, well, that *is* a question. I would think "current UTC time" and "current local time" would be pretty popular things to have available
20:17:34 <xkle> suzu just work your way through that book. should take at least a few weeks if you're doing exercises
20:17:38 <dfeuer> (And yes, I thought briefly about the matter before asking, and recognized that it could be tricky to find the *right* time in general.)
20:17:43 <ryantrinkle> dfeuer: yeah; that makes sense, and I think those will eventually get added to some sort of "host starter kit"
20:18:07 <ryantrinkle> but also keep in mind that Reflex is designed to be usable in situations where we don't have access to IO at all
20:18:14 <suzu> hm
20:18:16 <suzu> ok
20:18:16 <dfeuer> Oh?
20:18:22 <ryantrinkle> e.g. there could be an implementation of the Reflex (and associated) typeclass that runs entirely in ST
20:18:24 <suzu> ill take a look at the sample chaps tomorrow
20:18:33 <xkle> suzu cis194 can help, it's better than LYAH but just save yourself time and read the book. see  https://github.com/bitemyapp/learnhaskell
20:18:36 <ryantrinkle> dfeuer: also, here's one that's *totally* pure: https://github.com/ryantrinkle/reflex/blob/develop/test/Reflex/Pure.hs
20:18:36 <dfeuer> What would that be useful for?
20:18:47 <xkle> suzu but honestly no sense in dividing up your attention in too many ways if you want to learn better/faster
20:18:52 <ryantrinkle> well, in the case of this Pure implementation, it's my reference implementation
20:18:58 <ryantrinkle> it defines the semantics for other Reflex implementations
20:19:15 <ryantrinkle> the test suite for reflex runs Pure against Spider and ensures they always agree
20:19:27 <dfeuer> *nod*
20:19:33 <ryantrinkle> one thing to note is that in Pure, *time doesn't even pass*
20:19:46 <ryantrinkle> Pure takes the entire timeline and computes an entire result timeline
20:19:47 <ryantrinkle> all at once
20:19:54 <ryantrinkle> hence, it's useful for semantics, but not much else
20:20:07 <ryantrinkle> however, you could also, e.g., write a nondeterministic version of Reflex
20:20:12 <ryantrinkle> where the timeline is branching
20:20:37 <ryantrinkle> Reflex is intentionally very vague about what time *is*
20:20:48 <ryantrinkle> for example, it has no notion of "how much" time has passed
20:20:56 <dfeuer> Does reflex-dom offer enough the sort of time access needed to support animations?
20:21:07 <ryantrinkle> dfeuer: yes, but not with requestAnimationFrame yet
20:21:25 <ryantrinkle> i wouldn't recommend trying to lerp your animations yourself in reflex-dom just yet
20:21:34 <dfeuer> Does the time come as a Behavior, or some more subtle thing?
20:21:54 <ryantrinkle> dfeuer: they're a bit more complex than that
20:21:54 <ryantrinkle> https://github.com/ryantrinkle/reflex-dom/blob/develop/src/Reflex/Dom/Time.hs
20:22:08 <ryantrinkle> basically, you need to tell it how often you want to receive ticks
20:22:31 <ryantrinkle> i don't want to dive into something like a Behavior of time without a lot of thought about performance
20:22:38 <dfeuer> Hrmmm....
20:22:46 <ryantrinkle> basically the problem is that it would *always* be invalid
20:22:50 <ryantrinkle> and *always* need to be recomputed
20:23:07 <dfeuer> Since Behaviors are purely pull-based, wouldn't it be okay to sample them?
20:23:13 <ryantrinkle> yes, potentially
20:23:27 <dfeuer> Presumably the time would be sampled once per frame...
20:23:33 <ryantrinkle> per animation frame, yes
20:23:37 <ryantrinkle> but not necessarily per *frp* frame
20:23:47 <ryantrinkle> e.g., if you process a keystroke, a click, and then an animation frame
20:24:02 <ryantrinkle> i'm not sure you always want to wipe out your time value in between
20:24:06 <ryantrinkle> perhaps you do, though
20:24:32 <ryantrinkle> it wasn't clear to me what the "always right" approach was (or even that there necessarily is one), so i left it out
20:24:34 <dfeuer> I would expect to have a time behavior available that works per FRP frame, and then to hold it as necessary using events.
20:24:58 <ryantrinkle> yeah, that makes sense
20:25:08 <ryantrinkle> the good thing is that it's very easy to add that in a host :)
20:25:09 <dfeuer> (And perhaps to have optimized special cases there)
20:25:45 <dfeuer> Well, perhaps, but abstracting out things that are likely to be common into a (sub)class makes things easier....
20:25:58 <ryantrinkle> yeah, definitely
20:26:15 <dfeuer> But I think I see what you're getting at. Still trying to get the gist of the whole framework.
20:26:23 <dfeuer> It'll probably take me a while.
20:26:35 <ryantrinkle> cool :)
20:26:38 <ryantrinkle> let me know if you have any questions
20:26:47 <ryantrinkle> i'm not always in #haskell, but i'm in #reflex-frp most of the time
20:27:06 <dfeuer> One thing you didn't touch on was the extent to which your choice to avoid arrowization, etc., limited the implementation's optimization potential.
20:27:18 <ryantrinkle> ah, yeah
20:27:24 <ryantrinkle> well, i've done arrowized implementations before
20:27:40 <ryantrinkle> and let me tell you, it is *very* hard to get any leverage out of the potentially-better optimization
20:27:40 <dfeuer> Clearly, you've put a tremendous amount of work into optimization, thought into design, etc.
20:28:01 <ryantrinkle> yeah, performance is probably the #1 design constraint of reflex
20:28:02 <dfeuer> Just trying to see how it fits into what others have thought about before.
20:28:25 <ryantrinkle> the problem with arrowized FRP's optimization potential
20:28:30 <ryantrinkle> is that most apps are quite dynamic
20:28:38 <ryantrinkle> you're creating new circuits and destroying circuits a *lot*
20:28:40 <dfeuer> I also noted that you decided to go with the phantoms-everywhere design Apfelmus recently discarded as too awkward for users.
20:29:04 <ryantrinkle> whenever you create a new circuit, you have to run the optimizer
20:29:09 <ryantrinkle> it's tough to make that payoff worth it :)
20:29:14 <dfeuer> Yeah, I figured. It's been a long time since I read about what the arrowization stuff was supposed to accomplish in the way of performance guarantees....
20:29:15 <ryantrinkle> yeah, i disagree with that decision
20:29:23 <ryantrinkle> the phantom is very important
20:29:36 <ryantrinkle> otherwise you can't have two FRP systems in the same app in any kind of sane way
20:29:55 <ryantrinkle> and i wouldn't be able to, e.g., write the test code where I run the same code with Pure and with Spider
20:30:09 <dfeuer> *nod*
20:30:13 <ryantrinkle> it doesn't seem to be that hard for beginners, to me
20:30:24 <ryantrinkle> just always write 't' after Event or Behavior ;)
20:30:26 <xkle> is there a Data.Text equivalent of show?
20:30:53 <ryantrinkle> (also, i have bigger plans for the 't' in the future ;))
20:31:05 <dfeuer> Well, apfelmus was claiming that the need for polymorphism in the phantoms made dynamic switching hard. But you could be using different combinators that avoid the problem. I haven't gotten there yet; still trying to get the lay of the land.
20:32:38 <ryantrinkle> dfeuer: https://github.com/ryantrinkle/reflex/blob/develop/src/Reflex/Class.hs#L52
20:32:48 <ryantrinkle> switch and coincidence are the dynamic switching primitives
20:32:55 <ryantrinkle> i don't think the phantom type gets overly in the way
20:33:09 <dfeuer> That looks pretty sane.
20:33:40 <ryantrinkle> in general, i've found that when i leave out phantoms, it bites me later
20:33:44 <dfeuer> Producing EventSelectors could be annoying, but that's on the framework side.
20:33:55 <ryantrinkle> yeah
20:34:02 <ryantrinkle> the implementation is much harder to wrangle than the type, of course :)
20:34:03 <dfeuer> Speaking of event selectors,
20:34:15 <ryantrinkle> the main reason i have the phantom is that i went through about 17 iterations of FRP
20:34:21 <ryantrinkle> and i was constantly benching and testing them against each other
20:34:50 <ryantrinkle> and after a few of them, i got tired of needing to use C preprocessor hackery and stuff :P
20:34:55 <dfeuer> I was wondering whether GHC got too clever with that newtype, and ended up losing your memoization.
20:35:24 <ryantrinkle> dfeuer: i haven't seen that happen
20:35:39 <ryantrinkle> but i'd definitely be interested in knowing if there are any situations where that could happen
20:36:08 * hackagebot hoauth2 0.5.2 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.2 (HaishengWu)
20:36:18 <dfeuer> I know that Roman Cheplyaka encountered some issues with a similarish thing and had to disable some optimizations. I wonder if you're rescued by the higher-rank polymorphism.
20:36:41 <dfeuer> (That was in regex-applicative)
20:36:46 <ryantrinkle> dfeuer: yeah, that could be; also, i've got quite a few strategic NOINLINEs in Spider
20:37:29 <ryantrinkle> if any of my Event or Behavior constructors got inlined, it'd be problematic, because they all allocate cache cells using unsafePerformIO
20:37:52 <dfeuer> Ew.
20:38:00 <ryantrinkle> haha
20:38:02 <dfeuer> Why do you need unsafePerformIO?
20:38:34 <ryantrinkle> dfeuer: https://github.com/ryantrinkle/reflex/blob/develop/src/Reflex/Spider/Internal.hs#L466
20:38:41 <ryantrinkle> otherwise all your performance is atrocious :P
20:38:44 * dfeuer is ever so much more wary of unsafePerformIO than of unsafeCoerce, perhaps because of unfamiliarity with its particular subtleties.
20:39:08 <dfeuer> *shudder*
20:39:11 <ryantrinkle> i doubt it's even possible to implement FRP without unsafePerformIO or something like it
20:39:33 <dfeuer> IO isn't enough?
20:39:41 <ryantrinkle> all the functions in Reflex are pure
20:39:48 <ryantrinkle> in the class, i mean
20:40:07 <ryantrinkle> the primitives in MonadHold and MonadSample are monadic
20:40:21 <ryantrinkle> otherwise how could we have Functor (Event t)? :)
20:40:41 <ryantrinkle> https://github.com/HeinrichApfelmus/reactive-banana/search?utf8=%E2%9C%93&q=unsafePerformIO
20:40:47 <dfeuer> Oh....
20:41:00 <ryantrinkle> dfeuer: trust me, it's necessary :P
20:41:03 <dfeuer> I see.
20:41:07 <dfeuer> Well.
20:41:13 <ryantrinkle> i don't use things like that lightly
20:41:48 <dfeuer> It makes me a bit nervous for a couple reasons, but I can believe you.
20:42:03 <ryantrinkle> well, i'm happy to address any specific reasons if you'd like
20:42:23 <ryantrinkle> i've tested this stuff quite thoroughly, and the unsafePerformIO usage hasn't changed substantially in over a year
20:42:45 <dfeuer> I don't mean to doubt you or your testing.
20:42:52 <ryantrinkle> oh, not at all! i welcome it :)
20:43:14 <dfeuer> I just know some unsafePerformIO-related bugs involve extremely subtle optimization interactions and such.
20:43:16 <ryantrinkle> i'd certainly want to fix any problems if they're lurking somewhere
20:43:19 <ryantrinkle> yeah
20:43:31 <ryantrinkle> that's true
20:43:43 <ryantrinkle> the Weak reference stuff is far more subtle, though :P
20:44:02 <ryantrinkle> getting this stuff to perform *and* garbage collect correctly was quite a challenge
20:44:04 <dfeuer> I wish GHC were built differently wrt IO, and made it easier to glue on alternative concepts of it like FRP, operational monads, etc.
20:44:23 <ryantrinkle> yeah; i'm not sure what that would look like, but it sounds good :)
20:45:06 <ryantrinkle> i'm actually starting to get close to the point where i might need to contribute to ghc to get more performance gains
20:45:14 <ryantrinkle> e.g. it might be possible to make lighter-weight Weak pointers
20:45:26 <ryantrinkle> since the majority of mine don't require finalizers or anything like that
20:45:48 <ryantrinkle> perhaps dispensing with some of their features would make something more performant
20:45:54 <dfeuer> Reason number 2 is, perhaps, that monadic IO is an exceedingly well-understood model, while FRP is less so. It would be quite reassuring if FRP could be implemented efficiently on top of IO.
20:46:15 <ryantrinkle> yeah; it certainly can be
20:46:36 <ryantrinkle> in fact, if you just added a monad constraint to every function in Reflex, you could get rid of the unsafePerformIO easily
20:46:38 <jle`> it'd be interesting to have a sort of extensible io system
20:47:00 <conal> dfeuer: i'd say exactly the opposite. IO has no denotation (and would have to be prohibitively complicated), while FRP has a precise and simple denotation.
20:47:40 <ryantrinkle> dfeuer: the tricky thing is that programming with everything being monadic is just really annoying :P
20:47:54 <dfeuer> conal, that is fair. However, the ST s *fragment* of IO is substantially less tricky.
20:47:59 <jle`> oh nice of conal to drop by suddenly
20:48:00 <conal> "monadic" IO is imperative programming
20:48:05 <ryantrinkle> conal: good to see you!
20:48:09 <dfeuer> :-)
20:48:10 <conal> ryantrinkle: you too!
20:48:31 * dfeuer wants to watch the reactive vs. reflex cage match.
20:48:33 <conal> And I think it's a misnomer to call Haskell IO "monadic".
20:48:45 <conal> i.e. the claim that IO is a monad.
20:49:15 <ryantrinkle> dfeuer: reflex is just my best attempt to implement conal's ideas :)
20:49:16 <conal> .... is unfounded afaict
20:49:22 <dfeuer> Oh?
20:49:31 <dfeuer> I don't think I've seen this claim before.
20:49:40 <jle`> conal *is* frp
20:50:10 <weijf> while we have all the frp folks here ..
20:50:12 <Axman6> Fun, fact, I used to own Conal's phone, but we've never met. it was weird
20:50:14 <conal> dfeuer: as i understand it, the "monad" claim is "not even false". it's not a meaningful statement.
20:50:25 <conal> Axman6: hah. i'd forgotten.
20:50:28 <jle`> he is the physical manifestation of frp on this earthly plane
20:50:37 <exio4> conal: "the report said it is a monad so it has to be" :p
20:50:38 <dfeuer> I have noticed that conal has very strong views about certain "FRP" frameworks; I haven't seen him discuss reflex yet.
20:50:46 <Axman6> =)
20:50:50 <weijf> ryantrinkle is reflex suitable for game dev, with 60-90fps reactive computations?
20:51:15 <ryantrinkle> weijf: i haven't tested it on those kinds of workloads, but i've recently seen some indications that it might be
20:51:43 <ryantrinkle> weijf: see this thread: https://www.reddit.com/r/haskell/comments/3qsz16/why_is_this_reactivebanana_code_slow/
20:51:49 <dfeuer> conal, do you think FRP gives a simpler basis for thinking about IO than operational monads?
20:52:05 <ryantrinkle> weijf: especially this comment: https://www.reddit.com/r/haskell/comments/3qsz16/why_is_this_reactivebanana_code_slow/cwisqh1
20:52:12 <conal> dfeuer: what do you mean by "IO"?
20:53:08 <ryantrinkle> weijf: in that example, it's doing audio processing, which is a very high frame rate
20:53:10 <weijf> ryantrinkle i remember that
20:53:42 <ryantrinkle> weijf: there are some simple improvements that might be able to speed up the frame startup/teardown times, so this can probably be improved greatly
20:53:44 <dfeuer> conal, perhaps that's a philosophical matter? I tend to think of it in terms of FFI, filesystem access, network access, terminal I/O, graphics production, ....
20:54:54 <jle`> i'd probably use something like netwire for 60/90fps/auto processing stuff, though
20:55:10 <conal> dfeuer: that's all imperative stuff, lacking rigor/dependability/provability. do you know about peter landin's notion of "denotative" / "genuinely functional"?
20:55:33 <ryantrinkle> weijf: if you wanted to prototype something, i'd be happy to take a look at it and see if there's a way to optimize reflex for your workload
20:55:47 <ryantrinkle> one of the nice things is that we actually have some support behind Reflex now
20:55:59 <conal> haskell is weird in that it's a hybrid between mathematical elegance and fortran-on-steroids.
20:56:16 <dfeuer> conal, I think I've encountered some mention of such in your writings. Having largely to do with morphisms from code to concepts or some such?
20:56:30 <ryantrinkle> obsidian is up to 7 people, most of whom have a lot of reflex experience
20:56:48 <roconnor> conal: if the only IO operations in haskell were putChar and getChar, would you consider that IO object denotationally well defined (as a tree)?
20:57:23 <weijf> conal i'd like tos ee the fortran on steroids part of it. referring to anything particular? as far as i can tell idontgetoutmuch has been fighting a lonely battle on that front...
20:57:57 <conal> dfeuer: yes, but that description makes denotation sound more complicated than it is. it's just a precise, compositional interpretation of code as mostly-familiar mathematical objects like numbers, products, sums, and functions.
20:58:10 <dfeuer> jle`, I suspect GHC erred long ago by committing too hard to one particular (and particularly lousy) notion of IO. I'm not sure what a more flexible system would look like, but I would hope there would be enough room for things like FRP.
20:58:30 <johnw> conal: it's where all functions are defined in terms of either mathematical objects, or other functions within the semantics, right?
20:58:35 <jle`> well, we switched notions of IO once before
20:58:49 <jle`> maybe we can do it again :3
20:59:32 <conal> weijf: by "fortran on steroids", i mean more powerful ways of generating imperative computations (IO) than Fortran. but inheriting all of the basic semantic defects. see backus's turing award paper.
20:59:58 <dfeuer> conal, unfortunately, things like "files" and "terminal emulators" and "OS threads" are not so terribly familiar or well-behaved mathematical objects. How are we to deal with that?
21:00:10 <conal> http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm
21:00:16 <johnw> dfeuer: you're allowed to use abstract terms, so long as you characterize them somehow
21:00:21 <weijf> jle` dfeuer i get the feeling the current obsession with monads is a mistake myself..
21:00:51 <johnw> a "File" can be just a term that a set of functions provide operations in relation to; or it can be a function from position to byte
21:00:55 <conal> dfeuer: the same say we dealt with other low-level implementation mechanisms like stack & register munging, manual memory allocation, and goto.
21:01:13 <ryantrinkle> weijf: i totally agree; it would be like if someone started learning Java by contemplating the abstract nature of Objects instead of writing code
21:01:19 <dfeuer> jle`, I think it's likely too late for GHC. Too much code depends not only on the Report notion of IO but on its specific realization in terms of side-effecting primops in a fake state monad.
21:01:26 <ryantrinkle> it's absolutely not necessary to understand what "Monad" means before using IO, [], or Maybe
21:01:57 <jle`> i do believe that there's been active community effort to push back on monadmania over the past year or two; it's definitely different now than it was 5-10 years ago
21:02:05 <conal> dfeuer: i.e., we moved those things into the *implementation* of semantically/denotationally simple & precise concepts. another example is assignment, which we moved into the implementation of non-strict pure functions.
21:02:20 <johnw> jle`: we just executed "join" on the multiple levels of mania a few times
21:02:42 <jle`> now we just need to extract
21:02:46 <ryantrinkle> i've found it helpful to use the term "Action" a lot
21:02:51 <ryantrinkle> when speaking with beginners
21:02:54 * dfeuer goes away, hopefully for just a few minutes.
21:02:57 <roconnor> when it comes to teletype IO, I don't think there exists any semantics beyond the free monad for the getChar and putChar operations.
21:02:58 <ryantrinkle> "IO action"
21:03:01 <ryantrinkle> "IO is a type of action"
21:03:06 <ryantrinkle> etc.
21:03:24 <ryantrinkle> it seems to play a lot better with beginners than actually talking about monads at all does :P
21:03:29 <dfeuer> I agree with roconnor, which is what's making it hard for me to see how conal hopes to deal with the problem of *interfaces* that suck.
21:03:31 <jle`> i think at this point it's accepted that "io monad" is a bad term for almost any situation
21:03:36 <jle`> at least, i hope
21:03:53 <Cale> dfeuer: I'm just reading through the backlog, and one thing I think should be said about currentTime behaviours is that they have the problem of always being invalidated, so wherever anything depends on the value of such a behaviour, it will always need to be recomputed
21:04:05 <conal> roconnor: yes -- with a small set of primitives like putChar & getChar, there are denotations. i wouldn't choose a tree, as it's not very helpful. for the same reason, i don't think of numbers as trees, even though one can use trees to represent syntax for number expressions. 
21:04:28 <Cale> dfeuer: So you have to be really careful about the expense of working with them, even once you have them.
21:04:37 <conal> jle`: i like "monads".  i just don't like the widespread claim that haskell IO is one.
21:05:09 <conal> jle`: nor the false reassurance that there's something principled going on there.
21:05:27 <weijf> ryantrinkle agree, but I wonder if a monad is even the right abstraction for IO?
21:05:38 <ryantrinkle> weijf: well, i'd definitely like to get away from it
21:05:39 <roconnor> conal: I'm pretty sure a tree captures exactly what teletype is.  Anything else would be isomorphic.
21:05:56 <Cale> Monad is not a big deal, it's a little pattern which shows up in lots of libraries, and we abstract over it in order to not have to write the stuff in Control.Monad (like sequence, liftM2, etc.) over and over
21:06:07 <ryantrinkle> eventually, i'd love to write my main functions in terms of FRP
21:06:09 <conal> weijf: i'd ask a different question: what denotation/model do we want? and only then ask whether that model is a monad.
21:06:14 <Cale> The fact that IO happens to be a monad is not terribly important
21:06:35 <ryantrinkle> that's one reason that reflex-dom has a function "mainWidget", which supplies a reasonable default translation from reflex-dom to IO
21:06:40 <ryantrinkle> so you can just write
21:06:41 <Cale> What's more salient about IO in Haskell is that there is a type of IO actions at all.
21:07:01 <conal> roconnor: syntax is a degenerate semantics. it's just not very useful. there are no non-trivial equalities. so no room to reason usefully.
21:07:01 <scshunt> Can someone show me a practical example of a comand? Hackage is insisting there are no docs for comonad
21:07:02 <jle`> Cale, conal: they're pretty nice, but it's the hype that was unjustified and gave a lot of false impressions/misconceptions
21:07:18 <ryantrinkle> mainWidget $ button "Click me!" >>= count >>= display
21:07:29 <jle`> i'm specifically referring to culture, not the concept itself
21:07:34 <ryantrinkle> and you get a reflex-dom web app that does what you'd expect
21:07:38 <roconnor> conal: right, but for teletype IO there aren't any other equalities.
21:07:43 <Cale> scshunt: have you read this? http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
21:07:57 <dfeuer> BACK
21:08:03 <jle`> scshunt: my personal favorite: http://hub.darcs.net/ertes/articles/raw-file/media-processing.lhs
21:08:35 <conal> Cale: i agree. haskell-with-IO is a DSL for imperative programming. so if one is into imperative programming, it's a good choice. imperative computations as values is a good idea, like just about anything else as values. but we didn't set out to make a better fortran (power tool for incomprehensible programs).
21:08:42 <jle`> i've used comonadic interfaces for Store/polymorphic comonad functions to implement differential equation solvers
21:09:05 <roconnor> conal: oh, right, why a tree, because tree represent continious functions from streams to streams.
21:09:07 <scshunt> thanks
21:09:14 <scshunt> jle`: whoa, cool
21:09:23 <roconnor> conal: perhaps you prefer that denotation, but it is isomorphic :)
21:09:23 <Cale> conal: Sure, but it's a good start for interoperability with an underlying system that is such a fortran
21:09:25 <conal> roconnor: then i don't know what you mean by teletype IO.
21:09:35 <jle`> scshunt: the technique is similar to the one in the ertes article i linked
21:09:43 <scshunt> neat
21:09:56 <conal> roconnor: moreover, that notion of "IO" is nothing like Haskell's "IO"
21:10:00 <Cale> conal: Like, you can't easily escape the fact that your programs at least for now are running on Linux or Windows or something not too different.
21:10:01 <jle`> that's just one particular comonad, though
21:10:07 <scshunt> will read
21:10:07 <ryantrinkle> jle`: btw, i really liked what you did with persistence in auto
21:10:22 <Cale> conal: So it's good to be able to interoperate on that level with the operating system in a comprehensible way.
21:10:40 <Cale> conal: Of course the first goal should be abstracting over that to something nicer
21:10:50 <jle`> ryantrinkle: oh, thanks :) it was a concept mm_freak (netwire author) and i bounced around.  i still stay up late at night sometimes about how to write migrations though
21:10:58 <roconnor> conal: really, *nothing* like Haskell's IO.  you exagerate.  It is a least reminicent of Haskell's IO.
21:11:01 <Cale> Sometimes the something nicer is just yet another, higher level, imperative language
21:11:07 <conal> Cale: i don't want to escape OSs. i want to reason correctly and easily about my programs, independent of implementation complexity as much as possible.
21:11:20 <Cale> Sometimes it's one of these FRP systems we're building
21:11:24 <ryantrinkle> jle`: ah yeah, that sounds tough!
21:11:41 <ryantrinkle> some folks have been talking about starting to work on a client-side routing library for reflex at Compose
21:11:48 <ryantrinkle> it would be great to have your input on that
21:11:50 <conal> roconnor: sorry. s/nothing/almost nothing/. consider that the IO type has tens (hundreds) of thousands of primitives.
21:11:52 <ryantrinkle> i think it's a much simpler problem, though
21:11:58 <Cale> I don't think it's so terrible to have an imperative-ish substrate for now, so long as the rest of the machine at least kinda works like that
21:12:19 <Cale> Maybe eventually FRP will stop being a research project and we'll all agree on how it's to be done, exactly.
21:12:50 <roconnor> conal: but a lot of those hunderds of thousands of priminitives are just variants of getChar and putChar, with some notable exceptions.
21:13:03 <ryantrinkle> Cale: i think we, of all people, can safely say that it's not a research project anymore ;)
21:13:08 <dfeuer> conal, I think it's almost as important to have as principled a way *as we can* to bridge the gap between the beautiful ideas we can represent and the nitty-gritty implementations they need to translate to underneath.
21:13:17 <Cale> ryantrinkle: Well, it's a very practical research project now
21:13:37 <dfeuer> For that particular job, IO and ST seem like *relatively* well-behaved tools.
21:13:38 <conal> For me, the issue isn't about just FRP. It's about remembering that Haskell IO is a stop-gap measure to use when necessary while we're still figuring out how to program functionally and get the benefits in reasoning.
21:14:00 <ryantrinkle> Cale: haha yeah, definitely; usually research projects can't pay the bills
21:14:05 <dfeuer> Whereas unsafePerformIO in a graph reduction machine most assuredly is *not*.
21:14:44 <conal> roconnor: IO is not even deterministic. 
21:15:10 <jle`> ryantrinkle: sure, would be happy to chime in if i could add anything of value :)
21:15:25 * dfeuer gets *very* nervous around unsafePerformIO when it's used to actually perform IO.
21:15:48 <dfeuer> And only slightly less nervous when it's used for anything else.
21:16:10 <ryantrinkle> jle`: cool; compose is February 4-7; the weekend days are likely to be the busier ones for projects
21:16:21 <conal> in spirit, everything in haskell *other than IO* is implemented with unsafePerformIO. just under the hood, and carefully so that it's actually safe.
21:16:23 <ryantrinkle> (2 days of Conference and 2 days of Unconference, i.e. hackathon)
21:16:24 <roconnor> conal: I was interested in whether you would object to a stripped down IO restricted to the well-understood parts, like teletype IO.
21:16:30 <Cale> ryantrinkle: It's great that we can get things done in reflex, but it's pretty likely that the reflex that we're using in 5 years will have some significant differences from this one.
21:16:33 <roconnor> conal: sounds like you would be okay with that.
21:16:42 <ryantrinkle> Cale: yeah, absolutely :)
21:16:53 <ryantrinkle> like fusion!
21:16:58 <Cale> indeed
21:17:07 <jle`> i'll see if i can get my school to sponsor me
21:17:28 <ryantrinkle> jle`: that'd be awesome
21:17:52 <dfeuer> conal, it's true that lazy evaluation involves mutation, but that's a very *small* amount of under-hood nastiness. Or were you talking about something else?
21:18:03 <Cale> (and even perhaps interface differences -- like it doesn't seem certain that we keep DMap around forever, e.g.)
21:18:17 <conal> roconnor: sure. just as long as people don't conclude that it somehow makes the actually full, non-denotative IO any more principled.
21:18:30 <Cale> But maybe that'll be replaced with a real dependently typed finite map type :)
21:18:33 <ryantrinkle> Cale: yeah, that's definitely true
21:18:49 <ryantrinkle> i'm sure DMap could be improved
21:18:52 <roconnor> conal: okay
21:19:09 <conal> dfeuer: yes. something else. addition, multiplication, everything. they're all implemented imperatively, but wrapped up w/o the "IO" tag in their types.
21:19:57 <roconnor> Ah, it was "Representations of stream processors using nested fixedpoints" by Hancock, Pattinson, and Ghani
21:20:19 <roconnor> showing continous functions on streams are isomorphic to trees
21:20:30 <conal> and of course the underlying "machine" is an abstraction as well. actual von neumann machines disappeared decades ago.
21:20:34 <roconnor> which is really Brouwer's bar induction.
21:20:35 <jle`> conal: what about the notion of creating fully denotative IO frameworks within Haskell, and then writing a Haskell library to "compile" it into an IO ()?
21:20:41 <jle`> wihotu ever touching IO along the way
21:20:51 <roconnor> Good ol' Brouwer.
21:20:58 <Cale> jle`: Well, that's kind of what we do.
21:21:06 <conal> roconnor: thanks. i'll take a look and maybe figure out what you mean about trees
21:21:29 <beefsack> Hi all, decided to jump into Haskell again but would like a little advice regarding error handling.  I'm doing board game implementations each as separate libraries, and am hoping to have my error style consistent among all of the game libraries.  The idea is that there will be binaries which consume a number of these board game libraries to provide interfaces to the games and the more unified I can make the libraries the easi
21:21:29 <beefsack> er those binaries will be to implement.  I've been reading http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/ and the linked mailing list discussion but it's not really helping me pick a way forward.  Do people have any suggestions regarding error handling given my use case?
21:21:32 <conal> roconnor: i hope it's not a syntax/semantics confusion
21:21:33 <jle`> Cale: that's kind of the 'hope', right?
21:21:40 <dfeuer> conal, ah, yes, the rest of the reduction machinery. Still, that's far less "wild" than using unsafePerformIO from within Haskell, where a whole optimization pipeline sits between what you're trying to express and what actually happens.
21:21:53 <roconnor> conal: it's from Logical Methods in Computer Science, volum 5 (3:9) 2009, pages 1-17
21:22:03 <conal> roconnor: thanks
21:22:08 <roconnor> but the title is probably adequate to find it.
21:22:19 <conal> roconnor: yep. got it.
21:22:22 <Cale> jle`: I mean, it's also the practice of what we're doing with FRP systems -- though maybe in some cases we could be better about actually completing the mathematical side of things, rather than just saying "yeah, these things probably have nice denotations which we'll get around to writing down at some point"
21:22:49 <roconnor> conal: they conver the stream-processor to tree connection, and you probably know the tree is a monad connection.
21:23:06 <jle`> i like to think that netwire is a success in the fully-denotative-mathematical side
21:23:11 <Cale> (but I think once can be reasonably convinced that there is a nice denotation without that formalism being in place to the extent that a computer would accept it)
21:23:16 <Cale> one*
21:23:31 <dfeuer> So I guess the way I think of it is that both of these approaches are entirely sane: 1. Implement FRP on top of IO. 2. Implement FRP in the compiler.  The currently-expedient approach 3. Implement FRP in Haskell using unsafePerformIO   seems a bit scary.
21:23:32 <jle`> i am less convinced of the push/pullers
21:23:36 <conal> dfeuer: what i was getting at: when i use unsafePerformIO, I'm doing so in the same spirit as with pure primops, laziness, etc.
21:23:52 <Cale> beefsack: If you want the errors to be handled immediately, use Either
21:24:09 <roconnor> conal: on a somewhat unrelated note, are you familiar with "The Geometry of Synthesis"?
21:24:41 <jle`> to libraries like netwire, it's (1) implement FRP on top of data types providing only semantically consistent operations and compositions, (2) hook it onto IO in the messy implementation layer completely separate from the logic/programming side
21:24:42 <Cale> beefsack: If you expect the error to kill the program outright, and don't want to make it easy to catch, use 'error'
21:24:58 <dfeuer> conal, in the current world, that seems sensible. In the ideal world, it's like standing on the roof of a car and using poles with hooks on them to drive.
21:25:01 <conal> roconnor: yes. i've read those papers a few times and talked with Dan Ghica about the work. he visited at tabula when i was working there on compiling haskell to hardware.
21:25:15 <roconnor> conal: oh good.
21:25:20 <Cale> beefsack: If you're doing I/O, and you expect the user to only want to handle the error a small fraction of the time, use Control.Exception
21:25:39 <conal> roconnor: it's not what i hoped it would be, and i couldn't really tell until i talked with Dan in person.
21:26:01 <conal> roconnor: it's only weakly and impurely functional
21:26:22 <dfeuer> beefsack, I'd modify Cale's advice slightly. error, IMO, should only be used for "internal" errors, indicating that there is *buggy code*.
21:26:31 <Cale> right
21:26:50 <Cale> Which is pretty much the only time you're likely to want to kill the program outright
21:26:59 <conal> roconnor: it's more like algol with affine types than a functional/denotative language
21:27:13 <dfeuer> Cale, if I want to kill the program outright for a different reason, I want to do it using a different mechanism.
21:27:14 <beefsack> Cale & dfeuer: Thanks for the direction :) the majority of errors will be invalid input (e.g. playing when it's not your turn) and would be handled immediately, `Either` seems like a nice simple way to handle those
21:27:21 <Cale> (there is a way to catch the exception thrown by an 'error', but it is hard, and a last resort)
21:27:28 <Cale> yes
21:27:58 <conal> i'm back to work on the haskell-to-hardware compiler now. it was much too slow, but i've had a breakthrough, and i think it'll be tremendously faster now. i have yet to put the pieces all back together.
21:28:19 <conal> and i have plans for other back-ends besides hardware (HDL). should be fun.
21:28:35 <dfeuer> Catching an exception thrown by `error` is for weird systemy code like web servers that needs to work in the presence of other people's buggy code being linked with it.
21:28:45 <dfeuer> conal, that sounds interesting. Good luck.
21:28:47 <roconnor> conal: okay.
21:29:18 <Cale> dfeuer: Yeah, you're more likely to just download the source of the library which threw the 'error' and fix it.
21:30:43 <conal> dfeuer: thanks. :) i'm very excited about it. i have some *beautiful* formulations of useful operations like scans, sorting, linear algebra, and FFT, all of which turn into massively parallel implementations.
21:30:45 <dfeuer> Cale, I mean if your server has to do something useful when someone throws an error from their form handling thingumjigger.
21:30:57 <dfeuer> Cool!
21:31:28 <conal> roconnor: i scanned that paper. didn't see anything about an *isomorphism*. 
21:31:35 <dfeuer> conal, please just don't implement launchMissiles in that code; it could actually launch missiles if you do.
21:32:04 <conal> dfeuer: don't worry. i'm a pacifist.
21:32:04 <jle`> i was disappointed when i started using haskell that there isn't an actual launchMissiles implemented in ghc
21:32:17 <dfeuer> (Or, for that matter, `irradiateMachineOperator`!)
21:32:33 <dfeuer> jle`, there's an ACME package for that.
21:32:51 <ryantrinkle> dfeuer: well, you have to trust GHC when it tells you that its pure functions are pure
21:33:05 <ryantrinkle> you also have to trust reflex when I tell you they are
21:33:12 <ryantrinkle> that's basically what it means for me to be using unsafePerformIO :)
21:33:30 <ryantrinkle> it would be ideal to not have that situation
21:33:39 <dfeuer> ryantrinkle, it's not *you* I don't trust so much as the shady ways GHC behaves around unsafePerformIO.
21:33:56 <ryantrinkle> it's not *that* bad
21:33:59 <dfeuer> And I recognize there may not be any practical way around that sad state of affairs.
21:34:09 <ryantrinkle> :)
21:34:32 <scshunt> do I get smacked if I ask what the dual of fail is, when working with comonads?
21:34:36 <ryantrinkle> i'm a lot more confident in unsafePerformIO than i am in a lot of code i've written in C++ :P
21:34:50 <ReinH> scshunt: there is no dual to fail
21:34:56 <Cale> scshunt: You should first ask what the hell fail is doing in Monad in the first place
21:34:59 <ReinH> fail is not a principled part of the monad interface
21:35:02 <Cale> scshunt: It doesn't belong there
21:35:18 <Cale> (and it's finally getting moved out into its own class!)
21:35:21 <Adeon> cofail
21:35:28 <ReinH> again!
21:35:34 <ryantrinkle> fail getting moved out is awesome
21:35:42 <dfeuer> ryantrinkle, see for example this pull request I opened for the configurator package: https://github.com/bos/configurator/pull/26  That's much worse than anything I'll find in your code, I imagine.
21:35:46 <dfeuer> But still....
21:35:48 <Cale> But yeah, you could do something like  cofail :: m a -> String
21:36:07 <jle`> dfeuer: ugh yes i don't know why that pull request hasn't been addressed yet
21:36:08 <Cale> It's just... not very failure-related
21:36:15 <dfeuer> Does anyone know the timeline on pulling out fail?
21:36:19 <ryantrinkle> dfeuer: yeah, that's a horrible thing
21:36:27 <Adeon> in ghc 8 I think MonadFail goes in
21:36:29 <Cale> dfeuer: I thought it was going to be 8.0?
21:36:30 <Cale> yeah
21:36:32 <Adeon> IIRC it's in rc1 that was released recently
21:36:32 <jle`> i just saw it again the other day too
21:37:04 <dfeuer> I noticed the other day that Semigroup => Monoid  *hasn't* made it into GHC HEAD yet. Disappointing....
21:37:19 <ryantrinkle> in reflex, unsafePerformIO is only used to allocate cache IORefs, and the whole rest of the system goes to great pains to ensure that you can never detect that they're in use (semantically)
21:37:22 <Adeon> hmm, are Semigroups even in base?
21:37:28 <dfeuer> Yes.
21:37:31 <dfeuer> They are now.
21:37:33 <Adeon> ooh
21:37:40 <Cale> I find it a little bit surprising that these refinements to type classes are being done now after all these years
21:37:41 <dfeuer> Cool, ryantrinkle.
21:37:43 <jle`> if they're in base, then why not.  time to submit a ninja PR
21:37:53 <jle`> also time to get instance Semigroup a => Monoid (Maybe a)
21:37:59 <Cale> Either it's because there's pressure from actual examples in libraries
21:38:07 <Cale> or because we have a czar
21:38:11 <dfeuer> jle`, that's the wrong instance, per conal and also me.
21:38:21 <dfeuer> ER .... no, sorry.
21:38:22 <dfeuer> Not conal.
21:38:23 <jle`> would you rather the <|> instance
21:38:34 <dfeuer> I meant Conor McBride.
21:38:39 <dfeuer> Yes, <|>
21:38:51 <dfeuer> We need something *else* with the instance you suggest.
21:39:19 <dfeuer> But it's way too late to fix that horrible bug, i fear.
21:39:24 <jle`> it's the canonical embedding of a semigroup into a monoid :O
21:39:43 <dfeuer> jle`, yes. A perfectly lovely instance *for something that's not Maybe*.
21:40:47 <scshunt> darn it
21:41:00 <dfeuer> But as McBride says, Maybe is all about things that can fail (uninformatively). Everything else about it operates on that principle, so its Monoid instance should too.
21:41:17 <dfeuer> scshunt, what color yarn?
21:41:34 <scshunt> dfeuer: white, please
21:41:56 <jle`> 'things that can fail' is captured by its functor/applicative/monad instaces, particularly, i think; and it makes sense that the alternative and monadplus instances would be defined with that interpretation
21:42:39 <ryantrinkle> i just wish we could have mappend = Data.Map.unionWith mappend :(
21:42:51 <roconnor> conal: I see you are right.  The trees are only representive of continous stream processors.
21:43:17 <Axman6> mmappend = Data.MAp.uninWith mappend -- You can!
21:43:18 <roconnor> but the same strea processor can be, in some cases, represented by different trees.
21:43:27 <ryantrinkle> Axman6: how?
21:43:33 <conal> roconnor: that part is easy to believe. 
21:43:39 <Axman6> just call it mmappend :P
21:43:42 <ryantrinkle> lol
21:43:47 <ryantrinkle> haha, or, better yet
21:44:00 <ryantrinkle> import Data.Monoid hiding (mappend)
21:44:00 <conal> roconnor: so more like a syntax to the flow functions' semantics
21:44:04 <ryantrinkle> etc. etc. :P
21:44:07 <roconnor> the tree representive expliclity contains a modulus of continuty, while a continous stream function doesn't have a specific modulus of continutity.
21:44:08 <Cale> Yeah, that doesn't quite work out if you're trying to use something which is abstracted over a choice of Monoid... you need to make a newtype wrapper
21:44:26 <Cale> There should really be a newtype wrapper for the current instance and the lifting instance should be preferred
21:44:32 <Cale> To go along with the instance for functions.
21:44:38 <Cale> (and for e.g. Maybe)
21:45:02 <Cale> But good luck with that change
21:45:09 <ryantrinkle> haha yeah, i don't think it's happening :P
21:45:16 <scshunt> jle`: is there an explanation of the Store comonad somewhere?
21:45:17 <Cale> Because it'll break anything which uses the instance probably silently
21:45:21 <roconnor> conal: if we were in a constructive logic and said that a continuous stream function was a pair of a stream function and a modulus of continuity for that stream function, then we'd probably get an isormophism.
21:45:28 <Cale> and in a way which might not even be easy to detect at first
21:46:05 <conal> roconnor: who knows? and still not about trees.
21:46:11 <Cale> Like if you're combining Maps of lists or Strings, now you're appending the lists on collision and everything still builds and runs :D
21:46:11 <conal> roconnor: iirc
21:46:15 <conal> roconnor: i mean iiuc
21:46:17 <dfeuer> ryantrinkle, the way to do this is to write a module that reimplements the entire interface of Data.Map (and Data.HashMap, etc.) using GeneralizedNewtypeDeriving for almost everything.
21:46:37 <dfeuer> Cale, what are you talking about newtype wrappers and lifting instances and what?
21:46:46 <jle`> scshunt: the edwardk comonad article linked earlier has one, and i think ertes's article does oto
21:46:49 <jle`> *too
21:46:49 <ryantrinkle> dfeuer: that doesn't sound especially fun :P
21:47:04 <ryantrinkle> i usually just struggle through manually writing Map.unionWith mappend
21:47:11 <Cale> dfeuer: "lifting instance" means something like  instance (C a) => C (T a)
21:47:16 <dfeuer> ryantrinkle, I've done it. It's really not bad at all. The hard part is packaging it up and sticking it on Hackage with a good name.
21:47:26 <Cale> dfeuer: where here we're talking about C = Monoid and T = Map e
21:47:26 <ryantrinkle> dfeuer: ah, yeah
21:47:29 <scshunt> ReinH: Cale: (re: cofail) yes, that was the joke ;)
21:47:36 <conal> roconnor: what are you up to these days?
21:47:38 <dfeuer> Cale, I don't get the context of what you're talking about there.
21:48:03 <Cale> dfeuer: Well, if you want to make multiple instances of a type class for a given type, one of your options is to define a bunch of newtypes of it
21:48:11 <dfeuer> Yes.
21:48:13 <Cale> dfeuer: Like what was done with Sum and Product
21:48:16 <dfeuer> Yes.
21:48:19 <scshunt> Cale: wait, fail's getting moved out?! Hurrah!
21:48:20 <Cale> we could have similar newtypes of Map
21:48:24 <roconnor> conal: working for the man.
21:48:27 <ryantrinkle> dfeuer: i wonder if you could write a TH splice that automatically did that for a module
21:48:38 <ryantrinkle> "I want exactly this module, but with the following changes..."
21:48:41 <roconnor> conal: mostly thinking about lenses
21:48:43 <Cale> But the default instance for plain Map e, should probably be the lifting instance
21:48:49 <roconnor> conal: and other "optics"
21:48:49 <Cale> except that'll never happen now
21:48:54 <conal> roconnor: ah. :)
21:48:58 <dfeuer> ryantrinkle, I don't know. TH looks like a bunch of horrors to me.
21:49:04 <Cale> because code which uses the existing instance would silently break if you changed it
21:49:20 <ryantrinkle> Cale: would it be better as a Map.unionWith sappend ?
21:49:33 <ryantrinkle> dfeuer: it's not the most elegant thing ever, but it's great for heavy lifting
21:49:39 <roconnor> conal: you can read the last 4 or 5 posts from http://r6research.livejournal.com/ if you want to see what I've been thinking about lately.
21:49:44 <ryantrinkle> i wouldn't want to write my own JSON instances for everything :P
21:50:00 <ryantrinkle> (though i guess that can often use Generic these days)
21:50:03 <conal> roconnor: thx.
21:50:03 <Cale> I haven't thought much about how Semigroup fits into this, but yeah, if we have Semigroup, and it's a superclass of Monoid, then yes
21:50:04 <dfeuer> ryantrinkle, I really tried reading the papers about it, and documentation elsewhere, and ended up rather lost.
21:50:07 <scshunt> jle`: which edwardk article?
21:50:18 <roconnor> Grates are kinda interesting.  It will be fun to see where they go.
21:50:19 <scshunt> I see the ertes one and the Dan Piponi one
21:50:21 <jle`> on comonads and cellular automata, it was posted up earlier, heh
21:50:24 <jle`> oh
21:50:34 <jle`> https://www.schoolofhaskell.com/user/edwardk/cellular-automata
21:50:43 <ryantrinkle> dfeuer: i'd recommend reading the haddocks more than anything else: https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Exp
21:50:45 <Cale> ryantrinkle: However, the change will still be a silent breaking change in lots of code.
21:50:50 <dfeuer> ryantrinkle, that *does* use Generic, I believe. Speaking of which, Generic seems not to mesh well at all with some other things :-/
21:50:53 <scshunt> dfeuer: why can't Monoid (Maybe a) be in base?
21:51:03 <ryantrinkle> but honestly, TH is mostly only useful if you have a very serious task to take on
21:51:10 <Cale> ryantrinkle: In fact, it'd probably break a bunch of reflex-dom using code
21:51:13 <Cale> ryantrinkle: lol
21:51:22 <dfeuer> scshunt, it is; it's just not the way we want it.
21:51:23 <ryantrinkle> hahaha, yeah
21:51:25 <Cale> ryantrinkle: think about what happens to attribute lists
21:51:31 <jle`> scshunt: there isn't *too* much to store, though, and it'd be fun to implement the Comonad instance yourself.  and the articles linked above are basically practical applications of it
21:51:52 <ryantrinkle> Cale: well, attribute lists should be OK if they never have overlapping keys :P
21:51:57 <Axman6> scshunt: IIRC the only sensible implementation for Monoid (Maybe a) relies on Semigroup a, which isn't something available in base
21:51:59 <jle`> implementing your own Comonad instance for Store is def fun, like implementing your own Monad instance for State
21:52:02 <jle`> rite of passages, heh
21:53:02 <dfeuer> Axman6, there are two sensible implementations. That's one. The one Conor McBride prefers (and I happen to agree with him) defines  mappend=(<|>) and mempty=empty
21:53:05 <ryantrinkle> suzu: ah, just found your issue in the nixpkgs tracker! https://github.com/NixOS/nix/issues/599
21:53:17 <dfeuer> Axman6, also, Semigroup is going into base.
21:53:23 <Axman6> great
21:53:35 <ReinH> Monoid a => Monoid (Maybe a) is a monoid that ignores the original identity of a and tacks on a new one instead. It is a silly thing.
21:54:02 <jle`> scshunt: also, to me, the comonad laws as stated with extract/duplicate are much nicer to me in haskell than any statement of the monad laws
21:54:08 <Cale> ryantrinkle: right, but right now, it's kind of sensible what happens if keys overlap (the later one overrides), whereas concatenation would result in some really funny things happening for e.g. attributes which are numbers
21:54:09 <dfeuer> I suppose the Semigroup a => Monoid (Maybe a)  instance could actually happen now; the unqualified instance will never happen because it would break too much code in horribly difficult-to-track-down ways.
21:54:27 <ReinH> dfeuer: Conor would also argue that one of those things is Maybe and one of those things is not Maybe a ;)
21:54:37 <ReinH> Or maybe neither of them are Maybe, I forget.
21:55:14 <dfeuer> ReinH, he thinks the Monoid (Maybe a) instance should be the same as the Alternative instance. He thinks the "tack a unit onto a semigroup" instance should be something else.
21:55:39 <dfeuer> No idea what he calls it.
21:56:47 <scshunt> dfeuer: oh, now I understand.
21:56:55 <ryantrinkle> Cale: yeah, although concatenation can work for somethings
21:56:56 <ryantrinkle> e.g.:
21:56:57 <scshunt> Yes, that makes sense.
21:56:57 <ReinH> dfeuer: yeah
21:57:09 <ryantrinkle> "class" =: "a " <> "class" =: "b"
21:57:10 <ReinH> dfeuer: we'll call you the pigworker whisperer
21:57:17 <ryantrinkle> would turn into "class" =: "a b"
21:57:20 <ryantrinkle> which is totally legit
21:57:21 <scshunt> dfeuer: I barf at the idea of the Alternative instance being default
21:57:22 <dfeuer> ReinH, hahahahaha no.
21:57:33 <ReinH> dfeuer: too late
21:57:44 <dfeuer> ReinH, I can't understand almost anything he ever says. That's one of the rare exceptions.
21:57:58 <ReinH> Oh I can understand all of it. I just don't know what it means.
21:58:09 <ReinH> But I reliably know all the words.
21:58:29 <dfeuer> ReinH, well, you're one up on me, then. I'll have to ask you to explain all the words next time.
21:58:35 <ReinH> so I've got that going for me, which is nice
21:59:19 <jle`> also, should we paint the monoid instance blue or red?
21:59:46 <scshunt> jle`: thanks
22:00:27 <scshunt> jle`: green!
22:00:49 <jle`> now listen here
22:01:13 <dfeuer> jle`, I think we need a committee to make that decision. Should we send out the request for date requests for the monoid-instance-color meeting on green paper or gray?
22:01:16 <scshunt> I wonder if something similar would be useful for my game state
22:01:41 <scshunt> dfeuer: first you need to have a meeting to decide who's on the committee. don't get ahead of yourself.
22:01:50 <scshunt> the problem, of course, is that game state is not very polymorphic
22:03:02 <scshunt> hmm actually I think this is useful in another, history-rewriting context
22:03:59 <Cale> ryantrinkle: actually, I might have to allocate a good chunk of tomorrow to taking care of all the passport shenanigans
22:04:17 <dfeuer> Cale, where are you traveling?
22:04:24 <Cale> Compose conference
22:04:37 <Cale> (so NYC)
22:06:52 <scshunt> although hmm, maybe I don't need comonads after all
22:07:21 <scshunt> I should definitely try to avoid this project having each module correspond to an attempt to shoehorn a new ekmett library I haven't seen before
22:09:46 <scshunt> ... the risk of that is high
22:14:10 <jle`> what's the modern story on cereal vs binary?  i've been using binary but i'm considering switching to `cereal` so i can use the safecopy library on it
22:14:15 <jle`> is there any reason to prefer binary?
22:16:42 <Adeon> I still use both but only because libraries might use one or the other
22:16:46 <Adeon> I think it's mainly lazy vs strict?
22:24:56 <roelof> I have stored my data in a map. Now I want to print it in a tabular form.  Is that possible without converting the data to a array ? 
22:29:44 <suzu> roelof: yes
22:30:04 <suzu> look at Data.Map assocs :: Map k a -> [(k, a)]
22:30:27 <jle`> Adeon: i wonder if there could be made a library that auto-generated instances from one or the other
22:30:47 <roelof> suzu:  it looks that I convert it  
22:31:11 <roelof> but thanks for the tip
22:31:39 <suzu> if you use Data.Map.Lazy it converts it lazily
22:31:59 <suzu> um, but yes i think you convert no matter what
22:32:11 <suzu> getting the set of keys and looking each one up yourself isnt any different
22:32:21 <suzu> looking each value up yourself*
22:33:40 <jle`> roelof: btw, that's a list, not an array
22:34:50 <ryantrinkle> suzu: i posted a workaround for your nix issue here: https://github.com/ryantrinkle/try-reflex/issues/51
22:35:10 <ryantrinkle> i haven't tried it, but a bunch of people in the NixOS/nixpkgs issues section seem to have had some success :)
22:35:57 <suzu> awesome! thanks a lot
22:36:08 <suzu> i got reflex to build just fine with stack just now though
22:36:09 <suzu> :D
22:36:23 <ryantrinkle> awesome :)
22:36:37 <suzu> this sort of setup craziness isnt common is it?
22:36:55 <ryantrinkle> yours was definitely worse than average
22:37:15 <suzu> heh ok
22:37:17 <ryantrinkle> the typical try-reflex experience is: git clone, run the script, 3 minutes of downloading later, you're ready to build a web app
22:37:31 <ryantrinkle> stack is also generally pretty clean to use
22:37:42 <ryantrinkle> ghcjs is still a bit bleeding-edge, though
22:37:50 <ryantrinkle> so some of the tooling has some trouble with it
22:37:53 <suzu> does reflex-dom work with regular ghc?
22:37:57 <ryantrinkle> yep
22:38:02 <ryantrinkle> try-reflex installs it for both
22:38:04 <suzu> and it'll output js?
22:38:11 <ryantrinkle> no, it runs as a webkitgtk app
22:38:20 <ryantrinkle> all native, just using webkit for rendering
22:38:39 <suzu> webkitgtk wtf is that
22:38:46 <suzu> interesting
22:38:58 <ryantrinkle> webkit is the engine that chrome and safari are based on
22:39:02 <ryantrinkle> originally based on khtml
22:39:08 <suzu> right
22:40:14 <ryantrinkle> webkitgtk is a wrapping of webkit for GTK-based apps
22:40:37 <ryantrinkle> it would be interesting to try binding directly to webkit, but it'd also be quite a lot of work :)
22:42:24 <suzu> i see
22:42:28 <suzu> well today was a fun day
22:42:33 <suzu> maybe tomorrow ill actually program!
22:42:48 <suzu> nn
22:44:42 <Heather> [10 of 10] Compiling Data.Label.Base  ( src\Data\Label\Base.hs, dist\build\Data\Label\Base.o )
22:44:43 <Heather> Segmentation fault/access violation in generated code
22:44:52 <Heather> what the hell is that :S
22:47:16 <nocturne777> what would be the benefit of having MonadCatch in a transformer stack ?
22:47:26 <johnw> to catch exceptions :)
22:47:40 <nocturne777> is to to be able catch exceptions thrown with throwM ?
22:47:50 <ryantrinkle> Heather: sounds like a very serious error
22:47:55 <roelof> someone else his/her oponion about this : 
22:47:58 <roelof> I have stored my data in a map. Now I want to print it in a tabular form.  Is that possible without converting the data to a array ? 
22:48:06 <ryantrinkle> perhaps in template haskell code that's being interpreted at compile time?
22:49:00 <nesqi> roelof: Why would it be easier to print from an array?
22:49:52 <nesqi> Do you already have code that prints it from an array?
22:50:10 <roelof> I have no clue. Im learning Haskell and see that for example text.prettyprint.boxes work with arrays 
22:50:12 <django_> do people get paid to write haskell?
22:50:36 <Axman6> I do
22:50:40 <Axman6> so, yes
22:50:41 <Heather> ryantrinkle maybe
22:50:49 <nesqi> django_: I do but I'm only using haskell on side projects as noone else here knows it.
22:50:53 <roelof> nesqi:  I can write code to print from a array bit not in such way its in a tabular form 
22:50:55 <Heather> ryantrinkle yet another ghc 8 bug?
22:51:20 <django_> nesqi, which project?
22:51:32 <ryantrinkle> Heather: ah, maybe so
22:51:39 <nesqi> django_: work related projects
22:51:41 <ryantrinkle> are you using 8 for anything in particular?
22:51:53 * Axman6 technically gets paid to write haskell for the Australian government
22:52:31 <scshunt> niice
22:53:11 <nesqi> roelof: Well you could look at the sourcecode for text.prettyprint.boxes and remodel it for a Map but it's probably not worth the effort.
22:53:45 <nesqi> roelof: Wait, you are not using text.prettyprint.boxes now?
22:53:50 <nesqi> The code is still to be written?
22:54:52 <dfeuer> Heather, you may or may not be the Heather whose lens issue I just commented on.
22:55:12 <roelof> nesqi:  I have tried to use it but till now no success 
22:55:47 <roelof> I think I will use data.map assoc and work from there 
22:55:48 <dfeuer> nesqi, you want what from boxes? Can I add what you want to boxes? I have been neglecting that package rather badly :(
22:56:28 <roelof> dfeuer:  I want to use it. but I use a map instead of a array 
22:57:15 <dfeuer> roelof, what do arrays have to do with it?
22:59:12 <dfeuer> roelof, I'm trying to understand what you mean. Are you talking about the fact that some convenience functions take *lists* of boxes? If so, you can extract lists from maps in various ways.
23:05:15 <roelof> dfeuer:  no, I have this map as a example  fromList [("cash on hands",Account {accountName = "cash on hands", accountBalance = 10, accountTransaction = []})]
23:05:45 <roelof> now I want to print the accountname and the accountBalance in a tabular way 
23:06:06 <roelof> dfeuer:  this is clear ? 
23:07:40 <dfeuer> roelof, yes, but what I don't understand is where you're running into a problem relating that to the boxes library.
23:09:04 <roelof> dfeuer:  the boxex library seems to work only with arrays and not with maps or am I mistaken 
23:09:30 <roelof> dfeuer:  I could not find a example of a map with the boxes library 
23:09:37 <dfeuer> roelof, you're going to have to write some function to convert your custom record type into a box, I suppose, but dealing with the Map, per se, should be just a matter of turning it into a list with Data.Map.toList or something. The boxes library deals with boxes, and has some convenience functions for lists (not arrays).
23:10:38 <dfeuer> But a Map is easily turned int a list.
23:10:40 <dfeuer> into.
23:11:14 <roelof> dfeuer:  I was hoping it could be without a list. I get the feeling that the same data is stored 2 times in memory 
23:11:56 <ryantrinkle> roelof: i'd recommend not worrying about the details of performance until you have something you *know* is slow
23:12:04 <dfeuer> roelof, you'd best not worry about that :-). Only *pointers* to the data *may* be stored twice, and thanks to laziness it's likely even those won't be.
23:12:07 <ryantrinkle> the haskell compiler is very smart, and often does things faster that you might expect
23:12:37 <ryantrinkle> as long as your algorithms are basically alright (i.e. the right big-O notation), you should be fine in most circumstances
23:12:43 <roelof> oke, thanks , I will try this way 
23:13:07 <dfeuer> Besides, anything you're building with boxes should be small enough to fit on a few pages (or a few thousand pages, anyway), so performance shouldn't be an issue.
23:13:38 <Heather> this is very weak https://github.com/snoyberg/conduit/issues/242 :(
23:15:53 <dfeuer> Heather, I can't really imagine why conduit would use ImpredicativeTypes. That extension is pretty thoroughly hosed.
23:19:04 <Heather> I'm really tired from haskell ecosystem atm, if sandboxes is the way everyone like then I give up
23:20:53 <ryantrinkle> Heather: hm, what's so bad about sandboxing?
23:21:40 <dfeuer> Heather, a whole lot of people like Stack. And the sandboxing story is very rapidly getting *much* less painful with recent Cabal changes.
23:21:49 <Axman6> I really like the stack way of "sandboxing" which shares identical library compilations
23:21:53 <Axman6> between sandboxes
23:22:22 <Heather> ryantrinkle sandboxing is good for production, when you need to have really close environment or using docker or for administrating complicated tasks but I don't want to have system like that
23:22:52 <ryantrinkle> hmm, i've actually been moving towards more and more sandboxing
23:23:03 <Axman6> me too, it's made me way more productive
23:23:15 <Axman6> stack has completely changed how I do development
23:23:17 <ryantrinkle> e.g. i lock down the precise version of Postgres for each of my projects
23:23:45 <ryantrinkle> i use Nix so that each of my projects has its own environment all the way from glibc up to Haskell
23:23:47 <Adeon> stack is a killer app for me
23:23:53 <Heather> good luck with sandboxes and one day haskell ecosystem will be something alike plan9
23:23:54 <Axman6> agreed
23:24:01 <Heather> good but dead
23:24:07 <Axman6> Heather: what are you talking about? o.O
23:24:12 <kadoban> Heather: It's a little unclear what the actual problem you're having is, or what tools you're using.
23:24:17 <Axman6> you're not actually making any sense
23:24:17 <Adeon> I have some company internal haskell projects and it's convenient when I can put in stack files the git paths from where to pull company internal dependencies
23:24:32 <Axman6> Adeon: yeah, we use that a lot
23:24:32 <Adeon> and reproducibility and all that nice stuff
23:25:12 <Axman6> Heather: you understand that the sandboxes used for haskell are for projects, not execution right?
23:25:13 <Heather> Axman6 I will need to write an article about it because I can't represent it clearly with two words
23:25:32 <kadoban> Heather: What tangible issue is sandboxing causing you, especially when used internally with a good tool like stack?
23:25:47 <Heather> Axman6 for projects which can't interact with other projects on code level
23:25:58 <Axman6> eh?
23:26:05 <Heather> kadoban I hate stack
23:26:18 <Axman6> it sounds very much like you don't understand it
23:26:39 <dfeuer> She may have good reasons for not liking it...
23:26:43 <kadoban> Heather: Okay.
23:26:45 <dfeuer> Let's wait for the article.
23:26:54 <dfeuer> (or blog post, or whatever)
23:27:02 <Heather> next day we will provide virtual box with operating system to build little util on haskell
23:27:49 <biocage> on freebsd plz
23:27:58 <Axman6> yeah this really sounds like you don't understand what stack does...
23:28:03 <Axman6> biocage++
23:28:56 <Axman6> docker integration is an optional part of using stack, but you definitely don't need to use it...
23:29:09 <Axman6> which is the closest thing to an execution sandbox that stack offers
23:29:58 <Axman6> stack is really just a build tool which lets you lock down version numbers of libraries you depend on (and as a byproduct share common libraries between different projects safely)
23:31:06 <Axman6> for us the docker integration means I can build linux executables for deployment on OS X easily, and with GHC versions I can't use on OS X (because 7.8 broke under El Capitan)
23:33:31 <spindas> Is there anything in types that uses the @ character?
23:33:40 <Heather> Axman6 it's a disorder because finally you don't need 7.8 to be fixed, you don't need newer version, etc...
23:35:31 <spindas> Brackets are used for lists in type signatures, parentheses for grouping, ~ for type equality constraints, etc - is @ used for anything yet?
23:36:04 <ryantrinkle> spindas: i believe it will be used in explicit type application syntax, which is coming up
23:36:45 <spindas> ryantrinkle: looks like it https://ghc.haskell.org/trac/ghc/wiki/ExplicitTypeApplication - thanks!
23:36:58 <ryantrinkle> spindas: no problem :)
23:42:53 <roelof> maybe a stupid question : I have this [ ( xxx, xxx) ]  what is the type [ yy] ? 
23:43:34 <Clint> [(xxx, xxx)] ?
23:44:42 <adam__> can you elaborate a little?
23:45:11 <adam__> since we dont know the type of x and how x and y are related that is an unanswerable question
23:45:53 <adam__> if you are asking about the general types you could say that [(x,x)] is a list of tuples of type x
23:46:10 <adam__> while [y] is just a list of type y
23:47:22 <roelof> oke, I tried this [Tuple]  but that one does not work 
23:47:36 <roelof> I think I have to make 2 seperate types for printing 
23:48:09 <kadoban> roelof: Tuple isn't the type of a tuple. An example tuple type would be:  :: (Int, String)
23:48:19 <arkeet> what are you trying to do? where are you putting that? is it literally "[Tuple]"? what do you expect it to do, and what is it actually doing? what does any of it have to do with printing?
23:48:30 <kadoban> :t ("Hi", "There")
23:48:31 <lambdabot> ([Char], [Char])
23:50:14 <roelof> I try to print something in a tabular form 
23:50:18 <roelof> thanks all
23:51:47 <jgoux> luigy: Hi, I tried to add the path to the missing library in my LD_LIBRARY_PATH variable, but I'm still unable to use ghci (for my stack related issue)
23:52:42 <jgoux> luigy: related to this : https://github.com/commercialhaskell/stack/issues/1656
