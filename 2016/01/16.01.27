00:03:20 <coconut> when a data is of MonadIO class, what does it mean in english ?
00:03:43 <srhb> coconut: It means that it implements the methods in the MonadIO type class
00:04:17 <coconut> yes and? i know when a data is of Monoid type, it behaves like a list
00:04:22 <kadoban> coconut: It means you can do arbitrary IO in that Monad.
00:04:30 <EvanR> :t liftIO
00:04:31 <lambdabot> MonadIO m => IO a -> m a
00:04:39 <srhb> coconut: That's not true for all monoids.
00:05:08 <coconut> vaguely speaking, isn't monoid an abstraction of list like things ?
00:05:24 <coconut> anyway that's another question
00:05:39 <EvanR> (also, it's not exactly guaranteed that a MonadIO liftIO will actually let you *do* IO in that monad)
00:05:54 <EvanR> (unless you can come up with some laws regarding what it means to do IO)
00:06:12 <coconut> Im learning Shelly, and in a Sh Monad, i can not do IO
00:06:27 <coconut> and Sh Monad is a MonadIO
00:06:31 <EvanR> that seems odd, are you sure
00:06:34 <kadoban> EvanR: Ah, right, interesting point.
00:06:37 <EvanR> try liftIO
00:06:38 <srhb> coconut: Just use liftIO
00:06:53 <coconut> ok
00:06:54 <liste> try "liftIO $ putStrLn "hello world"
00:07:32 <srhb> coconut: And wrt. monoids: They are quite simple. You need a binary, associative operation and an identity element for it. 
00:07:35 <kadoban> New law: liftIO $ fireTheMissiles -- must fire the missiles!
00:07:42 * hackagebot ChannelT 0.0.0.1 - Generalized stream processors  https://hackage.haskell.org/package/ChannelT-0.0.0.1 (pthariensflame)
00:07:42 * hackagebot ChannelT 0.0.0.2 - Generalized stream processors  https://hackage.haskell.org/package/ChannelT-0.0.0.2 (pthariensflame)
00:08:18 <EvanR> coconut: a classic monoid you might see in class would be... the integers with the operation + and the mempty = 0
00:08:37 <coconut> its algebra...
00:08:44 <EvanR> just saying its not "like a list"
00:08:45 <ReinH> There are plenty of monoids that are not really very much like a list
00:08:46 <srhb> Or * with 1
00:08:58 <ReinH> rotations of a rubix cube form a monoid
00:09:00 <kadoban> monoid is from algebra, yeah.
00:09:05 <srhb> ReinH: Haha, how?
00:09:28 <EvanR> rubix cube moves are actually not only a monoid, but a group. the rubik's cube group
00:09:37 <ReinH> As the monoid part of the Rubik's Cube group https://en.wikipedia.org/wiki/Rubik%27s_Cube_group
00:09:43 <ReinH> groups are also monoids
00:09:44 <srhb> Ah!
00:09:53 <srhb> Thanks :-)
00:09:53 <ReinH> they are just monoids with some more stuff
00:10:02 <ReinH> oh
00:10:05 <coconut> what is the operator for the rubix cube ?
00:10:08 <ReinH> I read "not" but you said "not only"
00:10:11 <ReinH> EvanR: sorry
00:10:11 <srhb> Yes, I know what groups are, I had never heard of this one.
00:10:15 <EvanR> coconut: do one move, then the other
00:11:01 <EvanR> in that order ;)
00:13:19 <EvanR> still trying to figure out what comonoids are
00:13:44 <ReinH> comonoid is a -> (a,a) and a -> ()
00:13:49 <ReinH> pretty boring in Haskell
00:13:51 <ReinH> useful in other places
00:13:53 <ReinH> e.g., linear algebra
00:14:06 <EvanR> a -> () ...
00:14:09 <EvanR> exciting
00:14:11 <liste> EvanR https://stackoverflow.com/questions/23855070/what-does-a-nontrivial-comonoid-look-like this helped me a lot
00:14:15 <liste> to understand
00:14:19 <ReinH> yes, the dual of mempty :: () -> a
00:14:39 <liste> isn't that quite useful with linear types?
00:14:43 <EvanR> i know () -> a is sometimes called a "point" 
00:14:44 <ReinH> EvanR: http://graphicallinearalgebra.net
00:14:48 <liste> a resource that can be duplicated and closed
00:14:54 <EvanR> not sure what a -> () is supposed to be
00:15:14 <cocreature> I would call it "eat" :)
00:15:24 <ReinH> mempty produces a distinguished element
00:16:19 <ReinH> comempty eats an element and gives () instead
00:16:42 <coconut> does main has to be IO () ?
00:16:49 <ReinH> coconut: no, it can be IO a for any a
00:16:51 <srhb> coconut: No, it can be IO a
00:17:00 <srhb> That sweet alignment...
00:17:17 <coconut> i mean does it has to be IO something
00:17:20 <ReinH> EvanR: but seriously, check out that link, it shows off monoids and comonoids in the context of a really interesting presentation of the category theory behind linear algebra
00:17:27 <ReinH> coconut: Yes.
00:17:58 <coconut> has to be MonadIO something
00:18:00 <coconut> ?
00:18:41 <kadoban> coconut: IO is a type. MonadIO is a typeclass. It has to be: IO a
00:18:49 <liste> coconut no, main can't be MonadIO m => m a; it has to be IO a
00:19:02 <EvanR> IO is the secret sauce
00:19:16 <ReinH> coconut: no, it has to be IO something.
00:19:17 <kadoban> In reality it should be IO (), since IIRC the 'a' is just ignored and unused, but you technically can have one.
00:19:51 <coconut> thanks
00:19:53 <EvanR> MonadIO monads only can work be secretly using IO which is it secret has internally
00:19:58 <EvanR> s/be/by/
00:20:07 <EvanR> like as part of a transformer
00:20:32 <EvanR> ReinH: i am read the SO link first
00:22:59 <liste> are there any ML/Haskell family languages with linear/uniqueness types ?
00:24:37 <EvanR> idris now has uniqueness types, if thats the same thing
00:24:48 <EvanR> also clean uses them for IO
00:24:58 <EvanR> somehow
00:26:10 <liste> awesome
00:26:40 <EvanR> oh wow graphical linear algebra is a large book
00:27:36 * hackagebot language-thrift 0.7.0.1 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.7.0.1 (abhinav)
00:32:35 <ReinH> EvanR: yeah when I started reading it there were only 7 chapters o_O
00:32:38 <ReinH> EvanR: it's super good though
00:32:53 <ReinH> also I have a lot more to read since I last checked so that's great
00:33:29 <ReinH> liste: Not an ML or Haskell family language, but rust has affine types if you're into that sort of thing
00:33:31 <hath> Quick question by a newbie haskeller. If I've got a type like data Card a b = Card a b , where a and b are two different types how do I create a show instance that works on this type?
00:33:48 <tfilk> what is that channel about ?
00:34:21 <ReinH> tfilk: Haskell is a general purpose, purely functional programming language. www.haskell.org
00:35:10 <ReinH> hath: You can create a show instance for Card as long as both a and b are instances of Show, or you don't use one or both of them in your output.
00:35:13 <EvanR> hath: you could for example use deriving (Show)
00:35:22 <ReinH> e.g. instance (Show a, Show b) => Show Card a b where 
00:35:34 <hath> oh
00:35:35 <ReinH> deriving (Show) will also give you an instance when a and b are instances
00:35:52 <tfilk> that one "purely functional" what it do ?
00:36:06 <ReinH> tfilk: The website has a good explanation
00:36:15 <ReinH> No sense in typing it up again
00:36:32 <hath> I'm trying to customize the output. This bit  instance (Show a, Show b) => is what I was missing. Thanks
00:36:34 <tfilk> you can have bots and do:
00:36:43 <liste> ReinH yeah, cool that it's getting more mainstream traction (: I've looked into Mercury and ATS for that, but feels hard somehow to just start to use one of those 2
00:36:45 <tfilk> !whatishaskell
00:37:22 <ReinH> tfilk: We could. Or we can direct you to the website that answers your question.
00:40:15 <ReinH> As well as a bunch of other questions you don't even know you should ask yet.
00:55:24 <koz_> Is there a way for Cabal to grab the dependencies of *all* the targets in the .cabal file, rather than just the main one?
00:55:40 <koz_> (like, a single command, something like 'cabal install --all-the-fucking-deps-please)
00:59:39 <jdnavarro> koz_: cabal install --only-dependencies
00:59:57 <koz_> jdnavarro: That only gets the main target's deps.
01:00:09 <jdnavarro> --enable-tests --enable-benchmarks is not enough?
01:00:12 <koz_> This one has three - one for the lib, one for unit testing, one for benching.
01:00:28 <koz_> jdnavarro: DIdn't try that. So it should be cabal-install --enable-tests --enable-benchmarks --only-dependencies?
01:00:38 <bernalex> I don't think that will help.
01:00:49 <bernalex> if there are multiple targets that will just enable tests & benchmarks for the main target, I believe.
01:01:03 <koz_> bernalex: It oddly-enough actually did exactly what I wanted.
01:01:10 <bernalex> but cabal doesn't have a man file so I can't be bothered checking.
01:01:11 <koz_> So thanks jdnavarro! :)
01:01:14 <bernalex> koz_: oh. that's good I guess.
01:01:31 <koz_> bernalex: Yeah, I know. A lack of man page is a severe point against a CLI tool IMHO.
01:01:51 <bernalex> it's weird that --only-dependencies would get the main target, but enabling tests and benchmarks should install all targets. that's... not great.
01:01:53 <jdnavarro> koz_: I think you can set --enable-tests and --enable-benchmarks by default in your cabal config file
01:02:14 <koz_> jdnavarro: It's a fork of an existing project, and I dunno if they use sandboxen or not.
01:02:27 <koz_> I need all the deps because otherwise Flycheck gets confused.
01:03:18 <bernalex> koz_: I tried adding man pages for all the elm tools a couple of years back, but they were really against it. seems like it's a common notion amongst Mac OS X users. I would not be surprised if the main Cabal guys are Mac OS X users.
01:03:32 <koz_> bernalex: Maybe.
01:03:47 <koz_> My main goal is just to figure stuff out, and I'm only into my second *month* of Haskelling.
01:04:08 <jdnavarro> I believe there was a PR for man pages in cabal
01:04:25 <jdnavarro> I don't know if it has been released yet
01:05:01 <jdnavarro> in any case, if I remember correctly, it was a wrapper around the commandline messages
01:05:21 <bernalex> probably help2man or something.
01:06:05 <jdnavarro> sometimes it can be a pain to format man pages properly
01:06:29 <jdnavarro> specially if your source it's free format
01:06:33 <bernalex> I've never had any issues with it.
01:06:57 <koz_> jdnavarro: asciidoc makes it relatively painless in my experience.
01:07:03 <bernalex> some people hate troff, but you can just use a different format and use some 2man-program.
01:07:06 <koz_> Thanks to it, there's basically no reason to hand-roll manpages.
01:08:21 <jdnavarro> well, pandoc, asciidoc, etc are great if you start from a supported format like markdown
01:10:03 <julianleviston> jdnavarro: people *love* markdown, don’t they!
01:10:21 <merijn> I would argue that markdown is bad. Not very composable and ill-specified/standardised
01:10:37 <merijn> reStructuredText is much better in that regard
01:10:47 <merijn> And nearly as readable in plain text form
01:10:48 <jdnavarro> I'm using it all the time these days but I prefered ReST much more
01:11:00 <bernalex> I don't like markdown either
01:11:09 <jdnavarro> all my colleagues hate ReST
01:11:20 <merijn> jdnavarro: Replace your colleagues! ;)
01:11:26 <julianleviston> :)
01:11:27 <jdnavarro> :)
01:11:42 <koz_> jdnavarro and bernalex: ASCIIdoc is very similar to RST. Also, you should *fork* your colleagues.
01:12:15 <jdnavarro> yeah, I also tried to introduce asciidoc with asciidoctor... but no luck
01:12:39 <koz_> jdnavarro: I have great respect for asciidoctor, even if I don't use it myself.
01:12:44 <jdnavarro> it seems like markdown has already won
01:12:47 <koz_> But then again, I don't really write much documentation.
01:17:18 <koz_> Also, I feel like I've achieved something - I've sent in two PRs with non-retarded changes after less than two months Haskelling to a fairly-serious set of projects.
01:17:30 <koz_> This is pretty much more than I've done in ... well, any language I've ever worked in?
01:18:10 <frerich> koz_: This means you're now "made", in the Mafia sense.
01:18:45 <koz_> frerich: Said PRs haven't been merged yet.
01:18:53 <koz_> So I don't think I'm made *just* yet.
01:19:13 <koz_> But frankly, Haskell has an awesome community, so I'm happy to assist it.
01:19:56 <frerich> koz_: I keep tinkering with Haskell on and off for about five years now and I sometimes contribute smaller things to other Haskell projects. I noticed that with Haskell, it's actually convenient how a lot of technicalities are caught by the compiler and the reviews for PRs are very short and/or rather about design considerations.
01:20:18 <frerich> koz_: With other languages, it often turned out that "Oh but if a is false and b is greater than 17 then x is undefined, so better check for that!"
01:21:26 <koz_> frerich: Yeah, that's definitely true. I also happen to like how Haskell's worldview aligns with my own.
01:21:38 <koz_> I.e. we define the world through types, and then define their protocols.
01:21:48 <koz_> That just ... somehow appeals to my inner perfectionist.
01:21:51 <frerich> koz_: You're clearly more disciplined than I am. :-)
01:21:59 <jdnavarro> I don't know where I read that the Haskell community has a very low ratio of core authors to contributors compared to other languages
01:21:59 <koz_> frerich: PhD student in machine learning here. :P
01:22:09 <koz_> (with interest in logic)
01:22:29 <frerich> koz_: However, it's certainly true that because of types, I often find myself tinkering and hacking code bases without actually knowing what I'm doing. And it turns out that the patches are even correct!
01:22:35 <merijn> koz_: I know the feeling, I feel it's much easier to contribute to complex Haskell projects than comparably simpler projects in other languages
01:23:04 <koz_> merijn and frerich: Yeah - the self-documenting nature of Haskell types is remarkably surprising.
01:23:09 <merijn> Because it's easier to track what's going on and what's being affected where. As opposed to hunting to where in the code some knob is twiddled
01:23:21 <frerich> koz_: I often don't even need to bother seeing the 'big picture', I always use veryl ocal reasoning like "Ok, I have this String and a Frobnicate a, so how do I get from a to b...".
01:23:21 <koz_> merijn: I think immutability helps there.
01:23:38 <koz_> frerich: When tinkering with other peoples' code, that's a *good* thing.
01:23:47 <koz_> I mean it more in the sense of writing your own.
01:24:01 <merijn> Last time I encountered a bug in a python project I knew exactly what the bug was from the stacktrace, but couldn't find out where the broken code was actually being called. Patching some minor things in GHC was comparatively simple :p
01:24:29 <bernalex> haskell code is just insanely compartmentalised when compared to python
01:24:35 <koz_> I guess Guido's keeping TCO out of Python for better stacktraces has *some* meaning, lol.
01:24:48 <koz_> I dunno - for some reason, Python code always made me wanna take a shower afterwards. :P
01:25:33 <koz_> Like, nothing personal against the language or any of its fans, but *I* just found it strangely dirty whenever I made any effort to learn it.
01:26:01 <bernalex> I don't have much hope in a language whose BDFL thinks function composition is confusing.
01:28:06 <koz_> bernalex: Srsly?
01:28:10 <koz_> Like, *seriously*?
01:29:35 <bernalex> koz_: https://mail.python.org/pipermail/python-ideas/2015-May/033491.html
01:31:28 <koz_> bernalex: OK, well, now I have a much more concrete reason to dislike Python. :P
01:31:31 <koz_> I appreciate that.
01:31:38 <koz_> But yeah, functional composition isn't confusing at all.
01:31:44 <koz_> I have no clue what Guido is smoking.
01:33:08 <frerich> He does a *much* better job at designing a language, maintaining its primaryi mplementation and running the whole community than I could have ever done. So I suppose he made very conscious design decisions.
01:33:15 <bernalex> in general, I find that my IQ is quite a lot lower than it needs to be in order to even hope to reason about an endless cyclic dependency graph of side-effects.
01:33:18 <merijn> I can clearly tell none of you guys have TAed a functional language class :p
01:33:33 <merijn> frerich: Lol
01:34:09 <koz_> merijn: I've not had that privilege, no. I've TAed AI and basic discrete maths.
01:34:21 <koz_> (well, and this one class on assembly programming once)
01:34:23 <merijn> frerich: Guido, like Larry Wall and many "scripting languages turned popular" people suffers from the sad fact that they didn't read up on and become good at language design until AFTER their language became popular
01:34:25 <koz_> (that was *not* fun).
01:34:37 <bernalex> mgsloan: I know someone who's TA-ed a introduction to programming class that used haskell rather than java or whatever. they weren't confused as far as I heard. so the problem often lies there. "this isn't what my limited worldview defines programming to be" and "ouch my brain hurts".
01:34:43 <merijn> koz_: People struggle like hell with recursion and function composition (granted, they've been damaged by Java before)
01:34:53 <koz_> merijn: True dat.
01:35:06 <bernalex> mgsloan: uh that was for merijn, sorry
01:35:16 <koz_> Well, I learned Java first. Damn uni. My *second* language was Common Lisp.
01:35:19 <koz_> My *third* was Clojure.
01:35:24 <tsahyt> bernalex: I always though that learning Haskell (or any FP language) as a first language would be much easier than after you've already had experience with imperative programming
01:35:25 <koz_> I hit the functional wall pretty damn fast and hard.
01:35:54 <merijn> frerich: Although, at least in the defence of Guido and Larry they read up on stuff after becoming popular. Unlike Rob Pike & co who, after C became popular, decided they didn't need to read anything and came up with that Go atrocity
01:36:21 <koz_> merijn: From what I could tell, Go is basically 'C done right according to Pike, with awful package management because he never cared about it'.
01:36:22 <merijn> But I should keep my Go trolling to -blah :p
01:37:05 <bernalex> tsahyt: yes and no. there are trade-offs. if you know programming well, haskell might make your head hurt more than if you did not know other languages. but knowing programming means that you know the shell, version control, text editors, and a bunch of things that people who don't know programming will struggle with. struggling with basic computer knowledge will naturally impede your haskell progress.
01:37:07 <merijn> koz_: I can give you a long list of why "Go is C done terribly", including "even C's predecessors were better than Go"
01:37:25 <koz_> merijn: Oooh, I love a good ragey-rant! Do you have it in blog form?
01:37:31 <koz_> (I'm not being sarcastic there)
01:37:37 <koz_> (like, 100% sincere)
01:37:41 <bernalex> everybody hates go, so there should be lots of blogs to choose from.
01:37:41 <merijn> koz_: http://cowlark.com/2009-11-15-go/
01:37:52 <koz_> merijn: I think I love you. :)
01:37:55 <merijn> That one is pretty good, comparing Go with "Brand X" language
01:38:03 <merijn> bonus points if you know what Brand X is before the end
01:38:04 <bernalex> merijn: larry wall infamously once said that perl is an ugly and tedious language because its userbase demanded an ugly and tedious language, not because of his design shortcomings.
01:38:27 <julianleviston> koz_: are you this koz ? koz ruby
01:38:42 <julianleviston> koz_: sorry.. lol http://koziarski.com
01:39:00 <bernalex> anyway I'm off to get an energy drink. I'm super tired and need to make a haskell workshop.
01:39:15 <koz_> julianleviston: Nope, although he's geographically fairly close to me.
01:39:19 <merijn> Oh, and Brand X language is also a good reason for Haskell using /= instead of !=, since Brand X uses /= :p
01:39:32 <julianleviston> koz_: ah ok. same, I suppose (sorta) (au)
01:39:39 <koz_> julianleviston: NZ, thanks very much. :P
01:39:39 <frerich> merijn: I think 'good language design' is not just nice syntax and straightforward semantics. It also takes 'what's convenient' and 'what are my users familiar with' into account. So it may well be a 'dirty' or 'inconsistent' language, but it's still very good at getting things done -- which, IMHO, speaks favorable of 'language design'.
01:39:49 <julianleviston> koz_: no I mean *i* am in au :)
01:39:56 <koz_> Ah, right.
01:39:59 <koz_> Well, I'm in NZ.
01:40:08 <koz_> But it's nice to meet someone who's *vaguely* near my timezone. :P
01:40:52 <frerich> merijn: I don't like e.g. Perl or JavaScript very much for all the odd corners of the language, but I do readily accept that the languages actually work reasonably well for many purposes. I guess the usual suspect in this regard is PHP. :-}
01:41:19 <koz_> frerich: Insofar as PHP goes, I stand by Eevee's assessment.
01:41:26 <koz_> It's pretty darn fun to read and rather apt.
01:42:38 <frerich> Furthermore, I readily acknowledge that all this discussion is rather offtopic here. So I'll shut up. :-]
01:42:56 <koz_> frerich: You can't beat #emacs for off-topicness. :P
02:00:07 <monadc> I am completing the monad challenges and have got to http://mightybyte.github.io/monad-challenges/pages/ex2-4.html where it asks you to implement the queryGreek2 using chain and link and no cases. I have implemented chain and link and the previous queryGreek function http://lpaste.net/150894 . The hint is to use lambdas, could some one please give me an example especially with the divMay function. 
02:01:36 <frerich> monadc: You could write 'a `link` \x -> b x `link` \y -> ...'
02:01:45 <frerich> monadc: I.e. you use 'link' to chain lambda functions.
02:04:29 <dramforever> monadc: can you "match" the body of link with the body of queryGreek?
02:04:29 <dramforever> I mean, like the outmost "case"
02:04:29 <dramforever> hmm...so are you trying to "have it working" or "get it look nice"?
02:05:15 <monadc> dramforever to get it working
02:06:13 <fr33domlover> Anyone has thought on Hakyll VS gitit? Assuming editing is done only using git commits, in which cases would I prefer one over the other?
02:06:24 <monadc> dramforever it is possible to match all the functions except divMay
02:06:24 <fr33domlover> (considering hakyll uses pandoc too)
02:06:38 <monadc> the divMay function takes two a's but I have only two maybe a's , and link and chain take only one maybe -> a is possible to link them together ?
02:07:14 <dramforever> monadc: I don't think there's a problem, can you show us what you've got so far?
02:07:59 <dramforever> I think you might have understood something wrong
02:08:42 <dramforever> it should be like (... `link` (... `link` (... `link ...))), i.e. right associated
02:09:27 <dramforever> monadc: so... do you have some code written so far? it's kinda hard to get things going without knowing some context
02:12:45 * hackagebot elm-init 1.0.2 - Set up basic structure for an elm project  https://hackage.haskell.org/package/elm-init-1.0.2 (justus)
02:18:01 <bernalex> merijn: reading on go now. looks interesting.
02:18:21 <bernalex> merijn: promising that it starts with "it's incoherent, badly argued, and a lot of the details are simply wrong"
02:18:49 <mtesseract> Good morning :)
02:19:49 <bernalex> merijn: I recognise brand x immediately from the code snippet. :p although I'm not sure about the exact version.
02:20:36 <merijn> bernalex: Good on you, I don't think many people do :p
02:21:35 <bernalex> merijn: I have done a fair bit of programming languages research, so I have looked a tiny bit at most historically significant languages, hehe. too bad I had the punchline ruined though!
02:22:40 <bernalex> it would have been fun to see a java to simula comparison. :p
02:33:18 <frerich> merijn: I saw that Go vs. X page a few years ago already, but only now noticed that in the 'Object orientation' part, there's an interface with a method "  fire_icbm_at();". I'm somewhat disappointed that this is not used in the context of talking about side-effects!
02:36:16 <jle`> hm, should i use travis-ci or circle-ci for my continuous integration w/ open source projects?
02:36:28 <jle`> i've used both and i don't really see a major difference
02:36:41 <jle`> only that travis is more popular for some reason in the haskell community?
02:36:54 <jle`> i don't understand if there's a real reason why
02:37:03 <frerich> jle`: I'd use travis-ci purely on the grounds that it seems more popular than anything else, so chances are that other people can help you out with using it. I.e. "Use what your friends use"
02:37:07 <liste> jle` are there more Haskell plugins for either?
02:37:14 <bernalex> jle`: travis is more popular in every community I know of.
02:37:15 <dseitz> I prefer CircleCI
02:37:23 <jle`> well both work with haskell equally well
02:37:34 <jle`> i've used both for different projects and neither have given me any real problems
02:37:41 <jle`> especially now since stack came along
02:37:49 <liste> network effect is strong
02:37:56 <jle`> dseitz: any particular reason?
02:38:08 <frerich> jle`: To bring another system into the mix, I recently started using https://www.appveyor.com/ for a new project.
02:38:10 <jle`> liste: maybe, but CI is somewhere where I don't think network effect has any real impact on quality
02:38:14 <frerich> jle`: I don't know how well it works with Haskell though.
02:38:39 <jle`> circle's web GUI is nicer
02:38:56 <JagaJaga> Guys, can you suggest me any practical tasks (they need to write something using haskell) I can ask my students during exam? :)
02:39:22 <dseitz> I mostly like the response time from CircleCI and configuring it to work with Haskell and integrate my needs was easy. Sometimes it's just about which you pick first.
02:39:37 <jle`> JagaJaga: i'm asking my students to implement typeclass methods for tomorrow's final, like Functor for Maybe
02:39:44 * jle` shrugs
02:39:57 <jle`> i don't really like asking students to write out code by hand for a test
02:40:24 <bernalex> if it's by hand it should always be pseudo code with justifications imo
02:40:46 <JagaJaga> jle`: that's too easy and was already asked :)
02:40:47 <movedx> I'm trying to understand this recursion: "toDigits x = toDigits (x `div` 10) ++ [x `mod` 10]" There's also a "toDigits 0 = []" defined before hand. I understand that when x reaches to 0, I'll get [] and "[] ++ [something]" gives me a list with the first digit in it.
02:40:57 <bernalex> I would even accept "fmap f Nothing = Nothing; fmap f Something = apply f to Something" in that case.
02:41:03 <JagaJaga> they write it using their computers
02:41:07 <movedx> I just don't get how it goes back around and gets the rest of the digits.
02:41:20 <jle`> movedx: try evaluating it by hand
02:41:28 <jle`> toDigits 241 = ??
02:41:44 <jle`> substitute the definition for the function call
02:41:49 <liste> JagaJaga maybe a simple CAS or CSV parser?
02:41:57 <jle`> toDigits 241 = toDigits (241 `div` 10) ++ [241 `mod` 10]
02:42:06 <jle`> expand further until you no longer can
02:42:06 <movedx> jle`: Yeah good idea. I think my problem is I don't know the order of evaluation here: "toDigits (x `div` 10) ++ [x `mod` 10]"
02:42:09 <jle`> or until you get bored
02:42:17 <jle`> movedx: it doesn't matter :D
02:42:24 <jle`> evaluate either first, it's okay
02:42:25 <movedx> jle`: ! :O
02:42:27 <jle`> be bold
02:42:30 <JagaJaga> liste: thank you :)
02:42:32 <dseitz> Just do a full substitution, further expanding it
02:42:41 <movedx> jle`: <strong>movedx</strong>
02:42:49 <dseitz> once you've fully expended it.. you'll be like "Oh"
02:42:51 * hackagebot irc-fun-types 0.1.0.0 - Common types for IRC related packages  https://hackage.haskell.org/package/irc-fun-types-0.1.0.0 (akrasner)
02:42:53 * hackagebot irc-fun-messages 0.3.0.0 - Types and functions for working with the IRC protocol.  https://hackage.haskell.org/package/irc-fun-messages-0.3.0.0 (akrasner)
02:42:54 <jle`> \textbf{movedx}
02:42:55 * hackagebot irc-fun-color 0.2.0.0 - Add color and style decorations to IRC messages.  https://hackage.haskell.org/package/irc-fun-color-0.2.0.0 (akrasner)
02:43:16 <movedx> Ew :(
02:43:17 <jle`> circleci's web GUI is much more pleasing to look at so maybe i'll stick with that
02:43:27 <liste> JagaJaga for example something that solves equations of form "<constant> * x + <constant> = <constant>"
02:43:45 <dseitz> I like it. I am sure there is so much overlap between the two that it's not even really worth worrying about anymore.
02:43:55 <JagaJaga> liste: yeah, I have tasks like that
02:44:03 <dramforever> JagaJaga: Paper or computer?
02:44:09 <dseitz> A few years ago, there were more arguments.
02:44:10 <JagaJaga> Maybe some algorithms that are cool to write using haskell?
02:44:16 <JagaJaga> dramforever: computer
02:44:17 <jle`> quicksort?
02:44:23 <JagaJaga> jle`: TOO easy :D
02:44:33 <bernalex> hm? quicksort is a nightmare in haskell
02:44:33 <dramforever> nice, and sorry, I think I was just too rude...
02:44:38 <JagaJaga> jle`: oh! externall parallel merge sort
02:44:39 <jle`> "quicksort"
02:45:14 <liste> JagaJaga is a Roman numeral <-> base-10 converter too easy?
02:45:40 <JagaJaga> liste: yeah... But I will remember this task too :)
02:45:41 <bernalex> JagaJaga: I'd suggest putting some effort into it and giving them a test suite, and a bunch of functions that are = undefined, and have them fill it in.
02:45:59 <JagaJaga> bernalex: they are doing that right now
02:46:07 <bernalex> JagaJaga: check out e.g. https://github.com/alexander-b/thug-beginners/tree/master/lessonA
02:46:08 <liste> a simple virtual machine + assembler combo was a fun assignment too if there's enough time
02:46:26 <bernalex> liste: there usually never is for exams, heh
02:46:26 <liste> with a given ISA for example
02:46:40 <liste> we had something like that in C language exam
02:46:44 <bernalex> if there is time, just let them write a parser or some other compiler component for some stupid novelty language you give then
02:46:55 <bernalex> *them
02:47:14 <JagaJaga> liste: oh, that's awesome..
02:47:17 <merijn> JagaJaga: Parser combinators
02:47:17 <JagaJaga> bernalex: thank you!
02:47:26 <JagaJaga> too many parses tasks :D
02:47:42 <bernalex> have them write a tokeniser/parser/assembler/code generator/etc for some assembly language. that's always neat.
02:47:51 * hackagebot settings 0.3.0.0 - Runtime-editable program settings.  https://hackage.haskell.org/package/settings-0.3.0.0 (akrasner)
02:47:57 <merijn> Man, I really wish someone would write a matplotlib in haskell
02:48:05 <merijn> Except, you know, better
02:48:09 <JagaJaga> bernalex: goo idea, thank you!
02:48:16 <JagaJaga> s/goo/good
02:48:31 <Radivarig> how can I create Data.Text.Internal.Lazy.Text from String? 
02:48:44 <merijn> Radivarig: Easy, Data.Text.Lazy.pack
02:48:45 <jle`> Radivarig: pack
02:48:49 <merijn> :t Data.Text.Lazy.pack
02:48:50 <lambdabot> String -> Data.Text.Internal.Lazy.Text
02:48:51 <bernalex> JagaJaga: it's neat since you can just make up a pretty arbitrary assembly language with arbitrary binary translations, heh.
02:48:57 <Radivarig> ty!
02:49:04 <jle`> fromString should probably also work
02:49:26 <jle`> if you want a polymorphic version, heh
02:49:53 <jle`> :t fromString `asTypeOf` Data.Text.Lazy.pack
02:49:54 <lambdabot> String -> Data.Text.Internal.Lazy.Text
02:49:57 <movedx> jle`: Yeah I'm struggling with this as to me it would seem 'x' is being exhausted by the time it has been divided down to 0.*; also the first iteration of the function does not result in [] ++ [x % 10], but x ++ [x%10] - surely that's an error?
02:50:13 <dramforever> JagaJaga: what about operations on binary search trees?
02:50:25 <jle`> movedx: not sure how you get x ++ [x % 10]
02:50:32 <jle`> do it by hand, on a piece of paper :)
02:50:51 <jle`> it looks like the next step would be to evaluate toDigits (241 `div` 10)
02:50:55 <JagaJaga> dramforever: too easy, was in home tasks
02:51:03 <jle`> which is toDigits 24
02:51:14 <jle`> (i gave away a step for you)
02:51:31 <movedx> jle`: Well you get the recursion toDigits(x) over and over until you get 0.*, which results in the final recursive call coming back with [].
02:51:44 <Phillema1n> Is there a PDF version of LYAH?
02:51:58 <jle`> movedx: try not to get ahead of yourself
02:52:03 <jle`> what is toDigits 24 ?
02:52:16 <movedx> toDigits 2
02:52:17 <jle`> toDigits 24 = toDigits (24 `div` 10) ++ [24 `mod` 10]
02:52:32 <jle`>  = toDigits 2 ++ [4]
02:52:41 <jle`> and what is toDigits 2 ?
02:52:48 <movedx> toDigits 0
02:52:50 <jle`> no
02:52:51 * hackagebot funbot-ext-events 0.3.0.0 - Interact with FunBot's external events.  https://hackage.haskell.org/package/funbot-ext-events-0.3.0.0 (akrasner)
02:52:53 * hackagebot vcs-web-hook-parse 0.2.0.0 - Parse development platform web hook messages.  https://hackage.haskell.org/package/vcs-web-hook-parse-0.2.0.0 (akrasner)
02:52:54 <jle`> look at the definition
02:53:06 <jle`> toDigits n = toDigits (n `div` 10) ++ [n `mod` 10]
02:53:17 <jle`> toDigits 2 = toDigits (2 `div` 10) ++ [2 `mod` 10]
02:53:25 <jle`> it's *not* toDigits 0
02:53:31 <jle`> do you see why?
02:53:36 <movedx> Right, and then you end up with toDigits 0
02:53:38 <jle`> it's actually toDigits 0 ++ [2]
02:53:48 <jle`> it's not toDigits 0
02:53:51 <jle`> it's toDigits 0 ++ [2]
02:53:56 <movedx> ANd 0 ++ [2] isn;t valid.
02:54:17 <dramforever> but it's toDigits 0 ++ [2]...
02:54:24 <jle`> movedx: why are you talking about 0 ++ [2]
02:54:28 <jle`> it's toDigits 0 ++ [2]
02:54:35 <jle`> next, what's toDigits 0 ?
02:55:04 <jle`> i do suggest you literally write out what each one is, without trying to do shortcuts, heh
02:55:09 <jle`> toDigits 0 ++ [2] is *not* 0 ++ [2]
02:55:21 <jle`> it's the result of `toDigits 0` ++ [2]
02:55:30 <jle`> but the result of toDigits 0 is not 0
02:55:49 <movedx> I'm coming from procedural programming, so I'm trying to get my head around this.
02:55:59 <jle`> think about things as definitions
02:55:59 <dramforever> I wonder if you need this: toDigits 0 ++ [2] = (toDigits 0) ++ 2
02:56:04 <jle`> and substitutions
02:56:08 <dramforever> not toDigits (0 ++ [2])
02:56:22 <jle`> movedx: let's calculate toDigits 24
02:56:37 <jle`> toDigits 24 = (toDigits (24 `div` 10)) ++ [24 `mod` 10]
02:56:39 <jle`> right?
02:56:54 <movedx> Agreed.
02:57:07 <jle`> and that = toDigits 2 ++ [4]
02:57:08 <jle`> right?
02:57:17 <jle`> (toDigits 2) ++ [4]
02:57:28 <movedx> OK.
02:57:33 <jle`> so, what's toDigits 2?
02:57:58 <EvanR> ReinH: I read far enough to see it go from nats to matrices of nats, pretty awesome
02:58:04 <jle`>    toDigits 2 = (toDigits (2 `div` 10)) ++ [2 `mod` 10],      = (toDigits 0) ++ [2]
02:58:04 <movedx> jle`: toDigits 2 = (toDigits (2 `div` 10)) ++ [2 `mod` 10]
02:58:13 <jle`> yes, exactly
02:58:26 <jle`> simplifying it out more, we get toDigits 2 = (toDigits 0) ++ [2]    == [] ++ [2]
02:58:32 <jle`> because toDigits 0 = []
02:58:53 <jle`> so now we know that toDigits 2 = [] ++ [2], so toDigits 2 = [2]
02:59:01 <jle`> let's use that back where we needed it:
02:59:15 <jle`>  toDigits 24 = (toDigits 2) ++ [4], so toDigits 24 = [2] ++ [4], so toDigits 24 = [2,4]
02:59:50 <jle`> and back even furhter, toDigits 241 = (toDigits 24) ++ [1], so toDigits 241 = [2,4] ++ [1], so toDigits 241 = [2,4,1]
02:59:51 <movedx> Right. So the "0 = []" function definition "short circuits" the recursion when we've reached nothing else to divide. I guess I don't get how the list is being built through each cycle.
03:00:20 <jle`> think about it as substituting function calls for definitions
03:00:40 <jle`> wherever you see `toDigits n`, just literally replace it with `toDigits (n `div` 10) ++ [n `mod` 10]`
03:01:25 <jle`> toDigits 24 = toDigits 2 + [4] = (toDigits 0 ++ [2]) ++ [4] = ([] ++ [2]) ++ [4]
03:02:11 <jle`> so, toDigits 24 = ([] ++ [2]) ++ [4]
03:02:34 <movedx> AAAAH see the last example makes more sense to me - I didn't get how the list from the `mod` operation was being carried through.
03:02:52 * hackagebot irc-fun-client 0.5.0.0 - Another library for writing IRC clients.  https://hackage.haskell.org/package/irc-fun-client-0.5.0.0 (akrasner)
03:02:54 * hackagebot irc-fun-bot 0.6.0.0 - Library for writing fun IRC bots.  https://hackage.haskell.org/package/irc-fun-bot-0.6.0.0 (akrasner)
03:03:08 <jle`> movedx: it's like substituting in variables in math :)
03:03:21 <jle`> if you have x + y, and you know that x = (z*2), you can write (x*2) + y
03:03:26 <jle`> er, (z*2) + y
03:03:44 <jle`> it's not like the y disappears, or anything
03:03:50 <bernalex> it's precisely like substituting variables in maths. we call it "equational reasoning".
03:04:30 <movedx> My maths isn't very good at all, but I want to learn Haskell and FP because I see it as a purer way of working that's very concise and fast.
03:04:36 <movedx> So I really appreciate your patience, jle` 
03:04:39 <movedx> Thank you.
03:04:42 <jle`> toDigits 241 = toDigits 24 ++ [1] = (toDigits 2 ++ [4]) ++ [1] = ((toDigits 0 ++ [2]) ++ [4]) ++ [1] = (([] ++ [2]) ++ [4]) ++ [1]
03:05:03 <jle`> try doing some by hand :)  i actually do it sometimes for fun, it's kind of therapeautic
03:05:19 <bernalex> the processes are called beta-reduction (if we have, a = 1; b = 2 + a, we can reduce b to 1 and have b = 2 + 1 be equivalent to b = 2 + a), and beta-abstraction (going the other way. if you have a = 1 + 2, we can say b = 2 and do a = 1 + b, and have it be the same as a = 1 + 2)
03:05:43 <jle`> movedx: np!
03:06:03 <movedx> So we're building a list of the remainders as we go along and eventually hitting 0 = [], finalising the list.
03:06:15 <bernalex> jle`: a big portion of haskellers basically do this all the time in their heads. programming on the bus and queuing at airport security etc. equational reasoning is the big winnage in haskell imo. :]
03:06:31 <jle`> movedx: i'd think about it as defining a list
03:06:50 <jle`> movedx: another fun exercise you can do is figure out what head (toDigits 24) is
03:06:52 <jle`> @src head
03:06:52 <lambdabot> head (x:_) = x
03:06:52 <lambdabot> head []    = undefined
03:06:55 <jle`> @src (++)
03:06:55 <lambdabot> []     ++ ys = ys
03:06:55 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
03:06:55 <lambdabot> -- OR
03:06:55 <lambdabot> xs ++ ys = foldr (:) ys xs
03:07:17 <jle`> so, toDigits 24 = ([] ++ [2]) ++ [1], we know.  but what is head (([] ++ [2]) ++ [1]) ?
03:07:39 <jle`> head expects something in the form (x:xs), so we have to apply (++) until we get something in that form
03:07:52 * hackagebot funbot 0.5 - IRC bot for fun, learning, creativity and collaboration.  https://hackage.haskell.org/package/funbot-0.5 (akrasner)
03:07:56 <jle`> applying the inside (++), we see that [] ++ ys = ys, so [] ++ [2] = [2]
03:08:14 <jle`> so head (([] ++ [2]) ++ [1]) = head ([2] ++ [1])
03:08:35 <movedx> head (([] ++ [2]) ++ [1]) = head ([2] ++ [1]) = head [2,1] = [2]
03:09:05 <jle`> yeah; well, you sort of skipped a step, kinda
03:09:25 <movedx> Oh?
03:09:31 <jle`> to evaluate [2] ++ [1], we look at the definition of (++)
03:09:43 <jle`> and see it matches this pattern: (x:xs) ++ ys = x : (xs ++ ys)
03:09:54 <jle`> so, (2:[]) ++ [1] = 2:([] ++ [1])
03:10:03 <jle`>    = 2:[1]
03:10:09 <jle`> and head (2 : [1]) = 2
03:10:20 <jle`>  (because head (x:_) = x)
03:10:39 <jle`> oh, i'm assuming that you know how pattern matching works, and how lists are constructed with :
03:10:48 <movedx> I've not got that far in the list stuff yet, but I have seen (x:xs) before in the Haskell course I am going through.
03:11:07 <bernalex> @src (:)
03:11:07 <lambdabot> Source not found. Wrong!  You cheating scum!
03:11:10 <movedx> I do sort of, yeah. Pattern matching is very powerful. I'm very much looking forward to mastering that.
03:11:14 <movedx> lol
03:11:25 <movedx> @src (x:xs)
03:11:25 <lambdabot> Source not found. My brain just exploded
03:11:31 <movedx> :(
03:11:38 <jle`> movedx: mhm.  so you want to evaluate (2:[]) ++ (1:[]), and you look at which pattern it matches ... and you see what it matches the second pattern, (x:xs) ++ ys = x : (xs ++ ys)
03:11:57 <quchen> ([] ++ [1]) won't be evaluated when running `head ([2] ++ [1])`.
03:11:57 <akegalj> hey. I am looking at the wreq documentation and I don't understand why there is `get :: IO (Response a)` and docs say that it can throw HttpException, and later I see `asJSON :: (MonadThrow m) => ... -> m (Response a)`. Why isn't `get` also made an instance of MonadThrow ?
03:11:59 <jle`> so, "plugging in" the values, we see (2:[]) ++ [1] = 2 : ([] ++ [1])
03:12:03 <liste> isn't it something like "data [a] = [] | a : [a]" ?
03:12:16 <bernalex> @src []
03:12:17 <lambdabot> data [] a = [] | a : [a]
03:12:35 <jle`> movedx: and then we can see, head (2 : ([] ++ [1])) = 2
03:12:40 <jle`> because head (x:_) = x
03:13:24 <movedx> This will take time :)
03:13:39 <jle`> yeah, np; eventually you'll get more into pattern matching and how lists are constructed
03:13:44 <jle`> so don't worry about it for now :)
03:14:00 <movedx> My poor little uneducated mind will take time to understand the syntax and the concepts being applied here.
03:14:02 <jle`> but it's kind of neat that all evaluation in haskell is just basically like substituting definitions in for function calls
03:14:35 <jle`> (the main 'new' concept here is that [1,2,3] is actually just syntactic sugar for 1:(2:(3:[])), which is why i wrote [2] as (2:[]))
03:15:33 <movedx> Thanks again :)
03:15:55 <quchen> movedx: It's a good exercise to implement basic functions from Prelude and Data.List yourself from scratch (not all of them, some are quite complicated).
03:16:14 <bernalex> maybe OldList nowadays
03:16:38 <quchen> movedx: For example, define your own list data type `data List a = Nil | Cons a (List a)`, and write `map`, `filter`, `head`, `listToMaybe` for it.
03:16:55 <quchen> takeWhile, dropWhile, take, drop
03:17:01 <quchen> span
03:17:16 <quchen> And when you have that have a go at `group`, which is a bit tougher
03:17:28 <quchen> bernalex: Right
03:17:58 <movedx> For now I'm going to sleep, but, I will get around to that eventually.
03:18:10 <movedx> For now I have to stick with Go for the day job.
03:18:59 <bernalex> hopefully you'll get some keen insights from haskell, and end up rewriting your company's codebase in haskell while everyone else is on holiday. hyPiRion did, so you can do it too. :]
03:19:18 <movedx> Oh I just use whatever language I like.
03:20:27 <movedx> I want to learn FP and how to think in an FP way. Maybe... and don't set my hair on fire here... but maybe Haskell isn't the right language?
03:20:39 <movedx> Maybe it's the syntax I can't get on with? Or is it the concepts?
03:21:09 <bernalex> haskell would be my recommendation for learning FP. by some margin.
03:21:34 <liste> Haskell certainly makes you think in a FP way
03:21:42 <bernalex> haskell is a very pure and elegant language in terms of FP (unlike languages touted as "multi-paradigm"), and at the same time it is quite popular with lots of libraries.
03:22:53 <movedx> Haskell it is then \o/
03:23:10 <bernalex> movedx: just don't expect to grok it instantly. it takes some time to get used to something such an intrinsically different way of thinking. especially when you *know* how to accomplish a task with a different line of reasoning. it can be quite frustrating. "why can't I just X? in language Y it's so easy for me to X!" happens to all of us when learning haskell after being comfortable imperative programmers.
03:23:25 <bernalex> s/something//
03:23:45 <quchen> The transformative power of it is quite nice to watch. My colleague started using it regularly one year ago, and there are no discussions about whether we should or should not have state when we don't strictly need it. :-D
03:24:20 <liste> movedx: a case example: I tried to implement something akin to SQL "GROUP BY" with Java Streams and found myself pulling hairs out
03:24:30 <liste> and then doing it imperatively
03:24:33 <movedx> That's another interesting idea too: the whole state argument and design. Very clean and safe.
03:24:37 <liste> in Haskell it's trivial
03:25:13 <snhmib> haskell make the hard stuff easy and the easy stuff hard :S
03:25:44 <movedx> bernalex: I'll take it easy and stick with LYAH. I like it's format. I will then move to the CIS 194 lectures and do the exercises and home work.
03:26:34 <frerich> quchen: I observed the same in our team. In fact, recently (during a code review of some Java program), somebody argued in favor of returning early instead of maintaining a 'ret' variable and returning that at the end based on the ground that 'ret adds to the state of the function, state which can be potentially wrong'. :-)
03:26:34 <bernalex> movedx: CIS is great, but I learned primarily through LYAH and hacking on my own pet projects (gradually undertaking bigger and bigger projects), and I know haskell quite a bit now. good luck!
03:26:53 <movedx> bernalex: Thanks a lot mate.
03:27:23 <movedx> jle`: Thanks very much. I'll probably be bothering you a lot, but I'll pay it back in kind or with money when I become a billionaire. 
03:27:43 <jle`> haha. just a small mansion is adequate :)
03:27:50 <bernalex> "quite a bit" = used it in industry for a few years and am comfortable with building stuff at least.
03:28:05 <bernalex> can I have enough money for rent? that's all I need. no mansion necessary.
03:28:32 <movedx> bernalex: :(
03:28:58 <movedx> bernalex: Are you being serious?
03:29:27 <bernalex> movedx: I just meant that I only need enough money for rent and a tiny bit for treats (such as food and the occasional computer upgrade) to be happy. I don't like money. :]
03:29:30 <movedx> I'm hoping I can learn Haskell well enough to write REST APIs and CLI tools in it.
03:29:55 <bernalex> although, incidentally, I am at the moment flat broke and can only barely pay this month's rent, and have no clue what I'm going to do next month. :p
03:30:23 <ner0x652> Hi!
03:30:36 <movedx> bernalex: Oh right. It's nice to meet another minimalist who holds intrinsic values above extrinsic. 
03:31:13 <movedx> bernalex: Where do you live?
03:31:16 <movedx> If I can ask.
03:31:19 <bernalex> movedx: np -- Norway.
03:31:22 <liste> hi ner0x652 
03:31:30 <bernalex> ner0x652: hallo!
03:31:39 <movedx> bernalex: Damn. If you were in the UK or Australia, I could, and would, help you out.
03:31:39 <ner0x652> Is somebody involved in an information security open source project developed in Haskell? If yes, what are they? Do you know about some?
03:32:00 <bernalex> movedx: if you know of anyone who'd like to hire someone to do free software as a remote gig, let me know. :]
03:32:16 <bernalex> ner0x652: I'm not involved, but there are several. tor was recently implemented in haskell.
03:32:30 <bernalex> ner0x652: by the very reputable galois -- https://github.com/GaloisInc/haskell-tor
03:32:45 <movedx> bernalex: I'll keep my eyes and ears open. Have you tried oDesk, eLancer, rent-a-coder, etc?
03:33:00 <bernalex> ner0x652: and there are several other things. check out hackage and the crypto/security packages.
03:33:21 <bernalex> ner0x652: also, sel4 is an OS with emphasis on security which is written in c and haskell: https://sel4.systems/
03:33:33 <ner0x652> bernalex: Thank you very much :)
03:34:10 <bernalex> movedx: idk what those are, actually. well, I can guess what they are, but I don't *know* them.
03:34:15 <jle`> movedx: here's a great library for cli tools/shell scripts in haskell, btw https://hackage.haskell.org/package/turtle
03:34:30 <jle`> movedx: very well-documented with lots of tutorials
03:34:38 <jle`> i'd say that nice shell scripts/cli tools are haskell's killer app
03:34:40 <movedx> bernalex: Gove them a go - it takes time to get a profile setup and verified, etc, but it's possible you'll find some work.
03:34:43 <jle`> but i say that about everything
03:34:53 <bernalex> movedx: jle`: incidentally a great idea for learning haskell (IMO and IME) is to implement coreutils type programs without any libraries at all.
03:34:56 <jle`> "x is haskell's killer app" is something i say every day about something different, heh
03:35:16 <movedx> jle`: haha
03:35:25 <bernalex> I actually started doing it but then got sidetracked: https://github.com/alexander-b/coreutilhs -- they were meant to be self-contained tiny examples
03:35:26 <movedx> bernalex: I was thinking the classic: an IRC bot.
03:35:31 <bernalex> patches welcome!
03:35:38 <bernalex> movedx: done that too. good idea. :]
03:35:41 <jle`> i have an irc bot tutorial myself, incidentally; everyone loves irc bots
03:36:47 <jle`> movedx: also http://www.haskellforall.com/2015/10/basic-haskell-examples.html
03:36:47 <bernalex> I never finished mine, and it looks awful because I didn't even polish it. I just pushed it up, and hoped I would be too ashamed of the src to not finish it
03:36:54 <bernalex> https://github.com/alexander-b/y0l0bot
03:37:14 <bernalex> movedx: I'll keep it in mind. thanks for the namedrops!
03:37:16 <quchen> Andres Löh recently said something quite nice in a talk he gave, roughly "Haskell is really good at implementing compilers, and luckily most things *are* compilers."
03:37:26 <quchen> I vote for "compilers" as the killer app :-D
03:37:29 <sbrg> I am literally writint documentation for my haskell irc bot, kind of aimed at beginners. Thinking of using up-for-grabs.net to let beginner haskellers contribute
03:37:31 <jle`> movedx: http://www.haskellforall.com/2015/12/how-to-contribute-to-haskell-ecosystem.html is some fun haskell projects that any haskell early-intermediate can do, and advanced beginners
03:37:37 <jle`> quchen: compilers are the killer app
03:37:50 <jle`> i think that's where i got the "X is the killer app" template/trope from
03:37:52 <sbrg> it's pretty over-engineered but it's fun
03:37:53 * hackagebot pinchot 0.10.0.0 - Build parsers and ASTs for context-free grammars  https://hackage.haskell.org/package/pinchot-0.10.0.0 (OmariNorman)
03:38:00 <quchen> A browser is a compiler for several languages, and compiles them to something a rendering engine can understand.
03:38:02 <bernalex> I like that idea that haskell is like the velvet underground
03:38:17 <bernalex> not a lot of people learn haskell, but every single person who did, made his own programming language & compiler :p
03:38:30 <kosmikus> quchen: yes, using a sufficiently liberal interpretation of the word "compiler".
03:38:32 <quchen> A GUI framework compiles things into a description the window manager understands.
03:38:37 <kosmikus> quchen: a server compiles requests to responses :)
03:39:07 <jle`> compilers are haskell's killer app, but in large part because haskell is great at parsers and representing programs, building programs, ...
03:39:08 <sbrg> C code compiles input to segmentation faults. 
03:39:23 <quchen> kosmikus: Sure, you have to take that definition with a grain of salt, but it's not terribly wrong
03:39:50 <jle`> i am sure that everyone who has learned haskell has aspired to write a programming language/compiler, heh
03:40:16 <quchen> kosmikus: "Compiles to machine opcodes" is a too narrow definition for compilers anyway, but it's what most people (including myself) think what a *compiler* is.
03:40:18 <arw> i've started haskell with some 'write yourself a lisp in 48h' tutorial :)
03:40:58 <bernalex> quchen: hm I am accustomed to a compiler being "a program that translates from a source language to a target language". that's what the dragon book uses, and that's pretty much the canonical compiler literature.
03:41:11 <Lowl3v3l> bernalex, +1
03:41:38 <liste> I never understood why they're called "compilers"
03:41:45 <liste> wouldn't something like "translator" be better?
03:42:20 <quchen> bernalex: That's probably precisely what kosmikus meant with his statement. A language is something that describes a data structure, and data structures are ubiquitous
03:42:38 <quchen> And programs translate data to data, hence compilers compile data to other data.
03:42:48 <arw> liste: the reason is ancient history. compilers used to be tools that just compiled a list of (lower level language) snippets from higher level source code line by line.
03:42:56 <quchen> But yeah, I have a hard time thinking of my IRC client "compiling my input into human responses" too ;-)
03:43:33 <bernalex> liste: to compile means to put together from possibly different sources. compilers usually have linkers and things like that. it doesn't just translate. I guess that's where it comes from.
03:44:15 <bernalex> liste: it also transforms it in many other ways than translation. many areas of typechecking or inlining or whatever isn't really "translation" unless you dilute it a whole lot.
03:44:40 <bernalex> "transformer" might be adequate... but that doesn't convey that there might be different sources linked together etc. all in all I think "compiler" is an OK term.
03:44:56 <movedx> bernalex: What's rent like in Norway? I've heard it's expansive?
03:44:59 <movedx> expensive too.
03:45:10 <quchen> kosmikus: Didn't mean to misquote you, sorry if that was the case :)
03:45:17 <bernalex> movedx: it's not especially expensive with a Norwegian income. without any income, however, it's rather expensive. :p
03:45:52 <merijn> Everything in Norway is expensive >.>
03:45:55 <merijn> Especially booze
03:46:03 <bernalex> Norway is pretty cheap on everything
03:46:04 <movedx> Yeah you say that, merijn 
03:46:16 <movedx> But the wages will match the standard of living.
03:46:23 <movedx> At least in our industry.
03:46:28 <bernalex> foreigners tend to go "omg norway's so expensive i only make such and such moneys"
03:46:39 <arw> bernalex: in natural language translation, one needs to know a bit more about the meaning and circumstances. so "having a good look at things" like type-checking would still be translation imho
03:47:07 <bernalex> I've heard Australians that weren't even able to understand currency conversion, so they thought everything was insanely expensive.
03:47:25 <bernalex> then again, they also didn't understand time zones or reversed climates on the opposite hemishpere so.
03:47:36 <movedx> Ha!
03:48:01 <movedx> My Australian fiancè does indeed struggle with timezones :P
03:48:02 <bernalex> movedx: programmers actually make very little in Norway compared to e.g. the US & Australia where they're massively overpaid IMO. in Norway it's well paid, but not ridiculously so.
03:48:13 <t0by> what do you expect, they go around walking upside down
03:48:37 <quchen> Right, we ought to walk diagonally up, like Europeans!
03:48:43 <bernalex> movedx: my cohabitant lived in Australia for 9 years, so she's practically half-aussie by now, so that's something we kind of almost have in common I guess. :p
03:48:44 <movedx> bernalex: Oh yeah? Well I won't tell you what I was earning in the UK then :P
03:49:51 <bernalex> movedx: I've heard Americans cite the lowest wages they're willing to work for, and they might be three or four times more than a well-paying Norwegian programmer's job, which is ridiculous. that's not even adjusted to how comparatively "cheap" it is to live across the pond.
03:50:12 <bernalex> in any event, my income was perfectly adequate, back when I had such things. :p
03:50:52 <sbrg> bernalex: how much do they make in norway? And by "programmers", do you mean programmers with a CS degree?
03:51:06 <movedx> bernalex: I get what you mean. I was earning 2.5x what I am now back in the UK, but the standard of living here smashes England to bits.
03:51:34 <movedx> Rent is cheaper compared to the UK, considering what you get; food is cheaper; etc.
03:51:39 <bernalex> sbrg: master's level programmer with a couple of years of industry experience would make €50-55K a year.
03:52:00 <movedx> Wow. I can see why people would say that's low.
03:52:32 <bernalex> I had about 45K, which is certainly not too shabby. and more than enough to live in an expensive city and do downpayments and still eat out most days or whatever.
03:52:46 <tzaeru> 'ere in Finland, senior programmers rarely would make much more than 50ke a year, unless they also have leadership positions
03:52:56 <bernalex> but non-startups would be at 50K-ish.
03:53:03 <movedx> :/
03:53:25 <sbrg> bernalex: that sounds rather low, yeah. I live in Denmark and we're pretty much guaranteed somethingl ike ~64k eur right out of school
03:53:37 <bernalex> tzaeru: that's probably comparable to Norway adjusting for your cost of living.
03:53:45 <sbrg> but then again we have the highest taxes in the world or at least very close
03:53:46 <srhb> sbrg: Almost namesake, same country. Weird.
03:53:50 <movedx> I was earning €650/day, which absolutely destroys those wages.
03:53:51 <tzaeru> I've 5 years of industry experience and make 35ke a year :P
03:53:55 <sbrg> srhb: lol
03:54:00 <tzaeru> though I work in a startup
03:54:05 <tzaeru> and avoid large companies like the plague they are
03:54:29 <bernalex> tzaeru: wait until you're in my position. then you'll be considering large companies too. :p
03:54:57 <movedx> tzaeru: I'm at a startup now.
03:55:14 <tzaeru> bernalex, if you mean having a wife, kids, dogs, a car and trying to save up for an aparment, no, I wouldn't consider large companies.
03:55:44 <bernalex> tzaeru: I don't have any of that, but I do need to pay rent and eat, and there aren't any other jobs around, heh.
03:55:58 <tzaeru> I can't work anywhere where I don't know everyone and where I can't come and go exactly as I please and be free of reviews and other BS. also, no alcohol in middle of day, no go.
03:56:05 <bernalex> tzaeru: there's a huge company in town that will let me work very flexibly (only be in office for meetings), and let me work with only free software, so that's neat.
03:56:13 <tzaeru> hm
03:56:16 <tzaeru> well
03:56:22 <tzaeru> that might be almost on the table for consideration ;)
03:56:33 <bernalex> tzaeru: I can come and go, be free of reviews, and go to the pub whenever at least.
03:56:43 <tzaeru> yeah, that would work for me too :)
03:56:52 <bernalex> honestly I'd love to work for Microsoft Research, if they'd let me work remotely, and only do free software (e.g. GHC).
03:56:53 <tzaeru> unfortunately most well-paying jobs don't have such perks
03:56:58 <tzaeru> so I'll stick to my low-paying job that has them
03:57:14 <bernalex> yeah I'd prefer a low-paying job at a small company if only I could find one
03:57:32 <bernalex> I only have two demands presently: only free software, and work from/in Trondheim. turns out that's quite difficult. :]
03:58:08 <tzaeru> no doubt. there's pretty much just one town here that has a guaranteed software developer vacancies to begin with :S
03:58:15 <tzaeru> which is the capital
03:58:18 <bernalex> so if anyone here wants to get me a job, please do. bonus points if it's in haskell or idris or something. bonus bonus points if it's actually interesting work too. :p
03:59:10 <tzaeru> anyway.. I am decently sure that most Americans, when they cite their salaries, are either exaggerating or happen to be the better paid ones
03:59:45 <bernalex> I don't think so. even average Australians make more money than high-paying Norwegian programmers.
04:00:03 <bernalex> *highly-paid
04:00:10 <tzaeru> some statistics on random websites claim that median programmer salary in USA is 55ke
04:00:21 <EvanR> if you get me a dream job, you win!
04:00:32 <bernalex> yeah that's more than most best paid Norwegians
04:00:33 <tzaeru> and that less than 10% make over 85ke
04:00:36 <bernalex> then adjust for cost of living...
04:00:57 <tzaeru> still, it's much closer to what's paid here than hearing the $100k numbers people throw around often
04:01:09 <bernalex> oh yeah, absolutely
04:01:09 <EvanR> if youre living in SF
04:01:55 <EvanR> thats kind of throwing off the statistics
04:02:30 <tzaeru> that's true
04:03:04 <tzaeru> though in my experience with young americans in general, the culture of uh, exaggeration I guess, is somewhat more normal and expected.
04:03:25 <tzaeru> here it's really looked down to talk about your salary, particularly if it's above median.
04:03:43 <tzaeru> so people rather downplay their salaries than exaggarate them :P
04:03:57 <tzaeru> which is silly, because it lets companies get people cheap when they think they are getting paid the average!
04:04:34 <tzaeru> ... I should be doing my job.
04:04:57 <liste> I wonder if it's a Nordic thing?
04:05:47 <statusfailed> sanity check... I can update multiple record fields like this, right? `someRecord { a = "foo", b = "bar" }`
04:06:00 <hpc> yes
04:06:15 <hpc> might be semicolon instead of comma, but it's pretty much exactly that
04:06:23 <statusfailed> I'm getting a weird type error that gets resolved if I rewrite an expression like that, into one like this: `someRecord { a = "foo" } { b = "bar" }`
04:06:39 <jle`> might be precedence stuff
04:06:42 <statusfailed> i'll gist it, it's confusing the heck out of me
04:06:51 <jle`> try (someRecord {a = "foo" }) { b = "bar" }
04:06:55 <statusfailed> it's to do with type classes I think - the actual types aren't strings
04:07:08 <statusfailed> jle`: that's basically what I've got now, but I was really surprised the original didn't work
04:07:26 <jle`> i guess the association was weird
04:07:43 <EvanR> you can totally update more than 1 field
04:08:18 <merijn> Note that record syntax has precedence 11, higher than function application
04:08:30 <statusfailed> jle`: no I mean the {foo = bar, baz = qux} version didn't work; the one with two {} {} worked fine (even without extra parens)
04:08:52 <cocreature> the high precedence of record syntax confuses me every time I see it
04:08:53 <merijn> statusfailed: Can you lpaste the record's definition?
04:09:04 <statusfailed> doing it :-)
04:09:12 <jle`> foo bar { x = 4 }
04:09:24 <jle`> always confuses me, yeah
04:09:59 <cocreature> I just always use parentheses :)
04:10:01 <bernalex> liste: happens here too. asking someone about their salary is considered incredibly rude. which of course puts all the power in the hands of the already too powerful -- the employers.
04:10:03 <jle`> i actually always put parentheses anyway
04:10:04 <jle`> yeah
04:11:06 <EvanR> may last employment contract actually forbade people from discussing it
04:11:30 <EvanR> which only makes it worse when people do
04:11:36 <statusfailed> merijn: pasted here: http://lpaste.net/151008
04:11:39 <tzaeru> EvanR, where at?
04:11:48 <EvanR> SEO
04:11:58 <tzaeru> meant the country
04:12:03 <EvanR> America
04:12:10 <tzaeru> hmm
04:12:23 <tzaeru> I'm quite unsure if such clauses would be seen as legally binding here
04:12:30 <EvanR> probably not here either
04:12:31 <sbrg> bernalex: In my experience, it is generally considered 'rude' or at least a faux pas to ask someone about their salary, which is why people don't do it. however, I dont' really care, and when I do ask people, they don't really seem to mind either.
04:12:44 <tzaeru> laws regarding reasonable clauses in work contracts are quite extensive.
04:12:54 <sbrg> but his could be biased because I tend to associate with easygoing people or something
04:13:07 <merijn> statusfailed: Funky
04:13:08 <EvanR> it only matters if people complain or they try to enforce the contract
04:13:10 <bernalex> sbrg: yeah my friends and I can talk about salaries/wages fine. academics in general tend to have a different outlook.
04:13:14 <tzaeru> ^ you also get a bias when you associate with close-to-autistic programmers who have no clue about social standards
04:13:29 <statusfailed> merijn: what's weird is, the source of trifecta declares it like that just fine: https://hackage.haskell.org/package/parsers-0.12.3/docs/src/Text-Parser-Token-Style.html#emptyIdents
04:13:29 <EvanR> ridiculous contracts have effect whether or not they are legal and or actually applied
04:13:36 <tzaeru> or, if they do have a clue, they have no acute sense of it.
04:13:41 <merijn> sbrg: Depends on cultural context too
04:13:46 <bernalex> the only people I wouldn't disclose my wages/salaries to are prospective employers, because they usually only want to know them so that they can fuck you over.
04:13:58 <srhb> Maybe we could move the salary talk to -blah or some other place. It's interesting, though.
04:14:45 <JagaJaga> @src deepseq
04:14:46 <lambdabot> Source not found. Do you think like you type?
04:14:50 <bernalex> maybe I should get back to haskell hacking.
04:14:55 <JagaJaga> :t deepseq
04:14:56 <merijn> sbrg: Here it's commonly faux pas to ask how much people earn as having flaunting greater wealth than your social circle is seen as bragging and as such "not done"
04:14:57 <lambdabot> Not in scope: ‘deepseq’
04:15:15 <merijn> sbrg: Asking someone how much they earn might force them in the awkward position of admitting they earn much more than you
04:16:02 <tzaeru> it's kind of interesting that we find it awkward to make more than others, yet majority of people try to get into position where they make more than others.
04:16:06 <sbrg> merijn: true. but that would only really be awkward if they were doing the same job I was. then I might feel cheated. if someone else makes more than me I don't really care, heh.
04:16:24 <sbrg> tzaeru: well, we may find it awkward to admit it to others.
04:16:45 <bernalex> sbrg: merijn: if someone in a similar position makes more money than you, all the more reason to discuss it. the lowest paid person is likely getting fucked somehow.
04:16:55 <tzaeru> yeah, because we think that they'll be jealous or feel bad or think less of us or wouldn't be our friends anymore.
04:17:00 <tzaeru> which is kinda uh
04:17:05 <tzaeru> why are we then trying to get more money?
04:17:09 <sbrg> I personally hate money. I think it's a necessary evil and when I have it, most of my friends benefit from it as well. I just want to make enough to not have to worry about it constantly like i have had to my entire life.
04:17:13 <bernalex> that's the exact reason companies love this stigma. they can keep underpaying people.
04:17:25 <sbrg> bernalex: aye. it should just be open.
04:17:28 <tzaeru> bernalex, yeah, I agree
04:17:34 <sbrg> forcing companies to be open about it means they can't fuck someone over.
04:17:35 <EvanR> theres glass door
04:17:44 <liste> bernalex: at least there's anonymous web services you can post your salary to
04:17:48 <EvanR> "anonymous" salary reporting website
04:18:01 <ironChicken> anyone remember #talkpay?
04:18:02 <tzaeru> I've been thinking that if I get my own company up one day, as I hope i will, I want to have really transparent salary "rules"
04:18:03 <liste> I wouldn't trust their results though
04:18:27 <tzaeru> something like "lowest we ever pay to a full-time employee is 30k, and we will never pay anyone more than 3x than that, including any private stock returns"
04:18:32 <EvanR> tzaeru: heh... are you sure about that? ;) how will you pay someone nothing and someone else a fuck ton
04:18:39 <merijn> Let's move this to -blah
04:18:52 * liste agrees
04:18:55 <tzaeru> EvanR, by not doing either ^^ but yea..
04:18:57 <tzaeru> blah
04:20:39 <aweinstock> :t Control.DeepSeq.deepseq
04:20:42 <lambdabot> Control.DeepSeq.NFData a => a -> b -> b
04:20:46 <aweinstock> JagaJaga: ^
04:20:56 <bernalex> hm. what's the simplest collection type to use when you want it to be indexed by alphabetisation, with dupes being possible?
04:21:15 <monadc> I am completing the monad challenges and have got to http://mightybyte.github.io/monad-challenges/pages/ex2-4.html where it asks you to implement the queryGreek2 using chain and link and no cases. I have implemented chain and link and the previous queryGreek function also my attempts so far at the queryGreek2 function http://lpaste.net/150894 . The hint is to use lambdas, could some one please give a haskell noob some help. 
04:21:35 <bernalex> I guess I could just use a [[Stuff]] and reorder on insertion really. it doesn't matter.
04:21:57 <bernalex> or even [(Stuff, Int)]. meh.
04:22:47 <quchen> monadc: Does it compile?
04:23:12 <monadc> not the queryGreek2 function
04:23:29 <quchen> What's the error?
04:23:55 <monadc> wrong return type so far
04:24:22 <quchen> monadc: For what it's worth, you can write `link foo (\bar -> f bar)` instead of `link foo f`. You can then reindent the code for easier readability.
04:27:06 <monadc> how do nest functions so that two surrounding functions get the same return value i.e. (link 3(link 2(link 1()))
04:28:20 <quchen> Maybe this helps a bit.  link (Just s) (flip lookupMay d)  =  link (Just s) (\x -> lookupMay x d)
04:28:27 <quchen> This reacts to the "Just s" value.
04:29:12 <quchen> You'll get the result "lookupMay x d". You now want to react on that, so you wrap it in another link, like so: `link (Just s) (\x -> link (lookupMay x d) (\y -> ...)`
04:31:39 <bennofs> Hey, can anyone tell me what '*' means in a type heap profile with GHC? I was not able to find any information about it on the web
04:32:17 <monadc> quchen thanks for the help. How do I get one return value to two functions in the chain ?
04:32:25 <bennofs> Oh, I found it: http://stackoverflow.com/questions/24966628/ghc-heap-profiling-with-hy-what-is
04:36:42 <snhmib> is c2hs useful or is it better to stamp out everything by hand? are there other tools?
04:37:00 <snhmib> i just started to learn it and the first thing i learned is it doesn't understand pointers to a struct
04:37:05 <snhmib> which isn't very promising :S
04:38:26 <SX> Is it ok to forkIO thread that can write to Sink (conduit)?
04:38:35 <quchen> monadc: I don't understand the question :-(
04:39:04 <quchen> monadc: You mean "how can I use X in multiple functions"? If yes, then: you can use the "x" from "\x -> ..." anywhere in the "...".
04:39:27 <quchen> So you could write  link foo (\x -> link x (bar x x x))  if you wanted to.
04:39:43 <SX> I'm using runTCPServer from conduit-extra and I need to spawn a worker thread for each request from Client, then send response back.
04:39:55 <monadc> quchen no how can I use the result from that in multiple functions
04:40:33 <srhb> monadc: Many options. let result = expr1 in expr2 result result
04:46:37 <quchen> monadc: The result from what? Could you add braces to the part whose result you want to use multiple times?
04:48:49 <monadc> quchen  (link  3(link 2 ( link 1))) I want to get the result from Link 1 to 2 and 3
04:50:20 <quchen> monadc: let x = link1 in link3 (link2 (x)) -- this is equivalent to your code. You can use "x" anywhere in the "in" part of the code now.
04:51:39 <monadc> quchen and srhb thanks for the help
04:52:39 <quchen> monadc: Maybe this stub helps a bit: http://lpaste.net/151010
04:55:22 <monadc> quchen many thanks for that, I am still not sure how to do the fromIntegral conversions though ? 
04:56:30 <quchen> monadc: Nothing changes about those
04:57:31 <quchen> monadc: Remember, the following are equivalent:   case foo of Just s -> f s, Nothing -> Nothing     and     link foo (\s -> f s)
04:57:49 <quchen> So all those lambdas give you access to whatever is inside the "Just"s.
04:58:19 <quchen> (And when there's nothing in there, the entire thing results in Nothing.)
04:59:36 <monadc> quchen thank you very much you have been a great help
05:00:24 <quchen> monadc: Did you solve it? :-)
05:01:47 <monadc> quchen not yet but as soon as I've had my lunch I'm sure I will, I didn't know you could access the Just value like that )
05:02:19 <quchen> monadc: The entire point of "link" is to simplify the "access the Just value, bail if there's none" :-)
05:13:19 <lisbeth> what is the difference between an expression and a syntactic construct
05:13:40 <anakreonm> I have a data type which is not an instance of Eq. In another module (say A) I define QuickCheck tests for the data type. Is it possible to automatically derive an Eq instance for the data type from module A?
05:13:49 <liste> lisbeth expression is something that can result in a value
05:14:01 <liste> i.e. evaluated
05:14:03 <bergmark> anakreonm: use StandaloneDeriving
05:14:44 <anakreonm> Thank you
05:15:08 <liste> e.g. you can't evaluate "foo x = x", but you can evaluate "foo x" (if foo and x are defined and type check)
05:18:10 <snhmib> question: should hsc2hs consider these 2 the same? http://pastebin.com/MuRTEJsT
05:18:18 <snhmib> because it generates different code for each
05:18:48 <ggVGc> Where's my foo??
05:18:50 <ggVGc> By the bar
05:20:11 <pavonia> liste: Isn't an expression a syntactic construct too?
05:20:20 <liste> yes
05:20:53 <EvanR> a "value" might also just be some expression
05:21:04 <EvanR> one which is fully reduced
05:21:19 <EvanR> but its more complex in haskell
05:23:33 <bernalex> is there an "unlines but no \n after last line"?
05:24:02 <SX> How to correctly use forkIO inside a Conduit?
05:24:42 <ChristianS> bernalex: just strip it afterwards?
05:25:07 <bernalex> ChristianS: yeah I'm just using init atm
05:26:15 <SX> I need to spawn a worker thread, this thread does some stuff and writes to Sink.
05:27:03 <SX> Sink can be invalid by the time this worker tries to write to it
05:27:04 <srhb> bernalex: intercalate?
05:27:06 <srhb> I think.
05:27:29 <srhb> > intercalate '\n' ["foo","bar"]
05:27:31 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Char’
05:27:32 <lambdabot>      In the first argument of ‘intercalate’, namely ‘'\n'’
05:27:32 <lambdabot>      In the expression: intercalate '\n' ["foo", "bar"]
05:27:35 <srhb> Woops
05:27:48 <srhb> > intercalate "\n" ["foo","bar"]
05:27:49 <lambdabot>  "foo\nbar"
05:28:03 <srhb> I guess intersperse will do then
05:28:10 <srhb> > intersperse '\n' ["foo","bar"]
05:28:12 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
05:28:12 <lambdabot>      In the expression: "foo"
05:28:12 <lambdabot>      In the second argument of ‘intersperse’, namely ‘["foo", "bar"]’
05:28:15 <srhb> Or not.
05:28:30 <srhb> Oh, right.
05:28:50 <srhb> Yeah, intercalate makes more sense.
05:39:10 <jhrcek> srhb: unlines might be better function for this purpose
05:39:41 <jhrcek> > unlines ["foo", "bar"]
05:39:43 <lambdabot>  "foo\nbar\n"
05:39:45 <srhb> jhrcek: That seems unlikely :-)
05:40:02 <srhb> jhrcek: (Since the quester was for unlines without the terminating newline)
05:40:05 <srhb> question*
05:40:27 <jhrcek> srhb: ah, didn't see the question
05:41:02 <EvanR> > init "abcd"
05:41:04 <lambdabot>  "abc"
05:41:40 <EvanR> > init ""
05:41:43 <lambdabot>  "*Exception: Prelude.init: empty list
05:43:14 <JagaJaga> :t callCC
05:43:16 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
05:50:00 <bernalex> I never remember this crap in haskell. if I have Foo { bar :: Meh }, and Bar { baz :: Blah }, how do I update the baz with record syntax, given fu :: Foo?
05:50:26 <hodapp> wait, what's Meh?
05:50:40 <bernalex> oh eh bar :: Bar
05:50:49 <bernalex> I need some parens somewhere
05:51:21 <bernalex> it's not just fu { bar { baz = whatever } } at least
05:51:22 <frerich> So you have bar :: Meh and bar :: Bar?
05:51:34 <bernalex> forget about Meh, just :: Bar.
05:51:42 <bernalex> I just don't remember nested updates
05:52:00 <hodapp> hmmmmm
05:52:49 <bernalex> to be specific I have a Room which has neighbours :: Neighbours, and Neighbours have e.g. north :: Maybe Room, and I want to do r { neighbours { north = Just s}}, except, you know, whatever's actual haskell syntax for this crap.
05:53:35 <ClaudiusMaximus> bernalex: i think it might be something like  foo{ bar = (bar foo){ baz = whatever } }  (not sure if () needed)
05:54:36 <bernalex> ah that was it
05:54:42 <bernalex> you need the ()s indeed
05:54:43 <ClaudiusMaximus> hence lens
05:54:48 <bernalex> r { neighbours = (neighbours r) { north = Just s } } lol
05:54:55 <bernalex> yeah can't put in any big dep in this project tho
05:55:03 <bernalex> ta, ClaudiusMaximus !
06:02:28 <JonReed> Let's say I have a constant vector. Ideally, it could already be a vector at compile time. By writing something like `myVector = V.fromList ["value one ", "value two", ...]` am I saying that each time it will start with a list and then convert it to a vector at runtime at least once per each application start?
06:06:33 <EvanR> JonReed: yeah
06:06:49 <EvanR> but unless the list of megabytes long it shouldnt be a big deal
06:06:54 <EvanR> s/of/is/
06:07:42 <JonReed> EvanR: Yeah that's not a big deal. I was just curious whether compiler is smart enough to optimize that.
06:08:26 <EvanR> in general it cant evaluate CAFs at compile time
06:08:45 <EvanR> since it might crash or freeze up, which is only a thing at runtime
06:14:13 <JagaJaga> What are pros and cons of CPS?
06:16:55 <liste> JagaJaga as opposed to what?
06:17:35 <JagaJaga> liste: to regular things I suppose :)
06:26:13 <hodapp> "regular things"?
06:26:42 <EvanR> regular thing form
06:27:02 <hodapp> I was of the view that CPS isn't apart from regular things, it's rather a pattern that comes up all the time and the question is more whether you acknowledge it than whether you use it
06:27:56 <JagaJaga> hodapp: thank you.
06:28:08 <JagaJaga> Can we everything that haskell does using template haskell?
06:32:59 * hackagebot string-typelits 0.1.0.0 - Type-level Chars and Strings, with decidable equality.  https://hackage.haskell.org/package/string-typelits-0.1.0.0 (KyleCarter)
06:38:39 <hodapp> er, sorta? That's kind of a vague question.
06:41:52 <srhb> JagaJaga: What's the purpose of these questions?
07:19:16 <bernalex> does Data.Map.member just use == to figure out if the keys are similar?
07:20:10 <bernalex> so let's say I have a data type with two strings, and define equality to be if the first strings are equal. will Data.Map.member then say that Foo "a" "b" is a member of a map with Foo "a" "c", like I want?
07:21:10 <EvanR> bernalex: i see the code here, and it uses compare on the keys to try to find the thing
07:22:07 <bernalex> also, is there a lookup that returns the key instead of the value?
07:22:24 <EvanR> what is that type of that
07:22:37 <bernalex> k -> M.Map k a -> Maybe k
07:22:43 <bernalex> @hoogle Ord k => k -> M.Map k a -> Maybe k
07:22:46 <lambdabot> Parse error:
07:22:46 <lambdabot>   Ord k => k -> M.Map k a -> Maybe k
07:22:46 <lambdabot>                   ^
07:22:51 <bernalex> @hoogle Ord k => k -> Map k a -> Maybe k
07:22:52 <lambdabot> Data.Map.Lazy lookupIndex :: Ord k => k -> Map k a -> Maybe Int
07:22:52 <lambdabot> Data.Map.Strict lookupIndex :: Ord k => k -> Map k a -> Maybe Int
07:22:53 <lambdabot> Data.Map.Lazy lookup :: Ord k => k -> Map k a -> Maybe a
07:25:44 <bernalex> I guess it's useless since you already have the key, and that this is a silly hack and that I should be ashamed.
07:25:49 <EvanR> bernalex: thats an odd function but you can write it with a small number of combinators if you really need it
07:26:35 <EvanR> though its escaping me how atm
07:26:46 <bernalex> it's OK I'll just do this reasonably instead lol
07:40:58 <eikke> anyone running a PowerPC system?
07:41:46 <AndChat696729> Used to
07:44:53 <t0by> anyone misses running a PowerPC system?
07:45:26 <OverCoder> Is it the case of only Haskell being lazy or it's the case with every functional programming language?
07:47:44 <bernalex> OverCoder: neither. some languages are lazy. some lazy languages are also functional. Haskell is one of them. laziness is extremely desirable for functional programming, but it has its downsides as well. some functional languages think the downsides are too big for their usecase. so some functional languages are not lazy.
07:47:58 <t0by> OverCoder, ML is not
07:48:19 <OverCoder> hmmm, okay, thanks
07:51:20 <Geff22> Hello! A few days ago I was asked to help with falling GLFW-b in GHCi. The problem is that after a couple of dozen successful launches, GHCi begins to fall continuously. At first flag -fno-ghci-sandbox helped me, but then call "GLFW.init" from GHCi become lead to crash. Who can tell what leads to this strange behavior?
07:56:53 <sm> Geff22: if not here, you might try #ghc
07:57:03 <EvanR> Geff22: GLFW-b in ghci is a known problem
07:57:18 <EvanR> im surprised any opengl works
08:20:33 <dustmote> undefined symbols during linking step? anybody had this kind of error? The symbol has the name of a  datatype, typeclass, and typeclass method in it (also random letters)
08:21:31 <tsahyt> dustmote: Did you expose all necessary modules in your cabal file?
08:22:19 <tsahyt> This usually occurs when you build an executable against a library and the module containing that function isn't listed
08:24:49 <geekosaur> right, that often means the module defining that thing was not in either exposed-modules or extra-modules in the library's cabal file, so it didn't make it into the library
08:29:31 <dustmote> ah, i was missing a module 
08:29:36 <dustmote> thanks tsahyt!
08:29:48 <dustmote> needed more `exposed-modules`
08:31:44 <bernalex>  
08:31:46 <bernalex> oops
08:31:51 <emc2> does anyone know of a static integer dictionary implementation, assuming such a thing even exists
08:33:23 <tsahyt> what's a static integer dictionary?
08:34:44 <emc2> Map some subset of a set of integers U to values.  Static means you don't add mappings.
08:35:46 <tsahyt> Would Data.IntMap fit the bill?
08:36:11 <emc2> I want something more efficient
08:36:20 <emc2> But yes, it would
08:36:23 <tsahyt> Efficient in what way?
08:36:38 <tsahyt> or for what operations would be a better question
08:37:24 <tsahyt> If they're contiguous integers, or there is some fast (constant time) bijection between your indices and 0..n, you could wrap that around a vector
08:37:53 <tsahyt> but IntMap's lookup complexity is practically constant time anyway, you'd just be saving some constant
08:38:27 * hackagebot hzulip 1.1.1.3 - A haskell wrapper for the Zulip API.  https://hackage.haskell.org/package/hzulip-1.1.1.3 (yamadapc)
08:38:47 <emc2> The best static integer dictionaries have constant lookup time and space and construction time on the order of sorting the keys.  (They're just arrays with a good hash function).
08:39:24 <ggole> Sorted array + binary search would also be reasonable
08:39:24 <Geff22> Finally! I change order of build-depends (OpenGL and GLFW-b) in cabal file and now it's work! Hopefully it will no longer fall.
08:40:28 <emc2> http://www.itu.dk/~milan/papers/near_optimal_dict.pdf
08:42:25 <tsahyt> emc2: IntMap has O(min(n,W)) lookup complexity, where W is the word size of your architecture. For any reasonably large n that is constant time, and O(n*min(n,W)) construction time, which is on the order of sorting the keys. I don't know about the space complexity though.
08:48:32 <emc2> it looks like IntMap is a tree
08:50:15 <statusfailed> hmmm. How do you extract line and column position from an error in trifecta?
08:53:50 <emc2> Anyway, a cursory search of hackage turns up nothing.  Looks like it's safe to implement the structure in that paper.
08:54:25 <tsahyt> Do you actually need such a structure or did you just want to implement the paper? :)
08:55:04 <tsahyt> I'd love to see how it benchmarks against IntMap though, in my experience those are quite fast
08:56:43 <hiptobecubic> IntMap is very fast.
08:56:48 <hiptobecubic> I'm a big fan of IntMap :)
08:56:55 <Geff22> It seems I was a bit hasty. GHCi fell by calling init when windows defender is switched on.
08:58:17 <emc2> A single lookup into a dense array should win over a tree-based structure.  The only question is the overhead of the hash function
08:58:33 <sm> Geff22: \o/
09:09:06 <lingxia__> hey all
09:09:06 <lingxia__> is anyone around and knows coq?
09:14:32 <dwn> yo
09:14:48 <dwn> so I'm instructed to compute the determinant of a 2x2 matrix
09:14:58 <dwn> but he wants this function signature   det :: (Double,Double) -> (Double,Double) -> Double
09:15:08 <dwn> i think that's just a mistake, right?
09:15:35 <dwn> wouldn't it make way more sense to be det :: (Double,Double) (Double,Double) -> idk wut here -> Double
09:15:47 <dwn> as in, it'd take two tuples
09:16:13 <Nadrieril> that would be ((Double,Double),(Double,Double))
09:16:17 <Nadrieril> but yes
09:16:49 <Nadrieril> det :: ((Double,Double),(Double,Double)) -> Double
09:18:03 <Nadrieril> but by the magic of currification, both functions are equivalent :)
09:22:18 <lingxia__> ;akd
09:22:25 <dwn> thanks Nadrieril 
09:34:41 <Th30n> I have a cabal package which builds both a library and an executable. Is there a way to tell cabal that the executable depends on the library and not list all the library dependencies?
09:35:09 <Th30n> I find it annoying to duplicate the same information which I already have under library deps.
09:36:32 <bergmark> Th30n: give them different hs-source-dirs
09:39:26 <ChristianS> Th30n: and then list the library in the build-depends section of the executable, yes
09:40:19 <Th30n> Thanks, but now I get linker errors :/
09:40:40 <Th30n> related to what I use from my own library
09:41:14 <ChristianS> have you listed all relevant modules as exposed-modules?
09:41:17 <Th30n> Yes
09:41:28 <ChristianS> hmm
09:41:39 <Th30n> I get undefined references, as if the .so doesn't exist or wasn't specified to link with.
09:41:56 <statusfailed> Th30n: do they need to be in the same cabal file? You can do this quite nicely with stack I think, but your "sub-projects" each have their own cabal file
09:43:21 <Th30n> statusfailed: They don't, but I find this more convenient.
09:43:33 <Th30n> Except, obviously for this part I'm asking about xD
09:43:50 <ChristianS> Th30n: also, we do that, so i don't know why it's not working in your case
09:43:59 <Th30n> I guess I'll split 'em into multiple packages. Maybe switch to stack in the process.
09:45:23 <statusfailed> Th30n: this is a nice example of a "big" project: https://github.com/simonmichael/hledger
09:46:09 <statusfailed> ChristianS: Do you have an example cabal file? I think I had issues with this as well actually
09:47:00 <ChristianS> statusfailed: https://github.com/liqd/thentos/blob/master/thentos-core/thentos-core.cabal
09:47:20 <ChristianS> (longish, though)
09:47:59 <statusfailed> bookmarked, thanks :-)
09:50:32 <mjhoy> I have an odd issue (maybe not haskell related) on Linux x86/64: if I break my cabal project into an executable + library (as recommended) I can't build a static binary, the linker fails. However if I just have an executable, it works. Has anyone experienced this?
09:57:05 <Th30n> Hmm, by the looks of it, cabal passes the -rpath for ld which points into .cabal-sandbox/lib etc. where my library should be, but isn't for some reason...
09:57:56 <Th30n> It looks as if building the exe skips the step of copying the built library into 'install' destination.
09:58:13 <Th30n> This also happens when I try to install my lib into sandbox.
09:58:23 <ChristianS> mjhoy: hm, that was discussed just before, Th30n has the same (or a similar) issue.
09:58:33 <mjhoy> my error is something like /lib/gcc/.../crtbeginT.o: could not read symbols: Bad value
09:58:34 <Th30n> as 'cabal install' tries to install the exe right after the lib.
09:59:35 <dwn> so trynna compute 2d polygon area still, not sure what's going on 
09:59:37 <dwn> http://lpaste.net/3396205806893400064
10:00:04 <dwn> i think it should be doing the two dets at the bottom
10:00:05 <dwn> and adding them
10:00:09 <dwn> but that doesn't seem to be true
10:09:49 <dwn> nvm. * 0.5 too much
10:13:35 * hackagebot aeson-extra 0.3.1.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.3.1.0 (phadej)
10:18:35 * hackagebot avers 0.0.14 - empty  https://hackage.haskell.org/package/avers-0.0.14 (wereHamster)
10:18:37 * hackagebot avers-api 0.0.2 - Types describing the core and extended Avers APIs  https://hackage.haskell.org/package/avers-api-0.0.2 (wereHamster)
10:23:44 * hackagebot avers-server 0.0.2 - Server implementation of the Avers API  https://hackage.haskell.org/package/avers-server-0.0.2 (wereHamster)
10:24:18 <pikajude> is there an easy way to define a quickcheck Arbitrary instance for a sum type that's only nullary constructors?
10:24:28 <pikajude> other than elements [minBound..maxBound] which doesn't feel right
10:24:59 <kadoban> pikajude: Why not?
10:25:19 <pikajude> because I don't think a datatype representing ISO currency codes should be Enum and Bounded
10:26:11 <kadoban> pikajude: I dunno, doesn't seem like it'd hurt anything, and it's kinda useful occasionally?
10:26:33 <pikajude> fair enough.
10:27:14 <pikajude> next question: quickcheck seems to be missing a function Arbitrary a => Gen a -> Gen (Maybe a)
10:27:24 <pikajude> am I overlooking it?
10:29:02 <kadoban> pikajude: There's an Arbitrary instance:     Arbitrary a => Arbitrary (Maybe a)
10:29:52 <pikajude> I'm trying to wrap an existing Gen a to replicate the behavior of that instance
10:32:31 <kadoban> pikajude: I might be misunderstanding, apologies if so, but: 'arbitrary :: Gen (Maybe Int)' will work, because Int is an Arbitrary instance, thus so is Maybe Int. For your type too, if you make it an Arbitrary instance, you can do 'arbitrary :: Gen (Maybe MyType)'
10:35:28 <kadoban> :t arbitrary :: Arbitrary a => Gen (Maybe a)
10:35:30 <lambdabot> Arbitrary a => Gen (Maybe a)
10:40:57 <pikajude> kadoban: how do I turn sublistOf [1,2,3] into Gen (Maybe Int)?
10:41:03 <pikajude> other than fmap Just
10:44:06 <kadoban> pikajude: So 'sublistOf [1,2,3]' is going to be :: 'Gen [Int]' I guess there, so what do you want that to do? Like say it was going to generate a [], you want that to be 'pure Nothing', and otherwise you want to take the head of the list I guess and wrap it in Just?
10:44:26 <pikajude> no, I just want to generate either Just a sublist or Nothing
10:44:46 <pikajude> arbM myGen = arbitrary >>= \ x -> case x of { Nothing -> return Nothing; Just () -> Just <$> myGen }
10:45:10 <kadoban> pikajude: Gen (Maybe [Int]) ?
10:45:14 <pikajude> yeah
10:45:40 <kadoban> Ah, hmm.
10:46:19 <monadc> I am trying to complete the monad challenges and I would like some help with the queryGreek2 function http://mightybyte.github.io/monad-challenges/pages/ex2-4.html    . My code so far is http://lpaste.net/150894 including the queryGreek function and the link and chain functions you are limited to using. I am having trouble understanding how to get the Just values to use in divMay 
10:47:55 <kadoban> pikajude: I'm not sure this is a *good* way, but I guess: oneof [pure Nothing, Just <$> sublistOf [1,2,3]]   should work?
10:52:21 <monochrom> monadc: you can convert queryGreek's code into queryGreek2's code mechanically. observe this trend: "case xxx of {Nothing -> Nothing; Just val -> ...val...}" = link xxx (\val -> ...val...).   To see why, expand the definition of link.
10:53:09 <pikajude> here's the best I can do: "liftM2 (liftM2 (\ () -> id)) arbitrary . fmap Just"
10:53:16 <pikajude> that's Gen a -> Gen (Maybe a)
10:54:20 <monadc> monochrom ok thanks I'll give it a go
10:55:34 <lyxia> pikajude: kadoban's looks better.
10:55:41 <pikajude> it certainly does
10:55:45 <Clint> pikajude: suchThatMaybe?
10:55:55 <pikajude> though it actually does something different
10:56:04 <pikajude> I'm pretty sure Arbitrary a => Arbitrary (Maybe a) is like 30% Nothings
10:57:08 <lyxia>  you can adjust the probabilities which frequency
10:57:11 <kadoban> Yeah, mine is going to be like 50% Nothing, which isn't great. You can fix that a bit by using 'frequency' instead of oneof, but … yeah I dunno.
10:57:51 <lyxia> 25% Nothings.   arbitrary = frequency [(1, return Nothing), (3, liftM Just arbitrary)]
10:58:08 <Clint> arbitrary = suchThatMaybe arbitrary =<< arbitrary
10:58:24 <monochrom> I have a cunning plan. you should first use unsafePerformIO to generate a random number between 0 and 1, then use it as the probability of Nothing.
10:58:36 <kadoban> monochrom: XD
10:59:53 <kadoban> I would imagine I'd probably do something like lyxia's or mine if I had to do this in practice, depending on how much you care about the distribution.
11:00:29 <Clint> wait, isn't there already an instance for that?
11:01:48 <ReinH> :t fmap ([1,2,3] <$) (arbitrary :: Gen (Maybe ())) -- pikajude 
11:01:50 <lambdabot> Num t => Gen (Maybe [t])
11:01:55 <kadoban> Clint: If you just want a Gen :: (Maybe [Int]), sure. But the original questioner wants to use sublistOf
11:02:09 <pikajude> ReinH: the list isn't statically known, that's the whole point of Arbitrary
11:02:35 <Clint> kadoban: oh right
11:03:18 <ReinH> pikajude: I thought you were specifing a list [1,2,3] above
11:03:27 <pikajude> right, I call sublistOf on it
11:05:00 <naudiz> hey, I'm trying to get an old yesod app working... unfortunately, the Persist API seems to have changed and I'm getting an error for the automatically generated line "type YesodPersistBackend App = SqlPersistT": Expecting two more arguments to ‘SqlPersistT’ Expected kind ‘*’, but ‘SqlPersistT’ has kind ‘(* -> *) -> * -> *’
11:05:06 <ReinH> sublistOf [1,2,3] >>= \xs -> fmap (xs <$) arbitrary
11:05:18 <naudiz> can someone please help me with that problem?
11:05:44 <pikajude> that's a good idea ReinH 
11:05:46 <pikajude> i'll try that
11:06:13 <dalastboss> i want to sort instances of Enum; but sortBy (comparing toEnum) doesn't have the right type
11:06:14 <lyxia> :t \g -> (arbitrary :: Gen (Maybe ())) >>= mapM (const g)
11:06:16 <lambdabot> Gen b -> Gen (Maybe b)
11:06:16 <ReinH> type inference and defaulting should be enough there, otherwise annotate the type of arbitrary
11:06:35 <pikajude> I have to use fmap (\ () -> Just xs) but otherwise it works
11:06:40 <dalastboss> is there a nice/succinct way to do this?
11:06:59 <monochrom> dalastboss: you need Ord for sorting, or else write your own comparator. Enum doesn't do it for you.
11:07:00 <ReinH> pikajude: that's what <$ does though
11:07:15 <dalastboss> Int implements Ord
11:07:17 <monochrom> oh, you already wrote it
11:07:21 <seagreen> Any idea what library I should use to make a venn diagram? I'm looking at 'chart' and 'diagrams', but don't see anything yet.
11:07:22 <ReinH> :t sortBy
11:07:24 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
11:07:31 <monochrom> @type comparing toEnum
11:07:33 <lambdabot> Int -> Int -> Ordering
11:07:43 <pikajude> ReinH: right, but it's not restricted to f ()
11:07:48 <pikajude> so GHC tells me the type is ambiguous
11:08:01 <monochrom> @type comparing fromEnum
11:08:03 <lambdabot> Enum a => a -> a -> Ordering
11:08:17 <monochrom> toEnum sounds like the wrong direction
11:08:51 <dalastboss> ohh, gotcha
11:09:15 <dalastboss> nice
11:12:27 <ReinH> ,
11:13:08 <lyxia> seagreen: I know diagrams can do the job, though it's kinda heavyweight.
11:13:18 <monochrom> comma is the best delimiter since space :)
11:15:00 <sohum> I'm thinking about boolean blindness and how it interacts with collections
11:15:34 <naudiz> any ideas about my problem?
11:15:35 <seagreen> lyxia: Thanks! Heavyweight doesn't bother me, but I'm going to feel silly spending time getting the circles positioned correctly if someone's already done it.
11:16:59 <sohum> so collection.has(x) suffers from boolean blindness; at the type level you don't have a clue as to whether the collection does or doesn't. but collection.get(x) :: Maybe x gives you an object that acts as a witness for the true case
11:17:20 <ReinH> seagreen: you can use haskell to call out to google's chart API ;)
11:18:38 <seagreen> ReinH: Classic;) Thanks for the suggestion, but I'm too proud for that.
11:19:54 <sohum> what's the equivalent for something like List.indexOf? Maybe 4 doesn't really seem to cut it, because that's not a type-level witness in the sense that if you turn around and do list !! 4, you still get a Maybe back
11:21:37 <monochrom> in "collection.get(x) :: Maybe x", are the two "x"s the same thing? if yes, is x a value? is x a type? if x is a value, what is it doing in a type? does it mean that your "Maybe x" is a dependent type?
11:22:13 <sohum> I'm glossing, apologies. they're meant to be separate namespaces
11:22:50 <monochrom> then "Maybe x" does not tell you, at the type level, whether you have a witness or not
11:23:09 <sohum> a Just x does, though. 
11:23:23 <monochrom> but "Just x" is at the value level, not at the type level
11:24:24 <ReinH> I think the issue is slightly different. You can't know at the type level, because that would require dependent types.
11:24:45 <monochrom> I am just mimicking your logic. you first assert, type Bool does not type-level-guarantee that the value is True. and so I mimic that to: type Maybe x does not type-level-guarantee that the value is always Just x.
11:24:47 <ReinH> At the value level, Bool doesn't tell you which is true and which is false
11:24:59 <ReinH> Maybe a does
11:25:03 <dolio> What's the point of calling indexOf? If you do !! at the number it gives you, you should get back the original value you put in indexOf.
11:25:51 <monochrom> furthermore what is "Maybe 4"?
11:25:59 <ReinH> I think "at the type level" isn't what they meant, but that's just like my opinion, man
11:26:21 <sohum> ah, _sort of_. Maybe is a union type of Just and Nothing, which implies to me that Just and Nothing are also morally types, but I'm willing to say that it's at the value level for the discussion, that's not what I want to discuss
11:26:36 <ReinH> They are not morally types.
11:27:10 <OverCoder> Is it possible to do 'case exp of' with one line matching two cases? like 1 || 2?
11:27:12 <monochrom> what the hell? can't I say the same thing about Bool? Bool is a union type of False and True, therefore False and True are morally types?
11:27:22 <ReinH> OverCoder: you need a semicolon
11:27:32 <OverCoder> ReinH, um, can you show me an example?
11:27:51 <sohum> sure, okay, like I said, I'm willing to say at the value level
11:27:52 <dolio> The issue with booleans is that you have a test and an operation that's only well defined within the confines of that test. So it's better to roll that into a single operation that encodes both the test and the result of the operation. But doing that with indexOf and (!!) is just a -> [a] -> Maybe a, where you get back the first argument if it's in the list, and Nothing otherwise.
11:28:01 <ReinH> > case True of True -> 1; False -> 2
11:28:03 <lambdabot>  1
11:28:27 <Gurkenglas> ReinH, he wants to write the right side of the -> only once
11:28:50 <ReinH> Oh. One line doesn't mean "on one line". Got it.
11:29:03 <OverCoder> ^
11:29:13 <OverCoder> That's what I meant :>
11:29:28 <ReinH> That was asked and answered on SO yesterday http://stackoverflow.com/questions/35032490/multiple-cases-with-the-same-instructions-in-haskell
11:29:30 <OverCoder> (I just got a bit frustrated by the example for a little while haha)
11:29:38 <OverCoder> hm,okay thanks
11:30:36 <OverCoder> hm, no, guards won't work in my case, because I am casing a variable inside the body of the function itself
11:30:57 <ReinH> guards work anywhere cases work
11:31:00 <dwn> in haskell is it possible to do something like: 'a' - 'a' = 0, 'a' - 'b' = 1, ...
11:31:30 <dwn> that is, implement a subtraction operator for Char
11:31:33 <ReinH> dwn: Not with (-), and I also don't see the logic.
11:31:38 <ReinH> 'a' - 'b' is not 1
11:31:42 <OverCoder> ReinH, ooh, /me goes to read the docs of guards
11:31:58 <ReinH> :t ((-) `on` fromEnum)
11:32:01 <lambdabot> Enum a => a -> a -> Int
11:32:16 <dwn> ReinH: ord 'b' is ord 'a' plus on
11:32:19 <dwn> e
11:32:22 <ReinH> :t ((-) `on` fromEnum) 'b' 'a'
11:32:24 <lambdabot> Int
11:32:31 <ReinH> dwn: yes, and 1 - (1 + 1) is not 1
11:32:50 <dwn> er, right
11:32:50 <ReinH> x - (x + 1) is not 1 for any x
11:32:51 <monochrom> > fromEnum 'a' - fromEnum 'b'
11:32:53 <lambdabot>  -1
11:32:54 <dwn> I totally meant the opposite order
11:32:59 <ReinH> Yes, you totally did.
11:33:00 <dwn> my bad
11:33:20 <monochrom> you need to proofread everything you write
11:37:18 <sohum> the point of calling indexOf here might be that you want to do some sort of manipulation with the relationship between the index and the element. say you want to find the next element in a list given some element in the list. (and let's say with wraparound, so we don't have to deal with the case where the new index is out of bounds.) with indexOf, you have to get the Maybe Int that represents your index iff
11:37:24 <sohum>  the element is in the list, then ...
11:37:27 <sohum> ... you add 1 mod length to it, then you get _another_ Maybe when you index back into the list, because the compiler doesn't know the provenance of your Int
11:39:42 <sohum> Int as a type seems like it doesn't capture all it could here, in the same way Bool as a type wasn't capturing all it could there
11:40:09 <ReinH> sohum: That sounds like "if you want the index then you should get the index"
11:40:24 <dolio> Then the problem has nothing to do with indexOf, it has to do with your modulo operation and the knowledge that indexing into a list modulo its length is always well-defined.
11:40:56 <dolio> It could be any integer, not just one from indexOf.
11:41:06 <haskell323> Hi Im trying to accept command line arguments using arguments
11:41:09 <sohum> well, in the same way that there's nothing specifically wrong with Map.has
11:41:59 <sohum> it's just that we understand the type that captures the extra information we want relative to Map.has, and so Map.get returns a Maybe
11:42:08 <haskell323> Hi Im trying to accept command line arguments using haskell just 3 numbers
11:42:48 <sohum> I'm looking for an idea of what could be the corresponding type here
11:43:19 <sohum> or, really, I'm looking to poll you folks on whether you know of any already existing discussion/thought on this topic :)
11:45:00 <haskell323> Hi Im trying to accept command line arguments using haskell is there a pythonic way of doing this like arg[1]
11:45:09 <lyxia> haskell323: getArgs
11:45:15 <miguel1> hi everyone
11:45:23 <joshc> window 12
11:45:26 <joshc> ...
11:45:53 <miguel1> what do u reccomend as some project ideas for haskell?
11:45:58 <miguel1> or using haskell
11:46:22 <haskell323> when I use getArgs can I specify the parameters being passed in?
11:47:39 <Gurkenglas> miguel, Gryffindor for the consumer, Ravenclaw for the mathematician, Slytherin for metaprogramming or Hufflepuff for projects about projects?
11:48:36 <miguel1> did get it 
11:48:42 <miguel1> *didn't get it
11:49:03 <miguel1> sorry, im new around here, around the whole irc thing to be honest
11:49:04 <Gurkenglas> haskell323, the standard use for getArgs is to have the first line of your main's do block be "[foo, bar, baz] <- getArgs". For parameters like "-target file.txt", look at https://hackage.haskell.org/package/turtle
11:49:36 <noteventime> miguel1: Translate some of your shell scripts to Haskell with turtle 
11:49:47 <Gurkenglas> (As in, if you want stuff like optional parameters, arbitrary order, etc.)
11:49:51 <miguel1> i dont have shell scripts
11:49:57 <Gurkenglas> Write some!
11:50:25 <noteventime> miguel1: Then automate some of your tasks using turtle :)
11:50:48 <miguel1> what sort of tasks?
11:51:03 <miguel1> i always thought of that as appealing
11:51:21 <noteventime> miguel1: I don't know what sort of things you do :)
11:51:42 <miguel1> Guess you're right
11:51:55 <haskell323> would that be necessary if I just wanted the value of the arguments being passed such as three numbers like 3 5 and 100?
11:52:24 <miguel1> Thought about programming a Sudoku game but i have already programmed a Sokoban type of game using haskell so it  would be more of the same
11:52:42 <miguel1> I want something that will teach me things as i go along, im more of a pratical learner
11:53:11 <o`connor> miguel1: what practical use do you have for computers?
11:53:31 <noteventime> miguel1: There's always things like hacker rank, but that's more like solving puzzles than writing software 
11:53:47 <Skye__> miguel1: You can program an artificial intelligence that is capable of being my friend :)
11:54:06 <miguel1> ahahah
11:54:18 <miguel1> Im a computer science student
11:54:20 <miguel1> first year
11:54:56 <o`connor> miguel1: so you don't have any practical problems?
11:55:22 <miguel1> not off the top of my head
11:55:37 <noteventime> miguel1: What sort of CS are you interested in ?
11:55:59 <miguel1> I like OS's, learning about the kernel and stuff
11:56:07 <miguel1> I like window managers
11:56:11 <miguel1> I use i3wm
11:56:34 <noteventime> miguel1: Why not write something for XMonad?
11:56:39 <miguel1> But i need to start small as im intermediate in haskell, just started reading about monads today
11:57:10 <miguel1> Already learned about type class and instances and custom instances
11:57:15 <miguel1> IO too
11:57:22 <miguel1> but not much more than that
11:57:49 <dolio> o`connor: Student loans are a practical problem. :P
11:57:56 <o`connor> miguel1: how about you write a Haskell parser that goes to your university website and tells you if todays lunch option is delicious or not?
11:58:13 <miguel1> Nice one
11:58:15 <noteventime> miguel1: How about an emulator for some simple old hardware 
11:58:24 <noteventime> Or just some aspect of it 
11:58:27 <miguel1> But how do i start about that
11:58:45 <miguel1> How do build a emulator or interact with the web using haskel
11:59:01 <miguel1> those ideas are actually pretty awesome
11:59:21 <noteventime> miguel1: You could start by just parsing whatever binaries you need to be able to parse
11:59:48 <miguel1> First i need to learn about parsing and binaries
11:59:55 <miguel1> I have no clue what those are :P
12:00:00 <noteventime> That's a nontrivial problem, both to learn to use some parsing library and to research the format and instruction sets of the platorm 
12:00:17 <o`connor> miguel1: https://hackage.haskell.org/package/http-client ++ http://hackage.haskell.org/package/attoparsec ++ https://github.com/s9gf4ult/dom-parser
12:00:44 <miguel1> noteventime: what are the format and instruction sets of a platform?
12:01:04 <o`connor> miguel1: http://book.realworldhaskell.org/read/using-parsec.html
12:01:48 <miguel1> so a emulator would do what exactly
12:01:54 <noteventime> miguel1: The instruction set is the set of instructions the processor can execute
12:02:10 <miguel1> im thinking about the one regarding the lunch, it could apply to a lot of situations
12:02:20 <miguel1> are you talking sort of a bot that would do things for me?
12:02:25 <miguel1> that sounds amazing
12:02:26 <o`connor> miguel1: yeah
12:02:28 <noteventime> The lunch one is probably a better suggestion 
12:02:34 <miguel1> already
12:02:40 <miguel1> *alright
12:03:08 <miguel1> thats decided then, im programming a bot that goes to the weather website and tells the predictions for the next day
12:03:08 <noteventime> Though deciding whether lunch will be tasty sounds like a pretty tricky statistics/ML problem :P
12:03:11 <miguel1> :D
12:03:20 <o`connor> cool!
12:03:26 <miguel1> thanks guys
12:03:47 <miguel1> ill prob hve a lot of challenges ahead, but thats why we love programming aint it
12:03:56 <miguel1> here i go
12:04:20 <miguel1> ill prob just read about monads first
12:05:04 <o`connor> noteventime: deliciousP = (==) "tacos"
12:05:13 <miguel1> o`connor and noteventime: thanks for the idea
12:05:22 <o`connor> miguel1: no problem, good luck
12:05:37 <miguel1> what irc client are you guys using btw?
12:05:42 <miguel1> im using weechat
12:05:44 <o`connor> irssi
12:05:55 <miguel1> still learning what is irc all about :P
12:05:59 <hodapp> I'm using WeeChat.
12:06:08 <hodapp> I used irssi for ~10 years
12:06:16 <juri_> irssi. 10+ years.
12:07:33 <maerwald> fascinating
12:07:51 <pikkabird> join #qutebrowser
12:08:27 <miguel1> how do i go back in messages sent to me in weechat
12:10:02 <noteventime> miguel1: ERC (emacs)
12:11:14 <miguel1> noteventime: what?
12:11:28 <noteventime> miguel1: IRC client :P
12:12:44 <miguel1> oh ok ahah
12:16:57 <miguel1> or maybe a bot that goes to mail email and checks to see if there any new mails
12:17:06 <sohum> ReinH, dolio: ah, it could be the zipper of the list! 
12:17:50 <sohum> yes, this seems basically exactly it as a principled type representing the idea of an index into the list
12:18:33 <paulsh94> Why does "distribute cancel cancel" typecheck where "distribute f g x = f x (g x)" and "cancel x y = x"?
12:21:01 <noteventime> paulsh94: Why do you expect it not to typecheck?
12:21:38 <paulsh94> noteventime: because the second cancel doesn't have type (a -> b), but (a -> b -> a)
12:22:02 <kadoban> :t id
12:22:04 <lambdabot> a -> a
12:22:21 <kadoban> :t id :: (a -> b) -> a -> b
12:22:23 <lambdabot> (a -> b) -> a -> b
12:22:31 <kadoban> :t id :: (a -> b -> c) -> a -> b -> c
12:22:32 <lambdabot> (a -> b -> c) -> a -> b -> c
12:23:06 <noteventime> paulsh94: That just means that the "b" will become a function type
12:23:25 <kadoban> paulsh94: if you have a type like (a -> b), it can unify with something like (x -> y -> z), because (x -> y) ~ a, and b ~ z
12:23:47 <kadoban> Hmm, I screwed that up … wrong associativity, but whatever.
12:24:12 <paulsh94> noteventime: ty :)
12:24:15 <paulsh94> kadoban: ty :)
12:25:04 <noteventime> paulsh94: distribute :: (a -> b -> c) -> (a -> b) -> a -> c, so if you take b ~ (t -> s) you get :: (a -> (t -> s) -> c) -> (a -> t -> s) -> a -> c
12:25:06 <noteventime> and it fits
12:25:42 <paulsh94> yh, makes sense now :)
12:25:58 <paulsh94> thank you
12:28:48 * hackagebot graph-rewriting 0.7.8 - Monadic graph rewriting of hypergraphs with ports and multiedges  https://hackage.haskell.org/package/graph-rewriting-0.7.8 (JanRochel)
12:32:25 <miguel1> :quit
12:43:10 <Rouven> anyone using Atom with ide-haskell and ghc-mod?
12:43:35 <umib0zu> Rouven
12:43:37 <umib0zu> I am
12:43:41 <umib0zu> it’s broken though
12:43:45 <Rouven> yeah I noticed
12:43:58 <Rouven> linting works
12:44:19 <Rouven> but whenever I save I get file-not-found errors from ghc-mod
12:44:25 <umib0zu> same with me
12:44:45 <umib0zu> I do believe there’s a requirement somewhere that I don’t have
12:44:50 <umib0zu> I’m on a Mac by the way
12:44:50 <Rouven> I have a stack project, maybe it's that?
12:44:55 <Rouven> Mac as well
12:45:17 <umib0zu> I tried to dig into it but I think there’s some brew requirement that I haven’t found
12:45:41 <umib0zu> I built ghc from source, but this requirement seems to not be from source
12:51:15 <Rouven> I thought Stack would keep everything project-centric. Why is it using /usr/local/Cellar/ghc/7.10.3b/lib/ghc-7.10.3/   (I did NOT install ghc with Homebrew!)
12:56:12 <x77686d> I'm trying to figure out which version of the Prelude docs most closely correspond to the haskell-platform package 2012.1.0.0~debian1.  How could I do that?
12:57:27 <kadoban> x77686d: Figure out what GHC version it includes, the figure out what base version that corresponds to, and then you can find the docs.
12:58:06 <kadoban> x77686d: You're not intentionally using that haskell-platform, with no context, are you? There's newer ones, and haskell platform itself … I don't think is really recommended anymore.
13:00:07 <x77686d> I'm teaching a class and that's what installed.  I know it's out of date but there are upgrade issues that are beyond my control.
13:00:23 <x77686d> ghc shows 7.4.1
13:01:12 <x77686d> How could I map that back to a base version?
13:01:27 <kadoban> x77686d: From the release notes, that looks like base-4.5.0.0
13:02:31 <kadoban> x77686d: So I guess this stuff? https://hackage.haskell.org/package/base-4.5.0.0/docs/Prelude.html
13:02:52 <x77686d> Perfect!  Thanks!
13:03:01 <kadoban> x77686d: Also, wow that's old :-/
13:03:31 <kadoban> 'welcome
13:03:32 <x77686d> Our use is pretty modest.
13:05:09 <sbrg> I would like to generate haddock documentation for my code, but running 'stack haddock' starts rebuilding all my dependencies.. which I don't want to do. What is the correct way of doing this?
13:06:50 <Rouven> umib0zu: Got it working
13:06:56 <umib0zu> how
13:06:59 <kadoban> sbrg: --no-haddock-deps maybe?
13:07:00 <Rouven> stack --no-system-ghc --install-ghc build ghc-mod
13:07:11 <Rouven> in my project folder
13:07:24 <umib0zu> oooo
13:07:25 <Rouven> I don't have any global ghc/cabal/etc
13:07:32 <Rouven> using stack on a per-project base
13:07:33 <umib0zu> does anyone have a decent intro to stack
13:07:37 <sbrg> kadoban: ! that was it. thanks!
13:07:43 <umib0zu> I still haven’t reverted over
13:08:44 <kadoban> umib0zu: haskellstack.org is a decent set of docs, there's a quick-start and a user guide. There's also a video on youtube that chris allen and his coauthor for the haskellbook did
13:09:12 <kadoban> umib0zu: https://www.youtube.com/watch?v=sRonIB8ZStw
13:16:47 <sbrg> Okay... so what exactly do I need to do to generate documentation for my code? I ran 'stack haddock..' and it did something, but no documentation is to be found anywhere.
13:17:46 <kadoban> sbrg: It should output near the end where to look for the docs
13:18:50 * hackagebot servant-swagger 0.1.2 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-0.1.2 (NickolayKudasov)
13:19:54 <sbrg> kadoban: doesn't look like it. it tells me where it put the executable but nothing about the documentation.
13:20:21 <sbrg> If I find the doc folders in .stack-work those are empty save for my LICENSE file.
13:21:37 <sbrg> do I need to enable a flag in my .cabal file or something?
13:21:45 <kadoban> sbrg: Oh do you only have an executable, no library?
13:22:14 <sbrg> yeah. I just stumbled upon this: http://stackoverflow.com/questions/32712775/generating-documentation-for-my-own-code-with-haddock-and-stack
13:22:37 <sbrg> that's great.
13:23:41 <kadoban> Yeah, slightly unfortunate. Usually docs (of this kind) for an executable aren't amazingly useful though I guess that's not universal.
13:28:14 <sbrg> i guess I'll have to refactor the code into a library to be used by the executable
13:32:41 <marchelzo> hi
13:33:59 <marchelzo> what's the nicest way to avoid lots of this? http://sprunge.us/EGIj
13:35:04 <orion> marchelzo: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Maybe.html
13:35:37 <orion> Check out `maybe` and `fromMaybe`.
13:36:17 <deech> I have code that commpiles and works fine as an executable, but when loaded into GHCi I'm getting type errors. I don't have a small example. Are there any general debugging tips for this?
13:37:13 <marchelzo> so it would become "maybe (return ()) bar foo"
13:37:16 <kadoban> deech: How are you building the executable? How are you loading it into GHCi?
13:37:20 <marchelzo> I guess that's better
13:38:42 <lyxia> mapM_ bar foo
13:39:09 <deech> kadoban: These are the only compile time options I have in my Cabal file: -Wall -threaded. The rest are for the linking.
13:40:04 <marchelzo> oh, Maybe has a foldable instance
13:40:07 <marchelzo> cool
13:40:08 <kadoban> deech: So you're doing 'cabal install' to build the executable then? How are you loading it into GHCi?
13:41:17 <deech> kadobak: Or `cabal build`, yes. Just `:set -Wall -threaded` followed by `:load <main-module-file>`.
13:43:44 <kadoban> deech: Are you doing 'cabal ghci' or … crap is it called 'cabal repl' or something maybe? Or are you just doing 'ghci' and then stuff?
13:43:59 <kadoban> deech: I'd prefer the first, whichever one of those is the real command.
13:44:12 <deech> Ok, I'll try that. Thanks!
13:46:12 <edwinpeguero> how can I pass input to a shell command?
13:46:51 <epeg> I have (Just inp, Just out,_,_) <- createProcess (shell …) …
13:47:09 <epeg> but manipulating inp and out doesn’t seem to have an effect
13:47:41 <Unhammer> is there a regexp-quote function in Text.Regex(.TDFA) somewhere? can't find anything, but perhaps it's called something else …
13:48:29 <Unhammer> (ie. to turn "foo(bar)[1]" into "foo\(bar\)\[1\]" for literal matching on parts of a larger regexp)
13:49:15 <lyxia> epeg: have you tried flushing the channels on both sides ?
13:49:48 <epeg> lyxia: nope, let me try that.
13:56:34 <epeg> Can someone help me fix this shell code (http://lpaste.net/151040), it runs a command successfully, but then fails to interact with it.
13:57:30 <SavinaRoja> I'm glad I asked for clarification on what turned out to be vim search/replace syntax yesterday, getting a lot of mileage out of that
13:59:39 <lyxia> epeg: where does it get stuck, and what command are you running
14:08:46 <geekosaur> urgh. you do know about the limitations of doing a bidirectional pipe like that, right?
14:09:02 <geekosaur> regardless of language? regardless even of OS (provided it supports pipes at all)?
14:09:59 <geekosaur> basically, given this code you want at least the output part to be in a separate thread
14:10:34 <glguy> epeg: It's not OK to call hGetContents  more than once one a Handle
14:11:05 <geekosaur> hm, maybe not. but this is a deadlock, and yes, hGetContents should (but doesn't for some reason) throw an exception the second time
14:11:05 <glguy> epeg: and after you do so this line isn't going to finish until EOF: putStrLn streamElement
14:11:25 <geekosaur> so you have both IPC deadlock *and* lazy I/O problems
14:14:48 <glguy> geekosaur: it doesn't throw because the code never advances past line 12
14:22:48 <Strukks> I have trouble with writing a function that counts all elements in a non-binary tree
14:23:53 <lyxia> Strukks: what kind of trouble?
14:24:49 <Strukks> The kind where I don't know how to do it 
14:25:18 <umib0zu> Strukks define “non-binary tree”
14:25:27 <miguel> hi
14:26:15 <kahiru> Strukks, is non-binary tree a tree which can have a variable number of child nodes?
14:26:22 <Strukks> kahiru, yes
14:26:42 <Strukks> umib0zu: what kahiru said!
14:26:52 <koz_> Strukks: You probably want something called a 'rose tree' then: https://en.wikipedia.org/wiki/Rose_tree
14:27:00 <umib0zu> Strukks now explicitly define it.
14:27:36 <Strukks> data tree a = root a [tree a]
14:28:42 <umib0zu> ahh ok
14:28:46 <Strukks> You start the counting function with "= 1 + ..." but I've tried bunch of things next and idk
14:29:01 <koz_> Strukks: What are you trying to do exactly?
14:29:09 <Strukks> count all the nodes
14:29:29 <koz_> Strukks: You want a recursive fold.
14:29:47 <koz_> Think of it this way - you wanna count the nodes in the subtree, then sum all of them and add 1.
14:29:47 <Strukks> Yeah, I could do it for a binary tree easy, but now I have trouble
14:29:54 <koz_> Strukks: Well, consider it this way.
14:29:59 <koz_> Your base case is the same - a leaf has 1 node.
14:30:16 <umib0zu> what koz_ said. binary trees are easy to pattern match over but a pattern matching over a variable number of child nodes is hard.
14:30:33 <Strukks> koz_: ok, I got it
14:30:33 <koz_> Then you set up the recursive case something like this:
14:30:34 <umib0zu> I think what koz_ means is that the child nodes need to be in a list
14:30:39 <Strukks> Yeah, done
14:30:44 <koz_> umib0zu: That's the very definition of a rose tree.
14:30:47 <Strukks> sum is what I needed
14:31:00 <umib0zu> nice
14:31:03 <Strukks> I messed around with "length" all the time, I just had to put "sum" instead
14:31:17 <koz_> Strukks: Yeah, 'length' is a complete red herring here.
14:31:18 <Strukks> So obvious now :D
14:31:36 <koz_> Strukks: It's OK - this can be annoying, especially if you wanna do something complex with variable-arity trees.
14:31:53 <Strukks> variable trees are lame, I like binary trees
14:32:21 <koz_> Strukks: Well, every variable-arity tree can be binarized.
14:32:28 <koz_> (using something called the Knuth transform)
14:32:39 <Strukks> yep
14:49:04 * hackagebot bustle 0.5.4 - Draw sequence diagrams of D-Bus traffic  https://hackage.haskell.org/package/bustle-0.5.4 (WillThompson)
14:54:13 <hiptobecubic> That's a neat idea.
15:04:04 * hackagebot hothasktags 0.3.5 - Generates ctags for Haskell, incorporating import lists and qualified imports  https://hackage.haskell.org/package/hothasktags-0.3.5 (LukePalmer)
15:26:00 <ReinH> Data.Tree is a rose tree.
15:39:26 <snhmib> it is not possible to get a lazy bytestream from a socket handle? i use B.hGetContents, but then the program crashes with: "<socket: 3>: hGetBufSome: illegal operation (handle is closed)" if the other end closes the connection
15:39:28 * achudnov has spent the last hour studying stack source code and official docs to get the bastard to write test logs to a file...
15:39:50 <clintm> Ah, need to compile haskell-src-exts again.  Time to temporarily resize the build vms memory.
15:39:54 <achudnov> Does anybody by any chance know how to convince stack that printing logs to a file is a worthwile thing?
15:40:18 <achudnov> The option is in the code, but I can't figure out how to trigger it :(
15:40:39 <mgsloan> achudnov: It does, and as far as I know the marital status of software's parents are rather irrelevant
15:41:27 <achudnov> mgsloan: fair enough regarding the marital status
15:41:34 <clintm> achudnov: If nothing else, you could do 'stack build >logfile 2&1' or... hrm. the 2&1 is close, but I don't think that's right.  Let me look it up.
15:41:55 <clintm> that is, if you're on a unixey os.
15:42:00 <achudnov> clintm: yes, I could do that...
15:42:11 <hpc> stack build 2>logfile
15:42:13 <mgsloan> Here is where the decision is made https://github.com/commercialhaskell/stack/blob/master/src/Stack/Build/Execute.hs#L739
15:42:37 <achudnov> mgsloan: yes, it check for console AFAIU
15:42:41 <mgsloan> In other words, if we are building the last task, and the user only asked for one thing to be built, test logs are sent to the console
15:42:56 <achudnov> mgsloan: I even tried passing --no-terminal
15:43:03 <mgsloan> If the test fails, it always gets sent to the console
15:43:21 <achudnov> mgsloan: how can I get a copy in the log file?
15:44:06 <clintm> stack build >logile 2>&1 will throw everything into logfile
15:44:33 <clintm> ok, everything that went to stout or stderr
15:44:42 <achudnov> clintm: I understand. I'm just trying to figure out how to trigger the functionality that's *already in stack*
15:45:02 <achudnov> clintm: also, yes, I don't want the whole build log to show up --- just the test log
15:46:14 <mgsloan> Due to efficiency reasons, it ends up either being sent to the log file or the console, but not both.  I think we want to leave this as a default (sometimes you want to test things with a ton of debug logging on, and you get tons and tons of logs)
15:46:22 <achudnov> mgsloan, clintm: is what I want impossible in stack?
15:46:53 <mgsloan> achudnov: No, you just need to ask stack to build more than one target, and you will always get log files
15:47:13 <mgsloan> There isn't any flag for always getting log files with multiple targets, though
15:49:30 <mgsloan> If you wanted to implement sending it to both the console and the log, that could happen here https://github.com/commercialhaskell/stack/blob/master/src/Stack/Build/Execute.hs#L1236 , using code somewhat similar to https://github.com/commercialhaskell/stack/blob/master/src/Stack/Build/Execute.hs#L864
15:50:21 <mgsloan> You'd write to the console and write to the file, consuming the same conduit of process output
15:53:45 <achudnov> mgsloan: Could I bother you for an example of how to issue a test command with multiple targets? Suppose, there's a library called "lib" and a test-suite called "lib-test". (And, yes, I did read the --help and try different things already.)
15:55:44 <achudnov> mgsloan: Also, would having a flag to force writing log files be an acceptable feature request?
15:56:23 <mgsloan> Ahh, it's actually gotta be multiple target packages
15:56:41 <Rembane> 5
16:00:33 <achudnov> mgsloan: as far as I understand, tweaking the console guard of withLogFile (https://github.com/commercialhaskell/stack/blob/master/src/Stack/Build/Execute.hs#L759 ) would be the most straightforward way
16:11:17 <snhmib> you have to be joking me
16:11:40 <snhmib> it is not possible to use Network.Socket.ByteString, together with Data.Binary?
16:12:32 <CodeWeaverX> Anybody here familiar with using haskell's multithreading features?  I've got a concurrency performance issue I'm trying to ferret out.  Running this with multiple cores doesn't really give decent performance under OSX (which may be related to a logged bug in the RTS).  http://pastebin.com/qrBi3A7J  
16:14:10 <pavonia> snhmib: What makes you think it isn't?
16:15:32 <CodeWeaverX> Tbat it isn't performant?  My timing on it with no specification on the number of cores is 11s.  With 4 cores, it's 5.5 and change.  Given that the summations are utterly independent, I would expect better than a factor of 2 improvement.
16:16:03 <CodeWeaverX> Probably not actually 4, but better than 2.
16:16:18 <Shockk> CodeWeaverX: I think pavonia was replying to snhmib's question, not your code
16:16:25 <CodeWeaverX> Oh oops!
16:16:26 <CodeWeaverX> Sorry!
16:16:32 <snhmib> pavonia: i cannot get their types to match or something
16:18:15 <snhmib> wait i'll make a test
16:18:57 <pavonia> snhmib: The only problem I could think of is lazy vs. strict bytestrings, but there are conversion functions
16:19:04 <mgsloan> achudnov: Right, if you're fine with none of the logs being sent to console
16:19:26 <snhmib> pavonia: i tried importing both
16:19:48 <snhmib> i keep getting this: Couldn't match type `B.ByteString' with `Data.ByteString.Lazy.Internal.ByteString'
16:20:51 <pavonia> snhmib: Yeah, use from/toStrict
16:21:15 <glguy> snhmib: Regarding B.hGetContents, are you calling it more than once on the same handle?
16:21:44 <snhmib> http://pastebin.com/c1Ts5tjj
16:21:50 <snhmib> glguy: offcourse not
16:22:29 <snhmib> i switched from hGetContents to using send recv loops
16:22:38 <glguy> snhmib: You'll need to convert that lazy bytestring to a strict one, or use the lazy sending function
16:24:01 <glguy> also remember that send doesn't necessarily send the whole thing, it tells you how much it sent. There's sendAll, too
16:24:43 <snhmib> ooo
16:24:55 <snhmib> there is a lazy network bytestring package
16:25:01 <snhmib> ok cool :)
16:25:13 <glguy> There's a lazy bytestring module in the normal network package, actually
16:25:36 <snhmib> ?
16:25:41 <glguy> http://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket-ByteString-Lazy.html
16:25:46 <glguy> You don't need a separate package
16:25:54 <snhmib> oh no that's what i ment
16:26:19 <snhmib> adding .Lazy at the end made it compile :P
16:27:01 <achudnov> mgsloan: alright, thank you! Would you accept an issue for that feature?
16:38:22 <Shockk> this question's for anyone who's used web-routes before, for example with happstack or something like that:
16:38:46 <umib0zu> Shockk shoot
16:39:06 <Shockk> I know I can define my routes like `data Route = ViewObject Integer | NewObject` to end up with routes like /view-object/<Integer> and /new-object
16:39:36 <Shockk> but I wondered if there's something I can do to end up with a route like /view-object/<Integer>/<Integer>/...etc
16:40:08 <Shockk> for example `data Route = ViewObject [Integer]` <- would that kind of thing work for what I'm trying to do?
16:41:12 <mgsloan> achudnov: Sure, I'd accept a PR too.  Gonna have to wait for github to come back online tho.  I'm thinking "--output-logs".  Later, we can add "--output-console" to send everything to console
16:45:23 <CodeWeaverX> Okay, perhaps I'll rephrase this.  Where would be the best irc channel to pick someone's brains about parallel haskell performance?  I'm a little loathe to bug the GHC team on the trac site over what might be trivial.
17:04:17 <CodeWeaverX> Glargh.  Silly web irc client.
17:17:23 <finlay> hi
17:17:28 <valentine-bot> can someone explain to me why 'let _ = _' expressions are not allowed in many interpreters?
17:17:37 <valentine-bot> like most interpreters you can't define anything
17:17:46 <ReinH> "most interpreters"?
17:17:47 <finlay> does anyone know how to work around the github outage while using stack ??
17:18:02 <ReinH> Which interpreters?
17:18:07 <valentine-bot> every one i've used lol
17:18:19 <boj> define one
17:18:25 <ReinH> Which ones have you used?
17:18:31 <valentine-bot> http://tryhaskell.org/ for example
17:18:41 <valentine-bot> and the one on haskell.org which i think is the same one
17:18:42 <ReinH> Ok, how about another?
17:18:48 <ReinH> Ok, so that's one.
17:18:51 <valentine-bot> lol
17:19:10 <valentine-bot> i just don't understand let statements
17:19:11 <ReinH> tryhaskell.org is not a normal interpreter
17:19:18 <valentine-bot> and why they are a special case for certain interpreters
17:19:29 <ReinH> tryhaskell.org is not a normal interpreter
17:20:14 <mgsloan> finlay: Theirs an issue about adding an "--offline" flag / generally supporting offline use better
17:20:23 <mgsloan> I'd link you to it if github was up, heh
17:20:33 <ReinH> It allows a restricted subset of things because its goal is to demonstrate very basic haskell usage
17:20:33 <boj> the irony
17:20:50 <finlay> an issue, so not yet resolved
17:21:11 <finlay> mgsloan: so, stop working ?
17:21:25 <valentine-bot> is let a = 3 a valid haskell sentence
17:21:34 <valentine-bot> or is it always [let ___ in ___]
17:21:41 <mgsloan> Right.  There's also the thing about build plans not getting redownloaded.  If the server is down, then the html page gets downloaded, and that snapshot's description will always fail to parse.  I fixed that bug yesterday
17:21:49 <ReinH> let ident = expr is valid in do notation
17:21:58 <ReinH> otherwise it must be let ident = expr in expr
17:22:14 <finlay> I managed to find the lts-5.0.yaml file
17:22:28 <mgsloan> finlay: Which part of it isn't working?  The buildplan downloading?  If you've already got a project setup and building, it should continue building without needing internet access
17:22:52 <finlay> all-cabal-hashes.git/': The requested URL returned error: 500
17:23:17 <finlay> yeah, I will work on some other aspect...
17:23:38 <finlay> I wanted to upgrade to lts-5.0, and a particular package....
17:23:43 <finlay> maybe just revert to cabal !
17:24:16 <finlay> btw: "stack solver" is really great
17:24:29 <mgsloan> Sorry, work on stack started 8-9 months ago, it isn't perfectly polished yet
17:25:11 <mgsloan> Next time I need to take a trip on an airplane it'll probably get better offline support XD 
17:25:13 <finlay> mgsloan: its great
17:27:21 <ReinH> mgsloan: are you aware of skete?
17:29:58 <mgsloan> ReinH: Aware of its existence, but not sure about all the details
17:30:11 <ReinH> k
17:31:10 <mgsloan> I'll put down a TODO to consider whether we should try having stack use it
17:31:31 <mgsloan> There's also "yackage", for hosting a local hackage-like server
17:31:48 <ReinH> skete stores a hackage package collection in git, which achieves surprisingly good compression
17:32:00 <ReinH> so 16GB fit in about 1GB
17:32:21 <ReinH> there are some nice features around using branches to specify specific package subsets
17:32:30 <ReinH> so there could be, e.g., a branch for each nightly and lts release
17:32:47 <mgsloan> Ohh right, that idea. Interesting!
17:32:50 <ReinH> combined with edge caching I think it also has the potential to reduce server costs
17:33:06 <ReinH> anyway it's coming along pretty well now
17:33:16 <ReinH> you should talk to davean about it
17:33:30 <dsdeiz> curious, is it a good idea to convert bash scripts to haskell for the idea of learning and make the scripts faster?
17:33:48 <mgsloan> Using branches like that seems weird to me, but yeah, I'd be down to talk with them about it
17:33:48 <ReinH> Learning? Sure. Performance? Probably not.
17:33:57 <ReinH> mgsloan: branches, tags, w/e
17:34:09 <ReinH> Shell scripts tend to be IO bound
17:34:41 <jle`> dsdeiz: i think it's good practice
17:34:48 <jle`> there's a lot of resources around doing such a thing, too
17:35:03 <ReinH> I've converted a fair amount of shell scripts to Haskell and so far I've been happy
17:35:07 <jle`> http://hackage.haskell.org/package/turtle is a nice library with a great tutorial
17:35:11 <ReinH> easier maintenance is reason alone for me
17:35:36 <jle`> i think Tekmo is using turtle/shell scripting as a way to slowly infiltrate twitter with haskell
17:35:46 <jle`> making everyone do their scripts in turtle, heh
17:35:51 <ReinH> heh
17:35:53 <jle`> i wonder how that's going
17:36:13 <ReinH> I haven't tried turtle since it wasn't around when this was my day job, but process and conduit-process are relatively easy to use
18:11:26 <crypsys> i have a question about list comprehensions
18:12:05 <koz_> crypsys: What's your question?
18:12:26 <crypsys> why are they restricted to lists?
18:13:01 <crypsys> isn't "[" expr "|" bindings "]" equivalent to "do" "{" bindings ":" expr "}"?
18:13:13 <crypsys> s/:/;/
18:13:38 <geekosaur> they are because the haskell 98 committee said so
18:13:46 <geekosaur> see -XMonadComprehensions
18:13:52 <crypsys> shouldn't it work on any monad/functor, like [x*y | x <- Nothing, y <- Nothing]
18:13:56 <geekosaur> (or the Haksell 1.4 Report...)
18:15:16 <crypsys> i mean i understand that that's what the language specifies
18:15:19 <geekosaur> Functor isn't strong enough btw
18:15:30 <crypsys> yeah i wasn't sure about that
18:15:37 <geekosaur> Monad is overkill and ghc 8.1 wil lhave ApplicativeDo extension
18:15:49 <geekosaur> but basically the answer is not technical but politics
18:16:00 <geekosaur> they *were* monad comprehensions though Haskell 1.4
18:16:05 <dolio> Depending on what you write, Applicative is overkill.
18:16:08 <crypsys> it's been a long time since i've actually used haskell, and i've had no other need to understand monads
18:16:11 <geekosaur> Haskell 98 restricted them to lists
18:16:15 <dolio> And Functor is enough.
18:16:29 <geekosaur> GHC has an extension to make them monads again, and 8.1 will have an extension to allow them tpo be Applicaties
18:17:31 <geekosaur> they probably would have been applicatives originally if the idea had existed back then
18:18:04 <koz_> geekosaur: That's actually pretty cool. I learned something today.
18:18:11 <EvanR> you need to understand monads to interpret monad tutorials
18:18:25 <crypsys> so basically it's the same reason that map :: (a -> b) -> [a] -> [b] instead of map :: (:t fmap)?
18:18:34 <geekosaur> pretty much
18:18:51 <geekosaur> haskell '98 restricted a lot fo things in the name of making a better first time user's experience (as if!)
18:19:31 <geekosaur> since that was pretty much a failure from the outset, ghc has gradually been dismantling the restrictions
18:19:37 <EvanR> for fmap vs map, a convenient way to specialize types would fill that role
18:20:08 <EvanR> :t map where f = []
18:20:10 <lambdabot> parse error on input ‘where’
18:20:40 <EvanR> (a -> b) -> [a] -> [b]
18:21:28 <crypsys> that might make the weird stuff like ((.).) easier to understand too
18:21:39 <crypsys> (.) where f1 = (.)
18:21:44 <crypsys> type of (.), rather
18:22:24 <EvanR> :t (.)
18:22:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:22:53 <EvanR> well theres no handle for that, but you can use asAppliedTo
18:23:17 <EvanR> :t (.) `asAppliedTo` (.)
18:23:18 <lambdabot> ((b -> c) -> (a1 -> b) -> a1 -> c) -> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
18:23:30 <EvanR> much more clear
18:24:13 <EvanR> :t (.) (.)
18:24:14 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
18:25:09 <crypsys> it's like i'm reading the lens tutorial again
18:25:38 <finlay> :-)
18:26:01 <EvanR> the alphabet a b c a1 b1 etc is annoying
18:26:18 <crypsys> yeah, but i can't think of a better way
18:26:26 <EvanR> im ok with d
18:26:32 <EvanR> at least
18:26:52 <crypsys> :t (***)
18:26:54 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:27:03 <crypsys> now that's nice. i like primes
18:51:02 <deech`> I have a Haskell project that produces both a Haskell and a C shared library. I can build executables but can't get them to load in GHCi.  
18:51:15 <deech`> Because it can't find the C library.
18:52:16 <deech`> Currently the C lib goes in the standard ~/.cabal/lib... folder so it should find it. Any help is appreciated. 
19:13:17 <mrlase> how does selectList infer the type of Entity you are selecting? i.e., getFoos :: IO [Entity Foo] magically returns foo
19:13:37 <John[Lisbeth]> I am having trouble understanding case .. of
19:14:01 <John[Lisbeth]> I understand what type of things go in the of clause, but I have no idea what the case clause is for
19:18:45 <geekosaur> mrlase, unlike many languages, Haskell supports return type polymorphism
19:19:46 <geekosaur> which means, among other things, that if you specify the result type or it can be inferred from your code, Haskell can use it to select an appropriate typeclass instance
19:20:48 <mrlase> haskell continues to blow my mind
19:20:49 <geekosaur> however I note that if this is selectList from persistent, it has access to the result type because it's also the type in filters and select options
19:20:58 <geekosaur> type inference canbe quite powerful :)
19:23:53 <EvanR> so if you use read :: Read a => String -> a, step 1 is to determine what a is, then step 2 is to find a unique Read instance for that type. since if there is no instance or we dont know which one to use, it makes no sense. i would be allowed to generate any type i want like IO [Mvar Double] from nowhere
19:24:00 <Tim> Hello everyone
19:24:38 <Tim> I'm brand new to coding/programming. Is Haskell something that I can learn for my first language?
19:25:04 <EvanR> yes
19:25:20 <kadoban> Tim: You can, sure. It's a somewhat unconventional choice, but I believe a good one.
19:25:41 <supertramp_> Yup
19:26:10 <Tim> Thanks for all of the feedback. It's greatly appreciated.
19:26:19 <EvanR> alternatively you use the returned read result as the result of a yet another Read-polymorphic function
19:26:22 <supertramp_> Learn others at the same time tho, Haskell is very different from most langs
19:26:32 <kadoban> Tim: The only first languages I ever recommend are python and haskell, usually python just because there's a lot of fairly decent learning materials free out there for it.
19:27:06 <kadoban> supertramp_: That's … probably not a good idea, one should usually learn one language first until they can actually accomplish things.
19:27:21 <Tim> I'm an Econ student so I'm looking at learning R and SQL over the course of the semester.
19:28:18 <Tim> I stumbled upon "functional programming" and heard that it is harder for previous programmers because of the habits formed with other languages so I was really curious to get some community weigh in.
19:28:19 <synergistics> Generally, is the behaviour of a data type defined more by the functions that use that type than by the definition of the type itself? I've found that to be the case a lot of the time. Like with the Either type, it doesn't really have too much meaning unless you make functions that deal with the structure of the type.
19:29:11 <synergistics> Or do I just have this all wrong?
19:29:55 <EvanR> a good abstract data type only tells you how the operation work, rather than what its made of
19:30:06 <EvanR> Either is a bad example since its meant to be used raw
19:30:15 <kadoban> Tim: That's fairly accurate, yeah. It's different from most languages in ways that take the average programmer a little while to grasp.
19:30:33 <EvanR> synergistics: compare the type IO a
19:31:11 <EvanR> with primitives getChar, putChar, and combinators return, >>=
19:33:04 <synergistics> EvanR: I don't know much about the IO type, what are you saying?
19:33:59 <EvanR> the behavior of IO is understood in terms of its API, not the definition of the type, which you cant see
19:34:03 <EvanR> like you were saying
19:34:39 <synergistics> Oh, ok
19:34:50 <EvanR> also Data.Map k a
19:35:09 <EvanR> but Either a b = Left a | Right b, and thats all there is to it
19:36:10 <synergistics> I see
19:36:12 <Gentilhomme> how hard is it to learn Haskell if you have some experience with F#?
19:38:55 <hodapp> I'd expect that the F# helps a bit, but it's closer to OCaml than Haskell
19:39:01 <synergistics> EvanR: Because I'm defining a datatype similar to a BST that should only have certain numbers in it. I wasn't sure how to make such a restriction in the type definition, but I guess that's because you shouldn't (?)
19:39:19 <EvanR> certain numbers?
19:39:59 <synergistics> EvanR: Not this specific case, but for example, no number in the tree should be higher than 100
19:40:42 <EvanR> baking that into the data structure seems inflexible, but to enforce these constraints one echnique is smart constructors
19:41:53 <EvanR> in the ctor (like Data.Map.fromList) you check that the inputs obey the preconditions, and only return a wrapped tree if so
19:42:20 <EvanR> if you dont export the wrapper, the client cant mistakenly construct wrong data
19:43:03 <EvanR> its not expressed in the type, but is a good approximate safety net
19:43:47 <synergistics> EvanR: Ah interesting. That works for preventative behavior, but for more complex rules, they're defined by the functions
19:44:19 <synergistics> EvanR: Like how you expect a bst's elements to the right of a certain element to all be greater. The type doesn't impose that restriction, the functions do
19:44:51 <EvanR> rules? with an abstract type like weve been talking about, you can document laws that the operations obey, and assuming the lib has no bugs, you can enforce it because you control the construcion
19:45:24 <EvanR> also you dont need to expose the tree itself for a BST
19:46:19 <EvanR> so thats a detail the clients dont need to know about and youre free to change later
19:47:30 <nitrix> Any GPG users?
19:47:49 <nitrix> What would you guys do if you have a lost key with no revokation certificate?
19:47:54 <synergistics> EvanR: Right, and the laws are baked into the operations, not the type declaration, correct?
19:48:21 <nitrix> It was years ago and I wasn't interested at the time. Now that I'm more into it; there's this unused key with my name in the keyservers :(
19:49:15 <EvanR> synergistics: the laws are in your head, and implemented by your code (unless you messed up)
19:49:37 <EvanR> to express laws in the type there is dependent types
19:50:01 <kadoban> nitrix: Not much you can do about it.
19:50:35 <EvanR> nitrix: well if it was compromised, dont worry about it
19:50:39 <EvanR> wasnt*
19:50:40 <nitrix> kadoban: Can I just pretend someone was trying to impersonate me before I even had my own key :D ?
19:50:51 <EvanR> you can create a new key
19:51:01 <nitrix> Yeah, the one wasn't even used once.
19:51:06 <nitrix> But it's still there, which bothers me.
19:51:09 <kadoban> nitrix: Well, you can pretend I guess, nobody can really prove either way.
19:51:23 <EvanR> thats kind of how these go theses days, its hard delete anything ;)
19:51:43 <EvanR> nitrix: its not really an issue, since no one can use it
19:55:30 <nitrix> Isn't GPG somewhat flawed? What if some majority of people gets convinced that I'm not who I claim to be?
19:56:01 <EvanR> you mean is a web of trust flawed?
19:56:08 <nitrix> I know cryptographically it's as secure as the cyphers below, but the web of trust....
19:56:18 <nitrix> EvanR: Correct.
19:56:28 <EvanR> if the world conspires against you are fucked anyway
19:57:17 <Clint> nitrix: it's the same social issue as if that happens without crypto
19:57:58 <exio4> nitrix: that's why sites like keybase.io are somewhat a thing 
19:58:29 <EvanR> maybe reddit is an example of what happens when normal people are given a web of trust to maintain
19:58:46 <EvanR> most people are normal and a few are trolls
19:58:52 <EvanR> which is like real life
19:59:30 <nshepperd> next time, create a key with an expiry date
19:59:50 <divVerent> nitrix: sure that's a problem
20:00:05 <divVerent> essentially the CA problem, just a bit more decentralized
20:00:23 <divVerent> the way to solve this with GPG is to only ever sign a key if you know the person
20:00:24 <nshepperd> then, when the expiry date stops being updated, people know that it's been abandoned/lost by the owner
20:00:28 <divVerent> or AT LEAST have seen some kind of ID
20:00:42 <divVerent> but not everyone is following that
20:01:25 <EvanR> ID = IRL ID is kind of out dated
20:01:41 <Clint> and vulnerable to attack
20:02:08 <EvanR> you can have as many identities as you want, its just what you do with them that matters
20:02:26 <EvanR> trust is built over time
20:02:47 <nitrix> Well, the way I understand it is that the web of trust cannot be trusted.
20:03:05 <nitrix> It's purely asymmetric cryptography.
20:03:38 <EvanR> one thing is that you shouldnt really trust someone that someone else trusts as much as you trust them
20:03:53 <EvanR> which is why you want a weighted score
20:04:34 <nitrix> Oh. Does it forms a graph?
20:04:35 <EvanR> GPG is about verifying peoples IRL identities, but the bitcoin-otc web of trust extended that for the topic of counterparty reliability, and anonymity
20:04:58 <nitrix> Which each person weighting other keys by signing them?
20:05:00 <Benzi-Junior> hey guys, does anyone know the name of the guy who's been rewriting the GHC type system ?
20:05:01 <EvanR> yeah nanotube implemented a cool graph
20:05:31 <EvanR> nitrix: https://bitcoin-otc.com/trust.php
20:06:11 <Clint> nitrix: it's poorly named.  it's a web of certifications.
20:12:27 <synergistics> Are the arguments of a data constructor evaluated lazily?
20:12:36 <monochrom> yes
20:12:47 <synergistics> Can I prevent that?
20:12:53 <Axman6> unless they've been marked as strict
20:12:56 <synergistics> Oh, wait nevermind
20:13:02 <synergistics> I was thinking the opposite
20:13:21 <Axman6> data Foo {a :: !Int, b :: Int} a is strict, b is not
20:23:40 <tdoan> hi everyone!
20:24:59 <synergistics> Could someone help me understand why the "left" value in my constructor is not being evaluated lazily? Here's the code: https://gist.github.com/synergistics/3b204a685e1a63f9097f
20:34:36 <Axman6> synergistics: what makes you say that it isn't?
20:35:33 * geekosaur sees a bug that suggests that it's lazy until it's bottom
20:36:31 * koz_ giggles every time he sees the term 'bottom' used in any context, due to his extreme maturity.
20:36:41 <geekosaur> (also worth remembering is that the standard operations on the standard numeric types are strict)
20:36:44 <synergistics> Axman6: Was about to say that I figured out the problem. When I run    fromBase someNumber    , I'm only getting lefts returned because they're no base case. If I ask for a right, I get it.
20:36:57 <geekosaur> heh, that's the bug I spotted
20:37:14 <synergistics> geekosaur: What, my last comment?
20:37:22 <geekosaur> the lack of a base case
20:37:40 <synergistics> geekosaur: Ah, that's intentional. It just confused me for a while
20:39:32 <synergistics> geekosaur: So when you try to run "show" on something, it'll try to be evaluated all the way?
20:39:59 <geekosaur> the default Show instance will show everything, yes
20:40:10 <geekosaur> that is, one generated with deriving (Show, ...)
20:40:34 <geekosaur> you could create a manual instance that (say) only showed level and value, although it's bad style (Show has no formal rules but several informal ones)
20:41:13 <synergistics> geekosaur: Ok, thanks for that tip
20:42:07 <synergistics> geekosaur,Axman6: And thank you for examining the code!
20:42:26 <geekosaur> in fact, in this case I think those are all you need to recreate a value, so you'd do it like the Show for Data.Map: Show produces "fromValue l v" and Read accepts that
20:43:27 <geekosaur> (some of the informal rules are that the Read instance should accept the output of Show and reconstruct the original value, and that the Show instance should produce valid Haskell(
20:43:52 <synergistics> Makes sense
20:49:47 <EvanR> > show getChar
20:49:49 <lambdabot>  "<IO Char>"
20:50:03 <EvanR> > show (return () :: IO ())
20:50:05 <lambdabot>  "<IO ()>"
20:50:19 <EvanR> > show (return undefined :: IO ())
20:50:21 <lambdabot>  "<IO ()>"
20:51:00 <geekosaur> yeh, that's a deliberate violation. hence "informal"
20:51:13 <geekosaur> it's also considered somewhat evil, but convenient for lambdabot
20:51:56 <geppettodivacin> Where is the Show for IO actually defined?
20:52:01 <geekosaur> > show Data.Char.chr
20:52:02 <lambdabot>  "<Int -> Char>"
20:52:16 <geppettodivacin> And other functions, apparently.
20:52:25 <geekosaur> ^ another useful but ill-formed instance. that one is from Text.Show.Functions IIRC
20:52:38 <geppettodivacin> Ah. Cool.
20:52:48 <geekosaur> there isn't normally a Show for IO. I don't know offhand if the one lambdabot is using is packaged
20:52:49 <geppettodivacin> I was looking for that just for testing purposes at one point.
20:53:00 <geekosaur> but it might well be related to the function instance...
20:53:16 <EvanR> the repl barfing on no show for functions and IO is something that definitely feels unfriendly 
20:53:28 <EvanR> compared to other repls
20:53:47 <geekosaur> hm, nope, not in there
20:54:04 <jle`> EvanR: yeah, it really detracts from the 'p' in repl
20:54:55 <geppettodivacin> The one in Text.Show.Functions just prints "<function>" for all functions.
20:55:02 <geekosaur> it should also be noted that these Show instances are rather limited: they can't handle polymorphic types
20:55:07 <geekosaur> yeh, just remembered that one
20:55:12 <geekosaur> so both these instances are lambdabot specials
20:55:48 <geekosaur> the disadvantage of theText.Show.Functions one is it doesn't tell you much; the advantage is it works for polymorphic functions
20:55:50 <geekosaur> > map
20:55:52 <lambdabot>      No instance for (Typeable a0)
20:55:52 <lambdabot>        arising from a use of ‘show_M1941141482469135682699’
20:55:52 <lambdabot>      In the expression:
20:56:41 <geekosaur> Typeable (used to get the parameter and result types) only works for monomorphic types (currently; I don;t think thsi si changed in 8.1 but is planned for later in the 8.x series)
20:57:00 <geekosaur> some ofthe basic work has been done but it's not complete
20:57:32 <jle`> i'm not even sure if showing functions by showing their types is the most usable thing, as far as a REPL/exploring situation goes
20:57:38 <jle`> but it's the only practical thing at the moment
20:58:05 <geekosaur> yeh, doing anything else would require a compiler hook similar to the one added for call stacks
20:58:30 <jle`> yes
20:59:03 <jle`> hm, is there at the moment any plugins to help ghci show documentation for things a la idris?  i understand it should be totally possible because haddock outputs metadata that could be parsed by a command line tool
20:59:15 <geekosaur> @hackage goa
20:59:16 <lambdabot> http://hackage.haskell.org/package/goa
20:59:37 <geekosaur> hooks a local lambdabot instance into ghci, getting you among other things @hoogle
20:59:53 <jle`> hoogle is not quite what i meant, but that's nice to package up lambdabot stuff into ghci
21:00:15 <geekosaur> although I don't tink you can use the hackage one, you need the git HEAD from (iirc chrisdone's) repo
21:00:40 <geekosaur> anyway something similar could be done if you can provide the database; ghci's :define can do pretty much anything
21:00:41 <jle`> in idris's repl, you can lookup up documentation from identifiers.  i think this should be possible because haddocks outputs metadata for documentation, not just HTML
21:01:49 * jle` forks haddock
21:02:10 <jle`> er, well, /me looks into haddock api
21:02:16 <shanemikel> hello all
21:02:32 <geekosaur> oh right, https://wiki.haskell.org/Ghci already has a minimal hoogle example
21:02:32 <koz_> Hi shanemikel.
21:03:36 <geekosaur> it's a trfle out of date though as it suggests a :browse (which was added some years ago as a way to look at the names in scope from the current or a specified module)
21:04:01 <geekosaur> oh nm, I misread that
21:04:05 <geekosaur> getting late here, sigh
21:04:14 <geekosaur> thebrowse is what it's supplementing >.>
21:04:24 <jle`> i do love browse
21:04:37 <Bruuuuno> Hello, I'm not sure if what I'm trying to do is possible, but looking at this: http://lpaste.net/151058, would it be possible to call the function createCallback like this:
21:04:44 <Bruuuuno> createCallback "string" :: Int
21:05:20 <Bruuuuno> the Int represent the "a" in the createCallback signature 
21:05:41 <jle`> createCallback str :: m (AddHandler Int), you mean?
21:05:55 <geekosaur> no, because the resul type is m (AddHandler a) not just a
21:05:55 <jle`> hm, i wonder if there's any major reason why haddock is not a library, other than the fact that the API is extremely unstable
21:06:15 <jle`> does not exporting the library allow haddock to shift the API without worrying about people using it?
21:06:17 <geekosaur> nobody did (or had the time to do) the work?
21:06:27 <jle`> well, all you have to do is add the modules to the export list
21:06:34 <geekosaur> and, well, I think the api is tied to ghc-api which is also unstable
21:06:36 <jle`> and the voila you have a library
21:06:43 <geekosaur> and they'd like to fix that, but again work
21:06:55 <mgsloan> Yeah, it'd be nice if haskell-ide-engine could link in haddock.  Then you could potentially generate docs without recompiling, I think, maybe..
21:07:01 <geekosaur> and time, and people to do it (who have time to figure out how it all works)
21:07:24 <jle`> i was just wondering why they don't just export the modules
21:07:52 <Bruuuuno> could I change something to make it possible? I really don't want to type createCallback str :: m (AddHandler Int) everytime, m is normally a pretty long type
21:07:57 <jle`> but i guess exporting modules comes with some sort of implicit contract that the api remains consistent with sem vers
21:08:09 <jle`> Bruuuuno: you can use type synonyms, maybe
21:08:17 <geekosaur> Bruuuuno, normally you let it be inferred.
21:08:35 <Bruuuuno> I don't think I can infer it in that case
21:08:50 <geekosaur> sometimes you need to toss something extra in to help the inference, since you can't currently do a partial type signature (another thing under development for 8.x)
21:09:09 <geekosaur> (I *tink* that is still incomplete, but it may be partially available in the 8.1 rc)
21:09:20 <Bruuuuno> when is 8.x due?
21:10:09 <exio4> geekosaur: you can't? I thought that was one of the features of GHC7.10?
21:10:11 <geekosaur> they're targeting middle of February
21:10:31 <exio4> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/partial-type-signatures.html
21:10:41 <geekosaur> oh hm, so it is
21:10:57 * geekosaur just checked browser page open on 7.10.3 manual
21:11:36 <Bruuuuno> oh wow that's amazing
21:12:05 <jle`> middle of february oh boy
21:13:32 <geekosaur> they had originally hoped for something sooner but some things landed late and some bugs are proving annoying to fix (like the exponential blowup in guard checking)
21:14:09 * geekosaur initially wrote "explonential", which is at least evocative...
21:15:13 <kadoban> That should really be a word.
21:39:12 <lepton> Hi
21:39:46 <synergistics> How's it going
21:41:11 <lepton> Very well
21:42:16 <synergistics> Nice to hear
21:43:50 <synergistics> When I want to see what constructor was used to create a value of a certain type, is it better to pattern match on it or make predicate functions. E.g. For Maybe values, should I check the constructor by doing something like isJust or isNothing, or should I pattern match for that in a function
21:45:27 <synergistics> Nevermind.
21:45:53 * synergistics should check Hoogle faster
21:52:49 <lyndon> Hey Haskellers, Is anyone using Stack inside Docker?
21:53:31 <lyndon> I'm trying to cache some of the build steps ahead of the main project build and having trouble getting the dependencies only building once.
21:54:04 <lyndon> I posted here, but no love yet: https://www.reddit.com/r/haskellquestions/comments/42uygr/caching_stack_package_installation_for_docker/
21:54:08 <Axman6> I assume you're not talking about the docker support built into stack?
21:54:34 <lyndon> Axman6: That's right, I'm not talking about the built-in stack docker support
21:54:56 <lyndon> This is a dockerfile intended for use with the AWS elastic beanstalk docker-instances.
21:57:31 <lyndon> If there's a stackage channel I might try asking there too.
22:03:44 <kadoban> lyndon: Why not just run 'stack install' of whatever your application is as the caching step? That'll build all of the dependencies itself and cache them. The purpose of 'stack install whatever' isn't to install the whatever library globally, it's to build the thing and copy the executables from it into ~/.local/bin/  .  I'm not 100% sure why you're seeing what you're seeing, but I also don't really understand what the syntax of the file you're showing 
22:03:45 <kadoban> is or what it's doing.
22:04:55 <lyndon> kadoban: Is there a way to install the dependency globally?
22:05:08 <adam___> does anybody here have experience with reflex dom
22:06:20 <kadoban> lyndon: Just building the thing should. So it's a little confusing what you're showing, but … I don't understand what that's the output of or what it's doing under the hood. I assume it's doing more than just running those commands.
22:06:25 <lyndon> What I'm doing here is quite specific to how docker checkpoints individual RUN commands. It isn't possible (as far as I'm aware) to cache the project build.
22:06:50 <lyndon> Since, when I make a change to the project, the build will re-start as if it had never been built before.
22:07:49 <kadoban> lyndon: Yeah I think I'd probably have to understand more about how docker works to actually have any hope of answering this …
22:07:50 <lyndon> I'm attempting to pre-cache some of the project dependency builds, so that I can somewhat aleviate the time it takes to perform the project build when I make project changes.
22:08:46 <lyndon> kadoban: Thanks for trying. It's hard to find anyone who has mentioned this use-case before.
22:10:13 <kadoban> Sorry not to be more helpful. I guess the only thing I'd say is AFAIK when stack builds things as dependencies from a lts resolver like that, it should cache them in ~/.stack somewhere and then they get reused. So if you can make docker … not mess with that cache between builds, you should be all set? I guess?
22:10:17 <lyndon> If you have any idea about how to share stack dependencies between projects then I'm fairly sure I can use that to accomplish this.
22:10:49 <lyndon> kadoban: That's what I thought too, but the logs seem to show that the builds aren't being reused...
22:11:09 <kadoban> lyndon: If you try this outside of docker are you seeing the same behavior?
22:11:42 <kadoban> (because I don't … when I setup stack on a new machine I specifically build a few big packages I know I use commonly so they're cached for later, and then go away for a few hours)
22:12:23 <lyndon> kadoban: Good idea. I'll have a try setting up something to test it. My project builds are cached normally on my local machine, so it's not natural to test this haha
22:13:02 <kadoban> I really should learn docker at some point, I have a feeling it'd help me with some random stuff I do, I keep hearing it mentioned in connection with stuff I use, just … been too lazy so far I guess.
22:14:03 <lyndon> kadoban: It's quite exhilirating using docker-compose to test microservice architectures. You don't really gain too much for single-application development though.
22:14:05 <jle`> anyone know of any type-level map libraries?
22:14:11 <jle`> i guess it'd be similar to row polymorphism i guess
22:14:19 * hackagebot cassava-conduit 0.3.1 - Conduit interface for cassava package  https://hackage.haskell.org/package/cassava-conduit-0.3.1 (domdere)
22:16:27 <EvanR> jle`: re: repls, also idris will show an unreduc(abl)ed term, which would be interesting in haskell
22:16:52 <EvanR> essentially treating all programs and values as the same
22:17:05 <jle`> yeah.  but i think that would take a bit more than what we have now in haskell to implement, i think
22:17:32 <jle`> still, showing sources might be a nice thing for ghci
22:18:44 <EvanR> the IO () you get from doing putStrLn "foo" is some invisible value in haskell
22:19:09 <EvanR> but if it was known as putStrLn "foo", it would mirror how Just "foo" isn't an invisible value (supposedly)
22:20:53 <jle`> i guess it's not fundamentally impossible in haskell
22:21:28 <jle`> but for something like IO there's going to have to be a lot of ad-hocness maybe.  maybe one day
22:22:00 <EvanR> well the case with Data.Map seems to amount to same thing
22:22:27 <EvanR> fromList [(1,'a'),(2,'b')], i mean adhoc or not its the same result
22:23:46 <lyndon> kadoban: Looks like I found the issue... The resolver was 4.2 by default, but 4.1 in the project... doy
22:24:12 <lyndon> Still, I would have thought that the resolver from fpco/stack-build:lts-4.1 would be 4.1...
22:24:21 <lyndon> *shrug* :D
22:25:34 <kadoban> lyndon: Ah, weird.
22:27:41 <mjrosenb> I'm guessing it isn't possible to export an instantiation of a type from a module?
22:27:52 <o`connor> when I compile a program with -static, and then run it on another computer, I get: "terminated by signal SIGSEGV (Address boundary error)"
22:27:55 <o`connor> is that a known issue?
22:28:44 <kadoban> mjrosenb: What is an instantiation of a type?
22:29:10 <EvanR> type Foo = Maybe Int ?
22:29:45 <jle`> EvanR: yeah, but you're going to have to account for every single IO "primitive"
22:30:57 <EvanR> jle`: if you wanted it to look nice... in idris it displays the internal __io_bind primitives that IO is implemented with
22:31:30 <EvanR> which are irreducible
22:32:07 <wedens> is it possible to statically link with C library when building, and dynamically in GHCI?
22:33:03 <EvanR> yes
22:33:45 <EvanR> not sure about ghci though
22:34:03 <mjrosenb> kadoban: what EvanR said.
22:35:30 <kadoban> mjrosenb: Oh, yeah sure you can export type synonyms.
22:36:16 <mjrosenb> so, I have data GlobalState m = GlobalState { users :: m Users, uiState :: m UIstate }; I want to export GlobalState Behavior such that I can pattern match on it, and whatnot, but not so that you can instantiate m with anything else.
22:36:36 <average> https://twitter.com/skore_de/status/692088410387914753
22:36:50 <average> ^^ why doesn't someone make an entire book like that for me ?
22:37:09 <cocreature> probably because it’s a lot of work?
22:37:35 <EvanR> make a type synonym
22:38:21 <EvanR> i want one of those diagrams for scala
22:38:36 <ssuio> lambda
22:38:45 <cocreature> calculus
22:39:24 <average> cocreature: or maybe.. lambda caucus
22:39:48 <average> perhaps.. lambada caucus 
22:40:18 <average> I still somehow feel like I don't want to learn Haskell
22:41:48 <liste> shouldn't that diagram have "zero or more of the one kind of thing"
22:43:15 <average> liste: I think that's discussed in the replies/comments of that tweet
22:43:17 <cocreature> liste: yeah I think someone mentioned that in the replies
22:44:03 <shanemikel> I love this.. every time I'm here, somebody wanders in trying to be convinced to learn haskell, but they always seem to have made their minds up one way or the other already
22:44:42 <shanemikel> You do want to learn haskell, average
22:45:23 <mjrosenb> interesting, I have no clue why that works, but at the moment, I'm not going to ask questions.
22:48:23 <average> shanemikel: ever since I've heard about Haskell, it always was like "oh this is really cool, but wait.. I'd be better off doing X"
22:48:36 <EvanR> false
22:48:47 <average> or "oh this is really cool.. but wait.. why do I need to go so deep just to do simple things"
22:49:20 <shanemikel> the answer is, it depends.. depends on what kind of things you want to build, what your education level is, what kind of position your're looking to take, and what kind of company
22:49:34 <EvanR> either you dont actually (randomIO) or the way its simply done in e.x. PHP is just broken
22:49:52 <average> it's sort of a indecision between what looks cool and what value do I get out of this and how much time do I have to invest in this
22:49:58 <shanemikel> but the biggest question is, what problem are you trying to solve?
22:50:22 <average> shanemikel: http://blog.garage-coding.com/
22:50:31 <average> shanemikel: that's the sort of stuff I'm messing with
22:51:07 <average> about what you said above "what kind of position your're looking to take, and what kind of company"
22:51:12 <liste> well, most things in software aren't simple, and the non-simple things are where Haskell shines
22:52:27 <average> I think my time investment would be so big if I was to learn Haskell.. that by the time I would get real-world experience with it and have Haskell as an employable skill.. I would have not only cornered myself in a very narrow niche job market and would've also expended an ungodly amount of effort learning the language
22:52:53 <mjrosenb> is type Id x = x already defined anywhere?
22:53:15 <average> not to mention the risk associated with that
22:53:16 <shachaf> There's a newtype, but I don't think there's a type in a standard library.
22:54:00 <adam___> average: the skills you learn learning Haskell are applicable in every new language you work with
22:54:21 <adam___> even if you dont end up using Haskell at your specific job you will be happy that you are able to think about solving problems in a different way
22:54:28 <average> adam___: but are they really applicable ?
22:54:34 <mjrosenb> oh, I can't use a synonym without an argument.
22:54:34 <mjrosenb> blas
22:54:41 <mjrosenb> newtype, it is.
22:54:46 <average> in any language you say ?
22:55:02 <adam___> average: absolutely
22:55:10 <average> such as a weakly typed dynamic language ... where all the benefits are kindof not there..
22:55:20 <average> and all the guarantees are out the window
22:55:23 <adam___> such as javascript?
22:55:28 <average> yes, like Javascript
22:55:37 <adam___> you could use tons of functional programming concepts in javascript
22:55:45 <montanonic> Deeeefintely like JavaScript
22:55:53 <adam___> its actually the only way to stay sane in that language
22:56:02 <montanonic> adam___: https://leanpub.com/javascriptallongesix/read
22:56:04 <shanemikel> average: http://ramdajs.com/0.19.1/docs/
22:56:08 <montanonic> ooops, sorry
22:56:15 <montanonic> I meant average: https://leanpub.com/javascriptallongesix/read
22:56:22 <adam___> function programming to me is about learning to make simple building blocks which you compose together to build more complicated functionality
22:56:32 <adam___> that is an invaluable tool
22:57:01 <montanonic> FP is a much more sane way of writing JavaScript than OOP-style
22:57:16 <average> jobs require you to know OOP
22:57:21 <adam___> not really
22:57:26 <adam___> you can use either style
22:57:31 <adam___> they require you to get the job done
22:57:43 <average> sure, you can use either style until you get fired for not adhering to coding style
22:57:47 <adam___> if you have the ability to write functions in your language of choice you are good to go
22:58:00 <average> and after you get fired, you can continue using FP
22:58:04 <adam___> what jobs "require" you to use OOP
22:58:09 <average> most afaik
22:58:14 <adam___> definitly not javascript as OOP doesnt even exist
22:58:15 <EvanR> average: so what, know OOP
22:58:21 <adam___> they use prototypical inheritance
22:58:27 <adam___> thats not true OOP
22:58:31 <average> EvanR: know OOP, but then how might I justify to myself the learning of Haskell
22:58:41 <shanemikel> again, it depends on what you are to your employer.. are you a tool to be micromanaged, a lego block in a cumbersome infrastructure, or are you an engineer
22:58:51 <montanonic> average: check out that book I sent and the ramdajs lib someone else linked
22:59:13 <adam___> average: it seems like you already have your mind made up, you are just looking for somebody to agree with you
22:59:21 <mjrosenb> average: it is fun.
22:59:37 <EvanR> average: youre asserting that you have like 5 skill points to spend among things and then youre fixed
22:59:42 <montanonic> FP has the great benefit of abstracting out many patterns that you'd write a manual loop for, and purity is a tremendous asset to large apps
22:59:47 <adam___> if you wont even give it one week to try it out and see if its for you than how can you say it is not worth learning
22:59:52 <EvanR> thats a bad attitude for jobs anyway
23:00:21 <shanemikel> I know my statements are a bit harsh, and there is some reality to working in with your companies paradigm, but what I mean to say is, the best job will be one where you are free to make technical decisions
23:00:23 <adam___> let me ask you this, when writing software professionaly where do the majority of your bugs come from
23:01:27 <average> that I suppose is a question for researchers who quantify bugs from bug/issue trackers
23:01:38 <average> and I think it varies with the language and the type of application written
23:01:45 <average> and the libraries used and the entire system being developed
23:01:52 <shanemikel> one day, if you're not their yet (and most of us don't start that way) you will want more command over your work, and if that day isn't today, you're probably not to blame, but when that day comes, you'll be glad you know the tools availiable
23:02:07 <adam___> but if you had say just from experience what do you struggle with when working on projects
23:02:28 <mjrosenb> gah, so, for my GlobalState m = ... above, is it possible to get GlobalState m to derive (Show, Read) only when m a can also derive Show, Read?
23:02:32 <adam___> do you ever have problems with keeping track of what value a variable currently has?
23:03:01 <adam___> you need to think about the order of execution and think about every redifinition of every variable
23:03:03 <average> adam___: I would hope that I don't have trouble with that since a variable is.. as the name says .. variable
23:03:08 <average> a constant is constant tho
23:03:17 <adam___> right, but do constants ever give you any grief?
23:03:22 <adam___> probably not
23:03:25 <average> I know you're hinting at pure functions
23:03:33 <adam___> most bugs come from dealing with things that are able to change over time
23:04:15 <mjrosenb> or type mismatches :-p
23:04:28 <average> 08:58 ( shanemikel) again, it depends on what you are to your employer.. are you a tool to be micromanaged, a lego block in a cumbersome infrastructure, or are you an engineer
23:04:29 <adam___> understanding how to limit the amount of mutable state in your software is the greatest benefit that functional programming can give you
23:04:46 <adam___> haskell specifically can grant you MUCH more than that
23:04:51 <average> shanemikel: that's basically the definition of a job. why else would you get paid for a job.. surely not to do what you like to do.
23:05:07 <average> shanemikel: you do what someone else wants you to do in order to receive compensation
23:05:19 <adam___> average: get the job done
23:05:26 <adam___> why does it have to be written in way x or way y
23:05:37 <adam___> nobody will complain if you write a function to accomplish something
23:05:39 <kadoban> average: If you're only doing it for a job, and you know enough to not get fired … there's no way to motivate you to learn anything. If you don't feel like learning something, don't I guess.
23:05:57 <shanemikel> average: since you mentioned javascript, you might be interested in reading about the recent explosion of transpiled languages to javascript, there is a number of them (many invented specifically for javascript, and many that transpile functional languages to javascript, including haskell and ocaml)
23:06:06 <average> adam___: yes but.. the question is .. get the job using Catamorphisms and Monoids or get the job done with objects/classes and methods and all the other OOP stuff ?
23:06:29 <shanemikel> this trend is widespread, and is certainly coming from a real need
23:06:41 <montanonic> <--- PureScript fanboy over here
23:07:02 <wedens> how can I tell cabal/stack to prefer .a instead of .so library?
23:07:15 <CoconutCrab> average: I think you can use both, Scala does that
23:07:21 <adam___> montanonic: how does that compare to using ghcjs
23:07:24 <wedens> I need .so for ghci, but I need statically linked binary
23:07:33 <average> shanemikel: I've seen Elm but I wonder how functional it really is and how well do js concepts translate to the resulted code of that transpiler
23:07:35 <shanemikel> average: sorry, I was pretty regretful once I sent that.. poorly worded at best (very evocative).. what I should have said is: I think we all hope one day we can amount to more than a subordinate
23:08:18 <shanemikel> and learning the various technologies, patterns, frameworks, paradigms, etc that comprise the modern software ecosystem are a huge step towards that direction
23:08:24 <average> well, I find it hard to believe that using Haskell would change someone's status in a company
23:08:37 <CoconutCrab> average: in my place it does :)
23:08:54 <dolio> I think that's about enough of this.
23:09:04 <montanonic> adam___: I strongly prefer it currently because of its modifications to make more sense in terms of JavaScript. Arrays by default, not lists. Strict evaluation by default. It also gets rid of some older vertiges of Haskell, such as fmap existing (it just has map, which is generalized)
23:09:10 <average> CoconutCrab: what is the reasoning for that in this magic fairyland place that you talk about ?
23:09:20 <montanonic> adam___: It's FFI is also very painless
23:09:23 <montanonic> its*
23:09:28 <davidar> average: just out of curiosity, do you think mathematics is relevant to programming?
23:09:32 <CoconutCrab> average: actually I am using Scala, but in mostly functional way, I showed other the benefits of strong type system and pure function
23:10:00 <average> davidar: sure, if I write a CAS or write mathematical software
23:10:07 <CoconutCrab> 'let the type aid you, don't fight the types'
23:10:16 <mjrosenb> so... if I have data Foo m = { a :: m Int }, is there any way I can get it to derive Show (Foo Maybe), but also be able to use Show (Foo IO)?
23:10:29 <adam___> average: why are so many js frameworks staring to use a more functional approach? React, Vue, Riot, Cycle, Mythril...
23:10:39 <average> but when the job is making some web app, or an SPA .. or doing something with a database.. that has a deadline, a schedule, a backlog of tasks etc ..
23:11:01 <adam___> montanonic: that sounds pretty nice actually
23:11:21 <CoconutCrab> average: it still works, in one day I can chunk out more usable code than my colleagues 
23:11:27 <adam___> montanonic: so are you just using a javascript framework? and if so why did you choose that over reflexdom
23:11:37 <CoconutCrab> since I spend less time writing unit tests, fixing runtime bugs etc..
23:11:38 <average> will I really show up in a standup meeting saying "My catamorphism's types do not match with the monoid subtype that I've devised and I might have to use a Semi-Group instead"
23:11:43 <montanonic> average: or how, to avoid the fuckery of global variables, people use anonymous functions and create closures in JavaScript; which is functional style
23:11:55 <average> and who would even listen to my babble if I would say such things in a standup meeting..
23:12:19 <EvanR> just put it in a powerpoint with a rising graph of profits and they wont care
23:12:25 <CoconutCrab> now I am not sure if you are serious or not, most people don't need to know about those to reap the benefits of Haskell
23:12:27 <montanonic> no one would ever say anything like you said
23:12:59 <dolio> Can you go try to convince people that it's okay for you to not learn Haskell elsewhere? It's off-topic noise here.
23:13:01 <CoconutCrab> it's like telling everyone should learn C++ because it has meta template programming 
23:13:05 <average> CoconutCrab: software in the real world is developed in bite-sized chunks with very regular status reports
23:13:18 <average> and with regular code reviews
23:13:19 <average> and teams
23:13:20 <CoconutCrab> average: same here, we are a Japanese company
23:13:23 <average> and all that..
23:13:23 <adam___> average: its like addition, you can use it just fine without knowing the laws it follows and you dont need to tell anybody about it
23:13:37 <CoconutCrab> my colleagues had some problems at first, but now they have catched up
23:13:41 <shanemikel> actually, I read something tonight that puts this discussion into perspective.  I was looking into books on distributed architectures, and a reviewer commented something along the lines of "Software architecture is, relative to the other engineering disciplines, still in a Pre-industrial state.. learning usually comes through apprenticeship"
23:13:46 <adam___> average: knowing that it follows associativity, commutivity, etc is helpfull as it allows you to do new things
23:13:46 <montanonic> adam___: I'm actually teaching myself JS from the ground up right now using the book I linked to average a bit ago (it's a *really* good book, teaches functional programming using JavaScript and uses its latest features), and then I'm using PureScripts FFI to practice rewriting the javascript I've learned into well-typed libraries
23:14:07 <jhrcek> How do I get this behavior of Maybe? Just 1 <somefunction> Nothing == Nothing? I got a list of maybe values and I want to concatenate them so that the result is Nothing <-> there is any Nothing in the list
23:14:22 <montanonic> adam___: but, aside from this endeavor, I've been using PureScript's Halogen, and aside from having some gnarly, long type names, it's very very sensible, and very powerful
23:14:42 <average> I may agree to reading that book montanonic 
23:15:00 <average> but I am not quite sure that I can actually use Haskell in a workplace
23:15:02 <montanonic> adam___: and I haven't seen a framework that makes as much sense as it does, or is as composable; I have *not* used reflexdom however
23:15:02 <adam___> montanonic: any good support for mobile? 
23:15:03 <shanemikel> dolio: sorry man.. I can't help but engage these people
23:15:18 <Axman6> > sequence [Just 1, Just 2, Just 3]
23:15:20 <lambdabot>  Just [1,2,3]
23:15:23 <montanonic> adam___: that I don't have an answer to, sorry
23:15:29 <CoconutCrab> average: I think it will be hard
23:15:37 <average> I think the probability of getting fired or running over-budget would be so high, simply because Haskell is not an easy language
23:15:38 <CoconutCrab> average: to use Haskell for work
23:15:39 <montanonic> adam___: the PureScript community is *very* active, and the languages creator uses it in production
23:15:41 <Axman6> > sequence [Just 1, Just 2, Just 3, Nothing -- jhrcek]
23:15:43 <lambdabot>  <hint>:1:53:
23:15:43 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:15:50 <Axman6> > sequence [Just 1, Just 2, Just 3, Nothing] -- jhrcek]
23:15:52 <jhrcek> Axman6, cool, that's what I wanted. Thank you
23:15:52 <lambdabot>  Nothing
23:15:53 <montanonic> adam___: so it's definitely worth checking out; come join #purescript
23:16:03 <adam___> montanonic: I might have to do that :P
23:16:08 <average> and, if you willfuly would leave, imagine what sort of discussions would happen after you're not there, such as "this prick used this stupid language that we don't know"
23:16:08 <montanonic> adam___: SlamData coders use it, you can look up their company
23:16:30 <adam___> montanonic: I will try both definitely try both ghcjs and purescript and see how the workflow is
23:16:32 <EvanR> sounds like a nice bunch to be working with
23:16:33 <montanonic> average: awesome, I'm sure you'd like the book; I think it'd probably be a better use of your time than Haskell for now, based upon what's being said
23:17:03 <mjrosenb> sooo... is it possible to derive show in this instance? I feel like I should be able to, as long as I dont' instantiate it.
23:17:17 <adam___> montanonic: I actually need to make an app that can work across both web and mobile, as well as interact with the actual hardware on the phone (bluetooth, gps) so I dont know how to best approach it
23:17:34 <adam___> montanonic: is it fairly straightforward to work with existing js libraries?
23:17:39 <mjrosenb> I could also give this /other/ type an instantiation of Show and read, which are just undefined.
23:18:02 <adam___> because cycle/react both have a "native" version that allows you to make ios/android apps and its all done using javascript
23:18:14 <adam___> so if i can target javascript then im golden
23:18:16 <montanonic> adam___: https://leanpub.com/purescript/read go ahead and check the FFI section
23:18:22 <montanonic> adam___: to see some actual code
23:19:09 <shanemikel> not really, any company that regularly deals with software and isn't tiny will employ at least a handful that have experience with functional languages, and haskell has a lot in common with the other important ones
23:19:09 <average> also, using a transpiler, adds another level of abstraction, I can't tell if that's good or bad
23:19:16 <montanonic> adam___: the answer though, is yes; the caveat is that the libraries your interfacing with, given their lack of type safety, may lead to unsuspected bugs
23:19:19 <shanemikel> it's bad.. but it's still better than js
23:19:26 <montanonic> adam___: so the fault is still JavaScript, not PureScript :)
23:19:38 <average> it may be good because you can avoid common types of bugs as I understand from people who've talked about that in this channel
23:19:42 <adam___> montanonic: haha yeah I guess thats too be expected
23:20:09 <adam___> montanonic: it looks fairly painless though, you can just require your modules with a require
23:20:30 <average> but on the other hand, you have to learn another language, when you debug.. you need a debugger now because you're using a transpiler.. and then you need something special to map the lines from the initial source code to the resulted one
23:20:42 <Axman6> so, what's the current state of the art in dealing with errors? I'm working with a library which uses IO (Either LibError a) a lot, so I'
23:20:45 <adam___> so is purescript a full haskell compiler or is it a subset
23:20:54 <average> and now you need to write code in a fundamentally different way
23:21:01 <Axman6> I've tried ExceptT, but I can't remember if there's a more preferable method these days
23:21:13 <montanonic> adam___: exactly, PS compiles into CommonJS fanciness, and it can also output Browerified
23:21:22 <montanonic> Browserified*
23:21:27 <adam___> Axman6: idk, I thought monad transformers are for exactly that 
23:21:31 <EvanR> average: all the energy being wasted explaining this stuff in here could be better used doing haskell exercises
23:21:46 <Axman6> adam___: sure, but which one =)
23:21:53 <average> EvanR: which would lead to what outcome ?
23:22:03 <EvanR> less bitching
23:22:07 <adam___> lol
23:22:16 <montanonic> average: I think just studying functional style *in* JavaScript will be the best way to go; no need for transpilers, and if you see the advantages, it will be easier to convince others
23:22:20 <adam___> average: we dont mean to come acros as crass
23:22:37 <EvanR> no i was trying to be crass
23:22:38 <shanemikel> no, the biggest problem with js transpiled languages is that you need to know two langs.. you still need to know js, and you need to learn the language you're writing obviously.. this problem is compounded by the fact that there are many languages (even many functional) contending for the position, and moving between those (which may be mere dialects of haskell) and haskell itself may not be much better than knowing the faults 
23:22:39 <adam___> but its just you come in here with an attitude that clearly shows you have no interest in learning this language
23:22:40 <shanemikel> of js
23:22:58 <adam___> I feel like after all this the conversation has not moved in any direction
23:23:03 <adam___> if you want to learn it then learn it
23:23:07 <adam___> otherwise thats fine too
23:23:21 <adam___> either way choose one and try not to just repeat the same thing over and over
23:23:23 <EvanR> shanemikel: thats a lot of systems now, frameworks for php / js, clojure/scala/java, f#/c#
23:23:59 <adam___> Axman6: not sure sorry
23:24:01 <EvanR> might as well just stop worrying and use two languages, since ultimately youll probably be using a lot more than two anyway
23:24:38 <montanonic> My vote is still just to start with learning functional style in JavaScript
23:24:46 <average> CoconutCrab: so what sort of code do you develop there in japan ?
23:24:59 <montanonic> If you find it intriguing, you'll motivate yourself to take the next step into a language with higher-level features
23:25:01 <EvanR> montanonic: which can be pretty bad and annoy people
23:25:14 <EvanR> though i do it ;)
23:25:28 <CoconutCrab> average: in house projects
23:25:30 <adam___> EvanR: the thing is its less of a commitment and allows you to get your feet wet
23:25:38 <CoconutCrab> ads related 
23:26:16 <montanonic> JavaScript's ES6 syntax allows for writing stuff like: (x => y => x)
23:26:19 <montanonic> which is const
23:26:26 <montanonic> so it's definitely less bad now
23:26:33 <shanemikel> EvanR: but it's never just two languages
23:26:47 <montanonic> (x => y => x)(3)(4) = 3
23:27:18 <montanonic> currying + closure + lambdas
23:27:28 <CoconutCrab> IMO javascript ecosystem is a mess, it moves too fast
23:27:35 <shanemikel> EvanR: don't you have issues confusing hs syntax/operators with purescript?
23:27:46 <montanonic> I don't
23:27:55 <shanemikel> CoconutCrab: and yet, not fast enough
23:27:59 <montanonic> PS is different in very few ways
23:28:04 <montanonic> syntactically 
23:28:15 <EvanR> shanemikel: operators of what
23:28:18 <CoconutCrab> shanemikel: not fast enough in the 'right' direction (or is there any?)
23:28:24 <CoconutCrab> :)
23:29:04 <adam___> montanonic: thats the one thing I dislike about Purescrit/Elm. Its not exactly haskell
23:29:06 <EvanR> shanemikel: oh haskell, no they are basically the same langauge
23:29:18 <adam___> so if ghcjs seems to be a 1 to 1 replica
23:29:20 <adam___> why not use that?
23:29:27 <adam___> share your code between client and server
23:29:28 <EvanR> its like knowing what library you are using
23:29:44 <montanonic> adam___: 100% serious, I think PS improves upon Haskell in some ways; not just in terms of JS interop, but just straight up
23:30:15 <montanonic> adam___: row polymorphism means that you can be completely explicit about what *types* of effects happen within IO
23:30:28 <adam___> interesting
23:30:38 <montanonic> adam___: Eff (console :: CONSOLE, dom :: DOM) Unit
23:30:46 <montanonic> adam___: in PS, IO is Eff
23:30:58 <montanonic> adam___: that Eff will cause effects in the console and changes in the DOM
23:31:09 <adam___> interesting
23:31:51 <montanonic> adam___: full type safety; they even have a library for generating HTML that throws type errors when you try to put properties that a particular tag doesn't support inside of it
23:32:11 <Axman6> that's pretty badass
23:32:15 <montanonic> adam___: Halogen.HTML.Indexed
23:32:47 <adam___> halogen is the ui framework for purescript right?
23:32:57 <adam___> does it handle events using an frp system?
23:33:04 <montanonic> adam___: it is; they also have thermite, which is a high-level library for Facebook's React
23:33:19 <montanonic> adam___: not anymore; it used to, they adjusted the model to what they felt made more sense
23:33:20 <average> davidar: so what was your answer to that question ?
23:33:23 <average> 09:09 ( davidar) average: just out of curiosity, do you think mathematics is relevant to programming?
23:33:26 <montanonic> adam___: they have an FRP library though
23:33:39 <average> CoconutCrab: so if you're doing things with ads, why not just use Python or Ruby ?
23:33:44 <adam___> thermite, does that only work with react web version?
23:33:48 <montanonic> adam___: http://paf31.github.io/try-thermite/
23:33:55 <montanonic> adam___: not sure; there's a tutorial of it
23:34:18 <average> CoconutCrab: if it's something related to analytics .. Python or R for example have much more developed stats packages available than Haskell has
23:34:38 <average> CoconutCrab: how is Haskell the best choice for your work ?
23:34:56 <adam___> montanonic: does purescript have any sort of live reload
23:34:58 <davidar> average: I would argue that mathematics is just as relevant to programming as it is to mechanical engineering
23:35:28 <adam___> all programming is essentially one giant math problem lol
23:35:28 <davidar> not because you're working on mathematical problems, but because it provides a structure to support the correctness of your work
23:35:29 <montanonic> adam___: it has auto-recompile on changes with a server, not sure if that's what you mean
23:35:46 <CoconutCrab> average: because I am bad at investigating runtime bug, so I picks something that I can reason while writing it
23:35:51 <average> CoconutCrab: unless you hold an important position in the company or have close ties to the business owner, I'm very skeptical one could sell Haskell as the language du jour in a company ..
23:36:01 <adam___> montanonic: when you save your file will it auto compile the file to js and reload your browser so you see the changes automatically
23:36:04 <CoconutCrab> I pick*
23:36:16 <average> CoconutCrab: do you own the company ?
23:36:18 <montanonic> adam___: pulp is its build tool, `pulp server` compiles and sends your JS through a server; you just need to add an index.html file in your top-level directory that links app.js
23:36:20 <EvanR> clearly you probably cant convert an existing company completely to haskell
23:36:26 <adam___> ok how are we still on this topic
23:36:29 <CoconutCrab> average: no, I am just a lowly developer
23:36:45 <adam___> nothing has changed
23:37:00 <average> CoconutCrab: so how were you able to sell Haskell from that position ?
23:37:07 <adam___> a: I dont think I should learn haskell because reason a
23:37:11 <adam___> b: then dont
23:37:13 <montanonic> adam___: I think it auto-refreshes
23:37:14 <EvanR> did you do some haskell exercises and are taking a break?
23:37:16 <shanemikel> average: does your school have classes in functional lanugages?
23:37:25 <adam___> if you want to learn it do it
23:37:32 <CoconutCrab> average: that sounds like it should be discussed in -blah, not here :)
23:37:35 <adam___> otherwise why keep looking for excuses to not learn it
23:37:40 <average> adam___: please don't get so upset.. me talking about this is of much higher value then us talking about monoids.
23:37:44 <average> let me break it down to you this way
23:37:57 <average> "Money-Monoid vs. No-Money-Monoid"
23:37:58 <adam___> please explain to me how this is a constructive conversation
23:38:04 <CoconutCrab> I must now digress
23:38:05 <CoconutCrab> :)
23:38:06 <average> that's my explanation right there ^^
23:38:08 <EvanR> actually id rather talk about monoids
23:38:12 <adam___> ^
23:38:24 <average> EvanR: which kind of monoid is that ? a money-monoid or a no-money-monoid ?
23:38:31 <adam___> average: if you are only programming to make money go write javascript
23:38:36 <adam___> stop worrying about it
23:38:45 <EvanR> money, glory, babes, drugs, whatever you want
23:38:47 <adam___> if you want to learn something becuse you want to get better at your craft
23:38:51 <shanemikel> if you're not motivated to do it based upon your own research and goals, then a logical next step would be to reach out to a professor of functional languages in your school
23:39:00 <adam___> then worry about haskell
23:39:10 <montanonic> adam___: actually, I was wrong, no auto-refresh browser, but yes auto-recompile
23:39:27 <shanemikel> or to decide it's not for you ATM and return to the consideration (or not) at a later time
23:39:27 <average> adam___: I think you have a poor understanding of the world if you're throwing "go write js"  at me
23:39:49 * CoconutCrab goes back to lurking
23:39:50 <montanonic> this convo is like 40% mutual troll-bait, can we not
23:39:54 <adam___> montanonic: ok, well it sounds like it could be an interesting project to try to make something that works that way
23:40:02 <average> montanonic: i'm done
23:40:35 <montanonic> adam___: yeah I def recommend joining the IRC chan and reading through the PureScript book
23:40:39 <shanemikel> funny stuff
23:40:55 <adam___> if you guys have ever worked with clojure and figwheel, the ability to live reload your code and keep the state of the program is life changing
23:41:09 <adam___> I really want to see if its possible to do something like that with haskell
23:41:20 <EvanR> s/the ability/the basically only way to do it/
23:41:26 <EvanR> because of clojure reload times
23:41:36 <adam___> lol fair enough
23:41:43 <adam___> you have to admit it is amazing though
23:41:46 <montanonic> there was a video about FP and how category theory was discovered rather than invented
23:41:54 <montanonic> anyone know what I'm talking about? I'm trying to find it
23:41:58 <shanemikel> is that in erlang too?
23:41:59 <liste>  
23:42:34 <montanonic> I think it's thesis is basically: discovered things are fundamentally better than invented ones when it comes to language design; math is good
23:42:43 <EvanR> adam___: well its just a consequence of the very dynamic runtime which you are exposed to. other systems made it more convenient to do something like that
23:42:56 <EvanR> its more like a design pattern in clojure
23:43:28 <montanonic> adam___: how do you like Clojure compared to Haskell?
23:43:42 <EvanR> GHC has some code reloading shenanigas
23:43:51 <adam___> idk I think both are very interesting
23:43:52 <average> adam___: listen, i understand.. you're a Haskell artist/artisan/painter/musician
23:43:54 <average> that's fine..
23:43:54 <EvanR> not sure how robust
23:43:58 <montanonic> adam___: I feel converted by the type system, but I still think lisps are cool
23:44:04 <kadoban> average: You said you were done.
23:44:08 <montanonic> ^^
23:44:13 <adam___> montanonic: I learned it as an excuse to learn lisp
23:44:24 <montanonic> adam___: haha, good one :)
23:44:38 <EvanR> a haskell genius, billionaire, playboy, philanthropist
23:44:41 <adam___> but they have some really profoundly good ideas
23:44:51 <montanonic> adam___: great data type design
23:45:06 <adam___> since code is data and data is code, the macros you can write are powerful
23:45:18 <adam___> that being said, I am not a huge fan of dynamically typed languages
23:45:21 <adam___> I get the appeal
23:45:30 <average> kadoban: I'm interested in using Haskell strictly for business
23:45:37 <EvanR> adam___: i disagree with that feature... heavily untyped AST munging at runtime seems insane
23:45:42 <average> not art or "passion" (whatever that is)
23:45:45 <average> I find nothing wrong with that
23:45:51 <EvanR> not to mention confusing
23:45:54 <montanonic> I think I might need to just try it out. I'm pretty solid on static typing, but I think it would be fun to try clojure at some point, if nothing but to be able to target the JVM
23:45:57 <adam___> Haskells types just makes code almost write itself in most situtations
23:46:30 <adam___> montanonic: i highly encourage it. I would learn it JUST to experience figwheel and try OM Next
23:46:38 <mjrosenb> ok, it looks like StandaloneDeriving is what I need
23:46:48 <kadoban> average: You're interested in restarting the useless conversation from hell again? Wonderful, can't wait to not be here for it.
23:46:54 <fr33domlover> Hello! I'm trying to parsr JSON with aeson and I need the string literals as ByteString, but there is no instance FromJSON ByteString. Why is that?
23:47:01 <adam___> the ideas that david nolen has about stm, and communication between the server and client is really interesting
23:47:06 <fr33domlover> Do I have to parse as Text and encode?
23:47:13 <adam___> it is similar to relay/graphgl
23:47:17 <mjrosenb> but now it looks like I also need FlexibleContexts and UndecidableInstances.  I feel like I should not need both of these to do what I want.
23:47:32 <dolio> average: I think it was a good idea to be done with your previous 1 hour conversation.
23:47:35 <dolio> Or have it elsewhere.
23:47:37 <EvanR> fr33domlover: json strings are text data, not binary
23:47:37 <adam___> and the datomic database is amazing
23:47:52 <EvanR> fr33domlover: json doesnt directly support binary data, so you need to use some encoding mechanism
23:47:52 <montanonic> adam___: are all of those from clojure?
23:47:55 <adam___> a purely immutable database
23:48:04 <EvanR> fr33domlover: as an example check out base32k
23:48:11 <adam___> montanoic: relay/graph gl is made by facebook to work with js
23:48:17 <fr33domlover> EvanR, I know but some packages take strings as ByteString for speed and parse that, e.g. 'irc'
23:48:24 <adam___> its a alternative, idk if "alternative" is the right work
23:48:25 <montanonic> adam___: I though Haskell had concurrency on lockdown; can clojure compete?
23:48:30 <montanonic> thought*
23:48:34 <montanonic> actually, retract that
23:48:37 <montanonic> I don't want to language war
23:48:39 <EvanR> fr33domlover: they arent text strings though, youre thinking about binary data parsing
23:48:43 <adam___> but it helps aleviate the pain of restful api
23:49:13 <montanonic> that sounds very cool
23:49:13 <adam___> montanoic: to be honest I'm not a good enough at both to make such a bold statement
23:49:13 <fr33domlover> EvanR, IRC nicknames are ASCII text and still IRC packages have newtype Nickname = Nickname ByteString etc.
23:49:14 <EvanR> fr33domlover: its important to draw a distinction between text and binary byte arrays
23:49:25 <montanonic> adam___: fair point :)
23:49:38 <adam___> I think that it could be nice to learn both just for the difference in mind set
23:49:43 <EvanR> fr33domlover: well thats a unsafe hack, strictly speaking, and they should have used an ascii type
23:49:51 <adam___> both are really well designed but for very different reasons
23:50:00 <mjrosenb> yeaaaah.... this is almost certainly the wrong path.
23:50:26 <montanonic> adam___: good stuff; any preferred resources for learning it?
23:50:28 <montanonic> adam___: books?
23:50:59 <montanonic> adam___: I don't think I'll be getting to it until I get absolutely sick of what I'm learning now, but it will be innevitable that that happens
23:51:25 <mjrosenb> so, with data Foo m { a :: m A, b :: m B }, is there any context under which I can derive a Show instance of (Foo Maybe)?
23:51:25 <fr33domlover> EvanR, then I suppose I'll have to take the Text and encode as UTF-8 into a strict ByteString :P i need to parse a URL from bytestring...
23:51:26 <shanemikel> speaking of lisp.. It's clearly an inexpensive option of guest language in a plugin architecture.. are there any abstract hs libs for plugin architectures? what should I read on this, and is there a lisp parser/interpreter implemented in hs?
23:51:51 <adam___> montanonic: if you have 10 minutes check this out http://clojurescriptkoans.com/
23:51:59 <EvanR> fr33domlover: that makes more sense anyway, since the url are text and might contain unicode
23:52:06 <adam___> its all online so you dont need any setup
23:52:35 <EvanR> almost nothing on the internet is strictly ascii
23:52:36 <portu> Hello) I am newbie, can I ask a question here, which doesn't relate with haskell, but with functional programming and another programming language?
23:52:48 <adam___> portu: go for it
23:53:01 <montanonic> adam___: awesome, I will; ty
23:53:09 <EvanR> fr33domlover: you should make a FromJSON instance for this URL
23:53:10 <montanonic> adam___: also, nice chatting; going to pop back into work; ttyl
23:53:19 <adam___> sounds good peace :)
23:54:19 <EvanR> shanemikel: theres probably a million lisps in haskell, and yeah i was just mentioning / thinking about a plugin lib for haskell
23:54:22 * hackagebot EdisonCore 1.3.1.1 - A library of efficent, purely-functional data structures (Core Implementations)  https://hackage.haskell.org/package/EdisonCore-1.3.1.1 (RobertDockins)
23:54:49 <fr33domlover> EvanR, is it a good idea to do that inside a library though? it means anyone else writing such an instance and using my library will get a conflict
23:55:08 <EvanR> shanemikel: maybe this https://hackage.haskell.org/package/plugins-1.5.5.0
23:55:25 <portu> Can anybody recommend any project/course/book which can help to learn python and its functional features? I understand that this language support only part of FP paradigm
23:56:11 <EvanR> fr33domlover: it seems silly to avoid using this method because someone else might do it... but if youre worried about it you can use newtypes
23:56:18 <fr33domlover> portu, i know very little python but i think if you want FP, python isn't the answer...
23:56:22 <EvanR> more practically, let them use newtypes
23:56:26 <EvanR> or let them use your code
23:56:44 <Hafydd> portu: <https://docs.python.org/3/reference>, <https://docs.python.org/3/library/functions.html> and <https://docs.python.org/3/library/functools.html>.
23:57:20 <EvanR> fr33domlover: the whole point of these classes is so you dont have to do a second and third pass munging json data
23:57:28 <fr33domlover> EvanR, hmmm good point. I can use newtype if my instance isn't the generally correct one
23:57:55 <fr33domlover> EvanR, either way i'm doing the URL parsing inside FromJSON
23:57:57 <EvanR> how hard can it be to read a json string as a ByteString then parse it using the particular url lib?
23:58:03 <fr33domlover> whether it's for URL or another type..
23:58:06 <Hafydd> portu: (and <https://docs.python.org/3/library/itertools.html>.)
23:58:16 <EvanR> i mean how many ways are there
23:58:36 <fr33domlover> EvanR, the question isn't whether it's hard, but - yeah, whether there's a single way to do it :) i'll write the code and see
