00:00:07 <bollu> suppi: cuch. I just wanted to print my DSL
00:00:14 <jle`> switched to new coding style where multi-line type signatures start on the line after the name of the function/value
00:00:16 <bollu> phaazon: that's young? >_< I'm 19 and I feel "old"
00:00:19 <jle`> i mean, formatting style
00:00:20 <jle`> feels good
00:00:39 <jle`> this will be the start of something beautiful
00:00:44 <suppi> bollu, you can create a custom show
00:00:47 <phaazon> bollu: well, 19 is like a tadpole :D
00:01:06 <suppi> why do you feel old?
00:01:09 <phaazon> bollu: whatâ€™s your nationality?
00:01:24 <bollu> phaazon: Indian :)
00:01:34 <phaazon> I feel that very interesting that smileys â€“ especially weird ones like >_< â€“ go across nations
00:01:35 <bollu> suppi: I dunno. I'd like to believe I'm "mature"
00:01:46 <suppi> mature and old are not the same :P
00:01:52 <bollu> suppi: :P fair
00:01:54 <phaazon> @tell rvxi we need to talk pal. :D
00:01:54 <lambdabot> Consider it noted.
00:02:10 <bollu> suppi: I dunno, I feel like I've seen my fair share of life's horrors or something.
00:02:18 <HACKRILEGE> The object I have been trying to derive is the FREE BIMONAD?
00:02:20 <bollu> suppi: which makes me feel old and cynical
00:02:32 <jle`> radens: you can convert them to integers, add the integers, and convert them back
00:02:36 <orion> What are the pros/cons of using a list to represent EDSL instructions as opposed to using the Free Monad other than do-notation?
00:02:52 <jle`> but writing toNat/fromNat would probably be implemented recursively
00:03:01 <jle`> orion: you can use do notation with lists too, by abusing writer
00:03:13 <bollu> orion: sequencing apparently
00:03:42 <bollu> also, the more I play around with this structure the more it's starting to make sense. Haskell is awesome :D
00:03:56 <phaazon> bollu: btw, IÂ reckon thereâ€™re several kinds of maturity
00:04:06 <jle`> orion: you're asking a bit of a wrong question.  if sequencing it as a list is fine, then you don't need a monad interface
00:04:18 <jle`> you're asking if you want to give it a monad interface ... not if you want to use Free
00:04:21 <bollu> phaazon: how so?
00:04:27 <orion> When would a list not be fine?
00:04:28 <phaazon> I think no one is mature on all levels
00:04:30 <HACKRILEGE> I can find no mentions of such an object
00:04:35 <phaazon> we get more and more as we live
00:04:46 <jle`> yes, a list would be fine, and if you want to use do notation, you can just use Writer [Instructions] ()
00:04:56 <jle`> type Program = Writer [Commands] ()
00:04:59 <phaazon> bollu: philosophy maturity, love maturity, sex maturity, educational maturity, food maturity, etc.
00:05:06 <bollu> phaazon: ah, right, fair
00:05:10 <phaazon> I donâ€™t think thereâ€™s a global maturity thing
00:05:16 <phaazon> but we could discuss that on #haskell-blah
00:05:21 <bollu> phaazon: so, multiple basis vectors for maturity? :)
00:05:47 <HACKRILEGE> I shall return with the Free BiMonad.
00:05:48 <phaazon> yeah, the vector space of maturity has a very large canonical base ;)
00:06:11 <bollu> HACKRILEGE: what are the laws for Bimonad?
00:06:50 <orion> jle`: I meant to ask, under what circumstances would you definitely want to use a monad?
00:07:17 <jle`> orion: if your actions produce values as results, monad would be useful
00:07:29 <phaazon> yeah like Maybe
00:07:30 <phaazon> :D
00:07:41 <jle`> right now if you just are happy with a list of [Action], none of your actions produce a result
00:07:44 <HACKRILEGE> Associative identity of two return functions under kliesle composition
00:08:11 <jle`> Monad would give you something like `Action a -> (a -> Action b) -> Action b`
00:08:36 <jle`> "i have an action that produces an a, and a function from an a to an action that produces a b...i can combine/sequence those to create an action that produces a b
00:08:56 <HACKRILEGE> http://stackoverflow.com/questions/13556314/biapplicative-and-bimonad
00:08:56 <jle`> but whether or not this is useful depends on the specific situation...
00:09:15 <jle`> right now if you're perfectly fine with just [Action]...we have to know more about the problem to see if Monad would help, heh
00:09:35 <orion> jle`: Is [Action] basically an applicative, or is it even less powerful than that?
00:09:42 <jle`> it's a Monoid
00:09:49 <jle`> and that's the "power" you have
00:09:56 <jle`> which is pretty awesome already
00:10:15 <jle`> you get the no-op action for free -- []
00:10:17 <bollu> jle`: monoid is.. pretty weak no? :P
00:10:23 <jle`> monoids are awesome :O
00:10:30 <jle`> @google functional pearls monoid
00:10:32 <lambdabot> http://repository.upenn.edu/cis_papers/762/
00:10:32 <lambdabot> Title: "Monoids: Theme and Variations (Functional Pearl)" by Brent A. Yorgey
00:11:17 <jle`> but we have to know more about your specific application i think to see what Monad would add
00:11:52 <orion> jle`: I'm writing an EDSL to capture network operations as part of a cryptographic handshake protocol.
00:11:53 <jle`> if your computation is a monoid you can already use do notation
00:12:04 <ReinH> orion: no, all endomorphisms are not identity morphisms
00:12:50 <ReinH> (+1) is an endommorphism
00:13:02 <bollu> jle`: Oh yes, I was shown this paper by the diagrams people :)
00:13:14 <HACKRILEGE> Either that or through it's use of Free it has infinite degree
00:13:18 <jle`> can we see what you have already>
00:13:20 <jle`> ?
00:13:29 <orion> jle`: haha, it's 100% terrible code.
00:13:51 <jle`> if you're happy with a monoidal interface and it works fine then that's coo too
00:14:25 <orion> jle`: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/MessagePatterns.hs#L149-L174 <-- one example
00:14:26 <jle`> the description you gave is what the edsl is "for", so there are a bunch of ways to approach it.  if you just want to improve what you have already, we need to see that that is, heh
00:14:55 <orion> Currently there is no EDSL. The implementation is not separate from the description.
00:15:06 <radens> jle`: thanks, that sort of conversion is annoying but reasonable I guess
00:15:13 <phaazon> 09:19 < bollu> jle`: monoid is.. pretty weak no? :P
00:15:30 <phaazon> I think monoid and semigroup are ones of the most typeclasses that IÂ use in my code
00:15:36 <phaazon> along with Functor and Applicative
00:16:02 <bollu> phaazon: no, I meant, like, "weak" in the sense of "theorems" not "weak" in the sense of "useful". Group theory has so many theorems. I don't know any about monoids
00:16:18 <HACKRILEGE> Basically Monad m => Free m a is a monad in two directions. So the free Bimonad seems alluring, but I think it looks dubious
00:16:26 <orion> ReinH: "an endomorphism is a morphism (or homomorphism) from a mathematical object to itself." <-- that description leads me to believe that the identity morphisms can be included, because they point from objects to themselves.
00:16:32 <phaazon> those are not really theorems, IÂ guess
00:16:36 <phaazon> theyâ€™re laws
00:16:50 <jle`> orion: the general pattern where you think a monad (or even a Functor or Applicative interface) would be useful, for computations/dsl's, is if your dsl's consist of actions that produce results
00:16:56 <jle`> things of type `Action a`
00:17:21 <jle`> Functor lets you apply functions to the results of your actions, (a -> b) -> Action a -> Action b
00:17:28 <ReinH> orion: that is true
00:17:28 <phaazon> I like to reason in terms of types instead of trying to force a concrete use of it
00:17:30 <jle`> Applicative lets you sequence and merge your actions
00:17:32 <orion> jle`: Does 'a' refer to the "next" action?
00:17:33 <ReinH> identity morphisms are endomorphisms
00:17:42 <jle`> orion: `a` refers to the type of the result of the action
00:17:45 <ReinH> orion: but that's not what you asked me
00:17:47 <bollu> can I implement  branching given a free DSL?
00:17:51 <bollu> if-then-else style
00:17:54 <orion> ReinH: True.
00:17:59 <jle`> so, a `Parser Int` is a parser that parses an Int
00:18:06 <jle`> an `IO String` is an IO action that produces a String
00:18:28 <jle`> Applicative gives you the basic ability to "sequence" lists/pairs of actions
00:18:46 <bollu> jle`: but the final term of the DSL always has type Free DSL a
00:18:55 <bollu> "Done" / whayever you want to call it
00:19:00 <bollu> how do you interpret that?
00:19:04 <phaazon> Pure*
00:19:11 <jle`> i'm not sure if we're talking about the same thing
00:19:28 <bollu> jle`: like so: https://gist.github.com/bollu/f5a8e4c779a1e039d80b#file-free-monads-hs-L56
00:19:48 <ontop> Anyone know why I might not be able to use Maybe/Either from ghci?
00:19:50 <orion> jle`: http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern <-- In this SO example, the answerer writes, "data DSL next = Get String (String -> next) ..."
00:19:51 <jle`> there are other ways to define DSL's that don't involve Free
00:19:52 <ontop> Prelude says it's loaded :(
00:19:55 <bollu> it's "a", so the output of running this computation is.. "a"?
00:20:10 <bollu> jle`: rught, but I was asking in the context of Free
00:20:19 <phaazon> yeah, Iâ€™m writing EDSLs without Free
00:20:20 <jle`> i might have missed your original question then
00:20:21 <bollu> orion: the DSL isn't a monad
00:20:27 <bollu> orion: the Free DSL is a monad
00:20:36 <bollu> orion: the DSL just has Functor structure
00:20:54 <jle`> orion: yeah, in that case, the type of next represents the type of the result
00:21:00 <jle`> but it doesn't represent the next action
00:21:05 <bollu> (so, if I understand it right, something of the type Free DSL String) will return a "String" when you use it inside the do-notation
00:21:12 <orion> jle`: Oh! That makes sense.
00:21:19 <jle`> for example, one inhabitant would be `Get s (\res -> True)`
00:21:24 <jle`> that would be :: DSL Bool
00:21:28 <jle`> an action that produces a Bool
00:23:51 <orion> jle`: In my specific case I have: data Action = E | S | Dhee | Dhes | Dhse | Dhss -- where the first two instructions take or return a value (depending on the interpreter being used), and the other instructions just perform the respective cryptographic operation.
00:24:12 <orion> But at the end of the program, you should have a pair of symmetric keys.
00:24:53 <jle`> is your execution always... "linear"?
00:24:57 <jle`> a pre-determined list of actions
00:25:10 <jle`> can you imagine ever changing the action you do next based on what the result of a previous action was?
00:25:49 <jle`> (by "changing the action", i mean choosing from E, S, Dhee, Dhes, Dhse, etc. as your constructor)
00:26:49 <orion> I do believe it is linear,.
00:27:23 <orion> I'm guessing that as a result of it being linear, Free is too powerful for my needs.,
00:27:54 <ReinH> a list might suffice.
00:28:06 <orion> ReinH: I might need a list of lists.
00:28:33 <adam_> Hey sorry to interrupt, but I am going through a book on Haskell and I am a little confused with something
00:28:54 <adam_> why is kleisli composition in the opposite order to function composition
00:29:08 <orion> ReinH: The reason is that this is a network protocol and I need to wait for a response from the other party to continue.
00:29:22 <ReinH> :t (<=<)
00:29:23 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
00:29:24 <phaazon> adam_: you can have the same orientation with regular function composition if you want
00:29:27 <ReinH> :t (>->)
00:29:28 <lambdabot>     Not in scope: â€˜>->â€™
00:29:28 <lambdabot>     Perhaps you meant one of these:
00:29:28 <lambdabot>       â€˜>>â€™ (imported from Control.Monad.Writer),
00:29:30 <phaazon> :t (>>>)
00:29:31 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
00:29:32 <ReinH> :t (>=>)
00:29:34 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:29:40 <ReinH> Both can be in either order.
00:29:45 <phaazon> > (+1) >>> (*2) $ 10
00:29:46 <lambdabot>  22
00:29:51 <adam_> I see
00:30:04 <adam_> which one is considered idiomatic Haskell?
00:30:12 <phaazon> (.)
00:30:43 <phaazon> a bit like you do in maths actually
00:30:48 <adam_> so for regular function composition I use (.) but for composing monadic functions use (>=>)
00:30:58 <phaazon> (g Â· f)(x) = g(f(x))
00:31:09 <phaazon> adam_: you can use <=<
00:31:12 <phaazon> or =<<
00:31:16 <ReinH> or (<=<) if you want a similar order to (.)
00:31:32 <ReinH> or you can use (.) for both.
00:31:42 <adam_> wait what?
00:31:52 <ReinH> if you use the one from Control.Category
00:31:58 <ReinH> instead of the one from the Prelude
00:32:00 <adam_> interesting
00:32:12 <jle`> orion: in any case, Haskell is very easy to refactor, so might as well use [Action] for now and maybe refactor later :)
00:32:26 <adam_> why does there seem to be so many ways to accomplish the same thing haha
00:32:39 <ReinH> such is life
00:32:51 <adam_> (<>) and mappend, pure and return 
00:32:53 <jle`> orion: if you want to use do notation, remember that Writer [a] is broken, performance-wise
00:33:27 <jle`> but you can use do notation with [Action] using something like `Writer [a] ()`
00:33:34 <jle`> myAction = do
00:33:47 <jle`>   tell myFirstAction
00:33:50 <jle`>   tell mySecondAction
00:33:54 <jle`> etc.
00:34:07 <ReinH> :t tell
00:34:08 <lambdabot> MonadWriter w m => w -> m ()
00:34:09 <radens> Does this Take O(n) time? let three = Succ (Succ (Succ Zero))
00:34:11 <radens> three == Succ (Succ (Succ Zero))
00:34:13 <ReinH> tell doesn't take actions
00:34:14 <jle`> it's a bit of an abuse of do notation, apparently
00:34:19 <ReinH> tell takes monoid elements
00:34:32 <jle`> ReinH: well, i'm assuming myAction :: [Action], myFirstAction :: [Action], etc.
00:34:34 <jle`> heh
00:34:40 <jle`> oh
00:34:42 <jle`> yeah
00:34:43 <ReinH> Oh, so by action you don't mean action
00:34:45 <ReinH> Of course.
00:34:50 <jle`> well i still have some stuff wrong
00:34:57 <jle`> but...hopefully the basic idea got across heh
00:35:03 <jle`> good call though
00:35:14 <ReinH> I mean, instead of Writer [a] (), you could use (++)...
00:35:15 <jle`> radens: it depends on how you define (==)
00:35:24 <jle`> ReinH: yeah, (++), or mconcat is probably the saner way
00:35:32 <jle`> myAction = mconcat [
00:35:34 <jle`>   , action1
00:35:37 <jle`>   , action2 ]
00:35:38 <radens> jle`: deriving Eq
00:36:10 <jle`> but orion before expressed "ability to use do notation" as an advantage of Monad, and i was trying to show that Monoids can use do notation too
00:36:31 <jle`> (not that it's a good idea, heh)
00:36:34 <jle`> radens: yeah, i think so
00:36:48 <radens> gross
00:36:55 <ReinH> jle`: of course monoids can use do notation, monads are monoids la la la
00:36:56 <radens> thanks
00:37:50 <jle`> la la
00:38:05 <jle`> this isn't too directly related to the 'monads are monoids in the category of endofunctors' thing tho
00:38:11 <jle`> but i take it that was meant to be in jest
00:38:55 <jle`> tell here is our monoid homomorphism
00:39:35 <jle`> turning a `mempty`/`<>` monoid :: m into a `pure ()`/`*>` monoid :: Writer m ()
00:39:43 <ReinH> yes, this isn't about being helpful, this is about being correct
00:40:00 <ReinH> I know what you meant
00:40:06 <jle`> i meant what you know
00:40:43 <jle`>  <______<
00:42:41 <jle`> Cale: any reason why RandT is implemented using lazy StateT and not the strict one?
00:43:28 <Cale> jle`: No particular reason, but I also don't see any reason to make it the strict one.
00:43:43 <Cale> Well, one reason might be that when I wrote the code, there was so strict StateT
00:44:06 <orion> If 'm' is a Monad, what do you call "m a", and what do you call "a -> m b" ?
00:44:14 <Cale> I just put it up on HaWiki as an example of something you could do with StateT -- hackage didn't exist yet.
00:44:26 <quicksilver> I call "m a" an action 
00:44:29 <jle`> i'm considering replacing a tight loop with a strict accumulator on the StdGen ... and switching to RandT would make it non-strict there, but I guess the StdGen's are used immediately anyway
00:44:45 <jle`> or, if i care about performance, RandT/System.Random might not even be the best choice in the first place
00:44:47 <orion> quicksilver: What do you call the latter?
00:44:52 <Cale> orion: "the type of m-actions whose result has type a", and "a function from values of type a to m-actions whose result have type b"
00:45:03 <Cale> er, the type of functions*
00:45:12 <quicksilver> I call "a -> m b" either a function or an action with parameters or just an action (lazily)
00:45:21 <Cale> Or, more likely, I wouldn't say them in English
00:45:27 <Cale> I would just say "a to m b"
00:45:33 <jle`> orion: people typically call things of type `m a` "actions", but...it sort of depends on what heuristic/rough analogy you're looking at the thing as.  without context, there really isn't a name
00:45:34 <Cale> if I was speaking it aloud
00:45:44 <jle`> but i've heard people coin the word "mote" for something of type `m a`
00:45:53 <jle`> and "fote" for something of type `f a` ... 
00:46:01 <Cale> ugh, haha, I thought that was a joke until people started actually using it
00:46:08 <quicksilver> I'll get my cote
00:46:18 <jle`> i think fote is the joke
00:46:26 <jle`> at least, once mote started becoming not a joke
00:46:33 <jle`> once fote is accepted, `aote` will be the new joke
00:46:40 <quicksilver> "computation" is also used, but not very commonly in this channel.
00:47:12 <jle`> honestly any word chosen would have to be interpreted in a way detached from any other interpretation of that word
00:47:20 <jle`> in order to be usable as a description of something of type `m a`
00:47:38 <jle`> "action" is used to describe something of type `m a`, but it's understood that action means nothing more or less than "something of type `m a`" in that case
00:47:57 <jle`> same thing goes if you want to call it a computation
00:48:06 <orion> The reason I ask is because I'm trying to resolve in my head the difference between the Kleisli composition operator and bind. I realize that they have different type signatures, but couldn't it be said that both >>= and >=> sequence actions?
00:48:27 <orion> And, with bind, isn't the result of the previous action passed to the next one?
00:48:31 <jle`> throw in (*>) if you want to see something else that "sequences actions"
00:48:32 <quicksilver> I think that's a reasonable thing to say
00:48:45 <quicksilver> in both cases the result of the previous is passed to the next
00:49:10 <orion> So, what is the semantic difference between the two if both compose actions?
00:49:12 <jle`> oh, i've heard people call (a -> m b)'s "impure functions", in contrast to (a -> b)'s  --- impure in the context of what effects `m` is describing
00:49:42 <Cale> I use computation interchangeably with action
00:49:46 <jle`> orion: (>=>) sequences functions, the result is a new function
00:50:01 <jle`> (>>=) binds a function to the result of an action...i guess? the result is a new action
00:50:23 <jle`> the difference between (>=>) and (>>=) is roughly the same as the difference between (.) and ($)
00:50:33 <Cale> orion: A function a -> m b isn't something we'd normally call an "action", though I suppose it is an action in the (->) a monad.
00:50:51 <Cale> orion: It's not an m-action, it's a function which produces an m-action.
00:51:41 <quicksilver> orion: the result of >>= doesn't take a parameter
00:51:45 <quicksilver> orion: the result of >=> does.
00:51:58 <quicksilver> I mean, everything jle` and Cale said also. We're just saying the same things in different ways.
00:52:14 <ReinH> The semantic difference is evident from their types
00:52:21 <Cale> orion: (>>=) takes an m-action, say x, having results of some type a, and it takes a function, say f, from values of type a, to m-actions having results of type b, and constructs the m-action which will first execute x, and then if its result is v, will execute f v, producing the result of that action as its own.
00:52:28 <orion> quicksilver / ReinH: Yes, that's why I mentioned that I read the types.
00:52:29 <jle`> if you understand the difference between (.) and ($), you'll understand the difference between (>=>) and (>>=)
00:52:36 <ReinH> One takes two arrows and gives and arrow, the other takes an action and an arrow and gives an action.
00:52:42 <ReinH> *an
00:53:01 <Cale> If it helps just because it's schematic: x >>= f is the same as  do v <- x; f v  which is the same as  do v <- x; w <- f v; return w
00:53:32 <Cale> (<=<) :: (b -> m c) -> (a -> m b) -> (a -> m c)
00:53:54 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c)
00:54:08 <Cale> there's an analogy to be made between (<=<) and (.)
00:54:22 <anohigisavay> cabal repl exhausts my memory :(
00:54:27 * hackagebot wavefront 0.7 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.7 (DimitriSabadie)
00:54:27 <Cale> note that (>=>) and (<=<) are just flips of one another, they take the arguments in the opposite order
00:55:02 <Cale> What they do is pretty much the most obvious thing they *can* do with that type signature
00:55:28 <Cale> (g <=< f) x = do u <- f x; v <- g u; return v
00:55:31 <anohigisavay> i have a cabal project that uses happy/alex and cabal repl has problem loading the happy-generated hs file
00:55:56 <Cale> anohigisavay: How much memory
00:55:57 <Cale> ?
00:56:20 <orion> Cale: thank you
00:56:23 <anohigisavay> ate up my entire 16GB memory and kernel crashed
00:56:27 <Cale> wow
00:56:33 <anohigisavay> also
00:56:44 <anohigisavay> ghc-mod brought me the same problem
00:57:03 <Cale> Yeah, it's unsurprising that one would do it if the other did
00:57:40 <Cale> I take it just trying to compile with ghc directly produces the same outcome?
00:58:22 <anohigisavay> not directly, but cabal build works fine
00:58:29 <Cale> ah, okay
00:58:38 <Cale> after that, do you have a bunch of .o and .hi files?
00:59:05 <Cale> ghci should be able to load the .o without having to try to interpret it
00:59:41 <cocreature> you need -fobject-code for that iirc
00:59:55 <anohigisavay> Cale: you mean after cabal repl or cabal build?
01:01:06 <anohigisavay> Cale: i got .o and .hi files at dist/build
01:01:10 <Cale> after building
01:01:27 <anohigisavay> yea
01:01:43 <Cale> Yeah, cocreature is probably right
01:02:03 <Cale> It used to be that ghci would load object code if it was available, but that seems to have been disabled by default
01:04:36 <anohigisavay> Cale: cocreature: I did this: cabal repl --ghc-options="-fobject-code"
01:04:48 <anohigisavay> looks fine now
01:05:12 <cocreature> btw is this some giant project? Iâ€™ve never managed to have run cabal repl exhaust my memory
01:05:27 <cocreature> otherwise it might be a bug in which case itâ€™s probably worth reporting
01:05:35 <anohigisavay> cocreature: not giant, but the happy-generated hs code is a bit long
01:05:50 <anohigisavay> still less than 10k loc
01:05:58 <cocreature> that sounds like a bug
01:06:28 <anohigisavay> hmm...
01:14:16 <MarcelineVQ> anohigisavay: https://ghc.haskell.org/trac/ghc/newticket?type=bug is where you'd submit a bug. Before that try a cabal clean and then a cabal build, if it builds and still does this crazy crap please do make a bug report with as much relevant information as you can think of.
01:32:41 <merijn> Anyone have any ideas why my use of mapConcurrently appears to not actually do anything concurrent? >.>
01:33:21 <bartavelle> merijn, +RTS -N ?
01:33:44 <merijn> bartavelle: That shouldn't really matter for blocking IO tasks, afaik?
01:33:50 <bartavelle> indeed
01:34:03 <merijn> I'm basically just doing createProcess >> waitForPid
01:34:12 <merijn> But it's only launching one subprocess at a time
01:34:30 <merijn> Although I guess it can't hurt to enable the threaded RTS
01:37:24 <hunteriam> Cale: can you think of a way to write a typeclass EndsIn a b which indicates that b "ends in" a, ie b could be (a0 -> a1 -> ... -> a)
01:37:35 <hunteriam> Cale: we were trying to do this yesterday and couldnt get anywhere
01:39:28 * hackagebot alex 3.1.7 - Alex is a tool for generating lexical analysers in Haskell  https://hackage.haskell.org/package/alex-3.1.7 (SimonMarlow)
01:41:14 <bartavelle> merijn, did it help ?
01:42:33 <merijn> bartavelle: Not tested yet, I was trying to solve some other issues too
01:42:45 <merijn> Lemme check
01:42:59 <merijn> Yup
01:43:07 <merijn> ok, so that should help
01:43:21 <bartavelle> strange
01:43:23 <merijn> Now on to the next problem, I don't suppose anyone here is a SLURM expert? :p
01:44:04 <Cale> hunteriam: It's sorta possible, but not worth doing, and not really totally clearly specified.
01:44:30 <Cale> hunteriam: What were you hoping to do with the class?
01:44:55 <hunteriam> Cale: it was an attempt at doing Auth in servant
01:46:10 <Cale> Why is it that every time I hear about servant, it's surrounded by questions who my gut reaction answer to is "you shouldn't even want to do that in Haskell"? :)
01:47:24 * Cale looks at the servant documentation and immediately sees why this is
01:47:56 <Cale> It's one gigantic abuse of Haskell's type system extensions to do things which should probably be done in a proper dependently typed language instead.
01:48:59 <Cale> I dunno man :)
01:52:58 <hunteriam> !
01:53:00 <hunteriam> i agree!
01:53:35 <hunteriam> Unrelated: is it a bad idea to commit my changes after every interaction with my database? why wouldnt i?
02:06:43 <ReinH> Cale: What I don't get is I already showed them a perfectly reasonable way to do auth in servant
02:07:11 <ReinH> that solves their exactly problem without any of this nonsense
02:07:17 <ReinH> *exact
02:07:18 <Cale> oh okay
02:07:38 <Cale> hunteriam: ^^ did you see ReinH's answer?
02:07:42 <ReinH> yes
02:07:50 <hunteriam> uh i have it working
02:07:50 <ReinH> he said he would "try it later"
02:07:53 <Cale> ah, okay
02:07:54 <ReinH> that was like 12 hours ago
02:07:59 <hunteriam> yea its all good now dude
02:08:01 <Cale> Just making sure :)
02:08:14 <ReinH> So I don't understand why they're working on this at all
02:08:20 <hunteriam> curiosity
02:08:35 <ReinH> fair enough
02:08:41 <Cale> hunteriam: The thing is, it's not really clearly defined what the "end" is
02:09:09 <hunteriam> yea
02:09:16 <Cale> hunteriam: Or, for that matter, the number of arguments to a function
02:09:25 <Cale> Is another thing you can't really determine in general
02:09:31 <Cale> Consider, for instance foldr
02:09:34 <Cale> :t foldr
02:09:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
02:09:50 <Cale> How many arguments? Is it 3? What if b happens to be a function type?
02:10:12 <hunteriam> i mean
02:10:45 <hunteriam> what i really wanted was to be able to rewrite a function f :: a -> ... -> b to f' :: x -> a -> ... -> b
02:11:02 <hunteriam> or to rewrite to f' :: a -> ... -> b and fix the result
02:11:08 <ReinH> Here's a simple example: how many arguments does id take?
02:11:30 <ReinH> The answer is, of course, "as many as you want".
02:12:21 <ReinH> (or "one")
02:12:53 <Cale> Yeah, the only sane answer to the number of arguments that a function has in Haskell is "exactly one"
02:12:55 <ReinH> but people often say that (+) takes two arguments, so why wouldn't they say that id (+) 1 2 applies id to three arguments?
02:14:28 <Cale> Applying a function to "multiple arguments" is kind of a shorthand way of thinking about things which doesn't work out so well when you start programmatically manipulating types.
02:15:37 <ReinH> I don't really understand how  a function f :: a_0 -> ... -> a_n -> b  can be turned into a function f :: x -> a_0 -> ... -> a_n -> b unless it just ignores the x.
02:16:06 <ReinH> doesn't seem like a thing that should even be possible
02:16:35 * frerich nods
02:16:47 <frerich> hunteriam: I think your 'rewrite' function should be just something like 'rewrite f = \_ -> f'
02:17:02 <frerich> hunteriam: but that doesn't seem very useful.
02:17:33 <hunteriam> has to rewrite the result of applying f
02:18:02 <frerich> :t let rewrite f = \_ -> f; f = undefined :: a -> b -> c in rewrite f
02:18:03 <lambdabot> t -> a -> b -> c
02:18:16 * frerich does a Ninja move.
02:18:45 <ReinH> frerich: right, that's what I said too.
02:19:08 <frerich> ReinH: I guess then it must be right!
02:19:51 <ReinH> How would it rewrite the result of applying f?
02:19:59 <ReinH> the x appears as the first argument to the new f
02:20:12 <hunteriam> ?
02:20:44 <ReinH> yes, my thoughts exactly
02:20:55 <frerich> hunteriam: Now of course, if you would be a bit more specific about your types, then there may well be something useful. E.g. if you have a function 'a -> a' then it would be plausible to define a function 'times :: Int -> (a -> a) -> a -> a' which repeatedly applies some function (so you can do "5 `times` f $ x" or so
02:21:30 <hunteriam> take f :: a -> b -> c and make it f' :: a -> b -> c that always returns a specific type of c
02:21:33 <hunteriam> or value* of c
02:22:05 <frerich> hunteriam: Since you know nothing about 'a', 'b' or 'c', you cannot construct values of either type.
02:22:06 <ReinH> hunteriam: that's completely different from what you just said
02:22:19 <ReinH> before it was inserting a new x argument
02:22:41 <ReinH> now it's the same type, but it "always returns a specific type of c", which you can't do because c is polymorphic.
02:22:56 <hunteriam> take f :: a -> b -> Int and make it f' :: a -> b -> Int that always returns a specific type of c
02:23:04 <hunteriam> specific value of Int*
02:23:17 <ReinH> How is that not a completely different problem from the one you just described?
02:23:25 <bartavelle> that one is easy, and doesn't require the knowledge of f
02:23:40 <hunteriam> I want to do it generically for f
02:23:44 <hunteriam> for any number of args
02:24:20 <bartavelle> why would it be useful ? you don't need the original function to do that
02:24:34 <ReinH> I still don't understand how you just changed the problem statement in the middle of the discussion. Is this a different problem?
02:24:34 <hunteriam> Servant expects specific types of functions
02:24:46 <hunteriam> ReinH: there was a misunderstanding between you and I
02:24:46 <frerich> hunteriam: You can easily define 'fixate _ _ = 3'. You don't even need your original; (a -> b -> Int)' if you just want a fixed Int :-)
02:24:50 <hunteriam> this is all i ever cared about
02:25:05 <ReinH> then why have you been asking about something completely different?
02:25:27 <hunteriam> frerich: it needs to be generic
02:27:03 <frerich> hunteriam: So '\_ _ _ -> 0 :: (a -> b -> Int) -> a -> b -> Int' would not cut it? Because that takes an 'f :: a -> b -> Int' and turns it into an 'a -> b -> Int' which returns a specific Int values.
02:27:23 <hunteriam> frerich: it needs to take f :: a -> ... -> Int and return specifics
02:28:06 <ReinH> variadic functions are possibly in Haskell, but I doubt that this is possible.
02:28:08 <ReinH> Maybe Cale knows.
02:28:16 <ReinH> THey certainly aren't idiomatic haskell.
02:29:21 <_JKL_> http://lpaste.net/148651 any idea what goes wrong with my try to not calculate intermediate results multiple times?
02:30:06 <ReinH> *possible
02:34:12 <frerich> hunteriam: I think it might be useful to reconsider that technically, all functions in Haskell take precisely argument. So the 'more generic' solution is maybe not even useful. E.g. that 'f :: a -> ... -> Int' you sketched is actually 'f :: a -> (... -> Int)'. Now, there is a nice simple trick to define that your function should take a function which returns an int: '(a -> Int)'. However, by that time, you don't know anymore how many arg
02:34:12 <frerich> uments the original function took.
02:35:31 <frerich> hunteriam: Long story short: I suspect what you want is either impossible, or requires some servant-style type hackery. Neither of which is not something I can do. :-)
02:36:31 <ReinH> servant type hackery is not inane though, it's quite useful
02:36:36 <ReinH> you mean printf style type hackery
02:37:38 <Cale> Oh, well, you can do that...
02:41:22 <Cale> http://lpaste.net/148653 there you go
02:42:04 <Cale> hunteriam: frerich: ReinH: ^^
02:43:09 <Cale> Just be careful to make sure that it knows the end result has type Int
02:44:20 <ReinH> Cale: the original question involved different types
02:44:30 <ReinH> a -> b -> Int and etc
02:44:57 <ReinH> yours has foo :: a -> a
02:45:26 <hunteriam> ReinH: in Cales you just do instance Foo Type to specify what to rewrite all functions terminating in that type as
02:45:55 <Gurkenglas> Using curryN and uncurryN from https://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html : \x -> curryN . fmap (const x) . uncurryN :: c -> (a -> … -> c) -> (a -> … -> c) replaces the resulting c from the second argument by the x in the first argument
02:46:02 <hunteriam> ^
02:47:40 <hunteriam> data SqlT m a = SqlT {sqlConn :: Connection, runSqlT :: (m a)}
02:47:48 <hunteriam> Monad (SqlT m)?
02:48:38 <ReinH> Cale: ah, I see.
02:49:24 <ReinH> The constraint would be applied in functions that use SqlT m a
02:49:30 * hackagebot hedis 0.6.10 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.6.10 (k_bx)
02:49:33 <Gurkenglas> Monoid Connection => Monad (SqlT m) is possible - for how do you generate a Connection for return, and how do you combine the two Connections you see in (>>=)?
02:49:43 <hunteriam> exactly
02:49:53 <hunteriam> I dont really want to generate one myself though
02:49:57 <hunteriam> I want to be supplied one
02:52:31 <ReinH> return would have to generate a Connection.
02:52:53 <ReinH> there's no way to have one supplied to return
02:54:25 <Gurkenglas> Of course you could change the definition of SqlT if you don't like that.
02:55:13 <hunteriam> How so?
02:57:44 <Gurkenglas> Depending on where Connection comes from and where it goes, you could for example do "data SqlT m a = SqlT {sqlConn :: First (Maybe Connection), runSqlT :: (m a)}", letting First's Monoid instance use the first connection, if any, you mention anywhere
03:03:19 <ReinH> Gurkenglas: if you're going to do that, why not just use runSqlT to extract the m a, which presumably is a Monad?
03:06:18 <Gurkenglas> ReinH, because the produced SqlT m requires a sqlConn.
03:10:09 <ReinH> Yes, but once you have one
03:10:24 <ReinH> you have an m a that you can use with do notation, etc
03:11:25 <Gurkenglas> Well yes, you need to do that anyway to even fulfill SqlT m b's type, and there's exactly one way to achieve that
03:12:05 <Gurkenglas> (You need both.)
03:16:35 <orion> In a Free Monad, how do you create constraints on the ordering of actions? For example, it is an error to specify Foo *after* specifying Bar.
03:17:06 <orion> Is there a way to do it using the type system, or do I have to rely on my interpreter to check it at runtime?
03:17:55 <ReinH> orion: you can probably use an indexed free monad construction, which is a bit different from a usual free monad
03:18:37 <ReinH> orion: e.g., https://hackage.haskell.org/package/indexed-free
03:18:51 <ReinH> example use https://ocharles.org.uk/blog/posts/2013-11-24-using-indexed-free-monads-to-quickcheck-json.html
03:19:43 <orion> Great, thanks!
03:28:06 <phaazon> hm, Iâ€™m not sure about what to do to my type-driven functions
03:28:14 <phaazon> either I can rely on the type system only
03:28:38 <phaazon> so if you donâ€™t have explicit type for the returned type, youâ€™ll have to use ScopedTypeVariables
03:28:50 <phaazon> the other way to deal with that is to use a dummy argument
03:28:54 <phaazon> like phantom typingÃ§
03:28:55 <phaazon> -
03:28:57 <phaazon> -Ã§
03:29:10 <phaazon> but I donâ€™t really like that as it makes function calls longer and boring
03:31:46 <MarcelineVQ> http://stackoverflow.com/questions/22116363/what-is-the-purpose-of-data-proxy related?
03:43:27 <padre_angolano> -Ã§?
03:57:14 <frerich> In recent discussions with colleagues about all kinds of programming problems (mostly in C++ and Java), I always used the Haskell syntax on the whiteboard when talking about what kind of functions we'll probably need. And nobody blinked an eye. And today, somebody uttered that it would be nice if he could indeed just use that Syntax in Java (I didn't even mention it's Haskell syntax, I think he believes I kind of made it up on the spot)
03:57:16 <frerich> :-)
03:58:01 <KaneTW> haskell syntax feels very natural
03:58:48 <karchnu> frerich: awesome. :D
03:59:03 <Wizek> frerich, hehe :D
03:59:16 <karchnu> frerich: why don't you tell him ?
03:59:22 <Wizek> frerich, Did you tell him that it is indeed possible?
04:00:35 <KaneTW> my head is killing me
04:00:36 <KaneTW> piss
04:00:40 <KaneTW> wrong chat
04:01:36 <gameer> :D
04:02:25 <argoneus> I was thinking a bit about haskell, and is it me or is haskell less prone to bugs than other languages?
04:02:39 <argoneus> like, it seems to me that in Haskell, it either works or it doesn't, not "it works except here and here"
04:02:57 <argoneus> (assuming a programmer that knows what he's doing)
04:03:47 <Wizek> frerich, I mean, I haven't much experience with Java itself, but just a few weeks ago I did write some Haskell code to interface with Java code using this library: https://hackage.haskell.org/package/java-bridge And I was a bit surprised that it was this much possible to load java files, instentiate objects and call methods as it proved to be.
04:03:49 <liste> I'd say it's easier to make your code less prone to bugs in Haskell
04:04:05 <Stratege> Is there any reason why Data.List's sum is defined as "foldl (+) 0" instead of "foldl' (+) 0"? It seems to me like that's a case where being lazy is just harmful?
04:04:07 <liste> but you have to still do it yourself, it's not magic
04:04:49 <merijn> Stratege: I think historical reasons
04:04:54 <merijn> :t Data.List.sum
04:04:55 <lambdabot> (Num a, Foldable t) => t a -> a
04:05:00 <frerich> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#sum looks actually more complex.
04:05:08 <frerich> err sorry, I'm in Foldable.
04:05:33 <Stratege> if you look at the instance for [] you'll see it overwrites the default implementation
04:05:35 <frerich> Wait, maybe that's right. If I click 'Source' on 'sum' in http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html that gets me to Data.Foldable
04:06:08 <Stratege> yeah stumbled across that as well, search for Foldable [] and you'll see that it overwrites the default sum with List.sum
04:06:18 <Stratege> and if you click that you get to the actual implementation
04:07:23 <frerich> Stratege: Indeed, it uses GHC.List.sum, which uses what you wrote!
04:07:39 <jle`> argoneus: it's not just you
04:07:47 <jle`> that's actually one of the major selling points of haskell
04:08:15 <frerich> Stratege: Maybe it fuses really well when it's inlined or something tricky like that?
04:08:17 <argoneus> jle`: it's because you don't have to guard against everything everywhere and catch exceptions everywhere, right?
04:08:19 <jle`> and if you make some of your functions polymorphic enough, it eliminates a huge class of incorrect programs off the bat
04:08:31 <argoneus> though
04:08:32 <jle`> well that, too; using Maybe instead of null
04:08:41 <jle`> parametric polymorphism eliminates huge clases of incorrect programs
04:08:43 <argoneus> you do have to know what kind of values your functions may receive
04:08:46 <argoneus> and guard against those
04:08:49 <argoneus> but that's literally one line
04:08:52 <argoneus> as opposed to a bunch of ifs
04:08:56 <argoneus> in different places
04:09:13 <tero-> uncaught exceptions can still be equally annoying in Haskell as in other languages
04:09:15 <jle`> and also, lack of unchecked side effects makes code several orders of magnitude easier to reason about
04:09:25 <jle`> and less things to worry about, less sources of bugs
04:09:45 <jle`> so many sources of bugs in other languages just don't exist in haskell
04:10:01 <jle`> hidden state, fun stuff like that
04:10:10 <jle`> haskell is also much easier to test, for situations where you might want to test
04:10:20 <Stratege> frerich I toyed around a bit with "sum $ take 1000000 fib" (with the memoization based lazy fib) and it blew up to 80 gigs of memory usage before I had to kill it. So I'm not sure "it fusing really well" helps (even if it should do that)
04:10:32 <jle`> Stratege: did you compile with optimizations?
04:10:34 <argoneus> jle`: is this a feature of funcprog in general or haskell because it's pure?
04:10:53 <argoneus> I guess in lisps you can still have the same problems of imperative programming, right
04:10:59 <jle`> argoneus: haskell because of static types with parametric polymorphism and large usage of ADT's
04:11:01 <argoneus> as most lisps allow you to do just that from what I've seen
04:11:03 <Stratege> jle` nah, that's next step I guess.
04:11:51 <jle`> functional programming in general sort of discourages programming with unchecked side effects/hidden state as a part of your solution, so lisp etc. do have some advantage
04:12:19 <jle`> but beyond that, Haskell's type system + parametric polymorphism + ADT-based interfaces eliminates loads of bugs
04:12:23 <argoneus> I actually don't get why for example common lisp is funcprog, you can do regular OOP in it from what I've seen, if you just say that functional programming means you work with functions instead of some hidden state, you may as well call javascript functional programming
04:12:32 <argoneus> and javascript can't really be functional programming :<
04:12:36 <jle`> haskell is the only language i'd write something in if i intend to maintain it past a month or so
04:12:49 <hunteriam> best lib for encrypting passwords?
04:12:58 <jle`> functional programming is an approach to solving problems, not a language feature
04:13:12 <argoneus> well....
04:13:15 <hunteriam> javascript allows functional programming
04:13:15 <argoneus> a language may enable or even encourage it
04:13:34 <jle`> yeah, languages can make fp easier or harder, it can work with or against the language
04:13:40 <Stratege> argoneus to my understanding there is almost no paradigm that you can't somehow force into CLisp?
04:14:08 <hunteriam> what is used for encryption?
04:14:13 <argoneus> Stratege: it's possible, I don't intend to learn it though
04:14:19 <argoneus> I want to learn Haskell and Clojure afterwards
04:14:21 <Stratege> jle` well ... -O2 makes it go away, I guess because of the strictness analyzer optimizing it?
04:14:25 <argoneus> and see which one I like better
04:14:27 <argoneus> they both seem nice
04:14:36 <Stratege> argoneus I'd recommend scheme over CLisp any day, anyway.
04:14:38 <jle`> FP is nice but imperative programming in Haskell is so much more maintainaible, correct, etc. than imperative programming in other languages too
04:14:55 <jle`> all of the other benefits of haskell type system, etc. still carry over when you do imperative programming in haskell
04:15:05 <argoneus> Stratege: would you prefer Scheme to Clojure too?
04:15:09 <jle`> functional style, purity, etc. is only a part of the story :O
04:15:21 <argoneus> jle`: you can do imperative programming in haskell
04:15:22 <argoneus> ?
04:15:31 <jle`> yes, haskell does imperative programming pretty well
04:15:44 <jle`> and the result is much more maintainble, faster to write, etc. than other languages :O
04:15:50 <jle`> and easier to refactor
04:15:56 <hc> (once you know how to write haskell code fast;)
04:16:10 <jle`> haskell is my favorite language to do imperative programming in :)
04:16:20 <Stratege> argoneus I haven't seen enough of Clojure to really make that judgement, but when it comes to "learning and understanding" instead of "everyday use" then yes, a good scheme seems more suited for obtaining that deeper understanding of lisps.
04:16:23 <jle`> hc: yes, but that's like saying cars are fast once you learn how to drive fast
04:16:36 <nshepperd_> heh, oh. i was wondering why my fib list in ghci wasn't using up all my memory with saved fibs
04:16:36 <statusfailed> a CPS-ified "show" would be this, right?: 'showCPS x k = k (show x) :: Show a => a -> (String -> r) -> r' 
04:17:05 <nshepperd_> it's because 'fib :: Num a => [a]'!
04:17:21 <hc> jle`: more like saying roads don't matter anymore once you learn to fly an airplane ;-)
04:18:02 <hc> (roads being one of the main causes for having to go slow)
04:18:07 <argoneus> jle`: I like about haskell that.. how to explain.. in other languages, you're given a bunch of tools, like fors, whiles, do, if/then/else, etc. and in haskell you don't, but if you want them, you can easily implement them and use them as if they had been there in the first place, no weird syntax
04:18:08 <nshepperd_> I forgot about polymorphism preventing sharing :O
04:18:31 <argoneus> jle`: it almost seems to me like you can design a whole keyword system around your specific problem and write the solution in pretty much native language
04:18:42 <hunteriam> DSL
04:18:44 <hunteriam> argoneus: 
04:19:16 <argoneus> oh, so there is a name for that
04:19:33 * hackagebot Hoed 0.3.4 - Lightweight algorithmic debugging.  https://hackage.haskell.org/package/Hoed-0.3.4 (faddegon)
04:19:34 <nshepperd_> embedded domain specific language
04:19:37 <argoneus> is haskell good at making a DSL?
04:19:41 <Stratege> yeah
04:19:58 <argoneus> it makes things much easier to write and debug, right
04:20:01 <Stratege> and if you want to go beyond what haskell appears to provide directly (which is a lot)  there's Template Haskell
04:20:05 <argoneus> like
04:20:09 <argoneus> DSL seems much stronger than OOP
04:20:23 <Stratege> which allows you to essentially parse any string into a Haskell AST
04:20:36 <Stratege> (as long as you can come up with the parser)
04:23:20 <jle`> while i think other languages have some nicer facilities for "nicer looking" DSL's syntax-wise, Haskell is really great at building representations of programs
04:23:34 <jle`> in a robust way
04:23:41 <jle`> representations of programs and systems
04:25:55 <hunteriam> what should i use for hashingm?
04:27:33 <liste> crised I'd use something more type safe, like "class Tree<T> { T value, List<Tree<T>> subtrees }"
04:27:41 <liste> s/,/;/
04:28:01 <Stratege> jle` I'm inclined to disagree, since if you -really- want to you can just make a custom DSL and wrap it in a quasiquoter and then your syntactic baggage is minimal.
04:28:47 <liste> srry, wrong channel
04:32:04 <hunteriam> so no standard hashing lib?
04:32:50 <merijn> hunteriam: Usually depends on what you're hashing?
04:32:51 <Tehnix> hunteriam: Usually depends on what you're hashing?
04:32:59 <merijn> Tehnix: Jinx!
04:33:03 <hunteriam> passwords!
04:33:08 <hunteriam> for a web server
04:33:18 <merijn> hunteriam: Ah! Use bcrypt or scrypt
04:33:41 <absence> what's the lambdabot syntax for defining types?
04:33:47 <merijn> Should probably be some haskell bindings for that somewhere, but if not, they're C so should be trivial to bind
04:33:57 <cocreature> @hackage bcrypt
04:33:58 <lambdabot> http://hackage.haskell.org/package/bcrypt
04:34:40 <merijn> scrypt is slightly better, IMO, but bcrypt should be fine
04:34:59 <liste> absence "@let data Foo = Bar"
04:35:14 <absence> liste: ah, thanks
04:35:17 <cocreature> @hackage scrypt also exists, and @hackage cryptonite contains scrypt as well
04:35:18 <lambdabot> http://hackage.haskell.org/package/scrypt also exists, and @hackage cryptonite contains scrypt as well
04:36:14 <argoneus> I actually wondered, and I don't know what to search for, when there's some C library or something, like SDL, and people say they made a haskell binding for it, what does that mean?
04:36:26 <argoneus> I get that you somehow use haskell to make calls to the C library, but... how do you do that?
04:36:49 <argoneus> do you just reimplement all the functions and use some haskell function to do a native call?
04:36:51 <merijn> argoneus: Haskell has a Foreign Function Interface that can call C functions
04:36:56 <argoneus> ah
04:37:15 <merijn> argoneus: GHC understands C functions and can generate code to call them and return the results
04:37:23 <argoneus> so the binding is just a big .hs file with something like somefunc :: a->b->c foreignfunctioncall somefunc(a,b)
04:37:38 <argoneus> like that?
04:37:47 <merijn> argoneus: Usually it's wrapped up in a higher level haskell interface, but yes
04:37:48 <cocreature> often bindings also abstract over the original lib to provide a nice haskell interface
04:38:05 <argoneus> hm
04:38:27 <argoneus> what's a "haskell interface"?
04:38:32 <merijn> argoneus: See for example https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L283-L297
04:38:47 <merijn> Those imports are C functions elsewhere in the repository
04:39:00 <merijn> And the exported haskell functions provide a "nicer" interface to use them
04:40:54 <argoneus> merijn: those functions seem to have no implementation
04:41:03 <argoneus> do they automagically get it from the .h or ...?
04:41:20 <merijn> argoneus: The implementation is in C: https://github.com/merijn/posix-pty/blob/master/cbits/fork_exec_with_pty.c
04:41:41 <merijn> argoneus: Those declarations just tell GHC "what does the C function look like"
04:41:57 <argoneus> so GHC can also compile c?
04:42:06 <argoneus> to figure out what it does
04:42:11 <merijn> argoneus: No, cabal just calls your C compiler
04:42:42 <argoneus> I see
04:42:56 <merijn> argoneus: Both C compilers and GHC just produce binary object files. Object files consist of symbols (basically name-address pairs) and the linker is responsible for turning those into an executable
04:44:21 <merijn> argoneus: The declaration just tells GHC "In the final binary there will be a symbol with the following C type", which makes GHC emit a "use this symbol during linking" inside the calling code. The C compiler compiles the C code and produces an object file too. The linker then tries to link the two and sees that GHC's objectfile mention a symbol from the C compiler's object files and fills in the gaps
04:44:31 <ironChicken> does that idea "IO data dependency" make any sense?
04:45:34 <ironChicken> I think I mean that I have a function which requires an argument which can only be obtained by executing an IO action
04:46:10 <aweinstock> ironChicken: sounds like what (>>=) is for
04:46:32 <aweinstock> :t (>>=) :: IO a -> (a -> IO b) -> IO b
04:46:33 <lambdabot> IO a -> (a -> IO b) -> IO b
04:46:34 <argoneus> merijn: I always thought object files were language specific
04:46:53 <argoneus> but it makes more sense if they aren't
04:47:29 <argoneus> does this mean you can have bindings from any compilable language to any compilable language fairly easily?
04:47:41 <ironChicken> aweinstock: yeah, i guess so. but i think i'm trying to avoid making *this* function IO; i'd prefer the IO to be further up the chain of evaluation
04:47:52 <ironChicken> hmm, needs more thought
04:48:00 <Taneb> argoneus: the big hurdle, I believe, is memory mode
04:48:02 <Taneb> l
04:48:27 <merijn> argoneus: Object files are just binary data. Now of course, since this data is machine code the contents are language specific
04:48:48 <merijn> argoneus: i.e. C expects arguments on the stack in a certain order/in specific registers (also called the calling convention)
04:49:00 <liste> ironChicken you can just make a type without exposed constructor, and a "mkFoo :: IO Foo" instead
04:49:24 <merijn> argoneus: GHC knows the calling convention used on your system and makes sure to put everything on the stack the right way before calling C symbols
04:49:25 <aweinstock> ironChicken: the second argument to >>= doesn't need to take an IO action as input, it just takes the value
04:49:33 <merijn> argoneus: Which is why it needs to know the type of the C function
04:49:38 <argoneus> ohh
04:50:41 <merijn> argoneus: There's no conceptual reason why you couldn't have FFI bindings for any other machine languages
04:50:42 <Stratege> ironChicken "return . f" for any f is how you can turn any function into one that's in IO (or any monad really), so you can just write f without needing to involve IO in it at all.
04:51:02 <merijn> argoneus: It's just that maintaining this stuff for 10 language is lots of work, so most only implement C and call it quits
04:51:10 <aweinstock> ironChicken: if (mkFoo :: IO Foo) and (useFoo :: Foo -> Bar -> Baz), you can use (do { foo <- mkFoo; {- other stuff goes here to calculate bar -}; return (useFoo foo bar)})
04:51:45 <merijn> argoneus: Which is usually good enough, because since GHC knows how to translate to C and, e.g. python knows how to translate to C too you can call haskell from python by just pretending your calling/being called from C on both sides
04:51:46 <argoneus> merijn: so if there's a super awesome C++ library I want to use, it will be more difficult to bind?
04:52:08 <argoneus> um...
04:52:15 <aweinstock> :t fmap :: (a -> b) -> (IO a -> IO b) -- ironChicken this might also be useful
04:52:16 <merijn> argoneus: Usually you'd wrap the C++ library with a thin C wrapper (actually, usually this has already been done)
04:52:16 <lambdabot> (a -> b) -> IO a -> IO b
04:52:30 <merijn> argoneus: This lets C call the C++ stuff and since haskell can call C...
04:52:46 <argoneus> I see
04:52:56 <argoneus> so same with e.g. lua as well, just write a C wrapper for my lua programs
04:53:01 <argoneus> and then call the C wrapper from haskell
04:53:03 <aweinstock> :t fmap (+42) randomIO
04:53:03 <argoneus> easy
04:53:04 <lambdabot> (Num b, Random b) => IO b
04:53:08 <merijn> argoneus: Yes
04:53:28 <argoneus> that's nice
04:54:01 <merijn> You can have GHC pretending that haskell code is C too, so that you can call haskell from C. Which means you can also call haskell from anything that can call C
04:54:12 <argoneus> this means you can have the cool thing
04:54:34 <argoneus> where you write haskell for convenience and when you have a very implementation specific and performance intensive part you switch to C++ or something
04:54:42 <merijn> yes
04:56:45 <gameer> Hey guys. I have a data structure for trees: data Tree v e = Node v [(e,Tree v e)] .  Node v  is the first node. Then in the List each tuple is an edge with the node after the egde.
04:57:00 <gameer> Now I get an tree as input and i have to work with it
04:57:18 <gameer> How can I work with it? How I can get the first node?
04:57:53 <gameer> (I have to change the values of a Node, so I have to get through all the nodes. I do this revursive but I dont know how to start)
04:58:00 <gameer> recursive*
04:58:13 <Fuco> gameer: I don't want to discourage you, but you seem to be confused about this for a week now.  Why don't uyou try some simpler tasks first to build an intuition for haskell data types?
04:58:14 <liste> gameer pattern matching -- foo (Node val branches) = ... do stuff with val or branches ...
04:58:21 <Fuco> gameer: I feel like whatever we tell you just goes past
04:59:34 * hackagebot ini 0.3.4 - Quick and easy configuration files in the INI format.  https://hackage.haskell.org/package/ini-0.3.4 (ChrisDone)
04:59:49 <gameer> Yeah its true, I have really problems with it
05:01:00 <gameer> I could solve some other tasks with other data structures
05:01:16 <gameer> But I can't find a beginning in this :/
05:02:06 <gameer> So I know what I have to do and how I can get the result(problem was like minimax algorithm), but I am not able to find a beginning. 
05:02:43 <gameer> liste: Pattern matching was my thought,too. But I don't know how I get the really first node
05:04:47 <gameer> Fuco: I will repeat all my learned stuff after this, but I have to solve it until sunday :'(
05:04:57 <gameer> I see, that my skill is not enough..
05:06:39 <aweinstock> @let data AssocTree v e = AssocNode v [(e, AssocTree v e)]
05:06:41 <lambdabot>  Defined.
05:07:50 <aweinstock> @let sampleAssocTree = AssocNode "zero" [(1, AssocNode "one" []), (2, AssocNode "two" [])]
05:07:52 <lambdabot>  Defined.
05:08:49 <aweinstock> :t let sizeAssocTree (assocNode _ subTrees) = 1 + sum (map sizeAssocTree subTrees) in sizeAssocTree
05:08:50 <lambdabot> Parse error in pattern: assocNode
05:08:58 <aweinstock> :t let sizeAssocTree (AssocNode _ subTrees) = 1 + sum (map sizeAssocTree subTrees) in sizeAssocTree
05:08:59 <lambdabot>     Couldn't match type â€˜(t3, AssocTree t2 t3)â€™ with â€˜AssocTree t2 t3â€™
05:09:00 <lambdabot>     Expected type: [AssocTree t2 t3]
05:09:00 <lambdabot>       Actual type: [(t3, AssocTree t2 t3)]
05:09:16 <aweinstock> :t let sizeAssocTree (AssocNode _ subTrees) = 1 + sum (map (sizeAssocTree . snd) subTrees) in sizeAssocTree
05:09:17 <lambdabot> Num a => AssocTree t a1 -> a
05:09:33 <aweinstock> > let sizeAssocTree (AssocNode _ subTrees) = 1 + sum (map (sizeAssocTree . snd) subTrees) in sizeAssocTree sampleAssocTree
05:09:35 <lambdabot>  3
05:09:44 <aweinstock> gameer: ^ does this help?
05:10:31 <aweinstock> @let deriving instance Show AssocTree
05:10:32 <lambdabot>  .L.hs:155:24:
05:10:33 <lambdabot>      Expecting two more arguments to â€˜AssocTreeâ€™
05:10:33 <lambdabot>      The first argument of â€˜Showâ€™ should have kind â€˜*â€™,
05:10:55 <aweinstock> @let deriving instance Show (AssocTree v e)
05:10:56 <lambdabot>  .L.hs:155:1:
05:10:56 <lambdabot>      No instance for (Show v) arising from a use of â€˜showsPrecâ€™
05:10:56 <lambdabot>      Possible fix:
05:11:13 <aweinstock> @let deriving instance (Show v, Show e) => Show (AssocTree v e)
05:11:14 <lambdabot>  Defined.
05:11:23 <aweinstock> > sampleAssocTree
05:11:25 <lambdabot>  AssocNode "zero" [(1,AssocNode "one" []),(2,AssocNode "two" [])]
05:12:49 <aweinstock> @let mapAssocTree f (AssocNode x subTrees) = AssocNode (f x) (map (id *** mapAssocTree f) subTrees
05:12:49 <lambdabot>  Parse failed: Parse error: EOF
05:12:59 <aweinstock> @let mapAssocTree f (AssocNode x subTrees) = AssocNode (f x) (map (id *** mapAssocTree f) subTrees)
05:13:00 <lambdabot>  Defined.
05:13:19 <aweinstock> > mapAssocTree (++"!!!") sampleAssocTree
05:13:20 <lambdabot>  AssocNode "zero!!!" [(1,AssocNode "one!!!" []),(2,AssocNode "two!!!" [])]
05:13:21 <gameer> thanks, I have to understand it a bit
05:15:30 <haskey> Yo. I got this msg, "category theory is hardly relevant when learning FRP"
05:15:48 <haskey> Is that a fair comment?
05:15:58 <haskey> Or totally false
05:16:25 <haskey> Or a bit of both?
05:17:00 <oggy> i have a cabal sandboxed project created with a system-wide ghc 7.10.2 installation; now i updated ghc to 7.10.3; what steps should i take to get the sandbox working with 7.10.3?
05:17:21 <oggy> in particular, to get emacs and haskell-mode + ghc-mod working nicely again?
05:18:34 <destsk> Is there any similarity between let-polymorphism and RankNTypes, or am I misunderstanding/imagining things?
05:19:06 <statusfailed> haskey: ehh.. I guess Elm is FRP, and that certainly doesn't need any category theory
05:21:13 <haskey> statusfailed: But can that be generalised across the broader spectrum of FRP?
05:21:18 <statusfailed> haskey: but I think people use category theory to prove things about FRP, so ... depends what you want to do I guess?
05:21:25 <jle`> haskey: for the most part...using FRP doesn't really require any category theory
05:21:36 <jle`> any more than doing your taxes requires field theory
05:22:21 <jle`> i mean, looking at things through CT eyes might help you appreciate certain things more
05:22:26 <jle`> but that's pretty much it
05:22:31 <statusfailed> jle`: or prove things, or design new FRP system
05:22:51 <jle`> maybe; but those things probably aren't involved in "learning FRP", or using FRP practically in the day-to-day
05:22:53 <statusfailed> but agree with jle` 
05:23:20 <jle`> you can still play a piano without learning how to design/build one
05:23:30 <haskey> statusfailed: Let's reverse the question then - would understanding category theory help in "getting" FRP?
05:23:31 <statusfailed> true :-)
05:24:00 <jle`> are we talking about FRP the concept/denotative semantics, or FRP as in practically using it for making programs?
05:24:09 <statusfailed> I've used Elm a lot, and I have to say I don't know much CT 
05:24:13 <statusfailed> much / any :D
05:24:15 <aweinstock> probably, if you ignored opportunity costs of time for learning CT
05:24:30 <jle`> the actual semantics of FRP don't really obviously suggest CT as a useful basis
05:24:36 <aweinstock> (if you ignore opportunity costs, anything that wouldn't hurt is beneficial)
05:24:51 <jle`> i don't think CT is particularly suited for understanding the semantics of FRP
05:24:54 <jle`> or describing them
05:24:55 <aweinstock> therefore, I suggest learning economics!
05:25:00 <statusfailed> hahaha
05:25:15 <jle`> the original FRP paper is actually pretty succinct and easy to read, and doesn't involve any category theory
05:25:25 <jle`> and that's pretty much the entirety of FRP-the-theory
05:25:40 <jle`> so, I'd say no
05:25:43 <aweinstock> (I'm probably joking, but only mostly)
05:25:55 <statusfailed> jle`: is that by conal elliott? could you link the paper? I'd like to read it!
05:26:11 <jle`> that's the one
05:26:19 <jle`> http://conal.net/papers/icfp97/
05:26:36 <statusfailed> thanks!
05:26:51 <jle`> but yeah, i can't imagine how CT can be useful for understanding or stating the ideas of FRP in any meaningful/deep way
05:26:59 <haskey> jle' the multiplication tables we learn an school as kids do not talk about commutativity
05:27:04 <jle`> you might as well ask if learning about botany is helpful in learning FRP
05:27:35 <jle`> what made you think that CT would be relevant to learning FRP?
05:27:58 <aweinstock> haskey: but they should be symmetric, right?
05:28:28 <aweinstock> (even though they don't explicitly talk about commutativity)
05:28:52 <haskey> jle' I came across CT and FRP at the same time. I am so sorry if I thought they are connected
05:28:55 <jle`> of all the fields of mathematics i would think of to study to help learn FRP, i wouldn't pick category theory ... feels like a kind of random choice
05:29:05 <jle`> no need to be sory! :)
05:29:08 <jle`> was just curious
05:29:30 <jle`> if a link between the two was suggested somewhere
05:30:06 <jle`> if there was a specific branch of mathematics that might aid in FRP research, i might say it's topology
05:30:25 <jle`> but i don't think that's very useful for practical FRP usage in any case
05:31:39 <haskey> jle' I was plain wrong
05:32:43 <haskey> jle' thanks
05:32:43 <jle`> no worries!  for the record, you never claimed there was a link, so i wouldn't call you 'wrong' :)
05:33:33 <haskey> jle' Your not wrong there :)
05:33:46 <haskey> jle' You're not wrong there :) even
05:34:34 * hackagebot strive 2.2.0 - A Haskell client for the Strava V3 API.  https://hackage.haskell.org/package/strive-2.2.0 (fozworth)
05:39:34 * hackagebot argon2 1.0.0 - Haskell bindings to libargon2 - the reference implementation of the Argon2 password-hashing function  https://hackage.haskell.org/package/argon2-1.0.0 (OliverCharles)
05:40:41 <KaneTW> when writing an api to deal with foreign libraries where the IO actions can fail (e.g. due to network issues), is it better to use Either/Maybe or IOError?
05:41:55 <bergmark> KaneTW: https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/exceptions-best-practices.md
05:42:13 <merijn> KaneTW: Personal opinion: Default to Either/Maybe for APIs, exceptions for inside your application
05:42:26 <merijn> Although exposing a throwing version of your API is a welcome addition
05:46:07 <KaneTW> ty
05:50:22 <merijn> Is there a filterM for Traversable?
05:53:38 <ironChicken> Stratege, aweinstock: thanks for your pointers. i think i'm not really asking the right question. i'll have to see if i can tease out the general case from my dense specifics
05:56:18 <nshepperd_> merijn: filterA from Witherable?
05:57:41 <Fuco> hah when I read ironChicken I thought it's some c# version of scheme, and now I see it's a nick...
05:57:45 * Fuco feels silly
05:58:31 <nshepperd_> iron python... chicken scheme... iron chicken!
05:59:35 * hackagebot Verba 0.1.0.0 - A solver for the WordBrain game  https://hackage.haskell.org/package/Verba-0.1.0.0 (Jefffrey)
06:11:35 <bollu> so if I'm understanding the free monad right: you construct a Free f a that lets you imbue any functor "f" with a monad structure. You then make a DSL that is functor with respect to the "next" step (i.e, data DSL next â€¦ deriving(Functor)). 
06:11:56 <bollu> after which you use the Free monad to give a monad structure (do notation, sequencing, etc) to the DSL?
06:12:09 <bollu> the solution is so goddamn elegant. Who came up with it?
06:12:12 <bollu> I'm jealous
06:14:40 <liste> at least edwardk talks about them in http://comonad.com/reader/2008/monads-for-free/, but no idea where they're originally from
06:14:57 <bollu> liste: interesting
06:15:06 <bollu> liste: also, did I get the idea right? or did I miss something?
06:15:24 <bollu> also, I still don't fully undestand how the monadic structure of the Free f and the functor structure of f interact
06:15:27 <merijn> Whoo, despite all the complaints about length being in Foldable, it is magically making my code simple :D
06:15:38 <bollu> I can "implement" them by chasing the types, but I don't think I grok it
06:16:09 <mg_> Hey! I'm trying to learn haskell coming from a python/golang/java/etc world. When learning a new language I usually implement a simple terminal based ascii game, and I'm having some issues with this in haskell. Basically what I want is to have one thread/coroutine/whatever listen for user input (and updates the world based on that input) and a render thread that renders the world every x milliseconds. In go
06:16:11 <mg_> this trivial with goroutines, but how would I approach this in haskell?
06:16:30 <merijn> mg_: Threads?
06:16:33 <liste> bollu yeah, that's a typical use case for free monads
06:16:39 <bollu> liste: hm, I see
06:16:42 <mg_> I'm sorry if this is the wrong place to ask
06:16:48 <merijn> mg_: Check out Simon Marlow's Parallel & Concurrent Haskell book :)
06:16:53 <bollu> liste: questions; doesn't anything of kind * -> * have a Functor on it?
06:17:04 <bollu> (like, trivially)
06:17:07 <merijn> mg_: (GHC) Haskell has lightweight threads comparable to goroutines
06:17:11 <merijn> :t forkIO
06:17:12 <lambdabot> Not in scope: â€˜forkIOâ€™
06:17:21 <aweinstock> @let import Control.Concurrent
06:17:23 <lambdabot>  Defined.
06:17:28 <aweinstock> :t forkIO
06:17:29 <lambdabot> IO () -> IO ThreadId
06:17:38 <aweinstock> :t (newChan, readChan, writeChan)
06:17:39 <merijn> mg_: Check out the Control.Concurrent section from base (in addition to the aforementioned book)
06:17:40 <lambdabot> (IO (Chan a), Chan a1 -> IO a1, Chan a2 -> a2 -> IO ())
06:17:43 <merijn> bollu: And no
06:17:50 <bollu> merijn: counterexample?
06:17:50 <mg_> merijn: ok thanks! I'll have a look
06:18:06 <liste> @let data AntiFunc a b = AntiFunc (b -> a)
06:18:07 <lambdabot>  Defined.
06:18:09 <aweinstock> mg_: Control.Concurrent has Channels
06:18:13 <merijn> bollu: "newtype Foo a = Foo { runFoo :: a -> Int}"
06:18:40 <merijn> mg_: I would say writing concurrent software in haskell is as easy, if not easier than in Go :)
06:18:52 <bollu> merijn: hm, right. That would have a Profunctor instance right?
06:19:00 <geekosaur> bollu, for what it's worth the free monad showed up first as http://hackage.haskell.org/package/MonadPrompt
06:19:01 <merijn> bollu: It's actually Contravariant
06:19:18 <bollu> geekosaur: ty :)
06:19:36 * hackagebot feed 0.3.11.0 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-0.3.11.0 (AdamBergmark)
06:19:38 <bollu> merijn: yes, so that's what a profunctor is, correct? (a -> b) -> ( b -> f a)
06:19:43 <merijn> bollu: "contramap :: (a -> b) -> f b -> f a"
06:19:46 <bollu> (a -> b) -> (f b -> f a)**
06:19:57 <merijn> bollu: I think profunctors are both functors and contravariant?
06:20:01 <bollu> oh wait, a profunctor needs both the co-and the contra
06:20:01 <merijn> Not 100% sure
06:20:02 <RyanGlScott> bollu: (Almost) anything of kind * -> * does have an Invariant instance
06:20:03 <mnoonan> You could do "data Selfie t = Selfie t -> t"
06:20:05 <bollu> yeah, I mis remembered
06:20:19 <bollu> RyanGlScott: what's Invariant?
06:20:22 <RyanGlScott> class Invariant f where invmap :: (a -> b) -> (b -> a) -> f a -> f b
06:20:26 <mnoonan> neither a co- nor contra-variant functor
06:20:32 <RyanGlScott> See the invariant package on Hackage (disclaimer: I maintain it)
06:20:59 <bollu> RyanGlScott: oh, given both you can construct the covariant mapping? hm, interesting
06:21:23 <RyanGlScott> One thing I've been curious about for a while is if there's an invariant equivalent of Applicative
06:21:58 <RyanGlScott> There's Applicative (for things in covariant positions) and Divisible from the contravariant package (for contravariant positions)
06:21:59 <gameer> aweinstock: For me, your example for the Trees is complex, too :|
06:22:14 <RyanGlScott> Could you meld them together Ã  la Invariant?
06:22:26 <mnoonan> RyanGlScott: what kind of structure do Invariant types have? e.g. for functors X -> Y you can get the functor category [X,Y].. any analog?
06:22:26 <bollu> what's an F-algebra?
06:22:32 <bollu> (ELI know what a functor is)
06:22:42 <gameer> I have as input only a tree, bur ur example functions sizeAssocTree and mapAssocTree have more imputs
06:22:42 <aweinstock> gameer: is there anything simpler that I could implement on them, or anything specific I should explain about them?
06:22:57 <mnoonan> bollu: a type X and a function F X -> X
06:23:01 <mnoonan> (F a functor)
06:23:03 <gameer> Am I allowed to write u im a query?
06:23:08 <gameer> in*
06:23:23 <RyanGlScott> mnoonan: I know extremely little category theory, all I know is from this article: http://comonad.com/reader/2008/rotten-bananas/
06:23:36 <bollu> mnoonan: oh, so something that can take stuff out of a functor? mnoonan: won't anything with a monoid instance be an F-algebra?
06:24:01 <aweinstock> gameer: yes, and I don't think you need permission to /query people on IRC
06:24:04 <merijn> If I'm generating a bunch of String and outputting to a handle, would it be faster to encode to Text/ByteString before outputting or does it not matter?
06:24:18 <bollu> instance Monoid a => Falgebra a farrow fa = mempty ?
06:24:20 <merijn> aweinstock: It's considered polite not to PM random people without asking
06:24:21 <mnoonan> bollu: for a specific F. The idea is that the functor describes the structure of the operations, and the choice of X and F X -> X implements those operations on X
06:24:32 <merijn> aweinstock: I generally don't check PMs of people I don't know, for example
06:24:36 * hackagebot dawg-ord 0.2 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.2 (JakubWaszczuk)
06:24:44 <bollu> mnoonan: um, concrete example?
06:24:45 <aweinstock> merijn: ah, I wasn't aware of that
06:24:53 <bollu> merijn: oh, why not?
06:25:49 <merijn> bollu: I talk a lot, which occasionally gets me random PMs from people to solve their homework/help with something completely irrelevant/etc./easier to just ignore everything :p
06:25:59 <bollu> merijn: ah, fair enought :P
06:26:02 <bollu> enough*
06:26:35 <mauke> /umode +g
06:26:55 <merijn> Also, it's generally considered better to keep questions in the channel where the answer can help others
06:27:24 <bollu> wait, so for an f-algebra, I need a functor f, and a function g :: f a -> a for all a? for all f? for all a AND f?
06:27:29 <bollu> what's the restriction on g here?
06:27:38 <mnoonan> bollu: F-algebra of Int lists, say. Take "data F t = Nil | Cons Int t deriving Functor"
06:27:49 <mnoonan> you get to pick a and g
06:28:37 <mnoonan> you can make [Int] a F-algebra for the above F by picking a = [Int], g : F [Int] -> [Int] by:
06:28:43 <mnoonan> g Nil = []
06:28:59 <mnoonan> g (Cons n ns) = n:ns
06:29:14 <bollu> so, I'm construct an F-algebra of [] or for [Int]?
06:29:58 <Stratege> mnoonan the above wouldn't typecheck it needs to be ++ not :
06:29:59 <mnoonan> for that F, the function g : F [Int] -> [Int] describes an F-algebra on [Int].
06:30:13 <Stratege> oh sorry it does, my bad
06:30:55 <bollu> mnoonan: oh, so the F-algebra is for the F in combination with [Int], right? I need to show the existence of g
06:31:21 <bollu> so, given a functor F, and a type a, if I can show the existence of g :: F a -> a, then (F a) is an F-algenra?
06:31:32 <mnoonan> well, g is part of the data too
06:31:40 <mnoonan> you could have multiple valid ways to define g
06:31:52 <bollu> mnoonan: right, so, (F a, g) is the F-algebra?
06:31:55 <mnoonan> yeah
06:32:00 <bollu> ah, cool, thanks :)
06:32:19 <bollu> mnoonan: any laws that g should hold? as in, should be a homomorphism or something?
06:32:45 <mnoonan> nope! it's just the implementation on X of the operations that F defines.
06:33:14 <bollu> wait, so something like g :: F [Int] -> [Int], where g _ = [] is also valid?
06:34:26 <mnoonan> yeah, I think so
06:35:19 <bollu> hm, but for it to be an F-homomorphism it needs the diagram to commute (according to what I'm reading): http://chrislambda.github.io/blog/2014/01/30/catamorphisms-in-15-minutes/
06:35:43 <bollu> I want to study category theory properly but reading it through books suck because it's so frikkin abstract
06:35:52 <bollu> I wish someone did a category theory through Haskell or something
06:36:12 <mnoonan> I think you're talking about morphisms between F-algebras, not the actual functions that make up the F-algebras
06:37:05 <bollu> mnoonan: oh crap, right. We're in the category of F-algebras
06:37:11 <mnoonan> bollu: bartoz's blog is pretty close to "category theory through haskell" (http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)
06:37:24 <Hiro`> Hey everyone, given a string that might be a directory or a file, is there a nice way to check and return a boolean?
06:37:25 <bollu> whoa, neat
06:37:30 <bollu> I shoud read it!
06:37:55 <bergmark> Hiro`: check the filepath package
06:38:00 <bollu> https://hackage.haskell.org/package/filepath-1.4.0.0/docs/System-FilePath.html
06:38:02 <bollu> Hiro`: ^
06:39:44 * hackagebot dawg-ord 0.3 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.3 (JakubWaszczuk)
06:39:58 <Hiro`> bergmark: thanks
06:39:58 <bollu> doesn't the category of F-algebras look like this: Object = (F a, g), arrow: (Fa , g) -> (F' b, g') ?
06:41:02 <Hiro`> bollu: System.Filepath doesn't actually have an isDirectory predicate, though it seems like it used to.
06:41:02 <mnoonan> it depends on what you mean by "->" there :)
06:41:16 <bollu> mnoonan: maps :)
06:42:26 <Hiro`> there's an isDirectory is System.Posix.Files.ByteString, but this has a different type.
06:42:34 <ironChicken> heh
06:42:47 * ironChicken has actually written some chicken scheme in the past
06:42:57 <bollu> Hiro`: https://hackage.haskell.org/package/turtle-1.2.5/docs/Turtle-Prelude.html. Turtle has a testdir
06:43:09 <bollu> Hiro`: but using Turtle for what you're doing maybe overkill
06:43:16 <mnoonan> the morphisms are (regular old) maps f : a -> b, such that g' . fmap f = f . g :: F a -> b
06:43:49 <bollu> mnoonan: oh, the morphisms are the ones that can respect the F-algebra structure between objects?
06:43:56 <mnoonan> exactly
06:44:03 <bollu> mnoonan: so different objects all have the same underlying "a" ?
06:44:15 <bollu> oh no, they don't need to
06:44:17 <bollu> because we're fmapping
06:44:18 <bollu> hm
06:44:59 <bollu> oh, I get it. Since the F-algebra lets you "lower" from FA -> a, the arrow needs to respect both the F-algebra and the "punched through" version (without the f)
06:45:16 <bollu> mnoonan: thanks :)
06:45:30 <bollu> mnoonan: for my own reference, where did you learn category theory from?
06:46:02 <mnoonan> picked up in bits and pieces during a PhD in differential geometry. I don't recommend that approach :)
06:46:13 <KaneTW> is there a lifted version of withForeignPtr
06:46:17 <bollu> mnoonan: that's pretty cool though :P
06:46:22 <KaneTW> :t withForeignPtr
06:46:24 <lambdabot> Not in scope: â€˜withForeignPtrâ€™
06:46:33 <bollu> mnoonan: I want to learn GR someday. 
06:46:38 <bollu> mnoonan: so diff geo awaits.
06:46:42 <KaneTW> withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
06:46:44 <mnoonan> but actually messing around with Haskell has helped solidify a bunch of it for me
06:46:58 <KaneTW> except IO is replaced with some sufficient monad
06:47:21 <Fuco> bollu: it's category of F algebras because the F doesn't change. It determines the category
06:47:52 <bollu> Fuco: oh thanks, that helps a ton
06:48:25 <Fuco> you need to burn this image in your brain: https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/F_algebra.svg/188px-F_algebra.svg.png :D
06:48:30 <bollu> Fuco: the F-algebra uniquely determines the function F a-> a? or does different choices of "a" let you pick different F a -> a?
06:48:44 <merijn> There's no strict hGetContents unless I use strict Text/ByteString, right?
06:48:45 <bollu> Fuco: the diagram answered my question :P
06:48:51 <Fuco> F gives you the shape, you can use any 'a' there
06:48:52 <bollu> Fuco: there's an alpha and a beta. 
06:48:56 <Fuco> but the initial algebra is unique
06:49:13 <Fuco> alpha and beta are the "constructors" of the algebra
06:49:42 <bollu> Fuco: so which are the objects of the F-algebra?
06:49:46 * hackagebot Verba 0.1.0.1 - A solver for the WordBrain game  https://hackage.haskell.org/package/Verba-0.1.0.1 (Jefffrey)
06:49:51 <bollu> like, in the category of the F-algebras
06:50:03 <Fuco> F-algebras are the objects
06:50:03 <bollu> what are the objects and what are the morphisms? (the commute diagram doesn't tell you that)
06:50:18 <Fuco> the diagram tells you that, F(A) and F(B) are objects
06:50:30 <bollu> Fuco: but the diagram has A and B as well
06:50:38 <roelof> Hello, I have this file : https://github.com/rwobben/paytime/blob/master/paytime/src/Lib.hs 
06:50:40 <Fuco> well no, A and B are objects, sorry
06:50:43 <Fuco> with their maps
06:50:44 <bollu> Fuco: â€¦ I now realize that I've never been formally taught how to read commute diagrams
06:51:04 <Fuco> (A,alpha) is an algebra... but we often say A is algebra or alpha is algebra...
06:51:10 <Fuco> it's a bit confusing when reading papers ;D
06:51:30 <roelof> Now I think that Account can better be a map instead of a Array. How can I deal the best to make this work ? 
06:51:38 <mnoonan> The objects are the pairs of A and g :: F A -> A, and the arrows from (A,g) to (B,g') are (determined by) functions f :: A -> B
06:51:44 <bollu> Fuco: so, (A, alpha) is an object in the algebra, along with (B, beta)? and Hom((A, alpha), (B, beta)) has f in it?
06:51:54 <Fuco> object in the F-algebra cateogry
06:52:06 <Fuco> objects of the algebra are the elements of the set A
06:52:12 <Fuco> and alpha has the shape of the functor
06:52:19 <bollu> Fuco: right, I mean F-algebra.
06:52:35 <Fuco> consider functor F(X) = 1 + X
06:52:38 <bollu> okay
06:53:09 <bollu> Fuco: go on :)
06:53:09 <Fuco> in haskell data X = zero | next X
06:53:32 <bollu> right
06:54:02 <Fuco> now you need to construc the functions 
06:54:40 <Fuco> how do you extract from that an element
06:54:46 <Fuco> zero has no input so it's just a constant
06:54:46 * hackagebot dawg-ord 0.3.1 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.3.1 (JakubWaszczuk)
06:54:59 <Fuco> next has one input so it's an unary function X -> X
06:55:22 <Fuco> zero you can imagine is 1 -> X (choice of an element of the set)
06:55:42 <bollu> Fuco: functions from what to what?
06:55:55 <Fuco> well F is a functor C -> C
06:56:05 <Fuco> so some object of C to some object of C
06:56:30 <Fuco> F(A) is also an object of C
06:57:21 <bollu> Fuco: um, I'm sorry, but.. can you back up a little? so F is an endofunctor?
06:57:22 <Fuco> here I have a write up if you are interested: https://is.muni.cz/th/324754/fi_m/goljer_master_thesis.pdf
06:57:27 <bollu> yes, please
06:57:41 <Fuco> it has examples as well, and some real life usage :D
06:58:11 <bollu> ooh, thanks!
06:58:12 <mnoonan> bollu: F has to be an endofunctor so you can make a function F(A) -> A; A and F(A) have to be objects in the same category.
06:59:02 <bollu> mnoonan: but.. F(A) is some other object right? I don't how it's "endo"
06:59:09 <Fuco> I guess chapter 3.1 is where you could start
06:59:26 <Fuco> F is just a function between objects of the cateogry, it gives you back an object
06:59:28 <Fuco> imagine C = Set
06:59:30 <mnoonan> it's confusing coming from a Haskell perspective, because the Functor typeclass actually consists of endofunctors on Hask
06:59:40 <Fuco> A is a Set, F(A) is also a Set
06:59:47 <bollu> Fuco: but it's a functor, it should be between categories
06:59:53 <Fuco> it is, from Set to Set
06:59:54 <bollu> oh right, ues
06:59:56 <bollu> ahh
07:00:13 <Fuco> in the thesis I deal with Rel (category of Relations) but it's mostly the same
07:02:13 <bollu> kinda unrelated, but does anyone know of any companies / colleges that offer summer internships in type theory, haskell, FP, or related things?
07:02:56 <Fuco> actually, 3.1.3 deals right with the modeling of types, so you can jump right there
07:04:25 <bollu> Fuco: why do you use an inverted arrow?
07:04:27 <bollu> for the functor?
07:04:28 <bollu> C <- D
07:04:41 <Fuco> I use it everywhere, it's a convention in some circles
07:04:52 <bollu> Fuco: oh, I see. which circles would that be?
07:04:54 <Fuco> it allows nicer composition when you deal with relations
07:05:07 <Fuco> the people at oxford mostly
07:05:14 <bollu> huh, I see
07:05:26 <KaneTW> ugh
07:05:31 <KaneTW> all of these FFI operations can fail
07:05:47 <roelof> Hello, I have this file : https://github.com/rwobben/paytime/blob/master/paytime/src/Lib.hs 
07:05:49 <roelof> Now I think that Account can better be a map instead of a Array. How can I deal the best to make this work ? 
07:05:50 <KaneTW> but i con't tell when that's common enough to warrant a Maybe
07:06:22 <bollu> oh, so a natural transformation is basically a homomorphism of categories "through" a functor?
07:06:41 <Fuco> homomorphism of functors (or morphism in the functor category)
07:07:15 <bollu> oh, I see
07:07:40 <bollu> hm, so it's nat :: Functor f, Functor g => phi :: forall a. f a -> g a?
07:08:41 <Fuco> hm, I'm not quite sure if that's enough
07:08:57 <bollu> what am I missing?
07:09:32 <Fuco> right, that should do except you also need the associated laws
07:09:42 <bollu> oh, yes :)
07:09:50 <bollu> but there's no way I can give those laws in haskell
07:10:07 <Fuco> if you have h :: a -> a  it has to commute with fmap h on f/g
07:10:17 <Fuco> true, you just need to make sure it works
07:10:39 <bollu> f/g? is there some sort of functor quotient?
07:10:54 <Fuco> no, sorry... f and g 
07:11:03 <bollu> oh, you mean and :)
07:11:13 <bollu> sorry about that, I'm just not familiar with category theory
07:11:15 <Fuco> there's an example in set
07:11:29 <Fuco> you can imagine map and concat in haskell
07:11:34 <Fuco> and lists
07:12:00 <bollu> ty
07:12:12 <Fuco> map f . concat = concat . map (map f)
07:12:17 <Fuco> concat is natural transformation
07:12:18 <sphinxo> Could anyone give me some feedback on my use of arrows? http://lpaste.net/148658
07:12:56 <Fuco> f is the arrow [a] -> [b] in the category (in haskell Hask)
07:13:15 <bollu> :t concat
07:13:17 <lambdabot> Foldable t => t [a] -> [a]
07:13:32 <bollu> > concat Just [1, 2, 3]
07:13:33 <lambdabot>      Couldn't match expected type â€˜[Integer] -> tâ€™
07:13:34 <lambdabot>                  with actual type â€˜[a0]â€™
07:13:34 <lambdabot>      The function â€˜concatâ€™ is applied to two arguments,
07:13:46 <bollu> > concat $ Just [1, 2, 3]
07:13:49 <lambdabot>  [1,2,3]
07:13:55 <bollu> hm
07:14:03 * oish waves
07:14:26 <frerich> > concat ([1,2,3],[4,5,6])
07:14:28 <lambdabot>  [4,5,6]
07:14:55 <oish> having a brain futz, trying to implement the credit card equation per: https://www.vcalc.com/wiki/KurtHeckman/Credit+Card+Equation
07:15:13 <oish> But dont' seem to be able to get my brackets right
07:15:15 * hackagebot Verba 0.1.0.2 - A solver for the WordBrain game  https://hackage.haskell.org/package/Verba-0.1.0.2 (Jefffrey)
07:15:32 <Cir0X> Hey how do I convert an Float to String? http://lpaste.net/148660
07:15:48 <bollu> Cir0X: read should work
07:15:51 <bollu> > read 100.25
07:15:53 <lambdabot>      Could not deduce (Fractional String)
07:15:53 <lambdabot>        arising from the literal â€˜100.25â€™
07:15:53 <lambdabot>      from the context (Read a)
07:15:57 <oish> I have: n apr b p = (-1/30) * log (1 + (b / p)) * (1 - (1+i) ** 30) / log (1+i)
07:16:08 <sphinxo> bollu: Not show?
07:16:19 <oish> anyone see where I messed up?
07:16:22 <bollu> sphinxo: oh wait, sorry :P It is show
07:16:26 <sphinxo> Cir0X: I think you need show 
07:16:29 <bollu> > show 100.24
07:16:31 <lambdabot>  "100.24"
07:16:50 <sphinxo> > read $ show 3 :: Int
07:16:52 <lambdabot>  3
07:17:41 <bollu> Fuco: that commuting diagram for fold feels like cheating :P
07:18:21 <lyxia> oish: log ( 1 + (b / p) * (1 - (1 + i) ** 30) ) / log (1 + i)
07:18:23 <Cir0X> bollu: So I'm using show.. What am I doing wrong?
07:19:35 <sphinxo> Cir0X: You need an equals? Cir0X 
07:19:46 <sphinxo> oh wait dw
07:20:07 <frerich> Cir0X: You need to also put a constraint on 'Show a' in addition to 'RealFloat a'. The latter does not imply the former.
07:20:46 <oish> lyxia: hmmm , that gives NaN when called with for eg. 12 5000 100
07:20:49 <Fuco> bollu: which one? 
07:20:58 <oish> presumably cos of a negative number in the calculation
07:21:02 <bollu> Fuco: the last one, about the existence of a fold
07:21:37 <oish> lyxia.
07:22:01 <oish> lyxia: hang on -- works with 0.12 instead of 12, doh! thanks :))
07:22:41 <lyxia> yw
07:22:52 <Fuco> bollu: do you mean 3.10?  That's just a definition so no cheating there:D
07:23:48 <Fuco> if you mean 3.11 that is indeed neat ;D
07:24:09 <bollu> Fuco: yes, 3.11 :)
07:24:28 <bollu> Fuco: I can't wait to show this to a math prof at uni who uses Haskell as well. He'll like it
07:24:47 <Fuco> sweet 
07:24:58 <Cir0X> frerich: I didn't know that's possible, thanks a lo!
07:25:13 <Spacework> Clint, mp.
07:25:16 * hackagebot engine-io-yesod 1.0.4 -   https://hackage.haskell.org/package/engine-io-yesod-1.0.4 (TimBaumann)
07:25:22 <python476> funny, on /r/maths, almost no teacher mentioned haskell when asked (mostly applied numerical like R, numpy, few mathematica)
07:27:14 <bollu_away> python476: yeah, I was surprised he knew Haskell as well. Apparently he used to be a comp sci person before who then switched to math
07:28:12 <sphinxo> Anybody got any feedback for this? http://lpaste.net/148658
07:33:03 <lyxia> sphinxo: if you're just trying to optimize Push+Pop pairs away, you can optimize the tail recursively first, and then match on the head of the optimized result.
07:35:04 <lyxia> I guess that extends to Set+Set too. I'm just not sure when exactly my method stops working.
07:35:50 <ggole> sphinxo: in the Set/Set case, why do the values need to be the same?
07:36:14 <sphinxo> Good point :)
07:36:53 <ggole> You can also optimise operations per register between any pairs of instructions between which there are no interfering instructions
07:37:00 <ggole> (Which will need a different design.)
07:37:29 <frerich> sphinxo: Your 'Set' optimization actually drops 'Set' calls, that seems wrong. You should just keep the last Set.
07:37:29 <sphinxo> What would that look like? ggole 
07:37:53 <sphinxo> good catch frerich 
07:38:38 <ggole> Probably a table mapping an register to information about the value in the register
07:38:56 <lyxia> sphinxo: http://lpaste.net/148662
07:39:20 <ggole> Eg, this register is just a copy of that one, has not been read, etc
07:39:46 <ggole> This gets fun when you have control flow, but it should be easy for straight line code
07:39:58 <sphinxo> lyxia: does that match symetrically? 
07:41:27 <sphinxo> Ahh I see what it does
07:41:47 <sphinxo> That's neat
07:42:36 <frerich> sphinxo: If you find that a register is first zeroed out and then repeatedly added (e.g. 'Set r0 0;Add r0 r1;Add r0 r1;Add r0 r1;Add r0 r1') you could optimize that to a multiplication
07:43:08 <ggole> Or strength reduce a mul by 2 to an add
07:43:11 <ggole> etc, etc
07:44:22 <_JKL_> how Data.MemoCombinators memoSecond should work or used? Can i make a memo table with a single argument without caring others?
07:44:50 <dbp> I'm getting multiple definitions linking errors when trying to build hslua. Anyone have pointers of what to do to track this down / fix it? Environment is a circleci box (which is ubuntu): http://paste.ubuntu.com/14438545/
07:44:53 <sphinxo> strength reduce?
07:44:56 <lyxia> sphinxo: uniplate is a useful library for this kind of optimization by pattern matching.
07:45:01 <frerich> sphinxo: I guess in general it would be cool if you had a way to denote such 'rules' and then a generic function which applies a rule to some program, generating a new program.
07:45:16 * hackagebot lmonad 0.1.0.0 - LMonad is an Information Flow Control (IFC) framework for Haskell applications.  https://hackage.haskell.org/package/lmonad-0.1.0.0 (jp_rider)
07:45:28 <sphinxo> that's a very cool idea frerich 
07:45:35 <frerich> sphinxo: There's a program called 'hlint' which proposes improvements to your Haskell program. It has a lot of such 'rewrite rules' and they are defined in av ery nice manner. See e.g. https://github.com/ndmitchell/hlint/blob/master/data/Default.hs#L89
07:46:13 <frerich> sphinxo: Or https://github.com/ndmitchell/hlint/blob/master/data/Default.hs#L187
07:46:27 <frerich> It very declarative, but actual Haskell code.
07:51:29 <frerich> sphinxo: A while ago I was toying with a BF interpreter and implemented a simple optimization phase. The code is at https://github.com/frerich/brainfuck/blob/master/src/Data/Language/Brainfuck/Optimizer.hs -- the idea is that an Optimization is a function Program -> Program and then all the individual optimizations are separte functions. For instance, this is the optimization which drops additions/subtractions of zero:
07:51:35 <frerich> https://github.com/frerich/brainfuck/blob/master/src/Data/Language/Brainfuck/Optimizer.hs#L54
07:51:49 <frerich> I didn't really finish it, but maybe that's some inspiration.
07:52:06 <sphinxo> That's awesome
07:57:02 <fractalsea> I have written a new data structure for my application, but have problems with latencies. In threadscope I see this is from the garbage collections it causes (they are not there without it). What I see is very quick collections, that get slower and slower to ther point there is <20% productivity, at which point there is a gen 1 collection, and the process starts again. I looked in the myprog.prof file, but this shows t
07:57:03 <fractalsea> datastructure as only allocating 0.8% of the total bytes allocated. This makes me suspect itâ€™s to do with the number of objects/complexity of the data structure rather than its size in bytes. Is there any way I can profile the number of objects on the heap, rather than the raw size in bytes?
07:58:54 <sphinxo> frerich: What does foldProgram do?
07:59:05 <sphinxo> Enters loops?
08:00:13 <frerich> sphinxo: Right - in this language, you can have loops which contain sequences of instructions to be executed repeatedly. Since see https://github.com/frerich/brainfuck/blob/master/src/Data/Language/Brainfuck/Types.hs for the simple types.
08:00:36 <frerich> sphinxo: 'foldProgram' recursively applies a 'Program -> Program' function (e.g. an Optimization).
08:00:52 <sphinxo> ahh
08:01:29 <frerich> sphinxo: The actual function which optimizes everything is then https://github.com/frerich/brainfuck/blob/master/src/Data/Language/Brainfuck/Optimizer.hs#L27 -- it applies all the optimizations one after the other (not very clever). You can read "foldr (.) id" as "compose", i.e. it composes a list of functions.
08:01:54 <frerich> sphinxo: So in this code, each optimization does one pass over the program. The reason for this is that the optimizations tend to interact, i.e. some work better when you first apply others.
08:02:31 <sphinxo> ahh ok
08:02:49 <frerich> sphinxo: In your case, imagine 'Set a 0; Push b; Pop b; Set a 1'. The fact that the two 'Set' instructions can be merged is only apparent after dropping the Push/Pop sequence.
08:03:48 <ggole> frerich: that won't catch Set a 0, Set b x, Set a k, <list in which b is used>
08:04:06 <ggole> Or any number of other cases
08:04:29 <frerich> ggole: Hm? Not sure how what I wrote relates to what you wrote. Or are you not referring to Push/Pop?
08:05:22 <aweinstock> frerich: [Set b x, Set a y] == [Set a y, Set b x] if a/=b
08:05:36 <aweinstock> Set's to disjoint registers commut
08:05:37 <aweinstock> e
08:06:03 <frerich> aweinstock: That's right, but I still don't see how that relates to Push/Pop :-)
08:06:08 <ggole> frerich: I'm suggesting that relying on eliminating instructions and adjacency is missing many opportunities
08:06:15 <frerich> ggole: If course
08:06:28 <frerich> ggole: I gave an example of how the code sphinxo posted misses an optimization.
08:07:05 <aweinstock> [Set a 0, Set b x, Set a k, Use b] can be optimized to [Set a k, Set b x, Use b]
08:07:31 <aweinstock> but that can be done in your framework with a pass that randomly permutes commutative operations :)
08:07:40 <ggole> The "right" way to do this (at least, a more aggressive way) is to keep a table of so-far unused registers
08:07:41 <aweinstock> (there's probably much better ways)
08:08:00 * frerich wonders whether you guys are talking abotu the BF links I posted or the code sphinxo posted with the registers...
08:08:09 <frerich> There are two languages here :-)
08:08:25 <ggole> And when you have a definition of a register, mark the defining instruction dead if it is unused (and has no effects)
08:10:39 <frerich> ggole: I think in sphinxo your table of scratch registers would be quite small. There are only two registers in total. :-)
08:11:12 <ggole> Yeah
08:14:47 <hc> what's the recommended way to load a pkcs8 private key in der format into haskell?
08:15:07 <hc> to be used for https://hackage.haskell.org/package/crypto-pubkey-0.2.8/docs/Crypto-PubKey-DSA.html#t:PublicKey
08:15:26 * hackagebot Verba 0.1.0.3 - A solver for the WordBrain game  https://hackage.haskell.org/package/Verba-0.1.0.3 (Jefffrey)
08:43:33 <sbrg> I have a student that is having problems dealing with cabal hell when trying to install quickcheck. I hven't had to deal with it for a while now and I don't quite remember the steps and google isn't really helping. What is the quickest way I can get him up and running with a working quickcheck?
08:45:00 <glguy> cabal install QuickCheck, is the quickest way to get QuickCheck installed.
08:45:14 <sbrg> I know. this fails due to a number of version conflicts
08:45:34 <glguy> You can unregister the old versions of things and reinstall against the new versions of things
08:46:26 <SiIky> is there a pre-defined function (similar to fitler) but :: (a -> Bool) -> [a] -> ([a],[a])
08:46:38 <glguy> :t partition
08:46:40 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
08:46:53 <SiIky> glguy: thx (y)
08:47:08 <mfitton> Gah these parentheses are killing me
08:47:27 <mfitton> I hope I get better at grouping expressions so I stop having to recompile again and again
08:51:13 <glittershark> is there a version of `zip` that takes a default value and uses it for when one of the lists is short?
08:51:19 <glittershark> or would I have to write that myself?
08:51:23 <glguy> Not in base, at least
08:51:29 <glittershark> mmk
08:51:45 <glittershark> I'm already depending on classy-prelude and friends
08:51:52 <glittershark> don't know if that has it
08:51:55 <glittershark> probably not, if base doesn't
08:51:59 <glguy> me neither
08:52:18 <glittershark> oh hey
08:52:19 <glittershark> http://stackoverflow.com/questions/21349408/zip-with-default-value-instead-of-dropping-values
08:52:23 <glittershark> nice
08:54:18 <glguy> glittershark: You'd probably do better to write it out than to copy any of those
08:57:25 <quchen_> Is the Stack binary directory configurable somewhere?
08:57:42 <quchen_> stack path allows viewing, but apparently not modifying, the paths.
08:58:46 <cdepillabout> quchen_: If you do `stack --help`, you can see there is a global option --local-bin-path.
08:58:52 <cdepillabout> That's what you're looking for, right?
08:59:31 <quchen_> Oh, that's where the setting is? Interesting, let's see where the config file for that is so I can put it in my dotfiles
09:03:45 <cdepillabout> quchen_: Yeah, I always assume it will be in the output of `stack install --help`, and it's not, and I always fumble around trying to find it.  I've done it enough times now that I remember it's in `stack --help`.
09:05:51 <quchen_> cdepillabout: Hmpf, unfortunately I have to provide this flag on every installation. I can put "local-bin-path" in my global stack.yaml, but I can't use environment variables like $HOME there.
09:07:09 <cdepillabout> quchen_: I guess you could use something like a bash alias if you're calling it from the command line frequently.
09:08:11 <quchen_> cdepillabout: That's only a workaround though :-|
09:08:48 <cdepillabout> quchen_: Yeah :-\
09:20:39 * hackagebot Verba 0.1.0.4 - A solver for the WordBrain game  https://hackage.haskell.org/package/Verba-0.1.0.4 (Jefffrey)
09:25:40 * hackagebot errors 2.1.0 - Simplified error-handling  https://hackage.haskell.org/package/errors-2.1.0 (GabrielGonzalez)
09:27:01 <fractalsea> Is it usual for the GC to get slower and slower as the generation 0 heap gets filled up?
09:27:14 <fractalsea> Thatâ€™s what Iâ€™m seeing in threadscope before there is a gen 1 collection
09:30:42 <wz1000> I'm getting this bug closed in Aug 2015 on stack 1.0 https://github.com/commercialhaskell/stack/issues/769
09:31:21 <muzzle> Hi, I'm just curious is there any reason, why the createFile function is no longer in the directory package?
09:34:04 <maerwald> don't use the directory package, it's inconsistent and does weird things
09:34:22 <muzzle> maerwald, what's a better alternative?
09:34:29 <quchen_> maerwald: What should we use instead?
09:34:49 <maerwald> code that doesn't pretend to be cross-platform
09:34:59 <maerwald> so use the low-level posix functions if you can
09:36:07 <quchen_> What's wrong with cross-platform? Directories seem to be something we should be able to do regardless of OS.
09:36:18 <maerwald> what if the directory is a symlink?
09:36:47 <maerwald> so you want to delete it... does the library delete the contents or the symlink file?
09:40:56 <quchen_> maerwald: I don't know, but that's something the function could say, no?
09:41:06 <maerwald> and is the behavior the same on windows?
09:41:17 <quchen_> I don't know enough about Windows shortcuts
09:41:26 <quchen_> Why is there a problem with this there?
09:42:15 <maerwald> you are relying on the library to do something sane where there is no consistent common concept
09:42:37 <maerwald> that works for trivial high-level operations, but not much more
09:42:53 <koala_man> Windows has proper symlinks, and they're not the same as shortcuts
09:43:01 <quchen_> Hm, so the solution would be writing my own wrapper libraries in my project?
09:43:15 <quchen_> Ones that I can control the behaviour of?
09:44:05 <maerwald> well, I am writing a filemanager currently and I ended up removing any usage of the directory package... so I don't pretend to be windows compatible until I have actually written code for it where I am sure what it does under what circumstance
09:44:24 <maerwald> and the directory package even causes trouble on unix with symlinks
09:46:14 <maerwald> if you don't care about the details, it's probably fine. But as soon as you get into "delete something" land, you want to be sure what happens
09:50:29 <muzzle> thanks maerwald
10:09:20 <argoneus> this book is triggering me
10:09:31 <argoneus> http://puu.sh/moh9g/364f9487ee.png
10:09:42 <argoneus> I don't have that button on my keyboard ._.
10:10:17 <Wizek> Hello! On linux what are some good ways (or perhaps the best way?) to have multiple GHC versions installed at once and simply be able to switch between them?
10:10:21 <Encapsulation> Ezekiel 23:19-20
10:10:27 <Encapsulation> see the light, my friends
10:10:28 <johnw> Wizek: Nix
10:10:39 <argoneus> Encapsulation: what
10:11:15 <argoneus> is this a bot
10:11:37 <Wizek> johnw, really? I've tried using nix before, but couldn't make it work and I have some uncertainty about it. Have you much experience with it?
10:11:38 <monochrom> Wizek: ./configure --prefix=/usr/local/ghc-7.50.4124 and play with PATH
10:12:14 <johnw> Wizek: I've been using it as my only package manager for almost two years now, and I use it to work with 3 different versions of GHC, 3 versions of Coq, and 3 versions of Emacs, in any combination
10:13:09 <ReinH> Wizek: Stack is great for that
10:13:14 <johnw> for example, if I run: "load-env-coq84 load-env-ghc7103 load-env-emacs24 emacs", then I'm in an Emacs within an environment that uses those versions together
10:13:50 <johnw> does stack do binary deduplication among common dependencies?
10:14:00 <Wizek> johnw, fascinating. nix didn't strike me as production ready yet. Can it also be used in conjunction with with apt-get if I only want to use nix to manage ghc?
10:14:09 <bitemyapp> johnw: it copies the package conf files referencing the same binaries
10:14:12 <ReinH> You can easily have each stack project use a particular GHC
10:14:17 <johnw> Wizek: sure it can, it's completely orthogonal to your main package manager
10:14:22 <ReinH> and Stack will manage downloading them, etc
10:14:27 <johnw> bitemyapp: ah, ok
10:14:30 <bitemyapp> johnw: so yeah, it dedups.
10:14:47 <johnw> does it garbage collect? :)
10:15:02 <bitemyapp> it doesn't know what you're using or not using
10:15:03 <Wizek> johnw, is there a tutorial on how I could use nix with ghc?
10:15:05 <johnw> does it retain a history of past environment versions, allowing rollback?  is it atomic for multiple-package upgrades?
10:15:14 <johnw> Wizek: let me find a modern one for you
10:15:19 <bitemyapp> johnw: you're asking questions that only have the answer Mu
10:15:32 <ReinH> I'm not suggesting that Stack does everything nix does.
10:15:34 <johnw> I'm asking questions that all have the answer "yes" if we're talking about Nix
10:15:38 <ReinH> I'm suggesting that Stack does everything I need.
10:15:39 <bitemyapp> johnw: there are no versioned environments because there ain't no such thing as an environment
10:15:41 * hackagebot lmonad-yesod 0.1.0.0 - LMonad for Yesod integrates LMonad's IFC with Yesod web applications.  https://hackage.haskell.org/package/lmonad-yesod-0.1.0.0 (jp_rider)
10:15:53 <johnw> he did ask what was the best way, and I still consider Nix the best way
10:15:58 <bitemyapp> johnw: because why would you care about an environment? It's just a means of building a damn haskell project.
10:16:00 <glittershark> is there a typeclass-overriden version of repeat that's classy-prelude-friendly?
10:16:14 <bitemyapp> johnw: Nix is a fun yak-shave but it's going to waste more time than it saves for most Haskell users.
10:16:19 <ReinH> maybe if you want to spend a lot of time learning nix
10:16:27 <johnw> bitemyapp: completely disagree
10:16:28 <ReinH> if you just want to use multiple ghc versions, I think that's debatable
10:16:29 <bitemyapp> johnw: the ROI cliff on that journey is not good.
10:16:58 <johnw> an argument for another channel, alas
10:17:09 <bitemyapp> johnw: well, you disagree, but I pretty quickly ran into irreconciable problems just getting bloodhound to build under Nix and having to make expressions for each and every dep version that wasn't part of the current Nix snapshot of Haskell libraries was absurd
10:17:20 <bitemyapp> johnw: irreconciable w/ expert support. I was on NixOS.
10:17:27 <johnw> as I said, #nixos or let's leave it
10:17:40 <glittershark> ping on my earlier question?
10:17:45 <glittershark> sorry
10:17:48 <Wizek> hmm
10:18:27 <ReinH> Wizek: I can get you up to speed with using multiple stack versions in as much time as it takes you to install stack
10:18:27 <monochrom> glittershark, I wonder what type class would meaingfully generalize what repeat does
10:18:35 <glittershark> Monoid?
10:18:36 <Maplicant> Hi
10:18:42 <ReinH> Maybe nix is better, but are you interested in spending weeks to learn it before you can use it?
10:19:10 <ReinH> s/stack versions/ghc versions with stack
10:19:22 <monochrom> Monoid sounds wrong
10:19:29 <glittershark> no, monoid is wrong
10:19:33 <glittershark> needs to be a *->*
10:20:00 <johnw> Wizek: if you're interested in trying out the Nix way, come ask more in #nixos
10:20:10 <argoneus> :t a `mod` 5
10:20:11 <lambdabot> Expr
10:20:15 <argoneus> thanks
10:20:27 <argoneus> :t mod
10:20:28 <lambdabot> Integral a => a -> a -> a
10:20:42 <monochrom> and my --prefix and PATH takes only 5 seconds to learn
10:20:52 <Wizek> johnw, I've already joined that channel, and now I am a bit torn beween wanting to listen to your conversation about the ups and downs of nix and wanting a quick solution :D
10:21:27 <ReinH> Wizek: well, you can start using stack while you learn nix.
10:21:36 <SaTa> wow, so many peeps around here :-)
10:21:39 <monochrom> although, it did took me an hour to write a shell function for playing with PATH so I don't have to manually edit PATH every time
10:22:07 <monochrom> but it's already written now. I can share it. I spent that hour, you won't.
10:22:20 <Wizek> monochrom, please share :)
10:22:41 <ReinH> monochrom: now you should write a .ghc-version file in each project so you can use it to select the right ghc rather than, I assume, doing so manually.
10:23:09 <bollu> guys, is ##cs dead?
10:23:15 <bollu> or am I mis-remembering?
10:23:19 <bollu> the name of the channel?
10:23:23 <bollu> for computer science
10:24:00 <SaTa> do u guyz say welcome to new ppl here?
10:24:59 <mauke> no, but I frown at your butchering of "you", "guys", "people"
10:25:17 <cocreature> SaTa: if 1536 say hello to every new person here, it gets pretty noisy here :)
10:25:20 <monochrom> Wizek: http://lpaste.net/148674
10:25:30 <aweinstock> SaTa: if you have a specific question, the convention is to ask it directly
10:25:40 <monochrom> I think ##cs means Counter Strike the game
10:25:44 <SaTa> oh, k
10:25:54 <monochrom> there is no computer science channel in freenode IIRC
10:26:09 <bollu> oh, that's sad :(
10:26:14 <bollu> I had computer organization questions
10:26:21 <ReinH> If it were #cs it would be either computer science or counter strike the language, I guess.
10:26:26 <aweinstock> bollu: I can try to help
10:26:38 <bollu> aweinstock: won't it be off-topic though? :)
10:27:02 <bollu> aweinstock: well, I'm preparing for an examination that says it expects me to know "computer organization at the undergrad level" I honestly don't know what that entails
10:27:19 <aweinstock> theoretical CS seems partially in-scope for #haskell, but you can PM me if you think it's off-topic
10:27:35 <bollu> aweinstock: sure, I'll PM you :)
10:27:41 <cocreature> there is #haskell-blah for that kind of stuff :)
10:27:52 <bollu> oh right, let's move to #haskell-blah aweinstock?
10:27:56 <aweinstock> at my school, the computer organization class was stuff about assembly programming, and a bit of boolean logic
10:28:36 <ReinH> Generally I expect things on exams to have been covered during the course, so I am always surprised when people claim that they don't know what something on an exam is.
10:29:35 <bollu> ReinH: it's a competitve exam with no real bounds on topics
10:29:49 <bollu> ReinH: so I literally do not know what to prepare, though I have a rough idea from here: http://geeksquiz.com/computer-organization-and-architecture/
10:30:04 <bitemyapp> Wizek: if you get tired of Nix, ping me and I can show you how to build stuff with diff GHC versions in Stack.
10:30:59 <jeffairpson> is haskell a good programming language for artificial-intelligence-related projects?
10:31:17 <glittershark> haskell's a good programming language for anything :)
10:31:30 <glittershark> that's a non-answer though
10:31:59 <ReinH> bollu: ah
10:32:09 <jeffairpson> well, but it's a fact that certain language fits more than other for certain project
10:32:21 <jeffairpson> for example, prolog is the best one for computational linguistics project
10:32:31 <ReinH> bitemyapp: I mean, it's "change or add two options to your stack.yaml"
10:33:20 <bitemyapp> ReinH: all the same.
10:33:27 <ReinH> bitemyapp: :)
10:34:00 <johnw> haha, fighting over newbies; no, I want him!
10:34:28 <johnw> Wizek: choose Nix and I'll move into a trailer near your house so you have 24x7 live support
10:34:45 <ReinH> Wizek: You would rather use stack to manage GHC versions. Search your feelings, you know it to be true
10:34:47 <pikajude> choose nix and you'll never run out of side projects to bang your head against
10:34:57 <glittershark> jeffairpson: I myself would absolutely consider doing haskell for ML/AI stuff
10:34:59 <ReinH> nix leads to anger
10:35:01 <johnw> ReinH: love the nuance in that, lol :)
10:35:05 <ReinH> anger leads to hate
10:35:11 <bitemyapp> 24x7 live support - well, I didn't. But I keep strange hours I guess.
10:35:23 <suppi> hate leads to java?
10:35:28 <bitemyapp> suppi: maven
10:35:38 <suppi> same same
10:35:46 <jeffairpson> glittershark: why?
10:35:57 <bollu> oh, since a lot of people are here, lemme ask my question about Free monads again
10:35:58 <jeffairpson> glittershark: would you choose it over lisp?
10:36:07 <Jinxit> I want to do ML in haskell because of the type system
10:36:16 <glittershark> jeffairpson: depends on how long the project will live
10:36:17 <Jinxit> but if I need serious performance I would probably do it in C++
10:36:18 <bitemyapp> Jinxit: machine learnin'?
10:36:21 <bollu> So, the way I understand it, we create a type DSL next = â€¦. (deriving Functor) where the "next" represents the type of the next computation
10:36:22 <Jinxit> yeah
10:36:31 <argoneus> const seems like magic
10:36:34 <glittershark> I tend to prefer lisp for things that are write-once-then-run
10:36:41 <argoneus> do I just give it any value, and it gives me a function that returns said value?
10:36:41 <bitemyapp> Jinxit: well, you can get serious perf in Haskell, but the methods of doing so are a little oblique at first. Same principles apply (cache obliviousness, etc.)
10:36:41 <bollu> and then we use the Free DSL <whatever> type to "wrap up any number of layers of DSL" into oone type
10:36:47 <glittershark> and haskell for anything that's gonna live a while
10:37:00 <johnw> bollu: pretty much, yes
10:37:00 <bitemyapp> Jinxit: emmanuel_erc has done some vector-y perf optimization lately and #numerical-haskell exists for asking questions.
10:37:06 <glittershark> jeffairpson: I'm biased because I like haskell a lot, but then again this *is* #haskell
10:37:10 <argoneus> glittershark: ever used java/c/c++/python/lua/c#/whatever?
10:37:13 <glittershark> yes
10:37:15 <glittershark> heavily
10:37:17 <bollu> and since we get a Free monad instance on the DSL, everyone is happy because monad
10:37:19 <bollu> right?
10:37:23 <argoneus> and you still prefer to lisp/haskell fulltime?
10:37:28 <johnw> bollu: if you want to follow the literature, DSL is a "term algebra", and "Free DSL" is the DSL (the language formed from the rules of the grammar)
10:37:28 <glittershark> yep!
10:37:29 <bollu> and now, what about the dual structure? Cofree Comonad?
10:37:32 <Jinxit> yeah, but I would rather write an ML lib for pedagogy rather than performance
10:37:34 <argoneus> mmmh
10:37:35 <Jinxit> as a teaching tool
10:37:38 <argoneus> glittershark: what kind of lisp do you like?
10:37:45 <johnw> bollu: monad gives you a way to compose DSL actions
10:37:50 <glittershark> I like clojure a lot
10:37:52 <bollu> johnw: right
10:37:57 <bollu> glittershark: ewww.
10:37:58 <argoneus> I see, cool, thanks
10:37:59 <jeffairpson> glittershark: yeah, I'm fascinated and I'm thinking to begin to study it, since I do love category theory and therefore I'd love to see its concepts implemented in a programming language
10:38:01 <glittershark> I've written *some* CL and Scheme
10:38:04 <bollu> glittershark: it kills the spirit of scheme imo
10:38:07 <ReinH> johnw: these are not the droids you are looking for
10:38:20 <glittershark> hey, everyone has opinions
10:38:32 <glittershark> Haskell is by far my favorite programming language, and that's my opinion :)
10:39:11 <quchen> jeffairpson: It was a personal highlight to sit in a talk about Yoneda in Haskell, and the mathematicians said something along the lines of "woah, we didn't know it had *such* a practical application" :-D
10:39:53 <bollu> quchen: I don't grok the Yoneda lemma
10:40:28 <jeffairpson> qunchen: ahaha, you're intriguing me to start with haskell : p
10:40:32 <quchen> bollu: You don't really have to in order to use it in Haskell.
10:40:41 <glittershark> yess! one of us!
10:40:51 <bollu> quchen: yes, but it's nice to know category theory to read what, for example, ekemett writes :P
10:41:10 <bollu> quchen: the famous "monad is a monoid of endofunctors" is quite fun to grok
10:41:24 <quchen> Yoneda in Haskell is "it's a Functor no matter what", and you can put stuff in and take stuff out, but the out-taking requires Functor.
10:41:32 <quchen> Or was that Coyoneda
10:41:34 <quchen> :t Coyoneda
10:41:36 <lambdabot> Not in scope: data constructor â€˜Coyonedaâ€™
10:41:38 <ReinH> :t flip fmap [1,2,3] 
10:41:40 <quchen> :t CoYoneda
10:41:40 <lambdabot> Num a => (a -> b) -> [b]
10:41:41 <lambdabot> Not in scope: data constructor â€˜CoYonedaâ€™
10:41:44 <quchen> :-(
10:41:44 <absence> ReinH: hi! did you see my question on reddit about your l-system post? was experimenting earlier and got stuck :p
10:41:48 <ReinH> ^ yoneda
10:42:06 <ReinH> absence: iirc you actually need traversable on the functor as well so you can sequence it out
10:42:12 <bollu> ReinH: wait, which one is youneda?
10:42:19 <ReinH> :t fli fmap [1,2,3]
10:42:21 <lambdabot>     Not in scope: â€˜fliâ€™
10:42:21 <lambdabot>     Perhaps you meant â€˜flipâ€™ (imported from Data.Function)
10:42:25 <ReinH> :t flip fmap [1,2,3]
10:42:27 <lambdabot> Num a => (a -> b) -> [b]
10:43:04 <bollu> ReinH: that is yoneda?
10:43:41 <Wizek> aww guys, I really enjoy reading your lines about nix, stack and similar methods. It really meets my need for support at the moment. Thanks johnw, ReinH, bitemyapp, monochrom (and perhaps others too)! :)
10:43:49 <ReinH> :t runYoneda
10:43:50 <lambdabot> Not in scope: â€˜runYonedaâ€™
10:43:52 <quchen> lowerYoneda :: Yoneda f a -> f a
10:44:20 <ReinH> newtype Yoneda f a = Yoneda (forall b. (a -> b) -> f b)
10:44:24 <ReinH> it's a partially applied fmap
10:44:52 <absence> ReinH: ah, makes sense, i did run into some m (f (m ...)) stuff
10:45:09 <ReinH> bollu: https://www.schoolofhaskell.com/user/bartosz/understanding-yoneda
10:45:15 <bollu> ReinH: ty
10:45:40 <bollu> ReinH: so, in that definition, the function gets to pick a "b" right? (the callee is in control of b)
10:51:35 <ReinH> It means that (a -> b) has to work for all choices of b
10:52:17 <bollu> ReinH: oh. so, what about the same signature without the forall?
10:52:41 <ReinH> bollu: consider another example
10:53:14 <ReinH> let's say we have a function f :: [a] -> Int that we want to apply to a tuple of ([Int], [Char]).
10:53:52 <ReinH> what type does applyToTuple f (x,y) -> (f x, f y) have if f must be of type [a] -> Int and x and y can be different types?
10:54:33 <ReinH> the obvious one would be applyToTuple :: ([a] -> Int) -> ([b], [c]) -> (Int, Int)
10:54:52 <bollu> ReinH: hm, you "can't" type it, because if I say f :: a -> b or something, then it won't unify with x and y
10:54:58 <ReinH> but this means that a is universally quantified over the whole type, so one we pick a ~ b, we can't then pick a ~ c
10:54:59 <bollu> because x and y have different types
10:55:04 <bollu> yeah
10:55:05 <ReinH> so instead:
10:55:31 <ReinH> applyToTuple :: (forall a. [a] -> Int) -> ([b], [c]) -> (Int, Int)
10:55:41 <ReinH> now the function you supply has to work for all choices of a
10:55:47 <bollu> oh!
10:55:50 <ReinH> it can't be, e.g., a function [Int] -> Int
10:55:54 <ReinH> it can be, e.g., length
10:55:56 <ReinH> :t length
10:55:57 <lambdabot> Foldable t => t a -> Int
10:56:05 <ReinH> everything has an implicit quantification
10:56:13 <ReinH> so length :: forall a. [a] -> Int is of the type we want
10:56:24 <bollu> ReinH: but in other cases, I've seen people use forall to create existential types
10:56:28 <bollu> ReinH: how does that work?
10:56:34 <bollu> ReinH: it's like there are "two meanings" to forall
10:56:49 <ReinH> Via some mathematmatical tomfoolery whereby a forall can be used in a way that means exists
10:56:57 <ReinH> and ExistentialQuantification
10:57:04 <argoneus> > zip [1,2,3] (tail [3])
10:57:06 <lambdabot>  []
10:57:33 <bollu> ReinH: is the mathematical tomfoolery being the natural logic thing that universal quantification implies existence?
10:57:51 <argoneus> okay this book has broken examples
10:58:19 <argoneus> which one of you recommended me Programming in Haskell? >_>
10:58:46 <glittershark> definitely not bitemyapp :P
10:58:49 <bollu> ReinH: see this: https://www.reddit.com/r/haskell/comments/3y4kvn/lens_over_tea_5_prisms/cyenjlo?context=10000
10:59:04 <bollu> h :: (forall f. Functor f => (f b -> f t)) -> (b -> t)
10:59:12 <argoneus> oh wait
10:59:15 <argoneus> tail isn't the last item of a list
10:59:18 <bollu> means that I have to provide a function that has type f b -> f t for any Functor instance f of h's choosing, and then h will give me back a function b -> t.
10:59:19 <argoneus> it's everything except the head
10:59:21 <argoneus> well that's confusing
10:59:23 <glittershark> yep!
10:59:28 <bollu> ReinH: I don't understand how that works now
10:59:33 <glittershark> it makes more sense if you think of lists as cons cells, argoneus 
10:59:36 <bollu> ReinH: I've "flipped" from one view to the other now :/
10:59:38 <glittershark> if you have any lisp experience
10:59:43 <argoneus> nope
10:59:45 <glittershark> ok
10:59:47 <glittershark> well
10:59:51 <glittershark> all lists are are a head and a tail
11:00:02 <argoneus> ah, right
11:00:04 <argoneus> the famous x:xs
11:00:09 <glittershark> exactly
11:00:11 <mnoonan> bollu: I think the existential thing it's an encoding of "exists X. P(X)" by "not (forall X. not P(X))"
11:00:16 <mnoonan> *is
11:00:26 <argoneus> it just doesn't make sense to me logically
11:00:34 <argoneus> a dog doesn't have a head and then a tail
11:00:38 <argoneus> :<
11:00:40 <ReinH> bollu: data Showable a = forall a. Show a => MkShowable a is a claim that "for every a such that a is an instance of show, you can construct a Showable a with that a"
11:00:43 * hackagebot io-streams 1.3.5.0 - Simple, composable, and easy-to-use stream I/O  https://hackage.haskell.org/package/io-streams-1.3.5.0 (GregoryCollins)
11:01:12 <bollu> ReinH: and the function that I had linkeD?
11:01:21 <glittershark> argoneus: a snake kinda does, though :)
11:01:40 <bollu> h :: (forall f. Functor f => (f b -> f t)) -> (b -> t)
11:01:50 <bollu> for all types that admit a functor structure, I can construct an h?
11:02:16 <argoneus> how can I neatly take everything except the first and last item in a list?
11:02:22 <argoneus> without using something like length
11:02:45 <ReinH> bollu: now consider a putative exists quantifier "(exists a . Show a => (a,a)) -> Showable a", which says "if a is some instance of Show then I can use it to construct a Showable a"
11:02:50 <argoneus> or is there no "reverse" tail
11:02:56 <ReinH> bollu: forall and exists are dual
11:03:26 <ReinH> er, s/(a,a)/a
11:03:53 <bollu> (exists a . Show a => a) -> Showable a ?
11:04:09 <aweinstock> argoneus: [1,2,3] is shorthand for 1:(2:(3:[]))
11:04:17 <argoneus> > let xs = [1,2,2,1] in reverse. tail . reverse . tail xs
11:04:18 <lambdabot>      Couldn't match expected type â€˜a -> [a1]â€™
11:04:18 <lambdabot>                  with actual type â€˜[Integer]â€™
11:04:18 <lambdabot>      Possible cause: â€˜tailâ€™ is applied to too many arguments
11:04:19 <glittershark> > last [1,2,3]
11:04:21 <lambdabot>  3
11:04:25 <argoneus> oi
11:04:25 <aweinstock> head (x:xs) = x; tail (x:xs) = xs
11:04:26 <glittershark> but `last` is O(n)
11:04:33 <glittershark> whereas `head` is O(1)
11:04:46 <monochrom> add parentheses. (reverse . tail . reverse . tail) xs
11:04:57 <glittershark> or a `$`
11:05:12 <glittershark> > reverse . tail . reverse . tail $ [1,2,2,1]
11:05:13 <lambdabot>  [2,2]
11:05:14 <ReinH> Er, that shoud be: data Showable = forall a. Show a => MkShowable a
11:05:15 <argoneus> > let xs = [1,2,2,1] in (reverse . tail . reverse . tail) xs
11:05:17 <lambdabot>  [2,2]
11:05:27 <ReinH> because the a is quantified on the rhs
11:05:46 <mnoonan> argoneus: what about tail . init?
11:05:56 <glittershark> @src init
11:05:56 <lambdabot> init [x]    = []
11:05:56 <lambdabot> init (x:xs) = x : init xs
11:05:56 <lambdabot> init []     = undefined
11:05:57 <bollu> ReinH: so that's saying that for all "a" that has Show, I can implement a MkShowable on them?
11:05:59 <mnoonan> (not sure what you want for lists with length < 2)
11:06:08 <glittershark> > init [1,2,3,4]
11:06:10 <argoneus> oh, I see
11:06:10 <lambdabot>  [1,2,3]
11:06:15 <ReinH> so then you have MkShowable :: forall a . a -> Showable, which is dual to MkShowable :: (exists a . a) -> Showable
11:06:24 <argoneus> (tail . init) $ [1,2,3]
11:06:29 <argoneus> > (tail . init) $ [1,2,3]
11:06:31 <lambdabot>  [2]
11:06:33 <argoneus> dank
11:06:40 <absence> ReinH: still have some trouble making it fit. not quite sure about the type signature for step when cofree is involved. is it something like this? step :: (Traversable f, Monad m) => D0L f m a -> Cofree f (D0L f m a)
11:06:43 <ReinH> so forall is basically used because there is a mathematical justification and it lets us avoid introducing a new keyword into the language
11:06:57 <glittershark> argoneus: you don't need the parens if you have the $ :)
11:07:01 <bollu> ReinH: can you walk me through how forall and exists are duals?
11:07:02 <ReinH> absence: I think so
11:07:13 <argoneus> right
11:07:21 <argoneus> $ is a low priority operator
11:07:52 <bitemyapp> bollu: you can translate it into logic statements in English, then do the negation translation
11:08:04 <monochrom> I look at it differently. you don't need $ if you have parentheses.
11:08:15 <glittershark> also right associative
11:08:41 <bollu> bitemyapp: "there exists a functor f such that h :: (f a -> f b) -> a -> b works out" -> ??? 
11:08:54 <bitemyapp> lets back away from the haskell for a moment mate
11:09:08 <bollu> bitemyapp: alright :)
11:09:12 <quchen> monochrom: Took me quite some time to not like ($) at all anymore though
11:09:56 <bollu> bitemyapp: my on
11:09:58 <bollu> go on*
11:10:07 <bitemyapp> bollu: forall breathing persons x, x is alive. The negation of that would be "There exists a breathing person x, where x is not alive"
11:10:21 <ReinH> Eh...
11:10:31 <bitemyapp> bollu: however, you can do a translation where you replace the "forall" with "exists" such that it says the same thing as the original statement
11:10:41 <glittershark> @pf \f g -> (f x, g x)
11:10:41 <lambdabot> Maybe you meant: pl bf
11:10:47 <bitemyapp> There does not exist a breathing person x, where x is not alive.
11:10:48 <glittershark> @pl \f g -> (f x, g x)
11:10:48 <lambdabot> (. ($ x)) . (,) . ($ x)
11:10:50 <bollu> bitemyapp: what if my forall'd set is empty
11:10:52 <glittershark> ugh
11:10:53 <ggole> You could (probably) make a corpse breath with a respirator
11:10:54 <ReinH> The duality is expressed as: there exists an X such that P(X) is true imples that it is not true that for all X, P(X) is false.
11:10:56 <bitemyapp> bollu: doesn't change anything
11:11:00 <argoneus> I'm dumb
11:11:11 <argoneus> I just realized if you write \x, the \ is supposed to kinda look like the lambda symbol
11:11:11 <ReinH> If I am a man then it is not true that all people are not men.
11:11:15 <argoneus> I keep thinking it's some weird escape
11:11:17 <monochrom> :)
11:11:25 <glittershark> argoneus: correct! :)
11:11:28 <bollu> Bigcheese: "forall humans of age over 200, they are awesome" versus "there does not exist a person over age 200 who is awesome"
11:11:35 <bollu> oh, interesting. both are vacuously true
11:11:44 <argoneus> waait
11:11:51 <glittershark> @pl \(f, g) (x, y) -> (f x, g y)
11:11:51 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
11:11:59 <glittershark> goddammit pl
11:12:05 <bitemyapp> bollu: think you forgot to negate the "is awesome" in the second one?
11:12:07 <mnoonan> bollu: "who is *not* awesome"
11:12:13 <bitemyapp> bollu: really this stuff is easier symbolically.
11:12:18 <bollu> bitemyapp: oh yes, that was in my head :)
11:12:42 <argoneus> > double 8 where double = \x -> x * 2
11:12:43 <bitemyapp> bollu: anyhoo, that you can go between the existential/universal variants of the same statement through negation is why we only have forall in Haskell.
11:12:43 <lambdabot>  <hint>:1:10: parse error on input â€˜whereâ€™
11:12:48 <argoneus> err
11:12:52 <bitemyapp> bollu: because it's the same thing anyway
11:13:04 <bitemyapp> bollu: you shuffle where the forall is in the type to perform the negation.
11:13:05 <glittershark> argoneus: `where` has to be on a different line
11:13:13 <glittershark> > let double x = x * 2 in double 8
11:13:15 <lambdabot>  16
11:13:27 <glittershark> but!
11:13:36 <glittershark> > let double = (* 2) in double 8
11:13:38 <lambdabot>  16
11:13:38 <glittershark> :)
11:13:40 <bollu> bitemyapp: how do you show the forall / exists thing symbolically?
11:13:48 <argoneus> glittershark: I wanted to test the \x syntax
11:13:49 <argoneus> :(
11:13:52 <glittershark> I know :P
11:14:03 <glittershark> > let double = \x -> x * 2 in double 8
11:14:04 <lambdabot>  16
11:14:09 <argoneus> ah
11:14:13 <bollu> > let 3 = 5 in 3
11:14:14 <lambdabot>  3
11:14:20 <bitemyapp> bollu: sorry, but: https://en.wikipedia.org/wiki/Universal_quantification
11:14:22 <ReinH> bollu: âˆƒxPx = ~âˆ€x~Px
11:14:27 <glittershark> @v
11:14:28 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
11:14:28 <ReinH> where ~ is negation
11:14:38 <quchen> bollu: I don't understand that one. :-|
11:14:43 <argoneus> > let double = \x -> x*2 in double 8
11:14:44 <lambdabot>  16
11:14:50 <bollu> oh, thanks :)
11:14:53 <argoneus> > let double = Î»x -> x*2 in double 8
11:14:55 <lambdabot>  <hint>:1:17: parse error on input â€˜->â€™
11:14:58 <argoneus> :(
11:15:09 <bollu> quchen: I was screwing around, that used to work I think, someone showed it to me long back
11:15:16 <glittershark> argoneus: :set -XUnicodeSyntax, in your own ghci
11:15:18 <argoneus> btw, is there a particular reason why x*2 parses just fine?
11:15:24 <argoneus> like, * is a function, right
11:15:26 <pikajude> or better yet, don't set UnicodeSyntax
11:15:32 <argoneus> if it was called "hi" and not *, xhi2 wouldn't work
11:15:43 <bollu> argoneus: then you can use x `hi` 2
11:15:46 <quchen> bollu: I know it works, but I don't understand how!
11:15:49 <argoneus> yeah
11:15:51 <glittershark> argoneus: haskell treats functions with symbols in them differently than functions with characters
11:15:52 <argoneus> but why can you use * just like that
11:15:54 <argoneus> oh
11:16:02 <ReinH> argoneus: because identifiers that contain symbols are operators
11:16:07 <glittershark> functions with symbols (ie, operators) are infix by default
11:16:07 <argoneus> so if I had a function ('//.!!)
11:16:12 <argoneus> then I could do x'//.!!y ?
11:16:15 <glittershark> yep!
11:16:21 <argoneus> hmm
11:16:30 <monochrom> except for the '
11:16:30 <bollu> someone show him/her lens operators now :)
11:16:31 <ReinH> No, ' is considered a letter
11:16:32 <glittershark> well, the `'` might parse weird, since that's also valid as part of an identifier
11:16:35 <Jinxit> (and lenses sometimes aren't far from that)
11:16:36 <argoneus> ah, right
11:16:39 <argoneus> ' is popular in math
11:16:41 <argoneus> x and x'
11:16:46 <ReinH> Yes, for that reason
11:16:47 <glittershark> pronounced "prime"
11:16:56 <monochrom> > let x //.!! y = 2*x+y in 3 //.!! 4
11:16:57 <glittershark> or at least that's how I pronounce it
11:16:59 <lambdabot>  10
11:17:13 <bollu> argoneus: just some happy Haskell operators - https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Operators.html
11:17:16 <quchen> > let 1+1=3 in 1+1 -- bollu, this works by shadowing the (+) function. But in your case, there's nothing like that around.
11:17:18 <lambdabot>  3
11:17:33 <bollu> quchen: oh right
11:17:36 <ReinH> btw this means that valid brainfuck programs (without comments) are operators
11:17:57 <argoneus> oh yeah
11:18:01 <Jinxit> argoneus: (<<<>~) is one of my favourites, visually
11:18:08 <argoneus> I saw an operator <|> but couldn't really google it, what does it do?
11:18:14 <ReinH> argoneus: hoogle it
11:18:22 <Jinxit> hoogle it as (<|>)
11:18:27 <quchen> ReinH: []
11:18:33 <monochrom> it is from the Alternative type class. it is in the Control.Applicative modules
11:18:38 <argoneus> oh, that's useful
11:18:40 <ReinH> quchen: damn you
11:18:43 <glittershark> :t (<|>)
11:18:44 <lambdabot> Alternative f => f a -> f a -> f a
11:18:51 <quchen> ReinH: ,
11:19:01 <quchen> "Damn you twice" ;-)
11:19:11 <Jinxit> > Nothing <|> Just 8 <|> Just 2
11:19:13 <lambdabot>  Just 8
11:19:14 <ReinH> quchen: ok fine I'm wrong
11:19:25 <ReinH> well, Haskell is wrong.
11:19:58 <argoneus> hm, this doesn't help
11:20:02 <argoneus> "An associative binary operation"
11:20:06 <argoneus> thanks ._.
11:20:16 <monochrom> heh
11:20:26 <glittershark> haha
11:20:27 <bollu> ReinH: okay, so back to the example that I couldn't grok: g :: forall f. Functor f => ((f b -> f t) -> (b -> t))
11:20:37 <monochrom> for each instance I can tell you what it does. but the general story is pretty abstract.
11:20:37 <bollu> ReinH: what is the forall doing there?
11:20:45 <glittershark> argoneus: given an Alternative, it usually will pick the one that doesn't represent a failure
11:20:45 <monochrom> []'s <|> is just ++
11:20:56 <bollu> argoneus: think of it as "short circuiting"
11:20:59 <glittershark> yeah
11:21:00 <quchen> ReinH: I'm pretty glad [] isn't allowed or I'd waste writing ACME.Brainfuck the whole evening, with definitions like (+[>++<-]>[>++<-]>[>++<-]>[>++<-]>[>++<-]>.) = 32
11:21:04 <glittershark> it's used in parsers a lot
11:21:07 <csd_> How do I make a function such that it's type signature accepts both [Foo] and newtype Bar = Bar [Foo] ?
11:21:14 <monochrom> Maybe's <|> is what you saw from Jinxit's example.
11:21:15 <ReinH> argoneus: you know: its type, its typeclas, and isntances of its typeclass. This is enough to try it by creating multiple examples
11:21:36 <ReinH> Don't think of it as short circuiting.
11:21:42 <ReinH> > [1,2,3] <|> [4,5,6]
11:21:44 <lambdabot>  [1,2,3,4,5,6]
11:21:51 <argoneus> whoa
11:21:51 <ReinH> think of it, if you must, as making a choice.
11:22:00 <glittershark> @src (<|> :: Maybe a -> Maybe a -> Maybe a)
11:22:01 <lambdabot> Source not found. That's something I cannot allow to happen.
11:22:04 <glittershark> dammit
11:22:08 <Jinxit> why is making a choice of two lists the concatenation?
11:22:09 <bollu> ReinH: ehh, the list is the free monoid, it has so little structure you can't even do much with it right?
11:22:13 <argoneus> :t (<|>)
11:22:14 <lambdabot> Alternative f => f a -> f a -> f a
11:22:15 <ReinH> Jinxit: because a list is a list of choices
11:22:28 <ReinH> and if you make a choice between three choices and three choices, you can make one of six choices
11:22:28 <monochrom> the general story is "some kind of choice", but that is handwaving.
11:22:31 <argoneus> @src Alternative
11:22:31 <lambdabot> class Applicative f => Alternative f where
11:22:31 <lambdabot>     empty :: f a
11:22:31 <lambdabot>     (<|>) :: f a -> f a -> f a
11:22:36 <Jinxit> aha
11:22:51 <quchen> bollu: If you're interested in category stuff, there's a nice post by dolio I think where he explains that lists are not the free Monoid
11:22:55 <bollu> g :: forall f. Functor f => ((f b -> f t) -> (b -> t)) <- what is this asserting?
11:22:58 <bollu> quchen: really?
11:23:03 <argoneus> mmmhm
11:23:11 <bollu> quchen: I don't know a lot of category stuff but send it over
11:23:16 <ReinH> bollu: something that isn't true
11:23:21 <bollu> quchen: I'll bet it's something to do with _|_ or the like
11:23:46 <quchen> bollu: Something detail-y from a pracitcal perspective, yes. I can't find the link right now though
11:23:50 <absence> ReinH: is there something obviously wrong here? (can't get the functor/monad layering quite right) step = coiter go where go (D0L k ma) = D0L k <$> (sequence . k =<< ma)
11:23:50 <glittershark> @pl \f x y -> (f x, f y)
11:23:51 <lambdabot> flip =<< (((.) . (,)) .)
11:23:52 <bollu> ReinH: okay :) so, well, can you show a function that involves forall and is true?
11:24:09 <quchen> bollu: Ah, I think it was this one. http://comonad.com/reader/2015/free-monoids-in-haskell/
11:24:10 <monochrom> forall a. a -> a
11:24:26 <bollu> monochrom: a little too simple :) only id satisfies
11:24:37 <ReinH> Well, it's true in that it typechecks and it is inhabited by bottom
11:24:47 <monochrom> (forall a. a -> b) -> b
11:25:11 <ReinH> But yes, all of them involve forall
11:25:30 <ReinH> so pick a function
11:25:33 <bollu> monochrom: so the function works for all choices of a?
11:25:49 <monochrom> I don't understand the question
11:26:05 <bollu> monochrom: aren't you asking me to implement f :: (forall a. a -> b) -> b ?
11:26:09 <ReinH> Every polymorphic type has implicit universal quantification
11:26:43 <mnoonan> you can make a function with monochrom's type like: foo f = f "Hi, I'm bollu!"
11:26:46 <monochrom> I thought I were only to provide a type that contains forall, and is a true statement, even when we ban bottom
11:26:48 <bollu> monochrom: if so, can't I just do f g = g []
11:26:58 <monochrom> yes
11:27:08 <bollu> monochrom: ooh, okay, more forall questions please?
11:28:18 <average> hey
11:28:38 <average> someone claims it's hard to compile haskell code written 1 year ago
11:28:43 <average> how true/false is that claim ?
11:28:51 <csd_> How do I make a function such that it's type signature accepts both [Foo] and newtype Bar = Bar [Foo] ?
11:29:07 <johnw> csd_: I don't understand
11:29:19 <johnw> oh, you want Bar and [Foo] to be equal in the type checker's eyes?
11:29:23 <csd_> yes
11:29:30 <johnw> you can only do this: type Bar = [Foo]
11:29:46 <johnw> you can't get transparent equivalence
11:30:37 <csd_> i feel like i made it a newtype because declaring it a type synonym was causing me problems for some reason. but i cant quite recall why
11:30:50 <johnw> probably relating to instances
11:30:53 <csd_> yes
11:31:00 <bollu> just to reiterate, not (\forall x, P(x)) <=> \exists x , not P(X)  right?
11:31:28 <dolio> No.
11:31:33 <geekosaur> same problem in opposite forms. if you make them the same type, they are always the same type and one cannot have different instances. if you make them different types, they are different types and can have different instances
11:31:39 <monochrom> (forall b. a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
11:31:40 <bollu> dolio: where did I screw up?
11:31:41 <geekosaur> but cannot be treated as the same typoe
11:31:49 <dolio> bollu: Intuitionism.
11:31:55 <bollu> dolio: which is..?
11:31:55 <csd_> johnw: why cant i make the function generic to Bar/[Foo] ?
11:32:09 <monochrom> err, typo, parentheses
11:32:17 <monochrom> ((forall b. a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
11:32:19 <johnw> csd_: in Idris you could, Haskell doesn't transparent coerce like that
11:32:42 <csd_> so what would the most elegant / haskelly solution be
11:32:43 <bollu> monochrom: you still have extra parens I think
11:32:48 <dolio> bollu: Knowing that it is not true that P holds for all x does not allow you find an x for which P does not hold.
11:33:05 <bollu> dolio: oh, is that the only difference?
11:33:36 <johnw> bollu: imagine you passed (âˆƒ x. Â¬ P(x)) as the argument to a function. I can then see the "x" for which P is not true
11:33:51 <bollu> johnw: right
11:33:59 <johnw> bollu: but (âˆ€ x. P(x) -> False) is a just function to me as an argument, without information
11:34:27 <bollu> johnw: oh, so I lose the "point" where P(x) fails, right?
11:34:34 <bollu> johnw: i.e,  I lose the counterexample?
11:34:41 <johnw> yes, you only know *that* it fails
11:34:52 <johnw> which is why dolio said "intuitionism"
11:34:59 <bollu> johnw:  you don't know *where* it fails.
11:35:01 <johnw> one proof is constructive, the other is not
11:35:10 <bollu> hm, and thus is not equivalent?
11:35:20 <johnw> not in an intuitionistic type theory they aren't
11:35:28 <johnw> in a classic logic is a different story
11:35:34 <bollu> I see
11:35:36 <dolio> The exists version is constructively stronger.
11:35:49 <dolio> Unless you have some way of constructively searching for an x or something.
11:35:59 <bollu> monochrom:  ((forall b. a -> (b -> r) -> r)) -> ((a -> r) -> r) -> (a -> r) -> r â€” was this what you were going for?
11:36:09 <monochrom> no
11:36:11 <bollu> dolio: which is impossible if your set X is uncountable, right?
11:36:12 <monochrom> ((forall b. a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
11:36:34 <monochrom> err, they are the same
11:36:39 <dolio> Doesn't even need to be uncountable.
11:37:14 <monochrom> no, they are not the same
11:37:16 <johnw> bollu: you can't call P(x) -> False to "get the False" in order to know that x is a failing case
11:37:25 <csd_> johnw: changed it back to a type synonym and things type checked *shrug*
11:37:28 <monochrom> the official version is still ((forall b. a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
11:38:15 <dolio> Certainly you can't do it without knowing more about the type of x than nothing, though.
11:38:52 <Fuco> just assume infinity doesn't exist
11:39:11 <aweinstock> csd_: you could use unsafeCoerce (I don't recommend it, and it's very unsafe and unhaskelly, but it does exist)
11:39:22 <bollu> monochrom: f g h =  (g (\a bTor -> h a) h)
11:39:38 <bollu> monochrom: right?
11:39:38 <monochrom> bTor?!
11:40:06 <aweinstock> csd_: I think the haskelly way is to make it take the newtype, and then just wrap the unwrapped type when calling it
11:40:19 <bollu> monochrom: that's the type :P  the first parameter of f is (forall b. a -> (b -> r) -> r)
11:40:29 <average> is Haskell worth learning at this point in time ?
11:40:39 <average> am I an idiot for thinking that I can GTD faster in Python ?
11:40:40 <bollu> monochrom: or am I missing something?
11:40:55 <johnw> average: you probably can GTD faster in Python, since I bet you know Python :)
11:41:09 <average> johnw: yes, but I don't know Haskell
11:41:17 <johnw> so, yeah, GTD in Haskell will take a while
11:41:18 <average> for some weird reason I feel like I'm missing out
11:41:27 <glittershark> I anectodally find haskell considerably more productive than any other language
11:41:29 <johnw> that you are, but you didn't ask that question
11:41:30 <monochrom> no. the first parameter is (forall b. a -> (b -> r) -> r) -> (a -> r) -> r
11:41:57 <average> well, ok, a lot of people are saying Haskell's type system is so great
11:42:02 <johnw> it is
11:42:05 <bollu> monochrom: oh, right. be back with a solution. didn't see the brackets in the right place
11:42:33 <average> Python barely has a type system, it's certainly not something Python people care too much about
11:42:40 <average> but Haskell seems to be all about types
11:42:42 <johnw> average: Haskell is the best thing in computing that ever happened to me; but if you just want to GTD, Python can make you happy to, depending on your definition of success.
11:42:43 <aweinstock> what does GTD stand for?
11:42:50 <johnw> get things done
11:43:23 <dolio> Fuco: I'm not sure ruling out infinity is good enough, either.
11:44:31 <monochrom> I can GTDP faster in Haskell
11:44:36 <johnw> Fuco: imagine it's (forall x : Bool, P x -> False).  the type simply says that I'll never be able to create a P True or a P False to call to get the evidence. How do I test for "not able to"?
11:44:39 <csd_> aweinstock: but then if your function is recursive you have to rewrap it for recursing, and that's kinda ugly imo
11:44:42 <bollu> monochrom: wait, what is wrong with my original solution?
11:44:44 <kurt11> average: I'm write Python for my day job. Language choice is contentious, but generally, I'd say, yes, Python is better to get stuff done. Haskell is more intellectually interesting and I strongly think it's worth learning, but I wouldn't expect to be able to use it productively for a while
11:44:45 <bollu> monochrom:  f g h = g ((\a bTor -> h a) h)
11:44:51 <monochrom> as for GTD without the P, I use shell scripts
11:45:07 <aweinstock> GTDP? Properly?
11:45:12 <johnw> Fuco: (or rather, the function itself is the evidence, minor point)
11:45:12 <monochrom> it has a type error
11:45:13 <bollu> monochrom: wait I got the mistake
11:45:22 <monochrom> yes, P is properly
11:45:24 <dolio> If you know something is finite in that there is a correspondence with some set of finite numerals, then you're in good shape. But constructively you can also have sub-finite things that are known to have an injection into a finite set, but are not isomorphic to a finite set.
11:45:33 <average> kurt11: is there a timeframe when you expect to use Haskell productively ?
11:45:37 <bollu> monochrom: no, I think I'm right
11:45:37 <bollu> see
11:45:45 <monochrom> the compiler complains
11:45:46 <bollu> the first parameter to f (i.e g)
11:46:06 <glittershark> average: I've had well-mentored coworkers be productive within a week or two, but that's definitely an outlier
11:46:11 <bollu> monochrom: lemme run it through ghc
11:46:28 <monochrom> and I am not sure what you endeavour to coin the name bTor and go on to ignore it
11:46:30 <average> glittershark: that's surprising
11:46:34 <glittershark> average: learning haskell is definitely not something you should do if you have deadlines :) but I think it's absolutely worth doing
11:46:41 <bollu> monochrom: because it's forall b, I don't see where I can use it
11:46:55 <average> glittershark: actually, if we're at it
11:47:01 <bollu> oh, since it' forall, I can use it with a as well?
11:47:02 <average> glittershark: how is management at your workplace ?
11:47:10 <monochrom> but you are probably still misparsing my scary type
11:47:11 <average> or in general, how is the management of Haskell projects going ?
11:47:17 <kurt11> average: I've been toying with Haskell here and there. I do expect to start productively using it within the next year. I already productively use it to whiteboard functions or prototype elegant simple code and I've learned a lot from it. But for production SQL/REST type stuff, I've felt better with Python
11:47:18 <roelof> How can I refractor this code : http://lpaste.net/148685
11:47:28 <glittershark> average: I'm the management of the haskell project, for all intents and purpooses
11:47:36 <glittershark> though I'm not a manager in title
11:47:37 <average> it doesn't seem to be something that can be subjected to rigorous hardass planning/schedules simply because it's not easy
11:47:49 <glittershark> well
11:48:01 <glittershark> the haskell project I'm working on right now was in Go previously
11:48:05 <glittershark> and I complained about it a lot
11:48:28 <glittershark> and my manager, knowing I like Haskell, essentially jokingly told me "well if you can rewrite this in haskell in a weekend, we'll do it in haskell"
11:48:29 <kurt11> try to convert a variable length tuple to a list in Haskell. It's quite hard. It Python it's just "list(my_tuple)". Obviously that's due to lack of strong/static types.
11:48:31 <glittershark> and I did
11:48:33 <glittershark> and he held true to it
11:48:37 <average> so you've switched to Haskell, and this decision probably threw off some of the people who wrote the previous codebase in Go
11:48:40 <glittershark> things are *so much faster*
11:48:44 <glittershark> it did
11:48:47 <glittershark> there was pushback
11:49:03 <average> did some people leave as a result ?
11:49:04 <dolio> Oh yeah, you must also be able to decide the predicate.
11:49:09 <glittershark> this project hasn't quite been shipped yet, but from comparing time to implement certain features in go vs haskell I can definitely say haskell is way better
11:49:11 <dolio> Probably.
11:49:12 <glittershark> no, nobody left
11:49:16 <average> wow, ok..
11:49:25 <glittershark> actually all the pushback was from the management, none of whom are actually touching this project
11:49:34 <glittershark> all of the underling-developers have been learning haskell
11:49:39 <glittershark> and are really excited about it
11:49:42 <pranz> roelof: I wouldn't say it needs to be refactored
11:49:58 <glittershark> all in all it's going really really well
11:50:01 <monochrom> I would think you manage (or mismanage) a haskell project the exact same way you manage or mismanage any project.
11:50:06 <glittershark> and management is really pleased with how fast things are using
11:50:09 <average> but what about all that concurrency flashy fancy bells & whistles that Golang has ?
11:50:14 <average> how do you get those in Haskell ?
11:50:15 <glittershark> oh boy
11:50:22 <glittershark> Haskell has all of those, plus a real type system :)
11:50:30 <roelof> oke, I do not like the if then clause . I was hoping I could did a "better " way , pranz 
11:50:35 <glittershark> GHC's runtime is based on green threads just like Go's
11:50:47 <johnw> average: I think you might want to just start learning Haskell; we aren't going to be able to convince you that you should, until you learn more about it
11:50:55 <glittershark> and MVars work quite similarly to go's channesl
11:51:04 <glittershark> Go doesn't have anything that haskell doesn't, besides maybe simplicity
11:51:11 <johnw> @where lyah
11:51:11 <lambdabot> http://www.learnyouahaskell.com/
11:51:12 <glittershark> and I think that's a major detractor
11:51:13 <topi> hello
11:51:18 <glittershark> @where book
11:51:18 <lambdabot> http://haskellbook.com/
11:51:25 <average> johnw: I really should yes, just trying to get gather some stories here and there
11:51:34 <average> johnw: I've been learning a lot of languages along the way..
11:51:38 <glittershark> well count my success-story among one of them :)
11:51:57 <glittershark> and if I can talk you out of writing anything at all in Go...
11:51:59 <bollu> type error with RankNTypes: https://gist.github.com/bollu/9ff95618d8ea32a446e0
11:52:06 <bollu> I'm not sure why it's not instantiating type variables
11:52:20 <average> this would probably be my 10th language learned. what I'm interested in is learning it but being able to make use of it
11:52:41 <bollu> 	why isn't haskell instantiating the type variables 'a' and 'r'
11:52:53 <glittershark> average: haskell is a great language for improving the way your brain thinks about programming, in my experience
11:53:11 <glittershark> it's also a great language for getting things done in :)
11:53:16 <monochrom> bollu, are you sure you know "forall b. a -> (b -> r) -> r" vs "a -> (forall b. b -> r) -> r"?
11:53:19 <average> glittershark: is the lead of the previous Golang codebase still in your team ?
11:53:23 <roelof> How can I refractor this code : http://lpaste.net/148685
11:53:43 <glittershark> average: no, he got fired for other reasons
11:53:52 <average> interesting
11:53:58 <glittershark> average: a while ago, actually, which meant I ended up being the lead through the majority of the development of the golang codebase
11:54:09 <bollu> monochrom: good point, I don't know
11:54:21 <glittershark> average: I wrote maybe 90% of the (5000 lines of) code for the final implementation of the Go version
11:54:23 <bollu> monochrom: I can take a stab at it but I think I'd be wrong
11:54:34 <bollu> monochrom: what is the exact difference?
11:54:38 <glittershark> same functionality was 572 lines of haskell, not that LOC means anything really
11:54:55 <average> it does mean something
11:55:02 <glittershark> yeah
11:55:07 <glittershark> just not *everything*
11:55:11 <monochrom> it is also why "for all x, foo implies bar" is a universal sentence but "(for all x, foo) implies bar" is an existential sentence.
11:55:13 <johnw> Fuco, bollu: https://gist.github.com/0c6dc1c5b2d56100cc44
11:55:22 <average> less LOC means higher density, which means less people understand it, which hopefuly at least translates into job security
11:55:30 <glittershark> ha!
11:55:33 <glittershark> I hope the opposite
11:55:40 <average> why the opposite ?
11:55:40 <bollu> johnw: that's a Coq proof right?
11:55:43 <glittershark> I hate code ownership with a passion
11:55:44 * hackagebot yesod-auth-oauth2 0.1.6 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.6 (PatrickBrisbin)
11:55:51 <johnw> bollu: yes; one direction is trivial, the other impossible
11:56:05 <average> glittershark: you hate code ownership, but you're the lead on the project
11:56:10 <glittershark> The haskell version of this project has actually seen dramatically more contribution from other team members than the Go version, which basically ended up being only me working on it
11:56:14 <bollu> monochrom: (for all x, foo) implies bar <- why is this existential?
11:56:29 <glittershark> I hate code ownership but I can't seem to escape it
11:56:58 <bollu> glittershark: writing servers is the worst. you get a call at 9 PM when you're out on a date or something that the server caught fire
11:57:02 <average> well using Haskell instead of Go seems to be a code ownership decision among other things
11:57:07 <average> :)
11:57:09 <glittershark> bollu: we have an on-call schedule for that
11:57:34 <bollu> monochrom: I can tell you what "a -> (forall b. b -> r) -> r" means
11:57:34 <glittershark> average: it's a maintainability and pragmatism decision that wasn't actually made until one other person in the company learned haskell
11:57:45 <roelof> No one who can help me with a hint how I can rewrite this without the if then : http://lpaste.net/148685
11:58:00 <bollu> that means I'm given a function that takes some "a", and a function that gives me back an r *for all* choices of type b, and then expects a value back
11:58:03 <glittershark> I didn't advocate for haskell because nobody else could write it, I advocated for haskell because I think it's a better language
11:58:11 <bollu> monochrom: I could implement it like so: f a g = g a
11:58:14 <glittershark> at least at the particular problem that we're solving
11:58:25 <bollu> monochrom: I don't know what the former means : forall b. a -> (b -> r) -> r
11:58:33 <bollu> monochrom: could you explain to me what it means?
11:58:48 <lyxia> roelof: pattern guards depositIfAccount acct | accountName acct == acctName = deposit ... | otherwise = acct
11:59:10 <monochrom> the user gives you two parameters, x1 :: a, x2 :: b->r
11:59:30 <monochrom> but the types a and b (and r) are not your choice. it's the user's choice.
11:59:45 <monochrom> so you can't be sure that the user chose a=b
11:59:56 <glittershark> average: for the record, it wasn't actually my decision, I just argued for it
12:00:06 <bollu> monochrom: isn't the forall redundant?
12:00:12 <monochrom> yes
12:00:12 <pranz> roelof: http://lpaste.net/148685
12:00:18 <bollu> monochrom: what is difference between that and a -> (b -> r) -> r
12:00:21 <bollu> oh, there is none?
12:00:26 <monochrom> no difference, by convention
12:00:27 <bollu> hm, so I do understand the difference..?
12:00:31 <bollu> I see
12:00:31 <monochrom> yes
12:01:01 <monochrom> forall a b r. a -> (b -> r) -> r  for maximum redundancy
12:01:03 <bollu> monochrom: this was your type, right? (forall b. a -> (b -> r) -> r)
12:01:09 <roelof> Thanks all, 
12:01:09 <bollu> monochrom: so the forall is redundant?
12:01:11 <pranz> roelof: unless you replace your list with a Map I don't think there is anything more to be done
12:01:33 <monochrom> no. ((forall b. a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
12:01:51 <monochrom> this has zero redundancy
12:02:07 <monochrom> even the parens are all mandatory
12:02:21 <bollu> monochrom: oh, because the "b" is inside another function context you need the forall?
12:02:29 <roelof> pranz:  oke, that the next step I wanted to work on. Converting account from a list to a map 
12:02:29 <monochrom> yes
12:03:06 <bollu> monochrom: thanks a ton. I'll get back to you in 5 after playing with the question
12:03:36 <bollu> monochrom: but b never repeats in the function 
12:03:46 <roelof> Another question: Can I do two things after the then first asking for a amount and calling the function ?? 
12:03:46 <bollu> monochrom: what's the difference if I omit the forall b. 
12:04:06 <monochrom> you, the implementer, is unaffected. the user is affected.
12:04:35 <bollu> monochrom: hm, I see
12:04:38 <bollu> monochrom: oh right.
12:04:52 <bollu> monochrom: because the user will need to supply a type that works with all b
12:05:03 <monochrom> when finally I reveal where this horrible type comes from, I will be able to explain how the extra forall b gives the user more freedom.
12:05:10 <pranz> roelof: yeah, no problem
12:06:09 <bollu> monochrom: when I'm creating a lambda, how do I assert that my lambda parameter is a "forall" parameter?
12:06:24 <aweinstock> average: newChan, readChan, and writeChan in Control.Concurrent do the same thing as Go's channels, I think
12:06:57 <aweinstock> average: and forkIO spawns a green thread, which is just like a goroutine
12:07:00 <monochrom> you use type signatures.
12:07:09 <bollu> monochrom: how do you type signature a lambda?
12:07:11 <bollu> use :: ?
12:07:24 <aweinstock> monochrom: does that require ScopedTypeVariables extension?
12:07:30 <argoneus> if I get this right
12:07:33 <bollu> > (\a b -> a + b :: Int -> Int -> Int) $ a b
12:07:35 <monochrom> usually the top level type signature sufficies
12:07:35 <lambdabot>      Couldn't match expected type â€˜Expr -> Int -> Int -> Intâ€™
12:07:35 <lambdabot>                  with actual type â€˜Exprâ€™
12:07:35 <lambdabot>      The function â€˜aâ€™ is applied to one argument,
12:07:50 <argoneus> if I have something like add :: Int -> Int -> Int
12:07:58 <argoneus> does this function technically return another function?
12:08:02 <monochrom> aweinstock, we are playing RankNTypes
12:08:22 <argoneus> like I can just say it takes two arguments and returns an integer
12:08:23 <aweinstock> > (\(f :: forall a. Num a => a -> a -> a) -> (f 1 2, f 5.0 3.0)) (+)
12:08:25 <lambdabot>  (3,8.0)
12:08:32 <argoneus> but because of currying or whatever it takes an integer and returns another function, right?
12:08:42 <monochrom> ok, ScopedTypeVariables works too
12:09:04 <Th30n> argoneus: exactly
12:09:36 <monochrom> @type \(f :: forall a. Num a => a -> a -> a) -> (f 1 2, f 5.0 3.0)
12:09:37 <lambdabot> (Fractional t1, Num t) => (forall a. Num a => a -> a -> a) -> (t, t1)
12:11:09 <bollu> monochrom: FFS, I still wind back up at my original formulation because in my thing, I take the bTor and don't use it, so it should work forall b . ...
12:13:05 <azathoth99> more power than u can possibly imagine!!! haskell!! why all these punks say things are sloppy installing haskell?
12:13:36 <monochrom> are you ok?
12:13:51 <azathoth99> nop
12:13:59 <azathoth99> make 125k a yea and wana make 10x that
12:14:03 <bollu> xD
12:14:12 <azathoth99> Ima megagenius but no one wnats me to implement ideas
12:14:15 <azathoth99> my own way
12:14:18 <azathoth99> just want thier crayy way
12:14:47 <ReinH> argoneus: to answer your question from earlier, Haskell is by far the best language for DSLs and EDSLs that I have ever used. The immense power of ADTs, the type system, monads and other structures and their free constructions, and the ease of writing parsers (for traditional DSLs) just make it a joy.
12:14:48 <azathoth99> happstack.com might help me feed my ego
12:15:03 <bollu> monochrom: in that case, you were typing the *parameter* to the lambda
12:15:06 <azathoth99> adt??
12:15:12 <bollu> monochrom: I want to type the *lambda* itself
12:15:18 <glittershark> azathoth99: Abstract Data Type
12:15:20 <argoneus> ReinH: I keep hearing "domain specific language", but I'm not sure what to imagine under it
12:15:21 <azathoth99> oow
12:15:25 <monochrom> you can give it a type signature
12:15:31 <Cale> glittershark: Algebraic Data Type
12:15:32 <azathoth99> is darcs better than git?
12:15:36 <glittershark> oh
12:15:36 <argoneus> like examples of domains
12:15:36 <glittershark> yeah
12:15:39 <bollu> monochrom: can you show me how?
12:15:46 --- mode: ChanServ set +o mauke
12:15:46 --- mode: mauke set +b *!*@gateway/web/freenode/ip.108.7.239.13
12:15:47 <glittershark> I always muck up the algebraic vs abstract thing
12:15:51 --- kick: azathoth99 was kicked by mauke (bye)
12:15:55 <monochrom> I mean, you can put it in a "let" or "where", which allows you to give a type signature
12:16:00 <bollu> Cale: I like how you answered "algebraic" and glittershark answered "abstract"
12:16:00 <glittershark> ty mauke
12:16:06 <bollu> oh hm, thanks
12:16:15 <argoneus> spooky
12:16:17 <Cale> bollu: Algebraic makes more sense in context
12:16:27 <monochrom> ADT in #haskell is algebraic. ADT in #java is abstract.
12:16:37 <mauke> don't feed the protontorpedo
12:16:38 <monochrom> sue them.
12:16:41 <ReinH> It's rather annoying that A(lgebraic)DT and A(bstract)DT are basically opposite terms.
12:16:52 <argoneus> ...protontorpedo?
12:17:17 <dolio> @protontorpedo
12:17:17 <lambdabot> and haskell is general purpose?
12:17:24 <Cale> @protontorpedo
12:17:24 <lambdabot> can u build things fast in haskell?
12:17:26 <ReinH> But in Haskell ADT is going to be Algebraic pretty much every time.
12:17:27 <Cale> @protontorpedo
12:17:27 <lambdabot> am I cracked?
12:17:28 <Cale> @protontorpedo
12:17:28 <lambdabot> is ghc bad for learning?
12:17:29 <Cale> @protontorpedo
12:17:29 <lambdabot> does haskell sclae up to programming in the large?
12:17:34 <MarcelineVQ> haha
12:17:44 <average> @protontorpedo
12:17:44 <lambdabot> how can haskell automate ftp?
12:17:47 <ReinH> Woops.
12:17:47 <aweinstock> @help protontorpedo
12:17:48 <lambdabot> protontorpedo is silly
12:17:48 <average> @protontorpedo
12:17:48 <lambdabot> hey guys can haskeel be used to produce fast webapps?
12:17:51 --- mode: mauke set -o mauke
12:17:51 <bollu> monochrom:  f g h = let x = (\a b' -> h a) :: (forall b. a -> (b -> r) -> r) in g x h
12:17:54 <monochrom> my solution is to never write "ADT"
12:18:07 <ReinH> Alas poor Cale, I hardly knew ye
12:18:08 <bollu> monochrom: wrong again? :(
12:18:10 <hunteriam> @protontorpedo
12:18:10 <lambdabot> how deos haskell differ from ml or lisp?
12:18:16 <bollu> @bollu
12:18:16 <MarcelineVQ> man freenode is draconian
12:18:16 <lambdabot> unexpected end of input: expecting number, "d" or "("
12:18:24 <argoneus> what the fuck
12:18:31 <monochrom> well, the compiler is the judge I trust
12:18:42 <argoneus> how is this spamming
12:18:42 <bollu> what? oh, I thought protontorpedo was the nick of a person or something
12:18:45 <average> how can I add something to @protontorpedo ?
12:18:47 <aweinstock> @drop table database
12:18:47 <lambdabot> table database
12:18:59 <argoneus> @protontorpedo
12:18:59 <lambdabot> or does it become a mishmash of code?
12:19:04 <ReinH> argoneus: because of algorithms.
12:19:04 <monochrom> but make sure you turn on enough extensions
12:19:09 <average> How can I make money with Haskell ?
12:19:09 <aweinstock> @'apostrophe
12:19:09 <lambdabot> Unknown command, try @list
12:19:10 <average> any idea ?
12:19:11 <bollu> monochrom: which ones?
12:19:17 <bollu> RankNTypes?
12:19:17 <average> here's a live protontorpedo 
12:19:18 <byorgey> average: you can't, it is a list of quotes from an actual user
12:19:36 <bollu> byorgey: can you add yourself to the list?
12:19:40 <monochrom> yes at the very least
12:19:42 <average> @average
12:19:42 <lambdabot> Unknown command, try @list
12:19:44 <average> @average
12:19:44 <lambdabot> Unknown command, try @list
12:19:47 <average> @list
12:19:47 <lambdabot> What module?  Try @listmodules for some ideas.
12:19:49 <ReinH> When your in channel behavior is so bad that your nick is now a cautionary tale...
12:19:55 <byorgey> bollu: what?
12:19:58 <aweinstock> @quote protontorpedo
12:19:58 <lambdabot> protontorpedo says: is darcs better than git?
12:20:10 <argoneus> so about DSLs... if I made a game, I could easily make a DSL to spawn/remove/manipulate entities in my game?
12:20:14 <argoneus> that kind of use case?
12:20:22 <monochrom> you do not want to earn prontotorpedo's same status
12:20:22 <bollu> byorgey: to the list of users lambdabot remembers quotes from
12:20:27 <bollu> monochrom: who was he?
12:20:31 <monochrom> a troll
12:20:35 <bollu> ahh
12:20:39 <ReinH> Hmm... I think it's possible that meta discussions about protontorpedoing are worse than actual protontorpedoing.
12:20:47 <mauke> *is. I just kicked him out again
12:20:50 <aweinstock> "is darcs better than git?" was something that azathoth99 said literally word-for-word
12:20:58 <mauke> aweinstock: I just added it
12:21:08 <aweinstock> ah
12:21:16 <monochrom> other trolls come and go. prontotorpedo kept coming back so much, we have a special place for them.
12:21:16 <hunteriam> hey guys
12:21:18 <aweinstock> @quote zip`ap`tail
12:21:19 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
12:21:23 <monochrom> you do not want to earn prontotorpedo's same status :)
12:21:25 <hunteriam> I just got freenode banned for saying @protontorpedo
12:21:29 <mauke> s/kept/keeps/
12:21:35 <ReinH> Oh. Prontotorpedo, not protontorpedo. Shame.
12:21:53 <bollu> oh, I thought it was proton as well
12:22:13 <average> I need to make a website called  haskellmoney.com
12:22:19 <average> or haskellmoney.biz
12:22:23 <monochrom> I have typos. do not quote it on me.
12:22:28 <bollu> https://gist.github.com/bollu/9ff95618d8ea32a446e0
12:22:33 <ReinH> Can we talk about Haskell again?
12:22:34 <monochrom> only my types don't contain typos.
12:22:38 <bollu> why does haskell complain about type variables?
12:22:48 <Clint> haskell never complains
12:22:50 <bollu> https://gist.github.com/bollu/9ff95618d8ea32a446e0 <- why doesn't it introduce the a and r automatically?
12:22:57 <bollu> should I do something to ask it to?
12:23:02 <bollu> should I ask it to do something**
12:23:13 <byorgey> bollu: you need to turn on ScopedTypeVariables, and add  f :: forall a r. ...
12:23:20 <argoneus> I shouldn't have opened that likn
12:23:22 <argoneus> link*
12:23:29 <argoneus> now I feel dumb again
12:23:50 <monochrom> oh, so it works
12:23:54 <bollu> monochrom: it compiles!
12:23:54 <bollu> xD
12:23:58 <bollu> monochrom: yiss
12:24:01 <ReinH> bollu: (forall b. a -> (b -> r) -> r) introduces an explicit quantifier, which replaces the implicit quantifier, but it does not quantify a or r.
12:24:14 <ReinH> At least I thinkt that's the issue.
12:24:20 <bollu> monochrom: so my initial solution was right, except I needed the type signature I guess
12:24:31 <monochrom> but so does f g h = g (\a b' -> h a) h
12:24:44 <monochrom> ok, revelation time.
12:24:45 <bollu> monochrom: then why did you tell me I was wrong then?
12:24:49 <bollu> monochrom: yes, do tell
12:24:58 <monochrom> I only asked ghc
12:25:14 <monochrom> it comes from Control.Monad.Cont's Cont and callCC
12:25:30 <bollu> wait, callCC is that ugly?
12:25:39 <bollu> oh wow, I've never thought of expanding Cont r a and looking at it
12:25:49 <monochrom> for special case Cont, callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
12:26:04 <bollu> omg, I shou;d have been able to spot that!
12:26:31 <monochrom> it turns out that you can change it to ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a, and you can still use the implementation, no change.
12:26:44 <monochrom> but the extra forall b gives the user more flexibility
12:26:50 <bollu> monochrom: how so?
12:26:57 <bollu> monochrom: doesn't it hinder the user?
12:27:07 <bollu> monochrom: since the user needs to give something that works for all b?
12:27:27 <byorgey> bollu: no, the user gives a function that *takes an argument* which has to work for all b =)
12:28:07 <bollu> byorgey: hm, yes, but the output of the function needs to work for all b. How do you even interpret that?
12:28:29 <ReinH> byorgey: So rank n quantification has a polarity similar to valence, right? e.g. rank n | even n vs rank n | odd n?
12:28:36 <ReinH> Is this explored anywhere?
12:28:36 <monochrom> the user receives, not gives, a thing of type "forall b. a -> Cont r b".
12:28:57 <dolio> Like valence electrons?
12:29:01 <ReinH> in terms of the "who gets to choose a" intuition
12:29:07 <byorgey> ReinH: I'm not sure what you mean by valence, but yes
12:29:09 <ReinH> dolio: like positive and negative valence
12:29:24 <bollu> monochrom: um, can you go over that again? 
12:29:32 <dolio> Do you mean variance?
12:29:34 <bollu> monochrom: what do mean by "receives"?
12:30:01 <ReinH> I guess "valence" isn't the term of art for that.
12:30:18 <dolio> Well, it might be, but I've never heard it.
12:30:45 * hackagebot uniform-io 1.1.0.0 - Uniform IO over files, network, anything.  https://hackage.haskell.org/package/uniform-io-1.1.0.0 (marcosdumay)
12:30:48 <bollu> byorgey: the users takes an argument "a", which needs to return a Cont r b that works for all b?
12:31:07 <bollu> I'm not sure I can interpret that right
12:31:23 <byorgey> bollu: if I, the user, want to call callCC, I have to provide a function of type   ((forall b. a -> Cont r b) -> Cont r a)
12:31:26 <ReinH> I guess polarity is the common term, as in "an argument starts in positive position and every time it goes to the left of an arrow, the polarity is flipped"
12:31:26 <byorgey> right?
12:31:43 <bollu> byorgey: right
12:31:49 <byorgey> bollu: so when I implement that function, I receive an argument of type  (forall b. a -> Cont r b)  and I have to produce a value of type  Cont r a
12:31:58 <dolio> ReinH: You can think of it from a subtyping perspective, too.
12:32:06 <byorgey> so the function of type  (forall b. a -> Cont r b)  will be provided by the implementation of callCC
12:32:11 <ReinH> dolio: Oh? How so?
12:32:21 <dolio> Where: forall a. T[a] < T[U] < exists a. T[a]
12:32:44 <monochrom> for example, "callCC (\quit -> if True then (quit () >>= \x -> return [x]) else (quit () >>= \y -> return [[x]]))" is allowed if you have the extra forall b.
12:32:58 <bollu> byorgey: oh, I think I get it!
12:33:01 <dolio> And T -> U < T' -> U' if U < U' and T' < T.
12:33:10 <ReinH> dolio: I think I just s/variance/valence in my brain because I've been reading too much HoTT or something.
12:33:12 <bollu> so, because you only supply callCC with ((forall b. a -> Cont r b) -> Cont r a) 
12:33:20 <byorgey> so when I use that function, I get to pick whatever type b I want, just like I get to provide it with whatever argument of type a I want
12:33:22 <bollu> callCC has to figure out how to construct the ((forall b. a -> Cont r b))
12:33:25 <bollu> to get the Cont r a out
12:33:28 <bollu> right?
12:33:28 <byorgey> bollu: right
12:33:45 <bollu> ah, I see
12:33:47 <byorgey> bollu: in general, every time you go to the left of ->, the responsible party flips
12:33:53 <ReinH> dolio: Ok, I think I see what you mean.
12:34:26 <ReinH> byorgey: I wonder, are these polarities perhaps the same concept in some more general sense?
12:34:28 <bollu> f :: (forall b. a -> b) -> c (the called function needs to be able to create a "b" that works out.
12:34:44 <ReinH> I guess that's a question for dolio and anyone else too
12:34:46 <bollu> f :: (forall a. a -> b) -> c - (the callee needs to create a function that works with all a)
12:34:48 <byorgey> ReinH: which polarities?
12:34:54 <bollu> byorgey: is that what you were getting at?
12:35:04 <ReinH> byorgey: co/contravariance and rank n types
12:35:05 <byorgey> bollu: right
12:35:18 <byorgey> ReinH: yes, they are very related
12:35:22 <ReinH> They both involve a "moving to the left of an arrow flips polarity", etc
12:35:23 <bollu> byorgey: damn, this is really cool
12:35:39 <byorgey> =)
12:35:40 <ReinH> byorgey: so my intuition is that they unify at some more abstract level
12:35:48 <bollu> monochrom: now can you tell me where I can get some extra flexibility with the forall b ?
12:35:55 <bollu> byorgey: ^ same question :)
12:36:02 <monochrom> "callCC (\quit -> if True then (quit () >>= \x -> return [x]) else (quit () >>= \y -> return [[x]]))" is allowed if you have the extra forall b.
12:36:11 <byorgey> ReinH: sure, they probably do
12:36:20 <ReinH> byorgey: Ok :)
12:36:49 <monochrom> x and y have different types
12:36:55 <monochrom> err, typo
12:37:09 <monochrom> callCC (\quit -> if True then (quit () >>= \x -> return [x]) else (quit () >>= \y -> return [[y]]))
12:37:46 <monochrom> I don't actually like that, it is not too obvious
12:37:54 <bollu> monochrom: oh, so I can have different return types at different branches and that is cool because there's a forall b at the return type?
12:37:58 <bollu> damn, that's slick as all hell
12:38:06 <monochrom> callCC (\quit -> if True then (quit () >>= \x -> return (x+1)) else (quit () >>= \y -> return (y ++ y)))
12:38:32 <bollu> monochrom: trip down memory lane - you taught me Cont IIRC?
12:38:39 <monochrom> I forgot
12:40:23 <hunteriam> hey guys
12:40:26 <hunteriam> just a warning
12:40:30 <hunteriam> dont say that thing i said earlier
12:40:35 <hunteriam> I got network banned for saying it
12:40:41 <hunteriam> and had to contact freenode just now
12:41:15 <glittershark> ??
12:41:26 <hunteriam> begins with proton
12:41:30 <bollu> monochrom, byorgey, ReinH: thanks a lot for the lesson
12:41:36 <monochrom> but Cale said it 3 times without consequence
12:41:39 <bollu> I'm heading off to bed now, but I'll come back tomorrow with questions
12:41:41 <bollu> thanks a lot!
12:41:43 <hunteriam> no he faced conseequence
12:41:50 <hunteriam> 3:17 PM â‡ Cale quit (~Cale@CPEc8d3a35c2cdd-CM0c473de9d680.cpe.net.cable.rogers.com) Killed (Sigyn (Spam is off topic on freenode.))
12:41:53 <monochrom> I see
12:41:55 <hunteriam> thats a network ban
12:41:55 <Cale> haha, got auto-killed :)
12:41:56 <glittershark> I'm still confused
12:41:57 <Cale> (as well)
12:41:59 <Cale> Mine for demonstrating the @protontorpedo command :P
12:42:01 <Cale> monochrom: I said it 5 times, and got K-lined :D
12:42:01 <byorgey> bollu: night!
12:42:02 <bollu> I wonder what you said
12:42:07 <bollu> night guys :)
12:42:12 <hunteriam> i tried it once after you did Cale and got killed
12:42:17 <glittershark> is it just because you said it 3 times in a row?
12:42:41 <hunteriam> Apparently you can get killed for perpetuating other peoples `spam`
12:42:46 <Cale> It might be impossible to use the command for a bit, since the automatic spambot detector will be looking for the same thing
12:43:10 <byorgey> the horror!
12:43:30 <monochrom> use the cunning fact that lambdabot accepts a small edit distance
12:43:36 <monochrom> for example:
12:43:42 <monochrom> @stab monochrom
12:43:43 * lambdabot beats up monochrom
12:43:46 <hunteriam> @brotontorpedo
12:43:46 <lambdabot> what echniques can be used to scael application in haskell?
12:43:54 <glittershark> ha!
12:43:58 <hunteriam> @trolltontorpedo
12:43:58 <lambdabot> Unknown command, try @list
12:44:49 <byorgey> if anyone says anything else within an edit distance of 3 from @HeWhoMustNotBeNamed, *I* am going to ban them.
12:45:33 <Polarina> Voldemort? :|
12:45:46 <Clint> pikachu
12:45:48 <byorgey> no, you know, the OTHER one
12:46:14 <MarcelineVQ> betty
12:46:27 <monochrom> YMMV?
12:47:02 <hunteriam> @betty
12:47:08 <monochrom> nevermind, typo
12:47:10 * edwardk looks up, hoping for a nice productive haskell oriented discussion, sees a screen full of protontorpedo and leaves.
12:47:10 <hunteriam> have mercy please
12:47:40 <byorgey> what's new in edwardk land?
12:47:52 <ReinH> hunteriam: please stop. If you want to mess with lambdabot, do it in a pm.
12:48:13 <edwardk> byorgey: not much. was playing with propagators for a good long while, gave a talk, itch scratched
12:48:21 <glittershark> who owns lambdabot?
12:48:27 <edwardk> int-e
12:48:28 <glittershark> curious
12:48:30 <glittershark> ok
12:48:39 <glittershark> clearly I'm new :)
12:48:56 <edwardk> glittershark: before int-e i think cale used to run her
12:49:08 <glittershark> I'm delighted that she's female
12:50:03 <ReinH> byorgey: you know you're just inviting people to say things an edit distance of 4 away...
12:50:53 <bollu> don't think I can sleep
12:50:56 <bollu> have a question
12:51:43 <hunteriam> yes?
12:51:49 <edwardk> ReinH: clearly the answer is to just state that statements made within an unspecified exponentially distributed random edit distance will be met harshly and that puts it to bed indefinitely where it belongs.
12:51:57 <bollu> if there's a type signature f :: (forall h :: a -> b -> â€¦ -> h -> .. j) or something
12:52:05 <bollu> how do you know whose resposibility the h is?
12:52:07 <bollu> caller or callee?
12:52:25 <ReinH> edwardk: I would also accept "based on my determination of the matter" from an op :)
12:52:26 <hunteriam> h is a supplied arg
12:52:37 <bollu> hunteriam: yes
12:52:40 <glittershark> caller, if I understand quantified types
12:52:46 <monochrom> caller provides h
12:52:47 <glittershark> then again, I probably don't
12:52:57 <hunteriam> how could callee provide h bollu ?
12:53:13 <bollu> okay, and if it were (f :: forall z . a -> b -> .. z), then it is the callee's responsibility right?
12:53:27 <edwardk> byorgey: looking forward to ghc 8 so that i can clean up my hask code
12:53:29 <glittershark> still the caller
12:53:31 <monochrom> if you want to do it in detail, I'll use a smaller example. "a -> b -> c".  this is also "a -> (b -> c)".
12:53:33 <bollu> what?
12:53:45 <glittershark> the caller 'decides' the type
12:53:49 <monochrom> "a -> (b -> c)" user provides a, receives "b -> c".
12:53:50 <hunteriam> if the callee supplies it its not really forall z is iot?
12:53:53 <edwardk> byorgey: https://ghc.haskell.org/trac/ghc/ticket/10318 being resolved means i can clean up hask and algebra
12:54:07 <monochrom> when user receives "b -> c", they use it by providing "b"
12:54:13 <monochrom> so at the end, user still provides b
12:54:19 <bollu> monochrom: ogg
12:54:20 <bollu> ohh*
12:54:37 <monochrom> this extends to long chains such as "a -> b -> c -> d -> e"
12:54:39 <glittershark> forall a. a is unconstrained, the caller constrains it to a concrete type
12:55:05 <bollu> oh, but in the case of ((forall b. a -> b) -> c), the reason it becomes the caller's responsibility is that the caller has to *use* that (a -> b) in some way
12:55:07 <RyanGlScott> edwardk: How does hask compile with GHC 7.8 then if you need recursive superclasses?
12:55:19 <aweinstock> is it safe to private message lambdabot about @hewhomustnotbenamed?
12:55:22 <bollu> so, f :: a -> (forall b. a -> b) -> c or something would be the caller's choice right?
12:55:22 <glittershark> and using it constrains the type
12:55:40 <bollu> no, would be the implementer's choice*
12:56:04 <bollu> f :: a -> (forall b. a -> b) -> c <- f's choice, right?
12:56:07 <johnw> bollu: you should try it out
12:56:12 <glittershark> actually I had a question from the other day that I wanted to ask here
12:56:15 <bollu> johnw: implementing them?
12:56:20 <bollu> johnw: or,,?
12:56:22 <bollu> or..*
12:56:23 <johnw> yes
12:56:30 <edwardk> because i can then require an class (Functor k, Dom k ~ Op k, Cod k ~ Nat k (->)) => Category (k :: i -> i -> *) where ...; class (Category (Dom f), Category (Cod f)) => Functor (f :: i -> j) where type Dom f :: i -> i -> *; type Cod f :: j -> j -> *; ... -- despite the fact that this creates a superclass cycle between Functor and Category
12:56:34 <johnw> question like this make for perfect one-liners :)
12:56:40 <monochrom> ok, we need to talk value and type separately. in "((forall b. a -> b) -> c)", user chooses the type for b, then recevies a value of type a->user_chosen_type
12:56:42 <glittershark> why can't I `map toInteger xs` given `xs :: [forall n. Integral n => n]`
12:56:50 <edwardk> right now i have to hack around it by using 3 levels of approximation to Category and 2 levels of approximation to Functor
12:56:54 <monochrom> err, no, I said it wrong
12:57:05 <edwardk> and then make users define Category'' and Functor' and use Category and Functor
12:57:15 <byorgey> edwardk: ah, nice
12:57:33 <notdan> glittershark: because toInteger gets instantiated to the specific type in `map`
12:57:34 <notdan> I suppose?
12:57:40 <glittershark> so how *do* I do that
12:57:56 <monochrom> in "((forall b. a -> b) -> c)", implementer chooses the type for b, but user provides a value of type a->b
12:58:05 <edwardk> similarly i can require, say, a group to form a module over the integers, while requiring thatargument of a module to be a group
12:58:09 <bollu> monochrom: right
12:58:11 <notdan> Hm, let's see. You can probably use a wrapper
12:58:32 <bollu> monochrom: when does the choosing happen and when does the supplying happen?
12:58:41 <edwardk> similar concerns arise in my multicategory code in tricky places
12:58:47 <bollu> monochrom: as in, if the implementer can choose *any* b, how does the user know what to suppply?
12:58:53 <edwardk> so 8 gives me a lot of cool toys
12:58:54 <bollu> monochrom: that is why we need the forall b. anyway right?
12:59:15 <monochrom> the user is never told. the user is obliged to provide enough polymorphism.
12:59:16 <glittershark> :t ((\x -> toInteger x) :: forall n. Integral n => n -> Integer))
12:59:17 <lambdabot> parse error on input â€˜)â€™
12:59:22 <glittershark> :t ((\x -> toInteger x) :: forall n. Integral n => n -> Integer)
12:59:23 <lambdabot> Integral n => n -> Integer
12:59:27 <bollu> monochrom: ah right. understood
12:59:50 <glittershark> :t ((\x -> toInteger x) :: forall n. Integral n => n -> Integer) ([1,2,3,4] :: [forall n. Integral n => n])
12:59:51 <lambdabot>     Illegal polymorphic or qualified type: forall n. Integral n => n
12:59:51 <lambdabot>     Perhaps you intended to use ImpredicativeTypes
12:59:51 <lambdabot>     In an expression type signature: [forall n. Integral n => n]
12:59:55 <glittershark> > ((\x -> toInteger x) :: forall n. Integral n => n -> Integer) ([1,2,3,4] :: [forall n. Integral n => n])
12:59:57 <scx_> hello
12:59:57 <lambdabot>      Illegal polymorphic or qualified type: forall n. Integral n => n
12:59:57 <lambdabot>      Perhaps you intended to use ImpredicativeTypes
12:59:57 <lambdabot>      In an expression type signature: [forall n. Integral n => n]
12:59:59 <monochrom> I don't know about the "when" question. it's deep.
13:00:02 <glittershark> aww, lambdabot :(
13:00:09 <bollu> scx: hello
13:00:24 <scx> How to install it globally?: cabal install HTTP curl network-uri
13:00:51 <glittershark> maaan
13:01:22 <glittershark> http://lpaste.net/8386155212896731136 so why doesn't this work?
13:01:57 <monochrom> map's type narrow you down to monomorphic again
13:02:25 <glittershark> would I have to rewrite map, then?
13:02:35 <byorgey> glittershark: what are you trying to do?
13:02:47 <glittershark> convert a list of integrals to a list of integers?
13:02:50 <byorgey> [forall n. Integral n => n] is very strange and is unlikely to be what you want
13:02:54 <glittershark> exactly what it says on the tin
13:02:56 <glittershark> yeah, I know
13:02:57 <monochrom> I don't think you can meaningfully
13:03:17 <glittershark> I'm still a little confused about why a function whose return value is monomorphic can't be called like that
13:03:34 <monochrom> and "[forall n. Integral n => n]" is an impredicative type, not something normal.
13:03:36 <ReinH> I mean, if it were exactly what it said on the tin then it would do what you want, which it does not.
13:03:52 <glittershark> my aim here is to wrap my head around impredicative types
13:04:15 <monochrom> ah alright, but GHC is a poor lab for that. it is unable.
13:04:17 <ReinH> Well, it is exactly what it says on the tin, it is just not what you think it says on the tin.
13:04:18 <notdan> This seem to work: http://lpaste.net/148691
13:04:32 <bollu> monochrom: so, something like  [forall a. Show a =>  a] will let me create a list of all Showables?
13:04:35 <notdan> glittershark: http://lpaste.net/148691
13:04:47 <monochrom> that is not a list of Showables
13:04:56 <glittershark> thx notdan! so from what I'm understanding the problem is Prelude's, not mine
13:04:57 <bollu> monochrom: so what is it?
13:05:06 <bollu> monochrom: actually, why is it not? :)
13:05:11 <monochrom> something like [exists a. Show a *> a] is. but that's pseudocode.
13:05:15 <ReinH> notdan: Well, it does, but in practice it is no better than [fromIntegral x, fromIntegral y, fromIntegral z]
13:05:32 <ReinH> because it's just [MkIntegral x, MkIntegral y, MkIntegral z] plus extra machinery
13:05:37 <notdan> yeah, absolutely
13:05:51 <bollu> monochrom: how do I read the former versus the latter ?
13:06:12 <glittershark> am I approaching this right or am I going in a completely wrong direction?
13:06:42 <bollu> also, yoneda lemma: it just tells you that any locally small category can be mapped to a set and functions on the set?
13:06:46 <byorgey> notdan: that is not the same.  Integral'  is basically   exists a. Integral a => a,  not  forall a. Integral a => a
13:07:13 <monochrom> "[forall a. Show a =>  a]" is best understood by forgetting the list structure and just looking at one single element, "mystery :: forall a. Show a => a". can you implement an example of mystery?
13:07:19 <notdan> byorgey: well, yeah, but otherwise it doesn't make sense
13:07:28 <notdan> the latter doesn't exist
13:07:43 <bollu> monochrom: no, you can't I think
13:08:02 <byorgey> > 3 :: forall a. Integral a => a   -- sure it does
13:08:04 <lambdabot>  3
13:08:09 <glittershark> monochrom: I can implement mystery :: foral a. Integral a. a
13:08:18 <monochrom> so the type "forall a. Show a => a" does not mean an existential type related to Show
13:08:18 <glittershark> well I could if I typed it right
13:08:29 <bollu> monochrom: oh
13:08:31 <bollu> monochrom: huh
13:08:43 <bollu> monochrom: hmm, so I need an exists
13:08:43 <xplat|work> forall a. Read a => a is implementable
13:08:45 <notdan> byorgey: touche
13:08:55 <glittershark> this whole thing comes about because Haskell's number and string literals are existentially quantified
13:08:56 <ReinH> bollu: Yoneda's lemma says that there is an isomoprhism between forall r. ((a -> r) -> f r) and f a
13:09:02 <ReinH> bollu: did you read https://www.schoolofhaskell.com/user/bartosz/understanding-yoneda ?
13:09:11 <bollu> ReinH: yes, I was
13:09:12 <notdan> byorgey: I didn't recognize you the Integral class had methods of building stuff up
13:09:27 <bollu> xplat|work: how so? you just say read "" or something?
13:09:30 <monochrom> [exists a. Show a *> a] is pseudocode for a list of Showables. the Haskell code is [Showable], and you define the Showable type.
13:09:37 <xplat|work> bollu: yeah
13:09:59 <notdan> it's the class Num actually, hm
13:10:20 <monochrom> after you have implemented either "forall a. Integral a => a" or "forall a. Read a => a", now ask yourself what it really does. (it does not do what an existential value does.)
13:10:40 <monochrom> (instead, it does what a universal value, aka polymorphic value, does.)
13:10:43 <bollu> monochrom: it tries to create an "a" for any a you throw at it
13:10:48 <bollu> monochrom: right?
13:10:54 <monochrom> yes
13:10:58 <xplat|work> even with the superclasses and methods that have been dropped, not all number types have become comfortably Num :(
13:11:09 <kadoban_> xplat|work: boooo
13:11:15 <absence> ReinH: doesn't the functor in the l-system cofree generalisation have to be a monad instead? if it's Maybe you potentially end up with multiple Maybe values (depending on the monad, usually list), but Cofree wants only one
13:11:36 <ReinH> absence: No, you're mixing levels up
13:11:46 <monochrom> an existential value is not going to be nice and ask you "how would you like your 0 today? Int or Double?"
13:12:00 <monochrom> that is the job of a universal, polymorphic value.
13:12:08 <ReinH> f gives a representation of "determinacy", so for Maybe each production rule either gives a production or does not.
13:12:13 <monochrom> how would you like your egg today?
13:12:18 <bollu> monochrom: an existential type would you pick any type it wants, right?
13:12:22 <xplat|work> hatched
13:12:23 <ReinH> m gives the notion of substitution that is used to execute the step
13:12:34 <ReinH> absence: e.g., m ~ [] gives the usual "each letter produces a word"
13:12:35 <absence> ReinH: m is usually [] right?
13:12:43 <ReinH> I don't know of any other useful choices of m yet.
13:12:55 <monochrom> no, an existential value says "I encapsulate some data of a type, but I am not telling you."
13:13:08 <ReinH> But the advantage of abstracting with m is that we are significantly restricted in the ways we can implement the step function.
13:13:18 <monochrom> it doesn't even let you choose anything
13:13:38 <xplat|work> you could have m ~ [], m ~ Maybe, m ~ Identity, m ~ Reader Bool, m ~ IO.  all these give useful Cofree
13:13:52 <ReinH> absence: I have the work I did for this on another machine, I think, but give me a moment to try to recreate some of it.
13:13:54 <mauke> an existential value says "I have chosen a type. Pray I don't choose any further"
13:14:15 <bollu> monochrom: any existential type would pick any type *it* wants ?
13:14:22 <absence> ReinH: so axiom becomes [a], and rule becomes a -> Maybe [a]. for each step, you map rule to axiom and get [Maybe [a]], so you have multiple Maybe values, but coiter wants Maybe (D0L ..)
13:14:32 <absence> ReinH: ok, great
13:14:38 <monochrom> the creator chooses, at the time of creation.
13:14:46 <monochrom> the user, you, are stuck
13:14:48 <ReinH> :t sequence
13:14:50 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:14:50 <xplat|work> polymorphic functions get stuck with existential arguments
13:15:13 <glittershark> monochrom: I think I'm getting this. what would a function that returns an existential type look like?
13:15:13 <monochrom> worse, you can't even ask what choice was made.
13:15:15 <notdan> Yeah you can think of existential as a union and a universal as an intersection.
13:15:28 <glittershark> I guess... all functions take existential types as arguments? am I right?
13:15:45 <glittershark> or at least the types of the arguments are existential in the context of the function
13:15:46 --- mode: ChanServ set +o mauke
13:15:46 --- mode: mauke set -b *!*@gateway/web/freenode/ip.108.7.239.13
13:15:51 <dedgrant> edwardk: Wonderful news on undecidable superclasses. Great documentation trail for those of us learning.
13:16:06 <ReinH> absence: you have to distribute the f's over the m's in a particular way
13:16:07 <bollu> monochrom: so how do you use them?
13:16:09 <monochrom> "f :: Int -> Showable"
13:16:28 <bollu> monochrom: that's legit Haskell?
13:16:30 <glittershark> monochrom: since lambdabot doesn't have :i, what's Showable?
13:16:36 <monochrom> it depends on the actual existential type. a useful one provides some operations you can use.
13:16:37 <glittershark> @src Showable
13:16:37 <lambdabot> Source not found. Take a stress pill and think things over.
13:16:54 <monochrom> Showable is the fabled "data Showable = forall a. Show a => a"
13:16:59 <glittershark> nevermind, I lmgtfy'd
13:17:12 <bollu> monochrom: "f :: Int -> Showable" is "correct haskell"?
13:17:15 <monochrom> err, "data Showable = forall a. Show a => MkShowabl a"
13:17:16 <glittershark> okay! I think I'm understanding this
13:17:26 <monochrom> it is a valid type sig
13:17:36 <monochrom> f n = MkShowable n
13:17:43 <glittershark> so for a function `:: a -> Showable`, I could return a concrete type, but the caller would only get to use it like a `Show a => a`?
13:17:46 --- mode: mauke set -o mauke
13:17:53 <monochrom> yes
13:17:55 <bollu> also, in the same context: f :: safeHead :: forall a . [a] -> Maybe a
13:17:56 <glittershark> aha!
13:18:05 <glittershark> monochrom: thank you! this all just clicked for me
13:18:06 <bollu> the forall is not necessary?
13:18:12 <absence> :t Control.Comonad.Cofree.coiter
13:18:13 <lambdabot> Functor f => (a -> f a) -> a -> Control.Comonad.Cofree.Cofree f a
13:18:19 <notdan> bollu: it is implicit otherwise
13:18:27 <bollu> notdan: right :) thanks
13:18:29 <glittershark> I'm bouncing up and down in my seat because *everything makes sense now*. so thanks monochrom 
13:18:29 <absence> ReinH: but coiter just wants one f per step?
13:18:34 <bollu> monochrom: hm, this is all falling into place :D
13:18:39 <monochrom> you're welcome
13:19:03 <monochrom> "caller chooses" vs "callee chooses" is informative. "any" is bland.
13:19:15 <monochrom> the point of contention has never been about "any"
13:19:46 <monochrom> "informative" means giving non-zero information in the sense of information theory
13:19:53 <mauke> f :: Int -> (forall a. Show a => a -> r) -> r
13:20:18 <glittershark> so from a practical standpoint... would it make sense to use existential types for the Principle of Least Access?
13:20:27 <jle`> :t [] :: [(forall a. Show a => a -> r) -> r]
13:20:28 <lambdabot>     Illegal polymorphic or qualified type: forall a. Show a => a -> r
13:20:28 <lambdabot>     Perhaps you intended to use ImpredicativeTypes
13:20:28 <lambdabot>     In an expression type signature:
13:20:30 <glittershark> as a sort of refactor-guard
13:20:30 <xplat|work> "informative" means "not guaranteed to be said"?
13:20:31 <monochrom> yes. but not the only way
13:20:54 <bollu> monochrom: in some sense, an interface is an exists, right?
13:21:10 <glittershark> the interface is the typeclasses that the existential type implements
13:21:34 <monochrom> you can also use a record of accessibles. you can also use a module that exports almost nothing. and finally you can combine all of them.
13:21:39 <xplat|work> or the operations that are packaged up with the existential type
13:21:55 <monochrom> an interface is going to be the type, not the value, yeah.
13:22:11 <rschnck> Can anyone explain why this example doesn't work? http://codepad.org/xcSM26HB I understand it has to do with the scope of the apple/orange variables, but it's unclear to me.
13:22:20 <xplat|work> (exists a. (a, a -> b))
13:22:41 <xplat|work> this is essentially the same as just 'b'
13:22:46 <glittershark> so basically, if I'm already returning concrete types from my functions, I could refactor them to return existential types and nothing would change given I use the right typeclasses, but it would free me up to change my types in the future
13:22:57 <xplat|work> (exists a. (a, a -> a, a -> b)) -- this isn't
13:22:59 <mauke> rschnck: variables in patterns never refer to existing variables. they always create new variables
13:23:02 <mauke> rschnck: (they're binders)
13:23:12 <xplat|work> (it's essentially the same as Nat -> b)
13:23:25 <bollu> I don't geddit, isn't the yoneda lemma very natural?
13:23:31 <xplat|work> (or in Haskell, i guess 'CoNat -> b')
13:23:37 <rschnck> mauke: Ah, understood. Thank you. :)
13:23:54 <bollu> (as in, you can go from a small category to some set, and the choice of the initial set object doesn't matter, they're all a natural transformation away)
13:24:00 <monochrom> I think "natural" is a bit subjective
13:24:11 <monochrom> oh, that kind of natural
13:24:36 <xplat|work> the yoneda lemma is indeed very natural in the CT sense
13:25:03 <bollu> hm, but it seems to have a lot of implications
13:25:07 <bollu> I shall sleep on this
13:25:16 <bollu> night for realsies, and thanks for all the lessons :)
13:48:01 <monochrom> strange! haskell weekly news is back!
13:48:12 <frerich> In tuples, do you guys put a space after a comma or not? I can never decide.
13:48:24 <frerich> #haskell - where the important questions are dealt with.
13:48:47 <monochrom> I put a space. Haskell's default Show instance doesn't.
13:49:01 <Crawldragon360> I tend to be pretty liberal with whitespace.
13:49:13 <Crawldragon360> I can never find the golden ratio that people want between not enough whitespace and way too much.
13:49:40 <tdammers> space after comma, always.
13:49:50 <monochrom> style guides are meant to be violated
13:50:07 <tdammers> what a chauvinist attitude
13:50:25 <ReinH> absence: The step function turns out to be pretty ugly, but conceptually you are just distributing f over m when applying rules, or was it vice versa
13:50:41 <Crawldragon360> Trust me, I've tried to follow style guides and more often than not they get in the way because they were designed for cases that don't apply to you.
13:51:46 <monochrom> ok, a more reasonable statement is: style guides are meant to take exceptions
13:51:48 <Cale> frerich: Whatever looks better in context.
13:52:13 <Cale> frerich: Sometimes I'll use multiple spaces in order to align the second components of a bunch of pairs vertically into a column.
13:52:13 <Crawldragon360> I've very rarely seen a context where no space after a comma looks easier to read.
13:52:28 <Crawldragon360> Especially since international standards make the distinction between a comma and a decimal point confusing.
13:52:29 <monochrom> for example, most often I write "(x, y)". but sometimes I write "(x,y) + (a,b)"
13:52:34 <Cale> yep
13:52:56 <Crawldragon360> Cale: Also this.  It's surprising how often this comes up.
13:53:00 <monochrom> but you may be able to talk me into writing "(x, y)  +  (a, b)"
13:53:12 <mauke> (x, y) +
13:53:13 <mauke> (a, b)
13:53:17 <Cale> heh
13:53:23 <Cale>   (x, y)
13:53:26 <Cale> + (a, b)
13:53:28 <Cale> lol
13:53:46 <mauke> (+) (x, y)
13:53:48 <mauke>     (a, b)
13:53:57 <Cale> But yeah, if I'm thinking of the pair as a vector like that, I'm more likely to get rid of the space
13:54:10 <Cale> (particularly, if the components are single variables)
13:54:25 <Cale> Or single letter variables, especially)
13:54:31 <Cale> (x,y) somehow looks better than (x, y)
13:54:43 <monochrom> but you won't be able to talk me into writing "let p1 = (x, y) \n p2 = (a, b) \n in p1 + p2"
13:54:44 <hsk3> Do most seasoned Haskell programmers use something like ghc-mod in their editor, or do they think syntax highlighting is more than enough?
13:54:53 <monochrom> there is a reason Fortran was a thing.
13:54:56 <Cale> But (here is something longer, followed by another part) looks better than without the space
13:55:18 <Cale> hsk3: Everyone is different
13:55:55 <Cale> hsk3: I don't tend to get much mileage out of the fancy editor features whenever I bother to try installing them, so I haven't had ghc-mod installed in a while
13:56:01 <mauke> seasoned haskell programmers don't write haskell
13:56:14 <Cale> hah
13:56:15 <frerich> For me, I seem to default to space-after-comma for record-like data for which I was too lazy to whip up a dedicated type, e.g. ("Frerich", "Raabe", "Hamburg"). In a "mathematical" context though (and this includes e.g. indexing into a Data.Array), I somehow find (a,b) or (row,col) or (41,33) more natural.
13:56:18 <hsk3> mauke: ?
13:56:27 <ReinH> absence: I am somewhat annoyed that what is conceptually simple has a rather ugly implementation, but perhaps I am missing a nicer implementation.
13:56:47 <mauke> hsk3: source: me
13:57:22 <monochrom> oh, but when you do define a record type, you will be asking "is it R{x=1, y=2} or is it R{ x = 1 , y = 2 }"? :)
13:57:29 <hsk3> Cale: haskell seems unique in this way. you can have a ghci on the side. can't really do that with loosely typed langs can you? kinda need a fancy UI to avoid common pitfalls
13:58:00 <mauke> monochrom: R {x = 1,y =2 }
13:58:14 <kadoban> hsk3: I don't think the type system really makes ghci unique. If anything ghci I find more awkward than other REPLs.
13:58:25 <mauke> hsk3: eh? I can write C in vi just fine
13:59:03 <monochrom> my only gripe with python's basic repl is that it does not have a real reload like ghci does
13:59:23 <glittershark> hsk3: I write ruby in vim everyday, don't have any trouble with it
13:59:38 <hsk3> hmm
13:59:44 <Cale> hsk3: I'm not completely sure why it is, but I dunno, being able to type :r and have the thing reload your source and tell you what's the matter is a good part of it
13:59:47 <hsk3> glittershark: and no autocompletion and stuff?
14:00:08 <mauke> I use boring ^P (complete previously seen identifiers)
14:00:13 <glittershark> hsk3: for ruby, autocompletion of words in my current buffer is usually enough
14:00:15 <glittershark> coupled with neocomplete
14:00:33 <Cale> Autocompletion is nice, but overused, it creates a culture of overly long identifiers which make the code difficult to read.
14:00:36 <kadoban> Yeah I use neocomplete in "just complete crap I've already typed" mode. Also neosnippet
14:00:46 <glittershark> hsk3: for haskell, alanz and cocreature and a couple more are working on https://github.com/haskell/haskell-ide-engine, which looks really promising to me
14:00:47 <mauke> what's neocomplete?
14:00:54 <glittershark> and I've started writing vim bindings to it, which is going well
14:00:56 <kadoban> A vim plugin for autocompletion.
14:01:05 <mauke> what does it do?
14:01:13 <monochrom> does neosnippet analogously mean "just snip crap I've already typed"? :)
14:01:19 <glittershark> pops up autocompletion as-you-type rather than you having to hit C-X C-O
14:01:25 <kadoban> monochrom: It probably should :)
14:01:29 <glittershark> monochrom: no, you define your own snippets usually
14:01:31 <MarcelineVQ> kadoban: atom has that, where it suggests things you've already written
14:01:34 <mauke> ... I've never used C-x C-o ever
14:01:39 <glittershark> vim snips things you've already typed automatically
14:01:47 <glittershark> mauke: c-x c-o calls 'omnifunc'
14:01:52 <glittershark> which can be overriden by ftplugins
14:01:54 <monochrom> oh, that kind of snippets. now I see. (I defined some in gedit.)
14:01:59 <hsk3> cool
14:02:10 <glittershark> https://github.com/eagletmt/neco-ghc is *spectacular*
14:02:37 <kadoban> I did use neco-ghc at some point, but I think in some move to 'stack' or whatever when it was new I didn't feel like figuring out how to get it to work anymore.
14:02:54 <glittershark> I also wrote https://github.com/glittershark/vim-hare last weekend, and have been using it to great success this week
14:04:23 <glittershark> \selfplug
14:05:07 <_m_ryan> hi anyone help me please what does this error mean? http://lpaste.net/148693
14:05:17 <monochrom> neat
14:05:32 <ReinH> absence: https://gist.github.com/reinh/9353595b9582d3d2197b
14:05:42 <frerich> I suppose using any vim plugin with 'neo' in the name requires setting your wallpaper to show some anime celebrities.
14:05:59 <mauke> frerich: also, neovim
14:06:09 <glittershark> most of the neo plugins are made by one guy
14:06:11 <glittershark> not Neovim, though
14:06:20 <frerich> I thought neo is the new smart.
14:06:22 <glittershark> https://github.com/Shougo
14:06:26 <glittershark> he *is* japanese, though
14:07:10 <absence> ReinH: ooh, traverse
14:07:11 <Crawldragon360> I would assume that people using neo would have Matrix backgrounds just for the ironic pun potential.
14:07:25 <xplat|work> no, neo is the One
14:07:26 <mauke> _m_ryan: where does your 'elem' come from?
14:07:36 <ReinH> absence: the step function is ugly, but relatively easy to mechanically derive from the types.
14:07:49 <ReinH> there is probably a nicer version but tbqh I stopped once I had a working one.
14:07:52 <Heffalump> is there a GHC 8 release candidate yet?
14:08:28 <bitemyapp> Heffalump: dun think so. Some uglies still need smushing.
14:08:34 <hunteriam> how can imfenerate a random long bytestring?
14:08:43 <hunteriam> i generate*
14:08:44 <glittershark> arbitrary?
14:08:46 <Clint> Arbitrary instance
14:08:46 <frerich> _m_ryan: I suppose your 'Import' import brings 'Element' and some 'elem' function which is related to that into scope, so you don't get the default 'elem'.
14:08:54 <glittershark> :t arbitrary
14:08:56 <lambdabot> Arbitrary a => Gen a
14:09:07 <mauke> hunteriam: read from /dev/urandom
14:09:21 <frerich> _m_ryan: You could try 'import Import hiding (elem)'
14:09:24 <ReinH> absence: the uses of traverse and join do the following to the type constructors m and f: m . f . m => f . m . m => f . m
14:09:24 <glittershark> that's a bit low-level for haskell isn't it? :P
14:09:43 <xplat|work> mauke: no, /dev/random.  /dev/urandom gives you a pseudorandom long bytestring.
14:09:43 <_m_ryan> trying
14:09:48 <mauke> xplat|work: wrong
14:10:11 <xplat|work> mauke: hm, do i have it backward?
14:10:38 <Clint> they're both probably pseudorandom
14:10:43 <xplat|work> no, i don't
14:10:44 <geekosaur> don't waste /dev/random on this
14:10:46 <ReinH> absence: does that make sense?
14:10:59 <ReinH> (traverse and fmap join, that is)
14:11:07 <_m_ryan> ferich: it says elem not is Scope
14:11:18 <monochrom> see http://www.2uo.de/myths-about-urandom/ . /dev/random is not fundamentally safer.
14:11:20 <geekosaur> a PRNG is good enough for this use; save /dev/random for crypto progs
14:11:51 <glittershark> hunteriam didn't say what they were using it for :)
14:11:53 <mauke> geekosaur: wrong
14:11:59 <csd_> Is it possible to create multiple instances of the same class within the same namespace? Haskell is complaining about multiple function declarations
14:12:01 <geekosaur> and may well be slower because it gets throttled if a system that checks entropy (e.g. many linux kernels) decides there isnt enough
14:12:03 <xplat|work>  /dev/random might be random, /dev/urandom definitely isn't (if you generate a long bytestring)
14:12:14 <_m_ryan> mauke: it it possible to use a library from github?
14:12:14 <mauke> xplat|work: wrong
14:12:16 <geekosaur> csd_, sounds like you are doing it wrong
14:12:25 <xplat|work> monochrom: i didn't say /dev/urandom was unsafe, i said it was not random.  which it isn't.
14:12:43 <monochrom> ok, /dev/random is not fundamentally more random, ok?
14:12:51 <frerich> _m_ryan: Usually that "elem" function you want comes in via the Prelude. Does it help if you do "import Prelude (elem)"?
14:13:01 <csd_> geekosaur: http://pastebin.com/ipqhv8fc
14:13:12 <Heffalump> bitemyapp: ok, thanks
14:13:18 <absence> ReinH: that's exactly what i was trying to do, but i didn't realise it was m that needed the Traversable constraint, i thought it was f :) i think it makes sense, i'll pick the step function apart and make sure i understand. thanks a lot!
14:13:33 <ReinH> absence: I found that out by trying to do it and having GHC complain about m.
14:13:38 <geekosaur> csd_, it has to be indented to be part of the instance
14:13:46 <csd_> oh, thanks
14:13:56 <ReinH> absence: but you're distributing f *over* m so m needs to be traversable.
14:13:57 <ReinH> :t traversable
14:13:58 <lambdabot>     Not in scope: â€˜traversableâ€™
14:13:59 <lambdabot>     Perhaps you meant one of these:
14:13:59 <lambdabot>       data constructor â€˜Traversalâ€™ (imported from Control.Lens),
14:14:04 <csd_> haskell's indentation pickiness always trips me up
14:14:04 <ReinH> :t traversable
14:14:06 <lambdabot>     Not in scope: â€˜traversableâ€™
14:14:06 <lambdabot>     Perhaps you meant one of these:
14:14:06 <lambdabot>       data constructor â€˜Traversalâ€™ (imported from Control.Lens),
14:14:06 <ReinH> sorry
14:14:18 <ReinH> what the hell? autocorrect gone awry? sorry everyone
14:14:30 <ReinH> Oh, no, I'm an idiot.
14:14:31 <ReinH> :t traverse
14:14:32 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:14:34 <haskell246> Are there issues with cabal install on OSX El Capitan? I can't seem to install anything, all packages are failing while trying to do something with dependencies.
14:14:35 * ReinH sighs
14:14:39 <ReinH> sorry for spamming
14:14:44 <bitemyapp> ReinH: happens to the best (and worst) of us :)
14:15:10 <Clint> ReinH: it was a nice change from the quibbling over random
14:15:30 <xplat|work> monochrom: well, aside from my flip first comment, i said that /dev/random *might* be actually random, while /dev/urandom certainly isn't if you use enough bits.  which *is* *true*, if perhaps not the most relevant fact for most people's actual uses.
14:15:34 <haskell246> cannot satisfy -package-id hashable-1.2.3.3
14:15:41 <ReinH> haskell246: I know that it works in general. Can you provide more info about your case? Error messages, relevant versions of things like ghc and gcc, etc.
14:15:59 <ReinH> haskell246: have you done a cabal update?
14:16:09 <_m_ryan> ferich: yes it help thanks, question is it possible to use a package from github?
14:16:13 <mauke> xplat|work: both /dev/random and /dev/urandom are fed by the same CSPRNG
14:16:22 <ReinH> Clint: :)
14:16:28 <haskell246> Yep, did cabal update. GHC version 7.10.2
14:16:49 <ReinH> absence: this is easier to see in
14:16:51 <ReinH> :t sequenceA
14:16:52 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
14:17:24 <frerich> _m_ryan: In principle, you could fetch the code from GitHub, build & install it and the use that, sure.
14:17:28 <ReinH> absence: the f needs to be "pulled through" the t
14:18:24 <haskell246> Tried to cabal install lens, for example, and here's a log from a failed dependency install:
14:18:26 <xplat|work> mauke: yes, but /dev/random may try to block if there is not enough entropy in the pool to produce an actually-random output (note that i don't claim it always succeeds, or even that all implementations ever succeed).  /dev/urandom will not do this, so if you keep pulling bits you will definitely not get random output.
14:18:39 <haskell246> http://pastebin.com/QstnPpnf
14:19:10 <mauke> xplat|work: you never get "actually random" output. it's a PRNG
14:19:16 <xplat|work> (although it will probably still be cryptographically secure for all or almost all purposes)
14:19:23 <zoku> nothing is truly random
14:19:36 <zoku> there are no sources of infinite entropy
14:20:00 <xplat|work> mauke: if you mix enough random bits into the state of a PRNG you will get an actually random output
14:20:04 <ReinH> This is quickly progressing into an out-pedantry competition.
14:20:35 <bitemyapp> ReinH: roll out the 14 inchers and load up the powder
14:20:39 <zoku> there's not much point to mixing sources xplat|work 
14:20:48 <zoku> the weaker one will just weaken the stronger one
14:21:06 <xplat|work> zoku: possibly, but if there is an infinite source of entropy only /dev/random will attempt to feed its infinite bits of entropy to you without low-entropy interruptions
14:21:10 <ReinH> Nothing is truly anything. I win. Now let's move on.
14:21:16 <bitemyapp> advice I'd seen from security experts was "just use urandom"
14:21:38 <frerich> monochrom: Don't you have some tautology which is applicable to this kind of discussion?
14:21:41 <zoku> what security experts?
14:21:51 <monochrom> ah, let me see...
14:21:56 <haskell246> ReinH: Here's a sample log, http://pastebin.com/bTWS461Q
14:21:59 <mauke> zoku: http://www.2uo.de/myths-about-urandom/
14:22:09 <xplat|work> zoku: if you xor two random sources you get a random source as strong as the stronger one, unless they are correlated
14:23:01 <monochrom> I don't think I have one or can think one up now :)
14:23:12 <haskell246> It seems like hashable is a dependency for semigroup, but shouldn't cabal then just recursively download the dependencies?
14:23:31 <xplat|work> my advice is 'if you think you need a random number, use /dev/urandom, if you actually need a random number, use /dev/random and pray'
14:24:07 <mauke> xplat|work: what is your advice based on?
14:24:26 <monochrom> ok, there is one remotely related: #1
14:24:41 <Clint> if you actually need a random number don't use either
14:24:41 <xplat|work> (praying won't help, but it might make you feel better)
14:24:55 <ReinH> Usually these discussions take some amount of time to become a pointless argument about the meanings of words, before which possibly something useful may be discussed. "Nothing is truly X" is taking a shortcut in a race to the bottom. :/
14:25:03 <frerich> monochrom: Random factoid: your page is the second Google hit if I search for 'albert tautologies'
14:25:14 <monochrom> haha
14:25:15 <frerich> monochrom: You're "made", in the Mafia sense.
14:25:41 <xplat|work> Clint: if you actually need a random number and are a trained cryptographer, cryptologist, and experimental physicist you might have a better strategy than 'use /dev/random and pray'
14:25:53 <ReinH> Such staements are usually followed by arguments about the meaning of "nothing" and "truly" and "is".
14:25:58 <_m_ryan> ferich: thank for the help
14:26:25 <monochrom> haskell weekly news is truly amazing
14:26:43 <EvanR> just rolled 6 on a d6. use 6 from now on
14:27:10 <absence> ReinH: yes, i see it now :)
14:27:37 <xplat|work> there are plenty of random strings of bits, in fact most strings of bits are random, the trick is getting one of those to actually occur in the real world
14:27:37 <EvanR> 6 is a truly random number
14:27:55 <ali_bush> im currently getting a "*** Exception: Parse exception: not enough input" when making an http request in which the server kills the socket.
14:27:58 <monochrom> oh, I should read puregreen's Lens over Tea
14:28:06 <EvanR> xplat|work: what, they are all random
14:28:07 <frerich> _m_ryan: Have fun!
14:28:19 <ali_bush> how do I tell what the actual exception type is too use in try?
14:28:27 <xplat|work> luckily almost everyone doesn't really need a random number
14:28:39 <ReinH> Obligatory https://xkcd.com/221/, which is itself a retelling of an old IBM joke.
14:28:43 <monochrom> ali_bush: my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml may help
14:29:03 <haskell246> This El Capitan permissions changes is just the worst
14:29:11 <ali_bush> monochrom: thanks will have a look.    im having a blast learning haskell :)
14:29:12 <EvanR> ReinH: yeah i refrained from just posting that since i have some dice here
14:29:14 <monochrom> actually jump to the end, if you're already familiar with the basics
14:29:43 <EvanR> haskell246: i think you can totally disable it from a boot menu
14:30:16 <acowley> I haven't actually had any trouble with the El Cap permissions thing, and I find that a tad disconcerting.
14:30:21 <EvanR> i did it to install an "untrusted" driver, but i quickly got fed up trying to cherry pick what to disable. i just disabled it all and put myself in "linux" mode
14:30:28 <bitemyapp> acowley: that stuff fucked a lot of people up
14:30:51 <acowley> bitemyapp: So I gather. But I don't know how I managed to find the blessed path through the chaos.
14:31:18 <EvanR> are all your apps and games approved by apple? ;)
14:31:35 <acowley> Apple doesn't seem to mind my /nix or my /usr/local
14:32:26 <bitemyapp> acowley: pretty sure I took the IDGAF way out on my rMBP, but I don't remember for sure.
14:32:44 <acowley> I hope this is the beginning of a pro-nix campaign on Apple's part. Swift 4.0 will actually be GHC, and they'll use nix for package management.
14:32:46 <monochrom> one of the quotes of the week could use a "pun not intended" :)
14:34:02 <_m_ryan> ferich: there is another error comes out, http://lpaste.net/148693
14:36:43 <monochrom> the mention of "IsString" means that you have incorrectly turned on OverloadedStrings. kill it.
14:37:05 * bitemyapp watches monochrom instruct them on the use of a flamethrower
14:39:02 <frerich> _m_ryan: Does it help if you change 'import Prelude (elem)' to just 'import Prelude'? For some reason, it appears that standard definitions are not found for you. The 'Import' module seems fishy to me.
14:39:27 <frerich> _m_ryan: Is this part of some exercise and the "Import" module was provided to you?
14:39:41 <glittershark> the Import module is created by the stack template for Yesod, iirc
14:39:52 <frerich> Maybe it's meant to serve as some sort of simplified Prelude.
14:39:55 <glittershark> it's like "user-prelude"
14:39:57 <frerich> glittershark: Ah, hm.
14:40:03 <glittershark> it's all the things you want everywhere that *aren't* in Prelude
14:40:13 <monochrom> frerich, I think the stand elem is found this time, but now the combination of Foldable and IsString is too much ambiguity for 'x' `elem` "abc"
14:40:17 <glittershark> always thought it was a kinda neat idea
14:41:02 <glittershark> frerich: just looked at the paste; this is a classy-prelude thing
14:41:12 <glittershark> looks like _m_ryan is using yesod, which includes classy-prelude by default
14:41:16 <glittershark> which I am also using in my project
14:41:23 <monochrom> because now a simple "abc" has the polymorphic type (Foldable ???, IsString ???) => ???
14:41:35 <_m_ryan> ferich: glittershark is right
14:41:44 <xplat|work> if only OverloadedStrings came with a corresponding extended defaulting
14:41:54 <xplat|work> i've gotten bit by that so many times :(
14:42:07 <glittershark> it always defaults to String for me?
14:42:19 <glittershark> ah
14:42:32 <xplat|work> if i turn it off i need 'T.pack' on half my literals, if i turn it on i need ':: String' on the other half
14:42:33 <glittershark> the problem is `elem` in classy-prelude isn't the same as Prelude's elem
14:42:34 <_m_ryan> glittershark: is there a way for you to use a library form github?
14:42:36 <monochrom> it defaults to String if you kill OverloadedStrings
14:42:51 <ReinH> acowley: I had to fix them back after they borked my homebrew setup, but that took a single chmod and 5 minutes of googling.
14:43:01 <glittershark> _m_ryan: that sounds like a separate question :)
14:43:03 <_m_ryan> ferich: i update http://lpaste.net/148693 include the import module
14:43:05 <xplat|work> if you kill OverloadedStrings it doesn't default to String, it just is a String
14:43:26 <acowley> ReinH: Oh, you know I may have done that, too! But I think brew itself told me to do it, so it really wasn't any trouble at all.
14:43:35 <glittershark> I personally use OverloadedStrings on all my projects. classy-prelude too
14:43:42 <_m_ryan> glittershark: yes the code was not mine totally i just copy it on github cause it was not updated yet on hackage.
14:43:44 <ReinH> acowley: indeed
14:44:28 <glittershark> ah
14:44:42 <glittershark> _m_ryan: typecast the `"-_.~"` to a String
14:44:49 <glittershark> ("-_.~" :: String)
14:45:00 <glittershark> should fix it?
14:45:04 <xplat|work> the really annoying things about Data.Map and Data.Text and stuff in general is haskell doesn't let you abstract qualified imports
14:45:21 <glittershark> that's what classy-prelude is for imo
14:45:28 <glittershark> typeclasses for all the stuff that people normally import qualified
14:45:38 <monochrom> what is "abstract qualified imports"?
14:45:49 <xplat|work> like if you have a prelude of unqualified imports for your project, you can reexport everything from one module
14:46:20 <acowley> But we don't have good syntax for nailing down a particular implementation. Instead, we usually rely on one explicit type to knock down all the questions via inference.
14:46:33 <xplat|work> but if you want to have a qualified import like 'import qualified Data.Text as T' in all your files, you just have to copy-paste it, there's no way around it
14:46:40 <glittershark> oh yeah
14:46:50 <glittershark> re-exporting qualified imports
14:47:00 <monochrom> I see
14:47:20 <glittershark> that *would* be quite nice to have
14:47:27 <glittershark> but potentially confusing for readers of the code
14:47:39 <glittershark> I already get enough "where does this function come from" questions from my coworkers as it is
14:47:39 <acowley> I really want to get back to that work on GHC. I want to write module (Sig1 A, Sig2 B) => Foo[A,B] where ...
14:47:50 <xplat|work> no more so than reexporting unqualified identifiers
14:48:01 <glittershark> true, xplat|work 
14:48:31 <mgsloan> That would indeed be convenient, but it does come at a cost.  Now you can write "A.foo" without explicitly introducing the qualification A.
14:49:07 <xplat|work> now, if you did 'import qualified Data.Text as Control.Lens' and reexported that, or even *didn't* reexport it, that *would* be confusing
14:49:08 <mgsloan> Maybe the way to do this would be to force an explicit import like "import Foo (qual M, qual HMS, qual LBS)"
14:49:26 <mgsloan> But then much of the convenience seems to be gone
14:50:07 <frerich> _m_ryan: Sorry, I think monochrom did a better job at reading the error message you got than me, I believe changing the 'import Prelude' part as I suggested doesn't help much. It's rather that due to a language extension (called "OverloadedStrings"), the string "-_.~" may have different types and that's making things ambiguous.
14:50:20 <xplat|work> mgsloan: i think the best thing is to 'import MyProject.Prelude' and then import everything you use anywhere *explicitly* in that prelude, even if it's qualified
14:50:29 <ali_bush> monochrom: thanks that helped alot.
14:50:31 <xplat|work> so you have to indirect, but only once, ever
14:51:34 <glittershark> so much of that is fixed by having typeclasses for everything rather than having to qualify all your imports
14:51:44 <_m_ryan> ferich: thanks for the help though :)
14:51:46 <glittershark> not to sound like a broken record, but I really like classy-prelude :)
14:51:54 <xplat|work> ... except the part where it can be ambiguous
14:51:59 <_m_ryan> glittershark: thanks for the help :)
14:52:06 <glittershark> _m_ryan: sure!
14:52:16 <glittershark> in my expericnce it rarely is ambiguous
14:52:24 <mgsloan> classy-prelude utilities like "asList", "asMap", etc, are pretty nice for handling ambiguity
14:52:26 <frerich> _m_ryan: To test this theory, you could try changing ""-_.~"' to '("-_.~" :: String)', i.e. enforce that it's treated as a plain String.
14:52:32 <glittershark> things almost always boil down to concrete types eventually
14:52:51 <glittershark> yeah, plus the concretely-typed aliases to `id`
14:53:09 <mgsloan> GHC 8.2 's explicit type applications should allow more concise resolution of ambiguity
14:53:24 <_m_ryan> ferich: yes that what glittershark suggest :) thanks again
14:53:27 <xplat|work> with stuff like 'OverloadedStrings' it's easy to end up with the case of feeding a polymorphic literal to a polymorphic function which never ends well
14:54:27 <glittershark> that's maybe 5% of the time, in my experience
14:54:31 <xplat|work> like, tagsoup's '~==' on string literals is really convenient until you turn on OverloadedStrings to make something else convenient
14:54:41 <xplat|work> and then boom
14:54:50 <monochrom> glittershark: to be fair, this code was not ambiguous just a few months ago, when Prelude.elem was nailed to [] back then
14:55:02 <glittershark> yes, this is an example of that 5%
14:55:18 <glittershark> I think classy-prelude et al are good as opt-in things
14:55:24 <glittershark> I'm against Foldable being in base prelude
14:55:33 <xplat|work> '~== ("<foo>" :: String)' is *still* shorter than the next shortest thing, but it's annoying
14:56:59 <monochrom> explicit type application is scary and awesome at the same time
14:57:01 <xplat|work> (the more serious issue with tagsoup is it only implements an html5 tokenizer, which is a device that was only ever meant to be used alongside an html5 treebuilder, which afaict hasn't been implemented in haskell at all?)
14:57:26 <monochrom> the slippery slope I'm seeing is that we're riding closer and closer to writing Core directly
14:57:36 <glittershark> I'd be okay with that
14:57:48 <glittershark> \sarcasm
14:57:51 <monochrom> haha
14:58:22 <monochrom> {-# LANGUAGE SystemF #-}
14:58:30 <glittershark> beautiful.
14:59:14 <xplat|work> the weird thing that i'm seeing is that somehow arguments that are requested explicitly and provided implicitly seem much easier to reason about than arguments that are requested implicitly and provided explicitly
15:00:04 <acowley> It's sort of strange that we can't write Core directly already.
15:00:40 <xplat|work> it's not that strange considering that Core doesn't have an official input syntax
15:01:12 <acowley> Okay, so it's strange that Core doesn't have an official input syntax.
15:01:17 <monochrom> :)
15:03:04 <hpc> core could be that coveted AST language
15:03:14 <hpc> that everyone wants to divorce coding from text editing
15:03:27 <hpc> build your programs with gdb and resume ghc to build a program
15:12:20 <monochrom> Lens over Tea is really long. this is Lens over A Feast Spanning 5 Days
15:12:37 <ReinH> Or "Lens Over Teas"
15:12:48 <ReinH> Speaking of which, I should drink some tea.
15:13:05 <monochrom> and each day the fabled Italian dinner which lasts 3 hours and 10 courses or something
15:14:20 <monochrom> unless you're like the minster of education of Hong Kong. he claims he reads 30 books every month
15:17:11 <fnord__> hi, I'm having trouble with ghc-mod in haskell-mode (spacemacs layer) on NixOS. When I open a .hs file from a stack-project, I repeatedly get the error: "ghc-mod: <command line>: cannot satisfy -package-id base-4.8.1.0".
15:17:32 <fnord__> otherwise haskellmode including the interactive shell works fine. any ideas?
15:20:05 <monochrom> I am phobic to paper cuts, too. they're really annoying.
15:20:22 <kaiyin> how do you prove that m >>= fÂ always equalsÂ join (fmap f m) for any monad m?
15:21:16 <monochrom> I think it's by definition
15:21:30 <monochrom> I mean mathematical definition, not writing code
15:21:50 <zachk> you can't absolutely prove that condition in haskell itself 
15:22:11 <johnw> kaiyin: I think proving that in general, without reference to any definition of >>= and join/fmap in particular, would have to rely on parametricity
15:22:26 <kaiyin> ok
15:22:38 <hpc> proving it in general is definitional
15:22:45 <johnw> because if all you have is join, fmap and return, then there is only one way to define >>= (up to isomorphism)
15:24:48 <ReinH> It is tautological in the following sense: Given (>>=) and return, the correct implementations for join and fmap must satisfy the laws, and any implementation that satisfies the laws must be correct.
15:26:38 <ReinH> If you have some function that does not satisfy the laws, it is not join, and vice versa.
15:26:50 <johnw> kaiyin: it also depends on your definition of "equals".  join (join (fmap (fmap f) (return m))) would also be a valid definition of >>=
15:26:58 <deech> The GHC 7.10.3 download page is missing a link to the Sources. Who do I notify? I've posted to haskell-cafe yesterday but no one seems to have responded.
15:27:10 <johnw> that's why I mentioned up to isomorphism
15:29:52 <verement> kaiyin: I once wrote a proof: https://github.com/verement/etamoo/commit/37f46f035070bcf798ad5cc79770f3c81ca3e26d
15:30:34 <verement> not sure how well I did, but it convinced me
15:33:09 <kaiyin> verement: very nice!
15:37:26 <ReinH> (Whether it's tautological depends on whether you take it as one of your laws, really.)
15:41:25 <eitanChatav> How come I've never seen tutorials or anything on `haskeline`? That is an awesome library!
15:43:58 <frerich> eitanChatav: It's one of those libraries I always wanted to have a use case for (together with the brick package) but alas, never had a chance. :-(
15:44:31 <frerich> A bit like the sendfile system call on Linux.
15:45:28 <zachk> it's not too hard to use haskeline, I have wondered how to use it over network sockets though :-/ 
15:45:51 <zachk> the history access and handling of arrow keys is nice enough on it's on to use the library 
15:46:23 <eitanChatav> history and tab-completion are awesome
15:50:00 <papna_> At my company, we give an old ACM International Collegiate Programming Contest as a 2 hour programming practical for applicants.
15:50:03 <papna_> We tell them to use the language, etc. of their choice. (Occasionally this leads to languages we aren't familiar with at all.)
15:50:11 <zachk> never did much with the tab completion in haskeline 
15:50:14 <papna_> This isn't going where you might think--most of us actually know Haskell and can read the applicant's code fine.
15:50:17 <papna_> He didn't get that far, and most of us suspect this is in no small part because it tends to be slower to develop Haskell code than the most common languages chosen for the thing (e.g. Python.)
15:50:28 <papna_> Many Haskell fans seem to dispute this speed difference (included among them our applicant!), especially given the parsing that it needs to deal with, but most of us tend to think that you'd expect Haskell to slow people down considerably
15:50:32 <papna_> I was curious if anyone was interested in solving it with a 2 hour time limit to prove us wrong. :)
15:50:42 <zachk> papna_ like which ones? 
15:50:49 <zachk> which languages haven't you guys seen
15:51:20 <zachk> my dev speed in haskell does seem to slow down a bit, but I usually don't need to throw the whole program away and start over as the project grows 
15:51:23 <papna_> zachk: Python, Java, Ruby, Javascript, C, C++, Lisp
15:51:52 <papna_> zachk: I don't expect Haskell to be slower than most of that list ;)
15:52:07 <zachk> to execute or to code productively in? 
15:52:14 <papna_> zachk: To develop
15:52:31 <mauke> parsing is generally annoying
15:53:20 <zachk> I'm using a version of break that drops the character it breaks on, words, and my own little pattern matching library that uses $vars atm 
15:53:22 <papna_> The parsing part isn't so hard, though it is ugly. (I don't disagree with this applicant's idea that it would be less ugly in Haskell, though I do suspect even that part isn't faster to develop.)
15:54:05 <kaiyin> could anyone explain this piece of code a bit? i am totally lost. https://gist.github.com/kindlychung/a75ce0d11b29010c6aeb
15:54:14 <kadoban> papna_: I thought you were saying that you for some reason expect haskell to be slower to develop in than other languages, and then you say you don't expect it to be slower to develop in than that list above? I seem to be missing something.
15:54:17 <mauke> a priori I'd probably choose perl or javascript for parsing
15:54:45 <papna_> kadoban: Slower compared to a language like Python for problems like the one given to applicants, not slower than C to develop for them.
15:55:38 <zachk> haskell code is usually easier to modify/maintain, add new features, the compiler catches so much 
15:56:00 <mauke> perl code is usually easier to modify/maintain because it comes with a test suite :-)
15:56:35 <papna_> Add Perl to the above list (I think the only time I didn't know how to read the applicant's code or figure out what it did, somewhat proudly.)
15:56:46 <kadoban> I see. Given that I've never run experiments and I don't really time myself coding, I'd expect it to take similar amounts of time to dev something in python vs. haskell. Maybe a bit less in python if it's stuff like programming competition problems, just because you can be sloppier in python and as long as it runs correctly once, it's usually called good enough.
15:57:12 <mauke> you're proud of your ignorance?
15:57:43 <papna_> mauke: Dear lord, yes.
15:57:55 <mauke> ugh
15:58:11 <papna_> kadoban: You could try timing yourself to figure out your speed versus lots of people, unless you're chicken, of course. ;p
15:58:50 <kadoban> papna_: It wouldn't really prove anything at all. The people who do competition problems quickly â€¦ it's a different skill than normal coding. I have other hobbies instead of those.
15:58:54 <mauke> I'm somewhat intrigued but I'd choose my language only after reading the problem
15:59:37 <mauke> (and if it takes hours I'll probably give up halfway through)
15:59:58 <zachk> code everything as ms batch files
16:00:19 <mauke> not very familiar with those
16:00:32 <mauke> I don't think there's good documentation for cmd.exe
16:00:40 <papna_> mauke: PM me if you want. I'd be interested in your take, if you're interested. If you'd be so kind to send me what you have at minimum(two_hours, when_you_quit), that would be really cool to see no matter your choice, doubly so if your choice was Haskell
16:06:34 <bramantio> hello all greetings
16:14:31 <bramantio> hello all
16:14:51 <chreekat> bramantio: hi. :) 
16:19:19 <bramantio> subleq: hi
16:19:49 <subleq> hello
16:20:09 <bramantio> how do you do?
16:20:45 <subleq> I have a simple function that I'd like to make safer. I can't figure out how to implement it without partial functions: http://lpaste.net/148700
16:22:22 <subleq> loop relies on an invariant on its input that can't be guaranteed
16:24:04 <bramantio> what sense of these brackets? : loop [] _ _ = []
16:26:59 <chreekat> a "[]" is a list value that has no elements. So that says "if the first argument to  is an empty list, then return an empty list"
16:27:17 <chreekat> *to loop
16:28:33 <jle`> subleq: if you have a partial function that you can't refine the input tpye with, you can always return `Maybe`
16:29:10 <subleq> jle`: yes, but that just moves the error around in this case. The function is private and is only called when the invariant is true
16:30:02 <subleq> A pattern match here indicates programmer error
16:30:08 <subleq> *pattern match failure
16:30:20 <subleq> I want to make programmer error harder
16:31:25 <chreekat> subleq: Yeah, I see your dilemma. The solution would be to change the construction of intermediate objects. You create an intparts and wordparts with implicit dependencies on parts; it is those dependencies that "loop" doesn't know about
16:32:24 <subleq> But how do you make those dependencies explicit?
16:32:35 <chreekat> change the structure of the data
16:32:52 <chreekat> requires creativity. It's the fun part :)
16:32:54 <subleq> well yes
16:33:06 <subleq> i'm asking this question because i've thought about it and can't figure out how
16:33:39 <subleq> i was thinking of using lists of data ListElement = NumberWord Integer | WordWord String, but then how do you do the sorting?
16:36:56 <chreekat> Ah, I thought of something.. my hunch was to use a product type instead of a sum type, and then augment the components with a sentinel value...
16:37:23 <EvanR> sum are cooler
16:40:00 <subleq> Are you saying something like [(Maybe Integer, Maybe String)]?
16:40:37 <chreekat> subleq: try to get to a final line "zipWith recombineParts sortedWords sortedInts"
16:41:00 <subleq> chreekat: zipWith has the same problem :/
16:41:28 <subleq> you get the same result as just putting [] for the missing pattern matches in loop
16:41:55 <chreekat> It could wreck your data, but it wouldn't be impartial
16:42:12 <chreekat> :)
16:42:25 <chreekat> you'd need a different shap for sortedWords and sortedInts
16:42:30 <chreekat> and yeah, maybe there's a way that doesn't need zip
16:43:32 <chreekat> like, can you add enough stuff to the elemetns of the original list to summarize the function as "removeContext . sort . addContext" ?
16:45:12 <subleq> it would implicitly hide the programmer error and corrupt your data
16:45:16 <subleq> that's even worse...
16:48:50 <lynnard> Is there a way to combine several class constraint into one i.e., a ClassC that is only satisfied if ClassA and ClassB satisfy
16:49:21 <shachaf> You can combine constraints in that way, but not classes.
16:49:30 <shachaf> ClassC wouldn't be a class.
16:49:34 <lynnard> if I define a new empty class for this purpose then I have to write an instance with the exact same thing
16:50:08 <jle`> you can write type IsAAndB t = (ClassA t, ClassB t)
16:50:09 <lynnard> class A a, B a => C a where   | instance A a, B a => C a where
16:50:23 <jle`> and then foo :: (IsAAndB t) => blah blah
16:50:32 <lynnard> hah! will give that a try! exactly what I wanted
16:50:48 <jle`> you'll need -XConstraintKinds
16:51:30 <koz_> Can any Haskell graph library check for graph embeddability?
16:51:49 * hackagebot Slides 0.1.0.7 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.7 (darwin226)
16:53:12 <chreekat> subleq: what?
16:53:14 <Kaidelong> is there any particular reason why Oleg chose data Lan f a where { Lan :: f x -> (x -> a) -> Lan f a } as opposed to data Lan = forall x. Lan (f x) (x -> a) ?
16:53:28 <chreekat> "implicitly hide the programmer error and corrupt your data"
16:53:31 <Kaidelong> this seems needlessly obfuscating
16:54:15 <Kaidelong> are they not the same?
16:54:33 <chreekat> subleq: But that's like saying any function other than "id" is too untrustworthy :)
16:55:49 <jle`> Kaidelong: it's GADT symtax; some people find it easier to read :)
16:56:22 <Kaidelong> well my experience was that I was trying to figure out how to lift an algebra for a data structure to the algebra for its left Kan extension
16:56:27 <jle`> if you're comfortable with GADT syntax, it it's pretty straight forward
16:56:37 <Kaidelong> the GADT syntax didn't make it clear that it was a product that could be pattern matched on
16:56:45 <Kaidelong> to extract the original f x and (x -> a)
16:56:45 <jle`> hm
16:56:55 <jle`> if you've worked with GADT syntax, then it's sort of clear
16:56:58 <shachaf> The syntax only makes it clear if you know the syntax.
16:57:04 <shachaf> But that's true of the other syntax too.
16:57:11 <Kaidelong> GADT syntax is the same as the syntax for function types
16:57:19 <Kaidelong> but you can't pattern match on functions to run them in reverse
16:57:22 <shachaf> Is that Lan as in Left Kan extension? I've usually seen this type called Coyoneda.
16:57:38 <jle`> if you're familiar with GADT syntax, then it's clear what the intent is and the pattern matcheability
16:57:40 <Kaidelong> that's what Oleg called it in his explanation of the Freer monad
16:57:55 <shachaf> Yes, the special thing about constructors is that you can match on them. The fact that it's defined in a data declaration tells you that it's a constructor.
16:58:08 <Kaidelong> I guess that does clear up the ambiguity
17:00:13 <Kaidelong> I suppose it's the same tradeoff in natural languages where features that allow quick reading and speaking also make the language more complex and harder to learn
17:00:58 <Kaidelong> maybe people learning Haskell would prefer the GADT syntax because of its consistency
17:01:49 * hackagebot telegram-api 0.2.0.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.2.0.0 (klappvisor)
18:09:02 <circ-user-4vA1C> help join
18:09:58 <ReinH> Cale: ping
18:10:16 <Cale> hi
18:11:25 <ReinH> Cale: Do you happen to know a good way to do peephole optimization style rewrites on a list(-like) structure of instructions? e.g., in brainfuck an example would be to replace any occurrences of "><" or "+-" with ""
18:12:00 <ReinH> I think this can actually be implemented using a context-aware L-System, but I don't know an efficient way to implement a context-aware L-System
18:12:24 <Jinxit> isn't that basically substring search?
18:12:33 <Cale> I don't know any way which is not the entirely obvious recursive traversal and substitution
18:12:41 <ReinH> Right.
18:13:19 <ReinH> Jinxit: but ofc this applies to things that are not strings as well
18:14:22 <ReinH> Then again, for substring search on a large corpus, an fm-index could be employed.
18:14:44 <zachk> fm-index?
18:14:59 <ReinH> @google fm-index
18:15:00 <lambdabot> https://en.wikipedia.org/wiki/FM-index
18:15:58 <mac10688> Is there documentation for how to create a custom stack template?
18:16:32 <ReinH> mac10688: Look at the existing templates. It should be pretty obvious from their layout. It's a single file with templates demarcated in a certain way.
18:16:57 <ReinH> and interpolation done in a pretty obvious way
18:17:29 <ReinH> @google stack-templates
18:17:30 <lambdabot> https://github.com/commercialhaskell/stack-templates
18:17:42 <mac10688> yeah I've been there
18:17:54 <mac10688> it's instructions about where to save it
18:18:01 <ReinH> Anywhere you want.
18:18:20 <ReinH> locally on the file system or somewhere you can curl (a gist)
18:18:22 <mauke> +>+<->-<
18:18:46 <mac10688> and I guess the last question I would have is how to register my stack template with stack?
18:18:48 <ReinH> mauke: BF optimizing compilers get pretty serious
18:19:07 <ReinH> mac10688: You don't. Just pass a file location or a url instead of the template name.
18:19:14 <mauke> ReinH: I've yet to see one I'd actually consider optimizing
18:19:18 <mac10688> ah ok, thanks ReinH 
18:19:32 <ReinH> mac10688: stack new â€“help explains this
18:20:01 <ReinH> well, I'm not sure if it talks about urls, that's a recent addition that I requested and they were nice enough to implement.
18:20:27 <ReinH> er, stack new --help
18:20:36 <mac10688> it is an excellent feature. The filesystem will be good enough for me. I think I have enough to make my template tonight and test it
18:20:37 <mgsloan> It would be kinda nice to have a local folder of templates
18:20:42 <lynnard> Is there a way to 'view' a value from a function using Lens?
18:21:05 <ReinH> lynnard: can you give an example, preferably using types?
18:21:29 <ReinH> mgsloan: to avoid having to specify the path?
18:21:41 <lynnard> view (someLens arg) myfunc = myfunc arg
18:21:52 <ReinH> I think you want ``to''
18:22:02 <ReinH> > 1 ^. to succ
18:22:04 <lambdabot>  2
18:22:14 <emmanuel_erc> Hello there! When GHC does garbage collection on CAFs, is it "intelligent" enough to how a specific CAF is used and changes how it is used in the fina compiled code (I hope that makes sense)?
18:22:14 <mgsloan> ReinH: Yup, to have the same level of convenience of the repo templates
18:22:36 <ReinH> mgsloan: yeah, e.g., ~/.stack/templates
18:22:59 <ReinH> @google ghc garbage collection CAF
18:23:01 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/CAFs
18:23:06 <ReinH> emmanuel_erc: ^
18:23:11 <mgsloan> Yes, and I think the normal templates repo should get cloned as well https://github.com/commercialhaskell/stack/issues/1595
18:23:29 <lynnard> ReinH: I think you misunderstood what I wanted; not converting a function to a lens, but using a lens on a function
18:23:32 <ReinH> mgsloan: seems good
18:23:51 <ReinH> lynnard: ah. Why do you want that?
18:24:04 <Jinxit> lynnard: there's the -s functions, views, uses, etc
18:24:20 <Jinxit> they let you apply a function to what you're taking out
18:24:38 <lynnard> imagine I have a structure A { _myfunc :: a -> b } ; I'd do    view (myfunc . someLens arg) a@(A ...) => (_myfunc a) arg
18:25:31 <lynnard> I was doubtful about whether this can be done - after all, a function is not a traversable right?
18:25:43 <ReinH> But it is a Functor.
18:26:25 <lynnard> I thought the requirement for a type of data to be used with lens is a Traversable..?
18:26:57 <ReinH> traversals require Traversable
18:27:02 <ReinH> lenses just require Functor
18:27:05 <ReinH> :t lens
18:27:06 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
18:27:12 <lynnard> Right, I see
18:27:34 <mauke> .oO( arg & view (myfunc . someLens) a )
18:28:20 <ReinH> > view _1 (succ, pred) $ 1
18:28:20 <Lokathor> in MonadState, it has a "| m -> s" part in the typeclass definition
18:28:22 <lambdabot>      Could not deduce (Enum a0) arising from a use of â€˜predâ€™
18:28:22 <lambdabot>      from the context (Enum a, Num a)
18:28:22 <lambdabot>        bound by the inferred type of it :: (Enum a, Num a) => a
18:28:33 <lynnard> mauke: mhh, hehe yes that works but was expecting something more inline with the syntax
18:28:39 <Lokathor> i know that it means "for each m, there's exactly one s", i think, but what's that part called?
18:28:55 <ReinH>  > view _1 (succ, 2) $ 1
18:28:58 <emmanuel_erc> thanks ReinH
18:29:06 <ReinH> emmanuel_erc: yw
18:29:31 <ReinH> lambdabot has had enough of my requests, I guess.
18:29:58 <lynnard> hahah.. okay I think as you have demonstrated what I wanted is not needed really
18:30:05 <emmanuel_erc> What are you guys talking about? I can't always follow everything.
18:30:23 <mauke> Lokathor: functional dependency
18:30:24 <Lokathor> ReinH, your line started with a space
18:31:11 <ReinH> Huh, doesn't look like it to me. *shrug*
18:31:31 <Lokathor> > view _1 (succ, 2) $ 1
18:31:33 <lambdabot>  2
18:37:34 <dino-> I am relying on a package on hackage but I need a more recent version than is on hackage (I am currently getting from github because of this). But it would make my life easier if I could get the maintainer to update it..
18:38:00 <dino-> The maintainer on hackage for this is not the author in the cabal file. I don't understand how to get contact info for a person maintaining something on Hackage from the site.
18:38:48 <dino-> Does anyone know how I can get this info from the Hackage site?
18:38:54 <dino-> Maybe I missed something obvious
18:39:56 <sm> usually it's on the hackage page. If not, they're almost certainly active in the github repo
18:40:10 <ReinH> dino-: it's up to package authors to provide contact info. Check for a repository as well and try to find its owner, etc.
18:40:27 <dino-> sm, it's not the same person who owns the github upstream source.
18:41:01 <sm> dino-: perhaps point out the package and we can give more specific advice
18:41:13 <dino-> This package was put on Hackage by somebody who isn't the author, is what I'm saying. ok: https://hackage.haskell.org/package/aeson-bson
18:41:40 <dino-> Actually, is Alfredo DiNapoli here by any chance?
18:41:58 <sm> uploaded by AlfredoDiNapoli, who owns the repo. That's probably the actual maintainer in such cases
18:42:23 <dino-> sm: But there is no email for this person. The email addresses in the cabal file are two other people.
18:42:34 <ReinH> There is a github repo.
18:42:42 <sm> I understand, but github...
18:42:43 <ReinH> Github repos generally have an issues system you can use.
18:43:00 <dino-> Ok, I can find out if the people on github know anything about Hackage.
18:43:10 <sm> https://github.com/adinapoli
18:43:28 <ReinH> dino-: judging by the names, the repo is owned by the uploader
18:43:48 <ReinH> sm: "I want to contact someone, but only if I am not slightly annoyed while doing so"?
18:43:52 <dino-> Oh, I was confused, that this belonged (on github) to Niklas Hambuechen or Andras Slemmer
18:44:12 <ReinH> dino-: I don't know who it belongs to, but I know who uploaded it most recently and who owns its github repo
18:44:17 <ReinH> and those people are the same person
18:44:24 <sm> email them all! slackers.
18:44:45 <dino-> I didn't put those names together, there are actually a pile of forks of this thing.
18:44:55 <sm> demand action. That's the way to talk to these maintainers
18:45:05 <dino-> Thanks guys, sorry for the confusion.
18:45:08 <sm> :)
18:45:29 <ReinH> If you look at the repo owner's page, it has his name, which is the same name.
18:45:44 <ReinH> I realize that I am exercising Sherlock-level deductive powers here
18:46:04 <dino-> heh, I was fixated on those other names, the source code authors.
18:46:59 <ReinH> dino-: :)
18:48:37 <dino-> This one is a little more confusing, the adinapoli one isn't actually the same fork I was able to successfully build.
18:48:45 <dino-> But it's the only person who put it on hackage.
18:48:46 <ReinH> the plot thickens
18:48:59 <ReinH> much like soup
18:49:08 <ReinH> (which also thickens, you see)
18:49:30 <dino-> And that's not the one he forked (that I can use). This project is messy.
18:49:40 <dino-> In any case, I need to email these people.
18:54:43 <codedmart> I would like to try and write some haskell for a project I am working on. The api I have to deal with only has a python lib. Can I call python code from haskell?
18:54:48 <codedmart> Reliably
18:55:55 <ReinH> What sort of API is it?
18:57:50 <codedmart> ReinH "A python based api for accessing Shotgun..." https://github.com/shotgunsoftware/python-api
19:08:39 <ReinH> codedmart: it talks to a JSON API?
19:09:50 <ReinH> codedmart: Just write a client in Haskell. There's no FFI for Python.
19:10:17 <codedmart> ReinH Yeah, but I am not sure I will have enough time to port it over. But I guess if I want to use haskell the is the right approach.
19:11:08 <ReinH> Well, I'm sure you'll make more progress with the option that isn't impossible.
19:11:26 <codedmart> ReinH you are right. Thanks for looking!
19:12:11 <ReinH> Writing Haskell clients is fun. Try wreq or servant-client.
19:12:30 <mgsloan> Well, you could use an approach like this https://github.com/nh2/call-haskell-from-anything
19:12:43 <ReinH> wreq is especially easy to use imo. Both have excellent JSON support via aeson.
19:12:43 <codedmart> ReinH Yeah I like servant alot
19:12:53 <ReinH> mgsloan: The goal is to call python from Haskell though
19:12:56 <mgsloan> (dunno how easily it is to go from "call haskell from anything" to "call anything from haskell", but should be similar)
19:12:59 <mgsloan> yeah
19:13:43 <mgsloan> Certainly true that if it's a simple JSON API, probably easier just to use it rather than re-wrapping the python API in a new protocol
19:13:46 <ReinH> mgsloan: so now it isn't impossible, merely http://xkcd.com/1425/
19:15:15 <mgsloan> Unless something already exists for it ;) https://github.com/Russell91/pyfi
19:15:23 <mgsloan> Who knows how good it is, but it exists
19:15:59 <ReinH> Huh. Now I will have to resort to all the other good reasons I have for writing an API client in Haskell i nstead.
19:16:05 <ReinH> *instead
19:16:33 <ReinH> mgsloan: ;)
19:23:03 <jonathanfrias> Can I do something like: [x y | x <- [1..10], y <- [1..10], x < 10] in haskell?
19:23:19 <jonathanfrias> where I have 2 variables before the PIPE?
19:23:28 <sm> (x,y)
19:23:38 <ReinH> jonathanfrias: yes, but you can't apply x to y
19:23:58 <geekosaur> "x y" would mean the same thing it does in any other Haskell expression, so would try to use x as a function
19:24:23 <jonathanfrias> oh yes. that makes much sense thanks!
19:50:46 <pilne> #haskell-beginners
19:50:52 <pilne> oops
20:03:46 <CyberNine> hello guys
20:04:42 <CyberNine> so no one is active rn?
20:05:15 <Mirry> Hello CyberNine
20:05:39 <CyberNine> whats going on Mirry
20:05:59 <Mirry> not much, watching homeland. you ?
20:06:09 <bramantio> hello all
20:06:12 <CyberNine> teaching my husband on barnaby jack
20:06:33 <CyberNine> god i miss that guy
20:07:15 <Mirry> That's the guy who hacked ATM's on stage during a bh conference, right?
20:07:18 <bitemyapp> CyberNine: what's Barnaby Jack?
20:07:22 <Mirry> who's*
20:07:28 <CyberNine> ya he was 
20:07:57 <CyberNine> he was the guy that big brother killed one of the best cyber sec minds 
20:09:13 <CyberNine> @bitemyapp Bj was a great mind in the tech world that "died" in 2013 but some of us dont by that
20:09:14 <lambdabot> Unknown command, try @list
20:09:41 <CyberNine> bitemyapp Bj was a great mind in the tech world that "died" in 2013 but some of us dont by that
20:10:00 <Mirry> Do you think he was silenced CyberNine?
20:10:30 <CyberNine> there is no doubt he was i mean look at it he was going to show the pacemaker flaw and a week before black hat he died
20:10:37 <CyberNine> doesnt add up to me 
20:11:42 <CyberNine> but anyways on some lighter news what are you other techs up to these days
20:12:11 <CyberNine> im not truly a full tech im in my school almost done with my networking admin degree on my way to cyber serc 
20:13:43 <CyberNine> currently im just talking on irc and watching defcon 18 vids
20:15:49 <Mirry> Dreaming of being there on stage one day, aren't you?
20:23:25 <CyberNine> oh ya man i dream of bettering the tech world
20:28:11 <broma0> Hello, what's everyone doing when it comes to haskell's record fields (and the associated headache)? fclabels? classy prisms?  
20:29:17 <athan> broma0: What's your gripe in particular?
20:29:37 <athan> I think -XOverloadedRecordFields is coming... soon.. ?
20:29:55 <broma0> athan: that'll solve it (hopefully)
20:30:25 <broma0> i believe in 8.0
20:30:43 <athan> Make Haskell great again
20:31:04 <broma0> i hope thats a trump joke
20:31:29 <athan> broma0: You're fired :|
20:32:10 <Mirry> I absolutely love Trump's hair
20:32:40 <Mirry> I mean, the guy's a total wack job, but the hair is like an entity on it's own
20:32:46 <Mirry> Living the life
20:35:17 <geekosaur> OverloadedRecordFields isn't making 8.0 although some of the prerequisites are there
20:35:41 <geekosaur> this is probably the #1 thing that gets people to look at lens though
20:50:12 <jle`> binding with RecordWildCards in do blocks is fun
20:50:19 <jle`> Foo{..} <- foo
20:50:27 <jle`> it's like, name explosion
21:08:03 <broma0> geekosaur: "this is probably the #1 thing that gest people to look at lens" - are you specifically talking about the use of classy prisms allowing pseudo record overloading? otherwise lens is simply complementary 
22:28:19 <wedens> how can I use interpolation in quasi quotes? (e.g. in `sql` QQ from postgresql-simple)
22:51:30 <magthe> I do wonder which Free (from free) to use, Control.Monad.Free, Control.Monad.Free.Church, Control.Monad.Trans.Free, Control.Monad.Trans.Free.Church
22:57:29 <wedens> Church is more performant encoding
22:58:31 <jle`> magthe: maybe write your actual code using MonadFree
22:58:37 <jle`> and then pick which one to specialize in the end
22:58:58 <merq> is this a good channel for pentesting advice?
22:59:46 <MarcelineVQ> If it's haskell related
23:06:47 <fserb> I need some Monad trans help.
23:07:14 <Clint> perhaps you do
23:07:51 <fserb> I know how to go from State Int () to StateT Int IO (). (with something like "\x -> StateT $ pure . runState x".
23:08:02 <fserb> I'm having trouble doing something similar with ExceptT
23:08:05 <fserb> and even worse.
23:08:08 <fserb> what I actually have is:
23:08:31 <fserb> StateT Int (Except String) () that needs to go to StateT Int (ExceptT String IO) ()
23:09:17 <fserb> have been playing with ghci's :t for a while around this.
23:09:37 <Clint> fserb: do you want hoist?
23:10:13 <fserb> Clint: do I?
23:11:29 <fserb> maybe I do. But I don't know how to do it.
23:12:45 <saulzar_> Is there a low precedence (.) people use for chaining lens applications (kind of like &)?  
23:14:07 <fserb> I understand hoist manipulates the monad stack to the right, but I'm not sure how to use it.
23:14:18 <saulzar_> e.g.    ("world", 3) & (_1 .~ "hello"  .  _2 .~ 123)  ... except (.) binds too tightly
23:17:29 <fserb> If I try to "hoist (hoist lift)", I end up with a MonadTrans t => StateT Int (ExceptT String (t Data.Functor.Identity.Identity)) ()
23:17:39 <fserb> what do I do from there?
23:17:59 <ReinH> it's easiest to just use the mtl classes
23:18:08 <ReinH> rather than lifting and hoisting everywhere
23:19:05 <fserb> ReinH: but ExceptT doesn't play nicely with it, as far as my limited knowledge goes.
23:19:14 <ReinH> Sure it does.
23:19:16 <fserb> ReinH: like, can you help me with this particular example?
23:19:26 <ReinH> which example?
23:19:27 <fserb> ReinH: I always end up in a huge mess.
23:19:38 <fserb> StateT Int (Except String) () that needs to go to StateT Int (ExceptT String IO) ()
23:20:13 <ReinH> use throwError from the typeclass
23:20:46 <ReinH> which will work with both Except and ExceptT
23:21:17 <jle`> :t either throwError return
23:21:18 <lambdabot> MonadError e m => Either e a -> m a
23:21:32 <jle`> :t either throwError return :: Monad m => Either e a -> ExceptT e m a
23:21:34 <lambdabot> Monad m => Either e a -> ExceptT e m a
23:21:42 <jle`> hoist (either throwError return) should work
23:23:05 <ReinH> saulzar_: why are you using .~ twice? You shouldn't need t
23:23:08 <ReinH> to
23:23:32 <ReinH> I think you just want to replace the . with &
23:23:53 <saulzar_> Well, in the general case I'd be using it for things which were bigger than pairs..
23:23:55 <ReinH> > ("world", 3) & _1 .~ "hello" & _2 .~ 123
23:23:57 <lambdabot>  ("hello",123)
23:24:13 <ReinH> . is not what you want
23:24:20 <saulzar_> Yup. I'm just thinking a little about writing interfaces with default parameters
23:24:43 <ReinH> Right, so, the problem isn't (.)'s precedence. It's using (.) at all.
23:24:58 <saulzar_> Well..
23:25:16 <saulzar_> > ("world", 3) & ((_1 .~ "hello")  .  (_2 .~ 123)) 
23:25:17 <lambdabot>  ("hello",123)
23:25:26 <ReinH> Ok, but there's no reason to do that
23:26:22 <saulzar_> I'm thinking of functions with an interface like this: textInput :: InputConfig -> m (TextInput)
23:26:41 <ReinH> So this is a new problem now?
23:26:56 <saulzar_> No, but I'll just explain the motivation
23:27:32 <saulzar_> Then you use them like so...  textInput $ def & value .~ "foo"  (this is all very familiar I'm sure)
23:27:56 <ReinH> ok
23:27:59 <saulzar_> But I was thinking of supplying a function textInput :: (InputConfig -> InputConfig) -> m (TextInput)
23:28:18 <saulzar_> Such that you can use it like so: textInput (value .~ "foo)
23:28:40 <saulzar_> Just to get rid of a bit of noise with the "def &"
23:28:40 <ReinH> Oh. Seems better to just do the usual thing.
23:28:47 <fserb> OMG
23:28:57 <fserb> what you guys said almost worked, and I made it work! :)
23:29:24 <saulzar_> Yeah maybe, I'm just trying to streamline a Dom builder so getting rid of any little noisy thing would be good :)
23:29:26 <fserb> so, throwError is deprecated (?) (because Error is deprecated) to Except, which has throwE.
23:29:41 <fserb> :t either throwE return
23:29:43 <lambdabot>     Not in scope: â€˜throwEâ€™
23:29:43 <lambdabot>     Perhaps you meant one of these:
23:29:43 <lambdabot>       â€˜throwâ€™ (imported from Control.Exception),
23:29:43 <saulzar_> Soon as you use it over and over the extra noise gets quite, well, noisy
23:29:49 <fserb> ahn, lambdabot is so behind
23:29:52 <fserb> so
23:30:04 <jle`> throwError is deprecated?
23:30:11 <ReinH> fserb: what? no it isn't.
23:30:13 <fserb> on my ghc it is
23:30:14 <ReinH> throwError is fine
23:30:44 <fserb> http://hackage.haskell.org/package/transformers-0.5.0.0/docs/Control-Monad-Trans-Error.html#v:throwError
23:30:48 <fserb> it says right in the top
23:30:50 <fserb> and on ghci:
23:31:00 <jle`> oh i was thinking of the mtl throwError
23:31:01 <ReinH> fserb: mtl, not transformers, Except, not Error
23:31:10 <ReinH> Error is deprecated
23:31:21 <ReinH> for Except
23:31:27 <fserb> yep
23:31:27 <jle`> the mtl throwError is the canonical polymorphic interface for Except/ExceptT
23:31:33 <ReinH> I said mtl and Except to begin with
23:31:37 <fserb> ahn
23:31:41 <fserb> well
23:31:47 <jle`> admittedly confusing
23:31:48 <fserb> I made it work with: hoist (either throwE return . runExcept)
23:31:59 <ReinH> why would you need to do that?
23:32:11 <jle`> wait, if you already had Except, why not just `hoist generalize`
23:32:14 <ReinH> what specifically are you trying to do?
23:32:31 <ReinH> jle`: I don't see why you'd need hoist at all. I think I've only ever used it once or twice.
23:32:45 <jle`> true...avoid Except at all, heh
23:32:48 <ReinH> And thta was when I was writing transformers, not using them
23:33:42 <ReinH> "hoist (either throwE return . runExcept)" seems unnecessary, but I don't know what you are using it for
23:33:53 <fserb> I have a function that is :: StateT Int (Except String) A
23:34:03 <fserb> and I'm on a function that is :: StateT Int (ExceptT String IO)
23:34:10 <jle`> (either throwE return . runExcept) is `hoist generalize`, but, the better option is to never use Except at all
23:34:11 <ReinH> Oh. Why?
23:34:16 <ReinH> Why mix them?
23:34:27 <fserb> State and Except or IO?
23:34:33 <ReinH> Except and ExceptT
23:34:44 <fserb> oh.
23:35:21 <fserb> Are you saying "why use Except instead of Maybe? Or why use Except with State?"
23:35:22 <jle`> if you want to work with transformer stacks concretely, you could always define Monad m => StateT s (ExceptT e m) a
23:35:34 <ReinH> I'm asking why use Except instead of Either and why use both Except and ExceptT
23:35:56 <jle`> or you can define your functions over (MonadError e m, MonadState s m) => m a
23:35:59 <ReinH> You won't need to swap between Except and ExceptT if you don't use both
23:36:08 <ReinH> simple solution: don't do the thing that's hard that you don't need to do
23:36:20 <fserb> but wouldn't I have the same problem with Either?
23:37:00 <ReinH> I don't see why you wouldn't use ExceptT for both
23:37:13 <fserb> you mean always have IO there?
23:37:14 <ReinH> Or just write things generically using the class
23:37:20 <ReinH> that's what the class is for
23:37:39 <ReinH> like jle` suggested
23:37:39 <fserb> I had everything without IO
23:37:52 <fserb> and I was happy with that. Until I needed IO. :)
23:38:38 <jle`> if you want to work with transformer stacks, you can define your things as Monad m => StateT Int (ExceptT String m) a, instead of StateT Int (Except String) a
23:38:58 <fserb> oh
23:39:07 <fserb> o_O
23:39:16 <jle`> because you know that the first kind can't do IO
23:39:34 <fserb> will Haskell be ok with me not specifying what m is on the "pure" functions?
23:39:42 <ReinH> they're all pure
23:39:52 <jle`> it's called parametric polymorphism
23:40:02 <ReinH> so I'm not sure what "pure" in scare qoutes means.
23:40:21 <fserb> yeah, the quotes didn't make sense :)
23:40:27 <jle`> fserb: writing polymorphic functions is fun!
23:40:41 <fserb> ok, let me try that.
23:40:44 <jle`> you also know that something of type ([m a] -> m [a]) does no IO
23:40:50 <jle`> but something of [IO a] -> IO [a] might
23:40:55 <jle`> (and probably does)
23:41:23 <jle`> er, of type Monad m => [m a] -> m [a]
23:41:45 <jle`> something of type Monad m => ExceptT String m a, won't do any IO
23:42:39 <jle`> actually, if you had left the type signature off, it's likely that that's the type that GHC might have inferred for your first action in the first place :)
23:42:50 <fserb> hmm
23:43:00 <fserb> remove all type signature and hope for the best
23:43:00 <fserb> :)
23:43:11 <jle`> well, it's okay to have the type signature, heh
23:48:09 <ReinH> jle`: see, this is why I question weird uses of hoist to do normal-seeming things
23:48:13 <fserb> hmmmm. Can I still use "type" with parametric polymorphism?
23:48:36 <ReinH> fserb: can you use type at all?
23:48:45 <fserb> well
23:49:01 <jle`> ReinH: yeah, hoist would definitely be a solution to an AB problem here heh
23:49:07 <jle`> actually yeah, when have i used hoist in real life?
23:49:09 <jle`> maybe never
23:49:11 <fserb> type MyThing = StateT Int (ExcepT String)
23:49:20 <fserb> is fine
23:49:31 <jle`> you can do type MyThing m = StateT Int (ExceptT String m)
23:49:56 <ReinH> jle`: indeed
23:50:16 <fserb> but then
23:50:19 <fserb> hmmm
23:50:27 <jle`> foo :: Monad m => MyThing m, a MyThing that does no IO :O
23:50:35 <jle`> bar :: MyThing IO, a MyThing that does IO :O
23:50:50 <fserb> ahn, yeah. I need to parametrize everything that uses the non IO one
23:51:13 <jle`> i wonder if the rank n type would be okay here or if it'd be overengineering
23:51:19 <jle`> type MyThing' = forall m. MyThing m
23:51:24 <jle`> type MyThing' = forall m. Monad m => MyThing m
23:51:24 <ReinH> overengineering.
23:51:26 <jle`> heh
23:51:31 <jle`> welp
23:51:40 <jle`> it'll work :3
23:51:56 <jle`> fsvo "work"
23:51:59 <ReinH> I already prevented the hoist overengineering ;)
23:52:04 <ReinH> let's not start again
23:52:37 <fserb> but why do you guys think that having the Monad m => everywhere I use it is better than hoist?
23:52:54 <fserb> (It's an honest question, my haskell abilities don't go that far)
23:56:19 <fserb> (btw, I tried the forall thing. It works kinda. It messes up later, when I need to "instance Show" something that gets a function with this type)
23:56:36 <jle`> well, it's more flexible; you're not actaully converting anything, you can use Monad m => ExceptT e m a's with ExceptT e IO a, and they work together
23:57:10 <jle`> it's easier to work with a Monad m => ExceptT e m a than an Except e m a
23:57:13 <jle`> er, Except e a
23:57:40 <jle`> but the more disciplined route would be to avoid writing functions specifically for ExceptT or StateT, anyways
23:57:52 <fserb> what do you mean by that?
23:58:01 <jle`> write them polymorphically over all "monads that can throw errors", or "monads that can have state"
23:58:10 <ReinH> hoist might do work. Types don't do any work.
23:58:12 <jle`> for example, if your function only ever needs statey abilities, use MonadState s m =>
23:58:32 <jle`> if your action only ever needs errorie effects, use MonadError e m =>
23:58:45 <jle`> if your action needs both statey effects and io effects, use (MonadState s m, MonadIO m) =>
23:58:54 <jle`> just constrain it to only the effects your action needs
23:59:06 <ReinH> Yes, this was my original suggestion.
23:59:18 <ReinH> Use mtl's typeclasses.
23:59:30 <fserb> is there a tutorial somewhere about this?
23:59:44 <jle`> and in the end you might not even want to use monad transformers to implement your effectful action type
23:59:57 <jle`> but you could, if you wanted to!  who knows! :O
