00:11:47 <koz_> What would be a good thing in Haskell to draw me some line graphs?
00:13:47 <pavonia> diagrams?
00:14:18 <koz_> pavonia: https://en.wikipedia.org/wiki/Line_chart#/media/File:Graph_%28PSF%29.png <-- oneof these
00:14:54 <spindas> koz_, I think pavonia means the diagrams package 
00:15:01 <spindas> there's also https://github.com/timbod7/haskell-chart/wiki
00:15:17 <spindas> which might more directly solve your problem
00:15:28 <koz_> spindas: Oh, ok. I'll check out both.
00:15:42 <pavonia> Yep, I meant the package. Not sure it can draw this kind of graph, though
00:16:01 <spindas> koz_, line graph example with haskell-chart: https://github.com/timbod7/haskell-chart/wiki/example%204
00:26:34 * hackagebot visibility 0.1.0.2 - Simple computation of visibility polygons.  https://hackage.haskell.org/package/visibility-0.1.0.2 (darwin226)
00:45:26 <puregreen> how do monad transformer stacks interact with concurrency? e.g. I've got some operations like ExceptT (ReaderT (StateT IO)) and I want to execute them in parallel; what's the best way to do this?
00:46:01 <jle`> monad-control i think is how people normally deal with things like this
00:47:29 <jle`> hm, i misread your question
00:47:36 <jle`> executing a bunch of operations in parallel is usually done with `async`
00:48:01 <jle`> you might be able to use the two libraries together
00:49:38 <puregreen> jle`: thanks for a pointer
00:51:19 <sanotehu> if I'm working within my main do construct for a program, and I use a function that returns a `Maybe x', what is the correct way to halt execution if the result of that function is Nothing?
00:52:30 <wedens> can I set "--ghci-options" for "stack ghci" in stack.yaml?
00:52:33 <jle`> you can use forM_ foo $ \x -> ..., on your `foo :: Maybe a`, to get a construct that's like 'when', except you only go in if you have a Just, and x is inside the just
00:53:10 <jle`> but if you're describing `main` then it should also be perfectly fine to do x <- fromMaybe (throwIO MyError) foo
00:53:21 <jle`> er
00:53:28 <jle`> x <- maybe (throwIO MyError) return foo
00:53:49 <jle`> if the lack of the value represents an actual IO error, like a disk error or configuration error
00:54:13 <jle`> using forM_ will basically say "only do what's in here/only continue if you have a Just", which might match what you want better.
00:54:49 <sanotehu> I think the x <- maybe ... example might be the right one, I'll read up on it
00:54:51 <sanotehu> thanks
00:55:18 <MasseR> sanotehu: Just throwing this out there, but you could also check MaybeT IO a
00:58:19 <Ashy> heh, didnt realize my twitter bot was down all this time
00:58:29 <Ashy> https://twitter.com/LambdaTwit/with_replies
00:58:32 <Ashy> he's back up again now
01:04:38 <sanotehu> is there a haskell equivalent of if (error occurred) { print error; return failure; } ?
01:04:51 <jle`> you can use catch
01:04:59 <jle`> from Control.Exception
01:05:18 <sanotehu> that might be more what I'm looking for, thanks
01:05:21 <jle`> most of the tools you need for working with runtime exceptions in haskell are in Control.Exception :)
01:05:53 <jle`> simon marlow's book on concurrency in haskell also has a chapter all about ghc's runtime exception system
01:16:37 <phaazon> :t liftF
01:16:38 <lambdabot>     Not in scope: ‘liftF’
01:16:38 <lambdabot>     Perhaps you meant one of these:
01:16:38 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
01:16:45 <phaazon> @let import Control.Monad.Free
01:16:47 <lambdabot>  <no location info>:
01:16:47 <lambdabot>      The package (profunctors-5.1.1) is required to be trusted but it isn't!
01:16:55 <phaazon> okay :(
01:30:41 <wedens> in postgresql-simple after manual rollback and attempt to commit I get warning "there is no transaction in progress". how can I check that transaction was not rolled back or suppress this warning?
01:33:42 <statusfailed> Using an AST built in this style: http://jtobin.ca/practical-recursion-schemes/ what's the best way to map over all the "VarF" nodes ?
01:36:17 <MasseR> wedens: after rollback you tried to commit?
01:36:44 <MasseR> Usually in java/php-land I rollback in exceptions
01:36:55 <MasseR> It shouldn't reach the commit at all if an exception was thrown
01:41:17 <tdammers> try { database.beginTransaction(); database.doStuff(); } finally { database.commit(); } // MySQL style
01:41:41 <tdammers> seriously though, yes, rollback on exception is the sane way of doing this
01:42:06 <tdammers> ideally, wrap this whole machinery in something convenient, e.g. withTransaction
01:48:56 <wedens> tdammers MasseR: it's rollback on Left. I think I can somehow rearrange code to not try to commit after rollback..
01:49:32 <humanoyd> If I prepare a package for upload to hackage with `cabal sdist`, do I need to do anything about the haddock documentation or will it automatically be generated on the server?
01:49:39 <tdammers> you could still make a wrapper using Either as a monad or sth
01:50:58 <puregreen> humanoyd: it it supposed to be automatically generated on the server, except that Hackage seems to have problems with that
01:51:02 <wedens> tdammers: I'll just bitraverse it with commit and rollback
01:51:23 <puregreen> humanoyd: you can generate documentation and upload it after you upload the package itself, tho, so don't worry
01:51:31 <tdammers> since your database queries have to run in IO anyway, why not use IO errors for this?
01:51:41 <humanoyd> puregreen: Thank you
01:51:45 <tdammers> then you can just `bracket` your database interaction and call it a day
01:51:58 <tdammers> or whatever IO error handling is suitable
01:52:20 <tdammers> withTransaction :: (Transaction -> IO a) -> Database -> IO a
01:53:44 <wedens> tdammers: I don't like using IO for "logical" errors
01:54:01 <humanoyd> Is it considered good practice to include tests in `extra-source-files` ?
01:59:07 <Wizek> Hello! Might any of you have seen a library that can parse XML in the following way into data structures? `parseXML "<a>$1</a>[<b>$2</b>]" "<a>1</a><b>Hello</b><b>World</b>" == (1, ["Hello", "World"])`
02:00:26 <wedens> Wizek: what is it? O_o
02:02:21 <Wizek> Are you asking what is the name of the library? I don't know, I'm looking for one myself that works similar to my made-up example.
02:03:10 <quicksilver> I am fairly sure no library exists like that
02:03:15 <tdammers> same here
02:03:22 <tdammers> the input format doesn't look sane to me at all
02:03:26 <quicksilver> you could construct something a bit like it but
02:03:39 <quicksilver> designing an ad-hoc specification for a grammar with placeholders
02:03:42 <quicksilver> is probably a poor use of time
02:03:52 <quicksilver> it's hard to get that kind of thing right and useful.
02:04:53 <tdammers> a more idiomatic way to express this in XML would be something like <tuple><elem type="int" value="1"/><elem type="list" item-type="string"><item>Hello</item><item>world</item></elem></tuple>
02:05:17 <tdammers> and then you'd express the grammar in terms of XSD and XSL
02:07:22 <Wizek> Is it really that bad? I mean having an XML definition would allow very easy conversion between XML and native data structures, e.g. `renderXML "<a>$1</a>[<b>$2</b>]" (1, ["Hello", "World"]) == "<a>1</a><b>Hello</b><b>World</b>"`
02:08:06 <Wizek> And the syntax in the definition string is made up on the spot, so a different syntax might be better
02:08:14 <tdammers> yes, probably
02:08:35 <tdammers> I would forgo the idea of using strings for this entirely, and instead build a properly typed EDSL
02:09:35 <Wizek> Okay, sure. I was thinking about the definition being TH/QQ myself.
02:10:29 <tdammers> let buildMyXML a b = renderXML $ elem "a" [] a <> elems "b" [] b
02:10:39 <Wizek> `parseXML [xmldef| <a>Int</a>[<b>String</b>] |] "<a>1</a><b>Hello</b><b>World</b>" == (1, ["Hello", "World"])`
02:13:50 <Wizek> tdammers, Is that a syntax of an existing lib that I could use already? Or are you saying how you'd imagine the API?
02:14:31 <tdammers> I made that up on the spot
02:14:51 <tdammers> but it's similar to how Blaze builds HTML
02:15:00 <Wizek> true
02:15:17 <tdammers> come to think of it, you might actually just use blaze for this in the first place
02:15:54 <Wizek> tdammers, Can that be used both directions? Parsing and rendering too?
02:16:44 <tdammers> hmm, I don't think so, but I'm not sure
02:17:45 <Wizek> I mainly would need it for parsing at the moment, but I just realized that a flexible enough xml definition with this kind of parser could also be used for serializing. And I like the elegance of that: Define once, use both directions.
02:22:37 <Wizek> Or might you know about any other languages that can do similar? Have one definition for conversion, and be able to both serialize or parse accordingly?
02:22:45 <tdammers> Wizek: yes, but a two-way DSL is a whole different ball game
02:23:34 <tdammers> in particular, making sure the transform is lossless isn't trivial
02:23:51 <Wizek> Of course, that can be difficult.
02:24:03 <tdammers> e.g., when I feed data to your function that contains items that you're not using, then you cannot possibly reverse the transformation
02:24:49 <Wizek> Of course, then they would be dropped. But in my case I wouldn't mind that: Anything I care about I would include in my definition.
02:24:54 <tdammers> OTOH, if your input format is by definition redundant, then ignoring parts of the data is not problematic at all
02:25:00 <tdammers> and it's near impossible to tell the difference
02:27:44 <Wizek> Illustrating it with an example: `let def = [xmldef| <a>Int</a>[<b>String</b>] |] in renderXML def (parseXML def "<a>1</a><b>Hello</b><b>World</b><c/><d/><e/>") == <a>1</a><b>Hello</b><b>World</b>`
02:27:52 <Wizek> Something that works like this would be okay for me
02:29:11 <merijn> I have a reference somewhere for a paper on reversible parsers, i.e. generating parsers and pretty printers from the same code
02:31:55 <Wizek> merijn, Could you share? That sounds like something in the direction I'm looking for
02:33:34 <merijn> "Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing" by Rendell and Ostermann
02:33:51 <Wizek> Thanks!
02:34:09 <tdammers> ^ this is the kind of stuff I was thinking of
02:34:14 <tdammers> "reversible parsers"
02:34:20 <tdammers> complex and nontrivial topic.
02:42:31 * hackagebot wai-routes 0.9.6 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.9.6 (AnupamJain)
02:50:30 <puregreen> can I pause/resume a thread if I know its ThreadId?
02:50:59 <puregreen> (well, if it even makes sense)
02:51:10 <Adeon> nope
02:51:13 <Adeon> well you can kill it
02:51:26 <Adeon> but you can't stop/resume unless that thread itself is co-operating by knowing how to pause
02:51:47 <merijn> puregreen: Is there a specific reason you want to?
02:52:25 <puregreen> merijn: I have a thread that is essentially a “forever $ do” loop and it'd be nice if I could easily make the loop stop/continue
02:53:13 <merijn> puregreen: If you're willing to modify the original thread it'd be pretty easy
02:53:55 <puregreen> yep, modifying it is fine
02:54:42 <merijn> Just add some MVar to block on. At the start of the do block "takeMVar mvar >> putMVar mvar ()" then you can block it by having another thread "takeMVar mvar", causing the takeMVar in the forever to block
02:55:08 <merijn> Then you can unblock it by "putMVar mvar ()", might need to think carefully to prevent deadlocks
02:55:57 <puregreen> probably tryTakeMVar and tryPutMVar instead? so that it wouldn't hang if it's already running/sleeping
02:56:32 <puregreen> no
02:56:36 <puregreen> yes
02:56:53 <puregreen> takeMVar in the forever thread, tryTakeMVar for blocking
02:57:29 <Wizek> puregreen, I don't know whether it works on threads, but on Unix processes at least you can issue a SIGSTOP and SIGCONT that is quite effective.
02:58:00 <merijn> puregreen: Might want to takeMVar for blocking too (else the forever thread won't block and you'll only block for a short amount) but you might want to "tryPutMVar" when unblocking
02:58:14 <merijn> puregreen: It also depends on whether you want to block it from only a single thread or from multiple
02:58:27 <merijn> Wizek: Doesn't work on haskell lightweight threads
03:00:41 <puregreen> merijn: it worked, thanks!
03:02:11 <merijn> puregreen: If you need something more complex you can probably very easily factor this out into something more reliable and/or use STM to make it more robust with multiple pausers, but for simple solutions it should suffice :)
03:04:00 <bollu1> how does the definition of an "algebra" come about? algebra :: f a -> a?
03:04:15 <bollu1> I don't get how, say, a group corresponds to f a -> a?
03:04:19 <bollu1> or even a ring, or a monoid, or whatever
03:04:47 <bollu1> (because a group is a *collection* of such rules, right? eg: identity :: a, inverse :: a -> a, groupop :: a -> a -> a
03:05:00 <bollu1> so how exactly does an algebra correspond to that category theory definition?
03:05:18 <joash> bollu1: have you read http://bartoszmilewski.com/2013/06/10/understanding-f-algebras/ ?
03:05:55 <bollu1> joash: nope, thanks for the link :)
03:06:25 <bollu1> joash: I ran into algebras from a different route. Should have known the teach-category-theory entries would have F algebras
03:06:57 <bollu1> "But nothing prepares you for this definition of F-algebra " quite true :P
03:07:14 <joash> yep
03:07:21 <joash> it's a great article
03:08:39 <fr33domlover> I think there was a generalized 'map' in base 4.7 and now base 4.8 has 'map' that is /only/ for lists, and for other structures there is only 'fmap' filling the spot. Am I right?
03:09:10 <fr33domlover> suppose I want to map over a Sequence, is fmap the (only) way to do it
03:09:13 <fr33domlover> ?
03:09:22 <puregreen> merijn: by the way, I used a readMVar instead of “takeMVar mvar >> putMVar mvar ()”, it's supposed to be atomic (so I can use tryTakeMVar for blocking)
03:09:23 <fr33domlover> s/Sequence/Seq
03:09:25 <tdammers> I'd generally go with fmap anyway
03:09:36 <puregreen> fr33domlover: I don't remember any generalised map in base 4.7
03:09:52 <fr33domlover> puregreen, maybe i'm confusing it with mapM :P
03:10:07 <fr33domlover> but in this question i do mean 'map'
03:12:36 * hackagebot data-accessor-transformers 0.2.1.7 - Use Accessor to access state in transformers State monad  https://hackage.haskell.org/package/data-accessor-transformers-0.2.1.7 (HenningThielemann)
03:13:28 <fr33domlover> since I started using fmap instead of liftM my code suddenly has many fmaps :P
03:13:33 <fr33domlover> the price of abstraction?
03:13:50 <fr33domlover> generic => less specific meaning
03:14:13 <castlelore> opaleye only targets postgres?
03:14:28 <MasseR> Yes
03:14:43 <merijn> puregreen: Ah, yes, readMVar is good. combined with tryTakeMVar and tryPutMVar for multiple blockers I think it should work. Might wanna refer to the "Parallel & Concurrent Haskell" book to be sure if you really care about correctness :)
03:14:59 <frerich> fr33domlover: Well the opposite of generic is specific, so yeah...
03:15:46 <frerich> fr33domlover: I hope you're consequent in your usage of fmap and replaced all uses of (.), too.
03:15:53 <frerich> :o}
03:16:05 <fr33domlover> lol
03:16:18 <fr33domlover> actually I asked here about liftM VS fmap since base 4.8
03:16:25 <fr33domlover> and i was adviced to use fmap
03:16:41 <fr33domlover> liftM is just a Monad-specific fmap from now on
03:16:55 <jle`> it's also potentially less efficient :o
03:17:05 <frerich> I never understood what's up this "Make everything as generic as possible, instead of making it as generic as necessary" triage...
03:17:29 <kqr> a part of me prefers using the most generic operator because it lowers the symbol space I need to handle in my head
03:17:31 <jle`> one of the main benefits of generic code is giving you more power in reasoning about your polymorphic code i guess
03:17:36 * hackagebot data-accessor 0.2.2.7 - Utilities for accessing and manipulating fields of records  https://hackage.haskell.org/package/data-accessor-0.2.2.7 (HenningThielemann)
03:17:45 <kqr> if I only use fmap, I don't need to remember/explain liftM and liftA
03:17:53 <tzaeru> in my experience, the more people try to make generic and reusable code, the less time we have left when we need to rewrite everything anyway.
03:17:54 <kqr> same with pure/return
03:18:21 <jle`> yeah, in some cases the more generic versions are just more immediately recongizable than the specific versions
03:18:23 <kqr> but I also understand that sometimes more specific means easier to understand the purpose of the code, if there are insufficient comments
03:18:26 <jle`> and in some cases they aren't
03:18:29 <jle`> it's case-by-case
03:19:04 <jle`> more generic code in general means more powerful reasoning through types, though; but it does have costs
03:19:06 <kqr> I guess my aversion to specific symbols comes from people complaining that haskell is this huge language with a million functions and operators
03:19:12 <fr33domlover> one slightly annoying example is that sometimes a function takes a list when it really could take any Traversable
03:19:14 <kqr> which is not true if you stick to the most general ones lol
03:19:23 <fr33domlover> and you need to convert to/from list etc.
03:19:27 <frerich> I'd much rather read "map (foo . bar) yoyo" than "fmap (fmap foo bar) yoyo".
03:19:27 <jle`> for example, you can say more abut a `Num a => [a] -> [a]` than you can say about a `RealFrac a => [a] -> [a]`
03:19:28 <fr33domlover> a bit annoying
03:19:45 <jle`> and you can say much more things about a Functor f => ... than you can say about a Monad m => ...
03:19:52 <jle`> about what the function *can't* do
03:19:57 <jle`> and properties it must obey
03:20:18 <merijn> Also, the Functor one works for more stuff :)
03:20:38 <jle`> `Applicative f => (a -> f Bool) -> [a] -> f [b]` vs `Monad m => (a -> m Bool) -> [a] -> m [b]` 
03:20:51 <jle`> you can know that the Applicative version won't short-circuit
03:20:54 <jle`> and the Monad one might
03:21:09 <jle`> *f [a] and m [a]
03:21:44 <jle`> so if you used liftM instead of liftA, your type signature wouldn't tell people as much about the implementation, you'd ahve to leave it up to documentation
03:21:51 <jle`> merijn: yes that's another advantage too, heh
03:21:58 <jle`> tradeoffs for everything i guess
03:22:38 <fr33domlover> 'base' tries to take both roads, it has generic /and/ specific variants for some functions
03:23:10 <fr33domlover> like, it has 'map' specific for lists and 'genericLength' etc.
03:23:21 <jle`> which makes sense, the the same function might be more or less readable in different contexts
03:23:48 <jle`> but using liftM vs fmap is often more than just a readability thing, too; liftM is potentially less performant
03:24:33 <fr33domlover> [2 years later...] Hey, here's the new code that launches the first Haskell powered spaceship! fmap (fmap . fmap fmap 5) . fmap launch . fmap fmap (fmap land) $ fmap engine fmap . fmap)
03:24:55 <frerich> kqr: The benefit of a large vocabulary is that you can be very concise and yet expressive. E.g. 'f . g' tells you a lot more about what's going on than 'fmap f g'. Being generic is nice when defining a function since you can tell less (i.e. reason better) about the arguments. When applying a function though, knowing some context is nice.
03:25:05 <puregreen> {-# LANGUAGE AutomaticFmaps #-}
03:26:51 <puregreen> (* needs a sufficiently advanced ambiguity checker)
03:28:18 <fr33domlover> * hackagebot fmap-0.1 Fills your code with fmaps and derives Functor instances as needed to maximize the results
03:28:21 <kqr> frerich, right, that's exactly my thinking. i've come back to highly general code and had to manually figure out which instances of what I was using just to figure out what the code was *actually* doing in my specific case
03:29:56 <fr33domlover> [5 years later] Starting with GHC 10, the 'main' function is now called 'fmap'
03:31:01 <fr33domlover> [15 years later] Good evening, breaking news! The UN has decided unanimously today that the Earth will from now on be called the Fmap
03:32:38 <fr33domlover> ok last one I think... [25 years later] Steven Hawking: Apparently I was wrong, the universe began with the Big Fmap
03:32:52 <frerich> kqr: Right. The supposed 'simplification' of only using a single 'verb' like fmap is actually just a mirage. Less words to remember just means that you have more work trying to infer information from the context.
03:33:30 <kqr> fr33domlover, i'd be okay with calling the earth the fmap
03:35:50 <fr33domlover> [... 25 years continued] Hawking: Not only that, apparently the formula that explains all of existence is "god <$> matter". Aliens told me this but I fear we aren't advanced enough to understand its depth yet
03:37:36 * hackagebot storable-tuple 0.0.3.2 - Storable instance for pairs and triples  https://hackage.haskell.org/package/storable-tuple-0.0.3.2 (HenningThielemann)
03:38:12 <fr33domlover> kqr, cool! let's fmap it "the Fmap" from now on then. Then we can fmap about it on IRC, maybe even make fmap requests to fix the wording on some websites, or fmap some matches. When we decide to travel the wold, we can navigate using the fmap!
03:38:29 <fr33domlover> s/matches/patches
03:38:46 <fr33domlover> oops, I mean: fmap matches patches
03:39:18 <kqr> that sounds like an fmapping good idea
03:39:19 <Heather>  distributive 0.5.0.2 looks completely broken for me
03:52:37 * hackagebot hardware-edsl 0.1.0.0 - Deep embedding of hardware descriptions with code generation.  https://hackage.haskell.org/package/hardware-edsl-0.1.0.0 (mararon)
03:53:06 <kqr> someone on reddit.com/r/haskell spoke about the formatting package being "just the cont monad" and I feel like I have no idea what that even means. i'm vaguely familiar with continuation-passing style. is there a good guide to the cont type/monad?
03:59:03 <merijn> kqr: The Cont monad, shortly abridged in my experience is similar to quantum mechanics: http://abstrusegoose.com/93
04:00:19 <mauke`> @src Cont
04:00:19 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
04:00:32 <hunteriam> is haskell style code actually the future?
04:00:41 <kqr> i seriously think it is, yes
04:00:46 <mauke`> no, it's the pasture
04:01:01 <hunteriam> i like it a lot, but will people ever actua'ly adapt it?
04:01:02 <liste> a greener pasture
04:01:11 <statusfailed> In the future, old programmers will be put out to haskell?
04:01:16 <kqr> i don't think we'll see pure code in the mainstream for at least another 30 years, but I have no doubt it'll eventually get there
04:02:10 <anohigisavay> hi. i saw in some TH example code: emptyShow ''MyData
04:02:20 <anohigisavay> emptyShow :: Name -> Q [Dec]
04:02:56 <anohigisavay> the function call  does not return a Q [Dec] but generates some code?
04:03:20 <puregreen> [Dec] is code being generated
04:04:15 <merijn> kqr: I found the most enlightening example of Cont was ContT as bracket pattern
04:04:27 <anohigisavay> ahh i see
04:04:39 <merijn> kqr: See https://stackoverflow.com/questions/26436095/what-are-good-haskell-conventions-for-managing-deeply-nested-bracket-patterns
04:04:42 <anohigisavay> puregreen: thanks 
04:07:56 <kqr> anohigisavay, if it's less confusing, you could write $(emptyShow ''MyData) instead
04:08:06 <kqr> anohigisavay, though GHC contains a shortcut where you can remove the $() stuff if it's a top-level declaration
04:09:19 <kqr> anohigisavay, but the $() is TH magic that runs the expression inside during compile time, takes the "Q HaskellCode" that is returned, and pretends the code was in the source file to begin with
04:13:31 <anohigisavay> kqr: yea i do think the $() looks better
04:16:13 <fr33domlover> kqr, in the stackoverflow example note that the "flip runContT return" hack should really be "evalContT" :P
04:16:37 <fr33domlover> (i think)
04:22:51 * hackagebot mono-traversable 0.10.1 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-0.10.1 (MichaelSnoyman)
04:25:29 <anohigisavay> kqr: hi. i'm still a bit confused
04:26:00 <anohigisavay> why [str|hello word|] gives me a string, instead of a Q Exp or something?
04:26:04 <kqr> fr33domlover, if I understand the haddocks, you're right
04:28:04 <anohigisavay> oops
04:28:06 <anohigisavay> str = QuasiQuoter { quoteExp = stringE }
04:28:14 <kqr> fr33domlover, it returns a Q Exp, where the Exp is just a string
04:28:27 <kqr> ...i think
04:28:30 <kqr> i'm a bit foggy on the details
04:29:08 <scshunt> anohigisavay: Because [str| |] evaluates the quasiquote
04:29:30 <scshunt> str "hello world" would give you a Q Exp
04:29:46 <scshunt> Using this inside the quasiquote causes the result to be spliced.
04:30:13 <kqr> oh right that's the way it is
04:30:14 <scshunt> it also adds some syntactic convenience around string parsing
04:31:48 <anohigisavay> wait.. str is a QuasiQuoter i can use it as a function?
04:31:56 <anohigisavay> ahh
04:31:57 <anohigisavay> i see
04:32:14 <kqr> you can use (quoteExp str) as a function
04:32:32 <scshunt> err, right
04:32:45 <scshunt> not str "hellow world" but (quoteExp str) "hello world"
04:32:51 <scshunt> since there are other quoting functions for different contexts
04:33:04 <scshunt> Sometimes I forget people quote other things
04:33:06 <kqr> this is the essence of what powerful metaprogramming is – it's just regular code that happens to run during compile time
04:33:20 <anohigisavay> :D
04:34:25 <anohigisavay> difficult like hell 
04:34:38 <anohigisavay> but god i like it
04:34:46 <anohigisavay> thank you guys
04:35:06 <merijn> anohigisavay: Not quite, but it's often unexpected. Think of it like CPP macro's in C/C++, but instead of your macros being written in this very limited CPP language, they're written in full Haskell :)
04:35:21 <kqr> if you want an introduction to metaprogramming that's less intimidating, maybe it's time to learn a lisp
04:35:36 <merijn> The right way to think of TH is really "compile-time macros", except that your macro language is Haskell, instead of the common string based macros
04:35:44 <kqr> I say less intimidating because GHC metaprogramming is type-safe, which lisp is not
04:36:02 <merijn> kqr: Doubly typesafe if you use Typed TH :)
04:36:38 <kqr> merijn, that only affects quasi-quotes, right?
04:36:47 <merijn> Huh, no?
04:36:53 <kqr> okay I'm reading this too quickly
04:36:58 <ggole> Lisp macros are trivially type safe, since every lisp term has the same type
04:37:06 <merijn> QuasiQuotes is just the "[foo|]" notation
04:37:08 <ggole> They have other problems though
04:37:24 <merijn> Typed TH has a custom quasiquotes syntax, but you can just write arbitrary TH functions
04:37:50 <tdammers> ggole: I think this is one of the cases where it makes sense to distinguish between "is typesafe" and "typechecks"
04:38:09 <kqr> actually I'll take this moment to ask: some TH functions are documented along the lines of "this will just blindly generate code, it is up to you to ensure it type checks" – what does this mean?
04:38:42 <merijn> kqr: It means that it CAN generate code with type "String" in a context where the value should be, say, Int and then the compilation fails with type error
04:38:54 <kqr> ah so what's the problem with that?
04:39:02 <merijn> kqr: i.e. Type checking TH does not guarantee a typechecking final application
04:39:10 <merijn> kqr: Typed TH *does* give you that guarantee
04:39:52 <merijn> Where TH generates "an expression of some type" Typed TH has a way to say that it generates "an expression of type X"
04:39:53 <tdammers> the practical problem with untyped TH is that when you write TH that produces code that doesn't typecheck, it is hard to debug, because you don't get to see the generated code that the type error refers to
04:39:57 <kqr> merijn, aah. but regular type checking TH will not cause run-time bugs when it has generated mistyped code, it's just that it will generate code that fails the type check which may be confusing to debug?
04:40:07 <kqr> ah yes, what tdammers said
04:40:08 <merijn> kqr: Yes
04:40:34 <tdammers> it may sound like shenanigans, but the "confusing to debug" part can actually be quite a nuisance
04:40:48 <kqr> no I understand it's a bother
04:40:54 <kqr> better to flag errors as early as possible
04:40:58 <tdammers> not just that
04:40:59 <merijn> So typed TH is safeR than TH, in the sense that it limits the ways you can fuck up your debugging :)
04:41:06 <tdammers> suppose you write a library that exposes some TH
04:41:25 <merijn> kqr: But no, GHC, will never blindly trust TH splices to have the right type and then segfault at runtime
04:41:29 <tdammers> with untyped TH, you cannot easily make sure the TH produces well-typed output under all circumstances
04:42:04 <tdammers> but you don't want to burden your users with intimate knowledge of your library's inner workings in order to troubleshoot any errors that might occur
04:42:23 <kqr> course not
04:42:27 <merijn> Lemme illustrate with an example of what Typed TH can do, but TH cannot
04:43:07 <merijn> "Q (TExp (a -> b)) -> Q (TExp a) -> Q (TExp b)" (here TExp is "Exp" with a phantom parameter)
04:43:33 <merijn> You could write the same combinator in TH as "Q Exp -> Q Exp -> Q Exp", but that's clearly inferior
04:44:51 <kqr> am I unfair if I generalise and gather from that that typed TH let's you create more useful TH combinators?
04:45:18 <merijn> Amongst other things, but typed TH is secretly more powerful, as it's run at a different time than TH
04:45:18 <Xandaros> There is typed TH? o_O
04:45:42 <Xandaros> That is awesome. More types is always better in my world
04:45:51 <merijn> Typed TH runs after typechecking, with GHC effectively having holes that will be filled in by TH after typechecking
04:45:52 <kqr> xandaros the idris programmer
04:46:02 <merijn> This means your Typed TH can use typeclass constraints from the context
04:46:18 <merijn> Which you can abuse like so: https://github.com/merijn/validated-literals
04:46:23 <merijn> See the examples directory
04:46:34 <merijn> (I should really put some more polish into that)
04:46:49 <kqr> (there is a joke about the language there)
04:47:51 <Xandaros> merijn: Love it
04:48:44 <Xandaros> kqr: I actually liked Idris when I tried it. I prefer Haskell, though. (Can't wait for TypeInType. Hype hype)
04:51:09 <tdammers> HypeInHype?
04:53:49 <Xandaros> indeed
04:56:16 <sbrg> TypeInTypeHype
04:56:47 <sbrg> we need that extension. it makes the compiler output really positive and excited messages every time you use the stuff added by TypeInType
04:57:08 <sbrg> "Wow! You just wrote some dependently typed code! Isn't it just great?! Amazing!"
04:57:17 <tdammers> also, it should make the compiler output messages that urge you to start using TypeInType when you don't use it
04:57:29 <Xandaros> That should be default behaviour
04:57:32 <sbrg> lol
04:57:45 <tdammers> "10 Reasons Why You Shouls Start Using TypeInType Right Now, CLICK HERE!!!111"
04:57:54 <kqr> the compiler should also have sort of an avatar, in the shape of some regular office item to make users more comfortable with it... like a paperclip or something
04:58:05 <kqr> "I noticed you are not using TypeInType in this module – do you want me to add it?"
04:58:07 <Xandaros> And shout at you when you use functions that are known to be partial
04:58:47 <tdammers> "Installation requirements: USB cattle prod (required for instant compiler feedback)"
05:00:05 <Xandaros> Something I'd actually really like in haskell is a(n optional) totality checker.
05:00:05 <sbrg> "I notice you are using TypeInType but you do not seem very excited about it. Would you like me to enable TypeInTypeHype?"
05:00:39 <tdammers> "Would you like me to enable it twice?"
05:00:41 <arw> "helpful" compilers that tell people "maybe you need -XDoStuffMode?" just lead to unjustified overuse of DoStuffMode...
05:01:14 <tdammers> which is totally not a problem if DoStuffMode is a sane and useful extension
05:01:40 <Xandaros> UndecidableInstances
05:01:42 <tdammers> GeneralizedNewtypeDeriving - I don't see how you could possibly overuse that, except of course if you need to support compilers that aren't GHC
05:01:50 <sbrg> I would love a DoStuffMode extension. I am currently engaging in some TypeInTypeHype instead of Doing Stuff like studying for my exams.
05:01:52 <arw> tdammers: which leads to the question, why isn't DoStuffMode default, if it doesn't have any downsides?
05:02:17 <tdammers> arw: it does; it's not in the standard, and compilers that aren't GHC don't necessarily support it
05:02:20 <sbrg> arw: it doesn't have to have downsides to not be default. not being default makes code more portable.
05:02:22 <sbrg> ^
05:02:38 <arw> okay, yes, thats a valid point.
05:02:45 <sbrg> by enabling a ghc-specific extension you are explicitly stating that your code may not be portable, etc.
05:02:53 * hackagebot path-io 0.1.0 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-0.1.0 (mrkkrp)
05:04:22 <sbrg> directory? path? anyone else seeing question marks?
05:04:38 <boj> yup
05:05:17 <sbrg> "So uh.. this is an interface to directory? Maybe? For users of path maybe? I don't know. I was drunk when I wrote it. v. 0.1.0-10-beers-in"
05:05:20 <boj> ah, they used weird quotes
05:05:23 <sbrg> aah
05:06:23 <mauke`> Interface to XdirectoryY package for users of XpathY
05:08:11 <merijn> Ah, it makes sense now
05:08:35 <merijn> path is apparently a generic/"proper" type for paths and it's just wrapping directory (String everywhere) with that
05:13:10 <Xandaros> There are too many packages on hackage without documentation...
05:13:37 <merijn> Xandaros: Start writing docs and pull requesting them! :)
05:13:51 <Xandaros> That's not the issue, though, is it? :P
05:14:08 <Xandaros> Often the documentation exists, it just isn't built on hackage
05:14:09 <merijn> Xandaros: It depends, this discussion happens every X time frame on reddit/here/wherever
05:14:14 <merijn> Xandaros: Ah, that
05:14:26 <dons> hey folks.
05:14:45 <merijn> Xandaros: hackage uses batch processing on donated infrastructure to build docs, which can delay the time a lot
05:14:48 <merijn> dons: Hey
05:14:57 <merijn> dons: I have a question for you, actually :)
05:15:11 <dons> yep. i've got about 15 mins
05:15:28 <dons> job ad here: https://donsbot.wordpress.com/2016/01/18/haskell-developer-roles-at-standard-chartered-london-singapore/ 
05:15:33 <dons> looking for 3 more devs, singapore or london.
05:15:37 <dons> happy to answer any qs
05:15:42 <merijn> dons: Sometime in a distant past I saved a link to a paper by you on dynamically loaded plugins for Haskell. However, the link has bitrotted and I can't seem to find it anymore?
05:16:32 <dons> ah ok. "plugging haskell in" I guess?
05:16:41 <merijn> I think that's the one, yeah
05:17:04 <dons> citeseer has it i think http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.9.7627
05:17:51 <dons> @yow
05:17:51 <lambdabot> I wonder if I could ever get started in the credit world?
05:18:02 <merijn> dons: Yeah, the title was enough to find it. But stupidly enough I never saved that besides the link
05:18:40 <Xandaros> Is it using dynamic libs as plugins?
05:18:46 <merijn> At any rate, if it wasn't the one I had, it certainly looks like the paper I wanted. Thanks :)
05:19:27 <dons> there's a sequel to that one called "dynamic applications from the ground up" about hot swapping architectures
05:20:10 <merijn> ok cool, I'll have a look
05:22:44 <dons> so .... i'm trying to hire 3 more devs to join a haskell team of 10 split between london and singapore. AMA :)
05:22:54 * hackagebot fclabels 2.0.2.4 - First class accessor labels implemented as lenses.  https://hackage.haskell.org/package/fclabels-2.0.2.4 (AdamBergmark)
05:24:34 <m1dnight_> Say I have a bunch of functions with type `State Context T` and I have changed the function that used those  from `State Context T` to `StateT Context (Either String) T`. Can I still call those functions?
05:24:56 <m1dnight_> with `lift` it doesnt work but iirc that is used to get into the either monad, so the state monad should still be usable.
05:25:07 <merijn> m1dnight_: Grab Tekmo's mmorph package
05:25:10 <merijn> m1dnight_: You want "hoist"
05:25:33 <merijn> @hackage mmorph
05:25:34 <lambdabot> http://hackage.haskell.org/package/mmorph
05:25:41 <m1dnight_> (So without a package it is impossible?)
05:25:54 <merijn> m1dnight_: It's not impossible, you could reimplement hoist yourself
05:26:12 <m1dnight_> hah, well yes :)
05:26:15 <m1dnight_> Cool thanks merijn
05:26:17 <m1dnight_> I will check it out
05:26:41 <merijn> m1dnight_: But at that point you might as yourself "why am I inventing what someone else has already invented and tested more?" :)
05:26:46 <merijn> s/as/ask
05:26:57 <Xandaros>  /2
05:27:02 <Xandaros> nvm
05:27:04 <m1dnight_> That is true. But I prefer to take babysteps :D
05:27:10 <m1dnight_> Im going to try it out. The docs seems to be pending still
05:27:26 <merijn> m1dnight_: Check a slightly older version
05:27:43 <merijn> 1.0.4 has docs built
05:28:07 * hackagebot swagger2 1.2 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-1.2 (NickolayKudasov)
05:29:35 <tero-> stack build says "No GHC found, expected version 7.10.3... Try running stack setup" I run stack setup and it starts to download ghc-7.10.2 . the resolver is lts-4.2 . any tips?
05:29:41 <merijn> m1dnight_: Some notes: "State s a" is just an alias for "StateT s Identity a", so "hoist generalize" is what you want
05:29:54 <Xandaros> What repercussions are there for having lots and lots of dependencies? Does it compile the whole library, even if you only use one module? What about dead code in the binary?
05:30:52 <merijn> Xandaros: That's up to the linker, you can use '-fsplit-objects" if you want smaller binaries, but I would recommend not to care too much
05:31:58 <Xandaros> In general, I don't care. But being in a project that works with embedded devices (albeit not using haskell), I do think about binary size quite often lately.
05:32:08 <Xandaros> In any case, I like to know what actually happens
05:32:10 <merijn> Xandaros: All sane OSes use lazy loading for executables (so at least linux, BSD, windows, OSX, but probably anything else you care about too), so the only cost of large executables is 1) disk space and 2) virtual address space. On modern machines you don't really care about either
05:32:42 <Xandaros> My main concern is compile time, really
05:33:07 <Xandaros> Though dependencies have the benefit of only being compiled once... in a perfect world
05:33:08 <merijn> Xandaros: AFAIK -fsplit-objects actually increases compile time
05:36:52 <Xandaros> I wonder if you can create a haskell "mode" (Thinking along the lines of -XStrict or -XSafe here) which allows tiny binaries
05:37:18 <merijn> Xandaros: Theoretically? Yes. But it's a lot of engineering work and no one cares enough to invest that work
05:37:26 <KaneTW> p much
05:39:26 <Xandaros> btw, it only includes modules in the final binary that I actually use - not whole packages, right?
05:45:14 <tero-> no one else affected by stack installing ghc-7.10.2 instead of ghc-7.10.3 with lts-4.2?
05:49:10 <tero-> ah, I had an outdated version of stack. with fpcomplete ppa's version it works 
05:53:08 <coconut> any haskell tools to convert epub or mobi to txt ?
05:53:33 <coconut> i only know calibre
05:53:37 <coconut> which is very slow
05:55:09 <hodapp> well, EPUB is just HTML
05:55:36 <tdammers> pandoc
05:56:06 <hodapp> yeah, was just looking to see if Pandoc reads EPUB and I found Text.Pandoc.Readers.EPUB
05:56:06 <tdammers> not sure if that can *read* EPUB though, but then again, EPUB is basically HTML in an archive, so it shouldn't be hard to implement
05:57:26 <sparr> how does approxRational work? I mean, what's the algorithm behind it?
05:58:50 <merijn> sparr: Have you tried going over the source? :)
05:59:00 <merijn> sparr: It looks fairly simple at first glance
06:01:20 <Nuxular> This definition of Bellman's Principle of Optimality seems a little vacuous to me. Any thoughts? https://en.wikipedia.org/wiki/Bellman_equation
06:01:50 <Nuxular> optimal (x:xs) = optimal xs
06:02:53 <Nuxular> does it expect you to at some point decide on whether a policy is optimal via other means?
06:03:08 * hackagebot cabal-debian 4.32 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.32 (DavidFox)
06:03:55 <merijn> Nuxular: It seems to give an inductive definition of optimality to me
06:04:05 <sparr> merijn: I might not know where to look :(
06:04:18 <Nuxular> merijn: optimal (x:xs) = optimal xs
06:04:20 <merijn> sparr: There's a source link on the right side of the docs that hotlinks the source :)
06:04:41 <merijn> Nuxular: Where does that code come from?
06:04:57 <merijn> Nuxular: Note that there's a distinction between policy and decisions
06:04:59 <Nuxular> that's my attempt at condensing the statement into haskell code
06:05:23 <merijn> Nuxular: It's saying a "policy" (set of decisions) is optimal, if, given some initial state and initial decission all following decisions are optimal
06:05:40 <Nuxular> yes
06:05:41 <merijn> Which, to me, sounds like the induction step of an inductive proof
06:05:50 <Nuxular> but where is the base case?
06:06:13 <Nuxular> optimal x = True / optimal x = False
06:06:18 <merijn> Nuxular: Not in that principle. Although if your basecase is imply an initial state with no step then it trivially holds
06:06:38 <merijn> A set of zero decisions seems vacuously optimal to me
06:07:09 <Nuxular> so as I said, are we to decide on optimality using an unstated rule? (such as the one you offer)
06:07:17 <Nuxular> my point was that this was unstated
06:07:37 <merijn> You need a decision to decide whether a set of rule applications is optimal anyway
06:08:09 <Nuxular> nowhere in the principle is that stated
06:11:59 <Nuxular> furthermore, even if that is an unstated part of the principle (that a policy of no/one decision is optimal) then the principle simply reduces to "all policies that consist of finite (decision,state) sequences are optimal" which is still pretty useless
06:12:00 <statusfailed> Nuxular: not sure if I'm following, but isn't that what "V" is?
06:12:44 <statusfailed> oh whoops misread
06:13:33 <ner0x652> hi! :)
06:14:05 <Nuxular> if on the other hand the base case depends on some function then that implies that the optimality of the policy is the optimality of it's final step
06:14:12 <ner0x652> I am a Haskell beginner, started with write yourself a scheme parser in 48 hours in haskell
06:14:36 <ner0x652> I consider it a good tutorial, that tries to teach the hard way
06:14:52 <ner0x652> I would like to know, what is your opinion about it?
06:15:03 <statusfailed> ner0x652: I am a big fan
06:15:13 <statusfailed> I think it's good
06:15:18 <merijn> Nuxular: No, it doesn't
06:15:34 <ner0x652> Also, what do you think about books like: Learn you a Haskell for a great good or Real World Haskell
06:15:38 <merijn> Nuxular: You are ignoring the fact that there is a predicate/oracle that says if a given decision is optimal
06:16:21 <merijn> Nuxular: It's saying that given a predicate on whether a decision is optimal and then describes induction using that predicate
06:16:52 <Nuxular> merijn, where in the principle is the 'optimality of a decision' mentioned?
06:17:17 <dramforever> ner0x652: Learn You a Haskell teaches the basics rather clearly, and Real World Haskell has chapters on (rather) important stuff like Software Transaction Memory, Networking and Profiling
06:17:37 <Nuxular> the only things referred to as optimal are policies
06:18:10 <Nuxular> (the thing the principle is defining)
06:18:48 <merijn> Nuxular: Maybe I read it wrong...personally I would avoid wikipedia for reading mathematical definitions, in my experience they're always terrible
06:20:04 <Nuxular> that excerpt appears to be quoted from a book authored by Bellman
06:21:31 <ner0x652> dramforever: so it would be better to learn from LYH, then RWH?
06:22:12 <phaazon> hey
06:22:21 <phaazon> what is the extension for postfix operators?
06:22:24 <phaazon> like, i++
06:22:26 <phaazon> for instance
06:22:32 <phaazon> it could be handy for my case :)
06:22:34 <dramforever> ner0x652: um...you see, there are chapters on the basics in RWH too
06:22:50 <phaazon> (same question for prefix actually)
06:22:55 <Xandaros> ner0x652: Opinions differ, but that would kinda be my suggestion. RWH has some nice practice problems, though
06:22:59 <srhb> phaazon: Does that even exist?
06:23:03 <dramforever> They should be of decent quality, but I'm not exactly sure
06:23:09 * hackagebot cabal-debian 4.32.1 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.32.1 (DavidFox)
06:23:26 <srhb> phaazon: Apparently XPostfixOperators
06:23:35 <phaazon> nice, thanks
06:23:40 <dramforever> > let (~|) = (+5) in (16 ~|)
06:23:41 <lambdabot>  21
06:23:52 <ner0x652> understood, thanks
06:26:02 <phaazon> hm actually
06:26:04 <phaazon> that’s stupid
06:26:17 <phaazon> ++ is already taken for list concatenation
06:28:09 * hackagebot cabal-debian 4.32.2 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.32.2 (DavidFox)
06:35:01 <statusfailed> Can anybody help me write this code better? http://lpaste.net/150126
06:35:08 <statusfailed> I want to avoid writing out all the cases for each node
06:35:17 <statusfailed> because it's really tedious with a large datatype
06:36:02 <statusfailed> and I have about 3 different functions like "mapVars", so when I change "ExprF", I have to change all of them
06:36:52 <fizruk> statusfailed: not sure what you want, but try removing VarF from ExprF and having type Expr = Free ExprF instead of Fix
06:37:39 <fizruk> statusfailed: you would still need to write interpreters for each node at some point, but you can get a lot of useful staff from Free
06:38:28 <statusfailed> fizruk: well I want the recursion schemes, 'cata' is useful for doing 'eval'
06:38:43 <fizruk> statusfailed: ah, sorry, I (somehow) missed definitions for add/mul/lit
06:39:10 <statusfailed> ah no worries, they were a bit hidden there :-)
06:39:12 <fizruk> statusfailed: well, since you have variables, why not set them apart?
06:39:39 <statusfailed> fizruk: what do you mean?
06:42:15 <fizruk> statusfailed: well, variables are sort of "additional" thing to the expressions, evaluating/substituting variables does not actually depend on the type of expression
06:42:15 <frerich> statusfailed: Your 'cata' function seems to have a strange type. Shouldn't it be something like 'cata :: (var -> b) -> (Integer -> b) -> (r -> r -> b) -> (r -> r -> b) -> ExprF var r -> b'? With that, you could define 'mapVars f = cata (VarF . f) LitF AddF MulF', no? I left out the 'Fix' part here.
06:42:58 <fizruk> statusfailed: so you can just "add them later", Free is (for your case) essentially a Fix with automatically added variables
06:43:03 <synergistics> Anyone who uses vim for haskell, does autoindent register wit haskell files for you?
06:43:10 <synergistics> with*
06:43:16 <jvcakg> Greetings
06:44:51 <fizruk> statusfailed: the cata analogue in free would be iter
06:44:57 <statusfailed> fizruk: I'm just following this: http://jtobin.ca/practical-recursion-schemes/
06:45:35 <statusfailed> I think the "Fix" representation gives you cata for free
06:45:39 <fizruk> statusfailed: anyway, I was answering the wrong question, let me take another look at your code
06:45:41 <statusfailed> which is why I wanted to try recursin-schemes
06:45:47 <statusfailed> no worries, thanks for having a look :-)
06:47:06 <fizruk> statusfailed: yes, Free is just a bit more general than Fix in that Free f Void ~ Fix f  (double-check me)
06:47:31 <merijn> fizruk: Yes, looks right to me
06:47:32 <merijn> FYI
06:47:37 <jvcakg> Hi anyone wants to welcome me
06:47:58 <merijn> I tried building a Free based AST for a while, in the end it was a pain and I followed edwardk's advice and just handwrote a straightforward one
06:48:57 <fizruk> statusfailed: so mapVars is actually variable substitution
06:49:57 <statusfailed> mapVars is just supposed to apply a function to all the "Var" nodes, is that what you mean?
06:51:00 <fizruk> statusfailed: newtype Expr var = Expr (Fix (ExprF var)) deriving (Functor)
06:51:14 <fizruk> statusfailed: mapVars = fmap
06:51:49 <fizruk> statusfailed: but you probably want to substitute variables with subexpressions at some point?
06:52:18 <fizruk> statusfailed: i.e. substitute :: (var1 -> Expr var2) -> Expr var 1 -> Expr var2
06:52:30 <fizruk> statusfailed: you might guess what that looks like :)
06:52:48 <fizruk> (especially if you switch arguments)
06:52:58 <statusfailed> fizruk: not really actually, heh
06:53:03 <fizruk> :t (>>=)
06:53:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:53:08 <statusfailed> but i'm interested nonetheless ^^
06:54:09 <fizruk> statusfailed: ok, so does the Functor solution work for you?
06:54:33 <statusfailed> fizruk: Trying to figure it out actually
06:54:45 <statusfailed> gimme a couple mins :) (thanks!)
06:55:45 <fizruk> you might need {-# LANGUAGE DeriveFunctor #-}
06:55:59 <statusfailed> Got that, I still get "No instance for (Functor Fix)"
06:56:21 <fizruk> ah, right
06:56:46 <fizruk> hmm
06:58:11 * hackagebot set-cover 0.0.8 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  https://hackage.haskell.org/package/set-cover-0.0.8 (HenningThielemann)
06:58:13 * hackagebot yaml 0.8.15.3 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.15.3 (MichaelSnoyman)
06:58:19 <roelof> Hello, I have a Map where I need to pull out a record. I can use Map.lookup but then I see a maybe account.
06:58:31 <statusfailed> fizruk: Hmm. Basically I want to convert between representations of variables, e.g. "Expr Int" and "Expr String". I'm not sure how I can "fmap" an "Expr String", because it has kind *
06:58:36 <roelof> That one I cannot use as a argument for another function
06:58:49 <roelof> which function can I use the best then ?
06:59:11 <fizruk> statusfailed: fmap :: (a -> b) -> Expr a -> Expr b, perfectly fine
06:59:15 <boj> roelof: you need to match the Maybe, possibly with a case
06:59:30 <fizruk> statusfailed: GHC is just not able to derive instance
06:59:49 <fizruk> statusfailed: the definition of fmap would be exactly your mapVars
07:00:21 <Freundlich> roelof: A map might not contain a value for a given key. The Maybe forces you to specify what happens in that case.
07:00:46 <tdammers> the Maybe is required, because the only other possible implementation would be a partial one
07:00:49 <frerich> roelof: A 'case' would be a good start, e.g. 'case M.lookup "myKey" myMap of Just value -> doSomethingWith value; Nothing -> handleError'
07:00:52 <roelof> Freundlich:  I know the key is in the Map. I checked that before it 
07:00:56 <tdammers> (i.e., looking up non-existent keys would result in bottom)
07:01:20 <Freundlich> roelof: If you do that anyway, you might as well use lookup directly.
07:01:28 <tdammers> fromMaybe (error "This Can Never Happen™") $ lookup keyKnownToExist map
07:01:34 <tdammers> :P
07:01:52 <fizruk> s/Can/Should/
07:02:17 <boj> roelof: while you the user may know, the code doesn't pretend it does.  you have to handle both cases
07:03:11 <tdammers> seriously, I second the "why not use lookup in the first place" sentiment
07:04:40 <statusfailed> fizruk: so I want a functor instance of "Fix 
07:05:00 <fizruk> statusfailed: well, yes
07:05:02 <statusfailed> er, confused
07:05:26 <fizruk> statusfailed: not Fix, but Expr (which is Fix (ExprF var))
07:05:27 <roelof> Freundlich:  I did this : (fromMaybe (Map.lookup accountToDeposit accts)))    but then I see this error message: http://lpaste.net/150128
07:06:01 <fizruk> statusfailed: but I now don't think it's possible to get GHC to do that automatically
07:07:00 <statusfailed> fizruk: I get kind errors even trying to write it manually
07:07:12 <statusfailed> no wait
07:07:15 <statusfailed> hold that thought
07:07:15 <boj> roelof: you aren't supplying the right parameters
07:07:40 <boj> :t fromMaybe
07:07:41 <lambdabot> a -> Maybe a -> a
07:07:56 <fizruk> statusfailed: don't forget Expr should be a newtype (not merely type alias), and you're writing instance Functor Expr where fmap = mapVars
07:09:30 <derekv2> I started playing with lenses just to get some updaters without using the record syntax.  I noticed something right away that seems like it might get annoying:  Since the lenses are first class and not "scoped" to the object they operate on, if I create something like person^.name, 'name' is now out there in my namespace
07:09:59 <derekv2> and doing something like person^.personName seems inane
07:10:06 <Freundlich> roelof: fromMaybe is used if you have a default value in case of Nothing.
07:10:28 <boj> derekv2: you are still working with a record :)
07:10:44 <statusfailed> fizruk: yeah, i'm having trouble writing the 'recursive' bits of fmap (i.e. for nodes AddF and MulF)
07:10:57 <derekv2> boj: I know but I didn't like the way record updates worked
07:11:15 <roelof> Freundlich:  oke, then I will try another way. Im trying to get a value out of a record. 
07:11:16 <merijn> derekv2: What didn't you like about it?
07:11:23 <fizruk> statusfailed: did you try just writing fmap = mapVars?
07:11:38 <merijn> derekv2: Unless you're using nested records there's not much of a problem, I think?
07:11:49 <derekv2> merijn: too verbose, I thought 
07:12:29 <derekv2> merijn: If I use them inline, its a lot of noise... I'd like to the reader to be able to focus on the intent of the function without looking at a bunch of record update syntax nested in lambdas
07:13:03 <derekv2> merijn: So the first thing I did was to extract them to my own functions, this was simple but after like 4 of them I decided it wasn't something I wanted to spend time doing myself.
07:13:12 <derekv2> Boilerplate doesn't become haskell =]
07:13:48 <derekv2> So I googled around and found that people use lens for this, and I tried it, and I'm pretty OK with it. 
07:14:18 <derekv2> I'm just wondering if there's any discussion around the naming issue, I tried a google search and found nothing so far.
07:15:38 <boj> derekv2: you could look into makeFields
07:16:25 <statusfailed> fizruk: yeah, but the newtype has got a constructor everywhere and I'm trying to unpack it
07:16:45 <statusfailed> I'm not sure how that's supposed to work with "cata"
07:16:47 <statusfailed> I don't think it can?
07:17:07 <fizruk> statusfailed: which constructor are you talking about?
07:17:15 <fizruk> oh
07:17:17 <statusfailed> the "Expr" constructor
07:17:29 <fizruk> newtype Expr var = Expr (Fix (ExprF var))
07:17:54 <fizruk> instance Functor Expr where fmap f (Expr e) = Expr (mapVars f e)
07:18:08 <fizruk> I forgot than you need to unwrap/wrap things
07:18:15 <derekv2> boj: I'm using those, that solved the boilerplate problem =]
07:18:30 <statusfailed> fizruk: ahhh, whoops
07:18:36 <statusfailed> Yeah I'd forgot in a couple places
07:18:49 <derekv2> meh, I'm just forseeing an issue.  I'll wait until it actually is one and then look for solutions.
07:19:06 <statusfailed> so that works
07:20:08 <statusfailed> but I still have the issue that I can't write an "otherwise" case when using "cata" :\ I guess that's impossible?
07:21:13 <boj> derekv2: sorry, i may have misunderstood you then
07:23:08 <mnoonan> statusfailed: why can't you use otherwise?
07:24:33 <mnoonan> e.g. alg (VarF v) = var (f v), alg x = x?
07:26:27 <merijn> mnoonan: Wrong type, he'd have to safe/unsafeCoerce, I think?
07:27:19 <statusfailed> mnoonan: Yeah, 'x' has type ExprF var1 (Fix (ExprF var2)) instead of ExprF var2 (Fix (ExprF var2))
07:27:41 <mnoonan> ah, sorry. I think I didn't read enough context.
07:27:50 <derekv2> boj: no problem, thanks
07:27:52 <statusfailed> no it's OK, it's nearly correct :D
07:27:56 <statusfailed> *so close* :D
07:28:18 <mnoonan> I don't know if it would help, but I recently wrote a similar thing for a project.
07:28:33 <mnoonan> https://github.com/matt-noonan/FractalStream/blob/master/src/Lang/Expr.hs for the current Expr class and a bunch of utility functions
07:28:50 <mnoonan> https://github.com/matt-noonan/FractalStream/blob/master/src/Lang/Expr/Transform.hs for some transformations implemented as catas
07:39:37 <fizruk> statusfailed: I think you can write an otherwise... if you split your ExprF into parts
07:41:57 <fizruk> statusfailed: data WithVarF var r = VarF var | ExprF (ExprF r)data ExprF r = LitF Integer | AddF r r | MulF r r
07:42:38 <fizruk> statusfailed: newtype Expr var = Expr (Fix (WithVar var))
07:43:39 <fizruk> statusfailed: alg (VarF v) = var (f v); alg (ExprF e) = expr e where expr = Fix . ExprF
07:44:39 <fizruk> statusfailed: again, Fix (WithVarF var) ~ Free ExprF var
07:49:43 <humanoyd> Is it considered good practice to include tests in cabal's `extra-source-files` field when uploading to hackage?
07:49:54 <fizruk> statusfailed: does this make sense to you? :)
07:51:10 <fizruk> humanoyd: I think test-suite sources are included in package distro, why would you need to use extra-source-files?
07:51:32 <fizruk> humanoyd: e.g. here: http://hackage.haskell.org/package/swagger2-1.2/src/
07:52:41 <fizruk> humanoyd: test source files are only mentioned in test-suite sections in .cabal: https://github.com/GetShopTV/swagger2/blob/master/swagger2.cabal#L49-L76
07:53:13 * hackagebot stackage-curator 0.12.0 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.12.0 (MichaelSnoyman)
07:55:39 <humanoyd> fizruk: Thanks!
08:03:44 <statusfailed> fizruk: hmm I think so
08:04:14 <julianleviston> There’s no easy way to alias function names in Haskell is there?
08:04:26 <julianleviston> other than `type` ?
08:04:30 <merijn> julianleviston: "foo = bar"?
08:04:33 <statusfailed> julianleviston: foo = bar?
08:04:34 <statusfailed> dwerp
08:04:39 <statusfailed> too slow :(
08:04:42 <julianleviston> yeah I mean other than that.
08:04:43 <julianleviston> sorry
08:04:55 <statusfailed> julianleviston: hm, what's wrong with that?
08:05:00 <julianleviston> I don’t mean aliasing, I mean importing with a different name so as not to pollute the namespace
08:05:03 <statusfailed> ooh
08:05:04 <julianleviston> statusfailed: ^
08:05:22 <statusfailed> You can do "import qualified Foo.Bar as FooBar", then use "FooBar.foo"
08:05:26 <julianleviston> I think qualifiation is the only thing.
08:05:26 <statusfailed> but I think that's it
08:05:29 <statusfailed> yeah
08:05:31 <julianleviston> yep.
08:05:34 <julianleviston> cool.
08:05:38 <julianleviston> thanks.
08:06:31 <statusfailed> fizruk: Wouldn't that make it impossible to nest a VarF under an ExprF? For example to add two vars
08:06:37 <statusfailed> Well probably not, maybe I should just try it ^^
08:08:14 * hackagebot cheapskate-terminal 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/cheapskate-terminal-0.1.0.0 (yamadapc)
08:09:40 <statusfailed> fizruk: either way, thanks a lot for your help!
08:13:15 * hackagebot binary-search 0.9 - Binary and exponential searches  https://hackage.haskell.org/package/binary-search-0.9 (TakayukiMuranushi)
08:16:43 <fizruk> statusfailed: note that you're doing (Fix (WithVarF var)), not (Fix ExprF), so you actually *can* use variables in any subexpression
08:21:47 <SX> Hello! What's the fastest container for appends?
08:22:28 <SX> I'm generating a lot of data one-by-one and I need to store it in list-like container
08:22:35 <SX> Mutable is fine
08:22:54 <Xandaros> If you need to append a lot of singulat things, you can prepend them to a list and reverse at the end
08:23:11 <SX> Is it the fastest way?
08:23:37 <Xandaros> cons is O(1) and reverse is O(n). Not sure if you can do it faster
08:23:39 <sdfx4> With cassava what do people do for decoding CSVs with large numbers of columns (hundreds to thousands)?
08:24:59 <jmcarthur> SX: It depends on what you need to do with it other than appending.
08:25:26 <sdfx4> jmcarthur doing various statistics, machine learning, visualization
08:25:39 <SX> jmcarthur: Serialize, that's all
08:26:00 <SX> So serial access
08:26:19 <jmcarthur> SX: So you're just going to accumulate all this into one list and then serialize it all at once at the end?
08:26:29 <SX> I don't know the amount of elements, so Vector is not a good option..
08:26:36 <SX> Yes
08:28:01 <jmcarthur> SX: For that purpose, I think Xandaros's suggestion is fine. Difference lists (see the dlist package) might be reasonable for you, too. I doubt there will be a significant difference in performance.
08:28:40 <zaynmalik99> guys
08:28:51 <zaynmalik99> i need help
08:28:58 <jmcarthur> sdfx4: I don't mean to ignore you, but my question wasn't meant for you, and I don't know how to answer your question.
08:30:34 <SX> jmcarthur & Xandaros: ok, thank you.
08:31:04 <sdfx4> jmcarthur no worries i figured
08:33:30 <SX> If I have Producer (Pipes) for my data generator, is it possible to write Consumer, which accumulates data in list?
08:35:33 <Fuuzetsu> @pl any id
08:35:33 <lambdabot> or
08:42:25 <hexagoxel> i cannot prefix an infix operator parameter with _ somehow to get the effect of -fno-warn-unused-binds, can i?
08:43:34 <byorgey> hexagoxel: interesting, not that I know of.  I think your only option is to just give it an alphanumeric name prefixed with _
08:44:43 <hexagoxel> i'll use _ then, i then; inventing something else will defeat the purpose of giving it a name.
08:45:16 <hexagoxel> (words.. too many words)
08:45:46 <zaynmalik99> hi guys my fb is been hacked
08:45:50 <zaynmalik99> i need to recover it
08:45:53 <zaynmalik99> please help
08:46:04 <monochrom> my sympathy. but off-topic.
08:46:12 <jmcarthur> zaynmalik99: This is definitely not the right place. Sorry.
08:46:13 <julianleviston> zaynmalik99: wrong channel. this is for programming.
08:46:22 <zaynmalik99> do u know any channel
08:46:26 <zaynmalik99> i can get help
08:46:34 <monochrom> I know fb has tech support contacts.
08:46:47 <zaynmalik99> can i have it,please
08:47:04 <monochrom> somewhere on fb website, no?
08:47:11 <zaynmalik99> mmm
08:47:44 <zaynmalik99> i have already creaetd a case, but haved got any reply so far
08:47:54 <zaynmalik99> *haven't
08:47:55 <sdfx4> paging simon marlow
08:47:57 <jmcarthur> http://lmgtfy.com/?q=facebook+account+hacked
08:48:38 <sdfx4> jon coens
08:50:08 <zaynmalik99> thanks buye
09:08:38 * joeyh grumbles about the different buffering modes that can be in effect for stdout, depending on what it's connected to
09:09:03 <joeyh> source of bugs in haskell that I can't remember hitting in any other language
09:13:21 * hackagebot MonadRandom 0.4.2.2 - Random-number generation monad.  https://hackage.haskell.org/package/MonadRandom-0.4.2.2 (BrentYorgey)
09:13:29 <bitemyapp> joeyh: dynlangs usually do the right thing by default
09:13:34 <bitemyapp> joeyh: but I've seen that bite people in C++
09:14:18 <playIO> hi
09:15:12 <monochrom> "the right thing by default" is precisely the differing buffering modes depending on what stdout is connected to
09:15:48 <monochrom> it is also what C does. even SML.
09:18:42 <bergmark> is there a way to turn off the warning for using OverlappingInstances in 7.10?
09:21:29 <hexagoxel> does this RULE(S) make any sense? https://github.com/lspitzner/pqueue/blob/master/Data/PQueue/Min.hs#L270
09:24:41 <m_ryan> hi can anyone help me with this error. http://lpaste.net/150134
09:25:07 <hexagoxel> or: what could the purpose of such an "identity" rule be? enforce inlining?
09:25:35 <joeyh> reminds me, ghc sometime outputs large error messages with NoBuffering. I can tell because 1 char at a time makes ssh over slow links really crawl
09:27:42 <bergmark> m_ryan: `runDb $ insert ...' returns a Key, but mapM_ excepts `()' as the return value, so you can throw the value e.g. with `void'
09:28:43 <cads> Ahh.. that moment when "a monad is a monoid object in the endofunctor category" actually becomes your go-to for remembering the monad identities.
09:28:53 <m_ryan> can you give me example code for that?
09:29:04 <m_ryan> bergmark: can you give me example code for that?
09:29:47 <Gurkenglas> :t mapM_ -- Since when? I mean, I approve with all my heart but doesnt look like it
09:29:49 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
09:30:30 <monochrom> @type mapM_
09:30:32 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
09:30:41 <bergmark> huh, i was sure about that...
09:31:03 <monochrom> I think we need to know the types of runDB and insert. verbatim.
09:31:35 <Gurkenglas> Also I would recommend making AdvertisementImageAllocation a record with named fields and a default value with all initialized to Nothing
09:32:12 <Gurkenglas> (Assuming those are optional configuration parameters that all do entirely different things)
09:33:22 * hackagebot process-extras 0.3.3.7 - Process extras  https://hackage.haskell.org/package/process-extras-0.3.3.7 (DavidFox)
09:33:24 * hackagebot twitch 0.1.7.0 - A high level file watcher DSL  https://hackage.haskell.org/package/twitch-0.1.7.0 (AndreasSchacker)
09:33:30 <bergmark> oh i was thinking about when and unless
09:33:35 <bergmark> @type when
09:33:36 <monochrom> but at the end I suspect we need to know the surrounding code. perhaps the surrounding code is the one inflicting a non-() type
09:33:37 <lambdabot> Applicative f => Bool -> f () -> f ()
09:33:59 <m_ryan> monochrom: runDb $ insert the id of the data.
09:34:00 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
09:34:15 <monochrom> that is not a type.
09:38:30 * hackagebot th-lift 0.7.6 - Derive Template Haskell's Lift class for datatypes.  https://hackage.haskell.org/package/th-lift-0.7.6 (MathieuBoespflug)
09:42:15 <Gurkenglas> How nice would it be if there was a way to tell ghc to put every token on its own line (with proper indentation) and comment each token with the type it inferred for it, especially when it couldn't match something
09:44:26 <monochrom> it is nice only half of the time.
09:44:46 <Gurkenglas> So, like, make it on-demand
09:44:47 <monochrom> the other half of the time it is as bad as g++ error message verbosity
09:46:11 <SX> Guys, how to accumulate output of the Producer with Pipes?
09:46:56 <quchen_> SX: fold?
09:48:54 <quchen_> sum = fold (+) 0 id
09:48:59 <quchen_> sum :: (Monad m, Num a) => Producer a m () -> m a
09:53:51 * cads is reading about how to use monads to generalize David Spivak's idea of categories as database schema
09:55:33 <cads> he's using it to add various versions of nulls to these databases, and generalize the database to take values like lists of data or stuff like markov chains
09:55:36 <cads> kinda neat!
09:55:56 <cads> I was wondering if there are haskell libraries that base off of spivak's work, I've already found this: https://github.com/tomjaguarpaw/haskell-opaleye
09:56:40 <cads> The paper is this, "Kleisli Database Instances", 2012. http://arxiv.org/pdf/1209.1011v1.pdf
09:58:46 * hackagebot managed 1.0.2 - A monad for managed values  https://hackage.haskell.org/package/managed-1.0.2 (GabrielGonzalez)
09:58:49 <jmcarthur> SX: A consumer can accumulate it, but won't be able to return it, because the consumer won't know when the producer is "done". You will need to write a function that directly transforms the producer into a list. See Pipes.Prelude.toList, for an example of it (or just use it, of course, if it has the type you need).
10:00:25 <jmcarthur> SX: The implementation of that function is kind of low level. You can avoid needing the internal representation of a pipe by using Pipes.next instead of pattern matching directly.
10:00:55 <SX> jmcarthur: isn't Pipes.Prelude.fold enough?
10:01:52 <SX> I just need to wrap Producer to return accumulated value instead of yielding it one-by-one
10:01:59 <jmcarthur> SX: Sure. I wasn't saying you have to convert to a list first. I was just using toList as an example of the pattern you need if you need to accumulating in some custom way.
10:02:32 <jmcarthur> SX: Pipes.Prelude.fold is great as long as it is sufficient for your needs.
10:03:31 <SX> Ok, thanks! Btw, I also need some fast way to concat a list to list
10:03:52 <SX> [] ++ [] is slow, if I remember correctly
10:03:59 <jmcarthur> I thought you already asked that question earlier?
10:04:21 <SX> Nope, I asked how to append item to list, not list to list
10:04:21 <jmcarthur> What do you need to do with the result?
10:04:34 <SX> Serialize =)
10:05:10 <jmcarthur> So you're just going to append a bunch of lists of variable size to each other and then consume the whole thing at once at the end, exactly one time?
10:06:13 <SX> Not exactly. I have a Producer that yields a list, I need to flatten accumulated result to a single list.
10:06:33 <SX> But yes, consume at one time at the end
10:06:54 <jmcarthur> Not sure I see the distinction between what I said and what you said.
10:07:29 <jmcarthur> If I had to guess, I'd say this sounds like a good use case for difference lists.
10:08:28 <SX> Erm, yeah, no difference, sorry.. Ok, I'll look at dlist, thanks!
10:15:05 <obadz> is "getSum . fold . map Sum" an efficient implementation or does the map add extra work?
10:15:31 <obadz> somehow f :: [Int] -> Int; f = getSum . fold . coerce doesn't seem to work because t0 (Sum Int) != [Int] ?!
10:17:11 <obadz> probably need some explicit casts and scoped type variables
10:17:23 <obadz> f :: [Int] -> Int; f = getSum . fold . (coerce :: [Int] -> [Sum Int]) this works
10:17:29 <obadz> but is it more efficient than the map version ?
10:18:14 <jgoux> Hi
10:19:09 <jgoux> Is there a mentoring program or something to help beginners improve their haskell skills ?
10:20:38 <sm> jgoux: there's #haskell-beginners, for one
10:21:23 <sm> (beginners often get help here too)
10:21:39 <jgoux> sm: ok, thank you
10:21:55 <sm> and did you see http://try.haskell.org ?
10:23:01 <jgoux> sm: Yes, I'm also reading http://haskellbook.com/
10:24:07 <sm> for exercises in the basic core language, project euler is nice
10:24:26 <jmcarthur> obadz: In general, that will be more efficient than the map version. In specific cases, perhaps even this one, there may be no difference. It depends on whether there are applicable rewrite rules.
10:24:53 <kadoban> I'm having trouble getting 'pango' built, I get "setup: The pkg-config package 'pangocairo' version >=1.10 is required but it could not be found." I have libpangocairo installed in my OS package manager, and if I look it says it's version 1.36.3 or something … kind of confused.
10:25:19 <obadz> jmcarthur: so best bet is to coerce and put the right type annotations?
10:25:31 <Gurkenglas> :t ala Sum foldMap -- obadz, if you want coerce so you dont need to write "Sum" twice
10:25:32 <lambdabot> (Num b, Foldable t) => t b -> b
10:25:36 <jmcarthur> obadz: Basically, I'm saying that using map instead of coerce is slower without optimizations, but optimizations can sometimes eliminate the extra cost.
10:26:07 <jmcarthur> obadz: I think the best thing to do depends on how important efficiency is.
10:26:51 <Gurkenglas> Oh wait it's for efficiency. Well surely ekmett did ala right in Lens
10:28:31 <jmcarthur> :t sum
10:28:32 <lambdabot> (Num a, Foldable t) => t a -> a
10:28:37 <ClaudiusMaximus> kadoban: you probably miss the development headers (package libpangocairo-dev or similar)
10:28:44 <jmcarthur> ^^ Is surely preferable to all other solutions given so far.
10:29:10 <obadz> jmcarthur: obviously, just trying to understand when to use coercions ;-)
10:29:18 <jmcarthur> Got it.
10:29:56 <obadz> sum is implemented using foldMap Sum
10:30:01 <obadz> so maybe that's not so inefficient
10:30:26 <jmcarthur> Coercions are best used when you cannot tolerate the cost of reconstructing a data structure just to transform something contained inside and you aren't confident that optimizations would eliminate it for you.
10:30:42 <jmcarthur> s/transform/change the type of/
10:30:52 <Taneb> Anyone know if there's a variant of Debug.Trace that writes to file?
10:31:43 <kadoban> ClaudiusMaximus: Hmm, thanks. I got confused because there was no libpangocairo-dev, but apparently there was libpango-dev
10:32:12 <jmcarthur> obadz: More importantly, sum is part of the Foldable type class, so might have a specialized implementation. In the case of list, the implementation is GHC.List.sum.
10:32:27 <obadz> Taneb: traceIO with some MVar ought to do it?
10:32:47 <obadz> Taneb: hmmm nevermind
10:33:14 <bergmark> traceIO does not take an IO argument, but Taneb how about unsafePerformIO & writeFile?
10:33:32 <obadz> yeah I don't know of anything other than unsafePerformIO here
10:34:11 <Taneb> bergmark, that's the best thing I can think of (other than redirecting output) but the person I was asking on behalf of actually wants something different, so it's OK
10:34:29 <bergmark> Taneb: fwiw Debug.Trace is implemented with unsafePerformIO
10:34:32 <jmcarthur> Taneb: You could just redirect stderr to a file in your shell.
10:34:46 <jmcarthur> Ah you said that.
10:34:48 <codedmart> I seem to end up with chains of case statements like this: https://gist.github.com/codedmart/ab884166cfc66c94c4f4. Just looking for others opinions on alternatives to refactor this.
10:35:22 <bergmark> codedmart: MaybeT or ExceptT, or both
10:38:52 <codedmart> bergmark sorry got disconnected. So you use ExceptT or MaybeT just for a chain of maybes?
10:42:01 <codedmart> Clearly my connection is bad I keep getting cut off.
10:43:25 <Leizer> hey guys, can anyone tell me how can I start this http://rosettacode.org/wiki/Tic-tac-toe#Haskell
10:43:33 <Leizer> what function do I need to use
10:44:54 <kadoban> Is there a concise way to sum up the difference between ErrorT and ExceptT? I don't really understand why the later is deprecated, or if there's behavior differences between them?
10:47:05 <codedmart> bergmark:Trying this a different way. So you use ExceptT or MaybeT just to clean up a chain of cases?
10:47:10 <kadoban> Err the other way around, the former is deprecated I guess.
10:47:12 <Gurkenglas> codedmart, https://gist.github.com/codedmart/ab884166cfc66c94c4f4
10:47:55 <codedmart> Gurkenglas: Awe I see. Thanks!
10:48:38 <codedmart> Gurkenglas: Is fromMaybeT part of a lib or did you write that real quick?
10:49:56 <Gurkenglas> I wrote that real quick, and its a shame its not in Control.Monad.Trans.Maybe. Also it was wrong and I fixed it.
10:49:57 <opqdonut> kadoban: I was wondering about the same thing actually. one thing I do see is that Except doesn't have the Error type class
10:50:46 <codedmart> Gurkenglas: Thanks!
10:51:24 <Gurkenglas> Hmm, wrong again.
10:51:33 <opqdonut> kadoban: see also https://mail.haskell.org/pipermail/haskell-cafe/2014-September/115992.html
10:51:36 <codedmart> Gurkenglas: I get the idea.
10:51:57 <Gurkenglas> (The wrong part is where I evaluate x whether or not y is Nothing)
10:52:22 <kadoban> opqdonut: Hmm, thanks … maybe I can find more starting there.
10:53:15 <opqdonut> kadoban: tell me if you find something!
10:53:26 <Gurkenglas> There, this should be right.
10:53:58 <kadoban> opqdonut: Hmm, yeah I guess those links don't really lead anywhere elucidating :-/ I wonder if maybe it's supposed to be just a drop-in replacement. Kind of sucks it's not mentioned anywhere.
10:54:06 <jmcarthur> kadoban, opqdonut: Wasn't the Error type class just overly restrictive?
10:55:23 <Leizer> hey guys, can anyone tell me how can I start this http://rosettacode.org/wiki/Tic-tac-toe#Haskell . I'm a beginner in Haskell 
10:55:38 <kadoban> jmcarthur: Sounds possible. I seem to be missing the difference though.
10:55:43 <opqdonut> kadoban: it's a drop-in replacement, or at least was for my code
10:55:57 <kadoban> opqdonut: Hmm, well that's good to know at least.
10:55:59 <opqdonut> jmcarthur: yeah, also it was required a bit inconsistently
10:56:36 <Gurkenglas> (Oh and you can factor out that return :D.)
10:56:46 <jmcarthur> kadoban: The difference is that Error requires your error type to be convertible to a String and also for there to be some default value, for some reason I don't remember.
10:57:49 <kadoban> jmcarthur: Oh okay, that kind of makes sense.
10:58:12 <jmcarthur> kadoban: ExceptT makes more sense to me because it's just a badly named (IMO) implementation of EitherT.
10:59:50 <kadoban> I'll try just running with it, thanks.
10:59:54 <Gurkenglas> (Which you can also use instead. https://hackage.haskell.org/package/either )
10:59:56 <ReinH> ExceptT is indeed the poorly named ErrorT replacement that removes the constraint.
10:59:58 <bennofs> jmcarthur: ExceptT also requires errors to have a default value for errors, since there must be a Monoid instance for the error type?
11:00:09 <jmcarthur> Leizer: If you build it instead of loading it in GHCi, you get an executable you can just run. If you load it in GHCi, you just need to use main.
11:00:19 <ReinH> The main advantage to using ExceptT over EitherT is that it is in transformers and mtl
11:00:21 <jmcarthur> bennofs: I don't think there is a Monoid constraint anywhere.
11:00:42 <ReinH> bennofs: There is no default error.
11:00:49 <bennofs> oh sorry
11:00:54 <jmcarthur> ReinH: There's a noMsg error.
11:01:08 <Leizer> when i load it GHCi and use main just the text prints and from there what ?
11:01:21 <bennofs> you're of course right. 
11:01:35 <ReinH> jmcarthur: where?
11:01:37 <Leizer> and what do you mean by build it :?
11:01:52 <jmcarthur> kadoban: I said the wrong thing earlier. Error doesn't require your type to be convertible to a String. It requires it to be convertible *from* a String.
11:01:54 <ReinH> fail is ExceptT . fail
11:02:13 <kadoban> jmcarthur: Ah right, I think I internally understood it the correct way anyway.
11:02:34 <ReinH> I think we're all saying the same thing :)
11:02:34 <jmcarthur> ReinH: In the Error class.
11:02:37 <jmcarthur> ReinH: https://hackage.haskell.org/package/transformers-0.5.0.0/docs/Control-Monad-Trans-Error.html
11:02:45 <ReinH> jmcarthur: Ah, yes, of course. I was talking about ExceptT
11:03:03 <jmcarthur> Ah.
11:03:06 <ReinH> As was bennofs, in fact, so...
11:03:07 <kadoban> I wonder why @unmtl doesn't seem to understand ExceptT
11:03:21 <jmcarthur> Oh, the confusion was on my part. Sorry.
11:03:21 <ReinH> kadoban: hasn't been updated, but you can use ErrorT instead
11:03:26 <ReinH> jmcarthur: <3
11:03:47 <ReinH> @unmtl ErrorT String m a
11:03:48 <lambdabot> m (Either String a)
11:08:04 <Leizer> jmcarthus: can you explain what you said? how do i build it? also if i use main i get the text printed but thats all.
11:11:36 <Gurkenglas> Cant resist refactoring further http://lpaste.net/3238231876044849152
11:14:07 <Xnuk> @pl f[]=0
11:14:07 <lambdabot> (line 1, column 5):
11:14:07 <lambdabot> unexpected "0"
11:14:07 <lambdabot> expecting operator
11:14:26 <Xnuk> @pl \[a] -> a
11:14:26 <lambdabot> (line 1, column 2):
11:14:26 <lambdabot> unexpected "["
11:14:26 <lambdabot> expecting pattern
11:17:12 <ReinH> Leizer: main expects command line arguments and prints a usage message if they are not given.
11:17:35 <ReinH> In ghci, you can set arguments for main using :set args foo bar
11:17:44 <ReinH> To build an executable, you would use ghc
11:18:09 <Gurkenglas> http://lpaste.net/3238231876044849152 pls help
11:18:47 <kadoban> O.o, well that's curious. GHCJS seems to not understand {-# ANN main ignore #-} so badly that it gives a parse error on the next line :-/ Is it me or is that kind of bizarre? Works fine in GHC
11:19:19 <ReinH> Leizer: if your file is named TicTacToe.hs, the simplest thing to do is ghc TicTacToe.hs, which will compile that file into an executable called TicTacToe, which can then be run with ./TicTacToe.
11:19:59 <ReinH> kadoban: weird, maybe ask in #ghcjs
11:20:31 <kadoban> Yeah, sounds like a plan.
11:21:22 <frerich> ReinH: I know you didn't sleep well the last few nights.
11:21:38 <frerich> ReinH: I have good news though, which hopefully calm your restless spirit.
11:22:30 <frerich> ReinH: https://github.com/stedolan/bf.sed/issues/1 was scheduled for 1.0.0-rc1-NEVER
11:27:01 <ReinH> frerich: amazing
11:27:38 <AndrewT> hi there
11:27:40 <Leizer> ReinH: OK, so i used ghc- 7.10.3 to open my tictactoe.hs file and it did create an tictactoe.exe file in my folder but when I run it it closes immediatly 
11:28:02 <Jinxit> Leizer: try running it with cmd
11:28:05 <AndrewT> it has been such a looooong time since i ever logged into mirc!!lol
11:28:24 <ReinH> Leizer: you have to pass it command line arguments
11:28:41 <ReinH> And it outputs its results to the command line
11:28:48 <ReinH> So you'll probably want to run it from the command line.
11:29:19 <GLM> I heard that a lot of the basic functionality of the lens library (getters and setters) was made significantly easier out of the box with GHC 8. Is there any truth to that?
11:30:39 <codedmart> Gurkenglas: Are you still working on that?
11:31:06 <Gurkenglas> Not right now
11:31:20 <Gurkenglas> As in I dont see another refactoring in there
11:31:56 <Leizer> ReinH: when i run it from cmd it still prints the text and i dont know what i'm supposed to do from there
11:32:06 <Gurkenglas> I could alaf the MaybeT out of the result too but MaybeT is pretty useful for doing fromMaybeT
11:32:37 <AndrewT> anyone up for chat?
11:32:56 <Gurkenglas> Oh wait no MaybeT needed because FailFatal has no side effects
11:32:58 <AndrewT> im 35yo Male from malaysia
11:33:49 <breadmonster> AndrewT: wrong chatroom.
11:34:06 <Ankhers> AndrewT: This is #haskell. It is meant to support conversation about the Haskell programming language. You may be interested in ##chat.
11:34:11 <AndrewT> which will be the correct chatroom?
11:34:18 <AndrewT> lol
11:34:19 <breadmonster> mniip: How on earth did you get a freenode developer cloak?
11:34:31 <kadoban> AndrewT: AOL, circa 1995?
11:34:39 <AndrewT> lol
11:34:54 <AndrewT> wow things have really changed around here
11:34:59 <mniip> it's a long story that involved a lot of perl
11:35:39 <kadoban> AndrewT: There's #haskell-blah if you really want that, though I'd think one of the general chatrooms on here would probably be better.
11:36:33 <AndrewT> ok
11:36:36 <AndrewT> going over 
11:36:58 <breadmonster> kadoban: I wonder how he found this chatroom.
11:37:17 <AndrewT> by luck...
11:37:54 <josgraha> +1 to `#haskell` being the most courteous room on freenode :) 
11:38:43 <Gurkenglas> codedmart, here's another :) http://lpaste.net/3238231876044849152
11:39:05 <Gurkenglas> ("deriving Wrapped" probably has to be replaced from the right Lens TH stuff)
11:40:40 <ReinH> iirc AndrewT has been trolling us for some time now
11:40:47 <ReinH> Unless I'm thinking of someone else
11:41:35 <ReinH> I must be thinking of someone else.
11:42:03 <obadz> I thought the was the Andrew monad transformer?
11:42:40 <Gurkenglas> (Note that all the stuff since what is already on https://gist.github.com/codedmart/ab884166cfc66c94c4f4 is less optimizing for readability and more optimizing for the score output by the neural net between my ears)
11:43:10 <codedmart> Gurkenglas: Not sure I understand that one as well yet, but really appreciate it so I can learn :)
11:43:13 <codedmart> Thanks!
11:45:49 <ReinH> I vastly prefer Gurkenglas's first refactor
11:47:20 <Gurkenglas> Naturally. http://lesswrong.com/lw/km6/why_the_tails_come_apart/ applies for the scores each of our neural nets output.
11:53:51 * hackagebot dixi 0.6.0.4 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6.0.4 (LiamOConnorDavis)
11:53:52 <refried_> are data and newtypes always at the top level?
11:54:52 <johnw> refried_: do you mean the keywords? or regular type declarations?
11:54:57 <jmcarthur> refried_: Yes, in Haskell2010, but the TypeFamilies extension also allows you to put them inside of type classes and instances.
11:55:16 <refried_> johnw : i don't know the difference
11:55:28 <jmcarthur> refried_: Well, it only allows data in type classes, but in instances it can be either data or newtype.
11:55:36 <johnw> refried_: as jmcarthur says, they can appear within a class declaration too, but there they mean something slightly different
11:55:53 <refried_> ah
11:56:27 <refried_> i didn't know that.  what do they mean in a class declaration?
11:57:32 <jmcarthur> refried_: It allows the representation to vary based on type arguments, similarly to how type classes allow values to vary depending on types.
11:57:57 <refried_> ok I think I understand — thanks
11:59:46 <jmcarthur> Leizer: You can build by running   ghc Main.hs
11:59:56 <jmcarthur> Leizer: Then you can run the executable by running   ./Main
12:00:43 <Leizer> that just prints the text
12:00:51 <Leizer> what do i need to input after that?
12:01:23 <jmcarthur> Leizer: It looks like the text is meant to tell you how to use it?
12:01:56 <jmcarthur> Leizer: It looks like it's telling you to run it like     ./Main <n>     where <n> is 0, 1, 2, or 3
12:02:40 <Leizer> if i write "main 2" or any of the numbers it gives an error
12:02:55 <jmcarthur> I'm talking about running the executable.
12:03:15 <jmcarthur> Leizer: This program is expecting command line arguments. I'm not sure how to supply command line arguments in GHCi.
12:03:28 <geekosaur> :main arg1 arg2 ...
12:03:34 <jmcarthur> Ah!
12:03:47 <jmcarthur> Leizer: If you want to run it in GHCi, try   :main 2
12:03:47 <geekosaur> or use System.Environment.withArgs 
12:04:04 <jmcarthur> Leizer: Although this is perhaps not the most informative way to start.
12:07:01 <Leizer> thanks everybody i  think i finally managed to start it ;x sorry for bothering you with something so simple
12:15:25 <dfeuer> That was a shock....
12:15:38 <dfeuer> (,,) a b   is *not* an instance of Functor.
12:17:06 <dfeuer> I think this must be a *mistake*.
12:17:15 <python476> hi there
12:17:22 <python476> any emacs + hugs user here ?
12:17:54 <python476> I was hoping to use haskell-mode with hugs, but naively setting `haskell-program-name` to hugs hans
12:17:56 <python476> hangs*
12:18:03 <mnoonan> dfeuer: I can fmap (a,b,) in 7.10.2
12:18:15 <kadoban> python476: You know hugs isn't a usual thing to use anymore, right?
12:18:17 <barrucadu> python476: hugs hasn't been updated in nearly a decade
12:18:24 <barrucadu> Is there a particular reason you need it?
12:18:25 <dfeuer> mno2, oh? Was it added between 7.10.1 and 7.10.2 or something?
12:18:41 <dfeuer> mnoonan, I mean.
12:18:54 <mnoonan> I don't know, just adding a data point. This is with -XTupleSections, for reference.
12:18:58 <enthropy> mnoonan: fmap (+1) (1 :: Int,3 :: Int, 3 :: Int) -- works for you?
12:19:06 <enthropy> doesn't here with 7.10.2
12:19:29 <dfeuer> mnoonan, hmm.... I just tried it in 7.10.2; doesn't work.
12:19:30 <python476> barrucadu: I can't stand installing a 1GB package to have a repl and a few libs
12:19:40 <python476> no other or more interesting reasons
12:19:40 <mnoonan> no, fmap ("hi",) [1..3] --> [("hi",1), ("hi", 2), ("hi", 3)]
12:19:56 <dfeuer> mnoonan, that's totally different.
12:20:13 <python476> to learn CPS, Monads etc Hugs can do. Also I understand your arguments
12:20:28 * geekosaur figured that was so as not to encourage people to overuse tuples...
12:20:29 <mnoonan> dfeuer: what do you mean? that's the fmap for (,,) a b
12:20:31 <enthropy> dfeuer: probably nobody has wanted that instance enough to get it added
12:20:42 <python476> so far I use emacs + hugs aside with manual reload, it proves frustrating when trying to toy with Monadic types (and failing)
12:20:58 <mnoonan> (er, with ("hi", "there",) anyway)
12:21:16 <dfeuer> mnoonan, no, it's not. The fmap for (,,) a b is   instance Functor ((,,) a b) where fmap f (a,b,c) = (a,b,f c)
12:21:22 <lyxia> (,,) a b the type, not the value
12:21:31 <jmcarthur> python476: http://i.imgur.com/5hNJsIW.jpg   and I wonder how much of a difference there is now that it's 2016
12:21:42 <mnoonan> whoops, I understand. sorry.
12:22:26 <dfeuer> enthropy, I imagine you're right; I was just doing a bit of stuff in boxes (trying not to neglect it quite so much) and when I reached for that instance it just wasn't there.
12:22:30 <python476> jmcarthur: there's no deep solid reason in my reaction, I just wanted to use something light to learn. Really 1GB *sigh*
12:23:31 <dons> ciao folks. if anyone's pondering one of the jobs i'm hiring for but isn't sure, i'm happy to answer questions (gmail or work email) https://donsbot.wordpress.com/2016/01/18/haskell-developer-roles-at-standard-chartered-london-singapore/
12:23:44 <jmcarthur> python476: I empathize with you, but it's pretty liberating to put a price tag on such concerns. :)
12:25:13 <python476> jmcarthur: one day I'll repackage GHC into a tutorial package to be as tiny as possible ~_~
12:28:30 <dfeuer> > (+1) <$> (1,2,3)
12:28:33 <lambdabot>      No instance for (Show t0)
12:28:33 <lambdabot>        arising from a use of ‘show_M357045971281059872624316’
12:28:33 <lambdabot>      The type variable ‘t0’ is ambiguous
12:28:45 <dfeuer> > (+1) <$> (1,2,3) :: (Int,Int,Int)
12:28:47 <lambdabot>      No instance for (Functor ((,,) Int Int))
12:28:47 <lambdabot>        arising from a use of ‘<$>’
12:28:47 <lambdabot>      In the expression: (+ 1) <$> (1, 2, 3) :: (Int, Int, Int)
12:28:51 <dfeuer> Yeah, that.
12:28:52 * hackagebot braid 0.1.0.0 - Types and functions to work with braids and Khovanov homology.  https://hackage.haskell.org/package/braid-0.1.0.0 (saltza)
12:29:34 <kerx3s> Does anyone use Data.Dynamic & Data.Typeable?
12:30:07 <kerx3s> it would be useful to have a DT layer within haskell when the need comes up but I rarely hear these discussed.
12:30:22 <EvanR> those do dynamic typing
12:30:31 <EvanR> however i found the need never comes up
12:31:10 <barrucadu> I think the only time I've used dynamic typing in Haskell was when writing an intentially-confusing fizzbuzz
12:31:19 <barrucadu> *intentionally
12:31:24 <EvanR> for application specific purposes you can create your own sum type to implement your particular universe and it comes up much bette
12:31:24 <adas> do i have to improt something to use "undefined"?
12:31:26 <kerx3s> EvanR no? How about when you have data-derived large-ish records (hundreds or thousands of fields)
12:31:52 <EvanR> thousands of fields records wont work very well in haskell
12:32:19 <kerx3s> what do you do in that case? certainly you don't type thousand field ADTs by hand?
12:32:33 <dfeuer> kerx3s, in the event that you want to play with such things, note that the story behind them is expected to get *much nicer* in GHC 8.2 (next year, probably).
12:32:46 <EvanR> but as far as json-like maps go, you can build a layer between the typeless-schemad system and your application
12:32:48 <kerx3s> it seems like people implement data maps type of structure which approximate a dynamic typing system.
12:32:54 <barrucadu> adas: The prelude supplies it, so unless you're using NoImplicitPrelude it should be there
12:33:16 <EvanR> ah youre talking about something like json objects, not necessarily dynamic typing
12:33:27 <EvanR> the way aeson handles json is pretty good
12:33:41 <dfeuer> 8.0.0 will have a bunch of language machinery necessary to make nice Typeable and Dynamic, but the library API hasn't quite settled down yet.
12:33:53 <EvanR> like i said, theres a universe for the json data and a layer to convert between more typed-safe rep
12:33:55 <adas> barrucadu: thanks. I ended up doing type Bleh=undefined and thats why it didn't work
12:33:56 <EvanR> not dynamic
12:34:20 <kerx3s> EvanR isn't that aproximmating a DT. json perhaps, or large CSVs or databases... aeson works ok, but again, i wouldn't want to write ADTs for really large json files
12:34:47 <kerx3s> esp in some business intelligence / data science sort of scenarios where the data is only used for short term goals
12:34:53 <EvanR> kerx3s: in haskell (i guess up to 8.0.0) Dynamic is something way overpowered compared to say javascripts 7 "types"
12:35:17 <EvanR> if you want something like javascripts 7 types, you want a single sum type
12:35:19 <kerx3s> dfeuer looking forward to seeing wht that looks like
12:35:33 <kerx3s> EvanR I don't particularly _want_ full-on dynamic programming
12:35:47 <kerx3s> at the same time, I need something to fill-in the use case
12:36:10 <EvanR> right, i just have been having a hard time coming up with a good use case for dynamic typing
12:36:24 <jmcarthur> kerx3s: I've having trouble thinking of a data structure which is not amenable to static types. Do you have any examples?
12:36:25 <kerx3s> fast iteration, rapid data analyses. potentially large-ish records that need to be derived from data.
12:36:39 <EvanR> none of that requires dynamic typing
12:36:39 <jmcarthur> kerx3s: I would think that the larger it is, the *more* I want static types.
12:37:05 <dfeuer> kerx3s, there's a paper you can read about it now, but apparently things have changed since then. Basically, you'll be able to pull type information out of a TypeRep in a general and principled way.
12:37:06 <kerx3s> jmcarthur okay sure, but are you going to type in a record type definition with 10,000 fields in it?
12:37:35 <jmcarthur> kerx3s: I would only do that if I'm going to use all 10k fields in code.
12:37:38 <EvanR> youre thinking of a different kind of thing from dynamic typing
12:37:47 <kerx3s> jmcarthur if not, what do you do instead? i'm not saying DT is the right answer, i'm just looking for _some_ way that to deal with it
12:37:54 <EvanR> youre thinking of records with a particular structure to them
12:37:58 <jmcarthur> kerx3s: What is a real world use case for such a thing.
12:38:00 <jmcarthur> ?
12:38:08 <kerx3s> jmcarthur in machine learning or data mining contexts, that's extremely common.
12:38:23 <jmcarthur> kerx3s: In case it's not clear, my answer depends on this. I'm not trying to challenge you.
12:39:11 <jmcarthur> kerx3s: Are you saying that you would literally in a dynamically typed language make an object with 10k variables all with host language identifiers?
12:39:27 <EvanR> kerx3s: so take the case of FHIR records, which is a very large schema of possibly record types and children
12:39:54 <EvanR> the standard is framed in the context of an OOP language with the ability to basically do dynamic typing and check the "class" of an "object" (record)
12:40:03 <EvanR> but this large schema is literally the type signature for the data
12:40:12 <EvanR> dynamic typing is just getting in the way
12:40:15 <EvanR> how to do it?
12:40:24 <EvanR> you generate all the types from the spec using something like template haskell
12:40:35 <geekosaur> some amount of dynamic typing is useful when exchanging data with a program in a dynamically typed language. for example aeson provides some amount of dynamic typing because the javascript on the other side is not guaranteed to stick to a static type when generating json
12:40:42 <kerx3s> kerx3s potentially. at least all the _data_ is used and the types can be mixed. if there's a way to work around identifiers per field i would consider that.
12:41:05 <EvanR> kerx3s: but they can only be mixed in a certain pre-known ways, which is where sum types come in
12:41:27 <kerx3s> EvanR Yes template haskell is one way forward. the main example I've seen is Frames but it def has usability issues.
12:41:30 <EvanR> right json is handled with a sum type, not Dynamic
12:41:31 <Cale> kerx3s: It seems like with such a large number of fields, you probably just want something along the lines of a Map
12:41:57 <kerx3s> Cale perhaps but how would you deal with the heterogeneous types?
12:42:16 <lf94> :t (,) 1
12:42:17 <Cale> Two options:
12:42:17 <lambdabot> Num a => b -> (a, b)
12:42:38 <Cale> 1) Pick finitely many types and build a sum type around them
12:42:47 <Cale> (this is, e.g. what JSON does, pretty much)
12:42:48 <jmcarthur> I'd probably do something like define a record with one field for each field I actually intend to use and a big map for the rest, so I can just pass them around uninterpreted.
12:43:06 <Cale> 2) Figure out what things you need to do with the data, and store *those* instead
12:43:08 <EvanR> data J = N Double | B Bool | Null | S String | Array [J] | Obj (Map String J)
12:43:13 <EvanR> for example
12:43:13 <Cale> (this is OO)
12:43:50 <Cale> Well, I say "OO", but it's also a pretty good example of functional programming typically -- you're using functions as first class data.
12:44:31 <kerx3s> on a more concrete level, are there examples of getting json and csv into such a Map structure like what you're describing? most tutorials focus on getting them into ADT records.
12:44:38 <kerx3s> (tutorials on aeson or cassava i mean)
12:45:04 <EvanR> aeson can convert a json object to a Map, and other things
12:45:18 <EvanR> a tutorial on aeson would be good
12:45:51 <Ankhers> I believe cassava can convert your data into a Vector of Maps.
12:46:11 <kerx3s> and at this point where i'm using maps and converting as needed, i'm almost implementing a mini dynamic typing system, which brings me back to the initial question of why not formalize this workflow as such.
12:46:30 <EvanR> im trying to explain how that workflow isnt the best
12:46:45 <EvanR> do your conversion / validation on the front end and then you dont have to worry about this at all the use-sites
12:47:29 <Cale> kerx3s: Well, in Haskell, the separation between the value-level and the type-level is also the separation between run-time and compile-time
12:47:43 <kerx3s> EvanR trust me, i'm not a fan of DT, which is why i'm asking.
12:47:54 <kerx3s> A Vector of Maps is pretty much a mini dynamically typed "data frame", isn't it?
12:48:03 <EvanR> Maps of what though
12:48:04 <Cale> Types are the properties of your code which can be checked from only the source, at compile time.
12:48:14 <EvanR> Maps of a statically typed value
12:49:04 <Ankhers> cassava (and aeson) will also convert to a concrete type as well, assuming you have those.
12:49:09 <Cale> If the data that you're reading is from an external file that comes along after the program has been compiled, then the type system can't make guarantees about the contents of the file, which is why you need to check that what is there is actually what you want.
12:49:31 <kerx3s> Ankhers is there an example with cassava?
12:50:14 <Cale> http://hackage.haskell.org/package/cassava-0.4.4.0/docs/Data-Csv.html
12:50:19 <Cale> has some examples
12:50:48 <Ankhers> kerx3s: I don't have an example with cassava. I recently built something to use csv-conduit, which uses the same intername module for conversion.
12:50:53 <Ankhers> (it is a real mess though)
12:51:03 <Ankhers> My stuff, not the actual package.
12:51:06 <Cale> (see the stuff about FromField/ToField)
12:51:29 <kerx3s> Cale I'm okay with some sort of "Maybe + pseudo-DT". Isn't FromField / ToField for use with ADTs?
12:51:33 <kerx3s> or at least that's how i've used them
12:51:44 <EvanR> this type-based way of dealing with (supposedly) formatted text data is really nice
12:52:08 <Ankhers> {From,To}Field explains how to convert your data to and from the csv format.
12:52:18 <kerx3s> I don't have an opinion on the right way to do this, i'm just looking for a way that's reasonable
12:52:20 <Cale> Yeah, they're just for encoding and decoding the fields in your CSV to some more specific type so that you can more easily work with it.
12:53:00 <EvanR> kerx3s: yes ADTs, sum types, is how you deal with these alternatives at runtime (which is what DT is for)
12:53:23 <Cale> kerx3s: If you have a large number of different types of data, and there are new ones to handle all the time, then it's often better to start thinking about what those pieces of data have in common with respect to what your program is going to do with them
12:53:34 <kerx3s> Cale so if i wanted to say, fit  a neural network that uses data from all 20,000 columns I don't think the FromField ToField patterns will help
12:53:53 * hackagebot biohazard 0.6.3 - bioinformatics support library  https://hackage.haskell.org/package/biohazard-0.6.3 (ustenzel)
12:54:02 <EvanR> you can nest records and maps
12:54:03 <Cale> kerx3s: For example, if all your program ever did was display a String representation of the various bits of data, then all you need are Strings (or Text or whatever)
12:55:19 <Cale> kerx3s: If there needs to be some way for the user to manipulate each piece of data, then some sort of way to turn the data into a GUI (and turn the result from the GUI back into something that will go into a file) might be appropriate.
12:56:11 <kerx3s> Ill try out some of these Data.Map approaches. In general I want to replicate some of the generic programming that's easy to do in DT languages, eg iteration over arbitrary numbers of heterogeneous fields
12:56:22 <kerx3s> but still work in haskell and get some of the benefits of it.
12:56:50 <EvanR> theres Data.Data which is like what youre saying
12:57:41 <kerx3s> EvanR yeah there seem to be some tools for generic programming, dynamic typing, reflection, but very little discussion or  examples of usage in the wild.
12:57:54 <EvanR> but im really skeptical that its necessary and suspicious of the amount of work at the low levels you need to do to deal with bad data everywhere
12:58:28 <EvanR> basically the problems you get when you use js / ruby / clojure
12:58:39 <kerx3s> "suspicious of the amount of work at the low levels you need to do to deal with bad data everywhere" ? what does that mean?
12:58:58 <kerx3s> i'm very familiar with the problems of DT languages firsthand.
12:59:05 <Cale> If the pieces of data represent monsters in a video game, no matter how you end up serialising them to a file, you might decode them into a Monster type consisting of a record of functions like a timestep function which given a delta time and some game-level messages, gives another Monster representing how the AI decides to move, along with a means of drawing the monster in its present state, and maybe a few other thin
12:59:05 <Cale> gs.
12:59:08 <EvanR> then you should know how it goes
12:59:27 <EvanR> it would be the same in haskell
12:59:41 <Cale> and then you'd also probably need a ByteString or whatever in that record explaining how to serialise the Monster in its current state
13:00:12 <Cale> (and note that lazy evaluation can help a bit here, but even if we didn't have it, you could use a function which had a trivial argument)
13:00:58 <kerx3s> EvanR I do, but at the same time, the use cases aren't going away _and_ it doesn't fit with the standard use cases of haskell. so i'm trying to understand what the options are
13:01:04 <Cale> That can be a good way to generalise over many different sorts of data -- having a sum type with thousands of different cases for all the monsters in a big game might be really frustrating
13:01:20 <Cale> Especially as many of them probably internally need to depend on many different sorts of attributes
13:01:48 <Cale> Now those become parameters to functions which construct these Monster records, and don't show up in the types afterward.
13:01:56 <EvanR> kerx3s: the two ways Cale explained are very good and im not clear why you think they wont work
13:03:05 <kerx3s> EvanR I didn't say they wont. I'll have to try it out...
13:03:27 <Cale> It can be tricky to see exactly what it is that you'll need to put into these records of operations from the outset -- but usually you'll have some idea about what program you want to write to act on your data
13:03:35 <EvanR> DT is really about lack of imagination, lack of a system to help at compile time than a technique of its own
13:03:51 <Cale> DT?
13:03:56 <EvanR> dynamic typing
13:03:59 <Cale> oh, hah
13:04:09 <Cale> DT stands for "dependent typing" in my head now
13:04:11 <monochrom> @quote monochrom poor
13:04:11 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
13:04:24 <jle`> Cale: i was thinking the same thing, haha
13:04:29 <monochrom> so it's DT :)
13:04:36 <dfeuer> bitemyapp, your blog post http://bitemyapp.com/posts/2015-10-19-either-is-not-arbitrary.html doesn't seem to be quite as clear as it should be about the fact that the instances involved are actually *the only ones possible*.
13:04:37 <Cale> haha monochrom 
13:04:47 <EvanR> its dependent types where 100% of the checking is done in your head, and probably not documented anywhere
13:07:13 <kerx3s> speaking of DT now that the holiday is almost over i need to stop haskellinating and do some work-work with a DT language :/
13:07:41 <Cale> kerx3s: At some point I should really write some kind of tutorial on how to take this light OO approach in Haskell, because I think it's frequently overlooked. People often go straight into defining type classes, without really considering "well, what if I just put these methods into a record?"
13:08:21 <kerx3s> Cale yes definitely would like to see that!
13:08:29 <Cale> Which can also be thought of as "good ol' functional programming" in a way too.
13:08:30 <monochrom> the record way is more natural if you started with javascript rather than java
13:09:02 <monochrom> the problem is that who starts with javascript :)
13:09:34 <Cale> and you can do some really cool things in Haskell like making a record type which is parameterised over a choice of monad for the operations to live in
13:09:42 <Ankhers> I think a lot of web devs do javascript before java.
13:10:12 <Cale> and then that lets you write polymorphic functions which take those records, and produce an m-action using them
13:10:13 <sleepynate> much more common these days
13:10:24 <kerx3s> Cale q - if your functions are packaged with your data, say to get method dispatch-y behavior. Does that require a lot of memory overhead, or is the compiler smart enough to have the same functions "pointing" to the same implementation in memory?
13:10:33 <Cale> and even if m turns out to just be IO in your final program, you can locally restrict the operations which are available like that
13:10:48 <Cale> in such a way that those operations might depend on IORefs and MVars and such
13:11:32 <Cale> kerx3s: Well, records are always records of pointers to code (to handle the case that you have unevaluated expressions in the fields)
13:12:28 <Cale> kerx3s: and when those pointers are entered for the first time, and the expressions are evaluated, the pointers get updated to point at shorter pieces of code that just return the already-computed result
13:12:38 <kerx3s> if the function body is the same (say a lambda with the same content), can GHC figure that out or do you have to do something clever?
13:12:51 <kerx3s> hmm
13:12:53 <Cale> kerx3s: When you make a new record from an old one, if you pattern match a variable, and build a new record having that variable in one of the fields, it only copies the pointer
13:13:24 <kerx3s> what about when you re-evaluate it?
13:13:24 <Cale> Or, e.g. if you use record update syntax
13:13:39 <Cale> When any occurrence of the variable is evaluated, all of them become evaluated
13:13:54 * hackagebot webapp 0.2.0 - Haskell web app framework based on WAI & Warp  https://hackage.haskell.org/package/webapp-0.2.0 (natesymer)
13:14:17 <Cale> Yeah, I should be careful there, it's really a pointer to the pointer to code, isn't it? :)
13:14:30 <dfeuer> http://lpaste.net/5081296084714651648  <- me having fun.
13:15:00 <dfeuer> Fairly lunaticky foldr tricks.
13:15:11 <dfeuer> (But not as crazy as the double-foldr implementation of zipWith)
13:15:52 <Cale> kerx3s: anyway, lazy evaluation means that whenever you have a single (not typeclass polymorphic) variable which is bound to an expression, and anything causes that variable to be evaluated, then all occurrences of the variable share the result of that evaluation
13:15:54 <kerx3s> for example http://lpaste.net/150146
13:16:33 <Cale> In that case, since those are functions, the result 4 won't be saved
13:16:48 <kerx3s> are the thunks growing linearly with the size of the list, or are they growing with the number of unique functions in that list?
13:17:20 <Cale> Only the result of evaluating single variables gets shared between the occurrences
13:17:21 <kerx3s> this is relevant to that OO case, as you could have thousands or millions of functions, each representing a dispatch
13:17:56 <Cale> So for instance
13:18:04 <kerx3s> but in the "dispatch" usage, there may only be say, 4 or 5 unique functions that are used for thousands or millions of records
13:19:00 <Cale> Oh, the functions themselves won't take any more memory... so long as you bind them to a variable
13:19:17 <Cale> If you write them out multiple times, GHC won't go out of its way to discover that you've done this
13:19:40 <Cale> Like, let f = \x -> x + 1 in [f,f]
13:19:57 <Cale> will only have one copy of f in memory, and two references to it from the list
13:20:06 <syver> hello, I'm reading through the book Programming Haskell from First Principles and i'm having trouble with a task where I'm supposed to implement functions given some types. the i have the functions xz :: X -> Z, yz :: Y -> Z and xform :: (X,Y) -> (Z,Z),  which I managed to implement
13:20:08 <kerx3s> is ee but it does have to be bound
13:20:14 <kerx3s> so assigning a lambda in an if then else
13:20:18 <kerx3s> or case
13:20:22 <kerx3s> would be a bad way to go about it
13:20:32 <Cale> So long as it's bound to a variable in some way, it will be shared
13:20:40 <Cale> between all the occurrences of that variable
13:20:47 <syver> however, I need help with the final function, munge :: (x -> y) -> (y -> (w,z) -> x -> w
13:20:51 <kerx3s> whereas let f ... in ... or where will be memory efficient
13:21:07 <Cale> syver: you're missing a paren
13:21:35 <kerx3s> ok
13:21:45 <kerx3s> now i've really gotta stop haskellinating
13:22:00 <syver> oh sorry , munge :: (x -> y) -> (y -> (w,z)) -> x -> w
13:22:08 <Cale> syver: okay
13:22:14 <kerx3s> back to data science-y stuff  with R / python now :/
13:22:19 <Cale> So let's give names to the parameters of this function
13:22:24 <Cale> Suppose we're writing
13:22:38 <Cale> munge f g a = ...
13:22:42 <Cale> so we have
13:22:46 <Cale> f :: x -> y
13:22:50 <EvanR> kerx3s: youve inspired me to write something about dynamic typing
13:22:51 <Cale> g :: y -> (w,z)
13:22:54 <Cale> a :: x
13:23:04 <Cale> and we want to get something of type w
13:23:05 <obadz> does the lens package play nice with MonadState?
13:23:17 <Cale> syver: good?
13:23:22 <syver> yes
13:23:33 <kerx3s> EvanR please post it on reddit or something or tweet me so I can find it. will be interested to read...
13:23:56 <Cale> syver: So, the only place where we can possibly get something of type w is from the first component of a pair which is the result of applying g to something of type y
13:23:56 <circ-user-ARP5m> w.r.t http://dev.stephendiehl.com/fun/007_path.html anybody had a clue as to why individual compiler step return values (typically the AST) when those are also part of the state and (presumably, as Stephen left the code incomplete) the steps themselves would store the AST in the state monad?
13:24:00 <Cale> syver: So...
13:24:01 <lyxia> obadz: it does
13:24:12 <Cale> munge f g a = fst (g ...)
13:24:20 <Cale> now we need to get something of type y
13:24:30 <Cale> we still have not used
13:24:34 <Cale> f :: x -> y
13:24:35 <Cale> and
13:24:37 <Cale> a :: x
13:24:44 <syver> oh wow
13:24:45 <obadz> lyxia: where can I find an example/doc on how to use lenses to concisely update state in a MonadState ?
13:24:56 <syver> i got it now, so much easier than the things I tried!
13:25:13 <hunteriam> Does anyone know any good places to apply for summer internships (preferably FP)
13:25:14 <syver> thanks a lot!
13:25:36 <syver> for future reference, is this channel an acceptable place to ask for newbie help?
13:25:54 <Cale> yes, absolutely!
13:26:30 <syver> Excellent! You will probably hear more from me then :)
13:26:42 <Cale> syver: Feel free to ask lots of questions too. Most people remember what it's like to be a beginner :)
13:26:58 <kerx3s> syver try #haskell-beginners too if this channel is too flooded in category theory gibberish
13:27:07 <syver> okey thanks!
13:27:08 <Cale> You'll be surprised at the programs you can write if you learn to think about the types like that.
13:27:18 <lwander> @pl atches x y = length . filter (\(p1, p2) -> p1 == p2) . zip x y
13:27:18 <lambdabot> atches = (((length . filter (uncurry (==))) .) .) . zip
13:27:29 <Cale> Yeah, sometimes #haskell-beginners is kinda empty when this channel isn't though
13:27:36 <kerx3s> it's pretty much the same people.
13:27:50 <Cale> I actually really really hate the name #haskell-beginners for suggesting that #haskell is somehow not for beginners
13:27:54 <kerx3s> haskell seems to be fragmented into the same 40 people spread out across 20 channels.
13:28:14 <syver> Yeah, I'm starting to see how expressive Haskell is. Doing a bachelors in computer science and all we learn is Java
13:28:25 <lyxia> obadz: the haskell page of lens has a couple of links, and the github page seems pretty neat already. But I'm not sure if you'll find that sufficient.
13:28:26 <kerx3s> Cale they're both useful. sometimes find one is active while the other isn't
13:28:28 <syver> so I figured haskell is a good extra-curricular activity
13:28:45 <syver> I'll make sure to check both if its necessary
13:28:55 <kerx3s> syver good :) we need the next generation to get us moving
13:29:04 <kerx3s> in the right direction
13:29:15 <Cale> syver: Anyway, this way of reasoning about how to write a program from its type is actually surprisingly powerful
13:29:21 <kerx3s> god knows my generation is a lost cause
13:29:36 <kerx3s> as are your Java professors
13:30:15 <Cale> syver: You can often get away with writing programs that do the right thing (and pretty much have to do the right thing) without actually understanding how the program works :)
13:30:34 <syver> looking forward to getting to that point :)
13:30:57 <kerx3s> cale there's a parallel to dimensional analysis in physics
13:31:07 <Cale> Types are sort of like the nubs on Lego bricks which tell you how to stick things together in a way that will have some amount of structural integrity
13:31:10 <Cale> kerx3s: yeah
13:31:16 <python476> aight, smdiehl hinted me at installing GHC through stack
13:31:35 <lwander> @pl atches x y = length . filter (uncurry (==)) . zip x y
13:31:35 <lambdabot> atches = (((length . filter (uncurry (==))) .) .) . zip
13:31:56 <Cale> While with Lego, all the nubs look the same, types can sometimes be unique enough that things only fit together in one way, and once you find it, you pretty much know you must have the right thing.
13:31:56 <kerx3s> python476 are you just starting? if you're on OSX / unix stack is the way to go.
13:31:58 <monochrom> yes, if you use stack to install GHC, I think it is the least amount of manual work and decision
13:32:05 <python476> kerx3s: archlinux
13:32:23 <monochrom> archlinux's repo is also cool with GHC, too.
13:32:24 <python476> unless you give me a macbook air, I'll happily release you from that burden
13:32:31 <python476> monochrom: yeah
13:32:39 <python476> but I misunderstood smdiehl advice ..
13:32:45 <kerx3s> back to work again. R 'ing ...
13:33:19 <python476> stack downloads a 130MB package, but the unzipped packages still uses 1.1GB on disk
13:33:22 <python476> too late u_u;
13:33:26 <jmcarthur> I've uninstalled ghc from pacman and am using stack for everything now.
13:33:48 <jmcarthur> This still? :\
13:33:56 <syver> great analogy :)
13:34:07 <lwander> @pl zipper x y = unzip . zip x y
13:34:07 <lambdabot> zipper = ((unzip .) .) . zip
13:34:23 <syver> i think I'm really going to enjoy this language
13:34:36 <monochrom> Cale: http://lpaste.net/145254 is my recent execise in programming by types without knowing "what to do" a priori. now of course, after the code is done, I see what it does, and it does what we want.
13:34:48 <kerx3s> syver start with haskellbook.com do not read learn you a haskell
13:35:22 <syver> yeah i'm 5 chapters in :)
13:35:23 <python476> jmcarthur: aight. I'm happy to be cutting edge 
13:35:48 <syver> started with learn you a haskell but it didnt really work for me (no excercises)
13:36:18 <kerx3s> syver good :). LYAH is a dead end learning graveyard for newbies. it's really not good that people find that first.
13:36:28 <python476> kerx3s: is it that bad ?
13:36:43 <python476> lots of people praise haskellbook on twitter that's for sure
13:37:00 <syver> so far it's a lot better than LYAH
13:37:03 <jmcarthur> I have mixed feelings about a lot of these learning materials.
13:37:16 <kerx3s> python476 it's bad. the problem is it "feels" like you're learning but when you actually try to do something you don't realize that you didn't actually learn anything
13:37:19 <monochrom> LYAH is a good whirlwind tour. there are times you want a whirlwind tour. the only problem is that LYAH is too long for a whirlwind tour.
13:37:46 <kerx3s> python476 that's when people give up. so it's a net negative for the community.
13:38:00 <syver> just starting with lamba calculus made me understand the part on currying really easily, while in LYAH i didnt really understand the point of currying and how it worked
13:38:20 <monochrom> to learn anything, you would like a 2-hour whirlwind tour, and then weeks of deep learning. not weeks of whirlwind tour which is what LYAH does
13:38:26 <jmcarthur> I'm fine with people recommending a book you have to pay for, but I can't imagine the free resources out there are so bad that it's the only option. It's like nobody can imagine how we got by without haskellbook.com these days.
13:38:32 <kerx3s> monochrom I think we need a better whirlwind tour option, with equally attractive cartoons but one that doesn't lead to a pedagogical dead end
13:38:45 <jmcarthur> I agree with the criticisms of LYAH.
13:39:11 <kadoban> jmcarthur: Well, what other option would you point people towards? cis194 and stuff seems okay, but not perfect.
13:39:16 <python476> kerx3s: I did feel untaught, but I assumed it was because I don't know how to RTFM
13:39:27 <EvanR> [5~[5~[5~[6~[6~[6~[5~[5~[5~[6~[6~[6~
13:39:40 <kerx3s> jmcarthur much larger barrier to entry => weak community growth => lots of category theorists, not enough engineers
13:39:44 <python476> right now I'm onto haskell wiki CPS page + G.Hutton papers
13:39:58 <monochrom> jmcarthur, I got by without haskellbook.com, by using the Gentle Introduction. would you like other people to replicate what I did, seriously?
13:40:06 <jmcarthur> kadoban: Yes! I would like to direct these conversations to be about the best free vs. the best non-free resources, not just the best non-free vs. a sub-par free resource.
13:40:08 <monochrom> it was uphill both ways.
13:40:12 <python476> syver: I too find type based thinking a very powerful way to .. think
13:40:20 <jmcarthur> monochrom: Yeah, but cis194 isn't so bad.
13:40:29 <python476> syver: many people said, it makes you solve problems even outside haskell
13:40:46 <python476> `Haskell taught me how to write C` -- a snake
13:40:51 <kadoban> jmcarthur: Personally I usually suggest haskellbook.com , and at the same time cis194 if they don't want to buy something. I kind of wish I knew a better free resource though, one or two of the cis194 exercises I think aren't amazing.
13:41:09 <kerx3s> jmcarthur => weak ecosystem even today for a language older than java.
13:41:13 <monochrom> cis194 is a good skeleton of a good course. at least as far as the web material goes.
13:41:13 <kadoban> And it's a bit sparse just by nature of … originally being part of a class of course.
13:41:24 <jmcarthur> kadoban: I think we are on the same wavelength.
13:41:41 <kerx3s> there are real, concrete negative consequences to keeping people out via learning.
13:41:55 <monochrom> you should be mentioning the wikibook if you want to mention a good free book
13:42:16 <kadoban> I'll have to check out the wikibook, I don't think I've really ever read it.
13:42:29 <python476> HN thread about cis194 ended up mentionning haskellbook
13:42:48 <EvanR> its interesting for students to be claiming that teaching materials arent teaching correctly
13:43:10 <kerx3s> i noticed a stark phase transition over the holidays. it seems like _everyone_ started reading it all at once
13:43:24 <monochrom> the only problem with the wikibook is that at some points it has too many exercises along the same line. "work on data Two a = Two a a". "now work on data Three a  = Three a a a". "now work on data Four a = Four a a a a"...
13:43:38 <kadoban> EvanR: A little, though it's often not that hard to tell when you're not being taught well, if you know what the difference is.
13:44:00 <monochrom> and the Monad chapter has too long a fairy tale
13:44:13 <python476> btw, how twisted is the Poor Man's Concurrency papers  ?
13:44:16 <python476> paper*
13:44:26 <EvanR> kadoban: at the point you know the difference, i think youve graduated
13:44:37 <python476> it's stretching my mind very thin right now
13:44:42 <monochrom> I assume that Poor Man anything is very twisted
13:45:13 <suppi> Haskell has many good free resources... just not so much for beginners :)
13:45:44 <kadoban> EvanR: Hmm, I disagree. In university I could tell who the shitty professors were pretty quickly, even if they knew the material better than I did by far. You don't necessarily need to be an expert on a subject to tell if someone is teaching you in a useful way.
13:45:56 <jmcarthur> Anyway, I only object to beginner recommendations these days so commonly reading like: "LYAH if you are poor, but it sucks, so really, don't do this; haskellbook.com if you have money, and sorry, you just can't learn Haskell if you don't have money." I know nobody is actually saying this, but the impression I get is moving this way increasingly.
13:46:03 <Rembane> If I remember it correctly Poor Man's Concurrency paper implements the concurrency using continuations which are mind bending.
13:46:57 <hodapp> ...that's how I did concurrency when poking around in Ivory.
13:47:00 <EvanR> kadoban: what i was trying to say is it takes work on the students part to learn stuff, too many people complain about the professor or the article and give up citing that as a reason
13:47:41 <suppi> jmcarthur, the authors has specified numerous times that anyone with money problems should contact them, at the very least
13:47:47 <kadoban> EvanR: That is true. It's possible (IMO) to tell if resources or teachers suck. It's also possible to incorrectly blame teachers or resources and bail when things get tough.
13:48:27 <jmcarthur> suppi: That's great!
13:48:47 <suppi> also, you can learn haskell from free resources. it will just be harder
13:48:54 <Ygg> you would go so far as to say LYAH sucks ?
13:48:55 * hackagebot exception-transformers 0.4.0.3 - Type classes and monads for unchecked extensible exceptions.  https://hackage.haskell.org/package/exception-transformers-0.4.0.3 (GeoffreyMainland)
13:49:03 <Guest22833> oh
13:49:05 <jmcarthur> suppi: The things you are saying are true, but beside the point.
13:49:07 <Guest22833> quit
13:49:10 <monochrom> jmcarthur, I have not yet seen an asker that insists on free-of-charge. if I see one, I will be certain to suggest cis194, NICTA, wikibook, etc
13:49:12 <jmcarthur> Ygg: No, I would not say it sucks.
13:49:18 <kadoban> Ygg: On its own, yes. Though I wouldn't word it like that because that's kind of mean.
13:49:23 <Ygg> I'm currently learning haskell and that's uh, worrying me
13:49:49 <python476> suppi: do they give rebates if your mail is convincing enough ?
13:49:55 <monochrom> in practice, every asker has had left the money constraint lax. given that, haskellbook.com or many paid books exceed all of the free choices.
13:50:03 <python476> or exchange duties against pdf chapters
13:50:13 <jmcarthur> Ygg: It is fast-paced, has no exercises, and lacks motivating examples. On the other hand, it shows you a lot of neat stuff, and has a lot of cute pictures.
13:50:26 <suppi> python476, you should ask them :)
13:50:48 <monochrom> the fact is that the optimization problem "best quality under us$100" does not land you at any free one.
13:52:40 <GLM> Is there a Haskell IDE that has the ability to click a function and have it bring you to the function definition?
13:53:14 <suppi> GLM, like click on a name and bring a type signature?
13:53:29 <kadoban> GLM: hdevtools can do that, basically. I used to use the vim plugin.
13:53:30 <fr33domlover> GLM, that should be a basic IDE feature
13:53:58 <EvanR> since you might have to look at all the aux functions to read the definition, might as well open the source file
13:54:03 <GLM> suppi: Ideally, it'd bring me to where in the code it is defined
13:54:39 <suppi> I think you can do that in emacs with haskell-mode at the very least
13:55:12 <suppi> but I didn't really get to use that feature
13:56:33 <hunteriam> is there a way to write a `where` clause extending past pattern matching?
13:57:11 <dibblego> the NICTA/course is regularly run in-person, free of charge
13:57:28 <dmj`> hunteriam: what do you mean by 'past pattern matching'
13:57:29 <suppi> monochrom, isn't that true with most PLs?
13:57:46 <hunteriam> dmj`: i have f True = ... ; f False = ...
13:57:51 <hunteriam> dmj`: i want a where that covers both
13:57:54 <sleblanc> I have a type Attribute = Something | SomethingElse ... and a type AttributeValue attr val deriving Eq; how can I express Ord in a way that will not let me compare two AttributeValue with different "attr"? 
13:57:54 <monochrom> yes.
13:58:08 <kadoban> dibblego: Is it ever done in any kind of online interactive fashion, or would that be too much of a mess?
13:58:09 <dmj`> hunteriam: yes
13:58:17 <hunteriam> dmj`: how?
13:58:24 <dmj`> where f True = ... (newline) f False = ...
13:58:42 <hunteriam> dmj`: ?
13:58:48 <suppi> monochrom, i don't really understand why so much discussion is needed about that :\
13:58:53 <hunteriam> dmj`: f is the function im writing
13:59:09 <EvanR> sleblanc: thats not a valid data type declaration
13:59:16 <dibblego> kadoban: only like this, as we are doing now
13:59:24 <dmj`> hunteriam: you want a where that defines one function that pattern matches values on multiple lines, right?
13:59:28 <ecognium> Hello everyone, I have a question about parsing XML files. I have a huge XML file (deeply nested). I would like to parse this XML file but I only care about a handful of nodes. All the tutorials online seem to focus on parsing the entire file into a data type. Is there an example on how to parse the XML file without having to define the entire XML structure in Haskell? 
13:59:50 <hunteriam> dmj`: no i want to define a function and have a where clause that is useable across all the different `pattern matches` of the function
13:59:51 <dmj`> ecognium: which tutorials? check out xml-conduit
13:59:53 <EvanR> sleblanc: but you might want to combine the two types into one Attribute type which was Something val | SomethingElse val, then you can derive Ord
13:59:56 <dmj`> @package xml-conduit
13:59:56 <lambdabot> http://hackage.haskell.org/package/xml-conduit
14:01:00 <enthropy> hunteriam: put that function at top level, and then just don't export it from the module if the problem is clutter
14:01:18 <sleblanc> EvanR, it was shortened; here it is in full: http://lpaste.net/3452310092802686976
14:01:24 <enthropy> which isn't really a solution
14:01:43 <sleblanc> EvanR, I'd like to be able to refer to attribute types without values, too
14:02:00 <EvanR> sleblanc: alright. so include Ord in the deriving for both of them and itll work
14:02:03 <sleblanc> EvanR, which is why I have an AttributeValue
14:02:26 <sleblanc> EvanR, I'd like to avoid the case where someone tries to compare an AttributeValue Intensity x with an AttributeValue Colour y
14:02:32 <sleblanc> as it has no meaning
14:02:44 <ecognium> dmj`:  I am looking at it now. I reviewed this one (https://www.schoolofhaskell.com/school/advanced-haskell/xml-parsing-with-validation) and http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html (it looked nice but I am not working with HTML so did not know how to fetch nodes without specifying the structure upfront).  Even though the files are big, I am ok parsing them in one go as I don't need a high throughput
14:02:53 <EvanR> sleblanc: then you can use 3 types for the three kinds of attributes
14:02:54 <kadoban> dibblego: It'd be cool as hell as a MOOC, if that would even work. Though it's great as-is too :)
14:02:55 <sleblanc> EvanR, and I would like to avoid having an Ord instance on my Attribute type, as in my domain it makes no sense to order the attributes
14:03:11 <danilo2> Hello guys! is there in Haskell anything simmilar to unions from C++? I want a **really** low level stuff here and want to keep untyped data in a block of memory so I would rather not use GHC.Prim.Any, because it's always representred as a pointer
14:03:34 <EvanR> sleblanc: responding to your latest question, you can write your own Ord instance and not use deriving
14:03:55 * hackagebot grasp 0.1.0.0 - GRASP implementation for the AMMM project.  https://hackage.haskell.org/package/grasp-0.1.0.0 (janmasrovira)
14:04:02 <jmcarthur> danilo2: If we're talking super low level you could consider using the FFI. Or maybe there's a higher level way to go, but it's hard to say without knowing more about your problem.
14:04:15 <sleblanc> EvanR, but that will let someone type "AttributeValue Intensity x `compare` AttributeValue Colour y`, which is what I want to avoid in the first place
14:04:31 <EvanR> then you need to use more types
14:04:57 <danilo2> jmcarthur: I'm jsutr creating m own datatypes with a slighty different behaviour than Haskell's default ones. In fact I really need unions and I want to be able to store in this "memory chunk" one of predefined types
14:05:02 <EvanR> or maybe rethink your whole plan
14:05:25 <jmcarthur> danilo2: You can manipulate unmanaged memory buffers using Ptrs from the FFI.
14:05:28 <danilo2> jmcarthur: FFI could be the way to go but I would really prefer something available in Haskell out of the box if there is something like that
14:05:39 <jmcarthur> danilo2: It's Haskell.
14:06:10 <jmcarthur> danilo2: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.2.0/Foreign.html
14:06:13 <Cale> danilo2: The FFI library includes a whole bunch of in-Haskell services for low-level stuff
14:06:30 <danilo2> jmcarthur: I dont know anything aobut FFI to be honest with you. Coudl you tell a little bit more aobut these poitners and where should I start to do it pretty fast if that possible? I would be thakful for any hint here
14:06:44 <jmcarthur> danilo2: In particular, see https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.2.0/Foreign-Marshal-Alloc.html and https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.2.0/Foreign-Ptr.html
14:07:11 <jmcarthur> danilo2: It's probably worth skimming over
14:07:14 <jmcarthur> oops
14:07:47 <jmcarthur> danilo2: It's probably worth skimming over everything in the Foreign.* namespace in base. That's not actually everything there is to know about the FFI, but it's all you need to use pointers and understand manual memory management.
14:07:50 <danilo2> jmcarthur: ugh, all these functionalities are in IO. hmm, would it be safe to use them in unsafePerformIO ? I want to mimick the behavioru of pure haskell data types, so enforcing everybody to use IO will be a pain
14:08:16 <EvanR> sleblanc: make different types for each attribute, perhaps newtypes. if you still need a type which sums all those types, make that one and dont derive Ord for it
14:08:32 <jmcarthur> danilo2: The primitive package (http://hackage.haskell.org/package/primitive) has some wrappers that allow you to use some of these primitives in ST.
14:08:53 <jmcarthur> danilo2: It's a step sideways from the FFI. It's not intended for FFI sorts of things, but has similar functionality.
14:08:57 <danilo2> jmcarthur: Ok, thank you very much! :) One more question - how can I know the amount of bytes to reserve to keep one of predefined Haskells types (it keeps only unboxed values)
14:09:04 * hackagebot foldl 1.1.4 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.1.4 (GabrielGonzalez)
14:09:12 <danilo2> or not, not only unboxed
14:09:18 <EvanR> :t sizeOf
14:09:19 <lambdabot>     Not in scope: ‘sizeOf’
14:09:19 <lambdabot>     Perhaps you meant one of these:
14:09:19 <lambdabot>       ‘IM.size’ (imported from Data.IntMap),
14:09:31 <jmcarthur> danilo2: Ptrs lean on the Storable type class, which has a sizeOf function.
14:09:48 <danilo2> jmcarthur, Cale: great, thank you guys! :)
14:09:54 <EvanR> sizeOf is funny because its a constant for a given type, so needs to use proxy
14:10:03 <jmcarthur> danilo2: (In the primitive package, you would probably use Addrs instead of Ptrs. Addr doesn't have the phantom type argument that Ptr has.)
14:10:15 <danilo2> EvanR: yeah, I was suspecting such interface
14:11:06 <jmcarthur> danilo2: Ah, and the primitive package also has its own Storable alternative called Prim.
14:11:18 <jmcarthur> danilo2: As I said, it's kind of a step sideways from FFI.
14:11:25 <danilo2> jmcarthur: oh, thats interesting!
14:11:40 <sleblanc> EvanR, thanks for the tip. I think I'll just stick to the simplest, deriving Ord and let the user deal with asserting that attr==attr
14:11:47 <EvanR> unsafePerformIO also might work to use FFI secretly behind a "pure" data structure
14:11:58 <ecognium> dmj`:  I reviewed this tutorial (http://www.yesodweb.com/book/xml) and it feels like a bit more involved. Is there a library that I can use that can do something like (pseudo code) doc->{'node1'}->{'node7'}? Where the parsed structure is available for lookup by element names?  (sorry I am not proficient in Haskell so apologize if it is very easy thing to do)
14:11:58 <EvanR> if there are no side effects
14:12:06 <jmcarthur> danilo2: 
14:12:11 <jmcarthur> Gah, I keep doing that.
14:12:22 <danilo2> :D
14:12:27 <danilo2> thank you once again!
14:12:28 <danilo2> :)
14:12:44 <EvanR> sleblanc: sure, though in this case you can avoid that and it might make more sense to the end user to have different types
14:13:08 <EvanR> sometimes you cant avoid that and you have to make the user bookkeep all this, which is something you dont want
14:13:33 <jmcarthur> danilo2: As EvanR says, you can also use unsafePerformIO with FFI instead of using the primitive package. the FFI is a major (but not only) reason for it existing anyway.
14:13:57 <jmcarthur> danilo2: And there are more Storable instances out there than Prim instances.
14:14:21 <danilo2> jmcarthur: I see both of these worlds, thank you guys! :) Are there any reasons for preffering one over the other?
14:14:38 <danilo2> jmcarthur: you're answering my questions before I ask them :P
14:15:30 <danilo2> jmcarthur, EvanR: one last thing here :D Is there any "easy" way to make a Haskells complex datatype instance of SizeOf ? 
14:15:42 <danilo2> *not sizeOf - a typeclass defining sizeOf
14:16:02 <jmcarthur> danilo2: There is already a Storable instance for Complex
14:16:32 <hunteriam> is there any matrix multiplication built in to haskell?
14:16:32 <danilo2> jmcarthur: writing complex I ment a complex, not a simple one, not Complex :P
14:17:04 <danilo2> jmcarthur: just a datatype containeing other datatypes and so one, not built out of Ints etc
14:17:23 <jmcarthur> danilo2: re: primitive vs. ffi: Sometimes I like the phantom type on Ptr and sometimes I don't. primitive is a little more convenient when working with ST. The FFI is obviously a better fit when working with foreign functions. FFI has a lot more utility functions built in. primitive is kind of meant to be a small building block for higher level libraries, which I think explains why it has less functionality.
14:17:36 <jmcarthur> danilo2: You can just define your own instance of Storable.
14:17:59 <EvanR> yes they are very denotative
14:18:08 <EvanR> you just use the sizeOf its constituents
14:18:13 <danilo2> jmcarthur: ok, I think i know everything now. I was just asking about some automatic deriving mechanism for it
14:18:20 <danilo2> Thank you for your time and help! :)
14:18:30 <hunteriam> im looking for [[a]] -> [[a]] -> [[a]]
14:18:33 <hunteriam> for matrix multiplication
14:18:36 <jmcarthur> danilo2: It is not generallly difficult to write on your own. You wouldn't normally want to derive it, because usually the whole point is to have tight control over the memory representation.
14:18:46 <danilo2> EvanR: Thank you too! :))
14:19:10 <danilo2> jmcarthur: yep, right - I just realised that after asking the question :D
14:20:52 <jmcarthur> danilo2: Note that you could also roll a lot of this on your own using ByteStrings.
14:21:06 <kadoban> Is criterion still a good tool for benchmarking? Anything better I should look at instead?
14:21:33 <jmcarthur> kadoban: For microbenchmarks, it's hard to beat criterion.
14:21:49 <kadoban> Cool
14:22:45 <Wizek> hello! acid-state has to keep its whole database in memory at all times, right?
14:23:02 <dmj`> Wizek: yea
14:23:02 <dmj`>  
14:23:28 <danilo2> jmcarthur: yep, I was just looking forthe best solution and didnt know about the FFi's functionalities and especially about the Primitive lib. I will choose something fitting here :) Thank you! :)
14:23:47 <Wizek> Anyone knows why that is? Could it be just persisted to disk and dynamically managed what stays in memory and what gets read from disk?
14:24:00 <EvanR> Wizek: its persistent to disk too
14:24:05 * hackagebot pipes 4.1.8 - Compositional pipelines  https://hackage.haskell.org/package/pipes-4.1.8 (GabrielGonzalez)
14:24:11 <EvanR> but its design requires having it all in memory
14:24:19 <dmj`> Wizek: it saves a transaction log to disk along with a snapshot
14:24:27 <Wizek> Yes.
14:25:18 <Wizek> So couldn't the design be chaneged of either acid-state or in another similar lib that it would work quite the same way except it would free some less often accessed memory regions, and reload them from disk on demand?
14:25:23 <EvanR> if it had dynamic memory unloading you can be sure that a) it will not be as fast b) it will not be a couple source files big c) you may have to put up with a worse interface, not as generic, maybe
14:25:29 <monochrom> whole-thing-in-memory has various benefits such as one fewer kind of errors/exceptions. (the "disk has just disappeared" kind.)
14:25:39 <EvanR> and that
14:26:34 <dmj`> Wizek: you can do a few things, You could compress the data, and then save it in memory, this is a time vs space trade-off, but you're already wicked fast since it's in memory. 
14:26:36 <EvanR> Wizek: the idea of acid-state is your traded memory money for speed
14:26:55 <EvanR> and a nice interface
14:26:59 <EvanR> "nice"
14:27:30 <exio4> monochrom: "some bits flipped" is still a problem? :P 
14:27:47 <EvanR> if you cant trust memory youre kind of fooked
14:27:51 <EvanR> in haskell
14:27:54 <monochrom> yes but there is no exception for that, so you don't have to write a handler for it
14:28:07 <exio4> EvanR: true :)
14:28:09 <Wizek> hmm. I've only tried it cursorily, but what I like about it is that I can just store native data stractures without having to cast them to say SQL data types. And generally
14:28:16 <exio4> EvanR: maybe that's a reason to make ECC ram more mainstream
14:28:31 <dmj`> Wizek: that's the dream yea
14:28:38 <EvanR> Wizek: yeah which can for example be a set of indexed sets
14:28:38 <monochrom> ECC used to be mainstream 15 years ago or something
14:28:52 <EvanR> which you then would like a DSL to search through
14:28:58 <EvanR> perhaps called "NoSQL"
14:30:12 <Wizek> And also that it keeps all the data permanently through via the logs, so nothing can get lost
14:30:24 <EvanR> thats the D in acid
14:30:31 <Wizek> But I am concerned about memory usage
14:30:45 <EvanR> how large do you think your database will get
14:30:50 <dmj`> Wizek: postgres does cache a lot in RAM too though. 
14:31:48 <dmj`> Wizek: you also don't have to rely on a non-standardized binary format (cereal)
14:32:00 <dmj`> but a lot of people don't care about that
14:32:09 <Wizek> so I would like to use something similar that didn't have this everything-in-ram ad a hard requirement. If it was a chouice, or a config option, that would be perfect. E.g. I could say I want everything in mem, or I want at most 2 gigs of data in ram
14:33:09 <EvanR> having a configurable limit on acid-state after which it does controlled failure would be nice
14:33:17 <EvanR> but not sure if thats possible
14:33:42 <Wizek> EvanR, You mean without changing the api?
14:34:03 <EvanR> youd obvious have to change the api somehow to add this configuration option
14:34:29 <Wizek> of course
14:34:34 <Wizek> but besides that
14:34:57 <Wizek> Also, the "disk is gone" error could also be handled globally, and might not be necessary to handle locally: Print the error and halt can be a valid way to handle that.
14:35:00 <EvanR> space will run out eventually in any of these systems, and acid-state's memory based thing doesn't really let you control usage, because haskell
14:35:46 <EvanR> so its best to use only when you have reasonable knowledge of how big the database will get and buy that much more ram
14:36:47 <Wizek> Yeah, makes sense. I am just a bit surprised/disappointed that there is no such option either in that lib or another similar lib.
14:36:59 <EvanR> you mean disk-based database?
14:37:06 <EvanR> there are a lot of those
14:37:33 <Wizek> No, I mean DB very similar to acid-state  that does not require everything to be in RAM
14:38:02 <EvanR> theres postgres or sqlite where you only store one blob
14:38:04 <Wizek> Btw, another internal detail question: Do you know if the ram requirement extends to all data ever (full log) or just the latest dataset?
14:38:21 <dmj`> Wizek: you won't lose data if it's all in RAM and you exceed your resident memory + swap
14:38:25 <dmj`> w/ acid-state
14:38:35 <Wizek> hmmm
14:38:42 <Wizek> that is an interesting point dmj` 
14:38:42 <EvanR> not the full log
14:38:50 <dmj`> the transaction will be recorded on disk before it's considered complete, that's the D
14:38:59 <dmj`> to the log, it will simply append
14:39:02 <dmj`> don't be trippin' on acid-state
14:39:17 <dmj`> every haskell programmer depends on acid-state, since it runs hackage :P
14:39:23 <EvanR> o_O
14:39:25 <Wizek> hah
14:39:40 <Wizek> Really? Any idea about ram usage?
14:39:59 <EvanR> lets think logically about why you care about ram usage
14:40:02 <dmj`> It's no different than storing a bunch of stuff in an MVar, you can profile how big the heap is w/ ekg
14:40:25 <dmj`> Wizek: what kind of app are you planning to build with it, then we'll tell you if RAM is an issue
14:41:22 <Wizek> Well, I'm mainly asking generally to get a sense for what kind of projects that kind of datastore might be a good choice and what kinds might it not be.
14:41:46 <EvanR> one is a GUI app where you dont have to implement a save / load...
14:41:55 <EvanR> its just remembers what state it was in
14:43:24 <Wizek> Server with tens of thousands of registered users?
14:43:29 <dmj`> Wizek: you could use it for a web app, where you cache stuff in acid-state (there is a RAM only option w/ acid-state). Or you could store user information in it, then data for those users in postgresql. It will be fast.
14:43:51 <dmj`> another application idea is hackage =)
14:45:40 <EvanR> a video game with a persistent world(s)
14:46:10 <EvanR> though RNGs get tricky
14:59:47 <adas> in record syntax, is there a way to use the same name instead of getting a "Multiple declaration" error?
15:00:35 <monochrom> IIRC a future GHC version with a future extension allows that
15:00:39 <codebje> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
15:00:49 <codebje> GHC 8 will do it
15:01:29 <adas> looks like im using a version lesser than 8
15:01:51 <adas> unsupported extension
15:04:15 <codebje> yes, ghc 8 is not yet released
15:04:21 <codebje> likely to land mid feb, I think
15:04:22 <EvanR> type directed disambiguation, wow
15:08:36 <Franciman> Hi
15:08:53 <Franciman> Does anybody know mvc?
15:09:10 <Franciman> (the library)
15:09:24 <Franciman> I was trying to use it in combination with wxHaskell, but I don't know how to deal with events
15:10:00 <Franciman> I mean the main loop either is runMVC or the GUI loop, how can I conciliate things?
15:16:20 <danilo2> Hello! :) Is it possible in haskell to create type alias for a kind-type? I want sometihng like: type Foo a = Bar * a
15:22:03 <shirt> how can i have a function return a different types, as long as they all have a common typeclass? for example:
15:22:30 <shirt> foo :: (ToJSON t) => Int -> t
15:22:43 <shirt> foo n = if n == 0 then [1,2,3] else "Hello"
15:23:47 <GLM> shirt:What about Either Int t?
15:24:46 <shirt> GLM: hm... not sure that's what i'm looking for
15:24:59 <barrucadu> shirt: All you could do with such a value is convert it to JSON, so why not just return JSON?
15:26:18 <shirt> barrucadu: i'd like to pass the result of foo as an argument to another function that wants a ToJSON
15:27:04 <bergey`> The type of foo says that the caller gets to decide what type t is.  The definition says the return type depends on the input, which Haskell doesn't allow.
15:27:22 <bergey`> In this case, returning a Value probably works.  Value has a ToJSON instance.
15:27:59 <shirt> bergey`: yeah, in the case of ToJSON that would work, but the real typeclass i am working with this trick won't work
15:28:10 <GLM> bergey`: Is there a way to return something generic that we only know has the attributes of the typeclass?
15:28:18 <Ygg> any idea what could cause exponential memory usage through ghci but stay stable once compiled ?
15:29:06 <codebje> data ToJSONAble = forall a. ToJSON a => MkJSONable a
15:29:40 <codebje> let jsonify :: ToJSON t => t -> ToJSONAble ; jsonify = MkJSONAble
15:29:42 <bergey`> GLM: It's possible, but rarely what you actually want.
15:30:30 <shirt> codebje: hm... interesting. could you please write what "foo" would look like?
15:30:33 <codebje> let foo :: Int -> ToJSONAble ; foo n = if n == 0 then jsonify [1,2,3] else jsonify "Hello"
15:30:40 <shirt> awesome!
15:30:42 <bergey> shirt: I think the general approach still applies.  Pick a concrete type to return that has the required instance.
15:30:46 <codebje> not 100% sure it'll work
15:31:02 <codebje> it's the general idea behind one approach to heterogeneous collections
15:31:03 <shirt> bergey: what do you think about what codebje proposed?
15:31:15 <codebje> (I think it's not an elegant solution)
15:34:28 <bergey> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
15:42:23 <danilo2> Hello! :) Is it possible in haskell to create type alias for a kind-type? I want sometihng like: type Foo a = Bar * a
15:44:17 <geekosaur> Ygg, lots of things. ghci uses the bytecode backend, which does no optimization. compiling, unless you use -O0, will often fuse away memory allocations
15:44:19 * hackagebot th-reify-many 0.1.4 - Recurseively reify template haskell datatype info  https://hackage.haskell.org/package/th-reify-many-0.1.4 (MichaelSloan)
15:51:14 <jmcarthur> danilo2: I don't think I understand the question.
15:53:05 <danilo2> jmcarthur: ok, so I want to have code like the following one: `data Map a b; type MyMapKind a = 'Map a *; foo :: a -> Proxy (MyMapKind Int) -> String; foo = undefined` unfortunetally GHC doesnt allow for kind alias `MyMapKind` 
15:53:47 <danilo2> jmcarthur: ugh wait, an error
15:54:12 <exio4> danilo2: not yet
15:54:22 <danilo2> jmcarthur: the right is here: `data Map a b; type MyMapKind a = 'Map a *; foo :: a -> Proxy (a :: MyMapKind Int) -> String; foo = undefined`
15:54:29 <danilo2> exio4: ok, is it in the plan ?
15:54:58 <exio4> danilo2: it's already supported in HEAD :) 
15:55:07 <danilo2> exio4: YAY :D
15:55:10 <danilo2> thanks! :D
15:55:34 <exio4> danilo2: (it's part of the unification of kinds and types, the unification makes "kind synonyms/kind families" possible)
15:55:52 <jmcarthur> danilo2: So, at least right now, DataKinds isn't enough to permit you to use types as kinds, just data constructors and such. However, perhaps you actually wanted this instead:   data Map a b = Map a b; type MyMapKind = 'Map
15:56:15 <danilo2> exio4: yeah I've seen that. I'm waiting for moving to ghc 8.* so bad! I'm just waiting for the compilation - performance bugs to be fixed :D
15:56:29 <jmcarthur> I misstated that, but my suggestion is still legal.
15:57:04 <jmcarthur> Ah, no, it doesn't do what you wanted.
15:57:12 <danilo2> jmcarthur: in fact if we just paste ('Map a *) in places where (MyMapKind Int) is my code works fine, I wanted just to have nice type synonym :)
15:57:43 <danilo2> exio4, jmcarthur : thank you ! :)
15:57:44 <jmcarthur> Basically disregard everything I said, because I misunderstood what you wanted. :)
15:58:00 <danilo2> jmcarthur: no problem, sorry for being unclear :)
15:58:24 <jmcarthur> You were reasonably clear once you wrote code. I just fail at reading.
15:58:53 <danilo2> heh, my mental-haskell-parser often fails at night (at last here is night) :P
16:19:20 * hackagebot swagger2 1.2.1 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-1.2.1 (NickolayKudasov)
16:22:11 <Strukks> Hi, if I have a function as "fun a = ..." how can I constraint the a to be an Integer? If that question makes any sense
16:22:24 <johnw> you give fun a type
16:22:33 <johnw> fun : Integer -> Integer; fun a = ...
16:22:33 <python476> this eludes me => Not in scope: data constructor ‘IO’
16:22:51 <jle`> python476: there's no data constructor for IO normally
16:22:54 <python476> is it illegal to pattern match on IO ? myfun (IO x) = ...
16:22:58 <jle`> it's usually a type constructor
16:23:03 <python476> jle` ok
16:23:07 <jle`> yeah, IO doesn't really "contain" a value
16:23:18 <jle`> so it wouldn't make too much sense to pattern match on it
16:23:34 <jle`> there's no String "inside" an IO String, for instance
16:23:56 <johnw> sorry, fun :: Integer -> Integer
16:24:20 <python476> so if I got a toplevel type IO a -> Foo, I just myfun v = ...
16:24:20 <GLM> How can I map over every character in IO String
16:28:27 <kadoban> GLM: do {xs <- theIOString; return $ map toUpper xs}
16:28:36 <kadoban> There's also combinators like 'fmap' to make it easier.
16:29:15 <GLM> kadoban: I was hoping to do it with fmap
16:29:42 <kadoban> GLM: Sounds like a plan. What trouble did you run into?
16:30:15 <GLM> kadoban: It was only mapping over the string, not the chars in the string
16:30:58 <kadoban> :t fmap (map toUpper)
16:31:00 <lambdabot> Functor f => f [Char] -> f [Char]
16:31:30 <EvanR> :t fmap . fmap
16:31:31 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:31:38 <kadoban> GLM: Does that help at all? Note that IO is a Functor, so that's a polymorphic version of    IO String -> IO String
16:31:54 <jle`> python476: yes; although there aren't too many interestiong IO a -> Foo's you could write
16:32:05 <jle`> but yeah, you'd take it as a normal argument
16:32:28 <GLM> Yeah, that makes sense. Thanks
16:32:37 <EvanR> jle`: hold on, containers that hold onto IO commands are a thing
16:32:53 <jle`> oh yeah
16:32:56 <jle`> you're right
16:32:59 <jle`> :D
16:33:04 <jle`> i stand corrected
16:33:09 <jle`> there are lots of IO a -> Foo's
16:35:07 <python476> my head is spinning
16:36:11 <Axman6> hold onto something
16:36:25 <obadz> If you end your training now — if you choose the quick and easy path as Vader did — you will become an agent of evil.
16:37:01 <bind> you could try sticky tape ...
16:37:10 <obadz> “You must unlearn what you have learned.” -- Yoda
16:37:11 <kadoban> obadz: Will I get to sound all badass like james earl jones?
16:37:49 <EvanR> if programming languages were space opera franchises
16:37:56 <bind> even though you could also make graphene with it
16:38:30 <obadz> kadoban: "When you look at the dark side, careful you must be. For the dark side looks back."
16:38:40 <bind> haskell is so full of funs
16:39:24 <Axman6> python476: do you need some help?
16:39:32 <bind> well ... at least the dark side has something to look at then ...
16:42:21 <python476> Axman6: more than some, lots, but mostly I should go back to basic, and even before that, go to sleep
16:42:27 <python476> see ya tomorrow if you're there
16:42:31 <python476> thanks yall
16:42:50 <python476> ps: #haskell is one of the smoothest place on earth, dont change
16:48:58 <enthropy> I'm thinking of something that's sort of like stream/build-foldr fusion but instead of say  map f . map g = map (f . g), you'd have  \ xs -> (sum xs, maximum xs) -- in one pass
16:49:20 <enthropy> is there a term for that type of thing?
16:49:22 * hackagebot swish 0.9.1.7 - A semantic web toolkit.  https://hackage.haskell.org/package/swish-0.9.1.7 (DouglasBurke)
16:53:16 <codedmart> Gurkenglas was nice enough to give me this code but I am getting an error: https://gist.github.com/codedmart/5ca225ccc94b0a6131d4
16:56:41 <lyxia> codedmart: fmap fromJust . runMaybeT $ y <|> lift x
16:58:02 <solrize> anyone know a simple way to do binary field arithmetic?
16:58:14 <solrize> i found a finite-field package on hackage but it's only for prime fields
16:58:25 <lyxia> :t \x y -> runMaybeT y >>= maybe x return
16:58:26 <lambdabot> Monad m => m b -> MaybeT m b -> m b
16:58:34 <lyxia> codedmart: ^
16:58:41 <codedmart> lyxia Thanks!
17:00:18 <lyxia> codedmart: To be more specific, as the error says, you were returning a (MaybeT m a) instead of (m a), you just needed to remove the MaybeT layer.
17:00:47 <codedmart> lyxia OK thanks again, still have issues with error messages :)
17:01:07 <jmcarthur> Actually, the error was complaining that y was a (MaybeT m a) instead of an (m a), which is legitimately more confusing.
17:02:14 <lyxia> aha I stand corrected
17:03:16 <codedmart> lyxia or jmcarthur any chance you can look at this: https://gist.github.com/codedmart/5ca225ccc94b0a6131d4#file-error
17:03:42 <jmcarthur> Our error messages leave much to be desired. Once you learn a bit about how the type checker works, it's not so bad, but then the experts end up losing motivation to make the error messages nicer (it's hard to do).
17:03:45 <codedmart> So the commented out case statements work. But I was trying to find ways to refactor it.
17:04:17 <codedmart> jmcarthur I imagine it is hard to do.
17:06:59 <codedmart> I feel like I do pretty well, but I am still trying to get monads/transformers better.
17:07:11 <jmcarthur> codedmart: So the error message I see in your link is talking about Cookie.hs
17:07:35 <codedmart> Oh right sorry that is the name of the Auth.hs file in the gist. Forgot to rename it.
17:07:41 <jmcarthur> Ah.
17:07:45 <codedmart> Sorry :|
17:08:01 <codedmart> Seems I got RouteResult in a RouteResult.
17:08:32 <jmcarthur> codedmart: Nothing it's talking about seems to have anything to do with the pasted code, regardless. I'm seeing identifiers like route, jwtCheck, subserver
17:09:07 <codedmart> jmcarthur OK some of those are Servant related.
17:09:34 <codedmart> But any idea why I have RouteResult (RouteResult a) instead of IO (RouteResult a)
17:10:24 <jmcarthur> codedmart: It's hard to say, because the error message is talking about expressions not in your paste, like `(addBodyCheck subserver (jwtCheck request))`
17:10:46 <codedmart> jmcarthur OK let me revamp the paste to see if it helps.
17:11:45 <codedmart> jmcarthur Here is the current file in all it's glory: https://gist.github.com/codedmart/5ca225ccc94b0a6131d4#file-cookie-hs
17:12:12 <codedmart> Still playing with ideas. Just trying to understand things.
17:14:17 <radens> what is the name for the thick arrow used in type signatures (=>)?
17:16:07 <jmcarthur> codedmart: I'm sorry, I have to go. I think your problems would require me to have to read up on servant again. My knowledge is vague and probably out of date already.
17:16:17 <jmcarthur> codedmart: There is a #servant channel, in case you didn't know.
17:16:22 <codedmart> jmcarthur No worries thanks!
17:19:24 <codedmart> lyxia Thanks for your help as well.
17:22:26 <Cale> radens: "The arrow which separates the class context from the rest of the type"
17:23:51 <monochrom> except when it separates the class context from the class context. (class Functor a => Monad a :) )
17:24:36 <monochrom> I think you can just say "thick arrow" and be done with it.
17:25:15 <monochrom> err, class Functor a => Applicative a
17:33:39 <dfeuer> Can someone confirm my believe that  sum (map wLen ws) + length ws === sum (map ((+1) . wLen) ws) ?
17:35:05 <exio4> what's wLen?
17:35:08 <dfeuer> *belief
17:35:21 <dfeuer> exio4, that shouldn't matter, unless I'm very confused.
17:35:22 <Cale> It shouldn't matter :)
17:35:33 <exio4> oh, nvm..
17:35:59 <monochrom> @type length
17:36:00 <Cale> This is basically lots of commutativity and associativity of addition.
17:36:01 <lambdabot> Foldable t => t a -> Int
17:36:10 <dfeuer> I'm just doing a bit of cleanup in the terribly-neglected (by me) boxes package.
17:36:13 <monochrom> is ws a list?
17:36:30 <jle`> radens: it's a rocket
17:36:47 <monochrom> I think it doesn't matter either. Foldable has enough laws for this. my answer is yes.
17:36:56 <Axman6> dfeuer: makes sense to me, nice way to avoid traversing the list twice
17:36:56 <dfeuer> Yeah, that's what I thought.
17:37:14 <dfeuer> I was pretty certain; I just wanted another couple eyes. Thanks all.
17:42:13 <nanoz> Newbie Question : how to convert tuples to list
17:42:29 <nanoz> for example (1,2,3) - > [1,2,3]
17:43:14 <codebje> nanoz, let list_of_tuple3 :: (a, a, a) -> [a,a,a] ; list_of_tuple3 (a, b, c) = [a, b, c]
17:43:15 <monochrom> write explicitly \(x,y,z) -> [x,y,z]
17:43:40 <codebje> er, type is wrong for the list
17:43:42 <codebje> but you get the idea
17:43:45 <codebje> [a]
17:43:52 <nanoz> well i dont know what are you saying i got this in chapter 1 of learn haskell for great good
17:44:11 <exio4> dfeuer: http://exio4.xyz/~exio4/sum.length.txt (+ annotations that make this actually clear)? :P 
17:44:17 <monochrom> it means you have to define your own function for this.
17:44:42 <nanoz> are you joking >:
17:44:47 <monochrom> no
17:45:32 <nanoz> what my funciton will contain what is the input / predicate
17:45:35 <ReinH> I don't know of anything in LYAH that asks you to convert tuples to lists
17:45:54 <dfeuer> exio4, yep.
17:46:03 <monochrom> the input is a 3-tuple. the output is a list.
17:46:12 <nanoz> in chapter 1 they introduce tuples i'm keen on converting it
17:46:20 <kadoban> nanoz: tuples in haskell aren't like "kind of funky lists" like they are in some other languages.
17:46:39 <ReinH> there's generally no good reason to try to convert a tuple to a list
17:46:44 <monochrom> meta-level comment: you are ahead of yourself
17:47:06 <monochrom> and yeah, you're inflicting an XY problem on yourself. why convert at all.
17:47:10 <nanoz> ReinH i dont know yet lets see
17:47:20 <dfeuer> Now from lists to tuples ... that's sometimes useful.
17:47:28 <dfeuer> But not often.
17:48:28 <dfeuer> frequency (tuples to lists) <<< frequency (lists to tuples) < monthly
17:50:27 <EvanR> firstTwoWithDefaults :: [a] -> a -> a -> (a,a)
17:53:52 <nanoz> what this means No instance for (Num [t0]) arising from a use of `it'
17:53:52 <nanoz> In a stmt of an interactive GHCi command: print it
17:54:18 <monochrom> you confuse number with list.
17:54:25 <ReinH> What did you do?
17:56:23 <nanoz> let v(a1,a2,a3) = [[x,y,z]|x<-a1,y<-a2,z<-a3]
17:57:22 <nanoz> monochrom
17:57:24 <ReinH> and what do you expect that to do?
17:58:12 <nanoz> v(1,2,3)
17:58:37 <ReinH> how would a list comprehension work with numbers?
17:58:41 <monochrom> 1 is not a list. you are saying "x <- 1" as though 1 were a list.
17:59:02 <ReinH> also, function application is not done with parenthesis
17:59:05 <monochrom> > [[x,y,z] | x<-[4], y<-[10,20], z<-[0]]
17:59:06 <lambdabot>  [[4,10,0],[4,20,0]]
17:59:13 <ReinH> v(1,2,3) is v (1,2,3), applying v to the tuple (1,2,3)
17:59:19 <monochrom> you need lists in "x <- need_a_list_here" etc
17:59:36 <monochrom> like I said, meta-level comment: you are ahead of yourself
18:00:14 <nanoz> meta level comment: i'm here to learn your there to teach 
18:00:37 <ReinH> ...
18:00:38 <monochrom> then I quit. I'm not even being paid.
18:00:41 <Kristler> Don't be snippy, nanoz.
18:01:03 <nanoz> why this doesnt work than how will i do it :(
18:01:03 <nanoz> ]
18:01:09 <monochrom> you're welcome to do the self-contradictory thing of "I'm only at chapter 1" and at the same time "I want to do whatever I like"
18:01:15 <ReinH> nanoz: figure it out on your own
18:01:49 <ReinH> You don't get to demand anyone's help.
18:01:58 <nanoz> ofc
18:04:35 <Axman6> nanoz: v a b c = [[x,y,z]|x<-[1..a], y<-[1..b], z<-[1..c]]
18:04:59 <Axman6> you were close, but you should have been able to put that together from at least monochrom's comment
18:05:27 <ReinH> how do you even know if that's what they want?
18:05:37 <Axman6> I don't
18:05:50 <Axman6> I'm hopeful 
18:06:06 <monochrom> it's ok. any legal code is an improvement over any illegal code.
18:08:01 <nanoz> thats not what i want Axman6 :/
18:08:09 <nanoz> but thanx
18:08:10 <Axman6> ...
18:08:26 <Axman6> well my mind reading skills are a little off today
18:08:47 <Axman6> maybe I should try harder to guess what you want without you giving us any information whatsoever
18:09:07 <monochrom> to be fair, it was said many minutes ago
18:10:08 * hackagebot bimap 0.3.2 - Bidirectional mapping between two key types  https://hackage.haskell.org/package/bimap-0.3.2 (joel_williamson)
18:10:10 * hackagebot invariant 0.3 - Haskell 98 invariant functors  https://hackage.haskell.org/package/invariant-0.3 (ryanglscott)
18:11:00 <Axman6> nanoz: so....... what do you want
18:11:44 <nanoz> ill do it and inform you
18:12:03 <Axman6> -_-
18:12:05 * Axman6 leaves
18:12:18 <dfeuer> Is Eric Seidel about?
18:20:13 <nanoz> i guess it cant be done :/
18:20:36 * hackagebot http2 1.4.3 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.4.3 (KazuYamamoto)
18:20:56 <nanoz> i'll take a break and think about it
18:26:46 <Strukks> How do I Exit after the first value is found? "[ n+2*n+2 | n <- [1 ..], n*n > 100000]"
18:26:57 <Cale> Strukks: take 1 ?
18:26:59 <Cale> Or head
18:27:06 <Strukks> ", take 1"?
18:27:21 <Cale> Those are both functions which accept a list
18:27:27 <Strukks> oh
18:27:32 <Cale> Or you can just pattern match
18:27:47 <Cale> case [ n+2*n+2 | n <- [1 ..], n*n > 100000] of (x:_) -> ... something with x ...
18:28:07 <Strukks> head worked perfectly, tyvm
18:29:37 <Cale> Be cautious when using head -- it's fine here, but if you ever happen to give it an empty list, your program will die
18:30:01 <Strukks> I'll try to remember that, thanks!
18:30:40 <Cale> > head []
18:30:41 <lambdabot>  *Exception: Prelude.head: empty list
18:31:19 <Cale> ^^ it can really suck to try to figure out why this message is happening from a large program :)
18:31:46 <Cale> So if you have any doubt, pattern matching so that you can handle the empty list case is better.
18:33:34 <JamesJRH> Hi. How do I see what version of a module is imported by GHCi?
18:34:31 <monochrom> wait a second, a module can have versions?
18:36:04 <JamesJRH> monochrom: Well otherwise how do I see what package provided a module so that I can see the version of that.
18:36:07 <JamesJRH> ?
18:36:17 <Cale> If you mean package, then ghci -v will print a bunch of version information as packages get loaded
18:36:36 <JamesJRH> Ahh, perfect…
18:36:44 <monochrom> yeah, it has to be at the package level
18:37:21 <monochrom> there is no notion of "multiple module versions", only "multiple package versions"
18:37:41 <JamesJRH> Hmm: Prelude> import System.Random
18:37:42 <JamesJRH> *** Parser:
18:37:42 <JamesJRH> Prelude System.Random> 
18:38:06 <monochrom> try using some of its functions. it has delayed loading, implying delayed messages
18:38:18 <JamesJRH> Oh…
18:38:44 <JamesJRH> Hmm, give me an example.
18:38:53 <monochrom> randomIO :: IO Int
18:38:57 <JamesJRH> I haven't used System.Random yet.
18:39:03 <JamesJRH> Okay…
18:39:15 <monochrom> it should output 4...
18:39:49 <ReinH> -_-
18:40:00 <monochrom> haha
18:40:07 <JamesJRH> Ahh cool, and it list some dependencies loading too, finishing with: Loading package random-1.0.1.1 ... linking ... done.
18:40:28 <JamesJRH> monochrom: Lol!
18:41:18 <JamesJRH> https://xkcd.com/221/
18:41:24 <monochrom> yeah!
18:41:29 <JamesJRH> :-D
18:41:46 <monochrom> someone said this is a re-telling of a joke or true story in IBM
18:42:04 <monochrom> I forgot whether it's a joke or a true story
18:42:48 <JamesJRH> “RFC 1149.5 specifies 4 as the standard IEEE-vetted random number.”
18:46:22 <dpn`> free haskell book on packt today: https://www.packtpub.com/packt/offers/free-learning
18:46:24 <JamesJRH> monochrom: ‘RFC 1149.5’ is rather like ‘Platform 9¾’ – I don't think it exists in real life. https://tools.ietf.org/html/rfc1149.5 redirects to https://tools.ietf.org/html/rfc1149 .
18:48:32 <ReinH> dpn`: probably not worth it
18:48:33 <monochrom> ah, and 1149 itself is no no-joke
18:49:06 <JamesJRH> https://tools.ietf.org/html/rfc1149 is a joke in itself, in fact. It looks like it's about pigeons. :-]
18:50:26 <dpn`> ReinH, not worth signing up?
18:50:47 <ReinH> Packt is a mill, they put out lots of garbage.
18:51:01 <dpn`> I agree
18:55:33 <adas> ReinH: why do you think its garbage?
18:56:16 <ReinH> the books I've seen have obviously had no competent editing or technical review
18:56:38 <ReinH> they include nonsensical code, code that doesn't compile, etc
18:56:52 <ReinH> they generally will get literally anyone they can to write their books without regard for level of expertise
18:57:09 <mac10688> signs like a job for me!
18:57:23 <adas> any opinion on safari online? since they're a competing online library like packt
18:57:39 <ReinH> Generally quite good.
18:57:48 <SavinaRoja> mac10688: leave in lots of typos so they can hire me as an editor
18:58:23 <ReinH> safari books online has a huge library including lots of excellent books
18:59:45 <hodapp> Safari is excellent.
19:00:02 <hodapp> (not the browser)
19:00:33 <geekosaur> ("discount! only $200/yr!" once upon a time I *had* a subscription...)
19:01:06 <hodapp> ReinH: have you used Apress much? I found some good content there, but also some amount of junk.
19:10:05 <ReinH> hodapp: With Apress it depends on the author
19:10:52 <ReinH> I think they can be hit or miss but they are a reputable publisher
19:11:02 <ReinH> I know some people who have written for them
19:38:35 <diggle> @help
19:38:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:38:40 <diggle> @list
19:38:40 <lambdabot> What module?  Try @listmodules for some ideas.
19:39:07 <diggle> list
19:39:11 <diggle> awww
19:51:49 <adamCS_> Anyone feel like helping me be less confused about free monads?
19:52:16 <monochrom> I don't know. what does it take?
19:52:22 <adamCS_> :)
19:54:23 <adamCS_> I have a thing I can do with the state monad, to produce a rose tree for some web layout pruposes.
19:54:33 <adamCS_> s/pruposes/purposes
19:54:57 <adamCS_> for at least pedagogical reasons, I am trying to figure out how I would do it with a free monad
19:55:12 <adamCS_> the point is to have a simple notation, using do, etc.
19:55:46 <EvanR> webpage templating is the classic thing you dont need state for >_<
19:56:15 <EvanR> also abusing monad do notation when you are really using a monoid is kind of also classic
19:56:22 <infandum> Does anyone here work on bioinformatics? I'm worried that the lack of standardization might be hurting the bioinformatics scene in haskell.
19:56:45 <adamCS_> so: myLayout = row (col 1 (elt "A") >> col 1 (elt "B") >> col 1 (elt "C")) >> row (col 1 (row (elt "A") >> row (elt "B")))
19:56:53 <infandum> I see there was a push a few years back to standardize things, but the mailing list is nonresponsive and the site seems out of date
19:57:19 <adamCS_> Yes, I get that i could do this differently.  But I am wrapping another monad that already lays out elements of the DOM this way.
19:57:21 <EvanR> mconcat [row ..., col ..., col ..., row ..., row, ...
19:57:29 <EvanR> :(
19:58:06 <adamCS_> So I wrapped that with state in order to add the layout info into a rose tree as I go along.  
19:58:39 <monochrom> I don't know how to use a free monad for this
19:59:00 <EvanR> html generation is like the most functional thing people run into a daily basis
19:59:36 <EvanR> but its been imperatived to death by <insert something here>
20:00:44 <adamCS_> Then maybe I have extra questions.  One is, how better to think about all of this, and the other is still just a free monad question.
20:01:20 <julianleviston> EvanR: imperatived to death. I quite love that.
20:01:47 <julianleviston> EvanR: “You have been imperatived to death with the hammer of repeated mutation!”
20:01:55 <julianleviston> I might have to use that.
20:03:22 <EvanR> you can think of html as denoting some tree of elements. you can generate this tree using pretty much dumb functions, sometimes factoring parts out and using them locally or through closure
20:03:48 <EvanR> its cuts down on user code, library code, and makes it generally easier to read, i think
20:05:01 <EvanR> html itself not having this "dumb function" feature spawned decades of C-like attempts at imperative languages to generate html
20:05:42 <adamCS_> Right.  It might be relevant that I am doing all of this in reflex, an FRP framework, so parts of the DOM are dynamic.  I am trying to add a layout layer on top.  The way it works so far requires knowing something about the children (column sizes, e.g.,) before I can put the attributes on the parent.
20:05:46 <EvanR> dumb function meaning pure function, lambda calculus. no monads, no side effects
20:05:46 <julianleviston> Yeah, this is why all of the reactive HTML libraries are spinning up, too… it turns out you can get massive performance wins by treating the whole thing as a functional tree.
20:06:19 <monochrom> EvanR, I think I know why, but it's a semi-long story.
20:06:27 <adamCS_> There may be a dumb way to do that.  But I'm too dumb to see it.
20:07:15 <monochrom> suppose you want this to take linear time (proportional to output length) not quadratic time. there are two ways.
20:07:24 <Cale> adamCS_: I'm pretty familiar with reflex-dom, what's this additional layout stuff?
20:07:24 <julianleviston> adamCS_: when the children mount, they get mounted with a function. That function can “inform” the parent of stuff. 
20:08:12 <monochrom> one way is to use an algebraic data type for the intermediate tree you build, which enjoys dumb functions for building, even reusing. and have a last function that serializes trees to byte sequences.
20:08:30 <monochrom> the problem is that those languages suck at algebraic data types
20:08:47 <chancy> When is it actually a good idea to use partial application?
20:09:19 <monochrom> the other way is to thread through a state, which is "the current buffer so far". this can only entrench the stateful nature deeper.
20:09:25 <EvanR> monochrom: yes a type system would be nice and i guess thats too much to ask for html in 1990 or so
20:09:54 <monochrom> s/stateful nature/stateful illusion/
20:10:35 <Cale> chancy: Well, for one, whenever you have a function which can do part of its work with only some of its arguments, it might be beneficial to write things in a way such that it can do so.
20:10:43 <Cale> (performance-wise)
20:11:01 <EvanR> but such a technology at such a time still could have been expected to settle for "a node is a string or a list of nodes"
20:11:07 <EvanR> and thats the only type
20:11:36 <chancy> Cale: Ah hah, that's intersting. So it can be a pre-caching sort of optimization
20:11:39 <Cale> chancy: But more often, that isn't something we're thinking too much about -- it's just convenient to be able to apply a function to less than the maximum number of arguments it could be given and get another function which might be the argument to another higher order function like map or something
20:11:45 <adamCS_> Cale:  I've got the layout working, though I'm not sure it will hold up under widget switching, but that's not my issue yet.  What I've got is a StateT wrapper around a MonadWidget.  Then I have functions like "row::LayoutM a -> LayoutM a, which adds divs to the DOM  and builds up a rose tree in the state.  Then, when appropriate (a tricky thing in the presence of dynamics), I can use the state to add css classes to the divs I added.
20:13:45 <Cale> adamCS_: Is this basically in order to observe what sizes things are rendering at, so that it can be adjusted with CSS after the fact?
20:14:41 <Cale> Or something more like keeping track of the remaining screen real-estate as you build the page?
20:14:45 <adamCS_> Cale: Sort of.  I don't know how many columns I have below until I put them in.  
20:14:57 <adamCS_> as a simple case
20:15:23 <EvanR> self-modifying dom ;)
20:15:30 <adamCS_> so, for a css grid, I can't choose which class to use for each col until I have all the cols in the row.
20:15:33 <EvanR> the style depends on the style depends on the ...
20:15:51 <Cale> ah
20:16:00 <adamCS_> But I didn't mean to bring the html/DOM question here, though I'm happy to get advice
20:16:09 <EvanR> theres fluid styling where you dont have to know that
20:16:27 <adamCS_> it was the free monad part that has me stymied.
20:16:31 <adamCS_> I don't need it
20:16:39 <adamCS_> but I like to learn things...
20:16:49 <adamCS_> EvanR: like flex?
20:18:06 <EvanR> just thinking of floating divs
20:18:11 <EvanR> with fixed widths
20:18:29 <Cale> I'm not 100% sure I would use a StateT transformer just to keep track of how many cells in a row... I'd probably try to get away with building a list of the widgets which go in the cells first, and then use something which applies the appropriate class while building the row
20:19:02 <Cale> But go on about the free monad question...
20:19:19 * johnw grabs the popcorn
20:19:39 <Cale> hahaha
20:21:48 <adamCS_> Okay.  So, and try to forgive the stupid here, my weak understanding is that the free monad allows me to (maximally) abstract my DSL and my interpreter.  Where, for me, the DSL are basically the row and col functions and, I think, a function to represent the actual element in a row or column.  Then the interpreter should take the free monad and turn it into the rose tree I'm currently getting via my updates to my State.
20:23:28 <adamCS_> So, entirely ignoring the web part, I just want a function using do-notations/binds to give me a free monad that I can then interpret into the "obvious" rose tree.
20:23:52 <adamCS_> But the nesting part is eluding me.
20:25:22 <adamCS_> Cale:  (Yes, about deferring the building of the row until after all columns.  But that is sort of tricky in reflex, at least from what I understand. And, with dynamics, that doesn't really make sense at all.)
20:26:01 <adamCS_> So I have a functor: LayoutF a = Row a | Col Int a | Elt String a
20:26:31 <adamCS_> and the free monad of that is not what I want.  Which took me some time to understand.
20:27:48 <adamCS_> What I tried was: type Layout = Free LayoutF
20:28:27 <adamCS_> row::Layout a -> Layout a; row l = join $ liftF (Row l)
20:28:54 <adamCS_> col::Int->Layout a->Layout a; col w l = join $ liftF (Col w l)
20:29:24 <adamCS_> elt::String->a->Layout a; elt s x = liftF $ Elt s x
20:29:53 <Cale> I mean, you can write something like  makeRow ws = mapM (elClass "td" (whichClass (length ws))) ws where whichClass n = ...
20:30:00 <Cale> But okay...
20:31:16 <johnw> adamCS_: does this help at all: https://gist.github.com/f13aa253fafe35e6fa9b
20:31:21 <Cale> (you might want to pull the whole whichClass (length ws) expression out into the where clause just to be safe about not re-evaluating it, but if you write the function without using a lambda like that, I would expect it to be computed once)
20:32:06 <johnw> (though, it's not a rose tree)
20:32:35 <adamCS_> and now I have functions with the right signatures  and I can use binds/do-notation, but nothing is nested.  Which, after much head-scratching, I kind of get. But I can't figure out how to change the functor or the functions using it to get nesting as I want.
20:33:18 <adamCS_> johnw:  Thanks!  But that result also has no nesting, right?
20:33:28 <johnw> adamCS_: yes, an oversight, adding it now
20:33:30 <EvanR> your LayoutF is basically a list
20:34:08 <EvanR> er no
20:34:35 <adamCS_> EvanR:  Yes.  But I don't want it to be.  I see now why it is since all my constructors are like the identity functor. Sort of.  They have only one a
20:35:13 <adamCS_> But what I don't see is how to get what I do want which is a nested list.  Which I can then make into a rose tree
20:35:37 <adamCS_> though I think johnw is trying to do my ambition one better and make it a rose tree almost directly
20:35:51 <EvanR> yes thats what i thought too , but now im not so sure
20:36:09 <EvanR> reviewing free
20:39:50 <adamCS_> Cale:  (I do think I can do it in a more direct way but I am trying to preserve the nice syntax and composability of the reflex MonadWidget apparatus.  With my way you don't need to add much to an existing widget to have it lay itself out in a grid which can then be composed with other widgets and all the layout works.)
20:45:42 <adamCS_> Cale:  Here's a sample of the stateT version.  This makes a nested layout with some dynamic styling of various parts of the widgets and sub-widgets.  You can see that the syntax is a very thin layer over the regular reflex widget functions.
20:45:46 <adamCS_> http://pastebin.com/efXAXAKW
20:45:53 <mjrosenb> is there a typeclass for types with a zero value?
20:46:08 <mjrosenb> for some definition of zero... which I'm still thinking of.
20:46:19 <mjrosenb> I think I want a minimum element.
20:46:57 <Cale> adamCS_: yeah, I guess this approach has advantages when your cells depend on each other's results
20:47:18 <mjrosenb> uh-oh, this problem just became very ugly very quickly.
20:47:38 <Cale> mjrosenb: Perhaps Monoid?
20:47:47 <Cale> If you can decide what it's the zero of.
20:48:37 <Lokathor> what is a good data structure for a multi-line blob of text that will frequently have lines be replaced?
20:48:55 <EvanR> Data.Sequence maybe
20:48:56 <Lokathor> i've heard about a "difflist" thing in hackage, is that for this sort of situation?
20:49:02 <Cale> no
20:49:16 <adamCS_> Cale:  I am not claiming that it's actually better for anything.  It's just what I started trying to do and now it's something of a quest to get it to some useful place.  The StateT version is nearly there (though maybe not.  Dynamics are hard!) but now I just wanted a free monad education and tried to use this as a learning exercise.  And ran into trouble...
20:51:15 <Cale> adamCS_: Well, the reason that nothing is nested is that you probably want the action for generating a bunch of columns to be an argument to the Row operation
20:51:21 <EvanR> mjrosenb: the Max newtype causes an Ord, Bounded type to become the monoid where the minimum is mempty and max is the mappend
20:51:42 <Cale> Er, I guess it is
20:52:02 <Cale> hm, well, I guess I don't really understand what you mean by it not being nested...
20:52:08 <adamCS_> Cale:  Yes. But I can't figure out how with the free monad. 
20:52:29 <Cale> Yeah, you'd need to do something funny and recursive
20:52:47 <adamCS_> Cale: With state, I just end up running the state of the part I get as an argument, and then appending that to the rose tree in the right place.
20:56:01 <codedmart> Can I use ask (Reader) from within a different context? https://gist.github.com/codedmart/353f61fee2c728a313b7#file-error
20:56:08 <adamCS_> I can stick with StateT.  I just got curious since it seemed sort of like the thing people talk about the free monad for.  And then I got stuck and figured maybe I was being dumb or it was an interesting free monad question.  
20:56:33 <Lokathor> Data.Sequence seems like the sort of thing i want. shame there's no constant time update
20:57:26 <Cale> adamCS_: Maybe try something like:  data LayoutF a = Row (Layout a) | Col Int a | Elt String a
20:57:33 <Lokathor> i take it, if i want constant time updates and also self-adjusting sizing i'd need to build my own data structure package?
20:58:31 <Adeon> no I think you want mutable data structures if that's important to you
20:58:43 <wedens> how should I approach "mocking" database in code with logic interleaved with DB interaction? 
20:58:55 <Cale> Lokathor: There's not really a constant time update for anything though, just to be clear :)
20:59:20 <Cale> Lokathor: Any function whose range has n elements takes at least O(log n) time.
20:59:28 <Lokathor> well, "constant" like an array assignment in C/Java
20:59:49 <EvanR> Lokathor: an array would work... unless you want to delete a line
20:59:56 <EvanR> then you would have to shift
21:00:02 <adamCS_> Cale:  If I have f = row (col 1 (Elt "A") >> col 1 (Elt "B")), I get Free (Row (Free (Col 1 (Free (Elt "A" (Free (Col 2 (Free (Elt "B")))))))))
21:01:02 <Lokathor> basically, there's a text area on a webpage, and i'm getting updates about it in terms of updates to the "current" value
21:01:18 <Lokathor> so i need to both pass that on to the other clients, and also update the server's memory of the current text
21:01:35 <EvanR> if it always a fixed length?
21:01:39 <EvanR> IS IT*
21:01:42 <EvanR> CAPS LOCK
21:01:59 <Lokathor> nope, the goal is a code editing thing that others can all view at the same time
21:02:06 <Lokathor> so not a fixed length at all really
21:02:12 <EvanR> ah so you really want Data.Sequence
21:02:21 <EvanR> since i assume you wanna delete and insert lines
21:02:31 <Lokathor> yes, i do want to delete and insert lines
21:02:38 <EvanR> 1000 lines of code isnt that bad
21:02:46 <EvanR> > log 1000
21:02:48 <lambdabot>  6.907755278982137
21:02:57 <Lokathor> yeah it's not too bad
21:03:03 <Cale> The bigger problem with Data.Sequence isn't really the asymptotics, but the constant factors, however, at those sizes, it's really not going to be an issue
21:03:30 <EvanR> also the rate of updates
21:03:36 <EvanR> can't be that high
21:04:27 <Lokathor> how high is "can't be that high"?
21:04:33 <Cale> If you're dealing with hundreds of megabytes of data, Data.Sequence can be a bit slow.
21:04:33 <EvanR> the asymptotics would probably be a bitch nonetheless using an array and shifting
21:04:44 <Lokathor> probably
21:04:54 <kadoban> It's much easier for linear factors to matter than log factors
21:04:56 <Lokathor> it's planned to have updates be something like 30fps maybe
21:04:57 <EvanR> Lokathor: i was guessing that your app doesn't update that fast
21:05:10 <Cale> I sort of doubt that the performance would be a problem here even if you did something which was completely stupid
21:05:10 <Lokathor> or even less obviously, when people aren't typing
21:05:11 <EvanR> like 900 updates per millisecond 
21:05:19 <EvanR> ah ok
21:05:20 <adamCS_> Cale: You mean Layout and LayoutF defined in terms of each other?  I hadn't thought about that...
21:05:24 <Cale> adamCS_: yeah
21:05:53 <adamCS_> Cale:  I'll fiddle with that!  Though perhaps in the morning.
21:07:01 <Cale> adamCS_: Or, another way to abstract over operations is to start with a record type having operations in an arbitrary monad of the appropriate shapes
21:07:09 <adamCS_> jonhnw:  I'd love to see what you were thinking...I'll check that gist tomorrow or find you here.
21:07:20 <adamCS_> johnw:  I'd love to see what you were thinking...I'll check that gist tomorrow or find you here.
21:07:27 <Cale> So another easy way to get this right without thinking too hard about these funny encodings
21:07:47 <Cale> is just to do that, and make your "free monad" essentially a reader for such a record
21:07:49 <adamCS_> Cale:  Is that sort of the cofree thing?
21:08:26 <Cale> I've seen people call this a "van Laarhoven free monad"
21:08:47 <adamCS_> Okay.  I will look at that as well.
21:09:18 <Cale> newtype Free eff a = Free { runFree :: forall m. Monad m => eff m -> m a }
21:09:37 <Cale> But you almost don't need this type at all
21:09:52 <Cale> It's mostly just for convenience of passing around your record :P
21:10:37 <Cale> The more important tactic here is the idea of pulling your operations out into a record type parameterised on a monad
21:10:52 <Cale> and then writing functions which are polymorphic in the choice of monad, using those operations
21:11:04 <Cale> e.g. in this case, you might have
21:12:38 <Cale> data LayoutOps m = LO { row :: m a -> m a, col :: m a -> m a, elt :: String -> m a } -- not sure about that elt, but perhaps you get the idea
21:13:30 <Cale> Er, perhaps you're right that it needs an 'a' too
21:14:23 <Cale> But I think if you do it for real, maybe you'd want to insist that m was an instance of MonadWidget or something in addition to having these row and col operations
21:14:29 <adamCS_> Cale:  Not sure in this formulation.  In the other, without the a, it cuts things off.
21:14:42 <adamCS_> right
21:15:14 <adamCS_> so that would make it more like building FreeT
21:15:45 <adamCS_> but for now I will be content just making a rose tree out of simple do notation using Free.  I think.
21:15:59 <Cale> Maybe... I haven't actually used Free/FreeT in the style that they occur in Ed's library
21:16:37 <Cale> I've used MonadPrompt a little
21:16:51 <johnw> I primarily use Ed's library
21:18:08 <Cale> and this technique, well, I've been doing stuff like that for a while, but only recently heard it called the "van Laarhoven free monad" (but the attribution is probably correct anyway!)
21:22:19 <EvanR> is the "free object" something that only exists for concrete categories, like it says on wikipedia
21:24:08 <johnw> adamCS_: I haven't been able to write this in a way that I like, I'm going to have to give up now to turn to some other things.  Sorry.
21:24:47 <adamCS_> johnw:  No prob! Thanks for giving it a shot.
21:24:48 <Cale> EvanR: *kinda*?
21:26:10 <adamCS_> Cale:  Thanks for the ideas.  I'll see what I can figure out...
21:28:14 <Cale> EvanR: Whenever you have a "forgetful functor"
21:28:18 <EvanR> Cale: i guess since theres forgetful functors involved...
21:28:28 <EvanR> its kinda of depends on the Set thing
21:28:36 <Cale> Forgetful functor isn't really a precise technical term in general though
21:28:46 <Cale> So, you could almost take it to mean "right adjoint"
21:28:57 <Cale> and then the free functor is "left adjoint"
21:29:14 <EvanR> so it generalizes to any adjuction
21:29:22 <Cale> Sometimes you have a forgetful functor which doesn't really forget all the way down to a set
21:29:59 <Cale> e.g. maybe you forget the multiplication of your ring in order to obtain an additive Abelian group
21:31:07 <EvanR> so freeness is kind of informal
21:31:15 <Cale> yeah
21:31:27 <Cale> But adjunctions make it precise
21:33:25 <Cale> (or a multiplicative monoid, perhaps as a better example)
21:40:54 <orion> How do most people combine a Haskell application and logrotate?
21:41:27 <orion> Do they use the copytruncate option, or do they implement posix signal handling?
21:49:25 <kadoban> Anyone have a cute way to … compare benchmarks across history of code? I have my code in git and a benchmark using 'stack bench', seems like I can't be the first to want to see at a glance how it's changing over time with code changes.
21:49:55 <mgsloan> ++ I'd like this too
21:50:06 <mgsloan> Integration with perf testing is a plus too
21:51:49 <kadoban> :) I wonder if someone in the git world has done something for that, maybe in a general enough way that it could be plugged into. I know I've wanted this before in other contexts :-/
21:53:48 <spindas> kadoban, mgsloan: LiquidHaskell is using gipedia for that - https://github.com/nomeata/gipeda
21:54:26 <spindas> see https://github.com/ucsd-progsys/liquidhaskell/tree/master/scripts/performance
21:54:49 <sm> kadoban: yes, https://github.com/simonmichael/hledger/blob/master/tools/simplebench.hs
21:55:30 <sm> dirt simple but quite useful
21:56:56 <sm> or, hooked into cabal/stack bench: https://github.com/simonmichael/hledger/tree/master/hledger/bench
21:57:42 <kadoban> Interesting, thanks
21:59:56 <kadoban> sm: So with that I have to give it a bunch of different executables to try against each other basically, right?
22:00:31 <sm> yes, different exes, or different versions of them, or just one
22:06:33 <coconut1> Hi all, i plan to set up yesod + mongodb server to receive user client queries(from mobile devices). how does the client send json data? how to construct the URL? which library should i use?
22:07:36 <coconut1> and how do i set up yesod to define the json url that the client should use ?
22:21:30 <movedx> Well are you writing the client too? If so, then you define out the client sends the JSON data. As for the API: follow RESTful methodology and pick a JSON formatting standard, such as http://jsonapi.org/ 
22:22:43 <coconut3> movedx, yes i will write the mobile client
22:23:23 <movedx> Follow a JSON API standard and you'll have your format. Then just use REST endpoints/methods and you should have what you need to get started.
22:23:43 <coconut3> movedx, i just found about another db: couchdb which seems to define already the json url format
22:23:55 <coconut3> movedx, anyway i get your point. thanks
22:24:14 <movedx> Sure. Any document based DB will do. ElasticSearch is good.
22:24:43 <coconut3> haskellers choose elasticsearch more often ?
22:25:02 <coconut3> someone here mentions that yesterday
22:25:11 <movedx> Probably not. I'm just saying I like it.
22:25:15 <coconut3> ok
22:25:37 <movedx> It's very easy to cluster and work with. And Kibana is a lovely front end for pulling data out and visualising it. Then you have ElasticHQ for monitoring it.
22:26:13 <coconut3> any document based db that equally runs on android or iso platform §
22:26:18 <coconut3> ?
22:26:54 <movedx> Probably not.
22:27:47 <coconut3> ok
22:39:24 <sleblanc> coconut3, sqlite can store JSON if this will do
22:39:35 <sleblanc> It's not "NoSQL", but it lets you have indexes and custom functions
22:39:56 <coconut3> document based db seem to much intuitive to use
22:40:27 <sleblanc> do you mean that document stores are more intuitive to use than SQL databases?
22:40:58 <coconut3> i mean all the query languages and data representation etc
22:41:32 <coconut3> fits perfectly with my application which stores and process news articles
22:42:06 <coconut3> another question: i dont really intend to serve pages to users,only return json data. in this case do i have to use a web framework such as yesod ?
22:42:24 <coconut3> i do need to store user profile and have authentation
22:42:56 <sleblanc> coconut3, I do not have experience with Yesod in particular, but if you need to speak HTTP, you will need some form of framework (unless you want to roll your own)
22:43:23 <sleblanc> coconut3, and a framework will often take care of the gritty details of authentication
22:44:30 <coconut3> sleblanc, thanks
22:45:07 <sleblanc> but I suggest you give SQLite a try
22:51:27 <coconut3> it does attracts me for its small size suitable for mobile devices
22:51:42 <sleblanc> Check out their test suite
23:01:50 <coconut3> sleblanc, it only starts to provide json support recently...
23:14:15 <mjrosenb> I think I've asked this before, but in emacs, with haskell mode, when I go to launch a haskell interpreter, it asks if I want to start a new project
23:14:21 <mjrosenb> what exactly does that entail?
23:14:49 <mjrosenb> like, is it making permanent changes on the disk, or is it just setting up some session-local stuff?
23:27:53 <KaiJia> hello
23:28:30 <liste> hello KaiJia
23:33:05 <Sonarpulse> has anyone propose making a new template haskell that doesn't share any definitions with code proper
23:33:09 <Sonarpulse> so it works with cross compilers?
23:41:20 <mjrosenb> is it possible to blow away all locally installed packages, from a sandbox, without also blowing away the added sources?
23:43:54 <mjrosenb> oh, and now it is trying to upgrade sdl2 to 2.1.0
23:44:04 <mjrosenb> even though my local sources for it only have 2.0.0?
23:44:07 <mjrosenb> I'm so confused.
23:50:49 * hackagebot hpqtypes 1.4.4 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.4.4 (arybczak)
