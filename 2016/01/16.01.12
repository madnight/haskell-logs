00:00:00 * hackagebot hasql 0.19.3 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.3 (NikitaVolkov)
00:01:16 <cocreature> ali_bush: not other stack projects, but other cabal projects (which might be part of other stack projects). just put the path to them in the packages section of your stack.yaml
00:04:49 <jgoux> Hi
00:05:05 <liste> hi
00:05:09 <kadoban> ali_bush: You don't need to do anything to be able to use a stack project (which is also a cabal project) elsewhere. You can specify local things as extra-deps in stack.yaml, or git repositories as well.
00:05:22 <jgoux> I need to query both Oracle and Postgresql database in the same app, what's the best libraries out there to do it ?
00:12:49 <ali_bush> thanks
00:13:55 <liste> jgoux maybe something ODBC based, like hdbc-odbc?
00:23:29 <wribbe> Can't seem to find it, is there a way to suggest changes to the wiki (change broken link).
00:25:50 <pavonia> wribbe: It's a wiki, you can make changes yourself
00:26:34 <wribbe> pavonia: need to mail admin for account, just wanted to suggest the new link no plans for major contributions.
00:27:10 <jgoux> liste: I think the ODBC for oracle is my only option, but do I have to use ODBC too for postgres ?
00:28:16 <liste> jgoux no, there's postgresql drivers for just about every Haskell DB library
00:28:20 <phaazon> coucou
00:28:43 <jgoux> liste: ok cool, and if I use HDBC based libraries, they'll all have the same API ?
00:28:54 <liste> yes
00:29:12 <jgoux> I'll try to set hdbc up :D
00:29:19 <jgoux> thank you liste
00:30:40 <liste> yw (:
00:51:20 <quchen> Is there a lens to focus on all duplicate elements of a list?
00:51:45 <quchen> So if I had [1,2,X,3,X,5,6] it'd give me [X,X]
00:52:23 <magthe> quchen: you mean like a drunken lens?
00:52:45 <magthe> ah, sorry, misread, I thought you wanted a lens that duplicated all elements of a list ;)
00:55:04 * hackagebot human-readable-duration 0.1.1.0 - Provide duration helper  https://hackage.haskell.org/package/human-readable-duration-0.1.1.0 (yogsototh)
00:55:30 <jle`> quchen: you feel like breaking laws today?
00:55:53 <quchen> I have a requirement and need it met, that's what I feel like. :-)
00:56:08 <jle`> blaspheme
00:56:47 <quchen> Okay, I'll bite, what laws?
00:58:17 <jgoux> I have a hard time with stack xD
00:58:33 <mniip> for starters is it mathematical laws or constitutional laws
00:59:01 <jgoux> I have ghc-mod version 5.4.0.0 compiled by GHC 7.10.2
00:59:21 <jgoux> but when I do "ghc --version" it's the 7.8.4
00:59:22 <mniip> quchen, also that sounds more like a traversal than a lens
00:59:39 <jgoux> how can I update ghc with stack ?
00:59:41 <jle`> view l (set l b a) /= b
00:59:57 <jle`> you can set duplicate elements in a way that introduces new duplicate elements
01:00:06 <parsnip> hmm, i'm using TAGS table in git cloned hakyll to help me read my sites site.hs. is there an easier way? maybe M-x hoogle? 
01:00:16 <mniip> or you can try to set [1,2] or something
01:00:28 <jle`> set l c (set l b a) /= set l c a
01:00:32 <quchen> jle`: Oh, right. Damn.
01:00:34 <jle`> setting something once changes the duplicate set
01:00:47 <kadoban> parsnip: Err, you're doing what?
01:01:12 <jle`> and i'm pretty sure it breaks compsition laws too
01:01:14 <jle`> :O
01:01:42 <jle`> i don't know how but somehow my program acquired a memory leak
01:02:02 <parsnip> kadoban: i have a blog config file site.hs, and the definitions are in hakyll/src/
01:02:04 <jle`> but i don't feel like debugging
01:02:17 <ReinH> jle`: yes, "your program" did the acquiring.
01:02:38 <parsnip> i generated TAGS in that repo, and can jump to the definition, but it doesn't seem like the right way. 
01:02:48 <ReinH> parsnip: the right way to do what?
01:02:55 <jle`> yes i was doing just fine until it decided to pick up a memory leak
01:02:57 <quchen> jle`: Stack, heap?
01:03:01 <parsnip> to read the config file in my blog
01:03:05 <jle`> i'm not sure
01:03:11 <ReinH> parsnip: I don't understand.
01:03:19 <ReinH> Wat's wrong with it?
01:03:57 <jle`> it's just training a neural network, but the epochs today train in ~40% longer duration than they did yesterday
01:04:21 <jle`> i can probably just quit and re-load 
01:04:52 <parsnip> i have ~/blog/site.hs, a config file i'm not sure how to tweak. i want to check the types and maybe the actual definitions of things, so i did git clone of hakyll and did hasktags on ~/my-repos/hakyll/src/
01:05:29 <parsnip> not sure if this is a good way to go. can i use hoogle somehow? 
01:05:33 <jle`> i'm probably leaking dupChans but i don't think they would account for such a discrepency
01:05:49 <jle`> oh i don't know if it's actually a memory leak becuase i don't know how to check memory usage
01:05:55 <jle`> is that a unix command or something
01:06:15 <jle`> oh it shows up right there on `htop`.  hm.  doesn't seem to be any significantly bigger than it was yesterday
01:06:22 * jle` shrugs
01:06:23 <parsnip> on a positive note, i found http://hackage.haskell.org/package/hakyll-4.7.5.1/docs/, where at least clicking on source doesn't take me to a 404. 
01:08:49 <parsnip> oh, it was just broken at the author's self hosted haddocks https://jaspervdj.be/hakyll/reference/src/Hakyll-Core-Compiler-Internal.html#Compiler
01:14:58 <frerich> I often saw the notation of 'a ~ Int' or 'b ~ Int -> Bool' when talking about polymorphic functions ("unifying" types?). Is it also legal to write something like 'a -> b ~ Int -> Int -> Int, thus a ~ Int, b ~ Int->Int'?
01:15:19 <frerich> Is the tilde read as 'unifies' or 'corresponds to' or 'is' or something?
01:15:28 <quicksilver> yes. one of those.
01:15:54 <quicksilver> "unifies with" is possibly good
01:16:03 <quicksilver> although the theory refers to them as type equalities
01:16:19 <jle`> in my mind i read it as 'equals'
01:16:56 <frerich> I always read it as 'corresponds to'. However, I also still read 'combinator' as 'building brick' :-}
01:17:21 <frerich> I don't know where those terms come from so I made a bad habit of translating them in my mind.
01:19:28 <quicksilver> they always say when learning a foreign language
01:19:33 <quicksilver> you *shouldn't* translate terms in your mind
01:19:36 <quicksilver> you should read them as they are.
01:20:12 <frerich> I know, I readily admitted it's a bad habit! That's why I'm asking for what '~' means because 'a tilde Int' does not work very well.
01:20:24 <frerich> Or 'a squiggly line Int'
01:23:59 <quicksilver> remember they're in a constraint
01:24:04 <quicksilver> so they're to the left of an =>
01:24:12 <quicksilver> a ~ b => a -> b
01:24:25 <frerich> Oh, they are valid Haskell syntax? Heh!
01:24:28 <quicksilver> "given that a is equal to b, a function from a to b"
01:25:16 <frerich> I thought it was just some common notation people made up to talk about what happens when you apply a polymorphic function to some value, or when talking about how types are inferred in general.
01:25:20 <frerich> Oops.
01:31:05 <frerich> Hm, apparently called 'equality constraints', so 'equals' is maybe indeed a good way to read it.
01:31:20 * frerich will have to re-read https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/equality-constraints.html a few times to grok how it's useful
01:33:52 <Wizek> Anyone knows if there is some documentation for GHCJS, and if so, where? Googling around only leads me to ghcjs-dom on hackage, but very little to nothing about GHCJS itself.
01:37:53 <merijn> Wizek: I think there's a #ghcjs, and there should be stuff linked from luite's blog
01:42:02 <wedens>  how can I use ghci with some static C library? I use stack and Custom cabal build to specify path to .a and includes
02:00:09 <roelof> I think a beginners question : How can I make a empty map in ghci so I can use it for testing some functions 
02:00:31 <roelof> I thought let test = map.Empty would do it 
02:01:10 <frerich> roelof: You could do something like 'import qualified Data.Map as M' and then 'M.empty' gives you an empty map.
02:01:43 <frerich> roelof: You could also just 'import qualified Data.Map' and then use 'empty' but I'd feel uneasy with having the name 'empty' taken already :-)
02:01:47 <roelof> oke, can I now give it a name so I can use the empty map 
02:02:26 <quicksilver> frerich: it is useful (partly) for slightly obscure reasons to do with how instance search works.
02:02:52 <quicksilver> it is convenient to defer the enforcement of equality to the constraint solve
02:03:07 <jgoux> does anyone use Atom editor + stack successfully ? (with the latest resolver LTS)
02:03:16 <quicksilver> and it has implications for what counts as an overlap
02:03:21 <quicksilver> I don't understand it properly myself.
02:04:11 <frerich> quicksilver: Uh-oh
02:04:40 <quicksilver> it is also how GADTs always worked
02:04:50 <quicksilver> it's just that when GADTs were the only application of it, it could be hidden and not appear in user types
02:06:11 <roelof> frerich:  thanks, solved it 
02:06:42 <frerich> roelof: Oh, sorry - yes, you can give a name to it as usual, like 'let tim = empty'.
02:07:15 <roelof> frerich:  Np , I solved it with tim = M.empty 
02:13:09 <hunteriam> how do i unregister all the packages listed as failing by ghc-pkg check?
02:16:41 <merijn> hunteriam: Creative use of grep, awk, xargs and "ghc-pkg unregister"?
02:20:11 <meretrix> join #programming
02:23:32 <diggle> Hi. I'm a fairly new Haskell learner (started learning for like 1-2 days now...). I just want to know if someone can explain this line? I think I get it a little, but I don't know how it works completely. fib = 1 : 1 : map (\(a,b) -> a + b) (zip fib (tail fib))
02:24:51 <bernalex> diggle: try breaking it down a bit. (\(a,b) -> a + b) is just uncurry (+). i.e. apply (+) to e.g. (1,2) instead of 1 and 2 as independent arguments.
02:24:54 <jle`> do you know what : does ?
02:25:10 <bernalex> > 1 : 1 : []
02:25:12 <jle`> `x : xs` creates a list where x is the first item, and xs is the rest of the list
02:25:12 <lambdabot>  [1,1]
02:25:18 <jle`> so, the first item in fib is 1
02:25:23 <jle`> the second item is 1
02:25:27 <jle`> now think about what the 3rd item is
02:25:28 <bernalex> > tail [1, 2, 3]
02:25:29 <lambdabot>  [2,3]
02:25:44 <bernalex> > zip [1, 2] [3, 4]
02:25:46 <lambdabot>  [(1,3),(2,4)]
02:26:10 <bernalex> diggle: thanks to how independently all of these things work, you can investigate the small parts by themselves, and then try to understand what they do together.
02:26:31 <bernalex> diggle: does that help? is there a particular subexpression you are having trouble with?
02:26:35 <merijn> I think the map + zip is confusing, I think the zipWith implementation is clearer
02:27:08 <mniip> ^ thought of that too
02:27:33 <mniip> something something
02:27:44 <mniip> > let fib = 1 : scanl (+) 1 fib in fib
02:27:45 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:27:52 <diggle> I get as far as the zipped part. I think it works by making pairs and adding them, like (1, 1) becomes 2. Then after appending 2, the expression is still unevaluated because it's in the tail, so it does the tail again. Wha ti'm having problem is is that i'm wondering if it reconstructs all the list all over again after each evaluation.
02:28:40 <mniip> diggle, no there's only one list
02:30:54 <jle`> diggle: okay, the first item is 1, the second item is 1
02:30:56 <jle`> what's the third item?
02:31:08 <jle`> the third item is the first item of zipWith (+) fib (tail fib)
02:31:17 <diggle> Okay. Um. correct me if i'm wrong (which I probably am, but...). the function in map is a pattern match which basically adds 2 values. so first we get (1, 1), which is 2, which gets appended. then we get (1, expression) because the expression is still unevaluated and in the tail.
02:31:17 <jle`> what's the first item of zipWith (+) fib (tail fib) ?
02:31:30 <jle`> hold up
02:31:34 <jle`> what is the first item in `tail fib` ?
02:31:37 <jle`> tail (x:xs) = xs
02:31:47 <diggle> 1
02:31:53 <jle`> exactly
02:32:02 <jle`> so, what's the first item in zipWith (+) fib (tail fib) ?
02:32:08 <merijn> I'm not sure I'd say that the 2 "gets appended"
02:32:15 <diggle> (1, 1)
02:32:28 <merijn> That implies the list is modified, whereas it's really "already part of the list", just not computed yet
02:32:31 <jle`> i mean, the first item in map (blah blah) (zip fib (tail fib))
02:32:36 <jle`> it's 2, right?
02:32:48 <diggle> Nod.
02:32:51 <jle`> so, the first item of your list is 1.  the second item is 1.  the third item, we just found out, was 2
02:32:55 <jle`> can you figure out what the fourth one is?
02:33:00 <jle`> (hint: it's going to be 3)
02:33:12 * jle` is bad at giving subtle hints :|
02:33:26 <diggle> Er...maybe 3?
02:33:34 <mniip> hint: snape dies
02:33:54 <jle`> heh
02:33:57 <jle`> can you see why it's 3? :P
02:34:01 <diggle> Harry does too but anyhooooww...
02:34:21 <jle`> you figured out that zipWith (+) fib (tail fib)'s first item is 2
02:34:28 <jle`> can you figure out what the second item is...
02:34:39 <jle`> it adds the second item of fib with the second item of (tail fib)
02:34:40 <diggle> Yeah, that I can understand, because it goes 1+2, because that's the thing you get when you do zip fib (tail fib)
02:34:48 <jle`> mhm.  it adds 1 with 2
02:34:50 <jle`> and it's 3
02:34:54 <jle`> ta dah
02:34:57 * frerich thinks it would be nice to have some sort of whiteboard functionality built into IRC, this kind of sharing stuff is much easier to explain when you have arrows and boxes at your disposal.
02:35:05 <merijn> mniip: Technically everyone dies, since Nicholas Flamel gave up the philosopher's stone to be destroyed no one is immortal ;)
02:35:21 <merijn> mniip: Well, I suppose there could be more people using horcruxes...
02:35:21 <diggle> Or so you think. erm.
02:35:42 <merijn> Time to go be off-topic in -blah :p
02:35:49 <jle`> if you had a paper and pencil, you can write this down by hand
02:35:53 <diggle> I mean of course i'm going to give the only item that saves my existance to a person I know for like 15-25% of your life
02:35:54 <jle`> and figure out the 5th, 6th items, etc.
02:36:39 <diggle> But...yeah, I think I understand this. It just twisted my brain a little, but now I think I can understand it
02:36:49 <diggle> Thanks
02:37:47 <cocreature> is there a nicer solution for passing things to functions such as typeOf than (undefined :: Int) (replace Int with whatever type you want)?
02:37:54 <merijn> Man, I should redo my time travelling function as a gist to fry people's brain after they've recovered from fibs ;)
02:38:00 <merijn> cocreature: Proxy
02:38:24 <merijn> cocreature: "data Proxy a = Proxy" "foo :: proxy a -> Foo" in your class instead of "foo :: a -> Foo"
02:38:46 <merijn> cocreature: (lowercase proxy as a type variable so people can use, e.g. "Maybe Int" instead of "Proxy Int" if they have one
02:38:51 <cocreature> merijn: I was hoping to get away without passing in a parameter
02:38:57 <diggle> I uh. I think i'll prefer my brain in a un-fried state :P
02:39:05 <merijn> cocreature: Not really, sadly
02:39:21 <cocreature> merijn: alright, thanks
02:39:50 <cocreature> oh looks like the new typerep already accepts a proxy
02:39:56 <cocreature> so I get away with scoped type variables
02:40:08 * hackagebot ghc-dump-tree 0.2.0.0 - Dump GHC's parsed, renamed, and type checked ASTs  https://hackage.haskell.org/package/ghc-dump-tree-0.2.0.0 (EdskoDeVries)
02:48:37 <spuz> mniip: the scanl implementation looks simpler than the zip implementations. is there a disadvantage to using scanl?
02:48:52 <mniip> not that I know of
02:49:21 <spuz> what does the 'in' mean in that syntax?
02:49:47 <spuz> oh it's just part of let
02:50:57 <jle`> cocreature: there will be a new syntax in 8.0
02:51:15 <cocreature> jle`: yeah I know, but that doesn’t help me if I need it right now :)
02:51:55 <jle`> yeah, heh
02:52:09 <jle`> the currently accepted way is yeah, foo :: proxy a -> blah
02:52:11 <cocreature> sometimes I feel like the js guys. the version of ghc that I want to use is always the next version
02:52:30 <jle`> this approach is somewhat endorsed by GHC in base's GHC.TypeLits
02:52:46 <jle`> but, TypeLits is fairly old, so don't take it for too much, heh
02:53:16 <cocreature> I’m still annoyed by the fact that strings and nats don’t have “normal” singletons but instead you have to use this weird typeclass approach
02:54:08 <cocreature> but I suppose a separate constructor for each value is just not feasible
02:56:03 <hunteriam> https://www.irccloud.com/pastebin/kpjutZX0/
02:56:14 <hunteriam> ive installed MinGW+MSYS, how do i get stack tos ee it/
02:56:15 <hunteriam> ?
02:58:09 <liste> hunteriam can you run it from msys shell?
02:59:45 <hunteriam> i never had to do that before..
03:15:14 * hackagebot helix 0.9.5 - Web development micro framework for haskell with typesafe URLs  https://hackage.haskell.org/package/helix-0.9.5 (AnupamJain)
03:20:14 * hackagebot monad-logger 0.3.17 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.17 (MichaelSnoyman)
03:32:25 <Fuuzetsu> @pl f x = g x $ a $ b $ c
03:32:25 <lambdabot> f = flip g (a (b c))
03:40:57 <Gurkenglas> http://lpaste.net/3014728417980448768 why does this say ambigious infix expression until I put brackets around the "guard . not"?
03:41:06 <Gurkenglas> @letlpaste 3014728417980448768
03:41:06 <lambdabot>  Parse failed: Ambiguous infix expression
03:41:10 <Gurkenglas> :t ?f . ?g <=< ?h
03:41:11 <lambdabot> (Monad m, ?f::b1 -> m c, ?g::b -> b1, ?h::a -> m b) => a -> m c
03:41:46 <opqdonut> @info (<=<)
03:41:46 <lambdabot> (<=<)
03:41:48 <opqdonut> bah
03:41:52 <merijn> There is no @info
03:42:02 <merijn> And no one ever seems to remember that >.>
03:42:04 <opqdonut> anyway, it's "infixr 1"
03:42:36 <opqdonut> hmm, which should be ok
03:42:39 <opqdonut> since . is infixr 9
03:43:23 <Gurkenglas> As my :t line should validate :/
03:54:02 <hawnzug> @help
03:54:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:54:54 <hawnzug> @kind Maybe
03:54:55 <lambdabot> * -> *
04:00:43 <cloudhead> Hey, on the docs of the Network package, it says to use Network.Socket instead, but that's a lot lower-level, is there another package people are using for high level networking?
04:01:40 <cloudhead> And why are the high level interfaces being deprecated?
04:02:05 <merijn> cloudhead: It was deprecated because it didn't work out as well and nicely as expected
04:02:44 <cloudhead> merijn: ah.. cross platform issues or something else?
04:03:05 <merijn> cloudhead: The high level handle interface doesn't give you access to any of the socket options you might want to set
04:03:37 <merijn> And reworking it so that it does let you control those things didn't seem realistic, afaict
04:04:05 <merijn> So basically, if you're happy with the high level interface, it's fine, but if you need any form of control you're better of using the low level API
04:04:22 <cloudhead> gotcha, thanks
04:06:37 <merijn> bah...
04:07:02 <merijn> Why doesn't pipes-text have a simple combinator to turn into a line producer? :(
04:08:40 <ssaa> Lista
04:08:40 <ssaa> Lista
04:08:40 <ssaa> Lista
04:08:41 <ssaa> Lista
04:08:41 <ssaa> Lista
04:11:17 <quchen> merijn: I guess with "simple" you want to exclude the horror that "lines" is?
04:11:53 <merijn> quchen: That means I need go and get lens to build on our cluster and figure out how to fit that into things
04:12:25 <quchen> And then unroll the FreeT and then work with the lines
04:12:27 <merijn> I just wanted "fromHandle :: Producer Text m r" that produces lines of text :\
04:12:35 <angerman> If I have `data X a where s = X Bool deriving (Generic)`, I get  has existentials or constraints in its type. Any way around this?
04:12:41 <merijn> eh "Handle -> Producer Text m r"
04:12:48 <quchen> Or a Pipe Text [Text] m r
04:14:17 <liste> @paste -- angerman can you paste the original code?
04:14:18 <lambdabot> Haskell pastebin: http://lpaste.net/
04:14:45 <angerman> liste, give me a second. I'll boil it down to a sample.
04:16:53 <angerman> liste http://lpaste.net/7845954666155212800
04:18:53 <merijn> quchen: The pipes-text docs are attempting to convince me that wanting "lines :: Monad m => Pipe Text Text m r" is unreasonable, which is filling me with seething hate
04:19:36 <quchen> merijn: Where does it say that
04:19:48 <merijn> In the Tutorial thing
04:20:05 <merijn> "because you'd lose control over the chunking"
04:20:10 <jle`> angerman: can you standalone deriving?
04:21:22 <angerman> jle` as in `deriving instance Generic (X a)`?
04:21:26 <quchen> merijn: I don't understand the docs, and I think it's a bad package if it forces that on me.
04:21:38 <quchen> Chunking is great, unless you don't want it.
04:21:55 <quchen> Or in case you don't care about "preserving it".
04:23:20 <merijn> quchen: Yeah, I get the "I want to process in constant space" goal, but sometimes I just want freaking lines >.>
04:23:34 <angerman> jle` not sure if I'm running into: https://ghc.haskell.org/trac/ghc/ticket/10514 :-/
04:25:23 <quchen> merijn: To make things worse, a lens is the only API to using lines
04:25:55 <quchen> I don't understand why anyone would "lensify the main API". Including lenses in their own modules is fine, but the whole API is a nightmare.
04:29:00 <Hafydd> Heh.
04:30:17 * hackagebot biohazard 0.6.1 - bioinformatics support library  https://hackage.haskell.org/package/biohazard-0.6.1 (ustenzel)
04:33:34 <merijn> quchen: The missing link was apparently Pipes.Group.concats
04:33:44 <merijn> concats :: Monad m => FreeT (Producer a m) m x -> Producer a m x
04:34:56 <aweinstock> :t FreeT
04:34:58 <lambdabot> Not in scope: data constructor ‘FreeT’
04:34:59 <cocreature> merijn: if it helps: pipes-text doesn’t depend on lens, so you can just roll your own view and get away with not building lens
04:35:16 <quchen> lens-family should be enough anyway
04:35:17 * hackagebot hformat 0.1.0.0 - Simple Haskell formatting  https://hackage.haskell.org/package/hformat-0.1.0.0 (AlexandrRuchkin)
04:35:19 * hackagebot text-region 0.1.0.0 - Provides functions to update text region positions according to text edit actions  https://hackage.haskell.org/package/text-region-0.1.0.0 (AlexandrRuchkin)
04:35:41 <cocreature> or that yeah
04:40:17 * hackagebot hsdev 0.1.5.0 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.5.0 (AlexandrRuchkin)
04:49:12 <ironChicken> cool. i wonder if hsdev works with emacs
04:50:34 <Wizek> merijn, Thanks, I did find the blog somewhat useful, but not as much as I would like. E.g. I can't figure out if/how it might be possible to export Haskell functions and values to JavaScript. I could only find info and compile the other way around.
04:53:09 <merijn> Wizek: Pinging him here wouldn't hurt, he's here often enough and presumably knows best where to find info :p
04:54:17 <Wizek> luite, Might you be around?
05:24:56 <nut> Hi, when i cabal repl into ghci, how do i load the functions defined in Main.hs
05:25:21 <opqdonut> import Main?
05:25:35 <apriori> nut best is to cabal repl directly the executable you're interested in 
05:25:39 <apriori> as specified in the .cabal file
05:25:42 * hackagebot hsdev 0.1.5.1 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.5.1 (AlexandrRuchkin)
05:25:44 * hackagebot hackage-security 0.5.0.2 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.5.0.2 (EdskoDeVries)
05:26:11 <nut> apriori, how ?
05:26:30 <apriori> say your cabal file defines an executable, using the executable paragraph
05:26:33 <apriori> say its called "bla"
05:26:41 <apriori> then just call: "cabal repl bla"
05:26:46 <nut> ok
05:26:47 <nut> thanks man
05:26:50 <nut> or woman
05:27:00 <apriori> in case both executable and lib are called the same, then the more qualified form:
05:27:02 <apriori> cabal repl exe:bla
05:27:23 <apriori> np (and man)
05:28:23 <nut> thanks, i just changed the exe name...
05:29:00 <apriori> afaik, if there is only one executable it should default to that one when calling cabal repl
05:32:19 <statusfailed> Is it possible to put constraints on a class instance? e.g.,: "class Foo a; newtype T t = T { unT :: t }; instance Bar a => Foo (T a)" ?
05:32:31 <statusfailed> I get a kind error, I don't know if there's an alternate syntax
05:32:48 <merijn> statusfailed: Yes, but note that it will overlap with every other instance of Foo for T
05:33:06 <merijn> statusfailed: Kind error? lpaste the source
05:33:08 <statusfailed> oops, "class Foo repr where foo :: repr a -> repr a" for example
05:33:27 <statusfailed> I'll do a proper example heh
05:33:32 <merijn> statusfailed: That doesn't work
05:33:57 <merijn> statusfailed: "Foo :: (* -> *) -> Constraint" and "Bar :: * -> Constraint"
05:34:18 <merijn> So that means "a :: *" and "T a :: *" which means "Foo (T a)" is nonsense
05:35:51 <statusfailed> Right, I think I see what you mean
05:36:10 <statusfailed> So there's no way to limit "Foo" instances to ones where "a" is a specific type
05:36:15 <statusfailed> because the class definition says it has to work for all a
05:36:22 <statusfailed> is that fair?
05:40:42 * hackagebot biohazard 0.6.2 - bioinformatics support library  https://hackage.haskell.org/package/biohazard-0.6.2 (ustenzel)
05:43:28 <jgoux> After one hour trying to make Atom works with Haskell; I installed spacemacs xD
05:46:17 <apriori> jgoux, what was your issue?
05:48:34 <merijn> statusfailed: Yes
05:50:15 <jgoux> apriori: I installed stack, made a project, installed all the package required for haskell-ide on Atom, but ghc-mod crashed as soon as I save a .hs file
05:50:42 <jgoux> apriori: At the moment there is no official support for stack
05:51:56 <apriori> jgoux, yeah, well, my general experience with Atom so far is: its ghc-mod interop is buggy as f*ck
05:53:14 <statusfailed> merijn: thanks :-)
05:54:46 <happy0> 0
05:55:43 * hackagebot megaparsec 4.3.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-4.3.0 (mrkkrp)
05:55:45 * hackagebot wai-extra 3.0.14 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.14 (MichaelSnoyman)
05:57:14 <hodapp> yikes, is Atom support that bad?
05:57:20 <hodapp> I was just a lazy bum and stuck with Emacs
05:57:41 <apriori> hodapp, its not bad, no. but has severe issues with ghc-mod.
05:57:51 <hodapp> hum, I've never really used ghc-mod
05:58:01 <apriori> so far, only 3 months ago I had something "stable" (aka, not spamming your screen with tons of popups because of issues with ghc-mod)
05:58:09 <apriori> everything after that broke it, more and more
05:59:15 <apriori> back then it was even a nice experience. proper completion, warning/hlint highlighting
05:59:35 <apriori> but now its: open a .hs file, do something with, enjoy the 5 popups of some ghc-mod related issues
06:00:44 <maerwald> yeah, I'd reccomend not to use ghc-mod. Upstream also seems unwilling to care about any sort of stable API, causing developers from e.g. syntastic to abandon ghc-mod support
06:01:02 <apriori> maerwald, might be, but haskell-ide isn't quite there, yet
06:01:11 <maerwald> that's not the only alternative
06:01:19 <apriori> could you name others?
06:02:37 <merijn> hdevtools?
06:03:13 <merijn> Not sure if the one on hackage is still maintained, but there's a bunch of branches supporting recent versions of GHC on github and it works for me
06:03:37 <apriori> what editor are you using?
06:03:40 <merijn> vim
06:03:46 <apriori> ok
06:04:00 <merijn> together with syntastic
06:04:01 <apriori> yeah, well. I'm searching for an "ide-like" experience for a while now
06:04:16 <merijn> I guess that depends what "ide-like" means to you
06:04:19 <apriori> tried vim, leksah and Atom so far. Atom (when it was stable) came closest
06:04:36 <apriori> yeah, well, lets say, a bit more than a tabbed editor.
06:04:48 <merijn> I mean, I'm the kind of person who always works on 20k+ SLOC C++ codebases using vim, so take anything I say with a grain of salt :)
06:05:21 <apriori> yeah, well, as long as we won't go the religious "I'm right with everything" route, it's all fine :)
06:05:33 <apriori> 20k sloc c++.. wouldn't ever do that in vim ;)
06:05:41 <apriori> maybe something like QtCreator or so
06:05:51 <merijn> I'm always right, but I don't judge people desperately wanting to be wrong ;)
06:05:55 <apriori> hehe
06:06:15 <frerich> apriori: merijn readily acknowledges that there are always two opinions. His, and the wrong one.
06:06:33 <apriori> frerich, its a step before "I'm always right" - so I'm fine with that ;)
06:06:35 <merijn> apriori: All I generally use is error highlighting, jump to definition and fuzzy file opening, and I've got that covered :p
06:07:05 <apriori> merijn, although I totally admit that workign 100% with the keyboard is the fastest
06:07:11 <apriori> I never was that type of person
06:07:30 <apriori> (even with ~15 years of linux experience)
06:07:49 <dgpratt> I've been trying in fits and starts to get on with spacemacs
06:08:01 <apriori> might try spacemacs right now
06:08:10 <apriori> because stack & ghcjs is currently giving me headaches
06:08:15 <dgpratt> in theory I quite like it, but in practice it's been a struggle
06:08:18 <Ankhers> spacemacs is pretty interesting.
06:08:29 <Ankhers> I'm trying it out (again) right now.
06:09:07 <frerich> apriori: At a certain point, the number of lines of code doesn't matter at all. I've been using vim for 18 years I think, right now it's a code base of 796k lines of code according to sloccount (581k of which is C++). You never see all of it at once anyway. You just jump around.
06:09:22 <dgpratt> I would think anyone comfortable with vim would have a leg up on spacemacs
06:09:57 <apriori> frerich, I know it quite doesn't. its a matter of "style" and taste. 
06:10:30 <apriori> frerich, going that way, your vim quite obvious is not the "full" idea, you have to have multiple clis opened, e.g. for building and such
06:10:43 <apriori> either that, or you use tabs in vim and execute the buildsystem there
06:10:44 <frerich> apriori: Of course, right.
06:11:05 <spuz> apriori: what did you find lacking with Atom (i've not tried it yet)
06:11:54 <apriori> spuz, stack support. _stability_ (can't even stress that enough). jump to definition not working. conflicting ways to show hlint suggestions.
06:12:17 <MarcelineVQ> for atom I stopped having stability issues when I started using binary releases
06:12:32 <spuz> apriori: stack support would be great but stack is very new as far as I understand. stability sounds like an issue though
06:12:34 <apriori> performance though was nice (for completion, for example). and that is e.g. where eclipse (yuck, eclipse) is lacking massively. its integration is slow as f*ck.
06:12:38 <dgpratt> apriori, I agree with you -- there was one brief shining moment for me when atom worked really well
06:13:19 <apriori> dgpratt, guess we have to do some debugging ourselves and assist the author to get it right
06:13:28 <dgpratt> though things move fast and I haven't gone back to it since at least a couple months ago
06:14:05 <apriori> dgpratt, yeah, well, it also had some issues with build environments
06:14:24 <apriori> say e.g. multiple ghc versions and such. and that can be solved more easily with stack
06:15:38 <merijn> Multiple GHC versions has always been really easy, for me at least
06:15:49 <apriori> MarcelineVQ, for the editor you mean, I guess. 
06:16:21 <merijn> Hell, I just got GHC setup on the cluster after doing some stuff with Python...nothing makes me appreciate GHC and cabal more...
06:16:23 <apriori> yeah, I'm doing that as well. but I meant more the plugins for haskell support constantly complaining with popups.
06:16:47 <apriori> merijn, on a cluster? what are you working on?
06:17:31 <merijn> apriori: Number crunching on the university cluster, but most of my glue code (and in fact all of the job scheduling stuff atm) is in Haskell
06:17:58 <apriori> merijn, sounds like an interesting project. are you using cloud haskell?
06:18:08 <MarcelineVQ> Yes, the plugins are quite stable too for me, one trick with software constantly being update is to not update if things are working correctly though. atom's haskell plugins don't handle a complex project like ghc very well but I don't have issues with most projects I've gotten off git projects or my own
06:18:35 <MarcelineVQ> so far stack integration works quite well
06:18:38 <merijn> No, I'm just using createProcess to call out to the job queue
06:18:40 <apriori> MarcelineVQ, yeah, on such big projects I was constantly running out of memory.
06:19:10 <apriori> merijn, ok. anyway, cloudhaskell is kind of like Erlang for haskell. maybe you have some use for it.
06:19:53 <ggVGc> if I do hGetContents on an infinite stream of input, how do I close it when I decide I don't want more?
06:20:04 <ggVGc> if it's opened using withBinaryFile
06:20:06 <merijn> ggVGc: You hope it gets GCed
06:20:07 <apriori> given how often haskell-ghc-mod (the Atom plugin) gets updated though, it seems like the author is really fighting with the stability issues and trying to get them sorted.
06:20:26 <merijn> ggVGc: And keep your fingers crossed
06:20:38 <merijn> ggVGc: In other words, this is why pipes and conduit were invented ;)
06:20:47 <ggVGc> merijn: how would I do it in a more explicit way? I want to read a lazy bytestring from a system device into a paring function ByteString -> a, but I want to be able to stop at any point
06:20:57 <ggVGc> alright
06:21:36 <apriori> afaik a lot more libs are having conduit support
06:21:47 <apriori> I was quite amazed when I looked at it a few weeks ago
06:22:09 <montonero> Hey guys,  learning HXT and arrows here. Could not figure out how to convert [XmlTree] back to arrow so that I can do some parsing several times: http://lpaste.net/148863
06:23:42 <merijn> montonero: Not directly helpful, but: Have you looked at xml-conduit? HXT always struck me as very complex for the kind of XML parsing I've needed to do
06:24:44 <MasseR> The pseudo-xpath is surprisingly good
06:25:37 <montonero> merijn: yes, it is very difficult to get into. Especially if one does not have previous experience with arrows (like me) - but I like challenge ;)
06:25:58 <argoneus> are there any good tools for making wrappers around C++ libs?
06:26:09 <argoneus> or is it mostly manual
06:26:11 <apriori> argoneus, uargh. 
06:26:20 <apriori> mostly manual, maybe swig (barely ever used)
06:26:39 <argoneus> I read some examples on C code
06:26:41 <frerich> argoneus: There is https://hackage.haskell.org/package/cgen but I never tried that
06:26:46 <argoneus> but I'm not sure how to represent a class in haskell
06:26:48 <apriori> argoneus, because C is much easier to bind to 
06:27:17 <argoneus> if it helps I'm trying to wrap BWAPI, or at least parts of it
06:27:25 <argoneus> basically a library that interfaces with brood war and gives you access to gamestate etc
06:27:33 <merijn> argoneus: You can't really represent a class, there's no C++ FFI, just a C one.
06:27:34 <argoneus> and there's some classes like Player, Unit, etc
06:27:34 <apriori> argoneus, ah, starcraft AI dev?
06:27:40 <argoneus> yeah
06:27:52 <argoneus> I originally wanted to just try it in C++ or Java
06:28:02 <merijn> argoneus: So the usual way would be: 1) wrap C++ library with "extern C" interface 2) wrap C interface in Haskell
06:28:04 <argoneus> but seeing as I like haskell and wanted to practice it, I was wondering if this was realistic
06:28:18 <apriori> argoneus, search for a C binding and wrap that.
06:28:21 <merijn> argoneus: Also, cool, I'd love to play with any haskell interface you come up with :)
06:28:33 <argoneus> I started learning haskell like a week ago
06:28:39 <argoneus> so any haskell interface is a few years away :P
06:29:16 <Xandaros> Raw bindings aren't too difficult to make, though insanely tedious. Putting decent functional abstractions on top is where it gets more challenging
06:29:40 <apriori> oh jesus christ. instead of actually providing some proper means, bwapi actually does DLL-injection
06:30:24 <merijn> apriori: What sort of "proper means" do you imagine for hijacking existing binaries?
06:30:44 * hackagebot hasql 0.15.1.1 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.15.1.1 (NikitaVolkov)
06:30:46 * hackagebot hasql 0.19.3.1 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.3.1 (NikitaVolkov)
06:30:47 <apriori> merijn, its not that starcraft was out of support for a decade or something.
06:30:48 * hackagebot human-readable-duration 0.2.0.0 - Provide duration helper  https://hackage.haskell.org/package/human-readable-duration-0.2.0.0 (yogsototh)
06:31:05 <apriori> there were still patches being developed. so it wasn't impossible to implement a sane mechanism later.
06:31:26 <hodapp> apriori: thanks, I've read about DLL-injection and now I'll have nightmares about something additional
06:31:30 <merijn> apriori: By blizzard yes, but how do you imagine non-Blizzard people doing this?
06:31:42 <apriori> merijn, not at all, of course.
06:31:59 <merijn> apriori: Hence the hacky way they managed it. bwapi isn't blizzard supported at all
06:32:00 <apriori> so yeah, purely external, this is the only way
06:32:21 <merijn> argoneus: tbh, if you're familiar with the basics of linking and C/C++ the haskell FFI is pretty straightforward
06:32:47 <argoneus> I've done C/C++ a bit before haskell yeah
06:32:59 <argoneus> so I first need to wrap bwapi in C and then wrap that in haskell?
06:33:03 <apriori> I don't know how complex bwapi is
06:33:08 <argoneus> well
06:33:10 <merijn> argoneus: Yeah
06:33:20 <argoneus> it's basically a set of classes like Unit or Player with methods like selectAllFriendly or something
06:33:22 <apriori> but it might work better, to "just" come up with a complete haskell solution than to bind to bwapi
06:33:26 <argoneus> that's not very functional ._.
06:33:35 <merijn> argoneus: Also, have a look at Chapter 8 of the haskell report, it describes the Haskell FFI
06:33:39 <andreoss> greetings, I'm looking for xmonad design papers, mentioned here https://osdir.com/ml/lang.haskell.cafe/2007-11/msg00483.html
06:33:52 <merijn> argoneus: And should be fairly easy to read for C programmers :)
06:35:22 <merijn> @hoogle Int -> Text
06:35:24 <lambdabot> Data.Text drop :: Int -> Text -> Text
06:35:24 <lambdabot> Data.Text dropEnd :: Int -> Text -> Text
06:35:24 <lambdabot> Data.Text.Unsafe dropWord16 :: Int -> Text -> Text
06:35:57 <merijn> hmmm, I'm really unhappy with "T.pack . show" but I can't find any other efficient serialisation to text?
06:36:22 <byorgey> andreoss: try looking on https://donsbot.wordpress.com/papers/
06:38:07 <mauke`> byorgey: several links, all 403
06:38:26 <merijn> Lots of dons stuff is sadly dead :\
06:38:45 <merijn> I had a link to a paper by him on dynamic plugins in haskell that bitrotted too :\
06:38:49 <merijn> Haven't been able to find it since
06:38:50 <andreoss> found it https://web.archive.org/web/20070904012140/http://www.cse.unsw.edu.au/~dons/papers/haskell51d-stewart.pdf 
06:39:02 <byorgey> mauke`: ah, too bad =(
06:39:06 <andreoss> thought it would be longer though 
06:39:19 <byorgey> three cheers for archive.org
06:40:05 <byorgey> andreoss: yeah, there were never any really formal publications about xmonad
06:40:21 <apriori> merijn, how about good old mod 10/div 10?
06:40:23 <argoneus> merijn: seems like it'd be quite difficult
06:40:24 <argoneus> :(
06:40:32 <byorgey> andreoss: though you might also be interested in http://www.staff.science.uu.nl/~swier004/Publications/XmonadInCoq.pdf
06:41:01 <merijn> apriori: What about mod 10/div 10?
06:41:21 <apriori> merijn, in other words, write your own conversion algorithm directly building a Text
06:41:49 <merijn> apriori: That is most likely even slower
06:45:19 <abacaba> merijn: there's definitely one in text, I remember it being there
06:45:31 <abacaba> it creates a Builder, I think
06:48:10 <abacaba> there's also the text-show package
06:50:47 * hackagebot dawg-ord 0.5.0.1 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.5.0.1 (JakubWaszczuk)
06:59:59 <CasW> Hey guys, what is the type of a function that takes a ProofTree {leaves :: [Assumption], root :: And} and gives a ProofTree? (data ProofTree = {leaves :: [Assumption], root :: Expr}, data Expr = Var [Char] | Is Expr Expr | And Expr Expr | ..)
07:00:51 <frerich> CasW: The type of a function that takes a ProofTree and gives a ProofTree, e.g. 'ProofTree -> ProofTree'? :-)
07:01:16 <geekosaur> tose look like different ProofTree-s? perhaps you want a parameterized type
07:01:17 <CasW> Yeah, but it can only take a specific ProofTree, namely the one with an And Expr as root
07:01:54 <geekosaur> data ProofTree t = ProofTree {leaves :: [Assumption], root :: t} -- then ProofTree And -> ProofTree Expr
07:02:05 <geekosaur> except that And doesn't look like a type to me
07:02:41 <geekosaur> if you really wanted to distinguish those as types, you would need to refactor the definition of Expr
07:03:15 <frerich> CasW: Alternatively, you could also have 'ProofTree -> Maybe ProofTree' which yields Nothing in case the root node of the given tree is not an And expression
07:03:38 <CasW> Hmm, I'll just throw an error if the requirement isn't met
07:05:43 <cbaatz> Does anyone know if there's a common name for a monad that behaves almost like Except other than not aborting on the first failure in the applicative instance and instead accumulating all errors? So something that uses an alternative to Either under the hood whose Applicative behaves as in the `data Except err a = OK a | Failed err` example in McBride & Paterson's Applicative Programming with Effects.
07:07:17 <bennofs> cbaatz: the only way such a thing can work as a monad is if it is a Writer monad
07:07:35 <bennofs> cbaatz: because you need to supply a value, or else the monadic chain cannot continue
07:08:07 <bennofs> cbaatz: if you're ok with it only being an Applicative and not a Monad, I think that http://hackage.haskell.org/package/validation has something like that
07:25:56 <pyon> What does this error mean? “My brain just exploded” [Too much Elm influence here?] “I can't handle pattern bindings for existential or GADT data constructors.”
07:26:47 <benzrf> pyon: i think that error predates elm
07:26:47 <mauke`> you're trying to expose an existential type
07:28:05 <pyon> mauke`: And what's the problem with that? It should just introduce a non-unifiable type variable into the context.
07:28:39 <mauke`> feel free to extend the type checker :-)
07:28:40 <cbaatz> bennofs: So are you saying that writing something like that would mean that the applicative and monad instances would be inconsistent? Basically, it seems like I should be able to use sequence to perform a bunch of computations in parallel (using the applicative) and get either a list of any errors or a list of all results. I have custom coded such a function that specialises the sequence type, but doesn't have the same semantic as the
07:28:40 <cbaatz>  Except instance.
07:29:13 <bennofs> cbaatz: sequance can be done with just the applicative interface
07:29:17 <bennofs> cbaatz: see sequenceA
07:29:23 <umayahabdennabi> does anyone have an example of manually creating a UTCTime?  Like UTCTime {utctDay = ??, utctDayTime = ??}
07:29:23 <exio4> pyon: basically "use case" 
07:29:49 <umayahabdennabi> I am confused about the utctDayTime part, and how to create one
07:29:55 <bennofs> cbaatz: so that works. the problem is when you have something like    x >>= f. What do you do if x fails? You can't run f, since f needs the result of x.
07:30:00 <cbaatz> bennofs: Yes, but the applicative of Either (which Except relies on unless I'm missing something) doesn't have the right semantics for what I want - it aborts early.
07:30:06 <pyon> exio4: Doing that all over the place seems cumbersome.
07:30:17 <bennofs> cbaatz: AccValidation from the validation package does what you want
07:30:19 <exio4> pyon: you can, as always, CPS transform things, too
07:30:30 <pyon> exio4: No, thanks.
07:30:36 <exio4> pyon: (or write unwrapper functions for that)
07:30:51 <bennofs> cbaatz: alternatively, the construction 'Product (Const ErrorType) Identity' should work as well
07:31:14 <bennofs> oops sorry, that was wrong
07:31:24 <bennofs> I meant, 'Product (Const ErrorType) Maybe'
07:33:30 <cbaatz> bennofs: Ah, great. I see the AccValidation isn't particularly common - is that because the use-case isn't common or people end up coding this themselves do you think?
07:34:13 <pyon> exio4: Anyway, I found what I needed to find: Haskell existentials are weak existentials.
07:34:34 <bennofs> cbaatz: yeah, I think it exists in a few different places
07:34:41 <exio4> pyon: I think it's more that let typing rules are simplified
07:35:01 <pyon> exio4: I mean, every time you unpack an existential, you get a fresh new type.
07:35:18 <exio4> alright :)
07:35:22 <pyon> http://lpaste.net/148865
07:35:34 <pyon> If existentials were strong, this would type check.
07:35:45 <cbaatz> bennofs: Understood. Thanks for your help!
07:36:14 * hackagebot split 0.2.3 - Combinator library for splitting lists.  https://hackage.haskell.org/package/split-0.2.3 (BrentYorgey)
07:36:59 <exio4> pyon: care to explain how that makes sense? 
07:37:57 <exio4> pyon: existentials lose information, tracking things that ways sounds quite.. complicated :)
07:38:36 <pyon> exio4: The only thing strong existentials remember is which existentials have already been unpacked.
07:39:00 <pyon> exio4: So unpacking them again gives you the same type, instead of a fresh new one.
07:39:23 <exio4> ok
07:40:34 <mauke`> that means you'd have to track sameness of values somehow
07:40:38 <pyon> exio4: But I guess this isn't easy with first-class existentials. For instance, it's clear that, with strong existentials, unpacking `pack` twice should give the same hidden type. But what about unpacking `pack` and `const pack ()`? Not so clear anymore. :-p
07:40:47 <codedmart> If I run `stack setup` `stack build` or `stack update` it just stalls on `Updating package index Hackage (mirrored at https://github.com/commercialhaskell/all-cabal-hashes.git) ...` and nothing ever happens? 
07:41:06 <pyon> mauke`: Alternatively, a conservative rule could be used.
07:41:17 <exio4> that sounds more complex than what it needs to be
07:41:23 <mauke`> pyon: if pack is a method, unpacking it twice could give different results
07:41:28 <mauke`> (if you unpack it at different types)
07:41:46 <wedens>  how can I use ghci with some static C library? I use stack and Custom cabal build to specify path to .a and includes
07:41:52 <pyon> mauke`: Ah, right!
07:41:53 <mauke`> > (pi :: Float, pi :: Complex Double)
07:41:55 <lambdabot>  (3.1415927,3.141592653589793 :+ 0.0)
07:52:34 <ironChicken> is there a typeclass similar to Eq which provides an operator with semantics along the lines of "approximately equal"?
07:53:07 <barrucadu> I think "approximately equal" is likely to be very context-dependent
07:53:21 <barrucadu> What is "approximately equal" in one case might not be considered as such in another
07:53:31 <barrucadu> So it doesn't seem like a good candidate for a typeclass
07:54:18 <barrucadu> Although there is Eq1 for unary type constructors: https://hackage.haskell.org/package/transformers-0.5.0.0/docs/Data-Functor-Classes.html
07:54:30 <barrucadu> Which is structural equality ignoring values, I believe
07:59:35 <quicksilver> no, it is intended to respect values
07:59:48 <quicksilver> eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool
08:00:34 <quicksilver> ^^ note the Eq a constraint
08:11:16 * hackagebot cpsa 2.5.4 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-2.5.4 (JohnRamsdell)
08:43:55 <xplat|work> ironChicken: the problem is the idea of 'approximately equal' doesn't really quite make sense as such, in practice you either want to embrace the whole 'is a godawful hack' nature or use something more elaborate from the Literature (whether numerical computing, topology, mereology, analysis, or fuzzy logic)
08:45:09 <ironChicken> thanks for the pointers
08:46:42 * hackagebot propellor 2.15.3 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.15.3 (JoeyHess)
09:01:40 <oish_> Any good examples of where using applicative functors is useful? I get how they work just not where I'd use them!
09:02:28 <cocreature> oish_: by far the most popular usecase is lifting functions that require two arguments
09:02:41 <cocreature> > (+) <$> (Just 1) <*> (Just 2)
09:02:43 <lambdabot>  Just 3
09:02:51 <cocreature> > (+) <$> Nothing <*> (Just 2)
09:02:53 <lambdabot>  Nothing
09:03:08 <cocreature> actually replace two with multiple
09:03:15 <cocreature> that works for any number of arguments
09:03:15 <Cale> oish_: I mean, like Monad, it's just a small part of the interface of any library that happens to implement an instance.
09:03:59 <Cale> oish_: It's pretty cute sometimes when it comes to writing parsers
09:05:47 <oish_> cocreature: ok, so just to save having to pattern match your Maybe in the fmap? 
09:05:54 <Cale> oish_: e.g. applying a data constructor to the result of some parsers directly like   Foo <$> p1 <*> p2 <*> p3  where p1, p2, p3 are some parsers
09:06:21 <bartavelle> oish_: applicatives that are not monads are also useful for inspection
09:06:51 <cocreature> oish_: like Functor allows you to map functions taking a single argument over some structure, Applicative allows you to map functions taking multiple arguments over multiple structures
09:06:52 <oish_> Cale: oh, that is cute...
09:06:53 <ironChicken> oish_: like cocreature says: i needed to produce all the pairs from two lists today: (,) <$> xs <*> ys
09:07:02 <cocreature> whether those are lists, maybes or whatever else
09:08:05 <oish_> bartavelle: not sure I get what you mean by inspection
09:08:21 <bartavelle> yeah, that doesn't make a lot of sense :)
09:08:38 <bartavelle> something that is a monad has to "contain" arbitrary haskell expressions
09:09:08 <bartavelle> something that is an applicative can be fully represented with "simple" types (ie. you can have a Show instance)
09:09:34 <bartavelle> something that is *just* an applicative I mean
09:10:39 <cocreature> bartavelle: I can also write a show instance for Maybe which is also a monad
09:11:13 <bartavelle> you are right, I am not making much sense, which means I didn't really think this through
09:11:16 <bartavelle> you can show Maybe
09:11:26 <bartavelle> but you can't show a "maybe computation", like "a >>= b"
09:11:43 <bartavelle> you only can know at the end it's a "Maybe a" if you want to show this
09:12:03 <cocreature> > show (Just 1 >>= \x -> Just (x + 1))
09:12:05 <lambdabot>  "Just 2"
09:12:31 <cocreature> I still don’t understand what you’re trying to get at :)
09:12:44 <bartavelle> I suppose that's because it's wrong
09:13:20 <bartavelle> you can write something that's an Applicative where you can inspect how you created it
09:13:32 <bartavelle> but actually that is wrong
09:14:33 <bartavelle> but you can have the structure of how you computed something that is accessible, contrary to a monad because you have the bind operator
09:15:03 <orion> In a Free Monad, what is the meaning of "Pure a"?
09:15:16 <opqdonut> it's what return produces
09:16:01 <oish_> thanks folks.
09:16:34 <orion> opqdonut: That's what return produces when it's used inside of the DSL?
09:17:11 <opqdonut> orion: yeah, the return of the free monad
09:17:14 <cocreature> bartavelle: I still think you’re wrong (sry), since a free monad provides you a way to access the structure, but I need to run :)
09:18:37 <orion> opqdonut: When writing an interpreter, you pattern match on the free monad's various operations. For Pure, is it simply: fooInterpreter (Pure a) = return a ?
09:19:43 <opqdonut> orion: sure, if the return type of fooInterpreter is a monad
09:20:37 <opqdonut> bartavelle: yes, you're right, applicatives can be "introspected" while monads in general can't
09:20:44 <opqdonut> bartavelle: there was an article about this, let me see if I can find it
09:22:39 <opqdonut> bartavelle: anyway, the point is that the "structure" of an Applicative computation is always the same
09:22:54 <opqdonut> bartavelle: whereas the bind lets you affect the structure of a Monadic computation
09:24:21 <johnw> opqdonut: what do you mean by structure?
09:24:45 <johnw> Just _ <*> Nothing = Nothing.  If by structure you mean Just-ness, then the answer isn't the same.
09:27:14 <opqdonut> johnw: by structure I mean that in 'Just f <*> Just x <*> foo' the Justness of the result doesn't depend on x
09:27:54 <johnw> I see, you mean "structure" is determined statically, rather than based on any intermediate values
09:27:59 <opqdonut> yeah
09:28:12 <opqdonut> there was some article that explored this idea, and linked it to the efficiency of applicative parsers (vs. monadic ones)
09:28:16 <opqdonut> IIRC
09:28:21 <johnw> except that: f <*> x <*> foo, where you don't know the value of f and x, is somewhat dynamic too
09:28:25 <opqdonut> sure
09:28:39 <opqdonut> but the justness of the result depends only on the justnesses of f, x and foo
09:28:43 <johnw> I know that ocharles has explored this distinction between the two also
09:28:50 <johnw> I just don't know the right way to concisely say it...
09:29:21 <ocharles> hm?
09:29:21 <johnw> perhaps it is purely value driven, rather than computationally driven?
09:29:31 <johnw> ocharles: your applicative query framework
09:29:41 <ocharles> right, my mini haxl
09:31:15 <opqdonut> gah, I can't manage to find the article (if it even exists) on google
09:32:09 <opqdonut> oh well
09:33:58 <Tertain> Wrote some code using hmatrix and conduit to distort images from the MNIST data set. Haven't written much haskell code. Anyone care to critique? http://lpaste.net/148869
09:34:22 <fr33domlover> Hello! I noticed Haskell doesn't have a package for 'fontconfig'. What should I use then for choosing fonts?
09:34:50 <fr33domlover> It seems X11/Xft are the common choice when doing X programming directly
09:35:03 <Cale> Tertain: something you might like to know -- you can put multiple declarations inside of a single let, so long as they all start in the same column
09:35:04 <fr33domlover> Otherwise, whatever library you use already uses fontconfig
09:35:27 <Cale> (even inside do)
09:35:46 <Tertain> Cale: Thanks, that's good to know.
09:37:19 <johnw> opqdonut: some good, and revelant, comments here: http://stackoverflow.com/questions/7861903/what-are-the-benefits-of-applicative-parsing-over-monadic-parsing
09:37:34 <johnw> a key sentence: "What might we use this extra static knowledge for? Well, we can for example use it to avoid backtracking in LL(1) parsing by comparing the next character to the first set of each alternative. We can also determine statically whether this would be ambiguous by checking if the first sets of two alternatives overlap."
09:38:46 <Cale> Tertain: I dunno, it might be worth extracting the common thing that you're doing to dx and dy in createRandomField
09:38:55 <Cale> into at least a locally defined function
09:40:01 <Tertain> Cale: Like creating a pipeline of functions to perform those operations?
09:40:51 <Tertain> Cale: Oh I see what you mean. You're right. Thanks.
09:40:55 <Cale> i.e. f dt = dt2 / scalar (maxElement dt2) * scalar alpha where dt2 = smooth dt
09:40:57 <Cale> or something
09:41:24 <Cale> (maybe you have a better name for f)
09:42:21 <Cale> It also looks like something similar is going on with calc on line 83, there are a lot of similar things being done to the x and y components which can avoid being repeated
09:43:15 <Tertain> Cale: Thanks, good catch.
09:54:50 <wedens> does somebody use generic instances for FromRow, ToRow from postgresql-simple? I don't see any code that uses them on github
10:16:13 <meretrix> I'm using createProcess p { create_group = True }, but my child process still has the same group has the main haskell process.
10:16:17 <meretrix> Any idea why?
10:29:46 <zachk> how do I get lambdabot to list a function I have defined with @let?
10:34:02 <solidus-river> ?
10:36:01 <Ankhers> zachk: What do you meant by "list a function"?
10:36:22 <t0by> Hi'm I'm trying to do hw2 from cis194, http://www.seas.upenn.edu/~cis194/spring13/lectures.html. Now, at some point it asks me to rip apart a string in the form "123 TOKEN 345 OTHERTOKEN THIRDTOKEN". What is an haskell-like, clean way to do so? Coming from a C-like backgroud, where you either have the confort of regexps or can write your own iterate-over-some-chars parser, I am having trouble.
10:36:53 <csd_> I'm confused by how the types work out in this snippet: http://pastebin.com/rLJ2JzvT . If liftM is (a -> b) -> m a -> m b, how is the function able to take an STUArray and return something wrapped in ST
10:37:30 <csd_> (snippet from RWH)
10:37:37 <kadoban> > words "hello world and stuff" -- t0by
10:37:39 <lambdabot>  ["hello","world","and","stuff"]
10:37:41 <zachk> list the definition of something defined with @let via lambdabot 
10:37:43 <kadoban> t0by: Does that help? ^
10:37:55 <ReinH> kadoban: I suspect that they are supposed to *write* words, not use it.
10:39:25 <kadoban> ReinH: "Don't reinvent the wheel! (That's so *last* week.) Use Prelude functions to make your solution as concise, high-level, and functional as possible." from the hw2 PDF. So I suspect not.
10:39:31 <Ankhers> zachk: Does @src work?
10:39:38 <ReinH> kadoban: ah! seems good then.
10:39:53 <liste> :t newArray -- csd_
10:39:54 <lambdabot> Not in scope: ‘newArray’
10:40:28 <zachk> no @src doesn't seem to work over @let, lambdabot's brain explodes
10:40:31 <csd_> newArray :: (Ix i, MArray a e m) => (i, i) -> e -> m (a i e)
10:40:32 <liste> well, it's "newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)"
10:40:40 <liste> csd_ the m there
10:40:43 <liste> it's ST
10:40:52 <geekosaur>  @src dumps stuff from a fixed text database. it doesn't even consider @let definitions
10:41:19 <zachk> for example
10:41:26 <geekosaur> afaik you can't get stuff via @let back out
10:41:33 <zachk> @let f3 begin middle end = begin ++ middle ++ end 
10:41:34 <lambdabot>  Defined.
10:41:36 <zachk> oh really?
10:41:36 <csd_> liste: then why isnt the type fixed ? is it only inferring that from the type sig. that `new` provides?
10:41:51 <zachk> > f3 "oh " "darn " "then" 
10:41:52 <lambdabot>  "oh darn then"
10:42:00 <zachk> @unlet f3 
10:42:00 <lambdabot>  Parse failed: TemplateHaskell is not enabled
10:42:06 <zachk> @remove f3
10:42:06 <lambdabot> Unknown command, try @list
10:42:11 <zachk> bleh
10:42:17 <ReinH> @undefine
10:42:18 <lambdabot> Undefined.
10:42:30 <geekosaur> ...which nukes all of it
10:42:51 <ReinH> Is normal.
10:43:31 <liste> csd_ yes, `new' specializes the type to ST
10:44:00 <csd_> i havent studied monad transformers, i'm guessing this would fall into that bucket?
10:44:57 <liste> no, it's just a multi-param type class. here: http://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array-MArray.html
10:45:01 <ReinH> csd_: No, it's just a typeclass that allows multiple choices of m.
10:45:19 <ReinH> Well, two choices: IO and ST s
10:45:45 <liste> csd_ see the "instances" sections on that page
10:45:45 <ReinH> If you use IO then you get an IOArray or IOUArray, if you use ST s then you get an STArray or STUArray
10:46:06 <ReinH> (or a StorableArray for IO if your elements are Storable)
10:47:04 <csd_> oh thanks the instances section is helpful
10:47:37 <csd_> is it actually necessary to use the function newArray or could i have used the type constructor directly
10:48:13 <liste> I don't think the constructor is exposed
10:51:27 <ReinH> You can look at GHC.IOArray and GHC.Arr to see the underlying IO and ST array interfaces, respectively.
10:51:46 <ReinH> newArray proxies to one of them based on the return type you select
10:53:47 <ReinH> I believe that the constructors are technically exported by those modules, but to actually construct arrays you'll want to use the smart constructors either way
11:01:03 <csd_> ReinH: thanks
11:01:13 <csd_> liste: thanks to you too :)
11:03:33 <ReinH> csd_: you can basically look at newArray as selecting the correct array smart constructor based on the types you select.
11:04:36 <ReinH> selecting a return type via typeclasses is something most languages don't offer, so it takes some getting used to. You've probably already used it with read, for instance.
11:05:31 <csd_> i've tried to insert type hints within the code when using read
11:06:06 <csd_> otherwise i find the code feels more difficult to read
11:06:38 <xplat|work> sometimes that's the right call, other times it's just a matter of not being used to it
11:07:03 <csd_> yeah, i'm not at the level of being able to evaluate that
11:13:01 <t0by> kadoban, it helps. Thank you very much.
11:13:58 <kadoban> t0by: Ah, great.
11:15:59 <xpilot> hey does anyone have experience with the GLUT package?
11:16:10 <xpilot> I'd like to render directly to file instead of to a screen
11:16:28 <xpilot> but I can't find any tutorials that do this
11:16:33 <ij> Is there something for which mappend is implemented as "return the rightmost one". a + b = b
11:17:36 <xplat|work> > Last x <> Last y
11:17:37 <lambdabot>      Couldn't match expected type ‘Maybe a’ with actual type ‘Expr’
11:17:38 <lambdabot>      In the first argument of ‘Last’, namely ‘x’
11:17:38 <lambdabot>      In the first argument of ‘(<>)’, namely ‘Last x’    Couldn't match expec...
11:17:44 <xplat|work> oop
11:17:59 <xplat|work> > Last (Just x) <> Last (Just y)
11:18:01 <lambdabot>  Last {getLast = Just y}
11:18:34 <xplat|work> ij: the one from semigroups doesn't need the extra Maybe wrapper, but then it's only a semigroup
11:19:55 <xplat|work> :t Data.Monoid.Last
11:19:56 <lambdabot> Maybe a -> Last a
11:21:41 <dolio> Clearly the semigroup one is the right one.
11:22:11 <xplat|work> they're both the right one, First is the left one
11:22:29 <dolio> @yow!
11:22:29 <lambdabot> I'm encased in the lining of a pure pork sausage!!
11:22:30 <monochrom> haha
11:24:54 <glittershark> I don't think I've ever joined #haskell and not seen xplat|work making a silly pun
11:26:09 <xplat|work> i'm offended by that remark.  sometimes i make silly puns in #haskell from home too!
11:26:28 <glittershark> well
11:26:46 <glittershark> *I* am usually on #haskell at work
11:26:53 <glittershark> less so at home
11:27:07 <glittershark> also, irssi tab-complete
11:27:10 <glittershark> taht's the real answer
11:27:16 <glittershark> :P
11:28:01 <tommd> What, all of #haskell hasn't switched over from irssi to irc-core (glirc) yet?
11:28:31 * hodapp uses weechat
11:28:46 <augur> is there a way to use a type parameterized synonym in a type synonym instance?
11:28:51 <monochrom> glirc? does that mean you use opengl to turn irc into a texture map?
11:29:28 <augur> like, i have   type Elaborator a = StateT ElabState (Either String) a   and i want to have an instance like   instance Foo Elaborator where ...
11:29:31 <augur> but GHC is complaining
11:29:35 <monochrom> I think the TypeSynyonymInstances extension allows that
11:29:38 <ReinH> xplat|work: I wish Last, First, etc, had been added after pattern synonyms
11:29:52 <augur> its saying Elaborator needs 1 arg
11:29:59 <tommd> monochrom: No, it's just an alternate name for glguy's irc client on hackage 'irc-core'.
11:30:16 <ReinH> Well, actually no I don't, it wouldn't work very well for those.
11:30:18 <geekosaur> there's another extension needed
11:30:28 <augur> ah you know, if i change it to     type Elaborator = StateT ElabState (Either String)     it works fine
11:30:35 <glittershark> ooh, haskell irc client
11:30:47 <dolio> Having pattern synonyms doesn't really fix the fundamentally wrong design for them.
11:30:55 <glittershark> yyep, I'm switching to this
11:30:57 <augur> i guess GHC treats   'Elaborator a'   as a sugar, rather than treating 'Elaborator' as the thing being expanded. ok. hm
11:31:00 <tommd> yay!
11:31:09 <dolio> Maybe we'll eventually get to the semigroup versions.
11:31:30 <dolio> (As the only version, I guess.)
11:31:39 <monochrom> I don't need another console irc client
11:31:56 <glittershark> I need another console *everything*
11:32:01 <geekosaur> by default ghc does not permit partial application of type synonyms, because that could lead to type lambdas that haskell can;t deal with (although core can)
11:32:02 <exio4> augur: you can't pass unsaturated type synonyms around 
11:32:22 <geekosaur> iirc there's an extension that defers the type lambda check tot he point of use, so you can write such instances
11:32:27 <augur> exio4: yeah, i see that now. thats silly :)
11:32:36 <exio4> geekosaur: there's one? woah
11:32:42 <augur> but i guess thats what i get for thinking about them as functions. too much dependent types for me! :(
11:33:13 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-synonyms
11:33:20 <geekosaur> LiberalTypeSynonyms extension
11:34:04 <geekosaur> hm, except it looks like kind checking still happens too early so it would still reject that
11:34:24 <geekosaur> maybe. not sure
11:36:58 <exio4> geekosaur: I don't see how LiberalTypeSynonyms allow partial application
11:37:52 <geekosaur> it doesn't.
11:38:12 <exio4> allows*
11:38:16 <geekosaur> the normal check is naive, so if it looks like a partial application but isn't then it fails the normal check
11:39:05 <geekosaur> the alternative check delays the check so that those "not really partial" applications will work
11:39:33 <orion> I'm trying to write an interpreter for a Church-encoded free monad, but I'm getting this error: "Couldn't match expected type ‘Free t0 t1’ with actual type ‘F HandshakePatternF ()’" Do I need to convert 'F' to 'Free'? If so, do I use 'improve', 'iterM'
11:39:35 <orion> or something?
11:40:47 <geekosaur> in this case the normal check rejects it because it isn't fully saturated as written, but since it must get the parameter it requires from the instance definition it is actually valid
11:41:33 <geekosaur> (as I understand it)
11:41:43 <csd_> what makes GHC give types with numbers e.g. (a1 -> b) vs (a -> b) ?
11:42:44 <geekosaur> csd_, when tracking type variables through unification it tries to use the same variables the definition did. but if two definitions used the same type vars (or it's using the same definition twice or etc.) one of them must be renamed
11:43:33 <geekosaur> if it can't unify them directly
11:44:01 <csd_> so it's after an error / type check failure?
11:44:16 <geekosaur> ...?
11:44:36 <monochrom> I don't think "before vs after" is important or even observable
11:44:41 <ReinH> orion: what is F? Show us your code.
11:45:27 <geekosaur> only in the sense that the names only matter for error reporting
11:45:48 <orion> ReinH: F is http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free-Church.html#t:F
11:46:11 <monochrom> yeah, by the time an error message says both "a" and "a1", it means "some human thought they were the same. wrong."
11:46:14 <csd_> i guess i dont understand well enough how GHC works to understand your response
11:46:19 <bollu> Cale: I'm sorry I DC'd the other day and never came back when you were teaching me HoTT. Something came up and I had to leave :)
11:47:02 <geekosaur> ghc wants you to be able to relate an error message to what you wrote, so it tries to remember the names of type variables. type unification regularly must invent new type variables for use in constraining the types of expressions
11:47:46 <Zekka|Sigfig> Imagine if you feed ‘id’ to ‘id’
11:47:50 <Zekka|Sigfig> :t id
11:47:51 <lambdabot> a -> a
11:48:10 <csd_> :t id id
11:48:11 <Zekka|Sigfig> The a in the first id now corresponds to the type of hte second id, but the second ‘id’ also has an a in it
11:48:11 <lambdabot> a -> a
11:48:30 <geekosaur> that's not the best example since it can directly unify them
11:48:36 <Zekka|Sigfig> Oh wow! It didn’t introduce any gensyms
11:48:42 <Zekka|Sigfig> :t const const
11:48:43 <lambdabot> b -> a -> b1 -> a
11:48:47 <Zekka|Sigfig> There!
11:48:49 <Zekka|Sigfig> :t const
11:48:50 <lambdabot> a -> b -> a
11:49:00 <geekosaur> right, there's a good example
11:49:02 <Zekka|Sigfig> Both ‘const’s take an extra b — but those bs don’t necessarily have to be the same
11:49:27 <Zekka|Sigfig> @src const
11:49:28 <lambdabot> const x _ = x
11:49:30 <Zekka|Sigfig> (as a refresher)
11:49:40 <csd_> meaning that the type of b doesnt have to be the same? 
11:49:52 <Zekka|Sigfig> Yeah. We named them both ‘b’ but they can be different
11:49:57 <geekosaur> so the second one can't be "b" because "b" is already in use and it can't prove that they're the same type (in fact they aren't), so the second one is renamed to b1 to indicate that it's a different type
11:49:59 <csd_> and if the one b were c then it would mean they couldnt be the same
11:50:01 <Zekka|Sigfig> the b for the first const doesn’t always haev to be the same as the b for the second const
11:54:14 <monochrom> const const has "two b's" in the exact same sense that "sin (sin 2)" has "two x's"
12:02:09 <obadz> what's the best source of documentation to understand how to productively use type families?
12:02:37 * hackagebot rethinkdb-client-driver 0.0.21 - Client driver for RethinkDB  https://hackage.haskell.org/package/rethinkdb-client-driver-0.0.21 (wereHamster)
12:03:10 <monochrom> what is extra in "productively use" that is not already in just "use"?
12:03:40 <obadz> monochrom: it's not what's extra, it's what's missing... I'm not trying to understand any more theory than needed to use productively
12:03:56 <cocreature> obadz: just use them when you feel you need them
12:03:59 <cocreature> that’s it
12:04:01 <cocreature> done
12:04:08 <geekosaur> there's always use for the sake of use as opposed to use for an actual purpose
12:04:11 <obadz> cocreature: I'm not asking when to use, I'm asking where to find documentation..
12:04:26 <monochrom> the GHC user's guide has syntax semantics and example uses. no theory.
12:04:55 <obadz> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html ? Will read.
12:05:33 <monochrom> you probably also has it on your hard disk
12:05:42 <monochrom> it comes with normal GHC installations
12:06:20 <obadz> yes /nix/store/7hnlpxpmpka84zrhyq7z11bs0q3vgak1-ghc-7.10.2/share/doc/ghc/html/users_guide/type-families.html :)
12:06:33 <obadz> any enlightening youtube videos?
12:07:53 * hackagebot ipopt-hs 0.5.1.0 - haskell binding to ipopt and nlopt including automatic differentiation  https://hackage.haskell.org/package/ipopt-hs-0.5.1.0 (AdamVogt)
12:08:26 <bitemyapp> obadz: I think mono-traversable shows off one use-case
12:09:19 <ReinH> obadz: maybe https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html
12:09:19 <pavolzetor> Text.Pandoc.Definition does not build on 4GB of ram
12:09:27 <pavolzetor> is this a GHC bug?
12:09:44 <ReinH> 4GB is not necessarily a bug.
12:09:55 <ReinH> I've seen GHC take that much RAM before.
12:10:14 <pavolzetor> so how am I supposed to use pandoc?
12:10:40 <Clint> apt install pandoc
12:10:49 <pavolzetor> gentoo
12:11:14 <pavolzetor> I think that is unacceptable to use that much ram
12:11:19 <zachk> emerge pandoc? 
12:11:33 <pavolzetor> zachk: that runs out of memory
12:11:44 <zachk> ghc binaries wouldn't even fit in my original pc's ram
12:12:07 <greg`> s3.amazon.com is blocked from my firewall at work ,anyone know how to get stack to work without it?
12:12:18 <glittershark> who the heck blocks s3 at work
12:12:24 <xplat|work> pavolzetor: use it as a web service?
12:13:12 <obadz> ReinH: thx
12:13:15 <pavolzetor> zachk: I know, but 4 GB of ram is a lot
12:13:25 <zachk> used to be 
12:13:32 <pavolzetor> I never had a problem with any compiler in my life for which it was not enough
12:13:40 <glittershark> pandoc is huge, fwiw
12:14:11 <greg`> no kinda stack offline mode then i take it
12:14:38 <Ankhers> greg`: You could technically build the entirety of stackage.
12:14:47 <greg`> uhmmmm.....
12:14:59 <greg`> any other proxies?
12:15:07 <greg`> or mirrors?
12:15:10 <pavolzetor> I am going to report a bug; this is just silly argument to say 4GB is not enough
12:15:44 <glittershark> maybe it's possible to run GHC itself with RTS opts?
12:15:45 <greg`> pavolzetor: sorry i came late 4GB is not enough for what?
12:15:50 <glittershark> building pandoc
12:16:03 <glittershark> 4GB of RAM, specifically
12:17:00 <greg`> most likely the bug will be ignored until 4GB is a laughably small amount of memory 
12:17:04 <ReinH> pavolzetor: there's no bug
12:17:21 <ReinH> It is obviously not silly, since GHC is using that much RAM
12:17:36 <zachk> is there a dev build option for it?
12:17:37 <glittershark> pavolzetor: cabal build --ghc-options='+RTS -M2G -RTS'
12:17:39 <glittershark> works for me
12:17:44 <zachk> try shutting off -O2 etc
12:18:02 <glittershark> ghc itself uses the ghc runtime to run
12:18:25 <me_> is BONUS here?
12:19:09 <pavolzetor> greg: pretty sad
12:19:11 <x_pilot> anyone used opengl before?
12:19:24 <ReinH> pavolzetor: ok.
12:19:41 <x_pilot> I'm trying to figure out how to render 3d scenes directly to images/files
12:19:47 <pavolzetor> ReinH: I want to know why it needs so much RAM? Does it justifiably use it or just wastes it?
12:19:47 <greg`> finally getting my head around category theory , but still struggle with its practical application
12:19:50 <zachk> x_pilot in haskell? I have, if you want to play around with 2d stuff try gloss 
12:19:57 <dedgrant> Why does building pandoc with GHC take as much RAM as it does?  I've heard similar complaints from others with figures varying from 2GB to 4GB.
12:20:03 <zachk> juicy-pixels might be of help 
12:20:05 <x_pilot> zachk: yeah in haskell
12:20:14 <ReinH> pavolzetor: I'm sure it just allocates 3GB of garbage to annoy you.
12:20:25 <x_pilot> I found a package called not-gloss which seems to work pretty well
12:20:32 <greg`> lol
12:20:55 <ReinH> I've regularly seen it take that much RAM when building complex projects, especially with high levels of optimization
12:20:57 <pavolzetor> zachk: I will try, it without -O2
12:21:05 <x_pilot> zachk: gloss is 2D only right? not-gloss is supposed to be gloss but 3D
12:21:14 <ReinH> There are some pathological cases that can cause the typechecker to consume a huge amount of space, but 4GB is not pathological.
12:21:21 <glittershark> I mean, it's 2016, RAM is cheap
12:21:23 <cocreature> it’s all part of making ghc great again
12:21:29 <ReinH> cocreature: <3
12:21:43 <greg`> yeah depends what you are trying to compile to
12:21:52 <greg`> some people like arm processors
12:22:16 <cocreature> :)
12:22:16 <dzdncnfzd> Who wants to help me diagnose type errors? :D lpaste.net/148877
12:22:26 <zachk> not-gloss hasnt't been building for me on 7.10.x 
12:22:56 <x_pilot> zachk: what kinds of errors?
12:22:57 <dedgrant> ReinH: I've noted a correspondence between exploding RAM usage and number of modules being compiled in the past.. alleviated by -O0, so it seems that intermodule optimization is a common sort of complexity.
12:23:10 <x_pilot> zachk: it works for me
12:23:17 <zachk> looked like a bunch of functions in dependencies it required, have changed names
12:23:18 <dzdncnfzd> The problem is in the last part of the function on line 17
12:23:20 <zachk> seriously?
12:23:24 * zachk will try again
12:23:26 <ReinH> dedgrant: and various type-level extensions can make GHC especially hungry, as can template haskell.
12:23:35 <dedgrant> right
12:23:38 <ReinH> iirc, at least
12:23:43 <x_pilot> zachk: maybe try in a sandbox?
12:24:02 <ReinH> we had to use high-memory instances for our build servers because of it
12:24:05 <dedgrant> ReinH: Though from an engineering rather than cs perspective, those cases are more pathological. I'm just looking at use cases.
12:24:21 <ReinH> dedgrant: if they're pathological then we were doing a lot of pathological things
12:24:27 <dedgrant> haha yes.
12:24:34 <glittershark> dzdncnfzd: hard to diagnose without proper line numbers in the error messages :)
12:24:38 <dmwit> dzdncnfzd: Include enough stuff for us to reproduce your problem. Stub out implementations with undefined if they're not important, but keep their type signatures.
12:24:38 <dedgrant> It's a tricky balance :)
12:24:58 <greg`> yeah its talking about Lib.hs
12:25:07 <glittershark> dzdncnfzd: but my first thought is to change `liftM Listing <=<` to `Listing <$>`
12:25:21 <obadz> ReinH: in https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html, the IOStore example, what makes it not possible to do without type families? Looks like a standard type class to me..
12:26:07 <dmwit> glittershark: or maybe `liftM Listing .`?
12:26:22 <obadz> cc // ocharles 
12:26:24 <ReinH> obadz: IOStore doesn't use type families. It is a motivation for introducing Store, which does.
12:26:28 <dzdncnfzd> glittershark: done
12:26:32 <obadz> ReinH: oh ok
12:26:40 <dzdncnfzd> dmwit: done
12:26:46 <obadz> ReinH: sorry my bad
12:26:47 <ReinH> See the paragraph that begins "Cool - now we can go and extend this to TVar and other STM cells!"
12:27:22 <ReinH> obadz: Store is very similar to the use of newArray too.
12:27:34 <dzdncnfzd> glittershark: parseListing' is the working version of parseListing
12:27:39 <dzdncnfzd> dmwit: see above
12:27:41 <ReinH> it abstracts over state rather than arrays, but otherwise is the same concept
12:28:15 <dmwit> dzdncnfzd: So, yeah, I would bet `liftM Listing . (mapM parseArticle <=< ...)` would be a step in the right direction.
12:28:25 <bollu> ReinH: is there a nice place to read the "comonads are objects" other than the neighbourhood of infinity article?
12:28:45 <bollu> ReinH: along with comonad + free + cofree interaction
12:28:48 <ReinH> bollu: I mean, that's the thing that presents that view.
12:29:02 <bollu> ReinH: hm, I thought there would be multiple expositions :)
12:29:48 <ReinH> bollu: maybe http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
12:30:02 <thoughtpolice> pavolzetor: The reality is, A) It's hard to say whether RAM on these things are 'wasted' or 'used efficiently' without a lot of context (design, goals etc of the compiler). But, B) No, I don't think it's reasonable to require 4GB of RAM for such a module, and it seems reasonably like a bug to me or some possible edge case being triggered.
12:30:25 <ReinH> thoughtpolice: really? I've seen GHC take that much RAM many times.
12:30:38 <thoughtpolice> GHC should be much faster/speedier than it is now, IMO. But it takes a lot of dedicated time to shave down lots of small things that add up. People are mentioning things like type checking extensions, but the module in question is extremely 'simple' Haskell, all things considered. If I had to take a guess, I'd say Aeson is causing the optimizer to churn very
12:30:39 <thoughtpolice> hard.
12:30:41 <bollu> ReinH: thank you
12:30:41 <Ankhers> I just compiled pandoc, peaking at ~2.4GB RAM.
12:31:22 <ReinH> Ankhers: how did you detect that peak?
12:31:56 <thoughtpolice> If a module as simple as this is using 4GB, I'd say it's a bug _somewhere_: https://hackage.haskell.org/package/pandoc-types-1.16.0.1/docs/src/Text-Pandoc-Definition.html It's hard to get all the variables that factor into that laid out, though (Pandoc is large and has a lot of dependencies, so reproduction needs to be very precise)
12:31:58 <Ankhers> ReinH: Not very scientific, but just looking at OSX's Activity Monitor and htop.
12:32:07 <ReinH> Right.
12:32:13 <thoughtpolice> That module doesn't even import anything outside of the Platform, not even any other pandoc modules. That's not good.
12:32:18 <dzdncnfzd> dmwit: that works! Also working is: return . Listing <=< ...
12:32:33 <dzdncnfzd> really what we need is a function (a -> b) -> (a -> m b) 
12:32:41 <dzdncnfzd> which, well, I was sure there'd be one like that
12:32:48 <dzdncnfzd> but I guess you just need to compose with return
12:33:02 <ReinH> thoughtpolice: We don't know what exactly was being compiled.
12:33:17 <dmwit> dzdncnfzd: Sure, that's a nice fix, too.
12:33:26 <dmwit> glittershark++
12:33:43 <Ankhers> It could have been compiling multiple modules at once, and it ran out of memory on that one.
12:34:07 <glittershark> yeah, pavolzetor: try compiling with -j1
12:34:10 <ReinH> GHC doesn't even die on OOM errors, it just keeps chugging along...
12:34:43 <glittershark> it could hypothetically be using 1GB per compiler process on a 4-core machine
12:34:43 <ReinH> I mean, eventually the compilation fails, but an OOM error doesn't immediately cause it to terminate, which is Fun.
12:34:53 <Ankhers> pavolzetor: What was the exact message you received?
12:37:54 * hackagebot multiset 0.3.2 - The Data.MultiSet container type  https://hackage.haskell.org/package/multiset-0.3.2 (TwanVanLaarhoven)
12:38:00 <ReinH> Ankhers: you can use /usr/bin/time -l fwiw
12:38:05 <greg`> ok must away , tara
12:38:28 <Ankhers> ReinH: I was unaware of that.
12:38:37 <ReinH> And now you are not :D
12:38:46 <Ankhers> Indeed.
12:39:53 <zachk> whaddya know, latest update to not-gloss, and it builds :D
12:40:27 <bollu> what's not-gloss?
12:40:40 <sphinxo> Could someone explain to me why my recursive function is not running as I expect?
12:40:44 <sphinxo> My code 
12:40:45 <zachk> a 3d version of gloss, never had it build before 
12:40:50 <sphinxo> http://lpaste.net/148879
12:40:52 <xplat|work> i don't know what it is, but i know what it isn't
12:41:00 <sphinxo> given for example optimize [Set RAX 1, Set RAX 2, Push RAX,Pop RAX]
12:41:02 <pavolzetor> sorry, was in meeting
12:41:07 <sphinxo> it should return an empty list
12:41:23 <shachaf> No it shouldn't.
12:42:02 <xplat|work> shachaf: maybe it should.  we may be being misled by the identifiers about what it's actually supposed to do
12:42:03 <sphinxo> shachaf: ?
12:42:11 <shachaf> xplat|work: True.
12:42:27 <shachaf> I was thinking that was amd64 assembly.
12:42:39 <xplat|work> it might not actually be about machine code at all, it could be about chess problems
12:43:20 <shachaf> Whatever it's about, those overlapping instances are going to be a bad time all around.
12:43:33 <sphinxo> How should I do it otherwise?
12:43:35 <byorgey> sphinxo: in the [Instr] instance for Optimisable, should the first two clauses of optimise be recursive?
12:43:35 <monochrom> sphinxo: in "optimize (Push r : Pop r' : xs) | r == r' = xs", there is no recursion. is this what you want?
12:43:38 <zachk> could it launch missiles though? 
12:43:46 <sphinxo> monochrom: ahh yes
12:43:58 <ReinH> Well, fmap can't perform any peephole optimizations
12:44:08 <ReinH> so regardless of what you're trying to do, you won't achieve it with fmap.
12:44:32 <sphinxo> thanks byorgey and monochrom 
12:44:41 <ReinH> unless I misunderstand the purpose of the fmap there
12:44:46 <pavolzetor> thoughtpolice, glittershark: it was a single ghc process
12:44:59 <pavolzetor> so I guess j1 would not help right?
12:45:11 <ReinH> pavolzetor: what were you actually compiling
12:45:13 <ReinH> ?
12:45:26 <pavolzetor> ReinH: OS killed it, because it churned even through all the swap
12:45:26 <sphinxo> How could I do it better?
12:45:38 <ReinH> pavolzetor: but what were you compiling?
12:45:50 <pavolzetor> it was probably more than 4 GB, when it hit 3.3 GB I just could not do anything and wait
12:46:38 <monochrom> "the OOM caused a cascade of unfortunate events leading to the erasure of what I was compiling. so now I don't know what I was compiling." :)
12:46:43 <pavolzetor> Ankhers: http://lpaste.net/148880
12:47:04 <ReinH> sphinxo: presumably you mean, e.g., optimize (Push r : Pop r' : xs) | r == r' = optimize xs
12:47:10 <byorgey> sphinxo: if I were you I would get rid of the overlapping instance, and just declare explicit instances using fmap in the cases where you want it
12:47:18 <sphinxo> ahh ok
12:47:25 <pavolzetor> ReinH: http://lpaste.net/148880
12:47:30 <ReinH> pavolzetor: where's the rest?
12:48:08 <pavolzetor> ReinH: what rest?
12:48:18 <ReinH> pavolzetor: the rest of the output?
12:48:20 <pavolzetor> that was the only ghc process
12:48:28 <pavolzetor> that is the output I got from emerge
12:48:55 <pavolzetor> sans the output for all previous packages
12:50:15 <ReinH> Well, at least we can see that you weren't just compiling Text.Pandoc.Definition
12:51:00 <ReinH> But we don't know, e.g., whether your emerge build was in parallel or anything else that might be relevant.
12:51:37 <Ankhers> pavolzetor: What is in the log file?
12:51:55 <ReinH> You could try to compile pandoc directly with GHC
12:52:00 <pavolzetor> ReinH: only one GHC process was running
12:54:27 <ReinH> I'd be interested in the output of /usr/bin/time -l cabal install pandoc, for instance
12:54:46 <ReinH> especially from an empty user database.
12:55:44 <pavolzetor> Ankhers: http://lpaste.net/148881
12:56:01 <sphinxo> How do I represent a type that could be String, Int and Int, String?
12:56:19 <ReinH> sphinxo: why not pick one?
12:57:14 <sphinxo> How about String, String and String, int?
12:57:30 <sphinxo> for example Xor Register Register
12:57:37 <sphinxo> and Xor Register Int
12:58:03 <ReinH> Those are two different Xors, but why are your registers strings?
12:58:16 <sphinxo> Well I was just giving an example
12:58:17 <pavolzetor> I am going to lunch then I will report a bug
12:58:50 <sphinxo> ReinH: ?
12:58:52 <alpha123> wouldnt it be easier for them to be type Register = RAX | RBX | RCX | ..
12:59:00 <sphinxo> they are alpha123  :)
12:59:19 <ReinH> your choices are basically Either (String, String) (String, Int) or A String (Either String Int), named as you see fit.
12:59:31 <sphinxo> Great Thanks
12:59:31 <ReinH> iow you can choose to factor the String out, or not.
12:59:48 <sphinxo> I'm not using any strings
12:59:55 <sphinxo> data Register = EAX | EBX deriving (Show, Eq)
13:00:15 <ReinH> iow you can use ab + ac or a(b+c)
13:00:51 <sphinxo> I think i'll go with the second one
13:02:17 <monochrom> you need a "data ArgumentType = Immediate Int | Register Register | Address Int | AddressAndOffset Int Int"
13:03:09 <monochrom> except that the Immediate case never makes sense as a target argument. now you are between a rock and a hard place.
13:03:42 <monochrom> on top of that you eventually have to talk about 8-bit vs 16-bit vs 32-bit vs 64-bit
13:04:35 <ReinH> monochrom: ArgumentType also doesn't restrict arguments in the cases where only some of the options are valid
13:04:37 <xplat|work> data ArgumentType a where { Immediate :: Int -> ArgumentType Source; Register :: Register -> ArgumentType a; ... }
13:04:59 <monochrom> at which point you are more than choosing between the physical strength of Dr. Jekyll and the gentleman manner of Mr. Hyde
13:05:09 <ReinH> heh
13:05:26 <xplat|work> it would be a nightmare to guarantee valid arguments at the type level for, e.g., x86 tho
13:05:37 <xplat|work> at least, it would with GADTs
13:05:40 <ReinH> xplat|work: true enough
13:05:58 <ReinH> this is why I restrict myself to brainfuck compilers.
13:06:01 <ReinH> much easier
13:06:04 <xplat|work> i could see it actually working out with refinement types though
13:06:09 <ReinH> xplat|work: yeah
13:06:50 <xplat|work> in fact i feel that that sort of thing is almost the ideal scenario for refinement types
13:52:47 <lollancf37> clear
13:52:52 <lollancf37> oops sorry
13:53:12 * hackagebot hledger-ui 0.27.3 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-0.27.3 (SimonMichael)
14:09:11 <synergistics> I want to learn category theory and Haskell. Would starting with Haskell make learning category theory more productive? 
14:10:18 <x_pilot> synergistics: Haskell provides a lot of concrete examples of concepts in category theory like Functors
14:12:39 <synergistics> x_pilot: Yea I haven't seen much of that reading academic papers so far 
14:14:52 <exio4> synergistics: it might help, but not much
14:15:33 <xplat|work> mathematics may not provide a lot of concrete examples of functors, but it provides many examples of concrete functors
14:16:13 <Jello_Raptor> is there a haskell type that I should use if I want a monoid such that for all `a` and `b` in that monoid `a <> b >= a`? 
14:17:04 <nolraiU> That isn't a monoid.
14:17:10 <xplat|work> not particularly other than 'monoid'
14:17:10 <Jello_Raptor> the type has to be an instance of Monoid and Ord
14:17:16 <nolraiU> (Because of id)
14:17:33 <xplat|work> nolraiU: >= , not >
14:17:34 <Jello_Raptor> nolraiU: '>=' 
14:17:39 <kadoban> nolraiU: Why not? It wouldn't be with >, but >= seems fine.
14:17:41 <nolraiU> Oh.
14:17:43 <nolraiU> Hmm.
14:17:59 <nolraiU> Miss read it as "=".
14:18:02 <dolio> Max
14:18:32 <Jello_Raptor> I figured, but seems good practice to check if there's already a convention before going on to reinvent it. 
14:19:03 <xplat|work> Max is an example, but is it the only example?
14:19:17 <synergistics> exio4: what, Haskell or the papers? 
14:19:42 <dolio> Not necessarily.
14:20:02 <xplat|work> i think it isn't even the only join-semigroup, and all lower-bounded join-semigroups would be this thing
14:20:03 <dolio> If you have natural numbers, then the addition monoid works.
14:20:06 <Jello_Raptor> xplat: positive integers and floats with (+) as the operator and 0 work
14:20:20 <xplat|work> er, not even lower-bounded
14:20:54 <Jello_Raptor> infact, that's what i want to use the typeclass with (it's meant for costs in a search tree monad, and the monad requires that property to ensure ordered output) 
14:21:51 <xplat|work> if i had to make up a name for that thing i'd call it a 'left-inflationary monoid'
14:22:58 <kadoban> Why "left"?
14:23:37 <Jello_Raptor> xplat: oh oops, '<>' doesn't require commutativity. I actually need both `a <> b >= a` and `a <> b >= b` though *not* `a <> b == b <> a` 
14:23:59 <kadoban> Oh yeah nevermind, about the left thing.
14:24:47 <dolio> I always have to ask "why left," because I can never remember which side of operations matter for designating something "left" vs. "right."
14:25:23 <dolio> Left because it's bigger than the left, or left because operating from the left results in something greater?
14:25:31 <Jello_Raptor> i assumed the first
14:25:56 <dolio> Well, it's obvious since the definition came first.
14:26:52 <dolio> But if I say, "left seminearring," then you may not know.
14:27:02 <dolio> And I don't know, because I can't remember.
14:27:19 <zachk> Jello_Raptor so you want a :  a + b = a and a + b = b forall and b? where + is a  monoid's binary operator? 
14:27:45 <Jello_Raptor> zachk: '>='
14:27:54 * zachk looks that up
14:28:13 <zachk> cause I was just gonna say only the neutral element/right identity left identity would sovle that for all
14:28:21 <Jello_Raptor> It's just Ord's "greater than or equal" 
14:29:46 <dolio> I have the same problem with 'shallow' and 'deep' embeddings.
14:33:13 * hackagebot imagemagick 0.0.4 - bindings to imagemagick library  https://hackage.haskell.org/package/imagemagick-0.0.4 (AlexanderVershilov)
14:33:15 * hackagebot memory 0.11 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.11 (VincentHanquez)
14:33:20 <zachk> Jello_Raptor is your (<>) just mappend in a monoid? 
14:33:37 <monochrom> David Bowie would have appreciated hearing about left semi ear-ring. He might have tried it.
14:34:35 <Jello_Raptor> zachk: yes
14:34:57 <Jello_Raptor> monochrom: I was worried it was just me :P
14:35:06 <monochrom> I love puns.
14:35:32 <monochrom> Here is one I just invented this morning. What is unix, in a nutshell? Answer: it consists of a kernel and a shell.
14:36:51 <zipper> Hello, say I want to run a server so I have a function `runServer` that runs forver. The problem is the server takes an application that only it calls.
14:37:19 <zipper> My problem is that I want to be able to call the application severally while the server runs
14:37:28 <zipper> Does this make sense or do I need an example?
14:37:38 <monochrom> what is the type of runServer?
14:38:19 <zipper> monochrom: Give me a sec to show you
14:38:52 <zipper> I'm having issues accesing hackage page on Network.WebSockets
14:38:56 <zipper> Slow internet
14:39:24 <monochrom> do you have docs on your hard disk?
14:39:33 <zipper> monochrom: https://hackage.haskell.org/package/websockets-0.9.3.0/docs/Network-WebSockets.html#v:runServer
14:39:41 <zipper> monochrom: The internet
14:39:44 <monochrom> if you overrode a devious cabal default, you would have docs on your hard disk
14:40:04 <zipper> monochrom: I didn't know that will work on it.
14:40:07 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
14:40:22 <zipper> monochrom: Please lets stay on topic :)
14:40:37 <monochrom> an app has type PendingConnection -> IO ()
14:40:44 <zipper> Yes
14:40:57 <zipper> But I am unable to call the app from outside runServer
14:41:12 <zipper> Is there a way to call runServer like I would call the print function?
14:41:14 <monochrom> so I think you mean: runServer "localhost" 80 (\c -> app c >> app c >> app c)
14:41:23 <dfeuer> How the HECK does reifyTypeable work?
14:41:32 <dfeuer> The code looks horrifying and mysterious.
14:41:35 <zipper> I want to use websockets to stream data that is being printed to the browser
14:42:06 <zipper> monochrom: I'm not sure.
14:42:37 <zipper> Just as long as I am able to pass Text to the app. I can't call runServer more than once
14:42:45 <zipper> Let me show you some code I wrote
14:42:57 <monochrom> I don't think I will understand
14:43:15 <zipper> monochrom: How so? It's simple
14:43:44 <glittershark> zipper: are you looking for something like forkIO?
14:44:30 <zipper> glittershark: No I don't think forkIO would help in this case.
14:44:38 <zipper> but I could try idk
14:44:43 <monochrom> one single app, even one single run of one single app, can already stream as much data as many times as you want. you shouldn't need to run that app multiple times just to stream a lot of data. (assuming just one "session")
14:45:25 <zipper> monochrom: yes
14:45:33 <zipper> but how will I get data to that app
14:45:35 <zipper> ?
14:45:48 <zipper> monochrom: glittershark https://gist.github.com/urbanslug/eda1b605e45433e730c3
14:45:49 <monochrom> you create the data, no?
14:46:19 <zipper> monochrom: Yeah how will I call the sendTextData severally?
14:46:38 <zipper> glittershark: I could forkIO line 7
14:46:40 <zipper> idk
14:47:15 <monochrom> ok, I don't understand.
14:47:23 <zipper> or how will I just print to the browser?
14:47:37 <zipper> monochrom: Which part? You're such a clever guy :(
14:48:16 <zipper> monochrom: You've helped me severally
14:48:55 <glittershark> I mean
14:48:59 <glittershark> you'd need to make a *client*
14:49:10 <glittershark> to connect to those websockets
14:49:12 <glittershark> in Javascript
14:49:20 <zipper> glittershark: There is a client in the browser
14:49:28 <glittershark> okay?
14:49:38 <glittershark> so that's where you get your data
14:50:26 <zipper> No
14:50:39 <zipper> I want to get the data from another part in my application
14:50:50 <glittershark> what other part
14:50:56 <glittershark> a file? a database?
14:51:01 <zipper> Like literally write `print` from the standard library but for the browser
14:51:16 <glittershark> so you want to send data to the websocket?
14:51:31 <zipper> It's generated as we go by updateSession from ide-backend
14:51:35 <zipper> glittershark: Yes
14:51:40 <zipper> To the websocket server
14:51:47 <glittershark> `sendTextData`
14:51:50 <zipper> Which sends to the cleint in the browser
14:52:01 <zachk> you could just serve a page off your webserver and have the web client poll for updates to it 
14:52:02 <glittershark> `sendTextData :: WebSocketsData a => Connection -> a -> IO ()`
14:52:16 <zipper> glittershark: That is what I have but calling sendTextData severally is almost impossible.
14:52:17 <monochrom> that's too bad for you. if the client side stops making request, there is no such thing as "print to the browser".
14:52:27 <glittershark> well
14:52:33 <glittershark> this is websockets we're talking about
14:52:37 <zipper> zachk: What now? Please explain
14:52:40 <glittershark> I'm not sure what you mean by "severally"
14:52:46 <monochrom> and the client side can stop making requests because I can simply kill the whole bloody browser.
14:53:20 <zachk> you set up a route in your webserver to server a page, and your client keeps checking it and updates the dom from the page, ajax or json only on the page 
14:53:23 <zipper> Well I want the user to see on the browser and their work compiles.
14:53:30 <monochrom> so now your webapp is printing to a much needed audience
14:53:31 <zipper> The output
14:53:33 <zachk> no idea how to get javascript to poll 
14:53:48 <glittershark> zachk: zipper is using websockets
14:53:55 <zachk> oh, goodluck 
14:54:05 <zipper> glittershark: I could use anything that will work zachk 
14:54:31 <zachk> if you have something half way working with websockets, just use them, they are newer 
14:54:40 <monochrom> the whole control-flow of web apps is the total opposite of what you think, if I guess correctly what you think.
14:55:17 <zipper> monochrom: Please tell me. The client has to make a request.
14:55:18 <monochrom> the best you can do is to store your latest build log on the disk somewhere, overwriting the old previous build log.
14:55:36 <zipper> monochrom: I can't start the conversation, amirite?
14:55:39 <monochrom> and then, when a client makes a request, you send that file.
14:55:54 <glittershark> yeah, like
14:56:03 <glittershark> if I'm understanding you correctly
14:56:07 <glittershark> and I think I finally do
14:56:13 <monochrom> as opposed to "build, send build log, repeat"
14:56:25 <glittershark> you have a server process handling websockets, and another asynchronous server process that's doing a long-running process
14:56:34 <glittershark> and you want the latter to send progress to the former
14:56:43 <glittershark> which sounds to me like you need an MVar
14:56:59 <zipper> May I just show you the entire thing?
14:57:08 <glittershark> go ahead
14:57:11 <monochrom> yeah, store the build log on disk or in MVar or in TVar or in IORef
14:57:20 <zachk> or you could go with message passing via Cloud Haskell 
14:57:30 <glittershark> uh
14:57:44 <glittershark> not sure if that's necessary here tbh
14:57:50 <glittershark> MVars and TVars are good enough imo
14:57:51 <zipper> There: https://github.com/urbanslug/wai-devel/blob/master/src/Devel/Compile.hs#L111
14:58:09 <zipper> Replace print with something like printToBrowser
14:58:23 <glittershark> ok
14:58:39 <monochrom> in fact atomicModifyIORef is the simplest possible
14:58:39 <glittershark> so, yeah, you need something in the thread that's handling websocket connections
14:58:48 <zipper> zachk: I'm unfamiliar with message passing
14:58:53 <glittershark> that's reading from an MVar
14:59:17 <glittershark> this is definitely an MVar/TVar/IORef kind of problem
14:59:37 <zipper> glittershark: Okay so what should I do? Am I still to use websockets?
14:59:37 <glittershark> pick one of those, write to it from the `finishCompile` function, read from it in your websocket handler
14:59:42 <glittershark> yeah, websockets are fine
15:00:35 <zipper> glittershark: So I'll keep looping the sendTextData to read the MVar?
15:00:44 <glittershark> yep
15:00:53 <monochrom> no, sendTextData writes to the MVar
15:00:58 <glittershark> no, monochrom 
15:01:03 <zipper> monochrom: No
15:01:05 <glittershark> sendTextData is a WebSocket library funcion
15:01:08 <glittershark> function*
15:01:12 <zipper> It reads from updateStatus
15:01:15 <monochrom> I see
15:01:34 <glittershark> so yeah, you have a loop that reads from an MVar and writes it to the websocket
15:02:34 <zipper> glittershark: and this loop will be handleConnection calling sendTextData severally?
15:02:50 <zipper> glittershark: I think I have a mental image of what I need.
15:02:52 <glittershark> yeah
15:03:00 <zipper> WOW you guys, I have a general question that's totally offtopic but might I actually be clever? I'm surprised.
15:03:07 <glittershark> heh
15:03:19 <zipper> I join this channel and talk to people and feel dumb today I did not
15:03:24 <monochrom> I am not clever. I am only scientific.
15:03:29 <zipper> Guess I'm improving haha
15:03:31 <glittershark> :) I'm glad!
15:03:37 <zipper> monochrom: Oh please, you're modest
15:03:48 <zipper> *being
15:04:15 <monochrom> I don't know about that. there are a lot of clever, unscientific people, and they do much damage.
15:06:59 <zipper> monochrom: True :)
15:18:44 <impure_hate> ohai. I'm looking for pointers on generating code for other languages from single haskell codebase
15:29:09 <Gurkenglas> Can we have Data.Functor.Foldable added to lambdabot?
15:29:18 <Gurkenglas> @let import Data.Functor.Foldable
15:29:18 <lambdabot>  .L.hs:88:1:
15:29:19 <lambdabot>      Failed to load interface for ‘Data.Functor.Foldable’
15:29:19 <lambdabot>      Use -v to see a list of the files searched for.
15:29:40 <Gurkenglas> int-e?
15:33:43 <Gurkenglas> Next question: http://lpaste.net/edit/147680 <- lines 33-38 - "standalone deriving declaration"?
15:33:59 <Gurkenglas> (well it's got a question mark!)
15:43:55 <dedgrant> Gurkenglas: The 'Possible fix' might be misleading. 'Standalone deriving declaration' refers to writing an explicit 'instance Functor (StatementF s)', but it's probably not the solution you want.
15:44:45 <koz_> I've written the following attempt to define a Functor on HashSets: http://paste.rel4tion.org/198 <-- not sure how to resolve the issue in the comment
15:46:22 <Gurkenglas> koz_, https://www.schoolofhaskell.com/user/chad/snippets/random-code-snippets/set-is-not-a-functor
15:46:39 <koz_> Gurkenglas: I *thought* there might be a reason for that...
15:47:00 <zachk> @src iterate
15:47:01 <lambdabot> iterate f x = x : iterate f (f x)
15:47:21 <koz_> Gurkenglas: Although that doesn't really explain it very well.
15:47:25 <koz_> Could you enlighten me?
15:48:12 <Gurkenglas> Do you understand this sentence: "Functor needs to map commuting diagrams to commuting diagrams"?
15:48:32 <geekosaur> dedgrant, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#stand-alone-deriving not quite the same thing
15:48:50 <monochrom> koz_: the definition of the Functor class does not allow an Eq constraint (or Hashable) in fmap's type. However, if you use setFromList, you impose those constraints.
15:49:01 <dedgrant> geekosaur: ah right you are, cheers.
15:49:10 <koz_> monochrom: OK, I see. Gurkenglas: No, not really, sorry.
15:49:12 <monochrom> to "solve" this problem, you have to use a different class, not Functor itself.
15:50:16 <hexagoxel> http://www.randomhacks.net/2007/03/15/data-set-monad-haskell-macros/ http://hackage.haskell.org/package/rmonad
15:50:26 <koz_> monochrom: I get that, but Gurkenglas' example seems to insist that there's a theoretical reason why Sets aren't Functors.
15:50:31 <koz_> And I'd really like to understand that.
15:50:44 <Gurkenglas> That's not the point my link was making, but it works too. Eq does not gurantee that "equal" values are indistinguishable in the sense of being replaceable by one another in all places. Three objects of one type (that are "equal") can be mapped to three "nonequal" objects of another type
15:51:30 <koz_> Gurkenglas: What *is* the Eq guarantee then?
15:51:34 <Gurkenglas> there is none :I
15:51:41 <monochrom> there is an easy and widely agreed theoretical reason, and a subtle and debated theoretical reason.
15:52:08 <koz_> Gurkenglas: So basically, the Eq guarantee is 'whatever the type's author decided'?
15:52:27 <Gurkenglas> And so when you have functions a->b and b->c, where everything is "equal" in b and nothing is "equal" in a or c, and you map the functions one by one across a set of three elements of a, you end up with a one-element set of c
15:52:42 <monochrom> the easy one is: we all agree that theoretically fmap should work for all element types without restriction. so as soon as you require Eq etc you are imposing an unwanted restriction.
15:53:23 <zachk> Set has an Ord constraint 
15:53:37 <zachk> there is a Data.Set.Monad package though 
15:53:38 <Gurkenglas> And if you map the composition of the functions across, you get a three-element set of c. But Functor requires that mapping compositions and composing mappings does the same thing
15:53:48 <zachk> there is nowhere to pass the constraint into a regular functor in haskell 
15:53:53 <monochrom> the subtle one is: in the case of finite sets, if you somehow can argue that finite sets are functors, then "size :: Set a -> Int" is no longer parametric.
15:54:19 <zachk> do you mean math set's or Data.Set.Set's ? 
15:54:50 <Gurkenglas> So really the feature of Sets that breaks Functor is the deletion of duplicates, because what constitutes a duplicate is given by a lawless class.
15:55:20 <koz_> Gurkenglas: OK, *that* I understand. Thank you.
15:55:39 <koz_> I guess I was assuming stuff about Eq that wasn't actually there.
15:56:01 <monochrom> I don't think "Eq has laws" would help.
15:56:02 <Gurkenglas> Yea I'd wish there was a law in there that said x == y -> f x == f y
15:56:13 <dedgrant> Gurkenglas: .. ie. that Eq does not imply substitution?
15:56:28 <zachk> that looks like functional extensionality
15:56:47 <zachk> er wait
15:56:52 <monochrom> it is Leibniz
15:57:00 <zachk> ty :D
15:57:11 <monochrom> it is one of the most important and most overlooked requiement on equality
15:57:12 <zachk> that is not too hard to prove in a proof language 
15:57:27 <frerich> conal: I suppose you're not around, are you? i'm curious whether you know anything about the book "Functional Reactive Programming" by "Stephen Blackheath". My understanding is that there is a lot of misunderstanding about what the essence is of FRP exactly, so I'd rather not buy (or recommend) a misguided book :-]
15:57:38 <monochrom> yes, only because most proof languages have it as built-in.
15:57:42 <conal> frerich: hi.
15:58:12 <frerich> conal: Oh, hi!
15:58:25 <conal> i gave stephen's book a couple very quick skims and had some lengthy discussions with stephen (including on the publisher's forum site).
15:58:36 <monochrom> furthermore, many of them has to have it built-in, e.g., you can't say it using first-order expressions, so a prover that only let's you say first-order things has to provide it as a built-in, not user-definable.
15:58:49 <zachk> is it built into agda as well? 
15:59:14 <monochrom> I think agda is higher-order enough to say it as library code
15:59:48 <Gurkenglas> And the other reason for Set not being a functor (the one about it having a constraint) is stupid; we should be allowed to define Functors within the category of types with an Eq instance
15:59:53 <monochrom> which means it is user-definable but why bother, let's put it in the standard library for all to enjoy
15:59:55 <zachk> isn't the reflexive equality in agda, structural, and the functions are constructive so...no idea how to finish that thought in words 
16:00:23 <conal> frerich: i questioned calling his stuff "FRP", as it seemed to lack both fundamental properties of FRP --- simple precise specification/denotation & continuous time.
16:00:53 <conal> frerich: after our conversations, i think stephen at least tried to relate his implementation to some sort of spec/denotation, and gave at least a little thought to continuous time, but i don't know how well it came out.
16:00:58 <zachk> here is a link for Functor Set: https://hackage.haskell.org/package/set-monad-0.2.0.0/docs/Data-Set-Monad.html
16:01:04 <Cale> Gurkenglas: Well, it's not that stupid I think. It certainly complicates any polymorphic usage sites for fmap if it's constrained.
16:01:40 <koz_> If I have a typeclass whose minimal complete definition is 'Nothing', does that mean that if I don't define one of the typeclass's functions, it doesn't exist/can't be used?
16:01:53 <frerich> conal: Ah, that's interesting. I watched a couple of your talks and gathered that the concept of time being continuous (as opposed to being discrete) is one of the original (or basic ideas), but it's often neglectedd - many explanations of FRP seemed to force behaviours into a discrete corset.
16:01:54 <koz_> I'm asking about this specifically: http://hackage.haskell.org/package/classy-prelude-0.12.5/docs/ClassyPrelude.html#g:4
16:01:59 <conal> frerich: if you haven't already, i suggest reading my answer to https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language and following the links from there.
16:02:20 <Cale> frerich: It's often not terribly clear what exactly "continuous" means here.
16:02:31 <conal> frerich: indeed. continuous time (reals) was the founding idea.
16:02:52 <conal> Cale: it's clear & simple in the denotation.
16:02:57 <Cale> There are many different compromises one can make about the structure of time, and what operations are available on time itself, and they lead to different performance tradeoffs.
16:03:37 <frerich> conal: Ah, thanks - no, I wasn't aware of that StackOverflow answer. Let me digest that.
16:03:43 <conal> oddly, i've heard the claim that discrete time is somehow more efficient, while my long experience says the opposite. 
16:03:59 <Cale> conal: Well, it's not even just continuous vs. discrete
16:04:07 <conal> sadly, folks often skip giving any denotation at all, so their implementations are not even wrong (lacking a definition of correctness).
16:04:47 <Gurkenglas> "class ConstrainedFunctor c f where cfmap :: (c a, c b) => (a -> b) -> f a -> f b; <requirement that f define 'instance c a => c (f a)'>"
16:05:15 <Cale> conal: e.g. in Reflex, a Behaviour might *in principle* be changing continuously, but there's a limit to the extent to which you can actually observe that this is the case, because you can't actually measure the value of a Behavior at a time between the occurrences of any Events which are in scope.
16:06:55 <acertain> Gurkenglas, you can do that with https://hackage.haskell.org/package/constraints, e.g. "class ConstrainedFunctor c f where { cfmap :: (c a, c b) => (a -> b) -> f a -> f b; impliesInst :: c a :- c (f a) }
16:07:11 <conal> Cale: afaik, reflex doesn't have a (simple & precise) denotation. a few months ago, i encouraged ryan to give it a try. i haven't heard from him.
16:07:23 <koz_> Also, I'm trying to figure out how to implement the Element type family for something of mine, and I'm not sure how to proceed: http://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html#t:MonoFoldable
16:07:24 <johnw> Cale: a refinement of a denotational specifications only needs to be a subset of the abstract representation; so you can model in continuous time, but you aren't required to simulate it in the implementation
16:07:28 <koz_> Sorry, wrong link.
16:07:41 <conal> Cale: would be useful in revealing design flaws.
16:07:43 <Cale> conal: There's a reasonably simple pure implementation to work from
16:07:50 <koz_> http://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html#t:Element <-- actual link to said type family
16:07:50 <dedgrant> Cale: isn't it more productive to show that real-time denotation accommodates discrete effects (for example, temporal aliasing, which is critical to design of many feedback systems), in order to credit the benefits of the denotational semantics?
16:08:08 <johnw> the denotation still holds if the abstract relations maps abstract -> concrete faithfully
16:08:12 <johnw> s/abstract/abstraction
16:08:46 <conal> Cale: i wonder if that implementation is nearly as simple as the original denotation. the simplicity is crucial for making dependable reasoning practical.
16:09:07 <johnw> conal: that is, if you don't have a prove system to establish the relation :)
16:09:15 <johnw> s/prove/proof
16:14:54 <x_pilot> O
16:15:00 <x_pilot> whoops
16:15:11 <x_pilot> I'm getting some strange behavior from ByteString
16:15:21 <x_pilot> namely the length function seems to be hanging
16:15:31 <x_pilot> and never returning
16:15:55 <frerich> To be honest, after reading about it a bit, I'm not sure I'm able to clearly tell the terms semantic and denotation apart.
16:16:12 <Cale> johnw: Yeah, I expect that, when we do have some formal semantics for Reflex, there will be both discrete-time and continuous-time models.
16:16:51 <Cale> johnw: Behaviors in reflex are continuous-time only insofar as you can't tell when they change.
16:18:36 <MarcelineVQ> psaww egg on your faces when timeless physics become the norm
16:19:50 <c_wraith> x_pilot, I suspect an infinite loop in the creation, and calling length is the first place it gets forced 
16:21:12 <crossroads1112> Could someone explain to me how the line `foldr1 f $ map g $ tail primes` works in this prime generation function?
16:21:15 <crossroads1112> http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)#Core_functionality
16:22:28 <crossroads1112> Hello?
16:22:43 <Cale> crossroads1112: hi
16:22:54 <Cale> crossroads1112: I was just looking at the page you linked, sorry
16:22:58 <x_pilot> c_wraith: I see. sadly this is likely the result of some OpenGL/GLUT calls, which will be tough to debug
16:23:02 <crossroads1112> sorry, I didn't mean to pester, I just couldn't tell if my irc client was misconfigured 
16:23:03 <Cale> There are some rather misleading statements on it :P
16:23:17 <crossroads1112> I've been having issues with it lately
16:23:34 <Cale> "Being right-associative, the $ operator forces the last call – tail primes – to be evaluated first." -- associativity of an operation has essentially nothing to do with evaluation order
16:23:53 <Cale> and in fact, this is false
16:24:12 <Cale> The foldr1 gets applied first
16:24:17 <crossroads1112> I had that same thought. Isn't one of the hallmarks of "pure" code that the programmer has no concept of evaluation order?
16:24:31 <Cale> Well, if you assume that evaluation is lazy
16:24:57 <Cale> That's a specific evaluation order which is close enough to what the compiler does to get a good sense of how programs will behave
16:25:11 <crossroads1112> Oh, I see
16:25:40 <Cale> Though, you're correct, the specification doesn't say which order, only what the termination behaviour and results of programs should be
16:26:12 <Cale> and the implementation is allowed to compute things sooner if it can tell that it's safe to do so
16:26:21 <csd_> quickcheck question.. so i have a toy poker program. type Hand = [Card]. i defined an instance Arbitrary Hand. i would like to create a generator such that, for example, i can give a pair of cards, and have it generate all possible hands that use those cards. How would I do that?
16:27:44 <c_wraith> csd_, quickcheck isn't great at that sort of thing.. unless you're picking the two cards statically 
16:27:54 <csd_> yeah i'd provide the two cards
16:27:56 <Cale> csd_: I guess take the list of all cards, remove the given cards from it, and make some selections from the list (with removal)
16:28:13 <crossroads1112> Cale: So, as I've been taught to do, I attempted to examine the types. I loaded f and g into ghci and the type of the foldr1 line is (Enum t, Num t, Ord t, Foldable ((->) [t])) => [[t]]. This confuses me for a few reasons. Firstly, foldr1 is only supposed to take two arguments, why is it taking three here? Also the `Foldable ((-.
16:28:14 <Cale> csd_: There's a function that I often find handy in cases like this
16:28:18 <crossroads1112> Sent that too soon
16:28:23 <Cale> select [] = []
16:28:38 <c_wraith> csd_, then just partially apply the function before passing it to quickcheck 
16:28:40 <crossroads1112> The `Foldable ((->) [t])` Part was unfamillar to me
16:28:44 <Cale> select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
16:29:03 <csd_> Cale: the part i'm confused by is that when i run a property test through quickCheck, quick check is supplying the missing function argument based upon the arbitrary instance that fits the type signature
16:29:07 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
16:29:08 <lambdabot>  Defined.
16:29:11 <csd_> but, that wouldnt be possible here
16:29:20 <Cale> csd_: You can use forAll to override which generator to use
16:29:28 <acertain> haskell evaluation order is defined to an extent because of bottoms (loops/error/undefined)
16:30:05 <acertain> e.g. `(\_ x -> x) undefined 1 = 1`
16:30:06 <c_wraith> crossroads1112, the compiler is trying too hard to make sense of what you wrote, if it's inferring that. 
16:30:20 <Cale> acertain: Yeah, though you could be overly strict to some extent, and then back off if it was taking too long, for example. (Not that this would generally be a great idea)
16:30:33 <c_wraith> crossroads1112, you almost certainly forgot an argument to a function from Foldable 
16:31:01 <crossroads1112> c_wraith: Did you see the link that I posted earlier?
16:31:08 <csd_> Cale: so id have to write my own quickcheck function?
16:31:15 <Cale> csd_: no
16:31:19 <c_wraith> crossroads1112, but ghc is saying "no, I can figure out how to make this code correct. I just need to be able to fold across functions!" 
16:31:36 <Cale> csd_: forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
16:32:02 <Cale> csd_: Property is the right sort of thing to pass to the quickCheck function (it has a Testable instance)
16:32:50 <Cale> csd_: That is, for any *function* you could already pass to quickCheck, you could give it to forAll instead, along with a specific generator.
16:33:13 <csd_> oh i see
16:34:01 <csd_> thanks cale
16:34:02 <crossroads1112> c_wraith: I'm trying to figure out what the `foldr1 f $ map g $ tail primes` is doing in the function detailed here Enum t, Num t, Ord t, Foldable ((->) [t])) => [[t]]
16:34:05 <crossroads1112> oope
16:34:09 <crossroads1112> here:
16:34:10 <crossroads1112> 
16:34:10 <crossroads1112> http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)#Core_functionality
16:34:58 <Gurkenglas> crossroads1112, it explains it a few paragraphs later, under the heading of Non-prime numbers
16:35:51 <monochrom> "haskell evaluation order ... defined ..." depends fundamentally on which "haskell" you are talking about. and there are two common cases.
16:36:28 <monochrom> one case is "Haskell Report haskell", which paranoidly refrains from any order whatsoever, to the point it becomes unhealthy.
16:36:37 <dzdncnfzd> I've been reading a bunch of stuff about the Free monad, and how we should use it everywhere and completely separate semantics / meaning from implementation and so on. Does anyone know some nice codebases where this is practically put to use?
16:36:51 <Cale> lol, they took the naive implementation from Melissa O'Neill's paper, but not the other
16:37:11 <monochrom> another case is "haskell in practice", in which you know for sure it's lazy evaluation with small variations due to optimizer smartness.
16:37:17 <Cale> and I'm not certain, but I think the criticisms expressed in the paper still apply to this one
16:37:59 <Cale> Well, I guess it's probably a bit less naive than the naive one at least
16:38:32 <monochrom> here is an example you should always bear in mind. to evaluate "const x y", the Haskell Report totally permits you to fork two threads, have one thread work on x, have another thread work on y, then kill the 2nd thread when the 1st thread finishes.
16:38:45 <crossroads1112> Gurkenglas What I don't understand is how it is passing `map g` instead of a list and how they are doing a right fold on an infinite list
16:39:04 <monochrom> but it is not going to be consistent with what you see on your electricity bill in practice
16:39:07 <Ygg> This language is addictive
16:39:18 <Cale> crossroads1112: $ associates to the right, unfortunately
16:39:27 <Cale> So that's  foldr1 f (map g (tail primes))
16:39:36 <monochrom> to explain your electricity bill, you really have to commit to lazy evaluation. similarly to explain your memory bill.
16:39:50 <Gurkenglas> > foldr (\x xs -> x : x : xs) undefined [1..] -- crossroads1112, here's an infinite right fold
16:39:52 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
16:40:17 <Cale> crossroads1112: It's left fold which doesn't work for infinite lists
16:40:25 <Cale> @src foldl
16:40:25 <lambdabot> foldl f z []     = z
16:40:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:40:47 <Cale> ^^ foldl does nothing but apply itself to new arguments when given a nonempty list. If the list is infinite, it will never produce anything.
16:40:51 <Cale> @src foldr
16:40:51 <lambdabot> foldr f z []     = z
16:40:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:41:32 <Cale> ^^ by contrast, foldr applies the function f in the nonempty case, and f may or may not need to pattern match its second argument in order to produce anything.
16:42:35 <monochrom> there are times I am happy to talk at the Haskell Report level. but at that level, as per the Haskell Report, I talk denotation, not evaluation.
16:42:47 <Cale> In cases where f can produce a data constructor without needing to rely on its second argument, this will work just fine
16:44:04 <crossroads1112> Oh, I'm an idiot. I forgot how $ worked. They even spelled it out for me
16:44:21 <crossroads1112> Thank you
16:45:35 <dzdncnfzd> :t foldl
16:45:37 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
16:45:51 <dzdncnfzd> :t foldr
16:45:53 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:47:02 <dzdncnfzd> @src reverse
16:47:02 <lambdabot> reverse = foldl (flip (:)) []
16:47:03 <Gurkenglas> :t alaf Endo foldMap -- Maybe foldr had its signature in the wrong order all along
16:47:05 <lambdabot> Foldable t => (a1 -> a -> a) -> t a1 -> a -> a
16:48:13 <Denommus> is there a monadic prolog library, if that's even possible?
16:50:02 <monochrom> there is a monadic search-through-nondeterminism library ("logict"). but I think there is no logic-variable-unification library.
16:53:38 <crossroads1112> @src foldl
16:53:39 <lambdabot> foldl f z []     = z
16:53:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:54:15 <crossroads1112> @src foldr
16:54:15 <lambdabot> foldr f z []     = z
16:54:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:56:00 <Xnuk> @src (<*>)
16:56:00 <lambdabot> Source not found. My mind is going. I can feel it.
16:56:10 <Xnuk> @src (*>)
16:56:10 <lambdabot> (*>) = liftA2 (const id)
16:56:58 <Xnuk> @unpl const id
16:56:58 <lambdabot> (\ _ b -> b)
17:00:51 <crossroads1112> @src foldr1
17:00:51 <lambdabot> foldr1 _ [x]    = x
17:00:51 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
17:00:51 <lambdabot> foldr1 _ []     = undefined
17:01:35 <crossroads1112> @src foldl1
17:01:35 <lambdabot> foldl1 f (x:xs) = foldl f x xs
17:01:35 <lambdabot> foldl1 _ []     = undefined
17:16:18 <bramantio> s
17:16:25 <bramantio> hello all
17:18:06 <bramantio> hello cdg
17:43:10 <dhess> Hi, anyone here familiar with how GHC implements threadWaitRead in Control.Concurrent?
17:45:31 <Gurkenglas> https://hackage.haskell.org/package/constraints should have TH for generating all the instances
17:54:33 <dedgrant> What is the c.t. vocabulary attributed to the applicative functor analogs `pure` and <*>?  What is said in fast and loose discussion :)
17:55:53 <dedgrant> pure & apply?
17:55:59 <shachaf> Not sure that there are words.
17:56:02 <dedgrant> yea
17:56:45 <shachaf> https://ncatlab.org/nlab/show/closed+functor calls them F̂ and F⁰
17:57:29 <dedgrant> "eff-hat" and "eff-oh" perhaps in conversation?
17:58:00 <shachaf> And an Applicative functor is a monoid object in a particular category, so you could call those things whatever you call them unit and product for a monoid.
17:58:27 <dedgrant> That may work well in my context, ie. discussion as an associative product
17:59:02 <shachaf> The category is the category of endofunctors with Day convolution as tensor product.
17:59:42 <cem__> hi
18:00:13 <cem__> how to find a number is perfect square or not in haske;;
18:00:21 <cem__> haskell*
18:01:07 <Enigmagic> pretty much the same way in any language
18:01:24 <achernyak> is there a nicer way to write mapM_ ($ destination') (fmap cd_r fileList') 
18:01:34 <cem__> its O(n^2)
18:01:39 <achernyak> I marked the variables with '
18:01:57 <cem__> Enigmagic is there any formula
18:02:35 <achernyak> and I tried using sequence_ but that seems to never apply the destination' to the functions inside the array
18:02:35 <shachaf> achernyak: mapM_ (\f -> cd_r f destination') fileList'?
18:03:08 <cem__> i want is there any math formula to know the number is perfect square or not
18:03:26 <Enigmagic> cem__: i'd imagine google would be a good resource for that
18:04:20 <achernyak> shachaf, that does make it a bit nicer. I was trying to look for a method to map a list functions to a variable, but I think I actually like your anonymous function better. Only one traversal that way.
18:05:14 <achernyak> shachaf, thanks for the help. It definitely works!
18:06:26 <dedgrant> schachaf: Reading up on Day convolution on ncatlab :)
18:07:27 <shachaf> achernyak: Here's a confusing one: sequence_ (mapM cd_r fileList' destination')
18:11:51 <achernyak> shachaf, haha I was close on my other solution I had sequence_ (fmap cd_r fileList') destination' That was the one that didn't produce any results
18:12:09 <shachaf> Don't use the thing I wrote, it's terrible.
18:12:18 <shachaf> It uses the fact that map ($ x) fs = sequence fs x
18:12:59 <shachaf> That inner mapM is happening in a different monad from the other one.
18:13:02 <achernyak> shachaf,  yeah I was just trying to get better with my understanding of sequence seems like I rarely get to use it
18:14:09 <achernyak> ah I see how that could lead to some trouble if mapM is a different monad
18:14:42 <achernyak> I'll stick with your first suggestion :)
18:19:55 <linman32> hi, are there python bindings for haskell available?
18:22:40 <cem__> http://burningmath.blogspot.in/2013/09/how-to-check-if-number-is-perfect-square.html is this correct
18:23:02 <cem__> i was thinking about nice formula :)
18:28:59 <dzdncnfzd_> Guys I'm so close and I just need to know how to create a file. 
18:30:00 <dzdncnfzd_> I'm using System.IO but when I use: handle <- IO.openFile "~/example.html" IO.ReadWriteMode   I get "~/example.html: openFile: does not exist (No such file or directory)
18:30:11 <dzdncnfzd_> Is there something I'm missing
18:30:38 <dzdncnfzd_> I've also tried IO.WriteMode
18:30:41 <Enigmagic> dzdncnfzd: have you tried a path without a ~ in it? i don't think openFile expands shell variables
18:30:46 <dhess> dzdncnfzd_: Use the absolute path, openFile won't interpolate the "~"
18:32:41 <dzdncnfzd_> dhess: Thank you!!! God, I've been working on this so long I'm living up to my name
18:32:47 <dzdncnfzd_> Enigmagic++
18:33:25 <Enigmagic> psychic debugging
18:51:33 <homovitruvius> could somebody help me understand the error in http://dpaste.com/09SWCVR? it is about not being able to deduce an instance for a Monad I don't see anywhere. I've been banging my head on this for quite a long while... Thx
18:52:32 <whisk> S'it going?
18:52:55 <whisk> Marco.........
18:53:03 <bsmt> polo?
18:53:15 <whisk> There is life in this planet
18:53:33 <whisk> sup
18:53:43 <bsmt> not much
18:53:46 <bsmt> wishing it were summer
18:53:50 <geekosaur> homovitruvius, Parsec is ParsecT over Identity
18:54:03 <geekosaur> er, Parser which hides even more stuff
18:54:38 <geekosaur> Parser is roughly ParsecT String () Identity
18:55:08 <whisk> I feel ya bsmt
18:55:14 <geekosaur> in particular that means no IO
18:55:24 <whisk> Input Output
18:55:25 <whisk> ?
18:55:28 <homovitruvius> geekosaur: that is my Parser though, not Parsec'
18:56:37 <whisk> I wan't to check your code
18:57:01 <whisk> What are you parsin?
18:57:03 <whisk> g
18:57:13 <whisk> Lets pars
18:57:15 <whisk> e
18:57:54 <whisk> def pimpin(): 
19:00:11 <cynick>   m     
19:00:25 <whisk> ?
19:01:31 <whisk> Who can agree with me in the fact that the fight scenes in the new start wars, sucked donkey penis.
19:04:14 <glguy> whisk: Please stay on topic in #haskell
19:04:21 <sgronblo> whisk: i thoguht it was kind of typical stuff for modern action movies
19:06:47 <whisk> sure, whats the topic. 
19:08:17 <whisk> sgronble: yeah, but Kylo Ren was not a good casting choice.
19:09:49 <glguy> The topic is the Haskell programming language. Movie discussion is offtopic
19:14:20 <homovitruvius> no ideas on http://dpaste.com/09SWCVR? I've run out of ideas of my own...
19:17:16 <Cale> homovitruvius: Can we see the rest of your program?
19:18:10 <Cale> homovitruvius: There's clearly stuff missing, the error is discussing a part of the code which isn't what you pasted
19:18:23 * hackagebot machines 0.6 - Networked stream transducers  https://hackage.haskell.org/package/machines-0.6 (EdwardKmett)
19:18:46 <Cale> oh, er...
19:18:54 <Cale> I see, there's an extra line after the comment
19:19:00 <Cale> almost missed that
19:20:03 <nut_> Hello, could anyone explain briefly this code on ReaderT?
19:20:05 <nut_> ReaderT ApiConfig (ResourceT IO) a
19:20:43 <nut_> ApiConfig is a config that gets passed around
19:21:08 <nut_> i get that, but what about ResourceT IO
19:21:10 <nut_> and a
19:21:18 <ReinH> nut_: did you look up ResourceT?
19:21:26 <ReinH> a is a type variable.
19:21:35 <nut_> so a can be anything
19:21:38 <ReinH> yes
19:21:55 <nut_> when will anyone use this ?
19:22:26 <nut_> So in English, that code means what ?
19:22:28 <andromeda-galaxy> homovitruvius: well, do you ever declare any instances for HasReadFile, apart from the RIO one?
19:22:28 <ReinH> When they have an ApiConfig value to read and some resources to manage while possibly performing IO.
19:22:47 <Cale> oh, right, homovitruvius -- if you replace the definition of Parser, then the type of aOrB becomes more constrained
19:23:15 <ReinH> @hackage resourcet -- ResourceT is defined here
19:23:15 <lambdabot> http://hackage.haskell.org/package/resourcet -- ResourceT is defined here
19:23:27 <homovitruvius> andromeda-galaxy: in the real code I have an instance that has a file-system-in-a-string for testing purposes
19:23:27 <nut_> i'm guessing that there are some actions to be performed on apiconfig and return a
19:24:21 <ReinH> A ReaderT ApiConfig (ResourceT IO) a value is an action which can read an ApiConfig value, specify resources to be released, and perform IO while producing an a
19:24:37 <homovitruvius> Cale: yes, but where Identity pops up from. m should be (HasReadFile m) everywhere, no?
19:24:50 <nut_> thanks ReinH
19:24:53 <Cale> Well, the return you're applying doesn't do a whole lot
19:25:00 <nut_> That clarifies a bit
19:25:13 <Cale> The monad to be used is being inferred from the fact that you're applying evalState to the result of runPT
19:25:28 <ReinH> nut_: yw
19:25:57 <andromeda-galaxy> homovitruvius: never mind, Cale got where I was going faster
19:26:02 <andromeda-galaxy> that seems to happen to me a lot in here
19:26:05 <Cale> i.e.  flip evalState 0 $ runPT aOrB  () "" s :: Either ParseError Int
19:26:36 <homovitruvius> Cale: and shouldn't that type be forall m . (HasReadfile m) => m (Either ParseError Int) ?
19:26:52 <Cale> hm?
19:27:03 <Cale> Why would it?
19:27:34 <Cale> runPT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
19:28:06 <Cale> So if we don't constrain the type of aOrB at all...
19:29:11 <Cale> oh, right, awkward -- it's going to complain about ambiguities
19:29:24 <Cale> anyway, with the correct definition of Parser that you gave
19:29:34 <Cale> and aOrB as it was
19:29:54 <Cale> we have runPT aOrB :: Monad m => () -> Text.Parsec.Pos.SourceName -> String -> StateT Int m (Either ParseError Int)
19:29:58 <zoku> is there a usual method for submitting patches to libraries on hackage?
19:30:18 <ReinH> zoku: it depends on the library.
19:30:27 <Cale> and then filling in the rest, we get to  StateT Int m (Either ParseError Int)
19:30:39 <Cale> So m still isn't quite determined by that
19:30:46 <ReinH> Some might use github pull requests, some might use some other mechanism. Usually they will specify a repository and/or an issue tracker
19:30:51 <zoku> ah, this one links to github
19:30:52 <Cale> But then we apply evalState
19:30:56 <zoku> i'll fork i ton there
19:31:29 <Cale> and m gets picked to be Identity, effectively
19:31:53 <Cale> (because  evalState :: State s a -> s -> a  and  type State s = StateT s Identity)
19:32:14 <geekosaur> sigh, knew I was missing something there
19:32:23 <Cale> and you didn't supply an instance of HasReadFile for Identity, so that's where things go wrong
19:32:24 <geekosaur> (also realized I was getting too tired and backed out...)
19:32:55 <homovitruvius> Cale: thx, I see it now
19:33:01 <dzdncnfzd_> I'm trying to use the web-encodings project michael snoyman wrote (https://hackage.haskell.org/package/web-encodings-0.3.0.9/docs/Web-Encodings.html) but 1. it doesn't work with my dependencies 2. hackage says its deprecated. Does anyone know the replacement?
19:33:13 <ReinH> dzdncnfzd_: what are you using it for?
19:33:25 <dzdncnfzd_> decoding html special characters
19:33:32 <Cale> homovitruvius: If you change it to evalStateT, and remove the spurious extra return, then you can make it HasReadFile-constrained instead
19:33:58 <ReinH> dzdncnfzd_: in a client, a server? Which libraries are you using already?
19:35:11 <dzdncnfzd_> ReinH: ...I might classify it as a client? I don't know the precise definition of terms. It's a thing that grabs json and then reformats it into a new web document. I'll paste my build-depends
19:35:35 <dzdncnfzd_> ReinH: http://lpaste.net/148898
19:36:19 <ReinH> dzdncnfzd_: xml-conduit has an html entitiy decoder: http://hackage.haskell.org/package/xml-conduit-1.0.3.1/docs/Text-XML-Stream-Parse.html#t:DecodeEntities
19:38:14 <scshunt> I'm afraid to ask this but... are there any libraries to design monads with more than one kind of execution? That essentially end up having to be free monads so that the structure is preserved prior to their first execution?
19:38:27 <dzdncnfzd_> ReinH: Thanks for now!
19:38:29 <scshunt> if this makes any sort of sens
19:38:30 <scshunt> *sense
19:38:52 <dzdncnfzd_> ReinH: I have some questions for you later about properly structuring programs where you cannot escape monads no matter how you try
19:38:53 <koz_> I'm getting really confused about MonoFoldable.
19:39:04 <ReinH> SCHAAP137: so... free monads?
19:39:07 <ReinH> er
19:39:18 <ReinH> scshunt: have you seen the operational package?
19:39:27 <scshunt> no!
19:39:32 <ReinH> @hackage operational
19:39:32 <lambdabot> http://hackage.haskell.org/package/operational
19:39:44 <koz_> http://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-MonoTraversable.html#t:MonoFoldable <-- Basically, I have a container 'RuleSet a' which contains 'Rule a's.
19:40:04 <erlandsona> any thoughts on how to replace every 20th char of a string?
19:40:07 <koz_> When I try to do 'instance MonoFoldable (RuleSet a)', however, it complains at me that I haven't defined Element for RuleSet a.
19:40:28 <koz_> However, when I define it, it gives me an error regarding it expecting Rule as, and instead getting as!
19:40:35 <koz_> I'm not precisely sure what I am missing here.
19:40:52 <ReinH> erlandsona: split it into chunks, map over the chunks changing the head using pattern matching, and then join
19:40:53 <scshunt> ReinH: thanks for the link! Not sure it's quite what I want, but I need to chew on that more
19:40:53 <zoku> yay! just made my first haskell pull requst
19:41:01 <zoku> https://github.com/barrucadu/irc-client/pull/8
19:41:14 <ReinH> s/join/concat
19:41:21 <ReinH> or rather, concatMap
19:41:58 <erlandsona> Thanks ReinH!
19:42:05 <ReinH> or write your own recursive function using splitAt
19:42:49 <ReinH> scshunt: How does what you're asking for differ from free monads?
19:43:10 <koz_> http://paste.rel4tion.org/199 <-- my code so far, if that'd help.
19:43:15 <scshunt> ReinH: I'm trying to figure that out :D
19:43:44 <scshunt> ReinH: there's a list monad in here somewhere too
19:44:33 <erlandsona> ReinH: So chunksOf breaks the string in the wrong places and the [String]'s that gets created doesn't allow me to properly change the head of each String...
19:46:40 <erlandsona> What I need I think is something that keeps track of the index of the String with an accumulater so that I can replace the char at every 20th index? chunksOf won't let me replace... I looked into the chunksOf implementation to see if I could write a similar function but I'm a Haskell newb and figured there'd be an easier solution?
19:47:09 <andromeda-galaxy> erlandsona: what's wrong with chunksOf?
19:47:47 <erlandsona> Say I have "    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30"...
19:48:04 <erlandsona> chunksOf 20 that^String ==
19:48:13 <erlandsona> ["    1  2  3  4  5  6","  7  8  9 10 11 12 1","3 14 15 16 17 18 19 ","20 21 22 23 24 25 26"," 27 28 29"]
19:48:34 <andromeda-galaxy> erlandsona: isn't that what you needed?
19:49:22 <andromeda-galaxy> > join $ map (\x -> "f":tail x) $ chunksOf 20 "    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30"
19:49:23 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
19:49:24 <lambdabot>      Expected type: [[Char]]
19:49:24 <lambdabot>        Actual type: [Char]
19:49:28 <scshunt> ReinH: the problem is really that I envision my primitives sort of living outside of the monad... hmm
19:49:36 <erlandsona> Notice how 13 is split... If I'm changing the head of each 13 becomes 1  14... when I join it back together... I need to keep the numbers in tact.
19:49:40 <andromeda-galaxy> > join $ map (\x -> 'f':tail x) $ chunksOf 20 "    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30"
19:49:42 <lambdabot>  "f   1  2  3  4  5  6f 7  8  9 10 11 12 1f 14 15 16 17 18 19 f0 21 22 23 24 ...
19:49:59 <andromeda-galaxy> erlandsona: I'm not sure that I understand...
19:50:13 <erlandsona> what I want is...
19:50:16 <andromeda-galaxy> erlandsona: that code snipped replaced every 20th char in the string with an 'f'
19:51:17 <erlandsona>     1  2  3  4  5  6\n7  8  9 10 11 12 13\n14 15 16 17 18 19 20\n21 22 23 24 25 26 27\n28 29\n
19:52:24 <koz_> This is as far as I get: http://paste.rel4tion.org/200
19:52:30 <scshunt> ReinH: basically what I'm thinking is there's an underlying state monad. The point is to sort through actions on that monad
19:52:41 <andromeda-galaxy> > head $ join $ map (\x -> 'f':tail x) $ chunksOf 20 $ ' ':"    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30" -- erlandsona: if the problem was that the other one was splitting one char too early, here's an easy fix
19:52:42 <lambdabot>  'f'
19:52:49 <andromeda-galaxy> > tail $ join $ map (\x -> 'f':tail x) $ chunksOf 20 $ ' ':"    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30" -- erlandsona: if the problem was that the other one was splitting one char too early, here's an easy fix
19:52:50 <lambdabot>  "    1  2  3  4  5  f  7  8  9 10 11 12 f3 14 15 16 17 18 19f20 21 22 23 24 ...
19:53:22 <andromeda-galaxy> erlandsona: never mind, sorry, typed that one wrong
19:53:27 <scshunt> Some actions require a choice between actions, which they can either get from an outside source (e.g. a user) or can get by acting like the list monad
19:53:50 <andromeda-galaxy> > tail $ join $ map (\x -> 'f':tail x) $ chunksOf 20 $ (take 20 $ repeat ' ')++"    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30" -- erlandsona: if the problem was that the other one was splitting one char too early, here's an easy fix
19:53:52 <lambdabot>  "                   f   1  2  3  4  5  6f 7  8  9 10 11 12 1f 14 15 16 17 18...
19:54:16 <andromeda-galaxy> > drop 19 $ join $ map (\x -> 'f':tail x) $ chunksOf 20 $ (take 19 $ repeat ' ')++"    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30"
19:54:16 <koz_> Could someone give me a clue as to what I'm missing in my code posted here? http://paste.rel4tion.org/200
19:54:17 <lambdabot>  " f  1  2  3  4  5  6 f7  8  9 10 11 12 13f14 15 16 17 18 19 2f 21 22 23 24 ...
19:54:36 <andromeda-galaxy> erlandsona: never mind, actually, that's a bad approach
19:54:58 <erlandsona> Yeah sorry this is the string I want...
19:54:58 <erlandsona>     1  2  3  4  5  6\n 7  8  9 10 11 12 13\n14 15 16 17 18 19 20\n21 22 23 24 25 26 27\n28 29\n
19:55:27 <andromeda-galaxy> erlandsona: so, is the problem that the replacement character is getting inserted in the wrong place?
19:57:14 <erlandsona> I think so... I'm basically creating a 20 column grid right? Its the unix cal program but in Haskell...
19:57:24 <erlandsona> just do like a > cal 2 2016
19:59:52 <erlandsona> ...is what I'm going for.
20:01:02 <andromeda-galaxy> erlandsona: it's kind of hacky (it drops the first two characters and replaces them with a space), but how about this:
20:01:05 <andromeda-galaxy> > ' ':' ':(tail $ join $ map (\x -> 'f':tail x) $ chunksOf 20 $ tail "    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30")
20:01:07 <lambdabot>  "    1  2  3  4  5  6 f7  8  9 10 11 12 13f14 15 16 17 18 19 2f 21 22 23 24 ...
20:02:12 <andromeda-galaxy> erlandsona: alternativel,
20:03:10 <umayahabdennabi> does anyone happen to know which library “Date” is located in.  I’m getting the following error UnexpectedNull {errSQLType = "Date", errHaskellType = "UTCTime", errMessage = ""}
20:07:36 <andromeda-galaxy> erlandsona: implement a recursive function with splitAt to do it
20:07:58 <erlandsona> andromeda: closer... but 20 gets cut off right? the issue is really that we need a function replaceEvery instead of chunks of that goes through the string and instead of just breaking it apart as is... replacing the characters at indexes that equal a multiple of the number given... It feels like it should be a recursive thing or something?
20:08:57 <andromeda-galaxy> erlandsona: the idea of using chunksOf is that breaking the string into chunks and replacing the nth char in each chunk does the same thing; chunksOf + some kind of 'replace last' would be fine, but horribly inefficent since strings are linked lists in haskell
20:10:16 <andromeda-galaxy> erlandsona: splitAt is probably the way to go for a recursive version, or you could do your own, e.g. 'replaceAt (x:xs) replacement goal count | goal == count = replacement:xs | otherwise = x:replaceAt xs replacement goal (count+1)' (untested)
20:11:14 <erlandsona> Yeah something more like that... I'll work with that and see if I can't get close...
20:12:18 <harleyk> I'm trying to do something with the Crypto.Hash library where I take a string and turn it into a HashAlgorithm. I think I want something with the type of `(HashAlgorithm a) => String -> a` but that does not appear to work. Am I thinking about this problem incorrectly or is there a way to get what I want?
20:12:20 <andromeda-galaxy> erlandsona: sounds goodboy
20:12:23 <andromeda-galaxy> *good
20:12:58 <erlandsona> Thanks for all your help andromeda! Much appreciated! Hopefully one day I'll have enough experience to help someone else here!
20:13:24 <andromeda-galaxy> erlandsona: no problem! not long ago, I was feeling like that---I'm sure you'll be able to soon
20:14:08 <andromeda-galaxy> erlandsona: by the way, are you absolutely sure that 20 is the right number?
20:14:24 <andromeda-galaxy> (or that there are the right number of padding spaces at the beginning)?
20:16:29 <andromeda-galaxy> erlandsona: actually, it looks to me like you don't want to *replace* every 20th char,
20:16:37 <andromeda-galaxy> you want to *insert* every 20 thcar
20:16:40 <andromeda-galaxy> which makes this simple,
20:16:42 <andromeda-galaxy> look up intercalate
20:19:13 <andromeda-galaxy> erlandsona: never mind,
20:19:59 <andromeda-galaxy> erlandsona: but, are you sure that you don't wawnt to replace every 21st char?
20:20:07 <andromeda-galaxy> > tail $ join $ map (\x -> 'f':tail x) $ chunksOf 21 $ ' ':"                1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31"
20:20:09 <lambdabot>  "                1  2f 3  4  5  6  7  8  9f10 11 12 13 14 15 16f17 18 19 20 ...
20:20:10 <andromeda-galaxy> erlandsona: ^
20:20:21 <andromeda-galaxy> @more
20:28:16 <umayahabdennabi> what is the Date field in mysql-simple, UTCTime isn’t working?
20:39:12 <wedens> I have a .cabal file with unspecified versions for all dependencies. how can I set them to currently used version (semi-)automatically? (I use stack)
20:41:15 <andromeda-galaxy> wedens: I'm not sure, but cabal freeze seems roughly like what you want
20:41:44 <umayahabdennabi> is dynamic-cabal relevant? http://jpmoresmau.blogspot.in/2013/12/dynamic-cabal-to-solve-dependency-hell.html
20:42:36 <wedens> andromeda-galaxy: will stack respect  cabal.config?
20:42:40 <mgsloan> wedens: You can set them on upload via "--pvp-bounds".  I have schemes to support automatic version bounds that are wider https://github.com/commercialhaskell/stack/issues/1568
20:43:31 <andromeda-galaxy> wedens: never mind, mgsloan probably knows better; however, if you're using stack, do you need to set the versions in the .cabal file?  I thought that the premise of stack was that as long as you used stack & the same resolver snapshot, the dependency versions wouldn't change
20:43:58 <mgsloan> Right, you don't need to set version bounds for things to build, but you ought to set them for upload
20:44:21 <wedens> andromeda-galaxy: yeah, but I use both stack and Nix without stack
20:44:21 <mgsloan> What I like about the thing I've proposed in the issue linked above ^ is that it will be possible to automatically test multiple versions, and generate constraints from that
20:44:28 <andromeda-galaxy> wedens: ah, okay
20:44:47 <mgsloan> This means that with stack, we'll be able to generate wide version bounds, and have reasonable confidence that they are actually true
20:45:06 <mgsloan> (whereas with cabal-install, folks tend to just test the latest, and fix things as people run into them)
20:45:14 <wedens> mgsloan: I don't upload anywhere ;)
20:45:25 <mgsloan> Ah, well if you don't upload, you can just omit all your version constraints
20:45:43 <andromeda-galaxy> wedens: if you want them for nix, can you sdist with --pvp-bounds and then copy the generated cabal file back over the current one?
20:45:47 <pavonia> umayahabdennabi: What date field do you mean?
20:46:20 <umayahabdennabi> pavonia: for mysql-simple, my database uses a Datetime field
20:47:07 <umayahabdennabi> Both UTCTime and Day give an UnexpectedNull {errSQLType = "Date" error
20:48:59 <wedens> looks like I can. thanks andromeda-galaxy mgsloan 
20:49:06 <andromeda-galaxy> wedens: no problem, glad to be able to help
20:51:18 <mgsloan> Anyone here used the new GHC support for DWARF debug info?
20:52:06 <mgsloan> I've set "ghc-options: -O -g -rtsopts", as suggested here https://ghc.haskell.org/trac/ghc/wiki/DWARF , however, "objdump -Wi fib" does not yield anything like the output it should 
20:52:32 <mgsloan> And I haven't yet seen gdb stacktraces with more informative info
20:52:37 <pavonia> umayahabdennabi: Hhm, it seems these are the only date formats supported by that package, so no idea. Maybe report as a bug?
20:53:20 <umayahabdennabi> I would assume Datetime is a pretty popular field used in mysql
20:53:51 <umayahabdennabi> I was thinking of using the postgresql-simple version of Date in mysql-simple
20:54:29 <pavonia> umayahabdennabi: Oh wait, UnexpectedNull mean you get a NULL where your return type doesn't support that. Did you wrap your result type into a Maybe?
20:55:03 <umayahabdennabi> pavonia: No I didn’t.. looking into this now, thx a lot
20:55:38 <andromeda-galaxy> @tell erlandsona I think that you actually only want to replace every 21st char; it looks to me like this works: tail $ join $ map (\x -> 'f':tail x) $ chunksOf 21 $ ' ':"                1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31"
20:55:38 <lambdabot> Consider it noted.
20:57:29 <scshunt> ReinH: had a shower moment. Think that is what I want. Tahnks.
20:57:31 <scshunt> *Thanks
21:04:46 <umayahabdennabi> pavonia: Thanks, I changed UTCTime to Maybe UTCTime, and it fixed the issue
21:06:54 <koz_> I have the following (rather repetitive) instance declaration: http://paste.rel4tion.org/201 . Can I refactor it somehow to not be so repetitive?
21:07:35 <tippenei1> How can I compile for my debian linux server on my mac laptop? using stack preferrably, but whatever works
21:07:54 <tsani> I've been working recently on representing x86 assembly in Haskell. I used a free monad for this, but now I'm running into issues with labels; I can't find a way to represent jumps to labels that are defined further in the code.
21:08:28 <kadoban> tippenei1: Easiest way would just be to compile on the server itself. Otherwise … vm with the same platform?
21:09:11 <tippenei1> the server doesn't have enough memory, which is the reason I'm trying to do this in the first place
21:09:31 <tippenei1> I was hoping I didn't have to spin up a vm, but I suppose that willl have to do
21:09:35 <tippenei1> thanks for the sanity check
21:09:42 <tippenei1> or insanity, whichever
21:09:54 <kadoban> I suspect there's a better way that I just don't know :-/
21:10:00 <kadoban> But yeah that's what I'd do I guess.
21:12:01 <tsani> Specifically, one of the actions in the functor underlying the free monad produces a label for some address representation, so the constructor looks like Label (addr -> f) where f is where I tie the knot. This is nice because in the do notation I can write { l <- label ; {- interesting code -} je l }
21:13:07 <tsani> I thought to use monadfix since it's what turned up first when looking up how to use the results of later monadic binds earlier in a monadic computation, but there's no way to really write a MonadFix instance for Free f.
21:15:46 <tsani> I suppose I could refactor my Label action to instead take the name of the label to create as a string argument, and then add a constructor in my value type for label references, but that complicates the assembler a lot because now I have to keep track of a symbol table.
21:16:44 <tsani> Any suggestions for alternatives ? :/
21:27:33 <scshunt> ReinH: actually one third thought, no it isn't
21:28:41 <scshunt> my monad does weird self-referential shit and I'm far from sure that I'll get the right transformer behaviour around it
21:29:08 <scshunt> unless I just am not undrestanding it :/
22:04:07 <jle`> koz_: best thing i can think of is abstracting away the pattern as a high order function
22:04:47 <koz_> jle`: Can you have wheres or lets inside of an 'instance Foo Bar where ...' ?
22:05:01 <koz_> Or would I just need to create something external to 'feed forward' whatever it is?
22:05:03 <jle`> probably not; you'd have to define it outside
22:05:05 <jle`> yeah
22:05:05 <nut_> how can i put arment to cabal run
22:05:07 <jle`> and just not export it
22:05:11 <koz_> jle`: Thanks, I'll do that then.
22:05:11 <nut_> argument
22:05:35 <nut_> cabal run -q query
22:05:54 <nut_> this donesnt work
22:06:00 <koz_> jle`: What would that look like? I'm having trouble coming up with a type signature.
22:07:01 <jle`> liftKeys g f x = g f (keys x)
22:07:13 <jle`> ofoldl1Ex' f x = liftKeys ofoldl1Ex'
22:07:20 <jle`> um oops
22:07:21 <koz_> jle`: Yeah, I get that part. What would the type of liftKeys look like
22:07:23 <koz_> ?
22:07:25 <jle`> ofoldl1Ex' = liftKeys ofoldl1Ex'
22:07:33 <jle`> you can ask ghc :O
22:07:45 <koz_> Lol, OK.
22:08:00 <jle`> i wouldn't be able to answer because i don't know anything about keys or RuleSet
22:08:05 <jle`> but GHC can infer the type :)
22:08:16 <koz_> I'll give it a try then.
22:08:23 <jle`> my plan is usually to just do something dumb like liftKeys :: Int, and wait for the type error
22:08:56 <koz_> jle`: Woah, dat type.
22:09:22 <jle`> i'm sure there are nicer ways, heh
22:09:27 <koz_> liftKeys :: forall t t1 set . SetContainer set => (t1 -> [ContainerKey set] -> t) -> t1 -> set -> t
22:09:45 <koz_> ... I can haz no words.
22:09:48 <jle`> yeah heh, that's the most polymorphic type possible
22:10:09 <jle`> the forall's there are not required
22:10:17 <koz_> I'll see if it constrains it once I'm done replacing everything.
22:10:46 <jle`> well, you know x is (RuleSet a), so you aan plug that in for `set` there
22:11:06 <jle`> and you know what the ContainerKey of (RuleSet a) is, so you ca plug that into there too
22:11:21 <koz_> Will your liftKeys work for the definitions of ofoldl' and ofoldr as well
22:11:24 <koz_> ?*
22:11:24 <lambdabot> Maybe you meant: v @ ? .
22:11:50 <jle`> oh yeah, it won't work for those ;_;
22:11:57 <koz_> So I'd need a liftKeys2?
22:12:18 <koz_> Which is like liftKeys g f i x = g f i (keys x) or something>
22:12:21 <koz_> ?*
22:12:21 <lambdabot> Maybe you meant: v @ ? .
22:14:29 <koz_> I gotta say, I've never been *impressed* with a typecheker before.
22:14:32 <koz_> I am now.
22:15:54 <koz_> I wish I could tell the instance to be something like 'just use liftKeys for these functions here'.
22:19:32 <koz_> jle`: After some concretification, I get this: liftKeys :: (Ord b) => (a -> [Rule b] -> c) -> a -> RuleSet b -> c
22:25:02 <koz_> jle`: Would it be possible to do a similar thing here? http://paste.rel4tion.org/202
22:29:51 <koz_> jle`: I came up with: liftKeys2 f x y = mkRuleSet (filter f keys y) $ keys x
23:23:29 <MAXAM87> test
23:25:25 <farrioth> MAXAM87: test: no output
23:25:41 <MAXAM87> a
23:26:24 <farrioth> MAXAM87: a: command not found
23:27:11 <MAXAM87> exit
23:27:36 <ReinH> what
23:28:32 * hackagebot http2 1.4.1 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.4.1 (KazuYamamoto)
23:33:32 * hackagebot wai-logger 2.2.5 - A logging system for WAI  https://hackage.haskell.org/package/wai-logger-2.2.5 (KazuYamamoto)
23:42:52 <quchen> ReinH: Looks like a bot test.
23:43:05 <ReinH> yeah
23:43:46 <kadoban> IRC, where you can create a bullshit empty channel at will … tests bot in one of the biggest channels around.
23:43:47 <farrioth> Heh, I'm not actually a bot; I was just messing around.
23:43:56 <kadoban> Oh
23:44:00 <kadoban> Then … good job :)
23:44:14 <farrioth> Cheers.
23:44:14 * quchen applauds
23:44:26 <ReinH> farrioth: sounds like something a bot would say -.-
23:44:43 <farrioth> ReinH: I'm sorry Dave, I cannot do that.
23:45:10 <quchen> Suppose I'm writing a text editor. I don't want to load an entire file, because it might be very large. How would I load only "N lines around line X" into memory? Manually `hSeek`ing the handle comes to mind, but is there a smarter solution?
23:50:44 <ReinH> quchen: well, you can scan a file and create a semi-index of lines in very small constant space.
23:51:03 <ReinH> then use that to mmap
23:53:26 <quchen> ReinH: Good idea. (mmap?)
23:53:37 <ReinH> mmap??
23:53:46 <quchen> You said mmap.
23:53:53 <quchen> I don't know mmap.
23:53:56 <ReinH> yes, the system call
23:54:05 <ReinH> it maps files directly into memory
23:54:15 <ReinH> there are haskell wrappers even
23:54:34 <quchen> And what's a semi-index?
23:54:58 <ReinH> an index of line numbers to seek positions, in this case.
23:55:33 <ReinH> a very very simple example of http://www.di.unipi.it/~ottavian/files/semi_index_cikm.pdf
23:56:05 <shachaf> Constant space would be very small indeed.
23:56:25 <ReinH> well, the index won't take up constant space, but you only need to read a byte at a time technically
23:56:32 <quchen> shachaf: Where the constant grows linearly with the number of lines of the file.
23:56:40 <ReinH> and constant space can be large or small so I'm not sure what you mean
23:57:13 <shachaf> Asymptotically small.
23:57:35 <ReinH> I guess I should have been more clear: streaming the file will take constant space. The index itself will not.
23:58:34 <shachaf> I see. Creation of the index. OK.
23:59:10 <ReinH> although I think you can use a succinct data structure for the index to keep it surprisingly small as well
