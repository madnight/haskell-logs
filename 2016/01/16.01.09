00:00:06 <Clint> is there some way to keep ghc from getting confused by identically-named typeclasses in identically-named modules in different packages?
00:00:23 <jle`> Clint: -XPackageImports
00:00:37 <fserb> I'll read more about mtl and see if I can get this.
00:00:37 <Clint> jle`: i'm using that but it's seeing overlapping instances where there aren't any
00:00:51 <fserb> jle`, ReinH: thanks a lot :)
00:00:58 <jle`> Clint: hm,  taht's weird
00:01:05 <jle`> are you importing everything qualified?
00:01:17 <Clint> jle`: yup
00:01:26 <jle`> and you're sure tehy're not actually the same typeclass?
00:01:40 <jle`> from a package that both packages depend on?
00:02:12 <Clint> jle`: they are Crypto.Cipher.Types from crypto-cipher-types and Crypto.Cipher.Types from cryptonite and they are incompatible
00:02:30 <Clint> er, the class is BlockCipher
00:02:52 <jle`> and BlockCipher is separately defined in both modules?
00:02:59 <Clint> yes
00:03:04 <Clint> with different interfaces
00:03:28 <Clint> i haven't gotten around to BlockCipher from crypto-api yet but i'm assuming it won't have the same problem
00:03:32 <jle`> can you put up a minimal piece of code that brings up the error?
00:03:39 <jle`> are you writing any instances yourself?
00:04:25 <ReinH> Clint: why would you need both?
00:05:12 <ReinH> cryptonite includes its own Crypto.Cipher.Types module
00:05:27 <ReinH> The one from crypto-cipher-types appears to just be an extraction of tha tmodule
00:05:55 <ReinH> There's no reason to need crypto-cypher-types if you are already using cryptonite
00:07:18 <orb> Is there a package for linear algebra (especially on dense matrices) that tracks dimensions in the type?
00:07:34 <ReinH> orb: what size?
00:07:42 * hackagebot Slides 0.1.0.7 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.7 (darwin226)
00:07:42 * hackagebot telegram-api 0.2.0.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.2.0.0 (klappvisor)
00:07:48 <orb> I want to use it for neural networks.
00:08:04 <ReinH> Ok. What size matrices?
00:08:05 <jle`> orb: there's hmatrix
00:08:11 <jle`> i'm using it for my own nn's
00:08:11 <orb> So, perhaps a few hundred (or at most a few thousand) in one dimension.
00:08:24 <orb> Perhaps a 1000 x 100 matrix.
00:08:39 <jle`> `L 1000 100` is a 1000 x 100 matrix of doubles in hmatrix :)
00:08:47 <orb> I had a look at hmatrix, but hmatrix blows up at runtime when dimensions don't match.
00:08:56 <jle`> use Numeric.LinearAlgebra.Static
00:09:00 <orb> jle`: which one is yours?
00:09:07 <jle`> oh i'm just playing around right now
00:09:12 <Clint> jle`: http://lpaste.net/148703 doesn't give quite the same error but it claims duplicate instance declarations
00:09:27 <jle`> but the matrix types in Numeric.LinearAlgebra.Static will not compile if you have dimension mismatch
00:09:27 <ReinH> Clint: did you see what I said?
00:09:28 <orb> I plan to write AI for German style boardgames.
00:09:30 <Clint> ReinH: crypto-cipher-types is "obsoleted" by cryptonite but nettle uses crypto-cipher-types and not cryptonite
00:09:45 <orb> Using the ideas from TD gammon and Keldon's RftG AI.
00:09:45 <ReinH> Clint: Well. Crap.
00:09:53 <Clint> so i am trying to use an abstraction
00:09:53 <ReinH> Tell them to stop doing that then.
00:10:02 <jle`> Clint: oh heh
00:10:04 <Clint> ReinH: https://github.com/stbuehler/haskell-nettle/issues/6
00:10:08 <jle`> the duplicate typeclasses isn't your problem there
00:10:16 <ReinH> Clint: fair enough
00:10:24 <orb> jle`: Oh, thanks, I'll have a look at the Static module in hmatrix.
00:10:28 <ReinH> Clint: It's hard to keep track of Vincent's crypto packages
00:10:29 <jle`> your problem is that your instances are not really ... how typeclasses work in haskell
00:10:37 <jle`> instance Foo a => Bar a
00:10:40 <jle`> instance Baz a => Bar a
00:10:42 <ReinH> Even when it was literally job to build them.
00:10:43 <jle`> will break
00:10:49 <jle`> instance resolution matches on the instance head
00:11:10 <Clint> jle`: great, is there a way for me to do what i'm trying to do?
00:11:17 <jle`> it's irrelevant of Foo and Baz have the same name, heh
00:11:27 <jle`> well, one quick solution would be to use newtype wrappers
00:11:34 <Clint> oh god
00:11:42 <jle`> one for CCT's BlockCipher and one for OldCCT's BlockCipher
00:11:53 <jle`> or, use a wrapper for one and leave the other one unwrapped
00:11:58 <orb> Clint: newtype wrappers ain't scary.
00:12:00 <ReinH> s/job/my job
00:12:06 <Clint> orb: there are a lot of types involved
00:12:11 <jle`> then you can do instance CCT.BlockCipher cipher => MyBlockCipher cipher where ... 
00:12:14 <jle`> and that'll be okay
00:12:28 <jle`> and then newtype WrappedOldCCT a = WOCCT a
00:12:46 <jle`> insatnce (OldCCT.BlockCipher cipher) => MyBlockCipher (WrappedOldCCT cipher) where ...
00:12:56 <orb> jle`: Otherwise, one can probably muck around with phantom-types to choose which instance to pick?
00:13:04 <Clint> jle`: ok, i can try that, thanks
00:13:15 <jle`> that should go fine as long as you don't do something silly like write a CCT.BlockCipher instance for WrappedOldCCT
00:13:56 <jle`> Clint: the problem is that when picking which instance to use, GHC looks at instance ... MyCipher cipher where ..., and goes, "okay, this is the instance to go down, because it matches any type"
00:14:15 <jle`> it commits to taht branch, and then goes to check the constraints afterwards
00:14:19 <Clint> i see
00:14:30 <jle`> so you can see why having two `MyCipher a` instances would confuse GHC
00:14:52 <Clint> yeah, i assumed it would apply the constraint first
00:15:19 <jle`> typeclasses are weird! :O
00:15:45 <hunteriam> Maybe a -> MaybeT m a?
00:16:20 <jle`> `MaybeT . return` or `maybe mzero return`
00:17:02 <jle`> orb: if you know a way, let me know...sounds interesting :o
00:17:14 <jle`> i'm still noodling over a nice solution
00:18:43 <jle`> Clint: actually wait my solution was bad, you have to wrap both types
00:19:01 <jle`> writing an instance for the unwrapped version would also cause great pain
00:19:01 <ggVGc> What's my best choice for generating MIDI from haskell?
00:19:13 <Clint> jle`: why?
00:19:30 <jle`> because (WrappedOldCCT cipher) would still get matched under `cipher`
00:19:39 <jle`> because `cipher` matches anything
00:20:13 <Clint> right but there would be no matching instances then
00:20:25 <jle`> well, it would match, and then it would complain about a constraint not being satisfied
00:20:37 <jle`> it won't "fall through" to another potential instance
00:20:46 <Clint> ok
00:20:58 <jle`> i think it might in some cases but you'd be playing a dangerous game
00:21:49 <jle`> yeah, it might in some cases but it's sort of black magic to when it would break or not break to me
00:24:40 <orb> jle`: Something like http://lpaste.net/364250081815166976 might do the trick?
00:25:10 <orb> ggVGc: have you looked at https://wiki.haskell.org/MIDI, yet?
00:25:34 <jle`> oh that's interesting
00:25:40 <orb> Clint: perhaps closed type families might work.  But that seems like overkill, compared to using a newtype wrapper.
00:25:55 <jle`> might as well data Via = ViaShow | ViaDefault and lift with data kinds
00:25:56 <ggVGc> orb: yeah, I'm leaning towards using portmidi directly, but I asked in here in case someone had more specific experience
00:26:02 <jle`> but, type inference would be out the window
00:26:19 <orb> jle`: Yeah.  Perhaps one could use a functional dependency?
00:26:23 <ggVGc> I'm also looking at which FRP implementation is the most mature in haskell
00:26:30 <ggVGc> as I'd like to use FRP for this midi sequencer
00:26:45 <Clint> orb: i'll try it with the newtypes first
00:26:55 <orb> Oh, overlapping instances seems like the thing to use?
00:28:12 <jle`> i guess there area bunch of "solutions" here -- https://wiki.haskell.org/GHC/AdvancedOverlap
00:28:32 <jle`> ggVGc: FRP for midi, that's interesting :O
00:29:05 <jle`> school of music's frp / netwire would be nice for wav generation
00:29:14 <jle`> FRP for midi would be interesting
00:29:43 <orb> jle`: anything about overlapping instances that doesn't distinguish between `overlaps' and `overlappable' is out of date with newer ghc.
00:29:56 <jle`> true
00:30:04 <jle`> typeclasses are weird anyways :|
00:31:06 <orb> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#instance-overlap
00:31:21 <ggVGc> jle`: why? you don't think it makes sense? It's all signals
00:31:30 <ggVGc> I've written many midi things before, and FRP seems like a perfect fit
00:31:34 <jle`> ggVGc: it makes sense
00:31:40 <jle`> that's why i'm wondering why i haven't thought of it before
00:31:43 <jle`> heh
00:31:43 <ggVGc> jle`: also, this, https://vimeo.com/96744621
00:32:04 <jle`> oh hey, there's that haskell library for live performing/live synthesizing
00:32:11 <ggVGc> jle`: I've only done FRP in Elm so far though. What FRP implementation do you reckon I should look at first in haskell?
00:32:15 <ggVGc> there are quite a few
00:32:29 <jle`> Haskell School of Music uses that built in FRP library that generates wav's, i thought
00:32:38 <jle`> but maybe there's been some updates since I last looked into it
00:32:43 <ggVGc> maybe I'd like one that's similar to Elm's, but I don't think any is atm. Arrowized FRP seems good, but also not what I'm familiar with
00:33:03 <jle`> the closest to Elm you might find is a push-pull like react or sodium/reactive-banana
00:33:27 <jle`> i mean, not react, reflex
00:33:44 <ggVGc> yeah, ractive-banana looks good
00:33:47 <ggVGc> I was going to try that out
00:33:49 <ggVGc> cheers
00:36:10 <hunteriam> is there a way to `sign in` a user without needing to rehash and check their password on every request?
00:36:40 <Xe> cookies?
00:36:54 <hunteriam> its not very secure to store their password in a cookie is it?
00:37:00 <Xe> not their password
00:37:02 <Xe> a session token
00:37:09 <hunteriam> so i need to track their session
00:37:10 <hunteriam> ?
00:37:23 <Xe> might be better to
00:42:38 <hunteriam> could my session token be the combination of a user id and a random bytestring? does it need to expire?
00:44:44 <ggVGc> haskell must have some kind of session management library?
00:51:30 <zomg> ggVGc: Session management?
00:52:37 <ggVGc> zomg: for hunteriam, he's talking about handling user sessions for a web application. Surely haskell has this solved already
00:52:53 <hunteriam> theres wai-sessions
00:53:06 <hunteriam> just writing my own thoughj
00:55:37 <zomg> ahh
00:55:47 <zomg> yeah wai-sessions and probably some specific to libs like Snap or Yesod
00:56:18 <zomg> hunteriam: but yes you can make the session ID token be anything you want
00:56:48 <zomg> but it would be good to be some secure and hard to guess thing
00:57:11 <zomg> with hashing, the main attack vector against session hashes is timing attacks, but they are fairly hard to do from what I understand
00:57:16 <hunteriam> im using System.Random
00:57:19 <hunteriam> System.Entropy
00:57:20 <hunteriam> *
00:57:22 <hunteriam> for my tokens
00:58:14 <zomg> iirc yesod actually stores the whole session into cookies and it encrypts the cookie :)
00:58:20 <zomg> (or at least it used to)
01:21:19 <hunteriam> is it a bad idea to take all the various same-named functions from ByteString, Text, and String and making them typeclass functions?
01:21:54 <quchen> hunteriam: What laws would those follow?
01:22:07 <quchen> hunteriam: Most people consider classes without laws antipatterns.
01:22:46 <hunteriam> I mean.. hmm..
01:23:06 <hunteriam> the namespace errors though...
01:23:36 <hunteriam> I mean shouldn't there theoretically be laws since they more or less do the same thing?
01:24:08 <quchen> You'll have to be more concrete, "more or less" is hardly a law.
01:24:51 <quchen> Another problem is that although many functions are similar, many are not.
01:25:14 <quchen> Chunking makes no sense for String and strict BS/Text, for example. Should that be part of the class?
01:26:51 <hunteriam> Perhaps more than one class is appropriate
01:33:48 <tsani> How are defines from C header files used with the FFI?
01:34:42 <tsani> More precisely, how can I use a define from a header file in a Haskell module?
01:34:59 <KaneTW> you need to use some sort of tool for that
01:35:03 <KaneTW> c2hs etc
01:35:47 <KaneTW> hsc2hs should work too
01:36:54 <KaneTW> i think you can do #const <define> in hsch2s
01:36:58 <KaneTW> hsc2hs/
01:37:11 <KaneTW> and there's the #cinline macro with bindings-dsl
01:37:15 <tsani> Ah, okay, so it boils down to just looking up the values of the defines and splicing them into the code? (This is for a one-off thing, so I'll just look up the values myself :p )
01:37:29 <KaneTW> you can use the actual define name
01:37:45 <KaneTW> unless you just write the .hs file directly
01:37:49 <KaneTW> then you need to look it up
01:37:58 <KaneTW> consider using something like c2hsc for binding generation
01:38:25 <tsani> Got it. Thanks !
01:42:48 * hackagebot ibus-hs 0.0.0.1 - A simple uncomplete ibus api  https://hackage.haskell.org/package/ibus-hs-0.0.0.1 (ongyerth)
01:55:57 <hunteriam> quchen: intersperse for example
01:57:59 <ali_bush> hey guys.  Im attempting to make an http request and I believe the body im posting is being sent multiple times in the request.
01:58:29 <ali_bush> http://pastebin.com/235Wt2SQ is the code which makes the request.
01:58:31 <quchen> hunteriam: ?
01:58:43 <hunteriam> quchen: a function that should be part of a type class
01:59:16 <quchen> hunteriam: (Devil's advocate coming in) Why?
01:59:25 <ali_bush> encode is from aeson,  http = Network.Http.Client / http-streams
01:59:40 <hunteriam> it does the same thing for different types
01:59:54 <MarcelineVQ> I don't think ByteString, Text, and String are as similair as you're imagining them
02:00:40 <hunteriam> isnt the point to abstract that
02:00:51 <ali_bush> is there anything obvious im doing.  I know that encode returns a lazy bytestring which is why I use toStrict
02:04:32 <Cale> ali_bush: What's the type of makeInputStream?
02:05:06 <Cale> oh, I see, this is from io-streams?
02:05:24 <ali_bush> Cale: yeah
02:06:18 <Cale> Okay, so what makeInputStream appears to do is to make an InputStream which each time you request a value from it, it will execute the IO action given
02:06:43 <Cale> So this 'body' is actually an infinite stream of copies of  toStrict <$> Just(encode req)
02:08:38 <Cale> I see some ways to do something a bit more like what I think you intend, but I don't really know this library, and I think there's probably something a bit more succinct
02:09:04 <Cale> oh, there's System.IO.Streams.List
02:09:15 <Cale> which has fromList :: [c] -> IO (InputStream c)
02:09:37 <ali_bush> also found a fromLazyByteString
02:09:47 <ali_bush> in System.IO.Streams.ByteString
02:10:02 <Cale> yeah, that would be suitable
02:10:31 <Cale> Probably better than converting to a strict ByteString usually
02:11:28 <ali_bush> yeah.  I just really want this bit to work....  then I have actually written something in haskell  ( if you know what i mean )
02:11:55 <Cale> so yeah, try those things
02:19:26 <ali_bush> Cale: thanks.  fromLazyByteString worked.    I actually have a haskell program which does something useful :D
02:23:16 <python476> so very yegger
02:40:56 <spuz> if I define a type like this: data Foo = Foo String Int. How can I destructure a value of that type so that I can access the String and the Int values?
02:42:29 <KaneTW> spuz: pattern match on it
02:42:30 <jle`> spuz: you can use pattern matching
02:42:37 <KaneTW> @where learnhaskell
02:42:38 <lambdabot> https://github.com/bitemyapp/learnhaskell
02:42:40 <spuz> KaneTW, what is the syntax in this case?
02:42:52 <jle`> foo (Foo str int) = ... the string and int are in scope here ...
02:42:57 <KaneTW> you can either do f (Foo s i) = ... do stuff
02:43:09 <jle`> or let Foo str int = myFoo in ...
02:43:16 <KaneTW> or case x of Foo s i -> ...
02:43:23 <KaneTW> where x :: Foo
02:43:58 <jle`> if you're in a do block, Foo str int <- ... works too, etc. -- basically, anywhere that syntactically expects a pattern
02:44:20 <spuz> what about in the parameter list of a function definition?
02:44:33 <jle`> the first one i gave was that
02:44:37 <spuz> jle`, ok thanks
02:44:42 <jle`> myFunc (Foo str int) blah blah = ...
02:45:11 <jle`> np
02:51:03 <cbaatz> Does anyone know what's going on in: http://lpaste.net/148714 The quantified variant of the type synonym works, but the fixed one doesn't (without LiberalTypeSynonyms). It seems to me that RankNTypes activates LiberalTypeSynonyms for some type synonyms but not all. What am I missing?
03:02:53 <spuz> wow, i can't believe my solution works
03:09:12 <hunteriam> hoistMaybe = MaybeT . return
03:09:12 <hunteriam> what file should contain this function in my src?
03:28:14 <hunteriam> a -> Bool -> Maybe a?
03:37:25 <jle`> `x <$ guard b`, or `guard b $> x`.  some people also like [ x | b ], but that always felt kinda silly to me
03:37:52 * hackagebot edit-distance-vector 1.0.0.3 - Calculate edit distances and edit scripts between vectors.  https://hackage.haskell.org/package/edit-distance-vector-1.0.0.3 (ThomasSutton)
04:00:16 <hunteriam> Either a b -> Maybe b
04:00:17 <hunteriam> ?
04:01:19 <hunteriam> fmap Just
04:02:55 <hunteriam> nvm
04:06:01 <quchen> :t either (const Nothing) Just
04:06:02 <lambdabot> Either b a -> Maybe a
04:07:53 * hackagebot between 0.11.0.0 - Function combinator "between" and derived combinators  https://hackage.haskell.org/package/between-0.11.0.0 (PeterTrsko)
04:23:29 <Darwin226> Hey guys, is there some Debug.Trace equivalent for benchmarking?
04:24:17 <Darwin226> By that I mean unsafe functions I can hook into my code that help me measure how long something takes (with the usual caveats of Debug.Trace that everything depends on evaluation)
04:29:49 <quchen> Darwin226: I don't think there's a hack based on Debug.Trace around.
04:30:01 <quchen> Darwin226: Criterion is not an option?
04:30:16 <Darwin226> quchen: I don't mean being based on Debug.Trace. More like in the same vein
04:31:44 <Darwin226> quchen: I have a relatively complicated project and all I want to is to measure time between, say, two traceShows
04:32:35 <Darwin226> quchen: Profiling is fine but sometimes I don't really care about specific functions. 
04:32:53 <quchen> Darwin226: You can use a top-level IORef and feed that with timing values
04:32:59 <quchen> But that's way out in unsafe territory
04:33:04 <jle`> criterion is not a profiler :o
04:33:21 <jle`> it's for benchmarking
04:33:34 <quchen> The question is about benchmarking
04:33:35 <Darwin226> quchen: Yeah, I was thinking along the lines of that but hoping someone already did it
04:35:35 <Darwin226> quchen: Criterion is fine if I wanted to "do it right", but doing it that way sometimes is more of a hassle than it's worth. I'm guessing at least someone agrees with me, otherwise Debug.Trace wouldn't exist.
04:36:14 <quchen> I've got a tiny lib around that does my debugging hacking, but it's not released :-|
04:36:23 <quchen> I think you'll have to write it yourself
04:40:46 <Darwin226> quchen: Ok, thanks. I might do that then
04:42:54 * hackagebot dawg-ord 0.4 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.4 (JakubWaszczuk)
04:52:54 * hackagebot dawg-ord 0.4.0.1 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.4.0.1 (JakubWaszczuk)
04:57:42 <Wizek> Hello, has anyone seen this error while running `ghcjs-boot` and/or knows what it means? https://gist.github.com/Wizek/e4a73c6e9542a119ddd6 
04:59:32 <Wizek> "ghcjs-boot: ./.cabal-sandbox/bin/ghcjs-pkg: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)"
05:02:27 <bramantio> hello all
05:02:54 * hackagebot feed 0.3.11.1 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-0.3.11.1 (AdamBergmark)
05:04:57 <bramantio> drot: hi
05:05:22 <bramantio> spuz: hello
05:05:50 <bramantio> pantsman_: hello
05:07:44 <spuz> bramantio, hi
05:08:44 <pantsman_> hi
05:12:55 * hackagebot dawg-ord 0.4.0.2 - Directed acyclic word graphs  https://hackage.haskell.org/package/dawg-ord-0.4.0.2 (JakubWaszczuk)
05:15:24 <bollu> hey everyone :)
05:30:03 <bollu> so, the definition of the product of two objects a and b feels like cheating
05:30:32 <bollu> it's like someone picked out the idea of the isomorphism theorem (any of them - group, ring, ..) and then slapped it onto category theory
05:30:42 <bollu> as in, I don't see why factoring through the product is so important
05:30:52 <bollu> why can't there be some other universal property?
05:58:32 <argoneus> @src take
05:58:32 <lambdabot> take n _      | n <= 0 = []
05:58:32 <lambdabot> take _ []              = []
05:58:32 <lambdabot> take n (x:xs)          = x : take (n-1) xs
05:58:53 <argoneus> @src zip
05:58:53 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
05:58:53 <lambdabot> zip _      _      = []
05:59:05 <argoneus> hmm
05:59:14 <bollu> argoneus: how's Haskell coming along?
05:59:27 <argoneus> bollu: reading a book still
05:59:34 <bollu> argoneus: ah, cool :)
05:59:47 <argoneus> I can probably write simple things now
05:59:53 <argoneus> still no idea how parsers work though
06:00:00 <argoneus> er, I have an idea how they work, but not how I'd implement my own
06:00:09 <bollu> argoneus: parsers as in "in general" parsing or Haskell style parser-combinators?
06:00:20 <argoneus> haskell style parser-combinators
06:00:35 <argoneus> it's ok I'll figure it ut
06:00:36 <argoneus> out*
06:01:00 <josgraha> can anyone point me to the source code or an article that explains how the :t (type) command works in GHCI?  I wanted to understand how to create a string from a type in haskell
06:02:47 <hpc_> the :t command is magic
06:03:03 <hpc_> it exists outside the language, so there's no way it will help you do what you want
06:03:20 <josgraha> *agreed* there be dragons in that :t command 
06:03:37 <hpc> you can technically pull this off with Typeable, but if you give us more context we can probably help you figure out what you actually want
06:04:00 <edwardk> byorgey: My machine apparently thinks it is _very_ important that I remember that it is your birthday tomorrow. http://i.imgur.com/9iYTfK5.png?1 Happy birthday -1.
06:04:02 <josgraha> here's an example
06:04:02 <hpc> because this is a pretty odd operation to need
06:04:10 <josgraha> let x = "foo"
06:04:22 <bollu> edwardk: are you sticking around for a bit?
06:04:42 <edwardk> bollu: depends on your sense of timescale =)
06:04:52 <bollu> edwardk: um, ~15 minutes?
06:04:58 <josgraha> typeToString x -> x :: [Char}
06:05:04 <edwardk> i'll probably be gone by then
06:05:07 <bollu> ahh
06:05:13 <bollu> edwardk: when will you be back?
06:05:20 <bollu> I had a soft question on Cat. theory
06:05:35 <argoneus> @src product
06:05:35 <lambdabot> product = foldl (*) 1
06:05:41 <argoneus> the fuck
06:05:46 <argoneus> :t foldl
06:05:47 <bollu> as in, why are most things that I've seen so far (limits, co-limits, even function application) always defined through "factoring" through some structure
06:05:47 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
06:05:50 <edwardk> i tend to flit in and out
06:06:02 <hpc> josgraha: what are you going to use the type string for?
06:06:02 <josgraha> so i'm hoping to understand how to 1. inspect the type of something and then 2. how that inspection works
06:06:17 <argoneus> :t foldr
06:06:18 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:06:19 <josgraha> understanding how type information is derived
06:07:01 <josgraha> not to be used in production, strictly a learning activity
06:07:06 <hpc> oh, so this is to learn some ghc internals
06:07:32 <josgraha> correct, trying to go down the rabbit hole
06:07:51 <hpc> you won't find anything interesting that way i think, since you're staying above the "ghc internals" level the whole time
06:07:56 <hpc> you might ask in #ghc
06:08:18 <josgraha> ah very interesting
06:08:24 <josgraha> thank you so much
06:08:24 <bollu> do the Free Monad and the Cofree Comonad interact in any way?
06:08:31 <hpc> and also read the trac commentary - https://ghc.haskell.org/trac/ghc/wiki/Commentary
06:08:45 <bollu> in the sense of, is there some cool function that uses both, or translates between both or something
06:08:59 <hpc> josgraha: there's a lot on that commentary page and some of it might be relevant
06:09:01 <josgraha> oh perfect, thanks as you can tell i'm a neophyte
06:09:14 <hpc> it's been a while since i read it so i don't remember everything that's there
06:09:20 <hpc> they're all fun reads regardless
06:09:21 <bollu> argoneus: do you want ah explanation on Foldable? :)
06:09:31 <argoneus> bollu: nono it's fine thanks
06:09:45 <josgraha> for sure :)  thanks again
06:10:01 <hpc> josgraha: and just to completely answer your question from before, typeToString :: Typeable x => x -> String
06:10:06 <hpc> typeToString = show . typeRep
06:11:01 <nshepperd_> typeToString doesn't work on anything polymorphic though
06:11:04 <hpc> it won't work for arbitrary types (in ghc) because types get erased during compilation
06:11:09 <hpc> yeah, and that
06:11:54 <hpc> it may or may not be a coincidence that haskell's type system is simultaneously hard to inspect at runtime, and hard to circumvent at runtime
06:12:12 <nshepperd_> josgraha: you might be interested in an online book called 'write you a haskell'. it's still in progress, but it's a sort of tutorial on writing a haskell compiler from the ground up, including hindley-milner type inference
06:13:56 <josgraha> nsheppard_: wow thanks
06:13:57 <bollu> nshepperd: question: haskell doesn't use HM right?
06:14:16 <bollu> nshepperd: I tried coming up with typing rules for a language I was writing (I needed more power than HM)
06:14:31 <bollu> and no one could point me to a place where *what* type system Haskell uses is laid out
06:14:42 <bollu> nshepperd: It would be awesome if you covered extensions to HM as well :)
06:15:40 * frerich wonders why his laptop tells him that tomorrow is byorgey's birthday
06:15:54 <josgraha> bollu: i think u are missing the underscore :) nshepperd_:
06:16:26 <bollu> josgraha: oh, I was autocompleting >_< Looks like both users are around
06:17:23 <d-snp_> is there a way to dump some values to a file, and read it in later without worrying about deriving types etc?
06:17:41 <nshepperd_> bollu: I think haskell uses some version of system F?
06:18:01 <nshepperd_> (nshepperd is my phone or something)
06:18:20 <bollu> nshepperd_: really? but without RankNTypes haskell is decidable right?
06:18:26 <d-snp_> I just want to cache some calculated data, it contains values from external libraries as well, I just want whatever is in memory to be written to a file, and then later read that back in
06:19:06 <d-snp_> if the memory layout changed (because of other libraries being loaded or something) it may error or return Nothing or whatever
06:20:41 <nshepperd_> bollu: I believe so, but I don't really know the details...
06:20:59 <bollu> nshepperd_: hm, thanks :)
06:21:18 <d-snp_> i.e. dump :: a -> IO (ByteString); load :: ByteString -> Maybe a
06:21:54 <d-snp_> perhaps IO isn't even really necessary
06:21:57 <bollu> does anyone have a nice blog or something on coalgebras?
06:22:00 <bollu> (cofree coalgebras)
06:22:03 <bollu> ReinH: ping ^
06:24:01 <nshepperd_> d-snp_: the two main binary serialization libraries are 'binary' and 'cereal'
06:24:57 <nshepperd_> but they require a typeclass instance, it's not just writing out memory pages to disk
06:25:14 <d-snp_> yeah I found those
06:25:47 <d-snp_> perhaps it's just not possible on account of memory layout information not being available at runtime
06:26:22 <bollu> d-snp_: shot in the dark, but what about protobuf?
06:26:41 <d-snp_> good suggestion
06:26:50 <edwardk> bollu: there are plenty of interactions between them
06:27:01 <bollu> edwardk: is it written down somewhere?
06:27:09 <bollu> edwardk: and how do they interact? (through what structure)
06:27:15 <d-snp_> I think protobuf needs a description
06:27:22 <exio4> nshepperd_: require a typeclass instance? not really .. :p
06:27:24 <edwardk> bollu: e.g. https://github.com/ekmett/adjunctions/blob/master/src/Data/Functor/Adjunction.hs#L191
06:27:51 <nshepperd_> oh there's the generics stuff isn't there
06:28:01 <exio4> nshepperd_: you can use runPut manually, and it's quite useful, because you get a general-purpose (de)serialization 
06:28:07 <edwardk> there are lots of things where you can let a free monad 'cancel' with a cofree comonad.
06:28:14 <bollu> edwardk: hm, I see. I don't know what an adjunction is, but I will read up on it
06:28:42 <nshepperd_> oh yeah that too
06:29:23 <edwardk> e.g if you have one functor that has a sum wherever the other has a product, and a product where the other has a sum, etc. you can get a way to 'zap' two functors.
06:29:24 <edwardk> http://blog.sigfpe.com/2014/05/cofree-meets-free.html
06:29:35 <nshepperd_> I suppose I really meant that it's more strongly typed than just serializing anything
06:29:41 <edwardk> http://comonad.com/reader/2008/zapping-strong-adjunctions/
06:30:11 <bollu> edwardk: FYI, I don't know much category theoory :) I'm reading it (slowly) from the n-category cafe blog posts
06:30:11 <edwardk> there are some articles on 'pairing functors' (but you have to be careful as the 'pair' of a functor may not be unique in all categories)
06:30:33 <edwardk> sok, i don't know much category theory either.
06:30:46 <exio4> nshepperd_: yeah, they force you to take care of what you are actually serializing 
06:30:56 <bollu> edwardk: ;)
06:30:57 <nshepperd_> do the functors annihilate in a release of gamma rays? :)
06:31:22 <exio4> edwardk says that so we mere mortals can feel better
06:31:42 <jerv> is it possible to import a module unqualified, but demand that one particular function should be used qualified?
06:32:16 <exio4> jerv: import ABC hiding (function) 
06:32:22 <edwardk> exio4: compared to the folks who do real category theory though it is quite true
06:32:57 * hackagebot pipes-transduce 0.2.0.0 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.2.0.0 (DanielDiazCarrete)
06:33:14 <exio4> edwardk: the practical side of category theory? 
06:33:35 <edwardk> it has a practical side?
06:33:47 <exio4> edwardk: fsvo practical :p 
06:34:02 <jerv> exio4: that hides function, I want function in scope, but qualified
06:34:17 <exio4> jerv: import qualified ABC after that 
06:34:49 <edwardk> jerv: use two import statements. done
06:35:21 <jerv> great!
06:35:22 <edwardk> import Data.Map (Map); import qualified Data.Map as Map -- gets you Map and Map.fromList, etc.
06:35:47 <edwardk> import Data.Foo hiding (unsafeWhatever); import qualified Data.Foo
06:37:52 <bollu> so I'm reading this: http://stackoverflow.com/questions/16015020/what-does-coalgebra-mean-in-the-context-of-programming
06:37:57 * hackagebot debug-time 0.1.0.0 - Debug.Trace equivalent for timing computations  https://hackage.haskell.org/package/debug-time-0.1.0.0 (darwin226)
06:38:11 <bollu> and I don't get this: "So we can generalize our idea of an algebra even more. It's just some type τ with a function f τ → τ for some functor f."
06:38:27 <bollu> as in, like, before, we had a *bunch* of functions that we were fmapping on
06:38:45 <bollu> and now we reduced it to 1?
06:38:45 <bollu> how?
06:41:31 <orion_> In an EDSL if I want to restrict certain operations from being made before others are made first, are indexed free monads the only option I have?
06:42:57 * hackagebot debug-time 0.1.0.1 - Debug.Trace equivalent for timing computations  https://hackage.haskell.org/package/debug-time-0.1.0.1 (darwin226)
06:48:42 <saulzar> orion_, Well you can use your own functions to enforce some structures - e.g. withFoo :: (\Foo -> m a) -> m a  kind of thing, it's not really the same, though..
06:50:28 <davs> Hi! Does anyone know if the haskellbook.com book is still being developed? I'm about to buy the book, but since it costs a lot, I'd like a last confirmation that it is worth it :)
06:51:42 <bollu> where did the idea for an F-algebra come from?  I'm reading this:http://stackoverflow.com/questions/16015020/what-does-coalgebra-mean-in-the-context-of-programming
06:51:46 <bollu> how accurate is it?
06:51:56 <bollu> and how does an F-algebra generalize over "all algebras"?
06:54:20 <orion_> saulzar: Are IFMs even a solution at all
06:57:13 <saulzar> orion_, indexed monads in general seem kind of awkward to use to me
06:59:14 <saulzar> orion_, I've not come across IFMs as such, just reading about them now :) 
07:01:17 <mikail> hi, haskell noobie here. Please can you tell me which is the best library to use to parse csv files FAST.
07:03:51 <mikail> Is Attoparsec preferred over parsec nowadays?
07:03:59 <knupfer> mikail: yes
07:04:20 <knupfer> mikail: cassava
07:04:33 <knupfer> it's build on atto-parsec
07:04:52 <knupfer> and the fastest you can beg for
07:04:52 <mikail> I don't know either so before jumping into learning one I thought I'd ask to save myself time and effort
07:05:02 <mikail> great +1
07:05:48 <mikail> i'll check it out
07:06:34 <quchen> No, Attoparsec is not referred over Parsec. They serve different use cases.
07:06:39 <quchen> +p
07:06:53 <quchen> Attoparsec is fast, but has poor error reporting.
07:07:06 <knupfer> quchen: yes, but he explicitly wants a fast solution
07:07:46 <quchen> A parser generated by Happy might be even faster in that case
07:08:34 <knupfer> well, and he specifies that he is a beginner...
07:09:29 <quchen> Is there a parser lib (anywhere) that combines a fast-but-unfriendly parser with a slower one that reports errors better? If the fast parser fails, re-run with the slow parser to get a nice error message
07:10:04 <quchen> … based on the same grammar, so with no overhead for the programmer
07:11:13 <knupfer> you can write a write a preprocessor to convert attoparsec to parsec and use it while developing
07:11:37 <quchen> Hmm not sure whether that's so easy, since Attoparsec is always backtracking
07:12:31 <knupfer> I haven't got experience with parsec, but I guess that you can use constructs for enabling backtracking
07:13:05 <quchen> Yes, but Parsec becomes pretty slow when you sprinkle 'try' everywhere. Although, if it's only for error generation, that might be worth a shot even.
07:14:27 <knupfer> quchen: I suppose yes, there are also a lot of people which use -O0 while deving
07:19:19 <knupfer> Is it possible to issue warnings for unused functions?  Lets say I've got module A which exports f and g and Main which uses only f, now I want a warning about the unused function g...
07:19:38 <knupfer> Note that this is different from the unused imports warning from ghc.
07:21:03 <quchen> knupfer: What happens when you explicitly import f,g in main?
07:22:00 <knupfer> quchen: In this case I'll get the warning, but let's say you use the module A in some modules and you want to be sure that every function is used somewhere.
07:22:22 <quchen> I don't think there's a flag for that.
07:23:11 <knupfer> quchen: Do you know of a preprocessor/TH-library which checks for that?  Seems like a good idea for executables.
07:23:31 <tomjaguarpaw> wedens: "opaleye question: can I have different read and write types? (not just column types)"  Yes, they can be different.  What are you trying to do, though?
07:24:11 <quchen> knupfer: Unfortunately no. It would probably be easy to check for unused definitions project-wide based on the GHC AST.
07:24:24 <quchen> Where "easy" doesn't necessarily mean quick :-)
07:25:19 <knupfer> Hm, my usecase is the staticFiles in Yesod, I'd love to get warnings when I've got unused images...
07:26:06 <wedens> tomjaguarpaw: it was related to this question https://github.com/tomjaguarpaw/haskell-opaleye/issues/135
07:26:27 <quchen> I approve of the use case, but I don't have a solution. :-|
07:27:28 <knupfer> A extremely slow, but programmatically easy solution would be to rename a image and try to recompile, for every image... (would take some days in my case)
07:29:04 <tomjaguarpaw> wedens: Ah OK.  Did you reach a satisfactory conclusion?
07:29:30 <wedens> tomjaguarpaw: yes
07:30:00 <tomjaguarpaw> wedens: Great.  Feel free to keep asking any questions on the issue tracker.
07:42:31 <Habib> can anyone actually see my messages?
07:42:57 <quchen> Habib: Yes.
07:44:03 <Habib> Well, thank god for that, just making sure. I was in a different chatroom and no one wanted to know about this cool tmux trick I found (in the tmux room).
07:44:55 <bollu> hey people
07:45:01 <bollu> so my question about category theory
07:45:03 <bollu> was still around
07:45:31 <knupfer> bollu: ?
07:47:20 <bollu> okay
07:47:25 <bollu> so, why is it that everything in cat. theory
07:47:36 <bollu> is defined as a actoring?
07:47:42 <bollu> eg. limits, co-limits, etc
07:47:50 <bollu> product
07:47:51 <bollu> sums
07:48:52 <bollu> they're all defined through a factoring 
07:49:04 <bollu> of some "canonical" object
07:49:59 <bollu> for example, a product c of object a and b, is such that any other object d with two arrows from d -> a and d -> b will give you a factoring through d -> c
07:52:11 <codedmart> ReinH are you around by chance?
08:01:29 <lynnard> anyone familiar with Linear package? is there an operation that checks whether a point is inside a square?
08:01:56 <lynnard> e.g., op (V2 x y) (V2 width height) = x <= width && y <= height
08:31:16 <Nadrieril> bollu: my understanding is that you can only define behaviors by the relations they have with the rest of the world
08:31:52 <Nadrieril> that's the strenght of category theory, because it allows you to define anything that behaves like a product without having the first notion of what your objects/arrows are
08:32:48 <mac10688> ReinH, thanks for the templating help.
08:33:00 * hackagebot bson-generic 0.0.8.1 - Generic functionality for BSON  https://hackage.haskell.org/package/bson-generic-0.0.8.1 (PetrPilar)
08:33:07 <bollu> ReinH: I need some help with cateogry theory if you're around
08:33:15 <Nadrieril> actually, how would you construct an object in a category without any information of what those objects are ?
08:33:25 <Nadrieril> feels like parametricity what i'm saying
08:34:32 <bollu> ReinH: so, I was wondering why everything in category theory (products, co-products, function application) are all defined in some way of factoring through a common structure
08:34:50 <bollu> ReinH: I get the motivation (from the isomorphism theorems of group, ring, theory etc.)
08:34:58 <bollu> ReinH: but I don't see why this definition was chosen
08:35:18 <Nadrieril> thanks for even acknowledging my presence...
08:35:40 <bollu> Nadrieril: oh sorry
08:35:50 <bollu> Nadrieril: I was distarcted and didn't see your response :)
08:35:54 <bollu> Nadrieril: thanks a ton!
08:36:01 <Nadrieril> ok sry$
08:36:05 <Nadrieril> -$
08:36:31 <bollu> Nadrieril: hm, so you're saying that we define things that way because that's the only way category theory lets us study objects?
08:36:39 <Nadrieril> I think yes
08:36:49 <bollu> Nadrieril: hm, I see
08:37:13 <bollu> Nadrieril: so in some sense, the objects that we pick to be canonical are the "smallest" such objects, right? (since we have a morphism from every other object that fits the bill to our chosen object)
08:37:38 <Nadrieril> what do you mean canonical ?
08:38:06 <bollu> Nadrieril: the object that I call the "product" is the canonical object
08:38:34 <Nadrieril> oh you mean in some categories you have some sort of canonical construction of what a product is
08:38:40 <bollu> Nadrieril: yes :)
08:39:04 <Nadrieril> I guess yes, but I'm not sure if we have much choice actually
08:39:31 <Nadrieril> we'd have to look at examples I guess
08:40:25 <gameer> Hey guys, to learn in a good way haskell, would u suggest to read the "learnyouahaskell" or something other(maybe with a bit more practise)?
08:41:25 <arw> gameer: usually you will need more than one thing to read. and just try everything and use what appeals most to you.
08:41:47 <bollu> Nadrieril: also, question
08:41:48 <pilne> https://github.com/bitemyapp/learnhaskell 
08:41:54 <bollu> Nadrieril: In any arbitrary category
08:42:03 <bollu> Nadrieril: am I guarenteed the existence of a product?
08:42:08 <bollu> Nadrieril: garenteed*
08:42:26 <bollu> Nadrieril: guaranteed**
08:42:48 <Nadrieril> I'm sorry I'm no expert in category theory, I get most of my intuition from examples and Haskell
08:42:57 <bollu> Nadrieril: np ;)
08:43:03 <bollu> Nadrieril: I was wondering is all
08:43:11 <Nadrieril> but I don't think so
08:43:42 <cocreature> bollu: I’m pretty sure the answer to that is no
08:44:01 <gameer> arw: Okay, thanks :)
08:44:02 <Nadrieril> like, take a simple cat with 2 objects A and B and only identity arrows, how would you construct a product of A and B ?
08:44:33 <bollu> Nadrieril: hm, right. 
08:45:05 <Nadrieril> ok, sry, principle of exmlosion. but maybe add two arrows from A to B and B to A
08:45:33 <bollu> Nadrieril: won't they be isomorphic then?
08:45:39 <bollu> Nadrieril: A and B
08:46:07 <Nadrieril> why would they be ?
08:46:15 <arw> gameer: learning is always a highly individual thing. I liked LYAH, but ymmv.
08:46:16 <cocreature> bollu: only if those arrows are inverse
08:46:40 <Nadrieril> actually in my example, I think both A and B are products of A and B x)
08:46:48 <bollu> cocreature: what do you mean by that?
08:47:15 <gameer> arw: Yeah. I thought maybe someone knows a website with good exercises to learn it in practise
08:47:19 <bollu> cocreature: don't two arrows always "cancel out"? like, f o g will be idA if f :: A -> B and g :: B -> A right?
08:47:20 <Nadrieril> well you're right, because their composition would have to be id
08:47:39 <Nadrieril> bollu: only because in my example the only A->A arrow is id
08:47:53 <arw> gameer: well, I've learned a lot by doing some euler project exercises in haskell.
08:48:05 <Nadrieril> arw: ooh, good idea that
08:48:07 <arw> gameer: but thats nothing haskell-specific.
08:48:48 <cocreature> bollu: no, take Set, then take {1,3} and {2,4} and f : {1,3}->{2,4} with f(x)=2, and g:{2,4}->{1,3} g(x)=1, then (f.g)(4)=2
08:48:49 <arw> gameer: and there are no real solutions or hints, especially about the specifics of a haskell implementation of an exercise.
08:49:23 <arw> gameer: so yes, a haskell-specific collection of exercises would be nice, but i don't know one.
08:49:33 <cocreature> @where nicta
08:49:33 <lambdabot> https://github.com/nicta/course
08:49:39 <cocreature> those are haskell exercises
08:49:51 <bollu> cocreature: hmm
08:49:52 <cocreature> but they are not for complete beginners, you should have read lyah or something like that
08:50:43 <Nadrieril> bollu: it is better said as "there can be other arrows than A->A idA"
08:50:43 <bollu> cocreature: I disagree with your example, because your category has two objects: {1, 3} and {2, 4}. And then you evaluated f . g $ 2, but you got 2 by "peeking into" {2, 4} which should not be allowed 
08:51:00 <Nadrieril> *"there can be other A->A arrows than idA"
08:51:25 <bollu> Nadrieril: ah, so then how do I know which arrow is the identity arrow?
08:51:32 <bollu> Nadrieril: I was thinking of arrows as functions, so I'm wrong?
08:51:39 <bollu> (as in, there is only one identity function
08:51:46 <Nadrieril> bollu: it is the one such that f.id = id.g = id
08:51:47 <cocreature> bollu: well that’s because I said I was working in Set, so the identity of an object is given by it’s elements so I can look into them
08:51:48 <bollu> Nadrieril: so in that case, Hom(A, A) can have many members?
08:51:54 <Nadrieril> bollu: yes
08:52:26 <Nadrieril> bollu: eg, for finite sets, you can have an arrow that swaps some elements around
08:52:36 <Nadrieril> every permutation of a set A is in Hom(A, A)
08:52:36 <gameer> arw: Thanks for the answer :)
08:52:42 <bollu> cocreature: hm, but I thought that the members of Set were Sets (i.e, the object is a Set)
08:52:54 <bollu> cocreature: and you're not allowed to know anymore about an object right?
08:53:10 <Nadrieril> bollu: *the objects of the Set category are sets, yes
08:53:29 <bollu> Nadrieril: ah right, sorry for the terminology
08:53:38 <Nadrieril> bollu: its not that you're not "allowed", you can do what you want
08:53:41 <bollu> Nadrieril: so if I tell you that A, B \in Set, arrow a :: A -> B
08:53:54 <cocreature> bollu: why shouldn’t I be allowed that? {1,3} is a Set so it’s an object in Set (f.g)({2,4})={4} so it’s not the identity arrow
08:54:02 <Nadrieril> actually you often have to look into specifics if you are studiying a given category
08:54:14 <bollu> Nadrieril: hm
08:54:31 <Nadrieril> category theory is only a framework to regognize common patterns and use properties on them
08:54:32 <bollu> cocreature: is that the way it works? so given a category you're allowed to peer into the objects?
08:54:42 <bollu> cocreature: I thought the objects were black boxes
08:54:43 <cocreature> if you are making general statements about category than you can obviously not look into it
08:54:47 <Nadrieril> ^
08:54:53 <cocreature> but if you are talking about a specific category do what you want
08:54:55 <bollu> cocreature: so why are you looking into the structure of Set?
08:55:06 <bollu> cocreature: oh, to give me a particular example?
08:55:09 <bollu> cocreature: I see now :)
08:55:21 <Nadrieril> bollu: why do you have notions like "being allowed or not" ?
08:55:25 <cocreature> bollu: you said the arrow are always cancelling each other out. I provided an example where they don’t
08:56:31 <cocreature> category theory becomes useful once you apply it to specific categories
08:56:53 <Nadrieril> otherwise it would only be abstract nonsense
08:57:02 <cocreature> you make a statement once in a very general setting and then you apply it to individual categories to actually use it
08:57:42 <bollu> cocreature: thanks, that helps in understanding it. I've been climbing the tower of abstraction in math, never thought of seriously "going the other way around"
08:57:47 <Nadrieril> like the notion of product, you can witness it on products of sets for example
08:58:14 <Nadrieril> and you actually construct it by taking elements of the two sets
08:58:31 <cocreature> bollu: it’s like when talking about group theory. you can’t look into the elements of a group if you want to make a general statement, but you can take any general statement and apply it to specific groups
08:58:40 <Nadrieril> but category theory still gives you powerful properties on them
08:58:55 <bollu> cocreature: right. 
09:02:22 <cocreature> bollu: the advantage of going to category theory to find a solution even if you don’t need it in the generality you get it there, is that by loosing the concrete structure and gaining levels of abstraction you can often come up with “cleaner” solutions
09:03:17 <bollu> cocreature: cleaner in the sense of more elegant, right?
09:03:28 <bollu> cocreature: like, "less obfuscating stuff"?
09:04:04 <cocreature> bollu: and more general so if we are using coding terminology "code resue"
09:04:13 <cocreature> *reuse
09:04:34 <bollu> cocreature: ah right :) 
09:04:48 <cocreature> bbl
09:08:37 <athan> @tell Kaidelong Also, the water you used to cook your pasta in your sauses also has starch in them helps thicken, too!
09:08:38 <lambdabot> Consider it noted.
09:09:37 <Nadrieril> bollu: if we come back to your original question, the answer is no: there is not alsays a product
09:09:47 <Nadrieril> wikipedia says so ^^ https://en.wikipedia.org/wiki/Product_%28category_theory%29
09:15:54 <bollu> Nadrieril: thanks
09:16:06 <Nadrieril> my pleasure :p
09:16:09 <Nadrieril> * :)
09:18:35 <Nadrieril> and actually, the product being a universal construction, I don't think we take the smallest object such that. on the contrary, all products of A and B are isomorphic, so there is actually "only one" such object
09:19:54 <Nadrieril> ^ bollu
09:54:39 <dimsuz> hi! Is there a 'stack' command to clean up a ~/.stack directory? It's about 5Gb now and I don't mind to do some extra compiling next time... Or is deleting it the only way?
09:58:18 <cocreature> dimsuz: deleting is the only way so far, there are some issues such as https://github.com/commercialhaskell/stack/issues/133 for cleanup functionality, but nothing has been implemented so far 
09:59:50 <dimsuz> cocreature: got it, thanks!
10:23:07 * hackagebot latex-formulae-image 0.1.1.1 - A library for rendering LaTeX formulae as images using an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-image-0.1.1.1 (LiamOConnorDavis)
10:34:47 <cir0x> Hey! Is it possible to compile a 64 bit executable for Windows (who hasn't ghc installed)?
10:36:06 <cir0x> (from OSX)
10:36:53 <monochrom> I don't think it has been done. next resort: use a virtual machine
10:38:07 * hackagebot wai-session-postgresql 0.2.0.4 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.0.4 (hc)
10:38:18 <monochrom> my sister runs windows in a virtual machine (mac host) just because of Quicken or something :)
10:38:55 <cir0x> monochrom: What a bummer. I liked that in go
10:42:07 <quchen> monochrom: What's "cross-compilation" in a Haskell context then?
10:42:13 <quchen> Targeting ARM from elsewhere?
10:44:51 <andromeda-galaxy> cir0x: I looked into doing it with GHC cross compilation once last year, but ultimately gave up (I decided that it was easier to build in a Win7 VM)
10:45:05 <andromeda-galaxy> mostly because there's not too much documentation on GHC's cross compilation
10:46:45 <andromeda-galaxy> cir0x: supposedly it got better in GHC 7.8.1 though, so it might be worth another ty
10:46:47 <andromeda-galaxy> *try
10:52:10 <cir0x> andromeda-galaxy: That would be a killer feature in my opinion
10:55:25 <andromeda-galaxy> cir0x: I've been thinking about doing it earlier, let me take a look at doing it (I can only test Linux, but it should be similar for OS X)
10:55:52 <andromeda-galaxy> cir0x: I think that the basic idea is to use LLVM cross compilation support + mingw32/mingw64 headers, and then build a cross-compiling GHC
10:56:05 <andromeda-galaxy> (see https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling)
11:07:24 <sphinxo> I'm looking for a type that I can annotate optimizations with as well as track how many have been performed
11:07:34 <sphinxo> I was thinking something akin to type Optimization = Program -> Writer [String] Program
11:08:19 <sphinxo> and then optimize program = foldM (\program f -> f program) program [ <optimization_funcs> ]
11:12:57 <sphinxo> Would this work?
11:13:06 <sphinxo> is there possibly a better way?
11:13:36 <hexagoxel> it is too easy to forget the parens in "(if _ then _ else _) other stuff" :/
11:27:15 <Nadrieril> :t foldM
11:27:17 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
11:27:47 <Nadrieril> sphinxo: seems like a good way to do that :)
11:28:02 <sphinxo> Ok thanks
11:29:57 <bollu> monochrom: are you around? I wanted to play RankNTypes :P
11:30:37 <Nadrieril> what is that game ?
11:30:59 <bollu> he poses a RankNType function, I give a legeal instance
11:31:06 <bollu> Nadrieril: it's silly, but it really got the point across 
11:32:49 <andromeda-galaxy> cir0x: I'm about to try building ghc head for cross (to Windows), I'll let you know if it works
11:33:19 <Nadrieril> oh nice
11:33:36 <Nadrieril> you have an example ?
11:33:37 <deni> why does hastacheStr of the hastache package have IO in it's type signature if it's getting all the inputs (text and context for rendering?)
11:33:47 <deni> or am i misunderstanding MonadIO?
11:34:05 <cir0x> andromeda-galaxy: That would be nice! Good luck
11:35:13 <bollu> > data CoFree f a = a :< (f (Cofree f a))
11:35:14 <lambdabot>  <hint>:1:1: parse error on input ‘data’
11:35:33 <bollu> okay, why is data CoFree f a = a :< (f (Cofree f a)) legal BUT data CoFree f a = a >< (f (Cofree f a)) not?
11:35:41 <bollu> (why can't I have a weird looking concatenation operator?)
11:36:07 <bollu> is there a rule that all product type operators need to start with a : ?
11:36:46 <hpc> bollu: it's the only upper case symbol
11:36:51 <hpc> and those are data contructors
11:37:27 <Nadrieril> deni: apparently it uses it only for IORefs :/
11:38:08 <bollu> hpc: wait, so because : is uppercase and a symbol it works? >_< that doesn't really make sense..?
11:38:15 <bollu> hpc: what are the parse rules like?
11:38:20 <hpc> bollu: those symbols are data constructors
11:38:27 <Nadrieril> deni: which is stupid, because it could stay pure by using STRefs
11:38:31 <hpc> constructors have to start with an upper-case character
11:38:37 <bollu> hpc: Ahh
11:38:38 <deni> Nadrieril: but I am correct in the thinking that hastacheStr should likely be pure and functions like hastacheFile (which obviosly does some file manipulation) should be in terms of IO ?
11:38:40 <hpc> that's why data Maybe and not data maybe
11:38:40 <bollu> hpc: I see. 
11:38:44 <deni> or is the Context somehow impure?
11:39:00 <bollu> hpc: so in the parse table why is : considered a "upper-case letter"?
11:39:16 <hpc> bollu: so (:) works for lists
11:39:30 <Nadrieril> deni: you are right, it could and should be pure
11:39:40 <hpc> i would have to look at the report to remember if (:) being upper-case is a ghc-ism or if haskell allows it
11:40:01 <bollu> hpc: so kinda-sorta-hack? :) well, so in that case, why does (:<) work? would (:&) work as well?
11:40:11 <hpc> :t (:&)
11:40:13 <lambdabot>     Not in scope: data constructor ‘:&’
11:40:13 <lambdabot>     Perhaps you meant one of these:
11:40:13 <lambdabot>       ‘:+’ (imported from Data.Complex),
11:40:19 <hpc> it would work if you defined it
11:40:56 <bollu> hpc, well, how come (:<) works?
11:41:05 <hpc> bollu: because it was defined that way
11:41:06 <bollu> hpc: (I'm using it to create CoFree and it does parse)
11:41:23 <hpc> here's a summary:
11:41:25 <hpc> data CoFree f a = a :< (f (Cofree f a)) -- legal
11:41:29 <hpc> data CoFree f a = a :& (f (Cofree f a)) -- legal
11:41:39 <hpc> data CoFree f a = a <: (f (Cofree f a)) -- not legal
11:42:04 <bollu> hpc: so anything starting with : is legal?
11:42:22 <hpc> in that particular case, yes
11:42:29 <nocturne777> is servant library mature enough to be used in production?
11:42:30 <hpc> because it's defining (:<) as a data constructor
11:42:41 <nocturne777> what's your experience with it like?
11:42:48 <hpc> (:<) :: a -> f (Cofree f a) -> CoFree f a
11:42:54 <bollu> right, understood. Are there any other characters that I can use to start data constructors?
11:43:00 <hpc> here's another few examples:
11:43:10 <hpc> x + y = x -- legal
11:43:13 <hpc> x +: y = x -- legal
11:43:17 <hpc> x :+ y = x -- legal
11:43:20 <hpc> er
11:43:22 <hpc> x :+ y = x -- not legal
11:43:35 <bollu> hpc: wait, (+) is legal? o_O
11:43:49 <hpc> bollu: pretend Num isn't in scope ;)
11:43:53 <Nadrieril> not as a constructur
11:44:03 <hpc> bollu: i am defining functions in that scenario
11:44:06 <bollu> ah, right. Nadrieril as a function right?
11:44:12 <Nadrieril> yup
11:44:30 <hpc> the wordy versions of these examples would be
11:44:32 <Nadrieril> the same rule applies: upper-case first letter for constructus, lower-case for functions
11:44:48 <Nadrieril> *constructors
11:44:58 <hpc> data CoFree f a = Whatever a (f (Cofree f a)) -- legal
11:45:04 <hpc> data CoFree f a = whatever a (f (Cofree f a)) -- not legal
11:45:17 <hpc> whatever x y = x -- legal
11:45:23 <hpc> Whatever x y = x -- not legal
11:45:41 <hpc> it makes perfect sense if you forget for a moment you're dealing with symbols and not letters
11:45:45 <Fuco> haskell is so oppressive with its naming conventions...
11:46:32 <bollu> hpc: now I'm unsure as to which symbols are considered "uppercase" (only : right?)
11:46:38 <hpc> correct
11:46:45 <hpc> only (:) is upper-case
11:46:50 <Nadrieril> actually the only "upper-case" symbol for GHC seems to be ":" https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/data-type-extensions.html
11:47:02 <hpc> you can remember because (:) is the cons constructor for lists
11:47:05 <hpc> so it has to be a constructor
11:47:09 <hpc> so it has to be upper-case
11:47:40 <Nadrieril> I find it a bit annoying that GHC uses that to identify names
11:47:43 <hpc> it is admittedly extremely hard to follow when you're new to the language
11:47:48 <bollu> hpc: thanks a ton :) one more thing about haskell I didn't know about
11:48:01 <Nadrieril> because it does not look like it would be easy to allow any symbol in both constructor and function names
11:51:07 <andromeda-galaxy> cir0x: it looks like, according to https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling, the only way to run GHC on one architecture and use it to build executables for another is by using a Stage 1 cross compiler
11:51:28 <andromeda-galaxy> cir0x: which, I think, might be missing some optimizations, etc., and, more importantly, doesn't do GHCi or template-haskell
11:51:53 <andromeda-galaxy> cir0x: if you don't use either of those, I think that you can cross-build like this:
11:52:18 <Nadrieril> why not template-haskell ? seems too high-level to be affected by this for mle
11:52:23 <Nadrieril> *for me
11:54:51 <andromeda-galaxy> Nadrieril: according to that page, it has to do with the Stage 1 compiler not being able to make certain assumptions about dynamic linking...
11:55:02 <andromeda-galaxy> erikd: are you around?
11:55:10 <Nadrieril> feels weird
11:55:14 <Nadrieril> a shame though
11:56:27 <Nadrieril> I guessed it would only need for llvm to actually cross-compile
11:56:56 <Nadrieril> *had guessed
11:57:27 <andromeda-galaxy> I'm not entirely clear on a couple of things about the GHC architecture, including why we can't run on HOST while targeting TARGET with a Stage 2 compiler... I've seen that erikd has been doing some work on cross-compiling
11:57:39 <andromeda-galaxy> cir0x: I think that the answer is basically that you can't do it now, but should be able to soon
11:57:47 <andromeda-galaxy> (e.g. see GHC trac #10070)
12:00:03 <cir0x> andromeda-galaxy: But then it's only possible with configuring the build properly, not with just one argument to ghc
12:00:06 <cir0x> ?
12:01:22 <andromeda-galaxy> cir0x: at this point, I don't think that GHC is set up to build multiple backends at once, though I might be wrong (it might be possible to convince the llvm backend to do the right thing)
12:02:48 <andromeda-galaxy> cir0x: if not, once a few more bugs are fixed, it should be possible to ship a few cross compiler executables & still make it relatively painless to cross build
12:03:13 <breadmonster> Is ghc 8.0 out?
12:04:09 <thoughtpolice> Because the stage2 compiler needs to load object code for features like Template Haskell. Obviously, a host compiler cannot load code for some other platform. If you're willing to give up the stage2 features (ghci, template haskell) then cross compiling will probably work (with fiddling)
12:04:56 <cir0x> andromeda-galaxy: Okay, I will test it when 8.0.1 comes out. Thanks a lot for your effort!
12:05:15 <zachk> so template haskell AND ghci doesn't work on the arm port of ghc? 
12:06:21 <thoughtpolice> It does in GHC 8.0, since we fixed most of the bugs.
12:06:31 <zachk> cool :D 
12:06:59 <maerwald> except a lot of other things will probably not work in 8.0 :P
12:07:29 <Nadrieril>  why ?
12:07:39 <Nadrieril> does it break things ?
12:07:43 <sm> shush! lies! 
12:07:45 <maerwald> because that's what happens with new major releases
12:07:50 * sm plugs his ears
12:07:54 <Nadrieril> ah yes, but nothing specific ?
12:07:55 <sphinxo> What would I return? http://lpaste.net/148726
12:08:22 <Nadrieril> sphinxo: "return xs" ?
12:08:23 <maerwald> 7.10 also took some time before it was "usable"
12:09:02 <sphinxo> ahh yes
12:09:05 <Nadrieril> what are the cool changes in 8.0 ?
12:09:29 <tdammers> also, the library ecosystem tends to need some time to catch up and adapt to the breaking changes in new releases
12:09:47 <maerwald> yeah, but that's with every compiler
12:09:52 <andromeda-galaxy> cir0x: no problem!
12:10:16 <maerwald> gcc5 also introduced a lot of build failures
12:10:28 <andromeda-galaxy> Nadrieril: -XTypeInType?
12:10:52 <andromeda-galaxy> Some version of OverloadedRecordFields
12:10:55 <andromeda-galaxy> a new LLVM backend
12:11:03 <andromeda-galaxy> Natrieril: https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1
12:11:19 <Nadrieril> oh nice thanks
12:11:43 <sphinxo> Nadrieril: what would be the equivelent for anything else? (Non-exhaustive patterns in function)
12:12:02 <sphinxo> wait dw
12:12:20 <Nadrieril> sphinxo: you mean "reduce x = return x" ?
12:12:26 <sphinxo> yes :)
12:12:32 <Nadrieril> there you go :)
12:17:41 <ReinH> bollu: http://cheng.staff.shef.ac.uk/autumn07/section02.pdf
12:22:29 <bollu> ReinH: thank you!
12:23:15 * hackagebot storable-tuple 0.0.3 - Storable instance for pairs and triples  https://hackage.haskell.org/package/storable-tuple-0.0.3 (HenningThielemann)
12:24:06 <ReinH> bollu: (btw that's Eugenia Cheng, the lady who does most of the Catsters videos, which are great)
12:26:40 <bollu> ReinH: oh, the same person with the cat. theory videos? nice
12:27:20 <bitemyapp> bollu: catsters yes :)
12:27:54 <Nadrieril> ReinH: nice link, thx
12:30:32 <bollu> ReinH: the link contains some basic notions of cat. theory correct?
12:31:48 <Nadrieril> yup
12:33:19 <deni> interesting fact: realworldhaskell.org is on django (no point being made just found it interesting)
12:34:37 <deni> anyway, the question I wanted to ask is the mtl chapter in rwh stil relevant? (I've heard on multiple occassions that the book, or atleast some chapters, haven't aged well)
12:41:58 <ReinH> deni: it's fine as far as it goes, but it doesn't even mention the main feature of mtl, which is using the typeclasses to specify your actions rather than concrete instances
12:42:23 <ReinH> e.g. (MonadState Foo m, MonadReader Bar m) => m () rather than StateT Foo (ReaderT Bar m) ()
12:42:47 <ReinH> that lets you defer the choice of implementation until much later, when you actually want to use the action.
12:49:14 <glittershark> ReinH++
12:51:52 <Fuco> hm... *** Exception: Map.!: given key is not an element in the map  ... but why doesn't it tell me what key :/
12:53:16 * hackagebot uri 0.1.6.4 - Library for working with URIs  https://hackage.haskell.org/package/uri-0.1.6.4 (JaroslavGridin)
12:53:34 <jle`> Fuco: that would require the function to have a Show constraint :o
12:53:52 <Fuco> hmm, fair enough
12:54:35 <sphinxo> I'm trying to implement a type but i'm not sure the syntax? http://lpaste.net/148727
12:54:38 <jle`> probably wouldn't be too tricky to write your own wrapper ... but if this is a real issue, maybe that's a sign you should be using `lookup`, heh
12:55:05 <Fuco> jle`: yes, I was just looking through a documentation for a ... -> Maybe v version :P
12:55:07 <jle`> sphinxo: pattern match as if you were using it
12:55:14 <jle`> sphinxo: optimize (e :*: e') = (optimize e) :*: (optimize e')
12:55:25 <jle`> optimize (e :*: e') = optimize e :*: optimize e'
12:55:32 <jle`> or optimize ((:*:) e e') = ...
12:55:39 <jle`> kind of the same thing for lists
12:55:45 <jle`> you can do foo (x : xs) = ...
12:55:51 <jle`> or you can do foo ((:) x xs) = ...
12:55:56 <jle`> you wouldn't do foo (x (:) xs) = ... :O
12:56:43 <athan> jle`: In the next langauge, `` becomes a mixfix operator...
12:56:48 <sphinxo> "Parse error in pattern"
12:56:58 <sphinxo>     optimize e :*: e' = (optimize e) :*: (optimize e')
12:57:18 <Fuco> someone remind me how can I disable the Prelude lookup
12:57:33 <jle`> sphinxo: would you do foo x:xs, or foo (x:xs) = ... ?
12:57:48 <jle`> > let foo x:xs = x in foo [1,2,3]
12:57:50 <lambdabot>  <hint>:1:5: Parse error in pattern: foo
12:57:53 <sphinxo> ahh yes
12:58:38 <sphinxo> Overlapping instances for Optimisable (Expr Int)
12:58:40 <sphinxo>       arising from a use of ‘optimize’
12:58:54 <sphinxo> actually what am I doing
12:59:39 <sphinxo>  (:*:) :: Expr Int -> Expr Int -> Expr Int
12:59:49 <sphinxo> optimize Int lol
13:00:13 <sphinxo> hmm
13:02:18 <sphinxo> Hmm i'm going to need a typed and untyped version
13:02:25 <sphinxo> right?
13:11:05 <jle`> sphinxo: your problem is that you have an instance for Optimisable (f a)
13:11:09 <jle`> and (f a) matches (Expr Int)
13:11:34 <jle`> so, if you're looking for an instance for (Expr Int), it can either choose your (f a) instance or your (Expr t) instance
13:12:01 <sphinxo> ahh
13:12:22 <danilo2> Hello guys! Are injective TF available in GHC 8.1 ? 
13:17:29 <sphinxo> How can I do this without using overlapping instances? http://lpaste.net/148729
13:19:28 <sphinxo> Anyone?
13:23:08 <danilo2> sphinxo: if you want this instance: `Optimisable (f a)` you have to use overlapping
13:23:23 * hackagebot tagsoup 0.13.7 - Parsing and extracting information from (possibly malformed) HTML/XML documents  https://hackage.haskell.org/package/tagsoup-0.13.7 (NeilMitchell)
13:23:58 <sphinxo> Maybe something like instance Foo a => Foo a  where
13:24:00 <sphinxo> ?
13:24:45 <danilo2> sphinxo: what does it mean? such instance does no have any sense unless provided with additioonal context and overlapping
13:25:18 <forker> Sorry, a bit OT: Does anyone know whether PostgREST's query operator syntax (http://postgrest.com/api/reading/#filtering) is inspired by some standard draft or a whitepaper?
13:26:24 <sphinxo> Maybe some outer constructor
13:27:28 <sphinxo> danilo2: What instance could I use instead?
13:27:45 <sphinxo> ( Optimisable (f a) )
13:31:54 <danilo2> sphinxo: that depends what youre trying to do
13:32:07 <danilo2> if you want such behaviour as expressed right now, use overlapping instances
13:32:16 <sphinxo> otherwise?
13:32:36 <danilo2> they are not so bad, in fact they are used in very many places
13:32:50 <sphinxo> Oh ok
13:37:35 <danilo2> sphinxo: fyi the overlapping isntances could be bad because they can lead to infinite compilation (looping the compiler).
13:37:51 <danilo2> but if you prove nothing like that happens they are perfectly safe
13:38:17 <danilo2> additional it is sometimes hard to debug or track the flow of the code which uses overlapping instances, but if you use them, you need usch flow
13:38:41 <sphinxo> hmm, ok
13:38:48 <danilo2> just keep in mind that unless you really have to dont release commonly used API to your users that uses overlapping instances
13:39:05 <danilo2> it is perf3ectly safe to use them as helper functions, because you control their behaviour
13:39:31 <sphinxo> ahh ok, will bare that in mind. Thanks
13:39:37 <danilo2> :)
13:50:02 <`Guest00000> hello. in the haskell wiki, syntax highlighting...
13:50:21 <`Guest00000> quotes in idents don't work properly. does nobody care?
13:51:06 <ReinH> `Guest00000: do you have an example?
13:52:26 <`Guest00000> random page: https://wiki.haskell.org/MapReduce_as_a_monad
13:53:04 <`Guest00000> does nobody really see it or does nobody care?
13:56:06 <Cale> `Guest00000: that is pretty bad, and probably a more recent development, given that the author of the article probably wouldn't have just left it that way
13:59:05 <`Guest00000> Cale: "the author of the article probably wouldn't have just left it that way" what choice did they have?
13:59:24 <Cale> `Guest00000: using identifiers without quotes in them
14:01:13 <hsk3> class HasDescription a where
14:01:13 <hsk3>     description :: String
14:01:18 <hsk3> This doesn't work
14:01:30 <ReinH> hsk3: what does "doesn't work" mean?
14:01:34 <hsk3> Should it be description :: a -> String ?
14:01:49 <ReinH> hsk3: Well, that depends on what you want it to do.
14:02:09 <ReinH> Presumably you want each value to have a description, not a single description for the entire type, in which case yes.
14:02:09 <hsk3> i want a general interface for things that have a description
14:02:27 <hsk3> ReinH: could I have a single descr for the whole type?
14:02:44 <ReinH> Yes, description :: String doesn't allow you to modify the description based on the value
14:02:58 <ReinH> so it is effectively a single description for the entire type (entire set of inhabitants of the type)
14:03:17 <hsk3> But like I said, that didn't work. It was a compile-time error.
14:03:29 <ReinH> What compile-time error?
14:03:32 <gaze__> Hey folks, is there any good introduction to how you might write a new GHC backend? Something similar to Haste or CLash
14:03:43 <ReinH> hsk3: "doesn't work" provides no information.
14:03:58 <ReinH> Try to use a more informative description of the problem.
14:04:01 <hsk3> The class method ‘description’ mentions none of the type or kind variables of the class ‘HasDescription a’ When checking the class method: description :: String
14:04:02 <hsk3> In the class declaration for ‘HasDescription’
14:04:17 <`Guest00000> hsk3: from a use of description there is no way to determine what type a is
14:04:21 <`Guest00000> so, use a proxy
14:04:58 <gaze__> Is it basically as simple as implementing a translation from Core+PrimOps?
14:05:03 <ReinH> hsk3: Ah, right, then the thing you don't want to do won't work.
14:05:05 <`Guest00000> you can use type a -> String and ignore the parameter,
14:05:56 <`Guest00000> or you can use type Proxy a -> String, where data Proxy a = Proxy
14:06:49 <`Guest00000> which guarantees that description won't use the value
14:06:54 <`Guest00000> which is nicer.
14:07:58 <ReinH> I don't think that they actually want to do that
14:08:08 <ReinH> I think they just want description :: a -> String
14:09:01 <`Guest00000> Cale: i don't know which of (renaming identifiers to remove quotes; letting it be) is uglier
14:09:41 <Cale> Probably just letting it be would be best until someone can swap the syntax highlighter for something saner
14:11:03 <`Guest00000> agree
14:13:19 <kadoban> Can hlint be made to understand somehow that "foreign import javascript" isn't a parse error?
14:20:24 <Cale> `Guest00000: I suspect that what's happened is that someone updated MediaWiki and the GeSHi plugin which does syntax highlighting, which had been modified before to support Haskell better, got reverted.
14:20:59 <Cale> `Guest00000: I'm not sure who is responsible for adminning the wiki at the moment
14:22:11 <hexagoxel> kadoban: does <wrapping inside #ifndef HLINT> count as "making understand"?
14:22:55 <kadoban> hexagoxel: Possibly. Is that built in to hlint, the ability to do that, or how does that work?
14:24:09 <hexagoxel> kadoban: i guess it is; although hlint docs only mention that they support CPP in general, not that they define HLINT.
14:24:46 <Cale> Is it just something you can ignore, or does it cause hlint to fail altogether?
14:24:54 <Cale> If it's ignorable, I'd just ignore it
14:24:58 <kadoban> hexagoxel: Hmm. It doesn't seem to be having any effect for me.
14:25:15 <Cale> It will probably require modifications to hlint to fix properly
14:25:16 <hexagoxel> kadoban: maybe needs CPP enabled
14:25:18 <kadoban> It appears to make hlint fail altogether for the file :-/
14:25:29 <kadoban> hexagoxel: Yeah CPP is enabled on the file
14:26:05 <hexagoxel> and.. you did #ifndef .. #endif ?
14:26:28 <kadoban> Yep. It's HLINT , all capitalized, right? I wonder if that's new, I can't remember how old my hlint is.
14:26:29 <gaze__> Here's a thought... CLash can compile haskell to hardware, and hardware requires bounded memory to simulate... what limitations do you have to place on haskell such that you can execute the compiled program in bounded memory?
14:27:01 <gaze__> Some sort of limitation on recursion, yes?
14:27:12 <Cale> Not so much on recursion
14:27:24 <Cale> Recursion doesn't itself do allocation
14:27:37 <hexagoxel> kadoban: random example of other user's code that makes use of it: https://hackage.haskell.org/package/contravariant-1.3.3/docs/src/Data-Functor-Contravariant-Generic.html
14:28:09 <gaze__> oh I guess walther recursion is used to bound time but doesn't say anything about space
14:28:10 <hexagoxel> no idea when it was added.
14:28:12 <kadoban> hexagoxel: Thanks much, I'll play with it … I must be missing something, mine looks essentially exactly like that.
14:28:24 <gaze__> So how do you bound space?
14:28:33 <gaze__> I guess... when does a functional program _need_ to allocate?
14:36:53 <Cale> gaze__: Well, it's a bit tricky, but if you make the language simple enough, you can basically have 'let' manage the heap, and 'case' manage the stack
14:38:25 * hackagebot tfp 1.0.0.1 - Type-level integers, booleans, lists using type families  https://hackage.haskell.org/package/tfp-1.0.0.1 (HenningThielemann)
14:39:28 <Cale> gaze__: It depends a lot on exactly what kind of implementation approach you're taking to everything, but the stack in GHC at least gets something pushed on to it whenever a pattern match occurs where the scrutinee isn't yet evaluated enough to match a pattern, and also whenever a function application occurs, and the function is not yet a lambda, and so needs to be evaluated before it can be applied.
14:39:48 <Cale> (at least, this is a high level way of looking at a bunch of more detailed stuff that's going on)
14:40:37 <broma0> anyone know of some reading on practical uses of the continuation monad or CPS in general? I've read the "Mother of all Monads" post in addition to the haskell wiki page, but what im really looking for is a use of the style in the setting of a real, effectful executable like Xonad, Yi, the fpcomplete ide, etc. (NOT TOY PROGRAMS).  
14:40:59 <Cale> broma0: It *really* doesn't come up very often
14:41:25 <Cale> broma0: I believe the Perl 6 interpreter used ContT for some reason...
14:42:11 <Cale> (Pugs)
14:42:43 <broma0> Cale: that's whats so interesting to me.. i feel like there MUST be a way to use it to make general programming simpler, more clever, etc. I dont know if i'll really ever use it, but i would like to see a program written with a base stack of (ContT r IO) or seomthing
14:42:55 <Cale> There are fun things you can do with it, but it's almost always overkill, and most people tend to avoid it, because using callCC nontrivially is a great way to give yourself a headache
14:42:59 <broma0> (and for good reason)
14:43:11 <verement> broma0: I am using ContT in a monad stack to implement exceptions and for-loop control (break, continue) for an embedded language
14:43:13 <gaze__> Cale: I see...
14:43:17 <Cale> It's basically a more powerful version of GOTO
14:44:07 <Cale> Yeah, the applications tend to be interpreters for languages where you're implementing a variety of control structures.
14:44:47 <broma0> Cale: I've been getting a bit tired of monad-stack centered programs lately.. need to play with other ways of doing things
14:44:57 <Cale> broma0: You can sort of imagine that all the procedure declarations in most imperative languages are implicitly wrapped up in  callCC (\ret -> ...)
14:45:00 <geekosaur> extensible effects?
14:45:18 <Cale> and then when you write "return x;", what it does is to execute ret x
14:45:38 <Cale> broma0: Yeah, I really don't like monad transformers very much these days
14:45:40 <Twey> There was a nice blog post on using continuations to implement effects, somewhere.
14:45:54 <Cale> broma0: They're way way overused
14:46:25 <Cale> People don't consider the more old-fashioned way of just packaging up the operations you need into a data structure and passing that around explicitly.
14:46:45 <Cale> You can even abstract those packages of operations over a choice of monad
14:46:53 <broma0> Cale: so what do you find yourself using nowadays? I so badly want a nice alternative to use. I'd like to limit my monad usage to isolated (and very simple) cases as opposed to having every function in my damn program monadic
14:47:17 <broma0> Cale: I've been doing that lately.. it's almost like OOP in a weird way
14:47:18 <Cale> Well, it's not so much monad vs. not monad right?
14:47:22 <Cale> Yeah
14:47:50 <broma0> Twey: im REALLY interested in that...
14:47:52 <Cale> You shouldn't set out to define monads -- but you should always recognise when you can get one, because it tends to save you lots of trouble.
14:48:00 <broma0> Twey: any idea where to find it?
14:48:14 <Cale> Instead, decide how you want the code for things to look, and how you want to break down problems
14:48:25 * hackagebot Slides 0.1.0.8 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.8 (darwin226)
14:48:32 <Cale> and then maybe the operations will include something Monad-like, and maybe they won't
14:48:54 <hexagoxel> i think you can use ContT when you want to do a withForeignPtr on a list of objects. but maybe i am wrong, and i have not actually used ContT, and have not had the time to try to refactor.
14:48:57 <Cale> and there's still a lot of domain-specific art to getting that right
14:49:11 <Cale> Oh, yeah, that's a cute application of Cont or ContT
14:49:23 <jle`> I'd only use ContT if i have a lot of `(a -> IO b) -> IO b`'s in my program
14:49:24 <Cale> If you want to use a whole bunch of with*-style functions
14:49:29 <jle`> or, i'm using a library with it
14:49:30 <Cale> and nest them all
14:49:37 <jle`> yeah, withStuff-style things
14:50:18 <hexagoxel> (especially if the interface _only_ exposes the withStuff-style)
14:50:59 <hexagoxel> (so my guess was correct? yay! i really should refactor the code, in that case.. :)
14:51:13 <broma0> the way i usually approach haskell problems is to define the pure datastructures and their associated pure functions, and then split up the larger program into the necessary layers of effects. What is starting to bore me is how those layers nearly always map to a (ReaderT (StateT blah)), or a ReaderT (MVar a).. etc, and then I have all sort of MonadReader, MonadState constraints everywhere
14:51:57 <Cale> :t runCont . sequence . map cont
14:51:58 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
14:52:13 <Cale> ^^ this function in particular can be quite useful
14:52:13 <hsk3> Can someone explain to me why this "feature" of Haskell is not utterly stupid? http://stackoverflow.com/questions/22622399/how-to-fix-illegal-datatype-context-use-xdatatypecontexts/22622591#22622591
14:52:14 <hsk3> Why should he not be able to constrain what a is in his Units data type, without repeating that constraint on every function that uses Units?
14:52:22 <jle`> broma0: that's weird that you would think about the transformers first and then write polymorphic things afterwards...
14:52:27 <hsk3> Seems like a major disadvantage of Haskell to me
14:52:32 <jle`> why not just reason with effects and write specific actions for specific effects?
14:52:42 <hsk3> (Sigh. Here I was getting all excited about writing something in Haskell, and now I come across this on the first day!)
14:52:43 <jle`> and then figure out a concrete monad to use afterwards?
14:52:48 <Cale> hsk3: Disadvantage vs. what?
14:52:55 <geekosaur> hsk3, you can do that with GADT instead of ADTs. but you lose other things when you do.
14:53:10 <jle`> broma0: you might not even use transformers int he end
14:53:13 <geekosaur> it's a fundamental tradeoff, not a Haskell-specific limitation
14:53:24 <Cale> hsk3: The reason is that you don't really need the Num instance to build values of your datatype
14:53:24 <verement> continuations and resource management: http://aherrmann.github.io/programming/2016/01/04/resource-management-in-haskell/
14:53:36 <Cale> hsk3: You need it when you go to use Num operations on the contents.
14:53:39 <jle`> hsk3: it's actually not advised because it's a bad idea
14:53:40 <Adeon> there is this one extension that allows you to hide ugly constraints to a type synonym
14:53:53 <hsk3> Cale: But shouldn't the programmer be able to specify the *intention* of his own data type?
14:53:54 <Cale> hsk3: So it's really the functions which operate on values of the datatype which need the instance to be available
14:53:56 <hsk3> intention of how it's used
14:54:03 <hsk3> and with what it's used
14:54:13 <broma0> jle`: sitting here thinking about "why not just reason with effects and write....."
14:54:16 <hsk3> I mean, otherwise I might as well just use a tuple
14:54:32 <Cale> hsk3: I don't see what you mean about the tuple
14:54:33 <jle`> i'd be more surprised to see hidden constraints in functions
14:54:36 <verement> extensible effects: http://aaronlevin.ca/post/136494428283/extensible-effects-in-the-van-laarhoven-free-monad
14:54:52 <jle`> seeing `foo :: Num a => Point a -> Point a` makes more sense to me
14:55:08 <Cale> hsk3: But yeah, this Units a type is effectively a pair of a value of type a, along with a value of type SymbolicManip a
14:55:17 <jle`> than foo :: Point a -> Point a with a magic constraint on `a` that i have to search around to find the source of
14:55:39 <hsk3> jle`: that's because it's just Point. What if it was a NumPoint?
14:55:54 <exio4> still not very nice 
14:55:54 <hsk3> and the creator of NumPoint had made it clear what it's for?
14:56:11 <Cale> hsk3: If you'd like evidence that a is an instance of Num to be packaged up along with the datastructure when you construct a value of type Units a, and then unpacked again to discharge a type class constraint, you *can* do that
14:56:16 <jle`> still sort of relying on documentation and the user being able to keep track of everything in their heads
14:56:25 <jle`> haskell is about not forcing people to keep track of things in their heads
14:56:34 <jle`> and just letting the type system take care of the 'worrying' for you
14:56:52 <hexagoxel> they only need to keep track of all of category theory.
14:56:56 <Cale> hsk3: However, it creates the extra inconvenience at the value level that you *must* pattern match the data constructor
14:57:20 <jle`> foo :: NumPoint a -> NumPoint a requires you to understand what NumPoint can have, what constraints you can instantiate `a` on, etc.
14:57:29 <jle`> foo :: Num a => NumPoint a -> NumPoint a, no confusion
14:57:39 <jle`> and it's a bit more nice, less magic
14:57:42 <jle`> more explicit
14:57:45 <Cale> hsk3: Because it would always be possible to construct, say, a value of type Units Char which was nothing more than an infinite loop.
14:57:59 <Twey> jle`: The alternative isn't magic or non-explicit
14:58:12 <Cale> hsk3: and so the instance wouldn't actually be required because you wouldn't have used the data constructor to build the value
14:58:12 <Twey> jle`: You can pass in a NumPoint a for any NumPoint a you like
14:58:33 <Twey> jle`: It just so happens that you can only construct a NumPoint a if Num a (and that's made clear by the signature on the constructor)
14:58:33 <jle`> Twey: yeah, but in hsk3 's desired use case, foo would only be implementable of `a` was a Num instance
14:58:37 <hsk3> jle`: Okay, I see. But wouldn't that be weird for new programmers, because they could write functions involving NumPoint but without the Num constraint, which is not what the guy who made NumPoint intended.
14:58:55 <hsk3> I still have to keep track of things
14:58:59 <hsk3> when writing new funcs
14:59:04 <Twey> To be clear, I'm against the idea on the grounds of maximum generality
14:59:07 <Cale> hsk3: So pattern matching the constructor becomes necessary in order to ensure that the instance of Num is there (operationally, the data constructor gets a hidden field with the dictionary of Num operations, carried along with the rest of the data)
14:59:14 <jle`> hsk3: if you want to write a function that is polymorphic over all NumPoint a's, then they can write foo :: NumPoint a -> NumPoint a, that's fine
14:59:20 <Twey> But I think that the arguments against it from magic are invalid
14:59:44 <jle`> hsk3: if you never *need* the Nummy properties of `a`, then you can feel free to write polymorphic functions
14:59:50 <Twey> (the arguments from complexity maybe less so — bundled instances are maybe a bit unintuitive, and at any rate something else you have to know)
14:59:58 <hsk3> jle`: hmm good point..
14:59:59 <jle`> if you *do* need Nummy properties, then, include the Num constraint
15:00:15 <jle`> in fact, you have a Point a -> Point a function already defined, `id :: Point a -> Point a`
15:00:18 <jle`> it doesn't ever use nummy properties of a
15:00:55 <jle`> besides, what if some time in the future, you want to use `sqrt`?
15:01:00 <jle`> like, if you wanted to calculate a Magnitude?
15:01:03 <Cale> hsk3: It's possible to do this if there's some reason you really need to do it, but it probably shouldn't be your first approach -- constraining the functions which operate on your data almost always turns out to give you an easier time in practice. I suppose it requires actually trying both ways a bunch to feel it.
15:01:15 <hsk3> jle`: But then what's the point of "data"? It seems the point is only to get a new name for some data structure for clarity (and some convenience functions if record syntax is used). But the point is NOT to constrain type parameters in that data.
15:01:36 <jle`> data Maybe a = Nothing | Maybe a
15:01:41 <jle`> pretty useful :o
15:01:53 <Twey> hsk3: It gives you a ‘new type’ which is important in Haskell sometimes (e.g. you can define new instances on it)
15:02:11 <jle`> and yeah, if you ever decided you wanted to use `sqrt` on your `Point`s, you can just write magnitude :: Floating a => Point a -> Point a
15:02:22 <jle`> basically your type signature tells you what aspects of the `a` you are using
15:02:23 <Twey> In theory you can get by with just Either and (,), at least in Haskell 98
15:02:31 <Twey> But it makes your code much nicer to not do so
15:02:37 <jle`> if you arbitrarily constrained your Point's to only take `Num a`'s, then you can't use Floating operations on it
15:02:39 <geekosaur> it's not "just" for clarity; it's also so the compiler can catch your mistakes at compile time instead of your program crashing at run time
15:02:40 <Cale> hsk3: That's right. You can bundle a bunch of values together, and you're allowed to have multiple variations on your data at the same time. So it's a bit like a combination between a union (though you know which branch of the union you have via pattern matching) and a struct
15:03:07 <geekosaur> in addiiton to being able to build new things (like Maybe and [] and Map ...)
15:03:21 <Cale> hsk3: The new data structure is allowed to have new distinct instances of type classes from, say, what the pair type would have.
15:03:35 <Twey> Oh, and of course you get inductive types that way
15:03:38 <Cale> hsk3: and it won't type check against a pair
15:03:48 <Twey> (which Haskell otherwise has no means of expressing)
15:03:54 <hsk3> very interesting
15:04:01 <hsk3> looks like i'm gonna have to get back to the drawing board
15:04:06 <jle`> hsk3: if you *could* constrain constructors like this, your life is necessarily going to be fundamentally more complicated.  the reason it's discouraged is because the alternative is not worth the trouble
15:04:06 <Cale> hsk3: So you can constrain which operations on Units a values you provide, and not export the data constructor, but only particular ways of building them
15:04:10 <hsk3> design my code more properly
15:04:14 <Cale> hsk3: and obtain abstraction like that
15:04:21 <Twey> hsk3: It shouldn't be a big issue.  Just put your constraints on the functions.
15:04:36 <Twey> The transformation should be trivial.
15:04:37 <jle`> remember that the extension was put in because people thought it was a good idea ... then we later realized it was a very bad idea, after using it in practice
15:04:54 <jle`> it's not because we thought "let's just not do this so we can make people angry"
15:05:06 <hsk3> :)
15:05:07 <Cale> Well, it's not a *very* bad idea
15:05:16 <jle`> hsk3: and, you might be surprised at what constraints you end up putting in on your functions
15:05:31 <Cale> I mean, depending on which class context you're talking about
15:05:38 <Cale> The stupid context is stupid :)
15:05:42 <Cale> It was a mistake
15:05:56 <Cale> But if you turn on GADTs, you get a somewhat more useful one
15:06:14 <Cale> which will pack up the type class dictionary into your value on construction
15:06:28 <Cale> and will unpack it again, discharging a constraint, when you pattern match
15:06:57 <Cale> However, yeah, this is not something you often really *need* and if you don't really need it, I would advise against putting it into use.
15:07:32 <Twey> Cale: ‘The stupid context’?
15:07:35 <Cale> Because indeed it makes your life hard when you start having to worry about which type class instances have been unpacked
15:07:49 <Cale> Twey: Yeah, the class context on data declarations in Haskell 98
15:07:53 <Twey> Oh, right.
15:08:07 <Cale> (It's actually *called* the stupid context in GHC's source code)
15:08:15 <Twey> Haha.
15:08:20 <Cale> Because it does nothing, except constrain the type of the data constructors
15:08:36 <Cale> which means you still have to add the same constraint to all the things which use the constructor
15:11:12 <Cale> hsk3: One thing that's positive that I can say though, relative to the way that I understand things to work in Scala (though I haven't done much Scala at all), is that whenever you have a class C and a data type T, and you obtain an instance C T from somewhere, whether it's by unpacking it from a GADT, or as an implicit parameter to your function because the function's type is constrained, you'll always know that you h
15:11:12 <Cale> ave the same instance.
15:12:02 <hsk3> I just find it kinda unexpected, that's all, that I can't do something like this: data (Eq a, Ord b) => EqAndOrdPoint a b = EqAndOrdPoint a b
15:12:02 <hsk3> Without the constraint this would be:
15:12:03 <hsk3> data EqAndOrdPoint a b = EqAndOrdPoint a b
15:12:04 <hsk3> but now the intention of the naming "EqAndOrdPoint" is gone from the type, and I might as well just use a damn tuple.
15:12:05 <hsk3> kinda confusing
15:12:23 <Cale> hsk3: So at least that's a burden which won't show up -- if you ever redundantly have two instances of Num T, you won't have to worry about which one is being used when you apply (+) to some things.
15:12:41 <Cale> hsk3: Well, it *does* constrain the type of the data constructor
15:12:49 <Cale> hsk3: It just does nothing more than that
15:12:59 <Cale> If you put the class constraint on the opposite side of the = sign
15:13:03 <Cale> then it will do more
15:14:06 <hsk3> what?
15:14:07 <Cale> data EqAndOrdPoint a b = (Eq a, Ord b) => EqAndOrdPoint a b
15:14:09 <Cale> like that
15:14:18 <Cale> you'll have to turn on GADTs
15:14:24 <Cale> or ExistentialQuantification
15:14:40 <Cale> i.e. add  {-# LANGUAGE GADTs #-}  to the top of your source
15:14:41 <haskell007> @pointfree comb f g a b = f a (g b)
15:14:41 <lambdabot> Unknown command, try @list
15:15:01 <glittershark> @pl comb f g a b = f a (g b)
15:15:01 <lambdabot> comb = flip . ((.) .)
15:15:03 <haskell007> what's the command for pointfree again?
15:15:08 <haskell007> or though we go
15:15:10 <glittershark> :)
15:15:19 <haskell007> *oh there we go
15:15:42 <Cale> hsk3: This will cause pattern matching on the EqAndOrdPoint data constructor discharge any requirement for an Eq a and Ord b instance from the body of the pattern match
15:15:56 <Cale> hsk3: and so for example, you'll be able to write things like
15:16:09 <Cale> equal :: EqAndOrdPoint a b -> EqAndOrdPoint a b -> Bool
15:16:37 <Cale> equal (EqAndOrdPoint x _) (EqAndOrdPoint y _) = x == y
15:16:57 <hsk3> Cale: yes that is exactly what I'd want!
15:16:57 <Cale> (obviously a somewhat poorly named function, but you get the idea)
15:17:09 <hsk3> are there any reasons not to use GADT?
15:17:20 <Cale> Yep, but probably this will lead you to some awkward and annoying situations eventually
15:17:49 <Cale> Because any case in which you don't explicitly pattern match on the EqAndOrdPoint data constructor, you won't have that Eq a instance in scope
15:18:15 <Cale> and so even if you happen to have some values of type a from elsewhere, and a value of type EqAndOrdPoint a b in scope
15:18:26 <Cale> that's not enough
15:18:37 <Cale> you have to case on the EqAndOrdPoint a b before you can compare
15:18:43 <Cale> even if you don't need the contents
15:18:58 <hsk3> why don't i need the contents?
15:19:20 <Cale> Well, sigh, this is a bit hard to explain from this example
15:20:14 <Cale> You might just have the EqAndOrdPoint a b structure hanging around for some other reason
15:20:27 <Cale> maybe you're passing it along to some future stuff
15:20:38 <Cale> and wouldn't normally need to unpack it yet
15:20:52 <Cale> But suppose you also have two values of type a which you'd like to compare
15:21:18 <Cale> If you want the Eq instance, you *must* pattern match the EqAndOrdPoint a b, or else demand the instance separately
15:21:49 <hsk3> Cale: you mean for the type inference to deduce the Eq ?
15:21:51 <Cale> Even if it looks like you're not using the contents of the EqAndOrdPoint a b at that point in your program
15:22:11 <Cale> yeah, pattern matching is what silently unpacks the instance and brings it into scope so you can use it
15:22:20 <Cale> It's a hidden third field of the data structure
15:22:30 <Cale> If you'd like to think of it that way
15:22:36 <hsk3> ah ok i see
15:22:51 <Cale> This implicitness of where you're getting things can eventually get confusing and a bit awkward
15:23:17 <Cale> and the necessity of pattern matching on a bunch of stuff you normally wouldn't, can be itself an annoyance
15:23:26 * hackagebot telegram-api 0.2.1.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.2.1.0 (klappvisor)
15:23:41 <hsk3> Cale: so your suggestion would be to not use GADTs, keep using EqAndOrdPoint and rely on the programmer to remember the original intention of EqAndOrdPoint when writing future functions?
15:23:52 <hsk3> (with the name EqAndOrdPoint acting as a hint)
15:24:08 <Cale> I mean, I would probably never name a type EqAndOrdPoint
15:24:34 <Cale> But yeah, moving the constraints into the functions which operate on your data is usually the right first thing to try
15:24:49 <Cale> There *may* be a valid reason that this doesn't work out, but they are very uncommon
15:25:12 <hsk3> ok, it would work. it just feels i'm putting burdens on my mind - burdens that i should put on the compiler instead
15:25:12 <Cale> and the correct solution to the problem might even be just to stop using type classes, rather than doing the GADT stuff
15:25:39 <Cale> Like, you might just start explicitly passing around records of the operations you need
15:25:44 <Cale> (sort of OOP-style)
15:25:54 <Cale> It depends on what you're doing of course
15:26:59 <hsk3> yeah
15:27:02 <hsk3> this was a great discussion
15:27:07 <hsk3> lot to look up
15:27:14 <hsk3> thanks!
15:27:37 <Cale> hsk3: I think I should say something about modules
15:27:46 <hsk3> sure
15:28:08 <Cale> hsk3: One thing it's very important you realise you can do with data types, is that you can define a bunch of functions for constructing and operating on values of your type
15:28:20 <Cale> hsk3: and then *not* export the data constructor from the module in which you do this
15:28:38 <Cale> so then the functions you've provided become the only way of constructing values of your type
15:28:42 <Cale> from outside the module
15:29:11 <hsk3> oh, that's something that could work!!
15:29:20 <hsk3> right?
15:29:22 <Cale> yes
15:29:25 <hsk3> without all the headaches
15:29:32 <Cale> Look at Data.Set as a shining example of this
15:29:54 <Cale> http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Set.html
15:30:47 <orion> Where is IO defined?
15:30:49 <Cale> If you click on the source link for "data Set a", you'll see that it has some data constructors, Bin and Tip, and Bin has a bunch of fields
15:31:04 <Cale> orion: In the Prelude? Or you mean GHC's implementation?
15:31:24 <Cale> hsk3: Bin and Tip aren't exported, and you can't pattern match on them
15:31:26 <orion> In the Prelude. I'm looking for something like, "data IO a = ..."
15:31:43 <hsk3> Cale: yeah i could live with that. you just have functions instead to extract stuff
15:32:02 <Cale> hsk3: and you can't build values of type Set which break the internal invariants without them (well, Set ends up exporting some other operations which let you do that anyway, just for efficiency's sake, but let's ignore that)
15:32:13 <andromeda-galaxy> orion: well, most of the implementation of IO is tied up with compiler internals,
15:32:35 <Cale> orion: GHC's implementation is not very enlightening and is quite hacky
15:32:47 <Cale> orion: but let me get you a link anyway
15:33:00 <hsk3> cool
15:33:02 <hsk3> thanks Cale!
15:33:10 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-prim-0.4.0.0/src/GHC-Types.html#IO
15:33:20 <Cale> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:33:28 <hsk3> LYAH mentioned this function-only way, i just forgot about it
15:33:36 <Cale> Here, the (# , #) thing is an unboxed pair type
15:33:47 <Cale> and State# RealWorld is a 0-bit-wide thing
15:33:58 <andromeda-galaxy> Cale: that reminds me: has anyone come up with a way to implement IO that isn't considered hacky?
15:34:08 <Cale> which is just used to coerce the compiler into keeping things in the correct order
15:34:09 <Fuco> free monads!
15:34:41 <Cale> and these "functions" to which the IO constructor is applied are actually not proper functions, but effectful, unsafe things
15:35:42 <Cale> andromeda-galaxy: Yeah, Fuco's got it -- there are lots of implementations of "free monads" or similar which would be much less hacky
15:36:18 <Fuco> but I guess down there somewhere you would still need the hacky IO
15:36:24 <Cale> andromeda-galaxy: The tricky bit is 1) handling FFI sanely -- this is possible, but it is not exactly trivial, and 2) getting good efficiency
15:36:30 <andromeda-galaxy> Cale, Fuco: ah, okay---thanks!
15:36:33 <andromeda-galaxy> that makes sense...
15:37:03 <Fuco> andromeda-galaxy: there was an article someone linked recently... let's see
15:37:06 <Cale> Fuco: Well, not necessarily -- you need an interpreter for your free monad's actions which is effectful
15:37:13 <Cale> Fuco: So in some kind of ideal world
15:37:18 <Fuco> andromeda-galaxy: http://degoes.net/articles/modern-fp/
15:37:28 <Fuco> that's a pretty good writeup
15:38:01 <andromeda-galaxy> Cale, Fuco: this formulation sounds like the way people get IO in Coq... thanks for the information, anyway!
15:38:32 <Cale> Fuco: (sorry for delay) the RTS might contain an interpreter for IO actions written in Haskell, using the IO monad :)
15:38:58 <Cale> Fuco: which would then unpack these data structures, and turn around and immediately carry out the things described
15:39:16 <Cale> and of course, your very first implementation of everything couldn't look like that
15:39:32 <Cale> But yeah, once you have one...
15:41:10 <Fuco> well, but you would still give your program to something like "run :: Freewhatever -> IO ()" when you try to pass it into main
15:41:19 <Fuco> or not? I guess I'm missing something
15:42:24 <Cale> Fuco: Well, you would, just as now, define main :: IO ()
15:42:43 <Cale> Fuco: and the compiler would link some interpreter for IO actions into the code
15:43:05 <Cale> Fuco: that interpreter might itself be written in Haskell, and compiled with an earlier version of the compiler
15:43:13 <Fuco> oh right
15:44:06 <Cale> The funny circularity of self-hosting compilers :)
15:45:07 <ReinH> Fuco: meh
15:46:10 <samba1> Why isn't this working? Shouldn't hoist be able to modify EitherT in this way? http://lpaste.net/4889436983614504960
15:46:12 <ReinH> Fuco: that article constructs a bunch of straw men and then takes an embarrassing amount of joy in tearing them down.
15:47:08 <Fuco> either way I found it quite accessible to understand how the free monad thing works
15:47:09 <ReinH> Fuco: For example, if I am trying to make the point that "functional code is *always* easier to understand" is untrue and I choose as my counter-example "blahblah :: Boolean -> Boolean -> Boolean -> IO (); blahblah b1 b2 b3 = ...", that is a straw man.
15:47:41 <Fuco> that is a bit silly argument, I agree
15:48:00 <samba1> and yes, I know EitherT is not preferred these days - not the point
15:48:22 <zipper> I can't parse a JSON array into a list of values of a given type. Say I have an array of JSON objects. I want to parse this array into a list of values of that type. However, the FromJSON instance only takes values of a kind *. Therefore my list can't work. How can I solve this?
15:48:25 <ReinH> In the "From Coal to Diamond", he uses a the same sort of straw man again.
15:48:27 * hackagebot ShellCheck 0.4.2 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.4.2 (vidarhol)
15:50:10 <zipper> Like in this case my JSON file starts as [{objects},..., {objects}]
15:50:24 <ReinH> Fuco: His point about IO is valid, but it doesn't need to be propped up with straw men.
15:50:44 <ReinH> Others have given better critiques of IO, e.g. Conal, that don't resort to such tactics.
15:51:23 <ReinH> If you strip out all that stuff, you are left with the standard presentation of free monad interpreters for DSLs, which is fine I guess.
15:51:51 <ReinH> but by the time I got to that point, I already had a bad taste in my mouth from the weird polemic that came before.
15:52:54 <ReinH> I think he could have just said "If you have a value of type IO (), you don't have any way of knowing what it does from the type signature. We can improve on that in the following way."
15:53:15 <ReinH> who will think of the straw children, etc
15:53:31 <ReinH> ok, /rant
15:53:39 * hackagebot tfp 1.0.0.2 - Type-level integers, booleans, lists using type families  https://hackage.haskell.org/package/tfp-1.0.0.2 (HenningThielemann)
15:58:02 <orion> http://degoes.net/articles/modern-fp/ - "
15:58:14 <orion> "Note that our DSL defines the semantics of the cloud files API (one can even define laws for these operations), but does not actually describe how to provide the service."
15:58:22 <orion> Are there any good tutorials on how to do that? ^
15:58:48 <ReinH> orion: you can look at the free package, which provides some examples.
15:58:57 <orion> thank you
15:59:18 <ReinH> It's odd that he constructed the same thing and didn't link to the free package, which also provides template haskell for constructing the smart constructors automatically etc
16:08:18 <erisco> looking back at this Hakyll site I did a year ago, I can't remember at all how it works XD
16:08:38 <zachk> no comments? -_-
16:09:22 <erisco> nope, the way you do Hakyll is you look at other people's Hakyll sites and copy from them
16:25:34 <pronoob> how i redefine order?
16:26:32 <andromeda-galaxy> pronoob: order?
16:26:52 <pronoob> yes
16:27:27 <andromeda-galaxy> pronoob: from what package?
16:27:38 <Welkin> pronoob: is that like an expert beginner?
16:28:40 <ironChicken> i have a struct in a C library (say, foo_t), a record ADT which corresponds to it (say, Foo), and a Storable instance for that ADT. i'm now trying to use peekArray to peek a C variable on type foo_t**, but i get a segfault
16:29:06 <ironChicken> am i doing the wrong thing?
16:29:20 <Nadrieril> "Note that if g is itself a Monad, then you can collapse Free g a into g a." << that sounds very wrong to me
16:29:28 <Welkin> ironChicken: yes, you are practicing iron penis kung fu
16:29:33 <ironChicken> is peekArray supposed to work for foo_t**? or only for foo_t*
16:29:48 <pronoob> my type is defined like this:
16:29:49 <pronoob> data Bla = Bla1 | Bla2 deriving (Eq,Ord)
16:29:58 <capisce> Nadrieril: why's that?
16:30:22 <geekosaur> peekArray expects (Ptr Foo)
16:30:22 <ironChicken> Welkin: ?
16:30:42 <geekosaur> if you have (foo_t **) then that is Ptr (Ptr Foo)
16:30:45 <Nadrieril> capisce: well, a monad doesn't behave the same as the free monad over the same functor unless it is the free monad, does it ?
16:30:58 <Nadrieril> or is there some kind of free theorem that says they are the same ?
16:31:03 <ironChicken> geekosaur: makes sense
16:31:10 <geekosaur> although C can be a bit unclear as to what that (foo_t **) represents
16:31:11 <erisco> pronoob, you can only have one instance of a type class per type, so if you deriving Ord then you can have no other instance
16:31:34 <ironChicken> geekosaur: yes. but i know in this case it's an array of pointers to foo_t
16:31:34 <erisco> pronoob, if you want to define the instance yourself, removing deriving Ord
16:31:52 <geekosaur> however uit sounds like it is an array of pointers to Foo-s, so peekArray gets you a Ptr Foo and you need to peek that to get the Foo
16:31:53 <capisce> Nadrieril: hmm, it doesn't say they behave the same way though
16:32:19 <ironChicken> geekosaur: yes, cool. i'll have a go...
16:32:40 <Nadrieril> capisce: so what does he mean by "you can collapse" ? I read it as "you can write both, they are the same"
16:33:11 <Nadrieril> if he meant there if a transformation from one to the other, then of course, it's the free monad
16:33:22 <Nadrieril> the quote is from there: http://degoes.net/articles/modern-fp/
16:33:33 <capisce> Nadrieril: that there exists a function collapse :: Monad g => Free g a -> g a ?
16:34:06 <Nadrieril> capisce: that, I'm okay with, but I tought he meant something else
16:34:19 <Nadrieril> I may have misread then
16:34:33 <Nadrieril> thx
16:35:13 <capisce> Nadrieril: it's in the context of "interpreting free structures" so I guess that trivial collapse function is just meant as one interpretation
16:35:45 <Nadrieril> ooh you're right, I understand now :)
16:35:48 <capisce> "Interpretation is a so-called natural transformation between functors"
16:36:11 <Nadrieril> well, it's not trivial, but it's canonical
16:36:18 <mgsloan> Is it possible to change any GHC RTS options during runtime (in particular, -xc)?  I bet there isn't a direct way to do it, but I figure I may as well ask
16:36:21 <Welkin> no, Canonical is a company
16:36:32 <Nadrieril> the Ubuntu monad ?
16:36:42 <Nadrieril> why not ?
16:36:43 <monochrom> haha
16:39:11 <maerwald> don't make me throw up plz
16:40:03 <geekosaur> ironChicken, btw I said that (foo_t **) is not clear on what that means: it can mean a pointer to an array of foo_t, or an array of pointers to foo_t. you need to know which one C is expecting to write the FFI binding, because the former is peek and then peekArray while the latter is peekArray and then peek each array element
16:40:27 <geekosaur> both are valid, both are useful in different circumstances, (foo_t **) doesn't tell you which you have
16:41:41 <geekosaur> it can also be an array of arrays of Foo, but that is less common (then you peekArray and peekArray the result)
16:42:01 <geekosaur> C is "fun" that way
16:49:47 <Nadrieril> and some dare to say C is typed...
16:49:56 <Nadrieril> -to ?
16:50:57 <orion> ReinH: What example were you referring to?
16:51:27 <orion> I looked through them and the closest one was the Teletype example, but I couldn't find an example of imposing structure on a free monad.
16:53:45 <Nadrieril> orion: it's not about imposing structure, it's about interpreting it iiuc
16:54:21 <Nadrieril> so you basacally need a runMyMonad :: MyMonad a -> whatever
16:54:58 <Nadrieril> that you can constructt yby recursively pattern-matching on Free
16:55:06 <hunteriam> a ++ b that does nothing if b == []?
16:55:47 <Nadrieril> hunteriam: I would guess GHC optimises that case out
16:55:56 <hunteriam> ?
16:56:00 <orion> Nadrieril: I'm defining a DSL, and I want to encode the following information in the type: "It is an error to call Y before X"
16:56:20 <Nadrieril> orion: you cannot incode that in the structure of your monad
16:56:23 <orion> I.e., I want that to happen at compile time, not runtime (within the interpreter)
16:56:29 <Nadrieril> unless you go into indexed monads
16:56:39 <Nadrieril> well, you need indexed monads
16:57:12 <orion> Ok, that's the second time someone has recommended indexed monads, but I'm wishy-washy on them. I'm not sure I fully understand them, and the ocharles tutorial (JSONF) wasn't helpful to me. :(
16:57:34 <Nadrieril> yeah, their not easy
16:57:42 <Nadrieril> I'm not too confortable with them either
16:57:44 <orion> they're
16:57:53 <Nadrieril> oh yes sorry
16:58:05 <Nadrieril> I don't usually do that mistake, I'm confused
16:58:10 <hunteriam> make*
16:58:20 <Nadrieril> thx :)
16:58:32 <hunteriam> Nadrieril: 
16:58:46 <Nadrieril> please have the pleasure of pointing out my mistakes, I'll progress better that way
16:58:52 <hunteriam> what did you mean "GHC optimises that case out"
16:59:44 <Nadrieril> well I would guess the actual "++" function implemented in GHC checks that b==[] because it seems pretty common
17:00:11 <Nadrieril> and "optimises out" wasn't correct, you're right
17:05:37 <andromeda-galaxy> Hmm... is there any way to do injective type families in GHC 7.10.2?
17:06:21 <RyanGlScott> andromeda-galaxy: Yes, if by "injective type families" you mean "functional dependencies" :)
17:06:38 <RyanGlScott> Otherwise, no. You'll have to be patient or just get GHC HEAD.
17:07:41 <andromeda-galaxy> RyanGlScott: oh, good idea; I'll try that out. I wrote everything as type families initially because they seem much closer to the idea of type-level functions... thanks anyway!
17:08:38 <zipper> I might be missing something but can I somehow sort a map by the value? All I can see in the libraries sorts depending on the keys.
17:13:26 <Cale> zipper: There's no better way to do that than to make a list of the values in the Map and sort it.
17:13:59 <zipper> Cale: But won't I lose the keys that way?
17:14:07 <RyanGlScott> e.g.,  sortBy (comparing snd <> comparing fst) . Map.toList
17:14:13 <Cale> zipper: The Map isn't internally stored in a way that has anything to do with any ordering which might exist on the values -- in fact, the values in the Map may even be of a type which may not have any defined ordering on it.
17:14:49 <xnil> if anyone here has experience doing haskell development professionally, i am wondering what a typical entry-level full-time haskell dev position would likely bring in terms of yearly salary
17:15:12 <zachk> I read somehwere: less then other languages
17:15:34 <Cale> xnil: They're uncommon enough that it's probably hard to get meaningful statistics. It probably depends a lot on what exactly you're doing.
17:15:51 <zipper> xnil: Depends on country. I'm interviewing for a job and idk how much I'll be earning yet. Still hazy. I'm not in yet.
17:15:56 <xnil> USA
17:16:07 <xnil> same, zipper. they're saying "name your salary."
17:16:32 <xnil> such nice jobs don't come around often enough for me to feel terribly confident throwing a figure out there.
17:16:53 <xnil> granted, it's remote, and i've been homeless before due to being raised in poverty, so money is not my highest concern
17:18:00 <Cale> You might also consider whether it is for a small startup, or for a company which is already profitable.
17:18:33 <xnil> perhaps both. it's for a small startup affiliated with microsoft.
17:19:23 <zipper> Cale: Startups pay less I assume? But some are well funded. I'm confused.
17:19:53 <Cale> zipper: Yeah, I guess some are well-funded. Every situation is different. :)
17:19:57 <xnil> i feel as though i have no option other than to gamble
17:20:22 <zachk> make sure they pay you! 
17:20:28 <Cale> zipper: Sometimes if you'll be working for some guy out of his pocket, and you expect the job to be fun, you might name a number which is a lot lower.
17:20:37 * zachk worked for a startup before and never got an honest check from them 
17:20:46 <Cale> I don't think I'd ever go below $25/hr
17:20:54 <xnil> zachk: i have done enough contracting to know better than that.
17:20:59 <zachk> good :D 
17:21:17 <Cale> (even as a relative beginner)
17:22:14 <erisco> how can I find where cabal installed a package?
17:22:17 <Cale> and you can probably get a lot more from most places
17:22:41 <zachk> the actual package or you want the source to the package? (local copy of the source) 
17:23:00 <Cale> Especially if you're working on stuff which is vital to their business, which is common if you're writing their software.
17:23:53 <zachk> erisco the package source tree is gzipped under invidual directories on *nix like systems in something like this:  ~/.cabal/packages/hackage.haskell.org/
17:24:27 <erisco> how can I get the path?
17:24:28 <RyanGlScott> Also try "ghc-pkg describe <pkg>" if you want to know where cabal installs the libraries, data, etc.
17:24:29 <zachk> then you can just tar zxf the source tarball cd into the new directory, hack the actual source, and run a cabal install to install a custom package 
17:25:53 <hunteriam> a ++ b that = [] if b = []?
17:25:59 <Cale> xnil: Also, remember that while there aren't so many Haskell jobs, there also aren't too many Haskell programmers to fill them
17:26:11 <xnil> indeed
17:26:24 <xnil> i was contacted directly for this job though
17:26:31 <i_am_mahasamoot> I'm teaching myself programming on www.hackerrank.com, mainly focused on Python.  However, I'm also interested in learning Functional Programming.  To two languages, on the list, that seem most interesting are Haskell and Ocmal.
17:26:50 <erisco> hunteriam, a ++ [] = a
17:26:55 <i_am_mahasamoot> what are some of the pros and cons of Ocmal vs Haskell as a first functional languaga?
17:27:04 <hunteriam> erisco: i want a ++ [] = []
17:27:15 <hunteriam> prefix if theres anything in b
17:27:16 <xnil> i_am_mahasamoot: asked many times before. one moment, i'll grab the stackoverflow link.
17:27:22 <erisco> what do you mean you want this? ++ is already defined
17:27:29 <hunteriam> ...
17:27:30 <zachk> haskell has really nice parallelism compared to ocaml, last I checked ocaml has a global lock, and uses OS threads with OS IPC to do multicore 
17:27:32 <Cale> xnil: If you have additional expertise that makes you more suited to it than average, pick something on the higher end that you'd be happy with, and maybe let them tell you if it's too much :)
17:27:40 <hunteriam> erisco: what im asking for is a variation of ++
17:27:42 <xnil> hunteriam: [] is a monoid. a ++ [] = a, [] ++ a = a
17:27:52 <xnil> err, ++ is a monoidal operation
17:27:59 <hunteriam> xnil: i want a version of ++ such that a ++ [] = []
17:28:05 <xnil> ???
17:28:08 <erisco> okay, well, that is just a strange way to word it
17:28:09 <hunteriam> ??
17:28:11 <zachk> also haskell is pure and lazy, which can expand your mind, ocaml is strict can have IO effects anywhere and has an OO, that supposedly is very rarely used
17:28:15 <erisco> you want something completely different, not ++ at all
17:28:18 <Cale> xnil: But tbh, I never really 100% know how to answer such questions either.
17:28:20 <hunteriam> ...
17:28:23 <hunteriam> no i do want ++
17:28:24 <zachk> also the ML family, supposedly has a better module system 
17:28:26 <hunteriam> its a slight variation
17:28:40 <erisco> then you have me confused
17:28:52 <hunteriam> a ++ b = [] if b = [] 
17:28:54 <hunteriam> thats the variation
17:29:20 <erisco> myAppend a [] = []; myAppend a b = a ++ b;   ?
17:29:23 <zachk> hunteriam import Prelude hiding (++) and roll your own (++) to do what you want, that might break some things though, not sure 
17:29:35 <hunteriam> thanks for you help guys
17:29:40 <hunteriam> anyone got an elegant version?
17:29:43 <andromeda-galaxy> zachk: but backpack!
17:29:51 <zachk> whats backpack? 
17:30:18 <andromeda-galaxy> zachk: bringing Haskell the benefits of ML modules
17:30:35 <andromeda-galaxy> https://ghc.haskell.org/trac/ghc/wiki/Backpack
17:31:00 <i_am_mahasamoot> zachk: so Haskall would run better on all these multicore cpus and be a better education to boot
17:31:07 <andromeda-galaxy> zachk: http://plv.mpi-sws.org/backpack/
17:31:29 <andromeda-galaxy> zachk: and http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/ is a nice explanation of why we want it
17:31:46 <Cale> i_am_mahasamoot: yeah...
17:31:47 <Nadrieril> also, Haskell has better type inference
17:31:57 <Nadrieril> and uniforme syntax
17:31:59 <Nadrieril> -e
17:32:19 <Cale> i_am_mahasamoot: OCaml is a nice language in the big picture, but there are a lot of areas where Haskell edges it out slightly and manages to be a little nicer.
17:32:36 <andromeda-galaxy> as a convert from lispland, I can't really say that Haskell or ML has uniform syntax...
17:32:36 <exio4> Cale: like equality?
17:32:42 <Cale> exio4: indeed
17:33:11 <Nadrieril> I also find Haskell much more suited to do actual pure functional programming, with abstractions that feel natural 
17:33:12 <Cale> Haskell is just newer than OCaml, and had the advantage of being able to fix things which were already known to be awkward and yet hard to change there.
17:33:20 <Welkin> xnil: lol
17:33:25 <Nadrieril> andromeda-galaxy: indeed x)
17:33:27 <Welkin> xnil: the first person to say a number loses
17:33:34 <Welkin> xnil: when they ask you to name your salary, it is a trap
17:33:56 <xnil> i know
17:34:00 <andromeda-galaxy> Nadrieril: I do sometimes still miss the ease of writing macros in lisp, TH is something but it's a lot more difficul to use...
17:34:02 <exio4> zachk: import Prelude hiding ((++))
17:34:13 <zachk> wasn't haskell originally written in Lazy ML? 
17:34:14 <Welkin> xnil: they could havea budget of (for example) $120k for the position, but you say "I will do it for $60k!" then they just saved 60k per year
17:34:14 <exio4> Welkin: say something insanely high
17:34:15 <Cale> The main areas where OCaml might be considered nicer than Haskell are perhaps metaprogramming support (though Haskell does have a system for this called Template Haskell, I've heard really good things about MetaOCaml vs. it)
17:34:19 <Nadrieril> andromeda-galaxy: indeed... 
17:34:25 <Cale> and the module system
17:34:32 <Nadrieril> never actually done a lot of Lisp however
17:34:33 <i_am_mahasamoot> Cale: yeah, it's hard to change things once there's a codebase, take Python3 for example
17:34:50 <xnil> macros are in effect a CodeSmell
17:34:53 <xnil> on a team anyways
17:35:00 <andromeda-galaxy> I have a :: (Member 'Fld1 s ~ True, Member 'Fld2 s ~ False) => [Form s], and now GHC says "Could not deduce (Member 'Fld2 s0 ~ False)", with a :: [Form s0]...  can anyone explain that?
17:35:00 <xnil> on one-or-two-man projects, they are a godsend
17:35:01 <Welkin> god
17:35:07 <Welkin> that word "code smell" is a horrible word
17:35:08 <erisco> it is too bad that the Haskell stuff for Atom is crashing =\
17:35:10 <Welkin> who the fuck came up with that?
17:35:17 <xnil> Welkin: CodeSmell is a WordSmell
17:35:23 <Welkin> I usually hear it in the context of hacker news or paul graham, when he shits it out of his ass
17:35:28 <xnil> i think it was c2 that came up with it
17:35:32 <xnil> the consulting firm
17:35:33 <Welkin> is paul graham's writing what smells?
17:35:34 <Welkin> dunno
17:35:34 <Nadrieril> Welkin: the one that came out with "brainfart" ?
17:35:36 <erisco> it was on track towards a reasonable environment for Haskell
17:35:43 <Nadrieril> which is a likely horrible work
17:35:47 <andromeda-galaxy> xnil: that can sometimes be true, but even in very collaborative environments, a few, well-written and well-documented macros can still be incredibly useful
17:35:47 <Nadrieril> *word
17:35:48 <xnil> i don't really like PG very much tbh
17:35:55 <xnil> andromeda-galaxy: indeed
17:36:06 <xnil> that could be argued for anything
17:36:21 <hunteriam> elegant way to write ++ where a ++ [] = []?
17:36:23 <xnil> i will concede my opinion at that everything is good when handled correctly, except C++
17:36:31 <andromeda-galaxy> xnil: good point.
17:36:37 <andromeda-galaxy> the way that I've heard it said about lisp:
17:36:37 <xnil> hunteriam: a ++ [] /= []
17:36:38 <Nadrieril> hunteriam: how would that differ from the standard "++" included in Haskell ?
17:36:39 <exio4> hunteriam: what do you mean? 
17:36:53 <xnil> hunteriam: that is never the case
17:36:59 <hunteriam> exio4: a version of ++ where a ++ [] = []
17:37:00 <andromeda-galaxy> xnil: in lisp, good programmers can write incredible code, but bad programmers can write incredibly bad code.  In java, everyone writes mediocre code.
17:37:02 <Nadrieril> oh yeah, misread that
17:37:03 <xnil> why don't we make 1 + 2 = 10
17:37:05 <hunteriam> xnil: trying to define one dude.......
17:37:06 <exio4> hunteriam: why do you want that?
17:37:07 <Cale> i_am_mahasamoot: Yeah, Haskell's already kind of running into some of that. We're still sort of enamoured with the fact that there's a lot of packages now, but changes to the basic libraries have been really difficult to make for several years already, and there are things on the horizon which might require just defining a new language rather than trying to fit them into Haskell proper.
17:37:17 <hunteriam> exio4: I want to prefix a string if its not empty
17:37:26 <andromeda-galaxy> hunteriam: that makes lists not a monoid anymore...
17:37:31 <xnil> andromeda-galaxy: i could write ok code in java. it would just take a lot of scrolling to read it
17:37:43 <xnil> and a lot of boilerplate to get started
17:38:01 <andromeda-galaxy> xnil: of course, it would work, but the boilerplate & scrolling make it mediocre compared to languages where we can remove lots of boilerplate
17:38:10 <Nadrieril> hunteriam: let (+~+) a b = if b==[] then [] else a++b ?
17:38:12 <xnil> sure
17:38:22 <Welkin> xnil: you'd do better to invite some rats to dance on your keyboard for cheese
17:38:22 <hunteriam> Nadrieril: yes that is a solution
17:38:35 <andromeda-galaxy> hunteriam: why do you want that
17:38:35 <andromeda-galaxy> ?
17:38:45 <hunteriam> "exio4: I want to prefix a string if its not empty"
17:38:58 <andromeda-galaxy> hunteriam: oh okay, sorry I missed that...
17:39:00 <Cale> i_am_mahasamoot: In particular, it would be really nice to have a dependently typed language with non-strict semantics, and while this is still somewhat of a research project (how do non-strict semantics work with terms that have open variables in them when you're doing typechecking), it's something that seems inevitable that we'll want to do it, and yet fitting that into Haskell in a backward compatible way might be c
17:39:01 <Cale> hallenging or awkward.
17:39:11 <xnil> but i'm more of an engineer than a programmer, and i'm of the opinion that programming languages are unnecessarily heavily evaluated
17:39:32 <xnil> "TODO" comments first, then code.
17:39:37 <exio4> Nadrieril: .. er, why b == []? 
17:39:42 <andromeda-galaxy> hunteriam: how about defining a nicely named 'prefix' function for doing that?
17:39:54 <hunteriam> yes that is an option
17:39:58 <xnil> TDD is a waste of time on most projects, assuming sufficient talent within the team
17:40:00 <exio4> Nadrieril: { a +~+ [] = [] ; a +~+ b = a ++ b ; } 
17:40:19 <andromeda-galaxy> xnil: fair enough, I guess I'm too much of an academic to avoid evaluating programming languages...
17:40:23 <Cale> i_am_mahasamoot: For the last decade or so, many of the type system extensions to Haskell have been possible to view as sort of edging closer to dependent types, or opening up some styles of programming coming from dependently typed languages.
17:40:23 <xnil> me too
17:40:26 <xnil> i'm super opinionated
17:40:37 <Nadrieril> exio4: yeah, but I couldn't find a nice way to write it on a single line x)
17:40:51 <xnil> all but idris and haskell and turbo pascal and python and a few others can go lay to die IMO
17:41:04 <hunteriam> C is very useful
17:41:09 <xnil> "a few others"
17:41:21 <andromeda-galaxy> xnil: wait, how did turbo pascal make that list?
17:41:34 <xnil> andromeda-galaxy: ...and why didn't APL?
17:41:35 <hunteriam> honestly all the languages are useful
17:41:37 <xnil> or prolog?
17:41:44 <xnil> hunteriam: not really, no.
17:41:46 <Nadrieril> xnil: assuming sufficient talent from a team makes people say that C++ is better than Rust
17:41:46 <pavonia> Is Pascal still a thing?
17:41:47 <xnil> C++ has no place
17:41:49 <xnil> pavonia: yes
17:41:52 <andromeda-galaxy> hey, I kinda like prolog...
17:41:56 <xnil> prolog is great
17:41:58 <hunteriam> xnil: i think the fact that people use C++ heavily is proof that they are
17:42:09 <exio4> xnil: C++ does have a place
17:42:20 <xnil> hunteriam: i think it's more proof of bureaucracy in software shops
17:42:32 <hunteriam> xnil: what should people use instead?
17:42:42 <Cale> xnil: One thing I think is not necessarily a waste of time, though still can be challenging to fit in, is to put QuickCheck-style property-based testing somewhere into your development process.
17:42:42 <xnil> whatever they want
17:42:43 <Nadrieril> hunteriam: Rust
17:42:47 <exio4> xnil: it has deterministic resource usage, and TMP, it's nasty, but it is powerful, Rust is still green and it doesn't have that many libraries, for once
17:42:48 <xnil> C mostly
17:43:04 <xnil> rust is not up to speed with c++
17:43:20 <Nadrieril> not yet, but it will be soon
17:43:24 <Cale> xnil: It depends on what you're working on, but it's much less of a waste than unit tests, because coming up with the tests in the first place does something to make you think about your design in a particular way.
17:43:34 <hunteriam> xnil you think C++ is chosen because..? 
17:43:37 <Nadrieril> and people will make much better code with it
17:43:38 <orion> When designing a pair of DSLs, what should you do if there's a partial overlap in terms of instruction sets?
17:43:48 <exio4> xnil: C sucks badly when it comes to re-using code, which C++ achieves, in a nasty way, but it does achieve something
17:44:02 <xnil> exio4: i fully disagree
17:44:08 <xnil> we have unix shells for a reason
17:44:14 <Nadrieril> orion: either different modules, or an ugly prefix 
17:44:18 <hunteriam> unix shells?
17:44:19 <xnil> i think it could be better but it is certainly not unmanagable
17:44:20 <Cale> xnil: If you have to come up with universal properties that combinations of the functions you've defined will satisfy, rather than just one-off tests, doing lots of testing will coerce you to design things which are nicer just to be able to test them :)
17:44:29 <xnil> grep, sed, vim, etc.
17:44:40 <hunteriam> xnil: reusing code, not programs
17:44:48 <Nadrieril> orion: unless there's something inherently similar, in which case you can try to fit a typeclass somewhere
17:44:50 <xnil> hunteriam: ?
17:44:55 <hunteriam> ?
17:44:57 <xnil> hence where grep, sed, and vim are all useful
17:45:00 <glguy> The relative merits of C, C++, Rust, &c. are off-topic in #haskell
17:45:08 <Welkin> lol what
17:45:09 <xnil> Cale: indeed. i've used TDD on my own teams before out of necessity
17:45:11 <Welkin> I don't get it
17:45:14 <hunteriam> ^
17:45:16 <exio4> xnil: -> #haskell-blah?
17:45:28 <xnil> sure
17:45:41 <Welkin> after all these decades, people still find it entertaining to say the same things over and over about all the different programming languages
17:45:44 <Welkin> lol
17:45:45 <Welkin> it's like religion
17:45:53 <hunteriam> nice `++` where a ++ [] = []?
17:45:54 <xnil> Welkin: it'll always be that way.
17:45:55 <Cale> xnil: and it's often not obvious what the best semantics for your basic building blocks and combinators will be until you think about the properties they should have in that way
17:45:55 <Welkin> I lost interest a long time ago -- like with religion
17:46:01 <Nadrieril> Welkin: +1
17:46:09 <hunteriam> lets talk about religion guys
17:46:16 <zachk> plz don't
17:46:22 <xnil> i officially revoke my involvement in this discussion
17:46:24 <Cale> -- you almost don't even need to run the tests though, just thinking about the algebraic properties is enough
17:46:29 <xpilot> do you know what the 4th largest religion is?
17:46:38 <Welkin> do you know the muffic man!?
17:46:38 <Nadrieril> Whovian \o/
17:46:44 <zachk> xpilot #haskell-blah !!! (plz) 
17:46:52 <Welkin> muffin man*
17:46:57 <Welkin> the muffin man
17:46:57 <hunteriam> pls #haskell needs to talk about religion
17:47:03 <Sinestro> i mean, now that we've got christianity judaism is pretty much obsolete, right
17:47:07 <Sinestro> c vs c++ kinda thing
17:47:13 <zachk> there is an offtopic channel for haskellers called #haskell-blah 
17:47:14 <Nadrieril> nice one Sinestro
17:47:31 <xnil> anyways
17:47:32 <Welkin> zachk: you dirty whore
17:47:35 <Cale> xnil: But I dunno, yeah, X-driven-development for pretty much any X will be wrong :)
17:47:38 <xpilot> the google results for "how to convert to X" are judaism, islam, catholicism
17:47:40 <xpilot> and pdf
17:47:41 <xnil> Cale: yup
17:47:42 <glguy> Welkin: no thanks
17:47:45 <xpilot> ok I'm done
17:47:48 <Sinestro> pdf is the one true faith
17:47:49 <andromeda-galaxy> I have a :: (Member 'Fld1 s ~ True, Member 'Fld2 s ~ False) => [Form s], and now GHC says "Could not deduce (Member 'Fld2 s0 ~ False)", with a :: [Form s0]...  can anyone explain that?
17:47:57 <hunteriam> you cant prove pdf is real
17:48:01 <xnil> Welkin: i have a fair idea of how to handle the situation, but how should i respond to "name your salary?"
17:48:37 <Nadrieril> andromeda-galaxy: a problem with parentheses ?
17:48:44 <andromeda-galaxy> Nadrieril: I don't think so....
17:48:48 <xpilot> in other news, does anyone know where to find a table to ghc exit codes?
17:48:51 <Nadrieril> :/
17:49:10 <andromeda-galaxy> Nadrieril: I don't think so... s is a type-level set, Member is a type family,
17:49:20 <xpilot> I'm trying to compile th-orphans and all I'm getting is "ExitFailure (-11)" with cabal --verbose=3
17:49:36 <orion> Cale: Some things are difficult to test.
17:49:48 <Cale> orion: Indeed.
17:49:49 <andromeda-galaxy> I want to write datatypes that can be partially valid, so according to the validity information in the type some fields of the record will be Maybe t and others will be t
17:50:15 <Cale> orion: But the more you think about how to break things into easily QuickCheckable parts, I think it can only help. :)
17:50:21 <andromeda-galaxy> so now I'm trying to compose functions that ensure that a certain field is valid (actually, in this case, they do it by filtering a list)
17:50:25 <RyanGlScott> xpilot: Compile with -j1 to show the error messages
17:50:28 <andromeda-galaxy> and ghc seems like it's missing something...
17:50:28 <orion> "decrypt . encrypt === plaintext" isn't all that useful
17:50:41 <Nadrieril> andromeda-galaxy: it seems like it has not seen that s0~s to me...
17:50:53 <andromeda-galaxy> Nadrieril: agreed, it's kind of odd...
17:50:57 <Nadrieril> soes it say where s0 comes from ?
17:50:59 <Cale> orion: I'd say it's pretty important as a start!
17:51:06 <RyanGlScott> (Specifically, it compiles with one processor. But error messages don't show up if compiling with multiple processors.)
17:51:14 <Nadrieril> rha, why is IRC not threaded !
17:51:21 <orion> Cale: Ok, what if you're testing a hash instead of a symmetric cipher?
17:51:46 <andromeda-galaxy> Nadrieril: GHC says the type variable s0 is ambiguious, and it only seems to get it from saying a :: [Form s0]
17:51:53 <xpilot> RyanGlScott: that doesn't seem to change anything. I don't think I was ever compiling with multiple processors
17:52:05 <Xe> Nadrieril: too many hands on the code having too many opinions that threading is the devil
17:52:14 <andromeda-galaxy> but it seems to be missing some context, since I wrote a = () :: (..., Member 'Fld2 s ~ False) => [Form s]
17:52:21 <Nadrieril> that is strange... can you try explicitely typing your list ?
17:52:35 <orion> Nadrieril: May I PM you?
17:52:44 <Nadrieril> orion: yeah why not
17:52:56 <Cale> orion: Then the correct way to test depends on what the hash is. You might be able to test that single-bit changes don't result in collisions.
17:53:09 <Nadrieril> andromeda-galaxy: () is of type (). maybe you wanted undefined instead ?
17:53:10 <andromeda-galaxy> Nadrieril: do you mean using a :: [Form (<type level set here>)]?
17:53:16 <Nadrieril> ^ yes
17:53:23 <andromeda-galaxy> oh sorry, that's not actually ()
17:53:28 <andromeda-galaxy> it's just some code that I forgot to insert dots for
17:53:31 <Nadrieril> ok
17:53:47 <andromeda-galaxy> I tried using explicit types earlier, and it worked (actually, just explicitly typing the main function definition is enough), but it looses genericity
17:53:54 <andromeda-galaxy> and kind of defeats the point of using this representation
17:53:58 <Nadrieril> andromeda-galaxy: can you lpaste a snippet ?
17:54:02 <Nadrieril> @paste
17:54:02 <lambdabot> Haskell pastebin: http://lpaste.net/
17:54:05 <andromeda-galaxy> Nadrieril: sure, why not
17:54:36 <andromeda-galaxy> hold on, it's in lhs so I have to remove the >
17:55:06 <Cale> orion: Also, most testing of hash-functions, while it might not exactly be "QuickCheck style testing" will have to do with mathematical statistical properties of the hash, and so will be randomised testing of algebraic properties.
17:55:40 <andromeda-galaxy> Nadrieril: http://lpaste.net/7906396065874575360
17:56:07 <erisco> man Hakyll is confusing :(
17:56:25 <andromeda-galaxy> erisco: what's wrong?
17:56:54 <RyanGlScott> xpilot: It's possible the error message is getting lost in the verbose output. Try just cabal install th-orphans -j1, and post the output to http://lpaste.net/
17:57:00 <erisco> posts <- recentFirst =<< loadAll "posts/*"   does anything here say to apply a template to each post?
17:57:08 <erisco> because every post has my site's header and footer on it
17:57:14 <andromeda-galaxy> Nadrieril: wait, that was the wrong one, sorry
17:58:28 <andromeda-galaxy> Nadrieril: http://lpaste.net/5544816729189777408
17:58:37 <xpilot> RyanGlScott: http://lpaste.net/148739
17:58:40 <andromeda-galaxy> erisco: I vaguely remember something about that
17:58:40 <andromeda-galaxy> hold on
17:58:41 <andromeda-galaxy> ...
17:59:07 <erisco> the only documentation loadAll is "This function allows you to load a dynamic list of items"
17:59:09 <RyanGlScott> xpilot: What version of GHC are you using?
17:59:31 <erisco> as I said, the only way you use Hakyll is by copying from other people's websites
17:59:37 <andromeda-galaxy> erisco: does your definition for each element of posts/* have any template applications?
17:59:53 <erisco> what is my definition for each element of posts/* ?
18:00:09 <karlfish> How can I test functions where blocks using ghci?
18:00:19 <andromeda-galaxy> erisco: yeah
18:00:58 <Nadrieril> andromeda-galaxy: where was the problem ?
18:01:09 <erisco> andromeda-galaxy, do you mean the bit that starts `match "posts/*"` ?
18:01:12 <xpilot> RyanGlScott: I'm using goldfire's dependent types branch, compiled from source
18:01:15 <andromeda-galaxy> erisco: yes
18:01:19 <erisco> those are relateD?
18:01:24 <andromeda-galaxy> Nadrieril: if you compile that, don't you get type errors?
18:01:35 <erisco> why would those be related?
18:01:40 <xpilot> RyanGlScott: I guess I can't expect much support on that
18:01:50 <andromeda-galaxy> erisco: I'm not totally sure, but if I remember correctly, the loadAll uses that definition to render the content...
18:01:59 <andromeda-galaxy> Nadrieril: the second paste I sent you?
18:02:05 <erisco> well then what if I want it rendered in different ways?
18:02:09 <RyanGlScott> xpilot: Oh. I'm not sure why it doesn't show the errors, but TH has changed a lot in GHC HEAD. I can guarantee you th-orphans doesn't compile with it yet.
18:02:33 <Nadrieril> andromeda-galaxy: didn't try to compile 
18:02:48 <xpilot> RyanGlScott: I guess I'll have to wait for an update to th-orphans then
18:02:56 <RyanGlScott> (I know GHC HEAD also requires a later version of cabal-install than what is on Hackage, so maybe that is contributing.)
18:03:10 <andromeda-galaxy> Nadrieril: ghc complains on the b = ... line
18:03:11 <xpilot> RyanGlScott: I'm using cabal HEAD
18:03:15 <Nadrieril> andromeda-galaxy: thx
18:03:28 <andromeda-galaxy> Nadrieril: thanks for looking at it
18:05:44 <xpilot> RyanGlScott: I do have an older version on TH installed
18:05:58 <xpilot> RyanGlScott: in fact th-orphans required template-haskell <2.11
18:06:24 <RyanGlScott> xpilot: Right, don't do that... GHC needs the version of template-haskell that it comes installed with to work.
18:06:29 <acertain> does anyone have a link to the typing rules of MLTT with level polymorphism?
18:06:30 <Nadrieril> andromeda-galaxy: I get a lot more type errors than that
18:06:45 * erisco sighs
18:06:47 <erisco> this is hopeless
18:07:25 <RyanGlScott> xpilot: If you really, really need to compile th-orphans now with GHC HEAD, you'll need to patch it yourself
18:07:49 <xpilot> RyanGlScott: so I guess GHC HEAD is pretty unusable until all the packages on hackage get updated
18:08:11 <andromeda-galaxy> Nadrieril: really?
18:08:19 <andromeda-galaxy> oh yeah, never mind
18:08:19 <RyanGlScott> xpilot: I wouldn't say unusable. But this release in particular made a LOT of breaking changes to Template Haskell in particular
18:08:25 <andromeda-galaxy> I think that at least some of those are caused by that one
18:08:29 <andromeda-galaxy> so that was the one I decided to work onfirst
18:08:33 <RyanGlScott> xpilot: So I wouldn't get your hopes up of installing, say, singletons with GHC HEAD :P
18:08:39 <andromeda-galaxy> erisco: are you still here?
18:08:45 <andromeda-galaxy> you need to look into snapshots...
18:08:49 <xpilot> RyanGlScott: that was exactly what I was trying to do
18:08:55 <erisco> sure, I'm here
18:09:07 <Cale> orion: More concretely, you might want to check that, for various easy functions f, if you generate a vector of uniformly distributed random values, and you map over it (\x -> (hash x, hash (f x))), then the resulting vector of pairs is statistically indistinguishable (within certain bounds) from uniformly distributed random pairs
18:09:09 <xpilot> RyanGlScott: well, with goldfire's branch at least
18:09:14 <andromeda-galaxy> erisco: take a look at https://jaspervdj.be/hakyll/tutorials/05-snapshots-feeds.html
18:09:40 <andromeda-galaxy> erisco: "This poses a problem: if we just load all posts and take their content: we get the finished, processed content.  This means all templates have been applied at that point."
18:09:48 <Cale> orion: e.g. it should be very close to uncorrelated
18:10:15 <xpilot> RyanGlScott: I guess I'll just wait form ghc 8.0. Thanks for the help!
18:10:28 <RyanGlScott> xpilot: I had a hunch when you mentioned th-orphans and goldfire. singletons is probably the most GHC-version-dependent package out there.
18:10:38 <RyanGlScott> Is there a reason you can't just install it with GHC 7.10.3?
18:11:04 <andromeda-galaxy> Nadrieril: most of the other type errors seem similarly weird to me,
18:11:06 <Cale> orion: Certainly this is something you would demand of any cryptographic hash, because if you can find an f for which such a test fails, you can use it to weaken the strength of the hash.
18:11:20 <xpilot> RyanGlScott: I can, but I wanted to try out some dependent type stuff only possible on his branch
18:11:38 <Nadrieril> andromeda-galaxy: indeed
18:11:41 <Cale> (though that in itself might be a bunch of work)
18:11:51 <erisco> I apparently already have a snapshot
18:11:53 <andromeda-galaxy> e.g. the first one: fltrFrms specifically says that (Member 'Fld1 s1 ~ True) for the first one, but GHC seems to lose this information somehow
18:11:57 <RyanGlScott> Well, at some point Richard is going to need to rewrite a LOT of singletons, since so many more things can be promoted.
18:12:02 <andromeda-galaxy> erisco: are you using it?
18:12:12 <Nadrieril> andromeda-galaxy: maybe undecidableinstances has made GHC give up on some deductions ?
18:12:21 <mgsloan> Could probably make th-orphans more resilient to change by using 'reifyManyWithoutInstances' for new versions of TH
18:12:22 <xpilot> RyanGlScott: the dependent typed stuff works, but I can't use it with singletons
18:12:27 <andromeda-galaxy> Nadrieril: that's possible...
18:12:37 <andromeda-galaxy> Nadrieril: but everything else needs UndecidableInstances...
18:12:47 <mgsloan> Couldn't do that in the past because TH couldn't generate standalone deriving instances
18:12:49 <xpilot> RyanGlScott: right, once he finishes writing dependent haskell :P
18:12:58 <erisco> I'm trying but I just keep getting errors
18:12:59 <Nadrieril> andromeda-galaxy: I'm not too confident with type-level hackery actually... you may get better answers with others here
18:13:14 <erisco> including one of the most annoying… "commitBuffer: invalid argument (invalid character)"
18:13:16 <erisco> doesn't tell you where it is
18:13:18 <RyanGlScott> xpilot: I'm not even talking about dependent Haskell. I'm talking about, say
18:13:29 <RyanGlScott> data GADT a where GADTCon :: Int -> GADT Int
18:13:30 <erisco> screw it
18:13:33 <RyanGlScott> :kind! 'GADTCon
18:13:47 <Welkin> is this a new convention?
18:13:50 <Nadrieril> andromeda-galaxy: and you should avoid undecidableinstances if you can
18:13:51 <Welkin> GADTCon?
18:13:58 <andromeda-galaxy> Nadrieril: okay, thanks for looking at it anyway!
18:14:02 <RyanGlScott> Welkin: I'm not great with names :)
18:14:04 <Nadrieril> np :)
18:14:05 <Welkin> like Comic Con?
18:14:08 <Nadrieril> good luck
18:14:12 <Welkin> a haskell convention
18:14:33 <andromeda-galaxy> erisco: you need to be using loadAllSnapshots, right?
18:14:39 <erisco> yes
18:14:58 <andromeda-galaxy> erisco: so you have a saveSnapshot before you apply the default template, and are using loadAllSnapshots?
18:15:00 <xpilot> RyanGlScott: sure, all GADTs are now promotable, which isn't exactly dependent types, but it's getting there
18:15:01 <andromeda-galaxy> and it still doesn't work?
18:15:04 <erisco> yes
18:15:10 <andromeda-galaxy> that's odd...
18:15:17 <erisco> the error is unrelated now
18:15:23 <erisco> it is this stupid commitBuffer error
18:15:36 <RyanGlScott> xpilot: Well, currently singletons doesn't know you can promote GADTs yet. Plus it uses TH extensively, so he'd need to update a lot of things...
18:15:40 <erisco> which means I have to go through my files one by one and delete characters until it magically starts working again
18:15:52 <andromeda-galaxy> erisco: oh well...
18:16:03 <andromeda-galaxy> hopefully once that is done it'll start working.
18:16:10 <erisco> no, I'm finished with it lol
18:16:17 <erisco> commitBuffer problem happens a lot
18:16:19 <erisco> wastes my time
18:16:36 <andromeda-galaxy> Nadrieril: GHC requires UndecidableInstances for the Ins' typefamily
18:16:51 <andromeda-galaxy> I don't see any way to get rid of it and keep the Okasaki red-black representation
18:16:57 <xpilot> RyanGlScott: I'm pretty sure I can translate most if not all of the coq I've ever written into haskell with goldfire's branch
18:17:09 <xpilot> RyanGlScott: not that I've written that much coq
18:18:05 <xpilot> andromeda-galaxy: I overheard that you might need some help with type-hackery?
18:18:09 <RyanGlScott> xpilot: But yeah, tl;dr Richard is busy with conference-related stuff (I think) and probably won't be working on code for a while. Unless you write a patch :)
18:18:24 <Nadrieril> andromeda-galaxy: he can't even infer that Member x Empty ~ False :/
18:18:42 <Welkin> lol andromeda-galaxy, hakyll?
18:18:47 <xpilot> RyanGlScott: haha I don't think I'd be capable of patching singletons...
18:18:58 <RyanGlScott> xpilot: Few mortals are...
18:19:06 <xpilot> RyanGlScott: well maybe if I dedicated all my time to it
18:19:39 <andromeda-galaxy> xpilot: I do indeed...
18:19:51 <xpilot> RyanGlScott: although the type theory involved in promoting GADTs might be beyond me
18:19:56 <Nadrieril> andromeda-galaxy: do you intentionnally mix False and 'False, or is there some subtility i'm not getting ?
18:20:14 <xpilot> andromeda-galaxy: can you repost that lpaste?
18:20:34 <Nadrieril> *subtelty
18:20:53 <xpilot> andromeda-galaxy: nvm I got it
18:21:11 <xpilot> andromeda-galaxy: it was this, right? http://lpaste.net/5544816729189777408
18:21:29 <andromeda-galaxy> xpilot: it was
18:21:47 <andromeda-galaxy> Nadrieril: I probably missed the ' in a few places...
18:22:19 <Nadrieril> could be a good place to start ^^
18:22:42 <xpilot> andromeda-galaxy: I'll take a look then
18:22:53 <andromeda-galaxy> xpilot: thanks!
18:27:20 <xpilot> andromeda-galaxy: are you familiar with singletons?
18:27:43 <andromeda-galaxy> xpilot: somewhat...
18:27:57 <andromeda-galaxy> .
18:28:31 <xpilot> andromeda-galaxy: it looks like it could be useful for what you're doing
18:28:35 <Crawldragon> I have a couple of newbie questions:  Is Haksell a good language to learn about functional programming (my teacher seemed to think so) and what's a good book a beginner could get?
18:28:44 <andromeda-galaxy> xpilot: how so?
18:29:06 <xpilot> andromeda-galaxy: I've often found it easier to work with singleton values than with pure type-level hackery
18:29:28 <andromeda-galaxy> xpilot: okay, I'll try rewriting it with singletons
18:29:33 <andromeda-galaxy> thanks for looking into it!
18:29:35 <xpilot> andromeda-galaxy: I'll let you know if I spot a specific case, but I suspect the Ordering stuff is a candidate
18:30:07 <andromeda-galaxy> xpilot: ah, okay --- that makes sense
18:30:51 <xpilot> andromeda-galaxy: also, should your type families be closed instead?
18:31:15 <xpilot> andromeda-galaxy: oh I see some of them are
18:31:48 <Welkin> Crawldragon: here
18:31:53 <Welkin> @where learnhaskell
18:31:53 <lambdabot> https://github.com/bitemyapp/learnhaskell
18:32:13 <andromeda-galaxy> xpilot: good suggestino, I'll try making Member closed as well...
18:32:24 <Crawldragon> Welkin: Oh, nifty.  Thanks
18:33:51 <hunteriam> @lyah
18:33:51 <lambdabot> Unknown command, try @list
18:34:06 <hunteriam> @where lyah
18:34:06 <lambdabot> http://www.learnyouahaskell.com/
18:36:43 <Crawldragon360> hunteriam:  aha.  I was looking at that one.  I'll add that to my cart.
18:36:53 <hunteriam> free online btw
18:44:03 <tnks> just curious, when looking at the definition of Free, what forgetful functor is it the left adjoint of?
18:44:56 <tnks> I thought I'd see if I could understand a hair more CT talk.
18:45:31 <tnks> (not that that's necessary to use Free)
18:49:37 <mpickering> Well, any ideas :)? 
18:50:19 <mpickering> Which categories is it between? 
18:51:28 <xpilot> andromeda-galaxy: I'm confused what your fltrFrmsBy functions are trying to do
18:51:56 <mpickering> tnks ^
18:51:56 <Welkin> oh my god
18:51:59 <Welkin> what is with the name?
18:52:11 <Welkin> why is it missing all the vowels?
18:52:46 <xpilot> andromeda-galaxy: I don't think you want to operate on lists
18:53:02 <andromeda-galaxy> xpilot: the idea is to take a list of forms with no validity information and return a list of those that are valid on a given field
18:53:39 <andromeda-galaxy> Welkin: shorthand
18:54:24 <ion> xpilot: It’s about foliature forums.
19:04:14 <xpilot> andromeda-galaxy: the where clause of fltrFrms is unnecessary
19:05:31 <xpilot> andromeda-galaxy: it looks like the intermediate type s just needs some more constraints
19:06:00 <xpilot> in order to satisfy the fltrFrmsBy constraints
19:06:21 <Twey> tnks: Well, you'd want its adjoint to go from a monad to a functor, so I guess it's the forgetful functor from the category of monads (on Hask) to the category of (endo)functors (on Hask)
19:07:08 <shachaf> There are two different ways that Free is free.
19:07:47 <shachaf> One of them is what Twey said, and the other is as a free F-algebra.
19:07:58 <shachaf> See https://www.schoolofhaskell.com/user/dolio/many-roads-to-free-monads
19:09:56 <Twey> Hm, that's nice
19:14:52 <hunteriam> whats the use of free monads?
19:20:45 <andromeda-galaxy> xpilot: I know the where clause is unnecessary, that's left over from a different experiment
19:20:53 <andromeda-galaxy> but I'm not sure what other constraints to put on the intermediate s
19:21:03 <andromeda-galaxy> the constraint that GHC is missing is already there, as far as I can tell
19:23:50 <xpilot> andromeda-galaxy: I'm pretty sure I can get it to work with some ScopedTypeVariables
19:24:02 <andromeda-galaxy> xpilot: oh, that's an idea
19:24:19 <xpilot> andromeda-galaxy: it looks like ghc is losing some constraints when variables are universally quantified
19:24:47 <andromeda-galaxy> xpilot: indeed
19:24:52 <xpilot> andromeda-galaxy: one sure way to get it to work would be wrapping the foralls in GADTs
19:25:12 <xpilot> andromeda-galaxy: ghc is notoriously bad at type inference when foralls are involved
19:25:28 <andromeda-galaxy> xpilot: ah, I didn't know that---which foralls do you think should be GADT wrapped?
19:26:05 <xpilot> andromeda-galaxy: the intermediate a
19:27:26 <andromeda-galaxy> xpilot: so a :: T with T being some GADT like data T where { T :: (the constraints) => [Form s] })?
19:28:05 <xpilot> andromeda-galaxy: exactly, although you probably want to pass s0 to T
19:29:09 <xpilot> andromeda-galaxy: btw I did add in a constraint which eliminated some of the errors
19:29:19 <andromeda-galaxy> xpilot: which constraint?
19:29:30 <xpilot> andromeda-galaxy: Member 'Fld3 s ~ Member 'Fld3 s0
19:29:31 <andromeda-galaxy> xpilot: also: how do you pass in s with a context to the GADT without DatatypeContexts?
19:29:41 <andromeda-galaxy> xpilot: on which function?
19:29:52 <andromeda-galaxy> I thought that I already had that one...
19:30:03 <andromeda-galaxy> oh never mind, I see it.
19:33:04 <xpilot> andromeda-galaxy: haha ghc just said "My brain just exploded     I can't handle pattern bindings for existential or GADT data constructors."
19:33:27 <xpilot> andromeda-galaxy: which means the GADT approach needs an extra function
19:33:34 <andromeda-galaxy> xpilot: that message is annoying, and pops up worryingly often for me
19:33:35 <andromeda-galaxy> ah,
19:34:01 <lolisa> Hi, I think a lot of link at chapter 20 at https://wiki.haskell.org/All_About_Monads is down... can anyone have a look to confirm, and where should I report if it's not my problem?
19:34:16 <andromeda-galaxy> the whole point of this exercise was to make partially valid types easier to use... maybe I should hold off on this until GHC gets better support for type level magic
19:34:35 <specialisedType> so i'm stuck on something. i have a function, let's say it's foo :: IO a -> IO a. and in some given func I call `foo` on something that returns an IO () and something that returns an IO Text
19:34:37 <specialisedType> this works fine
19:35:06 <specialisedType> but if i make `foo` an argument to my function that calls `foo`, and give the argument the type (IO a -> IO a) then i can't use the resulting variable in the same place i used foo
19:35:10 <specialisedType> what's happening here?
19:35:30 <specialisedType> (the IO a is being specialised to IO () or IO Text, depending on where i do it, and it can't marry up these two usages)
19:35:45 <andromeda-galaxy> specializedType: lpaste?
19:35:46 <andromeda-galaxy> @where paste
19:35:46 <lambdabot> Haskell pastebin: http://lpaste.net/
19:36:05 <specialisedType> andromeda-galaxy: okay i'll write a small example
19:36:38 <andromeda-galaxy> specialisedType: great
19:37:15 <andromeda-galaxy> xpilot: thanks for looking into this.  Do you know *why* GHC ends up losing the context on the variable bindings, though?  I don't understand the reason for it...
19:38:34 <specialisedType> andromeda-galaxy: http://lpaste.net/148741
19:40:43 <andromeda-galaxy> specialisedType: what is the type signature (IO a -> IO a) -> IO () with explicit foralls?
19:40:53 <andromeda-galaxy> (e.g. explicit universal quantification)
19:41:09 <specialisedType> andromeda-galaxy: ... i don't know? how do i find out such a thing?
19:42:18 <andromeda-galaxy> specialisedType: well, basically in Haskell
19:42:27 <andromeda-galaxy> all type signatures are universally quantified over free variables
19:42:31 <andromeda-galaxy> do you know what those terms mean?
19:42:47 <xpilot> andromeda-galaxy: I'm not sure. I think there's still something funny going on.
19:42:55 <specialisedType> andromeda-galaxy: not quite; i'm not sure what it means to be universally quantified
19:43:19 <andromeda-galaxy> universal quantification is the "forall" quantifier (have you ever done any first-order logic?)
19:43:21 <specialisedType> andromeda-galaxy: i mean, it's clear if i provided a `foo` that was IO Int -> IO Int that it would totally break
19:43:28 <specialisedType> andromeda-galaxy: so i can see that this shouldn't compile
19:43:45 <specialisedType> andromeda-galaxy: but i'm not sure how to fix it so that it is "easy" to pass in the foo function.
19:44:38 <andromeda-galaxy> specialisedTypeo so, with that definition, passing in that foo function is totally valid
19:44:49 <andromeda-galaxy> bar2 :: forall a. (IO a -> IO a) -> IO ()
19:45:32 <andromeda-galaxy> you can kind of think about that as bar2 is a family of functions where for any type A (e.g. Int or String), there is a version of bar2 of type (IO A -> IO A) -> IO ()
19:45:54 <andromeda-galaxy> specialisedType: so you can make a type-specialized bar2 :: (IO Int -> IO Int) -> IO ()
19:46:04 <andromeda-galaxy> specialisedType: or bar2 :: (IO String -> IO String) -> IO ()
19:46:31 <andromeda-galaxy> specialisedType: what you actually want here is a way to say "this is a function that, when given a function from IO (any type) to IO (that type) gives you an IO ()"
19:46:48 <andromeda-galaxy> specialisedType: so what is the type of foo with the explicit quantifiers?
19:46:50 <specialisedType> andromeda-galaxy: maybe i'm confused, but are you saying with the defn "forall a. (IO a -> IO a) -> IO()" it should compile as in the second example?
19:47:05 <specialisedType> because i don't get it to compile
19:47:08 <andromeda-galaxy> specialisedType: no!
19:47:12 <specialisedType> andromeda-galaxy: ah okay :)
19:47:33 <andromeda-galaxy> specialisedType: the type signature (IO a -> IO a) -> IO () is equivalent to forall a. (IO a -> IO a) -> IO ()
19:47:45 <specialisedType> andromeda-galaxy: right
19:47:52 <andromeda-galaxy> specialisedType: the forall is the universal  quantification:
19:47:56 <specialisedType> oh
19:48:11 <specialisedType> hmm
19:48:12 <andromeda-galaxy> it says that for any type that you feel like, the function can be specialised so that every 'a' in the type signature is replaced by that type
19:48:30 <andromeda-galaxy> when there is an 'a' (or any other type variable) in the signature that is 'free' --- nothing ever defines it,
19:48:57 <andromeda-galaxy> specialisedType: Haskell just assumes that you meant to stick a 'forall a.' at the beginning of your type signature
19:49:00 <specialisedType> andromeda-galaxy: so foo with explicit forall is `forall a b. IO a -> IO b`
19:49:03 <specialisedType> ?
19:49:13 <andromeda-galaxy> specialisedType: which is?
19:49:14 <specialisedType> no
19:51:07 <specialisedType> andromeda-galaxy: no i'm confused. i thin my `foo` originally was just `forall a. IO a -> IO a`
19:51:16 <andromeda-galaxy> specialisedType: exactly?
19:51:24 <andromeda-galaxy> I mean to say, exactly!
19:51:33 <andromeda-galaxy> and your bar is of type:
19:51:38 <andromeda-galaxy> ?
19:51:58 <specialisedType> andromeda-galaxy: my bar is of type `forall a. (IO a -> IO a) -> IO ()`
19:52:03 <andromeda-galaxy> exactly
19:52:08 <andromeda-galaxy> so what does that type signature mean?
19:52:13 <andromeda-galaxy> using the definition of forall that I gave above
19:52:26 <acertain> does anyone have a link to the typing rules of MLTT with universe polymorphism?
19:53:06 <andromeda-galaxy> specialisedType: ?
19:53:29 <specialisedType> andromeda-galaxy: well it should say that given ANY foo :: IO a -> IO a, then bar will compile with such a foo?
19:54:04 <andromeda-galaxy> specialisedType: exactly!
19:54:06 <acertain> or something like it
19:54:06 <andromeda-galaxy> is that what you wanted?
19:54:08 <specialisedType> andromeda-galaxy: but clearly a foo like `IO Int` is of that form. but `bar` as-written can't handle that.
19:54:31 <andromeda-galaxy> specialisedType: exactly!  so what type do you want?
19:54:42 <andromeda-galaxy> (for bar)
19:55:01 <specialisedType> andromeda-galaxy: well that's what i'm confused about. Clearly here bar requires foo to be either IO Text or IO ()
19:55:21 <andromeda-galaxy> specialisedType: right, so bar wants it's first argument
19:55:28 <andromeda-galaxy> to be of type (forall a. IO a -> IO a)
19:55:28 <andromeda-galaxy> right?
19:55:51 <specialisedType> andromeda-galaxy: that's what it's currently stating yes
19:56:04 <andromeda-galaxy> specialisedType:_no, it's not
19:56:13 <specialisedType> hmm
19:56:20 <andromeda-galaxy> specialised type: you want it to say:
19:56:35 <specialisedType> andromeda-galaxy: woah
19:56:37 <andromeda-galaxy> give me a function which, given any IO a, will give me an IO a, and then I will give you an IO ()
19:56:41 <andromeda-galaxy> what it says now:
19:56:56 <andromeda-galaxy> for any a, give m a function from IO a to IO a, and I will give you an IO ()
19:57:01 <andromeda-galaxy> specialisedType: do you see the difference?
19:57:12 <specialisedType> andromeda-galaxy: yes
19:57:18 <specialisedType> andromeda-galaxy: thank you so much!
19:57:52 <andromeda-galaxy> specialisedType: you're welcome!
19:58:06 <andromeda-galaxy> but, there's one last thing: if you write what I'm hoping you will, it probably won't compile by default
19:59:31 <andromeda-galaxy> specialisedType: by default, Haskell 98 says that explicitly writing forall is not allowed
19:59:53 <specialisedType> andromeda-galaxy: indeed, i needed to add the `RankNTypes` language extension
20:00:02 <andromeda-galaxy> specialisedType: right, RankNTypes
20:00:08 <andromeda-galaxy> specialisedType: or, in this particular case,
20:00:16 <andromeda-galaxy> specialisedType: Rank2Types will suffice
20:00:37 <specialisedType> andromeda-galaxy: nice one :)
20:00:41 <andromeda-galaxy> specialisedType: Rank2Types is part of Haskell' is 
20:00:41 <specialisedType> thanks again :)
20:00:49 <andromeda-galaxy> (so it's often a bit nicer)
20:00:56 <andromeda-galaxy> specialisedType: no problem glad to help! :)
20:04:01 <exio4> http://lpaste.net/148746 how do you continue proof_e1 in this example?
20:04:47 <andromeda-galaxy> exio4: I probably won't be able to help, but what language is that?
20:05:39 <exio4> it's just doing equational reasoning by hand
20:05:40 <Nadrieril> @paste
20:05:40 <lambdabot> Haskell pastebin: http://lpaste.net/
20:05:51 <exio4> it's not a computer-checked programming language
20:06:06 <andromeda-galaxy> exio4: ah, okay
20:06:12 <andromeda-galaxy> which statement is proof_e1 proving?
20:06:37 <exio4> map f (repeat x) = repeat (f x) 
20:07:07 <andromeda-galaxy> exio4: ah...
20:07:13 <exio4> I know it's true, I just don't know the "correct" way to do this, other than "assume it holds, show it holds for the only possible case and then finally use it"
20:07:22 <hunteriam> exio4: expand the definition of map
20:07:24 <hunteriam> then apply it
20:07:36 <exio4> hunteriam: check the paste
20:07:50 <roconnor> exio4: you have to use induction
20:07:57 <andromeda-galaxy> hunteriam: exio4 is having trouble because that would have to be done on an infinite list
20:08:01 <andromeda-galaxy> roconnor: I was just about to suggest that!
20:08:08 <hunteriam> ^
20:08:10 <exio4> even if the inductive case.. isn't smaller?
20:08:24 <hunteriam> doesnt matter how much is left
20:08:36 <exio4> the problem is that I need to assume the same thing I am proving 
20:08:41 <exio4> not something smaller?
20:08:42 <andromeda-galaxy> exio4: I believe that you should do an inductive proof starting on the one-element list,
20:08:48 <hunteriam> prove its true for a list of n if its true for n-1
20:08:51 <hunteriam> then youre fine
20:08:52 <exio4> there's no such thing as a one-element list 
20:08:55 <roconnor> exio4: oh right;  you'll probably have to use co-induction
20:08:55 <exio4> it's repeat
20:09:05 <andromeda-galaxy> exio4: oh right, never mind... sorry
20:09:14 <exio4> andromeda-galaxy: also, the base case is the empty list
20:09:19 <andromeda-galaxy> roconnor: I want to get better at equational reasoning, where's a decent explanation of co-induction
20:09:24 <hunteriam> why does it being repeat matter?
20:09:25 <andromeda-galaxy> exio4: indeed, sorry
20:09:27 <exio4> roconnor: I.. *blushes* forgot about co-induction :P
20:10:00 <hunteriam> why cant you do it for n given n-1 exio4 ?
20:10:09 <roconnor> I don't know co-induction :(
20:10:18 <andromeda-galaxy> roconnor: oh...
20:10:21 <exio4> me neither, but I didn't even remember it was thing!
20:10:38 <exio4> hunteriam: "for n given n-1"
20:10:48 <hunteriam> yea?
20:10:54 <exio4> hunteriam: fmap f (repeat x) doesn't have a base case
20:11:12 <exio4> hunteriam: and there's -1
20:11:38 <exio4> there's no *
20:11:42 <roconnor> In most logics, I'm not certain you can prove taht map f (repeat x) = repeat (f x).  you may have to settle for proving they are bisimilar
20:12:04 <hunteriam> surely you can prove theyre equal
20:12:33 <roconnor> hunteriam: if you take equal to mean something like they have the same normal form (relative to some definition of normal form) then you may be in trouble.
20:12:59 <roconnor> hunteriam: co-recursion is a tricky beast.
20:13:27 <exio4> fmap f (repeat v) => fmap f (v : repeat v) => f v : fmap f (repeat v) 
20:13:47 <exio4> the tail of this list is what we were proving, there's no n-1
20:13:50 <exio4> it's still n :)
20:14:20 <roconnor> hunteriam: it's similar to proving equality of functions.  Again proving that two functions have the same normal form is unlikely to be possible, even if they are extensionally the same.
20:14:27 <roconnor> but you can prove they are extensionally equal.
20:14:40 <roconnor> And streams are basically function from Nat to A.
20:15:03 <andromeda-galaxy> roconnor: the most difficult thing in logic is remembering what all the different types of equality mean
20:15:11 <hunteriam> people prove the equivalence of functions all the time
20:15:20 <hunteriam> kinda the whole point of most of math no?
20:15:45 <andromeda-galaxy> hunteriam: structural or extensional equality?
20:15:56 <andromeda-galaxy> i.e. do we say: these functions are the same because they are syntactically the same
20:15:58 <roconnor> we can prove that  map f (repeat x) and repeat (f x) are equivalent.
20:16:10 <andromeda-galaxy> or do we say: these functions are the same because given the same inputs, they produce the same outputs?
20:16:12 <hunteriam> how? roconnor 
20:16:18 <hunteriam> andromeda-galaxy: second one
20:16:47 <andromeda-galaxy> hunteriam: roconnor said that extensional equality is possibly; he's saying that it's hard to "prove that two functions have the same normal form"
20:16:54 <andromeda-galaxy> hunteriam: that's syntactic equality
20:17:08 <hunteriam> gotcha
20:17:09 <hunteriam> but 
20:17:10 <roconnor> Let's see, first we define two streams, s1 and s2, as being equivalent if head s1 = head s2 and tail s1 and tail s2 are equivalent (co-recursively)
20:17:16 <andromeda-galaxy> hunteriam: in an ideal logic, we would know that syntactic equality implied extensinoal, and extensional implied syntactic
20:17:25 <andromeda-galaxy> but that doesn't work for just about anything other than 1st order logic
20:17:26 <Lokathor> ghcjs cannot build on raspberry pi 2 :/
20:17:33 <Lokathor> you get an out of memory error
20:17:39 <Welkin> Lokathor: lol of course
20:17:46 <Welkin> you need 1 GB of memory to build ghc
20:17:55 <Welkin> well, at least for the base libraries
20:17:58 <andromeda-galaxy> roconnor: did I get that right?
20:17:58 <hunteriam> no way to stuff some memory in there temporarily?
20:18:11 <Welkin> oh, ghcjs
20:18:16 <Welkin> no idea about that
20:18:19 <roconnor> so head (map f (repeat x)) = ... = f x and head (repeat (f x)) = f x ... so that half is fine.
20:18:31 <roconnor> andromeda-galaxy: sounds about right.
20:18:37 <andromeda-galaxy> roconnor: great!
20:18:57 <andromeda-galaxy> roconnor, hunteriam: and soundness = syntactic equality implies extensional, and completeness = extensional implies syntactic, right?
20:19:29 <andromeda-galaxy> and Godel's incompleteness theorem essentially says that for very powerful logics we can't have both...
20:20:09 <roconnor> tail (map f (repeat x)) = tail (f x : (map f (repeat x))) = map f (repeat x)).  and tail (repeat (f x)) = repeat (f x)
20:20:12 <hunteriam> roconnor: exio4 prove that every element is f x
20:20:28 <hunteriam> roconnor: exio4 given map f (repeat x) !! n prove thats f x
20:20:38 <hunteriam> roconnor: exio4 given repeat f x !! n prove thats f x
20:20:40 <roconnor> and by our co-inductive hypothesis map f (repeat x)) is equivalent to repeat (f x)
20:20:42 <hunteriam> generically for all n
20:20:42 <roconnor> so we are done.
20:21:33 <xvvx> what's the preferred package for sampling random numbers from statistical distributions? random-fu?
20:21:41 <Lokathor> Welkin, you can build stack and cabal on rpi2
20:21:43 <roconnor> Note, we can only use our co-inductive hypthesis when proving the part about tails ... such is the restriction of co-induction.
20:21:44 <andromeda-galaxy> roconnor: that's just proving extensional equality, right?
20:21:54 <roconnor> andromeda-galaxy: bisimilarity.
20:21:55 <exio4> roconnor: makes sense, thanks
20:22:08 <Lokathor> hunteriam, i could set up a swap if i really needed to i guess. I think i can live without though
20:22:12 <andromeda-galaxy> roconnor: oh..
20:22:22 <andromeda-galaxy> can you show semantic/extensional equality from bisimilarity?
20:22:37 <roconnor> andromeda-galaxy: I not sure if bisimilary is covered by the term extensional equality.  
20:22:39 <roconnor> It probably is.
20:22:40 <hunteriam> wait why cant you just proove theyre the same at every index?
20:22:45 <hunteriam> roconnor: exio4 andromeda-galaxy 
20:22:49 <andromeda-galaxy> roconnor: ah, okay
20:22:49 <hunteriam> prove*
20:23:02 <roconnor> hunteriam: sure you can do taht.
20:23:40 <roconnor> exio4: there are a bunch of references on google when I search for "coinduction and bisimulation"
20:23:54 <roconnor> exio4: such as "Bisimulation and Coinduction for Dummies"
20:24:04 <roconnor> exio4: probably some of these references can help you.
20:24:06 <hunteriam> "and by our co-inductive hypothesis map f (repeat x)) is equivalent to repeat (f x)"
20:24:23 <hunteriam> why did you use head as the base case
20:24:26 <hunteriam> why is that valid?
20:24:40 <exio4> roconnor: I see, thanks :) 
20:24:43 <roconnor> hunteriam: there isn't a base case in co-induction ... the restriction is different.
20:24:51 <exio4> roconnor: I completely forgot about this
20:25:06 <roconnor> hunteriam: for co-induction you can only use the inductive hyptohesis "inside a guard"
20:25:15 <roconnor> taking our definition of equivalent:
20:25:23 <hunteriam> roconnor: do you have a source for this? wikipedia is lacking
20:25:28 <roconnor> "we define two streams, s1 and s2, as being equivalent if head s1 = head s2 and tail s1 and tail s2 are equivalent (co-recursively)"
20:26:15 <hunteriam> co-recursively aka the heads of those streams are also equivalent?
20:26:21 <andromeda-galaxy> roconnor: is the semantic/syntactic consequence divide in logic essentially the extensional/intensional equality divide?
20:26:25 <roconnor> Formally the defintion is like s1 ≈ s2 := head s1 = head s2 /\ tail s1 ≈ tail s2
20:26:42 <roconnor> the definition is recursive
20:26:44 <hunteriam> \/\
20:26:50 <hunteriam> "/\"?
20:26:54 <exio4> and 
20:26:55 <roconnor> head s1 = head s2 /\  (the recursive bi)
20:27:01 <roconnor>  /\  means and
20:27:06 <exio4> ∧
20:27:07 <roconnor> logical and
20:27:15 <hunteriam> ah ok
20:27:35 <hunteriam> which is equivalent to showing every element is the same
20:27:56 <roconnor> anyhow, when you want to prove this equivalence, you are only allowed to use the inductive part when proving ("the recursive bit")
20:28:14 <roconnor> You are not allowed to touch it when proving  head s1 = head s2
20:28:48 <roconnor> In a sense your use of the inductive hypothesis needs to be guared by the "head s1 = head s2 /\" part of the predicte.
20:28:51 <hunteriam> yea the proof is rather simple to show map f (repeat x) ~= repeat (f x)
20:29:47 <roconnor> Another way of seeing this is that a proof of  s1 ≈ s2 is a proof that  head s1 = head s2 /\  head (tail s1) = head (tail s2) /\ head (tail (tail s1)) = head (tail (tail s2)) /\ ...
20:30:11 <roconnor> I.e. it is an infinite stream of proofs of simple equalities.
20:30:39 <roconnor> the co-inductive restriction is in place to ensure that witness of this stream of proofs is really productive.
20:30:42 <hunteriam> you can also show every element in map f (repeat x) = f x
20:30:48 <hunteriam> and the same for repeat (f x)
20:30:52 <hunteriam> you can use induction twice
20:32:15 <andromeda-galaxy> roconnor: did you see my question about equalities/consequences?
20:32:50 <roconnor> andromeda-galaxy: hmm.  the philosophical issue surrounding equality are deep and mysterious to me.
20:33:43 <hunteriam> andromeda-galaxy: i cant think of a single example of structurally but not extionably equal statements
20:33:55 <andromeda-galaxy> roconnor: ah, ok.... there are *lots* of different types of equality/consequence/etc, and it can get confusing
20:33:57 <hunteriam> extensionally 
20:34:11 <roconnor> but yes the semantic/syntatic divided seems to be reflected in the extensional/intensional divide.
20:34:12 <Cale> I think the technical issues surrounding equality are more interesting :)
20:34:50 <roconnor> @quote McKenna
20:34:50 <lambdabot> No quotes match. Whoa.
20:34:59 <roconnor> @quote "divide"
20:35:00 <lambdabot> No quotes match. You type like i drive.
20:35:07 <andromeda-galaxy> roconnor: yay!  that means that I probably have a pretty decent (at least conceptual) understanding of those terms!  Thanks for answering all of my questions about logic.
20:39:33 <andromeda-galaxy> http://homepages.inf.ed.ac.uk/jcheney/presentations/bisim4d.pdf slide 8: someone forgot to use \mathit{} in the formulas
20:52:59 <roconnor> another point to note, we we use co-induction to prove that  map f (repeat x)  ≈  repeat (f x), the co-induction is "on" the ≈, not on the stream.
20:53:08 <roconnor> *when we use
21:01:08 <dolio> I'm not sure that isn't because all the stuff that incorporates 'coinduction' doesn't really have coinduction principles.
21:01:51 <andromeda-galaxy> dolio: what is because of that?
21:01:54 <dolio> People just define other coinductive types that they use for equivalences.
21:02:28 <andromeda-galaxy> dolio: ah, okay...
21:02:40 <dolio> That "the co-induction is 'on' the ≈."
21:03:24 <andromeda-galaxy> dolio: I see, thanks for explaining
21:26:54 <jme_> Hello! I wonder if there is a simpler way to write this line of code: \x y -> f (g x) (g y)
21:27:17 <glguy> on f g
21:27:23 <glguy> :t on
21:27:27 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:29:07 <jme_> thanks!
21:55:11 <orion> When defining free monadic actions, is it better to say, "foo :: Free DSL a" or "foo :: (MonadFree Foo m) => m a"?
21:55:24 <orion> "foo :: Free DSL a" or "foo :: (MonadFree DSL m) => m a"?
21:56:24 <exio4> orion: "better"? what'd be better for you? :)
21:57:46 <nshepperd_>  with MonadFree you can use codensity, right?
21:57:53 <nshepperd_> seems like a win to me
21:59:22 <nshepperd_> or the church-encoded free monad
22:00:02 <orion> What is the meaning of the latter?
22:00:33 <Clint> https://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Free-Church.html
22:01:08 <lpsmith> Ok, SomeAsyncException is kind of messed up.
22:01:28 <lpsmith> I mean,  I appreciate the fact that it exists,  two thumbs way up!
22:01:35 <lpsmith> But... it's just so wrong at the same time.
22:02:53 <lpsmith> So,  are the exceptions raised in the following examples synchronous or asynchronous exceptions?
22:03:09 <lpsmith> A.   throwIO ThreadKilled
22:03:36 <Adeon> where does this text come from
22:03:49 <lpsmith> B.   putStrLn ("hello " ++ error "world :-(")
22:05:02 <lpsmith> C.   throwTo threadId (ErrorCall "I'm in your thread,  causing your exceptions")
22:11:53 <jle`> orion: might as well use the second one, right?  then you can pick an implementation later
22:13:02 <orion> jle`: An implementation of Free you mean?
22:13:28 <jle`> not necessarily even Free, just any implementation you might want
22:14:24 <jle`> there are many more useful instances of MonadFree f m than just `Free f`! :O
22:14:28 <nshepperd_> orion: it was explained in "Free Monads for Less", if you're not familiar with church encoding, sort of like a CPS'd version of Free. it has a more efficient (>>=), in much the same way that difflists have a more efficient ++
22:15:07 <nshepperd_> good for you if you're doing a lot of stuff with your free monad so that performance matters
22:15:36 <shachaf> I think it's more in the way that (forall r. (a -> r -> r) -> r -> r) lists have a more efficient (++)
22:16:09 <nshepperd_> oh, I suppose so
22:17:39 <shachaf> Maybe (Codensity . Free) corresponds to difference lists.
22:24:55 <nshepperd_> huh?
22:25:15 <nshepperd_> that's ill kinded
22:44:39 <dramforever> Is this correct? Rank 2 types cannot be inferred in general. consider sts f = (f "str", f 'c'), it could have type (forall a. Show a => a -> t) -> (t, t) or (forall a. Read a => a -> t) -> (t, t), and neither is more general than the other.
22:45:33 <dramforever> I'm asking because we have a separate -XRank2Types in case we implement rank-2 inferrence
22:47:29 <KaneTW> i thought there's a inferrence algorithm for rank-2 types already (just not implemented because it's really hard)
22:48:56 <mjrosenb> is it possible to write a type-level fst?
22:49:08 <mjrosenb> e.g. fst (a,b) = a?
22:49:45 <mjrosenb> because I have SimpleType a = (HellaComplexType a, ComplexType a)
22:49:56 <mjrosenb> and I need to write out HellaComplexType
22:50:06 <mjrosenb> and if these were values, I'd /totally/ use fst
22:50:09 <exio4> I wouldn't bring type families to this
22:50:24 <mjrosenb> yeah, that sounds too complicated.
22:50:47 <mjrosenb> I don't currently have type families or the other popular type extension
22:50:59 <mjrosenb> uhh... multi parameter type classes?
22:51:11 <exio4> what?
22:51:31 <exio4> I mean, type family Fst a where Fst (a,b) = a -- here, a type-level `fst`
22:51:34 <dramforever> KaneTW: then probably it does not handle typeclasses
22:51:39 <exio4> but it's not really nice
22:52:53 <dramforever> actually, the types I said depend on the existence of the two instances, which I believe is a bad sign. 
22:56:56 <nshepperd_> it would be "unusual" for a typing judgement to depend on typeclass scope
22:59:52 <dramforever> yet is does...
22:59:56 <nshepperd_> you could type that as sts :: forall r. (forall a. a -> r) -> (r, r) but that would be awfully restrictive
23:00:01 <dramforever> yet it does...
23:02:51 <dramforever> So... Got a clue? 
23:04:28 <zoku> Roadway is bare and wet.
23:04:39 <zoku> haha sorry, bad paste there
23:08:25 <nshepperd_> the fully general type would require something like f :: (a ~ String or a ~ Char) => a -> r, where the r may or may not depend on a
23:08:54 <nshepperd_> so really, I have no idea what the proposed rank-3 inference engine does
23:09:04 <nshepperd_> er, rank-2
23:09:16 <nshepperd_> maybe it really doesn't handle typeclasses
23:09:58 <dramforever> Then it is not feasible at all to be included... 
23:10:20 <dolio> The proofs for rank-2 types certainly don't have type classes.
23:13:24 <refreshFoo> Is there a function in Haskell with type (Foo -> FilePath -> IO ()) -> (Foo -> IO ByteString) ? basically I want to be able to "write to a string in memory" instead of "write to file" (without actuallly writing to file + doing a readFIle) 
23:18:53 * hackagebot hOpenPGP 2.3 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.3 (ClintAdams)
23:18:59 <ReinH> why would it have that type?
23:21:00 <refreshFoo> so we have this function: http://hackage.haskell.org/package/cairo-0.13.0.6/docs/src/Graphics-Rendering-Cairo.html#surfaceWriteToPNG
23:21:02 <ReinH> you can't do anything with the first argument and you won't have the filepath.
23:21:06 <hunteriam> how do you guys handle Text and Lazy Text and so on
23:21:08 <ReinH> so that doesn't seem like a useful type
23:21:26 <refreshFoo> surfaceWriteToPNG , and I want to derive something which gives me Surface -> ByteString; instead of writing it out to the file system
23:21:50 <ReinH> you can't do that
23:22:13 <ReinH> IO actions are opaque. You can't look inside and see what would do.
23:23:22 <ReinH> s/what/what it
23:25:06 <Clint> hunteriam: i import them qualified
23:25:40 <ReinH> Well, you can do something with the first argument. You just can't do anything useful with it.
23:26:52 <refreshFoo> Alright, thanks.
23:27:53 <ReinH> You could do something like: silly f foo = f foo "make up a filepath and probably write to it or whatever" >> return "then ignore foo and return a meaningless bytestring"
23:28:26 <bollu> :t callCC
23:28:27 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
23:28:37 <bollu> huh, where's the foral b. ...
23:28:51 <ReinH> implied
23:28:55 <ReinH> as is the forall a.
23:29:02 <bollu> ah, I see
23:29:37 <ReinH> the way they usually are
23:34:17 <hunteriam> Is there a way to convert a lazy bytestring to a bytestring?
23:38:34 <srhb> hunteriam: toStrict
23:39:38 <c_wraith> technically you would also need concat
23:47:30 <srhb> c_wraith: You're thinking of toChunks.
23:47:49 <c_wraith> oh, is toStrict new?
23:48:04 <srhb> Newish at least. :)
23:52:07 <refreshFoo> I have a M*N uchar array stored as a ByteString. Now, I want a byte string representing the "left most" M*n part of the byte string; i.e. I'm storing an image, with M rows and n cols; but the library has "strides" each row of n chars to N chars
23:52:20 <refreshFoo> is there an ultra efficient way to do this, or do I have a bunch of take/drop/concat operations I have to deal with?
23:58:11 <c_wraith> refreshFoo: the take/drop/concat approach is basically optimal, so long as you only call concat once.
23:58:36 <c_wraith> refreshFoo: take and drop are O(1) due to slicing, and concat is careful to allocate the right size target before it begins copying.
