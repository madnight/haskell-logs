00:00:55 <ontop> jle`: Is that neat?
00:01:13 <jle`> yeah, i heard good things about that book :o
00:01:20 <hunteriam> good god is there a simple sql library for haskell
00:01:28 <MarcelineVQ> which sql
00:01:32 <hunteriam> I'm not doing enough with sql that I need to be able to write in quasi quotes and so one
00:01:35 <hunteriam> literally any
00:01:44 <hunteriam> sqlite is fine
00:01:48 <pavonia> simple-mysql
00:01:54 <hunteriam> im looking at persistent and it looks very heavy weight
00:02:15 <pavonia> Err, mysql-simple
00:02:34 <potatoe> in a more detailed paste, http://lpaste.net/148512
00:02:38 <potatoe> I've no idea how to make this happen
00:03:02 <ontop> Is SQL and stuff a pain in the ass in Haskell?
00:03:09 <ontop> It sucks a lot in Go because you actually have to write it.
00:03:10 <jle`> hunteriam: i've heard good things about http://chrisdone.com/posts/haskelldb-tutorial
00:03:16 <ontop> In Ruby you just use horrible ORMs that do it all for you.
00:03:38 <potatoe> I'm doing it now and my problems arent with with postgresql-simple but rather with my own haskell knowledge
00:06:11 <kadoban> ontop: There's a variety of ways to do it in haskell, from what I know. There's cool fancy abstractions where you write none, but you have to learn them a bit, or there's just … write SQL, and some things in between.
00:07:32 <ontop> kadoban: But is it -good-?
00:07:46 <MarcelineVQ> but will it blend
00:07:47 <ontop> Do you have to wrap it all in IO actions too?
00:07:49 <ontop> That'd be neat.
00:08:23 <kadoban> I don't do a lot of DB stuff, but I think persistent is neat as hell. I also used one of the less exciting ones where you basically write SQL and it worked fine.
00:08:32 <hunteriam> persistent exhausts me
00:08:46 <hunteriam> im happy it works but theres no chance im ever learning it
00:08:47 <ontop> y?
00:08:54 <hunteriam> its just overwhelming
00:09:00 <ontop> What about it?
00:09:09 <hunteriam> the number of language extensions you need
00:09:11 <hunteriam> and strange syntax
00:09:16 <kadoban> It's quite a bit to learn, and it uses some type hackery and TH that makes it a bit hard to figure out wtf is going on.
00:10:05 <ontop> TH?
00:10:17 <kadoban> template haskell
00:10:24 <ontop> Also, another thing that bothers me about Haskell is language extensions.
00:10:25 <ontop> Don't know why
00:10:28 <ontop> Just don't like them.
00:11:09 <hunteriam> i want them to be merged into haskell
00:11:53 <ontop> Yeah
00:11:56 <ontop> See that's the part I don't like about them
00:11:59 <ontop> If they're useful
00:12:02 <ontop> ANd we need them for things
00:12:06 <ontop> Why aren't they just part of the language?
00:12:13 <ontop> And what do you truly gain by not having them?
00:12:52 <MarcelineVQ> Clarity. When you let things take their time to get into a language it keeps the entropy rate down.
00:13:05 <potatoe> anyone knows how to get this snippet working? http://lpaste.net/148512
00:13:15 <potatoe> i'm sure its a pretty basic mistake on my part but i'm lost 
00:13:15 <MarcelineVQ> Consider the lenght of time bewteen haskell 98 and haskell 2010 reports
00:13:20 <hunteriam> ^
00:13:28 <hunteriam> i want them to become part of it but they need to really be part of it
00:13:58 <ontop> What's a haskell report?
00:14:06 <MarcelineVQ> it's the language spec
00:14:10 <ontop> Aha.
00:14:15 <MarcelineVQ> https://www.haskell.org/onlinereport/haskell2010
00:14:35 <ontop> When's the next one?
00:15:02 <MarcelineVQ> idk I've never thought to check, related link though https://prime.haskell.org
00:15:20 <hunteriam> potatoe: 1 sec
00:15:33 <hunteriam> potatoe: what error are you getting?
00:16:15 <ontop> [Somewhere in between] The Haskell 2011 committee is disbanded.
00:16:16 <ontop> lollo
00:16:19 <potatoe> hunteriam i'm trying to run a basic query with the pool using this statement
00:16:23 <potatoe> res <- withResource pool (\ x -> withTransaction x "select 1")
00:16:28 <potatoe> but I get 
00:16:29 <potatoe>     Couldn't match expected type ‘Pool Connection’
00:16:29 <potatoe>                 with actual type ‘IO (Pool Connection)’
00:17:18 <hunteriam> potatoe: what lib is withResource from?
00:17:33 <ontop> MarcelineVQ: Seems super sad https://mail.haskell.org/pipermail/haskell-prime/2015-September/003936.html
00:17:33 <potatoe> Data.Pool
00:17:37 <potatoe> https://hackage.haskell.org/package/resource-pool-0.2.0.0/docs/Data-Pool.html
00:18:29 <geekosaur> there was supposedly a push to reboot the language process a few months ago but I think it got fatally bikeshedded
00:18:43 <ontop> So the language is dead?
00:18:44 <ontop> That's promising.
00:19:03 <MarcelineVQ> That could be your takeaway, if you read basically nothing of the thing you linked.
00:19:06 <MarcelineVQ> :>
00:19:08 <geekosaur> the langage is far from dead, the ghc team is still evolving it
00:19:17 <geekosaur> there's just no formalization
00:19:24 <ontop> Aha
00:19:28 <ontop> So GHC does whatever they want
00:19:31 <ontop> And that becomes the language
00:19:34 <ontop> And there is no spec?
00:19:39 <ontop> Spec that reflects reality*
00:19:39 <jle`> the language is "GHC Haskell", heh
00:19:40 <geekosaur> and arguably no need, since ghc's competitors are also pretty much long dead
00:20:01 <ontop> No offense (although I'm sure some will be taken): That's a piss poor way to govern a language. haha
00:20:06 <hunteriam> potatoe: could you paste the full error, and the full code snippet
00:20:17 <geekosaur> I do sometimes wonder what ghc's bus number is
00:20:43 <ontop> So are there many contributors to GHC?
00:20:50 <MarcelineVQ> oh yes
00:20:58 <hunteriam> is it growing still?
00:21:05 <MarcelineVQ> Yes to that too
00:21:08 <ontop> Also
00:21:09 <hunteriam> i mean the number of contrinbutors
00:21:19 <ontop> Is Stack a full replacement of Cabal?
00:21:28 <hunteriam> its interesting
00:21:31 <earthy> ontop: now, how is that different from e.g. Java or C#? :)
00:21:40 <hunteriam> its a seperate aplication that uses the Cabal library
00:21:50 <hunteriam> cabal and stack are both front ends for the library more or less
00:21:52 <kadoban> stack is a replacement for cabal-install. It uses the Cabal library, that cabal-install also uses.
00:22:03 <ontop> earthy: I wouldn't defend their process either. Go's on the other hand is excellent.
00:22:35 <ontop> They have a documented process for language proposals. A rigid release schedule (6 months). A spec came before an implementation. And there are two fine implementations.
00:22:46 <hunteriam> disapprove of rigidity
00:23:09 <ontop> hunteriam: Things need to get out. If your feature isn't done, push the feature back, not the release is their way of doing it.
00:23:25 <potatoe> hunteriam http://lpaste.net/148513
00:23:26 <ontop> Lots of non-critical bug fixes pile up
00:23:31 <potatoe> I've the full error there also
00:23:43 <potatoe> the previous paste I linked you has the Config object
00:23:47 <ontop> Though, they've compromised for important features (like 1.5 GC for example)
00:24:21 <mgsloan> Though, really, stack doesn't use the Cabal library all that much.  The main use of the library is to compile Setup.hs files (including the default Setup.hs)
00:24:33 <mgsloan> It does use the library for parsing cabal files
00:24:33 <hunteriam> potatoe: first thing, dont believe you need to liftIO that whole expression
00:24:35 <ontop> So, I can't use Stack without Cabal?
00:24:47 <mgsloan> Correct
00:24:52 <ontop> Weird ^_^
00:24:52 <potatoe> hunteriam but if I don't liftIO the whole thing the type signature wont match to AppM right?
00:25:02 <hunteriam> oh mb yes thats right
00:25:06 <MarcelineVQ> not to be confused with cabal-install
00:25:11 <kadoban> ontop: cabal, the executable, isn't Cabal, the library. The executable is cabal-install.
00:25:24 <ontop> MarcelineVQ: Officially confused.
00:25:25 <hunteriam> potatoe: where is `asks` from
00:25:34 <ontop> http://docs.haskellstack.org/en/stable/faq.html
00:25:35 <kadoban> You can't use stack without Cabal, though you probably won't notice except you'll use .cabal files.
00:25:38 <hunteriam> ontop: cabal-install is analagous to stack
00:25:38 <ontop> This kind of explains it though.
00:25:42 <potatoe> hunteriam control.monad.reader
00:25:42 <hunteriam> ontop: Cabal is a library
00:25:52 <potatoe> since AppM has readerT
00:26:56 <hunteriam> potatoe: dbPool?
00:27:03 <potatoe> hunteriam here is where I initialize it
00:27:04 <potatoe> http://lpaste.net/148513
00:27:08 <potatoe> I updated the paste
00:27:43 <potatoe> createPool is from Data.Pool as well
00:27:47 <hunteriam> potatoe: so heres what i believe is going on here
00:27:56 <hunteriam> potatoe: dbPool is IO something
00:27:59 <ontop> Well everyone. Thanks for answering my questions, time for bed :D
00:28:09 <potatoe> but withResource needs something
00:28:11 <hunteriam> potatoe: asks dbPool wraps dbPool in another monad
00:28:13 <potatoe> not IO something, right?
00:28:23 <hunteriam> potatoe: so pool unwraps that monad and gives you IO something
00:28:36 <hunteriam> potatoe: and then when you use pool you were expected to give just something not IO something
00:28:51 <hunteriam> potatoe: so you need to get the something out somehow
00:29:06 <potatoe> yeah, either I wrap Config in IO
00:29:26 <potatoe> which is how Opaleye does it (in some example code I was show yesterday)
00:29:28 <hunteriam> potatoe: would it be incorrect to nonIOPool <- liftIO pool?
00:31:39 <potatoe> hunteriam in Config?
00:32:41 <hunteriam> potatoe: http://lpaste.net/148515
00:32:55 <hunteriam> I'd think theres a more elegant way to smush together lines 6 and 7
00:33:17 <orion> There's a problem on this page: https://www.haskell.org/ghc/download_ghc_7_10_3#sources
00:33:43 <orion> "The source tarballs provide everything necessary to build the compiler, interactive system, and a minimal set of libraries." -- The links below that text are to "ghc-7.10.3b-windows-extra-src.tar.bz2"
00:35:21 <hunteriam> potatoe: works?
00:36:22 <kadoban> orion: Yeah that doesn't look right. If you need them, they're on https://downloads.haskell.org/~ghc/7.10.3/ , I assume they're the *-src.tar.* ones
00:36:49 <potatoe> yep hunteriam, but I've some other no instance error from PG, but I will try to resolve it myself first, thanks a lot for your help!
00:37:04 <hunteriam> potatoe: cool! np
00:37:14 <MarcelineVQ> orion: hmm, duno who to contact about that, you can find what you want from the full listing here though http://downloads.haskell.org/~ghc/7.10.3
00:37:35 <MarcelineVQ> oh kadoban said that forever ago, he's good :O
00:37:41 <kadoban> ;)
01:35:08 <beepbeep_> :t length
01:35:09 <lambdabot> Foldable t => t a -> Int
01:35:24 <beepbeep_> Why does length return Int?
01:35:40 <beepbeep_> wouldn't it be much more usable if length returned a Num?
01:35:55 <kadoban> :t genericLength
01:35:57 <lambdabot> Num i => [a] -> i
01:36:02 <beepbeep_> :D
01:36:07 <beepbeep_> mkay. :P
01:36:23 <beepbeep_> so theres an alternative
01:36:32 <beepbeep_> but why does it return an Int?
01:36:35 <beepbeep_> what's the usecase?
01:38:56 <python476> anyone heard of very large graph (500K nodes at least) application in Haskell ?
01:39:14 <python476> or if Haskellers have their own way to deal with large scale graphs
01:39:31 <kadoban> beepbeep_: Some mix of historical reasons and performance reasons I think. I'm not really sure though.
01:39:59 <merijn> beepbeep_: Because anything else will likely be far slower
01:40:12 <koz_> I was looking at classy-prelude, and then core-prelude by way of this. I can see that it defines a Map type, but I'm unclear how to create instances of it - what am I missing?
01:40:31 <jle`> koz_: link?
01:40:33 <merijn> beepbeep_: Forcing it to be Int lets GHC perform better optimisation. Polymorphic length not so much, unless GHC decides to inline the whole thing
01:41:23 <kadoban> merijn: Could it be Integer instead, or would that be just as problematic?
01:41:24 <merijn> python476: It depends on what you qualify as "large scale" and what you want to do with them
01:41:24 <koz_> jle`: http://hackage.haskell.org/package/basic-prelude-0.5.0/docs/CorePrelude.html#t:Map
01:41:29 <jle`> ah i see
01:41:42 <merijn> kadoban: Integer is far slower than Int (FSOV far)
01:41:50 <merijn> kadoban: Int lets things be unboxed
01:41:57 <kadoban> Hmm, right.
01:42:06 <jle`> hm, I expect it to be the same Map type from the containers package
01:42:59 <merijn> python476: Depending on the answers the solution might be to roll your own to get it to be fast enough. A lot of libraries/out of the box solutions for graphs are dreadfully slow
01:43:36 <jle`> koz_: this one, basically http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Lazy.html  -- but it's not clear if they're using the lazy or strict variant
01:44:01 <koz_> jle`: So the classy-prelude one has these functions too?
01:44:24 <jle`> if they're the same type, then you should be able to use them
01:44:26 <jle`> hm
01:44:49 <python476> merijn: thanks
01:45:15 <jle`> it doesn't re-export the functions, it seems, so you probably have to manually import it
01:45:16 <merijn> python476: I don't mean haskell libraries specifically, btw. More like any language :)
01:45:57 <koz_> jle`: Thanks, that clears it up.
01:46:02 <python476> I have no further details, I'm just following a graph class where they mention RL structural engineering / physics cases with ~Million vertices. Far above the usual small project size (small cities map, etc)
01:46:25 <koz_> (I guess if your Map is monoidal, you can make do without it though, I *think*)
01:46:45 <jle`> not quite, you still need at least a way to create a singleton map, heh
01:46:52 <jle`> otherwise the only thing you can do is mappend mempty's
01:47:25 <jle`> hm
01:47:31 <jle`> koz_: ah, you can probably manipulate them with http://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-Containers.html
01:47:37 <jle`> which is exported in classy prelude
01:47:53 <jle`> that should actually be enough for most use cases
01:48:13 <jle`> unless you want to get really fine tuned for performance reasons
01:48:15 <koz_> jle`: Ah, I see. I'll look at that.
01:48:24 <koz_> Nah - I'm trying to get my mind around classy-prelude right now.
01:48:37 <jle`> so classy-prelude probably expects you to manipulate Map's with Data.Containers instances
01:48:40 <jle`> *methods
01:48:42 <merijn> python476: I'd say for most graph processing on "medium data" (so about 10 million-ish vertices) you're probably better of writing your own stuff to get anywhere close to good performance. Most of the frameworks (especially distributed ones...) are pretty bad. And the GUI tools all break down at like 10k+ vertices :p
01:48:45 <jle`> *typeclasses
01:48:49 <koz_> jle`: Is this because of genericity reasons?
01:49:01 <Ygg> Hello
01:49:09 <jle`> probably because of the entire "point" of classy-prelude, i guess
01:49:13 <jle`> Ygg: hi!
01:50:06 <jle`> providing Map manipulation functions as typeclass-overloaded functions instead of monomorphic functions on specific types sounds like it would align with the philosophy of something that calls itself "classy prelude"
01:50:16 <koz_> jle`: I see.
01:50:19 <koz_> Makes sense.
01:57:45 <ggVGc> what would a function a (b,c) -> a b c be called?
01:57:51 <ggVGc> i.e reverse of (,)
01:58:30 <koz_> ggVGc: I believe 'uncurry' is similar.
01:59:06 <merijn> ggVGc: That question makes no sense
01:59:15 <merijn> ggVGc: 'a' cannot have both 1 and 2 arguments
02:00:17 <ggVGc> merijn: well, I have this, and wonder what the actual name of 'f' would be, https://gist.github.com/34aeebf2c2eaf9f26211
02:00:53 <koz_> jle`: It seems that (at least based on what I've seen of mono-traversible), it uses the strict Map.
02:00:54 <jle`> ggVGc: hm yeah, that would be a kind error
02:01:10 <ggVGc> jle`: oh? but it compiles in Elm
02:01:13 <ggVGc> and it makes sense to me?
02:01:20 <jle`> the first a is inferred to be * -> *, but the second would be * -> * -> *
02:01:31 <merijn> jle`: Looks like it's supposed to be a term, not a type
02:01:42 <jle`> oh i see
02:01:48 <jle`> \a (b, c) -> a b c ?
02:01:57 <merijn> jle`: Yeah
02:01:58 <ggVGc> yes
02:02:01 <jle`> ah
02:02:02 <ggVGc> sorry if I wasn't clear
02:02:06 <merijn> :t uncurry
02:02:07 <lambdabot> (a -> b -> c) -> (a, b) -> c
02:02:09 <jle`> :t uncurry ($)
02:02:10 <lambdabot> (a -> c, a) -> c
02:02:20 <jle`> um
02:02:43 <jle`> :t \f (x, y) -> f x y
02:02:45 <lambdabot> (t -> t1 -> r) -> (t, t1) -> r
02:03:18 <jle`> :t [uncurry, (\f (x, y) -> f x y)]
02:03:20 <lambdabot> [(a -> b -> c) -> (a, b) -> c]
02:14:05 <kurt11> I'm having trouble understanding the template haskell tutorials. Any suggestions? What do the following stand for and mean: Q, runQ, AppE, LitE, VarE, LamE?
02:15:25 <frerich> kurt11: Q and runQ are probably references to 'QuasiQuoters'. AppE, LitE, VarE and LamE are values which represent elements in the parse tree of a Haskell program: (function) application expression, literal expression, variable expression and lambda expression.
02:15:45 <kurt11> ty
02:16:45 <frerich> kurt11: With Template Haskell, you write Haskell code which generates/modifies a syntax tree and then the compiler will 'splice' the textual representation of what you did into the code (where your template is used).
02:19:11 <kurt11> frerich: thank you. that makes perfect sense in the abstract. :)
02:19:31 <Fuco> I've been lisper for years and I still find template haskell confusing and highly unusable :/
02:20:17 <suppi> kurt11, have you tried this? http://www.parsonsmatt.org/2015/11/15/template_haskell.html
02:20:17 <Ygg> has anyone used bindings-fluidsynth ? 
02:20:49 <kurt11> suppi: I've tried like five others. That one looks better. thank you
02:21:10 <merijn> Fuco: Really? Can you give some example of what you'd like to do but couldn't make work?
02:21:19 <suppi> kurt11, hope it will help. (I think it is safe to skip the ruby stuff at the beginning)
02:21:29 <python476> hi Fuco
02:22:19 <Fuco> merijn: I mostly gave up fairly soon because all I saw was noise.  I'm not really complaing I guess.
02:22:20 <kurt11> can anyone give a simple explanation or good tutorial to quasiquotation? The code samples at https://wiki.haskell.org/Quasiquotation don't work. I presume they are out of date
02:22:25 <Fuco> it seems too much of a hack to me I suppose
02:22:37 <Fuco> python476: hello
02:22:39 <kurt11> I'm using a recent ghci 7.10.2.
02:23:10 <merijn> Fuco: I don't really see why, it's pretty elegant IMO, you just have very different use cases than you do with, say, lisp macros, imo
02:23:17 <suppi> let's say I have a data type: data X = A Int | B | C Int, can I using something lense like that may or may not use the inner Int?
02:23:26 <Fuco> merijn: maybe that's the problem :) I try to force lisp into it
02:23:32 <kurt11> For example, this doesn't work: [expr|1 + 3 + 5|]
02:24:01 <frerich> kurt11: I have a few smaller Template Haskell projects I did (mostly to teach myself about TH...) up at GitHub. https://github.com/frerich/random-derive is arguably the most simple one, relying mostly on the quasi quoter.
02:24:13 <merijn> kurt11: Can you define "doesn't work"?
02:24:14 <frerich> kurt11: https://github.com/frerich/smartconstructor is more complex already
02:24:28 <merijn> kurt11: What do you do, what happened, what did you expect to happen?
02:24:39 <kurt11> I get: Not in scope: ‘expr’
02:24:52 <merijn> kurt11: Well, did you define and import a quasiquoter named expr?
02:25:13 <kurt11> Also if I try to launch `ghci -XQuasiQuotes Expr/Quote` I get: "target ‘Expr/Quote’ is not a module name or a source file"
02:25:27 <merijn> kurt11: It's not something built in, expr is defined in section $
02:25:42 <merijn> kurt11: And, is there a file named Expr/Quote?
02:27:08 <kurt11> merijn: ok, gotcha, I need to setup those files. Thanks :)
02:28:51 <suppi> maybe a Maybe (Lens X Int) ?
02:30:50 <merijn> kurt11: With TH the quasiquoters/template code must always be in a different file from the files where it's used (obviously, the template code must be compiled first so it can be used to generate the code to compile)
02:33:08 <merijn> kurt11: You can see the expression quoter for Haskell by for example importing "import Language.Haskell.TH" and running "runQ [| succ 'c' |]" in ghci to see the Haskell AST that generates.
02:33:31 <merijn> kurt11: The idea behind quasiquoters is that you can also generate something OTHER than haskell ASTs using something other than haskell as input
02:39:45 <merijn> Is there a combinator the reruns an IO action until it DOESN'T throw an exception?
02:40:42 <frerich> merijn: There is http://hackage.haskell.org/package/extra-1.4.2/docs/Control-Exception-Extra.html#v:retry
02:43:51 <allenj12> how do you change the main function of a stack project, it cant find an answer no the tutorial :(
02:44:17 <srhb> allenj12: I think it's just the regular cabal change.
02:44:54 <allenj12> srhb: i havent used cabal in a long time either haha its why i stopped using haskell for a while im assuming thats in the stack.cabal
02:45:23 <kadoban> allenj12: Are you talking about changing the name of 'main' to something else?
02:45:51 <allenj12> kadoban: well for the project i just made the default main function name is "someFunc"
02:45:59 <srhb> Oh, that won't do.
02:46:08 <merijn> Haskell doesn't have main functions, it has main actions
02:46:15 <merijn> And like in C they're called "main"
02:46:22 <suppi> allenj12, you have a .cabal file in the folder, open it and change the name :)
02:47:03 <suppi> oh, i probably didn't understand the question. disregard that
02:47:09 <kadoban> allenj12: I don't believe you can change it. Just set main = someFunc somewhere, assuming the type is correct (it should be :: IO () )
02:47:15 <allenj12> I dont see it listed really i just see that Lib is the file it takes it from
02:47:18 <merijn> kadoban: Doesn't have to be :)
02:47:27 <merijn> kadoban: main can have any type that unifies with "IO a"
02:48:44 <allenj12> kadoban: that seems kinda silly dosnt it? weird i cant just change it in the .cabal but i dont see a field
02:49:19 <suppi> allenj12, why not just do main = someFunc ?
02:49:44 <allenj12> suppi: i can and probably will, just seems odd though that i would have to do that
02:50:03 <kadoban> allenj12: No idea why you'd want to change it honestly.
02:50:17 <suppi> I don't know of other programming languages that allows you to do what you want
02:51:05 <allenj12> kadoban: its definatly not a big deal :P just such a weird default name
02:51:43 <allenj12> especially since when using cabal the standard is "main" right?
02:52:45 <suppi> allenj12, your main function is not "main"?
02:53:01 <kadoban> allenj12: I'm starting to suspect I have no idea what you're talking about.
02:53:35 <allenj12> ok ok hold on let me pastebin this to be clear
02:53:52 <suppi> kadoban, as do I ;)
02:56:15 <allenj12> http://pastebin.com/kT202YUh
02:57:23 <allenj12> hopefully that helps?
02:58:33 <srhb> allenj12: Is it complaining that main isn't in Main?
02:59:01 <kadoban> One sec, my computer is dying at the moment.
02:59:08 <suppi> ok ok ok
02:59:16 <suppi> allenj12, can you post the cabal file?
02:59:20 <allenj12> srhb: this is the error i get when i try to change it to main Not in scope: ‘someFunc’
02:59:25 <suppi> I think Lib is a library
02:59:26 <allenj12> yea
03:00:09 <suppi> allenj12, did you change someFunc in the export list?
03:00:10 <allenj12> http://pastebin.com/zmnAJMSp
03:00:40 <allenj12> suppi: where is that?
03:00:40 <kadoban> allenj12: Oh, that's just an example template essentially. The Lib file is just a library. The actual main application .hs file is in the app/ subdirectory
03:00:42 <allenj12> usuallyL
03:01:00 <suppi> do you have a file app/Main.hs where in it it imports Lib and sets main = someFunc ?
03:01:10 <allenj12> o wait a minute let me see
03:01:20 <kadoban> allenj12: It's complaining because someFunc is used in there. You can just wipe out someFunc and … do whatever you want to. The 'main' is in the app/ one.
03:01:31 <allenj12> kadoban: OOOOOOOOO i see now
03:02:17 <allenj12> sorry, haha the tutorial only really talked about the Lib, i assumed thats where most everything went
03:02:52 <kadoban> Ahh :)
03:14:38 <koz_> OK, I'm a bit confused. I'm trying to use this: http://hackage.haskell.org/package/mono-traversable-0.10.0/docs/Data-Containers.html#v:singletonMap
03:15:29 <koz_> But when I tried to use it, I get this: http://paste.rel4tion.org/187
03:15:39 <koz_> I don't have *any* clue what this error message is meant to mean.
03:15:45 <koz_> Could someone please help me make sense of it?
03:18:39 <jle`> koz_: just enable FlexibleConstraints
03:18:43 <jle`> the error message suggests it :)
03:19:09 <koz_> jle`: Could you please tell me what the deal with that is? I'm a bit confused as to why it requires this.
03:19:19 <jle`> you probably also need to provide a type annotation
03:19:35 <jle`> so it'll know what it's supposed to be creating
03:19:39 <jle`> > read "5" :: Int
03:19:41 <lambdabot>  5
03:20:09 <jle`> well, you're using type families in a constraint, which is a bit beyond normal haskell
03:20:27 <koz_> Is that why it needs FlexibleConstraints?
03:20:30 <jle`> yeah
03:20:34 <koz_> Ah, right, I see.
03:20:49 <jle`> i can't pinpoint an exact location where it'd need it because so much of that type signature is outside of normal haskell, heh
03:21:11 <koz_> jle`: Ah, I see.
03:21:12 <jle`> it uses type families, ~ ...
03:21:15 <jle`> actually, hm
03:21:32 <jle`> it might actually just be the fact that you use [Char]
03:21:36 <jle`> which would be a little funny here
03:21:48 <koz_> So if I did an Int -> Int map, it'd be OK?
03:22:05 <koz_> Apparently not...
03:22:23 <jle`> singletonMap 3 "Foo" :: Map Int String should work
03:22:44 <jle`> actually it'd be funny if the only reason you needed FlexibleConstraints was because there's a constraint on [Char], heh
03:22:49 <koz_> Oh, *that* is what you meant.
03:23:04 <koz_> I thought I had to type-annotate the arguments individually, not the type of the whole expression.
03:23:10 <jle`> typically in normal Haskell, typeclass constraints have to be polymorphic over constructors, so constraining on [a] would be okay, but constraining [Char] would not be
03:23:14 <jle`> FlexibleConstraints enables this
03:23:23 <jle`> ah no, i used `read` there as an example
03:23:35 <jle`> it's polymorphic on the return type, so you have to specify what value you want your result to be
03:23:44 <jle`> > read ("5" :: String)
03:23:46 <lambdabot>  *Exception: Prelude.read: no parse
03:23:54 <jle`> > read "5" :: Int
03:23:56 <lambdabot>  5
03:23:57 <koz_> I see, I see. Thanks.
03:24:03 <mauke> > read "()"
03:24:05 <lambdabot>  ()
03:24:05 <koz_> That makes much more sense now.
03:24:06 <mauke> extended defaulting
03:24:15 <jle`> > return 5
03:24:17 <lambdabot>      No instance for (Show (m0 a0))
03:24:17 <lambdabot>        arising from a use of ‘show_M90738324468782624111589’
03:24:17 <lambdabot>      The type variables ‘m0’, ‘a0’ are ambiguous
03:24:22 <jle`> > return 5 :: Maybe Int
03:24:23 <lambdabot>  Just 5
03:24:56 <jle`> yeah, the need for FlexibleConstraints might just be because the type signature involves a constraint on [Char], where normally in vanilla haskell you're only allowed to constrain polymorphically on [a].
03:25:10 <jle`> or maybe it's the fact that you're using type families
03:25:27 <koz_> jle`: So basically, if I stick a type on it, it'll be OK?
03:25:29 <jle`> it could be a bunch of things, so much of this is outside of normal haskell, heh.  in this case generally following the error's suggestions help
03:25:47 <jle`> well, this part is unrelated to FlexibleConstraints
03:25:57 <jle`> but, haskell has to be able to infer what type you want there
03:26:05 <jle`> you don't always have to provide a type annotation
03:26:19 <jle`> normally in real code, the desired type is inferrable from your usage in other places in your code
03:26:36 <jle`> > read "5" + 6
03:26:38 <lambdabot>  11
03:26:42 <jle`> > return 5 <|> Just 9
03:26:44 <lambdabot>  Just 5
03:26:48 <koz_> Yeah - I'm trying out classy-prelude in GHCi.
03:26:50 <jle`> note that i didn't have to provide type annotations there
03:26:55 <koz_> Which is probably why I'm running into this kinda thing.
03:27:18 <jle`> well, if you're in GHCi, it should still work as long as you're on ghc 7.8+
03:27:29 <jle`> well, if you assign it to a variable/name
03:27:30 <koz_> Let me check my version one sec.
03:27:34 <koz_> Yeah - I didn't.
03:27:41 <jle`> the problem comes when you try to *print* the value
03:27:51 <koz_> Yeah - I guess Show loses its shit over that.
03:27:56 <jle`> because if you want to *print* singletonMap 3 "foo", GHC has to know what type you are printing
03:28:09 <jle`> so it has to decide on a specific instance
03:28:35 <jle`> but the error you pasted actually comes even *before* this, because `singletonMap 3 "foo"` can't even be represented as a polymorphic variable without FlexibleConstraints
03:28:50 <jle`> FlexibleConstraints is fairly widely accepted though even if you're doing the tamest of haskell type system stuff
03:28:58 <koz_> jle`: I see.
03:29:33 <jle`> if you did something like let x = 4; and then :t x, you'll get something like Num a => a, which means it's storing x as a polymorphic value
03:29:47 <koz_> Yeah - 4 could be many things, depending on context.
03:29:51 <jle`> in this case it's trying to do the same thing, but the type of the polymorphic value doesn't make any sense without FlexibleConstraints
03:30:00 <koz_> I just tried :t on singletonMap 3 "Foo" and I got... something complex.
03:30:10 <koz_> So I get what you're saying.
03:30:15 <jle`> yeah, you got the polymorphic type of it
03:30:31 <koz_> (Num (ContainerKey map), IsMap map, MapValue map ~ [Char]) => map <-- this, to be exact
03:30:33 <jle`> which relies on a bit of type mechanisms that aren't in standard Haskell
03:30:44 <jle`> which is why it asked you to turn on FlexibleContexts
03:31:03 <jle`> with FlexibleContexts on, that's now a legal typeclass constraint
03:31:17 <koz_> I see, I see.
03:31:22 <koz_> Thanks for that - very enlightening.
03:31:27 <jle`> np
03:31:39 <jle`> you might get a more readable type if you did singletonMap (3 :: Integer) "Foo"
03:31:46 <jle`> or, easy-to-understand
03:32:07 <jle`> you should get something like (IsMap map, MapValue map ~ String, ContainerKey map ~ Integer) => map
03:32:32 <jle`> which means, "the thing has the type `map`, where map is an IsMap, the value is String, and the keys are Integers"
03:32:42 <koz_> What does ~ mean here?
03:32:49 <jle`> it's type equality
03:32:58 <jle`> `MapValue map` is the type of the values in your map
03:33:08 <jle`> `ContainerKey map` is the type of the keys in your map
03:33:18 <jle`> so the constraint is that MapValue map ~ String -- the type of the values is equal to String
03:33:27 <koz_> Ah, right.
03:33:40 <koz_> I guess with classy-prelude, I'm gonna run into this kinda thing often?
03:33:40 <jle`> ContainerKey map ~ Integer means that the type of the keys is Integer
03:33:50 <jle`> this actually comes from mono-traversable
03:34:00 <jle`> because mono-traversable relies on type families to do its magic
03:34:09 <koz_> Well, near as I can tell, classy-prelude leans on it quite a bit.
03:34:31 <jle`> yeah; it's a fairly tame usage of type families though as far as type families go
03:34:35 <jstolarek> http://lpaste.net/148529
03:34:52 <jle`> you can think of `MapValue` as a type function that takes a type of a map and returns the type of the values of that map
03:34:58 <jle`> so, MapValue (Map k v) = v
03:35:02 <jstolarek> is there a monadic equivalent for the definition of foo?
03:35:04 <koz_> Ah, I see.
03:35:07 <jle`> and ContainerKey (Map k v) = k
03:35:20 <koz_> I might wanna re-read something on type families.
03:35:21 <jstolarek> by monadic I mean a situation where both ex1 and ex2 are monadic computations
03:35:25 <koz_> I suspect it'll make more sense then.
03:35:30 <koz_> (like, in the general case)
03:35:42 <koz_> jle`: Any literature on type families you can suggest?
03:35:43 <jle`> this is really the entirety of it as far as mono-traversable goes
03:36:27 <jle`> jstolarek: that should already work if ex1 and ex2 are monadic actions, right?
03:36:33 <jle`> unless you mean you want to bind the result
03:37:07 <jle`> koz_: hm, none come specifically to mind, but in particular for this use case, there isn't too much depth you can really go into
03:37:30 <koz_> jle`: So basically, just remember what you said and I should be OK?
03:37:32 <jle`> koz_: for example, `Map k v` is an instance of `IsMap`, and MapValue (Map k v) = v, and ContainerKey (Map k v) = k
03:37:46 <jstolarek> jle` : yes, I want to bind the result to foo
03:37:57 <jle`> so, if you wanted to do singletonMap (3 :: Integer) "Foo" :: Map Integer String
03:38:15 <jle`> what happens is that it requres Map Integer String to be an instance of IsMap, which it is
03:38:35 <jle`> and it requres that ContainerKey (Map Integer String) ~ Integer, which it is, because ContainerKey (Map Integer String) is Integer
03:38:42 <koz_> Yup.
03:38:54 <jle`> and it requires that MapValue (Map Integer String) ~ String, which it is, because MapValue (Map Integer String) is String
03:39:24 <koz_> So basically, that would break if I tried something like singletonMap "Foo" "Bar" :: Map Integer String right?
03:39:27 <jle`> mono-traversable basically uses type families in a sense of "associated types".  "what is the type of the value of Map Integer String"?, that kind of stuff
03:39:37 <koz_> Because then the ContainerKey constraint would fail, right?
03:39:54 <jle`> koz_: yeah, it'll break because ContainerKey (Map Integer String) is Integer, but the way you called singletonMap requires it to be String
03:39:55 <jle`> yeah
03:40:21 <koz_> Alrighty, I think I got it. Back to learning my classy-prelude.
03:40:29 <jle`> jstolarek: you could probably do multi-way ifs with foo <- 
03:40:33 <koz_> I suspect I'll spend a day being puzzled and then a month being grateful. :P
03:40:49 <koz_> s/grateful/glad
03:40:56 <jle`> hopefully! :D
03:41:16 <koz_> Thanks jle` - you are an example to all instructors everywhere.
03:41:37 <jle`> haha thanks. in truth i'm just procrastinating going to sleep v.v
03:41:52 <koz_> jle`: What do you think *I'm* up to? :P
03:42:06 <koz_> Except my procrastination involves getting my head around classy-prelude instead of helping someone do the same.
03:42:07 <jle`> :P
03:42:22 <jle`> i wonder if people actually use classy-prelude
03:43:15 <koz_> Downloads 18538 total (330 in last 30 days)
03:43:20 <koz_> I'd say so, yeah.
03:44:11 <jle`> hm i guess so then :)
03:44:30 * koz_ just realized 'classy-prelude' is a pun.
03:44:35 <koz_> It took me *far* too long.
03:44:46 <jle`> most of mono-traversable is experimental, from what I've gathered...or at least erring on the less cautious side of introducing new typeclasses
03:44:50 <jle`> koz_: hah
03:45:02 <jle`> i actually think i first thought of it backwards the first time i read it
03:45:34 <koz_> When I read 'classy-prelude' I assumed they meant 'classy' in the sense of 'having class'.
03:45:38 <koz_> Not 'based on classes'.
03:45:51 <jle`> oh heh that's how i read it initially too
03:46:13 <koz_> Yeah, it only occurred to me later that it could have that second meaning also.
03:46:19 <koz_> Very clever, classy-prelude author.
03:46:21 <jle`> "If you understand Haskell's basic typeclasses, you understand mono-traversable."; hm, i feel like they should include basic knowledge of type families as a prerequisite.
03:46:35 <jle`> considering even MonoFunctor and MonoTraversable involve type families
03:46:57 <koz_> jle`: Someone should put an issue on the guy's GitHub.
03:47:20 <jle`> well, they explain it right there in the README
03:47:26 <jle`> at least the relevant bits
03:47:41 <jle`> but i guess it might be worth mentioning in the intro description
03:48:40 <jstolarek> jle`: yup, MultiWayIf does the job :-)
03:48:55 <jle`> yay!
03:49:31 <jle`> anyways, i'm off to bed, best of luck + happy haskelling :)
03:49:37 <anagha> hello
03:50:08 <koz_> jle`: See ya, and thanks again!
03:53:40 <Fuco> MonoFunctor is a functor between Haskell and c# types?
04:06:53 <Ainieco> hello
04:07:59 <Ainieco> trying to add HasPostgres instance for my snap app but need help with typechecker, how do i resolve it - http://lpaste.net/6923066202558300160 ?
04:12:51 <lyxia> Ainieco: can you post the whole file? It's hard to figure out what all these identifiers mean
04:13:46 <Ainieco> lyxia: sure, one sec
04:14:14 <Ainieco> lyxia: here you go http://lpaste.net/6923066202558300160
04:21:53 <merijn> Man...I wish there was something like async's Concurrent that worked better with transformer stacks :\
04:25:52 <lyxia> Ainieco: Shouldn't it be HasPostgres (Handler b App)?
04:27:46 <Ainieco> lyxia: not really
04:28:43 <lyxia> Ainieco: why not, that's what I read in the docs
04:30:35 <Ainieco> lyxia: beacuse i need AuthManager App outherwise i can't use AuthManager stuff in in handlers
04:30:54 <Ainieco> and i want to use db in these handlers as well
04:31:17 <Ainieco> so it has to be Handler App (AuthManager App)
04:49:00 <gameer> hello
04:55:08 <gameer> ReinH: Are u here?
04:56:48 <gameer> I have a task, where I have to handle with sequential  2player-games with complete Informations
04:57:45 <gameer> I have a given function identifyWinner, which identifies a winner for an actual state and an actual player.(return Nothing if no one won yet)
04:58:17 <gameer> I have a function, which generates a GameTree for a game  (functionname generateGameTree
04:58:19 <gameer> )
04:59:15 <gameer> Now I have to write a function, which checks for a gameTree, if the starting Player has a winning strategy
05:00:27 <gameer> The task says, we go bottom-up and mark every node with the actual winner
05:00:41 <gameer> The type is:  Game g s => Tree (g, Player) s -> Tree (g, Player, Maybe Player) s
05:01:04 <gameer> Someone has an idea how I can solve it maybe?
05:02:43 <gameer> The generateGameTree function looks: generateGameTree :: Game g s => g -> Player -> Tree (g,Player) s
05:03:05 <Fuco> isn't it simply minmax?
05:03:23 <gameer> The task says it is like ne minimax-algorithm
05:03:50 <gameer> I have 2 example pictures, 2minutes
05:03:53 <Fuco> are you then asking about haskell or about the algorithm?
05:05:30 <Fuco> A winning strategy is such that no matter what your oponent does you will force a win.
05:05:43 <Fuco> and conversly, on your turn there is at least one move where you can go to a state where ^ holds
05:06:15 <Fuco> so you are anding and oring the states as you move up and that's pretty much all
05:06:36 <gameer> http://imgur.com/a/FBOlo
05:06:49 <gameer> The second picture is an example of an generated GameTree
05:06:57 <gameer> (for scissors,paper,rock)
05:07:33 <gameer> The the first Picture is the same how it has to look, after the analyzeGameTree functions run on it
05:07:57 <gameer> So I start at the root?
05:09:08 <gameer> hmm
05:09:27 <gameer> I understand, what a winning strategy is
05:09:39 <Fuco> well the recursion starts at the root
05:10:45 <kaiyin> how can i rewrite this do block in >>= form? https://gist.github.com/kindlychung/2f470943a2e954c2fef0
05:10:52 <kaiyin> I am stuck there.
05:11:16 <Fuco> kaiyin: move the closing paren after \a to the end
05:11:23 <Fuco> or just remove them alltogether >>= binds in a way lambda works
05:11:30 <mauke> @undo addStuff = do a <- (*2); b <- (+10); return (a+b)
05:11:30 <lambdabot> addStuff = (* 2) >>= \ a -> (+ 10) >>= \ b -> return (a + b)
05:11:36 <Fuco> the \a binding needs to cover the return as well
05:12:34 <gameer> Fuco: But if u look on my example picture, why it says at first(at the root) Just Player2 ?
05:12:48 <Fuco> gameer: because player2 can always win
05:12:52 <gameer> ah
05:13:00 <gameer> because player1 starts and player2 can always conter?
05:13:04 <Fuco> first p1 picks any of the three, and then he simply picks the one where he wins
05:13:06 <Fuco> yes
05:13:08 <gameer> okay
05:13:23 <Fuco> which is what I said above about anding and oring
05:13:56 <gameer> okay
05:13:58 <gameer> sorry
05:14:10 <Fuco> it's fine, I'm just repeating 
05:14:11 <gameer> Its a bit more difficult for me the understand it all in english :d
05:14:16 <kaiyin> Fuco: nice, thanks!
05:14:47 <gameer> Then I have only the problem to implement it in haskell
05:15:00 <Fuco> that's usually the problem :D
05:15:06 <gameer> :D
05:15:40 <gameer> I have a given function identifyWinner :: state -> Player -> Maybe Player
05:15:52 <gameer> This shoudl return for the root Just Player2 or?
05:16:20 <Fuco> I'm not quite sure why the second argument
05:17:17 <gameer> hm?
05:17:32 <Fuco> player is already encoded in the state
05:17:38 <Fuco> is it not?
05:18:13 <gameer> In the GameTree is for the root ([],Player1)
05:18:29 <gameer> the first is what is played and the second is the actuall player
05:18:46 <Fuco> yes, so why do you need to give a player again to the function?
05:19:24 <gameer> Just Player2 says, that Player2 would win in this state,or not?
05:19:33 <jonathanfrias> hello
05:19:36 <gameer> so this is what to add, or is it wrong?
05:19:57 <Fuco> who designed the data structures?
05:20:03 <Fuco> is this an assignment?
05:20:23 <Fuco> I'm confused about the types... is GameTree the 'state'?
05:21:03 <gameer> Its an task I have to solve
05:21:25 <gameer> And the pictures were given as examples, how it has to look
05:21:40 <Fuco> the first picture is the result
05:21:51 <gameer> wait a second
05:21:54 <Fuco> and the bottom picture is the game tree, which includes player in each bubble
05:22:44 <gameer> I had a first task to write a function, which creates a GameTree
05:23:03 <gameer> It had to look http://i.imgur.com/GIv9kqP.png
05:23:13 <Fuco> yes
05:23:29 <Fuco> and now you transform it into a different tree with the added winner field
05:23:31 <gameer> And now the second task is to write analyzeGameTree, and after that the tree should look like
05:23:35 <gameer> yes
05:23:52 <gameer> So it has to look like http://i.imgur.com/KNPwnMc.png
05:23:54 <jonathanfrias> Hey So I'm trying to get a list of Integer number from [1..n/2] using halfList n = [x | x <- [1..(fromIntegral (n/2))]], but it doesn't work.
05:24:13 <Fuco> so for the leaf this is trivial, and for nonleafs you will "sum" the child trees depending on who's turn it is
05:25:00 <Ankhers> jonathanfrias: Don't use `/', use `div' instead.
05:25:01 <gameer> But u understand, what I have to do? Or u need further informations?
05:25:01 <Ankhers> :t (/)
05:25:02 <lambdabot> Fractional a => a -> a -> a
05:25:36 <Fuco> I understand what you have to do
05:26:26 <Ankhers> jonathanfrias: Nevermind, I missed your use of fromIntegral. But you can get rid of that by using div instead of (/). Are you trying to divide each number in your list by 2, or only get half of the list? What does "it doesn't work" mean?
05:27:04 <Fuco> if you don't see how to do it with trees then just try it with a simple list
05:27:10 <Fuco> generalizing that will be simple
05:27:54 <suppi> anyone here interested in toy programming languages? I've made a subreddit ( https://www.reddit.com/r/ExperimentalLangs/ )
05:28:17 <jonathanfrias> Given a value of 100 I want to generate [1..50]
05:28:34 <Fuco> > 100 `div` 2
05:28:36 <lambdabot>  50
05:28:54 <Ankhers> Can't you just use [1..n `div` 2]?
05:29:02 <Fuco> > map (flip div 2) [1..20]
05:29:03 <lambdabot>  [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]
05:29:12 <Ankhers> > [1.. 100 `div` 2]
05:29:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:29:18 <Ankhers> > [1.. 10 `div` 2]
05:29:18 <gameer> Fuco: On a leaf, I can get the winner with the given function identifyWinner
05:29:20 <lambdabot>  [1,2,3,4,5]
05:29:38 <Ankhers> jonathanfrias: Do you need to use list comprehension?
05:29:52 <jonathanfrias> yeah that seems to do it.
05:30:16 <Ankhers> > [x | x <- [1..10 `div` 2]
05:30:17 <jonathanfrias> Ankhers: No, but not really sure how else.
05:30:17 <lambdabot>  <hint>:1:26:
05:30:17 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:30:25 <Ankhers> > [x | x <- [1..10 `div` 2]]
05:30:28 <lambdabot>  [1,2,3,4,5]
05:31:17 <gameer> Fuco: But I dont know how I have to sum up it for a node :/
05:32:04 <Ankhers> jonathanfrias: Just stick with [x..y] syntax for creating simple lists.
05:32:08 <lyxia> Ainieco: Have you figured it out yet?
05:33:23 <Ankhers> > take (10 `div` 2) [1..]
05:33:25 <lambdabot>  [1,2,3,4,5]
05:34:57 <Fuco> gameer: extract all the 'Maybe Player' into a list and then either check if all equal the analyzed player or at least one, depending on who's turn it is
05:35:04 <saml_> hey, how can I use regex to test string?
05:35:12 <Fuco> I'm sure there's some function in Data.Maybe for that
05:35:17 <Fuco> or use the maybe monad
05:36:03 <Ankhers> saml_: There are a number of different regex libraries. But you could also write a parser, which I believe is considered more FP.
05:36:14 <quicksilver> not really more FP. Just better.
05:36:19 <gameer> Fuco: We didn't used monads yet so i have to silve it without
05:36:24 <quicksilver> regexps are an ugly ad-hoc minilanguage :)
05:36:29 <gameer> solve*
05:36:36 <quicksilver> they're a good solution if they are entered by the user, though
05:38:18 <Ankhers> quicksilver: I have a project where I need to have users enter a regex, can you suggest a decent library to use?
05:39:00 <saml_> > "a" =~ "a" :: Bool
05:39:02 <lambdabot>      Not in scope: ‘=~’
05:39:02 <lambdabot>      Perhaps you meant one of these:
05:39:02 <lambdabot>        ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
05:39:36 <quicksilver> Ankhers: I think the regex-pcre one (is that the name?) is fine although I'm not too fond of the way =~ gets overloaded, you dont' have to use it.
05:39:38 <saml_> looks like regex libraries are all 3rd party. no builtin (to ghc)
05:40:17 <lyxia> Ainieco: from AuthManager there is no reference to the database, so you need to use withTop to access the database snaplet from the base state, I dunno how legal that is though.
05:40:24 <Ankhers> quicksilver: Thanks. I'll take a look at it.
05:44:43 <gameer> Fuco: I think I have a bit too much problem with the basic features :/
05:44:56 <gameer> I have
05:44:58 <gameer> generateGameTree :: Game g s => g -> Player -> Tree (g,Player) s
05:45:07 <gameer> Game g s => Tree (g, Player) s -> Tree (g, Player, Maybe Player) s
05:45:09 <gameer> ouh
05:45:21 <gameer> analyzeGameTree :: Game g s => Tree (g, Player) s -> Tree (g, Player, Maybe Player) s
05:45:23 <gameer> so
05:46:00 <gameer> So the functions gets g s, what are the Beginningstate and the starting player
05:46:15 <gameer> And it gets the output from my generateGameTree or?
05:46:34 <Fuco> I don't know the types are pretty confusing
05:46:51 <Fuco> but all you hav eto do is pattern match the input Tree in analyzeGameTree
05:47:07 <gameer> I have import Types
05:47:08 <gameer> import Data.List
05:47:09 <Fuco> and then do the "obvious fmap"
05:47:20 <gameer> and "Types" is with some own things
05:47:25 <Fuco> what is g, s, Why Tree has two inputs?
05:47:27 <Fuco> what are the tuples
05:48:01 <gameer> where can i upload a bit code?
05:48:48 <gameer> The inputs are beginning state and starting player
05:50:20 <gameer> http://pastebin.com/bUetBk90  This is the given Types.hs for this task
05:50:40 <gameer> Which is imported. Addinf to that Data.List is imported. No other 
05:50:44 <gameer> Adding*
05:52:50 <gameer> Hope this does not confuse you more :'D
05:58:25 <gameer> Okay, I will try it on my own and will ask preciser little questions, i think this is a bit better
06:00:05 <statusfailed> Does anyone have a PDF of the paper "Programming language semantics and closed applicative languages" by John Backus?
06:03:09 <gameer> But..i have no idea how to start 
06:04:11 <gameer> what exactly does that mean
06:04:13 <gameer> 	analyzeGameTree :: Game g s => Tree (g, Player) s -> Tree (g, Player, Maybe Player) s
06:04:28 <gameer> I saw, that I made a mistake, thought the => is a -> :/
06:05:14 <aweinstock> it's a typeclass context
06:05:19 <aweinstock> :t fmap
06:05:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:06:14 <aweinstock> it means that fmap has, for any type f that instantiates the Functor typeclass, the type (a -> b) -> f a -> f b
06:06:40 <aweinstock> so, since [] is a Functor, fmap can be used as if it had the type (a -> b) -> [a] -> [b]
06:07:02 <aweinstock> and since Maybe is a Functor, fmap can also be used as (a -> b) -> Maybe a -> Maybe b
06:08:07 <aweinstock> in your example, Game is a typeclass, with parameters g and s
06:10:27 <aweinstock> gameer: was that what you were asking?
06:10:38 <gameer> yes
06:10:39 <gameer> thanks
06:10:59 <gameer> But it doensn't helps me :(
06:11:25 <aweinstock> what are you currently trying to do?
06:11:52 <gameer> I absolutely don't know how I can start to solve my task
06:12:24 <aweinstock> part of it is generating the game tree?
06:12:50 <gameer> I have a function generateGameTree, which generates a GameTree
06:13:23 <gameer> And I have to apply an algorithm like the minimax-algorithm on it
06:14:59 <aweinstock> what are you considering as the score of a node?
06:15:48 <od--> whats the formal name for the recursion pattern captured by mapAccumL?
06:16:00 <aweinstock> :t mapAccumL
06:16:02 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
06:16:46 <gameer> aweinstock: This is an example, what I get from generateGameTree: http://i.imgur.com/GIv9kqP.png
06:16:58 <gameer> (example: scissors,paper,rock)
06:17:23 <gameer> And with the function I have to write it has to look like this: http://i.imgur.com/KNPwnMc.png
06:17:32 <gameer> So it adds on every node the winning player
06:18:37 <gameer> I have a given function identifyWinner, which calculates the winner for an actual state and an actual player. So for a leafe for example I can get with this the result
06:18:55 <gameer> (I know that I can get the result, but I have problems to implement this all..)
06:20:33 <gameer> The function has be have this type: analyzeGameTree :: Game g s => Tree (g, Player) s -> Tree (g, Player, Maybe Player) s
06:20:53 <aweinstock> do you have a Game instance for rock-paper-scissors, to test things with?
06:21:28 <gameer> I have tests, which that I can check if my function is correct
06:21:43 <gameer> with*
06:22:08 <gameer> (but only works if I have code with no incorrect things..) 
06:23:39 <osa1> "copying precompiled package" stack is so awesome
06:24:28 <gameer> aweinstock: Do you understand my problem, what I have to do?
06:25:48 <aweinstock> I don't understand why (Just Player2) is in all the nodes in the upper 2 levels in the second picture you posted
06:26:34 <aweinstock> I think I understand that the first component of the 3-tuple is the list of moves made so far, and the second component is whose turn it currently is
06:26:37 <gameer> In the root it is JustPlayer2, because Player1 starts(because that Player1 is in the node)
06:26:44 <gameer> exactly
06:26:50 <gameer> And because Player1 starts
06:26:56 <gameer> Player2 can always conter and wins
06:27:13 <gameer> So in the root the third component is Just Player 2
06:27:40 <aweinstock> the 3rd component is who the winner is, if it can be determined?
06:27:59 <gameer> (the third part is what I have to add with this function, its the actual winner)
06:28:00 <gameer> yes
06:29:12 <gameer> The first is, what is played
06:29:39 <gameer> At the leaves both players played s.th. and the third component is the Winner.
06:29:46 <aweinstock> the easiest case is if the current node has a winner, which you can check with identifyWinner
06:30:45 <aweinstock> if that's not the case, then check if any of the child nodes lead to a win for the current player, I think?
06:30:51 <suppi> can I compose something like a Maybe lens?
06:31:03 <suppi> like Maybe (Lens' s a)
06:31:09 <aweinstock> :t (^?)
06:31:11 <lambdabot> s -> Getting (First a) s a -> Maybe a
06:31:26 <gameer> At the Leaves i can get the winner with identifyWinner
06:31:26 <aweinstock> :t fmap (^.)
06:31:27 <lambdabot> Functor f => f s -> f (Getting a s a -> a)
06:31:43 <aweinstock> :t liftA2 (^.)
06:31:45 <lambdabot> Applicative f => f s -> f (Getting c s c) -> f c
06:31:58 <aweinstock> suppi: ^
06:32:19 <gameer> aweinstock: I think this is the solution
06:32:21 <suppi> aweinstock, I mean, to create a different lens of type Maybe (Lens' s a') or something
06:32:30 <suppi> aweinstock, so liftA2? I'll try that
06:32:50 <gameer> Could you help me maybe with the implementation,too? This is the difficultest part for me :/
06:33:22 <suppi> for a more concrete example: I have a Maybe (MovementComponent s)
06:33:27 <tsani> I've been learning about functor fixed points and free monads, and the basic definitions (data Fix f = Fix (f (Fix f)) ; data Free f r = Free (f (Free f r)) | Return r) look very similar. What's the connection between them ?
06:33:29 <aweinstock> suppi: (f :: Maybe (Lens' a b)) (g :: Maybe (Lens' b c)) -- you want to compose these?
06:33:37 <suppi> which are basically two lenses, on for size and one for position
06:34:06 <suppi> aweinstock, (f :: Maybe (Lens' a b)) (g :: Lens' b c)
06:34:29 <aweinstock> tsani: I think that (Free f ()) is isomorphic to (Maybe (Fix f)), but I'm not sure
06:34:31 <suppi> for example
06:35:03 <aweinstock> :t \f g -> liftA2 (.) f (pure g)
06:35:04 <lambdabot> Applicative f => f (b -> c) -> (a -> b) -> f (a -> c)
06:36:26 <aweinstock> tsani: (the thinking being that () "gets rid of" the r, and Just acts like Return, but I'm not sure how rigourous that is)
06:36:45 <aweinstock> (and there might be a subtlety that's missing)
06:36:55 <suppi> aweinstock, something like this: http://lpaste.net/148532
06:37:10 <suppi> aweinstock, ok, I'll try that
06:37:40 <suppi> it is possible that my approach is all wrong, I'm experimenting and I don't really know what I'm doing
06:38:18 <tsani> aweinstock: Hmm. The intuition I was starting to have is that in the free monad, the result type of the computation is apparent in the type, whereas in the functor fixed point it's not. I concluded that a tree of functors can represent an untyped computation but a free monad represents a typed one.
06:39:36 <suppi> :t liftA2
06:39:37 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:39:38 <tsani> And in examples I've seen of using functor fixed points to represent syntax trees that get evaluated, the result type of the evaluation seems to come out of the thin air, more or less.
06:40:10 <aweinstock> suppi: liftA2 f x y = f <$> x <*> y
06:40:22 <suppi> aweinstock, yes, was just checking :)
06:40:28 <aweinstock> (liftA1 = fmap = (<$>))
06:42:01 <Ainieco> lyxia: right, but i'm not sure how to use it in `setLocalPostgresState s = local (set (db . snapletValue) s)`
06:42:52 <Ainieco> lyxia: it's easy for `getPostgresState = withTop db get` but nut sure where to stick it in setLocalPostgresState
06:43:05 <lyxia> Ainieco: setLocalPostgresState s m = getLens >>= \authManager -> withTop db . local (set snapletValue s) . withTop' authManager $ m
06:43:57 <puregreen> I've got a small utility that uses JSON to store a bunch of values, and I want to switch to Sqlite; what library would you recommend?
06:44:30 <bartavelle> puregreen, depends on your needs, but I would start with persistent
06:44:40 <Ainieco> lyxia: this one gives http://lpaste.net/2300995429950554112
06:46:01 <puregreen> bartavelle: persistent has too many dependencies :(
06:46:55 <bollu> if I have a DSL like this
06:46:55 <bollu> https://gist.github.com/bollu/f5a8e4c779a1e039d80b
06:47:16 <bollu> then, what stops the "next" parameter from being something that's "non DSL"?
06:47:27 <bollu> I understand why we write it that way (so we can combine it with Free)
06:47:52 <bollu> but it seems like a very silly way to encode what we need (a list of DSL calls). Why not [DSL] where DSL doesn't have the "next" type parameter?
06:47:58 <bollu> I don't see the point of creating a DSL like that
06:48:16 <bollu> I'm referring to the code from line 36 onwards: https://gist.github.com/bollu/f5a8e4c779a1e039d80b#file-free-monads-hs-L36
06:48:35 <bartavelle> puregreen, I never understood this argument, but in that case hpostgresql-simple ?
06:48:37 <bartavelle> err
06:48:40 <bartavelle> postgresql-simple
06:50:37 <puregreen> bartavelle: postgresql-simple is for Postgres, not Sqlite (there's sqlite-simple which is quite similar, but I used sqlite-simple in the past and I wonder whether there's anything better)
06:50:43 <bartavelle> ohh sorry
06:50:56 <puregreen> (sqlite-simple uses strings for SQL queries, for instance)
06:51:13 <bartavelle> yes, that's why I'd use persistent
06:51:32 <bollu> guys, have help with the DSL thingie?
06:51:40 <aweinstock> suppi: the type signature you have there for sizeOf isn't a lens
06:51:47 <lyxia> Ainieco: ah. Try replacing "local (set snapletValue s)" with "local (const s)".
06:52:30 <suppi> aweinstock, I know. I don't really know how to work with it though
06:52:33 <lyxia> Ainieco: and line 33 should also use withTop
06:53:01 <aweinstock> suppi: (\obj -> (^. size) <$> (obj ^. position)) :: GameObj s -> Maybe Size -- I think this'll work, but you can't set through it, only get
06:53:22 <bartavelle> bollu, this encoding is for when you need the power of a monad, if you only need a sequential list of instructions it is indeed overkill
06:53:40 <bartavelle> if I understand your problem accurately ...
06:53:46 <suppi> aweinstock, I actually need a lens rather than a get
06:54:00 <bollu> bartavelle: we need the power of a monad "on what" ? I understand that we are using Free to construct a monad with the DSL (since the DSL admits a Functor on it)
06:54:12 <bollu> bartavelle: but it seems convoluted and silly. I'm not sure what the payoff is
06:54:13 <Ainieco> lyxia: yay, it works now, thank you!
06:54:18 <suppi> aweinstock, but I'll start from what you gave me and try to find the rest. thanks!
06:54:22 <bartavelle> bollu, the payoff is that you get a monad :)
06:54:24 <bollu> bartavelle: is the only reason we do this is for "good do-notation"?
06:54:24 <tsani> bollu: If you just use a list of instructions, then you can't make later actions depends on the results of earlier ones for instance.
06:54:50 <tsani> But because the monad instance gives you >>=, you can do this
06:54:51 <lyxia> Ainieco: yw
06:54:53 <mnoonan> or rather, you can't make the *choice* of later actions depend on the earlier ones
06:54:55 <bollu> tsani: I can `traverse` on the list 
06:55:09 <bollu> tsani: I can have something like DSL -> Maybe Output or something
06:55:50 <bollu> bartavelle: aren't we mixing the DSL representation and evaluation when we say that we can choose later actions depending on earlier ones?
06:56:06 <bollu> like, the choice crops up when we *evaluate*, right?
06:56:24 <bollu> I'm not sure if I'm making sense
06:56:27 <bartavelle> bollu, depends on what you mean by DSL! It seems that for you it only represents the individual building blocks
06:56:39 <bartavelle> but how they combine together is part of the DSL
06:56:46 <bollu> bartavelle: oh, I see!
06:56:57 <bollu> bartavelle: huh, that's a neat way to argue about it
06:57:14 <bollu> bartavelle: okay, so the monad on the DSL lets me capture how actions combine as well?
06:57:17 <bartavelle> heh, you can have DSI, domain specific instructions ;)
06:57:40 <bartavelle> bollu, precisely, it means you can use all the monad machinery (including the do notation) and combinators
06:58:11 <bollu> hmm
06:58:26 <bollu> bartavelle: so if I have a completely "linear" DSL then I don't need the monad machinery?
06:58:40 <bollu> also, to construct the machinery, I need *both* the DSL *and* the free monad right
06:58:41 <bollu> ?
06:58:43 <bartavelle> if by linear you mean a fixed series of instructions, then no
06:58:46 <bollu> I can't have a Monad DSL
06:58:55 <bollu> bartavelle: yes, I mean fixed series.
06:59:05 <bartavelle> if you need to have your computation depend on the result of previous computation, then the free monad is useful
06:59:39 <bartavelle> I mean, the structure of the computation depending on the result of previous stuff (I guess, I am not really knowledgeable about theory)
07:00:04 <bitemyapp> Cale: do appreciate you having taken the time btw
07:00:21 <bollu> bartavelle: yeah, so my question was, do define a monad on the DSL, I never use the DSL *explicity* right? I always use Monad instance on "Free DSL <whatever>" and *not* write a Monad instance on DSL itself?
07:00:36 <bartavelle> yes
07:00:42 <bitemyapp> Cale: the general inclination toward equational presentation is something we took to heart and still use later in the book (we use it in the monad transformers chapter that is coming soon, for example)
07:01:12 <bollu> bartavelle: is it because DSL doesn't have enough structure to write a Monad for?
07:01:16 <bartavelle> bollu, I mean, you certainly *can* write a monad instance, Free is there to save you work
07:01:23 <bollu> bartavelle: ah
07:01:26 <bartavelle> bollu, depends on the DSL
07:01:35 <bartavelle> bollu, usually with the Free monad approach you just write a functor
07:01:48 <bollu> bartavelle: example of a DSL that already has a Monad instance on it without invoking Free?
07:01:51 <bartavelle> bollu, if you use the operational package, you don't even need a functor
07:02:04 <bollu> bartavelle: ?
07:03:20 <roelof> Hello, I have made some functions to add something to a map, delete from a map and display.  Is there a small web platform so I can make it run so the user can choose what he/she wants ? 
07:03:38 <bollu> bartavelle: what does the package giev you?
07:04:04 <bartavelle> bollu, I find it easier to use
07:05:19 <bartavelle> bollu, but if you only have a list of instructions that need to be executed in order, don't worry about all of this
07:06:04 <bollu> bartavelle: I'm trying to grok Free :)
07:06:10 <bollu> bartavelle: so this is just playing aound
07:06:19 <bollu> bartavelle: but thanks for the pointer!
07:06:42 <bartavelle> np
07:11:06 <bartavelle> roelof, if you mean a web application that can be directly used, you will probably have to write quite a bit of code first
07:11:21 <bartavelle> I mean, more code than what you wrote for your functions
07:13:07 <roelof> oke, I have the functions already, I can make a main function but that one will be big with a sort of menu and depending on the choices some questions 
07:13:35 <roelof> that is why im thinking of a web app so every choice can be a seperate choice 
07:19:41 <albeit> If I have as :: [a] and bs :: [Bool] of the same length, and the second list is a list of the valid items, is there a better way to filter the first list then "map snd . filter fst $ zip bs as"?
07:20:40 <mauke> [ x | (x, True) <- zip as bs ]
07:22:12 <albeit> Hmm could do that... but doesn't seem too much better...
07:24:44 <mauke> [ x | x <- as | True <- bs ]
07:25:50 <oisdk_> albeit trace bs xs = catMaybes $ zipWith (($>) . guard) bs xs
07:26:04 <oisdk_> which is not better at all, I now realise...
07:30:12 <gameer> Quick question, I want to patternmatch on datatypes with guard, and I ant to give the different "constructors" of the datatypes variables so that I can work with them of that makes sense. Here is a example of one of the guards:
07:30:31 <gameer> | t == (HD1 (int, p, tree)) = int : (getTreeValues p tree)
07:31:12 <gameer> My problem is that the compiler tells me that "int, p, and tree are not in scope". I just want to name the variables like that, how would I do that?
07:32:27 <frerich> gameer: In your example, you don't seem to use 't' in the definition but in general, maybe 'as-patterns' are what you want? E.g. something like 'f t@(HD1 p tree) = <do something with t, p and tree>'.
07:33:00 <gameer> t is a parameter of my function
07:33:12 <gameer> getTreeValues p t 
07:34:04 <mauke> getTreeValues p (HD1 (int, p', tree)) | p == p' =
07:34:57 <puregreen> where does callCommand (from process) take $PATH from? it's different from the PATH I get in terminal
07:38:14 <gameer> thanks mauke, will try that
07:43:06 <bollu> what's the best way to distribute turtle scripts?
07:43:18 <bollu> "best" in the sense of simplest for the end user
07:43:31 <bollu> is there anyway to generate binaries for all platforms?
07:44:55 <gameer> I want to pattern match on the case that my p as a function parameter is the same as the p in the data structure. Compiler tells me I have conflicting definitions for "p". How could I solve this while keeping the functionality?
07:45:09 <gameer> getTreeValues p (HD1 (int, p, tree)) = int : (getTreeValues p tree)
07:45:25 <troydm> do I understand it right, seq function forces it's first expression's thunk to be evaluated to WHNF?
07:45:29 <bartavelle> getTreeValues p1 (HD1 (int, p2, tree) | p1 == p2 = int : ...
07:45:43 <mauke> gameer: I just told you
07:45:55 <wedens> where can I read about where to use INLINE and INLINEABLE pragmas?
07:46:01 <bartavelle> oh yeah, what mauke said :)
07:46:19 <gameer> My bad, thank you guys!
07:46:30 <mauke> troydm: seq intertwines the fates of its two arguments. forcing the result of seq forces both arguments to WHNF
07:46:45 * hackagebot alsa-mixer 0.2.0.3 - Bindings to the ALSA simple mixer API.  https://hackage.haskell.org/package/alsa-mixer-0.2.0.3 (ThomasTuegel)
07:46:48 * hackagebot hackage-security 0.5.0.0 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.5.0.0 (EdskoDeVries)
07:47:05 <bollu> guys, what's the nicest way to distribute a tool written in Haskell?
07:47:18 <bollu> assuming the person has cabal installed, then it's a `cabal install` away
07:47:18 <bitemyapp> bollu: look at what pandoc does
07:47:22 <bollu> but otherwise?
07:47:26 <bollu> bitemyapp: oh thanks!
07:47:55 <bollu> bitemyapp: do you know how they generate / create the package installers?
07:48:22 <bartavelle> bollu, I think there is an army of packagers behind pandoc ...
07:48:41 <bollu> bartavelle: :( I was hoping for a simple way to package my haskell app
07:48:56 <bartavelle> it is simple if you only target a handful of targets
07:49:04 <bollu> bartavelle: eg: python has PyInstaller
07:49:14 <mpiechotka> @pl \c -> wm m (\m' -> i c m')
07:49:14 <lambdabot> wm m . i
07:49:15 <bartavelle> yeah well, haskell has cabal ;)
07:49:21 <bartavelle> (and stack!)
07:49:32 <bollu> bartavelle: okay, assuming the "smallest" number of targets? (Mac os X, Debian and Windows)
07:49:55 <bollu> bartavelle: true, but you can't assume everyone has cabal :) (unlike say, Python)
07:50:02 <bartavelle> well for debian there are simplified package builders
07:50:30 <bollu> bartavelle: and for other platforms?
07:51:19 <bartavelle> I don't know anything about macos, and there is the nullsoft one that seems popular on windows (don't know much about the subject)
07:51:42 <bollu> bartavelle: thanks for the help
07:51:47 <bollu> does anyone else know?
07:52:00 * hackagebot hackage-security-HTTP 0.1.1 - Hackage security bindings against the HTTP library  https://hackage.haskell.org/package/hackage-security-HTTP-0.1.1 (EdskoDeVries)
07:52:02 * hackagebot hackage-repo-tool 0.1.1 - Utility to manage secure file-based package repositories  https://hackage.haskell.org/package/hackage-repo-tool-0.1.1 (EdskoDeVries)
07:52:12 <Zekka|Sigfig> What was the original question? How to package a Haskell program for other people’s computers on multiple platforms?
07:52:50 <bollu> Zekka|Sigfig: yes
07:53:14 <Zekka|Sigfig> I only know how to handle the trivial case (you wrote an ordinary Haskell program with no dynamically-linked C dependencies)
07:53:16 <bollu> Zekka|Sigfig: I've written this:https://github.com/bollu/teleport (my first proper useful haskell tool)
07:53:25 <Zekka|Sigfig> Peeking
07:53:35 <bollu> Zekka|Sigfig: it is that yes, but the tool does depend on aeson and stuff
07:54:17 <Zekka|Sigfig> “A lightning-fast tool to quickly switch between repositories” this sounds more like a sandboxing tool than a deployment tool, am I misunderstanding?
07:54:35 <bartavelle> bollu, pure haskell dependencies won't hurt you, it's all in the binary
07:54:36 <bollu> Zekka|Sigfig: it's more of a "more-around-the-filesystem" thing
07:54:43 <bollu> I got tired of maintaining symlinks and stuff
07:54:52 <bollu> so I wrote a tool that lets me move around the file syste
07:54:55 <bollu> file system*
07:55:06 <bollu> it's silly :) But I really wanted to use haskell
07:56:40 <maerwald> symlinks are a plague
07:56:44 <Zekka|Sigfig> FWIW, afaik re Haskell deployment, an ordinary Haskell binary is statically-lnked against everything it depends on that it’s not forced to dynamically link against
07:57:15 <bollu> Zekka|Sigfig: okay, so the solution is?
07:57:42 <srhb> Zekka|Sigfig: Isn't thjat a bit misleading? More like "statically linked against every other Haskell library, dynamically to everything else" ? 
07:57:53 <Zekka|Sigfig> you should be sure to get the real story from someone else but I think this means deployment on multiple platforms ranges from trivial (build a binary, package needed files with it, then send around an archive with that binary in it) to about-as-hard-as-C (distribute source code, or find a way to package shared objects with it)
07:58:09 <Zekka|Sigfig> srhb: Can’t it statically link against C in some cases? I definitely know it statically links against Haskell libraries.
07:58:15 <srhb> Oh, it can.
07:58:17 <srhb> It's just not the default.
07:58:41 <bollu> Zekka|Sigfig: okay, like, is there an easy way to build the binaries for the platforms I'm interested in?
07:58:47 <Zekka|Sigfig> I was more thinking of cases like “your program uses Curses and is linked against your installation’s preinstalled version of curses"
07:59:25 <Zekka|Sigfig> bollu: I’ve never had to do cross-compilation — according to the wiki it’s possible but I don’t know how
07:59:42 <bollu> Zekka|Sigfig: oh :( well, this should be fun to figure out then 
08:00:10 <Zekka|Sigfig> It looks like you might need multiple GHC installations. Maybe stack can be made to manage them for you?
08:00:19 <Zekka|Sigfig> (I’ve never used Stack and I don’t have a realistic picture of what it does)
08:00:53 <bollu> Zekka|Sigfig: I'll have to look into that :)
08:00:57 <srhb> bollu: Usually, virtual machine the target environment and build it there, statically linking as much as possible.
08:01:00 <Zekka|Sigfig> I’m running my mouth here because I know if I say something direly wrong, people who actually know how GHC works will jump in and tell me I’m a dope
08:01:04 <srhb> Cross compilation isn't mature at all here.
08:01:25 <Zekka|Sigfig> and those people can probably help you
08:01:58 <bollu> srhb: ;_; you can't even run a VM for Mac OS.
08:02:10 <bollu> srhb: so if I had a linux computer I'm boned?
08:02:25 <Zekka|Sigfig> Aw, this makes me really sad
08:02:41 <bollu> Zekka|Sigfig: Sad because?
08:02:51 <Zekka|Sigfig> Because it would be nice if deployment was easy
08:03:08 <Zekka|Sigfig> I’ve only had to deploy Haskell programs in binary form on an OS I don’t run once
08:03:27 <bollu> yeah it would
08:03:32 <srhb> Deployment is easy as long as you only target other developers. :-)
08:03:35 <Zekka|Sigfig> and my procedure was just to copy all my source code over, compile it, and then email it to my weird friends
08:03:43 <bollu> srhb: so, well, what do you do if you have to deploy on Mac OS or something?
08:03:57 <srhb> bollu: Build it on a Mac.
08:04:03 <Zekka|Sigfig> Maybe we should look into distributing scripts that bootstrap intsalling cabal, then your program
08:04:24 <srhb> Zekka|Sigfig: Would be easier with Stack. Way easier.
08:04:25 <Zekka|Sigfig> Haskell binaries are already huge, who cares about an extra gigabyte or two on GHC and Cabal dependencies?
08:04:33 <srhb> Zekka|Sigfig: (It downloads the relevant ghc for you.)
08:04:44 <bollu> srhb: yeah, so you're boned without it right?
08:04:55 <bollu> srhb: oh, I'm using stack. how would that simplify life?
08:05:15 <srhb> bollu: As in, they only need to run stack install in the source directory, afaik.
08:05:22 <Zekka|Sigfig> I think he means it would be easier to write a script that bootstraps installing stack, then compiling your program
08:05:31 <srhb> Zekka|Sigfig: Not a he, but yes.
08:05:35 <Zekka|Sigfig> because stack already does a few of the steps my hypothetical bootstrap script would have to do.
08:05:44 <srhb> That's correct.
08:05:48 <Zekka|Sigfig> Oh. This might be a silly question, but do you prefer “she”?
08:05:55 <bollu> oh yeah
08:06:00 <srhb> Zekka|Sigfig: I prefer not being assumed male, but yes :-)
08:06:16 <Zekka|Sigfig> Sorry about that, I’ll try to remember in future.
08:06:40 <srhb> bollu: Of course, they would still need Stack installed.
08:07:04 <bollu> srhb: yeah, so if I want someone to install it on a haskell-less system, they would first need to install cabal and then do a cabal install best I can see
08:07:15 <bollu> how large is cabal? ~20 MB?
08:07:23 <bollu> oh but it needs to pull in GHC as well
08:07:28 <Zekka|Sigfig> I don’t remember how large it is, but GHC is a lot bigger
08:07:35 <bollu> aww man
08:07:36 <srhb> bollu: That's the case, indeed.
08:07:38 <dcoutts> bollu, srhb: you know you can make binaries if you have some knowledge about the target system
08:07:39 <bollu> this is a buzzkill
08:07:43 <srhb> Perhaps there are build services out there you can benefit from.
08:07:50 <bollu> dcoutts: how so?
08:07:59 <srhb> dcoutts: Sure, it's just cumbersome :)
08:08:09 <dcoutts> bollu: build it, grab the output, zip it up
08:08:18 <Zekka|Sigfig> Fortunately disk space is cheap! If people really like your program they’ll be willing to designate a few hundred megabytes to holding onto it
08:08:28 <Zekka|Sigfig> dedicate*
08:08:37 <dcoutts> bollu: cabal configure --prefix=$whatever; cabal build; cabal copy --destdir=$imagedir
08:08:41 <bollu> Zekka|Sigfig: I very much doubt that :P if it were a few megs I can believe that, but the tool is silly
08:08:48 <sm> bollu: 1. get it into stackage 2. work with packagers (linux distros, homebrew, ... ?) to get it into their distros 3. for anything not yet covered by 2, build and support your own binaries (using native machines, vms, cloud CI services or contributors)
08:09:05 <bollu> sm: okay, how do I get it into stackage?
08:09:08 <Zekka|Sigfig> Someday everyone in the world is going to use my ls implementation that only takes 300 mb of hard disk space
08:09:24 <bollu> Zekka|Sigfig: if you're not kidding, I'm curious 
08:09:29 <Zekka|Sigfig> I’m kidding.
08:09:30 <sm> I forgot: 0. get it onto hackage
08:09:47 <bollu> sm: it is in hackage which is why you can cabal install it
08:10:26 <bollu> okay, so, how does one get a package into stackage?
08:10:38 <sm> great. Then make sure it builds nicely with stackage nightly, and submit a pull request to the stackage config file and wait for it to be added
08:10:46 <bollu> ooh, it's that easy?
08:10:57 <bollu> sm: how do I check it builds properly with stackage ?
08:11:12 <sm> should be, at least if it's pure haskell. stackage docs tell more
08:11:25 <bollu> sm: yep, it is pure haskell
08:12:22 <sm> cd myproj; stack init ...; stack --resolver nightly build, I think
08:12:40 <bollu> sm: ok, ty
08:12:55 <bollu> sm: "using nightly stackage" means what exactly? It uses the nightly GHC build?
08:13:45 <sm> it uses recent versions of hackage packages (unlike lts stackage, which is updated less often)
08:13:56 <bollu> okay, cool. Thanks a ton
08:15:11 <sm> 1.5 add more docs to readme, otherwise packagers won't be interested
08:15:20 <bollu> yes I will
08:15:31 <sm> good luck
08:16:47 <bollu> thank you for all the help :)
08:17:42 <Ygg> why is it telling me that System.Console.ANSI could not be found ;_;
08:17:45 <sm> np
08:23:03 <Ankhers> Ygg: Do you have the ansi-terminal package installed?
08:25:02 <suppi> how do I reference a locally installed repo as a dependency to a different project in stack?
08:25:34 <Ygg> No, I didn't. I just fetched the package 
08:25:38 <Ygg> Thanks Ankhers
08:28:44 <Ankhers> suppi: locally installed repo, as in a git/hg/something repo cloned onto your machine?
08:29:15 <suppi> Ankhers, a git repo cloned and built onto my machine
08:29:56 <Ankhers> suppi: I'm unsure if you can use a file location, because they may be different for anyone that tries to build your project. You can, however, specify where the repo is and have stack build from that.
08:30:03 <luigy> suppi if it has not changes than upstream there might be more convenient ways than cloning, but this explains all aproaches http://docs.haskellstack.org/en/stable/yaml_configuration.html#packages
08:30:30 <suppi> I just want it for my machine :)
08:30:49 <suppi> thanks, both of you.
08:31:13 <Ankhers> You may be able to specify an absolute path as a local package.
08:31:51 <Ankhers> Similar to how you can use stack for "mega-repos". Instead of specifying a directory under the stack file, try an absolute path to the directory you want to build.
08:32:04 <Ankhers> suppi: ^^
08:32:11 <Ankhers> I have no idea if that actually works though.
08:32:27 <bollu> if I have a script that I need someone to source, how do I make sure it works across shells?
08:32:50 <bollu> (the haskell tool I has needs a shell-function wrapper to change working directories)
08:34:14 <suppi> Ankhers, something's happening, so I guess that works.
08:34:38 <Ankhers> suppi: Nice.
08:34:53 <suppi> just: packages:
08:34:55 <suppi> - some-directory
08:36:26 <glittershark> bollu: you test it a lot
08:37:04 <bollu> glittershark: xD
08:39:58 <diphtherial> hey, i'm a little confused about what environment i should be using (i'm on OS X yosemite fwiw); i was using the haskell platform earlier, but ran into issues installing gloss (a graphics/animation package), so i switched to stack
08:40:21 <diphtherial> it's been about a month since i attempted to do anything with stack...perhaps i should read over the docs again to refresh my memory
08:41:04 <recursion-ninja> I know that there is a HAskell tool that allows you to pass in source sode and have certain comment lines prefixed with ">>>" interpreted and checked against the next comment line. Does anyone know hwat this tool is called?
08:41:30 <kadoban> recursion-ninja: Talking about doctest?
08:41:36 <recursion-ninja> perhaps
08:41:50 <aweinstock> haskell has doctest too? I thought that was a python thing
08:41:51 <realyogsototh> diphtherial: I use stack and it is a great experience for me on Mac. stack upgrade && stack setup and you should be ok to start
08:42:31 <recursion-ninja> @kadoban, Yep `doctest` is the package. Thanks!!!
08:42:31 <lambdabot> Unknown command, try @list
08:43:46 <diphtherial> realyogsototh: noted, thanks :) i'll give it another try
08:45:04 <kadoban> aweinstock: I think it was inspired by python's possibly. Or I made that up.
08:46:01 <glittershark> Haskell is nothing if not a language known for lovingly stealing features from other languages
08:46:15 <glittershark> but in a nice way
08:46:15 <aweinstock> kadoban: the hackage description says it's "modeled after doctest for Python"
08:46:28 <kadoban> :)
08:46:50 <aweinstock> glittershark: my understanding is that Haskell had list comprehensions before Python did ;)
08:48:18 <glittershark> aweinstock: I wouldn't be surprised
08:49:59 <padre_angolano> afair python docs explicitly mention the fact that list comprehensions were taken from haskell
08:50:38 <frerich> https://wiki.python.org/moin/PythonVsHaskell says "Python's list comprehension syntax is taken (with trivial keyword/symbol modifications) directly from Haskell. The idea was just too good to pass up.", indeed.
08:54:11 <Fuco> funny... I quite dislike comprehension 
08:56:10 <diphtherial> Fuco: for any particular reason?
08:56:31 <diphtherial> i could understand disliking having to remember its peculiar syntax, but personally comprehensions feel natural to me
08:57:28 <suppi> I never use comprehensions
08:57:32 <diphtherial> like, i can often phrase my problems as building a list of elements that meet certain conditions
08:57:39 <blub> i think map and filter reads better most of the time
08:57:59 <glittershark> I'm with blub on this one tbh
08:58:22 <glittershark> I only end up using comprehensions when I have to do pattern matching on elements of a list
08:58:28 <diphtherial> fair; i guess makes sense to prefer less syntactic sugar
08:58:36 <suppi> it's a nice feature, I just don't find it very useful because it does not resemble most of my Haskell code
08:58:46 <Fuco> diphtherial: I very rarely need it, and indeed it seems quite out of place
08:58:55 <glittershark> I think the only list comprehension I have in my codebase right now is a `[(a, Maybe b)] -> [(a,b)]`
08:59:05 <diphtherial> it's probably because i'm coming to haskell from python, and i'm still a haskell newbie to boot
09:00:06 <suppi> many people start using haskell for solving project euler problems, I guess list comprehensions are more useful there
09:00:13 <Fuco> yea pattern matching is nice, you can do e.g. Just x <- maybeXs and it works... with filter it's a bit more cumbersome
09:00:17 <deni> the directory package uses a type FilePath which just a synonim for String and the system-filepath package uses and internal type also named FilePath which is not a String... :/
09:00:25 <Fuco> well, without using Data.Maybe anyway :P
09:00:28 <suppi> but I never seem to need it for other things
09:00:40 <deni> is there some other package other then directory to use that is in line with system-filepath?
09:01:43 <deni> os what is the proper way to handle this? other then doing encodeString and decodeString all over the place?
09:01:48 <deni> s/os/or/
09:10:00 <deni> this might be normal for all i know...I'm just not used to "converting" all the time. So an acceptable answer is..."Deni, this is normal stop fighting the types" :D
09:11:25 <glittershark> what are you trying to do with directory?
09:12:02 * hackagebot Plot-ho-matic 0.8.0.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.8.0.0 (GregHorn)
09:15:35 <mpiechotka> @pl \x -> f (g x y z)
09:15:36 <lambdabot> f . flip (flip g y) z
09:17:03 * hackagebot nanq 1.1.0 - Performs "W (National Kanji Exam) level analysis on given Kanji.  https://hackage.haskell.org/package/nanq-1.1.0 (fosskers)
09:17:41 <deni> glittershark: I'm just listing the files in a specific directory and then doing something with them
09:20:01 <deni> glittershark: I notice now that there's also filepath (vs system-filepath)
09:26:38 <Gurkenglas> :t mapMaybe sequenceA :: [(a, Maybe b)] -> [(a,b)] -- glittershark
09:26:39 <lambdabot> [(a, Maybe b)] -> [(a, b)]
09:32:03 * hackagebot nanq 1.1.1 - Performs "W (National Kanji Exam) level analysis on given Kanji.  https://hackage.haskell.org/package/nanq-1.1.1 (fosskers)
09:33:13 <kadoban> Heh, hackagebot doesn't handle unicode correctly apparently.
09:45:49 <mitskevich> Hello! Can somebody help me with this? http://lpaste.net/148537
09:47:16 * hackagebot gitHUD 1.3.0 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.3.0 (gbataille)
09:49:21 <srhb> mitskevich: Is it possible to suggest NOT doing this? :P
09:51:10 <mitskevich> srhb: sure, but what should I do if I want to pretty print BiggerContainer type in a similar way?
09:51:56 <srhb> mitskevich: Just make the class deal only with pretty printing, not some fallback show. It'll be a type error to use it for anything else then.
09:52:10 <srhb> Or better yet, unless you have a good reason, just have prettyBig :: BiggerContainer -> String
09:55:04 <mitskevich> srhb: Problem is, I’ll have to make prettyBig :: Show a => BiggerContainer a -> String, and if a is String, it will be quoted if I’ll use `show`… Or am I missing something? How do I show strings without quotes using show function?
09:55:25 <srhb> mitskevich: You don't, indeed. 
09:55:54 <srhb> (You could always conditionally strip them, but ugh)
09:56:52 <mitskevich> srhb: yep, that would be ugly…
09:56:56 <srhb> I just think the whole problem feels artificial. But if you must, get rid of the show at least. One can always define instance PPrint Foo where pprint = show
09:57:17 * hackagebot Lambdaya 0.2.0.0.1 - Library for RedPitaya  https://hackage.haskell.org/package/Lambdaya-0.2.0.0.1 (ralu)
10:02:13 <mitskevich> srhb: snippet is stripped down version of complicated case… it may look artificial, but basically I want to PP the data type that has variable type and I don’t want strings to be escaped (numbers and other types should be shown with show)…
10:03:19 <Gurkenglas> How'll you tell apart a number and a string containing a number?
10:04:14 <breadmonster> Gurkenglas: Umm, by the type?
10:04:19 <Ainieco> why they're using bangs for FromRow fields https://github.com/mightybyte/snaplet-postgresql-simple/blob/master/src/Snap/Snaplet/Auth/Backends/PostgresqlSimple.hs#L158
10:04:55 <Gurkenglas> breadmonster, I meant "How will mitskevich see a printout of a number and know it wasn't a String that his code removed the quotes from?"
10:05:01 <Ainieco> i assume bang there means that evaluation of should be eager but why?
10:05:05 <troydm> lol somebody posted this on 4chan http://i.4cdn.org/b/1452099515791.jpg
10:05:22 <albeit> If I read a Double (8 bytes) into a Storable array as an Int64, then write it back out as an Int64, will the final memory contents by changed?
10:05:42 <glittershark> breadmonster: my instinct would be to use DefaultInstances rather than overlapping instances
10:05:55 <glittershark> DefaultSignatures, rather
10:05:56 <glittershark> words
10:06:34 <srhb> instance PPrint String where pprint = id; instance PPrint Int where pprint = show -- problem solved
10:06:53 <glittershark> srhb: I get the idea the latter case is going to be happening a *lot* of times
10:07:11 <srhb> OK, maybe I'm getting thrown off by the name. :P
10:07:19 <mitskevich> Gurkenglas: I don’t need to. http://lpaste.net/148537 on line 5 there is variable type. On like 19 it’s PP function, if a is Int it will be shown with show, if it’s String, it will be returned with id.
10:07:42 <glittershark> sorry, meant to tag mitskevich on the DefaultSignatures comment
10:07:47 <srhb> Or better yet
10:08:00 <srhb> print :: Show a => BigContainer a -> String
10:08:10 <srhb> Ah, no, forgot the String case
10:09:00 <mitskevich> srhb: Sure, that’s what I did… Strings are messing this up though…
10:09:07 <sm> kadoban: seems so :( needs a fix
10:09:13 <Gurkenglas> mitskevich, maybe you could do filter (/= '"') . show? Unless some Strings contain escaped quotes.
10:09:30 <srhb> mitskevich: Well, lots of types could have similar SHow instances to that of String.
10:09:32 <kurt11> Can anyone explain or help me understand Data.Typeable. I'm looking at the hackage.haskell.org page but it is terse and lacks full descriptions
10:09:35 <t7> is there a name for a type with kind * that isnt a function ?
10:09:51 <t7> like an atom or something
10:09:58 <Gurkenglas> mitskevich, you could use Text instead of String. Text's show instance is already without the quotes.
10:10:01 <mitskevich> Gurkenglas: strings can contain quotes, sure :) and newlines for this matter (they are getting escaped too)…
10:10:03 <ggole> @hoogle (a -> a -> b) -> a -> b
10:10:05 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
10:10:06 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
10:10:06 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
10:10:13 <ggole> Hmph.
10:10:14 <lyxia> kurt11: is there something in particular you'd like to know about it
10:10:35 <ggole> @pl \f x -> f x x
10:10:36 <lambdabot> join
10:10:42 <ggole> Oh
10:10:43 <kurt11> lyxia: can you give me the gist of what it is? Is there a better site that explains it?
10:14:17 <mitskevich> Gurkenglas: not sure it’s a good solution to change whole project’s type structure (String to Text), when I just want to add some pretty printing… but thanks for suggestion, i’ll consider that…
10:16:28 <Gurkenglas> Actually I mean Doc, not Text, welp. Doc's from a library specialized on pretty printing and you could maybe use all of it
10:17:01 <Gurkenglas> I've been told show is meant for debug output and as soon as you want pretty, use something entirely different. :I
10:17:24 <Gurkenglas> > text "asdasd"
10:17:26 <lambdabot>  asdasd
10:19:34 <Gurkenglas> Show has a typeclass "law" (like the monad laws but less seriously enforced) that it produce something you can put into a .hs and run to produce the value. (Doc, of course, breaks it.)
10:20:30 <exio4> Gurkenglas: well, nothing OverloadedStrings can't solve :p
10:21:43 <mitskevich> Gurkenglas: thanks, i’ll check pretty library, looks like what I need
10:26:13 <zachk> mitskevich , pretty printing of haskell types? cabal install pretty-show, import Text.Show.Pretty , ppShow someHaskellTypethatHasAShowInstance 
10:27:27 * hackagebot pandoc-types 1.16.0.1 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.16.0.1 (JohnMacFarlane)
10:27:30 <mitskevich> zachk: thanks, I’ll try it
10:32:03 <bitemyapp> k_bx: hey
10:35:32 <zachk> is there a way to get lambdabot to join a channel? 
10:35:39 <monkeys11> Hi Haskellers, I am new to haskell and looking for an idiomatic way to write a new file to disk using a path like this "dir/dir1/text.txt" where dir and dir1 may or may not exist. If they don't' exist I want to create them. Is there an easy way to do this?
10:36:02 <ReinH> monkeys11: mkdir -p the dir first
10:36:07 <sm> createDirectoryIfMissing
10:36:14 <zachk> Syste.Filepath and System.Directory 
10:37:05 <ReinH> Ah yeah it's called createDirectoryIfMissing in System.Directory
10:37:15 <monkeys11> Awesome thanks!
10:41:43 <geekosaur> zachk, contact the maintainer
10:41:47 <geekosaur> @version
10:41:47 <lambdabot> lambdabot 5.0.3
10:41:47 <lambdabot> git clone https://github.com/lambdabot/lambdabot
10:41:53 <geekosaur> hm, not in there any more
10:41:59 <geekosaur> last I checked int-e was the maintainer
10:43:14 <geekosaur> sigh, also not in the user info (I am careful to include a pointer to me in the user info for IRC bots, not that I currently have any)
10:43:32 <bollu> um, this is probably stupid as hell
10:43:42 <bollu> but is there any way to "load" coq programs into the coq interpreter?
10:44:00 <bollu> I dislike the ui that the Coq tool has, I'd much rather work in the command line to execute tactics
10:44:05 <bollu> like, I'm going through SF
10:44:06 <johnw> Require Import
10:44:16 <bollu> johnw:for me?
10:44:17 <johnw> though I'm not sure just what you mean; do you want to ask in #coq?
10:44:58 <bollu> johnw: #coq is pretty dead most of the time :(
10:45:06 <bollu> johnw: I was hoping people here would know
10:45:22 <zachk> I might look into that language a bit more, but I find it's name somewhat distasteful 
10:45:52 <zachk> I tried Agda for bit, then Isabelle, got some stuff to work nicely in Isabell, then proving termination for integer division, couldn't figure that out 
10:47:24 <zachk> isabelle seemed very nice for proofs, had tactics, and multiple solvers, one click and it would write the tactics for your, sometimes :D 
10:48:18 <johnw> zachk: I enjoy using Coq
10:48:20 <bollu> heh, I'm just starting with the book
10:48:29 <bollu> and I like the very different feel it has to it from everything else
10:48:38 <bollu> it's the same feeling I had learning haskell for the first time
10:48:57 <johnw> but I don't find that Haskell and Coq really overlap in intended uses all that much
10:50:14 <ReinH> bollu: I just use proof general
10:50:14 <bollu> johnw: I'm learning it because I want to understand type systems properly
10:50:20 <ReinH> I can't imagine writing coq without it tbh
10:50:31 <johnw> bollu: that's a pretty good motivation
10:50:34 <bollu> ReinH: yep, johnw told me to install it as well. I'm on it
10:50:37 <jophish> Is Backpack still under development?
10:50:42 <bollu> I was using CoqIDE and I didn't like it
10:51:13 <bollu> johnw: I'm an undergrad, I'm pretty sure this stuff is not gonna help me in getting jobs or anything though :P
10:51:45 <hunteriam> how do i tell my stack project to depend on/ install a library?
10:51:51 <johnw> bollu: depends on the job you're seeking :)
10:51:51 <dmj`> bollu: why not start your own haskell company?
10:52:11 <johnw> bollu: it would help you to get an internship at my company
10:52:14 <zachk> in the projectNameHere.cabal file
10:52:21 <bollu> johnw: oh, where do you work?
10:52:23 <pikajude> what company is that, johnw
10:52:23 <jophish> bollu: I'd feel better about a candidate if they've played around in coq
10:52:28 <bollu> johnw: which is your company?
10:52:32 <johnw> BAE Systems, massive gov't contractor
10:52:34 <bollu> jophish: same question to you
10:52:35 <zachk> also try like stack build or stack solve and you be very specific in the stack.yaml 
10:52:50 <pikajude> BAE systems uses haskell?
10:52:50 <bollu> johnw: I'm not a US resident, any chance still that I can intern at your company?
10:52:52 <jophish> bollu: Myrtle Software, teensy tiny graphics company
10:52:55 <johnw> pikajude: yep, and Coq
10:52:57 <Taneb> johnw: how hard is it to get a Haskell internship with BAE in the UK?
10:53:10 <johnw> Taneb: I know nothing about the UK side of things
10:53:13 <pikajude> everyone dogpile on johnw
10:53:18 <pikajude> haskell, in real life? say no more
10:53:20 <bollu> jophish: same question to you :)
10:53:29 <johnw> pikajude: we use Haskell for most of our tooling
10:53:30 <dmj`> haskell, of the real world.
10:53:37 <Taneb> johnw: I have friends who're doing year-long placements with BAE
10:53:39 <pikajude> this sounds like a sweet deal
10:53:42 <bollu> oh wooow
10:53:46 <zachk> BAE?
10:53:48 <jophish> Taneb: I did an internship (on the c++ side) about 8 years ago without any hassle. I emailed someone at the company and that was it :)
10:53:53 <jophish> (at BAE)
10:53:56 <bollu> omg I would kill to write haskell for life
10:54:10 <pikajude> well, BAE is a defense contractor
10:54:12 <pikajude> so you probably can
10:54:18 <monkeys11> Is there a way to get the date as a string with dashes? "2016-03-18"
10:54:30 <pikajude> monkeys11: http://hackage.haskell.org/package/time-1.6/docs/Data-Time-Format.html#v:formatTime
10:55:11 <jophish> bollu: ping me in a week about that, things are in quite a state of flux right at the moment.
10:55:28 <jophish> (although the chances of using haskell are probably pretty small)
10:55:54 <bollu> jophish: even so :)
10:58:05 <diphtherial> hrm, i'm having real trouble installing gloss via stack, not sure if that's within the scope of this channel
10:58:23 <glittershark> I'm so happy that I managed to convince my employer to let me write a couple services in Haskell
10:58:47 <glittershark> I've been gradually polluting the minds of the rest of my team to my haskellish ways
10:58:53 <diphtherial> i'm not sure which version of gloss i need, and i'm unsure of what information to provide to you all to debug this further
10:59:07 <diphtherial> glittershark: :)
10:59:45 <glittershark> feels really good to get code review that's actually improving my code from coworkers who've been writing haskell for two weeks, too
11:02:29 <hunteriam> wow 2 weeks and its helpful?
11:03:21 <lispy> Just a reminder, the 'Hask' Anything thread is still up. Lots of good questions and answers: https://www.reddit.com/r/haskell/comments/3zhhk4/hask_anything_new_years_edition_the_thread_where/
11:03:21 <glittershark> yeah, coworker in question is a pretty smart guy
11:04:23 <lispy> glittershark: stack w/gloss is definitely in scope
11:04:38 <lispy> glittershark: I don't use stack or gloss, so I can't help you, but I would expect it to work
11:04:38 <hunteriam> wrong guy lispy 
11:04:45 <hunteriam> lispy:  youre looking for diphtherial 
11:04:47 <lispy> oh sorry
11:04:48 <glittershark> lel
11:04:51 <glittershark> I did that too earlier
11:04:52 <glittershark> np
11:04:55 <lispy> diphtherial: ^^
11:05:24 <diphtherial> lispy: thanks; i actually did finally get it to install after finding a reddit post that linked to a stack.yaml that pulls from the gloss github repo
11:05:35 <lispy> diphtherial: cool
11:05:41 <diphtherial> i'm very, very new to stack, so that kind of stuff is beyond my understanding currently...
11:06:23 <lispy> New tools can be daunting
11:06:27 <bollu> johnw: I can use proof general with, say, Agda as well?
11:06:41 <hunteriam> proof general?
11:06:43 <lispy> Lots of helpful folks in our community though, so just keep asking as you get stuck
11:06:57 <lispy> bollu: agda has its own mode
11:07:08 <bollu> oh, I see
11:07:16 <lispy> bollu: same with idris
11:07:40 <lispy> bollu: And recent releases of Isabelle don't work with PG anymore. So these days PG is just for Coq?
11:08:46 <lispy> hunteriam: It's off topic for #haskell, but I'll answer your question briefly. It's a mode for emacs that generalizes the interaction model for several interactive theorem provers.
11:14:44 <statusfailed> do applicative parsers correspond to a particular class of language?
11:14:56 <statusfailed> correspond i.e., can parse
11:16:36 <lispy> statusfailed: yeah, context-free
11:17:10 <lispy> statusfailed: although this is interesting: https://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
11:17:46 <bitemyapp> @pl u f z t = if f z then return z else t z
11:17:47 <lambdabot> u = (`ap` flip id) . ((.) .) . (`ap` return) . (if' .)
11:18:02 <bitemyapp> @ty if'
11:18:04 <lambdabot>     Not in scope: ‘if'’
11:18:04 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
11:18:07 <bitemyapp> tf
11:18:31 <lispy> statusfailed: the intuition for this is that the shape of the applicative computation cannot depend on the values computed wheresas monadic computations can
11:19:08 <lispy> statusfailed: where "shape" here is a bit hard to describe, but I mean roughly that you can't branch (or collapse a subcomputation) based on a computed value
11:23:40 <statusfailed> lispy: noise, thank you :-)
11:23:46 <statusfailed> noice*
11:24:24 <monochrom> nice? :)
11:24:32 <lispy> niiiiice
11:24:36 <ola2caref> Hi all 
11:24:39 <lispy> ola2caref: hello
11:24:41 <zachk> hello 
11:25:05 <statusfailed> monochrom: noice :p
11:25:11 <bollu> Error: Proof General is not compatible with Emacs 22.1.1
11:25:13 <bollu> now what?
11:25:13 <ola2caref> i need help about writing script 
11:25:25 <zachk> get a new version of emacs? :D
11:25:26 <lispy> bollu: PG is very old, you just need a different version
11:25:39 <happytolearn> I have a newb question about functions that do IO. If I have the following function that write to a file and returns a location, do I have to do anything special in the return like IO Location, or will it just work?
11:25:39 <bollu> lispy: so I need to install an older version of emacs?
11:25:40 <zachk> ola2caref whats the script supposed to do? is it in haskell? 
11:25:41 <happytolearn> getLocation String -> Image -> Location
11:25:41 <happytolearn> getLocation path image = writeFile name iamge
11:25:41 <happytolearn>   Location 200 path
11:25:57 <johnw> bollu: PG doesn't work with Agda, no
11:26:04 <johnw> agda-mode has its own fancyness, however
11:26:05 <lispy> bollu: Well, I was thinking you'd change the PG version either older or newer depending on what you need
11:26:07 <bollu> johnw: no, I want it for Coq
11:26:14 <zachk> it should be getLocation :: String -> Image -> IO Location
11:26:38 <lispy> bollu: if you're just starting with coq, I'd just use coqide until you get a chance to configure emacs.
11:26:40 <johnw> PG works quite well with Coq, although it doesn't support all the newest features of 8.5 (like parallelism) which CoqIDE does
11:27:11 <bollu> lispy: alright, I'll use coqide
11:27:59 <ola2caref> zachk i just have i little ideal i need help 
11:28:00 <koala_man> happytolearn: the type of the function would end in IO Location, if that's what you mean
11:28:29 <happytolearn> do I need to lift location into the IO monad?
11:28:36 <happytolearn> like liftIO Location
11:28:39 <monochrom> no
11:28:43 <koala_man> return $ Location 200 path
11:28:54 <zachk> what does getLocation do? or what is it supposed to do? 
11:29:41 <happytolearn> take a name and a picture, save the picture to disk, and then return a data structure that gets converted to json and sent back through the web api
11:30:03 <happytolearn> I can't wrap my head around performing the side effect of saving to disk
11:30:47 <koala_man> happytolearn: it can be tricky. are you familiar with 'do'?
11:31:13 <zachk> do { name <- getName ; picture <-getPicture ; savePictureToDisk ; makeyourdatastructure and set it back here 
11:31:15 <zachk> }
11:31:24 <happytolearn> yes, I thought I didn't need to use do because it was just one call
11:31:47 <hunteriam> how do I derive ToJSON?
11:31:54 <hunteriam> do i need DeriveAnyClass?
11:32:05 <koala_man> happytolearn: the value you return counts as a call
11:32:55 <monochrom> I think aeson doc begins with how to derive ToJSON
11:35:10 <Gurkenglas> What library provides something like "(Time -> (Int, Int) -> Pixel) -> IO ()"?
11:36:43 <byorgey> Gurkenglas: gloss
11:44:20 <Gurkenglas> How do I construct a picture from something like "((Int, Int) -> Pixel)"? Those constructors look more like mspaint tools. bitmap kinda looks fitting, but it seems more made for loading images from files
11:44:49 <zachk> use rectangle or circle for pixels
11:45:00 <zachk> if you want to load jpegs into gloss try gloss-juicy
11:45:33 <Gurkenglas> Nah I explicitly don't want that :P
11:45:49 <diphtherial> hrm, currently not having much luck with gloss on OS X yosemite...here's my stack.yaml that's partiall generated by stack solver --modify-stack-yaml: https://dpaste.de/0LoB
11:45:58 <zachk> you could manually construct the Bitmap 
11:46:17 <Gurkenglas> You're supposed to use circles/rectangles of size one for single pixels and they haven't provided an alias? o.o
11:46:27 <zachk> dive into the internals of the Bitmap of Gloss.Picture or what not 
11:46:28 <diphtherial> stack build runs ok, but when i attempt stack ghci, i get this: https://dpaste.de/jVen
11:46:30 <hunteriam> "fromtext is not a derivable class" they derive fromtext in the sercant tutorial.. what am i doing wrong
11:46:58 <haskell059> in my haskell sandbox, i ran cabal install monad-par -- and it apparently succeeded at the install. however, when i run ghc-pkg list, monad-par is not there
11:47:02 <haskell059> any ideas why?
11:47:17 <zachk> it be like pixel (x,y) = translate x y . Circle 0 or something 
11:47:17 <geekosaur> cabal sandbox hc-pkg list
11:47:22 <Gurkenglas> Why do you need to dive into internals for ((Int, Int) -> Pixel) -> IO () :( that sounds as preludey as writeFile and readFile and fetchURL
11:47:26 <zachk> cause you are in a sandbox 
11:47:27 <geekosaur> you're seeing what's installed *outide* the sandbox
11:48:02 <zachk> gloss and iirc opengl doesn't support the notion of using a single pixel 
11:48:08 <zachk> might be wrong about opengl though 
11:48:55 <haskell059> zachk geekosaur: when i run ghci and try to import a module in that package, it fails. why is this?
11:49:06 <geekosaur> sameissue. cabal repl
11:49:20 <diphtherial> zachk: i believe that's correct
11:49:30 <zachk> haskell059 try cabal install stack and use that 
11:49:38 <geekosaur> sanboxes are not something that ghc and its utilities magically know about
11:49:44 <zachk> why don't you use just cabal install the module instead of using a sandbox 
11:49:44 <tdammers> quick question; suppose I want to have regular expressions after all, what's the go-to library these days?
11:49:54 <geekosaur> zachk, stack doesn;t magically make raw ghci or ghc-pkg aware of its sandbox either
11:49:58 <happytolearn> How do I make a ByteString literal?
11:50:01 <diphtherial> what you could do is manipulate a texture that's on a quad that's the same size as the viewport, with a camera that's set appropriately as well
11:50:19 <Gurkenglas> How *are* you supposed to render 3D stuff? Project them onto the 2D plane, approximate using bzier curves and turn those into Pictures directly instead of going via pixels? Though there doesn't seem to be a constructor for those
11:50:43 <tdammers> happytolearn: most likely, if you're asking for that, something is wrong with your approach
11:50:48 <zachk> diphtherial well that's not *technically* pixels then either, isn't that the same thing as just constructing a bitmap in gloss? 
11:50:56 <tdammers> happytolearn: bytestrings aren't strings, they're sequences of raw bytes
11:51:06 <zachk> gloss is for 2d stuff 
11:51:11 <tdammers> happytolearn: but if you must, you can enable the OverloadedStrings extension
11:51:15 <Gurkenglas> -project them +project the internal representations of the bodies
11:51:20 <geekosaur> you need to use the sandbox utility to see stuff inside the sandbox. it'd be different commands if using stack vs. using cabal, in neither case will just using ghci or ghc-pkg show the sandbox's contents
11:51:29 <byorgey> Gurkenglas: if you just want ((Int, Int) -> Pixel) -> IO (), try JuicyPixels
11:51:42 <happytolearn> tdammers:I'm trying to use the NEtwork.HTTP.Media.MediaType package and it expects bytestrings
11:51:44 <happytolearn> instance Accept SVG where
11:51:44 <happytolearn> 30   contentType _ = "image" // "svg"
11:51:51 <zachk> Gurkenglas what are you attempting to do? 
11:52:11 <zachk> do you want to draw single pixels to the screen and make your own graphic primitives? 
11:52:22 <haskell059> geekosaur: so when i ran the normal cabal install command, the package isn't put into the sandbox (right?) -- so why doesn't ghc-pkg pick it up?
11:52:23 <byorgey> happytolearn: you can use the "pack" function to turn a String into a ByteString
11:52:38 <geekosaur> if you run cabal install and you are inside the sandbox then it installs inside the sandbox
11:52:59 <tdammers> haskell059: ah, yes, those are actually bytestrings, because of the way the protocols are defined
11:53:05 <haskell059> by inside the sandbox, you mean "ran sandbox init" ?
11:53:06 <geekosaur> if you ran it in ~ then it's installed outside the sandbox --- which also means it can't be seen *inside* the sandbox
11:53:06 <tdammers> haskell059: sorry, mistab
11:53:07 <Gurkenglas> I saw a video of a 3D scene rendered in Haskell and thought "Hey Ive almost been doing Haskell for 2 years now that doesnt sound so hard algorithmically"
11:53:10 <tdammers> happytolearn: ^
11:53:15 <haskell059> in the same directory?
11:53:21 <geekosaur> I mean there is a directory .cabal-sandbox
11:53:45 <tdammers> happytolearn: I guess OverloadedStrings isn't too bad for these, as long as you stay 7-bit-clean
11:53:45 <haskell059> oh so if you run the command in .cabal-sandbox then it gets installed in the sandbox; otherwise no?
11:53:56 <geekosaur> siiiigh
11:54:00 <happytolearn> what is 7-bit-clean?
11:54:34 <geekosaur> no, you don;t run it *inside* .cabal-sandbox. presence of a subdirectory .cabal-sandbox identifies the directory you are in as a sandbox, and cabal commands will work inside that sandbox
11:54:40 <zachk> Gurkenglas, and I can almostly postively say, that these days, almost no 3d scenes programs use raw pixels to create the scene
11:54:50 <zachk> they use OpenGL primitives or something layered over that 
11:54:51 <monochrom> that's interesting. if I run a cabal command in .cabal-sandbox, which level of sandboxing will that happen in? :)
11:54:57 <diphtherial> hooray, got gloss to work after adding some random directives to the stack.yaml (apologies for not being more specific; i figure you're all not very interested in my specific issues)
11:55:02 <tdammers> happytolearn: using only clean ASCII, i.e., only characters in the common 7-bit subset between UTF-8 and the usual 8-bit encodings
11:55:17 <haskell059> okay i see, thanks
11:55:20 <tdammers> happytolearn: with MIME content types, this is invariably the case
11:55:27 <happytolearn> I see
11:55:34 <Gurkenglas> That's fine, I want to see if I can approximate it with few lines
11:56:20 <zachk> I made a Binary instance for Gloss picture the other month, to work with Cloud Haskell, and the Bitmap serialization/deserialization part was so slow, I scrapped that approacha and went for something more complicated, but I learned alot in the process 
11:56:35 <tdammers> actually, using other characters is also fine, but it may produce unexpected results, especially regarding the lengths of the bytestrings you produce
11:56:52 <tdammers> > Data.ByteString.length $ toString "áá"
11:56:54 <lambdabot>  Not in scope: ‘Data.ByteString.length’    Not in scope: ‘toString’
11:56:54 <lambdabot>      Perhaps you meant ‘BSLC.toStrict’ (imported from Data.ByteString.Lazy.Ch...
11:57:00 <zachk> Gurkenglas then just use the lines from gloss if you are handling all the 3d stuff your self, like you want just a wireframe, and just need a 2d canvas to draw on 
11:57:19 <tdammers> > import Data.String
11:57:20 <lambdabot>  <hint>:1:1: parse error on input ‘import’
11:57:29 <augur> is there a class for monoidal functors? like.. where   Monoid a => f a -> a  ?
11:57:30 * hackagebot haskellscrabble 1.3.3 - A scrabble library capturing the core game logic of scrabble.  https://hackage.haskell.org/package/haskellscrabble-1.3.3 (happy0)
11:57:36 <tdammers> Data.ByteString.length $ Data.String.toString "áá"
11:57:37 <monochrom> it's probably called BS.length
11:57:46 <tdammers> > BS.length $ Data.String.toString "áá"
11:57:48 <lambdabot>  Not in scope: ‘Data.String.toString’
11:57:49 <zachk> augur isn't that almost comonads? 
11:57:57 <tdammers> oh wait
11:57:57 <johnw> augur: isn't that basically Foldable?
11:57:59 <monochrom> does Data.String exist?
11:58:02 <tdammers> > BS.length $ Data.String.fromString "áá"
11:58:03 <augur> zachk: maybe :)
11:58:04 <lambdabot>  Not in scope: ‘Data.String.fromString’
11:58:06 <augur> johnw: yeah, it seems so! ok then
11:58:13 <tdammers> monochrom: it does, but it may not be available
11:58:18 <tdammers> > BS.length $ fromString "áá"
11:58:20 <lambdabot>  2
11:58:23 <tdammers> hrngh
11:58:26 <johnw> :t foldMap id
11:58:28 <lambdabot> (Foldable t, Monoid m) => t m -> m
11:58:36 <tdammers> > fromString "áá" :: ByteString
11:58:38 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
11:58:38 <lambdabot>      Perhaps you meant one of these:
11:58:38 <lambdabot>        ‘BSC.ByteString’ (imported from Data.ByteString.Char8),
11:58:43 <tdammers> > fromString "áá" :: BS.ByteString
11:58:46 <lambdabot>  "\225\225"
11:58:52 <tdammers> hum
11:59:15 <augur> johnw: also it seems just:
11:59:17 <augur> :t fold
11:59:19 <lambdabot> (Foldable t, Monoid m) => t m -> m
11:59:21 <johnw> oh, yeah, heh
11:59:25 <augur> :)
12:06:22 <Gurkenglas> zachk, by lines I meant lines of code :D
12:07:59 <FireFly> tdammers: that appears as áá (a-acute-accent a-acute-accent) for me
12:08:39 <zachk> there used to be a not-gloss package, that was simple 3d graphics, similar to gloss, but it has been broke and not building for me for a while
12:09:08 <tdammers> FireFly: yes, that's what it is
12:09:15 <Gurkenglas> byorgey, how should I display the stuff generated by JuicyPixels? (The original question was for (Time -> (Int, Int) -> Pixel) -> IO ())
12:09:23 <tdammers> FireFly: I'm just a bit baffled at the length result, I assumed it would use utf-8
12:09:49 <FireFly> Ah
12:10:34 <Gurkenglas> Although I guess it should be "MonadIO m => m ((Int, Int) -> m Pixel) -> IO ()" or something
12:10:44 <Gurkenglas> * -> m ()
12:12:27 <Gurkenglas> Hmm I guess I can combine https://hackage.haskell.org/package/gloss-1.9.4.1/docs/Graphics-Gloss-Data-Bitmap.html#t:BitmapDatav:bitmapOfByteString with http://hackage.haskell.org/package/JuicyPixels-3.2.6.4/docs/Codec-Picture-Bitmap.htmlv:encodeBitmap
12:13:05 <Th30n> What's the easiest way to shuffle the list elements?
12:13:36 <zachk> how big is the list? 
12:14:40 <Th30n> Atm it's not much, I think indexing should be acceptable.
12:15:27 <Th30n> So, performance wise, no worries.
12:15:41 <Gurkenglas> http://hackage.haskell.org/package/random-extras-0.19/docs/Data-Random-Extras.html#v:shuffle looks ok
12:16:05 <zachk> the simple way, not very efficient, would be use System.Random and Data.List.permute , you permute the list with that function, take it's length , then generate a a list index from it's length using like RIO or something from random, then get a value from permute using the (!!) operator
12:16:14 <ReinH> @hackage random-shuffle
12:16:14 <lambdabot> http://hackage.haskell.org/package/random-shuffle
12:16:26 <zachk> oh wow or that
12:16:28 <zachk> :D
12:16:35 <Th30n> Thanks both!
12:16:47 <zachk> not a problem 
12:17:14 <happytolearn> Can someone who understands monad transforms please help me with some code I'm trying to write, I'm completely stuck. I tried to write to a file and return a data type from a do block, but I keep getting errors that neither of those functions are in the EitherT ServantErr IO Location monad
12:17:16 <happytolearn> http://pastebin.com/4ts37UYc
12:17:40 <johnw> lift $ writeFile ...
12:17:54 <johnw> and: return $ Location ...
12:17:57 <ReinH> or liftIO
12:19:04 <happytolearn> I get Not in scope: 'lift'
12:19:14 <johnw> import 
12:19:19 <johnw> Control.Monad.Trans.Class
12:19:26 <ReinH> happytolearn: well, how do you usually fix that error?
12:20:13 <broma0> is there a class function somewhere that captures the extremely general 'a -> m b'? I believe that's a homomorphism (iso?) 
12:20:22 <johnw> Kleisli?
12:20:24 <roelof> Hello, I have a map who looks like this [ { "test", 0, [] }, { "test2", 5, [] } ] 
12:20:38 <johnw> (from Control.Arrow)
12:20:45 <broma0> johnw: from Control.Arrow?
12:20:56 <roelof> Now I want to check if a item is on the list. How can I do this ? 
12:21:13 <broma0> johnw: thanks, ill take a look
12:21:24 <johnw> roelof: what does the syntax { ... } mean?
12:21:38 <ReinH> roelof: what syntax is that?
12:21:45 <roelof> it's a map of records  
12:21:52 <verement> :t elem
12:21:54 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
12:22:00 <ReinH> in what sense of the words map and records is that a map of records?
12:22:03 <merijn> broma0: "a -> m b" where 'm' is a Monad is a Kleisli arrow
12:22:11 <roelof> Reinh ; yep 
12:22:18 <ReinH> roelof: that was not a yes/no question.
12:22:22 <merijn> broma0: "newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }"
12:22:47 <ReinH> I don't understand how either "map" or "records" describes whatever that is.
12:22:58 <ReinH> It isn't Haskell syntax.
12:23:00 <roelof> ReinH:   no, you asked is that a map of records, and I say yes 
12:23:04 <ReinH> No, I did not.
12:23:12 <broma0> merijn: is (>>>) a generalization of (>>=)?
12:23:22 <roelof> you did : [21:21] <ReinH> in what sense of the words map and records is that a map of records?
12:23:25 <merijn> :t (>>>)
12:23:27 <monochrom> roelof: I'm pretty sure you only showing misleading pseudocode. what is the actual code?
12:23:27 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
12:23:36 <merijn> broma0: Not quite, it's a generalisation of
12:23:37 <ReinH> roelof: That is what I said. It does not mean what you said it means.
12:23:39 <merijn> :t (>=>)
12:23:41 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:23:46 <broma0> merijn: ah thats good
12:23:48 <broma0> thanks
12:23:59 <merijn> broma0: Which is somewhat different from >>=, but IMO much nicer theoretically
12:24:12 <ReinH> roelof: specifically, there are a bunch of relevant words before "is that a map of records?" that you seem to have ignored.
12:24:20 <broma0> merijn: nicer in practice to IMO
12:24:23 <ReinH> roelof: so again: what syntax is that? How is it a map of records?
12:24:24 <recursion-ninja> The fish operators are *dope*
12:24:32 <roelof> oke, here is the actual code : http://lpaste.net/148542
12:24:50 <tdammers> >>= is the pragmatic choice :D
12:25:10 <ReinH> roelof: ...
12:25:16 <ReinH> Never mind.
12:25:26 <roelof> what I try to do is if the users wants to delete a Account. I want to check if that Accounts exist in [Accounts] 
12:25:51 <Gurkenglas> You'd think gloss would have monadic versions of play, simulate, display, animate
12:26:04 <ReinH> roelof: you are looking for a function on lists. Have you looked in the Prelude and Data.List for such a function?
12:26:23 <monochrom> OK, it is really [ Account "test" 0 [], Account "test2" 5 [] ] .  now what do you want to find again? find by what criterion?
12:26:28 <ReinH> We are not a "look things up in the docs because you are lazy" service.
12:26:53 <roelof> yes, I did check on `elem`  and I did check findIndex but on both type problems 
12:26:58 <zachk> there is some version of it that is easier to work with, personally I found a post to rip the guts out of gloss, use rawOpengl with it, it's on the haskell reddit, and I have code using the technique, it was pretty easy, though my web browser is completely broke atm, so I can't give you the link or pastebin my code :( 
12:27:18 <verement> :t elemIndex
12:27:20 <lambdabot> Eq a => a -> [a] -> Maybe Int
12:27:23 <roelof> ReinH:  Im not lazy I hope someone can give me a tip 
12:27:24 <ReinH> roelof: what functinos do you know of that remove elements from lists?
12:27:45 <ReinH> or, rather, that return new lists with elements removed
12:28:08 <zachk> Gurkenglas cabal list gloss | less 
12:28:35 <roelof> ReinH:  The remove part is not the problem.  I first want to check if that item is in the [Account] so I can remove it later 
12:28:55 <roelof> Removing something which is not in the [Accounts] is stupid 
12:29:26 <Gurkenglas> roelof, the kind of problem you have becomes easier to solve once you formulate the type signature you want
12:29:53 <ReinH> roelof: and if you tried elem, why did it not work?
12:29:54 <monochrom> consider Data.List.find
12:30:00 <roelof> Oke, I thought.  String -> Account -> Maybe Int could work 
12:30:11 <roelof> I see then a type error 
12:30:12 <ReinH> roelof: What, specifically, do you want to do?
12:30:31 <ReinH> Saying something like "I want to check for an account by name" would help us.
12:30:55 <ReinH> We can't just guess at your meaning.
12:30:59 <roelof> ReinH:  that is exactly what I want 
12:31:04 <ReinH> Well, obviously we can, but it isn't very efficient.
12:31:07 <ReinH> roelof: then just say so
12:31:22 <roelof> sorry 
12:31:29 <anoe> Hello why the first function (writeFile) does not handle right the encodings http://lpaste.net/148541 (using HTTP.Conduit)?
12:31:43 <ReinH> roelof: the more clearly you can formulate your questions, the faster and better answers you will get
12:31:53 <Gurkenglas> roelof, when writing the type signature you want, try to make it as general as possible. That it uses String and Account is probably not essential for your function, but if you compare accounts based on their String maybe you can add information about that you have a function from Account to String.
12:32:22 <ReinH> :t any (\account -> fst account == "test")
12:32:24 <lambdabot> Foldable t => t ([Char], b) -> Bool
12:32:34 <Gurkenglas> Once we know that we can compare Strings, and that we can turn Accounts into Strings, we don't need to know that they are accounts and strings, and so your type signature would become Eq a => (b -> a) -> [b] -> Maybe Int
12:32:38 <ReinH> replace fst with your field accessor for the name
12:33:05 <Gurkenglas> (Oh, forgot an a argument in there.)
12:33:17 <Gurkenglas> Furthermore, you don't actually want to know where you find your element, so you don't need Maybe Int, Bool is enough
12:36:24 <roelof> Gurkenglas:  I think I need a int so I thougth I can use SplitAt for the deleting of that item 
12:36:39 <ReinH> well, binary files don't have an encoding
12:36:45 <ReinH> they are just a collection of bits
12:36:49 <ReinH> anoe: ^
12:37:01 <ReinH> If you want to handle encodings, you probably don't want Data.Conduit.Binary
12:37:40 <Gurkenglas> Okay, stay with the Maybe Int then. When you then realize that you can lazily turn the list of Accounts into a list of Strings, you don't need any (b -> a) anymore and can just look for "Eq a => a -> [a] -> Maybe Int"
12:37:42 <ReinH> (let me preempt someone by amending that "an ordered collection")
12:37:42 <anoe> ReinH: ok but how to rewrite wgetWrite' as wget that would retur body only
12:37:51 <ReinH> Gurkenglas: did you see my solution above?
12:37:59 <ReinH> oh
12:38:01 <ReinH> they need the int
12:38:10 <ReinH> roelof: why do you need to check before you delete?
12:38:16 <ReinH> what business reason do you have for doing that?
12:38:24 <roelof> I thought that was the best way  
12:38:27 <ReinH> Why?
12:38:33 <Gurkenglas> And it turns out this kind of question is posed so often that people have made a thing that answers it automatically if you are good enough at reducing the question as described above:
12:38:44 <roelof> First check if a item exist and then delete it 
12:38:45 <anoe> instead of sinkFile howto return the value of it ?
12:38:52 <Gurkenglas> http://hayoo.fh-wedel.de/?query=Eq+a+%3D%3E+a+-%3E+%5Ba%5D+-%3E+Maybe+Int
12:38:54 <ReinH> roelof: and what do you do if the item doesn't exist?
12:39:10 <roelof> Return the orginal list 
12:39:15 <ReinH> roelof: then you don't need to check at all
12:39:18 <ReinH> just filter the list
12:39:22 <ReinH> and if it exists, it will be removed
12:39:26 <ReinH> if it does not exist, it will not be removed
12:39:28 <Gurkenglas> What if the item exists twice?
12:39:47 <ReinH> Then they have a problem either way
12:40:35 <roelof> At this moment its posssible to add a item twice. I have to write a check later to make this impossible 
12:41:01 <ReinH> Either way, you can solve the problem without testing first
12:41:08 <ReinH> filter is easier, but the other way isn't that much harder
12:41:30 <augur> hmm
12:41:32 <roelof> ReinH:  so use a filter to look for all items which are not the item im looking for ? 
12:41:43 <ReinH> generally speaking, it's wise to avoid testing for a thing before you do the thing, for both efficiency and security reasons
12:41:58 <augur> GHCi is complaining that things are not in scope even tho they've just been loaded
12:42:01 <ReinH> roelof: filter (\amount -> name amount /= "test")
12:42:03 <ReinH> or w/e
12:42:12 <ReinH> will remove all "test" accounts
12:42:32 <ReinH> if you want to remove the first one, which to me seems to be logically inconsistent, you can do something else
12:42:41 <roelof> Bummer : then I was al the time on the wrong way 
12:42:43 <ReinH> but either way there is no need to test first
12:42:46 <augur> anyone know why GHCi would be doing this??
12:42:51 <ReinH> roelof: Welcome to programming. :)
12:42:55 <augur> how can i load multiple modules and bring them into scope??
12:42:57 <roelof> ReinH:  Thanks 
12:43:02 <ReinH> roelof: it's always good to question your assumptions.
12:43:34 <ReinH> s/amount/account
12:43:41 <tdammers> hmm, regex-pcre is not what I want... no pure regex matching
12:43:56 <augur> ah hm :module works but :load doesnt. weird. but ok :)
12:44:00 <ReinH> tdammers: obligatory suggestion that regex is probably not what you want, full stop :p
12:44:04 <roelof> Tomorrow try that way now time to sleep 
12:44:09 <roelof> Thanks all 
12:44:10 <ReinH> augur: I usually use :m +
12:44:42 <tdammers> ReinH: usually I'd agree, but in this case, there's something to say for regular expressions
12:44:59 <tdammers> ReinH: the use case is that I have a tool that needs to extract magic comments from source code in a variety of languages
12:45:16 <ReinH> tdammers: I see. What are "magic comments"?
12:45:19 <augur> ReinH: *nod*
12:45:19 <tdammers> and I want it to be extensible, such that users can add language definitions to a yaml file
12:45:34 <ReinH> tdammers: you can parameterize a parser easily
12:45:43 <ReinH> look at parsers's comment parser
12:45:52 <ReinH> It might be exactly what you want, in fact
12:46:12 <ReinH> pull single line start, multiline start/stop from a yaml file, use them to construct a comment parser.
12:46:31 <tdammers> the most tempting argument for regular expressions is that the syntax is familiar to the target audience
12:47:01 <ReinH> tdammers: Yes, it gives them a gun and makes their foot the size of the rest of the universe and then tells them to shoot it somewhere.
12:47:42 <johnw> lol
12:48:00 <johnw> it gives you a gun, and makes everything else into a foot
12:48:12 <tdammers> *sigh*
12:49:03 <deni> anyone used cassava for pasing CSV files?
12:49:17 <Clint> no, i use csv-conduit
12:49:21 <deni> I'm currently having an issue (which I think actually isn't library related but still). 
12:49:49 <tdammers> comment-marker: "^\s*--" # this is pretty much how users would prefer
12:50:15 <deni> Clint: I have a CSV file which has the first line of the file containg some decsription (not csv data). So I just ignore that line by doing hGetLine handle and then hGetContents handle
12:50:23 <bitemyapp> Is there a more complete URI normalization function than what network-uri provides?
12:50:54 <deni> but the issue I have is that the header has one field name enclosed with quotes ("something bla, something"
12:51:05 <deni> and it fails with that field I think
12:51:35 <deni> it's ignoring non-asci characters but that's another issue I think because it siliently drops them
12:51:43 <ReinH> tdammers: anyway this is all a thinly veiled excuse for the regexp libraries in Haskell generally being not that great.
12:52:06 <tdammers> ReinH: yeah, well, so far I've figured that most are really just wrappers around existing C libraries
12:52:21 <deni> Clint: this is the function I'm using: http://dpaste.com/1C3G11S
12:53:02 <deni> the error I get isn't really helpful: http://dpaste.com/37MP7WP
12:53:13 <deni> though compared to the csv libray it alteast gives me some error output
12:54:31 <tdammers> oh, wait, `match` would work after all
12:55:10 <Clint> deni: http://code.softwarefreedom.org/cgit/sflc-csv-conversion/tree/parseuploadedcsv.hs
12:55:56 <deni> Clint: that's using csv-conduit right? I didn't yet really grasp the *-conduit family of libraries
12:56:20 <Clint> deni: csv-conduit doesn't really have much to do with conduit
12:58:44 <deni> Clint: the CSV statment file that my bank gives me doesn't really help things...it's messed up...it's actually meant for use with Excel so strictly speaking it
12:58:48 <deni> it's not csv rather ssv
12:59:06 <deni> and the file is utf-16 encoded....which I can't really see why but there it is
12:59:13 <Clint> that's fun
13:00:06 <Clint> does your bank do OFX?
13:03:23 <deni> Clint: I don't know what that is so I'm going to guess no. :D
13:03:53 <deni> Clint: oh and also one other thing...they give csv for the main currency but for foreign currency they give me only HTML because reasons :D
13:03:54 <Clint> deni: they'll describe it as microsoft money or quicken or qfx or such
13:03:58 <deni> so now I'm parsing html as well :D
13:07:06 <deni> Clint: not sure...they give me a couple of format with the .wri extension...not sure what they are though
13:07:42 <tdammers> solved!
13:07:47 <tdammers> pcre it is
13:08:58 <Clint> deni: scary
13:10:14 <HairyDude> Is there a regex library that works on ByteString or Text and does replacements?
13:12:03 <xplat|work> ssv?  something-separated values?
13:13:32 <demize> space separated I'd assume.
13:17:06 <tdammers> HairyDude: regex-base and its implementations all work on ByteStrings
13:17:21 <tdammers> not sure about replacements though
13:21:43 <acertain> is there any difference between `foo (Bar a) = Bar a` and `foo a@(Bar _) = a` (besides possibly changing its type)?
13:22:09 <tdammers> yes
13:22:25 <HairyDude> tdammers: seems like you have to manually paste the strings together using the output of matchOnceText
13:22:37 <tdammers> the first one captures just the one record field in the `a` variable, the second one captures the entire Bar object
13:22:50 <dondestantman> Does any one know where to stream ant-man.
13:23:02 <acertain> sure, but are they compiled to the same thing?
13:23:12 <dondestantman> I was banned from ##minichan for asking about streaming ant-man.
13:23:26 <tdammers> HairyDude: haven't dived into it that deeply; my usual approach is to not use regexes, but rather parse things into more meaningful data structures, work on those, and write them back out
13:23:43 <dondestantman> Does anyone else here enjoy or wish to enjoy, like me, streaming ant-man?
13:24:00 <pranz> @where ops
13:24:00 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:24:03 <dondestantman> #Abraxas
13:24:25 --- mode: ChanServ set +o shachaf
13:24:41 --- mode: shachaf set +b *!*4b538701@*.75.83.135.1
13:24:41 --- kick: dondestantman was kicked by shachaf (dondestantman)
13:24:43 --- mode: shachaf set -o shachaf
13:24:51 <verement> acertain: they appear to be semantically equivalent, but I suspect the former may result in a new allocation
13:27:26 <xplat|work> yeah, take that ant stuff to #java
13:27:54 <deni> xplat|work: yeah there's a library actually called "ss"
13:27:57 <deni> s/ss/ssv/
13:28:20 <deni> demize: it's something but it can be space :)
13:30:40 <xplat|work> acertain: they may be compiled to the same thing depending on optimization.  it's possible, depending on the compiler, that the one without the @ could cause an extra allocation, unless Bar is a newtype in which case they are identical.
13:32:06 <xplat|work> 'depending on the compiler' means 'probably for homemade compilers, possibly for ghc -O0, maybe for ghc-O, probably not for ghc -O2'
13:34:28 <shapr> aw, I missed it
13:38:12 <deni> yeah I think that the main problem is that the CSV file is messed up. I have a censored version here if anybody cares to help: http://dpaste.com/2WN0QH6
13:38:29 <deni> it fails at the quotes ....or atleast that's my best guess
13:38:45 <deni> interestingly python gobbles the stuff up just fine
13:39:04 <deni> (with bunch of weird things in there but luckily in the fields i don't care about)
13:39:54 <xplat|work> that actually looks like tsv rather than ssv
13:40:06 <xplat|work> tsv = tab-separated values
13:41:15 <deni> xplat|work: it is....I set decDelimiter = fromIntegral (ord '\t') as the Options to use when I decode with cassava
13:41:39 <deni> xplat|work: see here: http://dpaste.com/1C3G11S
13:42:06 <deni> from what I can tell I'll just have to use parsec or something to write a custom parser
13:45:04 <sphinxo> Can someone explain to me this? : data S n
13:45:19 <Zekka|Sigfig> sphinxo: Is that the whole declaration?
13:45:24 <sphinxo> yes :)
13:45:34 <jle`> do you understand what the `data` keyword does?
13:45:50 <sphinxo> ahh wait it looks like it's part of EmptyDataDecl
13:45:51 <jle`> something like, data Maybe a = Nothing | Just a ?
13:46:13 <sphinxo> Some kinda empty type?
13:46:15 <jle`> it's just declaring a type constructor `S`, which has no data constructors
13:46:28 <jle`> so data Maybe a = Nothing | Just a    -- this has two constructors
13:46:29 <Zekka|Sigfig> sphinxo: Yeah, you can’t construct a terminating value of that type
13:46:41 <jle`> data Identity a = I a  -- this has one constructor
13:46:48 <argoneus> I was looking at some code examples, but I didn't find anything similar - is it possible to nest a do inside another do? like if I have a monad that is supposed to print its internal state, so I wrap the state in IO... would that work?
13:46:48 <jle`> data Foo a  --- this has no constructors
13:46:50 <Zekka|Sigfig> (this is allowed: undefined :: S n; let x = x in x :: S n)
13:46:59 <dobq> sphinxo: i'm guessing this is in the context of type-level numerals
13:47:08 <xplat|work> deni: what error message you get?
13:47:21 <sphinxo> Type level numerals?
13:47:28 <deni> xplat|work: http://dpaste.com/37MP7WP
13:47:28 <jle`> argoneus: can you give a more specific example ...?
13:47:33 <dobq> sphinxo: do you also have a "data Z"?
13:47:33 <jle`> what does it mean to 'wrap the state in IO' ?
13:47:40 <Zekka|Sigfig> argoneus: A do block is just an expression, but it’s not super clear to me what you mean
13:47:45 <sphinxo> Yes
13:47:48 <frerich> sphinxo: This is used for expressing numbers on the type level, e.g. you have 'data Z' and 'data S n' ("Zero" and "Successor") and then you could use e.g. "List (S (S (S Z)))' to denote a list of at most three elements or so.
13:47:57 <jle`> do blocks are valid expressions, so you can use any expression inside a do block, essentially
13:47:58 <argoneus> jle`: like if I have a monad that does some computations and logs progress to a file
13:48:04 <dobq> sphinxo: the type Z represents the natural number 0. the type constructor S represents adding one.
13:48:12 <argoneus> I need IO to write stuff to files, but I also need to do the actual computations
13:48:13 <Zekka|Sigfig> So if your outer do-block is IO _, if the inner one is also IO _, you can nest the inner one as a statement in the outer one
13:48:16 <sphinxo> hmm
13:48:18 <sphinxo> Thanks
13:48:25 <Zekka|Sigfig> But it sounds like you’re asking a question about how monads compose
13:48:32 <jle`> sphinxo: keep in mind that this method is slightly dated
13:48:39 <jle`> it's a relic of the old days
13:48:45 <sphinxo> How should it be done now? jle` 
13:48:59 <jle`> data Nat = Z | S n
13:49:02 <jle`> er
13:49:05 <jle`> dat Nat = Z | S Nat
13:49:12 <dobq> jle`: not sure that's the same thing...
13:49:22 <jle`> and then, using DataKinds, this gives you two types
13:49:22 <dobq> jle`: you would need DataKinds to get type-level naturals
13:49:28 <dobq> ah :)
13:49:48 <jle`> the reason this is better is because this disallows silly things like S Int or S (Maybe (S Bool))
13:49:53 <dobq> well i think it's unfair to call this a "relic" since the "modern" method requires a language extension
13:49:58 <argoneus> I guess Haskell isn't really meant for logging things during execution, right
13:50:01 <Zekka|Sigfig> argoneus: So being clear, you have a monad type like State FunkyComputationState, and you want to use IO too?
13:50:01 <argoneus> that smells sequentially
13:50:21 <Zekka|Sigfig> If so, it sounds like you want monad transformers
13:50:25 <argoneus> Zekka|Sigfig: yeah, or any other monad, like some sort of network downloader library, or even simple things like prime calculating
13:50:33 <argoneus> but I want to log when stuff happens
13:50:40 <jle`> dobq: any new haskell code written should probably use this method
13:50:49 <Zekka|Sigfig> Monads don’t themselves compose, but you can use monad transformers to stack support for additional effect types on top of existing monads
13:50:53 <xplat|work> deni: what is 'BL'?
13:50:57 <argoneus> ah, I see
13:51:02 <jle`> dobq: there's no reason to do data S n; data Z anymore in this era
13:51:05 <argoneus> so I write my thing without logging, without any side effects
13:51:18 <argoneus> and then I create some sort of IO wrapper and apply it on top?
13:51:24 <acertain> argoneus, you can `r <- flip evalState initialState $ do {-# stuff using state #-}` inside another do block to use a state monad to determine one IO effect, or you can use `StateT IO` to interleave state and IO effects
13:51:38 <dobq> jle`: yes but if the new method requires a language extension then the old method isn't really a relic. it's just the method you'd use in pure haskell.
13:51:52 <sphinxo> so before you might do something like -> Type n (S n)
13:51:58 <sphinxo> What would that look like now?
13:52:09 <Zekka|Sigfig> argoneus: I’m being a little slow here because I don’t know what you’ve been exposed to
13:52:10 <sphinxo> (where Type is a WriterArrow
13:52:15 <xplat|work> argoneus: sometimes WriterT is good for logs
13:52:16 <jle`> dobq: sure; i'm calling it a relic in the sense that there's no reason to use it anymore except for legacy...and most usage of it is found in the past
13:52:28 <dobq> i can agree with that :)
13:52:40 <acertain> argoneus, but you can always just pass around values instead of using a State monad
13:52:44 <argoneus> Zekka|Sigfig: so far I just barely grok'd monads
13:52:45 <argoneus> kinda
13:52:57 <argoneus> but I don't know how to glue them together when they're different types
13:53:00 <Zekka|Sigfig> But it’s common to define one monad type for your whole application that supports all the effect types you want, then write code that disregards the effects you don’t care about
13:53:08 <argoneus> I get that you piece a larger thing from a bunch of smaller things, but what if their types are different
13:53:32 <deni> xplat|work: Data.ByteString.Lazy...and B is just Data.ByteString
13:53:52 <Zekka|Sigfig> so WriterT [String] IO () is a monad for logging plus IO, and if you don’t need IO you either ignore IO, or write  the parts that don’t need it according to Monad m => WriterT [String] m ()
13:54:02 <jle`> argoneus: the typical approach is to find a "greatest common denominator" type
13:54:10 <jle`> er, least common denominator
13:54:27 <jle`> ?
13:54:33 <xplat|work> jle`: if it's something that's required for doing really advanced type-level-fu in as few extensions beyond haskell98 as possible it's less of a 'relic' and more of an 'Olegacy'
13:54:36 <Zekka|Sigfig> Logging plus state typically looks like WriterT [String] (State YourStateHere) ()
13:55:22 <sphinxo> What would this look like? jle` -> <WriterArrow> n (S n) 
13:55:25 <Zekka|Sigfig> argoneus: A monad transformer takes one monad type and gives you a new monad type supporting verything the old monad type did, plus something new
13:55:34 <xplat|work> deni: well there's your problem ... you set the encoding on your handle thingy but that applies to everything *but* bytestring since bytestring is pure binary reading
13:55:34 <koz_> What's the language extension that allows string literals to be treated as Text instead of [Char]?
13:55:42 <argoneus> Zekka|Sigfig: oh
13:55:45 <argoneus> sounds like something I need
13:55:47 <Zekka|Sigfig> it’s like a functor in that it supports an operation called “lift” that lets you take an operation suitable for the monad outside, and do it to the transformed version
13:55:52 <jle`> argoneus: the idea is, write all your code in the type that fits the best, and at the end, when you want to use them all together, write natural transformations from your little types into your common denominator type
13:56:00 <pranz> koz_: overloaded strings
13:56:14 <jle`> argoneus: do you mean logging as in accumulating a value, or logging as in outputting IO, to a file or stdout?
13:56:15 <xplat|work> deni: you have to actually read from the file with Text or String and encode it to utf8 or something to feed to Cassava i guess :-/
13:56:17 <koz_> pranz: Thank you!
13:56:21 <Zekka|Sigfig> So if you are in WriterT [String] IO, you can use ‘lift’ to turn an IO operation into a WriterT [String] IO operation.
13:56:23 <argoneus> jle`: outputting to stdout/file
13:56:36 <jle`> so WriterT probably isn't what you want, if you want streaming logging
13:56:53 <Zekka|Sigfig> There are some libraries like mtl designed to make this easier
13:57:21 <Zekka|Sigfig> I’ve got to go for now, but I may be back later — jle` is probably better at Haskell than me though and he may be able to help you
13:57:58 <xplat|work> jle`: you can get streaming logging usually with WriterT if it's a case where streaming logging even makes sense
13:58:12 <koz_> Also, how do I tell GHCi to run a file as a script instead of dropping me into a REPL?
13:58:29 <acertain> koz_, runhaskell ./file.hs
13:58:37 <sphinxo> What would this look like? -> <WriterArrow> n (S n) 
13:58:51 <koz_> acertain: Thanks - I derped out about runhaskell.
13:59:00 <xplat|work> and if it doesn't make sense at all but you want to force it to happen anyway there's always trace :-7
13:59:25 <jle`> argoneus: one thing you could do right now is, if you're already comfortable using `State s a`, use `StateT s IO a`, which allows you to embed arbitrary IO in the middle of your stateful computations
13:59:50 <jle`> it's not the prettiest/cleanest thing, but it "just works", if you're just learning and want to get something done
14:00:21 <xplat|work> the prettiest thing right now for haskell scripting is to use stack :)
14:00:23 <argoneus> hmmm
14:00:25 <jle`> you would log by doing something like `log :: String -> StateT s IO a; log str = liftIO (putStrLn str)`, and then now you can use `log` in the middle of your stateful computations
14:00:52 <jle`> as you learn more and more you'll learn how to replace this with more sane things that are safer/more disciplined
14:00:57 <jle`> but the nice thing about haskell is that it's really easy to refactor :)
14:01:15 <xplat|work> since using stack for scripting lets you specify your package deps inside your script
14:01:23 <jle`> but this works as a perfectly fine drop-in to add arbitrary IO to your State computation
14:01:51 <sphinxo> Can someone help me with what this should be? http://lpaste.net/148545
14:02:00 <xplat|work> and someday someone will write an automatic convertor from a Stack script to a .cabal project with stack.yaml
14:02:13 <jle`> then, for your non-IO state computations, you would write them in Monad m => StateT s m a, instead of State s a
14:02:22 <argoneus> hm
14:02:28 <argoneus> I actually still haven't understood the purpose of lif
14:02:30 <deni> xplat|work: cassava is expetinc ByteString...which is what I'm giving it
14:02:30 <argoneus> lift
14:02:36 <xplat|work> so when you outgrow a single file you'll be able to make a smooth transition
14:02:46 <jle`> argoneus: in this specific case, liftIO :: IO a -> StateT s IO a
14:02:58 <deni> xplat|work: hmmm let me double check
14:03:02 <jle`> it lets you use an `IO` in a `StateT s IO` computation
14:03:10 <xplat|work> argoneus: for a sec i thought you were asking a much more difficult question
14:03:18 <argoneus> xplat|work: lol
14:03:33 <xplat|work> deni: sure but it's a bytestring of raw utf16 bytes
14:03:45 <jle`> so, do your normal State-y stuff with get, put, modify, etc.
14:03:58 <jle`> and every once in a while if you want to do `foo :: IO a` in the middle of it, you'd use `liftIO foo`
14:04:04 <xplat|work> (which cassava isn't expecting, it wants something that's a superset of ascii)
14:04:27 <argoneus> ohh, I see jle` 
14:04:42 <argoneus> I don't really get the point of liftM2 though
14:04:49 <argoneus> it's Monad m => a -> m a
14:04:52 <argoneus> where do I tell it what is m?
14:04:54 <jle`> in this approach, you're using StateT s IO a as your "common denominator" type; `IO a` (IO actions) and `StateT s m a` (pure state actions) are your specific types for specific effects
14:05:07 <Clint> argoneus: you don't need to
14:05:08 <jle`> and `liftIO` is how you bring an `IO a` to your common denominator type
14:05:15 <jle`> argoneus: do you mean `return` ?
14:05:17 <xeaforz> It's nice to see an active irc channel
14:05:17 <pranz> argoneus: it figures it out depending on the context
14:05:21 <kadoban> :t liftM2
14:05:22 <jle`> that's usually figured out through type inference
14:05:37 <jle`> and the "lift" in liftM2 is more or less unrelated to the "lift" in "liftIO"
14:05:40 <deni> xplat|work: hmmm...I'm not sure I can do that then....can cassava do anything else then utf8?
14:05:42 <argoneus> what the fuck freenode
14:05:47 <xeaforz> lol
14:05:52 <jle`> it's related but vaguely
14:06:07 <jle`> the word 'lift' in haskell is sort of abused, it takes on a bunch of different meanings everywhere it's used, heh
14:06:13 <bergmark> deni: encode the file to utf8 using e.g. text-icu and then pass that to cassava
14:06:16 <jle`> but i mean, it's the same way in life, too :o
14:06:32 <sphinxo> Anybody help? : http://lpaste.net/148545
14:07:07 <deni> bergmark: right! that makes sense
14:07:16 <jle`> argoneus: here's a slightly more disciplined way, using pipes http://www.haskellforall.com/2014/02/streaming-logging.html
14:07:17 <argoneus> oh nevermind
14:07:19 <argoneus> I'm retarded
14:07:24 <sphinxo> Have I been muted?
14:07:25 <argoneus> I was looking at the wrong liftm2 definition
14:07:32 <argoneus> this is what happens when I try to program with 38.6C :(
14:07:46 <jle`> but there are a bunch of different approaches you can use to do something like this
14:08:03 <jle`> `StateT s IO a` works fine if you already have a perfectly good `State s a` program you just want to "add stdout logging to"
14:08:22 <argoneus> liftMX looks like a very useful func
14:08:23 <lyxia> sphinxo: what's the problem with what you pasted
14:08:38 <jle`> argoneus: usually we use the liftAx variants instead :o
14:08:43 <sphinxo> The first argument of ‘S’ should have kind ‘Natural’, but ‘n’ has kind ‘*’
14:08:45 <jle`> but yeah, i have to go :) happy haskelling!
14:09:01 <argoneus> lifta2 looks like an applicative
14:09:02 <argoneus> oh
14:09:03 <argoneus> lift A
14:09:04 <argoneus> lift M
14:09:06 <argoneus> ..........
14:11:03 <koz_> Is there a way in GHCi to see all the typeclasses of a type?
14:11:15 <sphinxo> Any ideas lyxia?
14:11:28 <Clint> koz_: :i will list instances
14:11:57 <dobq> sphinxo: you're mixing types and elements
14:12:02 <acertain> argoneus, liftM = liftA for monads
14:12:09 <argoneus> right
14:12:12 <dobq> sphinxo: the "b" type argument should be a type. but S is a data constructor
14:12:15 <argoneus> though if I have a do block
14:12:20 <argoneus> and I lift it to IO to print something
14:12:33 <argoneus> it returns IO <type>, which doesn't fit the >>= function, no?
14:12:38 <argoneus> since it expects <type>
14:12:53 <sphinxo> Ahh, that makes sense
14:12:54 <acertain> argoneus, lift is unrelated to lift{A,M}
14:12:57 <pranz> argoneus: think you're looking at the wrong lift
14:13:02 <pranz> :t lift
14:13:04 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
14:13:11 <pranz> argoneus: ^
14:13:27 <acertain> argoneus, do {a <- b; c} => b >>= \a -> c
14:13:38 <sphinxo> How should I fix this? dobq 
14:13:45 <argoneus> hmm
14:14:17 <dobq> sphinxo: it's not quite clear to me what you're trying to do
14:14:18 <acertain> do {a <- b; c} is desugared to b >>= \a -> c
14:14:25 <spuz_> I'm trying to use attoparsec to write a parser for a type that will take either a String or an Int as an argument. How do I 'fall back' from the numeric parser to the string parser?
14:14:49 <dobq> spuz_: attoparsec is backtracking by default
14:15:12 <frerich> deni: Is that a tab-separate file with optionally quoted fields you're dealing with?
14:15:30 <spuz_> dobq, I'm not familiar with parsers in general so I'm not sure what structures I should be using
14:15:41 <deni> bergmark: xplat|work you were right that this was the issue. I didn't realize that my hSetEncoding handle utf16 didn't actually have any effect
14:15:43 <deni> tnx!
14:15:46 <pranz> spuz_: choice [stringParser, numParser]
14:15:49 <sphinxo> Well I previously had data S n
14:15:53 <pranz> or choose it may be named
14:16:00 <sphinxo> with EmptyDataDecls
14:16:06 <deni> frerich: yep....it's working now it was an issue with encoding (the file is utf-16 encoded)
14:16:09 <koz_> I'm also a bit confused how one would create an Either under classy-prelude.
14:16:49 <frerich> deni: Ah, ok. Otherwise I would have wanted to point out that parsing that with e.g. parsec is probably just three lines of code or so :-)
14:17:02 <spuz_> pranz, thanks
14:17:17 <deni> frerich: yeah I was actually going to do that next....but got stuck with trying to make it work with existing libraries
14:17:31 <dobq> sphinxo: that's not really helpful information for me
14:17:35 <sphinxo> dobq: Now that seemed to work, but i'd like to adapt it to work with data Natural = Z | S Natural
14:18:35 <lyxia> "data Z" and "data S n" are common empty data declarations...
14:18:43 <dobq> sphinxo: okay, so you want to switch to this DataKinds solution?
14:18:56 <sphinxo> Yes, sorry for not being clear in the first place
14:19:21 <dobq> sphinxo: maybe you should use 'S instead of S. and did you actually switch on DataKinds?
14:19:31 <sphinxo> Yes
14:19:51 <frerich> deni: I don't know the syntax of your file exactly, but http://lpaste.net/148546 might get you started. It seems to print something sensible if I run the program like 'runhaskell foo.hs < input.txt'
14:20:49 <mpiechotka> @pl \f (x, y, z) -> f x y z
14:20:49 <lambdabot> (line 1, column 11):
14:20:49 <lambdabot> unexpected "z"
14:20:49 <lambdabot> ambiguous use of a non associative operator
14:21:32 <sphinxo> hmm, dobq still erroring
14:22:03 <Gurkenglas> @pl \f xyz -> f (x xyz) (y xyz) (z xyz)
14:22:03 <lambdabot> (`ap` z) . (`ap` y) . (. x)
14:23:11 <frerich> mpiechotka: That looks like something I'd call 'curry3' (it's like 'curry' but with three arguments)
14:23:24 <Gurkenglas> (You want uncurry3.)
14:23:30 <mpiechotka> frerich: Yep. But hoogle could not find curry3
14:23:37 <frerich> Sorry, *un*curry of course
14:23:39 <Gurkenglas> Try hayoo.fh-wedel.de
14:24:13 <mpiechotka> Yes, but hoogle could not find 'curry3' (sorry if it appears twice - some problem with client)
14:24:30 <aspidites> so i'm modelling a card game and want to write a polymorphic card types
14:24:43 * frerich wonders if there's a nice mnemonic to remember the difference between curry and uncurry. Statistically, I have a 50% chance of getting it right, but realistically I get it wrong 90% of the time.
14:24:53 <frerich> Kinda like with plugging in USB cables...
14:24:59 <aspidites> that is, i want to be able to model cards needed to play say, MtG with the same type that would be used for poker 
14:25:33 <aspidites> in purescript, i'd probably model the different fields (mana cost, effect text, power, etc) with an anonymous record
14:25:36 <frerich> mpiechotka: http://hayoo.fh-wedel.de/?query=uncurry3 does seem to find a function which matches your type
14:25:36 <deni> frerich: cool. Tnx. I'll check it out.
14:25:48 <sphinxo> dobq: ?
14:26:12 <Gurkenglas> Well what properties of cards transfer across games? None that you'd want to model, I think. Card *games* might have stuff in common like "People have cards on their hands (mostly) and take alternating turns (mostly)"
14:26:26 <xplat|work> frerich: curry makes the type sharper
14:26:31 <aspidites> right
14:26:35 <mpiechotka> frerich: Hmm. I was using https://www.haskell.org/hoogle/?hoogle=uncurry3. It seems that it exists in some 'random' modules
14:26:37 <xplat|work> frerich: (more pointy arrows)
14:27:05 <xplat|work> uncurry makes it softer (more fwooshy parens)
14:27:18 <aspidites> i guess i'm mostly wanting to be able to say that a card, regardless of what you play, can be drawn, rotated, etc, but I don't want to resort to type classes
14:27:33 <Gurkenglas> My mnemonic is "I usually need uncurry", because I tend to use it to fit a where'd definition into a composition chian
14:27:35 <Gurkenglas> *chain
14:28:01 <Jinxit> aspidites: what about games where you don't draw cards?
14:28:24 <xplat|work> like where you get dealt all the cards at the beginning, like rack-o
14:28:25 <Gurkenglas> aspidites, have you heard of Tabletop Simulator?
14:28:36 <aspidites> Gurkenglas: yes, I have
14:28:50 <aspidites> well most games you would
14:28:56 <nitrix> I've tried writing such a simulator and it was a very painful month.
14:29:06 <Jinxit> but it's an invalid generalization
14:29:19 <aspidites> so generally speaking, i'm less worried here about the best way to implement a card game and more worried about the answer to the anonymous record problem
14:29:23 <aspidites> perhaps I should have started there
14:29:24 <Gurkenglas> In any game, cards have the properties of position, orientation, and images on both sides.
14:29:29 <Jinxit> that's a better outset
14:29:30 <xplat|work> also, you not only can't reorder your hand in rack-o, you can't even renumber the cards to eliminate gaps while keeping the same order
14:29:51 <nitrix> Gurkenglas: More than that, some cards affects the game's rules too. e.g. Fluxx
14:30:13 <Gurkenglas> You want the simulator to enforce rules!?
14:30:31 <xplat|work> some cards send you to jail, directly to jail, do not pass go, do not collect $200
14:30:37 <Gurkenglas> Well I guess you can add mueval and give each card some space to define code for itself
14:31:06 <aspidites> nvm...I see this has just ended up in a bikeshedding conversation about what I should and shouldn't try to write
14:31:20 <aspidites> for the record, I don't think the existence of quake stopped frag from being written
14:31:30 <aspidites> that someone has done something before doesn't mean it isn't worth my time to write it
14:31:45 <nitrix> with fluxx, some of the rules affect player order, times that you pick new cards, exchange cards, some of them are matter of reaction speed of the oponents, etc.
14:31:59 <Jinxit> Gurkenglas: the hearthstone thing we discussed yesterday has unique code for cards but compile-time
14:43:23 <Gurkenglas> Sounds workable enough using continuations
14:44:43 <johnw> Continuations: When all you have is a hammer, and everything looks like a process for turning nails into something else
14:45:17 <Gurkenglas> Shouldn't you have a nail then? Because all you see is hammerlikes
14:45:20 <Jinxit> why continuations?
14:45:38 <bergey> a hammer, an anvil, and a forge?
14:46:26 <Gurkenglas> I mean a place in your Card record with type (Gamestate -> Gamestate) that's called when the card is played, one when the card is destroyed, one to determine its health at any state, etc
14:46:44 <Gurkenglas> (The last one would be Gamestate -> Health and replace the health)
14:47:26 <shachaf> When all you have is nail polish, everything looks like a nail.
14:47:38 <Jinxit> right now it's done with State Game but similar idea
14:47:52 <Jinxit> and they are executed at certain points
14:47:56 <Gurkenglas> I started out thinking I should say State Game but people keep being confused by that when I suggest it :I
14:48:19 <Jinxit> so most cards have an empty list of Triggers
14:48:22 <dmj`> when all you have is banana peels, everything is a banana
14:48:30 <zachk> prolly want some sort of MyState Game, with a stateT over IO 
14:48:43 <Jinxit> why?
14:48:50 <zachk> when all you have is everything, then you have everything 
14:49:02 <Gurkenglas> So cards can fetch a url to decide what they do, of course
14:49:08 <Jinxit> guh
14:50:02 <Gurkenglas> Try implementing http://gatherer.wizards.com/Pages/Card/Discussion.aspx?popularpage=3&multiverseid=9764 without IO
14:50:53 <Jinxit> I'm not really familiar with Magic, but isn't that just affecting Game?
14:51:08 <Jinxit> oh
14:51:11 <Jinxit> heh
14:51:13 <Jinxit> I see
14:52:17 <Gurkenglas> Consider Event -> StateT Game IO () instead of [StateT Game IO ()]
14:52:35 * hackagebot varying 0.3.0.0 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.3.0.0 (SchellScivally)
14:53:07 <Gurkenglas> (Of course actually it should be "(MonadIO m, MonadState s m) => Event -> m ()")
14:53:15 <Gurkenglas> -s+Game
14:53:17 <dmj`> when all you have are burritos, everything is a monad
14:53:21 <Jinxit> but I don't want IO
14:53:37 <Gurkenglas> Then take out the IO ._.
14:54:00 <dmj`> Jinxit: Use Identity, but StateT Game Identity a ~ State Game a
14:54:04 <koz_> I'm having trouble understanding the error here: http://paste.rel4tion.org/188
14:54:05 <Jinxit> and that doesn't let me have multiple triggers
14:54:39 <Gurkenglas> What? Sure it does. (>>) combines two into one
14:54:48 <acertain> a burrito is just a strong monad in the symmetric monoidal category of food (from ehttps://www.cs.cmu.edu/~edmo/silliness/burrito_monads.pdf)
14:55:06 <dmj`> koz_: put a $ before parseCSVFromFile
14:55:43 <koz_> dmj`: It worked, but why?
14:55:45 <Jinxit> so each Minion would get a trigger for each event, regardless of its' type, and then have to check if it's the right one?
14:56:12 <zachk> minions, summons, or creatures, or planeswalkers? >:E
14:56:30 <Jinxit> it's hearthstone :)
14:57:47 <koz_> dmj`: Never mind, got it.
14:58:02 <koz_> I understand better with bracketing, and function application precedence bit me again.
14:58:26 <dmj`> koz_: (putStrLn . pack . either show pipeline) <$> parseCSVFromFile "./src/original.csv, should have worked too
14:58:36 <dmj`> since function application on the right binds tighter
14:58:54 <Gurkenglas> You don't even need the brackets.
14:59:08 <koz_> dmj`: Now putStrLn is unhappy, since it expects Text -> () and instead got Text -> m0 ().
14:59:16 <zachk> teaching question: somethingHere <- monadIOStuff ,  whats the proper term for binding/assigning the monadIOStuff to somethingHere? 
14:59:21 <dmj`> Gurkenglas: true, was copying his 'fmap' example, in that you did
14:59:47 <lispy> zachk: I say that somethingHere is a binding for the resulst of the monadIOStuff computation
14:59:52 <Gurkenglas> koz_, parseCSV and putStrLn both make IO, you want =<< instead of <$> to connect them
15:00:05 <dmj`> koz_: you can probably lose the fmap
15:00:13 <dmj`> putStrLn . pack . either show pipeline) =<< parseCSVFromFile "./src/original.csv"
15:00:13 <zachk> is it basically like a let macro from scheme? uses a lambda and makes a new scope? 
15:00:29 <lispy> zachk: you could thank of it that way
15:00:29 <dmj`> koz_: since you're not joining it
15:00:40 <koz_> dmj`: I thought so. Thanks.
15:00:45 <dmj`> you're making a IO (IO ())
15:01:05 <Gurkenglas> Jinxit, how do you prevent that using a list of triggers?
15:01:10 <zachk> you can use <$> over IO, because IO is a Monad, and all Monads, are Applicative now, because of the Burning Bridges proposal 
15:01:17 <zachk> <$> is just fmap 
15:01:47 <Jinxit> Trigger has TriggerType (sum type) and TriggerAction (Bool -> Traversal' Game Minion -> State Game ())
15:01:49 <koz_> zachk: AFAIK, IO is a Functor too.
15:01:50 <lispy> zachk: do m1; e <- m2; m3 translates to m1 >> (m2 >>= (\e -> m3))  (extra parens for emphasis)
15:01:53 <koz_> That's kinda what I was going for.
15:02:00 <Jinxit> filter out the right trigger in each minion
15:02:05 <Jinxit> and execute it
15:02:18 <Jinxit> that is, minions hold their own triggers
15:02:24 <zachk> koz_ I think you are correct, and monad has to be at least an applicative and a functor these days 
15:02:35 * hackagebot varying 0.3.0.1 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.3.0.1 (SchellScivally)
15:02:47 <koz_> zachk: So can I do what I wanna do with just a Functor usage, or do I need the full Monad power?
15:02:58 <lispy> zachk: You can play with this translation with lambdabot if you use private messages and the @do @undo commands
15:03:08 <dmj`> zachk: (stuffHere :: a) <- (monadIOStuff :: Monad m => m a), it's just like (monadIOStuff :: Monad m => m a) (>>= :: Monad m => m a -> (a -> m b) -> m b) (\(stuffHere :: a) -> ... m b ... )
15:03:15 <lispy> @undo do { x <- y; z x }
15:03:15 <lambdabot> y >>= \ x -> z x
15:04:11 <Denommus> @undo do { x <- y; return x }
15:04:11 <lambdabot> y >>= \ x -> return x
15:04:26 <Denommus> damn, it doesn't support ApplicativeDo XD
15:05:02 <Gurkenglas> Jinxit, my Event is your TriggerType, and filtering out the right trigger in a minion sounds equivalent to doing a pattern match for a "Event -> State Game ()"
15:05:13 <lispy> Denommus: We just need someone to implement it :)
15:05:19 <Jinxit> yes, but you have to do it in each minion
15:05:37 <spuz_> pranz, what am I doing wrong here? https://gist.github.com/alexspurling/4b8ee2983c0640dc985e
15:05:49 <Jinxit> and that's just code duplication
15:07:10 <koz_> zachk and dmj`: I guess I wanna understand if use of putStrLn means I always gotta have monad operations, or can I resort to something 'less powerful' like functors or applicatives instead.
15:07:40 <pranz> spuz_: think you missed a comma between the list
15:07:42 <Gurkenglas> Oh so you basically have a list that lookup would turn into my function
15:07:44 <dmj`> koz_: since IO is all three you can have your cake and eat it too
15:08:04 <koz_> dmj`: How would I use fmap instead of this: putStr . pack . either show pipeline =<< parseCSVFromFile "./src/original.csv"
15:08:05 <koz_> ?
15:08:07 <rschnck> I'm looking at how Bool is defined (data Bool = False | True) and I'm confused at the fact that it takes the value of its value constructor. For example, with data BookInfo = BookInfo Int String the new BookInfo variable will have an Int and String value. It doesn't have a BookInfo value--that's just the value constructor. 
15:08:08 <zachk> I end up using var <- fmap somethingFunction putStrLn in a do block, instead of a seperate let 
15:08:17 <koz_> I guess I'm just trying to understand, and seeing an example would help.
15:08:20 <Jinxit> I guess? maybe
15:08:45 <spuz_> pranz, oh damn, there's me relying on the fact that I'm not understanding something
15:08:58 <dmj`> koz_: :t \f -> join (putStrLn <$> f "file")
15:08:59 <Gurkenglas> And I guess you can see why you wouldn't want to use a case of "_ -> return ()" in every "Event -> State Game ()" definition
15:09:12 <Jinxit> yeah
15:09:14 <hackriledge> How is the Monoid instance of a parameterized Monad related to the Monad instance?
15:09:24 <dmj`> :t \f -> join (putStrLn <$> f "file")
15:09:25 <pranz> spuz_: heh
15:09:25 <lambdabot> ([Char] -> IO String) -> IO ()
15:09:37 <koz_> dmj`: join is a monadic op, IIRC.
15:09:39 <Jinxit> I do other things in the lookup anyways, it checks if the minion receiving the event is the one that caused it
15:09:48 <hackriledge> If it is at all...
15:10:00 <Jinxit> (some may listen to their own death, some may listen to the death of friendly minions, etc)
15:10:16 <dmj`> koz_: yea, but you have to use it, otherwise you won't be able to evaluate IO (IO String)
15:10:37 <dmj`> :t \f -> putStrLn <$> f
15:10:38 <lambdabot> Functor f => f String -> f (IO ())
15:10:39 <koz_> dmj`: So that does answer my question - you do need monadic ops.
15:10:46 <zachk> :t var <- fmap (fmap toUpper) putStrLn 
15:10:47 <lambdabot> <no location info>:
15:10:47 <lambdabot>     not an expression: ‘var <- fmap (fmap toUpper) putStrLn’
15:10:59 <zachk> :t fmap (fmap toUpper) putStrLn 
15:11:00 <lambdabot>     Couldn't match type ‘()’ with ‘Char’
15:11:00 <lambdabot>     Expected type: String -> IO Char
15:11:00 <lambdabot>       Actual type: String -> IO ()
15:11:04 <zachk> D:
15:11:11 <koz_> Thanks - that's all I needed to understand.
15:11:26 <zachk> how do I get the max size of an Int on a machine in ghci/ghc? 
15:11:43 <lyxia> rschnck: When you define a datatype you define constructors, which sometimes have more data attached to them, sometimes not.
15:11:54 <Gurkenglas> > maxBound :: Int
15:11:56 <lambdabot>  9223372036854775807
15:11:56 <phaazon> hm, that constructor ticking stuff is boring (DataKinds)
15:11:57 <zachk> ty
15:12:35 * hackagebot patches-vector 0.1.5.1 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.5.1 (LiamOConnorDavis)
15:13:17 <zachk> ack
15:13:25 <zachk> :t fmap (fmap toUpper) getLine 
15:13:27 <lambdabot> IO [Char]
15:13:29 <zachk> there we go
15:14:20 <synergistics> Are the lambda terms \ab.b and \a.I (as in the identify combinator) equivalent? If so, what type of equivalence is that?
15:14:37 <rschnck> lyxia: Oh, I misread something I see.
15:14:47 <c_wraith> phaazon, it's (mostly) unnecessary if types and constructors never share names. 
15:14:58 <rschnck> lyxia: I guess it's confusing to me that when I print a variable of some type, its value constructor is included. Why is that?
15:15:14 <hackriledge> (koz_) is use of putStr permitted in any use other than in composition with other IO monads. No, I think not. Fortunately, every program is an IO monadic operation (main :: IO ()) so you will always have a place to use putStr, and more generally, any IO a
15:15:19 <HairyDude> ah, Magic
15:15:30 <HairyDude> I have a project to parse Magic rules text
15:15:48 <HairyDude> which meant implementing Magic itself, cos how else do you interpret it?
15:15:53 <lyxia> rschnck: the constructor is what distinguishes values of different types, and even within a single type there may be different constructors with the same fields.
15:16:36 <rschnck> lyxia: Ah, I see. That makes sense!
15:16:39 <rschnck> Thanks. :)
15:17:07 <hackriledge> (hackriledge) How is the Monoid instance of a parameterized Monad related to the Monad instance?
15:17:10 <Cale> synergistics: That's maybe alpha conversion
15:17:15 <Cale> synergistics: or nothing at all
15:17:21 <Cale> synergistics: depending on how I is defined
15:17:21 <hackriledge> If at all...
15:17:57 <lyxia> rschnck: You're welcome.
15:18:00 <Cale> Actually, if I is implemented in a nontrivial way, maybe it's more than that
15:18:12 <Cale> But we can't tell if we don't know exactly which term I is.
15:18:16 <hackriledge> The identity can be non trivial?
15:18:30 <synergistics> Cale: I see why now. \a.I = \a.\b.b = \ab.b
15:18:49 <Cale> yeah
15:18:59 <HairyDude> they're extensionally equal
15:19:07 <synergistics> Cale: Would that change I's definition or only implementation if you did implemetn it different?
15:19:21 <HairyDude> how would you implement I differently?
15:19:32 <Cale> hackriledge: If I = (\x.x)(\x.x), then it would need a beta reduction
15:19:41 <Cale> (and an alpha conversion)
15:19:59 <synergistics> But if you used I like that, wouldn't that term have to be in parens?
15:20:03 <hackriledge> It has unique implementation under these equivalence relations Cale describes
15:20:06 <lyxia> I'd implement myself tall and smart.
15:20:18 <xeaforz> And here I thought that C was my salvation. What a way to have a language such as this go unoticed by whole countries. Thank you
15:20:30 <Cale> hackriledge: uhhhh, does it?
15:20:35 <synergistics> lyxia: Poor Idiot bird
15:20:49 <HairyDude> xeaforz: Haskell's unofficial motto is "avoid success at all costs" :)
15:20:57 <Cale> I think determining whether a lambda term is equivalent to the identity is undecidable, isn't it?
15:21:08 <Cale> At least, depending on which lambda calculus we're talking about
15:21:16 <synergistics> Untyped
15:21:17 <hackriledge> It has the same effect, I can't make a stronger statement than that. There exists an isomorphism
15:21:45 <hackriledge> id x = x
15:22:02 <hackriledge> To*
15:22:19 <HairyDude> (\x.x)(\x.x) is extensionally equal to \x.x
15:22:26 <Cale> Like, for example, with a bunch of work, I could probably come up with a term which is the identity if and only if the Collatz conjecture is true.
15:22:37 <synergistics> Like how SKK involves an extra term, but has the same affect as I?
15:22:50 <exio4> Cale: f n = n + collatz n - 1  ? :P
15:22:57 <synergistics> SKK = \a.K a (K a)
15:24:10 <synergistics> hackriledge: Basically, you can say that \a.Ka(Ka) has the same effect as \a.a, but aren't equivalent in all ways?
15:24:17 <hackriledge> If the conjecture failed it would not result in the identity
15:24:32 <HairyDude> fun fact: S and K are (>>=) and return in the ((->) a) monad
15:24:37 <Cale> exio4: haha, perhaps something a bit like that
15:24:56 <Cale> exio4: in the untyped lambda calculus you have to worry about what happens when non-numerals are given to the thing
15:25:08 <exio4> Cale: oh, well 
15:25:17 <Cale> But I think it'd be possible to work around that
15:26:19 <Cale> I guess it's way simpler to produce a function which is the identity iff Collatz is false -- you look for a counterexample, and then return the identity once you've found one.
15:26:28 <hackriledge> HairyDude, I'm struggling with the correlation between Monads and Monoids in objects which are both, and I'm struggling to articulate this... There seems to be some intrinsic relation which eludes me
15:26:38 <Cale> Otherwise, you're looking forever
15:27:15 <koz_> hackriledge: Aside from a naming similarity, I don't see an inherent relationship.
15:27:22 <synergistics> Is category theory knowledge something common among a lot of people here?
15:27:25 <koz_> A monoid is a set with an associative operator and an identity.
15:27:30 <HairyDude> hackriledge: a monad over a category M is a monoid object in the category of functors M -> M
15:27:36 * hackagebot latex-formulae-hakyll 0.2.0.1 - Use actual LaTeX to render formulae inside Hakyll pages  https://hackage.haskell.org/package/latex-formulae-hakyll-0.2.0.1 (LiamOConnorDavis)
15:27:38 * hackagebot latex-formulae-pandoc 0.2.0.3 - Render LaTeX formulae in pandoc documents to images with an actual LaTeX installation  https://hackage.haskell.org/package/latex-formulae-pandoc-0.2.0.3 (LiamOConnorDavis)
15:27:46 <koz_> ...and goes to show I shouldn't open my mouth sometimes. :P
15:28:37 <HairyDude> hackriledge: return and join correspond to the monoid unit and composition respectively
15:29:10 <hackriledge> notId x = if someCondition then x else (x,x)
15:29:47 <hackriledge> Hmmm, hard to make something to return other than c with the same type!
15:29:48 <HairyDude> hackagebot: if you're talking about Haskell Monoid / Monad, it's not possible for something to be both because the two classes' parameters have different kinds.
15:30:20 <hackriledge> When parameterized
15:30:26 <hackriledge> Like []
15:31:29 <hackriledge> Ie. [] is a Monoid, [a] is a monad
15:31:38 <HairyDude> hackriledge: other way round :P
15:32:17 <hackriledge> Could one construct a superclass that serves as both, for objects implementing both
15:32:31 <codebje> one could, but it would have no useful methods
15:32:47 <HairyDude> class (Monad m, Monoid (m a)) => MonoidMonad where ???
15:32:53 <HairyDude> err
15:32:59 <HairyDude> class (Monad m, Monoid (m a)) => MonoidMonad ??? where ???
15:33:04 <hackriledge> It would have those of Monad and Monoid without the redundant aspects
15:33:16 <koz_> MonoidMonad = Monoad?
15:33:22 <koz_> Or Mononad?
15:33:23 <codebje> hairydude, that's a subclass, surely
15:33:34 <hackriledge> It's ok as a subclass actually
15:34:01 <codebje> :i MonadPlus
15:34:11 <codebje> I never know how to make the bots love me
15:34:16 <hackriledge> But then would simply discard redundant statements.. I think... Is there a redundancy?
15:34:19 <codebje> :t MonadPlus
15:34:20 <lambdabot> Not in scope: data constructor ‘MonadPlus’
15:34:32 <hackriledge> It's a class
15:34:36 <hunteriam> if i have sqlite.dll on my PATH why am i getting `missing c library: sqlite` for HDBC?
15:34:41 <hunteriam> in windows
15:35:14 <HairyDude> @bot
15:35:14 <lambdabot> :)
15:35:24 <hackriledge> Lol
15:35:45 <pranz> hunteriam: I don't think windows look for dlls in PATH
15:35:46 <HairyDude> @info MonadPlus
15:35:47 <lambdabot> MonadPlus
15:35:52 <hackriledge> Please don't feed the bots
15:35:55 <HairyDude> well, that's not very useful is it
15:35:58 <kadoban> Lol
15:36:02 <hackriledge> I'll Google it chill
15:36:06 <hunteriam> pranz: well Its in System32
15:36:18 <codebje> :t mzero
15:36:19 <codebje> :t mplus
15:36:19 <lambdabot> MonadPlus m => m a
15:36:20 <lambdabot> MonadPlus m => m a -> m a -> m a
15:36:28 <kadoban> IIRC @info doesn't actually exist, it gets typo-fixed to @undo, which does nothing because there's no do. Or maybe I'm remembering wrong.
15:37:08 <HairyDude> kadoban: I take it do is another lambdabot plugin that this instance doesn't use?
15:37:11 <Clint> @info do { x <- y; z <- a; return (x,z) }
15:37:11 <lambdabot> y >>= \ x -> a >>= \ z -> return (x, z)
15:37:38 <hackriledge> instance MonadPlus m => Monoid (m a) where mempty = mzero mappend = mplus
15:37:52 <hunteriam> @src MonadPlus
15:37:52 <lambdabot> Source not found. You type like i drive.
15:37:56 <kadoban> hackriledge: No, @undo desugars 'do' blocks
15:38:05 <hackriledge> class Monad m => MonadPlus m where mzero :: m a mplus :: m a -> m a -> m a
15:38:06 <codebje> long story short, what I'm badly trying to say is MonadPlus is probably the magic you want
15:38:12 <kadoban> HairyDude: ^
15:38:19 <HairyDude> @undo do { x <- y; z <- a; return (x, z) }
15:38:19 <lambdabot> y >>= \ x -> a >>= \ z -> return (x, z)
15:38:25 <HairyDude> right.
15:38:39 <hunteriam> is it wrong to put sqlite3.dll in System32 for HDBC? Im getting `missing c lib, sqlite`
15:38:55 <hackriledge> Thanks! I thought it must be a thing, you guys rule!
15:39:11 <Clint> hunteriam: can it find the header files
15:39:15 <HairyDude> I must get round to getting the platform working on windows
15:39:19 <hackriledge> One sec I have something horrible to show you!
15:39:32 <hunteriam> Clint: maybe? I dont know how dlls and .defs work
15:41:45 <HairyDude> I'd entirely forgotten about MonadPlus
15:41:55 <codebje> everyone does :(
15:41:56 <HairyDude> I've never come across a use case for it
15:42:08 <synergistics> How are combinators found? Is there a specific process people use that works to help find everything from the A to Z combinator? Seeing SK definitions of random combinators makes me wonder how people even thought to get to that.
15:42:27 <kadoban> Alternative is used for parsing and etc., and MonadPlus is just Alternative's big brother, right?
15:42:54 <codebje> MonadPlus is kind of a mix of failure and alternative
15:43:11 <HairyDude> > join return return 1
15:43:13 <lambdabot>      No instance for (Show (m0 a0))
15:43:13 <lambdabot>        arising from a use of ‘show_M542201959983927533113491’
15:43:13 <lambdabot>      The type variables ‘m0’, ‘a0’ are ambiguous
15:43:30 <codebje> so yeah, MonadPlus is like a less flexible Alternative
15:43:32 <HairyDude> > (join return return :: a -> b) 1
15:43:34 <lambdabot>      Couldn't match type ‘b1’ with ‘m0 a’
15:43:34 <lambdabot>        ‘b1’ is a rigid type variable bound by
15:43:34 <lambdabot>             an expression type signature: a -> b1 at <interactive>:1:2
15:43:39 <codebje> I've seen it used well, but cannot for the life of me remember where now
15:44:56 <kadoban> I imagine where you need to use (<|>) and (>>=) you'd use MonadPlus? Can't think of another reason to really.
15:45:23 <HairyDude> > (flip join return return :: a -> b) 1
15:45:25 <lambdabot>      Couldn't match type ‘b1’ with ‘m0 a’
15:45:25 <lambdabot>        ‘b1’ is a rigid type variable bound by
15:45:25 <lambdabot>             an expression type signature: a -> b1 at <interactive>:1:2
15:45:43 <kadoban> HairyDude: You can /msg lambdabot to play with it
15:46:18 <hunteriam> yikes
15:46:21 <argoneus> do you guys reckon an IRC bot is a decent first project or is there a lot of .. tricks?
15:46:52 <hunteriam> i have sqlite3.dll and sqlite3.def in System32 and I pass that directory as extra-lib-dirs and extra-include-dirs in stack but i still get the erro "missing c lib sqlite3"
15:46:55 <hunteriam> what on earth is giong on
15:46:56 <Jinxit> the parsing bit is fun to do in Parsec, argoneus 
15:47:00 <pranz> argoneus: sure, I think that is a good idea
15:47:05 <Jinxit> but I'm not sure what libs are available for the IRC side
15:47:12 <hunteriam> i know this is a bit of a technical question for ##haskell
15:47:25 <HairyDude> wait, S is bind, not join...
15:47:50 <argoneus> Jinxit: from what I've seen all I need is a handler that does some magic IO stuff
15:47:56 <HairyDude> > (>>=) return return 1
15:47:58 <lambdabot>      No instance for (Show (m0 a0))
15:47:58 <lambdabot>        arising from a use of ‘show_M842929564997732830713625’
15:47:58 <lambdabot>      The type variables ‘m0’, ‘a0’ are ambiguous
15:48:05 <argoneus> there's actually a wiki page for rolling your own haskell bot but it seems tricky
15:48:17 <Clint> i think last time i looked at that it didn't work
15:48:23 <argoneus> even better
15:48:27 <argoneus> I can figure out why and how to fix it
15:48:47 <argoneus> okay nice I'll make that, thanks :)
15:49:31 <kadoban> argoneus: Just to point this out: if you haven't done any basic haskell learning yet, starting with a project will probably be pretty frustrating.
15:49:33 <pranz> argoneus: alternatively a slack bot if you use that, I used slack-api and found it very easy to get into
15:49:57 <HairyDude> > (>>=) (return :: a -> b -> a) return 1
15:49:59 <lambdabot>      No instance for (Typeable b0)
15:49:59 <lambdabot>        arising from a use of ‘show_M773221316015687317813663’
15:49:59 <lambdabot>      In the expression:
15:50:06 <argoneus> kadoban: I spent the last several days reading things and example code
15:50:21 <argoneus> I want to program something now but programming erastothenes's sieve seems boring
15:50:31 <hackriledge> Ok, this is crazy; http://lpaste.net/148551
15:50:36 <HairyDude> lambdabot is weird :/
15:50:39 <Jinxit> argoneus: go for it
15:50:57 <argoneus> Jinxit: the only problem I can see is that I rely on information a 3rd party gives me, so it might be a bit hard to debug
15:51:03 <argoneus> at least that's the problem I had in other languages
15:51:15 <Jinxit> create your own channel?
15:51:19 <argoneus> or is there a way to debug the parsing and commands without connecting somewhere?
15:51:22 <argoneus> like tests
15:51:24 <Jinxit> also that
15:51:28 <HairyDude> hackagebot: I spy a typo on line 8
15:51:55 <argoneus> I could write the framework first, the parts that take strings and manipulate them
15:51:59 <argoneus> and only then worry about actual IO
15:52:05 <argoneus> that's what haskell is good for, right?
15:52:09 <Jinxit> yep
15:52:26 <hunteriam> hackriledge: InSane?
15:52:27 <hunteriam> fa?
15:52:37 <argoneus> is there an equivalent of unit testing though? to make sure my functions work as I want them to
15:52:49 <argoneus> I found something called HUnit, do I even need that for this?
15:52:52 <hackriledge> Refresh it, I caught those typos
15:52:56 <HairyDude> hunteriam: hah, make that two typos :)
15:52:59 <Jinxit> either straight up unit testing like normal, or property testing with quickcheck
15:53:19 <Jinxit> I use HSpec which has support for both
15:53:25 <hunteriam> hackriledge: IsSane ?
15:53:41 <hackriledge> Trivial! Ok I'll add it
15:53:49 <argoneus> okay nice, thanks Jinxit 
15:53:55 <argoneus> you are a great ally
15:54:01 <ReinH> argoneus: hunit, hspec
15:54:25 <hunteriam> hackriledge: fmap (flip bind f) crazy
15:54:26 <argoneus> this syntax looks like natural language
15:54:33 <hunteriam> hackriledge: scary stuff
15:54:35 <argoneus> it "throws an exception if you do X" $ do ...
15:54:40 <argoneus> that's cool
15:55:10 <ReinH> BDD is the name of that style
15:55:13 <hunteriam> hackriledge: good god what is this type for
15:55:18 <hunteriam> hackriledge: its huge is it not?
15:55:21 <ReinH> It isn't unique to Haskell
15:55:22 <hackriledge> Muhahaha
15:55:43 <argoneus> just a quick question, is the file/module system similar to python? that is a bunch of files, I can import functions from eachother, and each file can have a main that will execute when I run it?
15:55:51 <argoneus> or is there some magic with cabal config and compilation
15:56:09 <ReinH> argoneus: quickcheck offers a unique way of testing things as well
15:56:25 * argoneus looks up quickcheck
15:56:38 <ReinH> Not unique to Haskell but quite different from unit testing
15:57:09 <hackriledge> Everyone has tried to do this at some point. The idea is that we would like to write tree where we store the neighbors as a tree not a list. The way in which this acts like Free gives the extra structure needed to handle this additional recursive call...
15:57:48 <HairyDude> is that the free monad?
15:58:16 <ReinH> @check \xs -> reverse (reverse xs) == xs
15:58:17 <lambdabot>  +++ OK, passed 100 tests.
15:58:37 <ReinH> argoneus: ^
15:58:45 <exio4> @check \xs -> reverse xs == (xs :: [()])
15:58:46 <argoneus> does it automatically generate data to test?
15:58:47 <lambdabot>  +++ OK, passed 100 tests.
15:59:05 <argoneus> it just looks at the reverse function, checks what it accepts, and subs a random thing for xs?
15:59:05 <hackriledge> Does that make sense?
15:59:09 <ReinH> Yeah I should have specified an element type
15:59:18 <ReinH> Defaulting runs that example
15:59:22 <ReinH> Ruins
15:59:29 <exio4> indeed :(
16:00:06 <HairyDude> @check \xs -> reverse (reverse xs) == (xs :: [Int])
16:00:08 <lambdabot>  +++ OK, passed 100 tests.
16:00:28 <HairyDude> @check \xs -> reverse (reverse xs) == (xs :: [Maybe (Either Int Bool)])
16:00:32 <lambdabot>  +++ OK, passed 100 tests.
16:00:46 <Jinxit> what's more interesting is if it fails a test
16:01:13 <ReinH> argoneus: if you have a slow but correct function you can use it as a specification for an optimized version
16:01:20 <Jinxit> but I don't know it well enough to construct a simple one
16:01:27 <exio4> @check \xs -> reverse (x : xs) == x : reverse xs 
16:01:27 <HairyDude> @check \n -> n > 2 ==> odd n
16:01:28 <lambdabot>  No instance for (Arbitrary Expr)
16:01:29 <lambdabot>  arising from a use of ‘myquickcheck’ In the first argument of ‘text’, namely...
16:01:30 <lambdabot>  No instance for (Show Test.QuickCheck.Safe.SProperty)
16:01:30 <lambdabot>  arising from a use of ‘myquickcheck’ In the first argument of ‘text’, namely...
16:01:38 <exio4> err, :(
16:01:40 <ReinH> Yes it generates arbitrary test data by type
16:01:46 <HairyDude> @check \n -> n > 2 ==> odd (n::Int)
16:01:48 <lambdabot>  Couldn't match expected type ‘Int’
16:01:48 <lambdabot>  with actual type ‘Test.QuickCheck.Safe.SProperty’ In the first argument of ‘...
16:01:51 <argoneus> @check \a -> 1/a == 1/a
16:01:53 <lambdabot>  +++ OK, passed 100 tests.
16:01:57 <argoneus> hm
16:02:00 <HairyDude> @check \n -> odd (n::Int)
16:02:02 <lambdabot>  *** Failed! Falsifiable (after 1 test):
16:02:02 <lambdabot>  0
16:03:27 <exio4> @check \x xs -> reverse (x : xs) == x : reverse (xs :: [Int])
16:03:29 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 2 shrinks):
16:03:29 <lambdabot>  4 [2]
16:03:51 <ReinH> @check \xs-> unwords (words) xs == xs
16:03:52 <lambdabot>  Couldn't match expected type ‘() -> ()’ with actual type ‘[Char]’
16:03:52 <lambdabot>  The function ‘unwords’ is applied to two arguments, but its type ‘[String] -...
16:03:58 <Jinxit> @check \n -> (if n == 8 then True else (odd n)) == odd n
16:03:58 <ReinH> Heh
16:04:00 <lambdabot>  +++ OK, passed 100 tests.
16:04:03 <Jinxit> :^)
16:04:05 <Jinxit> @check \n -> (if n == 8 then True else (odd n)) == odd n
16:04:06 <lambdabot>  *** Failed! Falsifiable (after 9 tests):
16:04:07 <lambdabot>  8
16:04:09 <Jinxit> and boom
16:04:27 <exio4> sure, it's not a proof
16:04:35 <argoneus> ReinH: specification for an optimized version?
16:04:36 <argoneus> how
16:04:38 <Jinxit> exactly the point
16:05:23 <ReinH> argoneus: write a slow but correct algo. Use quick check to test your faster one against its results
16:05:37 <argoneus> ohh, like that
16:05:47 <argoneus> can you make it do like 100000 tests?
16:05:54 <ReinH> Sometimes it's easy to write the slow one
16:05:59 <johnw> argoneus: easy
16:07:13 <ReinH> argoneus: you might like Bird's Pearls of Functional Algorithm Design. It does this except it *proves* the faster one to be equivalen
16:07:28 <ReinH> t
16:07:51 <exio4> a proof is much more tedious yet certain, why isn't there some magic algorithm that finds those proofs by itself? ;) 
16:07:56 <ReinH> Via equational reasoning
16:08:11 <ReinH> exio4: wellllllllll ;)
16:08:16 <hunteriam> good god
16:08:16 <hackriledge> Can anyone see a problem with my crazy type? http://lpaste.net/148551
16:08:17 <kadoban> Pearls is really neat. It's taking me forever to make my way through it though.
16:08:19 <hunteriam> GOOD GOD
16:08:36 <Thery> Hello
16:08:41 <ReinH> exio4: actually Bird has you write one in his new book!
16:08:42 <hackriledge> Hi
16:08:46 <hunteriam> I have the entire sqlite3 source code, as well as compiled DLL and .def in a directory which I have pointed stack to with --extra-included-dirs/libs
16:08:53 <hunteriam> BUT
16:09:00 <exio4> anyway, proving things via equational reasoning feels tedious, but compared to proofs in imperative languages, it's.. so simple :P 
16:09:02 <hunteriam> i cant install hdbc because sqlite3 c library is missing
16:09:04 <hunteriam> WHY?!?!?!/
16:09:05 <Hijiri> exio4: you just have to simulate the brain of a computer scientist
16:09:10 <Thery> I heard this the where I can get some excellent code meth
16:09:23 <HairyDude> exio4: proving correctness is part of what dependent typing is for
16:09:25 <exio4> Hijiri: :D nothing AI couldn't solve? :P 
16:09:32 <Jinxit> I mean, if the types match up in the optimized version, it's gotta be correct, right?
16:09:36 <ReinH> kadoban: would be a great book for a book club / discussion group
16:09:37 <Jinxit> ;.)
16:09:37 <exio4> ReinH: waaa did he solve the halting problem? 
16:09:55 <argoneus> exio4: actually talking about that
16:09:57 <exio4> HairyDude: dependent types are quite tedious, because you need to prove the properties you want! 
16:10:01 <argoneus> is there a thing
16:10:09 <argoneus> to which you give a set of values, and it tries to give you an estimation formula for them?
16:10:09 <Thery> is this place noob friendly?
16:10:13 <argoneus> Thery: absolutely
16:10:19 <Thery> Awesome!
16:10:21 <ReinH> exio4: no a mechanical theorem prover for point free expressions in Haskell
16:10:22 <Jinxit> argoneus: the field of machine learning
16:10:23 <kadoban> ReinH: Hmm, yeah that'd probably be cool as hell. I've been trying to do one of the pearls a week or something, I usually have to sit down with quite a bit of paper and a computer and break my brain for a while.
16:10:40 <HairyDude> exio4: in Agda at least, you can say "trustme" for properties you can't be bothered to prove yet
16:10:43 <exio4> ReinH: er, what?! now I want the new book!
16:11:02 <kadoban> Only thing is, it's somewhat hard to tell if I'm actually learning a ton. It'd be nice if there were exercises to go with it too, though that would be hard as hell.
16:11:05 <ReinH> exio4: it's my favorite Haskell book
16:11:12 <Thery> I need help with an assignment I'm working on . It's in component pascal: http://pastebin.com/jf7ygxe5
16:11:36 <exio4> ReinH: I need it _now_! <_<
16:11:45 <ReinH> Thery: this is a Haskell channel
16:11:46 <HairyDude> hunteriam: looks like nobody can help you :(
16:11:52 <Thery> The thing is I'm struggling with starting the function at line 94
16:11:54 <exio4> argoneus: machine learning is -exactly- that :p 
16:12:11 <argoneus> oh
16:12:12 <Thery> Ah!
16:12:18 <argoneus> so stuff like neural networks and genetic algorithms
16:12:31 <Jinxit> the problem you described is called regression
16:12:32 <ReinH> Thery: recommend you switch to Haskell immediately
16:12:43 <Thery> i read Askhell hahaha
16:12:43 <kadoban> hunteriam: Maybe ask in 'stack'? Might want to point out exactly how your setup is … set up too. You could also just use the docker support, possibly?
16:12:44 <Jinxit> essentially fitting a line to some data (or plane, or hyperplane, etc)
16:12:49 <ReinH> Then we can help you!
16:12:50 <HairyDude> ReinH: what's the book called?
16:12:55 <argoneus> oh
16:12:58 <argoneus> not necessarily a line
16:13:03 <argoneus> it could be a more complex function
16:13:05 <ReinH> HairyDude: thinking functionally with Haskell
16:13:05 <puregreen> Thery: a procedure doesn't return anything, a function does
16:13:06 <Jinxit> still regression
16:13:18 <argoneus> this is cool
16:13:24 <hunteriam> i need to scream
16:13:34 <argoneus> too bad learning haskell won't help me figure out maths :(
16:13:42 <kadoban> hunteriam: Sorry, that was supposed to be: Maybe ask in #haskell-stack […]
16:13:44 <ReinH> It might
16:13:48 <hackriledge> Chill dude!
16:13:55 <Thery> ReinH: I would if I could but my school is making is work with component pascal so no choice at the moment... 
16:14:01 <exio4> argoneus: you might want to look in sites like coursera, there are quite nice machine learning courses there...
16:14:02 <Jinxit> I'm doing some ML in python atm and I wish badly that I could do it in Haskell instead
16:14:04 <Jinxit> because types
16:14:13 <ReinH> Thery: bah
16:14:15 <argoneus> exio4: I've tried some genetic algorithms before
16:14:23 <argoneus> I tried making an AI for brood war, but........ shit's complex o.o
16:14:26 <puregreen> Thery: and return is done as “functionName := resultThatYouWantToReturn”
16:14:36 <ReinH> argoneus: yes slightly complex
16:14:36 <puregreen> Thery: pm me if you need more help
16:14:41 <Thery> Puregreen: Where did I say procedure?
16:15:04 <ReinH> puregreen: or Haskell blah
16:15:08 <argoneus> I feel like I need to get a whole degree to be able to work with AI though
16:15:16 <argoneus> not the kind of investment I want to make right now
16:15:34 <argoneus> anyway this is offtopic sorry))
16:15:55 <kadoban> Ohh, there's lts-4, interesting.
16:16:33 <argoneus> by the way, do you think one should only learn haskell after having some experience in procedural/imperative programming?
16:16:42 <argoneus> or is it learnable just fine for like a maths student
16:16:46 <argoneus> or even an art student
16:17:11 <HairyDude> haskell helped me figure out some maths, namely category theory :)
16:17:21 <pranz> argoneus: I don't think experience is required. Some universities use Haskell for their intro cs course
16:17:28 <pavonia> argoneus: IMHO, you should even learn a functional *before* an imperative language
16:17:32 <kadoban> argoneus: It should be fine for someone with no programming knowledge. http://haskellbook.com/ is supposed to work for that usage.
16:17:33 <lispy> argoneus: I've heard of people learning Haskell as a first language, especially folks with a math background
16:17:38 <dzdcnfzd> It's learnable by all those things, though (in my opinion) it is generallly harder than procedural languages
16:17:40 <argoneus> hm
16:17:47 <argoneus> I guess it's nice when it's your first language
16:17:50 <hackriledge> pavonia, I agree
16:17:52 <adamCS> pavonia: Yes! Would save much heartache and frustration...
16:17:55 <argoneus> you don't try to glue OOP and procedural approaches to haskell, right
16:18:02 <argoneus> and wonder why it doesn't work like that
16:18:24 <HairyDude> well, SPJ said Haskell is the world's finest imperative language...
16:18:39 <hackriledge> Actually Haskell datatypes are just like objects in my mind
16:18:55 <HairyDude> hackriledge: types + operations = ADT
16:19:02 <HairyDude> hackriledge: and a well designed class is an ADT
16:19:28 <johnw> haskell data types are not really like objects
16:19:32 <argoneus> anyway thanks for the help as usual, good night my friends
16:19:42 <hackriledge> No one likes my crazy type?
16:20:25 <Jinxit> objects usually have functions and are mutable
16:20:27 <hackriledge> argoneus, good night
16:21:34 <hackriledge> Yeh it's the transient nature of the objects under lazy evaluation which is puzzling, but you can kind of look past that, all the best functionality is present
16:22:23 <dzdcnfzd> My feeling is that monads are so important for everything beyond toy programming, and require enough understanding of types, that Haskell is pretty rough for someone who's never seen even a structured program before
16:22:32 <hackriledge> I'll just try to bump this one last time, I'd love some commentary; http://lpaste.net/148551
16:23:43 <HairyDude> hackriledge: you don't seem to have defined a Monoid instance, what is mappend?
16:23:59 <hackriledge> No, an introduction to set builder notation in maths along with some set theory is sufficient, Wadeler neatly skipped over Monads during the introduction to Haskell he was lecturing
16:24:56 <exio4> hackriledge: does that even follow the monad laws?
16:25:08 <dzdcnfzd> hackriledge: what lecture?
16:25:12 <hackriledge> HairyDude, it's a partial MonadPluss instance... I'm not done yet, that was add far as I got with the implementation last night, I didn't know monad plus was a thing until today
16:25:27 <exio4> hackriledge: it doesn't look like it does, btw
16:25:45 <exio4> hackriledge: x >>= return, check the Sane case.
16:26:26 <exio4> er, wait, what
16:26:38 <Nadrieril> does this typecheck ?
16:26:45 <exio4> ^?
16:26:51 <exio4> and can you avoid partial functions?
16:27:00 <Nadrieril> I'm having trouble with | isSane fa = Insane fa fcrazy
16:27:04 <exio4> and instead switch to pattern matching vs "isSane" and then an unsafe pattern match
16:27:14 <exio4> s/unsafe/partial
16:27:16 <hunteriam> can anyone assist me in figuring out why my stack cant see my sqlite3.dll/sqlite3.h/sqlite3.def and so on
16:27:28 <hackriledge> Exio4 yeh I was struggling, there is a way I think, needs a tweak sure, but like, more importantly.... Hang on I have to respond to these comments
16:27:49 <exio4> hackriledge: give me a version of that code that type checks
16:28:22 <hackriledge> The isSane thing seemed required...
16:28:30 <hunteriam> question
16:28:33 <hunteriam> why are you writing this
16:28:35 <hunteriam> hackriledge: 
16:29:00 <exio4> hunteriam: why is it required?
16:29:01 <hackriledge> Yeh I guys I should use fromSane to get the a out hang on
16:29:04 <exio4> er
16:29:09 <exio4> hackriledge: ^ 
16:29:23 <exio4> hackriledge: does that actually type check, btw?
16:29:28 <hackriledge> Ok, I'll get it type checking
16:29:40 <hackriledge> I'm lacking a compiler sorry
16:29:41 <exio4> if it doesn't type check, checking the monad law doesn't make sense
16:29:52 <exio4> laws*
16:30:13 <exio4> bind (Insane a crazy) f | isSane fa = Insane fa fcrazy ; where fa = f a 
16:30:37 <HairyDude> hackriledge: what's the Functor instance?
16:30:50 <hunteriam> I wish there was a way for ghc to verify the monad laws
16:31:00 <hunteriam> could dependant typing even enable that?
16:31:04 <exio4> the functor instance is not the problem, to be honest =) 
16:31:08 <HairyDude> hunteriam: yes
16:31:55 <hackriledge> Yeh the Functor instance blew my mind so differed it until later! I guess I just apply fmap everywhere! I'll try and do that now too
16:32:38 <exio4> instance Functor Crazy where fmap f (Sane a) = Sane (f a) ; fmap f (Insane a as) = Insane (f a) (fmap (fmap f) as) ? 
16:32:50 <hackriledge> Sorry, where was the type error?
16:33:05 <exio4> hackriledge: the line I posted
16:33:16 <exio4> hackriledge: rewrite this to use pattern matching and you will see, btw.
16:33:58 <hackriledge> I can't pattern match because I apply a function
16:34:16 <exio4> ?
16:34:30 <exio4> hackriledge: are you familiar with "case" ? 
16:34:45 <exio4> hackriledge: case f a of Sane _ -> ... ; Insane _ _ -> ... 
16:35:19 <exio4> hackriledge: can you use write it with >>=, too? that'd mean running it would be easier.
16:36:47 <hackriledge> ?
16:37:13 <ReinH> >>= and LambdaCase work well together.
16:37:25 <hackriledge> The person this is for does not know infix syntax.
16:37:33 <hackriledge> I know I'm cruel...
16:38:20 <hackriledge> I mean, I have to then write an introduction to inflix syntax to accompany it and it leads to bloat
16:38:56 <hackriledge> Anyway, so forgive the lack of sugar
16:39:26 <Jinxit> if the person can't handle infix I'm sure they can't handle the Crazy
16:39:53 <Nadrieril> and you don't need infix to use case
16:40:19 <exio4> hackriledge: http://lpaste.net/148558 your code rewritten using using case, and (>>=) and with some boilerplate (added Control.Applicative for GHC 7.8, even!)
16:40:33 <hackriledge> That's the way it's cruel sure, I'm up against a wall anyway, just forgive the lack of sugar, the explanation of why is superfluous and frustrating
16:40:38 <exio4> hackriledge: do you see why it doesn't type check?
16:40:53 <exio4> hackriledge: specially the "fa@Sane{}" case.
16:41:02 <hackriledge> That's exio4!!
16:41:32 <exio4> hackriledge: per (>>=)'s type, m a -> (a -> m b) -> m b ; Crazy a -> (a -> Crazy b) -> Crazy b , right?
16:41:50 <hackriledge> Thanks*
16:42:01 <hackriledge> Right
16:42:31 <HairyDude> hunteriam: http://lpaste.net/148559
16:42:42 <exio4> hackriledge: now, Insane :: a -> Crazy (Crazy a) -> Crazy a 
16:42:55 <hunteriam> HairyDude: what language?
16:43:16 <hackriledge> Yes
16:43:38 <pranz> hunteriam: I think Agda
16:44:03 <exio4> hackriledge: Insane (v1 :: Crazy a) v2 :: Crazy (Crazy b), which isn't Crazy b
16:44:28 <Nadrieril> ooh, you have to implement the proofs of the monad laws as well as the monad functions *.*
16:44:36 <hackriledge> Isn't it?
16:44:38 <HairyDude> Nadrieril: exactly
16:44:46 <hackriledge> Another flap?
16:44:48 <Nadrieril> this is very elegant
16:44:50 <hackriledge> Fmap
16:44:55 <exio4> hackriledge: ...? no?
16:46:10 <hackriledge> Free . Free /= Free ?
16:46:21 <hackriledge> Ok...
16:46:27 <hackriledge> Damn
16:47:04 <hackriledge> So apply mconcat?
16:47:05 <HairyDude> hunteriam: yes, it's in agda
16:47:20 <hunteriam> HairyDude: Nadrieril proofs of the monad functions?
16:47:25 <hackriledge> Or join...
16:47:27 <HairyDude> http://wiki.portal.chalmers.se/agda/pmwiki.php
16:47:39 <hackriledge> Fold mapped...
16:47:52 <hackriledge> mappend*
16:48:00 <exio4> hackriledge: you probably meant something else, like http://lpaste.net/148560
16:48:03 <Nadrieril> hackriledge: do you have any idea of what you are trying to do ?
16:48:15 <Nadrieril> or are you guessing wildly ?
16:48:15 <dzdcnfzd> exio4: what does the "fa@(Sane{})" thing mean?
16:48:23 <exio4> dzdcnfzd: it's an "as-pattern"
16:48:37 <HairyDude> hunteriam: yeah, to produce a Monad record, you have to produce correctly-typed values for each of the laws as well as the operations
16:49:00 <lispy> > let { isJust Just{} = True; isJust _ = False } in isJust (Just 1)
16:49:02 <lambdabot>  True
16:49:12 <hackriledge> I'm trying to get to something describes in the comment on the paste, I have a good idea how, but lack experience enough to do it smoothly
16:49:15 <lispy> The inner {} in that example means the same as _
16:49:29 <johnw> I'm starting to feel like the channel's attention is being drained into an non-solution to a non-problem
16:49:30 <exio4> in _that_ case
16:49:56 <exio4> johnw: I need some excuse to waste my time :p 
16:50:07 <johnw> exio4: I'm sure I can find you something better
16:50:16 <hunteriam> HairyDude: in other words the user has to supply runit which is one of the proofs of the monad laws?
16:50:48 <exio4> johnw: I am all ears! 
16:50:50 <hackriledge> Hey johnw
16:50:59 <hackriledge> Please don't do that
16:51:02 <lispy> johnw: thanks for providing some direction!
16:51:13 <johnw> exio4: wanna fix bugs in c2hsc? :)
16:51:20 <dzdcnfzd_> exio4: I'm asking about the {} portion
16:51:22 <johnw> hackriledge: don't do what?
16:51:31 <hackriledge> !?
16:51:37 <exio4> johnw: uh-hu, that's harder :P
16:51:58 <johnw> exio4: then use Haskell to prove the equivalence of Mu and Nu.  that should keep you occupied for a few hours :)
16:52:13 <johnw> (their equivalence within Haskell, that is)
16:52:32 <ReinH> good times
16:52:42 <exio4> dzdcnfzd_: it's record syntax
16:52:43 <hunteriam> BAD TIMES
16:52:46 <dzdcnfzd_> exio4: namely, the "Sane{}" in  fa@(Sane{}) 
16:53:22 <exio4> dzdcnfzd_: it can be seen as "Sane _" but without adding as many _s as parameters to the constructor
16:53:37 <dzdcnfzd_> exio4: thanks!
16:53:41 <hackriledge> johnw, this is a Free MonadPlus. Did you invent that? Can't you see it's utility!? This whole language was inspired by the free Monad and it's expressive power
16:54:12 <johnw> hackriledge: so go, prove its Monad, and come back with the great news.  Until then, it's been enough already.
16:54:44 <exio4> dzdcnfzd_: (it's just a nice "abuse" of record syntax, kinda :p) 
16:54:46 <pranz> MonadJesus
16:55:22 <exio4> johnw: Mu/Nu equivalence, that's one of those proofs I haven't done! thanks! :D
16:55:39 <johnw> exio4: throw in Fix too, for bonus points :)
16:56:35 <dfeuer> I'm beginning to get the sense that type families are really useful for turning instance contexts into (more powerful) class contexts when the given instances provide a certain level of "coverage".
16:56:58 <hackriledge> Can't you see how helpful exio4 had been in helping me iron out these wrinkles? It's been invaluable. I'm sorry it frustrates you to see the channel used to further investigations other than those you see merit in. Of course I'm not going to refuse a kick, I respect this board allot.
16:57:25 <dfeuer> That is, if I have      instance foo => C bar     I may be able to use a type family to add some form of foo entailment to the C class.
16:57:26 <hackriledge> Thanks for your help guys, thanks for looking at my type, I hope when it's finished you can use it
16:57:57 <dfeuer> Is that the right way for me to be thinking?
16:58:15 <johnw> hackriledge: in that case, how about inviting exio4 over to #haskell-overflow?  we created that channel for this very purpose.  My apologies for not recommending that instead of just asking to stop.
16:58:30 <hunteriam> I dont understand why hackriledge's discussion was inappropriate
17:00:39 <dzdcnfzd_> Guys, I'm sitting in my second two-hour meeting in two days. This board is my only solace. Let's not fight for no reason.
17:01:12 <exio4> yeah, let's find a reason first! :P 
17:01:15 <hunteriam> does anyone feel like helping me install hdbc-sqlite3 on windows with stack?
17:01:23 <dfeuer> Quick question:   If I have     class C a b | a -> b,  is there a way to write   duh :: (C a b, C a b') => b :~: b'  ?
17:01:29 <StoneToad> dzdcnfzd_: you're able to irc while in a meeting o_O
17:01:36 <sm> hunteriam: is that a trick question ? :)
17:01:44 <hunteriam> ? im entirely serious
17:01:48 <StoneToad> sm: yea, he's trying to trick someone into helping him
17:02:24 <dzdcnfzd_> StoneToad: I am able
17:02:39 <sm> hunteriam: stack install hdbc-sqlite3 fails complaining about some missing sqlite C library ?
17:02:45 <hunteriam> yes
17:02:54 <lispy> hunteriam: 64bit windows?
17:02:56 <hunteriam> yes
17:03:09 <lispy> hunteriam: get msys2, it comes with the pacman package manager
17:03:20 <lispy> hunteriam: that way you can install the C library with pacman
17:03:24 <lispy> hunteriam: and then point cabal at that
17:03:31 <hunteriam> how would i point cabal at that
17:03:43 <lispy> IIRC --extra-lib-dirs?
17:03:55 <ReinH> I'd rather help you create an ubuntu VM.
17:03:57 <lispy> I always have to check the cabal user gide
17:03:57 <sm> maybe searching the net or the hdbc-sqlite3 docs/issues for other folks doing this finds a recipe ?
17:03:59 <lispy> guide*
17:04:39 <hunteriam> sm: believe me ive looked
17:04:47 <lispy> If you're on windows you'll want a more general solution to installing 3rd party C libs. That's why I recommend msys2/pacman
17:05:00 <lispy> Doing it one-off for each library gets old fast
17:05:16 <sm> +1
17:05:47 * HairyDude installs agda
17:05:57 <ReinH> At this point the only reason I can justify for using Windows to develop software is if you are developing windows software. It's so much easier to use a VM.
17:06:00 <HairyDude> been a few years since I touched it
17:06:14 <hunteriam> ReinH: VMs are heavy weight
17:06:28 <ReinH> A heavyweight thing that works is infinitely better than a lightweight thing that does not work
17:06:30 <exio4> ReinH: funnily enough, I have only used Windows (in the past years) for.. that :p 
17:07:04 <ReinH> But apparently you're rather waste weeks of your time now than seconds of your time later.
17:07:13 <ReinH> *you'd
17:07:48 <HairyDude> only thing I really use windows for is games
17:08:05 <hunteriam> lispy: where do i point cabal to
17:08:10 <HairyDude> even then most are ported to linux these days
17:08:27 <hunteriam> linux is what I would use if i liked wasting weeks of my time
17:08:33 <hunteriam> theres a reason I dont
17:08:44 <ReinH> lmao, remind me what you're doing at this exact moment again please?
17:08:46 <hackriledge> Windows is fine for all development other than packages which depend on the Unix package as far as I can tell
17:08:57 <hunteriam> ReinH: this is happening far less in windows than it did in linux
17:09:06 <hunteriam> in windows its a problem for Dev, in linux its a problem for every day life
17:09:16 <ReinH> Which is why you have a VM that you use for dev
17:09:20 <hackriledge> Mingw is a great little shell
17:09:22 <ReinH> although I disagree with your premise
17:09:28 <ReinH> I am happy to accept it since it doesn't change the argument at all
17:09:38 <hunteriam> there is no argument
17:09:55 <ReinH> ...
17:09:59 <ReinH> I am literally making an argument.
17:10:13 <hunteriam> enjoy yourself
17:10:16 <hackriledge> Does your package depend on Unix? If so it's not going to work in Windows
17:10:16 <ReinH> Ok
17:10:19 <ReinH> I tried.
17:10:26 <ReinH> Enjoy your Windows dev experience.
17:10:29 <pikhq> hunteriam: Yep, no real argument. Unix UI land is amateur hour.
17:10:39 <dgpratt> Functor has been a superclass of Monad for...a very long time, right?
17:10:47 <Clint> yes
17:10:48 <monochrom> not very long
17:10:53 <dgpratt> heh
17:11:04 <dgpratt> make up your minds, #haskell :)
17:11:22 <hackriledge> Though Monad offers a default flap...
17:11:27 <ReinH> Well, if "since the latest minor version release" is a very long time then yes.
17:11:27 <hackriledge> fmap*
17:11:35 <ReinH> hackriledge: liftM
17:12:00 <hackriledge> So why the Functor Superclass requirement?
17:12:05 <dgpratt> I've encountered some examples recently that define Monad, but not Applicative or Functor
17:12:18 <johnw> after AMP, liftM is really not necessary anymore, is it?
17:12:24 <dgpratt> so I wondered if that was kosher in the past and not now?
17:12:30 <ReinH> Why make rectangle a superclass of square?
17:12:34 <monochrom> it was kosher in the past
17:12:42 <ReinH> (I mean, superclass isn't the best way to describe the relationship, but w/e)
17:13:06 <pranz> hackriledge: because you can define fmap with return and bind
17:13:20 <dgpratt> ReinH, terminology fail, probably -- I hoped you all knew what I meant
17:13:29 <dgpratt> urg -- kb being difficult
17:13:52 <dgpratt> monochrom, what changed and when, roughly?
17:14:07 <xeaforz> On the note of windows dev, I use windows in a vm and linux is life; my2cents
17:14:37 <hunteriam> linux dev is nicer
17:14:39 <hunteriam> windows works better
17:14:48 <hackriledge> So since it's certainly automatically a Functor, isn't the superclass constraint redundant?
17:14:48 <ReinH> hunteriam: I thought we weren't arguing.
17:14:49 <monochrom> base changed to have "class Applicative m => Monad m". (and Applicative has always had Functor superclass)
17:15:22 <Nadrieril> hmmm... why can't I write "instance forall x . Monoid (f x) => whatever f" ?
17:15:38 <dgpratt> I see -- thanks monochrom
17:15:43 <monochrom> "forall x" is not part of instance syntax
17:15:48 <xeaforz> I was making an observational assesment of the opposite view
17:15:53 <Nadrieril> :/
17:16:01 <Nadrieril> is there a way to express this constraint ?
17:16:01 <ReinH> dgpratt: Functor ⊃ Monad would be more accurate.
17:16:02 <acertain> hackriledge, it's so you can use fmap (and functions that have a Functor constraint) on Monads
17:16:46 <dgpratt> ReinH, you want me to use fancy characters that aren't even mapped on my kb? :)
17:17:22 <acertain> liftM is useful as a definition for fmap though
17:17:23 <ReinH> dgpratt: the situation we had before was "We know that any Monad can be made a Functor, but to use fmap with a Monad instance generically we must write (Functor m, Monad m) => ..."
17:17:30 <ReinH> dgpratt: now, Monad m => ... is enough to use fmap
17:17:37 <hackriledge> So we do not write the instance Monoid m => Functor m where, why?
17:17:54 <ReinH> hackriledge: because there is no such instance.
17:18:03 <ReinH> It is impossible: they have different kinds.
17:18:09 <Nadrieril> hackriledge: maybe you meant Monad
17:18:11 <acertain> hackriledge, some Monads have a Functor instance that is faster than the general one
17:18:32 <hackriledge> Sorry, Monad*
17:18:39 <monochrom> Nadrieril: no, instances are an open world, there is no way a compiler is willing to confirm or deny "for all x, f x is a Monoid instance"
17:18:44 <ReinH> hackriledge: assuming you meant Monad, we don't write it because that would prevent us from writing a Functor instance for anything that is also a Monad.
17:19:02 <ReinH> Sometimes, as acertain says, you want to do this because the default can be improved upon.
17:19:16 <monochrom> in fact I imagine that a compiler would prefer to always deny, if it had free will
17:20:26 <hackriledge> You want to reserve that liftA and fmap may be different?
17:20:26 <Nadrieril> monochrom: I'm trying to do a sort of generic tree: "data Tree f a = Nil | Node a (f (Tree f a))". To write useful instances for it, I need constraints on f
17:20:28 <acertain> monochrom, https://hackage.haskell.org/package/constraints-0.6/docs/Data-Constraint-Forall.html
17:20:47 <monochrom> actually, open world is irrelevant for this, the relevant aspect is non-compulsory
17:20:58 <ReinH> Nadrieril: that's nearly Cofree.
17:20:59 <Nadrieril> And for APplicative I would have like to have (Monoid (f x) 
17:21:14 <Nadrieril> )
17:21:17 <ReinH> Although Cofree only allows non-empty structures.
17:21:26 <Nadrieril> So its Maybe Cofree ?
17:21:33 <ReinH> Not quite.
17:21:33 <Nadrieril> wait no
17:21:39 <Nadrieril> sry
17:21:46 <monochrom> Nadrieril, I wonder if what acertain just said helps
17:22:01 <pilne> am i off my rocker to think that yampa being utilized for a large "world" in a game would generate large amounts of garbage?
17:22:10 <hackriledge> Nadrieril, I found for return I needed the base case of the data structure to take a parameter, resulting in Crazy
17:22:14 <Nadrieril> monochrom: I'm not sure I understood what you meant
17:22:34 <pilne> or should i mosey on over to haskell-game for that question?
17:24:37 <acertain> hackriledge, sort of, sometimes a library can implement fmap faster in a way that user's can't tell
17:25:24 <acertain> the simplest case being when the inliner doesn't fire somewhere it should in liftM but does in fmap
17:25:58 <acertain> Nadrieril, https://hackage.haskell.org/package/constraints-0.6/docs/Data-Constraint-Forall.html lets you write (ForallF Monoid f) which is (forall a. Monoid (f a))
17:26:59 <hackriledge> Supplying a type parameter to your Nil I think results in a generalisation to my Crazy, st. Crazy = GenericTree Crazy
17:27:20 <Nadrieril> acertain: thx, I'm gonna try that
17:28:58 <Nadrieril> rha, constraints is not in ArchHaskell :(
17:29:07 <hackriledge> Oh no sorry, yours isn't like Free, ok
17:30:51 <hackriledge> Nadreril, Functor f is sufficient no? It allows you to access the neighbors...
17:32:10 <hackriledge> I guess it depends on what instance you intend to write for it, which would specify the required functionality over f.
17:32:13 <Nadrieril> hackriledge: In <*>, I need some way to combine the children of the two trees 
17:32:48 <hackriledge> I don't get forall though, is it basically doing what I just described but for all possible provided instances?
17:32:52 <Nadrieril> I thought about Monoid, it looks the simplest to me
17:33:29 <hackriledge> Monoid (GenericTree a)
17:33:56 <Nadrieril> hackriledge: no, I need a monoid constraint on f
17:34:05 <hackriledge> Oh, Minoid f. Sorry
17:34:36 <Nadrieril> acertain: ghc wants UndecidableInstances to make ForallF Monoid f work, but then he cannot deduce Monoid (f whatever) :/
17:34:45 <hackriledge> If that's the functionality you require I'd say that's sound motivation
17:35:16 <hackriledge> Go with that until you decide you need more rather than trying to prove it's as general as it could be?
17:35:35 <hackriledge> Unless that proof was easy... But I have no clue!
17:35:57 <Nadrieril> thats not the point. "Monoid f" does not make sense, as f is of kind *->*. I need forall x.Monoid (f x) instead
17:36:00 <broma0> I feel like most executable haskell programs (not libs) are generally built around some global monad transformer stack and possibly associated type classes that capture all of the programs side-effects. I'm getting a bit sick of this pattern, and i'm wondering if there are other *standard* ways of designing multi-layer effectful programs. are there? Delimited continuations? 
17:36:08 <acertain> Nadrieril, it shouldn
17:36:35 <hackriledge> Should work without the forall?
17:36:53 <HairyDude> filled out the example http://lpaste.net/148559
17:37:10 <acertain> it shouldn't need UndecidableInstances, but you need to use (exprUsingMonoidInstance \\ (instF :: ForallF Monoid f :- Monoid (f a))) or so to get the instance
17:37:16 <acertain> Nadrieril, ^
17:38:04 <hackriledge> @let data GenericTree f a = Nil | Node a (f (Tree f a))
17:38:05 <lambdabot>  .L.hs:155:35:
17:38:05 <lambdabot>      ‘Tree’ is applied to too many type arguments
17:38:05 <lambdabot>      In the type ‘f (Tree f a)’
17:38:11 <hackriledge> Sorry
17:38:26 <hackriledge> (hackriledge) @let data GenericTree f a = Nil | Node a (f (GenericTree f a))
17:38:39 <hackriledge> @let data GenericTree f a = Nil | Node a (f (GenericTree f a))
17:38:41 <lambdabot>  Defined.
17:40:22 <hunteriam> if anyone feels like helping me install hdbc on windows with stack, let me know
17:40:34 <dmj`> hunteriam: sounds painful
17:40:47 <hunteriam> worse than it should be
17:40:52 <hunteriam> ghc wont acknowledge the dll
17:40:55 <dmj`> hunteriam: what db are you targeting
17:40:55 <hunteriam> or the source
17:40:58 <hunteriam> sqlite3
17:41:07 <acertain> Nadrieril, you might need ScopedTypeVariables to get the a there to work
17:41:25 <dmj`> hunteriam: there is a sqlite pkg
17:41:31 <dmj`> @package sqlite
17:41:31 <lambdabot> http://hackage.haskell.org/package/sqlite
17:41:31 <Nadrieril> acertain: I was getting there indeed :)
17:41:52 <hunteriam> well the problem is that it doesnt htink the sqlite3 c lib is installed
17:42:13 <hackriledge> @let instance forall x. Monoid (f x) => Applicative GenericTree f a where
17:42:14 <lambdabot>  .L.hs:157:29: Not in scope: type variable ‘f’
17:42:14 <lambdabot>  
17:42:14 <lambdabot>  .L.hs:157:61: Not in scope: type variable ‘f’
17:42:39 <hackriledge> I can't get that right in my own...
17:43:12 * hackagebot dixi 0.6.0.3 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6.0.3 (LiamOConnorDavis)
17:43:17 <dmj`> hunteriam: well, that's an issue
17:43:23 <Nadrieril> hackriledge: that's what i've been trying to do, but this doent exist
17:43:38 <Nadrieril> hence my first question a while ago
17:44:11 <hackriledge> And if someone could correct that line it would answer your question?
17:44:42 <Nadrieril> yup
17:44:57 <hackriledge> Anyone? It's not possible?
17:45:21 <Nadrieril> hackriledge: thx for you help, but they have been helping me already
17:47:24 <Nadrieril> @paste
17:47:24 <lambdabot> Haskell pastebin: http://lpaste.net/
17:49:17 <hackriledge> Let me know if you figure out an adequate workaround or can confirm that none is possible. Sorry it's not clear above..
17:49:30 <hunteriam>   Extra-Libraries: sqlite3
17:49:30 <hunteriam> what does this mean in a cabal file?
17:50:03 <monochrom> it refers to a C library known as sqlite3
17:50:17 <monochrom> on linux it means -lsqlite3
17:50:25 <monochrom> I don't know windows.
17:51:51 <hunteriam> i have --extra-lib-dirs pointing to a sqlite3.dll file, why would i get the error that the c library is missing?
17:52:02 <hackriledge> I can confirm many other cases of cabal not working with bindings to dlls
17:52:15 <Nadrieril> acertain: it works :D thx very much
17:52:18 <hackriledge> In Windows
17:52:42 <hunteriam> solution?
17:52:50 <synergistics> Are the lambda terms \ab.ab and \a.a equivalent?
17:52:50 <hackriledge> Linux
17:53:04 <Nadrieril> synergistics: yes
17:53:17 <synergistics> Madrieril: Wonderful!
17:53:40 <Nadrieril> synergistics: it is called alpha equivalence IIRC
17:53:41 <hunteriam> not an option hackriledge 
17:54:14 <hackriledge> Community says your up against a wall then I think
17:54:21 <hunteriam> shame
17:54:30 <synergistics> Madrieril: Wouldn't it be eta equivalence
17:54:32 <hackriledge> Vm
17:54:42 <sm> no it doesn't.. Haskell is above platform bias people
17:55:19 <Nadrieril> synergistics: there's eta reduction, which converts "\x.f x" to "f"
17:55:31 <hackriledge> But then on Windows a vm may not rout to Windows drivers or something I remember like that which was problematic
17:56:02 <hackriledge> So dual boot
17:56:13 <Nadrieril> (btw synergistics, my name starts with "N" ^^)
17:56:14 <hackriledge> And it's exhausted
17:56:37 <hunteriam> its not worth it
17:56:38 <hunteriam> just for dev
17:56:41 <zachk> use virtualization if you don't want to dual boot 
17:56:48 <zachk> get a host for like $5 a month
17:56:49 <hunteriam> installing linux is just not worth it
17:56:50 <synergistics> Madrieril: (\ab.ab)xy = xy, (\a.a)xy = (x)y = xy
17:57:00 <zachk> hey I switched to linux/bsd long ago/dual booted mostly for dev work 
17:57:19 <hunteriam> ive used linux before
17:57:26 <zachk> ubuntu is pretty simple these days
17:57:27 <synergistics> Nadrieril: Oh, sorry!
17:57:41 <pavonia> hunteriam: I had issues installing another SQL library too (without stack, though). My solution is documented here, maybe it is of any help to you: https://github.com/bos/mysql/issues/18
17:57:47 <synergistics> Nadrieril: (tiny fonts)
17:57:52 <Nadrieril> synergistics: I'm sorry, I think I misunderstood you. you were asking if "\a b. a b" is the same as "\a.a" ? the answer is no
17:58:20 <Nadrieril> if only because of arity
17:58:25 <zachk> also for dev work on linux/bsd most of the tools are free as in free beer with source code available 
17:58:30 <synergistics> Nadrieril: Well when applied to two arguments, they have the same effect, correct?
17:58:32 <zachk> not so on windows
17:58:39 <hackriledge> I have never tried fpcomplete, but I understand they have an online Haskell development platform, not sure if they let you hist from their servers
17:58:45 <hackriledge> Host*
17:58:54 <Nadrieril> synergistics: no, because \a.a cannot be applied to two arguments
17:58:58 <zachk> some devs have switched to Mac OSX and they don't have many problems either, it is sort of unix under the hood 
17:59:14 <Nadrieril> you're cheating a bit when you say "'\a.a) x y" -> "x y"
17:59:16 <hunteriam> zachk: ive used linux before
17:59:55 <synergistics> Nadrieril: So then (\a.a)xy would be ((\a.a)x)y
17:59:59 <Nadrieril> synergistics: notice that "\a b. a b" is the same as "\a. \b . a b"
18:00:05 <synergistics> Nadrieril: But I guess you cannot do that?
18:00:12 <synergistics> Nadrieril: Previous comment
18:00:33 <synergistics> Nadrieril: Ah, so this one is actually asking for an argument b, not the other one
18:00:39 <Nadrieril> yes
18:00:45 <hackriledge> Nadrieril, Monad Plus f =>
18:00:54 <hackriledge> MonadPlus*
18:00:57 <ReinH> I already suggested linux. They were rude and dismissive.
18:01:13 <Nadrieril> its easy to see that "\a. \b . a b" and "\a.a" are different, because "\b . a b" and "a" are obviously not the same
18:01:40 <broma0> how can i achieve a "wizard" like effect with haskell's monads? the idea is basically that a computation's environment can change as execution proceeds, and the environmental change "enables" and "disables" various functions in the monad. sort of like the indexed state monad but for the whole transformer stack/env/etc.
18:01:51 <synergistics> Nadrieril: Right. But aren't these eta equivalent?
18:02:00 <ReinH> broma0: can you give an example?
18:02:10 <Nadrieril> synergistics: oh shit you're right x)
18:02:22 <synergistics> Nadrieril: that's why I'm confused XD
18:02:32 <Nadrieril> you're totally right
18:02:44 <Nadrieril> x)
18:02:49 <emmanuel_erc> Hello  there guys!
18:02:54 <synergistics> Hi
18:03:02 <Nadrieril> synergistics: in my defense, its 3am where I live ^^'
18:03:10 <emmanuel_erc> Hi there synergistics!
18:03:19 <synergistics> Nadrieril: Haha, no problem. Thanks for the help in any case!
18:03:37 <Nadrieril> np, I learned something too ^^
18:03:55 <hackriledge> ReinH, it's nice to know exactly when Windows fails, looks like binding to dll is problematic, but it might be possible, and if so, that would be the solution. Use Linux is not really an answer to "can this be done in Windows" which is why it was rejected as an solution. No offense meant
18:04:00 <mniip> well they are slightly different once you dilute your lambda calculus with some other expressions
18:04:02 <emmanuel_erc> I want to ask if my intuition about laziness is not leading me astray while I try to solve a particular problem.
18:04:10 <mniip> and if you introduce bottoms
18:04:52 <hunteriam> and by the way, every question about windows is not an excuse to tell the user theyre on the wrong platform
18:04:58 <Nadrieril> ^
18:05:26 <zachk> true, good luck getting a haskell library to ffi's to c to work on windows though 
18:05:30 <emmanuel_erc> In particular, the problem is simply just finding all the shortest paths on a fully connected undirected graph. My initial attempts were naive (I am using the FGL library, if anyone is familiar with it).
18:05:34 <zachk> that ffi's to... 
18:06:06 <broma0> ReinH: this explanation is getting long, hang on a sec.
18:06:42 <hackriledge> However, since this May be impossible under Windows, an alternative OS is the only pragmatic suggestion. Otherwise the answer is simply, no you can't, or if you can, were don't know how. Which it's pretty informative actually
18:06:58 <synergistics> Nadrieril: Oh, so a clarification. If two terms' bodies are eta equivalent, the terms themselves are also?
18:07:02 <Nadrieril> hackriledge: I think you are just jumping to conclusions here
18:07:05 <sm> hunteriam is right
18:07:09 <hackriledge> It lets you know we lack sufficient experience to help
18:07:29 <broma0> ReinH: sure. if im writing some service that a user interacts with, i generally end up with some "secure" environment that provides the "getCurrentUser" function, and an "insecure" environment that doesnt provide such a function. the user starts out in the "insecure" environment but may do something that adds the "secure" layer, like logging in. in the past, ive written a base monad "Insecure" and a
18:07:31 <broma0> "SecureT" transformer that adds the corresponding "getCurrentUser" function. How can I write one monad - App - that captures both the state where we have access to "getCurrentUser" and the state where we do not? I'm thinking a type family might do, but not entirely sure.
18:07:33 <zachk> so what do you want to do with the combination of haskell and windows? 
18:07:37 <Nadrieril> synergistics: I think yes
18:07:56 <hackriledge> zachk, bind to a specific dll
18:08:05 <ReinH> I didn't tell anyone that they're on the wrong platform. I offered a solution to the problem. That solution wasn't even "switch to linux".
18:08:06 <synergistics> Nadrieril: Lambda calc is so cool, so weird.
18:08:17 <Nadrieril> :)
18:08:24 <zachk> I have never done it, heard it can be impossible/hard or was it making dll's with haskell :D 
18:08:35 <hunteriam> theyre practically the same
18:08:37 <hunteriam> reinh
18:08:41 <broma0> ReinH: obviously getCurrentUser will fail when we're in the state without a current user - i.e. there is still static typing on the changing environment
18:08:48 <ReinH> hunteriam: Running linux in a VM is not practically the same as switching to linux.
18:08:58 <ReinH> It means running an application from windows that will fix your problems.
18:09:05 <hunteriam> youre being pedantic
18:09:08 <ReinH> No, I am not.
18:09:12 <ReinH> It's a material difference.
18:09:18 <sm> you are :)
18:09:22 <ReinH> You can even run it in a window.
18:09:35 <Nadrieril> broma0: I dont think you can switch monads in the same do expression
18:09:37 * zachk likes virtualbox 
18:09:38 <ReinH> It is just an application that you run from Windows that conveniently will get your thing to compile
18:09:45 <hunteriam> moving on
18:09:49 <hackriledge> Packages which do fail under Windows at least some of the time, if not all the time, which we should at least clarify. Has anyone had any success compiling and libraries wrapping a dll in Windows?
18:10:04 <hackriledge> Any*
18:11:22 <hackriledge> Ok, so no, can't help
18:11:38 <hackriledge> Good luck, report back with findings!
18:12:17 <hackriledge> But personally, I abandoned hope of that years ago after wasting weeks over the coarse of years
18:12:48 <broma0> Nadrieril: the goal would not be to switch monads, but to have one monad (possibly indexed) 
18:12:56 <hackriledge> But like I say, I might just be really bad at it!
18:13:02 <sm> a person wants to get Haskell + c libs working in windows; it's supposed to work, has been done by others in the past; they've stated they prefer not to run in a VM or another OS. Constant nagging about their choice makes us look bad
18:13:03 <zachk> you can just put ubuntu in a virtual machine and full screen, unless you want to game from it, then it is kinda sloggy, but the only thing I use windows for anymore on my home computer is when I want to game 
18:13:15 <zachk> sm I guess so
18:13:17 <zachk> which c library? 
18:13:24 <Nadrieril> oh right, I forgot about those
18:13:42 <hackriledge> Any for a start
18:14:01 <ReinH> *sigh* I wasn't constantly nagging anyone. I was responding to statements directed to me.
18:14:37 <hackriledge> *pats ReinH on the back sympathetically*
18:14:43 <Nadrieril> they need rebindablesyntax though
18:14:53 <zachk> try like cabal install wx, see if you can that to build it needs a c library 
18:14:54 <sm> ReinH: not directed at you particularly, but that's the overall effect from the channel, and as each new person notices the thread it tends to repeat
18:15:09 <hackriledge> Wx!!!!
18:15:14 <ReinH> sm: Well, why do you suppose that is happening?
18:15:16 <hackriledge> That was the one!
18:15:21 <zachk> its probably mostly from all of our personal experiences D: 
18:15:24 <sm> I think hunteriam asked at a bad time
18:15:24 <hunteriam> ReinH: ?
18:15:25 <hackriledge> Nearly killed me!!
18:15:34 <zachk> wx did? did you get it to work? 
18:15:38 <ReinH> hunteriam: ?
18:15:40 <hackriledge> No!!!!!
18:15:51 <zachk> same here :( I think I had it working once a few years ago 
18:15:55 <ReinH> sm: If you recall, my first comment on the matter was that I suggested linux and it did not work.
18:16:06 <Nadrieril> broma0: actually I think what you want is the typical example of an indexed monad. but I've never used one, I might not be able to help
18:16:11 <ReinH> By way of forwarning others to not attempt it
18:16:25 <hunteriam> So thats to say this absolutely does not worjk
18:16:26 <hunteriam> ?
18:16:37 <ReinH> hunteriam: Are you asking me?
18:16:50 <zachk> sometimes it just doesn't work, or it might build for a few years, then it breaks D: 
18:18:24 <sm> hunteriam: that SO page was an example of it working for someone. If you figure out paths etc. and get it working once, it should keep working
18:18:42 <hackriledge> We don't know certainly it can't work, only that we have personally not succeeded
18:18:49 <sm> ie, yes it is supposed to work
18:19:08 <sm> GHC/Cabal manuals may have more insight
18:19:09 <hackriledge> And yes, it's the biggest failing of our language I have found
18:19:28 <sm> gtg, good luck, onward to victory
18:19:35 <hackriledge> Huzah!
18:19:35 <ReinH> hackriledge: It is a failing of every other language community I have been involved in as well.
18:19:44 <ReinH> Except for those that are *specifically* windows development communities.
18:19:47 <hackriledge> Interesting
18:19:57 <hunteriam> sm: I have done that
18:19:59 <ReinH> I don't know of a non-MS language that doens't have problems with windows.
18:20:07 <ReinH> (non-MS-supported)
18:20:14 <hunteriam> point?
18:20:36 <hackriledge> We should keep up
18:20:46 <hackriledge> Or outpace
18:20:53 <mniip> ReinH, ANSI C?
18:21:03 <hackriledge> Personally I lack the skill to do this, certainly
18:21:18 <ReinH> mniip: What compiler do you use for ANSI C on Windows?
18:21:27 <mniip> surely msvc can crunch c90?
18:21:39 <ReinH> mniip: Yes, and who made VS?
18:21:42 <mniip> ah right
18:21:45 <mniip> that's what you meant
18:22:19 <hackriledge> So we used to compile to c right?
18:22:43 <hackriledge> Which in this case looks like it would offer a solution
18:22:55 <kadoban> GHC used to have an option to compile to C I believe. IIUC it no longer does.
18:23:02 <hackriledge> And was the motivation for doing that in the first place
18:23:05 <mniip> it was a broken kind of C
18:23:13 <hackriledge> Stg
18:23:20 <hackriledge> ?
18:23:39 <dmj`> kadoban: correct, -fvia-C was removed
18:23:44 <mniip> sorta, the whole thing was a huge hack I heard
18:24:05 <geekosaur> c90 msvc handles. it *still* doesn't do all of c99.
18:24:22 <geekosaur> (this is actively being discussed on one dev list I'm on...)
18:24:26 <ReinH> hackriledge: one of the problems with Windows is that there is no standard library path. Not knowing where to find, say, sqlite, happens to basically everyone. E.g., http://stackoverflow.com/questions/21476943/cmake-gui-specify-library-path-for-windows
18:25:00 <hackriledge> And it's solved?
18:25:15 <ReinH> There are some attempts to improve this, such as pacman, which was suggested. I have no idea if they followed through on this suggestion.
18:25:36 <hunteriam> the problem has not been not knowing where things were
18:26:04 <ReinH> Figuring out how to tell cabal where things are would probably solve the problem. Baiting people into a platform war will definitely not solve the problem.
18:26:09 <geekosaur> actually -fvia-C is still there, but only in unregisterised builds (used for porting to a new platform)
18:26:14 <hunteriam> i also did that reinh
18:26:26 <geekosaur> you generally don;t want to use it for anything else, i generates very portable but extremely slow code
18:26:26 <hackriledge> The thing that fixed my issue was simply moving the sqlite3.dlland sqlite3.def files to C:\Windows\SysWOW64.
18:26:34 <hunteriam> did that too
18:27:13 <kadoban> SysWOW64 … the hell is that? (haven't used windows in a long time)
18:27:29 <StoneToad> I've always wondered if it's syswow cause the dev was mindblown that they were adding 64bit support to window
18:27:33 <hackriledge> Looks like others have this working though which is promising, sorry I should have googled it...
18:27:36 <StoneToad> or if it has a real justification
18:27:42 <ReinH> hunteriam: where is the paste that shows what you have tried and what error you get?
18:27:45 <geekosaur> windows 32 bit under windows 64 bit
18:27:55 <dedgrant> hackriledge: is this an issue with side-by-side linking finding the wrong DLLs with the same name?
18:28:04 <geekosaur> (windows-on-windows is how 64-bit windows deals with 32-bit programs)
18:28:05 <hunteriam> ReinH: http://lpaste.net/148563
18:28:13 * hackagebot radian 0.0.5 - Isomorphisms for measurements that use radians.  https://hackage.haskell.org/package/radian-0.0.5 (TonyMorris)
18:28:54 <StoneToad> geekosaur: ooh so it should be read as something like sysw32ow64
18:28:59 <hackriledge> dedgrant, I'm like, the worst person to ask! Sorry, I have no clue about these things
18:29:00 <geekosaur> and the fact that moving dlls there helped, suggests maybe you're using 32-bit dlls with a 64-bit program?
18:29:09 <StoneToad> that's nicely confusing, has 64 in the name but has 32 bit libs :(
18:30:09 <ReinH> hunteriam: so you didn't actually attempt to pass a library location to stack?
18:30:13 <ReinH> You just called stack build?
18:30:17 <geekosaur> "wow" (windows on windows) gets used for two things: 32-bit stuff in 64 bit windows, and xp emulation on win7+
18:30:20 <hunteriam> ReinH: have you heard of stack.yaml?
18:30:43 <ReinH> hunteriam: a) did you post oyur stack.yaml b) have you heard of not being rude to people who are helping you?
18:30:56 <StoneToad> does anyone know why comonad.com is down? (everything returns 403 forbidden)
18:30:57 <hackriledge> Outch!
18:30:59 <hunteriam> ReinH: http://lpaste.net/148555
18:31:09 <geekosaur> so syswow64 is windows\system for the 64-bit WOW subsystem, and there's another one for the XP emulation WOW subsystem
18:31:35 <kadoban> geekosaur: That sounds confusing.
18:31:36 <codebje> stonetoad, https://www.reddit.com/r/haskell/comments/3zmm91/what_has_happened_to_the_comonad_reader_looks/
18:31:44 <ReinH> hunteriam: insulting people isn't going to make them want to answer your questions.
18:31:46 <ReinH> I'm done.
18:31:49 <hunteriam> lol
18:31:52 <StoneToad> codebje: thanks!
18:32:01 <hackriledge> It's not all that funny
18:32:22 <ReinH> And if you don't think "Have you heard of stack.yaml?" is rude, you need to learn a few things about socializing with other people.
18:32:31 <hunteriam> It was meant to be
18:32:36 <ReinH> I figured as muych
18:32:43 <dedgrant> hackriledge: OK. Generally: https://msdn.microsoft.com/en-us/library/7d83bc18.aspx (or for a more involved description: https://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspx)
18:32:45 <hackriledge> Ok, well you just list my help
18:32:49 <hackriledge> Lost
18:32:56 <ReinH> hunteriam: which is how I know you aren't worthy of help
18:33:07 <dedgrant> hackriledge: Ignore the second link. Wrong page.
18:33:29 <hackriledge> Thanks dedgrant!
18:33:52 <hackriledge> Best to chill
18:34:54 <hackriledge> The directories listed in the PATH environment variable
18:35:11 <hackriledge> Hmmm, so it should certainly find it
18:36:01 <hackriledge> What!!! That's visual studio! How is that relevant?
18:36:48 <hackriledge> It's used in linking somehow? No this is over my head I'm out
18:38:08 <kadoban> Shouldn't I need some extension to use "foreign import javascript unsafe […]" ? It seems to work fine without … but hlint complains it can't parse, it, heh. Hmmm.
18:40:47 <dedgrant> hackriledge: That's not VS-specific. That's a very simplified explanation of how Windows searches for DLLs. The longer story is in the second link I sent.
18:40:56 <hackriledge> Aha
18:41:27 <hackriledge> Then yes, it's surprising it does not find it when placed in  path
18:46:15 <zachk> how do I get my own lambdabot to connect to irc? 
18:46:35 <ackthet> have fun
18:46:40 <zachk> that bad? 
18:46:41 <ackthet> its not super well documented
18:46:49 <ackthet> i manged to figure it out with some googling
18:46:52 <zachk> aight
18:46:58 <ackthet> there is one file thats not on git that has all the server info
18:47:10 <zachk> yea I tried the help command and stuff and it didn't like my irc-connect with args that I chose 
18:49:35 <hunteriam> For those interested: stack build --ghc-options="-IC:\sqlite3"
18:50:05 <zachk> @ticker ^IXIC
18:50:05 <lambdabot> ^IXIC: 4835.76 -55.67 (-1.14%) @ 1/6/2016 5:15pm
18:50:10 <zachk> no shit
18:50:35 <zachk> http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS from here
18:50:46 <zachk> still doesn't tell me to how to connect :-/
18:50:51 <zachk> at least it builds these days
18:52:45 <hackriledge> hunterism, thanks!
18:53:27 <hackriledge> IC:/ ?
18:54:08 <hunteriam> hackriledge: -l links in directories for ghc, C:\sqlite3 contains the dlls
18:54:13 <geekosaur> that's still online?!
18:54:13 <hackriledge> Maybe this will work with wx?
18:55:11 <geekosaur> and the reason it doesn't say much about connecting is that I only got it to work by trial and error and still don't understand it...
18:56:20 <geekosaur> zachk, what did you try for @irc-connect?
18:56:22 <hackriledge> Strange it doesn't get the Windows Path...
18:56:37 <geekosaur> also I think that stuff may have changed; it's been years since the version documented there
18:57:05 <hackriledge> But good that -I works, a simple workaround!
18:57:17 <zachk> geekosaur I forget atm
18:57:41 <zachk> it just keeps talking about bogus server atm, trying @join 
18:58:17 <geekosaur>   @irc-connect freenode irc.freenode.net 6667 mybotnick this_shows_as_the_realname
18:59:02 <geekosaur> the bare "freenode" there is the server name used internally by bot commands, so you can if needed change the host without having to rewrite everything else to reference it
18:59:41 <zachk> and that was not documented at all, geekosaur 
18:59:45 <geekosaur> or connect multiple times, which used to be necessary on freenode because there was like a 20-channel limit
19:00:39 <geekosaur> yes, as I said earlier [07 02:54] <geekosaur> and the reason it doesn't say much about connecting is that I only got it to work by trial and error and still don't understand it...
19:01:02 <geekosaur> (that page you referenced is mine, and about a decade old; I'm not at CMU any more...)
19:01:23 <zachk> are you from #dutch-hack as well? 
19:01:35 <geekosaur> no
19:05:04 <zachk> and it dies on > 2 + 2 -_- mueval-core: Time limit exceeded
19:05:12 <zachk> prolly need to set that 
19:09:33 <exio4> geekosaur: there's still a limit but it is at 140 channels or so :P
19:14:42 <hunteriam> C:\Users\thepr\CompSci\Artstagram\sasher\src\Sql.hs:8:47:
19:14:42 <hunteriam>     lexical error in string/character literal at character '\r'
19:14:49 <hunteriam> \r?
19:16:03 <glguy> \r is a "carriage return" and the first half of a newline in Windows text files
19:16:59 <glguy> You probably forgot to terminate your string literal with a "
19:17:09 <geekosaur> translation: you have an unterminated string somewhere
19:17:36 <glguy> Probably on line 8
19:18:14 * hackagebot radian 0.0.6 - Isomorphisms for measurements that use radians.  https://hackage.haskell.org/package/radian-0.0.6 (TonyMorris)
19:26:12 <hunteriam> multi-line strings?
19:27:08 <geekosaur> there aren't any, as such. there are string gaps but most people think tye're ugly
19:27:41 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
19:28:12 <geekosaur> *they're
19:28:57 <geekosaur> there's also some TH hackery, search for 'here document' on hackage
19:30:46 <geekosaur> (well,quasiquoter hackery)
19:31:16 <kadoban> heredocs are really cool. I've used that hackery, it worked pretty nice. It's kind of unsatisfying that you need quasiquoters for it … but then you don't often need it either.
20:07:30 <hunteriam> no form of overloaded record fields are available yet?
20:08:05 <StoneToad> there are several?
20:08:40 <StoneToad> lens will automatically declare the typeclasses for you if you ask it to
20:08:49 <kadoban> Is that still coming in ghc 8, or did it get put off? I saw that one part was in I though, but I didn't really understand.
20:09:33 <geekosaur> full overloaded record fields isn't going to make ghc8
20:09:39 <geekosaur> but it's still being worked on
20:09:47 <kadoban> Ah, thanks.
20:10:35 <geekosaur> (ghc8 has branched, they're working on getting an rc out)
20:11:00 <kadoban> Nice! Pretty exciting stuff.
20:11:49 <StoneToad> http://statusfailed.com/blog/2013/02/19/overloading-record-fields-with-lens.html
20:12:10 <StoneToad> in the mean time you can hack around it
20:13:37 <hunteriam> is the solution the one that headlined reddit way back when?
20:18:51 <kadoban> Oo, I didn't realize MonadFail was making it into ghc8, that's neat. At least the first part or whatever.
20:26:22 <xv_ir> what are people using for rest clients thesee days? servant? conduit-http? wreq?
20:26:57 <dmj`> I use servant
20:28:09 <Clint> http-client
20:28:40 <xv_ir> servant looks really impressive! but as a relative beginner with project deadlines I'm a bit afraid of getting stuck on the type level combinator magic the minute i go beyond monkey-see monkey-do examples
20:29:24 <xv_ir> what do you guys think of wreq?
20:29:43 <Xe> servant makes it easier
20:29:59 <Xe> it takes a few hours to understand it, but once you do it becomes a godsend
20:30:01 <hackrilege> Doh I had my nic spelled wrong in my spellchecker!
20:30:11 <hackrilege> http://lpaste.net/revision/148575
20:30:14 <dmj`> xv_ir: what exactly do you need to do? I'd argue servant is simpler
20:32:09 <hackrilege> Ok, what I had earlier was isomorphic to Tree basically, this is better. it has the second, Free-like, direction of traversal
20:32:40 <hackrilege> And is thus crazy in the desired sense
20:32:58 <xv_ir> xe dmj` working on a layer of types and functions to generalize aggregation and compose across multiple domain-specific rest services
20:33:10 <Xe> xv_ir: you probably want servant ten
20:33:13 <Xe> then*
20:33:16 <dmj`> yea def. servant
20:33:22 <Xe> it can derive the client code for you
20:33:26 <Xe> so you cannot fuck it up
20:34:31 <hackrilege> Oops, this link http://lpaste.net/148575
20:34:46 <xv_ir> what's the problem with wreq? right now i've got some basic requests working, but i'm fighting a bit with aeson to get it working  beyond the trivial examples
20:35:09 <Xe> xv_ir: it's manual implementation and you can mess it up
20:35:28 <Xe> we live in 2016, the compiler should be able to abstract away things like that in the type system
20:35:44 <hackrilege> And it had a fatal mistake.. Sorry, back soon
20:35:51 <Xe> and it uses lens
20:35:53 <dmj`> yes compilers should save computers from humans
20:35:56 <Xe> some people find lens hard to read
20:36:24 <xv_ir> i'm definitely very end-user lens. question about servant...
20:36:40 <xv_ir> so i get that you declaratively specify the response data
20:37:06 <xv_ir> however some of the rest services i'm talking to have pretty complex/deeply nested queries
20:38:22 <hackrilege> Actually I'm pretty confused about something, how does MonadPlus get the type of a? I can't use the Monoid constraint the way I would like
20:38:34 <xv_ir> it's probably not practical to write out a specification for the entire service. using wreq/aeson i can see how i might pull out a few pieces of particular responses
20:39:00 <hackrilege> Namely, to provide Monoid operations which can be lifted
20:39:02 <xv_ir> but i'm not sure how that would be expressed in servant's declarative style
20:39:07 <ontop> WELP. Time to start the irc bot guys.
20:39:18 <hackrilege> Coool!
20:39:37 <ontop> stack new > cabal init?
20:39:44 <Xe> yes
20:40:15 <dmj`> xv_ir: your service has a specification wether you formalize it or not. Formalizing will make life easier for you. Note, you still have to declare From/ToJSON instances w/ for your types, you can also still use lenses w/ your json (when using servant)
20:40:29 <dmj`> wheter*
20:40:31 <xv_ir> ontop i've switched to stack. now that the've patched a few bug fixes it's a preetty  smooth transition
20:40:38 <dmj`> wether*
20:40:52 <dmj`> whether* :)
20:40:54 <ontop> Is there like a huge effort to move to stack and abandon Cabal?
20:41:02 <ontop> Why is Cabal so bad or undesirable? Just curious.
20:41:12 <Xe> cabal hell
20:41:14 <StoneToad> ontop: which cabal is 'Cabal' to you?
20:41:15 <xv_ir> ontop  it's built on top of cabal
20:41:19 <dmj`> stack still uses Cabal, but it replaces cabal-install I think
20:41:21 <StoneToad> there's 3 things with the name cabal
20:41:29 <ontop> That's insane :D
20:41:29 <xv_ir> super confusing :(
20:41:36 <dmj`> not really
20:41:38 <ontop> Okay, well I'm talking specifically about the tool "cabal"
20:41:45 <xv_ir> well not for us, we're used to it
20:41:47 <dmj`> the library is Cabal, the executable is cabal-install
20:41:48 <ontop> It seems like people are using "stack" as a replacement.
20:41:58 <StoneToad> stack replaces cabal-install
20:42:01 <ontop> Ok
20:42:01 <StoneToad> not Cabal library
20:42:03 <ontop> Gotcha
20:42:06 <ontop> Cabal library being?
20:42:08 <StoneToad> (which it uses)
20:42:11 <xv_ir> but fuck imagine going to the javascript community and they tell you some shit like "oh there's really 3 npms"
20:42:22 <xv_ir> "they all have the same name but they're really different"
20:42:28 <StoneToad> they dont' actually ahve the same name
20:42:40 <StoneToad> and why did my firefox hang :(
20:42:43 <xv_ir> i don't think we'd have much patience for that.
20:42:57 <ontop> I don't have much patience for this.
20:43:00 <ontop> But if you tell me stack is the thing
20:43:01 <ontop> Then I'm ok
20:43:09 <ontop> I made a project. But I don't like the name. Remaking.
20:43:26 <ontop> What do haskell users code in? Vim? Atom? Sublime? Emacs? Is there a survey somewhere?
20:43:32 <ontop> It's always cool to see the preference of language groups.
20:44:26 <mooncake> ：）
20:44:31 <xv_ir> dmj` so in wreq you can use lens on the aeson Value to pick out the chunk corresponding to the data of interest so i only define an ADT for that.
20:44:34 <dmj`> ontop: emacs / vim mostly
20:44:53 <xv_ir> dmj` so i should be able to do something equivalent for servant? basic question, i know...
20:44:58 <ontop> I'm a die-hard vim user. But somehow I've been coding on windows with Atom recently with vim mode and I haven't died.
20:45:00 <StoneToad> leksah is neat when it works (havn't tried in a while)
20:45:21 <xv_ir> ontop i like spacemacs
20:45:22 <dmj`> xv_ir: no reason you couldn't use lenses w/ the json returned by servant.
20:45:23 <ontop> How the heck do you parse a toml file in Haskell? What's the result of that? :|
20:45:32 <StoneToad> toml?
20:45:37 <ontop> Yea\
20:45:44 <ontop> https://hackage.haskell.org/package/htoml
20:45:45 <ontop> Maybe this.
20:45:46 <xv_ir> ontop as a longtime emacs user, it was worth the few weeks of reduced productivity
20:46:06 <ontop> xv_ir: What's so good about spacemacs?
20:46:21 <hunteriam> vim
20:46:23 <hackrilege> OK! This is it, I'm sure this time!!! http://lpaste.net/148577 could someone check the sanity of this structure? It's supposed to be a generic Monad Monoid Free Tree
20:46:26 <hunteriam> im excited for you ontop
20:46:54 <xv_ir> dmj` in servant i can get the json blob without declaring the type? is there an example of this somewhere? all the beginner tutorials i saw go straight to the type declaration magic...
20:47:31 <hunteriam> the json blob!
20:47:32 <hunteriam> ?
20:47:33 <ontop> hunteriam: y?
20:47:41 <xv_ir> ontop personally i did ~4 years vim -> IDEs -> ~4 years emacs. i like emacs, but the navigation never was up to
20:47:57 <xv_ir> ontop vim's "grammar of movement" level of composability
20:48:01 <ontop> I can't live without vim navigation. It's jsut so ingrained man :(
20:48:09 <ontop> I feel like a sloth without it now.
20:48:22 <ontop> What's really f'd though, is I learned vim keybinds all in dvorak.
20:48:31 <ontop> I never remapped anything lol
20:48:32 <xv_ir> ontop oh that's good. spacemacs/evil emulates vim pretty deeply
20:48:40 <xv_ir> not like those IDE fakevim emulations
20:48:40 <dmj`> xv_ir: it's not magic, there's a good video on it, you should watch it. It demystifies the magic. 
20:48:56 <ontop> How do I specify a dep in Stack?
20:49:07 <ontop> extra-deps: [htoml >= 0.1.0.3]
20:49:10 <ontop> It's sad :(
20:49:11 <hunteriam> what os the json blob xv ir
20:49:13 <dmj`> xv_ir: https://www.youtube.com/watch?v=gMDiKOuwLXw
20:49:18 <xv_ir> dmj` which one? note i'm at beginner-intermediate stage
20:49:19 <ontop> Oh it's yaml
20:49:23 <hackrilege> For those of you who would prefer I prove the laws hold before they consider it, iv had a go and it looks ok, I'm having snacks, then I will give it another go
20:49:23 <hunteriam> ontop the .cabal file
20:49:31 <ontop> Oh wat
20:49:35 <ontop> There's a cabal file here
20:49:41 <xv_ir> hunteriam operationally json blob = Aeson object...
20:49:47 <dmj`> xv_ir: it targets beginners
20:50:25 <luigy> is that you in the video dmj` ?
20:50:43 <ontop> Is there a list of categories for cabal files somewhere?
20:50:45 <dmj`> luigy: shameless plug I guess =)
20:50:50 <ontop> Or do I just write whatever I want?
20:51:01 <hackrilege> I guess the broadest question I can ask is does this look broken for any reason? I mean is it useless despite following the laws, and as always, had anyone seen it before...
20:51:06 <hackrilege> http://lpaste.net/148577
20:51:38 <xv_ir> ontop spacemacs is pretty good. full disclosure only thing to watch out for is that it can feel a bit sluggish initially, but running emacs in client-server mode helps a bit. stsill wish it was a bit more responsive.
20:51:49 <hackrilege> It's crazier than the version I was using earlier
20:51:49 <ontop> Ah
20:53:09 <ontop> So, using stack - if I declare a dependency in whatever.cabal, do I run cabal install --deps or stack somethingL?
20:53:26 <ontop> Guess I should open the docs for this thing.
20:53:28 <kadoban> ontop: No, you don't do anything extra. You just … build you package again if you want.
20:53:34 <kadoban> ontop: your*
20:53:36 <ontop> Ok
20:54:06 <kadoban> The only thing extra you ever have to do is, if the dependency isn't in the resolver you're using, you have to add it to stack.yaml too (to tell it what version to use and/or where to get it)
20:54:26 <glguy> You put the versions of packages your library supports in the .cabal file
20:54:37 <glguy> the stack.yaml is just transient data about your current environment
20:55:18 <ontop> Interesting.
20:55:46 <xv_ir> dmj` i saw some of this a while back it looked great, but i'll re-watch now that i have a bit more hands on experience
20:56:15 <kadoban> glguy: If you're trying to use some package that's in hackage but not stackage, you need to specify a version in the stack.yaml extra-deps so it knows which to use. Or you can do it other ways like specifying a git repo and commit to use, etc.
20:56:46 <dmj`> xv_ir: sounds good, join us in #servant too
20:57:16 <glguy> kadoban: sure, but that's not to say which version range you support, just which one you happen to be using locally
20:58:17 * hackagebot turtle 1.2.5 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.2.5 (GabrielGonzalez)
20:59:09 <ontop> Ugh.
20:59:14 <ontop> Atom is being a pile of garbage with ghc
20:59:19 <ontop> ghc-mod that is.
20:59:31 <ontop> This hasn't happened yet with a pure cabal project
20:59:34 <ontop> :(
21:00:56 <hackrilege> Oh man, I really can't figure this out! If a Monad of a Monoid is a Monoid, I can't use mappend within the Monad instance because I can't supply the Monoid a constraint :(
21:01:43 <kadoban> glguy: It's more than "which one you happen to be using locally", the idea is that anyone can use it to repeatably build the thing.
21:01:49 <hackrilege> Like, the problem I'm hitting I'm the above paste
21:01:55 <xv_ir> dmj` what is this :~> natural transformation, what's the context in which one transforms one monad into another?
21:02:09 <kadoban> ontop: Which ghc-mod are you using? A recent one? And what's going wrong?
21:02:25 <ontop> https://github.com/atom-haskell/haskell-ghc-mod/issues/83
21:02:28 <ontop> Seems to be this issue.
21:03:15 <hackrilege> Sorry for the spam :(
21:03:39 <kadoban> Doesn't look too fun. No idea about that.
21:03:43 <ontop> Yea.
21:03:45 <ontop> Looks super lame.
21:03:50 <ontop> I really like this plugin too
21:03:56 <ontop> Gives me lots of nice information
21:04:07 <ontop> Guess I'll switch to cabal only and see if that helps.
21:04:48 <kadoban> ontop: I wouldn't imagine it would, since a stack project is also a cabal-install project.
21:05:09 <dmj`> xv_ir: could be any higher kinded type really. It's not specific to monads per se. Just any higher kinded type of the form (m :: * -> *) (a :: *) :~> (n :: * -> *) (a :: *)
21:05:11 <ontop> I've made cabal projects with no problem before. I'll fire up a main and see.
21:06:25 <dmj`> xv_ir: in servant you'd probably want to use that when you need a monad stack more sophisticated than EitherT ServantErr IO a
21:06:30 <dmj`> the video goes into that though
21:08:22 <xv_ir> dmj`  i think that's where i got lost last time. not familiar with :~> arrows yet ... ~ page 900 in chris's book is roughly my current level of proficiency
21:09:56 <dmj`> xv_ir: let's take a simpler example then
21:10:00 <ontop> kadoban: Works without a stack project :|
21:10:33 <kadoban> ontop: You just delete the stack.yaml and it works?
21:11:02 <ontop> No, I just delete the folder and cabal init
21:11:06 <ontop> And I don't have any problems
21:11:47 <dmj`> @def eitherToMaybe :: Either a b -> Maybe b; eitherToMaybe (Left _) = Nothing; eitherToMaybe (Right x) = Just x
21:11:49 <lambdabot>  Defined.
21:12:00 <dmj`> > eitherToMaybe $ Right 4
21:12:02 <lambdabot>  Just 4
21:13:10 <xv_ir> dmj` ok that makes sense
21:13:45 <dmj`> xv_ir: this would fit (:~>) :: m a -> n a. To make it more specific we could say Either a :~> Maybe
21:16:44 <xv_ir> oh so :~> is expressing functions of kind * -> * ?
21:18:35 <dmj`> xv_ir: It express a function that goes from a type of kind (* -> *) to (* -> *). The type being defined infix might be making things blurry
21:19:11 <dmj`> @def newtype Nat m n = Nat { forall a . m a -> n a }
21:19:11 <lambdabot>  Parse failed: Parse error: a
21:19:23 <dmj`> @def newtype Nat m n = Nat { forall a. m a -> n a }
21:19:23 <lambdabot>  Parse failed: Parse error: a
21:19:38 <dmj`> @def newtype Nat m n = Nat { unNat :: forall a. m a -> n a }
21:19:40 <lambdabot>  Defined.
21:20:00 <dmj`> :k Nat 
21:20:00 <xv_ir> dmj` yes sorry that's what  i meant (* ->*) -> (* ->*) . why is it useful to have a new symbol for that, isn't -> sufficient?
21:20:02 <lambdabot> (k -> *) -> (k -> *) -> *
21:20:30 <dmj`> It's poly-kinded in this case, I think lambdabot has DataKinds on
21:20:53 <dmj`> :k Nat (Either String) Maybe
21:20:55 <lambdabot> *
21:21:40 <dmj`> :t Nat
21:21:42 <lambdabot> forall (k :: BOX) (m :: k -> *) (n :: k -> *). (forall (a :: k). m a -> n a) -> Nat m n
21:21:59 <dmj`> :t Nat eitherToMaybe
21:22:01 <lambdabot> Nat (Either a) Maybe
21:22:15 <dmj`> xv_ir: ^ does that make sense there
21:22:25 <dmj`> Nat holds the transformation
21:22:56 <xv_ir> just tried in ghci and
21:23:18 * hackagebot pipes-concurrency 2.0.5 - Concurrency for the pipes ecosystem  https://hackage.haskell.org/package/pipes-concurrency-2.0.5 (GabrielGonzalez)
21:23:28 <xv_ir> this makes sense after your maybe either example. Nat :: (forall a. m a -> n a) -> m :~> n
21:23:34 <xv_ir> what does it mean to "hold the transformation"?
21:24:44 <xv_ir> i hadn't seen/used the forall syntax before, it makes sense that the either -> maybe function is an instance of this transformation
21:25:01 <ontop> Welp. Stuck at parsing toml.
21:25:03 <ontop> life is hard.
21:25:13 <ontop> Do I have to name my files and modules all upper-case?
21:25:19 <ontop> The unix user inside my is screaming out loud.
21:25:27 <ontop> me*
21:25:35 <xv_ir> maybe this is the crux of it. i'm used to types being instance of typeclasses, but i haven't seen functions as being instances of anything yet
21:25:58 <xv_ir> so is a transformation like a generalized class of functions?
21:26:22 <xv_ir> which have the same kind signature?
21:28:11 <dmj`> xv_ir: natural transformations are known from category theory, in the category of categories (called Cat), objects are categories, morphisms are functors, and natural transformations I believe (someone can correct me or expound), are the composition of functors. I think it's a pretty fundamental notion in category theory. Haskell only operates 
21:28:41 <dmj`> in the Hask category, where objects are types, morphisms are functions and (.) is the composition of those functions
21:30:01 <ontop> What is Text, and why is it different than string?
21:30:06 <ontop> String*
21:30:25 <dmj`> xv_ir: natural transformations aren't specific to Cat though, and exist elsewhere
21:30:36 <xv_ir> dmj` that's strange. i think of functors as a typeclass. so how can it be that morphisms map to functors in category theory and morphisms map to functions in haskell?
21:31:17 <ReinH> functions are morphisms in one category and functors are morphisms in another category
21:32:46 <dmj`> xv_ir: what ReinH said =)
21:32:50 <dmj`> ReinH: hi o/
21:32:58 <ReinH> dmj`: \o
21:33:44 <ReinH> Functor is a typeclass for things which can be fmapped. It also aligns with a particular sort of functor in a particular category (Hask, as mentioned)
21:33:47 <xv_ir> dmj` ReinH I feel like i'm looking up words in a dictionary to find more words i don't understand. to be expected as a beginner i guess.
21:34:38 <nocturne777> I came across this article here: https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices. It basically syas that wrapping an EitherT around a transformer stack that has IO is wrong
21:35:01 <dmj`> xv_ir: functions are really just functors in Haskell. Where fmap = (.)
21:35:11 <nocturne777> since any kind of error could be thrown from the IO layer
21:35:16 <nocturne777> it suggests instead using MonadThrow typeclass 
21:35:26 <xv_ir> ReinH i believe you and I have a vague inkling that they're related. but it's not clear how. dmj` oh! let me think about that
21:35:42 <ReinH> dmj`: how?
21:35:48 <ReinH> functions are functors in what category?
21:35:55 <ReinH> oh
21:35:56 <ReinH> I see what you mean
21:36:09 <ReinH> but that's a weird way of saying it
21:36:47 <xv_ir> like (id <$> const) 4 2
21:36:48 <xv_ir> hmm
21:37:00 <dmj`> ReinH: yea, maybe I should have just said that (->) is an instance of Functor
21:37:44 <xv_ir> that makes sense, i remember this being bought up chris's book actually
21:37:53 <ReinH> Welll, ((->) a) is an instance of Functor
21:38:10 <ontop> xv_ir: I just read that in Chris' book!
21:38:13 <xv_ir> but it still hurts my brain a bit if i think more about about it
21:38:22 <ReinH> (->) has the wrong kind
21:38:26 <xv_ir> like so can -> be considered some kind of data constructor?
21:38:28 <dmj`> ReinH: ah yea, kind error 
21:38:30 <hunteriam> I wanna use the authorization header in servant according to https://en.wikipedia.org/wiki/Basic_access_authentication , is there Base64 decoding for Text somewhere?
21:39:25 <dmj`> @package bytestring-base64
21:39:26 <lambdabot> http://hackage.haskell.org/package/bytestring-base64
21:39:39 <dmj`> :t Data.Text.Encoding.decodeUtf8
21:39:40 <ReinH> hunteriam: base64 is an encoding for binary data. Text is not binary data.
21:39:41 <lambdabot> BSC.ByteString -> Data.Text.Internal.Text
21:39:49 <xv_ir> and it's just weird that on one hand functions are data and have data-like properties. but in haskell a function seems to have properties that data can't have
21:39:51 <hunteriam> thanks
21:40:13 <dmj`> hunteriam: servant-0.5 will have that, and it's being released soon
21:40:20 <xv_ir> like you can apply a function, but you can't "apply" a value of any other type right?
21:40:22 <hunteriam> :)
21:40:30 <ReinH> xv_ir: yes, that is what makes them functions.
21:41:43 <ReinH> (->) is a type constructor, not a data constructor
21:43:37 <xv_ir> ReinH so a function is a type, but it also has special semantics that no other type can have.
21:44:20 <xv_ir> is application the only special property of functions or is there anything else?
21:45:03 <xv_ir> ontop lot of people seem to be reading chris's book right now it seems.  it's hit some sort of adoption inflection point over the holidays :-)
21:45:14 <verement> :t 2 3
21:45:15 <lambdabot> (Num a, Num (a -> t)) => t
21:45:16 <ontop> xv_ir: It seems like a good book.
21:45:21 <ontop> :t fromList
21:45:22 <lambdabot> IsList l => [Item l] -> l
21:45:29 <ontop> Welp. fromList just broke my head.
21:45:52 <verement> Is there a link for this book somewhere?
21:45:54 <ReinH> luckily it isn't something you should care about.
21:46:28 <ontop> verement: Can't find it :(
21:46:44 <xv_ir> ReinH beginners like us don't know the boundaries of what does/doesn't need to be cared about =P
21:46:47 <ontop> Wait
21:46:48 <ontop> I found it
21:46:48 <ontop> http://haskellbook.com/
21:46:55 <hunteriam> dmj`:  should I encodeUtf8 the Text containing the Base64 string?
21:47:10 <verement> ontop: thanks!
21:47:12 <ontop> ReinH: This library gave me back this thing and it hurts my brain to consider what I have to do with it.
21:47:15 <xv_ir> yes. verment it's rough around the edges, but right now, but even so it's currently the most padagogically sound learning path
21:47:22 <xv_ir> verement
21:47:39 <ontop> http://lpaste.net/3628052303354789888
21:47:41 <ontop> Look at that thing.
21:47:46 <ontop> It hurts so bad.
21:48:05 <hunteriam> break it down
21:48:11 <hunteriam> into smaller funcrtions
21:48:16 <xv_ir> ontop that's how i feel working through aeson and rest clients the first time.
21:48:23 <hackrilege> Yeah!!!! Check This Out!!! http://lpaste.net/148575
21:48:32 <ontop> hunteriam: What do you mean?
21:48:38 <ontop> I mean.. I didn't make that.
21:48:49 <ontop> It's just this weird data thing that came out of this library function call to parse a toml file.
21:48:58 <ReinH> ontop: That isnt' that fromList, that's how show for Data.Map works.
21:49:07 <ontop> Oh, really?
21:49:17 <xv_ir> i'm sure it gets easier with practice but wading through the tutorials figuring it out the first time is slow going
21:49:19 <ontop> I mean a Data.Map makes a LOT more sense in this context.
21:49:26 <ReinH> It shows the association list of keys and values with fromList in front so it works as a valid haskell expression
21:49:36 <ReinH> with Data.Map.fromList
21:49:55 <hunteriam> dmj`: is it inefficiernt to encodeUtf8 the text of the base64 string, parse it and then decodeUtf8? it feels inefficient
21:50:03 <ReinH> > M.singleton 1 "foo"
21:50:05 <lambdabot>  fromList [(1,"foo")]
21:50:15 <ReinH> :t M.fromList [(1,"foo")]
21:50:16 <lambdabot> (Num k, Ord k) => M.Map k [Char]
21:50:41 <ReinH> > M.lookup 1 $ M.fromList [(1,"foo")]
21:50:42 <lambdabot>  Just "foo"
21:50:44 <ReinH> and so on
21:51:07 <ontop> Kewl.
21:51:11 <hackrilege> ReinH I did it! Check it out! http://lpaste.net/148575
21:51:31 <ReinH> hackrilege: Wow, you sure did write some code.
21:51:45 <ReinH> I am trying to say nice things as a new years resolution.
21:52:26 <hackrilege> Seriously though, this thing will have your arm off!!!
21:52:33 <ReinH> hackrilege: seriously though I have no idea what's going on :)
21:52:50 <hackrilege> It's going mental, honestly
21:53:18 <hackrilege> So much base case
21:53:39 <ontop> Yeah
21:53:45 <ontop> That looks like all the haskell I ever see alright.
21:53:54 <ReinH> hackrilege: https://pbs.twimg.com/media/CXkaraZWYAE2wVk.jpg:large
21:54:01 <hackrilege> It's like a totally pimped out recursion scheme
21:54:20 <ontop> Okay I'm in trouble boys :(
21:54:38 <hackrilege> Condescension is almost nice...
21:54:46 <ReinH> it's supposed to be funny...
21:54:50 <ReinH> hackrilege: source http://mathwithbaddrawings.com/2015/12/30/a-mathematicians-new-years-resolutions/?utm_content=bufferba3a7&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer
21:54:59 <dmj`> hunteriam: yes, you can encode/decode like that. As to efficiency, I'm not sure what you're trying to do
21:55:09 <hunteriam> dmj`: the wikipedia thing i linked
21:55:19 <hackrilege> I'm a physicist and that's how my fault treat me and it makes me feel alienated and alone!
21:55:27 <hackrilege> Family*
21:55:49 <ReinH> hackrilege: if you're a physicist then you should be used to that treatment from the maths people ;)
21:55:56 <hackrilege> Anyway, how badass is that thing!?
21:55:57 <dmj`> hunteriam: I think it will be fine
21:56:04 <ReinH> hackrilege: Well, it sure is ass, at least.
21:56:10 <dmj`> ReinH: heh
21:56:10 <hackrilege> !!!!!
21:56:13 <ReinH> hackrilege: <3
21:56:21 <ReinH> hackrilege: I mean that's halfway there
21:56:31 <hackrilege> Bahahaha
21:56:43 <hackrilege> It's not bad?
21:57:22 <ReinH> either half, really
21:57:43 <hackrilege> It's definitely badass, I have a keen sense for these things, but unless you agree, then I can't tell my prof that the core Haskell community thinks it's badass
21:57:59 <ReinH> hackrilege: I mean, it's a thing. I'm not sure if it's useful, but it's definitely a thing, and that's what matters.
21:58:20 <hackrilege> Well at least it's a thing I suppose
21:58:27 <ReinH> hackrilege: Maybe it's useful!
21:58:34 <hackrilege> I'd like to at least think it's dangerous
21:59:19 <ReinH> hackrilege: maybe you can explore it more and find out some cool properties or uses.
21:59:21 <hackrilege> I guess I would hope for some constructive commentary, but a high five would suffice
21:59:56 <ReinH> Or you could try to prove the laws for the typeclasses you wroute
22:00:34 <hackrilege> I think it needs more control. Since there are two directions to mplus in really. I think it motivates MonadPlusPlus as a superclass
22:00:58 <hackrilege> Yeh the laws hold I suspect
22:01:04 <ReinH> suspecting isn't proving
22:01:04 <hackrilege> !!!
22:01:12 <hackrilege> Strongly suspect
22:01:18 <ReinH> Ditto.
22:01:24 <hackrilege> Have proved
22:01:27 <ReinH> Show me
22:01:57 <hackrilege> Yeh, tomorrow, I just always get excited prematurely
22:02:23 <hackrilege> Any thoughts on MonadPlusPlus?
22:02:49 <ReinH> None as of yet.
22:02:58 <hackrilege> And a better name for the thing, now we can see what it does?
22:03:04 <ReinH> But I suppose it is somehow like C++.
22:03:16 <hackrilege> 4 the lols
22:03:21 <ReinH> Well, maybe you can see what it does. I can't.
22:03:35 <hackrilege> Oh
22:03:39 <ReinH> It might be interesting to see if it has any interesting structure. You could try to, e.g., take the derivative.
22:03:51 <hackrilege> http://lpaste.net/148575
22:04:02 <hackrilege> Derivative?
22:04:02 <ReinH> hackrilege: yes, I can see it.
22:04:15 <hackrilege> Just a bump for any spectators
22:04:33 <ontop> So, Go has something called goimports for adding things you need/want automatically to your stuff
22:04:36 <hackrilege> Link about derivative
22:04:37 <ontop> Is there anything like that for cabal?
22:04:48 <ontop> I'm basically going to murder myself if I have to append one more line to this :(
22:05:00 <hackrilege> Desist!!
22:05:19 <ontop> Desist?
22:05:29 <hackrilege> Don't do the murder
22:05:32 <ontop> Oh.
22:05:34 <ReinH> hackrilege: http://stackoverflow.com/questions/25554062/zipper-comonads-generically/25572148#25572148 http://strictlypositive.org/derivcont.ps.gz http://conal.net/blog/posts/differentiation-of-higher-order-types  http://stackoverflow.com/questions/12963733/writing-cojoin-or-cobind-for-n-dimensional-grid-type 
22:06:01 <hackrilege> Thanks!
22:06:05 <ReinH> hackrilege: it's fun stuff
22:06:10 <hackrilege> Awesome times
22:06:22 <ReinH> Plenty of rathole there for you :D
22:06:49 <ReinH> ontop: that should like a good tool that haskell should have please do so.
22:06:52 <ReinH> ontop: :D
22:06:57 <hackrilege> basically this is a tree where every node is a tree and it's neighbors are contained within a tree
22:07:07 <ontop> :|
22:07:25 <ReinH> s/should/sounds
22:07:47 <ontop> Crap
22:07:48 <ReinH> ontop: haskell-mode for emacs will do it for you to some extent
22:07:55 <ontop> I think I need a monad, but I have no idea how to do it
22:08:02 <ReinH> ontop: a monad for what?
22:08:15 <ontop> Well, basically I want to take this map that you saw earlier
22:08:21 <ontop> And do a lookup on all the values
22:08:29 <ontop> And put them into a data thing.
22:08:43 <ReinH> A "data thing"?
22:08:51 <hackrilege> :t traverse
22:08:51 <ontop> data Config = Config { props.... }
22:08:52 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:09:03 <ontop> Oh god, that's the chapter I skipped in the book!
22:09:10 <ReinH> ontop: can you write the type for the function you should have?
22:09:10 <ontop> Don't make me use traversable :(
22:09:26 <hackrilege> I don't know if that's what you want but I bet it's close
22:09:31 <ontop> makeConfig :: Either E.ParseError Table -> Maybe Config
22:09:33 <ontop> I have that right now
22:09:35 <ontop> But it's making me sad
22:09:39 <ReinH> and what is Config?
22:09:43 <ontop> Because I don't know exactly what to do with the parseError
22:09:44 <ontop> :(
22:09:59 <ReinH> well, I guess you would turn it into a Nothing.
22:09:59 <ontop> I don't want to bring IO () into it yet. But I have no other way to report the error.
22:10:09 <ontop> Yeah, that's what I'm doing. But that's like... the worst program ever.
22:10:14 <ontop> Config didn't load, doesn't tell you why. /troll
22:10:15 <ReinH> Or you would use an Either SomeError Config to report the error
22:10:21 <ontop> Hm.
22:10:22 <ontop> I like that.
22:10:29 <ReinH> that's what >>= is designed to do
22:10:35 <ReinH> :t (>>=)
22:10:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:10:54 <ReinH> you have an Either SomeError Table and a Table -> Either SomeError Config
22:11:02 <ReinH> and you wham 'em together with >>=
22:11:25 <hackrilege> You either keep passing the error up, or at some point it goes IO. Which every program does eventually
22:11:27 <ReinH> and you get your Either SomeError Config
22:11:47 <ontop> I knew I needed monads here :(
22:11:50 <ReinH> then you only have to worry about reporting the right error when turning a Table into a Config
22:12:01 <ontop> So, I thought to do something like this:
22:12:02 <ontop> makeConfig (Right m) = fmap (flip H.lookup $ m) ["nick", "user", "channels", "server", "port"]
22:12:09 <ontop> But this turns out to be a horrible idea I think.
22:12:17 <ReinH> Yes, and then something with Left e
22:12:23 <ontop> Yeah, I already took care of that
22:12:25 <ontop> That parts easy!
22:12:33 <ReinH> and then if you compare what you wrote to the definition of (>>=) for Either e, you will see
22:12:38 <hackrilege> Looks ok, what's wrong with it?
22:12:48 <ontop> hackrilege: If you saw the output... lol.
22:13:13 <hackrilege> Do you want to show me the output?
22:13:14 <ontop> :info Either
22:13:17 <ontop> Sure why not.
22:13:23 <ontop> Wait
22:13:25 <ontop> Let me stare a little.
22:13:30 <ontop> Let's not embarass myself.
22:14:04 <ontop> Oh. I kinda think it worked tbh.
22:14:07 <hackrilege> Well I'd rather have something to do while I wait, and I basically only want to see it to determine if looking at it could be useful
22:14:31 <hackrilege> Ok no need then
22:14:31 <ontop> http://lpaste.net/4715587234437267456
22:14:33 <ontop> That.
22:14:35 <hackrilege> Lol
22:14:39 <hunteriam> http://lpaste.net/148590
22:14:44 <hunteriam> rip
22:14:45 <ontop> It's clearly angry about the return type
22:14:48 <ontop> So I have to fix that
22:15:22 <ontop> :t fmap
22:15:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:15:48 <ReinH> hunteriam: try stack clean
22:15:54 <hunteriam> did
22:15:57 <ReinH> ok
22:17:11 <hackrilege> I need to see the source to understand that error
22:17:31 <ontop> What's the function that takes a value out of Just?
22:17:35 <ontop> fromJust?
22:18:03 <hunteriam> why would you need that
22:18:11 <hackrilege> Basically it says, since lookup might fail, and it returns a Node, how do you get a Config
22:18:15 <ontop> I wanted to get the Node's out of the Maybe Node :(
22:18:15 <hackrilege> ?
22:18:28 <hackrilege> That will fail of lookup failed
22:18:34 <ontop> Hm.
22:18:37 <hackrilege> If
22:18:38 <ontop> You're right.
22:18:46 <KaneTW> ontop: you need to handle the Nothing case
22:18:48 <hunteriam> typically you might want something like `case x of Just thing -> _; Nothing -> _`
22:19:00 <Clint> or use maybe
22:19:03 <KaneTW> if it's impossible, you can make it a runtime error
22:19:05 <ontop> hunteriam: But I have like 5 things at once here. Isn't this where the monad for Maybe comes into play?
22:19:05 <KaneTW> :t maybe
22:19:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:19:17 <hackrilege> :t error
22:19:18 <lambdabot> [Char] -> a
22:19:48 <hackrilege> That's always what I use!
22:20:13 <ontop> http://lpaste.net/357076850775687168
22:20:14 <hackrilege> I never handle errors... :o
22:20:17 <ontop> This is what I'm trying to do
22:20:23 <ontop> Massage the map at the bottom
22:20:26 <ontop> Into the data Config
22:20:38 <ontop> So I thought I'd start by doing a lookup on all the values I care about
22:20:56 <hackrilege> :t filter
22:20:58 <lambdabot> (a -> Bool) -> [a] -> [a]
22:21:02 <hackrilege> No?
22:21:12 <ontop> Filter won't help. I basically need to die if any of them are not found.
22:21:13 <ReinH> what is Config?
22:21:28 <ontop> It's defined right there?
22:21:33 <hackrilege> Then redefine lookup' to use error
22:21:34 <ontop> In the paste
22:22:05 <ontop> hackrilege: No fun in that. I learned about Functors, Applicatives, Monads and their instances with Maybe for a reason!
22:22:09 <ReinH> what is NTValue?
22:22:18 <ontop> ReinH: It's some parser type from this library.
22:22:23 <hackrilege> Ok
22:22:40 <ReinH> you can, e.g., Config <$> M.lookup "nick" m <*> M.lookup "user" m ...
22:22:44 <ontop> hackrilege: Probably take me 5 days to figure it out though haha.
22:22:46 <ReinH> I don't know where you get channels from
22:22:54 <ReinH> oh it's an array
22:23:00 <ReinH> yeah, that isn't just a map of strings
22:23:16 <ontop> Right, it's basically string -> object atm
22:23:18 <ReinH> so you can't just look up strings
22:23:28 <ReinH> that library should have some tools for dealing with it though
22:23:34 <ReinH> possibly similar to aeson's?
22:23:39 <hackrilege> Still no way to change between Node and Config
22:24:03 <ReinH> ontop: what library is this?
22:24:12 <hackrilege> That I can see anyway
22:24:15 <ontop> https://hackage.haskell.org/package/htoml
22:24:41 <ontop> hackrilege: Well, I'll have a [Maybe Node] after this.
22:25:03 <ontop> After the fmap
22:25:10 <ReinH> Hmm, interesting
22:25:17 <ReinH> You can go through aeson
22:25:38 <ReinH> that would make it easier to deal with
22:25:58 <ontop> I wanna fight the good fight.
22:26:07 <ontop> This shouldn't be -too- hard.
22:26:25 <ReinH> I don't think that is the good fight
22:26:26 <Clint> ontop: use note from the errors package to convert each lookup to an Either
22:26:36 <ReinH> the README even uses toJSON in the example
22:26:40 <ReinH> I think that's the intended use
22:26:57 <ontop> ReinH: No, that's just convenience.
22:27:07 <ReinH> ontop: According to the README it's an intended use
22:27:09 <ontop> toml is a configuration format. It's meant to be parsed and consumed just as JSON is.
22:27:15 <ReinH> Yes, I know
22:27:30 <ReinH> ontop: https://github.com/cies/htoml#how-to-pull-data-from-a-toml-file-after-parsing-it
22:27:39 <ReinH> The README specifically suggests doing what I'm suggesting
22:27:52 <ReinH> "The second main option is to use the toJSON function to transform the data to an Aeson data structure, after which you can use your Aeson toolbelt to tackle the problem. Since TOML is intended to be a close cousin of JSON this is a very practical approach."
22:27:57 <ontop> Right.
22:28:16 <ReinH> And if you don't want to do that, you're stuck with the usual pattern matching approach it also suggests
22:28:21 <ReinH> while dealing with the maybes and etc
22:28:23 * ReinH shrugs
22:28:31 <ReinH> I'd definitely use the aeson approach
22:28:38 <ontop> That's not the good fight? I just read about all sorts of cool ways to deal with these problems in Haskell
22:28:47 <ontop> Chris' book showed me. I just have to piece them together some.
22:28:58 <ReinH> Yes, and using aeson here is a very cool way to deal with this problem
22:29:06 <ontop> :\
22:29:13 * ReinH shrugs
22:29:26 <ReinH> if you're convinced that you want to do it the other way, look at the pattern matching example
22:30:09 <ontop> Ok.
22:30:27 <ReinH> and consider the following pattern:
22:30:45 <ReinH> > (,) <$> Just 1 <*> Just 2 :: Maybe (Int,Int)
22:30:46 <lambdabot>  Just (1,2)
22:31:05 <ReinH> if you have a bunch of Maybe values, you can put them into a Maybe Config that way
22:31:11 <ReinH> with any errors bubbling up
22:31:45 <ontop> Cool thx
22:32:26 <ReinH> e.g. Config <$> maybeName <*> maybeUser ... where maybeName = case m ! "name" of ...
22:32:28 <hunteriam> ghc fails to link `undefined reference` but ghci is fine
22:35:05 <hunteriam> could I get a problem for using a language extension in one source file but not another?
22:40:48 <kadoban> hunteriam: I don't believe that's a possible cause, at least I've never heard of it.
22:41:17 <hunteriam> the error appears to be related to ToJSON, which is derived automatically 
22:58:08 <hunteriam> is it acceptable to declare a datatype in file A and define instances for it in file B?
22:58:29 <hunteriam> I have a file C which depends on A and which B depends on
22:59:26 <kadoban> hunteriam: Yes
22:59:35 <jle`> it's typically not encouraged, but any problems that can come from this will be contained to within your project/library, so it's not the end of the world.  you basically have to deal with the mess yourself
22:59:46 <jle`> as long as you are careful with your exports
22:59:51 <bergmark> hunteriam: if A is not an exposed-module and you always get the instance if a library user imports the type
23:00:13 <hunteriam> jle`: any way out of this mess?
23:00:20 <jle`> it's a potential mess
23:00:30 <jle`> but it can be handled with discipline and care
23:00:36 <hunteriam> C depends only on data types in A
23:00:53 <jle`> I would move C into A, myself
23:01:19 <bergmark> this is what happens when you aren't careful with orphans: http://matrix.hackage.haskell.org/package/http-conduit#GHC-7.8/http-conduit-1.9.6
23:01:21 <hunteriam> I might just make a data type file
23:02:53 <bergmark> boot files can be another way to avoid cyclic dependencies
23:18:50 <ontop_> :t Monad
23:18:51 <lambdabot> Not in scope: data constructor ‘Monad’
23:18:55 <ontop_> :(
23:18:59 <hunteriam> :info Monad
23:19:09 <hunteriam> Monad = type class
23:19:11 <hunteriam> :k Monad
23:19:13 <lambdabot> (* -> *) -> Constraint
23:20:29 <ReinH> @info Monad
23:20:29 <lambdabot> Monad
23:20:34 <ReinH> not nearly as useful as ghci
23:20:45 <ontop_> lmao.
23:20:49 <ReinH> thanks lambdabot, you tried
23:23:46 <geekosaur> someday someone should stick a dummy @info in there to stop edit correction from doing that
23:23:59 <geekosaur> (it's "corrected" to @undo)
23:25:27 <mniip> well it's better than what happens if you try @seen
23:25:27 <mniip> :)
23:26:13 <hunteriam> @seen
23:26:14 <lambdabot> Say again?
23:26:49 <mniip> it gets levenshtein-corrected to @leet
23:26:58 <mniip> which for some reason appears to be a command
23:27:03 <mniip> that exists
23:27:10 <hunteriam> @afasdfaf
23:27:10 <lambdabot> Unknown command, try @list
23:28:53 <quchen> Lambdabot isn't a GHCi session, unfortunately
23:31:26 <jle`> @info do { x <- y; g x }
23:31:26 <lambdabot> y >>= \ x -> g x
23:32:31 <quchen> Autocorrecting commands is a pretty terrible idea.
23:34:51 <ontop_> Welp
23:34:57 <ontop_> ReinH: I think I did it.
23:34:59 <ontop_> But it hurt.
23:35:04 <MarcelineVQ> jle`: haha
23:36:07 <quchen> ?help metar
23:36:07 <lambdabot> metar <ICAO airport code>
23:36:08 <lambdabot> Look up METAR weather data for given airport.
23:36:09 <quchen> Wat.
23:37:06 <anohigisavay> i have a project that uses happy/alex
23:37:10 <anohigisavay> i can build and install it
23:37:10 <Jinxit> metar ARN
23:37:18 <liste> @metar EFMI
23:37:18 <lambdabot> EFMI 070720Z AUTO 26002KT CAVOK M29/M32 Q1014
23:37:51 <anohigisavay> but when i run cabal repl it eats up my memory
23:38:39 <ReinH> ontop_: good, that's part of the process
23:38:42 <ontop_> ReinH: http://lpaste.net/3025633679247409152
23:39:04 <ontop_> My eyes hurt
23:39:09 <ontop_> The goggles, they do nothing!
23:39:39 <quchen> Ugh.
23:39:51 <quchen> if isNothing a then Left else Right
23:39:52 <quchen> :s
23:39:59 <ontop_> quchen: Help? :D
23:40:25 <ReinH> ontop_: well, loadConfig doesn't do anything.
23:40:32 <ontop_> Haha
23:40:34 <ontop_> Yeah I didn't get there yet.
23:40:40 <ontop_> I was mainly concerned with unpacking the structure.
23:40:55 <ReinH> I wouldn't use a fold
23:40:55 <MasseR> liste:hah, I was wondering on what channel I was on. I thought this was one of my aviation channels :)
23:41:03 <ReinH> I'd use pattern matching the way the README suggests
23:41:12 <ontop_> :(
23:41:17 <ontop_> It's probably cleaner tbh.
23:41:25 <ontop_> I just wanted to try some fancy footed stuff.
23:41:37 <ReinH> you should learn to walk before you run
23:41:41 <quchen> ontop_: https://github.com/quchen/articles/blob/master/fbut.md#head-tail-isjust-isnothing-fromjust-
23:41:59 <ReinH> quchen: nice
23:42:44 <ontop_> ReinH: Learning's about making mistakes, then realizing why it was bad. Gotta let me make mistakes :D
23:43:01 <ontop_> I mean, it does work after all.
23:43:08 <ontop_> It's just slightly uglier than it had to be lol.
23:43:22 * hackagebot ini 0.3.3 - Quick and easy configuration files in the INI format.  https://hackage.haskell.org/package/ini-0.3.3 (ChrisDone)
23:43:45 <ReinH> ontop_: No worries there. I don't think I have the power to prevent you from making mistakes.
23:44:08 <ontop_> Well, condemning people to the way it should be done and limiting experimentation is a good start
23:44:23 <ReinH> ...
23:44:27 <ReinH> ok then
23:45:28 <ontop_> quchen: I made that a case statement instead of a isNothing
23:45:33 <ontop_> Thanks for the feedback :D
23:49:39 <ontop_> Awesome. Config loading done!
23:51:05 <MarcelineVQ> quchen: `nub1, nub2, nub3 :: Ord a -> [a] -> [a]` => ?
23:51:09 <frerich> ReinH: It almost sounds as if you mean to imply that mistakes are a bad thing ;-)
23:51:44 <ReinH> ontop_: Are you aware of how that function will behave? For example, it won't fail if there is no name.
23:51:45 <frerich> ReinH: Mistakes are perfectly fine, just repeating them is bad.
23:51:53 <ReinH> It will just return a bad result.
23:51:59 <quchen> MarcelineVQ: ?
23:52:11 <ReinH> one with the name set to ""
23:52:18 <ReinH> and likewise for al the other values
23:52:25 <ontop_> ReinH: Yep.
23:52:26 <MarcelineVQ> quchen: shouldn't it be Ord a =>
23:52:30 <ReinH> ok
23:52:50 <ontop_> I'm not trying to make anything rock solid. Pattern matching could help there I guess right? If I had a case for []?
23:52:59 <ontop_> (If i had done it the other way)
23:53:27 <quchen> MarcelineVQ: Oh, that sounds like a typo, yes.
23:53:57 <ontop_> ReinH: Also, if I had done pattern matching instead, and had like 50 values, wouldn't that mean I would have to indent 50 case statements to the right?
23:54:07 <ontop_> 50 keys sorry
23:54:11 <ReinH> frerich: it sounds as if I mean to imply that reaching for more advanced techniques before you have a firm grasp on basic techniques might not be the best way to learn.
23:54:54 <ReinH> ontop_: no, you can structure your program to avoid that pretty easily.
23:55:00 <ontop_> Oh.
23:55:03 <quchen> ontop_: Here's how I would have structured that function. http://lpaste.net/148595
23:55:45 <ontop_> I'm confused quchen 
23:55:48 <ReinH> ontop_: the example I gave before doesn't have that problem.
23:55:51 <ontop_> Your guard syntax uses -> not =?
23:56:15 <ontop_> ReinH: Well, how do I progressively build up a Config then?
23:56:27 <jle`> it's actually a case statement
23:56:33 <MarcelineVQ> ontop_: case uses -> so guards for it need to as well since guards just replace your statement
23:56:45 <ontop_> Oh..
23:56:50 <ontop_> I didn't know case could use guards
23:56:53 <ontop_> That's cool
23:56:56 <quchen> Oh, one could float the "could not find" parts one level up. http://lpaste.net/148596
23:57:11 <ontop_> That's pretty tidy quchen.
23:57:12 <quchen> ontop_: Those case guards is what "normal guards" desugar to
23:57:16 <ontop_> Can I borrow have it?
23:57:36 <ontop_> It's so much cleaner O_o
23:58:12 <yapple> @pl crypt key salt = useAsCString key (useAsCString salt . c_crypt) >>= packCString
23:58:12 <lambdabot> crypt = flip flip packCString . ((>>=) .) . (. ((. c_crypt) . useAsCString)) . useAsCString
23:58:20 <yapple> oh my
23:58:29 <quchen> ontop_: It's just a suggestion
23:58:51 <ontop_> quchen: Hm. Doesn't work out of the box. x in the where isn't in scope yet
23:59:46 <ontop_> Fixed.
23:59:52 <ontop_> quchen: Thanks very much.
23:59:57 <ReinH> ontop_: e.g., http://lpaste.net/4030861343128027136
