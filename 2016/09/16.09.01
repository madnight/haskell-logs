00:01:21 <nshepperd> sounds like we need some kind of magical Either :: Constraint -> Constraint -> Constraint
00:01:47 <nshepperd> instance Either (Empty a) (Boring b) => Boring (a -> b)
00:02:12 <Cale> The only thing which makes this kind of thing sensible is that the definitions are going to be equivalent
00:02:16 <Cale> but GHC doesn't know that
00:02:18 <nshepperd> i'm sure there's a good reason that won't work
00:02:44 <EvanR> the instances will be equivalent so it doesnt matter whether it picks one or the other first
00:03:30 <Cale> The problem is that neither instance is going to be more specific than the other, so overlapping instances doesn't help
00:03:48 <nshepperd> equivalence isn't the problem right now since we can't even write it
00:04:45 <nshepperd> "instance Empty a => Boring (a -> b); instance Boring b => Boring (a -> b);" will fail for "Foo -> ()" or "Void -> Bar" depending on which instance it happens to pick first
00:06:00 <Cale> Also, the instance Empty a => Boring (a -> b) isn't going to be the thing you want.
00:06:31 <Cale> Because () is actually neither initial nor terminal in Haskell.
00:06:33 <Cale> Void is both
00:07:08 <Cale> So, when you write that instance, you're going to presumably try using the Empty instance for a, which is fine, but it means you're giving the constant undefined function
00:07:59 * hackagebot XMLParser 0.1.0.2 - A library to parse xml  https://hackage.haskell.org/package/XMLParser-0.1.0.2 (AlanHawkins)
00:07:59 * hackagebot XMLParser 0.1.0.3 - A library to parse xml  https://hackage.haskell.org/package/XMLParser-0.1.0.3 (AlanHawkins)
00:08:10 <Cale> Whereas the instance which involves a Boring b constraint, you're presumably giving const boring
00:08:15 <nshepperd> the equivalence is a lie in non-total land, yes
00:09:02 <Cale> So they *aren't* really equivalent instances as such
00:12:55 <nshepperd> well, many typeclass laws in haskell only hold in the TotalHaskell fantasy
00:12:59 <nshepperd> that's not unusual
00:14:59 <Axman6> isn't fast and loose reasoning morally correct?
00:17:12 <Cale> I guess if we're committed to pretending we're not able to apply the function Void -> (), it doesn't matter if we get absurd or const ()
00:17:55 <shachaf> Axman6: But moral reasoning is not technically correct.
00:59:58 <f-a> I am checking Pipes package: is is possible/advisable to 'split' and 'merge/zip' pipes?
01:01:37 <f-a> say I have a producer producing a stream of 'f' and transform these 'f' to 'g' and 'h' using 2 different pipes
01:02:20 <f-a> is it sensible for me to want to, in a later step, have (g, h)? Or broken pipes, etc. make this unadvisable?
01:08:16 <pkmx> dfeuer: I guess this works? http://lpaste.net/182272
01:15:41 <cocreature> f-a: I think the typical solution to that is using pipes-concurrency. you can take a look at the mvc package (written by the pipes author) to get an intuition of how to deal with that
01:16:20 <dysfun> how does pipes compare to conduit?
01:16:24 <cocreature> f-a: oh no sory I think I misunderstood your problem
01:17:03 <cocreature> f-a: seems sensible as long as you want your combined pipe to stop yielding outputs when one of the input pipes stops yielding outputs
01:18:49 <f-a> cocreature: thanks
01:19:37 <f-a> I would probably like them, uhh, strictly paired (i.e. if one pipes skips a beat it's a problem), so it's a probably a problem
01:23:51 <elliptic00> Hi, I just try to understand a little bit of Monoid in Haskell.  could anyone explain to me what is following expression?  Num a => Monoid(Sum a)
01:24:13 <mauke> that looks like a fragment of an instance declaration
01:24:18 <cocreature> elliptic00: that means that the type "Sum a" is an instance of Monoid for any a that is an instance of Num
01:26:39 <elliptic00> I understand this funciton:  isPalindrome:: Eq a=>[a]->Bool, but not  Num a => Monoid(Sum a)
01:27:04 <cocreature> elliptic00: the first is a type signature of a function, the second is a typeclass instance declaration (or part of it to be precise)
01:27:31 <elliptic00> is  "Num a => Monoid(Sum a )  not a function signature?
01:27:39 <mauke> ... no?
01:28:58 <f-a> elliptic00: do you know what typeclasses are?
01:31:34 <elliptic00> sort of.. like  class in Java?  
01:31:40 <cocreature> not at all
01:31:43 <cocreature> more like interface in java
01:32:24 <cocreature> so Eq a means that you can use operations provided by the Eq typeclass (interface) on a
01:34:15 <elliptic00> what does Monoid(..) mean?
01:34:19 <Insanity_> Quick question, can you not define as type "Integral'"?
01:34:30 <Insanity_> findSum :: Integral -> Integral results in
01:34:43 <cocreature> Insanity_: no Integral is a typeclass not a type
01:34:43 <Insanity_> "expected a type, but Integral has kind '*->Constraint'
01:34:52 <cocreature> Insanity_: you probably want Integral a => a -> a
01:35:08 <Insanity_> oh cheers
01:47:56 * hackagebot writer-cps-mtl 0.1.0.0 - MonadWriter orphan instances for writer-cps-transformers  https://hackage.haskell.org/package/writer-cps-mtl-0.1.0.0 (minad)
01:47:58 * hackagebot writer-cps-transformers 0.1.0.0 - WriteT and RWST monad transformers  https://hackage.haskell.org/package/writer-cps-transformers-0.1.0.0 (minad)
01:49:25 <Reshi> @ty 1 + length
01:49:27 <lambdabot> (Foldable t, Num (t a -> Int)) => t a -> Int
01:50:05 <Reshi> Why is this ^^ not an error? I remember hearing an explanation once before, but I can't remember it again.
01:51:16 <shachaf> Why would it be an error?
01:51:40 <polux> well, it says that assuming that fonctions from traversables to ints can be seen as numbers then 1 + such_a_function is a number
01:52:02 <polux> foldable, not traversables, sorry
01:52:47 <polux> oh wait no, it doesn't say that :)
01:53:37 <polux> it says assuming ..., 1 + length is a function from a foldable to an int
01:54:42 <polux> so basically if you can explain which function from foldable to int each numeric literal denotes, then 1 + length makes sense (as a function)
01:54:58 <Reshi> @polux Yeah, but you still can't do: (1 + length) [1,2,3]. Well just wondering where the constraint Num (t a -> Int) is
01:54:58 <lambdabot> Unknown command, try @list
01:55:15 <mauke> you can if you define a Num instance for functions
01:55:30 <polux> recycle: well, you can if you declare an instance Num (t a -> Int) I guess
01:55:48 <polux> I mean Foldable t => Num (t a -> Int)
01:55:58 <Reshi> mauke: Thanks! That cleared it I think, found the haskell wiki link
01:56:13 <ahihi> > (1 + length) [1,2,3]
01:56:15 <lambdabot>  error:
01:56:15 <lambdabot>      • No instance for (Num ([a0] -> Int)) arising from a use of ‘+’
01:56:15 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
01:56:22 <ahihi> lambdabot used to have an instance like that
01:56:30 <Reshi> Did not know you could do this, https://wiki.haskell.org/Num_instance_for_functions
01:56:42 <mauke> @let instance (Num a) => Num (e -> a) where fromInteger = pure . fromInteger; negate = liftA negate; (+) = liftA2 (+); (*) = liftA2 (*)
01:56:44 <lambdabot>  .L.hs:160:10: warning: [-Wmissing-methods]
01:56:44 <lambdabot>      • No explicit implementation for
01:56:44 <lambdabot>          ‘abs’ and ‘signum’
01:56:49 <mauke> @undefine
01:56:49 <lambdabot> Undefined.
01:57:02 <mauke> @let instance (Num a) => Num (e -> a) where fromInteger = pure . fromInteger; negate = liftA negate; (+) = liftA2 (+); (*) = liftA2 (*); abs = liftA abs; signum = liftA signum
01:57:03 <lambdabot>  Defined.
01:57:10 <mauke> > (1 + length) [1,2,3]
01:57:16 <lambdabot>  4
01:57:17 <polux> tadaa
01:57:29 <Reshi> Oh wow, nice
01:57:32 <mauke> this works for all applicatives
01:57:47 <mauke> > (sin + cos) 0.4
01:57:49 <lambdabot>  1.3104793363115357
01:58:55 <Reshi> The wiki page, https://wiki.haskell.org/Num_instance_for_functions, is under the category 'Humour'. quote: "The usefulness of this instance is debatable, and it is not currently part of the language report or defined in any popular library."
01:59:55 <mauke> :t deriv
01:59:57 <lambdabot> error: Variable not in scope: deriv
01:59:59 <mauke> aw
02:13:30 <elliptic00> instance Eq Integer where 
02:13:30 <elliptic00>   x == y                =  x `integerEq` y
02:13:56 <elliptic00> how do we know x and y are Integer type?
02:14:29 <mniip> instance declarations substitute instance head into type variables mentioned in methods
02:14:57 <mniip> you have 'class Eq a where (==) :: a -> a -> Bool'
02:15:11 <mniip> when you write 'instance Eq Foo', it is implied that (==) :: Foo -> Foo -> Bool
02:15:17 <mniip> well
02:15:27 <mniip> in the equation you define in the block
02:15:43 <mniip> you can still *use* == of different types
02:16:06 <Insanity_> Is there a default way to get the complement of a set, with Lists?
02:16:21 <mniip> what set implementation
02:16:25 <Insanity_> If I have a list B, which contains a subset of list A, and I'd want a new list containing elements of A not in B
02:16:49 <mniip> :t (Data.List.\\)
02:16:51 <lambdabot> Eq a => [a] -> [a] -> [a]
02:16:56 <Insanity_> so I could use something akin to
02:17:05 <Insanity_> [1..100] \\ [1..50]?
02:17:19 <mniip> yes
02:17:27 <mniip> though don't expect it to optimize to [50..100]
02:17:32 <Insanity_> Thanks
02:17:36 <mniip> [51..100] rather
02:17:46 <mniip> I mean it could
02:17:56 <mniip> but generally you will lose performance
02:18:16 <Insanity_> it should return [51..100].. Well actually, this is a contrived example, the actual lists are slightly different :-)
02:18:34 <mniip> > ["foo", "bar", "baz"] \\ ["baz", "foo"]
02:18:36 <lambdabot>  ["bar"]
02:18:56 <mniip> > "aaabaaaabaaa" \\ "a"
02:18:59 <lambdabot>  "aabaaaabaaa"
02:19:08 <mniip> ah, removes the first occurence only
02:19:08 <Insanity_> seems like this worked
02:19:20 <Insanity_> >  [1..100] \\ [x^2 | x <- [1..10]]
02:19:23 <lambdabot>  [2,3,5,6,7,8,10,11,12,13,14,15,17,18,19,20,21,22,23,24,26,27,28,29,30,31,32,...
02:19:42 <Insanity_> Thanks :-)
02:21:01 <woffs> > "aaabaaaabaaa" \\ "aaaaaaaaaaaaaaaaa"
02:21:02 <elliptic00> anyone know what is good and bad when we compare Lisp and Haskell?..I'm new to both 
02:21:04 <lambdabot>  "bb"
02:21:20 <mniip> "good" and "bad"?
02:21:34 <elliptic00> Yep..
02:21:43 <elliptic00> in real world application.
02:30:23 <officialGupta> Hey! I have just started learning Haskell
02:31:16 <Cale> officialGupta: Welcome! Let us know if you have any questions
02:31:26 <ongy> officialGupta: welcome  :)
02:31:34 <mniip> Cale, I think it's pretty obvious that they will :)
02:31:50 <officialGupta> Cale
02:31:59 <officialGupta> Thanks, I will :)
02:32:10 <officialGupta> Cheers ongy
02:32:22 <stringer> Hey can I ask why foldl (*) 1 != foldr (*) 1  ?? Is this because there is no list argument apply to it ? 
02:32:29 <officialGupta> What is the coolest thing you have seen done in Haskell?
02:32:36 <stringer> applied*
02:32:46 <Cale> stringer: It's because a * (b * c) = (a * b) * c for any numbers a, b, c
02:32:53 <Cale> er, sorry
02:33:28 * Cale didn't catch the != as "not equal to"
02:33:36 <stringer> exactly
02:33:50 <Cale> If they're not equal, it's because the operation (*) is not associative
02:34:01 <Cale> For Float and Double, it won't be
02:34:19 <Insanity_> mhm, is there a way for haskell to actually evaluate a really long number accurately?
02:34:29 <Insanity_> > sqrt 5 * 100^100
02:34:31 <lambdabot>  2.2360679774997907e200
02:34:38 <Insanity_> without the e200 part
02:34:50 <Cale> > sqrt 5 * 100^100 :: CReal
02:34:52 <lambdabot>  2236067977499789696409173668731276235440618359611525724270897245410520925637...
02:34:57 <Insanity_> Thanks :-)
02:35:00 <stringer> Cale: can you provide 
02:35:01 <stringer> counterargument
02:35:45 <Cale> stringer: With floating point multiplication?
02:36:01 <stringer> yes
02:36:09 <Cale> @check \a b c -> a * (b * c) == (a * b) * (c :: Double)
02:36:11 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 1117 shrinks):
02:36:11 <lambdabot>  1.7647059517506691 -0.7506931979362368 -2.014402864506709
02:36:51 <Cale> > foldl (*) 1 [1.7647059517506691, -0.7506931979362368, -2.014402864506709]
02:36:53 <lambdabot>  2.6685857430992432
02:36:57 <Cale> > foldr (*) 1 [1.7647059517506691, -0.7506931979362368, -2.014402864506709]
02:36:59 <lambdabot>  2.668585743099243
02:37:04 <Insanity_> Where does CReal actually come from?
02:37:07 <Insanity_> Data.Number.CReal?
02:37:11 <stringer> I mean foldl (+) 1 == foldr (+) 1 inst true also
02:37:19 <Cale> Insanity_: yeah
02:37:24 <Cale> in the numbers package
02:37:33 <Insanity_> that is not by default part of haskell, I'm assuming?
02:37:46 <Cale> Insanity_: It's a library written in Haskell
02:38:02 <Insanity_> I see, I'll figure out how to use that one :-)
02:38:12 <Cale> It's not terribly practical
02:38:54 <Cale> > sum [1..1000] :: CReal
02:38:59 <lambdabot>  500500.0
02:39:05 <Cale> > sum [1..10000] :: CReal
02:39:11 <lambdabot>  mueval-core: Time limit exceeded
02:39:18 <Cale> ^^ it's kinda slow
02:39:22 <Insanity_> Ah, I see ^^
02:39:37 <Insanity_> But I need to represent really big numbers, is there an alternative you know of?
02:40:01 <Cale> Really big real numbers?
02:40:11 <Cale> Really big integers are covered by Integer
02:40:24 <Insanity_> Well, that sqrt 5 * 100^100 should be represented correctly
02:40:27 <Cale> and there's Rational as well, for fractions of Integers
02:40:34 <stringer> Cale: how about foldl (+) 0 == foldr (+) 0. Is this true ?
02:40:34 <Cale> But sqrt 5 isn't rational
02:40:41 <Cale> stringer: Not for Double
02:40:42 <Insanity_> Yup
02:41:01 <Cale> stringer: It's true for Integer (as is the product example)
02:41:15 <stringer> oh
02:41:19 <Insanity_> But I multiply it with 100^100, the rest of the digits I'm not interested in
02:41:27 <Cale> @check \a b c -> a + (b + c) == (a + b) + (c :: Double)
02:41:30 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 84 shrinks):
02:41:30 <lambdabot>  -5.161215328802952 -10.795092892569928 -9.249514281433756
02:41:43 <stringer> Oh
02:42:06 <Cale> > foldl (+) 0 [-5.161215328802952, -10.795092892569928, -9.249514281433756]
02:42:08 <lambdabot>  -25.205822502806633
02:42:13 <Cale> > foldr (+) 0 [-5.161215328802952, -10.795092892569928, -9.249514281433756]
02:42:15 <lambdabot>  -25.205822502806637
02:42:35 <Cale> Floating point numbers don't have many nice properties
02:42:52 <Cale> The operations are commutative, but that's about it
02:43:39 <verement> Insanity_: you might check the decimal-arithmetic library I'm working on
02:43:40 <stringer> Ok so how about this. We have a function times :: Integer -> Integer -> Integer
02:43:48 <stringer> 0 `times` _ = 0
02:43:54 <stringer> 0 `times` _ = 0
02:43:58 <verement> Insanity_: you can compute to essentially arbitrary precision
02:44:01 <stringer> n `times` m = n*m
02:44:24 <Insanity_> I see verement
02:44:24 <stringer> is foldl times 1 = foldr times 1 true ?
02:44:29 <Cale> nope
02:44:34 <stringer> why is that ?
02:44:39 <Insanity_> I'm quite new to actually using an external library xD Cabal source package, can I just import them like normal files?
02:44:50 <Insanity_> ah probably with :load
02:44:54 <Cale> Because on infinite lists containing 0, foldr will produce a result, while foldl will result in nontermination
02:45:14 <Cale> @let times 0 n = 0; times n m = n * m
02:45:16 <lambdabot>  Defined.
02:45:26 <Cale> > foldr times 1 [0..]
02:45:29 <lambdabot>  0
02:45:32 <Cale> > foldl times 1 [0..]
02:45:42 <lambdabot>  mueval: ExitFailure 1
02:45:53 <Cale> @src foldr
02:45:54 <lambdabot> foldr f z []     = z
02:45:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:46:02 <Cale> foldr times 0 [0..]
02:46:10 <Cale> er, sorry
02:46:14 <Cale> foldr times 1 [0..]
02:46:23 <Cale> = foldr times 1 (0 : [1..])
02:46:32 <Cale> = times 0 (foldr times 1 [1..])
02:46:36 <Cale> = 0
02:46:46 <Cale> @src foldl
02:46:46 <lambdabot> foldl f z []     = z
02:46:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:46:56 <Cale> foldl times 1 [0..]
02:47:04 <Cale> = foldl times 1 (0 : [1..])
02:47:18 <Cale> = foldl times (times 1 0) [1..]
02:47:28 <verement> Insanity_: you'll need to install the library first with 'cabal install' or 'stack install', then you can import the appropriate modules
02:47:31 <Cale> = foldl times (times 1 0) (1 : [2..])
02:47:46 <Cale> = foldl times (times (times 1 0) 1) [2..]
02:47:53 <Cale> = ... ad infinitum
02:47:57 <MarcelineVQ> stack install isn't really for installing libs as much as it is for installing executables
02:47:59 <stringer> Ok i get it now
02:47:59 * hackagebot writer-cps-transformers 0.1.0.1 - WriteT and RWST monad transformers  https://hackage.haskell.org/package/writer-cps-transformers-0.1.0.1 (minad)
02:48:02 <stringer> thank you
02:52:59 * hackagebot writer-cps-mtl 0.1.0.1 - MonadWriter orphan instances for writer-cps-transformers  https://hackage.haskell.org/package/writer-cps-mtl-0.1.0.1 (minad)
02:57:45 <Guest83182> hello, I am a newbie haskeller, I have a problem with my random package. can someone help me here?
02:58:53 <ongy> Guest83182: usually. Best state your problem, then everyone can see if they can help
03:00:22 <Guest83182> I am running mac OS X and my random package is not visible to my ghc. it is installed in this directory 
03:00:35 <Guest83182>    /Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/lib/ghc-8.0.1/package.conf.d
03:01:27 <Guest83182> but only packages in this directory are available :   /Users/miladzahedi/.ghc/x86_64-darwin-8.0.1/package.conf.d
03:02:49 <Insanity_> verement, once I have installed something with cabal, can I delete it safely?
03:02:56 <Insanity_> Or do I need to keep the cabal package in the project
03:03:24 <ongy> I'm not familiar with OSX, but it sounds like you installed your package with root (is that a term for OSX?) and executing ghc as user it only searches for user installed packages
03:03:50 <Insanity_> make sure you have the correct rights and owner set Guest83182
03:04:23 <Insanity_> sudo chown [username] [package.conf.d]
03:04:24 <verement> Insanity_: I don't think you need to keep it. If you're building another lib or executable with cabal you can just list the package among your dependencies in the .cabal file
03:04:40 <Insanity_> Thanks verement 
03:05:22 <Insanity_>  is there a guideline for importing packages? As in, defining an alias, is that pretty standard?
03:05:33 <Insanity_> import [package] as [alias]?
03:05:35 <Guest83182> <Insanity_> I will look into it
03:06:49 <verement> Insanity_: you don't import packages so much as the module(s) it provides
03:07:39 <Insanity_> Sorry, I meant modules I think (new to the terminology here)
03:07:55 <Insanity_> import Data.List as L
03:08:11 <verement> yes, that would work
03:08:25 <Insanity_> Is there a guideline that says we need to do it this or that way?
03:08:30 <Insanity_> coding convention wise
03:10:55 <verement> there are some common examples, but I don't think there's any need to follow them
03:11:21 <elliptic00> data Point a            = Pt a a
03:11:46 <elliptic00> can anyone explain what does it mean?
03:11:50 <Insanity_> Okay, cheers
03:12:24 <liste> elliptic00: it defines a data type Point with one constructor Pt that takes two values of the same type
03:12:56 <liste> elliptic00: eg. you could do a (Pt 4 12) or (Pt "hello" "world") but not (Pt 4 "hello")
03:13:22 <ongy> elliptic00: so you can have e.g. 'Paint Int' or 'Paint Float' in a two dimensional space
03:14:17 <liste> @let data Point a = Pt a a deriving (Show)
03:14:19 <lambdabot>  Defined.
03:14:34 <liste> :t (Pt "hello" "world")
03:14:36 <lambdabot> Point [Char]
03:14:44 <liste> :t (Pt "hello" 12)
03:14:45 <lambdabot> error:
03:14:45 <lambdabot>     • No instance for (Num [Char]) arising from the literal ‘12’
03:14:46 <lambdabot>     • In the second argument of ‘Pt’, namely ‘12’
03:14:48 <elliptic00> like in Java?   Point(Object o1, Object o2)?
03:15:34 <liste> elliptic00: not Point(Object o1, Object o2) but "class Point<T> { Point(T o1, T o2) {...} }"
03:16:06 <liste> not exactly though, constructors in Haskell are a bit different
03:16:30 <elliptic00> Nice...
03:19:00 <ongy> elliptic00: have you read about modules and export lists yet?
03:19:33 <elliptic00> not yet.. this is my next reading I think
03:19:46 <elliptic00> is important? 
03:20:22 <elliptic00> right now, I'm very confusing.. about typeclass.. data. type, newtype.. 
03:20:39 <ongy> not for learning the principals of haskell, but if you want to do anything serious, you want it to organize your code. I would have suggested a little excersize if you had read it
03:21:10 <elliptic00> Sure.
03:45:28 <parsnip> types, datatypes, sets of values, data structures, are sort of synonyms. typeclasses or classes are sort of like sets of types. 
04:03:39 <mkoenig> hi. which is the best way to parse a tuple. for example (a, b) = (1, 2) so that a == 1 & b == 2
04:04:46 <mkoenig> oh wait, this seems to work
04:05:06 <mkoenig> let (a, b) = (1, 2) in a+b
04:07:13 <mkoenig> ok forget about it ^^. haskell is very intuitive
04:08:05 <Xnuk> > uncurry (+) (1, 2)
04:08:07 <lambdabot>  3
04:30:29 <meditans> hi all, I'd like some help in choosing a suitable name for some modules. I wrote a library that does the preprocessing of the cpp in a haskell source, so that you can analyze it with haskell-src-exts afterwards (or other parsing libraries)
04:30:51 <meditans> the candidate package is https://hackage.haskell.org/package/preprocessor-0.1.0/candidate
04:31:14 <meditans> but it correctly complains for using a top-level name for the module
04:31:29 <meditans> what could a convenient name for this be in the hierarchy?
04:43:33 <athan> meditans: Maybe `Language.Cpp.PreProcessor`?
04:44:17 <ongy> athan: afaik CPP is the C PreProcessor, so I think Language.C would be better
04:45:04 <maerwald> yeah, I agree with ongy
04:49:04 <meditans> thanks, those are great suggestions. Is there a place where I can see all the module hierarchy for the modules in hackage?
04:53:11 <officialGupta> Hi all! Why does this code not work on a list of 20 numbers: myLast x = if null x /= True then last x else x
04:53:42 <mniip> you're constructing an infinite type there
04:54:29 <meditans> athan ongy maerwald however, Language.C.stuff gives the idea that it's about a complete cpp preprocessor, while it's tailored for the usage on haskell sources; so maybe Language.Haskell.CPP.PreProcessor?
04:55:09 <gabbiel> when importing, does specifying which functions to import reduce the binary size when compiled
04:55:13 <pavonia> officialGupta: In an if/then/else, the then and else branches must return values of the same type
04:55:34 <maerwald> meditans: cpp is a standalone program which is part of the C compiler and can be used for any random task
04:56:41 <officialGupta> @pavonia ah! yes, it works if you return a number. What if you don't want to return a number, but a string warning?
04:56:41 <lambdabot> Unknown command, try @list
04:56:41 <meditans> maerwald: true, but this library calls it with some arguments that it can only retrieve for a haskell project
04:57:03 <gabbiel> @src getLine
04:57:03 <lambdabot> getLine = hGetLine stdin
04:57:20 <pavonia> officialGupta: You can return a string too, but make sure the types match
04:57:22 <meditans> like the cabal macros file, specific includedirs. It doesn't work for generic tasks: should this be reflected in the choice of the name?
04:57:41 <pavonia> > if odd 3 then "three is odd" else "three is even"
04:57:43 <lambdabot>  "three is odd"
04:57:54 <officialGupta> pavonia: I am not sure I follow, how would I do that?
04:58:07 <pavonia> I just gave a sample
04:58:16 <gabbiel> why is there no printf for the standard types?
04:58:27 <camm> What are the current libraries used for encryption?
04:58:35 <pavonia> gabbiel: There is
04:58:40 <ongy> officialGupta: if you want to either return a number, or a string warning, you have to make it explicit with the type. Something like "Either String Int"
04:58:49 <Insanity_> Can someone tell me if I am looking in the right direction. If I would use foldl like `foldl (+) 0 [1..10]` I would essentially get sum [1..10]. but I am looking to get intermediate results. Is that something in the domain of foldl? For example, here I would get an array such as [0+1][0+1+2]...[9+10]] 
04:59:00 <meditans> camm: I heard good things about cryptonite
04:59:08 <hpc> > scanl (+) [0..10]
04:59:11 <lambdabot>  error:
04:59:11 <lambdabot>      • No instance for (Typeable t0)
04:59:11 <lambdabot>          arising from a use of ‘show_M510311681005157212718692’
04:59:15 <pavonia> gabbiel: In module Text.Printf
04:59:16 <hpc> :t scanl
04:59:17 <bjs> gabbiel: have you seen Text.Printf ?
04:59:17 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
04:59:27 <hpc> :t scanl1 (+) [0..10]
04:59:29 <lambdabot> (Num a, Enum a) => [a]
04:59:31 <hpc> > scanl1 (+) [0..10]
04:59:34 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
04:59:38 <hpc> Insanity_: like that?
04:59:45 <gabbiel> I mean, Text.Printf is really weird, its not even IO
04:59:46 <ongy> :t scanl1
04:59:47 <lambdabot> (a -> a -> a) -> [a] -> [a]
04:59:48 <hpc> in Data.List or something like that
04:59:52 <camm> Thanks meditans. It seems it is updated very often. :)
04:59:55 <hpc> gabbiel: it is
04:59:58 <officialGupta> pavonia: yes I see. Thanks.
05:00:08 <officialGupta> ongy: what is that?
05:00:11 <hpc> gabbiel: it's polymorphic so printf can be used as either printf() or sprintf()
05:00:15 <Insanity_> close, but for example it does not contain 2+3
05:00:20 <gabbiel> hpc: tell me, how would I incorporate it within a do block
05:00:47 <hpc> Insanity_: ah, you want to add consecutive numbers
05:01:01 <ongy> officialGupta: Both branches of the if/then/else have to have the same type. So returning String in one and Int in the other doesn't work. You can *wrap* them into another type. Either is a standard one.
05:01:05 <Insanity_> yeah, but starting anywhere within the original array to length x
05:01:09 <Insanity_> so if the range is [1..10]
05:01:10 <hpc> > map (uncurry (+)) (zip`ap`tail [0..10])
05:01:13 <lambdabot>  error:
05:01:13 <lambdabot>      • Couldn't match expected type ‘[Integer -> (b, b)]’
05:01:13 <lambdabot>                    with actual type ‘[a0] -> [b0] -> [(a0, b0)]’
05:01:23 <hpc> :t zip`ap`tail
05:01:26 <lambdabot> [a] -> [(a, a)]
05:01:28 <Insanity_> it can start at 7 [7+8+9] and [7+8+9+10]
05:01:37 <ongy> you could do then: if not (null x) then Right (head x) else Left "x was null, cannot get head"
05:01:50 <hpc> > zip`ap`tail [0..10] -- start with something like that, except don't actually use zip`ap`tail because it's just a silly bit of golfing
05:01:52 <lambdabot>  error:
05:01:52 <lambdabot>      • Couldn't match expected type ‘[Integer -> b]’
05:01:53 <lambdabot>                    with actual type ‘[a0] -> [b0] -> [(a0, b0)]’
05:02:10 <bjs> gabbiel: something like do { x <- getLine; printf "hello %s\n" x } presumably?
05:02:14 <hpc> > zip`ap`tail $ [0..10] -- >:(
05:02:17 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
05:02:18 <bjs> gabbiel: i'm not sure what your question really is
05:02:25 <hpc> @quote aztec
05:02:25 <lambdabot> alpounet says: map succ/pred is a scandinavian name generator or what? ... well, scandinavian and aztec
05:02:35 <hpc> lambdabot pls
05:02:39 <officialGupta> @ongy interesting, I have not come across the right left thing before
05:02:39 <lambdabot> Unknown command, try @list
05:02:42 <gabbiel> bjs: it doesn't even work though
05:03:09 <hpc> Insanity_: basically turn the list into a list of consecutive numbers first, then sum each pair
05:03:29 <bjs> gabbiel: define doesn't even work?
05:03:32 <Insanity_> I see, that helps me a bit further, thanks hpc 
05:05:02 <gabbiel> bjs: doing printf "%d\n" some_integer doesn't work
05:05:29 <peddie> gabbiel: try calling  putStr  on the result of  printf fmt . . .
05:06:06 <bjs> gabbiel: remember that printf is polymorphic, it won't "magically" print
05:06:22 <bjs> gabbiel: put it in main or something and you'll see it'll print out
05:06:47 <peddie> gabbiel:   do { x <- getLine; putStr $ printf "hello, %s\n" x }
05:06:57 <gabbiel> I though printf was supposed to do IO
05:07:12 <peddie> :t printf
05:07:13 <Reshi> if it is in the IO monad it will
05:07:14 <lambdabot> PrintfType r => String -> r
05:07:14 <hpc> gabbiel: it's polymorphic, it can either produce a string or an IO action
05:07:15 <bjs> gabbiel: no, printf just returns a PrintfType, it *might* be IO
05:07:22 <bjs> gabbiel: it might just be a String
05:07:22 <hpc> gabbiel: to see how it works, look at https://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Printf.html#t:PrintfType
05:07:23 <gabbiel> peddie: the string works fine without putStr, but integers don't even work with putStr
05:07:42 <peddie> hpc: you're right, sorry
05:07:54 <peddie> I've had no idea about that for years!
05:08:14 <peddie> :t putStr
05:08:16 <lambdabot> String -> IO ()
05:08:18 <pavonia> gabbiel: putStr prints strings, integers are not strings
05:08:26 <peddie> gabbiel: it's not putInt ;)
05:08:42 <hpc> peddie: it's like a principled version of varargs
05:08:48 <hpc> peddie: (except still not very principled :D)
05:08:53 <gabbiel> pavonia: im talking in the context of applying putStr to printf "%d\n" integer
05:09:14 <peddie> hpc: it's not that principled . . . i know how the input varargs work, just didn't know about the output trick in IO
05:09:17 <hpc> (er, of varargs and operator overloading)
05:09:21 <pavonia> gabbiel: What's the error you get?
05:09:34 <peddie> hpc: pretty slick
05:09:50 <Reshi> won't printf just print directly if it is in the IO monad. The docs say " The return value is either String or (IO a)", and using it in the IO monad with strings or integer works
05:09:59 <gabbiel> ambiguous type variable
05:10:03 <peddie> Reshi: you're correct, I was wrong
05:10:30 <pavonia> gabbiel: The it probably can't infer the type of your integer/number
05:10:37 <pavonia> :t 123
05:10:39 <lambdabot> Num t => t
05:10:46 <pavonia> :t 123 :: Integer
05:10:47 <lambdabot> Integer
05:10:55 <bjs> Reshi: yes, so for instance, main = printf "hello %s" "bjs"
05:11:03 <bjs> or whatever
05:11:05 <gabbiel> i made the expression be :: IO Int and still didn't work
05:11:15 <bjs> gabbiel: make it be IO () 
05:11:38 <gabbiel> still won't clear up the 9, says its ambiguous again
05:11:51 <pavonia> Or paste the complete code to see where the problem lays
05:11:53 <bjs> gabbiel: what code are you actually using?
05:11:57 <bjs> gabbiel: can you lpaste it?
05:12:17 <gabbiel> it works
05:12:41 <gabbiel> you'd think the %d implies int, but one has to do printf "%d\n" (9::Int)
05:13:16 <peddie> gabbiel: the %d only happens at runtime; it can't imply anything to the type checker, sadly
05:13:18 <bjs> gabbiel: oh, right. The compiler doesn't actually look at the string
05:13:41 <bjs> gabbiel: the type checker/inference engine doesn't have anything special to look at the string (like OCaml etc do)
05:14:00 <bjs> which sadly means (printf "%d" "hello") typechecks !
05:14:04 <ggole> OCaml's strings are actually syntax sugar for a GADT
05:14:19 <ggole> Er, format strings
05:14:37 <ggole> It's quite a hack, although typesafe and very convenient
05:14:59 <bjs> ggole: it's very nice in practice
05:15:29 <bjs> that said, i don't think i've reached for a printf in haskell very often
05:15:59 <ggole> Yeah, deriving Show takes you quite far
05:16:02 <gabbiel> i often have that problem, and I have to chain many string with (++), I end up using foldl1 (++)
05:16:24 <MarLinn> I was following the discussion and noticed that when I ask ghci ":i PrintfArg" it annotates the instances with "[safe]". Does that mean the module is annotated as Safe (from Safe Haskell)?
05:17:39 <gabbiel> i wish I could make my own prelude, can you believe the (&) function is not in the prelude?
05:18:14 <MarLinn> gabbiel: it's in Data.Function though
05:18:37 <gabbiel> yeah, but importing it everytime is a pain
05:18:39 <peddie> gabbiel: you can make your own prelude, join in the current trend
05:18:53 <ongy> :t (&)
05:18:55 <lambdabot> a -> (a -> b) -> b
05:19:28 <gabbiel> its like flip ($)
05:19:29 <lyxia> foldl1 (++)    isn't that    concat 
05:19:46 <dibblego> concat = foldr (++) [] 
05:20:22 <dibblego> (++) = flip (foldr (:))
05:20:46 <lyxia> okay it's not even efficient 
05:21:10 * dibblego boggles
05:21:20 <Reshi> Hard to decide a default set of functions which gets imported implicitly and meets evryone's needs equally.
05:21:26 <gabbiel> unrelated, but don't you just hate when there are more than 2 parentheses together, like in putchar(getchar()), it make my blood boil
05:22:00 <gabbiel> thank god for ($) and (&)
05:22:09 <gabbiel> and (.)
05:23:03 * hackagebot SGplus 1.1 - (updated) Small geometry library for dealing with vectors and collision detection  https://hackage.haskell.org/package/SGplus-1.1 (donomii)
05:23:35 <lpaste> GGuy pasted “Type variable ambiguous” at http://lpaste.net/182423
05:24:28 <GGuy> Hi, how do i make is unambiguous so all "makeThings" have a "getString" (in the code above)?
05:24:35 <gabbiel> i really want to make my own wm, but i need to learn xlib, and I heard it takes forever
05:24:45 <srhb> GGuy: You probably should not be doing that at all, but makeThing "test" looks like the ambiguous thing
05:25:02 <srhb> GGuy: (makeThing "test" :: Thing1) should help
05:25:35 <GGuy> srhb: thanks, but if I had more then 1 thing and wanted them all to have a getString?
05:25:49 <GGuy> sorry, that didn't make sense
05:26:31 <GGuy> maybe I have to think on it more
05:26:54 <srhb> GGuy: Maybe save it for when you have a concrete problem. Anyway, disambiguate makeThing "test" and it should work.
05:27:13 <cocreature> gabbiel: take a look at the xmonad source to get started. it’s quite simple and you can read through the important parts in a day or so
05:27:39 <cocreature> it also doesn’t use a lot of external libs or fancy haskell stuff so even if you are a beginner (not sure if you are) it’s quite readable
05:29:46 <camm> I defined a data type without constructors: `data Void` but I can instance that data type with: `let void = undefined :: Void` and then I can use void. I'm confused :/ How that is possible?
05:29:50 <GGuy> srhb: my concrete problem is where I make instances for functions. So "instance MakeThing (String -> Thing1) where makeThing x = (\y -> x ++ y)".
05:31:02 <GGuy> srhb: And I want "getString $ makeThing "test"" and "getString $ makeThing "test" "test2"" to both resolve
05:31:08 <Insanity_> Another noobie question
05:31:12 <Insanity_> > [map read (permutations k) | k <- [show x | x <- [10..20]]]
05:31:15 <lambdabot>  [[*Exception: Prelude.read: no parse
05:31:19 <Insanity_> I think that is becuase I need of
05:31:25 <Insanity_> > read "01" 
05:31:28 <lambdabot>  *Exception: Prelude.read: no parse
05:31:30 <Insanity_> so I would solve it with
05:31:33 <Insanity_> > read "01" :: Int
05:31:36 <lambdabot>  1
05:31:50 <Insanity_> How can I add the type to the mapping function, that seems to constantly throw errors
05:32:00 <Insanity_> > [map read (permutations k) :: Int | k <- [show x | x <- [10..20]]]
05:32:02 <lambdabot>  error:
05:32:02 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[b0]’
05:32:02 <lambdabot>      • In the expression: map read (permutations k) :: Int
05:32:37 <MarLinn> > [map (read :: String -> Int) (permutations k) :: Int | k <- [show x | x <- [10..20]]]
05:32:39 <lambdabot>  error:
05:32:39 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Int]’
05:32:39 <lambdabot>      • In the expression:
05:33:15 <MarLinn> > [map (read :: String -> Int) (permutations k) | k <- [show x | x <- [10..20]]]
05:33:18 <lambdabot>  [[10,1],[11,11],[12,21],[13,31],[14,41],[15,51],[16,61],[17,71],[18,81],[19,...
05:33:33 <MarLinn> I copied too much
05:33:38 <Insanity_> Works like a charm, thanks :-)
05:38:07 <Insanity_> Now in the resulting list, I want to loop over all the indices. But I feel that I'm thinking in a very imperative way here
05:38:48 <Insanity_> If I'd want to apply succ to them: [succ x | x <- xs] would not work, as x takes the value of such a list, e.g [10,1]
05:39:04 <Insanity_> whereas [succ x!!0 | x...] would work
05:39:10 <Insanity_> But only on the first elements in the list
05:39:33 <lpaste> GGuy revised “Type variable ambiguous”: “Type variable ambiguous” at http://lpaste.net/182423
05:40:03 <GGuy> Hi, hopefully that's more clear what I'm trying to achieve?
05:40:20 <Insanity_> So the solution I'd use is this, which is thinking in terms of loops
05:40:59 <Insanity_> "[ succ (x!!y) | x <- xs, y <- [0..(length x) -1]]"
05:41:25 <Insanity_> It'd work, but it feels wrong
05:41:28 <jonored> Insanity_: [ [ succ y | y <- x] | x<-xs ] ?
05:42:42 <GGuy> I would have thought I could have defined the class as "class (GetString a) => MakeThing a", but it's still ambiguous
05:43:04 * hackagebot DPutils 0.0.0.2 - utilities for DP  https://hackage.haskell.org/package/DPutils-0.0.0.2 (ChristianHoener)
05:43:29 <Insanity_> Doesn't seem to work jonored, but I think that is along the right lines, I might have messed up along the way
05:43:50 <Insanity_> I had :-) works perfectly
05:44:09 <ongy> Insanity_: are you using list comprehension because you want to, or because it's the best way you know?
05:44:20 <jonored> Alternately, it's also map (map succ) xs
05:44:22 <Insanity_> Best way I know :P
05:44:35 <ongy> jonored: is it map (map succ) or concatMap (map succ)?
05:45:21 <zomg> succ? https://www.youtube.com/watch?v=fPNdWnwuBDI
05:45:22 <zomg> :P
05:47:11 <jonored> Insanity_: If you want to flatten the list as well (like your indexing does), you can also use x later in the list comprehension, like this:
05:47:34 <jonored> > [succ y | x <- [1..5], y<-x]
05:47:36 <lambdabot>  error:
05:47:36 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M861383740253...
05:47:36 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
05:48:04 * hackagebot OrderedBits 0.0.1.1 - Efficient ordered (by popcount) enumeration of bits  https://hackage.haskell.org/package/OrderedBits-0.0.1.1 (ChristianHoener)
05:48:19 <merijn> jonored: It can't tell which enum instance
05:48:45 <jonored> merijn: Yep. I should have checked before I showed that.
05:48:49 <merijn> Actually, that entire comprehension seems to make no sense?
05:49:14 <jonored> ...Ah! Yes, that's wrong.
05:51:00 <jonored> > [succ y | x <- [[1..5],[1..2]], y <- x]
05:51:02 <lambdabot>  [2,3,4,5,6,2,3]
05:51:07 <jonored> is what I meant, of course.
05:53:04 * hackagebot bimaps 0.1.0.0 - bijections with multiple implementations.  https://hackage.haskell.org/package/bimaps-0.1.0.0 (ChristianHoener)
05:54:17 <Insanity_> Cheers jonored :-)
05:54:20 <lpaste> GGuy revised “Type variable ambiguous”: “Type variable ambiguous” at http://lpaste.net/182423
05:55:10 <lpaste> GGuy revised “Type variable ambiguous”: “Type variable ambiguous” at http://lpaste.net/182423
05:56:44 <cocreature> GGuy: you need to make a type annotation for the result of makeThing
05:57:03 <lpaste> f-a pasted “simple pipes” at http://lpaste.net/182437
05:58:35 <cocreature> f-a: because k only yields one time. pipes do not automagically loop. if you want that you need to recurse, i.e., use k as the last statement of k
05:59:12 <f-a> thanks cocreature 
05:59:18 <cocreature> yw
06:00:02 <GGuy> cocreature: Is there a way not to type annotate? In the code there is only one instance that's valid.
06:00:42 <cocreature> GGuy: no ghc doesn’t autoresolve ambiguities automatically even if there is only one instance in scope
06:04:05 <GGuy> cocreature: Okay thanks
06:06:05 <GGuy> cocreature: I noticed lucid does something similar but I guess in that case it's not ambiguous since they use functional dependencies https://github.com/chrisdone/lucid/blob/master/src/Lucid/Base.hs#L197
06:08:41 <cocreature> GGuy: the functional dependencies will only help resolving ambiguities for arg if the type of result is known
06:09:50 <GGuy> cocreature: Great, thanks! I think it just clicked.
06:18:05 * hackagebot pretty-types 0.2.2.0 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.2.2.0 (SvenHeyll)
06:35:33 <bjorn__> how to tell stack build to find a system lib in a particular path?
06:35:53 <bjorn__> it can't find libcurl
06:36:07 <maerwald> curl has a pkg-config file, it should find it
06:36:14 <maerwald> does cabal use pkg-config?
06:36:22 <dcoutts> maerwald: yes
06:36:32 <bjorn__> im on windows btw
06:36:36 <maerwald> dcoutts: I mean the specific cabal file
06:36:41 <dcoutts> oh :-)
06:36:57 <maerwald> bjorn__: ah, bad luck, no idea about windows
06:38:06 * hackagebot PrimitiveArray 0.7.1.0 - Efficient multidimensional arrays  https://hackage.haskell.org/package/PrimitiveArray-0.7.1.0 (ChristianHoener)
06:48:06 * hackagebot preprocessor 0.1.0.0 - Remove cpp annotations to get the source ready for static analysis.  https://hackage.haskell.org/package/preprocessor-0.1.0.0 (meditans)
06:48:08 * hackagebot pretty-types 0.2.2.1 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.2.2.1 (SvenHeyll)
06:50:40 <chpatrick> is it possible to add a constraint to the forall a. in ForallF?
06:54:02 <Gurkenglas> When a cabal dependency goes up to the next major version, you need to qualify or restrict your imports from that package, because it could introduce a name collision with something else in a minor version, right?
06:55:22 <ongy> Gurkenglas: afaik new names can be introduced with minor version bump either way. Major version is for breaking changes i.e. removing a function
06:56:30 <Gurkenglas> I mean that adding a function can be a breaking change, like if Data.Sequence added chunksOf and you import both that and Data.List.Split
06:59:39 <bjorn__> http://lpaste.net/182468
06:59:47 <bjorn__> how to parse this rss feed
07:00:04 <bjorn__> and get the torrent link in the item section?
07:00:25 <bjorn__> could anyone suggest an easy rss lib ?
07:19:54 <jophish> Is there a library for loading fonts in haskell,
07:20:00 <jophish> besides sdl-ttf?:
07:20:54 <jophish> ah, fontyFruity
07:23:17 <Gurkenglas> bjorn__, what part of that text do you want? You probably want either some general parser library or something that specializes in html
07:23:46 <Gurkenglas> (If you just want one thing from all that there might be a simple oneliner)
07:24:31 <nitrix> Gurkenglas: This is one of the arguments that goes for the import style where people list explicitely only the functions they need.
07:24:57 <nitrix> Gurkenglas: It's supposed to avoid future breakage during library upgrades that as adding clashing names.
07:25:03 <nitrix> *are
07:27:46 <bjorn__> Gurkenglas, i want the enclosure url
07:28:02 <bjorn__> and i am writing a Turtle script to automate the task
07:29:08 <Gurkenglas> :t fmap (takeWhile (/='\"')) . firstJust (stripPrefix "<enclosure url=\"") . tails -- bjorn__ 
07:29:10 <lambdabot> [Char] -> Maybe [Char]
07:30:45 <Gurkenglas> :t takeWhile (/='\"') . head . mapMaybe (stripPrefix "<enclosure url=\"") . tails -- Or if you don't want to import Data.List.Extra and don't mind crashing if it's not in there, this.
07:30:47 <lambdabot> [Char] -> [Char]
07:31:13 <nitrix> Gurkenglas: Wouldn't that break on "\\"" ?
07:31:38 <Gurkenglas> I don't follow
07:31:58 <Gurkenglas> You mean if there's escaped quotes in the url?
07:32:12 <nitrix> If someone has a string that escapes " with \" then your parser will get fooled thinking \" is the end of the string.
07:32:45 <Gurkenglas> Didn't even know you can put quotes in urls if you escape them ^^
07:33:22 <nitrix> It's not about URL themselves, it's about wether or not you trust the source of the data.
07:33:50 <nitrix> Any quote in a string will crash that parser.
07:34:00 <nitrix> Can I recommend tagsoup ?
07:34:49 <Gurkenglas> Any strings except the one following enclosure url isn't considered in the first place
07:35:09 <Gurkenglas> And \" doesn't crash that one, the url just gets cut off in a suggestive way :P
07:35:34 <nitrix> What if someone has this enclosure url inside another string?
07:35:52 <nitrix> There's all kind of ways this parser will crash.
07:36:05 <Gurkenglas> What do you mean, inside another string? The rss feed is given in a string
07:36:38 <nitrix> I use crash because crashing is worse than failing. A parser that fails, you know the input is malformed, but a parser that fail, the input is formed properly, it's you that's making a parsing mistake.
07:37:04 <nitrix> Gurkenglas: An XML key-value property where the value is a string wrapped by quotes.
07:37:23 <nitrix> <foo bar="<enclosure url=">
07:37:44 <Gurkenglas> It is a string wrapped by quotes, I strip the quotes with the \" and the takeWhile (/='\"')
07:38:06 <nitrix> <enclosure url="foo\"bar"> that also fails.
07:38:31 <nitrix> You'll obtain foo\
07:38:40 <Gurkenglas> <Gurkenglas> And \" doesn't crash that one, the url just gets cut off in a suggestive way :P
07:38:49 <nitrix> When you were meant to read foo"bar
07:39:29 <nitrix> Gurkenglas: It's a crash of the parser, it'll trip on the wrong delimiters if you don't handle escaping.
07:39:39 <nitrix> Gurkenglas: Then you'll have further issues down the road.
07:42:36 <Gurkenglas> In this case by the parser failing you mean the program crashing, any by the parser crashing you mean the parser returning a value that the programmer didnt intend to get?
07:43:08 * hackagebot Craft3e 0.1.1.0 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  https://hackage.haskell.org/package/Craft3e-0.1.1.0 (SimonThompson)
07:43:27 <nitrix> No, the parser is crashing, not the whole program. Because you've made assumptions on the stability of the parser, it'll keep going, but you'll get the wrong data parsed if it does trip on something.
07:43:38 <nitrix> Gurkenglas: e.g. foo\ instead if foo"bar earlier.
07:44:18 <nitrix> Gurkenglas: It "crashes" in the sense that it's operational semantics aren't going to follow the desired denotational semantics.
07:45:12 <Gurkenglas> Maybe I shouldn't have used "crashing" in my translation. (I understand that word as "the program halts and perhaps you get some sort of stderr output")
07:45:21 <nitrix> You'll ask the parser to parse a dot thinking you're in a completely different context, while it's still stuck behind trying to find the same dot in the wrong context because it tripped on something earlier.
07:45:49 <Gurkenglas> But he only wants the enclosure url, of course that approach doesnt scale well
07:46:06 <nitrix> Gurkenglas: Crash as in "move or caused to move with force".
07:46:24 <nitrix> Or with obstacles.
07:46:52 <nitrix> Gurkenglas: What if we recommend something more sane instead, like tagsoup ?
07:47:31 <Gurkenglas> Right at the start I gave him the keyword he'd need to google to find that x)
07:47:43 <Gurkenglas> But importing tagsoup just to get out that url seems overkill
07:48:00 <nitrix> Why is that?
07:48:37 <Gurkenglas> Because I remember when I first tried tagsoup and it took me a long while to understand enough to get my code working
07:48:47 <nitrix> Rewriting parsers that already exist (especially for something as widely used as HTML/XML) seems uncalled for.
07:49:09 <nitrix> Gurkenglas: parseTags and ~== or ~/=
07:49:16 <nitrix> There's like three operations...
07:50:01 <nitrix> Where ~== is for tag equality and ~/= is the not equal variant.
07:50:20 <nitrix> Oh, fromAttrib if you need the `url` attribute.
07:50:29 <MarcelineVQ> well what's the oneliner with tagsoup to do the job?
07:50:35 <quchen_> MuniHac participants: depending on the weather we might be heading out to the beer garden this evening. Looks a bit dark right now, but forecast says it’ll be fine. /join #munihac
07:51:13 <kosmikus> quchen_: I'll repeat this via twitter
07:51:24 <nitrix> MarcelineVQ: It'd be the same takeWhile / dropWhite, but you'd have a predicate that's (~== TagOpen "enclosure")
07:53:20 <Gurkenglas> Then using the preludey operators the same way doesn't count as a rewrite :P
07:54:11 <nitrix> Gurkenglas: It's meant to stay simple/"naive". With the benefit that now your parser is much more resilient.
07:54:37 <nitrix> Otherwise, yeah, you could use stuff like `sections` and the other things the library provides.
08:12:46 <prsteele> Hello everyone. Anyone have opinions about using persistent versus postgreSQL-simple?
08:14:01 <bartavelle> prsteele, persistent (optionally) does a lot of work for you, such as converting data types and maintaining database schema
08:14:24 <bartavelle> however for it to work well you'd better define your data types in the persistent template haskell stuff
08:14:47 <bartavelle> with enough types (tables), that makes compilation very slow to me
08:15:37 <prsteele> thanks. persistent definitely looks like it has better features, but I'm not sure it's worth the overhead of using their style
08:16:12 <sm> bartavelle: how many do you have ?
08:16:16 <bartavelle> to me it's very much worth it
08:16:34 <prsteele> well I'll take a stab at converting my data types then
08:16:55 <bartavelle> prsteele, yeah, but don't forget you'll have to maintain that code as you change your database schema
08:17:37 <prsteele> bartavelle: ya I suppose persistent might make it easier to add new columns later
08:17:37 <bartavelle> sm, just 26 in the project i'm currently working on
08:17:59 <sm> ouch
08:18:28 <stringer> Hey, if there is a function:  warbler f x = f x x The type of map warbler is [a -> a -> b] -> [a -> b] I'd like to understand why
08:18:29 <bartavelle> I also derive the json and lens stuff, so it's kinda slow when I have to change stuff in this file
08:19:29 <sm> there's an app I've wanted to try it for, but 200 tables.. sounds like compilation delay would be hellish
08:20:25 <bartavelle> sm, it's not as bad as the other file, where I define a bunch of other types and derive lens, aeson and elm-bridge :/
08:20:55 <sm> bartavelle: would groundhog be any better ? I hear it does migrations too
08:21:29 <bartavelle> I have no experience with it. What's slow here is TH stuff. But that's also noticeably faster than my having to type the relevant code, so :)
08:22:36 <sm> cool
08:22:37 <ski> stringer : `map :: (a -> b) -> ([a] -> [b])' for all types `a' and `b'. and for your `warber' the type is `(a -> a -> b) -> (a -> b)' (agree ?). so setting `a' in `map' to `a -> a -> b' and `b' in `map' to `a -> b', the argument type of `map' becomes equal to the type of `warbler', and then the result type (of `map') is `[a -> a -> b] -> [a -> b]'
08:22:48 <prsteele> looking ahead -- is there any reason I can't have an "Either a b" field in a persistent data structure? Does it handle sum types in a reasonable way?
08:23:20 <sm> bartavelle: so when you're hacking on your app.. say doing a reload in GHCI.. if you haven't changed the schema, it still reloads pretty quickly I suppose ?
08:23:27 <stringer> ok i get it
08:26:46 <bartavelle> sm, yup
08:27:49 <sm> thanks
08:28:21 <MarLinn> from what I heard in a similar discussion here yesterday groundhog and persistent are based on the same code, but persistent has TH while groundhog has JSON - which might be faster, but I hear it's awkward to use in this case
08:28:59 <bartavelle> there is also http://hackage.haskell.org/package/opaleye if you want type safe arbitrary queries
08:29:23 <bartavelle> I use esqueleto, which is pleasant in the sense that it very much maps to the generated SQL, but it's not really type safe
08:29:29 <bartavelle> (it can generate invalid queries)
08:30:05 <MarLinn> People who've used Haskell + DBs in production code seem to have become pragmatic and use plain SQL with flat wrappers. I get that even after using esqueleto for a dozen tables
08:31:26 <MarLinn> used = used extensively with many tables
08:31:26 <bartavelle> I always use persistent and/or esqueleto, but I don't really have tough DB problems
08:31:35 <Cooler> when chaining together functions that produce maybe values with >>=
08:31:53 <Cooler> if one function returns a nothing, is that checked at each step afterwards?
08:32:25 <bartavelle> Cooler, you can see that for yourself by looking at the implementation
08:32:28 <bartavelle> lemme find it
08:32:38 <MarLinn> Yeah, persistent is nice. Especially if you use Yesod's trick of putting it into its own module. No DB changes -> no recompilation
08:33:03 <bartavelle> Cooler, http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-665
08:33:20 <bartavelle> Cooler, so as you can see, it should ignore what's on the "right" of >>=
08:33:34 <ski> @src Maybe (>>=)
08:33:34 <lambdabot> (Just x) >>= k = k x
08:33:34 <lambdabot> Nothing  >>= _ = Nothing
08:33:43 <bartavelle> oh that's even better
08:33:48 <ski> Cooler : depends on whether you're left-recursive
08:33:51 <Cooler> return a >>= f1 >>= f2 >>= f3 >>= f4 >>= f5 >>= f6 >>= f7 >>= f8, if f2 gives a nothing, is that checked by bind at f3. f4, etc?
08:34:27 <ski> you may want to try `Codensity Maybe'
08:35:32 <Cooler> can it just stop evaluating and return a nothing as the result of the expression or does >>= need to check at f3, f4, f5, f6, f7 and f8?
08:35:40 <ski> Cooler : in `ma >>= (\a -> amb a >>= \b -> bmc b)' the outer `(>>=)' will abort so that neither `amb a' nor `bmc b' are tried
08:36:16 <ski> Cooler : in `(ma >>= (\a -> amb a)) >>= (\b -> bmc b)', both `(>>=)' will interpret the `Nothing' from `ma'
08:36:23 <ski> (unless magic happens)
08:36:47 <Cooler> ski, you added brackets that changes things
08:36:54 <prsteele> Cooler: foldr1 (>=>) (repeat (\x -> Nothing)) $ 1
08:37:04 <ski> Cooler : no, these are equal per the associativity law
08:37:36 <prsteele> Cooler: that terminates, so it's not checking the entire infinite list
08:37:58 <ski> Cooler : the point is that one alternative here is better than the other, for `Maybe'
08:38:21 <ski> Cooler : the typical cause of left-associatedness/nestedness here would be left-recursion
08:38:36 <ski> Cooler : `Codensity Maybe' would avoid this
08:38:54 <Cooler> what is codensity
08:38:55 <Cooler> ?
08:38:57 <prsteele> Cooler: and swapping in foldl1, instead, hangs
08:39:32 <ski>   newtype Codensity f a = MkCodensity (forall b. (a -> f b) -> f b)
08:40:04 <ski> it's capturing a particular (nq)CPS pattern of code
08:40:36 <ski> Cooler : the whole situation is similar to why `xs ++ (ys ++ zs)' is better than `(xs ++ ys) ++ zs'
08:40:56 <ski> and the (`Codensity') solution is also similar to the solution to that (which is to introduce an accumulator)
08:41:37 <Cooler> ski, so you saying the expression  f1 >>= f2 >>= f3 >>= f4 is evaluated as f1 >>= (f2 >>= f3 >>= f4) ?
08:41:39 <ski> Cooler : you know about `xs ++ (ys ++ zs)' versus `(xs ++ ys) ++ zs', right ?
08:42:32 <ski> actually `>>=' is declared as `infixl', so `f1 >>= f2 >>= f3 >>= f4' would be parsed as `((f1 >>= f2) >>= f3) >>= f4'
08:43:06 <ski> however, `f1 >>= \x -> f2 x >>= \y -> f3 x y >>= \z -> f4 x y z' would be parsed as `f1 >>= (\x -> f2 x >>= (\y -> f3 x y >>= (\z -> f4 x y z)))'
08:43:43 <ski> and i believe that the `do'-desugaring will generate the right-associated version from the command sequence inside the `do'-expression
08:45:10 <stringer> since map wrabler is [a -> a -> b] -> [a -> b] why can't I use it like map wrabler [ (+) 4 5, (+) 1 2] ?
08:45:20 <Cooler> so in ((f1 >>= f2) >>= f3) >>= f4 , instead of returning nothing as soon as f2 fails, it will keep checking if its nothing at f3 and f4
08:46:02 <bartavelle> stringer, (+) 4 5 has type "Num a => a", not "a -> a -> a"
08:46:09 <bartavelle> it's (+) that has this type
08:46:48 <ski> it would have to be something like `zipWith uncurry (map warbler [(+),(+)]) [(4,5),(1,2)])'. or, if you prefer, `zipWith ($) (zipWith ($) (map warbler [(+),(+)]) [4,1]) [5,2]'
08:47:04 <stringer> oh ok
08:47:10 <ski> `map warbler' wants a list of functions
08:47:35 <ski> hm, actually, that doesn't typecheck
08:48:02 <ski> `warbler (+)' only wants a single input, so make that `zipWith ($) (map warbler [(+),(+)]) [4,1])', say
08:48:38 <ski> aka `zipWith warbler [(+),(+)] [4,1]'
08:49:41 <Cooler> ski, what do you mean xs ++ (ys ++ zs)' versus `(xs ++ ys) ++ zs ?
08:50:49 <ski> `(xs ++ ys) ++ zs' will copy `ys' once, and `xs' twice
08:51:00 <ski> while `xs ++ (ys ++ zs)' will only copy `xs' once
08:51:16 <ski> left-nesting `++' is bad
08:51:30 <ski> so `foo ... = foo ... ++ something' is bad
08:52:04 <ski> (this is the reason that the result type of `shows' (and `showsPrec') is `ShowS' (which is `String -> String'), rather than `String', e.g.)
08:52:18 <ski> e.g., the naive definition of `reverse' :
08:52:23 <ski>   reverse :: [a] -> [a]
08:52:29 <ski>   reverse [    ] = []
08:52:38 <ski>   reverse (x:xs) = reverse xs ++ [x]
08:52:40 <ski> is inefficient
08:52:48 <ski> better is
08:52:56 <ski>   reverse xs = shunt xs []
08:52:59 <ski> where
08:53:06 <ski>   shunt :: [a] -> [a] -> [a]
08:53:11 <ski>   shunt [    ] acc = acc
08:53:22 <ski>   shunt (x:xs) acc = shunt xs (x:acc)
08:53:34 <ski> Cooler : makes sense ?
08:54:02 <ski> repeatedly adding something to the end of a list is bad, since you have to repeatedly traverse the list from the beginning each time
08:55:41 <ski> the problem is that e.g. `reverse [2,3,5,7]' here will generate `((([] ++ [7]) ++ [5]) ++ [3]) ++ [2]', which is a left-nested/associated use of `++' (due to the naive `reverse' being "left-recursive" (wrt `++'))
08:56:20 <ski> so naive `reverse' will take `O(n^2)' time (`n' being the length of the input list), rather than the expected `O(n)'
08:56:35 <ski> the version using `shunt' will take `O(n)' time
08:57:41 <Cooler> ski, yeah that makes sense
08:57:58 <ski> anyway, the point with `>>=' is basically the same
08:58:04 <Cooler> and all of this is because lists are linked lists in haskell?
08:58:15 <ski> (for monads where `>>=' "interprets" the left argument, i.e.)
08:58:44 <johnw> Cooler: when a Haskell program executes, some lists become straight code loops; it's not always a "linked list in memory"
08:58:49 <ski> lists are single-linked lists, yes
08:59:00 <Welkin> how could `reverse` ever be O(n^2)?
08:59:34 <ski> (also what johnw said. conceptually, it's a linked list, but it can be "virtual"/"ephemeral")
08:59:48 <ski> Welkin : naive reverse, see above
09:00:33 <AzureStigma> having trouble understanding this
09:00:34 <AzureStigma> http://lpaste.net/182528
09:00:36 <Welkin> lol
09:00:36 <ski> anyway, a slighty different way (with a different focus) to write `shunt' above is
09:00:41 <ski>   shunt [    ] = id
09:00:42 <AzureStigma> can someone please tell me what exactly is going on
09:00:44 <Welkin> for people who don't know that : exists
09:00:51 <ski>   shunt (x:xs) = shunt xs . (x:)
09:01:02 <Cooler> ski, so you avoid the normal  f1 >>= f2 >>= f3 >>= f4 ?
09:01:18 <bartavelle> AzureStigma, what is the unexpected result ?
09:01:20 <Cooler> because its left associative?
09:01:47 <AzureStigma> no its the example given for partial application
09:01:52 <AzureStigma> but i dont get it fully
09:01:58 <bartavelle> oh!
09:02:00 <puregreen> Welkin: O(n²) reverse is a common beginner implementation. It doesn't mean that the person who wrote it doesn't know that (:) exists.
09:02:03 <ski> Cooler : i think  `f1 >>= \x -> f2 x >>= \y -> f3 x y >>= \z -> f4 x y z' would be more common in practice than `f1 >>= f2 >>= f3 >>= f4', yes ?
09:02:03 <Welkin> AzureStigma: (+) 4 ?
09:02:08 <ski> Cooler : also, it depends
09:02:15 <bartavelle> AzureStigma, do you understand what the type of both addTen and fifteen are ?
09:02:29 <AzureStigma> no
09:02:32 <AzureStigma> yes
09:02:33 <AzureStigma> kinda
09:02:39 <bartavelle> :t (+)
09:02:40 <bartavelle> :t (+) 4
09:02:41 <lambdabot> Num a => a -> a -> a
09:02:42 <lambdabot> Num a => a -> a
09:02:44 <bartavelle> :t (+) 4 5
09:02:46 <lambdabot> Num a => a
09:03:01 <ski> Cooler : `long_list ++ [1,2,3]' isn't necessarily bad. it's when you do this thing *repeatedly* that you have to consider whether to rewrite it
09:03:12 <Welkin> `a -> b -> c` is the same as `a -> (b -> c)`
09:03:50 <AzureStigma> i see 
09:04:20 <AzureStigma> but now the two equal parts im confused with
09:04:29 <ski> Cooler : if you find this is a problem in practice, i would suggest using `Codensity Maybe' in place of `Maybe' there
09:04:33 <Cooler> ski, i don't understand f1 >>= \x -> f2 x >>= \y -> f3 x y >>= \z -> f4 x y z
09:04:44 <Cooler> f1, f2, etc are functions
09:04:47 <ski> Cooler : also holds for other "expression-like" monads
09:04:58 <Cooler> that have type a -> ma
09:05:00 <ski> Cooler : what is the actual code you're considering ?
09:05:13 <ski> Cooler : you do know how `do' desugars, yes ?
09:05:28 <Cooler> but theres no do notation here
09:05:38 <ski> @undo do x <- f1; y <- f2 x; z <- f3 x y; f4 x y z
09:05:38 <lambdabot> f1 >>= \ x -> f2 x >>= \ y -> f3 x y >>= \ z -> f4 x y z
09:05:52 <Welkin> @do f1 >>= \x -> f2 x >>= \y -> f3 x y >>= \z -> f4 x y z
09:05:52 <lambdabot> do { x <- f1; y <- f2 x; z <- f3 x y; f4 x y z}
09:05:54 <Welkin> lol
09:06:10 <ski> which means `f1 >>= (\x -> f2 x >>= (\y -> f3 x y >>= (\z -> f4 x y z)))'
09:06:25 <ph88^> does anyone know how to get the current position in megaparsec ?
09:06:46 <puregreen> ph88^: getPosition
09:06:49 <Cooler> ski, i was thinking of something like this return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)
09:06:57 <ski> it's not clear to me whether the actual code you're considering uses `do'-notation, or uses `(>>=)' with lambdas, or `(>>=)' without lambdas
09:06:59 <Cooler> from here http://learnyouahaskell.com/a-fistful-of-monads
09:07:08 <puregreen> ph88^: see the “Low-level operations” section in https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec.html
09:07:21 <ph88^> puregreen, how do i know which functions are available to me in that monad ?
09:07:51 <stringer> what does that mean that function is strict ? why (head . map f) xs = (f . head) xs is true only when function is strict
09:07:55 <ski> Cooler : perhaps in some cases GHC can spot this kind of problem, and automatically transform it away. i dunno
09:08:27 <puregreen> ph88^: MonadParsec is a class for parsers, which simply means that getPosition will work in any parser
09:08:35 <puregreen> I'm not sure I understand your question
09:08:38 <ski> but assuming a non-sufficiently-smart-optimizer, *if* you notice that this is a problem, you'd consider rewriting `return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)', possibly using `Codensity'
09:09:54 <ph88^> puregreen, i mean in the source code of MonadParsec https://hackage.haskell.org/package/megaparsec-5.0.1/docs/src/Text-Megaparsec-Prim.html#MonadParsec  i don't see getPosition
09:10:01 <Cooler> ski, can it skip evaluating landLeft (-1) and getting a function of type pole -> Maybe pole if the expression fails before it reaches that point?
09:10:38 <Cooler> or does it have to evaluate that as well?
09:10:47 <puregreen> ph88^: Ah. Well, yep, getPosition isn't a class method, it's a function written with getParserState
09:10:48 <ph88^> puregreen, i see failure, label, hidden, try, lookahead, notFollowedBy, withRecovery, eof, token, tokens, getParserState and updateParserState  .. after that it's some other code
09:10:54 <ski> Cooler : depends on how you write it
09:11:31 <puregreen> so your question is basically unanswerable except for using grep :)
09:11:40 <ph88^> puregreen, how can it be that i can use the functions from getParserState inside MonadParsec ?
09:12:02 <ph88^> oh i think i see
09:12:14 <ph88^> it's just a general function that so happens to work on getParserState  right ?
09:12:22 <ski> Cooler : if you write it exactly as `return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)', then no, unless the implementation happens to be smart enough to optimize that to something better
09:12:31 <bartavelle> ph88^, MonadParsec is not a concrete type, it's a typeclass
09:12:53 <ph88^> puregreen, so all functions inside a monad can access the methods of the class just like that ?
09:13:07 <bartavelle> ph88^, your actual type is probably ParsercT something, and it has a MonadParsec instance (https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Prim.html#t:Parsec)
09:13:08 <ski> (assuming `landLeft :: Birds -> Pole -> Maybe Pole', rather than `landLeft :: Birds -> Pole -> Codensity Maybe Pole')
09:13:34 <bartavelle> ph88^, that's the reason you can use any functions with a "MonadParsec" constraint
09:14:42 <ph88^> bartavelle, that's pretty cool, can i also overwrite methods like getParserState  ?
09:15:05 <Cooler> ski, is there some way to rewrite this where it would be able to terminate early?
09:15:27 <bartavelle> ph88^, you'll need to declare another type, and write a MonadParsec instance for it
09:16:04 <ski> Cooler : either write it in a right-associated way (or use `do'-notation, which amounts to the same thing), or use `Codensity' (or something similar)
09:16:05 <ph88^> bartavelle, i can not inherit from an existing type, use all methods definitions and overwrite just 1 ?
09:16:42 <bartavelle> ph88^, you can *sort of* do that with newtypes, but if you are an OOP programmer, you must see the error of your ways first :p
09:16:53 <ph88^> :P
09:17:11 <ski> Cooler : perhaps the simplest/nicest way to do the first option would be `(landLeft 1 >=> landRight 4 >=> landLeft (-1) >=> landRight (-2)) (0,0)'
09:17:19 <ski> (since `>=>' is right-associative)
09:18:05 <ph88^> bartavelle, why does the ParsecT type have so many instances? https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Prim.html#t:ParsecT
09:18:40 <johnw> because it's a monad transformer
09:18:42 <ph88^> i think type classes work a bit like traits in other languages
09:18:42 <bartavelle> ph88^, because they are useful :) first of all, because it's a monad transformer, and thus "lifts" the instances of the underlying monad
09:18:47 <johnw> this is fairly typical of transformers
09:18:59 <bartavelle> ph88^, yeah it's a *bit* like that
09:19:03 <aarvar> ph88^: in what sense
09:19:26 <ph88^> that you know if the class implements a trait that you can call certain methods on it
09:19:47 <bartavelle> ph88^, the instances that have a MonadSomething in front of them are typical of monad transformers
09:20:11 <bartavelle> ph88^, then MonadFail/Applicative/Alternative/MonadPlus are typical of parsers
09:20:28 <bartavelle> (json decoding, binary deserialization, etc.)
09:20:41 <bartavelle> well MonadFail/Applicative are very generic
09:21:14 <ski> @src (>=>)
09:21:14 <lambdabot> Source not found. You type like i drive.
09:21:18 <ski> bah
09:21:29 <ski>   (f >=> g) x = f x >>= g
09:23:04 <ph88^> bartavelle, do you know if i have a parser like    underline :: Parser Char;  underline = char '_'   if there is a way to make it   underline :: Parser (Char, Position);  underline = do;  pos <- getPosition;  u <- char '_';  return (u, pos)     ?
09:23:46 <bartavelle> ph88^, you can write a combinator that does it for you ... but I don't know if I understood your question properly
09:23:52 <ph88^> like i want to always append the getPosition operation to my parser monad and make it into a tuple. So that i don't have to do it in each parser
09:24:00 <bartavelle> withPosition :: Parser a -> Parser (a, Pos)
09:24:01 <Prutheus> Hello! My script using curl is generating a file named "cookie" when executed. why? how to don't let it created? I think the cause is in my self-defined curlPost' function. please have a look https://github.com/Prutheus/VISA/blob/master/Main.hs
09:24:26 <ph88^> bartavelle, yes that looks good !
09:24:45 <ph88^> i still have to put   withPosition    everywhere but at least it's less typing
09:25:04 <bartavelle> ph88^, be a true haskeller and use a one-letter function then ;)
09:25:08 <ph88^> :P
09:25:30 <fr33domlover> Q: Is there a way to force recompilation of a specific source file? I have a source file that uses TH to display the git hash of the running app, and ocassionally I want it updated, preferrably without rebuilding the entire app
09:25:36 <ph88^> is there any other useful information i can get from the MonadParser methods ?
09:26:09 <bartavelle> ph88^, what would you like to retrieve ?
09:26:25 <stringer> what does that mean that function is strict ? why (head . map f) xs = (f . head) xs is true only when function is strict
09:26:36 <LordBrain> fr33domlover, this question is after trying 'touch file.hs' and finding it still builds other stuff?
09:26:50 <ski> stringer : `f' is strict means that `f _|_ = _|_'
09:27:32 <ski> iow, the value/result of applying `f' to an unending computation ("bottom") is an unending computation
09:27:34 <fr33domlover> LordBrain, `touch`ing a file causes it to be rebuilt? if yes then that's what I need :P
09:27:57 <stringer> ski : ok and how is this affecting my example ?
09:28:08 <LordBrain> fr33domlover, i think so, but i'm assuming cabal/stack use time stamps like make
09:29:22 <fr33domlover> LordBrain, thanks. having some unrelated error here, i'll try `touch` when i'm done with that
09:29:28 <ski> stringer : i don't see why it would only hold when `f' is strict
09:30:43 <ski> oh, i see
09:31:58 <ski> stringer : in case `f' is non-strict, then `(f . head) xs' is non-bottom, even when `xs' is bottom or `[]'. otoh, in that case `(head . map f) xs' is still bottom
09:32:06 <stringer> ski : ok, I read somewhere about "laziness" of strict functions and I thought maybe that means that if xs is infinite f doesn't wait until it is fully genereted but takes head as soon as list has first element ( I can't tell if I express myself right)
09:32:31 <ski> s/even //
09:33:05 <ski> infiniteness of `xs' doesn't matter here
09:33:10 * hackagebot legion 0.2.0.0 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.2.0.0 (taphu)
09:33:18 <stringer> ok
09:33:34 <ski> what matters is whether `head' will give a defined result or not
09:33:41 <bartavelle> stringer:
09:33:45 <bartavelle> > (const 3 . head) []
09:33:46 <ski> (or at least partially defined)
09:33:47 <lambdabot>  3
09:33:55 <zennist> how do you type multiple lines of an expression into ghci in one line? e.g., a case structure
09:34:12 <Jaak> > (head . map (const 3)) []
09:34:15 <lambdabot>  *Exception: Prelude.head: empty list
09:34:23 <ski> zennist : one alternative is `case ... of {... -> ...; ... -> ...}' &c.
09:34:34 <srhb> zennist: within :{ and }: is the "prettiest", albeit slightly inconvenient.
09:34:46 <ski> zennist : another alternative is to start with `:{', then enter multiple lines (indented), then end with `:}'
09:34:51 <Prutheus> HELLO? anyone an idea maybe?
09:34:53 <zennist> does this work for other expressions too? like a let with multiple bindings?
09:34:56 <Prutheus> Hello! My script using curl is generating a file named "cookie" when executed. why? how to don't let it created? I think the cause is in my self-defined curlPost' function. please have a look https://github.com/Prutheus/VISA/blob/master/Main.hs
09:35:12 <ski> zennist : yes, also `do'
09:35:32 <zennist> I find multiline unwieldy - oftentimes need to quickly change a previous expression, and if it's a multiline, it's not easy to edit
09:35:34 <bartavelle> Prutheus, I don't know if many people use the Curl library, I think stuff like http-client or wreq are much more popular
09:35:46 <Prutheus> kk
09:36:05 <zennist> like: let { a = 3; b = 4} ?
09:36:33 <ski> yes
09:36:56 <ski> (also inside `do' and list comprehensions)
09:37:08 <zennist> I see - so in general, if an expression can be multiline, it can be transformed into single line by putting braces around and semi-colon separating the lines
09:37:17 <zennist> i wish this is in the official syntax guide
09:37:17 <ski> > [(x,y) | let x = 2; y = 3]
09:37:19 <lambdabot>  [(2,3)]
09:37:40 <ski> (often the `{'s and `}'s can be avoided)
09:38:37 <srhb> zennist: What official syntax guide? :-P
09:39:09 <zennist> srhb: mhh, just any web page claiming to introduce all the syntax in haskell :)
09:39:30 <srhb> zennist: Probably not official. It is in the language report. :)
09:40:02 <zennist> i really wish there can be an advanced interpretter built on top of ghci like ipython for python
09:40:08 <ski> zennist : anyway, braces and semicolons are alternatives to *layout* specifically
09:40:18 <zennist> with package like 'turtle' we don't need bash/zsh anymore
09:40:21 <srhb> zennist: Section 10.3 "Layout" describes this.
09:40:23 <ski> (so don't just insert them willy-nilly)
09:40:25 <bartavelle> zennist, https://hackage.haskell.org/package/ihaskell
09:42:54 <zennist> bartavelle: interesting - but why does it require ipython?
09:42:56 <EvanR> Cale: dfeuer's classes Empty and Boring were ignoring bottom im sure, so no fair throwing almost any theory out based on bottoms
09:43:21 <bartavelle> zennist, probably because it was easier to just write the kernel and reuse all ipython facilities
09:44:05 <mnoonan> is there any better feeling in the world than to watch a haskell process' memory usage go *down* over time? :)
09:45:05 <zennist> i see - i'm surprised that i don't know this thing exists for so long
09:48:23 <mnoonan> I think the IHaskell kernel doesn't actually need IPython proper, just Jupyter.
09:48:35 <mnoonan> they get conflated a lot since they used to be one unified thing.
09:50:53 <indicator> I have a stack project that has tests, which are in a test-suite cabal target with main-is: Spec.hs.  The tests pass, but the only way I've found so far to load Spec.hs from ghci is to add a module declaration at the top
09:50:57 <indicator> Is there another way?
09:51:27 <indicator> i.e. another way to call functions defined in Spec
09:51:27 <bartavelle> indicator, what does "stack exec ghci tests/Spec.hs" do ?
09:51:28 <dcoutts> indicator: cabal repl $name-of-the-test-suite
09:52:40 <bartavelle> indicator, it seems to work for me
09:52:55 <indicator> bartavelle, thanks, that did it!
09:53:11 <indicator> stack is very nice but I feel I've missed a few steps learning about ghc and cabal
09:53:17 <sm> stack ghci :$name-of-the-test-suite should also work, see https://docs.haskellstack.org/en/stable/GUIDE/#targets-locals-and-extra-deps
09:54:05 <indicator> dcoutts, what do you mean by name of the test suite?
09:54:11 <dmj> indicator: not too late to use nix w/ cabal
09:54:33 <sm> indicator: the name declared for the test suite in the cabal file
09:54:36 <indicator> dmj, tempting but I think I'd better get to grips with haskell better first!
09:54:54 <dmj> indicator: fair enough
09:55:28 <dcoutts> indicator: in your .cabal file, you wrote something like: test-suite thetests ...
09:55:35 <indicator> right
09:55:36 <dcoutts> indicator: that's the name of the test suite
09:55:44 <indicator> cabal repl complains about missing dependencies
09:56:23 <dcoutts> indicator: so you can use that as a target when you ask to build or repl something. You can use the lib name, exe names, test names etc
09:56:38 <indicator> missing deps: I guess that's because I'm not going through stack, so I'd have to specify cabal config file to read, or something?
09:56:51 <dcoutts> indicator: in current versions of cabal you need to first say: cabal install --only-dependencies
09:56:57 <dcoutts> in future it'll be automagic
09:57:28 <dcoutts> indicator: this may also work with stack ghci/repl, but I'm no expert on that
09:58:09 <indicator> I guess that's what stack exec is for...
10:00:06 <indicator> stack ghci complains like this: The following target packages were not found: mypackage-test
10:01:12 <indicator> I mean stack ghci mypackage-test
10:01:22 <sm> <sm> stack ghci :$name-of-the-test-suite should also work, see https://docs.haskellstack.org/en/stable/GUIDE/#targets-locals-and-extra-deps
10:01:53 <indicator> stack exec ghci mypackage-test runs, but complains target ‘mypackage-test’ is not a module name or a source file
10:02:06 <sm> indicator: you're missing the leading colon
10:02:10 <indicator> doh
10:02:28 <codedmart> Is there an easy way to go from line 1 -> line 3 just using split or splitOn or something? https://gist.github.com/codedmart/5ee1f5c1f036fc3aea715e99e5c0a455
10:03:13 <codedmart> Or do I need to write a parser?
10:04:18 <parsnip> codedmart: how about https://hackage.haskell.org/package/split-0.2.3.1/docs/Data-List-Split.html ?
10:05:50 <parsnip> oh, looks like you don't just want it flat. 
10:06:16 <codedmart> parsnip: Right
10:17:34 <parsnip> codedmart: you really want nested maps? it looks like a tree of maps, which seems redundant. though keep in mind, i'm a bit of a newb. 
10:19:40 <f-a> (Pipes) If I got a function like c1 :: Proxy X () () [a] IO () (which it should be a producer, iirc), how do I transform this to xyz :: IO [a]?
10:20:59 <codedmart> parsnip: Yeah, trying to figure it out.
10:23:12 * hackagebot utility-ht 0.0.12 - Various small helper functions for Lists, Maybes, Tuples, Functions  https://hackage.haskell.org/package/utility-ht-0.0.12 (HenningThielemann)
10:23:20 <parsnip> codedmart: i commented on the gist, trying to reduce the noise slowly. 
10:25:53 <parsnip> what do people do with json, convert to a tree? 
10:26:03 <Welkin> what?
10:26:11 <Welkin> json is already a sort of tree
10:26:39 <parsnip> to nested records? 
10:26:53 <Welkin> what are you trying to do?
10:27:06 <Welkin> write a fromJSON instance?
10:27:09 <EvanR> people do terrible things with json
10:27:17 <EvanR> when the lights are out
10:27:56 <EvanR> parsnip: the library aeson lets you convert text into json, and json into a host of different things, nested records is just one way
10:28:12 * hackagebot non-empty 0.3 - List-like structures with static restrictions on the number of elements  https://hackage.haskell.org/package/non-empty-0.3 (HenningThielemann)
10:28:39 <EvanR> json arrays at a certain point could be considered lists, or vectors, or stupid records of their own
10:28:55 <EvanR> or whatever
10:28:58 <EvanR> its up to you
10:29:18 <parsnip> was looking at codedmart 's problem: https://gist.github.com/codedmart/5ee1f5c1f036fc3aea715e99e5c0a455
10:30:22 <parsnip> maybe the question now should be, what is the surrounding problem, like maybe XY-problem. 
10:30:47 <Welkin> I don't get what the problem is
10:30:49 <Welkin> or why you would do that
10:30:52 <EvanR> thats not json
10:30:56 <Welkin> if you are converting from JSON
10:31:09 <Welkin> then all you need to do is define an instance of fromJSON for each type
10:31:12 <parsnip> i only asked about JSON because of the structure. 
10:31:14 <Welkin> then it figures it out for you
10:31:39 <parsnip> i thought it had a similar look, thus my random mention of json. 
10:32:10 <f-a> (I'll answer my own question `toListM`)
10:45:34 <felko> i'm having trouble writing the dual function to sequence (thus with type Monad m => m [a] -> [m a]), could anyone help me ?
10:46:34 <Cale> felko: There's a good reason you're having trouble
10:46:47 <Cale> felko: It's because that way around doesn't make sense :)
10:47:11 <felko> ok :3
10:47:17 <Cale> felko: Pick a specific monad such as IO
10:47:27 <felko> yeah I tried
10:47:40 <Cale> Your operation would take an IO action which when run will produce a list as its result
10:47:54 <Cale> and it needs to produce, without running that action, a list of IO actions
10:47:56 <johnw> felko: there is a typeclass for that operation, but it's confined to a subset of possible monads
10:48:31 <felko> Cale: I'm actually trying to write a Monad instance for my datatype data QueueT m a = QueueT { results :: m [a], actions :: [m a] }
10:48:33 <Cale> but which list of IO actions? What's the length of that list?
10:49:04 <johnw> felko: see https://hackage.haskell.org/package/distributive-0.5.0.2/docs/Data-Distributive.html
10:49:17 <felko> thank yu johnw 
10:49:21 <felko> you *
10:49:22 <johnw> you can have your QueueT over any Distributive m that's a monad, but not over IO, for example
10:49:46 <johnw> and as far as monads go, the choices are mighty slim
10:49:51 <johnw> Reader and Identity it looks like
10:50:02 <felko> ok, I have to try to write my (>>=) operation for (QueueT m) another way
10:50:29 <johnw> or, question again what you're trying to solve
10:50:38 <napping> What is QueueT supposed to mean?
10:50:41 <johnw> maybe a QueueT is the wrong idea
10:50:43 <felko> (>>=) should behave like so, with the Maybe monad: Queue (Just [1,2,3]) [Just 1, Nothing, Just 3, Just 4] >>= (\ x -> if x == 3 theh Nothing else Just x ) ==> Queue Nothing [Just 1, Nothing, Nothing, Just 4]
10:50:58 <shapr> I keep thinking MuniHac is for writing code for mountain unicycling, but it's not! It's a Haskell hackathon in Munich!
10:51:42 <felko> QueueT is some random datatype i'm trying to write to get familiar with monads, it's basically a list of results and another of monadic actions
10:52:06 <felko> with an operation stepQueue that executes the next monadic action and adds the result into th first list
10:52:52 <felko> maybe you want a paste of my code so far
10:52:55 <johnw> sure
10:53:01 <johnw> what you describe certainly sounds possible
10:53:07 <johnw> but I'm not sure that QueueT *itself* can be a monad
10:53:30 <lpaste> felko pasted “QueueT” at http://lpaste.net/182611
10:53:34 <napping> I'm sure it can, just not if any of those ways are useful
10:54:12 <felko> oh i'm just trying to get familiar with monads, not necessarily creating something useful napping 
10:54:15 <parsnip> is WriterT applicable here? since he says combine results from the action. 
10:54:46 <napping> like, I have no ideas that actually depend on having the same m in m [a] and [m a]
10:54:55 <johnw> what he describes almost sounds like a dynamic Free over WriterT
10:55:09 <johnw> no, not Free, there is no chaining
10:55:49 <napping> how would your example go with Queue (Just [10,11,12]) [Just 1, Nothing, Just 3, Just 4])
10:55:59 <felko> applying stepQueue ?
10:56:05 <napping> I'm not sure where the numbers are supposed to go exactly, with them being similar
10:56:10 <napping> in your >>= example
10:56:42 <felko> napping: yeah but binding to which function ?
10:56:46 <johnw> I think it's supposed to end with Queue Nothing []
10:57:03 <napping> oh, maybe (\x -> if < 4 then Nothing else Just x)?
10:57:04 <felko> by repetitive application of stepQueue, yes
10:58:03 <felko> napping: Queue (Just [10,11,12]) [Just 1, Nothing, Just 3, Just 4]) >>= (\x -> if x < 4 then Nothing else Just x) ==> Queue (Just [10, 11, 12]) [Nothing, Nothing, Nothing, Just 4]
10:59:05 <napping> like QueueT as bs >>= f = QueueT (as >>= mapM f) (map (>>= f) bs)?
10:59:38 <felko> I tried something similar but it didn't work, let me test
11:00:38 <felko> napping: nope, error (pasting them)
11:01:21 <lpaste> felko pasted “No title” at http://lpaste.net/182618
11:03:01 <napping> wait, you can't have an "f" that's just (a -> m b) if you are trying to define >>=
11:03:51 <felko> napping: what do you mean ? 
11:04:10 <felko> f :: Monad m => a -> QueueT m b here
11:04:26 <napping> in your example you have a function only returning a Maybe
11:05:15 <felko> napping: f*ck
11:05:59 <felko> napping: but is there a typeclass or something monad transformer-related with this kind of function ?
11:06:15 <napping> I'm really not getting what kind of function you want
11:06:31 <felko> ok thanks a lot anyway lol
11:06:42 <napping> If it's specifically m [a] -> [m a], that's really hard to do
11:07:13 <napping> lots of monads let something of a type like (m [a]) look at all kinds of context to figure out what list to make
11:07:29 <napping> it's really a huge restriction
11:08:25 <napping> Queue might not need that, but I don't get how you want to make it act
11:08:29 <felko> yeah I saw some Distributive instances, this is mostly unused stuff (at least by me)
11:09:00 <felko> you're right, but I kind of wanted to do like a list
11:09:09 <napping> Is there anything not like writer than is "Distributive"?
11:10:07 <felko> is Writer an instance of Distributive ? can't see it on the hackage page
11:10:56 <felko> but I actually wanted the monad instance of Queue to be like the list monad
11:10:59 <napping> oh, distributive is pulling a g out
11:11:21 <napping> you might want to change (m [a]) to (m a) in the first part then?
11:11:22 <felko> yep, it's a reader
11:12:18 <felko> napping: I thought about it but yeah, let's try that
11:12:22 <napping> as the comment says, Distributive m means m is isomorphic to (x ->) for some x
11:15:36 <the_2nd> how can I define a where clause for all pattern matches of a function?
11:16:06 <dmwit> the_2nd: f x = case x of { ... } where { ... }
11:16:21 <the_2nd> no way to do it with pattern matching? :/
11:16:40 <dmwit> the_2nd: `case x of { ... }` is pattern matching
11:16:41 <napping> the problem is, "where" is allowed to refer to variables bound in the pattern match
11:17:00 <napping> so you need to put the matching inside one where clause
11:19:44 <dmwit> I wonder whether a language extension to support a "multi-case" akin to what top-level function definitions allow. `case e1, e2, e3 of p1, p2, p3 -> ...; p1', p2', p3' -> ...` or similar. Not using tuples to explicitly avoid constructing and then immediately destructing a tuple.
11:20:01 <dmwit> s/allow/allow would be worth anything/
11:20:06 <the_2nd> there was a way to have | guards within a case case
11:20:11 <the_2nd> forgot how to do it
11:20:16 <dmwit> You just do it.
11:20:24 <the_2nd> parse error on input |
11:20:25 <dmwit> Guards can be attached to any pattern binding.
11:20:29 <dmwit> Show us what you tried.
11:20:32 <dmwit> ?lpaste
11:20:32 <lambdabot> Haskell pastebin: http://lpaste.net/
11:20:48 <napping> a where over several patterns would have kind of funny typing rules
11:22:55 <the_2nd> dmwit, http://lpaste.net/5678231478694051840
11:23:21 <napping> | before the ->
11:23:39 <dmwit> case palette of PaletteBMP rgbs | length ... -> Dark | otherwise -> Bright
11:23:48 <the_2nd> ahh
11:24:19 <the_2nd> works, thanks
11:24:23 <dmwit> Also it seems odd to report `Dark` when there are more brights than darks.
11:24:52 <the_2nd> it's the type a theme will have
11:25:03 <the_2nd> if a bmp ist mostly dark, the bg should be dark
11:25:21 <the_2nd> but if a txt defined theme has mostly dark colors, it's likely that the single bright color is the bg
11:25:34 <dmwit> okie dokie =)
11:25:39 <napping> say you have f (Left x) = Left a; f (Right (x,y)) = Right (a,b); multiwhere {a = x+1; b = "Message: "++y}
11:25:48 <napping> is that supposed to infer f :: Num n => Either n (n,String) ->  Either n (n,String), with b not in scope in the first clause?
11:26:33 <napping> I'm not sure about that scope thing, but I guess it's plausible enough
11:28:08 <felko> napping: I got it working with Comonad w => Monad (QueueT w) lol, but I can't figure it out with just Monad m => Monad (QueueT m)
11:39:55 <stringer> let's say we hace functions: f (x,y) z = (x z, y z) and g (x,y) = f (x . fst , y . snd)  why the type of g is (t2 -> t, b -> t1) -> (t2, b) -> (t, t1) ?? Shouldn't it be (t2 -> t, b -> t1) -> (t2, b) ->a -> (t, t1) ?? since f takes one extra argument ?
11:40:47 <sbahra> A couple of years ago, I was told it was a bad idea to embed Haskell in some server software written in C. Has this changed? Anything I should be aware of?
11:41:37 <sbahra> Essentially, there is a high performance server that stores data efficiently on disk, but ideally we would prefer if we could use Haskell for data processing.
11:42:12 <sbahra> And ideally, without crossing address spaces.
11:42:49 <sbahra> GHC documentation says it's fine, but would be good to get some extra color from someone who's dealt with this.
11:43:18 <shachaf> hi sbahra
11:43:35 <napping> can't say I have, but how thoroughly did you look at the docs?
11:43:42 <shachaf> Why was it a bad idea a couple of years ago?
11:43:46 <napping> I think the runtime will want to do stuff like send itself timer signals
11:44:08 <napping> as far as I know it hasn't really gotten any worse or better over time
11:44:18 <sbahra> shachaf: I forget, I was just told to avoid it.
11:45:15 <sbahra> napping: Ok.
11:53:30 <joe9> Do lens actually help? I am finding that they deter comprehensibility.
11:54:37 <geekosaur> try dealing with nested record types without some kind of lens sometime
11:56:08 <ongy> reading is ok, modifying (especially modify, not write) is really annoying
11:59:15 <camm> Hello everyone, the example from cryptonite http://hackage.haskell.org/package/cryptonite-0.19/docs/Crypto-Tutorial.html don't compile :/ The data type Key is not defined anywhere. Has anyone test that example?
12:00:49 <napping> apparently not
12:03:15 * hackagebot storablevector 0.2.11 - Fast, packed, strict storable arrays with a list interface like ByteString  https://hackage.haskell.org/package/storablevector-0.2.11 (HenningThielemann)
12:04:40 <hpc> it's always funny to see lexical scoping being explained in a book about theoretical math
12:05:00 <shapr> hpc: ??
12:05:14 <hpc> this isn't -blah!
12:05:17 <andromeda-galaxy> joe9: my experience with lens is that if you don't know a bunch of the lens combinators off the top of your head it greatly decreases readability, but if you do, it greatly increases readability ---  even where modifies, writes etc take place.  Ultimately it's just a huge package with a *lot* of stuff to learn before you can be really good at using it
12:05:30 <andromeda-galaxy> hpc: where did you find that?
12:06:43 <napping> joe9: If you haven't gotten to a point where readability is horrible without lens, you don't have to use them
12:06:57 <napping> but yeah, deep nesting tends to get you there
12:07:31 <napping> and it does handle those problems nicely once you learn it
12:08:28 <hpc> andromeda-galaxy: https://homotopytypetheory.org/book/ - it's not directly haskell-related, but still of interest given how much haskell draws from type theory
12:08:56 <andromeda-galaxy> hpc: oh, I've been meaning to readmore than the introduction of that for the last year!
12:08:57 <hpc> Cale has recommended it here on occasion
12:09:15 <hpc> same, just got to chapter 1 lol
12:09:35 <hpc> the introduction ramps up pretty heavily and then chapter 1 is easy again
12:09:44 <andromeda-galaxy> IIRC Idris, Agda, and stock Coq can't do HoTT because of Axiom K? ---I've partially been waiting to see if there's a proof assistant that can handle it without too much trouble
12:09:52 <andromeda-galaxy> cool, I will have to go back and try reading chapter 1 again
12:12:08 <napping> andromeda-galaxy: Coq doesn't assume K, Agda more or less does
12:13:15 * hackagebot hindent 5.2.1 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-5.2.1 (ChrisDone)
12:13:17 * hackagebot ADPfusion 0.5.2.0 - Efficient, high-level dynamic programming.  https://hackage.haskell.org/package/ADPfusion-0.5.2.0 (ChristianHoener)
12:14:09 <napping> last I recall there were questions about how to execute some expressions in HoTT, but I think there's been progress since then
12:15:03 <andromeda-galaxy> napping: hmm, I remember some problem in Coq but I don't know what it was
12:15:07 <andromeda-galaxy> Idris and Agda both have K
12:15:20 <andromeda-galaxy> do you still need a heavily patched coq?
12:15:53 <johnw> there is a separate CoqHOTT project
12:16:03 <johnw> because it changes the underlying meta-theory
12:16:32 <andromeda-galaxy> johnw: ah, I see. I will try that out then
12:19:16 <the_2nd> can I define a class instance on another class?
12:19:43 <the_2nd> class OuterClass a where ...
12:19:55 <the_2nd> instance OuterClass InnerClass where ...
12:20:15 <the_2nd> instance (InnerClass a) => OuterClass a where ...
12:20:37 <emmanuel_erc> Have any of you guys heard of or  used the clean programming language? (http://clean.cs.ru.nl/Clean)
12:21:34 <napping> sounds nice, never tried it
12:22:21 <napping> I've generally cared more about type system features than performance, but linear/uniqueness types sound very nice
12:22:39 <andromeda-galaxy> emmanuel_erc: I have not used clean, but I know that Idris at least has done uniqueness typing (inspired by clean), in a kind of neat way.  Unfortunately it's kind of buggy and might be ripped out soon
12:23:21 <andromeda-galaxy> napping: uniqueness types are kind of neat, and they pave the way for zero-allocation regions! That is a performance thing, but it's nice for doing OS/embedded development, which is something that you can't really do functionally now
12:23:44 <napping> yeah, the allocation stuff is the very interesting part
12:24:05 <napping> of course, Rust has it's own interesting take on handling allocation
12:24:25 <andromeda-galaxy> napping: Rust's allocation is basically uniqueness types, actually
12:25:01 <napping> well, yeah, but the borrowing is a fairly novel convenience on top
12:25:47 <dfeuer> You can really build an awful lot of other packages while waiting for vector to compile.
12:26:42 <andromeda-galaxy> napping: does clean really not do borrowing? I thought it was a kind of integral thing
12:26:45 <andromeda-galaxy> idris does
12:26:52 <dfeuer> Borrowing?
12:27:34 <steeze> so i wrote a pangram checking function (checks if a string contains all letters in the alphabet) that i found on rosetta code, and im confused about one part
12:27:47 <steeze> `containsAll = null . (['a' .. 'z'] \\)`
12:27:53 <steeze> containsAll "abcdefg"
12:27:55 <dfeuer> steeze, you wrote it? Or you found it?
12:27:58 <steeze> im confused on the null part
12:28:03 <steeze> sorry, i found it haha
12:28:17 <dfeuer> steeze, that's a pretty lousy implementation.
12:28:24 <dfeuer> What confuses you about the null part?
12:28:40 <steeze> im super new to haskell but not programming. i understand function composition but am confused what part the null is playing here
12:28:55 <dfeuer> It's checking if the result is the empty list.
12:29:04 <andromeda-galaxy> steeze: null is not a null pointer it's just a function that checks if something is the empty list
12:29:13 <napping> andromeda-galaxy: It might! I don't remember being able to take multiple read-only borrows of a linear value, and then give them back
12:29:22 <steeze> aha thanks all. i knew i was getting tripped up on syntax
12:29:26 <steeze> im enjoying haskell a lot so far though
12:29:27 <dfeuer> Lots of things can be empty these days.
12:29:42 <andromeda-galaxy> napping: hmm, maybe not, I don't know --- I didn't use clean much. Idris's uniquness typing does it also so I assumed it was a well accepted part of making linear types usable
12:29:49 * dfeuer twiddles his thumbs waiting for his sandbox to rebuild.
12:29:58 <steeze> dfeuer what was your idea for a better implementation?
12:30:07 <dfeuer> andromeda-galaxy, what is "borrowing"?
12:30:34 <shapr> Is the borrowing in Rust the same kind of thing that Clean does?
12:30:37 <andromeda-galaxy> dfeuer: borrowing a value gives you basically a read only copy of it that you can return at some point (and must before it is modified).
12:30:49 <andromeda-galaxy> shapr: not sure, not having used Clean much...
12:31:07 <maerwald> what is Clean?
12:31:23 <dfeuer> steeze, representing a set of English letters as a list is extremely inefficient. You could represent it as a Word and use Data.Bits....
12:31:33 <andromeda-galaxy> dfeuer: so for example if I have a number n, I can get a string representation of it (allocated somewhere new, presumably) by passing a borrowed version to show, and then after show returns I still have ownership of the value and can for example increment it
12:31:36 <emmanuel_erc> sorry... I was away for a bit.
12:31:40 <andromeda-galaxy> maerwald: a programming language based on linear types
12:32:12 <emmanuel_erc> Why is Haskell more popular than clean, given the performance diference between the two?
12:32:20 <shapr> we're charming
12:32:25 <maerwald> shapr: https://doc.rust-lang.org/book/references-and-borrowing.html
12:32:31 * shapr hypnotizes emmanuel_erc
12:32:44 <emmanuel_erc> lol shapr
12:33:02 <dfeuer> andromeda-galaxy, I don't really know anything about linear types, but isn't one of the ideas that you can control resources much more tightly? Once you start borrowing things, you need to bring in the garbage collector, right?
12:33:11 <emmanuel_erc> shapr: Are you going to lead me to the high Haskell altar?
12:33:11 <andromeda-galaxy> emmanuel_erc: we have more awesome types and when our programs look like mathematical formulae they work like that too!
12:33:16 * hackagebot soxlib 0.0.3 - Write, read, convert audio signals using libsox  https://hackage.haskell.org/package/soxlib-0.0.3 (HenningThielemann)
12:33:17 <napping> andromeda-galaxy, dfeuer: part of it is that you don't need to explicitly return the borrowing
12:33:27 <napping> dfeuer: and rust is specifically designed so you don't have to
12:33:29 <shapr> emmanuel_erc: sure! it's fun! the first redex is free!
12:33:58 <andromeda-galaxy> dfeuer: I think you are supossed to still not need gc, for example rust does not have it, and idris uses them for zero-allocation regions (although that doesn't really work right now)
12:34:01 <emmanuel_erc> lol.. I love haskell. I am not a troll.
12:34:02 <napping> dfeuer: in particular, you only get to mutate/deallocate stuff once you are past the scope where any borrows could be live
12:34:14 * shapr hugs emmanuel_erc
12:34:44 <hpc> emmanuel_erc: you make it sound like an aztec ritual or something
12:35:08 <emmanuel_erc> Well I was hypnotized...
12:35:11 <shapr> ha
12:35:15 <hpc> emmanuel_erc: of course if we in #haskell were to enact such rituals, you would first be evaluated before you are executed
12:35:35 <emmanuel_erc> Well I would need to be type-checked first right?
12:35:35 * shapr thunks hpc
12:36:42 <dfeuer> emmanuel_erc, you failed typechecking, so you actually never existed. *bonk*
12:36:52 <emmanuel_erc> hahaha
12:37:21 * dfeuer shoots Criterion's gazillion-and-a-half dependencies.
12:37:46 <mnoonan> I have a long-running process that I suspect is stuck; is there a way to get the runtime to tell me what it is working on?
12:37:50 <dfeuer> But especially vector and statistics.
12:38:16 * hackagebot netpbm 1.0.2 - Loading PBM, PGM, PPM image files  https://hackage.haskell.org/package/netpbm-1.0.2 (NiklasHambuechen)
12:38:19 <dfeuer> mnoonan, uh... good luck with that?
12:38:22 <hpc> dfeuer: try sdl2 sometime, it depends on lens for no obvious reason even though it sticks very closely to the C API
12:38:22 <mnoonan> I guess I'm wishing for the analogue to attaching gdb and printing a stack trace for C code
12:38:46 <Rembane> mnoonan: You might be able to see if it actaully does something or just waits for IO by using top and suchlike.
12:38:48 <cocreature> Morgawr: +RTS -Ds gives you scheduling information which can sometimes help
12:38:50 <mnoonan> I can do a profiling build, but if I kill the program then I don't get the profile (do I?)
12:39:13 <dfeuer> hpc, does it define instances for classes in lens?
12:39:21 <puregreen> hpc: https://github.com/haskell-game/sdl2/pull/123
12:39:42 <cocreature> mnoonan: also you could try building your program with -g and attaching gdb. I’ve never tried that on a running program (only for backtraces on crashes) but it should work I think
12:39:44 <hpc> oh right, linear
12:39:57 <puregreen> apparently there'll be a flag to make it optional now
12:40:15 <mnoonan> cocreature: oh, interesting.. I've never looked at what -g gives you before
12:40:20 <hpc> yeah, i can see what they were going for with depending on linear at least
12:40:38 <cocreature> mnoonan: it’s relatively new, I think you need at least ghc 7.8
12:40:50 <cocreature> eh 7.10
12:41:47 <ph88> hey guys i'm using the Text package https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec.html  but i only see a string function there which gives String   where is the function that gives Text ?
12:42:16 <puregreen> ph88: there isn't
12:42:25 <ph88> strange
12:43:28 <puregreen> ph88: what do you actually want to do?
12:44:13 <ph88> parse a file
12:44:21 <ph88> and i heard Text is better than String
12:44:27 <johnw> dfeuer: ping
12:44:28 <ph88> so i was thinking of using Text
12:44:34 <ph88> is this good?   text' = T.pack <$> string'
12:44:36 <dfeuer> johnw, pong
12:44:38 <johnw> dfeuer: re: fromListReversing: Could you achieve what you want do with a rewrite rule, instead of adding a special combinator the library?
12:45:09 <EvanR> ph88: the extension OverloadedStrings allows you to specify Text with "literals like this"
12:45:22 <EvanR> so you dont need a conversion on literals
12:45:38 <ph88> EvanR, i'm already using this extension
12:45:49 <puregreen> ph88: will you actually ever need to use the output of `string`?
12:46:09 <puregreen> because if you use string, you already know what it's going to return
12:46:22 <ph88> puregreen, sorry i don't understand what you are asking me
12:46:38 <puregreen> ph88: can you give an example of code that you want to write?
12:46:46 <dfeuer> johnw, I guess so.... I hate making people rely on rewrite rules.
12:47:14 <dfeuer> johnw, I do that for map/reverse, but if that doesn't fire it's really not a big deal.
12:47:52 <johnw> it just seems like down this road lie 1,000 other combinations that could potentially be custom-written to be faster than their composites
12:47:59 <dfeuer> That's true. :-(
12:47:59 <johnw> which is sort of what rewrite rules are for...
12:48:47 <dfeuer> However, this one matches the new Data.Map.fromDescList, which makes for consistency...
12:49:17 <dfeuer> Or better abstractions....
12:49:32 <dfeuer> reverse is generally a mistake; we should have mapReverse *instead*.
12:49:41 <dfeuer> But hey, no one else thinks that.
12:49:47 <dfeuer> Anyway, I have to run. Later!
12:50:02 <dfeuer> johnw, you should respond to the list.
12:50:11 <johnw> about the rewrite rules?
12:50:15 <dfeuer> Yeah!
12:50:18 <johnw> ok
12:51:25 <EvanR>  :t mapReverse
12:53:18 <ph88> puregreen, i be back later
12:55:32 <elliptic00> data Point a = Pt a a
12:55:32 <elliptic00> MyFun::(Point String)->String
12:55:32 <elliptic00> MyFun (Pt _ _) = "dog"
12:55:44 <elliptic00> why my code can't be compiled?
12:56:38 <glguy> elliptic00: Because you can't start a function definition with a capital letter
12:57:05 <glguy> capital letters are reserved for constructors
12:57:50 <elliptic00> nice catch.. glguy.
13:28:42 <stringer> Hi, is foldl (+) 0 xs = foldr (+) 0 xs true to every list xs ?? Even infinite one ?
13:29:09 <dolio> What types are the lists?
13:29:33 <stringer> xs :: Num a ⇒ [a],
13:29:42 <dolio> That's not specific enough to answer. :)
13:30:05 <dolio> I mean, the answer is 'no' in that case.
13:30:27 <stringer> in what case it isn't ?
13:30:40 <parsnip> commutative
13:31:06 <EvanR> foldl (+) 0 xs =? foldr (+) 0 xs
13:31:22 <EvanR> oh i see the different letter there now
13:31:27 <dolio> If I write a lazy extended natural number type, then `foldl (+) 0 (repeat 1)` will be bottom, but `foldr (+) 0 (repeat 1)` will be the infinite value.
13:32:16 <parsnip> stringer: one goes (((z + x1) + x2) + x3), the other goes (x1 + (x2 + (x3 + z))). so you are relying on commutativity that they are equal. also, issues dolio is describing. 
13:32:35 <dolio> That's not commutativity.
13:32:40 <parsnip> foldl has z on the _left_, and associates to the _left_. 
13:33:01 <stringer> mhm ok
13:33:04 <dolio> 0 is supposed to be a unit, so it's fine to move it around.
13:33:26 <parsnip> oh, sorry i was thinking about generalizing, pardon. 
13:33:27 <dolio> But reassociating infinitely isn't 'the same' in general.
13:33:37 <EvanR> also finite series cant necessarily commute
13:33:38 <dolio> Even if reassociating finitely is.
13:33:45 <EvanR> infinite series*
13:34:07 <dolio> Also, floating point numbers aren't even associative.
13:34:18 <nanthil> hey all. I'm new and going through the "learn you a haskell..." tutorials. I came to the recursion thing and thought I'd implement the age old problem. And I've tried a dozen different ways of doing this, and I'm at a loss
13:34:25 <nanthil> http://codepad.org/hSPVhfak
13:34:36 <nanthil> fibonachi
13:34:40 <dolio> So those will give finite examples that fail.
13:34:42 <Welkin> @where learnhaskell -- nanthil
13:34:42 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:35:04 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1 -- nanthil 
13:35:07 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:35:17 <parsnip> nanthil: however you're running it is lookgin for `main', is that the problem? 
13:35:22 <EvanR> heres a question, floats are obviously algebraically brain damaged, but we put up with it because "performance". can we make a number type that makes even less sense (but not trivial) and gets even better performance?
13:35:28 <nanthil> no I'm using ghci
13:35:49 <monochrom> EvanR, I wonder if fixed point arithmetic qualifies.
13:35:59 <c_wraith> EvanR, sure. my new numerical system is "all numbers are 0"
13:36:05 <EvanR> (but not trivial)
13:36:14 <c_wraith> it lets you do some serious optimization. 
13:36:15 <nitrix> nanthil: To the risk of sounding like a broken record; LYAH is a great book to get people interested by Haskell, but doesn't actually teach it well. There has been multiple alternatives popping up since then, one of which is gaining a lot of traction and becoming popular currently: http://haskellbook.com
13:36:27 <monochrom> Then again, it does not make less sense. It just has complementary skills and shortcomings compared to floating point.
13:36:32 <EvanR> yeah fixed point arith with a shitty bound due to machine ints
13:36:37 <parsnip> nanthil: also, the type doesn't have a tuple in it, but later you use such? 
13:36:53 <EvanR> and then hope were not so far gone that floats are higher performance thn ints
13:37:13 <nanthil> no I had it accepting number of iterations, and (a, b) so I could add (b, a+b)
13:37:30 <nanthil> can someone tell me what I'm doing wrong?
13:37:46 <Welkin> nanthil: the just generate an infinite list of fib numbers
13:37:49 <Welkin> and then use `take`
13:37:55 <monochrom> nanthil, don't you want "fibInit iter = fib iter 0 1"?
13:37:57 <dolio> I guess integer arithmetic is faster than floating point?
13:38:04 <nitrix> nanthil: The first problem that I see is `fib iter (0, 1)`. `fib` expects 3 arguments, not two.
13:38:06 <dolio> Even though they're both in hardware.
13:38:12 <nitrix> nanthil: The tuple (0, 1) counts as only one.
13:38:15 <Welkin> dolio: not on most cpus and gpus
13:38:23 <Welkin> they are optimized for floating point
13:38:31 <nanthil> yes sorry, I forgot to change that
13:39:02 <napping> dolio: floats usually try to be not much slower, at least
13:39:15 <monochrom> And lastly, your code will always give the answer [].
13:39:15 <nanthil> http://codepad.org/hSPVhfak
13:40:47 <joe9> Is there any haskell library that can take a list of points (x,y) coordinates and generate a monotonic path out of it . something as described in http://www.d3noob.org/2013/01/smoothing-out-lines-in-d3js.html
13:40:48 <nanthil> why?
13:40:48 <orion> What libraries should I look in to if I want to graph time series data?
13:40:58 <monochrom> I can prove it by induction.
13:41:00 * jonored feels that he should perhaps note that there are a great deal of cpus where integers, and frequently addition, subtraction, and bitshift in particular, are much faster. But that's not what was actually meant by "cpu".
13:41:04 <nanthil> monochorom: why wlil it always return []
13:41:06 <monochrom> Base case: fib 0 _ _ = [].
13:41:16 <Welkin> joe9: just sort the points
13:41:21 <EvanR> theres a folk belief that floats are faster than ints in general, which makes no sense, but there you go folks
13:41:23 <joe9> orion: haskell-chart or if you want to take the d3.js philosophy to gtk, then diagrams.
13:41:48 <monochrom> Induction step. Induction hypothesis: fib (iter-1) blah blah = []. Then fib iter num1 num2 = fib (iter-1) blah blah ++ [] = [] ++ [] = [].
13:41:52 <orion> joe9: Thanks.
13:42:00 <nanthil> yeah ok
13:42:02 <nanthil> cool
13:42:54 <dolio> EvanR: Seems like you could probably build hardware that would favor either.
13:42:55 <nitrix> nanthil: You probably want something like  (num1+num2) : fib (iter-1) num2 (num1+num2)
13:42:57 <nanthil> so if iter is 0 then [1]
13:43:24 <EvanR> you could build hardware optimized for roman numerals
13:43:25 <nitrix> nanthil: Where you get the current element, then define the rest of the elements as further applications of fib until you reach the base case.
13:43:27 <nanthil> or something?
13:43:34 <monochrom> No. nitrix's idea is better.
13:43:41 <nanthil> or something?
13:44:02 <joe9> orion: if it interests you https://github.com/joe9/baby-steps-to-building-a-chart-with-diagrams
13:44:07 <jonored> dolio: Hardware-wise, floats do have a bit more work to do than ints, but not too much.
13:44:30 <nitrix> nanthil: https://coderpad.io/NZZFDX2H
13:44:56 <dolio> Are the current generation AMD chips the ones that have two floating point processors for each integer processor? Or is that backwards?
13:45:29 <napping> backwards, and not in the upcoming generation
13:45:57 <EvanR> integer processors would be cool
13:46:01 <monochrom> \∩/ roman numerals. Addition is just string concatenation.
13:46:06 <EvanR> rather than Z^64
13:46:22 <prsteele> is there an easy way to compile with -Wall -Werror but permit things like orphan instances? I have Arbitrary instances in my test files for QuickCheck
13:46:55 <jonored> (adjusting the exponent depends on the result of the mantissa in a more complicated way than just high-order bits, so it's a bit bigger area and probably a slightly longer chain of gates to get the answer. Not really significant for a general purpose computer.)
13:47:06 <monochrom> probably add -fno-warn-orphan-instances or something like that
13:47:37 <EvanR> i was told ALU design is a bubbling cauldron of black magic
13:47:49 <jonored> EvanR: Just encode your numbers in unary, it'll be great :)
13:48:25 <prsteele> monochrom: it's actually -fno-warn-orphans, thanks!
13:48:47 <prsteele> monochrom: strange that it doesn't follow the pattern of -fwarn-orphan-instances
13:50:14 <napping> If I read Agner Fog right, the latest intel does 3 integer adds per cycle with 1 cycle latency, compared to 2 fp adds per cycle with 4 cycle latency
13:50:29 <napping> I guess the weird ones mess things up
13:50:44 <prsteele> style quesetion: is it preferred to put GHC-Options: ... in the cabal file, or a {-# OPTIONS_GHC ... #-} pragma in teh source file?
13:51:11 <parsnip> one is project-wide? 
13:51:38 <monochrom> yeah, this is probably completely determined by whether you want to use the option for just one file or for all files.
13:51:45 <prsteele> yes, but still only for a given target (e.g. unit tests). I suppose that's what you want to consider, though
13:51:58 <prsteele> thanks
13:57:06 <nitrix> nanthil: Hope it helped.
13:58:47 <nanthil> word
13:58:50 <nanthil> thanks
13:58:53 <nanthil> though
13:58:58 <nanthil> now I don't know what to do
13:59:09 <nitrix> You keep learning of course :D
13:59:15 <nanthil> well sure
13:59:22 <nanthil> but I thought I was understanding like I said before
13:59:30 <nanthil> but now I have no idea
13:59:36 <nitrix> Meh, it was close.
13:59:58 <nanthil> well, the idea was there. I'm not a novice programmer, I've done this algo in dozens of languages
14:00:07 <nanthil> but the syntax, and there are so many ways that things can go wrong
14:00:08 <MichaelK> Is it possible to make an instance with a type like (forall t. t -> t)?
14:00:24 <nanthil> since there are so many ways to do something
14:00:33 <nitrix> nanthil: Do yourself a favor and approach Haskell like you're a beginner.
14:00:35 <dmwit> MichaelK: Yes, but you will probably need a newtype wrapper.
14:00:39 <nanthil> I don't know what a simple implementation looks like
14:00:46 <nanthil> well I guess that's what I'm trying to do
14:01:05 <MichaelK> dmwit: Good idea
14:01:06 <nanthil> but at this point, I don't know what the base case of a function looks like in the language
14:01:24 <nanthil> and all the tools that come with, I thought I understood what they did, but it seems like they do the opposite
14:01:28 <EvanR> the only way to learn is to do
14:01:31 <nanthil> or simply odn't compile when I try to use it
14:01:32 <EvanR> read and write haskell code
14:01:37 <dmwit> MichaelK: Of course that type isn't super featureful. To a first approximation, the only inhabitant is `id`.
14:01:40 <nitrix> nanthil: Don't get demotivated. Haskell is a language that you cannot just pick the syntax and proceed happily. You're going to have to learn new ways to think and also new concepts (mostly abstractions).
14:02:11 <EvanR> when you really get stuck ask questions in here
14:02:19 <nanthil> that's what I mean. I have lots of them. From scheme, or from functional js. I don't even really know what I don't know
14:02:22 <nanthil> its like I have to start over again
14:02:27 <nitrix> nanthil: e.g. Functors, Applicative, Monads. Maybe you'll learn type stuff too, algebras, kinds, new forms of polymorphism (parametric instead of ad-hoc), etc.
14:02:57 <nanthil> yep
14:03:00 <EvanR> starting over is good, get good at it, this will be the first time perhaps you need to exercise that right
14:03:08 <monochrom> nanthil, nitrix has shown you a simple implementation. in fact, it can be even simpler by foresaking "iter" altogether and allow yourself to generate a potentially infinite list.
14:03:31 <nanthil> yeah, take
14:04:17 <monochrom> The only thing you need to accept is that this simplest way is completely different from the other simplest ways you've done in other languages.
14:04:25 <nitrix> nanthil: Here's a funnier variant that actually goes infinitely.
14:04:29 <nitrix> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:04:31 <lambdabot>  Defined.
14:04:39 <nitrix> > take 5 fibs
14:04:41 <lambdabot>  [0,1,1,2,3]
14:04:43 <nitrix> > fibs
14:04:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:04:54 <monochrom> You are basically looking at a paradigm shift, therefore simplest ways change completely.
14:05:03 <nitrix> nanthil: Haskell is more than syntax ;)
14:05:48 <EvanR> what if i want to go beyond infinity
14:05:50 <monochrom> Approximately the closest analogy you can draw, for this exercise, is from Python's generators, in which you would write a "yield" thing.
14:06:05 <nanthil> nitrix: I guess I know that, but i thought I was understanding the concepts
14:06:24 <nitrix> nanthil: You'll honestly need a better book than LYAH to "understand the concepts".
14:06:24 <nanthil> nitrix: I've been using scheme for a minute, and a lot is similar, except haskell is loads easier to do anything in
14:06:32 <nitrix> LYAH isn't teaching, it's just demonstrating things really.
14:06:34 <nanthil> and the examples seemed pretty straight forwrad
14:07:01 <nanthil> I'll go hunt for something else then
14:07:25 <nitrix> nanthil: Yeah but you need to apply it with exercises that progressively build your foundation and intuition for these things, rather than jump for a project and apply everything you've learned at once, feeling overwhelmed and mashing into it.
14:07:30 <nitrix> nanthil: haskellbook.com <3
14:08:15 <prsteele> nanthil: late to the conversation, but I always suggest projecteuler.net if you're into that sort of thing. You can stumble through the problems for a while before you realize you probably want some heavier machinery, but it's a good place to practice
14:08:25 <nanthil> nitrix: you mentioned vim. Do you use a vim addon for your browser, or are you hardcore enough to use a text browser
14:08:52 <nitrix> Ehm, I don't use my browser to edit code normally.
14:09:07 <nitrix> The site you saw is just a live collaboration whiteboard thingy. It isn't pratical.
14:09:22 <parsnip> nanthil: text browsers are usually awkward for most websites. 
14:09:47 <monochrom> I am so hardcore, I don't use a browser, I telnet www.haskell.org 80
14:09:58 <EvanR> thats probably the safest and most honest way
14:10:01 <nanthil> that's not what I meant
14:10:09 <nanthil> I used vimium on chrome
14:10:10 <monochrom> I'm just kidding! :)
14:10:12 <nanthil> addon
14:10:32 <nitrix> nanthil: But to answer the question, I don't think "being hardcore" should be a goal.
14:10:32 <dolio> If you learned Scheme first, you can learn the way I did: https://www.haskell.org/tutorial/
14:10:41 <nanthil>  haha, neither do I
14:10:46 <nanthil> it was just a goofy question
14:10:47 <chsn> monochrom: telnet? I just cat > /dev/i-have-no-idea-what-to-put-here
14:10:53 <EvanR> haskell is pretty hardcore, but just a coincidence
14:10:55 <nanthil> i'm considered hardcore for even knowing how to use vim
14:10:55 <nitrix> I just vim because I like vim. I've customized it to the operations I do frequentely. People have done the same with their editor of choice.
14:10:56 <monochrom> Oh I see. vi keyboard binding
14:11:34 <monochrom> chsn: Yeah, where is the TCP/IP stack in the /dev hierarchy? :)
14:11:59 <EvanR> /dev/internet
14:12:02 <chsn> monochrom: I don't know. I was trying to make a joke about eing more hardcore, but then irealized I didn't know jackshit about how linux entworking works.
14:12:03 <nitrix> chsn: If you do cat /dev/random, you have a small chance it gets your HTTP request perfectly right the first time.
14:12:11 <monochrom> hehe
14:12:20 <EvanR> plan9 networking maybe
14:12:27 <chsn> nitrix: cat /dev/random > /dev/memory ? and hope it toggles all the right bits
14:12:38 <chsn> or cat /dev/random | /usr/bin/zsh
14:12:40 <nitrix> chsn: 60 % of the time, it works all the time.
14:13:00 <chsn> more like 2^{-600000} % of the time
14:13:16 <EvanR> conditional probabilitistic workingness
14:13:18 <prsteele> you can probably get it high enough with some 1-character aliases for 'common' tasks
14:13:58 <chsn> yeah, if you defined all the asci chars to 'telnet haskell.org80'
14:14:39 <monochrom> actually these days it directs you to https://www.haskell.org
14:14:52 <monochrom> So now you have to be able to use RSA encryption by hand.
14:15:00 <monochrom> err, s/use/do/
14:15:16 <chsn> by hand *within the https timeout window* ?
14:15:23 <monochrom> YES!
14:16:37 <monochrom> No, just use stunnel.
14:16:40 <nitrix> That's it. I'm writing a Haskell SSL library which will out-source the heavy work to mathematicians via fax.
14:17:08 <nitrix> Mathematicians can do cryptos, right? Crypto's just maths.
14:17:23 <nitrix> c:
14:17:28 <EvanR> mathemagicians
14:17:32 <parsnip> nitrix: not sure they'll fax back what you hope for. 
14:17:44 <dmj> I write all my faxes in haskell these days
14:18:05 <nitrix> dmj: It's because Haskell is compiled. It's faster.
14:18:37 <parsnip> the faxes come back as `Maybe ok'. 
14:18:43 <nitrix> Ahah.
14:18:51 <dmj> Just "good enough"
14:19:38 <monochrom> Oh w00t, Hutton's book has a new edition (2nd)
14:19:56 <yyyyy> I heard a Free fax is not as fast as writing your own Fax burrito
14:19:57 <monochrom> freshly announced 12 hours ago by him on haskell-cafe
14:20:09 <chsn> monochrom: what's the book title?
14:20:16 <monochrom> Please don't use fax paper to wrap your burritos!
14:20:24 <monochrom> Programming in Haskell
14:20:26 * glguy put in a pre-order for it
14:20:28 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html
14:20:34 <dmj> yyyyy: depends if your free burrito was chalupa encoded 
14:21:03 <EvanR> free chalupas 
14:21:18 * monochrom wonders what's the "psz" doing in "pszgmh". Is he trying to type himself as a pointer to null-terminated string?
14:21:20 <nitrix> Too new to know; is Hutton known in the haskell ecosystem?
14:21:33 <yyyyy> depending on the amount of chili the chalupa might get you freer to the bathroom though
14:21:45 <chsn> this book seems very theoretical i.e. focusin gon th epretty, elegant, math side of haskell
14:21:55 <chsn> not so much the real world nitty gritty (based solely looking at TOC, without having read the book)
14:21:59 <yyyyy> chsn: the previous edition was really good
14:22:16 <nitrix> That comment from glguy is strongly biasing me to order it too.
14:22:34 <nitrix> chsn: So it's not really a beginner thing; more like intermediate / advanced?
14:22:43 <nitrix> Does it goes into CT or similar?
14:22:49 <monochrom> no it doesn't
14:22:53 <Cale> chsn: I think if you're going to get a book on Haskell, it should probably be more theoretically-minded. Practicalities change on a regular basis, and your best bet there is library documentation.
14:23:10 <dmj> wish I could buy individual chapters, 14 and 15 look good
14:23:14 <glguy> Graham Hutton spend a summer visiting Galois back around the time he released his previous version of the book. He left some copies of the previous version of his book as seen here https://wiki.haskell.org/wikiupload/a/aa/Screen-triplehead-galois.jpg
14:23:19 * hackagebot pathtype 0.8 - Type-safe replacement for System.FilePath etc  https://hackage.haskell.org/package/pathtype-0.8 (HenningThielemann)
14:23:42 <ph88> puregreen, this is my function, string'  returns a string and the type expects Text  https://paste.fedoraproject.org/419429/64977147/
14:23:48 <chsn> nitrix: I dunno; I only read the table of contents
14:23:49 <glguy> I need to replace that copy with the new edition :)
14:24:06 <yyyyy> glguy: that's a sweet keyboard you got there.
14:24:07 <chsn> Cale: I dunno -- I found that none of the thoery amde sense to me ... until I ran into them in practice .. then the made sense
14:24:19 <chsn> Cale: like none of monads made sense ... until in practice, I was writing functions carrying arounx oto much state
14:24:32 <chsn> Cale: then I was like "oh, this is a reader monad: oh; that is a state monad, ..."
14:24:49 <yyyyy> i got the kindle edition for that one
14:24:50 <EvanR> imagine monads were called flattenables
14:25:06 <nitrix> I'd kinda like "Chainable".
14:25:14 <EvanR> then the situation would be reversed
14:25:18 <yyyyy> i'd like Joinable
14:25:21 <dolio> Flattenable is a bad name.
14:25:25 <nitrix> Joinable, I agree.
14:25:28 <EvanR> Applicative is chainable too
14:25:33 <EvanR> so are monoids
14:25:53 <nitrix> I'd also really love to see `return` gone from that new Joinable.
14:25:56 <monochrom> chsn: "reasoning about programs" and "calculating a compiler" are the theoretical stuff in this book, but they are postponed until the last two chapters. So I'm sure this book is not all that detached.
14:26:00 <dolio> Unless you think substituting more trees at the leaves of a tree is 'flattening'.
14:26:31 <EvanR> Tree (Tree a) -> Tree a
14:26:46 <nitrix> class Joinable m where join :: m (m a) -> m a
14:26:52 <nitrix> :D
14:26:55 <EvanR> what i was going to say was, if it was called flattenable, we would have the exact opposite situation, people would instantly "get it" but still not really understand
14:26:59 <ph88> is there a nicer way to write this second do-block ?   https://paste.fedoraproject.org/419439/14727651/
14:27:09 <yyyyy> nitrix: yes!
14:27:16 <dolio> Ah, that's true.
14:27:53 <yyyyy> class (Applicative m) => Joinable m where join :: m $ m a -> m a, no?
14:27:57 <prsteele> ph88, pull it out to a function?
14:27:59 <monochrom> No. Use "CrossApplyable". Because "cross apply" is a thing in SQL, and it is (>>=) for tables.
14:28:03 <parsnip> for me, Monad is jsut DolphinScript
14:28:12 <parsnip> *just
14:28:21 <yyyyy> DolphinScript?
14:29:16 <parsnip> jumping in and out of the monad, swimming freely underwater. 
14:29:24 <EvanR> o_O
14:29:34 <dmwit> ph88: How about `liftM2 (++) (option [] underline) letterOrDigit`?
14:29:44 <dmwit> ph88: (And then drop the `concat` in the next line.)
14:29:46 <monochrom> I prefer salmon for that. jumping in and out of water.
14:29:53 <parsnip> taking a breath, then do some stuff, and come back up to blow out CO2. 
14:30:08 <monochrom> especially since salmon is cheap in Canada
14:30:11 <dmwit> ph88: ...or something like that.
14:30:24 <parsnip> monochrom: salmons are more Applicative
14:30:27 * dmwit reads more carefully
14:30:59 <ph88> dmwit, i don't understand your code
14:31:01 <monochrom> OK, deal!
14:31:04 <EvanR> monads arent generally characterized by a run function and do-some-stuff functions, thats just one way to use it (transformers come to mind)
14:31:19 <ph88> prsteele, you mean use   let .. in    or   where ?
14:31:30 <monochrom> But my "cross apply" suggestion is real.
14:31:54 <dmwit> ph88: Well, it's buggy, so there's at least one good reason you don't understand it. Here's a better version, I think: `the_rest <- some (liftM2 (\xs y -> xs ++ [y]) (option [] underline) letterOrDigit)`
14:31:58 <parsnip> it's a good compromise twoards DolphinScript
14:32:02 <monochrom> I much regret that 20 years ago when I was learning SQL and generally databases, they didn't bring up cross apply.
14:32:22 <monochrom> would have totally made monads easier to relate to 10 years ago.
14:32:23 * yyyyy goes looking for cross apply, even though writes SQL daily
14:32:34 <prsteele> ph88, e.g. "fs = do underline <- option Nothing ...", and then in basicIdentifier "the_rest <- some fs"
14:32:46 <monochrom> yeah, you will be thrilled, it's (>>=) for tables
14:32:54 <Welkin> tables!?
14:32:55 <prsteele> ph88, it could be top-level, or in a let ... in clause
14:32:56 <EvanR> i write SQL but it doesnt write back
14:32:57 <Welkin> what about chairs?
14:33:21 <yyyyy> EvanR: lol
14:34:45 <monochrom> chsn: on the web page for Programming in Haskell, you can find a link to his lecture slides for chapters 1-10. (It is a zip file.) From them you may be able to guess how much you want this book.
14:35:18 <ph88> dmwit, it's shorter but i don't understand it as well as the original code ^^
14:36:03 <dmwit> ph88: By the way, are you sure this is the parser you intended to write? This demands at least one letter or digit between every underline, which seems an odd restriction.
14:36:56 <dmwit> basicIdentifier = liftM2 (:) letterV (many (underline <|> letterOrDigit)) -- seems much more natural
14:37:53 <dmwit> (My proposed rewrite also lifts the restriction that identifiers have at least two characters, which again seems odd on the face of it.)
14:38:04 <yyyyy> monochrom: looks really great. i think i could avoid a few roundtrips to the database just by using it in a few cases. this is only available in SQL Server, right?
14:38:25 <ph88> dmwit, this is the grammar:      basic_identifier ::= letter ( underline? letter_or_digit )*
14:38:31 <ph88> i will double check it with the standard
14:38:40 <monochrom> probably. I don't actually know. I heard of it from some Erik Meijer articles on ACM Queue.
14:39:09 <EvanR> "its in SQL" hopefully doesnt mean its only in MS SQL server
14:39:19 <dmwit> ph88: Okay. You will at least want to switch from `some` to `many`; `some` is 1 or more, but the * in your grammar is probably 0 or more.
14:39:37 <dmwit> ph88: I wonder whether underline is a terminal or nonterminal in your grammar...?
14:40:08 <ph88> dmwit, yes i just noticed that and already switched
14:40:22 * dmwit nods agreeably
14:40:53 <monochrom> You know what, I feel totally moral and ethical to say both "SQL has cross apply" and "Haskell has PolyKinds and TypeInType".
14:41:03 <yyyyy> EvanR: that's what i meant, yes. i couldn't look it up elsewhere.
14:41:07 <ph88> dmwit, underline was not specified .. the standard is ambiguous on this part
14:41:23 <yyyyy> find it*, sorry.
14:42:03 <EvanR> haskell has foo = ghc has foo, since ghc is the unique haskell product
14:42:21 <monochrom> Or maybe not like that, instead more like "cross apply in SQL" and "PolyKinds in Haskell"
14:42:33 <ph88> dmwit, i implemented it as this   underline = char '_'
14:42:54 <EvanR> cross apply existed in sql 20 years ago?
14:43:05 <monochrom> I don't know.
14:43:27 <EvanR> the timeline must have been tampered with, terminate the experiment
14:43:28 <monochrom> It doesn't matter. If it didn't existed, then I much regret that it didn't exist. You have a problem?
14:44:31 <ph88> anyone know how to change this String to Text ?  https://paste.fedoraproject.org/419429/64977147/
14:45:11 <monochrom> Oh God, why is it using dark green ink to redact most of your code?
14:45:27 <dmj> ph88: library <- Data.Text.pack <$> string' "LIBRRAY"
14:45:36 <ph88> i was thinking to make a text' function, but i'm doing it wrong    text' = T.pack <$> string'
14:45:44 <yyyyy> single quote confused the highlighter i imagine
14:45:50 <prsteele> ph88, alternatively {-# LANGUAGE OverloadedString #-} might help
14:46:02 <ph88> prsteele, i already use that extension :/
14:46:03 <prsteele> ph88, OverloadedStrings, sorry
14:46:28 <monochrom> yeah, you want text' x = T.pack <$> string' x
14:46:28 <dmj> prsteele: think you'd still need to be explicit here even with OS enabled
14:46:31 <EvanR> ph88: i didnt ask this before, so to try and avoid a time loop, what the heck is string' ?
14:46:48 <monochrom> Don't go pointfree so quickly. You usually have type errors.
14:46:53 <prsteele> dmj: would just a type annotation work, then? :: T.Text ?
14:47:45 <prsteele> I'm not familiar with the internals of that (or any) extension
14:48:01 <dmj> prsteele: no, I think string' actually returns String
14:48:07 <ph88> EvanR, https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Char.html#v:string-39-
14:48:09 <dmj> prsteele: his type expects Text
14:48:10 <hpc> OverloadedStrings only makes literals polymorphic
14:48:16 <hpc> it's like Num and numeric literals
14:48:26 <hpc> you can write 5 and it will be polymorphic
14:48:32 <prsteele> ah okay, I didn't read his code closely enough, my bad
14:48:33 <dmj> prsteele: therefor, we'd need to convert from String to Text, Data.Text.pack :: String -> Text, q.e.d
14:48:34 <hpc> but (length [1, 2, 3, 4, 5]) is always going to be Int
14:48:58 <EvanR> ph88: maybe there is a Text version of that combinator in megaparsec
14:48:59 <ph88> monochrom, why was my point-free not correct ?
14:49:12 <monochrom> I don't know how to answer that.
14:49:19 <ph88> EvanR, i wish there was .. in any case i couldn't find it .. i'm already on the Text page .. so not sure if it's not there or i'm doing something wrong
14:50:09 <monochrom> Maybe I do. You're looking at "fmap pack (string x)" vs "(fmap pack string) x"
14:50:36 <puregreen> EvanR: there isn't
14:50:40 <ph88> monochrom, your function yields this  https://paste.fedoraproject.org/419467/27666001/
14:51:21 <monochrom> Oh OK, I guess I don't know what string' is.
14:51:38 <ph88> maybe i should just enable TypeFamilies like the suggestion ?
14:52:09 <ph88> https://hackage.haskell.org/package/megaparsec-5.0.1/docs/src/Text-Megaparsec-Char.html#string%27
14:52:26 <EvanR> string' :: String -> Parser String
14:52:44 <EvanR> string' . pack :: Text -> Parser String
14:52:57 <EvanR> fmap unpack string' :: String -> Parser Text
14:53:02 <EvanR> oops, that should also be pack
14:53:20 * hackagebot llvm-extra 0.6.0.2 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.6.0.2 (HenningThielemann)
14:53:37 <EvanR> its also wrong, nevermind
14:53:53 <ph88> was already using fmap infix     text' x = T.pack <$> string' x
14:54:06 <EvanR> there you go then
14:54:15 <ph88> that was not working
14:54:21 <dmj> ph88: <- instead of =
14:54:28 <dmj> you're in that monad
14:54:38 <EvanR> text' would be a new function
14:54:40 <ph88> i wanted to define a new function :/
14:54:43 <dmj> oh oh, I see
14:54:54 <EvanR> "not working" isnt helpful
14:55:08 <ph88> was specified here: https://paste.fedoraproject.org/419467/27666001/
14:55:16 <ph88> 15 lines up or so
14:55:33 <EvanR> you have to enable that extension to write such a signature then
14:55:46 <EvanR> though what signature and if its appropriate i dont know
14:55:47 <ph88> TypeFamilies ye ?
14:56:17 <EvanR> neither seem to pertain directly to ~ constraints
14:56:24 <EvanR> so whichever
14:56:50 <ph88> i'm just reading this for the moment https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html
14:56:57 <ph88> also i'm not familiar with ~ constraints
14:57:21 <monochrom> I don't know why some "Token" type is involved.
14:57:34 <Welkin> (Int ~ a) => a -> a -> a
14:57:37 <Welkin> that just means
14:57:41 <Welkin> Int -> Int -> Int
14:57:42 <monochrom> At least, not when we assume "string' :: String -> Parser String"
14:58:02 <EvanR> monochrom: that type is actually a simplification of a type with lots of constraints
14:58:10 <monochrom> Therefore, the logical conclusion is: either there is a lie somewhere, or the problem cause is elsewhere.
14:58:49 <EvanR> (MonadParsec e s m, Token s ~ Char) => String -> m String
14:59:12 <ph88> well it works with TypeFamilies ^^
15:00:38 <EvanR> ph88: for posterity, that type signature says you have a String -> m String, where m is constrained by MonadParsec e s m and Token s is equal to Char. Token is probably a type family
15:00:43 <EvanR> and e can be anything
15:01:10 <EvanR> s is the stream type for the parser youre using
15:01:24 <ph88> oki
15:01:24 <zq> :t \n -> foldl (>>=) mempty . replicate n
15:01:26 <lambdabot> (Monoid (m a), Monad m) => Int -> (a -> m a) -> m a
15:01:45 <zq> ^ is there a pre-existing function that does the above?
15:01:51 <EvanR> what those constraints really mean depends on more investigation into their definitions
15:02:43 <EvanR> :t foldM
15:02:45 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
15:03:11 <EvanR> hrms
15:04:11 <monochrom> I find the inferred "Monoid (m a)" pretty strange. So basically this is only good for a few things like [a] and Maybe a.
15:04:40 <zq> oh hey foldM
15:04:54 <zq> fold 'em
15:04:55 <yyyyy> if you extract 'mempty' and pass it as a parameter you can get rid of Monoid, no?
15:04:56 <zq> EvanR: thanks
15:05:49 <zq> :t \n start f -> foldl' (>>=) start $ replicate n f
15:05:51 <lambdabot> Monad m => Int -> m a -> (a -> m a) -> m a
15:05:59 <zq> monochrom: i guess i really meant that ^
15:06:40 <ph88> what's the difference between a type class and a type family ?
15:06:47 <yyyyy> zq: that, yes
15:07:43 <ph88> oh type families are types which take types
15:08:08 <ph88> and type classes are not types but like an interface for a type ?
15:09:20 <volhovm> Hi guys! One can't do a mtl transformer stack having two Reader monads for example. So is there any other way to do it? Like to parametrize MonadReader class with another parameter (type-level int literal) and use functions of type (MonadReader 2 s m) (MonadReader 3 s m) => ... where integer stays for the depth of stack?
15:09:30 <volhovm> I don't know. Are there any solutions?
15:09:40 <phadej> volhovm: lensy optics
15:09:49 <phadej> MonadReader env m, HasFoo env, HasBar env
15:09:53 <monochrom> "One can't do a mtl transformer stack having two Reader monads for example." This premise sounds wrong.
15:10:20 <volhovm> Hm, but if we have (MonadReader s1 m) (MonadReader s2 m) => ... function then what `ask` will return?
15:10:22 <phadej> though, lenses are optional, just start to be handy in that setting
15:10:28 <phadej> volhovm: we cannot
15:10:29 <monochrom> I can totally do ReaderT Int (ReaderT Bool Identity).
15:10:45 <yyyyy> volhovm: you can probably label the Readers, with the easiest way being newtypes. but isn't it easier to make a product type out of the two reader datatypes and carry only one Reader?
15:10:52 <volhovm> monochrem: Yes, but which MonadReader instance will it have?
15:10:58 <phadej> MonadReader has functional dependency, m determines r in MonadReader r m | m -> r
15:11:02 <monochrom> OK, I can't do that.
15:11:03 <mpickering> What is the recommended way to get a source of randomness these days? Is there a type class which provides a sensible interface?
15:11:28 <volhovm> yyyyy: imagine you're importing monad M1 from some library and you want to add some local config into it.
15:11:41 <cloudhead> what could cause haddock from not generating documentation for record fields when I have an export list with MyRecord(..) ?
15:11:42 <volhovm> Still having reader features from the library and adding your stuff to reader.
15:11:45 <phadej> volhovm: https://www.youtube.com/watch?v=GZPup5Iuaqw
15:12:22 <yyyyy> in this case i'd wrap the datatype in a newtype if they're the same, to avoid being stuck at the first to match
15:12:23 <phadej> mpickering: I use http://hackage.haskell.org/package/entropy
15:12:56 <yyyyy> ReaderT A $ ReaderT B Identity
15:13:20 <mpickering> phadej: Ok, do you know if there is anything which has a more complete API? I don't need randomness for anything serious
15:13:28 <yyyyy> though you have to unpack the newtype yourself. i never ran into that sort of situation, though.
15:13:32 <monochrom> Um, you can't write "$" in types :)
15:13:44 <volhovm> yyyyy: yes, i'm just thinking it can happen. rare case imo
15:13:47 <yyyyy> type f $ x = f x
15:13:59 <yyyyy> monochrom: i learned about it recently. so useful :)
15:13:59 <monochrom> oh darn it can be done?
15:14:13 <phadej> mpickering: serious or not http://hackage.haskell.org/package/monadcryptorandom works well for me for actual prng
15:14:21 <shachaf> With GHC TypeOperators.
15:14:22 <yyyyy> with TypeOperators. i don't remember who it was, but it was here on IRC.
15:14:32 <phadej> mpickering: with http://hackage.haskell.org/package/DRBG
15:14:44 <volhovm> phadej: thanks for the video
15:15:06 <phadej> mpickering: I did helpers for myself for those, so I actually don't remember the details :)
15:15:32 <mpickering> thanks for the suggestions
15:16:23 <shachaf> monochrom: You even talked about it here recently, in http://ircbrowse.net/browse/haskell?id=23199922&timestamp=1470865017#t1470865017
15:16:54 <yyyyy> hahahha and it was me asking about it
15:17:13 <yyyyy> we both have horrible memories
15:17:47 <NaOH> Let's say I have an f :: Int -> Int -> IO (), and I want to read the Int(s) from stdin, so I do a <- getLine; b <- getLine. Now, reading a and b into Int may fail, so I could use readMaybe from Data.Text. How can I compose readMaybe with f, in such a way that if either readMaybe a or readMaybe b is Nothing, for instance do putStrLn "error!", otherwise, run f a b?
15:17:52 <monochrom> I only remember things in the distant past...
15:19:18 <c_wraith> you don't remember any of the future at all? how unusual. 
15:19:49 <NaOH> * I should've said, run f (read a) (read b), or something among those lines
15:20:06 <shachaf> NaOH: Perhaps liftA2 f (readMaybe a) (readMaybe b)
15:20:21 <EvanR> whether a record is a memory or a prediction is subjective
15:21:11 <shachaf> Or even (liftA2 f `on` readMaybe). But that might be going too far.
15:21:41 <yyyyy> EvanR: a record is a memory location that you have to import half of hackage to access deeply nested
15:22:11 <shachaf> Or: [f x y | x <- readMaybe a, y <- readMaybe b]?
15:22:12 <NaOH> shachaf: thanks! I think that'll do it
15:28:21 * hackagebot bimaps 0.1.0.1 - bijections with multiple implementations.  https://hackage.haskell.org/package/bimaps-0.1.0.1 (ChristianHoener)
15:33:21 * hackagebot FormalGrammars 0.3.1.0 - (Context-free) grammars in formal language theory  https://hackage.haskell.org/package/FormalGrammars-0.3.1.0 (ChristianHoener)
15:34:16 <prsteele> I've seen some packages that use .Type or .Class modules... does anyone have a reference to a writeup explaining / justifying that design choice?
15:34:19 <Sonolin> who
15:35:33 <puregreen> prsteele: that design choice usually stems from the fact that without moving all types into a .Type module you tend to have mutually recursive modules
15:36:15 <puregreen> so instead of moving everything into one single giant module people just move types into one module and import it everywhere
15:36:22 <prsteele> puregreen: reasonable enough, thanks!
15:37:17 <puregreen> and then the .Type module ends up taking a minute to compile and you hate touching it
15:37:26 <prsteele> heh
15:37:53 <kadoban> Took me a while to learn that lesson ... my early projects have a lot of weirdness to avoid mutual imports instead of a more-sane .Types module.
15:43:22 * hackagebot dbm 0.2.1 - A *simple* database migration tool.  https://hackage.haskell.org/package/dbm-0.2.1 (RickyElrod)
15:48:33 <cloudhead> I can't seem to be able to generate haddocks for record fields that are manually exported. Any ideas why?
15:49:08 <cloudhead> It only works if the module has no export list, but if I do MyRecord(..) or MyRecord(MyRecord, field1), field1 doesn't show up in the doc
15:53:22 * hackagebot dbm 0.2.2 - A *simple* database migration tool.  https://hackage.haskell.org/package/dbm-0.2.2 (RickyElrod)
15:59:18 <dmwit> cloudhead: odd
15:59:39 <orion> I have a set of points which I want to connect using the diagrams library. I want to use the curve connector operator (.--.). Given a [P2 Double], how do I connect them, given the fact that the /last/ point must be passed to the "endpt" function?
16:00:14 <cloudhead> dmwit: yes and it works fine if my module has no export list :/
16:00:23 <orion> Assuming `pts` holds the points of the data I want to graph, I tried this: foldl' (.--.) origin pts
16:00:35 <orion> But, that won't ever work due to the aforementioned "endpt" requirement.
16:00:53 <zennist1> is there a way to accept a typeable and do different things depending on what typeclass it belongs to?
16:01:35 <dmwit> orion: It might help clarify your question if you say what you want to happen on a smallish example list. e.g. what would the diagram corresponding to `[x,y,z]` be?
16:01:44 <dmwit> orion: `x .--. y .--. z` -- ?
16:02:19 <dmwit> zennist1: Not really.
16:03:01 <orion> dmwit: Ah, [w, x, y, z] could be either: origin .--. w .--. x .--. y .--. endpt z   or: w .--. x .--. y .--. endpt z
16:05:18 <dmwit> orion: Rip off the last element and use a fold on the rest...?
16:12:50 <orion> dmwit: Doesn't type check, unfortunately: (.--.) :: P2 n -> Diagrams.TwoD.Path.Metafont.Types.MFPathData Diagrams.TwoD.Path.Metafont.Types.P n -> Diagrams.TwoD.Path.Metafont.Types.MFPathData Diagrams.TwoD.Path.Metafont.Types.P n
16:13:08 <orion> endpt :: P2 n -> Diagrams.TwoD.Path.Metafont.Types.MFPathData Diagrams.TwoD.Path.Metafont.Types.P n
16:13:23 * hackagebot BiobaseTypes 0.1.2.0 - Collection of types for bioinformatics  https://hackage.haskell.org/package/BiobaseTypes-0.1.2.0 (ChristianHoener)
16:13:25 * hackagebot BiobaseXNA 0.9.3.0 - Efficient RNA/DNA representations  https://hackage.haskell.org/package/BiobaseXNA-0.9.3.0 (ChristianHoener)
16:14:26 <lpaste> emmanuel_erc pasted “I am having troubling generalizing this? Any thoughts?” at http://lpaste.net/182775
16:15:29 <emmanuel_erc> The title should "I am trouble..."
16:15:29 <dmwit> > let f [x] = endpt x; f (x:xs) = x .--. f xs in f [w,x,y,z]
16:15:31 <lambdabot>  w .--. x .--. y .--. endpt z
16:16:07 <dmwit> > let f xs = case reverse xs of x:xs' -> foldr (.--.) (endpt x) (reverse xs') in f [w,x,y,z]
16:16:09 <lambdabot>  w .--. x .--. y .--. endpt z
16:16:45 <dmwit> orion: If you want help with a specific error, you should paste the exact error together with a minimal reproducible example to lpaste.
16:16:48 <dmwit> ?lpaste
16:16:48 <lambdabot> Haskell pastebin: http://lpaste.net/
16:17:22 <cloudhead> dmwit: figured it out.. I think it's a bug with -XDuplicateRecordFields
16:17:35 <dmwit> cloudhead: Oh, nasty.
16:17:38 <cloudhead> because the field names are rewritten
16:17:51 <dmwit> Yeah, I can see how language extensions might interact weirdly with haddock.
16:18:23 * hackagebot dbm 0.3 - A *simple* database migration tool.  https://hackage.haskell.org/package/dbm-0.3 (RickyElrod)
16:18:33 <cloudhead> gonna check if it's on the bug tracker already
16:22:04 <cloudhead> yep.. https://github.com/haskell/haddock/pull/486
16:22:05 <orion> dmwit: Doing pattern matching did the trick, thanks!
16:47:09 <orion> joe9: Is there a cleaner way of working with periodic functions than using the (~~) operator to join thousands of line segments?
17:08:17 <xcmw>  /SET autolog ON
18:18:27 * hackagebot x86-64bit 0.3 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.3 (PeterDivianszky)
19:09:49 <ReinH> orion: connect [p:ps] = p .--. connect ps; connect [p] = endpt p; connect [] = error "connect: empty list"
19:15:21 <elliptic00> data Tree a = Empty 
19:15:21 <elliptic00>             | Node a (Tree a) (Tree a) deriving (Show)
19:15:21 <elliptic00> buildTree::(Tree a)=>[a]->[a]->Tree a
19:15:23 <elliptic00> buildTree _ _ = Empty
19:15:25 <elliptic00>  
19:15:58 <elliptic00> I have above code, and I got compiler error: 
19:16:14 <elliptic00> Expected a constraint, but ‘Tree a’ has kind ‘*’
19:16:14 <elliptic00>     In the type signature for ‘buildTree’:
19:16:14 <elliptic00>       buildTree :: (Tree a) => [a] -> [a] -> Tree a
19:16:35 <geekosaur> @paste
19:16:35 <lambdabot> Haskell pastebin: http://lpaste.net/
19:16:37 <dmj> elliptic00: so, there is a code pasting service http://lpaste.net, it might be easier to put your code there, and syntax highlighting is provided too
19:16:42 <ania123> as I know haskell is static type language, but in yhe following hskell code I do not see variable assignment, why???
19:16:45 <ania123> fac 0 = 1 fac n = n * fac (n-1)
19:17:15 <elliptic00> thx dmj
19:17:28 <ania123> why is declaration of type n omittied ?
19:17:32 <geekosaur> but, yes, that;s not going to work. What do you believe `(Tree a) =>` means?
19:17:54 <geekosaur> n is not a type
19:18:03 <ania123> n is a variable
19:18:04 <pavonia> ania123: In most cases you can omit the type signature and the compiler will infer it for you
19:18:05 <ania123> is not?
19:18:20 <glguy> ania123: The type is inferred. Statically typed doesn't mean explicitly typed
19:18:29 <geekosaur> types can be inferred. signatures are often a good idea, but not necessary
19:18:31 <pavonia> :t let fac 0 = 1; fac n = n * fac (n-1) in fac
19:18:33 <lambdabot> (Num t, Eq t) => t -> t
19:19:06 <dmj> ania123: you can think of it more like binding symbols to values. In haskell the runtime system is responsible for the allocation, mutation (assignment). Of course, there are ways to do mutable things, but haskell itself is pure from that perspective
19:19:23 <ania123> statically typedmeans, type is checked during compile tyme
19:19:36 <ania123> if we do not assign types variables
19:19:41 <ania123> how it is verified?
19:20:03 <glguy> It is verified that it was used consistently across the program
19:20:04 <dmj> ania123: using a type inference algorithm, hindley milner
19:20:19 <ania123> ok
19:20:21 <ania123> thx
19:21:26 <ania123> Functional programs has no side eects.
19:21:41 <ania123> can one write for me very very small imperative programm
19:21:54 <dmj> ania123: it's called Algorithm W
19:21:55 <ania123> where occurs side effect
19:21:55 <glguy> No, functional programs have side effects, function application doesn't
19:22:33 <elliptic00> buildTree::[Char]->[Char]->Tree Char, it works now...
19:22:43 <glguy> or at least they have "effects" if there's a distinction to be made
19:22:58 <geekosaur> elliptic00, did you see my question earlier?
19:23:22 <ania123> http://stackoverflow.com/questions/2835801/why-hasnt-functional-programming-taken-over-yet
19:23:37 <ania123> Stateless programs; No side effects
19:24:19 <elliptic00> (Tree a)=> .. a is type of Tree?
19:24:42 <ania123> elliptic00: what is side effects? could you explain it me please?
19:25:34 <elliptic00> not sure.. not sure how that relate to side effect
19:26:19 <elliptic00> maximum1'::(Ord a) =>[a]->a
19:26:41 <elliptic00> a is type of Ord?
19:27:11 <elliptic00> can u explain how that relate to side effect?
19:27:40 <ania123> no, i can not
19:30:10 <Cale> ania123: It's really just *evaluation of expressions* which doesn't have effects in Haskell.
19:30:42 <ania123> Cale: does it has effect to other languages?
19:30:44 <Cale> ania123: That is, the process of reducing expressions to values for the purposes of pattern matching on the result doesn't have extraneous effects.
19:31:25 <Cale> Haskell has a separate type of values called "IO actions", and there's a process by which the steps described by those values are carried out, and *that* has effects.
19:31:57 <Cale> The 'main' in a compiled program will be such an IO action, and running the program will cause that action to be executed, which can have arbitrary effects on the computer.
19:32:30 <Cale> But for example, if you have a function of type  Integer -> Integer, and you apply it to 5 or something,
19:32:37 <Cale> 1) You will always get the same result
19:32:47 <Cale> 2) Nothing except for computing that result will occur
19:33:30 * hackagebot text-zipper 0.6 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.6 (JonathanDaugherty)
19:33:59 <Cale> Basically, a function f of type A -> B in Haskell is really a mathematical function: for any given value a of type A, if we compute f a and get some result b, then we'll always get that result
19:34:12 <Cale> (for the same f)
19:35:17 <Cale> and IO actions merely describe what things need doing, so evaluating them doesn't cause anything to happen, just as evaluating 1 + 1 and obtaining 2 doesn't have any other effects
19:35:55 <ReinH> elliptic00: you don't put types on the lhs of =>
19:36:07 <ReinH> You put type class constraints
19:36:34 <ReinH> E.g., Eq a => a -> a -> Bool
19:36:55 <ReinH> Eq is a typeclass, not a type
19:38:51 <ReinH> ania123: programs in functional languages have state.
19:41:54 <dmj> > flip execState 0 $ replicateM 10 $ modify (+1)
19:41:57 <lambdabot>  10
19:42:14 <dmj> state ! 
19:43:57 <ReinH> > let f = (+ 1) in f . f . f . f . f . f . f . f . f . f  $ 0
19:43:59 <lambdabot>  10
19:44:04 <ReinH> State!
19:50:13 <pavonia> with (0 :: Int) $ \ptr -> forM_ [1..10] $ \i -> poke ptr i  -- actual state!
19:51:01 <ReinH> They're all actual state
19:51:20 <dmj> > head [10]
19:51:22 <lambdabot>  10
19:51:23 <dmj> state!
19:51:37 <Jenaf> is there any standard library for handling bitmaps or so?
19:52:19 <dmj> @hackage bitmap
19:52:19 <lambdabot> http://hackage.haskell.org/package/bitmap
19:52:27 <ReinH> Handling them in what way?
19:52:32 <dmj> there's also JuicyPixels
19:53:29 <dmj> @package JuicyPixels
19:53:29 <lambdabot> http://hackage.haskell.org/package/JuicyPixels
20:03:31 * hackagebot text-zipper 0.6.1 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.6.1 (JonathanDaugherty)
20:05:51 <Jenaf> is there a way to download packages and dependencies in a fast way? (on a windows machine)
20:06:34 <Jenaf> and lol it seems that the package linear also includes a type for 0-dimensional vectors 
20:06:42 <nitrix> I'm not sure what you mean by "in a fast way". Your internet bandwith is going to limit the download speed regardless of your operating system.
20:08:04 <Jenaf> yeah, but is there something in the normal ghc platform to handle it?
20:08:05 <ReinH> cabal and stack are both designed to manage dependcies
20:08:07 <zq> how to pass flag to ghc --make when invoking cabal install
20:08:28 <nitrix> Jenaf: You're supposed to use cabal and/or stack to manage your project dependencies.
20:08:36 <ReinH> zq: why?
20:08:39 <Jenaf> I have the Platform thing from the haskell hompage, I think thats different from cabal or stack
20:08:47 <zq> ReinH: because i want to
20:08:53 <zq> because i need to
20:08:53 <nitrix> Jenaf: The latest Haskell Platform includes both.
20:09:02 <Jenaf> oh
20:09:08 <zq> because it's borderline ridiculous/hilarious that cabal install is running on 1/32 cores
20:09:14 <Jenaf> and how do I use them?
20:09:20 <zq> "why" lol
20:09:28 <ReinH> That seems unlikely, but cabal has a flag for ghst
20:09:33 <ReinH> For that.
20:09:39 <ReinH> For passing options to ghc
20:09:44 <nitrix> Jenaf: stack build, stack ghci, stack exec, stack install, ...
20:09:59 <Jenaf> ah
20:10:22 <Jenaf> I was using ghc to compile things that needed compilation or esle bare ghci
20:10:34 <nitrix> Jenaf: Most projects have a .cabal file that list the executable/libraries/dependencies/modules/ghc-flags/project details/so on.
20:11:00 <ReinH> zq: cabal has a -j flag for parallel builds
20:11:00 <nitrix> Jenaf: Here's one: https://github.com/nitrix/lspace/blob/master/lspace.cabal
20:11:12 <zq> ReinH: that does nothing to parallelize
20:11:13 <Jenaf> nitrix: at the moment I'm only doing little things to play around and learn haskell; so nothing over a few hundred lines
20:11:17 <ReinH> ...
20:11:28 <ReinH> Yes, it does.
20:11:37 <zq> all it does is parallelize across packages, not per package
20:11:48 <zq> ReinH: you want me to paste for you the top graph?
20:11:49 <Jenaf> that file is generated by cabal?
20:11:50 <nitrix> zq: Try +RTS -N ?
20:11:59 <zq> nitrix: on cabal?
20:12:23 <zq> whatever, i just hacked the ghc wrapper script
20:12:31 <nitrix> cabal is written in Haskell, no? It probably is subject to the same runtime system any other haskell app has.
20:12:47 <zq> nitrix: that would just parallelize the cabal executable itself, not the sub-ghcs
20:12:51 <zq> christ
20:14:25 <nitrix> Did I say anything wrong?
20:14:40 <glguy> ghc has a parallel build mode for when building a single package
20:15:21 <glguy> but it seems to go unused, I seem to remember it not working reliably in the past
20:15:30 <ReinH> zq: what version of cabal?
20:16:36 <ReinH> cabal build -j has built single packages in parallel since 1.20 http://blog.johantibell.com/2014/04/announcing-cabal-120.html
20:17:32 <glguy> zq: ghc itself has or had a -j flag of its own
20:17:54 <nitrix> 23:13:23          <-- | zq (~zq@pool-74-108-64-103.nycmny.fios.verizon.net) has left #haskell
20:17:56 <glguy> see lens.cabal for example
20:18:14 <glguy> well, bummer for him then
20:18:41 <glguy> stupid people flaming out of the channel don't deserve answers
20:18:50 <ReinH> lol
20:19:10 <nitrix> He seemed particuliarly angry that I suggested +RTS -N to try and solve his issue where -j wasn't giving him parallelization as suggetsed by ReinH.
20:19:24 <ReinH> Well, it wouldn't have worked
20:19:34 <ReinH> That wouldn't parallelize ghc
20:20:12 <nitrix> But doesn't cabal need it still to do whatever it does internally to parallelize ghc?
20:21:08 <nitrix> It's a first step. I don't know, I was going by elimination :/
20:50:48 <augur> anyone wanna chat about the SECD machine and its connection to CPS?
20:50:57 <augur> in particular, Plotkin's CBN+CBV paper?
20:51:00 <benzrf> what's the secd machinedgod 
20:51:01 <benzrf> *machine
20:51:07 <augur> lmfao
20:51:07 <augur> :)
20:51:21 <augur> SECD is a common type of abstract machine
20:51:25 <augur> State Environment Control Dump
20:51:33 <augur> its somewhat less elegant than the CEK machine, tho
20:51:40 <benzrf> what's the sek machine
20:51:57 <augur> CEK = Control Environment C[K]ontinuation
20:52:48 <benzrf> what is that, german or somethin
20:53:06 <augur> no, it's just to distinguish the continuation from control :)
23:03:36 * hackagebot shakespeare 2.0.11.1 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.11.1 (MichaelSnoyman)
23:20:42 <rios> pl \x->x
23:20:59 <cocreature> @pl \x -> x
23:20:59 <lambdabot> id
23:21:02 <cocreature> ^ rios
23:21:43 <rios> thanks
23:22:39 <rios> @pl \val f -> concat $ map f val
23:22:39 <lambdabot> (join .) . flip map
23:23:45 <parsnip> :t flip concatMap
23:23:47 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
23:25:26 <jle`> :t (>>=)
23:25:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:28:37 * hackagebot writer-cps-transformers 0.1.0.2 - WriteT and RWST monad transformers  https://hackage.haskell.org/package/writer-cps-transformers-0.1.0.2 (minad)
23:28:39 * hackagebot writer-cps-mtl 0.1.0.2 - MonadWriter orphan instances for writer-cps-transformers  https://hackage.haskell.org/package/writer-cps-mtl-0.1.0.2 (minad)
23:38:37 * hackagebot cpuinfo 0.1.0.0 - Haskell Library for Checking CPU Information  https://hackage.haskell.org/package/cpuinfo-0.1.0.0 (TravisWhitaker)
23:44:38 <parsnip> is there any monolithic cabal user guide? 
23:45:17 <parsnip> ah, i think this is it ftp://ftp.geoinfo.tuwien.ac.at/frank/Cabal.pdf
23:46:05 <Cooler> in this introduction to type classes in haskell https://www.haskell.org/tutorial/classes.html
23:46:29 <Cooler> under A Different Perspective. a comparison is drawn to OOP
23:46:54 <Cooler> where they talk about type classes being like classes and types being like objects
23:47:21 <Cooler> i don't think thats true, actually type classes are more like interfaces in java and types like classes
23:51:27 <Cooler> everything about type classes seem to parallel java interfaces, including inheritance and default methods
23:52:08 <liste> Cooler: they're pretty different - interfaces deal with *objects*, while type classes deal with *types*
23:52:58 <Cooler> liste, different how?
23:53:40 <liste> Cooler: you can have a value that's Iterable, for example, but you can't have a value that's Functor - only types that are Functors
23:53:52 <liste> one example of the difference is the Default type class
23:54:01 <liste> class Default a where def ::  a
23:54:04 <nshepperd> they're like java interfaces in that their purpose is to define an 'interface'
23:54:37 <Cooler> liste, you don't have a value thats iterable, you have a java class(type) thats iterable
23:54:40 <nshepperd> otherwise oop analogies aren't very good
23:55:03 <Cooler> a class implements iterable not a object
23:55:07 <liste> Cooler: sure I have a value that's iterable
23:55:22 <liste> I can receive an Iterable<Integer> value
23:55:29 <liste> in a function for example
23:55:39 <liste> (well, method)
23:56:00 <Cooler> when i say type classes are like java interfaces, i am talking about Eq and Ord
23:56:04 <Cooler> stuff like that
23:56:08 <parsnip> i thought that paragraphs was more an exercise in that they were able to replace words and have it be pretty accurate. i don't think analogies are ever a monopoly. 
23:56:32 <parsnip> *those paragraphs were
23:56:42 <Cooler> type classes require you to implement some methods for ad hoc polymorphism and so do interfaces
23:57:13 <liste> interfaces are subtype polymorphism
23:57:24 <Cooler> and interfaces can have the same inheritance and default methods like type classes
23:58:07 <parsnip> typeclasses don't really have default methods, but rather specify functions and their types that should be implemented. 
23:58:57 <Cooler> like the Comparable interface is the same as Ord
23:59:32 <Cooler> parsnip, they do have default implementations
