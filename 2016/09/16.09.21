00:01:00 <Axman6> edwardk: Are you still maintaining compensated? I'm using bos' maths-functions package in foldl-statistics because statistics does, but had a few cases where I needed some functions not offered by bos' package
00:01:31 <edwardk> i'm keeping it building, but not actively doing new stuff on it
00:01:45 <Axman6> that's probably good enough I think
00:02:00 <edwardk> what do you need from compensated?
00:02:01 <Axman6> just wasn't to make sure it's not abandonware
00:02:08 <edwardk> i need to get around to fixing up log, exp, etc.
00:02:23 <edwardk> it spun out of my old work on analytics
00:02:38 <Axman6> mainly just summation, multiplation and subtraction (maths-functions only offers the first)
00:02:55 <edwardk> those should work, but keep in mind i only proved it correct, i never actually ran it ;)
00:03:03 <edwardk> well, that's a bit of an over simplification
00:03:11 <edwardk> but be forewarned
00:03:30 <Axman6> yeah I _think_ that I probably don't need anything trigonometric or exp/log
00:03:43 <Axman6> I've aimed the package at things working over Doubles
00:03:53 <edwardk> good, because the trig stuff and log/exp don't work any better than as if they were doubles
00:04:00 <Axman6> yeah
00:04:15 <Axman6> any idea if there are better known algorithms?
00:04:18 <edwardk> they need to know a number of newton raphson steps to take or double angle fomula steps, and the class as structured doesn't give them that
00:04:42 <edwardk> well, the algorithms i use are basically the ones from the quad double folks, except generalized to work over themselves iteratively
00:04:54 <edwardk> so i can use Compensated (Compensated Double)
00:05:16 <edwardk> i just never implemented the extra trig functions when i write it the first time
00:05:29 <Axman6> right
00:05:44 <edwardk> MPFR is a much more robust solution, but a lot slower
00:06:03 <Axman6> well for my use that shouldn't matter, I only use log on doubles which would be the result of many compensated computations
00:06:18 <Axman6> yeah not too worried about that. this is just stats, not real maths :P
00:06:22 * Axman6 ducks
00:06:36 <edwardk> i wrote compensated so i could accumulate a bunch of things in higher moments
00:06:42 <edwardk> skewness, kurtosis, etc.
00:06:46 <edwardk> where you piss away precision fast
00:06:50 <Axman6> yeah that's exactly what this is for
00:06:55 <Axman6> https://hackage.haskell.org/package/foldl-statistics-0.1.0.0
00:07:05 <Axman6> (v 0.1.1.0 is out, but the docs aren;t building)
00:07:27 <edwardk> i had some code for computing those as a monoid in compensated form
00:07:42 * hackagebot glirc 2.18 - Console IRC client  https://hackage.haskell.org/package/glirc-2.18 (EricMertens)
00:07:42 * hackagebot brick 0.10 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.10 (JonathanDaugherty)
00:07:45 <edwardk> that helps fight the bias problem some and lets you do things like use compressed containers, etc.
00:08:23 <edwardk> i very deliberately shy away from the foldl forms because i like sharing and caching work =)
00:08:25 <Axman6> yeah it looks pretty easy to do, I thought about exposing the state from the fastLMVSK (length, mean, variance, skewness and kurtosis) function, but haven't done that yet
00:08:50 <edwardk> i was also computing covariance by component
00:08:57 <Axman6> can you expand on that?
00:09:10 <edwardk> covariance or the sharing concerns?
00:09:16 <Axman6> covariance /= correlation right?
00:09:55 <edwardk> correlation runs -1 to 1, covariance starts at 0
00:10:31 <Axman6> right
00:10:48 <Axman6> what do you mean by "because i like sharing and caching work"?
00:11:42 <edwardk> i mean i can build a tree of stuff and compute a monoid off the tree, and add new stuff anywhere, paying log'ish update costs, can replicate leaves or share them without paying a linear cost in the expanded tree rather than the shared graph
00:12:08 <edwardk> so i tend to favor using monoidal folds over left folds, because it means it is at least possible to work smarter
00:12:31 <edwardk> whereas a left fold is a race to the bottom. its a linear scan and all you can do is work faster and faster until you become io bound
00:12:50 <Axman6> yeah right, if you have data in a tree form that woiuld be useful.
00:13:13 <edwardk> well, i tend to have big honking blocks of data i want to store off to the side, i'm not mutating all of it all the time =)
00:13:18 <Axman6> I don't tend to, but would still like to expose the monoidal data so you caqn day run a computation in parallel
00:13:30 <edwardk> so being able to just grab the answer per chunk, and start from there goes a long way
00:13:40 <Axman6> yeah, agreed
00:24:26 <bollu> hey guys
00:24:39 <bollu> I was wondering if anyone had any tips to prepare for FP interviews
00:24:47 <bollu> like, other than the usual "know your DS and algo" stuff
00:25:48 <MarcelineVQ> hmm, have a project you can show off perhaps
00:28:52 <bollu> MarcelineVQ: hm, I do suppose I have that
00:30:05 <oherrala> bollu: code something together
00:30:55 <oherrala> some simple project. start coding. let the candidate do most of the coding and then help when stuck
00:31:33 <edwardk> oherrala: thinking bollu is the candidate
00:31:41 <oherrala> ah :D
00:35:04 <bollu> oherrala: yes, I'm the candidate :)
00:35:17 <bollu> I'm super excited and don't want to fuck it p
00:35:18 <bollu> up*
00:40:09 <oherrala> when interviewing people (not that I have interviewed many) I like to hear what projects (hobby or not) they have done. what technologies were used, what challenges there was and how things were solved
00:41:04 <oherrala> even better if I can point my browser to it (be it web app, or source code in github)
00:41:49 <bollu> I see :)
00:41:54 <bollu> thank you, that helps
00:42:04 <bollu> also, this is unrelated, but.. what exactly is liquid haskell about?
00:42:13 <bollu> I don't know what refinement types are
00:42:17 <bollu> could someone explain it to me?
00:42:36 <oherrala> with liquid haskell you can verify the software works as it should
00:42:58 <bollu> oherrala: so it like Coq? Like, a theorem prover? (dependant types?)
00:43:03 <oherrala> for example you can say "this function takes a list but the list should never be empty"
00:43:37 <oherrala> and "this function takes integer which should be between [N..M]"
00:43:57 <oherrala> That's all what I have learned from Liquid Haskell :)
00:44:08 <tsahyt> It also uses an SMT solver underneath
00:44:13 <tsahyt> that's where my knowledge ends
00:44:17 <oherrala> yep
00:44:28 <bollu> ah, I see
00:44:40 <bollu> so it's something like LEAN + Haskell?
00:56:47 <jle`> you know of doesn't have to be a reserved word
01:00:33 <cocreature> bollu: lean is not an smt solver :)
01:00:47 <cocreature> bollu: liquid haskell aims to be mostly automatic
01:01:33 <bollu> cocreature: ohh, really? hm, I thought it was
01:01:54 <cocreature> bollu: hm maybe we are talking about different things, I thought you are referring to https://github.com/leanprover/lean
01:02:05 <bollu> cocreature: yes, thr same
01:02:24 <cocreature> lean is more like coq or agda if you are familiar with one of those
01:02:34 <bollu> cocreature: yes, I am! I've been solving software foundations
01:02:44 <cocreature> which is very different from smt solvers like z3
01:03:31 <cocreature> bollu: also software foundations is an awesome book!
01:03:35 <bollu> cocreature: oh, so a theorem prover is more general? 
01:03:48 <bollu> cocreature: yes, I know. But college started and now I don't have a lot of time :(
01:04:10 <cocreature> yeah theorem prover is more general
01:05:07 <cocreature> there is a spectrum of theorem provers ranging from automatic (sat/smt solvers) to interactive (lean, coq, agda, …)
01:19:33 <mapty> hi guys, i am new to haskell, I was trying to test my code with the Tasty framework, so I installed it with "stack install tasty", but when i run my test file I get the message "Cannot find module Test.Tasty". Does anyone know how I can fix this ?
01:20:42 <pkmx> is tasty in your project's build-depends?
01:22:39 <mapty> i just had separate files actually, but now I figured out the problem
01:24:13 <mapty> well thanks ! 
01:34:42 <Phillemann> I'm trying to use intero, but it fails to recognize some of the modules I import. For example, "import Data.Time.Clock(UTCTime)" is marked as red, altough I do have "time" in my cabal file.
01:34:57 <Phillemann> Do I have to reload something or pass the time dependency in some other file?
01:43:38 <amalloy> if you added it to your cabal file while intero was already running, i expect you'd have to kill the intero buffer and reopen it
01:44:05 <Phillemann> You mean the "foo.hs" buffer?
01:45:55 <amalloy> no, the intero communication/repl buffer. you can just M-x intero-restart
01:46:36 <Phillemann> amalloy: Oh, silly me, didn't search for a command like that. Now it works, thanks. :)
01:46:50 <Phillemann> (Would be awesome if that command would executed automatically on .cabal file changes)
01:47:23 <amalloy> i think it would be pretty rude to automatically destroy everything the user has done in their repl
01:48:12 <Phillemann> True. You should be asked first :>
02:19:16 <bollu> assuming I want to learn to use an SMT solver
02:19:18 <bollu> what do I do?
02:20:23 <int-e> encode something simple like 8 queens, maybe
02:20:25 <bollu> like, what do I choose to model
02:20:27 <bollu> hmm
02:20:31 <koz_> bollu: http://dev.stephendiehl.com/hask/#smt-solvers
02:20:34 <bollu> what are the limits of a SAT/SMT solver?
02:20:38 <koz_> You may find this useful as a starting point.
02:20:47 <bollu> I don't really understand the boundaries between SAT solvers, SMT solvers and theorem provers
02:20:49 <zv> first
02:20:49 <koz_> bollu: It's not as simple as that to explain.
02:20:52 <int-e> bollu: memory and time ;-)
02:20:58 <bollu> zv: yes?
02:20:58 <zv> you download zv's hit new SMT interaction mode called "z3-mode"
02:21:08 <bollu> zv: I just built Z3 :)
02:21:10 <zv> next, you start his repo, this is the important part
02:21:34 <zv> it's critical for zv to appear as hip and well-loved by the open source community while he searches for a job
02:21:38 <bollu> :)
02:21:53 <int-e> bollu: it's really hard... the success of SAT/SMT solvers can be attributed to the fact that many instances of NP-complete problems turn out to be very easy. But it may be that the ones you're interested in are actually hard.
02:22:18 <zv> i totally disagree with what was just said but we won't strike it from the record.
02:22:24 <zv> anyway: https://github.com/zv/z3-mode
02:22:34 <bollu> zv: I starred it already if you notice ;)
02:22:47 <bollu> int-e: I don't really understand the boundary between SAT and SMT
02:22:49 <zv> oh good, be sure to write some glowing priase
02:23:04 <bollu> SAT is boolean satisfiability, right? Like, gievn a boolean expression, find values that satisfy it?
02:23:06 <bollu> so what's SMT?
02:23:08 <zv> "i was confronting with your brilliance when i, uh, read your simple reimplementation of lisp-mode"
02:23:13 <joncol> Hey people, I'm having some problems installing Hakyll using stack. I'm using lts-7.0 and just running `stack install hakyll` results in the system complaining about snap-core and snap-server versions being too new... Or something... ("snap-core-1.0.0.0 must match >=0.6 && <0.10").
02:23:26 <zv> bollu: Donald Knuth has a *WHOOOLLLE* new fascicle on this very topic
02:23:34 <zv> He calls it, "Boolean Satisfiability"
02:23:39 <zv> it covers both Sat and SMT
02:23:59 <bollu> zv: uhh, what's a fascicle?
02:24:09 <zv> It was proven by some hapless *$*( named Luby that any problem can be encoded in SMT
02:24:14 <zv> bollu: i don't know either
02:24:16 <int-e> bollu: yes SAT is satisfiability; SMT solvers incorporate other decidable theories (e.g. linear algebra), so instead of propositional variables you can also write, for example, inequalities.
02:24:47 <bollu> zv: uhh, any problem can be encoded in SMT?
02:24:53 <zv> bollu: yes, any
02:25:09 <bollu> int-e: so, it is SAT + presburger + other stuff?
02:25:18 <zv> he later created some important noise related to SMT called Luby Subsequences
02:25:21 <zv> but thats not important
02:25:34 <zv> because most sat solvers are just prolog that randomly restarts
02:25:38 <bollu> int-e: do they include undecidable theories it as well? (first order logic + peano)?
02:25:49 <zv> nessasarily
02:26:09 <bollu> zv: "necessarily" for which comment?
02:26:11 <zv> although you could encode those into a problem of boolean literals without any further appeal to SMT
02:26:17 <int-e> bollu: typically, no... tools that cover undecidable theories are called automated theorem provers, not SMT solvers
02:26:30 <bollu> int-e: ohh, so Coq ?
02:26:36 <int-e> no, Coq is interactive
02:26:39 <bollu> int-e: actually, no. it's tactics based
02:26:53 <bollu> int-e: hm, something like SPIN? but that's a model checker
02:26:54 <dmiles> coq cant do what Cyc does though right?
02:26:56 <zv> dude what the fuck
02:27:00 <zv> uh, sorry to swear
02:27:08 <bollu> int-e: which is an actual theorem prover?
02:27:55 <int-e> bollu: http://www.cs.miami.edu/~tptp/CASC/J7/SystemDescriptions.html lists some ATPs
02:28:06 <zv> All of these questions are answered, and more, arguably much better but someone named Donald Knuth
02:28:21 <zv> He spent years of his life writing a whole new edition of TAOCP for this very problem
02:28:26 <int-e> (hmm, CVC4 is on that list... I guess it makes sense to take an SMT solver and extend it to an ATP)
02:28:28 <dmiles> Cyc creates proofs using several rules and facts .. from my understanding is that Coq only verififies what SAT solvers create?
02:28:32 <zv> and it's only 200 pages
02:28:55 <zv> Which SAT/SMT solvers can do as well...
02:28:58 <bollu> zv: link to bool?
02:29:08 <zv> Its Fasc 4A 6
02:29:09 <bollu> book*
02:29:40 <zv> it goes under the name: fasc6a.ps
02:30:13 <zv> you want to read right after the picture of the cute cat on a game of life board
02:30:31 <zv> it talks about how theorem provers, sat and SMT solvers use an identical procedure
02:30:38 <zv> implementation details aside
02:31:16 <zv> although i believe conflict driven clause learning can solve formulas not expressed as unsatisfied literals as well
02:31:20 <dmiles> Grr TPTP CSR (Common sense resasoning tests) do not actually test for proof gen
02:31:51 <dmiles> yes conflict driven clause learning give us the ability to reason over open world
02:31:55 <dmiles> s
02:32:04 <zv> being the well known and hip author of z3-mode, the famed SAT/SMT inferior-process interaction mode, i can tell you that no matter how you dice it, it's a nasty set of problems
02:32:47 <zv> ok, fair enough
02:32:53 <zv> induction is a famously tricky problem
02:33:15 <bollu> zv: tricky how?
02:33:22 <zv> but again, knuth explains this in the part after the cute cat picture
02:33:39 <zv> he'll also give you a cool procedure for making any picture you want from any starting position in game of life
02:33:53 <zv> which, and i can tell you this from experience, will be very impressive at parties
02:34:24 <zv> bollu: well, i mentioned the randomly restarting prolog part right?
02:34:36 <bollu> zv: yes
02:34:51 <bollu> zv: can I have a link to this intruging book?
02:35:25 <dmiles> that is funny "randomly restarting prolog" but it is the most accurate description
02:35:43 <zv> http://www-cs-faculty.stanford.edu/~knuth/fasc6a.ps.gz
02:35:53 <zv> this is the problem with kids these days
02:36:06 <zv> it took me literally 5 seconds to look up "knuths new cool shit on sat solvers"
02:36:11 <zv> again, sorry to swear
02:36:25 <zv> and then these kids writing terminal emulators and x11 whatevers
02:36:37 <zv> they made me take like 20 seconds to figure out how to copy and paste
02:36:40 <zv> anyway
02:36:53 <zv> that is his book about sat solvers and cats
02:36:53 <bollu> zv: wow, that is the *actual* name of the book
02:36:58 <bollu> I thought you were joking about the name
02:36:59 <bollu> >_<
02:37:09 <zv> i know my sat solvers dog
02:37:28 <zv> i consider myself a lesser expert on cute cat pictures
02:37:40 <zv> so as you can imagine i was first in line
02:38:14 <bollu> huh, people use postScript?
02:38:19 <bollu> I thought it was mostly latex now
02:38:25 <zv> i thought the *exact* same thing
02:38:39 <tdammers> I thought it was mostly markdown onw
02:38:49 <bollu> "A fascicle is a https://en.wiktionary.org/wiki/bundle or a https://en.wiktionary.org/wiki/cluster"
02:38:55 <bollu> tdammers: joke, yes?
02:39:02 <zv> also, it's worth noting, donald knuth is old and he's just laying this stuff down without any regard to facts or format
02:39:17 <dmiles> i havent read fasc6a.ps.gz but is it mostly just saying that the most innnovative whatnots is to decide when to restart prolkog?
02:39:19 <tdammers> bollu: about 50% serious
02:39:19 <zv> you can just collect errata checks all day off this satisfiability 'fasicle'
02:39:34 <bollu> I see
02:39:43 <zv> in fact, i had an idea that I would sell knuth checks
02:39:49 <zv> i just have some 0day knuth errata
02:39:54 <zv> and i sell them for, lets say, 1000$
02:40:12 <zv> of course, this is in the event that my plan to become a well-known open-source guru fails for z3-mode
02:40:22 <cocreature> this is getting really offtopic
02:40:30 <zv> dude, this is sat solvers
02:40:35 <zv> its not like theres #satsolvers
02:40:50 <zv> i mean, there is
02:40:58 <bollu> wait wtf, this is like the 7th chapter of a book?
02:41:18 <dmiles> i often wondered if there will ever be a satsolvers channel on irc 
02:41:48 <zv> have you gotten to the cute cat part bollu?
02:41:52 <bollu> zv: no
02:41:52 <dmiles> its certianly not #math or ##logic  or #coq or 
02:42:05 <zv> ok well its page 25
02:42:31 <bollu> huh, yes
02:42:31 <zv> i mean, just as market research
02:42:33 <bollu> got to it now
02:42:39 <zv> would any of you buy a knuth check by proxy
02:42:41 <sshine> well, there's #haskell-offtopic
02:42:54 <bollu> see, I would love to study FP all day, but this can't happen at college because we don't have enough FP at college :(
02:43:03 <bollu> plus like, real life jobs and stuff
02:43:10 <zv> please man
02:43:15 <dmiles> actualyl there is only one library in haskell towards sat solvering right?   atp-haskell ?
02:43:16 <zv> excuses excuses
02:43:33 <bollu> zv: hey, I still code Haskell whenever :)
02:44:03 <zv> oh yeah, we gotta tie this back to haskell in order to ensure channel integrity.
02:44:07 <zv> sbv or whatever is pretty good
02:44:21 <zv> i would go so far as to say it's excellent
02:44:29 <bollu> I'm trying out LiquidHaskell
02:44:45 <dmiles> thanks bookmarking https://hackage.haskell.org/package/sbv
02:46:13 <zv> no problem
02:46:26 <dmiles> haskells typesystem doesnt help such things out does it?
02:46:41 <zv> i have no idea
02:46:54 <dmiles> ( i mean or does it.. i mean make the code for these easier to maintain )
02:47:04 <zv> honestly all sat/smt solver apis are dumb
02:47:18 <dmiles> well without CDCL yes
02:47:19 <zv> except their 'fundamental' languages like dimacs or smtlib
02:47:48 <zv> i dont mean this as a riff on sat solver authors, its usually inadequacies in languages strangely enough
02:48:02 <dmiles> CDCL is something Stickel discovered in 1982 and it only now being realized as usefull
02:48:19 <zv> really? i didn't really know the history
02:48:40 <zv> are you studying automated reasoning or do you read alot?
02:48:51 <dmiles> well in 1999 i was suppsoed to write a clone of CYC since the govt was getting sick of Lenat hording the Tech
02:49:11 <zv> that is pretty cool
02:49:12 <dmiles> the secret was CDCL 
02:49:15 <zv> haha
02:49:28 <dmiles> in that i had to have real proof of negation
02:50:14 <dmiles> CDCL is merly that .. you derive a provable set of bindings (even ungroundedness) of some vars
02:50:56 <dmiles> that set is durived by proving what is impoossble but using real techniques such as modus tollens
02:51:08 <dmiles> (rather than failing)
02:52:10 <dmiles> what is neat is you can create a much larger set of CDCL bindings (can create veryting impossible) faster and easer than what is on the possitive side of provoing
02:52:27 <zv> doesn't that essentially double the search space however?
02:53:02 <obscaenvs> Having build problems on macOS Sierra since I idiotically upgraded. Connected to ‘load commands size’ https://github.com/commercialhaskell/stack/issues/2577 Does anybody have a workaround?
02:53:07 <dmiles> yes.. even quadruple it.. but it tells me way faster what would be a utile path and i optimize to create as many unbound negatives as posssble
02:53:18 <zv> i.e (x v y) == (x v y v z) && (x v y not(z))
02:53:20 <zv> or its negation
02:53:57 <zv> dmiles: who were you working for on this project?
02:54:11 <dmiles> Teknowledge
02:54:13 <bollu> obscaenvs: so I shouldn't upgrade I take it?
02:54:25 <obscaenvs> you most definitely shouldn’t.
02:54:42 <dmiles> There where other groups to like XSB prolog with Flora
02:55:11 <zv> wow
02:55:31 <zv> definitely interesting how broad the research has turned out to be
02:55:57 <dmiles> zv: i think thiough this line of reasearch is now essentually dead though
02:56:00 <bollu> damn
02:56:15 <zv> theres a lot of cool stuff yet
02:56:33 <zv> i mean, i can't speak with authority on the topic of research in automated reasoning, but the applicability is wide
02:57:06 <dmiles> i think it is only out of fear that somoen will take cycorps money and right now the FP .. hinnly milner kids are going to get exacited about Coq for a few years
02:57:10 <zv> i've found & patched countless 0days in different C code with SMT solvers
02:57:38 <zv> i think things like this are going to displace traditional static analysis
02:58:00 <zv> theres still big problems with loops and so on, but I'm to understand the problems are tractable
02:58:04 <dmiles> right yes the static analysis parts are going to be imprioved for a fe years
02:58:28 <dmiles> before we start using the syustem to recongnise cute cats again
02:58:58 <zv> haha
02:59:11 <zv> well, knuths procedure is to generate cute cats, which is even better
02:59:35 <dmiles> oh yeah.. my system was to recognise and decide how we decide
02:59:54 <dmiles> (and give a proof to why the cat might be cute)
03:00:01 <zv> so tell us young folk, what happened
03:00:06 <zv> why isnt prolog eating the world
03:00:19 <dmiles> out of fear that somoen will take cycorps money
03:00:31 <dmiles> i know that sounds silly though
03:00:33 <zv> thats a pretty far-out conspiracy, you have to admit
03:00:45 <dmiles> (i cant belive it.. i am otally confused as well)
03:01:05 <zv> well, if you are anywhere near my timezone its like 3:00
03:01:06 <dmiles> (i am totally confused as well) i just flat dont get it
03:01:07 <zv> a confusing time
03:01:15 <zv> (of day)
03:01:21 <dmiles> yeah.. 3 am here
03:01:30 <zv> sf?
03:01:30 <dmiles> someone said prolog and got my attention
03:01:36 <zv> what a coincidence
03:01:44 <dmiles> portland or
03:01:51 <zv> same difference
03:02:24 <dmiles> still i want to know why we dont have this technonology as normnal everyday
03:02:36 <zv> i'm in the same boat
03:03:02 <dmiles> whatr gets me is people i worshipped like Erik Meuoller and Roger Schank asking the same question
03:03:04 <zv> it's really quite powerful stuff, and not in like the 'hm is great' or 'look ma, no null pointer dereferences in my systems programming language'
03:03:27 <zv> like, actually, seriously, powerful stuff that is useful in the business case, to people who have no deep interest in computers
03:03:41 <dmiles> if we had this tech in the 70s why dont we have it now?
03:04:16 <zv> i don't know enough about the community to be able to comment intelligently on the direction, but of course there are successor efforts
03:04:23 <zv> swipl, mercury and so on.
03:04:35 <dmiles> Stickel's CDCL of 1982 was given up on due tyo supposedly the problem you stated zv
03:04:36 <zv> even sat/smt solvers and SQL databases are an abstract continuation of the 'dream'
03:05:04 <dmiles> (doesnt it make the search space bigger? isnt that the wrong dirrection?)
03:05:10 <zv> yeah
03:05:38 <bollu> zv: what can and can't I do with liquid haskell?
03:05:44 <zv> i have no idea
03:05:53 <dmiles> so by 1983 you could get a pD by bashing stickel i;ve read litteral 100s of papers doing only that
03:06:04 <dmiles> pD/phD
03:06:14 <bollu> dmiles: what's your line of work? academia?
03:06:14 <zv> ah, scientific progress
03:06:52 <bollu> audience of LiquidHaskell: "	•	know what forall a. a -> a means?" I chuckled
03:06:58 <dmiles> bollu: it was .. now i am a spcultive historian talking smack and not delivering what i say is easy :(
03:07:15 <bollu> dmiles: in the sense?
03:07:31 <dmiles> though here is some research into teh probelm i am doiung:  http://pastebin.com/qBAyZi58#160
03:08:02 <dmiles> god that page is too big
03:08:17 <bollu> holy fuck, I just ran LiquidHaskell through a haskell file of mine
03:08:25 <bollu> and it inferred that I was using unbounded !!
03:08:27 <dmiles> but this is an example of using STickels method
03:08:28 <bollu> this is so cool
03:08:52 <bollu> dmiles: what is that file?
03:09:26 <dmiles> its a runthru of some CYc tests i am working on making my theorem prover fast at
03:10:05 <zv> dmiles just out of interest did you ever do the prolog implementation in sicp?
03:10:26 <zv> my interest in the topic is purely amateur hour and i had one question ive been wanting to ask an expert
03:10:45 <dmiles> i keep meaing to try out sicp
03:10:54 <zv> its a cool book
03:10:58 <dmiles> i tryed upv-curry
03:11:10 <zv> i never went to college so i figured i better get a cs education
03:11:26 <zv> so i decided to do sicp instead
03:11:33 <zv> same difference, right?
03:11:52 <zv> anyway, it is a cool book
03:12:09 <zv> its got a jit implementation (loosely), lisp interpreter as i'm sure you've hear
03:12:20 <dmiles> oh there is also a impl called SICP.. i was thinking it was an impl of someothing haskell related to
03:12:39 <quchen> I’m looking for a lib to draw some primitive objects into a picture, and then possibly display it in a window or save it as PNG. Suggestions?
03:12:52 <quchen> Could also be two libraries, one for the pics and one for the window, of course.
03:14:08 <merijn> quchen: Diagrams?
03:14:10 <dmiles> oh ok it was from the same book.. https://mitpress.mit.edu/sicp/code/
03:14:23 <quchen> merijn: That’s not for drawing pixelwise, is it?
03:14:38 <quchen> More of an abstract, LaTeχ-like workflow that renders nicely
03:16:35 <dmiles> zv: so nope havent done it.. i have one prolgo i like a lot
03:17:44 <dmiles> https://github.com/TeamSPoon/PrologMUD/blob/development/pack/logicmoo_nlu/prolog/e2c/cb-pttp.lisp  :) 
03:18:23 <dmiles> it doesnt keep binding in vars.. it keeps them in an array
03:19:13 <dmiles> usiually to keep them in vars a person makes more and more call stack
03:20:22 <dmiles> probly nothing wrong with more and more call stack its just neat to see several impls
03:21:59 <dmiles> qv .. it's late but going to keep your nick on my notify list
03:22:33 <dmiles> erm zv 
03:22:36 <zv> i'm here
03:22:40 * hackagebot tidal 0.8.2 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.8.2 (AlexMcLean)
03:22:42 * hackagebot language-puppet 1.3.2 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3.2 (SimonMarechal)
03:22:44 * hackagebot http-pony-transformer-case-insensitive 0.1.0.1 -   https://hackage.haskell.org/package/http-pony-transformer-case-insensitive-0.1.0.1 (JinjingWang)
03:22:46 * hackagebot http-pony-serve-wai 0.1.0.1 - Serve a WAI application with http-pony  https://hackage.haskell.org/package/http-pony-serve-wai-0.1.0.1 (JinjingWang)
03:23:02 <zv> take it easy dmiles, i gotta catch some zzz
03:23:09 <zv> and maybe some mst3k
03:23:15 <dmiles> yep.. till we meet again
04:15:33 <bonhoeffer> recommended way to learn haskell for an experienced programmer?
04:16:14 <bonhoeffer> without a lot of functional programming . . . I'm mostly a Julia, Matlab, Python, Ruby guy
04:19:44 <absence> bonhoeffer: realise that your experience might not help you, and might even hold you back, because it's a bit like starting from scratch (at least it was for me coming from c++ etc). the learn you a haskell book is a nice intro imho
04:19:58 <absence> @lyah
04:19:58 <lambdabot> Unknown command, try @list
04:20:07 <bonhoeffer> ok -- absence got it -- i was looking at that book
04:20:08 <absence> oh
04:20:15 <bonhoeffer> funny enough, that is why i want to learn it
04:20:25 <bonhoeffer> i know i can't think that way right now
04:20:25 <absence> cool :)
04:21:08 <absence> what worked for me was porting existing (simple!) utils i had written to haskell
04:27:59 <qaisjp> yulax, smh
04:28:33 <dd_> what is haskell
04:30:02 <srhb> dd_: A general purpose programming language.
04:30:08 <srhb> dd_: Check haskell.org for instance :)
04:30:45 <dd_> ok, thanks
04:33:24 <nathyong> does anybody know of any papers regarding a modern implementation of a graph reduction machine like the STG, but possibly with a function application spine?
04:33:31 <nathyong> I'm curious to know about alternative functional language implementations
04:34:16 <merijn> nathyong: That's the sort of question that'd do better on the mailing lists
04:34:46 <nathyong> merijn: is there one I should be subscribed to? It seems a bit out of scope for haskell-cafe
04:35:26 <srhb> nathyong: I think haskell-cafe has a pretty broad range, I think you'd get responses :)
04:36:06 <nathyong> cool
04:36:14 <merijn> nathyong: haskell-cafe is for "everything haskell related", I'd consider it on-topic
04:37:35 <nathyong> merijn: srhb: thanks for the heads up
04:47:05 <yulax> hi folks
04:47:14 <yulax> i'm just starting out with haskell
04:47:24 <srhb> yulax: Hi there.
04:47:41 <yulax> and, i wonder, why when i start ghci, the prompt is called prelude> as opposed to ghci as in the book?
04:47:56 <yulax> to clarify, im using "learn you a haskell" to learn
04:47:59 <srhb> yulax: Which book? But yes, it's the default prompt, the Prelude module (the default import)
04:48:05 <yulax> ah right
04:48:10 <yulax> thanks!
04:48:24 <srhb> yulax: Try typing "import Data.List"
04:48:25 <kamog> yulax: you can change it by :set prompt "ghci> "
04:48:49 <srhb> yulax: You should see it update to refer to the modules that are imported. I find the feature mostly useless, but there you go... :-)
04:49:44 <yulax> thank you
04:50:17 <yulax> i've set it to "n00b> " xD
04:51:48 <srhb> yulax: You can actually do a lot of fun things with the prompt, so yeah, it's fun to customize. :-)
04:52:57 <yulax> yea
04:53:09 <yulax> just playing around with it for now
04:53:10 <buglebudabey> my friend had a lambda as the prompt which was pretty cool
04:53:38 <yulax> so they set it to "-> "?
04:54:15 <fabiopbx> i use " λ " 
04:54:16 <fabiopbx> :D
04:54:37 <yulax> ah
04:55:04 <fabiopbx> lamba :)
04:55:14 <fabiopbx> lambda *
04:55:15 <fabiopbx> lol
04:55:35 <yulax> i remember there was some question i read about lambda operations in certain languages. naturally you can't easily type a lambda symbol, so they use -> .... i think it might have been c# 
04:55:47 <yulax> or maybe im totally off :-)
04:55:50 <jmcarthur> In Haskell it's \
04:55:58 <quchen> nathyong: edwardk mentioned something at ZuriHac for his TurboHaskell compiler
04:56:11 <quchen> I think he should have good suggestions regarding non-STG implementations
04:56:26 <srhb> quchen: Is that a play on people mishearing Haskell as Pascal? :P
04:56:29 <srhb> If so it's hilarious
04:56:46 <quchen> srhb: He’s fully aware of that, yes :-D
04:56:49 <srhb> :D
04:56:54 <nathyong> TurboHaskell, a corporate functional language for the 21st century
04:57:13 <nathyong> how should I get in touch with him?
04:57:28 <srhb> nathyong: Goat's blood and a pentagram. Or email, perhaps.
04:57:52 <Cale> edwardk: ^^
04:59:45 <nathyong> alrighty, I'll send him an email then
05:00:31 <merijn> Or just IRC, considering he's like always here even when he should be sleeping...
05:00:45 <merijn> Or just IRC, considering he's like always here even when he should be sleeping... ;)
05:00:49 * quchen nick-completed him earlier.
05:00:56 <quchen> So he’s here.
05:01:55 <nathyong> I shall wait patiently..
05:02:43 <cocreature> there is a repo or it https://github.com/ekmett/thc but I don’t think it’s anywhere near being usable
05:05:46 <nathyong> I'm reading the readme/docs now
05:12:45 <yulax> just a point on style, the LYAH book has spaces eveywhere, e.g. "y * 2" as opposed to "y*2". is it best practice to use spaces so liberally?
05:13:26 <nathyong> yulax: the style guides out there suggest using spaces
05:13:37 <cocreature> yulax: I would say so (based on the code I’ve seen and my own opinion)
05:14:01 <nathyong> I agree that it might be overkill for mathematics only
05:14:40 <nathyong> but for everywhere else, Haskell's symbol density is so high that you'll want spaces
05:15:55 <tdammers> there's also the edge case of ., which is an operator with spaces around it, but a namespace separator without them
05:16:20 <tdammers> i.e., Foo . bar means "compose the constructor Foo with the function bar", but Foo.bar means "the bar variable from the Foo module namespace"
05:16:26 <yulax> ok
05:16:29 <merijn> tdammers: It's only a namespace separator if the prefix starts with a capital letter
05:16:37 <tdammers> merijn: still an edge case
05:16:50 <tdammers> merijn: actually, that's even worse IMO
05:17:06 <tdammers> so basically, if you always put spaces around operators, you naturally avoid this edge case
05:17:09 <yulax> when i write python i'm lazy and don't bother using spaces so much as it makes the code look bloated
05:17:43 <tdammers> I think pep8 also suggests spaces around operators, but not around the = in named arguments and argument defaults
05:19:31 <cocreature> yulax: well being lazy is also an excuse in haskell. after all haskell is all about lazyness :)
05:20:00 <yulax> heheheh
05:20:00 <tdammers> I add random spaces into my Haskell source to make up for the conciseness of the language
05:20:00 <quchen> Haskell is about non-strictness.
05:20:10 <cocreature> stop ruining by stupid jokes
05:20:26 <tdammers> Haskell is about defaulting to non-strict evaluation.
05:20:52 <quchen> Non-strictness is not an option you can choose a default for.
05:21:05 <quchen> Laziness is a default choice for implementing non-strict semantics.
05:21:11 <tdammers> :)
05:21:23 <quchen> There are other defaults. But laziness is the default default.
05:21:50 <tdammers> there are other defaults, but this one is mine.
05:36:31 <maerwald> is there anything in haskell or related DSLs wrt a security type system?
05:36:36 <yangit11> is there any introduction to this ?
05:37:14 <nathyong> yangit11: what's "this"?
05:37:30 <srhb> yangit11: IRC? :-)
05:37:37 <yangit11> first time using IRC
05:38:00 <srhb> yangit11: I'm sure you can find a tutorial if you want to know more about the basics, but really, just ask your Haskell question :-)
05:38:01 <yangit11> yes, it looks like a chat room?
05:38:06 <srhb> yangit11: if someone can help you, they will.
05:38:09 <srhb> yangit11: That's right.
05:38:31 <srhb> yangit11: (About the Haskell programming language, specifically.
05:38:44 <yangit11> ok, sure
05:44:56 <merijn> maerwald: Can you be more specific about what you mean by "security type system"?
05:45:47 <int-e> what is the etymology of the "telescopes" in the system FC semantics?
05:47:16 <joncol> Can someone explain the Data.Default typeclass? What's it for? How does it work?
05:48:27 <lyxia> joncol: you use it to have a default value
05:48:37 <lyxia> joncol: notably for configuration records
05:49:32 <merijn> int-e: Because you "zoom in" on a piece of data
05:49:40 <merijn> int-e: So, similar to the etymology of lens :)
05:49:58 <merijn> int-e: Actually, I think it was "expanding" too
05:50:15 <merijn> int-e: Like, every bit you inspect allow you to extend the foldable telescope a bit more
05:50:38 <the_2nd> When writing a validator, which approach should I take : http://lpaste.net/207352
05:50:47 <merijn> pigworker discusses the etymology a bit in his thesis, I think
05:50:48 <maerwald> merijn: https://en.wikipedia.org/wiki/Security_type_system
05:50:51 <lyxia> If you have data BigRecord = BigRecord { a :: A, b :: B, ..., z :: Z }, and it is an instance of default, you can define a custom record overriding only one or a couple of fields as def { x = myX }
05:50:52 <merijn> I forgot who invented them
05:51:29 <merijn> lyxia: You can do that without being a default instance too
05:51:34 <lyxia> indeed
05:51:45 <int-e> mcbride... ok.
05:51:48 <merijn> lyxia: Just define "myDefault = BigRecord { ...}" and use "myDefault { x = myX }"
05:52:03 <Cale> int-e: I don't know, but that's a common term for similar things in other dependently typed systems
05:52:13 <merijn> int-e: I thought it was either Barendregt or De Bruijn who invented them. One of the famous Dutch FP guys at any rate
05:52:16 <Cale> int-e: Well, I sort of know what it's an allusion to
05:53:03 <joncol> lyxia: The docs only say "class Default a where", so does that mean there are no functions defined for the typeclass?
05:53:36 <merijn> joncol: "class Default a where def :: a" <- that's it
05:53:43 <merijn> But I don't like Default
05:53:57 <merijn> It has no laws or sane way too reason about what the defaults will be
05:55:23 <int-e> Thanks! McBride attributes the term to De Bruijn.
05:55:25 <Cale> You're meant to think of the shape of a collapsing telescope, which makes a certain amount of sense with regard to the way that variables introduced earlier in the context scope over the remainder of the context to the right.
05:56:39 <Cale> Speaking of telescopes, it would be really cool if there were a database where your rows were effectively telescopes, with the types of the later columns depending on the values of the earlier ones.
05:57:15 <merijn> Cale: So...dependent sums as rows? :p
05:57:24 <Cale> yeah, nested dependent sums
06:03:57 <zipper> Hey is ReinH here?
06:04:23 <the_2nd> ReinH : yeah zipper, what's up?
06:04:54 <zipper> Ok uh I saw your tweeet and tried to ask you the question but couldn't do it in 140 chars.
06:05:08 <zipper> "Finished Hutton’s new edition of Programming in Haskell, can wholeheartedly recommend to folks interested in learning the language."
06:05:19 <zipper> What if one needs a refresher on Haskell.
06:05:56 <zipper> Parts I need to brush up on are the type system, the runtime, compiler and category theory ?
06:06:01 <zipper> the_2nd: ^
06:08:56 <the_2nd> zipper, some decent resources : https://en.wikibooks.org/wiki/Haskell  http://learnyouahaskell.com/   http://dev.stephendiehl.com/hask/ 
06:09:05 <the_2nd> and maybe check out some irc guide / tutorial
06:09:48 <buglebudabey> Cale sounds similar to a CNN using relu functions
06:12:21 * ski looks at yangit11
06:22:45 * hackagebot jose-jwt 0.7.1 - JSON Object Signing and Encryption Library  https://hackage.haskell.org/package/jose-jwt-0.7.1 (LukeTaylor)
06:22:47 * hackagebot lackey 0.4.1 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-0.4.1 (fozworth)
06:22:49 * hackagebot http-pony-serve-wai 0.1.0.2 - Serve a WAI application with http-pony  https://hackage.haskell.org/package/http-pony-serve-wai-0.1.0.2 (JinjingWang)
06:26:14 <the_2nd> how can I make -Werror ignore deprecated warnings?
06:27:22 <cocreature> the_2nd: you can pass -Wno-deprecated-flags to completely disable deprecated warnings. I don’t think you can enable Werror and turn specific warnings not into errors
06:28:09 <the_2nd> cocreature, that will do, thanks
06:30:34 <mlmdfnio> What's an elegant way of selecting n random items from a list?
06:30:36 <the_2nd> cocreature, same for -Wpartial-type-signatures
06:30:46 <liste> mlmdfnio: shuffling the list and taking the first n
06:30:56 <liste> mlmdfnio: lazily, ofc
06:31:13 <mlmdfnio> liste: that seems like it would have a lot of overhead for large lists and small n?
06:31:35 <liste> mlmdfnio: laziness means that it's shuffled only just enough to take those nb
06:31:36 <liste> n*
06:32:30 <mlmdfnio> liste: so how would you do the shuffle?
06:32:42 <lyxia> take the first n elements. It's random, only with a stupid distribution.
06:33:07 <mlmdfnio> lol
06:33:46 <mlmdfnio> I think I found an explanation: https://wiki.haskell.org/Random_shuffle
06:34:37 <lyxia> if you know the length of the list, and you want a uniform distribution over all choices, you can do something based on Pascal's rule https://en.wikipedia.org/wiki/Pascal's_rule
06:34:48 <Clint> @hackage random-shuffle
06:34:48 <lambdabot> http://hackage.haskell.org/package/random-shuffle
06:35:18 <lyxia> that rule gives you a way to index the set of subsets of a set with natural numbers
06:35:39 <lyxia> *subsets of a fixed size
06:46:38 <rdesfo[m]> http://lpaste.net/207426
06:50:51 <lpaste> lyxia annotated “Haste.Ajax” with “Haste.Ajax (annotation) (rdesfo[m])” at http://lpaste.net/207426#a207433
06:56:32 <shane`> Can I create a pipe that makes pairs out elements: for instance, it should consume a, b, c, etc and output (a, b), (b, c), etc...A naive recursion implementation may give trouble when the pipe is empty right?
06:56:56 <rdesfo[m]> Clint (IRC): @lyxia thanks
06:57:29 <tsahyt> anyone here who knows AFRP and ideally has tried the wires library?
06:59:49 <nathyong> shane`: by pipe do you mean "function/combinator" or actually the Pipes library?
07:00:13 <shane`> nathyong: The pipes library
07:00:31 <nathyong> ah, I'm not familiar with that unfortunately
07:01:17 <shane`> Oh ok thanks anyway
07:03:31 <lyxia> shane`: pipes doesn't handle termination very well, does it?
07:04:24 <shane`> i am new to it myself, but from what I understand it does not, unless one uses pipes-parse but I am wondering if i can avoid using that.
07:10:39 <clueless> can someone help me with this script? adding the sum of the last four elements in an list to the head
07:11:15 <clueless> [1 2 3 4] -> [10 1 2 3 4]
07:11:52 <dominik> clueless: checkout the sum function and list's cons operator :
07:13:52 <michi7x7> > let f xs@(x:_) = (sum xs) : xs in f [1..4]
07:13:54 <lambdabot>  [10,1,2,3,4]
07:15:14 <michi7x7> hmmm...
07:15:16 <Eliel> > (sum [1..4]) : [1..4]
07:15:19 <lambdabot>  [10,1,2,3,4]
07:15:22 <michi7x7> yeah
07:15:28 <Eliel> mayhaps easier to understand this way :)
07:15:41 <ski> michi7x7 : no need to insist the list has at least one element (`x')
07:15:55 <michi7x7> ski: i first thought he wanted to replace the first element
07:16:00 <ski> (also, redundant brackets)
07:16:00 <ski> ok
07:16:09 <michi7x7> > let f xs = sum xs : xs in f [1..4]
07:16:12 <lambdabot>  [10,1,2,3,4]
07:17:10 <ski> > (((:) . sum) `ap` id) [1 .. 4]
07:17:12 <lambdabot>  [10,1,2,3,4]
07:20:46 <ongy> shouldn't it be last four?
07:20:48 <clueless> michi7x7: what if the list is longer than 4? reversing it?
07:21:02 <ongy> > (((:) . sum) `ap` id . take 4 . reverse) [1 .. 5]
07:21:04 <lambdabot>  error:
07:21:04 <lambdabot>      Precedence parsing error
07:21:04 <lambdabot>          cannot mix ‘ap’ [infixl 9] and ‘.’ [infixr 9] in the same infix expr...
07:21:37 <michi7x7> > let f xs = sum xs : xs in f [1..10]
07:21:39 <lambdabot>  [55,1,2,3,4,5,6,7,8,9,10]
07:21:43 <michi7x7> clueless: ^ ??
07:21:55 <michi7x7> ah, the last 4 elements
07:22:46 * hackagebot linode-v4 0.1.0.4 - Haskell wrapper for the Linode v4 API  https://hackage.haskell.org/package/linode-v4-0.1.0.4 (eatonphil)
07:22:49 * hackagebot hOpenPGP 2.5.4 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.5.4 (ClintAdams)
07:22:51 * hackagebot pontarius-xmpp 0.5.3 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.5.3 (PhilippBalzarek)
07:24:33 <michi7x7> > let f xs = (sum . take 4 . reverse) xs : xs in f [1..10]
07:24:36 <lambdabot>  [34,1,2,3,4,5,6,7,8,9,10]
07:25:51 <michi7x7> @pl \xs -> (sum . take 4 . reverse) xs : xs
07:25:51 <lambdabot> (:) =<< sum . take 4 . reverse
07:26:56 <three3> hi ..i am new to IRC and need some help with the 'LIST' command
07:27:26 <three3> once connected to a network i want to get a list of all the channles with 500 or more users
07:27:44 <three3> the command I am using is /list -min 500
07:28:01 <three3> but it is returning me all the channles
07:28:14 <glguy> three3: wrong channel
07:28:56 <three3> @gl_guy which will be the right channel
07:28:57 <lambdabot> Unknown command, try @list
07:30:29 <clueless> http://lpaste.net/204489 sorry for the dumb question Im new with the syntax
07:30:48 <clueless> why is this an error?
07:31:22 <glguy> clueless: It'll help us to guess if you include the generated error message
07:31:53 <three3> ?
07:32:12 <three3> glguy: what will be right channel for my query?
07:32:20 <jomg> clueless, the type is too general
07:32:39 <jomg> you use sum, so you need to constrain the type parameter a to Num
07:33:07 <ltbs> anyone had any luck getting stack/emacs/nixos to all play nice together? 
07:35:14 <clueless> jomg: [Num] -> [Num]?
07:35:31 <VitorCBSB> clueless: Num a => [a] -> [a]
07:35:32 <jomg> clueless, it would be Num a => [a] -> [a]
07:35:36 <jomg> dang :P
07:35:48 <VitorCBSB> :)
07:36:35 <glguy> ?tell Axman6 docs fixed http://hackage.haskell.org/package/foldl-statistics
07:36:35 <lambdabot> Consider it noted.
07:36:45 <nathyong> :t \xs -> (sum . take 4 . reverse) xs : xs
07:36:45 <mizu_no_oto_work> :t \xs -> (sum . take 4 . reverse) xs : xs 
07:36:49 <lambdabot> Num a => [a] -> [a]
07:36:49 <lambdabot> Num a => [a] -> [a]
07:36:51 <nathyong> whoa there
07:37:03 <mizu_no_oto_work> hah
07:37:09 <glguy> photo finish: nathyong by a nose
07:37:32 <nathyong> clueless: if you remove the type signature, your compiler can infer the type for you a lot of the time (but it's good practice to include it in)
07:37:47 <nathyong> or you could write sumOf4 :: _
07:37:59 <nathyong> doing so will cause GHC to throw an error and tell you the actual signature
07:38:05 <nathyong> (that it has inferred)
07:41:12 <ltbs> Couldn't you generalise further? Why a Num? Isn't 'a' a semigroup? 
07:41:38 <ertesx> ltbs: monoid
07:42:02 <jomg> ltbs, well you could replace sum by something more general
07:42:10 <jomg> but the function as written only generalizes to Num
07:42:13 <clueless> thank you both!
07:43:17 <ltbs> ertesx, why does it have to be a monoid? 
07:43:37 <ertesx> ltbs: what if xs == []?
07:43:53 <ltbs> then how would you take the last 4 elements of it?
07:44:05 <jomg> take will just return [] in that case
07:44:07 <ertesx> > take 4 (reverse [])
07:44:11 <lambdabot>  []
07:44:28 <munja>  /quit
07:48:05 <ertesx> clueless: BTW, this function will become horribly inefficient very quickly as the argument list grows in both time (because you're using lists) and space (because you're using 'reverse')
07:48:16 <ltbs> but that's the details of how 'take' works in haskell, not the original question by clueless. 
07:51:45 <mettekou> Pattern matching on values of a type which is otherwise contained in its own module seems to violate data abstraction. Is there a way to tackle this problem without implementing a folding function?
07:53:35 <ertesx> mettekou: would pattern synonyms be an option?
07:55:53 <ertes> mettekou: alternatively you can export *some* constructors while keeping others hidden, but i'd consider that bad style (one could make the mistake to assume that the exported constructors are complete)
07:58:00 <mettekou> ertes: I don't think pattern synonyms would help me much, but I'll look into them.
08:06:05 <ltbs> Anyone seen this error before? "Suspicious state from syntax checker haskell-stack-ghc: Checker haskell-stack-ghc returned non-zero exit code 1, but no errors from output: <command line>: cannot satisfy -package hspec"
08:06:23 <ltbs> I'm trying to get emacs working with stack and nix.
08:06:48 <ltbs> Project is more or less a stock yesod-sqlite
08:07:14 <ltbs> I've added hspec as a dependency in stack.yaml
08:07:25 <ltbs> and enabled nix
08:08:27 <grantwu> Have you tried intero?
08:09:20 <ltbs> no, I've not. Would you recommend it?
08:09:51 <grantwu> I haven't really used it, but it appears to at least do the emacs + stack/haskell thing right
08:10:05 <grantwu> Could? save you some effort, but ymmv
08:11:30 <ltbs> Thanks. I'll give it a go. I think I might give up on using stack with nix for the moment if necessary too. 
08:11:57 <sm> intero is great
08:15:02 <ltbs> Actually from the description intero does look like it does everything I need. I'll give it a go. Thanks guys. 
08:22:48 * hackagebot servant-purescript 0.5.0.0 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.5.0.0 (eskimo)
08:32:54 <bollu> {-@ die :: {v:String | false} -> a  @-}
08:33:01 <bollu> that has got to be the most elegant thing I've seen today
08:33:02 <bollu> so cool
08:33:12 <bollu> LiquidHaskell feels like I'm learning Haskell all over again!
08:33:18 <bollu> the whole "omg this idea is so cool" feeling
08:33:25 <bollu> I just wanted to gush :)
08:35:10 <bollu> does the Prelude come with some way to "unit test"?
08:35:18 <bollu> I'm writing a literate haskell file for people new to haskell
08:35:23 <bollu> I want it to contain assertions
08:35:33 <bollu> and, like, undefined functions that they're supposed to fill
08:35:43 <bollu> don't want them to cabal-install anything yet
08:35:49 <bollu> is there anything in Prelude that would do this for me?
08:37:15 <hpc> do you want it to be like if it doesn't pass the tests it doesn't compile?
08:38:16 <Cale> bollu: The Prelude certainly doesn't but there are a lot of different test frameworks out there to try
08:38:19 <hpc> a cheeky way to do it might be another .hs file that imports what the student edits, with some TH that fails in the Q monad if the "unit tests" don't match
08:38:33 <Cale> hah
08:39:18 <bollu> hpc: there's a Q monad? teach me :)
08:39:21 <bollu> hpc: yes, ideally
08:39:31 <bollu> Cale: yes, I use QuickCheck
08:39:34 <bollu> Cale: and tasty
08:39:35 <hpc> Q is where template haskell executes
08:39:46 <hpc> in some sense it's the compile-time version of runtime's IO
08:39:46 <sm> bollu: doctest is a nice lightweight one
08:39:50 <bollu> Cale: but like I said, I don't want them to have to deal with <cabal install> or <stack init> right now :)
08:40:13 <bollu> Cale: I'm teaching a group of linguistic profs at college. I pitched Haskell hard when they were looking for a functional programming language :]
08:40:16 <hpc> for your purposes you likely just need (return ()), (>>), and fail
08:40:19 <bollu> I'm setting exercises
08:40:24 <bollu> hpc: I see, interesting
08:40:26 <bollu> hpc: link, please?
08:40:31 <bollu> hpc: to documentation?
08:40:40 <hpc> search for "template haskell"
08:40:47 <bollu> Cale: I feel almost like some sort of evangelist >_>
08:51:18 <danza> bollu, tech corporates use that term without concern
08:51:42 <bollu> danza: :)
08:53:13 <pavonia> IIRC, there was a package that was meant to be an enhancement of blaze-html. Anyone knows it's name?
08:53:38 <glguy> lucid was in the same space I don't know if it's what you wanted or if it's an enchancement
08:56:11 <glguy> Can one detect that a Haskell module is being loaded by GHCi in interpreted mode with CPP?
08:56:53 <pavonia> Hhm, maybe. I recall reading an article kind of ranting about blaze-html and listing the features of that package doing it better thatn blaze-html
08:58:01 <Cale> bollu: I've always been a bit divided on whether to promote the language. I almost invariably end up doing so, but there are a fair number of ways in which Haskell benefited from keeping a small userbase for so many years -- at this point though, that's pretty much over.
08:58:41 <bollu> Cale: hm, what do you think are the advantages of a small community? tight-knit? share the philosophy?
08:59:11 <Cale> The ability for the language to change and not have thousands of users complaining about their giant codebases breaking.
09:00:10 <ltbs> A smaller userbase make it easier to resist the "lets make it enterprise" push, too. 
09:00:20 <Cale> ...and yeah, I'm sure it's also seen a lot of benefit from the fact that most Haskell users have been people who were generally interested in programming languages to begin with.
09:01:55 <Cale> bollu: The more popular a language or library gets, the harder it becomes to do much of anything about its flaws, short of starting over.
09:02:39 <Cale> The biggest problems Haskell has, we're just stuck with, pretty much, short of jumping off to something new.
09:03:36 <Cale> e.g. It wasn't really designed to be dependently typed from the outset, and while extensions can get you some of that flavour, it's pretty awkward to actually use it like that.
09:04:09 <ltbs> Cale: Do you think Haskell users will start to leave for Idris, then? 
09:04:57 <bollu> Cale: good point
09:05:05 <bollu> Cale: I have two pet problems: numbers and recoreds
09:05:06 <x1f577> can one use persistent without being forced to define data types in quasi quotes? what if i'd like to use my own data type that's defined the usual way?
09:05:07 <bollu> records*
09:05:08 <Cale> Well, Idris isn't quite the thing I want to leave for
09:05:51 <Cale> But some lazy-by-default dependently typed language with proper coherent type classes...
09:06:06 <bollu> Cale: is lazy really that attractive to you?
09:06:09 <Cale> yes.
09:07:17 <bollu> Cale: why? The only place where I feel it truly impacts me is 1. defining infinite structures, 2. list comprehensions are nice, 3. mutual recursion. What else do you like laziness for
09:07:33 <Cale> It gives you more ways to decompose problems into parts.
09:07:46 <bollu> Cale: but you can imitate laziness in a strict language
09:07:54 <bollu> thunk = \_ -> computation
09:08:00 <bollu> right
09:08:01 <bollu> ?
09:08:08 <glguy> No, that doesn't save the result back into the thunk
09:08:08 <Cale> Laziness only works at all if you have libraries full of things which are lazy.
09:08:14 <Cale> and yeah, that's not the same
09:08:25 <bollu> glguy: ahh
09:08:41 <bollu> Cale: example of a case where laziness truly helps?
09:09:01 <EvanR> also if you tried stuff like that in something like js, youll see that lambda wrappers around everything sucks royal ass
09:09:34 <Cale> There's an old paper...
09:09:39 <bollu> EvanR: true, but es6 notation is very lightweight IMO () => { ..}
09:09:45 <Cale> https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
09:09:49 <EvanR> uh...
09:09:59 <Cale> ^^ should really be called "Why *lazy* functional programming matters"
09:10:06 <EvanR> just having to put () everywhere is bad enough
09:10:08 <bollu> Cale: heh, I've read it
09:10:12 <EvanR> f()()()()
09:10:54 <EvanR> bollu: when writing algorithms, ime its usually easier to get decent performance by assuming laziness rather than eagerness
09:11:08 <Cale> bollu: In strict-by-default settings, you can be required to generate structures in the same code that processes them, because those data structures would otherwise be infinite or combinatorially large, and you don't have space to store them.
09:11:18 <EvanR> you have to do handstands to get eager to not do things in the wrong order
09:11:51 <EvanR> the accumulating parameter pattern
09:12:06 <bollu> ahh, I see
09:12:09 <Cale> Actually, here's a stupid example -- it's not really a good example because there are better ways to solve this problem entirely, but bear with me
09:12:12 <bollu> that's a very cool way to think of laziness
09:12:14 <bollu> sure
09:12:23 <Cale> Consider writing  isInfixOf
09:12:57 <Cale> It takes a pair of lists, needle and haystack, and tries to determine if needle occurs as a substring of haystack somewhere
09:13:09 <bollu> Cale: sure
09:13:24 <bollu> caasih: most optimal way to do this is to build the Knoth morris state machine right?
09:13:27 <bollu> Cale: ^
09:13:40 <Cale> Yeah, KMP is a smart way to do it
09:13:59 <mannny> http://efukt.com/21636_Feminist_Dike_VS_The_Patriarchy.html  "Feminazi landwhale beaches herself on the set of FaceFucking.com and shares her bloated-ass thoughts on sex, feminism and society."
09:14:09 --- mode: ChanServ set +o glguy
09:14:09 --- mode: glguy set +b *!*@50-73-172-4-pennsylvania.hfc.comcastbusiness.net
09:14:09 --- kick: mannny was kicked by glguy (mannny)
09:14:15 <bollu> mannny: uhh wrong channel?
09:14:19 <bollu> what was that about
09:14:26 <glguy> kindly ignore spammers
09:14:27 <Cale> random spammer
09:14:34 <Cale> But let's just think about how you do this the dumb way (because it's the kind of problem which illustrates the thing I'm trying to get at)
09:15:08 <Cale> You can imagine that in many other cases, you wouldn't be able to take advantage of the finer detail of the problem in the way that KMP does
09:15:31 <Cale> So, in an imperative setting, what you'd normally write is a pair of nested loops
09:15:38 <bollu> yes, right
09:15:51 <Cale> and you might have some early return for when you've found the string
09:16:14 <Cale> The structure in a strict functional language isn't much different from that, only you probably use recursion
09:16:15 <bollu> right
09:16:36 <Cale> You can't really break the problem down into smaller useful parts too well there
09:16:45 --- mode: glguy set -o glguy
09:17:04 <Cale> In Haskell, we get to write something like  any (isPrefixOf needle) (tails haystack)
09:17:23 <bollu> Cale: hmm
09:17:24 <Cale> tails is cheaper than it looks, because the list of tails is computed lazily
09:17:33 <bollu> Cale: but that's more because of having higher order functions, right?
09:17:37 <Cale> no
09:17:54 <Cale> well, okay, also consider
09:18:01 <Cale> I'll make this look even worse :)
09:18:10 <Cale> or (map (isPrefixOf needle) (tails haystack))
09:18:24 <Cale> after all, any p = or . map p in Haskell
09:18:42 <bollu> Cale: right
09:19:01 <Cale> Do we really want to compute whether the string is a prefix of every one of the tails? What if we find it right at the beginning?
09:19:21 <Cale> Laziness makes it so we don't have to worry about that.
09:19:33 <Cale> and so it becomes reasonable to write this decomposition as is
09:21:10 <EvanR> yeah a lot of "dumb ways of doing it" become ok ways by default
09:21:44 <bollu> Cale: go on
09:21:45 <Cale> This ability to have data structures which represent things you might want to try in the future is sort of key to how we think as lazy functional programmers.
09:21:56 <Cale> Lists are loops that are waiting to happen.
09:22:10 <EvanR> first class loops
09:22:25 <Cale> Yeah, that we can manipulate with higher order functions
09:22:39 <Cale> rather than sticking some logic into the loop body
09:22:49 <Cale> we get to stick something *outside* which transforms it
09:23:07 <EvanR> would be nice to save and restore such things
09:23:14 <Cale> and that makes all the difference, because it means we get to pull that outside part off into its own definition
09:23:33 <bollu> Cale: so like, recursion-schemes
09:24:45 <Cale> bollu: Yeah, our data structures are partially encoding how we intend to recurse, and in the case of tree structures especially, we may later choose to ignore various subtrees
09:25:00 <Cale> (with lists, that just means we may choose to stop early)
09:25:04 <bollu> Cale: right
09:25:09 <bollu> Cale: in some sense, aren't we encoding Y?
09:25:26 <Cale> and that lets us factor out the part which generates our space of options from the part which decides how to search it cleanly
09:25:35 <abc_> http://lpaste.net/207605 input number and list and return sum of list from 0-number .. any feedback? just learning haskell
09:26:30 <Cale> Guest32109: length is expensive to compute -- it walks down the entire list you give it. Generally you'd rather only apply it as a last resort.
09:26:57 <Cale> What are you trying to compute? The sum of the first x elements of the list?
09:27:24 <Cale> (oh boy, we get to illustrate lazy evaluation again ;)
09:27:49 <Guest32109> Cale: I see.. yeah thats basically it, if if x is greater than length ill return the sum and if list is null it returns 0
09:27:50 <bollu> Cale: category theory question
09:28:03 <bollu> why is CCC equivalent to lambda calculus? I know the folklore but I don't know the proof
09:28:58 <Cale> bollu: Do you have a copy of Awodey's book?
09:29:08 <Cale> It contains a pretty nice presentation of that
09:29:11 <bollu> Cale: nada.
09:29:19 <EvanR> the cartesian closure adjunction
09:29:29 <bollu> Cale: I would up analysis-paralysis ing on category theory book and wound up not picking any up
09:29:44 <bollu> EvanR: you get an adjunction between..?
09:30:11 <EvanR> (A,B) -> C and A -> (B -> C)
09:30:27 <bollu> EvanR: that is just curry
09:30:29 <bollu> or uncurry
09:30:33 <EvanR> right
09:30:33 <bollu> I forget which is which :)
09:30:58 <bollu> EvanR: so it is an adjunction from the category to itself?
09:31:01 <EvanR> by itself its probably not enough to make something equivalent to LC
09:31:11 <EvanR> an adjunction is between two functors
09:31:24 <Cale> bollu: You can interpret terms in the simply typed lambda calculus as arrows between appropriate objects in a CCC
09:31:39 <Cale> basically
09:31:45 <bollu> Cale: wait, terms get mapped to arrows? so what are the objects?
09:32:22 <Cale> The interpretations of types
09:32:30 <Cale> (really type contexts, but who's counting?)
09:33:18 <EvanR> types are objects, and the cool thing about STLC is there are function types / objects
09:34:29 <Cale> i.e. to each type, you associate some object in the category, and pair types correspond to products, the unit type corresponds to the terminal object, and function types correspond to exponentials
09:34:50 <bollu> Cale: no initial object?
09:34:55 <Cale> Not necessarily
09:34:59 <Cale> CCCs might not have one
09:35:44 <Cale> CCC = terminal object and products and exponentials
09:35:48 <bollu> I see
09:35:58 <bollu> Cale: which chapter of awodey has the correspondence?
09:36:23 <Cale> 6: Exponentials
09:36:32 <Cale> 6.6 is about lambda calculus specifically
09:36:45 <bollu> hmm, I don't know pullbacks
09:36:51 <bollu> it's the limit of some diagram IIRC
09:37:03 <bollu> A -> B <- C? no, that's equalizer
09:37:18 <Cale> No, that's right.
09:37:33 <Cale> Equalizer is with two parallel arrows
09:37:37 <bollu> ahh, riht
09:37:38 <bollu> right*
09:37:55 <bollu> Cale: it's nice how cute limits are
09:38:11 <bollu> Cale: I think they're the nicest idea I've seen in category theory so far
09:38:13 <Cale> A pullback is like a combination of an equalizer and a product.
09:39:36 <Cale> e.g. in the category of sets, if we have f: A -> C and g: B -> C, then we can get a pullback along the diagram A -> C <- B consisting of the set of pairs (a,b) such that f(a) = g(b), together with the obvious projection maps to A and B
09:40:58 <bollu> ah, interesting
09:41:20 <EvanR> is this sort of like a section or a retract
09:42:27 <EvanR> or can you expression those in terms of pullbacks
09:42:30 <EvanR> express
09:44:02 <Cale> Uh, I don't see a way. There will be an inclusion map from the pullback to the product of A and B which will be a monomorphism, however, I would be surprised to hear that it always splite.
09:44:04 <Cale> splits8
09:44:08 <Cale> can't type :)
09:45:08 <EvanR> its monomorphin time
09:46:31 <EvanR> also is there really a monomorphism from the pullback to the product?
09:46:47 <ReinH> Cale: coproducts are monic, products are epic.
09:47:40 <ReinH> Wait, I think that requires a 0 object (and dually for coproducts)
09:47:49 <bollu> what's a monomorphism?
09:48:01 <Cale> EvanR: Yeah, it's an equalizer on the product
09:48:02 <bollu> ReinH: epic is surjective right?
09:48:09 <bollu> ReinH: and monic is.. injective?
09:48:19 <EvanR> sort of
09:48:24 <ReinH> On Set, yes.
09:48:37 <ReinH> They are abstractions that work on categories.
09:48:38 <Cale> i.e. we can put the product in there with its projections A <- A x B -> B
09:48:54 <Cale> and that won't quite get us the pullback
09:49:08 <Cale> But there will be two paths around that square
09:49:18 <Cale> formed with the maps A -> C <- B
09:49:27 <Cale> and we're equalizing those
09:50:07 <Cale> i.e. we have two parallel maps A x B -> C, f . pi_1 and g . pi_2, and the pullback is their equalizer
09:50:24 <EvanR> monomorpisms can be left cancelled
09:50:31 <EvanR> thats there thing
09:50:42 <Cale> Equalizers are always monic, as it turns out
09:51:02 <ReinH> Cale: And there's a uniqueness property via unique isomorphism A x B <=> C? Is that interesting at all?
09:51:30 <Cale> wait what?
09:51:33 <ReinH> Wait no
09:51:50 <ReinH> There's not necessarily any morphism C -> A x B at all
09:51:54 <Cale> C is just this arbitrary object, yeah
09:52:07 <Guest32109> http://lpaste.net/207605 can't figure out whats the problem with this 
09:52:13 <Cale> It's part of the diagram we're taking the pullback of
09:52:32 <ReinH> Guest32109: Neither can we, since you didn't describe the problem.
09:52:35 <EEVV> Hallo! How can I pass a function to a function?
09:52:41 <EEVV> Like -> Int
09:52:41 <ReinH> EEVV: in the usual way
09:52:45 <EEVV> I'm a nuub
09:52:56 <ReinH> > id succ 1
09:52:58 <lambdabot>  2
09:52:59 <EEVV> is it something like (a => b)?
09:53:02 <ReinH> applies id to succ
09:53:11 <maerwald> anyone knows if there's something more maintained than seclib wrt security type system?
09:53:16 <ReinH> There is no => that works on values
09:53:33 <EEVV> ReinH, how do I assign a function as a parameter to another function?
09:53:41 <ReinH> :t ($)
09:53:43 <lambdabot> (a -> b) -> a -> b
09:53:47 <ReinH> Note the braces
09:53:59 <Cale> Guest32109: 1) SplitAt should be splitAt, 2) sum (splitAt x list) would mean that you're taking the sum of a pair, which you probably don't want to do, since it just picks the second component (for reasons of consistency, it'll make sense later) 3) whatever the result of that sum will be, it's surely not a list, and you're applying ... !! 1 to that
09:54:16 <EEVV> ReinH, so (a -> b) is the function and a -> b is the input & return?
09:54:31 <EvanR> :t map
09:54:32 <lambdabot> (a -> b) -> [a] -> [b]
09:54:35 <ReinH> EEVV: ($) is a function that takes a funcion (a -> b) and gives a function a -> b
09:54:41 <EvanR> stereotypical function that takes a function
09:54:45 <ReinH> We usually curry this:
09:54:52 <ReinH> (And use it infix)
09:54:55 <EEVV> that's so confusing
09:54:57 <ReinH> > succ $ 1
09:54:59 <lambdabot>  2
09:55:11 <EEVV> omg is that a interpreter bot? :D
09:55:11 <EvanR> :t iterate
09:55:12 <lambdabot> (a -> a) -> a -> [a]
09:55:13 <ReinH> It takes some getting used to.
09:55:14 <Cale> Guest32109: Note that you might be looking for take... and note that it's okay to apply take with a larger number than how many elements are in the list -- you'll just get the same list back
09:55:20 <Cale> > take 100 [1,2,3,4,5]
09:55:22 <lambdabot>  [1,2,3,4,5]
09:55:33 <Cale> > take 0 [1,2,3,4,5]
09:55:36 <lambdabot>  []
09:55:59 <EEVV> ReinH, how do you explicitly state that you want a function (as a parameter), which takes in an Int and returns an Int?
09:56:02 <Guest32109> Cale: http://lpaste.net/207605 ... actually I'm looking for the sum of the first x numbers in a list
09:56:10 <EEVV> ($)
09:56:10 <Guest32109> Cale: ohhh!
09:56:26 <ReinH> EEVV: (Int -> Int)
09:56:37 <EEVV> ReinH, I'll try that, thanks.
09:56:38 <Cale> Guest32109: The correct program should read pretty much how your English does, and shouldn't involve guards :)
09:56:40 <ReinH> :t ($) :: (Int -> Int) -> Int -> Int
09:56:42 <lambdabot> (Int -> Int) -> Int -> Int
09:56:48 <ReinH> That specializes ($) to work on Ints
09:57:51 <Cale> Guest32109: Generally any time that you're computing the length of a list you should try very hard to avoid that, unless for some reason the entire point of the computation was to know how many elements were in the list.
09:58:22 <ReinH> If you need to use length to compute something else, either find another way or find another data structure.
09:58:31 <Cale> You can sort of think of lists as being like loops that are waiting to happen
09:58:49 <Guest32109> Cale: Got it to work! thanks a lot
09:58:59 <Guest32109> Cale: sumThis x list = sum (take x list) :)
09:59:01 <Cale> Just as a loop is something which either never occurs (because its precondition isn't met), or consists of an iteration followed by another loop
09:59:23 <Cale> a list is either empty [], or consists of a single element followed by another list (x:xs)
09:59:35 <Cale> yep
09:59:51 <EvanR> that comparison only makes sense because laziness
10:00:09 <Cale> So yeah, the difference between lists and loops is that you get to modify lists after the fact -- like you did with take there
10:00:22 <Cale> bollu: ^^ this simple example might be of interest ;)
10:00:50 <bollu> Cale: "after the fact" meaning?
10:01:00 <ReinH> bollu: one way to look at monic is: f : X -> Y in category C is to say that for a fixed A in C, the morphism f* : C(A, X) -> C(A, Y) is injective. And dually for epic.
10:01:39 <Cale> bollu: I mean, from outside the determination of what the original list is
10:02:03 <EEVV> EvanR, it works :D do you have any tutorial site, which you have learnt from?
10:02:12 <bollu> ReinH: C(A, X) is Hom_C(A, X) ?
10:02:15 <Cale> Guest32109's program works even if the list has 100 factorial elements, or infinitely many elements -- we can get the first 10 of them and sum those without needing to store or compute the rest
10:10:16 <jonkri> ql
10:10:24 <jonkri> nvm :)
10:11:53 <EEVV> Can a function not return? Like main?
10:12:12 <EEVV> not return a value*
10:12:15 <EEVV> or anything :P
10:12:20 <bollu> EEVV: main does return, technically :P
10:12:25 <bollu> > fix id
10:12:31 <lambdabot>  mueval-core: Time limit exceeded
10:12:36 <EEVV> rip
10:12:45 <bollu> you can have computations that lead to non-termination
10:12:58 <bollu> so they don't "return anything". One could say they "return bottom"
10:13:12 <bollu> where bottom is this value that's in every type which means "non-termination"
10:13:16 <EEVV> bollu, I wonder how many times does haskell get stack overflows
10:13:17 <bollu> correct me if I'm wrong
10:13:25 <bollu> EEVV: doesn't have a stack :P
10:13:37 <EEVV> bollu, O>O meind blown
10:13:44 <Cale> It doesn't have a *call* stack, but that doesn't mean it doesn't have stack overflows
10:13:59 <EEVV> bollu, then how does it keep track of the return address?
10:14:00 <bollu> Cale: ah, my bad. I assumed we were talking about the call stack overflowing
10:14:04 <Cale> GHC's stack is better interpreted as a stack of pattern matches waiting to happen
10:14:28 <bollu> EEVV: through this thing called as a continuation. I should let Cale do the rest since I don't understand it super well
10:14:39 <Cale> i.e. whenever you have  case <scrutinee> of <some pattern matches>
10:14:43 <EEVV> Cale, pls
10:15:16 <Cale> It's going to put something on the stack to indicate that we want to proceed to match a pattern, before entering the code for the scrutinee
10:15:27 <bollu> interesting
10:15:30 <bollu> did not know that
10:15:30 <EEVV> Cale, so it still uses a stack?
10:15:33 <Cale> yeah
10:15:42 <EEVV> does it have an increased stack size?
10:15:45 <bollu> Cale: any real world examples where pattern match has led to an "overflow"?
10:15:51 <EEVV> (idk how you would actually do that, maybe a kernel call?)
10:15:57 <Cale> Sure, it's not hard to invent some
10:15:59 <bollu> Cale: I find it hard to believe that you can exhaust the stack with patterns matches
10:16:05 <Cale> > foldr (+) 0 [1..10000000]
10:16:06 <bollu> really? what's a perverse case?
10:16:07 <lambdabot>  *Exception: stack overflow
10:16:12 <bollu> wat
10:16:14 <bollu> oh, foldr
10:16:17 <EEVV> :OOO
10:16:18 <Cale> > foldl (+) 0 [1..10000000]
10:16:26 <lambdabot>  mueval: ExitFailure 1
10:16:30 <Cale> heh
10:16:32 <bollu> uhh, what?
10:16:33 <Cale> > foldl (+) 0 [1..1000000]
10:16:34 <bollu> wait what?
10:16:40 <Cale> timed out for whatever reason
10:16:41 <bollu> that made no sense to me
10:16:42 <lambdabot>  mueval-core: Time limit exceeded
10:16:42 <bollu> ah
10:16:52 <EEVV> > 1 + 2
10:16:54 <lambdabot>  3
10:16:57 <EEVV> yay
10:17:02 <bollu> Cale: I didn't realize that non-evaluated thunks counted as patterns
10:17:13 <bollu> > let 1 + 2 = 5 in 1 + 2
10:17:14 <Cale> The pattern matches are the ones which (+) is doing
10:17:15 <lambdabot>  5
10:17:21 <Cale> Actually the foldl one will usually work
10:17:22 <bollu> EEVV: ^
10:17:25 <EEVV> bollu what does let mean?
10:17:32 <Cale> But with optimisations off, you may still get a stack overflow
10:17:34 <EEVV> is it like assume?
10:17:41 <bollu> EEVV: it lets you name something temporarily.
10:17:43 <bollu> Something like:
10:18:01 <EEVV> > let x = 2; x + 3
10:18:03 <lambdabot>  <hint>:1:17: error:
10:18:03 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:18:03 <bollu> > let evens = [2, 4..], odds = [1, 3..] in take 10 (zip evens odds)
10:18:05 <lambdabot>  <hint>:1:21: error: parse error on input ‘,’
10:18:16 <EEVV> > let x = 2 | x + 3
10:18:17 <Cale> EEVV: bollu's example is intentionally confusing, he's locally giving a definition of the function (+)
10:18:18 <lambdabot>  <hint>:1:11: error: parse error on input ‘|’
10:18:28 <Cale> > let x = 2 in x + 3
10:18:30 <lambdabot>  5
10:18:31 <bollu> EEVV: ignore what I did, it's just this cute thing
10:18:34 <EEVV> oh
10:18:39 <EEVV> thanks, Cale
10:18:49 <EEVV> sooo let can create variables?
10:18:58 <bollu> EEVV: only in that small context in the "in"
10:18:59 <Cale> yeah
10:19:03 <EEVV> kool!
10:19:08 <bollu> EEVV: they're not "variables" since you can't change their values
10:19:14 <Cale> They are variables...
10:19:15 <bollu> EEVV: they're like consts
10:19:17 <EEVV> bollu, that sucks xD
10:19:23 <bollu> Cale: what? immmutable
10:19:24 <Cale> They're variables in the sense of mathematics
10:19:32 <bollu> Cale: ah, yes, that way :P
10:19:34 <lenomac> http://lpaste.net/207605 my first function works fine (returns infinite list of tetranacci numbers) but my second one doesnt seem to work (choose which element in list to get)
10:19:38 <lenomac> any help?
10:19:44 <bollu> Cale: but, like, programmers and mathematicians have very different notions of what a variable is
10:19:49 <Cale> and their values *may* vary, even if not while they remain in scope
10:19:49 <EEVV> let 2 + 3 = 5 in 3 + 3
10:20:04 <Cale> consider something like...
10:20:05 <EEVV> > let 2 + 3 = 5 in 3 + 3
10:20:07 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
10:20:30 <EEVV> let True = False in True == True
10:20:32 <EEVV> demmit
10:20:37 <EEVV> > let True = False in True == True
10:20:39 <lambdabot>  True
10:20:42 <EEVV> u wot
10:20:57 <Cale> > let { f x = let y = x^2 in x + y } in map f [1..10]
10:21:00 <lambdabot>  [2,6,12,20,30,42,56,72,90,110]
10:21:12 <Cale> Here, the value of y varies
10:21:12 <EEVV> Cale, confusing!
10:21:17 <EEVV> x(
10:21:22 <Cale> Because f is applied to different arguments
10:21:26 <Cale> So x varies
10:21:32 <EEVV> oh
10:21:37 <EEVV> so you can have multiple let and ins?
10:21:38 <ReinH> > let True = False in True
10:21:39 <Cale> yeah
10:21:40 <lambdabot>  True
10:21:44 <bollu> Cale: Interesting
10:21:52 <Cale> Of course -- let <decls> in <expr>  is an expression form
10:21:55 <EEVV> even bollu is amused!
10:22:00 <Cale> You can use it whenever an expression is required
10:22:05 <EvanR> uh, capital variables?
10:22:06 <bollu> Cale: though that's more because of the binding semantics of terms than the actual "let" varying, correct?
10:22:16 <EEVV> > let True == True = False in True == True
10:22:18 <lambdabot>  False
10:22:19 <bollu> Cale: 	like, it's because of the way in which the terms are reduced in f x?
10:22:22 <EEVV> ahh
10:22:30 <Cale> bollu: Well, function parameters are variables which vary every time you apply the function to a different argument
10:22:31 <jonored> EvanR: I think that's doing a pattern match with no variables, not changing True.
10:22:41 <Cale> I'm just justifying the use of the word "variable"
10:22:51 <bollu> Cale: correct, but they are constants in one application of a function :) Ah, yeah, sure. That I'm fine with
10:22:51 * hackagebot servant-snap 0.7 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.7 (imalsogreg)
10:22:51 <Cale> By explaining how things can actually change :)
10:22:53 * hackagebot servant-snap 0.7.0.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.7.0.1 (imalsogreg)
10:22:57 <EEVV> What is good website which gives me challanges to try and solve in Haskell?
10:23:01 <mizu_no_oto_work> bollu: it's not reassignable, but it's varying in the same sense that x varies in f(x) = x^2 when you call f(4), f(5) and f(6).
10:23:24 <Cale> EEVV: about the stack...
10:23:31 <EEVV> Cale, yeah?
10:23:35 <Cale> Lazy evaluation is outermost-first
10:23:38 <bollu> mizu_no_oto_work: yes, which an artefact of how evaluation is defined in lambda calculus? call-by value because of eta reduction
10:23:41 <bollu> mizu_no_oto_work: right?
10:23:51 <Cale> This means when you have an expression like
10:23:55 <Cale> f (g (h x))
10:24:03 <EEVV> it is called later?
10:24:04 <Cale> It's *f* which is applied first
10:24:09 <EEVV> or something like that?
10:24:18 <EEVV> I thought it was like executed when needed
10:24:19 <Cale> and it's applied to the as-yet-unevaluated expression g (h x)
10:24:48 <Cale> Only if and when f pattern matches on its argument will g (h x) be evaluated
10:24:51 <ReinH> outermost-leftmost, so x + y reduces (+), then (if (+) demands them) x, then y.
10:25:14 <soLucien> if i want to get rid of the non-exhaustive pattern matching warning
10:25:15 <Cale> So, we don't need to put something on the stack here to remember where we are while we evaluate g (h x), because we aren't going to evaluate that.
10:25:27 <soLucien> and spit out an error/exception
10:25:33 <soLucien> how can i do it in a function ?
10:25:41 <EEVV> Cale, wait... Evaluation is done at runtime?
10:25:43 <Cale> (at least not now)
10:25:45 <EEVV> or wat
10:25:46 <Cale> yes
10:25:58 <EEVV> Cale, because of the dynamic types?
10:26:04 <ReinH> No, because of dynamic values.
10:26:04 <Cale> Evaluation is only done at runtime, that's the better part of what runtime *is*
10:26:18 <Cale> Evaluation is the process of reducing expressions to values
10:26:29 <Cale> largely for the purpose of matching patterns
10:26:34 <EEVV> Cale, isn't that quite an overhead?
10:26:37 <Cale> hm?
10:26:42 <ReinH> EEVV: Compared to what?
10:26:43 <Cale> An overhead relative to what?
10:26:51 <ReinH> Not running your program? Yes.
10:26:55 <EvanR> agreed we shouldnt be evaluating anything at runtime
10:26:58 <EEVV> Cale, compile-time evaluation 'n stuff :P#
10:27:09 <ReinH> How do you evaluate expressions at compile time?
10:27:11 <mizu_no_oto_work> soLucien: do you want to recover from the error?
10:27:11 <EvanR> its a waste of resources
10:27:18 <ReinH> You don't know what their values are yet.
10:27:19 <EvanR> dont evaluate at compile time either
10:27:35 <mizu_no_oto_work> http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:error works if you want something unrecoverable
10:27:43 <soLucien> no , it is clear that something that should not happen has happened
10:27:50 <glguy> ReinH: You just evaluate for all possible values ahead of time
10:28:05 <ReinH> To the extent that expressions can be evaluated ahead of time, we already do that and call it (a form of) optimization.
10:28:14 <Cale> EEVV: Suppose my program does some I/O and gets some number x from the user. How am I supposed to evaluate factorial x at runtime?
10:28:20 <EEVV> So if we explicitly had to state the type of every variable/function parameter/whatever, then we wouldn't need to evaluate?
10:28:21 <Cale> er, not at runtime
10:28:22 <Cale> haha
10:28:22 <ReinH> e.g., replacing 1 + 1 with 2 at compile time
10:28:34 <dolio> Not everything possible to do like that is done.
10:28:34 <ReinH> But we can't replace x + y at compile time, unless we can also replace x and y at compile time
10:28:41 <ReinH> dolio: true
10:28:53 <EEVV> ReinH, but we calculate that at runtime (x + y)
10:28:58 <Cale> It's hard to work out the factorial of a number you don't know at compile time
10:29:07 <ReinH> EEVV: Yes
10:29:12 <glguy> Cale: What about a sufficiently smarat compiler?
10:29:17 <Cale> glguy: heh
10:29:29 <maerwald> ReinH: afair stuff like [1, 2, 3] !! 0 is not evaluated at compile time
10:29:33 <Cale> glguy: Maybe it's so smart it knows what number you're going to type :)
10:29:38 <EEVV> Cale, well yeah
10:29:40 <bollu> Cale: C++ you can encode factorial using template metaprogramming
10:29:44 <ReinH> Sorry, I worded that poorly.
10:29:44 <maerwald> I mean, even with optimizations
10:29:54 <ReinH> There are some compile-time evaluations that we perform and call them optimization
10:29:56 <EEVV> Cale, obviously I don't mean that we can resolve a factorial of an unknown number at compile-time
10:29:57 <ReinH> There are others that we don't
10:29:59 <glguy> EEVV: Maybe you're using a different "evaluate" than everyone else? Explicitly annotating types doesn't have anything to do with runtime evaluation
10:30:01 <Cale> bollu: That... doesn't help if you don't know which number you want to compute the factorial of yet.
10:30:03 <jonored> bollu: Worth note that a not unusual step in compiler design is to convert everything to "static, single-assignment form" - getting to "this name means that value in this context and won't change" is in a lot of ways a better representation than memory cells when you want to do reasoning.
10:30:24 <bollu> jonored: SSA is cute, yeah. I've used LLVM in the past
10:31:10 <soLucien> mizu_no_oto_work is there a non-partial way of implementing error ?
10:31:26 <EEVV> bollu, any good links for beginners? (tutorials, etc)
10:31:33 <Cale> EEVV: Anyway, evaluation generally refers to the process of turning expressions into values at runtime, for the purposes of matching patterns. It's most of what programs do internally, but isn't typically visible to the user (apart from making their CPU act as a space heater)
10:31:57 <mizu_no_oto_work> soLucien: if you want something total, use Maybe or Either
10:32:10 <EEVV> Cale, so evaluating is the process, where you just execute?
10:32:15 <Cale> EEVV: The other stuff that programs do, we usually refer to as "execution" in Haskell
10:33:02 <Cale> More specifically, "execution" refers to the process of carrying out the instructions described by values of type IO t, which can instruct the computer to do anything that computers can normally do.
10:33:08 <soLucien> mizu_no_oto_work pointMax' [] _ = error "Cannot get max from a empty Curve"
10:33:15 <soLucien> how do i use maybe here ?
10:33:18 <ReinH> Generally speaking, doing things with values requires knowing what those values are. And generally speaking, values are known at runtime and not at compile-time, while types are known at compile-time and not (in fact) known at runtime.
10:33:44 <ReinH> So the general solution to working with values is to do so at runtime.
10:33:52 <EvanR> ReinH: ignoring IO... all values (mostly functions) are known at compile time ;)
10:33:58 <mizu_no_oto_work> soLucien: pointMax' [] = Nothing ; pointMax' (x:xs) = 
10:34:03 <mizu_no_oto_work> soLucien: pointMax' [] = Nothing ; pointMax' (x:xs) = Just ...
10:34:06 <Cale> In a compiled program, the IO action called "main" is executed, and you can imagine that the thing which is executing it is going to demand that it be evaluated so that it can match it against patterns and figure out what actions are described, so it can carry them out.
10:34:32 <EvanR> you dont know what IO will give you, its like a box of chocolates
10:34:33 <Cale> (this isn't quite how it works in GHC... GHC does some awful hackery, but it's a good mental model regardless)
10:34:58 <mizu_no_oto_work> soLucien: pointMax' :: [MyCurve] -> Maybe Point, or something to that effect
10:35:02 <EEVV> talk to you people later
10:35:20 <Cale> abrupt :)
10:37:13 <maerwald> evaluation happens, when the program is executed... let's make things more confusing :P
10:37:19 <mizu_no_oto_work> soLucien: Essentially, you're returning a type that explicitly models the fact that the function isn't total
10:39:00 <Cale> maerwald: It does :)
10:39:06 <Cale> maerwald: But not the other way around
10:39:07 <soLucien> so i was trying to convert 
10:39:08 <mizu_no_oto_work> Probably should have mentioned that it's not evaluation in the same sense as javascript's eval(), but in the sense you've seen in math class
10:39:10 <soLucien> ?pasteboard
10:39:11 <lambdabot> Unknown command, try @list
10:39:13 <soLucien> ?paste
10:39:13 <lambdabot> Haskell pastebin: http://lpaste.net/
10:39:26 <Cale> Evaluation never causes execution to occur, but execution may demand evaluation.
10:39:53 <soLucien> http://lpaste.net/879559536434741248
10:40:26 <dolio> I don't think it's really great terminology, either. People in this channel took two synonyms and turned them into jargon with distinct meanings, and tend to expect people to intuit the difference.
10:40:40 <Cale> dolio: I don't think we expect people to intuit the difference
10:40:49 <Cale> We've always been quite willing to explain it :)
10:41:16 <Cale> and it's *useful* technical jargon
10:41:47 <soLucien> what was i doing wrong ?
10:41:58 <EvanR> Cale: too bad its so overloaded
10:42:24 <EvanR> but at least haskell didnt reinvent existing words
10:42:51 <mizu_no_oto_work> soLucien: pointMax' (x:xs) axis = Just ( max (axis x) (pointMax' xs axis) ) doesn't quite type: axis x :: Double, but pointMax' xs axis :: Maybe Double
10:43:13 <EvanR> instead of eval we can call it frobnicate
10:43:39 <EvanR> and execute is transmogrify
10:43:49 <soLucien> fornicate FTW !
10:44:38 <fizbin> I need to generate something kind of like an object format. It's binary, it has pointers from one part of the format to another, and the best documentation I have is C code that reads this format. I've got my code working, but it's mega ugly. Like, rats nest ugly. Is there a library for cleanly generating binary formats that I should be using instead?
10:45:18 <mizu_no_oto_work> soLucien: there is, however, an Ord instance for  Ord a => Ord (Maybe a).  So max (Just (axis x)) (pointMax' xs axis) will typecheck
10:45:30 <mizu_no_oto_work> > max (Just 5) Nothing
10:45:33 <lambdabot>  Just 5
10:47:43 <soLucien> i don't really get this something/nothing/just thing ..
10:47:53 <soLucien> how is this better than the error ?
10:48:25 <mizu_no_oto_work> soLucien: you can kind of think of Nothing as being like null
10:48:49 <mizu_no_oto_work> A value of type Maybe Int is like having a nullable int
10:49:13 <mizu_no_oto_work> And a value of type Foo is a definitely-present value of type Foo
10:49:14 <soLucien> okay great
10:49:21 <soLucien> i see
10:49:32 <soLucien> nullable Double
10:49:33 <soLucien> makes sense
10:49:51 <mizu_no_oto_work> which is better than OO languages, where nullness is tied to being primitive or not.
10:49:53 <maerwald> Cale: I think really understanding the difference becomes only useful for tricky cases like unsafePerformIO
10:50:34 <EvanR> understanding the difference becomes useful as soon as you wrote your entire program not knowing the difference then wanting to get the time of day inside your pure program
10:50:56 <mizu_no_oto_work> At any rate, Maybe forces you to deal with possibly nullable things at the type level, and also allows you to capture standard null handling techniques in library functions
10:50:57 <EvanR> which hopefully wont result in using unsafePerformIO
10:51:07 <EvanR> of course theres the acme-now package
10:51:11 <maerwald> EvanR: I don't that requires understanding the difference.
10:51:25 <EvanR> to fix it?
10:51:31 <mizu_no_oto_work> > maybe "missing data" show (Just 5)
10:51:33 <lambdabot>  "5"
10:51:36 <maerwald> you can understand IO and non-IO fine without the evaluation vs execution terminology
10:51:51 <mizu_no_oto_work> > maybe "missing data" show Nothing
10:51:51 <maerwald> most of it, at least
10:51:53 <lambdabot>  "missing data"
10:52:02 <EvanR> well IO doesnt make too much sense without having a way to execute it
10:52:11 <maerwald> that was not my point
10:52:15 <EvanR> not to be confused with evaluating it
10:52:45 <mizu_no_oto_work> soLucien: Having most things be non-nullable is really nice, because you only need to consider nullability when you actually need it
10:52:58 <EvanR> ime people tend to see IO types and think of them as functions, which cant result in anything good
10:53:28 <maerwald> no idea how that's related to my point
10:53:39 <soLucien> hmm so in my code the issue is
10:53:47 <soLucien> max expects double not maybe double
10:53:51 <mizu_no_oto_work> soLucien: and the primary difference with error is that error will basically stop your program and print an error message.
10:53:52 <soLucien> how do i fix it ?
10:54:04 <mizu_no_oto_work> > error "something fatal happened"
10:54:06 <lambdabot>  *Exception: something fatal happened
10:54:22 <mizu_no_oto_work> :t max
10:54:24 <lambdabot> Ord a => a -> a -> a
10:54:35 <maerwald> most of the time programmers think of their code in terms of "ok, what happens when I _run_ it"... and when you run it, BOTH evaluation and execution happen, so why really make a difference there? Well, most of the time it's irrelevant in practical thinking, exceptions being unsafePerformIO for example
10:54:38 <implementation> > fix error
10:54:40 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
10:55:07 <mizu_no_oto_work> Notice that max doesn't specify Double, it specifies that it works on some type a that has an Ord instance
10:55:08 <VitorCBSB> That didn't fix it all. :(
10:55:16 <EvanR> maerwald: because haskell is a pure functional language
10:55:22 <maerwald> blubb
10:55:36 <EvanR> thats one of the things that helps write working code
10:55:37 <mizu_no_oto_work> soLucien: both Double and Maybe Double have Ord instances
10:55:40 <int-e> VitorCBSB: "fix" just makes the program run in circles... ;-)
10:55:55 <maerwald> EvanR: you're having a monologue :P
10:55:56 <EvanR> in blub there really is no difference
10:56:09 <EvanR> i know you are but what am i
10:56:10 <HugoDaniel> :)
10:56:19 <HugoDaniel> Just Nothing
10:56:22 <mizu_no_oto_work> soLucien: but you can't compare a Double to a Maybe Double, you need to compare a Double to a Double and a Maybe Double to a Maybe Double
10:56:35 <mizu_no_oto_work> Just like you can't say
10:56:36 <soLucien> so i wrapp evrything in Just ?
10:56:47 --- mode: ChanServ set +o glguy
10:56:47 --- mode: glguy set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.119.157.169.230
10:57:04 <mizu_no_oto_work> > max "not a number" (4 :: Integer)
10:57:06 <lambdabot>  error:
10:57:06 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Integer’
10:57:06 <lambdabot>      • In the second argument of ‘max’, namely ‘(4 :: Integer)’
10:57:30 <EvanR> maerwald: i still think that someone who thinks thres no difference will have a hard time writing code, because of the acme-now example
10:57:51 <mizu_no_oto_work> soLucien: Just is how you construct a Maybe Double that contains an actual Double, yes.
10:57:57 <EEVV2> I'm back! And I've got a question! How can you mimic a while true loop in Haskell?
10:58:19 <Clint> do you want to mimic breaking out of it somehow?
10:58:28 <mizu_no_oto_work> EEVV2: recursion, usually
10:58:43 <EEVV2> Clint, what about infinite recursion? Wouldn't that overflow the stack?
10:59:13 <mizu_no_oto_work> EEVV2: not necessarily 
10:59:16 <EvanR> no, forever spamEmail looks like a small cyclic data structure
10:59:56 <EvanR> @src forever
10:59:57 <lambdabot> forever a = let a' = a >> a' in a'
11:00:09 <EEVV> mizu_no_oto_work, wouldn't that overflow the stack?
11:00:19 <soLucien> how do i extract a double from a just double 
11:00:32 <VitorCBSB> :t forever
11:00:35 <lambdabot> Applicative f => f a -> f b
11:00:45 <mizu_no_oto_work> Oh, "while(true) { ... }", you mean.  Yeah, forever is how to do that.  It doesn't overflow the stack because there's not a call stack
11:00:45 <EvanR> o_O
11:00:48 <implementation> soLucien: pattern matching. there's also `maybe`, `fromMaybe` etc.
11:01:04 <EEVV> mizu_no_oto_work, thanks!
11:01:10 <mizu_no_oto_work> > maybe 0 id (Just 5)
11:01:12 <lambdabot>  5
11:01:16 <mizu_no_oto_work> > maybe 0 id Nothing
11:01:18 <maerwald> EvanR: that's what I said 10 minutes ago already.
11:01:19 <lambdabot>  0
11:01:26 <implementation> > let someMaybe = Just 5; Just theValue = someMaybe in theValue
11:01:28 <lambdabot>  5
11:01:33 <maerwald> unsafePerformIO is one of the few reasons to make that distinction
11:01:44 <EvanR> no
11:01:46 <implementation> usually you want a Nothing case as well :)
11:01:48 <maerwald> which is basically what acme-now does
11:02:24 <EvanR> i was referring to writing a normal program that needs the current time, without unsafePerformIO, and you wrote the whole thing without IO
11:02:34 <maerwald> https://hackage.haskell.org/package/acme-now-1.0.0.1/docs/src/Acme-Time-Now.html#now
11:02:53 <EvanR> because why wouldnt you
11:03:01 <maerwald> I see unsafePerformIO there
11:03:02 <EvanR> i can just evaluate the current time
11:03:11 <EvanR> since evaluate = execute
11:03:11 <mizu_no_oto_work> soLucien: there's various other library functions, too, especially if you want to "preserve nullness"
11:03:18 <implementation> :t fromMaybe -- soLucien: like maybe with id as second argument
11:03:20 <lambdabot> a -> Maybe a -> a
11:03:28 <mizu_no_oto_work> > fmap (+ 1) Nothing
11:03:30 <lambdabot>  Nothing
11:03:36 <mizu_no_oto_work> > fmap (+ 1) (Just 5)
11:03:39 <lambdabot>  Just 6
11:04:26 <mizu_no_oto_work> > do { x <- Just 5 ; y <- Just 5 ; return (x + y) }
11:04:28 <lambdabot>  Just 10
11:04:34 <mizu_no_oto_work> > do { x <- Just 5 ; y <- Nothing ; return (x + y) }
11:04:36 <lambdabot>  Nothing
11:05:25 <maerwald> EvanR: did you check the implementation of acme-now?
11:05:43 <EvanR> yes
11:05:54 <mizu_no_oto_work> soLucien: fmap and do notation are really useful if you want semantics that are essentially null propagation; maybe is useful if you want to provide a default at a later point.
11:06:59 <EvanR> but ill just repeat my point for the third time, i think anyone who thinks theres no difference will have a hard time writing a normal program that suddenly needs the current time, or a random number, or whatever, and doesnt know that unsafePerformIO exists
11:07:20 <EvanR> so that doesnt need to factor in
11:07:42 <maerwald> if you want the current time or a random number without IO, then you are using unsafePerformIO
11:08:32 <adelbertc> for random number you can use something based on State. cant really do that with current time though
11:08:56 <implementation> ... in that case one might better want to restructure the program
11:09:16 <mizu_no_oto_work> soLucien: does that help?
11:10:43 <maerwald> adelbertc: this was about knowing about evaluation vs execution because of unsafePerformIO, but than he came up with a counter-example which uses unsafePerformIO :o
11:11:03 <adelbertc> maerwald: oh my bad :) i sort of just jumped in after reading 5 lines of scrollback
11:12:02 <soLucien> almost nailed it
11:13:38 --- mode: glguy set -o glguy
11:14:29 <ReinH> adelbertc: You can if you abandon our parochial concept of the enumerability of time!
11:14:45 <adelbertc> :-)
11:16:12 <nshepperd> If evaluation = execution, you should be able to execute an io action by evaluating it. Which you can't. (You have to unwrap it, apply it to a state token, then evaluate the result, which is completely different.)
11:16:31 <ReinH> "state token"
11:17:15 <ReinH> And this is just GHC's implementation, which is not canonical.
11:17:52 <ReinH> The Haskell report does seem to agree that evaluation /= execution, but in general it has very little to say on the subject of execution.
11:22:52 * hackagebot unjson 0.14 - Bidirectional JSON parsing and generation.  https://hackage.haskell.org/package/unjson-0.14 (MikhailGlushenkov)
11:22:54 * hackagebot async-extras 0.1.3.1 - Extra Utilities for the Async Library  https://hackage.haskell.org/package/async-extras-0.1.3.1 (lloucas)
11:22:56 * hackagebot unjson 0.14.0.1 - Bidirectional JSON parsing and generation.  https://hackage.haskell.org/package/unjson-0.14.0.1 (MikhailGlushenkov)
11:23:37 <maerwald> nshepperd: we were talking about people NOT having a strong concept of both terms, not about people who have a strong concept and think they are the same :o
11:24:00 <maerwald> which indeed, doesn't make a lot of sense
11:24:51 <dominik> I've been playing with servant's underlying core idea recently, namely tranlating type APIs into type-correct handler functions
11:25:16 <dominik> the very essence of which (I hope) is written down here: https://gist.github.com/bollmann/4b37a052135aaf7f801e2c2aa4d5c9dc
11:26:13 <dominik> however, I'm having problems in defining the HasServer instance for `instance HasServer (api1 :<|> api2)`, where I'm getting type-errors
11:26:30 <dominik> could anyone explain to me what I'd have to do here in order to make this type-correct?
11:27:17 <dmj`> dominik: can you paste your code, and type errors on http://lpaste.net
11:27:29 * shapr hops cheerfully
11:27:31 <shapr> yay code!
11:28:51 <dmj`> shapr: \o/
11:29:47 <shapr> oh hai dmj`!
11:30:00 <dmj`> shapr: hay :) o/
11:30:32 <dominik> dmj`: see the above gist
11:31:01 <benzrf> dominik: hot take: you should try out datakinds instead of plopping everything in *
11:31:18 <dmj`> dominik: I just joined the channel and can't see the past :( 
11:32:07 <benzrf> dmj`: https://gist.github.com/bollmann/4b37a052135aaf7f801e2c2aa4d5c9dc
11:32:50 <dmj`> data (a :: *) :<|> (b :: *) = a :<|> b
11:32:54 <dmj`> should be (a :: k)
11:33:04 <dmj`> enable poly kinds
11:33:34 <dmj`> same with, data (a :: Symbol) :> (b :: *)
11:39:08 <dmj`> dominik: try p1 = Proxy :: Proxy api1, on line 80
11:42:57 <dmj`> what benzrf said :)
11:52:46 <knupfer> How can I test type families and type operators?
11:53:05 <BernhardPosselt> hi how do you guys make your code testable? pure functions are easy to test but what about functions where you want to mock out things?
11:53:17 <BernhardPosselt> inject mocks by using partial application?
11:53:59 <knupfer> I've implemented rationals on the type level with some operators on them and I'd want to test them ideally with a type level quickcheck
11:58:09 <knupfer> BernhardPosselt: If you're talking about IO functions, you could make a class with all your impure functions (like readLine) and make instances for IO and instances for MockIO
12:00:51 <BernhardPosselt> right
12:01:21 <ReinH> But then you need some guarantee that MockIO has the same behavior as IO
12:01:38 <ReinH> So you're just moving the problem somewhere else
12:02:47 <BernhardPosselt> yeah, integration tests should cover that
12:02:59 <ReinH> Integration tests would already have covered it.
12:03:01 <BernhardPosselt> however sometimes its needed to mock out stuff to not lose your mind
12:03:28 <ReinH> Why?
12:03:36 <BernhardPosselt> e.g. if you want to test specific aspects only
12:03:53 <BernhardPosselt> e.g. i had some code that was moving files to folders based on a result
12:03:53 <ReinH> Why does your thing have extraneous aspects?
12:04:16 <BernhardPosselt> like if successful move to successfolder, otherwise failure folder
12:04:20 <maerwald> BernhardPosselt: depends what IO you do. If you want to test file operation functions, you don't really want to mock stuff. Instead you want to make sure the environment the tests are executed in stays the same. One way to approach that are containers (e.g. docker or stuff).
12:04:33 <ReinH> I can test a function Bool -> FilePath without mocking anything.
12:04:54 <ReinH> Or a similar function that isn't boolean blind
12:05:10 <ReinH> If you need mocks, I argue you need to rethink your design so you don't need mocks.
12:05:12 <BernhardPosselt> however it turns out that the whole file moving thing is not that cool if you dont want to test it :)
12:05:17 <ReinH> Since mocks imply coupling
12:05:53 <ReinH> Ultimately, the only way to test IO is by performing IO.
12:06:19 <ReinH> So do as much as possible without IO and you won't have to do that
12:06:27 <BernhardPosselt> right but think of something like the following scenario: you read a file, do some calculations and then post the result to somedomain.com
12:06:37 <ReinH> IO has no denotation. What IO means is whatever it does.
12:06:48 <BernhardPosselt> now its very time consuming to set up a mock server
12:06:55 <BernhardPosselt> so you just want to mock out the last part
12:07:03 <ReinH> Why?
12:07:12 <BernhardPosselt> because you dont want to set up a live server
12:07:19 <BernhardPosselt> (for that test case)
12:07:20 <ReinH> If you pass data into your "do some calculations" and then it gives some other data
12:07:26 <ReinH> you can just test "do some calculations"
12:07:29 <BernhardPosselt> you can
12:07:30 <ReinH> without requiring any IO or any mocks
12:07:41 <BernhardPosselt> you can assert that your server mock was called with the calculation result
12:08:00 <ReinH> You can assert that if your server mock is `id`
12:08:56 <BernhardPosselt> how?
12:09:20 <BernhardPosselt> isnt the "post to server function" of type IO?
12:09:37 <ReinH> Ok, return.
12:09:57 <ReinH> But then, again, you have to perform IO to test it
12:10:24 <maerwald> BernhardPosselt: I'd test that in docker containers too. Instead of mocking a server, I create a real one (hell, can even be ~10 different ones).
12:10:55 <maerwald> then your code is tested on the internal container network
12:11:31 <ReinH> That testing is multiple orders of magnitude slower than your unit tests, which imposes some restrictions on its usability.
12:11:41 <BernhardPosselt> right
12:11:43 <ReinH> And also requires non-trivial maintenance overhead.
12:11:56 <maerwald> ReinH: docker containers are not slower, no, the overhead is below 1%
12:12:07 <ReinH> maerwald: docker containers aren't what cause the overhead
12:12:08 <BernhardPosselt> maerwald: there would be no need for mocks ever if that applied for every usecase :)
12:12:17 <ReinH> networking causes overhead
12:12:19 <maerwald> BernhardPosselt: I didn't say it does
12:12:22 <ReinH> spinning up servers causes overhead
12:12:29 <maerwald> ReinH: yeah, but it's internal docker network
12:12:30 <ReinH> the fact that it's docker is irrelevant to my claim
12:12:48 <maerwald> you're not actually contacting a server farm in china
12:13:08 <ReinH> Ok. I mean, do you know how fast machines execute operations and how slow wires send data over distances?
12:13:20 <maerwald> there are no wires involved
12:13:33 <ReinH> Wires were a proxy for networking of all kinds
12:13:36 <BernhardPosselt> speed is probably not an issue
12:13:38 <ReinH> networking is much slower than not networking
12:13:45 <BernhardPosselt> usability much more
12:13:45 <maerwald> ReinH: I am talking about internal docker network
12:14:16 <ReinH> (There are literally wires involved in your internal networking. Machines contain wires. But I digress.)
12:14:37 <ReinH> And yes, networking *of all kinds* is orders of magnitude slower.
12:14:50 <BernhardPosselt> maerwald: stuff like: think about not one but multiple requests to a server in a very specific format
12:14:59 <ReinH> Making an HTTP request and receiving a response is *really slow*, compared to your CPU executing instructions and, e.g., reading things from memory.
12:15:02 <maerwald> ReinH: sure, but it's a reasonable approach
12:15:15 <ReinH> It doesn't scale.
12:15:16 <BernhardPosselt> you'd have to accept and return the appropriate response for each of those requests on your mock server
12:15:21 <ReinH> Either in performance or complexity
12:15:22 <maerwald> ReinH: why?
12:15:25 <maerwald> I disagree
12:15:31 <ReinH> Because if you have n tests, you need n test endpoints.
12:15:31 <maerwald> ever done docker container based testing?
12:15:53 <maerwald> I tested non-trivial web applications with it
12:16:00 <maerwald> it works fine
12:16:05 <ReinH> Yes, I've managed large CI farms as well.
12:16:26 <maerwald> it's slower than unit tests, but you're exaggarating
12:16:35 <ReinH> I'm saying that this sort of testing is of a different kind than the sort of testing you can run automatically when your editor writes a file.
12:16:47 <ReinH> And that matters.
12:17:12 <ReinH> So if you don't *need* this sort of integration test, you should avoid it. So you can spend the time when you *do* need it.
12:17:15 <maerwald> even the pure tests I wrote for most of my haskell things I wouldn't want to run when saving the file
12:17:54 <maerwald> sure, do whatever you need
12:17:59 <ReinH> The complexity also increases with the modularity of your system.
12:18:09 <ReinH> If I have n methods and can combine then  in n choose k ways...
12:18:18 <ReinH> s/methods/functions
12:18:36 <ReinH> So a reliance on integration testing actually penalizes modular systems
12:18:46 <maerwald> erm
12:20:21 <ReinH> I'm just saying, mocking (and the resulting integration testing requires) is often an anti-solution for functional programs (and other sorts of programs)
12:20:25 <ReinH> *required
12:21:24 <ReinH> It incentivizes jumbled balls of IO rather than pure functions
12:22:31 <ReinH> integration testing should be done based on usability requirements, not technical limitations of your design.
12:22:54 * hackagebot pinboard 0.9.10 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.10 (jonschoning)
12:23:22 <ReinH> iow, "We want users to be able to do X" is a good reason to write an integration test for X. "We don't know any other way of testing X" is not.
12:24:40 <maerwald> I have no idea what that means. If you want to test a file operation library, you want to fully execute the IO actions.
12:25:12 <maerwald> but not in randomly changing environments
12:25:45 <maerwald> and that is a per-function test in fact
12:28:33 <ReinH> Yes, presumably because you want your users to use those functions.
12:30:51 <maerwald> And for network stuff, the same CAN apply. It depends. Some things can be reasonably mocked, others not. Doesn't need to be integration tests.
12:32:01 <ReinH> Anything involving a mock is, by definition, an integration test. You are testing the integration of the thing with the (proxy for) the other thing.
12:32:36 <grantwu> That's not the definition I've seen used elsewhere.
12:32:55 <maerwald> by that definition, everything is an integration test, including "reverse", because you test it in conjunction with (:)
12:32:58 <grantwu> But I think it's a useful point of view
12:33:20 <maerwald> I think it's not useful. But it's certainly a fuzzy term, I agree.
12:33:32 <ReinH> maerwald: "unit' is also relative to how you define a unit.
12:33:39 <ReinH> In reality, I think they are on a continuum.
12:34:19 <ReinH> some things are small enough or low enough in complexity that they cross an invisible line and we call them unit tests
12:34:25 <ReinH> others are on the other side of that line and we call them integration tests
12:34:28 <maerwald> terminology philosophy...
12:34:33 <ReinH> and maybe the line isn't well defined, or isn't really a line at all...
12:35:03 <ReinH> maerwald: Where's Wittgenstein when you need him
12:35:12 <maerwald> he tore himself apart :P
12:35:23 <ReinH> One begins to appreciate why
12:41:36 <dominik> benzrf¸ dmj`: thanks! And sorry for my late reply (was afk). I'll try that
12:45:49 <dominik> dmj`: it was just what you said, I had the wrong Proxy type at line 80
12:45:52 <dominik> it works now :-)
12:46:09 <dominik> thanks!
12:46:13 <dmj`> dominik: wunderbar !
12:46:22 <dominik> dmj`: genau!
12:46:33 <dmj`> :)
12:55:40 <buglebudabey> @import Data.Array
12:55:40 <lambdabot> Unknown command, try @list
12:55:47 <buglebudabey> what's the command for this?
12:58:42 <slack1256> I don't think lambdabot can import modules
12:59:05 <slack1256> too bothersome
12:59:35 <buglebudabey> could have sworn i've seen people do it
12:59:41 <buglebudabey> @load Data.Array
12:59:41 <lambdabot> Unknown command, try @list
12:59:44 <buglebudabey> @list
12:59:45 <lambdabot> What module?  Try @listmodules for some ideas.
12:59:53 <buglebudabey> @list Data.Array
12:59:54 <lambdabot> No module "Data.Array" loaded
13:00:42 <dfeuer> Hey all. What do you call a category in which for every two objects x and y there exists at least one arrow x -> y?
13:04:11 <slack1256> dfeuer: where every object is terminal?
13:04:51 <johnw> and it sounds like every object is initial too
13:04:57 <dfeuer> slack1256, no, not at all.
13:05:07 <dfeuer> *at least one*, not exactly one.
13:05:22 <slack1256> oh
13:05:52 <dfeuer> For example, in Haskell,  newtype Foo a b = Foo (a -> Maybe b)
13:06:10 <stelleg> the wikipedia entry on Connected category mentions the idea, but doesn't give it a name
13:06:12 <dfeuer> We have    whatever :: Foo a b; whatever = Foo (const Nothing)
13:07:00 <dfeuer> Hrm. This is, I think, precisely the notion I need to unify Map and IntMap merge tactics.
13:07:47 <dfeuer> Or maybe I actually need more. Grrr.
13:07:56 <dfeuer> I need to pound this out.
13:08:22 <dfeuer> Yeah, I need more than that.
13:08:26 <dfeuer> But that's part of what I need.
13:10:17 <MichaelK> Hi, why aren't the tuples in the Arrow class Bifunctors?
13:10:51 <dfeuer> MichaelK, because that generalizes in too many directions at once. You'd need a multi-parameter typeclass and it would be a godawful mess, I think.
13:11:28 <ReinH> dfeuer: A connected category is one whose underlying graph is weakly connected. Your underlying graph is strongly connected.
13:11:28 <elliptic00> Hi, I just try to understand the data constructor and come up with analogy from Java class, please give me some suggestions on it
13:11:59 <elliptic00> class MyClass<T>{
13:11:59 <elliptic00>     publish MyClass(){}
13:11:59 <elliptic00>     publish MyClass(String str, T a){}
13:12:01 <elliptic00> }
13:12:03 <elliptic00> data MyClass a = Nothing | MyClass String a 
13:12:09 <ReinH> dfeuer: So apparently this is a strongly connected category.
13:12:35 <dfeuer> ReinH, yes. I'm not sure the name will do me any good though, because I may need some more ad hoc properties on top. As far as I can tell, strongly connected category is actually weaker than what I want as well.
13:12:39 <MichaelK> dfeuer: I was thinking to keep the bifunctor in the definitions: e.g. first :: Bifunctor f => a b c -> a (f b d) (f c d)
13:12:53 <ReinH> dfeuer: yes, but at least it's stronger than a connected category. :)
13:13:10 <ReinH> dfeuer: do you need limits too, say?
13:13:14 <dfeuer> ReinH, no, I mean it's weaker than what I would have thought would be called a strongly connected category.
13:13:19 <ReinH> Ah.
13:13:23 <dfeuer> ReinH, I still have no idea what limits are :-(
13:13:34 <ReinH> Then maybe!
13:13:41 <dmwit_> elliptic00: Looks about right to me, though it's been quite a while since I did any Java.
13:13:47 <joncol> Is there some way to configure hindent to force lines to be shorter than the limit configured in .hindent.yaml? Currently, it sometimes doesn't force the lines to be below < 80 it seems :/
13:13:59 <ReinH> dfeuer: https://www.youtube.com/watch?v=g47V6qxKQNU&list=PLUWfjhrIRed9sS4Odgknc4EF7bvjqL-VK !
13:14:29 <elliptic00> dmwit_ thx
13:14:32 <dfeuer> ReinH, have you looked at the new Data.Map.Lazy.Merge stuff yet?
13:14:49 <ReinH> dfeuer: That's Ed's stuff? Or something else?
13:14:59 <ReinH> Oh the new IntMap was Ed's stuff
13:15:04 <dfeuer> ReinH, no, it's mine :-).
13:15:07 <ReinH> yay!
13:15:11 <ReinH> Then no :)
13:16:20 <dfeuer> Well, I want to change the representation of the WhenMissing merge tactics to support more efficient Functor, Applicative, Category, and Profunctor instances.
13:16:38 <Cale> hehe
13:16:50 <dfeuer> Wren Romano simultaneously wants to be able to use the same tactic types for both Map and IntMap.
13:17:07 <dfeuer> Jonathan S. simultaneously wants to replace Data.IntMap.
13:17:16 <ReinH> haha
13:17:22 <ReinH> progress is progressing
13:17:36 <dfeuer> Wren's simple idea of adding a parameter to the merge tactic representing the map type doesn't work for Jonathan's IntMap merge draft.
13:17:44 <dfeuer> (for his IntMap replacement).
13:18:30 <dfeuer> So what I think we need instead is to generalize that parameter enough to cover a lot more bases. This starts, I think, with a Category that's "very strongly connected" in the sense discussed,
13:18:46 <dfeuer> but I think it likely needs some extra stuff to handle Applicative.
13:19:21 <buglebudabey> is something derived enum, if i do succ on the last element will it go back to the first?
13:19:38 <yiimi> import Network.Wreq ... r <- get "http://example.com/foo.png" ... import Data.ByteString as B ... B.writeFile "/Users/yuumi/monkey.jpg"  Couldn't match expected type ‘ByteString’ Data.ByteString.Lazy.Internal.ByteString’
13:19:57 <lgstate> what I would give for a haskell with clojure's tooling
13:20:02 <dfeuer> For Map, that parameter will be something like   newtype Foo f k a b = Foo (Map k a -> f (Map k b))
13:20:07 <Cale> lgstate: What in particular?
13:20:24 <dfeuer> For IntMap, it may end up being some sort of bundle of functions of different types.
13:20:37 <glguy> yiimi: The bytestring package has multiple varieties of ByteString, strict and lazy are the main two. You'll need to use the one that corresponds to Wreq
13:20:42 <Cale> lgstate: I remember you had a question the other day that I was going to say something about, but you left before I saw it, and I can't remember now what it was...
13:21:06 <lgstate> Cale: was it dealing with http://www.parens-of-the-dead.com/
13:21:13 <lgstate> I've been going around saying how awesome that screencast it
13:21:20 <yiimi> glguy: okay, i saw lazy bytestring, i guess there's a variant of writeFile which deals with lazy bytestrings
13:21:51 <glguy> yiimi: The modules are listed at http://hackage.haskell.org/package/bytestring , note the Lazy variety
13:22:06 <dfeuer> Oh wait, probably just     newtype Foo k a b = Foo (Map k a -> Map k b).  I forgot. Yeah.
13:22:19 <Cale> lgstate: Oh, maybe it was the question about transducer...
13:22:30 <lgstate> Cale: that's right, I did have such a question
13:22:36 <yiimi> import Data.ByteString.Lazy as L ... L.writeFile "/Users/yuumi/monkey.jpg" r ... Couldn't match expected type ‘L.ByteString’ with actual type ‘Response L.ByteString’
13:22:43 <lgstate> how would transducers look like in haskell?
13:22:52 <lgstate> I'm watching a series of webcasts on implementing mini kanren without monads
13:22:54 <dfeuer> The most annoying thing is that *all* these functions will actually always be one or more identity functions, but Haskell 2010 doesn't let us say so.
13:22:55 * hackagebot synthesizer-filter 0.4.0.2 - Audio signal processing coded in Haskell: Filter networks  https://hackage.haskell.org/package/synthesizer-filter-0.4.0.2 (HenningThielemann)
13:22:57 * hackagebot synthesizer-filter 0.4.1 - Audio signal processing coded in Haskell: Filter networks  https://hackage.haskell.org/package/synthesizer-filter-0.4.1 (HenningThielemann)
13:22:59 * hackagebot haskore-synthesizer 0.0.3.3 - Music rendering coded in Haskell  https://hackage.haskell.org/package/haskore-synthesizer-0.0.3.3 (HenningThielemann)
13:22:59 <lgstate> and the author is claiming that he cn do it with transducers instead
13:23:01 * hackagebot conduit-connection 0.1.0.3 - Conduit source and sink for Network.Connection.  https://hackage.haskell.org/package/conduit-connection-0.1.0.3 (slomo)
13:23:03 * hackagebot hOpenPGP 2.5.5 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.5.5 (ClintAdams)
13:23:42 <Cale> I recall there was a bunch of discussion about how best to translate transducers into Haskell -- there are a bunch of approaches depending on whether you care about effects.
13:24:40 <Cale> https://www.reddit.com/r/haskell/comments/2cv6l4/clojures_transducers_are_perverse_lenses/cjjyay7
13:25:11 <Welkin> what is a transducer?
13:25:32 <ReinH> > succ () -- buglebudabey 
13:25:34 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
13:25:39 <adam__> with natVal I can natVal (Proxy :: Proxy 3) == 3.  Is there a library with listVal (Proxy :: Proxy '[1,2]) = [1,2] ?
13:25:41 <Cale> http://hypirion.com/musings/haskell-transducers -- there's a bunch of stuff here where he ends up talking about Conduit toward the end
13:25:52 <Cale> and, well, Pipes is another thing similar to Conduit
13:25:53 <lgstate> Cale: thanks
13:25:58 <lgstate> Cale: will look into it and bug you later
13:26:26 <yiimi> needed r ^. responseBody
13:26:28 <lgstate> I'm currently having such divided loyalties between clojure and haskell
13:26:29 <dfeuer> ReinH, maybe you can figure out how to make Jonathan S.'s new IntMap (which he based on Ed's blog post, but made some big changes to) a little more understandable and less painful.
13:26:33 <yiimi> not the actualy Response
13:26:37 <lgstate> it's pretty crazy
13:26:42 <ReinH> dfeuer: maaaaaybe
13:27:33 <dfeuer> Or faster, of course. One question in our minds is whether to inline one level of Node into IntMap_, making IntMap = IntMap_...
13:27:46 <buglebudabey> ReinH what were you trying to show
13:27:56 <Cale> lgstate: Basically those are used to handle fancy streaming I/O situations in a way that lets you compose things together nicely (actually, that's a bit less general of a description than the reality of it, but it's what most people use them for)
13:28:27 <lgstate> Cale: but it's not fmap
13:28:46 <jle`> adam__: i had a library up that could do that, but it turns out that 'singletons' can do that pretty much already
13:28:53 <jle`> adam__: so my library was a little redundant haha
13:28:55 <Welkin> > 2 + 2
13:28:57 <lambdabot>  4
13:29:03 <dfeuer> singletons is a little complicated.
13:29:04 <Welkin> just checking
13:29:06 <jle`> adam__: with the singletons package, it's fromSing (sing :: Sing '[1,2,3])
13:29:07 <jle`> ta dah :)
13:29:44 <jle`>  > fromSing (sing :: Sing '[1,2,3])   -- ==> [1,2,3]
13:29:46 <adam__> jle`: thanks!
13:29:50 * dfeuer looks forward to the day (soon, I'm told!) when the singletons package will be pretty much obsolete.
13:30:03 <jle`> adam__: it also works with normal nats too --- fromSing (sing :: Sing 3) == 3
13:30:15 <ReinH> buglebudabey: that enum instances are not circular
13:30:23 <buglebudabey> oh well thats lame
13:30:31 <ReinH> No it isn't.
13:30:40 <buglebudabey> ReinH is there any way i can make a circular enumerable type
13:30:42 <jle`> if by lame you mean useful, then yeah :)
13:30:46 <Cale> lgstate: fmap is sort of a general interface to the idea of "apply this function to all the elements of this data structure" or "apply this function to all the results of this computation"
13:30:49 <ReinH> Yes. Make one.
13:30:50 <jle`> buglebudabey: it's pretty straightforward
13:30:52 <dfeuer> Enum is a broken class.
13:30:56 <jle`> data Foo = A | B | C
13:31:04 <dfeuer> Don't bother trying to make sense of it; it's senseless.
13:31:06 <ReinH> Define your own successor function for your type.
13:31:07 <jle`> cyclic A = B; cyclic B = C; cyclic C = A
13:31:10 <jle`> :)
13:31:27 <jle`> haskell doesn't force you to use the Enum typeclass to enumerate your type
13:31:36 <jle`> hooray for freedom
13:31:40 <buglebudabey> thanks jle` i didn't know if there was anything more i could do in the data declaration itself :P
13:31:50 <dfeuer> Seriously, Enum has absolutely no value as an abstraction. It's only there for convenience and confusion.
13:32:06 <jle`> it's basically the typeclass of things that can be [1 ... ]'d
13:32:12 <ReinH> dfeuer: it would have value for Nat, and things isomorphic to Nat.
13:32:16 <dfeuer> And its succ and pred methods aren't even useful.
13:32:36 <ReinH> Well, with pred it isn't even valuable for Nat
13:32:39 <dfeuer> ReinH, if you had a saturated pred, I guess.
13:32:50 <dfeuer> But the standard bounded types error or pred 0.
13:32:52 <dfeuer> Ugh.
13:33:13 <dfeuer> ReinH, also, fromEnum is partial on Nat.
13:33:26 <dfeuer> The whole thing is a disgusting kluge.
13:33:36 <Cale> lgstate: It's actually backwards
13:34:01 <Cale> lgstate: Given a function (b -> a), we get a transducer (x -> a -> x) -> (x -> b -> x)
13:34:28 <ongy> :t fromEnum
13:34:29 <lambdabot> Enum a => a -> Int
13:34:59 <dfeuer> We should have  class FromInt a where fromInt :: Int -> a, class ToInt a where toInt :: a -> Int, and then figure out what to do with the rest quite separately.
13:35:27 <jle`> but what bout efficient [x..y] syntax
13:35:31 <nitrix> dfeuer: No love for Integer o: ?
13:35:44 <Cale> lgstate: So it's an example of a "contravariant functor" http://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html
13:35:46 <dfeuer> jle`, there's no reason to lump that together with toEnum or fromEnum.
13:35:58 <jle`> i mean, so what do we use to implement it
13:36:13 <dfeuer> nitrix, Integer is handled with Num and Integral, a different pile of worms.
13:36:16 <jle`> replace Enum with something with a different name but the same problems?
13:36:19 <nitrix> dfeuer: class Integral a => FromIntegral b where fromIntegral :: a -> b
13:36:26 <ReinH> succLess :: Enum a => a -> Maybe a
13:36:30 <dfeuer> nitrix, what does that even mean?
13:36:32 <ReinH> and an unfold
13:37:11 <nitrix> dfeuer: You could define an instances for any types of your choice, of what it means to convert an Integral to it.
13:37:27 <dfeuer> niteria, that isn't valid Haskell.
13:37:44 <dfeuer> er.. nitrix 
13:37:44 <jle`> ReinH: that'd be nice for the [x..y] syntax i suppose
13:37:58 <ReinH> jle`: Mostly I wanted to make the pun before anyone else did
13:37:59 <dfeuer> :i Enum
13:38:39 <nitrix> dfeuer: Why not?
13:38:40 <Cale> Yeah, I think in some kind of ideal world we would just have Enum be the class for defining the four list enumeration syntaxes
13:38:48 <Cale> and the rest of it isn't important enough
13:38:54 <dfeuer> Enum isn't even a subclass of Eq or Ord.
13:39:20 <nitrix> dfeuer: Sorry, make it `FromIntegral a b`
13:39:26 <ReinH> Wait, didn't Wadler or someone already make that joke?
13:39:32 <ReinH> or a similar one
13:39:39 <jle`> it's been made but not in this current conversation
13:39:44 <jle`> so you still get points
13:39:47 <Cale> which joke?
13:39:59 <Cale> oh, the succLess one?
13:40:00 <dfeuer> The fact that the list enumeration things are only good for lists is another problem.
13:40:32 <dfeuer> In fact, IIRC, there aren't enough simplifier phases to be able to intercept them to make something that works well for other sequence types.
13:40:36 <ReinH> jle`: succLess is the canonical unfold for the cofree comonad for lists (Cofree Maybe) :)
13:41:02 <dfeuer> Thus Data.Sequence.fromFunction is a *much* better way to make Seq enumerations than fromList [x..y]
13:41:04 <ReinH> coiter succLess :)
13:41:34 <ReinH> non-empty lists, rather
13:41:47 <ReinH> so it's even better than enumFrom
13:41:53 * dfeuer empties ReinH's list into a bucket and dumps it in the trunk of his car.
13:41:56 <jle`> i feel like you should just do it per-container type anyways
13:42:08 <jle`> the types in 'vector' have `generate`
13:42:20 <Cale> lgstate: At some point I plan to make a game with reflex-dom, and I don't know what for the backend... maybe I'll be able to make some tutorials related to it, but I'm not sure they'll be as polished as the ones you linked.
13:42:41 <lgstate> Cale: it may also be that I know no clojure
13:42:46 <ReinH> Cale: that would be great. I started working on one but put it aside out of... uh... something...
13:42:52 <lgstate> so when I watched the videos, I was being impressed every 10 seconds
13:42:55 <lgstate> like wtf, you can do that?
13:42:58 <ReinH> It was hard to learn reflex-dom at the time
13:43:10 <lgstate> i.e. the impressiveness of the videos may have breen related to my noobiness at clojure
13:43:13 <lgstate> (and emacs)
13:43:27 <jle`> dfeuer: the problem with fromList [x..y] is similar to the problem of fromString, ain't it
13:43:35 <dfeuer> jle`, definitely. The trouble, of course, is that you don't get the pretty syntax. You could change IsList to do something smart, but then you'd have to use Integral rather than Enum. Or something.
13:43:56 <dfeuer> Honestly, I'd be much happier making enumerations an Integral thing.
13:43:57 <jle`> so what's the fix, better literals?
13:44:34 <jle`> haskell was invented in a type when literal theory wasn't too developed
13:44:41 <dfeuer> So we'd have a class for enumerable *sequences*, which would have enumFromTo :: Integral a => a -> a -> t a  or whatever.
13:44:52 <Cale> lgstate: I'm sure I could make some rather impressive demo videos if I planned things out -- it's really fun to be able to write a few lines of code and get interactively updating web application UIs running in your browser :)
13:44:53 <dfeuer> I know no literal theory.
13:45:12 <jle`> i made up the word but i'm sure there is such a thing v.v
13:45:13 <ReinH> dfeuer: theory of literals?
13:45:17 <dfeuer> And a subclass for potentially-infinite enumerable sequencing with enumFrom.
13:45:41 <dfeuer> ReinH, right, I know no such theory. I'm not saying it doesn't exist. I'm not saying it's not important. I'm saying I've never heard of it.
13:45:46 <dfeuer> or am I being too literal?
13:45:48 <lgstate> Cale: yeah; feedback is awesome
13:45:51 <ReinH> Cale: Sure, but you must be wiling to spend a few hours getting ghcjs and reflex-dom to build and run ;)
13:45:56 <jle`> but i feel like some languages written recently seem to be able to learn from a history of bad literal syntax in programming languages
13:46:08 <jle`> so there is some informal theory of literals being gathered by language developers somehow
13:46:28 <lgstate> Cale: the one thing I don't like about haskell is that there seems this massive mental energy requirement upfront (and I'm not referring to deciding the datatypes)
13:46:29 <ReinH> Formal PLT considers literals to be an implementation detail ;)
13:46:30 <ongy> jle`: do you have an example for that?
13:46:41 <jle`> no i was hoping nobody would ask
13:46:49 <Cale> ReinH: reflex-platform is a thing! :)
13:46:54 <Cale> ReinH: That's all I ever use
13:46:55 <ReinH> Cale: Hmm.
13:47:07 <Cale> https://github.com/reflex-frp/reflex-platform
13:47:16 <ReinH> lgstate: as opposed to other sorts of programming, which don't require thinking things through?
13:47:19 <jle`> what do i look like, a literal theorist?
13:47:43 <dfeuer> Rrr... I guess Integral doesn't exactly cover what I mean. Argh. We have issues.
13:47:44 <ReinH> Also riding a bike requires much more effort up front if you have never ridden a bike before
13:47:49 <Cale> clone that repo -> type ./try-reflex -> some downloading of binaries occurs -> you have a working ghcjs 8 and ghc 8
13:47:50 <lgstate> ReinH: as opposed to writing 1 function, seeing the new feature; then writing another function, and seeing that feature, i.e. incrementally
13:47:55 <Cale> with reflex-dom and such
13:48:12 <lgstate> ReinH: I've written non-trivial haskell programs.
13:48:13 <ReinH> lgstate: Why can't you do that with Haskell (assuming you can write a new feature by writing one function at all)
13:48:18 <dfeuer> Cale, PM if you have a minute.
13:48:25 <Cale> dfeuer: sure
13:48:35 <lgstate> ReinH: clojure has something called 'component' which makes it easy to *persist state* while hot reloading code
13:48:49 <lgstate> ReinH: I supose this is possible in ghcjs/ghc if you stored state cserver side, then had client reload the full state
13:49:00 <Cale> lgstate: I mostly *do* build things incrementally...
13:49:02 <lgstate> ReinH: but it works automaticlaly 'for free' in clojure if you just follow a certain pattern
13:49:21 <lgstate> Cale: alright, maybe I'm just a bad haskel lprogrammer, and Cale needs to provide some videos I can learn from :-)
13:49:32 <ReinH> So your specific critique is that Haskell doesn't have a good hot code reloading story?
13:50:05 <Cale> Maybe I should do, like, a reflex-dom twitch stream or something. Kappa
13:50:11 <ReinH> Cale: do it
13:50:13 <ReinH> do it right now
13:50:26 <ReinH> also: Kappa
13:50:36 <ongy> Cale: get access to the programming acount
13:50:51 <lgstate> ReinH: there's other nice things with hot reloading; in clojure, to add a new dependency, it's C-c r a p .. emacs downloads list of all potential packatges ... I can narrow them, and emacs shows versions, and I pick one -- and it's hot reloaded. In haskell, it's (1) look on hackage, (2) edit stack.yaml, (3) restart ghci,
13:51:06 <lgstate> ReinH: the overall experience is just much smoother
13:51:12 <Cale> ongy: ?
13:51:20 <ReinH> I wonder if that mnemonic was chosen on purpose or by happy accident
13:51:35 <ReinH> And that's not a facility of the *language*, it's a facility of the *tooling*.
13:51:47 <glguy> Wow, the keyboard sequence is "crap" to get a new package? That seems awfully honest
13:52:00 <grantwu> I imagine hot code reloading is harder with static typing?
13:52:12 <jle`> how do you figure?
13:52:17 <jle`> i feel like it'd be even easier
13:52:20 <lgstate> ReinH: my original statement was ' what I would give for a haskell with clojure's tooling' -- I'm not sure what you are referring to
13:52:31 <ReinH> GHC supports hot code reloading, we just don't market it very well
13:52:33 <lgstate> glguy: lol, C-c r = clj-refactor, a p = add artifact (pckage?)
13:52:36 <grantwu> jle`: You can't make changes that would break type checking, I guess
13:53:09 <jle`> well ... those are changes that would create breaking code anyways
13:53:15 <ongy> Cale: a new twitch user that as far as I understand it, can be used for programming podcasts or similar. Though I have not seen it in action yet
13:53:22 <ReinH> lgstate: I agree about the tooling, but I was responding to "the one thing I don't like about haskell is that there seems this massive mental energy requirement upfront"
13:53:35 <grantwu> jle`: not necessarily, I think
13:53:51 <Cale> ongy: I think any twitch user now is allowed to do programming streams as far as I know
13:53:57 <ReinH> ongy: Can't he just create his own account?
13:54:23 <ongy> programming is something twitch official-ish. Though I'm not quite sure
13:54:31 <Cale> I have an account, but I haven't used it in a while. I'll need to get OBS set up on this machine.
13:54:41 <ongy> Cale: last time I checked (~4months ago) it was still required to be games for twitch
13:54:44 <grantwu> jle`: Consider optional fields in protobufs
13:54:55 <lgstate> ReinH: yeah; about that; it feels lik in clojure, I can *explore* the space of the code I want to write; whereas in haskell, I need to have mentally visualized the code before I can write it
13:55:15 <lgstate> in clojure, it seems i can do "not working code" -> "sorta working code" -> "w2orking code"
13:55:19 <ReinH> Do you think that's a function of the language or your familiarity with the language?
13:55:24 <lgstate> and in haskell it's "think a lot" -> "working code"
13:55:34 <ReinH> I do a lot of the former, especially via holes
13:55:48 <lgstate> ReinH: I've done about 5 years or so of haskell and read RWH, LYAH, and done a few projects in haskell
13:55:51 <lgstate> but never as a full time job
13:55:56 <ReinH> Haskell is my favorite language for incremental development
13:56:02 <Cale> ongy: They've had "Creative" as an option for a while now
13:56:24 <glguy> Yeah, the types make exploration much more manageable
13:56:27 <Cale> If you put in "Programming" as your "game" it'll select "Creative" for you
13:56:31 <ReinH> let thingIDon'tKnowHowToDoYet = undefined in complexThing involving thingIDon'tKnowHowToDoYet
13:56:32 <Welkin> people use twitch to stream themselves playing musical instruments too
13:56:35 <glguy> I can change things and follow the types to see what I broke
13:56:43 * jonored /loves/ the "fiddle in ghci, add that function to the source file, fiddle in ghci some more..." thought process.
13:57:03 <ReinH> And then, when I'm ready to implement it, I start with complexThing involving _thingIDon'tKnowHowToDoYet and GHC tells me what type it is, which is the first step in knowing what value it should be.
13:57:23 <ReinH> And I can give GHC some guidance via a top-level type declaration
13:57:32 <dfeuer> Cale, you finally have a non-trivial actual PM from me.
13:57:39 <zyhn> "think a lot" -> "working code" is my ideal
13:57:45 <Cale> dfeuer: yeah, I see :)
13:57:57 <glguy> Cale: dfeuer sent you another message, fyi
13:58:41 <ReinH> This sort of top-down type-driven design has been very successful for me, and for others.
13:59:05 <jonored> I think I'm at "think a lot" -> "GHC says I'm wrong" -> "think some more" -> ... -> "working code" more than "think a lot" -> "working code", but I like that too :)
13:59:35 <ReinH> And it's also bottom-up, type-driven implementation, which means you naturally solve large problems by dividing and conquering them.
13:59:57 <ReinH> This is something I can't do with the same facility in most other languages, since they are not composable in the same way.
14:00:00 <Cale> glguy: I acknowledge your notification that dfeuer sent me another message.
14:00:18 <ReinH> Cale: glguy told you that dfeuer sent you another message, fyi
14:00:20 <ReinH> oh too late
14:00:59 <Cale> glguy: ReinH told me that you told me that dfeuer sent me a message, fyi.
14:01:16 <ReinH> dfeuer: I believe Cale is aware of your message.
14:01:52 <dfeuer> I believe that this is getting boring. I alerted Cale here only because he has a certain tendency not to notice PMs. Wasn't trying to lead to exponential noise :P
14:02:05 <jle`> > text $ fix (("Cale: " ++) . ("dfeuer: " ++ ) . ("glguy: " ++))
14:02:12 <lambdabot>  mueval: ExitFailure 1
14:02:20 <jle`> does that not work this way lol
14:02:32 <jle`> > fix (("Cale: " ++) . ("dfeuer: " ++ ) . ("glguy: " ++))
14:02:35 <lambdabot>  "Cale: dfeuer: glguy: Cale: dfeuer: glguy: Cale: dfeuer: glguy: Cale: dfeuer...
14:02:43 <dfeuer> :t text
14:02:45 <lambdabot> String -> Doc
14:03:08 <Cale> glguy: dfeuer believes that this is getting boring. He alerted me here only because I have a certain tendency not to notice PMs. He wasn't trying to lead to exponential noise, fyi.
14:03:23 <glguy> So pretty, the colors our names hash to work well together: http://imgur.com/a/LJP9f
14:03:34 <glguy> Cale: Thanks, I'll let ReinH know
14:09:44 <tommd> glguy: Can you ban glguy?  His presence in the channel is causing other people to spam using his name.
14:10:04 <glguy> You're the boss
14:10:09 --- mode: ChanServ set +o glguy
14:10:09 --- mode: glguy set +b *!*@haskell/developer/glguy
14:10:09 --- kick: glguy was kicked by glguy (for tom)
14:10:30 <MarcelineVQ> finally
14:11:52 <Hafydd_> What?!
14:13:56 <ReinH> dfeuer: I disagree. I think has been boring at all points in time.
14:14:10 <ReinH> continuously, I might add
14:14:44 <ReinH> Oh also maybe someone should unban glguy...
14:15:14 <dfeuer> Yeah, I would think so. He's helpful as well as pretty.
14:17:14 --- mode: ChanServ set -b *!*@haskell/developer/glguy
14:18:21 <yulax>  /buffer weechat
14:22:57 * hackagebot synthesizer-core 0.8.0.2 - Audio signal processing coded in Haskell: Low level part  https://hackage.haskell.org/package/synthesizer-core-0.8.0.2 (HenningThielemann)
14:22:59 * hackagebot eventstore 0.13.1.5 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.1.5 (YorickLaupa)
14:23:01 * hackagebot kontra-config 0.1 - JSON config file parsing based on unjson  https://hackage.haskell.org/package/kontra-config-0.1 (MikhailGlushenkov)
14:23:03 * hackagebot monad-logger-prefix 0.1.6 - Add prefixes to your monad-logger output  https://hackage.haskell.org/package/monad-logger-prefix-0.1.6 (parsonsmatt)
14:31:12 <lgstate> ReinH, Cale, glguy: I have a slightly less ambigious descrition of 'haskell vs clojure' -- in clojure, 'interactive' tends to mean 'write some code, test it'; -- in haskell, atleast to me, 'interactive' tends to mena 'write some code; type check it' ;; and somehow, running it and seeing results makes it feel better
14:31:37 <ReinH> Well, we do necessarily have a "type check it" step before running it
14:31:50 <alexKosh> let say I have [(Double,Double)], I can save it to file with something like: writeFile "file" . unlines . map (\x y -> show x ++ " " ++ show y). Is it a good practice to do it this way? or I should prefer some other libraries for this? related tasks?
14:32:14 <Cale> lgstate: Well, you can also run it...
14:32:40 <lgstate> Cale: yeah, but the 'testing' code often tends to be ill forammtted and easiedr to setup in clojujre than in haskell
14:32:44 <ReinH> alexKosh: You don't need to unlines, you can just show it and write then, then read the file and `read` the value. This might not be ideal, and at the least a safe read function should be used to avoid runtime errors.
14:33:12 <ReinH> You can also pick some other encoding. In practice, JSON is often a good middle ground between machine parsable and human readable.
14:33:19 <ReinH> Or you can use a binary encoding.
14:33:20 <glguy> lgstate: Yeah, that's what I do, write some code, try it in GHCi
14:33:43 <ReinH> Lots of people do repl-driven development with Haskell though, via GHCi
14:34:07 <ReinH> but there's no point in running your code if it doesn't typecheck, so think of it as GHCi not wasting your time. ;)
14:34:28 <alexKosh> ReinH, well, I need colums =) without [(,)] etc, (for example for gnuplot to understand it
14:34:54 <ReinH> alexKosh: If you're writing to a file for some purpose, you should certainly do something that makes sense for that purpose.
14:35:08 <ReinH> But that wasn't clear from your question.
14:35:20 <jonored> half of my actual practical usage is just GHCi with some libraries loaded.
14:36:08 <ReinH> You might have more success with CSV, since it's a defined format with existing implementations
14:36:18 <ReinH> and, to the point, one that gnuplot can read
14:37:04 <alexKosh> well, so use CSV library is better practice? then just prelude writeFile?
14:38:14 <ReinH> If the goal is to write something that gnuplot can read, I'd say CSV is a better idea than some ad hoc thing
14:38:32 <ReinH> since CSV is well defined and gnuplot can read CSV files
14:38:49 <ReinH> I wouldn't call it a "practice" as much as a "solution to the problem you posed".
14:38:50 <dfeuer> Caution: the cassava CVS library is pretty nice if and only if you're handling CSV the way it thinks you want to. It has two modes, but some bits are only available in one or the other, which can be annoying.
14:39:11 <dfeuer> But for use with labeled columns, it's pretty sweet.
14:43:04 <ph88> what's this at step 2 ?   https://hackage.haskell.org/package/gdiff-1.1/docs/Data-Generic-Diff.html#t:Family
14:43:19 <ph88> Create a family datatype, grouping your datatypes together.
14:43:52 <alexKosh> thanks
14:44:01 <MarcelineVQ> ph88: it shows you if you keep reading
14:44:27 <ph88> ah right .. i was literally taking it line by line :p
15:01:15 <xuxu>   let cars = run h $ table "cars" :: IO [Datum] -- using the rethinkdb driver
15:01:28 <xuxu> firstCar = take 1 $ map (\x -> x) cars
15:01:44 <xuxu> firstCar looks like [{"image":"...","thumb":"...","owner":"...","location_address":"...","year":2013,"id":"03261c6125b365086cb53b2","tax":3.5,"price":120000,timestamp":Time<2016-07-19 22:41:55.455 +0000>}]
15:02:10 <xuxu> firstCar :: [Datum]
15:02:18 <xuxu> i'm told that's an array of objects
15:02:22 <xuxu> https://hackage.haskell.org/package/rethinkdb-2.2.0.6/docs/src/Database-RethinkDB-Datum.html#Object
15:02:40 <xuxu> which means i might should use the hashmap lookup function
15:02:42 <xuxu> https://hackage.haskell.org/package/hashmap-1.3.1.1/docs/src/Data-HashMap.html#lookup
15:03:17 <xuxu> HM.lookup "timestamp" firstCar -- Couldn't match expected type ‘Map [Char] a’ with actual type ‘[Datum]’
15:04:01 <xuxu> this is where i'm at
15:04:05 <joncol> Hi, in the documentation for Data.List.unfoldr it says: "The function takes the element and returns Nothing if it is done producing the list or returns Just (a,b), in which case, a is a prepended to the list and b is used as the next element in a recursive call." Is that a typo? "a prepended" that is...
15:09:18 <xuxu> is Map [Char] a of kind * -> * ?
15:11:05 <ph88> can you put a do statement after a  let .. in ?
15:11:09 <ph88> after in
15:11:17 <amalloy> xuxu: Map [Char] is
15:11:29 <amalloy> Map [Char] a is of kind *
15:11:57 <grantwu> ph88: a do statement is just syntactic sugar for a bunch of compositions with bind; it's just an expression that has a monadic type
15:12:02 <geekosaur> looks like a straightforward type mismatch to me, Datum is a RethinkDB sum type, it is not a Map anything
15:12:12 <xuxu> amalloy: if you don't mind me asking, how did you know that?
15:12:42 <amalloy> because i know Map takes two type arguments, so if you specify both you will get a concrete type, which is kind *
15:13:20 <amalloy> if you specify fewer than two, you get a "type function", a kind with more arrows in it (someone else will know better words for what i'm trying to say)
15:13:57 <glguy> xuxu: In GHCi you can type ":k Map" to discover that it's a type with kind * -> * -> *
15:14:18 <Cale> :k Map
15:14:22 <lambdabot> error:
15:14:22 <lambdabot>     Not in scope: type constructor or class ‘Map’
15:14:22 <lambdabot>     Perhaps you meant one of these:
15:14:25 <Cale> aww
15:14:29 <Cale> :k Data.Map.Map
15:14:32 <lambdabot> * -> * -> *
15:14:43 <Cale> :k Data.Map.Map [Char]
15:14:44 <lambdabot> * -> *
15:14:47 <Cale> :k Data.Map.Map [Char] Integer
15:14:48 <lambdabot> *
15:15:01 <geekosaur> so it looks to me like you have a Datum which si presumably an Object (data constructor), and *that* is a HashMap Text Datum
15:15:15 <geekosaur> so you need to pattern match the Datum to get the HashMap
15:15:45 <xuxu> thanks geekosaur, that will take me about an hour :)
15:16:29 <jle`> :k forall a. Data.Map.Map [Char] a
15:16:30 <lambdabot> *
15:16:35 <geekosaur> getMap :: Datum -> Maybe Object; getMap (Object m) = Just m; getMap _ = Nothing
15:16:53 <xuxu> oh, maybe, i can do something like case Datum -> ...
15:18:14 <jle`> jonored: sounds like a typo yes
15:18:30 <dmwit> He's gone.
15:19:02 <jle`> oh, sorry j
15:40:12 <Sinestro> I'm getting a ton of linker errors where symbols from one particular file (or so I can guess from the mangled names) aren't getting found
15:41:21 <Sinestro> I've tried cleaning things out, but deleting my .stack-work directory and trying to build it again gives the same error.
15:42:15 <Sinestro> They're symbols of the form "_popperzmlangzm0zi1zi0zi0zm4s42cPS1cTb7rhNCTyeqAG_PopperziParserziTokenizzerziTypes_Literal_con_info", for the most part
16:07:49 <fred-fri> in java, pairs and tuples are discouraged, how common are they in haskell?
16:08:11 <benzrf> since when does java *have* pairs and tuples?
16:08:54 <mkaa> http://lpaste.net/208167 hello, So im asked to implemente a function to get the n tetronacci number (basically the sum of last four) in a recursive function but with linear time, Im not sure if that's what I did? would someone mind explaining plz
16:10:48 <jle`> fred-fri: 3-pls and higher are generally discouraged
16:11:24 <jle`> fred-fri: pairs are technically not ideal when there are alternatives, but people probably wouldn't get mad at you
16:11:31 <fred-fri> benzrf, java doesnt have a pair or a tuple class becuase its seen as suboptimal, thats the point. (though abstractmap.immutableentry is effectively a sneaky pair) so i was wondering how common it is in haskell
16:11:41 <benzrf> jle`: ha, 3-pl
16:12:09 <jle`> wait is there a better word for threeples >_>
16:12:19 <Koterpillar> triplets?
16:12:33 <glguy> I use 3-tuple
16:12:46 <jle`> oh yeah triples are a thing
16:13:17 <jle`> fred-fri: the problem with triples is that you don't really have any semantics as to what each of the components mean
16:13:40 <benzrf> jle`: i just found it funny
16:14:05 <jle`> in haskell it's easy to create your own data type with three fields --- data types are cheap in haskell, and you can give them meaningful names and stuff too
16:14:12 <jle`> and meaningful field names
16:14:22 <Koterpillar> and instances
16:14:23 <jle`> also in some cases, tuples might be un-ideal because they are lazy
16:14:24 <grantwu> I think they're useful when you want to return a bunch of things?
16:14:33 <augur> is anyone familiar with Cloud Haskell?
16:14:44 <jle`> grantwu: i wouldn't return a 4-tuple
16:14:51 <jle`> it'd make more sense to make a data type that has four fields
16:14:53 <grantwu> jle`: Well yeah
16:15:20 <shirt> my guess is that most haskell libraries and programs use a tuple at least *somewhere*
16:15:31 <jle`> yeah, tuples are fairly harmless
16:15:38 <Koterpillar> :t runState
16:15:40 <lambdabot> State s a -> s -> (a, s)
16:15:46 <jle`> but anything bigger then you should start rethinking it
16:16:21 <jle`> it's a lot easier to make a throwaway data type in haskell than it is in java, and also more idiomatic
16:16:40 <jle`> oh, and haskell style discourages functions taking tuples as input
16:16:50 <jle`> in favor of curried functions
16:17:23 <jle`> ie, instead of foo :: (Int,Bool) -> String, foo :: Int -> Bool -> String is preferred
16:20:50 <ertes> fred-fri: tuples model what you may know as "cartesian products" in set theory, and sometimes that is exactly what you need, particularly when you're writing a function *on* pairs of data without giving either component a special meaning
16:20:54 <ertes> fred-fri: example:
16:20:56 <ertes> :t zip
16:20:58 <lambdabot> [a] -> [b] -> [(a, b)]
16:22:07 <augur> does anyone know how, in cloud haskell, to send a message to a node at a given IP and port??
16:22:43 <ertes> fred-fri: unlike java though you encounter lots of these functions in haskell, so you could say that tuples are a lot more sensible and prevalent in haskell
16:22:55 <augur> its unclear to me how this should happen. in fact, it's unclear if this even makes any sense
16:26:22 <pikajude> what's the best way to figure out where my "Connection refused" exception is coming from?
16:26:45 <Koterpillar> pikajude: strace?
16:26:46 <johnw> if you build with profiling, you can use -xc
16:27:38 <pikajude> well, i have to use the repl because the regular build makes a dylib that's apparently too big
16:27:41 <pikajude> according to macOS Sierra
16:28:28 <geekosaur> known issue, ghc devs are working on it
16:28:42 <geekosaur> (load commands overflow, sierra introduced a 32k limit)
16:29:01 <geekosaur> (ghc binaries have far too many RPATH load commands in them)
16:29:06 <glguy> pikajude: Do you know about -fbreak-on-exception ?
16:29:09 <pikajude> yeah
16:29:18 <pikajude> when I break on the exception, I get a stack trace that is, uh
16:29:20 <pikajude> completely unrelated
16:29:59 <glguy> As an aside, how many places are you making network connections in this application that you're having trouble pinning down which one is failing?
16:30:00 <mniip> because it isn't a call stack
16:30:04 <Koterpillar> I stand by strace, it can attach to a process (though I don't know if whatever stands for it in macOS can)
16:30:09 <mniip> it's an evaluation stack
16:30:10 <pikajude> glguy: at least two
16:30:31 <johnw> dtrace can attach to a process also
16:31:02 <geekosaur> Koterpillar, on OS X^W^WmacOS it's dtruss and it has limitations in 10.11 and 10.12
16:31:06 <geekosaur> especially 10.12
16:31:48 <geekosaur> plus the default table sizes are far too small for many programs :/
16:33:06 <johnw> geekosaur: dtrace is a nicer CLI interface on top of dtruss
16:33:16 <johnw> dtruss is pretty.... raw
16:33:23 <pikajude> i thought it was the other way around
16:33:28 <geekosaur> ^
16:33:35 <johnw> oh, right you are
16:33:40 <geekosaur> dtrace is the low level probe interpreter
16:34:08 <geekosaur> dtruss is a trace application written in D (the dtrace script language)
16:34:18 <buglebudabey> can i patter much a tuple like so: (a@(x,y),b@(i,j))
16:34:35 <geekosaur> try it and find out? but it looks right to me
16:34:42 <glguy> buglebudabey: permission granted
16:34:48 <buglebudabey> woohoo
16:34:59 <buglebudabey> permission doesn't necessarily mean it's right though
16:35:25 <pikajude> just for a sampler, this is the part of code :hist highlights when I run it after breaking on exception: http://lpaste.net/6904105609868607488
16:35:56 <pikajude> that is this function, which cannot reasonably be expected to do a network connection: http://hackage.haskell.org/package/servant-swagger-1.1.2/docs/Servant-Swagger.html#v:toSwagger
16:38:10 <geekosaur> welcome to lazy evaluation? would guess that sub is the result of the network connection attempt in it and is being forced (thus forcing the connection) there
16:38:22 <pikajude> sub is a Proxy
16:38:28 <pikajude> how can that possibly be
16:39:01 <geekosaur> type level representation of either network events or errors
16:39:02 <cheater> hey guys, is there a way to make test-framework show me which quickcheck cases it's trying for a specific property while the test is running? all i see is "Test suite tests: RUNNING..." and i don't know what it's waiting for.
16:39:52 <geekosaur> but I don't know servant's internals (although I do know it uses type level stuff for that, if a Proxy weren;t enough of a hint)
16:40:19 <pikajude> i just don't understand how evaluating a Proxy would make the rts attempt a network connection
16:48:27 <augur> dcoutts: can i ask you a bunch of things about cloud haskell to clarify my understanding of it?
16:48:51 <dcoutts> augur: sure, note there's #haskell-distributed
16:48:56 <augur> oh!
16:52:39 <exio4> pikajude: evaluating a proxy doesn't do anything by itself
16:53:07 <exio4> pikajude: it carries the info to do something (with a function toSwagger using it)
17:00:41 <bob_twinkles> I'm just now diving in to exceptions and was wondering if someone could help me understand what's happening in this snippet http://lpaste.net/208174
17:01:27 <bob_twinkles> it appears that GHC is automatically implementing Typeable LoginException for me, since otherwise "instance Exception LoginException" would fail to compile (I think)
17:01:52 <bob_twinkles> is Typeable just special that way or does this behavior occur for other typeclasses?
17:03:29 <glguy> bob_twinkles: Typeable is special now, it is always automatically derived
17:03:45 <dmj`> isn't there a web browser written in haskell
17:04:10 <Koterpillar> dmj`: I've seen an example using Gtk
17:04:33 <bob_twinkles> ah, cool. Many thanks glguy
17:07:39 <dmj`> Koterpillar: seems like a browser would be perfect for haskell, parsing and concurrency
17:08:27 <Koterpillar> dmj`: and a lot of safety requirements
17:08:41 <Koterpillar> dmj`: agree, but reimplementing HTML and JS isn't a small task.
17:09:44 <dmj`> Koterpillar: heh, certainly. Browsers being the most used software of all time, might be worth it
17:11:21 <Koterpillar> dmj`: I suspect a lot of motivation for Rust was this
17:14:03 <cheater> this quickcheck property has been running for half an hour and i don't know what it's doing
17:14:27 <johnw> you'd also be hard-pressed to ensure there were no space leaks, of any size, since they'd accumulate over the day rather quickly
17:15:11 <Koterpillar> johnw: a lot of isolation?
17:15:21 <johnw> I don't think there's any language today that conbines both safe and well-performing with "easily written"
17:15:37 <lain666> what do people mean when they say haskell is pure?#
17:15:40 <johnw> lots of isolation does help, but it can also lead to laziness
17:15:45 <johnw> (of the human variety)
17:16:02 <johnw> lain666: it means that the type of function tells you what it does, with the exception of exceptions
17:16:14 * dmj` wonders if the quickcheck library is tested with quickcheck
17:17:06 <lain666> Can't find string terminator '"' anywhere before EOF at -e line 1.
17:17:45 <grantwu> johnw: What? How does that make sense
17:17:57 <johnw> grantwu: how does what make sense?
17:18:06 <grantwu> Tye type of the function tells you what it does
17:18:22 <johnw> a function Int -> Int has no side effects, but only computes from Int but Int
17:18:23 <Koterpillar> lain666: what languages, beyond Haskell, are you familiar with?
17:18:24 <grantwu> There are plenty of possible functions for nontrivial type signatures
17:18:40 <grantwu> Okay, yeah, but Int -> Int could be double, const 0 specialized, etc.
17:18:48 <johnw> in C, a function int foo(int) might literally do anything, with that behavior undetermined by the arguments in any way
17:19:00 <dmj`> lain666: IO is opt-in, you can't do anything like read/write to/from a network socket, print to the console, etc. 
17:19:04 <johnw> grantwu: I mean "what it does" in a more general way that how it does it
17:19:30 <grantwu> oh ok
17:20:05 <grantwu> I mean there's always unsafePerformIO :^)
17:20:38 <johnw> then I guess people say Haskell is pure because they are ignoring certain glaring details :)
17:21:56 <ZelteHonor> Does anyone know what happen with the Summer Of Haskell? 12 september was when the result should have been made public, but there is nobody speaking about it?
17:22:02 <orion> I have two Vectors. One is a sine tone and the other is a Hamming window. Both Vectors are of the same length. I want to multiply them together. Is V.zipWith (*) (hamming (V.length x)) x a valid way of achieving this?
17:22:10 <johnw> ZelteHonor: edwardk will know
17:23:01 * hackagebot servant-snap 0.7.0.2 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.7.0.2 (imalsogreg)
17:23:03 * hackagebot wild-bind 0.1.0.0 - Dynamic key binding framework  https://hackage.haskell.org/package/wild-bind-0.1.0.0 (debugito)
17:24:25 <ZelteHonor> Is there any news that I missed about it?
17:24:36 <johnw> s
17:24:41 <johnw> ZelteHonor: not that I'm aware of
17:29:52 <Darwin226> Hey guys. I think I've encountered a bug. I have an incoherent instance `instance {-# INCOHERENT #-} C a` and a regular instance `instance C T`. 
17:29:55 <Darwin226> Now I'm trying to use a method of that class on a value of type `F S` where `F` is a closed type family for which `F S = T`.
17:29:58 <Darwin226> For whatever reason the incoherent instance gets picked instead of the more specific one UNLESS I annotate the value, specifically saying it
17:30:00 <Darwin226> has the type `T`. Why doesn't the type family get resolved before the instance is picked?
17:30:12 <Darwin226> Anyone know what might be wrong?
17:31:19 <cheater> is there any way to load modules from my test suite in the repl?
17:32:00 <cheater> Darwin226: please post this to haskell-cafe
17:33:00 <Darwin226> It would take a considerable amount of effort to get a minimal example that demonstrates the problem. I just thought someone else might have experienced a similar thing and could point me in the right direction.
17:33:16 <dmj`> cheater: in haskell-mode for emacs I use haskell-session-change-target and it loads modules from the test-suite, I believe.
17:33:49 <Darwin226> Especially since it seems to stop working when I change unrelated things.
17:34:05 <dmj`> cheater: unsure how that's translated to ghci under the hood, but you might be able to ghci -isrc-tests
17:34:18 <dmj`> where src-tests is where your test modules are
17:34:38 <cheater> i'm going via cabal repl
17:35:03 <dcoutts> cheater: sure, cabal repl testsuitename
17:35:17 <cheater> Darwin226: regarding new compiler features i've had best response on the list
17:35:34 <cheater> dcoutts: that's crazy... why does that work?
17:35:52 <dcoutts> cheater: because that's what cabal build/repl [target] does!
17:36:04 <dcoutts> builds or starts the repl for the target you tell it
17:37:18 <dcoutts> targets here are components in the package, exes, lib, test suites, benchmarks etc
17:37:55 <cheater> oh ok
17:38:06 <cheater> i am 100% certain i will forget this in the future
17:38:17 <cheater> i wish there was a way for me to discover this easily
17:38:30 <dcoutts> cheater: see cabal build/repl --help
17:39:09 <dcoutts> cheater: and/or use the bash command completion for cabal
17:39:23 <cheater> right, i just read that, but it doesn't mention explicitly that a COMPONENT might be my tests, and i wouldn't have made the connection myself
17:39:57 <cheater> my command completion for cabal repl just starts doing options, and doesn't mention any COMPONENTs
17:40:12 <dcoutts> ho hum
17:40:37 <dcoutts> cheater: but it does say exactly that:
17:40:42 <dcoutts> Examples:
17:40:42 <dcoutts>   cabal repl               The first component in the package
17:40:42 <dcoutts>   cabal repl foo           A named component (i.e. lib, exe, test suite)
17:41:31 <dcoutts> (same for cabal build --help)
17:44:06 <cheater> oh, yes it does
17:44:23 <cheater> but i kind of assumed, after i read everything about COMPONENT, that there's not going to be any more talk about COMPONENTs
17:44:30 <cheater> so i stopped reading short of examples
17:45:04 <dcoutts> cheater: so once new-build becomes build, there'll be more of this kind of stuff, e.g. cabal build ../the/other/thing
17:45:08 <cheater> actually short of flags. because i'm not looking for flags, and i assumed all that visual mess below was flags, so i skipped it
17:45:16 <ReinH> Assumptions make an ass out of u and mptions
17:45:23 <cheater> yeah they do
17:45:31 <cheater> dcoutts: pretty cool
17:45:47 <cheater> now i have to figure out why this quickcheck property is hanging
17:45:59 <dcoutts> with cabal new-build/new-repl you can tell it to build any package or component in the project, by name or location
17:52:39 <cheater> this is maddening
17:58:25 <soLucien> where should stack.yaml be located in order to be picked up by the executable ?
17:59:32 <soLucien> by ghci
18:00:08 <geekosaur> ghc doesn;t read it, stack does. should probably be in the current directory when you run stack ghci
18:09:57 <ReinH> It needs to be in the directory that its project spec says it is in, relative to the cabal files it uses
18:11:05 <ReinH> Generally this is '.', i.e., the same directory as the cabal file, but other configurations are possible
18:16:17 <cheater> is there a good place to talk about quickcheck?
18:17:06 <hpc> here probably
18:23:03 * hackagebot wild-bind 0.1.0.1 - Dynamic key binding framework  https://hackage.haskell.org/package/wild-bind-0.1.0.1 (debugito)
18:23:05 * hackagebot wild-bind-x11 0.1.0.1 - X11-specific implementation for WildBind  https://hackage.haskell.org/package/wild-bind-x11-0.1.0.1 (debugito)
18:23:07 * hackagebot wild-bind-indicator 0.1.0.1 - Graphical indicator for WildBind  https://hackage.haskell.org/package/wild-bind-indicator-0.1.0.1 (debugito)
18:23:09 * hackagebot wild-bind-task-x11 0.1.0.1 - Task to install and export everything you need to use WildBind in X11  https://hackage.haskell.org/package/wild-bind-task-x11-0.1.0.1 (debugito)
18:28:17 <cheater> hpc: i'm trying to figure out what values quickcheck is trying to run my property test with..
18:39:49 <cheater> aha, i figured it out. running the property within ghci manually and pressing ctrl-c will tell me what values it tested with while it was hanging.
18:40:29 <cheater> oddly enough i set the property to fail if it doesn't finish within 2 seconds using within, but it still hangs longer than that
18:51:51 <cheater> aha, it was hanging in the precondition, and i only added "within" after that, that's why.
18:55:20 <allenj12> hey is there a way to get haskell-interactive-mode for emacs to work with stack not cabal
18:56:27 <dmj`> allenj12: M-x customize-set-variable <enter> haskell-process-type <enter> stack-repl
18:56:44 <caTh_> I have a socks connection which I believe I can make into an instance of Stream from Network-Stream.  Now, what I'm looking for is a way to manage some https requests over that stream, does anyone know which bit of the HTTP library I should look at?  I haven't found anything that will handle the interaction over a stream . . . 
18:57:48 <allenj12> dmj`: thanks, it cant find stack repl. Im probably missing a package
18:58:53 <dmj`> allenj12: er, maybe it's stack-ghci
18:58:56 <dmj`> :/
18:59:02 <dmj`> try that instead
18:59:15 <allenj12> dmj`: right before you said that I tried it and it seemed to take it
18:59:20 <dmj`> \o/
19:04:30 <allenj12> dmj`: still running into some problems with init.el , might need your help in a couple mins if your still on? :D
19:06:25 <dmj`> allenj12: yea, there is #haskell-emacs. But any changes to init.el, run M.x eval-buffer
19:06:32 <dmj`> M-x
19:07:03 <allenj12> dmj`: yea that i know but its complaining the value i am feeding to haskel-mode hooks and interactive hooks are void
19:07:27 <allenj12> Im making sure im following the directions right now, thanks for the irc tho
19:08:10 <dmj`> allenj12: http://lpaste.net/3961427054984953856
19:26:38 <codygman> I have a DecsQ I've built, how can I turn it into a ExpQ so I can use $() to "run" it?
19:34:52 <allenj12> dmj`: finally got it! thanks for your help
19:34:58 <dmj`> allenj12: cool! 
19:35:05 <dmj`> :) 
19:38:38 <geekosaur> codygman, at top level a splice is Q [Dec]
19:38:43 <allenj12> dmj`: one question tho I changed things that included cabal in   (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-CABAL-build) to stack. hopefully that will work too haha :D
19:39:07 <geekosaur> it's only Q Exp when spliced in the context of an expression
19:39:29 <haskell767> hi!
19:40:28 <dmj`> allenj12: I'd check the docs but pretty sure there is remapping of all cabal* things to stack* if stack.yaml is detected
19:40:49 <codygman> geekosaur: When you say spliced to you mean "[| some stuff here |]"? What is "$(some stuff here)" called?
19:41:00 <allenj12> dmj`: so what I did should work? or leave it the same
19:41:14 <geekosaur> no the [x|y] is a quasiquote, $(x) is a splice
19:41:22 <dmj`> allenj12: I'd leave it the same first
19:41:23 <haskell767> This is definitely a stupid question, but which framework would you recommend for receiving a bunch of requests at a time. Framework probably needs to have decent usage of SQL or similar 
19:41:43 <haskell767> I'm stuck between Yesod and Happstack
19:41:52 <haskell767> haven't made up my mind.
19:41:52 <allenj12> dmj`: gotcha, ill change it back. thanks. I gotta head to bed ill look at the docs tomorrow :D
19:42:19 <codygman> geekosaur: In ghci I have a function that is loaded who returns a DecsQ called f. I try running it with "$(f)" and it tells me I need a ExpQ type, not a DecsQ type.
19:42:31 <dmj`> allenj12: ok, good night!
19:42:33 <geekosaur> that is because ghci can't process TH declarations
19:42:43 <allenj12> dmj`: thansk again
19:42:48 <geekosaur> it was never enhanced to be able to deal with Q [Dec]
19:42:59 <dmj`> allenj12: cheers :)
19:43:14 <codygman> geekosaur: Oh, so I shouldn't have problems doing it in a source file where the function is in a different module?
19:43:21 <geekosaur> right
19:44:07 <geekosaur> (declarations in ghci are a bit of a hack, and I expect that making TH declarations work in ghci would be Difficult)
19:45:57 <haskell767> Hi, is there anyone who could help me out with web frameworks?
19:46:20 <depaysementKing> Would really appreciate some advice.
19:47:08 <codygman> geekosaur: Thanks
19:48:42 <dmj`> haskell767: yes
19:48:47 <depaysementKing> yes!
19:48:56 <depaysementKing> thank you dmj'!
19:49:03 <dmj`> depaysementKing: yes
19:49:21 <depaysementKing>  This is definitely a stupid question, but which framework would you recommend for receiving a bunch of requests at a time. Framework probably needs to have decent usage of SQL or similar
19:49:33 <depaysementKing>  I'm stuck between Yesod and Happstack. Haven't made my mind.
19:50:20 <Koterpillar> depaysementKing: happstack is more transparent to my taste
19:50:30 <depaysementKing> I think Happstack would be better since it seems to be a low-level HTTP server
19:50:47 <dmj`> depaysementKing: there's also snap, spock, servant and vanilla wai/warp. Depending on your needs they differ. But in general all haskell web frameworks are performant, and can handle many requests.
19:50:54 <Koterpillar> depaysementKing: fun fact: I found Happstack by searching for "Request -> IO Response".
19:51:03 <depaysementKing> Koterpillar: How hard would it be to set up a simple server in Happstack?
19:51:57 <depaysementKing> I'm decent at Haskell and I've done back-ends in python
19:52:05 <Koterpillar> depaysementKing: http://www.happstack.com/docs/crashcourse/index.html#your-first-app
19:53:27 <depaysementKing> sweet! 
19:53:40 <depaysementKing> Thank you Koterpillar!
20:12:52 <lpaste> dzack pasted “Composition” at http://lpaste.net/208214
20:13:17 <lpaste> dzack revised “Composition”: “Composition” at http://lpaste.net/208214
20:13:57 <dzack> ^ Could anyone help me understand what I'm missing in this bit of code?
20:15:06 <camm> Hey guys! How do you face the lack of jobs that require Haskell programmers in your countries? In my country, there is only one company that does Haskell and I can't apply there until I get my degree. :( So, In my case I will back to Java so I can apply to any of the many companies that does Java here.
20:15:32 <dzack> I'm basically trying to rewrite  f (g 4 5)  as something like (f . g) 4 5, but it results in the same type error
20:16:02 <shachaf> f (g 4 5) = (f . g 4) 5
20:16:42 <dzack> ah right, but I'm trying to do it with a partial application necessarily
20:17:10 <dzack> really, I'm just using it to demonstrate that functions can be composed
20:17:28 <shachaf> "partial application" doesn't have much meaning in Haskell.
20:17:34 <shachaf> @pl \x y -> f (g x y)
20:17:34 <lambdabot> (f .) . g
20:17:39 <shachaf> You can write that if you want.
20:17:43 <shachaf> But I don't recommend it.
20:18:27 <dzack> The big issue for me is that I'm not sure exactly why the type for h isn't right
20:18:48 <shachaf> Well, start with the type for (.)
20:18:54 <mac10688> f . g returns Integer -> Integer
20:19:04 <mac10688> do you need it to be point free style?
20:19:29 <dzack> not necessarily
20:19:45 <mac10688> ok then I would do. h a b = f ( g a b)
20:20:37 <dzack> Hmm yeah, that works - I don't understand why f . g is that type, though
20:20:53 <mac10688> because g takes two parameters to return an integer
20:21:00 <amalloy> f is a function that takes a number and returns another function
20:22:25 <mac10688> in ghci
20:22:33 <mac10688> type :t f . g
20:22:36 <mac10688> and see what you get
20:22:41 <dzack> right, I guess I'm thinking of it as a mathematical function - the output of g is a single integer, and the input of f is a single integer, right?
20:22:48 <amalloy> no
20:23:03 <amalloy> read the type signature as: Int -> (Int -> Int)
20:23:31 <dzack> ahh, I see
20:23:51 <mac10688> good because I don't know how to explain it in words lol
20:23:57 <mac10688> :t (.)
20:23:58 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:24:04 <mac10688> ah there we go
20:24:18 <mac10688> f = (b -> c) part
20:24:29 <mac10688> but g isn't really equal to (a -> b)
20:26:03 <dzack> I see, but something like (g 4) would be?
20:26:11 <mac10688> yeah
20:26:28 <mac10688> so i think you could do h . (g 4)
20:26:30 <mac10688> and that would work
20:27:08 <mac10688> there's a way to make it point free but it's beyond me and I think it's just more of an academic exercise. I wouldn't want to write that point free.
20:28:05 <mac10688> the bot knows how to make it point free
20:28:22 <mac10688> @let f x = x ^ 2
20:28:24 <lambdabot>  Defined.
20:28:35 <mac10688> @let g x y = x + y
20:28:36 <lambdabot>  Defined.
20:29:03 <amalloy> shachaf already showed that
20:29:05 <amalloy> @pl \x y -> f (g x y)
20:29:05 <lambdabot> (f .) . g
20:29:10 <mac10688> oh
20:29:20 <mac10688> yeah that's how to make it point free!
20:29:35 <mac10688> oh I missed that up top my bad
20:30:12 <dzack> out of curiosity, would something like f . g worked if I defined a custom data type for the input to g?
20:30:21 <dzack> something like g :: Z2 -> Integer
20:30:35 <dzack> where Z2 really just wraps two integers
20:30:44 <benzrf> yeah
20:30:52 <mac10688> yeah or make it a tuple
20:30:57 <benzrf> you could do `f . uncurry g'
20:31:21 <mac10688> I always froget if currying makes it a tuple or untuples a tuple
20:31:48 <benzrf> "currying" is the hack to get "multi-arg functions" in the lambda calculus
20:31:58 <benzrf> therefore, to curry a function means to de-tuple-ify it
20:32:10 <mac10688> ah
20:35:12 <dzack> neat, that works!
20:35:22 <dzack> great thanks for the help guys
20:43:09 <lgstate> are there any screencasts on implementing various type checkers in haskell?
21:00:27 <dmj`> dcoutts: do you know if there's a way to set a cabal configure option as an environment variable. So something like 'export GHC=ghcjs', then 'cabal configure' would automatically do 'cabal configure --ghcjs'
21:00:54 <muyfine> any lens experts out there?
21:01:24 <muyfine> trying to figure out how to simplify some lens operations
21:01:34 <glguy> muyfine: You should always just ask your actual question
21:01:51 <muyfine> haha, sorry - filling out lpaste
21:02:23 <muyfine> http://lpaste.net/208237
21:03:07 <muyfine> I have a map in a maybe value, and trying to figure out how to initialize it if Nothing, or insert into it if there's a Just
21:03:59 <muyfine> that logic in the lpaste seems overwrought
21:04:42 <benzrf> muyfine: you want `non'
21:04:44 <benzrf> :t non
21:04:45 <lambdabot> (Profunctor p, Functor f, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
21:05:07 <lpaste> glguy annotated “No title” with “first draft” at http://lpaste.net/208237#a208244
21:05:11 <benzrf> er, wait
21:05:17 <benzrf> mb, i think i misread what you said
21:06:06 <glguy> muyfine: Is it important to have the Maybe layer? Is a Nothing different from Just emptyMap?
21:06:08 <dmj`> muyfine: why use Maybe (M.Map k v) ? Why not just M.Map k v, and use mempty as M.empty
21:07:00 <glguy> muyfine: Take a look at that paste annotation
21:07:10 <muyfine> thanks for the help! the maybe is coming off JSON data that may or may not be there
21:07:46 <muyfine> glguy thanks that's cleaner than what I had
21:08:55 <muyfine> benzrf non sounds helpful - trying to parse the documentation on it around creading nested map when missing
21:08:59 <dmj`> muyfine: I'd convert Nothing to M.empty, in fact, you can set the default in aeson
21:09:04 <andromeda-galaxy> I have a couple of quick questions about category-extras and its descendents:
21:09:17 <dmj`> o .: "foo" .!= M.empty
21:09:19 <muyfine> wondering if that's applicable with being nested inside a maybe
21:09:45 <muyfine> dmj` yeah, but I'm using the TH stuff to derive instances
21:10:02 <muyfine> and not aware of whether I can change what it defaults to 
21:10:08 <benzrf> muyfine: oh good
21:10:10 <muyfine> (it was doing null)
21:10:42 <andromeda-galaxy> Is there a package that provides retractions and sections, and ideally a datatype for a retraction + a section together (presumably something like Retract a b for when b is a retract of a (retract meaning that retraction and section exist such that f . g = id_B)?
21:10:46 <andromeda-galaxy> )
21:11:27 <andromeda-galaxy> I think that any given category with all non-split-epics/monics (e.g. sections/retractions) should still be a category.  Is there a package providing instances for this?
21:11:44 <andromeda-galaxy> I see that category-extras and now categories has a typeclass for monoidal categories. What about monoidal functors?
21:11:51 <andromeda-galaxy> (most importantly lax monoidal functors)
21:11:58 <dmj`> muyfine: yea, probably not
21:12:18 <andromeda-galaxy> I want to make something like Applicative but as endofunctors on Hask with only these semi-invertible things
21:12:25 <andromeda-galaxy> (e.g. retracts)
21:12:41 <andromeda-galaxy> Also, is there a better place to ask about CT & CT-in-haskell related stuff?
21:13:01 <andromeda-galaxy> sorry for the deluge of questions.  I'm finding that categorical libraries aren't that easy to find
21:13:32 <andromeda-galaxy> and if you look for, e.g. "haskell monoidal functor" you just get a lot of explanations of why applicatives are strong lax monoidal functors, never anything about generalizing them
21:13:39 <andromeda-galaxy> (strength I think comes for free with laziness?)
21:19:25 <shachaf> andromeda-galaxy: I don't know about specific libraries that have these things, but you'd expect them to have some sort of monoidal functor if they have monoidal categories. But maybe not.
21:20:12 <shachaf> I don't understand your "any given category" statement.
21:21:09 <andromeda-galaxy> shachaf: I would expect that also, but Kmett's categories doesn't seem to
21:21:42 <andromeda-galaxy> shachaf: I was saying something along the lines of: if I take some category and remove every arrow that is not a split epic/monic, I should still have a category
21:22:05 <andromeda-galaxy> (I'm still learning CT, so that might be wrong, but I think that split epics/monics are closed under composition so it should be?)
21:23:03 <muyfine> glguy thanks for the paste - I took that down to http://lpaste.net/208237#a208268
21:23:07 * hackagebot Gifcurry 2.0.0.1 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-2.0.0.1 (lettier)
21:23:14 <andromeda-galaxy> so I was hoping for something like 'instance Category ar => Category (Retract ar)'
21:23:32 <muyfine> which is way better than what I started out with
21:23:58 <muyfine> thanks for the help - feel like I'm missing a lens operator that might handle that for me - trying to figure out how to use non in this case
21:24:32 <andromeda-galaxy> shachaf: do you know if that's true?
21:24:57 <andromeda-galaxy> (also, for applicatives, do my categories have to both be CCCs?)
21:25:00 <glguy> muyfine: Non would be more appropriate if the empty map was equivalent to Nothing
21:25:36 <shachaf> For "applicative" functors you presumably want closed monoidal categories. I don't think anything requires them to be CCCs in particular?
21:25:57 <andromeda-galaxy> okay, closed monoidal makes sense
21:26:00 <andromeda-galaxy> thanks!
21:26:01 <glguy> otherwise it's something like: imFailureReasons . non' _Empty . at k ?~ v
21:26:11 <andromeda-galaxy> I still can't find any libraries, though...
21:26:16 <muyfine> got it
21:26:42 <shachaf> Not sure about the other statement. I need to go home but I'll be back in a bit.
21:26:56 <shachaf> If f . fi = id and g . gi = id, what's f . gi?
21:28:26 <andromeda-galaxy> with f : B -> A, fi : A -> B, g : C -> B, gi : B -> C?
21:29:11 <andromeda-galaxy> then f . g : C  -> A and gi . fi : A -> C,
21:29:22 <andromeda-galaxy> and I thing that (f.g).(gi.fi) should still be id
21:29:48 <andromeda-galaxy> by associativity
21:30:51 <shachaf> With f, g : A -> B, fi, gi : B -> A. Or something, maybe I'm not making sense.
21:30:51 <andromeda-galaxy> shachaf: I also have to leave soon, actually for the day, but I'll be back tomorrow
21:31:12 <andromeda-galaxy> I was thinking of that problem in the context of defining composition for that category?
21:35:15 <shachaf> I mean, does that composition have an inverse?
21:35:43 <shachaf> But I'm walking home right now, not really thinking about it.
21:35:58 <andromeda-galaxy> shachaf: f.g was the composition, and gi.fi was the (half) inverse
21:36:11 <andromeda-galaxy> thanks for looking at it at all!
21:36:23 <shachaf> Why f . g?
21:36:42 <andromeda-galaxy> right type, and has an inverse?
21:36:46 <andromeda-galaxy> why not?
21:37:11 <shachaf> I thought you were asking whether it was a category?
21:37:24 <andromeda-galaxy> I was
21:37:58 <shachaf> So only looking at cases that obviously work isn't very useful.
21:38:42 <andromeda-galaxy> I just wasn't sure what other cases there are - I was asking if it with that composition operation was a category...
21:40:07 <shachaf> Oh, I think I misunderstood which category you were talking about.
21:40:33 <shachaf> I see what you meant now. An arrow is a section-retraction pair.
21:40:39 <andromeda-galaxy> Right
21:41:32 <shachaf> Yes, that's a category.
21:42:05 <andromeda-galaxy> great! I'm hoping that if the parent category is closed monoidal it also is, but haven't had a chance to work it out yet
21:42:23 <andromeda-galaxy> off the top of your head, do you have any idea if that's true?
21:47:17 <andromeda-galaxy> also: is there a better name for a section-retraction pair? I've been calling it Retract since it's evidence that A is a retract of B, but that's not really great
21:54:35 <e19293001> hi
21:54:59 <lambdabot> Hello.
21:55:23 <shachaf> andromeda-galaxy: Not sure.
21:56:11 <shachaf> andromeda-galaxy: Well, either one is determined by the other.
21:56:35 <shachaf> andromeda-galaxy: https://ncatlab.org/nlab/show/split+epimorphism suggests calling it a "splitting" but that maybe emphasizes the idempotent too much?
21:56:59 <andromeda-galaxy> shachaf: I'll try to check it myself tomorrow, then, thanks for looking into it!
21:57:19 <andromeda-galaxy> shachaf: it's handy to have both at hand in some structure though...
21:57:20 <e19293001> i would just like to ask if there is any haskell project that needs contribution?
21:57:44 <andromeda-galaxy> hmm, is reasonably nice
21:58:18 <andromeda-galaxy> *splitting is
21:59:04 <andromeda-galaxy> http://math.stackexchange.com/questions/73342/is-there-a-name-for-a-section-and-a-retraction-together also suggests split morphism, but I don't know enough CT conventions to know if that's likely to be really unclear
22:12:42 <glguy> e19293001: The best projects to contribute to are the ones you're using
22:19:17 <e19293001> glguy: I'm new and been reading Haskell Programming from first principles. I'm on the middle of the book where I use Hspec and QuickCheck
22:22:36 <cocreature> e19293001: fwiw hledger (https://github.com/simonmichael/hledger) recently asked for contributions but glguy is right: contributing to projects you use yourself is best
22:28:12 <e19293001> cocreature: thanks. i'll have a look at it
22:52:59 <lpaste> xuxu pasted “No title” at http://lpaste.net/208397
22:53:46 <xuxu> geekosaur, monochrom: when you both suggest pattern matching, are you suggesting function definitions as in the example pasted or guards, or case statements, or something else?
22:54:04 <geekosaur> either --- the function definition one turns into a case
22:54:28 <xuxu> 12:22 < ReinH> If you understand how pattern matching works, you will understand 99% of Haskell
22:55:00 <xuxu> ReinH: is there a good resource for understanding _how_ pattern matching works?
22:55:46 <geekosaur> the Report's not too terrible. https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
22:55:52 <xuxu> thanks geekosaur 
22:56:06 <geekosaur> basically a pattern match looks at the structure of a type
22:56:40 <xuxu> it was you, monochrom, ReinH, and [k- who have all suggested pattern matching at least 2 times recently
22:57:15 <geekosaur> so if j :: Maybe Int, you can discriminate on the constructor: case j of Just x -> {- do something with x -}; Nothing -> {- no value, do something else -}
22:57:37 <xuxu> i wasn't trying to avoid pattern matching in a previous problem, i just don't really know what people mean: is it generally function definition or is case statements or guards
22:57:40 <geekosaur> (don't need the ';' if you do it on separate lines; it uses layout)
22:58:32 <geekosaur> guards are not pattern matching but text expressions ("predicates" if you're being lispy) that you can use to refine a pattern match based on values instead of structure
22:58:49 <xuxu> i've been able to use case j of Just x -> but i haven't really understood how or why it works
22:58:49 <geekosaur> multiple function definitions get turned into a case-of construct
22:58:52 <grantwu> xuxu: https://wiki.haskell.org/Declaration_vs._expression_style Is this possibly relevant?
22:59:17 <xuxu> is there an equivalent of of the case j of Just x for pattern matching in function definitions or guards?
22:59:41 <grantwu> you can do like
22:59:48 <geekosaur> not for guards, and I guess what I have said twice about function definitions did not register
22:59:53 <grantwu> foo (Just x) = blagh
23:00:04 <grantwu> foo Nothing = blargh
23:00:10 <grantwu> this is equivalent to
23:00:17 <geekosaur> foo (Just x) = x; foo Nothing = 0        turns into      foo x' = case x' of {Just x -> x; Nothing -> 0}
23:00:30 <xuxu> this is useful 23:58 < geekosaur> guards are not pattern matching but text expressions ("predicates" if you're being lispy) that you can use to refine a pattern match based on values instead of structure
23:00:50 <grantwu> to that
23:01:18 <geekosaur> if, having extracted the x from a Just x, you need to check what the value of that x is, you can't do many things with pattern matches (like, x < 5) and need to add a guard instead
23:01:46 <geekosaur> and if the guard fails, it tries the following guard(s) if any. and then falls through to the next pattern
23:02:48 <xuxu> thanks geekosaur 
23:03:26 <xuxu> didn't know about wrapping a type in parens to pattern match on it: foo (Just x) = x
23:03:59 <geekosaur> but in functional programming, it's encouraged to make use of data constructors to separate things that are logically different (Just x vs. Nothing, Circle v Rectangle v Point v whatever. etc.) and then use case-of to handle each case appropriately, let your types describe your data instead of trying to shoehorn data into fixed/predefined types, and often the program logic follows naturallt
23:04:33 <geekosaur> well, pattern match syntax acts like expression syntax
23:04:48 <xuxu> as you saw earlier when i was playing with the rethinkdb driver, i am having problems getting types to match, and i'm also curious if there are some tips or (from oo land: patterns) for getting types to plug in with one another 
23:05:15 <grantwu> unsafeCoerce :^)
23:05:25 <geekosaur> if you were passing it to a function instead of accepting it as a pattern, you'd write foo (Just 1) Nothing (Just 3) or something --- writing `foo Just 1` passes two parameters, one a function (a -> Maybe a)and the other a (Num a => a)
23:05:38 <geekosaur> (this is useful with things like map)
23:05:49 <grantwu> Uh... I mean, when you say problems for getting types to match, do you mean you are having trouble satisfying the type checker?
23:05:54 <geekosaur> > map Just [1..4]
23:05:56 <lambdabot>  [Just 1,Just 2,Just 3,Just 4]
23:06:04 <grantwu> Or that you have incompatible types that you want to convert from one thing to another
23:07:00 <geekosaur> sometimes you have to just drill down to figure out the typed
23:07:03 <geekosaur> *types
23:07:19 <grantwu> type holes can help
23:07:30 <grantwu> As well as an editor with the ability to show you types
23:07:48 <geekosaur> in your RethinkDB case, I looked up Datum on hayoo to find out that it was a sum type one of whose constructors was Object, and the value associated with Object was a HashMap Text Datum
23:08:25 <geekosaur> (this ended up being somewhat indirect as the latest version of rethinkdb-client-driver has no docs, sigh --- had to look up the package on hackage and then step back a version to find one with docs)
23:08:49 <xuxu> well, e.g. when i query the database for documents, the returned data is of type Datum. i don't know which exact constructor it is though, i was just told that it was Object. would i normally pattern match to figure out the type of the returned data? 
23:09:26 <geekosaur> well, you have to know what constructors exist, which is where you have to look up Datum's definition in the rethinkdb-client-driver package
23:09:39 <xuxu> when i was told it wasn Object i noticed that Object was an alias for HM.HashMap ST.Text Datum
23:09:52 <geekosaur> after that I guessed, because you were trying to use HM.lookup
23:09:57 <xuxu> i think you can access items in a hashmap with lookup
23:10:23 <geekosaur> which suggested you wanted the Object constructor for Datum, which would give you a HashMap
23:10:33 <xuxu> and i was trying to figure out how exactly to do that but then i was pulled away from the task due to responsibilities 
23:12:05 <geekosaur> if you were pulled away, then you probably missed [21 22:16:12] <geekosaur> getMap :: Datum -> Maybe Object; getMap (Object m) = Just m; getMap _ = Nothing
23:12:33 <geekosaur> (may be slightly confusing as Object is both a data constructor for Datum and a type alias for HashMap Text Datum
23:12:37 <geekosaur> )
23:12:49 <xuxu> this sounds wonderful. i hope it all becomes more natural over time. it seems i'm constantly battling the compiler trying to figure out how to get types to work with another: "let your types describe your data instead of trying to shoehorn data into fixed/predefined types, and often the program logic follows naturally"
23:13:09 <xuxu> what you said seems to naturally follow what ReinH mentioned 
23:13:26 <xuxu> "If you understand how pattern matching works, you will understand 99% of Haskell"
23:14:12 <andromeda-galaxy> For an associative bifunctor, is it required that associate . disassociate = id? If not, is there another structure that is just a bifunctor + that?
23:16:06 <shachaf> What are associate and disassociate?
23:16:10 <xuxu> geekosaur: oh, i didn't realize it was an alias and a data type
23:16:27 <xuxu> and i did miss the getMap function you posted
23:17:12 <shachaf> You should be careful about types and things that aren't types. You mix them up and it'll be very confusing if you do that.
23:17:16 <andromeda-galaxy> shachaf: from Kmett's categoreis package: https://hackage.haskell.org/package/categories-1.0.7/docs/Control-Category-Associative.html#t:Associative
23:17:56 <geekosaur> sadly that pun on Object is rethinkdb-client-driver's fault
23:18:13 <andromeda-galaxy> shachaf: the package says that associate and disassociate fulfill the "pentagonal coherence identity law", and that is all (and I don't have Mac Lane on hand right now)
23:19:05 <andromeda-galaxy> I don't see associate/disassociate necessarily being inverses directly from those laws, but it seems like they should be
23:19:40 <shachaf> I would also expect them to be in general, but I don't know about this particular thing.
23:19:52 <xuxu> codedmart: conversation about rethinkdb above
23:19:54 <shachaf> Is it the pentagonal coherence condition in https://en.wikipedia.org/wiki/Monoidal_category ?
23:20:19 <andromeda-galaxy> I would expect so...
23:20:45 <andromeda-galaxy> (but I don't know for sure, yet)
23:20:50 <shachaf> At least in that case the associator is an isomorphism.
23:22:14 <andromeda-galaxy> right... I think that that is probably it, hopefully the requirement was just left out of the haddocks by mistake
23:22:44 <andromeda-galaxy> The haddock does the law in terms of bimap, so it would take a little while (at least for me) to make sure that they are the same
23:23:11 * hackagebot quickcheck-text 0.1.2.0 - Alternative arbitrary instance for Text  https://hackage.haskell.org/package/quickcheck-text-0.1.2.0 (fractalcat)
23:23:13 * hackagebot aeson-generic-compat 0.0.1.0 - Compatible generic class names of Aeson  https://hackage.haskell.org/package/aeson-generic-compat-0.0.1.0 (KeiHibino)
23:24:18 <shachaf> Wikipedia also states the law in terms of bimap.
23:24:22 <shachaf> Looks like the same law.
23:25:02 <andromeda-galaxy> oops, I was looking at the wrong diagram :-( sorry. Yeah, they look to be the same
23:25:35 <andromeda-galaxy> I might pull request categories to include the extra law sometime
23:26:12 <andromeda-galaxy> shachaf: thanks for all the CT help! I'm learning in the middle of a big project and talking with you has been really helpful
23:26:49 <shachaf> Except for that one time when I spent half an hour misunderstanding what you were saying earlier.
23:27:12 <xuxu> geekosaur: struggling to use the getMap function you mentioned. codedmart also gave me something to work with earlier, but i'm going to rest a bit tonight, and hopefully i can figure out tomorrow night
23:27:44 <andromeda-galaxy> that was actually still kind of illuminating for me - while I was trying to figure out what you were saying about the other thing that is not what I thought it was about I ended up getting a better idea of a totally different thing
23:28:06 <xuxu> one thing i'd like to look into if i can ever get past a simple query / filter for a database is f-algebras and homoiconicity in haskell. it seems like an interesting topic
23:28:09 <xuxu> https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/
23:28:19 <geekosaur> you give that function a Datum and it gives you a Maybe (HashMap Text Datum). (mostly out of paranoia; you may be able to prove it'll always be the Object case)
23:29:34 <xuxu> geekosaur: looks like i'm dealing with a [Datum]
23:29:39 <xuxu> c :: [Datum]
23:30:05 <geekosaur> then you'd want to apply it to each element of the list, unless you know it has exactly one element
23:30:37 <geekosaur> map getMap c :: [Maybe (HashMap Text Datum)]
23:30:44 <geekosaur> possibly then using catMaybes
23:30:47 <geekosaur> :t catMaybes
23:30:48 <lambdabot> [Maybe a] -> [a]
23:31:02 <geekosaur> which throws out the Nothing-s and unwraps the Just-s
23:41:20 <Ashy> is anyone else having issues with hdevtools and stack?
23:41:38 <lpaste> xuxu pasted “attempting to get a field in from RethinkDB Datum Object” at http://lpaste.net/208461
23:41:51 <Ashy> im getting this error when trying to run 'hdevtools check foo.hs':  Cabal error: The program 'ghc' version >=6.4 is required but it could not be found.
23:42:23 <Ashy> even though ghc 7.10.3 is installed: $ stack ghc -- --version
23:42:24 <Ashy> The Glorious Glasgow Haskell Compilation System, version 7.10.3
23:43:08 <Ashy> ~/.local/bin is on my $PATH and ive even added the ~/.stack/programs/ghc.../bin to my $PATH too
23:43:21 <Ashy> what context does hdevtools run in that it can't find ghc?
23:44:41 <Ashy> cabal repl is working and reports using ghci 7.10.3
23:44:41 <xuxu> i just realized my ghci prompt is a little confusing when reading from a paste site. my mind immediately starts parsing a lambda expression when i view it there
23:45:33 <Ashy> hmm this is a yesod project i wonder if that's causing the issues
23:46:10 <Cale> Ashy: Somehow I bet that wherever stack has installed ghc, it's not somewhere on your $PATH
23:46:27 <Cale> oh
23:46:33 <Cale> You commented on that, sorry
23:46:44 <Cale> (I'm just reading through)
23:47:12 <Cale> In that case, I'm not sure
23:47:16 <Ashy> im getting this issue on my mac and also on an ubuntu 14.04 vm
23:48:04 <xuxu> okay, i really am about to pass out over here
23:48:07 <xuxu> thanks again geekosaur 
23:48:21 <xuxu> maybe i can figure it out tomorrow
23:48:37 <Ucenna> Howdy!
23:48:49 <Ucenna> I had a programming question if somone would humor me.
23:49:01 * xuxu hopes he can be a productive haskell programmer 2 years from now
23:49:04 <ongy> Ucenna: just ask the question. Ususally someone responds
23:49:17 <ongy> xuxu: for the current error: Do you have OverloadedStrings active?
23:49:20 <Ucenna> : Sorry, I don't normally IRC.
23:49:33 <Ucenna> Is it ever wrong to use a tail-recursion.
23:49:41 <xuxu> ongy: yes
23:49:59 <Koterpillar> Ucenna: when your language doesn't support it
23:50:05 <Koterpillar> s/support/optimize/
23:50:07 <Ashy> Cale: hmm hdevtools works in a tmp dir with a hello.hs file 'main = putStrLn "Yo"'
23:50:13 <Ucenna> :P
23:50:21 <Ucenna> Okey dokey.
23:50:24 <Ashy> Cale: so it must be related to this yesod project dir
23:50:25 <Cale> Ucenna: sure -- in fact
23:50:40 <ongy> xuxu: I think it doesn't know what type to use for your key and confuses itself.
23:50:46 <Cale> tail recursion is a bit weird in Haskell, because evaluation is outermost first
23:51:48 <Ucenna> okay... So is there certain functions were it would be better to choose a non tail-recursive route, even if your language supports it.
23:51:50 <ongy> Ashy: hdevtools tries to handle stack somehow. You can see if you do 'hdevtools check -f foo.hs'. Maybe there's a bug in hdevtools
23:51:58 <Cale> So, you actually almost never want things to be truly tail recursive -- at the very least, you want something in the way which will force the evaluation of the arguments to the function, so you don't end up building up large unevaluated expressions in the parameters
23:52:08 <Ucenna> I'm just picking up functional programming and Haskell now, so I'm a bit new to this.
23:52:13 <Cale> Ucenna: consider foldr
23:52:17 <Cale> @src foldr
23:52:17 <lambdabot> foldr f z []     = z
23:52:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:52:17 <xuxu> ongy: what do you suggest? HM.lookup "timestamp"::Prelude.String z -- maybe?
23:52:35 <Cale> In the recursive case, foldr basically passes control to *f*
23:52:47 <Cale> and only if f needs its second argument will the foldr continue
23:53:03 <Cale> This allows the foldr to short-circuit, and also enables it to operate on infinite lists
23:53:08 <ongy> xuxu: You can use String, or text if you need better performance
23:53:19 <Cale> > foldr (\x xs -> x : 10*x : xs) [] [1..]
23:53:23 <lambdabot>  [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,14...
23:53:44 <johnw> I don't think switching to Text is a guarantee of better performance; it depends on how the Strings are being used
23:53:55 <Cale> > foldr (\x xs -> if x^3 > 100 then x else xs) 0 [1..]
23:53:58 <lambdabot>  5
23:54:30 <lpaste> xuxu pasted “specifying the key's string type” at http://lpaste.net/208475
23:54:30 <Cale> By contrast, let's have a look at the code for foldl
23:54:32 <Cale> @src foldl
23:54:32 <lambdabot> foldl f z []     = z
23:54:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:54:36 <xuxu> ongy: ^
23:54:50 <Cale> foldl does nothing but to greedily apply itself to new arguments in a tail recursive fashion
23:54:53 <Ashy> ongy: hmm it's working in a servant project on this machine, just not in the yesod project
23:55:02 <Cale> until it reaches the end of the list
23:55:02 <Koterpillar> TH?
23:55:15 <Ucenna> Okay...
23:55:18 <Ashy> ongy: i'll try with a fresh project created from the yesod-hello-world stack template
23:55:20 <Cale> So it's clearly never going to work on an infinite list, since those don't have any end
23:55:27 <ongy> xuxu: you want parentheses. It parses as "timestamp" :: (Text z) you want ("timestamp :: Text) z
23:55:33 <Cale> and it also won't be able to shortcut
23:55:41 <Ucenna> I gotcha.
23:55:57 <grantwu> I'm pretty sure that GHC can turn tail recursive functions into loops, sometimes?
23:56:02 <grantwu> Strictness analyzer is a thing
23:56:16 <Ucenna> In my practice, I'd noticed the possibility of infinite recursion, but I never really tested it to see what would happen.
23:56:19 <Cale> Also, "tail recursion optimisation" is much less meaningful in (GHC) Haskell, since there's no call stack
23:56:28 <lpaste> xuxu pasted “ongy: this is a little better” at http://lpaste.net/208478
23:56:33 <Ucenna> Okay, okay.
23:56:39 <Cale> (at all)
23:57:02 <Cale> There is a stack, but at least from the perspective of your running Haskell program, it doesn't look very much like a call stack
23:57:19 <Ucenna> Actually I'll be using self-enforced functional JavaScript, someone reccomended checking here for functional programming questions.
23:57:21 <Cale> It's much more like a stack of pattern matches waiting for their scrutinee to be sufficiently evaluated to match a pattern
23:57:36 <Ucenna> Okay.
23:57:38 <xuxu> ongy: z is an Object and it expects a Map String a 
23:58:00 <grantwu> https://wiki.haskell.org/Performance/Strictness#Strictness_analysis
23:58:12 <Cale> Ah, in almost any language other than Haskell (anything which uses eager evaluation), the answers to these questions are rather different
23:58:32 <Ucenna> Yeah, that's true.
23:58:50 <Ucenna> It might just be better to ask over on stackexchange, and pick everyone's brain.
23:59:05 <Cale> grantwu: Strictness analysis will mess with the order in which things are evaluated, sure -- and it'll often serve to make sure that the foldl doesn't blow up in your face :)
23:59:25 <grantwu> Ucenna: Which language are you using?
23:59:29 <Ucenna> I'm very, very, raw at functional programming. So I have lots of questions. :P
23:59:36 <Cale> Ucenna: But there are reasons for wanting any particular kind of recursion
23:59:41 <Cale> (in any language)
