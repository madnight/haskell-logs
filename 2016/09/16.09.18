00:17:31 <benzrf> sunjay: "dependent types" tends to mean the presence of types for functions whose return type depends on the input value
00:18:23 <benzrf> e.g. - suppose i have a type for "lists of length 1", "lists of length 2", "lists of length 3", and so on
00:18:44 <benzrf> then suppose i write a function which takes a natural number and returns a list of copies of the letter 'a' - as many as the input value
00:19:01 <benzrf> in something like haskell, i can't have a type for that function - there's no single type that the output will always be
00:19:12 <benzrf> (that's not quiiite true, but it's close enough)
00:19:51 <benzrf> a dependently typed language is one where i can say that the function has type "a function that takes a natural number, then returns a list of characters of length <whatever the input was>"
00:21:10 <Ninja__> Haskell newbie here
00:21:21 <Ninja__> Need help in pattern matching
00:23:54 <grantwu> Ninja__: What sort of issues are you encountering?
00:24:05 <grantwu> @paste
00:24:05 <lambdabot> Haskell pastebin: http://lpaste.net/
00:24:27 <glguy> 2016-09-18 00:22:00 quit Ninja__
00:24:38 <grantwu> oh
00:24:45 <grantwu> ...couldn't have wait
00:25:22 <[k-> your irc client is very... concise
00:25:30 <grantwu> ?
00:25:33 <grantwu> oh
00:25:37 <glguy> [k-: only in "detail" view
00:26:02 <[k-> your irc client has different modes?!
00:26:13 <glguy> yeah
00:27:19 <grantwu> hrm, I can't ctcp version you, weird
00:27:38 <grantwu> Do you have your client configured not to answer that or something?
00:27:51 <grantwu> Oh wait, never mind
00:27:52 <glguy> Yeah
00:27:56 <glguy> Goes to my ZNC
00:28:14 <grantwu> Er, your ZNC is passing through your actual client
00:28:39 <grantwu> (I had switched the arguments to /ctcp before, which was why I thought it didn't work before)
00:32:31 <glguy> https://i.imgsafe.org/e42dbea9ad.png https://i.imgsafe.org/e42dcdcb58.png https://i.imgsafe.org/e42de72e11.png
00:37:35 <glguy> detail view + dynamic regex filtering is useful as a moderator when trying to search messages by hostname or username or whatever to figure out what's going on
00:38:11 <glguy> grantwu: and the answer was http://hackage.haskell.org/package/glirc
00:38:32 <grantwu> Oh, was it not Andchat
00:39:00 <glguy> No, that's just my phone
00:39:22 <grantwu> oh lol
00:39:53 <[k-> compressed summary of join/parts!
00:40:00 <ongy> if I compile a non cabal haskell file in a cabal sandbox, will the sandbox be used for libraries?
00:41:36 <lyxia> I think so
00:42:19 <glguy> [k-: there's a toggle button for them, too; so if joins/parts get really bad I can hide them temporarily
00:43:42 <[k-> this sounds very nice
00:43:46 <glguy> [k-: That integrates with the /ignore command so that if I (for example) /ignore lambdabot, I can still notice when it talks without it scroling my screen
00:44:38 <[k-> oh, you wrote it!
00:49:54 <glguy> Yeah :)
00:54:55 <ashishnegi> hi.. i have following code : 
00:54:59 <ashishnegi> newtype JobPostBody =
00:54:59 <ashishnegi>   JobPostBody
00:55:00 <ashishnegi>   { joburl :: T.Text
00:55:01 <ashishnegi>   }
00:55:03 <ashishnegi>   deriving (Eq, Show, Generic)
00:55:39 <ashishnegi> this is ok.. but when i use `jobUrl` .. then compiler is forcing me to refer to the variable as `jobUurl`..
00:56:01 <glguy> jobUrl instead of joburl?
00:56:51 <ashishnegi> yes.. if i use `jobUrl` notice capital `U`.. then i pattern match for jobUrl.. compiler complains that 
00:56:54 <ashishnegi> Not in scope: ‘jobUrl’
00:56:54 <ashishnegi>     Perhaps you meant one of these:
00:56:54 <ashishnegi>       ‘jobUurl’ (line 31), ‘ST.jobUurl’ (imported from Sanskell.Types)
00:57:32 <glguy> You'd have to paste the code and the error to lpaste
00:57:41 <ashishnegi> i am using servant.. and using JobPostBody as `"job" :> S.ReqBody '[S.JSON] ST.JobPostBody :> S.PostNoContent '[S.JSON] (Either T.Text ST.JobId)`
00:57:47 <ashishnegi> ok.. i will do it. thanks
00:59:27 <ashishnegi> glguy: error went away.. uh.. :( :)
00:59:50 <srhb> ashishnegi: Sometimes errors go away just to embarrass people, they're cruel like that. :-)
01:00:55 <ashishnegi> srhb: well.. it is good that it went away before i had spent rest of day on it.. :) .. but must be some edge case in ghc
01:01:24 <srhb> ashishnegi: That sounds unlikely... But if you can reproduce it, I guess. :)
01:12:20 <mrwdxcr> hi, got a problem while trying to map a custom ArrayVal to a monad. tried something like this: map ArrayVal $ seq $ map evalExpr
01:13:10 <mrwdxcr> i get errors when i pass into monad that the type cant be matched
01:13:21 * hackagebot haskell-gi-base 0.18.3 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.18.3 (inaki)
01:13:25 <mrwdxcr> [[Value]] with actual type b0 -> b0
01:13:41 <mrwdxcr> any  examples on seq ?
01:14:57 <mauke> why are you using seq?
01:15:33 <mrwdxcr> sorry meant sequence. i'm tired
01:20:02 <lyxia> mrwdxcr: what's the type of ArrayVal
01:22:11 <mrwdxcr> lyxia: data Value = IntVal Int
01:22:11 <mrwdxcr>            | UndefinedVal
01:22:11 <mrwdxcr>            | TrueVal | FalseVal
01:22:11 <mrwdxcr>            | StringVal String
01:22:11 <mrwdxcr>            | ArrayVal [Value]
01:22:11 <mrwdxcr>            deriving (Eq, Show, Ord)
01:23:30 <lyxia> mrwdxcr: fmap ArrayVal . mapM evalExpr
01:24:51 <mrwdxcr> lyxia: Couldn't match type ‘a0 -> f0 Value’ with ‘Value’
01:24:52 <mrwdxcr>     Expected type: SubsM Value
01:25:05 <lyxia> mrwdxcr: can you paste your code with the full error?
01:25:16 <Darwin226> Hey guys. Is it possible to have overlapping instances with associated types? Everything I've tried so far tells me I have a conflicting type family instance
01:25:30 <lyxia> mrwdxcr: Is exalExpr not a function?
01:25:53 <mrwdxcr> lyxia: it's a function, ill do a pastebin
01:26:08 <lyxia> I prefer lpaste but sure.
01:26:30 <Darwin226> Ideally what I'd want is something like "if you know m is of type T then your associated type is U, in all other cases (or if you can't figure it out) it's V"
01:26:51 <Darwin226> I know it's not very haskelly and everything but maybe some combination of extensions and pragmas would let me do it?
01:26:55 <srhb> Does anyone know of a discussion of composition in Idris compared to Haskell? I'm thinking about strictness hampering composition.
01:28:03 <mrwdxcr> lyxia: http://pastebin.com/geCPxTcE   line 128 . 
01:28:55 <akegalj> I would like to have some binary that would run cabal/ghc and be able to autocorrect redundant import warnings in the project. I would write it myself but I don't have any knowledge about cabal/ghc internals. Can somebody give me pointers where to start
01:29:13 <mrwdxcr> lyxia: and here are the data types that i try to map http://pastebin.com/AD4NCbA2
01:30:53 <lyxia> mrwdxcr: to apply a composition f . g to a value a you can do f (g a) or f . g $ a, but f . g a is f . (g a)
01:31:19 <lyxia> mrwdxcr: and the pattern Array a doesn't need brackets
01:31:59 <lyxia> mrwdxcr: Array a -> ...  where result = fmap ArrayVal . mapM evalExpr $ a
01:32:35 <lyxia> mrwdxcr: note that I used mapM instead of map. You were trying to use  sequence . map evalExpr  which is equivalent to mapM evalExpr
01:33:55 <lyxia> mrwdxcr: and since result is an action that returns a value, you can't just put it in Right, so what I said won't work yet...
01:35:08 <mrwdxcr> lyxia: i am following
01:35:21 <lyxia> mrwdxcr: side note: all the cases before that one could use return
01:35:44 <lyxia> mrwdxcr: Array a -> fmap ArrayVal . mapM evalExpr $ a
01:37:04 <lyxia> first you sequentially evaluate the elements of the array and return them as a list, that's mapM evalExpr
01:38:08 <mrwdxcr> lyxia: and after i return them as a list how do I pass them to the monad?
01:42:31 <lyxia> mrwdxcr: I'm don't understand what you mean by "pass to the monad". You just need to wrap the result in a constructor, fmap is sufficient for that.
01:43:19 <mrwdxcr> lyxia: i tried with return $ ...
01:51:47 <florin36> hi, is there a function that takes a list of functions and applies each function to one argument and returns a list of results ?
01:52:11 <florin36> z :: [(a->b)] -> a -> [b] 
01:52:13 <liste> :t zipWith
01:52:15 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
01:52:18 <shachaf> sequence
01:52:22 <liste> :t sequence
01:52:24 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
01:52:35 <srhb> :t \x -> map ($ x)
01:52:36 <lambdabot> a -> [a -> b] -> [b]
01:53:22 <liste> florin36: you can also use hoogle to find functions based on type signature
01:53:32 <liste> @hoogle [a -> b] -> a -> [b]
01:53:35 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
01:53:35 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
01:53:35 <lambdabot> GHC.OldList map :: (a -> b) -> [a] -> [b]
01:53:41 <jle`> > sequence [(+2), (*3), negate] 10
01:53:44 <lambdabot>  [12,30,-10]
01:53:52 <florin36> liste, thanks
01:53:56 <jle`> > map ($ 10) [(+2), (*3), negate]
01:53:59 <lambdabot>  [12,30,-10]
01:54:30 <jle`> > [(+2), (*3), negate] <*> [10]       -- i guess
01:54:32 <lambdabot>  [12,30,-10]
01:54:54 <jle`> plenty o' ways :)
02:24:56 <Wizek> Hello, anyone knows if it might be possible to have a function of type `(a -> IO b) -> IO (a -> b)`?
02:25:43 <jle`> it isn't
02:25:49 <jle`> im sorry
02:25:54 <Wizek> so am i.
02:26:37 <Wizek> Is that because then that could lead to pure code doing io that it is not supposed to?
02:27:08 <jle`> it's because an IO (a -> b) is a specific program with fixed structure and effects
02:27:14 <jle`> that doesn't depend on any input
02:27:21 <jle`> it doesn't depend on any 'a'
02:27:39 <jle`> an (a -> IO b) would yield a different IO action with different effects for different a's
02:28:10 <jle`> an (a -> IO b) can choose what effects to execute based on an a
02:28:44 <jle`> bit an IO (a -> b)'s effects don't depend on whatever 'a' you eventually feed the function
02:28:55 <jle`> it's an IO action that produces an (a -> b)
02:29:44 <jle`> it can't care about 'a' when deciding its effects...after all, once you execute it to get the (a -> b), you can apply that same function to a bunch of different a's...it wouldn't go back in time to change the effects that happened :)
02:30:11 <implementation> in fact, it is possible (using yolomorphisms), but the side effects will come around and kick your ass if you do it.
02:32:37 <Wizek> yolomorphisms? :D Do you mean e.g. by doing unsafePerformIO? That's one way I could imagine it working
02:33:02 <jle`> "working" is a very generous way of describing it :)
02:33:57 <Wizek> jle`, is that because the order of the IO actions is henceforth undefined?
02:34:03 <implementation> unsafePerformIO (besides inlinePerformIO, unsafeInterleaveIO and unsafeCoerce) is exactly what I mean with "yolomorphisms"
02:34:17 <jle`> Wizek: it doesn't even really make sense
02:34:24 <jle`> what would you want the function to do?
02:34:48 <jle`> whatever idea of what you would want it to do, using unsafePerformIO would not let you match it
02:35:22 <jle`> there is no interpretation of a meaningful (a -> IO b) -> IO (a -> b) that can be implemented using unsafePerformIO
02:36:30 <jle`> the best thing you can do is get something meaningless that matches the type signature
02:37:00 <jle`> but then you might as well write foo _ = error "this doesn't mean anything"
02:37:19 <jle`> and that would be just as meaningful/useful as an implementation using unsafePerformIO
02:37:47 <ongy>  implementation we can avoid side effects. It just makes even less sens: const (return unsafeCoerce)
02:37:59 <jle`> when you consider unsafeCoerce/undefined/error/unsafePerformIO, getting something to match a type signature is trivial :p
02:38:22 <jle`> might as well go even simpler: foo :: (a -> IO b) -> IO (a -> b); foo = undefined
02:38:36 <jle`> got your function :)
02:38:47 <implementation> ongy: but then, the given function is not even called.
02:38:47 <ongy> mine won't crash. Maybe, with luck
02:39:10 <ongy> which is why I said it makes even less sense
02:39:11 <implementation> in  let unio :: (a -> IO b) -> IO (a -> b); unio f = return (\a -> unsafePerformIO (f a))   we just let it escape from IO
02:39:47 <jle`> it "escapes from IO" in the sense that unsafeCoerce :: Double -> Int lets a value "escape from Double"
02:39:57 <jle`> you're basically writing something that doesn't make any sense, just matches the type signature
02:40:00 <Wizek> Well, it may be a little longer to go into what use such a function may have (admittedly, it could help in a way that allows me to do quite a bit of restructuring of parts of a program for now and defer that task for later), but brb I may be able to show how it could make sense
02:41:14 <jle`> Wizek: how should it behave when you pass, say, `\x -> case x of True -> putStrLn "True"; False -> forever getLine`
02:41:29 <jle`> what would the (a -> b) that is returned even be...?
02:41:46 <jle`> er well, bad example
02:41:48 <jle`> heh
02:43:18 <jle`> well, the only result that would make sense would be `return (\_ -> ())`
02:43:23 <jle`> but i doubt that that's what you wanted
02:44:18 <jle`> or you might pass it (\x -> forever (return ()) :: IO Void)
02:44:45 <jle`> er, sorry, i should at least be giving one that has a different effect based on 'x'
02:45:08 <jle`> but yeah, the point is that the effect that happens can depend on x, but in whatever IO action you return, the effect that happens can't depend on what 'a' you give the function
02:46:10 <jle`> but feel free to give an idea of what you *think* the function should do, and i can give you some counter-examples to break the interpretation :)
02:48:48 <Wizek_> implementation's implementation seems to do quite what I was thinking about, it allows for the following: `do f <- unio print; return $ f 1 == ()` although lazyness was confusing for a bit
02:49:02 <Narfinger> hiho, can I let ghci read up until it finds a type error and then keep all the definitions it already loaded?
02:49:10 <Narfinger> I am sure I saw this somewhere but my google-fu is failing me
02:49:26 <Wizek_> Narfinger, -fdefer-type-errors ?
02:49:58 <Narfinger> thanks!
02:51:54 <jle`> Wizek_: what are you trying to achieve with that do block?
02:57:47 <Wizek> jle`, And that's the longer thing to go into. But maybe I can try. Have you ever used AngularJS's (1.x) dependency injection framework? (because if yes that could significantly reduce my explanation time)
02:58:21 <jle`> i haven't :o
02:59:36 <jle`> but yeah, i can promise you that whatever you are planning to use an (a -> IO b) -> IO (a -> b) for, an implementation using unsafePerformIO would not help you implement a useful one
03:00:02 <jle`> except for in rare situations :)
03:01:27 <ashishnegi> hi.. just wondering has anyone tried `kernel drivers` in haskell ?
03:06:10 <implementation> ashishnegi: for which kernel?
03:06:18 <Wizek> jle`, So, if you scroll down to the `assemble` splices here https://github.com/Wizek/hs-di#how you can see how they are transformed into `let .. in ..` expressions. This injection mechanism works well for pure code, and now I want to try an experiment to see if it would make sense to "unwrap" IO from dependencies and let whatever is dependent on them use them as pure values. Which is fairly trivial for leaf dependencies: `let .. in 
03:06:18 <Wizek> nounMonad >>= (\noun-> statement (sentence noun))` 
03:06:26 <ashishnegi> implementation: linux kernel drivers
03:07:43 <Wizek> jle`, But as soon as it is not a leaf, then it becomes more complicated: `let .. in sentenceM noun >>= (\sentence-> statement (sentence))`
03:08:37 <Wizek> jle`, and I imagine my original question could helm pe in this way: `let .. in unio sentenceM >>= (\sentence-> statement (sentence noun))`
03:08:52 <Wizek> jle`, Does that make sense?
03:10:58 <Arguggi> Anyone know if a library with the checked exceptions method described here ( whttps://www.well-typed.com/blog/2015/07/checked-exceptions/ ) was ever released or should I just include the .hs file in my project?
03:31:47 <Wizek> jle`, can you give a counterexample to break my assumptions in what I described above? I'd prefer to know about it before I decide to implement either one of these options. Or maybe this is one of those rare situations?
03:35:21 <ashishnegi> hi.. what should i import to use `MonadIO's liftIO` ... `import qualified  Control.Monad  as CM (liftIO)` is not working.
03:36:01 <lyxia> ashishnegi: that should allow you to use liftIO as CM.liftIO
03:36:21 <ashishnegi> Not in scope: ‘CM.liftIO’
03:36:21 <ashishnegi>     Perhaps you meant one of these:
03:36:22 <ashishnegi>       ‘CM.liftM’ (imported from Control.Monad),
03:36:23 <ashishnegi>       ‘CM.liftM2’ (imported from Control.Monad),
03:36:25 <ashishnegi>       ‘CM.liftM3’ (imported from Control.Monad)
03:36:30 <ashishnegi> compiler errors.. ^^ lyxia
03:37:12 <ashishnegi> do i need to include some package ??
03:37:14 <pkmx> @hoogle liftIO
03:37:16 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
03:37:16 <lambdabot> Test.Framework.Providers.API liftIO :: IO a -> ImprovingIO i f a
03:37:16 <lambdabot> Graphics.Rendering.Cairo liftIO :: MonadIO m => forall a . IO a -> m a
03:37:40 <ashishnegi> there is a Network.CGI as well :P
03:37:49 <Myrl-saki> > (\x -> do (x+) x) 5
03:37:51 <lambdabot>  10
03:37:54 <Myrl-saki> since when?
03:38:19 <ashishnegi> sorry what ?
03:38:50 <pkmx> ashishnegi: you need to import Control.Monad.IO.Class
03:38:55 <lyxia> ashishnegi: ah it's in Control.Monad.IO.Class
03:39:04 <pkmx> which should be in base if you are on GHC 8
03:39:22 <pkmx> otherwise, look into the transformers package
03:39:40 <lyxia> ashishnegi: didn't you get an error telling you that Control.Monad does not export liftIO
03:40:05 <ashishnegi> yaa.. lyxia i got that.. 
03:41:21 <ashishnegi> uh.. its working.. thanks.. i guess my eyes ignored IO.Class when reading docs :(
04:05:03 <Wizek_> Myrl-saki, Hmm, that seems unexpected. Is that because if do notation only contains a single action, bind (>>=) is not used?
04:05:59 <Wizek_> > (\x -> do return (); (x+) x) 5
04:06:01 <lambdabot>  error:
04:06:01 <lambdabot>      • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘show_M34747...
04:06:01 <lambdabot>        prevents the constraint ‘(Show (m0 b0))’ from being solved.
04:06:42 <pkmx> > (do do do do do 1) + (do 2)
04:06:45 <lambdabot>  3
04:10:29 <Wizek_> pkmx, Weird. That is surely unintended behavior, isn't it?
04:13:08 <hx0requiem> Hi everyone
04:13:18 <petercommand> Wizek_: why is that?
04:13:22 <pkmx> Wizek_: it is been defined that way since Haskell 98 i think: do { e } = e
04:13:25 * hackagebot haskell-gi-base 0.18.4 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.18.4 (inaki)
04:13:27 * hackagebot toxcore 0.0.2 - Haskell bindings to the C reference implementation of Tox  https://hackage.haskell.org/package/toxcore-0.0.2 (iphydf)
04:13:46 <petercommand> surely do can be nested
04:14:07 <hx0requiem> may i ask what this channel is about?
04:14:28 <cocreature> hx0requiem: the haskell programming language
04:14:45 <petercommand> hx0requiem: this channel is for the discussions of the Haskell language
04:15:01 <hx0requiem> oh, i actually have little to no idea of haskell
04:15:11 <Wizek_> petercommand, might it not make more sense to define it as `do { e } = e >>= return id`?
04:15:29 <Wizek_> whoops, I meant to say pkmx 
04:15:29 <hx0requiem> though currently studying C now. Just heard somewhere that this is a great chan so i gave it a try lol
04:15:59 <petercommand> Wizek_: why do you want to define do like that?
04:16:53 <petercommand> and that's not correct, I think you mean sth like `do { e } = e >>= \x -> return x` ?
04:17:36 <Wizek_> petercommand, because it seems to me that the semantics of do is vastly different for a single action(? item? line?) and multiple ones
04:18:07 <Wizek_> petercommand, you are right, `do { e } = e >>= return`
04:19:43 <petercommand> yeah, that's ture, the type of a do with only a single item need not be a monad at all, like numbers
04:20:15 <Wizek_> petercommand, Hence: This is surely unintended, isn't it?
04:20:35 <petercommand> hmm, I see your point
04:20:37 <Wizek_> I mean, AFAIK do was intended to make it easier to write multiple binds
04:20:58 <petercommand> yeah, obs that's the intent
04:24:50 <Wizek_> petercommand, Then, might it make sense to report it as a bug and make sure the semantics is uniform? e.g. by changing the definition to: `do { e } = e >>= return`
04:26:04 <Myrl-saki> pkmx: lol
04:26:12 <Myrl-saki> pkmx: oh really?
04:26:25 <Myrl-saki> pkmx: I didn't know about that. That's pretty cool.
04:26:54 <Myrl-saki> petercommand: I have a feeling that this is because of Identity.
04:28:17 <petercommand> Wizek_: it might, but that's not really a big issue imo
04:30:14 <cocreature> Wizek_: I guess the reason why it is that way atm is because do is a syntactic transformation so type information to check that in "do e" e is a Monad might not be available at that point. e >>= return would work but that could incur a performance impact. and to be able to optimize that away your monad needs to abide by a law that is not enforced. and even if you optimize it you create more code just to
04:30:16 <cocreature> optimize it away so your compile times go up
04:30:27 <Wizek_> petercommand, Agreed, I was just surprised.
04:30:55 <Squarism> is there any function :: Maybe (Maybe a) -> Maybe a ?
04:31:01 <Myrl-saki> Squarism: join. :P
04:31:05 <pkmx[m]> do { e1 ; e2 } is desugared into e1 >>=\ _ -> do e2
04:31:10 <Myrl-saki> > join (Just (Just a))
04:31:12 <Myrl-saki> errr
04:31:12 <lambdabot>  Just a
04:31:49 <pkmx[m]> so do e needs to desugar into e for that to type check
04:32:06 <Myrl-saki> oh. i thought it had something to do with monads
04:32:11 <Myrl-saki> i feel sad now. :(
04:33:18 <Wizek_> cocreature, I'd think `>>= return`'s are already optimized away by the compiler, so making such a change would not have runtime differences
04:33:43 <Wizek_> :t (>>= return)
04:33:45 <lambdabot> Monad m => m b -> m b
04:34:26 <petercommand> pkmx[m]: so say, do { do { e } ; e2 } -> do { e >>= return ; e2 } -> (e >> return) >> e2
04:34:33 <petercommand> pkmx[m]: I don't see where the problem is
04:34:58 <petercommand> pkmx[m]: so say, do { do { e } ; e2 } -> do { e >>= return ; e2 } -> (e >>= return) >> e2 #fix typo
04:35:32 <pkmx[m]> :t \e1 e2 -> e1 >>= _ -> (e2 >>= return)
04:35:33 <lambdabot> error: parse error on input ‘->’
04:35:56 <pkmx[m]> :t \e1 e2 -> e1 >>= _ -> (e2 >>= return)
04:35:58 <lambdabot> error: parse error on input ‘->’
04:36:02 <Wizek_> :t \e1 e2 -> e1 >>= \_ -> (e2 >>= return)
04:36:04 <lambdabot> Monad m => m a -> m b -> m b
04:36:21 <pkmx[m]> Hmm matrix is eating my lambda
04:36:35 <petercommand> matrix?
04:36:43 <Wizek_> an irc client I presume
04:36:46 <pkmx[m]> Yeah , you are right it works
04:37:05 <dominik> Hi, I'm currently trying to understand servant's underlying core ideas.
04:37:24 <dominik> to this end, I've tried to implement the API to handler type translation and some primitive routing myself.
04:37:37 <dominik> the snippet is here: http://lpaste.net/8161351294569676800
04:38:10 <dominik> however, somehow I'm still missing some understanding as the type-checker still tells me I'm wrong :-)
04:38:15 <pkmx[m]> My brain cannot function without ghci it seems =(
04:38:29 <dominik> http://lpaste.net/8161351294569676800
04:40:34 <dominik> my first question though is whether the above snippet captures the right thinking about servant's type-translation from some API to the corresponding handlers.
04:41:59 <dominik> and secondly my question would be how to tell the compiler that type family equations mean equal types on the left and the right hand side so that (e.g.) issue #1 would disappear
05:01:37 <e19293001> do you frequently use Hspec?
05:13:26 * hackagebot microformats2-parser 1.0.1.6 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.1.6 (myfreeweb)
05:13:43 <heebo> hello
05:14:27 <heebo> can anyone tell me how to configure emacs to jump to source code?
05:20:03 <ashishnegi> heebo: use intero in emacs 
05:21:11 <ashishnegi> hi.. i want `Text -> "LazyByteSting"`  i am using encodeUtf8 from Data.Text.Lazy.Encoding but getting compiler errors.. Couldn't match expected type ‘bytestring-0.10.6.0:Data.ByteString.Lazy.Internal.ByteString’  with actual type ‘bytestring-0.10.6.0:Data.ByteString.Internal.ByteString’
05:23:07 <geekosaur> where/how are you using it?
05:24:10 <geekosaur> I am seeing it go from lazy Text to lazy ByteString in the haddock; it sounds like you may be using it in a context requiring a strict ByteString
05:24:43 <ashishnegi> geekosaur: i want to pass my custom error message.. like https://github.com/haskell-servant/servant/blob/master/doc/tutorial/Server.lhs#L708 but i have a `Text`
05:25:08 <geekosaur> show actual code
05:26:20 <ashishnegi> sure.. doing
05:29:40 <eikke> Is there any way to silence '-Wredundant-constraints' without using an OPTIONS_GHC pragma which breaks compat with older GHC versions and apparently can't be CPP'ed  out?
05:30:46 <ashishnegi> geekosaur: please see http://lpaste.net/200968
05:30:59 <ashishnegi> line 34
05:32:01 <heebo> ashishnegi: how do i go to source in intero?
05:32:19 <geekosaur> ashishnegi, that doesn't appear to be importing Data.Text.Lazy.Encoding
05:32:34 <geekosaur> it has Data.Text.Encoding which would be the strict one
05:32:49 <ertes> heebo: not sure about intero, but in haskell-mode it's bound to the usual M-.
05:34:37 <ashishnegi> geekosaur: sorry.. i updated the lpaste.. it complains about Couldn't match expected type ‘Data.Text.Internal.Lazy.Text’ with actual type ‘T.Text’
05:35:03 <geekosaur> because that is Data.Text not Data.Text.Lazy
05:35:15 <heebo> ertes: yes , its correct , thats jump to definition of locally defined function..... Not quite what im looking for... I would like to be able to jump to source of a imported Library
05:35:31 <heebo> .... perhaps I ask too much
05:35:56 <ertes> heebo: that's most likely not possible, because the assumption that the source code exists may not even hold, not to speak of where it would be found
05:36:46 <geekosaur> ashishnegi, if that ends up causing trouble because servant is expecting a strict Text there, you may want http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy.html#v:fromStrict
05:36:53 <ashishnegi> heebo: for local fns.. M-. i have not seen library fns jump.. but for that you need to have source of lib as well.. then only it will be able to hook up (if it supports taht ).
05:36:55 <geekosaur> and both versions of Text imported
05:39:16 <ashishnegi> geekosaur: servant wants lazy text .. so i should be using `fromStrict` ideally .. right ?? otherwise if i use another lib that needs strict-text, then what my apis will return ?
05:39:49 <geekosaur> alternately, since it should be short, you can use the strict Text and encodeUtf8 and send the result through https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/bytestring-0.10.8.1/Data-ByteString-Lazy.html#v:fromStrict
05:40:15 <geekosaur> I would expect other type errors given that you are currently using the strict Text
05:41:24 <ashishnegi> now.. `(S.err404 { S.errBody = TE.encodeUtf8 . TL.fromStrict $ e })` passes
05:41:40 <geekosaur> ok, then servant is using strict Text
05:43:20 <ashishnegi> its lazy.. https://github.com/haskell-servant/servant/blob/master/servant-server/src/Servant/Server/Internal/ServantErr.hs#L16
05:43:24 <ashishnegi> i hope.. 
05:43:58 <geekosaur> *that* one is
05:44:10 <geekosaur> but it's also ByteString not Text
05:44:26 <geekosaur> you had imported Data.Text. not Data.Text.Lazy
05:44:45 <ashishnegi> i do `encodeUtf8` for bytestring..
05:45:12 <geekosaur> somehow I think we are not communicating
05:45:23 <Valoo> Hi. I can't solve a type mismatch problem (IO Text/Lazy.Text) in my code: http://lpaste.net/2595497940118142976
05:47:21 <geekosaur> Valoo, you have two problems there. the first is that you need to change `let list = getList` to `list <- getList`
05:47:48 <geekosaur> the second is that scotty apparently expects you to be using Data.Text.Lazy, not Data.Text
05:49:35 <geekosaur> if SQLite expects you to be using strict Text then you will need to use Data.Text.Lazy.fromStrict to turn the result into lazy Text
05:51:19 <heebo> thanks guys i'll see if i can get stack  to download sources
06:03:51 <Myrl-saki> https://gist.github.com/Myrl/2db074561eb7706b30465674d9f0b546
06:03:54 <Myrl-saki> is that correct?
06:07:50 <lyxia> Myrl-saki: no
06:08:23 <lyxia> import qualified Graphics.Gloss as G (event)
06:08:30 <Myrl-saki> Oh.
06:08:35 <Myrl-saki> Thanks.,
06:08:49 <Myrl-saki> Is that a common-place thing?
06:09:03 <Myrl-saki> I'm trying to "combine" 2 libraries together.
06:09:12 <Myrl-saki> Is that what most people do when there's a namespace conflict?
06:09:36 <srhb> dominik: Myrl-saki Qualifying them either in the import or at the use site is your only option, really.
06:09:39 <srhb> Woops
06:09:41 <srhb> Myrl-saki: ^
06:10:12 <Myrl-saki> srhb: yeah, I mean. Is it common to import only the conflict as qualified?
06:10:29 <srhb> Myrl-saki: I think it's a matter of taste.
06:10:34 <Myrl-saki> Ah.
06:10:39 <lyxia> I think it is more common to just import qualified without restricting the import list
06:10:40 <Myrl-saki> Thanks.
06:10:42 <srhb> Myrl-saki: What should be qualified and when is a discussion of epic proportions :-)
06:11:41 <Myrl-saki> :P
06:13:27 * hackagebot data-msgpack 0.0.3 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.3 (iphydf)
06:13:29 * hackagebot idris 0.12.3 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.12.3 (EdwinBrady)
06:18:00 <Myrl-saki> Hmmm
06:52:08 <Forlorn> :i (^)
06:52:28 <Forlorn> (^) :: (Num a, Integral b) => a -> b -> a       -- Defined in ‘GHC.Real’
06:52:39 <Forlorn> what if I don't want Integral?
06:52:47 <Forlorn> 25^(1/2)
06:52:55 <Wizek> :t (**)
06:52:57 <lambdabot> Floating a => a -> a -> a
06:53:10 <Forlorn> Awesome!
06:53:11 <Wizek> > 25 ** (1/2)
06:53:15 <lambdabot>  5.0
06:54:46 <Wizek> I wonder if these two functions could be, or would make sense to be combined
07:01:37 <cocreature> Wizek: they are mathematically different things
07:01:56 <cocreature> ^ is just syntax sugar for repeated multiplication
07:01:59 <cocreature> ** is not
07:04:39 <[k-> we have syntax sugar in mathematics?
07:07:50 <mtesseract> [k-: I would say, as soon as you are using some kind of convention in your scientific community, i.e. someothing like "I write this to mean that", that could be regarded as syntactic sugar. The major differences seems to be that the parser is a human, not a program.
07:09:04 <[k-> I would regard human-y things as convention
07:09:31 <cocreature> well I guess ^ is not quite syntax sugar, but it’s something you can straightforwardly define using only multiplication. ** is not as easily defined
07:10:30 <the_2nd> I want to repeat a list forever. e.g. [a, b, c, d] => [a, b, c, d, a, b, ...]  Is there a built-in function for this?
07:10:58 <cocreature> > cycle [1,2,3,4]
07:11:02 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2...
07:11:12 <the_2nd> cocreature, thanks
07:11:19 <cocreature> yw
07:13:28 * hackagebot nested-routes 7.2.2 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-7.2.2 (athanclark)
07:13:30 * hackagebot http-client-tls 0.3.3 - http-client backend using the connection package and tls library  https://hackage.haskell.org/package/http-client-tls-0.3.3 (MichaelSnoyman)
07:15:36 <Myrl-saki> nitrix: desu
07:16:37 <Myrl-saki> oh wait. what.
07:17:01 <Myrl-saki> this doesn't need any forall "constraints"?
07:17:06 <Myrl-saki> that's cool.
07:29:25 <Myrl-saki> Oh. I see. It doesn't even need to be IO. Ehh.. hmm.
07:52:50 <ben> Is Data.ByteArray some politically-correctly-named ByteString clone that tries to not tempt people to use it for text?
07:56:47 <pavonia> ben: It's not a type but a typeclass
07:57:04 <ben> Well, the module ships a type too
07:57:10 <ben> but ok, it's trying to be more general
07:59:50 <colo> a
08:04:32 <colo> how this works?
08:05:35 <srhb> colo: IRC?
08:05:41 * ski looks at colo
08:05:56 <colo> yes
08:06:03 <srhb> colo: You talk about Haskell, we talk about Haskell, everyone is gloriously happy. :-)
08:06:27 <colo> so atm nobody is talking right?
08:06:32 <ski> you are talking
08:06:39 <colo> ok got it
08:09:12 --- mode: hitchcock.freenode.net set +o ChanServ
08:09:12 --- kick: bitch was kicked by ChanServ (Banned: Inappropriate nickname prefix)
08:09:44 * ski blinks
08:09:55 <EvanR> there goes bitchx then
08:10:06 <EvanR> a totally valid jargon on irc
08:10:42 <colo> I am trying to write a 2d vector module, but i cant figure out how to properly implement operations that works both between vectors and numbers and between two vectors
08:12:15 <athan> ben: I think there's something different with the C FFI about it, or something along those lines
08:12:19 <athan> I've seen it used in cryptonite
08:12:39 <athan> colo: That sounds like an interesting problem :)
08:13:02 <athan> So basically what you're saying is, you can't make a `Num a => Num (Vector a)` instance?
08:13:17 * athan veers left
08:13:30 * hackagebot octane 0.16.3 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.16.3 (fozworth)
08:13:32 * hackagebot tagsoup-selection 0.1.0.1 - Selecting subtrees from TagSoup's TagTrees using CSS selectors  https://hackage.haskell.org/package/tagsoup-selection-0.1.0.1 (siracusa)
08:13:34 * hackagebot conduit-connection 0.1.0.2 - Conduit source and sink for Network.Connection.  https://hackage.haskell.org/package/conduit-connection-0.1.0.2 (slomo)
08:13:51 <athan> Is there a typeclass for homomorphisms? Or distributive properties or something? :s
08:14:08 <athan> s/typeclass/meaningfully cool thing
08:14:15 <EvanR> colo: like what
08:14:16 <ben> yeah i came from cryptonite
08:14:25 <ben> and was like why is this not a bytestring what is going on
08:14:32 * ski . o O ( `(+) :: Num a => Tensor m a -> Tensor n a -> Tensor (Max m n) a' )
08:14:32 <athan> ben: Just use convert :)
08:14:43 <athan> er Data.ByteArray.convert
08:14:48 <athan> because ByteString is an instance of it
08:14:50 <ben> that won't enlighten me as to what they were thinking! :D
08:14:55 <athan> oh! I think it's for some kind of mutable interface
08:15:05 <athan> like MVector would be
08:15:09 <ski> athan : type would be better than type-class, usually, i'd think
08:16:03 <athan> ski: Yeah I think you're right, I just don't know of a common approach to enlighten the user of my codebase of its property
08:16:12 <colo> i need a function to that can sum vectors and numbers or two vectors
08:16:26 <ski> what kind of structure should the homomorphism be preserving ?
08:16:38 <athan> shoot idk, I never really saw the (.)-map homomorphism until I really started haskelling
08:16:40 <ski> colo : and also matrices and tensors, i take it
08:17:02 <colo> actually i only need simple 2d vectors
08:17:04 <ski> "(.)-map homomorphism" ?
08:17:22 <athan> ski: Exactly haha, I just don't know how one would go about the different structure preservations, encoded in a type{,class}
08:17:26 <ski> colo : may be harder, if you want a single operation
08:17:48 <ski> colo : the simplest may be to define `(.+)' and `(+.)' for adding a scalar with a vector, and vice versa
08:18:02 <athan> ski: Just how (.) can commute over fmap - fmap f . fmap g == fmap (f . g)
08:18:13 * athan isn't using words right, he knows it
08:18:22 <athan> rightly*
08:18:40 <ski> athan : oh, that's about functors being category homomorphisms, iow preserving the category structure (here `(.)')
08:18:40 <colo> yes, but i'd like a single operator
08:19:23 <ski> colo : you might be able to do something with tensors, as a indicated above, if you turn on `DataKinds' and `TypeFamilies' ..
08:19:33 <ski> s/as a/as i/
08:20:08 <ski> (where `Tensor 1 a' would be `Vector a', and `Tensor 0 a' would be `Scalar a', or somesuch)
08:20:10 <colo> sorry, can you explain
08:20:33 <athan> ski: That's a wicked design o_o
08:20:48 <ski> athan : it feels perhaps slightly silly
08:20:51 <athan> with phantoming products and stuff
08:20:55 <colo> i see
08:20:58 <MarLinn> colo: or maybe a multi parameter type class alone might be an approach
08:21:00 <athan> well yeah haha, DataKinds >.>
08:21:14 <ski> perhaps using tensors that are polymorphic in the "dimension tail" would be nicer ..
08:21:28 <colo> something like Either?
08:22:59 <ski> well, the idea would be that the type system would know the dimension of the tensor
08:23:06 <srhb> MarLinn: You'd probably still want at least fundeps for Multiplication a b c | a b -> c, I guess
08:23:16 <ski> (so there would be no run-time checking about that)
08:23:37 <MarLinn> srhb: yeah, I was just about to write that, too
08:23:47 <EvanR> wait... what happens when you add two things with different dimensions
08:24:00 <srhb> Also I agree, this is something that's worthwhile to at least try out :(
08:24:02 <srhb> :) *
08:24:16 <srhb> (There's vectorspace for when it gets too unwieldly unusing the same operator)
08:24:25 <srhb> using. Guh, can't type today.
08:24:31 <ski> colo : an alternative (depending on how you want to use it) would be to define `(*)' as matrix multiplication, for possibly non-square matrices
08:25:07 <ski>   (*) :: Num a => Matrix n o a -> Matrix m n a -> Matrix m o a
08:25:44 <ski> (or perhaps using a different name for the operation)
08:25:58 <MarLinn> EvanR: They wrote that they only need skalars + 2d vectors. (still an interesting question in general)
08:26:12 <colo> for the moment i'm focusing only on vectors, not matrics
08:26:20 <ph88> can anyone recommend a diff package to diff two data structures? i found a few packages but i'm not sure which one to pick
08:26:20 <colo> martices*
08:26:23 <srhb> colo: Look at MarLinns suggestion, in case you missed it, it's the simplest route to do exactly what you asked for. :)
08:27:04 <ski> and then you could have `instance Num a => Num (Matrix m m a) where ...', so that if you write `3 :: Matrix 4 4 Double', then you'd get `3' scaled into the identity matrix
08:27:07 <colo> srhb: does that means something like Either
08:27:16 <athan> What are some interesting properties which * :: * entails? Does this make all kinds Typeable or something?
08:27:28 * ski isn't quite sure what colo has in mind by "something like Either"
08:27:48 <srhb> colo: Have a type class a la `class Multiplication a b c | a b -> c` with your multiplication operator of choice, then make instance for each combination of a, b and c that you want
08:28:13 <srhb> colo: eg instance Multiplication Double Vec2D Vec2D etc.
08:28:37 <athan> Because then with -XTypeInType, could you not be able to tell DataKinds from *? Is (* -> *) :: *?
08:30:03 <srhb> colo: `| a b -> c` reads as "where the type of a and b decide the type of c" -- which is what you seem to be asking for. :)
08:30:22 <colo> yes
08:31:04 <colo> i'm new to haskell so it takes a while for me to understand yours replies sorry
08:31:11 <srhb> colo: That's totally fine.
08:33:18 <Eduard_Munteanu> athan, falsehood, that's an interesting property entailed by * :: *. Dunno if you can prove it in Haskell though.
08:33:54 <Eduard_Munteanu> But it's known to be broken in Coq and Agda.
08:33:55 <ski> Eduard_Munteanu : `falsehood :: forall a. a; falsehood = falsehood'
08:34:05 <ski> replace `forall a. a' by `Void', if you prefer
08:34:17 <Eduard_Munteanu> Well, sure. There are already a million ways to do it in Haskell.
08:35:53 <athan> Eduard_Munteanu: You mean a Void at the kind level..?
08:36:21 <edwardk> colo: the downside of the approach mentioned with the multiplication class is that inference becomes much worse in haskell given z = x + y, you can infer the type of all 3 given the type of any one of x or y or z.
08:36:38 <edwardk> colo: in languages where type inference is 'forward only' at best, this isn't an option
08:37:04 <edwardk> but it does mean that code using such a custom multiplication operator will have much worse inference than haskell generally offers
08:37:15 <EvanR> Eduard_Munteanu: freezing the type checker after enabling only TypeInType, not sure yet if its possible
08:37:38 <EvanR> youd think it would be
08:37:41 <Eduard_Munteanu> athan, well, an inhabitant of Void.
08:37:56 <athan> oh snap! Okay I think I understand
08:37:58 <EvanR> but actually i still dont fully understanding girards paradox
08:38:33 <edwardk> Void at the kind level still has that pesky a :: Void inhabitant that doesn't get ruled out until you concretize a.
08:38:55 <colo> edwardk: what are the consequences of a worse inference? and what do you advice istead
08:39:13 <edwardk> colo: in linear what we do is offer up operators for .* and *. for scalar-vector multiplication
08:39:43 <edwardk> yes, the notation is ever slightly less convenient, but now inference works across the board
08:39:44 <EvanR> MarLinn: so... an auto promotion from x to (x,x) ?
08:40:03 <colo> ok
08:40:27 <EvanR> i support .* *. and /. notation
08:40:29 <colo> thanks
08:40:37 <EvanR> i like when the compiler can tell me i didnt mean what i said because its nonsense
08:40:48 <EvanR> unlike the + situation in js
08:41:53 <edwardk> colo: anyways the consequence is that in very mathy code the compiler can't help you much with determining if a constant should be a scalar or a vector, etc. so you have to be much more explicit
08:42:09 <edwardk> https://github.com/ekmett/ad/blob/master/src/Numeric/AD/Newton.hs#L311 uses a bunch of sub-expressions that are all having their type inferred by the compiler
08:42:37 <edwardk> in a world with a more general *, you'd have to go through and pick for each one if it was scalar or vector, use scoped type variables to pass those types around, etc.
08:42:45 <edwardk> things'd become twice as verbose
08:42:50 <edwardk> to save a few .'s
08:43:47 <edwardk> whether you view that as a good thing or a bad thing is a matter of personal taste, but i like inference to work
08:44:03 <EvanR> this kind of sounds like the argument for ocaml + and .+
08:44:12 <edwardk> meh
08:44:25 <EvanR> which didnt invent type classes
08:44:25 <monochrom> hehe
08:44:28 <edwardk> we have bidirectional inference, so its a much weaker complaint
08:44:35 * ski idly wonders whether there's a library for tensors that keeps track of co- / contra- variance
08:44:49 <edwardk> ski: i have code for doing so with a pair of hlists
08:45:32 <edwardk> it is kinda peculiar to my funny sparse matrix multiplication code though
08:45:39 <edwardk> just updated for tensors
08:45:51 <hc> what's the recommended way to get the current minute in the current timezone?
08:45:57 <edwardk> doesn't ensure linear index usage though
08:47:29 <colo> i'll use the .* notation
08:47:54 <EvanR> hc: look in Data.Time.LocalTime
08:48:26 <hc> yeah... doing that already
08:48:28 <EvanR> getCurrentTimeZone :: IO TimeZone gives you a TimeZone, which is really an "offset"
08:48:39 <EvanR> then apply that to the current UTC time to get a LocalTime
08:48:51 <hc> yeah, I got a localtime...
08:48:53 <EvanR> utcToLocalTime :: TimeZone -> UTCTime -> LocalTime
08:48:56 <hc> but I need a TimeOfDay
08:49:14 <EvanR> localTimeOfDay :: LocalTime -> TimeOfDay
08:49:20 <lpaste> hc pasted “cur minute.hs” at http://lpaste.net/201500
08:49:22 <EvanR> its one of the fields in LocalTime
08:49:28 <hc> EvanR: that's what i got so far
08:49:43 <Sonarpulse> How does cabal 1.24's nix-style builds treat packages that come with GHC? 
08:49:44 <hc> oh
08:50:02 <Sonarpulse> without taking into account globally-installed packages into the build plan?
08:50:28 <hc> EvanR: ah, yeah, got it, thank you!
08:50:30 <colo> i have another question: would you recommend including a NullVector value for the vector data type?
08:52:33 <dazz> hi
08:52:45 <Eduard_Munteanu> Hi, dazz.
08:53:16 <dazz> hello Eduard
08:55:46 <miky72> ciao
09:13:31 * hackagebot http-pony 0.1.0.0 - A type unsafe http library  https://hackage.haskell.org/package/http-pony-0.1.0.0 (JinjingWang)
09:13:33 * hackagebot logic-classes 1.7.1 - Framework for propositional and first order logic, theorem proving  https://hackage.haskell.org/package/logic-classes-1.7.1 (DavidFox)
09:13:35 * hackagebot aeson 1.0.1.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.0.1.0 (AdamBergmark)
09:22:19 <colo> where can i find the infix definition of the basic operators eg + - *
09:24:07 <ahihi> in ghci, try :i +
09:24:49 <pavonia> colo: The instances of Num should be defined in the Prelude or at least imported from there
09:24:57 <colo> ahihi: exactly what i was looking for, thanks
09:33:43 <Myrl-saki> Hmm
09:33:51 <Myrl-saki> nitrix: I'm trying to understand what the underlying monad is for though.
09:41:54 <Myrl-saki> oh boi.
09:45:06 <ph88> can anyone recommend a diff package to diff two data structures? i found a few packages but i'm not sure which one to pick
09:45:33 <suzu_> what data structures are they?
09:45:45 <ertes> ph88: my first guess would be to try whatever darcs uses
09:48:02 <nitrix> Myrl-saki: ertes just joined if you want to ask him.
09:48:28 <Myrl-saki> nitrix: xD
09:48:33 <nitrix> Myrl-saki: The monad below is to let you have monadic events or behaviors I'd assume.
09:49:23 <Myrl-saki> nitrix: The underlying monad is for 'getting' 'b', I think.
09:49:45 <nitrix> The whole wire is in that monad.
09:50:04 <Myrl-saki> nitrix: Isn't it only b? It's `a -> m (..)
09:50:27 <Myrl-saki> nitrix: https://github.com/esoeylemez/wires/blob/master/Control/Wire/Internal.hs#L85
09:50:41 <ertes> i'm assuming that this is about wires…  the underlying monad is for controllers: constructing events from m-pollers, animating behaviours using m-actions, reacting to events using m-actions
09:50:47 <nitrix> Myrl-saki: I guess, yeah. I think `Wire m a b` desugars to something akind to `a -> m b`
09:51:00 <ertes> to understand what the underlying monad is for, look at .Controller
09:51:03 <Myrl-saki> ertes: Yep, your assumption was right.
09:52:07 <ertes> it's also used for constructing constant behaviours for an initial m-action
09:52:11 <Myrl-saki> nitrix: I'll probably fail hard, but I'm trying to make a GUI(for games) library from this.
09:54:10 <ertes> Myrl-saki: is this GUI going to run at a certain framerate?  or are you using more like a widget GUI that is mostly static unless interacted with?
09:54:20 <Myrl-saki> ertes: The former.
09:54:41 <Myrl-saki> ertes: I quite liked reflex-dom's approach, but I'm not quite sure if that will work for a game lib.
09:54:49 <ertes> ok, then wires is fine =)
09:54:55 <ertes> otherwise i would have recommended reflex
09:55:22 <Myrl-saki> ertes: I was actually using reflex-gloss until nitrix notified me about this.
09:55:35 <nitrix> ertes: I have suggestions for wires.
09:56:36 <ertes> nitrix: go ahead, but let's once again move it to the less noisy #haskell-game =)
09:56:36 <Myrl-saki> :t fix
09:56:38 <lambdabot> (a -> a) -> a
09:56:46 <Myrl-saki> Man. This always gets me.
10:04:53 <icicled> does anyone have a run-down of tradeoffs between using typeclasses vs record of functions to implement swappable implementations of functions for use during testing?
10:09:32 <lyxia> you can only have one typeclass per type
10:10:15 <lyxia> so it's not as easy to swap as records of functions
10:12:06 <amalloy> one instance of a given typeclass per type
10:12:15 <lyxia> oh right
10:13:32 * hackagebot raz 0.1.0.0 - Random Access Zippers  https://hackage.haskell.org/package/raz-0.1.0.0 (lyxia)
10:13:34 * hackagebot pusher-http-haskell 1.1.0.2 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.1.0.2 (willsewell)
10:13:36 * hackagebot pagerduty 0.0.8 - Client library for PagerDuty Integration and REST APIs.  https://hackage.haskell.org/package/pagerduty-0.0.8 (BrendanHay)
10:15:51 <nitrix> Myrl-saki: fix f = let x = f x in x
10:16:34 <Myrl-saki> nitrix: Yeah.
10:16:44 <ertes> icicled: if you find your code *choosing* the implementation a lot, then records are better…  if you just want to use type-based choice, go with a class
10:17:04 <nitrix> Myrl-saki: Thus, the function you give to `fix` is going to have itself as its first argument.
10:17:12 <nitrix> Myrl-saki: fix $ \loop -> ... >> loop
10:17:23 <Myrl-saki> Oh. I see.
10:17:25 <Myrl-saki> Right.
10:17:47 <Myrl-saki> I think that means I should get some sleep
10:18:02 <Myrl-saki> Since i'm barely understanding simple things right now.
10:18:04 <Myrl-saki> :|
10:18:08 <nitrix> Fix too me a while to undestand :)
10:18:15 <nitrix> (And fixed point functions in general)
10:18:27 <Myrl-saki> nitrix: I kinda understood fix back then already
10:18:33 <Myrl-saki> But that took me like 10 minuters.
10:18:50 <Myrl-saki> nitrix: And I've been trying so hard to undrestand `concat` right now
10:19:15 <nitrix> Myrl-saki: Really? Foldable's concat?
10:19:19 <GLM> Does anyone have experience with the distributed-process library?
10:19:37 <Myrl-saki> nitrix: Not even Foldable. Just []
10:19:48 <Myrl-saki> I mean
10:19:59 <nitrix> Myrl-saki: concat @[] :: [[a]] -> [a]
10:20:02 <Myrl-saki> I know this, but I think I'm too sleepy to reason out properly.
10:20:51 <nitrix> That's TypeApplication notation for me specializing the `Foldable t` as `[]`.
10:21:05 <Myrl-saki> Ah.
10:21:16 <icicled> ertes: the only place I see myself swapping the implementations are during tests
10:21:27 <Myrl-saki> I'm gonn go to sleep. I can't think straight already
10:21:31 <nitrix> You have a nested list and your result is a single list, the elements are just flattened (concatenated).
10:21:44 <nitrix> > [[1,2,3], [4,5,6]]
10:21:47 <lambdabot>  [[1,2,3],[4,5,6]]
10:21:50 <nitrix> > concat [[1,2,3], [4,5,6]]
10:21:53 <lambdabot>  [1,2,3,4,5,6]
10:21:59 <icicled> I've seen quite a few blog posts that show the typeclass "way" but none that cover swappable functions in records
10:22:24 <Myrl-saki> gnight
10:23:31 <ertes> icicled: you can use newtypes for that
10:23:50 <suzu_> > foldr (++) [] [[1,2,3], [4,5,6]]
10:23:52 <lambdabot>  [1,2,3,4,5,6]
10:24:26 <icicled> ertes: yea I figured that was the way to do it with the typeclass approach
10:24:47 <icicled> thanks for confirming that
10:25:51 <icicled> I think I'll stick with records of functions since that's less boilerplate for me to manage
10:26:45 <ertes> icicled: yeah…  type classes are just a fancy method to pass those records implicitly after all…  if you don't actually need that, they may get in your way more than they help
10:26:57 <hsk3> join #macdev
10:27:06 <hsk3> sorry forgot /
10:28:52 <icicled> ertes: that's what I'm thinking - also if I need to constrain functionality there's mtl (also ConstraintKinds)
10:29:49 <icicled> I'm going to have to write this up in a blog post after I've figured this out
10:30:15 <icicled> thanks ertes 
10:30:31 <mpickering> Say I want to store a large complicated (Haskell) data type in a database, what do people usually do here? Do they create a schema which matches the type or serialise it and store the blob?
10:30:37 <hsk3> Let's say I create the folder ~/my-haskell-packages/
10:30:38 <hsk3> Inside it I create: ~/my-haskell-packages/my-package
10:30:38 <hsk3> Is there a way to configure Stack globally so that all Stack projects anywhere on the system can find my-package?
10:30:45 <hsk3> (Similar to hackage packages except just on the local computer.)
10:31:55 <icicled> mpickering: json + blob seems to work well enough as long as you don't need to modify outside the application - you could use any serialization technique
10:32:33 <icicled> mpickering: if you'reusing postgresql consider using jsonb.  sqlite has json functions now too
10:38:58 <florin36> hi, I have a question: I'm trying to find out if sequence function evaluates it's second argument more than once 
10:39:51 <florin36> I wrote this code http://lpaste.net/201803
10:40:18 <florin36> running it returned the same two values 
10:40:44 <mpickering> I guess it would be nice to have a proper schema so I could run queries about the data I have
10:40:55 <mpickering> Are there any tools which generate schemas from data type definitions
10:43:01 <ReinH> Aeson
10:43:28 <mpickering> Aeson can't generate sql schemas can it?
10:43:51 <mpickering> can you still query the jsonb fields? 
10:44:40 <juri_> I'm having trouble creating new instances for show without running into 'Orphan instance: instance [incoherent] Show BoxedObj3' . how do i add an instance without getting that warning?
10:45:12 <glguy> juri_: Define the instance in the same module as the BoxedObj3 type is defined
10:45:28 <ReinH> I thought you meant JSON schemas
10:45:36 <juri_> um, i am?
10:46:57 <ReinH> If you aren't querying into the JSON then it doesn't matter if your database has that feature, or if it's JSON at all. You might be able to use a more efficient binary encoding for instance.
10:47:21 <ReinH> @lpaste
10:47:21 <lambdabot> Haskell pastebin: http://lpaste.net/
10:47:39 <ReinH> juri_: show us the code and the error
10:49:14 <juri_> http://lpaste.net/201823
10:49:23 <juri_> those are the relevent lines.
10:49:26 <icicled> mpickering: yes you can still query against the json blobs in postgresql and sqlite
10:49:42 <icicled> mpickering: they have built-in functions for that
10:50:32 <mpickering> how do they enforce consistency across all the blobs?
10:51:01 <icicled> mpickering: they don't - you should normally do that in your application layer
10:51:11 <pavonia> juri_: R is just a type synonym for an already defined type
10:51:17 <icicled> or if you really want to enforce it at the db level you can write a trigger
10:51:50 <buglebudabey> I recently made a datatype of mine an instance of Monoid, can someone see if the new operation of mappending two datatypes is slower than my older version (line 57) ? I have a feeling it is: https://github.com/aneksteind/hext/commit/9ad6e16525df3be95b63e50159f52182c195b416
10:52:18 <juri_> sure. but i'm trying to add an instance for (ℝ -> ℝ)
10:52:42 <hsk3> Is it normal for people to upload their own personal packages to hackage - for their own convenience?
10:52:53 <hsk3> (and in the unlikely case someone else finds it useful)
10:53:05 <MarcelineVQ> buglebudabey: http://www.serpentine.com/criterion/tutorial.html
10:53:42 <buglebudabey> hsk3 it's normal but hackage is meant for other people to use your package, it kind of muddies the water if we have a bunch of personal projects that don't directly contribute to some sort of goal (just my opinion)
10:53:48 <jle`> hsk3: i don't think so -- there's a certain standard of documentation and universality and maintenance expected out of hackage, to me
10:53:48 <buglebudabey> hsk3 in my opinion that's what github is for
10:53:52 <jle`> although i have seen it done
10:54:07 <pavonia> juri_: It's just a warning, as long as you don't export the instance from a module, it should be okay to ignore it
10:54:09 <jle`> yeah, with stack, you can use github packages just as if they were on hackage, so there's no point in putting it on hackage
10:54:14 <jle`> you also pollute the namespace potentially
10:54:36 <hsk3> makes sense
10:54:42 <juri_> um, i'm trying to get rid of the warning, and do it 'right'.
10:55:03 <jle`> Wizek: sorry, went to bed earlier last night!
10:55:50 <ReinH> juri_: what does that code have to do with the error?
10:56:35 <pavonia> juri_: There's -fno-warn-orphans
10:56:36 <glguy> juri_: Generally it's good to avoid making orphan instances, and it's good to avoid making instances that specify more than the top-most type constructor. In your function case there's already a Show instance you can use.   import Text.Show.Functions ()
10:59:09 <buglebudabey> in [a] ++ as where you know [a] is a singleton, will it always be slower than a:as?
10:59:52 <glguy> buglebudabey: No, not with optimizations turned on
11:00:34 <buglebudabey> glguy is that something i'd have to do in my command when running/compiling or can i use an extension to always make it the case in my code
11:00:56 <glguy> cabal builds with optimizations by default
11:01:06 <buglebudabey> glguy what about stack
11:01:13 <glguy> stack uses cabal to build
11:01:21 <buglebudabey> ok thanks
11:01:38 <glguy> I'm sure it doesn't disable optimizations by default
11:01:38 <buglebudabey> i realize that last question was a bit silly
11:13:33 * hackagebot clock-extras 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/clock-extras-0.1.0.0 (JonathanFischoff)
11:13:35 * hackagebot clock-extras 0.1.0.1 - A couple functions that probably should be in the 'clock' package  https://hackage.haskell.org/package/clock-extras-0.1.0.1 (JonathanFischoff)
11:13:37 * hackagebot threads-extras 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/threads-extras-0.1.0.0 (JonathanFischoff)
11:15:15 <shachaf> Oh, Author name here has finally uploaded the Initial project template from stack code.
11:15:27 <shachaf> I've been waiting for that.
11:16:56 <glguy> Cool, I always wondered who example@example.com was
11:17:02 <glguy> That's good name to get
11:19:23 <Rarrikins> Even better, the description on the Hackage page is "Please see README.md"
11:19:36 <glguy> Sure makes it easy to spot the stack users
11:23:15 <ph88> ertes, darcs uses it's own diffing thing i think .. don't see any diff listed at dependencies
11:25:30 <ertes> ph88: it's also only for sequences…  you were talking about "data structures", so i'm not sure
11:27:05 <ph88> ah ok ^^
11:27:18 <ph88> i thought maybe one of these:
11:27:18 <ph88> https://hackage.haskell.org/package/gdiff-1.1/docs/Data-Generic-Diff.html
11:27:22 <ph88> https://hackage.haskell.org/package/HUnit-Diff
11:27:26 <ph88> https://hackage.haskell.org/package/gdiff-ig
11:27:30 <ph88> https://hackage.haskell.org/package/debug-diff
11:37:18 <ph88> be back later
11:45:27 <ashishnegi> hi.. i have made a web crawler.. and it shares parsed-data on the channel.. i have 2 crawling threads forked.. and main fn doing a `fix-loop` untill it gets `crawlfinished` msg. I find that my main fn does not receive any event untill these 2 threads are done.
11:47:15 <ashishnegi> http://lpaste.net/201972 -- "getting msgs" is never printed until all crawling thread finishes..  
11:47:54 <shachaf> shapr: whoa whoa whoa, shapr++
11:56:23 <intothemountain> Can I do IO inside the evaluated expression of a case expression?
11:56:51 <intothemountain> Something life "case <- doMyIO of ..."
11:58:36 <lyxia> doMyIO >>= \case
11:59:08 <intothemountain> lyxia: thanks!
11:59:12 <lyxia> yw!
11:59:46 <hsk3> What happens if one of my project's dependencies has as different stack resolver than my own project's stack resolver?
11:59:46 <hsk3> Will Stack just gracefully compile both with those two different resolvers? What if those two resolvers have different GHC versions?
12:00:15 <glguy> Your package should specify all its dependencies and bounds in teh package.cabal file
12:00:37 <hsk3> Ok I see now.
12:00:38 <glguy> the stack.yaml only specifies the versions being used locally in that particular working directory
12:01:21 <hsk3> glguy: so basically, when building my project, the project resolver will be ignored
12:01:34 <hsk3> i mean, the *dependency's* resolver
12:01:41 <glguy> yeah, the stack.yaml for that project is only for when you're building in that projects directory
12:01:50 <glguy> It doesn't define what versions you project supports
12:01:50 <hsk3> ok cool thanks
12:01:51 <intothemountain> lyxia: where do I do the pattern matching there? should I add an 'of'? what would go between 'case' and 'of'?
12:02:25 <lyxia> intothemountain: just on the next line
12:03:18 <intothemountain> lyxia: it raises a parse error
12:03:26 <lyxia> intothemountain: you need lambdacase
12:03:40 <intothemountain> oh, right
12:13:35 * hackagebot threads-extras 0.1.0.1 - Extends the threads package with a bounded thread group  https://hackage.haskell.org/package/threads-extras-0.1.0.1 (JonathanFischoff)
12:13:37 * hackagebot highlighting-kate 0.6.3 - Syntax highlighting  https://hackage.haskell.org/package/highlighting-kate-0.6.3 (JohnMacFarlane)
12:13:39 * hackagebot next-ref 0.1.0.0 - A concurrency primitive for a slow consumer.  https://hackage.haskell.org/package/next-ref-0.1.0.0 (JonathanFischoff)
12:13:41 * hackagebot next-ref 0.1.0.1 - A concurrency primitive for a slow consumer.  https://hackage.haskell.org/package/next-ref-0.1.0.1 (JonathanFischoff)
12:38:00 <Valoo> I am trying to use SQLite.Simple with Scotty, but I still can't get it to work: http://lpaste.net/774515481167003648
12:41:24 <geekosaur> half of that is list <- liftIO getList
12:41:49 <geekosaur> the other half... may, depending on how it went about inferring the type of getList, fix itself
12:55:51 <ashishnegi> hi.. has anyone used `servant` here ? seems like a small doubt.. how to write Api-type for "job/status/:job-id" ? ...   `"job/status/" :> S.Capture "id" ST.JobId :> S.Get '[S.JSON] ST.JobStatus` does not seem to work... getting 404 on `job/status/2` 
12:56:18 <geekosaur> Valoo, btw you will need to learn why liftIO is needed there or Haskell will just be frustrating fo ryou
13:06:41 <tastey_lemon> Hey all. Was wondering if anyone could point me to some good armitage useages i have a busted screen on my note 5 and i need to make a backup of it but i have set the phone into dev. Mode and locked it
13:07:25 <benzrf> if i have a datakind k, how can i define a function of type `forall (x :: k). <some stuff here>' where i need different logic depending on the structure of x?
13:07:33 <glguy> tastey_lemon: This is #haskell, which is for discussion for the Haskell programming language
13:08:04 <benzrf> i tried using a typeclass, but the type checker can't figure out that my instances cover all possible inhabitants of k
13:08:32 <benzrf> am i going to need to use an argument that has a value level reflection of the type?
13:10:52 <benzrf> or, i guess - hmm... i guess if there's no constraint at the call site, then that means there's no runtime representation of which x i have, which means what i want to do doesn't make sense
13:10:52 <benzrf> :(
13:12:50 <johnw> benzrf: you can do runtime reflection using a singleton
13:13:03 <benzrf> can you elaborate
13:13:07 <benzrf> i dont know about those
13:13:21 <johnw> I don't know the exact syntax for an arbitrary kind, but along the lines of forall (x :: k), Sing x
13:13:36 * hackagebot hfmt 0.0.2.3 - Haskell source code formatter  https://hackage.haskell.org/package/hfmt-0.0.2.3 (danielstiner)
13:13:42 <johnw> where Sing x will hold the value-level representation of your type-level k
13:13:52 <johnw> (sorry, type-level x)
13:15:16 <johnw> the singletons library, as you might guess from the name, is based on this technique
13:15:27 <johnw> and there is a very good paper describing how it achieves this
13:16:05 <ashishnegi> servent solution.. found `"job" :> "status" :> Capture "id" ST.JobId ...`
13:16:09 <ashishnegi> :)
13:48:47 <elliptic00> anyone know how to log all the typing in GHCi?
13:50:26 <colo> how can i benchmark a function?
13:51:58 <lyxia> @hackage criterion colo
13:51:59 <lambdabot> http://hackage.haskell.org/package/criterion colo
13:52:15 <ertes> elliptic00: not sure if that counts, but GHCi normally saves its history
13:52:31 <ertes> elliptic00: see ~/.ghc/ghci_history
13:52:57 <glguy> elliptic00: You can log all the typing into GHCi by typing into a .hs file and then loading that with GHCi. If you change the file you can reload with :r
13:53:14 <colo> i already tried but got always the same result with any function, what could cause this?
13:54:30 <orion> Is there an efficient way to convert a Data.Vector to a CArray?
13:54:55 <elliptic00> glguy , sometimes I need to do some quick dirty check in GHCi for some functions, and don't want to create a .hs file, and I need to copy all some typing to somewhere e.g. StackOver flow
13:55:37 <elliptic00> glguy it is good to just open the file, 
13:55:53 <srhb> orion: Data.Vector.Storable
13:56:23 <jmcarthur> orion: http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable.html#g:36
13:56:25 <lyxia> colo: that might be caused because the value you want to compute somehow gets computed only once
13:56:59 <orion> Oh, hmm... My intention is to use the 'fft' package, which uses CArrays from the 'carray' package.
13:57:10 <lyxia> colo: maybe you could paste some of your benchmarking code?
13:57:25 <colo> sure, in a sec
13:57:43 <jmcarthur> orion: http://hackage.haskell.org/package/carray-0.1.6.5/docs/Data-Array-CArray.html#g:11
13:59:32 <orion> jmcarthur: Are you suggesting I simply copy the ForeignPtr over from the Vector to the CArray?
13:59:51 <jmcarthur> yup
14:00:02 <orion> Makes sense. Thanks!
14:00:24 <jmcarthur> Just make sure you are aware of why some of these operations are unsafe
14:03:36 <orion> AFAIK, they're unsafe because there's no way for the runtime to guarantee immutability in the face of ForeignPtr.
14:04:08 <colo> lyxia: http://pastebin.com/DB2fhUGn
14:05:58 <lyxia> colo: whnf will not force the whole list
14:06:38 <colo> lyxia: so what can i do?
14:06:45 <lyxia> colo: use nf
14:07:53 <colo> error:     * Ambiguous type variable `a0' arising from a use of `nf'
14:08:22 <lyxia> colo: in other situations, you might need to rewrite your own forcing function
14:08:32 <lyxia> colo: give a concrete type to z
14:09:04 <lyxia> It's having trouble guessing what type of number you want.
14:14:20 <zennist> I'm looking at the ghc user guide on the ffi section - has anyone used the 'initialisation and deinitialisation entry points' before?
14:15:07 <zennist> it says you could implement 'mylib_init' and 'mylib_end' that essentially calls hs_init / exit stuff; but this looks like magic to me - does these functions get automatically called when the library is loaded/unloaded?
14:15:47 <zennist> or it just means that the user should call these functions when using the library?
14:16:26 <colo> lyxia: now works, thanks
14:16:32 <geekosaur> zennist, you need to use the platform's implementation of shared object init/deinit
14:16:56 <geekosaur> which is why it doesn't go into detail, it's different for windows vs. linux vs. os x vs. solaris vs. whatever
14:16:57 <zennist> and this only applies to shared library..?
14:17:00 <geekosaur> yes
14:17:36 <zennist> ah then i suppose it's not too useful - as i think building shared library for haskell is quite difficult unless you've compiled base, etc. all in PIC format right?
14:17:48 <geekosaur> correct
14:18:01 <geekosaur> well, you can use those with static but yes you need to call the init and deinit explicitly
14:18:06 <zennist> unless i go ahead and recompile all these things.. which could be a pain..
14:18:25 <zennist> i see - it's clear to me now, thx
14:18:35 <geekosaur> there are no hooks to do it automatically because static linking is all done at link time, not when the library is attached to the running process
14:20:22 <zennist> geekosaur: i've just got an idea - since the init & end code is pretty much similar across ffi libs; can't i just write it once in one lib and then link other ffi libs with that lib?
14:20:34 <zennist> then user can always call the same function to init/deinit
14:22:00 <geekosaur> you could, but it might be better to just explicitly init and deinit once if possible
14:26:14 <colo> which is the best image visualization module that allows pixel manipulation?
14:29:29 <hsk3> How would you feel about namespacing wiht your name a haskell package (to avoid conflicts on hackage)?
14:29:47 <hsk3> such as Geekosaur.Text.Manipulations
14:30:05 <hsk3> and call the package geekosaur-text-manipulations
14:30:14 <byorgey> sls
14:30:30 <byorgey> whoops.
14:30:44 <srhb> hsk3: Many packages now prefix the Package name as the topmost module
14:31:07 <srhb> hsk3: Rather than trying for Data.* or Control.* or System.* or what have you.
14:32:24 <latro`a> is there a nice way to go from a "Map (k1,k2) a" to a "Map k1 (Map k2 a)"?
14:32:33 <LordBrain> if you put your own name on it, its less inviting to other developers tho
14:32:47 <Darwin226> Hey guys. Is there a way to go from (forall r. C r => IO r) to IO (forall r. C r => r). I know the second type isn't supported by GHC but maybe there's a way to work around it?
14:32:48 <LordBrain> i mean, that's okay i guess, if you intend that
14:33:10 <latro`a> (intuitively, this is like currying the "function" that takes a pair (k1,k2) and gives an a)
14:33:13 <Darwin226> I have a function that takes a (forall r. C r => r) as an argument and I want to fmap it over that IO
14:34:51 <LordBrain> so that you want a function that takes IO (C r) and gives IO r ?
14:35:13 <hsk3> LordBrain: but if not your own name, the question is then what
14:35:15 <Darwin226> C is a constraint in this case
14:36:18 <LordBrain> hsk3, well, you could use your own name, that could work out, but i guess i'm suggesting a brand name instead
14:36:55 <hsk3> all right
14:36:55 <hsk3> i see
14:37:08 <LordBrain> well, you know what, a synonym that avoids the collision would be better i think
14:37:15 <srhb> hsk3: Package name seems sensible. And I suppose LordBrain does have a point that some may consider it rather... Pompous? To use ones own name. :)
14:37:16 <LordBrain> what's the package?
14:37:44 <srhb> hsk3: The servant package simply uses Servant as the top module.
14:38:24 <LordBrain> well not really, it doesnt strike me personally as pompous or anything, but its like declaring an intent that you may not mean, as in, "this is my territory. forever. other devels respect." which may serve to turn away others who might otherwise be more willign to step up and take over should you need that. 
14:38:45 <LordBrain> On the other hand, people are reluctant to take over things anyway unless you specifically ask or something.
14:38:54 <LordBrain> that's my sense anyway
14:40:34 <lyxia> latro`a: can't think of anything particularly nice
14:40:57 <LordBrain> so, using some neutral word seems a slightly more open-source-spirited maneuver to me
14:41:25 <LordBrain> but, you know, i have no real way to determine if this is actually true, no studies have been conducted to my knowledge
14:43:07 <LordBrain> I guess ask yourself whether it would make any difference to you personally were you to come upon such a project?  I suspect that even if it does, there would be other factors which would weigh more heavily...
14:44:17 <hsk3> yeah..
14:44:18 <hsk3> good points
14:45:04 <hsk3> but i mean really, if I saw a killer, highly useful package on GitHub called LordBrain.Text.Awesome, I'd have no problem with it lol
14:45:18 <hsk3> if it does what i want it to do
14:46:25 <LordBrain> yeah
14:46:46 <LordBrain> i think that if the effect i mean is real, its slight relative to other factors
14:46:47 <MarLinn> If you're brave you could go the Java route: Com.Example.Haskell.Enterprise.Data.Awesome.StringMap
14:46:58 <LordBrain> hahahaha
14:47:02 <LordBrain> don't do that
14:47:06 <siwica> In type class definition it is oftentimes stated: "the instances of XYZ should satisfy the following laws: ...". In what way are these requirements checked by the type system?
14:47:07 <hsk3> lol
14:47:51 <hpc> siwica: they aren't
14:47:51 <lyxia> Darwin226: I don't think so. It's the same as trying to turn a -> IO b into IO (a -> b). The action may depend on the argument so you can't run it before getting one.
14:48:07 <hpc> siwica: generally because they can't
14:48:35 <hpc> siwica: there's some rare cases where an invariant like that can be guaranteed by the type system, and then it no longer needs to be specified
14:48:53 <hpc> siwica: for instance there used to be a Pointed class that was basically Applicative without (<*>)
14:49:04 <LordBrain> putting your name on somethign could have positive effects too
14:49:08 <hpc> siwica: but it turned out all the laws it had were free theorems, so it was impossible to violate them anyway
14:49:16 <LordBrain> as in, people think "okay this guy's pride is in this"
14:49:45 <Darwin226> lyxia: I guess it could do different IO based on what the type actually is, but seeing how the first version is what you "accidentally" get when writing normal polymorphic functions it seems limiting
14:49:56 <LordBrain> maybe there actually have been studies on this
14:50:06 <Darwin226> For example (readLn :: Read a => IO a)
14:50:13 <LordBrain> now that i think on it, the marketing types may have really researched a question such as this
14:50:22 <siwica> hpc: Are there approaches to check whether they are satisfied?
14:50:24 <Darwin226> it's the same IO no matter what `a` you're getting in the end
14:50:52 <Darwin226> but there's no way do things with that a without losing the polymorphism
14:50:58 <siwica> hpc: Or is it proven to be impossible in the general case?
14:51:41 <hpc> like, with some automated process?
14:51:47 <siwica> yes
14:52:10 <hpc> generally we just work them out by hand
14:52:48 <siwica> "we" refering to anyone who instanciates the type class?
14:53:10 <lyxia> Darwin226: actually readLn may or may not raise an exception depending on whether parsing succeeded.
14:53:38 <MarLinn> siwica: there are some packages that put considerable effort into checking the laws with QuickCheck. I think SubHask was one of them
14:54:02 <Darwin226> lyxia: Hmm, good point. But let's pretend readLn = read <$> getLine for the sake of the argument
14:54:31 <lyxia> yeah I agree that the way the type system works is technically limiting
14:54:37 <siwica> MarLinn: Does QuickCheck do actual proves or does it genrerate random test cases?
14:54:48 <siwica> *proofs
14:55:56 <LordBrain> Darwin226, consider whether you might be better served with a non-type class design... explicit dictionary instead... so the constraint is no longer there and instead you have a specific type which has methods as fields as a parameter to the function.
14:57:17 <jmcarthur> LordBrain: That doesn't help, afaik. Darwin226 would just be stuck with trying to write a function   (forall r. C r -> IO r) -> IO (forall r. C r -> r)
14:57:20 <LordBrain> so instead of C being a class, its a parameterized type
14:57:28 <Darwin226> LordBrain: I can't do that because the typeclass belongs to another package. I'm trying to interface with it
14:57:35 <LordBrain> okay
14:58:14 <jmcarthur> Darwin226: You can use ConstraintKinds to turn a type class into a more explicit dictionary kind of thing, but I still don't think it would help you.
14:58:25 <MarLinn> siwica: just random tests. And of course you only get so far, because in general it's impossible (I think) to add such a tool to the library that defines the typeclass because it doesn't know how it will be used
14:58:58 <ben> with Control.Conccurent.Chan.Chans, how do you signal to your readers that you're done sending values now and they can stop waiting?
14:59:02 <Darwin226> The library in question is postgresql-simple
14:59:23 <Darwin226> unfortunately it doesn't separate the querying part from the parsing part in it's API
14:59:27 <glguy> ben: You encode that in the values you're sending on the channel
14:59:40 <Darwin226> so I'm stuck with these polymophic IO actions
14:59:54 <ben> ok but if i send like a Done value, my first reader is gonna read that and exit and the other bunch of readers are still gonna wait
14:59:56 <glguy> ben: e.g. data ChanMessage = LastMessage | NextMessage Message
15:00:16 <lyxia> Darwin226: if you wanna write impredicative types, you can approximate them with a data wrapper.
15:00:23 <glguy> ben: the reader could put the Done message back on the chan for the next reader
15:00:31 <ben> but it's a reader! :(
15:00:42 <ben> apparently the C.C.STM.TBMChans have a close function
15:00:59 <Darwin226> lyxia: Well now that I've thought about the readLn example I don't think there's anything I can do here, type wise
15:01:08 <ben> does everybody just use STM?
15:01:21 <Darwin226> since for all I know, the IO in this case DOES somehow depend on the returned value
15:02:26 <LordBrain> you need I without the O heh
15:02:59 <hsk3> LordBrain: found some good discussions about it: https://www.reddit.com/r/haskell/comments/2ggopt/whats_the_right_way_to_name_packages_and_modules/
15:05:23 <martinr_> I'm doing a few of the euler project challenges to learn Haskell
15:05:30 <martinr_> Going pretty well actually
15:05:55 <hsk3> martinr_: nice
15:06:59 <LordBrain> hsk3, yeah they make some good points there
15:07:18 <LordBrain> what's the package do, perhaps you can make use of a synonym or something
15:07:31 <lyxia> Darwin226: maybe if for some reason you know that the IO does not depend on the chosen type/value, you might try to define data AllC = AllC (forall a. C a => a), hope you're lucky enough to implement C AllC (or maybe leave the methods undefined).
15:08:05 <lyxia> Darwin226: and specialize your action at this AllC type to move the arrow inside
15:10:05 <Darwin226> lyxia: That's genius! Let's see if it will work
15:11:54 <Darwin226> `GHC doesn't yet support impredicative polymorphism`
15:12:11 <lyxia> oh wait, you can't write that??
15:12:21 <LordBrain> hsk3, there is keera-hails, that has a company name in the package name, but actually it wasnt his first choice, there was a collision
15:12:29 <Darwin226> lyxia: I can't write the instance
15:12:50 <joe9> I have a function: http://bpaste.net/show/e6056efd4264 . Is there a better way of writing this as I have another 2 more objects to add to this function.
15:13:03 <Darwin226> lyxia: http://lpaste.net/3864753732063330304
15:13:23 <Darwin226> fromRow :: FromRow a => RowParser a
15:13:39 * hackagebot eventstore 0.13.1.4 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.1.4 (YorickLaupa)
15:13:41 * hackagebot pipes-aeson 0.4.1.7 - Encode and decode JSON streams using Aeson and Pipes.  https://hackage.haskell.org/package/pipes-aeson-0.4.1.7 (RenzoCarbonara)
15:13:43 * hackagebot cql 3.1.1 - Cassandra CQL binary protocol.  https://hackage.haskell.org/package/cql-3.1.1 (ToralfWittner)
15:13:45 * hackagebot xlsx 0.3.0 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.3.0 (KirillZaborsky)
15:13:46 <joe9> it seems to be a foldM
15:13:47 * hackagebot swagger 0.3.0 - Implementation of swagger data model  https://hackage.haskell.org/package/swagger-0.3.0 (ToralfWittner)
15:13:59 <Darwin226> Though I guess we have the same problem here, just with RowParser instead of IO haha
15:14:42 <lpaste> glguy pasted “for joe9 - without ContT” at http://lpaste.net/202405
15:15:50 <LordBrain> joe9, i think you can make a combinator
15:16:26 <LordBrain> put it as a local function in the where clause 
15:16:43 <glguy> Yeah, those all seem to follow the same pattern
15:17:10 <lyxia> Darwin226: I think this will need more work actually. Thinking of A -> IO B, if it doesn't depend on A, it may still apply a pure function to it to return B at the end, so you better put a proper value at some point.
15:17:55 <lyxia> this involves inspecting B (to try to reconstruct it with a proper A) or using mfix or both.
15:18:49 * hackagebot wrecker 0.1.0.0 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-0.1.0.0 (JonathanFischoff)
15:18:51 * hackagebot wrecker 0.1.0.1 - A HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-0.1.0.1 (JonathanFischoff)
15:18:57 <Darwin226> I'm still hoping there's a simpler way to do this.
15:20:42 <Darwin226> ahh... the parser type also has IO in it's definition for some reason...
15:21:10 <joe9> glguy: the paste seems to be a reformatting of the pasted code. Are you suggesting checking out ContT?
15:21:33 <glguy> joe9: I'm saying that formatting it that way solves the problem of nesting
15:22:12 <lpaste> glguy annotated “for joe9 - without ContT” with “for joe9 - with ContT (annotation)” at http://lpaste.net/202405#a202428
15:22:49 <glguy> just making a single combinator for that pattern of functions with and something that uses the with is an option, ContT handles this style as seen in the second paset
15:24:50 <joe9> glguy: That is cool. I will need some time to get my head around it though. Thanks a lot.
15:26:12 <bollu> let's say I choose to encode a language as a free monad
15:26:23 <bollu> let L = Free(f) where f is the functor that generates the free monad
15:26:36 <bollu> now, if someone has the cofree comonad that's the interprter for this language
15:26:43 <bollu> can they reconstruct the language?
15:26:55 <bollu> As in, I understand that there is a canonical pairing between a cofree comonad and a free monad
15:27:08 <bollu> but, like, given the cofree comonad, can you construct the language back? or is it one-way?
15:27:26 <bollu> (I don't understand the correspondence very well, just know that it exists)
15:28:21 <glguy> joe9: The cool part about the ContT solution is that you can use it with the normal generic Monad operations. Example: do [v1,v2,v3] <- replicateM 3 (contT2 withVertexArray)
15:30:28 <glguy> joe9: live example of that https://github.com/glguy/irc-core/blob/v2/src/Client/CApi.hs#L146-L158
15:30:45 <joe9> glguy: the Cont monad is hard to understand. still struggling with it.
15:30:55 <glguy> marshaling stuff into temporary allocations for the FFI
15:33:53 <ydl> is there an idiomatic way to make pure computations that always return the same result but use a global variable as a workspace (to make computations performant i don't want to reinitialize the workspace)? in particular i have c functions that re-use a workspace (where previous entries in the workspace are useful to future computations) but are guaranteed to return the same result every time (they just might need to do some work to
15:33:53 <ydl> extend the workspace to the right length)
15:34:43 <LordBrain> ydl, access the global within the ST monad
15:35:31 <ydl> but can i save the global? or do i now have to do my whole computation in the ST monad? the latter is irritating since the function is conceptually pure
15:36:48 <ydl> furthermore, even if this is possible, is it enough to hide the global behind a module to protect users/the compiler?
15:36:51 <LordBrain> perhaps a memoization technique?
15:37:23 <Darwin226> lyxia: I decided to go with an ugly solution that works. I send a proxy (also wrapped in an existential) of the target type I want and force the query to return that type as the result. Then wrap that result in an existential.
15:37:32 <joe9> glguy: I like the "without ContT " version. It is a smart way of using $ and the function is still easy to understand.
15:37:37 <Darwin226> This gives me a function that's monomorphic in both the input and the output
15:38:05 <LordBrain> i guess the truly idiomatic thing would be to make that global a parameter
15:38:06 <Darwin226> then in the function that actually knows the type it wants to get, I call this mono function with the appropriate proxy and I coerce the result to what I want
15:39:51 <ydl> LordBrain: if it was in-haskell, memoization would work. the issue is the variable being modified is in C.
15:41:14 <conal> shachaf: ping
15:41:33 <ydl> let me be specific. i have a c function "int f(int* workspace, int x);" that, given an x, is guaranteed to give me the same y every time. for efficiency, it uses a workspace that it might or might not extend or modify, but will definitely access. how should i bind this function in haskell?
15:42:39 <ydl> it is annoying to expose the user to the implementation details by forcing every use of "f" in haskell into the IO or ST (or even State) monads
15:42:42 <LordBrain> make the workspace an opaque type in haskell and have the function bind as pure..
15:43:55 <LordBrain> hmmm
15:44:01 <glguy> ydl: If it's actually pure and you don't particularly care if the computation is duplicated or shared you can import it without the result being in IO
15:44:09 <LordBrain> yeah
15:44:48 <LordBrain> i'd just hide it
15:45:37 <LordBrain> so in haskell it becomes f: Int -> Int
15:45:50 <LordBrain> or CInt -> CInt
15:45:59 <glguy> You'll still need to pass the workspace pointer somewhere
15:46:08 <LordBrain> not if its always the same
15:46:20 <LordBrain> as in, he's sharing the workspace across runs
15:46:43 <glguy> if it's always the same it doesn't need to be a parameter? where do workspaces come from?
15:47:04 <glguy> Is it important that two threads not use the same workspace at the same time?
15:47:10 <ydl> glguy: yes
15:48:40 <ydl> glguy: if i were writing c code, i'd have, at the beginning of my single-threaded program "int *workspace = malloc(workspace_size); rest of program...". my case is actually a bit more complicated, instead of an array of ints it's a struct of arrays, but i think the idea is the same.
15:49:52 <glguy> If you need to make sure each workspace is only being used by one thread at a time that's a good reason reason to leave things in IO
15:52:58 <hpc> it's probably a necessary reason
15:53:16 <LordBrain> well, if its really nice to have it as pure, and worth the effort, i suppose he could have some kind of thread-safe container of workspaces in c
15:53:18 <hpc> you can probably make a toy program that evaluates an expression in a non-deterministic thread
15:53:38 <hpc> which if you used an expression involving one of those workspaces, would make it non-deterministically work or not work
15:53:44 <hpc> which violates purity
15:54:41 <ydl> it isn't too hard to make the c code thread safe. assuming i did that, then can i make the call pure by hiding things in modules (or otherwise?)
15:55:54 <jonored> hpc: Can you do locking in an unsafePerformIO? (Just curious whether the workspace pool sort of thing that this seems to require to satisfy pure requirements is possible to write haskell-side at all.)
15:57:17 <LordBrain> if i use unsafePerformIO, I feel i should be able to launch the nukes.
15:57:25 <LordBrain> :)
16:00:41 <LordBrain> he could have an TChan or something of workspaces inside an unsafePerformIO wrapper, and call the result pure.
16:00:53 <LordBrain> at least i dont see why not
16:02:08 <jonored> I'm a little iffy as to whether STM actually provides the sort of guarantees that C concurrent access needs, actually.
16:02:41 <jmcarthur> You can't use STM in unsafePerformIO
16:02:56 <jmcarthur> More specifically, you can't use atomically in unsafePerformIO
16:03:02 <LordBrain> oh thats true
16:03:12 <LordBrain> but there would be ways around it
16:03:19 <LordBrain> have some globals 
16:03:31 <jonored> I think this case would need an actual real lock, because the workspace is opaque.
16:05:03 <ydl> it is very easy to make the c code thread safe, i just did it :) so now i have a c function "int f (workspace* workspace, int x);" that uses workspace only internally, always returns the same value for a given x regardless of workspace contents, but might modify workspace freely. can i now make this function accessible as a pure function from Haskell?
16:06:20 <jmcarthur> I'd probably put the workspace in a global MVar. That should play well with unsafePerformIO.
16:06:43 <jmcarthur> ydl: Is it thread safe?
16:07:29 <LordBrain> ydl, that seems okay to me
16:07:31 <ydl> it is indeed threadsafe. i'd be interested in learning how to make the unsafe case work, but for this particular problem that's not necessary
16:08:07 <LordBrain> i think there is president already actually for that
16:08:48 <jmcarthur> If it had not been possible to make it thread safe, my suggestion to put the workspace in an MVar should have worked.
16:09:30 <jmcarthur> Provided the C function is not able to call back into Haskell and cause a deadlock somehow.
16:10:27 <LordBrain> every c function is io really if you think about it, its modifying slots of memory, it has no pure view... but we have the capacity to bind c as pure anyway, as well we should.
16:12:47 <ydl> so just to be explicit i would use the first trick here: https://wiki.haskell.org/Top_level_mutable_state to make a global Workspace, then 'foreign import "f" c_f :: Ptr Workspace -> Int -> IO Int' and call c_f with the global workspace, wrap that in unsafePerformIO, and export that?
16:13:40 * hackagebot licensor 0.2.0 - A license compatibility helper  https://hackage.haskell.org/package/licensor-0.2.0 (jpvillaisaza)
16:16:22 <jmcarthur> ydl: Yes, except instead of a global IORef you'd make a global MVar
16:33:19 <juri_> so, if i'm using 'map from<type> . filter is<type>' $ <objects of various types in a data class>, how do i get ghc to stop complaining about my from<type> function not having instances for the othe objects in the data class?
16:33:55 <juri_> see: http://lpaste.net/201823
16:36:16 <capn_freako> Can a Functor instance be defined for a closure (i.e. - (+ 1))?
16:37:06 <c_wraith> capn_freako: instances belong to types, not values
16:37:12 <c_wraith> capn_freako: functions are values
16:37:28 <geekosaur> either I don't understand what you mean, or one already exists
16:37:28 <glguy> capn_freako: Do you mean can functions have a Functor instance?
16:37:51 <glguy> instance Functor ((->) r) -- already exists
16:38:37 <Cale> juri_: Use pattern matching, perhaps. [x | OObj2 x <- children]
16:40:12 <Cale> capn_freako: Also, closures aren't distinguishable from functions in any way -- they're (maybe) part of the implementation mechanism for functions.
16:40:41 <Zemyla> Man, writing fingertrees gets exceedingly messy.
16:40:51 <Cale> Or perhaps it would be better to say that it's just not a closure any more once you can no longer separate it into code and environment
16:41:12 <Cale> (and certainly, for functions, you can't do that)
16:42:51 <juri_> Cale: i'm sure that was helpful.. i just have no idea how. ;)
16:43:36 <Zemyla> I mean, have any of you written any kind of fingertree library?
16:44:13 <Zemyla> Because if you have, imagine doing so in such a way that the elements are of heterogenous type.
16:44:18 <Cale> haha
16:44:22 <Cale> What is this?
16:44:30 <Cale> DFingerTree? :)
16:45:00 <jonored> juri_: I expect that you /could/ put in some explicit undefineds in there to get ghc to shut up, but I would recommend merging the dereference and the cases.
16:45:16 <Zemyla> Cale: As a hint, here's the node type. data Node f a where { Node2 :: f a -> f b -> Node f (a, b); Node3 :: f a -> f b -> f c -> Node f (a, b, c) }
16:45:18 <Cale> juri_: Well, that list expression will give you the values of x for which OObj2 x is an element of the list 'children'
16:45:28 <Zemyla> It's 
16:45:47 <Zemyla> It's an Applicative fingertree.
16:45:50 <Cale> juri_: So it does the map and filter at the same time, sort of.
16:47:05 <Zemyla> The other kind of heterogenous fingertree I plan to write has a node of type data Node p a b where { Node2 :: p a b -> p b c -> Node p a c; Node3 :: p a b -> p b c -> p c d -> Node p a d }
16:47:29 <Zemyla> So one is a free applicative and the other is a free category.
16:49:38 <jonored> juri_: the list comprehension is basically concat . map (\a -> case a of (OObj2 a) -> [a]; otherwise -> []) $ children if that's helpful to see what's going on. The function ends up actually total because it's both making the decision and doing the operation is the key bit.
16:50:46 <juri_> that was closer to useful. ;)
16:51:09 <juri_> I'm still a beginning haskeller, as you can tell.
16:53:13 <jonored> juri_: list comprehensions are really quite nice, you should learn them if you haven't yet. And they're actually very similar to do notation in ways that I found somewhat helpful.
16:55:31 <juri_> reading about it now.
17:04:20 <juri_> ok, kindof getting it..
17:04:56 <soLucien> hi guys ! I'm trying to understand monads by reading a scientific paper. At some point it says
17:04:57 <soLucien> http://pasteboard.co/4L3HU6pv7.png
17:05:07 <soLucien> Shouldn't monads be called M ?
17:05:13 <soLucien> this guy is calling it I
17:05:44 <lispy> soLucien: perhaps that monad represents identity
17:05:52 <soLucien> This is from Philip Wadler - The Essence of Functional programming
17:05:59 <lispy> oh, it even says so :)
17:06:07 <jxv> It's the identity type which satisfies a monad
17:06:10 <soLucien> ok so if it's identity, it is supposed to be I instead of M ?
17:06:22 <lispy> I mean, a name is just a name
17:06:33 <soLucien> how many tricks and cases are there in haskell ?
17:06:34 <soLucien> :D
17:06:42 <LordBrain> soLucien, Monad is a class, it refers to a bunch of different types, each with their own names
17:06:49 <jxv> ^
17:07:25 <soLucien> ok , so the letter M is not necessary .. it's not part of HS synthax
17:07:33 <soLucien> it's just a way of calling the type ?
17:07:38 <LordBrain> most monads are not called M
17:07:41 <juri_> ok, i broke it... ;p
17:08:07 <LordBrain> we do use the lower case conventional type parameter... Monad m => m a  .. where m stands for an arbitrary instance of the Monad class
17:08:26 <LordBrain> even that is merely a convention, its not required, any lower case identifier would work
17:09:05 <soLucien> okay i understand .. so M/m/foo/Bar/panCake are all legal names
17:09:09 <soLucien> for declaring a monad
17:09:17 <LordBrain> there are 5 name spaces
17:09:25 <LordBrain> if i recall right
17:10:01 <LordBrain> there are requirements per a given name space, Types, DataConstructors, and Type classes must start with a capital letter
17:10:10 <LordBrain> also Module names
17:10:11 <clueless> could someone mind explaining why or why not this function calculates in linear time? http://lpaste.net/202590
17:10:22 <soLucien> so wait .. i can only call it M/I/m/i or 3 more ?
17:10:33 <LordBrain> hmmm read the report
17:10:59 <LordBrain> https://www.haskell.org/onlinereport/haskell2010/
17:11:12 <LordBrain> that will clarify some things 
17:11:42 <soLucien> LordBrain i've only been introduced to Haskell less than 2 weeks ago
17:11:54 <soLucien> i'm already at Monads , trying to wrap my head around them
17:12:15 <soLucien> so i think looking at the language spec wouldn't help too much in the stage I am at
17:12:16 <glguy> There is the type and the value namespace
17:12:20 <LordBrain> well, see section 1.4 there, its only 2 paragraphs
17:12:24 <soLucien> ok
17:12:31 <glguy> Type classes and type constructors are in the same namespace ,for example
17:14:45 <jle`> clueless: it should be roughly linear time
17:15:01 <jle`> if you replaced !! with a strict !! (or a strict zipWith4) then you'll get constant space too
17:15:25 <LordBrain> in practice our naming has been extended since we have type operators etc.. but the 2010 report is a good foundation
17:15:33 <jle`> clueless: the best way to see this for yourself, i feel, is to just manually evaluate what you want
17:15:50 <jle`> manually evaluate tetranacci !! 8 by hand, by looking at the definition of !!
17:15:54 <jle`> @src (!!)
17:15:54 <lambdabot> xs     !! n | n < 0 = undefined
17:15:54 <lambdabot> []     !! _         = undefined
17:15:54 <lambdabot> (x:_)  !! 0         = x
17:15:54 <lambdabot> (_:xs) !! n         = xs !! (n-1)
17:16:00 <jle`> and the definition of zipWith4 :)
17:24:48 <juri_> ok, i am confused again.
17:25:35 <Cale> What's up?
17:25:45 <juri_> i'm trying to "iterate" over a list, containing items in a data class, and return a tuple containing one type, another type, then the rest.
17:26:23 <juri_> i can't merge the two 'fromOObj' functions, because they have different return types..
17:28:08 <shachaf> conal: hi
17:28:12 <drninjabatman> hello
17:28:17 <Cale> juri_: sure...
17:28:39 <Cale> (btw, "data class" seems a bit misleading, you don't have a class)
17:28:40 <conal> shachaf: hi. i got your question: "For computing [x^i | i <- [0..n]] (which you used for DFT), can you do better than O(n) work and O(log n) depth using repeated squaring?"
17:28:47 <juri_> I'm just lost, i guess.
17:28:55 <juri_> sure.
17:29:22 <juri_> i have a datatype with 19 initialization functions..
17:29:26 <conal> shachaf: i think the O(n)/O(log n) method does use repeated squaring. I don't know whether it's possible to do better.
17:29:36 <Cale> data constructors, I think :)
17:30:08 <conal> shachaf: coincidentally, i found use for another kind of squaring: functor squaring. seems to make for a more efficient FFT than the classic algorithms.
17:30:23 <conal> shachaf: just added to https://github.com/conal/talk-2016-generic-fft 
17:30:33 <juri_> and i want to create a tuple containing members that used one initializer in a list in the first slot, a different initializer in the second, and the remainder in the last.
17:30:45 <drninjabatman> I have a question: In https://github.com/snoyberg/conduit#unified-data-type we set the sink output to be Void but the source input to be Unit. Why this asymmetry?
17:31:54 <shachaf> conal: You can't do better with a scan when all the input values are equal?
17:32:00 <shachaf> That seems a bit surprising.
17:32:36 <Cale> drninjabatman: In this case, I'm not sure exactly.
17:33:11 <conal> shachaf: some optimization of that kind is already happening. when scan is given all equal values, even top-down scan drops from O (n log n) to O (n) work, thanks to CSE.
17:33:37 <conal> shachaf: was a very pleasant surprise when i saw my compiler make that improvement.
17:33:44 <Cale> drninjabatman: Normally, you'd use Void as a result type if you wanted to indicate that some operation wasn't intended to finish.
17:34:06 <drninjabatman> Cale: thnx!
17:34:08 <Cale> drninjabatman: I suppose that's *sort of* what's going on here
17:34:31 <juri_> so, is this a tuple of three list complehensions?
17:34:38 <grantwu> I have a String and I need a lazy Bytestring
17:34:56 <grantwu> Hoogle gives me Data.ByteString.Char8.pack, but that doesn't seem to be what I want
17:34:56 <Cale> juri_: It very well could be
17:35:01 <glguy> grantwu: You'll need to pick an encoding
17:35:05 <grantwu> Couldn't match expected type ‘BS.ByteString’
17:35:08 <grantwu>               with actual type ‘Data.ByteString.Internal.ByteString’
17:35:16 <shachaf> conal: I see. So reusing values in the way repeated squaring does is what makes the scan work in the first place.
17:35:23 <grantwu> glguy: Uh, UTF-8 is fine.  Really, it's all ASCII.
17:35:34 <glguy> grantwu: Data.ByteString.Char8 doesn't do UTF-8
17:35:51 <conal> shachaf: see https://github.com/conal/talk-2015-haskell-to-hardware, slides 58-60. and use in 61,62.
17:35:51 <glguy> also there are two different modules: Data.ByteString.Char8 and Data.ByteString.Lazy.Char8
17:36:04 <jle`> btw Data.ByteString.Char8 is almost always the wrong module for what you want
17:36:14 <Cale> juri_: You won't be able to do the matching trickery with the third list comprehension
17:36:15 <jle`> it should be marked unsafe/deprecated
17:36:16 <mmaruseacph2> a/win 4
17:36:22 <mmaruseacph2> bad window, sorry
17:36:30 <Cale> juri_: But you *could* use the concatMap version
17:36:41 <conal> shachaf: kind of, though it isn't squaring in the general (non-uniform) case.
17:37:08 <shachaf> Right.
17:37:15 <conal> shachaf: more like, the efficient scan algorithms turn out to do squaring when specialized to uniform/constant data structures.
17:37:16 <Cale> concatMap (\x -> case x of OObj2 _ -> []; OObj3 _ -> []; x -> [x])
17:37:30 <jle`> grantwu: the best way would be to use 'pack' from the text package, in Data.Text
17:37:46 <jle`> grantwu: and then use something from Data.Text.Encoding, like encodeUtf8
17:38:06 <juri_> oh wow, that's consise.
17:38:07 <conal> shachaf: an even simpler example would be a fold over a pure/constant structure. i'll cook up some examples.
17:38:16 <conal> shachaf: hadn't occurred to me before.
17:38:29 <jle`> grantwu: so (T.encodeUtf8 . T.pack :: String -> ByteString)
17:38:38 <shachaf> conal: That's what you do in the original DFT code, right?
17:38:48 <shachaf> conal: powers = fst . lscanAla Product . pure
17:38:55 <conal> shachaf: yes.
17:39:04 <grantwu> jle`: At this point... I just picked Data.Bytestring.Lazy.Char8
17:39:11 <grantwu> Technically I can assume ASCII
17:39:13 <shachaf> conal: Actually, now I'm wondering how the O(log log n) depth solution using square root can work.
17:39:20 <jle`> grantwu: replace with Data.Text.Lazy and Data.Text.Lazy.Encoding if you want lazy byestrings :)
17:39:34 <jle`> grantwu: i'd be careful with that
17:39:37 <conal> shachaf: i no longer believe it can.
17:39:38 <shachaf> conal: Don't you need at least O(log n) depth just for computing the last value of the scan?
17:39:41 <juri_> Cale: thank you kindly. I'm trying to understand my way through this, really.. ;)
17:39:56 <shachaf> OK.
17:40:07 <conal> shachaf: the fold -- yes, i think so.
17:40:16 <juri_> I'd come up to '[ x | x <- children, isOObj3 x ],', but i'm not sure where to unwrap...
17:40:18 <grantwu> jle`: With what?
17:40:30 <jle`> with any of the *.Char8 modules in bytestring
17:40:42 <Cale> concatMap takes the given function and applies it to each element of the list. Each time the function is applied, it produces a list of elements, and these are concatenated together.
17:40:42 <shachaf> Ah, right, that's what the last value of the scan is called. :-)
17:41:17 <Cale> juri_: You can just do what I showed in my first list comprehension: [ x | OObj3 x <- children ]
17:41:26 <jle`> (T.encodeUtf8 . T.pack) isn't much more complicated, and it's also robust and safe :)
17:41:36 <jle`>  *.Char8 will only bring you headaches down the line, inevitably
17:41:37 <conal> shachaf: the bush type makes for interesting scans also.
17:41:40 <juri_> ok, that makes sense.
17:41:53 <Cale> juri_: Only the elements which match the pattern will be selected, and x will refer to the argument of OObj3
17:42:16 <jle`> i'm honestly not sure why that module still exists except for legacy reasons
17:42:37 <conal> shachaf: where a bush size (# elements) is doubly exponential.
17:42:39 <Cale> juri_: So you don't need separate functions to serve as a conditional and to extract the value.
17:43:15 <grantwu> jle`: I did what you said, but out of curiosity, does Char8 work if all text is ASCII?
17:43:49 <LordBrain> Char8 isnt so bad
17:43:51 <grantwu> I don't necessary agree with this part of the homework spec, but this is for a school assignment where the input text must be ascii
17:44:24 <jle`> ah if it's for homework then it probably is ok
17:44:26 <Cale> grantwu: Yeah, it should work
17:44:34 <jle`> i just wouldn't use it in production
17:44:45 <jle`> it's an easy way to let bugs sneak in in larger projects
17:44:48 <grantwu> Good to learn good habits, though
17:45:02 <grantwu> Plus it's like a 3 month long homework assignment so I can't exactly ignore technical debt :/
17:45:47 <Cale> There are occasionally cases where you're picking through or generating mostly-binary data and you want some bit of ASCII text, and for that Data.ByteString.Char8 can be fine.
17:46:11 <LordBrain> you should probably use the packages your professor likes
17:46:15 <shachaf> conal: Ah, the Bush numbers actually improve on the RPow/LPow numbers. Interesting.
17:46:23 <Cale> But *in general* it's no harder to use Data.Text and that will get you unicode support
17:46:37 <Cale> So, it's usually just better if you're working with text
17:46:48 <grantwu> LordBrain: Professor doesn't have any preferences
17:47:03 <jle`> i guess the general rule applies -- use 'text' when you're working with text, use 'bytestrings' when you're working with binary/bits
17:47:27 <LordBrain> well, okay, if you have reasons tho, you can probably get away with anything, like if you have a justification for your choices
17:47:39 <conal> shachaf: indeed. and they work nicely in a scan as well.
17:47:48 <juri_> ok, that concatmap didn't typecheck..
17:48:00 <grantwu> jle`: Hrm.  That's the general advice I've heard - but is there any way of getting Text to store things in UTF8 internally?
17:48:04 <juri_> but i'm trying the comprehensions...
17:48:19 <jle`> grantwu: that's sort of the point of 'text' -- to abstract away the internal representation
17:48:34 <jle`> Text is an abstract data type that is encoding-agnostic
17:48:36 <juri_> which looks right to  me, and typechecks.
17:48:56 <LordBrain> Text works good for text, if this is only text you are working with an not general binary, but there might be reasons to choose ByteString, in fact, if you want to reduce dependencies, you're more likely to get away with doing only bytestring than doing only text.
17:49:22 <grantwu> jle`: Okay, but if you eventually need to get utf-8 out, and Text uses utf-16 internally, it's inefficient, right
17:49:24 <LordBrain> that's just my take
17:50:01 <koz_> Could someone explain the difference (semantically) between 'ContT (ListT Identity)' and 'ListT (ContT Identity)'?
17:50:08 <LordBrain> you probably wouldn't want to use text to marshal asn1 objects
17:50:21 <conal> shachaf: less work than top-down and less depth than bottom-up
17:50:46 <jle`> grantwu: i'd expect text's implementation to be reasonable, and figure out if conversion is a bottleneck through benchmarking/profiling afterwards :)
17:51:12 <shachaf> conal: Interesting.
17:51:25 <juri_> cale: those comprehensions let me get rid of the functions that were breaking me.
17:51:39 <conal> shachaf: yeah. i don't know why.
17:51:53 <juri_> I'll keep looking at concatMap.
17:51:57 <juri_> thanks again!
17:52:01 <LordBrain> knowing how to do unicode with bytestring is probably a necessary thing anyway
17:52:09 <shachaf> conal: I would have thought the regular tree was already "balanced".
17:52:18 <shachaf> conal: I should probably look at the actual shapes and compare them.
17:52:34 <LordBrain> and better to make mistakes in your homework than on real life projects, so i would go with bytestring
17:53:07 <conal> shachaf: yes, both bottom-up and top-down tree types i used are balanced at data structures, but not as functor compositions.
17:53:21 <LordBrain> so you learn to deal with doing conversions, and keeping track of encoding manually
17:53:26 <shachaf> conal: Right.
17:53:40 <conal> shachaf: they're like cons lists and snoc lists w.r.t functor composition, while bushes are balanced functor composition trees.
17:54:05 <shachaf> Yes.
17:54:09 <LordBrain> just make sure to throw some weird characters in your strings, while testing
17:54:47 <conal> i don't have theory or intuition about how balancing functor composition impacts parallelism.
17:59:49 <siwica> When having a chain of operators like `foo = (++) <$> getLine <*> getLine` is it always `(foo = (++) <$> getLine) <*> getLine` or would I have to look up operator precedence somewhere? Is so, where?
18:00:37 <conal> shachaf: i just clarified the wording, changing "balanced" to "composition-balanced". thanks for the remark.
18:01:09 <shachaf> conal: I know that's the type of balance you meant. I was just surprised that it helped.
18:01:21 <conal> shachaf: ah, okay.
18:02:08 <LordBrain> the precedence should be at the defitionions of <$> and <*> in Control.Applicative
18:02:19 <LordBrain> it doesnt change per different applicative instances
18:02:22 <jle`> siwica: you can check it out on ghci, too
18:02:35 <jle`>  :i (<$>) will tell you the precedence
18:02:38 <conal> shachaf: maybe also interesting: i could use the original Bush type (plus depth-indexing) with scan, but not FFT, since it uses functor product. which gets to a question you asked at my talk.
18:02:53 <jle`> and yeah, they're also in the haddocks, too
18:02:56 <conal> shachaf: (since the original Bush uses functor product, that is)
18:03:35 <jle`> siwica: btw, that's ((++) <$> getLine) <*> getLine ... slightly different than how you had it before
18:03:37 <siwica> jle`: Ok, perfect!
18:04:13 <siwica> jle`: yeah, it was just a typo though
18:04:31 <jle`> in this case both <$> and <*> are infixl 4, so they associate at the same precedence, and from left-to-right
18:05:21 <jle`> some operators, like (:), are infixr ... so 1 : 2 : [3,4] is 1 : (2 : [3,4])
18:05:40 <siwica> jle`: Since I am new to haskell I assume there is infixr too, if there is infixl?
18:05:51 <LordBrain> does lambdabot do :i ?
18:05:57 <siwica> jle`: ah, slower :)
18:06:09 <jle`> LordBrain: it's not clear what :i for lambdabot would be
18:06:16 <athan> Hi everyone, does anyone here know of a `hGetAsMuchAsYouCan :: Handle -> IO String`?
18:06:22 <athan> without closing the handle I mean?
18:06:37 <siwica> so r = right associative?
18:06:38 <athan> I'm trying to write an interactive wrapper around a CLI program, which polls for a password :\
18:07:07 <jle`> siwica: mhm, 1:2:3:4:[] is 1:(2:(3:(4:[])))
18:07:27 <siwica> jle`: ok, makes sense!
18:07:35 <lingxiao> hey all im parsing some stuff using conduit and Im getting this error: 
18:07:40 <lingxiao> Data.Conduit.Text.decode: Error decoding stream of UTF-8 bytes. Error encountered in stream at offset 112070655. Encountered at byte sequence "\194, B"
18:07:40 <jle`> and the "number" is how tightly they bind, with a higher number taking precedence over a smaller one
18:07:43 <geekosaur> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/System-IO.html#v:hGetBufSome https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/System-IO.html#v:hGetBufNonBlocking
18:07:50 <siwica> jle`: anything to worry about when mixing right and left associative operators?
18:08:21 <LordBrain> mixing is fine, higher precedence still get grouped first
18:08:31 <jle`> siwica: haskell will complain if you mix them if they are the same precedence
18:08:55 <lingxiao> this is frasustrating becuase for the conduit open file part i basically used:
18:09:00 <jle`> you can only mix them if one has different precedence than the other :)
18:09:00 <lingxiao> sourceFile $= decode utf8
18:09:01 <athan> you're awesome geekosaur!!
18:09:11 <lingxiao> and i thought this would fix the isssue
18:09:25 <geekosaur> lingxiao, that is Â
18:09:33 <lingxiao> ok?
18:09:34 <siwica> jle`: ok, makes sense. Thanks for the lesson :)
18:09:34 <jle`> siwica: see https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2 for more details
18:09:38 <geekosaur> either your input is not UTF8 but Latin1, or it is doubly encoded
18:09:48 <lingxiao> it's google ngrams
18:09:50 <lingxiao> so w/e that is
18:10:07 <jle`> and https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003
18:10:11 <LordBrain> if you're on windows i think you have to jump through some hoops to get it to be utf8
18:10:13 <lingxiao> so suppose it's utf 8, then it'll be all good right?
18:10:19 <lingxiao> im on a mac
18:10:29 <geekosaur> no, it is not valid utd8, that is why you have the error
18:10:51 <geekosaur> Â is what it would be if it is iso8859-1 instead of utf8
18:10:53 <LordBrain> oh, i'm thinking terminal, not a file
18:11:03 <lingxiao> ok so how should i decode it?
18:11:16 <lingxiao> so suppose some ngram file is opened as a bytestring ..
18:11:20 <jle`> oh TIL that you can specify the fixity of multiple operators at the same time
18:11:22 <jle`> thank you haskell report
18:11:25 <LordBrain> do you have control over the encoding of input files?
18:11:44 <LordBrain> if so, i would re-encode the input as utf-8 and make that a documented requirement
18:11:45 <lingxiao> i dont know ..
18:11:47 <lingxiao> wht does it mean? 
18:11:48 <lingxiao> LordBrain
18:12:08 <lingxiao> oh yeah no i have no control over that
18:12:13 <lingxiao> i get what i get basically
18:12:31 <LordBrain> okay then, youll need to detect its encoding and deal
18:12:34 <geekosaur> oh how "handy". they provide 3 urls claiming to describe the data format. 2 are dead
18:12:44 <siwica> jle`: Is it considered good style to entirely rely on operator precedence or is extensive use of parentheses encouraged in haskell?
18:12:58 <lingxiao> how do i detect its encoding?
18:13:35 <jle`> usually it's best to avoid expressions with lots of different operators in general
18:13:55 <LordBrain> lingxiao, well, if there is a bom, then that tells you, if there isn't there are algorithms and i'd be surpised if nothign is implemented on hackage
18:14:25 <lingxiao> sorry what's bom?
18:14:38 <LordBrain> https://hackage.haskell.org/package/charsetdetect-1.0/docs/Codec-Text-Detect.html
18:15:03 <LordBrain> bom is some special hidden characters at the beginning of the text stream
18:15:06 <geekosaur> byte order mark
18:15:09 <LordBrain> yeah
18:15:32 <LordBrain> use the detectEncoding function tho, from the link i just posted
18:15:34 <jle`> there are also common operators that are often used together (like <$> and <*>) in base and also in library-specific styles, so you might not need parens for that
18:15:34 <geekosaur> and, to be honest, you probably are at the mercy of the original text's encoding. there is no 100% way to detect that, and google probably didn't even try
18:15:44 <jle`> but otherwise redundant parentheses aren't too bad if they help readability
18:15:59 <LordBrain> detectEncoding likely already checks for the BOM
18:16:04 <geekosaur> (for example you cannot reliably dfistinguish between any of the iso8859 encodings without actual comprehension of the encoded text)
18:16:08 <geekosaur> and possibly not then
18:16:15 <jle`> but yeah, using a lot of different operators in the same expression will be confusing no matter how many parentheses you use
18:16:25 <LordBrain> and does the best it can in the case there is none
18:16:38 <siwica> jle`: Ok, I see. Thank you!
18:22:13 <jle`> np!
18:24:32 <Zemyla> geekosaur: Do the URLs work in archive.org?
18:25:59 <geekosaur> that was a *grump* not a "halp!"
18:27:56 <geekosaur> I mean, if google's not even keeping their references up to date, what should I expect of the data?
18:32:34 <haskell893> clear
18:33:16 <koz_> Could someone explain the difference (semantically) between 'ContT (ListT Identity)' and 'ListT (ContT Identity)'?
19:08:06 <orion> With Data.Vector, if I do V.fromList [ f x | x <- xs ] where 'length xs' is massive, will the construction of the Vector be "streamed", and thus done efficiently?
19:10:27 <dfeuer> orion, I don't know, but that very likely depends on the context.
19:10:51 <grantwu> orion: Consider generate instead?
19:11:30 <dfeuer> With generate, it will also depend on the context.
19:11:57 <dfeuer> But generate will probably be better where it applies nicely.
19:12:26 <orion> generate is annoying to me because the indices don't map directly to function inputs.
19:13:28 <grantwu> You could try iterate and put your f in a lamda that manually unconses
19:13:39 <grantwu> wait no
19:13:44 * hackagebot inspector-wrecker 0.1.0.0 - Create benchmarks from the HAR files  https://hackage.haskell.org/package/inspector-wrecker-0.1.0.0 (JonathanFischoff)
19:13:46 * hackagebot xlsx-tabular 0.1.0.2 - Xlsx table decode utility  https://hackage.haskell.org/package/xlsx-tabular-0.1.0.2 (KazuoKoga)
19:16:16 <dfeuer> orion, how are you using the vector?
19:16:23 <dfeuer> (once you've built it)
19:16:39 <dfeuer> That is probably more important.
19:16:51 <orion> I'm converting it to a CArray and passing it to Math.FFT
19:17:02 <dfeuer> Well then.
19:17:41 <dfeuer> What function are you using to convert it to a CArray?
19:17:47 <dfeuer> (link to Hackage please)
19:18:10 <orion> https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable.html#g:36
19:18:19 <orion> http://hackage.haskell.org/package/carray-0.1.6.5/docs/Data-Array-CArray.html#g:11
19:19:14 <dfeuer> orion, which functions in those modules?
19:19:50 <orion> let (ptr, len) = V.unsafeToForeignPtr0 rXY
19:19:55 <orion> sampleArray <- unsafeForeignPtrToCArray ptr (0, len)
19:20:34 <dfeuer> Ah...
19:21:11 <dfeuer> So the ultimate answer is: you have absolutely no hope of anything particularly streamy, and you also have no particular *need* for anything streamy.
19:21:35 <dfeuer> You're dumping a list into a vector.
19:22:06 <dfeuer> Which is then being (very nearly) just coerced into a foreign pointer.
19:23:00 <dfeuer> The only optimization you could wish for, orion, is *list* fusion, to prevent the list from ever being allocated.
19:23:40 <dfeuer> But that's only a little short-lived garbage anyway.
19:24:26 <grantwu> actually, hrm, generate would be bad, right
19:24:37 <grantwu> Because you have O(n) list access every time
19:24:45 <dfeuer> I don't know if fromList will fuse that out (I doubt it, but I'm not sure). Your other option is to use `foldr` or `foldM` or something to do the job "by hand"; I doubt you'll gain much.
19:25:43 <dfeuer> If anything. You've still gotta deal with the array doubling mess.
19:26:09 <dfeuer> Unless you know how long the list is, in which case I think vector has a special conversion for you.
19:26:30 <dfeuer> In any case, I don't think trying to do anything fancy is likely to gain you more than a pittance.
19:27:25 <orion> Ok, thank you.
19:27:36 <dfeuer> The most would be if you used an explicit fold *and* you knew the length in advance *and* your list were being produced by a "good producer".
19:28:16 <dfeuer> orion, if you do know the length in advance, using the special fromList variant for that *will* be a substantial win.
19:28:31 <dfeuer> That's the only real big potential one I see.
19:28:45 <dfeuer> Sorry I'm rambling.
19:29:50 <dmd_> anyone there
19:30:05 <dfeuer> No, dmd_ all 1431 of us are afk.
19:30:16 <dmd_> sorry was testing
19:30:28 <dmd_> can anyone shed some light as to why this wont run
19:30:51 <dfeuer> If you use capital letters, apostrophes, and punctuation, we'll try.
19:30:59 * dfeuer is in a bit of an ornery mood.
19:31:22 <athan> It's not easy trying to read the current prompt of a stdout handle, is it?
19:31:36 <athan> not of the current process, but one you "own" handles to
19:31:36 <dfeuer> athan, what is a current prompt?
19:31:52 <athan> dfeuer: hGetLine but without a \n at the ned
19:31:54 <athan> end*
19:32:11 <athan> so for instance `Prelude> ` in a ghci session
19:32:32 <athan> trying to read that last line of its stdout, but without a trailing \n
19:32:38 <dmd_> [(-1)^(x+1)/x | x <- [1..10]] says type variable is ambiguous
19:33:38 <dfeuer> athan, I would be surprised if many/any terminal emulators supported that. I would be more surprised still if there were Haskell bindings for such. And I'd be shocked if there were any non-terminal-specific way to do such a thing.
19:34:07 <athan> dang :\ thanks dfeuer!
19:34:36 <dfeuer> dmd_, the basic problem there is that you're using (^), whose exponent must be Integral, and (/), whose arguments must be Fractional, with the same type.
19:35:15 <dmd_> is there any type that supports both Integral and Fractional, I'm not understanding
19:35:42 <dmd_> perhaps my concept of type declaration is wrong, I'm only just studying Haskell seriously for University
19:35:56 <dfeuer> dmd_, for more sensible arithmetic, Haskell would default to either Integer or Double, but in this case it throws up its hands. There is no sensible type that is both Integral and Fractional, as far as I know. Certainly no standard one. You've made a mistake. Let me see if I can figure out how you should fix it.
19:36:18 <Koterpillar> **
19:36:33 <Koterpillar> use it instead of ^
19:36:36 <Koterpillar> dmd_: 
19:36:38 <dmd_> ** works as well? very nice
19:36:57 <Koterpillar> :t (^)
19:36:59 <lambdabot> (Num a, Integral b) => a -> b -> a
19:37:02 <Koterpillar> :t (**)
19:37:04 <lambdabot> Floating a => a -> a -> a
19:37:12 <dfeuer> Koterpillar, I wouldn't necessarily go there with this question, actually....
19:38:02 <dmd_> so the underlying problem is that there is no default type that is Integer and Fractional at the same time, am I understanding correctly?
19:38:16 <dfeuer> There is no such type period.
19:40:22 <dmd_> and it is because n^m requires m to be Integer?
19:40:32 <dmd_> whereas n**m does not
19:40:39 <jmcarthur> dmd_: Your problem is that in (a^b), a can be any number type, but b must be integer-like; however, in (a/b), a and b must be fractional types.
19:40:58 <jle`> n ^ m is basically implemented as n * n * n * ... * n, m times
19:41:03 <jle`> so it needs to be some Integral
19:41:09 <jmcarthur> dmd_: So the constraint that b is both integral and fractional is too tight.
19:41:31 <jle`> ** uses the type's "native" power function
19:41:41 <dfeuer> dmd_, well, sort of, but numeric ranges [1..10] don't make much sense for fractional types.
19:41:44 <jmcarthur> dmd_: I would fix this by carefully converting to the appropriate type for the division.
19:41:50 <dfeuer> So you really should start with an Integral type and convert.
19:41:57 <dfeuer> Most likely Int.
19:42:09 <dmd_> how to I convert on-the-fly
19:42:10 <jmcarthur> dfeuer: But (sadly) [1..10] still appears to sort of work until you figure out why your results are sometimes crazy...
19:42:14 <dfeuer> Or maybe Integer.
19:42:42 <athan> dfeuer: So they _did_ get something wrong at least :)
19:42:47 <dfeuer> jmcarthur, yes, that is most unfortunate. Enum Double is coo-coo-nuts, as my friend Otgonbaatar Badan would say.
19:42:48 <athan> terminals aren't composable
19:42:58 <jle`> coconuts are just nuts, aren't they
19:42:59 <jmcarthur> > ([1..10] :: [Rational], [1..10] :: [Double])
19:43:02 <lambdabot>  ([1 % 1,2 % 1,3 % 1,4 % 1,5 % 1,6 % 1,7 % 1,8 % 1,9 % 1,10 % 1],[1.0,2.0,3.0...
19:43:05 <jmcarthur> meh
19:43:37 <jmcarthur> dmd_: I would like to direct your attention to the fromIntegral function.
19:43:40 <jmcarthur> :t fromIntegral
19:43:41 <lambdabot> (Num b, Integral a) => a -> b
19:44:03 <jmcarthur> dmd_: It's kind of scarily polymorphic, but it's a pretty good way to convert from integrals to other numeric types.
19:44:31 <jmcarthur> dmd_: There's also fromInteger, if you want to just constrain the input to being Integer
19:44:33 <jmcarthur> :t fromInteger
19:44:35 <lambdabot> Num a => Integer -> a
19:45:16 <dfeuer> jmcarthur, which you don't, unless you actually choose Integer as the Integral type here.
19:46:49 <jmcarthur> dfeuer: That was what I meant.
19:47:03 <jmcarthur> dfeuer: (It might prevent having to add a type annotation in this case)
19:52:31 <mac10688> What is the standard way to build GUI interfaces in haskell?
19:52:37 <dmd_> tyvm everyone who helped me
19:52:48 <dmd_> how do i quote people?
19:52:50 <mac10688> An FRP library or binding to c++ gui libraries
19:52:58 <dmd_> cite
19:57:03 <dfeuer> dmd_, uhh.... Do you need to?
19:57:50 <dmd_> no, just to thank you and the other guys
19:58:02 <dmd_> and to know if it is required late
19:58:03 <dmd_> r
19:58:04 <dfeuer> dmd_, if you want, my name is David Feuer. jmcarthur is Jake McArthur, I think.
19:58:27 <dfeuer> I dunno about jle`.
19:58:34 <dfeuer> Or Koterpillar.
19:58:55 <dmd_> ty David and Jake
19:58:59 <dmd_> very much
19:59:03 <jle`> i'm justin le i guess heh.  if you need to cite for academic purposes, you can use http://ircbrowse.net/day/haskell/today?mode=recent
20:00:00 <dfeuer> I think I knew that once, jle`. Sorry I forgot.
20:00:42 <jle`> no need to apologize haha. nobody remembers morpheus or neo's real names either
20:01:05 <dfeuer> They probably do.
20:02:46 <jmcarthur> Neo = Mr. Anderson
20:02:51 <jmcarthur> You can't forget that one.
20:03:17 <jmcarthur> But okay, I didn't remember his first name without looking it up.
20:05:03 <athan> How difficult is C ffi-ing?
20:05:15 <athan> on a scale from 1 to make it stop?
20:05:22 <monochrom> 1
20:05:39 * monochrom now exaggerates. 0.1.
20:05:58 <jmcarthur> I'm confused. 1 and make it stop are the same number.
20:05:59 <geekosaur> I'd say 3, and 2 of that is because of C and not because of Haskell
20:06:50 <athan> monochrom: Phew :)
20:06:54 <geekosaur> (you have an API, it has a char ** or worse void **, you get to figure out how it's using that to determine how to represent it to Haskell. but you;d have to figure that out even in C
20:06:56 <geekosaur> )
20:07:05 <monochrom> I use a relative scale. "0" means between C and C. Therefore "1" is for between Haskell and C.
20:07:34 <monochrom> Of course, this is not to say that between-C-and-C is trivial. No way.
20:07:36 <geekosaur> (because (thing *) can be an "out" thing, or an array of thing, or a random pointer to thing)
20:08:02 <athan> ahh hell :\ thanks geekosaur
20:08:13 <athan> I often see "cbits" folders for libs that ffi
20:08:22 <athan> are those usually there to help manage this?
20:08:28 <geekosaur> as I said, you;d need to know this to use it even from C
20:08:34 <athan> I'm going to do a heap of reading here soon :)
20:08:45 <jle`> jmcarthur: his first name is misterrrr
20:08:53 <geekosaur> this is one of the "joys" of C programming :/
20:08:55 <athan> yeah, I haven't touched C in a lifetime :\
20:08:58 <athan> heh
20:09:35 <jmcarthur> C programming is basically working with pointers. As the FFI just gives you pointers and a simple mechanism for calling C functions, using the Haskell FFI is roughly the same as writing C. There are some ways it is more complicated, but on the other hand, you also get to use some of the superior abstracting power of Haskell, so it balances out.
20:09:44 <monochrom> If bsearch says "void *" it's because it's trying to be parametric polymorphic with boxing :)
20:10:18 <jmcarthur> The most annoying thing to me is when C macros are involved, because you have to write a C wrapper for those.
20:10:42 <jmcarthur> The fact that sometimes having to write C is the most annoying thing seems pretty good though.
20:10:46 <athan> s_s joys :D
20:11:16 <mac10688> There doesn't seem to be any articles written about using purescript with haskell. Anyone know how hard or easy it would be?
20:11:16 <monochrom> yeah, that could be a problem with some linux kernal syscalls. "Eh, why is it saying that the function doesn't exist?"
20:11:57 <monochrom> fortunately GHC has a "capi" call convention for that.
20:12:18 <athan> mac10688: Purescript is very similar to haskell
20:12:31 <athan> but using alongside it would entail some kind of web service thing
20:12:39 <mac10688> yeah haskell as the webservice
20:12:39 <athan> purescript actually has a C++ backend now :)
20:12:49 <mac10688> what?!
20:12:59 <athan> yee dawg
20:13:13 <mac10688> oh lol that doesn't mean what I was thinking it means
20:13:23 <mac10688> I don't really know what that means to be honest lol
20:13:41 <mac10688> but I guess I can just add purescript and the html + css files to an assets folder
20:13:48 <mac10688> and just serve it to the client
20:14:02 <mac10688> I just want purescript to compile when I compile the project
20:18:15 <athan> welcome to strong typing :v
20:20:03 <athan> Hmm, okay here's a problem: what about a persistent process written in C - can I invoke it, yet... peek into the C process with one of its headers?
20:24:38 <dfeuer> athan, whaaaat? This does not sound like a good plan. This actually sounds like you're probably about to implement half of Common Lisp, so you should probably just use Common Lisp.
20:26:46 <athan> hah! thanks dfeuer!
20:27:36 <geekosaur> peeking inside a process is ... troublesome. if it has some kind of remote procedure call, use it.
20:28:04 <dfeuer> athan, there are probably actually several different language environments offering that sort of introspection. I think Common Lisp has one of the more-developed facilities for such, but I don't actually know Common Lisp.
20:28:16 <geekosaur> otherwise.. the interfaces you have available differ on windows vs. linux vs. os x, there are security considerations in all three
20:28:39 <geekosaur> (some language runtimes do offer rpc like that. C doesn't)
20:29:06 <Sonarpulse> is everything related to nix-style Cabal builds in cabal-install?
20:29:21 <geekosaur> ?
20:29:33 <geekosaur> new-build is still considered a tech demo
20:29:39 <Sonarpulse> or does parts of that effort impact Cabal too
20:30:18 <geekosaur> oh, misparse. I suspect it needs a newer Cabal but if you have cabal-install 1.24 or later it will have already pulled in the newer Cabal lib
20:30:58 <geekosaur> note that there's much more than just new-build going on in 1.24 and Cabal updates are likely to be relevant to more than just new-build
20:31:14 <geekosaur> (like, support for ghc8 meant changing the way package ids work, iirc)
20:31:17 <Sonarpulse> well specifically I am writing a very big email about how nixpkgs ought to leverage this stuff
20:31:45 <Sonarpulse> and I am unclear weather that means abandoning our sticking to Cabal only and avoiding cabal-install
20:32:38 <Sonarpulse> geekosaur: that's the other thing, I thought cabal new-build in part needed the new ghc pkgid thing, but I guess not as it claims to work on 7.x or later?
20:33:22 <geekosaur> you might do better asking about this in #hackage. as I said, it's a tech demo currently; I could not tell you how complete its nix integration (!) is but suspect you will want to wait for a newer release to start using it
20:33:43 <geekosaur> ...and at that point you might well want to switch to it, because it should be much easier for nixpkgs
20:33:47 <Sonarpulse> oh is #hackage actually inhabited unlike #haskell-cabal ?
20:33:55 <geekosaur> yes
20:33:58 <Sonarpulse> sweet
20:34:01 <Sonarpulse> I'll go there thanks
20:34:10 <geekosaur> I didn't even know #haskell-cabal was a thing
20:34:40 <geekosaur> discussion seems to be split between that channel and #ghc, depending on how closely related the issue is to ghc itself
20:34:56 <Sonarpulse> heh makes sense
20:35:01 <Sonarpulse> well thanks geekosaur 
20:35:25 <Sonarpulse> I suspect this might be the wrong timezone for most people there, but I'll give it a shot
20:35:49 <geekosaur> a bit late for the us ones, a bit early for the england/europe ones, so yes
20:36:48 <grantwu> Does anyone have suggestions for graph libraries for Haskell?
20:37:14 <grantwu> I know fgl is a thing, but does anyone have opinions on it
20:37:24 <grantwu> (this would be for representing interference graphs)
20:38:04 <athan> sorry dfeuer & geekosaur, my electrons burped
20:38:20 <athan> but I think I understand the limitations of C processes
20:38:28 <athan> thank you for your help :)
20:39:38 <dfeuer> athan, I don't think I helped you any.
20:39:45 <dfeuer> But maybe put you back on the rails?
20:40:03 <dfeuer> grantwu, fgl is a little ... weird. It has rough edges.
20:40:11 <athan> oh yeah, ruby on rails. Automagical af
20:40:36 <grantwu> dfeuer: Any suggestions re: alternatives?
20:40:51 <dfeuer> It does things with tuples that should be done with records. Some things seem oddly lazy. The views are strange.
20:41:05 <dfeuer> grantwu, yes, I suggest you write fgl 2. :-)
20:41:17 <dfeuer> I can make a few suggestions if you like :D
20:41:22 <grantwu> We're currently doing Map to sets
20:41:27 <grantwu> dfeuer: :C
20:41:38 <grantwu> I wrote my first line of haskell a month ago
20:41:46 <dfeuer> Excellent! 
20:42:12 <dfeuer> grantwu, most of what I know about Haskell I learned reading and writing the source code for libraries.
20:42:15 <grantwu> What are your suggestions?
20:42:30 <grantwu> I will file them under "issues" for my compiler :P
20:42:43 <dfeuer> I don't remember off the top of my head. If you're serious about it though, I can PM you my email.
20:43:50 <athan> (noob question I should be googling) what's the difference between a foreign pointer and a stable pointer?
20:44:52 <grantwu> dfeuer: Hrm....
20:45:35 <dfeuer> grantwu, begin by offering total view functions instead of this "check if empty, then use a partial function to deconstruct".
20:45:36 <grantwu> I would only implement whatever I actually needed for my compiler
20:45:37 <grantwu> at least, for this semester
20:45:49 <dfeuer> I have never written a compiler.
20:46:00 <dfeuer> It sounds like fun though.
20:46:08 <grantwu> It's for a class :P
20:46:19 <dfeuer> It sounds like fun though.
20:47:35 <grantwu> stressful though
20:47:42 <dfeuer> *nod*
20:48:28 <grantwu> esp. because the best partners end up with register coalescing, inlining, memoization, cse, constant folding, strength reduction, intelligent instruction selection... although idk if anyone does all of those at once
20:48:38 <grantwu> i.e. it's not a trivial compiler :/
20:53:30 <grantwu> dfeuer: What exactly do you mean by total view function?
20:54:29 <dfeuer> grantwu, I would *love* to take this class. I just mean instead of having a function that throws an error when handed an empty graph, you should use Maybe or similar.
20:55:03 <dfeuer> fgl is full of oddly-shaped functions with peculiar failure modes.
20:59:16 <grantwu> oh
20:59:20 <grantwu> a view function, that is total
20:59:27 <grantwu> Yeah, that, it throws an error? that is very strange.
21:00:35 <anohigisavay> hi
21:01:01 <anohigisavay> i have some problem understanding when stack decides to rebuild packages
21:01:09 <prsteele-> anyone know how to overload numeric literals like we do with strings? I don't want to implement Num since there is no sensible definition for e.g. abs or signum  
21:01:56 <grantwu> dfeuer: Do you know much about https://hackage.haskell.org/package/graphs ?
21:01:58 <jle`> prsteele-: you gotta use Num
21:02:08 <dfeuer> grantwu, no, nothing.
21:02:14 <prsteele-> jle`: that is unfortunate. Thanks!
21:02:17 <grantwu> Oh wait, there's also Data.Graph
21:02:34 <jle`> prsteele-: hindsight is 20/20 :)
21:02:36 <dfeuer> grantwu, that's likely not what you want though.
21:02:50 <grantwu> dfeuer: How so?
21:03:29 <grantwu> also http://www.cs.cmu.edu/~janh/courses/411/16/ :P
21:04:31 <dfeuer> grantwu, the representation of graphs used there is pretty primitive. You're almost certainly better off with fgl, whether you improve it, write a nice little wrapper around it, or even just use it as it is and deal with the weirdness.
21:05:09 <dfeuer> I mean, 
21:05:11 <prsteele-> jle`: alternatively this *does* give me access to the standard set of + - * (and perhaps / if I keep going) which is nice
21:05:20 <dfeuer> if Data.Graph offers the operations you need, then go for it.
21:05:25 <dfeuer> It might even be fast.
21:05:36 <dfeuer> But more generally... I have my doubts.
21:05:58 <jle`> prsteele-: what is your instance?
21:06:48 <prsteele-> jle`: I'm trying to write a type-safe DSL for representing (among other things) polynomials. The type-safe part is requiring that, for example, you pass in a linear or quadratic term (rather than something with a higher degree)
21:07:05 <prsteele-> jle`: ultimately I want an alternative to AMPL in Haskell.
21:07:20 <jle`> but yeah, abs and signum were a bit unfortunate design choices.  there's always a tradeoff between convenience and universality/purity but it's hard to see the direct impacts without hindsight
21:07:36 <jle`> there were some changes that were easy to make, like dropping the Eq superclass
21:07:48 <jle`> but killing abs/signum would be harder, heh
21:07:55 <grantwu> dfeuer: Wait.. can you not find the neighbors of a vertex?
21:08:35 <prsteele-> jle`: oh well, I think I can make this work anyway. If I get abs I can lift the polynomial to an 'infinite' degree, likewise with /... it won't handle things like x / x well, but that's fine
21:09:01 <dfeuer> grantwu, I think you can.
21:09:06 <jle`> prsteele-: ideally you'll use an 'abs' that meshes with +/-/*
21:09:13 <jle`> that's what the 'linear' package does
21:09:31 <grantwu> dfeuer: Nothing on https://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Graph.html is jumping out to me
21:09:33 <dfeuer> grantwu, actually, you may only be able to see one way and not the other. 
21:09:36 <prsteele-> jle`: ya, that still works. I'm specializing constructors for abs and signum of 0-degree polynomials
21:09:52 <prsteele-> jle`: and otherwise lifting immediately to the infinite degree case
21:10:02 <dfeuer> grantwu, well, it represents a graph as an array of lists, right?
21:10:21 <grantwu> Oh
21:10:33 <grantwu> Right, you can pull it out from that, yeah
21:10:39 <dfeuer> I think the list is the list of edges out or something. I honestly haven't looked at Data.Graph much. I don't know much about graph algorithms, and I don't know what people use it for.
21:10:56 <prsteele-> jle`: I'm basically doing length-encoded vectors but for polynomial degrees, with extra cruft on top to handle Num instances
21:11:41 <dfeuer> grantwu, I probably *should*, since I'm one of two people responsible for the thing, but i'm very much more focused on Data.Map, Data.Sequence, and (recently) Data.IntMap.
21:11:48 <dfeuer> (and Data.Set)
21:11:58 <jle`> yeah, if you respect "universal" properties of abs (like, say, abs x * abs x = x * x, abs y = y * signum y), you should be fine
21:12:15 <jle`> it might not look like any meaningful "abs"/"signum" in your actual type/domain, but at least it'll play nicely with expectations
21:12:15 <dfeuer> Remove abs and signum from Num!
21:12:23 <dfeuer> Num is such cruft :-(
21:12:32 <prsteele-> jle`: yes, until I manage to lift this library to handle semidefinite programming
21:13:05 <jle`> :-(
21:13:22 <NervousBlackRabb> Are there a lot of "Num-like" behaviours where it doesn't make sense to have a "abs" and "signum" function? I'm still a haskell beginner.
21:13:45 <prsteele-> NervousBlackRabb: sure, complex numbers are an easy example
21:14:01 <dfeuer> I'd like Num to come with fromInteger, +, *, -, and a solemn oath that it makes a ring.
21:14:06 <dfeuer> And not much else.
21:14:18 <NervousBlackRabb> prsteele- Ah, that makes sense.
21:14:40 <prsteele-> dfeuer: I think that would be reasonable
21:14:49 <dfeuer> prsteele, it's years too late though.
21:15:42 <prsteele-> ya :\
21:15:55 <NervousBlackRabb> I haven't gotten around to using complex numbers in haskell yet.
21:16:13 <grantwu> dfeuer: Table to List is funky, but Table to Set isn't totally absurd, right?
21:17:04 <prsteele-> NervousBlackRabb: other examples would be something like matrix multiplication. You could make a conforming instance using component-wise multiplication (e.g. abs x * signum x == x) but that doesn't hold for 'regular' matrix multiplication
21:17:32 <prsteele-> NervousBlackRabb: this is less of an issue since you can just make special operators for matrix addition and multiplication
21:17:43 <jle`> yeah, but * sfrom Num shouldn't be matrix multiplication anyways
21:17:48 <jle`> the whole Num thing is kinda weird heh
21:17:54 <prsteele-> NervousBlackRabb: but this still prevents you from doing e.g. 5 * x, where x is a matrix
21:18:19 <NervousBlackRabb> I see. I haven't done much linear algebra in haskell either yet.
21:19:13 <jle`> i never thought about what abs/signum for Complex were haha
21:19:22 <jle`> it's kind of cute
21:19:44 <NervousBlackRabb> I was just glancing at the documentation. magnitude/phase make sense, I suppose. They follow (abs x)*(signum x) = x
21:19:44 <jle`> abs is the magnitude and signum is the angle
21:19:50 <prsteele-> abs is fine, signum is weird. I suppose you could make it conforming in polar coordinates?
21:20:53 <MarLinn> prsteele-: with -XRebindableSyntax you can "overload" numerical literals with the help of custom fromInteger/fromRational functions. Was that what you meant?
21:20:54 <NervousBlackRabb> jle` what's the logic behind "* from Num shouldn't be matrix multiplication anyways" ?
21:21:12 <jle`> it should be component-wise multiplication
21:21:29 <prsteele-> MarLinn: it *is*, if that works! thanks!
21:22:18 <NervousBlackRabb> jle` does component-wise multiplication follow some sort of law that matrix multiplication fails?
21:22:24 <athan> Holy toleto... how long has {-# LINE #-} been around?
21:22:32 <athan> ...did haskell get "sourcemaps" right first?
21:23:04 <jle`> it plays better with the other Num methods
21:23:09 <prsteele-> MarLinn: this looks like exactly what I'm looking for!
21:23:27 <jle`> like x * 3 = x + x + x
21:23:39 <jle`> assuming 3 is a matrix full of constant 3's
21:23:46 <jle`> if 3 was the identity matrix, then x + 2 would be kind of weird
21:24:00 <jle`> it just plays better with expectations, heh
21:24:34 <jle`> if all the numeric instances were point-wise, it all meshes together nicely
21:25:36 <jle`> * if 3 was 3*I
21:26:22 <NervousBlackRabb> Yeah, I'm just trying to process what you said. Like seeing what would happen if we used diagonal matrices instead of "full" matrices.
21:27:01 <NervousBlackRabb> Like 3*I*X would just multiply every entry of X by 3...
21:27:12 <jle`> but what about addition?
21:28:00 <mauke> athan: hah, that's ancient C tech. it's been around since the 80s at least, maybe before
21:28:08 <NervousBlackRabb> As in, what would happen if I did (3 + X) = (3*I + X) ?
21:28:10 <jle`> NervousBlackRabb: you might like 2x + 3x = 5x
21:28:18 <jle`> yes
21:28:40 <athan> mauke: javascript still got it wrong :)
21:28:54 <jle`> if x + y is component-wise, then numeric litearls have to also be full/constant matrices
21:29:48 <shachaf> i,i component-wise and vector-foolish
21:29:55 <NervousBlackRabb> Yes, I can see where you are coming from.
21:30:53 <shachaf> conal: I'd be interested to hear if you come across anything else.
21:31:12 <conal> shachaf: i'll let you know.
21:44:28 <mauke> hmm. the earliest occurrence of a LINE pragma I can find is the ghc 4.04 documentation
21:45:15 <mauke> which is from 1999
21:52:19 <prsteele-> alright, back with more questions. If I know how to convert from type a to type b, is there a way to get Haskell to do so automatically (when required)?
21:53:08 <Koterpillar> prsteele-: not implicitly
21:53:15 <Axman6> only in some very special circumstances - number literals and string literals
21:53:54 <Axman6> but if you have a function f :: a -> b, you just need to apply f to the value you want to "convert".
21:54:04 <prsteele-> thanks
21:54:31 <prsteele-> Axman6: ya, I know that's what you *should* do. I'm still wrangling with implementing Num, which doesn't like (+) and (*) changing types (moving to higher orders...)
21:55:54 <Axman6> yeah Num isn't well designed for situations where you might want to change the type of the result. there are projects which are better suited for that but they're not particularly widely used.
22:02:31 <emertens> ?quote
22:02:32 <lambdabot> tristes_tigres says: thinks that programming languages can be divided into two broad classes: functional and dysfunctional
22:11:21 <erisco> is there a package that gives a function instance for Floating?
22:13:48 * hackagebot yaml 0.8.18.7 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18.7 (MichaelSnoyman)
22:16:30 <erisco> > (sqrt^2) 3.0
22:16:32 <lambdabot>  error:
22:16:32 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M472419621693...
22:16:32 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
22:16:38 <erisco> > (sqrt^2) 3.0 :: Float
22:16:40 <lambdabot>  error:
22:16:40 <lambdabot>      • No instance for (Num (Float -> Float)) arising from a use of ‘^’
22:16:40 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
22:19:55 <erisco> :t sqrt (fst^2 + snd^2)
22:19:56 <lambdabot> Floating ((a, a) -> a) => (a, a) -> a
22:22:32 <joe9> Is it possible to have a datatype like this: http://bpaste.net/show/c531a8bb3932 without resorting to existential types? or, is there a better/more-haskell'ish way of representing this, please?
22:24:43 * Jello_Raptor snnrks
22:25:04 <erisco> people here have referred to this instance ... someone must have written it up somewhere
22:25:21 * Jello_Raptor is throughly amused at some of the banter in the thread he started :V https://www.reddit.com/r/haskell/comments/53cvf2/q_what_is_the_best_way_to_learn_enough_category/
22:25:29 <joe9> http://bpaste.net/show/b8eba992b428 the 'a' here is what I am trying to get rid of
22:25:51 <pavonia> joe9: There's not much you can do with the values of type a, can you?
22:26:30 <joe9> pavonia:  I just want to compare the previous value with the current value and do something if they are not equal.
22:27:03 <joe9> pavonia: but, the catch is that value could be of a different type for different uses of the Drawable.
22:27:22 <joe9> pavonia:  for a screen drawable, it is the screen width and height
22:27:50 <MarcelineVQ> erisco: Usually it's an error of Num being generic enough to infer your number is a function rather than telling you you're using it oddly. Were you aftering something like?:  sqrt . (\(x,y) -> x^2 + y^2) $ (3,9)
22:27:52 <joe9> pavonia: for a crosshair drawable, it is the cursor x or y position
22:28:07 <joe9> pavonia: does that make sense?
22:28:15 <pavonia> Yeah
22:28:48 <erisco> MarcelineVQ, I am looking for a package which provides the number instances for functions
22:31:08 <erisco> has no one uploaded it? XD
22:31:45 <erisco> ah ha! praise the conal! http://hackage.haskell.org/package/NumInstances
22:33:40 <erisco> Chrome, stop messing with your fonts and header bar please thanks
22:35:51 <erisco> :t sqrt (uncurry (+) . x^2)
22:35:52 <lambdabot> error:
22:35:52 <lambdabot>     • Couldn't match expected type ‘a -> (c, c)’
22:35:52 <lambdabot>                   with actual type ‘Expr’
22:36:22 <erisco> :t \x -> sqrt (uncurry (+) . x^2)
22:36:24 <lambdabot> (Num c, Floating (a -> c)) => (a -> (c, c)) -> a -> c
22:36:47 <erisco> that doesn't read nicely though, bit of a shame ... maybe there is another way to use the tuple instance here
22:37:34 <erisco> :t \x -> sqrt (uncurry (+) (x^2))
22:37:36 <lambdabot> (Num (a, a), Floating a) => (a, a) -> a
22:37:37 <erisco> I meant that one
22:42:49 <erisco> could yank in a linear algebra lib for dot product
22:44:58 <NervousBlackRabb> So, erisco, you're trying to give an implementation of Num for binary numerical functions?
22:45:46 <erisco> all of them, a complete instance
22:47:57 <NervousBlackRabb> What do you mean by that? Any function whose result is a Num?
22:51:13 <erisco> NervousBlackRabb, look at the package I linked to
22:53:57 <NervousBlackRabb> gotcha..
22:54:31 <grantwu> Anyone one got tips for speeding up Megaparsec (fork of Parsec) ?
22:54:50 <grantwu> We're parsing a C-like language with nested /* */ comments
22:55:19 <grantwu> I'm new to Haskell and all I know about Haskell performance is that there are profiling tools available and that liberally sprinkling ! sometimes helps
22:56:05 <cocreature> grantwu: don’t backtrack (i.e. call try) if you can avoid it
22:56:53 <cocreature> grantwu: try making the type signatures of your parsers as concrete as possible, i.e. instantiate type variables
22:57:03 <cocreature> grantwu: and if you are using String instead of Text, don’t :)
22:57:06 <shachaf> Sprinkling ! without a reason probably hurts.
22:57:21 <cocreature> yeah sprinking ! is almost never a good idea
22:57:47 <glguy> If you want the full liberal sprinkling experience there's a language extension
22:57:48 <Guest52664> Wait really? I'm a newb and I thought that was a good idea when writing performant code 
22:58:26 <Guest52664> Is excessive strictness inefficient? 
22:58:32 <cocreature> Guest52664: ! is not some magic thing that automatically makes your code performant. there are some cases where it makes sense and some where it doesn’t
22:58:34 <glguy> certainly
22:58:35 <shachaf> Yes, Haskell is in slow mode by default, but if you put !s everywhere, you unlock fast mode.
22:58:39 <grantwu> If it makes you do excess work
22:58:43 <shachaf> But don't tell anyone, that feature is for experts only.
22:58:56 <Axman6> shhh!
22:59:09 <MarLinn> It's like the old "turbo" button on pcs
22:59:10 <glguy> shachaf: My GHC license only seens to entitle me to 15 !s
23:00:43 <Axman6> yeah I had to choose the most bespoke handcrafted locations to use my dwindling supply of them
23:00:58 <erisco> is it curious that Floating does not require Ord?
23:01:11 <Axman6> doesn't it require Num?
23:01:21 <cocreature> erisco: why should it require Ord?
23:01:22 <Axman6> which requires Ord?
23:01:22 <grantwu> It's late enough that the ! jokes made my partner and I laugh for a good 2 minutes
23:01:51 <grantwu> cocreature: In any case - I see lots of String here: https://github.com/mrkkrp/megaparsec/blob/82994e45d4b98c874ff4f83a5f35f90ba122e5f2/Text/Megaparsec/Lexer.hs
23:01:52 <joe9> Guest52664:if you want performant code, check out Vector.Unboxed.
23:02:04 <joe9> Guest52664: instead of lists
23:02:04 <grantwu> Does anyone know how I might be able to make it... not string...
23:02:18 <erisco> cocreature, no reason, other than I expect there to be Floating instances which are not Ord
23:02:24 <geekosaur> Num doesn't require Ord, nor does Floating. Complex is not Ord
23:02:34 <erisco> okay, thanks
23:02:41 <erisco> in what sense is it not Ord?
23:02:43 <MarcelineVQ> I don't think Num needs Ord, it used to need Eq
23:02:51 <cocreature> erisco: is 1 < i?
23:03:13 <Guest52664> @cocreature yes, because I say so 
23:03:14 <lambdabot> Unknown command, try @list
23:03:17 <erisco> cocreature, no
23:03:34 <Guest52664> 1 < _ = True
23:03:47 <Axman6> the derived Ord instance for Complex would say yes :P
23:04:06 <erisco> there are instances with nonsense Ord instances, such as Ordering
23:04:20 <Axman6> nah the Ordering instance is totally useful
23:04:30 <erisco> for Complex we can order first by real component and second by irrational component, so it is like ordering (Num a) => (a, a)
23:04:54 <erisco> Axman6, I did not say it was useless, I said it was nonsense
23:04:58 <cocreature> it’s annoying that we mix things that can just be ordered in some weird way which is enough for putting them in a map and things where the ordering “makes sense”
23:05:08 <NervousBlackRabb> erisco, this looks like it's the same code in the library you got, but I found this wiki page: https://wiki.haskell.org/Num_instance_for_functions
23:05:26 <erisco> NervousBlackRabb, I actually found that same page, but thanks!
23:05:34 <Axman6> how is it nonsense?
23:05:43 <geekosaur> we need support for partial orders and arbitrary orders (for e.g. Map). *mathematically* Complex cannot be ordered
23:06:03 <cocreature> Axman6: arbitrary is a better name than nonsense
23:06:06 <erisco> Axman6, what is the reasoning you would give for the instance of Ordering for Ord?
23:06:14 <erisco> not for its mere existence, but for why it is defined as it is
23:06:56 <Axman6> is LT not less than EQ? I guess that doesn't really make a whole lot of sense but is the most sensible instance
23:07:04 <erisco> I avoided "arbitrary" because in a sense it is all arbitrary, as we must create the ordering out of nothing
23:07:43 <erisco> I preferred "nonsense" because there is no rationale for why this choice over another (a common one being "because that is historically mathematical")
23:07:45 <Koterpillar> one reason is that this should hold: LT < EQ == [EQ, LT] < [EQ, EQ]
23:08:07 <Axman6> so is Complex's Ord instance not compareing magnitude <> comparing realPart <> comparing imaginaryPart ?
23:08:12 <Axman6> (roughly)
23:08:58 <Axman6> (the last bit is definitely sus)
23:09:01 <cocreature> Complex doesn’t have an Ord instance
23:09:22 <Axman6> yeah that's probably good
23:09:34 <geekosaur> whatever Ord instance you pick, it's wrong for someone
23:10:05 <geekosaur> whereas I think most people will agree what Ord for, say, Double should do
23:10:20 <geekosaur> (modulo NaN, which is why we need partial ordering >.>)
23:10:27 <Axman6> grantwu: you'll notice that most of the things in Lexer.hs are just wrapping things in Char.hs, so maybe use that instead so you can use Text more often
23:11:22 <grantwu> I see
23:11:24 <erisco> geekosaur, does this suggest data Partial = LT | GT | EQ | NA ?
23:12:03 <grantwu> Axman6: Er, use Char.hs more often?
23:12:21 <erisco> or Maybe Ordering ... engineering trade off
23:12:21 <geekosaur> (a worse problem with Ord on Complex Double is, it should be stable on conversion to polar form, not that we support that anyway --- but the notion of an angle being less than or greater than another is even more arbitrary)
23:12:57 <geekosaur> I prefer the Maybe Ordering one myself, but yes, there are tradeoffs
23:13:30 <geekosaur> and may be implications (consider that the Monoid instance of Ordering is used to combine comparisons for e.g. sortBy; what works better for partial ordering there?)
23:13:38 <Koterpillar> so what's LT <> NA?
23:13:40 <Koterpillar> NA?
23:13:54 <Axman6> NALT
23:13:57 <erisco> the Monoid instance is the least concern :P
23:15:08 <erisco> I think, as you said earlier, the instance will always be wrong for someone
23:15:15 <erisco> this is the issue with type classes
23:15:22 <Axman6> newtypes!
23:15:24 <Axman6> >_>
23:15:34 <jle`> but i just want to be able to use Map (Complex Double) a
23:15:46 <jle`> is that so wrong
23:16:51 <jle`> erisco: also, everyone's favorite Num a => Num (r -> a) instance can not be Eq or Ord
23:17:22 <Axman6> I guess that's why they were removed as super classes right?
23:17:28 <erisco> jle`, heh
23:17:53 <Axman6> I feel I just made someone'ds eye twitch by using "super classes" but can't remember the proper term
23:18:51 <erisco> time for class Ord1 f where compare :: Ord a => f a -> f a -> f Ordering
23:19:13 <Axman6> can we add some Profunctor in there too?
23:19:27 <grantwu> Would adding a separate lexing stage improve performance?
23:19:32 <jle`> erisco: that's already in base
23:19:51 <grantwu> argh, I'm being stupid, I should just profile
23:19:51 <erisco> wow
23:19:57 <jle`> erisco: http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Classes.html#t:Ord1
23:20:10 <shachaf> "superclass" is the term
23:20:55 <jle`> erisco: except they call it compare1, not compare
