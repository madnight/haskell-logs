00:00:01 <zell> the path is narrow, especially so in higher dimensions, compared with the words which are broad in the alphabet
00:04:32 <zell> determining if an adjacent cell is occupied by a value satisfying a boolean function
00:06:21 <zell> perhaps also good for very long words selected if they contain short substrings
00:07:39 * hackagebot spy 0.14 - A compact file system watcher for Mac OS X, Linux and Windows  https://hackage.haskell.org/package/spy-0.14 (StefanSaasen)
00:07:39 * hackagebot indexed 0.1.3 - Haskell98 indexed functors, monads, comonads  https://hackage.haskell.org/package/indexed-0.1.3 (ReinerPope)
00:12:34 * hackagebot jose 0.4.0.3 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.4.0.3 (frasertweedale)
00:12:36 * hackagebot craft 0.0.0.1 - A UNIX configuration management library in Haskell  https://hackage.haskell.org/package/craft-0.0.0.1 (joehillen)
00:14:30 <zell> it would be exhaustive to store all common substrings and their overlaps
00:16:10 <zell> oh i guess then you add the substrings to the alphabet
00:18:02 <tsani> I have a monad transformer stack n in which one of the monads m lower in the stack has some function like foo :: (Foo -> m a) -> m a
00:18:39 <zell> i want one
00:18:55 <tsani> how can I lift foo to have the type (Foo -> n a) -> n a
00:19:05 <tsani> zell: :P
00:19:48 <geekosaur> tsani, you use lift as many times as necessary to reach that m, then run foo there.
00:20:49 <tsani> geekosaur: I get something of type (Foo -> m a) -> n a if I try that
00:20:59 <jle`> tsani: it would be a lot easier to answer if you gave us the concrete types :)
00:21:02 <jle`> that you are talking about
00:21:13 <geekosaur> hm. you may not be able to do that reliably
00:21:18 <tsani> jle`: very true :P
00:21:31 <tsani> I'm thinking something from mmorph might help me, but I'm not sure what
00:21:43 <tsani> I'll prepare a paste that shows what's happening
00:21:44 <zell> :t lift
00:21:45 <jle`> the answer for all 'm' might be complicated
00:21:46 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
00:21:50 <jle`> but the answer for a specific m will likely be trivial
00:22:03 <nshepperd> tsani: there's a package called monad-base-control i think that is commonly used in the lifting IO case
00:22:25 <geekosaur> that sounds like a situation where you may have to arbitrarily create an n from an m, and unless you can prove this is always possible for any m and any n (or you can devise a constraint that ensures that it is possible), you may not be able to do this generically
00:22:45 <nshepperd> There's isn't really a general solution for any m
00:23:20 <zell> given (m a -> n a)?
00:23:37 <geekosaur> are you given that?
00:23:48 <zell> i wanst
00:24:00 <tsani> In this case, n is `ExceptT PlaybackError (DbT m)` and DbT is my n, defined as `ReaderT ConnectionPool (StateT ConnectionState m)`
00:24:27 <geekosaur> also consider that this actually requires both directions --- you need to be able to do both m a -> n a and n a -> m a
00:24:35 <geekosaur> one for the parameter, the other for the result
00:25:09 <zell> oh this sounds coyoneda to me
00:25:19 <jle`> hm yeah, m is in both the positive and negative position here.  lifting things like this (being able to go back and forth) is a pattern that monad-base-control sort of encapsulates
00:25:58 <geekosaur> ...requiring a fair amount of work to set up, iirc
00:26:27 <jle`> yeah, monad-base-control is usually a pretty huge step in generalization
00:26:31 <nshepperd> tsani: if i were writing this i would just use a custom combinator here honestly
00:26:44 <jle`> yeah, writing the combinator manually should be pretty simple
00:27:08 <jle`> sorry, by simple, i mean non-magical
00:27:22 <jle`> it might not be simple :)  but it'll be clear and concise
00:28:01 <zell> i dont really know what your talking about..
00:28:09 <zell> whats a combinator?
00:28:10 <jle`> if you find that you have to generalize this pattern somehow, monad-control is basically the pattern of lifting actions in weird positions
00:28:23 <jle`> zell: write your ((Foo -> m a) -> m a) -> (Foo -> n a) -> n a
00:28:25 <jle`> manually
00:28:30 <jle`> for specifically your instances of m and n
00:28:42 <zell> i dont see the alternative
00:29:05 <jle`> as in, ((Foo -> ReaderT ConnectionPool (StateT ConnectionState m) a) -> ..) -> etc.
00:29:10 <jle`> with concrete types
00:29:13 <jle`> not polymorphic over all m and n
00:29:42 <zell> oh, so that they could eg only need satisfy a class constraint
00:29:49 <tsani> jle`: I think that's the best approach yes.
00:29:56 <tsani> Just do it for this concrete case.
00:29:56 <jle`> i mean, don't worry about class constraints
00:29:56 <zell> however you call it
00:30:01 <jle`> just write it monomorphically
00:30:14 <jle`> like say you want to take the first five items of a list
00:30:25 <jle`> you wouldn't look for a generic/polymorphic Functor f => f a -> f a
00:30:32 <jle`> you'd write it for the type you care about, [a] -> [a]
00:30:46 <jle`> because you only care about lists, what's the point of finding a complicated generic solution?
00:30:56 <zell> it would work with any foldable container though
00:31:10 <zell> identifying the constraint is helpful
00:31:33 <jle`> it's usually much easier to write the monomorphic case first
00:31:37 <jle`> and then see if you can generalize
00:31:51 <zell> how does monad-control help?
00:32:01 <jle`> also such a `Foldable f => f a -> f a` that takes the first items is not possible
00:32:07 <jle`> see the danger in premature generalization? :)
00:32:21 <zell> :t take
00:32:22 <lambdabot> Int -> [a] -> [a]
00:32:26 <zell> argh
00:32:31 <jle`> the best you can do is a Foldable f => f a -> [a]
00:32:44 <zell> :t toList
00:32:46 <lambdabot> error:
00:32:46 <lambdabot>     Ambiguous occurrence ‘toList’
00:32:46 <lambdabot>     It could refer to either ‘F.toList’,
00:32:51 <zell> yeh
00:33:15 <jle`> so by trying to prematurely generalize before you even write the monomorphic case, you run into misconceptions and confusions
00:33:36 <jle`> it might not be super obvious that a generic Foldable version is impossible
00:33:46 <jle`> and if you never need one anyway, why waste time trying to find it?
00:34:48 <zell> oh i get confused because i wrote a foldable instance for Stackish http://lpaste.net/194272
00:35:38 <zell> class Constructable f b a where
00:35:38 <zell>  construct :: Constructor f b a -> f a
00:35:51 <zell> not foldable sorry
00:38:22 <zell> instance Stack f => Constructable (Stackish f) () a where
00:38:22 <zell>  construct (a,_,(Stackish f)) = Stackish (push a f)
00:38:32 <zell> thats the generalisation to []
00:39:23 <zell> but whats the point in trying to find it
00:39:51 <jle`> hm is that a rhetorical question?
00:40:25 <tsani> jle`: you were right; the monomorphic case here was trivial :)
00:40:43 <zell> i was intending to use the parameter b as [Int] to direct the growth of Free [[]]
00:40:48 <jle`> :D
00:42:07 <zell> it turns out that there are infinitely many ways to represent the natural numbers as nested lists with empty basecases
00:42:46 <zell> thats the generalisation to lists and was an attempt to generalise []
00:42:56 <zell> oops
00:43:17 <zell> im trying to answer "and if you never need one anyway, why waste time trying to find it?"
00:44:00 <zell> the monomorphic instance is a special case of a superclass
00:44:44 <jle`> it's good to find the generalized/superclass version when you need it
00:44:51 <jle`> it's harder to justify finding it when you don't
00:45:23 <zell> admittedly the function take would require an additional argument per element to direct the traversal, but it was a generalisation after all, using take really does fix it to []
00:46:13 <zell> my monomorphic instance is a ploymer growth and modification api, the polymorphic generalisation can eg grow and modify programs
00:46:53 <zell> rather than just cyclic conected lists of tuples of Doubles
00:47:13 <zell> using a Free [] permits branching
00:47:44 <zell> using Free [[]] allows partial traversal of multiple subsections
00:48:19 <zell> no idea how to do the cyclic bit though, it really messes up the zipper
00:48:35 <zell> which needs to be unrolled to the start
00:50:16 <zell> admittedly i do have funding particularly to investigate these kinds of containers, i guess the user should be spared such investigations
00:54:47 <zell> maybe ill leave a trail of breadcumbs
01:12:45 * hackagebot elm-export 0.4.1.0 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.4.1.0 (krisajenkins)
01:56:58 <hsk3> How can I detect and get rid of unnecessary libraries in my build-depends?
01:58:46 <StarsC> is there such thing as MonadLimit ? which allows to run/execute some action/function up to Limit number of times?
01:58:57 <ongy> hsk3: there's https://hackage.haskell.org/package/packunused (last I tried it didn't build with ghc-8 though)
01:59:55 <Cale> StarsC: I'm not sure why that would need to be a type class
02:00:25 <StarsC> Cale: it should not, just any existing work in this direction would be nice
02:00:30 <Cale> StarsC: First of all, why would it execute the action less than the maximum?
02:00:52 <Cale> Maybe I don't understand what it is that you mean
02:00:53 <StarsC> for example it can check if there is internet but try not more than 10 times for example
02:01:13 <Cale> That seems like the sort of thing you'd handle just with recursion
02:01:53 <StarsC> another example - sort list but leave not more than 10 duplicates of each element
02:02:48 <StarsC> kinda general pattern i thought there is structure for it
02:04:03 <hsk3> ongy: thanks
02:04:22 <ClaudiusMaximus> your second example doesn't seem so related to the first, but can be implemented as   concatMap (take 10) . group . sort
02:04:49 <StarsC> ClaudiusMaximus: isnt it related if you would think about list as monad?
02:06:08 <jle`> i don't think so; sequencing actions in List doesn't mean having more or less of that item
02:06:37 <jle`> having 10 of an item in a list isn't related to "10 executions" in List
02:06:42 <StarsC> so its safe to assume that there is no such concept on stuctures level so far?
02:07:31 <jle`> there are ways to sequence an execution of action until a certain condition is fulfilled
02:07:34 <jle`> but
02:07:36 <jle`> that can be done with just Monad
02:07:40 <jle`> you don't need an extra typeclass
02:07:58 <jle`> runUntilLimit :: Int -> m Bool -> m ()
02:08:05 <jle`> * Monad m => ...
02:08:45 <jle`> that sounds like just a normal function you can write to work on all Monad instances
02:09:19 <StarsC> yes, thats true
02:09:31 <StarsC> hm, ok, that sounds plausible
02:09:35 <jle`> so i guess if you're asking if there's such a thing... then, yes?
02:10:18 <jle`> it might not be in any popular libraries, so you might have to write it from scratch if you want to use it
02:10:22 <jle`> but it shouldn't be too tricky :)
02:12:00 <StarsC> :) yes
02:12:51 * hackagebot servant-auth-cookie 0.3.2 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.3.2 (zohl)
02:12:58 <dazz> hi
02:13:30 <StarsC> jle`: ty
02:13:37 <jle`> np!
02:20:58 <suppi> I have a "test" folder in my stack project, everything compiles and runs and all but intero complains about not finding any modules i import
02:21:29 <suppi> for my local modules it says that it can't find them and for packages it says that they might be hidden
02:21:37 <suppi> any ideas how to make it work?
02:27:23 <reddy__> better to google
02:28:57 <suppi> reddy__, are you refering to me?
02:30:56 <reddy__> suppi yes
02:31:26 <suppi> thanks for the help
02:35:49 <osager> im writing a haskell script which is to be excuted by stack myscrip.hs
02:36:06 <osager> how to include some of my own modules?
02:37:24 <osager> i have a utility library in a folder called MyLib. MyLib and my script is inside the same folder
02:37:42 <osager> in my script, i import MyLib.Utiliy
02:38:31 <osager> when i run stack myscript.hs, it couldn't find the definitions in my module
02:41:49 <ongy> osager: I would recommend doing a proper package, since then you can also build an executable with optimization
02:51:51 <ania123> how can I check type of + in haskell
02:51:52 <ania123> ?
02:52:22 <cjay> ania123: :t (+)  in ghci
02:52:23 <pavonia> Type ":type (+)" in GHCi
02:53:01 <ania123> I am using winghci
02:53:40 <ania123> Prelude> :t (+) (+) :: Num a => a -> a -> a
02:53:57 <ania123>  (+) :: Num a => a -> a -> a
02:54:04 <ania123> what does => denotes?
02:54:19 <ania123> -> is functional type constructor? no?
02:54:36 <koz_> ania123: Everything before a => is a typeclass constraint.
02:54:45 <koz_> So the thing above means 'a must be an instance of Num'.
02:56:05 <ania123> so, type of + is Num X Num -> Num
02:57:04 <liste> ania123: not exactly
02:57:09 <ania123> why?
02:57:18 <liste> ania123: because Num is not a type
02:57:28 <liste> ania123: different types may *implement* Num
02:57:48 <ania123> if I want to define + as sum integers
02:57:50 <liste> so + can be Int x Int -> Int or Double x Double -> Double
02:57:51 <ania123> I give it type
02:57:52 <liste> for example
02:57:59 <ania123> + : int  x int -> int
02:58:16 <liste> (actually Int -> Int -> Int, but that's whole another thing)
02:58:56 <liste> > let (+++) :: Int -> Int -> Int; a +++ b = a + b in 3 +++ 4
02:58:58 <lambdabot>  7
02:59:14 <liste> > :t let (+++) :: Int -> Int -> Int; a +++ b = a + b in (+++)
02:59:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:59:24 <liste> :t let (+++) :: Int -> Int -> Int; a +++ b = a + b in (+++)
02:59:26 <lambdabot> Int -> Int -> Int
02:59:39 <liste> (I'm using +++ to not shadow Prelude's +)
03:00:16 <ania123> could you tell me please type of +
03:00:21 <ania123> what is type of +
03:00:30 <liste> ania123: it's Num a => a -> a -> qa
03:00:33 <liste> ania123: it's Num a => a -> a -> a *
03:01:01 <ania123> could you explain what that notation means?
03:01:13 <ania123>  a -> a -> a  is clear from me
03:01:22 <ania123> if a function has this type it means
03:01:49 <ania123> either it has 1 argument or two arguments
03:01:58 <ania123> if it has 1 argument of type a
03:02:20 <ania123> f(b) will be function of type a->a
03:02:27 <ania123> if f: a->a->a
03:02:28 <ania123> and
03:02:31 <ania123> b: a
03:02:39 <ania123> fbb: a
03:02:52 <liste> ania123: it means that "a -> a -> a for any a that implements the Num typeclass"
03:03:19 <liste> and types like Int and Double implement that typeclass (ie. have instances for it)
03:03:36 <ania123> ok
03:03:53 <ania123> assume f has type a->a->a
03:03:57 <ania123> and b: a
03:04:08 <ania123> fb has type a->a
03:04:10 <ania123> ok?
03:04:12 <liste> yes
03:04:22 <ania123> but this is not what we want
03:04:23 <ania123> no?
03:04:29 <ania123> because + has to be binary
03:04:33 <ania123> function
03:04:41 <ania123> it should has two arguments
03:04:42 <ania123> no?
03:06:44 <liste> ania123: in Haskell two-argument functions are usually a -> a -> a
03:06:49 <liste> it's called currying
03:06:57 <liste> :t (+)
03:06:58 <lambdabot> Num a => a -> a -> a
03:07:01 <liste> :t (+) 5
03:07:03 <lambdabot> Num a => a -> a
03:07:09 <liste> :t (+) 5 6
03:07:10 <lambdabot> Num a => a
03:07:36 <liste> you can have (a, a) -> a functions too but they are seldom used
03:07:52 <liste> :t uncurry (+)
03:07:53 <lambdabot> Num c => (c, c) -> c
03:08:01 <ania123> So, "Num a" means a has to be nstantioned by Num 
03:08:02 <ania123> no?
03:08:07 <liste> ania123: yes
03:09:25 <liste> ania123: in practice, for eg. Int means that there's a "instance Num Int where ..." defined somewhere
03:09:58 <liste> and that instance defines how (+) works *for Ints*
03:12:14 <ania123> liste: So, Num is a variable which can be int, or real, or nat, etc
03:12:21 <ania123> ok?
03:12:35 <ania123> Num is a type variable
03:12:38 <ania123> is not?
03:12:51 <liste> ania123: no, it describes another type variable
03:13:01 <ania123> a is a type variable
03:13:03 <ania123> ?
03:13:06 <liste> yes
03:13:08 <ania123> "a"
03:13:25 <ania123> Num is a kind of set
03:13:32 <liste> yes, a set of types
03:13:36 <ania123> from where "a"
03:13:40 <ania123> can get types
03:13:41 <ania123> no?
03:13:59 <liste> yes, it restricts the types that `a' can be
03:14:05 <ania123> cool
03:14:07 <ania123> thanx
03:14:10 <liste> yw (:
03:14:10 <ania123> clear :)
03:24:43 <ania123> liste: if I want to restrict type of + to be int, can I define it?
03:31:37 <ongy> :t ((+) :: Int -> Int -> Int)
03:31:39 <lambdabot> Int -> Int -> Int
03:39:17 <ania123> ongy
03:39:34 <ongy> yes?
03:39:58 <ania123> id I declare type of + like that and then I write 3 + (1-)
03:40:03 <ania123> id I declare type of + like that and then I write 3 + (-1)
03:40:35 <ongy> I don't see why you would do that, but you can
03:40:39 <ania123> i should get error, no
03:40:40 <ania123> ?
03:41:00 <ongy> > (-1) :: Int
03:41:02 <lambdabot>  -1
03:41:07 <ongy> why would you get an error?
03:41:09 <ania123> if I want + to be defined only for nat numbers
03:41:25 <ania123> what is type of 3.4
03:41:26 <ania123> ?
03:41:34 <ongy> :t 3.4
03:41:36 <lambdabot> Fractional t => t
03:41:43 <ongy> Which is something like Num, but for fractional
03:41:59 <ongy> the closes to Nat we have is Word. But Word behaves a bit different than you may expect
03:42:02 <ongy> > (-1) :: Word
03:42:05 <lambdabot>  18446744073709551615
03:42:41 <ania123> ongy: -2 is not natural number, no?
03:44:10 <ongy> it isn't. A value of type Word will also never be -2. But it underflows instead of throwing an error
03:44:23 <ongy> as you can see with the -1 example above
03:44:36 <ania123> if I want to give + type Nat->Nat->Nat
03:44:41 <ania123> and after write 
03:44:47 <ania123> 3+(-2)
03:44:58 <ania123> I want to see what compiler will answer
03:45:07 <ongy> :t Nat
03:45:09 <lambdabot> error:
03:45:09 <lambdabot>     • Data constructor not in scope: Nat
03:45:09 <lambdabot>     • Perhaps you meant one of these:
03:45:34 <ania123> what it means?
03:46:06 <ongy> that was a little fail from me
03:46:11 <mauke> that error message? it means Nat is not a value (as far as the compiler knows)
03:46:32 <liste> :k Nat
03:46:33 <lambdabot> error:
03:46:33 <lambdabot>     Not in scope: type constructor or class ‘Nat’
03:46:40 <ongy> so as I said, we don't have a Nat type. the closes we have is Word, but Word underflows (it's 64bit unsigned Int)
03:46:59 <ongy> > let add :: Word -> Word -> Word = (+) in 3 `add` (-2)
03:47:02 <lambdabot>  1
03:47:14 <mauke> > 3 + (-2) :: Word
03:47:16 <lambdabot>  1
03:47:51 <ongy> if you want to understand what and how it happens look up binary number representation, especially twos-complement
03:48:10 <pavonia> > 3 + (-2) :: Natural
03:48:13 <lambdabot>  *Exception: Natural: (-)
03:48:30 <pavonia> > 3 - 2 :: Natural
03:48:33 <lambdabot>  1
03:50:56 <ongy> why has Natural never come up in related discussions?
03:52:07 <ongy> > negate (1 :: Natural)
03:52:09 <lambdabot>  *Exception: Natural: (-)
03:52:24 <ongy> :t negate (1 :: Natural)
03:52:26 <lambdabot> Natural
03:52:35 <ongy> so it's a runtime error.
03:52:53 <mauke> > 1 - 2 :: Natural
03:52:55 <lambdabot>  *Exception: Natural: (-)
03:52:58 <mauke> yep
03:53:10 <mauke> looks like it's the default implementation of negate x = 0 - x
03:53:43 <pavonia> I don't even know where Natural comes from
03:53:43 <liste> > 2 - 1 :: Natural
03:53:46 <lambdabot>  1
03:53:56 <ongy> Numeric.Natural 
03:54:00 <ongy> https://hackage.haskell.org/package/base-4.9.0.0/docs/Numeric-Natural.html
03:55:06 <ongy> is it just error-ing? wouldn't something like ArithmeticException make more sense? (can we do that from pure code?)
03:55:26 <pavonia> It doesn't seem to work very well for big numbers, though
03:55:32 <pavonia> > 2^64 :: Natural
03:55:35 <lambdabot>  *Exception: stack overflow
03:56:25 <ongy> it says unbound
03:56:54 <ongy> oh it's ArithException, good to know
03:57:17 <pavonia> > iterate (* 4) 1 :: [Natural]
03:57:19 <lambdabot>  [1,4,16,64,256,1024,4096,16384,65536,262144,*Exception: stack overflow
03:57:52 <ongy> hm, code uses BigNat. I expected something 'newtype Natural = Nat Integer'
04:02:01 <shane`> If I use strict Text with Pipes, does that mean that Pipes will ensure that the at no point will too much Text be stored in the memory?
04:02:58 <Cale> It doesn't do any such thing. That's still your responsibility.
04:04:36 <shane`> What does it mean then, when it says that it is a sort of replacement for Text.Lazy?
04:04:39 <Cale> However, it makes it easier to work with a stream of strict chunks of Text
04:05:01 <Cale> Well, it's not as if Text.Lazy does that either
04:08:03 <shane`> My main concern is that there is this package HaTex which uses strict Text as its datatype for parsing etc. I need to use some of the parsers that it defines, but I do not want it to load all text at one go becaause in my case the file may be extremely large. One alternative would be to replace Text with Lazy Text in the source code. But can I use pipes to ensure the same thing without having to alter the code of Ha
04:08:04 <shane`> Tex?
04:12:55 * hackagebot ViennaRNAParser 1.3.0 - Libary for parsing ViennaRNA package output  https://hackage.haskell.org/package/ViennaRNAParser-1.3.0 (FlorianEggenhofer)
04:15:18 <ania123> 5 is natural number
04:15:47 <ania123> it is not clear for me, why compiler does not return 
04:15:59 <ania123> type of 5 just nat
04:16:04 <ania123> and instead it returns
04:16:05 <ania123>  :t 5 5 :: Num t => t
04:16:41 <ertesx> shane`: pipes is a streaming abstraction…  if it's used, it most likely means that the file is not read into memory in full, but chunk by chunk as it's processed
04:17:06 <pavonia> ania123: Number literals are overloaded in Haskell. 5 can be an Int, a Natural, a Double etc.
04:17:10 <ertesx> shane`: and in that case strict Text is the proper text type to use…  you process the file's content strict chunk by strict chunk
04:17:40 <ania123> pavonia: what Double  type stands for?
04:17:49 <ania123> int and nat is clear
04:18:17 <pavonia> A certain type of floating point numbers
04:18:34 <pavonia> > sqrt (5 :: Double)
04:18:36 <lambdabot>  2.23606797749979
04:18:38 <shane`> ertesx: Thanks, so am I to understand that given the existence of pipes, Lazy Text is sort of redundant apart from not having to learn and use pipes?
04:18:44 <ania123> also, if ok, clear
04:18:53 <ania123> but type of -5 an not be nat
04:18:55 <ania123> ok?
04:18:59 <ania123> :t (-5) (-5) :: Num a => a
04:19:01 <lambdabot> error:
04:19:01 <lambdabot>     • Could not deduce (Num (t0 -> a1))
04:19:01 <lambdabot>         arising from a use of syntactic negation
04:19:25 <ania123> nat belongs to Num
04:19:29 <ania123> it confuses me a bit
04:21:09 <pavonia> ania123: Yeah, you have two options if introdicing a new number type: 1) Make it an instance of Num, then you can use (+), (*) etc. with it but it might not perfectly fit into the Num class because natural e.g. doesn't have a negate function
04:21:47 <pavonia> 2) Don't make it a Num instance, but then you can't use the default operators for addition, multiplication etc. So it's a trade-off
04:31:40 <ongy> also Integral for fromIntegral
04:34:09 <ertesx> @tell shane` not quite (about the apparent redundancy of lazy Text due to streaming abstractions)…  lazy Text serves a different, compositional purpose: you can define texts based on a formula or on a transformation of other texts that only exist semantically, not as actual data in memory, very similar to lazy lists
04:34:09 <lambdabot> Consider it noted.
04:36:23 <M41px[m]> Hello, i try lens and aeson https://gist.github.com/41px/1837464bc8e33ca901d186da3bc24516 but I do not see how to go take a key. For example key "thumb". This is the proper way to use the library?
04:55:11 <rightfold> With postgresql-simple, is it possible to get the text representation of a non-text (e.g. timestamp) value without changing the query?
04:56:45 <srhb> rightfold: How does it represent timestamps? UTCTime?
04:57:38 <rightfold> LocalTime, or LocalTimestamp
04:57:50 <rightfold> but the value could be of any PostgreSQL type (hence "e.g.")
04:58:04 <rightfold> integers, doubles, points, text, bytea, etc.
04:58:05 <srhb> rightfold: The answer isn't generic.
04:58:48 <srhb> rightfold: Sometimes you may simply want the Show instance, sometimes you may want something more specific (like formattime)
05:04:45 <rightfold> Hmm, if I wrap the query with "SELECT row_to_json(t) FROM (<original query>) AS t" then I can get something to work I think :)
05:06:49 <srhb> rightfold: Seems like you're destroying type information. I wonder why you want that. :)
05:07:37 <rightfold> Because I don't know the original column types, and I just want to display the data to the user
05:07:49 <rightfold> the query comes from a file
05:11:31 <lpsmith> rightfold, yes, though it's not as pretty as you might want
05:12:28 <lpsmith> You can define your own "TextConv" type,  and then declare an FromField instance
05:12:41 <lpsmith> Or you can use fieldWith
05:12:55 <martinr_> Hello
05:17:48 <martinr_> im new to Haskell and im trying to assign a value to a variable in one function and access it in another function
05:18:11 <martinr_> Is there a way to do  global variables?
05:18:32 <martinr_> I've had a look at the wiki, but I'm still not sure how to do it
05:20:04 <rightfold> You cannot reassign variables in Haskll
05:20:14 <rightfold> You have to pass the value as an argument instead
05:22:06 <martinr_> rightfold, im not trying to reassign it
05:22:08 <martinr_> I've got
05:24:26 <martinr_> let screensize = 960 in a function. And then, further down in a top level statement I've got bar = "hello" ++ screensize
05:25:57 <rightfold> declare screensize at the top level as well. instead of inside a function
05:26:46 <rightfold> given "let x = a in e", x is only available inside a and e
05:27:32 <martinr_> rightfold, that would work except the value of screensize is assigned in an if statement
05:27:39 <martinr_> It depends on a condition
05:28:37 <martinr_> So i can't just put it top level
05:29:55 <srhb> martinr_: This is pretty common: main = do { someUserParam <- getThatUserParam; restOfProgramWith someUserParam }
05:30:01 <srhb> martinr_: Or some variation thereof
05:32:45 <martinr_> srhb, im sorry, but i don't quite understand
05:33:25 <srhb> martinr_: What you asked for initially is impossible in Haskell. The usual, simple method, is to get the user parameter and then refactor the rest of your program to take it as an argument.
05:34:05 <srhb> martinr_: For instance, a program that prints the user's name is: main = do { userName <- getLine; putStrLn ("Hi " ++ userName) }
05:34:24 <srhb> martinr_: Notice how, in a sense, putStrLn is "the rest of the program" which takes the input as an argument.
05:34:39 <srhb> (I prefixed "Hi " to it though)
05:37:27 <martinr_> ok...
05:37:31 <martinr_> Give me a second
05:37:36 <srhb> martinr_: Sure thing. :)
05:43:47 <martinr_> srhb, ah ok. I think i understand now. So if i put my foo = "hi" ++ screensize in a function instead of it being top level and then pass screensize as a parameter to that function, it should work?
05:44:52 <srhb> martinr_: I'm not exactly sure what you're saying, but if it's the same thing I just said, then yes. :-)
05:45:11 <martinr_> srhb fair enough :)
05:45:28 <srhb> martinr_: Try mocking up a small example and putting it on lpaste.net if you're in doubt :-)
05:57:15 <luffy`> hi
05:57:47 <luffy`> i've been reading Haskell Programming from first principles
05:58:27 <srhb> luffy`: Hi :)
06:02:20 <luffy`> hi srhb
06:07:48 <martinr_> srhb, would it be fine if i pasted a snippet of my code?
06:08:01 <srhb> martinr_: If it's more than one line, do it on lpaste.net
06:08:14 <martinr_> its an xmonad config by the way. one of the ways im getting familiar with haskell
06:08:17 <martinr_> srhb, ok
06:10:26 <lpaste> martinr_ pasted “terrible xmonad config” at http://lpaste.net/199568
06:10:49 <martinr_> srhb: ive deleted a lot of the irrelevant stuff
06:12:16 <srhb> martinr_: I think you could benefit from reading a little on do syntax and generally layout rules. let me just reformat togglevga a bit for you
06:12:50 <martinr_> srhb, you can probably tell from my use of curly braces i come from certain other languages
06:14:08 <srhb> martinr_: Yeah :-)
06:14:47 <srhb> martinr_: Something like this: http://lpaste.net/199568#a2829982255168880640 -- but notice that screenWidth is never used so far
06:16:26 <martinr_> srhb, thanks. :) what do you mean by screenWidth not being used so far?
06:16:42 <srhb> martinr_: I've taken the liberty of rewriting it to let ... in ...
06:16:58 <srhb> martinr_: In the first ... you're defining some names which you can then use in (and only in) the second ...
06:17:15 <srhb> martinr_: But note that you never refer to it again in the "in" section
06:17:39 <srhb> martinr_: So you're basically defining name and then never using it in the one place where it's in scope, effectively rendering it useless.
06:17:53 <srhb> a name*
06:20:05 <srhb> martinr_: What you want instead is for togglevga to actually return the result
06:20:26 <srhb> martinr_: The screenWidth I mean. So you can use it in main again :)
06:21:07 <srhb> martinr_: (Note, I think there's not enough separation of concerns here, but you're so close to a working solution, so let's just flesh it out for now)
06:22:02 <martinr_> srhb, yeah. dont give me the answer
06:22:06 <martinr_> ill get to it
06:22:09 <srhb> martinr_: Cool :)
06:29:48 <martinr_> srhb, so i put return screenWidth at the end of togglevga
06:30:10 <martinr_> and moved myStatusBar and myConkyBar to main
06:30:14 <martinr_> that should be fine?
06:30:26 <srhb> martinr_: Yes, this is one way. Be careful not to think of return as the return you'd see in imperative languages though.
06:30:53 <martinr_> srhb, why not?
06:31:35 <Cale> martinr_: Oh, and the reason you might have had trouble not using curly braces is that it seems your editor is putting physical tab characters into your source code. Pretty much everyone converts tabs to spaces in Haskell, because it matters how things line up vertically.
06:31:39 <srhb> martinr_: Because it's really nothing like the return of imperative languages, and extremely poorly named in Haskell, in an attempt to make do blocks actually seem like imperative programs (which worked to your advantage here) :-)
06:31:40 <martinr_> its completely different right?
06:31:50 <srhb> Yes, it is. :)
06:32:05 <Cale> return is a function such that  return v  is the action that does nothing except to produce v as its result
06:32:55 <Cale> So the name isn't inappropriate, but it also isn't a keyword and doesn't have any of the control effects that return has in most imperative languages (in the middle of a do-block, it's a no-op).
06:33:13 <martinr_> Cale, thanks. same Cale from ##math right?
06:33:16 <Cale> yeah
06:35:04 <athan> Is it possible to control all the input & output a process / terminal gets? For instance, sudo passwords?
06:35:55 <mrwdxcr> hello, newbie queston here: for example i got a type Env = Map Id Val; how can i get the Val parameter by knowing the Id ?
06:35:57 <Cale> athan: Yeah, it's possible to get Handles to its stdin/stdout/stderr
06:35:58 <athan> I'm looking at System.Process.createProcess, but it's just giving me some funny behaviour when I try it on some test commands
06:36:13 <horatiohb> I can't seem to import Prelude.catch into ghci, even though hoogle says it exists. Any idea why?
06:36:15 <athan> Cale: Okay cool that's what I thought, I must be invoking this wrong then
06:36:31 <athan> mrwdxcr: Data.Map.lookup :)
06:37:01 <athan> horatiohb: It might be a specific version of base, maybe? Though that rarely changes...
06:37:24 <Cale> horatiohb: The stuff in Prelude is imported by default, you don't need to do anything to import it
06:37:45 <Cale> ah, catch isn't in Prelude any longer, apparently
06:38:05 <Cale> (which is for the best, the old Prelude catch was less capable than Control.Exception's catch)
06:38:38 <srhb> mrwdxcr: There's a search engine called Hoogle which you can use to find functions when you know their type - which you do! Given a Map Id Val, how do I get Val from Id translates into the type `Map Id Val -> Id -> Maybe Val`. The Maybe arises because there might not be such an Id.
06:38:58 <Cale> I'm a little surprised that it was actually removed though -- that kind of change doesn't happen too often
06:39:18 <horatiohb> Cale: thanks for confirming. But then how should I catch calls to 'error'?
06:39:18 <mrwdxcr>  i have tried lookup and findWithDefault , but apparently "couldnt match type [char] with my Map Id Val
06:39:46 <mrwdxcr> hoogled first and read about the Data.Map
06:39:57 <martinr_> srhb, thanks for all the help. all good now
06:39:59 <Cale> horatiohb: *usually* you shouldn't catch calls to 'error', but if you really must, Control.Exception has catch as well as evaluate
06:40:07 <srhb> martinr_: Great! :-) And you're welcome.
06:40:07 <martinr_> out of interest, what was the other way to do it?
06:40:34 <bollu> srhb: what would you name "return"?
06:40:38 <Cale> horatiohb: You have to make sure that the evaluation of the 'error' happens during the execution of the IO action that you've applied catch to.
06:40:42 <srhb> martinr_: Oh, there are many ways to do it. What I was referring to specifically was just a vague dislike of having that function do too many seemingly unrelated things.
06:40:54 <srhb> bollu: pure is fine. Anything that doesn't conflate it with return of imperative languages.
06:41:10 <srhb> bollu: As Cale pointed out it's not that it's a bad name in isolation, it's just the cultural baggage. :)
06:41:15 <Cale> horatiohb: This is sufficiently fiddly that usually you would not attempt to do it -- most people treat 'error' as meaning "just kill the whole program, I've screwed up badly"
06:41:18 <martinr_> shrb ah ok :)
06:41:31 <martinr_> yeah i just did not want to mess with monitor detection more than once
06:41:42 <martinr_> probablu should have though
06:41:45 <martinr_> in hindisght
06:41:51 <martinr_> *hindsight
06:41:56 <srhb> martinr_: Well you can refactor later. :) You got something working, that's great!
06:42:14 <bollu> srhb: I wait for the day when the Haskell community gains more mindshare than C :P so people go to C and ask "what is this return and why is it not lifting my value? ;)
06:42:35 <horatiohb> Cale: I'm following most of what you're saying. But Statistics.Distribution.quantile throws an error if you pass it an argument that's outside the range [0,1]. This is not something I want to allow to crash my program. So how would you catch that error?
06:42:40 <martinr_> srhb, yep. feels good to get the first 'real' program I've done myself work fine
06:42:41 <srhb> bollu: Yes! And we'll be riding around on pegasi spewing rainbows forth to light our ways. :-)
06:42:48 <srhb> martinr_: I bet :-)
06:43:21 <bollu> srhb: :3 a man can dream
06:43:26 <srhb> bollu: :D
06:43:32 <Cale> horatiohb: crop the value to that interval beforehand, or make a safe wrapper around it that tests for that and produces a Maybe result
06:43:45 <zennist> does hsc2hs allow to import a typedef'd type?
06:43:54 <zennist> can't find info on this anywhere
06:43:57 <Cale> horatiohb: Or just grab the source code for statistics and fix it so that it doesn't call error :P
06:44:54 <horatiohb> Cale: thanks for the ideas. I would respectfully vote that library designers simply not throw error, especially in a computation that's not in the IO monad, but instead return Maybe(T) or Either(T).
06:45:13 <Cale> Yeah, it should probably produce a Maybe result here.
06:45:43 <jophish_> what library is this?
06:45:47 <Cale> Usually bos is pretty good about that kind of thing, but maybe there's some reason he didn't go with that
06:47:00 <Cale> jophish: statistics
06:51:16 <Cale> Actually, just clipping the value into range makes a certain amount of sense. Even for p in [0,1], there's not necessarily an x for which P(X <= x) = p
06:51:37 <Cale> So that's not really likely to be an accurate description of what the function actually is.
06:53:44 <Cale> It's likely either the supremum of x for which P(X<=x) <= p, or the infimum of x for which P(X<=x) >= p
06:58:18 <Cooler> are monads essential for side-effects?
07:00:43 <srhb> Cooler: Effects is probably a better wording than side effects, and no, one could model it in other ways. De facto in Haskell now, yes.
07:02:38 <Cooler> how do they do that? what about monads allow effects in lambda calculus?
07:03:18 <srhb> Cooler: It's not really that monads allow it, it's that it gives us a nice way to compose effects.
07:03:35 <srhb> Cooler: You don't ever need to touch a monad to print a string in Haskell, for instance.
07:05:19 <buglebudabey> srhb doesn't the IO monad make this possible
07:05:53 <srhb> buglebudabey: Make what possible?
07:06:20 <buglebudabey> to separate pure from impure, and allow a string to be printed
07:06:25 <srhb> buglebudabey: No.
07:06:36 <srhb> buglebudabey: putStrLn "foo" need not use any monadic machinery (return, bind)
07:06:57 <buglebudabey> but putStrLn :: IO()
07:07:59 <Cale> buglebudabey: It's really not the fact that IO is a *monad* which allows this, but rather the fact that we have a type of IO actions at all.
07:08:06 <srhb> buglebudabey: And that type could exist without the IO monad. Just as Maybe a can exist without the Maybe monad.
07:08:22 <srhb> buglebudabey: or [a] without having a list monad. :)
07:08:35 <buglebudabey> alright, makes sense
07:09:13 <srhb> It just happens that the IO monad is really practical for composing effects, and Maybe for composing failure, and [] for nondeterminism ...
07:10:14 <Cale> Yeah, we'd probably want something which allows a definition of return and (>>=), even if we didn't have those already.
07:11:04 <Cooler> earlier you mentioned composing effects, whats an effect though?
07:11:54 <Cale> Cooler: good question, there's no clear answer to what "effect" precisely means.
07:11:57 <srhb> Cooler: I'm don't feel comfortable actually trying to come up with a definition, but an effect is something like putStrLn "foo" or getLine
07:12:09 <srhb> Cooler: A _side_ effect is not possible in Haskell (barring unsafePerformIO)
07:12:29 <Cooler> haskell is just pure lambda calculus, yes?
07:12:42 <srhb> Cooler: In what sense? (No, I don't think so)
07:12:59 * hackagebot c2ats 0.1.0.1 - Translate C code into ATS  https://hackage.haskell.org/package/c2ats-0.1.0.1 (KiwamuOkabe)
07:13:08 <Cale> srhb: Well, careful -- when you say "in Haskell" there, you surely mean "in the evaluation of a Haskell expression"
07:13:14 * srhb nods
07:13:29 <srhb> Operational semantics are scary.
07:13:32 <srhb> :-)
07:13:38 <Cale> and yeah, I suppose that's meant to be implied by the word "side" in "side effect"
07:13:45 <Cale> But Cooler might not realise that :)
07:13:50 <Cooler> well thats how its presented in the book
07:13:50 <srhb> Yes, you're right.
07:13:52 <soLucien> on my windows machine im trying to to run cabal init, but it claims it cant find the ghc version, in the cabal config file i already set the ghc path..any ideas?
07:14:01 <Cooler> Haskell Programming from First Principles
07:14:21 <srhb> Cooler: I don't think they ever claim that "Haskell is just lambda calculus" -- do they?
07:14:46 <Cale> Cooler: I/O effects exist in Haskell more generally -- IO actions are values which describe arbitrary things that your computer is capable of doing.
07:14:57 <horatiohb> Cale: to be clear, the function in question is Statistics.Distribution.quantile, the inverse of the cumulative distribution function, and it seems to me that, being the integral of a prob. dist., this function must assume all values on (0, 1).
07:15:09 <Cale> Cooler: and *execution* of those IO actions is a separate process from evaluation of expressions, which carries out those descriptions.
07:15:29 <Cale> horatiohb: Probability distributions needn't be continuous.
07:15:42 <Cale> horatiohb: though maybe it's assuming they are
07:16:29 <horatiohb> Cale: true, but their integrals must be continuous, no?
07:16:46 <Cale> No, that's actually what I'm referring to
07:17:37 <horatiohb> ok, I'm confused, then.
07:17:42 <Cale> Consider the distribution which has 1/2 probability of being -1 and 1/2 probability of being 1, and no mass anywhere else.
07:17:57 <Cooler> srhb, check the paste
07:18:12 <Cale> So the integral of this distribution is 0, 1/2 or 1 depending on how many of the points in {-1,1} the interval you're integrating over contains.
07:18:13 <srhb> Cooler: Sorry, which paste?
07:18:20 <Cale> and can't take on any other values than those three
07:18:32 <buglebudabey> im getting this weird error while trying to stack build: Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.
07:18:33 <Cooler> http://lpaste.net/199694
07:18:41 <soLucien> how to set up cabal on windows properly, so it can find the ghc version and make cabal init works
07:19:15 <srhb> Cooler: I find that misleading, yes.
07:19:32 <horatiohb> Cale: yes, I assumed we were ruling out delta functions.
07:19:54 <vertebrate> Noob here.   Is there a better way to write:   duplicate (x:xs) = (x:[x]) ++ duplicate xs
07:19:55 <buglebudabey> why does my stack build depend on a xcode license agreement?
07:20:15 <Cooler> i mean it says in the book the purity of haskell is that its lambda calculus and nothing more
07:20:46 <Cooler> which i think is true if you only consider the evaluation of expressions
07:20:51 <srhb> Cooler: Yes, I see. And I find that statement misleading.
07:21:01 <Cale> Cooler: That's kind of a weird quote... we certainly do add some things, it's just that we don't add anything to the mechanism by which expressions are *evaluated*
07:21:07 <srhb> Cooler: (So I won't defend it :-P)
07:21:44 <Cale> Cooler: We certainly do add values which represent computations to be performed which the lambda calculus can't express, and we add mechanisms beyond expression evaluation (in particular, the execution of IO actions).
07:22:33 <pavonia> soLucien: I think you just have to make sure that both binaries (cabal and ghc) are in your PATH variable
07:22:40 <martinr_> srhb, i give up
07:22:49 <srhb> martinr_: :( what's up?
07:22:54 <martinr_> out of scope again
07:23:01 <martinr_> Even after return
07:23:08 <martinr_> Is it the type?
07:23:10 <srhb> martinr_: Remember how scoping works in let
07:23:41 <pavonia> Doesn't Hackage build documentation for candidate packages?
07:23:44 <martinr_> srhb, yes it only works after the in
07:23:46 <Cale> But it is certainly very nice to have this property that the evaluation of expressions is known not to carry out arbitrary IO effects, and is deterministic and repeatable.
07:23:55 <martinr_> But i mean i can't access it in main
07:24:17 <srhb> martinr_: Did you bind the value to a name?
07:24:20 <Cale> Cooler: (there are ways to break those rules, but they are used very sparingly, and only with great care)
07:24:26 <srhb> martinr_: as in screenWidth <- yourfunction
07:24:48 <martinr_> srhb, uh. no....
07:25:06 <srhb> martinr_: Remember the trivial example with a program that did username <- getLine; putStrLn username
07:25:21 <srhb> martinr_: functions don't suddenly cause values to appear in scope, ever.
07:25:21 <martinr_> Ah back to that again. Of course
07:25:43 <srhb> martinr_: (In this case it's a little more than that because it's an effect, but the same rule applies)
07:25:51 <Cale> martinr_: If you have an action whose type is something like IO String, it's important to realise that this is not very much like a String at all. It's like the difference between /bin/ls and a list of the files in your home directory
07:25:52 <Cooler> Cale, so the quote is wrong? i would think its correct because its talking about the purity
07:26:19 <srhb> Cooler: It's prose. I think it's at least slightly wrong or misleading.
07:26:20 <Cale> martinr_: When you write  v <- x  inside a do-block for IO, it means "execute the action x, and name its result v"
07:26:25 <srhb> Cooler: The intention is probably right.
07:26:59 <soLucien> thanks :)
07:27:02 <Cale> Cooler: It's not entirely wrong, it's just stated in a way which is easy to get an incorrect impression from
07:27:35 <Cooler> but isn't the reason haskell is pure that expression evaluation is pure lamda calculus?
07:27:39 <Cooler> lambda*
07:27:48 <Cale> Well, even that isn't *strictly* true
07:28:00 <Cale> Unless you stretch the definition of what lambda calculus is
07:28:09 <Cale> I suppose it is *a* lambda calculus
07:28:17 <ggole> Lambda calculus is just a calculus, it doesn't have anything like an order of evaluation
07:28:24 <Cale> data declarations sort of screw with the notion that it's some particular lambda calculus that we're using
07:28:37 <Cale> because they sort of let you extend the rules of that lambda calculus with new constructions
07:28:38 <martinr_> srhb, so i did screenWidth <- togglevga
07:28:53 <ggole> No, that's not true: data types can be understood as defunctionalised versions of their LC equivalents
07:29:11 <srhb> martinr_: Yes, that would bind the result of the togglevga action to the name screenWidth
07:29:38 <Cale> and then if you're thinking of something like the simply typed lambda calculus or System F or something
07:29:57 <Cale> Those lambda calculi have the property that they're strongly normalising: all programs terminate
07:30:08 <Cale> So Haskell breaks that in a number of ways
07:30:08 <martinr_> Aha! Now main has access to it
07:30:28 <srhb> martinr_: More correctly, it's in scope in (and only in) the enclosing do block)
07:30:30 <srhb> .
07:30:50 <martinr_> Well my main is one do block
07:30:53 <Cale> One: it has general recursion at the value level -- you can use let/in which is a thing often not present in other lambda calculi, to make recursive and mutually recursive local definitions
07:30:58 <srhb> martinr_: I'm just being a pedant. :-)
07:31:24 <ggole> Let is just sugar for application?
07:31:32 <Cale> It is not.
07:31:37 <Cale> For a couple of reasons
07:31:40 <martinr_> srhb, well you really should be in this situation :)
07:31:46 <Cale> One is that it allows recursion (and mutual recursion)
07:32:02 <Cale> another is that it lets you generalise types -- you can define things which are polymorphic
07:32:03 <ggole> That can be covered by allowing fix, which is definitely an LC term
07:32:04 <srhb> martinr_: But yeah, you can keep with that general rule. names do not just pop into existence ever. You bind them or they don't exist.
07:32:11 <srhb> (Well, or import them...)
07:32:13 <Cale> Whereas lambdas only have monomorphic arguments
07:32:29 <ggole> The calculus itself doesn't contain any notion of type.
07:32:32 <Cooler> but LC has recursion sort of us doesn't it?
07:32:32 <martinr_> srhb, learning experience right here
07:32:39 <Cale> ggole: Most lambda calculi do
07:32:52 <Cooler> (\x.xx)(\x.xx)
07:32:56 <Cale> System F, which is perhaps the closest to what Haskell's core is, does.
07:33:22 <Cale> Well, I shouldn't say "closest"
07:33:25 <martinr_> So how does type conversion work?
07:33:27 <ggole> And system F doesn't contain let.
07:33:30 <Cale> Other lambda calculi come closer
07:33:31 <martinr_> Just ::,?
07:33:35 <Cale> Right, it doesn't.
07:33:36 <martinr_> * ::
07:33:37 <srhb> martinr_: There is no type conversion
07:33:40 <ggole> (But GHC's version does, I know.)
07:33:53 <ggole> Because in system F let is just sugar for application.
07:34:09 <srhb> martinr_: You can have a function that takes one type of argument and gives you back a value of another type.
07:34:14 <Cale> Cooler: Untyped lambda calculus doesn't directly have recursion, but one can write a fixed point combinator which allows one to effectively obtain it.
07:34:19 <martinr_> But how do i concatenate a num [char] with a string?
07:34:33 <srhb> martinr_: a num [char] ?
07:34:44 <martinr_> Uh. That's what the euro
07:34:52 <martinr_> *error says
07:35:01 <Cale> > let f = reverse in (f [1,2,3], f "Hello")
07:35:03 <lambdabot>  ([3,2,1],"olleH")
07:35:05 <Cooler> so why is Haskell pure then?
07:35:08 <srhb> martinr_: You seem to have made a type error that implies that [Char] is a number.
07:35:09 <Clint> martinr_: did you try to concatenate a string with +
07:35:12 <Cale> > (\f -> (f [1,2,3], f "Hello")) reverse
07:35:14 <lambdabot>  error:
07:35:14 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
07:35:14 <lambdabot>      • In the expression: 1
07:35:17 <Cooler> pure in what sense?
07:35:20 <Cale> ^^ problem
07:35:34 <srhb> martinr_: [Char] is just String, and ++ takes any two [a] and concatenates them.
07:35:38 <srhb> :t (++)
07:35:39 <lambdabot> [a] -> [a] -> [a]
07:36:07 <martinr_> Cale. Yeah thats the error
07:36:38 <Cale> martinr_: Oh! Haha, I wasn't even referring to your case, that was another thread of discussion :)
07:36:45 <martinr_> Haha
07:37:10 <Cale> martinr_: That happens when you try to treat a number as a character or a string, or vice versa.
07:37:19 <Cale> martinr_: Num is a type class for numerical types
07:37:27 <Cale> and [Char] is not typically an instance of it
07:37:48 <martinr_> Cale, hence why i asked for type conversion
07:38:01 <srhb> martinr_: You're being misled by the type error I think.
07:38:06 <Cale> martinr_: If you have a number and want it to be a String, try show
07:38:30 <martinr_> Can i do screenwidth = "960" ?
07:38:39 <Cale> If you have a string, and want to parse it, you might try read, but often you'll want to handle the case of failure to parse, in which case you'll need to use reads or readMaybe
07:38:41 <srhb> martinr_: Yes, if you want it to be a String
07:38:54 <srhb> martinr_: (You do.)
07:39:01 <martinr_> Yeah i do
07:39:03 <Cooler> so why is Haskell pure then?
07:39:05 <Cooler> pure in what sense?
07:39:24 <srhb> martinr_: The reason the error is confusing is that it's saying this: "In order for your expression to have a valid type, String would need to be a number, but it isn't"
07:39:32 <martinr_> From what i can gather so far Cooler, it's pure confusion
07:39:34 <Cale> Cooler: Evaluation of expressions is deterministic and has no effect other than to produce a value which is the value of the expression.
07:39:47 <srhb> Er, Char, not String
07:39:50 <martinr_> srhb, got it
07:40:12 <srhb> martinr_: Specifically "be a number" -> have a Num instance
07:40:14 <martinr_> YES
07:40:22 <srhb> martinr_: Compiles? :-)
07:40:22 <martinr_> GET IN THERE
07:40:25 <Cale> Cooler: If you evaluate some expression multiple times, and the values of any free variables in it are the same, you will obtain the same result, always.
07:41:01 <martinr_> srhb, yes :)
07:41:05 <srhb> martinr_: Awesome. :)
07:41:06 <Cooler> and other functional languages like Scala are not pure?
07:41:11 <srhb> martinr_: Must be correct then, right? ;-)
07:41:43 <Cale> right -- in Scala, you can evaluate an expression many times and obtain different results every time, and it can cause arbitrary I/O while it's happening
07:42:14 <Cale> Cooler: This is extremely beneficial for understanding what programs mean, because you can understand how expressions evaluate in isolation, and know they will do the same in the real program.
07:42:47 <Cale> It's key to software reuse, because the less about the context in which something is running you need to understand in order to understand what it does, the more contexts in which you'll be able to apply it.
07:42:50 <Cooler> Cale, can you give an example? are you sure its just evaluation and not execution?
07:43:04 <martinr_> srhb and Cale, thank you so much for putting up with my questions
07:43:10 <srhb> martinr_: You're welcome. :)
07:43:13 <Cooler> Cale, an example in Scala i mean
07:43:21 <srhb> martinr_: Hope you stick around. :-)
07:43:29 <Cale> Cooler: Well, it means that a large portion of Haskell acts like mathematical expressions. If you see an expression like 5 + 5, you know for sure that it will behave the same way as 10
07:43:50 <Cale> Cooler: Oh, sure, anything involving generation of random numbers, or user input.
07:44:01 <ph88> hey guys, when i have two data structures is there a library that can show me the difference between the two ?
07:44:01 <srhb> is chrisdone around in some form?
07:44:10 <Cale> Cooler: Or disk or network access...
07:44:23 <martinr_> Years ago i was doing some java thing and had a question on some obscure irc and asked what to do. They said maybe you should learn java.
07:44:25 <martinr_> :/
07:44:29 <srhb> Or someone with admin contact to lpaste?
07:44:34 <Cale> Cooler: In Scala, evaluation of expressions can cause all that sort of stuff to happen.
07:44:35 <srhb> martinr_: Ouch...
07:44:40 <martinr_> I mean they weren't wrong
07:44:45 <soLucien> i managed to init the project with cabal, how am i supposed to start it now
07:44:46 <srhb> martinr_: Just not very nice. :-P
07:45:14 <Cale> Cooler: Scala doesn't really have a clear distinction between evaluation and execution.
07:45:16 <Cooler> Cale, well that not really evaluation but execution
07:45:27 <Cooler> sure
07:45:32 <martinr_> srhb: maybe haskell devs are just nicer :)
07:45:34 <srhb> martinr_: We have ups and downs in here, but in general I think it's a very good community that's mostly welcoming to newcomers. :)
07:45:45 <Cale> Cooler: The only mechanism of evaluation that Scala has is allowed to cause arbitrary effects to occur.
07:45:48 <ph88> ##c is the worst
07:46:15 <Cale> martinr_: Well, I think to a large extent that we remember what it's like trying to learn Haskell :)
07:46:46 <martinr_> srhb: yeah, i've always wanted to learn or even take a look at haskell. glad to know there's somewhere i can go for help and its not stackoverflow
07:47:17 <martinr_> cale, speaking of stackoverflow. ive probably seen your name there a few times. if im not mistaken
07:47:18 <srhb> martinr_: That's great. :) It's a lot of fun (but also at times frustrating) so the channel can be invaluable :)
07:47:19 <Cale> I still can't stand stackoverflow. I still blame it for killing our original wiki :(
07:47:35 <Cale> martinr_: If you have, it's an impostor.
07:47:41 <ph88> real world haskell wiki
07:47:44 <Cale> (and I'd be quite interested to know who)
07:47:49 <Cooler> Cale, seems like a really silly thing to leave out when making a functional language
07:47:59 <Cooler> a way to separate evaluation from execution
07:48:21 <martinr_> Cale: I might just be making it up in my head. Just that the nick seems familiar
07:48:25 <Cale> Cooler: Well, you have to understand that Haskell is taking a pretty different approach from most programming languages before it.
07:49:29 <Cale> Cooler: This distinction is pretty much singlehandedly responsible for Haskell's lack of popularity. Of course, it's so incredibly beneficial at the same time.
07:49:44 <Cale> But it makes the language very different to use initially.
07:50:01 <martinr_> Cale: you dont remember me saying or doing something slightly obstructive in ##math do you?
07:50:15 <Cale> I don't remember exactly what it was you said...
07:50:18 <Cooler> Cale, in Haskell that distinction is where exactly?
07:50:30 <martinr_> Cale, sorry. 'twas a late evening
07:50:40 <Cale> Cooler: I mean the distinction that evaluation of expressions is separate from execution of IO actions.
07:51:12 <Cale> Cooler: and that we have this type of IO actions that describe things to be done later, and evaluation doesn't cause those things so-described to occur
07:51:47 <soLucien> ho to start a cabal initialized project, every time i try (in ghc interactive mode) to :t something, its not in scope?
07:51:53 <ph88> are there any other libraries like this one?  https://hackage.haskell.org/package/gdiff-1.1
07:52:00 <alercah> soLucien: use stack and then do stack ghci
07:52:29 <Cooler> Cale, why wouldn't you do that when making Scala?
07:52:55 <Cale> Cooler: Because Scala's goal was to integrate very tightly with existing Java code on the JVM
07:53:34 <Cooler> or F#
07:53:34 <Cale> Cooler: and if you were to make that distinction, the interaction with Java code would have to be restricted to the execution of actions, rather than be allowed in the evaluation of expressions at all
07:53:54 <Cale> With F# it's similar, only .NET vs. Java
07:54:59 <Cale> Haskell just takes a very hard-line stance on the issue -- it both benefits immensely from it, and distances itself from the rest of what exists in the world.
07:55:14 <Cooler> Cale, i think Haskell's lack of popularity is down to not a great reason to switch over from tons of existing frameworks and code
07:55:45 <Cale> It's really just that learning Haskell is a sizeable time investment.
07:56:15 <Cale> As well as perhaps that Haskell programmers are not a simple commodity.
07:56:32 <Cooler> well also performance
07:56:45 <Cale> Performance was a big issue prior to about 2005 or so.
07:56:57 <Cale> But things improved *drastically* around then.
07:57:05 <ph88> how come ?
07:57:08 <Cale> With the efforts of people like Don Stewart
07:57:15 <Cale> ByteString showed up
07:58:08 <Cooler> Cale, i mean you can easily explode the memory usage with simple expressions
07:58:18 <Cale> Cooler: You can do that in most languages.
07:58:35 <Cooler> yes but in those languages its clearer
07:58:43 <Cale> I'm not sure I agree.
07:58:50 <soLucien> alercah: this is the command that i use to start "ghciCmd": "stack ghci --test --no-load --no-build"
07:59:29 <Cale> Dealing with space performance is tough no matter which language you're using.
08:00:16 <Cooler> "For instance, the innocuous looking expression foldl (+) 0 [1..10^8] requires gigabytes of memory to evaluate."
08:00:27 <Cale> Maybe it's more obvious that you're committing some sort of error if you have to write every malloc
08:00:37 <Cooler> yes
08:00:48 <Cale> But in a big program, it's hard to know where all the mallocs are and ensure that they all have frees, and that the frees happen in time.
08:01:30 <Cale> If it's any more difficult in Haskell, it's that Haskell simply lets you express more with fewer characters.
08:01:45 <Cale> So you can dig yourself a deeper ditch in a hurry :)
08:01:55 <ggole> There are bigger problems than forgetting to free, really
08:02:07 <Cale> also, that expression won't require so much memory if compiled with -O, try it
08:02:11 <ggole> Leaks don't bite as hard as use-after-free or UB
08:02:35 <alercah> soLucien: you passed --no-load
08:02:38 <Cale> ggole: For sure -- I'm ignoring all the ways in which explicit memory allocation is much harder to get right
08:02:41 <Cooler> Cale, i mean maybe so but none of that is clear upfront
08:03:17 <Cale> Cooler: Memory usage is not clear to beginner users of imperative languages either.
08:03:22 <codedmart> Does `omitNothingFields` do anything on FromJSON instance?
08:03:40 <soLucien> this were the defaults, after removing --no-load, still same :(
08:04:02 <Cale> It's just something that you get used to over a long period of using the language -- you get to know where the allocations are happening, and what is expensive, and you develop a sense of what to look for in code when there's a problem.
08:04:13 <Cooler> Cale, when you are constantly dealing with low level details, its harder to miss
08:04:44 <Cale> Haskell's partly-lazy expression evaluation isn't going to be something you're used to understanding performance problems in, when you arrive as a new Haskell user.
08:05:08 <Cale> (and we generally do a pretty miserable job of teaching it...)
08:05:45 <Cale> But eventually, it gets easier to spot the space leaks, and there are lots of tools for finding them in larger programs
08:06:56 <Cooler> Cale, i mean when you learn haskell you don't concern yourself with those details at all
08:07:11 <Cale> Cooler: Yeah, you have the freedom to completely ignore performance issues
08:07:26 <Cale> Until they finally catch up to you and you're forced to figure something out about them
08:07:33 <Cooler> yeah so even when you know haskell, you don't really know haskell
08:07:43 <Cale> Perhaps you could put it that way
08:08:29 <Cale> But that's a good thing too -- it's very useful that we can think about the meaning of programs separate from their performance characteristics
08:08:42 <Cale> What is optimisation after all?
08:09:02 <Cale> It's replacing a program with another one that means the same thing, but has better performance characteristics.
08:09:22 <Cooler> its easier to figure out and understand whats gonna cause a problem when you write the low level implementation yourself and can see the mallocs and access patterns
08:09:38 <Cale> If it's hard to say that two programs mean the same thing at all, it's harder to actually carry out optimisations (both as a user of the language, and as the compiler)
08:10:20 <cdk> are there no built-in Typeable instances for Proxy-like datatypes?
08:11:03 <Cale> cdk: Isn't Proxy itself an instance of Typeable?
08:11:41 <athan> This might be a silly question, but is there a pretty-printing aeson encode?
08:11:50 <athan> like one that adds newlines and block indents and stuff :)
08:12:02 <Cale> athan: That's not a silly question, but I don't know.
08:12:04 * athan is using json as a config file, like all the hipster trash
08:12:29 <cdk> ah, `typeOf (Proxy :: Proxy Int)` works but I need a typeable instance in scope for a value like `Proxy :: Typeable a => Proxy a`
08:12:31 <lyxia> @hackage aeson-pretty
08:12:31 <lambdabot> http://hackage.haskell.org/package/aeson-pretty
08:12:36 <Cale> athan: You might be able to do something janky like run a Javascript parser/prettyprinter over it
08:12:42 <cdk> > typeOf (Proxy :: Typeable a => Proxy a)
08:12:44 <lambdabot>  error:
08:12:44 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
08:12:44 <lambdabot>      • In the expression: typeOf (Proxy :: Typeable a => Proxy a)
08:12:56 <Cale> athan: That wouldn't strictly be correct, because the syntax of JSON isn't actually 100% compatible with the syntax of Javascript.
08:13:00 * hackagebot phoityne-vscode 0.0.9.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.9.0 (phoityne_hs)
08:13:16 <athan> lyxia: You're heroic :)
08:13:20 <Cooler> The beginning of this way about Monads
08:13:33 <Cooler> how do Monads compose effects?
08:13:34 <athan> Cale: Hah! That might be a way! thanks :)
08:14:02 <Cooler> in Haskell effects are just values of type IO a right?
08:14:20 <Cale> athan: If you want to put in the effort, there's libraries like http://hackage.haskell.org/package/wl-pprint
08:14:29 <Cale> which should make it pretty easy
08:14:41 <lyxia> cdk: only concrete types are Typeable
08:14:49 <lyxia> cdk: uh, monomorphic
08:15:11 <Cale> athan: I mean, to go directly from Value, rather than parsing the thing as JS
08:15:40 <Cale> Cooler: You could say that... sometimes when people say "effects" they mean something more general
08:15:57 <Cooler> thats why i said in haskell
08:16:06 <Cale> Cooler: Even in Haskell...
08:16:16 <Cooler> what do you mean?
08:16:22 <lyxia> cdk: you can wrap such a proxy in a custom datatype
08:16:27 <Cale> Cooler: Like, you might see people say things like "the list monad encodes the effects of nondeterminism"
08:16:48 <Cooler> not sure what you mean by that
08:16:57 <Cale> Let me provide an example...
08:17:03 <Cooler> the list monad has something to do with randomness?
08:17:22 <Cale> Not randomness, nondeterminism in the sense of nondeterministic automata -- having multiple results
08:17:34 <cdk> lyxia: how would that make a monomorphic value? I would still have something like `data MyType p = MyType (Proxy p)`
08:17:37 <lyxia> cdk: data PolyProxy = PolyProxy { unPolyProxy :: forall a. Typeable a => Proxy a }
08:17:41 <cdk> ah
08:17:45 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
08:17:47 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
08:18:02 <Cale> Here, "running" a list basically means to pick a value from it in all possible ways
08:18:20 <Cale> and the monad operations arrange to try them all
08:18:25 <JonReed> athan: If you want to pretty pretty print during development to see its structure, I would just encode it as json, and a js tool like: https://github.com/ddopson/underscore-cli 
08:18:46 <Cale> Is this an "effect"?
08:18:53 <Cale> Well, some people would use the word that way.
08:19:21 <Cooler> what? non determinism means having more than one value?
08:19:25 <Cale> yeah
08:19:31 <Cooler> ?
08:19:57 <Cale> Have you ever looked at the P vs. NP problem?
08:20:12 <Cooler> i thought non-determinism meant theres no way to model the system
08:20:13 <Cale> The nondeterministic Turing machines involved there are nondeterministic in this way
08:20:32 <Cale> They try all possible branches simultaneously.
08:21:52 <Cale> This is a very particular technical sense of nondeterminism which is common in computer science, but you may not have seen it before.
08:21:55 <martinr_> Cale, it was about the name ##maths by the way
08:22:10 <Cooler> i thought non-determinism meant in the sense of quantum systems where randomness is fundamental to the results
08:22:22 <Cale> martinr_: Oh, you were that guy, I had no problem with the suggestion, it's just... good luck getting everyone to move over :)
08:22:46 <Cale> Cooler: Sometimes it means that, but that's a different thing.
08:22:47 <martinr_> Haha. I wasnt being serious
08:23:20 <martinr_> But seriously uk > usa
08:23:23 <martinr_> ;)
08:23:26 <Cooler> "In computer science, a nondeterministic algorithm is an algorithm that, even for the same input, can exhibit different behaviors on different runs, as opposed to a deterministic algorithm. "
08:23:27 <Cale> Cooler: Well, you can sometimes regard that as the same sense, only you're thinking about what must be done in order to understand everything that could happen.
08:23:43 <Cale> Cooler: that's not the right sense
08:24:07 <Cale> https://en.wikipedia.org/wiki/Non-deterministic_Turing_machine
08:24:20 <Cale> In a deterministic Turing machine, the set of rules prescribes at most one action to be performed for any given situation. By contrast, a non-deterministic Turing machine (NTM) may have a set of rules that prescribes more than one action for a given situation. For example, a non-deterministic Turing machine may have both "If you are in state 2 and you see an 'A', change it to a 'B' and move left" and "If you are in 
08:24:20 <Cale> state 2 and you see an 'A', change it to a 'C' and move right" in its rule set.
08:24:58 <Cale> The idea being that it does *all* the things, effectively forking the universe.
08:25:19 <Cale> and if it accepts the string in some universe, then it accepts :)
08:25:47 <Cale> That's different from a probabilistic Turing machine
08:25:57 <Cale> which is a TM that has access to a source of randomness
08:26:30 <Cale> (and can be defined as a nondeterministic Turing machine that randomly chooses between the available possible transitions)
08:29:07 <Cale> This sense also shows up in https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton
08:29:42 <Cooler> what does all of this have to do with list?
08:30:02 <Cale> Well, these machines would be very easy to implement using the list monad operations :)
08:30:25 <Cale> Because when you went to look up what transition the machine would take in a given situation, you'd obtain a *list* of options
08:30:34 <Cale> and running that list would pick one, in all possible ways
08:30:47 <Cale> and you'd end up with a list of all the possible outcomes
08:31:38 <jmcarthur> If you look at the pseudo-imperative do notation for the list monad, x <- [1,2,3] means x could be 1, 2, or 3. From the point of view of the continuation, this is just nondeterminism.
08:31:43 <Cale> (of course, the time cost is exponentially worse than with a real nondetermistic Turing machine, but if we could do anything about that, well, a lot of the world's problems would be gone overnight)
08:32:22 <Cale> (Real nondeterministic Turing machines don't exist as far as we know)
08:32:44 <Cale> (as far as the time complexity they're supposed to obtain is concerned)
08:33:15 <Cooler> uh isn't that what a quantum computer is supposed to do?
08:33:29 <Cooler> evaluate all possible paths at once
08:35:14 <Cooler> what does this have to do with effects?
08:40:07 <agocorona> indeterminism can also be simulated with multithreading
08:46:01 <agocorona> in the transient monad  do x <- choose[1..100]; guard (x `rem` 2 ==0); liftIO $ print x 
08:46:47 <agocorona> with choose list = foldr (<|>) empty (async . return)  list
08:47:18 <athan> Anyone here know if there's a go-to hostname parser?
08:47:26 <athan> like how network-uri is nice for URIs I mean
08:47:35 <athan> I'm just looking for something to validate my text honestly :\
08:48:05 <agocorona> print the even numbers
08:49:41 <lyxia> @hackage hostname-validate
08:49:41 <lambdabot> http://hackage.haskell.org/package/hostname-validate
08:49:51 <lyxia> looks old but for just one function...
08:50:58 <athan> Thanks lyxia ><
08:55:13 <hoppfull> I took a look at the State monad and all I see is gibberish. No tutorial even explain what they are for. Could someone give me a primer on the state monad?
08:58:20 <traceroutelol> i've never used it
08:59:03 <agocorona> hoppfull:  it hides an additional parameter that is passed along
08:59:12 <traceroutelol> but i guess you specify a type of data as a parameter to the state monad
08:59:51 <hoppfull> agocorona: So it holds two values?
09:00:10 <agocorona> the return value and the state. yes
09:00:20 <agocorona> more or less
09:00:43 <hoppfull> agocorona: A tuple can hold two values.
09:01:13 <zipper> How can I write the conditional part of:
09:01:15 <zipper> `take 10 [y | x <- [0..], let y = x*3 where x *3 <= 50 ]`
09:01:26 <agocorona> yes. the state monad uses a tuple
09:01:34 <zipper> The let is messed up
09:02:16 <prohobo> yes
09:02:19 <prohobo> yes
09:02:20 <glguy> state values hold functions 
09:02:51 <hoppfull> glguy: But a function is a value so a tuple should be able to hold a function as well, right?
09:04:30 <biglambda> Does GHC8 allow currying type variables?
09:04:37 <lpaste> hoppfull pasted “tuple holding functions” at http://lpaste.net/199843
09:04:40 <glguy> Yeah, you can put functions in tuples, but that's not related to "state"
09:05:10 <hoppfull> glguy: "state"?
09:05:16 <glguy> The State type
09:05:27 <hoppfull> So we want a state type for its own sake?
09:05:29 <lyxia> biglambda: what do you mean?
09:05:39 <joe9> any recommendations for formatting haskell files in emacs: http://bpaste.net/show/125bac74bdf0 is what I use. But, it seems to be changing quite a bit. So, looking for something more stable.
09:06:02 <hoppfull> biglambda: They are already so you can partially apply type arguments to a type constructor.
09:06:16 <agocorona> hoppfull:  the state may hold wathever you want. the advantage is that you must not pass it manually
09:06:18 <glguy> The State type exists to bundle up a pattern of using functions with type: s -> (a,s)
09:06:42 <biglambda> Really I thought I can only partially apply data constructors
09:07:18 <glguy> biglambda: Currying type variables? Like you had a type with kind : (*,*)->* and you want a * -> * -> *?
09:07:33 <biglambda> Let me construct an example.
09:07:35 <biglambda> One sec
09:08:14 <EvanR> hmm, so the * level is a CCC
09:08:30 <EvanR> of its own
09:08:35 <agocorona> hoppfull:  whenever you need it, you get it with `get`  and change it with `put`
09:09:30 <hoppfull_> agocorona, glguy: I think the state monad is a solution without a problem right now. I'll just continue working without it and maybe I'll create a "state monad"-shaped hole in my mind eventually.
09:10:12 <hoppfull_> agocorona, glguy: Thanks for your patience, though!
09:10:37 <EvanR> State is usually not very useful on its own
09:10:56 <EvanR> its easier to just do s -> (a, s)
09:11:11 <EvanR> or really it doesnt come up very much, by itself
09:11:55 <hoppfull_> EvanR: thanks
09:13:01 * hackagebot hext 0.1.0.4 - a text classification library  https://hackage.haskell.org/package/hext-0.1.0.4 (aneksteind)
09:13:03 * hackagebot french-cards 0.1.0 - French Playing Cards  https://hackage.haskell.org/package/french-cards-0.1.0 (TarasSerduke)
09:13:05 * hackagebot timestamp-subprocess-lines 0.1.0.4 - Run a command and timestamp its stdout/stderr lines  https://hackage.haskell.org/package/timestamp-subprocess-lines-0.1.0.4 (EyalLotem)
09:13:38 <EvanR> for example if you were writing an IO heavy program which had a readonly context and "global" mutable variables, you could use IO-mutable memory cells (IORefs) which are part of the context. and the context is implemented with ReaderT not State
09:14:01 <EvanR> or you just pass the context around
09:14:26 <glguy> The State type is a useful building block; it's a simple type that supports various typeclass operations on a fundamental type. Just keep in mind that it doesn't exist as a recommendation for how to manage state in Haskell
09:14:36 <agocorona> hoppfull_: I like your pragmatism
09:14:51 <glguy> But in the case that it's what you need having that type around already saves some work
09:15:17 <biglambda> Here’s an example of what I mean: http://www.haskellpad.org/p/ayCxTREQlh
09:16:29 <Gurkenglas> Can factoring a common constructor out of all cases of a case statement anywhere ever make anything less defined than it was before?
09:16:37 <biglambda> I don’t think I can apply X to Y on the type level.
09:17:18 <biglambda> Gurkenglas: not sure what you mean?
09:17:34 <glguy> biglambda: You have to fully "saturate" X when you use it because it's a type synonym
09:18:07 <glguy> biglambda: type X u, so any time you use X you'll need to have applied it to something
09:18:22 <biglambda> giguy: I was just asking if I have to have saturated type synonyms in ghc8
09:18:34 <biglambda> Or forever.
09:18:35 <hoppfull_> agocorona: Thanks. It has served me well so far. : )
09:18:38 <glguy> You do
09:18:48 <biglambda> Forever?
09:19:00 <glguy> biglambda: You asked about currying which doesn't have to do with this
09:19:15 <biglambda> I see,
09:19:32 <biglambda> Not great at english.
09:20:41 <Gurkenglas> Could making the compiler replace "case x of A a -> Just a; B b -> Just b" with "Just $ case x of A a -> a; B b -> b" possibly produce newly infinite-looping code?
09:22:03 <EvanR> depends on what a and b are?
09:22:22 <Gurkenglas> Choose any a and b
09:23:17 * EvanR drills into remembering how case works wrt undefined
09:23:40 <EvanR> if x is undefined, then it would be wrong to get a Just
09:23:50 <Gurkenglas> Right, but this isn't less defined than before
09:23:57 <EvanR> it would be more defined
09:24:19 <Gurkenglas> And I'm asking whether this replacement can lead to anything anywhere being less defined than before
09:24:28 <EvanR> but it would be wrong because you would get a or b, not undefined
09:24:38 <Gurkenglas> You'd get Just undefined
09:24:52 <EvanR> oh i see, x is there in the second one
09:25:44 <EvanR> the optimization delaying undefines seems surprising to me as far as haskell goes
09:26:59 <Gurkenglas> I've got this feeling that we're only using least fixed points of recursive equations because that's what computers happen to give us an oracle for. We should instread strive to find the greatest lower bound of all maximal fixed points
09:28:12 <grantwu> wait, don't a and b have to be the same type
09:28:27 <EvanR> yes
09:29:21 <EvanR> Gurkenglas: well in this case its sort of moving the place where stuff gets evaluated, which is already annoying to track in haskell
09:29:23 <Gurkenglas> grantwu, that's not a problem. Imagine data X t = A t | B t, and my question remains
09:29:47 <grantwu> Gurkenglas: Yeah, just asking for my own understanding.
09:30:45 <EvanR> theres a big diff between undefined and Just undefined
09:30:57 <ggole> Optimisations should not change which fixpoint is found, surely
09:31:18 <EvanR> like in real life programming asking someone to be consistent about nil or empty array
09:31:32 <EvanR> despite them usually comparing as equal
09:31:38 <Gurkenglas> You don't even have to call it an optimization - my hunch is that when this changes something, the programmer made a mistake in the first place
09:32:05 <EvanR> the mistake is not manually factoring out the ctor?
09:32:11 <Gurkenglas> Which is why I'm asking whether there is any case where this change would make something less defined
09:33:14 <glguy> Gurkenglas: It's certainly not indicative of a programmer mistake. It's common to do that to increase strictness
09:33:24 <Gurkenglas> Factoring out the "ctor" (common term on the... left? dangit) should tend to be closer to what the programmer wanted to say
09:34:10 <ggole> You seem to be changing arguments between 'different' and 'less defined'.
09:34:12 <EvanR> not if it changes the semantics
09:34:18 <ericdwhite> Hi I was trying to use `read` to read a value that might be an int (e.g. port) or a string (e.g. hostname).  But `read` fails if the string is not quoted.
09:34:22 <ericdwhite> q. is this a terrible idea?
09:34:26 <ericdwhite> instance DS.IsString Int where
09:34:26 <ericdwhite>     fromString x = read x :: Int
09:34:26 <ericdwhite>       
09:34:35 <EvanR> yes its terrible
09:34:43 <ericdwhite> I thought so
09:34:58 <Gurkenglas> Where'd I say different :I
09:35:37 <ggole> "my hunch is that when this changes something, the programmer made a mistake in the first place"
09:36:13 <ggole> Although I suppose that you meant "when this makes something less defined"
09:36:27 <Gurkenglas> *more defined
09:36:28 <EvanR> ericdwhite: you can readMay to try to get a number, otherwise take it as it is (even if its an invalid hostname string)
09:36:43 <EvanR> for something more robust use a parser
09:36:57 <ggole> But it does make some programs more defined, eg, isJust (Just undefined) is more defined than isJust undefined
09:37:10 <Gurkenglas> I want to know if this could make something less defined :D
09:37:20 <ggole> I think we're talking past each other a bit here.
09:37:32 <EvanR> i dont see how it could be less defined
09:37:32 <ericdwhite> I was trying that, I will give it another go. thx
09:38:39 <Gurkenglas> <ggole> "my hunch is that when this changes something, the programmer made a mistake in the first place" <- I said that because I expect this change to only make everything more defined, but I'm not sure (asking whether it makes anything less defined is what started this conversation), so I just went with it changing something
09:39:25 <EvanR> in haskell at least, if they knew what they were doing, they did it that way because they didnt want it to act the other way
09:39:41 <EvanR> they wanted it to evaluate x at that point, not later
09:40:07 <Gurkenglas> All functions we can define in Haskell are monotonous, right? And any place where this change of the case term towards higher definedness would allow us to make something else less defined would then allow us to write a non-monotonous function
09:41:14 <Gurkenglas> EvanR, I'm mostly thinking about doing this "optimization"/lint after inlining, where it is unlikely that authors even noticed the ctor
09:42:05 <EvanR> one practical thing i can think of with not asking them to factor this way, is if i had 3 of the same ctors in the bodies, then leaving them there lets me more easily change one of them
09:42:20 <EvanR> for example if i made a mistake choosing them to be all the same
09:42:26 <Gurkenglas> ...okay what's a ctor
09:42:29 <EvanR> Just
09:42:45 <EvanR> or were you asking if you could factor out any f in term f a
09:43:33 <Gurkenglas> Actually sure why not, I was thinking about constructors like Just and (:) but would this work for any term?
09:43:50 <Gurkenglas> I guess anything except seq? ^^
09:44:01 <EvanR> why not seq?
09:44:15 <EvanR> its already messing up the evaluation order
09:44:40 <EvanR> in the case of f x, if f is undefined, it makes things less undefined
09:44:44 <EvanR> er
09:44:46 <EvanR> less defined
09:45:22 <EvanR> basically the compiler cant in general know which things are undefined, so arbitrarily swapping stuff changes what happens
09:45:38 <Gurkenglas> Is "undefined x" even differently defined than "undefined"?
09:46:16 <EvanR> it is if you do case y of A z -> f z
09:46:39 <EvanR> maybe not
09:46:49 <Gurkenglas> Is "undefined (case y of A z -> z)" even differently defined than "case y of A z -> undefined z"
09:47:17 <EvanR> what about case y of A z -> undefined z; B -> 5
09:47:30 <Gurkenglas> Then there's not common term on the left
09:47:47 <Gurkenglas> -not+no
09:48:37 <EvanR> what about case y of A z -> (y,) z; B -> (y,) 5
09:49:20 <EvanR> another example of more defined
09:49:37 <dmwit> ?remember Gurkenglas All functions we can define in Haskell are monotonous, right?
09:49:37 <lambdabot> Done.
09:49:51 <EvanR> to get back to a real function
09:50:06 <EvanR> case y of A z -> y z; B -> y 5
09:50:23 <dmwit> ?quote Cale logic
09:50:23 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
09:51:08 <EvanR> thats reaching
09:51:51 <Gurkenglas> Can't unify (\t -> A t | B t) with (Num a => a -> C)
09:52:21 <EvanR> drat
09:52:40 <EvanR> case y of _ -> y 5
09:52:56 <EvanR> y (case y of _ -> 5)
09:53:44 <Gurkenglas> Would all Haskell functions being monotonous suffice for this change never making anything, even anywhere else, less defined?
09:55:12 <Gurkenglas> That last example should have equal definedness before and after
09:55:28 <EvanR> monotonic? meaning if x < y then f x < f y
09:55:33 <EvanR> er, <=
09:55:41 <Gurkenglas> < being the definedness relation
09:56:13 <EvanR> the last example i vaguely remember getting messed up due to strictness annotations
09:56:44 <EvanR> maybe not, since it has to be a function
09:58:03 <Cale> EvanR: You think so? I think it's actually pretty true.
09:59:21 <EvanR> what about case y of !x -> y 5
09:59:37 <Cale> Oh, I thought you were replying to my comment that dmwit linked to :)
09:59:47 <EvanR> yeah i was
10:00:22 <EvanR> its a reach to say anyone is proving anything in an inconsistent logic
10:00:28 <Cale> The thing that functional programmers do in their heads is very structurally similar to the thing that mathematicians and logicians are doing -- even at the large scale of software engineering, the same concerns are tackled (with different sensibilities and somewhat different goals)
10:00:32 <EvanR> its like the falsum site
10:00:59 <Gurkenglas> "case y of !x -> y 5" and "y (case y of !x -> 5)" should also be equal
10:01:02 <Cale> Well, functional programmers care in a finer way about *which* proof they are providing
10:01:03 <EvanR> or the "anything can be anythinged" school
10:01:13 <Cale> So the inconsistency of the logic doesn't bother us nearly so much.
10:01:56 <dmwit> EvanR: Saying the logic is inconsistent is insult enough. You don't need to strip away the "proof" status of its proof objects to add injury to insult.
10:01:57 <Cale> Everything in our logic is "true", but it's true for a variety of reasons, and we care about which reason we're giving.
10:02:00 <EvanR> the results of functional programming, your quote and subsequent defense would have us believe have some well definedness without stating what the well definition is
10:02:49 <Cale> Apart from those differences, the actual process that goes on in people's heads is pretty similar
10:03:08 <EvanR> but i have been suffering from curry-howard-itis
10:03:20 <EvanR> almost everything in the world is not a type or a term of some type
10:03:24 <EvanR> is now*
10:03:40 <EvanR> im pretty sure im having a mental breakdown, not an epiphany
10:04:33 <Gurkenglas> Can you tell ghc to start inlining extremely (so I can find cases that surprisingly have a common term on the left?)
10:10:06 <orion> In Data.Vector.Unboxed, are in-place mutations only performed by functions labeled "unsafe"?
10:10:57 <orion> erm, the author uses "unsafe" to refer to bounds checking it seems.
10:11:36 <EvanR> they dont even mutate in place
10:11:41 <EvanR> right
10:12:19 <EvanR> check out Data.Vector.Unboxed.Mutable
10:12:33 <EvanR> hint see the type IOVector
10:15:47 <MarcelineVQ> Gurkenglas: check out -funfolding-* pragmas here for anything relevant to your needs https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#options-f
10:16:26 <MarcelineVQ> particularily -funfolding-use-threshold
10:17:12 <cocreature> orion: mutation is not unsafe because you have to do it in IO or ST
10:19:15 <cocreature> at least not unsafe in the sense that e.g. unsafePerformIO is unsafe and can break referential transparency
10:19:26 <shane`> Pipes and Conduit both have support for Attoparsec. Is there any way to convert a parsec parser to a pipes or conduit one?
10:20:46 <MarcelineVQ> Gurkenglas: relevant to {-# INLINE _#-} "The major effect of an INLINE pragma is to declare a function’s “cost” to be very low. The normal unfolding machinery will then be very keen to inline it." a higher -funfolding-use-threshold and -funfolding-creation-threshold should be similar to having INLINE on everything, and higher than that may do what you're after
10:23:21 <cocreature> shane`: parsec doesn’t provide an interface for incremental parsing (at least the last time I checked) so that’s not really possible
10:23:49 <cocreature> shane`: I think megaparsec which aims to be an improved version of parsec does support incremental parsing so it would be possible to build such a thing but it looks like no one has done that so far
10:24:24 <cocreature> hm no I think the info it provides for incremental parsing is not enough
10:25:06 <shane`> cocreature: thanks, but will using parsec's attoparsec support ensure that the parsing will use constant space?
10:25:39 <orion> Thank you cocreature, EvanR.
10:25:59 <shane`> cocreature: sorry if the question is naive, I am inexperienced with Pipes and Conduits and only have a cursory understanding as yet
10:34:44 <joe9> I am using Data.Vector.Storable to transfer data to a C FFI. When I run the memory profile, I see a lot of pinned data (I suspect that it is because of using Data.Vector.Storable) http://imgur.com/a/lkPN9 . Is my suspicion correct?
10:35:20 <joe9> https://github.com/joe9/baby-steps-to-building-a-realtime-chart-with-haskell/blob/master/app/Step026OpenGL.hs is my source code.
10:35:23 <cocreature> shane`: not sure what you are referring to by parsec’s attoparsec support
10:35:25 <joe9> any help, please?
10:36:42 <shane`> cocreature: I mean this https://hackage.haskell.org/package/pipes-attoparsec
10:38:19 <Jello_Raptor> Is there some good way to express the following property with haskell types? there's a function over some set of parameters, so that if any parameter p is replaced with a value p' such that `p' <= p`, then "f(...,p',...) <= f(...,p,...)"? 
10:39:26 <joe9> I read that pinned memory is not managed by the GC. Does that mean that the memory ends up being a space leak? How is the pinned memory of the Vector.Storable free'ed?
10:39:35 <Jello_Raptor> I don't need to be able to derive that the property is true, I can tag functions for which it's true, but some way of making sure that I only use such functions in specific places would be nice
10:39:52 <cocreature> shane`: oh pipes attoparsec support. well it depends on what you consider constant. if the size of a single parser result is constant and you are not doing any intermediate stuff that is unbounded and you are consuming each element independently it should run in constant space
10:41:27 <cocreature> joe9: that’s not quite true (afaik). pinned objects are in big blocks and won’t be moved by the gc and the gc will not partially deallocate such a block. once there are no more references to such a block however it will be freed
10:41:34 <Jello_Raptor> Ideally with a minimum of wrapping and unwrapping, and even better if it can also tell whether a function is order inverting (if any parameter p is replaced with a value p' such that `p' <= p`, then "f(...,p',...) >= f(...,p,...)")
10:42:17 <kadoban> Jello_Raptor: I mean you could make a Monotonic wrapper around a function and then take that as a parameter, if you consider that good enough tagging.
10:42:24 <kadoban> If that's even the right word
10:43:25 <joe9> cocreature: would this memory usage worry you? http://imgur.com/a/lkPN9
10:43:37 <joe9> cocreature: ok, Thanks. That makes sense.
10:43:55 <hsk3> Why isn't this working, to get an env var into a program?
10:43:56 <hsk3> BOOM="lol"; stack exec my-app ...
10:44:06 <cocreature> joe9: unless you are running on embedded I wouldn’t worry about anything less than 10mb or even 100mb
10:44:14 <ongy> Jello_Raptor: I think Proxy could also do something like that,but I have no experience using it
10:44:25 <Jello_Raptor> kadoban: it's the best I have at the moment, but that's well above my threshold for "too much wrapping and unwrapping". I'd rather just put explicit contracts in the docs for relevant functions.
10:44:39 <shane`> cocreature: Thanks! 
10:45:29 <glguy> hsk3: because of the ;
10:45:30 <Jello_Raptor> ongy: huh, let me see if that's reasonable
10:45:52 <joe9> cocreature: ok, Thanks. good to know. This is the Application Profiling Report:  https://gist.github.com/d4e1dd10fa7dd25c642da0be524695d0 . just want to check if you have any thoughts on it.
10:45:55 <cocreature> joe9: your memory usage is slightly increasing but that seems to mostly be caused by addAnotherUpdateData, whether that’s intentional or a leak I can’t tell
10:45:57 <hsk3> glguy: thanks mate
10:45:59 <hsk3> works now
10:46:33 <joe9> cocreature: yes, I am adding a line of data each second.
10:46:33 <khumba> hsk3: Alternatively: export BOOM="lol"; stack exec my-app ...
10:46:41 <kadoban> Jello_Raptor: Putting stuff in the docs is likely what I'd do. If it's possible to do a slower version that checks that it's true or coerces it to be true, you could call the fast versions "unsafe" also.
10:47:15 <cocreature> joe9: looks like your program is io bound (at least that’s what I recall high idle numbers mean) so putting optimization in your cpu time is probably not going to pay off
10:48:39 <Jello_Raptor> kadoban: I really just want some basic checks against my own stupidity, ideally ones that won't bit me at runtime 
10:49:05 <joe9> cocreature: ok, Thanks. it is an OpenGL window.
10:49:26 <cocreature> I guess all the drawing counts as idle
10:49:36 <EvanR> pinned memory is not moved by the gc
10:49:38 <kadoban> Jello_Raptor: Ya, I mean that's kind of what the wrapper does, though if that's too much wrapping for you, I dunno what could be done. Maybe something with an extension or something I'm not thinking of.
10:49:45 <EvanR> im so far behind
10:50:15 <cocreature> joe9: btw I saw in the backlog that you claimed nanovg is closed source? that’s not the case, you can find it here https://github.com/memononen/nanovg and the haskell bindings (which I wrote so I’m biased :)) here https://github.com/cocreature/nanovg-hs
10:50:37 <joe9> cocreature:  Thanks a lot . will check it out.
10:51:47 <EvanR> Jello_Raptor: you can probably express that for a function of 1 variable using type classes, but i dont really know how to express it for f(...,p,...), unless you want to do functions of a heterolist
10:52:25 <EvanR> either way its going to be somewhat hellish to do in haskell
10:52:49 <ongy> I thought about having 'f :: a'
10:53:12 <ongy> as 'f :: Proxy MyType -> a', which would be a bit of a hassle
10:55:48 <joe9> cocreature: https://github.com/joe9/baby-steps-to-building-a-realtime-chart-with-haskell is my project. Started with diagrams and then direct rendering using cairo, gloss and ended up with OpenGL.
10:56:01 <joe9> cocreature: with diagrams, it maxed out around 1000 points
10:56:30 <joe9> cocreature: with cairo and gloss, 10,000 points took 16 seconds
10:56:31 <EvanR> i hate to say it, but ghcjs might be the best way
10:56:43 <cocreature> joe9: nanovg is opengl3 so you should get about equal speed (maybe even better if your not an opengl whizard (I am definitely not))
10:56:49 <joe9> cocreature: with OpenGL, 100,000 points took around 300 ms
10:57:15 <EvanR> what kind of chart has 100000 points on it?
10:57:23 <joe9> cocreature: I was doing this with d3.js initially and around 1000 points is when it started choking up.
10:57:35 <joe9> EvanR: Just testing to find limits.
10:58:05 <cocreature> tbh if you have that many points you should probably just filter them appropriately for your zoomlevel before you draw them
10:58:09 <joe9> cocreature: will check out nanovg. The pics look pretty cool though.
10:58:27 <EvanR> from a UX perspective you probably dont want that much data at once
10:58:58 <EvanR> processed into a form that can be realistically rendered looking nice, yeah
11:03:00 <joe9> cocreature: this is my OpenGL 3 stuff https://github.com/joe9/baby-steps-to-building-a-realtime-chart-with-haskell/blob/master/app/OpenGLStuff.hs
11:08:53 <ashishnegi> hi.. what is the servant stable version ? i am working on 0.7 and seems to not able to get `Servent.API.Get` ??
11:10:34 <Cale> EvanR: I once plotted a graph of the first million values of the arithmetic derivative...
11:10:44 <Cale> I don't think I still have it, I should do it again :)
11:11:55 <geekosaur> ashishnegi, hackage has 0.8.1 as current
11:12:18 <joe9>   cocreature: I like how with nanovg you can save the rendering context.
11:12:24 <joe9> cocreature: pretty cool.
11:12:52 <EvanR> Cale: right... but thats not real time
11:13:03 <ashishnegi> yes.. but i can not find any tutorial about that version.. Online docs show release of 0.5.* http://haskell-servant.github.io/blog.html and all other documentation seems to be of 0.4.*
11:13:04 * hackagebot x86-64bit 0.3.1 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.3.1 (PeterDivianszky)
11:13:15 <ashishnegi> joe9: ^^
11:13:24 <geekosaur> but, I see no Servant.API.Get in the documentation. (on the other hand, hayoo finds Servant.API.Get but produces a dead link)
11:15:25 <Cale> EvanR: fair enough :)
11:15:53 <geekosaur> ...I don't see it in the github repo either
11:16:08 <EvanR> time dependent number theoretic facts
11:16:19 <EvanR> would be cool
11:17:02 <ashishnegi> geekosaur: changes in 0.5 says they changed the API.. http://haskell-servant.github.io/posts/2016-03-19-servant-0.5-release.html  no talk about 0.6-8.. Is it ok that i use 0.4.* ? or that would be old stuff ? i actually just need few apis.
11:17:41 <geekosaur> yeh. just found it in 0.4.4.7
11:18:26 <geekosaur> clearly it will be "old stuff", the question is whether it's compatible with everything else you need.
11:18:42 <geekosaur> in any case you should make sure you're working in some kind of sandbox (cabal or stack)
11:20:32 <ashishnegi> geekosaur:  i am using `stack`.. it fetched 0.7.* for me and tutorials are not working.. :(
11:21:10 <geekosaur> you will need to find a resolver that has the 0.4 version, or possibly disable use of a stackage-based resolver
11:22:58 <ashishnegi> geekosaur: uh.. not good for me. :(
11:23:30 <kadoban> Oh hey, there's an LTS with GHC 8 now, interesting.
11:24:44 <orion> Is there a reason Complex isn't an instance of Num?
11:25:19 <geekosaur> you may well be better off using a cabal sandbox instead of stack, if you don't want to hunt down a resolver that includes an older version of servant
11:26:04 <kadoban> lts-5 has servant-0.4.4.7
11:26:18 <geekosaur> orion, ghci 7.10.3 tells me instance RealFloat a => Num (Complex a)
11:26:20 <kadoban> lts-5.18 is the last of that
11:26:45 <joe9> https://hackage.haskell.org/package/FontyFruity the modules are not hyperlinked
11:27:01 <geekosaur> the doc builder is kinda infamously behind/off
11:27:27 <geekosaur> might comment in #hackage and see if someone can kick it, or ask the maintainer to upload docs manually
11:27:30 <orion> geekosaur: Oh, indeed. My mistake.
11:29:21 <tsahyt> is there a stack template that doesn't automatically create a library and an executable but just an executable?
11:30:40 <tsahyt> ah, simple does that
11:31:03 <kadoban> tsahyt: You know you can make your own templates, right? You can just modify one you otherwise like. You can also set the default template to your own custom one very easily.
11:31:15 <kadoban> (the format is really easy too)
11:31:31 <ashishnegi> geekosaur: docs are there for 0.8.1.. if i understood you correctly.. but it the servant.github.io that looks old.. i am currently reading 0.7.1 docs and working accordingly..
11:31:32 <joe9> cocreature: nanovg seems to be the next generation (modern OpenGL) gloss. I loved gloss. It was so much simpler to use than using cairo directly.
11:31:38 * jonored herps, derps, notices finally that nix has more support for lambdabot than just the haskell packages, and chucks his entire checkout of lambdabot.
11:31:47 <tsahyt> kadoban: Sure, but why make my own when a premade one does just fine?
11:31:50 <ongy> would it be reasonable to add an option to cabal to build documentation locally for all installed packages?
11:32:13 <glguy> ongy: You can already tell cabal to build documentation by default
11:32:17 <kadoban> tsahyt: Just pointing it out because it's not commonly known. (and IMO very useful)
11:32:21 <ongy> uhh, I can?
11:32:32 <ongy> "man: can't open /usr/share/man/man1/cabal.1.gz: Permission denied" whoops
11:32:44 <tsahyt> kadoban: I might make one that just sets up enough to run a repl and pull in a package that I want to play with
11:32:47 <glguy> ongy: ~/.cabal/config ; documentation: True
11:32:56 <geekosaur> it's hard to build docs after the fact though (thanks ghc) --- might need to rebuild them in a sandbox,  or use stack or cabal 1.24+ new-build
11:33:24 <kadoban> tsahyt: stack ghci --package whatever
11:33:40 <ongy> thx
11:33:57 <tsahyt> kadoban: does that automatically install the package?
11:34:11 <ongy> geekosaur: is there a way to just rebuild world?
11:35:02 <kadoban> tsahyt: It automatically builds it for you if it's needed, yeah. It's to be used outside of a package. It won't like modify the .cabal file you're working with currently to add that dependency or anything (so if you have a .cabal file, it's probably not what you want)
11:35:10 <geekosaur> if only it were "just"
11:35:22 <tsahyt> kadoban: that's just what I need sometimes then. thanks!
11:35:30 <kadoban> Anytime
11:35:34 <ongy> :) rebuilding base could also be interesting
11:36:05 <geekosaur> cabal install --reinstall world --enable-documentation # I VERY STRONGLY suggest a sandbox for this
11:36:22 <hsk3> How do I make sure that Snap serves routes ending with ".txt" as a static file?
11:37:50 <ashishnegi> hi.. what is the ' (single quote) before POST in `Verb 'POST 204 contentTypes a ` .. ? what does that mean ?
11:38:01 <ongy> wouldn't doing this in a sandbox separate world docu from newly installed?
11:38:05 <glguy> ashishnegi: It's part of the syntax of the DataKinds extension
11:39:11 <geekosaur> it's a data value elevated to type level
11:39:50 <geekosaur> type constructors get elevated to kinds, their data constructors get elevated to types
11:51:16 <murt_> yo im a beginner can anyone help me with a simple problem
11:51:56 <arianvp> sure
11:52:18 <suzu_> murt_: sure
11:52:24 <orion> murt_: sure
11:52:32 <suzu_> all aboard the "sure" train!
11:53:10 <murt_> ok here goes
11:53:15 <murt_> intadd :: (Num a) => a -> Integer
11:53:18 <murt_> intadd n = (n + 2) :: Integer
11:53:21 <murt_> whats wrong here
11:53:33 <suzu_> well, what does the compiler say?
11:53:34 <murt_> or can someone explain what exactly the :: operator does in the second line
11:53:41 <murt_> Couldn't match expected type `Integer' with actual type `a'
11:53:53 <suzu_> what else does it say?
11:53:59 <murt_> `a' is a rigid type variable bound by the type signature for: intadd :: forall a. Num a => a -> Integer
11:54:20 <suzu_> is that all?
11:54:32 <ongy> murt_: It tells the compiler that (n + 2) should be Integer. In this context it's redundant, since it can infere it from the function type
11:54:36 <suzu_> it should tell you the location of the error too
11:54:44 <murt_> yeah theres more
11:54:51 <geekosaur> murt_, what's wrong there is that a type signature is a contract between your function and all callers.. and it promises callers that it can be handed any type that is an instance of Num and will produce a new value of that same type
11:54:53 <Cale> murt_: The problem is that n+2 is a value of type a, but you are claiming that it is an Integer
11:55:12 <geekosaur> then the :: Integer in the body asserts that it must be Integer, not the caller-specified type
11:55:23 <geekosaur> (it is an assertion, not an operator)
11:55:25 <Cale> You probably wanted to apply fromIntegral
11:55:38 <murt_> is n+2 a polymorphic constant
11:55:44 <geekosaur> (in particular, it is *not* a C/Java style typecast)
11:55:53 <ongy> :t \n -> n + 2
11:55:55 <lambdabot> Num a => a -> a
11:56:02 <Cale> n+2 is polymorphic, yes
11:56:20 <Cale> Well, it's monomorphic inside the body of the function, it's just of some type which you don't get to choose
11:56:28 <murt_> right that makes sense, i thought it was a casting operator since doing 2 :: Float returns 2.0 in ghci
11:56:37 <orion> Is it possible to write a function which takes any Num as input and outputs a Complex Double?
11:56:37 <geekosaur> oh, I didn;t look closely at the declaration, you do promise Integer. but you are operating on the caller provided n which is not Integer
11:56:40 <murt_> so i cant force it to be returned as an integer
11:56:42 <Cale> Numeric literals are also polymorphic
11:56:44 <geekosaur> so you must convert with fromIntegral
11:56:58 <david-md> can anyone recommend a good source for learning about type level programming. I sort of get it a bit and have used it, but it'd be nice to have a fuller understanding
11:57:12 <Cale> When you specify a type for them, they can become whatever type it is that you wanted them to be, but you only get to do that once.
11:57:43 <geekosaur> Haskell does not do automatic type promotion like some other languages do; you must convert explicitly. Numeric literals are polymorphic so you don't have to convert every literal to an appropriate type
11:57:46 <murt_> wait so in my signature ive stated that the function accepts any Num and returns an Integer, yes? so is it possible to force the function to convert n+2 into an Integer?
11:57:58 <geekosaur> you've been told how to at least twice so far
11:58:00 <Cale> :t fromIntegral
11:58:01 <lambdabot> (Num b, Integral a) => a -> b
11:58:09 <Cale> You'll need an Integral constraint
11:58:15 <murt_> sure
11:58:16 <murt_> thanks
11:58:29 <murt_> intadd :: (Num a, Integral b) => a -> b
11:58:31 <murt_> ?
11:58:58 <Cale> That'd work, if you like
11:59:08 <ongy> I think it's the wrong way around
11:59:14 <Cale> er, right
11:59:15 <Cale> it is
11:59:18 <murt_> i still get the compile error where it says n+2 is of type a (Num) not b (Integral)
11:59:27 <Cale> It's the input type that needs to be Integral
11:59:32 <Cale> and the output can be any Num
11:59:39 <murt_> no no i want the output to be integral
11:59:45 <murt_> or is that not a thing thats important
11:59:47 <Cale> However, you might also just want  intadd :: Num a => a -> a
11:59:53 <ongy> Integer, or Integral? Those are different things
12:00:04 <murt_> ok let me explain what i wanted
12:00:19 <geekosaur> murt_, fromIntegral promises it can produce any instance of Num. that includes the instance you need here, which is Integer
12:00:22 <Cale> murt_: In order to convert from some other numeric type, to Integer, you need that other numeric type to be Integral
12:00:39 <geekosaur> but you have to constrain the input value to be an instance of Integral, not an instance of Num
12:01:01 <murt_> what if i want the output to be an Integer and not polymorphic
12:01:04 <Cale> Otherwise, what is it supposed to do when you give it some complex number, or a polynomial or something
12:01:20 <Cale> You can't convert just any sort of numbers to integers
12:01:33 <Cale> But you can convert any instance of Integral to Integer
12:01:33 <murt_> lets say its Integral
12:01:37 <geekosaur> > fromIntegral 3 :: Integer
12:01:39 <lambdabot>  3
12:01:52 <Cale> > fromIntegral (3 :: Int) :: Integer
12:01:54 <geekosaur> on the *caller* side it does what you want
12:01:55 <lambdabot>  3
12:02:02 <Cale> > fromIntegral (3 :: Word8) :: Integer
12:02:05 <lambdabot>  3
12:02:30 <Cale> > fromIntegral (3 :: Double) :: Integer -- won't work
12:02:32 <lambdabot>  error:
12:02:32 <lambdabot>      • No instance for (Integral Double)
12:02:32 <lambdabot>          arising from a use of ‘fromIntegral’
12:02:47 <murt_> is 3 :: Double a casting?
12:02:51 <Cale> no
12:02:59 <Cale> it's a specification of which type we want 3 to be in the first place
12:03:06 <murt_> OH
12:03:15 <ongy> murt_: of which type is the literal 3?
12:03:19 <Cale> :t 3
12:03:20 <lambdabot> Num t => t
12:03:26 <Cale> ^^ the literal itself is polymorphic
12:03:26 <murt_> its polymorphic right
12:03:33 <murt_> ok ok ok
12:04:02 <murt_> so the literal (n + 2) is polymorphic yes? what if i want the output to definitely be Integer?
12:04:53 <murt_> man im so confused right now
12:05:33 <ongy> you can make the input type Integer. Or make the input type (Integral a) and add a fromIntegral
12:05:53 <ongy> :t (+) -- The output type is the same as the input types
12:05:55 <lambdabot> Num a => a -> a -> a
12:06:32 <murt_> so if the input type is not constrained to Integral, the compiler wont let me return an Integer?
12:07:16 <murt_> is that because it realizes fromIntegral wont work for all Num types?
12:07:35 <gfixler> :t fromIntegral
12:07:36 <lambdabot> (Num b, Integral a) => a -> b
12:07:44 <geekosaur> unless you can find a conversion function (Num a, Num b) => a -> b; pretty sure there isn't one (what happens if a is Complex Double and b is Int?)
12:07:51 <kadoban> murt_: Sounds correct.
12:08:14 <ongy> (Num a) => a -> Integer would be enough, but I doubt you will find that either
12:08:21 <geekosaur> right
12:08:39 <murt_> what do you mean 'find' it
12:08:54 <ongy> either write it yourself, or find it in some library
12:08:55 <geekosaur> look for a function that provides the type you want
12:09:00 <murt_> like theres no function that can convert any number type to int
12:09:06 <murt_> ?
12:09:07 <geekosaur> @hoogle Num a => a -> Integer
12:09:08 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
12:09:09 <lambdabot> CorePrelude fromInteger :: Num a => Integer -> a
12:09:09 <lambdabot> Prelude negate :: Num a => a -> a
12:09:25 <murt_> right thanks for all the help everyone
12:09:27 <murt_> im gonna sleep on it
12:09:29 <geekosaur> there's one that goes the other direction, but that doesn't help jere
12:09:31 <geekosaur> *here
12:09:36 <kadoban> murt_: It's likely impossible to make a sensible function of that type, right.
12:09:45 <geekosaur> I already gave an example of that
12:09:53 <geekosaur>  (what happens if a is Complex Double and b is Int?)
12:09:55 <murt_> first day of haskell has blown my mind
12:10:03 <murt_> ill probably see some of you tomorrow night
12:10:05 <geekosaur> it's only defined for a very small subset of Complex Double values
12:10:13 <kadoban> murt_: It's ... not as complicated as it probably seems, but yeah there's some intricacies here.
12:10:28 <murt_> theres probably many reasons im not understanding it
12:10:41 <murt_> one is that ive been working with python mostly for the past few months
12:10:55 <murt_> two is that its 11 pm and ive been staring at this screen for the last 5 hours 
12:10:57 <ertes> murt_: you can go from Integer to any number type, but not the other way around, because some types that admit numeric literals and basic functions like addition aren't actually (just) numbers
12:11:07 <murt_> and three is that im trying to do things that a beginner probably shouldnt
12:11:28 <murt_> so thanks everyone
12:11:33 <murt_> ertes that makes sense thanks
12:11:35 <murt_> cya
12:12:12 <ongy> > fromInteger $ fromIntegral (maxBound :: Int) + (2 :: Integer)
12:12:14 <lambdabot>  9223372036854775809
12:12:29 <ongy> > (fromInteger :: Integer -> Int) $ fromIntegral (maxBound :: Int) + (2 :: Integer)
12:12:32 <lambdabot>  -9223372036854775807
12:12:48 <ertes> > (sin + cos) 3
12:12:51 <lambdabot>  error:
12:12:52 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M758012425213...
12:12:52 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
12:13:00 <ertes> > (sin + cos) 3 :: Double
12:13:02 <lambdabot>  error:
12:13:02 <lambdabot>      • No instance for (Num (Double -> Double))
12:13:02 <lambdabot>          arising from a use of ‘+’
12:13:45 <ongy> > uncurry (+) . sin *** cos $ (3 :: Double)
12:13:47 <lambdabot>  error:
12:13:47 <lambdabot>      • Couldn't match type ‘((c, c), b')’ with ‘Double’
12:13:47 <lambdabot>        Expected type: Double -> (c, b')
12:13:59 <ongy> > uncurry (+) . sin &&& cos $ (3 :: Double)
12:14:01 <lambdabot>  error:
12:14:01 <lambdabot>      • Couldn't match type ‘(c, c)’ with ‘Double’
12:14:01 <lambdabot>        Expected type: Double -> (c, (c, c))
12:15:26 <int-e> > (+) <$> sin <*> cos $ 3
12:15:29 <lambdabot>  -0.8488724885405782
12:16:13 <ongy> I was just missing parantheses. But that applicative trick is good to know
12:16:20 <ongy> :t sin <*> cos
12:16:22 <lambdabot> error:
12:16:22 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> b
12:16:22 <lambdabot>       Expected type: (a -> b) -> a
12:16:56 <ongy> :t (+) <$> sin
12:16:57 <lambdabot> Floating a => a -> a -> a
12:18:50 <Darwin226> Is there a T :: * -> Constraint that's automatically satisfied for any type?
12:19:26 <c_wraith> Darwin226: in sufficiently recent GHC, Typeable fits that description.
12:19:36 <c_wraith> ie, in GHC 8, all types are instances of Typeable
12:19:58 <Darwin226> Hmm... I think that's not enough actually
12:20:06 <c_wraith> But if you're going to use the constraint on a type specified by a type variable, you still need to specify the constraint
12:20:17 <Darwin226> I want this constraint to be dismissed at definition site, not at call site
12:20:20 <Darwin226> if it makes sense
12:20:37 <ongy> then why do you want it?
12:20:51 <c_wraith> Ah.  Doing that would break lots of the type system. :)
12:21:18 <Darwin226> Concretely, I have this type class for * -> * types and I want the type to be able to choose the constraint on the types that get wrapped in it
12:21:50 <Darwin226> so I imagine my class would look something like `class C (m :: * -> *) (c :: * -> Constraint) | m -> c`
12:22:12 <Darwin226> and I want the ability for some * -> * to say "I have no constraints"
12:23:07 <Darwin226> currently I managed to get something like that working with an associated type but it doesn't seem to work like I expected it to
12:24:36 <Gurkenglas> Can ghc infer instance signatures from instance implementations?
12:26:09 <Darwin226> lets see
12:26:33 <Gurkenglas> Then you could have function definitions that look like they pattern match on which type the argument has
12:27:17 <Darwin226> actually, I need to specify the constraint in the instance head
12:27:23 <Darwin226> so I don't know how to make it infer it
12:29:29 <Gurkenglas> Wait was my question relevant to your topic? I just randomly asked that :D
12:30:33 <Darwin226> Haha it was at least a partial match :D
12:34:56 <Darwin226> Does anyone have a link to that github gist of type class tricks that was recently on reddit?
12:35:13 <aukeroorda> Hello again. I am pretty new to haskell, so I might not be up to speed with the terminology. I am using GHCI, that is why I dont have any print statements (show). I keep running in to trouble with the type of this list. I have pasted my relevant functions and and error in this paste, and highlighted the most important lines: https://dpaste.de/Rjdu#
12:35:14 <aukeroorda> L1,16,18,22
12:37:26 <aukeroorda> I have tried a lot of 'debugging' in GHCI, checking the types that result from (read (head  ["2","3"])::Float), which is returning 2.0
12:37:29 <aukeroorda> a float value
12:37:59 <verement> aukeroorda: read expects a String argument, but b has type [Float]
12:38:18 <aukeroorda> Hmm
12:38:27 <aukeroorda> Oh wow, this already is a type Float
12:38:29 <MarcelineVQ> b is already a list of Float, you don't need to read it
12:39:23 <Cale> Also, you *definitely* should be pattern matching a, and probably b as well
12:39:55 <Cale> length a == 0  computes the length of the list a, which takes O(n) time
12:40:07 <Cale> pattern matching against [] is constant time
12:40:09 <aukeroorda> Hmm, I see
12:40:22 <aukeroorda> Oke, yeah that sounds a lot better
12:40:22 <Cale> Also, you're applying head and tail everywhere, which you won't have to do if you pattern match
12:41:58 <Cale> Every time you're using both head and tail together, and most places where you'd use either one on its own, you should be pattern matching instead.
12:42:19 <aukeroorda> Hmm, oke. I'll try and work on it, and come back with the results
12:42:26 <aukeroorda> Thanks Cale
12:42:28 <Cale> Sometimes, there's an idiom in which tail will appear, sometimes you know for certain that a list isn't empty and you can apply head
12:42:36 <Cale> (say, a list which does some kind of search)
12:43:06 <Cale> But mostly those are playing with fire, since they crash your program if the list is empty
12:58:51 <ReinH> aukeroorda: generally speaking, pattern matching is fundamental to Haskell, and you should learn it as early as possible so you can understand everything else.
13:02:21 <clueless_> can someone help me make this script work with user input? to show which digit they want
13:02:22 <clueless_> http://lpaste.net/200032
13:02:58 <aukeroorda> ReinH Do you know a good readup for pattern matching?
13:03:11 <aukeroorda> or is the haskell wiki a good source?
13:03:22 <Darwin226> So... turns out my code worked all along. I just didn't update the type signature and it coincidentally still matched, just not as generally as possible
13:03:34 <Darwin226> and hour spent
13:04:29 <Cale> Darwin226: If it's any consolation (it isn't), you can always just remove the type signature from something and see what the compiler infers :)
13:04:50 <Cale> ghci will tell you with :t
13:05:27 <Cale> aukeroorda: Most Haskell tutorials should introduce a bunch of pattern matching stuff early on...
13:05:32 <Darwin226> Cale: That's what did it in the end. I rewrote the whole thing with the "avoid overlapping instances" trick thinking the whole time "isn't this basically what I already had?"
13:05:48 <Darwin226> luckily the names were different enough that it forced me to remove the type signature
13:06:11 <Cale> clueless_: Sure, so you want the user to enter a number n, and it'll print out the nth element of the list?
13:06:36 <Cale> clueless_: main = do n <- readLn; print (tetranacci !! n)
13:09:09 <clueless_> Cale: thanks a lot, I was struggling a lot with the readLn part, I was using different method
13:09:55 <Cale> You could also do stuff like  do x <- getLine; print (tetranacci !! read x)
13:11:00 <Cale> Or if you want to be able to handle parse failure, you might use  case readMaybe x of Nothing -> ...; Just n -> ...
13:22:34 <elliptic00> take 3 ll where ll = [1..10]
13:22:48 <elliptic00> anyone know why above does't work in GHC?
13:23:10 <glguy> elliptic00: You can't attach a where to an expression
13:23:10 <mauke> because 'where' attaches to declarations, not expressions
13:24:01 <prohobo> ssssssssssssssssssss
13:25:03 <elliptic00> it works in my .hs file with where on second line
13:25:31 <elliptic00> take 3 ll \n where ll = [1..10], it works
13:25:32 <glguy> That's because you have a declaration in your .hs file.
13:25:49 <glguy> something = .... where ll = [1..10]
13:26:39 <glguy> To see it break in your .hs file try wrapping the expression in parentheses (take 3 ll \n where ll = [1..10])
13:27:51 <elliptic00> I use :{ take 3 ll  \n where ll = [1..10]  :}  doesn't work either 
13:28:09 <glguy> 13:22 glguy     : elliptic00: You can't attach a where to an expression 
13:28:10 <glguy> 13:22 mauke     : because 'where' attaches to declarations, not expressions 
13:28:37 <glguy> :{ :} doesn't make a declaration
13:28:45 <EvanR> what is :{ :}
13:28:55 <glguy> multi-line input in GHCi
13:31:10 <elliptic00> so anyone know how can I do it in :{  :} multi-line GHCI with my above problem?
13:31:29 <elliptic00> I can do it in .hs file, but not GHCi
13:33:15 <mauke> elliptic00: stop ignoring our answers, maybe?
13:34:11 <Valoo> I finally understand monads \o/
13:36:53 <glguy> elliptic00: You'd do it in GHCi by making a declaration like you did in your source file
13:37:47 <verement> > let ll = [1..10] in take 3 ll
13:37:49 <lambdabot>  [1,2,3]
13:38:04 <athan> krud. Can't derive Generic on a GADT, huh?
13:41:40 <athan> Ahh there we go. Neatly packed existentially quantified exceptions woot
13:58:26 <ertes> Valoo: what made it click for you?
13:59:17 <Valoo> ertes: The first example on this page: http://members.chello.nl/hjgtuyl/tourdemonad.html
14:00:01 <Valoo> replicate 2 =<< [1, 2, 3]
14:01:16 <mauke> > do x <- [1, 2, 3]; [(), ()]; return x
14:01:18 <lambdabot>  [1,1,2,2,3,3]
14:03:39 <zipper> You guys know what I can use for style checks in haskell?
14:03:53 <kadoban> hlint is the big one
14:03:58 <ReinH> hlint
14:04:28 <ReinH> stylish-haskell and hindent will reformat things for you
14:04:54 <Cale> Valoo: Its examples are fine, but it's perhaps worth pointing out that page is full of incorrect uses of the word "monad". For example, IO and Maybe are monads, but getLine and Just 4 are not.
14:05:21 <Welkin> > [1,2,3] >>= \x -> [(),()] >> return x
14:05:24 <lambdabot>  [1,1,2,2,3,3]
14:05:40 <Welkin> > [1,2,3] >>= [(),()]
14:05:43 <lambdabot>  error:
14:05:43 <lambdabot>      • Couldn't match expected type ‘Integer -> [b]’
14:05:43 <lambdabot>                    with actual type ‘[()]’
14:06:01 <Welkin> > [1,2,3] >>= \x -> [x,x]
14:06:03 <lambdabot>  [1,1,2,2,3,3]
14:06:45 <jpgg> test
14:06:51 <athan> Is it possible to handle an IOError?
14:07:12 <geekosaur> Control.Exception.catch
14:08:17 <ertes> Valoo: interesting, i almost forgot about that one…  note that in addition to what Cale said this guide was written before the Applicative-Monad-Proposal was implemented…  it uses this definition of Monad:  class Monad m where (>>=) :: m a -> (a -> m b) -> m b; return :: a -> m a
14:08:39 <ertes> note the lack of an Applicative constraint
14:09:36 <zipper> ReinH: kadoban Thanks
14:10:22 <zipper> Also is there a style guide for haskell? e.g past 80 chars is too much?
14:10:30 <Welkin> zipper: o.o
14:10:44 <Welkin> zipper: https://github.com/tibbe/haskell-style-guide
14:10:50 <Welkin> you are a regular here
14:10:59 <Welkin> how do you not already know
14:11:04 <hoppfull> Hey. I feel like I have a grasp on functors. Are there more than two functor laws?
14:11:06 <zipper> Welkin: I'm surprised you know me.
14:11:14 <ertes> zipper: "write code that is readable"
14:11:49 <zipper> Welkin: I have been writing clojure for the past few months and very little haskell.
14:11:53 <zipper> :(
14:11:59 <Welkin> zipper: cuckold!
14:12:36 <zipper> Welkin: Anyway feels really nice that you actually know this nick. A sliver of significance hahaha
14:12:58 <ertes> zipper: if you send me a patch that strictly follows the style guide Welkin just linked, i will most likely reject it =)
14:13:08 * hackagebot interlude-l 0.1.0.6 - Prelude replacement based on protolude  https://hackage.haskell.org/package/interlude-l-0.1.0.6 (darwin226)
14:13:12 <zipper> ertes: Why so?
14:13:51 <ertes> zipper: just saying that it's highly subjective and there is no universal style guide everybody follows
14:14:08 <zipper> ertes: True, it's just a guide. Not strict rules.
14:14:18 <ertes> for example i dislike lines beginning with commas or semicolons
14:14:39 <ertes> this style of optimising for the editor instead of the reader is not only ugly, but also completely pointless, because it doesn't work
14:14:41 <zipper> ertes: You clearly haven't written a lisp comment :)
14:14:44 <Welkin> ertes: blasphemy
14:14:54 <Welkin> I do all my lists like this
14:14:56 <Welkin> { one
14:14:58 <Welkin> , two
14:14:59 <Welkin> oops
14:15:03 <Welkin> [ one
14:15:05 <Welkin> , two
14:15:07 <Welkin> ]
14:15:42 <ertes> [ one,
14:15:45 <ertes>   two ]
14:15:53 <zipper> Oh you meant commas as in vertical lists, I have adapted to the comma at the start.
14:16:08 <Welkin> I love the comma at the beginning
14:16:09 <Welkin> o.o
14:16:22 <zipper> ertes: 80 chars per line is adapting to screen sizes and therefore legibility.
14:16:23 <Welkin> I hate that most modes don't support this for other languages
14:16:30 <Welkin> or cause compiler/interpreter errors
14:16:37 <zipper> Welkin: I do to. Acquired taste.
14:16:49 <mauke> I prefer
14:16:51 <mauke> one :
14:16:52 <mauke> two :
14:16:53 <mauke> []
14:17:07 <zipper> mauke: LOL never seen that in real life
14:17:18 <zipper> Just tutorials
14:17:22 <ertes> zipper: that one is fine, except i wouldn't go for a strict 80…  sometimes having to scroll (or using a wider screen) is better
14:17:29 <mauke> I think that's the only style (in haskell) that treats all elements uniformly
14:18:13 <mauke> my preference would be perl style: [
14:18:15 <mauke>   one,
14:18:16 <mauke>   two,
14:18:17 <mauke> ]
14:19:16 <ertes> i've never found it that useful to treat all elements uniformly, but i've used mauke's (:) style in the context of tests and benchmarks
14:19:38 <ertes> defaultMain $ … : … : … : []
14:19:57 <mauke> I like it because I can easily add, remove, or rearrange lines in my editor
14:20:27 <shachaf> But you can only use operators with precedence higher than 5.
14:20:28 <ertes> makes sense for lists that do actually change
14:21:11 <mauke> shachaf: or use parens
14:21:16 <MarLinn> and then there are export lists and language extensions where that approach doesn't work. But I also haven't seen a single style guide that covers language extensions
14:21:49 <ertes> MarLinn: i just list each of them in a separate pragma
14:23:13 <jpgg> test
14:24:36 <MarLinn> I use a single pragma but line up commas and #'s. I guess it comes down to editor tooling again...
14:25:26 <crobbins> MarLinn: i like separate pragmas so you can easily add/remove them without dealing with unnecessary changes in the diff
14:25:29 <ReinH> Ending commas privilege the last element, starting commas privilege the first element.
14:25:36 <crobbins> +1 ReinH
14:26:06 <ReinH> You're just trading one for the other. Perl style actually privileges neither.
14:26:14 <crobbins> that's why i actually like that some languages (*cough* python *cough*) allow trailing commas
14:26:50 <crobbins> i think there was a rfc for allowing trailing commas in lists
14:26:51 <ReinH> But that doesn't work in Haskell so I put things at the front entirely because I think it looks cool.
14:26:52 <crobbins> for ghc
14:27:39 <ReinH> While making some mouth noises about it being somehow more elegant as a rationalization
14:27:55 <MarLinn> that's why my style of writing language extensions works well if you're sorting them by descending importance (the first rarely changes) instead of word lengths or what have you
14:28:36 <ReinH> I just sort them alphabetically, or rather stylish Haskell does that for me so I literally never think about it
14:28:44 <ReinH> Ditto imports
14:29:33 <ertes> weirdly enough haskell allows trailing commas in export lists
14:29:45 <ertes> module X (a, b, c,) where …
14:29:45 <ReinH> And hindent styles my code, so 90% of the time I don't think about that either
14:29:56 <ReinH> So I spend more time thinking about other things
14:30:07 <ertes> (not sure if "haskell" does, but GHC surely does)
14:30:28 <ReinH> Like wtf that GHC error message means
14:34:14 <MarLinn> styling can both be documentation and procrastination - you just have to figure out which one you're actually doing
14:34:32 <ReinH> Can't it be both
14:35:55 <MarLinn> s/documentation/useful documentation/
14:36:54 <ertes> styling is also an exercise in typography, the art of text readability and aesthetics
14:38:28 <ertes> and you wouldn't write text like that
14:38:32 <ertes> , would you? ;)
14:38:40 <Welkin> you wouldn't download your mom, would you?
14:39:17 --- mode: ChanServ set +q *!*@107-147-70-64.res.bhn.net
14:49:24 <Phyx-> well that escalated..
14:50:44 <jpgg> can
14:51:25 <jpgg> can
14:52:11 <ludat> hi everyone, I'm thinking about writing a simple restful api at work what framework would you recommend?
14:53:10 <orion> ludat: scotty
14:53:32 <maerwald> ludat: snap
14:56:27 <ludat> some reasons to each? I've seen most frameworks but I'm not sure if I understand the strength of each one
14:57:15 <johnw> ludat: servant
14:58:16 <johnw> with servant, you define your API using types, which allows you to either server a test server or a test client, depending on which side you intend to write
14:58:21 <johnw> generate a*
14:58:42 <johnw> and it type checks your implementation nicely; we use it at work both for defining RESTful services, and for writing clients
14:59:36 <ReinH> It also generates docs, clients in other languages...
14:59:55 <johnw> yeah, that too :)
15:01:17 <ludat> johnw, interesting does it have some kind of full stack to do persistence and such? or I have to find one myself?
15:05:29 <pavonia> Does Hackage build the package documentation automatically? If so, how long does it usually take? I'm having trouble finding clear information about how that works on Hackage
15:05:53 <johnw> ludat: it only addresses web endpoints, not the other aspects of building out a full web app
15:06:28 <johnw> think of it like giving you a way to specify the type of a web API
15:08:30 <hpc> pavonia: it's supposed to automatically build documentation, but has historically had trouble with it
15:09:52 <frost_> \whois sulu
15:10:42 <glguy> In glirc the command goes green when recognized /03whois so you know it's recognized before submitting it
15:11:30 <pavonia> hpc: And does the website indicate if it already has tried to build it?
15:11:39 <frost_> ya thanks :) its late at my place :p
15:11:55 <pavonia> If it says "pending", I guess it hasn't
15:15:16 <glguy> pavonia: It builds it on its own but that can fail. If the maintainer wants to make sure that documentation is available when they update to hackage it's easy to upload documentation, too
15:15:43 <glguy> pavonia: Is a particular package's documentation missing?
15:18:21 <pavonia> glguy: I uploaded a package as a candidate, mainly to see if it and the docs build fine on a recent GHC before officially releasing it, so just wondering how the workflow is
15:19:32 <glguy> pavonia: If you want docs it's best to just upload them
15:19:38 <glguy> that way there's no downtime and you know they'll work
15:21:24 <pavonia> glguy: How do you upload the docs?
15:22:03 <glguy> This is my script for it (you don't necessarily need to use a script for these two commands, but it used to be more complicated) https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
15:25:47 <glguy> pavonia: Also that assumes you build documentation for your libraries
15:26:27 <pavonia> I need to build the docs for the dependencies too?
15:26:47 <grantwu> I'm having trouble understanding the distinction between the MonadFoo and FooT typeclasses; why is the FooT newtype needed?
15:27:00 <grantwu> See, for example, https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Lazy.html
15:27:19 <jpgg> can anyone see this message?
15:27:22 <glguy> Yeah, I think it's necessary to have the dependency documentation built so that the linking works correctly. I have documentation: True in my ~/.cabal/config for that reason
15:27:38 <geekosaur> grantwu, it's about newtype deriving
15:27:58 <pavonia> glguy: Okay, thanks
15:28:30 <geekosaur> for WriterT / MonadWriter, if you attach `tell` to WriterT then you always have to use `lift` to reach it; if you attach it to MonadWriter, then anyone who uses newtype deriving can use it directly
15:28:31 <grantwu> geekosaur: You mean, there's a newtype so that FooT isn't an instance of certain typeclasses MonadFoo is?
15:28:40 <grantwu> oh
15:29:20 <Aruro> is haskell good for time critical tasks? like content delivery?
15:29:34 <glguy> grantwu: MonadFoo is a constraint on types that implement the Foo operations. FooT is a type that implements MonadFoo
15:29:42 <glguy> Other types can also implement MonadFoo
15:29:43 <jpgg> tasdf
15:29:53 <johnw> Aruro: haskell is just fine for that, in the hands of someone who knows how to use it for those sorts of tasks
15:29:54 <glguy> jpgg: This isn't a test channel
15:29:54 <geekosaur> jpgg, yes, you show up
15:30:20 <jpgg> ok, ty. Sorry for the noise
15:30:50 <EvanR> content delivery doesnt stand out to me as a time critical task, in the sense of real time programming
15:31:45 <ReinH> Content delivery is only time critical in a very broad sense.
15:31:52 <ReinH> Pacemakers are time critical.
15:32:27 <ReinH> That said, I wouldn't write a pacemaker in Haskell, but I might write code that generates pacemaker code in Haskell.
15:34:04 * pavonia read that as "peacemaker" and was confused
15:34:27 <EvanR> write (fix codeThatGenerates)
15:35:05 <EvanR> code for a firearm, fortunately not yet
15:35:14 <glguy> EvanR: I think they call that a "quine"
15:35:45 <EvanR> darn tootin
15:38:55 <grantwu> How do I report documentation typos? 
15:39:09 <alercah> Report them to the package maintainer
15:39:11 <grantwu> For example, I think the code example for https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#v:ap has a typo
15:39:13 <ongy> the same way you report other bugs
15:39:26 <grantwu> oh wait nvm
15:39:42 <grantwu> liftMn isn't an actual function, but it means to use one of liftM1, 2, etc.
15:51:58 <ydl> is there a way to tell ghc -fllvm to use particular binaries for opt and llc?
15:53:15 <Aruro> does 50ms sound like time critical?
15:54:25 <Aruro> can haskell drive 50ms precision content system? lets say video?
15:54:58 <EvanR> 60fps video would be ~16ms of "precision"
15:55:10 <EvanR> which is nothing
15:55:37 <Aruro> so i assume the answer is yes?
15:55:38 <EvanR> unless you get a bad GC
15:55:49 <EvanR> then you will get some latency
15:55:49 <liste> and you can tune the gc
15:56:02 <EvanR> yeah
15:57:18 <Aruro> for example can netflix be potentially migrated to haskell?
15:57:38 <thoughtpolice> ydl: -pgmlo and -pgmlc, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html?highlight=pgmlo#replacing-the-program-for-one-or-more-phases
16:00:32 <EvanR> netflix the service?
16:00:35 <EvanR> or the client
16:00:36 <Aruro> yes
16:00:42 <Aruro> the service
16:01:00 <EvanR> that shouldnt be an issue, because the bottleneck is the internet, not the streaming source
16:01:39 <EvanR> even if ghc programs werent super fast
16:02:46 <EvanR> as long as you can download another 10 seconds of video every few seconds you can watch your showz
16:03:01 <EvanR> which is really a function of your internet service
16:05:15 <Aruro> but you will have many requests and some internal logic should be rather fast?
16:05:36 <EvanR> yes, ghc gives you rather amazing concurrency support
16:06:05 <EvanR> of course at some point youll need to replicate your server and distribute the requests, which isnt really a haskell issue
16:06:49 <ydl> thoughtpolice: thanks!
16:07:31 <thoughtpolice> EvanR: It's not that simple, because that bottleneck is not symmetric. Netflix has 40Gbp/s pipes that they try to saturate on *their* end. In this sense, it is extremely important whether the program actually writing to the NIC is as efficient as possible at the 'edge', whether or not any individual client is slow.
16:08:07 <ertes> Aruro: i imagine that a service like netflix is mostly I/O-bound (communication with databases, over HTTP, etc.) with occasional machine learning algorithms
16:08:35 <ertes> at that scale other things than the programming language start to become your bottleneck, for example your operating system's TCP stack
16:09:16 <Aruro> so haskell overall does not seem worse than other solutions?
16:09:17 <jmcarthur> You don't even have to reach anything near that kind of scale for the programming language to stop being the bottleneck.
16:09:17 <EvanR> thoughtpolice: so because their internet is so fast, they are the bottleneck, you say
16:09:25 <thoughtpolice> For their edge-level stuff, they've recently moved to adding TLS support to sendfile() in the FreeBSD kernel. The typical notions of scalability completely fall down at Netflix level, tbh. And plus, Netflix the service isn't just the literal writing of videos to the NIC, it's also 100 other components to make sure all that actually works.
16:10:00 <jmcarthur> Netflix is merely a very easy example of this to point to.
16:10:08 <ertes> Aruro: haskell is actually very efficient and scalable…  the thing it does not handle is real-time guarantees
16:10:13 <thoughtpolice> Haskell today would probably be good for some of those things (lots of infrastructural stuff for example, IMO), and probably not for other things. The Haskell of tomorrow could maybe do better on some of them, but not all.
16:10:56 <jmcarthur> It'd be great to have a low latency GC, but that's more of a runtime detail than a language issue.
16:10:56 <EvanR> the haskell of today, tomorrow (tm)
16:11:03 <thoughtpolice> Latency could be improved, at some throughput cost by GC improvements, for example, which makes certain things more viable.
16:11:33 <Aruro> so in large dataintensife mega apps haskell would be like abstract glue code?
16:12:10 <jmcarthur> It depends on what you're doing.
16:12:35 <EvanR> for solving einsteins field equations you might need to stick with fortran
16:12:39 <jmcarthur> Haskell could be basically the whole thing, or it might only be useful for certain parts. I think main deciding factor is the GC.
16:13:15 <jmcarthur> I think Haskell as a language seems great for data crunching. Throughput with Haskell is fine. The main issue there is libraries.
16:13:44 <ertes> Aruro: one of the main factors is whether the stuff you need is already implemented, and if not, whether it pays off to implement it yourself (as opposed to binding to an existing foreign implementation)
16:13:49 <jmcarthur> Sure, Fortran compilers will typically generate better code, but it's just a not-usually-huge constant factor.
16:13:53 <EvanR> fortran sucks? ah well, theres always haskell ;)
16:14:15 <tnks> sometimes qhen people say "Haskell" they include "FFI as necessary" which makes things blurry.
16:14:39 <EvanR> fortran having the advantage of almost all scientific code ever written being written for it
16:15:07 <jmcarthur> There's also the question of what counts as FFI. Does using Ptr automatically put you "in the FFI"?
16:16:48 <ertes> Aruro: one interesting aspect of this is:  with haskell reinventing the wheel can and often is cheaper than binding (or using a different language)
16:18:16 <EvanR> when you have a clear idea of what the wheel is yeah... if not youre screwed anyway!
16:18:23 <Aruro> so basically businesswise there is no big disadvantage in using haskell? in terms of userexperience(speed)
16:18:48 <EvanR> businesswise theres an obvious disadvantage, getting replacable engineers to work on it
16:18:52 <ertes> Aruro: there can be disadvantages, but UX/speed is not one of them
16:19:09 <Aruro> EvanR: that is out of scope at the moment :)
16:19:20 <EvanR> haskell doesnt have liskov's programmer substitution principle
16:24:17 <ertes> EvanR: i'm glad it doesn't…  programmers aren't objects after all
16:24:36 <kadoban> EvanR: Does any language?
16:25:21 <ertes> no; try getting into any existing PHP code base (corporate or not) without going insane =)
16:26:40 <MarLinn> but there seem to be more Haskell programmers than Haskell jobs, so if the parties are flexible enough "substituting" should be possible
16:27:42 <jmcarthur> I think the trick is to just not restrict yourself to only hiring people who already know Haskell.
16:27:55 <jmcarthur> They can learn. It's their job. Just hire people who are able and willing.
16:28:14 <Aruro> does haskell play well with clojure? is it good mix?
16:28:20 <EvanR> nope
16:28:29 <jmcarthur> Too many job ads look for too specific skills.
16:28:52 <EvanR> haskell and clojure have two different universes of technology, for example serialization libraries. though there is json
16:29:00 <Aruro> jmcarthur: i have feeling every useless job now requires 5 years of very specific experience
16:29:22 <EvanR> even haskell FFI is C based, and clojure is java based
16:29:38 <EvanR> but java-bridge does give you JNI
16:29:48 <Aruro> EvanR: so gluing them together will be pain?
16:30:05 <EvanR> unless you go through a common thing like http or json
16:30:10 <MarLinn> Even more general, too many employers know too little about  how programming works
16:30:25 <ertes> i can imagine that applicant screening can be difficult with haskell, because it's so easy to look like a skilled haskell programmer
16:32:39 <MarLinn> ertes: you mean because skills like choosing the right abstraction or evaluating real performance are hard to test for?
16:33:49 <EvanR> "do you know the difference between a Map and a list"
16:33:58 <ertes> MarLinn: yeah, and because being able to solve every other project euler problem does *not* make you a skilled programmer, except perhaps for some efficiency tuning in algorithms…  but that's rarely relevant
16:34:11 <EvanR> should at least filter out PHP only programmers
16:34:29 <hpc> ertes: ask about continuations
16:34:36 <hpc> ertes: worst case scenario, they're a lisp programmer
16:35:41 <ertes> i feel like a lot of people can solve every PE problem, but can't actually write a *program*…  with a command line interface, reading files (without loading them into memory in full), using concurrency properly, dealing with exceptions, etc.
16:36:08 <hpc> /every/ PE problem?
16:36:25 <hpc> the ones past 25 or so stop being programming problems and start being ultra-specific math problems
16:36:40 <Aleksejs> I have a question: I convert function \f -> g . f to \f x -> g (f x). What processes are involved here? I've added x, so there is eta-abstraction. But what about removing (.) ?
16:36:44 <ertes> whatever, you get the idea =)
16:36:53 <hpc> :P
16:37:47 <ertes> Aleksejs: it's really just applying (.) by substituting its definition, once it's fully applied
16:37:57 <mauke> Aleksejs: inlining (.), beta reduction
16:38:13 <hpc> Aleksejs: eta expand \f -> g . f to \f x -> (g . f) x, then beta reduce the expression (g . f) to (\x -> g (f x)), then beta reduce (\x -> g (f x)) x to g (f x)
16:38:51 <MarLinn> I feel like being able to solve PE problems at least gives you a baseline, similar to "map vs list". But it weeds out a different kind of crop
16:38:53 <hpc> er yeah, (g . f) gets evaluated, not beta reduced
16:39:22 <Aleksejs> I see, thanks!
16:39:43 <hpc> or i guess it does get beta reduced, if you consider (.) to be the lambda
16:39:59 <hpc> the names are less important than knowing what's being done
16:41:12 <hpc> ertes: looking at someone's github can be a good indication of how useful they can be on the IO side of things
16:42:35 <M41px[m]> I advanced with lens and Aeson but I find the "fmap (^? key "thumb" . _String) $ fmap (\x -> (x^._2)) $ js ^@.. members" is heavy. I would like to remove fmap. You think it is possible?
16:42:41 <M41px[m]> https://github.com/41px/getthumb/blob/master/src/Main.hs
16:43:54 <MarLinn> hpc: if they're contributing somewhere, or at least are playing around in public. If they're doing something, but not in public, you might miss out on someone that way
16:44:32 <hpc> M41px[m]: so going through some steps that might help you, change (f . g $ x) style to (f $ g $ x) style first
16:44:45 <glguy> M41px[m]:  fmap (^. _2) $ js ^@.. members  is    js ^.. members ,  I think
16:44:48 <hpc> M41px[m]: then you can reason about (f . g), which in this case is something of the pattern (fmap f . fmap g)
16:45:00 <hpc> M41px[m]: which is equal to fmap (f . g)
16:46:08 <glguy> M41px[m]: and since you're ignoring the Maybe layer
16:46:17 <glguy> js ^.. members . key "thumb" . _String
16:50:05 <glguy> and since you're going to just throw the list away anyway:
16:50:34 <glguy> traverseOf_ (members . key "thumb" . _String) (traitementThumb dir) js
16:51:24 <M41px[m]> Ok thanks :)
16:52:56 <slack1256> is there a RAD for wx(widgets) ?
17:03:35 <Gurkenglas> glguy, that'll require him to make traitementThumb String -> T.Text -> IO (), right?
17:05:56 <glguy> right
17:08:16 <Gurkenglas> Hah I was just gonna tell him to replace that get with uses :D
17:13:12 * hackagebot tagsoup-selection 0.1.0.0 - Selecting subtrees from TagSoup's TagTrees using CSS selectors  https://hackage.haskell.org/package/tagsoup-selection-0.1.0.0 (siracusa)
17:13:13 * hackagebot ersaconcat 0.0.1 - A script to concatenate AIP ERSA  https://hackage.haskell.org/package/ersaconcat-0.0.1 (TonyMorris)
17:45:33 <ydl> is there a way to make sure GHC will inline functions accessed from a record (as opposed to a typeclass)?
17:46:50 <saulzar> ydl, Is that actually possible?
17:47:10 <saulzar> ydl, After all the function in the record can change...
17:48:22 <ydl> i should have said when possible. in particular the dictionary is known at compile time.
17:49:04 <saulzar> Example?
17:50:01 <EvanR> + used when Int is known
17:50:39 <saulzar> That is a typeclass not a record though
17:51:34 <EvanR> i heard dictionary
17:51:42 <ydl> EvanR: my fault, should have said record
17:51:42 <EvanR> which is just an invisible record
17:53:21 <Zemyla> Hmm, I think I came up with an alternative formulation for Bazaars.
17:53:22 <ydl> but that's just the point. suppose instead of a typeclass it is convenient for me (because it doesn't satisfy laws, it has multiple instances, etc.) to have something like "data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }", and then i have functions "f :: Monoid a -> ..."
17:53:54 <ydl> of course Monoid satisfies laws but this is an easy example
17:54:29 <Zemyla> Instead of newtype Bazaar a b t = Bazaar { runBazaar :: forall f. (Applicative f) => (a -> f b) -> f t }...
17:55:19 <Zemyla> You have newtype Bazaar a b t = Bazaar { runBazaar :: forall p c u y z. (c -> b) -> (forall x. a -> p x -> p (c, x)) -> (forall x. (x -> y) -> p x -> z) -> (u -> a -> y) -> p u -> z }
17:56:41 <Zemyla> * u -> t -> y
18:01:16 <mniip> 1474159980 [03:53:00] <ydl> but that's just the point. suppose instead of a typeclass it is convenient for me (because it doesn't satisfy laws, it has multiple instances, etc.) to have something like "data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }", and then i have functions "f :: Monoid a -> ..."
18:01:37 <mniip> have you seen my dictionary representation tricks stuff :o
18:02:27 <lpaste> mniip pasted “DictRep” at http://lpaste.net/200218
18:02:27 <ydl> mniip: no, what do you mean?
18:05:33 <ydl> mniip: but i still need to create a class to use these, correct?
18:06:00 <mniip> what do you mean
18:15:34 <ydl> mniip: can you give an example of usage of your function "given"?
18:19:23 <mniip> given (BoundedDict 'a' 'z') maxBound :: Char
18:21:09 <mniip> aaand gotta go!
18:39:33 <joobus> is there a way to declare a type for a particular string?  like:  type SomeException "string_from_a_json_response_from_some_site"
18:41:20 <geekosaur> no, strings are strings (which is to say [Char] or Text depending on OverloadedStrings and instances in scope)
18:41:32 <geekosaur> you may be thinking of type level strings, which are a different beast entirely
18:41:48 <clueless> this will be a really weird question, but could someone translate this to python because I'm trying to understand the logic of it which im having a hard time to figure... http://lpaste.net/200032
18:42:09 <nathyong> joobus: if you're using OverloadedStrings, you could say ("string" :: SomeException)
18:43:39 <joobus> geekosaur: I'm fetching a json from a site, and one of the response fields is basically the 'type' of a thing, e.g. "image" or "video".  I'd like to be able to parse this as a sum type of, e.g. Pic | Video | Text
18:44:07 <geekosaur> you need to convert it, you cannot tell Haskell's type system to pretend a string is some other type
18:44:18 <joobus> k, thanks
18:44:56 <geekosaur> in some languages a type like that is a string with extra behavior. haskell isn't one of them
18:45:19 <geekosaur> (perl somewhat infamously is, often in ways you don't expect...)
18:46:41 <pavonia> clueless: Do you understand the individual syntactic parts of it?
18:48:49 <clueless> pavonia: I get that tetranacci is a no parameter function that returns a list that is created by joining [0 1 1 2] to another conjuction of of lists that are created by 4 recursive calls 
18:50:11 <grantwu> joobus: The read typeclass might be useful
18:50:15 <pavonia> clueless: Try to evaluate the function by hand to see what the 5th, 6th etc. value of the list is, I think this will make it a bit clearer
18:50:23 <grantwu> Also, I think Aeson might have good facilities for doing this?
18:51:57 <clueless> pavonia: I mean and I get that each value is calculated by the past 4 numbers .. but I need to implement that in python but I cant figure out the how to make the user input the digit they need
18:53:08 <pavonia> Does Python even have lazy evaluation?
18:53:45 <pavonia> You could rewrite it to a simple loop, of course
18:58:48 <joobus> pavonia: Do you consider generators lazy evaluation?
19:01:53 <pavonia> joobus: Not sure what that is in this context
19:04:56 <joobus> python has generators which are kind of like lazy evaluation, and there are generator comprehensions, like (item*2 for item in [1,2,3,4]).  Python will only evaluate 1 item in the generator at a time.
19:05:15 <joobus> I looked at clueless paste though, and don't think it would help him.
19:06:34 <pavonia> Hhm, you would need four of these items in parallel then to emulate that
19:07:08 <clueless> joobus: what do you mean?
19:10:30 <joobus> clueless: basically I didn't understand the paste code you posted.  I couldn't see how it ever got the initial x0 x1 x2 x3
19:13:14 * hackagebot wahsp 0.2 - A haskell binding of the Web Audio API ala blank-canvas  https://hackage.haskell.org/package/wahsp-0.2 (nshaheed)
20:00:38 <lpaste> joobus pasted “How do I catch an exception in Haskell?” at http://lpaste.net/200255
20:01:03 <joobus> If someone wouldn't mind taking a look at that paste, I would appreciate it.
20:01:36 <geekosaur> Control.Exception.catch
20:02:07 <geekosaur> however I think aeson has an entry point for that
20:04:19 <redbarron> Hi, i have a problem where I need to shuffle a list by taking random values from a list until it is exhausted and I was wondering if there was a way I could store adjacent values so that a walk with normal distribution was sampled faster
20:04:21 <joobus> i thought `parseMaybe` would catch the exception.  It is from Data.Aeson.Types.  But the program still just exits on execution.
20:05:53 <grantwu> redbarron: What is a walk with normal distribution?
20:06:13 <grantwu> joobus: Are you sure it's not exiting at fromJust?
20:06:30 <geekosaur> I expect it's actually decode
20:06:31 <joobus> also, the terminal is just spitting out `(^?!): empty Fold` so I don't know what exception is actually being thrown, if any.
20:06:52 <redbarron> I mean that if the random values were selected with Gaussian probability with distance from the last deleted value
20:07:00 <joobus> I'm fairly certain the decode works.
20:07:06 <geekosaur> hm, no, wouldn't be
20:07:15 <redbarron> Does that make sense?
20:07:52 <grantwu> Yes; I think an Array or a Data.Sequence might be better for you
20:08:36 <geekosaur> in any case that message is the exception (and will be an ErrorCall). the problem being that it does not call fail, it throws directly
20:08:49 <redbarron> I understood Vector uses unboxed Arrays, is that right?
20:08:50 <geekosaur> so you can't intercept it with a parse error
20:09:41 <geekosaur> it is better to use something that lets you control how the error is signaled (using fail, for the parser) than to use something that throws exceptions directly
20:09:48 <grantwu> redbarron: Documentation says you want https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html
20:10:20 <shachaf> Instead of catching an exception you should produce a parser that can fail.
20:10:20 <redbarron> I also heard they stored adjacent values closer in a tree structure, I wondered if that would lead to the speed increase I desired
20:10:36 <shachaf> You shouldn't be using (^?!) if you're not sure the field will be there.
20:10:55 <geekosaur> ...which is what I just tried to say
20:10:57 <redbarron> If not I would like to use explicitly the fact that locally adjacent values are sampled more often
20:11:39 <shachaf> geekosaur: I didn't mean to contradict you.
20:11:44 <shachaf> What geekosaur said.
20:11:58 <johnw> I think you codicted him
20:12:07 <geekosaur> no, I was wondering if I said it too confusingly
20:12:17 <joobus> shachaf: you're probably right, but I also want the whole parse to fail if a field is missing.
20:12:21 <redbarron> But mostly I'm trying to understand the implications of the Vector and unboxing (and boxing)
20:12:24 * geekosaur a trifle short on sleep
20:12:36 <geekosaur> joobus, you do that by catching the missing field and invoking fail in the parser
20:13:02 <geekosaur> which will fail the parse without an exception (unless you use the parser entry point that rethrows the parse fail as an exception, of course)
20:15:38 <geekosaur> redbarron, a boxed value has two attributes: (1) it can be lazy (2) it can diverge (that is, throw an exception or cause an infinite loop or etc.)
20:15:42 <redbarron> Also related to the implementation of Sequence, using finger trees
20:15:45 <geekosaur> unboxed values are just values
20:17:41 <redbarron> I don't see how that relates to a speed increase, i must be mistaken
20:18:09 <grantwu> Not needing to be lazy or diverge means you can store the actual value and not the thunk, to speak imprecisely
20:19:15 <grantwu> This means accessing the value doesn't require any computation, so to speak
20:19:24 <redbarron> So unboxed values are strict and so instant
20:19:32 <redbarron> ?
20:19:42 <geekosaur> yes
20:19:58 <grantwu> What is the difference between being unboxed and strict?
20:20:11 <geekosaur> haskell is lazy by default, if you store a "value" somewhere it stores the computation that will produce it, not the result
20:20:22 <geekosaur> unboxed is one way to achieve strictness
20:20:50 <shachaf> It's a bit of a confusion of categories.
20:20:51 <geekosaur> another is case scrutiny (case somevalue of {x -> x} -- this makes somevalue strict without unboxing it)
20:21:08 <shachaf> There's no such thing as a strict value. A function can be strict in its argument.
20:21:26 <redbarron> And some decomposition based on pairs of strict values is being used by Vector to give better random access?
20:22:17 <grantwu> I think the random access part is just from having the values stored in not a linked list
20:24:03 <redbarron> I thought there was renaming going on so that it was still a linked list, but of values which were this type, making a kind of rose tree
20:24:32 <categoryTheoreti> I have a type (Maybe Record1, Maybe Record2) that I'm trying to serialized with acid state but I keep getting told No instance for (SafeCopy Record1).  Is there something simple I'm missing or do I need to add it as an instance?   If it matters, all fields in the records are Data.Text or [Data.Text].
20:25:33 <lpaste> milesrout pasted “Formulas & Existential Quantification” at http://lpaste.net/200273
20:25:50 <redbarron> Which would be how it related to the finger trees of Sequence
20:25:54 <milesrout> so I know this won’t work, because it’s trying to unwrap an existentially quantified thingy
20:27:09 <milesrout> given { data AnyT = forall a. MkT (T a) } you can’t do { case x of (MkT y) -> y }
20:27:30 <milesrout> but how can I kind of ‘work inside’ the polymorphism
20:27:36 <geekosaur> you may want a GADT
20:27:51 <milesrout> I um have one
20:27:54 <geekosaur> data AnyFormula where MkAF :: a -> Formula a
20:28:12 <geekosaur> now pattern matching MkAF will unwrap the a
20:28:17 <shachaf> geekosaur: There's nothing GADT syntax can do that regular ADT syntax can't do.
20:28:28 <shachaf> So "you may want a GADT" is a bit of an odd statement.
20:28:49 <milesrout> Formula a <— the a here is just a marker basically
20:29:12 <milesrout> problem is that if I have a list of formulas, they’re all of different types, so I made AnyFormula
20:29:47 <shachaf> milesrout: If you use this existential type, you can do anything with y that doesn't end up with a type involving "a".
20:30:58 <shachaf> Maybe you want something like: case a of MkF xA -> case b of MkF xB -> MkF (xB #& xB)
20:31:02 <milesrout> ooooh
20:31:20 <shachaf> But I think it might be even better to rethink your whole type.
20:31:37 <shachaf> But I'm not sure what you're doing with it so I'm not sure.
20:32:16 <shachaf> That second xB should be xA of course.
20:32:24 <redbarron> How can I know that Vector Array or Sequence will make use of the increased likelihood of accessing elements close to each other in order
20:32:26 <milesrout> the idea is this: modusPonens :: Formula (a -> b) -> Formula a -> Formula b
20:34:46 <redbarron> I know that these types have good random access, but in my application the access had weighted probability, i would like to embed this information about access use to shape the data structure to improve speed
20:35:28 <redbarron> Or to understand that one of those types does that
20:36:20 <milesrout> shachaf: thanks!
20:36:22 <milesrout> that worked perfectly
20:36:27 <Cale> redbarron: None of those really take advantage of read locality.
20:36:45 <redbarron> Thanks Cale
20:36:52 <Cale> redbarron: I suppose with unboxed vectors or arrays, you get to take some advantage of your CPU cache
20:37:22 <Cale> (boxed ones basically won't be too beneficial, since they're basically arrays of pointers to code...)
20:37:41 <redbarron> If I use list I can just use drop and that makes use of read locality right?
20:38:22 <Cale> Well, accessing a list in the order in which the elements occur is going to be optimal, but random access on lists is horrible
20:38:36 <Cale> You could similarly deconstruct a Sequence by chopping it into parts
20:38:51 <Cale> Seq has efficient (log cost) splitting
20:39:18 <redbarron> I guess there is an inflection point when distance of close random access becomes faster with Sequence
20:40:32 <Cale> Actually, I lied, there is an advantage to access locality with Sequence, having to do with the fact that the internal finger tree is lazily computed in a bunch of ways.
20:40:38 <redbarron> I guess Sequence can't do reverse faster
20:40:57 <redbarron> Cale, that's what I meant!!
20:41:13 <Cale> But that'll stabilize quickly
20:41:26 <Cale> and often the whole thing will already be evaluated
20:41:43 <redbarron> in my application I access every element once in a random order
20:42:41 <redbarron> But with weighted probability of successively accessing close values
20:43:28 <redbarron> It's kind of a fast shuffle
20:44:57 <redbarron> I guess I imagine having the first access defining a path through a tree and the next having to climb only slightly in the tree to get to the next element
20:45:03 <Cale> redbarron: I have to admit, a lot of the time I'd be like "whatever, this is going in a Map, and if it needs to be faster we'll think more after"
20:46:09 <redbarron> I'm trying to find use for my free zipper or modify it to use the good random access properties of Sequence
20:48:23 <redbarron> I imagine it would look like zipping a list with a shuffled version of itself, which should be faster if the pairs produced were close in the initial list
20:48:48 <maybefbi> how to write (- 1) :: Int -> Int in haskell
20:48:55 <maybefbi> haskell thinks it is (-1)
20:48:57 <Cale> maybefbi: subtract 1
20:49:02 <maybefbi> thanks
20:49:16 <redbarron> :t (\a->a-1)
20:49:18 <lambdabot> Num a => a -> a
20:49:20 <Cale> Or you can write things like (+(-1)) if you're golfing
20:49:36 <maybefbi> nah subtract is readable
20:50:21 <redbarron> :t flip (-) 1
20:50:23 <lambdabot> Num c => c -> c
20:53:01 <redbarron> Would it make sense to use Sequence in a zipper, I'm concerned that the backwards portion of a split is reversed in a zipper
20:54:42 <pavonia> maybefbi: In this case also "pred"
20:55:48 <glguy> pred is different from subtract 1 for one argument (at Int type)
20:56:11 <fr33domlover> @type (- 1)
20:56:12 <lambdabot> Num a => a
20:56:20 <maybefbi> actually im using :: Scientific -> Scientific, which is also Num
20:56:57 <pavonia> > (minBound - 1 :: Int, pred minBound :: Int)
20:57:00 <lambdabot>  (9223372036854775807,*Exception: Prelude.Enum.pred{Int}: tried to take `pred...
20:57:51 <lpaste> joobus pasted “Can this be simplified any?” at http://lpaste.net/200288
20:58:28 <joobus> k, I've posted an error handling example of a parseJSON instance.  I was just curious if it could be simplified any more.
20:59:41 <athan> Hey everyone, can you imagine a circumstance where aeson will fail to parse, but when you try manually it always succeeds?
21:00:02 <athan> i.e. I `show` the bytestring being parsed when I throw my error, and try the parse myself
21:00:05 <johnw> what does "try manually" mean?
21:00:16 <glguy> I'm going to go with not a top-level list or object
21:00:28 <redbarron> athan no that's impossible by definition surely
21:00:31 <athan> johnw: Using Data.Aeson.decode in ghci
21:00:40 <athan> it's astounding, but my results are consistent
21:00:53 <glguy> typical pure functions
21:01:05 <pavonia> joobus: mKey = maybe pure mzero
21:01:16 <athan> here is the error message thrown by eitherDecode, and the raw bytestring being parsed: http://lpaste.net/200290
21:01:29 <joobus> pavonia: thanks :)
21:02:15 <athan> "jsonrpc" is not present... when it's right there! It's very od
21:02:17 <athan> odd*
21:02:30 <glguy> MalformedRPCData isn't an Aeson error
21:02:44 <athan> it's a custom exception I throw when decoding fails :)
21:03:23 <athan> Stranger still, when I put something like `i <- obj .: "id"` before my query for jsonrpc, it will fail similarly, with "id" not being found
21:03:33 <athan> I'm guessing this is some kind of strictness or forcing error
21:03:54 <joobus> athan: can you post the code that is doing the parsing?
21:04:00 <athan> sure thing
21:04:26 <glguy> athan: What type are you trying to decode that as in GHCi?
21:04:58 <glguy> (If the answer is "I'm not specifying one." then you need to specify one)
21:05:15 <athan> joobus: http://lpaste.net/200292
21:05:27 <athan> glguy: It's a monomorphic type, with and instance and everything
21:05:38 <athan> specfically a `RPCResponse GotBalance` :)
21:06:15 <hoppfull> Why do we even have map when fmap does the job? Is it because of historical reasons? map comes from lisp or something like that?
21:06:17 <athan> I could link you all the git commit if you're inclined :x
21:06:47 <redbarron> No map is for list, the ultimate foldable container
21:07:01 <shachaf> The reason was to avoid confusing people.
21:07:05 <hoppfull> redbarron: fmap works on lists as well
21:07:12 <redbarron> There is deep voodoo in list
21:07:24 <redbarron> There is a reason it exists
21:07:26 <johnw> hoppfull: in days past, fmap was indeed called map, but apparently confusion arose
21:07:40 <hoppfull> johnw: Thanks.
21:07:51 <redbarron> And that is the same reason that it appears in the type of mconcat
21:08:46 <glguy> athan: The error is that it couldn't parse the result field
21:08:51 <glguy> because jsonprc wasn't in it
21:08:51 <athan> here is where aeson is failing: http://lpaste.net/200292#line22
21:08:59 <glguy> and jsonrpc is in fact not in the result field
21:09:07 <athan> glguy: But if you look at the exception I threw, it's obviously there!
21:09:14 <glguy> No, its' not there
21:09:22 <redbarron> list is more than just a functor which is Monad because it's a Monoid, it's the only one
21:09:24 <glguy> The result field has balance and unlocked_balance
21:09:28 <athan> and when I try to decode as a `RPCResponse GotBalance`, it works fine in ghci
21:09:33 <athan> the bytestring I mean
21:09:39 <glguy> athan: That means that your code is not trying to parse it as that type
21:09:41 <athan> oh, wait..
21:09:53 <athan> oh woah
21:10:12 <pavonia> redbarron: What are you talking about?
21:10:17 <athan> Ahh!! Thank you glguy!
21:10:20 <glguy> You're probably parsing a RPCResponse (RPCResponse a)
21:10:24 <redbarron> :t mconcat
21:10:26 <lambdabot> Monoid a => [a] -> a
21:10:50 <hoppfull> I've looked a little into Prolog in the past but not much. In Prolog I seem to remember functions can return several answers yet they are not lists so that sounds like a functor to me. Can we do stuff in Haskell like we do in Prolog where we sort of query a nondeterministic function for possible solutions? Or is a logical programming language the best place to do logical programming?
21:11:48 <athan> yeah you were right >< thanks glguy
21:11:55 <athan> did the $.result part tip you ff?
21:12:00 <athan> off*
21:12:25 <pavonia> hoppfull: Nondeterminism is what the list Monad instance is usually used for
21:12:33 <glguy> No, this part: failed to parse field result: key \"jsonrpc\" not present
21:13:42 <hoppfull> pavonia: interesting. Thank you!
21:17:08 <johnw> pavonia: https://wiki.haskell.org/Logic_programming_example
21:17:57 <pavonia> Was this meantfor hoppfull?
21:18:48 <grantwu> Anyone know much about ghc-mod?  I was wondering if it had a "insert case statement for type" capability
21:22:37 <johnw> pavonia: sorry, you're right
21:58:34 <[k-> johnw: What's the answer? The child is a girl, parent 1 is a female and parent 2 is a male, right?
22:10:52 <MarcelineVQ> johnw: I really like this link
22:14:25 <athan> Anyone off the top of their head know if there's an aeson parser for the empty object "{}"?
22:14:48 <glguy> Sure, the default aeson parser
22:14:50 <athan> The empty tuple () seems to only work for an empty list
22:15:05 <athan> sorry, an aeson parser instance*
22:17:30 <fr33domlover> athan, the empty object passes the parser indeed
22:17:42 <fr33domlover> {} is an object with an empty Map
22:17:52 <fr33domlover> to aeson, I mean
22:18:02 <athan> ahh okay
22:25:38 <jle`> athan: Map Void a, or Map a Void?
22:25:56 <athan> :s good idea...
22:26:03 <jle`> oh wait neither of those might have instances
22:27:14 <athan> Why doesn't haskell have unsigned types? Like UInt64 etc?
22:27:24 <johnw> Word64 is what it's called
22:27:24 <glguy> Data.Word
22:27:26 <athan> I mean I know you can peek into their unboxed variants
22:27:30 <athan> oh herp
22:27:43 <jle`> Word?
22:27:56 <glguy> Sup?
22:28:01 <athan> word on dawgg
22:28:29 <jle`> import Data.Dawgg
22:28:41 <elliptic00> data Point a = Pt a a
22:28:41 <elliptic00> Pt 1 2::Point Int
22:29:19 <elliptic00> Invalid type signature: Pt 1 2 :: Point Int
22:29:19 <elliptic00>     Should be of form <variable> :: <type>
22:29:23 <elliptic00> anyone know why I got following error: 
22:29:34 <jle`> can you post more context?
22:29:56 <jle`> you're not allowed to just have orphan expressions like that at the top level in haskell source code
22:30:16 <jle`> but it would work in ghci, because ghci takes expressions as input
22:30:47 <jle`> it might be that you're just writing a random expression in your file, which doesn't really make sense in haskell
22:30:48 <elliptic00> what is wrong with  that?
22:31:08 <jle`> haskell files are a list of declarations
22:31:17 <glguy> GHCi still isn't a Haskell source file
22:31:54 <jle`> so you can only put declarations in haskell files.  you can't really just put an expression in the middle of a haskell file, what would that even mean? :p
22:32:09 <jle`> but you can try it out in GHCi
22:33:43 <geekosaur> haskell is like c/c++/c# and java in that a source file has to contain a program with an entry point named main
22:33:58 <geekosaur> it doesn't handle bare expressions at top level
22:33:58 <elliptic00> what is wrong with this syntax:  Pt 1 2::Point Int 
22:34:07 <jle`> there's nothing wrong with that syntax
22:34:09 <geekosaur> are you listening>
22:34:20 <glguy> geekosaur: not today
22:34:25 <jle`> elliptic00: it's a valid expression
22:34:28 <geekosaur> apparently
22:34:34 <jle`> elliptic00: but you can't just put an expression at the top level of a haskell file
22:34:42 <geekosaur> it's a valid expression. expressions are not valid at top level in a source file
22:34:44 <jle`> maybe they're not a native english speaker?
22:34:47 <geekosaur> expressions are valid in ghci
22:34:50 <grantwu> elliptic00: Which other languages do you know?
22:35:06 <elliptic00> Java
22:35:10 <grantwu> (Trying to find an analagous example)
22:35:13 <grantwu> Okay, so
22:35:55 <grantwu> http://lpaste.net/200333
22:36:01 <grantwu> You understand why this isn't valid, right?
22:36:40 <elliptic00> Ok, thx
22:37:34 <grantwu> oh crap, I forgot to put the psvm inside a class
22:37:37 <grantwu> well uh... oopos
22:38:17 <geekosaur> main = print (Pt 1 2 :: Point Int)
22:38:26 <geekosaur> don;'t need a class or public static void
22:38:35 <grantwu> ?
22:38:46 <grantwu> Yes, well, I was trying to give an equivalent Java example
22:39:03 <geekosaur> oh oops I misread you as elliptic00
22:39:11 <glguy> >_<
22:39:29 * geekosaur maybe back away from keyboard for a while, sigh
22:42:32 <elliptic00> this line doesn't work in .hs file: main = print(Pt 1 2::Point Int) 
22:42:50 <grantwu> You need to put a space after the print
22:42:55 <grantwu> and you need spaces around your ::
22:43:02 <cocreature> does Pointi have a Show instance?
22:43:16 <grantwu> wait, actually
22:43:20 <grantwu> maybe you don't need spaces
22:43:24 <geekosaur> don't need a space actually
22:43:37 <grantwu> nvm, ignore me >_<
22:43:48 <geekosaur> "doesn't work" is not a helpful assertion. what exactly happens?
22:43:51 <geekosaur> @paste
22:43:51 <lambdabot> Haskell pastebin: http://lpaste.net/
22:44:08 <geekosaur> ^ full program and full error message to the pastebin. don't paste into the channel
22:44:12 <elliptic00> main = print (Pt 1 2 :: Point Int) 
22:44:20 <glguy> We've got to get a mode for GHC where it will just declare "didn't work"
22:44:23 <elliptic00> dones't work either
22:44:35 <elliptic00> I'm use .hs file, not on GHCi
22:44:36 <grantwu> elliptic00: Sorry, ignore what I said, the issue isn't the spaces
22:44:48 <grantwu> (but adding the spaces is good style; irrelevant at your stage)
22:45:09 <grantwu> We're going to need to see the declaration of Point to help you; preferably the whole program
22:45:28 <elliptic00> data Point a = Pt a a 
22:46:02 <glguy> deriving Show?
22:46:11 <elliptic00> data Point a = Pt a a
22:46:11 <elliptic00> main = print (Pt 1 2 :: Point Int) 
22:46:16 <grantwu> elliptic00: So, I'm assuming you're even more of a beginner than I am
22:46:16 <elliptic00> whole program
22:46:22 <cocreature> you don’t have a Show instance
22:46:23 <grantwu> If you look at the definition of print
22:46:27 <redbarron> Is there a module combing Sequence and Split?
22:46:45 <grantwu> print :: Show a => a -> IO ()
22:47:15 <grantwu> so, print takes in something of type a and yields an IO action.  a is contrained to be a type that is an instance of Show.
22:47:50 <grantwu> This might make other people here roll your eyes... but a decent analogy for typeclasses is Java interfaces
22:47:55 <elliptic00> data Point a = Pt a a
22:47:55 <elliptic00> main = print (Pt 1 2 :: Point Int) 	
22:47:59 <elliptic00> updated one
22:48:11 <grantwu> I... don't see any change
22:48:14 <elliptic00> data Point a = Pt a a
22:48:14 <elliptic00> main = print $ show (Pt 1 2 :: Point Int) 
22:48:19 <elliptic00> sorry
22:48:23 <elliptic00> I put show on it
22:48:28 <grantwu> er... not quite
22:48:32 <grantwu> Let me finish
22:48:33 <geekosaur> Show instance, not show function
22:48:43 <geekosaur> `print` does `show` already 
22:48:43 <grantwu> so, in Java, imagine you had something like
22:49:13 <grantwu> interface Show<T> { String show(<T> t); }
22:49:27 <grantwu> (not sure if I got the generic syntax right)
22:50:21 <grantwu> in java land, I would say "You're calling show on a class which doesn't implement the Show interface"
22:50:41 <grantwu> in Haskell, I'd say "You're applying show to a value of a type which is not an instance of the Show typeclass"
22:51:03 <grantwu> so, you need to make the Point type implement Show
22:51:22 <grantwu> which is easy - just add "deriving Show" to the end of the definition of the Point datatype
22:51:40 <grantwu> I don't understand exactly how this works, but I believe the compiler automagically derives a reasonable show instance
22:51:43 <redbarron> Type constraints implement inheritance
22:51:58 <fr33domlover> grantwu, s/calling show on a class/calling show on an object that's an instance of a class
22:52:08 <grantwu> oops, yeah.
22:52:17 <geekosaur> it does and there's an option that shows you the code it generates
22:52:21 <grantwu> I haven't written Java in almost 3 years!
22:52:28 <grantwu> :P
22:52:42 <geekosaur> -ddump-deriv
22:52:43 <fr33domlover> grantwu, haven't written any java for long time too, and i don't miss it at all :D
22:53:14 <geekosaur> that said,I think the code is outlined in the haskell 2010 report for the ones specified by the standard, including Read and Show
22:53:47 <elliptic00> data Point a = Pt a a deriving(Show)
22:53:47 <elliptic00> main = print (Pt 1 2 :: Point Int) 
22:54:21 <elliptic00> It works. awesome!
22:54:40 <elliptic00> Thanks grantwn
22:55:06 <elliptic00> how to make your name highlight in IRC?
22:55:07 <glguy> elliptic00: What are you using to learn Haskell?
22:55:32 <grantwu> elliptic00: I believe you spell it right :P
22:55:33 <elliptic00> online. reading wiki haskell.org
22:56:11 <elliptic00> and learnyouhaskell
22:56:19 <redbarron> I like how I can define a custom splitting strategy based on delimiter policies using Split, and I like how Sequence has fast update, but I'm not sure how to use the Splitter datatype with Sequence
22:56:48 <redbarron> https://hackage.haskell.org/package/split-0.2.3.1/docs/Data-List-Split-Internals.html
22:57:02 <elliptic00> Ok, I just reading some called Monad, and I need you guy help me a bit.
22:57:42 <redbarron> :t (>=>)
22:57:44 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
22:57:55 <redbarron> :t (.)
22:57:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:58:14 <elliptic00> reading some sth called Monads
22:58:16 <geekosaur> elliptic00, irc clients highlight a name if it's the first thing in a line. no prefixes or suffixes needed
22:58:32 <elliptic00> geekosaur hi
22:58:35 <grantwu> elliptic00: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html was extremely helpful for me
22:58:56 <geekosaur> (some clients will catch it if it's not the first thing but this is not guaranteed --- in fact I may be helping someone sort out some irssi issues with that tomorrow...)
22:59:12 <elliptic00> does your name highlighted?
22:59:16 <geekosaur> yes
22:59:24 <grantwu> word of warning though: I believe there are some nasty typos in the random number generator section
22:59:37 <grantwu> And it's all older Haskell, so it doesn't run without modifications to imports
23:00:05 <grantwu> I kind of want to go touch it up
23:02:09 <redbarron> I'm working on a publication called m monads are burritos, meant as an alternative to burritos for the hungry mathematician; https://www.cs.cmu.edu/~edmo/silliness/burrito_monads.pdf
23:03:45 <elliptic00> Ok, I spent couple hours on reading some Monads online in Library, and I'm very confusing. But I try to use ANALOG what I have understood matrix in Linear Algebra course.
23:04:01 <elliptic00> Hi, I'm just reading Monad in Wiki Haskell.org, and I found it is very confusing.
23:04:01 <elliptic00> but it seems to me I could think of {Monad three laws} as Matrix Multiplication in Linear Algebra.
23:04:01 <elliptic00> 1. Left identity matrix => I*A = A   [return >>= f == f]
23:04:03 <elliptic00> 2. Right identity matrix => A*I = A  [f >>= return == f] 
23:04:05 <elliptic00> 3. Associativity  A*B*C = A*(B*C)    [m >>=(\x -> g )>>= \y-> h == f >>= (\x -> g >>= \y -> h)
23:04:33 <elliptic00> can your guys give me some idea what is wrong my ANALOG?
23:04:52 <elliptic00> sorry, typo Analogy
23:05:19 <jle`> elliptic00: it's pretty much the same thing, but it's a better analogy if you state the laws in terms of (>=>)
23:05:25 <jle`> return >=> f = f
23:05:32 <jle`> f >=> return = f
23:05:40 <jle`> (f >=> g) >=> h = f >=> (g >=> h)
23:06:07 <geekosaur> this is the sort of thing math types live for --- you can often find such isomorphisms
23:06:08 <jle`> but i wouldn't call them "laws" of matrix multiplication
23:06:13 <redbarron> What is Strength?
23:06:35 <jle`> that's a deep question
23:07:15 <redbarron> I have flippers and a long straw
23:07:21 <grantwu> http://mathoverflow.net/questions/157230/expression-for-functor-strengths might be useful
23:07:33 <grantwu> I know no category theory though
23:08:13 <redbarron> No this makes no sense
23:08:53 <redbarron> It uses bad style
23:09:51 <redbarron> And other confusing techniques
23:10:33 <elliptic00> how do you guy learn Haskell? do your guy use write some interesting small projects to practice?
23:10:34 <redbarron> Such as coyonedas
23:10:49 <grantwu> I do not recommend doing what I am doing
23:11:09 <elliptic00> reading Haskell doc is boring
23:11:23 <redbarron> I eat bananas but my eyes bugged out
23:11:27 <grantwu> 1. Learn SML in a bunch of classes, 2. Meditate on the monad tutorial for a couple days, 3. Start writing a compiler for a class
23:11:52 <geekosaur> I did the old Gentle Introduction, then got involved with xmonad since I know X11
23:12:05 <grantwu> elliptic00: reading docs is always boring
23:12:06 <geekosaur> (the "Gentle Introduction" is .. not especially well named
23:12:07 <danilo2> Hello guys! I'm one of the founders of luna-lang.org startup, which creates isomorphic visual/textual programming language in Haskell. We've been recently selected by TechCrunch as one of the best startups from Europe and secured a seed round. We are looking for Haskell developers to join us. We are based in Poland / Krakow, but remote work could also be possible :)
23:12:23 <danilo2> If that is interesting to somebody here, Id love to chat! :)
23:12:28 <geekosaur> but it worked for me since I already had been exposed to both functional programming and SML)
23:12:30 <grantwu> Writing some toy program is usually a good idea, yeah
23:13:26 <nitrix> danilo2: Try your luck on the mailinglists if you want better exposure.
23:13:44 <redbarron> That looks fun danilo2
23:14:03 <danilo2> nitrix: That is a great idea! I'll do it. Anyway, if somebody would like to hcat with me directly, I'm often here :)
23:14:19 <danilo2> redbarron: yes it is indeed! :)
23:14:25 <grantwu> danilo2: Do you take interns?
23:15:12 <danilo2> grantwu: That only depends on the knowledge of a candidate. If you are passionate about functional programming and you are fluent in Haskell, then yes :)
23:15:32 <grantwu> Hrm... dunno if I'm fluent...
23:16:22 <grantwu> What is the difference between Luna and Haskell? it looks very similar
23:16:41 <danilo2> grantwu: drop me a line at contact@luna-lang.org and we can talk about it :)
23:17:20 <shachaf> What is the issue with the random number generator section?
23:18:24 <danilo2> grantwu: there are a lot of differences – Luna has dual representation. If you change the visual, the textual updates (and vice versa!). Luna has notion of objects, while Haskell has type classes (dont think Luna is Object Oriented in the classical meaning, it is just another way of thinking about the abstraction that betterm atches the visual patterns). Luna compiler understands
23:19:11 <danilo2> grantwu: what are monads and allows for aoutomatic lifting (something like effects on steroids). Moreover we strongly work with our type checker to make it more dependent type aware and to understand as much as possible, for example to understand dataflow errors
23:40:00 <cocreature> danilo2: looks like a cool project, sadly I’m not looking for a job right now ):
23:50:41 <sunjay> Is it possible to implement similar features to Idris in Haskell?
23:50:52 <srhb> sunjay: Yes, for instance, addition.
23:50:58 <srhb> sunjay: Are you thinking of something specifically?
23:52:26 <sunjay> From my very rudimentary understanding, dependent types are cool because you get to specify to some extent the contents of your type. Can something like that be implemented in Haskell?
23:52:57 <cocreature> are you asking if you can use dependent types in haskell right now or whether they could be added to ghc?
23:52:58 <srhb> sunjay: Partially. And with varying amounts of pain. For instance, length indexed vectors is quite possible nowadays.
23:53:07 <srhb> sunjay: You may want to check out Richard Eisenbergs work.
23:53:37 <sunjay> I guess I'm asking if they would fit. Idris was designed around dependent types, I don't know if those same concepts would work in Haskell
23:53:55 <danilo2_> cocreature: if you will be looking, just drop us a line! Im glad you like it! :)
23:54:03 <grantwu> sunjay: https://wiki.haskell.org/Dependent_type#Lightweight_Dependent_Typing may be helpful.
23:54:51 <sunjay> grantwu: http://cs.brynmawr.edu/~rae/ Is this who you are referring to?
23:54:56 <sunjay> Thanks for the link :)
23:55:24 <srhb> sunjay: That is who I was referring to.
23:55:55 <sunjay> srhb: Oh sorry I mentioned the wrong person. Thank you!
23:55:55 <grantwu> ? yeah, I think you meant srhb
23:55:56 <srhb> His adviser, Stephanie Weirich, has a number of talks on the topic as well.
23:56:07 <srhb> advisor?
23:56:15 <grantwu> i,i advisur
23:56:18 <sunjay> srhb: Awesome! I'll check that out
