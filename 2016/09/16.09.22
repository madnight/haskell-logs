00:00:05 <Ucenna> I'm slowly teaching myself Haskell, but I'll be actively learning javascript as part of a class.
00:00:07 <grantwu> WHen you say "self-enforced functional javascript" do you actually mean that, or do you mean one of the many languages that have Javascript as their primary compilation target?
00:00:21 <Ucenna> I'll be using javascript
00:00:31 <augur> Cale: when you say that haskell's stack is a stack of pattern matches, what do you mean, exactly??
00:00:38 <Ucenna> but any functional programming will have to be done on my own. 
00:00:47 <xuxu> i don't think i like the way data is returned in the rethinkdb driver anymore :) 
00:00:53 <augur> do you mean like a CEK machine stack? or something else??
00:01:03 * mikaunix
00:01:10 <Cale> augur: Well, consider what needs to happen when you try to evaluate an expression like  case f x y of Nothing -> ...; Just k -> ...
00:01:19 <xuxu> i'm pretty sure i can create a hashmap and retrieve information from it relatively easily with HM.lookup
00:01:33 <Cale> augur: Since neither of the patterns immediately matches, we need to evaluate the expression f x y
00:01:42 <Koterpillar> augur: https://github.com/quchen/stgi
00:01:51 <ongy> xuxu: ok then something that I can't see is weird
00:01:54 <augur> Cale: aha ok, so a CEK/SECD style stack :)
00:01:55 <Koterpillar> oh, maybe that's not what Cale means
00:02:15 <augur> where you have like..  a zipper into the first redex
00:02:35 <grantwu> augur: I don't claim to understand this at all, but I know this is what GHC uses: https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf
00:02:37 <xuxu> codedmart ^
00:02:50 <augur> Cale: what do you mean by a normal call stack?
00:02:53 <quchen> *Haskell* does not have a stack. *GHC* has a stack via the STG. The crux is that this stack does not store return addresses, but direct continuations to jump to when branching.
00:03:11 <Cale> augur: I mean the sort of stack that most imperative programmers would be familiar with
00:03:21 <quchen> The STG has three types of frames. One is for arguments/function calls, and that differs a bit between different implementations.
00:03:23 <augur> i dont know what those sorts are :x
00:03:27 <quchen> One is for updates, which are optimizations.
00:03:33 <augur> quchen: updates?
00:03:36 <quchen> And the last one is for pattern matching.
00:03:44 <xuxu> > hm = fromList [(1 :: Int, 'a'), (2, 'b'), (3, 'c')]
00:03:46 <lambdabot>  <hint>:1:4: error:
00:03:47 <lambdabot>      parse error on input ‘=’
00:03:47 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
00:04:09 <quchen> augur: x = 1+1; evaluating x triggers an update, overwriting the thunk with its WHNF
00:04:25 <augur> ok, right
00:04:26 <Cale> augur: Ah, okay, so the usual expectation is just when you apply a function *anywhere*, you put something on the stack to remember where to continue once the function's code has computed a value.
00:04:28 <quchen> It’s a hidden destructive update, and how laziness is implemented
00:04:33 <xuxu> hm = fromList [(1 :: Int, 'a'), (2, 'b'), (3, 'c')] ; HM.lookup 1 hm -- Just 'a'
00:04:49 <Cale> augur: But since lazy evaluation is outermost-first, we sort of don't need to do that usually.
00:04:52 <xuxu> at least i'm not going crazy and know how to deal with hashmaps
00:05:14 <xuxu> just having trouble navigating between types
00:05:28 <xuxu> i'm pretty sure the guy who wrote the rethinkdb driver was using best practices
00:05:37 <xuxu> not sure why i'm having so much trouble 
00:05:48 <augur> Cale: is that really a difference then in what *sort* of stack we have, or just a difference in how it gets built up/manipulated, in relation to the program?
00:06:08 <Cale> augur: Oh, the stack itself is a stack of code pointers, sure
00:06:20 <Cale> It's a difference in how it gets built up
00:06:24 <grantwu> huh?  Stack of code pointers?
00:06:34 <ongy> xuxu: try to litter your code with type annotations and see if it helps
00:06:38 <Cale> Yeah, like usual
00:06:56 <ongy> or put it in a file, that may get you better error messages
00:07:26 <xuxu> ongy: a file would give better error messages than those in ghci?
00:08:03 <grantwu> I don't believe the stack is usually only pointers to code
00:08:03 <grantwu> Spilled temps, for example...
00:08:05 <ongy> xuxu: I think it may in this case. Or just work because type inference has more information
00:08:12 <Cale> In either case, the stack tells you where you're going next.
00:08:34 <Cale> It's just "weird" in Haskell because the evaluation order is usually different
00:08:54 <shachaf> It doesn't seem very weird after you try evaluating a bit of Haskell code by hand.
00:08:58 <Cale> yeah
00:09:00 <shachaf> You naturally end up with the same stack in your head.
00:09:03 <hoppfull> I'm trying to refer to a type from a c library with foreign import ccall MyType :: ???
00:09:43 <Ashy> Cale: well that's weird, hdevtools works fine for a newly created project from the stack template yesod-hello-world
00:10:03 <ongy> hoppfull: you will have to define your own type
00:10:18 <hoppfull> ongy: With newtype?
00:10:42 <xuxu> interesting discussion around the ghc stack :) thanks everyone
00:11:00 <xuxu> quchen: thanks for covering all of the stack frames
00:11:21 <quchen> xuxu: The Readme of the STGi has a bit more detail on this
00:11:47 <quchen> https://github.com/quchen/stgi/#stack
00:12:03 <ongy> depends on what you want to do. If it's an opaque type I use EmptyDataDecls and 'data CType' and (Ptr CType) at points of use. If you need to introspect it, you will have too have a look at Marshalling
00:12:30 <Cale> quchen: That looks really cool, btw
00:12:41 <quchen> :-)
00:12:50 <xuxu> oh, wow it's late
00:12:52 <hoppfull> ongy: It's an opaque type and I don't want to introspect it. Just pass it around inside a monad I guess.
00:13:21 <Cale> and yeah, I'm leaving out some other types of stack frames here
00:13:49 <Cale> Mostly because if you're going to get a stack overflow, I don't think I've ever seen it be for any reason other than an excess of return frames :)
00:13:50 <hoppfull> ongy: An IO monad to be precise. Also, is "Ptr" in Foreign.C.Types?
00:15:56 <ongy> hoppfull: opaque C types are usually some typedef over an pointer. And we need to tell GHC that we are passing a Ptr around
00:16:04 <ongy> it's in Foreign.Ptr
00:18:14 <hoppfull> ongy: thanks! I think I've got what I need to progress a little further now
00:23:12 * hackagebot haskell-neo4j-client 0.3.2.3 - A Haskell neo4j client  https://hackage.haskell.org/package/haskell-neo4j-client-0.3.2.3 (asilvestre)
00:23:14 * hackagebot haskell-neo4j-client 0.3.2.4 - A Haskell neo4j client  https://hackage.haskell.org/package/haskell-neo4j-client-0.3.2.4 (asilvestre)
00:23:45 <hoppfull> A c function that takes no arguments and returns nothing, is the type IO () -> IO () appropriate for that?
00:24:13 <bartavelle> what would be the first argument ?
00:24:14 <Koterpillar> hoppfull: the signature you pasted _takes_ an IO action
00:24:43 <hoppfull> ok. So how do I pass nothing? Is there a unit value like in F#?
00:25:04 <Koterpillar> hoppfull: why not just have a type of IO () ?
00:25:35 <hoppfull> Koterpillar: hmm, didn't think of that. I'll try it! Thanks!
00:32:29 <Guest81290> Hi. I'm in cabal hell. I have this setup: http://imgur.com/a/rfnQQ where A, B and C are my own projects and D is a package on hackage I have no control over. When I compile A and B on their own it's all fine and well. But when I try to `cabal install` C it's telling me "Failed to load interface for foo. There are files missing in D".
00:33:29 <dmiles> zv: are you awake?
00:34:31 <ongy> Guest81290: does C have an explizit dependencie on D?
00:34:59 <dmiles> zv: i remember now the proof I came up with why conflict driven clause learning (CDCL) was manditory requirement in 1999
00:36:00 <Guest81290> ongy: yes
00:36:28 <ongy> Can you link the hackage page of D?
00:36:59 <Guest81290> ongy: that'd be https://hackage.haskell.org/package/megaparsec-5.0.1
00:38:15 <tinkyholloway> I'm confused by what I have to do to get a stack resolver on nix. In my stack.yaml I have nix: enable: true and resolver: lts-7.0. In my environment I have haskell.compiler.ghc801. I've read that this has all recently changed, but I can't find out how to do it
00:38:32 <dmiles> if you start out with authorial form called  Prenix normal form (PNF) -- and you work your way to (negated normal form) NNF , (conjuctive) CNF for and then to horn clauses Clausual form "by the book" that means you eliminate non horn clauses..  however after that is doewn and you are left with final forms.. if you do it the way books like SICP does it.. you cant recreate the PNF
00:39:29 <dmiles> thus it loses too much data and therefore too unsound and too incomplete to do anything other than program verification.. quite sad really
00:39:32 <ongy> Guest81290: I don't see anything that could cause weird things to happen. Can you paste your error message?
00:41:12 <dmiles> amitedly program verification is neat but bars from guided program synthesis 
00:41:59 <dmiles> the reason we have this techonlogy in the early 80s and no longer have this tech is due to people forgettign the "round truip rule"
00:42:13 <Guest81290> ongy: http://lpaste.net/208531 where "klparser" is A, "klprettyprinter" is B and "herple" is C in the diagram.
00:43:48 <dmiles> (round trip rule.. the data must be able to reproduce what the user or programmer wished to store... if it cant then that is adataloss)
00:44:29 <ongy> Guest81290: ah. If you have tried the ghc-pkg check command I'm out of ideas
00:45:02 <Guest81290> ongy: I did. It did nothing. Thank you anyway. :)
00:45:48 <dmiles> so what they were filling kids heads with the last few years doent meet the requirements described https://en.wikipedia.org/wiki/Round-trip_format_conversion
00:46:30 <dmiles> (filling kid's heads with the fact its ok to remove non horn clauses in SAT)
00:47:03 <dmiles> another lie they teach kids is that double negative emination is sane
00:47:27 <dmiles> it is not at least one modality must be inverted when we do that
00:47:47 <{AS}> Hi is there something like guard, but works well with MonadError?
00:48:06 <grantwu> I don't see why it's not sane... It's just not part of constructive logic
00:48:09 <dmiles> there is several default modalities of data for example   "known"  vs "askable"
00:48:37 <dmiles> it is sane as long as you invert something in the process  :)
00:49:16 <dmiles> that is not truth inverting but quantification or modal pair inversion
00:49:28 <{AS}> I guess when ... $ throwError ... would work
00:50:04 <dmiles> ~~foo(X)  might be   ~asserted(~foo(X))
00:50:37 <dmiles> or  ~~foo(X)  might be   ~nesc(~foo(X))
00:51:14 <dmiles> or could even be   all(X):~nesc(~foo(X))
00:52:43 <dmiles> even if you make it   all(X):isTrue(~~foo(X))    you still need to find the middele modality
00:53:04 <dmiles> it might really be:    ~all(X):isTrue(~foo(X)) 
00:53:59 <dmiles> often times we can convert those to ~~foo(X) and do double negative elination as long as we dont get dataloss
00:54:10 <dmiles> i have never seen a non dataloss example
00:55:09 <dmiles> for some peoples domains i think they can suffer small dataloss and that is ok
00:55:22 <dmiles> since they dont need to full power of logic
00:55:48 <dmiles> they dont need to use*
00:55:48 <{AS}> Is there a better way to have a local do-scope than using  _<- do? 
00:58:21 <zipper> ReinH: d00d?
00:58:38 <mniip> {AS}, just "do"
00:58:52 <{AS}> mniip: so I can have nested do's?
00:58:53 <{AS}> Thanks
00:59:25 <mniip> > do { do { do "moo" }; do { do { [1,2,3] }; do "a" } }
00:59:27 <lambdabot>  "aaaaaaaaa"
01:00:36 <{AS}> What monad was this run in? :)
01:00:39 <{AS}> but thanks!
01:00:52 <{AS}> > :t do { do { do "moo" }; do { do { [1,2,3] }; do "a" } }
01:00:54 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:00:56 <mniip> is this a question for me? in which case I do know the answer
01:00:56 <{AS}> :t do { do { do "moo" }; do { do { [1,2,3] }; do "a" } }
01:00:58 <lambdabot> [Char]
01:01:16 <{AS}> Ah interesting
01:02:19 <mniip> > [1,2,3] >>= "foo"
01:02:21 <lambdabot>  error:
01:02:21 <lambdabot>      • Couldn't match expected type ‘Integer -> [b]’
01:02:21 <lambdabot>                    with actual type ‘[Char]’
01:02:24 <mniip> > [1,2,3] >> "foo"
01:02:26 <lambdabot>  "foofoofoo"
01:02:39 <{AS}> "moo" >> [1,2,3]
01:02:43 <{AS}> > "moo" >> [1,2,3]
01:02:45 <lambdabot>  [1,2,3,1,2,3,1,2,3]
01:03:01 <{AS}> Ha
01:03:04 <{AS}> interesting
01:03:07 <mniip> it's really just 'concatMap (\_ -> "foo") [1,2,3]'
01:03:43 <{AS}> Yeah, you easily forget that [-] is a multiplicative monad
01:03:46 <{AS}> :)
01:04:29 <mniip> it's called []
01:04:51 <mniip> ([] x) = [x]
01:04:53 <hamid> folks... is this "Mio: A High-Performance Multicore IO Manager for GHC" right now implemented?
01:04:56 <{AS}> Oh
01:05:09 <ongy> > [] x
01:05:11 <lambdabot>  error:
01:05:11 <lambdabot>      • Couldn't match expected type ‘Expr -> t’ with actual type ‘[t0]’
01:05:11 <lambdabot>      • The function ‘[]’ is applied to one argument,
01:05:19 <mniip> well, in types
01:05:21 <ongy> > [] 'x'
01:05:23 <lambdabot>  error:
01:05:23 <lambdabot>      • Couldn't match expected type ‘Char -> t’ with actual type ‘[t0]’
01:05:23 <lambdabot>      • The function ‘[]’ is applied to one argument,
01:05:27 <mniip> :t undefined :: [] x
01:05:29 <lambdabot> [x]
01:05:32 <{AS}> > :k []
01:05:34 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:05:37 <{AS}> :k []
01:05:38 <ongy> this annoyed me for so long. Until I found out I can use return (or pure)
01:05:39 <lambdabot> * -> *
01:06:06 <shachaf> It means: Choose an element of "moo"; then choose an element of [1,2,3]; then use the value of the latter choice.
01:16:05 <grantwu> hamid: I think so
01:16:27 <phz_> updating my libraries for the new stackage lts to work…
01:16:41 <phz_> on 42 dependencies, 90% of the building time goes to lens…
01:16:45 <grantwu> hamid: https://mail.haskell.org/pipermail/ghc-devs/2013-February/000414.html
01:16:46 <phz_> which is a dep of a dep
01:16:55 <phz_> pfiou.
01:22:38 <bartavelle> pfiou!
01:23:14 * hackagebot binary-parsers 0.2.1.0 - Extends binary with parsec/attoparsec style parsing combinators.  https://hackage.haskell.org/package/binary-parsers-0.2.1.0 (winterland)
01:23:16 * hackagebot json-rpc-generic 0.2.1.2 - Generic encoder and decode for JSON-RPC  https://hackage.haskell.org/package/json-rpc-generic-0.2.1.2 (KeiHibino)
01:33:56 <Guest81290> Is there some sort of "local hackage"? We're having a bunch of packages at our working group - versions and all. But they are too specific for us to upload them to hackage. Can we somehow have that whole versioning and cabal-dependency stuff?
01:35:31 <merijn> Guest81290: You can run your own copy of hackage if you want, yes
01:35:50 <merijn> Guest81290: You can also specify multiple repositories in your cabal config, afaik
01:43:30 <hvr> merijn: you can actually even specify per-project add-on repos
01:43:45 <hvr> (to avoid cluttering ~/.cabal/config globally)
01:45:04 <m4lvin> why does this work? http://lpaste.net/208604
01:45:24 <Unhammer> say I have data A = B | C | D Text | E (Int -> Bool); cond x y z B = foo x y z fst;cond x y z C = foo x y z snd; etc
01:45:25 <Unhammer>  
01:45:27 <Unhammer> – is there a way to combine only the B and C cases into a function like "cond x y z |B→helper fst | C→ helper snd where helper …" so I don't have to repeat myself so much (B and C are very similarly implemented, D and E very different)
01:45:42 <merijn> m4lvin: Because that's perfectly fine the way do notation desugars
01:45:57 <merijn> @undo do { let x = 5; x + y }
01:45:57 <lambdabot> <unknown>.hs: 1: 23:Parse error: }
01:46:09 <merijn> @undo do { let x = 5; x + y; }
01:46:09 <lambdabot> <unknown>.hs: 1: 22:Parse error: ;
01:46:11 <merijn> hmmm
01:46:17 <merijn> oh, right
01:46:21 <m4lvin> ah, so i do not need a return, because with return x+y it fails
01:46:24 <m4lvin> ?
01:46:24 <merijn> @undo do { let {x = 5}; x + y; }
01:46:24 <lambdabot> let { x = 5} in x + y
01:46:30 <m4lvin> ah
01:46:38 <m4lvin> so the do allows me to leave out the "in"?
01:47:02 <merijn> m4lvin: I recommend learning the rules used to desugar do notation: https://en.wikibooks.org/wiki/Haskell/do_notation
01:47:04 <mniip> > do let x = 5; 3 + x
01:47:06 <lambdabot>  <hint>:1:20: error:
01:47:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:47:08 <mniip> shame
01:47:21 <m4lvin> ok, i always thought the "let ..." in a do block is a very different thing from let ... in ..., but that is not the case?
01:47:31 <merijn> mniip: See my last undo, you need to disambiguate the semicolon from the let block
01:47:44 <merijn> m4lvin: It's different, but not "very different"
01:47:49 <m4lvin> hehe
01:47:51 <lyxia> Unhammer: you could first pattern match against D and E, and then the rest in a wildcard.
01:47:52 <merijn> m4lvin: As shown in the wikibook
01:48:10 <m4lvin> yes, thanks for the suggestion!
01:49:18 <lyxia> Unhammer: oh not if they are not exactly the same, in which case you might use "case" + a helper function
01:49:46 <hamid> grantwu, oops i missed your reply. awesome! so we are already using the "mio".
01:51:11 <merijn> hamid: If you're using GHC >7.6 you're automagically using mio, yes :)
01:51:22 <hamid> +1
01:51:40 <merijn> hamid: Well, maybe you also need -threaded, not sure if mio did work on the single-threaded runtime too
01:51:53 <Guest81290> merijn: thanks
01:53:30 <amalloy> Unhammer: you could also perhaps redefine your type to reify the similarity a bit better: data Toggle = B | C; data A = Simple Toggle | D Text | E (Int -> Bool); cond x y z (Simple t) = foo x y z (helper t)
02:02:28 <Unhammer> lyxia,  hm, wildcards would remove pattern-match type checking though :/
02:02:57 <hamid> merijn, im really interested about its implementation as well. are these things usually modular?
02:03:01 <Unhammer> amalloy,  ah, that'd work … poor man's polymorphic variants =P
02:04:07 <merijn> hamid: The way GHC (and many high-level compilers) works is that you produce an executable from the compiled code, but for a lot of the "built-in" stuff you simply have a library and have the compiler insert a function call to that library
02:04:42 <merijn> hamid: So things like allocating memory, blocking until a file descriptor is ready, sleeping, running GC, allocating/reading MVars, etc. are just library functions in the runtime system
02:05:15 <merijn> hamid: Some languages (i.e., C) have a really tiny runtime system that does almost nothing. Others have massive runtimes taking care of lots of stuff
02:05:17 <hamid> merijn, awesome... so an interface to provide for example different io managers
02:05:40 <{AS}> What is the procedure for suggesting a Haskell feature?
02:06:00 <merijn> hamid: So, it is theoretically possible (although practically speaking a huge hassle) to write your own runtime system and use it to replace GHC's RTS
02:06:01 <MarcelineVQ> I'
02:06:15 <merijn> {AS}: Depends on the complexity, size and controversialness of the feature :)
02:06:21 <MarcelineVQ> {AS}: I'd make a trac ticket for it, if it makes sense to add to ghc
02:06:32 <merijn> {AS}: And whether it's a language feature, compiler feature or library feature
02:06:44 <{AS}> The size is small and the complexity is not too bad 
02:06:50 <{AS}> I can't comment on controversy
02:06:58 <{AS}> it's a language feature
02:07:35 <merijn> {AS}: Best places would be to write the proposal up on the wiki and submit it to either the ghc-devs or libraries mailing list and see how people respond
02:07:40 <mniip> C runtime haha
02:07:57 <mniip> point %rsp at a top of a mapped memory region and you're done
02:08:00 <merijn> mniip: You laugh, but it's there
02:08:09 <{AS}> merijn: MarcelineVQ thanks
02:08:13 <merijn> mniip: You need to setup the environment variables, argv, etc.
02:08:14 <mniip> unless you mean libc
02:08:20 <mniip> in that case it's by no means tiny
02:08:30 <merijn> mniip: Something needs to call main with some setup
02:08:48 <merijn> mniip: Like I said, tiny, but it exists
02:09:01 <beatdown> C has no "runtime system"
02:09:25 <beatdown> libc is not a runtime system
02:09:30 <mniip> beatdown, it has some invariants that count as an RTS
02:10:02 <merijn> beatdown: I'm not talking about libc
02:10:03 * beatdown writes some asm
02:10:24 <mniip> I've booted C on bare metal
02:10:32 <merijn> Something has to call main and call exit when main returns. That's the RTS
02:10:33 <mniip> more than that I booted lua on bare metal
02:10:38 <merijn> mniip: Yes, but that's a different standard
02:10:45 <merijn> mniip: The C standard specifies 2 Cs
02:10:54 <merijn> Freestanding and hosted environment
02:11:01 <merijn> Freestanding has no runtime system
02:11:04 <merijn> Hosted does
02:11:25 <mniip> not really sure which component you refer to by the runtime system then
02:11:40 <mniip> just the tiny wrapper between the entry point and main?
02:11:48 <merijn> mniip: "the part that calls main and exit"
02:12:07 <mniip> is that a useful analogy
02:12:17 <merijn> mniip: Yes, no, maybe
02:13:55 <merijn> hamid: Anyway, to get back on topic. The GHC runtime is actually pretty easy to poke around in (assuming you know C, obviously :p)
02:14:22 <mniip> ehhhhh
02:14:26 <merijn> hamid: If you compile with -debug (that uses the RTS with debug symbols) you can just load your haskell program into GDB and breakpoint parts of the runtime
02:14:27 <mniip> I wouldn't say that
02:14:58 <merijn> mniip: What? That it's easy to poke around in?
02:15:02 <mniip> yes
02:15:08 <mniip> even if you mean just the data structures
02:15:15 <merijn> It's by far the easiest C project I've poked around in
02:15:28 <merijn> (Possibly including my own C projects..)
02:16:29 <beatdown> Easy is subjective
02:16:35 <mniip> merijn, you've stopped on a gdb breakpoint, your first action?
02:16:41 <hamid> merijn, haha gonna try it then
02:16:51 <Zemyla> mniip: Get ye flask.
02:17:16 <mniip> (you are likely to be eaten by a grue)
02:17:18 <merijn> mniip: I debugged an overflow issue in the RTS as first attempt at poking around in it
02:17:42 <merijn> (That was why I was poking around in the first place)
02:17:52 <mniip> I did a similar thing, still, your answer?
02:18:12 <Zemyla> I remember debugging a program when I had no source access, just process monitor.
02:18:19 <merijn> Pretty sure breakpoint was the first thing I did once I started messing with the C part
02:18:37 <merijn> Because I was looking for calls to sleep(2)
02:18:45 <mniip> you can't do anything useful when stopped on a breakpoint unless you know exactly where to look
02:18:53 <mniip> for which you have to read pages and pages of docs
02:19:07 <merijn> mniip: You can look at the surrounding sources and inspect variables
02:19:50 <merijn> this statement doesn't make sense to me: "you can't do anything useful when stopped on a breakpoint"
02:19:58 <merijn> How else would you do *anything* in gdb?
02:20:07 <mniip> huh
02:20:19 <mniip> we're probably talking about different parts of the RTS then?
02:20:43 <iLetBigSHITS> I LET A MASSIVE SHIT
02:20:50 <iLetBigSHITS> IT CLOGGED THE TOILET
02:20:54 <merijn> mniip: I'm talking specifically about the C bits, I'm not sure which other bits you'd use gdb to look at?
02:20:58 <mniip> my adventures inside the RTS involved a lot of $rbp memory dumping, and casting $rbx into StgClosure * and taking an expedition inside it
02:21:01 <iLetBigSHITS> grumble: let me guess
02:21:04 <niko> iLetBigSHITS: do you need a irc break
02:21:15 <iLetBigSHITS> you joined because of in #debian you see other guy tell me go spam here?
02:21:21 <iLetBigSHITS> niko no, i just got here, lol
02:21:25 <merijn> mniip: Yeah, but then you're trying to look at *haskell* code executing inside the RTS
02:21:27 <iLetBigSHITS> but thx for the offer
02:21:32 <ezyang> Hey guys, is there a way to use 'assert' but passing a string message? 
02:22:08 <merijn> mniip: I was meaning things like: https://github.com/ghc/ghc/blob/24e05f48f3a3a1130ecd5a46e3089b76ee5a2304/rts/posix/Select.c
02:22:17 <mniip> hmm
02:22:22 <mniip> that might even have a useful stacktrace
02:23:00 <mniip> and debug info for variables and stuff
02:23:04 <mniip> what a luxury
02:23:09 <iLetBigSHITS> mniip, do you let big shits?
02:23:14 <merijn> mniip: Specifically I was debugging stuff like the select on line 331
02:23:15 * hackagebot luminance 0.11.0.4 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.11.0.4 (DimitriSabadie)
02:23:17 * hackagebot quickcheck-text 0.1.2.1 - Alternative arbitrary instance for Text  https://hackage.haskell.org/package/quickcheck-text-0.1.2.1 (fractalcat)
02:23:19 * hackagebot clang-pure 0.1.0.2 - Pure C++ code analysis with libclang  https://hackage.haskell.org/package/clang-pure-0.1.0.2 (PatrickChilton)
02:23:21 * hackagebot clang-pure 0.1.0.3 - Pure C++ code analysis with libclang  https://hackage.haskell.org/package/clang-pure-0.1.0.3 (PatrickChilton)
02:23:22 <mniip> iLetBigSHITS, kindly please leave
02:23:42 <merijn> mniip: Right. If you're in the C part and compile with -debug (which adds the C DWARF stuff) you just have a regular C stack trace, variables, symbols, etc.
02:23:48 <iLetBigSHITS> mniip, or what?
02:23:52 <merijn> mniip: So you can just step/breakpoint/whatever
02:25:25 <merijn> mniip: I agree that if you're trying to peer inside execution of Haskell code gdb isn't going to be really helpful :)
02:26:56 <mniip> I should probably go look for conseuquences
02:28:00 <lyxia> ezyang: I guess the best is to catch AssertionFailed and append your string to it before rethrowing it, if you want to keep the behavior of assert as much as possible.
02:29:14 <ezyang> lyxia: I came up with a perfectly horrible plan: put an error in the first arg to assert :) 
02:29:33 <mniip> ezyang, fix error
02:29:56 <ezyang> mniip: fix error? 
02:30:01 <ezyang> oh  
02:30:01 <mniip> > fix error
02:30:03 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
02:30:06 <ezyang> haha :) 
02:31:10 <lyxia> ezyang: Oh. Uh. Okay :D
02:32:47 <lyxia> I guess at this point you could redefine assert :: HasCallStack => Bool -> a -> a
02:33:08 <lyxia> uh with a String in there
02:39:17 <mettekou> I know the meaning of a namespace isn't always clear in Haskell, but when creating a new data type for specific kinds of text, should it live in Data.X or Text.X?
02:39:49 <mettekou> This is for a library I'm writing to upload on Hackage, not for a project of my own.
02:42:20 <mniip> merijn, my fix was this https://github.com/ghc/ghc/commit/a25bf2673d0f6db5f454619ddf91f974cace4e8b
02:44:18 <merijn> mniip: My fix was so confusing my first attempt inverted the bug, the second just reverted back to the original back and only my third actually fixed it :p
02:44:36 <merijn> mniip: And I somehow managed to get people to sign off on the first two fixes >.>
02:44:49 <merijn> And then I actually discovered a similar bug in the single-threaded version
02:45:15 <merijn> mettekou: I, personally dislike both the Data and Control prefixes
02:45:32 <merijn> mettekou: I prefer just taking unique top-level prefixes, like Pipes does
02:45:53 <mniip> just wait until we have Control.Control
02:46:03 <mniip> import Control.Control (Control(Control))
02:46:07 <mettekou> merijn: bound and unbound do it too. But is there a consensus in the community on that approach for the future?
02:46:21 <Cale> Data.Miscellaneous.Control.Stuff.Things
02:46:54 <Cale> Data and Control never should have been introduced
02:48:03 <Cale> It was just people went a bit giddy with power when hierarchical modules were added to the language, and every module name suddenly had to have a dot in it.
02:48:15 <merijn> mettekou: I think so, as long as you are considerate and don't take up "high value" real estate for a smalltime library
02:49:09 <mettekou> merijn: Yeah, that's the thing: the library will have a generic name. But if I can make it work it'll be useful to many people.
02:49:30 <merijn> mettekou: How generic is generic?
02:50:03 <mettekou> mettekou: English language word of two syllables generic. But not one you would expect on Hackage.
02:50:03 <hamid> are there sponser for ghc contributers? im curious
02:50:40 <hamid> *any sponsor
02:51:17 <merijn> hamid: I don't think so. Some of them hack on GHC as part of their dayjob
02:51:26 <mettekou> Ah damn, I tagged myself in that last message.
02:51:33 <merijn> The main bottleneck is lack of contributors, not lack of funding for the existing contributors
03:00:24 <hamid> merijn, why is that? i mean look at rustlang... it's glowing! but ghc seems slow maybe because it's a different paradigm with lots of new concepts?
03:00:47 <hamid> merijn, slow as in slow in development
03:01:13 <hamid> well it's not worth than iso c++ :D
03:06:57 <tdammers> rust has a huge high-visibility user behind it
03:07:21 <tdammers> the upside of that is that there's a lot of activity, but the downside is that there is also some pressure to "get things done"
03:08:24 <tdammers> e.g., quickly getting Rust into a production-ready state has been an important goal pretty much from day 1, while Haskell was a research language for much of its existence, so there was more pressure to experiment with novel ideas and less pressure to deliver something practically useful
03:09:17 <tdammers> that's not to say Haskell isn't practically useful; it just means that if in doubt, Haskell will lean towards theoretical soundness rather than direct practical benefits
03:10:56 <mniip> or both!
03:11:49 <mniip> just look at the levity polymorphism stuff!
03:42:36 <peti> Yo Emacs users. Has anyone updated to Emacs 25.1 already?
03:43:19 * peti tried to switch yesterday, but it seems like either haskell-mode or structured-editing-mode doesn't like the new version.
03:44:03 <peti> I cannot copy regions into the yank buffer, i.e. M-w doesn't seem to do anything.
03:55:50 <knupfer> Is it possible to write core in a haskell source?
03:57:52 <srhb> knupfer: No.
03:59:57 <MrElendig> knupfer: s/core/kernel/ ?
04:00:01 <knupfer> srhb: Ok thanks.
04:00:02 <MrElendig> if so, yes
04:00:08 <knupfer> MrElendig: Nein
04:00:42 <knupfer> I'd like to write core, which get's pasted literally into the core when compiling
04:00:45 <srhb> MrElendig: I think they are referring to GHC Core. :)
04:00:51 <knupfer> yep
04:00:53 <srhb> That was what my answer was about at least.
04:01:17 <knupfer> > print "core"
04:01:18 <knupfer> :)
04:01:19 <lambdabot>  <IO ()>
04:01:55 <mniip> 1474541850 [13:57:30] <srhb> knupfer: No.
04:02:01 <MrElendig> that shouldn't be impossible 
04:02:04 <mniip> not with a significant amount of template haskell
04:02:28 <mniip> by now I'm sure someone would have invented a library for that
04:02:44 <knupfer> mniip: perhaps with a compiler plugin
04:02:46 <MarcelineVQ> you could make a ghc plugin for it
04:02:50 <knupfer> yeah
04:03:07 <mniip> uhh
04:03:36 <bollu> can I get some sort of JSON / machine friendly output from "stack build"? 
04:03:50 <bollu> I want to get line numbers, etc. from a stack build invocation
04:05:38 <ilyanok> Anyone can show me how to use Data.Constraint.Forall module?
04:06:06 <ilyanok> I tried http://lpaste.net/208767 but ghc is not happy...
04:06:24 <knupfer> Is there some sort of a "Reduction stack browser"?
04:07:01 <knupfer> I want to inspect where my module fails on each reduction step, to know which type function I've to optimize
04:08:44 <mniip> what reduction do you mean
04:08:49 <mniip> constraint solving or?
04:09:01 <knupfer> -freduction-depth
04:09:25 <mniip> afraid not
04:10:08 <knupfer> Ok, in a hacky fashion that's easy to write myself, but I hoped for a polished solution
04:10:48 <knupfer> Something like compiling with -freduction-depth=1, collecting the error message and increasing the depth until it works
04:11:10 <knupfer> In my case, that would be more or less 3000 compiles :)
04:12:12 <knupfer> It would be really nice to have a stepper for the type checker...
04:21:32 <soLucien> hi guys ! as a beginner, should I use Parsec or ReadP 
04:21:41 <soLucien> i am supposed to choose one of them and argue for my choice
04:21:43 <knupfer> soLucien: attoparsec
04:22:06 <soLucien> is it the same as parsec ?
04:22:32 <knupfer> more or less
04:22:45 <knupfer> attoparsec is faster but has got less friendly error messages
04:22:55 <soLucien> i have to either choose one or the other
04:23:02 <soLucien> it's for my school project
04:23:13 <Phosphero> lol! @soLucien my name's Lucien, and there was a guy at my last work who would say "The soLucien is Lucien" every time I solved a problem for him
04:23:18 * hackagebot aeson-injector 1.0.6.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.0.6.0 (NCrashed)
04:23:42 <soLucien> and i did state that i am beginner, so i've done haskell for a total of 15 days
04:23:51 <soLucien> I am also Lucien :D
04:24:03 <soLucien> glad i'm not the only one
04:24:55 <soLucien> so i don't think "less helpful error messages" would help
04:24:58 <soLucien> :D
04:25:19 <knupfer> so take parsec or megaparsec
04:26:00 <bollu> has anyone had any luck with trifecta?
04:28:20 <Phosphero> so, I'm new to haskell, and I've been trying to set up a basic API using servant + persistent basing my code off of https://github.com/parsonsmatt/servant-persistent, but I'm getting a type error that's completely indecipherable to me: https://www.refheap.com/122799. 
04:28:45 <Phosphero> error occurs on line 23
04:28:55 <srhb> Phosphero: Some versions of the docs and examples refer to EitherT, some to ExceptT
04:29:18 <Phosphero> so am I mixing versions somehow?
04:29:31 <srhb> Phosphero: Yes, it appears that you need to use ExceptT instead of EitherT
04:29:58 <Phosphero> ah ok. so it's saying it's expecting an ExpectT, but finding an EitherT
04:30:21 <srhb> Phosphero: I'm actually a little confused whether it's one way around or the other, but yes :-P
04:31:38 <Phosphero> hm, since my readerToEither function is Config -> AppM :~> EitherT ServantErr IO, and I don't see an ExceptT used anywhere, it's probably what you said 
04:31:56 <knupfer> Can I compile a module using ghc api or similar? Or would I've to call an external ghc process?
04:32:06 <Phosphero> must be using a different package version than the example :/
04:32:43 <ph88_> do you guys like fixing errors found by the compiler ?
04:33:07 <knupfer> yes, why?
04:33:23 <Cale> ph88_: I like it a whole hell of a lot better than fixing errors not found by the compiler.
04:33:36 <ph88_> bcz i didn´t like all the errors, but now i start to like to fixing them
04:33:50 <ph88_> kind of unexpected
04:33:54 <knupfer> ph88_: I see the compiler as a friendly teacher
04:34:06 <Phosphero> I like it better than upgrading a javascript library, and finding out a week later that I broke the ability for people to create new users
04:34:19 <knupfer> ph88_: If you don't like his counsel, you can silence him with various flags
04:34:54 <ph88_> i don´t use any flags
04:34:56 <ph88_> just use ghci
04:35:24 <knupfer> It's a big aid for reasoning
04:35:55 <knupfer> You could turn off a lot of warnings and some errors, but I wouldn't recommend that.
04:36:17 <eklavya> when I say insert element set
04:36:36 <eklavya> why can't the compiler figure out that the type of insert can only be Data.Set.insert
04:36:41 <eklavya> and not Data.List.insert
04:36:42 <eklavya> ?
04:37:14 <ph88_> better not to turn off warnings and errors
04:37:37 <knupfer> eklavya: It can and it does
04:37:40 <StarsC> is there monad which is similar to Maybe monad but returns last successful case before failing with Nothing?
04:38:01 <eklavya> knupfer: it doesn't, I just fixed that error !
04:38:20 <eklavya> it says ambiguous 
04:38:53 <knupfer> eklavya: Ah, so you imported both
04:39:00 <eklavya> yes
04:39:25 <knupfer> Well, that's a name clash. You're right that it could use the type to differentiate a name clash
04:39:56 <eklavya> ok, just wanted to know if I was doing something wrong or was that really a limitation
04:40:09 <eklavya> thanks knupfer :)
04:40:21 <knupfer> eklavya: I wouldn't consider this a limitation
04:40:36 <knupfer> you actually say something like foo = 4; foo = 5
04:40:37 <eklavya> why not?
04:40:51 <knupfer> so the compiler doesn't know which definition to pick
04:41:23 <eklavya> I don't understand, how are these two cases similar?
04:42:04 <knupfer> When you import a module, it's just like if you'd have defined all those functions yourself
04:42:31 <eklavya> ok
04:42:36 <knupfer> And when you import two modules which export a function of the same name, it's like you've got two definitions for the same name
04:42:48 <knupfer> You could import qualified
04:42:51 <eklavya> why doesn't it error out than and there then
04:42:53 <knupfer> import qualified Data.Map as M
04:42:55 <knupfer> M.insert
04:43:00 <eklavya> yeah
04:43:10 <pavonia> The compiler could still try to match the types of both and see if one fits
04:43:33 <knupfer> pavonia: And what when both fit?
04:43:43 <eklavya> ambiguous :P
04:43:45 <Cale> It's not quite like that, because in particular it won't complain if you've imported things with the same names unless you actually go to use them
04:43:50 <pavonia> Then it could still report the ambiguity
04:44:13 <knupfer> I'd say it doesn't complain for convenience
04:44:44 <knupfer> So you don't have to specify precisely the functions you want to import, only because some names clash of functions which you don't use
04:44:56 <Cale> Well, also because you're allowed to explicitly qualify things when they do clash
04:45:48 <eklavya> Cale: so ghc just looks at the name and says there is a conflict and doesn't actually look at the types?
04:45:56 <buglebudabey> could someone help me figure out why my logic is incorrect in my code, leading to an out of index error for my matrix? pretty sure on line 28 or 30 http://lpaste.net/208820
04:46:02 <Cale> Like, you might have imported both module A and module B, and if one thing called foo happens to clash, you're allowed to refer to it by A.foo or B.foo as appropriate
04:46:04 <pavonia> Checking all possible identifiers would give exponential time complexity in the worst case, though
04:46:13 <Wizek_> Does anyone know of a way to search for instances of how people use certain operators? E.g. in source code hosted in hackage or github? Unfortunately most search engines I try seem to not to support non-alpha-numeric queries such as ">=>".
04:46:13 <knupfer> eklavya: yes
04:46:34 <Cale> eklavya: That's correct, it can't even start typechecking until it figures out what everything refers to
04:46:43 <eklavya> ok
04:46:47 <eklavya> got it
04:46:57 <Phosphero> srhb: Yay! compiler is happy now :) thanks for the help.
04:48:01 <Cale> eklavya: Though, I think there are some ugly provisions to try to defer that decision until typechecking for the case of record fields...
04:48:30 <eklavya> in the new record impl or in the old one too ?
04:48:39 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-field-disambiguation
04:48:54 <Cale> DisambiguateRecordFields -- it's been around for a while
04:49:06 <eklavya> ok
04:49:20 <eklavya> I thought before ghc 8 you couldn't have a record name clash
04:49:59 <Cale> It only works to disambiguate inside of record constructions and pattern matches involving the data constructor explicitly
04:50:11 <nathyong> Wizek_: a bit of a long shot, but try http://symbolhound.com/?q=%3E%3D%3E
04:50:13 <eklavya> ok
04:50:33 <Cale> So I guess it doesn't actually look at the type
04:50:50 <Cale> It just looks at which data constructor is involved, and uses that to disambiguate the field
04:52:30 <eklavya> ok
04:53:03 <Cale> Generally, I would try to avoid that though
04:53:27 <Cale> Treat record fields like you would the names of any other functions
04:55:44 <Phosphero> @Wizek what about hoogle?
04:55:44 <lambdabot> Unknown command, try @list
04:58:06 <soLucien> so Parsec ?  http://pasteboard.co/68P0peBoQ.png
04:58:32 <soLucien> i have to argue for my choice in the report
04:58:44 <soLucien> so why should I use parsec over ReadP ?
04:58:49 <soLucien> or the other way around
04:59:48 <soLucien> my colleagues are using readP because it seems "easier" , but i would love to hear what someone more experienced thinks about it
05:00:03 <pavonia> Parsec has a lot more usefull combinators
05:01:01 <pavonia> Oh wait, seems ReadP has grown a bit
05:02:29 <Cale> Because of the way you run ReadP parsers using ReadP_to_S, it's impossible to get good error messages about parse failures
05:02:51 <soLucien> so in the end it's a matter of choice? Look at the API and see which one is best in my opinion ?
05:03:05 <knupfer> soLucien: use parsec
05:04:10 <soLucien> okay, sure  .. i'm also leaning in that direction
05:04:10 <antipsychiatry> Hi
05:04:11 <Cale> If you like the symmetric choice of ReadP, you might want to check out attoparsec
05:04:20 <soLucien> but why ? I have to argue for my choice
05:04:23 <Wizek_> nathyong, Yeah, I've been trying that search engine, although its index seems to be horribly incomplete. E.g. http://symbolhound.com/?q=%3E%3E%3D&l=&e=&n=&u=github.com <-- seemingly no haskell project on github ever uses the bind operator, only a single scala project has it defined. That seems unlikely to me. 
05:04:49 <nathyong> ah, sad. I guess running a search engine has its costs
05:05:49 <Cale> attoparsec is able to produce reasonably decent error messages, it supports incremental parsing, its parsers always backtrack on failure (so you don't have to worry about 'try' like with Parsec)
05:06:29 <soLucien> i have to choose between ReadP and Parsec
05:06:32 <Cale> and it's generally a bit faster
05:06:35 <soLucien> there's no attoparsec choice
05:06:47 <Cale> Why not?
05:06:52 <knupfer> So take Parsec, and later on it's easier to switch to attoparsec in other projects
05:07:03 <soLucien> because it's a uni assignment
05:07:04 <knupfer> Cale: It's the homework spec :)
05:07:10 <Cale> ah
05:08:30 <soLucien> okay, Parsec
05:08:35 <soLucien> it is decided
05:08:44 <Cale> It's kind of an arbitrary decision
05:08:58 <soLucien> but i have to argue for my choice, why would you choose Parsec over readP ?
05:08:59 <Cale> You can always switch later, the refactoring which is required is usually minimal
05:09:14 <soLucien> yes, because the haskell code looks like the grammar :D
05:10:55 <Cale> The main advantages of ReadP are that it has a symmetric choice operator, and that parsers can arbitrarily backtrack without needing special annotations
05:11:06 <Cale> Most everything else, Parsec is better at.
05:11:14 <knupfer> soLucien: And the disadvantage of ReadP is for example the errors
05:11:56 <knupfer> An advantage for ReadP would be the lack of dependency
05:12:36 <knupfer> An the name of the parser is more informative
05:14:04 <Cale> Yeah, Parsec produces nice parse errors for you, and includes a way for you to annotate parsers to improve them further. It has better performance than ReadP generally (especially in cases where the grammar is LL(1), so that you don't need to use 'try'). Parsec can be used as a monad transformer, if you're so inclined, and is capable of operating on ByteString and Text.
05:14:30 <Cale> Parsec can give you information about the position in the document (line and column) where you're currently parsing.
05:15:09 <Cale> It has support for permutation parsing, and some functions for easy construction of expression parsers.
05:15:45 <Cale> oh, and not just Text and ByteString, but also Parsec can parse streams of tokens too, so if you wanted to do lexing separately, that's possible
05:16:49 <knupfer> soLucien: Your homework spec is quite horrible. Parsing "38 + 4" as Call "+" [Number 38, Number 4]
05:16:54 <knupfer> That's gross
05:16:54 <soLucien> that's great, thanks a lot cale and knupfer
05:16:56 <soLucien> yes
05:17:00 <soLucien> it is horrible
05:17:08 <soLucien> i had to write an intepreter last week
05:18:01 <knupfer> And it mixes parsing with io (!)
05:19:04 <soLucien> for this AST http://lpaste.net/4438581909932474368
05:19:18 <soLucien> now i have to generate the AST from javascript
05:20:16 <knupfer> use ghcjs :1
05:20:18 <knupfer> :1
05:20:25 <knupfer> :P
05:20:46 <soLucien> i would if i wouldn't have to write it myself :D
05:25:12 <Phillemann> Is there no function "(a -> b) -> (a,a) -> (b,b)"? I'm currently using bimap f f, but it's incredibly repetitive.
05:26:48 <bollu> :t (***)
05:26:50 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:27:07 <int-e> :t join (***)
05:27:07 <bollu> :t (+ 1) *** (+ 1)
05:27:08 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
05:27:09 <lambdabot> (Num b', Num b) => (b, b') -> (b, b')
05:27:12 <{AS}> is there a way to get type safe accessors and updaters for disjoint records?
05:27:17 <bollu> ^ I think that should work.
05:27:22 <bollu> int-e: what's join?
05:27:25 <bob_twinkles> fmap would work as well
05:27:35 <bollu> it's funny, I don't understand arrows properly and yet I use them as tuple combinators
05:27:36 <int-e> bollu: in this case, (r -> r -> a) -> r -> a
05:27:37 <bollu> idk if that's most people
05:27:52 <bollu> int-e: oh, monadic join?
05:27:54 <int-e> :t join
05:27:56 <lambdabot> Monad m => m (m a) -> m a
05:27:59 <int-e> bollu: yes.
05:28:42 <bollu> int-e: what does (>>=) do for (-> a)? I've never asked
05:29:18 <int-e> bollu: a >>= f = \r -> f (a r) r
05:29:19 <phadej> Phillemann: 
05:29:24 <phadej> :t over both
05:29:26 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
05:29:37 <phadej> > over both (+1) (2, 3)
05:29:39 <int-e> bollu: it's the reader monad (hence the name r)
05:29:40 <bollu> ah
05:29:41 <Phillemann> Damn. I just wrote exactly the same function by hand :D
05:29:42 <lambdabot>  (3,4)
05:29:48 <bollu> int-e: interesting
05:30:01 <Phillemann> phadej: Thanks.
05:30:41 <phadej> Phillemann: that's an enter to the lens-rabbit-hole
05:30:45 <phadej> though
05:31:05 <Phillemann> I rabbit hole I already have a foot into by using wreq.
05:31:14 <phadej> :)
05:31:20 <Phillemann> Doesn't feel weird yet.
05:33:27 <phadej> I have problem to keep lines short, as I don't write specialised functions with `lens` that much
05:33:56 <EEVV> > max 2 3
05:33:59 <lambdabot>  3
05:34:05 <EEVV> > let max = max 2 3 in max
05:34:08 <lambdabot>  error:
05:34:08 <lambdabot>      • Occurs check: cannot construct the infinite type:
05:34:08 <lambdabot>          t5 ~ t3 -> t4 -> t5
05:34:15 <EEVV> can someone help?
05:34:21 <EEVV> oh
05:34:21 <EEVV> wait
05:34:23 <EEVV> xD
05:34:24 <geekosaur> EEVV, let is recursive
05:34:26 <EEVV> maybe....
05:34:28 <EEVV> yeah
05:34:33 <EEVV> > let x = max a b in x
05:34:35 <lambdabot>  max a b
05:34:35 <EEVV> oops
05:34:37 <EEVV> oh
05:34:38 <EEVV> ok
05:34:55 <geekosaur> ...
05:35:02 <byorgey> that was... odd
05:35:09 <srhb> Some people do need s/n/. /
05:35:12 <srhb> er \n
05:35:37 <M2tias> yep
05:47:55 * byorgey waves hello from the Haskell Symposium in Nara, Japan
05:48:03 <bartavelle> ah, lucky!
05:48:10 <byorgey> some nice talks today, videos should be online soon (within a few days)
05:48:26 <bartavelle> have fun!
05:48:52 <byorgey> I am indeed both lucky and also having fun!
05:48:59 <bartavelle> hehe
05:49:30 <byorgey> bartavelle: where do you live?  Next year will be in Oxford, maybe that will be closer?
05:49:47 <bartavelle> france, so yeah
05:50:14 <bartavelle> all things considered I'd rather coerce my employer to send me to Nara than to Oxford though!
05:50:33 <byorgey> hehe, fair enough
05:56:37 <Insanity_> byorgey: will all talks be online?
05:56:46 <Insanity_> Including the lightning talks
05:58:45 <byorgey> Insanity_: my understanding is yes
05:58:52 <Insanity_> Cheers
05:59:04 <byorgey> I am not 100% sure about the lightning talks but I don't know why they wouldn't be put online
05:59:37 <phadej> last year they were in the single video
06:03:15 <Sagi> under which circumstances can an expression which throws an Exception e get past my catch specifically for e? I'm really confused by what I'm seeing. The stacktrace produced by +RTS -xc goes right through the function doing my exception handling.
06:09:25 <lpaste> Sagi pasted “TypeDecodingFailed gets past Exception handler for ASN1Error?” at http://lpaste.net/8391662335927779328
06:13:59 <ClaudiusMaximus> Sagi: E.evaluate only evaluates to WHNF (outermost constructor), so if the exception occurs deeper in the structure it'll escape the scoope of the E.catches
06:16:11 <delYsid> Trying to figure out how to use Language.Haskell.TH.dataD.  Can anyone point me to a relatively small self-contained example?
06:16:18 <Sagi> ClaudiusMaximus: hmm, so I should take a look at deepseq?
06:17:45 <lyxia> Sagi: since you're returning a tuple maybe the error will appear just from evaluating one of the three components?
06:18:24 <ClaudiusMaximus> Sagi: that would be one solution; alternatively restructure the pure code to use things like Either or Maybe instead of IO exceptions
06:19:04 <Sagi> yeah, it's the asn1-encoding library which generates them, not me
06:19:18 <Sagi> so that's not really an option within my current time budget
06:19:25 <ClaudiusMaximus> sure
06:19:40 * Sagi will have a look at deepseq
06:19:44 <Sagi> thanks!
06:23:21 * hackagebot clang-pure 0.2.0.0 - Pure C++ code analysis with libclang  https://hackage.haskell.org/package/clang-pure-0.2.0.0 (PatrickChilton)
06:32:50 <Axman6> glguy: re foldl-statistics, thanks! did you do something to fix that? (and is it something I could've done?)
06:40:10 <EEVV> How can I apply a function over a list?
06:40:20 <delYsid> :t map
06:40:22 <lambdabot> (a -> b) -> [a] -> [b]
06:40:22 <erisco> EEVV, fmap
06:40:38 <EEVV> erisco, thanks
06:41:25 <M2tias> erisco: why not jsut a map?
06:41:48 <EEVV> :t fmap
06:41:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:42:02 <EEVV> I don't get the `f a` and `f b`
06:42:16 <EEVV> is this some kind of parameter recursion?
06:42:20 <erisco> why not differently named functions for all types?
06:42:39 <merijn> EEVV: It's a type variable, like 'a' and 'b' are
06:42:47 <M2tias> erisco: it's there, I'm not asking to implement it
06:42:59 <erisco> EEVV, when you use fmap for lists, f becomes [], i.e. list, so '[] a' is a list of a's, and '[] b' is a list of b's
06:43:12 <EEVV> merijn, so it says that the function (a -> b) returns a type f and `a`, `b` are an `f` type?
06:43:41 <merijn> EEVV: No, it returns "f a -> f b" where 'f' and 'a' and 'b' are types
06:43:55 <merijn> EEVV: And 'f' is a type that takes another type as argument, such as Maybe
06:44:22 <EEVV> uhm
06:44:24 <EEVV> ok
06:44:38 <erisco> M2tias, I think modernising Prelude and base is a good thing, which means letting go of old choices
06:44:57 <M2tias> erisco: now that's a better answer
06:45:17 <M2tias> map is just way easier for noobs like EEVV and me
06:45:36 <M2tias> to understand the type descriptor
06:46:02 <erisco> M2tias, I disagree, because what does "modernising" entail? it entails what I first said, reducing the number of names and definitions required, i.e. genericity
06:46:25 <EEVV> `f => (a -> b)` is confusing to me
06:46:47 <erisco> yes, well, I do not think base should be designed for novices
06:47:06 <M2tias> perhaps
06:48:06 <EEVV> Why does `print $ map fibonacci [0..100]` block?
06:48:28 <Insanity_> What are you trying there EEVV?
06:49:00 <EEVV> Insanity_, trying to create a list of fibonacci numbers
06:49:06 <EEVV> or, rather, display
06:49:23 <Insanity_> map applies a function to each element in the list
06:49:30 <Insanity_> I'm not sure if that is the best approach here
06:49:47 <M2tias> it works 8)
06:50:02 <EEVV> > map succ [0..10]
06:50:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11]
06:50:20 <EEVV> Insanity_, maybe I can't print it?
06:50:35 <Insanity_> how did you define the function "fibonacci"?
06:51:00 <erisco> EEVV, how did you define fibonacci?
06:51:01 <EEVV> Insanity_, not using foldr, but the conventional approach (the recursion example approach)
06:51:20 <EEVV> oh woops
06:51:27 <EEVV> I confused factorial and fibonacci
06:51:28 <erisco> did you forget a base case? there are two
06:51:33 <Insanity_> O.o
06:51:44 <Insanity_> Well those are quite different things EEVV :P
06:51:57 <erisco> how did you define factorial?
06:51:58 <EEVV> Insanity_, yes :D http://lpaste.net/208972
06:52:50 <erisco> how did you run this program?
06:53:04 <EEVV> erisco, I compiled it, and ran the executable file
06:53:29 <erisco> pastebin the complete program please
06:54:26 <EEVV> erisco, http://lpaste.net/208976
06:55:40 <michi7x7> recursive madness?
06:55:44 <yulax> buffer #tardis
06:55:47 <yulax> oppos
06:55:49 <yulax> ooopss
06:55:51 <erisco> I am guessing it is to do with the output buffer
06:55:55 <ahihi> it blocks because standard output is line-buffered by default
06:56:09 <erisco> it might not be producing enough characters before you fall off the deep end computationally to flush the buffer
06:56:13 <ahihi> so you'll only see the print once the entire list is computed
06:56:18 <ahihi> which will take a long time
06:56:38 <ongy> shouldn't it also flush when the buffer is full?
06:56:46 <michi7x7> > fix (\x -> 1 : 1 : zipWith (+) x (tail x))
06:56:48 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:57:13 <Insanity_> EEVV: you don't need a map there
06:57:17 <EEVV> ahihi, what? How comes I can print thousands of fibonacci numbers in a program made using an imperative programming language? :(
06:57:31 <Insanity_> And you can use an infinite list as well
06:57:36 <ahihi> EEVV, you can't using this approach
06:57:36 <erisco> your fibonacci algorithm sucks, that is why
06:57:39 <Insanity_> using your implementation of fibonacci, you could use list comprehension like so
06:57:51 <EEVV> erisco, thanks for your criticism
06:58:01 <Insanity_> take 100 [fibonacci x | x <- [1..]]
06:58:03 <EEVV> Insanity_, how do I do it without a map?
06:58:05 <ahihi> you can replace the print with e.g. mapM_ print, to print line by line
06:58:05 <EEVV> oh
06:58:06 <michi7x7> EEVV: your program is exponentially complex. Try the same implementation in C and you will get an stack overflow pretty soon
06:58:18 <erisco> EEVV, heh ;) well, it is a standard example of "don't do this" in introductory courses on algorithms
06:58:20 <EEVV> michi7x7, I did it with a foor loop ;)
06:58:22 <ahihi> or disable output buffering
06:58:23 <EEVV> for*
06:58:34 <EEVV> all I got was integer overflows
06:58:37 <erisco> EEVV, like a bubble sort, you could say, except even worse
06:59:07 <ongy> EEVV: then that would be more like the infinit list
06:59:11 <michi7x7> EEVV: try this: fibs x = 1 : 1 : zipWith (+) x (tail x)
06:59:12 <tefter> here is good fibo algo ; http://pastebin.com/e130k218
06:59:19 <ongy> erisco: isn't bubble sort n^2? So far worse than bubble sort
06:59:26 <EEVV> michi7x7, but I don't understand that
06:59:35 <michi7x7> this will give you an endless-list, that you can actually print until memory overflow
06:59:39 <erisco> ongy, I acknowledged that
07:00:26 <michi7x7> EEVV: it's also wrong... oh my. fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
07:00:48 <EEVV> michi7x7, what is zipWith? Just adding a list (if I remember)
07:01:16 <hpc> > zipWith (++) ["one", "two"] ["apples", "oranges"]
07:01:18 <lambdabot>  ["oneapples","twooranges"]
07:01:25 <michi7x7> EEVV: think of it like so: fibs is an endless list, tail drops the first element. so the first argument to zipWith is [1,1,2,...] and the second argument is [1,2,3,...]
07:01:36 <michi7x7> zipWith combines this 2 lists using (+)
07:02:01 <EEVV> michi7x7, I understand tails. Does 1 : 1 just create a list [1, 1]?
07:02:14 <michi7x7> > 1 : 1 : []
07:02:16 <lambdabot>  [1,1]
07:02:27 <EEVV> > 1 : 1
07:02:29 <lambdabot>  error:
07:02:29 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M634698091619...
07:02:29 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:02:29 <michi7x7> it prepends to a list
07:02:51 <lpaste> chpatrick pasted “Printing out all function types in a C++ file in 7 lines of Haskell” at http://lpaste.net/208985
07:03:18 <EEVV> michi7x7, but if your fibs isn't a function, then is it a list?
07:03:53 <EEVV> > fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
07:03:55 <lambdabot>  <hint>:1:6: error:
07:03:55 <lambdabot>      parse error on input ‘=’
07:03:55 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
07:04:28 <michi7x7> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
07:04:30 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
07:04:43 <EEVV> Coolk
07:05:03 <michi7x7> EEVV: well, it doesn't take any arguments. Doesn't mean it's not a "function"
07:05:05 <Cale> Note also this technique:
07:05:14 <srhb> michi7x7: That's exactly what it means.
07:05:18 <Cale> > let fibs x y = x : fibs y (x+y) in fibs 0 1
07:05:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:05:36 <Cale> It might be more intuitive why that one works, and it generalises in some other ways.
07:05:38 <michi7x7> srhb: I've always had my problems with naming things in Haskell
07:05:42 <srhb> michi7x7: :)
07:05:50 <merijn> michi7x7: The first 26 things are easy ;)
07:06:02 <EEVV> > foldr (*) [1, 2, 3]
07:06:04 <ongy> m: but that's bad style
07:06:05 <lambdabot>  error:
07:06:05 <lambdabot>      • No instance for (Typeable t0)
07:06:05 <lambdabot>          arising from a use of ‘show_M596903159589432033817259’
07:06:12 <Cale> > foldr (*) 1 [1,2,3]
07:06:14 <lambdabot>  6
07:06:17 <ongy> merijn: also we have unicode support in GHC so...
07:06:26 <EEVV> > foldr (*) 2 [1, 2, 3]
07:06:28 <lambdabot>  12
07:06:50 <EEVV> Cale, what is that parameter after the function (*) for?
07:06:57 <EEVV> just multiply the end result?
07:07:09 <Cale> EEVV: foldr f z replaces each (:) in the list with f and the [] at the end (if any) with z
07:07:24 <Cale> @src foldr
07:07:24 <lambdabot> foldr f z []     = z
07:07:24 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:07:26 <EEVV> Cale, oh
07:07:28 <EEVV> I see
07:08:07 <EEVV> > [1, 2, 3]:1
07:08:09 <lambdabot>  error:
07:08:09 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M352706148791...
07:08:09 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
07:08:20 <michi7x7> Cale: that's by far the best explanation of fold I've seen
07:08:33 <michi7x7> EEVV: other way round
07:08:35 <michi7x7> :t (:)
07:08:36 <lambdabot> a -> [a] -> [a]
07:09:02 <EEVV> michi7x7, I remember you can get the head and tail of a list by doing (x : xs), but how do I make the bot print the head?
07:09:25 <EEVV> michi7x7, or is that reserved for parameters?
07:09:26 <ongy> > let (x:xs) = [1..] in x
07:09:28 <lambdabot>  1
07:09:49 <EEVV> > let (x : xs) = [1..2] in xs
07:09:51 <lambdabot>  [2]
07:10:01 <EEVV> why haskell gotta be so confusing ;-;
07:10:05 <michi7x7> > case [1,2,3,4] of (x:xs) -> x
07:10:07 <lambdabot>  1
07:10:24 <ongy> it's not. once you understood the principles. But then there's extensions...
07:10:27 <michi7x7> > case [1,2,3,4] of (x:y:z:xs) -> x+y*z
07:10:29 <lambdabot>  7
07:10:50 <EEVV> > let (x : xs : xss) = [1..9] in xs
07:10:52 <lambdabot>  2
07:11:06 <michi7x7> EEVV: Haskell has a pretty steep learning curve, that's true
07:11:13 <michi7x7> > 1 : 2 : 3 : 4 : []
07:11:15 <lambdabot>  [1,2,3,4]
07:11:20 <EEVV> michi7x7, especially when you can't find a good tutorial x{
07:11:31 <michi7x7> ^ that's the reason why you can pattern match with (x:xs)
07:11:35 <Insanity_> EEVV: The book "Learn you a haskell for great good" is quite good to learn it imo
07:11:39 <michi7x7> EEVV: learn you a Haskell?
07:11:50 <EEVV> > "int: ".2
07:11:52 <lambdabot>  error:
07:11:52 <lambdabot>      • Couldn't match expected type ‘b0 -> c’ with actual type ‘[Char]’
07:11:52 <lambdabot>      • In the first argument of ‘(.)’, namely ‘"int: "’
07:12:00 <EEVV> > "int: "++ 2
07:12:02 <lambdabot>  error:
07:12:02 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘2’
07:12:02 <lambdabot>      • In the second argument of ‘(++)’, namely ‘2’
07:12:15 <michi7x7> :t show
07:12:15 <ongy> michi7x7: I don't know if it's higher than any other language if it's the first someone learns. But it certainly is when learning seconds since it's rather different
07:12:16 <grantwu> What are you trying to do o.o
07:12:17 <lambdabot> Show a => a -> String
07:12:27 <EEVV> michi7x7, learn me a Haskell
07:12:28 <Insanity_> > "int: " ++ show 2
07:12:30 <lambdabot>  "int: 2"
07:12:44 <EEVV> Insanity_, if show is a function, can I override it?
07:13:15 <Insanity_> I'm not sure if you can, I'm just learning Haskell :D someone else will probably answer that
07:13:24 <ongy> > let show _ = "3" in "int: " ++ show 2
07:13:27 <lambdabot>  "int: 3"
07:13:36 <EEVV> Insanity_, learn me a Haskell too
07:13:47 <delYsid> EEVV: You can define a Show instance for a particular data type.
07:13:52 <EEVV> let show Int = "4" in show 4
07:13:58 <michi7x7> EEVV: write an instance for "Show" and you will be good
07:14:07 <grantwu> You get a Haskell!  You get a haskell!  YOU ALL GET HASKELLS!
07:14:17 <EEVV> delYsid, like an object instance?
07:14:26 <EEVV> > let show Int = "5" in show 4
07:14:28 <lambdabot>  error:
07:14:28 <lambdabot>      Not in scope: data constructor ‘Int’
07:14:28 <lambdabot>      Perhaps you meant one of these:
07:14:32 <delYsid> Where do I start if I want to use TH to generate a relatively simple sum type?
07:15:02 <delYsid> I find the docs very scarce.
07:15:05 <grantwu> EEVV: Int is the name of one of the built in integral types.
07:15:14 <grantwu> > let show i = "5" in show 4
07:15:16 <lambdabot>  "5"
07:15:44 <EEVV> > let show -> Int = 2 in show 5
07:15:46 <lambdabot>  <hint>:1:10: error: parse error on input ‘->’
07:15:53 <michi7x7> EEVV: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102 <- a few paragraphs down "instance Show TrafficLight where ..."
07:15:57 <quchen> You cannot override functions.
07:16:20 <lyxia> delYsid: I'd look at template-haskell's datatypes.
07:16:26 <EEVV> michi7x7, too far! I'm going to page 1
07:16:36 <M2tias> EEVV: start reading
07:16:39 <michi7x7> quchen: sure you can
07:16:40 <michi7x7> > let show x = 5 in show "a"
07:16:41 <lambdabot>  5
07:16:51 <EEVV> > show True
07:16:53 <lambdabot>  "True"
07:16:58 <delYsid> lyxia: I know I need DataD (or dataD) somehow, but the sig confuses me
07:16:58 <quchen> That’s shadowing, not overriding.
07:17:02 <lyxia> delYsid: You want to create a data declaration, that's the DataD constructor, then look at what you can put in each field.
07:17:19 <grantwu> > let foobar = 5 in show foobar ++ { let show = const "Pusheen" in show 4 } 
07:17:21 <lambdabot>  <hint>:1:34: error: parse error on input ‘{’
07:17:38 <grantwu> > let foobar = 5 in { let show = const "Pusheen" in show 4 } ++ show foobar
07:17:40 <lambdabot>  <hint>:1:19: error: parse error on input ‘{’
07:17:54 <michi7x7> quchen: yeah, true... As said, I have my problems with Haskell nomenclature
07:18:15 <EEVV> > let x = [1..] in x !! 55
07:18:17 <lambdabot>  56
07:18:32 <michi7x7> > [1..] !! 55
07:18:34 <lambdabot>  56
07:18:43 <merijn> michi7x7: It's usually called shadowing in other languages too :)
07:18:43 <grantwu> ...well the intent was to show that shadowing only changes things in the scope
07:19:01 <EEVV> let x !! y = 0 in [1..] !! 2
07:19:03 <merijn> grantwu: You need {} after the let
07:19:06 <EEVV> > let x !! y = 0 in [1..] !! 2
07:19:08 <lambdabot>  0
07:19:22 <grantwu> > let foobar = 5 in { show foobar ++ { let show = const "Pusheen" in show 4 } }
07:19:24 <lambdabot>  <hint>:1:19: error: parse error on input ‘{’
07:19:35 <grantwu> merijn: sorry... which let?
07:19:56 <lyxia> delYsid: First Cxt, it's a type synonym for a list. You probably don't want to put anything there, so pass an empty list.
07:19:59 <EEVV> > let x = [1..] in length x
07:20:00 <grantwu> > let { foobar = 5 in show foobar ++ let { show = const "Pusheen" in show 4 } }
07:20:02 <lambdabot>  <hint>:1:18: error: parse error on input ‘in’
07:20:03 <merijn> oh, actually, you don't, I think
07:20:05 <lambdabot>  mueval-core: Time limit exceeded
07:20:23 <lyxia> delYsid: then you need a name for your datatype, and a list of type parameters.
07:20:28 <EEVV> > length [1..]
07:20:32 <grantwu> > let { foobar = 5 in { show foobar ++ let { show = const "Pusheen" in show 4 } } }
07:20:34 <lambdabot>  <hint>:1:18: error: parse error on input ‘in’
07:20:35 <lambdabot>  mueval-core: Time limit exceeded
07:20:56 <grantwu> oh god, I'm randomly inserting braces.  We LaTeX now
07:21:21 <mjrosenb> that is not a nick I expeted to pop up first thing upon joining this channel.
07:21:25 <mjrosenb> grantwu: morning.
07:21:44 <grantwu> mjrosenb: Using haskell for compilers :P
07:21:50 <EEVV> > elem 4 [1..]
07:21:52 <lambdabot>  True
07:21:55 <EEVV> u smot
07:22:15 <grantwu> mjrosenb: o/
07:22:39 <grantwu> anyone know how to get the let thing actually work?
07:22:54 <mjrosenb> grantwu: context?
07:23:02 <EEVV> > let factorial n = foldr (*) 1 [1..n] in factorial 3
07:23:03 <grantwu> let { foobar = 5 in show foobar ++ let { show = const "Pusheen" in show 4 } }
07:23:04 <lambdabot>  6
07:23:07 <EEVV> omg
07:23:10 <EEVV> It works!
07:23:12 <grantwu> mjrosenb: This doesn't work
07:23:23 * hackagebot avwx 0.3.0.0 - Parse aviation weather reports  https://hackage.haskell.org/package/avwx-0.3.0.0 (hc)
07:23:23 <grantwu> mjrosenb: I don't know where to put the parentheses to get it to work
07:23:25 * hackagebot hw-prim 0.1.0.1 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.1.0.1 (haskellworks)
07:23:27 * hackagebot http-pony-transformer-startline 0.1.0.0 - transform HTTP startlines to tuples  https://hackage.haskell.org/package/http-pony-transformer-startline-0.1.0.0 (JinjingWang)
07:23:28 <michi7x7> > (\x -> let show = const "Whatever " in show x) 5 ++ show 5
07:23:30 <lambdabot>  "Whatever 5"
07:23:45 <michi7x7> grantwu: ^ ? =)
07:23:57 <grantwu> michi7x7: True, but how would I do it with two lets?
07:24:11 <delYsid> lyxia: Expected type CxtQ, Actual type [t0], hmm, a empty list doesnt seem to work.
07:24:25 <mjrosenb> grantwu: let allows you to bind an arbitrary number of variables.
07:24:36 <lyxia> delYsid: yeah if you use dataD the arguments should be wrapped in Q
07:24:38 <delYsid> gah, this stuff confuses me.  I can write Lisp macros without even looking at any docs, and I wrote my last macro a year ago.  But this stuff... phew
07:24:38 <EEVV> > foldr max 0 [1, 3, 4, 5, 2, 11]
07:24:41 <lambdabot>  11
07:24:43 <Phillemann> I'd like to write something like "case someMaybe of Nothing -> ...; Just x -> ...; Just y -> ...;
07:24:45 <Phillemann> Is that possible?
07:24:53 <EEVV> > Maybe True
07:24:54 <tsahyt> @hoogle (Monoid a, Traversable f) => f a -> a
07:24:55 <lambdabot>  error:
07:24:55 <lambdabot>      • Data constructor not in scope: Maybe :: Bool -> t
07:24:55 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
07:24:59 <lambdabot> Bound closed :: Traversable f => f a -> Maybe (f b)
07:24:59 <lambdabot> Bound.Term closed :: Traversable f => f a -> Maybe (f b)
07:24:59 <lambdabot> Language.ECMAScript3.Syntax.Annotations removeExtraAnnotationField :: Traversable t => t (a, b) -> t a
07:25:06 <grantwu> Phillemann: https://wiki.haskell.org/Pattern_guard ?
07:25:18 <tsahyt> Is there no generalized version of mconcat?
07:25:19 <EEVV> > Maybe False (Maybe True)
07:25:21 <lambdabot>  error:
07:25:21 <lambdabot>      • Data constructor not in scope: Maybe :: Bool -> t0 -> t
07:25:21 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)error:
07:25:24 <mjrosenb> Phillemann: sure, but if x and y are equivalent, the y case will never be hit
07:25:27 <grantwu> mjrosenb: I know - I wanted to show that shadowing works based on scopes
07:25:36 <tsahyt> @hoogle (Monoid a, Foldable f) => f a -> a
07:25:36 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
07:25:36 <lambdabot> Data.Universe.Instances.Traversable fold :: (Foldable t, Monoid m) => t m -> m
07:25:36 <lambdabot> Data.Universe.Instances.Reverse fold :: (Foldable t, Monoid m) => t m -> m
07:25:41 <tsahyt> ah, right...
07:26:03 <mjrosenb> grantwu: ahh,
07:26:04 <Phillemann> grantwu: Well, guards are for functions.
07:26:05 <EEVV> > take 2 [1..]
07:26:07 <lambdabot>  [1,2]
07:26:16 <michi7x7> > let show = const "Pusheen" in let x = show 5 in x ++ show 5
07:26:16 <lyxia> delYsid: It might be easier at first to just use the actual constructors.
07:26:18 <lambdabot>  "PusheenPusheen"
07:26:18 <Phillemann> What if I don't want to refactor it into a function?
07:26:20 <EEVV> > take 2 (cycle [1..])
07:26:21 <mjrosenb> Phillemann: guards work on case statements as well.
07:26:23 <lambdabot>  [1,2]
07:26:31 <ongy> > \case Just "hi" -> Ho; Just "ho" -> Hi; Nothing -> "No" $ "ho"
07:26:33 <lambdabot>  error:
07:26:33 <lambdabot>      • Data constructor not in scope: Ho
07:26:33 <lambdabot>      • Perhaps you meant one of these:
07:26:37 <mjrosenb> just they aren't as useful.
07:26:42 <srhb> > let foo | True = 4
07:26:44 <lambdabot>  <no location info>: error: not an expression: ‘let foo | True = 4’
07:26:44 <srhb> > foo
07:26:46 <ongy> > \case Just "hi" -> "Ho"; Just "ho" -> "Hi"; Nothing -> "No" $ "ho"
07:26:47 <lambdabot>  error:
07:26:47 <lambdabot>      • Variable not in scope: foo
07:26:47 <lambdabot>      • Perhaps you meant ‘for’ (imported from Data.Traversable)
07:26:48 <srhb> Er
07:26:48 <lambdabot>  error:
07:26:49 <lambdabot>      • Couldn't match expected type ‘[Char] -> [Char]’
07:26:49 <lambdabot>                    with actual type ‘[Char]’
07:27:07 <Phillemann> Holy shit...didn't know that
07:27:10 <EEVV> > minimum 0
07:27:13 <Phillemann> Just x | x == y -> ...
07:27:15 <lambdabot>  error:
07:27:16 <EEVV> > minimum []
07:27:19 <lambdabot>      • Could not deduce (Num (t0 a))
07:27:21 <lambdabot>        from the context: (Foldable t, Ord a, Num (t a))
07:27:21 <grantwu> michi7x7: Hrm... that's not quite what I wanted
07:27:23 <lambdabot>  *Exception: Prelude.minimum: empty list
07:27:33 <grantwu> michi7x7: I only wanted the shadowed show to apply to one of them
07:27:38 <delYsid> lyxia: You mean dataD?  I am actually trying to use that.
07:27:43 <mjrosenb> > let x = 2 in (let x = 5 in x)
07:27:45 <lambdabot>  5
07:27:47 <lyxia> delYsid: DataD, not dataD
07:27:48 <ongy> > (\case Just "hi" -> "Ho"; Just "ho" -> "Hi"; Nothing -> "No") $ Just "ho" -- Phillemann you can also do this
07:27:50 <lambdabot>  "Hi"
07:27:54 <michi7x7> > let s = show in let show = const "Pusheen" in s 5 ++ show 5
07:27:57 <lambdabot>  "5Pusheen"
07:27:59 <michi7x7> well, yeah...
07:27:59 <lyxia> delYsid: dataD is a function. DataD is a constructor.
07:28:04 <EEVV> > [10..]
07:28:07 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
07:28:12 <EEVV> > [10..0]
07:28:14 <erisco> okay, guys, if you want to play with lambdabot it is better if you do it in private chat
07:28:14 <lambdabot>  []
07:28:19 <Phillemann> ongy: This works with literals, but not with other values apparently.
07:28:22 <EEVV> > [..0]
07:28:24 <lambdabot>  <hint>:1:2: error: parse error on input ‘..’
07:28:34 <ongy> Phillemann: things you can pattern match on. yes
07:28:52 <Phillemann> Yes, though that has no meaning to me yet :D
07:28:56 <michi7x7> EEVV: its [10,9..0] but this really getting out of hand ... /msg lambdabot ?
07:28:57 <EEVV> Can you create a decrementing list? Like [10..0]?
07:29:18 <EEVV> michi7x7, thanks and what is getting out of hand?
07:29:25 <michi7x7> EEVV: this chat
07:30:34 <ongy> :t [0,1..]
07:30:36 <lambdabot> (Num t, Enum t) => [t]
07:30:40 <EEVV> michi7x7, how do I exit ghci?
07:30:50 <michi7x7> EEVV: :q
07:30:56 <EEVV> michi7x7, thanks
07:30:59 <lyxia> > [10,9 .. 0]
07:31:01 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
07:32:15 <ongy> > [10,9 .. 0] :: Natural
07:32:17 <lambdabot>  error:
07:32:17 <lambdabot>      • Couldn't match expected type ‘Natural’
07:32:17 <lambdabot>                    with actual type ‘[Integer]’
07:32:18 <mettekou_> I've just read through the papers on TypeFamilies (Associated Type Synonyms, Associated Types with Class, and Type Checking with Open Type Functions) and would like to combine it with DataKinds to write a function of type String -> *. However, I haven't got the slightest clue how to go about this.
07:32:23 <ongy> > [10,9 .. 0] :: [Natural]
07:32:25 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
07:33:00 <tsahyt> @hoogle (Semigroup a, Foldable f) => f a -> a
07:33:02 <lambdabot> Prelude maximum :: forall a . (Foldable t, Ord a) => t a -> a
07:33:03 <lambdabot> Prelude minimum :: forall a . (Foldable t, Ord a) => t a -> a
07:33:03 <lambdabot> Data.List maximum :: forall a . (Foldable t, Ord a) => t a -> a
07:33:04 <erisco> mettekou, what does your function do?
07:33:15 <tsahyt> hm, so there's no general fold1 then?
07:33:42 <mettekou> Well, I would like to use it to prove a property of a String, hence my intuition from Coq telling me I need String -> *.
07:33:56 <mettekou> * playing the role of Prop here.
07:34:19 <erisco> you may be disappointed because the facilities in Haskell for this are of lesser power
07:34:31 <EEVV> I just found the best thing on Haskell ever :o
07:34:54 <yulax> ok
07:34:56 <erisco> mettekou, the discussion would be more directed if you detailed the property you want to prove
07:35:15 <yulax> ok i make list [[1,2],[3,4],[5,6]]
07:35:19 <yulax> lets call it w
07:35:30 <yulax> and then i do w ++ [[5,6]]
07:35:48 <yulax> and it displays [[1,2],[3,4],[5,6],[5,6]]
07:35:51 <Sagi> ClaudiusMaximus: thanks again, deepseq works just fine.
07:35:52 <yulax> but then when i type w
07:35:59 <yulax> it displays the "old" w
07:36:02 <yulax> what gives?
07:36:06 <erisco> many newcomers today, this is great :)
07:36:13 <ongy> yulax: values are not mutable in haskell. So (++) returns a new list
07:36:17 <yulax> yea it's uni people :-)
07:36:18 <erisco> yulax, this is because ++ does not mutate w, in fact nothing in Haskell is mutable
07:36:20 <yulax> ah yes
07:36:23 <yulax> i remember now
07:36:25 <erisco> oh right, start of a new year heh
07:36:50 <yulax> so if i say p = w ++ ... etc it will set p to be that?
07:37:01 <ongy> > let w = [[1,2],[3,4],[5,6]] in let z = w ++ [[5, 6]] in (w, z)
07:37:03 <lambdabot>  ([[1,2],[3,4],[5,6]],[[1,2],[3,4],[5,6],[5,6]])
07:37:11 <erisco> yes, though "set" is maybe a misleading term
07:37:15 <erisco> it "defines" p as that
07:37:31 <yulax> yea
07:37:37 <yulax> that's better terminology
07:39:56 <erisco> a wonderful consequence of this is that what you write means the same thing no matter where you write it
07:40:18 <erisco> taking into account free variables and overloaded functions
07:41:43 <mettekou> erisco: Well, I would like to prove properties in general, but a simple example would be whether the String contains some word.
07:42:06 <codedmart> If I have a tuple like `(Maybe Int, Maybe Int, Maybe String, Maybe String)` is there a function that allows me to check if any of the tuple elements are Just or vice versa any are Nothing?
07:42:30 <codedmart> Or do I need to write my own?
07:43:13 <srhb> codedmart: That sounds very lensy.
07:44:09 <codedmart> srhb: OK have done very little with lenses, but will take a look. Thanks!
07:46:12 <yulax> i create a list k [5555,5554,5553,5552]
07:46:19 <yulax> then i say reverse k
07:46:23 <yulax> and it reverses it]
07:46:26 <yulax> howerver
07:46:39 <yulax> when i say K = reverse k
07:46:46 <yulax> it does not like this
07:46:50 <yulax> what is happening?
07:47:08 <lyxia> definitions in haskell are recursive
07:47:21 <ski> also, variable names can't start with an upper case letter
07:47:21 <lyxia> so you're defining a list that's the reverse of itself
07:47:41 <lyxia> oh, that too!
07:48:16 <Phillemann> This might be very specific for this channel, but can I get wreq to please don't throw an exception if the HTTP status code is something else than 200?
07:48:49 <yulax> ah right 
07:48:57 <yulax> that's probably the problem
07:49:12 <yulax> yea
07:49:19 <yulax> when i say let ko = ...
07:49:22 <yulax> we get the right thing
07:49:24 <yulax> thanks
07:50:22 <lyxia> yulax: you're almost an anagram of me.
07:51:37 * slack1256 awaits the doppelganger fight
07:52:42 <erisco> mettekou, I would talk to someone who has more experience with this, such as ekmett, but from my knowledge this is impossible because terms cannot exist as types
07:53:10 <erisco> mettekou, the closest you have is singletons (see the singletons package) where types have just one term, and so the term is as good as the type and vice versa
07:55:28 <yulax> lyxia: so i am
07:55:37 <erisco> by using a specially built types, based on singletons, you may be able to create this proof, but I suspect not for String
07:55:46 <yulax> it's not my real name though xD
07:56:20 <mettekou> erisco: Yeah, I already came across those. Too bad, really, I was looking into creating a data type for prose which could be constrained using various style guides.
07:56:26 <mettekou> At the type level, that is.
07:57:34 <erisco> try Idris, the possible successor to Haskell once Haskell runs itself into the ground
07:58:18 <erisco> the grandmother of Miranda :P
07:58:29 <erisco> I mean the granddaughter
08:00:19 <erisco> mettekou, another possibility is using TH to do your own analysis at compile time
08:01:36 <erisco> I find these endeavours to be ultimately a waste of time, though, because the result is complicated
08:02:03 <erisco> so while the intent is to reduce development problems, the result is making development more problematic
08:02:13 * ski looks at inco6
08:02:42 <mettekou> Yeah, I guess some problems will always be solved at the term level.
08:02:46 <mettekou> It's a shame though.
08:03:02 <erisco> it is engineering
08:03:19 <EEVV> I tried to do `factorial :: Integer -> Integer` in GHCI, but it basically says that the variable is not in scope
08:03:27 <erisco> absent of all other factors, why not put the maximum quality into everything?
08:03:46 <erisco> of course you would, but that isn't reality
08:04:24 <mettekou> My only gripe with solving problems at the term level is that constraints imposed there can be circumvented more easily than constraints imposed through typing.
08:04:53 <mettekou> Or at least: messing with type-level code requires more sophistication from the library user.
08:04:55 <ski> EEVV : you need to give the type signature and the defining equation(s) at the same time
08:05:13 <EEVV> ski, do I use a semicolon?
08:05:17 <ski> yes
08:05:24 <ski> EEVV : also, in the interactor, you need to use `let', to define a variable
08:05:44 <EEVV> ski, thanks. So I also do let factorial n = ...?
08:05:58 <ski> EEVV : otherwise it'll be interpreted as an expression to be reduced (and the result printed)
08:06:11 <EEVV> ski, oh, that is ok :D
08:06:13 <ski> EEVV : yes, or `let factorial :: Integer -> Integer; factorial n = ..n..'
08:06:30 <EEVV> ski, thanks :)
08:06:34 <ski> (in case you wanted to prove the type signature)
08:06:41 <johnw> mettekou: you can write a type-level function String -> Bool, and then use it as a constraint: foo :: myFunc "Hello" ~ True => ...  But it will only work for constant strings
08:06:41 <erisco> well, it is not doomed, we make progress by making it simpler
08:06:45 <ski> (otherwise it'll just infer the type)
08:06:57 <lyxia> you no longer need let in ghci
08:07:11 <ski> lyxia : oh ? :(
08:08:03 <EEVV> ski, what does it mean to give a type of `Num` to GHC (the compiler)?
08:08:49 <lyxia> ski: since GHC8 so it's still not well known
08:08:50 <mettekou> johnw: Oh, okay, too bad.
08:09:11 <lyxia> This is one less thing newcomers will get to complain about!
08:09:50 <johnw> mettekou: even in Coq it would only work for strings known at compile-time; if a string is coming from outside the program (command-line arguments, file, etc.) you'd have to rely on decision procedures to determine anything about the string, which are just as runtime checks
08:10:36 <mettekou> johnw: Ah yes, I hadn't thought about it that way yet. My bad!
08:10:49 <erisco> no, because you can know the cases johnw... well, I do not know about Coq specifically, but ideally it is possible
08:10:56 <ski> EEVV : `Num' is a type class, a constraint/property that can be ascribed to types (usually type variables). in this case it means that the type in question is "numeric", supports the operations in the type class `Num', which is `(+)',`(-)',`(*)' (but not `(/)'), and a few more
08:11:11 <johnw> erisco: the cases?  there are infinitely many strings
08:11:28 <erisco> case s of "hello":s' -> m   then clearly s contains "hello" in m
08:11:39 <johnw> yes, and you know "hello" at compile-time
08:11:44 <ski> EEVV : the `Num a =>' part of the type signature claims that the remainder of the type signature works, but only if `a' will be a numeric type, in the above sense
08:11:47 <EEVV> ski, so Integer falls into this Type? (super Type :P) 
08:11:58 <johnw> also, what you just wrote is a runtime decision procedure to test for "hello" :)
08:12:12 <erisco> it is also an error for what I meant, whoops
08:12:18 <erisco> but you get what I mean
08:12:28 <ski> EEVV : `Integer' is an instance of `Num', yes. it's not a "super type". it's a collection/class of types, that all share having "numeric operations" defined on them
08:12:38 <johnw> erisco: no, I actually don't
08:12:47 <EEVV> ski, so the types are also passed at runtime?
08:12:51 <ski> EEVV : `Int',`Float',`Double',`Rational' are some other types which are instances of `Num'
08:13:01 <ski> @src Num
08:13:01 <lambdabot> class Num a where
08:13:01 <lambdabot>     (+), (-), (*)       :: a -> a -> a
08:13:01 <lambdabot>     negate, abs, signum :: a -> a
08:13:01 <lambdabot>     fromInteger         :: Integer -> a
08:13:17 <ski> (is how the type class `Num' is defined, lists the operations which every instance of it has to support)
08:13:23 <ski> EEVV : i'm not sure what you mean by that
08:13:26 <erisco> johnw, two things... I thought you meant the whole string would have to be constant. Second, by "runtime check" I thought you meant the kind that might throw an exception
08:13:27 <EEVV> ski, oohh wait nvm. I see it polymorphic, so you can just point to the add, subtract, multiply function
08:13:33 <EEVV> it is *
08:13:41 <ski> EEVV : "it" being ?
08:13:52 <johnw> erisco: we should probably be discussing this in the context of a real example
08:13:55 <EEVV> ski, I meant "it is" :P
08:14:07 <ski> EEVV : yes, but "it" referring to what ? :)
08:14:16 <EEVV> ski, Num
08:14:24 <erisco> johnw, the error in my example is that "hello":s' :: [[String]], but I meant something of :: [String]
08:14:24 <nitrix> EEVV: It's not a "super type" system, it's more of a classification. Types "belongs" to type class if they implement the required functions. This way, it describes what it means to do that operation on such type, and thus you get something akind to adhoc polymorphism, but slightly better.
08:14:26 <johnw> but a function of type String -> Prop in Coq can only be determined if the String is knowable at compile-time; otherwise, it would need to be String -> bool and executed at runtime
08:14:28 <ski> EEVV : `Num' is not a polymorphic type class
08:14:56 <ski> EEVV : if you got `factorial :: Num a => a -> a', then `factorial' would be a polymorphic function, though
08:15:06 <erisco> johnw, you can say anything about Coq and I have no knowledge to rebuke it, I am just speaking idealistically
08:15:10 <ski> (a type class *constrained* polymorphic function, specifically)
08:15:15 <johnw> if you try to write a function String -> Prop based on a totally opaque term, you'll find yourself struck in the proof, because there is no case analysis you can do.  Your property would either have to apply universally to all strings, or to none.
08:15:20 <ertesx> johnw: hmm?  coq doesn't allow type computations at run-time?
08:15:22 <johnw> replace Coq here with compile-time
08:15:24 <EEVV> ok
08:15:43 * ski isn't sure if this is what EEVV tried, or if they got `Num' from somewhere else
08:15:44 <johnw> ertesx: no, types are all erased at runtime
08:16:17 <ertesx> johnw: is that why Prop is an extra type?  (beside Set)
08:16:20 <johnw> ertesx: or rather, that really depends on how you're extracting :)  If you go to Haskell, then non-Prop types are preserved in the extraction, but then Haskell will erase the types at runtime
08:16:23 <erisco> johnw, okay, well say we want both the needle and the haystack to be variable, then we might have  if x `substr` s then m else n  in which we know x is a substring of s in m, but not in n
08:16:29 <ski> johnw : "can only be determined" ?
08:16:42 <johnw> ski: written
08:17:06 <ski> johnw : clearly you can write the equivalent of `\x -> x === x', no ?
08:17:13 <erisco> johnw, I have brought this kind of thing up before and the sticking point is that people want to do everything with GADTs, so it seems, which I am not committed to
08:17:36 <johnw> ski: "Your property would either have to apply universally to all strings, or to none." :)
08:18:08 <johnw> I guess another way of saying this is that compile-time functions can only act on details known at compile-time
08:18:10 <ski> well, i'm still not sure what "can only be determined" even means .. :)
08:18:25 <johnw> ski: poor choice of language then; I meant "possible", "can be written", etc.
08:18:26 <mizu_no_oto_work> EEVV: With typeclasses, it's not that types are passes at runtime, it's that "implementation dictionaries"  are (usually) passed at runtime.
08:18:27 * ski . o O ( NbE )
08:18:47 <EEVV> mizu_no_oto_work, ok thanks.
08:19:06 <osager> anyone using haskell code inside emacs org mode ?
08:19:11 <osager> how to set it up?
08:19:12 <ski> johnw : clearly `\x -> x === x' can be written (and even proved to hold for every input, should you wish to do so), without knowing a particular `x' input ?
08:19:16 <ertesx> johnw: "compile-time function"?  yeah, might be poor language choice =)
08:19:21 <johnw> 08:17 <johnw> ski: "Your property would either have to apply universally to all strings,
08:19:22 <johnw>           or to none." :)
08:19:30 <johnw> \x -> x === x can be applied to any string
08:19:53 <ski> oh, so your later statement rebutted your earlier one
08:19:57 <johnw> ?
08:19:59 <johnw> how is that?
08:20:05 <johnw> I've only been saying one thing all this time
08:20:20 * ski is probably not understanding it well, then
08:20:21 <johnw> you can't write a compile-time function that relies on details that will only become available at runtime
08:20:29 <johnw> that's really all I'm trying to say
08:20:37 <erisco> no one is going to dispute that
08:20:51 <ski> (if you wish, we can drop it. i don't think it's a very enlightening point. sorry for the noise)
08:20:54 <johnw> ok, then I'm not going crazy :)  I must have expressed myself poorly
08:21:28 <mizu_no_oto_work> EEVV: One common way of implementing typeclasses is that there's a struct "data NumStruct a = Num { + :: a -> a -> a, ...}" that's associated with the typeclass.  Then, a function of type "foo :: Num a => a -> a" gets desugared to "foo :: NumStruct a -> a -> a" in the compiler.
08:21:31 <ertesx> johnw: but there is no such thing as a "compile-time function"?  there are just functions, and it depends on how you apply them…  for example in haskell with -XRankNTypes you can easily make functions that need static knowledge depend on run-time things for that knowledge, as long as you handle all cases
08:22:01 <erisco> I was just suggesting how you can know more statically, including knowing that a string is a substring of another string, without knowing what either string is
08:22:05 <johnw> ertesx: the 'singletons' libabry will let you write some compile-time functions for Haskell
08:22:30 <johnw> ertesx: although you can't write any kind of compile-time function, you can write a lot of them
08:22:54 <johnw> erisco: sure, if you can characterize the inputs in some way, that is compile-time knowledge
08:22:56 <ertesx> johnw: ok, yeah…  but haskell has a separate level for "type functions"…  i was still thinking dependent types
08:23:03 <johnw> anyway, as ski said, there's nothing new being said here
08:23:10 <johnw> ertesx: ah, ok
08:23:22 <ski> EEVV : btw, in case you know anything about how OO is often implemented, note that type classes work very differently. with OO, a dictionary of methods would be associated with every *value* of the type. while with type classes, a dictionary of methods would be associated with the type itself. so if you have a list of values, you'd still only have a single dictionary
08:23:24 * hackagebot http-pony-serve-wai 0.1.0.3 - Serve a WAI application with http-pony  https://hackage.haskell.org/package/http-pony-serve-wai-0.1.0.3 (JinjingWang)
08:23:26 * hackagebot hpqtypes 1.5.1.1 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.5.1.1 (MikhailGlushenkov)
08:23:28 * hackagebot codex 0.5.0.2 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.5.0.2 (bitemyapp)
08:23:32 <erisco> it was quite simply  x `substr` s  where substr :: String -> String -> Bool
08:23:51 <erisco> which gets DT people up in arms, evidently, but it seems plausible to me
08:24:32 <ski> EEVV : also, with type classes, you can do `fromInteger :: Num a => Integer -> a', where there isn't even *any* input value of the type `a', the "overloading" is purely on the *return* type. you can't really do that with the OO way of associating method dictionaries with values
08:24:51 <johnw> erisco: If the arguments are known at compile-time, then the answer could be too
08:25:07 <erisco> johnw, even without knowing the arguments
08:25:13 * ski looks at EEVV
08:25:14 <ertesx> has anyone actually used singletons for a practical project?  i really tried, but it was a rather terrible experience
08:25:16 <johnw> erisco: ok, I'd like to see that :)
08:25:20 * EEVV looks at ski
08:25:46 <ski> EEVV : any comment ? did it make any sense at all ? or perhaps it'd beyond your current level of understanding ?
08:25:47 <EEVV> ski, ok I guess :D I'm still really new to Haskell
08:25:50 <erisco> johnw, I gave the example earlier, it is straight-forward, it is  if x `substr` s then m else n  clearly x `substr` s is True in m, and False in n
08:26:03 <erisco> johnw, analysis of m and n can proceed with that respective knowledge
08:26:05 <ski> EEVV : feel free to ignore the last points i made, if they don't make sense to you atm :)
08:26:15 <EEVV> ski, I understand a lot, but only my knowledge of Haskell has limited my understanding of what you've said :(
08:26:30 * ski has no idea which other programming languages EEVV has seen before
08:26:46 <bartavelle> there is a presentation in the nara conference about a new STM implementation, that seems to be faster
08:26:57 <bartavelle> is that supposed to go into ghc ?
08:27:03 <EEVV> ski, assembly, Python, C++, Java, NodeJs/Js, HTML+CSS, PHP
08:27:05 <EEVV> all that crap
08:27:11 <EEVV> and maybe more x{
08:27:17 <ski> ok
08:27:22 <johnw> erisco: I'm not sure what the benefit of that analysis would be; you'll end up with a decision tree that again, needs execution at runtime to be resolved to an "answer"
08:27:22 <ski> x86 ?
08:27:29 <ongy> EEVV: have you actually worked with them, or just had a look?
08:27:32 <EEVV> ski, yeah x86, i386
08:27:34 <ski> my condoleances
08:27:49 <EEVV> ongy, I've worked with them
08:27:57 <erisco> johnw, what answer are you looking for? the only one I am interested in is whether x is a substring of s, which that adequately answers statically
08:28:08 <mizu_no_oto_work> EEVV: Additionally, it's possible to 'conditionally implement' a typeclass, whereas it's usually not possible to conditionally implement an OO interface.  For example, there's "instance Eq a => Eq [a]" which means that lists only have equality if the *elements* in the list have equality.
08:28:09 <johnw> you're not *computing* substr at compile-time, even in your example, which is what I thought we were discussing.  Now it sounds like you're making a different point, so I don't understand know what is being debated
08:28:13 <mizu_no_oto_work> > [1,2,3] == [1,2,3]
08:28:15 <lambdabot>  True
08:28:20 <erisco> johnw, the proposition is True in m without execution
08:28:35 <johnw> erisco: how do you get that answer?
08:28:39 <EEVV> mizu_no_oto_work, the only thing I don't get about your points, is the use of `=>`
08:28:49 <EEVV> your guy's point*
08:28:51 <EEVV> points
08:28:54 <ongy> EEVV: that's haskell syntax for coinstraint
08:29:03 <mizu_no_oto_work> It's special syntax associated with typeclass constraints
08:29:06 <erisco> johnw, because statically you know how case analysis works on Bool, so you know it must be the case the proposition is true in m
08:29:11 <EEVV> ok
08:29:16 <ski> EEVV : the main part of the type is to the right of `=>', the constraints (normally on type variables) is to the left
08:29:21 <mizu_no_oto_work> > [const] == [id]
08:29:23 <lambdabot>  error:
08:29:23 <lambdabot>      • Occurs check: cannot construct the infinite type: a0 ~ b0 -> a0
08:29:23 <lambdabot>        Expected type: a0 -> b0 -> a0
08:29:35 <ski> @type product
08:29:36 <lambdabot> (Foldable t, Num a) => t a -> a
08:29:37 <KaneTW> :t [const]
08:29:38 <lambdabot> [a -> b -> a]
08:29:44 <mizu_no_oto_work> > [const] == [const]
08:29:46 <lambdabot>  error:
08:29:46 <lambdabot>      • No instance for (Eq (a0 -> b0 -> a0)) arising from a use of ‘==’
08:29:46 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
08:30:01 <ertesx> EEVV: x86 assembly isn't that bad…  it's basically PHP: lots of extra complexi^W features for your convenience
08:30:25 <EEVV> ertesx, but those features are sometimes VERY platform dependent, or just use GCC ;)
08:30:26 <bartavelle> x86 has consistent naming for its operands
08:30:34 <johnw> erisco: say I wrote this: if 1 == 0 then m else n.  I could also say that's "True in m", but that wouldn't mean anything
08:30:49 <EEVV> GCC as the linker :P
08:30:51 <bartavelle> or operations?
08:30:52 <johnw> so I don't understand how to make use of what you're saying
08:30:58 <mizu_no_oto_work> EEVV: so in the one context (list of ints), you can see if the lists are equal, but not in the other (list of functions).
08:31:05 <ertesx> EEVV: i'm just joking…  i'm well aware of the horrible mess that is x86 =)
08:31:07 <johnw> anyway, we should take this out of channel, see me in #haskell-overflow
08:31:09 * ski . o O ( `instance (Compact a,Overt a,Eq b) => Eq (a -> b) where ...' )
08:31:13 <nitrix> mizu_no_oto_work: You might want typeRep or :~: for that.
08:31:24 <erisco> johnw, in m it is true that 1 == 0, in n it is false that 1 == 0, this is fine
08:31:51 <erisco> johnw, say we want to prove a property of m, then we come up with a proposition Q to express this property
08:31:52 <EEVV> ertesx, I don't think it is that big of a mess. It is just useful instruction, but PHP has a weird naming convention; you would sometimes see underscores, sometimes not.
08:32:00 <johnw> erisco: #haskell-overflow
08:32:02 <EEVV> useful instructions*
08:32:07 * EEVV sighs
08:32:34 <nshepperd1> Isn't that what dependent types are all about? So you can use values of type (x `substr` y) => (x : string) -> (y : string) -> foo in m
08:32:52 <ski> @google PHP fractal
08:32:53 <lambdabot> http://fractal.thephpleague.com/
08:32:54 <lambdabot> Title: Fractal - Output complex, flexible, AJAX/RESTful data structures
08:32:59 <EEVV> mizu_no_oto_work, can you tell me what f => (a -> b) means?
08:33:04 <johnw> nshepperd1: if he's talking about implication (x `substr` y -> m), then I get it
08:33:07 <ertesx> EEVV: try writing a boot-loader that goes from real mode all the way up to long mode and can still communicate with the hardware and works in your emulator as well as on bare metal =)
08:33:12 <ski> (hm, actually <http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/>)
08:33:37 <ski> EEVV : can you provide some concrete code which gives rise to that ?
08:33:43 <ski> EEVV : also include error messages, if any
08:33:44 <nitrix> EEVV: `f => (a -> b)` is missing the type class name.
08:33:45 <ski> @paste
08:33:45 <lambdabot> Haskell pastebin: http://lpaste.net/
08:34:27 <EEVV> ertesx, nah :P I'd rather stick to writing virtual machines so I can have a reusable instruction set
08:34:39 <mizu_no_oto_work> EEVV: everything on the left hand side of the => is a constraint.  For example, "(Num a, Eq a, Ord a) => a -> a -> a"
08:34:43 <ertesx> nitrix: well, we have constraint polymorphism =)
08:34:51 <EEVV> mizu_no_oto_work, OH! I get it!
08:35:11 <EEVV> mizu_no_oto_work, so a *inherits* from Num, Eq and Ord (whatever that is!)
08:35:11 <ski> (`Ord a' implies `Eq a')
08:35:17 <ski> no inheritance
08:35:27 <ski> `Num',`Eq',`Ord' are type classes
08:35:29 <EEVV> ski, I used asterisks to kind of hint that I was confused :P
08:35:33 <mizu_no_oto_work> EEVV: it's not exactly inheretance
08:35:43 <EEVV> mizu_no_oto_work, that's why I used asterisks :P
08:35:59 <EEVV> I just don't know the correct term
08:36:08 <mizu_no_oto_work> EEVV: you've seen comparators in Java, right?
08:36:09 <ski> the (compound) constraint `(Num a,Eq a,Ord a)' claims that (the type (variable)) `a' *belongs* to / is an *instance* of each of the three type classes `Num',`Eq',`Ord'
08:36:11 <ertesx> EEVV: with type classes there is no hierarchy the way there is in OO
08:36:18 <ski> so if we have
08:36:23 <ski>   foo :: (Num a, Eq a, Ord a) => a -> a -> a
08:36:39 <ertesx> it's a flat landscape with some types (or groups of types) being instances of some type classes, and some type classes have requirements on instances
08:36:56 <ertesx> example:  instance Num Integer
08:37:05 <EEVV> ertesx, ok, but I remember my friend showing some really weird things, like a binary tree in, what, 3 lines of code?
08:37:10 <ski> then this claims that we can apply `foo' to two arguments of type `a' (being a type variable, so any type, but must be the *same* for both arguments), and it'll return a result of type `a' ...
08:37:23 <ertesx> EEVV: sure, but that has nothing to do with type classes
08:37:27 <ski> ... *provided* that `a' is an instance of `Num',`Eq',`Ord'
08:37:32 <mizu_no_oto_work> EEVV: they're a bit outside the normal class hierarchy, in that you have a separate Comparator<Foo> object that has no relation to the Foo object (it's not a subclass or anything).  Typeclasses are like that.
08:37:32 <ertesx> EEVV: if you see:  (+) :: (Num a) => a -> a -> a
08:37:33 <EEVV> ertesx, I know :P
08:37:40 <ertesx> EEVV: and you know:  instance Num Integer
08:37:46 <ertesx> EEVV: then you can use (+) with a = Integer
08:38:00 <ertesx> that's basically the whole story of using type classes in a nut-shell
08:38:02 <ongy> ertesx: then how do superclasses work? Is Integral not somehow "lower" than Num?
08:38:23 <EEVV> ertesx, but why not explicitly use `Num` instead of `a`, rather than "constraining"?
08:38:44 <ski> we know that `foo' works for any type `a' that's an instance of these three type classes .. expanding on the line ertesx said, but for `foo', we can e.g. take the type variable `a', in a particular call of `foo', to be the specific type `Integer' (not a type variable)
08:38:48 <ski> so, from
08:38:52 <ertesx> ongy: you could view that as a "tree" (or partial order), if you want, but that quickly breaks down, as soon as you have multiple variables and more complicated contexts
08:38:54 <ski>   foo :: (Num a, Eq a, Ord a) => a -> a -> a
08:38:56 <ski> we get
08:39:04 <ongy> oh Num isn't required for Integral, replace Num by Real then
08:39:14 <ski>   foo :: (Num Integer,Eq Integer,Ord Integer) => Integer -> Integer -> Integer
08:39:27 <mizu_no_oto_work> EEVV: "Comparator a => a -> a" is like saying that "I want some globally canonical Comparator for the type a to be implicitly taken as an argument for my function" 
08:39:35 <ertesx> EEVV: look at this:  (+) :: (Num a) => a -> a -> a
08:39:36 <ski> (all `a's must be replaced by the *same* specific type, for a particular use of a polymorphic thing, like `foo')
08:39:46 <ertesx> EEVV: could you pass an Integer as the first argument and a Double as the second?
08:39:51 <ertesx> the way it is written
08:39:51 <ongy> ertesx: do you have an example where partial order breaks?
08:40:06 <ski> then, since we *know* that `Integer' is in `Num',`Eq',`Ord', iow we know that the constraint `(Num Integer,Eq Integer,Ord Integer)' *holds*, we can simplify this signature into just
08:40:12 <ertesx> ongy: class (A a, B b) => C a b
08:40:12 <ski>   foo :: Integer -> Integer -> Integer
08:40:38 <ski> reading : `foo' *can* be used by passing two `Integer' arguments to it, getting an `Integer' result back
08:40:40 <EEVV> ertesx, why can't you replace `a` with `Num`
08:40:41 <EEVV> ?
08:40:42 <ski> EEVV : makes sense ?
08:40:46 * ski ceases
08:40:58 <mizu_no_oto_work> EEVV: You mean, "Num -> Num -> Num"?
08:41:05 <EEVV> mizu_no_oto_work, yeah
08:41:08 <ski> EEVV : `Num' is not a type
08:41:14 <ski> `Num -> Num' makes no sense
08:41:23 <EEVV> ski, ok, this is coming together
08:41:26 <EEVV> I thought Num is a type
08:41:30 <mizu_no_oto_work> Haskell doesn't use subtype polymorphism, basically
08:41:30 <ertesx> EEVV: because what ski said:  if it were OO-style inheritance, you could pass an Integer as the first argument and a Double as the second
08:41:31 <ski> `Num' is a predicate/property, that you can apply to a type, in order to form a constraint
08:41:34 <ertesx> but (+) doesn't allow that
08:41:38 <ski> and constraints go to the left of `=>'
08:41:42 <ertesx> (+) :: (Num a) => a -> a -> a
08:41:47 <EEVV> I guess Num just overloads(?) functions, or *HAS* functions like (+) (-) (*)
08:41:48 <EEVV> ?
08:41:49 <ertesx> all arguments and the result are of *the same* type
08:41:52 <ski>   (+) :: Num a => a -> a -> a
08:42:19 <EEVV> ertesx, I see now
08:42:30 <ertesx> EEVV: similarly:
08:42:31 <ski> `Num' is the type class of all types which support `(+)',`(-)',`(*)' (and a few more), of the given signatures 
08:42:34 <ertesx> :t realToFrac
08:42:36 <lambdabot> (Real a, Fractional b) => a -> b
08:42:46 <ertesx> EEVV: here 'a' and 'b' can indeed be different types
08:42:57 <ertesx> > realToFrac (4.5 :: Integer) :: Double
08:42:59 <lambdabot>  error:
08:42:59 <lambdabot>      • No instance for (Fractional Integer)
08:42:59 <lambdabot>          arising from the literal ‘4.5’
08:43:00 <ski> operations with `Num' in their constraint part will be overloaded
08:43:02 <ertesx> whoops
08:43:06 <ertesx> > realToFrac (4.5 :: Rational) :: Double
08:43:08 <lambdabot>  4.5
08:43:35 <mizu_no_oto_work> EEVV: as I said before, you can think of " Num a => a -> a -> a" as being syntax sugar for " NumImplementation a -> a -> a -> a", where NumImplementation is a struct containing the functions (+), (*), etc.
08:43:37 <ongy> ertesx: makes sense. But saying there is no hirarchy still sounds wrong to me. 
08:43:51 <EEVV> ertesx, so Rational is like Integer, but for numbers past the radix point?
08:44:03 <ertesx> EEVV: Rational is a type: the type of ratios
08:44:11 <EEVV> ertesx, ok
08:44:28 <ski> EEVV : note that this isn't your ordinary ad-hoc overloading .. it's (supposed to be) a *principled* kind of overloading. e.g. `(+)' requires that both arguments and the result has the *same* type. if you want something like adding a scalar to a vector, you'll have to define another function/operator (possibly also named `(+)', if you hide/shadow the usual one)
08:44:42 <ertesx> > 1/12 + 1/15 :: Rational
08:44:44 <lambdabot>  3 % 20
08:45:23 <ski> ratios .. aka fractions
08:45:35 <jonored> It's a bit like a documented and enforced version of python's duck typing, or like concepts like "Swappable" in C++.
08:45:36 <mizu_no_oto_work> EEVV: Typeclasses originated in a paper called "making ad hoc polymorphism less ad hoc"
08:45:37 <ReinH> Less ad hoc, even
08:45:39 <xa0> but are they the same, or just isomorphic
08:45:48 <ski> (exact arithmetic with fractions, as opposed to floating-point, which uses approximations)
08:46:11 <ski> xa0 ?
08:46:13 <ertesx> maybe we should start explaining type classes as what they really are: a fancy mechanism to pass implicit arguments
08:46:21 <xa0> ski: ratios and fractions
08:46:28 <EEVV> Can anybody learn me a Haskell?
08:46:31 <ski> ertesx : which isn't all that they are ..
08:46:48 <ertesx> ski: sure, but it seems to be a useful first approximation
08:46:48 <ski> xa0 : a fraction is a form of expression, which denotes a ratio
08:47:00 <xa0> touché
08:47:01 <ski> xa0 : just like a lambda expression denotes a function
08:47:39 <jonored> I mostly get them as roughly groups of CLOS-style generic functions.
08:47:41 <ski> EEVV : how about .. you ?
08:47:45 <ertesx> EEVV: just try learning it on your own, and whenever you hit a stumbling block, ask here…  this channel is very active, and you will almost always find someone to help you with beginner questions =)
08:47:55 <EEVV> ertesx, ok
08:48:00 <crough> ski: The only real difference between implicits and type classes is that type classes are global and coherent
08:48:02 <EEVV> btw I love the list filtering :)
08:48:03 <ski> ertesx : sure
08:48:26 <ertesx> me, too
08:48:30 <ski> crough : *nod*. the last point is very important
08:48:33 <ertesx> > filter (< 10) [1..]
08:48:38 <EEVV> :t (==)
08:48:39 <lambdabot>  mueval-core: Time limit exceeded
08:48:40 <lambdabot> Eq a => a -> a -> Bool
08:49:37 <ski> > [m | n <- [0 ..],let m = n * (n + 1) `div` 2,odd m]
08:49:38 * crough would kill for local coherence
08:49:39 <lambdabot>  [1,3,15,21,45,55,91,105,153,171,231,253,325,351,435,465,561,595,703,741,861,...
08:49:46 <EEVV> > "hello" `compare` "test"
08:49:48 <lambdabot>  LT
08:49:54 <EEVV> what does it mean to compare strings?
08:50:04 <ski> lexicographic comparision
08:50:07 * jonored is a little uncomfortable with the "it's just an implicit struct" approach because it seems pretty clear that typeclasses don't need to exist at runtime (althouh there are reasons to implement them that way).
08:50:11 <ertesx> EEVV: in other words: dictionary order
08:50:13 <ski> the empty string (or list for that matter) is the least
08:50:32 <ski> for non-empty, you compare the first two elements/characters. if they differ, you have your answer
08:50:41 <ertesx> > map (compare "abc") ["ab", "abb", "abc", "abd"]
08:50:41 <ski> otherwise you go on, in lockstep
08:50:43 <lambdabot>  [GT,GT,EQ,LT]
08:50:45 <EEVV> oh, thanks
08:50:58 <EEVV> :t read
08:50:59 <ski> @src [] (==)
08:50:59 <lambdabot> []     == []     = True
08:50:59 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
08:50:59 <lambdabot> _      == _      = False
08:51:01 <lambdabot> Read a => String -> a
08:51:06 <{AS}> :t notNull
08:51:07 <ski> is how it's implemented
08:51:07 <lambdabot> error:
08:51:07 <lambdabot>     • Variable not in scope: notNull
08:51:07 <lambdabot>     • Perhaps you meant ‘notNullOf’ (imported from Control.Lens)
08:51:16 <{AS}> sorry
08:51:25 <{AS}> It should have been the lambdabot chat
08:51:57 <jonored> although I suppose implementing them statically at compile-time is equivalent to just constant-folding on the "f (NumImplementation a)" step.
08:52:25 <ski> jonored : they do need to exist, in case of polymorphic recursion (and also with extensions like existentials)
08:52:27 <EEVV> > read "2" :: Int
08:52:29 <lambdabot>  2
08:52:35 <EEVV> omg, I am cheenious
08:52:48 <ski> > read "2" * 3
08:52:50 <lambdabot>  6
08:52:54 <EEVV> > read "2"
08:52:56 <lambdabot>  *Exception: Prelude.read: no parse
08:53:06 <ski> that's because of defaulting
08:53:21 <ski> usually it'd complain about an ambiguous type variable
08:53:28 <ertesx> > join (liftA2 (\x y -> (x, y, compare x y))) ["abb", "abc", "abd"]
08:53:30 <lambdabot>  [("abb","abb",EQ),("abb","abc",LT),("abb","abd",LT),("abc","abb",GT),("abc",...
08:53:32 <ertesx> awww…
08:53:34 <ski> but lambdabot has an added defaulting of `()'
08:53:42 <ertesx> lambdabot: you really need to show more…  but i love you anyway
08:53:44 <ertesx> @botsnack
08:53:44 <lambdabot> :)
08:53:45 <ski> > read "()"
08:53:47 <lambdabot>  ()
08:54:02 <EEVV> What is the difference between tuples and lists?
08:54:11 <ertesx> > (3, "blah")
08:54:11 <ski> > take (read "2") (show (-37))
08:54:13 <lambdabot>  (3,"blah")
08:54:14 <lambdabot>  "-3"
08:54:17 <ertesx> > [3, "blah"]
08:54:18 <lambdabot>  error:
08:54:19 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘3’
08:54:19 <lambdabot>      • In the expression: 3
08:54:27 <EEVV> oh
08:54:38 <EEVV> ertesx, two lines of code just showed me the way :D
08:54:41 <ski> ertesx : lists are homogenous, indefinite length. tuples are heterogenous, definite length
08:55:15 <ertesx> ski: i'll forward that to EEVV =)
08:55:20 <ski> a tuple is like a lightweight record/`struct'
08:55:27 <ski> ertesx : er, ta
08:55:40 <jonored> ski: polymorphic recursion? (I'm not seeing how to make there be a "f (FooImpl a)" that isn't a constant given a type a that is known at compile-time.)
08:56:16 <EEVV> > (3, (2, 2),3)
08:56:18 <lambdabot>  (3,(2,2),3)
08:56:22 <ertesx> EEVV: you can see more clearly what ski just said by looking at the types of the constructors
08:56:25 <ertesx> :t (,)
08:56:26 <lambdabot> a -> b -> (a, b)
08:56:26 <EEVV> > 2:(3)
08:56:28 <lambdabot>  error:
08:56:29 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M508445004095...
08:56:29 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:56:30 <ski> jonored : consider `silly :: Show a => [a] -> String; silly [] = ""; silly (a:as) = show a ++ silly (map (: []) as)'
08:56:39 <ertesx> it takes an 'a' and a 'b' and constructs an (a, b)
08:56:42 <ertesx> :t (:)
08:56:43 <lambdabot> a -> [a] -> [a]
08:56:51 <ertesx> that one takes an 'a' and a list of 'a'
08:56:57 <ertesx> so it's homogenous
08:57:16 <EEVV> ertesx, ah
08:57:23 <ski> jonored : given an initial `Show a' dict, it'll need to construct also `Show [a]',`Show [[a]]',`Show [[[a]]]', &c. at run-time, depending on the length of the input list
08:57:51 <ertesx> also of course the obvious fact that lists can be arbitrarily long
08:58:56 <ski> jonored : of course, some definite number of these could be precomputed at compile-time, but not all potentially infinitely many of them ..
08:59:22 <ski> jonored : and polymorphic recursion was even in Haskell98
08:59:35 <nathyong> How do I derive an instance of MonadTrans for a newtype around a StateT?
08:59:48 <ski> (polymorphic recursion was one of the few cases which couldn't be inferred, required a type signature)
08:59:48 <jonored> Okay, yeah. Hadn't occurred to me that the number of types actually used in a haskell program can be unbounded.
09:00:03 <ski> nathyong : `NewtypeDeriving' ?
09:00:12 <nathyong> yeah, I've got that
09:00:12 <ski> er, add `Generalized' in there
09:00:18 <nathyong> I think what I actually have isn't a transformer
09:00:24 <ski> possibly
09:00:28 <nathyong> I just want to be able to lift something from the inner monad
09:00:37 <EEVV> > let all@(x : xs) = [1..10] in all
09:00:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:00:44 <EEVV> ermagherd
09:00:49 <ski> nathyong : do you use the "monadic result type" `a' more than once ?
09:00:51 <EEVV> I'm learning so much for one day :P
09:01:01 <nathyong> ski: nope
09:01:25 <nathyong> newtype Blocks a = Blocks (StateT BlockState InnerMonad a)
09:01:29 <ski> nathyong : well .. seeing the actual type woul .. ty
09:01:47 <ski> ah, of course this isn't a monad transformer
09:01:54 <ski> there's no monad parameter to `Blocks'
09:02:02 <nathyong> yep
09:02:25 <nathyong> how do I call some (InnerMonad b) function though?
09:02:34 <ski> (or, "not even wrong", if you prefer :)
09:03:03 <ski> you could define `liftBlocks :: InnerMonad a -> Blocks a'
09:03:41 <nathyong> The implementation feels like it should be trivial.. it's not coming to me right now though
09:03:58 <ski>   liftBlocks act = Blocks (lift act)
09:04:21 <nathyong> oh, of course
09:04:26 <nathyong> I can lift into StateT and re-wrap
09:04:31 <nathyong> ski: thanks a lot
09:04:35 <ski> np
09:05:07 <EEVV> Is it a bad practise to use tabs for indentation? Because GHC is complaining a lot.
09:07:53 <nathyong> EEVV: yes, if you ever introduce spaces in your file then good luck debugging
09:07:57 <nathyong> no pretty alignment
09:08:05 <ski> EEVV : if you use tabs for indentation, then you must not use spaces for indentation, and also break line after any layout-introducing keyword followed by a block of more than one line
09:08:15 <ski> EEVV : the short version is : just avoid tabs
09:08:35 <{AS}> Is there a way to avoid generating large terms in quickcheck?
09:08:51 <ski> hm, smallcheck ?
09:09:08 <{AS}> ski: I guess I meant generating really large terms
09:09:13 <ski> (doesn't avoid generating large terms, per se, but does try to make them smaller)
09:09:46 <{AS}> I am trying to use sized
09:09:54 <{AS}> but it seems that I still get really large terms
09:10:03 <{AS}> also does haskell reuse terms?
09:10:10 <lyxia> smallcheck enumerates all terms under a given size
09:10:10 <{AS}> or quickcheck
09:10:33 <{AS}> I mean I still want to be able to have large terms
09:10:39 <{AS}> but with less probability
09:10:44 <lyxia> {AS}: sized only works if your generator uses it
09:10:51 <{AS}> lyxia: it does
09:11:02 <{AS}> but perhaps I should divide instead of subtracting
09:11:03 <{AS}> :)
09:11:06 <lyxia> can you show it?
09:11:28 <{AS}> lyxia: It's a bit in a bad state now
09:11:55 <{AS}> I understand that you can provide less help though
09:12:08 <{AS}> Thanks for the suggestions, I have an idea how to move on !
09:14:46 <bollu> guys, the GHC codebase is overwhelming
09:14:53 <bollu> how do you guys handle complex haskell codebases?
09:14:59 <bollu> I wish there was VC++ level tooling
09:21:17 <nathyong> bollu: fast-tags + reading the haddock documentation
09:21:23 <nathyong> it's a pain though
09:22:03 <bollu> nathyong: what's fast-tags? is it like a ctags alternative?
09:22:04 <nathyong> although, the GHC codebase possibly predates modules? The module layout is totally flat, making the source code structure a little unintuitive
09:22:18 <nathyong> bollu: fast-tags is the best ctags-generating implementation I've seen for Haskell
09:22:20 <bollu> is it possible for people to write better tooling?
09:22:21 <bollu> I see
09:22:37 <nathyong> for one, it can output useful tags when run on the GHC code base
09:23:11 <nathyong> better tooling is coming [eventually], but I personally believe GHC's code might be a bit too special for tooling
09:23:26 * hackagebot servant-github-webhook 0.3.0.0 - Servant combinators to facilitate writing GitHub webhooks.  https://hackage.haskell.org/package/servant-github-webhook-0.3.0.0 (tsani)
09:23:28 * hackagebot avwx 0.3.0.1 - Parse aviation weather reports  https://hackage.haskell.org/package/avwx-0.3.0.1 (hc)
09:23:30 <bollu> I see
09:23:38 <bollu> nathyong: who's writing the better tooling? FPComplete?
09:23:59 <nathyong> bollu: yeah, and there's chrisdoner with Intero which is pretty neat
09:24:16 <nathyong> Not sure what support that has for project navigation, but it shouldn't be too hard to hack something together
09:24:54 <bollu> I see
09:24:55 <maerwald> last time I checked intero doesn't work with vim, does it?
09:25:08 <bollu> I'm thinking of writing sublime text plugin
09:25:15 <bollu> especially with the new sublime text build
09:25:17 <nathyong> maerwald: sadly it's emacs only
09:25:17 <bollu> the API is smexy
09:26:17 <nathyong> still, the fact that it exists inspires a little hope
09:28:48 <pizzeria> hi
09:29:15 <ski>      lo
09:29:37 <maerwald> nathyong: give them some more time and the only way you can use haskell will be stack+emacs+OSX in a few years...
09:30:55 <bollu> maerwald: "then"?
09:31:08 <bollu> maerwald: I don't understand the animosity towards FPComplete / commercialhaskell
09:31:14 <ertesx> intero is also stack-only as far as i saw
09:31:15 <pizzeria> what you guys recommend for this issue: i have trees which distances' I need to store and also be able to quickly remove. do you have any recommendations?
09:32:06 <bollu> ertesx: I for one welcome stack. cabal hell was a thing till stack made it non-exitent
09:32:09 <ski> distances whence and whereto ?
09:32:11 <bollu> idk why people dislike them
09:32:48 <pizzeria> distances between nodes in the tree and also distance as defined by a special function that takes two trees
09:32:49 <hvr> bollu: note that there's cabal new-build now as well
09:33:05 <hvr> bollu: also, stack is no silver bullet either
09:33:07 <ertesx> bollu: i don't mind stack, but i'm using nix
09:33:18 * ski doesn't really get the situation, but would perhaps suggest a `Map' at this point
09:33:22 <Clint> hvr: how do matrix builds get queued?
09:33:46 <bollu> hvr: yes, It's far from perfect, but it made haskell *usable* for me at least. 
09:34:02 <bollu> hvr: I'm glad that cabal development stepped up due to stack :) I'd love to give a whirl again
09:34:03 <hvr> Clint: currently, they need to placed into the queu manually by trustees; once they're into the queue they get requeued from time to time automatically; but that's gonna change
09:34:16 <Clint> hvr: ok, thanks
09:34:29 <bollu> fml, I have an OS assignment to write a shell in C. I'm tracking null pointers
09:34:33 <ertesx> bollu: haskell-mode, as far as i see, does everything intero does, but doesn't insist on stack, so i can use it
09:34:50 <pizzeria> Are there tables/matrices in Haskell with constant random access?
09:34:52 <bollu> ertesx: I had trouble setting up haskell-mode multiple times IIRC
09:35:07 <bollu> ertesx: intero was so painless. It auto-installs into a proper stack sandbox I think. But, like, it "just works"
09:35:18 <bollu> ertesx: say what you will, both stack and intero care about UX
09:35:50 <maerwald> bollu: community splitting and aggressive blog posts about the haskell committee
09:35:55 <ertesx> bollu: i repeat: i don't mind stack, but i'm using nix, so intero's insistence on stack makes it unusable for me
09:35:56 <maerwald> but the topic is annoying
09:36:05 <nshepperd_> "the road to hell is paved with UX"
09:36:25 <ezyang> Well, from a technical perspective, one of the reasons Stack can offer good UX is because it is less flexible 
09:36:36 <ezyang> That is a good thing from a UX perspective, except when you need the flexibility 
09:36:58 <ezyang> I think people should use Stack if it works, because it will be a lot smoother, but know when to use something else if the extra flexibility is needed. 
09:37:02 <ertesx> the point is that there is still a world outside of stack, and some weird people like me choose to live there =)
09:37:02 <hvr> ezyang: clearly, those who need flexibility are doing it wrong ;))
09:37:34 <bollu> maerwald: what's this about community splitting?
09:37:36 <ezyang> For example, if you're a beginner, yeah, please use Stack 
09:37:57 <bollu> ertesx: ah, sorry, I missed that bit :)
09:37:59 <maerwald> bollu: it's OT here I'd say
09:38:05 <bollu> marcel: what's OT?
09:38:15 <hvr> ezyang: and once you become an expert, gradudate to cabal? :)
09:38:45 <ezyang> pray that you never become an expert :P 
09:39:00 <bollu> hvr: I would like to help with cabal if possible, though I have little experience with large scale haskell projects
09:39:04 <bollu> hvr: can I still help?
09:39:05 <ertesx> i haven't found myself recommending stack yet, but i can see some scenarios where i might; most notably windows
09:39:14 <hvr> bollu: there's plenty of easy tasks
09:39:48 <hvr> bollu: there's even non-programming tasks, if documentation is something you have a hang for
09:39:49 <ertesx> "beginners" in general?  not so much…  most linux distributions handle GHC well enough
09:39:55 <ski> bollu : "Off Topic", i suppose ..
09:40:14 <bollu> hvr: such as?
09:40:29 <ezyang> ertesx: Well, there's something to be said for being given a set of packages that are known to build well together 
09:40:45 <bollu> ertesx: beginner in the sense of, I'm decent at Haskell. Not ekmett level, but decent. Want to work on something large
09:41:57 <ertesx> at any point anyone can choose to use stack for anything…  i just don't find myself recommending it to beginners in general, only in certain cases
09:41:58 <ezyang> bollu: the 2.0 milestone tracks the things we really want to fix for next release  https://github.com/haskell/cabal/milestone/39 
09:42:12 <ertesx> i found that the LTS deal is not that important for most beginners
09:42:30 <ezyang> ertesx: Well, it's certainly true if they're only using base ghc is enough 
09:42:47 <ezyang> bollu: Things that are not assigned need hands. Some tickets are complex because they require some design work 
09:42:48 <Clint> the lts deal is all i care about and i don't even use stack
09:43:02 <ezyang> bollu: Are you interested in bug fixing or features? 
09:43:14 <bollu> ezyang: I'd like to start wth bug fixes
09:43:22 <ertesx> ezyang: i have yet to experience a haskell workshop that suffered from the library issue at all, and we have installed some rather heavy packages like lens, wai or the snap framework
09:43:47 <ezyang> bollu: How complicated, from a scale of minimal test case available to big complicated test case that needs minimizing? ;) 
09:44:05 <ezyang> ertesx: Those packages are good citizens ;)  I hear it's much less rosy in yesod land 
09:44:27 <ertesx> ezyang: the thing that i'll probably do differently in future workshops is to make people aware of stack, but not in the sense of recommending it, just talking about it and how/when it helps
09:44:33 <maerwald> ertesx: I know one or two packages that really have cabal hell... and the dev uses stack ;P coincidence? No.
09:44:44 <ertesx> ezyang: yeah, i can see how yesod could be problematic =)
09:45:05 <maerwald> because they stopped caring about correct upper bounds and testing against latest hackage
09:45:34 <maerwald> huge projects like snap usually don't have that problem
09:45:36 <ezyang> bollu: HTis is a really important bug that needs fixing https://github.com/haskell/cabal/issues/3871 it might be a GHC bug 
09:45:47 <ertesx> maerwald: well, sure, but stuff like that can be fixed:  file an issue or even send a patch
09:45:54 <maerwald> ertesx: lol
09:45:54 <bollu> ertesx: umm, I'm not sure. start with easy? :P
09:45:57 <ertesx> i know how tooling can make you blind
09:46:11 <ezyang> bollu: I haven't tried to repro hvr's test case yet, but I trust him to have given a repro'ing case haha 
09:46:21 <ezyang> ertesx: Oops, that's not an easy one, I think 
09:46:21 <ertesx> but i think we have all suffered from that at some point =)
09:47:16 <ezyang> bollu: The band-aid fix for https://github.com/haskell/cabal/issues/3881 should be simple 
09:47:45 <ertesx> ezyang: what's not an easy one?
09:47:59 <ezyang> ertesx: Sorry, I meant to send that to bollu 
09:48:02 <ertesx> ah
09:48:11 <ezyang> bollu: https://github.com/haskell/cabal/issues/3853 should be easy but it might involve mucking about hackage-security 
09:48:52 <bollu> ezyang: what's hackage-security?
09:48:53 <ezyang> bollu: Does that help? If you lurk in #hackage and pester with questions we'd be more than happy to help 
09:49:08 <ezyang> bollu: It's this guy: https://github.com/well-typed/hackage-security/ 
09:49:19 <ezyang> cabal-install depends on it 
09:49:25 <bollu> ezyang: cool, so I can pick up 3853?
09:50:13 <ezyang> sure 
09:50:21 <ezyang> are you @bollu on GitHub? 
09:50:43 <bollu> yep
09:51:49 <ezyang> bollu: I think the first thing I would do is to build Cabal/cabal-install with new-build, with a checkout of hackage-security in the top-level directory 
09:52:13 <ezyang> then grep for "Could not read index" and read the code until you understand the bug (adding traces as necessary) 
09:53:37 <bollu> thanks :)
09:54:07 <ezyang> happy to see extra hands :) 
10:02:34 <glguy> Can I tell cabal new-build it needs to reconfigure?
10:03:14 <ezyang> glguy: delete the cache dir :( 
10:03:20 <glguy> OK, thanks
10:03:32 <ezyang> file a bug too please 
10:06:28 <glguy> ezyang: Is it the case that new-build uses different autogen dirs for each component in Cabal-1.24 ?
10:06:46 <glguy> (seems related to a ticket you and edward were involved with)
10:06:56 <ezyang> glguy: I think that's HEAD only 
10:07:46 <ezyang> because convenience libraries haven't been in a real release yet 
10:07:49 <glguy> Because I'm trying to generate a Build_packagename.hs module and my library section sees it with new-build but the executable component : setup: Error: Could not find module: Build_glirc with any suffix:
10:08:21 <ezyang> this is 1.24? 
10:08:35 <glguy> I don't even know why the executable section is looking for it, it's not mentioned in the executable section. it's in the "other-modules" of the library component
10:08:39 <glguy> Yeah, just released Cabal
10:09:03 <ezyang> oh did we just release a patchfix 
10:09:11 <ezyang> hmm, but I don't think that includes 90e908b80b327c4636c21627b0e2a54a6a8d4e4f 
10:09:22 <glguy> I'm on stock 1.24.0.0 cabal-install and Cabal both
10:09:45 <ezyang> ok, then this is probably something different 
10:10:13 <MasseR> Does the yaml library support decoding base64 values? As in something like '!binary |-\n w6Ri' ?
10:10:41 <ezyang> uhh, file a bug. Give us -v3 output 
10:10:51 <ezyang> (sorry bug doesn't ring a bell) 
10:12:53 <glguy> ezyang: OK, I'll try to put together a bug report. running with -v shows that the problem is in the sdist phase of new-build: /Users/emertens/Source/glirc/./dist/setup/setup sdist --verbose=2
10:18:09 <ezyang> glguy: Oh I know what the problem is. Make sure your sdist hook is generating your Build module too 
10:18:28 <glguy> ezyang: Oh, thanks
10:20:24 <ezyang> there's also https://github.com/haskell/cabal/issues/3656 but this is only fixed in HEAD 
10:23:01 <muyfine> I'm trying to write a nested lookup for aeson value type - something that takes a list of keys and keeps doing lookups
10:23:14 <muyfine> I've got a couple of implementations http://lpaste.net/209302
10:23:36 <muyfine> not super excited about either one - is there a more concise way to represent that?
10:31:37 <johnw> lookups ks <$> Map.lookup k m
10:31:59 <johnw> oh, you'd need to unwrap Object still
10:32:10 <johnw> (\(Object m') -> lookups ks m') <$> Map.lookup k m
10:33:24 <glguy> ezyang: How would I know where to create the module? the LocalBuildInfo field is optional
10:34:02 <glguy> (I'm looking at sDistHook)
10:34:59 <muyfine> johnw thanks - is that not a partial function though?
10:35:18 <johnw> muyfine: you are right, never mind me
10:36:00 <mutantmell> Hey everyone, I have a question about TypeInType.
10:36:03 <mutantmell> I have a data type that looks like this: data Default (t :: *) (d :: t) = Default | Override t
10:36:18 <mutantmell> And I would like to write a function like this: extract :: Default t d -> t
10:36:43 <mutantmell> Is this something that is possible today, because most of my attempts have resulted in failure :)
10:36:55 <muyfine> the fact that I only want to operate on one of the Just values differently is what's throwing me... feel like a prism might help me
10:38:03 <johnw> sure it would
10:38:56 <johnw> something along the lines of: m ^? ix k . _Object . to (lookups ks)
10:39:32 <johnw> using lens-aeson
10:41:53 <muyfine> johnw nice - I'll check that out
10:42:46 <Enigmagic> mutantmell: no, you need some way to get a value for the Default case
10:44:07 <mutantmell> Enigmagic: The idea is that the default value is stored in the Type.  I believe (say) Idris can do this, and I wasn't sure if there was a way to do it with TypeInType at this date
10:45:34 <mniip> 1474565781 [20:36:21] <mutantmell> Is this something that is possible today, because most of my attempts have resulted in failure :)
10:45:38 <mniip> with reflection perhaps
10:46:37 <mutantmell> mniip: Thanks, I'll take a look
10:55:26 <glguy> dcoutts: You around? I'd like to generate a dynamic module, I want it to contain a list of all the packages and versions I depend on. I can create this file in the postConf hook and building works fine. I'd like to tell Cabal not to look for this module in src/ when building a source tarball (because it will be created at configure time). Is that possible?
10:55:38 <dcoutts_> glguy: hia
10:56:12 <dcoutts_> I think so, you can override the src dist hook I think
10:56:34 <glguy> This one specifically? sDistHook :: PackageDescription -> Maybe LocalBuildInfo -> UserHooks -> SDistFlags -> IO ()
10:57:14 <glguy> Would I just want to remove the module in question from all components of the PackageDescsription then?
10:57:25 <glguy> and then defer to the standard implementation of sDistHook?
10:57:32 <dcoutts_> glguy: right, exactly
10:58:07 <dcoutts_> and also add your +1 to the appropriate ticket about easier support for generated modules :-)
11:00:37 <mutantmell> mniip: It looks like that'll work, but the type won't be as clean
11:00:43 <mutantmell> mniip: thanks for the pointer
11:03:05 <Xnuk> How do you all organize `import`s?
11:07:14 <Welkin> how do you install new packages or start new projects using nix?
11:07:46 <dmj`> Welkin: check out cabal2nix
11:08:18 <sm> Xnuk: alphabetically in two groups: imports from outside and imports from the current project
11:08:31 <Welkin> what about ghc versions?
11:08:57 <sm> Xnuk: and some projects group common ones into an Import.hs
11:09:04 <dmj`> Welkin: by default nix is configured to use the latest ghc, like 8
11:09:44 <dmj`> Welkin: it's namespaced
11:09:44 <Welkin> dmj`: I'm using whatever reflex-platform installed for me and trying to create a new servant + ghcjs project
11:09:55 <dmj`> so if you want an arbitrary environment for ghcjs and the hashtables package, let's say
11:09:58 <dmj`> nix-shell -p "haskell.packages.ghcjs.ghcWithPackages (pkgs: with pkgs; [hashtables])" --pure
11:10:09 <dmj`> Welkin: cool
11:10:57 <Welkin> dmj`: I wasn't bragging o.o
11:11:00 <Welkin> I was asking for help
11:11:25 <Welkin> I'm already in a nix shell
11:12:09 <Welkin> bb
11:13:04 <Xnuk> sm: Import.hs is a great idea
11:16:17 <sm> Xnuk: see the yesod starter template for an example, I think
11:18:04 <dmj`> Welkin: ok
11:23:29 * hackagebot repr-tree-syb 0.1.1 - Tree representation and pretty-printing of data structures based on SYB  https://hackage.haskell.org/package/repr-tree-syb-0.1.1 (NikitaVolkov)
11:23:31 * hackagebot x86-64bit 0.4 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.4 (PeterDivianszky)
11:34:01 <mniip> I wonder, are classes of languages described with applicative parsers and monadic parsers different?
11:34:36 <mniip> probably context-sensitive vs recursively-enumerable?
11:35:27 <VitorCBSB> I *think* applicative parsers describe context-free languages.
11:39:35 <joe9> is map a wrapper over hashmap? I want to store using an Integer (microseconds) as index. Would Hashmap.Strict be performant?
11:40:01 <joe9> I meant "is Data.Map a wrapper over HashMap"
11:40:02 <dmj`> joe9: use an IntMap
11:40:05 <grantwu> Perhaps consider https://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-IntMap.html
11:40:25 <dmj`> joe9: you might be able to use a vector too
11:40:50 <ReinH> Data.Map is not a wrapper over HashMap, nor could it be.
11:41:01 <joe9> dmj`: Is IntMap a good idea when the indexs are very sparse?
11:41:11 <ReinH> Yes.
11:41:18 <ReinH> That's the intended use case of maps.
11:41:30 <joe9> dmj`: ReinH, ok, Thanks.
11:41:43 <ReinH> In that case, Vector would *not* be appropriate.
11:41:55 <dmj`> joe9: what ReinH said
11:42:14 <ReinH> dmj`: just saving you some typing
11:43:16 <dmj`> ReinH: heh :]
11:52:22 <buglebudabey> if i have a datatype defined "data Expr a = M a | ... " and I have a M String in one circumstance and an M (String, String) in another circumstance, how can i account for that?
11:52:37 <Franciman> Hello
11:52:41 <buglebudabey> by pattern matching on M?
11:52:56 <Franciman> Is there any new interesting library around for GUI programming in haskell?
11:52:59 <buglebudabey> M [] = ..., M(a,b) = ...?
11:53:07 <glguy> dcoutts_: It seems like removing the module from the PackageDescription is changing the package id and making new build mad
11:53:16 <glguy> but removing it does allow normal sdist to succeed
11:53:43 <lpaste> glguy pasted “error after removing autogen module from PackageDescription” at http://lpaste.net/209475
11:54:28 <glguy> What I did: https://github.com/glguy/irc-core/blob/setup-plugin/setup/src/DependencyTools.hs#L35
11:54:51 <hpc> buglebudabey: if you have an M String sometimes and an M (String, String) sometimes, that mean your type is Expr SomethingThat'sBothStringAndTuple
11:55:46 <buglebudabey> hpc in reality it can be whatever, but i need to extract information from the a in "M a", can if a can be any type i'm not exactly sure how to go about that
11:55:50 <hpc> as stated you would not be able to match those separately
11:55:59 <hpc> getting that information would break parametricity
11:56:12 <hpc> you'll need to reformulate your Expr type to support that operation
11:56:50 <hpc> and how you do that depends on the larger problem around Expr
11:57:06 <joe9> I am doing this to get the current time in microseconds: http://dpaste.com/0QVKF2G . Just want to check if there is a library that might already be doing this.
11:57:10 <hpc> but most likely you split M into a constructor for strings and another for tuples, or something
11:57:22 <buglebudabey> okay so if i wanted to make it only accept "a" as a string or a tuple then i can make a new datatype wrapping a string or tuple?
11:57:29 <hpc> or instead of M ("something", "something else") you have (M "something", M "something else")
11:57:53 <hpc> or Either
11:58:02 <buglebudabey> ok thanks
11:58:21 <dcoutts_> glguy: hmmm
11:59:48 <buglebudabey> hpc, if i leave the type def as "data Expr a = M a ..." then use GADTS to say (M a :: EitherTupleString -> Expr EitherTupleString), is that okay?
12:00:29 <dcoutts_> glguy: that's very odd, since that should not affect the package registration info that's generated
12:00:33 <buglebudabey> hpc whoops i mean M:: a -> Expr EitherTupleString
12:03:12 <ReinH> joe9: What are you doing with the current time in microseconds? I ask because the current time in microseconds is a lie in many applications.
12:03:41 <ReinH> In the presence of multiple machines, multiple processes, or even multiple threads, the answer you get can be incoherent.
12:12:33 <glguy> dcoutts_: does it look like I'm doing the right things and this is a bug or am I doing something unintended?
12:18:54 <glguy> maybe instead of generating a Haskell module I should be generating a text file and loading that via template Haskell
12:23:31 * hackagebot keysafe 0.20160922 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20160922 (JoeyHess)
12:27:53 <ilyanok> Sorry for asking this twice but can anyone show me how to use Data.Constraint.Forall module?
12:27:56 <ilyanok> I tried http://lpaste.net/208767 but ghc is not happy...
12:31:44 <edwardk> ilyanok: what constraints do you need on f for PFix f to be traversable?
12:32:38 <edwardk> ilyanok: you're saying there that forall x that Traversable (f x) can be proven to hold, right?
12:32:52 <ilyanok> edwardk: forall s. Traversable f s
12:32:59 <ilyanok> right
12:33:11 <edwardk> what does ghc tell you when you try that right now?
12:33:22 <edwardk> that it can't figure out the type to use instF at?
12:33:56 <edwardk> try turning on scoped type variables and giving instF an explicit type signature or using type application
12:34:14 <edwardk> right now it has no reason to pick the instF from ForallF Traversable f     vs. any other ForallF it has in scope.
12:34:35 <edwardk> type type and therefore effect of instF is underdetermined
12:34:51 <ilyanok> nope... I think one error is "Can't deduce Traversable f (PFix f)" and "Overlapping instance ForallF ..." but let me re-check
12:35:57 <edwardk> what is the signature of instF again? forall x. ForallF p f :- p (f x) ?
12:36:13 <edwardk> so if you turn on ScopedTypeVariables and then use
12:36:31 <ilyanok> http://lpaste.net/209568 here are the error messages
12:36:47 <buttbutter> Hey. I'm trying to understand chainl/chainr/chainl1/chainr1 from ReadP. Here's the source: http://paste.ubuntu.com/23217259/. What I don't understand is how x and y are unique values, if (>>=) :: m a -> (a -> m b) -> m b.
12:36:51 <edwardk> traverse f x \\ (instF :: ForallF Traversable f :- Traversable (f (PFix f)))
12:37:28 <edwardk> but you're going to need that signature there to use instF
12:37:36 <edwardk> regardless of what other extensions you turn on
12:37:40 <edwardk> and you'll need ScopedTypeVariables to write it
12:37:45 <edwardk> (or type application)
12:38:23 <edwardk> buttbutter: you might try looking at my implementation in `parsers`?
12:38:54 <edwardk> er i guess they are no more informative
12:38:55 <edwardk> https://github.com/ekmett/parsers/blob/master/src/Text/Parser/Combinators.hs#L208
12:39:08 <ilyanok> edwardk: Wow, it compiled! Thanks, Edward!
12:39:13 <sim642> Is there a nicer way to achieve this: takeZipLength xs ys = map snd $ zip xs ys ? I could define the thing nicely with pattern matching but I was hoping there'd be some one-liner way to do this
12:39:15 <edwardk> ilyanok: np
12:39:49 <edwardk> :t flip (zipWith const)
12:39:50 <lambdabot> [b] -> [c] -> [c]
12:40:06 <edwardk> or zipWith const ys xs
12:40:09 <sim642> ooh
12:40:27 <edwardk> :t zipWith (const id)
12:40:28 <lambdabot> [b] -> [c] -> [c]
12:40:32 <edwardk> etc
12:40:52 <buttbutter> Hm. I mean, I literally just don't understand the basic source.
12:41:00 <buttbutter> I don't understand why x isn't the same as y.
12:41:30 <buttbutter> If (>>=) literally extracts the "a" from an m a, in this case, from p. Then how is x different from y?
12:42:09 <edwardk> buttbutter: think about how a parser combinator library works
12:42:12 <edwardk> let's define a simple one
12:42:27 <edwardk> newtype Parser a = Parser (String -> [(a, String)])
12:42:36 <edwardk> you have an extra input you aren't seeing there. the input string
12:42:51 <buttbutter> Right.
12:43:07 <tsahyt> While trying to implement asteroids using AFRP (wires) I've come across a situation where the easiest way to solve something would be a function of type Wire m a b -> (b -> Wire m a c) -> Wire m a c. Now this looks suspiciously like bind and it brought me back to the question why exactly do AFRP libraries not have Monad instances these days?
12:43:20 <tsahyt> I've read that it compromises performance, but I'm not sure how
12:43:39 <edwardk> when you run a parser p       with do x <- p; q x    you are consuming from an input string, producing a new 'a' (here, x) and a new string representing the rest of the input, if you run 'p' again it is now running on this ever shortening remaining input string
12:43:43 <edwardk> so it isn't the same thing
12:44:21 <buttbutter> Ah, right.
12:44:28 <edwardk> do x <- p; y <- p; return (f x y)   -- first runs it with the whole string, then, the parser p eats some of it, if the state stays the same between invocations of p, e.g. the parser doesn't consume any text, of course you'll get the same answer
12:44:35 <ReinH> tsahyt: monadic bind represents dynamic dispatch of behaviors
12:44:37 <edwardk> but here the very point of 'p' is to parse something
12:44:59 <buttbutter> I see I see :)
12:45:04 <ReinH> i.e., your behavior and a 'behavior selector' serve as a sampling device
12:45:11 <tsahyt> ReinH: I think I still don't understand FRP well enough to see why this would be bad
12:45:22 <buttbutter> So a bind is like (m1 >> m2) in a way except m2 is "chosen" based off the result of m1.
12:45:38 <edwardk> tsahyt: the issue of having monadic binding in FRP is usually one of memory. say you have a thing that switches the whole computation pipeline to a different one, then you switch back, you can't really do that monadically with the same 'memory' of what the state was in the middle tha tyou can with, say, an applicative
12:45:38 <buttbutter> But a computation still happens, just like with (>>).
12:45:49 <ReinH> tsahyt: One concern seems to be introducing time leaks: http://apfelmus.nfshost.com/blog/2011/04/28-frp-banana-0-2.html#comment-194103280
12:46:02 <sim642> edwardk, wait, what's happening in (const id)?
12:46:07 <jonored> buttbutter: And in fact, a >> b is a >>= (\_ -> b)
12:46:20 <buttbutter> jonored: Ah, right :D
12:46:32 <edwardk> with an applicative    i can see both things like f <$> foo <*> bar   -- i can write an interpreter that knows about foo and bar, independnet of the result of 'foo'
12:46:36 <buttbutter> The function of (>>) is so clear in my head because it's called "then" or "and then"
12:46:43 <buttbutter> Which isn't so obvious with bind :)
12:46:51 <edwardk> but with a moand foo >>= \x -> bar >>= \y -> f x y;  -- unless i can run 'foo' i can't know bar.
12:46:51 <JonReed> Hi, is there a way quickly pattern match newtype using lens. like `newtype MyInt = MyInt Int; makeClassy ''MyInt`. ` `(myInt . MyInt) :: _ -> Int`
12:47:01 <ReinH> You can also call bind "then" if you suitably change the meaning of "then" ;)
12:47:02 <edwardk> but this means i can't easily track state related to bar behind the scenes for you
12:47:18 <buttbutter> ReinH: True :D
12:47:27 <ReinH> then (>>) becomes a special kind of "then", namely: "then but ignoring the previous result"
12:47:36 <tsahyt> ReinH: Ok so I think I finally understood what a time leak actually is. thanks for the link!
12:47:46 <JonReed> In other words, I want to extract Int from MyInt using lens. Is the easiest way would be to redefine newtype as `newtype MyInt = MyInt { unInt :: Int }`
12:47:51 <buttbutter> Maybe (>>=) can be the verbose "Based off of that computation, do this next" :D
12:48:00 <edwardk> JonReed: typically you'd make an instance of the classes needed to make _Wrapped and _Wrapping MyInt work
12:48:06 <tsahyt> edwardk: so it hinges on the fact that a Monad can decide where to go next based on the input, and an Applicative can not?
12:48:22 <buttbutter> edwardk: Anyway, thanks for clearing that up. I think I can proceed now.
12:48:35 <edwardk> tsahyt: yeah, and arrows and applicatives are limited enough that you can 'see all the parts' without running the computation
12:48:58 <tsahyt> ah, so ArrowApply encapsulates this notion of decision making then?
12:49:05 <edwardk> yes
12:49:24 <edwardk> when you find yourself in ArrowApply, you're basically hosed for the same reasons as Monad
12:49:25 <ReinH> basically, the moment you add Monad behaviors, you immediately get a dynamic behavior graph with all it implies
12:49:51 <edwardk> i've been wondering if an imgui in haskell would be a fun frp alternative
12:50:16 <sm> I like the sound of that
12:50:19 <edwardk> doubling down on the 'monad' side of the equation, removing the memory
12:50:26 <tsahyt> now I just gotta figure out if I can do what I need without the power of monads
12:50:29 <tsahyt> I think in my case I can
12:51:03 <ReinH> ditto ArrowApply, which is an annoying way to say Monad.
12:51:08 <edwardk> encapsulating state in a few well chosen places and things like 'mouse location' rather than monolithic user-side state in the frp machinery
12:51:35 <edwardk> well, Arrow is already a Monad, just in Prof.
12:51:43 <tsahyt> edwardk: what's an imgui?
12:51:52 <ReinH> edwardk: imgui-hs++
12:52:01 <edwardk> tsahyt: an 'immediate mode gui'.
12:52:04 <ReinH> An "immediate mode"... yeah
12:52:11 <edwardk> basically you turn the entire world on its ear for gui design
12:52:35 <ReinH> edwardk: I meant Monad, not monad. :p
12:52:37 <edwardk> instead of having your state and a bunch of stuff that mutates that state, and a bunch of display elements with their own state, and then having to make sure you wire all three of those thigns together as you go
12:52:52 <ReinH> edwardk: That sounds like the way a Haskeller would do it.
12:53:33 * ski waits for the remainder
12:53:39 <EvanR> me too
12:53:52 <edwardk> you instead just make a function like 'button' or 'text_field' or whatever that simultaneously renders the control at some kind of cursor position, and checks for input for that button or text field for the current frame
12:54:22 <edwardk> in c++, you can do things like just call if (gui::button("hello")) { respond, right here, right now; }
12:54:23 <ski> edwardk : a bit like continuation-based web stuff in inverting control (back) ?
12:54:46 <edwardk> gui::slider("x",&x,0,1); -- throws a slider control up and edits the value 'x' in place
12:54:58 <edwardk> well, the key is more that there is zero memory to the imgui
12:55:12 <edwardk> you just call the function that happens to draw the widgets every frame
12:55:19 <edwardk> if you want to hide something? don't draw it
12:55:32 <edwardk> tree control? just keep recursing into the tree
12:55:45 <ski> and it automatically layouts ?
12:56:03 <edwardk> the imgui itself maintains some active state about which control was active last frame, and you can provide hints like 'draw the next control on the same line as the previous one'
12:56:10 <edwardk> or you can do more manual positioning
12:56:46 <edwardk> typically for things like menus the best way to do it is to use one frame to figure out the width of the menu itself, and of the little shortcut key area and icons, etc. then use that width for all subsequent frames
12:56:56 <edwardk> so you can do detailed layout
12:57:38 <ski> mhm
12:57:39 <EvanR> so it responds to clicks and keypresses immediately
12:57:40 <edwardk> https://www.youtube.com/watch?v=pBjzyi3YVVA&feature=youtu.be
12:57:49 <edwardk> see the little windows there? those are all draw imgui style
12:57:54 <EvanR> and its up to you to remember that so it can display differently
12:58:36 <edwardk> it also has some efficiency wins, normally a 'text field' holds onto all sorts of editor state even when it isn't actively being used
12:58:51 <ReinH> edwardk: btw has there been any interesting new research into fm indexes since 2012 or whenever? more on dynamic updates, etc?
12:58:56 <edwardk> so here the imgui backend takes control of that and holds onto a single 'editor state' or whatever for the focused view
12:59:04 <ReinH> A quick google scholar search didn't turn up much
12:59:07 <edwardk> ReinH: not that i've seen
12:59:10 <ReinH> k
12:59:20 <tsahyt> edwardk: does this require redrawing of every widget in every frame?
12:59:35 <edwardk> tsahyt: sure. but that is the gpu's job.
13:00:00 <edwardk> i can hit 90fps there without it taking more than a fraction of a millisecond to draw the ui stuff
13:00:12 <edwardk> the time is all spend doign the interesting bits
13:00:32 <edwardk> tsahyt: on the other hand you can do things like infinitely deeply nested menus, etc.
13:00:39 <edwardk> so its a trade-off
13:01:31 <ski> who cuts it off ?
13:01:43 <edwardk> as a functional programmer i tend to like the notion of using an 'immediate mode scene graph' as a function handled the same way, scribbling into draw lists, etc. as it goes
13:02:04 <edwardk> ski: how many menus do you currently have open as you are navigating down the tree?
13:02:24 <edwardk> you don't pay anything at all for a menu that isn't currently open and being explored
13:02:40 <ski> well, i assume you have an infinite recursion for the infinite menues, yes ?
13:02:52 <edwardk> ski: you have a menu that looks like
13:03:12 <ski> i suppose the items in the menu are guarded behind a suspension or something
13:03:33 <edwardk> void recurse() { gui::begin_menu(); if (gui::menuitem("recurse")) { recurse(); gui::endmenu() } };
13:03:36 <edwardk> the 'if' cuts you off
13:03:42 <edwardk> no suspensions, etc. just straight line c code
13:04:01 <edwardk> i probably mangled that
13:04:14 * ski doesn't follow
13:04:30 <EvanR> what is the return value of gui::menuitem("recurse"), i guess a bool/int ?
13:04:31 <ski> `begin_menu' and `endmenu' looks stateful
13:04:32 <edwardk> but the intent was to have begin/end menu pairs, and an if (gui::menuitem call that returns true if the menuitem is currently open)
13:04:33 <EvanR> which means what
13:04:53 <ski> oh, i see
13:05:08 <edwardk> ski: yes, the whole kit and kaboodle is a ball of muddy state. like glBegin(); glPoint(); glPoint();glPoint(); glEnd();  --- immediate mode graphics in the old gl days
13:05:24 <EvanR> so it returns true if that widget is currently activated, clicked
13:05:29 <EvanR> or in this case open
13:05:50 <EvanR> and the if block acts as a callback
13:06:01 <EvanR> which might draw more stuff
13:06:13 <EvanR> i wish GL was this nice ;)
13:06:37 <edwardk> the 'state' here is the hidden state inside of the gui system itself, but it only kind of contains information about the path to the last thing that was open last frame or whatever.
13:06:58 <edwardk> so the internal state of the entire system is a single stack of menu items to the current 'hot' menu item
13:07:35 <edwardk> https://github.com/ocornut/imgui provides a bunch of examples in the readme
13:07:40 <EvanR> are you thinking this would be a monad? or some other structure for the haskell version
13:08:03 <edwardk> it'd probably be a monad or just a pile of mutable goo in IO or something
13:08:12 <edwardk> something that gets it out of the way
13:08:24 <EvanR> sweet
13:08:44 <edwardk> dear imgui has the benefit that it plugs into _anything_ since all it does is produce triangles to render later, and knows nothing about your graphics pipeline
13:09:04 <edwardk> so you scribble into it, tell it about mouse movement and keyboard events, and it gives you back triangles for the frame that you draw at the end yourseld
13:09:07 <edwardk> er yourself
13:09:25 <edwardk> it manages an internal font atlas by asking you to stick a big array it gives you into a texture
13:09:34 <edwardk> so you provide its entire worldview
13:09:50 <EvanR> oh, fonts?
13:09:54 <edwardk> i've been looking at this as a way to do vr interactions, by stealing the same concepts, etc.
13:10:22 <edwardk> it uses stb to load truetype fonts and has a simple font baked in
13:11:28 <edwardk> the funny thing is that gui's built this way despite sometimes needing a frame worth of delay for layout are way punchier than ones built the old style. try moving through a menu in a windows app and watch how long it takes for a submenu to pop up some time. they do that so you don't lose the submenu when you go to move the mouse towards it
13:11:39 <ixor> is there something in haskell to replace solr and lucene?
13:11:55 <edwardk> ixor: nothing i know of
13:12:09 <EvanR> whats with the frame worth of delay
13:12:10 <ixor> edwardk: what are you building gui with?
13:12:17 <EvanR> i didnt get that part
13:12:37 <edwardk> EvanR: say you want a nicely laid out menu, with icons in a column, text in a column, short-cut text in a column...
13:12:38 <EvanR> you draw stuff and then measure it somehow?
13:13:07 <edwardk> how wide should the menu be? will it fit on the screen or should it move backwards a bit? etc
13:13:39 <edwardk> ixor: right now i'm just dumping out code in c++ for it, rather than using haskell. i spent a long time fighting with haskell + qt before this.
13:13:52 <EvanR> right but how do you do it
13:13:56 <edwardk> and various other gui frameworks before hand
13:14:35 <edwardk> imgui currently holds onto a stack of measuring frames on the path to the hot object that you can stuff measurement data in from your evil stateful nasty widget.
13:15:04 <EvanR> ok
13:15:21 <EvanR> and when you use that in the next frame, is there a graphical jump
13:15:30 <EvanR> or is the measuring process invisible
13:15:36 <edwardk> so e.g. a menuitem draws as it will, but also scribbles the max of its widths per column into that transient table of column widths for the current menu stack depth.
13:15:49 <edwardk> its amazing how little you can see of one frame at 90hz =)
13:15:57 <EvanR> uh huh...
13:16:08 <edwardk> the gui framework can decide not to draw the 'measuring' frame or whatever internally
13:16:17 <EvanR> that would be unacceptable for a pro web page gui ;)
13:16:23 <EvanR> oh ok
13:16:31 <edwardk> remember everything is going into draw list and then happening later
13:16:44 <edwardk> so you can just shut off the draw list, while letting everything else happen
13:17:12 <edwardk> these aren't chaotic css %age layouts, etc.
13:17:21 <edwardk> there isn't a separation of style/logic
13:17:29 <edwardk> the very point is to get something up and tinkerable fast
13:17:29 <EvanR> splendid
13:18:16 <edwardk> you can get good at this style and make things that look good, but i'm more interested in doing things like getting my scene editable.
13:19:22 <edwardk> so make a scene graph, render a 'tree' control as you navigate down the scene graph in the real scene. throw a panel with whatever the currently manipulated object is in the world's state, just as a bucnh of sliders and text fields
13:19:46 <edwardk> and now you can navigate up and down the scene in a tree control and edit everything in your world
13:20:15 <edwardk> the 'editor' can be as simple as hooking into your serialization framework and 'serializing' to the gui
13:20:48 <edwardk> use the same framework to dump it to json or a binary format
13:21:35 <edwardk> i also just realized that i'm spamming #haskell with all of this, not #haskell-lens. oh well =)
13:21:54 <edwardk> clearly we need #haskell-lens-flare
13:22:20 <phadej> :)
13:22:53 <hololeap> I'm pretty sure the answer is "no," but I wanted to double-check: can you infix more than one function like so: [1,2,3] `flip (++)` [4,5,6]
13:23:26 <alexkosh> hey, how to import somthing which conflicts with prelude, so I can use function which do not conflict unqualified and the one which conflict qualifed, while still use prelude conflicting function unqualified?
13:23:33 * hackagebot synthesizer-llvm 0.8.1.2 - Efficient signal processing using runtime compilation  https://hackage.haskell.org/package/synthesizer-llvm-0.8.1.2 (HenningThielemann)
13:23:35 * hackagebot boolean-like 0.1.0.0 - Logical combinatory operations dealing with datatypes  representing booleans by their constructors.  https://hackage.haskell.org/package/boolean-like-0.1.0.0 (Shou)
13:24:02 <phadej> alexkosh: import Prelude hiding (clashingFunc); import qualified Prelude as P
13:24:13 <edwardk> hololeap: no, but you can make a pair of combinators <| and |> that combine to let you write [1,2,3] <| flip (++) |> [4,5,6]
13:24:35 <hololeap> o_O
13:24:42 <edwardk> i think my favorite version of that is to call them -: and :-     where :- is a data constructor for a tuple type
13:25:00 <edwardk> and -: unpacks it, choose fixity of -: and :- appropriately
13:25:04 <alexkosh> thx, so I can import somthing twice) cool
13:25:31 <edwardk> the first version of that trick i saw was due to chung-chieh shan
13:26:13 <phadej> alexkosh: yes, import language is quite powerful, e.g. import Data.Map as Data.Set (fromList) and make your co-workers wonder what happens
13:27:02 <hololeap> Prelude Data.Sequence> [1,2,3] <| flip (++) |> [4,5,6]
13:27:02 <hololeap> Precedence parsing error  cannot mix ‘<|’ [infixr 5] and ‘|>’ [infixl 5] in the same infix expression
13:27:16 <edwardk> hrmm
13:27:18 <edwardk> > [1,2,3] & flip (++) $ [4,5,6]
13:27:20 <lambdabot>  [4,5,6,1,2,3]
13:27:27 <edwardk> tada. we have an appropriate pair in base today
13:28:55 <dmwit> (&) is in base?
13:29:06 <ongy> is it in Prelude?
13:29:06 <edwardk> dmwit: in Data.Function for a year or two now
13:29:33 <dmwit> jeez, I'm behind the times
13:29:38 <hololeap> hoogle doesn't show it :/
13:29:47 <dmwit> http://hoogle.haskell.org/?hoogle=%28%26%29 does
13:30:01 <edwardk> hololeap: it is probably running off an old base?
13:30:10 <EvanR> edwardk: since im not really in #haskell-lens, im glad you accidentally shared this idea in here
13:30:17 <ReinH> hoogle is a lying liar
13:30:24 <hololeap> weird, i was using www.haskell.com/hoogle
13:30:41 <jacereda> anyone got HaRe working with ghc 8.0.1?
13:30:49 <edwardk> hoogle with the lens combinators in scope is kinda hilarious
13:31:45 <hololeap> *haskell.org
13:32:14 <dmwit> I wrote a small library for defining graphs that sits on top of fgl, and it uses (-|) and (|->) for its edge constructors. One of them is (,) just like edwardk says.
13:32:39 <dmwit> It's pretty fun to write `n -|e|-> n'` to mean "there's an edge labeled `e` from node `n` to node `n'`".
13:32:43 <alanz> jacereda: what do you mean?
13:34:11 <shachaf> dmwit: That should be the syntax for type signatures for functions.
13:34:17 <edwardk> dmwit: cute. i used a type level version of that for a while a -| c |-> b was how I appeased conal after GHC lost the ability to use (~>) as a name for an Arrow variable, etc. 
13:34:48 <shachaf> Ah, that also works.
13:35:05 <shachaf> Does conal actually do that?
13:35:07 <jacereda> alanz: if I try something like "ghc-hare rename Platform/Native.hs os 16 1" nothing happens, I just get (ok ("C:\Users\jacereda\bbs\Platform\Native.hs"))
13:35:09 <edwardk> but there i used -| as flip and |-> as application
13:35:15 <shachaf> I guess I'll find out at his talk in a few weeks.
13:35:19 <jacereda> alanz: no file is modified
13:35:19 <edwardk> shachaf: i think he just learned to cope with the new normal
13:35:25 <edwardk> he eventually quieted down
13:35:39 <shachaf> I guess you need LiberalTypeSynonyms or something to make this work?
13:35:45 <edwardk> for all i know he's still fuming though =)
13:35:53 <EvanR> shachaf: which talk?
13:35:56 <alanz> jacereda: what does ghc-hare --version give you?
13:36:08 <jacereda> alanz: Version 0.8.3.0, Git revision 08dc761a9ee543b5eca76bbb4cf2209fdd96000e (dirty) (1677 commits) x86_64
13:36:32 <edwardk> the above version does have the benefit that -| and |-> can have fixity declarations though
13:36:54 <edwardk> unlike Arrow (~>) => .... which always had to leave (~>) at the default
13:37:02 <jacereda> alanz: tried also the latest tag
13:37:44 <alanz> jacereda: I see that is the current master.
13:38:02 <alanz> Is is possible to share the code you are renaming? is it in a repo somewhere?
13:38:14 <dmwit> edwardk: I love it, it's just as cute at the type level.
13:38:50 <edwardk> personally i just got used to reading the prefix notation -- i guess that makes me sound like a lisper
13:39:05 <jacereda> alanz: unfortunately no, it's a large shake-based build system for my employer and it isn't in any public repo
13:39:30 <jacereda> alanz: would lpasting the debug output help?
13:40:00 <edwardk> (a -> f b) -> p s (f t) -- what isn't to love? =)
13:40:02 <alanz> I was about to ask for that
13:40:40 <jacereda> alanz: -d --verbose vomit?
13:41:29 <alanz> jacereda: yes, I'm a bit rusty on the exact meanings, but -d, and -vv. 
13:41:35 <jacereda> alanz: http://lpaste.net/7278762783989039104
13:42:44 <jacereda> alanz: oops, forgot -d in that one
13:43:06 <alanz> jacereda: try with -d -vvv, the --verbose vomit is for the underlying ghc-mod, I need the HaRe debug output
13:43:32 <jacereda> alanz: ok
13:44:11 <jacereda> alanz: http://lpaste.net/8682757167503114240
13:45:08 <jacereda> alanz: I can try building on a Mac and see if it works there if you think it can make a difference
13:45:41 <jacereda> alanz: I'm on Windows but the line separators are unix, could that be a problem?
13:45:43 <alanz> jacereda: if you could. I am trying to make sense of that debug stuff, it is mostly aimed for dev
13:45:59 <alanz> I doubt it, so long as it parses it should be ok
13:46:26 <alanz> It did not generate a .refactored file anywhere?
13:46:43 <alanz> Because if it returns ok, that's what should have happened
13:47:24 <alanz> There should be C:\Users\ric\bbs\Platform\Native.hs.refactored
13:48:45 <alanz> jacereda: to avoid spamming the channel, maybe switch to #haskell-refactorer
13:48:54 <jacereda> alanz: ok, thanks
14:04:41 <sm> edwardk: is https://wiki.haskell.org/Tangible_Value a kind of immediate gui ?
14:06:03 <edwardk> good question. feels more 'frp'y, to me, but i suppose there is a continuum of such things
14:08:20 <glguy> dcoutts_: follow up, the error message I was running into earlier appears to be specific to new-build + locally defined packages being used as setup.hs dependencies, inlining that code into my setup.hs instead of using a package works fine
14:08:21 <dfeuer> Oh, that's funny. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-difference-between-xtypeintype-and-xpolykinds says the wrinkles in PolyKinds were smoothed out for GHC 7.6. As far as I can tell, they weren't actually all smoothed out till 7.10!
14:08:57 <dfeuer> edwardk, hello! I do have a question or two for you if you have time.
14:09:15 * sm tries to boil down the essence of immediate guis into sentence
14:11:03 <sm> widget view, controller and model data are combined in one entity ?
14:11:45 <sm> which is simpler to work with and compose, possibly at a slight cost in flexibility/performance
14:14:46 <edwardk> sm: you call a function which is responsible for both drawing the widget and checking the world for updates. users aren't tracking widget state, that gets delegated to the ui.
14:15:06 * edwardk hides from dfeuer
14:15:23 <EvanR> runGui :: [Poke] -> Program s -> s -> (s, [Triangle])
14:15:50 <edwardk> pretty much. maybe with some ST like effects if you want to get fancy so it can mutate stuff in place?
14:16:48 <EvanR> too rich for my blood
14:16:55 <dfeuer> edwardk, it's not so bad.
14:17:03 <edwardk> uh huh
14:17:33 <edwardk> you say stuff like that and then you come to me with 'hey, here's how we can replace all of the IntMap internals'
14:17:44 <dfeuer> edwardk, that wasn't me.
14:17:54 <dfeuer> But I do have a question about that too.
14:18:03 * edwardk blinks
14:18:09 <dfeuer> Jonathan S. wants to replace all the IntMap internals.
14:18:14 <edwardk> see!
14:18:15 <dfeuer> And I'd love to help.
14:18:22 <dfeuer> But I have a simpler question first!
14:18:38 <edwardk> ah the gentle but slippery slope begins
14:18:54 <dfeuer> I'm trying to make the Data.Map merge tactic transformation operations (Profunctor, Functor, Applicative, and Category instances, specifically) more efficient.
14:19:06 <edwardk> k
14:19:06 <EvanR> the space of dfeuer's masterplan is path connected
14:19:46 <dfeuer> Currently, a "Missing" tactic is   (k -> x -> f (Maybe y), Map k x -> f (Map k y))
14:20:08 <dfeuer> Super simple, but combining/transforming is awful.
14:21:21 <edwardk> because of the 'f's?
14:22:04 <dfeuer> To fix that, I *think* I need an algebraic datatype.  DropMiss | PreserveMiss (x -> y) (Map k x -> Map k y) | MapMiss (k -> x -> y) | MapMaybeMiss (k -> x -> Maybe y) | TraverseMiss (k -> x -> f y) | TraverseMaybeMiss (k -> x -> f (Maybe y))
14:22:10 <dfeuer> The f's and the Maybes.
14:22:30 <dfeuer> But then actually it's even a little worse, because MapMiss and TraverseMiss need lazy and strict variants.
14:22:37 <edwardk> personally i'd probably leave it out of this thing, and do it separately if at all
14:22:46 <edwardk> because everyone pays for the complexity of mucking with it
14:23:08 <dfeuer> Nothing I've mentioned changes the interface at all.
14:23:27 <edwardk> if 'f' shows up in the type signature it does, no?
14:23:33 <edwardk> if it doesn't you can't do anything with it
14:23:34 * hackagebot boolean-like 0.1.1.0 - Logical combinatory operations dealing with datatypes  representing booleans by their constructors.  https://hackage.haskell.org/package/boolean-like-0.1.1.0 (Shou)
14:23:36 * hackagebot reedsolomon 0.0.4.1 - Reed-Solomon Erasure Coding in Haskell  https://hackage.haskell.org/package/reedsolomon-0.0.4.1 (NicolasTrangez)
14:23:37 <edwardk> so you have to pick
14:23:38 * hackagebot gh-pocket-knife 0.1.0.0 - Script helpers for interacting with GitHub  https://hackage.haskell.org/package/gh-pocket-knife-0.1.0.0 (PatrickBrisbin)
14:23:39 <dfeuer> ?
14:24:15 <edwardk> give the type signature for your GADT, not just constructor members
14:24:22 <dfeuer> There's no GADT here.
14:24:26 <lpaste> glguy pasted “Example --full-version outout” at http://lpaste.net/209821
14:24:42 <edwardk> DropMiss :: ?
14:24:56 <glguy> I thought this was kind of cool and wanted to share, I added a flag to my program that can show all the versions of its dependencies and build tools
14:25:10 <dfeuer> The one where a GADT might be nice is PreserveMiss, but I can get away with two functions instead.
14:26:21 <dfeuer> edwardk, DropMiss is extremely easy. It's super-polymorphic because it only makes empty maps.
14:26:21 <edwardk> glguy: fun. i did something similar once for an old compiler, where i dumped the version numbers of all my deps and current darcs patch state for debugging purposes. wow that must have been a long time ago if darcs was involved
14:26:38 <edwardk> i think i stole the idea of getting the current darcs patch info from darcs itself even
14:27:08 <dfeuer> DropMiss :: WhenMissing f k x y
14:27:12 <glguy> There's a really convenient package for git commit ids on hackage, gitrev
14:27:34 <edwardk> ok, so you currently do bake 'f' into the adt
14:27:59 <dfeuer> Yes, that's unavoidable.
14:28:15 <dfeuer> With either the current approach or the modification.
14:28:40 <dfeuer> Anyway, there are a couple issues:  1. Applicative looks like it's going to be *ugly*.
14:29:06 <edwardk> depends on what you want to have fit into it. (a -> b), (k -> a -> b), (k -> a -> Maybe b) ... all fit and form a category with no mention of 'f'
14:29:11 <edwardk> is why i asked
14:29:45 <edwardk> with all the extra stuff i'm not sure you're an instance of all those classes you want
14:29:53 <dfeuer> Sure I am.
14:30:31 <edwardk> e.g. category needs to know some properties of 'f', if f exists. etc. its a messy non-fundamental design
14:30:46 <edwardk> that is what i mean
14:30:51 <dfeuer> Because the entire thing is a representation of  k -> x -> f (Maybe y), which is basically k -> ReaderT x (MaybeT f y)  (so you get the Kleisli category when f is a Monad),
14:31:54 <dfeuer> er...  I mean  (MaybeT f) y, and of course  also ReaderT k (ReaderT x (MaybeT f)) y
14:31:56 <edwardk> yes, but there is also a composition possible where you can compose k -> a -> f b    and k -> b -> g c    and get k -> a -> Compose g f c or whatever.
14:32:27 <edwardk> the interactions you have with 'f' are kinda messy
14:32:57 <dfeuer> How's that composition relate?
14:33:29 <edwardk> my point was more that as you make these messier and messier walks they have more ways they can combine is all
14:33:43 <edwardk> you can choose to always model this as k -> a -> f (Maybe b) though, i suppose
14:33:58 <dfeuer> That's what it represents. 
14:34:11 <dfeuer> I just want to find the best ways I can to represent it.
14:34:18 <dfeuer> And manage the internal complexity.
14:34:21 <edwardk> and take the monad, but now your applicative has a problem. MaybeT isn't the same applicative as Compose f Maybe
14:34:46 <dfeuer> What's the significance of that?
14:34:58 <edwardk> so you can no longer use the applicative on your crazy complicated k -> a -> f (Maybe b)   when f is just an applicative.
14:35:06 <dfeuer> Operationally, MaybeT seems very clearly the "right" thing for the job.
14:35:06 <edwardk> so you now _need_ f to be a Monad
14:35:33 <hoppfull> Can I express 1e6 as an int? (1e6 :: Int) doesn't seem to work.
14:35:45 <edwardk> just pointing out that MaybeT has different semantics than the applicative for Compose f Maybe
14:36:30 <dfeuer> Sure. Don't you think MaybeT is the right one though?
14:36:37 <grantwu> hoppfull: 10^6?
14:36:38 <edwardk> and that by cutting off more of the cases you can get more permissive instances.
14:37:59 <hoppfull> grantwu: thanks
14:41:14 <hoppfull> This is rediculous: ((10 :: Int)^(6 :: Int)) Come on haskell!
14:41:16 <ReinH> hoppfull: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#fractional-looking-integer-literals
14:43:07 <glguy> hoppfull: Prelude> :set -XNumDecimals --- Prelude> 1e6 :: Int   --- 1000000
14:43:25 <bitemyapp> that was a nice and chunky netsplit
14:49:55 <janosp> Hi, I asked a similar question yesterday, but couldn't it solve yet. Assume I have f :: Either a b    and  g :: b -> IO (Either a b)     is there a way to combine them with >>= ?
14:50:10 <janosp> something like f >>= g
14:50:50 <janosp> hence something like that is possible:      c <- f >>= g
14:54:20 <dcoutts_> glguy: yeah, bug somewhere. What you're doing looks reasonable.
15:00:47 <lyxia> janosp: either (return . Left) f g
15:01:44 <janosp> cool, thank you !
15:12:59 <athan> Hi everyone, I know I've asked this a dozen times, but is it possible to run arbitrary IO at compile time?
15:13:11 <glguy> Template Haskell
15:13:13 <athan> I see `runIO : IO a -> Q a`, I'm just not sure how to use it
15:13:52 <athan> I really just want an `a` back, I'm not sure how i'd turn it into an Expr
15:14:00 <athan> I was thinking something like
15:14:31 <athan> $(runIO foo), but you need it to be a Q Expr, don't you?
15:14:46 <athan> let foo :: Foo
15:14:50 <athan> agh sorry
15:14:52 <glguy> lift :: Lift t => t -> Q Exp
15:15:08 <athan> ! wow okay
15:15:46 <athan> so let foo' :: Foo; foo' = $(lift =<< runIO fooIO) would work?
15:17:27 <glguy> $(do str <- runIO (readFile "hello.txt"); [| str |])
15:17:34 <glguy> or that
15:18:08 <glguy> lift is used in the "oxford bracket" syntax
15:20:22 <athan> thanks glguy :)
15:24:51 <athan> Do you happen to know if Lift is derivable glguy?
15:24:59 <glguy> I do!
15:25:02 <athan> There's no instance for ByteString :\
15:25:06 <athan> :x
15:25:44 <glguy> If you have a bytestring you can turn it into a String and use stringE on that
15:25:56 <MarcelineVQ> Are you trying to include a file blob on your source? There's packages for that iirc
15:26:00 <glguy> stringE :: String -> ExpQ
15:26:25 <athan> MarcelineVQ: Close! Generating a public/secret keypair
15:26:42 <athan> at compile time, as poor-man's cert
15:26:59 <ertesx> athan: why don't you just load it from a file?
15:26:59 <athan> glguy: Hmm, right on. Thank you
15:27:11 <glguy> athan: Do remember that you're generating Haskell syntax, not normal Haskell values
15:27:22 <athan> ertesx: Because then this time I can just generate it every time I compile haha
15:27:27 <glguy> so it's not so much that you're using String as your using string literal syntax
15:27:29 <athan> yeah :\
15:27:32 <glguy> or list of word8 syntax, etc
15:27:38 <ertes> athan: you could generate it every time you run, if necessary
15:27:56 <ertes> athan: compiling it into the executable sounds dangerous, if this is at all security-related
15:28:08 <athan> ertes: Then anyone can clone my source code and use an altered version!
15:28:19 <ertes> athan: are you trying to implement DRM?
15:28:25 <athan> not really drm
15:28:29 <athan> just a way to distinguish me
15:28:32 <athan> like a cert
15:28:32 <ertes> sounds like DRM =)
15:28:48 <athan> :x
15:29:03 <ertes> athan: i don't mind, it's just that DRM doesn't work
15:29:15 <athan> yeah haha
15:29:17 <athan> idk
15:29:23 <athan> if I can pull this off it might
15:29:45 <ertes> might just as well use a file and some symmetric encryption with a hardcoded key
15:29:58 <athan> this will just ensure messages are coming from a specific build
15:30:12 <ertes> it won't really ensure that =)
15:30:38 <MarcelineVQ> athan: would a crc check do the same thing
15:30:59 <MarcelineVQ> or is it md5?
15:31:08 <MarcelineVQ> I don't know much about that stuff
15:31:52 <athan> md4 actually :v
15:33:16 <grantwu> What are you trying to do exactly?
15:33:47 <glguy> Yeah, justify yourself!
15:34:04 <ertes> athan: what i'm saying is: don't bother overengineering this, because it won't be enforcing anything anyway…  people have invested millions of whatever currency trying and failing to do that
15:34:42 <grantwu> It doesn't necessarily sound like DRM to me
15:34:43 <ertes> and if you want to rely on this, you should be aware of it
15:35:23 <ertes> athan: if however you just want to distinguish between deployments, all you need to do is to generate a key at run-time and put it into a file
15:36:35 <grantwu> I mean how do you verify that it's the right key though
15:37:54 <nshepperd1> Or even just generate a number rather than a key
15:38:52 <yulax> ok
15:38:56 <yulax> so i have a query
15:39:01 <yulax> i'm using the lyah book
15:39:24 <yulax> i define a list of nouns, let nouns = ["sailor","computer","rabbit"]
15:39:35 <yulax> then a list of adjectives
15:39:47 <yulax> and then,  [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
15:40:25 <yulax> i understand that since we are combining the new values adjective and noun with a string, the compiler assumes they are strings too
15:40:43 <yulax> we get ["sweary sailor","sweary computer","sweary rabbit","grouchy sailor","grouchy computer","grouchy rabbit","dimwitted sailor","dimwitted computer","dimwitted rabbit"]
15:41:22 <ReinH> The SHA of the git commit being deployed would be better than this
15:41:34 <yulax> but now, why does it know to combine *one* part of the list "adjectives" and "nouns", as opposed to the whole list? 
15:41:49 <geekosaur> yulax, because that's how list comprehensions work
15:42:02 <jle`> that's what the syntax does
15:42:04 <jonored> yulax: The <- in list comprehensions is essentially "drawn from"
15:42:18 <jle`> that's like saying "foo = 10" -- how does it know to define foo as 10
15:42:29 <jle`> well...that's just, literally what that construct does >_>
15:42:38 <yulax> so we are assuming by using <-, that "adejective" is one element of "adjectives"?
15:42:42 <yulax> sorry
15:42:51 <jle`> we don't have to assume.  that's how it's defined :)
15:42:53 <yulax> this is literally my first time using haskell
15:42:55 <yulax> right ok
15:42:56 <ReinH> That's what <- means
15:42:57 <yulax> thanks
15:43:00 <yulax> no i know
15:43:07 <grantwu> athan: I'm not sure this is something you want to solve at the level of your haskell program
15:43:21 <yulax> but it's just a strange way of doing it compared to stuff i've seen before...
15:43:23 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
15:43:27 <ReinH> You can't trust compilers anyway
15:43:29 <yulax> but yea, thanks for everything!
15:43:32 <ReinH> It is known
15:43:49 <yulax> ReinH: you can if the compiler is free software and has regular public audits...
15:43:53 <jle`> yulax: np!  i suggest letting to of expectations from things you've seen before if you want to continue to learn haskell without headaches :)
15:44:02 <ReinH> No, you can't.
15:44:02 <yulax> nono
15:44:04 <yulax> i know
15:44:19 <grantwu> athan: If you want to authenticate the identity of a remote service, best to wrap things in TLS + certs or something
15:44:20 <yulax> ReinH: then you can't trust anyone then... what do you trust?
15:44:32 <ReinH> No one.
15:44:33 <grantwu> Or SSH certs
15:44:52 <jle`> yulax: fwiw, expectations based on things you've seen before are the most common cause of frustration and confusino when learning haskell
15:45:01 <ReinH> Also: don't invent your own crypto
15:45:48 <ReinH> Anyone who thinks they can invent their own crypto should on no account be allowed to do so.
15:45:53 <ertes> i think it's more useful to know what is common to things one knows and what is different
15:46:16 <jle`> yulax: but, actually, in this case, the list comprehension syntax is very similar to how python does things, if you have any python experience
15:46:28 <EvanR> by induction, crypto should not exist
15:46:30 <jle`> ReinH: only people who know why they shouldn't invent their own crypto should be allowed to do so
15:46:41 <ertes> it's not like your prior programming experience is basically useless when you learn haskell =)
15:47:03 <yulax> jle`: i use python quite a lot but never had to use list comprehension
15:47:28 <ertes> yulax: you don't *have to* use them…  in python you usually *want to* use them =)
15:47:31 <ReinH> And to how math does things: { (a,b) | a \elem A, b \elem B }
15:47:33 <jle`> hm, you never *have* to use list comprehehsnions in python, but it does make things a lot simpler :)
15:48:01 <ertes> yulax: in haskell not as much as in python though, because very often using the underlying functions is clearer and more convenient
15:48:05 <EvanR> ew, can we have a proper predicate instead of elem ;)
15:48:25 <yulax> ertes: my language is not entirely literal. perhaps  i mean i never came across them, and needed to use them in a program of mine.
15:48:30 <ReinH> elem is a proper predicate.
15:48:57 * EvanR takes off type theory goggles and is blinded by the horror
15:49:19 <shachaf> Python [x + y for x in xs for y in ys if x > y] can always become a = []; for x in xs: for y in ys: if x > y: a.append(x + y)
15:50:25 <ertes> i think the first haskell code i ever saw looked like this, and it blew me away:
15:50:35 <ertes> > take 10 [ x^2 | x <- [1..], even x ]
15:50:37 <lambdabot>  [4,16,36,64,100,144,196,256,324,400]
15:50:48 <ertes> from today's perspective it's rather boring =)
15:51:20 * jonored saw a oneline list of primes pretty early on..
15:51:22 <jle`> one must learn to find wonder in the world
15:51:28 <jle`> in the simple things
15:51:36 <EvanR> miracles all around us
15:51:59 <jle`> i'm still impressed by forever m = m >> forever m
15:52:08 <EvanR> and i dont wanna talk to a !@#$ computer scientist
15:53:11 <ertes> i love those mini-examples that are designed to sell haskell
15:53:14 <MarcelineVQ> monads, how do they work?
15:53:16 <ReinH> jle`: I'm still impressed by the type of forever.
15:53:18 <ertes> the super-short prime sieve that isn't a prime sieve
15:53:24 <ertes> the super-short qsort that isn't qsort
15:53:33 <jle`> i hope you're being sarcastic
15:53:39 <ReinH> I am not.
15:53:45 <jle`> oh not talking to you
15:53:49 <glguy> burn
15:53:54 <jle`> s/to/about
15:54:07 <ReinH> Ok fine I am
15:54:07 <jle`> those cute code golf examples tend to sell haskell as a code golfy language
15:54:29 <ReinH> And they're, you know, lies.
15:54:41 <jle`> but succinctness to the point of semi-obfuscation isn't the reason why i still use haskell
15:54:55 <jle`> but it's hard to show type safety and maintainability in a little soundbyte
15:54:58 <jle`> and correctness
15:55:22 <ertes> the problem is: you can't really show haskell's utility in two lines of golf code
15:55:34 <ReinH> Especially when that code is a lie.
15:55:36 <jle`> yea :/
15:55:45 <jle`>  :\
16:05:42 <yulax> ReinH: how is the code a lie. it is compiled with tools that also have all their source code available. the code for glasgow haskell compiler is available. if the code is a lie, then the whole world is a lie
16:06:15 <ReinH> The code in question doesn't do what it claims to do.
16:06:23 <hpc> yulax: the lie is that how they do it isn't how they say they how they do it
16:06:43 <jle`> yulax: for example of a code that is a lie:
16:06:49 <jle`> sort (x:xs) = x:xs
16:06:52 <jle`> sort [] = [1,2,3]
16:06:52 <hpc> for instance the golfed "quicksort" has performance closer to bubblesort
16:06:56 <jle`> that definitely doesn't sort anything
16:07:30 <jle`> @let myVeryGoodSorter (x:xs) = x:xs; myVeryGoodSorter [] = [1,2,3]
16:07:32 <lambdabot>  Defined.
16:07:37 <jle`> > myVeryGoodSorter [6,9,10,3]
16:07:40 <hpc> the algorithm looks quicksorty at a high level but it operates on singly linked lists in very suboptimal ways
16:07:40 <lambdabot>  [6,9,10,3]
16:08:12 <hpc> quicksort assumes an array-like container and modifying the list by swapping elements in place
16:09:22 <jonored> How bad is this one for that sort of lying?
16:09:41 <jonored> > let primes = 2:[a|a<-[3..], all ((0/=).(a `mod`)) $ takeWhile ((<a) . (^2)) primes ] in primes
16:09:43 <lambdabot>  [2,3,4,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83,...
16:10:06 <jonored> ...apart from the fact that I failed somewhere in there...
16:11:59 <Hijiri> I think that's basically the fake golf sieve
16:12:10 <Hijiri> except with the square optimization
16:12:29 <ertes> jonored: if you'd claim that it's a *sieve*, you'd be lying, but you didn't
16:13:10 <ertes> this is what a list-based prime sieve looks like: https://github.com/esoeylemez/snippets/blob/master/PurePrimeSieve.hs
16:13:36 <ixor> what do haskellers use for making search available on thier sites?
16:13:45 <ixor> using solr here and not liking it
16:15:40 <johnw> ixor: I defer the searching to Google's spider
16:15:58 <johnw> but if you have a custom data set, I don't know
16:23:37 * hackagebot hmatrix-repa 0.1.2.2 - Adaptors for interoperability between hmatrix and repa  https://hackage.haskell.org/package/hmatrix-repa-0.1.2.2 (VivianMcPhail)
16:23:39 * hackagebot plot 0.2.3.6 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  https://hackage.haskell.org/package/plot-0.2.3.6 (VivianMcPhail)
16:28:27 <osa1> mmmm being able to initialize function record fields like { field x y z  = ... } would be nice
16:30:09 <ReinH> Not sure what that would do
16:30:23 <osa1> { field = \x y z -> ... }
16:45:30 <soLucien> hello guys ! I was reading something about monads and came into the expression
16:45:34 <soLucien> "monadic context"
16:45:44 <soLucien> and 2 examples were given
16:45:49 <soLucien> Either and Maybe
16:45:53 <soLucien> are there others as well ?
16:47:21 <dibblego> @src unless
16:47:21 <lambdabot> unless p s = if p then return () else s
16:47:45 <soLucien> unless = if not 
16:47:46 <soLucien> ?
16:49:21 <dibblego> soLucien: sorry, that was not intended to reply to you. Yes there are hundreds of other exmples of monads. Identity, [], ((->) t), State s, Writer w, Cont r, and many more
16:50:04 <soLucien> i am talking about something called a 'monadic context'
16:50:13 <soLucien> something that is used to create a monad
16:50:17 <soLucien> as far as i can read
16:50:51 <dibblego> that term is not well-defined, but you have given examples of values that meet the definition of monad
16:51:09 <soLucien> so Either and Maybe are monads ?
16:51:20 <soLucien> i thaught they were data definitions
16:51:42 <dibblego> (Either e) and Maybe are examples of values that meet the definition for monad
16:52:57 <dibblego> can you take those values, call them (f), and write pair of functions, ((a -> f b) -> f a -> f b) and (a -> f a) such that those functions satisfy properties of identiy and composition? Yes, you can, and so they are examples of monads
16:57:41 <soLucien> you lost me at the ((a -> f b) -> f a -> f b) and (a -> f a) part
16:57:48 <soLucien> i'm still trying to get this stuff
16:59:52 <dibblego> they are type signatures
17:00:02 <soLucien> i know , i understand what they are
17:00:07 <soLucien> but i don't get the rules
17:29:27 <Koterpillar> can someone please weigh in on https://github.com/hspec/hspec-wai/pull/40 ? The maintainer said (see related pull request) that they don't have time to review
17:31:15 <caTh_> Does anyone on know the internals of the http-client-tls and associated libraries?  I need to figure out how to make an Https connection over a custom Connection type.
18:23:40 * hackagebot dib 0.5.0 - A simple, forward build system.  https://hackage.haskell.org/package/dib-0.5.0 (blajzer)
18:23:42 * hackagebot hw-bits 0.1.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.1.0.1 (haskellworks)
18:46:25 <Zemyla> Should the (!?) operator in vector be more properly written as (‽)?
19:07:57 <nathyong> Are there any best practices for deciding what symbols to use when creating your own APIs?
19:08:17 <nathyong> Trying to avoid symbol spam, but keyword spam is almost as bad..
19:12:17 <benzrf> Zemyla: lol
19:15:15 <ski> Zemyla : no, `⁉'
19:16:45 <benzrf> ah unicode
19:17:02 <benzrf> pick a random array of 48x48 pixels and they got u covered
19:17:03 <benzrf> C:
19:23:29 <hoppfull> If readFile doesn't succeed does it return an IOError or something? Can I pattern match against the result to check if it succeeded or failed?
19:23:42 * hackagebot pusher-http-haskell 1.1.0.3 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.1.0.3 (willsewell)
19:25:06 <benzrf> hoppfull: readFile is lazy IO anyway, u probably shouldnt use it for real world stuff
19:25:20 <benzrf> note: i dont know jack shit about real world uses of haskell, im probably super wrong :>
19:25:28 <hoppfull> benzrf: Interesting. Thanks
19:27:18 <geekosaur> hoppfull, if it fails it just stops producing characters; there is no way to catch the error or eof or whatever
19:27:32 <geekosaur> if you need to know, don't use lazy I/O
19:28:17 <hoppfull> geekosaur: When I try to read a file that doesn't exist I get an exception.
19:28:27 <geekosaur> yes, that is from the open, not the read
19:28:42 <hoppfull> geekosaur: Soooo... What should I use? Eager(?) IO?
19:28:53 <geekosaur> once it has a Handle, it moves it "into the background" and you can no longer do anything with it directly and it can't signal errors any more
19:29:22 <hoppfull> All I know is I have a text file and I need to get its content into a string.
19:29:47 <geekosaur> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/System-IO.html#g:17
19:30:34 <geekosaur> (these functions haven't changed in a while, so it's still correct even if you don't have 8.0.1. the last change was encoding support back in ghc 6.12)
19:39:12 <zzing> I was reading somewhere last night that no haskell parser gets the layout exactly as specified in the language report. If that were true, is there anything that describes how some of compilers implement it?
19:48:25 <geekosaur> zzing, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#haskell-standards-vs-glasgow-haskell-language-non-compliance covers ghc's divergence from the standard
19:49:22 <geekosaur> I think what you read may have been dated; Haskell98's version of layout turned out to have a corner case which was ambiguous, so different parsers could recognize a certain (uncommon) construct in different ways while still being compliant. Haskell2010 corrected it.
19:58:39 <geekosaur> that said, the definition of layout talks about close braces and semicolons being inserted at syntactically correct spots, with minimal guidance about what spots to use if more than one could be found (iirc this is where H'98 got its ambiguity from, as it just had the "syntactically correct" part). compilers, especially those supporting language extensions, may disagree sometimes
20:09:04 <joe9> need some advice, please? I want to start an async process. But, if the async process dies/finishes, I want the main process to exit too. withAsync waits for the main process to exit.
20:09:55 <joe9> it is like using bracket and withAsync together
20:10:05 <lispy> joe9: if the async process finishes cleanly you could detect it by having that thread write to a chan that the main thread is waiting on
20:11:07 <lispy> if you wrap the async thread in a catch all, and do the clean up then you can even handle some unclean exits
20:11:24 <lispy> But I'm not sure if you can make a completely bullet proof solution
20:12:50 <zzing> geekosaur, I will look at the 2010 report then, thank you
20:13:56 <grantwu> So I know there is a package that makes Haskell code point-free
20:14:01 <grantwu> Is there an un-point-free package
20:14:15 <ddere> pointful?
20:14:32 <grantwu> ah
20:18:51 <joe9> lispy: Ok, Thanks. I was trying to avoid the writing to the channel.
20:22:11 <glguy> > ?unpl (.).(.)
20:22:13 <lambdabot>  mueval-core: internal error: PAP object entered!
20:22:13 <lambdabot>      (GHC version 8.0.1 for x86_64_unknown_linux)
20:22:13 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
20:22:17 <glguy> > ?unpl (.).(.)
20:22:19 <lambdabot>  mueval-core: internal error: PAP object entered!
20:22:19 <lambdabot>      (GHC version 8.0.1 for x86_64_unknown_linux)
20:22:19 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
20:22:21 <glguy> Oh
20:22:23 <glguy> ?unpl (.).(.)
20:22:23 <lambdabot> (\ x g x0 x1 -> x (g x0 x1))
20:22:36 <glguy> Also, GHC probably shouldn't be panicing like that
20:23:11 <ski> > ?_
20:23:13 <lambdabot>  mueval-core: internal error: PAP object entered!
20:23:13 <lambdabot>      (GHC version 8.0.1 for x86_64_unknown_linux)
20:23:13 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
20:23:43 * hackagebot snap 1.0.0.1 - Top-level package for the Snap Web Framework  https://hackage.haskell.org/package/snap-1.0.0.1 (DougBeardsley)
20:26:05 <geekosaur> cute bug
20:26:33 <grantwu> :t foldMap
20:26:34 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
20:29:44 <grantwu> Why is foldMap named the way it is?  It doesn't really look that much like a fold...
20:30:14 <grantwu> I guess fold is a special case of reduce
20:31:26 <Maxdamantus>  src foldMap
20:31:29 <Maxdamantus> eh
20:31:33 <Maxdamantus> src foldMap
20:31:39 <Maxdamantus> @src foldMap
20:31:39 <lambdabot> Source not found. I feel much better now.
20:31:45 <Maxdamantus> Damn it.
20:31:56 <geekosaur> wouldn't expect it to be there, it's a poorly curated text database not the actual definitions
20:32:10 <Maxdamantus> I'm pretty sure it'll be defined in terms of foldl/foldr.
20:32:27 <geekosaur> actually isn't it the minimal definition of the Foldable typeclass?
20:32:30 <grantwu> Yeah, it is
20:32:36 <grantwu> Never mind
20:32:41 <nshepperd_> foldMap is a typeclass function anyway so it doesn't have an actual definition anyway
20:33:02 <grantwu> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Foldable.html#foldMap
20:35:57 <nshepperd_> the default definition in terms of foldr i guess
20:38:00 <ski> (apropos, <http://comonad.com/reader/2015/free-monoids-in-haskell/>)
20:48:45 <joe9> lispy http://bpaste.net/show/a5bec3a7476b I am using the bracket and withException of safe-exceptions
20:52:16 <lispy> joe9: there may be better ways. It's just the first thing I thought of.
20:52:39 <joe9> lispy, sure, just want to get your opinion. Do you see any issues with it?
20:54:23 <lispy> joe9: nothing jumps out at me, but I've been wrong about such things so I'm afraid to tell you it's good :)
20:54:33 <joe9> lispy, ok, Thanks.
21:01:27 <ania122> can one tell me, why following prorgamm gives me error to compile?
21:01:28 <ania122> N = a `div` length xs     where        a = 10       xs = [1,2,3,4,5]
21:02:40 <benzrf> ania122: variable names have to start with a lowercase letter
21:03:34 <ania122> benzrf: where do you see capital letter?
21:03:41 <benzrf> N
21:04:23 <ania122> still it does not compails 
21:04:51 <EvanR> let N = 0 in N
21:04:54 <EvanR> > let N = 0 in N
21:04:57 <lambdabot>  error: Not in scope: data constructor ‘N’
21:05:12 <EvanR> (weird)
21:05:15 <benzrf> ania122: what error do you get?
21:05:19 <benzrf> EvanR: how's that weird
21:05:22 <ania122> n = a `div` length xs     where        a = 10       xs = [1,2,3,4,5]
21:05:29 <EvanR> why can i "assign" 0 to N
21:05:32 <benzrf> ania122: but what error do you get?
21:05:38 <ania122> pr1.hs:4:7: error: parse error on input ‘xs’ [1 of 1] Compiling Main             ( pr1.hs, interpreted ) Failed, modules loaded: none.
21:05:40 <benzrf> EvanR: capital letter signifies a data constructor
21:05:53 <EvanR> oh its a pattern match
21:06:07 <benzrf> ania122: can you use lpaste to show us your code? I'm having trouble telling what your indentation is like
21:06:25 <EvanR> > let !Nothing = Just 3 in ()
21:06:28 <lambdabot>  *Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern !No...
21:06:42 <ania122> http://pastebin.com/DQpgj9Bk
21:07:22 <benzrf> ania122: thanks!
21:07:31 <benzrf> fyi, lpaste.net is much nicer than pastebin.com
21:07:36 <benzrf> it doesn't have ads, among other things
21:07:51 <ania122> aha 
21:07:52 <ania122> ok
21:08:03 <benzrf> ah, i see
21:08:13 <benzrf> ania122: 'a' and 'xs' have to be indented the same amount
21:08:16 <benzrf> so the x should line up with the a
21:09:15 <ongy> pastebin has ads now? *shudder*
21:09:45 <benzrf> it has for ages
21:10:06 <nshepperd_> they sold out, man
21:11:23 <ania122> benzrf: could you paste please code\
21:11:27 <ania122> ?
21:11:38 <geekosaur> ads, and whininess if you block them
21:13:03 <ongy> ania122: it's literally one ' ' in line 4 to align the x with the a, not the s
21:13:37 <benzrf> ania122: yeah, hold on
21:14:03 <benzrf> sorry, im flossing so i cant rly work at the same time
21:14:42 * Clint squints.
21:16:47 <ania122> ongy: sorry, not clear
21:17:40 <d4rkd3v1l> hey anyone know how to crack rar password
21:17:57 <ongy> http://lpaste.net/210087 ania122 
21:18:29 <ongy> d4rkd3v1l: this is neither on topic here, nor can we generally condone discussion of that
21:19:58 <ania122> ongy: I confuse now, your and my code seems to be identicall, but your code compiles, mine does not ... I confuse now
21:20:07 <d4rkd3v1l> ok , sry
21:20:56 <ongy> ania122: haskell is whitespace aware, so you will have to align your lines in the where block. If you are not using a monospaced font, this may be hard to see
21:22:00 <ania122> ongy: what text editor can you recomend me to highlight it
21:22:05 <ania122> ?
21:25:09 <benzrf> ania122: i like vim, myself
21:25:24 <ongy> I'm not aware of any editor that explicitly highlights alignment. I'm saying monospaced font, since variable width usually have rather tiny spaces, which makes it really awkward to see
21:30:44 <grantwu> Is there a name for a coding style where functions always have all of their arguments listed
21:31:55 <glguy> verbose?
21:32:26 <grantwu> c.c
21:32:32 <grantwu> I find it helpful
21:33:21 <glguy> That's fine, you can write code any way you like
21:33:26 <ski> grantwu : "pointful", perhaps ?
21:33:30 <nshepperd1> Pointy :)
21:34:06 <grantwu> right, but I'm collaborating with someone on a project and he tends to maximum brevity
21:34:10 <ertes> id x1 x2 x3 x4 x5 x6 x7 x8 …
21:34:29 <grantwu> ?
21:34:42 <ski> grantwu : or "eta-expanded" or "extensionally defined", or something ..
21:34:59 * ski nods to ertes
21:35:16 <benzrf> id :: (a -> b -> c -> d -> e -> f) -> a -> b -> c -> d -> e -> f
21:35:22 <ski> "all of their arguments" isn't really a precise term
21:35:35 <ski> > id id id id id id id id ()
21:35:37 <lambdabot>  ()
21:35:46 <ski> `id' can take as many arguments as you like
21:35:46 <grantwu> Agreed but like
21:36:33 <grantwu> Isn't "fully applied" a thing though
21:37:17 <ertes> grantwu: there is no point at which 'id' is "fully applied"
21:37:31 <ski> > foldr (\x f s -> f (concat ["(",show x," * ",s,")"])) (\s -> s) [2,3,5,7] "1"  -- `foldr' taking *four* arguments, acting like `foldl'
21:37:34 <lambdabot>  "(7 * (5 * (3 * (2 * 1))))"
21:37:44 <ski> @type foldr
21:37:46 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:37:59 <grantwu> ertes: GHC mailing list seems to have some concept of "fully applied"
21:38:03 <ski> in this case, `b = String -> String'
21:38:04 <ertes> grantwu: "listing all arguments" or "fully applied" only make sense for certain monomorphic types
21:39:13 <benzrf> grantwu: im pretty sure thats an implementation detail that gets decided automatically by ghc depending on how the function gets used
21:39:55 <benzrf> grantwu: like, if you write "id x = x", but then only use "id" in a place where you're doing "id f x", ghc will compile it to a 2-arg function, and then 2 args is full application
21:39:58 <benzrf> (i think)
21:40:16 <dolio> No.
21:41:01 <benzrf> oh
21:41:04 <benzrf> oops
21:41:05 <dolio> `id x = x` compiles to a one argument function. But it's so short that it will probably inline everywhere.
21:41:17 <ertes> grantwu: on the other end of the spectrum you couldn't even define 'id' by listing more than one argument
21:41:39 <ertes> you couldn't "list all arguments" even if you wanted to…  you couldn't even list two, because then you would write ($) instead of 'id'
21:41:53 <glguy> grantwu: You'd probably get more out of showing specific code that you like or don't rather than guessing names of things
21:42:09 <grantwu> I'm not quite understanding how id can take more than one argument
21:42:12 <benzrf> here, this is what i was thinking of dolio https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode#Example3:Unsaturatedapplicationstoknownfunctions
21:42:37 <grantwu> glguy: getLiveAt i l = fromMaybe S.empty (M.lookup i (lines l)) vs getLiveAt i = fromMaybe S.empty . M.lookup i . lines
21:42:48 <grantwu> I personally prefer the former...
21:42:55 <glguy> id f x === (id f) x === f x
21:42:59 <ertes> grantwu: it's a matter of instantiation:  if you write (id x y), then haskell infers that (id x) must be a function, and because (id x = x), x must be a function
21:43:58 <grantwu> My informal reading of id f x is that id f reduces to f
21:44:05 <ertes> (id :: a -> a), (x :: a), but a = m -> n, so you instantiate id's type as:  (id :: (m -> n) -> m -> n)
21:44:14 <dolio> benzrf: There are other factors to consider. Like, that example might compile to straight forward C--, but inlining is based on syntactic saturation, I think.
21:44:15 <grantwu> ...I guess
21:44:19 <grantwu> quit
21:44:21 <grantwu> oops
21:44:47 <dolio> So known_fun_2 probably won't be inlined into known_undersaturated_app.
21:47:03 <ski> @pl id x = x
21:47:03 <lambdabot> id = id
21:47:13 <ski> (true that)
21:47:24 <ertes> @let myId = myId
21:47:26 <lambdabot>  Defined.
21:47:27 <ertes> > myId ()
21:47:32 * ski smiles
21:47:33 <lambdabot>  mueval-core: Time limit exceeded
22:04:10 <ania122> http://pastebin.com/bwz6b4X4
22:04:34 <ania122> 'Nothing' in this program is not variable, what data it is?
22:05:28 <Koterpillar> :t Nothing
22:05:30 <lambdabot> Maybe a
22:05:33 <Koterpillar> ania122: ^
22:05:45 <Koterpillar> @src Maybe
22:05:45 <lambdabot> data Maybe a = Nothing | Just a
22:05:46 <ania122> ?
22:05:50 <Koterpillar> ania122: ^
22:06:07 <ania122> not clear
22:06:26 <liste> ania2: it's a value of type Maybe a
22:06:35 <ania122> aha, thx
22:06:36 <Koterpillar> ania122: Nothing is a constructor of type Maybe. Do you know what the "data" keyword does?
22:07:10 <ania122>  Do you know what the "data" keyword does?
22:07:14 <ania122> not really
22:07:29 <ania122> can you give me a link
22:07:40 <Koterpillar> @where lyah
22:07:40 <lambdabot> http://www.learnyouahaskell.com/
22:07:44 <Koterpillar> ania122: here you are
22:07:53 <ania122> ok
22:07:55 <ania122> thx
22:08:11 <ania122> I want to avoid using Nothing
22:08:13 <ania122> and write
22:08:16 <ania122> mylast [] = []
22:08:41 <ski> then `myLast' will only work on lists whose elements are also *lists*
22:08:47 <ania122> but, program does not work ... is there whay to avoid 
22:09:02 <ania122> Nothing
22:09:03 <ski> (all elements of a given list must have the same type)
22:09:15 <ski> ania122 : another way is to use `error'
22:09:22 <ania122> ok
22:09:36 <ski>   myLast [] = error "please don't try to take the last of an empty list, it won't work"
22:10:49 <ski> (`error' takes a string, and, when evaluated/reduced, will cause the program to "crash"/abort, stop doing what it was doing, and print the string as part of an error message)
22:10:50 <ania122> ski: http://pastebin.com/cjfGwHcM
22:10:56 <ReinH> Why would you want to avoid Nothing?
22:11:10 <ReinH> Nothing is exactly what you want
22:11:33 <ski> ReinH : you forgot to give a string as argument to `error', and you also forgot to change the other definition equation, which mentions `Just'
22:11:36 <ski> er
22:11:38 <ski> ania122 ^
22:11:45 <ReinH> I don't think did
22:11:50 <ReinH> :p
22:12:05 <ski> (for some reason i got a hold of "r" rather than "a")
22:12:13 <dmj`> is it possible to configure cabal (like choose a compiler '--ghcjs'), based off an environment variable. So all calls to 'cabal configure' use those settings.
22:12:21 <ania122> ski: could you paste please?
22:12:43 <ski> ania122 : should i paste the english sentences i said above ?
22:12:53 * ski doesn't see what good that'd do
22:12:57 <ania122> no, programm please
22:13:03 <ania122> http://www.cs.nott.ac.uk/~pszgmh/book.html
22:13:06 <ski> should i repaste your program ?
22:13:19 <ania122> I followi this book, actually slides
22:13:25 <ania122> ski: yes please
22:13:29 <ski> (i'm not going to simply write the corrected program for you, but i can give suggestions, and try to explain stuff)
22:13:42 <ania122> ok
22:13:48 <ReinH> We aren't here to write your programs for you
22:14:01 <ski> (i'm also not sure what good it would do to repaste your exact program, including the non-working parts)
22:14:24 <ReinH> I still don't understand your aversion to Nothing
22:14:51 <ReinH> Nothing is better than a runtime error
22:15:13 <ania122> Reinh: I am trying to do a exercise from slide, I pointed: Show how the library function last that selects the last element of a list can be defined using the functions introduced in this lecture.
22:15:57 <geekosaur> so you indeed do not want Nothing --- you want to do what the standard last function does, which is throw an exception
22:16:29 <ania122> I want to implement last
22:16:41 <ania122> using some operations on lists
22:16:57 <geekosaur> you cannot return a "no value", there is no such value that works for every type (except the ones that actually throw exceptions)
22:17:27 <ania122> aha
22:18:25 <ski> instead of using `myLast [] = error "blahblah..."', you could also simply omit the `myLast []' case from the definition. then you'll also get an error message, in case you try to apply `last' to an empty list
22:18:53 <ski> (assuming you manage to fix the remaining stuff that needed to be fixed, i.e.)
22:19:57 <ania122> geekosaur: what you point, means I have to use last function to define mylast
22:19:59 <ania122> is not?
22:20:14 <geekosaur> no, that was not my point
22:20:36 <geekosaur> my point is there is no way you can write myLast [] = [], or anything similar in place of the []
22:20:53 <ania122> ok
22:23:46 * hackagebot snaplet-postgresql-simple 1.0.1.0 - postgresql-simple snaplet for the Snap Framework  https://hackage.haskell.org/package/snaplet-postgresql-simple-1.0.1.0 (DougBeardsley)
22:24:26 <grantwu> https://twitter.com/grantwwu/status/779189209408086016 Has anyone encountered this issue before?
22:27:45 <hoppfull> I have a philosophical question. I'm making an opengl program that relies on a text file to exist (glsl shader source). Right now if that file doesn't exist, I let my program fail. Nothing to check if it exist or anything. I just let it all crash. Less code. Easier to grok. Is this sort of "whatevs, do what you want" or is there a strong philosophical reason I shouldn't let my program fail like this?
22:28:12 <johnw> hoppfull: if you're not going to have users, do what you like
22:28:27 <Koterpillar> hoppfull: at least make sure the output says what is wrong
22:28:37 <Koterpillar> hoppfull: someone is going to package it wrong sooner or later
22:29:24 * ski . o O ( "hopplös" )
22:29:25 <hoppfull> johnw: Thanks
22:32:15 <hoppfull> Koterpillar: I noticed when I flexed my monad muscles code got a lot prettier. But it took a huge mental effort on my part. But I'm still curious about the philosophical question for the day I involve other people in what I produce. Thank you for your response!
22:32:18 <ReinH> grantwu: that looks reasonable to me, given what I know about hindent
22:32:36 <ReinH> Specifically, its heuristics
22:33:18 <ReinH> Maybe not the way you would indent it, but not a bug either.
22:34:12 <grantwu> ReinH: It's not what happens here though: http://chrisdone.com/hindent/
22:37:25 <MarcelineVQ> which template are you running?
22:37:48 <ReinH> Different version? Things changed recently with 5.0
22:38:05 <ReinH> And previously there were multiple styles as well
22:45:28 <ania122> ski: http://pastebin.com/Qgd8c7G8
22:45:37 <ania122> this looks ok for all inputs
22:45:43 <ania122> excep last []
22:46:31 <ania122> uh... no
22:46:36 <ReinH> error is a function
22:46:46 <ReinH> :t error
22:46:48 <lambdabot> [Char] -> a
22:47:02 <ReinH> You need to give it a string argument.
22:47:34 <ania122> ReinH: how?
22:48:30 <ReinH> How do you usually apply functions to values?
22:48:44 <ReinH> How do you apply last to a list?
22:49:21 <ania122> in haskell? or in lambda calculus?
22:50:02 <ReinH> You're writing Haskell, right?
22:50:08 <glguy> both, though?
22:50:27 <ReinH> Why would I be taking about lambda calculus?
22:56:45 <Lokathor> is there a builtin to give the index of the highest value in a list?
22:57:37 <Koterpillar> not likely: lists don't have to be finite, and there can be more than one highest value
22:57:56 <Koterpillar> Lokathor: > indexOfTheHighestValueInAList (repeat 5) 
22:58:09 <Lokathor> well, i know they can be infinnite :3
22:58:35 <Lokathor> but oh well, i'll build it
22:58:39 <dmj`> > fst $ head $ sortBy (compare `on` snd) $ zip [1..] [4,5,8]
22:58:41 <lambdabot>  1
22:58:49 <ania122> ReinH: http://pastebin.com/LiHiVejy
22:58:52 <dmj`> > fst $ head $ sortBy (flip compare `on` snd) $ zip [1..] [4,5,8]
22:58:53 <Lokathor> ah ha, now there's some fun
22:58:54 <lambdabot>  3
22:59:01 <ania122> could you please have a look it
22:59:20 <dmj`> Lokathor: ^
22:59:34 <Lokathor> hmm, what should i import for `on` to work
22:59:54 <ReinH> ania122: does it compile?
23:00:03 <ania122> it compiles
23:00:09 <Koterpillar> Lokathor: Data.Function
23:00:09 <ania122> it works ok with any input
23:00:11 <ania122> except
23:00:20 <Lokathor> nice
23:00:23 <Lokathor> dmj`, thanks
23:00:34 <ania122> myLast []
23:00:49 <dmj`> Lokathor: don't use head though, use safeHead or something
23:00:50 <ReinH> It works on with that input too.
23:00:58 <ReinH> ok*
23:01:11 <ReinH> It does what you told it to do.
23:01:32 <Lokathor> dmj`, yeah, though this is for a demo where the list is known to be 3 elements long always
23:01:40 <ania122> myLast [] *** Exception: No end for empty lists! CallStack (from HasCallStack):   error, called at lasttest.hs:2:13 in main:Main
23:02:02 <Koterpillar> ania122: and what do you want to happen instead?
23:02:03 <ReinH> Yes, that's what you told it to do.
23:02:04 <ania122> ReinH: I did not tell it to eturn it
23:02:17 <ReinH> To what?
23:02:20 <dmj`> Lokathor: sweet
23:02:39 <ReinH> It is doing exactly what you told it to do.
23:03:05 <ania122> it should rettunr, an empty list does not has last element
23:03:09 <ania122> this type of message
23:03:13 <ania122> :)
23:03:14 <ReinH> Return what?
23:03:21 <ania122> a text message
23:03:25 <ReinH> It can't do that
23:03:30 <ania122> ok
23:03:53 <geekosaur> it cannot return a message because a message has a fixed type that is not necessarily the type the caller requested
23:08:40 <ReinH> That's something you can do with Either
23:09:05 <ReinH> Or if you just want to show that there is no result, Maybe
23:09:25 <ReinH> But that function would have a different type
23:20:29 <johnw> any thoughts on starting a proof of: f <$> x <*> x = fmap (\v -> f v v) x?
23:21:23 <ski> it's false ?
23:21:34 <ski> (in general)
23:21:51 <johnw> ok, then I'm not insane
23:22:37 <ski> (just consider `State s', with `x = modify g' for any non-idempotent `g :: s -> s')
23:22:45 <johnw> of course, thanks ski
23:23:16 <ski> (or, if you prefer, `[]', with `x = [0,1]', say)
23:23:25 <johnw> yeah, it's obvious now, must be late
23:23:48 * hackagebot Gifcurry 2.0.0.2 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-2.0.0.2 (lettier)
23:23:50 * hackagebot text-zipper 0.8 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.8 (JonathanDaugherty)
23:26:20 <Lokathor> dmj`, http://lpaste.net/210093 C#; http://lpaste.net/210137 quick haskell approximation
23:27:23 <e19293001> what haskell library can you recommend for gui?
23:27:44 <dmj`> e19293001: what kind of gui
23:28:00 <dmj`> Lokathor: I black out when I read imperative code
23:28:06 <Lokathor> hahahah
23:28:16 <dmj`> when I come to, can't remember anything
23:28:37 <Lokathor> a friend is in a CompSci 101 type class, C# is the language used. Though next semester is Java for whatever reason
23:28:49 <Lokathor> not sure why you'd use 1 semester of C# and then Java after that instead of all Java
23:29:05 <Lokathor> i guess that's why i don't get paid the professor bucks
23:29:08 <e19293001> dmj`: sorry for being broad. i mean gui for desktop applications
23:29:28 <Lokathor> e19293001, do you want to be able to have your program work on windows?
23:29:28 <MarcelineVQ> I'd rather stick with C#, not that I'm some expert on that subejct though
23:29:41 * Lokathor gasps!
23:29:47 <Lokathor> my favorite vampire!
23:29:53 <MarcelineVQ> :<
23:30:00 <e19293001> Lokathor: probably i can make it work in windows and linux
23:30:29 <Lokathor> e19293001, "haskell with a GUI" and "windows" are... not too friendly of concepts, last I checked (about a year ago)
23:30:35 <dmj`> Lokathor: probably some kind of conspiracy where large enterprises fund schools to change curriculum, to get jobs in .net shops, to boost enterprise sales
23:31:04 <e19293001> Lokathor: so, even only for haskell, what can you recommend?
23:31:10 <Lokathor> though since windows 10 can now run linux libs through that interpreter thing... maybe you can just make a linux version only and tell people to run through the linux virtual layer
23:31:45 <dmj`> e19293001: ghcjs can do that, http://scribe-salutes-82753.bitballoon.com/
23:32:19 <dmj`> e19293001: you can probably deliver your app through atom or whatever that lightweight browser thing is, unibrowser, a single app as a browser
23:32:44 <Lokathor> yeah that's handy if you can get it working like that
