00:07:24 <wz1000> Is there anything in base like the applicative functor newtype Count a = Count Int, which behaves like [a] but throws away all information other than the length of the list?
00:07:41 * hackagebot bond 0.6.0.0 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.6.0.0 (chwarr)
00:07:41 * hackagebot mios 1.4.0 - A Minisat-based SAT solver in Haskell  https://hackage.haskell.org/package/mios-1.4.0 (shnarazk)
00:09:01 <shachaf> wz1000: Const (Product Int)?
00:09:44 <wz1000> shachaf: Ah, but the monoid instance does not match
00:11:23 <shachaf> Why not?
00:11:51 <wz1000> shachaf: length (xs <> ys) = length xs + length ys
00:11:59 <shachaf> ?
00:12:16 <shachaf> length (xs <*> ys) = length xs * length ys
00:12:32 <wz1000> shachaf: (<>) is mappend
00:12:44 <shachaf> Yes, but you wanted an applicative functor.
00:12:52 <wz1000> shachaf: I want both.
00:12:57 <shachaf> Both what?
00:13:09 <wz1000> [12:39] <wz1000> shachaf: Ah, but the monoid instance does not match
00:13:29 <shachaf> Ah, the monoid instance for Const (Product Int) a
00:13:46 <wz1000> shachaf: Yeah
00:14:00 <shachaf> OK, then you should define your own type.
00:23:56 <lpaste> manyone revised “hackerrank problem”: “hackerrank problem” at http://lpaste.net/192564
00:24:59 <manyone> i got it to work - you guys were right - i simply used fromIntegral on all Int's i was using as Double. thanks
00:32:35 * hackagebot servant-swagger 1.1.2 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.1.2 (phadej)
00:32:37 * hackagebot servant-purescript 0.3.1.5 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.3.1.5 (eskimo)
00:46:25 <tsahyt> Is there a way to get O(1) slicing with Text when using take and drop?
00:48:21 <opqdonut> take and drop utilise fusion
00:48:29 <mauke> unlikely, given that Text uses a variable-width encoding internally
00:48:56 <opqdonut> so if you consume the slice using a fold, it'll be efficient in terms of allocations and time
00:49:09 <opqdonut> but if you want to hang on to the slice, it will allocate
00:55:05 <tsahyt> opqdonut: I consume the slice using a zip, and then run a takeWhile on that
00:55:11 <tsahyt> two slices actually
00:56:10 <opqdonut> tsahyt: then you won't be paying that much extra for the slice, since takeWhile will iterate through the contents anyway
00:56:34 <tsahyt> opqdonut: so I thought, but profiling shows that almost all the time is spent in creating those slices
00:56:46 <tsahyt> and it's much slower than the String/Zipper based solution
00:56:49 <opqdonut> interesting
00:56:51 <tsahyt> on the plus side it uses constant memory
00:57:59 <opqdonut> it might be that Text fusion and the normal [] fusion aren't gettign along
00:58:40 <opqdonut> no, Data.Text.zip at least tries to stream
00:59:04 <opqdonut> I guess you'll need to look at the core to find out what's happening
00:59:40 <tsahyt> http://lpaste.net/4632388971974885376
00:59:58 <tsahyt> here's the code. it's really a rewrite of a String/Zipper based solution that made my memory explode on large inputs
01:00:04 <tsahyt> hence all the boilerplate
01:03:19 <DangerousDav3> Hello, Why can't I pattern match over a type and only over type constructor? means data Type = Constructor | Constructor2 and can't pattern match over Constructor and Constructor2 and if I replace them to Constructor c | Constructor2 c2 it work
01:03:28 <DangerousDav3> s
01:04:53 <opqdonut> tsahyt: generic suggestions for optimizing that: 1) get rid of the redundant zipper code, it might be getting in the way of the optimizer 2) consider tracking the length better, T.length is O(n) after all
01:05:28 <pavonia> DangerousDav3: That is supposed to work
01:05:39 <tsahyt> oh, it is indeed. I thought it was O(1). that might be the actual problem then
01:05:45 <DangerousDav3> if I create number = Double | Int
01:05:51 <DangerousDav3> can I pattern match over Double and Int?
01:05:54 <opqdonut> tsahyt: also, since your code is indexing-heavy, you might want to switch to e.g. UArray Char
01:06:05 <opqdonut> tsahyt: or Data.Sequence
01:06:13 <opqdonut> tsahyt: (note that Text indexing is O(n))
01:06:37 <pavonia> DangerousDav3: Yes, but note that Double and Int are value constructors then
01:06:53 <DangerousDav3> what do you mean
01:06:59 <tsahyt> huh. I did not realize that. I must have mixed up text and vector complexities
01:07:03 <opqdonut> tsahyt: or, if you're fine with Word8 instead of unicode, Data.ByteString has O(1) indexing
01:07:11 <tsahyt> I always thought text was going to behave roughly like vector in those things
01:07:17 <pavonia> DangerousDav3: They aren't types
01:07:28 <tsahyt> opqdonut: does bytestring do fusion?
01:07:29 <fr33domlover> DangerousDav3, you can use (Ctor {})
01:07:33 <glguy> text uses a variable length encoding
01:07:37 <fr33domlover> may help in some cases
01:08:21 <DangerousDav3> pavonia: I don't use them on the function signature
01:08:26 <DangerousDav3> pavonia: Only for pattern matching
01:08:33 <opqdonut> tsahyt: it does, I think
01:08:49 <opqdonut> tsahyt: yeah, it does
01:08:59 <pavonia> DangerousDav3: That should work then
01:09:06 <tsahyt> ok I'll use bytestring then I think
01:09:25 <glguy> you'll pattern match them was
01:09:38 <glguy> as literally Int and Double
01:09:50 <glguy> not with numbers
01:16:16 <kadoban> DangerousDav3: What are you actually trying to do? A lot of this seems to be what I can only assume in really missing the point.
01:22:19 <DangerousDav3> pavonia: If I want to define LabelType = Int | Double
01:22:29 <DangerousDav3> And I get [LabelType]
01:22:36 <DangerousDav3> how can I set sum over it?
01:22:41 <DangerousDav3> should I create a new one?
01:24:30 <zipper> Hey dudes say you know Haskell but everyone says you should write your new thing in Erlang? Will you drop everything and learn Erlang?
01:24:44 <zipper> *dudes and ladies
01:24:47 <pavonia> DangerousDav3: You have nothing to sum over, Int and Double aren't ints and doublehere but just new constructors
01:26:06 <pavonia> DangerousDav3: If you just want to distinguish between int and doubles, you could use "type LabelType = Either Int Double"
01:27:29 <DangerousDav3> LabelType = Either Int Double?
01:28:03 <pavonia> Well, what are you trying to do?
01:30:07 <Taneb> zipper, there's rarely any harm in learning a new language, if you have the time, but if you're working on this alone and believe you can do it, and do it well, in Haskell, go for it
01:31:33 <zipper> Taneb: Do you know why erlang would be better than haskell really?
01:31:56 <zipper> Such answers are highly subjective anyway
01:32:00 <Taneb> zipper, Erlang is very good, I've heard, even exceptional for distributed systems
01:32:03 <zipper> and would vary depending on use case
01:32:26 <zipper> Taneb: Yeah everyone says that but I wonder why it's very good.
01:32:36 * hackagebot bitcoin-payment-channel 0.3.0.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.3.0.0 (runeks)
01:32:37 <zipper> Like I like quickcheck on haskell
01:32:41 <zipper> and the type system
01:33:29 <Taneb> You'd probably be better off asking in #erlang but: it is designed for fault tolerance, it has distributed system primitives in the standard library
01:33:44 <Taneb> I wouldn't know where to begin writing distributed systems in Haskell
01:33:56 <Taneb> But Erlang is literally designed for it
01:34:19 <Taneb> You'd lose Haskell's type system, but I'd be very surprised if there wasn't something comparable to QuickCheck for Erlang
01:35:32 <amalloy> erlang has a quickcheck implementation, yes
01:36:22 <amalloy> written in fact by john hughes himself
01:36:29 <ahf> it costs money though :-(
01:36:31 <ahf> and quite a lot of money
01:36:42 <zipper> ahf: It's not foss?
01:36:44 <ahf> proper and triq are the open source ones
01:36:51 <ahf> zipper: no, it has license servers and what not :-(
01:37:00 <zipper> ahf: No free version?
01:37:05 <ahf> and it's the best implementation of the three quickcheck versions we have
01:37:09 <zipper> Ok I guess erlang is not as cool
01:37:13 <ahf> zipper: they have a eqc_mini which is a very stripped down version
01:37:18 <ahf> zipper: nah, proper is awesome - it's GPL-3
01:37:26 <zipper> ahf: Oh
01:37:28 <ahf> but it's nowhere near as fancy as quiviq's eqc
01:37:45 <ahf> when i asked for a license offer it was 5000 euro / year / person
01:38:00 <zipper> ahf: 0.o
01:38:02 <zipper> Damn
01:38:37 <ahf> they do give out licenses to researchers and people who actively writes articles (blog posts, etc.) about what they use it for
01:48:02 <Insanity_> I am premutating a really large string in haskell (20 chars)
01:48:14 <Insanity_> permuting? permutating? First one sounds correct
01:48:32 <Insanity_> Any way, I am using 'permutations' for that, is this the fastest way?
01:48:38 <Insanity_> :permutations
01:48:41 <Insanity_> :t permutations
01:48:42 <lambdabot> [a] -> [[a]]
01:54:52 <tdammers> Insanity_: if the order in which you are going to process the permutations matches the order you get from the permutations function, then that's probably as good as it gets
01:56:04 <Insanity_> tdammers: that is indeed the case, thanks :-)
01:56:14 <tdammers> using Text instead of String may or may not be faster; I'm unaware of a standard permutations function for Texts though
01:57:04 <tdammers> anyway, remember that Haskell's lists are lazy, so you're only calculating the permutations up to the last one you process
01:57:35 <Insanity_> which in my case will really be the last one, I am checking all the permutations ^^
01:58:43 <Cooler> Cale, you said earlier Real should be called Rational
01:58:46 <koz_> Insanity_: Are you familiar with the Johnson-Stenhaus-Trotter algorithm?
01:58:51 <Cooler> but theres a RealFrac
01:58:55 <koz_> It might get you what you need *much* more efficiently.
01:58:55 <Insanity_> koz_ not yet 
01:59:03 <Insanity_> Thank you :-)
01:59:05 <koz_> Insanity_: Look into it.
01:59:09 <koz_> It's *really* handy.
01:59:10 <Cooler> and its still not called Rational
01:59:28 <Cooler> :info RealFrac
01:59:34 <Cooler> :t RealFrac
01:59:35 <lambdabot> error: Data constructor not in scope: RealFrac
01:59:44 <Cooler> :t RealFrac 10
01:59:45 <lambdabot> error:
01:59:45 <lambdabot>     Data constructor not in scope: RealFrac :: Integer -> t
01:59:58 <Cooler> :i RealFrac
02:00:01 <koz_> Cooler: RealFrac is a typeclass.
02:00:04 <Cooler> yes
02:00:05 <koz_> (I think)
02:00:25 <Cooler> class (Real a, Fractional a) => RealFrac a
02:00:32 <Cooler> why is it not Rational a?
02:00:59 <lyxia> Insanity_: There are a *lot* of permutations of 20 elements though.
02:01:27 <Cooler> also this makes it weird that Real a has toRational
02:01:30 <koz_> lyxia: Precisely why I suggested that algorithm - it at least means that you can exclude the ones you obviously *don't* want.
02:01:43 <koz_> And you can construct permutations of a specific form much more easily.
02:02:06 <Insanity_> I'm checking that out now koz_, thank you
02:02:23 <koz_> I can't count the number of times this thing has saved my ass lately.
02:02:34 <Cale> Cooler: Well, for one, Rational is taken.
02:02:45 <koz_> It's probably *the* most useful algorithm I learned in my Advanced Algorithms class.
02:02:49 <Cale> Cooler: It's a synonym for Ratio Integer
02:03:02 <Cale> > 3/5 + 6/11 :: Rational
02:03:05 <lambdabot>  63 % 55
02:03:13 <koz_> Cale: I was told that Ratio Int is overflow-prone. Why is that exactly?
02:03:16 <Cooler> Cale, so why would you make RealFrac
02:03:34 <Cale> koz_: Because the denominators of rational numbers often get multiplied together
02:04:11 <koz_> Cale: Ah, of course - the representation has to be big enough to hold it before we gcd it down, right?
02:04:12 <Cale> koz_: whether you're adding or multiplying them, unless you can guarantee something number theoretical about the denominators, you can easily end up with large values
02:04:24 <Cale> yeah, and gcd'ing might not even help
02:04:34 <Cale> Cooler: hm?
02:04:53 <koz_> Cale: OK, that makes sense. Thanks.
02:05:17 <Cooler> Cale, so why would you make RealFrac?
02:05:29 <Cooler> when you already have Rational
02:05:36 <Cale> Rational is a type
02:05:40 <Cale> not a class?
02:05:58 <Cale> Are you looking at the operations in the classes you're asking about?
02:06:17 <Cooler> class (Real a, Fractional a) => Rational a
02:06:30 <Cale> RealFrac is for types that support truncate, round, ceiling, floor, and properFraction
02:06:38 <Cooler> instead of type Rational = Ratio Integer
02:07:03 <Cale> Rational wouldn't be a good name for RealFrac
02:07:17 <Cooler> what?
02:07:25 <Cooler> why not?
02:07:41 <Cale> RealFrac is basically for stuff that can be separated into an integer part and a fractional part
02:07:51 <Cale> > properFraction pi
02:07:53 <lambdabot>  (3,0.14159265358979312)
02:08:03 <Cale> That operation makes sense on more than just rational numbers
02:08:32 <Cooler> huh? i thought fractional meant it had to be a rational complex
02:08:33 <shachaf> @src Real
02:08:33 <lambdabot> class (Num a, Ord a) => Real a where
02:08:33 <lambdabot>     toRational :: a -> Rational
02:08:37 <Cale> It doesn't really make sense to call *any* type class "Rational"
02:08:39 <Cooler> complex rational
02:08:43 <Cale> huh? no
02:08:49 <shachaf> good method
02:09:04 <Cale> Fractional means vaguely a similar thing to "field" if you know that term
02:09:05 <Cooler> fractional = Ratio Integer
02:09:13 <Cale> No, you're confused
02:09:22 <Cale> class  (Num a) => Fractional a  where
02:09:22 <Cale>     (/)              :: a -> a -> a
02:09:22 <Cale>     recip            :: a -> a
02:09:22 <Cale>     fromRational     :: Rational -> a
02:09:32 <Cale> This is for types which allow division
02:09:41 <Cooler> recip
02:09:48 <Cooler> recip is very suggestive
02:09:53 <Cale> More precisely, types which have multiplicative inverses of nonzero elements
02:09:58 <Cale> Yeah
02:10:15 <Cale> The intention is that recip a * a will basically be 1
02:10:40 <Cale> Of course, the fact that we want Float and Double as instances will spoil everything
02:11:06 <Cale> @check \x -> recip x * x == 1 :: Double
02:11:09 <lambdabot>  error:
02:11:09 <lambdabot>  • Couldn't match expected type ‘Double’ with actual type ‘Bool’ • In the exp...
02:11:13 <Cale> @check \x -> recip x * x == (1 :: Double)
02:11:16 <lambdabot>  *** Failed! Falsifiable (after 1 test):
02:11:16 <lambdabot>  0.0
02:11:23 <Cale> hah!
02:11:30 <Cale> @check \x -> x /= 0 ==> recip x * x == (1 :: Double)
02:11:30 <lambdabot>  : -1: -1:Ambiguous infix expression
02:11:39 <Cale> @check \x -> (x /= 0) ==> (recip x * x == (1 :: Double))
02:11:41 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 1023 shrinks):
02:11:41 <lambdabot>  2.7725497737853586
02:11:48 <Cale> that's what I was looking for :)
02:12:16 <Cale> So there are examples of floating point numbers for which recip won't *quite* give you a multiplicative inverse
02:12:27 <Cale> But that's not terribly surprising -- it's just rounding error.
02:12:47 <Cale> > recip 2.7725497737853586 * 2.7725497737853586
02:12:49 <lambdabot>  0.9999999999999999
02:14:26 <Cooler> so Fractional means these types have multiplicative inverses for all nonzero elements?
02:14:33 <Cale> Cooler: But pretty much the intention is that instances of Fractional are more or less the same thing as the mathematical concept of fields -- with a few exceptions made to allow for types that only work with approximations.
02:14:41 <Cale> yeah
02:16:27 <Cale> I wouldn't really want it to be called "Field" for the reason that we're going to make these exceptions for Float and Double and various things based on them (e.g. Complex Double), just because setting expectations that laws will hold only to break them kind of sucks. But if it had been called Field all along, I also probably wouldn't complain too much.
02:16:38 <Aruro> what is good library for pdf generation?
02:17:01 <Cale> Aruro: using process to execute latex? :)
02:17:06 <merijn> Aruro: tbh, depending on your goal you might be better of producing latex
02:17:32 <Aruro> same question for latex generation?
02:17:32 <Cale> (pdflatex)
02:18:35 <koz_> In fact, I think numeric-prelude did exactly that - they have all the numbers in a hierarchy of rings, fields etc.
02:19:42 <Cale> Aruro: I'm not sure whether I'd bother with a special library for that, but it depends on how complicated the LaTeX I was generating was going to be. There is a library called hlatex which looks reasonably comprehensive, and I'm sure that pandoc contains some relevant code, you might want to look into whatever it's using.
02:20:13 <merijn> Aruro: I would write a template by hand then write code to fill in the gaps
02:20:29 <merijn> Aruro: It depends on how complex the PDF has to be
02:21:25 <Cale> Pandoc seems to have http://hackage.haskell.org/package/texmath as a dependency, but apart from that, it just does a bunch of string manipulation using functions defined as it needs.
02:21:30 <Cale> http://hackage.haskell.org/package/pandoc-1.17.2/docs/src/Text-Pandoc-Writers-LaTeX.html#writeLaTeX
02:21:58 <Cale> Of course, you could use Pandoc as a library too!
02:22:37 <Cale> Just generate data structures of its Pandoc type, and then http://hackage.haskell.org/package/pandoc-1.17.2/docs/Text-Pandoc-PDF.html
02:28:06 <Cooler> f :: Cust a => a -> a
02:28:22 <Cooler> instance Cust CT where
02:28:47 <Cooler> f _ = CTValue
02:29:07 <Cooler> CTValue :: CT 
02:29:24 <Cooler> will that work?
02:29:40 <Cooler> theres only one instance of Cust
02:30:29 <Cooler> or is that a type error?
02:32:05 <Cale> If f is a type class method of Cust, then yes
02:32:38 * hackagebot bitcoin-payment-channel 0.3.0.1 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.3.0.1 (runeks)
02:33:19 <Cooler> Cale, what no f is just a top level function
02:33:47 <Cale> In that case, no. Its type signature says it will work for any instance of Cust, but you only provided an implementation that works for one.
02:34:01 <Cooler> yes but theres only one instance
02:34:03 <Cale> There's no guarantee that a future module won't define a new instance.
02:34:07 <bwe> Hi, I did `cabal install statistics`. Then `import Statistics.Sample` in ghci (the same sandbox I installed it into). Could not find module ‘Statistics.Sample’. How do I correctly import the package?
02:34:08 <Cooler> ok
02:35:05 <lyxia> Cooler: why use a typeclass if it's only ever going to have one instance
02:35:22 <Cooler> Cale, but it would work if its a type class method?(as a default implementation?)
02:35:47 <Cooler> lyxia, this is just a contrived example
02:35:54 <lyxia> bwe: are you running ghci as "cabal ghci"
02:35:55 <Cale> bwe: Are you certain it's installed, and that you're using the sandbox ghci?
02:36:50 <Cale> Cooler: Not as a default implementation unless you used the DefaultSignatures extension, and even then, there would be no point to providing it as a default implementation in the class, because it would only work for exactly one instance.
02:37:03 <bwe> lyxia: No. Just ghci.
02:37:18 <Cale> Cooler: So you might as well put that code in the instance, and not the class.
02:37:37 <bwe> Cale: 'Installed statistics-0.13.3.0.'
02:38:11 <Cale> Cooler: also, classes which only ever have one instance tend not to be terribly useful
02:38:27 <Cooler> Cale, you said earlier it would work if its a type class method
02:38:30 <Cale> bwe: Okay, try cabal repl
02:38:55 <Cale> Cooler: yeah, with the intention that the implementation you gave is in an instance of the class for CT
02:39:12 <Cale> class Cust a where f :: a -> a
02:39:22 <Cale> instance Cust CT where f _ = CTValue
02:39:26 <Cooler> oh
02:39:51 <bwe> Cale: That's a revelation.
02:39:54 <Cooler> the Default Signatures extension allows this somehow?
02:40:11 <Cale> *That* doesn't require DefaultSignatures
02:40:15 <Cooler> allows it as a default in Cust i mean
02:40:35 <Cale> but with DefaultSignatures, you can give a more specific default implementation than the type of the method indicates
02:41:02 <Cale> Usually this is only useful if the implementation you give is still polymorphic and so will apply to at least a handful of instances
02:41:08 <Cooler> but isn't that a type error as a default implementation?
02:41:32 <Cale> DefaultSignatures lets you write  default f :: CT -> CT; f _ = CTValue
02:41:54 <Cale> and then that will be used as the default implementation if and only if the type unifies
02:42:01 <Cooler> oh you redefine the type
02:42:05 <Cale> yeah
02:42:09 <Cale> just for the default
02:42:20 <Cooler> yeah
02:42:27 <Cale> But it's silly when you just pick a concrete type
02:42:46 <Cale> More interesting when you need some other class constraint in order to provide a default
02:42:55 <Cale> which will still work mostly generically
02:46:58 <Cooler> http://lpaste.net/192912
02:47:12 <Cooler> this is from Haskell Programming from First Principles
02:47:32 <Cooler> does it work in principle? it fails in principle as well right?
02:48:11 <Cooler> unless you assume that no operations of Num will ever get used
02:52:17 <lyxia> What's "in principle"?
02:54:02 <Cale> Cooler: Well, anything polymorphic which has a Fractional-constrained type is allowed to use operations of Num on values of that type
02:54:45 <Cale> Cooler: So, there's no way to ensure that no operations of Num will ever get used -- there certainly exist operations asking only for Fractional and which use operations of Num
02:55:05 <Cale> :t (\x -> x + 1 / 2)
02:55:06 <lambdabot> Fractional a => a -> a
02:55:16 <Cale> That uses (+) for example.
02:57:45 <bwe> I read http://hackage.haskell.org/package/statistics-0.13.3.0/docs/Statistics-Sample-Histogram.html that `histogram`'s type signature requires a Vector. So, I head over to http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Generic.html#t:Vector to grasp what a vector actually is. Yes, it should be a set of two values. However, the documentation confuses (at least) me. `histogram 10 
02:57:46 <lpaste> bwe pasted “Statistics.Sample.Histogram (histogram)” at http://lpaste.net/1617006580799111168
02:57:51 <bwe> [1,2,3,4]` fails with vv
02:59:37 <Cale> bwe: You passed it a list, not a Vector
03:00:47 <Cale> bwe: Though I guess if you want to use the list syntax to specify vectors, there's an extension for that now
03:01:04 <Cale> (OverloadedLists)
03:01:44 <Cale> However, the usual thing would be to apply Data.Vector.fromList to it
03:02:06 <Cale> typically, you'd  import qualified Data.Vector as V
03:02:12 <Cale> and then it would be V.fromList [1,2,3,4]
03:04:55 <Cooler> Cale, yeah so it fails in principle
03:06:57 <Cale> Cooler: But it will be okay if you write an instance of Num as well.
03:09:12 <Forlorn> Suppose that I have a string "1 + (4 - 2)" how can I parse it in a tree like structure? Graph: http://sprunge.us/GPVC
03:09:54 <Forlorn> any tips?
03:11:14 <Forlorn> perhaps I can use Data.Tree
03:11:19 <Cale> https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Expr.html
03:11:20 <Forlorn> but I need to build a Tree in haskell, hmm
03:11:31 <bwe> Cale: I've got to import Data.Vector as V. `V.fromList [1,2,3,4]` gives me `fromList [1,2,3,4]`. `histogram 2 $ V.fromList [1,2,3,4]` gives me `Variable not in scope: histogram :: Integer -> Vector Integer -> t`. `histogram`s type signature tells me it expects a Vector of Double type. The error tells me that I provided a Vector of Integer type. Is that the mistake? So, then I've tried `histogram 2 V.fromList 
03:11:37 <bwe> [1,2,3,4::Double]`. Still, `Variable not in scope: histogram :: Integer -> ([a0] -> Vector a0) -> [Double] -> t` is raised.
03:11:39 <Cale> You probably don't want a Tree, just some data structure you invent to represent expressions
03:12:17 <Forlorn> I don't want to use the inbuilt parser method
03:12:19 <Cale> bwe: You're missing parens around the argument to histogram in that last one
03:12:34 <Forlorn> I want the understand the paradigm of how to execute such a task
03:13:14 <Forlorn> another approach would be to use something like groupBy (\x y -> isDigit x && isDigit y) "123+432"
03:13:16 <Cale> Forlorn: Well, you can perhaps use a library such as Parsec to write the parser, and then separately understand how such a library might be implemented
03:13:28 <bwe> Cale: `histogram 2 $ V.fromList [1,2,3,4::Double]` gives `Variable not in scope: histogram :: Integer -> Vector Double -> t`.
03:13:30 <Forlorn> and then group it like ["123", "+", "432"]
03:14:10 <Forlorn> and then group it like ["123", "+", "432" "*" "12] and then something for operator precedence
03:14:35 <Cale> bwe: Weird, for some reason it thinks 2 has type Integer
03:14:56 <Cale> bwe: Do you have Statistics.Sample.Histogram imported at all?
03:16:12 <lpaste> bwe pasted “Statistics.Sample.Histogram” at http://lpaste.net/5920779779526623232
03:20:20 <Cooler> does that show up everytime somebody uses lpaste?
03:20:33 <bwe> Cale: Yes, I have imported `Statistics.Sample.Histogram`. Most recent error: `Non type-variable argument in the constraint: Data.Vector.Generic.Base.Vector v1 Double`.
03:21:15 <Cale> bwe: hmm, try turning on the FlexibleConstraints extension that it tells you you'll need for that
03:21:21 <bwe> Cooler: If you select the IRC channel #haskell before you paste. 
03:21:38 <Cale> Er, sorry, FlexibleContexts
03:22:07 <Cale> :set -XFlexibleContexts
03:22:33 <Cale> Well, hmm
03:22:41 <lpaste> bwe revised “Statistics.Sample.Histogram”: “Statistics.Sample.Histogram” at http://lpaste.net/5920779779526623232
03:22:42 <Cale> Maybe that won't do it, if the type is ambiguous
03:22:48 <Cale> yeah
03:22:57 <Cale> So, I guess just tell it what type of result you want
03:23:12 <Cale> This is less of a hassle if you're not trying to do it at the ghci prompt
03:23:36 <bwe> Hum. That's frustrating. 
03:23:50 <bwe> So many things that can break.
03:24:17 <bwe> How do I tell it the type of result I want (presuming it to be indifferent from a type signature)?
03:33:52 <Cooler> someone mentioned (->) failed to generalize functions?
03:33:57 <Cooler> why?
03:34:30 <Cooler> i think it was ertes?
03:36:16 <ski> generalize ?
03:39:31 <Cale> Cooler: It doesn't generalise functions, it is the type constructor for function types
03:43:42 <Cooler> 10:02:57 <geekosaur> easy enough to excuse from the direction that Arrow was trying to generalize functions. it didn't succeed, but I'm not convinced the attempt /per se/ was a bad thing
03:44:08 <MarLinn> Arrow = the Arrow typeclass, not (->)
03:44:21 <Cooler> oh
03:44:26 <Cooler> you mean the one with local state?
03:44:55 <ski> (not even wrong ..)
03:45:18 <MarLinn> I'm reluctant to say yes because that's not the point, but ... yes...
03:45:21 * MarLinn cringes
03:45:49 <ski> "one with local state" would be a particular data type, which might be an instance of of the type class `Arrow' .. not a type class itself
03:46:45 <Cooler> how did it fail? seems like it generalizes pure functions (->) to all computations
03:47:18 <ski> it was a mistake to put `arr' in the base type class
03:47:22 <Cooler> also someone mentioned arrows are largely abandoned or something?
03:47:29 <Cooler> in favor of coeffects?
03:47:36 <logcat> Hi, not trolling. I am trying to learn haskell again. Tooling looks bad, I found no way to see autocomplete with docs  (haddock I assume) and no way to download and jump to source (haddock also I assume). Do I miss something or is it like this ?
03:48:06 <Aruro> logcat: there is autocomplete in ghci
03:48:17 <Aruro> logcat: tabcomplete
03:48:23 * ski assumes logcat is talking about some random IDE ?
03:48:56 <logcat> "autocomplete with docs" ? I assume something like this http://eclipsefp.github.io/images/completion.png
03:49:29 * ski doesn't use Eclipse ..
03:49:38 <logcat> and "jump to source", say I have dependency on aeson, can stack download sources, and when I have import of that stuff, press some buttons and jump to source of aeson, so I can read actual source of it
03:49:47 <logcat> I don't care which ide, just want it all together
03:50:33 <ski> (perhaps(?) it would be nice, but it's not a priority for me .. ymmv)
03:50:48 <Cooler> anyone?
03:51:25 <Aruro> logcat: haddock has sources, u can have all local packages documented and look in browser
03:51:44 <lpaste> bwe revised “Statistics.Sample.Histogram”: “Statistics.Sample.Histogram (running from file)” at http://lpaste.net/5920779779526623232
03:52:00 <bwe> Cale: So, putting it into a file and loading the same does not make a difference at all.
03:53:31 <MarLinn> Cooler: Things like "state" are fuzzy concept. E.g. using something as "state" just means you push it into the background of your model. Applicatives, Monads, and Arrows are all just tools to push stuff into the background of you model, including "state". If one tool is better than others for a use case you use that.
03:53:34 <Cale> bwe: Well, the expectation behind my statement was that you're going to write an actual program where some type signatures will exist on top-level things already, and they'll help it know which type of result it needs to produce.
03:54:22 <logcat> Aruro: what browser? web browser, if so it is completely different game when you can jump to exact function source from dependency which you are using right now.
03:54:52 <MarLinn> Cooler: Arrows are powerful, but you almost never need the power. And in many cases you would love to use their power, but then arr makes no sense
03:55:26 <Cale> Cooler: Arrow is a somewhat unpopular class just because it contains arr which sort of undermines a lot of the best applications that the class would have, and to go along with that, it lacks some operations that would be better suited there.
03:55:33 <Aruro> logcat: yes web browser, maybe in haskell-mode there is such thing but im not sure
03:55:55 <Cale> Well, I say "just because", but also the libraries which would use it in the way that I'm thinking tend to be a bunch of engineering effort to write.
03:56:32 <Cale> Cooler: The nice thing about Arrow as an interface is that its basic combinators like (>>>) and (***) have you combining elements of a type that you control
03:57:11 <Cale> The thing about Monad is that whenever you have a (>>=), the argument on the right is a function, which is basically a black box which can't be examined at runtime except to apply it to an argument
03:58:08 <Cale> So if we want to do some runtime analysis to simplify our computations before actually carrying out the things they describe, Monad is going to make our life hard
03:59:07 <Cale> So Arrow provides a bit of hope that maybe we can wire things together in a way that lets us discover that we've combined things which could be done in a simpler way (for a simple example, maybe you apply an arrow computation to something which ought to be its inverse, and you can see this and skip doing much of anything)
03:59:16 <Cale> But arr
03:59:19 <Cale> :t arr
03:59:20 <lambdabot> Arrow a => (b -> c) -> a b c
03:59:32 <Cale> It basically gives you black boxes
04:00:08 <Cale> and the proc/do syntax for arrows sticks an arr in between every pair of lines -- it's basically required to wire up the results of previous computations to where you need them
04:00:25 <Cale> and so you end up with code that can't be scrutinized after all
04:00:38 <Cale> Some relatively simple changes to Arrow would fix this though.
04:01:34 <Cale> However, it's also a rare library that actually is ambitious enough to try to do that dependency analysis and simplification in the first place
04:03:11 <Cale> and if you're not taking advantage of that... Arrow is perhaps a bit clunky a lot of the time
04:03:37 <Cale> Though, we actually have an Arrow in our test framework for a client project I'm working on
04:04:27 <Cale> Our tests can both produce results and require inputs from previous tests, in addition to checking that results are as expected
04:04:42 <Cale> and so we use Arrow just as an interface to wire things up
04:05:18 <MarLinn> The arr problem is also part of a bigger debate. You can make similar arguments for "pure" - but not without inducing fierce replies from some sides
04:05:48 <Cale> pure is not so much of a problem as arr
04:06:24 <Cooler> Cale, got dced
04:06:35 <bollu> Cale: what's a nice arrow library to get the hang of arrows?
04:06:41 <bollu> Cale: I've used arrow as tuple combinators
04:06:49 <Cooler> whats wrong with arr?
04:06:51 <bollu> Cale: don't really grok the "arrow" of arrows
04:07:06 <Cooler> arr just turns pure functions into computations
04:07:11 <Cooler> :t arr
04:07:13 <lambdabot> Arrow a => (b -> c) -> a b c
04:07:36 <bollu> :info Arrow
04:07:39 <Cale> bollu: Well, perhaps ertes' library "wires"
04:07:49 <bollu> Cale: what's it for? FRP right?
04:07:52 <Cale> yeah
04:08:03 <bollu> hm, I need a painless way to setup a GL context first
04:08:09 <Cale> Though mostly, I would just recommend only learning about Arrow if a library you want to use needs it
04:08:24 <warbo> hello, I wonder if anyone might know a technique to help me. I want to (conceptually) return a different type depending on the given argument value, i.e. 'MyData -> MyOutput a' where 'a' depends on the 'MyData' value.
04:08:29 <warbo> Normally I'd make the return value existential or use a continuation, e.g. 'MyData -> (forall a. MyOutput a -> Foo) -> Foo', but I need the function to be recursive and can't figure out an approach where I can make recursive calls
04:08:35 <Cale> Maybe take a look at the class definition enough to detect when that pattern is appearing in your own code at some point
04:08:58 <Cale> warbo: You're asking for a dependently typed language.
04:09:15 <warbo> Cale: yes, it would be trivial if I had dependent types
04:09:37 <Cale> Well, I mean, that's pretty much the definition of what makes a dependently typed language dependently typed
04:09:46 <Cale> You have types which depend on values.
04:10:16 <Cooler> warbo, return a different type or can you use Either a b?
04:10:30 <Cale> In Haskell, you usually either give up on making the distinction, or else go to lots of trouble...
04:11:11 <Cale> You might be able to index the type MyData, turning it into a GADT which makes each value apparent at the type level
04:11:21 <warbo> Cooler: I think "Either" would only solve 'one layer', but since it's recursive I think I need something more powerful
04:11:32 <Cale> How is your MyData type defined?
04:11:37 <Cale> (what is it really?)
04:11:42 <warbo> well, the MyOutput type is a GADT
04:12:00 <warbo> so that's the step I'm trying to do ;)
04:12:46 <ski> warbo : why doesn't either existential approach work ?
04:12:48 <Cale> In that case, the best you'll be able to do is probably to make an existential wrapper around MyOutput and to have something like  MyData -> SomeMyOutput
04:12:49 <bwe> Cale: Right. I want to use it as part of a top level function. But I learned it's better to get it running in isolation (MWE) and only when it works I might implement it into the top-level function.
04:13:02 <lpaste> bwe revised “Statistics.Sample.Histogram (running from file)”: “Statistics.Sample.Histogram (running from file)” at http://lpaste.net/5920779779526623232
04:13:27 <Cale> bwe: Try giving it a concrete type
04:13:29 <MarLinn> warbo: maybe you can pull out the recursion into an explicit fix and then use the continuation approach internally?
04:13:45 <Cale> Like  hh :: Int -> Vector Double -> (Vector Double, Integer)
04:14:01 <Cale> oh, sorry
04:14:06 <Cale> hh :: Int -> Vector Double -> (Vector Double, Vector Integer)
04:14:29 <Cale> and then, actually take the arguments
04:14:38 <Cooler> anyone?
04:14:43 <Cale> hh = histogram
04:14:44 <Cale> perhaps
04:14:46 <Cooler> whats wrong with arr?
04:14:59 <lpaste> bwe revised “Statistics.Sample.Histogram (running from file)”: “Statistics.Sample.Histogram (running from file)” at http://lpaste.net/5920779779526623232
04:15:02 <warbo> I have some serialised type signatures, of the form "Z", "S Z", "Z -> S Z", etc. which I've read in using haskell-src-exts, so my input value is Language.Haskell.Exts.Syntax.Type, although I'm only using the fragment of it which fits that form
04:15:02 <Cale> Cooler: Oh, I sort of explained that
04:15:10 <Cooler> i got dced
04:15:12 <Cale> ah
04:15:28 <Cale> Cooler: well, it basically amounts to the fact that functions are black boxes
04:15:44 <MarLinn> @where logs -- Cooler
04:15:44 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
04:15:53 <Cale> which spoils any attempt at doing program analysis prior to running your combined computation
04:16:49 <warbo> ski: I get 3 cases: 'Z' becomes 'MyOutput Z', 'S a' recurses on 'a' and becomes 'MyOutput (S a)', 'a -> b' recurses on 'a' and 'b' to become 'MyOutput (a -> b)'
04:16:51 <Cale> The main advantage that Arrow appears at first to have over Monad is that you can analyse where the results are flowing for the most part, and the things you're combining are of a type you have control over
04:17:00 <Cale> so you can watch for combinations that would simplify
04:17:17 <Cale> and try to save lots of work later when you actually run the thing
04:17:26 <MarLinn> I wonder... -XArrows needs arr it for tuple magic. But maybe one could create something like Arrow based on lenses instead...
04:17:38 <warbo> ski: if I don't have the 'MyOutput a' returned explicitly, I can't think of a way to turn the return values of the recursive calls into the required output
04:17:43 <lyxia> bwe: You are using Data.Vector.Vector but should be using Data.Vector.Generic.Vector
04:17:51 <Cale> MarLinn: You can add a handful of operations to Arrow so it doesn't need arr for its tuple manipulation
04:19:32 <Cale> assocL :: a (b,(c,d)) ((b,c),d), assocR :: a ((b,c),d) (b,(c,d)), unitL :: a b ((),b), unitR :: a b (b,()), retractL :: a ((),b) b, retractR :: a (b,()) b, swap :: a (b,c) (c,b)
04:20:11 <MarLinn> Cale: sure. But explicit tupling also feels awkward. We have these beautiful data types, but arrows only work on their isomorphic equivalent
04:20:28 <warbo> MarLinn: is there a way to do such separation which gives me access to the 'MyOutput a' value?
04:20:29 <Cale> Well, these tuples mostly come up implicitly
04:21:05 <Cale> MarLinn: the way the proc/do syntax works is it basically just tuples up all the available results from previous computations
04:21:30 <Cale> and sticks in operations to extract the things you need when you use them as inputs on later lines
04:21:34 <warbo> I've tried using an existential, but hit the same problem: the recursive calls give me 'SomeMyOutput' values which I don't know how to plug together
04:22:22 <Cale> An interesting optimisation question comes up when you go this way -- how to find the minimum number of such operations needed to go from one associated word to another
04:22:24 <lpaste> bwe revised “Statistics.Sample.Histogram (running from file)”: “Statistics.Sample.Histogram: changed to Data.Vector.Generic (lyxia)” at http://lpaste.net/5920779779526623232
04:22:46 <Cale> It's like a sorting algorithm problem, but with no associativity :)
04:23:11 <cinimod> I am using ghci 8.0.1 and get warning: 'CURRENT_COMPONENT_ID' macro redefined [-Wmacro-redefined] *70* times every time I reload
04:23:25 <cinimod> It's making ghci unusable
04:23:33 <lyxia> bwe: Data.Vector.Generic.Vector is the typeclass you were trying to use
04:23:35 <Cale> cinimod: That's, unusual
04:24:08 <lyxia> bwe: now if you want to just use a concrete Vector type like in your latest paste, Data.Vector gives you that.
04:24:34 <MarLinn> warbo: if you have a recursive function (a -> MyOutput b), you can turn it into (a -> MyOutput b) -> (a -> MyOutput b) and later "fix" that. Then a second function of similar type can get access to the result of the first and be "fixed" again. But you need quite some preconditions for it to be usable I find
04:24:36 <bwe> lyxia: Now, I am completely confused.
04:25:18 <lpaste> lyxia revised “Statistics.Sample.Histogram: changed to Data.Vector.Generic (lyxia)”: “Statistics.Sample.Histogram: changed to Data.Vector.Generic (bwe)” at http://lpaste.net/5920779779526623232
04:25:41 <cinimod> @Cale: is this something to do with backpack? I am loading multiple packages in one project
04:25:41 <lambdabot> Unknown command, try @list
04:25:48 <cinimod> Cale: is this something to do with backpack? I am loading multiple packages in one project
04:25:51 <Cale> cinimod: https://github.com/haskell/haskell-mode/issues/1417 looks related
04:26:22 <lpaste> bwe revised “Statistics.Sample.Histogram: changed to Data.Vector.Generic (bwe)”: “Statistics.Sample.Histogram: changed to Data.Vector.Generic (lyxia)” at http://lpaste.net/5920779779526623232
04:26:45 <bwe> Data types should help
04:26:57 <Cale> bwe: You didn't give your function implementation any arguments
04:27:05 <Cale> hh n v = ...
04:27:07 <lyxia> bwe: histogram is generic over vectors, that is, types which are instances of the Vector typeclass (Data.Vector.Generic.Vector).
04:27:18 <tsahyt> is there a convenient function to take a slice from somewhere in a bytestring or is something along the lines of  \i j -> take (i - j) . drop i the preferred way to do that?
04:27:33 <tsahyt> j - i actually
04:28:49 <cinimod> Cale: looks the same but I am not using haskell-mode
04:28:55 <Cale> tsahyt: I don't think there's a primitive way, probably take and drop is the way to go
04:29:05 <tsahyt> ok thanks
04:29:06 <lyxia> bwe: I first assumed you wanted to keep writing code generically (which is why I mentionned Data.Vector.Generic.Vector), but now I think you want to pick a concrete vector type, which Data.Vector.Vector is.
04:29:20 <Cale> tsahyt: You can of course define a function to do it
04:30:16 <Cale> lyxia: This whole problem got started because of ambiguity at the ghci prompt
04:30:46 <lyxia> bwe: okay, you applied histogram to two arguments, so the result should be a pair. hh :: (V.Vector Double, V.Vector Int)
04:30:50 <warbo> MarLinn: thanks, I'm scratching my head but can't immediately see how that splitting up helps; could you elaborate? I don't know 'b', but I do have GADT constructors for 'MyOutput Z', 'MyOutput a -> MyOutput (S a)' and 'MyOutput a -> MyOutput b -> MyOutput (a -> b)'
04:31:49 <lpaste> bwe revised “Statistics.Sample.Histogram: changed to Data.Vector.Generic (lyxia)”: “Statistics.Sample.Histogram: working now” at http://lpaste.net/5920779779526623232
04:32:03 <MarLinn> Cale: ok, we have a way to fix Arrow... now all we need is a better name. ;) What would you suggest? "Computation"? "DataFlow"?
04:32:37 <merijn> MarLinn: The thing is, all of Arrow's functionality seems to be replaced by: Category, Applicative, and Profunctor
04:32:38 <lyxia> bwe: the second vector is better used with an integral type, since it contains the number of elements of each bucket.
04:33:17 <bwe> lyxia: which do you mean the second vector to be?
04:34:00 <lyxia> bwe: histogram returns two vectors, I mean the second.
04:35:07 * warbo wonders why he seems to end up with dependent types in pretty much all of his Haskell projects...
04:38:55 <MarLinn> warbo: If you have some minimal code I could try to adapt that would be great.
04:39:48 <MarLinn> Otherwise I have this older paste of mine that uses the trick: http://lpaste.net/180207. It's not pretty, but maybe the explicit fix trick (look at the bottom) is understandable even without all the data types around it
04:39:54 <lpaste> bwe revised “Statistics.Sample.Histogram: working now”: “Statistics.Sample.Histogram: changed second vector to Integral type” at http://lpaste.net/5920779779526623232
04:43:37 <Reisen> Is there a nice way of representing building a chain of reversible operations? For example, having x = (+3) . (+4) and automatically producing the reverse operation from x ((-) 4) . ((-) 3)?
04:44:00 <Reisen> Might be a stupid question
04:52:48 <merijn> Reisen: How do you know the reverse of each operation?
04:53:47 <tsahyt> merijn: through some kind of isomorphism type maybe
04:54:09 <merijn> tsahyt: I can think of many ways, I was just wondering what he had in mind :p
04:54:19 <tsahyt> merijn: what other ways are there?
04:54:46 <Reisen> merijn, that's part of my question I guess. All the operations I will know ahead of time, my naive guess was to create an Op datatype with an operation and its reverse
04:55:18 <tsahyt> Reisen: data Iso a b = Iso { embed :: a -> b, project :: b -> a } would be one way to represent this
04:55:32 <merijn> Reisen: Have you looked at the design of darcs? (The version control system) They model patches as composable and invertable operations
04:55:35 <tsahyt> naming stolen from semigroupoids
04:55:47 <tsahyt> because that's the first Iso type I could find
04:55:57 <Reisen> merijn, nope, actually I'm about 2 weeks into Haskell at the moment
04:56:20 <Reisen> Haven't had a change to really delve into other sources that heavily yet
04:56:42 <mpickering> Reisen: This kind of problem is know as "bidirectional programming" if you just want to look at the literature
04:56:52 <bwe> lyxia & Cale: Thanks for your help
04:56:53 <merijn> tsahyt: That isomorphism approach is weaker than, say, Darcs' patch algebra
04:57:32 <Blade_Ander> Hi guys!
04:57:32 <tsahyt> merijn: I haven't looked into darcs tbh. But I suppose you could define a version of (.) that composes to an Isomorphism itself and you'd have both directions in one go
04:57:47 <merijn> tsahyt: Because there's no way (I think?) to do "f . g . h" and compose that with "f . g . h . g^-1" and get "f . h"
04:57:49 <wahrsagevogel> If I have a problem that makes me want to use StateT a [] () ist this reasonable or should I start looking at something better?
04:58:13 <merijn> wahrsagevogel: Is it reasonable? Yes, no, maybe, it depends. :)
04:58:33 <mpickering> tsahyt: yes and in fact there is a representation of isomorphisms which allows you to compose them with (.)
04:58:45 <merijn> tsahyt: So depending on what Reisen means with "reversable" there's things that require more than isomorphisms :)
04:59:05 <mpickering> type Iso a b = forall p . Profunctor p => p a a -> p b b
04:59:21 <mpickering> is isomorphic to the representation you gave
04:59:32 <mpickering> and we've reinvented the lens library :)
04:59:58 <Reisen> Well, looks like in the space of 5 minutes I've found a lot of reading material I need to go through
05:00:33 <warbo> Here's what I'm trying to do (make a working alternative to "f1" at the bottom); I've simplified a little, and added some stuff for context http://lpaste.net/193065
05:00:34 <wahrsagevogel> merijn: well the reason i'm asking ist that if you happen to use "State a ()" then often a fold is better. Now I want all possible outcomes hence the [].
05:01:26 <wahrsagevogel> merijn: I'm just asking to be pointed to possible other directions I should explore
05:02:12 <tsahyt> mpickering: one of these days I'm finally gonna learn lens
05:02:21 <tsahyt> even after more than 2 years of haskell it's still scary
05:02:50 <tsahyt> but before that I'll finally find some way to make this haskell code as fast as the C equivalent. I've been tearing my hair out over that for a whole day now
05:06:21 <mpickering> I will explain one day if you ask. The concepts are not difficult, the issue is the library is too large to understand
05:06:39 <warbo> for the record, I've already got a working version of what I'm after
05:06:45 <mpickering> but once you understand the concepts you are thankful the library already provides what you want
05:07:01 <warbo> but it works by concatenating strings together and invoking a `runhaskell` subprocess :P
05:07:19 <warbo> trying to see if there's an alternative
05:07:27 <tsahyt> mpickering: I've spent some time basically reimplenting it's zooming functionality when working with a large state type in a MonadState. that was the first time I wished I had used lens.
05:18:09 <quchen> Is there a way to add Haddock comments to TH-generated code (lenses, to be specific)?
05:19:03 <MarLinn> warbo: I think my idea has nothing to do with what you want after all. Sorry.
05:19:13 <warbo> MarLinn: heh, no worries :)
05:19:18 <quchen> merijn: Re tortoise and hare: isn’t that for cyclic data structures, which lists cannot be detected to be?
05:19:42 <merijn> quchen: The specific algorithm, yes. But the trick used in it is not
05:19:57 <quchen> What’s an example of it being useful in Haskell?
05:20:01 <merijn> quchen: Like this one: https://gist.github.com/merijn/c163cc106fd245d1cf2e
05:20:34 <ggole> You can implement cyclic structures by (manually) allocating identities, in which case the tortoise and hare algorithm applies
05:20:37 <quchen> merijn: Thanks. I like copying your stuff, it worked very well for the STGi. :-)
05:20:49 <quchen> Oh, splitInHalf.
05:20:50 <merijn> quchen: Or algorithms like "drop last 10 elements" where you don't know how long your list will be, but you wanna perform operations a fixed distance from the end
05:20:55 <quchen> That one might even be my own code. 
05:20:59 <ggole> I should say, *detectably* cyclic structures
05:21:44 <merijn> quchen: Basically, any list algorithm that deals with fixed stretches of lists of unknown length can use this sorta trick. I like how elegant it is :)
05:22:44 <quchen> merijn: I wonder what the general principle is though.
05:22:51 <quchen> Collecting all examples is hardly useful.
05:23:41 <merijn> quchen: The general principle is recursing at different points of the same list simultaenously
05:25:38 <mpickering> quchen: You can, but you need to write the type signatures yourself
05:25:55 <quchen> I can do what?
05:26:40 <mpickering> add haddock comments to th generated code
05:26:45 <mpickering> for lenses specifically see, https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-TH.html#v:generateSignatures
05:27:28 <ZachK> hey, what is the best way to have ghci auto reload a file when you save it?
05:28:33 <mpickering> use ghcid
05:28:51 <mpickering> which is a separate program which manages the reloading
05:33:55 <ZachK> thanks
05:33:58 <ZachK> will take a look 
05:34:39 <quchen> mpickering: Ah, interesting. Thanks!
05:39:44 <lpaste> bwe pasted “How to correctly specify packages in build-depends of cabal file” at http://lpaste.net/82888642564980736
05:41:00 <merijn> bwe: Lemme guess, your executable and library source are in the same directory? :)
05:41:32 <bwe> merijn: 100 points.
05:41:51 <merijn> bwe: If you "import Stat" in Main.hs and Stat.hs is in the same directory it'll try to recompile instead of linking against your library
05:42:15 <merijn> bwe: Move either the library or executable (or both) to a subdirectory and use the source directory field to specify the subdir
05:42:26 <bwe> merijn: Which it does. I even wondered why it does compile twice.
05:43:04 <merijn> "Hs-Source-Dirs" is the right field (same applies for tests)
05:48:11 <bwe> merijn: I've changed it and compiling works.
05:58:11 <Cooler>  Num a needs Eq a  right?
05:58:33 <ertes> Cooler: type this in GHCi:  :i Num
05:58:36 <Cooler> class Eq a => Num a ?
05:59:17 <opqdonut> not any more
05:59:17 <Cooler> why not?
05:59:17 <Boomerang> :i Num
05:59:29 <opqdonut> Num used to require Eq but it changed some time ago
05:59:34 <ertes> Cooler: because some things that act like numbers aren't (easily) Eq
05:59:36 <Cooler> why doesn't it require Eq
05:59:44 <Cooler> like what
05:59:49 <ertes> Cooler: functions
05:59:54 <Cooler> ?
06:00:03 <Cooler> function :: Num a?
06:00:13 <opqdonut> http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num
06:00:15 <Cooler> that doesn't make sense
06:00:21 <ertes> Cooler: function-like things can be instances of Num
06:00:24 <opqdonut> Cooler: an instance Num (a -> Int) e.g.
06:00:38 <ertes> Cooler: here is a simple one:  instance (Num a) => Num (e -> a)
06:00:40 <opqdonut> Cooler: where f * g = \x -> f x * g x
06:00:55 <opqdonut> (i.e. pointwise operations)
06:01:12 <ertes> Cooler: it's an instance of a more generic pattern:  if F is an Applicative, you can write:  instance (Num a) => Num (F a)
06:01:31 <ertes> with (+) = liftA2 (+), fromInteger = pure . fromInteger, etc.
06:03:29 <Squarism> Im gonna do a talk on haskell at work for java-programmers. I wonder if there are any good material on how to win over typical java programmers? Maybe no fibonnaci or to complex stuff - but "selling" / neat
06:04:02 <ertes> Squarism: talk about practical things like concurrency, STM, thin abstractions, etc.
06:04:24 <Insanity_> fib is not complex, and it's nice to see how it works in a different language as most will be familiar with the problem
06:05:24 <Squarism> Insanity_, notice the "OR"... i think i meant pointless algorithms for enterprise programmers
06:05:25 <ertes> Squarism: java programmers are OOP enthusiasts, so you have a very difficult target audience…  it's best to get a good understanding of why OOP is bad, but never to actually mention it during the talk
06:05:58 <Insanity_> Squarism: it's not pointless though, neither for enterprise programmers. You can demonstrate a common problem in a new language, helps see the differences between how they would do this in Java compared to Haskell
06:06:22 <Insanity_> When I learn a new language (like now Haskell), I do compare the problems with how I'd tackle it in a different language. (That also being Java in my case)
06:07:22 <Squarism> ertes, the typical java programmer does very little concurrency (i dare say). Concurrency is done super high level abstractions for different standard cases
06:07:40 <Squarism> done using ... 
06:07:41 <Squarism> even
06:07:52 <Cooler> ertes, should we change its name then? from Num to something else
06:07:58 <ertes> Squarism: that's why you should show it…  show them how haskell solves *their* problems using completely different technology that actually provides an advantage
06:08:06 <ertes> Cooler: like what?
06:08:22 <Cooler> whats a mathematical structure that has +, -, * defined
06:08:34 <ertes> Cooler: semirings, rings, fields
06:09:13 <ertes> Cooler: but Num is none of those…  it has this fromInteger function that doesn't belong there
06:09:14 <Cooler> yeah so change the name to that
06:09:34 <Cooler> how does fromInteger work with functions
06:10:07 <ertes> Cooler: answer that using Applicative:  fromInteger = pure . fromInteger
06:10:42 <Cooler> what? how does that work?
06:10:50 <Cooler> its recursive
06:10:55 <ertes> nope
06:10:56 <opqdonut> it's a different fromInteger
06:11:04 <Cooler> from where
06:11:19 <ertes> Cooler: instance (Num a) => Num (F a)
06:11:27 <ertes> in this case:  F = (->) e
06:11:46 <ertes> so whenever 'a' is a Num, (F a) is also a Num
06:12:13 <ertes> pure :: a -> F a
06:12:35 <ertes> compose that with fromInteger and see what you get
06:14:00 <Cooler> ertes, thats weird
06:14:11 <Cooler> where are you getting a second fromInteger from?
06:14:30 <Cooler> your supposed to implement one not use it
06:15:20 <Cooler> the second fromInteger is of type Integer -> Num a from what your saying
06:15:55 <Cooler> or Num a => Integer -> a
06:15:58 <quchen> Squarism: Rip off the node.js people, write a webapp. Import WAI/Warp, main = run 8000 (\_req respond -> respond (responseLBS ok200 [] "Hello World!"))
06:16:24 <Squarism> quchen, i like that!
06:17:07 <quchen> Above example needs -XOverloadedStrings by the way.
06:17:22 <quchen> inb4 rambling about how ByteString should not be IsString.
06:17:36 <quchen> Which I normally agree with, but not in this example. :-þ
06:17:38 <ongy> quchen: I could also package a library that makes the same example in C. I don't really see the value
06:18:04 <ongy> does the IsString instance of bytestring handle unicode?
06:18:09 <bartavelle> Squarism, some code just looks better in Haskell, even without going into complicated stuff. Just with sum-types I could show how easy it was to encode some business logic compared to the actual java code that was in production
06:18:20 <merijn> ongy: If "silently dropping" is "handling", then yes
06:18:23 <quchen> Bytestring is not a string, so it should not be an IsString.
06:18:25 <bartavelle> (well, most code just looks better ;)
06:18:26 <ongy> so no
06:18:30 <merijn> ongy: Right
06:18:33 <Squarism> bartavelle, true!
06:18:50 <ongy> I dislike silent drops even more than just crashing on it :(
06:19:12 <merijn> ongy: Which is why the ByteString instance of IsString is so awful :(
06:19:31 <Cooler> bartavelle, then thing that scares ppl away is performance
06:19:39 <bartavelle> Squarism, but that was when I was learning Haskell, and I did the smug-asshole impersonation, so my proselitism didn't work well
06:19:45 <bartavelle> proseletism ?
06:19:52 <ongy> Squarism: depending on what you want to achieve with the talk, you may want to mention scala. Or at least be prepared for questions
06:19:53 <bartavelle> y
06:20:19 <bartavelle> Cooler, in that case, performance was mostly database-bound
06:20:38 <bartavelle> "proselytism"
06:21:33 <Squarism> ongy, ive already done a scala talk. "people in charge" were sceptical (Here, java is the only choice for the future enterprise) but all devs wanted to learn.
06:21:56 <ertes> Squarism: also don't show them terrible examples that are great on the surface, like the infamous qsort example
06:21:59 <ongy> Cooler: I have tried it befor. My haskell code was (imo significantly) faster compared to an existing project. But I can't say if that's because the others project scope is a bit bigger, language optimization or plain skill (really doubt the last one)
06:21:59 <quchen> ongy: The value of that depends on whether you’re in sales or not. I think it’s nice that one can write such a small webserver example program, and then talk about how Warp works, how it’s automatically parallel and such.
06:22:27 <ongy> quchen: at that point you are trying to sell a library, not haskell
06:22:31 <quchen> ongy: And it’s not an academic example. It’s minimal, yes. But that’s what drives many Haskell-based applications, not something made up for a slide.
06:22:39 <ertes> Squarism: i.e. don't make them go "wow" during the talk, and then "oh, that's actually quite horrible" when the look into the stuff themselves later
06:23:02 <bartavelle> Squarism, also about the "let me show you how it would look in haskell", one should be careful to not pick the worst java code, as it could look much better in java already ...
06:23:08 <quchen> Haskell is, among other things, a library, a community, a package ecosystem. To make people buy into it, that matters much more than whether we have rank-N-types.
06:23:51 <Squarism> ertes, i didnt plan too =D
06:24:09 <ongy> quchen: may be. I'm in a academic environment so I'm more interested in the language. I guess for businesses other things are important (aswell)
06:24:10 <Insanity_> You have a point there quchen. Java is used a lot in the enterprise, but not really because of the language itself. Everything around Java makes it so useful to them
06:24:42 <Jupelius> It's never the language itself that makes it useful
06:24:43 <Insanity_> Pull in x things you need with maven, so you have to avoid reinventing a lot of wheels
06:24:56 <ertes> Cooler: i'm getting the second fromInteger from the fact that 'a' is a Num
06:25:12 <Cooler> i think a major reason to use Java is Spring
06:25:19 <quchen> Well, Haskell-the-language being interesting is what made people build all the packages and the compiler and everything. So we should also give some credit to this part of it.
06:25:39 <ongy> Jupelius: I mainly use haskell because I like the type system.
06:25:46 <Insanity_> Jupelius, maybe it's never the language itself that makes it useful, but if the language is utterly terrible, I'm not sure how much some tools and libraries would change that
06:26:10 <Squarism> Yeah.. in all seriousness im not doing a java vs haskell contest. We're pot committed to java. But haskell can be good for small problems / subsystems / scripting etc
06:26:22 <Jupelius> Insanity_: if it's the only language for a specific thing, then it's a quite reasonable choice
06:26:41 <ertes> from my experience java programmers have a love/hate relationship with programming patterns…  if you can make patterns tasty again, they're sold =)
06:27:32 <Insanity_> Yeah true, if it is the only choice (speaking of DSL then more I guess). But to agree with quchen here, I don't think a language like brainf*ck will get many useful libraries any time soon - and even if it did, would you want to learn it? :P
06:28:10 <Insanity_> And indeed Squarism, you don't want to start a Java vs Haskell thing at work ;-)
06:28:23 <Cooler> to switch over completely you would need something like Spring for Haskell
06:28:30 <Insanity_> More a "right tool for the job" thing, and as you said, haskell might be the right choice for some of the smaller parts you need
06:28:48 <ertes> Insanity_: all brainfuck really needs is some modularity features like named procedures, and some conventions like a stack to pass arguments to named procedures
06:28:58 <ertes> it could be such a useful language!
06:29:05 <Insanity_> héhé :D 
06:29:11 <Insanity_> Imagine bringing that up with a manager though ertes
06:29:21 <ertes> "brain-what?"
06:29:24 <Insanity_> "I'd like to try out brainfuck for the next project"
06:29:26 <ongy> whitespace
06:29:28 <ongy> or apl
06:29:42 <Cooler> isn't there something called lolcode?
06:29:49 <Insanity_> Yeah there is Cooler :-)
06:30:02 <ertes> i'd use lazy k instead
06:30:08 <Cooler> nimrod
06:30:09 <quchen> Insanity_: I implemented Brainfuck a couple of times, but it would not be my choice for learning to use it properly to umm implement a games engine with.
06:30:12 <Insanity_> There are a bunch of these "esoteric" languages
06:30:25 <ertes> brainfuck looks horrible, but isn't really that horrible to use
06:30:27 <Cooler> i don't think nimrod is esoteric
06:30:36 <Insanity_> there was a language based on arnold's character in the terminator I believe
06:30:41 <ongy> quchen: as scripting language for plugins :)
06:30:47 <Squarism> ertes, hehe.. true. Thats one idea i had.. maybe do some Combo of a few base types (Reader Monad - Either - Tree - XYZ) and solve some problem in few lines 
06:30:53 <Insanity_> https://github.com/lhartikk/ArnoldC
06:31:39 * quchen likes befunge most. Very interesting concept, very puzzle-y coding, very nice code golfing capabilities.
06:31:43 <ertes> i wrote this lazy k…  uhm…  javascript code as part of a challenge: http://lpaste.net/7356318189568917504
06:31:43 <ertes> =)
06:32:20 <ertes> it's not obfuscated, it's just…  churched =)
06:32:39 <Insanity_> That'd make many people happy during code reviews I bet :D
06:32:43 * hackagebot rosmsg-bin 0.1.0.0 - ROS message management tools  https://hackage.haskell.org/package/rosmsg-bin-0.1.0.0 (akru)
06:32:55 <ertes> (i wanted to do the SK transform, too, but ran out of time)
06:33:04 <Cooler> quchen, befunge looks like a text version of visual scripting
06:36:28 <ertes> Squarism: perhaps something more domain-specific…  remember hangman?  something like that that is *really* difficult and ugly to express in java
06:37:12 <ongy> ertes: it is?
06:37:36 <ertes> ongy: the pattern
06:38:07 <ongy> I really don't get it. but maybe I would have to try it
06:38:27 <Cooler> ertes, the game hangman?
06:38:29 <ertes> ongy: do you know what i'm referring to?
06:38:30 <Squarism> ertes, yeah.. i will show the game and talk a little about that
06:38:39 <ertes> Cooler: yeah
06:38:51 <ongy> I asume the hangman game. but I don't know what of it should be ugly to express in java
06:39:01 <Insanity_> indeed, I miss that as well ongy
06:39:03 <ongy> but I haven't tried to implement it, so I may be missing something
06:39:11 <Insanity_> I have, and still don't really see it :P
06:39:25 <ertes> the game is not difficult to express, but i have shown a specific pattern to encode it to Squarism 
06:39:47 <Forlorn> if I have `let a b = [1..b]`, `a 5 = [1..5]` is all good, but what if I want `a inf = [1..]`
06:39:54 <ertes> let me see if i have an implementation of it somewhere
06:40:08 <Insanity_> Cheers ertes
06:41:34 <Cooler> Forlorn, trying to return a infinite list?
06:41:38 <ongy> Forlorn: I think at that point I would make the list an argument, not the upper bound. (Or use takeWhile)
06:41:41 <Forlorn> Cooler, yes
06:42:33 <Forlorn> ongy, that makes more sense, thanks
06:43:40 <Cooler> how do you return a infinite list?
06:44:02 <ongy> > drop maxBound $ [0..]
06:44:08 <lambdabot>  mueval-core: Time limit exceeded
06:44:13 <ongy> Cooler: the same way you return finite lists
06:44:42 <Cooler> drop maxBound?
06:45:17 <ongy> > [0..] -- this works, but lambdabut limits the output (guess why)
06:45:20 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:45:33 <Forlorn> why?
06:45:34 <Forlorn> ^^
06:45:53 <Cooler> arbitrary limit
06:46:56 <Cooler> ongy, sure [0..] works but i was talking about sometimes returning finite lists
06:47:42 <ongy> Cooler: the type doesn't say if it's finite. but if you want an example
06:47:44 <Cooler> or returning a custom infinite list that skips 3 numbers or something
06:48:07 <Cooler> f skipn = [0, skipn..]
06:48:19 <ongy> flip takeWhile [0..] . (\u -> /=u)
06:48:23 <ongy> I think that works
06:48:50 <ongy> :t drop 3 [0..]
06:48:52 <lambdabot> (Num a, Enum a) => [a]
06:48:54 <ongy> > drop 3 [0..]
06:48:56 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
06:49:31 <Cooler> uh no
06:49:41 <Cooler> >[0,3..]
06:49:49 <Cooler> > [0,3..]
06:49:51 <lambdabot>  [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,7...
06:50:00 <ongy> > 0 : drop 3 [0..]
06:50:03 <lambdabot>  [0,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
06:50:08 <Cooler> nope
06:50:08 <ongy> infinite lists are still lists
06:50:32 <ertes> Insanity_, ongy, Squarism: https://github.com/esoeylemez/snippets/blob/master/Hangman.hs
06:50:32 <Cooler> ongy, yes i know the types are the same
06:51:03 <Cooler> > f n = [0, n..]
06:51:07 <lambdabot>  <hint>:1:5: error:
06:51:07 <lambdabot>      parse error on input ‘=’
06:51:07 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:51:14 <Cooler> > le f n = [0, n..]
06:51:17 <Cooler> > let f n = [0, n..]
06:51:18 <lambdabot>  <hint>:1:8: error:
06:51:19 <lambdabot>      parse error on input ‘=’
06:51:19 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:51:19 <lambdabot>  <no location info>: error: not an expression: ‘let f n = [0, n..]’
06:51:26 <Insanity_> Thanks ertes
06:51:38 <ongy> Cooler: iirc [start,step..upper bound]
06:51:48 <ertes> you can generalise it even further by abstracting the [] into an arbitrary Alternative…  that way you could even encode the stuff like the number guessing game sanely
06:52:02 <ertes> so the type should really be called "GuessGame", not "Hangman"
06:53:55 <Cooler> why did that not work? it works in ghci
06:53:57 <Cooler> > let f n = [0, n..]
06:53:59 <lambdabot>  <no location info>: error: not an expression: ‘let f n = [0, n..]’
06:54:22 <Cooler> > let f n = [0, n..] in take 10 $ f 10
06:54:24 <lambdabot>  [0,10,20,30,40,50,60,70,80,90]
06:54:27 <Cooler> ok
06:54:49 <ertes> Cooler: lambdabot has a separate command for definitions:  @let
06:55:06 <Cooler> so what does let do?
06:55:16 <ertes> @let xx = 500
06:55:18 <lambdabot>  Defined.
06:55:19 <ertes> > xx + xx
06:55:22 <lambdabot>  1000
06:55:40 <Cooler> let vs @let
06:56:22 <ertes> @let is a lambdabot thing…  it just inserts whatever you give it into a haskell source file and reloads it
06:56:23 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
06:56:47 <hpc> where did that error come from
06:56:53 <ertes> that way it emulates GHCi's 'let' without 'in'
06:56:58 <ongy> ertes last post started with @let
06:57:17 <hpc> i mean specifically it being a TH error message
06:57:34 <ertes> hpc: the stuff after my @let actually explains it =)
06:58:00 <ertes> it's the "naked expression at top-level" error
06:58:04 <hpc> @let syntax error
06:58:04 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
06:58:16 <hpc> ah, that makes sense then
06:58:49 <ertes> does lambdabot insert anyway?
06:58:51 <ertes> @let yy = 300
06:58:52 <lambdabot>  Defined.
06:58:54 <ertes> > xx + yy
06:58:56 <lambdabot>  800
06:58:58 <ertes> ok
07:03:27 <ongy> @let {-# LANGUAGE TemplateHaskell #-} syntax error
07:03:28 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
07:05:56 <[k-> I got lost while reading a list comprehension *again*, but I got back on my feet
07:06:59 <glguy> maybe stop walking while reading code
07:07:07 <Insanity_> lmao
07:07:18 <han-solo> :)
07:08:04 <ongy> I want google glass to write code while walking
07:08:08 <c_wraith> [k-: if it makes you feel any better, some of us hardly use list comprehensions at all.  Why bother when we have higher-order functions that do all the same things?
07:08:24 <[k-> I was using figurative language, just in case you really didn't know. It was this code here: mconcat xss = [x | xs <- xss, x <- xs]
07:08:41 <Insanity_> I'm sure we all knew :P
07:08:52 <glguy> some of us like them, too!
07:09:00 <c_wraith> Funny that the same could be said about do blocks, but I use those all the time.
07:09:08 <han-solo> hello
07:09:16 <shapr> oh hai
07:09:44 <han-solo> a new user here, would to get good beginner handbooks in haskell
07:10:03 <shapr> han-solo: Have you seen "Learn You a Haskell" ?
07:10:07 <Insanity_> I'm using this: http://learnyouahaskell.com/chapters
07:10:12 <ongy> [k-: is that 'concatMap concat'??
07:10:14 <han-solo> thanks
07:10:15 <Insanity_> Well, the paperback
07:10:18 <han-solo> shapr: nope
07:10:32 <shapr> han-solo: that's teh link Insanity_ just posted
07:10:43 <Cale> han-solo: also http://www.cis.upenn.edu/~cis194/spring13/lectures.html
07:10:44 <han-solo> yeah, got it! THnaks
07:11:17 <[k-> it's found in GHC.Base, the author said yes it was, but because concatMap concat was not defined in GHC.Base, he resorted to list comprehension 
07:11:29 <ongy> :t \xss = [x | xs <- xss, x <- xs]
07:11:30 <lambdabot> error:
07:11:31 <lambdabot>     parse error on input ‘=’
07:11:31 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
07:11:38 <ongy> :t \xss -> [x | xs <- xss, x <- xs]
07:11:40 <lambdabot> [[t]] -> [t]
07:11:43 <han-solo> Cale: thanks
07:11:54 <c_wraith> [k-: you find all sorts of weird things in the GHC.* modules
07:12:06 <[k-> The list monad operations are traditionally described in terms of concatMap: xs >>= f = concatMap f xs Similarly, mconcat for lists is just concat. Here in Base, however, we don't have concatMap, and we'll refrain from adding it here so it won't have to be hidden in imports. Instead, we use GHC's list comprehension desugaring mechanism to define mconcat and the Applicative and Monad instances for lists. We mark them INLINE because the inliner is not 
07:12:24 <c_wraith> [k-: they don't get to use the full expressive power of the libraries, on average, because they're *implementing* it.
07:12:58 <[k-> and we get to learn how they do it!
07:13:03 <hpc> see also, implementations of kernel modules, or garbage collectors, or malloc
07:13:14 <ongy> kernel code is fun
07:13:21 <Cooler> i found Learn you a haskell to be very centered around passwords
07:13:30 <merijn> ongy: Not if it's linux kernel code... >.>
07:13:51 <hpc> there are some ridiculously sophisticated garbage collectors out there
07:13:52 <ongy> merijn: is bsd better? I only have real experience with linux
07:14:15 <[k-> hpc: jvm's generational garbage collector?
07:14:18 <merijn> FreeBSD is much better, at least. And so is Minix
07:14:29 <Forlorn> merijn, why is it better?
07:14:30 <hpc> definitely, as well as ghc's own
07:14:54 <merijn> Forlorn: Better documented, cleaner, more consistent, less ugly hacks
07:15:23 <hpc> i consider ghc's to be better overall because of the other incidental stuff that lets it do some weirdly powerful tricks
07:15:42 <ongy> I have to read into the generational GC stuff again
07:15:51 <ongy> and what exactly the (is it big or major?) gc run does
07:16:00 <Forlorn> merijn, you mean the kernel and manuals are better documented?
07:16:12 <hpc> something ghc's gc is able to assume because of haskell's general avoiding mutation
07:16:30 <hpc> is that things that were created further in the past are extremely unlikely to refer to things created nearer the present
07:16:35 <merijn> Forlorn: I mean the actual source of the kernel and also it's APIs
07:16:46 <ggole> Every GC can do that, really
07:17:15 <ggole> It's common to have older generations assume no pointers to young and use a write barrier to mark the exceptions.
07:17:40 <hpc> sure, but you can't take nearly as much advantage of that fact
07:17:41 <Forlorn> merijn, I see.
07:17:46 <[k-> I think that's Ruby's GC
07:17:59 <hpc> and you can't make that assumption within the same generation
07:18:21 <ongy> Forlorn: for example, try finding out what netlink is and how it works
07:18:42 <ggole> Can you do that in Haskell? Doesn't thunk evalution result in writes to an object that may refer to young objects (that have just been produced by the thunk)?
07:18:58 <c_wraith> hpc: I can create a circularly linked list with (:) constructors in different generations pretty easily. :P
07:19:26 <c_wraith> ggole: indeed it does
07:19:56 <merijn> ggole: GHC basically assumes everything is trash, except those bits that are reachable
07:19:59 <c_wraith> I really want compact regions.  Are they still expected to land in 8.2?
07:20:21 <ggole> merijn: again, many collectors work that way
07:20:40 <hpc> c_wraith: gah, forgot about knot tying
07:20:40 <Forlorn> ongy, I just read a couple hundred pages from the Linux Programming Interface (Linux and Unix system programming)
07:21:01 <c_wraith> ggole: I think the big difference is that ghc can set things up so that it only needs to promote an object from one generation to an older one a single time ever.
07:21:01 <Forlorn> I didn't see much major differences, with the exception of Linux providing more features
07:21:15 <Forlorn> I didn't read the entire book though
07:21:17 <ongy> Forlorn: if you want to we can talk more about it, but I think we should move it to -blah
07:21:27 <[k-> does ghc literally collect garbage as we traverse and manipulate a list?
07:21:53 <ggole> There are some additional tricks like rewriting a reference to an evaluted thunk directly to the resulting value, but those are also known in other implementations
07:22:08 <Cale> It collects garbage basically any time it likes, whenever things are being allocated, there's an opportunity for it.
07:22:15 <merijn> [k-: You might wanna read the GHC commentary and ezyang's draft paper on the runtime system
07:22:16 <hpc> c_wraith: and that allocation is almost free, and you can expect a program to allocate gigs or terabytes of memory over its lifetime
07:22:48 <hpc> (in most use patterns, the only cost is a pointer increment)
07:22:48 <[k-> I haven't even finish a book on haskell!
07:23:03 <hpc> @where commentary
07:23:04 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary
07:23:10 <hpc> [k-: ^
07:23:15 <ggole> These are all nice things, but they are all standard in modern collectors.
07:23:51 <hpc> ggole: if you define "modern" to exclude almost every gc in common use
07:23:53 <ggole> I'm sure GHC's collector is very good, but my impression is that there is no reason for that other than that somebody (Marlow?) put a lot of careful work into it, rather than some property of the language
07:23:54 <[k-> I have stumbled upon this before, it's a looooong journey
07:24:15 <hpc> ggole: it's both, a lot of careful work that /uses/ properties of the language
07:24:41 <hpc> (or lack of properties, the haskell report is intentionally vague and high-level on many things)
07:24:58 <ggole> I don't see any property of Haskell that makes writing a good collector easier.
07:25:45 <ggole> In particular all of the things you mentioned, while they are great ideas, are also done by other implementations
07:26:38 <c_wraith> only languages with lazy evaluation semantics get to use optimizations based on "this value will only ever be mutated at most once"
07:26:46 <hpc> what other implementations?
07:26:49 <c_wraith> laziness and purity, that is
07:27:18 <c_wraith> And while that's not nearly as strong as "this value will never be mutated"
07:27:18 <c_wraith> It does give additional power over "mutated N times"
07:27:25 <ggole> OCaml, V8, the JVMs, I'm sure there are more I'm not familiar with
07:28:01 <ggole> (OCaml's current collector is single threaded, though.)
07:31:31 <[k-> this page? https://ghc.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
07:31:42 <ongy> u
07:31:48 <[k-> or is it the RTS
07:32:44 <Insanity_> seems to be a specific implementation notes [k-
07:32:45 * hackagebot constraint-classes 0.3.0 - Prelude classes using ConstraintKinds  https://hackage.haskell.org/package/constraint-classes-0.3.0 (guaraqe)
07:32:51 <Insanity_> "but one that will stop all the user threads and run multiple GC threads during the garbage collection process." 
07:33:08 <Insanity_> is the GC normally a STW? 
07:35:41 <hpc> iirc it's no longer totally STW, though it does still stop it sometimes
07:36:07 <[k-> this *was* 10 years ago
07:36:07 <ongy> STW?
07:36:13 <Insanity_> stop-the-world
07:36:43 <Insanity_> https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent
07:37:12 <[k-> I think JVM's ParallelGC is concurrent?
07:37:20 <[k-> My memory sucks 
07:37:50 <ggole> Parallel and concurrent mean different things in the GC world
07:38:10 <ggole> IIRC, parallel means that more than one thread works on the heap at the same time
07:38:11 <hpc> [k-: i remember the jvm having the only fully concurrent gc as well
07:38:16 <hpc> though not by default?
07:38:25 <ggole> And concurrent means that collection proceeds at the same time as the mutator threads
07:38:32 <Insanity_> There are a few other JVMs that might offer that hpc
07:38:47 <Insanity_> Azul JVM or something iirc 
07:38:56 <ggole> You might be thinking of Zing, Azul's thing
07:39:00 <[k-> I think it could be an experimental flag
07:39:09 <Insanity_> ggole that's the one I was thinking of :-)
07:39:13 <ggole> Although I think there are some research efforts on Jikes RVM
07:39:18 <[k-> it was on /r/programming a week ago
07:39:26 <[k-> (or two)
07:40:26 <[k-> there's hardly anything on the gc commentary
07:42:10 <ongy> [k-: there's https://wiki.haskell.org/GHC/Memory_Management but the linked paper is also 8 years old
07:42:42 <[k-> Thanks!
07:42:56 <ggole> http://simonmar.github.io/bib/parallel-gc-08_abstract.html might be more interesting
07:43:10 <hpc> ah, also https://ghc.haskell.org/trac/ghc/blog/new-gc-preview
07:43:14 <ongy> ggole: I think that's the paper linked
07:43:42 <hpc> which is from 2010 and mentions that the "young" collection is concurrent
07:44:18 <ggole> And it mentions making use of the once-mutated property: so there is a useful and (more or less) Haskell specific trick
07:46:04 <[k-> nooo, chrome likes to replace my current tabs with newly opened links 
07:49:32 <Insanity_> O.o
07:50:57 <[k-> I click on one link and it opens it, I click on another link and it replaces it!
07:51:26 <Forlorn>     f = [ x | x <- d 0, not (any (\z -> x `rem` z == 0) (d a)) ]
07:51:38 <Forlorn> ambigious type variable `t0` arising from use of `any`
07:51:56 <Forlorn> why?
07:52:26 <sullyj3> So, I'm learning interpreters and haskell at the same time. Does anyone have any comments on the beginning of my lexer http://lpaste.net/193278 before I implement the rest of it similarly?
07:53:03 <merijn> sullyj3: tbh, the real solution would be using something like megaparsec to write your parser, rather than writing a lexer like this
07:53:09 <merijn> sullyj3: It'll both be easier and faster :)
07:53:18 <tsahyt> okay I've finally got a version of this palindrome thing that is sufficiently fast AND uses little memory
07:53:25 <tsahyt> but it requires use of ST, and I wonder why that is
07:53:27 <sullyj3> merijn: Yeah, but I'm learning how they work.
07:53:45 <[k-> :t rem
07:53:47 <lambdabot> Integral a => a -> a -> a
07:53:49 <tsahyt> http://lpaste.net/7409354150841942016
07:54:03 <Forlorn> sullyj3, perhaps you can get some additional insight from here: http://dev.stephendiehl.com/fun/002_parsers.html
07:54:05 <[k-> hm, it doesn't seem ambiguous 
07:54:10 <tsahyt> here's the code. why does the maximumBy/unfoldr construct not compile to something equivalent to what I've handrolled with ST?
07:54:39 <tsahyt> on an unrelated note the ST code could probably be made prettier, but I just wanted to check my hypothesis quickly
07:55:03 <Forlorn> [k-, http://sprunge.us/RPKL
07:55:04 <merijn> tsahyt: I don't understand the question. Are you confused by what ST does or...?
07:55:07 <Forlorn> perhaps it is arising from somewhere else?
07:55:15 <tsahyt> merijn: I'm confused why the idiomatic version blows up my heap
07:55:38 <tsahyt> shouldn't fusion prevent this here?
07:55:47 <sullyj3> It bugs me that I'm doing a takewhile and dropwhile on the same list with the same predicate. It feels like it's doing twice the work it needs to. I know its a miniscule performance hit but it bugs me aesthetically. Is there any way to fix that?
07:56:05 <merijn> tsahyt: Are you sure fusion triggers?
07:56:12 <sullyj3> in an imperative language i could loop til non idigit and just store the index
07:56:16 <lyxia> :t break -- sullyj3 
07:56:18 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
07:56:22 <tsahyt> merijn: it should, I'm compiling with optimizations on
07:56:23 <tsahyt> but let me check
07:56:36 <merijn> tsahyt: It's quite hard to tell what your code is doing for me
07:56:48 <tsahyt> merijn: finding the longest palindrome in a string
07:56:50 <sullyj3> Forlorn: Thanks.
07:56:53 <[k-> Forlorn: shouldn't primes2 take an argument?
07:56:57 <merijn> tsahyt: Because there's almost no types for the smaller expressions
07:57:02 <tsahyt> this is the like 5th version or so, it's becoming less clear on every iteration
07:57:02 <merijn> tsahyt: Yeah, I get that :p
07:57:12 <Forlorn> [k-, nope, it is an infinite list
07:57:20 <sullyj3> lyxia: Perfect. Thankyou.
07:57:24 <tsahyt> the naive versions were nice to read but hopelessly slow. this is the first one (with the ST thing) that can compete with C in terms of performance
07:57:29 <sullyj3> Probably should've hoogled it
07:57:31 <Forlorn> [k-, the list of all primes
07:57:40 <merijn> tsahyt: But, like, line 46 it's not clear which Functor until I look up what next is
07:57:56 <tsahyt> merijn: well that or the type signature of unfoldr
07:58:13 <merijn> tsahyt: Or, like, what "slice" is
07:58:33 <tsahyt> slice takes a slice out of a bytestring in allegedly O(1) time
07:58:34 <merijn> tsahyt: Yeah, but that's more mental effort than I usually invest in lpastes :p
07:58:43 <[k-> Forlorn where does the argument to a come from?
07:58:47 <tsahyt> point taken, I'll add more types into my where clauses
07:59:20 <[k-> you called d a which should have been a list right? but a is a function
07:59:48 <tsahyt> hmm. when using stack, --ghc-options=-ddump-rule-rewrites *should* display the rewrites, right?
07:59:51 <tsahyt> because it doesn't.
08:00:08 <Forlorn> [k-, ah, that seems to have been the problem, I forgot to apply the argument to `a`
08:00:17 <ertes> tsahyt: the algorithm we discussed yesterday should be fast and use constant memory (it would just share the argument string)…  also your use of ST is pointless and most likely only hurts performance
08:00:22 <Forlorn> [k-, ty
08:00:27 <[k-> tsahyt, it's something with stack, it's somewhere in . stack_work
08:00:34 <[k-> Forlorn: welcome :)
08:00:37 <tsahyt> ertes: it absolutely does not hurt performance. it's the one thing that actually worked in making this fast
08:00:55 <tsahyt> I've got an implementation of what we discussed yesterday and it doesn't even finish within 10 minutes on an input that this here can do in less than 3 seconds
08:01:00 <ertes> tsahyt: you can implement the same thing using recursion instead of mutable variables and get a faster result
08:01:11 <Forlorn> [k-, still getting the same error when applying the argument though
08:01:25 <tsahyt> ertes: I just opted for ST to check whether the maximumBy/unfoldr construct really was what's causing this incredible buildup
08:01:36 <Forlorn> [k-,     f = [ x | x <- d 0, not (any (\z -> x `mod` z == 0) (d (a x))) ]
08:02:28 <ertes> tsahyt: STRef is really an almost pointless abstraction…  IORef can make sense from time to time, if you have highly non-local or even concurrency-related needs, but whenever you use STRef, i assure you that simple recursion is going to perform better
08:03:08 <tsahyt> ertes: I'm going to try this. I'd prefer it too, but at least I've finally got a version that is actually roughly as fast as the C implementation
08:03:14 <Forlorn> http://sprunge.us/cYZA
08:03:15 <[k-> tip: instead of `not any ==` use `all /=`
08:03:19 <Forlorn> here's my full error log
08:04:38 <ertes> tsahyt: the trick to get this code fast is to make sure you use sharing…  fusion won't help you; in fact ByteString doesn't fuse at all (unlike Text and Vector), and even if it would, it would not help you here
08:05:04 <[k-> Forlorn: it seems that ghc needs a type annotation because it can't infer what (d (a x)) should be, I think
08:05:19 <tsahyt> ertes: the problem is not the slicing. or the bytestring.
08:05:40 <[k-> Forlorn: somehow it doesn't know 
08:05:59 <Forlorn> ah
08:06:05 <Forlorn> perhaps make a separate function
08:08:10 <[k-> or (d (a x) :: [Integer])
08:08:19 <tsahyt> ertes: I've now tried explicit recursion. it is indeed marginally faster and has good memory usage characterstics
08:09:10 <tsahyt> I've updated the code http://lpaste.net/7409354150841942016
08:10:03 <tsahyt> this could definitely be golfed somehow without losing performance. But I'm still no wiser as to why explicit recursion (or ST for that matter) performs so much better than the more idiomatic version
08:10:19 <ertes> tsahyt: also i suggest slicing instead of keeping start/end indices:  note that functions like 'drop', 'splitAt', 'take' are all O(1) and do not allocate extra memory for the actual slice
08:10:31 <ertes> tsahyt: in other words you probably don't need BSPos either
08:11:03 <ongy> ertes: they are? how?
08:11:06 <tsahyt> ertes: but I am slicing. I don't create new strings anywhere anymore as far as I can tell.
08:11:53 <tsahyt> I walk the string in order to determine *where* I need to slice though
08:12:04 <ertes> ongy: ByteString uses memory sharing, so slicing (per se) is cheap
08:12:20 <ongy> ohh, on ByteString, I missed that
08:12:28 <tsahyt> now I have attempted doing this using zip and takeWhile like in the original zipper version but it performed a bit worse
08:12:34 <ertes> tsahyt: oh, i just saw the unsafeDrop
08:13:05 <tsahyt> ertes: I could have used the safe versions, but since I have the checks in place I thought I might as well go for unsafe
08:13:34 <ertes> yeah, although i suggest that you try the safe versions, too…  very often they don't even make a difference
08:13:47 <tsahyt> ertes: iirc they didn't
08:14:17 <tsahyt> well they do. but it's a very small difference indeed
08:15:57 <ertes> tsahyt: let's see if i got the algorithm right: search "axyxb" from the back, find that the longest palindrome is "a", drop 1, search "xyxb" from the back, find that "xyx" is the longest palindrome, etc.
08:16:03 <ertes> tsahyt: is that accurate?
08:16:46 <tsahyt> I walk the entire string. For each element I start searching outwards and stop until the two equidistant characters to it stop matching.
08:16:58 <shapr> I could walk 500 strings ...
08:17:00 <shapr> ok, nm
08:17:15 <tsahyt> and then there's the even length case to handle which works roughly similar although around a different symmetry point
08:17:26 <ertes> ah
08:17:35 <tsahyt> so for each element in the string I check for an odd length palindrome with this element in the center, and an even one. I remember the longer one and move on
08:17:52 <tsahyt> well I only remember it when it was indeed the best one yet, which is now made explicit through the recursion
08:18:08 <ertes> yeah, now i see why this variant is faster than the tails/inits variant:  it has better memory locality
08:19:00 <tsahyt> the tails/inits variant is also O(n^3) I think. It considers every pair of start-end points for a palindrome and then needs to check each of these, which is in the worst case O(n) itself. so we get O(n^3) altogether 
08:19:24 <tsahyt> this one should be O(n^2) in the worst case, as for each center point I walk up to n elements away from it during my checks
08:19:56 <ertes> true
08:21:07 <tsahyt> hmm. how inconvenient. I just realized that the C version is still 10x faster
08:22:04 <[k-> i like how you treat it as an inconvenience
08:22:16 <tsahyt> well this is still pretty fast
08:22:29 <tsahyt> 1.7s on a 100 million element string
08:23:01 <[k-> damn, my grid is slow then
08:23:28 <ertes> tsahyt: do you have the C version online?  i'd like to give it a try
08:23:34 <tsahyt> it's not my code
08:23:57 <tsahyt> it was written by someone in another channel who asked me to write a comparable haskell version. unfortunately I accepted the challenge
08:24:08 <ertes> i'm pretty sure i can match it or at least get very close to it in haskell
08:24:14 <tsahyt> I'll put it on lpaste
08:24:28 <prsteele> (jumping in mid-conversation) have you tried using e.g. the ST monad?
08:24:39 <tsahyt> ertes: http://lpaste.net/77250626110619648
08:24:52 <tsahyt> ertes: I'd love to hear about the results
08:25:21 <tsahyt> prsteele: for a part of it yes, but explicit recursion turned out to be slightly faster
08:25:54 <prsteele> interesting
08:26:09 <[k-> ertes: tsahyt: please @tell me the results! I have to go to bed now 
08:26:37 <tsahyt> [k-: my work here is done, I don't think I can get this particular version any faster.
08:27:09 <[k-> I'm sure you would be interested in how fast ertes's implementation would be
08:28:14 <[k-> this is exciting. but alas, the bed calls for me
08:32:05 <ertes> tsahyt: were you comparing the C code's timing output to the output of 'time' for your own program?
08:32:46 * hackagebot servant-github-webhook 0.2.0.1 - Servant combinators to facilitate writing GitHub webhooks.  https://hackage.haskell.org/package/servant-github-webhook-0.2.0.1 (tsani)
08:32:58 <tsahyt> ertes: I was comparing it to the -s stats printed by the runtime
08:33:31 <ertes> tsahyt: one thing to note is that it gives the C code an advantage, as it doesn't time its I/O
08:33:57 <ertes> i'll use the 'clock' package for timing
08:34:23 <ertes> (normally i'd use criterion, but then again it becomes difficult to compare to the C version)
08:34:42 <prsteele> why not just `time` each of them?
08:35:47 <ertes> prsteele: i'm going to do both:  'time' both and 'clock'/'time.h' them to compare the bare algorithm
08:35:55 <prsteele> cool
08:35:59 <tsahyt> ertes: are you going to use the same algorithm?
08:36:20 <ertes> tsahyt: yeah
08:36:36 <tsahyt> one thing to note btw is that I have used random strings to benchmark this. the algorithm performs well on these. if you put in a huge palindrome to start with it will perform very badly
08:37:15 <tsahyt> I've used the following to generate those strings: < /dev/urandom tr -c "[:alnum:]" | head -c10000000 > string.txt
08:40:51 <Forlorn> tsahyt, make a condition for palindromes
08:41:09 <sullyj3> given `data Token = INTEGER Int | PLUS | MINUS`, is it possible to define a type called Op that is either a PLUS Token or MINUS Token?
08:42:09 <prsteele> sullyj3: no, the constructor would have to take a Token and would need to do something with the INTEGER case
08:42:12 <glguy> sullyj3: If you had:  data Op = PLUS | MINUS, you could have: data Token = INTEGER Int | OP Op
08:42:13 <geekosaur> sullyj3, no. usually I'd refactor that to data Token = INTEGER Int | OP Op; data Op = PLUS | MINUS
08:42:16 <sullyj3> ideally functions of Tokens would accept Ops, but functions of Ops would not accept Tokens
08:42:45 <geekosaur> the things on the right hand side of the = in a data declaration are data constructors, not type constructors
08:43:49 <sullyj3> Thanks guys.
08:44:13 <sullyj3> geekosaur: I'm not really clear on the difference, I haven't learnt about the type keyword yet
08:44:29 <geekosaur> this isn;t related to the type keyword
08:44:36 <sullyj3> oh.
08:44:59 <sullyj3> Well, anyway, I don't know what you mean.
08:45:29 <prsteele> data Foo a = MkFoo a; Foo is a type constructor, MkFoo is a data constructor
08:45:39 <ertes> tsahyt: i'm using this command: base64 -w0 < /dev/urandom | tr -cd 'a-c' | pv -Ss 10M >| palindrome.txt
08:45:54 <geekosaur> data Maybe a = Nothing | Just a -- Just is a data constructor, it can be used as a value. Maybe is a type constructor, it can be used as a type. (in both of those cases you generally apply it to something, e.g. Maybe Int, Just 3)
08:46:05 <ertes> tsahyt: (the pv command is like 'head', but with a progress meter)
08:46:26 <tsahyt> ertes: I'll generate one of these myself for comparison
08:46:57 <Valoo> hi
08:47:07 <lambdabot> Hello.
08:48:04 <Valoo> I am trying to program the euclidian division but I can't get it to work
08:48:14 <Valoo> here is my code: http://lpaste.net/2200889663655247872, can anyone help?
08:48:34 <sullyj3> geekosaur: So by "it can be used as a value", you can create a Maybe that is a Just without an a? Or am I misunderstanding.
08:48:40 <prsteele> Valoo: euc (b - a) a
08:49:03 <geekosaur> you can use Just as a value; it behaves as a function.
08:49:10 <geekosaur> > map Just [1,3,5]
08:49:10 <Valoo> thanks prsteele
08:49:12 <lambdabot>  [Just 1,Just 3,Just 5]
08:50:08 <glguy> sullyj3: The division is between types and values,   Maybe is a type,   Just and Nothing are values.  You make types with type constructors and values with data constructors.
08:50:35 <prsteele> Valoo: function application has the highest precedence
08:51:00 <prsteele> Valoo: so it was being interpretted as (euc b) - a a
08:53:30 <sullyj3> I think I get it.
08:53:34 <sullyj3> cheers.
08:56:06 <sullyj3> Man this language is the best thing I've ever found at making me feel slow haha
08:56:47 <prsteele> keep with it, it takes some getting used to if you come from almost any other language but the payoff is worth it
08:58:24 <schell> sullyj3: it really does have a big payoff in productivity, IMO
08:59:23 <Boomerang> All the time you spend making your code type check is time you don't have to spend debugging it later on
08:59:48 <sullyj3> prsteele, schell: I just love how pretty everything is
08:59:52 <sullyj3> if that makes sense.
09:00:09 <schell> it does
09:00:49 <schell> there’s enough flexibility in the syntax (by using infix, flow control left or right) that you can make lots of code almost read like english
09:00:53 <sullyj3> Everything fits together like a jigsaw, and the perfect abstraction for the problem is always lurking somewhere in the standard library
09:01:09 <schell> :)
09:08:16 <Forlorn> argghh
09:08:32 <Forlorn> why does my function get stuck?
09:08:33 <Forlorn> http://sprunge.us/ZjWW
09:08:48 <Forlorn> the same one from before `prime2`
09:08:54 <Forlorn> primes*
09:09:47 <merijn> Forlorn: Because your list comprehension is infinite
09:09:49 <schell> it looks like x goes on forever
09:09:54 <merijn> Forlorn: Therefore your "any" is also infinite
09:10:29 <Forlorn> hold on
09:10:35 <Forlorn> my any shouldn't be infinite
09:10:37 <schell> you may want “take n” instead of the “y < n” filter
09:10:48 <Forlorn> ah
09:10:50 <schell> i may be rusty with my list comps tho
09:11:30 <Boomerang> you can also use takeWhile
09:11:31 <merijn> Forlorn: "y < n" is equivalent to filter. it keeps trying. The compiler doesn't magically know future entries will always be bigger
09:11:38 <Forlorn> I see
09:12:07 <schell> (thumbsup)
09:14:24 * Welkin throws dmj a pancake
09:15:50 <Forlorn> omg!
09:15:52 <Forlorn> it's so fast!
09:15:58 <Forlorn> thank you guys!
09:16:30 <schell> sweet :)
09:27:26 <tsahyt> is there a good tutorial anywhere on how to read ghc core output?
09:31:10 <sullyj3> so I'm having trouble translating this simple parser from python. http://lpaste.net/193422 It's barebones, it just adds and subtract numbers. What I have in haskell so far: http://lpaste.net/193426
09:31:20 <sm> @google "how to read ghc core output"
09:31:21 <lambdabot> No Result Found.
09:31:34 <sm> @google how to read ghc core output ?
09:31:35 <lambdabot> http://stackoverflow.com/questions/6121146/reading-ghc-core
09:31:35 <lambdabot> Title: performance - Reading GHC Core - Stack Overflow
09:31:35 <sullyj3> I'm assuming I need some sort of fold?
09:31:50 <tsahyt> sullyj3: why not just use a parser combinator library?
09:32:05 <tsahyt> if you don't want to pull in any dependencies there's even a minimal one in base
09:32:47 <sm> or: http://www.haskellforall.com/2012/10/hello-core.html
09:32:47 * hackagebot cayley-client 0.2.0.0 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.2.0.0 (MichelBoucey)
09:33:14 <tsahyt> sm: thanks!
09:33:59 <sullyj3> tsahyt: Because I'm working through https://ruslanspivak.com/lsbasi-part3/ and one of the exercises is to reimplement the super basic python one in a different language
09:34:54 <sullyj3> Presumably using libraries is against the spirit of understanding how it all works
09:35:05 <tsahyt> sullyj3: this does not state that you must not use parser combinators though, and as I said we have one in base too
09:35:06 <Welkin> sullyj3: use parsec to write a DSL, or an interpreter
09:35:12 <Welkin> there is even a guide on how to do it
09:35:14 <tsahyt> relevant http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-ParserCombinators-ReadP.html
09:35:45 <Welkin> *not* using parser combinators is just stupid
09:35:51 <Welkin> what are you going to use instead? regex?
09:36:01 <sullyj3> I'm having enough difficulty understanding how the python version works. I don't even know what a combinator is. It sounds advanced and way beyond the scope of what I'm trying to do.
09:36:13 <Welkin> sullyj3: a combinator is just a ninfix function
09:36:15 <tsahyt> sullyj3: it's very common in haskell to use parser combinators, because of how easy it is
09:36:16 <Welkin> infix*
09:36:21 <sullyj3> It's only stuff like "1 + 2 + 3 - 1"
09:36:26 <tsahyt> it often gets used even instead of regexes
09:36:40 <sullyj3> this problem is too simple for regex
09:36:50 <tsahyt> does it allow parentheses?
09:36:53 <sullyj3> nope
09:36:53 <Welkin> regex is too complicated for anything
09:36:55 <Welkin> you mean
09:37:51 <sullyj3> the logic is just stuff like "an operation must be followed by a number.
09:38:47 <Boomerang> sullyj3: remove the second "INTEGER" in the 2nd and 3rd partial functions for expr and then call recursively
09:39:19 <Boomerang> expr (INTEGER a:PLUS:ts) = a + expr ts
09:40:04 <sullyj3> Oh ffs. Of course
09:40:09 <sullyj3> Boomerang: Thanks heaps
09:40:11 <Boomerang> :)
09:42:15 <joe9> I want to do this: {-# OPTIONS_GHC -hide-package OpenGLRaw #-}
09:42:19 <joe9> Is that possible?
09:42:37 <joe9> message http://bpaste.net/show/0fd5fd83fb63
09:42:46 <joe9> is there an alternative to doing that.
09:43:06 <geekosaur> ghc8 manual says it's dynamic
09:43:07 <Boomerang> Isn't it GHC_OPTIONS ? Can't rememver
09:43:13 <geekosaur> it's OPTIONS_GHC
09:43:22 <Boomerang> ok
09:43:23 <glguy> joe9: This is what the .cabal file is for
09:44:09 <Exordian> ohai, i'm searching for the "best" way to handle state for an interactive console editor ; i've a lot of stateless parts, but some parts have to be stateful (which file is loaded, which mode i'm in - cmd vs insert, where is my curser) ; there seems to be multiple ways to manage state in haskell, unfortunately i don't can look into all of them, can you recommend something to start with?
09:44:54 <joe9> glguy: I have it in the cabal file, but, ghci is not reading the cabal file.
09:45:06 <Exordian> or is there a comparsion somewhere, i haven't found yet?
09:45:08 <glguy> joe9: You can use "cabal repl" to load your library into GHCi with the correct flags
09:45:09 <joe9> glguy: http://bpaste.net/show/909325192257
09:45:21 <joe9> glguy: makes sense. Thanks.
09:45:24 <mheinzel> Boomerang: But it doesn't work the same way for the MINUS case, right? You would subtract the whole following expression.
09:46:05 <mheinzel> 3 - (3 + 3 - 2) instead of 3 - 3 + 3 - 2
09:46:24 <Boomerang> mheinzel: yes you're right, there was no minus case in the example, maybe the minus can be translated to a plus by change the next integer?
09:46:34 <Boomerang> *changing
09:47:17 <mheinzel> Instead of handling the tokens like this: (3 +) (2 -) (1), maybe group them this way: (3) (+ 2) (- 1)
09:47:19 <mheinzel> ?
09:47:27 <Boomerang> +1
09:47:54 <mheinzel> expr (INTEGER i : _) = ...
09:48:18 <mheinzel> expr (PLUS : INTEGER i : ts) = ...
09:48:34 <ertes> tsahyt: C version (compiled with -O2) takes about 0.20 secs on this machine on average, my haskell version takes 0.28 on average
09:48:40 <joe9> glguy: as an fyi, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Packages/PackageImportsProposal this seems to work : import "gl" Graphis.GL
09:48:50 <tsahyt> ertes: that's amazing. so what did you do to make it so fast?
09:49:16 <ertes> tsahyt: what is really slow on the haskell side is the I/O…  B.readFile takes most of the time, most likely because it doesn't use the seeking trick the C version uses
09:49:29 <ertes> tsahyt: i didn't bother replicating that in haskell, as it's easy enough to do when needed
09:49:46 <tsahyt> ertes: I've switched to using mmap but other than better memory stats it didn't do much
09:49:56 <ertes> tsahyt: hang on, i'll squeeze out a bit more performance, then i'll push
09:50:28 <sullyj3> Boomerang: Hang on, I've just realised that's right associative, which isn't what I want
09:50:42 <Boomerang> do what mheinzel suggested
09:51:00 <tsahyt> ertes: how did you determine that IO is the bottleneck? I've done a profiling build but readFile doesn't even show up
09:51:00 <Forlorn> has anyone bought the haskellbook?
09:51:13 <mheinzel> As long as there is only + and - without parentheses, it works.
09:51:21 <Boomerang> How are you going to handle EOF as an int though?
09:51:44 <sullyj3> Yeah, the EOF was cargo culting on my part I got rid of it
09:52:02 <sullyj3> mheinzel: the ... might be obvious to you but it's not to me haha
09:52:33 <mheinzel> sullyj3: We can figure it out together ;)
09:52:57 <mheinzel> sullyj3: And yeah, EOF is unnecessary.
09:53:02 <sullyj3> in case expr (INTEGER i : _) = ..., we can't do any adding or subtracting without knowing what comes next
09:53:48 <mheinzel> This case should only occur once: Right in the beginning.
09:53:58 <ertes> tsahyt: by benchmarking the algorithm explicitly (using 'clock') and finding that the overall program needs much longer that that =)
09:54:02 <sullyj3> sure
09:54:32 <mheinzel> And we definitely need the rest. If you man this, you are right.
09:54:45 <mheinzel> So (INTEGER i : ts)
09:54:49 <Boomerang> If you're just going to be using PLUS and MINUS you could do expr (INTEGER i : ts) = i + expr ts; expr (PLUS : INTEGER i : ts) = i + expr ts; expr (MINUS : INTEGER i : ts) = (-i) + expr ts; expr [] = 0
09:54:58 <Boomerang> *only PLUS and MINUS
09:55:52 <mheinzel> Boomerang: Yes, this is where I was going.
09:56:10 <Boomerang> But if you want more operation like * and / you'll probably want to extend your Tokens to have more of a tree structure
09:56:25 <sullyj3> Yeah, I'm sure I'll learn about trees later.
09:56:42 <Boomerang> sorry translate your Tokens into an AST before evaluating it
09:57:24 <mheinzel> Boomerang: Sure. As soon as operators with different precedence are used, you need something more sophisticated
09:57:50 <tsahyt> ertes: can I even be sure that the file has been read completely after the call to readFile? I thought lazy IO might become a problem here
09:58:46 <sullyj3> Thanks Boomerang mheinzel
09:59:11 <Boomerang> ood luck with your parsing/evaluating!
09:59:15 <Boomerang> *Good
09:59:54 <ertes> tsahyt: https://github.com/esoeylemez/snippets/blob/master/longest-palindrome-hs.hs
10:00:17 <ertes> tsahyt: yeah, you can be sure in the case of ByteString, even if you read into a lazy ByteString
10:00:36 <ertes> tsahyt: compiled with -O
10:01:24 <sullyj3> Thanks. I feel like the different grouping is a good solution, I'm having trouble understanding why I had difficulty creating one that more directly captured the spirit of the python implementation http://lpaste.net/193422
10:01:57 <tsahyt> ertes: as far as I can tell this still just uses B.readFile though? So how did you speed up the IO process?
10:02:06 <ertes> someone wanted me to @tell them…  could someone please tell me who that was?  backlog is gone
10:02:20 <tsahyt> ertes: [k- I think
10:02:22 <sullyj3> Which looks to me like a fold
10:02:35 <ertes> tsahyt: i didn't…  i just didn't include it in the benchmark, exactly like in the C version
10:02:42 <tsahyt> ertes: ah okay
10:03:12 <ertes> tsahyt: you can use fstat or seeking together with an explicitly allocated Ptr to perform the same trick
10:03:14 <tsahyt> I'll try using clock on my implementation to see how this compares
10:05:47 <ertes> @tell [k- you asked me to notify you about the palindrome algorithm…  the C version (GCC/-O2) is faster by a facter of about 1.4 compared to this haskell version (GHC/-O): https://github.com/esoeylemez/snippets/blob/master/longest-palindrome-hs.hs
10:05:47 <lambdabot> Consider it noted.
10:06:01 <tsahyt> wow, IO really does take a long time
10:06:59 <tsahyt> on my test data I achieve 0.1826s according to the C measurements, 0.1752s according with my Haskell version using clock measurements
10:07:11 <tsahyt> but about 1.7s wallclock for the Haskell version
10:07:18 <Forlorn> does Criterion benchmark even work?
10:07:33 <tsahyt> Forlorn: criterion is excellent, but I don't think it's well suited for this comparison
10:07:49 <ertes> tsahyt: there you go =)
10:08:06 <tsahyt> ertes: Now I'm tempted to implement this seeking trick
10:08:16 <Forlorn> I have counted manually and i have a test that takes around 20 seconds while the other takes 2-3 seconds but once in Critereon they both take 20 - 21 micro seconds
10:08:29 <ertes> tsahyt: it's horrible to implement, but should make this faster than the C version overall
10:08:47 <ertes> oh, wait
10:09:01 <Forlorn> here's a small snippet of the Criterion benchmark code
10:09:01 <tsahyt> ertes: although I do like the mmap version right now. it's nice to see that my algorithm uses virtually no memory on its own
10:09:02 <Forlorn> http://sprunge.us/hBSd
10:10:07 <brucey> hey, does this work?
10:10:17 <tsahyt> brucey: yes
10:10:23 <glguy> Forlorn: depending on what primes type is it's probably only being computed once
10:10:23 <brucey> oooh, thanks
10:10:36 <glguy> Forlorn: and then after that you're just benchmarking list indexing
10:11:37 <Forlorn> oh, I was testing in GHCI manually perhaps it doesn't index then?
10:12:17 <ertes> tsahyt: BTW, not sure why, but maximumBy performed terribly for me…  i don't know how it's implemented, but it's the reason i used foldl'
10:12:49 <glguy> Forlorn: No, the issues is that primes is a top-level list that stays computed once forced, so the first time it will be slow and all subsequent uses will be fast
10:12:53 <tsahyt> ertes: I noticed the same thing. That was actually my original question today. Explicit recursion did just fine.
10:13:10 <twice> hi guys, what's wrong with this code? http://lpaste.net/193447 
10:13:43 <mheinzel> sullyj3: A fold would only take one token at a time, but we need two here. However, you could make expr tail-recursive with an accumulator. Maybe that comes a bit closer...
10:13:44 <glguy> twice: You're supposed to tell us
10:14:22 <ertes> i would have expected it to be a strict left-fold, but apparently that's wrong
10:14:45 <ertes> > maximumBy compare (cycle [1,2,3])
10:14:47 <lambdabot>  *Exception: stack overflow
10:14:54 <tsahyt> ertes: it's implemented in terms of foldr1
10:15:02 <Forlorn> glguy, `primes2` and `primes` uses two different approaches to find the primes
10:15:07 <tsahyt> which *should* fuse as far as I understand
10:15:29 <geekosaur> twice, I see code. I do not see any indication of what problem you might have with it. if you got a compiler error, please include the full error message. if you got an incorrect result, please provide the result you got vs. what you expected
10:15:41 <glguy> Forlorn: That makes sense, the issue is that you aren't benchmarking the computation of them with criteron, you're benchmarking list indexing
10:15:55 <Forlorn> isn't there anything I can do to benchmark them instead of the list indexing?
10:16:14 <twice_> i'm getting this error http://lpaste.net/193463
10:16:25 <ertes> tsahyt: that's odd
10:16:29 <geekosaur> (hlint doesn't think much of it, mostly because of all the extra parentheses --- I feel like you're trying to force something like the way other languages handle function arguments)
10:17:00 <geekosaur>       from the context: (Integral t, Floating t)
10:17:06 <ertes> tsahyt: but i'm not going to question it…  i found that it's best not to trust any of the predefined folds except the lazy ones
10:17:42 <ertes> perhaps it's time for a Strict-Left-Folds-Proposal
10:18:02 <glguy> Forlorn: You'll need to "trick" the compiler into generating the list again. One way to do that is to have a function return the list of primes rater than to define them as a top-level list
10:18:06 <geekosaur> twice_, Haskell does not automatically convert numeric values. you are using `mod` and `div` which require an Integral constraint, and `sqrt` which requires a Floating constraint, and no numeric type has both.
10:19:00 <Forlorn> glguy, I'll try that, thanks
10:19:57 <geekosaur> for `div` you can use `/`; `mod` is harder but there's a floating point variant in https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/Data-Fixed.html#v:mod-39-
10:20:33 <twice_> geekosaur: thnx I need integers
10:20:45 <geekosaur> ...but you use sqry
10:20:47 <geekosaur> sqrt
10:21:22 <twice_> so I need to cast toInt(sqrt(toFloat(n)))
10:21:42 <prsteele> twice_: floor, round, ceiling
10:21:43 <geekosaur> you might be able to do something like: floor (sqrt (fromIntegral n))
10:22:00 <Forlorn> glguy, so I tried `take n primes` instead, hopefully that's what you meant, but it is still not working
10:22:12 <glguy> Forlorn: Is primes still a top-level definition?
10:22:44 <Forlorn> glguy, ah, ok, sorry, I misunderstood the top-level thing, yeah it is
10:23:04 <mheinzel> sullyj3: http://lpaste.net/193506, how do you like this one with an accumulator?
10:26:09 <twice_> geekosaur: I just fixed the lines with sqrt and it's compiled, so it's no need to do casting on div and mod
10:26:16 <twice_> ?
10:26:42 <Forlorn> glguy, hm, but parts of the prime functions will be top-level
10:26:58 <geekosaur> yes, you;d do either one or the other
10:27:04 <glguy> Forlorn: You can have top-level functions
10:27:37 <glguy> Forlorn: The issue is top-level monomorphic non-function values, this is the topic http://stackoverflow.com/questions/6090932/how-to-make-a-caf-not-a-caf-in-haskell
10:28:13 <geekosaur> either you would use floating point alternatives to div and mod, or convert around sqrt so it is compatible with integer math
10:28:27 <geekosaur> not both, that;d just get you the same problem in reverse >.>
10:29:04 <twice_> :D
10:30:00 <interzeller> hi all, I'm looking for an open source project to contribute to (intro level beginner)
10:30:05 <interzeller> I'm fairly versed in theory but otherwise inexperienced with open source
10:30:13 <interzeller> does anyone know a welcoming project/task to contribute to?
10:30:49 <glguy> interzeller: The best projects to contribute to are the ones you use
10:32:19 <interzeller> glguy: I don't use haskell day to day, but I'll can pay attention to what libraries tutorials use
10:32:56 <glguy> interzeller: In that case a first step would be to use Haskell for something for yourself
10:34:45 <interzeller> glguy: I've written a lambda calc interpreter, (I've gotten a suggestion to use catamorphisms but I'm struggling to apply them when Expr -> Expr)
10:34:55 <interzeller> glguy: http://codereview.stackexchange.com/questions/139752/lambda-calculus-interpreter-in-haskell
10:35:12 <Forlorn> glguy, if I put it in a where clause is still a top-level function?
10:35:34 <Forlorn> glguy, http://sprunge.us/POaG
10:36:06 <glguy> Forlorn: I'd expect that to work better.
10:36:14 <glguy> Forlorn: but
10:36:19 <Forlorn> but... it doesn't.
10:36:20 <Forlorn> :D
10:36:28 <glguy> now you're testing how long it takes to make the first element of the list
10:37:05 <prsteele> could you just do something like sum the list? or find the maximum element?
10:37:09 <glguy> whnf specifies that you're interested in how long until you know the outermost constructor
10:37:22 <glguy> which for a list is the first (:)
10:37:28 <Forlorn> ah
10:37:48 <glguy> nf would evaluate the whole list
10:38:14 <tsahyt> why does the unix package seemingly not provide a function that reads from a Fd to a ByteString, even though it has ByteString versions to open a Fd
10:38:57 <Forlorn> glguy, what about the last item?
10:39:16 <geekosaur> because it's not about reading ByteStrings. it is about the normal path functions being incorrect on POSIX because pathnames are ByteStrings, not utf-8
10:39:23 <glguy> Forlorn: sure, another way to force the list would be to force the last time in the list
10:39:25 <Forlorn> or if I tested for the last item, would it try to optimize and cheat and give me inaccurate results?
10:40:03 <glguy> Forlorn: I imagine it's going to be difficult to compute the 10000th prime number without computing the ones before it
10:40:34 <koala_man> tsahyt: did you find this one?  https://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-IO-ByteString.html#v:fdRead
10:40:47 <koala_man> wait
10:40:47 <tsahyt> koala_man: yes but it returns a string, not a bytestring
10:40:57 <geekosaur> and as far as I know duplivating opening an fd was just to maintain the same API as the normal one
10:40:58 <Forlorn> glguy, but how could it have done that before? Did it find it perhaps during the compilation process?
10:41:08 <tsahyt> I can read it into a Ptr and then build a bytestring from that I suppose
10:41:10 <koala_man> god, I read ByteString and not ByteCount
10:41:27 <glguy> Forlorn: Before it was computing all of the numbers once and saving that list
10:41:49 <Forlorn> glguy, but it took just a second and in GHCI it took like 20 seconds, weird
10:42:22 <glguy> Forlorn: GHCi's much slower than optimized compiled code
10:46:09 <joe9> need some advice, please? haskell code snippet : http://bpaste.net/show/b198e5db2185 , full code: http://dpaste.com/1W54ZM8, C function being called: https://www.opengl.org/wiki/GLAPI/glShaderSource , related SF answer: http://stackoverflow.com/questions/11726563/how-can-i-convert-a-haskell-string-into-a-ptr-ptr-glchar
10:46:17 <Forlorn> I am sorry, I must sound really stupid at this point, but it is still not working
10:46:20 <joe9> Is my haskell code snippet correct? It compiles
10:46:29 <Forlorn> glguy, http://sprunge.us/cIXG
10:46:51 <joe9> but, am not sure if I am doing the right thing.
10:47:47 <sullyj3> mheinzel: That's awesome, thanks so much
10:48:29 <nitrix> Does haskell allow   class Foo a where coerceInstance :: forall b c. (Foo b, Foo c) => b -> c
10:48:45 <sullyj3> The reason I was so picky about is that I'm trying to develop my intuition for tranlating between imperative and functional style
10:48:57 <nitrix> err.
10:49:15 <nitrix> class Foo a where coerceInstance :: forall b. Foo b => a -> b
10:50:21 <nitrix> Is this looking for problems?
10:51:36 <geekosaur> you can write it, but I think the only possible implementation is coerceInstance = undefined
10:51:39 <mheinzel> sullyj3: You're welcome. But be aware that this program will crash on invalid input.
10:51:43 <lyxia> looks like unsafeCoerce
10:52:00 <mizu_no_oto_work> Forlorn: what's not currently working?
10:52:03 <nitrix> geekosaur: What if all the instances are newtype with the same underlaying type?
10:52:23 <Forlorn> mizu_no_oto_work, it's giving equivalent benchmarks for both functions
10:52:27 <nitrix> lyxia: Is it really unsafe?
10:52:34 <geekosaur> you have no constraint on b
10:52:36 <Forlorn> when the other is 20 times faster
10:52:57 <sullyj3> mheinzel: Yeah, by design for now
10:53:02 <geekosaur> you can write coerceInstance :: some_Foo_instance -> IO x
10:53:20 <nitrix> geekosaur: `b` is constrained to `Foo b`.
10:53:32 <geekosaur> you did not write any such constraint
10:53:38 <nitrix> class Foo a where coerceInstance :: forall b. Foo b => a -> b
10:53:54 <geekosaur> oh, sorry. sigh
10:54:07 <geekosaur> so a slightly more principled unsafeCoerce
10:54:11 <nitrix> Yeah.
10:54:20 <nitrix> geekosaur: It seems to provide both unification (the type class) and classification (the parameter to the type class and the different newtypes).
10:54:21 <geekosaur> but it's still on the user to not define instance Foo IO where ...
10:54:34 <nitrix> I'd isolate it in a module.
10:54:36 <geekosaur> type classes are open world
10:54:45 <geekosaur> an type classes are always exported
10:54:46 <nitrix> Ah you're right though :/
10:56:11 <dmwit> glguy: Yep. But I confirmed a few weeks ago that it's very easy to update to modern GHC.
10:56:26 <lyxia> nitrix: it is very unsafe because it bypasses the typechecker. 
10:56:43 <nitrix> lyxia: In what way?
10:57:29 <mizu_no_oto_work> Forlorn: I'm not sure what's wrong, there
10:57:51 <nitrix> lyxia: `Foo A` to `Foo B` would require both A and B to have instances defined for `Foo`.
10:58:10 <nitrix> lyxia: It's a coercion between instances.
10:58:12 <glguy> Forlorn: It's not interesting to compare compiled/optimized performance to GHCi
11:01:12 <lyxia> nitrix: ah I didn't see you meant to define a type class. don't mind me. 
11:02:35 <mizu_no_oto_work> Forlorn: you mean, you're getting equivalent numbers between p and p2, or between ghci and -O2?
11:02:38 <Forlorn> but it still takes around 10-15 seconds for the first benchmark and 2-4 seconds on the second benchmark
11:02:59 <Forlorn> but the time for the first benchmark is 21.23 microseconds and the second is 20.18 microseconds
11:03:02 <Forlorn> like... lol
11:03:20 <nitrix> lyxia: No worries. I don't think it's something people commonly do anyway :P
11:05:20 <Forlorn> (I am not talking about ghci now I am talking about ghc and running ./main)
11:05:56 <Forlorn> I count manually how long a benchmark takes to finish, and it is totally inaccurate to what it is displaying
11:06:12 <mizu_no_oto_work> So the program takes about 15-20 seconds to run, using ./main?
11:06:24 <Forlorn> yeah
11:06:54 <Forlorn> it saying: "benchmarking primes/p" ... for 15 secs or so, and then "benchmarking primes/p2" for 3 secs or so
11:08:56 <Forlorn> and then it claims it took 21 microseconds on the first and 20 microseconds on the second test
11:09:29 * Forlorn hangs himself.
11:09:40 <geekosaur> benchmarks typically run a large number of invocations and compute the average for one call, because many things can affect the timing between individual calls
11:12:48 <mizu_no_oto_work> Forlorn: It looks like the default number of resamples is 1000 - https://hackage.haskell.org/package/criterion-1.1.1.0/docs/src/Criterion-Main-Options.html#defaultConfig
11:13:39 <mizu_no_oto_work> And there's also something about a confidence interval
11:13:48 <Forlorn> resamples?
11:13:57 <Forlorn> It redos the test 1000 times?
11:13:58 <geekosaur> what I just described to you
11:14:06 <geekosaur> [13 18:09] <geekosaur> benchmarks typically run a large number of invocations and compute the average for one call, because many things can affect the timing between individual calls
11:14:30 <mizu_no_oto_work> At least 1000 times, it looks like
11:14:32 <Forlorn> Won't it save the results of what it previously have found hence just giving cached values?
11:15:11 <geekosaur> for example, both unix and windows multitask, if there is a context switch to a different process in the middle of one call, you will see sllowdowns to that call because of time spent in the other process plus potentially a slowdown in the next call because the CPU's instruction cache got cleared
11:15:47 <glguy> Forlorn: GHC doesn't memoize functions, it does memoize some top-level non-functions "CAF"s
11:16:12 <geekosaur> (and data cache, which impact will depend on what data you're using --- if it's all in registers then D cache won't matter)
11:16:17 <mizu_no_oto_work> Forlorn: no.  If you have (\n -> let x = foo in x), you'll recalculate x everytime you call that function.
11:16:35 <mizu_no_oto_work> Memoization is manual since it isn't always an optimization
11:16:54 <Forlorn> that must explain it, because I am really hesitant that I've generated 50000 primes in 101 microseconds, or is that plausible?
11:17:23 <Forlorn> s/that must explain it, because//
11:18:19 <mizu_no_oto_work> i.e. you could refactor (\n -> let x = foo in x) to (let x = foo in \r -> x), where every call of that function would share a pre-calculated x.
11:20:35 <mizu_no_oto_work> Forlorn: 10k primes took 20 microseconds, and 50k primes took 100 microseconds?
11:21:33 <prsteele> Forlorn: you can test this a bit more directly. Compute the maximum of the primes you generate, and print it. Time the execution of the program using `time`.
11:22:04 <prsteele> Forlorn: it can't omit any computations there, really, since it doesn't know the max comes at the end, so it will be forced to evaluate all the entries in the list 
11:24:37 <glguy> Forlorn: Does it affect the outcome to put {-# NOINLINE p #-} and {-# NOINLINE p2 #-} pragmas on those definitions?
11:25:19 <joe9>  I want to throw exceptions with the source file name and line number. Any library that can help?
11:26:50 <Forlorn> prsteele, I tried your suggestion, and p1 runs at 2.45s and then p2 runs at 0.14s.
11:27:16 <Forlorn> just using `time ./p1` and then `time ./p2`
11:28:07 <Forlorn> glguy, where would I put those? (I am relatively new to Haskell)
11:28:25 <glguy> Forlorn: underneath the defintions of p and p2 all the way to the left
11:29:38 <glguy> Forlorn: Also, what's the definition of 'd'?
11:30:00 <mizu_no_oto_work> Forlorn: http://primesieve.org/ - it looks like they generate the first ~6 million primes in 10k microseconds, and their algorithm is O(n log log n).  Presumably 600k primes could be done in ~1k microseconds 60k in ~100.  So 50k in 100 microseconds in unoptimized haskell would be surprisingly fast, but not completely out of the realm of possiblility.
11:30:31 <Forlorn> glguy, http://sprunge.us/cCUW
11:30:38 <mizu_no_oto_work> But `time ./p1`'s timing suggests that part of this is being run once then cached.
11:31:29 <glguy> Forlorn: p and p2 don't even compute the same thing
11:31:32 <Forlorn> same with ghci, if I run primes !! 10001 the second time it gives me the result directly
11:31:51 <glguy> So it's even less surprising that they perform at different speeds
11:32:09 <Forlorn> they should perform at different speeds
11:32:17 <Forlorn> that's my problem
11:32:18 <glguy> they're different functions
11:32:24 <Forlorn> yeah
11:32:25 <glguy> they produce different lists
11:32:32 <glguy> like not-equal
11:32:38 <mizu_no_oto_work> Forlorn: a top level data structure isn't going to be recomputed; only functions will be recomputed
11:32:40 <Forlorn> my problem is that they give almost the EXACT same speed when using Criterion
11:32:50 * hackagebot snorkels 0.2.0.0 - Strategic board game of medium complexity  https://hackage.haskell.org/package/snorkels-0.2.0.0 (unaizalakain)
11:33:19 <mizu_no_oto_work> So you'd expect primes !! 1001 to be much faster the second time
11:33:28 <mizu_no_oto_work> since the list is now stored in memory
11:33:35 <Forlorn> glguy, p2 does not give the primes?
11:33:41 <glguy> it skips primes
11:33:49 <glguy> try p2 10 == p 10
11:33:52 <prsteele> Forlorn: just test it
11:33:57 <Forlorn> fuck
11:33:58 <Forlorn> lol
11:35:25 <mizu_no_oto_work> At any rate, did the no-inline pragma cause criterion's time to go up?
11:35:55 <mizu_no_oto_work> Also, you didn't change the optimization level between using time and using criterion, right?
11:36:29 <Forlorn> nope
11:36:49 <Forlorn> well, I can get them to be equal, just some minor fixes I guess
11:37:20 <mizu_no_oto_work> what is 'them' in 'get them to be equal'?
11:37:53 <Forlorn> that p1 n is not equal to p2 n
11:38:05 <Forlorn> since p2 skips the first handful of primes
11:38:20 <Forlorn> but that is irrelevant to this Critertion issue
11:39:05 <Forlorn> {-# NOINLINE p2 #-} and for p1 did not help
11:39:36 <glguy> The issue is that you're surprised that criterion runs one of the tests longer than the other?
11:39:55 <Forlorn> No, I am surprised that they run at the same speed
11:40:05 <Forlorn> p1
11:40:06 <Forlorn> time                 21.23 μs   (21.20 μs .. 21.28 μs)
11:40:11 <Forlorn> p2
11:40:12 <Forlorn> time                 20.38 μs   (20.36 μs .. 20.40 μs)
11:40:57 <Forlorn> and sometimes p2 (the faster) is slower by 1 microsecond, so it is just a random distribution of 20±1 microseconds
11:41:43 <prsteele> Forlorn: what if you compute nf (maximum (map p1 [1..10000])), nf (maximum (map p2 [1...10000]))
11:41:51 <Forlorn> when in real life, they don't run at the same speeds, hence Criterion is giving incorrect benchmarking
11:42:03 <glguy> Forlorn: GHCi isn't real life
11:42:09 <Forlorn> not GHCi
11:42:24 <Forlorn> `time ./p1` vs `time ./p2`
11:42:25 <mizu_no_oto_work> Fornlorn: out of curiosity, have you seen http://www.serpentine.com/criterion/tutorial.html ?
11:42:32 <Forlorn> yes
11:43:06 <mizu_no_oto_work> and `time ./p1` just runs p1 once, right?
11:43:13 <mizu_no_oto_work> but takes ~2 seconds?
11:43:21 <Forlorn> p1 is the slow one
11:43:41 <schell> is there a way to setup a cabal project so when profiling it builds using one module, and in production, another?
11:44:04 <Forlorn> p1 took 3.42s and p2 took 0.14s
11:44:35 <Forlorn> but in Criterion they both take 20±1 microseconds
11:45:16 <schell> i guess i could do with passing a flag to cabal
11:45:29 <ReinH> schell: that seems like an anti-feature to me
11:45:35 <Forlorn> note that a microsecond is 10^-6 of a second
11:46:32 <schell> ReinH: maybe you know of a better way to fix my problem - one of my dependencies can’t build for profiling, which is fine as I only use it for interactive development
11:46:47 <glguy> Forlorn: behaves the same funny way here compiling it
11:46:54 <schell> i need a way to keep it from trying to build during profiling, and then switch out all uses of it in my code for a non-op
11:47:27 <schell> my plan was to write a non-op module and then swap the module using cabal flags
11:47:31 <Forlorn> Welcome to my life :D
11:47:39 <Forlorn> prsteele, like so? http://sprunge.us/McPa
11:48:01 <glguy> Forlorn: Here's what's happening:
11:48:17 <glguy> GHC's too clever and is still precomputing the list once and indexing it
11:48:47 <glguy> I'm looking at the optimized core for these two functions
11:49:40 <glguy> p2 =  \ n_a3Oi ->    case n_a3Oi of _ { I# ww1_a7HX -> $w!! lvl6_rb1U ww1_a7HX }
11:49:48 <glguy> p1 = \ n_a3EK -> !! lvl8_rb1Y n_a3EK
11:50:08 <MarLinn> Q: Given an (Out foo) :: * -> Constraint, is Data.Constraint.ForallT (Out foo) (,) a constraint level equivalent of forall a b. (Out foo a,Out foo b) :=> Out foo (a,b)?
11:50:57 <ReinH> schell: what dependency?
11:51:05 <schell> halive
11:51:06 <glguy> Forlorn: so the 20us is still the time taken to do list indexing
11:51:26 <Forlorn> yup
11:51:30 <schell> ReinH: it’s this flag in halive specifically https://github.com/lukexi/halive/blob/master/halive.cabal#L72
11:52:01 <Forlorn> this seems like a problem that will come up a lot
11:52:08 <schell> it causes a bunch of “Perhaps you haven't installed the "p_dyn" libraries for package” errors
11:52:17 <schell> so i was going to skip it entirely
11:52:19 <Forlorn> it it wrong benchmarking with `time` instead?
11:53:22 <ReinH> Forlorn: Yes.
11:54:32 <schell> ReinH: maybe it’s a stack issue
11:54:44 <schell> my resolver doesn’t match that of halive’s
11:54:49 <twice_> Who knows how to solve it via Haskell (some recursion)How many there is a strictly increasing sequence of positive integers whose sum is equal to a given number n? For example, for n = 9, there are sequences: 1 2 6, 1 3 5 1 8 2 3 4 2 7, 3 6, 4 5, 9 That is, the answer to question is 8
11:55:00 <ReinH> schell: does passing the ghc option override it?
11:55:02 <Forlorn> ReinH, then what should I do?
11:55:09 <Forlorn> Should I just turn off optimization?
11:57:28 <Insanity_> twice: can you rephrase that?
11:57:41 <senoj> twice_: that sounds like a homework problem
11:57:55 <MarLinn> Mpf... doesn't seem that way. Makes sense, I guess...
11:58:12 <Insanity_> senoj: it does but to me it feels like some words are missing XD
11:58:32 <ReinH> How is "1 3 5 1 8 2 3 4 2 7" a strictly increasing sequence of positive integers?
11:58:48 <Insanity_> ^ he missed some "," I think
11:58:51 <ReinH> Oh, you must have missed some commas
11:58:56 <Insanity_> because neither would the answer be 8 otherwise
11:58:57 <twice_> yes sorry
11:59:01 <ReinH> This is bin packing.
11:59:14 <ReinH> So look up knapsack problem solutions
11:59:40 <ReinH> The basic method is to try every combination of either using or not using an element from the list
11:59:58 <ReinH> The dynamic programming method is to store the results of doing this for sublists
12:00:19 <ReinH> But this is pretty obviously a homework problem, so we shouldn't give you the answer
12:00:23 <twice_> the recursion sollution is ok
12:00:28 <Insanity_> I agree with ReinH here
12:00:31 <ReinH> they are both recursion solutions
12:00:34 <prsteele> ya I'm not sure bin packing / knapsack works here, since we're not really worried about hte objective function
12:00:38 <Insanity_> Sounds like homework to me
12:00:56 <ReinH> prsteele: the numbers' value and weight are the same, but it is a knapsack problem
12:01:11 <Insanity_> btw twice
12:01:11 <ReinH> it is pretty directly the 0-1 knapsack problem
12:01:24 <Insanity_> instead of asking for a full solution, I guess it would be like 'rules' of stackoverflow
12:01:39 <Insanity_> if you try to solve it - show some code - and show where you get stuck, it's easier to help. And you'll learn more that way than by just asking for the solution
12:01:48 <prsteele> ReinH: I'm not seeing it. You have a knapsack of capacity n=9, and you're interested in _how many ways we can pack it_, not getting the maximum value of packed elements
12:01:54 <twice_> I think it's easier than knapsnack
12:01:57 <ReinH> the only additional requirement is that the sequence must be monotone, but you get this for free with the usual solutions since they proceed in only one direction through the list
12:02:23 <ReinH> prsteele: the haskell solution to the 0-1 knapsack problem can be trivially altered to produce a list
12:03:10 <ReinH> you generalize the question to 'show all packings that give the max weight and max value' rather than 'show *the* packing'
12:03:35 <mizu_no_oto_work> 'show *a* packing', you mean
12:03:40 <ReinH> sure
12:03:45 <prsteele> how would you weight the packing {1, 8} and the packing {9} ?
12:03:52 <ReinH> both are 9
12:04:08 <prsteele> okay fine show all packings then, sure
12:04:38 <senoj> packings and partitions are not the same thing
12:05:24 <mizu_no_oto_work> twice_: at any rate, your professor is likely just looking for a simple recursive brute-force approach.
12:05:36 <mizu_no_oto_work> given that his example number is 9.
12:05:52 <mizu_no_oto_work> and not over 9,000
12:06:04 <twice_> yes
12:06:58 <mizu_no_oto_work> The Knapsack problem is easy to write a brute force solution to.  It's just that you quickly start to need more brute force than can practically be brought to bear.
12:07:36 <prsteele> in this particular problem I think I see an easy O(n^2) algorithm
12:07:59 <prsteele> sorry, maybe I don't
12:08:43 <senoj> I think the best known solutions are exponential
12:08:55 <prsteele> for the general problem, there is a lot of structure here
12:09:00 <ReinH> pack (x:xs) total result | total + x > 9 = ???; pack (x:xs) total result | total + x == 9 = ???; pack (x:xs) total result | total + x < 9 = ???
12:09:02 <prsteele> also I think there is a pseudo-polynomial time alg
12:09:07 <MarLinn> mizu_no_oto_work: That's a great number to distinguish which algorithm to choose XD
12:09:56 <ReinH> pack :: [Int] -> Int -> [[Int]] -> [[Int]]
12:10:07 <MarLinn> What's your constant? IT'S OVER NINE....THOUSAAND!
12:10:24 <kadoban> Given that there's only 2**9 subsequences of length 9, pretty much any correct solution should be fine.
12:10:45 <ReinH> That's an O(n^2) algorithm, but you memoize the sublists to improve it in the usual way.
12:10:50 <kadoban> I said that wrong, but w/e.
12:11:19 <ReinH> I don't expect you need a dynamic programming solution, just the naive one
12:12:51 <ReinH> sorry, the syntax with guards is wrong there, but maybe you get my meaning
12:15:04 <prsteele> I think we're approaching this the wrong way. we just need a count, not the packings. I think we can do this without any lists at all
12:15:40 <ReinH> Once you come up with a solution, I can show you the really naive one liner
12:16:02 <ReinH> prsteele: Perhaps, but I suspect the expected solution enumerates the packings
12:19:14 --- mode: tepper.freenode.net set +o ChanServ
12:19:51 <ReinH_> ugh
12:20:06 <ReinH_> netsplit?
12:20:10 <MarcelineVQ> ye
12:20:20 <ReinH_> irccloud is still confused
12:20:24 <MarcelineVQ> only had 140 people left on my node
12:20:59 <ReinH_> Anyway, the naive solution is to list all subsequences and filter the ones whose sum is 9, and there's a clever use of filterM to generate the subsequences.
12:21:41 <Zemyla> > 1
12:21:45 <ReinH_> Maybe one day someone will give me this as an interview question so this knowledge will actually be useful
12:22:56 <Zemyla> > 1
12:23:06 <ReinH_> lambdabot, noooooo
12:24:09 <int-e> > 42
12:24:23 <ReinH_> @botsnack
12:24:26 <kadoban> > 6 * 9
12:24:30 <lambdabot>  1
12:24:31 <lambdabot> :)
12:24:32 <lambdabot>  mueval-core: Time limit exceeded
12:24:34 <lambdabot>  54
12:25:52 <kadoban> Haha
12:29:05 <ongy> > 42
12:29:08 <lambdabot>  42
12:30:39 <lingxiao> hey all
12:30:52 <lingxiao> im getting a what i think is an encoding error and would like some help
12:30:52 <prsteele> hello
12:31:03 <lingxiao> so I greped a bunch of stuff and put it in a text file
12:31:12 <lingxiao> now when i try to open it as Text, im getting some rror:
12:31:47 <lingxiao> hGetContents: invalid argument (invalid byte sequence) 
12:31:54 <ongy> > (\case Just x -> x ; Nothing -> "None") $ Just "Some" -- :)
12:31:58 <lambdabot>  "Some"
12:32:07 <lingxiao> i tried this block of code: http://lpaste.net/193619
12:32:15 <lingxiao> and it opens the thing successfuly as stirng
12:32:27 <lingxiao> however when it try to encoe it as text, i get the same issue again
12:33:57 <ongy> lingxiao: have you tried printing the string? maybe it would error aswell but wasn't forced far enough
12:34:09 <lingxiao> yeah th efile is huge though
12:34:13 <lingxiao> so printing it takes a long time
12:34:34 <lingxiao> also how do i prevent myself from gettingthsi eror: hGetContents: illegal operation (delayed read on closed handle) 
12:34:40 <ongy> printing to /dev/null is usually fast
12:34:51 <lingxiao> how do i do that?
12:35:01 <lingxiao> print >> /dev/null    i assume not?
12:35:08 <geekosaur> lingxiao, are you closing the handle explicitly? don't do that
12:35:22 <lingxiao> yeah i did 
12:35:26 * geekosaur finds paste...
12:35:26 <lingxiao> ok i stopped doing that
12:35:49 <geekosaur> once you use getContents or hGetContents, the handle is no longer "yours"
12:35:54 <lingxiao> like when I take 10000 items from the string and pack it, its fine
12:36:03 <lingxiao> oh i see .. whose is it?
12:36:33 <geekosaur> hGetContents uses unsafeInterleaveIO to do reads "in the background" --- the handle belongs to that
12:36:36 <ongy> http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#v:hGetContents somewhat explains it
12:36:54 <ReinH_> handling very large files is a use case for pipes/conduit
12:37:10 <ReinH_> but switching to pipes/conduit won't fix your encoding problem
12:37:14 <ongy> lingxiao: you can either open the file you print to, or use file redirection in the terminal (errors should be on stderr, so they should still print)
12:37:16 <lingxiao> right yeah ..
12:37:32 <lingxiao> ok get this error again: invalid byte sequence
12:37:37 <lingxiao> im thinking it's an encoding problem
12:37:54 <ReinH_> What is your system locale? Is this on Windows?
12:37:57 <lingxiao> also how come memroy doesnt get freeed up after an error is thrown?
12:38:02 <geekosaur> yes, that's encoding
12:38:06 <lingxiao> os x
12:38:07 <ongy> sounds like it. Did you get a bom grepped into your file?
12:38:22 <ReinH_> If your system locale isn't something.UTF8, it can cause this
12:38:31 <lingxiao> i may have
12:38:36 <lingxiao> it's google ngrams
12:38:36 <lingxiao> so anything goes
12:38:40 <ReinH_> what does `locale` list (in a terminal)?
12:38:46 <lingxiao> whats the solution here 
12:38:53 <lingxiao> sorry my computer is freezing
12:38:56 <ReinH_> We don't know what the solution is until we know what the problem is
12:39:11 <lingxiao> why doesn tmemory get freed up  here?
12:39:38 <ReinH_> One option would be to read it with bytestring and then explicitly convert to text via the text encoding functions
12:39:50 <geekosaur> re BOM, http://qdb.dreamwidth.net/dw/428
12:39:52 <ReinH_> This would avoid any issues with the locale
12:40:00 <lingxiao> you know i htikn im going to do that
12:40:13 <geekosaur> (I thought there was a "someone set up us the BOM" in there but it must have been a different project...)
12:40:17 <ReinH_> ha
12:41:00 <ongy> I never got why the utf8 bom even exists
12:41:28 <ReinH_> to... signal the endianness?
12:41:33 <kadoban> Just to mark UTF-8 files I guess? It's pretty weird.
12:41:54 <ReinH_> to signal a particular unicode encoding (in this case, it's a utf-8 bom)
12:42:00 <ReinH_> to annoy people
12:42:07 <ReinH_> pick three
12:42:21 <shachaf> The BOM character exists, so it's possible to have it in UTF-8 data. But you shouldn't.
12:42:34 <ongy> the only one that fits the name is the first. and I have never seen it used (i.e. not work when it's removed)
12:42:44 <ReinH_> ongy: the others are side effects
12:44:12 <alex_new> hey, I am trying to build stack project within NixOs. here is my stack.yaml which works. http://paste.ofcode.org/4GcJu8QMtEccJ6JSqqsbdT Do you know how to avoid writing explicit path to the gfortran library? (extra-lib-dirs:)
12:45:16 <ongy> wiki says for utf8 byte order has no meaning, so it's literally "this is utf8, probably"
12:45:45 <geekosaur> windows used to use an initial bom to differentiate utf8 text files from 8-bit code page text
12:46:09 <geekosaur> there are still versions of notepad that will write an initial bom if you save a file as utf8
12:46:49 <ongy> notepad. Feels like the worst part of windows
12:47:15 <Welkin> ongy: no, that is windows
12:47:52 <Welkin> there was a lot of product placement in this series called "Humans" I watched last night
12:47:59 <geekosaur> could be worse. early os x had some horrid hack to distinguish utf8 from the old mac roman-8 encoding... which sometimes guessed wrong
12:48:01 <Welkin> ipads, microsoft surface
12:48:04 <Welkin> other things I forgot
12:48:22 <Welkin> and everyone was british
12:48:51 <mauke> ongy: bush hid the facts
12:49:15 <ongy> mauke: ??
12:50:04 <mauke> ongy: https://en.wikipedia.org/wiki/Bush_hid_the_facts
12:50:56 <prsteele> ... I can't believe that turned out to be germane
12:52:04 <kadoban> Haha
12:54:02 <mtesseract> Hi
12:56:05 <prsteele> hello mtesseract 
12:57:56 <geekosaur> heh, I remember that bug
12:59:28 <ongy> I either never saw that one, or ignored it as weirdness of computers
13:10:37 <ReinH_> > filter ((== 9) . sum) . filterM (const [True, False]) $ [1..9]
13:10:43 <lambdabot>  [[1,2,6],[1,3,5],[1,8],[2,3,4],[2,7],[3,6],[4,5],[9]]
13:10:51 <ReinH_> prsteele: ^
13:11:19 <ReinH_> prsteele: interested in the version that doesn't generate any lists
13:11:27 <MarcelineVQ> oh snap that's what I ended up with, hooray
13:12:18 <ongy> :t filterM (const [True, False])
13:12:21 <lambdabot> [b] -> [[b]]
13:12:38 <ongy> > filterM (const [True, False]) [1..2]
13:12:41 <lambdabot>  [[1,2],[1],[2],[]]
13:13:06 <MarcelineVQ> Though I'm not really sure why it works so now I gotta look up filterM and the [] Monad instance
13:13:16 <Welkin> > filterM (const True) [1,2]
13:13:19 <lambdabot>  error:
13:13:19 <lambdabot>      • Couldn't match type ‘Bool’ with ‘m Bool’
13:13:19 <lambdabot>        Expected type: b -> m Bool
13:13:28 <kadoban> :t filterM
13:13:30 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
13:13:44 <ReinH_> In this case, filterM takes an element and gives a list of decisions about whether to include it
13:14:09 <ReinH_> our "monadic predicate" ignores the element and both chooses and doesn't choose the element.
13:14:20 <ReinH_> so we get every combination of both choosing and not choosing each element
13:14:35 <Welkin> so it's combinations
13:14:43 <MarcelineVQ> fascinating
13:14:45 <ReinH_> It's powerset.
13:14:50 <Welkin> :t combinations
13:14:52 <lambdabot> error: Variable not in scope: combinations
13:14:55 <Welkin> :t permutations
13:14:56 <lambdabot> [a] -> [[a]]
13:14:58 <ReinH_> it's powerset.
13:14:58 <ongy> is it fast?
13:15:02 <ReinH_> it isn't permutations
13:15:04 <Welkin> oh
13:15:07 <Welkin> yeah, powerset
13:15:15 <Welkin> yeah, I know it's not permutations
13:15:19 <kadoban> It's as fast as generating 2**n things can be, I think.
13:15:32 <ReinH_> the specification of the problem is: the number of elements of the powerset of [1..9] which sum to 9
13:15:43 <ertes> > do y <- ["", "y"]; e <- ["", "e"]; s <- ["", "s"]; pure (y ++ e ++ s)
13:15:45 <lambdabot>  ["","s","e","es","y","ys","ye","yes"]
13:15:53 <ReinH_> so length . filter ((== 9) . sum . powerset is the naive solution
13:15:59 <ertes> > filterM (const [False, True]) "yes"
13:16:02 <lambdabot>  ["","s","e","es","y","ys","ye","yes"]
13:16:04 <ReinH_> er filter ((== 9) . sum)
13:16:13 <ertes> note that filterM is *horribly* inefficient on lists
13:16:21 <ertes> so better use Data.List.subsequences
13:16:31 <kadoban> Is it?
13:16:40 <ReinH_> ertes: merely an implementation detail
13:16:41 <Welkin> > Data.List.subsequences [1..3]
13:16:43 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
13:16:48 <Welkin> good to know
13:16:57 <ReinH_> The less naive solution reifies the choises via recursion and prunes impossible choices
13:17:03 <ReinH_> *choices
13:17:08 <ertes> ReinH: filterM can't really be more efficient
13:17:24 <ertes> it's similar to the nubEq vs. nubOrd deal:  the type makes it inefficient
13:17:30 <ReinH_> I know. I just mean that it's the specification for the solution and I don't care if it is efficient
13:17:30 <ongy> @src Data.List.subsequences
13:17:30 <lambdabot> Source not found. Whoa.
13:17:43 <MarcelineVQ> What is the nub thing?
13:17:45 <Welkin> ongy: don't use @src
13:17:54 <Welkin> MarcelineVQ: that is filter for uniques
13:17:58 <ertes> > nub "abbaacca"
13:18:02 <lambdabot>  "abc"
13:18:04 <MarcelineVQ> No sorry I mean what is the ordeal
13:18:11 <ReinH_> ordeal?
13:18:14 <Welkin> O(n^2)
13:18:15 <ReinH_> I mean, it's a bit trying
13:18:17 <ertes> MarcelineVQ: deal =)
13:18:19 <MarcelineVQ> :>
13:18:22 <ertes> MarcelineVQ:
13:18:24 <ertes> :t nub
13:18:29 <lambdabot> Eq a => [a] -> [a]
13:18:32 <Welkin> there is one that uses radix sort that is faster though
13:18:40 <ReinH_> A solution with an Ord constraint can be faster
13:18:45 <ertes> MarcelineVQ: you can't use an efficient (O(log n) lookup) data structure with this type
13:18:45 <Welkin> in one of edwardk's packages I think
13:18:47 <ReinH_> since you can sort the list first
13:18:50 <ReinH_> and do it on n log n
13:19:05 <MarcelineVQ> I see that makes a lot of sense thank you
13:19:08 <ReinH_> Data.SortedList has one
13:19:21 <ReinH_> iirc
13:19:43 <ertes> if the list is sorted, you can simply use 'group'
13:19:53 <ReinH_> ertes: exactly
13:20:02 <ertes> > map head (group "aabbbbbcccd")
13:20:08 <lambdabot>  "abcd"
13:20:16 <ReinH_> group os O(n), sorting is O(n log n), sorting then grouping is O(n log n)
13:20:21 <ReinH_> s/os/is
13:20:31 <ertes> i like to view 'group' as O(1) most of the time =)
13:20:42 <ReinH_> Ok. Same answer. :)
13:20:51 <ongy> and just having the Ord is not enough. since that would sort the list, which may not be wanted
13:21:06 <ReinH_> ertes: in the sense that if you're using the result you're already traversing the list anyway?
13:21:12 <ertes> ongy: Ord is enough to use Set instead of a list to keep track of seen elements
13:21:21 <ReinH_> ongy: yes, the Ord version is not stable
13:21:27 <kadoban> The only potential problem with the sorting solution is, if there's very few unique elements, but many many duplicates, sorting first is pretty bad (in terms of space at least)
13:21:44 <ReinH_> but you can make an Ord version that is stable with a little extra work
13:21:48 <ertes> ReinH: in the sense that usually it's more important that it adds a constant overhead to each individual list item
13:21:53 <ertes> (to me)
13:22:01 <ReinH_> ertes: ah, sure
13:22:18 <ertes> overall it's still O(n), of course
13:22:29 <ReinH_> Everything is O(1) if you don't demand the result.
13:22:36 <Welkin> oh lawd
13:22:43 <ReinH_> really good constant factors too!
13:22:51 <Welkin> arguments over big-o notation again
13:22:59 <ReinH_> Are we arguing? I wasn't aware.
13:23:00 <ongy> if I never run the program I don't care about performance
13:23:05 <ReinH_> ongy: exactly!
13:23:08 <ertes> Welkin: i think we're in agreement =)
13:23:22 <Welkin> big-o isn't that useful really
13:23:22 <Welkin> o.o
13:23:26 <kadoban> So it's more like ... complaining about non-existant arguments again.
13:23:29 <ReinH_> Why would I disagree with ertes? He's always right?
13:23:31 <Welkin> it doesn't mean much
13:23:38 <ertes> uuuhhhhhhh…
13:23:38 <ReinH_> I mean "He's always right."
13:23:50 <Welkin> nothing is even well defined
13:23:51 <ReinH_> ertes: to a first approximation
13:23:55 <Welkin> what is `n`?
13:24:13 <ertes> you know, why i don't like supporting people in /query?
13:24:24 <ReinH_> Welkin: big O notation is well defined, most uses of it are not.
13:24:33 <ertes> because if you search #haskell logs, you'll find about one instance of me being wrong every day
13:24:36 <ongy> because they alwasy come back to you, and you have to pamper them forever?
13:24:43 <kadoban> Welkin: The input size, here with Ord at least it'd be the number of elements of the list. And what we'd be counting is likely the number of comparisons.
13:24:44 <ReinH_> ertes: Like I said, "to a first approximation". :)
13:25:06 <kadoban> Another model would potentially give a different answer, though I'm too lazy to think it out.
13:25:43 <kadoban> But for many many uses, the number of comparisons is a good proxy for how long it'll take.
13:26:11 <ertes> ReinH_: fast and loose reasoning once again =P
13:26:37 <ReinH_> ertes: Fast and loose reasoning is well defined. Most uses of it are not.
13:27:17 <ertes> hah!  i knew that i hadn't been wrong today yet!
13:27:46 <ReinH_> Most *uses* of "fast and loose" amount to slightly more credible hand waving ;)
13:31:50 <joe9> haskell code : http://dpaste.com/13KYC4C  I am wrapping the function calls like this: http://bpaste.net/show/6912729c5466 . Is there a better way  of doing this?
13:33:14 <ReinH_> joe9: what are you doing? That's a lot of code to read through.
13:33:39 <joe9> ReinH_: I am doing some opengl calls. I want to check for any errors after each command.
13:33:48 <joe9> ReinH_: Thanks for taking a look.
13:34:26 <joe9> ReinH_: like this http://bpaste.net/show/47e32f79146a
13:34:27 <ReinH_> I don't know what you're doing, but judging by the types you can't be doing the right thing
13:34:45 <ReinH_> checkGLErrors takes an IO action and gives an IO action
13:34:56 <ReinH_> sometimes you use it with <-, sometimes you use it without <-, sometimes you use it without an argument
13:34:59 <ReinH_> all three can't be correct
13:35:38 <ReinH_> joe9: If you check for compile errors frequently, you won't get into a situation where you have dozens of mistakes in your code to fix at a time
13:35:56 <ReinH_> Try to make it a point to successfully compile your code after each significant change
13:35:57 <joe9> ReinH_, you have a good point. let me fix the compile errors and
13:36:02 <ReinH_> don't just write a bunch of code and then see if it compiles
13:36:35 <ReinH_> (I know some people that use the latter strategy, like edwardk, but they are intimately familiar with Haskell and GHC errors, so it's a workable process for them.)
13:36:36 <dmwit> Easy does it. He's probably coming off the other side of what he thought would be a minor refactoring to clean up before asking his question.
13:36:40 <joe9> ReinH_:  I am not worried about the compilation errors. I can fix them. I am more worried about how I shoud be structuring something like that.
13:37:05 <ReinH_> You have to have a working program before you can decide whether it is a good program.
13:37:20 <joe9> ReinH_: good point. let me work on this and get back.
13:37:33 <ReinH_> joe9: ok :)
13:37:49 <dmwit> joe9: The best ideas I have all involve writing modified `gl*` functions with a better API.
13:38:21 <dmwit> joe9: e.g. `glAttachShader' x y = checkGLErrors (glAttachShader x y)`, or perhaps lifting it into an `ExceptT`.
13:38:35 <ReinH_> joe9: in the TDD world, we use "time to green" (how long it takes you to go from a failing test suite to a passing test suite) as a metric for how well our process is working. In the type-driven-development version of TDD, it's "time to compile".
13:38:44 <ReinH_> The longer you go without compiling, the more risk you are assuming.
13:38:58 <ReinH_> the more frequently you compile, the more feedback you get
13:39:14 <joe9> ReinH_: compiling version : http://dpaste.com/354SBY4
13:40:01 <joe9> ReinH_: this code snippet http://bpaste.net/show/9cd4abea51bc
13:40:14 <joe9> ReinH_: I presume there must be a better way of writing it.
13:40:40 <joe9> dmwit, good suggestion. Thanks.
13:40:40 <lingxiao> hey guys 
13:40:51 <lingxiao> i used conduit and got a more informed error message
13:41:21 <ReinH_> joe9: let me show you how the author of the gl package uses getGLError: https://github.com/ekmett/quine/blob/da2e3a4531bed0fe39a680b123c460dad0750da2/src/Quine/GL/Error.hs#L103
13:41:27 <ReinH_> joe9: Pretty similar to what you are doing.
13:41:32 <ReinH_> It can't be that bad of an idea.
13:41:33 <lingxiao> http://lpaste.net/193657
13:41:45 <lingxiao> encountered at byte sequence "\194ty "
13:42:02 <ReinH_> lingxiao: interesting
13:42:08 <ReinH_> Perhaps your file is corrupted.
13:42:14 <lingxiao> oh boy :(
13:42:19 <lingxiao> what makes you think that?
13:42:40 <ReinH_> Maybe your grep included a binary file and somehow matched. I don't know.
13:42:57 <ReinH_> But there's a byte sequence that isn't valid utf-8 in it.
13:42:59 <joe9> ReinH_: How did you find that so quickly? Did you know about it?
13:43:03 <ReinH_> joe9: Yes. :)
13:43:11 <kadoban> How would it work if one of the files he greped through was in some other encoding? Wouldn't it do exactly this?
13:43:36 <ReinH_> joe9: Well, I knew that he wrote quine, and I thought "He probably uses getGLError." So I searched for "getGLError" in the repo on github.
13:43:58 <ReinH_> joe9: So if you look at call sites for throwErrors, you might find some patterns to use yourself
13:44:35 <ReinH_> also quine is really cool
13:45:54 <joe9> ReinH_: That module is perfect. Exactly what I was trying to do and a lot better.
13:46:53 <joe9> ReinH_:  Thanks a lot for the suggestion.
13:51:12 <ReinH_> :)
13:51:48 <ReinH_> kadoban: ah, perhaps!
14:01:43 <mpickering> Is it actually necessary to install nix to use reflex?
14:01:50 <MarcelineVQ> no
14:01:52 <Welkin> no
14:02:06 <Welkin> but the only way I could get ghcjs to work with anything was using nix
14:02:07 <Welkin> O.o
14:02:14 <kadoban> mpickering: It's just their recommended way. I use stack and it works great.
14:02:15 <Welkin> I wasted a whole night installing it with stack twice
14:02:40 <mpickering> well I don't want to use stack either heh
14:02:46 <mpickering> I guess I'll try it and see what happens
14:02:50 <mpickering> nix never worked well on osx though
14:02:52 <kadoban> GHCJS is kind of a pain to get installed. The stack solution *should* just work (copy stuff out of the docs into a file), but once it didn't for me and it was a pain.
14:02:58 <Welkin> I'm using it on osx
14:03:04 <Welkin> it works fine so far
14:03:23 <kadoban> I guess you could do without stack too if you really want to, you'd have to install GHCJS on your own and do whatever cabal stuff makes it use that version, I guess?
14:04:03 <Welkin> just use reflex-platform
14:04:09 <Welkin> it installs nix and everything for you
14:06:20 <mpickering> It doesn't work if you already have nix installed
14:06:33 <mpickering> I'm trying now after clearing nix from my system
14:07:33 <joe9> Is there any reason why stack cannot pull in the latest commit from the git location?
14:08:20 <jonored> That's a little surprising; the core nix things should be fine with parallel environments like that.
14:08:31 <MarcelineVQ> Do you mean is there a reason you can't specify to just pull the latest commit?
14:08:51 <joe9> when I specify a git location, I have to give a commit explicitly.
14:09:02 <joe9> Why not just pull the latest commit from git repo?
14:09:10 <MarcelineVQ> It's the same logic behind extra-deps and your resolver having specific versions
14:09:30 <MarcelineVQ> if stuff works with that commit it'll keep working basically
14:09:54 <joe9> MarcelineVQ: makes sense. Thanks.
14:12:10 <mpickering> jonored: It was quite an old installation from at least a year ago and I don't think it ever worked properly then
14:14:28 <jonored> mpickering: Ah, maybe an updating nix itself issue or somesuch.
14:18:06 <amf> given [("a", (1 :: Int, 2 :: Int)), ("a", (0, 0)), ("b", (2, 3))], is there a better way to combine elements than using Data.HashMap.toList . Data.HashMap.fromListWith ? e.g. is there a monoid instances package for things like this?
14:20:33 <kadoban> amf: What do you want to happen?
14:21:14 <lingxiao> hey guys the gay grep works is that if i do 
14:21:20 <lingxiao> nohup grep "not" ?gms/*txt    
14:21:41 <lingxiao> it'll find all strings containing "not" in directories  __gms/__.txt right?
14:22:31 <geekosaur> ?gms/ matches any directory whose name is 4 characters, the last three of which are "gms"
14:22:31 <lambdabot> Not enough privileges
14:22:32 <amf> kadoban: [("a", (1, 2)), ("b", (2, 3)) ], e.g. like keys combine
14:22:35 <geekosaur> bah
14:22:44 <koala_man> lingxiao: ? only matches one character, so it would look in _gms but not __gms
14:22:46 <geekosaur> forgot the bot uses ? as a secondary command character
14:22:54 <lingxiao> ah ok geat
14:23:03 <lingxiao> but grep "not" will match any string conating not right?
14:23:07 <lingxiao> including "note"
14:23:09 <lingxiao> "capnot"
14:23:19 <geekosaur> correct
14:23:22 <lingxiao> "foo , but not bar"  and "bar if not baz"
14:23:24 <lingxiao> ok great thanks!
14:23:53 <geekosaur> gnu grep has -w to (attempt to) match whole words
14:24:14 <kadoban> amf: Well, I mean there's a few ways to write that, but none I know of super built-in I'd say.
14:24:42 <kadoban> :t groupBy ((==) `on` fst) . sort --comes to mind, but that only gets you like 1/2 way there
14:24:44 <lambdabot> (Ord b, Ord a) => [(a, b)] -> [[(a, b)]]
14:25:04 <amf> kadoban: i figured, it wont be hard by hand, was hoping to save some time / bytes
14:25:40 <lingxiao> ok thaks
14:32:53 * hackagebot clckwrks 0.23.19.1 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.19.1 (JeremyShaw)
14:52:03 <prsteele> ReinH_: you still around? I have a list-less solution
14:52:57 <lpaste> prsteele pasted “list-less solution” at http://lpaste.net/193714
14:53:25 <kadoban> listless xD
14:54:02 <prsteele> ya I was trying to disamgiguate between "lacking enthusiam" and "lacking lists"
14:55:47 <kadoban> I just thought the double meaning is funny.
15:04:50 <adnelson> hi, anyone familiar with hspec... I want to run tests which hit a postgres instance which I set up/teardown before/after my tests. I wrote an hspec `around_` handler which takes care of this. Thing is that the database runs on a random arbitrary port, and I need the tests to know what that port will be while they're running. So my question is, how do I pass the information of the port to the test examples?
15:06:29 <prsteele> adnelson: you could, for example, store the port in the Reader monad, and the runReader yourTests port to get tests out
15:07:41 <adnelson> prsteele: right, I'm using a reader monad to store the connection. But my question is how do I actually find the port?
15:07:51 <adnelson> so to elucidate a bit:
15:08:14 <adnelson> let's say I have a function `setupDb :: IO Int` which sets up a database and returns the port
15:08:24 <adnelson> and I have a `teardownDb :: IO ()` which tears the database down
15:08:34 <adnelson> I want those two functions to wrap my tests
15:08:59 <adnelson> but I also need the `Int` that `setupDb` returns to be available to my tests, so that they can use it to connect
15:09:41 <prsteele> what doesn't work with setupDb >>= (runReader yourTests) >> teardownDb ?
15:10:02 <adnelson> well I'd need to bracket it first of all
15:10:13 <adnelson> or else if the tests fail then the db wouldn't be torn down
15:10:25 <prsteele> true
15:10:43 <adnelson> and yeah I could write that kind of logic by hand, but I would imagine there's an idiomatic way to do this in hspec
15:11:40 <prsteele> I do not know of a way, sorry. this is *not* to say there isn't one, though  
15:11:56 <adnelson> no worries :) thanks
15:12:21 <MarcelineVQ> an example of a ReaderT based connection with bracket can be found here https://wiki.haskell.org/Roll_your_own_IRC_bot
15:12:31 <prsteele> I think when I did this type of thing I actually let the teardown steps fail, so I could inspect the DB after a failed test
15:13:52 <adnelson> that can be useful for sure
15:14:32 <[k-> tell me someone @tell'd me
15:14:55 <MarcelineVQ> [k-: lambdabot has become self-aware
15:14:59 <[k-> yay!
15:18:07 <MarcelineVQ> I have little experience with bracket but doesn't it already pass around what you want? mytest f = bracket setupDB (const tearDown) (\theInt -> f theInt)
15:23:01 <nomeata> Hi. Is something broken with haddock? http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Eq does not list the methods of Eq.
15:24:54 <glguy> nomeata: haddock doesn't appear to be impressed with the reexport
15:25:34 <hvr`> nomeata: there should be a ticket about it already somewhere
15:25:47 <nomeata> hvr`: ok, good.
15:26:05 <nomeata> (although I still have to teach my class different, without the help of the documentation)
15:26:24 <nomeata> https://github.com/haskell/haddock/issues/549
15:26:41 <MarcelineVQ> You can probably use an old version of the docs for now
15:27:02 <MarcelineVQ> http://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#t:Eq
15:32:54 * hackagebot yesod-auth-hashdb 1.5.1.3 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.5.1.3 (paulrouse)
15:44:26 <ph88> hey guys, with quickcheck how can i generate some specific characters ?
15:45:17 <kadoban> ph88: What do you mean?
15:45:19 <ph88> more specifically i want to generate 1 character out of a possible list of characters
15:45:33 <kadoban> Sounds like "oneof"
15:45:39 <kadoban> Or whatever it's called, think it's that.
15:45:48 <ph88> hhm ok
15:45:57 <glguy> ph88: Do you know about http://hackage.haskell.org/package/QuickCheck-2.9.1/docs/Test-QuickCheck.html ?
15:46:14 <glguy> Take a look at the "Generator combinators" section
15:46:18 <ph88> ok
15:46:37 <ph88> i think elements (i was already looking there because of oneOf)
15:48:03 <ph88> if i need to have 1 specific character i just make a list of 1 element ?
15:48:12 <ph88> oh wait .. pure
15:50:16 <adnelson> if I want to use the auto-generated Paths_mymodule stuff (e.g. to access data file paths from code), how do I set this up during development time to use data files relative to my source code? If I just put in `import Paths_mymodule` then ghci complains that it can't find that module.
15:50:35 <adnelson> (I want to have these files available when I run `cabal repl` or similar)
15:53:26 <filibustr> cd ..
15:53:30 <filibustr> :/
15:58:34 <nomeata> adnelson: Does "cabal repl" work for you?
15:58:34 <ph88> glguy, do you know how i can generate a list of 0 or 1 elements ?
15:58:52 <nomeata> adnelson: or you could add -ibuild/some/path to ghci’s command line
16:00:22 <glguy> ph88: with the same elements function 
16:00:45 <kadoban> ph88: Possibly: sublistOf [whatever]   You should check it can give an empty one though, and the full one.
16:05:47 <ph88> kadoban, hhmm not sure .. can't make much of the implementation  https://hackage.haskell.org/package/QuickCheck-2.9.1/docs/src/Test-QuickCheck-Gen.html#sublistOf
16:07:12 <glguy> The implementation indicates that each element is independently chosen to be in the list or not and that there isn't any special cases in it for empty list results
16:07:14 <glguy> so it should work
16:07:23 <ph88> i think it means either use the complete list or give back an empty list
16:07:37 <ph88> ooh it's for each element .. ok
16:07:43 <glguy> That's true when the complete list is one element long
16:08:54 <ph88> what if i already have a Gen though ?    like   Gen [a] -> Gen [a]  or  Gen [a] -> Gen []  ?
16:11:51 <ph88> eh that second thing isnt a valid type i guess .. i just mean that the output can be either a generator that creates an empty list or a list with element a
16:32:56 * hackagebot ekg-json 0.1.0.3 - JSON encoding of ekg metrics  https://hackage.haskell.org/package/ekg-json-0.1.0.3 (JohanTibell)
16:32:58 * hackagebot ekg 0.4.0.11 - Remote monitoring of processes  https://hackage.haskell.org/package/ekg-0.4.0.11 (JohanTibell)
16:34:23 <buglebudabey> is it a coincidence theres a mathematician by the name of Haskell Curry?
16:34:57 <amalloy> all the stuff is named after him
16:35:03 <buglebudabey> actually now that i read about him im realizing this
16:36:22 <buglebudabey> i think it's cool there are programming languages Brook and Curry as well
16:39:13 <cortex> If I have a type (type Bits [Bit]) defined as a list of another type (data Bit = One | Zero), how can I instantiate an item of it? [One, Zero] doesn't work.
16:39:42 <puregreen> type Bits = [Bit], or data Bits = Bits [Bit]?
16:39:53 <puregreen> if the former, then [One, Zero] should work
16:40:01 <puregreen> if the latter, then “Bits [One, Zero]”
16:40:15 <puregreen> the former is a type synonym, the latter is a new type
16:40:55 <jonored> If you used newtype, the answer is the same as for data: Bits [One, Zero]
16:40:56 <cortex> it is the former, but [One, Zero] is not accepted as a return value for my function with signature String -> Bits
16:41:18 <ReinH_> What is your code and what is the error?
16:41:23 <ReinH_> @lpaste
16:41:24 <lambdabot> Haskell pastebin: http://lpaste.net/
16:41:27 <amalloy> [One] is definitely of type Bits
16:41:51 <cortex> http://lpaste.net/193854
16:42:22 <puregreen> allSeqs doesn't accept any arguments, but it should
16:42:24 <amalloy> that function doesn't take a string argument
16:42:36 <puregreen> so it tries to interpret [Zero, One] as a one-argument function
16:42:39 <puregreen> and fails
16:42:51 <ReinH_> [Zeor, One] is not a function from String to Bits
16:42:55 <ReinH_> *Zero
16:42:59 <jmcarthur> allSeqs is not a function, but is expected to be one.
16:43:03 <jonored> allSeqs a = [One, Zero] should work there.
16:43:21 <cortex> ...allright =) That fixed it. The error message didn't really help though
16:43:24 <cortex> thanks!
16:43:28 <shachaf> "doesn't work" doesn't work as a problem description.
16:43:42 <Welkin> don't work?
16:43:52 <ReinH_> You didn't provide the error, so I'm not sure if it was helpful or not.
16:44:34 <ReinH_> > let f :: String -> (); f = () in f "string"
16:44:37 <lambdabot>  error:
16:44:37 <lambdabot>      • Couldn't match expected type ‘String -> ()’ with actual type ‘()’
16:44:37 <lambdabot>      • In the expression: ()
16:44:40 <ReinH_> That is a very helpful error.
16:44:54 <ReinH_> It tells you exactly what the problem is.
16:48:53 <cortex> Right, it makes sense if you understand that forgetting the argument makes it interpret my expression as a function, I guess I'm just not very used to reading haskell types
16:51:33 <jonored> cortex: Strictly speaking, that's probably more of a "not used to both having that kind of equational input and having functions all be first-class values in variables".
16:53:14 <cortex> jonored: Yes. I would like to have a suggestion how to improve the messages, because I have really struggeled with things like this, but I don't =)
16:56:17 <jonored> cortex: Not sure there's a way to for that particular bit - you've also got to support things like giving a type to foo in "foo = map bar" where foo really /is/ a function.
16:56:21 <Denommus> is there a framework like websharp for Haskell?
16:58:07 <jonored> Denommus: Have you looked at servant or yesod? Dunno how similar they are to websharp, but there are definitely server-side web frameworks about.
17:02:24 <cortex> jonored: I think what got me confused is that it was reported like this:
17:02:25 <cortex>     • Couldn't match expected type ‘String -> Bits’
17:02:25 <cortex>                   with actual type ‘[Bit]’
17:03:10 <cortex> i.e. it said that the actual type was [Bit], which kinda looks like it is not Bits, even though it actually is. Since they were different, I thought that is where the problem was, not in the String -> part
17:04:27 <cortex> When just reading that, it didn't seem entirely unreasonable to assume that it just omitted the part of the type that was actually correct
17:04:47 <ReinH_> Yeah, you have to know that when you say type Bits = [Bit], you are literally saying Bits = [Bit]
17:05:05 <ReinH_> and [Bit] = Bits
17:05:39 <cortex> Yes, I "knew" that, but since it didn't work I thought I was doing it wrong. So I came here for help. 
17:05:58 <cortex> ...which worked excellently btw! Thanks again for being so helpful!
17:06:05 <jonored> cortex: Ahh, fair. But, well, it doesn't, and you kinda do want the actual inferred type as the actual type - if you had two synonyms for String, and a function that used both, how should it tell which to report in an error message?
17:06:56 <jonored> (Especially if one of the arguments might be missing in the actual definition.)
17:10:41 <cortex> jonored: No, I don't have a good suggestion. If this particular error is a common newbie mistake, I suppose it could suggest that you forgot the argument if the type is correct except for the argument. 
17:11:54 --- mode: ChanServ set +o glguy
17:11:54 --- mode: glguy set +b-o $a:^5 glguy
17:14:21 <alex_new> very stupid question, does repa support complex numbers? 
17:14:25 <alex_new> )
17:21:37 <dmwit> cortex: Actually, it will tell you both the part of the type that didn't unify *and* the full type, when those aren't the same.
17:22:00 <dmwit> e.g. the message will say something like "Couldn't match expected type `Foo` with actual type `Bar` when trying to unify `() -> Foo` with `() -> Bar`".
17:22:29 <dmwit> cortex: So it was not stupid to think it omitted the part of the type that was correct -- it was just incorrect to assume it did that in one part of the message but not the other.
17:24:30 <dmwit> alex_new: I'm not sure, but a glance through the haddocks suggests that repa is pretty happy to store any old type.
17:25:20 <dmwit> alex_new: Of course the unboxed versions are often a different story. But http://hackage.haskell.org/package/repa-3.4.1.1/docs/Data-Array-Repa-Repr-Unboxed.html#t:Unbox lists an `(RealFloat a, Unbox a) => Unbox (Complex a)` instance, which sounds promising.
17:25:35 <alex_new> dmwit: hope so. any way, yarr does, maybe I will move to it
17:31:03 <benzrf> what is yarr o=
17:31:24 <alex_new> repa clone, some say it is faster
17:31:28 <benzrf> o
17:32:57 * hackagebot rdf4h 3.0.0 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-3.0.0 (RobStewart)
17:42:24 <clueless> hi
17:43:04 <milesrout> I think I have a situation where a Free monad is what I want. I currently have a little EDSL for doing natural deduction proofs.
17:43:30 <milesrout> So I have a type Formula = Atomic Blah | Conjunction Formula Formula | Disjunction …
17:44:11 <milesrout> and I have a type Deduction = Deduction (Set Formula) Formula i.e. a set of premisses and a conclusion
17:44:51 <milesrout> and I have a bunch of functions that take Deduction -> Except String Deduction (modulo me remembering how the Except/Error/ExceptT/ErrorT shit works)
17:45:58 <milesrout> but what I think I actually want is to take something like `do { dA <- assume a; dNA <- assume (Not a); dB <- implElim dNA dA; implIntro (Not a) dB }` and create a structure representing a natural deduction proof
17:46:33 <clueless> who or how am I supposed to ask about one question I have 
17:46:35 <milesrout> then have an interpreter that checks it, and another interpreter that writes it out using bussproofs-style LaTeX so I can copy-and-paste it into my thesis
17:46:38 <clueless> im a begineer in haskeel
17:47:02 <milesrout> is this what Free monads are basically made for? They seem to be used for this sort of build-up-a-structure-and-consume-it-in-multiple-ways pattern
17:47:04 <kadoban> clueless: Ask away
17:47:30 <milesrout> clueless: don’t ask to ask, just ask :)
17:49:37 <clueless> milesrout: hi!
17:52:48 <clueless> milesrout: so I have a script in Haskell that I'm supposed to translate to python, 
17:53:07 <milesrout> just ask the channel, not me specifically
17:53:22 <milesrout> I don’t know much about Haskell, I’m here to ask questions too
17:54:36 <clueless> select n lst g = help n lst g (length lst - 1) []   where  help 0 _ g _ ps     = (ps, g)          help n lst g max ps =  help (n-1) (left ++ right) g' (max-1) (pick : ps)            where (i, g') = randomR (0, max) g                  (left, pick : right) = splitAt i lst
17:54:45 <ReinH> @lpaste
17:54:45 <clueless> can someone help me go trhough this declaration?
17:54:45 <lambdabot> Haskell pastebin: http://lpaste.net/
17:54:57 <ReinH> clueless: use a paste in please
17:55:05 <c_wraith> is the ghcjs ffi actually documented anywhere?  I can't find it.
17:55:09 <ReinH> Pastebin
17:55:42 <ReinH> clueless: Haskell is whitespace sensitive, so we need to see the code verbatim
17:55:47 <clueless> http://lpaste.net/193934 can someone help me go over this script?
17:56:03 <clueless> sorry im just learning hwo to use freenode too
17:58:54 <c_wraith> clueless: ok.  It's written a bit densely, but the logic isn't complex.  What's your question?
17:59:15 <t4nk629> I'm planning to learn functional programming and decided on learning Haskell.  Any one have a good pet project idea to work on?  I have object oriented programming knowledge in C#
17:59:51 <clueless> c_wraith: thanks, just started learning haskell this week
18:00:09 <clueless> c_wraith: select n lst g = help n lst g (length lst - 1) [] first line .. there is 3 variables n lst and g
18:00:30 <hydraz> Yeah?
18:00:33 <c_wraith> t4nk629: throw out OOP knowledge, temporarily.  It will get in your way as you learn.  :)  (When you have a good handle on Haskell, the OOP knowledge won't get in your way any longer, and may even provide useful approaches sometimes)
18:00:51 <amalloy> t4nk629: my advice is to do programming exercises, like 99 problems or adventofcode.com. trying to solve someone else's set of problems will give you a good direction for what to learn
18:01:01 <kadoban> t4nk629: You're planning on actually learning the language before doing a project in it, right?
18:01:02 <amalloy> if you don't already have something you want to program, of course
18:01:09 <clueless> c_wraith: in the declaration though, from where does 'help' come from? or what is the function
18:01:22 <c_wraith> clueless: 'help' is defined in the where clause
18:01:42 <hydraz> clu​eless: `help' is defined in the wher- god damn it, I need to get faster
18:01:58 <c_wraith> clueless: lines 11 and 12 each contain an equation for it.  The two equations cover different cases on the value of the first argument.
18:02:31 <t4nk629> You would recommend programming exercises first?  Before tackling a project?
18:02:50 <hydraz> I would also recommend learning the language before those, t4nk629 :P
18:02:55 <amalloy> if you're looking for something to get your hands dirty, and you don't already have a project you want to do
18:03:00 <clueless> c_wraith: okay, I guess I am even more confused
18:03:00 <amalloy> then exercises are a good substitute
18:03:08 <clueless> c_wraith: baiscally, 
18:03:24 <clueless> c_wraith: select n lst g = help n lst g (length lst - 1) [] .. it starts by showing how the function would be called
18:03:25 <amalloy> but if you do have a project you're excited to implement, that's a great motivator
18:03:27 <kadoban> t4nk629: I'd recommend http://haskellbook.com/ , which has exercises in it
18:03:37 <clueless> c_wraith: then it declares the diff vars that will be used?
18:04:05 <clueless> c_wraith: after the 'where' is where it actually declares them to their values? 
18:04:11 <c_wraith> clueless: haskell doesn't care about use before definition.
18:04:21 <amalloy> is haskellbook actually good?
18:04:38 <c_wraith> clueless: line 10 calls the function declared in lines 11 and 12
18:04:52 <kadoban> amalloy: Ya, I like it, and a friend has done very well learning haskell from scratch in it
18:05:30 <t4nk629> Thanks for the input
18:05:34 <c_wraith> clueless: it's just like calling a function you define later in any other language.  Except for C or C++, because of their single-pass weirdness.
18:06:02 <Zemyla> What is the name for a recursive type where an f a may contain an f b for some b /= a!?
18:06:22 <c_wraith> Zemyla: irregular?
18:06:42 <Zemyla> Ahh, okay. Thanks.
18:07:07 <c_wraith> I'm not 100% certain of that terminology
18:07:21 <c_wraith> I just know it's usually found with polymorphic recursion.
18:09:39 <clueless> c_wraith: oh shit! I think I get it, give me a second to analyze it
18:09:51 <clueless> c_wraith: 
18:09:56 <clueless> c_wraith: basically here
18:10:07 <milesrout> clueless: plz no spammerino
18:10:43 <clueless> c_wraith: where  help 0 _ g _ ps     = (ps, g)          help n lst g max ps =  help (n-1) (left ++ right) g' (max-1) (pick : ps) it is saying, if the number next to help is zero, declare the function like this, otherwise the other one?
18:10:48 <clueless> milesrout: my b
18:11:49 <c_wraith> clueless: that is indeed what it's doing
18:11:58 <c_wraith> clueless: that's a form of pattern matching.
18:12:40 <c_wraith> clueless: functions are often declared with multiple equations and pattern matching is used to determine which is selected.
18:12:57 <Denommus> jonored: the thing about websharp is that it also does frontend seamlessly
18:13:00 <Denommus> jonored: like ocsigen
18:15:01 <c_wraith> clueless: one thing that formatting doesn't make clear is that "where" is a keyword.  It defines additional bindings in a series of declarations.
18:24:16 <MarLinn> I just found a trivial bug in ghci. Just enter -_ The only "bug" is an overly dramatic error message. Problem 1: I'm almost certain it should have been reported already, but I can't find a ticket. Problem 2: I can only test on 7.10.3 right now. Could someone with 8.0 do a quick test to see if it's still there?
18:24:34 <norotartagen> computers are just broken mathematics
18:24:36 <norotartagen> i've figured it out
18:24:50 <johnw> did you mean "_" or "-_"?
18:24:55 <johnw> I get the same error msg for both
18:25:25 <hydraz> MarLinn: You mean, ``· Found hole: _ :: a where a is a rigid type variable bound by the inferred type of it :: Num a => a at $location``?
18:25:29 <hydraz> Looks about right to me
18:25:57 <MarLinn> Yes, the holes thingies
18:25:59 <Cale> NOTABUG RESOLVED WONTFIX :D
18:26:09 <hydraz> ^
18:26:38 <MarLinn> the type hole message is ok, but my ghci also says "ghc: panic!" "report this" etc
18:26:46 <Cale> Oh, there's no panic here
18:26:51 <hydraz> Well, mine doesn't.
18:26:55 <Cale> http://lpaste.net/193960 is what I see
18:27:08 <hydraz> Same here
18:27:25 <clueless_> c_wraith: so, it basically says, when help is called with a zero next to it first
18:27:47 <clueless_> c_wraith: help 0 _ g _ ps     = (ps, g) 
18:28:16 <clueless_> we will use the ps and g values to create (ps,g)?
18:28:31 <MarLinn> Yeah, I get that from some functions, others panic as a bonus. But if you don't get it I suppose it's been fixed by now. Well, nothing to report, then!
18:28:36 <clueless_> c_wraith: we will use the ps and g values to create (ps,g)?
18:29:05 <clueless_> c_wraith: otherwise, help n lst g max ps =  help (n-1) (left ++ right) g' (max-1) (pick : ps)
18:29:35 <clueless_> we will use that help that ultimately will do : help (n-1) (left ++ right) g' (max-1) (pick : ps)
18:29:49 <clueless_> c_wraith: we will use that help that ultimately will do : help (n-1) (left ++ right) g' (max-1) (pick : ps)
18:30:47 <clueless_> c_wraith:and it declares that (i, g') = randomR (0, max) g
18:31:07 <clueless_> c_wraith: but I dont get why we are declaring that pair. . for what and how
18:32:50 <clueless_> help with this please http://lpaste.net/193934
18:34:10 <ReinH_> clueless_: do you know how pattern matching works?
18:34:18 <ReinH_> > let (x,y) = (1,2) in (y,x)
18:34:20 <lambdabot>  (2,1)
18:35:06 <clueless_> ReinH_: was that an example of pattern matching?
18:35:10 <ReinH_> yes
18:38:03 <kamog> I found cute exercises on the haskell wiki!
18:38:08 <clueless_> ReinH_: then yes, I think.. that is used in the help part right/
18:38:22 <clueless_> ReinH_: to decide which help definition to use
18:39:47 <ReinH_> and do you understand how x and y are bound to 1 and 2?
18:43:49 <jonored> Denommus: Ah, I see. yesod I'd say that the seams show (the client-side you get to pick which way you build javascript, and does typed interpolation sorts of stuff to help you with that), and servant I've not dug into enough yet.
18:46:34 <jonored> Denommus: I do expect we'll see a fairly seamless server-and-client FRP setup soon out of reflex (if nobody else gets there first, I'm going to do it for the server side, and it's already basically all there on the client side.)
19:02:55 <interzeller> is it possible ro use pattern matching with catamorphisms?
19:15:22 <kamog> 4 Problem 4 (*) Find the number of elements of a list.
19:32:59 * hackagebot micrologger 0.3.1.1 - A super simple logging module. Only for use for very simple projects.  https://hackage.haskell.org/package/micrologger-0.3.1.1 (savannidgerinel)
19:42:41 <dibblego> .wi
19:43:07 <dibblego> sorry, havin a shocker
19:43:52 <Denommus> jonored: not as seamless as websharp or ocsigen, though. They permit shared channels and signals
19:48:23 <jonored> Denommus: That does sound about like the expected result of "I want to be able to bridge FRP networks through a server over http".
19:54:36 <MarLinn> Such things also sound like "I don't care about accessibility or security-conscious visitors" and "good thing all users have high-end pcs so their browsers can virtualise my server". Not saying it's necessarily connected, but there's definitely a snake with an apple in that virtual dom
20:02:11 <norotartagen> css does not work, it's actually true
20:02:22 <norotartagen> i can confirm as a web developer
20:02:27 <norotartagen> it's not you, it is css
20:03:17 <norotartagen> abstraction is impossible
20:05:46 <norotartagen> i mean, the css spec writers are smarter than you anyway
20:05:58 <norotartagen> and they added flexbox, so quit complaining
20:07:13 <glguy> Wrong channel?
20:10:16 <geekosaur> or has one of those clients that doesnt make pm obvious
20:12:14 <capisce_> smart or not, they didn't anticipate modern web apps when css was originally designed
20:16:17 <dmj> capisce_: haskell's clay DSL abstracts css nicely
20:16:25 <dmj> @package clay
20:16:28 <lambdabot> http://hackage.haskell.org/package/clay
20:17:36 <norotartagen> the way i would describe it, the fundamental problem with css is that content is not container-aware, only viewport-aware
20:17:46 <norotartagen> css is for styling..... websites
20:17:54 <norotartagen> not (I repeat, not) parts of websites
20:18:24 <shachaf> norotartagen: This is not the channel for that.
20:21:11 <MarLinn> that reminds me: is there an easy way to have cabal run clay or haste functions to generate stuff at compile time so yesod can integrate it in its binary?
20:22:33 <dmj> MarLinn: you could use TH, but then also file-embed
20:22:45 <dmj> @file-embed
20:22:49 <dmj> @package file-embed
20:22:49 <lambdabot> Unknown command, try @list
20:22:53 <lambdabot> http://hackage.haskell.org/package/file-embed
20:23:00 <dibblego> norotartagen: Please stop immediately.
20:26:01 <MarLinn> dmj: yesod already uses file-embed (I think) to integrate its own flavour of templates. So you're implicitly saying cabal can produce "extra" files before compiling?
20:26:41 * norotartagen starts
20:26:45 <dmj> MarLinn: I'm saying template haskell can create files at compile time
20:26:46 <glguy> MarLinn: I don't think that you can specify arbitrary operations to run in a .cabal file, but you can extend a Setup.hs
20:27:16 --- mode: ChanServ set +q *!*@71-89-76-184.dhcp.bycy.mi.charter.com
20:30:34 <MarLinn> hmm... cabal can run preprocessors, so there should be a way, at least through hackery. I guess Setup.hs is indeed the best place to look. Thx.
20:33:00 * hackagebot chalk 0.1.0.2 - Terminal string styling.  https://hackage.haskell.org/package/chalk-0.1.0.2 (cattheory)
20:38:06 <dmj> if I modify a mutable vector with ST can I modify it further with IO at a later time
20:40:33 <dmj> don't think so
20:43:06 <nshepperd> you could unsafecoerce an STVector s into an IOVector
20:43:53 --- mode: ChanServ set -q *!*@71-89-76-184.dhcp.bycy.mi.charter.com
20:44:20 <nshepperd> that doesn't seem obviously evil
20:46:08 <dmj> devilish
20:47:09 <dmj> nshepperd: I have a PrimMonad m => v (PrimState m) Int
20:47:18 <dmj> I'd like to construct it with ST, but modify it with IO
20:49:50 <angerman> Say f :: a -> b -> m c, and I have m a and m b, do a' <- a; b' <- b; f a' b' would apply a and b to f. Is there some shorthand for that?
20:50:26 <c_wraith> Not that's really better.
20:50:35 <c_wraith> You could do tricks with join and liftM2
20:50:39 <c_wraith> But they're not an improvement
20:51:00 <glguy> angerman: f a' b' applies f to a' and the result of that to b'
20:51:53 <joobus> is it possible to derive a FromJson instance for a data type and also makeLenses``, or will the json instance have keys that start with an underscore?
20:52:22 <shachaf> c_wraith: I think join and liftA2 is an improvement.
20:52:30 <norotartagen> (sorry for the css rant, #haskell)
20:52:55 <shachaf> Well, with ApplicativeDo that do expression would turn into join and liftA2 anyway.
20:54:58 <angerman> c_wraith, glguy: that all seems kinda ugly :( I went from f <$> a <*> b to do a' <- a; b' <- b; f a' b'; as the underlying datatype changed from f a to f (Either e a)
20:55:50 <angerman> join $ f <$> a <*> b *does* look better though.
20:56:02 <nshepperd> dmj: yeah, you just need to unsafeCoerce the PrimState m into RealWorld
20:56:25 <glguy> angerman: I think the do-notation version is the available optimal solution there
20:56:49 <dmj> nshepperd: feels so wrong :(
20:57:45 <dmj> nshepperd: I'm looking for a way to purely construct a mutable vector, or a way to impurely modify an immutable vector
20:57:47 <nshepperd> I wonder why there isn't a vector function for doing this conversion anyway
20:58:10 <dmj> nshepperd: something with stToIO ..
20:58:43 <dmj> unsafeSTToIO :: ST s a -> IO a
20:58:47 <dmj> tada
20:59:37 <nshepperd> oh, I suppose it would be bad if you could runST and get a mutable vector out
20:59:51 <nshepperd> since you wouldn't know if it was shared
21:05:46 <dmj> nshepperd: ah, makes sense
21:06:54 <koz_> Are there any guides/tutorials to writing Haskell bindings to C libraries?
21:08:17 <dmj> koz_: check out inline-c
21:08:59 <angerman> glguy in absesense of applicativedo, this would turn into binds right? Which would (potentially) be less efficient than (join $ f <$> a <*> b) right?
21:09:20 <glguy> or potentially more efficient
21:10:02 <koz_> dmj: That is really cool - thanks!
21:11:12 <angerman> glguy right; so efficiency is probably a bad measure.
21:15:51 <caThe> hello, I have a problem for which I believe I should be using monad transformers, however, I'm not sure exactly how to proceed:  I have an (IO (Maybe a), and an IO (Maybe b)) and I need to persist the values to a db, how can I combine those two IOs so that I can pattern match on the Maybes ? 
21:16:59 <glguy> caThe: do mb1 <- action1; mb2 <- action2; case (mb1,mb2) of ....
21:18:06 <dmj> :t \f -> f <$> (undefined :: IO (Maybe a)) <*> (undefined :: IO (Maybe b))
21:18:12 <lambdabot> (Maybe a -> Maybe b1 -> b) -> IO b
21:22:59 <caThe> interesting, thanks
21:41:35 <adelbertc> hey all - does anyone have experience working with a model checker like Alloy or TLA+?
21:43:24 <hackrilege> hi, i prepared a paste, can anyone give me some tips? http://lpaste.net/194151
21:45:27 <hackrilege> the general feature seems to be defining constraining the undecidable instance, which normally is poor practice, but im taking this example to demonstrate its utility.
21:45:40 <hackrilege> i guess id like to discuss that approach in general
21:46:49 <hackrilege> admittedly it looks like a lot of overhead...
21:47:33 <hackrilege> but i like all the easy to define functions it generates
21:48:44 <hackrilege> there seems to be now way to remove the type constraining synonyms, the more general functions cast and convertf complain if not prescribed a fixed type, which the synonyms do well
21:49:24 <hackrilege> providing these synonyms to a module not using OverlappingInstances means its quite safe
21:53:33 <johnw> hackrilege: these feel like Lens Isos
21:54:14 <johnw> i.e., why reinvent the scaffolding, if lens will additionally give you a ton of tooling besides
21:55:28 <nshepperd> dmj: so I think you need something like unsafeSTToIO . fmap unsafeCoerce :: ST (STVector s a) -> IO (IOVector a)
21:55:54 <hackrilege> because im slowly rederiving only the bits of lens i need, both to aid my own understanding and to improve the presentation
21:56:36 <AndChat484449> Shdgbfsuw
21:57:44 <hackrilege> i would use lens if i could understand it
21:58:19 <c_wraith> You don't really need to understand it to understand it.
21:58:38 <norotartagen> i sense invisible quantifiers
21:58:43 <norotartagen> :P
21:59:11 <hackrilege> the documentation is not transparent
22:02:57 <c_wraith> The thing is, most of lens is implementation details.
22:04:02 <hackrilege> the point is i need to explain exactly how to implement the framework i use
22:04:53 <hackrilege> i can explain the prelude and the general principals of functional programming, but not the workings of lens
22:05:16 <hackrilege> all the unused overhead must be removed by me
22:06:03 <peddie> hackrilege: the thing that helped me understand what lens is doing was simon PJ's talk about lens on skillsmatter -- much more helpful than all the blog posts I've read put together
22:06:06 <hackrilege> so that i may present completely the implementation of the tools i am  designing
22:06:31 <hackrilege> that requires a subscription no?
22:06:48 <hackrilege> anyay my pooint about overhead remains
22:06:51 <peddie> I certainly didn't pay; I think I signed up for free with a dummy account
22:06:52 <c_wraith> It requires a login, but iirc, they're free
22:07:06 <hackrilege> im using NoImplicitPrelude for example
22:07:46 <c_wraith> The thing is, you can understand the basics of how lens works without understanding 99% of the lens library
22:08:01 <c_wraith> The basics are Lens, Traversal, Identity, and Const
22:08:31 <hackrilege> but i would still implement them completely in my presentation
22:08:53 <hackrilege> and may not need to
22:08:55 <peddie> hackrilege: there are also lens libraries that aren't called 'lens' and are much, much simpler if you want to understand
22:09:02 <c_wraith> That's all you need to implement them completely, unless you want things like Prism
22:09:28 <hackrilege> what i have which is apparently like ISO i have in about 6 lines.
22:10:51 <hackrilege> i dont want to have to defend why im not using lens everytime i write eve a small code fragment which resembles it but briefly, it adds unnecessary overhead. and id consider that closed
22:11:00 <hackrilege> even
22:11:51 <hackrilege> when its absorbed into prelude ill change my stance
22:12:19 <hackrilege> until then i program in haskell, not lens
22:12:39 <peddie> hackrilege: if you don't want to understand how lenses work, then don't :)  just trying to explain how you could go about removing whatever prevents you from reusing lots of hard work by clever people
22:13:16 <hackrilege> i will also do that hard work, fear not
22:13:46 <johnw> I just thought you'd prefer to focus on your actual problem, then spend your evening yak shaving libraries that have already been designed and fleshed out over several years; and you asked us for opinions on the utility of what you'd written, and my response is still that lens gives much better utility for that particular class of problems. But now you know, so please enjoy whichever approach you wish to take.
22:14:00 <hackrilege> but its literally the opposite of my priorities within this project
22:14:13 <hackrilege> which is for people who have never seen haskell before
22:14:59 <hackrilege> lens is a strait no go. i need to exhaustively describe all of my overhead, and i dont Need to describe the whole of lens, so im not going to
22:15:00 <johnw> I wouldn't ever give a person who'd never seen Haskell before code that relies on working around OverlappingInstances in some subtle way, as you described
22:15:28 <johnw> if they'd never seen Haskell before, I'd even avoid type classes
22:15:32 <johnw> just use conversion functions
22:15:40 <hackrilege> your right
22:17:30 <hackrilege> but i can explain away the Overlapping thing in an understandable way "these would go crazy if they hadnt been used properly, this is howthey are used properly" and then at least no one is left asking any questions i cant answer about how lens works
22:18:53 <hackrilege> and as its seems like a really common thing people might try to do with classes i guess i thought it warranted proper treatment
22:19:12 <johnw> OverlappingInstances?  It's common to avoid them.
22:19:19 <hackrilege> i guess i was looking for comments other than regarding that library i dont much appreciate
22:19:53 <hackrilege> there are reasons they should be avoided and ways they can be used safely, as is the point of this paste
22:20:00 <hackrilege> http://lpaste.net/194151
22:20:59 <hackrilege> namely in the use of the convertf function which is immediately delivered upon defining cast in both directions
22:21:15 <johnw> I have no further opinions on this, hackrilege 
22:21:24 <hackrilege> i guess one class wrapping class in both directions is an option, but so is the safe use of OverlappingInstances
22:23:10 <lpaste> glguy annotated “converting between list representations” with “converting between list representations (annotation)” at http://lpaste.net/194151#a194194
22:23:22 <glguy> There you go, no need to talk about two of the extensions
22:24:08 <hackrilege> sigh
22:24:22 <hackrilege> i guess i need a less trivial example where you cant just do that
22:24:35 <hackrilege> thanks though
22:25:44 <MarcelineVQ> What is your presentation?
22:25:59 <hackrilege> interacting subdomains of nd space
22:26:23 <lpaste> manyone pasted “perimeter” at http://lpaste.net/194197
22:27:25 <johnw> manyone: recs <- replicateM k getLine
22:27:49 <manyone> the 'perimeter' program i pasted runs and prints the points in the input - how do manipulate the list called 'recs'?
22:28:07 <johnw> how do you want to manipulate ti?
22:28:15 <hackrilege> i have a comonad instance for Free Zipper and im using it to load eg a string into eg a box. nearest neighbour interaction such as self intersection of the line is faster in the grid2d (when Zippers are incorperated) representation and the elastic force on the strand is fastest as a Zipper over the Map2d type
22:28:40 <hackrilege> its about the concept of nearest neighbours in projections of hilbert space
22:28:43 <manyone> ii want to map over it and split the components into pair - eg "1 34" -> (1,34)
22:29:07 <sbrg> manyone: :t span
22:29:12 <sbrg> :t span -- manyone
22:29:16 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
22:29:26 <johnw> you could also: mapM putStrLn $ map (\str -> split str) recs
22:29:29 <c0v3r7>   implode or explode
22:29:45 <johnw> a list is just a value, so you can transform that value using any expression of the proper type
22:29:50 <glguy> manyone: You can use "words" to split the string on spaces words
22:30:02 <glguy> manyone: readLn is a handy shortcut for getLine + read
22:30:23 <manyone> i can only do it outside the "do" block?
22:31:22 <manyone> im trying to do it after the mapM line ,inside the do, but it wont work
22:31:55 <hackrilege> eg "communicate force between only segments of a line lying in a local Cartesian region of fixed width"
22:32:20 <glguy> manyone: recs is in scope in the do-block starting at line 9
22:33:29 <hackrilege> it can be thought of as a line being carried by the flow of a fluid on the grid
22:34:01 <hackrilege> thats why my Grid2d contains lists as its element, they are line segments
22:34:16 <lpaste> glguy annotated “perimeter” with “perimeter (annotation)” at http://lpaste.net/194197#a194204
22:35:29 <manyone> thanks glguy let me try
22:36:04 <hackrilege> i think basically im revisiting the concept of stencils from Repa
22:38:48 <hackrilege> consider the difference between reorienting the whole line and then loading it into the grid as segments at each cell, or performing the transformation over the grid representation, transferring portions of the segments between adjacent cells
22:39:00 <hackrilege> its actually pretty funky in haskell...
22:40:05 <hackrilege> the ability of the Zipper to update the grid in much less than the time it would take to update each element makes this local opperations like this quite fast
22:40:19 <hackrilege> (subsections of the grid*)
22:41:37 <hackrilege> think eg drawing a continuous line in a bitmap image. the path can be traversed to access each element that needs to be updated, the unchanged elements need not be visited
22:43:01 <hackrilege> operations like the "paintbucket" tool are also fast using the Free Zipper Comonad instance
22:43:49 <hackrilege> (whih consists of constructing a zipper whoes elements are the input zipper at each configuration)
22:43:55 <hackrilege> which*
22:45:16 <nathyong> Is it worth using Data.Sequence over List?
22:45:38 <hackrilege> please check out the source for the Free List Zipper here; http://lpaste.net/194212
22:46:16 <nathyong> I'm wondering if I should convert all my functions to generalise them to Foldable/Traversable instead of [a]
22:46:25 <nathyong> (and then switching to Sequence)
22:47:01 <hackrilege> im finding its best just to work with lists nathyong
22:47:07 <nathyong> but if lazy ++ isn't much slower than Seq.|> then I can deal with a performance penalty...
22:47:11 <nathyong> yeah, it's a little troublesome
22:48:45 <nathyong> Also Set doesn't have a Traversable instance
22:49:06 <sbrg> |> is O(1)
22:49:10 <sbrg> ++ is O(n)
22:49:50 <sbrg> you should use what is most appropriate for what you're doing. in this case, Sequence is asymptotically faster if you're appending
22:50:43 <nathyong> sbrg: won't laziness cause it to fuse until necessary, resulting in one long ++ chain with the same O(n) cost as appending n elements using |>?
22:51:34 <mauke> no
22:51:57 <mauke> but DList can do that
22:52:01 <nathyong> oh, okay
22:53:47 <hackrilege> append xs ys = DL (unDL xs . unDL ys)
22:54:34 <nathyong> well, looks like I'm going to be using Sequence
22:54:37 <nathyong> thanks all
22:54:41 <hackrilege> fromList    = DL . (++)
22:55:13 <hackrilege> i cant see how that ends up being faster
22:56:20 <hackrilege> did anyone see this? http://lpaste.net/194212
22:56:22 <MarcelineVQ> you're assured right-associative construction
22:56:46 <hackrilege> is there a paper where i can read about it?
22:58:33 <MarcelineVQ> I'm not sure, they're called difference lists or Hughes lists afaik
22:58:44 <hackrilege> i can find it from that thanks
22:59:18 <alper> hello everyone. Can someone explain to me why this expression fails to compile?
22:59:22 <alper> 6 / (length [1,2,3])
22:59:40 <hackrilege> i get this; http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/lists.pdf
22:59:48 <peddie> > 6 / (length [1, 2, 3])
22:59:51 <lambdabot>  error:
22:59:51 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
22:59:51 <lambdabot>      • In the expression: 6 / (length [1, 2, 3])
23:00:07 <hackrilege> > 6 / (fromIntegral(length [1, 2, 3]) )
23:00:09 <lambdabot>  2.0
23:00:16 <hackrilege> :t fromIntegral
23:00:18 <lambdabot> (Num b, Integral a) => a -> b
23:00:27 <hackrilege> :t realToFrac
23:00:30 <lambdabot> (Real a, Fractional b) => a -> b
23:00:34 <peddie> 6 `div` (length [1, 2, 3])
23:00:39 <peddie> > 6 `div` (length [1, 2, 3])
23:00:42 <lambdabot>  2
23:01:25 <mauke> alper: length returns Int. Int doesn't support /
23:01:49 <alper> > :t (/)
23:01:56 <lambdabot>  mueval-core: Time limit exceededmueval: ExitFailure 1
23:02:40 <hackrilege> :t ((/).fromIntegral.length)
23:02:48 <lambdabot> (Foldable t, Fractional a) => t a1 -> a -> a
23:03:29 <hackrilege> oh no i always get point free things with 2 arguments wrong
23:03:40 <alper> Why does the expression 6 / (length [1,2,3]) not reduce to 6 / 2? 6 / 2 works
23:03:49 <mauke> alper: length returns Int. Int doesn't support /
23:03:49 <hackrilege> :t 2
23:03:51 <lambdabot> Num t => t
23:04:12 <hackrilege> :t (length [0,1])
23:04:14 <lambdabot> Int
23:04:38 <peddie> :t (/)
23:04:41 <lambdabot> Fractional a => a -> a -> a
23:05:10 <hackrilege> :t 2.0
23:05:12 <lambdabot> Fractional t => t
23:05:19 <MarcelineVQ> (only spamming types doesn't help someone who's confused about types :>)
23:06:06 <hackrilege> 2 is a Num, Num contains both Ints and Fractionals
23:06:47 <hackrilege> the compiler picks the Fractional 2.0 when you write 6/2, but it cant do that when you write 6/(2::Int)
23:07:02 <hackrilege> > 6/(2::Int)
23:07:05 <lambdabot>  error:
23:07:06 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
23:07:06 <lambdabot>      • In the expression: 6 / (2 :: Int)
23:07:11 <hackrilege> which is the same error you get
23:07:15 <revtintin> \q
23:07:54 <alper> So Num is a type that can be converted into a fraction and the return type of the length function is not a type that can be converted into a fraction?
23:08:25 <hackrilege> Num is anything with (+) and (*) and fromIntegral
23:08:31 <hackrilege> and abs
23:08:34 <ongy> alper: Num is not a type, but a class
23:08:35 <hackrilege> and signum
23:08:40 <mauke> alper: Num is not a type. Haskell doesn't convert types
23:08:41 <hackrilege> i think thats it
23:09:11 <mauke> also, hackrilege is confusing things by talking about Int vs Fractional. Int is a type, but Fractional isn't
23:09:19 <mauke> Fractional is a class, like Num
23:09:34 <hackrilege> so as Doubles and Ints support those functions, they have Num instances
23:10:16 <hackrilege> Fractional is a subclass of Num, in addition to having those functions i just gave it also has (/) and fromRational
23:10:32 <hackrilege> i think thats right anyway, sorry i should check
23:10:59 <hackrilege> Double has a Fractional instance, Int only has a Num instance
23:11:34 <mauke> it's like this: numeric types in haskell mainly fall in two groups, integral and fractional numbers
23:11:47 <hackrilege> its because eg 1/2 is not an int. its about making sure when you do the opperations defined over a group you dont end up with something not in that grup
23:11:48 <mauke> integral numbers support div and mod, fractional numbers support /
23:11:53 <alper> why does div work?
23:11:55 <alper> >6 `div` (length [1,2,3])
23:12:07 <hackrilege> thats just defined over Int
23:12:07 <mauke> Int is integral
23:12:19 <hackrilege> > 6.0 `div` (length [1,2,3])
23:12:26 <lambdabot>  mueval-core: Time limit exceeded
23:12:44 <hackrilege> well that should break because 6.0 is not an Int
23:12:47 <hackrilege> :t 6.0
23:12:53 <lambdabot> Fractional t => t
23:13:00 <hackrilege> :t div
23:13:02 <lambdabot> Integral a => a -> a -> a
23:13:34 <hackrilege> a common cheat is to use floor
23:13:38 <hackrilege> :t floor
23:13:40 <lambdabot> (RealFrac a, Integral b) => a -> b
23:13:48 <hackrilege> floor 6.0
23:13:53 <hackrilege> > floor 6.0
23:13:56 <lambdabot>  6
