00:23:10 <jle`> "IO is just State Realworld"
00:32:40 <{AS}> Is there a quickcheck combinator like listOf
00:32:42 <{AS}> but is bounded in size?
00:32:58 <MarcelineVQ> iirc vectorOf
00:33:08 <{AS}> MarcelineVQ: thanks!
00:33:15 <{AS}> but doesn't that produce with exact size?
00:33:22 <MarcelineVQ> yes
00:33:42 <{AS}> I want something which is at most a particular size
00:34:32 <MarcelineVQ> ah alright well listOf is what you want, you'll need to use resize with it though
00:34:59 <Guest23478> I'm using megaparsec to parse semicolon-separated statements like so: http://lpaste.net/218529 I would now like to handle "return" separately. But return is also separated with a semicolon. Is there an elegant way to give this additional stop condition to megaparsec?
00:35:09 <{AS}> MarcelineVQ: Oh, so I can resize listOf?
00:35:13 <{AS}> Thanks
00:35:15 * hackagebot servant-aeson-specs 0.5.2.0 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.5.2.0 (mchaver)
00:35:33 <MarcelineVQ> probably, I've not played with it I have to admit, but that's the purpose of resize so I hope so
00:37:41 <{AS}> > resize 2 (listOf arbitrary)
00:37:43 <lambdabot>  error:
00:37:43 <lambdabot>      • No instance for (Show (Gen [a0]))
00:37:43 <lambdabot>          arising from a use of ‘show_M359629572812319898327764’
00:38:05 <{AS}> :t resize 2 (listOf arbitrary)
00:38:07 <lambdabot> Arbitrary a => Gen [a]
00:38:22 <{AS}> OK, I will try that
00:41:20 <MarcelineVQ> lambdabot doesn't seem to like it when I use quickcheck, but something like this should work correctly: > quickCheck $ forAll (resize 3 $ listOf arbitrary) ((<=3) . length)
00:41:56 <{AS}> Yeah, it returns me <IO ()>
00:42:07 <MarcelineVQ> there's also verboseCheck if you want to see what's going on
00:42:11 <{AS}> I guess quickcheck uses some IO which is not supported in the sandbox interface
00:42:19 <jle`> you can use @check
00:42:28 <{AS}> @check forAll (resize 3 $ listOf arbitrary) ((<=3) . length)
00:42:31 <lambdabot>  +++ OK, passed 100 tests.
00:42:35 <{AS}> Ah, cool
00:43:04 <jle`> @check forAll (resize 3 $ listOf arbitrary) ((<= 4) . length)
00:43:07 <lambdabot>  +++ OK, passed 100 tests.
00:43:11 <jle`> oh
00:43:15 <jle`> @check forAll (resize 3 $ listOf arbitrary) ((<= 2) . length)
00:43:15 <{AS}> @check forAll (resize 3 $ listOf arbitrary) ((<= 2) . length)
00:43:18 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
00:43:18 <lambdabot>  [(),(),()]
00:43:18 <jle`> lol
00:43:21 <lambdabot>  *** Failed! Falsifiable (after 11 tests):
00:43:21 <lambdabot>  [(),(),()]
00:43:21 <MarcelineVQ> :>
00:48:20 <Guest23478> Or maybe an easier version: can I somehow separate the input and apply different parsers on the left and right half?
00:50:57 <grantwu> I think so?
00:51:01 <grantwu> Just find the return statement in the input
00:58:43 <lyxia> Guest23478: do you mean that the return statement is always last?
00:59:04 <Guest23478> lyxia: it is
00:59:45 <grantwu> Are you trying to short circuit parsing after you find the return?
01:02:11 <grantwu> ertes: How do I post to the libraries mailing list?
01:03:35 <lyxia> Guest23478: how about   liftA2 (\stmts ret -> stmts ++ [ret]) (endBy stmt' psemi) returnStmt   ?
01:18:02 <Guest61> hi all
01:19:15 <Guest23478> lyxia: that sounds like a start, thank you
01:24:01 <Guest61> whats this channel about?
01:24:15 <cocreature> Guest61: it’s about the haskell programming language
01:26:01 <Guest61> interesting
01:26:23 <Guest61> i was pointed to this channel by a friend of mine
01:27:25 <Guest23478> grantwu: sorry, haven't seen your response. Thank you anyway. :)
01:38:06 <Insanity_> how can I install this? https://hackage.haskell.org/package/mysql
01:38:22 <Insanity_> using cabal install I get errors, just as when using the Setup.lhs
01:38:36 <Insanity_> "No instance for (ConstOrId..)"
01:39:02 <Insanity_> Is it looking for something like "mysql_config"? 
01:39:57 <Insanity_> nevermind, seems like it is a problem with the version of ghc/cabal that I'm using: https://github.com/bos/mysql/issues/20
01:40:36 <merijn> Insanity_: I generally advice people to stick with current version -1 of GHC to avoid these sorts of issues
01:41:07 <Insanity_> Would indeed have been a good idea, thanks
01:41:44 <merijn> Insanity_: It usually takes 6 months to a year for the entire ecosystem to be updated/compatible. So unless you need a specific feature/bugfix of the latest GHC OR plan to spend a lot of time writing patches, I usually stick with the previous stable one :)
01:42:19 <Insanity_> Sounds like good advice :-) 
01:44:57 <merijn> @remember Unknown Godel's incompetence theorem. The incompleteness theorem is you can't prove it, the incompetence theorem is YOU can't prove it.
01:44:57 <lambdabot> Okay.
01:57:43 * ocramz is doing his `cata` katas
01:58:35 <ocramz> basic folds are everywhere
01:59:50 <MarcelineVQ> Like in coffee filters
02:03:48 <merijn> :cq
02:06:46 <ccapndave> Morning.  Is it a general pattern to have a mkSomething function (with some optional arguments) to make a Something?
02:08:12 <geekosaur> in cases where you need to hide the constructor to preserve invariants, yes
02:08:13 <lyxia> it is sometimes called "smart constructor"
02:08:15 <merijn> ccapndave: If you want to hide the constructors of Something it is
02:08:20 <ccapndave> Cool
02:08:21 <ccapndave> Thanks
02:09:26 <merijn> ccapndave: If you want "optional" arguments there's two main approaches: 1) have a most general construction function and partially apply it for common cases or 2) use a record datatype with config options and provide a "default" record that people can override
02:10:20 <ccapndave> merijn: Actually I'm using Elm which doesn't have typeclasses or higher typed kinds (yet) so I don't think a more general construction function is possible
02:11:01 <ccapndave> But the default record approach works great.  And that could be implemented as a mkSomething function with no arguments to keep the pattern
02:11:23 <grantwu> I think by "more general construction function" merijn just means like
02:11:41 <ccapndave> I think I meant higher kinded types, not higher typed kinds
02:12:01 <grantwu> mkSomething rarelyChangedOption sometimesChangedOption frequentlyChangedOption
02:12:14 <ccapndave> Ah I see :)
02:14:10 <merijn> grantwu++
02:14:25 <grantwu> Does elm not have ML style structures either?
02:35:18 * hackagebot protobuf-simple 0.1.0.2 - Simple Protocol Buffers library (proto2)  https://hackage.haskell.org/package/protobuf-simple-0.1.0.2 (mrijkeboer)
02:35:20 * hackagebot fortran-src 0.1.0.4 - Parser and anlyses for Fortran standards 66, 77, 90.  https://hackage.haskell.org/package/fortran-src-0.1.0.4 (DominicOrchard)
02:35:22 * hackagebot aeson-extra 0.4.0.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.4.0.0 (phadej)
02:35:27 <ocramz> hullo!
02:36:07 <Rembane> Good morning!
02:37:33 <ocramz> I'm looking at `linear`, where we can find `liftU2 :: (a -> a -> a) -> f a -> f a -> f a` and `liftI2 :: (a -> b -> c) -> f a -> f b -> f c`: lifting binary functionals over the union and intersection of two container types
02:38:05 <ocramz> I was wondering what ways are there to make the types more specific?
02:38:40 <ocramz> to represent those set operations, I mean
02:40:32 <intothem1untains> What monad would make sense for a data Pair a = P a a?
02:41:12 <Rembane> intothem1untains: What operations would you like to run on the pair?
02:41:26 <tdammers> without further semantics, I would say none
02:41:36 <intothem1untains> Rembane: None, it is just an exercise
02:41:36 <liste> intothem1untains: do you mean a monad instance?
02:41:42 <intothem1untains> liste: yes
02:41:50 <liste> so "instance Monad Pair where ... "
02:41:53 <intothem1untains> P x j >>= g (x, j) of course can't be
02:42:19 <intothem1untains> Sorry, P x j >>= g = g (x, j)
02:42:19 <merijn> I would say there's two possible instances for Pair, I'm not sure whether they're both lawful or only one is
02:42:29 <intothem1untains> merijn: which ones?
02:42:35 <intothem1untains> g x and g j?
02:43:04 <kqr> quick question that was more difficult than I thought to find on google: where do I put my own stack template for it to be useable?
02:43:16 <merijn> intothem1untains: Right, but I'm not sure the laws hold :)
02:43:24 <merijn> intothem1untains: It's a good exercise to try and find out, though :p
02:43:33 <ocramz> kqr : submit a PR ?
02:43:34 <intothem1untains> merijn: yeah, i doubt they do
02:43:40 <merijn> intothem1untains: I'm not so sure
02:43:55 <intothem1untains> merijn: the identity law doesn't hold
02:44:03 <kqr> ocramz, huh so no way to just have my private one?
02:44:31 <merijn> intothem1untains: There's only one sensible return "return x = Pair x x", but I suppose that doesn't work well with "x >>= return = x"
02:45:33 <merijn> intothem1untains: Well, you could do "(Pair x y) >>= f" "case (f x, f y) of (Pair x _, Pair _ y) -> Pair x y"
02:45:45 <merijn> Which would make "x >>= return" hold
02:45:52 <merijn> But I'm not sure about the rest...
02:46:08 * intothem1untains is trying to follow merijn 
02:46:32 <kqr> merijn, could you not make "Pair x y >>= f = f y"?
02:46:37 <merijn> intothem1untains: Basically, apply the function twice and only use half of the Pair of it's result. Which might not be very sensible, but it's not obviously wrong
02:46:50 <merijn> kqr: No, then "x >>= return = x" doesn't hold
02:47:06 <kqr> merijn, oh right sorry of course
02:47:55 <intothem1untains> merijn: oh, i see
02:48:01 <merijn> I'm honestly not sure if that works out :)
02:48:40 <intothem1untains> better to leave instance Monad Pair undefined then
02:49:01 <intothem1untains> time to have breakfast!
02:51:26 <merijn> Left and right identity for return work that way
02:51:38 <merijn> So, the question is associativity and my gut says that works out too
02:51:56 <kqr> it feels a bit silly that you can't create your own private stack templates (if it is indeed the case that you can't). I like some parts from all templates (protolude prelude, ISC license and so on) but it's highly unlikely anybody will find something that's perfect for them
02:52:23 <merijn> intothem1untains: So, to answer, there probably is a Monad for Pair, but whether you consider it "making sense" is up to the observer ;)
02:53:00 <merijn> tbh, imo, trying to prove monads without regards for their sensibility is good practice :)
02:53:20 <kqr> if kmett has taught me anything it's to make stuff instances of everything you can and figure out what good it does later
02:53:44 <geekosaur> https://docs.haskellstack.org/en/stable/GUIDE/#fun-features
02:53:53 <geekosaur> kqr ^^
02:54:03 <kqr> geekosaur, YES that is a fun feature! thanks
02:55:43 <merijn> kqr: IF there is a unique instance
02:55:51 <merijn> kqr: If there are multiple, better not commit to one yet
02:55:57 <kqr> merijn, good point
02:56:01 <kqr> newtype all the things!
03:08:17 <ThomasLocke> Hey all. I could use some advice/feedback. I have a 105kloc stack written in Dart, that is currently in production. It is fairly standard REST project, with browser clients hooking up against a bunch of REST interfaces. Where should I start looking if I'd like to write such an application in Haskell, maybe with Elm for the client?
03:08:34 <ThomasLocke> There seems to be quite a lot of frameworks. The current system relies very heavily on JSON.
03:08:55 <ThomasLocke> So I would probably need something that works well with JSON out of the box.
03:10:50 <ocramz> kqr : I was wondering about the possibility as well but then I started just using the preexisting ones. I quite like https://github.com/commercialhaskell/stack-templates/blob/master/franklinchen.hsfiles
03:20:03 <kqr> ThomasLocke, have you checked out servant? it's very popular among people who create rest services
03:21:09 <kqr> ThomasLocke, basically you specify which endpoints you have in the type system and it pretty much generates your code for you as far as I understand it
03:21:23 <kqr> ThomasLocke, it integrates well with JSON, which is probably also the most popular serialization format used with it
03:22:26 <kqr> ocramz, neat! I'll include some of the good parts from that template into mine
03:49:09 <ThomasLocke> kqr, Thanks. I'll take a look.
04:02:18 <kqr> anyone familiar with this error? http://lpaste.net/1623484070086311936
04:02:48 <kqr> ah never mind
04:02:48 <{AS}> Is there a common interface between smallcheck and quickcheck?
04:02:58 <{AS}> I want to avoid writing a property twice :)
04:03:00 <kqr> build-depends can not refer to executables
04:03:31 <kqr> damnit does that mean I at last have to split my projects into library/executable
04:07:08 <lyxia> {AS}: why are you writing properties twice, aren't they just functions -> Bool ?
04:07:29 <{AS}> lyxia: if I want to use implications etc. then no
04:07:45 <{AS}> and e.g. forAll
04:08:26 <lyxia> Ah I see.
04:08:47 <lyxia> no idea :/
04:09:23 <{AS}> thanks anyway :)
04:10:22 <kqr> is there a stack command to run your program? other than stack exec -- myprogram
04:11:13 <Wizek_> kqr, You may not have to define a "library" section in your cabal file: you may also just include the same files and dependencies
04:11:37 <romildo> How is the name (or how is it pronounced) of the () type?
04:11:42 <lyxia> romildo: unit
04:11:43 <merijn> romildo: "Unit"
04:11:43 <Phosphero> Hi folks - what's the recommended library for parsing / verifying / creating JWT tokens? there's two that I've been able to find, one with documentation that hasn't been updated since april, and one that's been updated very recently but I can't find any documentation for.
04:11:54 <kqr> Wizek_, yes, I saw that, but it's probably about time I split it up anyway :)
04:12:02 <merijn> kqr: What's the problem with splitting your project into an executable and library?
04:12:12 <merijn> kqr: You realise you can have both in the same cabal file? :)
04:12:14 <Wizek_> kqr, about `stack run`: http://stackoverflow.com/a/35107441/499478
04:12:24 <kqr> none whatsoever, merijn. it's just something I haven't done intentionally so far, so I'm not in the habit of doing it
04:12:45 <kqr> merijn, doesn't help that like 99% of my haskell programs are simple 50-line scripts...
04:12:49 <merijn> kqr: I usually develop everything as a library and then add a trivial executable shim around that :p
04:12:58 <kqr> yes, that's the correct way to do it
04:13:27 <kqr> Wizek_, neat! I wonder why this isn't a stack feature
04:13:57 <ocramz> Is there some State-based construct to monitor convergence? i.e. inspect the previous N states 
04:19:29 <kqr> are there arbitrary-range integer types in haskell? like in Ada I can say "Cell is an integer ranging from 0 to 15". this is obviously checked at run-time, but still. is there something like this?
04:19:56 <kqr> or are you meant to newtype with smart constructors yourself
04:20:16 <merijn> kqr: Nothing like that, you can either use newtypes + smart constructor or Liquid Haskell
04:21:50 <liste> @hackage refined -- there's also this
04:21:50 <lambdabot> http://hackage.haskell.org/package/refined -- there's also this
04:22:03 <liste> probably other packages too
04:35:20 * hackagebot http-api-data 0.3.1 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.3.1 (NickolayKudasov)
04:41:55 <{AS}> I am looking for a function Either b a-> Maybe a
04:42:01 <{AS}> I can't seem to find one on Hoogle
04:42:03 <{AS}> @hoogle Either b a-> Maybe a
04:42:06 <lambdabot> package base
04:42:06 <lambdabot> package bytestring
04:42:06 <lambdabot> package containers
04:42:55 <tabaqui> is expression like
04:42:58 <tabaqui> func :: IO()
04:43:01 <tabaqui> func = do func
04:43:08 <tabaqui> is tail recursion?
04:43:16 <{AS}> tabaqui: do is just syntax
04:43:30 <merijn> do is redundant there
04:43:45 <tabaqui> right, it's more complicated function
04:43:57 <nkpart> {AS}: http://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Combinators.html
04:43:58 <merijn> It's not a function
04:44:04 <{AS}> nkpart: thanks
04:44:07 <nkpart> has rightToMaybe
04:44:09 <tabaqui> well, well, like so:
04:44:14 <tabaqui> connect :: IO()
04:44:18 <tabaqui> connect = do
04:44:44 <tabaqui>     catch (AMQP.connect addr port) (\_ -> connect)
04:44:56 <tabaqui> is it a tail recursion?
04:45:01 <{AS}> That I think is not tail recursive
04:45:10 <merijn> tabaqui: No, but it doesn't matter
04:45:56 <{AS}> Haskell could probably eliminate the continuation to tail recursion if it was sufficiently smart
04:45:59 <{AS}> I am unsure if it does
04:46:49 <merijn> {AS}: GHC compiles everything to, effectively, CPS. So depending on your point of view, either EVERYTHING is tail call, or nothing is
04:47:33 <{AS}> merijn: You mean it uses a continuation-based abstract machine?
04:47:37 <merijn> tabaqui: You don't leak memory by not doing tail recursion, because tail call optimisation is meant to avoid memory leaks caused by function call stacks
04:47:48 <merijn> tabaqui: However, GHC doesn't *have* a function call stack
04:48:24 <merijn> {AS}: STG consists of function application and case-of analysis, essentially. And case-of is basically CPS if you squint a little :)
04:48:54 <merijn> {AS}: Because after committing to a branch in case you never have to return
04:49:21 <{AS}> merijn: that is true
04:49:31 <tabaqui> merijn: no stack call, but how it does...
04:49:37 <tabaqui> merijn: what about AST
04:49:43 <tabaqui> merijn: ?
04:51:06 <{AS}> I think it would turn something like quicksort ps ++ [x] ++ quicksort qs to quicksort ps (\ps' -> quicksort qs (\qs' -> ps ++ [x] ++ qs)) 
04:51:21 <{AS}> ps' ++ [x] ++ qs' that is
04:51:46 <merijn> tabaqui: I don't understand your question?
04:51:57 <{AS}> merijn: but anyway, it can drop making a larger continuation 
04:52:00 <{AS}> in this case
04:52:15 <merijn> {AS}: I always recommend the STG paper as good starting point to have an intuition :)
04:52:28 <{AS}> merijn: Link please?
04:52:38 <tabaqui> merijn: abstract syntax tree - it's a presentation of function calls
04:52:57 <merijn> {AS}: https://pdfs.semanticscholar.org/5c70/ed80977204a5b84f1f02764d6c3b5d9b8185.pdf
04:53:03 <{AS}> Thanks!
04:53:14 <tabaqui> merijn: "connect" depends on "connect" depends on "connect"
04:53:27 <tabaqui> merijn: haskell is lazy, yes, but stack is still a stack
04:53:37 <merijn> {AS}: A bit outdated compared to how GHC implements things nowadays, but it's nicely comprehensive and not a terrible approximation of how GHC compiles
04:53:52 <{AS}> thanks
04:54:02 <merijn> tabaqui: Abstract syntax tree has nothing to do with presentation of function calls. And how does 'connect' depend on connect?
04:54:28 <merijn> {AS}: There's also a later paper that reflects on some described implementations in the STG paper called "How to make a fast curry"
04:54:51 <{AS}> ah cool
04:55:48 <tabaqui> merijn: "connect" should return some result outside
04:56:00 <tabaqui> merijn: to know this result it calls another "connect"
04:56:02 <merijn> tabaqui: "return" to where?
04:56:26 <tabaqui> merijn: to function that calls "connect" previously
04:57:02 <tenniscp25> does your hindent (5.2.1) ignore ~/.hindent.yaml?
04:59:19 <merijn> tabaqui: Also, note that connect is still not a function. And what do you suppose 'connect' "returns"?
05:00:03 <NickHu> What does 'canonical form' mean when you talk about a haskell function?
05:00:04 <tabaqui> merijn: why it's not a function? it returns I/O action
05:00:24 <merijn> NickHu: Context?
05:00:45 <NickHu> https://wiki.haskell.org/Typeclassopedia#Laws_2
05:00:47 <merijn> tabaqui: It doesn't take an argument. Functions take arguments (well, function take *one* argument, to be precise)
05:01:49 <tabaqui> merijn: function "putChar" takes an argument, but it's IO monadic too,
05:02:45 <merijn> NickHu: "Canonical" generally means "according to or ordered by canon law." or more generally a sort of "standard rule", in this case it's describing the standard form after the term
05:02:49 <merijn> NickHu: "only a single use of pure at the very beginning and only left-nested occurrences of (<*>)."
05:03:10 <{AS}> merijn: I have made a more readable non-type 3 font version of that paper if you are interested
05:03:11 <NickHu> Does it basically mean normalisation to a form like pure f <*> x <*> y <*> z etc.
05:03:14 <NickHu> ?
05:03:14 <merijn> tabaqui: putChar is a function that returns an IO action, yes.
05:03:20 <merijn> NickHu: Yeah
05:03:48 <merijn> {AS}: I have a more readable copy, there used to be one on the Microsoft Research site, but they changed the site and all links bit-rotted
05:04:00 <{AS}> Ah
05:04:12 <NickHu> Would it be correct to say that this puts pure on the left-outermost node of the syntax tree?
05:04:38 <merijn> NickHu: That sounds right, but I'm too tired and lazy to think enough to ensure that it is :)
05:04:53 <tabaqui> merijn: fine, but it doesn't make things clear
05:04:58 <{AS}> merijn: This https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf ?
05:05:25 <{AS}> It seems they converted the fonts, but with an ugly conversion :)
05:05:48 <merijn> {AS}: The very original is a postscript file, so it depends on the quality of the PDF conversion
05:05:55 <NickHu> merijn: Actually I'm not sure it would, because left-outermost would surely imply that you'd bracket my example like this: (pure) (f <*> x <*> y <*> z)
05:05:58 <NickHu> Which is wrong, right?
05:06:22 <{AS}> Yeah, anyway, I found my conversion a bit better
05:06:27 <{AS}> so that is good :)
05:07:05 <merijn> NickHu: oh, yeah, you're right
05:07:27 <merijn> "pure f" would always be a left hand branch of a <*>
05:07:57 <{AS}> Isn't that why you use the f <$> x <*> y <*> z ?
05:08:18 <merijn> {AS}: Personally I use that because of readability :)
05:08:24 <{AS}> since pure f <*> x ~ f <$> x
05:08:28 <merijn> <$> is less noise than "pure f <*>"
05:12:55 <{AS}> merijn: so Haskell doesn't do defunctorization?
05:15:37 <merijn> {AS}: I'm not familiar with the term?
05:16:09 <{AS}> merijn: It is the elimination of higher-order functions
05:16:20 <merijn> {AS}: oh, no, definitely not
05:16:40 <merijn> {AS}: Note, that you probably mean *GHC* doesn't do defunctorization ;)
05:16:55 <{AS}> Yeah
05:17:03 <{AS}> defunctionalization, sorry
05:17:13 <merijn> {AS}: Anyway, GHC will do lots of inlining based on it's heuristics (how expensive/large) functions are and use that to enable further optimisation/rewriting
05:18:24 <merijn> {AS}: But it doesn't necessarily eliminate all higher-order functions.
05:18:36 <{AS}> Aha
05:19:49 <ggole> Do you mean defunctionalisation? Defunctorisation usually means elimination of modules in SML.
05:20:29 <{AS}> ggole: Yeah, I tried to correct it --> {AS}: defunctionalization, sorry
05:20:39 <ggole> Ah
05:20:43 <merijn> ggole: To be fair, the SML documentation of defunctorise that the SML usage is wrong :p
05:20:51 <ggole> Usually it's whole program compilers that do that
05:20:56 <ggole> (Although partial defunctionalisation is possible.)
05:21:10 <merijn> ggole: MLton documentation "This pass is grossly misnamed and does not perform defunctorization."
05:21:38 <merijn> hmm, maybe I misread that
05:21:39 <merijn> anyway
05:24:34 <fr33domlover> Q: If I make a clean `stack build` of a package and all its deps, during the long build process, often GHC stops 4-5 times with an error "strange closure type, report bug" something like that. Then I run `stack build` again and it continues, and eventually the build does succeed. But I wonder, why does it happen? And why does one build produce that error and the next one not? isn't the compilation process a
05:24:37 <fr33domlover> pure computation that should always have the same result?
05:25:53 <int-e> fr33domlover: I had such a problem with building ghc once... turned out one bit in my computer's memory was faulty
05:27:43 <fr33domlover> int-e, hmm interesting. but i don't seem to have any such visible errors in other programs, just GHC having these errors
05:27:52 <nathyong> How do I tell ghc to inspect a particular directory for header files when using LANGUAGE CPP?
05:28:39 <merijn> nathyong: Blind guess: -I
05:29:50 <nathyong> let's see if it works
05:30:01 <nathyong> hmm, npoe
05:34:36 <adnauseam> hello  folks, cansomeone please explain what minimal complete means ? 
05:34:39 <adnauseam> im unsure of the meaning 
05:34:54 <hpc> in what context?
05:35:22 * hackagebot yesod-bin 1.4.18.4 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18.4 (MichaelSnoyman)
05:35:47 <fr33domlover> adnauseam, you mean minimal complete class instance by chance?
05:36:00 <adnauseam> in haskell, and in general in math - what's a minimally complete function definition ?
05:36:38 <adnauseam> ive done some googling, found a few stack exchange posts that shot over my head, and a wiki article about o-completeness, but it's written pretty formally 
05:37:16 <merijn> adnauseam: Where did you find the term? i.e., what context?
05:38:10 <adnauseam> example https://mail.haskell.org/pipermail/libraries/2013-May/020110.html
05:38:26 <adnauseam> and its an uni FP course 
05:38:38 <ertesx> grantwu: https://mail.haskell.org/mailman/listinfo/libraries
05:39:01 <merijn> adnauseam: That refers to typeclasses, are you familiar with typeclasses already?
05:39:15 <adnauseam> sure 
05:40:10 <merijn> adnauseam: So, let's take "class Eq a where x == y = not (x /= y); x /= y = not (x == y)" <- this class defines two functions (==) and (/=), and each has a "default" definition that can be overwritten
05:40:51 <merijn> adnauseam: Right now == calls /= and vice versa, which means that if you call == you get an infinite recursion. But if I overwrite == then they both work!
05:41:03 <adnauseam> yeah i was thinking thew professor was talking about things that sounded very much like polymorphism, but for small functions 
05:41:04 <merijn> adnauseam: Similarly, if I overwrite /= they also both work
05:41:39 <merijn> adnauseam: So, a minimal complete definition = "the minimum number of functions I need to explicitly define to make ALL functions of a typeclass work"
05:41:53 <merijn> In case of Eq, the minimal complete definition is "== OR /="
05:42:14 <adnauseam> what did you mean by overwrite over there?
05:42:43 <adnauseam> define it for my /new/ type ie the type im applying it to ?
05:42:44 <merijn> adnauseam: When you write an instance of a class you can define the implementation of functions of that class
05:42:53 <adnauseam> ah yes, ofcourse 
05:43:00 <nathyong> merijn: it was indeed -I, but I didn't need a space; thanks for the heads up
05:43:12 <NickHu> I know you have to take bottom out of Hask to make it behave nicely as a category, but is this the same as taking out general recursion?
05:43:12 <adnauseam> is ok to think of this as primitives in other languages ?
05:43:32 <merijn> adnauseam: "instance Eq MyFoo where Foo x == Foo y = x == y" <- didn't define /=, so it defaults to the "default definition" of "not (x == y)"
05:43:35 <adnauseam> primitive types + primitive functions, sort of like the GL subset of OpenGL et al
05:43:56 <jonored_> adnauseam: Incidentally, I'm not aware of a context-independent mathematical meaning for "minimal complete" apart from the "smallest" of something that has some property that complete is being used for.
05:44:47 <Rembane> Good morning, I want to get the ManagerSettings from options in wreq using a lens, but I can'
05:44:55 <adnauseam> yeah, it sounds as if someone renamed primitives to minimally complete,  but i guess they wanted to be very specific and primitives wasn't sufficient 
05:45:10 <Rembane> Good morning, I want to get the ManagerSettings from options in wreq using a lens, but I can't get my head around it. How do I do this? https://hackage.haskell.org/package/wreq-0.4.1.0/docs/Network-Wreq.html#v:manager
05:45:27 <ertesx> NickHu: you have to?  as far as i see Hask is fine as it is, but to answer your question: yeah, you would take out general recursion
05:46:02 <NickHu> Well I mean having bottom and general recursion in your system means the same thing (ish) doesn't it?
05:46:34 <jophish> Is this at all interesting: replace :: a -> f b -> f a; (every Functor can implement this with <$)
05:46:55 <jophish> I'm actually interested in coreplace :: f a -> Either a (f b)
05:47:07 <quchen> :t ($>)
05:47:09 <lambdabot> error:
05:47:09 <lambdabot>     • Variable not in scope: $>
05:47:09 <lambdabot>     • Perhaps you meant one of these:
05:47:12 <ertesx> NickHu: it's not quite the same thing: you can have bottom without general recursion, but you can't have general recursion without bottom
05:47:13 <quchen> Huh?
05:47:37 <quchen> :t (Data.Functor.$>)
05:47:39 <lambdabot> Functor f => f a -> b -> f b
05:47:52 <adnauseam> thank you that extremely helpful 
05:48:00 <quchen> jophish: It’s already in Data.Functor. :-)
05:48:17 <NickHu> ertesx: I see. I suppose you could just have bottom to be an error term or something rather than something which never terminates
05:48:40 <quchen> Oh wait, what you asked for is actually already <$, you just wanted to give it a nicer name. Nevermind.
05:48:46 <NickHu> If we take out general recursion, does that mean we can't use Applicative for context-sensitive parsing?
05:48:53 <ertesx> NickHu: they are the same thing
05:49:01 <jophish> quchen: not exactly, I'm actually just interested in coreplace
05:49:08 <ertesx> (error term vs. infinite loop)
05:49:19 <{AS}> NickHu: There are total parser combinators
05:49:23 <jophish> Either, Maybe and Identity can implement coreplace
05:49:36 <{AS}> NickHu: http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators.html
05:49:37 <jophish> but I'm wondering if there's anything more to the story
05:49:59 <ertesx> NickHu: not quite, parser combinators can be defined coinductively
05:51:23 <NickHu> Oh I see, so you get basically a much larger tree with applicatives and rely on laziness to help you not die to inefficiency
05:51:34 <NickHu> But this only works for finite alphabets
05:51:37 <jophish> It's almost like Comonad, except that the value might be empty
05:51:44 <jophish> I'm not sure how to express that well
05:52:20 <quchen> jophish: What laws do you expect for your abstraction?
05:52:53 <jophish> quchen: I'm trying to figure that out myself. I *think* there should be some sort of inverse with pure
05:53:21 <ertesx> NickHu: coinductive parsing would mean that your parser has to produce all the time…  as long as it does that, it can keep matching
05:53:25 <ertesx> indefinitely
05:53:35 <ertesx> or rather *not* matching
05:53:36 <quchen> The inverse of pure is extract. Are you looking for an extract-with-fallback?
05:53:43 <jophish> At the moment the class is called "Single" and the coreplace allows one to extract the single element of a Functor or nothing
05:54:01 <jophish> quchen: yes, I suppose
05:54:14 <jophish> I don't think I can come up with anything particularly rigorous 
05:54:20 <NickHu> I think I read something which pointed to a paper which talked about how you could do very efficient context free parsing with applicatives and laziness; does anyone know what paper I might be thinking of?
05:55:21 <ertesx> NickHu: are you sure it was applicative?  there is a superset of that using arrows (it's basically the original motivation for arrows)
05:55:28 <NickHu> I'm not sure
05:55:35 <NickHu> It might have even been a link to a blog post
05:55:51 <NickHu> Does laziness have anything to do with context free parsing with applicatives?
05:55:59 <ertesx> NickHu: applicative parsers have the ability to match in parallel
05:56:11 <ertesx> which means: you can drop entire branches early
05:56:25 <ertesx> the best way to see that is to just implement it yourself
05:56:32 <NickHu> Yes, because the applicative functor cannot make choices in the chain
05:57:07 <ertesx> it doesn't have to be efficient to see how it works:  data Parser a r = Done r | Fail | More (Set a) (Maybe a -> Parser a r)
05:57:38 <ertesx> the difference is in the Set:  it specifies which characters the parser accepts as the next
05:57:45 <ertesx> s/characters/tokens/
05:57:54 <ertesx> this information can be used by (<|>)
06:08:28 <pavonia> Is there a way to somehow make a do-block reference to a variable the is defined later in that block, like do { when b $ jump end; ...; end <- label }? I'm trying to define a monad that builds a list of (JumpMark, Command) values where the jump marks are somehow automagically computed by the commands given in the do-block
06:09:19 <quchen> pavonia: Yes, but it’s horrible or confusing. :-)
06:09:23 <quchen> ?google reverse state monad
06:09:24 <lambdabot> https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
06:09:30 <lyxia> mfix !
06:09:42 <quchen> ?google goto in haskell
06:09:43 <lambdabot> https://www.reddit.com/r/haskell/comments/1jk06q/goto_in_haskell/
06:10:46 <raek_> MonadFix perhaps?
06:12:18 <pavonia> Which of these is the less confusing option? :)
06:12:31 <quchen> Not reverse state.
06:12:37 <quchen> Reverse state is never the less confusing option.
06:12:42 <quchen> It’s the benchmark of crazy code.
06:12:50 <jonored_> But... Tardis monad.
06:12:58 <jonored_> Do both :)
06:13:07 <quchen> (Crazy code is measured in μReverseState)
06:13:17 <quchen> Tardis is 2 ReverseState. :-)
06:14:26 <athan> What do you call the process of turning a Word64 into a series of Word8s?
06:14:36 <athan> de-significantdigitization?
06:14:51 <merijn> athan: "truncation"?
06:15:01 <athan> I think you're right merijin
06:15:05 <athan> but I want to retain the value
06:15:17 <athan> so `fromChars . toChars` == id
06:15:23 <pavonia> Okay, thanks for the suggestions, I'll have a closer look at them
06:15:57 <merijn> I understand mfix as long as I don't think about it too hard :p
06:17:12 <athan> If I was to consume a list of Word8s and turn it into an unbounded Integer, could I do so via a catamorphism alone, or does it need to be hylomorphic?
06:17:38 <athan> to allocate the "significance so far" if doing a left fold (I think :s)
06:18:18 <lyxia> "chunksOf" at the bit level
06:19:08 <athan> Or maybe I could `zipWith` the [0..] - wait... wrong direction. It would work with [..0]! I think
06:19:24 <athan> lyxia: basically yeah
06:20:06 <jle`> athan: how are you consuming a list of word8s ?
06:20:13 <jle`> sum . fromIntegral ?
06:20:47 <mnoonan> athan: can't you just cata with [] -> 0 and (x:n) -> x + 256*n?
06:21:08 <athan> jle`: I'm not really, realistically my stack would blow
06:21:16 <athan> but that's what I'm trying to figure out
06:21:24 <jle`> athan: i mean, how is the result supposed to depend on the word8's ?
06:21:32 <jle`> is `const 1` acceptable?
06:21:36 <athan> mnoonan: That's what I thought at first, but I don't know if it's right :s
06:21:55 <athan> jle`: Each Word8 represents a digit
06:21:57 <mnoonan> Sure, if your list is little-endian at least
06:22:11 <jle`> ah
06:22:16 <athan> hmm
06:22:22 <mnoonan> er, big-endian rather
06:22:34 <mnoonan> no, little endian :)
06:24:20 <Kuros`> i love big endians and i cannot lie
06:30:24 <NickHu> Could I describe an expression like ((a * b) * c) to only 'contain left associative instances of *', or is there perhaps a clearer way?
06:32:33 <pavonia> You mean such that a * b * c is parsed as (a * b) * c?
06:34:48 <ertesx> pavonia: mfix is the *correct* way
06:34:57 <yulax> ok i'm in a haskell lecture. regarding programming interesting  tasks, what is good resource to challenge a beginner
06:35:13 <NickHu> Sort of; to clarify, I'm not saying anything about the way the operator fixes
06:35:23 * hackagebot camfort 0.901 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.901 (DominicOrchard)
06:35:24 <Rembane> yulax: https://projecteuler.net/
06:35:35 <ertesx> pavonia: monads that are supposed to allow that specifically are instances of MonadFix, and then you can use a very convenient notation by enabling -XRecursiveDo
06:35:42 <NickHu> Rather, an expression like a * (b * c) would 'contain only right associative instances of *'
06:35:44 <yulax> ooh
06:35:55 <NickHu> The issue is, I don't know if I mean associative here or whether I mean a different word
06:36:20 <ertesx> pavonia: example using -XRecursiveDo:  do rec { y <- f x; x <- f y }; pure (x + y)
06:37:34 <pavonia> > let f x = [x-1] in do rec { y <- f x; x <- f y }; pure (x + y)
06:37:38 <lambdabot>  <hint>:1:31: error:
06:37:38 <lambdabot>      parse error on input ‘<-’
06:37:38 <lambdabot>      Perhaps this statement should be within a 'do' block?
06:38:18 <pavonia> NickHu: What do you mean by "contain an instance" here?
06:38:34 <NickHu> As in it's in the expression
06:38:42 <jle`> Rembane: probably a bad idea for learning a language
06:39:40 <pavonia> NickHu: So (a *b) * (c * d) would translate to (
06:39:43 <pavonia> err
06:39:49 <Rembane> jle`: Yes, you only learn a strange subset of a language hacking on those problems.
06:40:02 <pavonia> Yeah, to what would that tranlsate? :p
06:40:14 <NickHu> It doesn't matter because I don't need to talk about it
06:40:19 <iphy> http://hastebin.com/ivocihotok.hs <- any idea how to implement the "implement" function?
06:40:49 <iphy> so, what it should do is put any pure function into the Server monad
06:41:00 <NickHu> If I said an expression that contains only left associative instances of *, is it clear that it means something like (((a * b) * c) * d?
06:41:06 <{AS}> is there a reason why mfix is not just defined per default as mfix f = join (f <$> mfix f) ? 
06:41:11 <NickHu> Maybe I mean left associating instances of *?
06:41:33 <jle`> NickHu: the association of * isn't a property of the instances
06:41:43 <jle`> the instances can't define the associativity
06:41:44 <NickHu> I'm not talking about instances
06:41:50 <jle`> so, what are you talking about?
06:42:04 <iphy> given addI :: Interface (Int -> Int -> Returns Int), I want: implement addI (+) :: Int -> Int -> Server Int
06:42:06 <NickHu> I'm using instance in the English sense of the word, as in, there is an instance of => the expression contains this
06:43:04 <NickHu> 1 + 2 -- there is an instance of the operator + in this expression
06:43:08 <jle`> can you rephrase your original question in this english sense?
06:43:35 <jle`> do you mean maybe 'occurrence' ?
06:43:46 <NickHu> Occurrence and instance are synonyms
06:43:53 <NickHu> But yes, sure
06:44:10 <pavonia> NickHu: If you'd allow a terminating element, you could define a type like [] where (:) can only have right-associative recursion
06:44:41 <NickHu> Yes I understand that, I'm not asking anything about Haskell semantics, just English
06:44:49 <Cale> NickHu: The convention about whether (*) associates to the left or not doesn't tend to change in the middle of an expression...
06:45:07 <NickHu> Cale: Yeah, hence why I don't think I mean the word associative here
06:45:14 <Cale> But if (*) associates to the left, then a * b * c * d means ((a * b) * c) * d
06:45:14 <NickHu> Problem is, I can't think of the right word
06:45:41 <Cale> "associates to the left" or "left associative" is the usual way to say it...
06:46:11 <NickHu> Is it accurate to describe the expression ((a * b) * c) as containing only left associating occurences of the * operator?
06:46:18 <bollu> I want to use the GHCJS api
06:46:20 <bollu> how does it work?
06:46:36 <NickHu> It's important in the context of what I'm writing to emphasise that * associates to the left
06:46:43 <jle`> NickHu: well, ((a * b) * c) doesn't care about the associativity of *
06:46:50 <Cale> I don't know whether (a * b) counts as a left-associated instance of (*)
06:46:53 <jle`> * can be right-associative, but ((a*b)*c) is unambiguous because of its parentheses
06:47:00 <Cale> But perhaps, depending on how you define that :)
06:47:03 <ertesx> :t \f -> do rec { x <- f x }; pure x
06:47:05 <lambdabot> error:
06:47:05 <lambdabot>     parse error on input ‘<-’
06:47:05 <lambdabot>     Perhaps this statement should be within a 'do' block?
06:47:11 <ertesx> :t \f -> do { rec { x <- f x }; pure x }
06:47:13 <lambdabot> error:
06:47:13 <lambdabot>     parse error on input ‘<-’
06:47:13 <lambdabot>     Perhaps this statement should be within a 'do' block?
06:47:25 <jle`> but, if * is left-associative, then a*b*c is (a*b)*c
06:49:19 <ertesx> "left-associative" is a weird term…  it sounds like it should be an algebraic property when it's really just a syntactic feature
06:49:36 <slack1256> When people say GADT = existential + equality, I don't understand the equality part
06:49:37 <Cale> Well, it's clear what NickHu wants to express, I think
06:49:58 <Cale> He's trying to say that, for example, the expression contains no occurrences of a subexpression of the form (a * (b * c))
06:50:05 <NickHu> Yes, that's pretty much it
06:50:20 <slack1256> do they mean stuff like 'data Refl a b where { Relf :: Relf a a }' that unifies a with b? if so unification is clearer than "equality"
06:50:30 <ertesx> slack1256: most likely it means that constructors can restrict arguments to the type
06:50:42 <Cale> (i.e. any such subexpression has had associativity applied to it to rewrite it to ((a * b) * c)
06:50:47 <Cale> )
06:50:55 <NickHu> ^ Yes, that's bang on what I mean
06:51:25 <slack1256> ertesx: probably, still have problems seeing why name that equality
06:51:27 <ertesx> slack1256: but there is an equivalent expression of that in terms of equality constraints (as introduced by -XTypeFamilies) and CPS
06:51:36 <ertesx> slack1256: so yeah, it most likely means that
06:52:25 <ertesx> slack1256: newtype Eq a b = Eq { fromEq :: forall r. ((a ~ b) => r) -> r }
06:52:46 <Cale> bollu: Is there something in particular you wanted to know? I'm assuming you're talking about the GHCJS.DOM library, or else the stuff in ghcjs-base?
06:52:56 <Cale> bollu: That's a lot of explaining to do...
06:54:19 <bollu> Cale: remember the webGL examples I'd written? I want to port them to use GHCJS
06:54:45 <bollu> Cale: my (admittedly grandiose) aim is to be able to use diagrams to describe stuff to render, which then uses canvas / webgl / what have you to render in a page
06:54:59 <bollu> Cale: It would lead to wicked expressive webpages in a couple lines of haskell (is the hope)
06:55:10 <bollu> Cale: think it's feasible?
06:55:19 <Cale> http://web.mit.edu/greghale/Public/ghcjs-dom-ghcjs/html/ghcjs-dom/doc-index-All.html -- documentation for ghcjs-dom as compiled with ghcjs itself
06:55:36 <bollu> Cale: ghcjs is a GHC compiler extension right?
06:55:46 <Cale> Er, maybe the contents page would be better: http://web.mit.edu/greghale/Public/ghcjs-dom-ghcjs/html/ghcjs-dom/index.html
06:55:53 <Cale> bollu: sort of
06:56:10 <Cale> Practically speaking, it's a separate compiler
06:56:19 <Cale> But it shares most of its code with GHC
06:56:33 <bollu> Cale: I see
06:56:41 <bollu> Cale: so do the two projects pull from each other?
06:56:47 <Cale> If you haven't yet installed it, I recommend getting it via reflex-platform -- at least if you're not really short on disk space
06:56:55 <bollu> I'll do that then
06:57:04 <Cale> I'm sure luite would upstream things as appropriate
06:58:39 <bollu> cool, thanks :) I'll build it and get things working first, then
06:58:52 <Cale> bollu: Don't build ghcjs yourself, unless you want to hack on it
06:59:12 <Cale> Just clone this https://github.com/reflex-frp/reflex-platform
06:59:24 <Cale> and then you'll find a "try-reflex" script in there
06:59:25 <bollu> yeah, I'm just following the instructions: 	1.	./try-reflex
06:59:25 <bollu> 	2.	
06:59:29 <bollu> whoops
06:59:29 <Cale> as well as work-on
06:59:31 <bollu> https://github.com/reflex-frp/reflex-platform
06:59:55 <iphy> any idea how to implement liftF :: Applicative m => Proxy (a -> Returns b) -> (a -> b) -> (a -> m b) -- where Returns is newtype Returns r = Returns r
07:00:02 <bollu> Cale: the output is a webpage, right? index.html + main.js or something?
07:00:08 <Cale> yeah, roughly
07:00:37 <Cale> You get foo.jsexe which is a directory containing a simple index.html which is enough to load the javascript, and a bunch of javascript.
07:00:56 <Cale> You're allowed to edit the html, and it'll preserve any changes to that
07:01:13 <Cale> (on subsequent compiles)
07:01:16 <bollu> oh, okay. neat
07:01:30 <bollu> Cale: what's the overhead? with respect to "vanilla" code?
07:02:02 <Cale> I haven't done much testing myself, but I believe Ryan has said something like about 4x slower than native code.
07:02:10 <bollu> ouuch. 
07:02:15 <Cale> Which is... usually totally acceptable
07:02:20 <bollu> well, okay. Let's see how much that translates to
07:02:25 <bollu> I want to write graphics code :)
07:02:37 <Cale> I mean, that's slower than *native code*
07:03:26 <Cale> Not comparing to hand-written Javascript
07:07:37 <tdammers> 4x slower than native is pretty good actually
07:08:14 <tdammers> IIRC, "2x slower than native" is already considered excellent for any higher-level language, and we're talking about running inside a browser here, rather than directly on metal
07:09:28 <ertesx> iphy: f _ g x = pure (g x)
07:10:33 <Welkin> tdammers: but is it isomorphic and webscale?
07:10:53 <Welkin> tdammers: oh, and non-blocking!?
07:12:18 <M-Purple> Is the Haskell client abandoned?
07:12:18 <ertesx> no, it's only epic
07:12:30 <Welkin> what haskell client?
07:12:33 <ertesx> M-Purple: "the haskell client"?
07:13:21 <iphy> ertesx: yeah, I did that wrong
07:13:28 <netblaze> sex
07:13:49 <iphy> ertesx: I actually mean http://hastebin.com/ivocihotok.hs 
07:14:18 <ertesx> iphy: blank page
07:14:27 <ertesx> (in a pretty colour at least)
07:14:31 <tdammers> Welkin: just throw in elasticsearch, you'll get webscale for free
07:16:05 <M-Purple> I thought this was a matrix room. Its bridged to irc
07:16:15 <M-Purple> https://github.com/Xe/morpheus
07:16:20 <Welkin> ?
07:16:29 <Welkin> what is matrix?
07:16:44 <Xe> yeah, i have been meaning to work on that more, but i have had the depressions.
07:19:18 <{AS}> Is there a debugging guide for GHC?
07:19:39 <mniip> what kind of debugging
07:19:57 <{AS}> Uh, quickCheck is hanging
07:20:09 <mniip> debugging haskell code with haskell tools?
07:20:09 <{AS}> and verboseCheck is producing the Matrix on my computer
07:20:13 <{AS}> mniip: Yeah
07:20:50 <mniip> hmm
07:20:51 <ertesx> so much linear algebra talk this afternoon
07:20:55 <mniip> there's the ghci debugger
07:21:01 <iphy> ertesx: http://hastebin.com/raw/ivocihotok
07:21:09 <{AS}> mniip: I will take a look
07:21:12 <Lokathor> did somebody say "webscale"? :D
07:21:21 <mniip> did someone say mongodb
07:21:26 <Welkin> nope
07:21:29 <Welkin> no one said that
07:21:41 <{AS}> Is this #node ?
07:22:10 <ertesx> iphy: from which library are you importing those modules?
07:22:29 <ertesx> or:  how are HaskellType and ServerType defined?
07:22:29 <iphy> I'll make a testcase
07:22:35 <iphy> it doesn't matter
07:22:38 <iphy> any monad transformer is fine
07:22:47 <iphy> forget 'call' also
07:23:40 <ertesx> iphy: in any case it looks to me like you're looking for a monad morphism between two specific monads
07:24:30 <ertesx> if that's the case, there is no general answer
07:30:56 <learning> When importing a module in ghci it is often listed on the left side, but eventually this starts to unnecessarily take space. Is there a way to avoid that?
07:31:35 <learning> besides import qualified
07:31:44 <Welkin> you mean the prompt?
07:31:52 <Welkin> use :set
07:32:38 <Welkin> :set prompt "<new prompt>"
07:32:50 <Welkin> you can put that in yout .ghci as well so it loads every time
07:32:55 <Welkin> I replace mine with a lambda
07:33:55 <Welkin> learning: type `:help` to see all the options in ghci
07:34:13 <ph88> for some reason the parser i wrote expects another \ in the input string and i can't figure out why ..  https://paste.fedoraproject.org/435399/82682014/
07:34:50 <learning> I'm referring to this -> Prelude Control.Monad> replicateM 5 $ putStrLn "kittens"   . Notice how Control.MOnad is on the left side. Is there a way to avoid that when importing modules?
07:36:49 <Welkin> yes
07:36:51 <Welkin> I just told you
07:37:11 <learning> I see. So setting the prompt will remove that behavior. I didn't completely understand. Thank you.
07:37:14 <mnoonan> Is there an F-algebra trick for writing something like cata/fold, except where the patterns might involve nested constructors? e.g. Nil -> Even, Cons _ (Cons x) -> x, Cons _ Nil -> Odd?
07:37:42 <learning> I thought that would only change the Prelude bit. I didn't realize that would stop the library notification bit as well.
07:38:18 <learning> Thank you very much.
07:41:55 <geekosaur> learning, specifically if there is a %s in the prompt then it is replaced with the current module import list. the default prompt is "%s> "
07:49:28 <learning> Thank you for the clarification. It was getting a bit annoying and I appreciate the help
08:07:05 <iphy> ertesx: http://hastebin.com/raw/lomuxalaqe
08:09:19 <{AS}> Is there a reason why Haskell doesn't introduce sharing for functions in constant applicative form?
08:09:29 <{AS}> as discussed here: https://www.reddit.com/r/haskell/comments/33ml04/definition_of_fix/
08:12:50 <kqr> was *> or <* invented first?
08:12:59 <kqr> and when would you want to use one over the other? purely stylistic?
08:14:30 <ertesx> iphy: you can't go from any monad to any other (than itself) without extra information
08:14:37 <lyxia> {AS}: Then you can't write functions when you don't want sharing.
08:14:49 <iphy> ertesx:  Returns is not a monad
08:14:49 <ertesx> iphy: in other words 'implement' should be a member of IsReturnType
08:14:58 <{AS}> lyxia: at what point would one like that? :)
08:15:00 <iphy> it's just a newtype that marks the end of the function type
08:15:07 <{AS}> I thought increase sharing = good?
08:15:30 <ertesx> iphy: 'Returns' doesn't seem relevant to 'implement'
08:16:16 <iphy> addInterface :: Interface (Int -> Int -> Returns int)
08:16:44 <iphy> implement addInterface (+) :: Int -> Int -> ServerT IO Int -- or something
08:17:16 <iphy> "implement" should be a function that applies all arguments and then does 'pure' on the result
08:17:49 <lyxia> {AS}: you don't want to share things that are cheaper to compute than to store and fetch
08:18:27 <{AS}> Ah
08:19:24 <lyxia> That is either really small values, or really large values that sit there and do nothing most of the time. I don't have any concrete example to point to at the moment though.
08:20:19 <lyxia> Anyway, the point is that sharing is not 100% good, so you don't want to cut off any options.
08:20:29 <{AS}> I see
08:26:39 <iphy> ertesx: http://hastebin.com/raw/erohoguwaz
08:27:42 <joncol> Hi, using Parsec, is there a nice way to "apply" a parser between N and M times? (N, M are Ints). I guess I could do it by replicateM N combined with (optional "" (count M) parse), but maybe there is a better way?
08:28:21 <joncol> Or that combo doesn't work exactly.
08:29:22 <fr33domlover> joncol, i never used parsec but i used other parsers and i just wrote a small utility function for that myself
08:30:33 <fr33domlover> between N and M = require N times, then optional M times
08:30:59 <joncol> fr33domlover: Yes, that would work.
08:31:11 <fr33domlover> with replicateM you can do the first part
08:31:19 <fr33domlover> the required N times, and get the result in a list
08:32:37 <joncol> fr33domlover: But how to prevent it from matching input data where there is *more* than the "allowed" number M?
08:33:38 <joncol> fr33domlover: I guess I could just fail if I parse another one after M optionals...
08:35:26 * hackagebot haiji 0.1.0.1 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.1.0.1 (NoriyukiOhkawa)
08:40:22 <ph88> for some reason the parser i wrote expects another \ in the input string and i can't figure out why ..  https://paste.fedoraproject.org/435399/82682014/
08:42:27 <{AS}> So Uniplate is not transitive
08:42:28 <{AS}> ?
08:42:42 <{AS}> so if you have Biplate A B and Biplate B C, you don't have Biplate A C, right?
08:52:30 <kqr> which is the "best" parser-combinator library on hackage? i haven't been active in a while and I know there are a lot of "replacements" for parsec
08:52:47 <{AS}> kqr: what are you parsing?
08:52:48 <ph88> not sure kqr but i'm using megaparsec
08:53:19 <{AS}> There is no really single best library
08:56:00 <kqr> {AS}, a very simple custom format describing a board game. i'm writing a tool to help me generate data for a school assignment, so I don't have to do that manually
08:56:11 <iphy> http://hastebin.com/raw/bezagupuyo <- if I use "implement" instead of "undefined", it fails
08:56:15 <kqr> ph88, ah yes. megaparsec and trifecta are probably the big ones I've heard of
08:56:18 <{AS}> kqr: I would guess that attro-parsec might be what you need
08:56:23 <iphy> even though implement has the type signature I need
08:56:34 <{AS}> attoparsec
08:56:39 <kqr> {AS}, I could cetrainly get away with attoparsec, which used to be my favourite!
09:01:33 <cocreature> kqr: generally I go with megaparsec/trifecta for human generated input so I get decent error messages and attoparsec for machine generated input where error messages are not that important
09:02:04 <ph88> cocreature, could you take a look at my paste please ?
09:02:44 <lpaste> anewnewbie pasted “Provide phantom type at call site” at http://lpaste.net/220438
09:04:27 <anewnewbie> Hi I have a slight problem providing a type parameter in a function which uses it but the type parameter is not used in the function's arguments. I have pasted an example
09:05:04 <geekosaur> ph88, first part of otherSpecialCharacter might need a `try` because if it sees \ followed by not-\ it has still consumed the first \
09:05:40 <ph88> oki i'll try that
09:05:43 <anewnewbie> Do I have to use an unused / extra Data.Proxy argument to provide it? Maybe another way?
09:05:46 <lpaste> iphy pasted “types don't match although they are equal in writing” at http://lpaste.net/220453
09:06:05 <iphy> ertesx: ^
09:06:31 <geekosaur> iphy, please include the full error(s) you get
09:06:36 <lpaste> iphy revised “types don't match although they are equal in writing”: “types don't match although they are equal in writing” at http://lpaste.net/220453
09:07:32 <iphy> hm
09:07:52 <lpaste> iphy revised “types don't match although they are equal in writing”: “types don't match although they are equal in writing” at http://lpaste.net/220453
09:08:04 <iphy> does lpaste try to compile?
09:08:07 <iphy> it compiles..
09:08:17 <geekosaur> no, it just runs a heuristic checker
09:08:22 <cocreature> I think it only runs hlint
09:08:49 <lpaste> iphy revised “types don't match although they are equal in writing”: “types don't match although they are equal in writing” at http://lpaste.net/220453
09:08:50 <ski> anewnewbie : use a "proxy", or `TypeApplications' <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#visible-type-application>
09:08:56 <iphy> added the errors ^
09:09:29 <Philonous> anewnewbie, Taking another argument to fix the type would work. 
09:10:07 <ski> anewnewbie : however, i don't really see where `readable' would be more useful than using `readMaybe' directly ..
09:10:16 <anewnewbie> ski: I found proxies as well, but I was wondering whether something more elegant than adding an unused parameter would be possible. I 'll look into TypeApplication, thanks a lot!!!
09:10:49 <iphy> http://rextester.com/UZXHD70204
09:10:55 <iphy> here you can compile it
09:10:57 <anewnewbie> ski: I know, in the given example this is true, but in my real code it is a bit more complicated. I simplified it to the actual core of the issue
09:11:14 <anewnewbie> ski: Thanks again!!
09:11:14 <geekosaur> iphy, it's as much that different things may happen with different ghc versions
09:11:25 <ilyanok> I'm getting linking errors while running stack build, like this one http://lpaste.net/220480, what does it mean?
09:11:32 <ski> anewnewbie : ok, i don't see how, but that could possibly be the case for all i know :)
09:11:39 <ilyanok> can I fix it somehow?
09:11:42 <geekosaur> sure I could compile it ... with 7.10. which might not even compile some code expecting ghc8, and might get different errors
09:12:00 <iphy> if it works on some version, that's interesting
09:12:02 <geekosaur> that said, I think it tells you what;s wrong: you're expecting it to work backwards from ServerType m r to m and r
09:12:05 <geekosaur> it doesn't
09:12:08 <geekosaur> sigh
09:12:08 <anewnewbie> ski: if you are interested I could paste an actual code example to satify your curiosity :)
09:12:20 <ReinH> ilyanok: what OS?
09:12:26 <ilyanok> OSX
09:12:33 <ReinH> Which version?
09:12:57 <ilyanok> 10.11.6
09:12:59 <geekosaur> ilyanok, usually when I see those I look to see if I forgot to put an un-exported module in other-modules
09:13:10 <ReinH> Is that Sierra?
09:13:17 <geekosaur> no, 10.11 is El Cap
09:13:18 <ilyanok> No, El Capitan
09:13:21 <ReinH> Ok
09:13:36 <ski> iphy : maybe (?!) you want to put an FD `f -> m' on `IsReturnType m f' ?
09:14:00 <ski> anewnewbie : shoot
09:14:02 <ilyanok> geekosaur: hm, that can be the case
09:14:15 <anewnewbie> ski: gimme a sec
09:14:44 <ph88> when quickcheck generates a new test case, how can i ignore some part of the data of the generated output and the actual output ?
09:14:57 <iphy> ski: fascinating
09:15:01 <iphy> now I get undecidable instances
09:15:28 <ph88> suppose i have    data Foo = Foo (String, Int)    and i only want quickcheck to compare the String part of equality
09:15:33 <iphy> ski: but it works
09:16:10 <ilyanok> geekosaur: yep, it worked, thanks!
09:16:34 <ski> note that the FD means `forall f. unique m. IsReturnType m f', iow `forall f m0 m1. (IsReturnType m0 f,IsReturnType m1 f) => m0 = m1', iow you can't have two instances with different `m's, for the same `f'. if you don't want this restriction, then don't add the FD
09:16:39 <ski> iphy ^
09:16:49 <dhalgren> hi! will haskell2016 & hiw2016 videos be online somewhere? Or are they somewhere already?
09:16:49 <ph88> how to actually "traverse / walk" a data structure and change the value of all items of the same type within the data structure ?
09:16:58 <geekosaur> but if you don't add it, you need to annotate types :/
09:17:18 <geekosaur> ph88, that's the classic use of generics
09:17:24 <ski> ph88 : how about `Traversable' ?
09:17:31 <iphy> ski: I only need the two instances below
09:17:32 <kqr> cocreature, ah, that makes sense as a distinction. well in this case it's machine generated!
09:17:43 <ph88> never used traversable before
09:18:07 <ph88> can it be automatically derived ?
09:18:13 <cocreature> yep
09:18:17 <ph88> nice
09:18:18 <cocreature> with -XDeriveTraversable
09:18:24 <cocreature> which is a pretty safe extension
09:18:29 <ski> iphy : well, i wanted you to consider in the abstract whether the condition just stated would make sense for the problem domain your type class is supposed to describe
09:19:05 <iphy> thanks
09:19:09 <ski> ph88 : you'll need to parameterize the positions of the data structure corresponding to the "elements" that you want to traverse over, though
09:19:09 <iphy> ski: yeah, it makes sense I think
09:19:15 <ski> iphy : good
09:19:45 <iphy> http://lpaste.net/220512
09:19:48 <iphy> here is what I have now
09:19:54 <johnw> ph88: what about lens: x & partsOf biplate %~ (f :: a -> b)
09:19:56 <ski> iphy : 'tis just that you shouldn't just add an FD in order to get rid of type ambiguities, if you're aren't prepared to accept the declarative meaning of the FD
09:20:19 <iphy> and used like this: http://lpaste.net/220515
09:20:26 <ph88> ski, it depends what kind of function i want to apply to the data to know which elements to traverse
09:20:27 <lpaste> anewnewbie pasted “Actual code” at http://lpaste.net/220517
09:20:35 <ph88> johnw, never used lens before
09:20:38 <dhalgren> I think I saw a list of ghc extensions by popularity in stackage somewhere, but forget where. anyone know of it?
09:20:47 <dhalgren> hackage actually
09:20:55 <ski> ph88 : lenses are more general than `Traversable'
09:21:00 <johnw> ph88: what I wrote would change every 'a' within 'x' to a 'b' using 'f'
09:21:01 <anewnewbie> ski: I habe pasted a more complete (but not necessarity compiling) version of the code
09:21:12 <anewnewbie> s/habe/have
09:21:35 <johnw> ph88: it's similar to the uniplate library, which can achieve the same thing
09:21:47 <ph88> don't know the uniplate library either :p
09:22:02 <anewnewbie> ski: I want to use this to avoid creating boilerplate tests.
09:22:33 <johnw> ph88: syb (scrap your boilerplate) can do it too.  this is a problem that's been thought about a fair bit
09:22:48 <ph88> so many options :/
09:22:51 <ski> anewnewbie : ok
09:23:37 <ski> ph88 : i'd probably suggest : learn `Traversable' before any of the other alternatives suggested
09:23:42 <ph88> oki
09:23:56 <anewnewbie> ski: does this look a reasonable thing to do?
09:24:06 <ski> ph88 : perhaps it'll not fit in your situation, but it will still help to learn it, in order to learn about lenses
09:24:18 <plakband> I want to make a data structure for which certain updates can fail/are illegal. I'm considering making a `Lens s (Maybe s) a a`, is there a reason why I shouldn't?
09:24:25 <ski> anewnewbie : it looks less nonreasonable, at least :)
09:24:32 <plakband> It violates the set-set law, but I feel like that shouldn't be that big of a deal
09:24:36 <cocreature> ph88: if you’ve ever used mapM you basically already understand traversable :)
09:24:59 <ph88> i've used mapM
09:25:05 <ski> ph88 : `Traversable' is `mapM', generalized from lists to an arbitrary (parameterized) data structure
09:25:25 <cocreature> mapM is already generalized these days :)
09:25:31 <anewnewbie> ski:  I'll settle for that  :)
09:25:53 <ski> plakband : perhaps ask in #haskell-lens
09:25:54 <cocreature> the only difference is that traverse only requires Applicative
09:28:06 <plakband> ski: alright, thanks
09:28:50 <ph88> not sure about the difference between traversable and functor
09:31:28 <ski> ph88 : with `Functor f', you can go from `f a' to `f b', using `a -> b'
09:32:06 <ski> ph88 : with `Traversable t', you can go from `t a' to `i (t b)', using `a -> i b', with `Applicative i'
09:32:23 <ski> (and also works for any `m' with `Monad m' instead of `i' with `Applicative i')
09:33:17 <ski> ph88 : so, `Functor' only allows you to individually transform each element, independenty of all the others. `Traversable' also allows your element transformation to have effects which can affect how the rest of the elements gets transformed
09:34:05 <ski> ph88 : e.g. replacing every element with the running sum of all elements seen so far can be done with `Traversable' (using `i = State n', `n' being the numeric type in question), but not with `Functor'
09:34:10 <ski> ph88 : makes any sense ?
09:35:21 <dhalgren> ski: certainly helps me at least, thx
09:35:21 <ski> ph88 : or if you wanted to perform some `IO'-action, or whatever, for every element, while also (possibly) transforming it, you could probably use `Traversable'
09:35:28 * hackagebot hoauth2 0.5.6.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.6.0 (HaishengWu)
09:36:19 <ski> @src Traversable
09:36:19 <lambdabot> class (Functor t, Foldable t) => Traversable t where
09:36:20 <lambdabot>     traverse  :: Applicative f => (a -> f b) -> t a -> f (t b)
09:36:22 <lambdabot>     sequenceA :: Applicative f => t (f a) -> f (t a)
09:36:24 <lambdabot>     mapM      :: Monad m => (a -> m b) -> t a -> m (t b)
09:36:26 <lambdabot>     sequence  :: Monad m => t (m a) -> m (t a)
09:36:31 <ph88> makes perfect sense, thx ski
09:37:10 <ski> `Foldable' is for the restricted case where you only want the combined effect performed for every element, rather than actually (also) building a new data structure with the transformed elements
09:37:20 <ski> so `Foldable' has `mapM_'
09:38:08 <ski> `mapM' and `sequence' above are two slightly different ways of doing the same thing (since `Functor t')
09:38:22 <ski> similarly with `traverse' and `sequenceA'
09:38:31 <ski> `traverse' is the `Applicative' version of `mapM'
09:38:42 <ski> `sequenceA' is the `Applicative' version of `sequence'
09:39:00 <ph88> ski, in a fold you could also construct a new data structure, no ?
09:39:32 <ski> (nowadays, when `Monad' is a subclass of `Applicative', probably we'd only need `traverse' and `sequenceA', but `mapM' and `sequence' are there because of hysterical raisins)
09:40:01 <ski> ph88 : yes, but not one which is a structural copy of the input one
09:40:27 <ski> ph88 : because "fold" here only cares about the *order* in which the elements occur. it doesn't care about the "nesting" of them
09:40:34 <ski> (or "grouping", if you prefer)
09:41:35 <bombom080> hello, I am a new user
09:41:35 <ski> (also folds here ignore any other information that might be stored in the structure, apart from the elements. so that wouldn't be duplicated either, then)
09:41:39 <ski> hello bombom080
09:41:46 <dhalgren> ski: there's been a lot of cleanup in the Monad hierarchy recently; will mapM/sequence get deprecated w time too?
09:41:49 <bombom080> hi frinds ski
09:42:14 <ski> dhalgren : not sure
09:42:14 <ph88> ski, the function used by traverse .. what does it get passed ?
09:42:25 <ReinH> Unless the data structure is the initial encoding of the fold, e.g., list and foldr
09:42:27 <ski> ph88 : it's similar to the one used by `mapM'
09:42:48 <nshepperd1> Supposedly there are some cases where mapM is more efficient
09:42:57 <dhalgren> aha, thx
09:43:18 <bombom080> you talking about
09:43:24 <bombom080> hacking
09:43:34 <Cale> bombom080: Welcome! Let us know if you have any questions about the language. Also, it's not generally considered a good idea to use your root user to connect to IRC.
09:43:44 <ski> ph88 : `traverse f t = sequenceA (liftA f t)' and `sequenceA t = traverse pure t' are general laws. similarly `mapM f t = sequence (liftM f t)' and `sequence t = mapM return t'
09:44:02 <dhalgren> bombom080: Traversable class seems to be the topic :)
09:44:32 <ph88> ski, i mean f .. what should be it's type signature ? i see   a -> m b    is that correct ?
09:44:35 <ski> ph88 : really, we'd only need one of `traverse' and `sequenceA'. we have both for convenience (and perhaps for efficiency). similarly for `mapM' and `sequence'
09:45:11 <ski> ph88 : reading from above, it's spelled as `a -> f b' in the signature for `traverse', and `a -> m b' in the signature for `mapM'
09:45:46 <ph88> i still think you can implement traverse by fold
09:46:00 <ski> ph88 : anyway, `traverse'/`mapM' will (in some traversal order fixed by the instance) pass each element of the input of type `t a' to that callback function
09:46:06 <ski> ph88 : you can't
09:46:38 <ReinH> ph88: feel free to try
09:46:48 <ReinH> You might learn why you can't.
09:46:49 <ski> ph88 : consider e.g. `data Expr a = Var a | Lit Integer | Add (Expr a) (Expr a)', where you can certainly write `Functor Expr', `Foldable Expr' and `Traversable Expr'
09:46:51 <nshepperd1> traverse is basically a drop in replacement for mapM
09:46:59 <nshepperd1> Except it only needs applicative
09:47:46 <ski> ph88 : if you try to use only the operations afforded by `Foldable' to instance `Traversable', you'll (a) lose the nesting/grouping by `Add'; and (b) you'll lose the `Integers' stored by `Lit'
09:47:58 <nshepperd1> :t traverse
09:48:00 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:49:46 <ski> ph88 : keep in mind that `traverse pure = pure'/`mapM return = return' are laws that should hold for `traverse'/`mapM'
09:50:08 <ph88> was just thinking about that strangely enough
09:50:27 <ski> (those expresses that, if you do no effects, and don't change the elements, then you get back the same (or, in other words, an equal) data structure)
09:50:37 <nshepperd1> Consider even (Int, a). Fold throws away the Int, traverse keeps it.
09:52:36 <acowley> I'm having trouble using a type indexed by a Symbol with template haskell. GHC says, 'Type Foo "hello" isn't in scope'
09:52:51 <iphy> is something like this possible? http://lpaste.net/220636
09:52:56 <acowley> Where we have newtype Foo (s :: Symbol) = Foo Int
09:53:11 <acowley> Is there a known issue with TH and DataKinds?
09:53:30 <ski> iphy : requires `OverlappingInstances', which is generally considered a bad idea
09:53:54 <c_wraith> acowley, in what context? a type splice? a name literal? 
09:54:01 <bollu> @Cale: started playing around, GHCJS is slick 
09:54:01 <lambdabot> Unknown command, try @list
09:54:05 <bollu> Cale: ^
09:54:06 <acowley> A splice
09:54:09 <iphy> I tried OverlappingInstances, which didn't work (on ghc 7.6.3)
09:54:17 <Cale> bollu: It really is, isn't it? :)
09:54:34 <Cale> bollu: Luite has been insanely productive
09:54:43 <ski> hm, perhaps it'll even not work at all, with this combination of an associated type synonym
09:54:50 <bollu> c
09:55:01 <bollu> Cale: I want to read the source code (understand how it works)
09:55:07 <ski> (perhaps you could try type families, though i would refrain from doing so)
09:55:16 <iphy> I'm already using type families
09:55:17 <acowley> c_wraith: That is, yes, it's a type splice that refers to Foo "hello"
09:55:24 <iphy> this class with a type in it is a type family
09:56:00 <ski> i mean in the general sense, not just in the restricted sense of having an associated type synonym or associated data type
09:56:07 <acowley> But I can refer to that type in the same source file without trouble
09:56:19 <c_wraith> acowley, hmm. I've never even used a type splice. I bet it was missed when implementing DataKinds due to others also forgetting they exist. 
09:56:30 <acowley> ah, crud
09:57:06 <iphy> either I copy/paste most of the code and specialise it for IO
09:57:39 <Cale> bollu: Did you try out reflex-dom too? :)
09:57:39 <c_wraith> acowley, it's possible it is supported, but you need a special constructor for a symbol. 
09:57:42 <ph88> is sequence provided by yet another typeclass ?
09:57:45 <iphy> or I require the client code to write IO wrappers for every function (meaning I default to IO)
09:57:54 <Cale> :t sequence
09:57:57 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
09:58:02 <Cale> ^^ Traversable
09:58:50 <acowley> c_wraith: I can work around this by newtype my application to the Symbol, or I could newtype the Symbol itself, but either way it's gross :(
09:59:45 <c_wraith> acowley, what if you use a type alias? 
09:59:47 <soLucien>  http://pasteboard.co/7O6aC3r4t.png
09:59:49 <soLucien> why ?
09:59:54 <bollu> Cale: uhh, not yet. What does that do?
09:59:59 <acowley> c_wraith: I tried that, it doesn't work
10:00:00 <soLucien> i mean why f <- a x <- b
10:00:13 <soLucien> instead of return (a b) ?
10:00:35 <soLucien> is it the same thing ?
10:00:51 <ski> it's not
10:01:00 <ski> `a b' doesn't type check
10:01:25 <soLucien> (this is taken from LYAH Applicatives section)
10:01:31 <ski> if `a :: IO (t -> u)', then `a' is not a function
10:01:34 <geekosaur> soLucien, x <- y is not the same as let x = y
10:01:40 <lolisa> Hi, I got a rather silly question
10:01:49 <soLucien> what is the difference ?
10:01:50 <geekosaur> @undo do { f <- a; x <- b; return (f x) }
10:01:50 <lambdabot> a >>= \ f -> b >>= \ x -> return (f x)
10:01:52 <lolisa> I had written a DSL in finally tagless style
10:02:08 <ski> `a' is an I/O-action that, when executed, will (perhaps) perform some I/O-effects, and eventually (unless it yields an exception, or terminates the program, or ...) yield a function of type `t -> u'
10:02:29 <soLucien> is it like for each f in a and each x in b ?
10:02:36 <geekosaur> only for lists
10:02:36 <soLucien> like in the case of list comprehensions ?
10:02:38 <ski> soLucien : it's like asking what's the difference between a cake, and a *recipe* of a cake
10:02:48 <Cale> bollu: It's a driver on top of the reflex FRP system to let you control the DOM interactively. The reflex-platform I had you download includes it.
10:02:53 <geekosaur> see the @undo I did above, which is what the do translates to
10:02:58 <ski> you can probably eat the recipe, but it will probably not taste that good
10:03:09 <ski> the proper use of a recipe is to perform it, follow its instructions
10:03:10 <Cale> (there's a tutorial on the github repo)
10:03:25 <soLucien> i haven't yet got to monads, so i don't understand the >>= notation, geekosaur
10:03:27 <lolisa> everything is well, I had seperate the stuff, add tons of constructor/destructor into the language, now I am having a lot of file, I wonder how should I structure the file, like, are there anyway other than using constructor as dir name, impl destructor in it, or vice versa? 
10:03:44 <geekosaur> soLucien, that doesn't actually matter
10:03:48 <acowley> c_wraith: I'm going to newtype the type application to a Symbol
10:03:52 <lolisa> (cause doing so seems to have a 'not very extensible' file structure...)
10:03:56 <ski> soLucien : sortof, only in this case there's no "for each". it's "after executing the action, let's name the computed result"
10:04:16 <bollu> Cale: ooh, interesting
10:04:17 <geekosaur> what matters is that <- involves using (>>=), so something else is happening not merely "assignment"
10:04:19 <jonored_> soLucien: do notation on the list monad is /very/ similar to list comprehensions, yes, but while it's analogous for IO it doesn't acutally mean the same thing - different monad :)
10:04:34 <ski> s/sortof/sortof, but really very different/
10:04:47 <dhalgren> Swizec: OT: your nick a pun on marmot by any chance?
10:05:26 <soLucien> okay so after each function in a, do some x in b , returning the output of the execution
10:05:34 <soLucien> each f in a 
10:05:42 <ski> soLucien : so `f' is the result after executing `a', and `x' is the result after executing `b'
10:06:02 <ski> soLucien : since `a :: IO (t -> u)' (for some types `t',`u'), we will have that `f :: t -> u'
10:06:17 <ski> soLucien : similarly, since `b :: IO t', we'll have that `x :: y'
10:06:30 <ski> er, `x :: t'
10:06:47 <ski> soLucien : and so `f x :: t', and so `return (f x) :: IO t', as required by `do'-notation
10:06:48 <soLucien> okay now i need some time to get that sink in
10:07:06 <ski> (hm, actually `u' rather than `t' in my last line above. sorry for that)
10:07:18 <soLucien> i haven't gotten to the do-notation unfortunately .. i need to read up on what it means
10:07:27 <soLucien> but it seemed it's part of the monad
10:07:43 <soLucien> which is something i haven't yet read up on
10:07:43 <ski> `do'-notation is syntactic sugar on top of `(>>=)'
10:08:12 <ski> just like list comprehension notation is syntactic sugar on top of stuff like `filter',`map',`concat'
10:08:19 <c_wraith> don't worry. reading about monad is less useful for understanding it than this conversation will be. 
10:08:50 <soLucien> i read some stuff like "do notation allows imperative style programmin"
10:09:25 <ski> one could say that, in a certain sense, yes
10:09:43 <ski> however, `<-' is not assignment
10:09:59 <ski> it's "name the result after executing an action"
10:10:18 <soLucien> okay i kind of got it
10:10:34 <ski> in `do'-notation, a sequence of commands follows the `do'
10:11:34 <soLucien> okay i got it
10:11:34 <ski> the basic shape of such a command is typically `<pat> <- <expr>', where `<pat>' is any pattern (usually just a single variable name), and `<expr>' is any expression of type `m t', where `t' is some type, and `m' is a monad
10:11:46 <soLucien> however, there's another thing i am unsure of
10:11:49 <soLucien> what does return do ?
10:12:03 <soLucien> i understand that it does not return as in the imperative languages
10:12:05 <ski> each proper command in a single `do'-expression must use the same monad `m' 
10:12:20 <soLucien> ski i understood the type signature of the do
10:12:27 <soLucien> from your explanation
10:12:31 <jonored_> soLucien: return wraps a single value in the monad's type. For Maybe, it's Just.
10:12:37 <soLucien> and the tyope of the IO Applicative,
10:12:42 <ski> soLucien : right. it simply converts any value `x' (or more complicated expression, if you prefer) into a "trivial action" that does nothing except yield `x' as the result value
10:12:47 <soLucien> so i understand why f is a function and x is a type
10:13:04 <soLucien> so pure = return means 
10:13:36 <ski> soLucien : the last command of a `do'-expression must be a single expression (no `<-' allowed there), having type `m t', for some type `t', and for the monad `m' in question
10:13:39 <soLucien> is a polymorphic way of saying wrap it in whatever the type is
10:14:07 <soLucien> pure = Just in maybe can be replaced by pure = return 
10:14:22 <soLucien> oh wait .. no .. because Maybe is either Nothing or Just
10:14:25 <ski> soLucien : so if you want the final result, after executing your `do'-action, to be a plain value `x' (of type `t'), you need `return' to convert that into something of type `m t'
10:14:30 <soLucien> so then the compiler gets confused
10:15:21 <ski> soLucien : ".. can be replaced by .." -- depends on how you've defined `return' for `Maybe' :)
10:15:41 <ski> soLucien : if you defined it as `return = Just', then all's fine. if you defined it as `return = pure', then you're in trouble
10:15:53 <hansihe> say i have a list [a, b, c] and want all combinations of all elements [[], [a], [b], [c], [a, b], [a, c], [b, c], [a, b, c]]. how would i do that?
10:16:36 <bollu> doesn't continuation style give us an ismorphism between (a -> b) ~= a -> (b -> r) -> r?
10:16:44 <ski> > filterM (const [False,True]) [a,b,c]
10:16:45 <byorgey_> hansihe: the canonical one-liner for that is  filterM (const [False, True])
10:16:46 <bollu> is there some category theory meaning to this?
10:16:48 <lambdabot>  [[],[c],[b],[b,c],[a],[a,c],[a,b],[a,b,c]]
10:16:48 <ski> hansihe : hm, wrong order ..
10:16:49 <bollu> the iso?
10:17:24 <ski> bollu : it's between `b' and `forall r. (b -> r) -> r', the `forall' is important
10:17:42 <bollu> ski: right, sorry, missed that it works for any choice of return tye
10:17:43 <bollu> type*
10:17:59 <ski> you need the `forall' in order to go in the backwards direction
10:18:10 <bollu> ski: what happens if I don't have it?
10:19:10 <ski> bollu : <http://blog.sigfpe.com/2006/11/yoneda-lemma.html> might be interesting
10:19:34 <ski> bollu : if you don't have it, then there's no reason to suppose that you can construct a `b' from your `r'
10:19:49 <bollu> ski: wait what, this is related to yoneda? HOW?
10:20:25 <ski> bollu : let's say `a' and `b' are empty, and that `r' is inhabited, e.g.
10:20:41 <bollu> ski: give me 5?
10:20:52 <ski> er, sorry, `a' should also be inhabited
10:21:02 <bollu> ski: okay, go on
10:21:03 <ski> bollu : then you can go from `a -> b' to `a -> (b -> r) -> r', but not in the opposite direction
10:21:28 <bollu> ski: so how does having the forall r. … help?
10:21:33 <ski> yes
10:22:00 <ski> @djinn (a,Not b,r) -> ((a -> b) -> (a -> (b -> r) -> r))
10:22:00 <lambdabot> f (a, b, _) c = void (b (c a))
10:22:01 <ski> @djinn (a,Not b,r) -> ((a -> (b -> r) -> r) -> (a -> b))
10:22:02 <lambdabot> -- f cannot be realized.
10:22:20 <bollu> ski: what's the exact diference between a -> (b -> r) -> r and a -> (forall r. (b -> r) -> r)?
10:22:24 <ski> bollu : sorry, you said "how". well then you can just pick `r' as `b'
10:22:56 <ski> bollu : the two expressions can't be compared, since `r' is free in one and not free in the other
10:23:20 <ski> in the former, you're talking about some particular `r'
10:23:25 <ski> in the latter, you're not
10:23:45 <ski> (just as in either, you're talking about some particular `a' and `b')
10:23:46 <bollu> ski: isn't the first expression: forall a. forall b. forall r. a -> (b -> r) -> r  and the second: forall a. forall b. a -> (forall r. (b -> r) -> r) ?
10:23:51 <ski> not at all
10:24:02 <byorgey> (it is a tad confusing that Haskell implicitly quantifies free type variables, so one could reasonably think that.... what bollu just said
10:24:14 * ski agrees with byorgey
10:24:51 <byorgey> maybe we should write them as   (B -> R) -> R  and   forall r. (B -> r) -> r
10:25:02 <byorgey> those are obviously different
10:25:09 <ski> claiming that `b' is basically `forall r. (b -> r) -> r' is different from claiming that `forall b. b' is basically `forall b r. (b -> r) -> r'
10:25:19 <ski> (the latter follows from the former, of course)
10:25:52 <bollu> byorgey: so, Haskell does not add forall a b. in that expression?
10:25:53 <ski> (more precisely stated : from knowing that the former holds for *every* `b', it follows that the latter holds)
10:26:04 <ski> forget about "add forall a b."
10:26:19 <bollu> ski: okay, go on
10:26:48 <ski> the only situation, in Haskell, where `forall's are added, are in type signatures, and then only directly after the `::'
10:26:59 <ski> but there were no type signatures in the present discussion
10:27:17 <ski> `[a] -> [a]' is not at all the same as `forall a. [a] -> [a]'
10:28:01 <ski> if it were, then `([a] -> [a]) -> [[a]] -> [[a]]' would be the same as `(forall a. [a] -> [a]) -> [[a]] -> [[a]]', which is clearly nonsense
10:28:03 <bollu> ski: oh, wow, did not know that
10:28:22 <bollu> ski: so in that case, how does the ExplicitForall extension work?
10:28:41 <ski> `ExplicitForall' allows you to write `forall' in types
10:28:44 <bollu> ski: like: map :: forall a b. (a -> b) -> [a] -> [b]
10:29:24 <ski> in certain situations, for *convenience*, `forall's are implicitly inserted by Haskell
10:29:43 <bollu> ski: ah
10:30:22 <ski> `forall's are inserted just after `::' in a type signature, binding the apparently unbound type variables in the type, *unless* they happen to already be in scope in the wider context (e.g. when declaring a new type class)
10:30:55 <ski> `ExplicitForall' simply allows you to write such `forall's explicitly, rather than having Haskell insert them implicitly
10:31:17 <dabd> Can you write a quickcheck property expressing the relationship between unfold and fold?
10:31:53 <ski> generating arbitrary types tends to be problematic ..
10:32:01 <ski> for specific types, you should be able to do it
10:33:20 <nshepperd> anyway, you can get from `forall r. (b -> r) -> r` to b easily. but `(b -> ()) -> ()` is pretty much useless
10:34:29 <bollu> ski: so what's the category theoretic explanation? can I think of it as endofunctor that takes objects to the same identity and arrows to the continuation version? and the opposite as its' adjoint? I don't think it works out as cleanly as that
10:35:24 <ski> bollu : if `f' is a functor, then `f b' is the same as `forall r. (b -> r) -> f r'. iiuc, this is closer to the usual formulation of Yoneda
10:35:36 <ski> bollu : now take `f = Identity' ..
10:36:19 <byorgey> dabd: what is the relationship between unfold and fold?
10:36:32 <bollu> ski: lost you at "take f = Identity"
10:36:44 <dabd> byorgey: they are duals
10:36:54 <bollu> ski: isn't yoneda something like, if you know all of Hom(A, B) to all B, you can reconstruct A?
10:36:59 <ski> bollu : so, you have some kind of natural isomorphism between the functor `f', and a functor `b |-> forall r. (b -> r) -> f r', which iirc they express in some fashion with functor categories, opposite categories, and hom sets
10:37:05 <bollu> ski: ah
10:37:07 <byorgey> dabd: yes, but how would you express that as a quickcheck property?  Or is that what you were asking?
10:37:23 <ski> bollu : Cale might be able to give a better account of the CT aspects of it
10:37:25 <dabd> yes I don't know how to express it as a quickcheck property
10:37:27 <bollu> :t unfld
10:37:29 <lambdabot> error: Variable not in scope: unfld
10:37:30 <bollu> :t unfold
10:37:32 <lambdabot> error:
10:37:32 <lambdabot>     • Variable not in scope: unfold
10:37:32 <lambdabot>     • Perhaps you meant one of these:
10:37:36 <bollu> hm
10:38:15 <byorgey> dabd: I really don't either.  It's sort of a meta-level property.
10:38:46 * ski was assuming dabd already had some concrete property in mind, in terms of inhabitants
10:39:02 <byorgey> you can probably come up with some laws relating them, but they probably have e.g. certain functions being inverses as a prerequisite, which is hard to test using quickcheck
10:39:47 <dabd> byorgey: so to test it I should pick up concrete examples and write properties based on those.
10:40:02 <byorgey> e.g. you probably have things like "given functions f and g such that ... are inverse, then fold f . map something == ... unfold g ... something"
10:40:54 <byorgey> dabd: what exactly are you testing?
10:41:41 <dabd> byorgey: thanks, I'm actually a Scala programmer and working through a book called FP in Scala.  There I had to implement unfold for Streams and was wondering how to write a property based test
10:42:05 <byorgey> dabd: ah, so you want to test your implementation of unfold?
10:42:09 <dabd> yes
10:42:46 <byorgey> dabd: ok, that sounds like a good idea, but I think you should try to come up with properties that do not involve fold
10:44:47 <byorgey> fold for Streams does not make a whole lot of sense anyway.
10:45:29 <Zemyla> Okay, so a Dict is usually represented as data Dict c where Dict :: c => Dict c, right?
10:46:09 <Zemyla> But could it also be represented as newtype Dict c = Dict { runDict :: forall r. (c => r) -> r }?
10:46:38 <ski> hm .. i'd suppose so
10:47:33 <phadej> it's "easy" to see by writing isomorpisms
10:47:51 <dabd> byorgey: thanks
10:48:43 <athan> What's your favorite way to write a simple bit encoder? :|
10:49:14 <athan> I'm trying to write one that can be compatible with base16, base64, and base58, and I'm stuck on how to trucate the data
10:49:21 <athan> or really, make a data stream that's compatible
10:49:22 <dabd> byorgey: you mean it does not make sense because the stream can be an infinite list?
10:49:37 <athan> with base16 and base64, it's really easy because base16 is a common denominator
10:49:52 <athan> how would you write an encoder using only lists and Int?
10:50:05 <byorgey> dabd: oh, I was thinking of the definition of Stream that is *necessarily* an infinite list.  Maybe the Scala version is different.
10:51:09 <byorgey> dabd: but yes, that is why.
10:52:07 <dabd> byorgey: the Scala stream is also an infinite (lazy) list. They somehow show an implementation of foldr https://github.com/fpinscala/fpinscala/blob/master/answers/src/main/scala/fpinscala/laziness/Stream.scala#L76-L80
10:52:32 <EvanR> cant you convert a stream into a stream of accumulations by monoid
10:53:28 <byorgey> dabd: yes, if you have laziness, it's not *entirely* useless, since you can use a lazy combining function that might not look at its second argument, and then the recursion would terminate.
10:54:03 <dabd> I suppose in Haskell you can do the same
10:54:31 <byorgey> dabd: but every use of foldr on an infinite list either (1) does not terminate on some inputs, or (2) has some n such that it will never look past the first n elements, no matter what input it is given
10:58:00 <hansihe> ski: earlier with the powerset one-liner, you know if there is any easy way to get it in the correct order?
11:00:47 <dabd> byorgey: I have to think about those 2 points, it is not obvious for me
11:03:04 <dmwit> byorgey: I bet I could implement `takeFirst (n:ns) = take n ns` as a fold, which doesn't seem like it fits in either regime you described there.
11:03:37 <dmwit> genericTake, if you must, to avoid complaints about `Int` being finite. ;-)
11:07:26 <amalloy> i'm not so sure you could, dmwit
11:07:57 <amalloy> foldr doesn't seem to have the right kind of computation shape to do that, to me, although i could surely be wrong
11:18:35 <infandum> How can I run a haskell script multithreaded and specify the number of threads?
11:19:03 <infandum> stack ghci script.hs works, but it uses ALL threads which may be crazy as there can be lots of them using mapConcurrency
11:19:14 <infandum> concurrently I mean.
11:19:34 <edwardk> infandum: you mean the +RTS -N kinda stuff?
11:19:45 <infandum> stack runghc script +RTS -N2 doesn't work as it says that it wasn't compiled with threaded
11:19:56 <infandum> but then why would not specified -N make it threaded?
11:20:00 <edwardk> oh, no idea re stack runghc
11:20:25 <edwardk> infandum: you'd have to get it to compile the script with -threaded before it runs it with +RTS -N.
11:21:18 <infandum> hmm
11:22:25 <edwardk> how that translates into stack-speak i don't know
11:24:21 <infandum> edwardk: Yeah, normally I compile but I'm using Turtle for scripting so it's a basic script
11:24:27 <infandum> so I use runhaskell basically
11:24:59 <geekosaur> actally I think you just need a -- there
11:25:05 <geekosaur> stack is eating the +RTS stuff
11:25:20 <geekosaur> stack runghc -- script +RTS -N2
11:25:49 <geekosaur> or maybe that needs to be --RTS instead of just --
11:26:01 <infandum> geekosaur: Then it thinks it's passed to the script
11:26:22 <geekosaur> no, that stops *stack* from eating it, so runghc should get it
11:26:35 <geekosaur> probably need --RTS if it's going too far with it though
11:27:13 <geekosaur> (I really wish haskell stuff didn't use "permute", so options go where you expect them to)
11:27:14 <codedmart> Hmm... I am getting `it is a hidden module in the package http-client` yet I have it in my build depends?
11:27:22 <infandum> geekosaur: I mean, stack runghc script.hs -- --arg1 arg +RTS -N2
11:27:31 <athan> codedmart: You might need it in the executable stanza :)
11:27:32 <infandum> that says that it's not compiled with "-threaded"
11:27:44 <infandum> I probably need the ghc options thingy
11:28:01 <athan> infandum: --ghc-options=~
11:28:02 <athan> !
11:28:11 <athan> (to runghc)
11:28:17 <athan> at least I think
11:28:19 <athan> maybe to stack
11:28:47 <geekosaur> mh, if it's actually using runghc then it probably needs extra woobery, at that
11:29:06 <geekosaur> maybe just make sure you have a recent stack, and stack --RTS script.hs ...
11:29:14 <infandum> athan: Says it's not a valid argument
11:29:23 <infandum> I remember doing something like this a while back
11:29:25 <infandum> I think
11:29:29 <ski> hansihe : the obvious is to reverse ..
11:29:30 <geekosaur> (note no runghc, stack knows to run .hs itself if recent enough)
11:29:57 <geekosaur> but the --options likewise also tend to go to stack
11:30:28 <geekosaur> and if using runghc explicitly there may be even more magic involved; the unix shell script was a bit messy with respect to option handling iirc
11:31:20 <athan> woobery sounds like what happens when the floor disappears, but you're somehow not falling
11:31:46 <infandum> geekosaur: It's the newest stack in arch
11:32:12 <athan> Shoot, guys I'm lost
11:32:21 <athan> how do I convert between base64 and base58 manually?
11:32:30 <athan> using Ints, mod, div and the like? :(
11:33:04 <athan> I'm considering turning the data into a list of Bools, but even then because 58 isn't a power of base 2, I'm still borked I think
11:35:09 <athan> I think there's a lot... remaining... that I need to figure out! :V
11:36:08 <Tuplanolla> Investigate this sequence, athan: [9000 `quotRem` 58, 155 `quotRem` 58, 2 `quotRem` 58]
11:40:18 <athan> Tuplanolla: Would that mean the base58 encoded sequence of 9000 is [10,39,2]?
11:40:40 <Tuplanolla> Yes, because: 10 * 58 ^ 0 + 39 * 58 + 2 * 58 ^ 2 == 9000
11:40:43 <athan> I can't seem to "add it back up"
11:40:53 <athan> WOAH
11:40:57 <athan> I had it backwards!!
11:41:08 <athan> thank you so much Tuplanolla!!
11:41:40 <Tuplanolla> Here's a fun function: sum . zipWith (\ n r -> r * 58 ^ n) [0 ..]
11:41:46 <athan> so by "working with the quotient", you step a digit?
11:41:53 <athan> :U
11:42:21 <Tuplanolla> If you give it the list of remainders in base 58, it'll sum them all together into an integer.
11:46:22 <neonfuz> Is there a way to check that a list is at least a certain length without running length on it?
11:46:33 <neonfuz> (because length has to traverse all the way to the end of the list)
11:46:46 <Welkin> no
11:47:00 <geekosaur> null . take N ?
11:47:01 <neonfuz> no regular way? alright
11:47:10 <neonfuz> oh yeah, take, hmm
11:47:41 <neonfuz> geekosaur: do you mean drop N?
11:47:51 <geekosaur> hm, yes, sorry
11:48:00 <neonfuz> null . take N-1
11:48:05 <neonfuz> drop*
11:53:46 <DavidEichmann> Any one know if there is some way to {-# UNPACK #-} a polymorphic type? least when unpackable types are used.
11:54:20 <DavidEichmann> e.g. I have a vector type:  data V a = {-# UNPACK #-} !a {-# UNPACK #-} !a
11:54:43 <DavidEichmann> but the compiler just says it will ignore the UNPACK
11:56:05 <DavidEichmann> the performance difference is crazy! But using a concrete type (data V = V {-# UNPACK #-} !Double {-# UNPACK #-} !Double) is ugly and means I cant use a lot of type class stuff. E.g. you can't make V an instance of Functor any more.
11:57:45 <Cale> DavidEichmann: No, the whole point of UNPACK is to subvert the very mechanism which enables polymorphism and lazy evaluation
12:01:58 * ski imagines an implementation with type-passing for unboxed types
12:02:33 <ski> (DavidEichmann : also, it's not a polymorphic type. it's a type variable)
12:04:39 <ski> @hackage mono-traversable
12:04:39 <lambdabot> http://hackage.haskell.org/package/mono-traversable
12:05:00 <ski> DavidEichmann ^
12:05:41 <dmwit> amalloy, byorgey: foldr (\elem rest -> take elem (elem:rest)) []
12:06:16 <dmwit> Guaranteed to terminate for all input lists (it looks at at most the first n elements, where n is the first element), but no fixed bound works.
12:06:22 <DavidEichmann> thanks I'll have as look!
12:06:46 <dmwit> (Suppose the fixed bound was n. Then [n+1 ..] would be a counterexample.)
12:07:09 <nshepperd1> dmwit: maxBound :: Int
12:07:16 <nshepperd1> :)
12:07:21 <dmwit> nshepperd1: Make it genericTake, as I mentioned above.
12:07:22 * ski . o O ( "Kreisel's No Counterexample interpretation" )
12:08:11 <nshepperd1> Yeah, if you use bigints (an infinite alphabet) it can work
12:08:44 <nshepperd1> You're basically hiding the nontermination in the bigint implementation
12:09:06 <dmwit> ?
12:11:11 <dmwit> If you like, I can make a version that works on [[()]]. Though I don't really understand your objection, so I don't know whether you would like that or not.
12:11:17 <nshepperd1> Suppose your bigint type was peano Nat, you could provide (fix Succ)
12:11:54 <dmwit> Ah, now I understand your objection.
12:15:00 <dmwit> Interesting!
12:33:25 <Welkin> where is `migrateAll`???
12:33:34 <Welkin> I see it used in many persistent examples
12:33:37 <Welkin> but it doesn't exist
12:33:55 <Welkin> runSqlPool (runMigration migrateAll) pool
12:33:58 <shapr> :hoogle migrateAll
12:34:02 <Welkin> nope
12:34:09 <Welkin> it doesn't exist
12:34:25 <shapr> Welkin: https://hackage.haskell.org/package/snaplet-persistent-0.5/docs/Snap-Snaplet-Persistent.html ?
12:34:27 <dmwit> Welkin: It is defined by some TH in the examples I see from Google.
12:34:45 <dmwit> Welkin: e.g. they all have a line like `share [mkPersist sqlSettings, mkMigrate "migrateAll"] [...]`.
12:35:02 <Welkin> yeah, that is different though
12:35:06 <Welkin> I already have that
12:35:36 <Welkin> oh, I see
12:35:43 <Welkin> it is create by the th
12:35:47 <Welkin> created*
12:43:25 <Welkin> I can't figure out where this error is even coming from or why
12:43:26 <Welkin> http://lpaste.net/8792181797354995712
12:43:53 <Welkin> if I comment out the line, everyone compiles fine
12:45:44 <fr33domlover> Welkin, wrong monad perhaps?
12:45:55 <fr33domlover> you may need to use runLoggingT there
12:46:01 <fr33domlover> (or runNoLoggingT)
12:46:39 <fr33domlover> carefully examine the type of the monadic action on line 24
12:48:34 <fr33domlover> Welkin, runLoggingT (runSqlPool migrateDB pool) logFunc
12:49:01 <fr33domlover> you should examine the scaffolding code
12:49:06 <dmwit> Presumably there will need to be some runResourceT or similar in there, too.
12:49:11 <fr33domlover> see how it works and just do the same thing
12:50:50 <Welkin> that is weird though
12:51:00 <Welkin> I just copied it straight from examples on how to do this
12:52:15 <Welkin> I guess you are right though
12:52:17 <Welkin> that is so strange
12:53:22 <tjt> Hi! I am visiting University of Glasgow for work (not related to haskell). I was thinking that which building I should go to absorb haskell-y knowledge as a hobbyist by reading corridor posters and looking at  people
12:58:45 <tjt> plan is to escape my workspace lab during lunch hour and then wander between different places. Plan is not to talk to people, as that would become awkward as I cannot comprehend the dialect that well.
13:02:32 <tjt> i mean no ill to scots, to be clear. all native english speakers are evenly difficult to understand
13:02:52 <Welkin> that isn't what I want though
13:02:56 <Welkin> I'd like to log the migration
13:02:59 <Welkin> but I did get it working
13:03:01 <Welkin> it just seems wrong
13:04:02 <ReinH> tjt: to be fair, I estimate that none of us understand Finnish.
13:08:09 <ReinH> Well, I understand a little Estonian, so perhaps.
13:08:30 <tjt> ReinH: I believe so. I remember reading about an interensting study that in general, non-native speakers are more easily understood by other non-natives, and native speakers use language that is too colourful and descriptive. Non-native is to the point, so to speak.
13:08:50 <ReinH> Fewer idioms, for instance.
13:09:00 <ReinH> Non-native speakers often have trouble with idioms
13:09:32 <ReinH> To be fair, so do native speakers.
13:10:35 <tjt> though when you have something that is complicated and needs plenty of detail in speech, then non-native speaker like I will have trouble. so, if someone says pascal, haskell, monoid, so on, swoosh that thing goes over my head. better to stay at  reading at the corridor posters (again, if those are present here at UoG)
13:11:14 <ReinH> Luckily we can speak in syntax :)
13:11:23 <ReinH> Well, some of the time
13:12:35 <Tuplanolla> I asked a reasonable question, but these people keep sending me ASCII butts.
13:16:37 <ReinH> Tuplanolla: ?
13:17:05 <Tuplanolla> It's a bad joke about speaking in syntax.
13:17:49 <jonored> Isn't that mostly a problem with pointless style, though?
13:21:58 <prsteele> anyone used a simulation library in Haskell? Looking at Aivika now, which seems... large...
13:29:26 <ReinH> prsteele: no no it says "Aivika itself is a light-weight engine with minimal dependencies." ;)
13:49:19 <iphy> http://lpaste.net/221535 <- I get an error trying to get a functional dependency to work - it works on ghc 7.6, but not on 7.10
13:49:36 <iphy> do I need anything else to make it work?
13:51:15 <ReinH> iphy: Well, here's the issue: https://ghc.haskell.org/trac/ghc/ticket/8634
13:52:05 <iphy> oh no :(
13:52:39 <prsteele> iphy: not positive, but associated types might work instead
13:53:17 <iphy> what would that look like?
13:53:44 <prsteele> https://wiki.haskell.org/GHC/Type_families#An_associated_type_synonym_example
14:09:45 <iphy> prsteele: http://lpaste.net/221600 I don't think type synonyms are possible
14:10:58 <prsteele> iphy: If you really believe f -> m, then your class should just have one type, f. Then the associated types should be use to build m from f
14:12:09 <iphy> yeah, but it's wrong
14:12:48 <iphy> I was told to add f -> m because I got a different error without it
14:12:56 <iphy> and adding it made it work on 7.6
14:13:48 <iphy> http://lpaste.net/221600 <- added the error message
14:18:28 <adam___> If I am using something like Data.Fixed.Vector, is there a way to write a function (getSubVector first last vec) so that (getSubVector 2 4 (5, 6, 7, 8, 9) = (6,7,8))?  Seems like the type depends on the first two arguments 
14:19:26 <Welkin> use `slice`
14:19:33 <Enigmagic> iphy: try adding `m` to the Returns type... `data Returns (m :: * -> *) r`
14:20:35 <Welkin> adam___: http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#v:slice
14:21:55 <adam___> Welkin: might be dumb, but Data-Vector doesn't encode length in type, right?
14:23:07 <adam___> Welkin: I'm trying to figure out if you could write `slice` in a fixed-length setting -- can't figure out if the return type would ever make sense
14:24:54 <ReinH> Cale: have you ever seen a situation where switching an ST usage from thaw/freeze to modify causes runtime to drop from 6 hours to 8 seconds?
14:25:11 <ReinH> I'm guessing something somthing fusion or inlining?
14:25:14 <iphy> Enigmagic: I was hoping that the Interface is independent of m
14:25:22 <ReinH> anyway yay it's fast now
14:26:12 <Enigmagic> iphy: but the types are not independent of m?
14:26:22 <iphy> they are
14:26:43 <iphy> m is just the monad the ClientT and ServerT transform
14:28:27 <ReinH> Cale: Criterion reports the following speedup: 831.8 s -> 53.32 ns
14:28:31 <ReinH> Yes, seconds to nanoseconds.
14:28:40 <ReinH> Haskell!
14:28:42 <EvanR> ReinH: impressive, 270000% speedup
14:28:45 <ReinH> right?
14:29:46 <ReinH> I mean, I want to say it isn't evaluating anything now, but it passes the tests so
14:31:36 <Cale> heh
14:32:15 <Cale> What, was it doing lots and lots of safe thaw and freeze copies on every iteration or something?
14:35:33 <ReinH> N....nooo?
14:35:36 * hackagebot hsdev 0.2.1.0 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.2.1.0 (AlexandrRuchkin)
14:35:38 * hackagebot hdocs 0.5.0.1 - Haskell docs tool  https://hackage.haskell.org/package/hdocs-0.5.0.1 (AlexandrRuchkin)
14:35:44 <soLucien> so i need to understand the return keyword
14:35:54 <ReinH> (the return function)
14:36:09 <ReinH> First step is probably understanding that it is not a keyword. :)
14:36:10 <soLucien> function
14:36:13 <soLucien> cool
14:36:24 <soLucien> and i have one issue with it
14:36:32 <ReinH> it is a function of type Monad m => a -> m a for some m, and what it does depends on what m is.
14:36:38 <soLucien> so return is something in a monadic context
14:36:48 <soLucien> but a monad is an applicative
14:36:54 <soLucien> and a applicative is a functor
14:36:54 <Enigmagic> iphy: then why not just remove `m` from `HaskellType` and `ServerType`? that will also fix it
14:37:01 <ReinH> soLucien: return is a.k.a. pure
14:37:14 <soLucien> pure is the applicative form 
14:37:23 <soLucien> of lifting something into the computational domain
14:37:36 <soLucien> so is return = pure 
14:37:38 <ReinH> I'd be wary of thinking of these things as "computational domains" or "contexts"
14:37:47 <iphy> Enigmagic: yes, I can remove it from HaskellType
14:37:48 <soLucien> until it is overriden by the monad ?
14:37:53 <ReinH> It's a way of taking an `a' and turning it into an `m a' for some m
14:37:55 <soLucien> context not domain
14:37:55 <iphy> but not ServerType, because ServerType ends up being ServerT m r
14:38:11 <ReinH> such that it meets the requirements imposed by the Applicative and Monad laws
14:38:13 <sdrodge> soLucien: return and pure should do the same thing, return only exists because Monad hasn't always been a sublcass of Applicative.
14:38:26 <Aruro> soLucien: yes both pure and return do a -> Container a
14:38:35 <Enigmagic> iphy: why does ServerType need m?
14:38:44 <Enigmagic> does the type depend on m somehow?
14:38:44 <ReinH> Think about instances of Monad.
14:38:47 <ReinH> return :: a -> [a]
14:38:50 <ReinH> return :: a -> Maybe a
14:38:51 <soLucien> i'm not there yet
14:38:51 <ReinH> and so on
14:38:55 <soLucien> i haven't read on the monad yed :D
14:39:00 <iphy> Enigmagic: in reality it's a StateT s m a
14:39:04 <soLucien> yet , still att he applicative
14:39:07 <iphy> m goes into StateT like that
14:39:13 <ReinH> soLucien: Then why are you asking about return?
14:39:26 <davean> People didn't want to just make return "return :: Applicative m => a -> m a"
14:39:32 <soLucien> http://pasteboard.co/7O6aC3r4t.png
14:39:36 <davean> And instead left it in the monad class
14:39:40 <soLucien> it's from LYAH
14:39:41 <iphy> same for the ClientT version
14:39:47 <soLucien> in the applicative dicsussion
14:39:51 <soLucien> discussion
14:39:58 <Enigmagic> iphy: okay, does the type of `ServerType m Int` change based on what type m is?
14:40:09 <iphy> no
14:40:13 <iphy> good point
14:40:14 <soLucien> i was trying to get what return does in this context
14:40:20 <soLucien> but because it is the same as pure
14:40:22 <ReinH> soLucien: This is one of the reasons I don't like LYAH
14:40:24 <sdrodge> soLucien: So the answer to your question is that return is the same thing as pure, except specialized to monads.
14:40:26 <ReinH> it introduces concepts out of order
14:40:32 <Enigmagic> iphy: so perhaps you want something like `implement :: Interface f -> HaskellType f -> m (ServerType f)`
14:40:43 <EvanR> return x = [x]; return x = Just x; return x = \r -> x, not really deserving as much fanfare as computational domains
14:40:43 <ReinH> return is something that IO does that satisfies the Monad laws
14:40:47 <ReinH> and has the appropriate type
14:40:49 <ReinH> that's all
14:40:50 <soLucien> ReinH something else that you would recommend ?
14:40:51 <iphy> uhm
14:40:56 <Aruro> soLucien: there are no contexts in haskell, context is too big of a word/idea, haskell has just types, in this case container types
14:41:40 <ReinH> soLucien: Hutton's new Programming In Haskell is great
14:41:43 <Aruro> soLucien: contexts are more about interpretation of types
14:41:50 <prsteele> I don't know, I sometimes think of monads as _computational contexts_. It's what helped me understand the phrase "programmable semicolons"
14:41:57 <ReinH> ("container" is also the wrong word)
14:42:01 <iphy> Enigmagic: for f = Int -> Int -> Returns Int, the function would be: implement :: Interface (Int -> Int -> Returns Int) -> (Int -> Int -> Int) -> Int -> Int -> ServerT m Int
14:42:04 <ReinH> It has higher-kinded types.
14:42:09 <EvanR> programmable semicolon is also the wrong word ;)
14:42:15 <Aruro> ReinH: whats wrong with container?
14:42:19 <EvanR> youre limited to monad laws
14:42:26 <prsteele> I'm not saying it's the _right_ word, just what helped me understand the phrase :)
14:42:34 <ReinH> Aruro: It's too facile
14:42:38 <iphy> Enigmagic: not: -> m (Int -> Int -> ServerT ? Int)
14:42:39 <ReinH> It either explains nothing or everything
14:42:56 <ReinH> Proxy is not a container, but it is a Functor, Applicative, Monad
14:42:58 <EvanR> everything is a container
14:43:10 <ReinH> So you either say "a container can contain nothing", which is just redefining container to be a meaningless term
14:43:11 <EvanR> container oriented programming
14:43:16 <ReinH> or you say "Ok, container is a bad term"
14:43:33 <Aruro> why bad? functor is nothing but touching container
14:43:37 <ReinH> No it isn't.
14:43:41 <Enigmagic> iphy: and definitely not `ServerT m (Int -> Int -> Int)` ?
14:43:46 <EvanR> a player is a container of game strategies, a game is a container of moves
14:43:47 <Aruro> ReinH: then what it is?
14:43:51 <ReinH> I just gave an example of why it isn't
14:43:59 <davean> is Void a container?
14:44:04 <ReinH> a Functor is a type of kind * -> * with an implementation of fmap that satisfies the laws.
14:44:17 <EvanR> Void contains _|_
14:44:18 <Aruro> and this kind is a Container
14:44:22 <ReinH> No it is not
14:44:26 <Aruro> yes it is
14:44:29 <Aruro> what is it then?
14:44:30 <iphy> Enigmagic: I'll see if I can refactor ServerT to that
14:44:31 <ReinH> unless you redefine "container" to mean "type of kind * -> *"
14:44:37 <ReinH> in which case the word serves no purpose
14:44:42 <ReinH> It is a type of kind * -> *
14:44:43 <ReinH> that's it
14:44:45 <ReinH> that's what it is
14:44:52 <iphy> Enigmagic: but I can't refactor ClientT to that
14:44:57 <Aruro> well, then i guess you dont need words :)
14:44:59 <geekosaur> Aruro, is Proxy a container?
14:45:02 <EvanR> you can try to refuse Aruro's claim by naming a type of kind * -> * thats not a container
14:45:04 <ReinH> Aruro: I tried that one
14:45:06 <ReinH> They didn't bite
14:45:12 <davean> Aruro: No, the point is we need words that have meanings
14:45:14 <ReinH> EvanR: I did.
14:45:15 <prsteele> I think these phrases should always be interpreted as nothing more than (possbily helpful, possibly harmful) analogies
14:45:19 <EvanR> however, you will instantly be counterrefuted about how any possible thing ever is a container
14:45:20 <geekosaur> someone already mentioned Void too
14:45:25 <davean> Aruro: If you define away all meaning, they're useless
14:45:28 <ReinH> EvanR: Yes, that's what I said.
14:45:31 <Aruro> what does Kind mean?
14:45:36 <ReinH> Are people not reading the things I say?
14:45:38 <Aruro> also meaningless word
14:45:42 <ReinH> No it isn't.
14:45:50 <Aruro> same as type btw.
14:45:51 <ReinH> We know exactly what a kind is.
14:45:54 <ReinH> No it isn't
14:45:55 <geekosaur> a kind is the type of a type
14:45:58 <ReinH> We know exactly what a type is.
14:46:01 <EvanR> kind is a type for types, its "types" which is meaningless ;)
14:46:03 <Enigmagic> iphy: okay, well if not you'll definitely need Returns to take `m` as a parameter for the fundep to work... otherwise there is no way to determine `m` from `Returns r`
14:46:07 <ReinH> We have a rigorous formal understanding of "kind" and "type".
14:46:08 <Aruro> ReinH: tell us what is Type? :)
14:46:17 <ReinH> The fact that *you* don't doesn't mean that it doesn't exist.
14:46:22 <geekosaur> Maybe Int has kind *. Maybe has kind * -> * (give it a type parameter and it gives you a type back)
14:46:29 <ReinH> Aruro: ffs, look up type theory and find out for yourself
14:46:54 <Aruro> ReinH: did you read stanford encyclopedia of philosophy on cathegory theory?
14:46:55 <davean> ReinH: You're their google though
14:47:12 <ReinH> ...
14:47:30 <EvanR> a type is a simplicial set?
14:47:38 <Aruro> ReinH: wander why its in philosophy? beacuse what IS type is not easy to formalize
14:47:47 <ReinH> Also, how is "Ok, 'container' doesn't have a meaning, but that's ok because nothing else does either" an argument that you find compelling?
14:47:51 <ReinH> Yes it is
14:47:58 <ReinH> it has been formalized in a number of ways
14:48:03 <ReinH> you are just apparently ignorant of them
14:48:15 <EvanR> name one way for posterity
14:48:24 <ReinH> ffs I am not your dictionary
14:48:38 <ReinH> go read https://en.wikipedia.org/wiki/Intuitionistic_type_theory
14:48:40 <Aruro> ReinH: i dont see why u bash container analogy when u offered some math formalism
14:48:48 <ReinH> Because that's WHAT IT IS
14:48:58 <ReinH> I am describing the thing
14:49:03 <ReinH> you are describing a bad proxy for the thing
14:49:05 <Aruro> you think like that, i already offered u to use no words :)
14:49:16 <davean> WTF
14:49:18 <Aruro> use formulas 
14:49:22 <ReinH> I did
14:49:25 <soLucien> computational context !
14:49:30 <EvanR> theres a lot of usages of "type", for instance in my other contexts a type is a word to mean "data structure"
14:49:37 <ReinH> A Functor is a type of kind * -> * with an implementation of fmap that satisfies the laws
14:49:42 <EvanR> as silly as sometimes "type" means record of some sort
14:49:44 <ReinH> this is a complete and correct definition of Functor
14:49:48 <ReinH> all of the terms it uses are well defined
14:49:59 <soLucien> a different "universe" where the computation takes place
14:50:02 <Zekka> fwiw I'm also used to using the word "type" for things that are way more broad, and I'm even guilty of using formal words like "functor" that way to try to get an intuition across
14:50:04 <ReinH> The fact that you do not seem to know what the words mean
14:50:08 <ReinH> does not imply that they are meaningless
14:50:09 <Zekka> that's a different use-case than the formal definitions have
14:50:29 <Aruro> ReinH: did you assume you know more than me?
14:50:30 <ReinH> And I am not here to teach you what "type" means. You can learn that yourself if you want.
14:50:45 <ReinH> No, I inferred it based on evidence.
14:50:47 <Aruro> in your argumentation?
14:50:52 <Zekka> they're both valid usecases but you want the words to have different meanings depending on who you're using them with
14:51:02 <EvanR> heres one unhelpful one, a type is an element of a type universe
14:51:17 <EvanR> for instance *
14:51:27 <ReinH> If you say "type is a meaningless word" then I infer that I know more about what 'type' means that you
14:51:33 <Zekka> When I'm speaking to nonprogrammers I say "a type is a name for a kind of thing" which is very imprecise and captures a lot of usages that don't apply in programming languages
14:51:35 <ReinH> I also deduce that this discussion is entirely unproductive.
14:51:40 <ReinH> And I am exiting it now.
14:51:47 <Zekka> But I would never say that to someone who wanted to know what types were in Haskell
14:51:53 <Aruro> ReinH: unproductive was to bash earthly Container analogy
14:51:56 <Zekka> (at least it wouldn't be the only thing I would say)
14:52:03 <ReinH> No, the container analogy is bad
14:52:07 <ReinH> calling attention to that fact is productive
14:52:08 <Tuplanolla> Am I a functor if I can't contain myself?
14:52:14 <davean> The container analogy is litterly an analogy
14:52:17 <ReinH> since it prevents people from using bad models
14:52:20 <ReinH> to understand things
14:52:21 <iphy> https://www.irccloud.com/pastebin/sjbXtuvp/Enigmagic%3A
14:52:30 <davean> and wow do we know the sorts of erros analogies cause in people's thinking
14:52:38 <EvanR> this discussion has been done and from now on it should be auto optimized into a link to the discussion prior, or a better version written up somewhere
14:52:40 <geekosaur> what is the Container in a Proxy, in an IO, in a Void? unless you have decided Container means anything it feels like in which case it doesn't tell anyone anything and you shouldn't bother
14:52:49 <iphy> Enigmagic: ^
14:53:00 <iphy> I was hoping to avoid the IO in Returns here
14:53:01 <ReinH> geekosaur: Yes, I already said this, but maybe your restatement will be more effective. ;)
14:53:10 <iphy> so the Interface is a blueprint, and you could fill in any m
14:53:11 <Aruro> ReinH: you offered no MODEL btw, you offered just definition from book
14:53:16 <ReinH> Aruro: that is the model.
14:53:19 <Aruro> nope
14:53:21 <geekosaur> some things do not have simple models
14:53:21 <iphy> Client = ClientT IO
14:53:21 <ReinH> Yep
14:53:32 <ReinH> "nuh uh" "uh huh"
14:53:38 <Zekka> ReinH: FWIW I think formal definitions often don't help people understand, but they usually won't make people more wrong
14:53:41 <geekosaur> you can try to come up with one and it will be wrong. see every monad tutorial in existence.
14:54:05 <EvanR> Aruro: in the beginning of the idris book, the better analog for types is the shapes where pegs go in a childrens toy. The objects that go in them are things "with that type"
14:54:12 <ReinH> There are approximations of type theory that are far more effective as models than "everything is a container dur"
14:54:16 <Zekka> I think saying it formally is super defensible, even though I'm pretty sure most people's learning process for this inovlves assuming some wrong things first
14:54:19 <davean> I mean, mathematical definitions are nearly definitionally models?
14:54:23 <ReinH> e.g., explaining what a kind is in non-formal terms
14:54:27 <ReinH> rather than saying "containers"
14:54:32 <ReinH> like it's some sort of magical word
14:54:45 <Zekka> (when I learned monads, I started with container analogy and then learned why it was wrong)
14:54:54 <geekosaur> ReinH, I know you did. I was emphasizing
14:55:16 <ReinH> This is nowhere near the first time this "everything is a container" analogy has been problematic, and nowhere near the first time someone has championed it regardless.
14:55:24 <EvanR> the shape analogy and what that means operationall can be formalized with logic, but it still doesnt really define what "type" means concretely. and it doesnt need to
14:55:42 <Aruro> ReinH: Haskell does not check functor laws so they are not laws at all, in case u are big fan for math
14:55:50 <ReinH> Humans do.
14:55:56 <Aruro> here we go
14:55:57 --- mode: ChanServ set +q *!*@AAnnecy-653-1-81-186.w90-41.abo.wanadoo.fr
14:56:06 <ReinH> Programming is a social activity. It matters what humans do.
14:56:41 <ReinH> At this point you have offered nothing substantive beyond "functers are too containers la la la" and I am not going to respond any more.
14:56:52 <MarcelineVQ> Someone disagreeing isn't reasonable grounds for moderation. On the topic though (-> r) is enough to show why container is a weird term, isn't it?
14:58:03 <ReinH> MarcelineVQ: not really, fsvo "container" :)
14:58:04 <Welkin> MarcelineVQ: someone is too trigger happy to silence people in here, and they do it from the shadows
14:58:16 <ReinH> If we can define "container" precisely, we can say whether it's true or not that ((->) r) is a container.
14:58:20 <ReinH> Until that point, we aren't even wrong.
14:58:25 <ReinH> we're just making no sense.
14:58:37 <MarcelineVQ> That's fair
14:58:57 <Enigmagic> iphy: dunno, i would still lean towards applicative instead and get rid of `m` from ServerType and HaskellType
14:59:21 <Enigmagic> and if you're on a newer version of GHC you can get rid of the Returns type and use closed type families instead
14:59:46 <nshepperd1> IO is a quantum container. Until you open it it lives in quantum superposition of all possible values. Once you do, then you and the cat in the box become entangled in a superposition together :)
14:59:52 <ReinH> nshepperd1: Agreed!
14:59:55 <ReinH> nshepperd1: Or possibly not!
14:59:57 <ReinH> Who can say!
15:00:03 <nshepperd1> Hehe
15:00:07 <ReinH> nshepperd1: words have no meaning!
15:00:23 <davean> ReinH: you have no meaning, go code :-p
15:00:28 <ReinH> yeah
15:00:32 <jonored> Hey, I thought that State RealWorld sucked as an analogy, and there you go all quantum on it :p
15:00:33 <Zekka> imho a lot of people learn stuff by learning wrong stuff first, then refining that
15:00:46 <Zekka> so uh, if we teach newbies tons of wrong things maybe they will eventually move onto right things
15:00:51 <NemesisD> hi all. i'm trying to pre-build a .cabal-sandbox on a CI machine so that on another machine, all dependencies and build artifacts will be in place and won't have to be rebuilt. it turns out cabal.sandbox.config and the package configs all use absolute dirs. i've rewritten all those but when i run cabal build on the final machine packages have "missing files"
15:00:56 <Zekka> this appears to work in physics
15:01:02 <jonored> Now we just need "Prune" on IO and we'll have that linear-time sort, right?
15:01:20 <sdrodge> Aruro: I think what people were trying to say is that the container metaphor gets stretched pretty thin sometimes when it comes to Functors. Some decent examples, imo are ((->) r) and IO.
15:01:40 <geekosaur> NemesisD, cabal sandbox hc-pkg recache
15:01:47 <Zekka> the really important thing is probably to write programs that use a monad somewhere
15:02:07 <sdrodge> Aruro: It doesn't exactly feel right to call a function (which isn't a data constructor) a container, does it?
15:02:09 <Zekka> like, actual non-demo programs
15:02:23 <ReinH> Zekka: Wittgenstein had a lot to say about the idea, he called it "lying to children". Its success depends on the nature of the lies.
15:02:43 <ReinH> we now call it Wittgenstein's Ladder
15:02:44 <sdrodge> Aruro: And having arbitrary side effects isn't exactly a container either.
15:02:49 <EvanR> container is a magic word that distorts and conforms to anything it needs to, i think we should respect that (possibly synonymous with fear it)
15:02:53 <ReinH> And my assertion is that "functors are containers" is not a good ladder.
15:02:58 <ReinH> or a good rung, whatever
15:03:00 <sdrodge> ReinH: am I doing your point justice? ^
15:03:01 <jonored> I'd not really like to go past "Functors generalize containers"; too many examples of no, but also some useful yes.
15:03:07 <Zekka> ReinH: I don't know what Wittgenstein said specifically but I think he's broadly right, and I agree with you in this specific case
15:03:07 <ReinH> sdrodge: I am done with the point :)
15:03:13 <Welkin> ReinH: you mean the Wittgenstein who was in this channel?
15:03:16 <johnw> sdrodge: actually, there is at least one formal definition of container, and it's based on function
15:03:23 <ReinH> Welkin: I mean the philosopher of some note.
15:03:26 <sdrodge> ReinH: You're talking about it right now, lol...
15:03:32 <johnw> sdrodge: http://www.cs.le.ac.uk/~ma139/docs/thesis.pdf
15:03:33 <ReinH> sdrodge: No, I'm talking about talking about it. ;)
15:03:38 <NemesisD> geekosaur: thanks! that seemed to do it. now it does have to rebuild the entire library (but not dependencies), but i think that's because the packaging system seemed to have a different cabal version than it so i had to reconfigure and that invalidated the project. any way around that?
15:04:01 <geekosaur> that I don't know.
15:04:09 <sdrodge> ReinH: I must've misunderstood what you were saying to Zekka then.
15:04:20 <EvanR> containers probably spawned the OOP revolution back in '78 (year made up)
15:04:35 <Zekka> I'm not really trying to discover the new and greatest way to introduce monads to people
15:04:39 <nshepperd1> Actually the above is just a simple consequence of quantum amplitude distributions (and also ordinary probability) having a monad instance
15:04:43 <ReinH> Zekka: To your point (and Wittgenstein's), all of our knowledge of the universe is, in a deep sense, a lie. And perhaps now we should move to #haskell-philosophy, which afaik does not exist...
15:04:59 <sdrodge> johnw: Well, way to ruin my point :P
15:05:04 <MarcelineVQ> it's called haskell-in-depth
15:05:08 <ReinH> sdrodge: it's a service we provide
15:05:22 <nshepperd1> Just like how all monad analogies are really just examples of monads
15:05:46 <ReinH> MarcelineVQ: fsvo "depth", I suppose it is. :)
15:05:56 <Zekka> usually when I teach lately I am teaching more basic and more practical (that is, related to a specific problem) things to people
15:06:04 <geekosaur> "that's deep, man" :p
15:06:10 <EvanR> nshepperd1: last week i modeled IO with an abstract N player game with interruption... i think QM can fit into this model
15:06:17 <Zekka> which is lucky because it's easy to tell small lies (like introducing variables without talking about scoping rules yet)
15:06:36 <c_wraith> what happened to that incredibly enlightening reddit discussion about how burritos are just monads in the category of fud? 
15:06:50 <EvanR> https://www.cs.cmu.edu/~edmo/silliness/burrito_monads.pdf
15:07:16 <dmj> ah yes, the tortilla endofunctor, I know it well
15:07:21 <c_wraith> I was actually thinking of edwardk's remarks on reddit. 
15:07:50 <c_wraith> they were a far more enlightening discussion of what monads actually are than any analogy. 
15:07:56 <Zekka> (I'm also lucky that the guys I mentor are not learning Haskell, which I've found really hard to teach)
15:08:46 <EvanR> i am still trying to comprehend the connection between monads and algebra, or monads and topological closures (maybe thats really the same thing)
15:09:00 <ReinH> Zekka: What's basic and practical is: here's *a* Functor/Applicative/Monad. Here's another one. Here's another one.
15:09:13 <jonored> topology connects to all the things, it's just kinda how it is.
15:09:25 <ReinH> Zekka: In order for an abstraction to make sense, you have to understand the motivation.
15:09:30 <Zekka> ReinH: I think that's a different sense of "practical" still. Usually I'm dealing with people who are literally saying "my code doesn't work and I don't know why"
15:09:36 <ReinH> Sure
15:09:38 <Zekka> people who want to learn monads usually don't have any code yet
15:10:06 <johnw> Zekka: I deeply disagree with that assumption
15:10:28 <Zekka> johnw: You think so? Give me an idea, I might have said something different from what I meant
15:10:35 <c_wraith> johnw, dunno. you see it all the time in here. 
15:10:38 <johnw> you can write a ton of Haskell code without having any real understanding of monads as an abstract concept
15:11:03 <c_wraith> but so many people who know no haskell demand to learn monads first. 
15:11:06 * jonored suspects that people who want to learn monads have probably already used some not neccessarily via the monad names, and just aren't aware of it.
15:11:08 <mgsloan> Yup, I've seen Oleg teach Haskell to linguists, including grokking typeclasses.  Monads were never touched.
15:11:15 <Zekka> Oh yeah -- but I guess I'm assuming that a newbie is following the LYAH-type track where they've only written small programs that aren't very practically useful
15:11:24 <Zekka> You're absolutely right, you can learn it without that
15:11:25 <johnw> I know several people, expert programmers in other languages, who've written code for xmonad or some other Haskell library they want to use, but don't yet know monads -- or even really care.  So I'm just questioning the "usually" part of what you said...
15:11:26 <mgsloan> People who make broad statements about monads and newbies on the other hand... ;)
15:11:34 <ReinH> The understanding comes in handy when you write a type and then say "Oh, I bet this is a Monad." Otherwise, a functional (heh) understanding of how to use do notation suffices for a lot.
15:11:44 <Zekka> When I was learning, the other people I knew at the same time were learning monads at the same time they were writing their first useful program
15:11:45 <johnw> c_wraith: now that's certainly true
15:11:55 <johnw> "the monad mystique" is what drives some people to our doorstep
15:11:59 <ReinH> Zekka: See, this is another reason I don't like LYAH.
15:12:04 <ReinH> Basically I don't like LYAH.
15:12:14 <Zekka> This was also at the time that people were still recommending LYAH, by the way
15:12:15 <EvanR> can we histogram the channel log for "monads" and hope that it waxes and waves with lunar cycles, or sun spots, or something
15:12:22 <EvanR> wanes*
15:12:23 <ReinH> Zekka: People still recommend it.
15:12:33 <johnw> EvanR: lol
15:12:56 <Zekka> It also seems like the sort of thing that's likely to happen if you're trying to introduce Haskell to an impatient person who wants to immediately do general-purpose prorgamming and is used to a language like Python
15:12:59 <jonored> I think the name is a troublingly significant portion of that.
15:13:06 <EvanR> ^
15:13:15 <Zekka> but those guys should probably stick to languages they already like, if their first goal is to have a program that works for a specific task
15:13:18 <systemfault> My personal experience with learning Haskell via LYAH was the same as trying to learn a natural language by remembering different words but without learning how to use them together.
15:13:25 <mgsloan> I don't have an opinion on LYAH, since I didn't use it to learn.  People probably recommend it because it has pretty pictures and that makes it approachable
15:13:39 <mgsloan> Or rather, makes it appear to be approachable?
15:13:52 <Zekka> LYAH was my first resource and I kinda recommend against -- I spent a lot of time scrutinizing it thinking the information I wanted was there, but in the end I had to dig it up myself
15:13:53 <systemfault> At the end of LYAH, i knew a few things... but still couldn't fo anything meaningful with the,
15:13:54 <geekosaur> actually it was recommended because there weren't a lot of alternatives at the time
15:13:56 <johnw> I liked LYAH, but I appreciate cutness as a pedagogical tool
15:14:01 <Zekka> that isn't a bad path as a learner, but you don't need a book to take that path
15:14:16 <Zekka> I actually have to go, but I may be back later
15:14:24 <geekosaur> and people just kept recommending it when there were
15:14:31 <johnw> Zekka: you can only bind other activities into this channel; you cannot leave
15:14:31 <davean> geekosaur: really?
15:14:52 <johnw> because this is, after all, the container called #haskell
15:14:52 <mgsloan> Yeah, that's true, I remember LYAH being a bit like a first-of-its-ilk newcomer Haskell book
15:14:57 <davean> geekosaur: It seems there were rather  decent number of learning books before LYAH
15:15:05 <systemfault> Like what?
15:15:11 <geekosaur> there were some (fairly expensive iirc) books targeting university courses.
15:15:13 <systemfault> RHW was awful for me.
15:15:15 <mgsloan> Haskell school of expression by Hudak was cool
15:15:21 <mgsloan> And definitely predated LYAH
15:15:24 <systemfault> *RWH sorry
15:15:39 <davean> RWH, Hudack, I've seen 2 or 3 others
15:15:42 <johnw> yeah, RWH felt too much like solving problems I didn't care about
15:15:48 <systemfault> ^ THAT
15:15:48 <davean> I don't memorize Haskell learning boosk though :)
15:15:55 <pharaun> RWH was great it gave me initial examples/problem solving
15:15:58 <pharaun> then i was able to go from there
15:16:02 <mgsloan> I think LYAH was the first modern newcomer book, the others were good but old 
15:16:07 <pharaun> didn't like LYAH at all
15:16:13 <geekosaur> and some of the problem with that is, one runs into enough courses (directly or described by friends) where you really do need to be doing the classwork as well as having the book...
15:16:26 <mgsloan> I didn't feel like RWH was a newcomer book, it was very much so a "fill in the practical knowledge gaps" book
15:16:41 <geekosaur> so one can be fairly leery of trying to learn just from a university textbook
15:16:53 <pharaun> i learn better with practical knowledge, then i can fill it in with theorical reasoning
15:16:59 <systemfault> The exercices were really bad because they were often requiring things you had not learned at that specific point in the book
15:17:07 <geekosaur> and yes, RWH did have some introductory material but it was mostly trying to fill the "next step"
15:17:11 <Welkin> RWH was awful
15:17:26 <davean> mgsloan: Really? When I read RWH I felt it was too newcommer oriented
15:17:31 <mgsloan> Really?  I liked it, but I tend to like reading material regardless of organization levels
15:17:50 <systemfault> pharaun: Me too, I finally learned the whole functor/applicative/monad stuff when I reimplemented them in other languages.
15:17:51 <Welkin> is*
15:18:05 <mgsloan> The real "next steps" book is Marlow's book Parralel and Concurrent Haskell.  That book is _amazeballs_
15:18:17 <ReinH> it's super good
15:18:27 <ReinH> Hutton's new edition of Programming in Haskell is also super good
15:18:35 <mgsloan> And he updated it recently!
15:18:37 <ReinH> As is Bird's Thinking Functionally with Haskell
15:18:41 <ReinH> thus "new edition" ;)
15:18:47 <mgsloan> Ahh yes :D
15:18:48 <geekosaur> I think a fair amount of the problem with RWH is what johnw said, actually: there weren't a lot of practical, useful examples at the time
15:19:13 <systemfault> I don't care about implementing your bloom filter... I don't care about implementing a JSON parser...
15:19:13 <mgsloan> Right, nowadays RWH is looking dated.  But at the time it was a great book for me to read
15:19:17 <ReinH> (Bird's book is a rewrite of Intro to FP Using Haskell, my previous favorite Haskell book of all time)
15:19:29 <ReinH> And, in fact, favorite FP book of all time.
15:19:30 <mgsloan> systemfault: Well then write the book you would care about..
15:19:31 <mgsloan> :D
15:19:41 <systemfault> mgsloan: Someone already did.
15:19:42 <geekosaur> and an awful lot of people seem to think that if it's not about the web, it's not useful at all any more
15:19:53 <pharaun> -_-
15:19:54 <mgsloan> I for one love bloom filters and parsing
15:20:06 <mgsloan> They are both really cool problems / solutions
15:20:16 <systemfault> mgsloan: Me too... but not when I'm learning the core language.
15:20:25 <pharaun> i liked the parsing one, cos i find myself spending a good % of my time with any project.... parsing
15:20:35 <pharaun> so it was great to bootstrap me at least into something useful initially
15:20:40 <mgsloan> systemfault: It is to liven up the material.  I hate intro material that just does stdout
15:20:43 <pharaun> then i was able to just kinda... organically pick up the rest
15:20:48 <mgsloan> Well, bloom filters and parsing is still stdout
15:20:58 <mgsloan> I like intro materials that get into graphics and sound like hudak's book
15:21:20 <systemfault> I haven't read Hudak's book, but that looks interesting.
15:21:37 <mgsloan> It's old but fascinating if you are into music
15:21:51 <johnw> mgsloan: funny, that's exactly the type of examples I like least
15:21:57 <EvanR> https://cdn.meme.am/instances/500x/71978262.jpg (ancient aliens monads)
15:22:05 <pharaun> i don't do sounds
15:22:05 <mgsloan> Haha well we have different styles of computer use johnw :)
15:22:08 <pharaun> that would be no good for me
15:22:13 <davean> I don't get much out of trivial problems, I learn best with real problems so I can see comprimises and such
15:22:14 <pharaun> graphics would have been good as well
15:22:22 <Welkin> write yourself a scheme is good for learning haskell
15:22:31 <Welkin> if it was updated I mean
15:22:32 <davean> You have to actually deal with complexity for me to learn the core language
15:22:38 <Welkin> and had more explanations
15:22:39 <mgsloan> johnw: Just today we had a stack collaborator meeting.  We made some jokes about sharing emacs config being like sharing underwear XD
15:22:45 <pharaun> davean: well i used rwh to bootstrap
15:22:51 <pharaun> then i often reimplement various projects of mine
15:23:01 <pharaun> ie i have a comic book reader, a... irc bot, couple other projects
15:23:04 <systemfault> mgsloan: More or less true :P
15:23:16 <pharaun> i'm partial to the irc-bot one cos - some concurrency, some network, some parsing, and a couple other bits n' pieces
15:23:31 <pharaun> (could easy add stuff to it, ie db for storage, network calls to other stuff, parsing for the protocol, etc)
15:23:52 * geekosaur has to admit that while xmonad being featured in RWH was neat in a sense, a niche within a niche within a fairly unix-specific environment is ... not very real world for most people
15:24:00 <mgsloan> Please forgive my crass humor, but using johnw's emacs config is like buying celebrity used underwear XD
15:24:11 <ReinH> >_<
15:24:14 <Welkin> RWH is cited as an example by haskell haters
15:24:23 <Welkin> and they mention it specifically as a reason they gave up on the language
15:24:27 <pharaun> >_<
15:24:36 <ReinH> My experience is that haters don't need reasons
15:24:37 <Welkin> and the ironic title
15:24:37 <systemfault> Welkin: I did give up 2 times because of it.
15:24:43 <pharaun> Welkin: interesting
15:24:46 <luigy> mgsloan what about something like spacemacs? :P
15:24:51 <pharaun> cos its *what* made me finally start to... grasp some of it
15:25:00 <ReinH> spacemacs is pretty ok sort of but I mean it's software so still pretty garbage
15:25:03 <pharaun> at least enough to do something interesting with it as i filled in the more theorical stuff
15:25:03 <mgsloan> luigy: All 3 of us in that conversation use spacemacs :)
15:25:09 <Welkin> personally, the only reason I got into haskell was because of LYAH
15:25:33 <mgsloan> And spacemacs heavily uses johnw's awesome use-package library
15:25:36 <systemfault> LYAH + CIS194 + Haskellbook for me.
15:25:41 <pharaun> if i learned it via lyah i would have not gotten into haskell amusingly enough
15:25:41 <Welkin> then I moved on to better resources, like the cis course, some nicta stuff, write yourself a scheme, typeclassopedia, this channel, yesod book
15:25:42 <ReinH> mgsloan: use-package is great
15:25:54 <pharaun> so i guess this discussion is a great example of why many different kind of book/resources is a good thing (tm)
15:26:03 <systemfault> Welkin: Typeclassopedia, that thing is AWESOME.
15:26:04 <mgsloan> I know!  My first peak at it was actually from john himself at ICFP last year!
15:26:09 <ReinH> Welkin: You complained about RWH, but write yourself a scheme is super out of date.
15:26:13 <ReinH> Doesn't even compile on modern GHC.
15:26:20 <Welkin> so LYAH is doing a lot of good for newcomers
15:26:27 <Welkin> it makes haskell approachable
15:26:51 <mgsloan> pharaun: Indeed!  Different learning styles, different preferences == different resources for different folks
15:27:08 <davean> ReinH: That teaches the most important part of being a Haskeller - Updating your code so we can finally have nice things
15:27:12 <mgsloan> There is no "One true way" to learn
15:27:16 <ReinH> It also makes some questionable choices.
15:27:19 <davean> ReinH: its what seperates us from python
15:27:20 <mgsloan> Except maybe getting down with some code and making it happen
15:27:22 <ReinH> e.g., error handling
15:27:22 <pharaun> ReinH: how so?
15:27:28 <pharaun> oh
15:27:41 <pharaun> i am currently struggling with my own mini-scheme impl with error handling
15:27:48 <pharaun> could you elaborate a bit more on that one?
15:27:55 <ReinH> davean: no, I think you have that confused with complaining that other people's code hasn't been updated.
15:28:08 <pharaun> (i ended up doing a half half from the schemer thing, and half my own thing) so i'm wondering what you found bad about it
15:28:25 <pharaun> mgsloan: ya
15:28:55 <ReinH> pharaun: it also completely misses out on a nice opportunity to discuss evaluation strategies, which would be relevant to Haskell
15:29:09 <ReinH> since understanding lazy evaluation is a big part of understanding Haskell/GHC
15:29:31 <pharaun> ahhh
15:29:44 <ReinH> "here's call by name, here's call by value" etc
15:29:56 <ReinH> scheme is a great playground for that
15:30:13 <pharaun> yup
15:30:35 <pharaun> probably will never have strict scheme compat (that's what husk does) but its a fun little playing ground to try out various things
15:30:38 <ReinH> "lexical scoping means making the environment a list of environments rather than one big map"
15:30:38 <ReinH> etc
15:30:40 <mettekou> SICP even discusses them in detail.
15:30:44 * jonored sads as he finds that his just-updated nixpkgs is not building lambdabot correctly with GHC 7.10.3 :(
15:30:53 <pharaun> ReinH: yeah, one change i did was trying out ST and STrefs instead of iorefs
15:30:59 <pharaun> and various other approaches
15:31:06 <ReinH> pharaun: Either. :)
15:31:09 <EvanR> is there a simple way to know how wide the terminal is to know if im print out stuff that is too long
15:31:27 <pharaun> then for error handling, i ended up going back to Either iirc
15:31:33 <pharaun> still not 100% sold on that one
15:31:35 <ReinH> Simple? No. A way? Yes, probably.
15:31:35 <EvanR> yet im not wasting horizontal space with conservative guesses
15:31:43 <ski> EvanR : `tput cols', perhaps ?
15:31:55 <pharaun> ReinH: i'm actually not sure how to implement the env stuff in the scheme without either st or ioref
15:31:59 <ReinH> EvanR: a few package provide some way to get terminfo values
15:32:02 * ski supposes there's some equivalent operation in a library
15:32:06 <EvanR> tput, that is bad ass
15:32:10 <ReinH> pharaun: pass it around
15:32:15 <mettekou> pharaun: ReaderT or StateT should do nicely.
15:32:28 <pharaun> wouldn't that give issue with nested closures tho?
15:32:33 <ReinH> mettekou: Both of which are enterprise versions of passing it around. ;)
15:32:39 <pharaun> and passing in the new values in/out of the closure 
15:32:52 <pharaun> guess i need to do an impl of that and see how that works out
15:32:53 <ReinH> pharaun: the nested closure issue is solved by passing a list of environments
15:33:02 <ReinH> free lexical scoping :)
15:33:12 <pharaun> .... 
15:33:15 <pharaun> why didn't i think of that
15:33:16 <ReinH> there's a lisp paper that describes this
15:33:24 <pharaun> list of envs! wow
15:33:30 <ReinH> yep
15:33:34 <ReinH> it's an old code but it checks out
15:33:35 <pharaun> yes that would do the trick
15:33:51 * ski . o O ( "static link" )
15:33:54 <pharaun> i was mainly wanting to try to get off ST cos the runST restriction got a bit.... painful
15:34:01 <pharaun> and i really would prefer not to use ioref
15:34:07 <ReinH> yeah that's why I disclike it
15:34:09 <ReinH> dislike it
15:34:18 <ReinH> a really unidiomatic solution
15:34:26 <ReinH> "use an IO escape hatch"
15:34:33 <pharaun> it worked for my initial impl and i was able to get something to work but yeah
15:34:42 <ReinH> sure ofc, just like global state Just Works
15:34:43 * ski used `STRef' for logic variables
15:34:52 <pharaun> and it taught me more about STRefs, i've never used ST before
15:34:57 <ReinH> iorefs are global state for IO actions
15:35:02 <pharaun> so i got to learn its limitations a bit more so its another thing in my toolbox
15:35:05 <pharaun> already used ioref before
15:35:27 <pharaun> anyway "list of envs" for nested closure, there is a paper on this?
15:35:42 <EvanR> down with the global state
15:36:11 <pharaun> mini global re STref but ugh
15:36:18 <pharaun> hence wanting to move away fro that approach
15:36:25 * ski . o O ( threaded synthesized/inherited attributes in attribute grammars )
15:36:38 <pharaun> thanks ski
15:37:00 <ski> pharaun : sorry, that's just a random association, not a suggestion for what you asked
15:37:06 <pharaun> dangit :P
15:37:17 <pharaun> D E C E P T I O N :0
15:37:56 <pharaun> anyway gonna spend some time sooner or later with the list of envs and see how that works out
15:38:34 <ski> pharaun : i haven't followed from the start, but couldn't you just store the environment map inside the closure ?
15:38:46 * ski isn't quite sure what the problem was
15:39:07 <pharaun> ski: iirc i do (the stref) i was mostly trying to figure out the nested envs
15:39:27 * ski . o O ( `data Val = LitInt Integer | Clos (Map Ident Val) Ident Expr' )
15:40:26 <ski> (if you wanted something Scheme-like, you'd need some more stuff thrown in there ..)
15:40:47 <pharaun> i think the (scheme-like) bit was what i got stuck on
15:41:05 <pharaun> but this was like 8 months ago, i should be well relaxed enough to give this another shot :D
15:41:44 <ski> well, you'd have something like `Clos ID (Map Ident Loc) BVL SExpr', i suppose
15:43:44 <ski> (where a `Loc' has an identity, and references a mutable cell. `BVL' is a "bound variable list", possibly dotted)
15:43:54 <pharaun> ah
15:44:47 <ski> the `ID' is for being able to compare procedures by identity
15:46:34 <ReinH> pharaun: http://www.dtic.mil/cgi-bin/GetTRDoc?AD=ADA062925
15:46:39 <ReinH> pharaun: http://oai.dtic.mil/oai/oai?verb=getRecord&metadataPrefix=html&identifier=ADA062925
15:47:49 <pharaun> thanks you two :D
15:48:56 <pharaun> 1979 :o
15:49:46 <pharaun> haha the pdf, well that explains why it was so big, i was wondering about that while downloading it
16:22:11 <soLucien>         ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)  
16:22:22 <soLucien> what is the lambda saying ?
16:22:39 <Welkin> that is appl
16:22:42 <Welkin> :t ($)
16:22:45 <lambdabot> (a -> b) -> a -> b
16:22:46 <Welkin> apply
16:23:15 <Welkin> @djinn (a -> b) -> a -> b
16:23:15 <lambdabot> f a = a
16:23:26 <Welkin> lol what
16:23:51 <lyxia> @djinn a -> a
16:23:51 <lambdabot> f a = a
16:23:58 <jonored> it happens to also be id, because of currying.
16:24:00 <Welkin> :t \f x -> f x
16:24:02 <lambdabot> (t -> t1) -> t -> t1
16:24:05 <lyxia> oh indeed
16:24:29 <jonored> (well, id with a more restrictive type.)
16:25:08 <soLucien> id of a function 
16:25:09 <soLucien> ?
16:25:39 <Koterpillar> :t \fs xs -> zipWith id fs xs
16:25:40 <Skami> Hello! In gtk's documentation, I found GtkGLArea. Is there any way to use it with gtk2hs ?
16:25:41 <lambdabot> [b -> c] -> [b] -> [c]
16:25:54 <soLucien> okay but how do i "read" this lambda ?
16:26:00 <Welkin> soLucien: apply
16:26:11 <Welkin> you can replace it with ($)
16:26:15 <soLucien> (\f x -> f x)
16:26:19 <Koterpillar> soLucien: given a function f and a value x, apply f to x
16:26:19 <soLucien> what does this do 
16:26:22 <Koterpillar> ^
16:26:31 <soLucien> okay so the lambda is 
16:26:35 <Welkin> > (+ 3) $ 2
16:26:37 <soLucien> \ f x
16:26:38 <lambdabot>  5
16:26:59 <soLucien> how does haskell know that 
16:27:03 <Welkin> > (\f x -> f x) (+ 3) 2
16:27:04 <soLucien> f is the function ?
16:27:07 <lambdabot>  5
16:27:16 <Welkin> because it is being applied over x in the body
16:27:19 <Koterpillar> soLucien: because it's applied to an argument
16:27:19 <verement> > (\f x -> f x) (+ 3) 2
16:27:22 <lambdabot>  5
16:27:44 <soLucien> okay so it is infered from the right side that f si a function
16:27:57 <soLucien> is*
16:28:18 <verement> > ($) (+ 3) 2
16:28:20 <Koterpillar> yes, see again:
16:28:23 <soLucien> because -> f a , it understands that f is a function, and a is the parameter
16:28:24 <lambdabot>  5
16:28:25 <verement> > id (+ 3) 2
16:28:25 <Koterpillar> :t \f x -> f x
16:28:30 <lambdabot>  5
16:28:30 <lambdabot> (t -> t1) -> t -> t1
16:28:43 <Koterpillar> this gives f :: t -> t1, x :: t1
16:29:14 <soLucien> i see , yes that makes sense
16:29:22 <Skami> Wouldn't in be x :: t
16:29:26 <Skami> *it
16:29:38 <Koterpillar> Skami: yes, sorry, x :: t
16:31:35 <Squarism> Anyone know if theres some "virtual-dom" (or alike) based ghcjs framework available? Found some "ghcjs-virtial-dom-bindings" but they were inactive / hadnt many users (if its proportional to github issues).
16:31:52 <Welkin> vdom
16:33:00 <Squarism> Welkin, https://github.com/ghcjs/ghcjs-vdom?
16:33:16 <Welkin> yeah
16:33:21 <Welkin> there are a few of them
16:33:53 <Squarism> had hoped there were one with lots of users and activity. =/
16:35:51 <Welkin> well this one is under the official ghcjs project
16:36:04 <intothem1untains> How was it possible again to write first the operation and than the condition within guards?
16:36:44 <intothem1untains> s/than/then/
16:40:15 <ReinH> Squarism: reflex-dom?
16:40:35 <ReinH> intothem1untains: can you give an example?
16:40:46 <intothem1untains> | response if condition
16:41:01 <ReinH> That's possible?
16:41:03 <Squarism> ReinH, it doesnt use virtual-dom or anything alike.
16:41:07 * intothem1untains is gonna end without battery
16:41:09 <ReinH> Squarism: oh ok
16:41:21 <Welkin> yeah, reflex-dom mutates the dom directly
16:41:25 <ReinH> yay
16:41:26 <intothem1untains> ReinH: that's not the exact syntax, but I read somewhere something similar
16:41:43 <ReinH> intothem1untains: can't think of anything like that
16:41:47 <ReinH> but obv I don't know everything
16:42:11 <ReinH> Welkin: I just assumed it would be doing something efficient. Woops...
16:42:14 <intothem1untains> battery is gonna die, see you!
16:42:16 <geekosaur> only thing I can think of is a misunderstanding of pattern guards?
16:45:24 <MarcelineVQ> intothem1untains: do you mean m-XMultiWayIf ?
16:45:49 <MarcelineVQ> -XMultiWayIf https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/syntax-extns.html#multi-way-if
17:30:18 <ydl> is anyone using the llvm backend on windows? preferrably with stack?
17:31:27 <dmwit> ?where justask
17:31:28 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
17:34:35 <dmwit> ?tell Skami You may be interested in https://wiki.haskell.org/Gtk2Hs/Demos/GtkGLext/hello.hs which demonstrates how to use GL and gtk2hs together.
17:34:35 <lambdabot> Consider it noted.
17:36:59 <VitorCBSB_> Is it correct to say that typeclasses are a (limited?) form of refinement typing?
17:37:04 <dmwit> ?tell Skami See also http://hackage.haskell.org/package/gtkglext
17:37:04 <lambdabot> Consider it noted.
17:37:29 <ClaudiusMaximus> dmwit: unfortunately afaik gtkglext is deprecated/abandoned (not supported in recent gtk) - but apparently recent enough gtk has a native replacement (though i don't know what it is)
17:37:45 <mgsloan> ydl: There is a discussion here, but not windows specific https://github.com/commercialhaskell/stack/issues/1742
17:37:47 <dmwit> VitorCBSB_: I don't really think so. Usually refinements assert something about the behavior of values in the type, whereas typeclasses really don't statically enforce anything about behavior.
17:38:26 <mgsloan> ydl: I would just try `ghc-options:` with `  "*": -fllvm` and it might just work
17:38:44 <mgsloan> (in your stack.yaml)
17:39:13 <dmwit> ClaudiusMaximus: Oh, dang. Is that comment about gtk itself or gtk2hs?
17:39:29 <ClaudiusMaximus> dmwit: gtk at the C level i think
17:39:34 * dmwit nods
17:41:09 <ReinH> VitorCBSB_: http://goto.ucsd.edu/~rjhala/liquid/abstract_refinement_types.pdf
17:44:08 <ydl> mgsloan: actually my problem is i get segmentation faults when compiling programs with a locally compiled llvm. i'm trying to figure out how to get a working llvm.
17:46:30 <VitorCBSB_> ReinH: Hahaha, I'm a bit of a newbie to automatic reasoning (and refinement typing), that paper is a bit outside my comfort zone. :)
17:55:37 <ReinH> VitorCBSB_: TL;DR: yes, there is a connection of sorts.
17:59:03 <mgsloan> ydl: Best of luck to you! Unfortunately that is outside of my area of expertise
18:14:20 <lethjakman> What is the operator for |>
18:14:31 <lethjakman> I want to do something like this:
18:14:37 <lethjakman> 3 |> timesThree
18:14:54 <Welkin> ?
18:14:56 <Welkin> what?
18:15:04 <lethjakman> Sorry. 
18:15:07 <jle`> lethjakman: what do you want |> to do?
18:15:09 <Welkin> |> can be whatever you want
18:15:20 <Koterpillar> lethjakman: I think you're looking for (flip ($))
18:15:21 <Welkin> |> is append for Data.Sequence.Seq
18:15:25 <Koterpillar> :t flip ($)
18:15:27 <jle`> @let x |> y = x * y
18:15:28 <lambdabot> a -> (a -> c) -> c
18:15:29 <lethjakman> I want to pipe 3 into a function timesThree that looks like this timesThree :: Num a => a -> a
18:15:31 <jle`> > 10 |> 3
18:15:31 <lambdabot>  Defined.
18:15:31 <Welkin> :t (&)
18:15:34 <jle`> :)
18:15:34 <lambdabot> a -> (a -> b) -> b
18:15:35 <lambdabot>  error:
18:15:35 <lambdabot>      Ambiguous occurrence ‘|>’
18:15:35 <lambdabot>      It could refer to either ‘Lens.|>’,
18:15:37 <lethjakman> Is that defined anywhere?
18:15:44 <lethjakman> Or do I have to define it?
18:15:50 <Welkin> yes
18:15:54 <jle`> lethjakman: do you mean `x |> f = f x` ?
18:15:58 <Welkin> (&) = flip ($)
18:16:03 <jle`> if that's what you want, it's in Data.Function, as (&)
18:16:11 <jle`> x & f = f x
18:16:30 <lethjakman> Yep
18:16:32 <lethjakman> That's exactly it!
18:16:35 <lethjakman> Thank you!
18:16:35 <jle`> > 10 & negate
18:16:37 <lambdabot>  -10
18:16:46 <jle`> be aware that using it heavily is not really idiomatic haskell style
18:16:52 <lethjakman> OK. 
18:17:02 <lethjakman> Makes sense. 
18:17:05 <jle`> instead of 10 & negate, consider writing 'negate 10'
18:17:25 <Welkin> it's normally used as part of lens
18:17:30 <Welkin> I've never used (&) in my life
18:17:38 <jle`> yeah, it's a part of certain eosteric styles
18:17:38 <lethjakman> Do you not use lens?
18:17:47 <Welkin> I haven't found a need for it yet
18:17:51 <jle`> *esoteric
18:17:53 <lethjakman> Fair enough. 
18:17:58 <lethjakman> I liked it in combination with aeson. 
18:18:00 <jle`> well, diagrams uses it too, but it has to define its own because fixities are weird
18:18:18 <jle`> i don't think you ever really need lens, it's just something useful you can plop down in your everyday code :)
18:18:23 <jle`> but i rarely use the operators myself
18:18:38 <slack1256> lens for executables, never for libraries
18:19:07 <lethjakman> That's fair. 
18:19:11 <jle`> a lot of library DSL's have a specific style that uses &, so there's that.  but it's just not commonly used in normal non-DSL non-specific-library-style code
18:19:21 <lethjakman> Honestly I was just watching an F# video, and I knew haskell had it, but I couldn't remember how. 
18:19:37 <jle`> yeah, i think elm has one too that people often ask about
18:19:38 <Welkin> slack1256: lol, you must remember my regular complaint about the sdl2 package then
18:19:45 <lethjakman> Yeah. 
18:20:02 <lethjakman> <| is $ and |> is & apparently. 
18:20:08 <Welkin> elm syntax is confusing with <| and |>
18:20:13 <lethjakman> I agree. 
18:20:36 <lethjakman> I just want a elm like library I can use in GHCJS
18:20:47 <lethjakman> The FRP aspect of it is really nice, but it's just not as powerful. 
18:20:56 <Welkin> elm is not frp
18:20:57 <Welkin> lol
18:21:02 <lethjakman> No? 
18:21:07 <Welkin> if you want real frp use reflex and reflex-dom
18:21:09 <slack1256> not anymore ;-)
18:21:13 <lethjakman> I mean, I know they changet it a bit recently. 
18:21:24 <Welkin> it was never frp, but was frp-like
18:21:26 <lethjakman> But I mostly used it a year ago or so. 
18:21:36 <slack1256> Welkin: sdl2 used lens? I don't remember seeing any of the operators. It uses linear but that understandable
18:21:43 <Welkin> now it uses the "elm architecture" which is what Redux is based on
18:21:45 <lethjakman> are reflex and reflex-dom fast?
18:22:02 <Welkin> slack1256: the high-level package, which ate the low-level bindings, too, requires lens
18:22:04 <lethjakman> Very interesting. 
18:22:14 <Welkin> lethjakman: yeah, they should be
18:22:26 <Welkin> join #reflex-frp if you want to ask about it
18:22:59 <Welkin> I believe the virtual dom was created to combat problems with the dom and javascript
18:23:11 <lethjakman> Sure thing. Thank you. 
18:23:22 <Welkin> but haskell can get around that I think
18:23:28 <Welkin> that's what I was reading just now
18:24:34 <slack1256> https://hackage.haskell.org/package/sdl2 or is it another package?
18:24:43 <Welkin> yeah, that's it
18:25:56 <slack1256> wtf, version 2.1.3 doesn't requires lens but version 2.1.2.x does
18:26:16 <c_wraith> slack1256: lenses can be defined without a dependency on the lens package
18:26:31 <Welkin> slack1256: linear requires lens
18:26:36 <c_wraith> slack1256: in fact, that was a design goal of the lens package.
18:28:58 <Cale> Welkin: I think there might still be a place for it -- there are some scenarios where it might be nice to have a small virtual DOM restricted to a single reflex-dom widget. For the most part though, the problem that the virtual DOM solves is that if you're computing the DOM in a coarse-grained way from the whole model at once, you need a way to diff things and apply only the minimal changes required because replacing large subtrees of 
18:28:58 <Cale> the DOM and having everything re-render is slow and poorly behaved.
18:29:22 <Cale> This problem doesn't come up so much with reflex-dom's way of breaking things up into smaller and smaller parts
18:29:58 <lethjakman> Is there a FRP sdl2 engine?
18:30:20 <Welkin> you can use anything you want with sdl
18:30:55 <lethjakman> I just found this: https://github.com/haskell-game/fungen
18:31:01 <lethjakman> So I was curious if there were the FRP version. 
18:40:11 <EvanR> which package has an integer square root
18:40:22 <EvanR> or integers log
18:40:42 <EvanR> or cool integer algorithms
18:41:02 <Welkin> what is that
18:41:20 <Welkin> integer sqrt would be easy to compute
18:41:44 <EvanR> perhaps but would be nice to have the most optimal version already done for you
18:41:44 <Welkin> just use scanl on 1
18:41:52 <Welkin> and multiply it by itself
18:42:01 <EvanR> huh
18:42:10 <Welkin> you compute it backwards
18:43:22 <EvanR> even that is sufficiently complicated to not justify the inefficiency
18:43:49 <Welkin> what is the integer sqrt of 6?
18:44:08 <EvanR> 2
18:44:23 <Welkin> 1? 1*1 = 1, nope. 2? 2*2 = 4, nope. 3? 3*3 = 9, nope.
18:44:30 <Welkin> or is your definition different?
18:44:55 <EvanR> algorithm 1.12 in this book, modern computer arithmetic uses division, so it must be faster
18:45:04 <geekosaur> the closest integer to the correct answer, as used in gaming contexts etc.
18:46:15 <EvanR> well thats a terrible argument, but guess and check is usually not optimal
18:47:24 <Welkin> EvanR: it is better than plug-n-chug?
18:47:37 <Welkin> or multiple-guess?
18:49:43 <EvanR> multiple-guess sounds even worse than guessing
18:50:23 <EvanR> but thats a good point, if an algorithm could guess and provide wildly bad answers, but not totally random, that might have value
18:50:26 <Welkin> lol
18:50:50 <Welkin> I had a math teacher in high school who called multiple choice tests "multiple guess"
18:51:25 <Welkin> EvanR: isn't that what newton's method is all about?
18:51:58 <geekosaur> numerical methods in general
18:52:38 <tomleb> join /#archlinux
18:52:45 <tomleb> welp
18:52:48 <tomleb> oops
18:54:32 <tomleb> bought the haskell book a while back, damn that book is useful for learning
18:55:00 <Welkin> and even more useful when you run out o firewood in the winter
18:55:06 <Welkin> I'm sure you'll need it up in canada
18:55:31 <tomleb> lel
19:00:15 <EvanR> oh wow... chapter 3 has probablistic rounding for floats
19:00:32 <EvanR> flip a coin and round toward +inf or -inf
19:01:10 <Welkin> monte carlo floats
19:02:28 <pavonia> What is a use case for this?
19:02:38 <EvanR> no idea
19:02:42 <Welkin> trolling?
19:03:41 <EvanR> another problem possible with floats, if you round to m bits, then n < m bits immediately, you might get a different result than using the second rounding by itself (for a given rounding mode)
19:03:43 <geekosaur> fair rounding that amortizes out over large numbers of operations, iirc
19:04:19 <geekosaur> "standard" 5/9 rounding can introduce artifacts in large data sets
19:05:49 <Rarrikins> EvanR: Here's one for floored square root: http://lpaste.net/1349859537678499840
19:07:56 <EvanR> interesting
19:15:05 <pavonia> That feeling when your code produces the correct result but you don't have the slightest idea how it works :p
19:16:09 <Kuros`> the most unsatisfying feeling ever because you know it's most likely full of bugs as well
19:16:52 <pavonia> It typechecks, so it must be correct
19:17:06 <Kuros`> :)
19:22:44 <EvanR> try adding the constraint BugFree program =>
19:22:58 <EvanR> and enable generalized newtype deriving
19:31:02 <soLucien> ghci> Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))  
19:31:03 <soLucien> Just "3!"
19:31:08 <soLucien> how does this Lambda
19:31:13 <soLucien> get preserved across the bind?
19:31:36 <soLucien> i am talking about x
19:33:53 <zyhn> soLucien: it doesn't. the second >>= is part of the \x -> ...
19:36:28 <soLucien> i see thanks
20:01:21 <benzrf> in template haskell, how can i put some user-supplied code into the body of a lambda but be guaranteed that the lambda doesn't capture anything in the user-supplied code?
20:05:04 <c_wraith> benzrf: use the function that generates fresh, non-capturing names to generate the name of the lambda argument
20:05:18 <benzrf> but look at the docu here, it says it can capture https://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH-Syntax.html#v:newName
20:06:22 <c_wraith> benzrf: sure, it has to be capturable, or you can't use it.
20:06:35 <benzrf> o, hold on
20:06:46 <benzrf> so it can capture names made with mkName - but not ones from the argument code?
20:06:51 <benzrf> ach this shits subtle as heck
20:07:03 <benzrf> wait, hold on, this doesnt feel right
20:07:08 <c_wraith> benzrf: no, that's not it
20:07:26 <benzrf> look @ the doc - it can capture names made with mkName
20:08:18 <c_wraith> Ah, that is troubling.
20:11:15 <allenj12> is there a way to test if im actually logged in instead of just having a nickname? wanna test something
20:11:33 <benzrf> whois yourself
20:12:37 <allenj12> benzrf: so it says allenj12 is unknown but also allenj12 is logged in as allenj12 im assuming that means im logged in
20:12:59 <Koterpillar> allenj12: this is not the IRC help channel
20:13:06 <benzrf> the "unknown" is your "realname", i think
20:13:10 <Koterpillar> ^
20:13:24 <allenj12> Koterpillar: sorry
20:14:11 <allenj12> benzrf: gotcha, so guess it worked. thanks, and sorry
20:14:29 <benzrf> its ok
20:23:14 <benzrf> how do i do this though :\
20:35:44 * hackagebot wire-streams 0.1.1.0 - Fast binary io-streams adapter.  https://hackage.haskell.org/package/wire-streams-0.1.1.0 (winterland)
20:35:44 <muyfine> is there a way to monadically fold down a HashMap?
20:36:22 <alercah> HashMap is a monad. Not sure I understand beyond that
20:37:01 <alercah> oh wait, hash*map*
20:37:03 <alercah> nvm lol
20:37:26 <alercah> muyfine: it's not a monad because there's no sensible join operation
20:38:49 <muyfine> something like: Map.foldM :: Monad m => (a -> v -> m a) -> a -> HashMap k v -> m a
20:39:21 <muyfine> I've been using traverseWithKey (which is Applicative): traverseWithKey :: Applicative f => (k -> v1 -> f v2) -> HashMap k v1 -> f (HashMap k v2)
20:39:50 <muyfine> basically want foldM, but with the key also present - eek, I meant above Map.foldWithKeyM
20:40:32 <muyfine> Map.foldrWithKey :: Monad m => (k -> v -> a -> m a) -> a -> HashMap k v -> m a
20:40:35 <muyfine> something like that
20:41:44 <Cale> muyfine: iforM from Control.Lens.Indexed
20:41:55 <Cale> er
20:42:13 <Cale> not quite :)
20:42:25 <Cale> ifoldrM
20:42:33 <Cale> ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b
20:42:47 <Cale> (Eq k, Hashable k) => FoldableWithIndex k (HashMap k)
20:44:43 <Cale> muyfine: https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Indexed.html#t:FoldableWithIndex
20:45:01 <muyfine> oh nice - is HashMap have an instance of FoldableWithIndex?
20:45:09 <Cale> yeah
20:45:10 <muyfine> that looks perfect
21:04:29 <muyfine> Cale thanks - that worked great!
21:35:45 * hackagebot monoid-subclasses 0.4.3 - Subclasses of Monoid  https://hackage.haskell.org/package/monoid-subclasses-0.4.3 (MarioBlazevic)
22:07:37 <Myrl-saki> what is the pattern keyword?
22:08:09 <liste> Myrl-saki: it's for defining pattern synonyms
22:08:11 <Myrl-saki> oh. patternsynonyms.
22:09:09 <Myrl-saki> liste: Checking. Thanks.
22:11:02 <Myrl-saki> oh boi. that sounds complicated. woops.
22:15:38 <c_wraith> Myrl-saki: they're not that complicated - they just let you name patterns.  Pretty handy.  They only get complicated when you combine them with things like view patterns
22:16:05 <Myrl-saki> c_wraith: I see. I'm in class right now, I guess I'll check them out once I arrive home. xD
22:37:41 <kqr> is there a function for `mconcat . Vector.toList`? and similarly, `Text.unlines . Vector.toList`? or am I doing things wrong by using vector?
22:39:48 <c_wraith> kqr: mono-traversable probably has things for that.
22:40:09 <c_wraith> kqr: though if you're using basic boxed Vector, you could use its Foldable instance
22:40:47 <c_wraith> :t fold
22:40:51 <lambdabot> (Monoid m, Foldable t) => t m -> m
22:45:24 <c_wraith> hmm....
22:45:30 <c_wraith> :t fold `asTypeOf` concat
22:45:33 <lambdabot> Foldable t => t [a] -> [a]
23:14:55 <Lokathor> > Package store-core-0.2.0.2 can't be built on this system.
23:14:59 <lambdabot>  <hint>:1:58: error:
23:14:59 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:15:01 <Lokathor> what an ominious error
23:25:26 <kqr> c_wraith, thanks, that's step 1! is there any other reading on when to use Vector vs List? how much of an efficiency gain is a boxed Vector anyway – isn't the major inefficiency all the indirection in the underlying types?
23:26:12 <Lokathor> a Vector saves quite a bit compared to a List, as I understand it
23:41:13 <jle`> hm, what's a plan for unifying `'[b]` and `as ++ '[a]` to show that b ~ a
23:41:19 <jle`> and as ~ '[]
23:58:01 <ocramz> morning all
