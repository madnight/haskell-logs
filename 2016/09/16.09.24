00:01:43 <dmj`> shachaf: I don't really care about the order of the IO occurring in this case
00:02:00 <shachaf> Well, it doesn't change the order.
00:07:45 <dmj`> shachaf: Ah, I see what you're saying, but there isn't a sane monoid/monad plus/alternative for IO (afaik)
00:07:53 <shachaf> ?
00:07:56 <dmj`> foldMap would be ideal
00:08:51 <dmj`> shachaf: foldMapWithKey, what you recommended above
00:08:55 <dmj`> :t foldMap
00:08:57 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
00:09:23 <dmj`> we'd need to fold into IO though, with the key
00:09:32 <shachaf> Yes.
00:09:36 <shachaf> See e.g. http://hackage.haskell.org/package/lens-4.14/docs/src/Control.Lens.Indexed.html#itraverse_
00:09:36 <dmj`> :(
00:10:47 <dmj`> shachaf: woa
00:11:04 <dmj`> (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()
00:11:20 <dmj`> shachaf: why bother with 'b' though
00:11:32 <shachaf> Why restrict it to ()?
00:12:09 <dmj`> it gets discarded to () anyways
00:12:24 <dmj`> suppose it's a convenience then
00:13:21 <shachaf> Why force people to void their thing?
00:15:47 <dmj`> yes, I agree, that would be annoying
00:17:17 <dmj`> @typ itraverse_ (\k v -> print (k,v)) (Data.Map.fromList [(1 :: Int, "foo" :: String)])
00:17:19 <lambdabot> IO ()
00:17:42 <dmj`> seems to be exactly what is needed
00:18:10 <dmj`> shachaf: is there a lens-light library with this function, so I don't have to pull lens onto the frontend
00:18:31 <shachaf> No. But you can probably copy the code, it's only a few lines.
00:18:41 <shachaf> There are a couple of different variations of it, as mentioned in the bug I linked to.
00:20:02 <dmj`> yes, but I'd have to copy Traversed and FoldableWithIndex as well
00:21:43 <dmj`> eh, I bet ghcjs can handle it, reflex-dom uses lens
00:22:56 <jle`> you could just copy the instance definitions
00:23:03 <jle`> for the only instance you care about :)
00:25:44 <dmj`> jle`: heh, I'll just wait until FoldableWithIndex makes it into base - Data.Foldable :). I'll see how much bigger adding lens makes things
00:26:24 <jle`> like, if you wanted to use "dimap" for functions and you didn't want to add a profunctors dependency
00:26:34 <jle`> you don't have to copy the Profunctor typeclass
00:26:46 <jle`> you can just copy dimapFunction f g h = g . h . f
00:29:22 <dmj`> jle`: you make a good point :) 
00:30:14 <jle`> or in this case itraverseForMaps_ = <paste definition>, no need for traverse/foldablewithindex
00:30:29 <dmj`> it seems imapM_ is the crux of what is needed, this requires the Sequence data type, and ifoldMap, but that requires the class Indexed and IndexedGetting constructor
00:30:44 <dmj`> along with FoldableWithIndex
00:31:46 <jle`> imapM_ :: Applicative f => (k -> a -> f b) -> Map k a -> f ()   -- ?
00:32:44 <dmj`> jle`: yea, that would work fine
00:33:30 <dmj`> jle`: it's late though, zzz's time
00:33:38 <jle`> night :)
00:33:50 <dmj`> g'night ;)
00:41:13 <dumbquestion> I've got a silly question. I'm currently using ghci and used the bytestring library to read a file under qualified import BL.readFile "~/Projects/awesome/happy.txt" . ghci will even autocomplete the path to the desired file...but then it will say the file does not exist. Why is that
00:45:45 <ongy> dumbquestion: have you tried expanding the "~" manually?
00:48:19 <dumbquestion> thanks...apparently that was it. Why would this make a difference when ghci is able to expand this with autocomplete?
00:55:42 <ongy> because ghci does something, while open does another thing. Not sure if its intended or you could call it a bug in ghci
00:56:04 <xSergx> :D
01:20:53 <bear_> #haskell-offtopic/join
01:21:07 <bear_> haskell-offtopic/join
01:23:23 <bear_> hello
02:31:54 * hackagebot http-pony 0.1.0.3 - A type unsafe http library  https://hackage.haskell.org/package/http-pony-0.1.0.3 (JinjingWang)
02:31:56 * hackagebot http-pony-serve-wai 0.1.0.4 - Serve a WAI application with http-pony  https://hackage.haskell.org/package/http-pony-serve-wai-0.1.0.4 (JinjingWang)
03:06:10 <dominik> Hi, is there a way to compose two WAI applications together?
03:06:37 <dominik> in the sense that whenever an incoming route can be answered by the first app, it is, and only then the second app is tried?
03:12:01 <dominik> well, I guess I can try to hand-craft my own based on the statuscode of the first app's response...
03:14:10 <ph88^> anyone know why replay has Int in that tuple ??   https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#t:Args
03:14:42 <zennist1> when should I use Control.Monad.Trans.Except vs Control.Monad.Catch?
03:15:34 <lyxia> ph88^: it's the size
03:15:36 <zennist1> (and there is also monad-control; but I'm reading somehwhere that I should prefer Control.Monad.Catch over that)
03:15:57 <ph88^> lyxia, size of what ?
03:17:17 <lyxia> ph88^: QuickCheck runs generators of type Gen a, which is just a newtype wrapper aroung QCGen -> Int -> a
03:18:02 <ph88^> so it's the amount of generators to run ?
03:18:20 <lyxia> no it's just a size parameter that can be used to control the size of generated values
03:18:32 <ph88^> where is this Int used even? I saw in this source code it's pattern matched on _ so not used  https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/src/Test-QuickCheck-Test.html#quickCheckWithResult
03:18:43 <lyxia> it's the value that's passed around by the sized/resize combinators.
03:19:22 <ph88^> lyxia, so it says something about the amount of data in a data structure ? (the data structure which is being generated) ?
03:19:25 <lyxia> The arbitrary instances for Int and lists use it.
03:19:43 <ph88^> ah ok
03:21:18 <ph88^> lyxia, since i wanted to give the seed in replay by the first element of the tuple QCGen .. should i use a default value for the second? i think that i'm obliged to provide a full tuple (unlike a record)
03:21:27 <ph88^> https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#t:Args
03:21:46 <ph88^> what should i set there for that Int ?
03:22:26 <lyxia> ph88^: to replay a test you must store both the QCGen and the Int
03:22:39 <lyxia> It's the usedSize field of Failure
03:23:35 <ph88^> aaaaahh
03:23:37 <ph88^> excellent
03:23:42 <ph88^> thank you very much lyxia 
03:26:07 <lyxia> ph88^: Note that in quickCheckWithResult, replay a appears twice, once for each component.
03:31:55 * hackagebot hw-prim 0.1.0.3 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.1.0.3 (haskellworks)
03:46:51 <aukeroorda> Hello guys. I am still quite new to Haskell, so please point me to any mistakes I might make. I am trying to use the map function to create some additional data about the current state of a small puzzle. I am now trying to reuse a function that works for rows, and pass a transposed column to it, but I am having difficulties with that. I created a s
03:46:51 <aukeroorda> mall paste for it: https://dpaste.de/kKKW#L12,21,31
03:47:52 <aukeroorda> The columnAsRow function seems to work properly. It doest atleast in the cases I tested manually
03:50:56 <aukeroorda> Right now it doesn't compile, because I of the strange structure I am trying at line #21
03:52:36 <aukeroorda> Hmm, I think I'll just write a function to transpose the complete puzzle as well, and apply that beforehand
04:18:07 <yhhko> i'd like to use IntMap, but I have keys exhausting the Word spectrum. so can I somehow assume that Int is indeed 32 bit (meaning that i can just save words >2^31 as negative ints)?
04:21:33 <dabd> what is the typeclasses you would use to implement something like https://www.tensorflow.org/? Applicative functors, arrows or something else?
04:21:39 <dabd> what are*
04:26:25 <mpickering> I'm not sure that question makes sense
04:31:56 * hackagebot scrape-changes 0.1.0.4 - Scrape websites for changes  https://hackage.haskell.org/package/scrape-changes-0.1.0.4 (2chilled)
04:36:04 <dabd> mpickering, what doesn't make sense?
04:36:39 <dabd> how was thinking how you would model the problem in terms of typeclasses, if it makes sense
04:37:02 <dabd> how would you model data flow graphs
04:37:16 <dabd> in a functional way
04:38:02 <geekosaur> do I even need typeclasses for that, or are parameterized types sufficient?
04:42:10 <mpickering> It seems that you are thinking of the implementation before specifying what problem you want to solve
04:44:04 <dabd> mpickering the problem is how to implement a data flow graph such as tensorflow in a functional way
04:44:26 <geekosaur> so why start with typeclasses?
04:44:42 <dabd> I have almost no Haskell experience but I thought in Haskell you model problems in terms of types
04:44:52 <geekosaur> we do. but they are not OO types
04:44:59 <dabd> I am not thinking OO
04:45:22 <geekosaur> then why start with them? they solve a particular problem which is not evident here
04:45:40 <dabd> I didn't mention OO
04:45:48 <dabd> typeclasses are OO?
04:45:50 <mauke> no
04:46:12 <mauke> but you're weirdly fixated on typeclasses, which often happens with people who come from OO and think "classes? I know this!"
04:46:29 <geekosaur> ^ exactly
04:46:44 <dabd> I was thinking typeclasses because it looks like Free Applicative Functors seem to be able to model the static nature of the data flow graph
04:47:05 <dabd> ok, so how would you model this problem?
04:47:08 <mpickering> The first part of your model should always be your *data*types. Define data which reflects your domain as precisely as possible. 
04:47:21 <mpickering> Free applicative functors are not to do with type classes though!
04:47:45 <mpickering> Well, I guess they are in some sense but they are just a datatype. 
04:48:20 <dabd> ok how would you model the nodes and edges of the graph.  It seems like a node is a function and the edges are inputs to the functions
04:49:04 <dabd> but the whole graph forms a dependency graph because the inputs to one function might come from outputs of other functions
04:49:28 <mpickering> I'm not sure of a nice way to represent graphs, someone else will know better
04:49:39 <mpickering> but you hit on the precise problem. that kind of construction is very fragile
04:50:12 <dabd> what construction is fragile?
04:51:09 <mpickering> the fact you have to build a cyclic structure using laziness 
04:51:27 <dabd> the graph is not cyclic it is a DAG
04:51:35 <dabd> data flow graphs are DAG
04:51:39 <mpickering> oh, that makes it much easier
04:52:23 <aukeroorda> Hmm, I am having a lot of trouble understanding why this patternmatch is incorrect: https://dpaste.de/vfRV#L4,5,8,9 You cannot have a 'set' value after the x?
04:52:24 <dabd> I think we can model how to represent the graph and how to evaluate it separately.
04:52:51 <dabd> I am thinking once you represent it you can for example do a topological sort to evaluate it in the proper order, given a set of inputs
04:53:21 <mpickering> that seems like a good idea. You should try implementing it and asking here if you get stuck
04:53:27 <mpickering> it's easier to help when there is code to talk about
04:54:07 <mpickering> aukeroorda: you can use the syntax '["1", x, "0"]' to do what tyou want
04:54:34 <aukeroorda> Oke, let me try that! Thanks
04:54:47 <mpickering> In the pattern 'x:xs' then x is bound to the first element of the list, and xs bound to the rest of the list
04:55:30 <mpickering> So in your pattern match, you have [String], to the right of the colon binds something which is of type [String] and "1" : String
04:56:40 <mpickering> also, If you are dealing with bit strings of length 3 then maybe you could represent your data as "data ThreeString Bool Bool Bool"
04:58:41 <aukeroorda> Hmm, the input will usually be "10.", and "1.1", with the dot
04:58:55 <aukeroorda> But thanks for your advice
05:02:36 <stevenxl> Hi folks. I remember browsing a while back to a web page defining abstractions. It was a Haskell wiki and it started off with introducing the concept of an axiom. Does that ring a bell to anyone?
05:02:41 <stevenxl> Thanks for any help.
05:16:42 <niklasb> is hackage sluggish for anybody else?
05:17:13 <srhb> niklasb: Looks fine.
05:17:50 <niklasb> every 10th page load or so takes forever :(
05:17:52 <niklasb> maybe it's my internet
05:18:14 <srhb> niklasb: I think so. :)
05:18:38 <srhb> If anything it seems faster than usual to me. :-P
05:31:15 <agocorona> niklasb: there are hackage packages that have not been compiled for a month
05:31:57 * hackagebot hs-duktape 0.1.3 - Haskell bindings for a very compact embedded ECMAScript (JavaScript) engine.  https://hackage.haskell.org/package/hs-duktape-0.1.3 (myfreeweb)
05:35:14 <joe9> need some advice, please? http://dpaste.com/1KZYTYZ is my program. I want to continue the thread within the context while the main thread returns from the function.
05:35:39 <joe9> actual code: http://bpaste.net/show/58b1cabd64a5
05:36:02 <joe9> The GLFW createWindow can only be created in the main thread. The window handle can be used in any other thread.
05:36:31 <joe9> So, I want to create the window and let the other stuff happen in a different thread.
05:37:17 <joe9> I meant create the window in the main thread and use the different thread for the other stuff.
05:47:35 <martinr_> hey
05:51:53 <martinr_>  ^.,frdeswqA
05:51:55 <martinr_>  ^.,frdeswqA
05:56:12 <zomg> martinr_: fascinating
05:56:25 <buglebudabey> is there a simple way to parse a double in parsec
05:58:06 <Squarism> anyone got a good idea on how to tackle this http://lpaste.net/210359
05:58:13 <Squarism> ie write a "update"
05:58:34 <Squarism> it doesnt need to be fast 
05:59:01 <erisco> buglebudabey, there is probably a parser in the lib for you already
05:59:20 <martinr_> zomg: sorry. i was cleaning my keyboard 
05:59:43 <martinr_> didnt realise weechat was open
06:03:39 <erisco> Squarism, you had this question yesterday. What did you try since then?
06:04:31 <Squarism> erisco, i tried composing lenses "recursively" by means of insepcting path elements
06:04:48 <Squarism> ...but that would lead to some variable type expression - feels hard
06:11:40 <niklasb> are there any current type-level bugs that allow to implement unsafeCoerce in pure GHC Haskell? I know GeneralizedNewtypeDeriving was unsound in that way for quite some time
06:13:28 <erisco> Squarism, you should narrow your question. It is a lot of effort on our part to reconstruct what you're trying to accomplish and then tell you how to do it
06:18:58 <Squarism> erisco, ok.. ill try that
06:24:55 <mpickering> It seems like you have a simpler problem you are trying to solve and have already engineered something to try and solve it
06:25:12 <mpickering> as a result, it's not clear what the original problem is. It would help to explain with some comments
06:27:04 <Squarism> ok.. ill do that. 
06:31:51 <cheater> hello
06:32:35 <srhb> cheater: Hello.
06:32:44 <cheater> i read this paper abstract on HoTT, and it said: "all types support a generic program that transports elements along these equalities". what does "transport" mean in this case? it's in the abstract, here: http://dl.acm.org/citation.cfm?id=2976748
06:33:47 <Narfinger> hiho, I have a "newtype Intervall = Interval Int64", can I somehow convert one time from Int64 to Interval without any overhead?
06:35:54 <srhb> Narfinger: That's what newtype does. :)
06:35:55 <joe9> HoTT is cool. I wish it becomes more mainstream.
06:36:22 <joe9> the book helped me (a newbie without math or compsci background) understand it.
06:37:00 <srhb> Narfinger: When you use newtype like that, there's a distinction between Interval and Int64 at compile time, but not at runtime.
06:37:24 <cheater> joe9: HoTT is not cool... it's hott... says right in the name, duh
06:37:33 <felko> I'm trying to write a class that can convert monads but I'm facing a weird error I can't decrypt, anyone help me ? Here's the paste:
06:37:33 <cheater> :)
06:37:36 <lpaste> felko pasted “No title” at http://lpaste.net/211448
06:37:39 <Narfinger> yeah but my question is how to convert it because otherwise the types will not match
06:37:50 <srhb> Narfinger: Interval :: Int64 -> Interval
06:38:24 <Narfinger> ah thanks 
06:38:33 <Narfinger> could have thought of that by myself -.-
06:38:44 <cheater> Narfinger: it's confusing in the beginning, don't worry
06:39:01 <srhb> Narfinger: :) Using the same name for the type and value constructor like that can be a bit confusing at first, yeah.
06:40:20 <jchia_> monad transformer stack question: When would one prefer to use a StateT of ReaderT of something (e.g. IO) instead of just a RWST of something (e.g. IO)? It seems that the RWST can do what a StateT of ReaderT can do.
06:41:15 <srhb> jchia_: If you don't use the Writer, why have it?
06:41:43 <cheater> jchia_: if you need to compose.
06:41:43 <jchia_> RWST has one less layer of monad transformer and seems simpler
06:42:24 <jchia_> cheater: compose what?
06:42:48 * parsnip gets tired of typing `wordlist <- loadWords' in repl after reloading file.
06:43:10 <parsnip> (reloading via C-c C-l)
06:46:30 <cheater> jchia_: ok why would you use Maybe (a, b) and not MaybePair a b?
06:46:58 <cheater> jchia_: if you have an (a, b) then you can compose it (put it in a Just) and then you have Maybe (a, b).
06:47:56 <jchia_> cheater: Do you mean composing the StateT part with the ReaderT part so that I can combine the StateT part with something other than a ReaderT?
07:02:26 <felko> I'm trying to write a class that can convert monads but I'm facing a weird error I can't decrypt, anyone help me ? Here's the paste:
07:02:33 <lpaste> felko revised “No title”: “No title” at http://lpaste.net/211448
07:05:54 * geekosaur notes that the bottom two instances overlap each other and every other instance
07:06:15 <geekosaur> (contexts are not used to select an instance)
07:06:32 <Cale> Yep, that's why it's spinning forever
07:07:09 <Cale> Note that any time you have to turn on IncoherentInstances, something is probably completely broken
07:07:51 <Cale> Overlapping and Undecidable instances are also kind of questionable, you really want to avoid those
07:08:21 <felko> How can I ?
07:08:34 <Cale> Don't write those two instances there
07:08:54 <bonhoeffer> what are some good reasons to learn haskell? will i better understand math?
07:09:01 <felko> then where Cale ?
07:09:15 <geekosaur> you can't write them at all, typeclasses don't work that way
07:09:28 <geekosaur> bonhoeffer, probably not. it *will* make you a better programmer
07:09:28 <Cale> bonhoeffer: Maaaaybe you could use it as a way to get into certain areas, but for the most part, you learn Haskell to have a better time at writing programs.
07:09:36 <bonhoeffer> for example, i was going to start going back through project euler problems
07:09:54 <Cale> felko: Nowhere.
07:10:02 <bonhoeffer> what kind of programs -- for example, i'm doing more machinelearning and text processing these days
07:10:06 <felko> Cale: ok :(
07:10:13 <bonhoeffer> also some static code analysis
07:10:23 <bonhoeffer> a lot of my dev's use oCaml
07:10:35 <bonhoeffer> so i wanted to try a functional language
07:11:48 <geekosaur> haskell forces you to think about how you design your types / represent your data in the program, and how you manage that data. other languages often let you ignore this --- but if you apply the same things in those languages, you will write better programs in those languages
07:11:56 <pavonia> Can the type checker even find any intermediate type such as that "n" on the last instance definition?
07:11:58 <Cale> felko: Note that when the resolver is trying to figure out which instance to apply, it can never rely on the absence of a particular instance, because if it did, new instances in future modules which have yet to be compiled (or written!) might affect the decisions it makes.
07:12:04 <Cale> oh, he left
07:12:39 <geekosaur> (fewer error, fewer runtime failures, often faster and more modular / reusable)
07:14:13 <liste> bonhoeffer: Haskell works well enough for those, though the numerics and NLP libraries are not as advanced as in Python
07:14:27 <liste> bonhoeffer: but code analysis and compilers are the killer app
07:16:03 <Cale> bonhoeffer: A really nice thing about using Haskell, perhaps even the main one, is the fact that in large projects, you have much less to fear from big refactorings. You can often make some change, and the type checker will help you find all the things which need changing as a consequence, and by the time you've worked through all the things it complains about, your program will, with an almost unreasonable frequency, 
07:16:03 <Cale> still work.
07:16:46 <martinr_> nice dramatic pause
07:17:00 <Cale> heh, that line was automatically broken by my IRC client
07:19:36 <Cale> bonhoeffer: For example, at the company I work for, we use Haskell to write web applications, both for the backend (server), compiled to native code, and for the frontend (client), compiled to Javascript that runs in your browser. Often a new feature will start out with some changes to types which are shared between both the frontend and backend and which facilitate communication between them.
07:20:07 <Cale> From there, the compiler will begin to complain about all the things in both the frontend and backend which need updating to deal with the new structure.
07:20:39 <bonhoeffer> liste: thanks -- yeah my formal methods guys love it
07:21:48 <bonhoeffer> Cale: interesting -- that sounds cool
07:29:40 <bonhoeffer> Cale: how did you learn -- are they teaching haskell in school or does everyone pretty much pick it up after learning imperative prog languages?
07:29:56 <Squarism> Ok.. now i have a perfectly compiling one file with 3 examples. Im looking for ideas on writing the function "update". http://lpaste.net/211508
07:29:59 <Cale> I started learning Haskell from various sources on the web back around 2001-2002
07:31:05 <Cale> They do teach some Haskell (or require students to learn it) at some universities.
07:32:02 <bonhoeffer> my undergrad taught lisp for basic cs -- they've gone to python -- lisp is functional, right?
07:32:05 <Cale> bonhoeffer: It's sufficiently different from imperative programming that it's not the easiest transition to make.
07:32:13 <bonhoeffer> Cale: i'm finding that 
07:32:33 <parsnip> bonhoeffer: i think scheme is more functional than common lisp. 
07:32:36 <Cale> (at least in this direction -- the people who I've started off with Haskell seem to have not much difficulty picking up imperative languages after)
07:32:50 <bonhoeffer> parsnip: i thought scheme was a dialect of lisp
07:33:00 <parsnip> bonhoeffer: at least, scheme has immutability, iiuc. 
07:33:27 <parsnip> bonhoeffer: scheme is a lisp, but when people say lisp, they often mean common lisp, hence some people even say, "scheme vs. lisp". 
07:33:51 <bonhoeffer> yeah -- i'm pretty sure the cs friends were using emacs lisp or simliar
07:33:53 <Cale> bonhoeffer: Various flavours of Lisp make functional programming possible to varying degrees
07:34:10 <bonhoeffer> but haskell is functional from the ground up
07:34:13 <Cale> yeah
07:34:20 <parsnip> bonhoeffer: i think emacs lisp is closer to common lisp than scheme, though it's so old, it doesn't quite fit such a definition. 
07:34:25 <bonhoeffer> got it -- are there various compilers
07:34:37 <Cale> Sort of... but mainly you're going to want GHC
07:34:53 <bonhoeffer> ok -- time to go and learn me a haskell
07:35:04 <bonhoeffer> and hopefully solve some math problems soon
07:35:13 <parsnip> bonhoeffer: it's my "first" language! 
07:35:22 <parsnip> bonhoeffer: math problems with haskell? 
07:35:29 <bonhoeffer> parsnip: lucky you
07:35:51 <bonhoeffer> parsnip: bad idea? i was going to go through proj euler 
07:36:30 <parsnip> bonhoeffer: people here were just bad-mouthing something about project-euler+haskell. 
07:36:37 <bonhoeffer> why?
07:36:49 <Cale> bonhoeffer: Not a terrible idea, lots of people like doing that...
07:37:04 <parsnip> right, _i_ like doing that, just watch out for opinions here. 
07:37:15 <bonhoeffer> well, i'm about to invest time -- why any reservations?
07:37:19 <Cale> I think the main criticism is that you can't really expect PE problems to really teach you very much *Haskell* past a certain point.
07:37:26 <bonhoeffer> sure 
07:37:36 <parsnip> bonhoeffer: i got through 70 problems with haskell :)
07:37:44 <bonhoeffer> i'm more interested in the math anyway -- i would just love to solve their basic problems differently
07:37:56 <Cale> You only need a fairly limited fragment of the language to do them, but it's a decent source of exercises to get started.
07:37:57 <bonhoeffer> yeah, prob 70 will still be Julia or Matlab for me
07:38:10 <bonhoeffer> Cale: then probably some codewars
07:38:17 <parsnip> bonhoeffer: but then i slowed down, because working with algorithms can be a little tricky in haskell, because the standard approach to algorithms are in imperative style. 
07:38:54 <parsnip> bonhoeffer: though some of that was, the level of abstraction to understand how haskell's Vector package effects algorithms. 
07:39:28 <parsnip> bonhoeffer: but that's great, now i'm curious about algorithms, and it's motivating more learning, albeit stepping away from haskell at the moment. 
07:39:30 <Cale> It's possible to translate any imperative algorithm to Haskell of course, but when you're starting out, it can be a bit tricky to figure out how to do things while avoiding mutable variables.
07:39:47 <bonhoeffer> ha -- tell me about it!
07:39:56 <parsnip> bonhoeffer: but the haskell language is a real pleasure to work with for at least the earlier project euler problems. 
07:40:03 <bonhoeffer> ok -- off to a day of kids soccer -- will look at tonight
07:40:16 <bonhoeffer> thanks for the thoughts
07:40:23 <Cale> If you ever get really stuck, there's a mechanical method that will basically always work
07:40:36 <Cale> ah, okay :)
07:40:50 <Cale> parsnip: If you're interested in it...
07:40:58 <martinr_> Cale: go ahead. im interested
07:41:19 <Cale> Basically the trick is to take each place in the imperative program where the program counter could be, and turn that into a function.
07:41:50 <Cale> The parameters to that function will be the current values of the mutable variables in scope in the imperative program
07:42:00 <parsnip> i'm basically taking a large detour, i think i need a foundation in basic algorithms. i'm even taking a look at a math course geared towards cs. 
07:42:27 <Cale> and you'll have this function decide where to go next (which function to apply), and how to update things (which arguments to provide), based on what the imperative program would do there
07:42:38 <Cale> Loops will result in mutual recursion
07:42:51 <Cale> This will initially give you a bit of a mess
07:42:58 <Cale> But it's a mess of *equations*
07:43:18 <parsnip> i guess you still have to watch out for thunks. i think you may be benefitting from experience with algorithms and/or large noodle. 
07:43:25 <Cale> and so once you've gone through and done it systematically, you can immediately start to simplify the equations by substituting equals for equals
07:44:16 <Cale> Of course, to get a really *nice* functional program will require understanding further what's taking place.
07:45:19 <martinr_> huh ok - thanks. thats actually useful for what im doing right now Cale 
07:45:20 <Cale> But as you get better at this, you can skip more and more steps, like, if you understand the complete effect of a loop body perfectly well, there's no point in introducing all the intermediate functions for each line -- you can do it all at once.
07:45:49 <parsnip> right, i need to go through a course and do some loop counting problems on paper, etc. 
08:03:38 <joe9>  I am trying to figure out how to use glXCreateContext (creates an OpenGL context, in C GLX library) from haskell. Any library recommendations, please? google turned up XHB. Not sure if that is recommended
08:06:02 <geekosaur> I think we normally recommend using OpenGL directly, not the X11 interface
08:07:40 <joe9> geekosaur: I think OpenGL works with a provided context. I do not think it can create the context itself.
08:07:58 <joe9> geekosaur: I could not find a createContext function in it's index too.
08:08:48 <int-e> SDL or a toolkit library (gtk, probably wx) will do the trick. I don't know what we "normally recommend".
08:11:05 <geekosaur> you'd normally use GLUT for direct OpenGL access. SDL provides a wrapper; gtk provides its own interface which probably goes through X11
08:13:03 <geekosaur> and the rendering context you are talking about is specifically an X11 thing not an OpenGL thing. this may mean you are only aware of OpenGL as an X11 interface. you are probably better off using gtk or sdl in that case as int-e said
08:14:56 <maerwald> people still use glut? uhm
08:18:15 <hpc> GLUT and SDL provide the same thing
08:18:28 <hpc> they set up the window and initialize an opengl context
08:18:41 <hpc> glfw does the same
08:19:00 <hpc> glfw and sdl also provide sound, good gamepad support, and some other things
08:19:07 <hpc> er, glfw doesn't do sound
08:19:28 <hpc> then there's gloss which sets up a window, initializes an opengl context, and then doesn't give it to you
08:19:50 <hpc> it's more frameworky and everything you do has to be within the gloss api
08:20:23 <hpc> people do still use glut, but only by way of tutorials for opengl never update EVER
08:20:48 <hpc> glfw or sdl are significantly better options in every way
08:32:10 <parsnip> is this horrible: 
08:32:28 <parsnip> dropWhile (not . isAlpha) . dropWhile isAlpha
08:33:26 <parsnip> shoot, i need the index
08:34:59 <dmj__> Do free free monads exist.
08:36:17 <parsnip> is this like free free groups? 
08:37:31 <dmj__> parsnip: I'm unsure
08:39:36 <dmj__> I have a free monad in my library but need to continually extend it to support different end user cases, I'd like for a way to allow users to extend it themselves, hence free free
08:40:42 <parsnip> these references seem to bring free monad closer to the math definition i've seen: https://wiki.haskell.org/Free_structure https://softwaremill.com/free-monads/
08:41:27 <parsnip> like, a free group on a set X = {x0, x1, ...} is like all linear combinations of xi, sort of, iirc. 
08:41:37 <parsnip> so in that case, seems okay to do it again. 
08:42:19 <parsnip> like there's a functor from Group to Set that is obvious, then a functor back, for example is the free group. 
08:42:49 <parsnip> i think those two functors even have magical properities, like "adjoint" or something, which i never really grasped any intuition for. 
08:43:36 <parsnip> here's what looks like a general definition of "free": https://en.wikipedia.org/wiki/Free_object
08:43:45 <jmcarthur> dmj__: Just give them a free monad transformer instead of a free monad?
08:49:12 <dmj__> jmcarthur: yes, maybe we could expose a typeclass where MonadFree is a super class, and let them make an instance. Then call runFree on their data type when specified as input.
08:49:59 <dmj__> Making them specify their own interpretation might be too hairy though
08:50:19 <jmcarthur> That's not quite what I meant.
08:50:38 <jmcarthur> I just mean if you have some core set of operations you could just expose them via FreeT instead of Free.
08:50:49 <jmcarthur> And the user can "extend" by just applying to whatever monad they want.
08:51:27 <jmcarthur> But maybe I didn't understand what you are trying to do.
08:52:23 <jmcarthur> I always think it's weird when people use Free in their interfaces. It's fine as an implementation, but it seems a pretty lazy way to design an interface.
09:23:17 <buglebudabey> if i have a [M b] and i want to return a [b], what can i do?
09:24:40 <srhb> @hoogle Monad m => [m b] -> m [b]
09:24:43 <lambdabot> Control.Monad.Run mswitch :: (Monad m, MonadUnTrans MaybeAlg t) => [t m b] -> m b -> m b
09:24:43 <lambdabot> Control.Monad.Run mswitch0 :: (Monad m, MonadUnTrans MaybeAlg t) => [t m b] -> m b -> m b
09:24:43 <lambdabot> Control.Monad.Run mswitch1 :: (Monad m, MonadUnTrans MaybeAlg t) => [t m b] -> m b -> m b
09:24:47 <srhb> Blergh.
09:25:03 <srhb> :t sequence
09:25:05 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
09:25:10 <srhb> buglebudabey: ^
09:25:53 <buglebudabey> srhb and to extract that (t a) from the m should I just pattern match it in a case expression?
09:26:15 <srhb> buglebudabey: There is no general way to go from `m a` to `a`
09:26:57 <srhb> buglebudabey: So it depends on your specific `m`
09:27:03 <lyxia> const undefined :: m a -> a -- :P
09:28:01 <exio4> or simply undefined :p
09:32:04 * hackagebot checkers 0.4.6 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.4.6 (ConalElliott)
09:32:06 * hackagebot fltkhs 0.4.1.0 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.1.0 (deech)
09:32:08 * hackagebot hascar 0.2.1.0 - Decompress SAPCAR archives  https://hackage.haskell.org/package/hascar-0.2.1.0 (hc)
09:32:20 <geekosaur> buglebudabey, is that [M b] supposed to be a monad, or a data constructor?
09:32:34 <buglebudabey> geekosaur a monad
09:32:46 <buglebudabey> geekosaur Parser to be specific
09:32:51 <geekosaur> then you cannot do it for arbitrary m
09:33:14 <geekosaur> parsers generally have run functions, you could fmap that over the list
09:34:20 <buglebudabey> do you know if theres one in parsec specifically geekosaur 
09:36:07 <geekosaur> wouldn't that be parse?
09:38:24 <cheater> hi
09:38:59 <buglebudabey> geekosaur parse returns a Parser a
09:39:41 <geekosaur> it does? http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec.html#v:parse seems to think it's an Either
09:39:42 <buglebudabey> so if i mapped parse over a [String] and got [Parser Expr] then i'd like to get a [Expr] geekosaur 
09:40:21 <geekosaur> and it would be kinda silly if asking parsec to run a parser produced a parser instead of the result of that parser
09:40:29 <buglebudabey> yeah, my bad
09:40:59 <geekosaur> you still need to deal with the Either,  but you would anyway (or are you certain none of the parses can ever fail?)
09:41:57 <buglebudabey> i am dealing it yeah
09:42:23 <buglebudabey> i'm gonna play around with it now that i realize the mistake, thanks
09:54:33 <Squarism> As i ive been going on about to solve my little puzzler for 2 days, i present a working solution. Maybe not optimized, but atleast produce what i need
09:54:34 <Squarism> http://lpaste.net/211782
09:55:10 <prsteele> Squarism: do you have a problem statement for the puzzle?
09:55:31 <Squarism> prsteele, oh.. it WAS to complete the function "update"
09:55:39 <Squarism> i found a solution
09:55:45 <Squarism> as can be seen =D
09:55:49 <Squarism> <- proud
09:55:56 <prsteele> Squarism: I meant more of an English-language type statement haha
09:56:12 <buglebudabey> i have a parser that = parseDouble <|> parseInt that fails every time i try to parse an int. is this because it's failing on parseDouble? in that case would doing adding try fix it?
09:56:41 <Squarism> prsteele, i think the "test-cases" illustrate it. Below the "update" implemenation
09:57:33 <Squarism> basically how to update an alternating map of 2 types at arbitrary depth
09:57:42 <buglebudabey> nevermind, answered my own question
09:57:43 <prsteele> ah cool
09:58:08 <geekosaur> buglebudabey, without seeing the parsers that cannot be answered with certainty. but probably yes since without try it will attempt parseInt at whatever character failed parseDouble
09:58:27 <buglebudabey> yup, thank you geekosaur 
09:59:40 <prsteele> uh, architecture question. If I want to build up an output document (plain text) what is the best approach from a high level? Writer monad? Or is there something better-suited?
10:00:41 <prsteele> known possible alternatives to me would be something like pipes
10:00:55 <geekosaur> a prettyprinter library, maybe
10:04:28 <LordBrain> i'd put parseInt before parseDouble... unless you have some reason not to
10:04:57 <prsteele> (not certain here but) wouldn't that cause 123.345 to parse as an Int, with .345 left over?
10:05:26 <LordBrain> well i guess it depends on how those parsers are written
10:07:30 <LordBrain> in most cases you're right, so i guess i didnt think before i spoke
10:18:50 <erisco> with several parsers, <|> is not commutative, and particularly they take the first match
10:19:34 <erisco> in parsec this match is just on the first character
10:20:53 <erisco> so if you are using parsec, or another lookahead-1 parser buglebudabey, it is expected that if the first character is a digit that it will only try to match a double
10:21:23 <erisco> in such a parser, parseDouble <|> parseInt is the same as parseDouble
10:22:07 <erisco> you can change this behaviour in parsec by using try, so   try parseDouble <|> parseInt
10:22:57 <erisco> try changes the parser from lookahead-1 to lookahead-* i.e. infinite lookahead
10:24:11 <erisco> another option is  parseInt <*> optional (char '.' *> some digit)  but requires you to construct the double yourself
10:32:52 <horatiohb> Any idea why MVector wasn't made an instance of Eq?
10:32:53 <Valoo> Hi
10:33:08 <prsteele> hello Valoo 
10:33:39 <Valoo> I can't get scott-hastache to install: http://lpaste.net/4813472047374008320
10:33:47 <Valoo> *scotty-hastache
10:34:41 <cloudhead> anyone using profunctor lenses?
10:35:17 <Valoo> Is it just me, or does anybody else can't install it either?
10:37:58 <jmcarthur> horatiohb: It's not an instance of Eq because it'
10:38:00 <jmcarthur> s mutable
10:38:38 <jmcarthur> horatiohb: Unless you mean they should be equal if they are the same array by identity.
10:38:53 <jmcarthur> horatiohb: In which case I might agree that it's a little sad that it's missing.
10:41:14 <prsteele> is there an easy way to get QuickCheck to generate tests at the type level? Or do I need to reach for TH?
10:41:57 <slack1256> I've done something machivelian.
10:42:53 <slack1256> With zsh edit-command-line I launch a nix-shell that imports the Turtle library from cache, then I write haskell scripts and run them. The good thing is that they appear on zsh history...
10:43:11 <slack1256> it is convoluted but it works as a semi good shell scripting environment
10:43:29 <lispy> slack1256: semi-good or semi-group?
10:43:41 <slack1256> good
10:45:24 <EvanR> semigoodoid
10:47:40 <mogunus> Hi, I’m trying to get started with hakell in emacs. I’ve installed haskell-mode and this works OK. I want more magic/electric features for inspecting types and catching errors in buffers though, so my plan is to install ghc-mod and hlint and the emacs frontend for those things. Does this sound right for getting started?
10:47:50 <mogunus> I just installed haskell-platform from homebrew cask.
10:48:28 <prsteele> mogunus: I use https://github.com/prsteele/emacs-config/blob/master/lisp/prsteele-haskell.el
10:48:44 <prsteele> mogunus: and am reasonably happy with what I've got
10:49:47 <mogunus> prsteele: thank you, that looks helpful.
10:49:49 <prsteele> mogunus: uh, line 25 should be removed, haskell-mode-contextual-space has been removed in the newer releases
10:50:06 <mogunus> good to know :-)
10:51:09 <prsteele> mogunus: notably C-c C-l compiles and loads a REPL, and if there are errors they are highlighted in the source files
10:52:31 <mogunus> prsteele: that’s exactly what I’m looking for. And the output of haskell-process-do-type looks really good too. Thanks.
10:52:52 <tsahyt> Hello! I was wondering, why do the laws for ArrowChoice and Arrow not require distributivity between the product and coproduct operations?
10:53:13 <tsahyt> as far as I can tell this would ensure that we are working in a distributive category
10:53:18 <prsteele> mogunus: you're welcome!
10:53:25 <tsahyt> and indeed it does hold for the (->) instance I think
10:53:44 <tsahyt> I haven't verified it for Kleisli arrows
11:05:21 <tsahyt> nvm, I think I'm wrong
11:56:00 <absence> is it possible to have ghci just spit out a few lines of type errors on :r, so i don't have to scroll up all the time?
11:58:36 <glguy_> Sure, just write fewer type errors!
11:59:25 <glguy_> -freverse-errors and -fno-helpful-errors might be relevant, too
12:02:11 <absence> glguy_: yes yes :) 
12:05:57 <absence> glguy_: ah, the reverse errors one is exactly what i need! thanks
12:06:09 <JohnnyL> 3~/quit
12:26:04 <xocolatl> hi all.  I'm having trouble figuring out how to execute an arbitrary query with postgresql-simple. I'd like to build a simple repl type app.  any pointers?
14:16:24 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
14:16:24 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
14:16:57 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
14:16:57 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
14:34:15 * hackagebot Cartesian 0.5.0.0 - Coordinate systems  https://hackage.haskell.org/package/Cartesian-0.5.0.0 (SwiftsNamesake)
15:15:04 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
15:15:04 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
15:20:12 <Ainieco> hello
15:20:42 <glguy> intothem1untains: If you do end up getting interested in that and have more questions there's also #haskell-irc
15:29:03 <intothem1untains> glguy: I'll have a go through tonight or tomorrow
15:29:10 <intothem1untains> Seems interesting :)
15:30:51 <solucien> i'm trying to do the typeclassopedia exercises in order to get Functors
15:31:00 <solucien> i'm at this one : Implement Functor instances for ((,) e) and for Pair, defined as
15:31:00 <solucien> data Pair a = Pair a a
15:31:44 <solucien> i've done this :
15:31:46 <solucien> instance Functor (Pair a) where
15:31:46 <solucien>   fmap f Pair a = f a
15:31:53 <solucien> but it seems wrong
15:32:20 <glguy> That defines `fmap' to match on 3 parameters: f, Pair, and a
15:32:23 <solucien> so 1) is it wrong ? if so, why /how can i improve it
15:32:37 <solucien> i want to run f on both of the values
15:32:42 <solucien> in the Pair's tuple
15:32:51 <solucien> i believe that is the idea in a functor, isn;t it
15:33:25 <glguy> solucien: To get a little less confused, let's redefine the Pair type as follows:
15:33:35 <glguy> data Pair a = MkPair a a
15:33:39 <verement> also it should be instance Functor Pair, not Functor (Pair a)
15:34:07 <solucien> i looked at the definition of Either to get inspiration
15:34:16 * hackagebot irc-conduit 0.2.1.0 - Streaming IRC message library using conduits.  https://hackage.haskell.org/package/irc-conduit-0.2.1.0 (barrucadu)
15:34:18 * hackagebot pagination 0.1.1 - Framework-agnostic pagination boilerplate  https://hackage.haskell.org/package/pagination-0.1.1 (mrkkrp)
15:34:20 * hackagebot wai-middleware-content-type 0.5.0 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.5.0 (athanclark)
15:34:22 * hackagebot irc-client 0.4.4.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.4.4.0 (barrucadu)
15:36:21 <solucien>  instance Functor (Pair a) where
15:36:22 <solucien>   fmap f MkPair (a a) = ((f a) (f a))
15:36:24 <solucien> does not parse
15:36:43 <solucien> so here a is the type of the value
15:36:47 <glguy> Now you've defined fmap to have 3 parameters with the 3rd being an invalid pattern
15:36:51 <glguy> fmap should have 2 parameters
15:37:35 <solucien> okay so i try to pattern match it to (MkPair (a a)) instead ?
15:37:48 <glguy> closer, but the (a a) part is wrong
15:38:03 <glguy> (MkPair a a)
15:38:21 <solucien> yes i did this
15:38:56 <glguy> ((f a) (f a)) this attempts to apply the function (f a) to the argument (f a)
15:39:09 <glguy> but you need to construct a new Pair
15:39:09 <solucien> so pattern match the constructor to (MKPair a a)
15:39:34 <solucien>   fmap f (MkPair a a) = MkPair (f a) (f a)
15:40:50 <Ainieco> hello, i'd like to create simple message queue using Map, e.g keys for map are message types and values are payloads
15:41:13 <Ainieco> the problem is that for every message type i'd like to have different type for payload
15:43:17 <Ainieco> i could do it using sum type for payload but that would require me to perform a check if sum type variant is the correct one for the message type
15:43:28 <Ainieco> which is not completely typesafe on compile time
15:44:25 <glguy> Ainieco: instead of a Map for a queue, you could use a queue containing a sumtype where each constructor in the sum type corresponds to a message type and its payload
15:45:20 <glguy> Or a record with a list for each type of payload rather than a Map, or if the Map aspect is important for some reason you can look at https://hackage.haskell.org/package/dependent-map-0.2.3.0/docs/Data-Dependent-Map.html
15:48:10 <Ainieco> glguy: thanks!
15:50:40 <Ainieco> glguy: reason i'm using map is that i'd like to have a "channels" in queue to easily locate events of certain type and process them in order
15:51:38 <Ainieco> so the keys of my map are message types and channels at the same type
15:54:22 <glguy> Ainieco: a record of queues would work similarly and require less complexity
15:54:55 <Ainieco> glguy: yup, that's waht i thought as well
16:01:23 <intothem1untains> glguy: it's bigger than i thought
16:08:55 <solucien> glguy   fmap f (MkPair p p) = MkPair (f p) (f p)
16:09:01 <solucien> still cannot parse this
16:09:15 <solucien> conflicting definitions for p
16:09:32 <glguy> solucien: It wouldn't be good to name the first and second component of the pair the same value, woudl it?
16:09:48 <glguy> How would you tell them apart?
16:10:18 <solucien> i agree
16:10:24 <solucien> but a is the type
16:10:32 <solucien> they are supposed to be the same type
16:10:39 <shachaf> In Miranda f x x = ... meant something like f x y | x == y = ...
16:10:50 <solucien> instance Functor (Pair p) where
16:11:23 <glguy> solucien: You don't names things the same name because they have the same type
16:11:34 <solucien> i understand
16:11:49 <glguy> With (MkPair p p) you're naming the components of MkPair
16:11:54 <glguy> so they need unique names
16:12:25 <glguy> This isn't the same as when you were declaring data Pair a = MkPair a a, which is defining the type of MkPair
16:13:21 <solucien> how can i fix this ? 
16:13:23 <solucien> i tried 
16:13:32 <solucien> instance Functor (Pair p) where
16:13:32 <solucien>   fmap f (MkPair (p a) (p b)) = MkPair (f (p a)) (f (p b))
16:14:14 <glguy> Could you explain what you think this part does: (MkPair (p a) (p b))
16:14:57 <solucien> coerses a to type p
16:15:02 <solucien> coerces
16:15:15 <solucien> or checks the type of a to be p
16:16:58 <glguy> OK, it doesn't do that.
16:17:09 <solucien> okay so this is the closest i've done 
16:17:11 <glguy> But if you write: (MkPair x y) it names the first component x and the second component y
16:17:20 <solucien> instance Functor (Pair t) where
16:17:20 <glguy> Types don't feature here
16:17:20 <solucien>   fmap f (MkPair a  b) = MkPair (f a) (f b)
16:17:37 <solucien> however, i still can't parse this
16:17:47 <solucien> because of the kind
16:18:04 <glguy> The kind of `Pair t` is *
16:18:08 <glguy> but you need something of kind * -> * there
16:18:10 <solucien> yes
16:18:13 <glguy> The kind of `Pair` is * -> *
16:19:10 <solucien> how can i fix this ?
16:19:15 <mauke> ...
16:19:34 <mauke> lisa needs braces
16:20:27 <solucien> or even more : is this fixable ?
16:20:52 <zyhn> solucien: instance Functor [put something with kind * -> * here] where
16:20:56 <mauke> <glguy> you need something of kind * -> * there  <glguy> The kind of `Pair` is * -> *
16:21:34 <glguy> Whoa, gotta use <spoiler> tags!
16:21:51 <solucien> okay so instead of pair
16:21:56 <solucien> i should put a function ?
16:22:02 <mauke> waaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaat
16:23:09 <mauke> <verement> also it should be instance Functor Pair, not Functor (Pair a)
16:23:19 <solucien> glguy i don't understand kinds yet ..
16:23:31 <mauke> you don't have to understand kinds
16:23:46 <solucien> would you be kind enough to point me in the right direction ? what am i supposed to do there ?
16:24:02 <solucien> i want a functor that applies to type Point
16:24:12 <solucien> sorry
16:24:13 <solucien> Pair
16:24:17 <mauke> <verement> also it should be instance Functor Pair, not Functor (Pair a)
16:24:18 <mauke> <verement> also it should be instance Functor Pair, not Functor (Pair a)
16:24:23 <solucien> which applies f to both of the members in the pair
16:24:43 <solucien> yes
16:24:46 <solucien> that fixes it
16:25:54 <solucien> okay so it's because i am already defining
16:26:08 <solucien> data Pair a = MkPair a a
16:26:45 <solucien> if i would say Pair = Foo a | Bar b c then i would need to write it
16:26:50 <solucien> in the functor
16:26:52 <solucien> am i correct ?
16:27:42 <solucien> that is why the functor for Either is
16:27:42 <mauke> that's several errors
16:27:48 <solucien> instance Functor (Either x) where
16:28:05 <mauke> the thing after 'Functor' needs to take one type parameter
16:28:17 <solucien> i see
16:28:23 <mauke> your Pair takes one, so 'instance Functor Pair' is correct
16:28:41 <mauke> 'Either' takes two, so we need to pre-fill one of them
16:29:14 <solucien> i understand 
16:29:21 <mauke> technically Either doesn't have a Functor instance
16:29:36 <mauke> instead we're saying "for all types x, 'Either x' is a functor"
16:30:07 <solucien> i see , i understood that, and i was trying to replicate it for the Pair type
16:30:30 <solucien> for all types x which can be contained in a pair
16:30:32 <solucien> define fmap
16:30:40 <solucien> but i see now
16:30:48 <solucien> that the type is inferred because it is a single one
16:33:27 <srhb> solucien: I don't think you've got it. The difference isn't that it's somehow "inferred"
16:34:01 <srhb> solucien: It's that Pair t does not take a type argument at all, therefore it cannot be an instance of Functor (kind mismatch)
16:34:17 * hackagebot simple-effects 0.2.0.1 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.2.0.1 (darwin226)
16:34:58 <srhb> solucien: Wheras Either t _does_ take a type argument, and _can_ have a Functor instance (kind * -> *)
16:36:00 <oldmanmike> In cryptonite, why was cfb8Encrypt/cfb8Decrypt not carried over from crypto-cipher-types? They're commented out in the source.
16:36:52 <solucien> so either is data  Either a b  =  Left a | Right b
16:37:30 <solucien> my Pair is data Pair a = MkPair a a
16:38:05 <srhb> solucien: Right
16:38:11 <srhb> solucien: Notice the left hand side
16:38:22 <srhb> Either a b <- two type arguments
16:38:28 <srhb> Pair a <- one type argument
16:38:28 <solucien> if i made it data Pair a b = MkPair a b
16:38:32 <srhb> Yes...
16:38:55 <solucien> i would have to match the type in the 
16:39:03 <srhb> solucien: What do you mean "match the type"
16:39:06 <solucien> functor Pair a
16:40:28 <srhb> solucien: functor (Pair a) would be possible, yes, because the _kind_ of Pair a is * -> * -- that is, it takes one type argument, as is the requirement for making a Functor instance.
16:41:35 <solucien> i understand
16:41:39 <solucien> so when i call the fmap
16:41:50 <solucien> i have to choose which of the kinds to use
16:42:01 <solucien> from the functor call
16:42:23 <srhb> solucien: No...
16:42:24 <Welkin> lpaste is filled with spam
16:42:36 <Welkin> doesn't chris done know?
16:42:37 <srhb> Welkin: Yes, I sent chrisdone a mail about it recently.
16:42:41 <justicefries> so it seems like *most* stuff I'm working with is compiling in macos sierra
16:42:49 <srhb> solucien: I don't know where you got that idea.
16:42:53 <justicefries> yesod.auth seems to not compile.
16:43:11 <srhb> solucien: You cannot even create a Functor instance for something that does not have kind (* -> *)
16:43:18 <srhb> solucien: So there is no "choice"
16:51:51 <joncol> Hi, I'm trying to pass some initial user state to my Parsec parser. Specifically an Int of 0. When I try doing `runParser parseMyStuff 0 "" data`, the compiler complains with "No instance for (Num ()) arising from the literal ‘0’". I'm missing something basic here.
16:53:32 <EvanR> joncol: perhaps the parser you are running is written to assume u = () ?
16:54:18 <EvanR> or theres a missing top level type signature establishing that it shouldnt default to ()
16:54:39 <EvanR> which a 0 should work with...
16:54:40 <joncol> Yes, it's ":: Parser MyDataType". What's the correct type?
16:55:06 <EvanR> Parsec String Int MyDataType
16:55:13 <joncol> Cool, thanks
16:58:25 <athan> Hey everyone I've got a silly question - is there any sense in using a Data.Map.Strict vs. Data.Map.Lazy if the data contained is a function? Would this optimize the functions contained in any way?
16:58:47 <athan> Or really, is there any use in `seq` ing, or `deepseq` ing a function expression?
16:59:14 <hpc> not particularly
17:00:08 <athan> it wouldn't trigger inlining or anything more habbitually?
17:00:22 <athan> I'm not sure what role strictness plays in inlining
17:00:24 <hpc> inlining is static
17:00:35 <athan> hmm
17:01:11 <hpc> just the indirection of having a Map lookup is enough "don't know what to inline" to make it not doable
17:03:26 <EvanR> would stricting or seqing function help at least as much as making sure Ints are evaluated
17:04:12 <jp_rider1> hi, I'm using recv (http://hackage.haskell.org/package/network-simple-0.4.0.5/docs/Network-Simple-TCP.html#v:recv) to receive data from a tcp connection. unfortunately, when I get responses on the order of 100,000 bytes, it always returns Nothing. It works fine if the input is smaller. does anyone have any experience with this? 
17:04:37 <EvanR> yikes
17:04:45 <Lokathor> 100k bytes at once you say
17:04:50 <EvanR> well wouldnt Nothing mean something like peer went away
17:05:11 <EvanR> or other network problem
17:05:20 <Lokathor> doc says "Returns Nothing if the remote end closed the connection or end-of-input was reached. The number of returned bytes might be less than the specified limit."
17:05:31 <jp_rider1> documentation says the peer closes the connection
17:05:40 <jp_rider1> or eof like Lokathor said
17:05:51 <Lokathor> jp_rider1, sounds like you should read smaller amounts at a time, and then stitch them together
17:06:14 <EvanR> yes
17:06:31 <jp_rider1> I've tried ranges from 512 to 1024 * 1024 * 1024, always getting the same behavior
17:06:33 <EvanR> conduits to the rescue
17:07:26 <Lokathor> sounds like the buffer overflows and crashes before your program can read things out of it maybe?
17:07:58 <jp_rider1> the haskell program?
17:08:00 <jp_rider1> maybe?
17:08:19 <jp_rider1> it will print the "Nothing" though
17:08:52 <Lokathor> well really it's wrapping some networking lib that's more at the C level, so if the native lib crashes out then the haskell lib might read that as the same as the other end closing the connection
17:09:14 <jp_rider1> o interesting, yes maybe that could be happening then
17:09:23 <Lokathor> is there perhaps a way for you to get less than 100k at once
17:09:50 <jp_rider1> do you have any suggestions?
17:10:09 <jp_rider1> i don't have control over the server program
17:10:44 <jp_rider1> maybe i'll give conduit a try
17:10:56 <Lokathor> i'm afraid that the only time i've worked with the network stuff was for an IRC bot, and the IRC spec says that messages should be 512 bytes or less
17:11:45 <jp_rider1> haha k. wish I had that restriction :)
17:11:54 <jp_rider1> thanks for the help
17:12:24 <glguy> jp_rider1: Are you sure that the sender is actually sending 100k bytes?
17:12:45 <glguy> It could be trying to send 100k, only sending a few k and not bothering to send the rest or something
17:13:15 <glguy> considering that normal send behavior is to not necessarily send the whole message
17:15:16 <jp_rider1> glguy: I believe it is sending 100k. I have a python script that repeatedly calls `s.recv(1024)` and it receives the whole message
17:15:30 <geekosaur> Lokathor, if you mean the Haskell network library is wrapping something, it is wrapping system calls. if thet somehow overflowed a buffer, the entire process would crash, not just the C FFI part
17:15:43 <solucien> if i want to define my own either
17:15:55 <solucien> how do i make haskell ignore prelude ?
17:16:06 <solucien> this is simply for educational purpose
17:16:08 <geekosaur> also, if it was not clear from the documentation (it seemed fuzzy to me last time I looked), TCP is a stream. There are *no* "messages"
17:16:19 <Lokathor> solucien, https://wiki.haskell.org/No_import_of_Prelude
17:16:20 <solucien> I TRIED import qualified Data.Either as X
17:16:30 <ben> import qualified Prelude as DontLookHere? I dunno
17:16:40 <geekosaur> you get what's available at the moment which may or may not be the whole thing you sent, depending on lots of conditions.
17:18:31 <geekosaur> solucien, Either is in the Prelude
17:18:38 <geekosaur> importing Data.Either does not change this
17:20:12 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009 <-- the language Report specifies that Either is defined in the Prelude. you must suppress the implicit Prelude import to get rid of it.
17:21:44 <solucien> i won't do it then .. seems too complex
17:23:22 <koz_> solucien: It's really not: http://dev.stephendiehl.com/hask/#custom-preludes
17:31:37 <adelbertc> @djinn
17:31:37 <lambdabot> Cannot parse command
17:32:12 <adelbertc> @djinn Monad m => (a -> m b) -> m (a -> b)
17:32:12 <lambdabot> -- f cannot be realized.
17:32:24 <adelbertc> @djinn Monad m => m (a -> b) -> a -> m b
17:32:24 <lambdabot> -- f cannot be realized.
17:32:29 <adelbertc> boo
17:33:11 <solucien> i'm trying to implement the Functor for the ITree http://lpaste.net/357320233687449600
17:33:13 <adelbertc> so i know you can go m (a -> b) -> a -> m b, is it possible to go go the other way around? just wondering in teh interest of commuting monads
17:33:29 <solucien> how do i map a functor over Leaf (Int -> a) ?
17:33:56 <solucien> i tried some odd stuff, but they wouldn't parse
17:34:07 <solucien> i think i got the Node list right
17:34:12 <srhb> solucien: What do you mean "map a functor"
17:34:18 * hackagebot clang-pure 0.2.0.1 - Pure C++ code analysis with libclang  https://hackage.haskell.org/package/clang-pure-0.2.0.1 (PatrickChilton)
17:34:20 * hackagebot stache 0.1.7 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.7 (mrkkrp)
17:34:21 <solucien> define a functor
17:34:40 <solucien> fmap f Leaf (Int -> a) = ?
17:35:21 <srhb> solucien: First off, if that were legal, you have too many arguments
17:35:23 <srhb> :t fmap
17:35:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:35:38 <solucien> a functor tells Haskell how to run a function f over a arbitrary type
17:35:40 <srhb> solucien: fmap takes two. 
17:35:43 <solucien> that is what i meantby map
17:36:00 <srhb> solucien: That's not really a good definition, but let's skip that for now.
17:36:47 <srhb> solucien: The contents of the leaf is a function.
17:36:57 <solucien> yes, so i need to use composition ?
17:37:06 <solucien> f.a ?
17:37:10 <srhb> solucien: First, you need to get precedence right such that you actually have two arguments to fmap
17:37:16 <srhb> solucien: Something like fmap f (Leaf g)
17:37:34 <srhb> solucien: Notice the paranthesis. If I wrote `fmap f Leaf g` that's _three_ arguments to fmap, thus a type error.
17:38:36 <solucien> okay .. now for the fun part
17:39:02 <solucien> Leaf(Int -> f.a) does not work
17:39:24 <srhb> solucien: No, why would it? You can't have types as arguments there.
17:39:47 <srhb> Even if `Int ->` were valid syntax, it's meaningless in a term context.
17:40:10 <solucien>   fmap f (Leaf g) = Leaf (f.g)
17:40:11 <srhb> solucien: Perhaps you meant something like (Leaf (\n -> (f . a) n)
17:40:15 <srhb> Or that :)
17:40:38 <solucien> i got it , thanks a lot srhb
17:40:43 <srhb> solucien: You're welcome.
17:40:51 <solucien> i'm one step closer to undersstanding monads :D
17:41:43 <solucien> i'm at step 5 from http://dev.stephendiehl.com/hask/#monads : the Typeclassopedia
17:45:28 <lispy> solucien: looks like a good path. Keep at it.
17:50:23 <solucien> http://pasteboard.co/7939NaPa4.png
17:50:34 <solucien> is this violating the principle because
17:50:51 <solucien> doing fmap (g . h) = (fmap g) . (fmap h)
17:50:58 <solucien> would yield a different result ?
17:51:45 <solucien> g.h would perform 2 steps, while (fmap g ) . (fmap h) would perform 4 ?
17:52:00 <solucien> come to think about it, i am not sure now
17:52:07 <absence> is it possible to do the oposite of lift with a monad transformer?
17:52:34 <solucien> why is this an evil functor instance?
17:54:28 <solucien> i would say because fmap (g.h) performs the g.h function "pipe" twice ?
17:54:38 <solucien> while the other does it twice for each function ?
17:56:04 <srhb> solucien: Can't seem to get your pastebin to work
17:56:09 <srhb> solucien: Can you not use lpaste.net?
17:57:15 <solucien> http://imgur.com/a/kOgA4
17:57:20 <solucien> it seems pasteboard is down
17:57:45 <solucien> it was a small snippet from the thing i'm reading
17:58:25 <srhb> solucien: And you're asking whether fmap (g . h) is a problem?
17:58:25 <solucien> does this one work, srhb ?
17:58:31 <srhb> Yes
17:58:35 <solucien> i am asking why is this functor
17:58:47 <solucien> a evil one , which violates the rules
17:59:04 <solucien> fmap id = id
17:59:04 <solucien> fmap (g . h) = (fmap g) . (fmap h)
17:59:48 <glguy> Yes, that's why it's "evil" / "wrong"
18:01:09 <solucien> it seems that it would satisfy the first rule
18:01:14 <solucien> fmap id = id
18:01:48 <srhb> solucien: It doesn't.
18:02:23 <solucien> oh shit i see .. the list would double
18:02:29 <srhb> solucien: Right.
18:02:40 <solucien> cool
18:26:42 <joe9> I am searching for haskell bindings for  glx.h https://gist.github.com/918d29f8f977fc111ac6fea2d2269eb7 but could not find any. Any suggestions on how I can search for any haskell library that provides it?
18:29:19 <geekosaur> there are no Haskell bindings for the X11 GLX extension. Haskell OpenGL bindings generally go directly, not via X11.
18:30:00 <pavonia> There is https://github.com/reacocard/haskell-glx
18:30:05 <geekosaur> (the exceptions being the SDL, Wx, and Gtk+ wrappers, but they hide the details inside themselves)
18:34:20 * hackagebot jose-jwt 0.7.3 - JSON Object Signing and Encryption Library  https://hackage.haskell.org/package/jose-jwt-0.7.3 (LukeTaylor)
18:34:22 * hackagebot simple-log 0.5.0 - Simple log for Haskell  https://hackage.haskell.org/package/simple-log-0.5.0 (AlexandrRuchkin)
18:42:00 <internetuser> whois
18:42:25 <Axman6> I think, therefore I is
18:42:46 <internetuser> hello
18:42:57 <Axman6> hello!
18:43:23 <internetuser> how do i setup vpn 
18:43:58 <Axman6> I think you might be in the wrong place, this is a channel for discussion of the Haskell programming language
18:44:15 <internetuser> o sorry 
18:49:52 <joe9> geekosaur: Thanks. The only function that I could not find in OpenGl is createContext. Only glx seems to provide it.
18:50:30 <joe9> pavonia: Thanks.
18:50:33 <geekosaur> Did you by any chance consider looking at existing code?
18:50:53 <joe9> geekosaur: What existing code? glfw or sdl2?
18:50:56 <geekosaur> I don't see a lot of sense in forcing X11 (and, in effect, Linux only) for something that just wants to use OpenGL
18:51:02 <geekosaur> glfw, probably
18:51:26 <joe9> geekosaur: the problem with glfw is that the creation and destruction of windows should be in the main thread.
18:51:34 <geekosaur> but I didn;t mean look at glfw, I mean look at existing code that uses OpenGL
18:51:48 <jp_rider1> just an update, i'm still not getting any output from the tcp stream using conduit (even with sinkFile)
18:51:50 <joe9> geekosaur: https://ask.slashdot.org/story/03/01/11/0043207/why-isnt-x11-thread-safe comment by nellardo.
18:52:10 <geekosaur> ...
18:52:22 <geekosaur> ok, yes, from now on OpenGL is dependent on X11 for its existence. Noted.
18:52:24 <joe9> geekosaur: ok, thanks. will check on glfw is creating the context. That is a good idea.
18:52:46 <geekosaur> Never mind that it works on Windows and OS X/macOS without any X11 being involved
18:53:36 <joe9> geekosaur: i am on linux and do not care for the other platforms. I just want something that works well on linux instead of a "lowest common denominator", imho.
18:54:50 <geekosaur> I just don't see a lot of point in using an obsolete 2D window system to access a 3D graphics model that has a direct interface without the extra setup/teardown of a 2D interface you're not going to use.
18:55:33 <joe9> geekosaur: glfw is also using glx internally.
18:55:45 <geekosaur> that seems wrong...
18:56:35 <joe9> geekosaur: What is the "obsolete 2D window system"? I am not well versed with the graphics stuff, so, any info/suggestions you provide are helpful.
18:57:31 <geekosaur> X11
18:57:40 <geekosaur> GLX is part of X11
18:58:19 <joe9> geekosaur: so you recommend not using X11?
18:58:41 <geekosaur> it is a server extension. (Your pastebin earlier is from Mesa which was originally the open source software OpenGL renderer wired into XFree86, and became the main hardware interface as well)
18:59:43 <joe9> geekosaur: both glfw and sdl use X11 on linux, correct?
18:59:49 <geekosaur> you now have me wondering, I had understood Linux offered more direct access to OpenGL but maybe it's still forcing you to go through X11 to get to it. (Maybe the alternative is having to hardwire NVidia or something; that would figure)
19:00:04 <geekosaur> sdl usually tries to go directly when it can
19:00:22 <Adeon> afaik you have to use glx plus X11 if you want to use opengl on X
19:00:27 <Adeon> I don't know how to create context otherwise
19:00:39 <joe9> geekosaur: It is just the wrapper. create the window XCreateWindow, etc. The rest of my program to render is using OpenGL code.
19:01:04 <joe9> Adeon, I agree with you. That is the only solution I could find.
19:01:10 <joe9> geekosaur: ^^
19:01:10 <geekosaur> well, glx's context is mostly a dummy X11 context, not an OpenGL context --- although it does have an OpenGL context associated with it
19:01:11 <Adeon> sdl2/glfw should be doing the X11 GLX part for you
19:01:17 <Adeon> but if you hare not using them then you need to do it yourself
19:01:35 <f-a> I installed ghc8, can I switch back to ghc7 somehow?
19:01:52 <Adeon> I can be wrong though...maybe nowadays you can create context without GLX or use glx functions without actually having X
19:01:55 <joe9> Adeon: I want to skip glfw/sdl2. the glx interface is just to create the context.
19:02:13 <Adeon> yeah then you need to use glx server extensions I believe
19:02:15 <geekosaur> nvidia and ati/amd both ship libraries that should allow direct access, but I can imagine them being proprietary enough that you have to hardwire one of them
19:02:36 <joe9> Adeon, I could not find anything to create context without using glx. If you know of any, can you please let me know?
19:02:47 <geekosaur> so maybe people just punted and put up with having to configure X11
19:02:57 <Adeon> the core opengl part doesn't have anything that can create contexts
19:02:59 <Adeon> it's always up to platform
19:03:04 <Adeon> and on X it's glx
19:03:15 <glguy> f-a: That depends how you installed it. GHC itself is fine having multiple versions installed at the same time
19:03:30 <Adeon> in vulkan though it's even easier to make context without tying it to any windowing system
19:03:39 <Adeon> so it's very easy to run headless vulkan if you want for whatever reason
19:03:40 <f-a> glguy: downloaded from ghc website, ran ./configure make install
19:04:21 <glguy> f-a, OK, then the old version is still installed
19:04:25 <f-a> yeah
19:04:59 <geekosaur> f-a. where did you install it?
19:05:09 <joe9> Adeon: ok, Thanks. good to know. I have a video card supporting OpenGL 3.3 and it does not support Vulkan.
19:05:19 <geekosaur> there's no uninstall but you could remove it manually. or just install the older one on top
19:05:39 <f-a> geekosaur: /usr/local (default dir)
19:06:07 <geekosaur> or install 7.10.3 in a different directory and use $PATH to select one, or if you;re on Ubuntu/Mint you can use hvr's PPA
19:06:10 <glguy> the previous version is still in /usr/local/lib/ghc-7.whatever/bin
19:08:23 <f-a> glguy: yup, but of course if I invoke ghc ghci cabal it will pick up ghc8
19:10:14 <joe9> f-a: can you use stack?
19:10:28 <f-a> joe9: no
19:10:55 <zort> does Persistent support embedded documents in MongoDB?
19:12:28 <geekosaur> f-a, export PATH=/usr/local/lib/ghc-7.10.3/bin:$PATH
19:12:36 <geekosaur> hash -r
19:12:42 <geekosaur> then: type ghc
19:13:12 <geekosaur> or: ghc --version
19:13:35 <geekosaur> ("hash -r" is because shells remember where they last found somehting. although setting $PATH should clear that anyway)
19:13:39 <f-a> handy, geekosaur 
19:14:08 <f-a> still, f@x60s:~/.cabal/bin$ ghci
19:14:08 <f-a> GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
19:14:37 <f-a> (ghc-the-compiler works)
19:15:13 <geekosaur> hm, are all the wrapper scripts in that dir? I don't recall how the bindist does that offhand
19:16:14 <f-a> is redownloading 7.10.3 and reinstalling that viable?
19:16:33 <f-a> seems the less arduous way
19:17:25 <glguy> Yeah, that'd be OK, too. For myself I install each GHC into a separate --prefix in my home directory so I can have them all available
19:17:44 <f-a> seems sensible, I'll adopt the same way
19:18:03 <f-a> glguy: and then you change PATH in your bashrc appropriately, right?
19:18:11 <glguy> No, I don't change my path
19:18:18 <glguy> I use the -w flag to cabal-install to pick a GHC
19:19:11 <f-a> thanks.
19:19:36 <glguy> e.g.: cabal install -w $HOME/ghc-7.10.3/bin/ghc whatever-package
19:33:51 <Welkin> over 100 users are gone
19:55:16 <EvanR> freenode go down the hole
19:55:27 <glguy> Only 100 missing, that's pretty good for today
20:05:47 <GLM> How might I go about writing a function of type Monad m, Monad n => m a -> (a -> n (m a)) -> n (m a)
20:10:32 <pavonia> You can't, I think
20:13:59 <glguy> GLM: You can see that it's not possible because `m' could be `Proxy'
20:14:24 <glguy> unless it was implemented as: thing x _ = return x
20:15:26 <glguy> But if you wanted to use the function argument, and `m' was Proxy then you'd have no value of type `a' to apply the function to
20:16:19 <shachaf> And in particular you can't use m's Monad instance to make it work that way only in the Proxy case.
20:16:45 <MarcelineVQ> How is Proxy used? I've seen it used in things like servant but I don't actually understand it
20:19:09 <pavonia> How is Proxy even a Monad?
20:19:28 <shachaf> The only way it can be.
20:19:38 <pavonia> What is return?
20:19:47 <Axman6> return a = Proxy
20:19:50 <glguy> pavonia: You can look up its instance definition via the source links in the haddocks
20:19:58 <Axman6> Proxy >>= _ = Proxy
20:20:11 <glguy> <spoiler> tags? :-p
20:20:53 <ReinH> Axman6: _ >>= _ = Proxy, even.
20:21:03 <shachaf> If it isn't obvious why Proxy is a monad, then writing its Monad instance is a good exercise.
20:21:13 <Axman6> I was implementing Control.Monad.Proxy.Strict :P
20:21:13 <shachaf> Would have been.
20:21:26 <glguy> put your head down against a baseball bat and spin around 10 times
20:21:32 <glguy> and then write the instance
20:21:56 <glguy> I think that's how memory works
20:22:13 <pavonia> I find instance functions ignoring their results generally a bit weird
20:22:26 <pavonia> s/results/parameters/
20:23:04 <shachaf> It's a monad because it satisfies the laws.
20:23:28 <shachaf> Which is easy to show because all values of a Proxy type are equal.
20:26:46 <EvanR> they will probably have spoiler tags in slack at some point, if they dont already. lets switch
20:31:44 <namra> greetings
20:32:17 <namra> trying to graps the following: filterM (\x -> [True, False]) [1,2,3]
20:32:46 <EvanR> good old list monad
20:32:50 <namra> to get some inside of the predicate a first did: powersetPred :: Int -> [] Bool
20:33:00 <namra> powersetPred x = [True, False]
20:33:03 <namra> that works fine
20:33:08 <kii> any one know how to use modbus? any one has taken sat/ielts/act? any one from usa/europe?
20:33:30 <namra> but i want to wrap that in a writer and log the x value
20:33:43 <namra> powersetPred :: Int -> Writer [String] ([] Bool)
20:33:54 <namra> but now i get a type mismatch
20:34:07 <EvanR> WriterT ?
20:34:10 <namra> Couldn't match type ‘[Bool]’ with ‘Bool’
20:34:19 <namra> Control.Monad.Writer
20:34:23 * hackagebot tianbar 1.1.0.1 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.1.0.1 (AlexeyKotlyarov)
20:34:23 <namra> from mtl package
20:34:36 <namra> but the return type of the first pred is also [Bool] Oo
20:34:59 <namra> note i'm very new to haskell
20:35:11 <namra> just finish reading learn you a haskell for great good
20:36:01 <EvanR> so whats the error
20:36:05 <EvanR> oh i see
20:36:21 <joe9> Adeon:  Do you think using XCB is a better idea for multi threading the GUI ? Each window having a different thread instead of all gui stuff in the main thread.
20:36:23 <EvanR> somewhere you are using the result as a Bool not a list
20:40:30 <namra> EvanR: http://pastebin.com/hA7rw7B1
20:41:02 <geekosaur> joe9, multithreading still won't work
20:41:15 <geekosaur> unless every thread has its own connection to the server
20:41:45 <glguy> namra: filterM requires a function argument   a -> m Bool
20:42:03 <geekosaur> or every X11 operation locks the world, which both xcb/xhb and xlib can do but it slows them both down rather badly
20:42:05 <glguy> namra: You're trying to use powersetPred which has type  a -> m [Bool] where m is Writer [String]
20:44:11 <geekosaur> (this is another reason I was hoping you could avoid X11)
20:44:24 <namra> glguy: but when i have powersetPred :: Int -> Writer [String] Bool
20:44:51 <namra> and return only False or True it'll work
20:45:00 <glguy> namra: Maybe you wanted: WriterT [String] [] Bool ?
20:45:25 <glguy> then you'd use lift instead of return on line 14
20:48:40 <namra> glguy thank you very much
20:49:07 <namra> as i said i'm new to all that, and didn't know about WriterT
20:50:25 <namra> ah now i get it. the nondeterministic computations because of the [] context.
20:50:45 <geekosaur> hm, lock the world won't work with xcb/xhb anyway, there's no way to ensure each thread sees only its own events unless each thread has its own connection
20:51:42 <lyndon> has anyone had any luch with stack hoogle?
20:52:15 <lyndon> (from the global project)
20:52:37 <EvanR> namra: WriterT is a monad transformer. It equips any other monad with the ability to do tell, thats how you could think of it.
20:54:33 <EvanR> they are useful when youre comfortable setting up a monadic interface but dont want to write the core monad instance yourself, and the base functionality happens to be a combination of things that transformers can do
20:54:39 <namra> EvanR: thanks, that why one has to do lift ((MonadTrans t, Monad m) => m a -> t m a) instead of return
20:55:49 <EvanR> lift embeds a program from the original monad into the new monad so you can use it together with tell (in this case)
20:55:51 <namra> not even familiar with transformers yet ^^
20:56:32 <EvanR> they can be abused but you pretty much need to know them
20:57:13 <namra> "we often need to be able to use several effects at once" --- a i see, that's why you say one needs to know them
20:57:28 <EvanR> transformers arent the only way to do that
20:58:08 <EvanR> and theres more to the story behind that quote
20:58:34 <EvanR> but youll figure it out
20:59:09 <EvanR> you really need to know them because some big time libraries have gone full-transformer
21:03:40 <namra> certainly very interesting how that purity is achieved and with what levels of abstractions
21:04:22 <namra> truly mind-blowing and somehow liberating.
21:05:20 <namra> liberating in a sense when one thinks of imperative languages where one can do side-effect every and thus this has to be always on once mind when calling something especially in third party libs
21:07:01 <EvanR> its also more about culture, in haskell you can certainly do IO without it being evident in the type of the library calls
21:07:22 <EvanR> its just way more common in haskell to either not do that, or only do IO that has no side effects
21:07:35 <EvanR> debugging notwithstanding
21:09:37 <namra> thanks guys for the help, learned quite alot in this short time. cu
21:10:41 <cynode> EvanR, What kind of IO doesn't have side effects?
21:11:35 <glguy> an action that creates and uses arrays or IORefs internally
21:11:49 <joe9> geekosaur: oh, ok, Thanks. Do you have Wayland as an alternative?
21:12:06 <glguy> You could have a value with type `IO Int' that uses IO to compute the Int without exposing any side effects
21:12:15 <joe9> geekosaur: I do not mind each thread being an OS thread and each thread having it's own connection to the server.
21:12:16 <EvanR> you can also spawn threads to solve a problem internally, which cant be accessed by anything outside the function
21:13:14 <cynode> Ah, ok. That makes sense.
21:14:17 <EvanR> heres another one, you could create a "promise" value which only has a value after some external agent is ready. when the pure value of the promise is evaluated, it could use IO to wait until that value is available, it would just seem to take longer to eval
21:14:43 <EvanR> as long as the answer arrives eventually, its the same as being generated by regular code
21:15:40 <EvanR> if the result is still functionally related to the input, youre good (proof pending)
21:15:41 <geekosaur> joe9, I wish it were. So far it looks like a trainwreck looking for a place to happen, and I know plenty of folks who've tried to use it and given up and gone back to X11 because they are trying to push something that straight up isn't ready yet
21:16:52 <geekosaur> I mean, it took X 11 major versions and 4 minor versions to really be usable, and another minor version before it was really ready to be a graphics platform (X11R5)
21:17:15 <joe9> geekosaur: oh, really, I thought wayland was almost there. if emacs and firefox can  work with wayland, I would switch. Those are the only 2 gui apps I care about.
21:18:14 <EvanR> as soon as terminal emulator works on wayland, ill switch, its the only GUI app i care about
21:18:16 <joe9> geekosaur: Is there something wrong with each OS (asyncBound) thread having a connection to the server? I like this as it keeps having to mix the gui code and each thread can do it's own windowing stuff. Supposedly, there was eXena which did that long time ago.
21:18:49 <geekosaur> the devs would like people to believe it's almost there. but the more people use it, the more they're finding out the dumb choices they made (several of which they were informed of beforehand. but they "knew better" and did it anyway and are discovering the consequences)
21:18:53 <joe9> EvanR: There is no terminal emulator on wayland? That seems basic.
21:19:07 <geekosaur> that
21:19:11 <EvanR> i dont know, it was a joke
21:19:30 <geekosaur> that's not something that belongs at window system level to be honest
21:20:21 <geekosaur> xterm was part of X11 because of history, more or less. with X11R5 you started seeing toolkits and desktop environments and many of them sported their own terminals
21:20:49 <EvanR> yes, that makes no sense
21:23:27 <geekosaur> joe9, there's no real problem with it aside from the annoyance of managing so many separate connections and that it complicates sharing some window system related things (although *most* things are in fact shared anyway, so you can do it, it's just annoying)
21:24:37 <geekosaur> (fun fact: you can draw in any window you can get an XID for. see for example $WINDOWID in almost any X11 terminal, which allows things running in the shell to draw directly into the terminal window)
21:25:07 <geekosaur> (there are "text mode" web browsers that use this to render images)
21:25:08 <EvanR> handy
21:26:00 <EvanR> good thing all passwords are rendered as ****** so you cant scrape the pixels and get it!
21:26:00 <joe9> geekosaur: I am at a decision point, either use xcb (I do not mind managing the connection per thread) or wayland. I think wayland is a much bigger/longer change
21:26:25 <geekosaur> ultimately it'll be a better choice. I'm far from convinced of it right now
21:26:42 <geekosaur> I'd go with xcb / xhb
21:27:09 <joe9> oh, ok. thanks. That is a prudent choice, it appears too. though my wild side wants to dive into wayland.
21:27:46 <geekosaur> I just hope they figure it out faster than X did >.> (figure X1R1 to X11R5 before they got it all straight...)
21:27:59 <geekosaur> ("X1" is not a typo)
21:28:18 <joe9> geekosaur:  http://swaywm.org/
21:28:26 <joe9> geekosaur: interesting.
21:28:45 <grantwu> Does anyone have any experience using Alex with Megaparsec?
21:34:42 <joe9> geekosaur: any recommendations for a haskell library to work with xcb?
21:34:52 <joe9> geekosaur: xhb?
21:34:57 <geekosaur> yes
21:35:06 <joe9> geekosaur:ok, Thanks.
21:41:31 <Axman6> :t ala
21:41:33 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
21:41:56 <Axman6> > ala Sum [1..10]
21:41:59 <lambdabot>  error:
21:41:59 <lambdabot>      • Couldn't match expected type ‘(Unwrapped (Sum b0) -> Sum b0)
21:41:59 <lambdabot>                                      -> f (Sum b)’
21:42:33 <Axman6> > [1..10] ^. ala Sum
21:42:35 <lambdabot>  error:
21:42:36 <lambdabot>      • Couldn't match type ‘Const (Sum b) (Unwrapped (Sum b))’
21:42:36 <lambdabot>                       with ‘[Integer] -> Const (Sum b) [Integer]’
21:43:44 <Axman6> hmm, can someone remind me how ala works?
21:43:54 <ReinH> > ala Sum foldMap [1..10]
21:43:57 <lambdabot>  55
21:44:13 <Axman6> ah ha
21:44:35 * dmj` sings, "it's magic, magic, magic"
21:44:38 <shachaf> @let àla = ala
21:44:41 <lambdabot>  Defined.
21:44:43 <ReinH> heh
21:45:42 <Axman6> > àla Product foldMap [1..100]
21:45:46 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
21:47:00 <joe9> geekosaur: xcb seems a wiser choice https://gist.github.com/264e754543e41c78eaf5102b4a9faae9 works without an issue.
21:49:31 <geekosaur> it should work; xhb would be more Haskell-friendly in some sense
21:49:45 <geekosaur> although it's still low level so how Haskell-friendly it can be is ... limited
21:55:50 <joe9> geekosaur: ok, Thanks.
22:27:43 <Lokathor> what would be some suggested libraries to compile with stack that would pull in some of the other major libraries
22:27:56 <Lokathor> so that i could just pre-compile a big portion of LTS 7.0
22:28:15 <geekosaur> yesod? :p
22:28:26 <Lokathor> ah ha, yes, that's the one
22:29:21 * Athas is a little annoyed that so many Haskell tools come with no manpages.
22:30:48 <joe9> geekosaur: looks like xcb is not an option. XCB still uses xlib XOpenDisplay when creating OpenGL context: https://xcb.freedesktop.org/opengl/
22:31:26 <geekosaur> oyyyyy
22:32:07 <joe9> geekosaur: though there is https://xcb.freedesktop.org/manual/group__XCB__Glx__API.html https://xcb.freedesktop.org/manual/structxcb__glx__create__context__request__t.html
22:32:10 <Axman6> Lokathor: acme-everything depends on literally everything (not quite)
22:32:33 <Lokathor> well, that might be... a little overkill :P
22:32:36 <joe9> geekosaur: but I cannot find any documentation on how that function is used.
22:32:36 <Lokathor> but i'll consider it
22:33:04 <geekosaur> that's the problem with xcb, nothing is documented
22:33:26 <geekosaur> I always ended up digging through Qt and KDE source to decipher the parts of it I needed
22:33:53 <joe9> geekosaur: especially this: https://xcb.freedesktop.org/manual/group__XCB__Glx__API.html#ga63a4038a7d33c78cf814b1962158ead1
22:34:13 <joe9> geekosaur:  that seems to indicate that it creates the GLX context
22:34:44 <Axman6> Lokathor: https://www.stackage.org/package/acme-everything
22:35:12 <Lokathor> i think that'd actually take up too much :P
22:37:41 <Axman6> 24
22:37:44 <Axman6> whoops
22:37:46 <Clint> no
22:37:55 <MarcelineVQ> Clint: 25 maybe?
22:46:40 <joe9> geekosaur: How do you ceck the Qt / KDE source? Do you git clone and grep or is there a source repository index that is easier to search?
22:47:39 <geekosaur> I just read through their online repo. It helps that I ported older KDE versions to Solaris so I'm somewhat familiar with how they lay things out (which is part of why I went there instead of Gtk+ repos)
22:48:15 <geekosaur> of course they change things up every so often, KF5 I expect to complicate the next time I go looking for something :)
22:49:00 <joe9> geekosaur: Is this a good place?
22:49:03 <joe9> http://code.qt.io/cgit/qt/qt5.git/
22:49:34 <geekosaur> for the Qt layer, yes. but Qt only goes so far; for some things you have to look in higher level toolkits like KDE
22:50:13 <geekosaur> (there are some other options these days, as a number of toolkits switched from gtk to qt when the gnome devs announced they were taking over gtk dev and only targeting gnome)
22:51:46 <geekosaur> o.O I have not been paying close enough attention. Unity's switching to Qt?!
22:53:13 <geekosaur> (well, ok, my main interest in Unity is avoiding it...)
22:54:31 <joe9> geekosaur:  any particular project https://techbase.kde.org/KF5/Getting_Started/Source_Code#Source_Repositories_and_Revision_Control here?
22:56:01 <geekosaur> not really. pre-KF5 I looked in the kde base component but I haven't really looked at how they redid things with KF5
22:56:22 <geekosaur> it's a fairly major redesign so I expect I'd be as lost as you are :)
22:57:03 <joe9> geekosaur: there is kde-runtime.git
22:57:17 <geekosaur> otoh I;ve been doing source archaeology for long enough that I can usually find my bearings fairly easily. I can't convey 35 years of experience over IRC though
22:57:30 <joe9> kdegraphics.git
22:57:50 <joe9> geekosaur: fair enough. just a project name will help me.
22:57:54 <geekosaur> the runtime component should have most of the interfaces at xcb level
22:57:57 <joe9> https://quickgit.kde.org/
22:58:09 <joe9> geekosaur: ok, Thanks. will try the runtime
22:58:22 <geekosaur> you will also want the opengl stuff though and that will be spread between kde's and qt's opengl widgets
22:59:28 <geekosaur> the basic widgets should still be in the runtime component, the graphics component will be higher level stuff built on the runtime and any low level stuff should be isolated to the runtime component
22:59:45 <joe9> geekosaur: nothing in runtime
23:01:12 <Lokathor> so i currently have a scotty based server that i actually know nothing about as the webserver for my website
23:01:16 <Lokathor> it's just a hello world thing
23:01:35 <Lokathor> for a few URLs, i want it to just server up a static html file that will be on disk
23:01:56 <Lokathor> is this a "sane" thing to have it do, or should i pick another library for this sort of thing?
23:02:01 <geekosaur> oh, runtime is the wrong thing
23:02:18 <geekosaur> for kde4 it'd be kdelibs, nothing kf5 jumping out at me on quickgit though
23:03:04 <joe9> geekosaur:  ok, THanks. will check out kdelibs
23:03:12 <geekosaur> lxr.kde.org might be a good idea if you are looking for specific glx calls
23:03:23 <joe9> geekosaur: nothing in kdegraphics and qt3d, btw.
23:03:33 <joe9> geekosaur: thanks. will check out lxr.kde.org
23:04:16 <joe9>  Warning **
23:04:16 <joe9> Issuing rollback() due to DESTROY without explicit disconnect() of DBD::mysql::db handle dbname=lxr at /home/lxr/lxr/lib/LXR/Common.pm line 976.
23:04:23 <joe9> got that error when I tried lxr.kde.org
23:04:50 <geekosaur> siiigh
23:05:15 <geekosaur> they're letting their infrastructure languish :/
23:05:22 <geekosaur> not the best of signs
23:05:23 <joe9> https://lxr.kde.org/ident?_i=xcb_glx_create_context&_remember=1 -- no definitions found
23:05:29 <joe9> no usages found
23:05:49 <geekosaur> check the qt repos then
23:06:00 <geekosaur> there should be a QOpenGL component
23:06:05 <joe9>  geekosaur:  found something with just the word glx
23:07:24 <joe9> geekosaur: but those are all just glx.h bindings
23:07:40 <joe9> geekosaur: I do not know if kde is even using the xcb_glx_create_context
23:07:54 <geekosaur> like I said, more likely to be in the qt repo
23:08:24 <joe9> no, nothing there. checked out the qt5 repo
23:08:39 <geekosaur> the pre-kf5 KOpenGL widget was a wrapper around QOpenGL with some added behavior; I don't know what the replacement is
23:08:39 <joe9> git://code.qt.io/qt/qt5.git
23:10:44 <joe9> I wish there were some examples of XHB
23:11:06 <joe9> would you be worried as XHB is for version 1.6 . where as the latest version of xcb is 1.11
23:13:24 <joe9> geekosaur: got a sample here https://github.com/KhronosGroup/Vulkan-Samples/blob/master/samples/apps/atw/atw_opengl.c
23:13:48 * geekosaur is finding qt rearranged things too, no more QOpenGL
23:14:15 <joe9> geekosaur: no, that uses XOpenDisplay. old version, I think.
23:15:28 <geekosaur> http://fossies.org/linux/xorg-server/hw/kdrive/ephyr/ephyrhostglx.c
23:31:02 <joe9> geekosaur: That is a very good sample. Thanks a lot.
23:34:27 * hackagebot hw-prim 0.3.0.0 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.3.0.0 (haskellworks)
23:35:48 <lpaste> lambda-11235 pasted “Cabal failing to notice containers” at http://lpaste.net/213344
23:36:37 <hvr> Cabal is *not* failing to notice contains
23:36:56 <hvr> it's simply not mentioned in the build-depends for the exe
23:38:16 <lambda-11235> hvr: Ah, thanks. Thought I tried that, must be late.
23:50:17 <Lokathor> whee, new server http://lpaste.net/213359
23:50:43 <Lokathor> (100% cargo culted)
