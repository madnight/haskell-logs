00:00:03 <MarcelineVQ> she's dead jim
00:00:09 <ongy> I just noticed
00:00:11 <manyone> i wanted a list returned
00:01:01 <[k-> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#v:inits
00:01:30 <[k-> is there a way to bookmark Data.List with a link pointing to the latest version of base?
00:02:12 <manyone> thank you for inits - it works too
00:02:27 <oherrala> [k-: just drop the version from url
00:02:37 <oherrala> https://hackage.haskell.org/package/base/docs/Data-List.html
00:02:43 <[k-> :o thank you!
00:04:59 <lpaste> myers revised “stty”: “Selling Bankink Logins Fresh Cvv+ dumps track WU Trf Hacked PayPal Acct Pay Date Site Msrminifresh” at http://lpaste.net/187505
00:06:00 <lyxia> I never saw this kind of spam before.
00:06:03 <MarcelineVQ> that's a new method
00:10:53 <geekosaur> sssss
00:14:57 <amalloy> what is a good haskell etup for emacs? what i have now seems to amount to little more than syntax highlighting, correct indentation, and inferior-haskell, but i'm sure there's much more out there somewhere
00:16:25 <systemfault> amalloy: I've heard of "intero" for emacs.. but haven't tried it
00:16:42 <systemfault> amalloy: http://commercialhaskell.github.io/intero/ That thing
00:18:44 <anticensored> what is haskell?
00:19:05 <amalloy> that looks amazing. i'll be thrilled if it works even half as well as that page claims
00:19:17 <anticensored> amalloy: what?  your moms pussy?
00:19:22 <anticensored> does it not work well?
00:20:34 <oherrala> amalloy: I'm using intero. It's good
00:21:01 <anticensored> oherrala: in your moms cunt?
00:21:15 <jle`> @where ops
00:23:09 --- mode: ChanServ set +o shachaf
00:23:21 --- mode: shachaf set +b-o $a:anticensored shachaf
00:29:41 <systemfault> @pl (\acc x -> acc++[x])
00:29:51 <systemfault> What's that command to simplify
00:30:31 <lyxia> you got it right but lambdabot is away
00:30:56 <geekosaur> also "simplify" is dubious
00:31:10 <systemfault> geekosaur: As expected from a beginner like me.
00:31:12 <dibblego> (. pure) . (++)
00:31:26 <dibblego> \acc -> (acc ++) . pure
00:31:59 <systemfault> dibblego: I'm still not familiar with the (. pure) "pattern"
00:32:07 <dibblego> \x -> x . pure
00:33:25 <amalloy> oherrala: does it need to be inside a stack/cabal project to work? i have a fair number of loose .hs files lying around, and intero seems to be clueless inside them
00:39:49 <systemfault> geekosaur: What is the proper term I should use instead of simplify
00:40:16 <geekosaur> "pointfree" --- meaning, remove explicit bindings
00:40:27 <geekosaur> (acc and x in yours)
00:40:34 <amalloy> systemfault: "simplify" is a fine term - geekosaur is pointing out that a point-free solution is not necessarily simpler
00:40:55 <amalloy> that is, "simplify" is a fine term but not if what you are looking for is a point-free version
00:40:57 <systemfault> geekosaur: Ah, thank you :)
00:41:36 <geekosaur> yes, exactly that. you can convert pretty much any expression to point-free form, but the result can be larger and hairier
00:42:20 <geekosaur> although in at least one sense it is a "simplification": the compiler can often optimize them better
00:42:53 <geekosaur> but, I at least try to avoid writing code designed for the compiler to read at the expense of the next person that has to read it (which may or may not be me...(
00:48:26 <kaol> I find myself using a function like (Monad a -> Monad b) -> (Monad a -> Monad b). I suspect that there could be some abstraction behind this, does it sound familiar to anyone?
00:51:01 <dibblego> do you mean? Monad m => (m a -> m b) -> m a -> m b
00:52:36 <kaol> Sorry, I was unclear. (Monad m, Monad n) => (m a -> n b) -> m a -> n b
00:55:27 <ongy> isn't that just function application? with a specialication
00:56:14 <kaol> Hmm. Right you are. No wonder it seemed somehow obvious.
00:57:33 <kaol> In this particular case, there is some magic done in monads, but the basic pattern's there.
00:58:42 <oherrala> amalloy: nope, I don't think so
01:01:17 <amalloy> hm. oherrala: when i run it on https://github.com/amalloy/advent-of-code/blob/master/day22/Day22/Game.hs , any action i do yields "Couldn't guess that module name. Does it exist?", apparently because it can't find one of the other files in that folder: "Could not find module ‘Day22.Search’ It is not a module in the current program, or in any known package."
01:02:27 <amalloy> but it turns out it does work for standalone .hs files - i just didn't realize i need to C-c C-l first
01:04:54 --- kick: bitch was kicked by ChanServ (Banned: Inappropriate nickname prefix)
01:05:39 <amalloy> so i conclude that it works on standalone .hs files and on stack packages, but not on faux projects consisting of multiple .hs files lumped together in a directory
01:06:14 <amalloy> which is fine with me i guess
01:13:28 <elliptic00> countChar::Char->String->Int
01:13:28 <elliptic00> countChar c = length.filter(==c) 
01:14:09 <elliptic00> Why this function can be ignored String?
01:14:41 <vapid> because of currying
01:14:51 <vapid> http://learnyouahaskell.com/higher-order-functions
01:15:55 <vapid> wtf is happening
01:16:19 <Axman6> yeah there's a lot of noise at the moment, not sure what's up
01:17:09 <Axman6> maybe there was a netsplit at some point
01:44:10 <mniip> indeed there was
01:44:29 <mniip> 1473494702 [11:05:02] -tomaw/Wallops- Looks like a US hub died so a few client servers delinked from the network. bringing them back online now.
02:06:09 <dabd> very basic question: how to write the following in point-free? f x y = (x + 1) : y
02:07:14 <[k-> My best try:  f x = (:) succ x
02:07:54 <lyxia> @pl f x y = (x+1) : y
02:07:54 <lambdabot> f = (:) . (1 +)
02:08:23 <quuxman> point free is entertaining. What the heck do you use that function for?
02:08:28 <[k-> > succ 1
02:08:31 <lambdabot>  2
02:09:08 <quuxman> shachaf: still around? What's up these dys?
02:09:25 <opqdonut> dabd: here's how you derive it: https://gist.github.com/anonymous/9282c9ea631c2d4240b6dcb128dced6a
02:09:51 <shachaf> whoa whoa whoa, hi quuxman
02:09:57 <shachaf> See #haskell-offtopic
02:10:38 <dabd> opqdonut: thanks
02:23:10 * hackagebot elm-init 1.0.5 - Set up basic structure for an elm project  https://hackage.haskell.org/package/elm-init-1.0.5 (justus)
02:23:12 * hackagebot do-list 0.9.1 - List construction with do notation  https://hackage.haskell.org/package/do-list-0.9.1 (TarasSerduke)
02:34:50 <ashishnegi> `return $ (flip writeChan msg) <$> userChan` in a `do` block does not call `writeChan` but doing like `case userChan of Nothing -> return () Just c -> writeChan c msg` does .. can not understand the reason ?
02:35:43 <ongy> ashishnegi: userChan is something in Maybe?
02:36:09 <ashishnegi> ongy: yes..
02:36:40 <ashishnegi> ongy: its compiling fine in both cases and but in one.. it does not call `writeChan` userChan is `Maybe Chan` after looking it up in a map
02:37:34 <mauke> the first code is equivalent to: case userChan of Nothing -> return Nothing; Just c -> return (Just (writeChan c msg))
02:38:50 <mauke> the second code is equivalent to: maybe (return ()) (flip writeChan msg) userChan
02:39:03 <ashishnegi> mauke: but this is do in `IO ()` 
02:39:17 <mauke> irrelevant
02:39:24 <ashishnegi> uh.. thanks..
02:39:40 <ongy> ashishnegi: what's the type of: (flip writeChan msg) <$> userChan
02:40:05 <mauke> I mean, why does it matter whether this is part of a 'do' block?
02:41:24 <ashishnegi> ongy: yes.. that is what causing the problem.. how do you see type in emacs
02:41:53 <ashishnegi> mauke: but every line of do block should be `IO ()` right ? then how is the first compiling ?
02:42:02 <mauke> ... because it's in IO?
02:42:05 <ongy> I don't know about emacs. But you can figure that one out yourself
02:42:07 <mauke> why do you think it isn't?
02:42:24 <ongy> the type, not emacs hackery
02:42:51 <ashishnegi> ongy: it is `IO ()` i used emacs shortcut to find that out.. let me apply my brain as well..
02:43:10 <ashishnegi> `flip writeChan msg` is (\c -> writeChan c msg)
02:43:15 <iputra> hello
02:43:31 <mauke> iputra: o/
02:43:44 <ashishnegi> (\c -> writeChan c msg) <$> Just c' => Just (writeChan c' msg)
02:43:53 <amalloy> ashishnegi: for the same reason that: return $ putStrLn "hello" --- doesn't write to stdout
02:43:55 <ongy> ashishnegi: think in types, not implementation
02:44:57 <amalloy> you have a (return) around the call to writeChan in your non-working case, and not in your working case
02:45:14 <iputra> how do you do?
02:45:21 <mauke> return (Just (...)) actually
02:45:30 <ashishnegi> ongy: Maybe (IO ()) should be the type of `(flip writeChan msg) <$> userChan` ??
02:45:46 <iputra> my name's ikhsan i'm from indonesia
02:46:02 <ongy> that looks correct to me
02:46:12 <iputra> i have a question with haskell programming language
02:46:39 <ashishnegi> ongy: then compiler started complaining about every statement of `do` block to be `IO`.. so i put a `return` which caused problem
02:47:09 <ongy> because the type you get is IO (Maybe (IO ())), but you want IO ()
02:47:10 <iputra> exactly question about functional programming, so my question is what the purpose of functional programming language ?
02:47:54 <mauke> ashishnegi: 'return' just wraps another layer of IO around it. you want the opposite: remove one layer of Maybe
02:48:12 <ongy> iputra: I would say writing libraries and applications.
02:49:01 <ashishnegi> mauke: you are right.. which is only possible by destructing `Maybe`.. or something is there ?
02:49:21 <implementation> iputra: that's like "what is the purpose of programming"
02:49:22 <mauke> ashishnegi: well, there are helper functions. they use case/of internally, though
02:50:02 <iputra> implementation: i'm sorry for my english, i mean that
02:50:27 <mauke> ashishnegi: e.g. the <$> operator you used destructs Maybe on the inside
02:50:59 <iputra> ongy: i know that, can you give the example program which make by haskell
02:51:08 <ashishnegi> mauke: which is not what i want.. as it wraps it again.. your `maybe` function is better api i guess..
02:51:28 <mauke> iputra: pandoc
02:51:49 <mauke> iputra: darcs, ghc, xmonad, leksah
02:52:28 <mauke> and the facebook spam filter thing
02:52:36 <implementation> iputra: here's a (incomplete) list http://hackage.haskell.org/packages/tag/program
02:53:02 <mauke> https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
02:53:16 <Cooler> does - have some special behaviour?
02:53:44 <Cooler> for example let x = - 3 works
02:54:08 <iputra> implementation: what's the benefit from learning haskell ?? i still confuse, why i must learn haskell ?
02:54:14 <ongy> yes, - has some special case for parsing. Because it's a unary and a binary operator
02:54:15 <mauke> Cooler: yes
02:54:34 <mauke> iputra: what programming languages do you know?
02:54:40 <ashishnegi> iputra: haskell like any other High Level Language can be used to write anything written in java/python/rails/clojure (c and c++ except for few areas.).. It is just that it make it easier to write them easier to write and maintain..
02:54:52 <Cooler> mauke, for convenience?
02:55:25 <iputra> mauke: pascal, c, python, php
02:55:32 <Cooler> what exactly is the behaviour?
02:56:01 <mauke> Cooler: well, it's the only unary operator in haskell so it gets special treatment in the parser
02:56:36 <quuxman> iputra: then learning Haskell will also be a nice practical introduction to some great computer science concepts
02:56:50 <mauke> iputra: one of the benefits of haskell is a good and powerful type system
02:56:59 <raek> iputra: for me functional programming is about writing code that is pure. pure means that you don't perform side-effect in your code.
02:57:15 <iputra> ashishnegi: that mean haskell can collaborate with other programming language ?
02:57:25 <Cooler> mauke, whats the exact behaviour?
02:57:42 <mauke> Cooler: I'm confused. what exactly do you mean?
02:57:42 <raek> iputra: in haskell, you cannot accidentally mix code with side-effects and code without side-effects (because they have different types)
02:57:48 <quuxman> iputra: type inference, lazy evaluation, powerful implicit optimzations, and managed side effects
02:58:00 <ongy> iputra: it's easy-ish to interface with C, others not so much
02:58:39 <ashishnegi> iputra: collaboration over json apis can be done by any language including haskell.. if you mean calling fns of other language from haskell.. its possible but believe that you would not want to do that after you learned haskell. :)
02:58:44 <raek> iputra: in my opinion, the most important side-effect to avoid is mutable state. many other languages also focus on making it simpler to program without mutable state (for example Erlang and Clojure)
02:59:27 <mauke> compared to c and pascal, you don't have to manually manage memory and work with unsafe pointers
02:59:45 <mauke> compared to python and php, you can get amazing performance
02:59:48 <raek> iputra: if you get rid of mutable state, concurrent programming, parallel programming, logic programming and lazy evaluation becomes far more easier
02:59:55 <Cooler> mauke, well - 3 evaluates to -3
02:59:57 <ashishnegi> iputra: also it is not important to learn haskell for writing programs.. this languages made me a better c++/java/clojure programmer :)
03:00:10 <Cooler> instead of stuff like (+ 3)
03:00:18 <raek> also, you don't lose any expressive power by removing mutable state
03:00:36 <ashishnegi> iputra: i meant writing big software only.. you can learn it for learning new research in languages.
03:02:01 <mauke> ?
03:02:38 <iputra> thx for the answer guys, now i understand, even if it's just a little bit
03:02:46 <iputra> thanks guys
03:02:55 <iputra> thanks for all
03:03:12 <implementation> just do it, you'll understand afterwards ;)
03:10:32 <Cooler> why is mod (-12) 7 = 2
03:11:01 <Cooler> shouldn't it be 5?
03:13:08 <mauke> no, but -5 might work
03:13:29 <mauke> > rem (-12) 7
03:13:31 <lambdabot>  -5
03:14:02 <nshepperd> because -12 is -2*7 + 2
03:14:04 <mauke> Cooler: because -12 divided by 7 is -2 with rest 2
03:19:15 <Cooler> mauke, i said mod not rem
03:19:40 <mauke> ??
03:20:23 <Cooler> nshepperd, so it changes direction when its negative?
03:23:11 * hackagebot rosmsg 0.4.3.3 - ROS message parser, render, TH  https://hackage.haskell.org/package/rosmsg-0.4.3.3 (akru)
03:27:41 <ph88> i understand that these types are wrong  https://paste.fedoraproject.org/423981/47335126/   but i'm not sure if i *want* the expected type or the actual type (so change the type or change the expectation) .. anyone an idea?  this is related to QuickCheck
03:29:49 <hk238> it's defined to be the smallest positive integer, so while -1 * 7 + (-5) = -12, you choose the version where -2 * 7 + (2) = -12 the `remainder term` is positive.
03:29:55 <hk238> @ Cooler
03:30:20 <hk238> Or at least that's how I remember it I'm not sure ^^
03:50:14 <cocreature> ph88: neither looks like what you want. are you trying to create a NonTerminal with an arbitrary token but a fixed version?
03:51:23 <ph88> yes cocreature , not even all tokens are valid .. a particular one should be generated
03:53:33 <cocreature> ph88: try changing the instance definition to "arbitrary = do arbitraryIdentifier <- arbitrary; pure (LN (NTer arbitraryIdentifier [Version1])" and completely remove arbNTer
03:55:46 <ph88> aah ok
03:56:03 <ph88> how can i write that without do notation ?
03:58:55 <mettekou_> Is there a way to customize the id column in the database with Persistent?
03:59:17 <ph88> arbitrary = arbitrary >>= \x -> return (LN (NTer x [Version1])    ??
04:00:57 <mettekou> I would like Persistent to use a different type than bigint (PostgreSQL) and to disable automatic incrementation.
04:02:22 <cocreature> ph88: (\identifier -> LT (NTer identifier [Version1]) <$> arbitrary
04:02:49 <ph88> oh not even monad
04:03:34 <mettekou> Never mind, found the solution: add a column in the Template Haskell and then use Primary to mark it as the primary key.
04:05:10 <cocreature> ph88: x >>= \x -> return (f x) can always be replaced by fmap f x
04:10:44 <ph88> cocreature, do you know what i'm doing wrong here?  https://paste.fedoraproject.org/425246/50579614/
04:15:17 <int-e> listOf (arbTer [Version1], arbitrary) <-- the pair is not a random generator.
04:17:26 <ph88> ye it has two random generators inside
04:17:41 <int-e> ph88: how about  listOf ((,) <$> arbTer [Version1] <*> arbitrary)
04:17:52 <ph88> instead of  Gen (a, b)   i have (Gen a, Gen b)  now
04:20:20 <ph88> i think that works, but why ?
04:20:32 <koz_> ph88: You mean int-e's suggestion?
04:21:39 <ph88> ya
04:23:12 * hackagebot bitcoin-payment-channel 0.2.3.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.2.3.0 (runeks)
04:23:14 * hackagebot htaglib 1.0.4 - Bindings to TagLib, audio meta-data library  https://hackage.haskell.org/package/htaglib-1.0.4 (mrkkrp)
04:23:16 * hackagebot snowflake-core 0.1.0.1 - twitter's snowflake  https://hackage.haskell.org/package/snowflake-core-0.1.0.1 (KaiJia)
04:26:58 <cocreature> ph88: because listOf expects something of type Gen a, and you gave it something of type (Gen a, Gen b) but (,) and Gen are different things
04:28:00 <koz_> ph88: Basically, (,) has the signature a -> b -> (a, b). But what we want is Gen a -> Gen b -> Gen (a, b). Notice the similarity?
04:28:15 <koz_> Now, to 'lift' our arguments into the world of Gen, we use <$> and <*>
04:28:54 <ph88> does <$> have precendence or <*>  ?
04:29:08 <koz_> ph88: They do different things.
04:29:12 <koz_> <$> is just infix fmap.
04:29:15 <ph88> ya
04:29:17 <koz_> :t (<*>)
04:29:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:29:22 <ph88> but they still have precedence rule
04:29:39 <koz_> ph88: I don't remember their precendence - in this case, I'm not sure it even matters.
04:29:44 <ph88> ok
04:29:58 <koz_> The idea is that you can use that as a lift. So you go from 'f a b' to 'f <$> a <*> b'.
04:30:00 <cocreature> they have the same precedence
04:30:13 <cocreature> so it’s just left to right
04:30:17 <ph88> but if (,) takes two arguments why is it not    (,) <$> (arg1) (arg2)  ? and we need <*>  ?
04:30:24 <cocreature> (because they are both infixl)
04:30:33 <koz_> ph88: Because arg1 and arg2 aren't Gen.
04:30:42 <koz_> We need to 'lift' them into the Gen world to make them play nice.
04:31:36 <koz_> For example, imagine we had Maybe instead of Gen if it helps.
04:31:50 <koz_> > (,) <$> Just 4 <*> Just "foo"
04:31:53 <lambdabot>  Just (4,"foo")
04:32:09 <ph88> pretty sure arg1 and arg2 are gen .. that's how i ended up with (Gen a, Gen b) in the first place
04:32:20 <koz_> ph88: Sorry, my bad. It's a bit late, I got confused.
04:32:38 <koz_> What I meant was that (,) has type signature a -> b -> (a, b)
04:33:03 <koz_> So if you use it directly, a is 'Gen c' and b is 'Gen d', so you get (Gen c, Gen d), which is not what you want.
04:33:30 <koz_> However, we can't just use 'fmap' alone, because (,) expects two arguments.
04:33:37 <ph88> dunno where the c and d come from .. but i get the point
04:33:45 <ph88> yes !
04:33:47 <koz_> ph88: They are different types.
04:34:07 <koz_> Saying 'a is 'Gen a'' is circular, so I just gave the 'inner' types different names.
04:34:09 <ph88> so if fmap expects two arguments then why we need <*>  ?
04:34:20 <sshine> like 'Maybe Int' and 'Maybe String' in that example, c and d would be the types.
04:34:23 <koz_> fmap expects *one* argument.
04:34:29 <sshine> s/the types/the argument types/
04:34:52 <koz_> fmap takes a function (a -> b) and returns a function (f a -> f b).
04:34:58 <ph88> does <*> denote some kind of sequence in which the arguments are being applied to (,) ?
04:35:03 <koz_> ph88: Kinda.
04:35:03 <sshine> :t fmap (,) (Just 4)
04:35:05 <lambdabot> Num a => Maybe (b -> (a, b))
04:35:18 <sshine> :t (<*>)
04:35:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:35:31 <koz_> Replace the 'f' above with 'Maybe' to see sshine's point.
04:35:54 <ph88> so if you have a function with 5 args, then you need 5 things in the Gen container and glue them together with <*> first
04:36:02 <koz_> ph88: Basically yes.
04:36:25 <koz_> The advantage of the f <$> x <*> y <*> ... <*> blah notation is we can now lift functions of arbitrary arg counts.
04:36:42 <koz_> It's one reason I absolutely love that notation to bits.
04:36:51 <sshine> ph88, <*> lets you apply a function that's already inside an applicative to a value that's also lifted.
04:37:10 <lyxia> :t (<*>) `asAppliedTo` Nothing
04:37:12 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
04:37:37 <koz_> lyxia: I've never seen asAppliedTo before. Where is that from?
04:37:45 <sshine> ph88, since (,) is curried, simply fmap'ing it onto the first value will partially apply it and leave the partially applied function inside the Maybe.
04:38:13 <ph88> ya ok so i should really read it as <$> happens first and then we are left with a function that takes 1 more argument  and we have 1 Gen left  and then <*> takes both to produce the final answer
04:38:25 <sshine> > liftM2 (,) (Just 4) (Just "foo")
04:38:28 <lambdabot>  Just (4,"foo")
04:38:28 <koz_> ph88: Yeah, that's a way to look at it.
04:38:53 <ph88> koz_, it's a special function from lambdabot i think, i asked before if i could get it in ghci .. but it's not there by default
04:39:04 <koz_> > liftA2 (,) (Just 4) (Just "foo")
04:39:06 <lambdabot>  Just (4,"foo")
04:39:14 <sshine> koz_, right, thanks.
04:39:21 <koz_> ^ is equivalent to (,) <$> Just 4 <*> Just "foo"
04:39:37 <lyxia> Right, asAppliedTo is just a lambdabot thing
04:39:48 <koz_> Just that the <$> ... <*> notation needs less bracketing, and we don't have to have liftA25 or whatever be defined for it.
04:40:01 <lyxia> of course you can easily define it, it's just a specialization of const
04:40:04 <sshine> > pure (,) `ap` Just 4 `ap` Just "foo"
04:40:07 <lambdabot>  Just (4,"foo")
04:40:26 <sshine> :t ap
04:40:28 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:41:32 <ph88> (,) looks a bit ugly though
04:41:34 <sshine> hmm, ap and <*> are pretty much the same.
04:41:49 <ph88> i mean someone who doesn't know haskell it looks like a weird thing to have (,)
04:42:37 <koz_> ph88: Well, it's not the worst I've seen.
04:42:45 <koz_> Lens has some truly hideous looking operators.
04:42:51 <koz_> Like ^?!
04:43:03 <sshine> with the TupleSections extension you can even have (o,,o) = \x -> (o,x,o)
04:43:38 <sshine> koz_, yeah, lenses are supposed to add convenience, not make Haskell look like APL. :P
04:44:08 <koz_> sshine: I usually just write everything longform.
04:44:16 <koz_> (when I use lenses, I mean)
04:44:37 <koz_> :t over
04:44:39 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
04:44:50 <koz_> > over mapped (+1) [1, 2, 3]
04:44:53 <lambdabot>  [2,3,4]
04:45:05 <koz_> That's *much* more readable than the infixy alternative IMHO.
04:45:29 <ph88> if i have   type BasicIdentifier = Terminal   and i already have an Arbitrary instance for Terminal, can i make a seperate Arbitrary instance for BasicIdentifier ?
04:46:12 <Taneb> ph88, the short answer is "no", type synonyms are interchangable
04:46:15 * koz_ also finds the 's t a b' type names funny.
04:46:34 <koz_> :t from
04:46:37 <lambdabot> (Profunctor p, Functor f) => AnIso s t a b -> p t (f s) -> p b (f a)
04:46:46 <koz_> Wait, not that one...
04:47:04 <koz_> It has a much cooler signature in the docs.
04:47:08 <Taneb> ph88, the long answer is you can use "newtype BasicIdentifier = BasicIdentifier Terminal" which makes a new type (ha) with identitcal runtime representation
04:47:15 <koz_> from :: AnIso s t a b -> Iso b a t s
04:47:20 <sshine> koz_, I agree to both (long form, funny type names)
04:47:34 <ph88> Taneb, i will choose to make a normal function instead of an instance function
04:47:47 <Taneb> ph88, that is the other long answer :)
04:47:52 <ph88> :P
04:48:10 <koz_> sshine: So you do 'over both agree (longForm, funnyTypeNames)'? :P
05:08:05 <kuribas> Is there a library or datatype for searching on ranges?
05:11:05 <1JTAA7TBK> Hello sempai!
05:11:17 <1JTAA7TBK> What is this name ? ? ?
05:11:51 <buttbutter> I have a style question. Say I have a function, I don't know, buildBicycle :: [Part] -> Bicycle. And then another function bicycleFactory :: [[Part]] -> [Bicycles]. bicycleFactory just builds a lot of bicycles and is just a mapping of buildBicycle on [[Parts]]. For these sort of situations, is it stylistically better to define buildBicycle outside of bicycleFactory? Or within it in a where block or 
05:11:57 <buttbutter> something? Assuming that buildBicycle is *only* used by bicycleFactory.
05:12:05 <koz_> kuribas: What kind of 'searching on ranges' are you trying to do?
05:12:34 <koz_> buttbutter: bicycleFactory appears to be fmap buildBicycle.
05:12:41 <kuribas> koz_: search in non-overlapping ranges.  I guess an IntMap will do...
05:13:12 <koz_> kuribas: If they're non-overlapping, yeah, an IntMap could do.
05:13:16 <kuribas> koz_: for a truetype encoding to glyph mapping.
05:14:02 <buttbutter> koz_: Yeah...so where would you end up defining buildBicycle? In the block of bicycleFactory or outside of it?
05:14:26 <cocreature> buttbutter: I would define it outside
05:14:35 <1JTAA7TBK> Yeah but what color will you paint the shed for the bike.
05:14:42 <1JTAA7TBK> Like what will the bike shed look like?
05:14:45 <dramforever> Question: Can I/How to get an uploaded file in servant?
05:14:59 <Cooler> https://wiki.haskell.org/Let_vs._Where
05:15:02 <koz_> buttbutter: There's relatively little cost to not where-binding something.
05:15:18 <Cooler> can someone help me understand how fib is evaluated there?
05:15:25 <buttbutter> I'm asking about readability. :)
05:15:36 <koz_> buttbutter: Readability for something like this is kinda subjective IMHO.
05:15:53 <buttbutter> Yeah, kind of seems that way I guess.
05:16:00 <buttbutter> Well, I have one vote for outside and that's what I've done.
05:16:04 <buttbutter> So I guess I'll just leave it like that :)
05:16:06 <dramforever> I think readability here doesn't matter too much because you can switch easily anyway
05:16:32 <koz_> buttbutter: I think it's more important to be consistent than anything else.
05:16:52 <koz_> Inconsistency is gonna be unreadable no matter what else you choose or don't choose to do.
05:17:00 <Cooler> anyone?
05:17:35 <koz_> Cooler: You might need to wait a bit. I certainly don't feel competent to answer your question, even though I *did* notice you asking.
05:18:19 <dramforever> Cooler: Looks like it's relying on optimization
05:18:23 <dramforever> "Thus it will not float the definition out from under the binding of x."
05:19:22 <Axman6> dramforever: #servant might be a better place to ask, I had a quick look and couldn't see anything obvious
05:19:43 <dramforever> Axman6: Nice, thanks for that
05:20:07 <koz_> dramforever: What is the (!!) in those fib definitions?
05:20:13 <koz_> :t (!!)
05:20:15 <Cooler> index
05:20:15 <lambdabot> [a] -> Int -> a
05:20:23 <Cooler> list[i]
05:20:25 <koz_> Oh, derp, I forgot that thing even *exists*.
05:20:45 <dramforever> That's good. You won't use it if you never knew it existed
05:20:49 <koz_> Also, is that operator pronounced 'index' or 'bang-bang'?
05:21:13 <implementation> perhaps "at"
05:21:27 <Cooler> does it use the same list(same memory) or create new lists(copies) each time it recurses?
05:21:37 <koz_> implementation: Yeah, that'd make sense. I've mentally read it as 'bang bang' up to now.
05:21:58 <dramforever> Oh wait a sec
05:22:08 <koz_> Although by that logic, the lens operator (^?!) would be read something like 'caret-interrobang'.
05:22:10 <dramforever> Cooler: Sorry I didn't quite notice the primes...
05:22:36 <koz_> Although I have a tendency to read that as 'huh?!'.
05:22:46 <opqdonut> koz_: how about "the power of interrobang"?-)
05:22:57 <koz_> opqdonut: That's a very long-winded name for an operator.
05:23:13 * hackagebot snowflake-server 0.1.0.0 - snowflake http server  https://hackage.haskell.org/package/snowflake-server-0.1.0.0 (KaiJia)
05:23:15 <dramforever> so the first fib uses the same list, but the second creates a new one for every indexing
05:23:15 * hackagebot mikrokosmos 0.1.0 - Lambda calculus interpreter  https://hackage.haskell.org/package/mikrokosmos-0.1.0 (mroman42)
05:23:23 <opqdonut> by the power of interrobang I compel thee
05:23:27 <opqdonut> oh well
05:23:45 <koz_> opqdonut: It's always a question for me how to pronounce certain infix operators.
05:23:48 <dramforever> :t {- That's way too -} confusing
05:23:50 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
05:24:05 <Cooler> so how is it evaluated? can it use the same memory?
05:24:10 <Axman6> dramforever: so, I assume you mean a file uploaded via a form? it's pretty unlikely there'll be support for that in servant - it's more focused on APIs (so you would PUT the contents of the file)
05:24:10 <koz_> I'm glad that some people settled on <$> being read as 'superman'.
05:24:21 <opqdonut> :D
05:24:21 <koz_> dramforever: Wtf does that even.
05:24:55 <Cooler> koz_, <$> actually means hope
05:24:55 <liste> koz_: https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Traversal.html#v:confusing
05:25:11 <koz_> liste: Is the name of that function meant to be ironic?
05:25:40 <Cooler> XD
05:25:49 <dramforever> Cooler: the first one does, the second one doesn't
05:25:58 <dramforever> because "The compiler cannot know whether you intended this -- while it increases time complexity it may reduce space complexity."
05:26:17 <koz_> liste: Oh, I think I get it now. It's 'con-fusing', rather than 'confusing'.
05:26:33 <koz_> Much like the whole thing about 'ders' and 'de'.
05:26:41 <liste> though I'd guess it does have a certain form of humor to it (:
05:26:45 <opqdonut> when you combine two swindles, you're confusing
05:26:59 <Cooler> ok so how does it evaluate that expression?
05:27:04 <Cooler> the first one the optimized
05:27:08 <Cooler> version
05:27:25 <koz_> liste: Large chunks of lens seem to have a very hacker sense of humour.
05:27:33 <koz_> Like the vicious-as-hell type signatures for lenses.
05:27:36 <koz_> All about the stab.
05:27:37 <Cooler> fib = (map fib' [0 ..] !!)
05:27:39 <dramforever> Cooler: There goes a list
05:28:00 <dramforever> a list called (map fib' [0..]) lifted to the top level so it's shared
05:28:30 <Cooler> no wait
05:28:33 <dramforever> call that fibList. Now you call fib 5, you index into fibList, and get back a thunk
05:28:36 <Cooler> wait
05:28:58 <Cooler> lets say i have    main = print $ fib 10
05:29:04 <Cooler> fib = (map fib' [0 ..] !!)
05:29:11 <dramforever> Ok
05:29:21 <Cooler> whats the entire evaluation ordeR?
05:29:35 <Cooler> it goes to execute main
05:29:39 <dramforever> Important thing: Mr. Compiler says, that (map fib' [0..]) looks constant, lemme get that out
05:30:18 <dramforever> so now fib is a list. I index out the 10-th element, which is a thunk that says (fib' 10)
05:31:07 <Cooler> uh
05:31:07 <Nuxular> Hi, should my haskell files have access to sandbox installed packages without any special package-db flags?
05:31:13 <Cooler> dramforever, what?
05:31:33 <dramforever> Do you understand the constant lifting part?
05:31:48 <Cooler> yes but i need some help with the steps of evaluation
05:31:51 <dramforever> It's like fibList = map fib' [0..], then fib = (fibList !!)
05:32:06 <Nuxular> I tried following http://projects.haskell.org/diagrams/doc/quickstart.html but ended up having to run with "-package-db .cabal-sandbox/i386-windows-ghc-7.10.2-packages.conf.d"
05:32:16 <dramforever> now we have fibList = [fib 0, fib 1, fib 2, ...]
05:32:41 <1JTAA7TBK> Hello
05:32:46 <buglebudabey> hello
05:32:56 <dramforever> Oops, sorry I mean fibList = [fib' 0, fib' 1, fib' 2, ...]
05:33:27 <1JTAA7TBK> Hello
05:33:36 <Cooler> @src map
05:33:36 <lambdabot> map _ []     = []
05:33:36 <lambdabot> map f (x:xs) = f x : map f xs
05:33:41 <Cooler> right
05:33:42 <1JTAA7TBK> My name is jon snow, please keep the wildlings out!
05:34:19 <dramforever> Let's check out fib 10, which is fibList !! 10, which is fib' 10, which is (fib 9 + fib 8)
05:34:22 <1JTAA7TBK> Also, how can this channel even be real? Elon Musk told me this was all a simulation? Can haskell be real if C isn't even real?
05:34:42 <1JTAA7TBK> Is this a real language? level with me guys.
05:34:44 <Cooler> dramforever, hold on a second
05:34:56 <vapid> no
05:35:02 <vapid> this is all a dream
05:35:07 <Cooler> how did get from fibList !! 10 == fib' 10
05:35:11 <1JTAA7TBK> read it in word up magazine
05:35:38 <dramforever> @src (!!)
05:35:39 <lambdabot> xs     !! n | n < 0 = undefined
05:35:39 <lambdabot> []     !! _         = undefined
05:35:39 <lambdabot> (x:_)  !! 0         = x
05:35:39 <lambdabot> (_:xs) !! n         = xs !! (n-1)
05:36:05 <dramforever> goes like [fib' 0, fib' 1, ...] !! 10 = [fib' 1, ...] !! 9 = ...
05:37:08 <Cooler> dramforever, but we haven't evaluated fibList yet, we just gave it a name
05:37:23 <dramforever> Oh I skipped some steps :P
05:37:40 <dramforever> it gets tedious...but I'll give it a try
05:37:51 <Axman6> @where ops
05:37:51 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
05:38:16 <koz_> Axman6: I was wondering how to light the Bat Signal.
05:38:39 <dramforever> _ stands for "uninteresting". fibList !! 10 = (map fib' [0..]) !! 10 = (_ : map fib' [1..]) !! 10 = (map fib' [1..]) !! 9
05:38:45 <Axman6> ops, see 1JTAA7TBK above
05:38:51 <dramforever> Does this make more sense now? Need more expansion?
05:39:36 <Cooler> dramforever, that doesn't seem right
05:39:48 <Cooler> (_ : map fib' [1..]) doesn't seem right
05:40:22 <Cooler> it needs to know the elements of fibList to pattern match (_:xs)
05:41:08 <Cooler> how does it know to just go from  map fib' [0..] to  map fib' [1..]
05:41:12 <Cooler> ?
05:41:23 <dramforever> More skipped steps :(
05:41:53 <dramforever> It's good actually. I don't want to be reduced down to a machine really, but here it goes:
05:42:10 <saurabhnanda> anyone using opaleye here? can you help me out with https://github.com/tomjaguarpaw/haskell-opaleye/issues/204 ?
05:42:11 <dramforever> [1..] = {- syntax sugar of -} enumFrom 1
05:43:37 <dramforever> uh..no sources? enumFrom n = n : enumFrom (succ n), and for Int's, succ n = n + 1
05:44:20 <dramforever> map fib' (enumFrom 0) = map fib' (0 : enumFrom (succ 0)) = fib' 0 : map enumFrom (succ 0)
05:45:55 <ertesx> dramforever: try the last one again
05:46:02 <koz_> dramforever: Decompiling Haskell forever.
05:46:30 <Cooler> = fib' 0 : map fib' enumFrom (succ 0)
05:46:43 <dramforever> Eww
05:46:45 <ertesx> Cooler: you try it again, too =)
05:46:47 <Cooler> = fib' 0 : map fib' (enumFrom (succ 0))
05:46:57 <dramforever> Yeah, stupid fingers
05:47:15 <dramforever> You know what, I think I remembered a webpages that can show you reduction steps of a subset of Haskell
05:47:32 <Cooler> isn't there a command on lambdabot that does this?
05:47:48 <buglebudabey> can i write [mj i j | i <- range bounds, j <- range bounds] as [mj i j | i,j <- range bounds]?
05:48:06 <ertes> buglebudabey: nope
05:48:15 <buglebudabey> so the first way is the simplest?
05:48:34 <ertes> buglebudabey: you could give 'range bounds' a name
05:48:38 <dramforever> let bnds = range bounds in [mj i j | i <- bnds, j <- bnds]
05:48:51 <buglebudabey> gotcha, thanks
05:48:56 <ertes> [ mj i j | let c = range bounds, i <- c, j <- c ]
05:48:58 <ertes> like that
05:49:01 <dramforever> Or maybe even Applicative, liftA2 mj bnds bnds
05:49:17 <ertes> applicative style is what i would use
05:49:19 <koz_> dramforever: mj <$> bnds <*> bdns, you meant.
05:49:20 <buglebudabey> oh cool, didn't no you could do it in the comprehension itself
05:49:25 <buglebudabey> know*
05:49:54 <ertes> buglebudabey: list comprehensions are basically just reassembled do-notation
05:49:59 <dramforever> koz_: I like the liftAN functions better. Your tastes may vary
05:50:19 <koz_> dramforever: They do - I prefer the <$> .. <*> style myself.
05:52:40 <barrucadu> Is something up with hackage? I uploaded a package ~10 minutes ago. hackage.haskell.org/package/concurrency says package not found, but hackage.haskell.org/concurrency/maintain works
05:52:52 <ertes> join (liftA2 mj)
05:52:53 <barrucadu> * package/concurrency/maintain
05:53:04 <ertes> (no, don't do that)
05:53:07 <barrucadu> Is it just a little slow at generating the page for a new package?
05:53:29 <koz_> ertes: Wait what?
05:53:35 <koz_> How does that even?
05:53:50 <implementation> barrucadu: to me, package/concurrency shows up
05:53:59 <ertes> barrucadu: i can see it, too
05:54:00 <dramforever> Cooler: you still there?
05:54:22 <barrucadu> implementation: ertes: Hah, it must have appeared in the last 30 seconds. If I refresh now, it shwos up.
05:54:30 <dramforever> I hope you get how fibList works now
05:54:39 <ertes> koz_: the 'join' is for a reader monad, not for []
05:54:48 <koz_> dramforever: Nope. Next, they'll request you go down to the compiled assembly.
05:54:52 <ertes> koz_: join f = \x -> f x x
05:55:17 <koz_> ertes: I never quite got the point of the Reader monad.
05:55:32 <dramforever> koz_: I can just leave this channel if this ever happens, you know
05:55:42 <koz_> dramforever: Yep, because you're not a compiler.
05:55:48 <ertes> koz_: it's this kind of reader monad:  instance Monad ((->) e)
05:56:02 <dramforever> And I'll be The Guy Who Didn't Want to Provide ASM
05:56:03 <koz_> ertes: Wait, functions from e to whatever?
05:56:17 <koz_> dramforever: Your name isn't 'asmforever', after all.
05:56:19 <ertes> koz_: it's just Reader in disguise
05:56:32 <ertes> or rather: (Reader e) is just ((->) e) in disguise
05:56:54 <hodapp> huh, HLearn looks like something I should familiarize myself with
05:56:58 <koz_> ertes: I guess I don't get what the point of calling that out as a monad is exactly.
05:56:59 <hodapp> though then I might have to comprehend SubHask
05:57:02 <Cooler> dramforever, yeah i trying to find the site you mentioned
05:57:14 <ertes> > (do x <- sin; y <- cos; pure (x^2 + y^2)) 15
05:57:15 <dramforever> Cooler: https://stevekrouse.github.io/hs.js/
05:57:17 <lambdabot>  1.0
05:57:33 <ertes> koz_: it's usually more useful in applicative style
05:57:34 <dramforever> Doesn't really save code for you, and no expression sharing
05:57:40 <hodapp> dramforever: neat!
05:57:46 <dramforever> And you got to define a lot in the Function Editor
05:57:55 <koz_> ertes: So wait, the reader monad there carries around that 15 which gets given to sin and cos implicitly?
05:58:09 <ertes> > liftA2 (+) ((^2) <$> sin) ((^2) <$> cos) 15  -- not a particularly great example though
05:58:12 <lambdabot>  1.0
05:58:23 <ertes> koz_: yeah
05:59:01 <ertes> koz_: it's literally just reader, but where 'ask' is 'id' and 'asks f' is just 'f'
05:59:11 <ertes> and fmap is (.)
05:59:15 <koz_> ertes: I *think* that makes sense.
05:59:19 <koz_> Kinda.
05:59:30 <koz_> But then again, it took me a while to get what 'traverse' did, so yeah.
05:59:59 <koz_> Once I understood it, though, I ended up using it *everywhere*.
06:00:12 <ertes> koz_: if you ever implement Reader yourself, you'll find that except for the obligatory wrapping/unwrapping you're implementing the ((->) e) instance
06:00:32 <ertes> yeah, reader monads not so much…  they are pretty useless in practice =)
06:00:37 <dramforever> koz_: data Pair a = Pair a a is a monad, by taking the diagonal when mapping
06:00:49 <Cooler> dramforever, uh it seems to have trouble with valid haskell code
06:00:56 <dramforever> Pair a b >>= f = let (u, _) = f a; (_, v) = f b in Pair u v
06:00:58 <ertes> ReaderT can sometimes be useful, but i'd rather not use it at all
06:01:07 <dramforever> Cooler: You got to adopt it a bit...
06:01:15 <Cooler> http://lpaste.net/188640
06:01:17 <dramforever> Doesn't really work so well
06:01:30 <dramforever> When I say "a subset", I mean "a subset"
06:01:34 <koz_> dramforever: So it's basically 'both' from lens?
06:01:43 <koz_> Sorry, 'over both'.
06:01:44 <dramforever> Ouch
06:01:52 <ertes> Pair is quite a useful Applicative
06:01:57 <dramforever> Pair a b >>= f = let Pair u _ = f a; Pair _ v = f b in Pair u v
06:01:59 <dramforever> Like this
06:02:03 <dramforever> f returns Pair's
06:02:21 <dramforever> Then Pair a is isomorphic to (Bool -> a)
06:02:43 <ertes> about that example from earlier:  [ mj i j | Pair i j <- sequenceA (pure (range bounds)) ]
06:02:45 <dramforever> to (Pair u v) = \c -> if c then u else v
06:02:56 <dramforever> from f = Pair (f True) (f False)
06:03:07 <dramforever> Generalizing away the Bool and poof, the Reader monad
06:03:41 <koz_> dramforever: OK, I *think* I follow.
06:03:48 <koz_> But it is about 1am here, so I might just be crazy.
06:04:51 <dramforever> Cooler: I think I got to leave now, but hopefully someone else will guide you through the Grand Evaluation Mission of Fib -- Optimized
06:05:11 * koz_ immediately volunteers not to.
06:05:12 <ertes> Pair a ≃ a*a ≃ a^2 ≃ 2 -> a ≃ Bool -> a
06:05:43 <koz_> That squiggly equals is 'isomorphic to'?
06:05:48 <ertes> yeah
06:05:51 <Cooler> the implications doesn't seem obvious from the function definition
06:06:13 <koz_> OK, *that* makes a bit more sense.
06:06:31 <ertes> koz_: types form a semiring with sums (Either), products ((,)) and isomorphism
06:06:49 <koz_> ertes: What's the identity element?
06:07:04 <ertes> 0 and 1
06:07:20 <koz_> What's 0 and 1 in the type domain?
06:07:22 <ertes> 0 ≃ Void for (+) a.k.a. Either
06:07:30 <ertes> 1 ≃ () for (*) a.k.a. (,)
06:07:39 <koz_> Ah, OK. That makes sense.
06:07:57 <ertes> oh, and it's fast and loose, so we're ignoring bottoms
06:08:09 <koz_> ertes: We generally make a point of doing that, I've noticed.
06:08:48 <Cooler> koz_, does it really make sense?
06:09:06 <koz_> Cooler: Yeah - I can handle some structures.
06:09:21 <Cooler> <ertes> Pair a ≃ a*a ≃ a^2 ≃ 2 -> a ≃ Bool -> a makes no sense to me
06:09:23 <koz_> (I just spent all of today mired in lattices - by comparison, this is nice)
06:09:34 <koz_> Cooler: It's just a bunch of isomorphisms.
06:09:37 <ertes> Cooler: Pair a ≃ (a, a), does that make sense?
06:09:39 <koz_> (on types)
06:09:41 <Cooler> yes
06:09:53 <ertes> Cooler: now instead of writing (a, a) write a*a
06:09:56 <koz_> (a,a) is a product type.
06:10:17 <Cooler> why would you write a*a? is that a multiplication on types?
06:10:25 <koz_> Cooler: We can define a ring on types.
06:10:29 <Cooler> do you mean the cartesian product?
06:10:31 <koz_> Rings have two operations - + and *.
06:10:35 <ertes> Cooler: because it's a semigroup with all the usual laws
06:10:39 <koz_> + for types is Either, * is (,)
06:10:43 <koz_> ertes: Ring.
06:10:49 <ertes> oopss
06:10:52 <ertes> semiring, of course
06:11:25 <Cooler> ok
06:11:43 <Cooler> so you mean the cartesian product and disjoint union or something like that?
06:11:58 <ertes> yeah
06:12:13 <Cooler> a^2 = a*a?
06:12:23 <ertes> Cooler: using the (*) semigroup you can rewrite a*a to a^2
06:12:31 <koz_> Cooler: Yep, much as the Cartesian product of A x A = A^2.
06:12:37 <Cooler> how does 2 -> a make sense?
06:12:37 <koz_> (in the language of sets)
06:13:08 <ertes> koz_: (->) can be shown to be the exponentiation operator for type algebra
06:13:26 <koz_> ertes: I've seen that actually - it's to do with the number of functions between sets.
06:13:35 <ertes> which makes sense, if you look at it using a few finite types and just count the elements
06:13:44 <ertes> yeah
06:13:50 <ertes> how many functions of type 3 -> 5 are there?
06:14:00 <koz_> ertes: 5^3 IIRC.
06:14:12 <ertes> sorry, that was actually for Cooler =)
06:14:19 <koz_> I *hope* I got that the right way around.
06:14:27 <ertes> but yeah, 5^3 is correct
06:14:52 <ertes> then of course 2 ≃ Bool
06:14:57 <koz_> Yeah, it's size of codomain to the power of size of domain.
06:15:06 <koz_> s/size/cardinality/g
06:15:37 <Cooler> what exactly is -> defined as here?
06:15:42 <ertes> you should always keep in mind that sizes are just a metaphor, but they work as long as your types are finite
06:15:45 <Cooler> you lost me at 3 -> 5
06:15:51 <ertes> the isomorphisms work across the board though
06:16:08 <koz_> Cooler: 3 represents 'the canonical type with 3 different options'. I.e. 1 + 1 + 1.
06:16:40 <koz_> Cooler: Are you aware of the notation for functions of the form f : A -> B?
06:16:46 <ertes> (Bool, Integer) -> Integer ≃ 2*Integer -> Integer ≃ Integer^(2*Integer) ≃ Integer^2 * Integer^Integer ≃ (Bool -> Integer, Integer -> Integer)
06:16:57 <ertes> you can do some fancy type rearrangement with type algebra
06:17:12 <ertes> whoops
06:17:14 <ertes> that was wrong
06:17:21 <koz_> ertes: Was about to say...
06:17:29 <Cooler> koz_, no what notation do you mean?
06:17:42 <ertes> Either Bool Integer -> Integer ≃ 2 + Integer -> Integer ≃ Integer^(2 + Integer) ≃ Integer^2 * Integer^Integer ≃ (Bool -> Integer, Integer -> Integer)
06:17:44 <ertes> that's the one
06:17:51 <Cooler> f :: a -> b
06:18:13 <koz_> Cooler: When we say 'f : A -> B', we mean 'the function f with domain A and codomain B'.
06:18:16 <ertes> Cooler: 3 ≃ Maybe Bool
06:18:18 <ertes> for example
06:18:27 <Cooler> koz_, yes but what notation?
06:18:29 <ertes> Maybe Bool ≃ Bool + 1 ≃ 2 + 1
06:18:45 <koz_> Cooler: The 'f : A -> B' notation.
06:18:57 <ertes> Cooler: think of 3 and 5 as any types with 3 and 5 elements resp.
06:18:57 <Cooler> you mean
06:18:59 <Cooler> f :: a -> b
06:19:00 <Cooler> ?
06:19:26 <koz_> Cooler: I was using a mathematical notation there.
06:19:35 <koz_> But yes, that's how Haskell renders it.
06:19:39 <ertes> (i suggest just using haskell notation)
06:19:53 <Cooler> ertes, so 3 is the set with 3 unique elements?
06:20:05 <ertes> Cooler: *a* *type* with 3 unique elements
06:20:17 <koz_> Cooler: Or, more exactly, the sum type with 3 'options'.
06:20:17 <ertes> it's not any specific type
06:20:38 <ertes> Cooler: you can put (Maybe Bool) where you see 3
06:20:53 <ertes> and (Maybe (Either Bool Bool)) where you see 5
06:21:19 <ertes> Nothing, Just True, Just False :: Maybe Bool  -- 3 inhabitants
06:21:44 <ertes> Nothing, Left False, Left True, Right False, Right True :: Maybe (Either Bool Bool)  -- 3 inhabitants
06:21:48 <ertes> 5
06:21:51 <Cooler> ertes, yes but how does 2 -> a = a ^ 2?
06:21:52 <ertes> not 3
06:22:36 <ertes> Cooler: for any given type A, how many functions are there of type 0 -> A?
06:22:46 <Cooler> 1?
06:22:52 <ertes> can you write it?
06:23:08 <Cooler> uh
06:23:14 * hackagebot async-dejafu 0.1.3.0 - Run MonadConc operations asynchronously and wait for their results.  https://hackage.haskell.org/package/async-dejafu-0.1.3.0 (barrucadu)
06:23:15 <ertes> f :: Void -> A
06:23:16 * hackagebot concurrency 1.0.0.0 - Typeclasses, functions, and data types for concurrency and STM.  https://hackage.haskell.org/package/concurrency-1.0.0.0 (barrucadu)
06:23:18 * hackagebot dejafu 0.4.0.0 - Systematic testing for Haskell concurrency.  https://hackage.haskell.org/package/dejafu-0.4.0.0 (barrucadu)
06:23:20 * hackagebot hunit-dejafu 0.3.0.2 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.3.0.2 (barrucadu)
06:23:22 * hackagebot tasty-dejafu 0.3.0.2 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-0.3.0.2 (barrucadu)
06:23:23 <Cooler> right
06:23:28 <Cooler> () -> A
06:23:31 <Cooler> but thats a value
06:23:34 <Cooler> of type a
06:23:41 <ertes> Cooler: () is not isomorphic to Void
06:23:53 <Cooler> really?
06:23:56 <koz_> Void is isomorphic to 0.
06:24:01 <koz_> () is isomorphic to 1.
06:24:06 <ertes> Cooler: () has one inhabitant, while Void has none
06:24:17 <koz_> (or rather, they're the canonical types for 0 and 1)
06:24:22 <hpc> it's perhaps more accurate to say... that
06:24:24 <Cooler> isn't f : Void -> a
06:24:31 <Cooler> just a value of type a?
06:24:36 <ertes> Cooler: nope
06:24:45 <ertes> Cooler: your answer was correct, but i'd like you to see why
06:24:51 <hpc> as far as a programmer would be concerned they're basically the same
06:25:01 <ertes> there is exactly one such function, but it's not necessarily straightforward what it is
06:25:12 <hpc> since the only difference () -> A can have over Void -> A is a bottom result for (f bottom)
06:25:24 <hpc> and programmers don't like bottoms
06:25:29 <koz_> hpc: Hurr hurr.
06:25:31 <koz_> Ahem.
06:25:32 <hpc> (and they cannot lie)
06:25:35 <koz_> LOL.
06:25:36 <ertes> Cooler: let me ask differently:  if i gave you a function of type 0 -> A, what could you do with it?
06:26:08 <Cooler> well how is it even a function
06:26:31 <ertes> Cooler: just assume that it is (because it is)
06:26:32 <Cooler> you can't apply it to anything that has a type
06:26:42 <hpc> functions are things with (->) at the root of the type
06:26:44 <hpc> which this has
06:26:49 <ertes> Cooler: let's put it this way: you can't apply it
06:26:55 <ertes> there is no value of type 0
06:27:09 <hpc> ertes: there's bottom, if you're in a system that has it
06:27:13 <ertes> Cooler: but it's still a function i can give you…  it's just not very useful =)
06:27:19 <koz_> hpc: We're pretending bottom doesn't exist.
06:27:20 <ertes> Cooler: it's called the empty function
06:27:28 <ertes> hpc: no bottoms allowed
06:27:33 <koz_> ertes: Hurr hurr?
06:27:48 <Cooler> ok
06:28:02 <ertes> koz_: that's not how butt-head laughs…  it's uh-huh-huh-huh huh-huh huh-huh…
06:28:03 <ertes> =P
06:28:07 <Cooler> are you asking for its definition?
06:28:11 <koz_> ertes: True dat.
06:28:24 * hackagebot rosmsg 0.4.4.0 - ROS message parser, render, TH  https://hackage.haskell.org/package/rosmsg-0.4.4.0 (akru)
06:28:43 <ertes> Cooler: the bottom-less definition actually needs a trick
06:28:50 <ertes> for example -XEmptyCase
06:28:56 <ertes> f = \case{}
06:29:08 <ertes> uhm, you also need -XLambdaCase for this one
06:29:19 <hpc> or you can just not pattern match on it
06:29:40 <hpc> er
06:29:44 <ertes> yeah, if you have a value of type A, you can just ignore your argument
06:29:59 <hpc> yeah, i was reading it haskelly and capital A would be a concrete type
06:30:07 <Cooler> so f _ = valueoftypea
06:30:08 <hpc> but if it's unknown you're stuck with empty case or something like that
06:30:22 <Cooler> isn't that the const function?
06:30:24 <ertes> hpc: that's fine, i was assuming "any concrete type A" =)
06:30:31 <ertes> Cooler: not quite
06:30:41 <ertes> Cooler: say A = Bool
06:31:00 <ertes> f _ = False;  g _ = True  -- are these different functions?
06:31:12 <ertes> f, g :: 0 -> Bool
06:31:40 <Cooler> yes
06:31:47 <ertes> Cooler: how can you tell them apart?
06:32:00 <Cooler> oh right you can't apply it
06:32:14 <Cooler> so they are the same
06:32:17 <ertes> yeah
06:32:22 <hpc> extensionally the same, anyway
06:32:47 <ertes> yeah, there are different functions, but you can't distinguish between them extensionally
06:33:04 <ertes> also there is this interesting case:  0 -> 0
06:33:16 <hpc> in agda or something like that, you can distinguish them with intentional equality
06:33:31 <Cooler> are there even functions 0 -> 0?
06:33:35 <hpc> id
06:33:38 <koz_> Cooler: There is precisely 1.
06:33:45 <Cooler> which is?
06:33:55 <aarvar> 0 ^ 0 = 1
06:34:00 <hpc> id :: 0 -> 0
06:34:04 <hpc> id x = x
06:34:12 <Cooler> how is id 0 -> 0?
06:34:20 <hpc> because id :: forall a. a -> a
06:34:21 <Cooler> id is a -> a
06:34:26 <hpc> and 0 can instantiate a
06:34:37 <ertes> Cooler: 0 -> 0 it's widely accepted to be isomorphic to 1
06:35:13 <ertes> it's a really weird function, but a function nonetheless =)
06:35:23 <Cooler> sure because id covers everything it also covers void?
06:35:27 <koz_> ertes: There must always exist degenerate examples.
06:35:31 <koz_> For everything.
06:36:13 <ertes> Cooler: yeah
06:36:27 <Cooler> what does this have to do with 2 -> a?
06:36:38 <koz_> ertes: When I'm more awake, I have to ask you to explain the Yoneda lemma. :P
06:36:40 <ertes> Cooler: now what about 1 -> A?
06:36:45 <ertes> how many functions of this type?
06:36:58 <Cooler> a?
06:37:04 <ertes> koz_: you better ask someone who really understands it =)
06:37:15 <koz_> ertes: Who on this chan does/would?
06:37:44 <jmcarthur> As (0 -> 0) is isomorphic to 1, it is also isomorphic to (0 -> a).
06:38:14 <ertes> Cooler: can you tell which functions those are?
06:38:46 <ertes> Cooler: example:  1 -> 3, and let (y1, y2, y3 :: 3) be the inhabitants of 3
06:38:56 <Cooler> well if 1 is Something and a is anything(Int, String, Bool, etc) then you have
06:39:09 <Cooler> Something -> Int Something -> Float,etc
06:39:13 <ertes> koz_: i'd expect there to be quite a few, so just ask
06:39:20 <koz_> ertes: OK, after I'm rested.
06:39:59 <ertes> Cooler: i don't quite follow that…  1 is a concrete type like ()
06:40:09 <ertes> while A is any concrete type
06:40:30 <ertes> using the example A = 3, what are the functions of type 1 -> A?
06:40:41 <Cooler> yes so A can be Int, Float, String, etc
06:41:11 <Cooler> A is just the co-domain right?
06:41:24 <Cooler> so you have as many functions as there are co-domains
06:41:26 <ertes> ah, you should use punctuation when talking about haskell…  "Int Something" was quite confusing =)
06:41:41 <Cooler> oh missed a ,
06:41:49 <jmcarthur> Cooler: When ertes says A=3, they mean it has exactly three distinct values, such as   data A = A1 | A2 | A3
06:42:08 <koz_> Cooler: Alternatively, think of 3 as 'Maybe Bool'.
06:42:27 <Cooler> yeah i got it
06:42:37 <hpc> or Ordering
06:42:44 <aarvar> or Maybe (Maybe Unit)
06:42:49 <hpc> or acme-php's Bool ;)
06:42:52 <ertes> Cooler: can you write a function of type () -> Maybe Bool?
06:42:52 <aarvar> er, ()
06:43:03 <koz_> hpc: What is the whole acme thing anyway?
06:43:14 <hpc> acme is a prefix applied to packages that are jokes
06:43:14 <Cooler> f _ = Just True
06:43:42 <ertes> Cooler: okay, you said earlier that there should be 3 of those…  what do all of these functions have in common?
06:44:00 <Cooler> hpc, the acme from roadrunner?
06:44:12 <hpc> you should look at the acme-dont package for a good taste of what it's about
06:44:19 <Cooler> ertes, the input?
06:44:28 <hpc> Cooler: not sure if it's directly based on that, but certainly a similar etymology
06:44:28 <ertes> i should update acme-schoenfinkel at some point =)
06:44:43 <hpc> hasslich is my favorite acme joke on hackage :D
06:45:10 <ertes> Cooler: yeah, but more like:  if you look at the shape of these functions
06:47:00 <Cooler> ertes, when you say shape do you mean mapping?(injective, bijective, surjective)?
06:47:23 <ertes> Cooler: just the way you have written the function
06:47:25 <ertes> f _ = Nothing
06:47:28 <ertes> f _ = Just False
06:47:29 <ertes> f _ = Just True
06:47:55 <ertes> Cooler: can you think of a combinator that would make these perhaps look more aesthetically pleasing?
06:48:28 <ertes> (i should call them f1, f2, f3 instead of calling each of them f)
06:49:07 <Cooler> i am not sure what you mean by combinator
06:49:24 <Cooler> you mean like combinators in lambda calculus?
06:49:27 <ertes> Cooler: they are all constant, and i hoped that you would think of 'const'
06:49:42 <ertes> oh, "combinator" just means "function" really
06:49:52 <Cooler> yeah its const
06:50:50 <ertes> Cooler: now this one is a bit more tricky, but you can figure it out (pretend that you don't already know the answer)
06:50:57 <ertes> Cooler: what about 2 -> A?
06:51:43 <Cooler> a^2? but why
06:52:16 <Cooler> i would think 2*a?
06:52:18 <ertes> Cooler: let's use:  data A = X1 | X2 | X3
06:52:20 <ertes> so A ≃ 3
06:52:41 <ertes> and let's use B = Bool
06:52:43 <ertes> uhm
06:52:45 <ertes> and let's use 2 = Bool
06:53:03 <ertes> there is a function that maps False to X1 and True to X1
06:53:09 <ertes> there is a function that maps False to X1 and True to X2
06:53:10 <ertes> there is a function that maps False to X1 and True to X3
06:53:14 <ertes> there is a function that maps False to X2 and True to X1
06:53:15 <ertes> etc.
06:53:35 <Cooler> ohhhhh.
06:53:36 <Cooler> yes
06:53:41 <Cooler> a^2
06:54:10 <ertes> and if you continue this game, perhaps in a more useful (i.e. inductive) manner, you'll quickly see that (->) is indeed exponentiation for types
06:57:07 <Cooler> for every possible value of its domain, it can map to any value in the co-domain
06:57:41 <Cooler> and every possible mapping is a huge superset of the possible values?
06:58:55 <ertes> Cooler: it's actually easy enough to show this by writing an explicit bijection
06:59:48 <ertes> factorExp :: b^(a + 1) -> b * b^a
07:00:12 <ertes> multExp :: b * b^a -> b^(a + 1)
07:00:19 <ertes> then show that they compose to id
07:00:30 <ejbs> http://lpaste.net/8817866629498011648 Could someone look at this and see if there's something weird with my typeclass and instances of them? I get an odd error (I don't have Main.hs)
07:01:01 <ertes> Cooler: you can even show the distributivity law this way, which is really useful in practice to make better use of haskell's sharing
07:01:37 <ertes> distrib :: a^(e1 + e2) -> a^e1 * a^e2
07:01:56 <ertes> collect :: a^e1 * a^e2 -> a^(e1 + e2)
07:02:09 <ertes> and again:  distrib . collect = id, collect . distrib = id
07:02:29 <ertes> (the former is really a special case of the latter)
07:05:01 <ertes> Cooler: and of course:  curry :: a^(e1*e2) -> (a^e2)^e1
07:06:13 <pavonia> ejbs: This example is incomplete. What's the type of What are the types of line2profiles and rest?
07:06:26 <pavonia> oops
07:12:22 <Cooler> ertes, what was this all about?
07:13:00 <ejbs> pavonia: Yeah, I know. I got some help from the lab assistant to solve it
07:14:25 <ertes> Cooler: it's type algebra…  it gives you a commutative semiring structure over types and isomorphism that you can use to reason about and transform types
07:14:34 <ertes> Cooler: i can give you a practical example, if you want
07:15:25 <Cooler> something about reader monads?
07:16:51 <ertes> Cooler: no, something about lenses
07:20:36 <buttbutter> Is it possible to rename select functions that you want to import from another module?
07:21:32 <verement> you could re-export them with a different name
07:21:37 <buttbutter> Basically, I'm trying to import a module that has some functions with the same name as the module I'm writing. But it's only for a few, and I don't want to have to prepend a qualifier everywhere, especially on the types that the module I'm trying to import exports.
07:21:55 <buttbutter> verement: Right, but I don't like that. :(
07:21:56 <Hafydd> buttbutter: you can import some names qualified and some unqualified.
07:22:05 <buttbutter> Oh, didn't know that :D
07:22:23 <Hafydd> (Or rather: you can import all names qualified and some names unqualified.)
07:22:29 <buttbutter> Is the syntax import Module as M (functions)?
07:22:54 <Hafydd> No, it is: import qualified Module as M
07:23:07 <buttbutter> And then separately import the ones I want to be unqualified.
07:23:15 * hackagebot alga 0.2.2 - Algorithmic automation for various DAWs  https://hackage.haskell.org/package/alga-0.2.2 (mrkkrp)
07:23:17 * hackagebot haskelzinc 0.2.0.3 - CP in Haskell through MiniZinc  https://hackage.haskell.org/package/haskelzinc-0.2.0.3 (klara_mar)
07:23:19 * hackagebot opaleye 0.5.1.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.5.1.0 (tomjaguarpaw)
07:23:37 <Hafydd> Yes.
07:23:40 <ertes> buttbutter: you can also do a qualified and a hiding import
07:23:56 <ertes> import qualified Moo as M; import M hiding (…)
07:24:03 <Hafydd> Actually, I suppose you can also select the ones you want qualified (but there's no reason to do that in this case).
07:24:29 <buttbutter> I want only a few functions to be qualified, namely the ones with conflicting names.
07:24:34 <buttbutter> So isn't that a good reason to do it?
07:24:49 <ertes> buttbutter: basically haskell lets you import a module as often as you want, under as many names as you want, qualified and unqualified
07:24:57 <buttbutter> Okay. Good :D
07:24:58 <Hafydd> That's a good reason to select the ones you want unqualified, but the qualified names aren't going to get in the way.
07:25:07 <buttbutter> I see. :D
07:25:10 <buttbutter> Perfect. Thanks!
07:25:37 <Hafydd> See also: https://wiki.haskell.org/Import
07:26:02 <Hafydd> And https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3
07:26:52 <zennist> i found out that Lens.TH doesn't use the TemplateHaskell extension - does that mean there is a way that I could use it without TemplateHaskell extension too?
07:27:11 <zennist> I ask this because I'm going to compile some code on a stage1 compiler - which doesn't support TemplateHaskell extension
07:28:06 <ertes> zennist: you can write templates without TH, but you need TH to apply them
07:28:21 <zennist> how about TemplateHaskellQuotes?
07:28:54 <ertes> i only know QuasiQuotes, and it's the same thing for them:  you can write quasi-quoters without QQ, but you need QQ to apply them
07:29:37 <mekeor> which is the default html haddock directory for cabal installed hackage packages on unix? is ~/.cabal/share/doc/html/?
07:32:46 <hvr`> mekeor: more or less... recent cabal versions have:    datadir: $prefix/share  |  docdir: $datadir/doc/$abi/$pkgid  |  htmldir: $docdir/html   |  haddockdir: $htmldir
07:35:21 <owoce> hi everyone. im learning about monads, i get how Maybe/Either, [] and State work. my question is, do you know any  _suprising_  things that form monads?
07:36:58 <owoce> im trying to find as many monadic things as i can to better see the pattern
07:37:17 <liste> owoce: (->) a, maybe?
07:39:46 <mekeor> owoce: IO, maybe?
07:40:04 <owoce> right, forgot about IO.
07:41:10 <owoce> liste: thanks, i haven't used Reader yet
07:42:50 <liste> owoce: Cont is pretty wacky
07:43:27 <hydraz> owoce: ((-> r), not Reader; https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-645
07:45:52 <Hafydd> hydraz: that line is defining instance Monad (r ->), which is Reader.
07:46:52 <Hafydd> owoce: I don't know if it's surprising, but perhaps the implementation of the continuation monad is not obvious, so that is worth studying.
07:47:02 <hydraz> Oh, sorry; Now I'm more confused than I was before wrt the ((-> r) monad instance
07:47:26 <liste> hydraz: Reader is just a wrapper for ((->) r)
07:47:37 * hydraz fucks off and reads some more documentation
07:47:41 <liste> (well, conceptually anyway, without considering ReaderT)
07:48:00 <owoce> also i think some parser library had a Parser monad? that looked interesting
07:48:05 <hydraz> Parsec.
07:48:15 <Hafydd> What would return :: a -> a -> r be?
07:48:23 <liste> many parser combinator libraries have Monad instances for the parser type
07:48:35 <hydraz> Hafydd: const?
07:49:06 <Hafydd> :t const :: a -> a -> r
07:49:08 <lambdabot> error:
07:49:08 <lambdabot>     • Couldn't match type ‘a1’ with ‘r1’
07:49:08 <lambdabot>       ‘a1’ is a rigid type variable bound by
07:49:17 <Hafydd> :t const
07:49:19 <lambdabot> a -> b -> a
07:49:38 <Hafydd> I think there is no such Monad, and maybe you were thinking of Reader all along.
07:51:12 <liste> :t return 5 :: (r -> Int)
07:51:14 <lambdabot> r -> Int
07:51:19 <Cooler> if i have a function f _ = True
07:51:42 <Cooler> and then it tries to evaluate   f expr
07:51:51 <Cooler> does expr even get evaluated?
07:52:01 <liste> let's try out
07:52:09 <ongy> > let f _ = True in f undefined
07:52:09 <liste> > let f _ = True in f undefined
07:52:15 <lambdabot>  True
07:52:16 <lambdabot>  True
07:52:19 <Hafydd> Heh.
07:52:28 <Cooler> so no
07:52:41 <exio4> you don't pass the turing test
07:52:53 <exio4> I am sure ongy and liste are just different instances of the same bot! 
07:55:03 <owoce> Cooler: if it were evaluated, it would throw an error, because that's what happens when you evaluate undefined
07:55:32 <owoce> (i mean in the examples ongy/liste posted)
07:55:42 <Cooler> yes i got that
07:56:07 <Cooler> trying to understand the evaluation order
07:56:34 <owoce> ah sorry
07:57:58 <owoce> evaluation order of what? i thought one of the things about laziness is that you kinda don't know the evaluation order
07:58:18 <ongy> there is still an evaluation order that's deterministic
07:58:26 <ongy> but it's not always as obvious
07:59:06 * [k- pokes liste and ongy to see if they respond differently
08:00:00 <[k-> > let f !_ = True in f undefined
08:00:03 <lambdabot>  *Exception: Prelude.undefined
08:00:58 <[k-> I thought ghc would ignore _ completely
08:01:37 <[k-> i mean if it is unused why even bother evaluating it
08:01:43 <owoce> > :t (!)
08:01:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
08:02:09 <ongy> owoce: bangpatter, to force eager evaluation
08:02:28 <vapid> > let f _ = 1 in f undefined
08:02:31 <lambdabot>  1
08:02:34 <owoce> ah it's syntax not an operator?
08:02:40 <hydraz> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#bang-patterns-informal
08:03:01 <liste> ! as an operator is different
08:03:04 <M41px[m]> hello, i try this http://lpaste.net/188741
08:03:13 <ongy> [k-: it's also not the _ that makes something not evaluate
08:03:18 <ongy> > let f x = True in f undefined
08:03:20 <lambdabot>  True
08:03:51 <M41px[m]> I do not know how to do without the IO
08:04:43 <M41px[m]> I would like to do : device >>= checkId >>= enrole >>= ...
08:04:57 <liste> M41px[m]: what does checkId do=
08:05:09 <liste> :t liftM -- M41px[m]
08:05:11 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:05:31 <liste> you can do that to lift non-IO functions to IO
08:05:52 <[k-> But I thought _ was treated specially?
08:06:07 <hydraz> :t fmap
08:06:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:06:22 <ongy> [k-: I think only to avoid warnings (but I may be wrong)
08:06:24 <hydraz> or that. you can use that to lift non-IO functions to IO.
08:06:24 <liste> [k-: _ just means that the pattern isn't bound to a variable
08:06:58 <liste> > let f _ = _ in f 5
08:07:01 <lambdabot>  error:
08:07:01 <lambdabot>      • Found hole: _ :: t1
08:07:01 <lambdabot>        Where: ‘t1’ is a rigid type variable bound by
08:07:08 <liste> > let f x = x in f 5
08:07:10 <lambdabot>  5
08:08:21 <[k-> I see
08:10:32 <c_wraith> has anyone had success using something like closure compiler to remove dead code from ghcjs output? 
08:13:44 <ertes> c_wraith: i don't know if it actually removed dead code for me, but at least i could shrink it to a couple of hundreds of KiB
08:16:40 <MarLinn> c_wraith: NoScript does a great job with that... ;p
08:16:44 <ertes> c_wraith: i think you can even use different -O levels for the individual outputs to make some of them extra-small…  some will require -O SIMPLE, while others survive -O ADVANCED
08:23:16 * hackagebot opaleye 0.5.1.1 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.5.1.1 (tomjaguarpaw)
08:23:18 * hackagebot glue-example 0.4.7 - Make better services and clients.  https://hackage.haskell.org/package/glue-example-0.4.7 (seanparsons)
08:28:14 <mekeor> Haste seems like a really nice, innovative, usable project. i wonder whether it's suitable for a single-paged web-site with some javascript functioanlity at the front-end and some database-handling at the back-end. but why not, right? it's true haskell, isn't it?
08:29:13 <mekeor> maybe i should just give it a try. i'm quite uncertain atm. but maybe you can tell me bout your experiences with haste, too?
08:30:13 <c_wraith> mekeor, haste is real haskell. it just lacks things like concurrency that you can get from ghcjs (in exchange for larger Javascript) 
08:30:47 <dmj> single-threaded concurrency
08:31:17 <mekeor> i see. so, for a little web-site, it should be a good idea, i guess?
08:31:32 <c_wraith> mekeor, yeah it should work fine. 
08:31:50 <dmj> mekeor: probably for a big one too
08:32:19 <dmj> mekeor: the js is large, but you can do things like closure compile it and have the web server pre-render / deliver your templates
08:32:36 <dmj> most people will have it cached
08:32:38 <mekeor> it's so nice that in theory you can write a whole website just using haskell, using Haste, Html-Blaze and Clay and many other nice libraries :3
08:33:22 <dmj> mekeor: sure, just using ghcjs itself (probably will want at least ghcjs-dom too)
08:34:38 <xcmw> Is there a generic number parser anywhere that can parse decimals, fractions, mixed numbers, and written out numbers?
08:36:01 <ongy> > read "1/2" :: Float
08:36:04 <lambdabot>  *Exception: Prelude.read: no parse
08:36:21 <mekeor> dmj: how would you compare ghcjs to haste?
08:36:41 <[k-> Fractional a?
08:36:52 <xcmw> Written out numbers are of least importance
08:37:49 <xcmw> Haste does not support template haskell. GHCJS does.
08:38:44 <dmj> mekeor: it's not full GHC for one
08:38:46 <Cooler> why doesn't this give an error?
08:38:48 <Cooler> http://lpaste.net/188763
08:38:55 <Cooler> the do block isn't indented
08:39:03 <dmj> @google ghcjs vs. haste
08:39:05 <lambdabot> https://www.reddit.com/r/haskell/comments/31ui2h/whats_the_current_status_of_ghcjs_vs_haste/
08:42:47 <cloudhead> is there a way to have NamedFieldPuns work with normal functions on data types?
08:43:04 <cloudhead> or something similar?
08:43:28 <lyxia> cloudhead: what do you mean?
08:44:45 <cloudhead> lyxia: something like this: http://lpaste.net/188767
08:46:01 <Cooler> anyone?
08:46:04 <bergmark> cloudhead: chekc out view patterns
08:47:30 <cloudhead> bergmark: hmm but is it possible to map more than one function for a single argument?
08:48:00 <c_wraith> So..  At least gzip works quite well on ghcjs output.  Transferred size is about 20% of the full size.
08:48:23 <c_wraith> 80% compression isn't the norm for gzip
08:49:16 <bergmark> cloudhead: you can use e.g. (&&&) to make a tuple
08:49:40 <cloudhead> ah right
08:49:47 <cloudhead> I guess that's not a bad solution
08:50:09 <cloudhead> I'm trying to avoid using records inside sum types
08:50:16 <cloudhead> but I don't remember why
08:50:38 <Cale> heh, that's a really cute idea
08:50:50 <Cale> (the extension to named field puns)
08:50:55 <Cale> But yeah, view patterns
08:51:03 <c_wraith> Cale: did you ever try anything like closure compiler to minimize ghcjs output?
08:51:11 <ertes> mekeor: the question you should be asking yourself is whether you want to use haskell threads with blocking actions to do stuff like HTTP requests
08:51:15 <Cale> c_wraith: Yes, we use that
08:51:26 <c_wraith> Cale: how much does it help, do you know?
08:51:41 <Cale> From what I recall, a lot.
08:52:24 <c_wraith> Ok.  Guess I need to figure out how to use it correctly.
08:52:28 <ertes> mekeor: however, you can create a cooperative concurrency abstraction to deal with these things (it's still haskell)
08:52:43 <cloudhead> yeah if the extensions treated all functions of type Record -> Field it would work
08:54:03 <mekeor> ertes: so which of the two solutions can use haskell threads with blocking actions to do stuff like http requests?
08:54:12 <ertes> mekeor: GHCJS
08:54:15 <Cale> I don't have any examples of it on my system right now, since we use it only in deployment, and I'm not responsible for that, but iirc, it brought things down to a few hundred KB
08:54:28 <lpaste> lyxia annotated “No title” with “To cloudhead (annotation)” at http://lpaste.net/188767#a188772
08:54:33 <Cale> (from a few megabytes)
08:55:00 <dmj> Cale: wow, nice
08:55:04 <c_wraith> mekeor: for what it's worth, I'm experimenting with ghcjs right now.  https://ghcjs-demo.adjoint.us/ is my current exceptionally dumb test case. :)
08:55:29 <Cale> very demo
08:55:33 <dmj> Cale: I'm using vector a lot and inlining explodes the code base size, can go from 3MB to 1MB with aggressive closure compiling
08:55:36 <c_wraith> Though despite being dumb, it demonstrates everything necessary for single page apps except ajax calls.  I'll integrate one of those soon.
08:55:39 <dmj> explodes the js size*
08:55:49 <Cale> You have 3 candies!
08:56:24 <cloudhead> lyxia: :o interesting
08:56:31 <dmj> c_wraith: nice
08:57:43 <Cale> Here's a little demo I made the other day since Welkin was interested in interacting with an audio element: http://cale.yi.org/reflex/Audio/Audio.jsexe/
08:58:35 <Cale> The progress bar is clickable to seek the audio :)
08:59:18 <dmj> Cale: was just going to mention that, very cool
09:00:11 <dmj> since we're all showing off ghcjs stuff...
09:00:24 <dmj> here's a todo app w/ ghcjs-dom
09:00:26 <dmj> http://scribe-salutes-82753.bitballoon.com/
09:01:00 <Cooler> don't you have to intend do blocks and?
09:01:12 <leshow> dmj: wheres the code for your todos?
09:01:18 <Cooler> and the function body if it spans multiple lines?
09:01:19 <Cooler> http://lpaste.net/188763
09:02:01 <dmj> leshow: it's not released yet
09:02:28 <Cale> dmj: Heh, todomvc is also one of the integration tests for reflex-dom :)
09:02:56 <ertes> terminology question: given f . g = id, g . f = id, would you call f and g "witnesses" of an isomorphism?
09:03:14 <Cale> ertes: sure
09:03:25 <Cale> ertes: Though you might also just call them isomorphisms
09:03:48 <ertes> thanks
09:03:51 <Cooler> dmj, consider replacing the radio buttons with these https://www.youtube.com/watch?v=O6dc-sJm0Ho&t=2466s
09:04:09 <Cooler> nvm those are checkboxes
09:04:24 <Cale> (though I can imagine technical cases where you'd want to save the term "isomorphism" to refer to the pair of maps along with the relevant proofs :)
09:04:24 <dmj> Cale: ah, very cool. I actually use todo mvc for day to day tasks heh
09:04:57 <Cale> https://github.com/reflex-frp/reflex-todomvc/blob/develop/src/Reflex/TodoMVC.hs :)
09:05:50 <Cooler> can someone explain why you don't have intend do blocks?
09:05:55 <Cooler> or the function body
09:06:00 <Cale> what?
09:06:09 <Cooler> <Cooler> http://lpaste.net/188763
09:06:26 <dmj> Cale: nice! 229 lines is good, mine is 319 lines :/ and suffers from large allocations since I'm using lists liberally
09:06:32 <Cale> ah, because the first non-whitespace character following a layout keyword sets the indentation level for the block
09:06:41 <Gurkenglas> Is there an easy way to run a ReadPrec?
09:07:01 <Cooler> Cale, oh
09:07:02 <Cale> Cooler: So you can do that, but you'll have a hard time closing the block because you can't start a line in a shallower column to close it
09:07:14 <Cooler> ok
09:07:25 <ertes> Cale: yeah, normally i'd use "isomorphic functions" or even "bijections", but in this case i'd like to use "witness" for rhetorical reasons =)
09:07:41 <Cale> "isomorphic functions" sounds like the functions themselves are isomorphic
09:07:55 <Cale> Rather than their domain and codomain
09:08:32 <ertes> true
09:09:31 <Cale> Heh, so I have my machine overclocked to 4.3 GHz with water cooling, and it's great, but if I play a game for half an hour, my entire room gets uncomfortably hot.
09:10:10 <hydraz> Look at the bright side, you now have a room heater for winter
09:10:23 <dmj> Cale: might be time to pull out the liquid nitrogen
09:10:53 * jonored has used a computer running litecoin mining as a heater.
09:11:04 <hpc> thermodynamically there's nothing you can really do about that but make the processor more heat-efficient or make the room dissipate heat better
09:11:21 <hpc> better cooling for the CPU would only make the room heat up faster if anything
09:11:22 <ertes> you could get a fan…
09:11:31 <jonored> (it's just as efficient as a space heater, and also yields a trivial amount of cryptocurrency as a side-effect.)
09:12:13 <ertes> if you don't mind heating your neighbourhood =)
09:12:40 <hpc> clearly the problem here is greenhouse gasses
09:12:46 <Cale> Yeah, usually my solution is just to turn on the air conditioning, but then the other people in the house complain that I'm making the house cold
09:12:52 <Cale> (except for my room)
09:13:08 <[k-> dmj: your todo app is _hell_ on my phone 
09:13:11 <[k-> so sluggish
09:13:12 <alex-177> I can't generate type applications with  template haskell, can I?
09:13:13 <lyxia> play in a bathtub for watercooling yourself
09:14:13 <Cale> alex-177: You certainly can
09:15:21 <Cale> alex-177: See AppT/appT
09:15:32 <dmj> [k-: no surprise there, you on an iPhone?
09:16:14 <alex-177> Cale: I mean expression like `fold @[]`
09:16:19 <ertes> "this street looks rather depressing this time of the year" – "yeah, some say it's cursed, but actually it's this Cale guy's gaming PC"
09:16:29 <alex-177> Cale: not type
09:16:33 <Cale> http://saulzar.github.io/reflex-todomvc/ -- btw, this is the running version of Ryan's reflex-dom todomvc (took me a bit to locate a running copy)
09:16:39 <buglebudabey> could anyone give me a good example of for_M usage?
09:16:39 <dmj> [k-: the CSS isn't optimized for mobile, also, DOM events are different on browsers as well, and I haven't normalized them cross-browser entirely
09:16:45 <buglebudabey> could anyone give me a good example of for_M usage?
09:16:57 <dmj> > forM_ [1..10 ::Int ] print
09:16:59 <lambdabot>  <IO ()>
09:17:06 <[k-> dmj: I'm on a budget android phone
09:17:53 <Cale> alex-177: Ah, perhaps not
09:18:07 <[k-> dmj: striking out items is okay but typing is not smooth, characters get lost because my google keyboard hangs momentarily 
09:18:41 <dmj> [k-: in chrome, each keystroke is around 1MB allocation for me, but its' immediately GC'd by the browser
09:18:53 <Cooler> :T Char
09:18:58 <Cooler> :t Char
09:19:00 <lambdabot> error:
09:19:00 <lambdabot>     • Data constructor not in scope: Char
09:19:00 <lambdabot>     • Perhaps you meant one of these:
09:19:02 <Cale> :k Char
09:19:04 <lambdabot> *
09:19:13 <Cooler> @src Char
09:19:13 <lambdabot> data Char = C# Char#
09:19:14 <dmj> [k-: react and other frameworks hang out in the 5-50kb zone on DOM redraws per each event
09:19:14 <[k-> that sounds... terrible (it is, right?)
09:19:29 <Cooler> is it a 8 byte char or a unicode char?
09:19:36 <Cooler> i mean 1 byte
09:19:54 <hydraz> unicode
09:20:37 <Cale> > maxBound :: Char
09:20:40 <lambdabot>  '\1114111'
09:21:01 <lyxia> buglebudabey: did you mean forM_?
09:21:19 <Cooler> so its a variable length encoding?
09:21:20 <buglebudabey> lyxia yes
09:21:38 <lyxia> buglebudabey: oh dmj gave a good one, I guess
09:21:55 <dmj> [k-: yea, has to do with runtime representation, and how efficient your redraw is
09:21:57 <glguy> Cooler: No, Char isn't variable length
09:22:38 <[k-> the one Cale linked has much smoother typing but more sluggish adding
09:22:45 <Fairy> What's the difference between writing "let a = 3" and just "a = 3"? I'm reading the "learnyouahaskell" tutorial and it says that you use the "let" keyword inside GHCI, while you can omit it inside a script, but that doesn't seem to be true?
09:22:57 <glguy> Fairy: GHC 8 changed that
09:23:16 <Fairy> Ah, cool, thanks ;)
09:23:17 * hackagebot mida 1.0.2 - Language for algorithmic generation of MIDI files  https://hackage.haskell.org/package/mida-1.0.2 (mrkkrp)
09:23:19 * hackagebot glue-common 0.4.8 - Make better services and clients.  https://hackage.haskell.org/package/glue-common-0.4.8 (seanparsons)
09:23:21 * hackagebot glue-core 0.4.8 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.4.8 (seanparsons)
09:23:23 * hackagebot glue-ekg 0.4.8 - Make better services and clients.  https://hackage.haskell.org/package/glue-ekg-0.4.8 (seanparsons)
09:23:25 * hackagebot glue-example 0.4.8 - Make better services and clients.  https://hackage.haskell.org/package/glue-example-0.4.8 (seanparsons)
09:23:27 <c_wraith> glguy, I think the question is about top level bindings in a source file
09:23:31 <dmj> [k-: haskell lists become js objects, and js objects aren't as efficient as js arrays, from a memory footprint and lookup time perspective
09:23:45 <glguy> c_wraith: I think it's about the new declaration behavior in GHCi
09:23:59 <c_wraith> Oh, I see. 
09:24:06 <Fairy> So, the "let" keyword is pretty much useless at this point, or?
09:24:10 <c_wraith> I didn't even know that changed 
09:24:19 <dmj> [k:- most efficient DOM redrawing algorithms have absolutely minimal allocations, if any
09:24:25 <Cale> Fairy: It's still part of the syntax of expressions, but you don't need it at the ghci prompt
09:24:32 <glguy> Fairy: You'll still use let in do notation, and let...in to make expressions
09:24:36 <MarLinn> why... why would you have any kind of js do the work of a simple input box... has the world gone insane? I thought we were the sane ones... -_-
09:24:40 <Cale> Fairy: GHCi used to try harder to emulate the inside of a do-block
09:25:13 <Cale> and in the middle of a do-block, you can use let (without an 'in' part) to declare things that scope over the remainder of the block
09:25:17 <[k-> dmj: you are basically coding like a game!
09:25:42 <Cale> also, just generally, there is an expression form  let <decls> in <expr>
09:25:45 <dmj> [k-: essentially, that's how react works, animation loop
09:25:50 <Cale> > let x = 6 in x^2 + x + 1
09:25:53 <lambdabot>  43
09:26:13 <[k-> does react has emphasis on mobile?
09:27:46 <Cale> MarLinn: If you're compiling Haskell to javascript and reacting to input occurring in that textbox, then a bunch of javascript code is going to run every time you enter a character in the textbox.
09:28:27 * hackagebot propellor 3.2.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.2.0 (JoeyHess)
09:28:27 <dmj> [k-: react-native would
09:28:29 * hackagebot difftodo 0.2.0 - Generate todo lists from source code  https://hackage.haskell.org/package/difftodo-0.2.0 (jml)
09:28:38 <Fairy> Cale: makes sense, thx ;)
09:29:25 <hoppfull> Can I write kind signatures in my haskell code like with type signatures?
09:29:36 <glguy> Yes using the KindSignatures extension
09:30:09 <ashishnegi> hi.. is there a way to live load the code in haskell ? i have a server and everytime i change it, i need to restart the process.. 
09:30:24 <hoppfull> glguy: Is that an like Template Haskell? I haven't used anything like that yet. Wrote my first line of haskell a week ago.
09:31:13 <Cale> ashishnegi: There are ways to do that, but they generally require a bit of engineering to set up.
09:31:46 <ashishnegi> Cale: can you suggest where i should start looking ?
09:32:52 <Cale> You might look at what xmonad does when you "reload your configuration" -- it's basically building a new copy of the program, serialising all its state to disk, then switching to the new executable, which recovers that state.
09:33:13 <ertes> ashishnegi: one way to fix that is to split your application into multiple processes;  disadvantage: you need to serialise
09:33:43 <Cale> You might also look at hint, which is a wrapper around the GHC API that can load interpreted or compiled Haskell modules and interact with them at runtime.
09:34:05 <ashishnegi> ertes: mine is a very simple app
09:34:38 <ertes> ashishnegi: by eliminating process restart which problem would you like to solve?
09:34:47 <Cale> Note also that it might be difficult to retain open connections
09:35:09 <ashishnegi> Cale: that would be fine.. thanks.
09:35:10 <Cale> If you go with that approach which serialises everything anyway
09:35:22 <glguy> I think you can be clever about preserving open sockets by execing the new process and telling it which file handles correspond to what state
09:35:51 <ashishnegi> ertes: it is really tiresome to keep starting process whenever you change a little code.
09:39:42 <MarLinn> ashishnegi: sounds more like a tiny problem of you development environment or deployment setup to me. Your tools should be able to just handle the restarting for you
09:40:09 <ashishnegi> MarLinn: which tools can help with this.. i use inferno with emacs ?
09:41:14 <ashishnegi> MarLinn: project uses stack .. stack build --fast is what i use to build
09:42:39 <MarLinn> ashishnegi: I have no experience with emacs or inferno. But can't you just add a hook to emacs? I mean you press some key combination to compile, so just have that combination do one extra step
09:43:15 <ashishnegi> MarLinn: makes sense.. restart the process
09:43:30 <MarLinn> exactly
09:46:44 <xuxu> is it common to use comonad's extract function for extracting a value from a monad? 
09:47:06 <[k-> I wanted to create something like this in haskell to js actually https://youtu.be/8E4dspICPJE&t=0m25s
09:47:07 <Cale> xuxu: It's uncommon for something to be both a monad and comonad
09:47:42 <Cale> xuxu: (and even less common for the two structures to agree with each other somehow)
09:49:11 <pjrret433> hi, does anyone know of an ide (editor/whatever) that supports source level debugging of haskell code (highlight the current line, show locals, etc.)?  ideally, cross-platform, but linux-only is okay, too
09:49:24 <xuxu> Cale: interesting. this is my first time to use comonad. i need to extract a value from Maybe a. is it common to extract a value from a monad with extract? 
09:49:48 <ertes> ashishnegi: in that case you should integrate haskell into your development environment…  for example i develop using the interpreter most of the time
09:50:38 <ertes> ashishnegi: i can't help you with inferno (do you mean intero?), but haskell-mode has haskell-interactive-mode built-in
09:51:01 <ertes> ashishnegi: that one integrates a running GHCi into your emacs, such that you can easily reload modules and evaluate expressions in them
09:51:09 <ashishnegi> ertes:  yaa.. haskell is already good most of the time.. it is now the side effect code.. my ui is in elm and websockets on hasekll.. i want to keep debugging some workflow..
09:52:07 <xuxu> pjrret433: i've had a good experience with the haskell-ide plugin for Atom. the intero haskell ide for emacs looks interesting as well. the haskell-ide in atom will highlight the line with problems. syntastic in vim does this as well.
09:52:28 <ertes> ashishnegi: i have no experience with elm, but at least on the haskell side you can make use of this library: https://hackage.haskell.org/package/rapid
09:52:50 <ertes> ashishnegi: it can help you with reloading components in long-running applications during development
09:55:20 <santosha> does anyone have a recommendation for a Haskell plug-in for IntelliJ IDEA?
09:55:54 <santosha> e.g. HaskForce or the jetbrains Haskell plug-in?
10:00:23 <xuxu> I used type holes to come up with a type signature 
10:00:35 <xuxu> However, now I see a fun error that I just didn't expect to see
10:01:15 <pavonia> If you have a function like withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b, what would you call the second argument of that function? Is it a handler?
10:02:07 <xuxu> nevermind, i misread :) ghc's compiler errors are extremely helpful
10:02:18 <amalloy> that seems like a weird type signature. you'll have more than one b, but you're returning only one of them, and you have no functions in scope that can operate on b. which result are you keeping, and which are you throwing away?
10:02:43 <amalloy> also what will you do if the list is empty?
10:03:11 <pavonia> amalloy: You only have one b, the one returned from the inner function
10:03:42 <[k-> but won't the inner function be called multiple times?
10:03:49 <amalloy> oh, it takes a Ptr, so the function is expected to iterate over the array itself
10:05:31 <amalloy> "handler" is a word vague enough to mean nothing, really. you might call it an iterator, since it apparently has to iterate over a number of values. or a consumer
10:06:14 <pavonia> Hhm, the inner function can just do whatever it wants with the Ptr, it don't have to iterate
10:06:22 <pavonia> *doesn't
10:07:43 <amalloy> incidentally, how will the inner function know how many elements are in the pointer array you're presumably building out of the list?
10:08:42 <Fairy> [1,2,3] is actually just syntactic sugar for 1:2:3:[], but what about [ [1,2,3], [1,2,3] ] ?
10:08:56 <amalloy> i don't know Ptr/Storable well, but i don't see any way to use those to create a distinguished value at the end of an array
10:09:10 <amalloy> (1:2:3:[]):(1:2:3:[]):[]
10:09:12 <hydraz> That's (1:2:3:[]):(1:2:3:[]):[]
10:09:22 <hydraz> god damn it
10:09:33 <[k-> ninja'd
10:09:40 <Fairy> ;)
10:10:37 <pavonia> amalloy: You have to pass the length to the inner function another way
10:14:52 <MarLinn> How about... "consumerator"? Or "spell" (it's magic!)? "cat'arr'morphism"? "unArrY"?
10:15:02 <pavonia> with :: Storable a => a -> (Ptr a -> IO b) -> IO b would be another example, perhaps less confusing
10:15:20 <sm> santosha: they are about equivalent
10:16:06 <pavonia> "consuming function" maybe
10:17:44 <xuxu> oh, i don't need to use extract
10:18:29 <xuxu> map (sum . fReturningMaybe) [1,2,3]
10:18:35 <xuxu> the sum will extract the value
10:20:29 <xuxu> it doesn't seem like it's possible to use extract on Just 3 to extract the value 3
10:22:21 <xuxu> lambdabot is talking smack to me
10:22:25 <xuxu> λ :src Control.Comonad.extract Source not found. My pet ferret can type better than you!
10:22:42 <benzrf> @source sdf
10:22:42 <lambdabot> Unknown command, try @list
10:22:44 <benzrf> @src sdf
10:22:44 <lambdabot> Source not found. My brain just exploded
10:23:26 <xuxu> what is the point of extract?
10:23:29 <monochrom> "extract" doesn't make sense for Maybe
10:23:44 <monochrom> "extract" makes sense for Identity, but that's too easy.
10:23:57 <xuxu> there's a good chance i misunderstood its functionality
10:24:24 <xuxu> i thought you could extract values from a monad, and iirc, maybe is a monad?
10:24:31 <xuxu> Maybe*
10:24:41 <monochrom> there is no "extract" for all monads.
10:24:43 <dkasak> xuxu, extract is a method of comonads.
10:24:54 <hydraz> You can extract values from a Comonad, and Maybe isn't one of those.
10:25:11 <glguy> xuxu: 09:46 Cale      : xuxu: It's uncommon for something to be both a monad and comonad
10:25:13 <xuxu> oh okay, it operates on comonads
10:25:55 <xuxu> is there a way for extract the 3 from Just 3?
10:26:01 <glguy> pattern matching
10:26:18 <monochrom> use pattern matching so you explicitly deal with the Nothing case.
10:26:24 <xuxu> strangely i was able to do it with sum and function composition
10:26:33 <monochrom> http://www.vex.net/~trebla/haskell/crossroad.xhtml
10:26:56 <xuxu> map (sum . square) xs where square is (Num a, Eq a, Integral a) => a -> Maybe a
10:27:10 <xuxu> the contraint for square is probably unnecessary
10:28:04 <monochrom> what is square? why does it even dabble in "Maybe"?
10:28:36 <xuxu> i'm working on an exercism exercise which requires a square function to return a Maybe
10:28:45 <opqdonut> Eq a sounds like it's returning Nothing on 0 or something
10:28:47 <opqdonut> :)
10:29:13 <ReinH> How does the exercise indicate that?
10:29:17 <hydraz> Doesn't Num imply Eq?
10:29:21 <monochrom> So what is square?
10:29:41 <xuxu> square x | x == 0 = Nothing | otherwise = Just $ 2 ^ (x - 1) is the function definition without the type class
10:29:54 <opqdonut> (hah, called it)
10:30:05 <hydraz> opqdonut: nice.
10:30:24 <xcmw> Is there any reason not to use megaparsec over parsec?
10:30:26 <amalloy> that doesn't sound like a function that squares
10:30:30 <monochrom> Num used to imply Eq. But there was a change a few years ago.
10:30:33 <xuxu> ReinH: the unit test expects "square 1" to return a Just 1
10:30:38 <hydraz> monochrom: *why*?
10:30:57 <opqdonut> hydraz: consider the "a -> Double" Num instance
10:31:09 <monochrom> To allow more exotic types to be Num without being Eq
10:31:34 <xuxu> i thought Num implied integral, but i guess it doesn't. seems strange to have a generic Num class constraint and an Integral constraint
10:31:38 <monochrom> And I don't mind the change, if you want to know.
10:31:57 <ReinH> Why does that seem strange?
10:32:07 <glguy> Num can't imply Integral since we want Double to be an instance of Num
10:32:13 <ReinH> Some numbers are not integral, but they are still numbers
10:32:26 <opqdonut> xuxu: Integral implies Real which implies Num
10:32:33 <monochrom> But Integral implies Num. (Num a, Integral a) should be redundant.
10:32:48 <MarLinn> xuxu: Integral implies Real; Real implies Num and Ord; Ord implies Eq
10:33:42 <monochrom> the plot thickens. the constraints thinnen.
10:34:05 <hydraz> The superclass chain, otoh, continues baffling
10:34:15 <monochrom> heh
10:34:33 <monochrom> @type sum
10:34:35 <lambdabot> (Foldable t, Num a) => t a -> a
10:35:20 <monochrom> I have doubt about your interpretation of the exercism question, like ReinH did. But meh.
10:36:23 <monochrom> I do witness my 3rd-year computer science students mixing up x^2 with 2^x.
10:36:35 <hydraz> How?
10:36:44 <MarLinn> Maybe the Maybe is supposed to catch overflows? But then it would need a Bounded constraint...
10:37:34 <monochrom> hydraz: Do you mean: How do students mix up x^2 with 2^x?
10:37:44 <hydraz> monochrom: Yes.
10:38:53 <monochrom> I don't know how to answer. But they do. If there is a question talking about powers of 2, they write "x^2". If there is a question talking about squaring, they write "2^x".
10:39:31 <hydraz> That must be disappointing to witness; my condolences.
10:39:47 <mrm> Well, at least they're consistent.
10:40:17 <monochrom> And the best part is, for a question talking about squaring, they write "2^x", and then they go on to say "therefore a square is an even number because 2^x is".
10:40:22 <opqdonut> so just start using ²x syntax?-)
10:40:23 <implementation> remember remember: O(2^x) \subset O(x^2). at least that's what some of my fellow students wrote in their exams.
10:40:45 <ReinH> Instead of calling that function "square", you should call it "banana"
10:40:48 <Cale> monochrom: what... what are you reading?
10:40:53 <ReinH> Because it isn't a banana.
10:40:55 <monochrom> opqdonut: would be find except for the latest addition I just said.
10:40:59 <Cale> oh, homework?
10:41:03 <xuxu> , testCase "total grains" $ 18446744073709551615 @=? i total
10:41:06 <monochrom> s/find/fine/
10:41:13 <xuxu> it doesn't seem like it's calling the function called total
10:41:23 <hydraz> ReinH: :D
10:41:24 <xuxu> i = fromIntegral
10:41:32 <monochrom> Cale, student homework is the hallmark of human creativity
10:41:48 <mrm> Are CS students not required to pass calculus there?
10:42:03 <hydraz> Are CS students not required to pass "6th-grade mathematics" there?
10:42:32 <monochrom> They are required to pass calculus here.
10:42:34 <Cale> "See me after class."
10:42:39 <Cale> lol
10:42:57 <hydraz> That's more baffling than the superclass chain, monochrom.
10:43:29 <xuxu> ReinH: i'm fine with calling it "banana"
10:43:41 <xuxu> it wants me to call it square though
10:44:05 <merijn> hydraz: As someone who's TAed a bunch of classes, including functional programming, I can say that students will never cease to amaze you with their ability to come up with profoundly dumb solutions :)
10:44:17 <ReinH> It has as much to do with square as banana, so I think you misunderstand the assignment.
10:44:40 <hydraz> merijn: So they're programmers in training, then? :P
10:44:58 <xuxu> i have all the tests passing except for the total test case pasted above
10:45:06 <xuxu> expected: 18446744073709551615 but got: -1
10:45:15 <hydraz> Smells like overflow
10:45:19 <xuxu> even though if in ghci i type out my function, it returns that number
10:45:20 <monochrom> All of you who don't have access to student homework, you should read dailywtf.com to widen your horizon on what supposedly-well-educated people could invent.
10:45:23 <merijn> hydraz: Especially ones whose answers look like they're simply a markov chain regurgitating your explanations back to you :p
10:45:27 <xuxu> sum $ map (sum . square) [1..64]
10:45:33 <xuxu> > sum $ map (sum . square) [1..64]
10:45:35 <lambdabot>  error:
10:45:35 <lambdabot>      Variable not in scope: square :: Integer -> [a]
10:45:39 <xuxu> oh right
10:46:15 <glguy> xuxu: 18446744073709551615 is 2^64, use Integer instead of Int
10:46:27 <hydraz> Speaking of the daily WTF, http://thedailywtf.com/articles/the-inner-json-effect
10:46:33 <ReinH> :t sum
10:46:36 <lambdabot> (Foldable t, Num a) => t a -> a
10:46:43 <xuxu> aha! that made the test pass
10:46:50 <xuxu> i'm going to submit this excercise to exercism
10:46:54 <ReinH> Do you know why sum . square works?
10:47:05 <xuxu> then maybe someone here can criticize it in all its dumbness
10:47:12 <glguy> (rather 2^64-1)
10:47:35 <[k-> is the daily wtf safe to be consumed on a daily basis?
10:47:41 <xuxu> http://exercism.io/submissions/08765ddeee08417e87c584572354236c
10:47:50 <hydraz> [k-: not if you value your sanity.
10:48:42 <xuxu> ReinH: i do not, i was planning on using extract, but i accidentally stumbled on this solution
10:48:52 <xuxu> it seems like a hack 
10:49:02 <ReinH> You should figure that out, or you won't have learned anything.
10:49:12 <MarLinn> [k-: If you're not working in the industry, it will make you glad you aren't. If you are, it might keep your hopes for change low.
10:49:15 <ReinH> It is not a hack. You are using it as a hack.
10:49:58 <xuxu> :t sum
10:50:01 <lambdabot> (Foldable t, Num a) => t a -> a
10:50:03 <[k-> > sum [Nothing]
10:50:06 <lambdabot>  error:
10:50:06 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M139733869896...
10:50:06 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
10:50:12 <ReinH> I correct solution arrived at my accident does not teach anything
10:50:20 <ReinH> By
10:50:25 <[k-> > sum [Nothing] :: Int
10:50:26 <ReinH> And A
10:50:29 <lambdabot>  error:
10:50:29 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Maybe a0’
10:50:29 <lambdabot>      • In the expression: sum [Nothing] :: Int
10:50:34 <hydraz> > sum Nothing :: Int
10:50:36 <lambdabot>  0
10:51:06 <xuxu> it operates on something that's foldable and returns some value that's not wrapped in a foldable context. Maybe is a foldable i presume. applying sum Just 3 should give you 3 
10:51:07 <monochrom> If you accidentally invent a solution, that's cool, but you should reverse engineer it to find out why.
10:51:09 <xuxu> > sum Just 3
10:51:12 <lambdabot>  error:
10:51:12 <lambdabot>      • Couldn't match type ‘Maybe a0’ with ‘t0 -> t’
10:51:12 <lambdabot>        Expected type: a0 -> t0 -> t
10:51:31 <xuxu> > sum $ Just 3
10:51:34 <lambdabot>  3
10:51:41 <ReinH> How would you write that without sum?
10:51:43 <xuxu> i guess that's why it works
10:53:28 <Fairy> why does [3,3..10] produce a list of infinite 3's? :S
10:53:57 <xuxu> > 10 / 3
10:53:57 <MarLinn> These function names that are required in the exercise seem to have "industry quality". Almost, but not quite, entirely unrelated to the thing they refer to.
10:53:59 <lambdabot>  3.3333333333333335
10:54:00 <ReinH> Because it starts with a 3, then produces 3s until it produces a 10
10:54:06 <ReinH> Which is never
10:54:31 <xuxu> ReinH: i'm not sure
10:54:43 <[k-> I've seem to have read the daily wtf before
10:54:45 <ReinH> xuxu: then that should be your exercise.
10:54:47 <xuxu> is there such a thing as "impure"? :D
10:54:48 <[k-> maybe from reddit
10:54:55 <xuxu> the opposite of pure
10:55:00 <hydraz> Impure, also known as IO.
10:55:01 <ReinH> xuxu: as we have said, you use pattern matching
10:55:12 <xuxu> ReinH: i tried that
10:55:17 <xuxu> i will continue playing though
10:55:19 <ReinH> Try again
10:55:34 <xuxu> for the record, this is the silliness that is coming from my keyboard
10:55:40 <xuxu> (xa -> a) $ Just 3
10:55:48 <xuxu> (\xa -> a) $ Just 3 -- rather
10:56:18 <hydraz> [k-: Daily WTF posts are regularly on /r/programming; The one I linked hit 258 points a month ago
10:56:24 <ReinH> start with: case xa of
10:57:55 <xuxu> > (\x -> case x of Just x -> x) $ Just 3
10:57:57 <lambdabot>  3
10:58:13 <ReinH> And Nothing?
10:58:14 <hydraz> That's just (\(Just x) -> x) $ Just 3
10:58:38 <xuxu> hydraz: i like that version better
10:58:48 <ReinH> > (\x -> case x of Just x -> x) $ Nothing
10:58:51 <lambdabot>  *Exception: <interactive>:3:8-28: Non-exhaustive patterns in case
10:58:51 <ReinH> Do you?
10:58:57 <hydraz> neither mine nor your version deal with Nothing in a good way
10:58:58 <ReinH> Are you sure?
10:59:05 <maerwald> there's also LambdaCase
10:59:06 <hydraz> > (\(Just x) -> x) Nothing
10:59:09 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
11:00:26 <[k-> Fairy, the difference between 3 and 3 is 0, so to get the next element of the list, haskell adds 0 to 3 to get 3 again, never getting to 10
11:00:36 <[k-> that's how the infinite list is generated 
11:02:12 <xuxu> you could do something like this
11:02:15 <xuxu> let descence x
11:02:18 <xuxu>   | Just x = x
11:02:21 <xuxu>   | otherwise = Nothing
11:02:27 <xuxu> descend*
11:02:47 <xuxu> the first guard won't match
11:02:54 <[k-> for [1,3..9] haskell adds (3-1)=2 to 3, then 2 again amd again until it gets to 9
11:03:00 <xuxu> i prefer guards to case statement for some reason
11:03:21 <hydraz> is that even valid?
11:03:25 <[k-> xuxu you could just pattern match 
11:03:25 <xuxu> no
11:03:53 <xuxu> [k-: oh, a function definition with pattern matching! i forgot about that
11:04:08 <hydraz> What you want is "descend (Just x) = x\ndescend _ = Nothing" (where \n is a literal newline in your program test), but that's just join for the Maybe monad
11:04:11 <[k-> that's what they have been hinting all along 
11:04:20 <hsk3> Why aren't there Functor and Traversable instances for the tuples?
11:04:22 <hsk3> fmap (+1) (1,2,3)
11:04:25 <hsk3> fails
11:04:57 <xuxu> hsk3: a tuple can contain multiple different types of values
11:05:16 <hsk3> a shit of course lol
11:05:18 <hsk3> thanks
11:05:20 <xuxu> fmap (+1) (1, Yellow, [1,2,3]) -- doesn't seem right :)
11:05:25 <[k-> :t maybe -- xuxu
11:05:31 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:05:40 <hydraz> ^ that
11:05:42 <maerwald> xuxu: that's not the problem
11:05:44 <MarcelineVQ> well, there's Functor for (,) so it's not unreasonable
11:05:56 <MarcelineVQ> but (,,) isn't quite as commonly used
11:06:00 <maerwald> > fmap (+1⁾) ("abc", 3)
11:06:02 <lambdabot>  <hint>:1:9: error: lexical error at character '\8318'
11:06:03 <monochrom> I can envision fmap (+1) (1,2,3) = (1,2,4).
11:06:13 <hydraz> > fmap (+1) ("herp", 1)
11:06:16 <lambdabot>  ("herp",2)
11:06:19 <[k-> it's either you use maybe or you pattern match
11:06:57 <maerwald> monochrom: yeah, but I'd say that's not even what he expect of the functor instance
11:07:05 <maerwald> and I agree the functor instance of tuples is not that useful
11:08:29 <xuxu> hydraz: the returned value in "descend (Just x) = x\ndescend _ = Nothing" doesn't seem to line up since x might be an Int and Nothing is a Maybe
11:08:46 <xuxu> [k-: thank you 
11:08:47 <monochrom> This is why descend is a bad idea.
11:09:42 <monochrom> I don't understand why the avoidance of pattern matching.
11:10:00 <monochrom> To the desperate extent that "I can hide it behind a named function!"
11:10:42 <monochrom> Fully knowing that "f (Just x) = e1; f Nothing = e2" is syntax sugar for f = \v -> case v of Just x -> e1; Nothing -> e2
11:11:52 <monochrom> if anything, the "maybe" function already does that for you, you shouldn't be writing yet another one.
11:15:00 <MarLinn> But if you're explicitly pattern matching, aren't you writing "another version of maybe" in a way?
11:15:33 <monochrom> yes absolutely.
11:16:53 <[k-> (there is also fromJust but fromJust is partial and gives weird errors on Nothing, pattern matching/maybe is much better)
11:16:56 <MarLinn> I don't know about others, but my own instinctive aversion against pattern matching stems from that feeling of duplication, from an unhealthy obsession with "short" code and from a trained aversion against branching, because branching is an enemy of performance. Is it a sensible aversion? Hell no.
11:17:23 <ReinH> pattern matching is the only way anything gets done
11:17:59 <ReinH> it's completely non-sensible to have an aversion to it
11:18:12 <ReinH> Haskell is fundamentally a pattern matching language
11:18:59 <monochrom> "maybe e2 (\x -> e1)" is slightly shorter than the case equivalent
11:19:03 <glguy> "maybe" is useful because it can produce a function for working with Maybe a values that you can pass around, not because it avoids pattern matching explicitly
11:19:09 <ReinH> xuxu, hsk3: There *can't* be a Functor isntance for (,) or (,,)
11:19:27 <glguy> maybe z f <$> something
11:19:28 <ReinH> That would be a kind mismatch
11:19:40 <monochrom> If your (\x -> e1) function can be written in pointfree form, "maybe e2 fff" is certainly shorter.
11:20:14 <ReinH> maybe is the canonical fold for Maybe
11:20:16 <MarcelineVQ> Oh that's right, thank you ReinH, it's (a,) that has a functor yeah?
11:20:20 <ReinH> (,) a, yes
11:20:46 <monochrom> However, if you plan to write (\x -> e1) in  pointful form, and if e1 is really long, maybe isn't all that better than case.
11:21:24 <[k-> maybe e2 id, perhaps 
11:21:25 <monochrom> because case encourages you to lay out things nicely, and you could use a lot of laying out when e1 is long.
11:21:30 <MarcelineVQ> If you're in love with guards you can use pattern guards, but it's not any different than case for something like Maybe, foo x | (Just x') <- x = x' | otherwise = "nothing"
11:21:34 <benzrf> is there a way to make this work:
11:21:36 <benzrf> pattern PairOf x = $(pairOf [p| x |])
11:21:42 <benzrf> er, i guess that should be <- and not =
11:21:54 <ReinH> Instead of preferring guards to patterns, you should prefer patterns to guards
11:21:58 <ReinH> patterns are fundamental, guards are not
11:22:17 <ReinH> guards often incur an Eq constraint, since you need a way to produce a Bool from your values
11:22:19 <MarLinn> [k-: maybe f id == fromMaybe f
11:22:41 <ReinH> If you understand how pattern matching works, you will understand 99% of Haskell
11:22:58 <ReinH> If you understand how guards work, you will understand only how guards work
11:23:13 <monochrom> But the other 1% of Haskell will take you 99% of your time to understand
11:23:19 * hackagebot timespan 0.1.0.0 - Useful timespan datatype and functions  https://hackage.haskell.org/package/timespan-0.1.0.0 (AlexanderThiemann)
11:23:21 * hackagebot octane 0.16.0 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.16.0 (fozworth)
11:23:23 * hackagebot cplex-hs 0.3.0.0 - high-level CPLEX interface  https://hackage.haskell.org/package/cplex-hs-0.3.0.0 (stefanjhlk)
11:23:24 <ReinH> monochrom: probably true
11:23:40 <MarcelineVQ> the onepercenter's burden
11:23:41 <[k-> oo there's fromMaybe?
11:25:03 <MarLinn> [k-: it's in Data.Maybe
11:25:42 <[k-> I hoogle'd it 
11:26:33 <hsk3> how can I apply [f, g] to [a, b] to produce [f a, g b] ?
11:26:36 <hsk3> is there a common pattern for that?
11:26:51 <MarcelineVQ> zipWith ($) I think
11:27:09 <benzrf> is it possible to get quasiquoter syntax for things that dont do string parsing
11:27:24 <benzrf> e.g. can i somehow abbreviate $(foo [| stuff here |]) to something like [foo| stuff here|]
11:27:46 <hsk3> MarcelineVQ: that works thanks
11:29:11 <xuxu> monochrom, ReinH: i wasn't trying to avoid pattern matching. i'm just kind of new and still getting familiar with solving problems with that technique
11:29:18 <xuxu> thank you for your patience!
11:41:32 <elliptic00> I try to define a function to read a file name and return a list of string 
11:41:34 <elliptic00> readFileToList1::FilePath->String 
11:41:34 <elliptic00> readFileToList1 f = readFile f >>= \contents   
11:41:52 <elliptic00> I keep getting error, anyone could help?
11:41:59 <ReinH> A String or a list of string?
11:42:11 <ReinH> because your function returns a String, not a list of string
11:42:31 <elliptic00> readFile f return String?
11:42:40 <ReinH>  readFileToList1 does
11:42:42 <monochrom> the "\contents" part looks like either a syntax error or incomplete
11:42:42 <ReinH> because you said that it does
11:43:23 <ReinH> so first you want to make your type match what you said
11:43:29 <glguy> readFileToList1 would have type FilePath -> IO [String]   or similar
11:43:45 <ReinH> And it also must be IO
11:44:02 <ReinH> you can't write a function that reads a file and returns a String or a [String]
11:44:31 <elliptic00> do I have to return some IO type?
11:44:41 <ReinH> yes, because you are performing IO
11:45:23 <elliptic00> can I unwrap the IO type inside the funtion and return it?
11:45:28 <Gurkenglas> What's a good way to insert haddock into a latex paper? (and perhaps expand upon it)
11:45:29 <ReinH> That's what >>= does.
11:45:34 <monochrom> there is no unwrap.
11:45:56 <ReinH> >>= provides you with the value on the condition that you put it back in IO when you're done
11:46:00 <Cale> elliptic00: Your function is producing a description of what should be done
11:46:01 <elliptic00> we can do  type <- action?
11:46:07 <ReinH> Yes, that is >>=
11:46:10 <Cale> Not an actual String (or list of strings)
11:46:19 <monochrom> Instead of telling you there is no way to unwrap, I should also tell you: There is no need, you will never need it.
11:46:22 <Cale> But a description of some steps which could be carried out to get some
11:46:33 <Cale> It wouldn't be "unwrapping"
11:46:33 * ReinH shrugs
11:46:34 <MarcelineVQ> 3 cooks, one dish, what flavor will result
11:46:42 <ReinH> Wadler calls it unwrapping in this context, so I am going to call it unwrapping in this context
11:47:04 <Cale> It would be misleading to do so though...
11:47:06 <elliptic00> I try to do  str <- readFile fname; return str
11:47:21 <monochrom> That will give you FilePath -> IO String
11:47:22 <ReinH> That is just readFile fname, but it does type check.
11:48:00 <elliptic00> ok, very helpful..
11:48:01 <Cale> elliptic00: Yeah, a do-block lets you describe a more complicated IO action in terms of the results of smaller ones.
11:48:10 <monochrom> You know, I don't refrain from picking on Wadler for saying "strict vs lazy" either.
11:48:55 <monochrom> Hell, nevermind Wadler, I even pick on Bird for that.
11:49:09 <Cale> elliptic00: It might be helpful to think of the difference between an IO String and a String as being like the difference between /bin/ls and a list of the files in your home directory.
11:49:53 <elliptic00> nice Analogy :)
11:50:04 * glguy is crushed to discover that /bin/ls doesn't contain a list of the files on his computer
11:50:20 <ReinH> glguy: it contains all of them!
11:50:23 <ReinH> at the same time
11:50:47 <ReinH> and a complex interface for sorting and displaying them, because the unix philosophy is to do one thing and do it well
11:50:49 <ongy> ReinH: that would be /dev/sda (for some settings)
11:50:51 <ReinH> and there is already sort
11:51:01 <Cale> It contains a list of the files on *my* computer. Pls no snooping.
11:51:01 <ReinH> which you can't use with ls
11:51:22 <monochrom> clearly, /bin/ls contains RealWorld#
11:52:26 <ggole> The unix philosophy is a great idea.
11:52:39 <ggole> It would be nice if an operating system were to actually achieve it.
11:52:47 <monochrom> I prfer the linux philosophy.
11:52:48 <david`> hi I'm having a bit of trouble starting a stack project. It's a brand new stack project except I've changed to a nightly build and I get the error "Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1". I get the same error with nightlys a way back and even after I've run stack upgrade -git. Any ideas what this is being caused by?
11:53:32 <MarcelineVQ> did you run stack setup?
11:54:04 <glguy> david`: put your stack.yaml on http://lpaste.net
11:54:05 <MarcelineVQ> currently nightly changes the compiler
11:54:18 <glguy> sounds like a syntax mistake is leading to a bunch of packages being treated as a single string
11:55:27 <david`> yea I did but it said it was going to use the GHC in my path, I'll try setting system-ghc to false
11:56:49 <david`> and http://lpaste.net/188887 is my Relation.stack file
11:57:32 <glguy> That seems OK, what about the .cabal file?
11:57:48 <lyxia> oh you almost won lpaste number 188888
11:58:00 <david`> I'm trying to do an implementation of Lennart Augustsson typed relational algebra paper for GHC, and nice!
11:58:49 <david`> cabal file is http://lpaste.net/188889
11:59:18 <monochrom> haha lyxia
11:59:52 <ongy> 2 close misses
12:00:14 <ReinH> what command are you running and what is the complete error message?
12:00:32 <glguy> david`: What version of stack?
12:00:59 <glguy> david`: If it's less than 1.1.2 you probably need to upgrade and it would then be related to this I think https://github.com/commercialhaskell/stack/issues/1758
12:01:08 <glguy> GHC 8 changed the package ID format
12:01:25 <david`> stack ghci or stack build and the full message is "Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1"" and the stack --version "Version 0.1.5.0 X86_64"
12:01:40 <glguy> Yeah, time to upgrade stack
12:09:54 <david`> ah cool, I'll give that a go
12:22:34 <benzrf> aww what the fuuck
12:22:58 <benzrf> i was trying to play around with writing a template haskell thingy for crappy nonlinear patterns
12:23:20 * hackagebot xdcc 1.1.3 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.1.3 (JanGerlinger)
12:23:22 * hackagebot servant-github-webhook 0.1.0.0 - Servant combinators to facilitate writing GitHub webhooks.  https://hackage.haskell.org/package/servant-github-webhook-0.1.0.0 (tsani)
12:23:31 <benzrf> but apparently ghc shoots down nonlinear patterns at parse time, so i can't do $(nonlinear [p| (x, x) |])
12:23:43 <benzrf> lame!
12:24:49 <david`> thanks everyone, I had an ancient version of stack hiding in my ~/.cabal folder. Confused the hell out of me. Making the move from Mu to GHC is hard :)
12:43:19 <soLucien> hi guys ! I have a list and i want to iterate over 2 items at a time
12:43:26 <soLucien> is there any short way of doing it ?
12:43:41 <soLucien> as in : i want to get both x and x+1 in my iterator
12:44:05 <jonored> I think zip a (drop a) will do you there.
12:44:34 <jonored> tail a I think, actually.
12:45:06 <jonored> > let a = [1..5] in zip a (drop a)
12:45:08 <lambdabot>  error:
12:45:08 <lambdabot>      • Couldn't match expected type ‘[b]’
12:45:08 <lambdabot>                    with actual type ‘[a0] -> [a0]’
12:45:13 <jonored> > let a = [1..5] in zip a (tail a)
12:45:16 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
12:45:38 <soLucien> great , thanks a lot !
12:45:40 <dmj> > chunksOf 2 [1..10]
12:45:43 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
12:47:30 <dmj> > map (\[x,y] -> show x ++ "&" ++ show y)) -> chunksOf 2 [1..10 :: Int]
12:47:33 <lambdabot>  <hint>:1:40: error: parse error on input ‘)’
12:47:43 <dmj> > map (\[x,y] -> show x ++ "&" ++ show y)) $ chunksOf 2 [1..10 :: Int]
12:47:46 <lambdabot>  <hint>:1:40: error: parse error on input ‘)’
12:48:00 <dmj> > map (\[x,y] -> show x ++ "&" ++ show y) $ chunksOf 2 [1..10 :: Int]
12:48:03 <lambdabot>  ["1&2","3&4","5&6","7&8","9&10"]
12:48:09 <jonored> soLucien: Whether you want chunksOf or top zip the list with itself offset by one is, of course, dependent on what you're trying to do.
12:54:00 <MarLinn> > let a = [1..5] in zip a (tail a) -- oups
12:54:02 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
12:54:11 <MarLinn> > let a = [] in zip a (tail a) -- that's what I meant
12:54:13 <lambdabot>  []
12:54:56 <MarLinn> Mh. I expected it to fail. Think, then write...
12:55:24 <monochrom> zip probably goes like "zip [] _ = []" so it never spots the problem with tail [].
12:57:33 <glguy> zip is documented as "zip is right-lazy:"
12:58:23 <MarLinn> > (zip [] undefined, zip undefined []) -- but only right-lazy, apparently
12:58:25 <lambdabot>  ([],*Exception: Prelude.undefined
12:58:32 <monochrom> saved by laziness.
12:58:45 <hydraz> As is often the case
12:59:10 <monochrom> I once tried to prove that Haskell will not allow you both left-nonstrictness and right-nonstrictness.
13:00:42 <hydraz> When laziness isn't saving you, however, it's coming back to bite you in the ass
13:02:43 <MarLinn> sound like an interesting exercise to develop a language that can be lazy in every subset of arguments simultaneously
13:03:38 <dmj> can I get access to the pointer that references an immutable vector on the heap
13:09:23 <glguy> dmj: Vectors are pinned, so such a pointer would only be good until the next GC
13:09:24 <monochrom> dmj: The API allows it for Data.Vector.Storable. Find its doc and scroll to the bottom.
13:09:26 <glguy> aren't*
13:12:10 <dmj> glguy: that should be fine, these vectors don't last long, The ones that do will be in an IORef, so the GC would probably keep it around
13:13:49 <dmj> monochrom: this seems to be exactly what I want
13:13:51 <dmj> unsafeWith :: Storable a => Vector a -> (Ptr a -> IO b) -> IO b
13:14:12 <dmj> "Pass a pointer to the vector's data to the IO action. The data may not be modified through the 'Ptr."
13:15:18 <dmj> except I want to mutate the vector via the ptr
13:15:28 <dmj> so I assume you can... but not sure why the docs would say that
13:16:24 <dmj> isn't that the whole piont
13:16:27 <dmj> s/piont/point
13:16:48 <glguy> No, the point is to allow you to export the contents of the immutable vector for reading via the FFI
13:17:05 <glguy> There's a separate type for mutable, storable vectors
13:20:26 <dmj> glguy: I need the vector the be pure though, but operations on it impure.
13:20:58 <dmj> glguy: The PrimMonad constaint would violate break certain typelass instances
13:21:00 <dmj> constraint*
13:21:33 <dmj> I guess I could try ST...
13:22:02 <dmj> in those instances that need purity
13:23:21 * hackagebot hs-di 0.2.0 - Dependency Injection library for Haskell  https://hackage.haskell.org/package/hs-di-0.2.0 (Wizek)
13:23:23 * hackagebot hs-di 0.2.1 - Dependency Injection library for Haskell  https://hackage.haskell.org/package/hs-di-0.2.1 (Wizek)
13:23:48 <Welkin> hi dmj 
13:29:24 <elliptic00> anyone know what is the difference between unwords and unlines?    when I do :info unwords and unlines, it shows the same signature of their function
13:29:45 <glguy> elliptic00: Check out the documentation for the two
13:30:23 <elliptic00> :info unlines
13:30:23 <elliptic00> unlines :: [String] -> String
13:30:23 <elliptic00>   	-- Defined in ‘base-4.8.2.0:Data.OldList’
13:30:25 <elliptic00> > :info unwords
13:30:27 <elliptic00> unwords :: [String] -> String
13:30:29 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:30:29 <elliptic00>   	-- Defined in ‘base-4.8.2.0:Data.OldList’
13:31:03 <elliptic00> They have the same signature
13:31:10 <Welkin> alljust use them
13:31:17 <Welkin> the type won't alays tell you the details
13:31:23 <glguy> No, the documentation is at https://hackage.haskell.org/package/base
13:31:47 <Welkin> > unwords ["你", "好"]
13:31:50 <lambdabot>  "\20320 \22909"
13:32:03 <Welkin> damn you
13:32:19 <Welkin> > putStrLn $ unwords ["你", "好"]
13:32:22 <lambdabot>  <IO ()>
13:32:23 <elliptic00> Thanks, I just saw the doc.
13:32:37 <elliptic00> you are good at Chinese..
13:32:45 <Welkin> why is it showing the codepoint?
13:32:54 <Welkin> what is lambdabot doing to it
13:33:00 <glguy> Because the codepoints are outside the range of 0x20-0x7e
13:33:14 <glguy> > text (unwords ["你", "好"])
13:33:17 <lambdabot>  你 好
13:33:33 <Welkin> oh, I have never seen `text`
13:33:35 <Welkin> :t text
13:33:37 <lambdabot> String -> Doc
13:33:42 <Welkin> oh, a pretty printer
13:33:44 <elliptic00> are you guys are Chinese?
13:33:47 <Welkin> nope
13:34:12 <elliptic00> it seems to me  u know some Chinese
13:34:28 <Welkin> yes
13:34:53 <elliptic00> where u from?.. if u d't mind to answer it
13:35:14 <Welkin> 美国
13:35:56 <XV17> Hello
13:36:01 <suzu_> i
13:36:03 <suzu_> hi
13:36:36 <XV17> New to IRC's, any tips?
13:36:48 <Welkin> XV17: join #freenode for irc help
13:56:02 <vapid> > unwords "epic"
13:56:04 <lambdabot>  error:
13:56:04 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
13:56:04 <lambdabot>        Expected type: [String]
13:56:47 <vapid> > map (:) [1, 2]
13:56:49 <lambdabot>  [<[Integer] -> [Integer]>,<[Integer] -> [Integer]>]
13:57:06 <vapid> > map 5 $ map (:) [1, 2]
13:57:09 <lambdabot>  error:
13:57:09 <lambdabot>      • Could not deduce (Num a0)
13:57:09 <lambdabot>        from the context: (Num (([a] -> [a]) -> b), Num a)
13:57:25 <vapid> .
13:57:41 <glguy> You can experiment with lambdabot using /msg
13:58:03 <vapid> but then nobody else will see me fail
13:58:14 <glguy> You're catching on!
13:58:18 <Welkin> lol
14:14:37 <Wizek> Are there people here who like unit testing, mocking, dependency injection? There is a new project of mine about which I'd be curious to hear some feedback: https://github.com/Wizek/hs-di I'm looking to find at least one other person who can get excited about the potential of these three techniques in Haskell, someone who could be interested in discussing details of this project and related questions.
14:20:14 <soLucien> what would i have to change to get this to work ? toXML :: [Point] -> String
14:20:14 <soLucien> toXML c = intercalate "" ( toXML' ( c in zip c (tail c) ) )
14:20:25 <soLucien> i get an error at the "in"
14:20:31 <soLucien> however, it works in the REPL
14:21:58 <dmj> soLucien: check out concatMap
14:22:25 <dmj> soLucien: you need to add a let binding it seems
14:25:32 <soLucien> dmj still a synthax error ..
14:25:41 <athan> Anyone here know why repa-algorithms uses Double monomorphically?
14:25:59 <dmj> soLucien: can you paste your code on http://lpaste.net
14:26:01 <athan> monomorphic being used as "concrete type" here, not CT related :)
14:26:12 <glguy> soLucien: This doesn't mean anything: ( c in zip c (tail c) )
14:26:20 <glguy> You'll have to explain what you thought that does
14:26:20 <soLucien> http://lpaste.net/3734870278900023296
14:27:49 <soLucien> i could use Chunksf 2 instead
14:28:28 <soLucien> chunksOf
14:29:00 <jonored> soLucien: They do different things, and you look like you're trying to do either "zip c (tail c)" or "(\c-> zip c (tail c))", depending on whether c is a variable you've already got bound.
14:29:53 <jonored> the zip and tail gives you a list where every element has a turn as both the first and the second element, while chunksOf every odd element is a first, and every even element is a second.
14:30:27 <soLucien> ok .. the idea is this : i have a curve , which is an array of points
14:30:35 <soLucien> i want to write it to a svg file
14:30:50 <soLucien> so i need to iterate through the points with a iterator of size 2
14:30:52 <jonored> So in toXML c = you're already binding the list to the name c, so you don't need the "c in" part at all.
14:31:42 <soLucien> it doesn't compile Couldn't match expected type `(Point, Point)'
14:31:42 <soLucien>  with actual type `[(Point, Point)]'
14:31:53 <soLucien> if i do intercalate "" ( toXML' ( zip c (tail c) ) )
14:32:14 <soLucien> that is why i was trying to use the 'in'
14:32:36 <dmj> soLucien: there is no 'in' w/o let <name> = <val> 
14:32:45 <jonored> let x in <thing that references x> is just defining a local variable.
14:32:46 <soLucien> true ..
14:39:11 <amalloy> let x in thing doesn't do anything; let x = y in thing actually creates a local
14:40:51 <jonored> soLucien: So, a question: do you want each point to show up once, or twice?
14:41:34 <soLucien> twice . points are nodes, i'm constructing edges
14:41:50 <soLucien> so zip c (tail c)
14:42:14 <jonored> toXML' takes a pair of points?
14:42:27 <soLucien> yes .. and constructs a xml node out of them
14:42:46 <jonored> You're trying to give it the whole list; you need map.
14:42:46 <soLucien> xml element
14:43:49 <soLucien> still not working :(
14:44:27 <soLucien> http://lpaste.net/3734870278900023296
14:45:11 <jonored> are you just doing intercalate to concatenate the results?
14:45:16 <soLucien> yes
14:45:44 <soLucien> i am sure there's a better way, but is it possible to fix this one ?
14:45:53 <athan> How do I supply default RTS options from Cabal? Isn't it with the flag `ghc-options: -threaded -rtsopts=...`?
14:45:58 <jonored> Ah, that's not how map works, sorry. map takes a function and a list, and applies the function to the members of the list.
14:46:10 <jonored> map toXML' (zip ...
14:46:12 <soLucien> i know .. i need something like an aggregator
14:46:33 <soLucien> no , that does not work, jonored..
14:46:41 <soLucien> that was the first thing i tried
14:47:40 <soLucien> zip c tail c returns (Point, Point) and intercalate needs [(Point, Point)]
14:47:45 <jonored> but you probably want concatMap, as dmj pointed out, if you want to run the members of the list through toXML' and concatenate the results.
14:47:48 <soLucien> so i want to aggregate them into an array
14:47:52 <geekosaur> athan, -with-rtsopts="..."
14:48:10 <athan> ahh, thanks geekosaur!
14:48:18 <geekosaur> -rtsopts just enables end user rts options that are considered potentially "dangerous"
14:49:06 <athan> +RTS -N0 :D
14:49:20 <jonored> :t zip
14:49:22 <lambdabot> [a] -> [b] -> [(a, b)]
14:49:44 <athan> +RTS -N0 :D
14:49:46 <dmj> glguy: unsafeWith works /great/ :)
14:49:46 <athan> erp, sorry
14:49:47 <jonored> soLucien: zip has no way to produce a (Point, Point) - it always produces a list of pairs.
14:50:23 <jonored> So something is mixed up if it's looking like it isn't :)
14:51:03 <amalloy> concat $ zipWith (curry toXML') c (tail c)
14:52:38 <glguy> soLucien: intercalate "" is just  concat
14:52:44 <glguy> You need to map toXML' over the list
14:53:06 <glguy> the combination of concat and map is concatMap
14:53:13 <glguy> toXML c = concatMap toXML' (zip c (tail c))
14:53:43 <ReinH> @quote aztec
14:53:44 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
14:53:45 <soLucien> amalloy's line worked, thanks a lot
14:53:53 <soLucien> now i just have to figure out
14:53:56 <soLucien> what it's doing
14:54:10 <soLucien> and how to come up with the same kind of things myself
14:54:13 <ReinH> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:54:16 <lambdabot>  <no location info>: error:
14:54:16 <lambdabot>      not an expression: ‘let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)’
14:54:20 <ReinH> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
14:54:23 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:54:31 <ReinH> Stare at that one for a while :)
14:54:48 <soLucien> Haskell is intimidating
14:55:02 <ReinH> Here's a nice explanation of how that works http://jelv.is/blog/Lazy-Dynamic-Programming/
14:55:10 <ReinH> in the context of dynamic programming, of which that is an example
14:55:38 <ReinH> soLucien: it sure can be
14:55:46 <amalloy> i think trying to introduce tying the knot will just make it harder to get the idea of zipWith
14:56:02 <ReinH> Well, you are tying the knot
14:56:31 <ReinH> > zipWith (+) [0,1,1,2] [1,1,2,3]
14:56:33 <lambdabot>  [1,2,3,5]
14:56:52 <amalloy> my understanding is that "tying the knot" refers to self-recursive data structures
14:57:02 <ReinH> which this is
14:57:30 <amalloy> no, zipWith is a recursive function, but it doesn't create a data structure that refers to itself
14:57:43 <ReinH> In this case, it does
14:57:48 <amalloy> how so?
14:57:52 <soLucien> so this would be written in 2 lines if using zip ?
14:57:52 <ReinH> in the case of fibs
14:57:52 <monochrom> look at "fibs =  .... fibs ...." again.
14:57:52 <amalloy> i mean, for fibs obviously yes
14:57:55 <amalloy> but that was my point
14:57:56 <ReinH> ok
14:58:04 <amalloy> don't introduce this fibs example because it confuses zipWith
14:58:08 <ReinH> amalloy: fair point
14:58:46 <soLucien> gotta get back to LYAH .. i suck at this :D
14:58:54 <ReinH> soLucien: with zip, you create a tuple and then you can map over that tuple to apply a function to each element
14:59:23 <ReinH> so you might say map toXML' (zip c (tail c))
15:00:32 <ReinH> zipWith does away with the extra step of building and using the tuple, and just applies the function directly
15:00:36 <soLucien> that is more understandable for me
15:00:48 <ReinH> > zipWith (+) [1,2,3] [1,2,3]
15:00:51 <lambdabot>  [2,4,6]
15:01:01 <zell> > let fibs = 1 : scanl (+) 1 fibs in take 5 fibs
15:01:03 <lambdabot>  [1,1,2,3,5]
15:01:34 <ReinH> > map (uncurry (+)) (zip [1,2,3] [1,2,3])
15:01:37 <lambdabot>  [2,4,6]
15:01:51 <ReinH> Or, if uncurry is confusing,
15:02:03 <ReinH> > map (\(x,y) -> x + y) (zip [1,2,3] [1,2,3])
15:02:06 <lambdabot>  [2,4,6]
15:03:52 <zell> But it factors out the additional traversal of the map, right? I mean does it do uncurry (+) while it zips?
15:04:02 <ReinH> zell: there is no additional traversal
15:04:23 <zell> because ghc does that automatically?
15:04:36 <ReinH> No, it is not an optimization
15:04:41 <ReinH> it is the behavior of lazy evaluation
15:05:30 <zell> So map asking for an argument progresses zip to evaluate it's next element
15:05:34 <ReinH> > let xs = [1..] in take 5 $ map (uncurry (+)) (zip xs xs)
15:05:37 <lambdabot>  [2,4,6,8,10]
15:05:55 <ReinH> That can't work if map has to retraverse the list
15:06:01 <ReinH> since it would never have gotten to the end of the first traversal
15:06:03 <ReinH> @where lazy
15:06:04 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
15:06:24 <ReinH> @src map
15:06:24 <lambdabot> map _ []     = []
15:06:24 <lambdabot> map f (x:xs) = f x : map f xs
15:06:33 <amalloy> zell: yes, when map needs a list element to call f on, that is when zip produces a tuple
15:06:45 <amalloy> so the two of them progress in parallel
15:06:51 <ReinH> map f demands either a [] or a (:) from its argument
15:07:50 <zell> Wow it's cool how zip makes this kind of simultaneous parallel traversal lazy
15:07:53 <ReinH> it recurses on xs, which demands another [] or (:)
15:08:13 <ReinH> Haskell does this everywhere by nature
15:08:18 <athan> Is -O2 no longer a compile flag for ghc 8?
15:08:39 <saurabhnanda> need help with opaleye, please. can anyone please look at https://github.com/tomjaguarpaw/haskell-opaleye/issues/205
15:08:59 <ReinH> The *optimization* that GHC performs, called fusion or deforestation, is to optimize away the construction of extra (:) inside the loop.
15:09:37 <monochrom> -O2 is still a compiler flag for ghc 8.
15:09:53 <athan> thanks monochrom, didn't see it in --show-options though :s
15:10:09 --- mode: ChanServ set +o glguy
15:10:09 --- mode: glguy set -q *!*@188.29.165.62.threembb.co.uk
15:10:49 <ReinH> @src zip
15:10:50 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:10:50 <lambdabot> zip _      _      = []
15:11:07 <ReinH> zell: zip likewise only demands a single (:) at a time from arguments, and recurses on the tails.
15:11:15 <monochrom> athan, ghc 7.10's --show-options doesn't list -O2 either.
15:11:45 <zell> Wow the post doc bit of the evolution of the Haskell programmer is cool
15:11:49 <monochrom> at which point I feel safe to hypothesize: the "2" is considered a parameter
15:12:07 <monochrom> just like it would list "-i" but not "-imydir"
15:12:49 <zell> Does deforestation give faster last?
15:12:52 <athan> oh hm, good point
15:12:55 <zell> :t last
15:12:58 <lambdabot> [a] -> a
15:13:00 <ReinH> zell: and zip produces a value whose outermost structure is a (:) constructor
15:13:01 <ReinH> @src foldl
15:13:02 <lambdabot> foldl f z []     = z
15:13:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:13:13 <ReinH> @src foldr
15:13:14 <lambdabot> foldr f z []     = z
15:13:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:13:19 <ReinH> > foldr (:) [] [1,2,3]
15:13:21 <lambdabot>  [1,2,3]
15:13:31 <ReinH> with foldr, the outermost thing is f
15:13:35 <ReinH> with foldl, the outermost thing is foldl
15:13:44 <ReinH> so we can say:
15:13:53 <ReinH> > take 10 $ foldr (:) [] [1..]
15:13:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:14:09 <ReinH> because foldr produces a (:) immediately, which can be consumed by take
15:14:22 <ReinH> > take 10 $ foldl (flip (:)) [1..]
15:14:25 <lambdabot>  error:
15:14:25 <lambdabot>      • Couldn't match expected type ‘[a]’
15:14:25 <lambdabot>                    with actual type ‘[Integer] -> [Integer]’
15:14:27 <ReinH> woops
15:14:29 --- mode: glguy set -o glguy
15:14:34 <ReinH> > take 10 $ foldl (flip (:)) [] [1..]
15:14:42 <lambdabot>  mueval: ExitFailure 1
15:14:50 <ReinH> but foldl can't produce a (:) until it finishes evaluating all its recursive calls to foldl
15:15:14 <ReinH> so we say that foldr is "productive", or that its recursion is "guarded" because the recursion happens inside a constructor which can be pattern matched
15:15:17 <ReinH> while foldl is not
15:15:21 <zell> foldl sucks
15:15:32 <zell> I finally get it thanks
15:15:41 <zell> Outermost thing huh
15:15:52 <ReinH> Haskell's evaluation happens outside-in
15:16:01 <ReinH> known as "leftmost-outermost reduction"
15:16:21 <zell> (lambdabot) foldr f z (x:xs) = f x (foldr f z xs)
15:16:42 <zell> So the f here is (:) which can be pattern matched
15:16:45 <ReinH> right
15:16:49 <zell> Woot
15:16:52 <ReinH> if f were not a constructor, it wouldn't be productive
15:17:18 <ReinH> That's not true
15:17:19 <ReinH> sorry
15:17:25 <ReinH> if f demands its second argument
15:17:27 <ReinH> e.g.,
15:17:37 <ReinH> > foldr (||) True (repeat False)
15:17:37 <zell> Guarded by lazy evaluation recursing on (:)
15:17:44 <lambdabot>  mueval-core: Time limit exceeded
15:17:55 <ReinH> woops
15:18:00 <zell> lol
15:18:37 <ReinH> brain fart
15:19:04 <ReinH> > foldr (||) False (repeat True)
15:19:06 <lambdabot>  True
15:19:20 <zell> wowza
15:19:55 <ReinH> Compare:
15:19:59 <ReinH> > False || True
15:20:02 <lambdabot>  True
15:20:03 <ReinH> > False `max` True
15:20:06 <lambdabot>  True
15:20:12 <ReinH> > foldr max False (repeat True)
15:20:15 <lambdabot>  *Exception: stack overflow
15:20:18 <ReinH> So what's the difference?
15:20:33 <zell> @src max
15:20:33 <lambdabot> max x y = if x <= y then y else x
15:20:47 <ReinH>  @src sometimes lies
15:20:51 <ReinH> Well, in this case, it does not
15:20:56 <ReinH> but the important thing is how (<=) is defined.
15:20:58 <ReinH> for Boo,.
15:21:00 <ReinH> Bool
15:21:23 <ReinH> @src (||)
15:21:23 <zell> Hmm
15:21:23 <lambdabot> True  || _ = True
15:21:23 <lambdabot> False || x = x
15:21:38 <ReinH> (||) True is non-strict in its argument
15:21:44 <ReinH> max True is strict in its argument
15:22:02 <vapid> @src map
15:22:02 <lambdabot> map _ []     = []
15:22:02 <lambdabot> map f (x:xs) = f x : map f xs
15:22:10 <vapid> @src foldM_
15:22:11 <lambdabot> foldM_ f a xs = foldM f a xs >> return ()
15:22:36 <zell> Why not; _ || True = True
15:22:38 <zell> ?
15:22:47 <ReinH> zell: which means that foldr max True (repeat False) = max True (foldr max True (repeat False), and max demands the result of (foldr max True (repeat False) before it produces a result
15:22:59 <ReinH> zell: convention
15:23:10 <zell> But why not both?
15:23:16 <ReinH> why not both what?
15:23:19 <ReinH> why not non-strict in both?
15:23:24 * hackagebot glirc 2.16 - Console IRC client  https://hackage.haskell.org/package/glirc-2.16 (EricMertens)
15:23:56 <amalloy> for booleans, max *could* have been specialized to be the same as (||), right?
15:24:06 <ReinH> Because that turns out to be incredibly difficult to implement, and requires concurrent speculative evaluation.
15:24:17 <ReinH> conal has a thing for this, actually
15:24:32 <zell> Ok
15:24:33 <ReinH> amalloy: afaik
15:25:50 <ReinH> er, I meant foldr max False (repeat True) up there in all cases. Stupid brain.
15:26:15 <ReinH> amalloy: it annoys me that they are different
15:26:24 <ReinH> denotationally, they should be equivalent
15:26:50 <ReinH> since || is exactly join (in the lattice sense) is exactly max
15:26:55 <amalloy> that change could be made for all derived Ord instances actually, right?
15:27:15 <ReinH> Hmm. Yes?
15:28:31 <ReinH> zell: see http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice
15:28:43 <zell> Thanks
15:29:28 <ReinH> under the hood, you need to race both computations concurrently by forking threads!
15:29:31 <zell> How to publish pdf in Haskell journal?
15:31:21 <elliptic00> Hi, I try to write code to read a list of files and directories and keep all the files only here is my code filter(\x -> doesFileExist x >>= \bo) listFile 
15:31:45 <ReinH> What do you think ``>>= \bo`` does?
15:32:11 <hydraz> Ooh, ooh, I know this one!
15:32:13 <elliptic00> unwrap the IO bool
15:32:15 <hydraz> Gives a syntax error!
15:32:23 <dmj> elliptic00: you need to use filterM
15:32:44 <dmj> elliptic00: you're trying to perform IO in a function (a -> Bool)
15:32:45 <ReinH> elliptic00: ``\bo'' is not a legal Haskell expression
15:32:47 <dmj> :t filterM
15:32:48 <elliptic00> oh.. is like mapM ?
15:32:49 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
15:32:55 <amalloy> interesting. i looked at the generated Ord instance for a three-way enum, and it's not what i expected. it calls con2tag on each argument, then GHC.Prim.tagToEnum# on each tag and compares those as ints
15:33:09 <dmj> elliptic00: it's like filter, but in a monad
15:33:19 <elliptic00> cool.. thx
15:33:23 <ReinH> Both sides of an infix operator must be haskell expressions
15:33:29 <ReinH> so >>= \bo is gibberish
15:33:58 <elliptic00> i assume  x >>= y   is same as   y <- x
15:34:18 <dmj> :t filterM (pure . even) [1..10::Int]
15:34:20 <lambdabot> Applicative m => m [Int]
15:34:23 <dmj> > filterM (pure . even) [1..10::Int]
15:34:24 <ReinH> That's besides the point, and evidently not true in the way you seem to mean
15:34:26 <lambdabot>  error:
15:34:26 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M887727943874...
15:34:26 <lambdabot>        prevents the constraint ‘(Show (m0 [Int]))’ from being solved.
15:34:36 <ReinH> :t k >>= \bo
15:34:38 <lambdabot> error:
15:34:38 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:34:41 <ReinH> That is a syntax error.
15:34:42 <dmj> > (filterM (pure . even) [1..10::Int]) :: Maybe [Int]
15:34:45 <lambdabot>  Just [2,4,6,8,10]
15:35:11 <ReinH> The desugaring of x <- k involves >>=
15:35:20 <ReinH> But x >>= y is not the same as y <- x
15:35:53 <ReinH> :t (>>=)
15:35:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:36:02 <saurabhnanda> anyone using opaleye that can help me with a simple update query? https://github.com/tomjaguarpaw/haskell-opaleye/issues/205
15:36:08 <ReinH> You can't use >>= to go from ``m a'' to ``b''
15:36:13 <ReinH> only from ``m a'' to ``m b''
15:36:16 <MarLinn> do {y <- x; f y} ~~> x >>= \y -> f y
15:36:42 <hydraz> more generally do { y <- x; z } => x >>= \y -> z
15:36:58 <hackrilege> > let (f,g,h) = (\a->zipWith g a (tail a),\ a (b:bs) -> h (a++[b],bs),id) in f ["hello"," world","!"]
15:37:01 <lambdabot>  [("hello ","world"),(" world!","")]
15:37:47 <hackrilege> > let (f,g,h) = (\a->zipWith g a (tail a),\ a (b:bs) -> h (a++[b],bs),map fst) in f ["hello"," world","!"]
15:37:50 <lambdabot>  error:
15:37:50 <lambdabot>      • Couldn't match type ‘([a], [a])’ with ‘[(b1, b0)]’
15:37:50 <lambdabot>        Expected type: ([a], [a]) -> [b1]
15:39:21 <monochrom> elliptic00: You need you know that if you write "\x" without anything following it, it is a syntax error.
15:39:30 <monochrom> Because this is the second time.
15:39:47 <vapid> > \x00
15:39:49 <lambdabot>  <hint>:1:5: error:
15:39:49 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:39:59 <vapid> ? ?
15:40:01 <vapid> ?
15:40:10 <vapid>   ?
15:40:14 <vapid>  ??
15:40:24 <hackrilege> > let (f,g) = (\a->zipWith g a (tail a),\ a (b:_) -> a++[b]) in f ["hello"," world","!"]
15:40:27 <lambdabot>  ["hello "," world!"]
15:40:33 <monochrom> You also probably need to know that if you write like "\x" we cannot guess what you mean, so we can't even tell you how to fix it.
15:41:15 <hackrilege> what is this!? some kind of multiple zipper!?!?!?!?
15:41:44 <vapid> i feel extremely tired
15:41:46 <hackrilege> :t \x
15:41:47 <vapid> but i dont want to sleep
15:41:48 <lambdabot> error:
15:41:48 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:42:16 <vapid> becauseif i sleep i will be wasting some part of my life that i could spend on actually useful stuff
15:42:23 <vapid> but i cant atually do that because im sleepy
15:42:24 <vapid> help
15:42:28 <hackrilege> :t \ f x -> f x
15:42:30 <lambdabot> (t -> t1) -> t -> t1
15:43:42 <hydraz> :t ($)
15:43:44 <lambdabot> (a -> b) -> a -> b
15:45:30 <hackrilege> > \a->zipWith (\ x (y:_) -> x++[y]) a (tail a) ["hello"," world","!"]
15:45:33 <lambdabot>  error:
15:45:33 <lambdabot>      • Couldn't match expected type ‘[[Char]] -> t’
15:45:33 <lambdabot>                    with actual type ‘[[a]]’
15:45:49 <hackrilege> omg so sorry
15:46:44 <hackrilege> anyway, previously my zipper had type ([a],[a]), but this thing is of type [[a]]
15:47:04 <hackrilege> pretty funky huh
15:47:12 <hackrilege> any idea what its called?
15:47:54 <athan> hackagebot: fold? :)
15:47:55 <MarcelineVQ> a list of list of a
15:48:29 <hackrilege> :t let (f,g) = (\a->zipWith g a (tail a),\ a (b:_) -> a++[b]) in f
15:48:31 <lambdabot> [[a]] -> [[a]]
15:48:46 <hackrilege> that thing
15:48:52 <hackrilege> omnizipper
15:49:45 <MarLinn> decapiselfzip, obviously
15:50:04 <hackrilege> !?
15:50:49 <MarLinn> decapitate + zip with itself. decapiselfzip.
15:51:14 <hackrilege> i dont think that function is exported by base
15:51:49 <MarLinn> not to be confused with decapisilksepp. That's a nasty guy.
15:54:07 <hackrilege> @let omnizipper x = zipWith (\ a (b:_) -> a++[b]) x (tail x))
15:54:08 <lambdabot>  Parse failed: Parse error: )
15:54:17 <hackrilege> @let omnizipper x = zipWith (\ a (b:_) -> a++[b]) x (tail x)
15:54:20 <lambdabot>  Defined.
15:54:32 <soLucien>   data Point = Point (Double, Double) deriving (Show)
15:54:39 <soLucien> can this be translated as a type ?
15:54:46 <soLucien> instead of data
15:54:52 <geekosaur> it is a type
15:54:55 <lingxiao> hey all
15:55:10 <lingxiao> im at my wits end with this bug that's taken me two days so far ..
15:55:18 <athan> Maybe with -XDataKinds :v
15:55:23 <lingxiao> im deploying my haskell code on some remote server 
15:55:40 <hackrilege> in the middle of the sea?
15:55:42 <lingxiao> my functions open 100 + large txt files and parses them ... then writes the result to disk
15:55:45 <athan> soLucien: You mean `type Point = (Double, Double)`?
15:55:53 <soLucien> something like that
15:55:58 <soLucien> but also deriving show ?
15:56:00 <lingxiao> it seems like my function is terminatiing prematurely ..
15:56:06 <hackrilege> whats the
15:56:10 <hackrilege> paste
15:56:13 <lingxiao> it only reads one .txt file and then terminates
15:56:17 <athan> type aliase aren't new constructs
15:56:40 <athan> they're like variable names for underlying types - they "inherit" everything because they're not considered a different thing
15:56:44 <hackrilege> can you paste the code?
15:56:55 <athan> SolarAquarion: ^
15:57:05 <athan> er soLucien ^ sorry
15:57:27 <ReinH> lingxiao: what happens when you run it locally?
15:57:34 <hackrilege> www.lpaste.net
15:57:35 <geekosaur> soLucien,things defined with `type` are purely aliases. they cannot have their own instances
15:57:38 <lingxiao> so far parsed 4 files ..
15:58:06 <soLucien> i see , so data > type
15:58:09 <lingxiao> but it's not very practical ... i only have 8G of ram
15:58:13 <lingxiao> remote has 500 + 
15:58:19 <soLucien> you need some data to be able to define types out of it
15:58:43 <MarLinn> soLucien: I wouldn't recommend declaring it as a type. Better use data or newtype for more type safety and nicer error messages
15:58:55 <geekosaur> soLucien, more precisely, you need a distinct constructor
15:59:01 <ReinH> Why on earth do you need 500GB if RAM?
15:59:27 <hackrilege> many wallets is my guess
15:59:39 <ReinH> *of
15:59:51 <ReinH> Try it locally with smaller files
16:00:29 <ReinH> soLucien: Show is not a type.
16:00:32 <lingxiao> so yeah it works one only one file remote
16:00:50 <lingxiao> and im pretty sure it'll run to completion w/ smaller files
16:00:57 <ReinH> "Pretty sure"?
16:00:58 <ReinH> Try it.
16:00:59 <lingxiao> but my problem is gettting it to work in remote
16:01:08 <lingxiao> suppose it doesnt work... then what does it prove?
16:01:12 <lingxiao> like im not sure how to fix this 
16:01:15 <ReinH> That you can debug it locally
16:01:29 <ReinH> That the problem isn't on the remote server
16:01:31 <hackrilege> or that we cant do much more
16:01:33 <lingxiao> well lcoally its already ran much farther than on remote
16:01:37 <lingxiao> on remote it quit after 2 
16:01:49 <lingxiao> local it's still going at 6
16:02:11 <ReinH> soLucien: ``type'' creates a type synonym, it does not define a new data type.
16:02:24 <hackrilege> can we get the source to see if we can spot the bug?
16:02:57 <ReinH> lingxiao: http://stackoverflow.com/help/mcve
16:03:31 <ReinH> Find the problem by eliminating things that are not the problem.
16:04:16 <schell> does anyone know how much memory is alloc’d by the TVar constructor?
16:04:50 <ReinH> schell: http://stackoverflow.com/questions/3254758/memory-footprint-of-haskell-data-types
16:05:04 <soLucien> ReinH as in a type would be used to "call an array of Foo a Bar"
16:05:19 <soLucien> type Bar = [Foo]
16:05:21 <ReinH> soLucien: Yes, e.g., type String = [Char] calls a list of characters a string.
16:05:36 <MarLinn> lingxiao: If it's not your own server my first check would be if it uses some kill script to distribute resource usage or something. Such things should be easy to spot if you monitor your program with some tool - which would be the first step anyway
16:05:36 <ReinH> That is the definition of String.
16:05:36 <soLucien> okay , but it does nothing else aliasing
16:05:41 <ReinH> soLucien: correct.
16:05:46 <soLucien> great
16:05:53 <schell> thanks ReinH 
16:06:04 <xcmw> Am I doing this right? I know they are some builtin functions for parsing numbers but they did not seem to support exactly what I wanted. http://lpaste.net/189281
16:06:08 <lingxiao> MarLinn how would i monitor for kill scripts?
16:06:38 <kram1032> Hi I'm trying to install a bunch of things with Stack but no matter what it keeps telling me it expects ghc 7.10.3 rather than 8.0.1. Do you need to fall back to the older version or can that be fixed somehow? (I'm working on Windows here)
16:06:54 <jle`> kram1032: have you tried stack setup?
16:07:21 <MarLinn> lingxiao: You wouldn't monitor "for" them. You would monitor in general and try to spot patterns like "it always dies when memory usage is almost exactly 500MB"
16:07:46 <ReinH> We can't tell you why a remote server is terminating your process, but we might be able to help you write a program that processes text files while using less than 500GB of memory.
16:08:09 <ReinH> Even 8GB should be more than enough for most use cases
16:08:22 <kram1032> jle`: not yet. Will that mean I'll get the older version of haskell installed and it'll work with that, or will it still work with the newer version then?
16:08:36 <jle`> it'll install the appropriate versions of ghc
16:09:14 <hackrilege> i guess its needed in ram for rapid access
16:09:32 <jle`> determined by the stack file of the project  -- usually from the resolver/snapshot
16:09:44 <hackrilege> and should consider consuming 500gb successfully as the task
16:09:44 <schell> ReinH: looks like a data TVar = (TVar (IORef a)) so it’s +1 word over IORef
16:09:55 <hackrilege> but yeh, we cant get the bug without the source
16:10:29 <kram1032> ok... doing that now
16:12:25 <tsani> Is there a way to produce haddocks with working (nonlocal) links? The goal is to host them myself for a package I've made.
16:14:40 <hackrilege> :t foldl1 (\ (a,c) (b:bs) -> (c++[b],bs))
16:14:42 <lambdabot> error:
16:14:42 <lambdabot>     • Couldn't match expected type ‘([a], [a])’ with actual type ‘[a]’
16:14:42 <lambdabot>     • In the pattern: b : bs
16:14:52 <hackrilege> :t foldl (\ (a,c) (b:bs) -> (c++[b],bs))
16:14:54 <lambdabot> Foldable t => ([a], [a]) -> t [a] -> ([a], [a])
16:15:26 <MarLinn> hackrilege: would you mind playing with lambdabot in private conversations, please?
16:15:35 <hackrilege> no i want to identify this thing
16:15:40 <hackrilege> that was my presentation of it
16:15:55 <hackrilege> i would like help with this thing*
16:15:57 <zennist> are all of the libs installed by cabal 'static'?
16:16:17 <ReinH> zennist: define "static".
16:16:37 <zennist> static as in 'static library'
16:16:43 <zennist> usually .a on linux
16:16:48 <hackrilege> i defined it using zip above, thats the equivalent using fold
16:16:58 <zennist> it seems that there are both versions in my .cabal/lib
16:17:09 <zennist> .a and .dylib on my Mac
16:17:36 <MarLinn> hackrilege: I'm quite sure that doesn
16:17:48 <MarLinn> hackrilege: I'm quite sure that doesn't have a name
16:18:02 <MarLinn> (sry)
16:18:03 <hackrilege> it generalises a zipper
16:18:17 <ReinH> zennist: haskell libraries are linked statically (by default)
16:18:35 <ReinH> How does it generalize a zipper?
16:18:55 <hackrilege> i could use an int accessor to just move one
16:19:19 <ReinH> How?
16:19:55 <ReinH> zennist: non-haskell (usually C) libraries are linked dynamically (by default)
16:20:01 <hackrilege> > omnizipper ["hello"," world","!"]
16:20:04 <lambdabot>  ["hello "," world!"]
16:20:16 <zennist> ReinH: really? it seems that ghc has a -dynamic option which i think allows you to compile your library *dynamically* against your existing dynamic libraries (but i might be wrong)
16:20:22 <ReinH> In what sense is that a zipper?
16:20:28 <athan> How long should it take to multiply two matricies of size <10000,1> and <10000,10000>?
16:20:42 <geekosaur> zennist, you can override it, static is the default not the mandatory
16:20:50 <ReinH> zennist: Yes, it has flags. Do you think that contradicts what I said?
16:21:16 <zennist> basically - i'm seeing every package in cabal's lib directory with .dylib AND .a
16:21:18 <hackrilege> in that i have defined the operation "right"
16:21:46 <hackrilege> > (omnizipper.omnizipper) ["hello"," world","!"]
16:21:50 <lambdabot>  ["hello  "]
16:21:55 <athan> How long should it take to multiply two matricies of size <10000,1> and <10000,10000>?
16:21:56 <athan> gah sorry
16:21:56 <ReinH> Have you?
16:21:59 <hackrilege> urgh, thats broken
16:22:24 <pavonia> :t omnizipper
16:22:27 <ReinH> athan: as long as it takes, if not longer
16:22:27 <lambdabot> [[a]] -> [[a]]
16:22:56 <hackrilege> -- @let omnizipper x = zipWith (\ a (b:_) -> a++[b]) x (tail x))
16:23:19 <MarLinn> zennist: Maybe you have the dynamic flag set in your cabal config for some reason?
16:23:25 * hackagebot octane 0.16.1 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.16.1 (fozworth)
16:23:29 <hackrilege> oh it drops the tail, i should use the fold version
16:23:36 <pavonia> What is this function used for?
16:23:36 <hackrilege> one sec
16:24:06 <hackrilege> i was using it to try to shift the elements between a list of lists
16:24:55 <zennist> MarLinn: no - not having that flag set; but it might be something peculiar for Mac, as just checked my Linux only has .a's....
16:24:57 <Cale> athan: About half a second?
16:25:36 <athan> Cale: Dangit :( I'm getting around 8 with repa
16:26:02 <Cale> Does that include any of the time spent computing the matrices in the first place?
16:26:23 <athan> nope, I've forced the data.. at least I think so
16:26:36 <athan> I'm still digging into it :\ sorry
16:26:37 <ReinH> hackrilege: even if you wrote that correctly, it would not be a zipper
16:27:17 <ReinH> We have a well defined notion of what a list zipper is / means http://strictlypositive.org/diff.pdf
16:27:35 <ReinH> it is the derivative of a list
16:27:41 <zennist> also would be grateful if someone can confirm my belief - I see ghc has -dynamic and -shared: I suppose -dynamic controls whether the dependency libraries are linked with my library dynamically or not, and -shared decides whether my library is dynamic or not; so if I only have -shared but not -dynamic I should get a giant library containing .a of all my dependencies; correct?
16:27:51 <Cale> athan: What are the matrix entries?
16:27:59 <athan> Cale: Doubles
16:28:04 <athan> all unboxed too
16:29:43 <geekosaur> zennist, not quite. if you are generating a shared object, it must reference other shared objects, not static ones
16:30:33 <geekosaur> *executables* can reference static libraries. a shared object can't use static libraries because they cannot be relocated at runtime to match wherever your shared object is loaded into memory
16:30:38 <zennist> geekosaur: i'm reading somewhere that by generating all .a as -fPIC code, one could achieve a big shared object with '-shared' without '-dynamic'
16:31:14 <geekosaur> mm. theoretically yes, practically there are issues (like, you cannot dlopen() a .a regardless of whether it has PIC objects in it or not)
16:31:38 <zennist> i see
16:31:40 <geekosaur> (actually there are glibc versions that will try to do so iirc, they are unreliable)
16:32:05 <Cale> athan: Maybe compare whatever you're doing against hmatrix
16:32:15 <athan> That's my next plan :) thanks Cale
16:33:19 <geekosaur> anyway, yes it is possible to do tricky things on some platforms and under some circumstances, no ghc does not support doing so because haskell code always seems to violate the circumstances that work >.>
16:33:26 <xcmw> exit
16:34:12 <geekosaur> (linux 32-bit actually can get away with pretending a non-PIC static object is shared. this caused lots of unexpected problems when x86_64 linux became a thing...)
16:39:52 <soLucien> Could not find module `Network.HTTP.Client'
16:39:59 <soLucien> why could this happen ?
16:40:21 <soLucien> (running this on indows)
16:40:23 <soLucien> Windows
16:40:44 <c_wraith> soLucien: the package isn't installed, ghc wasn't told to use the package, the package was installed in a different sandbox...  There are a number of reasons why ghc might not be using it.
16:41:50 <soLucien> isn't this part of the standard library ?
16:41:54 <c_wraith> No
16:42:06 <c_wraith> There's no network code at all in the standard library
16:42:19 <soLucien> is there a search engine for these types ?
16:42:28 <soLucien> so i know what to stack install
16:42:40 <soLucien> when i am missing something
16:42:41 <soLucien> ?
16:42:58 <c_wraith> hoogle can often get you a package name from a module name
16:43:06 <athan> Cale: Holy crap I got it to around that range don't ask me how
16:43:08 <pavonia> There's also hayoo
16:43:17 <c_wraith> there's a hoogle specifically for stack libraries, too
16:44:36 <JonReed> Hi, I'm searching for an infinite loop in my module, so I'm trying to compile it with -prof, however it screams "Perhaps you haven't installed the profiling libraries for package" and outputs a bunch of dependencies that I use. Do I actually need to compile all dependencies with some profiling support, if I only want to debug my module?   
16:45:12 <pavonia> If it depends on all these, yes
16:46:47 <mpickering> I'm trying to write a function of type "Getter Player Int" by first focusing on a list in the data structure and then returning the length. Is there a more idiomatic way to do this than `to (lengthOf complicatedLens)`
16:48:20 <geekosaur> JonReed, yes
16:49:09 <geekosaur> because of things like cross-module inlining, and the inlined code has to match the non-inlined code or you get bizarre bugs and core dumps
16:49:15 <soLucien> okay so i found the dependencies i needed, stack installed them , and built the thing on my PC. I want to somehow save them in the git repo so that when i build it on my laptop, i will not have to manually install them again
16:49:19 <geekosaur> ghc does a lot of evil things internally
16:49:22 <soLucien> what's the procedure for this ?
16:49:45 <geekosaur> soLucien, you generate a cabal file specifying the dependencies
16:51:45 <geekosaur> hm, does `cabal init` figure out deps like that?
17:01:01 <mpickering> it does sometimes but I never worked out when it did
17:03:05 <glguy> It can figured them out if you already have the dependencies installed
17:03:13 <glguy> and the imported modules are unambiguous
17:03:34 <geekosaur> so for a stack project you'd need stack exec -- cabal init
17:03:44 <geekosaur> well, the -- is unneeded if you don't pass options to cabal init
17:04:24 <soLucien> how can i define a data to be an array ?
17:04:52 <soLucien> i tried switching from   type Curve = [Point]  to   data Curve = [Point] 
17:05:02 <soLucien> and it fails to parse
17:05:11 <hydraz> data Curve = Curve [Point]
17:06:00 <geekosaur> also note that;s not an array, it's a linked list
17:06:03 <hackrilege> data Curve = Curve {getPoints :: [Pont]}
17:06:24 <hackrilege> Point*
17:06:34 <MarcelineVQ> soLucien: some helpful relevant reading https://wiki.haskell.org/Type
17:06:37 <c_wraith> If you want an array, use the vector library
17:06:46 <hydraz> Or the array library
17:07:41 <soLucien> so [Point] is a array of points
17:07:48 <hydraz> Linked list.
17:08:00 <soLucien> but if i want to create Curve[Point] it becomes an array
17:08:02 <soLucien> ok
17:08:30 <soLucien> so all [foo] objects are actually linked lists under the hood
17:08:43 <soLucien> not arrays as in other programming languages
17:09:02 <geekosaur> yes, because linked lists are how you encode loops in functional languages
17:09:07 <hydraz> The type [a] is a linked list "above the hood", too
17:09:13 <Cale> There are arrays too, but that's a different type
17:09:35 <soLucien> makes sense
17:12:22 <hackrilege> data Curve a where Curve :: [a] -> Curve a
17:13:16 <hackrilege> :t toList
17:13:19 <lambdabot> error:
17:13:19 <lambdabot>     Ambiguous occurrence ‘toList’
17:13:19 <lambdabot>     It could refer to either ‘F.toList’,
17:13:32 <hackrilege> :t Data.Foldable.toList
17:13:34 <lambdabot> Foldable t => t a -> [a]
17:14:22 <hackrilege> so you could write a Foldable instance and obtain its representation as a list using toList, and then many of the functions of the haskell prelude will be easy to use
17:15:10 <hackrilege> i dont know if there is an easy way to translate functions on lists to functions on an arbitrary instance of Foldable
17:16:25 <hackrilege> i have one but its not easy
17:22:22 <santosha> anyone have experience with the (at least three) available IntelliJ plugins for Haskell?
17:23:27 * hackagebot darcs 2.12.3 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.12.3 (GuillaumeHoffmann)
17:23:29 * hackagebot generic-deriving 1.11.1 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.11.1 (ryanglscott)
17:24:19 <hackrilege> isnt that more for an IDEA forum?
17:25:17 <santosha> I wouldn't think so
17:26:17 <hackrilege> can you link the hackage repo?
17:27:33 <santosha> no, they wouldn't be in the hackage repo, is that your point?
17:27:49 <hackrilege> yes
17:28:50 <ReinH> santosha: don't mind hackrilege. I don't think many of us use IntelliJ for Haskell dev though.
17:29:08 <hackrilege> i use notepad
17:29:16 <santosha> suit yourself
17:29:17 <hackrilege> or wordpad if it crashes
17:29:44 <geekosaur> https://notepad-plus-plus.org/
17:30:00 <geekosaur> ^ do yourself a favor, if you're using notepad for programming
17:30:13 <hackrilege> that heard that can be buggy
17:31:47 <ReinH> You just said you crash notepad.
17:32:23 <ReinH> Which is already remarkable.
17:32:35 <hackrilege> typing ":set editor yourEditorOfChoice.exe" in ghci sets the editor called with :e "fileToEdit.hs" at the ghci prompt
17:33:11 <hackrilege> yes, for some reason recent versions of ghci have some dumb renaming bug when your program doesnt compile, its really annoying
17:33:48 <ReinH> "Some dumb renaming bug"? Have you reported it?
17:34:23 <hackrilege> :e wont work with notepad whichis its default in windows if the ,hs file targeted does not compile, it instead attempts to open a different file
17:34:34 * geekosaur doesnt get that one. crashes notepad, btu won't use notepad++ because "that can be buggy"
17:34:35 <hackrilege> .hs*
17:34:50 <hackrilege> i mean it is hacked#
17:34:56 <hackrilege> the bad kind of buggy
17:35:09 <ReinH> What
17:35:12 <geekosaur> if you download it from not the original source, quite likely. same with lots of programs
17:35:39 <hackrilege> whereas notepad is bundled with windows
17:36:05 <hackrilege> really the killer is not having an undo buffer, its like climbing without a rope
17:36:14 <MarLinn> you can always manually echo content from ghci with :! so you don't even need an editor!
17:36:50 <hackrilege> what does that append a file?
17:38:35 <MarLinn> depends on your os and batch skillz... Only true haxors know how to program in windows batch from ghci
17:39:39 <hackrilege> nah, i wrote windows command prompt in haskell
17:40:22 <hackrilege> well its a pretty sucky version tbh, but System.Process is good
17:43:13 <MarLinn> So if you wrote a command prompt - why not an editor, if all others suck. Can't be worse than notepad...
17:43:38 <hackrilege> its on the bucket list
17:43:52 <hackrilege> im sure there are plenty already
17:44:39 <santosha> you seriously use notepad?
17:45:00 <hackrilege> wordpad when im being serious
17:45:17 <hackrilege> ie, after the first time i try to compile it
17:45:27 <hackrilege> and it dosent compile
17:45:37 <hackrilege> because of the bug i mentioned
17:46:05 <hackrilege> or if i need the undo buffer
17:46:58 <hackrilege> or the more advanced ctrl+h
17:47:55 <santosha> being new here, I'm not sure if you are being serious or just have a very dry sense of humor
17:48:02 <hackrilege> i wouldnt want crazy underlining or colouring doing my head in
17:48:23 * athan needs an ms-paint tty plugin
17:48:48 <hackrilege> just thought id give the features id include in a bare bones text editor while on the topic of writing one
17:49:36 <santosha> yes, like "undo"
17:49:41 <pavonia> hackrilege: In what way is Notepad++ buggy?
17:50:05 <hackrilege> its a known security flaw i dont have a reference sorry
17:50:11 <ReinH> santosha: not being new here, neither are we.
17:50:50 <hackrilege> im just security conscious and for minimal overhead
17:51:01 <ReinH> I mean, wordpad isn't even a plain text editor, but I don't really care enough to pursue it.
17:51:54 <kosh_> hey, what is the best way to do 2d fft of hmatrix matrix?
17:52:29 <hackrilege> i need to read the source, write (or read and compile) the compiler in order to trust the code contains no bugs
17:53:16 <ReinH> So you've vetted the source of GHC?
17:53:42 <MarLinn> hackrilege: you get an A for effort but I'd say you gave yourself away with these last comments...
17:53:57 <kosh_> unfortunatly Numeric.GSL.Fourier has only 1d fft. ( i can try to do 2d via 1d, by doing it for each row & column) but it does not sounds efficient
17:54:11 <athan> vellvm ftw
17:54:46 <hackrilege> yeh and i manurfactured a small machine based on the zx81 from transistors from old crt tvs to ensure the hardware was not corrupted
17:54:57 <ReinH> I don't believe you.
17:55:06 <hackrilege> gosh
17:55:17 <peddie> @hackage vector-fftw  -- kosh_ 
17:55:18 <lambdabot> http://hackage.haskell.org/package/vector-fftw  -- kosh_
17:55:37 <hackrilege> i do use notepad...
17:55:42 <soLucien> !pastebin
17:55:56 <peddie> kosh_: hmatrix matrices are just  Data.Vector.Storable  vectors
17:55:57 <pavonia> @lpaste
17:55:58 <lambdabot> Haskell pastebin: http://lpaste.net/
17:56:29 <soLucien> http://lpaste.net/6556386517873328128
17:56:40 <soLucien> i want to do the commented out transformation
17:56:47 <soLucien> but i get  a compile error
17:56:57 <soLucien> what do i have to change for it to work ?
17:57:01 <peddie> kosh_: I'm sorry, I lied; I thought this package had 2-d transforms, but it doesn't
17:57:42 <kosh_> eh(
17:57:45 <ReinH> soLucien: you need to use the data constructor to create and pattern match Curve values.
17:58:18 <ReinH> Any Haskell tutorial would explain this.
17:59:25 <peddie> kosh_: depending on how comfortable you are with the FFI, you might grab the code for that package or hmatrix-gsl and add 2-d transforms.  it's probably what I would do
18:00:05 <kosh_> peddie: I am noob =)
18:00:38 <kosh_> but how hard could it be if you have 1d example...
18:00:42 <kosh_> =)
18:01:29 <hackrilege> http://lpaste.net/6556386517873328128
18:01:41 <hackrilege> i annotated your paste
18:02:43 <soLucien> ReinH do you know of any quick haskell tutorial ? i had to read chapters 1-11 this week but i couldn't since it was way too much
18:03:20 <soLucien> any idea whether there's a quicker way in ?
18:03:25 <ReinH> Why did you have to read 11 chapters in a single week?
18:03:34 <hackrilege> lol
18:03:36 <soLucien> i have no idea.
18:03:58 <soLucien> maybe they think we're geniuses
18:04:04 <ReinH> Did someone tell you to? Surely you have some idea.
18:04:17 <hackrilege> check the paste, at least it has correct syntax, but i dont know what you were trying to do with the function curve
18:04:42 <soLucien> ah , i'm doing this for my master course
18:05:03 <soLucien> but i think the workload is too much
18:05:24 <hackrilege> its a breeze, chillax
18:05:38 <ReinH> I have a hard time believing anyone would assign 11 chapters in a week.
18:06:05 <kosh_> hah, gsl does not have special routine for 2dim or Ndim fft
18:06:11 <soLucien> http://pasteboard.co/1BQcIMxA7.png
18:06:20 <geekosaur> 11 chapters?that's a bit much even for me >.>
18:07:05 <peddie> kosh_: ok . . . it's sunday morning, I might as well take a look at vector-fftw, gimme a few minutes
18:07:07 <geekosaur> o.O
18:07:19 <hackrilege> anderzej is a deamon
18:07:54 <kosh_> peddie: thx. you are saint
18:07:55 <soLucien> haha
18:08:11 <peddie> kosh_: no promises :)  do you have real data?
18:08:16 <ReinH> To be fair, LYAH takes a lot of pages to explain simple concepts
18:08:20 <peddie> (as opposed to complex)
18:08:22 <soLucien> exactly
18:08:28 <soLucien> that's why i want a quicker way in
18:08:33 <ReinH> I would never use it to teach Haskell
18:08:41 <kosh_> peddie: sure. no - I am trying to solve pde with spectral method
18:08:50 <peddie> kosh_: coolo
18:09:06 <kosh_> I mean: real/complex everything would work
18:09:16 <hackrilege> https://hackage.haskell.org/package/unm-hip-0.3.1.6/docs/Data-Image-Complex.html
18:09:26 <ReinH> Hutton's Programming In Haskell has a brand new edition.
18:09:27 <soLucien> i tried, but after some a while i felt like i was wasting time
18:10:05 <soLucien> i hate these slow-paced tutorials where they try to teach you to program as well as the programming language
18:10:38 <hackrilege> learning haskell teaches you to program
18:10:59 <hackrilege> i see what you mean though
18:11:13 <soLucien> i've done java/c#/powershell/ruby/python/bash/php/js and some other stuff 
18:11:24 <soLucien> in the last 5 years
18:11:24 <ReinH> Thinking Functionally With Haskell by Bird is great and pretty brisk.
18:11:28 <hackrilege> i think map and fold are good enough for most
18:11:29 <soLucien> so i know how to program
18:11:31 <geekosaur> hah. https://www.haskell.org/tutorial/ is old and some of the code no longer works unmodified, but might be the ticket
18:11:41 <hackrilege> > map (+1) [1,2,3]
18:11:45 <lambdabot>  [2,3,4]
18:11:56 <hackrilege> > foldl (+) 0 [1,2,3]
18:11:59 <lambdabot>  6
18:12:10 <hackrilege> understand the source and your golden
18:12:15 <santosha_> I'd also like to find a "Haskell for the Impatient", or Haskell for Scala Programmers
18:12:36 <ReinH> soLucien: you should get Bird's book imo
18:12:40 <soLucien> i can say Ruby and Powershell have similar constructs, and c#/Java can do lambdas
18:12:55 <soLucien> i'm on it 
18:13:07 <hackrilege> how to publish haskell material?
18:13:30 <glguy> wasn't the gentle introduction to Haskell supposed to be rather sudden?
18:13:38 <hackrilege> i dont want to paywall it, just make a nicer reference to a journal than a wabpage
18:13:43 <ReinH> Yes, rather ironically named.
18:14:18 <geekosaur> glguy, yes, but in part it's because they assume you know programming and preferably have been at least exposed to functional programming concepts)
18:14:21 <hackrilege> soLucien, its all about the typechecker
18:14:55 <MarLinn> soLucien: Initially I assumed that you're expected to know some form of functional programming, which would make it a lot easier - but then I wouldn't have expected anyone to relegate logic programming to two days in a masters course... Strange planning indeed
18:15:10 <santosha_> Gentle Intro to Haskell hasn't been revised in 16 years...
18:15:13 <ReinH> This is a really strange couree
18:15:23 <ReinH> Course
18:15:37 <soLucien> .. and we have Advanced Algorithms in parallel with it
18:15:57 <soLucien> compute complexity of randomized functions, hash functions
18:16:15 <soLucien> it's only been one week
18:16:40 <ReinH> Hmm, actually maybe byorgey or bos's lecture notes would be good
18:17:34 <hackrilege> im teaching haskell a bit atm, i wrote an intro for my prof, it covers lazy evaluation, lists and key classes, it focuses on the power of lists and introduces Maybe for catching errors. growing and folding lists as a programming approach is the key concept. thats about it
18:17:36 <ReinH> Their curricula were actually reasonable
18:19:19 <santosha_> I start getting lost when it comes to monad transformers, free monads, type-level programming and the like
18:19:36 <hackrilege> sorry...
18:20:54 <hackrilege> i like Free because of its recursive character which embodies the lazy list comprehension
18:21:25 <hackrilege> mmmmm recursion
18:22:21 <hackrilege> the base case and inductive step seem to be so central to this approach
18:23:28 * hackagebot machines-io 0.2.0.13 - IO utilities for the machines library  https://hackage.haskell.org/package/machines-io-0.2.0.13 (bitemyapp)
18:23:35 <hackrilege> i even define Free as; data Free f a = Base a | Recurse (f (Free fa))
18:23:52 <hackrilege> i dropped a ' '
18:24:59 <catstail> Testing, testing. Sorry, this just happened to be the buffer I'm in.
18:25:03 <buglebudabey> could someone give me direction on how to implement this dynamic programming solution in haskell? http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/
18:25:09 <hackrilege> im working on Alternative Functors in 2 directions to try and get (:) and Recurse to work together in an unfold
18:26:27 <Cale> buglebudabey: I might use a lazy array for that...
18:26:50 <Cale> buglebudabey: You can define an array whose elements are defined in terms of the values of other elements of the array, all at once
18:26:57 <Cale> (recursively)
18:27:38 <hackrilege> i find that [[a]] can be used to store "splittings" in a list :: [a], so that Free [[]] a can be infinetly nested and navigable under a [Int] accessor
18:27:43 <buglebudabey> Cale that's actually exactly what i've done for other dp problems, namely ones that need multidimensional arrays, but i'm still having a bit of trouble with this one. i'll go back to the lazy arrow and show what i have
18:28:43 <hackrilege> i hope to capture all type level representations of the natural numbers
18:29:32 <hackrilege> and a set of functions transforming them into well defined adjacent representations
18:29:59 <hackrilege> as is obtained via a Free Zipper
18:30:29 <hackrilege> and i want to know where i should publish the write up
18:33:27 <ReinH> Your blog?
18:33:35 <hackrilege> does anyone have any experience of publishing accademic journals?
18:34:20 <athan> Why doesn't repa arrays support an update function? Must I extract and append? :(
18:34:47 <ReinH> arXiv?
18:35:02 <ReinH> Journals have acceptance and peer review processes.
18:35:10 <MarLinn> you mentioned a professor you worked for. Professors might know a trick or two about publishing I hear
18:35:14 <hackrilege> how does that work, ur my peer right?
18:35:23 <hackrilege> he is a chemistry prof
18:35:33 <ReinH> I don't review papers for journals.
18:35:38 <peddie> kosh_: https://gist.github.com/peddie/9eadcae2b936217d4469bbd07f0d7967#file-unnormalized-hsc-L89-L116 
18:35:49 <peddie> kosh_: this compiles and works on a simple example
18:35:55 <hackrilege> this haskell stuff is a bit of an aside, it comes from too much polymorphism, but it solves his problem too so its good
18:36:10 <MarLinn> Right. Chemistry profs don't publish. Silly me.
18:36:27 <ReinH> Find an appropriate journal, go through their submission process.
18:36:45 <athan> hackrilege: check this out: https://arxiv.org/help/submit
18:36:47 <hackrilege> i like the power of the result though and id like to see if i can get past this reviewing stage and get my first haskell publication, within about half a year
18:37:04 <hackrilege> thanks athan
18:37:12 <athan> good luck :)
18:37:54 <santosha_> there are journals associated with presenting at conferences as well
18:38:25 <peddie> kosh_: using  Numeric.LinearAlgebra.Data.flatten  and  reshape  to convert between the matrix and a Data.Vector.Storable.Vector and  dft2d  from that modified version of vector-fftw, you can probably build a 2-d transform that doesn't do the wrong thing with sizes
18:39:06 <hackrilege> it gives them permission to reliscence my work, seems odd. id prefer cambirdge  journal of functional programing, you think if im careful with typos it could get in?
18:39:30 <ReinH> Realistically? No, I do not.
18:39:40 <hackrilege> so what hurdles remain
18:40:01 <hackrilege> other than just a good writeup
18:40:26 <ReinH> That would be the biggest one.
18:40:40 <hackrilege> yeh but thats turtely simple
18:40:46 <santosha_> reliscence?
18:40:59 <hackrilege> Submitters must grant arXiv.org a non-exclusive and irrevocable license to distribute or certify that the work is available under another license that conveys these rights.
18:41:31 <ReinH> If you want them to publish your work, they have to be able to publish your work.
18:41:33 <jonored> "submitters must allow arXiv.org to do the thing you're asking arXiv to do".
18:42:48 <hackrilege> and then do you get points if subscribing institutions access the work?
18:42:51 <buglebudabey> Cale this is my implementation so far but i'm getting an infinite loop. To me the implementation is proving difficult because I have to initialize values in the array first and also what happens when I don't need an else statement as in the prior link? http://lpaste.net/189523
18:43:09 <ReinH> What points? What subscribing institutions?
18:43:18 <hackrilege> money, unis
18:43:42 <ReinH> arXiv isn't a journal
18:43:59 <hackrilege> thanks sorry for noob
18:45:36 <ReinH> Realistically, you have about the same chance of being published in the JFP as you do of playing in the NBA. It's the most prestigious journal in its domain.
18:45:48 <ReinH> I have about the same chance.
18:46:02 <ReinH> So I'm not trying to insult you
18:46:07 <hackrilege> i guess i should establish how far i need to develop the functionality over this structure to use the speed afforded, but id like to leave the api pretty high level
18:46:53 <hackrilege> ok, whats another option other than conference joiurnals?
18:47:15 <ReinH> Your blog? arXiv?
18:47:28 <hackrilege> right
18:47:34 <hackrilege> all or nothing
18:48:31 <ReinH> Yes, that's what you asked.
18:48:38 <hackrilege> it seems strange that supervised doctoral research would be below the level of journal publication
18:49:28 <ReinH> You are doing supervised doctoral research on Haskell?
18:49:37 <hackrilege> i suppose not
18:49:49 <santosha_> some conference journals are more academic than others
18:49:53 <ReinH> I don't believe you.
18:50:07 <hackrilege> but you said NBA, is that how rare haskell phds are?
18:50:09 <ReinH> You would have asked your advisor these questions
18:50:37 <ReinH> That's how rare being published in the JFP is
18:50:53 <glguy> There are probably more NBA players than Haskell-specific PhD
18:51:02 <ReinH> Also true
18:51:11 <c_wraith> Does byorgey count?
18:51:18 <hackrilege> that would be the avenue of computational chemistry or physics, but then the haskell specific stuff isnt a relevant result there
18:51:19 <glguy> I bet he can count pretty high
18:51:39 <c_wraith> I only got a BS.  I can't count much past 5
18:51:57 <ReinH> There are other journals
18:52:02 <[k-> I can count up to 2
18:52:23 <hackrilege> [1,2..]
18:53:00 <hackrilege> oh, which other journals?
18:53:24 <hackrilege> thats kind of what i was asking for when you said blog
18:53:50 <ReinH> You specifically asked for things that *weren't* journals
18:54:06 <hackrilege> not nba level jfp
18:55:23 <hackrilege> *conference journals*
18:55:32 <ReinH> 6:46 PM <hackrilege> ok, whats another option other than conference joiurnals?
18:56:00 <MarLinn> You could publish on github. It automatically gives more cred to whatever you publish and you might get peer review
18:56:07 <hackrilege> is it correct the inference then that jfp is the only non conference haskell journal
18:56:27 <hackrilege> github take ip rights
18:56:39 <ReinH> What? No they don't.
18:56:40 <MarLinn> Oh, oh! Start your own journal!
18:57:03 <MarLinn> The do have an IP. Several!
18:57:16 <hackrilege> you agree to something! i remember finding it was more than i was prepared to
18:57:37 <ReinH> I don't believe you.
18:57:45 <hackrilege> promise
18:58:02 <hackrilege> not looking for that now though
18:58:07 <ReinH> You just make up things and then say "I can't remember" when pressed.
18:58:08 <hackrilege> anyway hackage is better
18:58:10 <glguy> "We claim no intellectual property rights over the material you provide to the Service."
18:58:13 <glguy> https://help.github.com/articles/github-terms-of-service/
18:58:34 <hackrilege> i didnt make it up though, im just abstaining from providing proof
18:58:36 <ReinH> You are either a troll or indistinguishable from a troll.
18:59:04 <ReinH> It is a demonstrably false statement
18:59:05 <hackrilege> im just to lazy to dig through github terms and conditions atm forgive me
18:59:25 <hackrilege> but there is a reason i dont want to use it and its not correct for me to defend that here
18:59:49 <hackrilege> i favour hackage
18:59:52 <ReinH> Then just say that, don't make stuff up
19:01:05 <hackrilege> i have a wild imagining based on a vague recollection of finding something like "github take ip rights"
19:01:14 <hackrilege> ...
19:01:31 <ReinH> Yes. I will just assume everything you say is a lie from now on.
19:01:37 <hackrilege> so i publish my thesis via cable. fine
19:02:09 <santosha_> So you wouldn't consider something like "Proceedings of the ACM SIGPLAN Symposium on Haskell" because it's a conference journal?
19:02:33 <hackrilege> its in .lhs anyway (using lhs2tex and bibtex with a crude parser to extract bitex from pdf)
19:02:49 <hackrilege> i wouldnt want to have to fly anywhere
19:02:50 <ReinH> Oh. Cabal.
19:02:58 <hackrilege> sorry
19:03:50 <hackrilege> it does not seem very high impact, a module which produces my thesis as a pdf...
19:04:25 <ReinH> Oh my god
19:04:39 <hackrilege> can you publish in a conference journal without presenting at a conference?
19:04:44 <peddie> lolol
19:04:57 <hackrilege> final result = blog. el lame
19:05:10 <ReinH> Ok, this is off topic
19:05:26 <hackrilege> its good to have a public record of the haskell publishing process
19:05:38 <ReinH> This is off topic
19:05:47 <hackrilege> ok, sorry
19:05:49 <hackrilege> end
19:06:16 <ReinH> We don't, we have a public record of your fever dream about being published in the JFP
19:07:15 <Cale> @tell buglebudabey http://cale.yi.org/reflex/Jumps/Jumps.jsexe/
19:07:15 <lambdabot> Consider it noted.
19:07:59 <ReinH> Cale: nice, reflex for examples is a cool idea too
19:08:16 <hackrilege> i didnt know the options i know them know so does anyone reading, im happy you will be able to access my work using cabal, or stack or whatever it is you use, just not github
19:08:24 <benzrf> hey Cale
19:08:35 <benzrf> ive made some more progress on my CAS thingy
19:08:36 <Cale> What's up benzrf 
19:08:38 <Cale> nice
19:08:53 <benzrf> you can do basic rewriting now :>
19:09:32 <Cale> hehe, now you have to make it emit the Coq or Agda proof that the things are equal as you go :)
19:11:08 <benzrf> well, right now it's using augur's simplefp
19:11:15 <benzrf> (which is turing-complete >.>)
19:11:32 <benzrf> oh, it's not "now I have to"
19:11:36 <benzrf> i did it the other way around
19:11:46 <benzrf> i built rewriting on top of having a term backing what you see :)
19:11:52 <benzrf> ok sry this is off topic
19:11:58 <Cale> ah, cool
19:12:43 <Cale> Feel free to join #haskell-offtopic if you think it'd be more suitable :)
19:13:02 <Cale> (if you have anything more to say about it)
19:13:02 <benzrf> hows that different from #-blah
19:13:34 <Cale> It's different in that it has the same ops as #haskell and doesn't have the arbitrary restriction that your client must use TLS
19:20:15 <[k-> how does minJump work?
19:20:35 <[k-> why does having -1 in front of the list make it stop working
19:22:43 <xuxu> if i mentioned everyone in the channel that helped me this evening, it could possibly come off as spamming to get attention, so here's a thank you (without highlighting) to everyone who helped earlier this evening! 
19:22:59 <Cale> [k-: btw, reload, I fixed a bug
19:23:25 <xuxu> monochrom: i do apologize, i wasn't trying to ignore the advice to pattern match, i was just struggling at the time to figure out how to do this
19:23:30 * hackagebot machines-directory 0.2.0.9 - Directory (system) utilities for the machines library  https://hackage.haskell.org/package/machines-directory-0.2.0.9 (bitemyapp)
19:24:16 <Cale> [k-: If you entered an empty list, length xs - 1 would be -1, which would result in some out of range indices
19:25:03 <xuxu> one advantage to using sum the way i did at http://exercism.io/submissions/08765ddeee08417e87c584572354236c is that i don't have to define another function below to unwrap the value, the sum in (sum . square) does this for me
19:25:35 <xuxu> at least, i think it's decent 
19:25:53 <athan> Is there a way to compare NaNs?
19:26:03 <athan> just to see if NaN == NaN I mean :\
19:26:22 <athan> (as a special value for doing matrix computations)
19:26:30 <geekosaur> NaN is not comparable per IEEE754
19:26:32 <[k-> The bug was that it crashes when you pass in a double
19:26:34 <athan> > 1/0 == 1/0
19:26:37 <lambdabot>  True
19:26:41 <athan> > 0/0 == 0/0
19:26:43 <lambdabot>  False
19:26:47 <athan> hm :\
19:26:51 <glguy>   isNaN :: a -> Bool
19:26:56 <ReinH> That is the correct behavior.
19:27:03 <glguy> NaN is an error condition
19:27:18 <athan> :O Thank you glguy!!
19:27:34 <ReinH> xuxu: sum is an elegant way to do that IF YOU UNDERSTAND IT.
19:28:23 <xuxu> was my earlier explanation sufficient?
19:28:39 <xuxu> it operates on something that's foldable and returns some value that's not wrapped in a foldable context. Maybe is a foldable i presume. applying sum Just 3 should give you 3 
19:28:44 <xuxu> ^explanation from earlier
19:29:06 <xuxu> > sum $ Just 3
19:29:09 <lambdabot>  3
19:29:09 <[k-> that was from yesterday o_O
19:29:16 <erisco> :t and . join (zipWith (==) . drop 1) -- is this the elegant test for a list of equal elements?
19:29:18 <lambdabot> Eq a => [a] -> Bool
19:30:05 <augur> benzrf: uh oh
19:31:03 <athan> erisco:  I think lexicographic order is more general
19:31:04 <augur> benzrf: werent you looking into a proof development system of some sort?
19:31:07 <augur> i wrote a thing
19:31:17 <augur> just a brief one, not a full blogpost, but
19:31:21 <athan> :t mconat . zipWith compare
19:31:23 <lambdabot> error:
19:31:24 <lambdabot>     • Variable not in scope: mconat :: ([a] -> [Ordering]) -> c
19:31:24 <lambdabot>     • Perhaps you meant one of these:
19:31:28 <augur> benzrf: https://github.com/psygnisfive/basic-proof-development/blob/master/Main.hs
19:31:29 <erisco> I am just looking for other golfs
19:31:32 <athan> er.. yea
19:31:34 <Gurkenglas> :t (==1) . length group
19:31:36 <lambdabot> error:
19:31:36 <lambdabot>     • Couldn't match expected type ‘a -> Integer’
19:31:36 <lambdabot>                   with actual type ‘Int’
19:31:45 <erisco> length of groupBy is worse imo
19:31:45 <Gurkenglas> :t (==1) . length . group -- <.<
19:31:48 <lambdabot> Eq a => [a] -> Bool
19:31:50 <MarcelineVQ> xuxu: interesting use of sum, alternatively there's: sum $ mapMaybe square [1..64]
19:32:04 <athan> hu
19:32:22 <Gurkenglas> genericLength will shortcut if that's the important part
19:32:25 <erisco> you have to work the whole list, it isn't as simple
19:32:52 <athan> that's bananas -- :v from far left field
19:33:12 <erisco> how so? I would guess it first leads to a compiler error due to ambiguity
19:33:20 <erisco> so what integer type do you pick?
19:33:33 <Cale> :t null . drop 1 . group -- slightly different function
19:33:35 <lambdabot> Eq a => [a] -> Bool
19:33:52 <Gurkenglas> Oh right been a while I last used that, you also have to annotate with Natural. Yep that one's better ^^
19:34:22 <erisco> looks good Cale
19:34:33 <MarLinn> > null . drop 1 . group $ []
19:34:35 <lambdabot>  True
19:34:52 <MarLinn> nice
19:35:01 <Cale> It's arguably more natural in that all the elements of the empty list are equal.
19:35:25 <erisco> > (and . join (zipWith (==) . drop 1)) [] -- same thing, this makes sense
19:35:27 <lambdabot>  True
19:36:29 <erisco> the proposition is that "∀x,y∈L;x=y"
19:39:38 <erisco> is Natural Peano nats?
19:49:37 <xuxu> MarcelineVQ: thank you for that tip!
19:50:17 <xuxu> and there is also Data.Maybe.fromJust
19:52:35 <[k-> I mentioned that yesterday. fromJust is a partial function
20:01:42 <xuxu> [k-: you must be in a different time zone :)
20:02:18 <xuxu> thanks for mentioning that you mentioned that, i see that message now
20:04:33 <cynode> Could anyone tell me what this means: main = (>>= (readFile "foo") (writeFile "bar"))? I know it doesn't work, and that I should use (>>=) instead, but what is it actually trying to do?
20:04:44 <[k-> thanks for mentioning that you appreciated my mention that I mentioned fromJust yesterday 
20:06:48 <pavonia> cynode: The would be equivalent to \x -> x >>= (readFile "foo") (writeFile "bar"), which is a type error
20:06:56 <pavonia> *That
20:08:42 <MarLinn> cynode: You could write it as (>>=) (readFile "foo") (writeFile "bar") as you mention or as (readFile "foo") >>= (writeFile "bar"). The second form is a bit clearer.
20:08:45 <[k-> (I was trying to be funny, failed again!)
20:09:13 * erisco watches [k- fly away
20:09:16 <MarLinn> You can think of >>= (at least in this context) as sequencing the two actions. At the same time a value is transported - in this case, the file content.
20:10:04 <cynode> My haskell reading skills are still pretty poor I'm afraid. It's returning a function that takes one parameter? Does the type error come because >>= is expecting two parameters?
20:10:10 <geekosaur> the other thing it's doing is section syntax
20:11:00 <pavonia> :t (readFile "foo") (writeFile "bar")
20:11:02 <lambdabot> error:
20:11:02 <lambdabot>     • Couldn't match expected type ‘(String -> IO ()) -> t’
20:11:02 <lambdabot>                   with actual type ‘IO String’
20:12:03 <pavonia> cynode: ^ that is your first error. Even if that would typecheck, the types of main and the resulting function wouldn't match
20:13:35 <cynode> I think I'm missing something. Is (readFile "foo") (writeFile "bar") a complete expression? It looks like two separate expressions just put next to each other.
20:14:29 <pavonia> An expression of the form x y in Haskel means a function x applied to an argument y
20:14:36 <geekosaur> that is how function application works in Haskell
20:14:50 <cynode> Oh right. I see it now.
20:14:53 <pavonia> cynode: In you case x = (readFile "foo") and y = (writeFile "bar")
20:15:01 <geekosaur> just like `readFile "foo"` itself, but the function is a parenthesized expression here
20:15:58 <cynode> So the type error happens because it's trying to apply/call an IO String?
20:16:33 <geekosaur> there's a couple other possible places it could detect a type error
20:16:41 <geekosaur> I think
20:17:20 <geekosaur> hm no, `IO a` unifies with anything so the section wouldn't be a type error
20:17:28 <geekosaur> just peculiar
20:17:54 <cynode> geekosaur: Ok, no idea what that means. :)
20:18:17 <geekosaur> [11 03:06] <pavonia> cynode: The would be equivalent to \x -> x >>= (readFile "foo") (writeFile "bar"), which is a type error
20:19:14 <geekosaur> that expression is what the value of `main` is; a function (which then has the other type error embedded within it). but the type of `main` is `IO a` for any a, and functions are entirely legitimate (but not useful there_
20:21:37 <cynode> So let me see if I've got this: with the "main" I originally gave, it tries to declare main as a function (which it shouldn't be because main is an IO) that tries to call an IO String (which doesn't work because IO String is not a function). Right?
20:22:54 <hamme> So main :: IO String?
20:23:13 <MarLinn> uhm...
20:23:29 <MarLinn> I think it's easier to think "bottom up"
20:23:31 * hackagebot hs-di 0.2.2 - Dependency Injection library for Haskell  https://hackage.haskell.org/package/hs-di-0.2.2 (Wizek)
20:23:33 * hackagebot fixfile 0.6.0.0 - File-backed recursive data structures.  https://hackage.haskell.org/package/fixfile-0.6.0.0 (rev_null)
20:24:19 <hamme> Bottom-up?
20:24:49 <MarLinn> (readFile "foo") has type (IO String), i.e. an IO action that returns a String. (writeFile "bar") has type (String -> IO ()), i.e. a function that takes a String and returns an IO-action.
20:25:44 <MarLinn> you can not apply the first to the second because the second has the wrong type. That has nothing to do with IO per se
20:26:05 <hamme> Yeah IO String !~ String
20:26:26 <[k-> but you are applying the second to the first!
20:26:45 <cynode> MarLinn: Can't you not apply the first to the second because the first isn't a function? It's an IO?
20:28:19 <MarLinn> take a function like (++). Type: String -> String -> String. You can't apply that to an Int. No IO, but still no application
20:28:55 <MarLinn> (readFile "foo") takes no "input", so it can't be applied to anything 
20:29:28 <pavonia> It's not a function
20:29:28 <hamme> (You can't apply things to readFile "foo")*
20:29:56 <MarLinn> yes
20:30:12 <MarLinn> (writeFile "bar") takes a String as "input", so if you tried to apply it to (readFile "foo"), IO would indeed be a problem
20:31:45 <pavonia> But it's the other way around in this case, they're trying to apply (readFile "foo") to the writeFile thing
20:32:16 <hamme> Here's a picture to try and help the problem -> https://vgy.me/F1BEGY.png
20:32:19 <MarLinn> yup. I was just trying to use it as an example how IO could be the problem
20:32:58 <hamme> Anyways, here's a picture for what MarLinn just said -> https://vgy.me/iHx2gv.png
20:33:18 <hamme> Recall that type String = [Char]
20:33:58 <erisco> this is a delicious word salad
20:34:09 <dmj> glguy: I can't use unsafeWith :( since there is no Storable a => a for my Vector a
20:34:53 <cynode> It's the same problem as trying to apply something to ((++) "first" "second"), right? Since the result of that is a String, not a function, you can't apply it.
20:35:22 <MarLinn> erisco: Are you saying my efforts were misguided? Don't have a problem if you do...
20:35:35 <hamme> yes
20:36:07 <hamme> Not sure what the template is for what should be answered, or should be further sub-socrate'd
20:37:36 <pavonia> Maybe I'm mistaken, but you apply a function to an argument, not the other way around, no?
20:38:03 <MarLinn> The last missing piece is the type of (>>=). In this case it can be regarded as (IO a -> (a -> IO b) -> IO b). Now shake everything like you do with normal functions and you get a nice main :: IO ()
20:38:13 <hamme> You apply values to functions
20:38:29 <glguy> No, you apply functions to values
20:39:04 <[k-> is there a difference?
20:39:05 <hamme> Uh, say what you think, not what you mean?
20:39:31 <glguy> The difference is that if you say that you're applying x to y that someone will know what you meant
20:39:37 <hamme> Anyways, functions take values, values don't take functions
20:39:59 <erisco> wrong again, functions are values :D
20:40:33 <hamme> But sometimes functions take functions as values! What will SPJ think of next!
20:40:46 <MarLinn> and all data is functions, so there is no data, only ... values. Argh, confusion! ;p
20:40:54 <hamme> Hum
20:41:41 <glguy> dmj: That sounds like a deal breaker
20:41:42 <[k-> application is only possible when the receiver is a function?
20:41:46 <hamme> I think a value is one datum of many data
20:42:00 <hamme> yes [k- 
20:42:13 <hamme> and uh cynick 
20:42:43 <hamme> cynode, 
20:43:04 <glguy> What's the original question, anyway?
20:43:21 <hamme> > It's the same problem as trying to apply something to ((++) "first" "second"), right? Since the result of that is a String, not a function, you can't apply it.
20:43:25 <lambdabot>  <hint>:1:78: error: parse error on input ‘,’
20:44:16 <pavonia> I'd say it's the same problem as trying to apply ((++) "first" "second") to some value
20:44:17 <MarLinn> The original original was <cynode> Could anyone tell me what this means: main = (>>= (readFile "foo") (writeFile "bar"))? I know it doesn't work, and that I should use (>>=) instead, but what is it actually trying to do?
20:44:52 <hamme> Oh, I can say what that means
20:44:59 <glguy> So we've covered that it should have been: (>>=) (readFile "foo") (writeFile "bar")
20:45:09 <hamme> yes
20:45:20 <glguy> and that (>>= (readFile "foo") (writeFile "bar"))  is   (>>=) (writeFile "bar") (readFile "foo") ?
20:45:29 <glguy> err, no, that was wrong
20:45:35 <glguy> missed a parenthesis :)
20:46:03 <erisco> lets simplify the syntax and get that out of the way, and forget it entirely
20:46:52 <hamme> ok
20:47:07 <erisco> unless it is syntax we're confused on … pick between syntax or monads
20:47:16 <cynode> It
20:47:22 <cynode> It's the syntax I was confused on.
20:47:35 <cynode> I think.
20:47:35 <hamme> Uh, (>>=) is an infix
20:47:39 <glguy> cynode: Were you trying to use >>= in prefix lisp notation?
20:47:42 <hamme> it goes between things
20:48:24 <erisco> (>>= x) y ≡ y >>= x   (>>= x y) z ≡ (>>= (x y)) z ≡ z >>= (x y)
20:48:28 <cynode> glguy, Yes!
20:48:37 <glguy> Some languages you can write things like: (+ 1 2 3) to mean the sum of 1, 2, and 3. But that's not how Haskell works.
20:48:43 <hamme> so like  (readFile "foo") >>= (writeFile "bar")
20:49:01 <glguy> In Haskell you can use operators (things made up of symbols) in either infix position:   1 + 2
20:49:07 <glguy> or in prefix position:  (+) 1 2
20:49:15 <hamme> (>>=) (readFile "foo") (writeFile "bar")
20:49:24 <erisco> or this thing  (+ 1) 2
20:49:33 <hamme> ^ Be careful with that
20:49:41 <erisco> or this  (2 +) 1
20:49:53 <hamme> something like (/1) 2 != (1/) 2
20:51:07 <erisco> someone already explained it correctly as  (? m) ≡ \x -> x ? m
20:51:31 <glguy> cynode: In Haskell, function application "binds tighter" than any infix operator, so:   (a b + c d)  is   ((a b) + (c d))
20:51:54 <erisco> should we go over infixities as well? :P
20:52:12 <hamme> you mean like how they associate?
20:52:12 <cynode> Ok, so I get that functions made of symbols are infix. And that infix can be used as prefix by surrounding it as parenthesis. What I wasn't clear on was why (>>= (readFile "foo") (writeFile "bar")) doesn't call >>=. I think I have that now...
20:52:32 <erisco> an infixity is an association and a precedence
20:52:41 <erisco> and an operator of course
20:52:46 <hamme> Well
20:52:59 <hamme> (>>= (readFile "foo") (writeFile "bar"))
20:53:12 <hamme> (>>=) not in proper prefix form
20:53:20 <erisco> cynode, "doesn't call >>=" this is an odd thing to say, what do you mean?
20:53:34 <[k-> is this  (>>= (readFile "foo") (writeFile "bar"))  the same as  (>>= (readFile "foo" (writeFile "bar"))) ?
20:53:53 <erisco> [k-, yes
20:54:00 <[k-> aha!
20:54:06 <geekosaur> hamme it's in section form
20:54:27 <geekosaur> it's short for: \x -> x >>= (readFile "foo") (writeFile "bar")
20:55:06 <Clint> @pl \x -> x >>= (readFile "foo") (writeFile "bar")
20:55:07 <lambdabot> (readFile "foo" (writeFile "bar") =<<)
20:55:22 <hamme> Which isn't "what you mean", on top "not typechecking"
20:55:23 <erisco> the price of syntactical richness
20:55:43 <[k-> Be like scala!
20:55:49 <cynode> erisco, I mean that I expected it to just call >>= the same way that (>>=) (...) (...) calls >>=. The same way that (myFunction (...) (...)) would call myFunction.
20:56:22 <cynode> (Assuming that myFunction took two arguments of course. Let's not go into currying please.)
20:56:39 <geekosaur> cynode, but we like section syntax. it's syntactically the same kind of thing as (+1)
20:57:07 <dmj> scala :( 
20:57:21 <erisco> cynode, mm, it is more clear to talk about equivalence, so you might say "x is not an equivalent expression to y"
20:57:28 <geekosaur> being able to partially apply *operators* as well as functions is convenient
20:58:27 <hamme> I finally see where the typechecking error comes from
20:59:08 <cynode> Just read the first part of https://wiki.haskell.org/Section_of_an_infix_operator and it makes much more sense now. Since >>= is an infix operator, it's placing the second argument (writeFile "bar") on the left side of the >>=?
20:59:28 <erisco> no
20:59:54 <erisco> (>>= x y) is (>>= (x y)) is  \a -> a >>= (x y)
21:00:15 <cynode> Rats. Thought I had it there.
21:00:16 <erisco> (>>=) x y  is completely different
21:00:19 <geekosaur> (?z) is \x -> x ? z. (z?) is \x -> z ? x
21:00:25 <hamme> Almost
21:00:46 <hamme> hum
21:01:01 <hamme> So what would happen in (1 + 2 3)
21:01:16 <geekosaur> (1 + (2 3))
21:01:20 <hamme> And?
21:01:33 <erisco> ghc writes you an angry letter
21:01:37 <geekosaur> (which could even typecheck if there were a Num instance for functions)
21:02:01 <geekosaur> some years ago lambdabot even had such an instance loaded
21:02:10 <geekosaur> it was a good way to confuse people :p
21:02:32 <hamme> This is a lot like the Fun with Types lectures
21:02:34 <erisco> using Church encoding? not sure how that works for negatives
21:03:23 <dzack> anyone happen to know of a resource with a lot of math-y Haskell examples?
21:03:39 <erisco> using repeated application? what is the interpretation of negatives?
21:03:55 <hamme> Last time I went that way I used a Tuple
21:04:06 <dzack> i'm thinking of things like representing lines and calculating intersections, or maybe representing Q and defining multiplication. That sort of thing
21:04:07 <geekosaur> erisco, no, not a function representation of numbers
21:04:09 <hamme> (positive, negative) :: (Nat, Nat)
21:04:22 <erisco> oh, (Num b) => a -> b  ?
21:04:51 <hamme> So it'd be (pos, neg) where pos < neg
21:04:51 <geekosaur> let instance Num a => Num (b -> a) where fromInteger n = pure (fromInteger n); (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*)
21:05:10 <geekosaur> not a complete instance there, I just took the first one I found in my log
21:05:19 <erisco> mhm, okay
21:05:38 <erisco> so with overloaded literals I suppose that would work … terrifying :P
21:05:40 <hamme> GHC wants abs, and signum
21:05:54 <hamme> Anyways
21:05:55 <geekosaur> yes, ghc warns about that these days
21:06:10 <hamme> What happens when you have (2 3) in 1 + 2 3
21:06:16 <hamme> cynode, 
21:06:29 <erisco> 2 is a function which returns 2
21:06:34 <erisco> which is applied to 3, yielding 2
21:06:40 <erisco> then you have 1 + 2
21:06:44 <erisco> which is … 3
21:07:11 <cynode> hamme, erisco, others... Ok, let me try again. >>= has a lower precedence than function application. So it tries to call whatever (readFile "foo") returns which isn't a function. That's the first problem. Then, if that worked, it would return a curried >>=, which due to section syntax would place whatever argument you provide it with on the left si
21:07:11 <cynode> de of the operator.
21:07:12 <hamme> erisco, we aren't defaulting to Num (b -> a) where <something const>
21:07:46 <hamme> I don't see anything wrong in that
21:07:50 <erisco> hamme, well what is the question then? (2 3) is a type error unless 2 is a function
21:08:29 <hamme> Yes, as an analogous example of applying values to a value doesn't work
21:09:23 <geekosaur> except when the compiler is doing things to the value
21:09:24 <erisco> cynode, based on your vernacular I do not think you're grasping the nature of it, particularly there is no "tries to call"
21:09:28 <hamme> So yeah, if that didn't fail the type checker you'd be left with \a -> a >>= <whatever this returned>
21:10:36 <geekosaur> numeric literals are replaced with calls to fromRational or fromInteger, depending on whether they have a decimal point in them or not (respectively). there are ghc extensions to do similar things to string literals and list literals
21:10:52 <erisco> cynode, the correct thing to do is to think in equivalent expressions, and to understand what the expression is you need to understand the syntax and precedence and so-forth, which you seem to be catching on to
21:11:32 <hamme> Also, I think Haskell attempts to "apply" not "call"
21:11:54 <erisco> I do not understand what this "attempts to" is either
21:12:34 <glguy> erisco: Well... In the case of a type error, applying a non-function, it attempts to, fails, and generates an error :)
21:12:44 <glguy> comma comma comma
21:12:49 <hamme> during typechecking
21:13:26 <erisco> it attempts to unify the types and fails, okay
21:13:50 <erisco> so are we having a discussion on how the compiler infers types? how it checks types?
21:13:55 <hamme> Uh
21:13:55 <monochrom> > True "x"
21:13:58 <lambdabot>  error:
21:13:58 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
21:13:58 <lambdabot>                    with actual type ‘Bool’
21:14:15 <hamme> Why you can't apply values to concrete values
21:14:17 <monochrom> that would be the kind of type error for using non-functions as functions
21:14:24 <hamme> > 1 2
21:14:27 <lambdabot>  error:
21:14:27 <lambdabot>      • Could not deduce (Num t0)
21:14:27 <lambdabot>        from the context: (Num (t -> t1), Num t)
21:14:40 <hamme> > "the" 1
21:14:43 <lambdabot>  error:
21:14:44 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
21:14:44 <lambdabot>                    with actual type ‘[Char]’
21:15:04 <monochrom> I don't know what is the meaning of "apply values to concrete values"
21:15:20 <monochrom> In fact let me be bolder. I don't think it can have a meaning.
21:15:50 <hamme> You can apply values to other values, if the latter are functions.
21:16:10 <erisco> cynode, it may sound pedantic, but I think a source of confusion is the way in which you are trying to answer the question "what is really going on?", which I think was your premise
21:16:48 <monochrom> No, former, not latter.
21:16:57 <monochrom> We write like "sin 3" not "3 sin".
21:17:03 <erisco> cynode, if you're looking for an answer as some form of "it does this and that" I don't think that answer will be particularly helpful
21:17:21 <glguy> hamme: You still apply functions to values
21:17:33 <hamme> but application in lambda calc is App Lamba Term
21:18:19 <monochrom> What is Lambda doing there in application?
21:18:21 <erisco> cynode, the complete reasoning has been said a few times now, but I'll go again. The first step is to get out of the syntax quagmire so it is clear what the expression actually is
21:18:37 <erisco> cynode, by "get out of the syntax quagmire" I mean to find a normal form, a simpler form
21:19:22 <monochrom> I am afraid of asking "where did you read this from?" because I am sure there are many crackpots on the Internet who would totally write this misguided crap.
21:19:32 <pavonia> Is there a tool to create the headers for module as seen here? http://hackage.haskell.org/package/HTTP-4000.2.17/docs/src/Network-HTTP-Base.html
21:19:45 <erisco> cynode, "sections" are a syntax feature, but unnecessary, so get rid of it. (? m) is \x -> x ? m  which means that  (>>= (readFile "x") (writeFile "y")) is  \a -> a >>= (readFile "x") (writeFile "y")
21:20:07 <erisco> cynode, the way in which I am reasoning right now is how we should be reasoning about it
21:20:22 <monochrom> Also, if anything, you should be citing typed lambda calculus, not just lambda calculus.
21:20:39 <erisco> if that rewrite is still confusing then perhaps we're confused about precedence … precedence is a syntax feature but not necessary, so lets get rid of it
21:20:44 <monochrom> There are a few things in untyped lambda calculus that Haskell will refuse to do.
21:20:48 <erisco> to get rid of it we will use parentheses always
21:21:21 <erisco> (>>= (readFile "x") (writeFile "y")) is  (>>= ((readFile "x") (writeFile "y")))  because that's just how section notation works
21:21:58 <erisco> and we can say  (? m) is  \x -> (?) x m
21:22:20 <erisco> so this leaves us with  \a -> (>>=) a ((readFile "x") (writeFile "y"))
21:22:44 <monochrom> @type (&& not True)
21:22:47 <lambdabot> Bool -> Bool
21:23:33 * hackagebot posix-acl 0.2.0.1 - Support for Posix ACL  https://hackage.haskell.org/package/posix-acl-0.2.0.1 (NicolaSquartini)
21:23:56 <erisco> so now we can ask what is the difference between  (>>=) (readFile "x") (writeFile "y")  and  \a -> (>>=) a ((readFile "x") (writeFile "y"))  which should be starkly clear now
21:23:58 <monochrom> @type (>>= (readFile "x") (writeFile "y"))
21:24:00 <lambdabot> error:
21:24:00 <lambdabot>     • Couldn't match expected type ‘(String -> IO ()) -> a -> m b’
21:24:00 <lambdabot>                   with actual type ‘IO String’
21:24:18 <erisco> monochrom, it is acknowledged that does not type check
21:24:29 <monochrom> ah OK
21:24:46 <cynode> erisco, Best I can tell then, my last explanation attempt was right but with the wrong terms?
21:25:08 <lerax> Hey guys! All are you ok? Anybody with concerns to build correlated material between discrete mathematics and haskell? I'm building for now a new repository for Discrete Mathematics using Haskell for myself and for my other coleagues. (sorry for the bad english, i'm not a native speaker) I'm starting today: https://github.com/ryukinix/discrete-mathematics
21:25:30 <erisco> cynode, I am not sure because your terminology is not clear to me, but you can judge if the explanations match
21:25:37 <monochrom> Since it is a type error, any story that imagines how to evaluate or execute it is wrong. it is a type error. you won't ever get that far.
21:26:00 <monochrom> Instead, you should look at the grammar and how the computer parses this thing.
21:26:32 <monochrom> The computer builds a parse tree and then finds that the parse tree is a type error. So what you need to look at is the parse tree.
21:26:43 <lerax> If somebody can review the content and give me some feedback I'll be glad. Any opinion is very welcome, critics and helpfull comments too.
21:27:08 <erisco> yes, exactly, that is what I mean by getting the syntax out of the way so we can see the actual expression
21:27:26 <erisco> dispell the unnecessary features such as sections, precedence, the lot
21:27:57 <monochrom> my example (&& not True) could have helped.
21:29:46 <cynode> erisco, So it all boils down to trying to "call" a value. Or apply a value to something. (If we use glguy's definition of apply.)
21:30:06 <glguy> Ha, no, I can't claim to have invented the concept of function application
21:30:50 <cynode> glguy, of course not. :) Just trying to be clear.
21:31:18 <monochrom> No, it boils down to parsing and building the parse tree.
21:31:47 <monochrom> Draw a parse tree on some online whiteboard. There is no point talking more until you do this.
21:33:34 <kody1> ?wiki Monad
21:33:34 <lambdabot> http://www.haskell.org/haskellwiki/Monad
21:36:08 <dmj> m-m-m-m-mooonads
21:37:15 <cynode> monochrom, You were saying that applying a value is prevented by the type system, right? And that because of this going any further in the explanation has no real meaning?
21:40:15 <erisco> cynode, that is part of it, there are different ways to boil it down, if we mean normalising
21:40:57 <erisco> cynode, I was aiming to normalise to a notation like in Lambda Calculus, where you have abstraction, application, and variables
21:41:09 <hamme> b-b-b-b-burritos, dmj 
21:41:12 <erisco> so there is three parts it boils down to
21:42:18 <erisco> from this notation the actual expression is much clearer, which is a significant source of the confusion
21:42:33 <erisco> and by "actual expression" I mean the same as what monochrom is talking about
21:43:00 <erisco> we have to get from syntax, from a line of characters, to a parse tree / abstract syntax tree, or what I have been calling "the expression"
21:43:27 <erisco> then once we know precisely what that is we can talk about it
21:44:17 <cynode> Ok, I'm 99.9% sure I understand it now. Good enough for me. If there's anything that I've got wrong that I don't realize, I'm bound to come across it in the future as I learn more about Haskell. Thank you all for your help!
21:46:26 <Gurkenglas> How do I asum two MaybeT (StateT S []) values using []'s logic?
21:47:53 <schell> in your opinion is “fix $ \f -> f >>= return” equivalent to “fix $ \f -> f” ?
21:48:17 <erisco> I wouldn't seek an opinionated answer on that
21:48:34 <schell> erisco: is it law?
21:48:53 <erisco> your question reduces to asking if  \f -> f >>= return  is equivalent to  \f -> f
21:49:37 <schell> erisco: right - it seems the evaluation would be equivalent - can i cancel out the “>>= return” since f recurses infinitely?
21:50:45 <erisco> actually I don't know if fix is injective, maybe not
21:51:10 <hamme> :t fix
21:51:13 <lambdabot> (a -> a) -> a
21:51:21 <schell> ericsco: i thought i needed it - i see now i don’t need it to ask the question
21:51:48 <schell> i can just ask is \f -> f equivalent to \f -> f >>= return
21:52:01 <erisco> I have retracted my certainty on that
21:52:04 <hamme> hum
21:52:23 <hamme> There is a difference between the two
21:52:29 <erisco> asking if  abs x == abs y  does not reduce to asking if  x == y
21:52:31 <peddie> kosh_: it seemed silly that this wasn't super easy already, so I put together https://github.com/peddie/hmatrix-fftw along with an extended version of vector-fftw that does multidimensional transforms.  I added a few basic doctests, but there may still be significant bugs.  hope that is helpful
21:52:47 <Gurkenglas> fix isn't injective
21:52:48 <erisco> you need injectivity, and I do not know if it is
21:53:25 <hamme> I know the difference between \f -> f, and \f -> f >>= return
21:53:30 <Gurkenglas> You don't need injectivity to say that x == y implies fix x == fix y
21:53:31 <schell> hamme: yes, there is - but it seems to me to be a difference similar to 1/0 and 1/0 + 1
21:53:44 <erisco> that isn't the direction we're going in Gurkenglas 
21:53:49 <hamme> oh
21:53:55 <hamme> so what's injective
21:54:03 <erisco> one-to-one
21:54:06 <hamme> oh
21:54:22 <hamme> is identity injective and surjective?
21:54:35 <erisco> yes
21:54:42 <hamme> is the other thing injective
21:55:49 <Gurkenglas> erisco, the direction of "your question reduces to" that we need is the direction that doesn't need injectivity. Although if the answer to the question wasn't known, we'd need both, I guess.
21:56:30 <erisco> Gurkenglas, the question was  fix f == fix g  and I said it reduced to  f == g
21:57:03 <erisco> however, if we do know f == g, then we know  fix f == fix g, so your approach isn't useless here
21:57:05 <schell> where g = f >>= return and f = f
21:57:15 <Gurkenglas> But that's what I'm saying :(
21:58:31 <schell> at the bottom of this question i’m trying to simplify a monad proof by avoiding a recursive path
21:58:50 <hamme> uh
21:59:17 <schell> i’m new to proofs so i’m a bit stuck
21:59:20 <erisco> Gurkenglas, sorry
21:59:24 <Gurkenglas> A question reduces to another if an answer to the second gives an answer to the first. Here a "yes"-answer to the second gives a yes-answer to the first, but a no-answer to the second wouldn't give a no-answer to the first. So the question technically doesn't reduce that way, but since monad laws give us "\f -> f >>= return" = "\f -> f", we only need the yes-answer part ^^
22:01:14 <schell> if you guys are interested in the specific discussion it’s part of an issue thread on github: https://github.com/schell/varying/issues/8
22:01:46 <Gurkenglas> How do I get at the asum in a monad transformer stack that's hidden beneath another Alternative?
22:01:50 <hamme> https://vgy.me/YYmip3.png
22:02:50 <hamme> https://vgy.me/DyOsUl.png
22:02:53 <Gurkenglas> For other mtl classes, I can lift out manually when I have the same class twice, but specifically asum doesn't look like that'll work
22:03:07 <hamme> The uh, inverse seems like they work, schell erisco 
22:03:47 <schell> hamme: i’m not sure what you posted there - is that coq? (wild assumption)
22:04:14 <hamme> Haskell
22:04:23 <erisco> I am not sure what is being shown here either
22:04:29 <hamme> The uh
22:05:43 <hamme> \fa -> fa `cobind` coreturn == \fa -> fa `bind` return
22:05:51 <hamme> On the type level
22:06:05 <hamme> So does that mean injective?
22:06:37 <erisco> are you asking if your "f" is injective?
22:06:38 <shachaf> What is injective?
22:06:43 <erisco> I am not grasping your question here
22:08:00 <erisco> I was wondering if fix was injective
22:08:24 <erisco> to say that questions of  fix f == fix g  reduce to questions of  f == g  relies on fix being injective
22:08:25 <monochrom> @type fix (\f -> f >>= return)
22:08:26 <lambdabot> Monad m => m b
22:08:38 <hamme> huh
22:08:43 <erisco> though as Gurkenglas points out, if we know f == g then we know fix f == fix g by substitution
22:08:59 <Gurkenglas> by well-definedness! :D
22:09:05 <monochrom> don't forget types
22:09:10 <erisco> and we know \f -> f >>= return is the same as \f -> f
22:09:23 <erisco> so we know they are also the same under fix
22:09:35 <monochrom> @type \f -> f >>= return
22:09:37 <lambdabot> Monad m => m b -> m b
22:10:44 <monochrom> You only need Leibniz.
22:10:46 <hamme> so the function being surjective doesn't matter
22:11:42 <erisco> think about 2*x == 2*y, does it matter if (2*) is surjective?
22:11:59 <hamme> ok
22:12:28 <erisco> compare to  abs x ≡ abs y  does injectivity matter?
22:13:10 <hamme> I tihnk so
22:13:35 <monochrom> In a few months, it will be flu season again, and injection will matter.
22:13:41 <erisco> find the example where  abs x = abs y  but  x ≠ y
22:13:51 <hamme> 1, -1
22:13:58 <monochrom> On the bright side, there will also be Black Friday sales.
22:14:02 <erisco> haha, and surjective injection will matter :P
22:14:41 <hamme> I think that half of the month has become violently commercialised, monochrom 
22:15:01 <hamme> I don't think people win unless they order online
22:15:07 <erisco> Gurkenglas, what is your counter-example for fix?
22:16:22 <hamme> afaik, abs is idempotent, so fix (abs y) == fix (abs y), iff x == y || -x == y
22:16:34 <hamme> er
22:17:03 <erisco> well, that is a type error, so I guess they're both erroneous :D
22:17:11 <hamme> yeah
22:17:15 <hamme> I caught the mistake
22:17:27 <hamme> fix abs y == fix abs y, iff x == y || -x == y
22:17:43 <erisco> :t fix abs
22:17:44 <lambdabot> Num a => a
22:18:09 <hamme> So uh, does fix ever become a value
22:18:20 <erisco> fix is already a value, it is a function
22:18:39 <hamme> does it become a value that can be showed
22:18:41 <monochrom> you want to give a non-strict function to fix for maximum usefulness.
22:18:42 <erisco> fix abs y  is a type error again, unless we're accounting for function numbers again
22:18:52 <hamme> does it hit normal form
22:19:39 <Gurkenglas> erisco, fix (1:) == fix ((1:) . (1:))
22:20:07 <erisco> hehe, looks good :)
22:20:14 <monochrom> nice
22:20:38 <Gurkenglas> though the way I arrived at the sense that fix mustnt be injective is that (a -> a) is larger than a
22:20:57 <erisco> hamme, fix is recursion, i.e. if you abstract recursion itself you get fix, so if you ever found recursion helpful then fix is equally helpful
22:21:34 <erisco> though in the pragmatic sense, when you might use fix rather than recursion (syntactically), see monochrom's response
22:21:45 <hamme> fixed-points are neat, but I want to get of Mr. Fix's Wild Ride, erisco 
22:21:56 <monochrom> You have just inspired me to come up with more involved examples. Basically it is very easy to write two programs equivalent but using different recursive approaches to do their same job.
22:23:08 <hamme> So, like that guy that did the tour talk about all kinds of catamorphisms?
22:23:10 <erisco> hamme, I am not familiar with this
22:23:36 <monochrom> I don't limit myself to all kinds of catamorphisms.
22:23:46 <hamme> http://imgur.com/gallery/Wxzbl
22:24:20 <erisco> lol, bit of a stretch to think someone would know that :P
22:25:10 <monochrom> But I know a certain kind of catmorphism that I won't reveal until Halloween
22:25:41 <hamme> It's where the skeleton wars, and friends came from
22:25:54 <hamme> in skelebones we trust
22:25:59 <ReinH> hamme: it is not a wild ride, it is a very rigorous and well behaved ride
22:26:42 <hamme> This is mathematics, the definition of well-behaved, and very rigorous are not human-friendly
22:27:15 <int-e> Are there any extensions I should consider for lambdabot besides LambdaCase (I'm inclined towards enabling it) and TypeApplications (I'm unhappy about the white-space sensitive @, so inclined not to enable it, but could be swayed if enough people want it)?
22:27:20 <erisco> humans are fickle, never mind them
22:28:32 <hamme> I..
22:28:35 <schell> well i like the idea by the definition of the right identity monad law, \f -> f is equivalent to \f -> f >>= return
22:28:55 <hamme> You some kind of deity?
22:29:02 <schell> can i use the right identity while proving the right identity?
22:29:04 <shachaf> int-e: You should fix @wiki to use the new wiki URL style.
22:29:08 <schell> oh god it’s happening again
22:29:20 <int-e> @wiki bla
22:29:20 <lambdabot> http://www.haskell.org/haskellwiki/bla
22:30:33 <int-e> so just https://wiki.haskell.org/bla instead?
22:30:51 <shachaf> Maybe it's not very important, since there's a redirect.
22:30:54 <shachaf> I just noticed it earlier.
22:31:03 <int-e> it's easy enough to change.
22:31:09 <int-e> but I want to do it right :P
22:31:35 <shachaf> Yes, that's the new URL format as far as I can tell.
22:31:51 <hamme> What's the point to the proof of right identity if you already have the proof for right identity
22:32:16 <hamme> Better proof?
22:32:25 <hamme> Newtype instance?
22:32:43 <int-e> @learn
22:32:43 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
22:32:50 <erisco> if you're working with numbers then you ought to prove the same thing in a dozen ways
22:32:56 <schell> well my monad has a possible path of infinite recursion, which i *think* i can simplify to \f -> f 
22:32:57 <int-e> oh... there's a lot of those links hardcoded in there!
22:33:19 <schell> so if i assume the right identity is true _while i prove it_ then i can ignore that path
22:33:21 <schell> i think
22:33:45 <shachaf> int-e: I think @where deprecates most of those anyway.
22:33:51 <shachaf> @where learn
22:33:51 <lambdabot> http://www.seas.upenn.edu/%7Ecis194/spring13/index.html | https://github.com/bitemyapp/learnhaskell | https://github.com/NICTA/course/
22:34:36 <shachaf> @where+ learn https://wiki.haskell.org/Learning_Haskell
22:34:36 <lambdabot> I will never forget.
22:34:58 <schell> another question i should ask is how do you properly “reduce” a recursive function in a proof, since every substitution ends up inserting another function body?
22:35:13 <erisco> induction
22:35:53 <erisco> and coinduction, which I do not understand and have never seen formalised
22:35:56 <schell> erisco: so like - zap it with electricity? ;)
22:36:02 * schell looks up induction
22:36:14 <int-e> nitrix: Sorry, I was at a workshop last week, so I didn't have time for looking at your pull request.
22:36:25 <schell> i’ve been attempting the feynman method
22:36:57 <elliptic00> Hi, How to write a function without any arguments?   e.g. in Java    void fun() { do sth }
22:37:22 <erisco> elliptic00, there is no such thing
22:37:34 <glguy> elliptic00: What would such a thing "do"?
22:37:38 <ReinH> That's just a value.
22:37:46 <ReinH> (Specifically, a value that is not a function.)
22:37:54 <elliptic00> I try   fun::() 
22:37:57 <erisco> if you want to "do something", i.e. IO, then look to the various IO libraries, starting with IO in base
22:38:01 <elliptic00> but it does't work
22:38:08 <ReinH> There are only two fun :: (): fun = () and fun = undefined
22:38:17 <erisco> elliptic00, maybe you should read an introductory Haskell book, there are good ones
22:38:30 <ReinH> Neither of them do anything useful
22:38:43 <ReinH> and neither of them are a function
22:39:00 <erisco> @where learn elliptic00
22:39:00 <lambdabot> https://wiki.haskell.org/Learning_Haskell
22:39:19 <elliptic00> thx
22:39:22 <hamme> A function without arguements, how so, elliptic00 
22:39:48 <ReinH> hamme: there is no such thing
22:39:52 <erisco> probably faster to read these basics in an ebook than to rehash them piecemeal here
22:40:03 <hamme> Yes
22:40:11 <elliptic00> thx guys.
22:40:28 <hamme> But, there's many "no arguements"
22:40:43 <ReinH> Neither of them *is* a function, rather.
22:41:40 <erisco> short story is, at one point there was something called "procedure" which was a named block of code you called which did side effects
22:41:46 <erisco> a procedure had no arguments
22:41:55 <erisco> separately there were functions which did have arguments
22:42:14 <pavonia> Bah, why is GHCi compiling a certain module again and again even if it doesn't have changed :/
22:42:23 <erisco> then instead of having two keywords, they simplified to just "function" with possibly zero arguments as equivalent to "procedure"
22:42:33 <erisco> but they're still procedures
22:42:45 <erisco> and Haskell has none of those
22:43:09 <hamme> So, procedures don't ask for arguements because they use side-effects to supplement them?
22:43:43 <erisco> I wasn't programming at the time, so I don't know what the thinking was
22:44:18 <erisco> probably a time when mutating global variables was the standard
22:44:46 <ReinH> registers
22:44:57 <ReinH> once upon a time, programmers worked directly with registers
22:45:25 <ReinH> ways of abstracting on top of this is basically the history of programming languages
22:45:37 <hamme> Those still involve functions, just that the arguements are preapplied
22:46:29 <erisco> procedures are sensible in the set-then-call convention, as I have dubbed it
22:46:45 <erisco> which looks like  x = 3; y = 4; add();
22:47:28 <ReinH> they're sensible ways to work with the underlying machine directly
22:47:33 <ReinH> since the underlying machine uses that model
22:47:40 <erisco> mhm
22:47:50 <ReinH> the underlying machine has named places where you put things
22:47:57 <ReinH> and then operations for doing things with those named places
22:48:14 <ReinH> if you want to take some of those operations and reuse them, you give them a name
22:48:17 <ReinH> this is a procedure
22:48:29 <erisco> when you're working with one-of's, such as hardware, it ends up being a natural fit
22:48:46 <hamme> Until you get bit by implicits
22:48:51 <shachaf> Emphasize the "lying" in "underlying".
22:48:51 <hamme> or levitation
22:49:09 <erisco> it falls apart when trying to unit test though … but I imagine that practice doesn't go back too far
22:49:15 <shachaf> What actually happens with things that seem simple, like registers, is pretty complicated.
22:49:19 <hamme> Lying-obverse, or lying-it's-already-here
22:49:48 <erisco> passing around state is fairly miserable in most languages
22:50:12 <hamme> Why's that
22:50:13 * ReinH cluches his random access machine model close to his chest
22:50:26 <hamme> shhh, reinhardt
22:50:38 <erisco> hamme, how do you do this? a common thing is environment configuration
22:50:59 <erisco> it is onerous enough that even some Haskellers make unsafe IO exceptions to mutate a global variable :P
22:51:37 <hamme> So, is ST global, or local?
22:51:45 <ReinH> local
22:51:46 <hamme> I need a guage for how onerous this is
22:51:55 <ReinH> the whole point of ST is to ensure that the state is local
22:52:07 <erisco> it is so onerous OO has this thing called "dependency injection"
22:52:09 <hamme> but gives up on the mutating thing
22:52:33 <hamme> (though, the typechecker giveth, and the tpyechecker taketh)
22:52:52 <erisco> in any language with functions you have the option of passing an extra argument everywhere, which is unpleasant
22:53:01 <shachaf> ST is not really about the type checker.
22:53:16 <erisco> in Haskell you might use ReaderT, but this is also unpleasant
22:53:16 <shachaf> Hmm, maybe it is.
22:53:28 <shachaf> More than IO, I guess.
22:53:32 <erisco> but there is hope! http://tomasp.net/coeffects/
22:53:42 <hamme> So uh
22:53:45 <glguy> I agree with the older shachaf
22:53:50 <ReinH> Coeffects are for mputers!
22:53:50 <erisco> coeffects gives you the set-then-call convention, it is glorious :)
22:54:00 <hamme> inb4 someone finds semi-coeffects, like they did with neritic eDSL's erisco 
22:54:03 <shachaf> I agree with future glguy
22:55:24 <hamme> So
22:55:59 <erisco> and maybe those ML modules abate the issue, but I haven't wrapped my head around the syntax yet
22:56:56 <hamme> Typeclass vs World doesn't go into syntax, but it goes into the issue behind them
22:57:05 <hamme> Mostly providence
23:03:04 <hamme> iirc, ML Modules are the basis of backpack, ericbmerritt 
23:03:07 <hamme> fuck
23:03:11 <hamme> erisco, *
23:13:50 <Forlorn> how can I permutate, [2,3,4¸...] -> [(2*3,4), (3, 2*4), (2, 3*4), ...] ?
23:15:24 <erisco> > let a = [2,3,4] in [(x,y*z)|x<-a,y<-a,z<-a]
23:15:28 <lambdabot>  [(2,4),(2,6),(2,8),(2,6),(2,9),(2,12),(2,8),(2,12),(2,16),(3,4),(3,6),(3,8),...
23:15:53 <kadoban> Forlorn: It's unclear how to extend that sequence exactly, to me.
23:16:00 <erisco> the rest are the flips of those pairs
23:17:10 <ReinH> [2,3,4,...], not [2,3,4]
23:17:23 <Forlorn> well for 2*3*4 = 6*4 = 2*12 = 3*8
23:17:29 <erisco> you can stick in other numbers… what am I missing here?
23:17:53 <ReinH> [2,3,4...] is infinite.
23:17:55 <Forlorn> well for 2*3*4*... = 6*4 = 2*12 = 3*8*...
23:18:06 <kadoban> Forlorn: Can you descibe in plain language the sequence you're looking for?
23:18:08 <Forlorn> ops
23:18:14 <erisco> oh, so we're asking how to take the infinite product
23:18:19 <Forlorn> the previous statement is wrong
23:18:28 <erisco> I can give you two ways of doing that
23:18:36 <elliptic00> Hi, in Prelude, is there any command to get more info about the function than :type :info ?
23:18:51 <ReinH> :type and :info are not in Prelude
23:18:54 <ReinH> Prelude is a module
23:18:57 <ReinH> I think you mean ghci
23:19:03 <erisco> see "carp" and "carpl" https://github.com/erisco/acrid-parser/blob/master/parser/common.hs
23:19:04 <ReinH> And I think we have corrected you on this before
23:19:23 * geekosaur wonders what people like elliptic00 think the program they are running is after they have done ":m Numeric"
23:19:51 <geekosaur> or if they think the shell is called "~"
23:20:12 <Forlorn> if I have a bunch of factors in a list, I then want to find all possible identities of a number with only two factors
23:20:20 <erisco> carp is unpleasant to read, carpl is simpler, there is more than one way to do it
23:20:26 <ReinH> erisco: not lazy product, lazy "permutation", although it isn't clear what is meant by permutation
23:20:31 <ReinH> since it isn't "permutation"
23:20:46 <ReinH> That is, permutation already has a meaning, and that meaning is not this
23:20:51 <erisco> ReinH, I don't see the difference
23:20:51 <kadoban> Forlorn: What's an "identity"?
23:21:03 <Forlorn> 10 = 2*5
23:21:06 <ReinH> erisco: between what and what?
23:21:09 <Forlorn> 10 is an identity to 2*5
23:21:18 <Forlorn> or identic
23:21:32 <kadoban> Forlorn: You want to find all numbers that are the products of two prime factors?
23:21:37 <Forlorn> 1 = cos^2 theta + sin^2 theta
23:21:39 <Forlorn> is an identity as well
23:21:41 <erisco> ReinH, permutations and product. Is the permutations of choosing 2 from [x,y,z] not the product [x,y,z] * [x,y,z] ?
23:22:24 <ReinH> (x,x) is a member of [x,y,z] * [x,y,z]
23:22:46 <Forlorn> given 2*3*4, we can find 6*4 = 2*12 = 3*8, so what's valuable here is (6,4), (2,12), (3,8).
23:22:53 <kadoban> Forlorn: So you want to find all of the ways to complete the equation, a * b = c  where a and b are prime numbers?
23:23:05 <erisco> ReinH, ah
23:23:19 <ReinH> So you want prime factorization?
23:23:20 <Forlorn> 4, 12, 8 are not prime numbers so no.
23:23:39 <ReinH> Given a prime factorization, you can compute the unique ways those numbers can be combined.
23:24:06 <Forlorn> ReinH, yes, but only two factors should remain in the end
23:24:06 <kadoban> Forlorn: Is there a restatement of my attempt, leaving out "prime" that matches what you want?
23:24:20 <ReinH> Ok.
23:24:33 <ReinH> Find all permutations of the prime factors and group them into two groups in every way possible
23:24:52 <hamme> There are other places where you can get information about functions, though, elliptic00 
23:24:53 <ReinH> then eliminate duplicates, or produce them in a way that does not produce duplicates
23:25:15 <elliptic00> hoogle? 
23:25:22 <hamme> yes
23:25:52 <elliptic00> my intention inside the ghci
23:25:58 <hamme> mmm, ok
23:26:13 <elliptic00> I mean in ghci without goto browser
23:26:17 <Forlorn> ReinH, I see, thanks
23:26:33 <hamme> There's a ghci tag ":browse", it gives a print out of things defined in a module
23:26:35 <elliptic00> :type and :info are very limited info.
23:26:40 <hamme> a module that ghci can see that is
23:26:45 <ReinH> There is also :help
23:26:53 <hamme> but that's also type information
23:27:17 <hamme> it gives a print out of typeclasses (the types, that is) as well
23:27:21 <elliptic00> since I'm newbie in Haskell, I use ghci a lots to find the def of functions
23:27:31 <cocreature> elliptic00: if you are looking for something like :doc that lets you view haddock documentation that sadly doesn’t exist
23:27:35 <ReinH> ghci integration for hoogle: https://wiki.haskell.org/Hoogle#GHCi_Integration
23:27:46 <hamme> I should do that as well
23:27:58 <Forlorn> how did you find the definitions of functions again?
23:28:02 <Forlorn> in ghci
23:28:19 <hamme> You can get their type information, or where they are defined with :t and :i, iirc
23:28:34 <Forlorn> ty
23:28:47 <hamme> but then I don't know if there is anything that gives something like a print out of the source code for the functions
23:29:12 <hamme> I don't know how to install plug-ins into ghci
23:29:18 <ReinH> Nothing afaik
23:29:33 <ReinH> You can find the source on hackage or stackage.
23:29:40 <ReinH> which you can search with hoogle
23:29:43 <ReinH> but that require a browser
23:29:48 <geekosaur> there isn't. not sure there could be since it could be a compiled module for which no source is available
23:29:49 <ReinH> *requires
23:30:15 <kody1> you can search hoogle directly from a terminal too
23:30:45 <erisco> hm, you could adapt product to be permutation
23:31:20 <erisco> it seems close, only that you do not want pairs drawn from the same indicies
23:31:39 <erisco> skip those and you have permutation
23:32:37 <erisco> which is a special case then, so I wonder what more general uses it could have
23:32:54 <kody1> i have a basic question...say i read a file in main and store it as a string. how do I access that string outside main?
23:33:14 <erisco> particularly I mean the sig is  perm :: (a -> b -> c) -> [a] -> [b] -> [c]  
23:33:21 <cocreature> kody1: pass it as an argument to anything that requires it
23:33:23 <amalloy> main has to pass it as an argument to whatever needs it
23:33:28 <erisco> so proper permutation is  \x -> perm (,) x x
23:33:36 <Gurkenglas> When lambdabot complains that an letlpaste's imported package isn't trusted, then that means the lpaste would typecheck, yes?
23:33:47 <erisco> it is exactly the product with the diagonal taken out! :)
23:34:45 <ReinH> kody1: don't think about getting things outside of main, think about getting things (like functions you want to call) *into* main
23:35:01 <ReinH> main has the string, so your function needs to be used in main
23:35:23 <kody1> okay. thank you
23:35:25 <ReinH> or used in a thing that is used in main
23:35:34 <ReinH> but everything you want to do has to be invoked from main
23:35:39 <erisco> though then as you compose you lose the permutation, say if you go to 3
23:35:47 <erisco> maybe something with modulus
23:37:08 <amalloy> i think it's fine to think of it the other way also, ReinH
23:37:15 <hoppfull> Do we use IO monads for things other than Input/Output?
23:37:31 <ReinH> amalloy: it often leads to "how do I get this value out of IO?" thinking ime
23:37:48 <amalloy> yes, but once you get over that it's fine i think
23:38:02 <ReinH> Yes, but if you haven't then it's not, I think. :)
23:38:13 <amalloy> like i haven't thought too much about it, but i think of my IO actions as propagating into main, and pure values like config / CLI args out of main into my pure code
23:38:20 <amalloy> agreed
23:38:39 <ReinH> Yeah, at some level it doesn't matter: they're the same thing.
23:38:47 <ReinH> But at some level, it does matter because you don't see that they are the same thing
23:39:17 <erisco> map everything to () and it looks the same
23:39:24 <ReinH> terminal objects ftw
23:39:27 <hamme> nah mane
23:39:36 <hamme> data Void
23:39:41 <shachaf> "only main can do I/O" is just as true in Haskell as it is in C.
23:39:47 <ReinH> initial objects also ftw
23:39:48 <hamme> I don't recall the pragma for zero-constructor datatypes
23:40:06 <erisco> shachaf, no static initialisation shenanigans possible?
23:40:42 <shachaf> No pragma necessary. It's part of Haskell 2010.
23:41:19 <erisco> Haskell marches towards its own destruction…
23:41:22 <hamme> atom-ghc-mod is lying to me
23:41:36 <hamme> it gets angry when I try to do this
23:41:59 <hamme> I'm pretty sure that atom-ghc-mod is up to date
23:42:14 <shachaf> GHC calls the extension EmptyDataDecls, if you want it.
23:42:19 <ReinH> amalloy: have you written a roguelike in Haskell?
23:42:40 <amalloy> i've written the first ten lines of a roguelike in haskell a couple times, i think
23:42:41 <kody1> another quick question. how do you guys run the programs you write? do you go into ghci and load it or do you use runhaskell from the terminal?
23:42:48 <ReinH> amalloy: heh, same
23:42:57 <ReinH> amalloy: you should write one and make videos and then wait for step 3
23:43:00 <hamme> I use stack exec
23:43:05 <erisco> kody1, ghci myself
23:43:19 <geekosaur> Gurkenglas, I don't think so, it doesn't make it past the import so it doesn't try to typecheck; after all, typechecking probably requires the thing being imported, else why import it?
23:43:20 <hamme> and uh, atom-ghc-repl
23:43:26 <amalloy> my real-life haskell experience is pretty limited. a fair number of exercises, stack overflow questions
23:43:27 <erisco> but all my programs tend to be single files
23:43:37 <ReinH> It depends on how you want to run the program.
23:43:54 <ReinH> amalloy: (step 3 of course being profit)
23:44:02 <kody1> erisco : but if you have a file which takes in input, then how do you run it from ghci?
23:44:05 <hamme> (memes)
23:44:07 <hoppfull> kody1: I always load my program into GHCi with ":l Main.hs", then I code a little, reload with ":r", call main, code some more, check types of my functions with ":t" and so on
23:44:35 <ReinH> amalloy: it would be interesting to see someone with limited Haskell experience and extensive roguelike development experience write one in Haskell
23:44:36 <erisco> kody1, I don't have programs which do IO
23:44:46 <kody1> Aha. okay.
23:44:49 <cocreature> heh since I’ve started spending too much time playing caves of qud, I’ve also thought about writing a roguelike in haskell
23:44:52 <hamme> don't do this to me, senior
23:44:54 <erisco> kody1, but if I did, you can call IO functions in ghci as well
23:44:55 <hamme> I'm just a child
23:44:55 <kody1> What if you do? You use runhaskell?
23:45:01 <amalloy> ReinH: honestly i don't have extensive experience in that either. only started contributing to dcss 18 months ago or so
23:45:01 <ReinH> cocreature: :) how is qud?
23:45:15 <ReinH> amalloy: I mean, a year and a half is longer than most programming jobs so...
23:45:32 <ReinH> I'm going to go ahead and call it extensive ;)
23:45:34 <hamme> what do you use erisco 
23:45:35 <Gurkenglas> geekosaur, if I remove the mapStateT token lambdabot gives type errors instead, so at least some errors are noticed before the imports
23:45:53 <erisco> hamme, for what?
23:46:01 <kody1> erisco : How can you call IO functions from ghci?
23:46:02 <hamme> instead of le IO
23:46:21 <ReinH> kody1: ghci functions as an IO do block (with a few additional features)
23:46:24 <erisco> kody1, you just type it in?
23:46:25 <cocreature> ReinH: I love it but I have to admit I haven’t really played any other roguelike before so I don’t have anything to compare it to.
23:46:30 <ReinH> so you can just say, e.g., > print (Maybe 1)
23:46:51 <ReinH> This is also why bindings have to have the form: > let a = 1
23:46:53 <hoppfull> :t map
23:46:55 <lambdabot> (a -> b) -> [a] -> [b]
23:46:58 <hamme> (the printouts in ghci are also IO())
23:47:00 <hoppfull> > :t map
23:47:02 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
23:47:04 <kody1> Oh sorry. I'm a bit confused. Will figure it out...
23:47:13 <hamme> @type map
23:47:15 <lambdabot> (a -> b) -> [a] -> [b]
23:47:25 <ReinH> kody1: anything you can do in main, you can do in ghci
23:47:29 <hamme> That's how you use the lambdabot 
23:47:29 <hoppfull> hamme: thanks
23:47:32 <ReinH> and a few other things too
23:47:45 <kody1> ReinH : Yes. Okay.
23:47:55 <hoppfull> @kind Either
23:47:57 <lambdabot> * -> * -> *
23:48:07 <hamme> @type Either
23:48:09 <lambdabot> error:
23:48:09 <lambdabot>     • Data constructor not in scope: Either
23:48:09 <lambdabot>     • Perhaps you meant variable ‘either’ (imported from Data.Either)
23:48:10 <amalloy> i bet geekosaur could make a more convincing attempt at a haskell roguelike than i could, with more experience in both of those things
23:48:14 <Cale> cocreature: I agree Caves of Qud is awesome, and I've played quite a few other roguelikes :)
23:48:19 <hamme> @type Left
23:48:19 <ReinH> Either is not a value.
23:48:20 <lambdabot> a -> Either a b
23:48:26 <hamme> shhh, ReinH 
23:48:29 <ReinH> Only values have types.
23:48:33 <hamme> shhhhhhhhhhhh
23:48:40 <ReinH> hamme: no u
23:48:44 <hamme> Chapter 26 of first principles
23:48:48 <hamme> I am lrning
23:48:51 <hamme> smrt good
23:48:53 <ReinH> geekosaur: ok do that please
23:49:00 <erisco> what about a good text adventure
23:49:10 <ReinH> erisco: I've started a few of those too
23:49:23 <erisco> you are in a forest
23:49:27 * geekosaur did consider it at one point, actually. but got over it
23:49:32 <ReinH> haha
23:49:53 <amalloy> caves of clojure was a cool blog series about writing a roguelike in clojure
23:49:55 <hoppfull> A surprising amount of people seem to be doing games with Haskell.
23:50:12 <amalloy> i don't think he ever finished it, but a lot of that stuff would apply here too, i think
23:50:13 <hamme> Same with web apps
23:50:14 <ReinH> well, seem to be almost doing games with Haskell
23:50:32 <hamme> I see more web apps than video games though
23:50:42 <hamme> people would likely be more impressed with video games
23:50:43 <ongy> I tried minesweeper with haskell. It's horrible (may have been my fault)
23:50:59 <ReinH> amalloy: Yeah, I've done a few interesting things, but not a real game
23:51:06 <erisco> I think the hotness right now is Elm
23:51:22 <hoppfull> I'm playing around in that zone as well. But it's just for learning.
23:51:26 <ReinH> I used a list zipper to replace the usual doubly-linked list with sentinel for tracking actors and action points
23:51:27 <amalloy> i tried to implement Dominion in haskell. it's so hard
23:51:42 <hoppfull> PureScript seems interesting.
23:51:44 <ReinH> a circular list zipper, that is
23:51:49 <ReinH> a ring zipper?
23:52:02 <erisco> the #1 problem with programmers making games is programmers like to program more than they like to make games :P
23:52:03 <ongy> my main problem is thatI didn't really know how to do 2 dimensional arrays in haskell
23:52:11 <ReinH> erisco: confirm
23:53:08 <amalloy> i dunno, i'd rather play dcss than program it, most of the time
23:53:15 <ongy> I could have done Array (Array Int), but I didn't really want to
23:53:15 <ReinH> fair point
23:53:25 <ReinH> ongy: Array (Int,Int) ?
23:53:28 <erisco> ReinH, was that a request or agreement?
23:53:37 <ReinH> erisco: agreement
23:54:25 <hoppfull> ongy: A 2D array can be defined by a 1D array. Instead of calling for element (x, y) you call for element (x * y). Becomes the same thing.
23:54:31 <ongy> ReinH: Array (Int, Int) feels more like int[2][] in other languages
23:54:43 <Kvasir> hello
23:54:46 <Kvasir> universe
23:54:59 <ongy> and I do know how to do it generally, I just wanted to look more into a functional side of doing it, and that fell apart
23:55:06 <erisco> you can organise a 2D array in many ways… do so based on your access pattern
23:55:11 <ReinH> How did it fall apart?
23:55:12 <cocreature> Cale: you are the one that got me into it in the first place when you talked about it on #haskell-offtopic :)
23:55:14 <hamme> a step up from hello world, no doubt, Kvasir ?
23:55:17 <erisco> if we're bothering with arrays I presume we're worried about locality
23:55:33 <ongy> I guess mostly my fault. I wanted to do something zipper like for 2D, which I failed at
23:55:35 <ReinH> a Map makes a good 2d grid (for when we're not)
23:55:42 <ReinH> esp. when that grid is sparse
23:55:54 <ReinH> like he said, it depends on access patterns
23:56:08 <ReinH> *whispers* comonads
23:56:15 <hamme> It seems like an auspicious time to use untested and prototype data structures, ReinH 
23:56:25 <hamme> Random Access Zippers, or getout
23:56:36 <ongy> so Map (Int, Int)? that sounds reasonable. And I wanted to do minesweeper, so the accesspatter would have mostly been "All fields around me"
23:56:58 <ReinH> minefields are sparse, and locality doesn't matter for the magnitude and time frames involved
23:57:19 <erisco> eh, you'd have to do something quite spectacular to fail to make minesweeper suitably realtime
23:57:20 <Kvasir> wow didn't expect  this chat to be so active
23:57:27 <ReinH> erisco: indeed
23:57:32 <hamme> I prefer Minesweeper RPG
23:57:52 <ReinH> Kvasir: one of the most popular on freenode, or at least populous.
23:58:07 <Kvasir> well it is mentioned in a book, and on an online tutorial
23:58:24 <erisco> does that make use legends? didn't know we were in tomes now
23:58:40 <kody1> Is it true that in main, execution takes place from top to bottom?
23:58:46 <Kvasir> "The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck. People there are extremely nice, patient and understanding to newbies."
23:59:21 <erisco> kody1, evaluation always works the same, and it is lazy
23:59:32 <erisco> spare some GHC features
