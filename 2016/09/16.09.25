00:09:46 * hackagebot tianbar 1.1.0.1 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.1.0.1 (AlexeyKotlyarov)
00:09:46 * hackagebot hw-prim 0.3.0.0 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.3.0.0 (haskellworks)
00:15:33 <glguy> lambda-11235: it looks like your pvp ascii art is wrong, Haskell pvp you linked to uses first two numbers for breaking changes
00:21:11 <lambda-11235> glguy: The second number says "non-breaking API additions" on what I'm looking at on lpaste.
00:23:02 <glguy> Right, but the first and second number are both for breaking changes
00:23:08 <Lokathor> lambda-11235, the first and second number are both for possible-breaking changes in Haskell land
00:24:19 <glguy> http://pvp.haskell.org
00:34:40 * hackagebot hw-bits 0.2.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.2.0.0 (haskellworks)
00:34:42 * hackagebot glirc 2.19 - Console IRC client  https://hackage.haskell.org/package/glirc-2.19 (EricMertens)
01:08:20 <jluttine_> hi! is there a way to see the implementation of some instance in ghci? i'd like to see the implementation of instance Applicative Either.
01:09:04 <jluttine> or alternatively, just print the source of a module (Data.Either in this case)
01:09:50 <srhb> jluttine: Unfortunately no.
01:10:29 <jluttine> srhb: ok, thanks :(
01:11:13 <srhb> jluttine: lambdabot can use a "fake" source list and you can integrate it with ghci, though it's not trivial, and probably not worth it. Your best bet is to go to Hackage and view the actual source.
01:11:17 <rembo10> Is it possible to compile static files in the binary? I want to ship something like syncthing, where the web ui is embedded inside the binary
01:11:39 <srhb> rembo10: With template haskell, you could do that.
01:11:47 <jluttine> srhb: thanks, i'll do that!
01:11:53 <srhb> rembo10: ie. read in a String at compile time and embed it.
01:12:31 <srhb> rembo10: And someone has already packaged this up for you: https://hackage.haskell.org/package/file-embed-0.0.10/docs/Data-FileEmbed.html
01:12:35 <rembo10> Oh cool. If I use template haskell, is it still portable? Like could I compile for linux, osx and windows?
01:12:40 <rembo10> I'll take a look at that link
01:13:16 <srhb> rembo10: My experience with Windows is limited to "nothing works easily, ever" but ymmv. :-)
01:13:26 <rembo10> Haha
01:13:32 <rembo10> I know
01:14:36 <srhb> rembo10: That particularly doesn't seem to use anything *nix-specific though, so I guess it should work.
01:15:11 <rembo10> I just kind of want to make sure my bases are covered before I go all in with haskell
01:15:55 <the1R> hi
01:16:09 <the1R> hhi
01:16:18 <srhb> the1R: Hi there.
01:34:41 * hackagebot hw-bits 0.2.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.2.0.1 (haskellworks)
01:34:43 * hackagebot hw-prim 0.3.0.1 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.3.0.1 (haskellworks)
02:34:53 <Phyx-> rembo10: If you want a useful answer: yes it is. 
02:35:23 <Phyx-> rembo10: bare in mind that TH uses the runtime linker, so you may get strange link errors if there's a bug on the RTL of that platform.
02:35:58 <Phyx-> rembo10: as of GHC 8.0.1 the linker support is a lot more solid. But if you do find an issue, please report it :)
02:36:48 <srhb> Phyx-: Thanks a lot. :-P
02:37:07 <rembo10> Haha thanks to both of you!
02:39:41 <Phyx-> np, also 8.0.2 will contain a few more linker fixes as well.
02:42:56 <rembo10> Thanks!
03:43:37 <jluttine> if i only define instance Applicative, should haskell automatically deduce Functor instance? i was hoping that, but i get error could not deduce (Functor (.....))....
03:44:09 <shachaf> That doesn't happen whether or not you define an Applicative instance.
03:44:34 <shachaf> You can ask GHC to derive it if you want (again independent of the Applicative instance).
03:44:58 <shachaf> Or you can write something like "instance Functor F where fmap = liftA" if you like.
03:46:28 <jluttine> ok/. is there some particular reason why i also need to write Functor instance if i'm already defining Applicative instance?
03:47:14 <shachaf> You need to define it because it's a superclass.
03:47:27 <shachaf> Define it or otherwise make sure it's there.
03:50:27 <jluttine> ok, thanks. i just got confused because a book i'm reading says that "you can write fmap using monadic operations: fmap f xs = xs >>= return . f"
03:51:09 <shachaf> Yes, that's one implementation of fmap that you can use.
03:51:28 <shachaf> You can write instance Functor F where fmap f x = x >>= return . f
03:51:37 <shachaf> But you have to write it to choose that implementation.
03:52:12 <shachaf> As it happens, all possible Functor instances are equal (almost). But GHC doesn't know that.
03:52:49 <jluttine> but i need to have the Monad instance defined before that and i thought i can't have Monad instance defined unless i have it's superclass Functor instance already defined
03:53:09 <jluttine> need to play with these.. :)
03:54:12 <jluttine> to me this sounds a bit like chicken-egg problem
03:56:11 <lyxia> the instances can have mutually recursive definitions, but they still need to be written explicitly with "instance" or "deriving".
03:56:23 <jluttine> i actually meant to suggest: instance Functor F where f map f x = pure f <*> xs
03:57:00 <amalloy> you don't have to write the Functor instance *before* the Monad instance, it's just illegal to write a Monad instance without also writing a Functor instance. they can depend on each other in either direction
03:57:04 <jluttine> lyxia: ok! so i need to put those definitions inside one :{ :} block in ghci i suppose
03:57:38 <amalloy> well, it would be a lot easier if you put it in a .hs file isntead of writing it directly into ghci
03:57:49 <jluttine> amalloy: yep, i see that now :)
04:00:16 <jluttine> yes, now it works! thanks amalloy lyxia shachaf, now it makes sense :)
04:09:36 <NickHu> Is there a ghc extension to derive Applicative/Functor?
04:10:19 <MarcelineVQ> Functor, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DeriveFunctor
04:12:13 <Hi-Angel> Is it possible to limit a RAM that ghc can use for compilation?
04:12:56 <Hi-Angel> Preferably with ghc's tools, because, I guess, `umemory` limit would lead to crash as ghc take all the allowed memory
04:12:59 <srhb> Hi-Angel: GHC takes RTS options. :)
04:13:09 <srhb> Hi-Angel: It will probably crash if you go very low, though
04:15:25 <srhb> Hi-Angel: For example, ghc +RTS -M512m -RTS will limit the heap size to half a gig.
04:16:29 <Hi-Angel> Thank you, ah, right, ghc with its RTS options just exits upon exhausting..
04:17:16 <srhb> Yes, GHC is quite memory hungry. Compiling on low-memory systems is a bit of an art.
04:21:37 <moop> what's the minimum required ram for GHC?
04:22:07 <srhb> moop: There's no really clear number.
04:22:15 <Hi-Angel> moop: I think pretty low, it's that depending on package you're building, it may take very much
04:22:31 <srhb> Right.
04:23:28 <Hi-Angel> Anyway, is there a way to pass +RTS options to stack? Simply writing "+RTS" leads to "stack: Most RTS options are disabled." message
04:23:45 <Hi-Angel> I mean, not stack itself, but the ghc it using
04:23:59 <martinr_> hey
04:24:04 <Hi-Angel> Hi
04:24:08 <hvr> with cabal you can say '--ghc-options '+RTS -M2G -RTS'
04:24:17 <MarcelineVQ> stack build --ghc-options +RTS ...
04:24:18 <hvr> Hi-Angel: maybe something similiar is possible with stack too
04:24:30 <Hi-Angel> Oh cool, thank you!
04:33:03 <jchia_> I have a Vector String and a Data.Vector,Unboxed.Mutable.IOVector Int. I want to 'zip' them and print the 'paired' items side-by-side line-by-line. What's a succint way to do it? I see no concise way to get a regular vector or list from an unboxed vector, and the simplest way I can see is to traverse the range of indexes and manually read the items from each vector to make the string to be printed.
04:34:01 <jchia_> I can't use basicUnsafeFreeze on the unboxed mutable vector. It works only on boxed mutable vectors
04:34:45 * hackagebot hw-bits 0.2.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.2.0.2 (haskellworks)
04:35:21 <jchia_> I'm wondering why Data.Vector.Unboxed.Mutable doesn't define a function to get a boxed non-mutable vector or at least a boxed mutable vector.
04:36:06 <lyxia> there is "convert" between immutable vectors
04:37:26 <lyxia> and there is "freeze". Both functions can be found in Data.Vector.Unboxed
04:38:00 <jchia_> lyxia: I know there's Data.Vector.map. No problems with mutable vectors here.
04:38:08 <jchia_> i mean immutable
04:39:49 <lyxia> So... were you not looking for "convert" and "freeze"?
04:40:27 <jchia_> i'm trying to 'zip' a boxed immutable vector with an unboxed mutable vector
04:41:05 <jchia_> does convert deal with that?
04:41:35 <jchia_> can it convert between boxed/unboxed mutable/immutable?
04:41:38 <lyxia> freeze : mutable -> immutable, convert : immutable unboxed -> immutable boxed
04:43:05 <jchia_> freeze converts from boxed mutable to boxed immutable. does convert convert between boxed and unboxed?
04:44:29 <lyxia> yes it does
04:45:02 <jchia_> convert :: (Vector v a, Vector w a) => v a -> w a
04:45:14 <MasterMinded> Hello I need help with some beginner haskell functions, willing to pay, pm me if interested
04:45:16 <jchia_> I'm not sure what the v and w mean. I'll check it out
04:46:44 <NickHu> MasterMinded: You can get free help if you just ask in the channel :) Please direct long code snippets to a pastebin though
04:47:00 <jchia_> lyxia: Thanks. I think i see the v & w means.
05:33:32 <jchia_> lyxia: It seems that convert only converts between two immutable vector types and freeze only freezes unboxed vectors. I have to convert from unboxed mutable to boxed immutable. Any idea?
05:35:26 <jchia_> I meant "freeze only freezes boxed vectors"
05:42:37 <Myrl-saki> I'd take this to an Idris channel or Elm, but I want varied answers. Which do you prefer, Idris or Elm?
05:45:12 <padre_angolano> which do you prefer, forth or LaTeX
05:45:39 <zennist1> in haskell - is there a way to import some variable under a different name?
05:46:00 <zennist1> I know you can do it on the module level, but how about names under a module e.g., className?
05:46:21 <zennist1> I'm trying to import some low level classes and do a rename and export - but it's not a type so can't do 'type =..'
05:51:14 <geekosaur> zennist1, no (although it's been bikeshedded a bit on -cafe)
05:52:08 <zennist1> i see - yeah, i hope we can have import X (x as myX) for example
06:00:05 <geekosaur> also I think Backpack's supposed to provide that but (a) not at the level of Haskell (b) don't recall if current version is at that level (c) hasn't landed yet
06:22:32 <zort> does Persistent support embedded documents in MongoDB?
06:34:48 * hackagebot htaut 0.1.0.0 - Tautology Proving Logic in Haskell  https://hackage.haskell.org/package/htaut-0.1.0.0 (Ailrun)
06:43:13 <agocorona> zennist1: import X(x) myX= X.x
06:44:54 <geekosaur> if I read this right, they want to rename a typeclass?
06:54:51 <zennist1> agocorona: can you do this for typeclass?
06:56:04 <geekosaur> actually I am not sure a typeclass can ever be renamed...
06:57:40 <mettekou> Is there an idiomatic way of using actions in two monad transformer stacks in the same function? Case in point: the type checker and evaluator monad transformers for a dependently-typed language. The type checker needs the evaluator to reduce terms when necessary to determine their equivalence.
06:57:44 <geekosaur> (I don't mean ability, I mean logical consistency)
06:58:11 <agocorona> In general, in a language it is much more valuable what you can not do than what you can do
07:01:25 <saurabhnanda> does anyone know how to pull a project from github using stack?
07:03:26 <geekosaur> saurabhnanda, https://docs.haskellstack.org/en/stable/faq/#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do last example
07:03:43 <saurabhnanda> geekosaur: thanks
07:05:32 <saurabhnanda> ah okay
07:05:39 <saurabhnanda> it was already there -- I was searching for it in package.yaml
07:05:45 <saurabhnanda> it was in stack.yaml
07:06:30 <ph88> does anyone understand why i'm getting a parse error here?   https://paste.fedoraproject.org/434994/47481232/
07:07:19 <lyxia> ph88: you're missing a do
07:07:26 <lyxia> just after ->
07:07:34 <ph88> ah i see !
07:08:14 <lyxia> ph88: BTW you can do (input, result) <- ...
07:08:48 <ph88> ah yes much nicer :)
07:10:19 <ph88> lyxia, do you know where this error is coming from ?  https://paste.fedoraproject.org/435003/47481258/
07:10:59 <saurabhnanda> What could this mean? // Failure when adding dependencies:  //girella: needed (-any), stack configuration has no specified version // needed for package ServantOpaleye-0.0.0
07:12:02 <lyxia> ph88: what's the type of qc2
07:12:03 <ph88> saurabhnanda, maybe your package is not in the release
07:12:14 <ph88> lyxia, qc2 :: (Arbitrary t, Show t) => (t -> Bool) -> Maybe (Int, Int) -> IO (IORef (Maybe t), Result)
07:12:17 <saurabhnanda> ph88: I'm adding the package via Github
07:12:21 <saurabhnanda> - location: https://github.com/silkapp/silk-opaleye/tree/girella 
07:12:52 <lyxia> ph88: why are you returning an IORef rather than its contents?
07:13:31 <lyxia> ph88: lines 5 and 7, do you really want to print the reference, or the value it contains?
07:13:44 <ph88> lyxia, something to do with code i found here http://stackoverflow.com/a/8191448/1833322  not sure how it works or why it works .. but i'm changing it to suit my needs
07:14:31 <lyxia> ph88: can you show me your version
07:15:18 <lyxia> It might be better to apply readIORef like in the SO answer
07:15:33 <ph88> lyxia, https://paste.fedoraproject.org/435010/47481290/
07:16:14 <ph88> oh yes that is actually a mistake that i forgot to apply readIOref
07:16:19 <ph88> something went wrong copy pasting there
07:16:20 <saurabhnanda> ph88: okay. it's also required in the extra-deps section
07:18:52 <ph88> lyxia, fyi adding language extension FlexibleContents fixes it .. i'm just curious where the error is coming from in the first place
07:20:33 <lyxia> ph88: yes it does but I was thinking that it isn't necessary here
07:21:56 <ph88> that be even better
07:22:11 <ph88> i'm a bit reluctant to use language extensions before i really understand what they do in the first place
07:22:18 <ph88> not that they are a bad thing
07:22:25 <lyxia> I don't even think you can print IORefs
07:22:43 <ph88> well it was a mistake
07:22:54 <ph88> i return (readIOref input, result)  from qc2 now
07:23:05 <lyxia> uh oh
07:23:17 <lyxia> input <- readIORef input ; return (input, result)
07:23:30 <ph88> ooh
07:23:39 <lyxia> of type IO (Maybe a, Result)
07:23:55 <ph88> but this is original SO code:    Failure {} -> readIORef input
07:24:01 <ph88> so it return directly, no ?
07:24:13 <lyxia> but yours is wrapped in a return
07:24:39 <ph88> aaah i see !
07:24:49 <lyxia> you're not returning the (Maybe a) value, you're returning the action that reads the value.
07:25:06 <saurabhnanda> how to solve the following -- "The following package identifiers were not found in your indices: girella-1.0.0 "
07:25:15 <ph88> yup the type looks much much better now    qc2 :: (Arbitrary t, Show t) => (t -> Bool) -> Maybe (Int, Int) -> IO (Maybe t, Result)
07:25:47 <ph88> saurabhnanda, not that i think you get quicker answer there but there is also #haskell-stack
07:25:49 <lyxia> saurabhnanda: is girella available locally?
07:26:21 <saurabhnanda> lyxia: ph88: already have this in the stack.yaml
07:26:27 <saurabhnanda> packages:
07:26:29 <saurabhnanda> - location: https://github.com/silkapp/silk-opaleye/commit/3faf7436bbee3b6146dad251bddc25cfbf185c85
07:26:29 <saurabhnanda> - location: https://github.com/silkapp/haskell-opaleye/commit/4c3b9d911607c705ed7d5e2f106c1cb0360b69d5
07:27:15 <saurabhnanda> lyxia: ph88: that's the girella.cabal file: https://github.com/silkapp/silk-opaleye/blob/girella/girella.cabal
07:27:37 <ph88> lyxia, do you know from Failure usedSeed how to get the actual seed it seems to give a QCGen instead    https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#t:Result
07:28:08 <lyxia> ph88: that's the seed
07:28:14 <ph88> saurabhnanda, sometimes you have to type    stack resolve  or   stack setup   .. i'm just a newb myself so can't help much
07:29:08 <ph88> lyxia, i think it's the generator .. https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/src/Test-QuickCheck-Random.html#mkQCGen   this shows a function that takes an int and returns a generator .. makes me belief the int is the seed
07:31:49 <lyxia> ph88: no the terminology is just confusing but a seed is a generator
07:32:33 <ph88> does it have a show representation even ?
07:32:35 <ph88> let me look
07:33:01 <ph88> doesn't seem so :/
07:33:16 <ph88> i expect the seed just to be a number ..
07:33:28 <ph88> lyxia, do you know how to get a number representation from QCGen ?
07:33:45 <lyxia> https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Random.html#t:QCGen how is that not Show QCGen and Read QCGen
07:34:49 * hackagebot simple-effects 0.3.0.0 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.3.0.0 (darwin226)
07:34:51 * hackagebot app-lens 0.1.0.3 - applicative (functional) bidirectional programming beyond composition chains  https://hackage.haskell.org/package/app-lens-0.1.0.3 (kztk)
07:37:36 <lyxia> saurabhnanda: are these opaleye packages dependencies of your own application?
07:37:54 <saurabhnanda> lyxia: didn't understand the question.
07:38:29 <saurabhnanda> lyxia: I'm trying to use an unreleased (on hackage) package from github
07:38:42 <saurabhnanda> lyxia: trying to use it directly via github
07:39:22 <lyxia> saurabhnanda: Shouldn't that go in extra-deps
07:40:50 <saurabhnanda> lyxia: it's there in extra-deps as well -- https://gist.github.com/saurabhnanda/9dc432d4d0a3840a83c47516d5c0f9e4
07:42:25 <ertes> mettekou: there is the mtl way:  myAction :: (MonadX m, MonadY m) => m ()
07:43:16 <ph88> lyxia, now i see  "TFGenR 00000002761A461F0000000000030D40000000000000E13800001B848621E000 0 6 3 0"   how can i turn this back into a QCGen ?
07:44:09 <lyxia> ph88: have you tried read
07:45:06 <lyxia> it's supposed to be the inverse of show
07:46:35 <ph88> lyxia, yes i remember what it is, i haven't used it before though .. looking at the source code of read now .. can't make much of it
07:47:39 <lyxia> well they just wrap the instances of the underlying generator so there's not much to see.
07:47:50 <Clint> MarcelineVQ: maybe
07:48:50 <ph88> lyxia, amazing it works now! i'm very happy
07:49:02 <ph88> this is how i run it now:   qcrp contextClause $ Just ("TFGenR 00000002761A461F0000000000030D40000000000000E13800001B848621E000 0 6 3 0",1)
07:49:20 <ph88> when i put Nothing it generate a new one
07:49:26 <lyxia> cool
07:53:47 <joncol> Hi, I'm converting a document using Parsec. During the "compilation" of the document, I use the user state to keep a list of warnings for malformations in the input data. Is there some way of accessing this user state after runParser has finished? Or should I do this in some other way?
07:56:28 <lyxia> joncol: use getState before applying runParser
08:05:54 <soLucien> f (a -> b)
08:06:04 <soLucien> function application in a computational context
08:06:18 <soLucien> is it the same as running a -> b function, then running f on the result ?
08:06:27 <soLucien> i'm trying to get Applicative
08:06:57 <Kuros`> When I use the ghc :edit command on a file Test.hs, then make some syntax error in the file and close it, ghc complains about the syntax error but when I try to do :edit again, it says "Cannot find the Test.hs +24 file"
08:07:12 <joncol> lyxia> But it's the actual parsing that modifies my state?
08:07:29 <Kuros`> I'm not sure why it's trying to open the file name plus the number of lines in the file
08:07:43 <lyxia> joncol: sure
08:08:19 <Kuros`> clarification: it's notepad that tries to open that file, it seems like ghc is trying to make notepad open "Test.hs + 24" for some reason
08:08:49 <pavonia> Kuros`: I think it's a feature to jump to a certain line which notepad doesn'T support
08:09:48 <joncol> lyxia: So I wouldn't get the warnings produced by the parsing...
08:09:59 <Kuros`> well it only does that if there's a syntax error :o
08:10:22 <Kuros`> if the file is loaded without an error and i do :edit, then it loads it without problem
08:10:31 <Kuros`> i mean loads it into notepad without a problem
08:10:34 <pavonia> soLucien: I's more like pushing the function application into the context
08:11:18 <pavonia> Kuros`: Does the number coincide with the line of that last error?
08:11:35 <Kuros`> yes
08:11:56 <Kuros`> i guess if there's not an error there's no particular line it wants to jump to, makes sense
08:12:01 <NickHu> soLucien: You can think of `pure` as "lifting" into a functor
08:12:22 <lyxia> joncol: why not
08:12:28 <pavonia> Kuros`: Seems it's trying to tell the editor that
08:12:29 <soLucien> i am having trouble understanding this lift abstraction
08:12:34 <soLucien> what actually happens ?
08:12:40 <NickHu> So if we have g :: a -> b, then pure g :: f (a -> b)
08:12:47 <lyxia> joncol: I didn't understand how you've come to that conclusion.
08:12:47 <soLucien> i mean evrything functional actually goes imperative at some point
08:12:50 <soLucien> under the hood
08:12:51 <NickHu> soLucien: It depends on what the functor does
08:12:57 <buttbutter> In GHCI, whe it says "Use -v to see a list of the files searched for", what exactly is the format to actually use the -v flag? 
08:13:02 <soLucien> i kind of got functors
08:13:13 <NickHu> Applicatives are a special kind of functor
08:13:29 <pavonia> buttbutter: "ghci -v", or maybe ":set -v" inside of GHCi also works
08:13:31 <NickHu> They give you `pure` and (<*>)
08:13:33 <soLucien> but i am trying to get the pure and the <*> now
08:13:36 <soLucien> yes
08:13:40 <soLucien> for example maybe
08:13:45 <soLucien> pure is Just
08:13:47 <NickHu> pure is a general way to lift something into the applicative
08:13:49 <soLucien> i don't get that .. why ?
08:13:59 <soLucien> Maybe applicative
08:14:02 <buttbutter> pavonia: Aha. Thanks. I was trying :l -v and stuff and just couldn't figure it out :P
08:14:03 <soLucien> pure = Just
08:14:07 <NickHu> Because if we have a function g :: a -> b
08:14:13 <NickHu> And a value x :: a
08:14:21 <NickHu> And say y = g x :: b
08:14:47 <lyxia> joncol: instead of doing runParser (parser :: Parsec S U A), do runParser (liftA2 (,) parser getState :: Parsec S U (A, U)) and that gives your state after parsing.
08:16:13 <NickHu> For any applicative functor, we have pure g <*> x = pure (g x)
08:16:25 <NickHu> (That's called the homomorphism law for applicative functors)
08:16:45 <NickHu> Note that either sides of the equation are equal to y in that functor
08:17:01 <NickHu> Or, y "lifted" into that functor
08:17:03 <pavonia> soLucien: With Functor you can't apply a function that require effects/context to be computed itself. Applicative gives you this expressiveness
08:17:24 <NickHu> If we take the Maybe functor as an example, then lifting a value into the Maybe functor means that it may or may not be there
08:17:58 <NickHu> With the list functor, we are saying we have a bunch of inputs are we want to do the computation for all of them and then collect the results in a list
08:18:36 <NickHu> The IO functor is magic, and is used to sequence effectful computations - you basically read it like "this thing will do an impure computation, but our description of it is pure"
08:20:12 <soLucien> pure g <*> x = pure (g x) : this means that applying a pure function, then using <*> on it will yield the same result as calling the 2 functions , then applying pure to them
08:20:14 <soLucien> i understand
08:20:21 <NickHu> Yes
08:20:29 <NickHu> There are more applicative laws too
08:20:35 <soLucien> i am reading them
08:20:43 <NickHu> I'd recommend reading the typeclassopedia
08:20:44 <soLucien> and i do understand where they come from
08:20:51 <soLucien> that's what i am reading right now
08:21:07 <soLucien> but i get no intuition as to what Applicative really is
08:21:20 <soLucien> and if i don't understand that, i can't see its use
08:21:23 <NickHu> If you look at the signature for fmap
08:21:31 <NickHu> f (a -> b) -> a -> b
08:21:45 <NickHu> If we put in more brackets, it's equal to this: f (a -> b) -> (a -> b)
08:22:03 <NickHu> wait I missed some fs
08:22:09 <soLucien> yes .. apply the function f to the result of (a -> b)
08:22:21 <NickHu> f (a -> b) -> (f a -> f b)
08:22:32 <soLucien> that is what i did understand
08:22:53 <NickHu> Hang on I got that wrong again: (a -> b) -> (f a -> f b)
08:23:05 <NickHu> Applicative basically lets us have functions inside the functors too
08:23:27 <NickHu> While plain functors only allow us to lift a normal function to operate in the functor's context
08:23:46 <soLucien> but f is a function, isn't it ?
08:23:55 <soLucien> fmap (+3) some list
08:24:02 <soLucien> will add 3 to all the elements of the list
08:24:09 <NickHu> Yes
08:24:10 <soLucien> +3 is the f in this case
08:24:22 <NickHu> So (+3) is a function from Int -> Int
08:24:39 <NickHu> fmap (+3) is therefore a function from [Int] -> [Int]
08:25:14 <soLucien> so where does applicative come in here ? 
08:25:17 <joncol> lyxia: Thanks, I'll look into that.
08:25:20 <soLucien> "Applicative basically lets us have functions inside the functors too"
08:25:28 <soLucien> but +3 is a function
08:25:37 <NickHu> soLucien: Applicative only pertains to pure and <*>
08:25:56 <NickHu> So we could have lists of functions with your example: [(+1), (+2), (+3)]
08:26:20 <NickHu> Which has type [(Int -> Int)]
08:26:29 <NickHu> Which unifies with f (a -> b)
08:26:31 <soLucien> i see .. so applicative allows multiple functors to be applied
08:26:49 <NickHu> No, it's not multiple functors
08:26:56 <NickHu> It's a single functor, the list functor in this instance
08:27:10 <NickHu> In the Maybe functor, you could have a function that is or is not there
08:28:10 <NickHu> If we do (Just (+1)) <*> (Just 2), we get Just 3
08:28:55 <NickHu> What do you think Nothing <*> (Just 2) yields?
08:29:44 <soLucien> Nothing ?
08:29:48 <NickHu> Yup
08:30:00 <soLucien> it might as well be Just 2 , it was a guess
08:30:16 <soLucien> depends on the rules in the applicatie
08:30:19 <soLucien> applicative
08:30:21 <soLucien> right ?
08:30:52 <NickHu> Yes, that's right, but the only way to make all the laws hold is for it to yield Nothing
08:32:00 <soLucien> so applicative is a fancy functor
08:32:08 <NickHu> Yes
08:32:12 <NickHu> And Monad is a fancy applicative
08:32:15 <soLucien> that will first "lift" stuff in the functional doman
08:32:27 <soLucien> computational domain .. whatever the correct term is
08:32:38 <NickHu> Into the functor
08:32:39 <soLucien> then perform <*>
08:32:59 <soLucien> instead of applyinf f directly, it does  one more step
08:33:40 <soLucien> makes the function pure , then applies whatever operation <*> is supposed to do
08:33:54 <soLucien> as opposed to simply calling f a and f b
08:34:06 <NickHu> Oh don't conflate the applicative `pure` with the concept of function purity, they mean different things
08:34:26 <soLucien> okay , it calls pure on the function
08:34:32 <NickHu> What do you mean by calling f a and f b?
08:34:35 <NickHu> They are types
08:34:39 <NickHu> Not functions
08:34:46 <soLucien> f a -> f b
08:34:50 <pavonia> Note that the function already is in this context, so it's more like taking it out of there, doing the actual function application, and stuffing it back into the context
08:34:50 * hackagebot distributed-closure 0.3.2.0 - Serializable closures for distributed programming.  https://hackage.haskell.org/package/distributed-closure-0.3.2.0 (MathieuBoespflug)
08:34:58 <soLucien> makes a a f and b a f
08:35:06 <soLucien> coerces ? is that correct
08:35:17 <NickHu> soLucien: Look at this http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
08:35:21 <soLucien> i got flamed for saying "cast" few weeks ago :D
08:35:39 <soLucien> i've seen it , this is the first thing i looked at
08:35:44 <soLucien> when trying to understand monads
08:35:53 <soLucien> but it didn't help , so i went the typeclassopedia way
08:35:59 <soLucien> but maybe it will make more sense now
08:40:24 <Kuros`> seems like the bug stems from here https://github.com/ghc/ghc/blob/master/ghc/GHCi/UI.hs#L1430
08:40:25 <soLucien> have you ever felt stupid when trying to understand these things ?
08:41:06 <NickHu> soLucien: Everyone does, but then they hit the moment of satori when it just clicks
08:41:27 <soLucien> i swear haskell is the most depressing programming language i've ever seen ..
08:41:34 <NickHu> It's great
08:41:39 <soLucien> but then again, been doing imperative for the last 5 years
08:41:44 <soLucien> OO all the way
08:41:58 <pavonia> Kuros`: It's no a bug, it's a feature ;)
08:42:34 <soLucien> Java/C#/Ruby/Python/JS/php/PowerShell
08:42:36 <Kuros`> i've come back to haskell from time to time, last time i tried to make a really simple networking program, but it required not only monads of course but a stack of them, which kicked my ass
08:42:54 <NickHu> soLucien: One thing to remember is that different functors (list/Maybe/IO/Either etc) work in completely different ways
08:43:01 <NickHu> They just share structure
08:43:07 <soLucien> i thaught Ruby is the worst, the lack of types frustrated me
08:43:14 <soLucien> but HS is in the other extreme
08:43:14 <NickHu> And that structure is captured by fmap, <*>, >>= etc.
08:43:28 <NickHu> soLucien: You should look at servant, it's crazy cool
08:44:22 <NickHu> You can write your web API *as types*
08:44:36 <NickHu> So your compiler guarantees you don't have dangling routes
08:45:25 <saurabhnanda> I'm unable to solve this problem no matter what I do -- The following package identifiers were not found in your indices: girella-1.0.0 
08:45:32 <saurabhnanda> can someone please help me?
08:46:08 <soLucien> if it could be applied to gigantic codebases and simply statically analyze them it would be awesome
08:47:03 <soLucien> unfortunately i had to work with huge programs/DSLs such as Vagrant and Puppet , which already have their web api defined
08:48:53 <NickHu> Well, it probably could
08:49:07 <NickHu> idk, type checkers are huge and are going to be big in 10 years
08:49:26 <joncol> lyxia: Thanks, that worked perfectly. I'm a bit rusty on the abstractions, *how* does this actually work? I noticed that if I switched the order of `parser` and `getState` arguments to liftA2, the state returned was empty (i.e. as *before* parsing was done), but I don't really understand this.
08:50:02 <lyxia> saurabhnanda: where does girella come from
08:50:05 <glguy> saurabhnanda: it doesn't appear to be released
08:50:35 <glguy> there's a package candidate on hackage
08:50:59 <saurabhnanda> lyxia: glguy: from here: https://github.com/silkapp/silk-opaleye/tree/girella
08:51:17 <saurabhnanda> lyxia: glguy: I've tried pulling it directly via Github -- didn't work. Then via submodules, still doesn't work.
08:51:40 <joncol> Is lifting (,) some way of sequencing operations?
08:51:54 <soLucien> NickHu most errors in Ruby come from the lack of types
08:51:58 <glguy> "doesn't work" sounds serious
08:52:16 <NickHu> soLucien: It's probably more to do with huge stdlib and attracts lots of beginners
08:52:21 <soLucien> that makes refactoring a pain
08:52:35 <NickHu> Go has this problem too
08:52:40 <saurabhnanda> glguy: lyxia: here's my first attempt (Directly via github) -- https://gist.github.com/saurabhnanda/9dc432d4d0a3840a83c47516d5c0f9e4
08:52:40 <NickHu> Basically everything popular sucks
08:52:42 <lyxia> joncol: liftA2 sequences two operations and combines their results
08:52:49 <NickHu> :t liftA2
08:52:51 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:52:54 <soLucien> and you need to write tests for evrything
08:52:59 <saurabhnanda> lyxia: glguy: stack can't find girella-1.0.0 whatever I do
08:53:04 <soLucien> otherwise refactoring is impossible
08:53:19 <soLucien> i find that counterproductive and error-prone
08:53:32 <lyxia> saurabhnanda: is the location pointing to a commit link known to work?
08:53:44 <soLucien> c# is my favourite
08:53:45 <NickHu> unit tests the way they are used in the industry are a (bad) replacement for thinking about your programs
08:53:59 <glguy> is it OK to have two packages sections?
08:54:00 <soLucien> types, refactoring, lambdas
08:54:07 <saurabhnanda> lyxia: "known to work" = "sensible code" OR "valid package descriptor"?
08:54:32 <soLucien> i'll prolly like F# as well once i pass the Haskell hell
08:55:18 <saurabhnanda> glguy: hmm didn't notice that
08:55:31 <NickHu> F# is one of those things that nobody uses because .NET
08:55:44 <tnks> it
08:55:46 <NickHu> Apparently it has some pretty cool stuff in it, but I don't know anything else about it
08:55:48 <saurabhnanda> glguy: thanks, that was one issue. now running into a new one
08:55:59 <tnks> nobody needs an asterisk.
08:56:08 <tnks> not many, surely. . . but they're out there.
08:56:22 <tnks> I mean, people say the same about Haskell too.
09:00:07 <saurabhnanda> glguy: lyxia: any idea how to solve this erro? https://gist.github.com/saurabhnanda/9dc432d4d0a3840a83c47516d5c0f9e4#file-error-txt switch to a lower stack resolver?
09:03:30 <glguy> Yeah, you'll have find a resolver that has the packages you want, or you can switch to a resolver without packages and using stack solver find the set of packages that satisfy the dependencies
09:03:46 <glguy> (like ghc-7.10.3)
09:25:16 <saurabhnanda> glguy: how do I get stack to find me the appropriate resolver?
09:26:49 <joe9> saurabhnanda: stack solver --resolver lts ?
09:26:57 <joe9> or --resolver nightly?
09:26:58 <saurabhnanda> joe9: thanks
09:29:47 <joe9> saurabhnanda: stack solver --update-config --resolver lts is what I normally use.
09:30:28 <felko> why can't I do this with arrows ?
09:30:31 <lpaste> felko pasted “No title” at http://lpaste.net/214881
09:31:23 <felko> it seems that the F in an expression of the form "O <- F -< I" isn't evaluated with the local scope
09:31:40 <glguy> felko: proc i -> mult i -< i
09:31:48 <glguy> You can't use i as an argument to mult
09:31:54 <felko> why ?
09:32:11 <glguy> It's a variable that restricted to the ends of the arrow notation
09:32:17 <glguy> proc i -> mult -< i
09:32:37 <felko> yeah but mult takes two arguments
09:32:54 <glguy> That's not arrow notation's problem :)
09:33:12 <felko> how would you solve this problem ?
09:33:16 <glguy> I wouldn't use arrows
09:33:35 <felko> actually this is a simplification of another problem
09:34:04 <glguy> If you want to have two arguments to something with arrow notation you can "uncurry it" and give ita type:  a (Int,Int) Int
09:34:10 <glguy> for whatever arrow `a' you're using
09:34:53 * hackagebot reedsolomon 0.0.4.2 - Reed-Solomon Erasure Coding in Haskell  https://hackage.haskell.org/package/reedsolomon-0.0.4.2 (NicolasTrangez)
09:35:31 <lpaste> felko revised “No title”: “No title” at http://lpaste.net/214907
09:35:43 <felko> glguy how can I do in this case ?
09:36:54 <felko> also is there a particular reason for the middle expression not being evaluted in the same scope ?
09:37:15 <glguy> Yeah, that's the point of arrow notation, so isolate these scopes
09:37:41 <glguy> there's a desugaring algorithm to transform that notation to the various operations in the Arrow class
09:38:02 <felko> i'll check that out
09:38:13 <felko> thans anyway
09:38:19 <felko> *thanks
09:47:52 <mbrgm> can someone give me a hint where I could learn about "spawning one shell process, then once that one is finished spawn another one"?
10:03:09 <saurabhnanda> if I want to compose a lens getter in point-free form, which function should I be using?
10:04:43 <saurabhnanda> how to convert this to point-free form? (t >>= (\x -> Right $ activateTenant $ x ^. key))
10:05:11 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
10:05:11 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
10:05:11 --- names: list (clog iojNMgh5ZH godel_ sdx23 stef204 zjyjer martinga_ `^_^v manuel_ drbean RegEchse DrGuschtel ype iskander zort dmag_ Rodya_ nr152522 tmtwd caumeslasal infinity0 cspin godel ninjazoe demize justan0theruser copy` prohobo sigma9141 texasmynsted connrs miklcct cyphase breadmonster mbrgm samba1 irrequietus jomg osa1 rgrinberg free_beard urodna hpc dsh biglama glguy dh desophos BrambleG cdk_ zipper eivarv vqrs buglebudabey wildlander thunderrd cmdv)
10:05:11 --- names: list (saurabhnanda diphuser Elish psychicist__ Kuros` takle passy topi zariuq MindlessDrone JoshS Squarism unclechu max-m gnull TimWolla padre_angolano timemage Xalphor aarvar ph88 leat4 Gurkenglas_ brian[m] AleXoundOS SShrike soLucien shesek M-wamaral srenatus[m] teqwve radix1 Voldenet ertes whald tigg_ M-krsiehl nidzo_ M-Quora M41px[m] groscoe t0m0 AntiSpamMeta romich oisdk_ _flow_ ManiacTwister angular_mike_ lancetw JackMc metalrain zrl zph reem)
10:05:11 --- names: list (adulteratedjedi johtso spicydonuts a____ptr bgyss kilimanjaro zero7 loopspace iphy shelling__ FMJaguar billstclair ocharles_ YP-Cloud__ dgonyeo cstrahan peteretep Xorlev paf31 Scorchin ajmccluskey wyvern kipd jmct Tritlo dstockwell Deide frostarea jgt obadz buttbutter bjz magneticduck HanlonsRazor cyberlard sdothum slackircbot mjo SAL9000 mankaev erikd simukis_ Hi-Angel twanvl_ ziocroc fr33domlover thc202 Guest29189 ggole_ briansteffens gienah pfoetchen)
10:05:11 --- names: list (MoALTz nidr0x DavidEichmann jophish___ albertus1 netheranthem Wizek Wizek_ Levex kurnevsky Tinchos Lowl3v3l t0by zyhn _janne vili_ danvet boothead carado bhiliyam hackebeilchen jluttine no-n shookees tax Orion3k takuan agocorona hackagebot vlatkoB_ UzUzTd firstdayonthejob nepiktaz cfricke hvr bd_ moop robertk BartAdv geppettodivacin dmiles whiteline deank grouzen Sgeo valdyn tag nerdystreetrat statusbot steshaw daey lonokhov Sam__ ljhms bounb pratch)
10:05:11 --- names: list (acertain k4rtik otto_s_ Vektorweg1 hexagoxel lspitzner Chobbes Sose vin-ivar cads hucksy MrWoohoo herzmeister [k- MrElendig majoh joe9 mt travism rdesfo[m] Rotaerk pyon statusfailed barrucadu jlouis_ supki srk phileas alanz otterdam hanDerPeder LeaChim mindos_cloud____ ahf shans_ Saizan nikola qz chbatey Ornedan killtheliterate Twey chris2 lieven ElderFain Reisen johnw fycth GGMethos_ scopedTV zugz integral tomus zomg Rembane_ lucz dpn` irclogger_com)
10:05:11 --- names: list (adarqui AustinMatherne jgornick kandinski Akahige nakal__ herzen jorj koz_ rembo10 Rarrikins theDon Tharbakim markus1199 predator217 pavonia niko worch M-Shrike isochronia tagada[m] pkmx[m] M-Illandan M-mistake M-schmittlauch SeriousBug[m] M-Magnap M-david davidar bb010g[m] Swizec oldmanmike mendez alpounet henriquev wting caw Ring0` geal cgfbee lattenwald ryanpcmcquen alunduil codedmart happy0 toure cannibalbob jaimguer Brando753-o_O_o Hermit)
10:05:11 --- names: list (hamishmack magthe cods benjamin1rom Jupelius ricardo82 minsky dpepsilon RevJohnnyHealey luis` horatiohb abh CurryWurst_ atk canta yeltzooo hodapp freekevin TxmszLou foobars Ravana sqrt2 hegge mariothemad baweaver dan_f davl shapr_ greenbagels_ EvanR moei shachaf nlz jcp__ ctag urh Fylwind __name__ bitemyapp sdrodge tippenein javax mell solidsnack ziman kosorith JPohlmann daf sajith MK_FG rotcpy nickpascucci coius Yaiyan Xandaros Myrl-saki APic naudiz)
10:05:11 --- names: list (shennyg PlasmaStar wtw mjrosenb nekomune urdh asjo p_q edwtjo liste _kit_ m1dnight` bbee Pucilowski Rodya andjjj23 Geekingfrog cdidd jackhill eamelink_ ben tumdedum PanicSkittle klugez spacebug Morgawr mak` a3Dman Maxdamantus cow-orker sleepynate Deewiant richi238 ephess_ amalloy_ alang__ osfameron Guest5571 johnstein seliopou Warrigal katymoe_ indiffernet newsham heurist ycheng CindyLinz Elision cross wayne parsnip superfatkappa amiri hemite mdarse)
10:05:11 --- names: list (Flaeme davean nornagon giraffe_ bitonic djm_ Belgarion0 alphonse23_ yaknyasn PotatoGim marcel sephiap stephe dextertzu machinedgod amatecha Amun_Ra nesqi l3france gpampara Forlorn ggherdov dsm heyj mnoonan arkeet ixti tharper glowcoil milessabin MorTal1ty gsingh93 liyang thebnq Merv Filthy_casual zymurgy rann wizonesolutions qmm lexi-lambda jfokkan__ jmathes CARAM__ dogui jdt si14 hausdorff ryantm sns marienz stevenxl OliPicard banjiewen dwarders)
10:05:11 --- names: list (fengshaun cheater snoogie prkc LuckyRawApe CaptainLex __main__ mbrcknl jw358 marmoute Zialus relrod obihann saurik vishesh Profpatsch VitorCBSB angseus fmapE StoneToad spoonm _drazil sevas qguv octo_ lassulus Phillemann n__dles swhalen ndeine hansihe mantovani bluepixel revprez joedevivo Raynes zetavolt absence brixen dhananjay unsymbol c_wraith emeritus tomaw Ulrar JDevlieghere_ alang solarus geekosaur Mandus HalfEatenPie dzack prayfordiyab mkloczko)
10:05:11 --- names: list (32NABS4B6 xa0 jimki bananagram shwouchk Elsi bjs mw jlewis seagreen CosmicRay kishar_ baetheus djsjadkhf dcoutts_ catgirl PierreM eikke spaceships gothos dario idupree carc xfix acfoltzer mikeizbicki adimit Lord_of_Life flux SolarAquarion Klumben xacktm @ChanServ martinr_ heinrich5991 staticfox trevorriles kini tg edran seveg reactormonk Boreeas vfs ario maerwald xxpor Factionwars myfreeweb ephemeron arianvp dredozub- Ke ReinH_ wrengr_away samgd_)
10:05:11 --- names: list (s4kashya Drezil greeny mtesseract thomas iteratee acro ChongLi mrm ski euphoria- iross pdxleif haldean shymega c-rog pdgwien Marqin anachrom1 sLite Akii henrytill niluje Fuuzetsu Iceland_jack kosmikus andreass lachenmayer KaneTW fairfieldt dredozubov_ MasseR d3lxa oelewapperke sword_smith ollef SenpaiSilver mlhmwglt mikeplus64 Sigyn aloiscochard Bane^ Liskni_si bitch Xe elementalest bdeferme IndigoTiger posco burp_ dfranke felixsch timrs2998 Forkk kungp)
10:05:11 --- names: list (asm89 joehillen mudfog kriztw higgs betawaffle Amadiro _Shandy Edoxile alem0lars BigTrouble M2tias esmiurium officer_raccoon ncl28 NickHu gniourf tnks Tehnix beaky koomi Reyu Purlox petercommand Axman6 cschneid rotty x1n4u bgamari lpaste _6a68 minad Jaxan raid da-x brezel tgeeky cbaines SuperTux88 lispy fyolnish Blkt codehero akermu nemesit|znc pflanze SegFaultAX sohum kier Quintasan l4m8d4 Ezku Snircle shyn ixian cloudhead rockfruit noexcept_ divVerent)
10:05:11 --- names: list (chrzyki cnr drdo Zemyla weechat4 abbe Tesseraction amuck bengt_ Wamanuz2 Neo_ jorendorff_ stelleg_ Eliel_ vervain_ Guest196 Dykam_ Bigcheese_ KorriX_ eronel_ jonrh Moyst staffehn_ Jinxit jkarni_ grumble enolan grol_ SLi kolko_ nitrix sivs_ nbouscal Guest57142 deni Cathy yorick_ Laney pharaun gseitz_ Ankhers danieli kolmodin orcus tobik suzu ernst dxtr chelfi koala_man dcoutts Matajon ahihi Willis KeelOfSteel ion rbocquet bshelden reynir oldsk00l zenzike)
10:05:11 --- names: list (RGamma kjanosz lenstr quuxman Xnuk hpd squimmy m4lvin teppic Nycatelos fall__ jokester defanor fnordbert Saimeidae rom15041 filibustr Guest97047 mitch_ madknight hyPiRion kiwnix ego benj02 MarcelineVQ sim642 hbar_ rossberg luite Clint Mon_Ouie cjh` donwilliam DANtheBEASTman wrmsr fold4 ClaudiusMaximus taruti phz_ sujeet aleator jibi t0mb0_ flonk mmaruseacph2 tabaqui Hakey sphalerite otulp nont__ Benzi-Junior norotartagen dpower aupiff Athas Philonous)
10:05:11 --- names: list (electrostat bjobjo oberstein kav Kneiva_ jotrk eagleflo sgronblo hughrawlinson stass elgot Princess17b29a RayNbow` int-e lyxia zennist1 froztbyte fabiopbx_ neonfuz notdan_ e armlesshobo XMunkki_ pelegreno___ nshepperd_ schjetne keko-2 kshannon_ pyrtsa zerokarmaleft Chousuke_ dqd bcoppens haircode fuziontech treehaqr bartavel` nathyong kritzcreek huonw coup_de_shitlor- Desoxy Starfire_ vikram__________ Phyx- unbalanced hiratara spinda japesinator)
10:05:11 --- names: list (thorkilnaur TrevorBramble tazjin_ mitchty_ besenwesen Taneb anoe tomku Biohazard lstrano wamaral wjm cin intothem1untains hiptobecubic brolin_empey noplamodo Soup nshepperd1 Mokosha xnyhps segmond oskarkv afcondon joncfoo sbrg niklasb cic nek0 louispan sa1 pikhq jnoah etrepum nwf dmoon1221_ ReinH kyagrd micmus strmpnk xplat|work mpickering avdi nkpart quoboo jml phuu sclv {AS} incomprehensibly chriswk S11001001 crough mbrock rlr mkurkov edwardk rfw)
10:05:11 --- names: list (emiliocobos rstone caasih ericbmerritt lukexi georgew trig-ger w4and0er96 justicefries thoughtpolice bigs monad_cat AlainODea pkogan carter adelbertc mno2 seanparsons tjpeden jessicah yminsky tumi so runeks pchiusano Cerise schnizzle uwap jrslepak buoto mrd avn pmade grantwu gnusosa hxegon astocko Qommand0r codeman777 tromp ppnkk frontendloader Cale siklsten ao1ei8_ flipping1it cdsmith_ theo scinawa1 Ralith_ sjl__ kantokom1 qknight arw__ hsyl20)
10:05:11 --- names: list (knyppeld1nan raek_ ido_ jstimpfl1 DiabolikFreenode ipuustin_ ggVGc ircbrowse esssing kmicu nmattia tinkyholloway borkdude_ cocreature suppi etabot peddie nille bind tabaqui1 adamCS Jello_Raptor noctux kuno nyuszika7h zxtx johnv_ folsen inr pkmx ijp ortmage_ chirpsal1 kloeri Nikotiini Soft jchia_ Ranhir scared yulax julmac shutdown_-h_now bshd swistak35 yamadapc albel727 sshine gridaphobe wolfcore kipras fkurkowski mrlase `0660 joeytwiddle Yuras jbalint)
10:05:11 --- names: list (jtobin solatis gabiruh_ przembot juri_ mgaare_ Jonno_FT1 Freundlich ninefing1rs cynick_ haasn johl bsermons_ monkeyiqde DustyDingo chronon-io fergusnoble kian- tokik riscool leadingthenet karls ali_bush_ pacak1 eyck PHO jinblack prooftechnique_ rodlogic magicman tekacs Tristan-- wildleaf_ funfun CodeKiwi Khudher mceier joeyh kwantam LordDeath nopf qnikst kyren saidinwot Majiir guios qryantm lpsmith earthy lanodan bugabinga lhynes parenthetical rcsgns_)
10:05:11 --- names: list (SparkySparkyBoom descender BrAsS_mOnKeY PalTale marmalodak Gothmog_ ngWalrus sag3 alercah LnL Baughn ybit bydo zhulikas tristero jzl amiller_ Ewout numberten hnz Khisanth citaret eliasr zaquest Enigmagic alx741 mimi_vx fingerzam hex0punk1 runawayfive abrar brent thallada jrib1 ynyounuo Adeon SiCC trajing RazorX jtcs JRHaigh jvanbure M-ou-se jonored brisbin fxrs wedens orzo capisce [swift] nurupo omilu jchia tolt aweinstock ploop tv1 guampa logcat)
10:05:11 --- names: list (xocolatl jpl Guest53913 vodkaInferno nshepperd DDR nilOps leothrix ramatevish Lutin` cjay lambdabot Rabbit_ m1dnight_ poga lukky513 andromeda-galaxy gorbulas martingale ArP Eagle_Erwin comboy bencryption cjwelborn Sonderblade calloc Oxyd jophish stux|RC-only simony s4kashya_ jle_ yarou tek0 netblaze srhb nathanic rcat mrowe _ashbreeze_ gfixler Taylor Hafydd robogoat siddhu hongminhee jix s4msung epta sparr ongy dmwit ajaniMember fiddlerwoaroof Ninja3047)
10:05:11 --- names: list (pieter garphy`aw croben dyreshark a6a3uh __rlp joachifm bob_twinkles tych0 jrp6 codebje squisher kennyp tessier bsmt nckx dju denimuser mathu dunj3 Tene ps-auxw marinintim TheMystic qinusty Nik05 g4k andreypopp jokleinn4 Igloo tdammers Immune_ Greezler lulf_ Bengi carter-znc TommyC mankyKitty niteria_ krgn mauke jroesch_ tero- adraenwan robtaylor pcapriotti tctara_ marens_ zpconn__________ kaol sbauman fabianvf mattp_ bairyn_ phadej_ ft DTZUZU mads-_)
10:05:11 --- names: list (wagle goldfire vikraman AppleJacks24 anelson arrdem_ hiredman Jaak surtn Sagi implementation_ Sorella ddima gargawel spion hive-mind dolio theorbtwo etcinit brennie aatxe schultz gornikm tjbp_ cmr telmich DrCode hydraz TabAtkins sykora opqdonut diskie_ undermink stasku pikajude MitchW thoros zmanian__ Speed emmflo42 dan64- navilan- nanovad isomorphismes psmolen_ Vbitz_ Volundr Robin_Jadoul Vq_ andyo_ strixy eL_Bart0 dibblego yusukesuzuki_ dxld qnix_)
10:05:11 --- names: list (Hijiri_ NemesisD beckyconning_ oherrala3 metaf5 pygospa potatoe` orion__ sisir___ tarcwynne_ o`connor tusj codebam Madars byorgey aristid shock- intelux jlyndon mniip daishan luigy Bashmetim sebastian-w Nahra` fryguybob verement opios sleezd dustinm monty amontez hc shirt tsani watersoul atomi benzrf sdemos bogdanteleaga exio4 ent dschoepe ec\ eddsteel Rembane linduxed irishsultan aaron7 Arguggi icedev nilsi anderson RageD monochrom Bez_ ryoia dsantiago)
10:05:11 --- names: list (Intensity)
10:07:37 <glguy> using `view'
10:07:48 <pavonia> mbrgm: Have you looked at the process package? It has various commands for starting processes which you could run in a loop
10:08:10 <mbrgm> pavonia: thank you, I'll take a look at that. just didn't know where to start.
10:08:38 <geekosaur> that looks like the kind of thing I wouldn't want to try to pointfree tbh (assuming \t key -> ...)
10:09:43 <glguy> saurabhnanda:   fmap (views key activateTenant)
10:09:44 <saurabhnanda> glguy: the type of view has a MonadReader, strangely
10:10:04 <glguy> saurabhnanda: Yeah, it's a generalization of functions
10:10:07 <saurabhnanda> glguy: view and views are very different
10:10:13 <glguy> Not very different
10:10:24 <saurabhnanda> glguy: actually both have monadReader
10:10:51 <glguy> t >>= \x -> Right (f x)    is fmap f t
10:12:19 <saurabhnanda> glguy: I'm getting confused
10:12:37 <saurabhnanda> glguy: I'm working with an AppM (Either CustomError Tenant)
10:12:39 <ReinH> more generally, k >>= \x -> return (f x) is fmap f k
10:13:01 <saurabhnanda> the code that I wrote above, has the type -- AppM (Either CustomError (AppM Tenant))
10:13:07 <saurabhnanda> AppM is getting nested!
10:13:22 <ReinH> That doesn't seem like the right type
10:15:08 <saurabhnanda> ReinH: it isn't 
10:15:22 <saurabhnanda> ReinH: I'm working with two monads at the same time -- AppM and Either
10:16:22 <glguy> saurabhnanda: the fmap and views thing i posted doors what you wrote
10:16:46 <saurabhnanda> glguy: which one?
10:19:48 <saurabhnanda> ReinH: glguy: trying to shorten http://lpaste.net/215073
10:20:53 <ReinH> that's just fmap
10:21:52 <ReinH> return . fmap (activateTenant . view key), I believe.
10:22:07 <soLucien> http://lpaste.net/352876325515558912
10:22:10 <soLucien> is this correct ?
10:22:18 <soLucien> is the applicative pure function correct ?
10:22:23 <saurabhnanda> ReinH: in an Either inside a ReaderT, what does fmap target?
10:22:26 <ReinH> soLucien: Does it satisfy the laws?
10:22:38 <soLucien> all 4 of them ?
10:22:41 <soLucien> i don't know
10:22:49 <ReinH> saurabhnanda: That's what you need to know to know if it's correct.
10:22:50 <soLucien> is that the way i have to look at it ?
10:22:53 <ReinH> saurabhnanda: start with the pure laws
10:23:07 <ReinH> yes, that's what correct means: satisfies the laws.
10:23:12 <soLucien> soLucien* :D
10:23:27 <ReinH> sorry, soLucien ^
10:23:36 <ReinH> saurabhnanda: that depends on context.
10:24:18 <ReinH> In this case, I think you want fmap (fmap (activateTenant . view key)
10:24:41 <ReinH> since you have a functor nested in a functor
10:24:49 <ReinH> also I'm missing a )
10:25:44 <ReinH> soLucien: start with pure id <*> v = v
10:25:48 <saurabhnanda> ReinH: createTenant::NewTenant -> Appm (Either TenantCreationError Tenant) and activateTenant::TenantId -> AppM (Tenant) 
10:25:52 <saurabhnanda> ReinH: if that helps
10:26:01 <ReinH> soLucien: wait, how does that even compile?
10:26:06 <ReinH> pure doesn't have the right type
10:26:40 <ReinH> saurabhnanda: if activateTenant is an action then I don't think your code is correct
10:26:45 <ReinH> you want to bind actions
10:26:56 <ReinH> and then not return, since that would nest the functor structure
10:27:20 <soLucien>   pure = ZipList
10:27:21 <ReinH> sorry don't mind that last, you do want to return, but not twice
10:27:30 <saurabhnanda> ReinH: this is correct -- http://lpaste.net/215073 -- it compiles and runs
10:27:35 <soLucien> i'm poking in the darkness .. i'll look at the laws
10:27:36 <ReinH> soLucien: Ok, that compiles, but does it satisfy pure id <*> v = v?
10:27:55 <ReinH> soLucien: let's take as an example: pure id <*> [1,2,3]
10:28:01 <ReinH> er
10:28:09 <ReinH> pure id <*> ZipList [1,2,3]
10:28:21 <soLucien> so id is the identity function
10:28:30 <ReinH> yes
10:28:31 <soLucien> it returns whatever was called
10:28:33 <ReinH> yes
10:28:45 <ReinH> so what is evaluated first?
10:28:53 <ReinH> remember: leftmost, outermost
10:29:03 <soLucien> pure id
10:29:16 <soLucien> it evaluates pure id , then applies the list to it
10:29:18 <soLucien> right ?
10:29:18 <ReinH> soLucien: is pure id outermost?
10:29:39 <soLucien> i actually don't know ..
10:29:48 <ReinH> in 1 + 2, (+) is outermost
10:29:52 <ReinH> the tree looks like
10:29:54 <ReinH> (+) - 1
10:29:59 <ReinH>   `- 2
10:30:16 <ReinH> well, I have that backwards, drawing is hard
10:30:16 <soLucien> so * is outermost here /
10:30:28 <soLucien> <*>
10:30:35 <ReinH> It looks like
10:30:39 <ReinH>  (+)
10:30:39 <ReinH> 1   2
10:30:44 <ReinH> Yes, <*> is evaluated first
10:30:50 <ReinH> so you can do that using your definition
10:31:36 <ReinH> In order to evaluate <*>, what needs to be evaluated?
10:31:56 <soLucien> so wait
10:32:07 <soLucien> isn't function call supposed to be evaluated first?
10:32:12 <ReinH> what do you mean?
10:32:16 <ReinH> <*> is the function
10:32:27 <soLucien> i see .. 
10:32:36 <ReinH> 1 + 2 = (+) 1 2
10:32:46 <ReinH> (+) is the function there
10:32:54 <ReinH> (<*>) is the function here
10:33:01 <NickHu> Yes, you evaluate pure id as a result of the top level <*> evaluation
10:33:02 <nshepperd1> Function calls bind tighter than operators but that's just syntax
10:33:06 <NickHu> It's implicit, soLucien 
10:33:09 <nshepperd1> Nothing to do with evaluation
10:33:11 <ReinH> in order to evaluate (<*>), we try to apply its definition
10:33:17 <ReinH> its definition involves pattern matching
10:33:24 <ReinH> on both the left side and the right side
10:33:28 <ReinH> which one is evaluated first?
10:33:33 <ReinH> remember: leftmost outermost
10:33:40 <soLucien> pure then ..
10:33:43 <soLucien> pure id
10:33:52 <soLucien> that's leftmost 
10:33:57 <ReinH> pure id is matched with the pattern ZipList gs
10:34:08 <ReinH> in order to do this, we must evaluate pure id
10:34:10 <ReinH> what does it evaluate to?
10:34:26 <soLucien> i actually don't know .. id ?
10:34:32 <soLucien> the callee ? but what is the callee ?
10:34:38 <ReinH> you said: pure f = ZipList
10:34:40 <colo> what is the infix declaration of (!!)
10:34:40 <ReinH> does that compile?
10:34:43 <saurabhnanda> ReinH: I think my problem is that, the first one needs to be an fmap and the second one a monadic bind
10:34:44 <ReinH> did you try to compile it?
10:34:50 <ReinH> colo: xs !! n
10:34:54 * hackagebot atom-conduit 0.4.0.0 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.4.0.0 (koral)
10:34:56 * hackagebot rss-conduit 0.3.0.0 - Streaming parser/renderer for the RSS 2.0 standard.  https://hackage.haskell.org/package/rss-conduit-0.3.0.0 (koral)
10:35:03 <soLucien> no i didn't i cant compile because i am overriding some stuff from the prelude
10:35:06 <NickHu> soLucien: Your expression with brackets explicitly put in looks like this (((pure) (id)) <*> (ZipList))
10:35:13 <ReinH> soLucien: You need to check your work by compiling it
10:35:48 <ReinH> It's counterproductive to ask questions about code you haven't tried to compile
10:35:58 <ReinH> all our answers that assume it compiles will be misleading
10:36:52 <colo> ReinH: sorry i mean the declaration like infixl 5
10:36:57 <ReinH> colo: https://www.haskell.org/hoogle/?hoogle=(!!)
10:37:34 <ReinH> The documentation tells you the fixity, if defined
10:38:01 <ReinH> soLucien: doing so also wastes *our* time
10:38:09 <exio4> colo: if you are on ghci and want to know the fixity of a function in scope, you can use :i
10:38:10 <ReinH> since we spend time doing something futile
10:38:20 <soLucien> okay , my apologies
10:38:37 <ReinH> if you want to know if your code works, step 1 is always to ask the compiler
10:38:43 <soLucien> i have commented out the stuff that can't compile from http://lpaste.net/2053808328215101440
10:39:01 <soLucien> i can't compile because some of this stuff is already defined in prelude
10:39:04 <ReinH> soLucien: Show us the actual code you compiled and any compiler error please.
10:39:10 <ReinH> You can hide things from the prelude
10:39:20 <colo> exio4: i tried but it only gave me the type declaration
10:39:22 <ReinH> import Prelude hiding (things, you, define, yourself)
10:39:26 <soLucien> then i have to re-declare  Maybe for ecample
10:39:31 <ReinH> No you don't.
10:39:31 <soLucien> example
10:39:35 <ReinH> You can hide specific things
10:39:48 <soLucien> ok .. i tried iport qualified
10:39:53 <soLucien> import qualified
10:39:59 <ReinH> import Prelude hiding (things, you, define, yourself)
10:40:18 <ReinH> or, import Prelude (things, you, want, to, import)
10:40:24 <soLucien> how can i hide the Functor Either ?
10:40:31 <soLucien> only the functor, not either itself
10:40:35 <NickHu> ReinH: You can't hide instances
10:40:36 <ReinH> You can't hide typeclasses, unfortunately
10:40:42 <ReinH> but you can call your Either something else.
10:40:47 <NickHu> Define a new typeclass
10:40:56 <ReinH> Either isn't relevant to your question though
10:41:32 <soLucien> http://lpaste.net/2053808328215101440 this is what i was trying to compile , but i can't because of the prelude
10:41:38 <soLucien> i commented out the functors
10:41:44 <ReinH> yes, but most of that has nothing to do with your question
10:41:49 <soLucien> which i am overwriting ..
10:41:53 <soLucien> i know , apologies
10:42:16 <NickHu> Declare a typeclass Functor' with identical functions except with an ' at the end
10:42:24 <NickHu> Then make instances for that
10:42:51 <ReinH> NickHu: He'd also need to define his own Applicative.
10:42:58 <ReinH> Alternativley, define ZipList'
10:43:07 <NickHu> Yes, either works
10:43:13 <ReinH> except if you aren't importing Control.Applicative, it shouldn't be in scope
10:43:15 <ReinH> nor its instance
10:43:20 <ReinH> so none of this is relevant *to the question*
10:43:25 <NickHu> ReinH: On newer GHC it is
10:43:33 <ReinH> NickHu: ZipList is in Prelude?
10:43:39 <NickHu> Oh idk about ziplist
10:43:46 <NickHu> But pure and <*> and stuff are
10:43:47 <ReinH> That's the thing in question
10:43:48 <ReinH> Yes.
10:43:50 <ReinH> But that's fine.
10:43:58 <ReinH> He's defining his own ZipList
10:44:00 <ReinH> so I assume it isn't in scope
10:44:09 <soLucien> exactly .. i will fix them some other time .. 
10:44:13 <soLucien> i am defning it because
10:44:23 <ReinH> just put ZipList and its alleged instance in their own file
10:44:24 <soLucien> it's an exercise from the Typeclassopedia
10:44:27 <ReinH> and try to compile it
10:44:32 <soLucien> yep
10:45:23 <ReinH> There's a simple problem that I can easily demonstrate with what I think you intend pure to be, but what you have right now is just a type error
10:45:56 <ReinH> So fix that first and then we can talk
10:46:25 <ReinH> On a side note, I really wish more libraries would expose internal modules
10:46:38 <ReinH> I've been trying to find a trie where I can actually access the tree structure directly, but nope
10:46:53 <saurabhnanda> help with http://stackoverflow.com/questions/39689887/how-to-compose-functions-operating-with-readert-and-either please
10:47:03 <NickHu> What for?
10:47:07 <ReinH> The thing I want to write is dead simple if you can recurse on the tree structure, annoyingly complex and inefficient otherwise
10:47:18 <ReinH> I want to prune the tree to its minimal prefixes
10:47:47 <soLucien> http://lpaste.net/1347416143668707328
10:47:57 <soLucien> so yes, type error
10:48:07 <NickHu> Remember the type of pure :: a -> f a
10:48:15 <ReinH> which is just prune (Trie True _) = Trie True mempty and the other cases do the usual recursion
10:48:28 <ReinH> (for the map-based trie)
10:49:09 <NickHu> ReinH: This sounds like a traverse
10:49:12 <ReinH> soLucien: what is the type of ZipList?
10:49:19 <NickHu> :t ZipList
10:49:20 <ReinH> NickHu: fortunately for me, they aren't traversable.
10:49:21 <lambdabot> [a] -> ZipList a
10:49:29 <ReinH> NickHu: *I* know its type.
10:49:44 <NickHu> Yeah I know, I just wanted to illustrate
10:50:39 <ReinH> I hacked something together in a less agreeable way for now
10:51:04 <soLucien> yes a -> [a]
10:51:09 <ReinH> might contribute the correct version back to list-tries, if I can figure out my way around that package's maze of typeclasses
10:51:19 <NickHu> lol
10:51:38 <soLucien> newtype ZipList a = ZipList { getZipList :: [a] }
10:51:42 <ReinH> soLucien: What is that an answer to?
10:52:11 <ReinH> pure for ZipList is of type a -> ZipList a, not a -> [a]
10:52:54 <ReinH> Now, note that the contents of a ZipList needs to be [a]
10:53:19 <ReinH> Which means that, given a value of type `a', you first need to make a value of type `[a]' before you can package it up with ZipList
10:53:43 <ReinH> so pure = ZipList would give you ZipList id, but ZipList id is not a valid ZipList.
10:54:09 <ReinH> There are in infinite number of ways to turn a value into a list of values, you just have to pick the right one.
10:55:32 <ReinH> NickHu: Hmm. There should be some generic traversal of the tree that my function is an instance of, which I can contribute.
10:55:53 <NickHu> Yeah, that's what I was thinking
10:55:54 <ReinH> It might just be the canonical Church fold.
10:56:00 <NickHu> It sounds just like a traverse to me
10:56:22 <ReinH> Well, Boehm-Barducci for you pedants out there
10:56:54 <ReinH> NickHu: which begs—I mean prompts— the question: why isn't it Traversable?
10:57:03 <NickHu> Mm
10:57:23 <NickHu> Could someone go over this typeclassopedia exercise with me? I'm not sure if I got the intention correct
10:57:26 <NickHu> http://lpaste.net/215242
10:57:39 <NickHu> It's about the alternative formulation Monoidal
10:57:50 <ReinH> NickHu: And I don't think it's a Traversable traverse, it's the canonical fold.
10:58:21 <nshepperd1> ReinH: isn't that a cata
10:58:30 <ReinH> nshepperd1: probably?
10:58:37 <nshepperd1> The trie thing i mean
10:58:42 <ReinH> me too
10:59:18 <ReinH> NickHu: Everything in Hask is a comonoid.
10:59:35 <NickHu> Ignore the names, I just kinda guessed
10:59:36 <ReinH> but that isn't counit.
10:59:46 <ReinH> :t mempty
10:59:48 <lambdabot> Monoid a => a
11:00:07 <ReinH> If you consider that a is isomorphic to () -> a
11:00:24 <nshepperd1> So the library author needs to be heckled into adding a data.functor.foldable instance :)
11:00:26 <ReinH> then unit :: () -> a has, as its dual, counit :: a -> ()
11:00:29 <ReinH> which is just const ()
11:00:52 <ReinH> and mappend :: (m, m) -> m has, as its dual, comappend :: m -> (m, m)
11:00:58 <NickHu> ReinH: That's not the definition of unit in the typeclassopedia
11:00:59 <ReinH> which is just \m -> (m,m)
11:01:01 <NickHu> It means something else
11:01:10 <ReinH> If that isn't the definition of unit then it isn't a monoid
11:01:12 <NickHu> Monoidal isn't Monoid
11:01:16 <ReinH> Oh, ok.
11:01:19 <ReinH> Then the names are bad
11:01:22 <NickHu> https://wiki.haskell.org/Typeclassopedia#Alternative_formulation
11:01:42 <ReinH> Unless they're referring to monoidal in some other category, which is possible
11:02:10 <NickHu> Well Edward Yang came up with it so I suppose you'd better take it up with him lol
11:02:56 <ReinH> I don't disagree with the formulation, but the names are certainly confusing without context.
11:03:30 <ReinH> This is one way to show that applicatives are closed functors, which is nice enough.
11:03:30 <NickHu> I thought I said it was a typeclassopedia exercise
11:03:32 <ReinH> https://ncatlab.org/nlab/show/closed+functor
11:03:48 <ReinH> NickHu: Yes, that provided *some* context :)
11:04:03 <ReinH> I prefer it to the lax monoidal functor with a strength account, anyway
11:04:38 <NickHu> Yeah, anyway, did I get the point of the question? I'm not convinced in my answer
11:05:25 <ReinH> NickHu: counit is easy enough, since () is terminal: counit _ = ()
11:05:55 <ReinH> there's automatically this canonical arrow from every type to ()
11:06:14 <ReinH> (canonical in the sense that it is unique up to unique isomorphism)
11:06:22 <ph88> hello
11:07:26 <lyxia> ph88: hi
11:07:32 <ReinH> This means that any other thing you can do is equivalent to this thing, so there's no choice to be had about counit.
11:07:34 <ph88> :)
11:07:44 <ph88> i don't understand why my parser is failing at this point  https://paste.fedoraproject.org/435399/82682014/
11:07:55 <NickHu> Yeah it's more the laws part I'm not certain about
11:08:02 <ReinH> NickHu: you're wrong about your counit for Maybe, since counit (Just x) = () as well
11:08:38 <ReinH> (A different sort of counit is m a -> a)
11:08:58 <ReinH> (the one for comonads)
11:09:33 <ReinH> NickHu: Let me ask you this: can you demonstrate a type that *is not* an instance of Comonoidal?
11:09:57 <NickHu> ReinH: counit (Just x) = x implies counit (Just x) = () because the only type x can take is ()
11:10:38 <ReinH> Oh, it does. I missed the part where it's f () -> () despite reading it multiple times since it doesn't make sense.
11:10:41 <ReinH> ;)
11:11:32 <NickHu> Probably would've been better to write counit _ = () but I wanted to be explicit for when I read it again X months into the future
11:11:37 <ReinH> Anyway, what is an example of an Applicative which is not Comonoidal?
11:12:04 <ReinH> const () is the only function from any type to (), so it is also the function from f () to () for all f. ;)
11:12:29 <NickHu> Yeah, I see
11:12:36 <saurabhnanda> is there only one ExceptT ? If not, which is the recommended package?
11:12:48 <NickHu> Are the laws I wrote at the end "reasonable" though?
11:13:09 <ReinH> saurabhnanda: transformers implements it, mtl builds on transformers
11:13:43 <ReinH> NickHu: yes, they are the "obvious" ones. :)
11:13:57 <saurabhnanda> ReinH: so I should be looking at the one in mtl package?
11:15:07 <EvanR> whats the diffrence between category Set and category Hask 
11:15:24 <NickHu> EvanR: They have different objects and different morphisms
11:15:32 <ReinH> EvanR: Everything.
11:15:54 <ReinH> Better to ask: how are they similar?
11:15:55 <EvanR> is it more than alphaconversion
11:15:57 <EvanR> thats what im asking
11:15:59 <ReinH> Yes.
11:16:13 <NickHu> Hask isn't a real category anyway
11:16:19 <NickHu> In a mathematical sense
11:16:25 <ReinH> We can easily define Hask to be a real category.
11:16:25 <EvanR> like which properties of Set does hask not have
11:16:47 <ReinH> It just won't be the category of Haskell types and functions.
11:17:18 <NickHu> EvanR: Well in Set, the objects are mathematical sets and the morphisms are functions
11:17:34 <NickHu> In Hask, the objects are types and the morphisms are haskell functions
11:17:38 <EvanR> uh huh, im waiting for something not of the form "rename X to Y"
11:18:22 <EvanR> name a thing not in hask, for some reason besides we dont call it that
11:19:09 <EvanR> ex. all objects in hask are comonoids
11:19:19 <EvanR> are there objects in Set that arent comonoids?
11:19:43 <NickHu> EvanR: That's a result of the types we can write down being comonoids
11:19:50 <NickHu> And the objects of Hask being types
11:19:59 <EvanR> the question remains
11:20:02 <NickHu> Well
11:20:08 <NickHu> Mathematical sets aren't comonoids
11:20:12 <EvanR> no?
11:20:28 <NickHu> I don't really know enough category theory, but I didn't think they were
11:21:28 <EvanR> perhaps you can saay there are functions in Set defined using law of excluded middle, but obviously not in hask
11:22:33 <EvanR> like, R -> Bool such that x rational -> True, x irrational -> False, and these are the only choices
11:22:36 <NickHu> Not if you are a constructivist ;)
11:22:47 <EvanR> ive seen that done in math class, so it must be in Set ;)
11:23:05 <ReinH> Set is cartesian closed. There are arrows S -> {} and S -> S^2 for all objects S in Set.
11:23:18 <EvanR> sure
11:24:22 <NickHu> You have no law of excluded middle in constructive mathematics though
11:24:26 <ReinH> Presumably by Hask we mean the nice Platonic Hask without bottoms.
11:24:28 <EvanR> maybe this question depends just as much on what Set really is
11:24:33 <EvanR> yes
11:25:44 <ReinH> EvanR: Basically, we believe that Hask has more structure than Set.
11:25:45 <EvanR> i assume Set is classic set theory with all the classical logic, otherwise youd be using a different category
11:26:03 <ReinH> It might be a CPO
11:26:53 <EvanR> i see
11:27:09 <EvanR> all functions in moral hask are scott continuous
11:27:28 <EvanR> though without bottoms whats the point
11:30:03 <ReinH> EvanR: well, when you get into categorical interpretations of strictness, it becomes significantly more complicated
11:30:04 <ReinH> e.g., https://pdfs.semanticscholar.org/7b69/c7333092e5824edfc7e2256d4f3daa249794.pdf
11:30:51 <ReinH> Platonic Hask is useful for a bunch of things and falls over in a way that is relatively predictable (c.f. fast and loose reasoning)
11:32:16 <nshepperd> there are morphisms in Set that aren't in Hask, such as programHalts :: Program -> Bool
11:32:59 <EvanR> and that exists in Set 
11:33:38 <EvanR> "merely"
11:33:48 <nshepperd> actually i'm not sure
11:33:53 <EvanR> so Hask has less functions
11:35:49 <ReinH> nshepperd1: In Platonic Hask, there are no bottoms
11:35:52 <ReinH> there is no halting problem
11:36:08 <EvanR> theres countable functions from Nat to Nat but uncountable from N to N in Set
11:36:22 <soLucien> okay so i can't get this to compile 
11:36:23 <soLucien> http://lpaste.net/6250838301008199680
11:36:31 <nshepperd> ReinH: even in platonic hask you can ask whether some python source code represents a halting program
11:36:39 <soLucien> i believe the issue is on line 9
11:36:59 <EvanR> yes Program isnt nec haskell
11:37:12 <intothem1untains> fmap for Maybe defines 'fmap g (Just a) = Just (g a)'. But what if a is a functor itself? Why not 'Just (fmap g a)'?
11:37:18 <soLucien> how can i pattern match the [ITree] list ?
11:37:19 <nshepperd> and there's no platonic Hask program that will calculate that
11:38:12 <Clint> intothem1untains: what?
11:38:47 <intothem1untains> Clint: which part what?
11:39:12 <ph88> anyone want to have a peek at my parser issue ?  https://paste.fedoraproject.org/435399/82682014/
11:40:27 <soLucien> i added the error message
11:40:33 <soLucien> it's long and i don't understand it
11:40:45 <ReinH> soLucien: you say fmap as.
11:41:29 <ReinH> are you sure that's what you want?
11:42:14 <ReinH> intothem1untains: f a isn't a functor.
11:42:20 <soLucien> i want to fmap on the other as
11:42:26 <soLucien> so its recursive
11:42:27 <ReinH> fmap *what* on the other as?
11:42:37 <ReinH> > fmap [1,2,3]
11:42:39 <lambdabot>  error:
11:42:40 <lambdabot>      • Couldn't match expected type ‘a -> b’
11:42:40 <lambdabot>                    with actual type ‘[Integer]’
11:42:41 <ReinH> > fmap succ [1,2,3]
11:42:42 <soLucien> fmap (f as) ?
11:42:44 <lambdabot>  [2,3,4]
11:42:46 <ReinH> No
11:42:58 <ReinH> fmap takes a function
11:43:02 <ReinH> you give it a list
11:43:15 <soLucien> fmap f as still gves errors
11:43:48 <ReinH> `fmap f` isn't right either
11:43:53 <ReinH> > fmap succ
11:43:56 <lambdabot>  error:
11:43:56 <lambdabot>      • No instance for (Typeable f0)
11:43:56 <lambdabot>          arising from a use of ‘show_M286280026406539433912253’
11:44:10 <ReinH> fmap f is a function that takes (in this case) a list
11:44:24 <soLucien> as is the leftover list
11:44:28 <ReinH> Yes.
11:44:34 <ReinH> `fmap f` does not reference as
11:44:40 <intothem1untains> ReinH: the Maybe data type is an instance of Functor and defines "fmap _ Nothing = Nothing; fmap g (Just a) = Just (g a)" right?
11:44:52 <ReinH> intothem1untains: yes.
11:45:09 <intothem1untains> What if that a type was a Functor too?
11:45:10 <soLucien> so fmap f as
11:45:15 <ReinH> soLucien: Yes.
11:45:21 <ReinH> intothem1untains: It isn't.
11:45:27 <intothem1untains> Why can it not be?
11:45:29 <soLucien> still doesn't compile ..
11:45:45 <ReinH> soLucien: I didn't say that would make it work, but it was certainly wrong.
11:46:03 <ertes> intothem1untains: there is a kind error in your question =)
11:46:18 <ReinH> ertes: because a is a value
11:46:24 <ReinH> and instances of functor are not values
11:46:28 <intothem1untains> ertes: Would a list of lists not be an example of it?
11:46:35 <ReinH> intothem1untains: No, it would not.
11:46:36 <soLucien> http://lpaste.net/2807813729930969088
11:46:49 <ReinH> f must be of kind * -> *
11:46:56 <ReinH> and it is applied to a, which means that a must be of kind *
11:47:06 <ReinH> Nothing of kind * can be an instance of Functor
11:47:32 <ReinH> Now, f (g a) can be a functor, and f and g can both be functors.
11:47:44 <ReinH> e.g., f = [] and g = [] => [[a]]
11:47:52 <ertes> ReinH: uhm…
11:48:01 <intothem1untains> That kind of blow my mind
11:48:02 <Cale> ReinH: Not all of that can be true at the same time...
11:48:08 <ReinH> er sorry
11:48:11 <ertes> if f (g a) is a functor, then f is certainly not a functor
11:48:14 <ReinH> f (g a) can't be a functor
11:48:17 <EvanR> modal logic hour
11:48:18 <ReinH> but the composition of f and g can be
11:48:36 <intothem1untains> Any recommended introduction to kindness?
11:48:58 <EvanR> kindedness maybe
11:49:08 <grantwu> One thing that frustrates me about Haskell is the high number of broken links on Hackage documentation
11:49:12 <intothem1untains> (pun was intended)
11:49:23 <grantwu> For example http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Ord clicking compare here doesn't do anything.
11:49:26 <EvanR> grantwu: looking at the right doc repo?
11:49:42 <grantwu> EvanR: ?
11:49:43 <EvanR> also everyone says you should generat your own docs
11:49:47 <soLucien> ok .. so what is the trouble with my ode? Is it the null case ?
11:49:47 <intothem1untains> Coming from python, haskell docs are, erm, not good
11:50:06 <ertes> grantwu: there is something else broken there it seems
11:50:12 <ReinH> soLucien: What is line 24 in your paste?
11:50:15 <ertes> grantwu: the link doesn't work, because you're already there
11:50:25 <grantwu> Hrm, okay, i suppose
11:50:26 <ertes> but for some reason 'compare' doesn't show up
11:50:28 <soLucien> it is   fmap f (Node (a:as) ) = Node (f a): fmap f as
11:50:43 <grantwu> ertes: Yeah... that's not good.
11:50:50 <aidecoe> hello
11:50:53 <ReinH> soLucien: The error is accurate
11:51:08 <ertes> grantwu: consider sending a note to the libraries mailing list
11:51:28 <zort> why is the interface to use generics "data Foo = ... deriving (Generic) ; instance Foo Fooable" instead of the simpler (to me) "data Foo = ... deriving (Fooable)"?
11:51:33 <ertes> intothem1untains: i disagree
11:51:42 <ReinH> `Node (f a): fmap f as` is a list of ITrees, not an ITree
11:52:12 <grantwu> ertes: Uh, got it
11:52:28 <ertes> zort: because Generic only provides the mechanism…  it's part of base/GHC…  Foo is someone's class that uses the mechanism
11:52:29 <intothem1untains> ertes: i should note i'm not talking about the documentation of the language itself, but of its most known third party libraries
11:52:33 <ReinH> You can tell that it is a list because you construct it with (:)
11:52:34 <soLucien> okay , but why should it be a single ITree ?
11:52:43 <ReinH> soLucien: what is the type of fmap?
11:52:46 <EvanR> python requires a lot more explanations
11:52:53 <intothem1untains> ertes: compare the docs for django/flask and the ones for any web framework in haskell
11:53:01 <soLucien> shit. yes
11:53:04 <EvanR> but haskell could use more tan zero probably
11:53:05 <ReinH> soLucien: Or, for that matter, what is the type of line 5?
11:53:11 <EvanR> oh .... web...
11:53:31 <ReinH> Yesod has an entire book.
11:53:33 <soLucien> it should be f b 
11:53:35 <intothem1untains> EvanR: only one of the possible examples
11:53:42 <intothem1untains> ReinH: books are not docs
11:53:42 <zort> ertes: I don't understand. isn't it just a syntax matter, transforming "deriving (Fooable)" to "deriving (Generic) ; instance Fooable Foo"?
11:53:48 <ReinH> intothem1untains: Of course they are.
11:54:04 <soLucien> so i have to transform this list into a single tree
11:54:04 <ertes> intothem1untains: yeah, i can agree there, but without comparing it to python:  haskell libraries are much easier to learn in general, because most of them have a good sense of locality, the abstractions are sharper, and names and types tell a lot without needing too much prose
11:54:04 <intothem1untains> ReinH: yes, which you most of the times have to buy
11:54:17 <ReinH> You can't just exclude "a large collection of explanations for a thing" for arbitrary reasons because it supports your point
11:54:20 <ReinH> And this one you do not.
11:54:27 <ReinH> Ok, it isn't a book
11:54:27 <intothem1untains> ertes: that is true, and that's why i'm learning haskell, because it is a pleassure
11:54:35 <ertes> intothem1untains: of course good prose is always easier, but i don't blame any open source programmer for not taking the time to do it, because i know from my own experience how difficult and time-consuming it is
11:54:37 <ReinH> it is freely available documentation that you can also consume in book form for free
11:55:11 <intothem1untains> ReinH: have you had a look to django's docs?
11:55:21 <ReinH> Have you looked at the Yesod book?
11:55:27 <ertes> zort: nope
11:55:38 <ReinH> Also I'll note that django's docs =/= python's docs
11:55:40 <intothem1untains> no, but i guess that's more comparable to books about django
11:55:49 <ertes> zort: i see no way for GHC to understand that one implies the other
11:55:59 <ertes> zort: it would have to read your mind
11:55:59 <intothem1untains> ReinH: yeah, i'm talking about docs for common libraries
11:56:10 <ReinH> intothem1untains: So why can't I be allowed to comment on things I'm ignorant of?
11:56:10 <ph88> python's docs are not good
11:56:13 <ReinH> (I have, in fact, read them)
11:56:28 <intothem1untains> ReinH: I'm not saying you can't
11:56:49 <zort> ertes: really? how else does "deriving (Fooable)" where Fooable is not Eq or Show or such make sense?
11:56:52 <ReinH> You're just looking for arbitrary reasons to exclude the Yesod book so you can continue to claim that Yesod doesn't have good documentation
11:56:55 <EvanR> stop not disagreeing
11:56:58 <ReinH> Which, the book aside, it *still* does.
11:57:03 <saurabhnanda> help with https://www.reddit.com/r/haskell/comments/54gic4/using_either_for_representing_errors_and_allowing/ please
11:57:09 <intothem1untains> ReinH: I'm not claiming it doesn't
11:57:18 <bitemyapp> I use Yesod in my day to day work and I'm not unhappy with it
11:57:18 <ReinH> So then what *is* your claim?
11:57:21 <saurabhnanda> need help designing a domain API which uses Either a lot -- https://www.reddit.com/r/haskell/comments/54gic4/using_either_for_representing_errors_and_allowing/
11:57:28 <bitemyapp> The Yesod book helps, but I don't think it gets people as comfortable as the Django book did.
11:57:32 <ph88> can anyone look at my parser problem??  https://paste.fedoraproject.org/435399/82682014/
11:57:41 * EvanR uses double negation elminiation on intothem1untains to comical effect
11:57:41 <bitemyapp> so I think I understand the dissatisfaction/discomfort with it, if they have indeed tried to use it.
11:58:07 <bitemyapp> I think the problem is that the Yesod book doesn't explain in as much detail or provide the same kind of examples as the Django book.
11:58:07 <intothem1untains> That the docs for haskell libraries are worse than the ones for python libraries - which, of course, isn't a formal study i went throguh
11:58:10 <ertes> zort: the difference is that it's not derived in any way…  there is actually a default definition that is applied, because you omitted member definitions
11:58:17 <bitemyapp> I've used Yesod and Django both professionally, so this isn't based on guessing.
11:58:32 <ReinH> EvanR: ah see I'm more of an intuitionist
11:58:33 <intothem1untains> EvanR: lol
11:58:38 <zort> hmm alright whatever
11:58:46 <bitemyapp> I'm not sure complaining on #haskell will get anything fixed _either_, but I think the objection points to a real problem.
11:58:55 <EvanR> ReinH: well.. right thats why its funny, using it in normal language usually doesnt work either
11:59:36 <bitemyapp> intothem1untains: I'll be straight with you. Haskell is really nice and very rewarding once you're comfortable, but until you are, learning to use the libraries and stuff is going to be a rough experience.
11:59:40 <soLucien> ReinH so i wrapped it all in a node, and it worked. now i'm having issues with the null case
11:59:52 <ph88> saurabhnanda, what do you mean they don't compose nicely ?
11:59:56 <bitemyapp> intothem1untains: you have to decide if you're willing to eat that upfront cost or not.
11:59:58 <soLucien>   fmap f (Node (a:as) ) = Node (f a : fmap f as)
12:00:00 <ReinH> soLucien: Well, [] isn't a ITree either.
12:00:02 <ph88> eh easily
12:00:04 <soLucien> yes
12:00:07 <ReinH> [] is once again a list
12:00:08 <soLucien> it should be a Leaf
12:00:10 <soLucien> conceptually
12:00:15 <intothem1untains> bitemyapp: believe me, i'm more in love with haskell than i ever was with python
12:00:25 <ReinH> You can't pattern match on [], and you can't give an []
12:00:27 <ReinH> since [] is not an ITree
12:00:48 <saurabhnanda> ph88: how do you compose a function that returns (Either a x) and another that return (Either b x) 
12:01:06 <ReinH> saurabhnanda: what are the types of the functions?
12:01:07 <soLucien> i  think that conceptually the end of a ITree is a  Leaf (Int -> a)
12:01:09 <ertes> intothem1untains: one thing i have noticed (with personally i don't mind at all!) is that library authors tend to prefer writing nothing over repeating what the name and type already say, so when you read the haddocks of a library, you may find a lot of undocumented things
12:01:15 <intothem1untains> but i still appreciate the good quality of docs around python and how easily readable it is
12:01:32 <ReinH> soLucien: [] isn't an ITree, so your line 7 doesn't make sense
12:01:38 <ReinH> you've already handled the Leaf case
12:01:42 <intothem1untains> ertes: but there is so much more to tell than just what the name and types are
12:01:44 <ph88> saurabhnanda,  ??
12:01:48 <saurabhnanda> ReinH: createTenant :: NewTenant -> AppM (Either TenantCreationError Tenant) AND activateTenant :: TenantId -> AppM (Either TenantActivationError Tenant)
12:02:06 <saurabhnanda> ReinH: context -- https://www.reddit.com/r/haskell/comments/54gic4/using_either_for_representing_errors_and_allowing/
12:02:11 <saurabhnanda> ph88: easily, how?
12:02:24 <ReinH> saurabhnanda: by bind and pattern matching, probably.
12:02:27 <EvanR> intothem1untains: in some cases... like on te ridiculously overcomplicated web
12:02:36 <ertes> intothem1untains: personally i prefer substantial documentation over writing "This action gets X." for an action named "getX"…  and if the author has nothing substantial to say, they can save both theirs and their readers' time by not writing anything at all
12:02:37 <soLucien> ok .. what should happen when the Node list is empty ?
12:02:44 <soLucien> i will pattern match it to   fmap f Node [] = 
12:02:48 <ph88> saurabhnanda, you say they don't compose easily, but what do you mean by that ?
12:02:51 <ReinH> soLucien: No you won't
12:02:58 <ReinH> fmap f Node [] is (fmap f Node) []
12:03:06 <ertes> intothem1untains: i know the "welcome!" effect of prose, but writing prose for the sake of writing prose is in a sense dishonest
12:03:17 <soLucien>   fmap f ( Node []) ?
12:03:20 <ReinH> soLucien: Yes.
12:03:28 <saurabhnanda> ReinH: ph88: let me update the Reddit post with sample code
12:03:52 <soLucien> okay .. and what should it be ? ..
12:03:59 <ReinH> soLucien: What can it be?
12:04:00 <soLucien> call f on an empty node
12:04:15 <ReinH> @src map
12:04:15 <lambdabot> map _ []     = []
12:04:15 <lambdabot> map f (x:xs) = f x : map f xs
12:04:16 <soLucien> a default Leaf ?
12:04:22 <soLucien> i don't know .. an empty node ?
12:04:24 <ReinH> soLucien: Why would it be a default leaf?
12:04:28 <ph88> ReinH, could you take a look at my parser problem perhaps ?
12:04:38 <ReinH> How do you construct an empty Node?
12:05:03 <ReinH> ph88: link?
12:05:10 <ph88> ReinH, https://paste.fedoraproject.org/435399/82682014/
12:05:13 <intothem1untains> ertes: it's not a welcome effect i miss, it is the facilities for grasping new concepts
12:05:22 <soLucien> i don't know .. an empty node ?
12:05:25 <soLucien> sorry
12:05:30 <buglebudabey> could someone help me figure this error out? "IOException of type IllegalOperation (people.csv: hGetContents: illegal operation (delayed read on closed handle))"
12:05:46 <soLucien> Node [] ?
12:06:02 <soLucien> so call f on an empty node
12:06:07 <saurabhnanda> ph88: ReinH: added code snippet to https://www.reddit.com/r/haskell/comments/54gic4/using_either_for_representing_errors_and_allowing/
12:06:14 <ReinH> ph88: You haven't included all the relevant code.
12:06:18 <saurabhnanda> here's the problem -- createAndActivateTenant :: NewTenant -> AppM (Either TenantCreationError (Either TenantActivationError Tenant)) 
12:06:24 <ph88> ReinH, what are you missing ?
12:06:51 <intothem1untains> on an unrelated note: i'm defining functors for types that already have it as an exercise, how can i solve duplication?
12:07:01 <ReinH> ph88: extendedIdentifier references identifiers that are not in scope
12:07:11 <ReinH> like terS
12:07:13 <ertes> intothem1untains: sure, but then for the most important libraries that kind of documentation is there, and if not, you're always welcome to contribute =)
12:07:33 <ReinH> soLucien: Yes, Node []. How do you call f on an empty node?
12:07:34 <intothem1untains> i hope i eventually will
12:07:38 <ReinH> How does map call f on an empty list?
12:07:41 <ReinH> @src map
12:07:41 <lambdabot> map _ []     = []
12:07:41 <lambdabot> map f (x:xs) = f x : map f xs
12:07:55 <ertes> intothem1untains: you can't…  write a new type
12:08:13 <intothem1untains> ertes: ohkay!
12:08:14 <soLucien>   fmap f (Node [] ) = Node (f (Node []))
12:08:21 <soLucien> does not compile
12:08:22 <ertes> intothem1untains: or literally a "newtype", then with -XGeneralizedNewtypeDeriving you can just copy all instances except the one you're challenged to implement
12:08:22 <ph88> ReinH, here is a new paste https://paste.fedoraproject.org/435484/47483046/
12:08:23 <saurabhnanda> ReinH: ph88: is my question making sense now?
12:08:39 <ReinH> soLucien: what is the type of f?
12:08:48 <ReinH> soLucien: and again, how does map apply f to the empty list?
12:09:01 <soLucien> function a -> b
12:09:22 <ReinH> soLucien: so you need to apply f to a's
12:09:26 <ReinH> where are the a's in Node []?
12:09:37 <ph88> saurabhnanda, i would put the errors in a list
12:09:45 <soLucien> nope .. it's an empty node
12:09:50 <EvanR> saurabhnanda: Either (Either TenantCreationError TenantActivationError) Tenant, obv ;)
12:09:55 <ReinH> soLucien: So how many times to you need to apply f if there are no a's?
12:10:16 <EvanR> (really, put all your apps errors in one sum type)
12:10:40 <ReinH> data TenantError = ...
12:10:43 <intothem1untains> ertes: would that work in the case of ((->) e) too?
12:10:52 <verement> buglebudabey: looks like you are getting bitten by lazy I/O
12:10:53 <ertes> intothem1untains: sure
12:10:55 <EvanR> when using libraries where you want to pass on some errors, you can map them to one of your errors
12:10:57 <ReinH> soLucien: how many times does map apply f to []?
12:11:05 <ReinH> or rather, to the a's in []
12:11:13 <EvanR> in general exceptions will make this a lot easier (if youre in IO)
12:11:33 <buglebudabey> verement any way i can make this strict?
12:11:47 <buglebudabey> verement or somehow get around this?
12:12:08 <soLucien> zero times
12:12:14 <soLucien> i mean it shouldn't 
12:12:17 <soLucien> this is my base case
12:12:20 <ertes> intothem1untains: (->) is just another type constructor, except for its awkward syntax caveat
12:12:21 <verement> buglebudabey: can you show the code?
12:12:29 <saurabhnanda> EvanR: ReinH: Isn't the loss of granularity really problematic?
12:12:31 <soLucien> when you have nothing left, don't apply f
12:12:34 <ReinH> soLucien: Ok, so fmap f (Node []) = ??? if you don't want to apply f to Node []?
12:12:35 <EvanR> buglebudabey: yes, dont use readFile or getContents
12:12:40 <ph88> saurabhnanda, i think you should use a monad that runs all of your either actions and when one fails that it stops executing the other action
12:12:46 <buglebudabey> EvanR what's the alternative?
12:12:49 <ReinH> saurabhnanda: what loss of granularity?
12:12:52 <soLucien> i tried Node[] but it still won't compile
12:12:59 <buglebudabey> EvanR i'm reading from a small sv file
12:12:59 <ph88> saurabhnanda, so instead of   createTenant newTenant >>=   try    createTenant >>= newTenant
12:13:02 <saurabhnanda> EvanR: ReinH: How does a call-site know which errors it really needs to handle? What about non-exhaustive checking ?
12:13:06 <ReinH> soLucien: show me the whole line that you tried
12:13:14 <soLucien>   fmap f (Node [] ) =  Node []
12:13:23 <buglebudabey> verement http://lpaste.net/215543
12:13:28 <EvanR> saurabhnanda: it sounds liek you want to put more information in the types, which is where dependent types come in
12:13:36 <ReinH> soLucien: and what was the error?
12:13:43 <EvanR> like Either E X, e and E is only one of this list of errors
12:13:58 <EvanR> ignore that lower case e, my e key is brokn
12:14:25 <soLucien> http://lpaste.net/2807813729930969088
12:14:33 <ReinH> EvanR: btw, https://en.wikipedia.org/wiki/Litotes
12:14:34 <EvanR> in any case, one E type is really going to save you a lot of work
12:14:39 <ertes> BTW, it's 2016…  can't we… fix this already?  where is -XArrowSections?  and why is -XTupleSections not standard?  it has to be the dumbest inconsistency of haskell and should have been fixed decades ago
12:15:00 <ReinH> soLucien: and what is line 23?
12:15:21 <soLucien>   fmap f (Leaf g) = Leaf (f . g)
12:15:23 <EvanR> ReinH: theres that, but "i dont dislike them" is not the same as "i like them"
12:15:25 <soLucien> okay it's the leaf ..
12:15:27 <soLucien> shit ..
12:15:33 <amalloy> soLucien: those errors are both pointing at   fmap f (Node (a:as) ) = Node (f a : fmap f as) 
12:15:50 <EvanR> thats not emphasizing how much i really really like them
12:15:55 <saurabhnanda> ReinH: EvanR: loss of granularity is the following... "someFunc :: a -> b -> Either E r" -- if E is an ADT with a laundry list of ALL domain errors, won't I be forced to implement non-exhaustive call-sites for `someFunc` all the time? Isn't that a bad thing?
12:15:55 <ertes> sorry, i needed that =)
12:16:32 <EvanR> saurabhnanda: error handling is kind of a acquired taste, do you really expect to be catching any of these errors?
12:16:48 <EvanR> if not, use exceptions
12:16:52 <saurabhnanda> EvanR: these are domain-specific validation errors. Strict validation errors from the DB layer.
12:17:32 <EvanR> exceptions
12:17:36 <saurabhnanda> EvanR: ReinH; So, basically one solution is a quick way to combine ADT value-types in an ad-hoc manner -- is that possible?
12:17:45 <ReinH> soLucien: Are you *sure* it's the Leaf line?
12:17:59 <ertes> saurabhnanda: note: you can have E = SomeException, and reuse the dynamic typing of it
12:18:02 <EvanR> saurabhnanda: yes, you can quickly do Either (Either A (Either B (Either C ( ...) Z
12:18:17 <soLucien> no ..
12:18:29 <EvanR> thats about as adhoc as you can get
12:18:31 <ph88> sometimes quickcheck fails sometimes it pass .. does that mean it's not checking enough cases ?
12:18:35 <EvanR> ertes: nice idea
12:19:05 <verement> buglebudabey: simplest might be to use readFile instead of withFile/hGetContents; that will probably solve your immediate problem though it may not be the best solution as it is still using lazy I/O
12:19:08 <saurabhnanda> ertes: how will that work? 
12:19:09 <ph88> saurabhnanda, if you put them in the same ADT then you can put them in a List
12:19:20 <soLucien> it's   fmap f (Node (a:as) ) = Node (f a : fmap f as)
12:19:25 <soLucien> that's the line
12:19:37 <ReinH> Yep.
12:19:39 <soLucien> okay , what is wrong with it now ? i am casting it to a node
12:19:39 <EvanR> ph88: it doesnt sound like hes looking for a list of errors
12:19:41 <saurabhnanda> EvanR: don't the nested types complicate the call sites? Is the following possible? Either (A+B+C) Z
12:19:53 <soLucien> so i iterate through all the nodes
12:19:57 <saurabhnanda> ph88: how will the List work at the type-level?
12:19:58 <soLucien> and run f on them
12:20:04 <exio4> saurabhnanda: you can implement your own instance of Exception
12:20:08 <ertes> saurabhnanda: ideally you'd just use the 'exceptions' library, which readily provides 'throwM' and 'catch' for Either SomeException
12:20:08 <ReinH> soLucien: What is the type of a? What is the type of f?
12:20:35 <ph88> saurabhnanda,  AllErrors = Error1 | Error2    and then you can have a list of [AllErrors]
12:20:40 <EvanR> saurabhnanda: this is also a good use case for extensible variant types, se the paper extensible records with scoped labels
12:20:59 <saurabhnanda> ertes: how different is that from unchecked exceptions? you're taking about MonadThrow and MonadCatch, right?
12:21:11 <ertes> saurabhnanda: SomeException and the whole dynamic exceptions machinery of haskell is actually orthogonal to IO
12:21:19 <EvanR> saurabhnanda: i wasnt seriously suggesting you put tons of Eithers in the type, thats just a dumb way to do a proper ADT
12:21:21 <ertes> saurabhnanda: you can't have unchecked exceptions with Either
12:21:41 <ertes> saurabhnanda: there is always the Either layer itself that remains to be unpacked at the end
12:21:43 <ph88> saurabhnanda, but actually i think instead of a list you can use a monad that just fails at the first error !
12:22:02 <EvanR> like Either! ;)
12:22:05 <ertes> saurabhnanda: and yeah, MonadThrow and MonadCatch
12:22:16 <soLucien>  a is ITree ?
12:22:17 <ph88> anyone here good with parsers ?
12:22:22 <soLucien> and f is a -> b
12:22:22 <saurabhnanda> ph88: say AllErrors = Error1 | Error2 | Error3 | Error4 -- how will you write a function signature that can result ONLY in Error2 | Error4?
12:22:26 <EvanR> using SomeException, you still dont really know  from looking at the types what errors might be thrown
12:22:41 <ReinH> soLucien: Let's avoid using the same thing to mean different things.
12:22:49 <EvanR> saurabhnanda: you cant
12:22:59 <ReinH> In fmap f (Node (t:ts) ) = Node (f t : fmap f ts), what is the type of a?
12:23:01 <ReinH> er, of t
12:23:01 <ertes> well, you can add that knowledge, because you can always go from a more specific exception type to SomeException
12:23:10 <saurabhnanda> EvanR: "you cant" for?
12:23:13 <ph88> saurabhnanda, i wonder if you really need that Error2 | Error4  ..  i don't know though ... maybe GADT's ?
12:23:25 <soLucien> t is a Node , ts is [Node]
12:23:34 <ReinH> Node is not a type.
12:23:39 <ertes> let (c :: Either (Either MyEx1 MyEx2) a), you just have to map this function over Left:  either toException toException
12:23:39 <EvanR> the connection is worthless so i cant continue for now
12:23:42 <ertes> :t toException
12:23:44 <soLucien> ITree
12:23:45 <lambdabot> Exception e => e -> SomeException
12:23:49 <ReinH> soLucien: ITree what?
12:23:55 <ReinH> ITree takes a type argument
12:24:03 <soLucien> t is a ITree (Node)
12:24:07 <ReinH> Node is not a type.
12:24:31 <ReinH> What is the type of fmap here?
12:24:32 <ReinH> :t fmap
12:24:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:24:35 <ReinH> what is f?
12:24:44 <saurabhnanda> ertes: can you help me with the approach you're suggesting? My ask -- the type signatures should document the errors that need to be handled by the call-site.
12:24:49 <soLucien> f is a function that you want to call on a ITree
12:25:06 <soLucien> then fmap has to recursively walk the tree and run it
12:25:09 <soLucien> return a new ITree
12:25:15 <ertes> saurabhnanda: make sure your individual error types have Exception instances
12:25:16 <soLucien> the modified one
12:25:26 <saurabhnanda> ertes: check
12:25:38 <saurabhnanda> ertes: what else?
12:25:48 <ReinH> soLucien: Sorry, what is f in the type of fmap?
12:25:50 <ReinH> :t fmap
12:25:51 <ertes> saurabhnanda: then you can use 'first' from Data.Bifunctor to map over Left
12:25:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:26:07 <soLucien> (a->b), it is a function 
12:26:09 <saurabhnanda> ertes: okay...
12:26:22 <ertes> saurabhnanda: let (c :: Either MyEx A), where MyEx is your exception type
12:26:23 <soLucien> a function from some type a to some type b
12:26:37 <ertes> saurabhnanda: before integrating it into a larger computation, you could choose to go to SomeException
12:26:51 <ertes> first toException :: Either MyEx a -> Either SomeException a
12:26:53 <soLucien> am i correct ?
12:26:59 <ReinH> soLucien: Ok, again we're getting confused by vocabulary, but this time it is my fault.
12:27:08 <ReinH> You are writing a Functor instance for ITree
12:27:15 <ReinH> :t fmap
12:27:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:27:33 <ReinH> If I am writing a Functor instance for [], then I am writing a function fmap :: (a -> b) -> [a] -> [b]
12:27:49 <ertes> saurabhnanda: so SomeException is your unified exception type when you need it (e.g. if you want to use Either's Monad instance), but in other places you can keep the error types separate
12:27:55 <soLucien> ye
12:27:55 <ReinH> if I am writing a Functor instance for ITree, I am writing a function fmap :: (a -> b) -> ITree a -> ITree b
12:28:12 <ertes> saurabhnanda: and you can also get back out of SomeException by using 'catch' or 'catchJust'
12:28:15 <soLucien> yes
12:28:24 <ReinH> which means that in fmap f x, f :: a -> b, x :: Itree a
12:28:38 <EvanR> ertes: i changed my mind this is terribly complex now
12:28:49 <EvanR> and doesnt gain you any documentation
12:29:06 <EvanR> in the cas of SomeException
12:29:09 <ph88> can anyone look at my parser problem??  https://paste.fedoraproject.org/435399/82682014/
12:29:09 <saurabhnanda> ertes: if createTenant can result in TenantCreationError and activateTenant can result in TenantActivationError, in this scheme of things, what would be the type of createAndActivateTenant?
12:29:10 <ertes> EvanR: then don't use the Monad instance, which requires a unified exception type =)
12:29:22 <soLucien> okay , the function f has to be called on a ITree
12:29:22 <Phyx-> "This is an archived post. You won't be able to vote or comment." hmm well that sucks, wonder why /r/Haskell archives posts
12:30:03 <EvanR> ertes: good point. i think saurabhnanda is not asking the right question, because you probably dont want to handle all possible errors any possible call site
12:30:03 <ertes> saurabhnanda: that's really your choice…  you can go to SomeException and lose documentation, or you can go to Either TenantActivationError TenantCreationError
12:30:13 <ReinH> soLucien: On an ITree a.
12:30:29 <soLucien> yes ..
12:30:30 <ReinH> soLucien: It's important to be as correct as possible when learning :)
12:30:41 <soLucien> and return the ITree b
12:30:54 <ReinH> Wait.
12:30:56 <ReinH> No. Sorry
12:30:58 <saurabhnanda> ertes: so another way to look at my question is, how to combine the left values of various Eithers in type-safe ad-hoc manner.
12:31:00 <ReinH> Remember: f :: a -> b
12:31:01 <grantwu> Can someone explain the purpose of a proxy type?
12:31:05 <ReinH> f takes an a
12:31:05 <Nameo> Hey
12:31:07 <ReinH> not an ITree a
12:31:19 <ReinH> fmap f takes an ITree a
12:31:21 <ertes> saurabhnanda: yeah, that sounds right
12:31:24 <ReinH> by doing something with f
12:31:33 <saurabhnanda> ertes: right, so is it possible?
12:31:41 <soLucien> yes , the ITree is the "computational context" that the documentation talks about , right ?
12:31:52 <soLucien> f is simply a function
12:31:53 <saurabhnanda> EvanR: how can I clarify my question? 
12:31:53 <Nameo> I got a problem trying to install hsdev on ubuntu 16.04, when I run cabal install hsdev I get "hsdev-0.2.0.0 failed during the building phase. The exception was: ExitFailure 1" unfortunately I seem to be the only one with that issue, have you any idea why?
12:32:01 <ertes> saurabhnanda: you need nicer ad-hoc sum types, and it's possible to some extent, but as far as i know nobody has done it
12:32:11 <EvanR> saurabhnanda: type safe, adhoc, use tons of Eithers
12:32:19 <ReinH> soLucien: Yes, our goal is to take f, which operates on a's and make fmap f, which operates on ITree a's
12:32:22 <EvanR> ertes: extensible variants
12:32:41 <saurabhnanda> EvanR: nested Eithers? will they be easy to use?
12:32:44 <grantwu> Specifically, I need to implement https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Prim.html#v:updatePos and I don't know what proxy is for
12:32:51 <ReinH> soLucien: In: fmap f (Node (t:ts) ) = Node (f t : fmap f ts)
12:32:53 <EvanR> saurabhnanda: your list of requirements sure is flexible! ;)
12:32:59 <ReinH> t is an ITree a, f :: a -> b
12:33:00 <ertes> i was thinking of combinatorial species, but we don't have them in haskell =)
12:33:02 <ReinH> you can't apply f to t
12:33:17 <grantwu> nvm, reading http://stackoverflow.com/questions/27044209/haskell-why-use-proxy
12:33:30 <EvanR> ertes: idris effects library also lets you change the type of exception in the course of the computation
12:33:32 <saurabhnanda> EvanR: ReinH: ertes: somehow, I thought this would be an obvious thing in Haskell. I'm writing my very first type-safe webapp and hitting this. This is surely not a corner case.
12:33:44 <ReinH> soLucien: However, let's look at this again:
12:34:06 <ReinH> soLucien: starting with, fmap f (Leaf g) = Leaf (f . g)
12:34:15 <EvanR> saurabhnanda: this is a standard issue with haskell, you want something more precise in the types than it cant really handle. haskell isnt the state of the art type system in the world "anymore"
12:34:18 <ertes> EvanR: you can get some of that by using indexed monads, but this smells a lot like overengineering
12:34:18 <saurabhnanda> EvanR: ReinH: ertes: I basically want to use Haskell exactly for its advertised purpose. Type-safe, but easy to use.
12:34:34 <ReinH> soLucien: Let's look at fmap f (Node ts)
12:34:38 <tsahyt> is anybody here involved with cabal development?
12:34:38 <EvanR> saurabhnanda: its easy if you accept some limitations of the types
12:34:40 <grantwu> I think Ocaml has extensible variant types?
12:34:48 <ReinH> without breaking it out into Node [] and Node (t:ts) cases
12:34:50 <grantwu> LiquidHaskell does refinement types
12:34:52 <ertes> saurabhnanda: i know it's not a satisfying answer, but usually we just live with not specifying exceptions in types
12:34:53 <saurabhnanda> ertes: this is supposed to be the core of a very large webapp. Doubt the over-engineering. 
12:34:54 <tsahyt> I was wondering if this pull request is being worked on by someone? https://github.com/haskell/cabal/pull/2540
12:35:00 * hackagebot zxcvbn-c 1.0.1 - Password strength estimation  https://hackage.haskell.org/package/zxcvbn-c-1.0.1 (JoeyHess)
12:35:02 * hackagebot atom-conduit 0.4.0.1 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.4.0.1 (koral)
12:35:04 * hackagebot simple-effects 0.3.0.1 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.3.0.1 (darwin226)
12:35:11 <EvanR> ertes: indeed monads are definitly ovet engineered
12:35:23 <lpaste> Nameo pasted “Installproblem” at http://lpaste.net/215649
12:35:29 <ReinH> soLucien: in Node ts, what is the type of ts? Remember, the constructor is Note [ITree a]
12:35:38 <EvanR> saurabhnanda: use a single type for the entire body of possible "app"xceptions
12:35:44 <saurabhnanda> ReinH: ertes: EvanR: are type-level sets the answer?
12:35:54 <ertes> saurabhnanda: the best you can get right now with a reasonable amount of engineering is to make a large sum-type of all possible errors you care to handle
12:36:13 <ReinH> soLucien: How about joining me in #haskell-overflow? It'll be easier to follow and we won't get in the way of the other conversations.
12:36:20 <maerwald> EvanR: are you an e-e advoate too?
12:36:20 <soLucien> i would say it's a list ?
12:36:22 <soLucien> great
12:36:23 <EvanR> saurabhnanda: i have been telling you... extensible variants
12:36:25 <ertes> saurabhnanda: the approach i personally go for is not to distinguish between meanings of errors, but the way i handle them…  in other words: don't catch certain errors, but catch certain severity classes
12:36:32 <saurabhnanda> EvanR: sorry, missed that.
12:36:34 <EvanR> maerwald: ee/
12:36:48 <maerwald> ee/?
12:37:03 <saurabhnanda> EvanR: this? https://hackage.haskell.org/package/extensible
12:37:14 <EvanR> i am about to throw this compute at the wall maerwald 
12:37:32 <maerwald> xD
12:37:33 <saurabhnanda> EvanR: no docs?
12:37:39 <EvanR> ethe fuck is e-e
12:37:50 <maerwald> EvanR: extensible-effects, freer etc
12:38:00 <EvanR> well, not really
12:38:31 <EvanR> but extensible records and extensible variants with scoped labels looks really awesome
12:38:55 <EvanR> saurabhnanda: type level set theory has been implicited in haskell, and its insane
12:39:09 <maerwald> the haskell community has sure made a good job of hitting every problem with the monad class :P
12:39:13 <EvanR> extensible variants, not sure but it would also probably be insane
12:39:13 <maerwald> and now people get sick
12:39:33 <ertes> i think saurabhnanda is talking about sets as a data structure more than a mathematical object =)
12:39:47 <EvanR> me too
12:39:55 <saurabhnanda> EvanR: where can I read more about extensible variants?
12:40:01 <EvanR> but to manage the sets you have to basically use set theory
12:40:27 <saurabhnanda> EvanR: ertes: basically type-level sets as a way to do (Either 'Error[Error1 Error3 Error5] Z)
12:41:41 <EvanR> saurabhnanda: http://research.microsoft.com/en-us/um/people/daan/download/papers/scopedlabels.pdf
12:42:08 <EvanR> this is better than sets
12:42:14 <ertes> saurabhnanda: there is a really simple (note: simple ≠ quick ≠ short) way to do an ad-hoc variant of "extensible variants" in haskell, but you have to do some engineering first:  write type classes along the lines of mtl's effect classes, except for errors
12:42:16 <saurabhnanda> damn, I hate it when my questions lead to a research PDF
12:42:36 <EvanR> you can pay me to implement a language with these ;)
12:42:42 <EvanR> then it wont be research anymore
12:42:45 <djsjadkhf> is the universe written in haskell?
12:43:04 <exio4> djsjadkhf: I believe it's a PHP-like language
12:43:15 <tsahyt> I hope it's written in a dependently typed language
12:43:23 <tsahyt> then again black holes are probably bottoms
12:43:28 <ggole_> Doesn't elm pretty much do that?
12:43:33 <EvanR> saurabhnanda: the practical answer is to not be that precise
12:44:24 <saurabhnanda> EvanR: how is that practical? Won't all call-sites end-up being partial/non-exhaustive if I use a single ADT for all domain errors?
12:44:27 <EvanR> black holes can be well typed
12:44:45 <EvanR> saurabhnanda: why do you think that? also no you probably arent catching all possible errors at all call sites
12:44:49 <grantwu> ggole_: It seems to have extensible records
12:44:59 <EvanR> thats the point of "exceptions" (Either)
12:45:08 <ertes> saurabhnanda: i honestly think that haskell is not the right language for that though…  if you look at all the languages with type-level exception declarations, you'll notice that they have this feature built-in…  in haskell you'd have to implement it yourself
12:45:40 <EvanR> ertes: syntax extensions lin the language would also help
12:45:41 <saurabhnanda> ertes: not the right language for what?
12:46:08 <ertes> saurabhnanda: pro point: you actually can…  contra point: it's a lot of work, and the way it integrates into your code is a bit awkward
12:46:30 <ertes> saurabhnanda: for actions with exception declarations
12:46:55 <EvanR> of all the things we covered , just using one type will be by far the least painful
12:47:00 <ertes> the most ugly part is: you have to scratch the standard Monad class
12:47:28 <EvanR> something like a validator though, you obviously want a specific error type and possibly throw the app wide error by translating
12:47:30 <ertes> which means you will have to deal with -XRebindableSyntax, if you want to keep your do-notation
12:47:51 <EvanR> rebindable syntax? thats it 
12:47:58 <EvanR> weve jumped the shark ;)
12:48:06 <harwiltz> Hello all. I'm trying to multiply a double by (2/Int) and return a double, but I keep getting compiler errors
12:48:12 <saurabhnanda> EvanR: is this the right thing to do? http://lpaste.net/215712
12:48:37 <harwiltz> I have (2.0/w) * x, I'm guessing a have to cast (2.0/w) to a double, but I can't figure out how
12:48:38 <ertes> harwiltz: what is "(2/Int)"?
12:48:40 <EvanR> i suggest using exceptions now ;)
12:48:47 <saurabhnanda> EvanR: http://lpaste.net/215712 is my problem with a unified ADT
12:48:48 <EvanR> it will simplify your code
12:48:50 <harwiltz> ertes: 2 divided by some integer
12:49:07 <EvanR> do you understand the usual workflow ith exceptions
12:49:07 <saurabhnanda> EvanR: exceptions will simplify?
12:49:20 <EvanR> they work by NOT handling them 
12:49:25 <ertes> harwiltz: (2.0 / w), where (w :: Integer), sounds like an error
12:49:40 <EvanR> then you write your code in a saner sequence
12:49:42 <harwiltz> ertes: I'll try 2.0/(fromIntegral w)
12:50:13 <EvanR> in terms of what you said, your fallback case would be "rethrow"
12:50:13 <ertes> harwiltz: yeah, in order to do floating point division (as opposed to integer division) you have to go to Double first
12:50:27 <harwiltz> ertes: Yup, that did it :)
12:50:55 <harwiltz> Lol I literally tried fromIntegral on just about everything else for some reason, I kept neglecting that one variable
12:51:00 <EvanR> saurabhnanda: do you get how the Either e monad works?
12:52:05 <saurabhnanda> EvanR: my problem with the catchall `_` case when handling ADTs is that it's easy to break when you add a new value to the ADT. the `_` catches all and you don't get a non-exhaustive warning. and you can miss out call-sites where you *should* be specifically handling new values.
12:53:19 <ertes> saurabhnanda: again, i really think you shouldn't engineer toward handling different errors
12:53:41 <EvanR> saurabhnanda: for very local stuff like validation, then you would have a more speificcific type. this isa good reason not waiting all the way until you put something in the database to do validation
12:53:54 <ertes> saurabhnanda: instead engineer toward error handling classes:  types or errors that may be different, but are always handled together
12:54:05 <EvanR> validation of a request shouldnt wait all the way until youre trying to pstuff it into a database to cause an app wide exception
12:54:11 <ertes> s/ or / of /
12:54:21 <EvanR> and thus force you to make your validation errors into app wide exceptions
12:54:36 <EvanR> i mean, use app wide exceptions for validation types
12:54:41 <saurabhnanda> EvanR: not always possible. Something like uniqueness checks need to go the the DB level.
12:55:02 <EvanR> thats not a validation error
12:55:13 <EvanR> thats a transation that needs to retry
12:55:43 <ertes> saurabhnanda: in one application i had this error type (except with extra error info attached to each constructor):  data Severity = Emergency | Fatal | Permanent | Transient
12:55:49 <EvanR> (even more workflow that we dont have in the types)
12:56:11 <ertes> the actual error type/message is meaningless in the context of error *handling*
12:56:17 <ertes> it usually just ends up in a log file
12:56:57 <EvanR> saurabhnanda: not only that, once you get to the level of app wide "error" handling,, which probably shows an error to the user, might as well use exceptions (in IO)
12:57:22 <Wizek_> Let's suppose I have `a :: IO Int` and it is computationally expensive to get at Int, but I want to use this value in more than one place within my application. Is there a way to make sure that the IO action only computes at most once? The only way I can think of is to bind it in main (`a' <- a`) then manually pass the derived value around and down to function calls. But this can be tricky/ugly if I want to use it "deeper" than just 
12:57:22 <Wizek_> a few calls. Or I could use a reader/ST monad, which also requires changes to not only where I want to use it but all functions in-between on the stack. Is there any other way?
12:58:01 <EvanR> uh, you dont care when or where it gets initially excuted?
12:58:05 <EvanR> but its intensive?
12:58:35 <ertes> Wizek_: i'd go with passing around the value
12:58:41 <EvanR> ^
12:58:43 <saurabhnanda> aargh... if I had to be pragmatic, why would I be using a strongly typed, lazy, and pure language. I want to be correct AND fast.
12:59:18 <Nameo> Don't you have any idea for my installation problem ? :(
12:59:32 <Nameo> (http://lpaste.net/215649)
13:00:11 <grantwu> saurabhnanda: You can try OCaml, it has polymorphic variants
13:00:11 <EvanR> haskell has a huge pragmatic component to it
13:00:43 <Wizek_> EvanR, Well, not _that_ intensive. 
13:01:17 <EvanR> does your IO Int actually do any I/O ?
13:01:30 <Wizek_> EvanR, yes
13:01:47 <EvanR> then execute it somewhere during initialization and pass the result around 
13:02:05 <grantwu> saurabhnanda: You do understand that you can also use testing
13:02:17 <EvanR> possibly in a Reader
13:02:22 <ertes> saurabhnanda: you're trying to engineer something that is difficult to engineer in haskell…  believe it or not, problems like that exist…  however, we have shown you multiple ways to solve it, if you were to go down that route, and we also told you that the route is questionable…  now it's up to you to decide
13:02:26 <EvanR> which wont help that much
13:02:31 <exio4> Wizek_: well, you could always use unsafePerformIO for a global (Maybe ReturnType) variable, and then write a wrapper over the IO call
13:02:45 <EvanR> noooo
13:02:49 <Wizek_> nooooooo
13:02:50 <Wizek_> :D
13:03:04 <EvanR> (unles it doesnt really do any IO)
13:03:06 <Wizek_> exio4, That was my 3rd idea, but I dared not mention it.
13:03:40 <ertes> Wizek_: pass the value around…  you usually only need it at the top-level anyway…  in deeper 'where'-levels you can just refer to the value the top-level function received
13:03:41 <EvanR> if it happened to use IO for something like variables to do an algorithm in place, you could make a promise object that used unsafePerformIO when the value needs to be first generated
13:04:25 <EvanR> but randomly accessing files during a progrma at who knows where is bound to explode in your face
13:04:45 <saurabhnanda> ertes: I understand. All I'm saying is that I'm surprised that this hasn't been done yet. It seems like a very obvious corollary to me if you try to design systems using Haskell's stated values & principles.
13:05:03 <saurabhnanda> ertes: Hasn't been done, or isn't trivial to implement.
13:05:22 <EvanR> it sounds like you dont understand the issue very well if you think this is trivial to implement
13:05:52 <EvanR> for a "large" complex web application that has a database
13:06:26 <ertes> saurabhnanda: it's not that surprising, if you think about it:  typically there is not much of a need to be aware of all the different ways a program can go wrong, but there are clusters of error types which i'd call "severity classes", and you really only need to tell between those clusters
13:06:39 <ertes> saurabhnanda: if you do that, suddenly error handling looks really simple
13:06:42 <EvanR> the take away is that haskell doesnt let you be as precise as is sometimes possible for all problems
13:06:55 <exio4> saurabhnanda: what is the issue? I wasn't checking
13:07:34 <saurabhnanda> EvanR: understand at Haskell/type level, or generally "dealing with errors/validations" level?
13:08:07 <EvanR> right, "errors/validations" this is not really a good way to think about the problem space
13:08:27 <EvanR> if we dont understand the problem we cant hope to get a good solution
13:08:53 <EvanR> validation is a thing you do at the very beginning when you get input
13:09:02 <EvanR> not at the end when you try to put it in a database
13:09:07 <grantwu> saurabhnanda: Perhaps http://guppy.eng.kagawa-u.ac.jp/~kagawa/PVH/ might be useful?
13:09:12 <saurabhnanda> exio4: complete context -- https://www.reddit.com/r/haskell/comments/54gic4/using_either_for_representing_errors_and_allowing/
13:09:48 <EvanR> validation has nice solutions in haskell, like using Applicative
13:10:06 <saurabhnanda> EvanR: does that really make a difference here? I want the users of my core domain library to be aware of errors that the API may throw and that they need to handle.
13:10:28 <saurabhnanda> EvanR: validations=digestive-functors -- learnt that the hard way
13:10:30 <ertes> and what happens on validation error?  you abort and/or log and (e.g. in web apps) resend the form with error messages on each form field that had a validation error
13:10:35 <EvanR> thats a localized problem and doesnt require solving your bigger concern
13:11:16 <ertes> do you really care whether in field "abc" an integer failed to parse as opposed to an e-mail address?  the only difference is in the message you show to the user, not the way you handle the error
13:11:17 <EvanR> saurabhnanda: right, in almost all libraries, this is done with documentation, what exceptions might be thrown
13:11:26 <exio4> saurabhnanda: can'
13:11:36 <exio4> saurabhnanda: can't you go with an existential type there?
13:12:21 <exio4> saurabhnanda: basically reimplementing the Exception hackery with Typeable
13:12:30 <EvanR> saurabhnanda: im agreeing with you that haskell just really cant do what you want 100%
13:12:35 <saurabhnanda> exio4: how would that work?
13:12:50 <exio4> one sec, I'll check if it makes sense in code first :P
13:12:56 <ertes> saurabhnanda: exio4 is saying: "just reinvent SomeException"
13:13:05 <saurabhnanda> EvanR: but you're also saying that it's not a valid use case that needs implementing in the first place. Which is what I'm trying to disagree with.
13:13:05 <EvanR> exio4: one of the (many) requirements of saurabhnanda is that the exceptions are all evident in the types of all things
13:13:40 <EvanR> saurabhnanda: no im not, 
13:13:43 <polyaletheia> Hi does anyone know the latest ETA for GHC 8.0.2?
13:13:58 <EvanR> i know several ways to deal with your concern in just not haskell
13:14:14 <EvanR> which doesnt satisfy yet another requiremnt, that it be haskell
13:14:17 <Lokathor> polyaletheia, https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.2
13:14:24 <saurabhnanda> EvanR: which language would have infra already available for this?
13:14:34 <EvanR> infra?
13:14:42 <polyaletheia> Yeah that has "Very tentative: Release candidate by late-August 2016."
13:15:10 <grantwu> saurabhnanda: https://realworldocaml.org/v1/en/html/variants.html
13:15:17 <Phyx-> Lokathor: afaik, it's currently held up on that Mac OS issue
13:15:35 <Phyx-> Lokathor: #12479
13:15:36 <ertes> saurabhnanda: any dependently typed language basically allows you to invent any (decidable) programming pattern in the type system, so languages like idris
13:15:50 <Lokathor> polyaletheia, oh i'm sorry i forgot what month it alraedy was i'm dumb
13:16:09 <EvanR> i just dont know what infra refers to
13:16:19 <grantwu> infra probably means "type system features"
13:16:31 <Phyx-> whoops, means polyaletheia 
13:16:31 <ertes> EvanR: my inner tab completion turned it into "infrastructure" =)
13:16:33 <saurabhnanda> EvanR: infra = ad-hoc, type-safe way to combine ADTs
13:16:52 <polyaletheia> Phyx-: thanks, that gives me an idea of the hold-up
13:17:11 <EvanR> if so, you could make fancy syntax for combining multuiple extensible variants in idris
13:17:16 <EvanR> i see ocaml has it too
13:17:36 <grantwu> OCaml is also not lazy and tends towards less purity, so...
13:17:39 <ertes> BTW, lens can probably do this in some way, too
13:17:48 <EvanR> saurabhnanda: is this word  something you made up?
13:17:51 <ertes> it probably has "prism classes" of some sort
13:17:59 <saurabhnanda> EvanR: which word?
13:18:09 <EvanR> alright well
13:18:50 <saurabhnanda> EvanR: infra = infrastructure
13:19:09 <Phyx-> polyaletheia: I'm not sure it'll stop the RC from going out, but it's one of those things that they would want to fix. But the proposed fixes would require changes to both Cabal and GHC. so not sure what will happen here. 
13:19:59 <ertes> indeed, there is makeClassyPrisms
13:21:01 <Tuplanolla> I looked at some old versions of GHC and it appears some extensions like ScopedTypeVariables have existed since the dawn of time.
13:21:48 <Tuplanolla> Is there a historical summary of all the extensions? For example this is both narrow and somewhat inaccurate: https://damianfral.github.io/ghcaniuse/
13:25:11 <Tuplanolla> The -X flags weren't introduced until GHC 6.8. Before that there were -f flags. Even further back in time only -fglasgow-exts existed.
13:32:07 <saurabhnanda> EvanR: ertes: ReinH: possible solution -- https://int-index.github.io/ether/
13:34:41 <grantwu> i,i Template Haskell, the solution to and source of all problems
13:35:01 * hackagebot GPipe 2.1.8 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1.8 (TobiasBexelius)
13:40:44 <intothem1untains> Is there no better way? https://paste.debian.net/840931/
13:40:59 <EvanR> any sufficiently advanced TH program is indistinguishable from magic
13:41:26 <EvanR> but its certainly a practical option for many things
13:42:00 <garammasala> Hi
13:42:04 <intothem1untains> Than getting "is" into a Node, applying fmap and getting it back out?
13:42:15 <juri_> http://lpaste.net/215955
13:42:27 <juri_> can someone give me a bit more of a clue about this warning?
13:42:59 <juri_> it's in my openscad parser.
13:43:20 <juri_> and i've never quite seen that form of the warning.
13:43:34 <Tuplanolla> You don't need to destroy the list, intothem1untains.
13:43:36 <juri_> i mean, OK, i get it, i've got patterns that are not matched.
13:43:46 <juri_> but.. what do those paterns look like?
13:44:12 <Hijiri_> intothem1untains: [] has its own instance of Functor that you can use
13:44:23 <Tuplanolla> There's also DeriveFunctor, intothem1untains.
13:44:49 <Hijiri_> so [] has fmap, also plain map
13:45:15 <intothem1untains> Tuplanolla, Hijiri_: but there we have to rely on the implementation of Functor for [] right? It could be that fmap for [] only maps the first element
13:45:24 <intothem1untains> (I know it isn't the case)
13:45:43 <intothem1untains> Tuplanolla: I'm doing it as an exercise (typeclassopedia)
13:45:47 <Hijiri_> that would break the laws I think
13:45:48 <Tuplanolla> The functor laws guarantee it doesn't do anything silly, intothem1untains.
13:45:55 <Hijiri_> and the type
13:46:07 <intothem1untains> I should read those laws :p thanks!
13:46:11 <Hijiri_> how could you map only the first element if it goes to another type
13:46:22 <intothem1untains> true
13:46:27 <intothem1untains> didn't think about that
13:46:34 <intothem1untains> thank you!
13:46:52 <Tuplanolla> Specifically map f x : map f xs == map f (x : xs) always.
13:46:57 <hpc> heh yeah, it actually wouldn't break the laws if you got to ignore the type system
13:47:12 <hpc> you'd still have fmap id = id, and fmap f . fmap g = fmap (f . g)
13:51:07 <intothem1untains> But how can I make sure that "g i" :: ITree b?
13:51:16 <intothem1untains> I have to "fmap g i" right?
13:51:53 <intothem1untains> And to concatenate that with the "is", I would have to "fmap (Node . g) is"?
13:52:55 <intothem1untains> No, sorry, that makes no sense
13:56:56 <intothem1untains> Going back to the solution I posted, if I didn't do "fmap g (Node is)" and simply did "fmap g is", that wouldn't be :: [ITree b], just :: [b]
13:57:35 <Hijiri_> it wouldn't be [b] either, since g :: a -> b, not g :: ITree a -> b
13:58:02 <Tuplanolla> Hint: apply the theorem I mentioned to your first solution, intothem1untains.
14:01:36 <intothem1untains> Tuplanolla: So "fmap g (Node (i:is)) = Node (fmap g i : fmap g is)"?
14:02:12 <Tuplanolla> You just inlined the definition, so you can apply the theorem now, intothem1untains.
14:02:24 <Hijiri_> that's still a type error, is a list of ITree a, not a
14:02:30 <Hijiri_> is is a*
14:02:55 <intothem1untains> Hijiri_: yes
14:03:32 <intothem1untains> That's why I don't get how it could be done in any other way
14:04:02 <soLucien> so Functor and Applicative are typeclasses
14:04:09 <soLucien> so :t Applicative for example
14:04:12 <soLucien> gives me nothing
14:04:19 <soLucien> how can i see the type of it ?
14:04:21 <Hijiri_> actually map f x : map f xs is also a type error
14:04:23 <Tuplanolla> Use :i instead, soLucien.
14:04:38 <soLucien> :i applicative shows instances declared
14:05:02 <soLucien> ok it prints the code
14:05:05 <soLucien> i see , thanks
14:05:14 <Hijiri_> it should be f x : map f xs == map f (x : xs)
14:05:50 <Hijiri_> intothem1untains: are you having trouble figuring out what you should be mapping over the list?
14:05:57 <Tuplanolla> Oh, I wrote that wrong indeed. Just listen to Hijiri_, intothem1untains.
14:06:13 <intothem1untains> With "fmap g (Node is) = Node (fmap g is)", the problem is that "fmap g is" isn't :: ITree b, but :: [b]
14:06:15 <sofianito> Hi there. I'm new to haskell and I'm looking for best resources to learn effectively the language. I recently bought the Maybe Haskell book from Pat Brisbin but I'm having hard time to understand it
14:06:19 <intothem1untains> No, wait, just b
14:06:27 <Hijiri_> fmap g is isn't [b] or anything, it's a type error
14:06:40 <Hijiri_> g :: a -> b but is is [ITree a]
14:06:50 <Hijiri_> so you can't map g over is
14:06:52 <intothem1untains> Oh, true
14:07:05 <intothem1untains> Oh
14:07:06 <Hijiri_> Right now you have g :: a -> b and is :: [ITree a]
14:07:17 <Hijiri_> did you figure it out?
14:07:23 <intothem1untains> Can I fmap an fmap?
14:07:25 <Hijiri_> yep
14:07:41 <intothem1untains> Now let me figure out how :s
14:08:00 <intothem1untains> God this is brain draining
14:08:07 <cynode> sofianito, I'm in the same boat as you. I'm working through the Real World Haskell book right now, which has really helped me.
14:08:56 <intothem1untains> fmap g (Node is) = Node (fmap (fmap g) is)
14:08:58 <sofianito> cynode: Shall I start directly from Real World Haskell book?
14:09:15 <intothem1untains> Tuplanolla, Hijiri_: thank you for your patience!
14:09:56 <intothem1untains> typeclassopedia is a very very good exercise
14:10:06 <Tuplanolla> You could also (fmap . fmap) g is, intothem1untains. It's equivalent.
14:10:09 <sofianito> cynode: I bought the Maybe Haskell thinking I would understand functors, applicative, monads,... but for me reading the book is quite though :/
14:10:47 <Tuplanolla> Add another (fmap .) to go one level deeper again, intothem1untains.
14:10:49 <sofianito> cynode: and the book is supposed to be for begineers ...
14:10:56 <intothem1untains> Tuplanolla: I see
14:11:43 <cynode> sofianito, I started with Real World Haskell (Still am.) Of course, I'm rather new as well so not well versed on all the resources available. It's very "Real World" though, and I haven't found it too difficult.
14:13:10 <sofianito> cynode: Thanks I'll give it a try
14:13:59 <Rembane> Good morning, is there a way to get the URL I was redirected to with wreq?
14:14:56 <AleXoundOS> interesting question
14:15:31 <Tuplanolla> Related note: I constantly fall into the trap of thinking fmap . fmap == join (.) fmap even though I should know better by now.
14:15:49 <implementation_> sofianito: I'd also recommend you the "elephant book", aka "Learn You A Haskell For Great Good"
14:17:15 <sofianito> implementation_: I heard about it but I read somewhere bad critics about it
14:17:59 <Rembane> sofianito: It has pretty pictures, quite nice explanations and it's free, but it completely lacks exercises. http://learnyouahaskell.com/
14:18:03 <Tuplanolla> It feels more like a Haskell tour than a Haskell textbook, but that doesn't make it bad.
14:18:08 <soLucien> is ($) a pattern matcher for a function ?
14:18:28 <lyxia> Rembane: I'm not sure about it but you could take a look at the Content-Location header
14:18:37 <lispy> soLucien: ($) is just an operator for function application.
14:18:39 <soLucien> here 
14:18:41 <soLucien>   (ZipList gs) <*> (ZipList xs) = ZipList (zipWith ($) gs xs)
14:18:46 <soLucien> :t zipWith
14:18:48 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
14:18:49 <sofianito> implementation_: There is another one I found. Haskell Programming book, it's a 1000 page book
14:19:03 <soLucien> so it takes a function and 2 lists and returns a third
14:19:04 <lispy> it's even defined like this: f $ x = f x
14:19:32 <soLucien> so the ($) is a pattern matcher for the function (a->b->c) ?
14:19:42 <lispy> it's not a pattern
14:20:07 <soLucien> zipWith someFunction list1 list2
14:20:07 <lispy> :t ($)
14:20:09 <lambdabot> (a -> b) -> a -> b
14:20:14 <Tuplanolla> It's a visible version of the space between f and x in f x, soLucien.
14:20:17 <Rembane> lyxia: I tried it now and my server isn't sending that header. But it could've worked! Thank you. :)
14:21:18 <implementation_> @src ($)
14:21:18 <lambdabot> f $ x = f x
14:21:40 <soLucien> i understand that .. but how can zipWith list1 list2 work
14:21:49 <soLucien> if the function is not given ?
14:22:12 <lispy> in the expression, zipWith ($) gs xs, ($) is the function
14:22:35 <soLucien> what function .. ?
14:22:49 <lispy> it's the function that applies a function to a value
14:22:56 <lispy> ($) f x = f x
14:22:57 <EvanR>  :t the
14:23:37 <lispy> :t \gs xs -> zipWith ($) gs xs
14:23:40 <lambdabot> [a -> c] -> [a] -> [c]
14:25:50 <ReinH> applicatives!
14:25:52 <geekosaur> soLucien, wrapping an operator in parentheses turns it into a function
14:26:03 <geekosaur> which you can pass to other functions
14:26:14 <ReinH> they apply things!
14:26:23 <ReinH> ($) is apply!
14:26:39 <ReinH> let apply f x = f x in zipWith apply fs xs
14:28:35 <soLucien> isn't <*> also apply ?
14:28:49 <ReinH> <*> is a form of application
14:28:52 <soLucien>   (ZipList gs) <*> (ZipList xs) = ZipList (zipWith ($) gs xs)
14:28:54 <soLucien> i am saying
14:29:00 <ReinH> that's why it's called Applicative
14:29:20 <ReinH> @google mcbride applicative programming with effects
14:29:32 <ReinH> :(
14:29:35 <lambdabot> Plugin `search' failed with: <<timeout>>
14:29:40 <ReinH> http://strictlypositive.org/Idiom.pdf
14:30:08 <ilyanok> haven't used parsec for some time... is it now necessary to put typing annotations to parsers?
14:30:33 <soLucien> ReinH you recommend i read the 12-page PDF?
14:30:44 <ReinH> Absolutely.
14:30:58 <ReinH> Well, if and only if you want a better understanding of Applicative
14:31:08 <soLucien> before carrying on with the typeclassopedia
14:31:11 <ilyanok> it seems like even simplest things like "myalnum = alphaNum" fail to infer the type
14:31:12 <soLucien> well my goal is to get monads
14:31:26 <soLucien> so in order to do that, i need to understand what an Applicative is
14:31:28 <ReinH> In that case, http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
14:31:36 <ReinH> Applicative can be made optional
14:31:36 <lispy> soLucien: I think that paper is a bit advanced for beginners. if I were you'd I'd come back to it later.
14:31:41 <soLucien> i got the intuition, but i need to make my own
14:31:58 <ilyanok> or am I missing some LANGUAGE pragma?
14:32:18 <ReinH> ilyanok: what error are you getting?
14:32:21 <geekosaur> ilyanok, normally it shouldn't be needed. are you using OverloadedStrings or something else that interferes with type inference?
14:32:22 <Tuplanolla> At least with Megaparsec the most general types require some extension, ilyanok.
14:32:34 <Tuplanolla> I forget which one it was though.
14:32:46 <ilyanok> Btw, type inference in REPL works like a charm
14:33:16 <ilyanok> ReinH: "No instance for Stream s0 m0 Char"
14:33:43 <soLucien> my teacher told us : whenever in doubt, use this code to create the Applicative instance Applicative SubsM where
14:33:43 <soLucien>   pure = return
14:33:43 <soLucien>   (<*>) = ap
14:33:58 <ReinH> If you have a Monad, you also have an Applicative in this way.
14:33:59 <soLucien> and this for the Functor
14:34:01 <soLucien> instance Functor SubsM where
14:34:02 <soLucien>   fmap f m = m >>= \a -> return (f a)
14:34:38 <ReinH> If you've defined a Monad instance, you can use it to implement Applicative and Functor
14:35:01 <ReinH> If you've defined Functor and Applicative instances, you can implement the Monad instance by also defining (>>=)
14:35:02 * hackagebot pandoc-citeproc 0.10.1.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.1.1 (JohnMacFarlane)
14:35:04 * hackagebot language-thrift 0.10.0.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.10.0.0 (abhinav)
14:35:04 <Tuplanolla> It's FlexibleContexts, ilyanok.
14:35:04 <soLucien> okay , i still don't understand what a Monad is, so i was trying to get it by getting Applicative first
14:35:20 <ReinH> A Monad is an Applicative that can also do (>>=)
14:35:20 <soLucien> but if monad is easier, i'll look at that
14:35:49 <soLucien> with the intuition that a Applicative is a Functor divided in 2 stages
14:35:49 <lispy> soLucien: they're very related. I wouldn't worry too much about which order you learn them because you'll want to learn both.
14:35:59 <soLucien> the lift operation (using pure)
14:36:04 <soLucien> and the apply
14:36:07 <ilyanok> Tuplanolla: yep, I added that, but still no luck
14:36:23 <soLucien> i haven't managed to create any Applicative yet, but i'll skip directly to Monads now
14:37:35 <ReinH> An Applicative is not "a Functgor divided in 2 stages"
14:37:44 <ReinH> An Applicative is "a Functor and also some other things that Functors can't do"
14:38:02 <Clint> bifurcatedfunctors
14:38:05 <ReinH> Likewise, a Monad is "an Applicative and also another thing that Applicatives can't do"
14:39:02 <Tuplanolla> You could specialize the stream by, say, importing Text.Parsec.String and making the stream type in the insolent parts concrete (of type Parser String), ilyanok.
14:39:12 <soLucien> well .. shit ..
14:39:12 <ilyanok> here is the code: http://lpaste.net/216191 and the error: http://lpaste.net/216195
14:41:07 <ReinH> soLucien: Functor gives fmap. Applicative gives pure and <*>
14:41:18 <ReinH> You can't implement pure or <*> via fmap
14:41:36 <ilyanok> Tuplanolla: importing Text.Parsec.String doesn't help... well, I can write the type by hand, restricting it to String or giving the generic constraint, both things work
14:41:40 <ReinH> If you could, we wouldn't need an extra class
14:42:00 <ilyanok> I just wonder why the generic type is not inferred
14:42:01 <soLucien> i see .. is there any intuition behind it ?
14:42:04 <geekosaur> ilyanok, normally you'd have something more than that and it can then infer things, or you would specify which token type by importing the appropriate module. something that small is indeed too polymorphic
14:42:10 <soLucien> typeclassopedia is not very helpful
14:42:38 <lyxia> ilyanok: you have been hit by the monomorphism restriction
14:42:49 <geekosaur> mm, right
14:43:15 <ilyanok> lyxia: thanks!
14:43:20 <lyxia> @where monomorphismrestriction
14:43:20 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
14:43:21 <ilyanok> that's it
14:44:15 <ReinH> soLucien: intuition comes from working through examples
14:45:15 <soLucien> i am trying to
14:45:48 <soLucien> http://pasteboard.co/7urhVlJGb.png
14:45:55 <soLucien> this is the first on
14:45:56 <soLucien> one
14:47:08 <fnurglewitz> <ReinH> You can't implement pure or <*> via fmap
14:47:13 <fnurglewitz> fmap Reader const :P
14:49:30 <djsjadkhf> James Paul Warburg (August 18, 1896 – June 3, 1969) was a German-born American banker. He was well known for being the financial adviser to Franklin D. Roosevelt. His father was banker Paul Warburg, member of the Warburg family and "father" of the Federal Reserve system.
14:49:32 <djsjadkhf> [..]
14:49:34 <djsjadkhf> He gained some notice in a February 17, 1950, appearance before the U.S. Senate Committee on Foreign Relations in which he said, "We shall have world government, whether or not we like it. The question is only whether world government will be achieved by consent or by conquest."[1]
14:49:36 <djsjadkhf> Paul Moritz Warburg (August 10, 1868 – January 24, 1932) was a Jewish German-born American banker, and an early advocate of the U.S. Federal Reserve System.
14:49:38 <Hijiri_> well, you can't make a general pure with just fmap
14:49:40 <Hijiri_> @where ops
14:49:40 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
14:50:01 --- mode: ChanServ set +o dcoutts
14:50:23 <fnurglewitz> Hijiri_: true, I cannot deny that 
14:50:32 <ContessaTP> djsjadkhf's away message looks interesting. It's (join #a,0)
14:50:56 <soLucien>   /join #a,0
14:50:58 <glguy> joining 0 means part all channels
14:50:58 <soLucien> :D
14:51:34 <fnurglewitz> really?
14:51:56 --- mode: ChanServ set -o dcoutts
14:53:21 <jle_> that's neat
14:53:57 <jle`> i don't know what i was expecting to happen
14:54:02 <ContessaTP> lol
14:54:16 <fnurglewitz> it doesn't work on xchat
14:54:23 <Tuplanolla> That sounds like good design.
14:54:29 <fnurglewitz> * 0 :No such channel
14:54:43 <Tuplanolla> It's like removing a special file to create a new one.
14:57:28 <Tuplanolla> Now, I wouldn't be surprised if some Unix variant had that feature...
14:58:05 <jle`> `touch 0` would remover every file in the folder?
15:03:46 <ertes> touch -- "-rf *"
15:04:14 <ReinH> Well actually
15:04:25 <ertes> this command may very well remove every file in the directory for some people…  just not directly =)
15:04:56 <ReinH> ertes: ha
15:05:04 <ReinH> Ah little Bobby Tables
15:05:23 <Tuplanolla> Now that's a properly lazy implementation, ertes.
15:14:01 <xocolatl> hi all.  I'm having trouble figuring out how to execute an arbitrary query with postgresql-simple. I'd like to build a simple repl type app.  any pointers?
15:19:19 <EvanR> xocolatl: try using the Read instance?
15:19:26 <EvanR> :t read
15:19:28 <lambdabot> Read a => String -> a
15:20:06 <EvanR> String -> Query
15:21:45 <xocolatl> hmm
15:21:52 <EvanR> hmm, also Query wraps a ByteString, so if you have the query text encoded as a ByteString just use Query
15:22:11 <glguy> Query is an instance of IsString, so use fromString
15:22:23 <EvanR> :t fromString
15:22:25 <lambdabot> IsString a => String -> a
15:22:30 <EvanR> oh duh
15:22:45 <xocolatl> I'll need a little bit more help, please.  you seem to be telling me how to execute a query, whereas I need to get the results without defining a type
15:23:16 <EvanR> oh... well that was exactly your question
15:23:39 <xocolatl> sorry, poorly phrased
15:23:45 <EvanR> you can convert the results to a list of list of strings
15:23:46 <xocolatl> although the two go hand in hand
15:24:06 <EvanR> which normally would be horrible, but you want to display the results so
15:24:08 <xocolatl> I don't seem to be able to do that
15:24:56 <glguy> Looks like you'll use the instance FromField a => FromRow [a] where
15:25:28 <intothem1untains> What should happen when an applicative f (a -> b) is, let's say, Nothing?
15:26:02 <xocolatl> glguy: could you please give me a quick example, I'm terribly new to haskell
15:26:10 <EvanR> use forEach_ to loop through the results
15:26:24 <intothem1untains> nevermind :s
15:26:39 <glguy> But I don't see that there's a universal FromField instance
15:26:43 <EvanR> its parameterized by FromRow r, so whatever type r your loop requires, itll work as long as its a FromRow
15:27:58 <glguy> xocolatl: No, I don't have an example handy, but combined with (FromField a, FromField b) => FromField (Either a b), you should be able to create a result type for an arbitrary set of fields with an arbitrary type
15:28:24 <EvanR> use FromField String
15:29:01 <glguy> EvanR: That's only compatible with types: name, text, "char", bpchar, varchar
15:29:22 <EvanR> it would fail on other stuff? or are the docs just lying
15:29:38 <glguy> The docs say it's compatible with those types I listed
15:30:02 <xocolatl> my tests agree
15:30:06 <xocolatl> with glguy 
15:30:11 <EvanR> i suggested trying it in case thats how, like SQL does, converts anything whatsoever to string
15:30:28 <jake__> Is there a way to make a library such that static pointers that came from it would be consistent across any program that was linked with that library?
15:32:37 <jake__> Or is that just already how it works?
15:32:52 <xocolatl> glguy, EvanR: http://pastebin.com/Y8W6UneT
15:34:15 <glguy> xocolatl: you'll need to build something to handle all of your types with Either, or make a new universal field type with a FromField instance
15:34:17 <EvanR> http://lpaste.net/216418
15:34:38 <glguy> you're working against the intention of this library, so it's just a bit of extra trouble
15:35:43 <EvanR> a newtype like DumbAsHellStringRep would make sense for this application
15:35:48 <xocolatl> glguy: is there a better library for this?
15:35:49 <EvanR> but i see now way to create one
15:37:16 <EvanR> an instance for Dynamic would also work
15:37:30 <geekosaur> jake__, static libraries are relocated at link time, addresses will not match
15:38:25 <xocolatl> EvanR: I don't see a difference between your paste and mine
15:39:04 <EvanR> its the same text without 5 go pro ads making the screen delay resize
15:39:31 <geekosaur> nonportably there are ways to do this (on linux, you can make the .a a linker script that forces the real object file to link at a fixed address... but the link will fail if it can't do that. and you have to be careful about where you put it or you'll mess with memory allocation or with shared objects)
15:39:32 <jake__> geekosaur: Eh...so to use static pointers it has to be the same binary
15:39:46 <xocolatl> EvanR: ah, I use adblock
15:39:55 <geekosaur> can you expand "static pointers"?
15:40:17 <jake__> geekosaur: https://ocharles.org.uk/blog/guest-posts/2014-12-23-static-pointers.html
15:40:41 <geekosaur> pastebin gets pissy if you adblock it. including randomly refusing to load raw urls
15:41:03 <sgronblo> Can I use generics to derive ToJSON but specify an override for a field name?
15:41:11 <jake__> it's an extension to GHC that allows pointers (which I assume have to come from the same code) to send pointers (functions included) across networks
15:41:40 <jake__> it works across machines, and OS it says but I wasn't really sure if it still worked across builds
15:41:53 <xocolatl> so anyway, I guess haskell is not a good choice for my app :(
15:42:06 <sgronblo> I was trying to work around the fact that my todo list item has an SQL column called id, but I renamed it todoId in haskell because haskell was complaining about a clash for the id name.
15:42:10 <EvanR> xocolatl: try ByteString
15:42:18 <Cale> xocolatl: I just got here, what's your app?
15:42:26 <EvanR> bytea, name, text, "char", bpchar, varchar, unknown
15:42:43 <EvanR> "unknown" might be the key here
15:43:05 <geekosaur> oh, different story entirely, I was thinking static libraries and linker symbols
15:43:05 <xocolatl> Cale: trying to do a simple repl with postgresql-simple (basically copy the official "psql", if you know that)
15:43:27 <EvanR> Cale: convert aribtrary results to String
15:43:41 <EvanR> its arbitrary because the user types the query in
15:43:51 <EvanR> i suggest the ByteString FromField instance
15:44:02 <Cale> xocolatl: I think that seems doable...
15:44:17 <jake__> geekosaur: Oh! It looks like it serializes the name not the address! It then uses a lookup table to find the address!
15:44:22 <geekosaur> jake__, as I understand this, the pointers themselves are not static. the keys are, and you pass the keys around
15:44:25 <geekosaur> yes
15:44:34 <jake__> haha fantstic!
15:44:39 <jake__> *fantastic
15:44:53 <xocolatl> EvanR: No instance for (FromRow ByteString)
15:44:59 <EvanR> FromField
15:45:13 <EvanR> its FromRow [ByteString]
15:47:37 <xocolatl> I can't seem to wrap my head around this :(
15:48:25 <EvanR> try forEach_
15:48:38 <EvanR> and pass in a lambda that takes a [ByteString]
15:48:44 <EvanR> and does IO ()
15:49:34 <xocolatl> hoogle doesn't know about forEach_
15:49:58 <EvanR> well, have you looked at the docs for postgres-simple ?
15:50:24 <xocolatl> yes, but clearly I don't understand them well
15:50:29 <EvanR> https://hackage.haskell.org/package/postgresql-simple-0.5.2.1/docs/Database-PostgreSQL-Simple.html#v:forEach_
15:51:25 <EvanR> forEach_ :: FromRow r => Connection -> Query -> (r -> IO ()) -> IO ()
15:51:37 <EvanR> its a function with 3 argument, the 3rd one is a function
15:51:43 <EvanR> itll be called on each row of the result
15:51:46 <xocolatl> tbh, that link is *not* real documentation.  lack of documentation is the most frustrating thing about learning this otherwise awesome language
15:52:17 <EvanR> i just read the link, and it looks pretty good for documentation
15:52:26 <xocolatl> you already speak the language
15:52:31 <EvanR> i just directed you the final answer without suggeseting reading everything it referred to
15:52:44 <EvanR> such as forEach (no underscore)
15:52:48 <EvanR> and then fold
15:52:52 <glguy> xocolatl: the point of the database library documentation isn't too teach you haskell
15:53:01 <grantwu> Is that what passes for good documentation nowadays
15:53:01 <EvanR> i was going to say that next
15:53:11 <grantwu> Stuff you don't have to read from beginning to end
15:53:29 <EvanR> the top section of postgres-simple (and mysql-simple) explain exactly what the lib does and how it works
15:53:44 <EvanR> but doesnt teach you haskell
15:53:53 <xocolatl> nothing explains how to do what I want to do
15:53:57 <xocolatl> examples are terse
15:54:00 <grantwu> The problem is when people want to learn Haskell by building something
15:54:03 <xocolatl> when they exist
15:54:18 <grantwu> It's hard to build anything without using libraries
15:55:13 <EvanR> i agree this use case isnt exemplified in the docs, so youd have to go from "knowing nothing" to "understanding how to go from A to B on your own" through some sort of reading the docs process and thought
15:55:24 <EvanR> which is what i did, and here we are helping you
15:56:32 <xocolatl> I appreciate your help, but I've spent several hours on this before coming to ask for help and it's very frustrating :(
15:56:57 <grantwu> The average library imo is not usable for a haskell newcomer
15:57:10 <EvanR> i had a hard time with docs at first because a lot of information in contained the "instances" list, yet thats really not very much info other than the instance exists
15:57:28 <EvanR> lo and behold thats the key to this particular task
15:57:43 <grantwu> I still don't quite understand what a Proxy type is for
15:58:07 <EvanR> im so glad proxy types arent necessary in idris ;)
15:58:25 <jle`> grantwu: it's a hack to let you type in types as inputs to a function
15:58:52 <EvanR> xocolatl: did forEach_ work for you, if not, whats going wrong right now
15:59:00 <xocolatl> EvanR: not yet
15:59:35 <grantwu> jle`: Okay... do you know what the proxy is doing here? https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Prim.html#v:updatePos
15:59:41 <jle`> grantwu: for example, the 'typeRep' function lets you get a TypeRep for a given type that's an instance of Typeable
15:59:56 <jle`> but, how do you tell typeRep what type you want the TypeRep for?
16:00:04 <jle`> you pass it (Proxy :: Proxy TheTypeICareAbout) :)
16:00:22 <jle`> grantwu: in that case, updatePos needs to know what 's' you want to use
16:00:51 <jle`> grantwu: if it was just updatePos :: Pos -> SourcePos -> Token s -> (SourcePos, SourcePos), then how would updatePos know what the 's' you want was?
16:00:59 <grantwu> Can't it get that from Token
16:01:01 <jle`> you never give anything of type 's'
16:01:10 <jle`> grantwu: Token is a type family here, so it might not be injective
16:01:21 <grantwu> a.... what is a type family
16:01:22 <jle`> Token is an associated type for every 's' instance
16:01:24 <EvanR> xocolatl: maybe this http://lpaste.net/216529
16:01:33 <jle`> grantwu: so, say, for Text, the token for Text might be Char
16:01:43 <jle`> Token Text = Char, maybe
16:01:47 <EvanR> er
16:01:48 <jle`> Token String = Char too, maybe
16:01:58 <grantwu> if I put something like
16:02:01 <grantwu>   type Token AlexStream = Lex.Lexeme
16:02:04 <grantwu> in the instance declaration
16:02:08 <lpaste> glguy pasted “for grantwu” at http://lpaste.net/216534
16:02:11 <EvanR> xocolatl: http://lpaste.net/216529 i changed ByteString to [ByteString] there
16:02:18 <jle`> grantwu: yeah, that means that 'Token AlexTrem' is 'Lex.Lexeme'
16:02:31 <glguy> grantwu: Proxy is for linking type information around without having a value of that type
16:02:46 <jle`> so, if you use updatePos and give it a 'Char', it's not clear what instance of Stream you want 
16:02:50 <jle`> it's not clear what 's' is
16:02:59 <xocolatl> EvanR: Incompatible {errSQLType = "int4", errSQLTableOid = Nothing, errSQLField = "one", errHaskellType = "ByteString", errMessage = "types incompatible"}
16:03:03 <jle`> it could be Text, or it could be lazy Text, or it could even be String!
16:03:11 <EvanR> xocolatl: ... that sucks
16:03:17 <xocolatl> EvanR: indeed
16:03:57 <jle`> grantwu: if you had two instances of Stream that had Lex.Lexeme as their tokens, then just giving updatePos a Lex.Lexeme is not enough for it to know what 's' you are using it with
16:04:11 <jle`> you need to explicitly pass in the 's' that you want
16:04:18 <EvanR> xocolatl: in which case ask Cale because he seemed to think this was plausible
16:04:26 <grantwu> okay.  so if I'm writing the instance declaratoin
16:04:33 <grantwu> do I need to do anything with the Proxy...?
16:04:47 <glguy> grantwu: Only if you wanted to pass the proxy through to something else that uses proxies
16:05:02 <jle`> you don't, it's mostly for type inference's sake when you're *using* updatePos.  unless yeah, you want to pass it down to another function
16:05:29 <grantwu> Okay
16:05:35 <grantwu> So what the Proxy does is
16:05:40 <Cale> Yeah, FromField / FromRow you can think of as being a bit like "read" or "reads" -- they attempt to actually parse the result of querying
16:05:45 <xocolatl> Cale: what more should happen here? http://lpaste.net/216548
16:06:09 <lpaste> glguy annotated “for grantwu” with “for grantwu (annotation)” at http://lpaste.net/216534#a216552
16:06:14 <glguy> grantwu: see that one for example
16:06:15 <grantwu> if I had instance Foo Stream where type Token Foo = Lex.Lexeme and I also had instance Bar Stream where type Token Bar = Lex.Lexeme
16:06:43 <glguy> grantwu: That example has the proxy argument getting "used" for something
16:07:01 <grantwu> Then having the proxy allows type inference to succeed?
16:07:43 <jle`> grantwu: yeah, it makes it possible for haskell to know if you wanted to use the instance for Foo or Bar
16:07:53 <jle`> it's basically a way of "passing" Foo/Bar into the function
16:08:15 <jle`> but in Haskell, you can't actually pass types as arguments literally
16:08:19 <grantwu> Hrm... this sounds like something ML functors solves
16:09:01 <EvanR> xocolatl: you can try [Value] (from the aeson library) which has an instance, the docs say "json"
16:09:15 <EvanR> but that might only work on postgres json fields
16:09:28 <grantwu> I wish there was a way to see what language extensions a package uses
16:09:41 <grantwu> Or at least an adhoc convention where a package might say
16:09:48 <xocolatl> I would guess that would only be for json fields indeed, but let's give it a whirl
16:09:58 <jle`> grantwu: a package can enable extensions 'globally' in the cabal file
16:10:01 <jle`> so you can look at there
16:10:18 <jle`> unless you mean that you wanted a list of all the extensions used in any of the modules in the package
16:10:19 <glguy> But packages typically don't use that, so it's not reliable as a way to answer this question
16:10:40 <jle`> grep -R LANGAGE src/ , maybe?
16:10:45 <grantwu> To use Foolibrary, you must understand: TypeFamilies, FunctionalDependencies, MultiparameterTypeClasses
16:10:47 <jle`> s/LANGAGE/LANGUAGE
16:10:53 <glguy> add a -i for case insensitive
16:11:13 <jle`> glguy: ah also, just because a package uses an extension in its implementation doesn't mean that you need to understand it to use it
16:11:19 <grantwu> Yeah ^
16:11:19 <jle`> * grantwu 
16:12:00 <grantwu> Then you could have a "newb friendly library set"
16:12:55 <grantwu> Probably a ton of work though, so I doubt this'll ever happen :/
16:13:07 <xocolatl> EvanR: same error message (but with Value instead of ByteString for the haskell type)
16:13:26 <glguy> Is it actually language extensions that people are getting stuck on?
16:13:46 <glguy> I think there's plenty of struggling with stuff that was in Haskell 98
16:14:25 <jle`> yeah, the extensions might be the wrong thing to arbitrarily delineate skill level at
16:14:34 <grantwu> well, Megaparsec's usage of fundeps and this proxy stuff (type families) is something I personally am getting stuck on
16:14:37 <jle`> what is newb friendly or not newb friendly is probably *concepts*
16:14:40 <jle`> not extensions
16:14:50 <jle`> grantwu: yeah, you're not stuck on the extension, you're stuck on specific concepts
16:14:51 <grantwu> Sure
16:15:10 <jle`> so it would be more useful to specify what concepts you'd need to understand to use a library
16:15:21 <grantwu> The extensions are just implementations of certain concepts, I guess?
16:15:27 <EvanR> xocolatl: right. so on one hand the database is a well typed system and we like to retain this as much as possible in haskell. but on the other hand, the literal protocol for communicating with SQL databases is a raw stupid string of data, why cant we just show it
16:15:31 <jle`> grantwu: in what way?
16:15:32 <EvanR> so yeah this is frustrating
16:16:15 <xocolatl> EvanR: glad I'm not alone :)  I usually like how well typed haskell and postgres both are, but #!@$
16:16:17 <glguy> if you don't want what the postgresql-simple library exists for, maybe just use the underlying library instead of dismantling this one
16:16:22 <EvanR> xocolatl: i dont even have a haskelly justification for this, i this i would open a github issue for it
16:16:33 <EvanR> i think*
16:16:40 <grantwu> jle`: The concept of a https://en.wikipedia.org/wiki/Type_family vs the extension https://wiki.haskell.org/GHC/Type_families
16:17:11 <EvanR> glguy: it seems a simple matter to add an instance for a newtype "DumbAsHellString"
16:17:16 <jle`> grantwu: yeah, but there's no reason to use "extensions" as an arbitrary way of specifying what concepts are useful to understand
16:17:26 <EvanR> for debuggin
16:17:31 <xocolatl> glguy: I get scared by looking at how postgresql-simple uses libpq.  my haskell is nowhere near good enough for that
16:17:32 <jle`> a lot of extensions don't really correspond to any new concepts, and a lot of concepts don't correspond to any specific extensions
16:17:34 <grantwu> jle`: Sure
16:17:38 <EvanR> they have other debugging stuff in there, just not for this
16:18:06 <glguy> EvanR , the query type was a hint that it doesn't attempt to make dynamically generated queries easy
16:18:42 <xocolatl> that's so people don't stupidly build queries by appending strings
16:18:43 <EvanR> this isnt just not easy, its absurdly difficult
16:19:02 <EvanR> and its not even really about the query, its the results
16:19:08 <xocolatl> exactly
16:19:12 <benzrf> EvanR: just wireshark it C:
16:19:12 <glguy> xocolatl: and the type class driven from row is the same story
16:19:37 <EvanR> xocolatl: well when i started haskell, i was able to fix a 64/32bit mismatch in mysql-simple, so it cant be that bad ;)
16:20:25 <glguy> anyway, building EvanR 's dumb string type will be a good exercise
16:20:36 <EvanR> try, i see the support to do that now
16:20:39 <EvanR> true
16:20:58 <grantwu> jle`: Going off of concepts then, maybe a generalized disclaimer?  "We use advanced type level programming, be warned!"
16:21:26 <xocolatl> I'm kind of fed up with it tonight (this is a hobby project, not anything I need for work)
16:21:30 <EvanR> building a decent repl for this is definitely going outside postgres-simples scope, but i can see how this is a pain in the arse to just get a hello world
16:21:41 <jle`> yeah, that's something i hope libraries can announce up-front :)  like, the specific concepts that a user would need to use the library
16:21:52 <jle`> like, basic understanding of lenses, or template haskell, or generics
16:22:41 <EvanR> jle`: user skill dependency tracking?
16:23:16 <EvanR> must download lens mastery
16:23:23 <jle`> lol
16:23:55 <jle`> some kind of haskell knowledge tree/graph might be useful haha
16:25:53 <EvanR> what is the root of that tree
16:26:07 <EvanR> reasonable awareness of surroundings?
16:26:13 <Axman6> _|_
16:26:26 <grantwu> "functions are function values"
16:26:35 <EvanR> _|_ persistent vegetative state
16:33:52 <Cale> xocolatl: The reason for incompatible types is that the parser for ByteString expects a field in a particular format. (Sorry, I've been a bit busy here...)
16:34:10 <Cale> xocolatl: You'll actually want to make the query in a lower-level way, which doesn't attempt to parse the fields, most likely
16:34:50 <EvanR> which you can effectively do with the FieldParser support in postgres-simple
16:35:05 * hackagebot wai-middleware-content-type 0.5.0.1 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.5.0.1 (athanclark)
16:35:07 * hackagebot consul-haskell 0.4 - A consul client for Haskell  https://hackage.haskell.org/package/consul-haskell-0.4 (sseveran)
16:35:09 * hackagebot persistable-record 0.4.0.3 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.4.0.3 (KeiHibino)
16:40:32 <West405>  
16:47:24 <grantwu> Anyone have experience using Alex with Megaparsec?
17:13:43 <juri_> http://lpaste.net/215955
17:13:48 <juri_> can someone give me a bit more of a clue about this warning?
17:14:33 <koz_> juri_: Could you paste the code generating these? Just the immediate context is fine.
17:14:55 <koz_> I'll be able to give you more concrete feedback if I see what exactly is generating this.
17:15:34 <pavonia> Looks like there's not case branch for x<0 || x>12
17:16:27 <koz_> pavonia: I can tell, but I wanna see what exactly juri_ already has, so I can suggest a fix.
17:17:06 <juri_> http://lpaste.net/216844
17:17:23 <juri_> that's all the exprN functions...
17:17:34 <juri_> starting at the line kicking that error.
17:17:42 <juri_> er. warning.
17:17:54 <prsteele> juri_: yes, but what if someone calls `exprN 13` ? or `exprN (-1)`?
17:18:25 <koz_> What prsteele said.
17:18:28 <juri_> sure, so do i add a expr n@_ at the end, generating error?
17:18:41 <koz_> juri_: That's an option, but that would make exprN partial.
17:18:43 <prsteele> you might want to create something like `data MyFlag = A0 | A2 | ... A12`, and then have `exprR :: MyFlag -> GenParser Char st Expr`
17:18:56 <koz_> Also, what prsteele said again.
17:19:05 * koz_ needs to up his question-answering game.
17:19:47 <juri_> ok, that makes some sense.
17:20:29 <EvanR> koz_: higher-lower ?
17:21:00 <juri_> I'm in the process of making the project i maintain compile without warnings. it teaches me some haskell. ;)
17:21:41 <koz_> EvanR: Wat.
17:21:49 <prsteele>  -Wall -Werror for life
17:21:57 <koz_> juri_: Good idea.
17:22:07 <koz_> And, once again, what prsteele said.
17:22:15 <koz_> I should just write a macro for saying that.
17:22:17 <prsteele> lol
17:22:21 <koz_> Like /truth or something.
17:22:56 <koz_> How do I let-bind something for lambdabot?
17:23:11 <prsteele> > let f x = x -- ?
17:23:14 <lambdabot>  <no location info>: error: not an expression: ‘let f x = x -- ?’
17:23:32 <prsteele> not sure
17:23:35 <koz_> > let truth = "What prsteele said."
17:23:37 <lambdabot>  <no location info>: error:
17:23:37 <lambdabot>      not an expression: ‘let truth = "What prsteele said."’
17:23:40 <koz_> :(
17:24:15 <Koterpillar> >let truth = "What koz_ said" in truth
17:24:19 <Koterpillar> > let truth = "What koz_ said" in truth
17:24:21 <lambdabot>  "What koz_ said"
17:24:40 <koz_> Koterpillar: Ah.
17:24:53 <koz_> But then..
17:25:04 <koz_> > fmap ord truth
17:25:06 <lambdabot>  error: Variable not in scope: truth :: f Char
17:25:07 <geekosaur> probably was looking for @let
17:25:10 <koz_> Yes, that.
17:25:17 <koz_> @let truth "What prsteele said."
17:25:17 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
17:25:23 <koz_> ARGH.
17:25:29 <MarcelineVQ> y'all whack
17:25:32 <geekosaur> it's a top level expression
17:25:35 <koz_> MarcelineVQ: Proudly.
17:25:46 <koz_> @let truth = "What prsteele said."
17:25:48 <lambdabot>  Defined.
17:25:54 <koz_> > fmap ord truth
17:25:57 <lambdabot>  [87,104,97,116,32,112,114,115,116,101,101,108,101,32,115,97,105,100,46]
17:26:07 <koz_> > truth
17:26:09 <lambdabot>  "What prsteele said."
17:26:14 <koz_> There we go, perfect!
17:26:43 <EvanR> profoundly whack
17:26:58 <EvanR> someone give lambdabot a variable for the last thing said
17:27:04 <EvanR> and who said it
17:27:20 <koz_> EvanR: How would you even?
17:27:31 <EvanR> im guessing with IO
17:27:44 <koz_> EvanR: You can order pizza with IO.
17:27:53 <koz_> (except you'd get IO Pizza instead of Pizza)
17:27:57 <koz_> (goddamn one-way monads)
17:28:00 <Clint> now i want pizza
17:28:04 <EvanR> me too
17:28:30 <EvanR> i also want to write an IO action that orders pizza
17:28:37 <koz_> EvanR: Surely that's not too hard.
17:28:51 <koz_> order :: Text -> MaybeT (IO Pizza)
17:28:59 <Koterpillar> :t Pizza
17:29:01 <lambdabot> error: Data constructor not in scope: Pizza
17:29:10 <grantwu> unsafeOrderPizza
17:29:18 <koz_> grantwu: I see you like to live dangerously.
17:29:46 <EvanR> pretty sure Pizza, whatever it is, cant be eaten
17:29:54 <koz_> I wonder if any pizza place has a public API I can write a Hackage package against.
17:30:03 <EvanR> i think that exists
17:30:04 <grantwu> unsafeDupableOrderPizza
17:30:04 <koz_> EvanR: No, you'd need an IO action for that.
17:30:11 <grantwu> I have nothing against ordering multiple peoples.
17:30:13 <koz_> So something like 'eat :: Pizza -> Maybe Pizza'.
17:30:24 <EvanR> if you run an IO action to eat pizza, you probably dont want it to return Pizza as a result
17:30:35 <koz_> EvanR: What if you don't finish it?
17:30:36 <Koterpillar> leftovers
17:30:41 <koz_> Hence, Maybe Pizza.
17:30:44 <benzrf> koz_: ayyyyy lmao
17:31:01 <EvanR> enough
17:32:14 <koz_> Well, that cheered me up from this marking I'm having to do, which is frankly depressing.
17:32:37 <EvanR> IO Franks
17:33:08 <koz_> EvanR: Why not just define a Food typeclass and be done with it?
17:35:03 <grantwu> class Edible a => Food a 
17:35:06 * hackagebot hs-di 0.3.0 - Dependency Injection library for Haskell  https://hackage.haskell.org/package/hs-di-0.3.0 (Wizek)
17:35:15 <koz_> grantwu: There are non-Food edibles?
17:35:26 <grantwu> ...possibly
17:35:26 <EvanR> well there is a category of food
17:35:42 <EvanR> where burritos are monads
17:35:43 <Koterpillar> what is the identity morphism in that category?
17:35:50 <koz_> Koterpillar: I was about to ask.
17:36:09 <Koterpillar> microwave?
17:36:12 <EvanR> ill have to review the pdf
17:36:27 <koz_> #haskell - where humour is effectful.
17:36:42 <EvanR> morphisms are recipes
17:36:48 <EvanR> so identity is raw
17:37:06 <koz_> EvanR: Does associativity hold?
17:37:27 <Koterpillar> the domain of recipes is different from the codomain
17:37:45 <EvanR> you can compose recipes
17:38:00 <EvanR> it doesnt matter how theyre grouped
17:38:15 <koz_> Koterpillar: You mean the range? It's still Food -> Food, but you just don't have surjectivity.
17:38:46 <koz_> Unless there's some category-theoretical notion of codomain I'm missing here.
17:38:47 <Koterpillar> koz_: recipes are typically -> Food, but input varies
17:39:05 <EvanR> surjective?
17:39:08 <geekosaur> aaand now I'm thinking `eat` wanted to be CPS
17:39:12 <koz_> EvanR: Onto.
17:39:19 <EvanR> what would that mean
17:39:22 <koz_> geekosaur: Good idea, actually - you can eat things in different ways.
17:39:58 <koz_> EvanR: That for all y in the codomain of the function, there exists some x in the domain such that f(x) = y.
17:40:10 <geekosaur> also, possibly a stream abstraction to properly express the leftovers :)
17:40:12 <koz_> In a way, there are no 'unreachable elements' of the codomain, I guess.
17:40:58 <koz_> geekosaur: New cookbook by #haskell 'Monadic food programming'.
17:41:06 <EvanR> thats for functions, not recipies
17:41:42 <EvanR> or are you talking about an endofunctor
17:41:51 <jle`> recipies are `IO Food`
17:41:57 <jle`> or `Recipe Food`
17:42:01 <koz_> Then later, Edward Kmett proves that food is actually [insert complex category theoretical construction here] and makes a new library.
17:42:35 <harwiltz> Hello all. How could I go about converting the output of a trig function (ie (sin x)) to an Int? I've tried a bunch of fromIntegral configurations, as well as fromIntegral . toInteger, but can't get anything to work
17:42:44 <EvanR> :t floor
17:42:45 <lambdabot> (RealFrac a, Integral b) => a -> b
17:42:53 <koz_> EvanR: round would work too?
17:42:53 <prsteele> also ceiling, round
17:42:55 <koz_> :t round
17:42:57 <lambdabot> (RealFrac a, Integral b) => a -> b
17:42:59 <EvanR> :t truncate
17:43:00 <lambdabot> (RealFrac a, Integral b) => a -> b
17:43:03 <harwiltz> I tried round actually, didn
17:43:06 <koz_> ${DEITY}-damn it, prsteele...
17:43:07 <harwiltz> *didn't work
17:43:09 <koz_> > truth
17:43:11 <lambdabot>  "What prsteele said."
17:43:12 <harwiltz> I'll try floor
17:43:13 <prsteele> @where hoogle
17:43:13 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
17:43:16 <jle`> harwiltz: hm, what do you mean by "didn't work" ?
17:43:22 <harwiltz> jle`: Compiler error
17:43:25 <prsteele> you can search for things like "Double -> Int" there
17:43:28 <jle`> what was the compiler error?
17:43:31 <EvanR> round should work
17:43:37 <jle`> it might have had problems figuring out what type you wanted to round to.  or from
17:43:53 <jle`> > round (sin 3)
17:43:54 <EvanR> > round (sin 1)
17:43:55 <lambdabot>  0
17:43:56 <Koterpillar> harwiltz: with probability 1, the output of sin x can be converted to an Int using (const 0)
17:43:57 <lambdabot>  1
17:43:57 <harwiltz> jle`: I think that's it, just a sec
17:44:19 <EvanR> lol
17:44:20 <jle`> > round (sin 3 * 100)
17:44:23 <lambdabot>  14
17:44:34 <harwiltz> Right now I have "let red = floor $ 255.0 * (sin x)
17:44:40 <EvanR> Koterpillar: preserving what property?
17:44:57 <jle`> harwiltz: yeah, we'd need to know the compiler error to help.  there's a lot of things that could go wrong with that
17:45:03 <harwiltz> And I get the error: No instance for (RealFrac Int) arising froma use of floor
17:45:05 <jle`> x might be an Int or something
17:45:07 <jle`> oh hey
17:45:09 <jle`> lol
17:45:13 <jle`> yeah, you can't call sin on Int's
17:45:20 <harwiltz> Lol. I'm dumb
17:45:34 <jle`> sin (fromIntegral x) would work
17:45:47 <harwiltz> Yup :)
17:45:48 <jle`> if x has to be an Int
17:46:12 <jle`> but sin's of Ints are usually uninteresting, heh
17:46:26 <harwiltz> jle`: That's true. This is mostly experimental
17:46:37 <EvanR> ghc needs an extension which reports errors as if #haskell explained them
17:46:39 <koz_> jle`: Un-Int-resting, you say?
17:46:44 <harwiltz> ;)
17:46:49 <koz_> EvanR: I'm not sure that's decidable.
17:46:53 <jle`> yeah, was just suggesting that it might have been a bug in your logic if you ended up having to take the sine of an Int
17:46:56 <jle`> koz_: ;)
17:46:58 <EvanR> "you cant use foo on a bar"
17:47:13 <jle`> for example, if i accidentally took the sin of a Bool, my problem probably isn't that i needed to convert the Bool
17:47:19 <grantwu> koz_: It's not that bad to implement if you require internet access :D
17:47:19 <jle`> it's probably that i took the sin of the wrong thing
17:47:34 <koz_> grantwu: Can you imagine the amount of compile error spam we'll have to answer?
17:47:52 <EvanR> its not that bad if you require a credit card number ;)
17:47:54 <grantwu> Yes; it sounds horrifyingly beautiful
17:48:13 <koz_> Compiler errors as a service.
17:48:14 <grantwu> Maybe we should apply ML to this.
17:48:22 <koz_> I'm sure there's at least five SF startups working on it.
17:48:26 <grantwu> use #haskell as training data.
17:48:30 <EvanR> well, there is now
17:48:32 <grantwu> To improve error messages
17:48:36 <koz_> grantwu: That's a hilarious PhD.
17:49:41 * geekosaur wonders if they're taking sine of an angle in degrees instead of radians
17:50:46 <jle`> :o
17:51:24 <jle`> every once in a while i forget that degrees are a thing
17:52:41 <MarcelineVQ> not rad enough?
17:53:10 <EvanR> double bacon six cheese... inspect element
17:58:12 <jle`> oh i was talking about academic degrees
18:00:06 <EvanR> you dont need a phd to learn haskell, its just a side effect
18:02:14 <nathyong> Does anybody know how fast ether is?
18:02:29 <nathyong> (that is, does it slow down compilation a lot, is it slower than mtl, etc)
18:03:45 <Sindriava> nathyong: I doubt either slows compilation in a meaningful way, I prefer to use the repl :)
18:04:06 <nathyong> Sindriava: ether, the mtl extension library, not Either
18:04:16 <nathyong> https://int-index.github.io/ether/
18:04:51 <Sindriava> nathyong: Either, as in "either of mtl or ether", not the type.
18:05:02 <nathyong> oh, right lol
18:05:32 <nathyong> well seeing as I'm already using Generics and TH I guess there's not much hope on the "compilation speed" side
18:05:56 <Sindriava> Oh yeah, that ship has sailed with TH imo D>
18:05:58 <Sindriava> * :D
18:06:40 <EvanR> :D>
18:09:32 <nathyong> I should probably just roll my own lenses
18:09:45 <nathyong> or write a vim macro that will generate them for me actually
18:09:53 <nathyong> that's an idea
18:10:22 <jle`> to help with compilation time?
18:11:02 <EvanR> im thinking about doing something like that
18:11:04 <jle`> i saw someone come in here with a super cute idea on how to write lenses using only ghc generics and minimal boilerplate
18:11:10 <jle`> i thought that was neat
18:11:25 <nathyong> that sounds like a good idea honestly
18:12:04 <jle`> the only reason we haven't dropped TH altogether is because you need TH to make the names of the functions match the names of the constructor
18:15:04 <nathyong> but I thought you could only use generics to derive stuff like instances?
18:15:09 <nathyong> right
18:15:32 <jle`> you can use generics and stuff to derive functions too
18:15:34 <jle`> that aren't instances
18:15:45 <jle`> the limitiation is that you can't dynamically generate identifiers
18:16:54 <grantwu> Does anyone know how to get Megaparsec to parse an custom token type?
18:25:26 <pavonia> grantwu: You have to define a Stream instance for it, I think
18:25:36 <grantwu> I have
18:25:45 <grantwu> Also, does anyone know what :| is here? https://hackage.haskell.org/package/megaparsec-5.0.1/docs/src/Text-Megaparsec-Char.html#satisfy
18:27:04 <grantwu> pavonia: I guess what I'm asking is... so how do I get a monadic value?
18:27:43 <grantwu> Do I just call token?  How does that work...
18:27:48 <pavonia> What do you mean?
18:27:54 <jle`> :|
18:28:14 <jle`> grantwu: could be http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List-NonEmpty.html
18:28:26 <geekosaur> that was my guess
18:28:38 * geekosaur didn't realize it had gone into base in 8.0
18:28:41 <grantwu> ah, it is.
18:29:02 <geekosaur> so I was poking through the standalone packages
18:29:03 <grantwu> thanks.
18:29:20 <grantwu> pavonia: so I have a stream type
18:29:47 <grantwu> I did the instance AlexStream Stream thing (I'm trying to get Megaparsec working with Alex)
18:30:07 <grantwu> then I said type Parser = Parsec Dec AlexStream
18:30:15 <nathyong> wow, nonempty is in base
18:30:58 <Clint> so is semigroup
18:31:19 <jle`> yeah, if you move semigroup into base, might as well move one of its most useful instances
18:32:55 <grantwu> pavonia: Oh, I think this is me not entirely getting multiparameter type classes/type families...
18:42:39 <EvanR> question, whats the point of data families. i dont think ive ever seen them used
18:42:47 <grantwu> Is there any way to get the source of something from hackage in raw form?
18:42:51 <EvanR> usually people use type (synonym) families
18:45:24 <pavonia> grantwu: You can browse the source files of the package
18:45:34 <grantwu> pavonia: That's not in raw form
18:45:39 <grantwu> It has syntax highlighting and stuff
18:45:55 <dcoutts_> EvanR: it's about injectivity
18:46:03 <grantwu> I want to be able to do curl hackage.haskell.org/blah | grep ""
18:46:28 <grantwu> Incidentally - I'm trying to find Tokens https://hackage.haskell.org/package/megaparsec-5.0.1/docs/src/Text-Megaparsec-Char.html#satisfy
18:46:29 <dcoutts_> grantwu: yes, raw source files
18:46:35 <pavonia> grantwu: Not from the documentation, I mean on the main page there's "browse"
18:47:07 <pavonia> https://hackage.haskell.org/package/megaparsec-5.0.1/src/
18:47:23 <grantwu> pavonia: Ah, cool
18:47:45 <grantwu> Does anyone know where Tokens might be defined/
18:47:48 <grantwu> I can only find tokens
18:49:05 <EvanR> what about injectivity
18:50:52 <geekosaur> it's a type family associated with the Stream class
18:51:39 <grantwu> geekosaur: https://hackage.haskell.org/package/Stream-0.4.7.2/docs/Data-Stream.html here?
18:51:40 <geekosaur> http://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Prim.html#t:Token
18:52:12 <geekosaur> quite possibly haddock doesn't handle associated type families well yet...
18:52:13 <grantwu> Oh, *facepalm*
18:52:51 <grantwu> hrm?  I think this is probably just my fault
18:54:06 <grantwu> Token wasn't referenced anywhere that it should've been linked if that's what you're saying
18:54:50 <geekosaur> yeh, I ran into some stuff that didn't seem to be linked usefully when looking for (:|) too
18:55:07 <geekosaur> also hayoo seems not to understand type families yet :/
18:56:35 <cheater> if i'm using quickcheck to test equality of two values, can i make it spit out those two values when it fails?
19:01:08 <EvanR> geekosaur: i noticed agda html output links great, but it generates html for literally everything ever. maybe if you generate haddocks locally the links will all work just as well as that
19:01:12 <EvanR> er grantwu 
19:01:25 <grantwu> wait
19:01:48 <grantwu> geekosaur: That's Token, not Tokens
19:01:55 <geekosaur> oh :/
19:03:10 <grantwu> :'(
19:04:30 <grantwu> geekosaur: AHA https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Error.hs
19:04:37 <geekosaur> ah
19:04:52 <geekosaur> sure enough...
19:05:12 <grantwu> Yeah... I just started looking at the likely imports...
19:05:27 <nshepperd> cheater: i think it does that by default if you use ===
19:05:51 <grantwu> Oh, and of course.  I should've looked at the ErrorItem type
19:06:21 <cheater> oh there's ===? i didn't know. thanks.
19:06:29 <nshepperd> :t (Test.QuickCheck.===)
19:06:31 <lambdabot> (Show a, Eq a) => a -> a -> Test.QuickCheck.Property.Property
19:17:04 <cheater> yes, that worked. thank you!
20:12:06 <grantwu> Am I hitting the MR here? http://lpaste.net/217537
20:13:43 <geekosaur> no, since you have a type signature
20:14:12 <grantwu> oh
20:14:16 <grantwu> I need to annnotate fromIntegral
20:16:28 <grantwu> Okay... but mkPos just says it takes an Integral
20:16:47 <grantwu> Am I just supposed to pick some instance of Integral?
20:17:13 <grantwu> Why can't I have this be polymorphic for all Integrals?
20:17:30 <geekosaur> I noticed that in the error; your fromIntegral there is pointless
20:17:45 <geekosaur> er, the warning
20:18:00 <grantwu> oh
20:18:11 <geekosaur> ypu take an Integral instance to a Num instance, then mkPos takes that down to an Integral instance
20:18:32 <grantwu> well that's embarassing :/
20:19:27 <grantwu> geekosaur: Thanks
20:23:17 <buhrmi_> MYAAAAHH
20:23:36 <grantwu> buhrmi_: ?
20:25:16 <buhrmi_> grantwu: totally
20:53:20 <grantwu> I've got more trouble with type families
20:54:49 <grantwu> http://lpaste.net/217699
20:56:13 <grantwu> How do I get the compiler to do the obvious thing?
20:57:09 <pavonia> You have to give an explicit type annotation such that it knows what 's' is
20:57:54 <buhrmi_> have u tried Ctrl+a delete?
20:58:22 <grantwu> pavonia: Could you show me what to do in this instance?
20:58:41 <grantwu> annotating Semi with Token s doesn't work
20:59:47 <pavonia> Try "semi :: (Token s ~ Lex.Lexeme, MonadParsec e s m) => m (Token s)"
21:00:56 <grantwu> pavonia: Uh...
21:01:04 <grantwu> Why is semi supposed to be monadic?
21:01:34 <pavonia> That's the result of the tokParse function
21:02:19 <grantwu> Right, tokParse yields a monadic value.  But Semi shouldn't, I think?
21:02:42 <pavonia> Don't confuse semi and Semi
21:02:56 <grantwu> er... what is semi
21:03:02 <joe9> geekosaur: just want to get your opinion if you notice something obvious: https://gist.github.com/c37e65595684bea91ef2dc0c59762ffa is my code.
21:03:14 <grantwu> Wait, hold on, I think I have confused Lex.Lexeme and Tok
21:03:14 <joe9> geekosaur: line 107 core dumps
21:03:27 <grantwu> No, never mind
21:04:14 <joe9> geekosaur: but nothing is printed from line 104 :  fprintf(stderr, "Could not create context\n");
21:04:17 <geekosaur> joe9, you free error and then try to print error->error_code
21:04:33 <joe9> geekosaur: silly mistake. Thanks.
21:04:50 <h0ffmann> huh?
21:05:11 <geekosaur> h0ffmann, this is some C that apparently will be hooked into Haskell
21:05:16 <joe9> geekosaur: but that is not it though. It still core dumps with this:  https://gist.github.com/45ad222083c0099128b511a50d8a7911
21:05:38 <h0ffmann> Ok. Haskell is like?
21:05:52 <joe9> geekosaur: if there is an error, the fprintf to stderr should print that line, correct?
21:06:27 <geekosaur> it will print on line 104, then you unconditionally try to print error->error_code even if the call succeeded (and error is NULL)(
21:06:30 <joe9> geekosaur: without this line,    fprintf(stdout, "xcb_generic_error_t: %d\n", error->error_code); , the OpenGL version lines print NULL.
21:06:32 <EvanR> h0ffmann: check out the /topic command and follow the links to see what Haskell is like
21:07:18 <joe9> geekosaur: without that printf on error, this is what I get: http://bpaste.net/show/05b2a359a1ef
21:07:20 <geekosaur> in fact you free error unconditionally, even if it came back NULL
21:07:40 <joe9> geekosaur: I am trying to figure out why the glGetString functions would not be working.
21:07:50 <joe9> geekosaur: they just return (null)
21:08:16 <joe9> geekosaur: I added the printf on error code as I suspected that something is off with the context creation.
21:09:56 <h0ffmann> .help Let them eat cake
21:10:53 <Rotaerk> ..
21:11:54 <grantwu> pavonia: Adding the type annotation you gave seems to spawn more errors
21:12:07 <pavonia> yay
21:12:12 <grantwu> pavonia: 
21:12:13 <grantwu> oh
21:12:17 <grantwu> never mind I did confuse semi and Semi
21:13:06 <grantwu> pavonia: No, what you gave works, my apologies
21:13:25 <pavonia> No worries :)
21:18:04 <cheater> if i have two Property values in QuickCheck, can i somehow glue them together?
21:18:29 <cheater> so what i want to do is, when quickcheck gives me one set of parameters, i'd like to check TWO things at once
21:19:18 <cheater> so instead of prop a b = (a^2) === (b^2) i'd like to have something like... prop a b = (a^2) === (b^2) &&& (a^3) == (b^3)
21:20:11 <Koterpillar> .&&.
21:20:31 <Koterpillar> https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Property.html#v:.-38--38-.
21:21:10 <athan> Is there a comonad for co-lists?
21:21:20 <athan> er, cofree comonoid..?
21:21:31 <athan> where extend :: [a] -> [[a]]
21:22:57 <dibblego> athan: there is no extract, so there is only extend
21:23:01 <jle`> [] is not a comonad
21:23:27 <dibblego> https://hackage.haskell.org/package/semigroupoids-5.1/docs/src/Data-Functor-Extend.html#line-72
21:30:20 <geekosaur> joe9, I think you'll have to find someone who understands the glx extension under xcb. I have no idea why those calls are failing, unless there is some call necessary to pass the context from xcb to opengl
21:32:11 <athan> dibblego, jle`: Awesome :) starting to get the hang of it
21:33:29 <athan> Monoid a => (NonEmptyVector a `mod` length n) might be? :s
21:33:50 <jle`> what is n?
21:33:58 <jle`> er
21:34:00 <athan> where `extract :: Monoid a => NonEmptyVectorModLength 4 a -> a` would just <> the 4 a's up
21:34:04 <jle`> is that supposed to be an instance declaration?
21:34:04 <athan> :v
21:34:31 <athan> agh shoot
21:34:33 <jle`> what is NonEmptyVectorModLength ?
21:34:38 <athan> this is something related to countability...?
21:34:55 <athan> jle`: a mock type representing size-indexed vectors
21:35:05 <athan> well, really a hybrid between lists and chunksOf
21:35:11 * hackagebot xml-conduit 1.4.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.4.0.1 (MichaelSnoyman)
21:35:13 * hackagebot yesod-core 1.4.25 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.25 (MichaelSnoyman)
21:35:15 * hackagebot wai-extra 3.0.18 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.18 (MichaelSnoyman)
21:35:17 * hackagebot language-bash 0.6.2 - Parsing and pretty-printing Bash shell scripts  https://hackage.haskell.org/package/language-bash-0.6.2 (KyleRaftogianis)
21:35:19 <jle`> i'm not sure i follow
21:35:23 <athan> so it mandates the list/vector to be of length foo, where foo `mod` n == 0
21:35:30 <joe9> geekosaur: ok, Thanks.
21:35:32 <athan> I don't know if I do either o_0
21:35:47 <athan> sorry, thanks jle`!
21:36:29 <jle`> fixed-length vectors are comonads, btw
21:36:45 <hetao> Client: HexChat 2.12.1 • OS: Microsoft Windows 10 Pro (x64) • CPU: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz (2.59GHz) • Memory: 7.9 GiB Total (3.3 GiB Free) • Storage: 209.8 GiB / 450.6 GiB (240.8 GiB Free) • VGA: Intel(R) HD Graphics 5500 • Uptime: 13h 23m 37s
21:36:45 <jle`> as long as their length is at least 1
21:37:38 <Koterpillar> hetao: your homework for today: add GHC version
21:37:39 <grantwu> hetao: Wrong chat?
21:38:10 <h0ffmann> hetaoJo n1
21:38:29 <geekosaur> joe9, fwiw it looks like you need to make the context current to get it from the glx extension to opengl
21:38:34 <jle`> athan: extract [x,y,z] = x and duplicate [x,y,z] = [[x,y,z],[y,z,x],[z,x,y]], a length-3-vector
21:38:37 <geekosaur> creating it does not make it current
22:15:08 <dmwit> ?hoogle Applicative f => Int -> f a -> f [a]
22:15:10 <lambdabot> Control.Monad replicateM :: (Applicative m) => Int -> m a -> m [a]
22:15:11 <lambdabot> Text.Parser.Combinators count :: Applicative m => Int -> m a -> m [a]
22:15:11 <lambdabot> Text.Megaparsec count :: Applicative m => Int -> m a -> m [a]
22:15:30 <ania123> which one is correct: The process to evaluate a type to an expression is called type inference or The process to evaluate a type for an expression is called type inference.
22:15:35 <dmwit> Megaparsec seems like the wrong library for this to be in.
22:16:02 <dmwit> ania123: The latter is more correct English; but "evaluate" is probably the wrong verb.
22:16:17 <dmwit> "infer" would of course be the canonical choice =P
22:16:33 <dmwit> But "choose" could be okay, too, perhaps, depending on what you mean.
22:31:56 <neonfuz> Do you guys have any recommendations for learning haskell?
22:32:13 <liste> @where learnhaskell
22:32:13 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:32:16 <neonfuz> Right now I'm making my way through Learn You A Haskell, but I'm thinking maybe I want something more serious/in depth
22:33:01 <EvanR> brent yorgey's CS course listed on that link is pretty highly rated
22:33:24 <EvanR> @where cis194
22:33:24 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
22:33:46 <dmj`> neonfuz: sit down and make a chart with two axis, on the Y axis write typeclasses, on the X axis write data types. For each square in the grid, write the typeclass instance for that data type from memory.
22:34:07 <EvanR> lol
22:34:18 <dmj`> keep growing the grid until haskell mastery achieved
22:34:30 <EvanR> type bingo
22:34:34 <dmj`> heh
22:34:35 <EvanR> the middle square is a free monad
22:34:55 <dmj`> heh
22:35:12 * hackagebot htaut 0.1.1.0 - Tautology Proving Logic in Haskell  https://hackage.haskell.org/package/htaut-0.1.1.0 (Ailrun)
22:35:19 <dmj`> I was thinking Monad ContT, but free monad works too
22:35:27 <EvanR> or if its [A], Monoid, a free monoid
22:52:01 <jle`> there should be a #haskell bingo
22:53:23 <dmj`> haskingo
22:54:05 <ReinH> "What is a free monad?" I have bingo!
23:35:14 * hackagebot servant-auth-cookie 0.4 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.4 (zohl)
23:36:22 <Lokathor> "how do i use random numbers"    "why is "foo" ++ getLine a type error?"
