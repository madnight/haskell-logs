00:01:32 <jle`> csraghunandan: what do you need to do that for?
00:01:52 <chreekat> csraghunandan: do you mean library or executable?
00:01:55 <jle`> ( also, this channel has non-guys, too! :) )
00:02:19 <Axman6> guys is definitely a gender neutral term these days
00:02:39 <ReinH> It definitely is not.
00:03:10 <chreekat> I'm on the fence. where i grew up, definitely, and I still see the term used by a woman to refer to a group of women. But where I have lived since, not so much
00:03:22 <chreekat> so I don't use it anymore, or try not to...
00:04:36 <phadej> guy is a men's name, I just cannot think plural "johns" to be gender neutral :)
00:05:54 <phadej> (I have immediate connection to https://en.wikipedia.org/wiki/Guy_L._Steele_Jr. )
00:06:02 <parsnip> Axman6: thanks, perfect
00:06:04 <parsnip> can post spoiler to projecteuler57
00:06:13 <parsnip> http://lpaste.net/186445
00:06:21 <parsnip> first use of mapAccumL
00:07:12 <Axman6> Ashley is also a men's name, but you'll struggle to find one these days
00:08:11 <Axman6> phadej: "johns" has a very particular meaning as "clients of prostitutes", so would probably not be a good choice for a collective noun for all men/all people :P
00:08:30 <phadej> Axman6::)
00:08:48 <phadej> then "simons" :)
00:09:11 <Axman6> "simons" has a specific meaning as "the elders of the GHC project" :P
00:09:59 <Cale> Guy is not only a man's name, it's also an English word.
00:10:20 <Cale> and while in some cases it refers to a male person, it doesn't have to
00:10:46 <Axman6> which means it's definition is fluid, like all english words (but not spelling!)
00:10:50 <ongy> and natural languages are well defined and globally agreed on. But this isn't -blah
00:22:20 <ania123> implemetation of alpha equivalence -- A algorthm which decides whether two terms are alpha equivalent.
00:22:39 <ania123> does someone knows where can I find it?
00:23:39 <opqdonut> alpha equivalence means renaming bound variables (lambda arguments)
00:24:19 <opqdonut> just recurse over the terms, check the structure matches, and keep track of the correspondence between bound names
00:25:08 <ania123> opqdonut: it is not so easy to implement, many things has to be considered ...
00:25:44 <phadej> it is
00:26:01 <ania123> it is?
00:26:13 <phadej> it is as easy
00:26:56 <phadej> recurse over with a reader where you collect renamings
00:28:48 <Cale> http://cale.yi.org/reflex/Audio/Audio.jsexe/ -- audio player example using reflex-dom
00:29:04 <ania123> phadej: I do not agree it is so easy as you think..
00:29:17 <ania123> Cale: what do you think, is alpha equivalence easy to implement?
00:29:20 <phadej> it is, have done multiple times
00:29:26 <phadej> in various ways
00:29:56 <cocreature> ania123: what problems are you thinking of?
00:30:03 <Cale> ania123: Depends on what you mean by easy. It's not a one-liner, but there's no special technical challenge there
00:30:34 <Cale> If the expressions differ structurally in any way, they're not alpha equivalent
00:30:47 <ania123> phadej: \xy.xy  and \yx.yx
00:30:54 <Cale> and the only interesting case in the comparison is where you reach a variable in both expressions
00:31:16 <Cale> You maintain a dictionary mapping the variables of one expression to the variables of the other
00:31:21 <cocreature> ania123: that’s what phadej was referring to by “collect renamings”
00:31:22 <phadej> ania123: one simple approach is to transform into bruijn indicces version
00:31:35 <phadej> ania123: both would be \.10
00:32:03 <phadej> and renamings would be "Map VarName Indice"
00:32:09 <Cale> I suppose the other interesting case is what happens at a binder
00:32:13 <ania123> phadej: I want to avoid bruijn indicces
00:32:17 <Cale> The binders add things to the dictionary
00:32:39 <Cale> and at variables, you look up what you had in the dictionary and check that it lines up
00:32:42 <phadej> ania123: than you can explicitly have Set (VarName, VarName) equivalences
00:33:05 <ania123> since we have infinite set of variables
00:33:13 <ania123> does the algorthm always terminates
00:33:13 <ania123> ?
00:33:22 <phadej> yes, it's strucutal recursion?
00:33:26 <Cale> ania123: Yeah, it's O(n) where n is the size of the structure
00:33:45 <Cale> Well, perhaps O(n log n), because you have to do lookups
00:35:30 <phadej> ania123: you have to consider only variables in the terms
00:35:56 <ania123> phadej: ok. thx
00:36:16 <phadej> or alternatively you can perform unique renaming, which will be < 10 lines
00:36:33 <jle`> EvanR: yes I agree, redundant constraints are often useful for documentation
00:37:06 <ania123> phadej: unique renaming? to use fresh variables?
00:37:12 <phadej> (i.e. systematically rename all variables to be unique ones, it's one way to make substitutuion simpler too)
00:37:36 <ania123> \x.x  and \y.y
00:37:36 <phadej> or just use `bound`, which gives all of that "for free" http://hackage.haskell.org/package/bound
00:37:42 <tdammers> DangerousDav3: programming is wrong? no. but the circumstances under which most of us have to do it are suboptimal at best, sometimes toxic.
00:37:55 <ania123> how would u rename those
00:38:00 <ania123> variables?
00:38:17 <phadej> say you have an infinite supply of variables [v0, v1, v2 ...]
00:38:23 <phadej> then both terms would be renamed to \v0.v0
00:39:06 <phadej> but the same strucutal recursion will be in that method as well, but only on a single term at once, which is simpler task
00:48:28 <wedify> apparently everything in the qt binding is machine generated
00:48:41 <wedify> i can't find what it is generated *from*
00:49:36 <wedify> it is hard trying to understand how c/c++ interface with haskell
00:50:04 <dysfun> it's probably using cffi
00:51:56 <cocreature> wedify: interfacing with c code is pretty straight forward in itself. but writing all this code by hand is a lot of work so a lot of libraries resort to generating this code in some way
00:52:24 <cocreature> wedify: there is no direct c++ interface so you basically have to write a c layer over the c++ code and interface with that
00:52:57 <cocreature> wedify: there are also a lot of supporting tools/libraries that make interfacing with c code easier such as hsc2hs and c2hs
00:55:06 <tdammers> that's an issue with C++ though, not Haskell's FFI
00:55:18 <tdammers> I believe binding to C++ code from *any* language requires a C wrapper of sorts
00:55:25 <tdammers> tjat
00:55:40 <cocreature> yeah sadly that’s the case
00:55:42 <dysfun> some people do attempt to just mangle the names and use as if it was C, but that doesn't always work
00:55:51 <tdammers> that's because C++ performs name mangling, and that mangling is platform- and compiler-specific, so you can't directly link to things
00:55:51 <geekosaur> as of C++11 it doesn't absolutely require it, but the interface details are hairy enough that it's still easiest to go through extern "C" shims on the C++ side
00:56:06 <geekosaur> not just name mangling. template instantiation and such
00:56:15 <cocreature> c++ semantics are also simply too complicated to be easily embedded into all sorts of languages
00:56:15 <dysfun> name mangling is the easy bit
00:56:30 <geekosaur> I know a project that figured out the name mangling and then ran into a brick wall the first time someone tried to import a template function
00:56:40 <dysfun> that sounds about right
00:56:53 <cocreature> yeah templates are one of the most annoying parts when binding to c++11
00:57:23 <dominik> Anyone knows how I use TLS via HTTP/2 over ALPN with the wai package?
00:57:59 <dominik> I can't seem to find how to set it up. But apparently this is now the preferred method instead of relying on warp-tls ?
01:03:55 <cocreature> dominik: what makes you think that? if I understand the docs correctly you are still supposed to use warp-tls. it is not warp-tls that is deprecated but the ssl support in warp-tls is deprecated in favor of tls
01:04:12 <dominik> cocreature: ahh, nvm. Yea, I see now
01:04:23 <cocreature> dominik: I might be wrong but that’s the way I interpret it :)
01:04:27 <dominik> ist just ssl that's deprecated :-)
01:04:43 <dominik> cocreature: no, I think you're right :-)
01:25:39 <erikd> did someone ping me? if, it was lost in the scrollback
01:36:07 <tdammers> how is template instantiation a problem? that happens at compile time, not runtime
01:37:32 <cocreature> tdammers: but how do you bind to a template function? you need to bind separately to each instantiation
01:37:46 <tdammers> cocreature: well yes of course, that's how templates work
01:37:59 <tdammers> the template function doesn't exist anymore once the code is compiled
01:38:25 <cocreature> tdammers: yeah but that gives you a very different api than the c++ api because you now need to think of every possible type your user might want to call the function on and provide a specialization and a binding to it
01:38:33 <cocreature> that’s quite painful
01:38:37 <tdammers> yes, it is
01:39:28 <tdammers> and IMO the sane solution is to not have C++ be your public-facing FFI language, i.e., use C++'s "FFI" to export C++ functions (extern "C"), and Haskell's C FFI to import them
01:39:40 <tdammers> and vv
01:39:59 <cocreature> well now we’re back to the point that it’s painful to bind to c++ libraries which is where we started
01:40:05 <tdammers> yes
01:40:25 <tdammers> C++ libraries in general are a bad idea IMO, unless they're specific to C++ itself
01:40:46 <tdammers> "foobar-for-C++" is a fine library to write in C++, "foobar" is not
01:41:02 <cocreature> it doesn’t matter if writing libraries in c++ is a bad idea if there is a giant library (hello llvm) that is not easily replacable so you need to bind to it
01:41:19 <tdammers> oh boy, right
01:41:32 <EvanR> theres java bridge... why not c++-bridge ;)
01:42:26 <wedify> there's hoppy and ffi-cxx. i'm playing around with both trying to understand them
01:43:56 <cocreature> wedify: tbh if your c++ library is not particularly large I would just bite the bullet and write a small c layer exposing the c++ api and bind to that
01:44:02 <tdammers> actually, just not doing any compile-time binding at all, and instead shelling out and using some sort of IPC is often a good idea
01:44:32 <wedify> i'm trying to bind opencv, or at least get one of the exsiting bindings to work
01:45:00 <tdammers> I've done that for phantomjs before (call JS from Haskell), and before that, I had an A* implementation in C++ that ran in its own process, driven from a Python frontend
01:45:03 <wedify> c2hs doesn't like it when headers include c++ headers
01:45:59 <wedify> so i'm going to try hoppy. i'm doing some by hand so i can understand what's going on
01:46:56 <wedify> fun fun fun
01:57:46 <root____5> hi
02:02:36 <wedify> hi
02:03:07 <Insanity_> Hey
02:07:51 <Xnuk> hi
02:33:50 <alfredo> wedify didn't read the whole conversation, but are you aware of this project? https://github.com/LumiGuide/haskell-opencv it binds OpenCV 3.1 and it's used in production at LumiGuide
02:34:45 <alfredo> under the hood it uses inline-c and inline-c-cpp. Talking to the 2 main maintainers (the Dijk brothers) they told me had great success with inline-c-cpp 
02:41:41 <wedify> heh heh, that's like 4 bindings to opencv that i know of now
02:46:50 <Forlorn> how can I take 20 terms of the fibonacci series in haskell?
02:47:25 <Forlorn> can I make an infinite series from my function definition?
02:48:30 <liste> :t iterate
02:48:31 <lambdabot> (a -> a) -> a -> [a]
02:48:41 <liste> > iterate (+1) 0
02:48:43 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:48:48 <alfredo> wedify hehe, at least this ones though are 1. Well maintained (are used in production) 2. Well documented 3. modern, so pick you poison ;)
02:49:09 <lyxia> > take 20 $ fix (\fib -> 0 : 1 : zipWith (+) fib (tail fib))
02:49:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
02:50:45 <lyxia> Forlorn: ^ ?
02:53:06 <NickHu> Is a corecursive definition really the best thing to give to a beginner? ;)
02:55:51 <wedify> 'import "base" Control.Concurrent.MVar' is valid syntax? since when? i assume it means it's importing from the base package
02:57:05 <peddie> wedify: {-# LANGUAGE PackageImports #-} or so
02:59:18 <Forlorn> fibSeq = iterate (\x -> (fib (x + 1))) 0
02:59:18 <Forlorn> why won't this work?
02:59:18 <merijn> Forlorn: What is "fib"?
02:59:18 <Forlorn> fib n = fib (n - 2) + fib (n - 1)
02:59:19 <Forlorn> fib 0 = fib 1 = 1
02:59:19 <peddie> Forlorn: 'iterate' applies the function you give it as an argument to the previous result of applying it
02:59:22 <liste> Forlorn: seems you want map and [1..] instead of iterate
02:59:43 <liste> > map (*2) [1..]
02:59:44 <Forlorn> ah that is true
02:59:45 <Forlorn> sorry
02:59:46 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
02:59:50 <Forlorn> also thanks
03:00:37 <NickHu> Can you really do definitions like fib 0 = fib 1 = 1?
03:00:45 <wedify> no
03:01:07 <Forlorn> didn't want to spam
03:01:23 <ertesx> people should always write the boring definition of 'fibs'
03:01:51 <Forlorn> it is really slow, perhaps I need to write a more fun version of fibs
03:01:53 <peddie> > map fst $ iterate (\(o,t) -> (o + t, o)) (0, 1)
03:01:56 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:02:42 <NickHu> Forlorn: If you want a more efficient definition of fibonacci, consider the function twoFibs :: Int -> (Int, Int)
03:03:05 <NickHu> Where twoFibs n gives you the nth fib and the n+1th fib in a tuple
03:03:40 <ertesx> if you want an efficient fibs, write it in the most boring manner possible
03:03:47 <ertesx> peddie just wrote it
03:04:30 <ertesx> here is another one:
03:04:30 <ertesx> > let fibs x y = x : fibs y (x + y) in fibs 0 1
03:04:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:04:34 * peddie wonders whether anyone, in the history of the world, has actually needed an efficient fibs
03:04:58 <ertesx> if they have, they probably just used the formula =)
03:05:48 <Cale> peddie: Sometimes it shows up in data structure implementations
03:06:00 <Cale> But I don't know about the infinite list versions
03:06:28 <peddie> Cale: oh, fibonacci heaps etc. -- but surely the limiting factor is not the computation of the sizes :)
03:06:56 <ertesx> this one computes the 10000000th fibonacci number in a few milliseconds: https://github.com/esoeylemez/snippets/blob/master/FibNF.hs
03:09:46 <ertesx> and 'signum' has a bug that i hadn't noticed =)
03:10:08 <peddie> ertesx: wow, I just looked up the formula that's based on . . . that is mega cool
03:13:59 <Forlorn> wasn't there a mathematical identity to the fibonacci sequence
03:13:59 <Forlorn> oh, well, peddie's answer is what I'll use, thanks
03:14:00 <NickHu> Forlorn: Yeah, it's called Binet's formula
03:14:01 <NickHu> But you can approximate it by rounding something like (1 + sqrt(5))^n/2 or something
03:14:21 <ertesx> or you can use my code to get an exact answer =)
03:14:38 <wedify> so i've produced an object file of my c-wrapper but ld can't find it. i've used a command like 'ghc --make test.hs -optl -L. -lvideo'
03:14:58 <wedify> any ideas on why it's not being found?
03:15:40 <ertesx> NickHu: FibNF uses an actual number field instead of approximating sqrt 5
03:17:35 <NickHu> ertesx: Ooh, fancy
03:18:04 <NickHu> But there's a really teaching point from twoFibs to tail recursion
03:18:05 * hackagebot terminal-progress-bar 0.1.0 - A simple progress bar in the terminal  https://hackage.haskell.org/package/terminal-progress-bar-0.1.0 (RoelVanDijk)
03:18:07 * hackagebot basic-prelude 0.6.1 - An enhanced core prelude; a common foundation for alternate preludes.  https://hackage.haskell.org/package/basic-prelude-0.6.1 (MichaelSnoyman)
03:18:12 <NickHu> really cool teaching point*
03:18:43 <ertesx> NickHu: yeah, fibs has a lot of education value with the many ways to implement it
03:19:18 <NickHu> Are number fields the way our fast prime number generators work?
03:19:19 <ertesx> however, one shouldn't use 'fix'
03:19:38 <NickHu> Why not? I need to learn more about fix
03:19:52 <ertesx> NickHu: no, they use sieving together with a probabilistic test like miller-rabin or baillie-PSW
03:20:28 <NickHu> btw incase you guys haven't seen it, nearly relevant: http://www.willamette.edu/~fruehr/haskell/evolution.html
03:21:35 <ertesx> NickHu: you can use fix as a tool as a haskell programmer, but you probably shouldn't use 'fix' when teaching, unless you are actually teaching 'fix'
03:21:42 <ertesx> (or you have taught it before)
03:22:27 <NickHu> Mm, it never came up in my functional programming course
03:22:55 <peddie> ertesx: I think that was someone else 
03:23:17 <lyxia> that was me using fix
03:23:24 <ertesx> peddie: yeah, "you" is a bit ambiguous, but "one" sounds so formal =)
03:23:39 <peddie> ertesx: righto, gotcha :)
03:53:36 <pavonia> Are the Hackage account requests processed manually? Because it says "we will be unwilling to add Kittenlover97 to the package uploader group"
04:01:19 <Cale> pavonia: Yes, I believe they are
04:02:44 <pavonia> Cale: Do you know how long it takes for the request to be accepted then?
04:03:04 <NickHu> pavonia: I just registered and was accepted immediately
04:03:22 <NickHu> There wasn't even a stage of "waiting for account approval"
04:03:38 <pavonia> Ah great, thanks
04:18:06 * hackagebot fsnotify-conduit 0.1.0.0 - Get filesystem notifications as a stream of events  https://hackage.haskell.org/package/fsnotify-conduit-0.1.0.0 (MichaelSnoyman)
04:22:14 <nathyong> Hey all, I've got a state monad tracking some data type holding my state, and this is fine and all
04:22:44 <nathyong> but sometimes I want to track some extra metadata on top of this, and I was trying to use a state monad transformer
04:23:19 <nathyong> but the transformer causes functions written for the inner state monad to need lifting
04:24:01 <nathyong> is there a solution to this issue that allows me to use my old functions with the transformed monad?  Something like deriving for the inner state
04:24:11 <nathyong> I'm not sure if mtl solves this problem since it's two layers of state
04:24:33 <tdammers> stacking multiple MonadStates on top of each other isn't very nice
04:25:01 <tdammers> but, do you actually need state, or will read-only context be enough?
04:25:17 <tdammers> if so, try ReaderT, or just pass context around as an extra argument
04:25:42 <nathyong> At the moment I think I might be able to get away with a WriterT, but I'm worried I'll need something more powerful down the track mostly
04:26:10 <nathyong> I guess I could track it as an extra argument, true
04:26:14 <tdammers> well, if you need to manipulate two states in concert, then you have to either lift, or consolidate both states into a combined type and build a state monad on that
04:26:43 <tdammers> with the latter approach, tastefully applying typeclasses can make your life a bit easier
04:26:43 <nathyong> yeah, I'd rather not have to build a new datatype for adding state layers every time
04:27:11 <tdammers> it's a bit unfortunate Haskell doesn't have anonymous record types (or extensible records, depending which way you squint)
04:28:23 <nathyong> I guess I could implement a custom transformer and give it the mtl instances to pass through the state layer, though
04:28:25 <nathyong> would that work?
04:28:42 <tdammers> just making a new data type for your combined state would be easier, I guess
04:29:24 <tdammers> also, I believe if you use lenses, you can use tuples as a poor man's ad-hoc record type
04:29:44 <nathyong> the main reason I'm leaning against that is that I'm inheriting a large amount of boilerplate code for modifying the old data type that was tracked by state, and I'd rather not re-implement every function
04:29:50 <tdammers> i.e., make your state monad something like State (Foo, Bar)
04:29:57 <nathyong> that could work
04:29:59 <nathyong> _1 and _2
04:30:03 <tdammers> and then with lenses, you can just compose _1 or _2 in as needed
04:30:05 <tdammers> exactly
04:30:28 <tdammers> but then, switching to a proper lensified record type wouldn't be a lot of extra hassle either, and it'd make the thing more readable
04:30:47 <tdammers> data CombinedState = CombinedState { _foo :: Foo, _bar :: Bar }
04:30:57 <tdammers> and then you compose foo and bar in instead of _1 and _2
04:31:13 <nathyong> but I'd still need to add _foo to every existing function that works on the Foo state, right?
04:31:38 <nathyong> Or am I able to derive MonadState CombinedState => MonadState Foo?
04:31:46 <nathyong> (or implement said instance)
04:31:54 <tdammers> you can of course implement the instance
04:32:03 <tdammers> not sure if it can be derived
04:32:16 <nathyong> that might be the easiest method
04:32:41 <tdammers> but if you lensify your CombinedState type, and use lens operators to modify the state (which, btw., is pretty nifty), you can just compose foo and bar into the relevant lenses and it'll work fine
04:33:29 <nathyong> hmm, okay
04:33:34 <tdammers> so where you would have written, say, fooCounter %= succ, you can now write foo . fooCounter %= succ
04:34:10 <nathyong> Ah, I see
04:34:24 <nathyong> so that works if succ :: Foo -> Foo or whatever
04:34:36 <nathyong> I've got a bunch of functions succ :: State Foo
04:34:40 <nathyong> (in that format)
04:34:45 <nathyong> do the lenses still compose?
04:39:58 <tdammers> just an example
04:40:04 <tdammers> succ is (+ 1)
04:40:12 <tdammers> generalized to arbitrary enums
04:40:14 <tdammers> > succ 23
04:40:17 <lambdabot>  24
04:40:17 <tdammers> > succ 1
04:40:20 <lambdabot>  2
04:40:20 <tdammers> > succ False
04:40:22 <lambdabot>  True
04:40:47 <tdammers> imagine data Foo = Foo { _fooCounter :: Int, ... }
04:41:02 <tdammers> and then lensified so that fooCounter is a Lens Foo Foo Int Int
04:41:31 <nathyong> mhm
04:51:21 <nathyong> tdammers: okay, looks like I'll go with a merged implementation with lenses; thanks so much for your help at this hour!
04:57:59 <chenyu> hello
05:00:53 <liste> hi chenyu 
05:02:51 <nathyong> chenyu: what's up?
05:06:14 <nathyong> hmm, speaking of monad transformers, extending ExceptT is annoying
05:06:37 <nathyong> ideally you'd like to extend the monad wrapped by ExceptT if you're using it to catch your errors
05:16:31 * TheToastedOne waves
05:18:07 * hackagebot servant-subscriber 0.5.0.2 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.5.0.2 (eskimo)
05:26:46 <Insanity_> I'm not sure what I should be looking for here. Something akin to 'takeWhile' I think
05:26:53 <cheater> hi
05:27:00 <Insanity_> I want to take values from a list, until the last taken value / by length of the list is a certain value
05:27:12 <Insanity_> 'x / length (xs)'.. kind of. 
05:27:15 * TheToastedOne waves
05:27:28 <alercah> Insanity_: you might need to write a custom fold for that I think
05:27:31 <cheater> could someone link me up to the paper that defined the term "programming on the left side"? i can't find it. i believe this paper was what defined pattern matching.
05:27:53 <Insanity_> Thanks alercah, I'll take a look into that
05:28:21 <TheToastedOne> https://www.haskell.org/tutorial/patterns.html - is that what you're looking for?
05:30:09 <cheater> i'm looking for the original paper.
05:35:32 <ocramz> hi all
05:35:32 <mrm> So, I decided to use an experimental number theory class as an excuse to finally get around to learning haskell, and one minor thing I'm impressed by is that I still haven't had to write a single type annotation yet.
05:39:40 <mrm> I mean f : N -> N probably isn't that hard to infer, but it's still pretty nice.
05:40:44 <fizbin> Hey, what could cause a program that should be CPU bound (it does only a tiny bit of IO at the beginning) to instead give a "time" result like "real 27m46.462s" / "user 6m54.746s" / "sys 5m54.857s" ?
05:41:07 <fizbin> Could truly horrid memory use result in that?
05:41:54 <ocramz> fizbin: it depends. Can you post a gist?
05:42:21 <fizbin> Of the whole program? No, it's huge and proprietary.
05:42:42 <fizbin> I know from profiling that it spends nearly all its time in pure code.
05:42:53 <ocramz> eh, then it's hard to help you here. But yes, piling up thunks and all that
05:43:15 <ocramz> do you profile memory use?
05:44:09 <fizbin> I did, but with different input. I guess I'll go through it with this input too, though given that it takes 27 minutes with profiling compiled out, I may be at this a while.
05:45:13 <ocramz> what's the application?
05:45:18 <cocreature> fizbin: maybe you just have a high load on your system? real is not the time your program was scheduled but the actual time between when it was started and when it tetrminated
05:45:53 <fizbin> It's optimizing a complicated DFA.
05:48:24 <cocreature> fizbin: I don’t think memory can really cause these numbers. the actual allocation from the os should be in sys and memory accesses end up in user afaik
05:50:13 <cocreature> I guess if you swap it could be this way
05:50:40 <fizbin> cocreature: That's what I'd thought too, but I think the latest OSX might be doing something weird with compressed memory. What I'll see while watching this program in "top" is that it runs with 99%+ of the CPU for maybe ten minutes, then drops down to ~5% for the rest of the time.
05:51:26 <cocreature> fizbin: maybe throw perf at it? (iirc os x has perf)
05:51:40 <fizbin> The "CMPRS" column in top is relatively small right now in the use-all-the-CPU stage, but I think it balloons during the "use almost no CPU" time.
05:52:58 <cocreature> if your program has 27minute runtime you really don’t want to use rts profiling
05:53:25 <cocreature> so either become a perf wizard (you can include haskell symbols if you compile with -g) or find a smaller testcase
05:53:41 <cocreature> or just stare at your code really long but that’s usually not very productive :)
05:55:52 <balac> @pl (\x->[x])
05:55:52 <lambdabot> return
05:56:29 <liste> :t (: [])
05:56:31 <lambdabot> a -> [a]
05:57:19 <Grisha> hi everyone
05:57:53 <buglebudabey> hello
05:57:54 <ongy> hi
05:57:58 <Grisha> could please someone give me reading pointers to the following problem: I've got a type constructor with two variables smth like data Type a b = ...
05:58:25 <Grisha> and then I do the following trick: type TypeInt = Type Int
05:58:32 <Grisha> a partially applied type constructor
05:58:37 <Cale> okay
05:58:53 <Grisha> it seems to get compiled by the ghc, but I don't understand why and what happens under the hood
05:59:49 <Cale> Grisha: Well, type functions are curried just like all other functions
05:59:54 <Cale> :k Either
05:59:55 <lambdabot> * -> * -> *
05:59:57 <Cale> :k Either String
05:59:59 <lambdabot> * -> *
06:00:02 <Cale> :k Either String Int
06:00:04 <lambdabot> *
06:00:59 <Grisha> and what does ``type'' do with those? Can I think of it just as of a substitution rule for types?
06:01:11 <Cale> Yeah, type just defines aliases
06:01:21 <Grisha> each time I use TypeInt, it automagically gets converted into ``Type Int''?
06:01:26 <Cale> You can imagine that the first thing a compiler might do is just unfold all the type aliases
06:01:28 <Cale> yep
06:01:42 <Grisha> okay
06:01:43 <Grisha> I see
06:02:09 <Grisha> probably the first time when my intuition coincided with what actually goes on inside ghc ;-)
06:02:15 <Grisha> Cale thanks a lot
06:03:09 <Grisha> I'm playing with Repa arrays and building a type hierarchy  by partially applying Array type constructor
06:05:46 <Cale> cool, yeah, repa uses a fair amount of fancy types as I recall
06:06:22 <Grisha> being a total newbie, I was terrified by the Repa tutorial at first ;-)
06:06:30 <Grisha> shapes, shmapes, unboxed - what the hell?
06:12:48 <intothem2untains> :: Maybe String -> IO () that will print Just string and do nothing if Nothing?
06:13:27 <intothem2untains> <$> and >>= need the monad constraints to be the same (right?)
06:13:38 <phadej> no
06:13:44 <phadej> they have different type
06:13:49 <intothem2untains> :t (<$>)
06:13:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:14:00 <intothem2untains> :t (>>=)
06:14:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:14:37 <Grisha> :t fromMaybe
06:14:39 <lambdabot> a -> Maybe a -> a
06:14:41 <intothem2untains> In this last one, for what I want to do, m is Maybe in the first argument and IO in the second
06:15:37 <intothem2untains> Grisha: how would that help?
06:16:15 <ongy> :t fmap putStr (Nothing :: Maybe String)
06:16:17 <lambdabot> Maybe (IO ())
06:16:56 <Grisha> intothem2untains, I thought about printing an empty string for Nothing
06:17:31 <intothem2untains> ongy: I still try to get my head around the definition of fmap
06:17:52 <Grisha> :t putStr
06:17:53 <lambdabot> String -> IO ()
06:18:23 <Grisha> ongy, that's brilliant ;-) I still need some time to recognize such patterns
06:19:04 <Grisha> intothem2untains, within Maybe, you want to replace your String with IO ()
06:19:13 <Grisha> Maybe is a functor too
06:19:55 <Grisha> to replace things within a functor, you use fmap
06:20:46 <ongy> so if you combine the 2 things we said:
06:20:57 <ongy> :t fromMaybe (return ()) . fmap putStr
06:20:59 <lambdabot> Maybe String -> IO ()
06:22:11 <Grisha> that took an interesting turn
06:23:41 <ongy> is there a way to check with language extensions lambdabot has activated?
06:25:18 <ertes> intothem2untains: mapM_ putStrLn
06:25:33 <ertes> :t mapM_ putStrLn :: Maybe String -> IO ()
06:25:35 <lambdabot> Maybe String -> IO ()
06:26:46 <Grisha> :t mapM_
06:26:48 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
06:27:18 <ertes> alternatively:  traverse putStrLn
06:27:38 <ertes> uhm…  traverse_
06:27:47 <ertes> :t traverse_ putStrLn
06:27:48 <lambdabot> Foldable t => t String -> IO ()
06:27:54 <ertes> huh?
06:27:59 <ertes> oh, sure
06:28:33 <cheater> does anyone know what the original paper was that defined pattern matching?
06:30:32 <intothem2untains> :t traverse_
06:30:33 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
06:31:31 <intothem2untains> ertes: would traverse_ not print each letter on one line?
06:32:22 <intothem2untains> Apparently not
06:32:30 <buglebudabey> cheater, you could look into some of haskell's intermediate languages like Core or STG
06:32:34 <intothem2untains> I still have trouble understanding ongy's solution :S
06:32:55 <cheater> why would i do that? i'm looking for a paper
06:33:15 <ertes> intothem2untains: f = Maybe
06:33:19 <ertes> not f = []
06:33:26 <Grisha> intothem2untains, do you understand fromMaybe?
06:33:31 <buglebudabey> cheater are you wondering how pattern matching is implemented?
06:33:40 <intothem2untains> Grisha: yep
06:33:42 <[k-> ongy: This could be it: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/Pristine.hs.default (I don't know though, but this looks awfully close)
06:33:48 <cheater> no i'm looking for the original paper that defines it, the implementation is completely unrelated
06:34:03 <ertes> intothem2untains: in ongy's solution fmap maps over Maybe
06:34:11 <ertes> so the string, if it's there, turns into an action
06:34:12 <Grisha> intothem2untains, so what you want to do is to put an IO action within a Maybe
06:34:25 <ertes> fromMaybe extracts that action from the Maybe with a default action, if none is there
06:34:48 <ertes> fmap putStrLn :: Maybe String -> Maybe (IO ())
06:35:02 <ertes> fromMaybe (pure ()) :: Maybe (IO ()) -> IO ()
06:35:26 <ertes> therefore: fromMaybe (pure ()) . fmap putStrLn :: Maybe String -> IO ()
06:35:38 <buglebudabey> cheater if you're talking about pattern matching in haskell's context they are related
06:36:00 <intothem2untains> ertes: so (pure ()) is the default action?
06:36:06 <ertes> intothem2untains: yeah
06:36:29 <intothem2untains> ertes: so what is function composition doing there?
06:36:29 <cheater> i really don't want to talk about pattern matching in haskell. i'm looking for a specific paper.
06:36:33 <ertes> intothem2untains: i'm using the word "default" for "the result in case the argument is Nothing"
06:36:34 <mnoonan> cheater: if you're talking pattern matching in general, maybe some of the early lisp papers? though I don't see it in the earliest one (http://www-formal.stanford.edu/jmc/recursive.pdf)
06:36:46 <ertes> intothem2untains: it's composing the two functions =)
06:37:03 <intothem2untains> which ones? fmap and putStrLn?
06:37:04 <cheater> i remember it was called something like "programming on the left hand side"
06:37:23 <intothem2untains> oooooh
06:37:25 <intothem2untains> now I see
06:37:40 <intothem2untains> fromMaybe (pure ()) and fmap putStrLn are the composed ones
06:37:43 <intothem2untains> (right?)
06:37:47 <ertes> intothem2untains: correct
06:37:55 <intothem2untains> I still have problems with precedence
06:38:41 <ertes> intothem2untains: just keep this in mind: function application has the highest precedence, and that can't be overridden
06:38:54 <ertes> (there is one exception, but it doesn't really matter here)
06:38:56 <ongy> ah, Traversable instance of Maybe. Does it exist for exactly that?
06:39:04 <ertes> ongy: Foldable actually
06:39:11 <ertes> > sum (Just 5)
06:39:13 <lambdabot>  5
06:39:24 <ongy> :t mapM_
06:39:26 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
06:39:44 <intothem2untains> ertes: if function application has the higher precedence, why doesn't it try to apply . as an argument to fromMaybe?
06:39:47 <ertes> since the Foldable-Traversable-Proposal many base functions have suddenly become a lot more useful =)
06:39:48 <ongy> > sum Nothing
06:39:50 <lambdabot>  0
06:40:18 <ertes> intothem2untains: because haskell has infix syntax for functions with symbolic names
06:40:26 <liste> > sum (1,2)
06:40:28 <lambdabot>  2
06:40:37 <liste> (:
06:40:50 <ertes> intothem2untains: so (f x . g y) is always read as ((.) (f x) (g y))
06:41:06 <phadej> liste: but otoh
06:41:07 <intothem2untains> so infix has higher precedence than function application?
06:41:10 <phadej> > traverse Just (1, 2)
06:41:12 <lambdabot>  Just (1,2)
06:41:19 <ertes> intothem2untains: nope, function application has the highest precedence
06:41:42 <ertes> intothem2untains: otherwise you would get something weird like: (f (x . g) y)
06:42:08 <phadej> > traverse (Just . (+1)) (1, 2)
06:42:10 <lambdabot>  Just (1,3)
06:42:35 <intothem2untains> ertes: ooohkay
06:43:43 <ertes> intothem2untains: you can imagine an invisible operator ($$) between functions and arguments, and that one has the highest precedence:  f x . g y = f $$ x . g $$ y = (f $$ x) . (g $$ y)
06:44:26 <ertes> (you can't define that operator in haskell, because there is no way to declare the precedence that application has – that's intentional)
06:47:38 <ongy> int-e: is there a reason lambdabot does not use -XLambdaCase? Is it worth creating an issue/PR?
06:50:11 <intothem2untains> ertes: yes, my trouble was with not identifying . as the most outter function
06:50:16 <intothem2untains> thank you!
07:01:45 <chenyu> :t ($$)
07:01:46 <lambdabot> Doc -> Doc -> Doc
07:04:20 <Gurkenglas> In the Maybe Hask kleisli category, Void is both the initial and terminal object. Is Maybe a universal object in that property?
07:12:58 <lingxiao> hey all
07:13:21 <lingxiao> is there an example of non-commutatitive, associative algebra with identity   
07:15:18 <MarcelineVQ> function composition
07:15:37 <lingxiao> oh right ... i guess i meant a typeclass
07:15:47 <lingxiao> that i dont have to declare just for my project
07:17:57 <ahihi> Monoid? or am I missing something?
07:18:09 * hackagebot ogmarkup 3.0.0 - A lightweight markup language for story writers  https://hackage.haskell.org/package/ogmarkup-3.0.0 (lethom)
07:18:11 * hackagebot colonnade 0.4.5 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/colonnade-0.4.5 (andrewthad)
07:18:13 * hackagebot ansigraph 0.3.0.0 - Terminal-based graphing via ANSI and Unicode  https://hackage.haskell.org/package/ansigraph-0.3.0.0 (Cliff_Harvey)
07:20:29 <lingxiao> monoid is commutatitve i think
07:20:39 <phadej> it isn't
07:20:47 <phadej> > [1] <> [2]
07:20:49 <lambdabot>  [1,2]
07:20:53 <phadej> > [2] <> [1]
07:20:55 <lambdabot>  [2,1]
07:21:18 <phadej> "commutative monoid" is commutative :)
07:21:58 <lingxiao> i'm sorry ?  
07:22:02 <lingxiao> oh i see right 
07:22:06 <lingxiao> thanks 
07:22:35 <fr33domlover> Q: I have 'data D m' and I want to write a Default instance for it, but just for the case where (MonadIO m) so that I can use IO actions in the instance definition. Is this the way to do it: instance MonadIO m => Default (D m) where ...
07:22:45 <Forlorn> is it possible to write 1e20?
07:22:51 <Forlorn> without spelling it out?
07:23:00 <ahihi> > 1e20
07:23:02 <lambdabot>  1.0e20
07:23:09 <Forlorn> oh, thanks
07:23:11 <fr33domlover> @type 1e20
07:23:13 <lambdabot> Fractional t => t
07:23:24 <ertes> fr33domlover: yeah
07:23:46 <Cale> fr33domlover: yes
07:23:56 <fr33domlover> ertes, Cale, thanks :-)
07:23:57 <Cale> oh, ertes already answered :)
07:24:10 <ertes> fr33domlover: you may want to check first if you can make (D m) a monoid, because mempty is a more principled 'def'
07:25:01 <fr33domlover> ertes, D is sort of a ConnectionSettings type, not sure it should be a monoid
07:25:07 <Forlorn> you can't have it as an int?
07:25:15 <Forlorn> Integer*
07:25:29 <fr33domlover> @type (1e20 :: Integer)
07:25:30 <lambdabot> error:
07:25:30 <lambdabot>     • No instance for (Fractional Integer)
07:25:31 <lambdabot>         arising from the literal ‘1e20’
07:25:36 <fr33domlover> Forlorn, ^
07:25:47 <ongy> > 1e-10
07:25:49 <lambdabot>  1.0e-10
07:25:58 <fr33domlover> Forlorn, you can probably use TH if you really really really want :P
07:25:59 <ertes> > 10^20
07:26:01 <lambdabot>  100000000000000000000
07:26:30 <fr33domlover> ertes, would GHC optimize out the (^) ?
07:26:36 <ertes> unlikely
07:26:42 <c_wraith> fr33domlover: there's an extension that allows exponential notation in integral literals
07:26:50 <fr33domlover> Forlorn, ^
07:27:12 <c_wraith> something like.. DecimalIntegers?
07:27:14 <ertes> but (^) is efficient, so it doesn't hurt to compute it once
07:27:55 <Insanity_> is (**) more efficient when you already have floats? 
07:28:08 <Insanity_> :t (**)
07:28:09 <lambdabot> Floating a => a -> a -> a
07:28:10 <ertes> Insanity_: likely
07:28:30 <c_wraith> Doesn't ** go directly to a hardware instruction?
07:28:41 <ertes> it does on x86 and x86_64
07:29:06 <c_wraith> That's..  most things ghc targets.
07:29:45 <c_wraith> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#fractional-looking-integer-literals
07:29:53 <ertes> > shiftL (5^20) 20
07:29:55 <lambdabot>  100000000000000000000
07:30:10 <c_wraith> NumDecimals is the name of the extension
07:30:26 <ertes> oh, nice
07:31:11 <c_wraith> 7.8 is longer than I realized it's been around.
07:48:03 <cheater> mnoonan: i wasn't able to find the paper in question
07:48:07 <cheater> thanks for the link though
07:52:49 <Forlorn> myiteration (\(i, x) -> if x > 3 then return i else continue ) [1,2,3,4,5]
07:52:59 <Forlorn> can I do something like this? ^ pseudo-code
07:54:13 <Forlorn> for(var i = 0; i < arr.length; i++){  if(arr[i] > 3) return i; }
07:55:48 <Insanity_> You want to just return the first one?
07:56:21 <Insanity_> > [x | x <- [1..5], x > 3]
07:56:23 <lambdabot>  [4,5]
07:56:26 <Forlorn> Yeah, I want to return the index of the first one that is above > 3
07:56:41 <Insanity_> oh I'm sorry I misunderstood you
07:56:45 <lyxia> foldr (\(i, x) continue -> if x > 3 then Just i else continue) Nothing $ zip [0 ..] [0, 11, 22, 33, 44]
07:56:49 <lyxia> > foldr (\(i, x) continue -> if x > 3 then Just i else continue) Nothing $ zip [0 ..] [0, 11, 22, 33, 44]
07:56:51 <Forlorn> oh, nvm that works
07:56:52 <lambdabot>  Just 1
07:57:01 <lyxia> > foldr (\(i, x) continue -> if x > 3 then Just i else continue) Nothing $ zip [0 ..] [0, 1, 2]
07:57:03 <lambdabot>  Nothing
07:57:22 <mnoonan> cheater: no problem. that title you mentioned did sound familiar, but I can't think of what exactly it was (or the contents of the paper, really)
07:57:27 <Forlorn> Insanity_, thanks
07:57:42 <lyxia> Forlorn: also, findIndex
07:58:05 <Insanity_> Forlorn, mine would only work if the array is exactly like that, not if it is random
07:58:10 <Insanity_> [1,3,5] for example
07:58:17 <ski> > findIndex (> 3) [1,3,5]
07:58:19 <lambdabot>  Just 2
08:01:45 <NickHu> Is there any way to get ghc profiling to give me a max alloc stat? It gives me total alloc, which tells me how much memory was allocated over the lifetime of the application, but I'm interested in the maximum usage
08:02:52 <Forlorn> Insanity_, [x | x <- iterate (+1) 0, x < 4]
08:03:00 <Forlorn> can I make this stop after 3 ?
08:03:18 <Insanity_> after three elements?
08:03:22 <Insanity_> > take 3 [x | x <- iterate (+1) 0, x < 4]
08:03:24 <lambdabot>  [0,1,2]
08:03:39 <Forlorn> oh, but the number 3 is unknown to us
08:03:40 <Insanity_> or until the element is three
08:03:47 <Insanity_> > takeWhile (<=3) [x | x <- iterate (+1) 0, x < 4]
08:03:53 <lambdabot>  mueval-core: Time limit exceeded
08:03:57 <[k-> NickHu iirc it could be -xc or -s
08:03:57 <Forlorn> x < 4 after this is no longer satisified it should stop
08:06:11 <Forlorn> oh, takeWhile (<3) (iterate (+1) 0)
08:06:18 <Forlorn> that was what I needed, thanks again
08:06:28 <cheater> what if love is dead
08:06:31 <Insanity_> np
08:06:41 <Forlorn> :)
08:06:46 <cheater> your code will have a bug
08:06:57 <Forlorn> because of love?
08:06:59 <Forlorn> ^^
08:07:08 <cheater> because of lack of it.
08:07:11 <[k-> NickHu: correction, -xc is for printing stack traces on error
08:08:41 <[k-> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
08:08:59 <Forlorn> http://sprunge.us/ZAXa
08:09:01 <Forlorn> any good?
08:09:17 <nitrix> Is there a reliable network library that nicely detects when a socket is closed rather than reading 0 bytes?
08:09:22 <cheater> @type takeWhile
08:09:23 <lambdabot> (a -> Bool) -> [a] -> [a]
08:09:31 <Forlorn> https://projecteuler.net/problem=2
08:09:35 <Forlorn> for this problem
08:10:53 <darwin226> Hey guys, how do I convert UTCTime to a UNIX timestamp?
08:11:08 <EvanR> theres a function for that
08:11:18 <darwin226> I can't seem to find it
08:11:23 <EvanR> UTCTime -> PosixTime
08:11:34 <EvanR> utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
08:11:42 <kadoban> Forlorn: A pretty direct translation of the problem would likely be better. Make a list, fibs, of all fibonacci numbers, in sorted order. Use 'filter' to get the even valued ones, and takeWhile to get the ones small enough, sum that.
08:12:07 <EvanR> Data.Time.Clock.POSIX
08:12:50 <ski>   Prelude> [x | x <- iterate (+1) 0, then takeWhile by x <= 3]
08:12:52 <ski>   [0,1,2,3]
08:12:54 <ski> Forlorn ^
08:12:56 <darwin226> Is the show instance for that type appropriate for, for example, endpoints that expect the unix timestamp sent to them?
08:13:14 <Forlorn> kadoban, oh, it was hell discovering this even fibonacci sequence though, lol
08:13:20 <ski> Forlorn : you'll need to enable the extension `TransformListComp' for that
08:14:00 <kadoban> Forlorn: Which suggests it won't be too great for readers of it either, hehe.
08:14:14 <EvanR> darwin226: the posix time type is a NominalDiffTime which is just a number (a Pico), you can format it however you want
08:14:33 <EvanR> i dont know any really standard way to display that except as just the integer number of seconds
08:14:34 <kadoban> Why would you need extensions for a pretty basic problem? I don't see the benefit of that syntax anyway.
08:14:59 <darwin226> EvanR: Hmm, I guess that's what they want then. Thank you
08:15:34 <ski> kadoban : just an alternative way to do it, which might feel nicer (in that it incorporates into list comprehension syntax)
08:16:47 <kadoban> ski: I've been doing haskell for quite a long time and I've never seen that syntax, which unless I'm just uniquely uninformed, suggests a lot of other people won't know what that does either (except by guessing).
08:16:56 <NickHu> Is there a guide to which types of haskell vector I should be using?
08:17:22 <ski> kadoban : more reason to make it more familar, then ?
08:17:59 <kadoban> ski: More reason to not use it, certainly when the more familiar syntax is fine, I'd say.
08:18:02 <ski> Forlorn : `\(xs, x) -> xs' is `fst'
08:18:51 <Forlorn> ski, what do you mean?
08:19:04 <ski> @pl \(xs, x) -> xs
08:19:04 <lambdabot> fst
08:19:13 <ski> Forlorn : i mean you could replace one by the other
08:19:43 <ski> kadoban : i don't dispute the other suggestion being just fine here. but i don't see why one should strive not to use something, just because it's not well known
08:20:28 <kadoban> ski: Being less well known is a bad thing for readability and maintainability, right? So, what benefit does it have to counteract that problem?
08:20:29 <ski> (certainly, if it's used very seldom, the chance of it becoming well known will be bleak)
08:21:31 <lingxiao> hey all
08:21:43 <lingxiao> suppose i have a tokenizer and compiler
08:21:53 <lingxiao> what should foo be named?  foo = compiler . tokenizer
08:22:02 <lingxiao> foo :: String -> Parser
08:22:06 <ski> being less well known isn't an intrinsic property. imo, it should be judged on its intrinsic virtues (or lack thereof), not on the extrinsic ones. if it has merit in itself, then it deserves to be *made* well known
08:22:25 <ski> (whether that's the case here, i'm not sure. but i don't want to preclude it beforehand)
08:25:08 <ski> (in fact, i think some aspects of how `TransformListComp' currently works to be less desirable .. but i think that's something fixable. also the concrete syntax could be debated. but given that we can already express several important classes of list transformations entirely within a list comprehension, i think it's (potentially) nice to enlargen that class to include more common cases, so that one can treat them on an equal footing to the other constructs 
08:25:20 <ski> (er, cut off near ".., i think it's (potentially) nice to enlargen that class to include more common cases, so that one can treat them on an equal footing to the other constructs of the "list comprehension" minilanguage)")
08:34:17 <dmj> is there a mutate in-place for vector? modify seems to be returning a new vector
08:34:32 <c_wraith> only for mutable vectors 
08:35:08 <c_wraith> ie, look at modules with Mutable in their name somewhere 
08:35:35 <EvanR> the type IOVector for example has this
08:36:00 <EvanR> i found th module stuff for that stuff kind of unintuitive
08:36:03 <dmj> aw dang it
08:36:05 <EvanR> module docs
08:36:51 <dmj> 90% of what I'm doing is comparing immutable vectors and creating IO () actions. There is only one place where I need to mutate an immutable vector inplace, the freeze / thaw dance returns a new vector though... looks like everything has to be mutable then
08:36:59 <c_wraith> dmj, there are easy operations to covert between mutable and immutable vectors. they're the freeze/thaw operations. 
08:37:08 <ph88> hey guys, does someone know a function to get an instance of Arbitrary that generates nothing?  https://hackage.haskell.org/package/QuickCheck-2.9.1/docs/Test-QuickCheck.html
08:37:58 <ph88> actually .. i want it to always generate the same thing .. so not really generate
08:38:07 <c_wraith> dmj, well, depends. do you really *need* the same vector in those rare occasions (like the vector is shared between threads?) 
08:38:07 <ph88> because it's more or less a constant in my program
08:38:12 <bartavelle> ph88, arbitrary = pure (your thing)
08:38:16 <kadoban> ph88: pure whatever, yeah
08:39:19 <dmj> c_wraith: in this case it's a single threaded situation, the vectors run in an FRP loop and are GC'd immediately. A new one is created, compared to the old one, IO () actions produced, the new one becomes the old one, the cycle cycles
08:39:33 <dmj> I want like
08:39:45 <ph88> can i let arbitrary take a parameter ?
08:39:45 <dmj> modify :: (forall s. MVector s a -> ST s ()) -> Vector a -> IO () :) 
08:40:00 <ph88> so i can choose which pure thing i want
08:40:25 <ertes> dmj: use a mutable vector without exposing it
08:40:45 <dmj> c_wraith: can I get away with it if it's not shared? It seems like it uses clone...
08:40:47 <kadoban> ph88: Well, 'arbitrary' itself can't, but maybe there's some other way to do what you need to?
08:40:48 <c_wraith> dmj, lots of things break if you violate immutability :) 
08:41:16 <ph88> kadoban, i don't know, is there ? :/
08:41:32 <kadoban> ph88: Heh, well what's the goal? Like how would you be using this?
08:41:46 <bartavelle> ph88, you can newtype :/
08:42:09 <bartavelle> ph88, but you can also define a plain function in the Gen monad and use this instead of arbitrary where you need variance
08:42:24 <ertes> dmj: how much of the vector do you modify?
08:43:05 <fizbin> Well, this isn't good: Productivity   2.6% of total user, 1.4% of total elapsed
08:43:17 <dmj> c_wraith: it seems like we could unsafeThaw to a mutable vector, mutate it, then unsafeCopy back onto the original vector
08:43:26 <dmj> ertes: length of the vector is preserved
08:43:35 <ertes> dmj: but how much do you modify?
08:43:47 <dmj> ertes: just swapping element order
08:43:57 <c_wraith> dmj, only if you're 100% certain laziness will never keep a reference to the old vector around. 
08:43:58 <ertes> dmj: how many?
08:43:59 <dmj> ertes: that depends on how the first vector differs from the next
08:44:11 <dmj> ertes: potentially swapping every element if it was reversed
08:44:26 <c_wraith> dmj, if it does, you have a time bomb that can explode in many mysterious ways
08:44:43 <ph88> kadoban, bartavelle this is what i intend to do  https://paste.fedoraproject.org/423963/33494411/  this code does not compile though
08:44:47 <ertes> dmj: if you modify most of the original vector (swapping is modifying two elements, as far as vectors are concerned), don't bother and just copy immutable vectors
08:44:58 <c_wraith> dmj, what's the concern with allocating a new vector? 
08:44:58 <ertes> dmj: there is a backPermute function, i think, that should help you with this
08:45:04 <bartavelle> ph88, sorry I gtg :(
08:45:25 <ph88> np bartavelle see you next time !
08:46:21 <dmj> c_wraith: allocations should be minimal. everything should be done in-place. All comparisons done by the immutable vectors just iterate over them, never mutating, until now.
08:46:31 <ertes> dmj: from my own experience: don't use unsafeThaw/unsafeFreeze…  they tend to explode by leaking effects across frames in subtle ways
08:47:26 <c_wraith> ertes, unsafeFreeze is OK. it's easy to be sure you're using it correctly. unsafeThaw, on the other hand, is a recipe for disaster 
08:47:43 <ph88> kadoban, do you think i should not make an Arbitrary instance for Terminal .. but instead define my own seperate function that returns a Gen ?
08:47:51 <kadoban> ph88: Just hardcode [Version1] into the arbitrary instance?
08:47:58 <dmj> ertes: so if we copy vectors in this way I assume fusion can remove the intermediate vectors produce assuming the lengths stay the same
08:48:01 <ertes> c_wraith: once you have frames, unsafeFreeze is also a problem…  remember that values can survive frames in FRP
08:48:20 <ertes> dmj: sometimes, not always
08:48:34 <dmj> ertes: this FRP uses WeakRefs and they get finalized on each iteration (iirc)
08:48:50 <kadoban> ph88: It's quite possible that it shouldn't be an Arbitrary instance. I'm not really clear from this code snippet. Brb though
08:48:54 <ph88> kadoban, in the future Version2 has to be added, and the code under test might work differently
08:49:09 <ph88> i mean depending on which version it is
08:49:21 <c_wraith> ertes, I just mean you can syntactically verify that the code modifying a vector is all run before you unsafeFreeze it. 
08:49:54 <c_wraith> ertes, obviously, you shouldn't use it in situations where you can't verify that. 
08:49:58 <ejbs> is this not valid Haskell?   let cs = if profileType p1 == DNA then nucleotides else aminoacids
08:50:14 <ejbs> (so essentially let x = if y then z else a)
08:50:25 <ertes> c_wraith: this case seems to be one of them…  i had a similar case:  a ring buffer for average computation
08:50:35 <dmj> c_wraith, ertes: the problem is like, because of this one requirement, I'm forced to rewrite all my immutable code as mutable. I guess this is why the Generic interface was made ;)
08:50:35 <kadoban> ph88: Well, I mean you could make it really arbitrary, and later it'll be one of however many versions you have, would that be a problem? Any tests that care can filter out Terminals that are the wrong version (using (==>) or whatever it is), or just build their own Terminal
08:50:42 <ski> ejbs : `let' requires an `in', except inside `do', list comprehensions and the interactor
08:50:44 <c_wraith> ejbs, depends on context. if it's an expression, it's incomplete 
08:51:02 <ejbs> ski: c_wraith: I missed the in!
08:51:05 <ertes> dmj: i'd go with immutable vectors
08:51:18 <ertes> dmj: or make sure the vector itself doesn't leak
08:51:48 <ertes> in some cases you can maintain a mutable vector as internal/local state, but never actually expose it
08:51:54 <ski> ejbs : fwiw, it may be clearer&nicer to use a `case' instead here
08:52:11 <ski> ejbs : in place of the `if'-`then'-`else', i mean
08:52:57 <ertes> dmj: of course the ideal solution would be to make noise on GHC trac to add linear/uniqueness types =)
08:52:57 <ejbs> ski: That's true
08:52:59 <kadoban> ph88: Your tests should ... rule out behavior that's broken, regardless of what changes. If you have a particular thing you're planning on changing/adding later, write the tests such that they are expected to handle that correctly. I might be missing something though.
08:54:12 <ertes> i really envy Clean for that
08:55:15 <ejbs> So if I wanna mappend by using bind, how do I do that exactly?
08:55:41 <ejbs> (I have a map (lambda map ...) call and I want to flatten the inner map)
08:55:45 <ejbs> Oh wait that's called flatMap
08:56:48 <ph88> kadoban, i'm talking about generating valid input data. The data structure is depending on the context so i can not just generate a random Version which i want. For the moment i will try it like this  https://paste.fedoraproject.org/423972/35013014/
08:58:14 <ejbs> Okay. Is flatMap/mappend readily available for Lists in Haskell?
08:58:44 <ejbs> Ok it type checked with fmap, sorry for all the spam :(
08:59:16 <fizbin> @t concatMap
08:59:16 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
08:59:53 <ejbs> Oh fmapis just map but general for functors
09:00:01 <ejbs> fizbin: concatMap, got it
09:00:14 <fizbin> @type concatMap
09:00:15 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
09:00:20 <Forlorn> argh
09:00:21 <Forlorn> [x | x <- primes, 21 `mod` x == 0, x <= 21]
09:00:40 <Forlorn> I am getting the same problem again, it gets stuck, any ideas?
09:01:26 <fizbin> ejbs: But I'll also note that in such situations a list comprehension expression is often easier code to write and to read later.
09:01:53 <fizbin> Forlorn: You need a way to tell haskell to stop scanning down primes once it gets larger than 21
09:02:32 <Forlorn> [x | x <- takeWhile (<=21) primes, 21 `mod` x == 0, x <= 21] ?
09:02:56 <fizbin> Yeah. Except now, you don't need the last clause because it's redundant
09:03:15 <Forlorn> yay, yeah, noticed
09:03:16 <Forlorn> :)
09:03:24 <Forlorn> thanks
09:03:46 <[k-> why would the first not work?
09:04:26 <fizbin> [k- The problem is that primes is either an infinite or very, very, very long list.
09:04:49 <[k-> ahh
09:06:43 <ertes> Forlorn: in particular note:
09:06:47 <ph88> why is it actually that when i use  pure  it becomes a non-pure value ?
09:06:51 <ertes> > filter even (repeat 3)
09:06:57 <lambdabot>  mueval-core: Time limit exceeded
09:07:02 <ph88> or is it just to indicate you want to use a  pure value ?
09:07:16 <ertes> Forlorn: you might think that's the empty list, but it's really an infinite loop
09:07:34 <Forlorn> Oh, nice thanks ertes.
09:08:04 <ertes> Forlorn: do you see why?
09:08:40 <dkasak> ph88, in what sense does it become a non-pure value?
09:08:46 <Forlorn> Hmm, it would be nice if whenever it finds a prime it should divide 21, such that when 21 / 7 / 3 = 1 it stops and doesn't go all the way up to 21
09:08:49 <Forlorn> ertes, yeah
09:09:12 <ph88> dkasak, that it's wrapped by the monad now
09:09:34 <ertes> Forlorn: are you trying to write a function for factoring?
09:09:43 <Forlorn> yes
09:10:09 <dkasak> ph88, it's wrong to consider monadic values as "unpure". They're just values like any other.
09:10:23 <ph88> i don't think so
09:10:36 <ertes> Forlorn: you can write a function of type (Integer -> Maybe (Integer, Integer)) that returns a prime factor and the remaining number
09:10:37 <Forlorn> ertes, it factored the long 600851475143
09:10:45 <phadej> is `Just 'a'` pure or unpure?
09:10:49 <ertes> Forlorn: then you can use that function together with 'unfoldr'
09:10:55 <Forlorn> but it continues searching even though it has found all the factors
09:11:11 <dkasak> ph88, that said, you can consider `pure 4` as being the monadic value that simply gives you `4` when bound, without any other effects.
09:11:22 <phadej> is `putStrLn "foo"` pure or unpure
09:11:31 <Forlorn> ertes, oh, I see
09:11:36 <phadej> philosophical...
09:12:53 <ertes> Forlorn: this is not the most efficient way to do trial division, but don't worry…  once you have this done, you can easily make it more efficient without destroying the unfoldr pattern
09:12:55 <ski> phadej : depends on POV ..
09:13:32 <ski> ph88 : i basically agree with dkasak
09:14:33 <ertes> Forlorn: your function needs to work like this:  factor1 210 = Just (2, 105)  -- return the smallest factor in the left component, remaining composite in the right
09:14:44 <ertes> Forlorn: with this special case:  factor1 1 = Nothing
09:15:02 <jonored> saddest part of the monads for IO thing is that people need IO enough that they end up conflating the two too much when monads in general are just not that weird :)
09:15:37 <ph88> i understand that these types are wrong  https://paste.fedoraproject.org/423981/47335126/   but i'm not sure if i *want* the expected type or the actual type (so change the type or change the expectation) .. anyone an idea?  this is related to QuickCheck
09:15:55 <orion> jonored: Is there a better solution?
09:16:28 <jonored> orion: I wasn't saying that I had a better solution, merely lamenting the constraints we've got.
09:16:41 <orion> I see.
09:18:11 * jonored is generally of the opinion that maybe, list, and maybe state are better to start understanding monads by, and easier to get that there's nothing rule-breaking about them, than IO.
09:18:11 * hackagebot glirc 2.15 - Console IRC client  https://hackage.haskell.org/package/glirc-2.15 (EricMertens)
09:19:01 <prsteele> I agreed with jonored, writing out a chain of Maybes without the monad or applicative instance is what got me to understand it
09:19:45 <dkasak> jonored, agreed. I think a large part of the confusion is that you can't inspect IO values easily, other than by interpreting them, but by then they have already been given preferential treatment by the runtime system so they seem special even on the language level.
09:19:50 <ARM9> and just breaking the illusion that monads are somehow related to IO which a lot of misinformation around the web would have you believe
09:20:51 <ertes> not sure if there is any benefit in treating IO specially…  i'd say the opposite
09:21:10 <dmj> ertes: Mutable.Generic lacks forM_ :(
09:21:38 <ertes> in order to help make monads click you probably need to see that both Maybe and IO are monads, despite being semantically rather unrelated
09:21:57 <ertes> dmj: yeah, the mutable interface is terrible
09:22:04 <ertes> s/terrible/minimalistic/
09:23:07 <ongy> the Maybe monad instance is quite nice. The weirdest monad to me is still List
09:23:15 <ph88> be back later
09:23:36 <prsteele> I just think of the List instance being cross products
09:23:40 <dmj> ertes: yea, recursion makes it a bit onerous to work with. Immutable is quite nice /and/ efficient
09:24:36 <ertes> dmj: there is one other solution: if you do bulk updates in subslices of the vector, you can use a rope to make this efficient *and* pure
09:24:37 <jonored> Recognizing that list comprehensions and do notation are almost identical makes List's monad instance really understandable to me.
09:24:59 <ertes> dmj: currently the easiest way to construct a rope of vectors is to use the fingertree package
09:25:06 <ertes> (as far as i know)
09:26:16 <ertes> dmj: a rope of vectors is basically just Seq, but it can use vectors for subsequences: https://en.wikipedia.org/wiki/Rope_(data_structure)
09:26:51 <ertes> dfeuer: just in time…  do you think there is a way to expose a more generic Seq that makes the fingertree package obsolete?
09:27:02 <dfeuer> ertes, no, I do not.
09:27:51 <dfeuer> ertes, in particular, polymorphism comes with extra indirection and extra allocation. Data.Sequence is not at all likely to eat that.
09:28:04 <ertes> i see
09:43:32 <dmj> ertes: so, if you had to, given mutate :: V.Vector -> IO (), and argument = V.fromList [1]. How would you mutate the immutable vector in place :)
09:46:14 <ertes> dmj: not sure what you mean
09:49:33 <dmj> ertes: this effect
09:50:14 <dmj> do { let a = V.fromList [1] in mutate a; print a } -- shows [2]
09:50:36 <dmj> where mutate :: V.Vector Int -> IO ()
09:51:44 <jophish> Is it ever possible for ghc to inline something marked as NOINLINE
09:52:45 <dmj> ertes: w/o allocating additional vectors
10:00:35 <ertes> dmj: that's a type error, as far as i see
10:00:42 <ertes> dmj: or a side effect, which is even worse
10:02:51 <kalleklovn> hitler was great but misunderstood
10:02:59 <maerwald> O.o
10:04:00 <kalleklovn> imagine the hero he would be today if germany won the war
10:04:07 --- mode: ChanServ set +q *!*@51.174.19.26
10:04:40 <Welkin> kalleklovn: sounds like you want to watch/read The Man in the High Castle
10:04:44 <dmj> ertes: it's a side effect, yea
10:05:06 <maerwald> Welkin: I think that was a rather poor trolling attempt
10:05:21 <Welkin> I know
10:05:30 <ertes> dmj: i don't mean IO effect, but in fact side effect
10:05:36 <maerwald> and even for -offtopic, probably inappropriate
10:05:39 <ski> dmj : `a' looks out of scope ?
10:06:30 <ertes> dmj: the way you wrote it (ignoring the scope error) it's unsafe
10:08:11 <ski> dmj : "How would you mutate the immutable vector in place" -- i probably wouldn't
10:08:53 <dmj> ski: yea, that's the answer I assuming :/
10:09:11 <ertes> dmj: the way to get rid of temporary vectors is by stream fusion, but it doesn't cover *all* usage patterns
10:09:20 <ertes> dmj: the other way is to use a rope
10:09:31 <ski> dmj : one cold imagine `unsafeThaw'ing it, if one's *sure* that there's no other reference to it, and then use `writeIORef' or something to "export" the mutable result somewhere
10:10:06 <ski> however, i'd be very wary of assuming there's no other reference to it, especially in the presence of optimizations
10:11:05 <ski> (`mutate' would then have to close over an appropriate `IORef' to a referene cell holding a mutable vector)
10:14:12 <mizu_no_oto_work> dmj ski: There's also something like transients, for cheap conversion of mutable to immutable structures
10:14:37 <ski> i believe dmj wanted a conversion in the other direction ?
10:15:27 <mizu_no_oto_work> err, it goes both ways
10:15:58 <mizu_no_oto_work> edwardk was playing around with them at some point; I'm not sure if he's produced a usable library for them yet
10:16:34 <ski> package name being `transients' ?
10:17:49 <mizu_no_oto_work> looks like it
10:18:12 * hackagebot text-zipper 0.7 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.7 (JonathanDaugherty)
10:18:25 <ski> or `transient' ?
10:18:58 <mizu_no_oto_work> https://github.com/ekmett/transients
10:19:36 <ski> mhm, not hackage
10:19:40 <mizu_no_oto_work> yeah
10:20:57 <Forlorn> hmm
10:21:18 <Forlorn> a = b x y z
10:21:29 <Forlorn> b returns (k,l,m)
10:21:35 <Forlorn> but I only want k
10:21:46 <Forlorn> what to do?
10:22:06 <Forlorn> how do I deconstruct it?
10:22:10 <ongy> let (k, _, _) = b x y z
10:22:35 <Forlorn> a = let (k, _, _) = b x y z ?
10:22:50 <ARM9> let a@(k, _, _) = b x y z
10:22:59 <ongy> > let (k, _, _) = (1, 2, 3) in k
10:23:02 <lambdabot>  1
10:23:18 <mizu_no_oto_work> a = k where (k,_,_) = b x y z
10:24:15 <implementation> view _1 $ b x y z
10:24:23 <mizu_no_oto_work> > (1,2,3) ^. _1
10:24:25 <lambdabot>  1
10:24:50 <mizu_no_oto_work> Forlorn: there's also the lens, if you're using lens ^
10:25:15 <ARM9> somehow I get the feeling he's not using lens
10:25:27 <Forlorn> I am not using lens
10:25:29 <mizu_no_oto_work> Probably not, but it's worth mentioning
10:25:58 <Forlorn> thanks!
10:26:47 <ReinH> or case b x y z of (k, _, _) -> k
10:26:56 <ertes> Forlorn: you can pattern-match everywhere in haskell
10:27:11 <ertes> Forlorn: at no point are you forced to give a value a name just to deconstruct it again
10:28:11 <Forlorn> ertes, what do you mean by "giving the value a name"?
10:28:20 <ReinH> a = b x y z
10:28:29 <ertes> Forlorn: if you write "x = (1,2,3)", you're giving the value (1,2,3) the name x
10:28:29 <ReinH> gives the value (b x y z) the name a
10:28:52 <ertes> but you could just as well write "(x, y, _) = (1, 2, 3)"
10:29:11 <Forlorn> I probably need to learn more but here it is
10:29:12 <Forlorn> http://sprunge.us/FdEj
10:29:41 <implementation> there might even be a package somewhere on hackage that allows you to access the first element of any tuple using (car) ... (and the second using (cadr) and so on)
10:30:20 <avalokite> What was Forlorn's original question?
10:30:48 <Forlorn> how to deconstruct b
10:30:56 <implementation> found it https://hackage.haskell.org/package/acme-cadre-0.1/docs/Acme-Cadre.html
10:31:03 <Forlorn> and I used it to `factor m = f where (_, f, _) = (factor' m [] primes)`
10:31:16 <joe9> http://bpaste.net/show/156031b7b85c does this mean that it needs ghc 8?
10:32:02 <geekosaur> for that version of gloss-examples at least, yes
10:34:32 <Hi-Angel> I didn't know that GHC.Tuple has sooo many useful contructors https://hackage.haskell.org/package/ghc-prim-0.4.0.0/candidate/docs/GHC-Tuple.html
10:36:13 <joe9> geekosaur: Thanks.
10:36:58 <ongy> Hi-Angel: most things that define tuple instances don't go that far
10:37:04 <implementation> I always wanted to use (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) some day
10:37:30 <ongy> and irrc a friend of mine got ghc to crash with 15 element tuple
10:40:49 <ertes> Forlorn: note that your sieve is not a sieve =)
10:42:40 <orion> I wish HaLVM supported GHC 8.
10:43:41 <ertes> this one is a sieve: https://github.com/esoeylemez/snippets/blob/master/PurePrimeSieve.hs
10:47:29 <joe9> geekosaur: have you used gloss ? like it?
10:47:33 <umib0zu> ertes was someone looking for seives?
10:47:40 <geekosaur> I have not
10:50:22 <Welkin> umib0zu: show us your wares
10:51:45 <joe9> any gloss users here? any opinions or experiences? I want to render a realtime chart using openGL and gloss seems to make it easier
10:51:57 <Taneb> Can someone help me figure out why one of my tests is using so much memory?
10:52:04 <Taneb> https://gist.github.com/Taneb/8100945ecde0444640b45a730430f50d isTreeOrdered and the two tests that use it
10:52:29 <MarLinn> Hi-Angel: look at the source, it gets better ;)
10:53:48 <Hi-Angel> :D
10:55:47 <umib0zu> Welkin https://github.com/jfarid27/Project_Euler/blob/master/Proj3/Sieves.hs
10:55:55 <umib0zu> like this?
10:58:33 <dgirsh> I'm designing a simple interpreted language for testing real-time embedded systems. The control flow is severely restricted to provide strong static guarantees on what the scripts will do + how long they will run. For example, you can only branch on constant conditionals or loop over fixed ranges. There is a large existing codebase in C++ with relevant models and IO libs, so this language must be able to call into C++. Finally, the
10:58:33 <dgirsh> systems under test have hard timing requirements, so we can't tolerate much jitter in the test framework. Our past solution was a custom DSL embedded in the C++ runtime, but we ended up re-inventing too many wheels (parser, linter, interactive interpreter, etc..) to achieve the static guarantees we need. Haskell's facilities for crafting embedded DSLs with these guarantees are extremely appealing to me, but I'm stuck in determining how
10:58:33 <dgirsh> to embed it into the soft real-time C++ runtime. Pointers to any libraries / existing projects would be greatly appreciated!
10:59:16 <koala_man> if I have [[Char]], how do I get all Strings containing one character from each group? 
10:59:18 <ertes> i can see how one could make the mistake to call a naive prime filter a "sieve", but calling it "eratosthenes" is just trolling ;)
10:59:42 <lyxia> koala_man: sequence
11:00:01 <koala_man> nice, thanks
11:00:31 <Hi-Angel> Taneb: I didn't see anything from my limited experience, but did you try to benchmark it?
11:00:32 <byorgey> Taneb: my guess is that the problem is your Arbitrary instance.  It is probably generating some ridiculously huge Treaps.
11:00:47 <Taneb> byorgey, isHeapOrdered works fine
11:01:56 <Taneb> Hi-Angel, I'm trying to run it with profiling enabled now
11:02:46 <mpickering> Is there a well used Nat type, or a function which performs subtraction but never returns a value less than 0?
11:03:05 <dmwit> :t \x -> max 0 . subtract x
11:03:07 <lambdabot> (Ord c, Num c) => c -> c -> c
11:03:17 <Taneb> mpickering, there's Numeric.Natural but that was only introduced relatively recently in base
11:03:27 <Taneb> byorgey, if it is the Arbitrary instance, how would I mitigate that?
11:03:27 <Hi-Angel> dgirsh: it's actually an interesting question. I'd recommend to ask it on stackoverflow.
11:03:40 <byorgey> Taneb: rightheap = case l of ...  <- should that say  case r of ?
11:04:14 <byorgey> Taneb: use http://hackage.haskell.org/package/generic%2Drandom
11:04:21 <dmwit> mpickering, Taneb: Natural throws Underflow for negative results. Up to you whether that's acceptable or not.
11:04:41 <Taneb> byorgey, oh you're right! That is embarrassing :(
11:04:54 <mpickering> no, not really thanks dmwit 
11:04:58 <byorgey> Taneb: oh, never mind, you need some constraints
11:05:12 <mpickering> Not sure how that moved into base with partial instances..
11:05:40 <mizu_no_oto_work> dgirish: You might find https://www.infoq.com/presentations/automated-testing interesting, though it doesn't directly answer your question.
11:06:00 <byorgey> Taneb: if you're still stuck later I can try to help more, but gotta run to class now, sorry
11:06:19 <ertes> dgirsh: note that haskell has no C++ FFI, so if you need to bind to C++, you'll most likely create a C wrapper first
11:07:33 <Hi-Angel> ertes: well, C++ does only differ from C by mangled names, I don't think it's impossible to call that mess of symbols.
11:07:42 <geekosaur> sadly, that isn't true
11:07:59 <geekosaur> you can demangle names, sure, and some languages have FFIs that do so. then you run into templates
11:08:34 <dmwit> dgirsh: You might like fficxx
11:08:45 <dmwit> ?hackage fficxx
11:08:45 <lambdabot> http://hackage.haskell.org/package/fficxx
11:08:55 <MarLinn> I think I remember seeing some tool that was meant to facilitate haskell/c++ interop... something in the context of qt bindings... If only I would remember more...
11:08:59 <mizu_no_oto_work> dgirsh: Sigma, over at Facebook, has Haskell code sandwitched inbetween 2 layers of C++: https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
11:09:13 <geekosaur> (and templates are a Hard Problem because you might end up trying to instantiate one at runtime)
11:09:19 <ertes> Hi-Angel: there are a lot of things that simply have no name to begin with (templates), and the calling convention can be different (exceptions)
11:09:53 <ertes> in fact just like haskell C++ needs a run-time system
11:10:24 <phadej> ertes: not necessarily
11:11:37 <mauke> geekosaur: templates are fancy cpp. they don't exist at runtime
11:12:09 <geekosaur> that's exactly the problem
11:12:24 <geekosaur> this does not stop someone from trying to FFI to what they think is a "function"
11:12:43 <geekosaur> (but is actually a macro because template)
11:12:46 <MarLinn> dgirsh: Here's yet another tool: http://khumba.net/projects/hoppy/
11:14:20 <mauke> oh, yeah. I agree
11:14:24 <geekosaur> (someone actually did that shortly after perl6 NativeCall announced c++ support, and was rather perplexed as to why it failed)
11:15:21 <dgirsh> dmwit mizu_no_oto_work MarLinn:  Lookin into fficxx, Sigma, and hoppy. Thanks! 
11:16:26 * dfeuer offers geekosaur a chocolate chip cookie.
11:17:24 <mizu_no_oto_work> dgirsh: You might find https://www.infoq.com/presentations/automated-testing interesting, though it doesn't directly answer your question.  Essentially, the creator of quickcheck has used it to test stateful embedded systems in automobiles, with rather good results.
11:18:13 * hackagebot aeson-compat 0.3.5.2 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.5.2 (phadej)
11:18:57 <routerl> talk
11:19:20 <dfeuer> Does anyone have a sense of how a ITraversable class traversing a type-aligned sequence using a McBride-style indexed monad would compare in power to my IxTraversable class traversing one with an Atkey-style applicative?
11:19:32 <mizu_no_oto_work> digirsh: See also  http://www.quviq.com/
11:19:57 <mizu_no_oto_work> dgirsh, rather
11:21:21 <dfeuer> The Atkey-style traversable is sufficient to implement McBride-style maps over the type-aligned sequence, and also folding to Categories... what's the monadic one get? Is every Atkey-style traversable also McBridey traversable?
11:30:32 <Taneb> byorgey, changing my Arbitrary instance to generate smaller Treaps worked like a charm, thanks :)
11:35:43 <the_2nd> what is the second in last operator there? the "opening arrow" https://raw.githubusercontent.com/i-tu/Hasklig/master/hasklig_example.png
11:38:06 <ski> the_2nd : which line ?
11:38:15 <the_2nd> last line
11:38:17 <the_2nd> -<
11:38:46 <ski> that's the last operator, not the second to last operator
11:38:57 <ski> it's used in `proc' notation (arrows)
11:39:05 <the_2nd> my bad, meant "symbol"
11:39:59 <ski> the_2nd : <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation>
11:41:25 <ski> the_2nd : however .. the whole snippet shown looks more or less incoherent, to me
11:42:58 <the_2nd> ski, thanks
11:43:37 --- mode: ChanServ set -q *!*@51.174.19.26
11:53:19 <black0range> Why is mappend on functions not the same as normal function composition?
11:55:11 <ertes> black0range: there is Endo, if you want that
11:55:25 <johnw> and it only works for functions of type a -> a, not a -> b
11:55:50 <ertes> black0range: but for composing parametric things Category is usually a better idea
11:56:13 <black0range> Yes, just wondering why :) 
11:56:40 <dmwit> black0range: Any Applicative induces a Monoid with `mempty = pure mempty` and `mappend = liftA2 mappend`.
11:56:55 <dmwit> black0range: In particular, the `(e ->)` Applicative uses this implementation.
11:57:22 <dmwit> So it is nicely uniform in that sense.
11:57:32 <joe9> In this module, I am trying to figure out how to read data from an IO ref or Chan http://hackage.haskell.org/package/gloss-1.10.2.3/docs/Graphics-Gloss.html#v:display . The "play" function has an argument and type called world. Can I assume that "world = IO <data read from an IORef or TChan" ?
11:58:37 <dmwit> joe9: I suspect that won't work well, given that you also need to supply a `world -> Picture` function.
11:59:02 <black0range> dmwit: ty 
11:59:13 <dmwit> joe9: Indeed, I suspect gloss as a whole won't work well if your update functions need to do `IO`.
11:59:18 <hpc> joe9: gloss has separate IO-y versions of its run functions
11:59:25 <hpc> but they aren't the default import
11:59:49 <hpc> see Graphics.Gloss.Interface.IO.(the thing you want to use)
11:59:52 <dmwit> Oh, indeed it does. Nice.
11:59:58 <hpc> http://hackage.haskell.org/package/gloss-1.10.2.3/docs/Graphics-Gloss-Interface-IO-Display.html
12:00:34 <joe9> http://bpaste.net/show/a57f19dcfb2e this is not possible correct . I would need a function that does this: (IO Int -> Picture)
12:00:54 <joe9> hpc, Thanks.
12:01:09 <dmwit> "not possible" is so strong.
12:01:22 <dmwit> But yes, it's probably not what you want.
12:02:01 <joe9> hpc:  have you used gloss? I find that Cairo rendering with gtk slows down considerably when the data set reaches 1k points.
12:02:32 <joe9> hpc, not sure if gloss can do better. I hear that OpenGL can easily do 100K points.
12:02:33 <hpc> i have, it definitely has issues with complex scenes
12:02:54 <hpc> that's not really down to any backend thing though, it's just the way gloss is designed
12:03:09 <hpc> it uses GLUT and opengl on the backend
12:03:24 <joe9> hpc: https://github.com/joe9/baby-steps-to-building-a-realtime-chart-with-haskell/tree/master/app is what I tried.
12:03:30 <hpc> with a compiler flag to make it use GLFW (which when i tried it didn't work)
12:03:46 <ski> @where monoids
12:03:46 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
12:03:47 <lambdabot> instance Monoid a => Monoid (rho -> a)'
12:03:52 <ski> black0range : seen that ^ yet ?
12:03:54 <bizarrefish> Hi all
12:04:18 <joe9> hpc, any thoughts on how gloss performs?
12:04:43 <joe9> hpc, i am new to opengl stuff and read that glfw is the later version and better
12:05:00 <hpc> gloss is effectively a software renderer
12:05:33 <hpc> glfw replaces glut as the thing that creates the window and sets up the UI context and such
12:05:57 <hpc> both glfw and glut give you an opengl context to do rendering with
12:06:09 <joe9> hpc, also stumbled upon this: http://hackage.haskell.org/package/graphics-drawingcombinators-1.5.1
12:06:36 <joe9> hpc, not sure if it is any better or worse than gloss. gloss had more examples and docs, hence, want to try it first.
12:06:42 <hpc> gloss also is unable to unload resources, once you tell it to load a texture it's in memory forever
12:06:58 <joe9> hpc, oh, that is a memory leak, correct?
12:07:05 <hpc> sort of
12:07:29 <hpc> what you're supposed to do is load all your resources at the start and never generate any dynamic textures or anything like that
12:07:37 <hpc> it's very limited in what you can do with it
12:07:53 <hpc> but for learning and making something simple like tetris, it's perfect
12:08:46 <joe9> hpc, any library you recommend for a realtime opengl (glfw) chart ?
12:08:52 <hpc> it hides a ton of ugly details behind very high-level not-quite-perfect definitions that are easy to use
12:09:11 <hpc> i don't really know enough about graphing to give a good recommendation
12:14:02 <joe9> hpc, fair enough, any library you recommend for realtime opengl (glfw) drawings?
12:14:50 <joe9> hpc, I am looking for a decent updated opengl library so I can use it as a starting point if gloss does not work for me.
12:16:15 <joe9> hpc, any recommendations, please? something you liked?
12:21:29 <ReinH> @hackage gl
12:21:29 <lambdabot> http://hackage.haskell.org/package/gl
12:24:02 <joe9> ReinH: Thanks.
12:36:30 <nitrix> Hi.
12:37:03 <nitrix> How am I supposed to use stack to compile a project that needs network-2.6.3.1 on windows?
12:37:31 <nitrix> It's getting stuck on some missing tools to run ./configure. I'm using the Haskell Platform afaik
12:38:22 <byorgey> Taneb: great =)
12:39:44 <drw_> I have a Servant service and a Reflex-dom client.  I'm able to generate a javascript client of the service and call it with the client, but there is no typed responce this way--just JSON.  I'd like to write client calls in haskell and compile then in the reflex-dom client, but when I referenc the model types, I have to reference all the server-side libraries as well (in this case, I'm struggling with Acid-state).
12:42:05 <nitrix> Nevermind.
12:42:07 <nitrix> https://github.com/commercialhaskell/stack/pull/2552
12:42:22 <nitrix> It has been solved 3 days ago :) I'll obtain stack master then :)
13:13:00 <soLucien> hi guys ! I want to set some variables in my files, and i keep getting a parseError .. Here's what i'm doing at the end of my file: https://gist.github.com/s0lucien/08c85d4b6d04f8df07417d92f1f251cf
13:13:25 <soLucien> i've first defined the types, the data
13:13:34 <Gal3rielol> hi, how do I make the function errorWithStackTrace works
13:13:40 <soLucien> and now i want to instantiate few of them
13:14:05 <Gal3rielol> it only prints the error msg but without stack
13:14:48 <verement> soLucien: try removing 'let'
13:16:53 <ongy> int-e: is lambdabot on twitch irc?
13:17:04 <ongy> if not, how hard would it be?
13:18:09 <TommyC> ongy: I don't believe it is. It would not be too hard.
13:18:15 * hackagebot ansigraph 0.3.0.1 - Terminal-based graphing via ANSI and Unicode  https://hackage.haskell.org/package/ansigraph-0.3.0.1 (Cliff_Harvey)
13:19:31 <M41px[m]> hello, Is it be possible to avoid the overlapping of "case" in sessionFromRedis function? Or it's the right way to use? https://github.com/41px/session/blob/master/Main.hs
13:20:40 <geekosaur> you can pattern match as deeply as you need to
13:20:51 <geekosaur> Right (Just sessionjs) -> ...
13:20:57 <amalloy> case session of (Right (Just s)) -> ...
13:21:23 <erisco> Right (Just s) ->
13:21:58 <amalloy> right, i still forget you don't need the outer parens in case like you do in a function definition
13:23:30 <camargo_> Hello!
13:23:47 <joe9> hpc, do you know how to get the width and height of the window when using gloss? The examples seem to be hardcoding them instead of reading them from the window
13:24:11 <M41px[m]> Ok thx all
13:24:32 <joe9> https://github.com/joe9/baby-steps-to-building-a-realtime-chart-with-haskell/blob/master/app/Step025Gloss.hs line 60 hpc.
13:25:19 <camargo_> That moment when you need to unzip files and everything you search about zipping and unzipping with Haskell does refer to tuples.
13:27:44 <ertes> camargo_: add "archive"
13:29:32 <t0by> :)
13:29:53 <camargo_> Yay. Codec.Archive.Zip might solve!
13:30:06 <t0by> camargo_, https://hackage.haskell.org/package/zip-archive ? 
13:30:09 <t0by> 'xactly.
13:31:11 <codedmart> Is there a better way to solve this other then using `IncoherentInstances`? https://gist.github.com/codedmart/fb955f357e49e2341568237313d96cef?
13:32:20 <erisco> can we see the class and instances as well?
13:32:55 <codedmart> erisco: Was that directed at me?
13:32:59 <erisco> yes
13:33:39 <codedmart> erisco: Database.RethinkDB.Datum is from the rethinkdb package. Let me find the link to them.
13:35:27 <codedmart> erisco: https://github.com/AtnNn/haskell-rethinkdb/blob/master/Database/RethinkDB/Datum.hs#L68 and https://github.com/AtnNn/haskell-rethinkdb/blob/master/Database/RethinkDB/Datum.hs#L166
13:40:39 <Guest32351> hi! I have some questions I'd love you could help me with
13:41:49 <glguy> Guest32351: Go ahead and ask them. For continuity between visits it's best if you could pick a more identifiable nickname than Guest32351.
13:42:51 <Guest32351> I'll just post them and see if anyone is up to answer (sorry if I'm not speaking politely but English is not my native language, I'll try my best)
13:42:53 <erisco> codedmart, this seems problematic from conception. Why treat lists one way but lists of characters another?
13:43:13 <Guest32351> Ok, I will change my username
13:45:10 <bvaldivielso> Ok, it's me, Guest32351, I "changed" my username (I don't really know how to use IRC properly)
13:45:56 <geekosaur> usually just /nick whatever
13:46:29 <bvaldivielso> I would like to know how much intuition one can get with this monads thing (or well, with any similar abstraction)
13:47:20 <codedmart> erisco: OK thanks for looking. I will look into that.
13:47:22 <erisco> each line is a statement, <- is assignment … that kind of intuition?
13:48:02 <bvaldivielso> I kind of get them now (I know I have a lot to learn yet) but every time I see a function that takes a monad as a parameter have to spend some time thinking of what that function does to every instance of the monad typeclass
13:48:42 <bvaldivielso> erisco not like that, I think I'm pretty comfortable with the do syntax already
13:48:47 <geekosaur> with experience, plenty. but it's not the kind if abstraction people are accustomed to working with, so it takes a while to develop an intuition that some data structure is a monad
13:49:13 <erisco> if you care about properties outside the monad laws then you necessarily have to consider the specific monad instance
13:49:22 <erisco> so this is a natural thing to do
13:49:29 <geekosaur> even, as in your case, when you know the Monad instance exists but you don't know how the type fits the instance
13:50:10 <bvaldivielso> I see
13:50:58 <erisco> the benefit in that case is merely that you have one definition for all monads
13:51:09 <bvaldivielso> and can you easily see when some type has some implicit monadic structure?
13:51:54 <johnw> bvaldivielso: often you'll find yourself thinking "I wish I could just compose these functions without doing all this housekeeping on the side..."
13:52:06 <johnw> if you can then abstract the housekeeping, Monad becomes your friend
13:52:12 <erisco> that a type can have a Monad instance? no, there is no general way to find this
13:53:05 <bvaldivielso> ok cool
13:53:18 <bvaldivielso> and regarding library and api design
13:53:21 <erisco> the instance is not necessarily unique either
13:53:43 <sm> all haskellers use predefined monads, but I think probably only a minotiry of haskellers invent new ones
13:53:53 <erisco> Functor on the other hand is unique and can be derived by the compiler
13:54:09 <bvaldivielso> how could I learn what constitutes a good haskell design and what doesn't ?
13:54:27 <johnw> time, experience
13:54:31 <johnw> making mistakes
13:54:34 <bvaldivielso> erisco that's awesome, I hadn't even thought of this
13:54:46 <sm> and if you can get it to compile, it's probably reasonable 
13:54:53 <bvaldivielso> (the uniqueness of the functor instance)
13:56:05 <bvaldivielso> thank you all guys/gals, those are some interesting answers
13:56:30 <bvaldivielso> I started doing the NICTA course and I thought it was really useful
13:56:44 <bvaldivielso> what do you think of it? https://github.com/NICTA/course
13:57:16 <erisco> bvaldivielso, I recommend conal's lectures on denotational design as a methodology for good functional programming
13:57:46 <erisco> this one I found particularly accessible https://www.youtube.com/watch?v=bmKYiUOEo2A
13:58:47 <bvaldivielso> erisco cool, I'll take a look at it
13:59:01 <soLucien> what should i do if i want to select a value in a tuple ?
13:59:13 <soLucien> as a generic value
13:59:16 <erisco> soLucien, what do you mean by select?
13:59:16 <dibblego> bvaldivielso: are you in Australia?
13:59:20 <soLucien> i have this (bbox c )(Point (-1.0,-1.0),Point (1.0,1.0))
13:59:37 <bvaldivielso> dibblego no, I'm in Spain
13:59:43 <soLucien> i want to access the first Point's X and the second Point's X and add them up
13:59:55 <dibblego> bvaldivielso: ok, will try to run NICTA/course in Spain some time :)
14:00:46 <bvaldivielso> dibblego I'm not sure I understand what you mean
14:01:00 <erisco> getX . uncurry (+)  something like this soLucien
14:01:22 <dibblego> bvaldivielso: NICTA/course is regularly run in-person, and is being run in Sydney and Canberra this year.
14:02:45 <erisco> er, make that curry (+)
14:02:54 <bvaldivielso> dibblego ah ok, I see
14:02:59 <erisco> no wait… uncurry… to curry or to uncurry, that is the question
14:03:24 <soLucien> so wait . I have a function bbox that returns a (Point, Point)
14:03:54 <soLucien> they are the corners of a rectangle
14:04:07 <soLucien> i want to find the width and haight from it
14:04:19 <soLucien> (trying to be more specific about the use case)
14:04:52 <soLucien> so the width is the right-top corner's x - the bot-left corner's x
14:05:03 <soLucien> this bbox represents these 2 points
14:05:12 <erisco> uncurry (-)   then gives you a Point with width and height magnitudes as first and second component
14:05:32 <erisco> abs . uncurry (-)    something like this … I am presuming you have a Num instance
14:05:40 <soLucien> double
14:05:44 <soLucien> okay, i will look at uncurry
14:05:49 <erisco> double what?
14:06:25 <soLucien> the point
14:06:32 <soLucien> the point X and Y are doubles
14:06:39 <soLucien> so it
14:06:44 <erisco> I am saying a Num instance for Point
14:06:57 <soLucien> Point is (Double, Double)
14:07:25 <erisco> then newtype it :)
14:08:22 <erisco> or write the Num instance for  (Num a, Num b) => Num (a, b)
14:08:26 <erisco> > (1, 2) + (3, 4)
14:08:29 <lambdabot>  error:
14:08:29 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M792001828318...
14:08:29 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
14:08:38 <erisco> > (1, 2) + (3, 4) :: (Int, Int)
14:08:40 <lambdabot>  error:
14:08:40 <lambdabot>      • No instance for (Num (Int, Int)) arising from a use of ‘+’
14:08:40 <lambdabot>      • In the expression: (1, 2) + (3, 4) :: (Int, Int)
14:10:21 <conal> erisco: thanks for the denotational design plug. i'm glad that video worked for you.
14:12:46 <dmwit> ?let (<<*>>) = (Data.Biapplicative.<<*>>)
14:12:48 <lambdabot>  .L.hs:156:11: error:
14:12:48 <lambdabot>      Not in scope: ‘Data.Biapplicative.<<*>>’
14:12:48 <lambdabot>      No module named ‘Data.Biapplicative’ is imported.
14:13:13 <bvaldivielso> another question: this time on how I should structure my libraries
14:13:28 <dmwit> > let (<<*>>) = (Data.Biapplicative.<<*>>) in ((+), (+)) <<*>> (1, 2) <<*>> (3, 4)
14:13:31 <lambdabot>  error:
14:13:31 <lambdabot>      Not in scope: ‘Data.Biapplicative.<<*>>’
14:13:31 <lambdabot>      No module named ‘Data.Biapplicative’ is imported.
14:13:46 <dmwit> Okay. Well :t liked it well enough. =P
14:13:46 <bvaldivielso> I have seen that it's almost a convention to "publish" both your public interface and your .Internal
14:13:59 <dmwit> bvaldivielso: Yep. Consenting adults and all that.
14:14:05 <mniip> @let import Data.Biapplicative
14:14:07 <lambdabot>  Defined.
14:14:21 <dmwit> > bipure (+) <<*>> (1, 2) <<*>> (3, 4)
14:14:24 <lambdabot>  error:
14:14:24 <lambdabot>      • Couldn't match expected type ‘(Integer -> Integer -> b,
14:14:24 <lambdabot>                                       Integer -> Integer -> d)’
14:14:46 <bvaldivielso> and I should use this .Internal thing for testing purposes right?
14:14:51 <erisco> you mean <<$>> or some such I am guessing
14:14:58 <erisco> oh, that is bipure, nevermind
14:15:32 <erisco> the .Internal is for all the guts that are not intended as the public interface
14:16:18 <erisco> but people may import this anyways, with understanding that it is volatile, if they wish to tinker under the hood
14:16:45 <bvaldivielso> ok, I see
14:17:15 <erisco> this is contrary to the nanny culture of other package repositories
14:17:18 <dmwit> > ((+), (+)) <<*>> (1, 2) <<*>> (3, 4)
14:17:21 <lambdabot>  (4,6)
14:17:35 <bvaldivielso> I was writing a Parser library just for practicing my haskell
14:18:16 * hackagebot libltdl 0.1.1 - FFI interface to libltdl  https://hackage.haskell.org/package/libltdl-0.1.1 (GeoffreyMainland)
14:18:25 <bvaldivielso> and tried to publish a Parser module (in cabal's that exposed-modules)
14:18:38 <bvaldivielso> in cabal's exposed-modules*
14:19:09 <bvaldivielso> which could have some submodules like Parser.Util, Parser.Combinators and such
14:20:04 <bvaldivielso> is it possible to expose all the Parser submodules without explicitly telling cabal?
14:20:34 <dmwit> no
14:20:43 <bvaldivielso> I had to explicitly type the names of all the submodules I wanted to expose
14:20:49 <dmwit> correct
14:20:58 <sm> a helper tool, hpack, can discover them for you
14:21:12 <bvaldivielso> uh, ok
14:21:13 <erisco> some things are not that important to automate… how many submodules do you have?
14:21:35 <sm> since it's very error-prone, I like automating this one
14:21:37 <bvaldivielso> I didn't have much, but it's something I usually do in other languages and am pretty comfortable with
14:21:48 <bvaldivielso> didn't have many*
14:22:13 <erisco> cabal can't tell if you export a non-existent module?
14:22:26 <glguy> bvaldivielso: you'll need to list all your modules under either exposed-modules or other-modules so cabal knows what files to put in the sdist tarball and to know how to link your package when installing it
14:22:35 <soLucien> erisco what i needed was fst and snd
14:22:54 <soLucien> to get the first and second element of a 2-tuple
14:22:55 <bvaldivielso> erisco I guess it can, I don't know
14:23:04 <erisco> soLucien, I still recommend writing a Num instance, and then the options I suggested become available
14:23:29 <erisco> soLucien, and usually you would use pattern matching rather than projectors
14:23:45 <soLucien> (_, a) = a
14:23:48 <soLucien> smth like that ?
14:24:20 <erisco> (+) (a, b) (c, d) = (a + c, b + d)   there is your (+) definition already
14:24:27 <bvaldivielso> glguy ok, I was wondering if there was any "official" way to automatically expose submodules, but I see there isn't any
14:25:35 <np356> Hello there, I have two questions: Is there an equivalent of iostreams (c++) in haskell? I need to read and process data and I want to abstract the processing from the underlying source (file, socket, etc.).
14:25:39 <np356> ?
14:26:00 <erisco> np356, there are IO libraries available, yes
14:26:06 <sbrg> np356: there's lots of libraries that do that, yes. I personally prefer conduit
14:26:08 <dmj> np356: there is a package called io-streams that can do that
14:26:12 <sbrg> but there's also pipes and other friends. 
14:27:13 <np356> 2. What is the "correct" way of processing a collection with a window? something like: for (int i = 0; ...; ++i) { process(data + i, data + i + window_size); }
14:27:27 <np356> conduit.. alright, thank you sbrg
14:27:35 <np356> I'll google that
14:29:00 <erisco> you can have indexable arrays in Haskell
14:29:16 <np356> say I have xs = [1..100], and I want to process it in chunks of 5 elements sequentially. Whats the kosher and efficient way of implementing it in haskell?
14:29:42 <np356> without turning it into a for loop
14:29:59 <kadoban> np356: The "split" package has chunksOf, if that's what you mean
14:30:01 <erisco> that depends on what you consider efficient
14:30:14 <erisco> a list may already not be efficient by whatever standard you have
14:30:18 <np356> something like mapEvery fn 5 xs?
14:30:49 <erisco> but it is concerning to come to Haskell for the express purpose of writing high performance IO programs
14:31:31 <np356> yeah, chunksOf is what I'm looking for.
14:32:30 <np356> erisco, the program I'm writing is nessesarly high-performance. Though, I'm still learning Haskell and I want to develop good habbits from the beginning.
14:32:36 <sbrg> i have written "chunksOf" so many times
14:32:50 <ongy> you could also patternmatch into set's of 5: fun [x1:x2:x3:x4:x5:xs]
14:33:03 <monochrom> I think np356 is looking for sliding window, so chunking may be wrong.
14:33:07 <np356> I read already few haskell books and now its time to try it out on a real project.
14:33:19 <np356> monochrom, correct.
14:34:04 <erisco> *shrug* I guess my bias is that I have no interest in using Haskell for high performance IO :P
14:34:36 <lyxia> > fmap (take 5) . tails $ [0 ..]
14:34:39 <lambdabot>  [[0,1,2,3,4],[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,...
14:35:08 <erisco> we're talking about lists to begin with, so there is indirection on every element and no memory locality
14:35:31 <erisco> if you really want efficient then you want sequential allocation
14:36:27 <Welkin> erisco: then you want space engineers
14:36:28 <erisco> but we should also consider where this data is coming from, and what "processing" it means
14:37:28 <dmj> erisco: ghc might be fusing the lists away, and unboxing the values too
14:37:29 <np356> erisco, I have 20GB of integers stored in a text file, and I want to maintain a running average over the last 100 datapoints.
14:37:34 <np356> think of it as SMA100
14:38:07 <np356> for the entire 20GB file.
14:38:21 <np356> I want to produce another 20GB with those average
14:38:31 <np356> something like scanl but for a larger window than one element
14:38:34 <np356> i guess
14:38:34 <erisco> mhm, so I would look at pipes or conduit to facilitate the streaming of this file
14:38:35 <sbrg> np356: any of the streaming libraries should be able to accomplish that using constant memory. 
14:38:56 <erisco> but you certainly would never read it into a list
14:39:01 <np356> conduit... cool. I'll read a tutorial about it.
14:39:26 <parsnip> i would like to time `main' in ghci, i guess with `:set +s'. but my results seem to be cached i guess, can i reset the memory so haskell has to recalculate from scratch? 
14:39:29 <sbrg> np356: Just google "fpcomplete conduit guide" or some such. there's a lengthy guide
14:39:38 <Welkin> np356: nothing here? http://hackage.haskell.org/package/statistics
14:39:51 <Welkin> np356: I'd use pipes over conduit
14:40:03 <sbrg> np356: Why, if I may ask? Just curious
14:40:06 <Welkin> those are the two most commonly used streaming libraries
14:40:08 <sbrg> Only ever used conduit and grown to like it
14:40:16 <erisco> dmj, might. It is a black box.
14:41:10 <np356> sbrg, I'm trying to learn haskell. I read few books about it and I love the language. Now I want to build an end-to-end project using it. I came up with this idea to write a simple trading/backtesting system.
14:41:24 <monochrom> parsnip: I think a :reload will do
14:41:26 <erisco> I don't want to rely on might-happens. If list optimisations incidentally speed up list programs without me thinking about it, great
14:41:31 <np356> It will read FX data from CSV files, and output orders, etc.
14:41:35 <np356> then render graphs.
14:41:38 <erisco> but I am never going to rely on it when I explicitly need it to happen
14:41:45 <np356> This is more of a learning experiene than anything else
14:42:14 <erisco> am I going to inspect the compiler output every time? no
14:42:22 <parsnip> monochrom: hmm, didn't work, maybe time to bit the bullet and get more comfortable with command line ghc. 
14:42:26 <parsnip> *bite
14:42:47 <sbrg> parsnip: there's also a benchmarking library. the name eludes me though. 
14:43:04 <monochrom> criterion
14:43:06 <Welkin> np356: pipes-csv is what you will want then
14:43:10 <sbrg> that's the one
14:43:14 <Welkin> for streaming/parsing csv
14:43:23 <mniip> @check \xss -> diagonalize (diagonalize xss) == diagonalize (fmap diagonalize (xss :: [[[()]]])
14:43:23 <lambdabot>  <unknown>.hs: 1: 89:Parse error: EOF
14:43:23 <Welkin> there is one for conduit too I think
14:43:28 <mniip> @check \xss -> diagonalize (diagonalize xss) == diagonalize (fmap diagonalize (xss :: [[[()]]]))
14:43:31 <buglebudabey> im trying to run ghci using stack on a file that's not part of a project and im getting "error parsing targets, directory not found" is there a way i can get around it not being part of a package?
14:43:31 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 5 shrinks):
14:43:31 <lambdabot>  [[[(),(),()],[(),(),(),()],[(),()]],[[()],[(),(),()],[(),(),()],[(),(),()]],...
14:43:46 <np356> nice!
14:43:52 <np356> thank you Welkin!
14:44:04 <mniip> hmm, is Omega not a monad, or did I implement diagonalize wrong
14:44:15 <parsnip> monochrom: or, doing some silly `let main = print "hello"' to break binding seemed to help. 
14:44:21 <erisco> :t diagonalize
14:44:23 <lambdabot> [[a]] -> [[a]]
14:44:24 <mniip> oh I did
14:44:25 <mniip> haha
14:44:42 <np356> btw, do you have any ides with autocompletion for function names?
14:44:54 <soLucien> i have a type Curve = [Point]
14:44:59 <sbrg> np356: what editor are you using?
14:45:05 <soLucien> now i want to define a toList method for it
14:45:10 <np356> ghc-mod + sublime isn't nessesarly brilliant at code completion 
14:45:18 <erisco> soLucien, it is already a list, though
14:45:19 <np356> sublime or vscode
14:45:20 <sbrg> soLucien: Curve is already a list
14:45:22 <monochrom> recently I have found that haskell-mode for emacs can do autocompletion too
14:45:22 <soLucien> which will convert it back to a [Point]
14:45:32 <soLucien> what's the easeiest way of doing it ?
14:45:36 <monochrom> then again it just needs to ask ghci to do it
14:45:40 <erisco> type X = Y means X and Y are the same thing
14:45:46 <bvaldivielso> is it feasible to have your text editor typecheck your code real time?
14:45:57 <Welkin> bvaldivielso: it's called ghc-mod
14:45:57 <mniip> @check \xss -> diagonalize (diagonalize xss) == diagonalize (fmap diagonalize (xss :: [[[()]]]))
14:45:59 <soLucien> i have tried map
14:46:01 <Welkin> and flycheck
14:46:02 <monochrom> so actually I don't know when it was implemented first. I only found out last month.
14:46:03 <lambdabot>  mueval-core: Time limit exceeded
14:46:08 <np356> bvaldivielso: yup, hlint does that for me in vscode and sublime
14:46:09 <sbrg> np356: I use emacs, personally, and I'd wager that the most complete "IDE support" exists for emacs. there's both haskell-mode and the more recent intero
14:46:11 <erisco> mniip, inconclusive :P
14:46:11 <np356> and its pretty good
14:46:21 <bvaldivielso> Welkin np356 awesome!
14:46:28 <ertes> bvaldivielso: haskell-interactive-mode does that, too
14:46:37 <bvaldivielso> I'll look into ghc-mod
14:46:38 <ongy> hdevtools does it aswell
14:46:45 <ertes> ghc-mod is mostly useful with vim
14:46:50 <soLucien> ok i made it .. that was easy
14:46:59 <soLucien> doing toList c = c will cast it to list
14:47:01 <bvaldivielso> well I see every existing mode does it except the one I'm using
14:47:02 <erisco> soLucien, I don't think you are listening
14:47:12 <ertes> bvaldivielso: emacs?
14:47:15 <sbrg> soLucien: no, not really. but also yes
14:47:22 <bvaldivielso> ertes yes
14:47:24 <np356> bvaldivielso: https://github.com/SublimeHaskell/SublimeHaskell
14:47:25 <ertes> bvaldivielso: are you using haskell-mode?
14:47:26 <sbrg> type Foo = Bar defines Foo as a type synonym for Bar
14:47:34 <sbrg> that is, they are literally the same type. there is no difference to the typechecker
14:47:40 <bvaldivielso> ertes I'm using the default one
14:47:59 <np356> cool. Thanks everyone.
14:48:00 <bvaldivielso> ertes I think it is haskell-mode
14:48:00 <np356> bye!
14:48:18 <bvaldivielso> ertes I'll check it up
14:48:19 <ertes> bvaldivielso: there is no default, but the most common haskell mode is haskell-mode…  that one has haskell-interactive-mode as an optional extension, but you need to enable it
14:48:32 <iphy> is there a way to ask cabal for the dependencies of a .cabal file?
14:48:50 <soLucien> erisco i am trying to learn .. this is the first haskell code i ever write
14:49:04 <soLucien> so i try to listen , but maybe some things don't really make sense
14:49:08 <iphy> I want to get them out to put them into another file
14:49:12 <soLucien> (yet)
14:49:21 <conal> iphy: if you've already built the package, you can do "ghc-pkg describe <package-name>".
14:49:22 <erisco> soLucien, yes, but you received two replies to your question and engaged with neither of them, so it is a wonder you are posting your question here
14:49:23 <Welkin> lol what happened
14:49:41 <Welkin> suddenly there are tons of people coming in right at this moment saying they are new to haskell and asking for help
14:49:43 <conal> iphy: might give you the info you want.
14:49:50 <sbrg> Welkin: maybe a course
14:49:52 <Welkin> is there some kind of blog post someone made?
14:49:53 <sbrg> heh
14:49:56 <erisco> soLucien, you can ask for clarification if something does not make sense, we're happy to explain
14:49:56 <glguy> iphy: You can use: cabal freeze
14:49:57 <sbrg> start of a semester
14:50:00 <monochrom> there is a difference between "I don't understand so I ask for more explanation" and "I don't understand so I ignore all of you"
14:50:10 <soLucien> erisco but the answers were wrong .. look 
14:51:02 <soLucien> http://pasteboard.co/LrLQEw0Y.png
14:51:05 <erisco> soLucien, by your own admission you are a newcomer, and presumably do not understand our comments, and so what reason could you have for determining our answers as wrong?
14:51:14 <mniip> > do x <- Omega [1..3]; y <- Omega [1..3]; return (x, y)
14:51:16 <lambdabot>  Omega {runOmega = [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(2,3),(3,2),(3,3)]}
14:51:29 <JonReed> Hi, I don't get what's the point of type families. All type families tutorials I've seen so far seem to be using data families. Are type families just fancy synonyms? E.g., you can't have `type MyList "one int" = [Int]` but you can have `type family MyList (a :: Symbol); type instance MyList "one int = [Int]; "` and then `print $ ([5] :: MyList "one int")`. However I can't see the point of that. 
14:51:31 <sbrg> soLucien: sure, but that doesn't change the fact that they are literally the same type. 
14:51:39 <mniip> > liftA2 (,) (Omega [1..]) (Omega [1..])
14:51:41 <lambdabot>  Omega {runOmega = [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,...
14:51:51 <Welkin> and here comes mniip with the spam
14:52:04 <soLucien> the curve is an array of points, but the type is Curve .. and my assignment is asking me to write a toList function that turns it into a list of points
14:52:12 <erisco> soLucien, what you did works, but you are not achieving what you think you are achieving. It is redundant. We are trying to explain why it is redundant
14:52:31 <sbrg> soLucien: And the correct answer to that assignment is probably "toList = id" with the correct type signature
14:52:32 <iphy> glguy: so, my use case is to get the list of dependencies and put them into a Dockerfile, so when the list of dependencies changes, the dockerfile is updated
14:52:33 <soLucien> i understand .. i am trying to acheive what my assignment asks me to
14:52:38 <sbrg> it's a "trick question"
14:52:42 <iphy> I really just need the list that's in the cabal file
14:52:45 <Welkin> Data.Array.toList
14:52:46 <Welkin> done
14:52:46 <soLucien> but i do understand that haskell will infer the type
14:52:51 <soLucien> so it needs no explicit casting
14:52:59 <erisco> Haskell does not have casting
14:53:00 <Welkin> there is no such thing as "casting" in haskell
14:53:03 <sbrg> no, it isn't doing any type inferring there
14:53:08 <soLucien> okay 
14:53:31 <mniip> Welkin, isn't this amazing
14:53:44 <monochrom> mniip: What is Omega?
14:53:49 <ertes> :t coerce
14:53:51 <lambdabot> error: Variable not in scope: coerce
14:53:58 <ertes> :t Data.Coerce.coerce
14:54:00 <erisco> soLucien, try this   :t c :: [Point]   and note how there is no error
14:54:00 <lambdabot> Coercible a b => a -> b
14:54:02 * ertes runs away
14:54:03 <ReinH> monochrom: Omega is, iirc, a diagonalization technique
14:54:09 <Welkin> mniip: I don't know what you did
14:54:13 <mniip> > runOmega $ Omega [0..] >>= (`replicateM` (Omega ['a'..'z']))
14:54:16 <lambdabot>  ["","a","b","aa","c","ab","aaa","d","ba","aab","aaaa","e","ac","baa","aaab",...
14:54:18 <erisco> ertes, you've dug too deep and have released the Balrog!
14:54:26 <ReinH> for enumerating, in this case, N^2, and similar things
14:54:36 <ertes> erisco: huh?  no…
14:54:46 <ertes> :t Unsafe.Coerce.unsafeCoerce
14:54:48 <lambdabot> a -> b
14:54:53 <ertes> erisco: now i have
14:55:02 <monochrom> Does it mean it is a monad for some kind of list/stream such that join is diagonalization? I think I've seen an example in haskell-cafe.
14:55:13 <soLucien> c :: [Point] :: [Point]
14:55:16 <erisco> ertes, sorry, I am conditioned to fear "coerce"
14:55:19 <ReinH> monochrom: that's my understanding
14:55:22 <iphy> glguy: the problem with cabal freeze is that it doesn't take flags
14:55:25 <monochrom> OK neat
14:55:29 <ReinH> pretty neat :)
14:55:45 <hvr`> iphy: what do you mean by not taking flags?
14:55:49 <ertes> erisco: coerce is actually safe =)
14:55:55 <erisco> I see that
14:56:04 <mniip> it isn't
14:56:18 <ertes> but it doesn't do casting the way e.g. C does, turning (int)1 into (float)1.0 implicitly
14:56:21 <erisco> I wonder what use it has… seems a bit pointless
14:56:21 <mniip> you can use it to violate invariants
14:56:27 <ertes> s/implicitly//
14:56:42 <monochrom> law-complying coerce is safe. but that just shoves the problem under the rug.
14:56:59 <iphy> hvr`: cabal freeze -fsome-flag
14:57:00 <ertes> well, at least it doesn't segfault your program =)
14:57:01 <iphy> doesn't work
14:57:11 <monochrom> true
14:57:22 <glguy> It's not pointless, it can coerce between, for example, [Int] and [Sum] as a no-op
14:57:25 <iphy> hvr`: some-flag is defined in mypackage.cabal
14:57:28 <glguy> Sum Int*
14:57:45 <sbrg> really? 
14:57:48 <monochrom> but coerce is still not cast
14:57:48 <erisco> glguy, is there special sauce under the hood? I just presumed it was a vanilla type class
14:57:58 <sbrg> huh
14:58:28 <glguy> Yeah, it's supported by the compiler to allow you to coerce between representationally equal types
14:58:33 <monochrom> but don't quote it on me. I seem to recall that different people have different, conflicting meanings of "cast"
14:58:41 <erisco> https://ghc.haskell.org/trac/ghc/wiki/Roles
14:59:03 <erisco> I hear "cast" applied wrt subtyping
14:59:24 <kadoban> Yeah, cast means like 12 different things, depending on which language you come from, and if it's C++, depending on which casts you know, heh.
14:59:38 <hvr`> iphy: oh right... I can only tell you, that in cabal 1.25, 'cabal new-freeze' does support them
14:59:46 <iphy> I see
14:59:48 <hvr`> iphy: not sure if that's of any help
14:59:48 <erisco> soLucien, the reason   :t c :: [Point]   is correct is because  Curve ~ [Point]  i.e.  Curve and Point are the same type, so   c :: Curve   and   c :: [Point]  are the same thing
14:59:51 <monochrom> Bah I should simply go build a time machine and go back and hypnotize Dennis Ritchie to not introduce the idea of "cast" at all. Then today no one will ask about it in Haskell.
14:59:53 <iphy> well, I've inverted the flag in the cabal file
15:00:05 <iphy> so the default is what I need for the dockerfile
15:00:15 <iphy> it's just not what users will typically want
15:00:19 <monochrom> (To coerce Ritchie into not casting. Eh!)
15:00:26 <iphy> (that's ok)
15:00:33 <erisco> soLucien, so if you have a Curve you have a [Point] which is a list, no additional work needed. If you really want a function then use "id", which is  id x = x
15:00:43 <ertes> use "coerce" and "convert" instead
15:00:47 <ertes> "cast" is highly overloaded
15:00:54 <erisco> soLucien, which is just what you've written, and it does nothing because it doesn't need to! :)
15:01:16 <ReinH> monochrom: you could cast a hypnotize spell
15:01:19 <ertes> a coercion is a no-op on the operational level
15:01:23 <monochrom> \∩/
15:01:41 <erisco> reinterpret_cast is the only true cast
15:01:43 <soLucien> erisco this point is part of my assignment
15:01:50 <erisco> none of this checked cast sissy stuff
15:01:54 <ReinH> I really feel like this is beyond the scope of an assignment
15:01:59 <sbrg> being cast into cabal hell is the only true cast
15:02:22 <soLucien> http://pasteboard.co/LDKaUHQB.png
15:02:41 <soLucien> cast =  changing some type to some other type if it "fits"
15:02:55 <soLucien> that's what i meant ..
15:02:59 <ReinH> how is Curve defined?
15:03:07 <soLucien> a array of points
15:03:09 <sbrg> supposedly type Curve = [Point]
15:03:11 <erisco> well that is so broad as to describe… a lot of functions
15:03:12 <ReinH> what is its definition?
15:03:20 <sbrg> ReinH: ^
15:03:27 <soLucien> type Curve = [Point]
15:03:30 <ReinH> if type Curve = [Point], then there is no casting going on, since Curve and [Point] are the same type already
15:03:44 <erisco> where does your assignment define Curve?
15:03:48 <soLucien> i understand .. well maybe the teacher wanted to show us that
15:03:50 <ReinH> They are two different names for the same type, that is all.
15:03:51 <ertes> soLucien: take that "=" literally
15:04:06 <sbrg> soLucien: that has been my point all along
15:04:27 <sbrg> but notice that there is no "cast" in the assignment. are you sure that Curve is supposed to be: type Curve = [Point] ?
15:04:30 <erisco> width and height are also casting, by that definition
15:04:34 <sbrg> because "compute" suggests otherwise
15:04:37 <monochrom> soLucien: at the beginner level, there are only "type specialization" and "conversion". There are no casting or coercion at this point, and they are not needed.
15:04:40 <ReinH> I would like to see where Curve is defined in the assignment.
15:05:11 <ReinH> If it isn't type Curve = [Point], then toList = id will not work.
15:05:49 <monochrom> Type specialization means "someone gave me a function id::a->a, can I use it for Int->Int?" Answer: yes.
15:06:23 <erisco> can I use it to make me dinner?
15:06:46 <monochrom> Conversion means you have an Int and you want to map it to the corresponding Double. Conversion is actual computation. Int and Double have different bit patterns for the "same" value, there is actual computation to be done.
15:07:01 <soLucien> http://pasteboard.co/LICg8HlM.png
15:07:02 <Welkin> you can use it to toast your cat and walk your bread
15:07:30 <monochrom> And neither type specialization nor conversion is remotely close to what everyone calls "cast" or "coercion"
15:07:37 <ReinH> That doesn't define Curve though
15:07:40 <ReinH> It just claims that it exists
15:07:50 <soLucien> yes .. i defined it as an array of points
15:08:02 <sbrg> it's not an array, it's a list
15:08:05 <soLucien> list
15:08:06 <Welkin> lol
15:08:08 <soLucien> :)
15:08:16 <sbrg> and you were probably supposed to choose another definition
15:08:19 <Welkin> well, other languages add to this confusion
15:08:22 <buglebudabey> could someone help me find out where I am indexing outside of the array in my 0-1 knapsack problem? http://lpaste.net/186955
15:08:28 <Welkin> by stupidy calling their dynamic arrays "lists"
15:08:32 <Welkin> stupidly*
15:08:53 <monochrom> cast iron can be used to grill steak, but first you have to set it on fire.
15:09:08 <erisco> so you chose  curve = (:)   … I like your frugality
15:09:09 <soLucien> Java/Ruby/Powershell/C#/PHP/Python/JS/Bash
15:09:14 <soLucien> that is where i come from
15:09:25 <Welkin> ew to all of those
15:09:33 <soLucien> so i have maybe another kind of lingo
15:09:46 <Welkin> well, learn how it works in haskell
15:09:50 <Welkin> otherwise we can't help you
15:09:50 <soLucien> of course
15:09:52 <ertes> half of those don't have "data structures"…  they have "hash tables" and call them "arrays"
15:09:53 <soLucien> that's the point
15:09:55 <soLucien> i love it so far
15:09:57 <ReinH> It's a nice representation, assuming the assignment allows it
15:09:59 <sbrg> soLucien: don't worry, it's fine. it's just important to know the distinction because lists will not perform as you would expect if you use them as you would arrays.
15:10:16 <parsnip> Hmm, if I run `time stack ghc p051.hs && time ./p051', it takes about 10 seconds. Whereas, if I do `time stack runghc p051.hs', takes about 33 seconds. 
15:10:34 <erisco> performance is the unimportant part of it … it is that arrays and lists are different structures
15:10:35 <parsnip> so, runghc doesn't do optimization? 
15:10:40 <Welkin> rundmc
15:10:57 <Welkin> parsnip: runghc and running in ghci is for quick tests
15:11:09 <erisco> lists are inductive, and arrays not
15:11:15 <Welkin> you need to actually compile to really test it though
15:11:21 <erisco> arrays are not particularly insightful in the FP realm
15:11:41 <monochrom> eh? IMO performance (at least the asymptotic kind) is why so many data structures exist and they are considered different.
15:11:52 <sbrg> parsnip: try ghc -fforce-recompile 
15:11:56 <sbrg> (I think that flag exists)
15:12:11 <erisco> monochrom, *shrug* that is to care about the side effects, the boring stuff :P
15:12:28 <MarLinn> I don't like that we call these things "lists"... it makes more sense to think of them as stacks or streams
15:12:41 <Welkin> MarLinn: what?
15:12:44 <monochrom> like why don't I put everything in a CSV file. Answer: CSV may be fast for some purposes but not all purposes.
15:12:47 <soLucien> so guys .. once i finish this , maybe i would like some feedback
15:13:07 <soLucien> should i make the repo public and ask you to review it?
15:13:17 <MarLinn> Welkin: "List" has all these confusing connotations from other languages
15:13:19 <sbrg> sure. someone will probably take a peak.
15:13:45 <Welkin> MarLinn: a list is a singly-linked list in haskell
15:13:48 <sbrg> MarLinn: well, we could just say "linked list". 
15:14:23 <erisco> monochrom, I am being a little facetious. My assumption is that concerns are misaligned coming into FP, and so I am bending in the other direction to maybe come out in the middle
15:14:26 <MarLinn> "linked" sounds like explicit pointers. And like it could actually be a doubly-linked list...
15:14:27 <glguy> and don't get me started on grocery lists, rarely are they the linked variety
15:14:32 <sbrg> it's not really a stack because you traditionally don't have the option to append to a stack. but that's probably just pedantry since they are basically the same thing
15:14:33 <soLucien> i think haskell is amazing so far .. basically i implemented a 2d vectorial space with translation and rotation in ~100 lines
15:14:52 <sbrg> i can't think of a difference except that they have separate operations traditionally defined for them
15:15:03 <ongy> MarLinn: a stack usually provides Push/Pop. Filter on a stack would feel weird (at least to me)
15:15:17 <soLucien> would take a extremely long time doing this in OOP
15:15:29 <Welkin> soLucien: oop is not the only other option
15:15:38 <Welkin> there is a whole world beyond oop
15:15:47 <erisco> soLucien, it isn't that difficult in C#/Java/whatever
15:16:14 <soLucien> erisco i agree
15:16:19 <soLucien> but not 100 lines
15:16:21 <ertes> erisco: try translating the 'linear' package to C#/java/whatever
15:16:24 <wedify> does cabal have a way to list installed packages that are not depended on by other installed packages?
15:16:39 <monochrom> glguy: In a classical music store, I saw a paper pad called "Chopin Liszt"
15:16:50 <ongy> I'd argue that haskell has way denser lines, and comparing haskell loc to e.g. C loc has no value at all
15:16:55 <erisco> ertes, if it doesn't use particular type class features then I can, but I am not saying it would be short
15:17:00 <ertes> erisco: i wouldn't be surprised if the source code size blows up by a factor of 100
15:17:40 <erisco> ertes, particularly when defining ADTs, by the time you get all the boilerplate (that I recommend) in, you are about 100x over Haskell ADTs, yes
15:17:44 <ertes> erisco: the problem is not defining equivalents of those classes, but .NET/JVM don't have arbitrary polymorphism
15:18:00 <ertes> you can only abstract over types of kind *
15:18:37 <erisco> yes, it is sometimes a hindrance, but I have found often not
15:18:52 <parsnip> hmm, i have some hundred exercises in separate file. if i want to compile them to test their times, i would have those hundred sections in my .cabal file? 
15:19:23 <erisco> the only times you need HKP is just when you're writing functions generic to them, which is not so common
15:19:32 <erisco> maybe linear is full of that, I don't know
15:19:34 <monochrom> use the unix command "cat" to merge them into one huge file :)
15:19:36 <ertes> erisco: because you probably do something along the lines of: "screw it, i'm going to write a single class for these things and just use dynamic means to tell them apart"
15:19:42 <MarLinn> ongy: True. Especially when you think about stacks in the way you must do implicitly in imperative languages. Filtering a stack of nested method calls is... a rare occurrence
15:20:19 <parsnip> monochrom: but i'd still like to run them separately. i guess it'd be like i feed main an argument to select which to run? 
15:20:19 <erisco> ertes, well, I can show you
15:20:42 <ertes> erisco: you decide not to have V1, V2, V3 and V4, but a dynamic-dimensional vector type…  at least that's what i found myself doing in my OO days
15:21:14 <parsnip> monochrom: i guess i'll just have to keep experimenting, good exercise i guess. 
15:21:21 <ertes> erisco: sure, i never missed HKP before i learned haskell =)
15:21:23 <erisco> hm, my best examples are sitting in proprietary code ATM… I made a breakthrough on it recently
15:21:29 <monochrom> sounds like a lot of work either way
15:22:13 <erisco> ertes, oh, it is generic over vector length?
15:22:15 <ertes> erisco: i believe you…  but OO really doesn't solve the abstraction problem well
15:22:35 <monochrom> it is also between a rock and a hard place. a thousand modules under "exposed-modules:" or "other-modules:" is going to choke the shell. a huge file is going to choke ghc.
15:22:56 <erisco> well, you can have your vectors inherit from an interface which defines addition, subtraction, and so-forth
15:23:33 <erisco> the difference here is that the interfaces a type implements is closed, whereas this is not the case with type classes, a significant feature
15:23:37 <ertes> erisco: it basically uses base classes like Traversable and Applicative
15:23:55 <erisco> but since you know ahead of time the reasonable interface for vectors, this isn't much of a problem
15:24:04 <ertes> erisco: so you can use linear's functionality very often even for types defined outside of it with no relation to linear algebra
15:24:05 <erisco> though wrt performance I wince at the indirection
15:25:38 <erisco> ertes, it just happens that you're often working with specific types rather than generically
15:26:06 <erisco> in Haskell we have these facilities available so we just use them, but you can survive without them for most tasks
15:26:47 <erisco> so you cannot define, say, "sequence", but you can define it for each type and you probably only have one or two you're interested in anyhow
15:27:09 <ertes> erisco: and also every function you defined in terms of those, etc.
15:27:33 <erisco> well you don't have sequence, so derived functions are moot
15:27:33 <ertes> if you really program in that style (and i do now) it makes you sad
15:28:37 <erisco> yes, well, I have decided to take what I can get :P there is satisfaction in bringing some beauty to ugly situations
15:29:04 <ertes> erisco: my personal opinion is that OO is like the microsoft excel of programming paradigms: it's never the right tool for the job, yet everybody uses it
15:29:52 <erisco> with enough effort, every problem can look like an Excel spreadsheet
15:31:05 <ertes> http://tristancalderbank.com/2016/09/06/excel-messenger-a-terrible-experiment-in-vba/
15:31:28 <bvaldivielso> I don't know if someone has read this tutorial on parser combinators http://dev.stephendiehl.com/fun/002_parsers.html
15:31:39 <erisco> ertes, I rarely use inheritance when working in OO languages… and particularly C# is progressing more towards functionalism
15:31:45 <glguy> It's likely that someone has
15:31:54 <bvaldivielso> but I was wondering why the type of parse is String -> [(a, String)]
15:32:03 <erisco> ertes, recently obtaining the "using static" feature in C#6 which is a love song to functional programming
15:32:08 <bvaldivielso> and not String -> Maybe (a, String)
15:32:53 <bvaldivielso> I have implemented everything he does in the tutorial with the Maybe monad and it seems to be enough
15:32:57 <erisco> bvaldivielso, I haven't read that one, but I can tell you why I chose that in my parser :P
15:33:06 <Welkin> O.o wtf is with this?? https://github.com/Dridus/ghcjs-react-router/blob/master/src/React/Router.hs
15:33:12 <Welkin> factories????
15:33:21 <ertes> erisco: that's all fine, but unless you're forced in some way to use C#, given a proper FP language like haskell it seems absurd to use C#
15:33:29 <ReinH> Welkin: Yes. JavaScript.
15:33:34 <glguy> bvaldivielso: using a list allows you to do more backtracking
15:33:37 <erisco> relax, an XFactory is just a function like -> X
15:33:44 <ReinH> react-router is JavaScript. It uses factories.
15:33:56 <bvaldivielso> erisco that would be great, can it be so that multiple valid partial parsing results can be propagated until they fail?
15:33:59 <erisco> ertes, of course I am forced :P
15:34:23 <erisco> bvaldivielso, that is just it, yes
15:34:48 <bvaldivielso> glguy ok I think I understand now
15:34:53 <bvaldivielso> that's awesome
15:34:57 <erisco> when you have the grammar  (A | B) C  then you want this equivalent to   A C | B C  and  B C | A C
15:35:07 <erisco> many parsers do not give you this, your Maybe parser being one of them
15:35:13 <erisco> they do that in name of efficiency
15:35:19 <ertes> Welkin: it has factories, but no facades?  where is its dependency injection and its BusinessEnterpriseSingleton?
15:35:43 <erisco> so when parsing  A | B  you want to parse both options, and you want to try both of these options again with C
15:36:28 <bvaldivielso> erisco but the Alternative typeclass does not give you that "paralellism", right?
15:36:33 <ertes> ok, enough OO bashing for today =)
15:36:58 <erisco> bvaldivielso, I do not understand the question.
15:37:23 <bvaldivielso> erisco he later makes it parser an instance of Alternative
15:37:42 <erisco> Alternative defines (<|>) and empty, and parser combinators use both of these, and particularly | (as you may see in grammar notations) appears as (<|>)
15:37:53 <erisco> another name for this is "executable grammars"
15:37:59 <bvaldivielso> so that he can do things like `parseNumber <|> parseString`
15:38:03 <erisco> as you just write your grammar and then run it
15:38:05 <bvaldivielso> yes
15:38:24 <erisco> but there is nothing about Alternative saying how your parser has to work, only the Alternative laws (which are vague in this regard)
15:39:17 <erisco> particularly   empty <|> x = x, x <|> empty = x, x <|> (y <|> z) = (x <|> y) <|> z   (same as Monoid laws)
15:39:31 <bvaldivielso> I think Stephen Diehl's implementation just returns the first parser result if it doesn't fail
15:39:55 <erisco> there are trade offs in time and memory use with regards to what information you keep
15:40:19 <erisco> when I did parsing I was particularly interested in general context-free parsing, so I kept all information
15:40:47 <bvaldivielso> sure, but if you are just going to keep the first that doesn't fail, you can probably get away with parse :: String -> Maybe (a, String)
15:40:51 <bvaldivielso> right?
15:41:05 <erisco> yes
15:41:36 <erisco> that type directly dictates that your parser produces either zero or one parses
15:41:52 <bvaldivielso> cool
15:42:00 <erisco> so inductively, as you use combinators, you will always have zero or one parses
15:42:56 <erisco> a typical choice with <|> is that you keep the first success and ignore the rest
15:43:11 <erisco> which means you will fail to parse some grammars correctly, but this is the trade off
15:43:18 <dmwit> Is there anything like a "constrained" Dynamic? i.e. something like `data ConstrainedDynamic c where ConstrainedDynamic :: (Typeable a, c a) => a -> ConstrainedDynamic c`, so that one could write e.g. `instance Ord (ConstrainedDynamic Ord)`?
15:43:27 <bvaldivielso> cool
15:43:31 <bvaldivielso> I was thinking today that you can "simulate" the Maybe monad with the List monad (Just a ~ [a] and Nothing ~ []), is there a name for this intuition?
15:44:09 <bvaldivielso> well you can "simulate" the Identity Monad with the Maybe Monad to (Id a ~ Just a)
15:44:16 <monochrom> "inject/embed Maybe a into [a]"
15:44:37 <monochrom> similarly "inject/embed a into Maybe a"
15:44:46 <bvaldivielso> monochrom cool, that is what I was looking for
15:45:17 <kosh> if anone uses spacemacs: when I open repl in haskell layer, how do I circle for previous input (like up arrow in terminal)
15:45:50 <bvaldivielso> I read in this article http://blog.sigfpe.com/2008/12/mother-of-all-monads.html that the Continuation Monad is the "mother of all monads", could this be phrased as "Every monad can be embedded in the Continuation Monad?"
15:46:06 <bvaldivielso> or is it not the same?
15:46:09 <shachaf> bvaldivielso: The true mother of all monads is Codensity.
15:46:18 <monochrom> I think it is not the same.
15:46:41 <dmwit> The mother of all typeclasses is `Default`.
15:46:51 <bvaldivielso> shachaf I didn't even know that was a thing
15:47:00 <erisco> bvaldivielso, btw, on the "first result" choice, empty has to be the parser that always fails and consumes no input
15:47:21 <Welkin> what is the father of all monads?
15:47:29 <bvaldivielso> welkin lol
15:47:30 <monochrom> Wadler
15:47:39 <glguy> Welkin: That's ridiculous, Monads don't have fathers.
15:47:43 <bvaldivielso> erisco yes, that's how I implemented it
15:48:10 <parsnip> fatherless and often misunderstood :(
15:48:12 <erisco> bvaldivielso, it isn't a free choice, so good :P
15:48:20 <shachaf> Is there a precise meaning to "Codensity is the mother of all monads"?
15:48:39 <erisco> Density is the father of all monads, then, clearly
15:48:45 <monochrom> haha
15:48:53 <hpc> density is the comother, silly
15:49:51 <bvaldivielso> erisco what is a free choice? the notion of an unique "sensible" implementation of a function type or something like that?
15:50:14 <erisco> bvaldivielso, the Alternative laws necessitate the empty parser work that way
15:50:30 <erisco> if you choose <|> to take the first success
15:50:44 <bvaldivielso> ah ok, you mean the laws force it to be that way
15:50:51 <erisco> yes
15:50:56 <ReinH> kosh: M-p and M-n
15:50:56 <bvaldivielso> ok cool
15:51:57 <kosh> ReinH: thanks, but somehow it is not working
15:52:06 <buttbutter> How can I do something like this? foo = blah where blah = derp; derp = stuff. I understand that where only binds to what is above it, so how can I bind derp to stuff?
15:52:08 <bvaldivielso> I'm sorry if I'm rapid-firing my questions, but it's the first time I talk to people that know way much haskell than I do
15:52:15 <ReinH> kosh: are you in insert mode?
15:52:44 <ReinH> buttbutter: you can just do that.
15:53:01 <kosh> ReinH: cool thanks
15:53:34 <erisco> bvaldivielso, another option is longest match, though this may be more a textbook thing
15:55:19 <amalloy> buttbutter: all bindings in a where clause can see each ohter
15:55:34 <buttbutter> Oh, nevermind. My problem is that I wrote something like where foo (x, y) = (x', y'); x' = blah x. I can't use "x" in the definition of x' because x is only bound to the input in the foo (x,y) = (x', y') line, right?
15:55:37 <ReinH> amalloy: o/
15:55:53 <monochrom> right
15:55:56 <amalloy> \o
15:56:16 <buttbutter> monochrom: Are you saying right to me?
15:56:19 <bvaldivielso> erisco for parsing? I was thinking that if your grammar was well-defined, you'd end with just one possible result
15:56:39 <monochrom> yes
15:56:44 <amalloy> right, buttbutter. in that case x is only visible inside of foo, because it's one of foo's arguments
15:56:48 <buttbutter> What's a good way to get around that issue :)
15:56:55 <amalloy> you can add another where clause inside of foo if you want
15:57:07 <buttbutter> Oh, I didn't know you could have nested wheres
15:57:10 <monochrom> foo (x, y) = (blah x, y')
15:57:15 <amalloy> every pattern match can have a where
15:57:19 <ReinH> or you can pass things around as arguments
15:57:21 <buttbutter> Ah, perfect :D
15:58:13 <erisco> bvaldivielso, no, that is almost a meaningless thing to say. By choosing String → Maybe (a, String) you have one (or no) result by definition
16:00:15 <erisco> bvaldivielso, consider  S ::= a | aS  which translates to  pS = S <$> char 'a' <|> pS
16:01:21 <erisco> I mean, whoops …  pS = S1 <$> char 'a' <|> S2 <$> char 'a' <*> pS
16:01:35 <erisco> data S = S1 Char | S2 Char S
16:01:51 <erisco> so if we run this on  "aaa" we will get  Just (S 'a', "aa")
16:02:02 <erisco> under the "first success" version of <|>
16:02:11 <athan> Pipes' `map` function looks so intuitive: `map :: (a -> b) -> Pipe a b m r` friggin cool
16:02:25 <erisco> so what do you mean by "just one possible result"? we have necessitated one possible result by the way we made the parser
16:02:55 <athan> are maps in pipes always fused? So `map f . map g => map (f . g)` automatically?
16:03:19 <athan> I hear free monads do this... I'm probably wrong though
16:04:37 <erisco> under the "longest match" choice of <|> we get  Just (S2 'a' (S2 'a' (S1 'a')), "")
16:04:45 <erisco> again, one result, of course
16:05:25 <johnw> athan: I think there's a rewrite rule for that, but I'm not sure
16:05:39 <athan> johnw: Friggin cool :) thanks
16:05:54 <erisco> under the "all matches" choice of <|> we get  [(S1 'a', "aa"), (S2 'a' (S1 'a'), "a"), (S2 'a' (S2 'a' (S1 'a')), "")]
16:06:27 <bvaldivielso> erisco I meant that a correct "code" our parser should produce an "unique AST"
16:06:59 <bvaldivielso> that for a correct "code"*
16:07:00 <erisco> so, hopefully by this example you can see the nature of the issue. It is unrelated to ambiguity, though that is another consideration
16:07:13 <erisco> a nonambiguous grammar is affected by the choice you make for <|>
16:08:01 <bvaldivielso> yeah, I see what you mean
16:09:13 <bvaldivielso> another question kind of related to parsers and libraries
16:09:26 <bvaldivielso> I started implemeting a basic SQL select query parser
16:09:57 <bvaldivielso> it would parse queries like "select A.b, C.d from A, C"
16:11:08 <bvaldivielso> and "select A.b, C.d from A, C" may be syntactically valid, but it could happen that schema A doesn't have a b column
16:11:16 <erisco> well, I shouldn't say ambiguity is unrelated, but just unnecessary
16:12:05 <erisco> the only interpretation of the three I gave that supports ambiguity is the "all matches"
16:12:22 <erisco> the other two interpretations cannot be ambiguous
16:12:36 <bvaldivielso> the design I was thinking about involved having a data WeakQuery = WeakQuery { selects: [String], froms: [String] }
16:13:04 <bvaldivielso> this WeakQuery wasn't concerned about a column b existing in schema A
16:13:07 <erisco> bvaldivielso, what is the context of this? are you parsing SQL queries from a text file?
16:13:42 <erisco> the typical setup is you first parse and get an AST, then you do semantic analysis on this, possibly using another interim representation
16:14:16 <bvaldivielso> erisco No, I wan't to build a tool that will allow me to do some easy data manipulations from CSV and JSON files
16:14:31 <erisco> how is SQL involved?
16:14:56 <bvaldivielso> I want to write the transformations in a SQL-like language
16:15:29 <bvaldivielso> I don't want all the features relational dbs have, I just one some projections, products and aggregations
16:15:32 <buglebudabey> can i convert an array to a list from Data.Array?
16:15:38 <bvaldivielso> I just want*
16:15:54 <bvaldivielso> and well, filters
16:16:16 <erisco> what is a schema?
16:16:32 <bvaldivielso> I mean a "table"
16:16:52 <erisco> is this the first row of the CSV you read out, or what is it?
16:17:17 <bvaldivielso> yeah, I would get the schema from the CSV headers
16:17:59 <bvaldivielso> so it is ok to have a WeakQuery type that doesn't enforce semantic correctness
16:18:18 * hackagebot atlassian-connect-descriptor 0.4.4.1 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.4.1 (RobertMassaioli)
16:18:31 <bvaldivielso> and then have a function enforcing this correctness that maps from a WeakQuery to a Query
16:18:38 <erisco> so you create a Query, and then you have a function runQuery :: Query → Csv → Either Error Csv  or something like this
16:18:48 <erisco> if the column does not exist you produce a Left error
16:19:20 <bvaldivielso> I see
16:19:32 <erisco> well you cannot determine semantic correctness ahead of time, that is impossible, as your schema is sitting in the text file as you've said
16:19:44 <erisco> you can only determine it at the time you operate on the CSV
16:20:05 <bvaldivielso> so this runQuery is the one that should be in charge of enforcing correctness
16:20:12 <erisco> you can determine other things, such as names are in scope
16:20:55 <bvaldivielso> yes
16:21:03 <erisco> if you do   select x.y from z   this is erroneous regardless of schema
16:21:44 <erisco> compileQuery :: String → Either CompileError Query   something like this perhaps
16:22:36 <bvaldivielso> and would there be any way I could make the type system help me with this correctness enforcing?
16:23:23 <bvaldivielso> I think haskell type system cannot help with this, but as I believe, dependent types could
16:25:05 <buglebudabey> can someone help me realize why i'm getting an uninitialized element exception here? http://lpaste.net/187035
16:25:13 <bvaldivielso> (I don't know almost anything about dependent types or any type related thing, so what I said doesn't make any sense probably)
16:29:03 <buglebudabey> found out the problem nvm guys
16:29:14 <buglebudabey> initialized my matrix incorrectly
16:29:33 <Welkin> enter the matrix
16:30:12 <buglebudabey> ?
16:31:26 <Welkin> buglebudabey: your name is always confusing to look at
16:31:42 <buglebudabey> Welkin sound it out, it helps
16:31:43 <Welkin> bugadobadoobadee
16:32:04 <buglebudabey> it's a dream to type too
16:34:15 <erisco> bvaldivielso, sort of, yes, but it is an arduous route and not particularly worth it
16:35:13 <erisco> you would be better to choose a query language more conducive to that purpose
16:35:52 <erisco> you might view CSV as [[a]] and so then you can think in terms of transformations on that type
16:37:12 <bvaldivielso> erisco well it's not just about [[a]] because I want to perform joins (in the SQL sense) between different tables
16:37:30 <erisco> why does that change what a CSV is?
16:37:56 <bvaldivielso> ah sorry, I misread you
16:38:23 <erisco> join :: ([a] -> [a] -> Bool) -> [[a]] -> [[a]] -> [[a]]  or some such
16:38:51 <erisco> join :: (Row → Row → Bool) → Csv → Csv → Csv   aliased
16:39:18 <bvaldivielso> I was thinking of having column name information in my Csv data type
16:39:33 <Welkin> erisco: you and your fancy unicode arrows
16:39:52 <bvaldivielso> but yes, that's what join is
16:40:05 <erisco> data Csv = Csv { schema :: [a], rows :: [[a]] }  perhaps
16:40:46 <erisco> Welkin, 🦄
16:40:59 <bvaldivielso> yes, something like that
16:43:20 <erisco> not suitable for streaming
16:43:37 <erisco> this design composes CSVs, rather than operations on CSVs
16:44:20 <bvaldivielso> hmm that's an interesting observation
16:44:24 <zv> hey guys, not really haskell related but I figure people here probably know the answer: What is a good way to distribute computing without a single coordinating 'master'
16:44:44 <erisco> but you can do the latter, you can have a data type of operations
16:44:56 <erisco> think relational algebra for example
16:46:39 <kosh> if I have "Vector Complex" what is the easies way to convert it to "Vector Double" of double length and reverse operation. the order is not important (e.g. r1 r2 r3... i1 i2 i3... or r1 i1 r2 i2 ...)
16:46:41 <bvaldivielso> yes, good idea! if I am able to find some monad structure in this operation type, I will be the proudest guy ever
16:47:14 <kosh> probably I need not easy, but efficient way
16:47:15 <bvaldivielso> it seems similar to other monad instances I've seen
16:48:24 <erisco> monad is probably unnecessary
16:48:26 <dmwit> kosh: `fmap realPart v <> fmap imagPart v` -- ?
16:48:31 <jonored> zv: It Depends. (Given a well-partitioned problem space, even RFC1149 networking and static assignment of segments can do quite well.)
16:49:10 <bvaldivielso> well thank you very much erisco, you've been very helpful
16:49:15 <erisco> this is a start bvaldivielso  data Csv a = Project Col (Csv a) | Restrict (Row → Bool) (Csv a) | Join (Row → Row → Bool) (Csv a) (Csv a)
16:49:16 <zv> jonored: ah, I left out something critical. New parties can join and leave 'at will'
16:49:43 <zv> I don't mind 'work' being done twice, but it needs to approach completing the problem space
16:49:46 <erisco> bvaldivielso, basically, instead of  join :: (Row → Row → Csv a) → Csv a → Csv a → Csv a  you have  Join :: (Row → Row → Csv a) → Csv a → Csv a → Csv a
16:49:59 <erisco> bvaldivielso, straight-forward, and then you can interpret this later when you run the query
16:50:09 <monochrom> kosh: Use Data.Vector.Unboxed. It's already done for you. See its doc. :)
16:50:39 <bvaldivielso> I'll try to be hanging around here whenever I can to see if I can learn something (and eventually answer some questions haha)
16:50:53 <kosh> thanks 
16:51:02 <Wittgenstein> test
16:51:10 <erisco> bvaldivielso, you'll have to figure out what the leaves should be, presumably names of CSV files or something
16:51:34 <jonored> zv: I expect it still depends on what the problem looks like for a decomposition, and it'll probably have significant overhead.
16:52:15 <zv> jonored: imagine cloning an online dictionary
16:52:21 <zv> there are many, many entries
16:52:39 <bvaldivielso> erisco ok, I'll try
16:52:40 <zv> all sorted alphabetically
16:52:43 <bvaldivielso> thank you vey much
16:52:49 <lpaste> Wittgenstein pasted “error ” at http://lpaste.net/187046
16:53:11 <Wittgenstein> Can anyone help me with that?
16:53:12 <zv> we can partition the *storage* of data in this way without coordination (e.g consistent hashing) - is there something equivalent for work?
16:53:14 <Wittgenstein> I'm new to Haskell.
16:53:16 <erisco> bvaldivielso, this may be a natural progression towards GADTs for you, but try this simpler one for now
16:54:15 <monochrom> Wittgenstein, "countChar st character" is an Integer not an [Integer]. Therefore, "instances <- countChar st character" makes no sense.
16:54:46 <bvaldivielso> erisco I didn't know GADT was a thing either
16:54:48 <Wittgenstein> monochrom, but instances is supposed to be an integer
16:54:49 <jonored> zv: I mean, you could reuse that, if your work is just a function; hash the inputs.
16:54:55 <bvaldivielso> I have so many things to look up
16:55:16 <monochrom> That is not what I am talking about.
16:55:27 <monochrom> Again, "countChar st character" is an Integer not an [Integer].
16:55:44 <monochrom> If you say so much as "x <- y" you need y to be [something]
16:56:00 <bvaldivielso> Well, I'm leaving, we'll see if I wrap my head around all these ideas
16:56:03 <bvaldivielso> thank you very much
16:56:05 <bvaldivielso> bye
16:56:22 <MarcelineVQ> I ​miss bvaldivielso
16:56:59 <erisco> they have been gone for so long now
16:57:37 <Wittgenstein> monochrom, But when I do character <- st, isn't character just a Char instead of a [Char]?
16:57:55 <monochrom> Again, that is not what I am talking about.
16:58:09 <MarLinn> Wittgenstein: the problem is not with  character but with st
16:58:10 <monochrom> st :: [Char] is why "x <- st" is legal.
16:58:31 <monochrom> LOOK AT THE RIGHT HAND SIDE of <-
16:58:40 <erisco> I like the idea of "hand-crafted software" … not that stuff crafted by hooves, or claws
17:00:03 <glguy> erisco: Mine is artisanal
17:00:19 * MarLinn thinks that "Hand" would be the perfect name for a Haskell-based js-generator
17:01:02 <Wittgenstein> monochrom, but instances is supposed to be an integer why is it an [Integer]?
17:01:16 <MarLinn> Wittgenstein: syntax
17:01:21 <monochrom> Again, I am not talking about instances.
17:01:32 <monochrom> I give up.
17:01:42 <Wittgenstein> Great, You're less helpful than the compiler.
17:01:43 <Wittgenstein> Dumb fuck.
17:02:00 <monochrom> OK, you are a troll.
17:02:02 --- mode: ChanServ set +o monochrom
17:02:06 --- mode: monochrom set +b *!*@81.193.61.235
17:02:06 --- kick: Wittgenstein was kicked by monochrom (Wittgenstein)
17:02:22 <howtousecryptoni> :S
17:02:34 --- mode: monochrom set -o monochrom
17:02:48 <Welkin> lol
17:02:54 <Welkin> I thought the name Wittgenstein looked odd
17:03:12 <howtousecryptoni> I'm trying to encode a bytestring with AES256 using the cryptonite library. I must say I have no clue how to use this library. It's predecessor had a simple function called decode or similar.
17:03:25 <sm> #haskell, once the friendliest place on earth
17:03:38 <sm> :-/
17:03:49 <glguy> sm: it stays friendly by not allowing people to behave like that
17:05:06 <erisco> but decode wasn't highfalutin enough … you can derive it using six of the more generic functions now available
17:05:51 <glguy> Cryptonite's not particularly complicated in this regard, you always had to know what cipher and mode you wanted to use
17:06:05 <glguy> Check out: http://hackage.haskell.org/package/cryptonite-0.19/docs/Crypto-Cipher-Types.html#t:BlockCipher
17:06:06 <kwantam> It's probably best not to implement AES so much as derive it from proofs of security for an ideal block cipher.
17:06:07 <kwantam> :)
17:06:26 <howtousecryptoni> kwantam: That confuses me more. glguy, checking that out
17:06:28 <hpc> sm: while #haskell often smothers trolls with kindness, the line of patience is definitely drawn short of his last line
17:06:44 <kwantam> howtousecryptoni: sorry, that was me thinking I was clever but mostly just being useless.
17:06:54 <Welkin> #haskell-daycare
17:07:00 <hpc> (also that line broke a network rule, not just a channel rule)
17:07:19 <erisco> best not to have the feds come in here though
17:07:47 <howtousecryptoni> glguy: That doesn't clarify things much for me :( Could you give me an example?
17:08:07 <glguy> howtousecryptoni: If those methods don't make sense you probably shouldn't be using AES directly
17:10:14 <athan> Why isn't pipe's `scan` function `scan :: (x -> a -> x) -> x -> Pipe a x m r`? There's an extra mapping :s
17:10:31 <athan> the actual type is `scan :: (x -> a -> x) -> x -> (x -> b) -> Pipe a b m r`
17:10:45 <howtousecryptoni> glguy: I'm trying to get the same result as Go's aes.NewCipher(secret) function
17:12:11 <howtousecryptoni> I woudl use one of the older libraries which have similar looking functions but they say to use cryptonite
17:12:11 <glguy> howtousecryptoni: And what does that do in Go?
17:12:28 <howtousecryptoni> glguy: NewCipher creates and returns a new cipher.Block
17:14:12 <geekosaur> have you seen http://hackage.haskell.org/package/cryptonite-0.19/docs/Crypto-Tutorial.html ?
17:14:54 <howtousecryptoni> geekosaur: No. I'm embarassed to have missed that. Hm, is there a library that predefines the encrypt/decrypt functions like other languages have?
17:15:48 <howtousecryptoni> I have to run, but in case anyone else wanted to weigh in I'll check the logs later. Thanks for your help glguy and geekosaur 
17:15:52 <glguy> No, cryptonite is like the aes library in Go, you have to combine a block cipher with a cipher mode to get an encryption or decryption function
17:16:16 <geekosaur> I want to say something abotu (a) composability and (b) not encouraging poor programming practices
17:16:48 <geekosaur> but obviously "but other languages are fine with violating both" is supposed to be a strong argument of some kind
17:17:20 <monochrom> I want to hear, geekosaur.
17:17:30 <kadoban> A "just do it" button on crypto is ... pretty bad, kinda.
17:17:38 <erisco> geekosaur, well, I think we need to move away from talking about languages as though they are animated things
17:17:58 <erisco> it aint the languages, it is the programmers
17:18:06 <geekosaur> well, it encourages "don't think" which is almost always a security problem looking for a chance to happen when it comes to crypto
17:18:29 <erisco> and to that extent, "but no one else does that" or "but people do it like this" are the arguments
17:18:44 <geekosaur> as for composability, that just means "I can use a small toolkit to provide fullfunctionality" instead of "I provide 5 billion entry points for all the different things you could do"
17:19:00 <geekosaur> (and, well, Haskell. we like composable)
17:19:46 <erisco> those are sensible arguments too
17:19:57 <Welkin> haskell is like legos
17:20:05 <Welkin> wrapped in a burrito
17:20:07 <erisco> if you don't know for yourself then a good bet is to look at what others are doing
17:22:22 <hydraz> Welkin: But is join or bind a part of that burrito's definition?
17:24:16 <MarLinn> I'm not sure but Haskell gives you plenty of forks like >>= and >>> and <<= to eat your burritos
17:24:31 <MarLinn> Haskell: Where you can have your burrito and eat it, too!
17:24:54 <geekosaur> but then they want cake :p
17:24:57 <Sonolin> so... do notation is an all you can eat buffet?
17:25:19 <verement> this channel should not be making me hungry
17:25:24 <Sonolin> lol
17:25:58 <monochrom> Programming languages want to anthropomorphize humans.
17:25:59 <hydraz> =<< burrito
17:26:02 <Welkin> don't forget the curry
17:26:05 <hydraz> Yum!
17:26:07 <Welkin> curry burritos
17:26:21 <erisco> pipe that to me
17:26:51 <MarLinn> Yeah, they want cake. Especially cake they can smash together. No wonder their culture has so many clowns throwing cakes into each other's faces!
17:29:06 <monochrom> "Currito" exists.
17:29:39 <peddie> burroti
17:42:04 <johnw> If there any docker users who'd like to try my "fully local Hoogle" image in about 2 hours, just run: docker run -p 8687:8687 -ti jwiegley/hoogle-local, and you should have quick access to a fairly large local documentation set
17:42:34 <johnw> it's not small, though (~2 Gb)
17:43:07 <monochrom> would it download all of that 2Gb at once?
17:43:23 <johnw> another nice thing to do would be to dockerize an updateable local Hackage
17:43:31 <johnw> yeah, the 2G is needed to start the container on your machine
17:44:06 <johnw> actually, I think I can slim this down quite a bit, let me check...
17:45:16 <johnw> no, not really, n/m
17:46:36 <johnw> ah, zsol/hackage-server already exists, nice
17:53:21 <johnw> actually, it should be available in about 10 mins, it went up quick
17:55:28 <c_wraith> What's the state of the art on using ghc and ghcjs on the same codebase?  Multiple executable sections in the .cabal file? Can you specify the compiler in an executable section in the .cabal file?
17:57:21 <c_wraith> Hmm.  Looks like that isn't going to work.
18:01:24 <ydl> is Control.Lens.Fold a strict generalization of Control.Foldl? i also mean in the sense that the performance gains of Control.Foldl are also present in Control.Lens.Fold?
18:02:20 <c_wraith> ydl: No.  Lens doesn't always choose the fastest option, in order to find the most compatible one.
18:03:12 <c_wraith> ydl: things in Control.Lens.Fold tend to go through the Applicative instance for Const a, which means monoidal composition, which isn't always the best approach.
18:07:40 <ydl> c_wraith: but is it reasonable to expect GHC to optimize that away? Control.Foldl also requires some GHC magic to be performant anyway. i see what you're saying though, i wasn't thinking of that detail, more just the guarantee that you will only do one "pass" through the fold.
18:07:44 <Welkin> have you aussies seen this? https://en.wikipedia.org/wiki/File:CSIRO_ScienceImage_10713_Cooloola_Monster.jpg
18:08:46 <c_wraith> ydl: I would only expect GHC to optimize that away in rare cases not involving recursion.
18:08:51 <peddie> Welkin: probably #haskell-offtopic?
18:15:15 <c_wraith> ydl: as a general rule, everything in lens is designed to optimize down to a single pass through the data structure.  So they should have that much in common.
18:18:21 * hackagebot papa-prelude 0.0.2 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-0.0.2 (TonyMorris)
18:18:57 <Welkin> pap-prelude? okay now
18:19:04 <Welkin> that's just weird
18:19:10 <Welkin> must have a pap smurf obsession
18:19:15 <Welkin> papa-prelude*
18:19:28 <Welkin> papa smurf*
18:20:00 <Welkin> I wonder if you add a stutter into your package name, people will pronounce it that way
18:20:13 <Welkin> p-p-picnic-time
18:50:58 <wedify> does cabal have a way of listing packages that aren't depended on by other packages?
18:51:33 <slack1256> locally?
18:51:42 <slack1256> or on hackage?
18:51:57 <wedify> locally
18:52:44 <geekosaur> no, since it's just formatting what ghc-pkg says
18:52:44 <wedify> i want to write an "update" script which takes a list of packages, nukes everything and then reinstalls the list
18:53:13 <geekosaur> (also every package depends on one of base, haskell98, or haskell2010 --- which cannot be updated)
18:53:43 <slack1256> wedify: ghc-pkg dot seems to help with what you do
18:53:54 <slack1256> you have to convert the dot file to a png first
18:54:07 <wedify> geekosaur: would ghc-pkg unregister leave those alone?
18:54:17 <slack1256> I highly doubt that your goal is a correct answer to that problem
18:54:19 <geekosaur> no, it's not smart enough to do that
18:54:50 <wedify> slack1256: do you have a proposal?
18:55:31 <wedify> i guess i could just manually write the lists. i'm trying to only have apps in the global space
18:55:39 <wedify> so it would be a short list
18:55:53 <wedify> i just don't want to forget something
18:56:06 <geekosaur> possibly the right way to do this is to install a bindist in a nonstandard location and then look at its global package list
18:56:19 <geekosaur> those will be the packages you can't safely reinstall or remove
18:57:37 <lpaste> geekosaur pasted “compiler-provided global packages” at http://lpaste.net/187097
18:58:02 <geekosaur> (or, find someone who doesn't install anything globally so the global list is the compiler provided list :)
18:58:12 <geekosaur> note that versions will differ for ghc8
19:02:38 <wedify> ghc-pkg gives me two lists. one of packages in /usr/lib and another for packages in ~/.ghc
19:03:04 <wedify> it seems like it would be safe to nuke the ones in my home dir and leave the ones in /usr/lib?
19:03:10 <geekosaur> yes, the first one is the global list, the second the per-user list
19:03:24 <geekosaur> (sandboxes "take over" that one)
19:04:17 <wedify> how do you guys keep your applications up to date? 
19:05:44 <wedify> i would like to have a rolling release type thing where everything is the newest possible when i update
19:06:19 <geekosaur> oh also applications don't show up unless they also have libraries (so for example that list I pasted doesn't include alex or happy both of which are installed from the same place as the compiler)
19:13:26 <wedify> does stack offer functionality like i'm looking for?
19:20:12 <glguy> wedify: I use cabal update, then I run this to check if newer versions of things have come out https://github.com/glguy/GhcPkgUtils
19:20:43 <glguy> and and then I use that to unregister old things and to build projects against the new versions of things
19:22:01 <wedify> glguy: cool. thanks
19:22:52 <yyyyy> wedify: i clone the app repositories and do `stack build` followed by `stack install`. if the project is not using stack, i `stack init` first. you could do the same with `cabal sandbox`, but compilation times will be longer.
19:23:11 <yyyyy> and you'll waste a lot of space
19:23:33 <jonored> nix probably does it pretty easily, but at even more space cost if you update frequently.
19:24:47 <yyyyy> you can of course copy the executables out of the dist directory created by `cabal sandbox` after building it to reclaim space.
19:24:51 <jonored> (well, and don't keep up with reclaiming old generations.)
19:25:09 <yyyyy> (and destroy the sandbox)
19:25:23 <yyyyy> jonored: how do you do something similar with nix?
19:25:39 <slack1256> hdd space is cheap, this netbook has 500GB and is from 2012. Nixos works like a charm ;-)
19:25:42 <wedify> i guess i could have a sandbox in my home dir. then when i update i delete the sandbox
19:26:14 <yyyyy> wedify: the advantage of stack in this case is that you reuse compiled packages and avoid recompiling things.
19:26:46 <glguy> If you're chasing the nightly resolver to stay up to date you'll still accumulate lots of packages just the same
19:26:47 <jonored> yyyyy: I haven't dug into how the nix expressions for haskell packages get generated, but I think it probably looks like "regenerate it, and tell nix to update your user environment".
19:26:50 <yyyyy> slack1256: i'm on the opposite side. i have a 128 GB SSD. every MB counts.
19:27:10 <slack1256> but I am sure it is really really fast ;-)
19:27:40 <slack1256> ideal setup, root and /nix/store on a SSD, media and doc on a HDD (or nfs whatever)
19:27:41 * jonored has a 500GB SSD that it wasn't worth not bumping to... it's a bit slow because there's an IDE layer in there.
19:28:00 <jonored> (Old laptop.)
19:29:00 <yyyyy> the desktop has an SSD and HDD, but this here is a notebook. getting a big SSD is still expensive, and i can't fit more on this dell.
19:29:31 <yyyyy> jonored: is it one of those 8 MB SSD + rest HDD?
19:30:09 <jonored> yyyyy: Nope. It's much, much too tiny for that - it had to fit with it's adapter into a 2.5" laptop HDD slot.
19:30:11 <slack1256> (sorry guys, I know I started speking of HDD/SSD, but maybe this belongs to #haskell-blah)
19:48:31 <fresheyeball> hey haskellers
19:49:04 <fresheyeball> so I want to parse a string like this "(True || False) && howdy)"
19:49:32 <fresheyeball> into an AST like this `P (T :| F) :& V "howdy"`
19:50:02 <fresheyeball> I'm looking at attoparsec
19:50:16 <fresheyeball> but it feels like sandblasting a soup cracker with this
19:50:32 <Welkin> fresheyeball: is this for an elm thing?
19:50:44 <fresheyeball> its a Haskell thing
19:50:51 <fresheyeball> there is no attoparsec in Elm
19:51:04 <Welkin> I thought you might be working on the elm language
19:51:15 <fresheyeball> I am working on Elm stuff
19:51:19 <Welkin> I see you have a lot of elm packages
19:51:26 <fresheyeball> but I am not yet skilled enough with compilers to actually write one
19:51:35 <fresheyeball> yeah I have elm stuff up
19:51:45 <fresheyeball> I should publish some of my haskell stuff
19:52:16 <fresheyeball> its kind of crazy to get recognized for my Elm packages
19:52:33 <fresheyeball> anyway, I am building this crazy thing
19:52:47 <fresheyeball> https://gitlab.com/fresheyeball/shrink-boolean
19:52:58 <fresheyeball> just for fun
19:53:17 <fresheyeball> it already does a good job shrinking boolean expressions
19:53:42 <fresheyeball> but I want to parse Haskell/Elm/PureScript to my AST
19:53:47 <fresheyeball> and print back
19:53:55 <fresheyeball> so I can integrate with my ide
19:54:01 <fresheyeball> and get boolean simplification for free all the time
19:54:09 * Welkin slaps dmj with a burrito trout
19:54:36 <fresheyeball> its such a simple mapping 
19:55:01 <fresheyeball> I don't think I need all the bells and whistles/ learning curve of attoparsec
19:55:29 <fresheyeball> or atleast the language def token lexing stuff I see in tutorials
19:55:36 <fresheyeball> maybe attoparsec is still right idk
19:55:47 <fresheyeball> anyway, I'm looking for advice 
19:56:12 <fresheyeball> how can I do this simply without having to learn a giant parser library first
19:56:14 <fresheyeball> ?
19:56:47 <ydl> is there a function in lens with type (a -> b) -> Lens.Fold s a -> Lens.Fold s b? I ask because I think the following is an implementation: map f fold = fold . (.) contramap f . flip (.) f? and if so, why is Lens.Fold s not a functor?
19:58:59 <fresheyeball> no help?
19:59:28 <fresheyeball> Welkin: if the answer is really 'deal with it, there is going to be learning curve, use all the things' thats fine too
20:00:00 <Welkin> I can't hep you fresheyeball 
20:00:02 <Welkin> help*
20:00:07 <fresheyeball> aww
20:00:11 <Welkin> I don't really understand what you are trying to do even
20:00:11 <Welkin> haha
20:00:28 <fresheyeball> I just want to parse a String to an ADT
20:00:32 <Welkin> parse the string into an AST, siplify the expression, then convert it back to a string?
20:00:40 <Welkin> simplify*
20:00:48 <fresheyeball> shh, and AST as and ADT
20:00:49 <fresheyeball> yes
20:00:56 <fresheyeball> just parse to AST, and back to String
20:01:01 <glguy> yes, attoparsec can do that
20:01:08 <dmj> Welkin:?
20:01:14 <fresheyeball> glguy: ok!
20:01:23 <Welkin> dmj: hi
20:01:33 <fresheyeball> so, how would you recommend doing this in attoparsec?
20:02:03 <glguy> ydl: Fold can't be a functor, it's a type synonym
20:02:04 <fresheyeball> is there a simple path? or should I bite the bullet and learn all the fancy attoparsec modules
20:02:09 <ayayayao> Should I need to use FlexibleContexts with Parsec? Should I need to use type signatures for my parsec parsers if I havne't yet used them? Should I use Megaparsec instead of Parsec? Should I use Earley instead? Are there any Parsec tutorials where a language is implemented?
20:02:16 <glguy> for a more complicated type
20:02:35 <Welkin> ayayayao: slow down
20:02:44 <fresheyeball> Nothing wrong with FlexibleContexts
20:03:12 <glguy> fresheyeball: what have you tried so far? have you used attoparsec?
20:03:24 <fresheyeball> I've not used attoparsec yet
20:03:36 <fresheyeball> I am trying to learn it, and have a simple problem picked out
20:03:40 <Welkin> isn't it just like parsec?
20:03:48 <Welkin> almost the same api
20:03:51 <fresheyeball> I've not used parsec either
20:04:06 <fresheyeball> for whatever reason, I've not needed to until now either
20:04:39 <Welkin> my first haskell project was using parsec to write myself a scheme :D
20:05:12 <fresheyeball> crazy
20:05:28 <glguy> ayayayao: you'll only need Flexible Contexts if you try to write type signatures that are somewhat general, but it's not a requirement
20:06:21 <glguy> like trying to be general in the steam type but not the token type
20:07:25 <glguy> even if you don't use a definition it still has to have a type and ghc want you to use the extension is the inferred type requires it
20:07:28 <fresheyeball> I could write this as a simple function using pattern matching on strings
20:07:32 <fresheyeball> that feels like the wrong way though
20:08:31 <ydl> glguy: fine, it can't be made a functor without a newtype. that said do you know of a function like the one I wrote?
20:20:16 <dfeuer> carter, why the heck is an STException a wrapped ()?
20:21:52 <carter> dfeuer: cause I wanted to make sure it was a heap pointer that you couldn't do bad stuff with if you got too clever. 
20:21:56 <semigroup> Is there a class out there that provides a "nor" version of things that implement Alternative?
20:21:58 <glguy> ydl: (\f l -> l . to f) :: (a -> b) -> Fold s a -> Fold s b
20:22:09 <carter> dfeuer: I just need a mono type to unsafe coerce to
20:22:19 <dfeuer> carter, why do you need anything to unsafeCoerce to?
20:22:40 <dfeuer> (If you do, the approved type is Any, not (), but I don't see why you do)
20:24:26 <dfeuer> carter, another question is why you have   unsafeIOToSTE (IO io) = STE (\s-> unsafeCoerce io s)  instead of just unsafeIOToSTE = unsafeCoerce
20:25:55 <dzack> Hi guys - I'm thinking about giving a "Intro to Category Theory and Haskell" sort of talk in a few weeks, does anyone have any resources they'd recommend for that sort of thing?
20:26:05 <dfeuer> dzack, where?
20:26:34 <dzack> dfeuer: It'll just be through my uni's math department
20:26:56 <dzack> The audience will be a mix of pure/applied math majors, and maybe some math/cs folks as well
20:27:57 <carter> dfeuer: it's only used locally and in a saturated way.  Also I don't like point free style
20:27:59 <dfeuer> carter, oh, I see... the problem is the Typeable constraint... Still, this does not look like the right workaround.
20:28:13 <carter> dfeuer: it works
20:28:27 <dfeuer> It's gross. Let me see if I can fix it or not...
20:28:50 <carter> If you can get a simpler thing to work  on the same or larger range of ghc versions then yay
20:28:50 <dfeuer> (partially fix it, that is)
20:29:01 <dfeuer> (it's inherently going to be a bit gross)
20:29:22 <carter> Which part would you fix? My double boxing siliiness ?
20:30:00 <dfeuer> Yes, and I don't think it makes sense to dig those Eithers all the way to the bottom. I think the fundamental running operation should take (e -> b) and (a -> b) functions.
20:30:37 <carter> Eh, that's not gonna be an inner loop issue though.
20:30:51 <carter> But cps can be nice
20:30:59 <dfeuer> It's already CPS.
20:31:03 <carter> Heh
20:31:17 <dfeuer> You should also offer a non-CPS version for convenience, but as long as it's CPS you might as well go all the way.
20:31:52 <carter> What would be the not cps version? Just return either?
20:32:21 <dfeuer> Yeah.
20:32:23 <carter> I guess the full cps one would avoid an allocation
20:32:36 <dfeuer> I'm working on this; I'll have something tonight, probably.
20:32:41 <carter> That pair of additions I'm def ok with doing
20:32:54 <dfeuer> And getting rid of the double boxing and using Any instead of ().
20:32:56 <carter> Split that part out from the other changes
20:33:15 <carter> dfeuer: some type fam changes happened to any at some point
20:33:22 <dfeuer> Doesn't matter.
20:33:22 <carter> I was using any before
20:33:29 <dfeuer> It's always been a safe target for unsafeCoerce.
20:33:33 <carter> But then I got weird errors
20:33:45 <dfeuer> Weird compiler errors?
20:33:54 <carter> dfeuer: not sure with new runtime reps
20:34:21 <carter> I'm crashing. But make a clone and setup Travis ci on your re
20:34:22 <dfeuer> All you need is a stuck type of kind *  (TYPE LiftedPtrRep or whatever it's called)
20:34:32 <carter> Repo and have at it
20:34:33 <carter> Yeah
20:34:59 <carter> I'm a bit spread thin the next day or so. But these sound solid.
20:35:34 <carter> Could you have the handle foo stuff be a seperate pr then the internals stuff?
20:35:52 <dfeuer> foo?
20:35:55 <carter> But yeah, as long as it's wall clean on 7.4 - master
20:36:04 <carter> RunSte variants
20:36:10 <dfeuer> When did KindSignatures become available?
20:36:14 <dfeuer> Yeah, I can make that separate.
20:36:39 <dfeuer> But those require a major version bump; internals don't.
20:36:42 <carter> dfeuer: I think Hvr has a doc on that
20:36:51 <carter> Nah. Just minor version bump
20:37:21 <carter> But either way, want those changes in different PRs cause they are different types of code review :)
20:38:08 <carter> That are logically unrelated :)
20:38:20 <dfeuer> Suuuure.
20:39:44 <carter> But yeah, if you look In the repo history I think I had Any at some point
20:40:00 <carter> Or maybe that made typeable barf??
20:40:24 <carter> Forget. Anyways. Sounds like we're on the same page.
20:40:42 <carter> Night!
21:01:27 <Gurkenglas> Golfing around, I hit upon a weird stack overflow: Why does the second work and the first doesn't? http://lpaste.net/4168029400127766528
21:03:24 <Cale> In the second one, g isn't recursive, is that intentional?
21:04:10 <amalloy> it's mutually recursive with h, isn't it?
21:04:25 <Cale> Well, okay, but it's not recursive in the way that foldr would make it :)
21:04:31 <Gurkenglas> Cale still found the error though, it's less recursion, shoulda seen that
21:04:54 <Gurkenglas> Grr when everything is strings the compiler stops catching errors
21:08:47 <geekosaur> mmm, stringly typed
21:09:17 <dfeuer> When I compile a package with stack build, how can I pass ghc -ddump-simpl *and see the output*? 
21:09:34 <dfeuer> I'm passing this option all different ways, but I can't figure out if/where it's being logged.
21:09:47 <dfeuer> This is driving me crazy.
21:10:00 <dfeuer> Anyone know?
21:11:17 <geekosaur> logfiles should be documented somewhere, but you could try -ddump-to-file and look among the build artifacts
21:12:04 <semigroup> dfeuer: have you tried looking in .stack-work/logs/ ?
21:12:34 <dfeuer> semigroup, yeah. There's stuff in there for the dependencies that were built....
21:12:39 <dfeuer> And test log stuff
21:12:49 <dfeuer> but no actual this-package log that I can find.
21:13:24 <semigroup> Hmm, that shouldn't be the case. When I look in .stack-work/logs, log for my package are also in there as the package name
21:13:43 <dfeuer> Nada.
21:13:56 <geekosaur> odd
21:14:22 <[k-> there is a flag, i think its called --ghc-opts
21:14:45 <dfeuer> [k-, yeah, that should make GHC genrate the stuff. But it seems to go down a black hole.
21:15:59 <dfeuer> Or something. I don't get it
21:17:49 <[k-> I remember generating core before and seeing the output... it just dumped it into my terminal
21:18:00 <semigroup> dfeuer: did you see this issue?
21:18:02 <semigroup> https://github.com/commercialhaskell/stack/issues/1727
21:18:24 * hackagebot snowflake-core 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/snowflake-core-0.1.0.0 (KaiJia)
21:18:26 * hackagebot text-zipper 0.7.1 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.7.1 (JonathanDaugherty)
21:18:28 * hackagebot brick 0.9 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.9 (JonathanDaugherty)
21:18:30 * hackagebot lazy-io-streams 0.1.0.0 - Get lazy with your io-streams  https://hackage.haskell.org/package/lazy-io-streams-0.1.0.0 (lukec)
21:18:32 * hackagebot XMLParser 0.1.0.4 - A library to parse xml  https://hackage.haskell.org/package/XMLParser-0.1.0.4 (AlanHawkins)
21:18:32 <dfeuer> semigroup, ooh, thanks! 
21:19:14 <geekosaur> huh
21:22:03 <dfeuer> semigroup, that's a pretty seriously non-obvious place to stick logs....
21:22:44 <semigroup> Indeed. Also surprising to learn that logs end up in a totally different place for GHCJS, which is what I mostly use these days
21:22:46 <semigroup> :/
21:23:34 * hackagebot papa-prelude 0.1.0 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-0.1.0 (TonyMorris)
21:40:32 <[k-> is ghcjs preferred to haste?
21:40:45 <geekosaur> depends on what you are doing
21:42:17 <[k-> what are their usecases?
21:42:52 <geekosaur> haste is more limited but the generated code is smaller and faster and it's more JS-native. ghcjs is about as complete as it's possible to get, but comes with a huge runtime and the code is generally slower so it can get the behavior exactly right intead of relying on JS native behavior being "close enough"
21:44:00 <[k-> I tried to compare the equality of arrays in js, and I gave up when I found out how js tests for equality
21:44:58 <[k-> so for haste, if you are relying on a small set of ghc functionality, it would be better to use it?
21:46:28 <geekosaur> probably, yes. basically it's a Haskell-lite you can use where you'd otherwise use JS snippets in web programming.
21:47:31 <kadoban> Err, haste says it's "the full Haskell language, including GHC extensions". Am I missing fine-print somewhere? What does it not do that GHCJS does?
21:47:39 <kadoban> I didn't think it used to say that ...
21:48:51 <kadoban> Oh, "except Template Haskell" that's pretty big.
21:50:05 <geekosaur> the fine print is also likely to involve haste sticking closer to JS data semantics instead of strict Haskell (i.e. using JS native data types instead of emulating Haskell core types; this will be most relevant for numbers, I suspect)
21:51:07 <kadoban> Hmm
21:52:00 <geekosaur> (i.e. if you pretend a JS decimal type is an Int, it will be fast but you may manage to accumulate some "fuzz"; ghcjs will get exact results but be slow and pedantic about it)
21:53:08 <kadoban> That's a kind of interesting distinction. I wonder how much that actually comes up. GHCJS is working pretty well for me though, so I doubt I'll actually try the other side.
21:54:03 <geekosaur> probably about as much as FP fuzz :)
21:54:10 <geekosaur> er, floating point
21:54:31 <kadoban> Hehe
22:07:56 <dfeuer> GRRR... Now I can't figure out where stack test puts the bleeping test logs.
22:08:00 <dfeuer> This is really driving me nuts.
22:18:25 * hackagebot multifile 0.1.0.0 - create many files from one  https://hackage.haskell.org/package/multifile-0.1.0.0 (AlanHawkins)
22:18:27 * hackagebot papa-base 0.1.0 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-base-0.1.0 (TonyMorris)
22:32:47 <jle`> dfeuer: let me know if you ever figure it out, i sort of gave up looking for them a while ago
22:33:14 <dfeuer> jle`, this is ridiculous.
22:33:48 <dfeuer> jle`, let me take that back.
22:33:53 <dfeuer> I found them.
22:33:56 <dfeuer> Sort of.
22:34:04 <jle`> to be fair i didn't look very hard
22:34:11 <dfeuer> The first time, they didn't show because I segfaulted, killing HSpec.
22:34:34 <dfeuer> wait...
22:34:43 <dfeuer> er...
22:35:39 <dfeuer> jle`, never mind, I didn't find them.
22:35:53 <dfeuer> I found a log I got via cabal after I gave up finding the stack one.
22:36:02 <dfeuer> Ridiculous.
22:39:42 <jle`> have you asked #haskell-stack ?
22:40:03 <jle`> you might have better luck than i did when i asked a couple of months back
23:05:26 <kadoban> jle`: What kind of logs are these? What package can I try that'll give the logs you're talking about? The testing thing(s) I use don't seem to have logs.
23:06:38 <kadoban> Also, you looked in .stack-work/logs/ I assume?
23:13:03 <raduom> hi. are there any downsides to using the eff monad?
23:13:34 <johnw> raduom: https://www.reddit.com/r/haskell/comments/3nkv2a/why_dont_we_use_effect_handlers_as_opposed_to/
23:14:56 <dfeuer> They're also complicated as #%@!
23:15:11 <glguy> Is that a lens operator?
23:18:05 <dfeuer> glguy, it's what you say when you can't figure out what the lens operator you need is called.
23:18:26 * hackagebot huff 0.1.0.0 - A fast-foward-based planner  https://hackage.haskell.org/package/huff-0.1.0.0 (TrevorElliott)
23:33:33 <[k-> dfeuer: I like that joke :D
23:34:14 <bizarrefish> Wouldn't it be possible to go one step further than do-notation, and have an operator of type: M t -> t ?
23:34:46 <bizarrefish> This operator would expand to a 'bind'
23:35:07 <peddie> bizarrefish: can you define this operator?
23:36:08 <liste> :t extract
23:36:10 <lambdabot> error: Variable not in scope: extract
23:36:40 <liste> :t extract
23:36:42 <lambdabot> Comonad w => w a -> a
23:36:55 <bizarrefish> Hang on, I'm talking about this: (a -> M b) -> (c -> M a) -> (c -> M b)
23:36:59 <bizarrefish> Not sure what that is
23:37:03 <liste> :t >>=
23:37:04 <bizarrefish> But I bet it exists
23:37:05 <lambdabot> error: parse error on input ‘>>=’
23:37:07 <liste> :t (>>=)
23:37:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:37:14 <liste> :t (>=>)
23:37:16 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:37:22 <bizarrefish> Yes!
23:37:30 <liste> aka 'the fish operator'
23:37:53 <ngWalrus> that's one bizarre fish
23:37:54 <bizarrefish> Right. So in haskell, this is a fairly trivial thing to do without any special syntax, thanks to function currying
23:38:35 <pavonia> :t (<=<)
23:38:37 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
23:38:39 <bizarrefish> I actually was thinking about non-haskell languages. An example of this kind of thing is the 'await' operator in C#
23:39:49 <cocreature> liste: if >=> is the fish operator, what do you call >->? :)
23:39:58 <bizarrefish> Basically, I wanted to be able to write a normal function, but have an operator which transforms into a bind
23:40:35 <liste> cocreature: id, fishbone maybe?
23:40:56 * bizarrefish approves the name 'fish operator'
23:41:37 <cocreature> liste: that’s a decent name :)
23:41:53 <bizarrefish> Also, anorexifish
23:42:11 <bizarrefish> Or headless-guy
23:42:37 <Forlorn> how can I make a function that checks if an array contains an even number and then returns True?
23:43:03 <ongy> :t any
23:43:05 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
23:43:10 <Forlorn> thanks
23:43:22 <ongy> that is if your array is an instance of Foldable
23:43:53 <Forlorn> oh, perhaps I should call it List, not array?
23:44:10 <Forlorn> linked list
23:45:12 <liste> Forlorn: depends on if it's a list or an array. [1,2,3] is a list
23:45:37 <Forlorn> ah, that's what I am using a list
23:45:45 <Forlorn> using, a list
23:45:47 <Forlorn> *
23:49:20 <bizarrefish> Damn, that fish operator is cool
23:49:26 * bizarrefish is playing with it
23:49:40 <liste> :t Kleisli -- check this out too
23:49:42 <lambdabot> (a -> m b) -> Kleisli m a b
23:50:43 <bizarrefish> So, that's the type of the bind-function
23:50:52 <bizarrefish> So >=> composes those
23:50:56 <liste> it's the Category instance of Monad
23:51:46 <liste> and Arrow
23:52:05 <bizarrefish> 1mo gotta go to wrork
23:52:06 <bizarrefish> *work
23:52:17 <bizarrefish> thanks for helping with my fish problem
