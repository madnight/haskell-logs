00:07:39 * hackagebot papa-base 0.1.0 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-base-0.1.0 (TonyMorris)
00:07:39 * hackagebot huff 0.1.0.0 - A fast-foward-based planner  https://hackage.haskell.org/package/huff-0.1.0.0 (TrevorElliott)
00:22:34 * hackagebot result 0.2.5.0 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.2.5.0 (srijs)
00:22:36 * hackagebot HDBC-session 0.1.1.0 - Bracketed connection for HDBC  https://hackage.haskell.org/package/HDBC-session-0.1.1.0 (KeiHibino)
00:22:38 * hackagebot huff 0.1.0.1 - A fast-foward-based planner  https://hackage.haskell.org/package/huff-0.1.0.1 (TrevorElliott)
01:22:35 * hackagebot papa-include 0.1.0 - Third party libraries  https://hackage.haskell.org/package/papa-include-0.1.0 (TonyMorris)
01:22:37 * hackagebot papa-prelude 0.1.1 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-0.1.1 (TonyMorris)
01:22:39 * hackagebot papa 0.1.0 - Reasonable default import  https://hackage.haskell.org/package/papa-0.1.0 (TonyMorris)
01:36:19 <ventonegro> Hi, is there a library for calculating the unique suffixes for strings in a list?
01:41:48 <srhb> ventonegro: suffixes how?
01:44:28 <ventonegro> srhb: Let's say, given ["abcmno", "abcxyz", "abcd"] it would return ["mno", "xyz", "d"]
01:45:13 <srhb> ventonegro: A suffix tree library might be useful there.
01:45:26 <ventonegro> srhb: Bad example, actually ["xyzabc", "mnoabc", "dabc"] -> ["zabc", "oabc", "dabc"]
01:48:18 <ertesx> ventonegro: depending on the use case you might be interested in a radix tree
01:51:00 <ertes> unfortunately the bytestring-trie library is the only useful implementation i'm aware of, and it's hardcoded to use ByteString
01:51:18 <merijn> ertes: Maybe we can backpack-ify it soon ;)
01:51:53 <ertes> merijn: what does that mean?
01:55:04 <ertes> ah, i think i found it
01:55:34 <ertes> <http://plv.mpi-sws.org/backpack/>; this?
01:55:38 <ventonegro> ertes: Thanks, I'll investigate in that direction
01:57:10 <merijn> ertes: The stuff ezyang is working on
01:57:31 <merijn> ertes: There was an email on the proposal to backpack-ify base
01:57:51 <merijn> ertes: http://blog.ezyang.com/category/haskell/backpack/
01:58:04 <merijn> Which also has background info
02:02:57 <ertes> will this be in GHC in the foreseeable future?
02:07:08 <merijn> Backpack is slated to be merged into 8.2 if ezyang gets his way
02:07:21 <merijn> Although it'll be experimental at that point
02:07:54 <buttbutter> How can you cast between type synonyms?
02:08:18 <merijn> buttbutter: Type synonyms are literally aliases
02:08:29 <merijn> buttbutter: So they're exactly the same type
02:08:43 <merijn> buttbutter: Additionally, there's no real notion of "casting" in haskell
02:09:20 <buttbutter> I understand that, but for example. If I have type Height = Int. If I then have an instance of a Height and ask GHCI to report on its type, it will return Height.
02:09:29 <buttbutter> I need GHCI to return Int C:
02:09:36 <buttbutter> (After "casting")
02:09:54 <buttbutter> Is that a possibility?
02:10:09 <ongy> try :t (a :: Int)
02:10:15 <ongy> if your variable is called a
02:10:52 <merijn> buttbutter: Height and Int are literally the same. GHC(i) try to use whatever synonym is used in the source, for usability/readability reasons
02:11:08 <merijn> buttbutter: Why do you need ghci to return "Int"?
02:11:10 <buttbutter> I see.
02:11:31 <pavonia> Wasn't there a trick with :k to resolve type synonyms?
02:11:48 <merijn> pavonia: That's for type families
02:11:57 <pavonia> Ah right
02:11:58 <buttbutter> I don't *need* it. Something just feels unsavory about it.
02:12:08 <merijn> buttbutter: Why's that?
02:12:09 <buttbutter> But I understand that type synonyms are literally just two names for the same thing.
02:12:23 <buttbutter> Just a feeling :)
02:13:32 <merijn> buttbutter: Like I said, GHC just tries to be helpful. Imagine your synonym is a synonym for a line long type (I've had those) and you define a function using that synonym twice. If it used the "actual" type, it'd become rather unreadable
02:14:34 <merijn> buttbutter: I would actually recommend against a synonym like "type Height = Int", because suppose you had "type Width = Int" too, and a function "foo :: Height -> Width -> Bool", nothing would stop you from passing a "Height" as "Width" argument
02:14:55 <buttbutter> I meant Height as a person's height :)
02:15:03 <buttbutter> But I can see why that would be a bad choice in that context.
02:15:20 <buttbutter> And I guess you wouldn't want an Int for a person's height. It was just a stupid example! 
02:16:37 <merijn> buttbutter: An alternative would be to use newtype like "newtype Height = Height { getHeight :: Int }", at runtime this would be equivalent to an Int, but the typechecker wouldn't allow mixing them with Int
02:16:59 <merijn> (The record syntax is there to generate a helpful "getHeight :: Height -> Int")
02:17:09 <merijn> Whether that's worth the effort, depends on the code :)
02:18:14 <buttbutter> Neat, I didn't know record syntax would disallow mixing.
02:18:44 <merijn> buttbutter: It's not the record syntax that disallows it. It's the newtype :)
02:19:17 <ertes> buttbutter: regarding type equality: think filenames and inodes on unix =)
02:19:20 <merijn> buttbutter: That's the entire meaning of newtype "I want to create a new type that is identical to this one, but the type checker should yell at me to do the conversion"
02:21:27 <NickHu> If the compiler recognises the newtype as an Int, then what does it actually do with the getHeight function?
02:21:54 <NickHu> Is it just a piece of information passed to the typechecker to say "yeah, let this typecheck as an Int"
02:22:40 <ertes> (if you came from a language that has this notion of "object identity", then i can see why type equality may feel uncomfortable)
02:24:10 <geekosaur> NickHu, pretty much. the newtype itself is just a figment of the typechecker's imagination, and getHeight exists solely to maintain the figment. after the typechecker is done, the newtype is gone and getHeight vanishes with it
02:24:43 <implementation> getHeight = id :)
02:24:46 <NickHu> I see
02:24:58 <buttbutter> merijn: I see :D
02:25:01 <buttbutter> Thanks :)
02:25:02 <NickHu> implementation: It doesn't have the right type to be id lol
02:25:23 <geekosaur> there are no types by that point, so effectively that is correct
02:25:41 <implementation> NickHu: but it behaves like id. the different type is the sole purpose of getHeight
02:26:24 <geekosaur> but in practice it's a bit more complex; there are a few circumstances in which it really does generate what amounts to an untyped id. this is why you see some users of newtypes reaching for unsafeCoerce, to make that generation not happen
02:26:25 <kostja> Hello! What is the difference between MonadPlus and Alternative?
02:26:26 <NickHu> I suppose id before the typechecking and id after the typechecking would in this case be two different things
02:26:53 <NickHu> kostja: Alternative is like an Applicative and a Monoid rolled into one, MonadPlus is like a Monad and a Monoid rolled into one
02:27:27 <NickHu> Is the reason MonadPlus isn't a subclass of Alternative also historical, or is there actually a decent reason for this?
02:28:25 <kostja> NickHu: There is an instance Alternative m, Monad m => MonadPlus m
02:28:36 <implementation> kostja: Alternative is for Applicatives and MonadPlus is for Monads. in earlier times, not every Monad was an Applicative, so the same thing exists two times.
02:28:54 <ertes> note that this is when Data.Coerce is useful
02:29:23 <ertes> :t Data.Coerce.coerce getSum :: [Sum] -> [Int]
02:29:25 <lambdabot> error:
02:29:25 <lambdabot>     ‚Ä¢ Expecting one more argument to ‚ÄòSum‚Äô
02:29:25 <lambdabot>       Expected a type, but ‚ÄòSum‚Äô has kind ‚Äò* -> *‚Äô
02:29:29 <ertes> :t Data.Coerce.coerce getSum :: [Sum Int] -> [Int]
02:29:31 <lambdabot> error:
02:29:31 <lambdabot>     ‚Ä¢ Couldn't match representation of type ‚Äòa0‚Äô with that of ‚Äò[Int]‚Äô
02:29:31 <lambdabot>         arising from a use of ‚ÄòGHC.Prim.coerce‚Äô
02:29:36 <implementation> kostja: it's a little like with fmap vs liftM, pure vs return, ap vs <*>, etc
02:29:46 <ertes> huh?
02:29:50 <NickHu> Also I always found it strange how the MonadPlus doesn't impose a requirement of a Monoid instance
02:29:54 <ertes> this is supposed to work‚Ä¶
02:30:21 <kostja> so MonadPlus is redundant
02:30:43 <ertes> kostja: MonadPlus is a historical accident
02:30:48 <ertes> if you can, just ignore it
02:32:19 <NickHu> Why isn't the typeclass of Alternative something like class (Applicative f, Monoid f) => Alternative f?
02:32:40 <ertes> NickHu: because that's a kind error
02:34:10 <implementation> f :: * -> *; Monoid :: * -> Constraint; so (Monoid f) doesn't work.
02:34:37 <kostja> thank you! I thought MonadPlus would have a different meaning. Something like Monad m, Monoid e => StateT e m
02:34:53 <kostja> where the MonadPlus instance would merge the state
02:35:25 <kostja> and then I was puzzled why there would be a default intance for Alternatives
02:36:05 <merijn> ertes: Does Sum have the correct role annotations?
02:36:56 <ertes> merijn: d'oh
02:37:03 <ertes> :t Data.Coerce.coerce :: [Sum Int] -> [Int]
02:37:05 <lambdabot> [Sum Int] -> [Int]
02:37:08 <ertes> there we go =)
02:37:08 <kostja> also the MonadPlus instance of Maybe feels wrong. Because the implementation depends on the choice which component gets ignored. (And if an implementation depends on a choice, it will always be the wrong choice for someone.)
02:37:19 <merijn> ertes: Submit a bug report and make everyone's oh, duh
02:37:30 <ertes> merijn: somehow i used 'coerce' like 'map'
02:37:34 <ertes> coerce getSum -- wrong
02:37:56 <merijn> kostja: For every valid MonadPlus there are necessarily AT LEAST two valid MonadPlus instances
02:38:07 <merijn> kostja: Similarly, every Monad is one of AT LEAST two valid Monoids
02:38:10 <merijn> eh
02:38:13 <merijn> s/Monad/Monoid
02:38:17 <ertes> merijn: it's not a bug, it's me being stupid =)
02:38:26 <merijn> ertes: Yeah, I completely read over it too :p
02:38:28 <NickHu> merijn: How so?
02:38:39 <merijn> NickHu: "flip mplus"
02:38:57 <merijn> NickHu: and "flip mappend"
02:39:09 <NickHu> ooh
02:39:18 <merijn> In fact, there's Data.Monoid.Dual, which does that
02:39:25 <NickHu> And in the case of lists, you also have ZipLists I suppose
02:39:25 <merijn> (for monoids)
02:39:42 <NickHu> So that makes at least 4 list instances of monoid right?
02:39:48 <kostja> merijn: we should probably introduce a newtype Commutator m and an instance (Monoid m) => Monoid (Commutator m) where one flips mplus
02:40:01 <merijn> NickHu: ZipList doesn't work as monoid, I think
02:40:03 <implementation> kostja: already exists
02:40:12 <kostja> merijn: oh, I'm typing to slow
02:40:17 <kostja> thank you very much!
02:41:21 <merijn> kostja: So the answer is, there's usually lots of possible instances for these things and people pick the one that seems most obvious/useful
02:41:28 <kostja> NickHu: the list instance is commutative
02:41:50 <merijn> kostja: I mean, imagine Parser with an Alternative instance that tries alternatives right to left...that would be rather annoying :p
02:42:01 <mapty> hi guys, i am new to Haskell and i have this question: if i have created a module where i define a new type - data Line = Horizontal | Vertical, do i need to make a separate constructor function inside the module for the type or is there a way i can use Horizontal and Vertical directly in another file ?
02:42:59 <kostja> merijn: why? you can't predict if the most probable hits are
02:43:07 <kostja> s/if/where/
02:43:16 <implementation> mapty: if the constructors are exported, you can just use them in other modules
02:43:26 <NickHu> kostja: By that, do you mean that `mappend` is commutative for lists?
02:43:43 <kostja> NickHu: I see it is not :)
02:43:43 <NickHu> Because I don't think it is..
02:44:11 <implementation> mapty: if the first line of your module file says "module Foo where", then everything is exported, including the constructors
02:45:02 <mapty> @implementation, I am exporting it like this: module Curves (Line) where, but when i try to use Vertical and Horizontal in another file where I "import Curves" i get that they are not in the scope
02:45:02 <lambdabot> Unknown command, try @list
02:45:31 <lyxia> mapty: module Curves (Line(..))
02:45:41 <implementation> mapty: if you export Line explicitely, you need to add the constructors in round paranthenses after the type, or use (..)
02:45:41 <kostja> another question: Do you except that (+) will be ever moved to a new typclass in the default prelude? like an (abelian) group? Because Num is very odd class for such a common operator name
02:46:19 <mapty> @lyxia, @implementation oh yes ... i totally forgot about that, thank you 
02:46:19 <lambdabot> Unknown command, try @list
02:46:52 <merijn> kostja: Because most people read left to right
02:47:05 <NickHu> kostja: I feel like we already have <> for this; is there a typeclass for a monoid with a commutable operation?
02:47:09 <NickHu> What is such a structure called?
02:47:17 <merijn> kostja: "myParser = foo <|> bar" <- having to understand it tries bar first is counter intuitive :p
02:47:36 <kostja> NickHu: what with other groups, rings, or algebras? I would rather write (+) for matrix additions
02:47:38 <kostja> then <>
02:47:46 <merijn> kostja: No, I don't think the Num hierarchy will change anytime soon
02:47:52 <lyxia> mapty: you're confusing lambdabot with @ !
02:48:01 <merijn> kostja: There have been a million proposals, but all with lots of flaws
02:48:20 <merijn> kostja: Such as "people don't want to implement a million finegrained classes for their numeric types"
02:48:29 <merijn> kostja: Also, type signatures would become hell
02:48:33 <kostja> merijn: one could provide default implementations like for applicative and moand
02:48:55 <merijn> kostja: Not to mention, how do you differentiate between the Sum and Product monoids for Num, for example?
02:49:14 <srhb> ls
02:49:16 <NickHu> kostja: Matrices are more of a mathematics thing than a programming thing though
02:49:16 <srhb> woops
02:49:42 <kostja> NickHu: but numerics has a lot todo with programming
02:49:45 <NickHu> There's no "natural way" to represent a matrix on hardware
02:49:49 <NickHu> That is true
02:50:41 <kostja> merijn: AbelianGroup g => Monoid g and Group g => Monoid g
02:51:17 <merijn> kostja: That doesn't work, because that results in two Monoid instances of Int
02:52:31 <implementation> class Monoid a => DoubleMonoid a where secondEmpty 
02:52:41 <kostja> merijn: one has the same problem at the moment, so one has to wrap up Int in Sum or Product
02:52:42 <implementation> [...]
02:54:40 <phadej> implementation: secondEmpty?
02:55:12 <phadej> by monoid laws `empty` is unique
02:56:02 <ertes> (unfortunately)
02:56:05 <implementation> phadej: it's for types that have two monoids. The first is mempty/mplus, the second is secondEmpty/secondPlus *gg*
02:56:32 <ertes> TheOtherMonoid
02:56:33 <implementation> like (0,+) and (1,*) for numbers
02:56:38 <phadej> implementation: you probably have those operations related, so you want to use group/field/lattice or some other name
02:57:07 <ertes> (+), (*), max, ‚Ä¶
02:58:02 <phadej> maxmin is btw a lattice, http://hackage.haskell.org/package/lattices-1.5.0/docs/Algebra-Lattice-Ordered.html#t:Ordered
02:58:44 <lyxia> implementation: semirings?
02:59:16 <quchen> Is there a ByteString-prettyprinter somewhere that gives me the hexdump of the data? Like "10 a0 fe ..."
02:59:29 <quchen> I‚Äôve rewritten this countless times now :-/
02:59:49 <ertes> quchen: rewrite it once more, but this time as a library =)
03:00:04 <quchen> ertes: :>
03:00:50 <ertes> quchen: Numeric should have everything you need
03:02:08 <NickHu> Is there a way to get the kinds to line up to impose a Monoid constraint on the Alternative typeclass?
03:02:26 <ertes> :t foldr (\w -> showHex w . showChar ' ' .) id
03:02:28 <lambdabot> error: parse error on input ‚Äò)‚Äô
03:02:34 <NickHu> Should it really be there, and Haskell doesn't support it, or is there some reason to not do that?
03:02:43 <ertes> :t foldr (\w r -> showHex w . showChar ' ' . r) id
03:02:45 <lambdabot> (Foldable t, Show a, Integral a) => t a -> String -> String
03:02:54 <ertes> quchen: like that
03:03:09 <quchen> ertes: Yes, that‚Äôs that I‚Äôve got dozens of times. :-)
03:04:00 <ertes> NickHu: there is no way, and also we have Monoid and Alternative instances that disagree
03:04:10 <ertes> > Just "abc" <> Just "def"
03:04:13 <lambdabot>  Just "abcdef"
03:04:15 <ertes> > Just "abc" <|> Just "def"
03:04:17 <lambdabot>  Just "abc"
03:05:10 <ertes> it's best to think of Monoid and Alternative as unrelated, except that they represent the same algebraic structure
03:05:41 <NickHu> Oh - so does this mean that the underlying monoidal structure of the Alternative isn't necessarily the same monoid as a Monoidal instance of the functor itself?
03:06:16 <NickHu> :t (Just "abc" <>)
03:06:18 <lambdabot> Maybe [Char] -> Maybe [Char]
03:06:38 <NickHu> So <> is in the list monoid here
03:06:56 <ertes> that wording is unnecessarily convoluted; simpler:  the Alternative instance and the Monoid instance don't necessarily have the same semantics
03:06:59 <NickHu> But <|> is part of the Maybe Alternative instance
03:08:11 <implementation> :t (Nothing <>)
03:08:18 <lambdabot> Monoid a => Maybe a -> Maybe a
03:08:21 <ertes> look at the Monoid instance:  instance (Monoid a) => Monoid (Maybe a)
03:08:23 <implementation> :t (Nothing <|>)
03:08:29 <ertes> it's not "the Monoid instance for Maybe"
03:08:29 <lambdabot> Maybe a -> Maybe a
03:08:38 <NickHu> Is there also a list of standard Monads I should understand btw? I learned about ST yesterday and it was pretty interesting :)
03:08:50 <ertes> it's "the Monoid instance for (Maybe a), if a is a Monoid"
03:09:03 <NickHu> Yes I see
03:09:06 <ertes> NickHu: IO =)
03:09:13 <NickHu> Yeah, I think I have IO nailed
03:09:27 <ongy> Moand MAybe
03:09:28 <NickHu> Writer and Reader too
03:09:30 <NickHu> Yup
03:09:35 <NickHu> Maybe and []
03:09:39 <implementation> NickHu: State, STM
03:09:47 <ertes> Writer and Reader aren't that useful
03:09:59 <implementation> Q if you want to do template haskell
03:10:00 <NickHu> STM is basically like a subset of IO that can be done in a transaction, right?
03:10:12 <ertes> but to get a complete toolset of basic patterns you may want to look into the 'transformers' and 'mtl' packages
03:10:34 <ertes> an (STM A) is a memory transaction that results in an A
03:10:35 <NickHu> I have an understanding of monad transformers
03:10:39 <implementation> I think it's better not to think about STM as an IO-subset but rather as a completely different thing :)
03:11:33 <NickHu> I was going to dive into the world of lenses this afternoon
03:11:59 <ertes> NickHu: the monads i use most often (*as monads*) are:  [], IO, Maybe, StateT s m, ST s, STM
03:12:21 <ertes> rarely also:  Either e
03:12:30 <NickHu> Do you ever use [] with do notation rather than list comprehensions?
03:12:39 <ertes> oh, and of course (Codensity m) =)
03:12:50 <ertes> NickHu: i prefer do-notation over list comprehension
03:13:03 <implementation> Free is an interesting monad as well
03:13:04 <ertes> reason:  the result is at the end
03:13:37 <ertes> (ResourceT m) from the 'resourcet' package is sometimes a useful utility monad
03:14:03 <NickHu> List comprehension is syntax sugar for operations in the list monad, is it not?
03:14:28 <ertes> NickHu: you could say that‚Ä¶  there is even -XMonadComprehensions
03:14:50 <saurabhnanda> has anyone taken any remote "engineer assist" kind of consulting from FP Complete? Any reviews?
03:15:05 <NickHu> Does that generise list comprehensions to other monads?
03:15:10 <NickHu> generalise*
03:15:12 <ertes> NickHu: yeah
03:15:25 <ongy> does that make sense?
03:15:30 <NickHu> Hmm, I can't imagine what that would look like
03:15:51 <NickHu> For something like the Maybe monad I prefer to explicitly write out the binds though
03:15:56 <ertes> [ length line | line <- getLine, _ <- putStrLn line ]
03:15:57 <ertes> =)
03:17:31 <implementation> NickHu: if you want to understand lambdabot's @pl output, you should also know the (->) a and (,) a monads :D
03:17:50 <implementation> the plugin it really likes those
03:17:56 <NickHu> Mm, I know they are Monads but haven't thought very hard about what they represent as Monads
03:18:05 <ertes> > pure 5 :: (String, Int)
03:18:08 <lambdabot>  ("",5)
03:18:12 <implementation> they're essentially Reader and Writer
03:18:19 <ertes> oh, it is?
03:18:34 <mniip> ((->) e) is an environment monad
03:18:45 <mniip> every computation has access to the 'e' environment
03:18:50 <NickHu> ertes: Does that desugar to - getLine >>= (\x -> putStrLn x >> return (length x))?
03:18:55 <ertes> i didn't realise that there was a Monad instance for (Monoid e) => (,) e
03:18:55 <mniip> I haven't seen ((,) a) being used a lot
03:19:25 <ertes> NickHu: i think so‚Ä¶  not sure exactly how list/monad comprehensions desugar, but it's going to be something equivalent to that by the laws
03:19:45 <implementation> > ("1",0) >> ("234",1) >> return 5
03:19:48 <lambdabot>  ("1234",5)
03:19:54 <implementation> see, it's writer
03:20:06 <ertes> with an awkward 'tell' yeah
03:20:42 <implementation> > (let ask a = a in do a <- ask; return (a + a)) 5
03:20:45 <lambdabot>  10
03:20:55 <implementation> and (->) is Reader
03:21:04 <ertes> > snd (((), ()) >> (undefined, ()))
03:21:07 <lambdabot>  ()
03:21:33 <ertes> ok, it's just as useless as Writer =)
03:21:56 <implementation> telling `undefined` is unfair :P
03:22:31 <ertes> implementation: i'd *prefer* it to crash
03:23:22 <ertes> not crashing means that it's building up unevaluated mappends all over the place
03:24:09 <NickHu> I saw this on a stackoverflow answer about Alternative
03:24:12 <NickHu> class (Applicative f, forall a. Monoid (f a)) => Alternative''' f
03:24:18 <NickHu> What would this mean?
03:24:24 <ertes> NickHu: nothing, it's not haskell
03:24:55 <NickHu> Can't you do it with ExistentialQuantification?
03:25:03 <ertes> NickHu: it's supposed to mean:  f is an Alternative''' whenever for all a there is a Monoid (f a) instance
03:25:24 <ertes> no, the only way to bind the 'a' there is as an argument to the class
03:25:40 <ertes> class (Applicative f, Monoid (f a)) => Alternative a f
03:26:01 <NickHu> So it conveys the intent of the Applicative typeclass but is in no way actual Haskell
03:26:08 <NickHu> *Alternative
03:26:45 <ertes> not even that‚Ä¶  it's just inventing ways to force Monoid to have the same semantics as Alternative
03:28:29 <NickHu> Right, but they are actually different things so it's not correct to do that anyway
03:30:40 <ertes> some people seem to think that they should really have the same semantics when appropriate
03:31:51 <ertes> but there is no technical reason for that, and also some people disagree that they should (me included)
03:33:40 <ertes> both ((Monoid a) => Monoid (Maybe a)) and (Alternative Maybe) are useful monoids, and i wouldn't want to give either of them up for the sake of‚Ä¶  i don't even know what
03:38:14 <ongy> > Just 5 <> Just 5
03:38:21 <lambdabot>  error:
03:38:21 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M452241521874...
03:38:21 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
03:38:37 <ongy> > Just 5 <> Just (5 :: Int)
03:38:44 <lambdabot>  error:
03:38:44 <lambdabot>      ‚Ä¢ No instance for (Monoid Int) arising from a use of ‚Äò<>‚Äô
03:38:44 <lambdabot>      ‚Ä¢ In the expression: Just 5 <> Just (5 :: Int)
03:42:09 <implementation> > Just 5 <> Just (5 :: Sum Int)
03:42:11 <lambdabot>  Just (Sum {getSum = 10})
03:44:43 <ongy> can I fmap an infix operator?
03:45:00 <ongy> > fmap (<>) (Just 5) (Just (5 :: Sum Int))
03:45:03 <lambdabot>  error:
03:45:03 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòMaybe (Sum Int) -> t‚Äô
03:45:03 <lambdabot>                    with actual type ‚ÄòMaybe (m0 -> m0)‚Äô
03:45:16 <ongy> oh right, not that easy
03:45:31 <ongy> > (<>) <$> (Just 5) <*> (Just (5 :: Sum Int))
03:45:34 <lambdabot>  Just (Sum {getSum = 10})
03:45:34 <NickHu> > (Just 5) <> (Just (5 :: Sum Int))
03:45:37 <lambdabot>  Just (Sum {getSum = 10})
03:45:45 <Robin_Jadoul> ongy: liftA2, but that's Applicative
03:45:55 <NickHu> There is already a Monoid instance for Maybe a
03:46:40 <ongy> I know, I just wondered how hard it would be to simply lift mappend
03:47:53 <merijn> Robin_Jadoul: His is also applicative
03:48:00 <merijn> Robin_Jadoul: Since <*> is applicative
03:48:18 <Robin_Jadoul> merijn: I was typing that before I saw his own response :-)
03:50:47 <saurabhnanda> has anyone taken any remote "engineer assist" kind of consulting from FP Complete? Any reviews?
03:52:04 <NickHu> #haskell is the only assist you need :)
04:01:31 <int-e> ongy: regarding lambdacase, I could use a reminder the upcoming weekend... too busy with other things right now. I won't run lambdabt on Twitch IRC (why does that even exist)... Freenode by itself is more than busy enough.
04:20:18 <mapty> Hi, is there a way to print the type of a variable by using PrintStrLn (e.g. in the same way :t works) ?
04:23:25 <munja> @mapty- you can use  typeOf from Data.Typeable iirc
04:23:25 <lambdabot> Unknown command, try @list
04:23:35 <NickHu> @help
04:23:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:23:40 <NickHu> @list
04:23:40 <lambdabot> What module?  Try @listmodules for some ideas.
04:23:56 <ongy> lambdabot being helpful
04:24:03 <munja> help list
04:24:16 <munja> That's probably what you want
04:24:29 <munja> @help list
04:24:29 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
04:24:39 <tabaqui> help list
04:24:45 <mapty> @munja, so there is no built in way of doing it otherwise ?
04:24:45 <lambdabot> Unknown command, try @list
04:25:01 <Zemyla> Goodnight, cuties! ‚ô•
04:25:10 <Zemyla> Wait, wrong channel.
04:25:22 <munja> xD
04:25:42 <NickHu> lol
04:25:45 <munja> Not as far as I know
04:26:00 <ongy> Zemyla: are you saying we aren't cute?
04:26:17 <munja> :'(
04:27:17 <mapty> well thanks :) 
04:28:16 <munja> What's wrong with importing a module?
04:31:28 <ongy> :t typeOf
04:31:30 <lambdabot> Typeable a => a -> TypeRep
04:32:02 <ongy> that's interesting. Why does lambdabot show a different type (I guess they are equivalent?) than https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Typeable.html#v:typeOf
04:35:26 <munja> Yeah but it only works if the function is typeable i guess
04:37:40 <liste> ongy: do you mean the forall?
04:38:05 <ongy> yes
04:38:30 <ongy> iirc that's implicit with the output from lambdabot, but why doe they use different representations? I though both would try to mirror source
04:40:52 <merijn> ongy: lambdabot uses the signature produced by whatever GHC it is compiled with
04:41:14 <merijn> ongy: Lambdabot doesn't look at source, it uses GHC-the-library to compile stuff and query types, etc.
04:41:27 <merijn> ongy: 4.9 is for GHC 8.0, which I'm pretty sure lambdabot is NOT compiled with
04:41:43 <srhb> merijn: I think it is?
04:41:47 <srhb> How to check though...
04:41:49 <merijn> It is?
04:42:02 <ongy> wasn't there a discussion about activating TypeInType and applicative do?
04:42:14 <liste> munja: Typeable is automatically and implicitly derived for everything that can be Typeable
04:42:40 <munja> ooh
04:45:00 <bartavelle> srhb, check for a function that's only in latest base
04:45:08 <bartavelle> :info GHC.Generics.packageName
04:45:25 <bartavelle> hum :)
04:45:40 <srhb> bartavelle: If only lambdabot had :info :-P
04:45:49 <bartavelle> my thought exactly
04:45:59 <bartavelle> :t GHC.Generics.packageName
04:46:01 <lambdabot> forall k k1 (d :: k) (t :: k -> (* -> *) -> k1 -> *) (f :: * -> *) (a :: k1). GHC.Generics.Datatype d => t d f a -> [Char]
04:46:42 <bartavelle> this appeared in base 4.9 according to the changelog
04:48:49 <srhb> bartavelle: Neat. :)
04:49:46 <nmdanny> is there a function with the following signature: MonadError e m => Either e a -> m a  ?
04:50:16 <bartavelle> nmdanny, https://www.stackage.org/haddock/lts-6.16/either-4.4.1.1/Data-Either-Combinators.html#v:eitherToError
04:50:31 <bartavelle> nmdanny, you can use hoogle for that https://www.stackage.org/lts-6.16/hoogle?q=+MonadError+e+m+%3D%3E+Either+e+a+-%3E+m+a
04:50:47 <srhb> Or even lambdabots Hoogle
04:50:51 <srhb> @hoogle MonadError e m => Either e a -> m a 
04:50:51 <lambdabot> Data.Either.Combinators eitherToError :: (MonadError e m) => Either e a -> m a
04:50:51 <lambdabot> Data.Either.Utils eitherToMonadError :: MonadError e m => Either e a -> m a
04:50:51 <lambdabot> Language.PureScript.Errors reifyErrors :: (MonadError e m) => m a -> m (Either e a)
04:51:26 <nmdanny> huh, the hackage hoogle didn't show me that function
04:51:52 <srhb> nmdanny: You mean the haskell.org one (or one of them?) They have a very restricted package set
04:52:03 <munja> Yeah just looked it up too and didn't find anything on the haskell.org one
04:52:12 <srhb> nmdanny: hoogle.haskell.org would find it though :)
04:52:26 <nmdanny> right, the haskell.org one was the one I used
04:52:27 <liste> https://www.stackage.org/lts-6.16/hoogle?q=MonadError+e+m+%3D%3E+Either+e+a+-%3E+m+a the stackage one too
04:58:50 <nmdanny> btw, what's the difference between hackage and stackage? is stackage limited to packages in LTS/Nightly and hackage has everything?
04:59:10 <liste> nmdanny: yes
04:59:11 <srhb> nmdanny: Yes.
05:00:11 <hpc> stackage is also not run by haskell.org
05:00:34 <hpc> (which is a minor point but worth knowing)
05:00:51 * chenyu says hello to everyone
05:01:11 * eklavya says hello to chenyu
05:03:36 <nicolasparis> hello chenyu
05:05:52 <woody> > 1 + 1
05:05:54 <lambdabot>  2
05:12:24 <pavonia> Is there a way to make GHC output a user message at compilation time? In this case, I want to make it print the value of a certain pre-processor variable
05:16:08 <ongy> pavonia: you can with template haskell
05:16:30 <ongy> or maybe warning pragma
05:16:52 <f-a> well if it is preprocessor, why not cpp?
05:17:14 <ongy> how to print with cpp?
05:18:21 <f-a> #define scary_print(var) print " var " <-- or soemthing like that?
05:18:30 <pavonia> f-a: I already tried with CPP's "#pragma message" which doesn't print anything for me
05:18:36 <f-a> depending on what pavonia needs
05:18:38 <f-a> ah
05:18:40 <f-a> compilation
05:19:32 <f-a> pavonia: I wonder if #error could do? (of course not if it blocks compilation)
05:20:14 <pavonia> Trying GHC's warnings, one sec
05:20:21 <zoran119_> when i run 'cabal install' for my project in a cabal sadbox, i can see 3 executables (in .cabal-sandbox/bin, dist/dist-sandbox-b93fd522/build and ./dist/build/)
05:20:31 <liste> pavonia: there's runIO :: IO a -> Q a
05:20:45 <zoran119_> which one is 'the one' (just built)?
05:20:56 <zoran119_> what is the difference between all of them?
05:21:29 <quchen> I remember a talk about the "meaning of a program". The speaker talked about different levels of understanding: the hexdump, the operational semantics, the denotational semantics.
05:21:43 <quchen> Does that ring a bell for anyone? I can‚Äôt find it anymore :-/
05:21:52 <quchen> It also featured a functor from Hask to Set :-)
05:22:05 <quchen> (That is, it was Haskell-related)
05:23:55 <ertes> quchen: that sounds a lot like a talk conal elliott would give =)
05:25:32 <quchen> ertes: Let‚Äôs see!
05:34:04 <pavonia> liste: Okay, runIO seems to work. But how do you get the value of the CPP variable into the Haskell string?
05:34:17 <merijn> pavonia: You don't
05:34:45 <pavonia> How do you print it then?
05:34:55 <merijn> You can maybe use the # operator to stringify a variable, but I'm not sure that works with Haskell's CPP mode
05:35:08 <f-a> yeah, stringify it and use print
05:35:27 <merijn> f-a: I'm not sure stringify works, string concat certainly doesn't
05:35:46 <merijn> f-a: GHC uses traditional mode for CPP
05:36:06 <f-a> merijn: can't we just invoke print on TOKEN ?
05:36:12 <f-a> well, print " TOKEN  "
05:36:39 <pavonia> So do I need a wrapper macro for this stringify thing?
05:36:41 <merijn> f-a: That doesn't work, because CPP doesn't substitute inside string quotes
05:38:37 <ruslantalpa> is there an optimised (caching) version of a function to get the current time in WARP (to replace this time <- getPOSIXTime). thanks
05:39:28 <merijn> How would you cache the time?
05:41:09 <ruslantalpa> the value changes only once a second, while a webserver could execute thousands of requests in that timeframe
05:41:22 <ruslantalpa> and system calls are expensive
05:41:28 <merijn> ruslantalpa: How would you check whether a second has already expired?
05:42:33 <ruslantalpa> store value in a mvar and have a separate process update the value once a second. (warp does this, i am jsut looking for the function name)
05:44:36 <ruslantalpa> found it. https://www.stackage.org/haddock/lts-6.16/auto-update-0.1.4/Control-AutoUpdate.html
05:50:28 <f-a> pavonia: indeed what merijn said is true, you can work around if bu using -pgmF and -F options
05:50:48 <f-a> (warning, pgmF expects a program which takes 3 arguments, check man for more info)
05:52:41 <pavonia> f-a: Sorry, I don't understand. Are you saying I should write a program to do the replacement?
05:52:58 <ejbs> f (l:ls) =
05:52:58 <ejbs>   (map (l:) ls) ++ (f ls) why does this construct an infinite type error?
05:53:34 <bartavelle> map (l:) ls
05:53:37 <ejbs> Yeah
05:53:39 <ejbs> I realised it haha
05:53:42 <bartavelle> ;)
05:53:48 <ejbs> (\x -> (l:[x]) switched to this :)
05:56:26 <f-a> piezoid: no, just do ghc -pgmF cpp -F some-file.hs
05:56:44 <f-a> as #define MYP(bar) #bar doesn't work apparently w/ -XCPP
05:57:46 <f-a> pavonia: silly me there is an easier way
05:59:36 <f-a> what are you trying to print, pavonia ?
06:00:30 <pavonia> f-a: The value of _WIN32_WINNT currently in use, as the value passed to cabal doesn't seem to be used
06:02:51 <merijn> f-a: Using a CPP setting other than traditional is not safe, it can/will mangle your haskell
06:03:00 <f-a> indeed
06:06:00 <pavonia> Never mind, I'm stupid ... I can just use hsc2hs' #const function for this
06:10:32 <pavonia> Now that raises the question why cabal configure seems ignore --hsc2hs-options="-D_WIN32_WINNT=..."
06:13:40 <pavonia> cabal clean fixed it
06:22:10 <ZoF> Word on the street is that 2017 is the year of Haskell, MS windows to s
06:22:40 * hackagebot yaml 0.8.18.6 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18.6 (MichaelSnoyman)
06:22:42 * hackagebot classy-prelude 1.0.0.2 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-1.0.0.2 (MichaelSnoyman)
06:39:08 <Grisha> hi everyone
06:39:51 <oherrala> hi
06:39:58 <ski> quchen : i suppose you'ven't found the talk yet ..
06:40:09 <quchen> ski: Unfortunately not :-/
06:40:16 <quchen> I‚Äôll find it eventually!
06:40:28 <quchen> Conal has a talk like that, but it wasn‚Äôt the one I remembered
06:40:38 <quchen> Sorry for the vague descrption
06:42:54 <NickHu> Quick survey, for those of you who do frontendd, do you prefer Elm or PureScript (or maybe something else)?
06:46:52 <[k-> I would be interested in such a survey too
06:48:43 <NickHu> I have glanced over the documentation for both, and Elm wants to teach you about writing frontend and the PureScript just seems to be like LYAH but in PureScript
06:53:20 <[k-> so what would you be leaning towards?
06:53:44 <NickHu> It also seems as if Elm has its own architecture while doing frontend with PureScript in most paths leads to a library wrapping React
06:54:21 <NickHu> [k-: At this point I'm inclined to say Elm, but because I have 0 experience with frontend/web/DOM stuff, and I hear about Elm a lot more on lobste.rs than PureScript
07:03:04 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
07:03:04 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
07:03:15 <NickHu> chreekat: Yeah, you're right - I can't imagine writing frontend which needs all the type magic you expect Haskell to have though
07:03:50 <[k-> What a comprehensive book :)
07:04:37 <NickHu> It looks very comprehensive seeing as PureScript is so new
07:04:46 <chreekat> jackhill: I meant that the package for yaml is called 'yaml'
07:04:53 <benzrf> NickHu: well, i mean - why not?
07:05:06 <chreekat> NickHu: then just use jquery :D
07:05:10 <NickHu> benzrf: It's probably because I don't have a usecase in mind
07:05:16 <benzrf> heh
07:05:27 <jackhill> chreekat: I understood that, but I now see that I had copy-paste problems. Thanks!!
07:05:34 <chreekat> jackhill: haha gotcha
07:05:34 <benzrf> the thing to understand is that in haskell , type magic generally exists because there's a use for it
07:05:43 <NickHu> Elm holds your hand and shows you how to build UIs; that seems to be exactly what I need
07:05:51 <NickHu> benzrf: Very true
07:06:02 <chreekat> NickHu: then you won't be led astray. I know people use it for exactly that and seem happy about it
07:06:22 <NickHu> I wouldn't know how to build a UI in Jquery - but that's not the point of Jquery is it? 
07:06:40 <chreekat> NickHu: I meant, use Elm
07:06:50 <[k-> there is jquery-ui
07:07:05 <benzrf> NickHu: use ghcjs with reflex-dom :]
07:07:27 <benzrf> it's legitimately production-ready (unless you are an actual giant company)
07:07:28 <NickHu> [k-: Yeah but then I'd have to write javascript.. :(
07:07:46 <benzrf> ok well maybe im overselling it - but i dont think so
07:07:55 <NickHu> benzrf: Interesting - will it teach me how to webdev because aside from HTML idk anything about the DOM
07:08:14 <benzrf> oh
07:08:16 <[k-> I was writing something in javascript until I gave up and just tried prototyping in haskell
07:08:17 <benzrf> uhhh -
07:08:24 <benzrf> not exactly
07:08:24 <[k-> i couldn't compare arrays!
07:08:27 <benzrf> NickHu: do you know css?
07:10:05 <[k-> if you go the elm route, I will go the elm route... eventually :)
07:11:01 <NickHu> benzrf: Well, yeah
07:11:05 <benzrf> ok then
07:11:12 <Insanity_> [k-: compare arrays? 
07:11:31 <benzrf> NickHu: honestly, if what you want is to learn about the DOM, you really should just grit your teeth and do some javascript
07:11:47 <NickHu> It just seems the target for webdev keeps changing - the modern age hotsauce is React and Angular and stuff like that which apparently generate the HTML on the clients
07:11:49 <benzrf> they're pretty closely intertwined
07:11:56 <[k-> I was trying to compare if two arrays were the same for javascript
07:12:00 <NickHu> benzrf: I don't really care about it tbh I just want to make something that works lol
07:12:05 <benzrf> mm
07:12:07 <_matix> is it possible to use an accumulator with foldl?
07:12:16 <Insanity_> as in, contain the same elements? 
07:12:18 <benzrf> _matix: what do you mean?
07:12:44 <NickHu> _matix: Sure, foldl (\acc x -> acc + x) 0 [1..10]
07:12:45 <benzrf> NickHu: javascript's really not that bad apart from the syntax, standard library, and coercion shit
07:12:47 <[k-> yes Insanity_. but in javascript, arrays with the same element are not equal to each other
07:12:49 <_matix> benzrf: when iterating through a list i want to compare the current element, next element, and accumulated value
07:12:49 <Insanity_> Yeah NickHu it does change quite quickly. Personally I like angular2/typescript, once you get the hang of it
07:12:54 <benzrf> NickHu: which is... a lot... but the core semantics are pretty decent
07:13:16 <_matix> NickHu: thx really just learning haskell right now; what is the '\' for?
07:13:22 <NickHu> Yeah I've heard that JavaScript itself isn't too bad, it's the foul-smelling sauce that people layer over it
07:13:44 <benzrf> NickHu: javascript's core semantics are pretty standard modern dynlang stuff
07:13:49 <benzrf> i.e., scheme
07:13:51 <NickHu> _matix: It's a lambda expression - i.e. an anonymous function with two arguments acc and x, and it returns the expression on the right side of ->
07:14:00 <Insanity_> yeah but you can easily compare that yourself though, see if array B contains all elements of A
07:14:08 <NickHu> benzrf: The problem is no one uses just javascript though
07:14:22 <benzrf> you have one namespace of variables, functions are first-class, lexical scoping
07:14:44 <NickHu> Prototyped based OOP; yeah, I know about the javascript language and sure I could write it
07:14:49 <benzrf> ah alright
07:14:53 <NickHu> But I probably couldn't write it in an idiomatic way
07:14:56 <benzrf> mhm
07:15:00 <NickHu> And I don't want to be maintaining that kind of fluff
07:15:06 <benzrf> you could just go ahead and try reflex-frp
07:15:10 <benzrf> depending on what it is that you want to write
07:15:16 <[k-> Insanity_: I kind of searched the web for solutions, but they seemed too complicated. I wasn't willing to put in the effort for something that I felt should have been already provided for free
07:15:20 <benzrf> and what your technical concerns are
07:15:31 <NickHu> At the moment basically just a streaming terminal client
07:15:32 <ski> _matix : `\x -> x^2' is "the function that, when given an input, call it `x', returns `x^2'), iow the squaring function in this case
07:16:03 <benzrf> are you cool with the end product being a boilerplate 10-line html page that pulls in a 3MB blob of js?
07:16:07 <ski> _matix : `\acc x -> acc + x' means `\acc -> (\x -> acc + x)', iow the function that when given an input, call it `acc', returns a function that when given an input, call it `x', returns `acc + x'
07:16:23 <_matix> NickHu ski thanks guys, I'll play around a bit and come back with further questions
07:16:23 <benzrf> if so, ghcjs is quite nice
07:16:32 <_matix> ski: what is this "iow" word you are using?
07:16:34 <_matix> :P
07:16:37 <benzrf> _matix: "in other words"
07:16:38 <ski> _matix : for short, the function that when given two inputs, call them `acc' and `x', returns `acc + x'. iow in this case just the addition function (curried)
07:16:51 <[k-> in other words
07:17:05 <NickHu> benzrf: lol - tbh I'd rather use something that people actually use
07:17:15 <benzrf> people do actually use ghcjs
07:17:15 <NickHu> But I could look into it, thanks for the suggestion :)
07:17:20 <merijn> NickHu: There's public infrastructure running ghcjs!
07:17:26 <benzrf> merijn: holy shit really?
07:17:35 <ski> _matix : in this case `\acc x -> acc + x' can be written even shorter as just `(+)'
07:17:53 <merijn> benzrf: https://bicycledutch.wordpress.com/2015/06/09/bicycle-parking-guidance-system-in-utrecht/
07:17:59 <merijn> benzrf: That's running ghcjs
07:18:09 <benzrf> hahahah nice!!
07:18:45 <ski> _matix : the symbol `\' is supposed to be an ascii approximation of a greek (lower case / minuscule) lambda. i think with the extension `UnicodeSyntax', you can instead type `Œª', if you prefer
07:18:56 <Insanity_> [k- maybe it should be there by default yeah, but with the latest ecmascript you can write such a comparison in about 4 lines if you don't wrap it in a function and have some syntax that makes other programmers want to kill you 
07:19:15 <_matix> ski: ah ncie
07:19:15 <benzrf> NickHu: seriously, ghcjs isnt like some experimental thing that breaks on usecases that the author didn't use
07:19:17 <ZoF> Excellent community you guys have here :^)
07:19:37 <benzrf> NickHu: it's basically a legit haskell compiler (mostly)
07:19:48 <NickHu> Insanity_: It's the falsy truthy thing which really gets me when it comes to JS
07:19:54 <derpalinobreh> Pragmas are fine. Its nice to be able to enable compiler extensions. Haskell adding features is one of the great things about it.
07:19:55 <NoGreaterLanguag> I also hate custom operators. Just because you can doesn't mean you should. I am a casual user of most packages and am not going to memorize your weird operators. 
07:19:58 <realmenusehaskel> Macros as in unrestricted AST transformations? That way lies madness. It's impossible to reason about code written in DSLs that way because the code you write gets transformed every which way before being evaluated.
07:20:01 <ZoF___> I completely agree. My biggest complaint about today's Haskell is that it doesn't have a good way of allowing the user to extend the language. Sure, EDSLs are great, but we need a more attractive macro system so that monad & arrow are not the only privileged medicines that get a spoonful of sugar.
07:20:02 <Kashelluser> And change it did, which served to scare away users and maintain the equilibrium. This is what's referred to as "avoiding success at all costs". Maybe the problem is that we've outgrown that.
07:20:04 <tsundere_haskell> From what I gather, for a long time the secret of Haskell's success was that unlike most research languages it had users, and unlike most production languages it didn't have so many that it was excessively hard to change things and made it hard to evolve.
07:20:06 <ilikepotatostoo> The criticism about copying GHC pragmas doesn't make sense to me -- the compiler errors related to pragmas make it very clear which feature you are using that's not part of the Haskell standard.
07:20:07 <isthisrealhaskel> Parsing complex data structures with aeson is painful but I was able to muddle through it. Yes there are too many regex libraries. I have written more database serialization logic than I care to think about. 
07:20:36 <NickHu> benzrf: Mm, I just haven't heard anything about it but it sounds interesting - 3MB js output though lol
07:20:43 <Insanity_> Yeah NickHu it's a bit of an oddity in the language I guess
07:20:43 <merijn> oh, look it's the spam brigade
07:20:54 <merijn> NickHu: I'm not sure that 3MB js output was serious :p
07:20:54 <benzrf> NickHu: well, i may be exaggerating? i dunno
07:20:58 <mniip> huh
07:21:01 <mniip> what was that
07:21:02 <ski> _matix : in lambda calculus, it's written as ‚åúŒª x. x¬≤‚åù, in Haskell it's `\x -> x^2' or `Œªx -> x^2' (`->' is supposed to approximate the ‚åú‚Ü¶‚åù "maps-to" arrow. ‚åúx ‚Ü¶ x¬≤‚åù is yet another notation, in general math, for the function ‚åúŒª x. x¬≤‚åù)
07:21:03 <merijn> tbh I dunno the size of the output
07:21:12 <merijn> mniip: scriptkiddie troll brigade
07:21:13 <[k-> NoGreaterLanguag: me too, so many operators @.@
07:21:51 <benzrf> NickHu: i'm doing a ghcjs project that uses reflex-frp and lens, and the standalone output is 1.9M after closure gets through with it
07:22:09 <NickHu> That.. still seems quite big
07:22:13 <benzrf> i mean
07:22:18 <benzrf> it's basically a statically linked binary
07:22:27 <NickHu> oh lol standard haskell approach
07:22:43 <benzrf> NickHu: wait, do you know about asm.js?
07:22:44 <NickHu> At least it can't ask for all of the memory in the machine just to do a call to print :)))
07:22:58 <ski> _matix : in the origins of lambda calculus, it was written ‚åúxÃÇ. x¬≤‚åù iirc, which became ‚åú^x. x¬≤‚åù for typographic reasons, and then people started using the greek ‚åúŒª‚åù instead of ‚åú^‚åù (because of visual similarity), and it started to be known as lambda calculus
07:23:02 <NickHu> benzrf: I know vaguely what it is but haven't used it
07:23:12 <benzrf> oh wait nvm, ghcjs doesnt target asm.js
07:23:16 <benzrf> still -
07:23:26 <benzrf> ghcjs is legitimately a compiler
07:23:28 <ilikepotatostoo> Haskell platform is decent. It certainly has come a long way over the last couple of years. 
07:23:35 <benzrf> it doesn't, like, try to map haskell semantics to similar javascript semantics
07:23:46 <ski> (perhaps the dot wasn't there in the original notation. perhaps it was just ‚åúxÃÇ x¬≤‚åù, or maybe ‚åú(xÃÇ) x¬≤‚åù, not sure)
07:24:10 <benzrf> it implements Actual Haskell, like ghc does, and compiles to something along the lines of ghc's c-- output
07:24:13 <benzrf> but js instead of c--
07:24:37 <NickHu> Does #haskell usually get this much spam?
07:24:43 <benzrf> so you can basically toss random entire haskell projects into it and get properly functioning output
07:24:52 <merijn> NickHu: What do you mean "that much"?
07:24:55 <benzrf> not *always*, but *usually*
07:24:59 <merijn> NickHu: That was like barely a screenful
07:25:03 <benzrf> and most of the really popular stuff on hackage works perfectly
07:25:14 <merijn> NickHu: Popular freenode channels attract trolls
07:25:23 <[k-> that's a very enticing feature
07:25:26 <Darwin226> Does anyone know how orphan instances work with typeclasses with no parameters?
07:25:29 <ski> (iirc, Peano also had something similar with writing ‚åúf(x) = ..x..‚åù as equivalent to ‚åúf = (x)..x..‚åù ..)
07:25:32 <NickHu> merijn: Oh, I only use freenode for #haskell and #openbsd
07:25:39 <benzrf> Darwin226: ...typeclasses with no parameters?
07:25:46 <merijn> Darwin226: You're making me sad...
07:25:49 <merijn> benzrf: Sure
07:25:57 <merijn> benzrf: "class Foo where"
07:26:04 <Darwin226> Let's pretend there are valid reasons
07:26:08 <Darwin226> for a second
07:26:12 <benzrf> good lord
07:26:18 <benzrf> is that Haskell 2010?
07:26:23 <NickHu> benzrf: That's interesting, but can you still use cool stuff like STM?
07:26:24 <merijn> benzrf: 0, 1, infinity rule!
07:26:25 <hpc> merijn: what does that end up doing?
07:26:36 <demize> ski: Are you sure about that? Church's A Set of Postulates for the Foundation of Logic uses Œª at least.
07:26:39 <merijn> hpc: Defines a class that can have 0 or 1 instances :p
07:26:48 <Darwin226> so, module A defines an instance for this class, module B imports module A and does something that requires this instance. If module C imports B, does it also have to import A to get the instance?
07:26:52 <merijn> hpc: "instance Foo where..."
07:26:57 <byorgey> benzrf, Darwin226: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/type-class-extensions.html#nullary-type-classes
07:27:04 <benzrf> NickHu: i don't know about stm
07:27:07 <byorgey> I don't think it's Haskell 2010
07:27:17 <hpc> merijn: that's useful :P
07:27:20 <merijn> NickHu: ghcjs supports STM and lightweight threads, yes
07:27:48 <byorgey> oh, sorry, I linked to the 7.8.4 docs
07:27:50 <byorgey> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#nullary-type-classes
07:28:08 <Darwin226> Or actually, does a function f :: MyClass => something become f :: something if it's defined with a MyClass instance in scope?
07:28:16 <benzrf> NickHu: yeah, part of the output is the entire runtime system
07:28:26 <benzrf> i think it does garbage collection
07:28:33 <benzrf> like, instead of piggybacking on javascript's
07:28:36 <benzrf> not sure
07:28:50 <benzrf> NickHu: do you use nix?
07:29:00 <demize> ski: Ah, seems you might be right, it's just that he never published anything before switching to Œª, mmm.
07:29:01 <byorgey> Darwin226: I wouldn't think so
07:29:12 <osa1_> when I was working on it the gc was just claering some internal variables, the rest is taken care of by the js runtime
07:29:23 <byorgey> Darwin226: I would think the constraint has to be satisfied at the *use* site, not the definition site
07:29:34 <[k-> you can re-export module A too
07:29:35 <osa1_> e.g. `reg1 = null; reg2 = null; ...` so that the gc can collect values in those
07:29:53 <demize> ski: Though he apparently has also said that he just chose it at random.
07:30:36 <ski> demize : page 7, <http://www.users.waitrose.com/~hindley/SomePapers_PDFs/2006CarHin,HistlamRp.pdf>
07:30:44 <benzrf> osa1: ah
07:30:48 <NickHu> benzrf: I would really like to use nix, but alas, I do not
07:31:12 <benzrf> NickHu: to be clear - i'm talking about nix as in the package manager, not as in "*nix" the family of operating systems
07:31:38 <NickHu> Yes I know exactly what you're talking about
07:31:41 <benzrf> well you can install nix over pretty much any distro (or OS X) and it works fine
07:31:57 <NickHu> I have used nix, but it doesn't really work nicely on my arch setup
07:31:58 <benzrf> anyway i was gonna suggest that you grab reflex-platform and just try ghcjs out
07:32:07 <benzrf> i use arch and i use nix and nix works fine :}
07:32:11 <benzrf> i mean
07:32:16 <benzrf> i dont use nix for primary package management
07:32:23 <benzrf> i use it in place of, e.g., cabal sandboxes
07:32:26 <benzrf> as a dev tools
07:32:29 <benzrf> *tool
07:33:04 <NickHu> Yeah I see
07:33:20 <NickHu> It made a broken symlink soup the last time I tried to use it on archo
07:33:34 <benzrf> ...broken?
07:33:37 <benzrf> how were you using it?
07:33:41 <NickHu> However, I did manage to get it set up on the university computers to allow me to install my own compilers and packages etc :DDD
07:33:46 <benzrf> sick
07:33:49 <NickHu> Can't remember
07:33:59 <benzrf> "symlink soup" is kind of the name of the game in nix
07:34:03 <benzrf> but "broken"?
07:34:13 <NickHu> As in dangling symlinks
07:34:13 <benzrf> do you currently have it installed
07:34:17 <benzrf> huh. weird
07:34:31 <NickHu> No; I'm also at work right now so can't really try it out
07:35:05 <_matix> Is it okay to paste a single line of code in this channel? 
07:35:14 <Darwin226> So it appears that the instance silently gets exported by the module that imports it from somewhere else
07:35:15 <NickHu> Yeah probably
07:35:16 <Darwin226> darn
07:35:16 <hpc> > "no" -- ;)
07:35:19 <lambdabot>  "no"
07:35:26 <NickHu> Unless it is like 1000000000000000000000 characters long
07:35:36 <NickHu> Actually is there a character limit in irc?
07:35:36 <_matix> :P
07:35:38 <benzrf> NickHu: yeah
07:35:40 <merijn> Darwin226: Instances are ALWAYS exported, including transitively
07:35:40 <NickHu>  or freenode?
07:35:52 <benzrf> NickHu: i don't know if there's a character limit in the protocol, but afaik all servers will truncate messages
07:36:04 <chakravarthy> Hello guys. I recently started with haskell and I installed intero mode with emacs yesterday to try it out. And it has a command for inserting the type signature for the thing at point
07:36:08 <_matix> In this guard, is (f, r) what is being returned?   | y == x = let (f,r) = getReps ys in (y:f, r)
07:36:11 <hpc> generally there's a line limit of 255 bytes, including the nick and PRIVMSG and all that stuff
07:36:13 <NickHu> So, what you're saying is, they invented tweets before twitter
07:36:21 <benzrf> NickHu: good meme, friend
07:36:32 <Darwin226> merijn: What I ultimately want is a logging function that knows the context it's ran in but doesn't require it as a parameter
07:36:33 <benzrf> _matix: no, that's kind of like in an imperative language:
07:36:35 <hpc> in practice there's not really a reason to have that limit and implementations are likely to just ignore it and do their own thing
07:36:36 <_matix> hpc: yeah i just meant standards, like will I get flamed if i don't use a paste :)
07:36:43 <benzrf> _matix: (f, r) = getReps ys; return (y:f, r)
07:36:56 <chakravarthy> I wrote a simple quicksort function. And when i executed the command to insert the type signature, i got a weird type signature 
07:37:02 <benzrf> _matix: let..in lets you bind some variables, like this:
07:37:05 <hpc> _matix: it's a judgement thing ;)
07:37:05 <chakravarthy> I've no idea what it means(i'm a beginner to haskell)
07:37:08 <benzrf> > let x = 3 in x + 1
07:37:10 <merijn> Darwin226: Have you looked at ImplicitParameters ?
07:37:11 <lambdabot>  4
07:37:13 <NickHu> _matix: return in haskell means something completely different to return in an imperative language
07:37:32 <_matix> NickHu: what word would I use to describe the result produced by the guard?
07:37:32 <NickHu> chakravarthy: What does the type signature look like?
07:37:36 <benzrf> merijn: eek
07:37:40 <Darwin226> merijn: Yeah, that's next on my list. I keep avoiding them.
07:37:56 <chakravarthy> Nik05: quicksort :: forall a. Ord a => [a] -> [a]
07:38:01 <merijn> benzrf: What?
07:38:07 <chakravarthy> what is forall a. ?
07:38:10 <NickHu> _matix: The guard is an expression, so it has the same type as what its contents evaluate to, namely (y:f, r)
07:38:13 <_matix> NickHu: also, what is the term for the signature of a function, e.g. func :: Eq a => [a] -> [[a]];  also for the separate parts (Eq a), and ([a] -> [[a]])
07:38:18 <chakravarthy> I've never seen that before anywhere in `haskell-book`
07:38:35 <_matix> NickHu: I have so many questions hahaha 
07:38:44 <hpc> _matix: breaking down the line, "y == x" is the condition of the guard, and the result for that case is the whole rest of the "let .. in .."
07:38:46 <benzrf> merijn: implicit parameters are kinda skeevy arent they
07:38:52 <NickHu> _matix: That is a polymorphic type signature, which means a can be any type
07:39:00 <ski> chakravarthy : you can remove the `forall a.' there, as it's implicit at that point
07:39:01 <benzrf> chakravarthy: you can remove the forall a.
07:39:02 <_matix> benzrf: er so .. what follows the "in" is what the expression will evaluate to
07:39:07 <benzrf> _matix: exactly!
07:39:11 <NickHu> The Eq a => part means we impose a restriction that any type we substitute for a must be equatable
07:39:19 <hpc> _matix: what follows the "in" is the result, which is (y:f, r)
07:39:24 <merijn> benzrf: They're not particularly elegant IF you can avoid them. But if you can't they're perfectly fine
07:39:29 <hpc> for whatever y, f, and r end up being
07:39:32 <benzrf> mm, ok
07:39:52 <merijn> benzrf: They don't let you break the type system or anything
07:40:00 <NickHu> _matix: This mechanism works by something called a typeclass, which is named Eq
07:40:12 <NickHu> It represents things we can compare by equality, for example numbers or strings
07:40:16 <benzrf> NickHu: have you done any FRP before?
07:40:19 <chakravarthy> yea, I read about typeclasses
07:40:21 <tsundere_haskell> Nope. With strictness, the fact that algorithms compose well in Haskell goes out the window. You'll pry laziness from my cold, dead hands.
07:40:26 <NickHu> These types are instances of the Eq typeclass, and they implement equality
07:40:27 <_matix> benzrf NickHu Thanks guys! 
07:40:35 <Kashelluser> Give yourselves a hand. Haskell is pretty awesome. Sure there is a lot do but we have real traction and a great language.
07:40:36 <NickHu> benzrf: Nope, I hear it's the new cheese though
07:40:39 <chakravarthy> but, i've never come across forall .a before, so just asked
07:40:46 <realmenusehaskel> In many ways it already is. Haskell 2010 is a remarkably usable language, even though it is basically Haskell 1998 with a new coat of paint. It isn't like the language standard is rolling along all that fast.
07:40:51 <NickHu> chakravarthy: It's an extension you're using which is causing that
07:41:08 <_matix> NickHu: So if I have a signature       func :: a -> b    would I be able to use multiple type classes?
07:41:13 <NickHu> It's a universal quantification but in that context it doesn't matter
07:41:18 <NoGreaterLanguag>  The Haskell community is helpful. I have seen people with a mathematical background explaining to an experienced engineer how when he creates some code it doesn't run.
07:41:24 <NickHu> _matix: Eq is a typeclass, a and b are polymorphic types
07:41:27 <ski> chakravarthy : you can ignore it for now. when you get more under your belt, you'll want to revisit it, and learn it (polymorphism, higher-rank types, &c.) properly
07:41:34 <_matix> NickHu: e.g. func :: Eq a => Ord b => a -> b
07:41:36 <[k-> there are so many conversations taking place at the same time it's hard to follow any of them
07:41:38 <chakravarthy> NickHu: extensions? I dont think ive enabled any extensions
07:41:57 <NickHu> _matix: Close, you want func :: (Eq a, Ord b) => a -> b
07:42:04 <benzrf> NickHu: semantically speaking
07:42:22 <merijn> [k-: You get used to it, also, depends on how busy a time of day it is
07:42:23 <benzrf> NickHu: er, wait - do you know about the general idea, or have you just not actually used it
07:42:30 <NickHu> chakravarthy: https://downloads.haskell.org/~ghc/5.02.1/docs/set/universal-quantification.html
07:42:34 <hpc> [k-: also right now one of them appears to be a botnet?
07:42:58 <ski> hpc : which ?
07:43:00 <NickHu> benzrf: Isn't the general idea that "event handlers" are stupid and we should model events as continuous processes rather than discrete things?
07:43:07 <Insanity_> ski: wondering the same thing here
07:43:11 <benzrf> well, sort of
07:43:13 <[k-> hpc: I only found out when someone said so
07:43:35 <[k-> ski: NoGreaterLanguag didn't respond to me when I said something to him
07:43:53 <NickHu> can't you tell by their names lol
07:43:57 <NickHu> who picks irc handles like that
07:44:08 <merijn> NickHu: I've seen plenty of weird names
07:44:11 <[k-> haha lol
07:44:11 <benzrf> NickHu: i think it'd be more accurate to say that the idea is that - instead of imperatively updating things when an event occurs - you define the thing that you would be updating in terms of the event
07:44:28 <Insanity_> merijn: Ditto, it's IRC after all
07:44:36 <ski> [k- : perhaps they just didn't notice / got busy
07:44:40 <benzrf> NickHu: in particular, FRP libraries usually provide a "Behavior" type and an "Event" type
07:44:41 <Insanity_> -t there
07:44:47 <benzrf> NickHu: semantically, you can think of it as:
07:44:57 <merijn> ski: No, I'm pretty sure said person is a bit, see discussion in -offtopic
07:44:58 <benzrf> NickHu: newtype Behavior a = Behavior (Time -> a)
07:45:06 <benzrf> NickHu: newtype Event a = Event (Time, a)
07:45:08 <merijn> NickHu: Have you read Conal's papers?
07:45:09 <benzrf> er
07:45:12 <benzrf> NickHu: newtype Event a = Event [(Time, a)]
07:45:19 <NickHu> merijn: No
07:45:30 <merijn> NickHu: I recommend the FRAN and Push-Pull FRP papers as starting points
07:45:44 <NoGreaterLanguag> I don't think this can be done, honestly. cabal hell is more or less a direct consequence of the dread diamond dependency problem. We encourage the creation of a lot of smaller packages, so we feel the pain slightly more than most.
07:45:44 <benzrf> NickHu: so then Behavior is clearly a functor, applicative, and (sometimes) monad - and Event is clearly a Functor, but not an Applicative
07:45:54 <merijn> NickHu: http://conal.net/fran/ and http://conal.net/papers/push-pull-frp/
07:46:04 <benzrf> NickHu: or you could read those :)
07:46:11 <realmenusehaskel> Well, implicit in your phrasing is an assumption that the Haskell community is somewhat elitist and exclusive. My experience with the community was quite the opposite. 
07:46:15 <[k-> ski: NoGreaterLanguag is talking like we aren't here though
07:46:20 <merijn> NickHu: Although I have to say that common usage of FRP has been coopted into something far less sensical
07:46:26 <benzrf> yeah
07:46:28 <benzrf> that's true
07:46:29 <NickHu> I'll stick it on the end of the list, thanks :)
07:46:43 <realmenusehaskel> talking like you're not here? Hwat?
07:46:46 <benzrf> NickHu: in any case, pragmatically speaking, this can look like something along the lines of this:
07:46:49 <NoGreaterLanguag> Agreed, hwat?
07:46:54 <Kashelluser> What grabbed me about the Haskell language was that they had a better answer to basically every one of the language features I'd been working on.
07:46:59 <tsundere_haskell> I think you articulated something that I never fully realized until you said that the Haskell community self-selects for kind and helpful people.
07:47:03 <ZoF___> Yes, hwat?
07:47:10 <NickHu> hwat?!
07:47:19 <Insanity_> hwat!
07:47:19 <hpc> dang old chatbots i tell you hwat
07:47:23 <chakravarthy> Nik05: I deleted the type signature and entered `:t quicksort` and this time I did not get forall a. 
07:47:38 <ski> [k- : possibly
07:47:46 <chakravarthy> maybe this is because some of the defaults set by intero-mode that I get a different type signature ?
07:47:47 <[k-> I'm laughing so hard XD
07:47:53 <NickHu> chakravarthy: Oh is this a signature your editor inserted for you?
07:48:06 <benzrf> NickHu: http://lpaste.net/187356
07:48:09 <_matix> What is the indentation error on line 9?  http://lpaste.net/1957854128847716352#line9
07:48:12 <[k-> hpc: XD
07:48:20 <chakravarthy> NickHu: Yup.
07:48:33 <benzrf> NickHu: that snippet is not valid reflex-dom, i don't think, but it would be if you swapped out a few names
07:48:40 <NickHu> benzrf: Looks pretty cool
07:48:53 <merijn> _matix: Helps if you paste the error too :)
07:48:55 <hpc> _matix: "| otherwise =
07:48:59 <hpc> "
07:49:07 <hpc> _matix: missing the "=" on the previous line
07:49:18 <_matix> hpc: ah thank you. 
07:49:39 <benzrf> NickHu: the code is using a monad for constructing a DOM, and you can get Events and Behaviors as the results of your actions, and you can go the other direction and generate actions whose resulting DOM is based on the current value of a Behavior or something
07:49:44 <hpc> if it had made it past the parsing step, you would have gotten a much more informative type error about otherwise being applied to arguments
07:49:47 <_matix> hpc: is the "=" unnecessary for "otherwise" at certain times?  I had thought my ide gave me a hint to not use it. 
07:50:01 <ski> _matix : required
07:50:07 <_matix> ski: thank you
07:50:07 <hpc> guards are always of the form "| bool = expr"
07:50:15 <hpc> otherwise is not special in that regard
07:50:20 <hpc> in fact, it is aggressively unspecial
07:50:20 <ski> _matix : btw, `otherwise' is just another name for `True'
07:50:22 <hpc> @src otherwise
07:50:22 <lambdabot> otherwise = True
07:50:26 <hpc> actual definition
07:50:31 <_matix> ski: haha yes i just ran it in ghci ;) 
07:50:53 <NickHu> chakravarthy: That's basically a more expressive way of saying the same thing; i.e. "forall a. a -> a" == "a -> a"
07:51:00 <merijn> NickHu: tbh, those papers are kinda easy to read. You could probably at the very least skim them in like an hour :)
07:51:08 <NickHu> But you can do fancier things with the explicit quantification
07:51:09 <benzrf> NickHu: so what that's doing is, intuitively, saying "as time passes and the value of rev changes, the content of this text element should reflect those changes"
07:51:39 <ski> _matix : sometimes people write `f otherwise = ...' or `case ... of ...; otherwise -> ...', but that's really a misunderstanding (or a "cute" misuse) of what `otherwise' is. better is to use `_' here
07:51:44 <chakravarthy> NickHu: I see, thanks for clearing things up. I'll just delete the 'forall' for simplicity sakes
07:52:04 <NickHu> I'll definitely look into it, but there are a few things I need to write before I do the front end anyway; I also bought the Awodey Category Theory book today :)
07:52:10 <benzrf> NickHu: (reflex-dom actually makes use of a third thing, "Dynamic", which is a combo of a Behavior and an Event, where changes in the value are delimited)
07:52:22 <ski> NickHu : please don't claim that `forall a. a -> a' is the same as `a -> a', it's incorrect
07:52:35 <benzrf> ski: they're the same thing as top-level terms
07:53:02 <ski> NickHu : `func :: forall a. a -> a' is equivalent to `func :: a -> a' (the latter being an abbreviation), in case `a' is not already in scope
07:53:05 <hpc> only by syntactic fluke
07:53:17 <benzrf> hpc: true
07:53:21 <NickHu> Yeah I did mean on the top level
07:53:24 <hpc> the difference between "forall a. a" and "a" is the same as the difference between "\a -> a" and "a"
07:53:36 <hpc> (at a theoretical level)
07:53:44 <ski> NickHu : if you say `forall a. a -> a', then you're suggesting that `(a -> a) -> Foo' is equivalent to `(forall a. a -> a) -> Foo', which is patently false
07:53:49 <benzrf> ... for loose meanings of "the same" ;)
07:54:01 <hpc> "is similar to", yeah
07:54:32 <benzrf> ski: welllll, those two types *are* equivalent in the sense that in neither case can you do anything with the argument
07:54:34 <benzrf> ;)
07:54:34 <mickymus> My impression is that, in the real world, people only think about laziness or eagerness in very limited situations, and generally imagine that data types are inductive and functions are total.
07:54:42 <NoGreaterLanguag> I remember when I first joined the community I was very aggressive and confrontational, but the more I hang out the more helpful I become. 
07:54:43 <ski> NickHu : it's important that we're talking about the *whole* type to the right of `::' in a type signature (and also that `a' is not already in scope, but that won't happen that commonly for newbies)
07:54:46 <realmenusehaskel> This community very carefully polices and grooms newcomers to continue the tradition, almost like a self-preserving culture.
07:55:02 <ski> benzrf : "in the sense that in neither case can you do anything with the argument" -- depends :)
07:55:11 <NickHu> ski: Yes; would it be more correct to say it is true in the context where a appears free?
07:55:16 <Kashelluser> If you had to explicitly request the next chunk of the file like you do with read or other system calls in other languages, it also wouldn't be an issue.
07:55:17 <benzrf> ski: well, the latter can use the argument, but it's meta-theoretically guaranteed to be id
07:55:29 <benzrf> mickymus: you going somewhere?
07:55:36 <haskellh4ck3r> I am willing to trade some performance for safety. I accept that in general Haskell code will be slower than C++ however we can build more reliable code which saves money. I will buy more cores to compensate. My growth as a Haskell programmer really took off when I started posting to here and getting torn a new one each week, which strongly motivated me to improve.
07:55:40 <benzrf> NoGreaterLanguag: o/
07:55:44 <ski> benzrf : if `(a -> a) -> Foo' occurs inside the larger type `forall a. [a] -> (a -> Int) -> (a -> a) -> Foo', then you sure can do something with the argument ! :)
07:55:51 <tsundere_haskell> Your problems with Haskell are real and most of you arguments are certainly valid, but assuming Haskell is only appealing to a select group of people, because you personally have difficulties is just plain wrong reasoning.
07:55:56 <benzrf> ski: again, i was talking about top-level types >:P
07:56:01 <ski> benzrf : the *context* of where the type occurs is essential
07:56:22 * ski . o O ( "The place of the Word of the Lord must be truly understood" -- Castle Master )
07:56:43 <ski> benzrf : yeah, please don't assume that without saying so explicitly :)
07:57:05 <benzrf> poo
07:57:12 <orion> Am I crazy for wanting to use Haskell to read signal data over USB from a SDR?
07:57:37 <hpc> orion: possibly, but it's probably doable with the right library
07:57:44 * hpc has no idea which library that would be though
07:57:54 <hpc> or you can FFI to the appropriate C lib
07:57:55 <oherrala> orion: sounds like fun
07:58:10 <hpc> orion: i have had far crazier ideas ;)
07:58:14 <NickHu> Sounds like you could use pipes for this
07:58:14 <oherrala> https://hackage.haskell.org/package/sdr
07:58:18 <ski> (i want reasoning to be compositions, if some equivalent is stated for types, it want it to be applicable to all type sub-expressions of a type expression as well, unless explicitly stated otherwise)
07:58:26 <ski> (s/compositions/compositional/)
07:58:55 <NickHu> Is there a reason why sed isn't on this channel?
07:59:02 <benzrf> sed?
07:59:16 * ski . o O ( Ced )
07:59:23 <NickHu> A freenode bot (iirc)
07:59:27 <Kashelluser> I love lazyness by default, especially the performance advantages in terms of writing out clear code
07:59:33 <haskellh4ck3r> After years of programming in Haskell, I find the strictness a pain to deal when when I program in OCaml.
07:59:42 <NickHu> Basically if you do a s/abc/def/ it will echo your last line with the replacement done for you
07:59:46 <NickHu> If you make a typo
07:59:47 <tsundere_haskell> These days, if they want to "compose well", Haskell developers must use formal compositional abstractions - streams, wires, pipes, iteratees, FRP, categories, comonads, arrows, etc. - or explicit metaprogramming. 
07:59:53 <NickHu> Then again, maybe that was on rizon...
07:59:56 <ski> haskellh4ck3r : are you a bot ?
07:59:57 <ongy> NickHu: sounds confusing
07:59:59 <merijn> ski: ping in #haskell-ops
08:00:00 <realmenusehaskel> Laziness is essential for defining your own abstractions, but I agree that we need the ability to selectively mix in strictness clearly. I would really like the ability to say "This data type should be strict". 
08:00:14 <NickHu> ongy: How so?
08:00:16 <haskellh4ck3r> Of course I'm not a bot friend
08:00:20 <NoGreaterLanguag> The basic idea, in my head at least (no bearing on anyone else's), is that you could have strictness annotations on types, with the following meaning: !X would be the same type as X, except guaranteed to be in WHNF.
08:00:51 <ongy> NickHu: I don't usually relate what others say, to a message. (well I got used to it with lambdabot, so it may be less confusing than I think)
08:01:01 <tsundere_haskell> you mean like a robot?
08:01:02 <haskellh4ck3r> you mean like a robot?
08:01:03 <Kashelluser> you mean like a robot?
08:01:03 <NoGreaterLanguag> you mean like a robot?
08:01:05 <realmenusehaskel> you mean like a robot?
08:01:10 <NickHu> lol wtf
08:01:11 <hpc> looool
08:01:13 <ongy> what's going on?
08:01:13 --- mode: ChanServ set +q *!*@50.21.189.32
08:01:18 <ZoF> Kappa
08:01:38 <NickHu> You missed one
08:01:55 <mickymus> you mean like a robot?
08:02:03 <NickHu> s/one/two/
08:02:32 <ongy> also, what triggered that? Mention of lambdabot?
08:02:36 <ZoF> t.t well I lost that one
08:02:38 <hpc> ski: you missed NoGreaterLanguag and realmenusehaskel
08:02:49 <NickHu> and mickymus 
08:02:56 <hpc> ZoF: were those bots yours?
08:03:02 <benzrf> NickHu: ok, here's a directly-compilable (as in, "ghcjs Foo.hs") actually-working version of the hypothetical snippet i posted: https://gist.github.com/b9be2f67d39b04b80c071b52e5783615
08:03:43 <NickHu> Nice
08:03:48 <ZoF> hpc: Will I be banned if they were?
08:03:49 <benzrf> as output you get a directory with a boilerplate script-tag-using html file that you can immediately open in yr browser
08:03:55 <benzrf> and it does exactly what it looks like
08:04:25 <hpc> ZoF: im not an op :P
08:04:25 * ski didn't K-line anyone ..
08:04:26 <benzrf> as you type, the reverse of it appears below
08:05:01 <NickHu> ghcjs: command not found
08:05:05 <NickHu> rip ;_;
08:05:20 <sm> ZoF: you might get off with one warning if you come clean and name the rest of them
08:05:21 <[k-> NickHu: you are going the ghcjs route?
08:05:41 <NickHu> [k-: I thought I'd just see what the example benzrf posted looks like after you compile it
08:05:45 <benzrf> NickHu: install nix and then git clone  https://github.com/reflex-frp/reflex-platform
08:05:52 <[k-> ah okay
08:05:56 <benzrf> NickHu: i can post the compiled output if you want
08:05:58 <ZoF> Hmmm well you found them all fam, I was just posting random sentences from a reddit thread
08:06:02 <shachaf> ZoF: This behavior is not appreciated.
08:06:11 --- mode: ChanServ set +o shachaf
08:06:46 <ZoF> Sorry, it won't happen again !
08:06:48 <NickHu> ZoF: I knew those sentences were too well formed to have come from IRC!
08:07:24 <benzrf> NickHu: https://my.mixtape.moe/ycvxlo.tar.gz
08:07:37 <NickHu> lol nice choice of pastebin
08:07:47 <benzrf> not many hosting sites for random binary files
08:07:57 <NickHu> I can give you an invite to paste.xinu.at if you want
08:08:00 <sm> ...and to be fully rehabilitated, contribute documentation to three haskell packages and post a review of haskell irc/bot libraries
08:08:02 <merijn> benzrf: Just base64 encode them :p
08:08:07 <benzrf> :}
08:08:08 <NickHu> It's got a nice upload client on arch too
08:08:16 <benzrf> anyway i gotta go
08:08:25 <benzrf> i have class in 20 minutes and i need to write a short thing before then
08:08:28 <benzrf> later
08:08:32 <NickHu> Okay, thanks for the advice :)
08:08:37 <benzrf> my pleasure :}
08:08:45 <[k-> and the laugh
08:08:45 --- mode: ChanServ set -q *!*@50.21.189.32
08:08:52 <NickHu> My term doesn't start for another whole month - Summer is so boring
08:09:11 <[k-> my examinations are next month
08:09:17 <NickHu> yowch
08:10:09 <[k-> but I wrote haskell code in the light of it anyway
08:10:13 <NickHu> lol the js is literally 6MB
08:10:28 <[k-> ouch
08:10:46 <[k-> won't ghcjs be *worse* than js then
08:10:57 <NickHu> It depends on what you mean by worse
08:11:05 <NickHu> But 6MB javascript is kinda taking the piss lol
08:11:53 <ongy> if you are on mobile or have limited bandwith 6MB website sounds terrible
08:12:54 <NickHu> well, considering I like things like min.css
08:12:54 <[k-> There is this issue: https://github.com/ghcjs/ghcjs/issues/417
08:13:00 <NickHu> Yeah, it sounds terrible lol
08:13:15 <[k-> ongy: I am on both now ;-;
08:13:28 <[k-> well not the bandwidth 
08:14:19 <NickHu> his all.js file is 248KB how?! This one is 3.3MB
08:14:39 <NickHu> lol it crashed vim when I opened it ;_;
08:14:51 <benzrf> NickHu: ok 2 things:
08:14:59 <benzrf> 1. all.js is the other js files combined, so it's 3MB, not 6
08:15:10 <[k-> it's minified tho 
08:15:12 <benzrf> 2. closure compiler will cut the size of all.js by like 2/3
08:15:17 <benzrf> [k-: dont think it is
08:15:29 <[k-> I meant the issue*
08:15:33 <benzrf> ah
08:16:00 <[k-> if it was minified and it was 3MB, now that's something
08:16:28 <NickHu> benzrf: What is out.js supposed to be?
08:16:29 <benzrf> im running closure over this all.js right now
08:16:43 <benzrf> NickHu: it's the "binary"
08:16:49 <NickHu> oh
08:16:53 <benzrf> NickHu: but it relies on the stuff in rts.js and lib.js
08:17:02 <NickHu> Which are included in all.js?
08:17:07 <benzrf> rts.js is literally the rts - lib.js is generic stuff, like base
08:17:09 <benzrf> yeah
08:17:17 <benzrf> after closure:
08:17:19 <benzrf> 868K all.min.js
08:17:26 <NickHu> Still seems unacceptable
08:17:30 <benzrf> well
08:17:35 <benzrf> this is using reflex-dom
08:17:39 <benzrf> which pulls in lens and all kinds of stuff
08:17:53 <sm> NickHu: get a better editor! :)
08:17:54 <benzrf> it's like if you have a statically linked GUI app - you're gonna have a lot of overhead for your toolkit
08:18:04 <benzrf> if you did ghcjs bare, you'd get waay smaller files, i think
08:18:11 <benzrf> anyway i do actually have to go
08:18:13 <benzrf> later
08:18:27 <NickHu> ok cool, thanks again btw
08:18:44 <benzrf> (to be clear: only a tiny tiny amount of that size is from the actual code i wrote)
08:18:46 <benzrf> (almost all of it is the deps)
08:18:50 <benzrf> ok later
08:20:55 <[k-> that's...worse
08:21:21 <ongy> but hard to avoid
08:22:15 <martinr_> Should i learn haskell?
08:22:19 <NickHu> "Reflex is great (and its author is a genius) but it's not really useful yet for non-desktop apps. Because Reflex + GHCJS is impossibly slow on mobile."
08:22:31 <NickHu> martinr_: probably not
08:22:33 <ongy> martinr_: you might get a rather biased answer in here
08:22:43 * hackagebot statsd-client 0.3.0.0 - Statsd UDP client  https://hackage.haskell.org/package/statsd-client-0.3.0.0 (tclem)
08:22:54 <martinr_> Go ahead, convince me
08:23:18 <Rotaerk> okay, here goes...:  yes.
08:23:48 <ongy> if you have time to ask questions like that, you don't have any reason not to
08:24:31 <Guest37925> martinr_
08:24:36 <Guest37925> its generally not useful for anything at all
08:24:45 <martinr_> Yeah that's my view too
08:24:48 <Guest37925> it exists solely for the purpose of mental masturbation
08:24:56 <NickHu> lol
08:24:57 <martinr_> Why just not use Java?
08:25:01 <ongy> like I said, rather biased answers :)
08:25:04 <mickymus> Haskell elists trying to keep everyone down!
08:25:08 <NickHu> If you're happy with Java, use Java
08:25:16 <mickymus> elitists **
08:25:19 <Guest37925> no dont
08:25:19 <martinr_> That was /s
08:25:20 <Guest37925> use c
08:25:21 <Guest37925> its fast
08:25:21 <NickHu> Nobody really cares what language you use anyway
08:25:22 <Guest37925> and safe
08:25:38 <MarLinn> o_O
08:25:46 <martinr_> But c looks disgusting
08:25:46 <NickHu> Good programmers can learn how to write decent code in any language
08:25:55 <Guest37925> no it doesnt
08:25:55 <NickHu> martinr_: Guest37925 is obviously a troll
08:26:01 <ongy> depends on how you define decent
08:26:03 <glguy> Yes yes, everyone's very clever.
08:26:09 <martinr_> It's worse than assembly
08:26:16 <ski> NickHu : and conversely ..
08:26:17 <Guest37925> i meant the haskell is only good for mental masturbation part
08:26:29 <martinr_> OK I'm convinced
08:26:33 <NickHu> lol
08:26:35 <Guest37925> learn erlang
08:26:51 <Rotaerk> "I really want to mentally masturbate! thanks for convincing me Guest37925!"
08:27:03 <jrajav> I mean let's be honest
08:27:04 <martinr_> ^
08:27:11 <jrajav> Mental masturbation DOES sound pretty fun
08:27:18 <martinr_> ^
08:27:26 <NickHu> sometimes I really hate irc
08:27:29 <MarcelineVQ> must be friday
08:27:34 <Guest37925> y-you too
08:27:45 <NickHu> yup
08:27:56 <martinr_> OK I'm going to level with you
08:28:16 <martinr_> Just came here as no one was in my favourite irc channel
08:28:35 <NickHu> Isn't it more mainstream to bug your facebook friends?
08:28:37 <Rotaerk> martinr_, haskell is unlike most languages; that should be reason enough to learn it out of curiosity
08:28:52 <martinr_> NickHu, nah i deleted that
08:28:59 <Rotaerk> you deleted facebook?
08:29:00 <NickHu> good for you
08:29:01 <Rotaerk> thank god
08:29:03 <martinr_> Yes
08:29:13 <glguy> martinr_: OK, well you're welcome to come back if you have a Haskell question.
08:29:14 <Rotaerk> maybe people will have more free time now
08:29:23 <bizarrefish> he's lying. i checked, it's still there
08:29:29 <bizarrefish> why lie?
08:29:31 <martinr_> glguy, maybe I'll check it out
08:29:35 <martinr_> Any good resources?
08:29:47 <NickHu> Learn you a Haskell is quite a nice read
08:29:57 <NickHu> http://learnyouahaskell.com/
08:30:04 <bizarrefish> the haskell wiki is pretty good too
08:30:11 <hpc> LYAH is enjoyable but lacks exercises
08:30:31 <Jackoe>  there's a great reddit thread on this, one second?
08:30:33 <bizarrefish> haskell programmers seem to make thr best writers
08:30:34 <hpc> the haskell wiki is very hit-or-miss in how useful it is for learning
08:30:37 <[k-> I am confused by the sudden entry of many people
08:30:38 <sm> ZoF: seems like you "forgot" to shut down mickymus
08:30:41 <Guest37925> i found lyah to be quite thorough
08:30:44 <martinr_> After all, most of what i do is from curiosity
08:30:47 <hpc> the haskell wikibook is pretty good for specific concepts
08:30:50 <ski> @where haskellbook
08:30:50 <NickHu> If you actually want to learn Haskell, byorgey's class is pretty good
08:30:50 <lambdabot> http://haskellbook.com
08:30:53 <NickHu> http://www.cis.upenn.edu/~cis194/spring13/
08:31:00 <ski> martinr_ : that ^ one is used by #haskell-beginners
08:31:03 <hpc> the CIS course i haven't looked at but it's supposed to be very good
08:31:20 <NickHu> I haven't used it either myself admittedly
08:31:36 <NickHu> But this repo seems to know what it's talking about: https://github.com/bitemyapp/learnhaskell
08:31:44 <NickHu> oh he's on this channel too. cool
08:31:53 <MarcelineVQ> It's good, there's 0 hand holding though so it expects you to research things it doesn't explain
08:31:57 <hpc> martinr_: you should pick whichever one you can get through the first hour or so of without going "bleh", read and do exercises until you get confused and overwhelmed, then try other resources until things make more sense
08:32:21 <martinr_> hpc ill try lyah and report back
08:32:22 <Jackoe> https://www.reddit.com/r/haskell/comments/4r286o/15_free_haskell_books/ <-- the thread
08:32:29 <hpc> if you stick with haskell you'll ultimately end up using almost all of them
08:32:52 <martinr_> In other words, i shall be back in a couple of days
08:33:05 <martinr_> Thanks everyone
08:33:06 <ongy> hpc: then I'm doing things wrong
08:33:32 <MarLinn> I like "Write Yourself a Scheme in 48h" - it's a bit outdated now, but a fine piece of 48h of continuous mental (Haskell) masturbation
08:33:35 <martinr_> Oh one more thing
08:33:44 <hpc> ongy: or you're doing it unusually right? ;)
08:33:44 <martinr_> Best ide for Linux?
08:33:51 <martinr_> Or just text editor
08:34:01 <ongy> if you are used to vim or emacs, use that with plugins
08:34:03 <NickHu> just use a text editor, IDEs are useless anyway
08:34:05 <hpc> vim or emacs
08:34:07 <ongy> otherwise, no idea
08:34:11 <martinr_> Vim it is then
08:34:14 <NickHu> hpc: vim obviously ;)
08:34:22 <hpc> there's some haskell-specific plugins out there that aren't tremendously necessary
08:34:37 <hpc> eclipse-fp is allegedly alright now?
08:34:45 <ongy> hpc: I feel like I'm doing ok. But I may be missing better ideas
08:34:47 <martinr_> Hpc, text colours?
08:35:16 <hpc> i use a totally stock vim with :set list
08:35:39 <NickHu> hpc: Dude that's hardcore
08:35:41 <ongy> I think I got a highlight file from somewhere
08:35:46 <hpc> and :hi Comment term=bold ctermfg=Cyan guifg=#80a0ff gui=bold but it took me a few years to get to the point of being annoyed enough to add it
08:36:00 <NickHu> what about neco-ghc
08:36:11 <hpc> oh, and syntax on if that doesn't happen to default that way in your distro
08:37:13 <ongy> I would also recommend softtabs(or is it autoexpand?) and setting sensible tabsize
08:37:30 <NickHu> Hmm, I'm not sure if I agree with the statement that "Haskell is difficult to teach effectively"
08:37:36 <NickHu> ongy: expandtabs
08:37:44 <nastyney> howdy all.
08:37:46 <hpc> NickHu: i have been forced to keep myself comfortable with some really weird systems, and staying close to defaults makes that easier
08:37:50 <ongy> hi nastyney 
08:38:04 <nastyney> According to HN this is a very helpful community
08:38:14 <NickHu> hpc: Yeah, I can use vanilla vim, but that's for general sysadmin stuff - I like to develop on my own tweaked setup
08:38:46 <hpc> i do heavily configure other stuff though - you should see my screenrc sometime
08:38:59 <ongy> hpc: does it redirect to tmux?
08:39:06 <hpc> haha
08:39:10 <ongy> nastyney: mostly helpful
08:39:25 <ongy> unless it diverges into philosophical questions and everybody disagrees
08:40:25 <NickHu> Oh did they finish haskellbook?
08:40:47 <[k-> is there still a special price?
08:41:40 <ongy> nastyney: do you have any specific question?
08:41:52 <NickHu> [k-: It's $59
08:42:11 <NickHu> I don't understand why people think programming books are expensive
08:42:26 <NickHu> I looked up the price of Albegra by M Artin and it was ¬£130 ;_;
08:42:39 <hpc> they can both be expensive ;)
08:43:09 <[k-> It is completed but under editing
08:43:22 <[k-> I haven't bought a single book yet
08:43:33 <[k-> $59 seems pretty expensive
08:43:34 <NickHu> I bought a print copy of LYAH
08:43:39 <NickHu> It was like ¬£10
08:44:16 <[k-> this is 1234 pages long though 
08:44:16 --- mode: shachaf set -o shachaf
08:44:38 <NickHu> I remember I was sent a review copy of the first couple of chapters
08:44:49 <NickHu> I sent back my feedback and never got a response though lol
08:44:58 <nastyney> Perhaps I could utilize your guidance, I am seeking to have beginner Python critiqued.
08:45:24 <martinr_> Python sucks
08:45:50 <martinr_> How's that?
08:45:59 <nastyney> lol, just trying to do what it takes to strengthen my understanding. To be quite fair I must give haskell a try
08:46:10 <NickHu> lol it's really easy to find a pdf of this book by googling
08:46:15 <nastyney> I know
08:46:20 <nastyney> but not all of them have solutions
08:46:24 <nastyney> which is why Im here
08:46:26 <glguy> nastyney: This is the wrong channel to get Python help, actually. It's #haskell.
08:46:29 <[k-> they have free chapters 
08:46:40 <nastyney> I figured
08:46:43 <nastyney> it was worth a shot
08:46:46 <glguy> martinr_: We don't need language bashing
08:46:53 <NickHu> [k-: I found a full (presumably leaked) pdf of 1160 pages on the second google link
08:46:58 <[k-> https://wiki.haskell.org/IRC_channel
08:47:05 <martinr_> glguy, fine
08:47:32 <nastyney> With solutions to all the exercises?
08:47:39 <nastyney> @NickHu
08:47:40 <lambdabot> Unknown command, try @list
08:48:30 <NickHu> I might get a print copy when it comes out
08:49:17 <prsteele> nastyney: if you have a question about Haskell (even if it is in comparison to Python) you'll probably get someone trying to answer
08:49:39 <nastyney> to whomever is curious: https://repl.it/D07J
08:49:55 <[k-> will you buy it anyway?
08:50:12 <nastyney> Simply trying to determine if this solution misses any test cases
08:50:28 <NickHu> [k-: Maybe a print copy; idk - I'm not sure if this book is worth it, I'm not the intended audience
08:51:29 <[k-> nastyney: there is an easier solution
08:51:41 <nastyney> but does it address negative integers?
08:51:57 --- mode: ChanServ set +q *!*@gateway/web/cgi-irc/kiwiirc.com/ip.45.73.150.234
08:52:03 <prsteele> nastyney: think about how you'd do this with pen and paper
08:52:06 <hoppfull> G'day my fellow interlocutors!
08:52:18 <hoppfull> Is lift and fmap the same thing?
08:52:32 <[k-> if there is a negative integer, you could test for it somehow
08:53:57 <NickHu> @define divides :: Integral a => a -> a -> Bool; x `divides` y = y `mod` x == 0
08:54:01 <lambdabot>  Defined.
08:54:02 <prsteele> hoppfull: their types aren't really close to each other at all
08:54:20 <NickHu> > (-3) `divides` 15
08:54:21 <ongy> :t lift
08:54:26 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
08:54:27 <lambdabot>  True
08:54:47 <NickHu> There's no need to check for negatives because it doesn't matter
08:55:46 <ilikepotatostoo> Free server: 74.208.89.158 
08:55:47 <ilikepotatostoo> root
08:55:48 <ilikepotatostoo> Rm9S3n84YJ
08:55:56 --- mode: ChanServ set +o glguy
08:55:56 --- mode: glguy set +b ilikepotatostoo!*@*
08:55:56 --- kick: ilikepotatostoo was kicked by glguy (ilikepotatostoo)
08:56:06 <bollu> is there a function that does IO a -> Int -> IO [a]? (bring "count" number of elements")
08:56:07 <[k-> well, when I think of multiples, they should be positive?
08:57:14 <NickHu> [k-: That's not how the divides relation works
08:57:21 <ongy> NickHu: your divides still has a problem
08:57:26 <hoppfull> prsteele: I read the type signature on some web page and it was the same as fmap. I can't seem to find lift. In which module is it?
08:58:10 <hoppfull> Wait. Is lambdabot a haskell REPL in here?
08:58:13 <MarLinn> :t replicateM -- bollu
08:58:15 <lambdabot> Applicative m => Int -> m a -> m [a]
08:58:29 <hoppfull> 5 + 6
08:58:31 <prsteele> hoppfull: either mtl or transformers package
08:58:36 <NickHu> ongy: How so?
08:58:45 <[k-> but multiples of 3 are 3,6,9,12,15...!
08:58:46 <ongy> > 0 `divides` 5
08:58:48 <prsteele> hoppfull: yes, triggered by starting with > I think
08:58:49 <lambdabot>  *Exception: divide by zero
08:58:59 <hoppfull> > 10 * 5
08:59:02 <lambdabot>  50
08:59:06 <hoppfull> Coooooool!
08:59:15 <hoppfull> You guys are wizzards!
08:59:18 <ongy> hoppfull: it also has useful things like:
08:59:21 <ongy> :hoogle lift
08:59:32 <ongy> @hoogle lift
08:59:33 <bollu> MarLinn: thanks :)
08:59:36 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
08:59:36 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
08:59:36 <lambdabot> Data.Vector.Fusion.Bundle lift :: Monad m => Bundle v a -> Bundle m v a
08:59:39 <bollu> MarLinn: is it in Control.Monad?
08:59:42 <bollu> :t replicateM
08:59:44 <lambdabot> Applicative m => Int -> m a -> m [a]
08:59:52 <[k-> is 3 a multiple of -1?
08:59:55 <MarLinn> bollu: Yup
09:01:25 <NickHu> ongy: 0 is not in the domain, but I can't think of a way to encode this into the types
09:01:52 <[k-> Is 0 a natural number?
09:02:03 <[k-> math is confusing...
09:02:05 <NickHu> Yes but divides is usually defined on N_+
09:02:22 <NickHu> And the second argument is in Z
09:02:31 <prsteele> it really comes down to convention
09:02:35 <NickHu> ^^^this
09:02:51 <ongy> bakc in school our teachers didn't really agree on that
09:02:59 <ongy> Some used N/N_0, others N/N+
09:02:59 <mickymus> Hey guys I was looking to meet some real hackers so I went over to where they hang out(Hacker News of course!) and they said this was the most hopping channel in the world of irc, is this assertion true? 
09:03:15 <NickHu> glguy: pls kick mickymus 
09:03:34 --- mode: glguy set +q *!*@108.175.2.145
09:07:54 --- mode: glguy set -q *!*@gateway/web/cgi-irc/kiwiirc.com/ip.45.73.150.234
09:08:24 --- mode: glguy set +q *!*@70.35.196.206
09:12:08 <[k-> would it be hard to codegolf in haskell?
09:12:28 --- mode: glguy set +b *!*@108.175.0.0/20
09:12:28 <shapr> it's fun to codegolf in Haskell
09:13:04 --- mode: glguy set +b *!*@70.35.192.0/20
09:13:12 <[k-> do you have some examples I could see?
09:13:17 <pavonia> Isn't the point of codegolf that it is hard?
09:13:23 <amalloy> http://codegolf.stackexchange.com/questions/19255/tips-for-golfing-in-haskell
09:15:58 <[k-> codegolf aims to write the shortest code possible
09:16:26 <NickHu> Obviously you should be writing APL for that ;)
09:17:55 <ongy> what's codegolf?
09:18:11 <NickHu> solve a programming challenge in as few bytes as possible
09:18:14 <prsteele> ongy: write a program to do X, minimizing the size of your source file
09:18:15 <NickHu> e.g. reverse a list
09:18:46 <ongy> oh, we did that in the course where I first learned haskell. But with tokens, not bytes (for some definitino of token)
09:18:56 <NickHu> but.. why?
09:19:02 <NickHu> You don't really learn anything from it
09:19:10 <sm> omg, best 404 ever: https://nosuchpage.slack.com
09:19:20 <[k-> _=$$/$$;__=_-_;@_=_+_;$_=@_+_;$__=@_+$_;$-_=$__*$_;@__=''<<$-_*($__+$_)+@_;$___=''<<$-_*$__-$__<<$-_*($__+@_)<<@__<<@__;@___=''<<$-_*$__-$_*$_<<$-_*($__+$_)-$_<<@__<<@__;(___=->____{$.+=_;____<<($.%$-_==__¬†?$___+@___:$.%$_==__ ?$___:$.%$__==__ ?@___:$.);$.<($__*@_)**@_?___[____]:____})[[]]
09:19:26 <[k-> this is fizzbuzz in ruby!
09:19:48 <ongy> it wasn't mandatory, just a little fun competition. Also encourages you to look into language constructs
09:20:11 <pavonia> NickHu: It trains your brain to think unconventionally
09:20:49 <NickHu> sm: 500ms load time lol what a waste
09:21:05 <prsteele> well I already use slack to waste time, so...
09:22:49 * hackagebot store 0.2.1.1 - Fast binary serialization  https://hackage.haskell.org/package/store-0.2.1.1 (borsboom)
09:22:51 <kgadek> hi! You may (or not) recall me from Flowbox ‚Äî those guys that make VFX software; Haskell inside, _some_ Luna language, etc. We're currently expanding our interests, we're looking for opportunities to use Haskell anywhere possible. If anyone needs a group of Haskellers with professional experience to get the job done (and done provably well with TC of course!), reach me at kgadek@flowbox.io
09:23:17 <NickHu> What does provable well with TC mean?
09:23:52 <kgadek> well, only that the typechecker can prove a program is right
09:23:54 <_matix> Can anyone explain the error I'm finding here on line 23?  (a type mismatch error)  http://lpaste.net/187415#line23
09:24:18 <glguy> _matix: You need (f:r) to be (f,r)
09:24:39 <_matix> glguy: thank you.
09:24:40 <NickHu> kgadek: But the typechecker only tells you your types are correct, which isn't the same thing as program correctness
09:25:07 <hoppfull> Is it possible to do "case x of x when x < 0 -> 0 otherwise -> x"
09:25:09 <kgadek> NickHu: of course, the area of proof is dependent on the programmers. You can prove basically nothing except for most basic things. Sometimes you can prove some deeper properties and thus prove more elaborate things, like thread-safetey
09:25:12 <kgadek> *safety
09:25:37 <amalloy> hoppfull: use a guard
09:25:43 <haasn> The type checker can prove that your program won't crash, it can't prove that your program will compute the correct result
09:25:46 <hoppfull> amalloy: alright, thanks mate!
09:26:04 <amalloy> case x of x | x < 0 -> 0 ; otherwise -> x
09:26:04 <kgadek> haasn: true and false. Depends on what you want to prove
09:26:10 <[k-> or an if-else-then statement
09:26:11 <amalloy> of course for this specific example, it's just max x 0
09:26:18 <kgadek> haasn: can't prove everything of course
09:26:30 <amalloy> er, min x 0 i guess
09:26:35 <pavonia> hoppfull: What about "max [0, x]"?
09:26:38 <hoppfull> amalloy: That's what I was looking for! Thanks!
09:26:38 <amalloy> i get those confused all the time
09:26:49 <hoppfull> pavonia: The specific example isn't important.
09:27:01 <hoppfull> pavonia: But thanks anyway.
09:27:01 <NickHu> pavonia: You probably mean maximum rather than max
09:27:03 <pavonia> Also my syntax was wrong :(
09:27:15 <haasn> kgadek: Speaking generally. You can use it to prove some specific things, though, like that your red/black tree is a valid red/black tree, true
09:27:19 <[k-> pavonia is golfing :D
09:27:25 <ongy> pavonia: there's max and maximum
09:27:34 <NickHu> max doesn't take a list [k- 
09:27:35 <pavonia> ongy: Yeah
09:27:44 <[k-> max would work without the list
09:28:00 <[k-> so effectively it's shorter without the list 
09:28:15 <kgadek> haasn: well, yes. Or that you won't escape runST
09:28:36 <NickHu> pavonia: alternatively uncurry max (0, x)
09:28:47 <kgadek> haasn: I won't tell you that you can prove everything, even if it would be possible it wouldn't be feasible 
09:29:10 <NickHu> kgadek: It's not possible, that's why we have halting problem
09:29:21 <kgadek> NickHu: I know :)
09:29:27 <haasn> And the incompleteness theorem
09:29:33 <kgadek> haasn: but proving that you conform to the REST api defined a priori is nice enough
09:29:55 <haasn> kgadek: Gives me an idea for a business model. Pay per proof.
09:30:23 <haasn> Add $X to include a proof that the program corresponds to a given REST api
09:30:31 <prsteele> I think most businesses would be happy with one or two tests in place of a proof, unfortunately
09:30:40 <haasn> Add another $X to include a proof that it will not overflow
09:30:43 <kgadek> integration tests are not complete though
09:30:54 <kgadek> TC proofs are‚Ä¶ well, something more to that
09:31:12 <MarLinn> add another $X for every proof that must be re-done because of changed requirements
09:31:16 <kgadek> because you can prove that you always ‚Äî for example ‚Äî return a User object and not a Tester object
09:31:32 <kgadek> tests can only show that for some finite use-cases this doesn't happen
09:32:38 <kgadek> in short, I see TC as a complement to tests. 
09:33:04 <ongy> kgadek: hve you ever used isabelle/hol or coq?
09:33:21 <MarLinn> bottom line: nice marketing blurb for management types. For professional programmers, maybe not so much ;)
09:34:49 <kgadek> ongy: yes ‚Äì coq ‚Äì though I didn't like it. I still like to make useful software. coq doesn't seem able to actually get any job done. On the other spectrum we have e.g. python, which is dynamically typed but can get the job done (arguably easily). I think of haskell as a nice middle-ground
09:36:13 <kgadek> MarLinn: well, investing some time into nicely typed program to make some unit-tests redundant (so save some time). That's a nice tradeoff. It's not always a best idea, but if you can do this then you can win small gains there and there
09:36:50 <kgadek> pragmaticity is crucial to business, I don't deny that
09:36:56 <kgadek> always pick best tool to get the job done
09:37:47 <kgadek> if you like no-typechecking, prefer a spectrum of tests and do it efficiently ‚Äî great!
09:38:20 <kgadek> if you'd like to get some software that's (arguably, again) more maintainable because of nice types and need a team‚Ä¶
09:38:24 <kgadek> ‚Ä¶you know where to find me ;)
09:39:28 <_matix> does the case     func (x:xs) = x  capture lists with only one element?
09:40:34 <ongy> yes
09:40:56 <ongy> all lists with at least on element
09:41:02 <amalloy> > case [1] of (x:xs) -> (x, xs)
09:41:05 <lambdabot>  (1,[])
09:41:09 <_matix> ongy: in that case, what value does xs carry?
09:41:18 <_matix> null? 
09:41:19 --- mode: glguy set -qq *!*@108.175.2.145 *!*@70.35.196.206
09:41:25 <_matix> or []
09:41:30 <rickclown> hello everyone
09:41:32 <_matix> nvm silly question
09:41:33 <amalloy> no such thing as null
09:41:34 <ongy> [], as amalloy demonstrated
09:41:43 <_matix> ongy: yes just realized 
09:42:58 <MarLinn> :t null -- ;)
09:43:01 <lambdabot> Foldable t => t a -> Bool
09:43:12 <_matix> Oh null is a function. 
09:43:19 <hydraz> > null []
09:43:21 <lambdabot>  True
09:43:38 <hydraz> So yes, technically xs is null. i.e., a value for which null returns True.
09:44:00 <Pandora4> hi
09:44:22 <ongy> hydraz: that sounds dangerous. With that argument id is True
09:44:43 <hydraz> I never said it was a good thing to claim :P
09:44:49 <Pandora4> is modular programming the same as functional programming , is there somekind of overlap?
09:44:58 <hydraz> But hey, whatever boats your float
09:45:32 <[k-> floats your boat
09:45:46 <hydraz> Boats your float.
09:46:13 <_matix> it's not a rocket appliance
09:46:15 <[k-> is it an allusion to something?
09:46:29 <hydraz> Not really
09:50:59 <ongy> Pandora4: what's modular programming?
09:51:32 <Pandora4> https://en.wikipedia.org/wiki/Modular_programming
09:52:08 <Pandora4> instead of classes, I gather, they use modules of functions, or code that's standalone, component based.
09:54:26 <ongy> sounds rather unrelated to me. There
09:54:39 <ongy> sounds rather unrelated to me. There are modules in haskell, but you can also find them in e.g. python
09:56:05 <ongy> and even if there's no language level support, the same rough idea can be done in C with properly separated headers and compile units
09:56:35 <nitrix> Are Control.Concurrent.Chan.Chan bounded and blocking at 1 element?
09:56:48 <nitrix> What if one reader is lagging behind, does it affects writers?
09:57:04 <glguy> nitrix: check out http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent-Chan.html#t:Chan
09:57:46 <nitrix> glguy: "Write a value to a Chan." osm
09:57:48 <nitrix> isn'
09:57:52 <nitrix> isn't very descriptive.
09:58:02 <glguy> Yeah, you'll have to read more than that )
09:58:12 <nitrix> The MVar isn't saying enough.
09:58:24 <glguy> data Chan a; Chan is an abstract type representing an unbounded FIFO channel.
10:00:05 <bwe> Hi, I want to write test cases with Hspec. I've learned about haddock documentation that it supports example syntax. To me it's redundant to define examples and test cases (which can in many cases be the same). Is there a way to do it once for both?
10:00:32 <glguy> bwe: Search for "doctest"
10:00:46 <nitrix> glguy: I must have a peculiar bug then.
10:01:41 <ongy> glguy: you are still op btw.
10:01:52 <glguy> so true
10:02:05 <glguy> The client shows a little @ next to my messages so I can tell
10:02:31 <nitrix> glguy: I can tell just by your abrassiveness ;)
10:03:20 <monochrom> I hope that's just a joke.
10:05:43 <nitrix> Keeping your hat indoor in impolite.
10:05:49 <nitrix> :P
10:07:40 <monochrom> But it is not a hat. It is a staff keycard.
10:08:26 <ongy> or police badge
10:08:42 <glguy> Anyway, discussion about moderation is welcome in #haskell-ops
10:09:30 <ongy> I didn't want to complain. It's just not common in here, so I thought you may have missed it
10:15:58 <[k-> It's strange how in other irc networks, ops can be seen pervasively. Freenode doesn't have this culture though
10:19:44 <bwe> glguy: That's precisely what I want.
10:20:04 <glguy> bwe: You can see it in action with the lens package (and presumably many other places)
10:22:50 * hackagebot store-core 0.2.0.1 - Fast and lightweight binary serialization  https://hackage.haskell.org/package/store-core-0.2.0.1 (borsboom)
10:24:38 <ongy> what's the difference between -blah and -offtopic?
10:25:01 <geekosaur> -blah is controlled by someone else, and requires SSL connection
10:25:01 <hpc> one of them is cooler
10:25:06 <hpc> :P
10:26:11 <[k-> which?
10:30:19 <bwe> glguy: I have doctest up and running. What a bliss! If I specify another couple tests with Hspec. Then how do I bring both doctest and hspec in tandem? I mean one call for both?
10:31:22 <prsteele> bwe: I haven't used either of those (just HTF and QuickCheck) but if this question were about those the answer would be 'write your own main function' rather than relying on the auto-generated one
10:31:22 <glguy> bwe: You can have multiple test sections in your .cabal file
10:31:36 --- mode: glguy set -o glguy
10:32:30 <bwe> glguy: Fine. How can I do it? https://www.haskell.org/cabal/users-guide/ has nothing to say about this specifically, isn't it?
10:32:46 <glguy> bwe: https://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
10:33:48 <bwe> glguy: Thanks.
10:35:02 <nek0> Hi folks. I have a question I cannot find any answers for on the internet. Is it possible to query the version number at compile time and make it accessible to the executable?
10:35:36 <glguy> http://hackage.haskell.org/package/base-4.9.0.0/docs/System-Info.html#v:compilerVersion
10:35:45 <glguy> or do you mean the package version?
10:35:50 <glguy> That's in Paths_yourpackagename
10:36:25 <nek0> I meant the package version.
10:36:40 <glguy> https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
10:37:10 <nek0> thank you very much, glguy 
10:41:31 <abstract-alf> I'm trying to get a list of file paths in the current directory that are themselves directory. I have the following: do dir <- getCurrentDirectory; contents <- getDirectoryContents dir; dirs <- filter doesDirectoryExist contents.  Trouble is, `doesDirectoryExist` returns an IO Bool, not a bool, so I can't directly call filter that way.  Suggestions?
10:42:42 <ongy> :t filterM -- abstract-alf 
10:42:43 <glguy> :t filterM
10:42:49 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
10:42:50 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
10:43:18 <hydraz> haha
10:44:10 <abstract-alf> nice, who wins?
10:44:33 <ongy> I guess you do. Got the advice you asked for :)
10:44:58 <glguy> *high five*
10:45:19 <abstract-alf> thanks!
10:46:09 <abstract-alf> I should have known about filterM, considering how I'm already using mapM in this program
10:47:38 <ongy> :t filterA
10:47:40 <lambdabot> error:
10:47:41 <lambdabot>     ‚Ä¢ Variable not in scope: filterA
10:47:41 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
10:48:00 <abstract-alf> (empty list)
10:48:26 <jle`> wait
10:48:33 <geekosaur> are you actually using getCurrentDirectory, or some other directory?
10:48:35 <jle`> oh ok
10:48:53 <jle`> i was thinking of findM, which can't be implemented using Applicative
10:48:57 <abstract-alf> jle`, I'm actually using getCurrentDirectory.  
10:49:08 <abstract-alf> my program will be compiled to EXE and used in-place
10:50:13 <ongy> why is it liftA/liftM but filterM when it has the Applicative constraint?
10:50:21 <hydraz> ¬Ø\_(„ÉÑ)_/¬Ø
10:50:27 <abstract-alf> yeah, that's weird
10:50:29 <hydraz> Probably because filterM is older than the AMP
10:50:34 <jle`> ongy: historical reasons
10:50:36 <abstract-alf> yeah, different module
10:50:42 <jle`> when filterM was written, Applicative didn't exist yet
10:50:42 <glguy> Because it wasn't previously the case that Applicative was a superclass of Monad
10:50:56 <geekosaur> also liftM is a different kind of mess >.>
10:50:59 <hydraz> It did exist, just wasn't a superclass of monad
10:51:21 <geekosaur> (it's a historical accident that reconstructs fmap from (>>=))
10:51:21 <glguy> hydraz: and before that it didn't exist!
10:51:36 <hydraz> glguy: right
10:52:26 <_matix> er. what do i do if a cabal package requires base=>4.7 && <4.8  ?  can i just cabal install base@4.7 ?  will this mess with my environment
10:52:38 <hydraz> Sandboxes!
10:52:39 <glguy> _matix: base versions are tied to GHC versions
10:52:47 <hydraz> No sandboxes? alright
10:53:12 <_matix> hydraz: is there a tool for sandboxing?
10:53:22 <hydraz> `cabal sandbox`
10:53:25 <_matix> oh heh
10:53:33 <ongy> _matix: if you have it as library dependencie you will have to use a compatible ghc version
10:53:39 <geekosaur> there are at least two, they just won't help here because base also contains the ghc runtime
10:53:40 <abstract-alf> OK, so `read` throws an exception if it cannot actually do the string -> a conversion.  Is there a version of `read` that returns a Maybe a?
10:53:47 <hydraz> But, yeah, that.
10:53:56 <[k-> readMaybe
10:54:14 <abstract-alf> wow, I should really have tried that first
10:54:16 <geekosaur> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/Text-Read.html#v:readMaybe
10:54:29 <_matix> hm.  will all hell break loose if i just modify the build-depends to accept version 4.8.2 ?  xD 
10:55:00 <geekosaur> it could fail to build --- but you don't need to modify, use --allow-newer=base
10:55:00 <ongy> you can try that. If it compiles get a issue/pr up upstream
10:55:16 <geekosaur> (assuming your cabal command isn't ancient)
10:55:29 <_matix> oh right.  i won't have bugs, it just won't build!  wow.. what an amazing feature lol
10:55:44 <hydraz> There are no bugs if you have no program.
10:59:02 <sboosali>     <command line>: can't load .so/.DLL for: stdc++.dll (addDLL: could not load DLL)     ghc.exe: stdc++: The specified module could not be found.
10:59:15 <sboosali> hey, i got this weird error (stack build on windows 10, ghc 7.10.*), triggered by a line of TemplateHaskell (makeLenses):
10:59:21 <sboosali>     <command line>: can't load .so/.DLL for: stdc++.dll (addDLL: could not load DLL)     ghc.exe: stdc++: The specified module could not be found.
10:59:45 <sboosali> i tried googling it, but the issues dicussions didnt seem to help
11:00:18 <geekosaur> something is using C++, and you don't have (the right version of) its runtime installed
11:00:22 <sboosali> I tried reproducing it in smaller packages, and with simpler TH-macros, but haven't been able to
11:00:51 <sboosali> geekosaur thanks, can you explain?
11:02:09 <prsteele> sboosali: you could try `dumpbin /DEPENDENTS` on... either stack or GHC, maybe, to see what runtime libraries they think they need
11:02:15 <geekosaur> not without knowing what you are working with. I must assume the module you are compiling imports a module that binds to C++ code via the FFI, so Template Haskell needs to import the module to make sure it has all the types in scope it might need
11:02:48 <sboosali> prsteele: thanks! let me try that
11:07:10 <sboosali> geekosaur: it also errors when lens is the only import in the module, but lens has a lot of dependencies (maybe text?). And, I hadn't been able to cause it to error in a new package with the same snapshot that only depends on lens and only calls makeLenses. maybe my package is doing something weird.
11:15:26 <abstract-alf> Do you all think the use of the |> operator could be considered idiomatic Haskell? (|>) x f = f x
11:15:53 <prsteele> abstract-alf: that looks like & from lens, I think
11:16:15 <sboosali> prsteele: i got
11:16:18 <sboosali> prsteele:  "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\dumpbin.exe" /dependents "C:\Users\Maria\AppData\Roaming\local\bin\stack.exe"   Image has the following dependencies:     ADVAPI32.dll     CRYPT32.dll     GDI32.dll     KERNEL32.dll     msvcrt.dll     SHELL32.dll     USER32.dll     WINMM.dll     WS2_32.dll  "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\dumpbin.exe" /dependents "C:\Users\Maria\AppData
11:16:24 <abstract-alf> xs |> map f |> filter f2  vs (filter f2) $ map f xs
11:16:32 <sboosali> let me clean that up
11:16:41 <abstract-alf> prsteele, it's a F#/elm idiom
11:16:55 <abstract-alf> prsteele, called "pipe"
11:17:37 <[k-> there's a package for this, called Flow 
11:17:38 <hydraz> It's also Data.Function.(&)
11:17:48 <hydraz> :t Data.Function.(&)
11:17:50 <lambdabot> error:
11:17:50 <lambdabot>     Not in scope: data constructor ‚ÄòData.Function‚Äô
11:17:50 <lambdabot>     Perhaps you meant one of these:
11:18:08 <prsteele> abstract-alf: so anyway yes, I've seen it in use but called (&)
11:18:20 <ongy> :t (Data.Function.&)
11:18:22 <lambdabot> a -> (a -> b) -> b
11:18:26 <hydraz> thanks
11:18:42 <sboosali> prsteele: together, they need these CRYPT32.dll GDI32.dll KERNEL32.dll msvcrt.dll SHELL32.dll USER32.dll WINMM.dll WS2_32.dll ADVAPI32.dll KERNEL32.dll WSOCK32.dll
11:18:47 <abstract-alf> prsteele, thanks
11:18:51 <abstract-alf> hydraz, thanks
11:18:58 <hydraz> np
11:19:12 <prsteele> sboosali: from your error you might want to check ghc.exe
11:19:32 <sboosali> prsteele: how do I check it?
11:19:57 <sboosali> prsteele: (btw, ghc alone needs ADVAPI32.dll     GDI32.dll     KERNEL32.dll     msvcrt.dll     SHELL32.dll     USER32.dll     WINMM.dll     WSOCK32.dll
11:20:18 <sboosali> prsteele:
11:20:35 <sboosali> prsteele: Whenever I've had template Haskell problems in the past, it's almost always been related to profiling.
11:20:47 <sboosali> I disabled profiling (it already wasn't enabled), but that didn't help
11:20:54 <prsteele> sboosali: so I'm not really a Windows guy, and none of those jump out at me as being C++. Maybe msvcrt. I'm probably running out of usefulness for this problem, sorry
11:21:16 <sboosali> prsteele: ok thanks again
11:22:23 <zyhn> how do I specify where stack should put an executable that it has built?
11:22:52 * hackagebot aeson-pretty 0.8.2 - JSON pretty-printing library and command-line tool.  https://hackage.haskell.org/package/aeson-pretty-0.8.2 (FalkoPeters)
11:23:35 <zyhn> i.e. can I change local-bin?
11:25:25 <lingxiao> hey guys
11:25:33 <lingxiao> im running my code on remote and Im encountering this error: stty: standard input: Inappropriate ioctl for device
11:25:38 <lingxiao> and I'm really stuck on how to fix it
11:25:42 <lingxiao> kI'm using 
11:26:00 <lingxiao> im opening a bunch of files and streaming it using conduit
11:26:11 <geekosaur> that error isn't from haskell, it's from a shell script or dotfile
11:26:27 <lingxiao> right ... and my shell script is fine, the sys admin checked it
11:26:34 <geekosaur> that is invoking the stty command on something that is not a tty (probably a pipe)
11:27:21 <geekosaur> zyhn, https://docs.haskellstack.org/en/stable/yaml_configuration/#local-bin-path
11:27:24 <lingxiao> my function also runs fine on some dumy data
11:27:45 <lingxiao> geekosaur sorry could you elaborate on this: invoking the stty command on something that is not a tty (probably a pipe)
11:28:58 <lpaste> geekosaur pasted ‚Äústty‚Äù at http://lpaste.net/187505
11:29:08 <geekosaur> lingxiao ^
11:29:31 <lingxiao> geekosaur ok if i may make a confession im a complete noob at this
11:29:38 <geekosaur> in your case, I suspect you are using ssh with a command, so you don't have a tty
11:29:42 <lingxiao> im googling what stty is but what is the lpaste you sent me?
11:29:46 <geekosaur> `ssh -tt` will work around this
11:29:55 <lingxiao> still greek to me :(
11:30:01 <lingxiao> where do i say ssh -tt
11:30:11 <lingxiao> all i know how to do is move files from local to remote ..
11:30:19 <lingxiao> and submit a job to queue ... :(
11:30:26 <geekosaur> oh
11:30:32 <lingxiao> and i learned that two days ago ..
11:30:36 <lingxiao> yeah .. :(
11:30:38 <geekosaur> that's a different story. batch jobs like that generally do not run interactively
11:31:29 <lingxiao> yeah ... 
11:31:31 <geekosaur> *somewhere* you have a script, or are invoking a command with `createProcess` or `system` or etc., that is running the `stty` command
11:31:51 <geekosaur> I cannot say any more because I do not know what exactly you are doing
11:32:06 <lingxiao> yeah  me neither .. im using conduit ..
11:32:08 <joe9> when rendering graphics, can all scaling be expressed by matrix? such as logarithmic scaling? I understand that linear scaling can be defined by a matrix. Not sure if that can be done when logarithmic scaling is used?
11:32:11 <geekosaur> sigh
11:32:21 <geekosaur> conduit is not related
11:32:21 <lingxiao> but the thing is that it works with my dummy data ..
11:32:33 <lingxiao> ok good because i would have no idea how to debug it 
11:32:41 <jle`> joe9: what do you mean by logarithmic scaling?
11:32:45 <geekosaur> and I doubt your data is related, unless you are invoking an external command and it somehow behaves differently on the data
11:33:00 <geekosaur> but all I can do is guess, because you have not shown what you are doingf
11:33:08 <jle`> joe9: things like x' = log(x) ?
11:33:12 <lingxiao> sorry how do I show what I'm doing?
11:33:49 <joe9> jle`: http://bl.ocks.org/mbostock/7621155 the scaling used by this graph.
11:34:21 <lingxiao> its weird since changing the source of data is the only way i can get the program to run
11:34:46 <joe9> jle`:  I am not good at math , hence not sure if the expression x' = log(x) describes the scale used
11:35:20 <geekosaur> so, can you lpaste whatever file or command you are changing to change the source of the data?
11:36:03 <lingxiao> Geekosaur here's my main.sh:  http://lpaste.net/187513
11:36:16 <lingxiao> here's my shell script: http://lpaste.net/187514
11:36:19 <jonored> logarithmic isn't just a matrix transform; matrices only (by themselves) do linear.
11:36:29 <jle`> yeah, you wouldn't be able to do that with a straightforward multiplication by some matrix.  traditional "transformation matrices" are simply coefficients between each pair of bases, expressing the bases in the new space as a linear combination of the bases in the old space
11:36:52 <jle`> in an essense, transformation matrices are literally nothing more than the parameterization of an arbitrary linear transformation
11:37:24 <jle`> "what is the bare minimum i need to describe a linear transformation between these bases?" => put them in a box, you got a matrix.
11:37:29 <joe9> jle`:  https://github.com/d3/d3-scale/blob/master/src/log.js the java script source
11:37:56 <joe9> jle`: Thanks.
11:38:37 <jle`> so the matrices you're thinking about can't really describe anything other than a linear transformation, because they are constructed in a contrived way specifically for linear transformations
11:40:31 <joe9> jle`: makes perfect sense. Thanks.
11:40:52 <jle`> joe9: you can taylor transform continuous transformations to get approximations of them as linear transformations at a given point, though
11:41:17 <jle`> the act of a transformation around a point and its local neighborhood can be approximated as roughly linear
11:41:37 <jle`> but in this case you'd just have a different "matrix" to use at every point, so not super useful here
11:42:12 <jle`> hm
11:42:23 <jle`> well, it might be useful if you can find a closed-form expression for the matrix components
11:43:24 <joe9> jle`: I am reading up on opengl to render a chart of around 10,000 points in realtime.
11:43:28 <jle`> so instead of calculating f(x), you could calcuate `A(x) * x + b(x)`, where A is a linear transformation matrix approximating f specifically at the point x
11:43:54 <jle`> which might be optimizable
11:44:10 <joe9> jle`:  I am thinking if there is a possiblity to specify the scale to the opengl renderer as a matrix and let it do the number crunching.
11:44:18 <jle`> oh yeah no not that
11:44:56 <joe9> jle`: It would work for linear scale. but, from what I gather, it would not work for logarithmic or any other scale.
11:46:01 <jle`> yes.  if there is a function asking for a transformation matrix, what that function is really asking for is a bunch of coefficients to describe a linear transformation
11:46:33 <jle`> the fact that you give it to it in matrix form is incidental
11:46:48 <joe9> jle`: ok, makes sense. Thanks.
11:46:57 <jle`> np!
11:47:26 <lingxiao> Geekosaur I don't know if what I sent is helpful at all
11:47:40 <geekosaur> it's not :( I have no idea what is going on
11:47:43 <abstract-alf> Thoughts? https://pbs.twimg.com/media/B58DjdCCQAASQrI.jpg
11:47:59 <abstract-alf> is lens truly that difficult?
11:48:19 <geekosaur> all I can imagine at this point is that there is some complexity to the batch system, and I cannot know or guess what that might be
11:48:33 <hesk> I get the error "Record syntax is illegal here: {foo :: String, bar :: String, baz :: String}". Couldn
11:48:44 <hesk> 't google anything worthwhile, could anyone help? 
11:48:53 <prsteele> hesk: paste some context
11:49:09 <geekosaur> um, unless main_test is doing something clever; you did not include the Core or MainSubroutines modules
11:49:28 <hesk> I'm defining a data type. I'll paste code 
11:49:47 <jle`> you might have forgotten the constructor
11:50:09 <jle`> data Foo = FooConstructor { foo :: String, bar :: String }
11:50:22 <geekosaur> abstract-alf, it's not really that difficult, you can use it for most things without understanding the type level hackery underlying it.
11:50:39 <hesk> The problem was I had (Show) at the end without the "deriving" :P 
11:50:58 <jle`> :P
11:51:13 <hesk> thanks though!
11:51:30 <geekosaur> abstract-alf, that said, a typo can get you a weird type error you may well not be able to decipher without some understanding of the implementation
11:54:56 <Malice> who here has installed the kali toolkit onto linuxmint
11:57:12 <geekosaur> what exactly does that have to do with Haskell programming?
11:59:27 <lingxiao> Geekosaur sorry yeah there's actually lots of files .. here's the repo: https://github.com/lingxiao/GoodGreatIntensity
11:59:32 <lingxiao> main is in app
12:03:49 <lingxiao> I don't know if it's really helpful
12:04:00 <lingxiao> and what do you mean by doing something with Batch?
12:06:09 <geekosaur> lingxiao, I do not know what batch system you are using (you said you were submitting jobs) or what it does
12:06:31 <lingxiao> oh i thought by batch you means omething in my code .. funny here's the message from the sys admin
12:06:32 <lingxiao> http://lpaste.net/187546
12:06:56 <lingxiao> essentially saying the same thing you're saying ... but he's saying the problem is in the haskell cod
12:06:56 <lingxiao> e
12:07:46 <geekosaur> it's not.
12:07:55 <lingxiao> yeah it certianly works on my machine
12:07:57 <hesk> Hey does anyone know how to get the number e=2.71... from prelude? 
12:08:13 <geekosaur> and he missed a clue: I just looked at logs, and the stty message comes out even before the run script tries to change directory
12:08:14 <jle`> > exp 1
12:08:18 <lambdabot>  2.718281828459045
12:08:30 <geekosaur> I am going to guess the batch system runs your shell dotfiles and you have an unprotected stty command there
12:08:39 <hesk> lambdabot: that isn't e! :)
12:08:44 <hesk> thanks jle
12:08:46 <geekosaur> that is, in ~/.bash_profile or ~/.bashrc
12:08:47 <lingxiao> by shell dotfiles you mean my main.sh
12:08:53 <jle`> np!
12:09:09 <lingxiao> so you're syaing there's an unprotected ssty command in my    main.sh?
12:09:28 <lingxiao> here it is: http://lpaste.net/187549,   but he saw it too and saw nothing wrong
12:09:57 <geekosaur> [09 19:08] <geekosaur> that is, in ~/.bash_profile or ~/.bashrc
12:11:38 <lingxiao> oh osrry i mustve missed that message, but i cannot ssh into  ~/.bash_profile or ~/.bashrc  though?
12:11:42 <lingxiao> so I can't inspect what's wrong
12:14:39 <ReinH> you can't... ssh... into... a file?
12:15:21 <shachaf> ReinH: That sounds like a true statement.
12:15:25 <ReinH> It dies.
12:15:27 <ReinH> does
12:15:42 <ReinH> So I'm wondering why they're surprised by this.
12:15:54 <lingxiao> sorry .. i meant open it
12:17:11 <geekosaur> then I have no idea what is going on
12:17:59 <lingxiao> yeah oh boy :(
12:18:05 <lingxiao> thanks for helping me though!
12:18:25 <ReinH> why can't you open those files?
12:19:43 <geekosaur> well, could be lots of things, like they have .profile instead of .bash_profile or they use zsh instead of bash (in which case there's like 4 possible files it could be using) etc
12:20:34 <ReinH> geekosaur: which is why I was asking them? :)
12:22:52 * hackagebot printf-safe 0.1.0.1 - Type safe interface for Text.Printf  https://hackage.haskell.org/package/printf-safe-0.1.0.1 (kcsongor)
12:22:55 * hackagebot vector-space 0.10.4 - Vector & affine spaces, linear maps, and derivatives  https://hackage.haskell.org/package/vector-space-0.10.4 (ConalElliott)
12:23:43 <geekosaur> in any case, the stuff in logs --- because it has some errors from when you used the wrong directory --- indicates that the stty error is happening before anything else, so it is something about the shell startup environment.
12:24:13 <geekosaur> it's back in your local sysadmin's lap at this point; I cannot guess what the batch system does when it initializes the environment for a batch job
12:24:34 <geekosaur> lingxiao, ^
12:25:14 <lingxiao> geekosaur it's weird becuase in my main, it also creates a new direcotry in my project folder called outputs
12:25:26 <lingxiao> that outputs folder does appear when i run my exe file
12:25:28 <geekosaur> (a real batch system would timestamp those log lines. sigh)
12:25:40 <geekosaur> right, the stty is not a fatal error
12:25:41 <lingxiao> haha I'll leave that part out in my email to sys admin
12:25:53 <geekosaur> it goes on and runs your job
12:26:42 <lingxiao> oh i see .. ok i'll try again and email him
12:26:46 <lingxiao> sys admin that is
12:26:51 <ReinH>  Can this be tested by creating a new login shell and running it from there?
12:27:29 <geekosaur> sh main.sh </dev/null
12:27:32 <ReinH> lingxiao: so why can't you open your dotfiles?
12:27:38 <lingxiao> i have no idea ..
12:27:38 <geekosaur> that would rule out everything related to the job itself
12:27:44 <ReinH> what do you mean, you have no idea
12:27:46 <ReinH> did you try it?
12:27:47 <geekosaur> and thereby finger the batch system
12:27:49 <lingxiao> yeah ...
12:27:54 <ReinH> well? what happened?
12:28:04 <lingxiao> yeah i cant run the script in the top node if that's what you're asking
12:28:43 <ReinH> geekosaur: yeah, exactly
12:28:47 <lingxiao> ok so when i do less ~/.bash_profile i get this:
12:29:19 <lingxiao> less ~/.bashrc someting opens and i see this:
12:29:28 <lingxiao> ping
12:29:31 <lingxiao> "/home1/l/lingxiao/.bashrc lines ?-?/? (END)"
12:29:31 <ReinH> ?
12:29:40 <lingxiao> sorry, ignore the ping
12:29:48 <ReinH> what happens when you open it with an editor?
12:29:52 <geekosaur> guessing they pasted output starting with a slash and their client got upset
12:30:06 <lingxiao> emtpy
12:30:13 <ReinH> Ok, so you *can* open it and it is empty.
12:30:18 <ReinH> That is different from not being able to open it.
12:30:25 <ReinH> what about .bash_profile?
12:30:45 <ReinH> and what does ``echo $SHELL'' say?
12:30:56 <lingxiao> actually that's empty too
12:31:02 <ReinH> Ok, so they are empty.
12:31:14 <ReinH> That's good to know.
12:31:16 <lingxiao> "/pkg/bin/bash"
12:31:26 <lingxiao> haha did that backslash wont show up thing again
12:31:35 <ReinH> just put a space in front
12:31:40 <lingxiao>   /pkg/bin/bash 
12:31:41 <lingxiao> ahh
12:32:18 <ReinH> Did you try geekosaur's suggestion?
12:32:23 <Nik05> or / + space
12:32:31 <geekosaur> / starts IRC commands. how you avoid that is to not start with a slash, or some clients have other ways (I can just double the inital slash; some other clients use /say, some clients don't have anyway to do it at al)
12:32:39 <ReinH> Although at this point I'm not sure that this is even a Haskell problem.
12:32:51 <lingxiao> ReinH sorry which suggestion are you refering to ?
12:32:56 <geekosaur> I'm quite sure it's not at this point
12:33:26 <geekosaur> I still think it's the batch system setting up the job env, and only whoever configured the batch system (or knows its config) will know for sure
12:33:33 <geekosaur> [09 19:27] <geekosaur> sh main.sh </dev/null
12:33:40 <geekosaur> lingxiao, ^
12:34:17 <geekosaur> if you don't get the stty error from that then it's not your job or your program that is doing it, it's the batch system while setting up the job environment
12:34:45 <lingxiao> ok i did sh main.sh
12:34:54 <lingxiao> and it's running main.sh right?
12:34:58 <geekosaur> yes
12:35:01 <ReinH> did you do what he said, or did you do ``sh main.sh''?
12:35:19 <lingxiao> i did sh main.sh </dev/null
12:35:21 <ReinH> ok
12:35:25 <geekosaur> but it's running it without stdin connected to a terminal, so if the stty is something inside your job you should get the errr message
12:35:45 <ReinH> I ask because the </dev/null is the important part
12:35:49 <geekosaur> if you do not, then the message is coming from whatever in the batch system runs your main.sh
12:36:53 <lingxiao> ok so sorry what does "it's running it without stdin connected to a terminal" mean?
12:37:13 <lingxiao> and by "so if the stty is something inside your job " you mean the stty is coming from the schedulear right?
12:38:05 <ReinH> "the stty is coming from inside the house"
12:38:22 <lingxiao> sorry what's the house?
12:38:27 <Clint> the house has scheduled ears
12:38:32 <geekosaur> if you get the stty error message output from 'sh main.sh </dev/null' then something in or run from main.sh is generating the error. if you do not, then whatever runs main.sh from the batch job submission is generating the error and you will need help from your sysadmin
12:38:39 <ReinH> lingxiao: a joke, ignore it
12:39:48 <lingxiao> haha ok great ... yeah im running it and its still running
12:39:52 <geekosaur> as for what is going on: the 'stty' command is used to configure terminal behavior. when you run something normally, it is attached to a terminal. when you redirect its input from /dev/null, standard input is not the terminal any more; it is the system device representing an "always-empty file"
12:40:08 <geekosaur> yes, it's running your job on whatever data
12:40:11 <wedify> what do you guys think of creating a multiparameter class for arithmetic operations. 'class Arith TypeFirstArg TypeSecondArg TypeResult where'?
12:40:12 <nitrix> Can I distinguish `import Network` (the library) as opposed to the module `Network` that I have locally?
12:40:32 <geekosaur> nitrix, only with PackageImports extension
12:40:36 <wedify> an advantage is i don't have to have fromIntegral everywhere
12:40:40 <geekosaur> import "networl" Network
12:40:42 <geekosaur> er
12:40:46 <geekosaur> import "network" Network
12:41:11 <johnw> geekosaur: cool, I'd forgotten about that extension
12:41:44 <wedify> nitrix: wouldn't it be better to use MyProject.Network instead?
12:41:55 <geekosaur> and yes, that's a better solution
12:42:04 <geekosaur> or even MyNetwork
12:42:25 <bwe> https://www.haskell.org/haddock/#Examples has a broken link under Examples section. Can anyone take care of this?
12:43:32 <ReinH> wedify: you're probably just replacing fromIntegral with explicit type signatures everywhere due to breaking type inference.
12:44:11 <geekosaur> lingxiao, an example of configuring terminal behavior: `stty -echo` turns off the terminal echoing back the keys you type, for use when e.g. reading passwords. (note that modern shells use an input mode that evades that setting, though, so it may not work at a shell prompt, only within programs you run)
12:44:11 <ReinH> nitrix: the common practice of prefixing your modules with a distinguishing namespace is in part designed to avoid this problem.
12:44:38 <lingxiao> oh wow i didnt know there's all these things going on
12:45:31 <nitrix> wedify: ReinH Noted. Good old "for now it needs to compile", but I left myself a note.
12:45:39 <nitrix> It seems indeed that I'll have to do exactly that.
12:45:52 <hesk> What is up with dividing with length? If i do 2/2 I get a nice Double but "length [1,2] / 2" returns an error, what gives? 
12:46:09 <implementation> :t length
12:46:12 <lambdabot> Foldable t => t a -> Int
12:46:19 <geekosaur> hesk, numeric literals are polymorphic
12:46:21 <athan> hesk: Integrals aren't floating :)
12:46:22 <implementation> :t (/)
12:46:25 <lambdabot> Fractional a => a -> a -> a
12:46:31 <geekosaur> since you use (/) it infers the numeric literal is a Double
12:46:39 <hesk> Why wont it convert for me? 
12:46:52 <geekosaur> but if you use a function that produces Int, you *must* use fromIntegral to make the result compatible with (/)
12:47:03 <implementation> hesk: there is no implicit conversion in haskell
12:47:05 <athan> hesk: Because of type safety :v
12:47:21 <hesk> Alright ^^. The more you know!  Thanks for the quick replies :) 
12:55:27 <ReinH> nitrix: just imagine, once upon a time there were no namespaces.
12:55:52 * nitrix pulls his hair
12:55:55 <nitrix> None D:
12:56:12 <ReinH> Well, the only change is now '.' is allowed in a module name. :)
12:56:30 <nitrix> We can pretend c:
12:56:45 <implementation> just imagine, in some other horrible universe, there were java-like namespaces. import Org.Haskell.Base.Prelude.*;
12:56:48 <nitrix> Is Foo...Bar valid?
12:57:07 <ReinH> Do you have a compiler sitting there?
12:57:17 <merijn> nitrix: It is with a double dot if it's an enum instance
12:57:19 <napping> ReinH: package-qualified imports are newer than that
12:57:22 <bwe> When I define a Test-Suite, do I need to put the same build-depends from Executable?
12:57:43 <ReinH> napping: sure
12:57:46 <bwe> (provided that Test-Suite has same main-is: as Executable.)
12:57:54 <nitrix> merijn: Those are imports.
12:58:13 <ReinH> bwe: As a general rule, no. If they are the same thing, they need the same imports.
12:58:18 <nitrix> merijn: import Foo...Bar
12:58:21 <ReinH> and thus the same packages
12:58:29 <merijn> nitrix: What would that even mean?
12:58:42 <bwe> ReinH: Thanks for clarification.
12:59:01 <bwe> ReinH: So, Test-Suite sees that in Executable and inherits it from the latter?
12:59:21 <nitrix> merijn: Nothing. I'm simply curious if the namespace currently is just about allowing `dot` in the name but it still being flat.
12:59:44 <nitrix> merijn: On linux `.` could be understood as a folder name.
13:00:08 <ReinH> bwe: No.
13:00:17 <ReinH> Test-Suite doesn't know anything about Executable
13:00:40 <bwe> ReinH: So why don't I need the build-depends for test that Executable requires?
13:01:02 <merijn> nitrix: Dot is simply a separator
13:01:21 <merijn> nitrix: Incidentally, the way module names are mapped to filenames is completely implementation defined
13:01:38 <merijn> So the one directory per module level is strictly GHC
13:01:45 <geekosaur> nitrix, in theory a module system could deal with that. in practice ghc's module system maps the .s to /s and it looks for Foo///Bar.hi. whether that is an acceptable pathname is up to the OS; whether it is a *useful* one is debateable
13:02:09 <lingxiao> geekosaur when i do stack build o remote i get this: WARNING: Installation path /mnt/castor/seas_home/l/lingxiao/.local/bin not found on the PATH environment variable 
13:02:12 <geekosaur> (on many Unixlikes it is the same as Foo/Bar.hi, or `import Foo.Bar`. on some, it is an error)
13:02:15 <napping> in practice, GHC doesn't allow Foo..Bar as a module name, but I don't see where it's documented
13:02:16 <lingxiao> should i ignore this warning
13:02:21 <merijn> geekosaur: Pretty sure it's an illegal module name according to the report
13:02:26 <lingxiao> sorry stack install , not stack build
13:02:28 <merijn> napping: The report doesn't allow it
13:02:51 <merijn> napping: It's not Haskell to have "Foo..Bar", so I don't see why it should be documented?
13:03:09 <napping> The user's guide just says "allow dots in module names"
13:03:13 <geekosaur> lingxiao, you aren't running your program via $PATH, so you can ignore it
13:03:20 <lingxiao> ok great thanks!
13:03:22 <merijn> napping: The user guide is not the definition of Haskell
13:03:29 <napping> something that doesn't specifically exclude cases like Foo..Bar that nitrix asked about
13:03:31 <merijn> napping: The Haskell 2010 Report defines the language
13:03:37 <MarcelineVQ> bwe: Test-Suite needs whatever Test-Suite uses, whether that's the same things as Executable depends entirely on your project.
13:03:50 <merijn> napping: The user guide is merely implementation details of GHC
13:04:05 <ReinH> bwe: What? What I said is that you need the same thing.
13:04:14 <ReinH> So how did you get from that that you don't need the same thing?
13:04:17 <merijn> napping: And the language report does not allow more than 1 dot in a row in module names
13:04:55 <prsteele> "modid 	‚Üí 	{conid .} conid 	    (modules) " apparently, so yes, no consecutive dots
13:05:04 <bwe> ReinH: A lapse in my attention. Might be.
13:06:09 <ReinH> bwe: If your test-suite section has the same executable, it needs the same build-depends. It don't know anything about and does not inherit anything from your executable section.
13:06:38 <merijn> bwe: Usually for executables I just define a library with most of the code and have the executable/tests depend on that library
13:07:05 <merijn> bwe: Which 1) drastically reduces duplication of build-depends and two, makes reusing your code easier
13:07:49 <bwe> merijn: Having an example at hand?
13:08:00 <MarcelineVQ> this happens to be the default setup in a stack based project
13:08:03 <glguy> bwe: https://github.com/glguy/irc-core/blob/v2/glirc.cabal
13:10:14 <napping> merijn: I don't see anything near http://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/syntax-extns.html#hierarchical-modules that refers back to the standard
13:10:38 <merijn> napping: Well, no, but I don't see why it has to?
13:11:12 <merijn> napping: That part of the users guide seems old, because the hierarchical module system afaik is incorporated in Haskell2010
13:11:25 <napping> I'm saying it's reasonable to read compiler documentation without consulting the language standard, especially when you are reading about implementation-specific extensions and it doesn't point you back to the standard
13:11:52 <bwe> glguy: Thanks. But I can't follow completely. It must be too obvious to spot for me.
13:12:00 <napping> Or considering the question "If I'm reading this part of the docs, where do I go for more detail?"
13:12:38 <merijn> bwe: The executable and test-suite only have "glirc" as build-depends
13:12:54 <napping> That bit of the manual was dropped in the 8.0.1 docs, btw
13:12:56 <merijn> bwe: If you didn't use the library you'd have to duplicate the build-depends of the library section
13:13:39 <merijn> bwe: Line 42 and 140
13:14:09 <merijn> bwe: You depend on the library defined on lin 44-134
13:14:19 <bwe> merijn: Am I right the 'library' is not followed by a name, that this implies the following build-depends are defined for 'glirc'?
13:14:33 <bwe> merijn: This is where I cannot safely connect the dots.
13:14:39 <napping> pretty nifty how that works out
13:14:47 <merijn> bwe: Libraries have no name specifier
13:15:02 <merijn> bwe: You can have at most 1 library per package
13:15:16 <merijn> bwe: So the library name always matches the package name
13:15:39 <merijn> bwe: So it's like depending on any other library, except the executable and library are defined in the same cabal file
13:15:49 <S3thc0n> Hi, I'm having a weird type error whose reason I can't figure out after trying an hour, here's the code: http://lpaste.net/187622
13:16:03 <bwe> So, glirc.cabal defines Library glirc. Which is itself a build-depends of executable and test-suites.
13:16:15 <merijn> bwe: Right
13:16:26 <napping> S3thc0n: what error?
13:16:34 <S3thc0n> Would anyone mind taking a look and helping a beginner out? :)
13:16:41 <napping> "Error: use all" looks like some kind of lint output
13:16:42 <S3thc0n> napping: It's in the paste :)
13:17:04 <dogui> S3thc0n: seems to say use the 'all' function, can you try replacing 'and' by 'all id' ?
13:17:11 <dogui> S3thc0n: no clue why it says that though
13:17:13 <napping> but that's just suggesting you turn "and (map test list)" into "all test list"
13:17:21 <bwe> I feel the implementation of Haskell is too good to be comprehended by brains used to much unclearer stuff: "My brain is so used to that bad stuff that it cannot easily comprehend the simple stuff."
13:17:27 <merijn> bwe: And since importing the glirc library brings in scope all the stuff you probably want/need you don't need list the other stuff again
13:17:28 <glguy> You can ignore the pastebin "error" and "warning" lines
13:17:36 <napping> Oh
13:17:37 <dogui> ugh, true
13:17:38 <merijn> bwe: It happens ;)
13:17:55 <napping> I see, the fancy colors just make the pastebin complaints stand out so much more.
13:18:00 <S3thc0n> napping: Oh, strange, I'm not getting that on my end.
13:18:17 <glguy> S3thc0n: The pastebin "errors" aren't actual errors, they're opinions
13:18:32 <S3thc0n> glguy: Oh, I see :D
13:18:36 <napping> S3thc0n: I'm just confused, your real error is at line 29
13:18:47 <merijn> bwe: Occasionally you'll need a few extra build-depends for stuff that you use in tests that's not exported, but it should reduce most of the duplication
13:18:51 <S3thc0n> napping: Exactly
13:19:12 <merijn> bwe: And like I said, by having 90% of your application code be a library it makes reusing much simpler
13:19:20 <napping> S3thc0n: you switch halfway down the list "assignment6" from having the second element of the pair be a Bool to having it be atree
13:19:41 <geekosaur> oh, lingxiao? it just occurred to me that looking at your local dotfiles would not have been useful anyway, it's the ones that the batch job scheduler can reach that matter
13:19:46 <S3thc0n> napping: oh wow, ofc.
13:19:50 <prsteele> S3thc0n: in `assignment6`, the first element of the list has type (Bool, Bool), but the fourth element has type (BSearchTree Bool, BSearchTree Bool)
13:19:52 <geekosaur> I don't know if you can even get at those from your Mac
13:19:52 <napping> The first two lines are the most useful in that error
13:19:57 <merijn> bwe: Example: GHC is actually just a library + wrapper executable, this means that you can simply use it as a library (which stuff like hdevtools/ghc-mod do)
13:20:07 <S3thc0n> napping: Damn what a stupid mistake - I thought the actual test case was wrong all the time
13:20:09 <merijn> Anyway, bedtime :)
13:20:47 <S3thc0n> napping , prsteele: Thanks for taking a look, that helped a lot :D
13:21:06 <napping> S3thc0n: do you have any trouble reading that sort of error?
13:21:16 <napping> or you just didn't see why it made sense to get it?
13:21:33 <bwe> merijn: However if the functions covered by tests are only a small part of the library, and don't need the majority of imports, then it would be sensible not to import the library itself in the Test-Suite. Then I should import them explicitly. Have I got the point?
13:22:06 <marcelocamargo> Hello! Is there something like a bind (>>=) from IO () to IO [()]? Concurrent programming becomes harder when you must interface with other subtypes of IO
13:22:12 <S3thc0n> napping: Well, my problem is that GHC doesn't give me any deeper reason for a type error so I'm not always sure where to look for my mistake.
13:22:17 <bwe> merijn: Well, wishing you colorful dreams.
13:22:58 <napping> S3thc0n: well, the first line says what type the surrounding code needed, the second line says what type the subexpression has, and the rest of it is giving more and more code pointing you at where the problem happened
13:23:08 <S3thc0n> napping: In other words, it doesn't tell me WHY it expects the type to be Bool
13:23:08 <geekosaur> marcelocamargo, can you provide an example?
13:23:11 <hpc> marcelocamargo: standard XY problem disclaimer, but answer to the question as asked is probably ListT IO or something along those lines
13:23:39 <napping> yeah, that's the trickiest thing to figure out
13:23:45 <athan> Is it possible to make a newtype an instance of Unbox?
13:23:46 <geekosaur> Monad leaves the result type open, but the monad itself cannot change (here, IO); I am trying to understand what situation you are running into to provoke that question
13:24:14 <napping> (If you don't see why the inner expression has it's type, you can usually check that by building it up in GHCI)
13:24:51 <marcelocamargo> anyIoAction >> mapConcurrently downloadFile fileList
13:24:53 <napping> S3thc0n: actually, if you are using a not-ancient version of GHC you can probably use "Typed Holes"
13:25:28 <S3thc0n> napping: Yup, I did that, which is why I labeled the error 'weird' - I was not expecting there to be one after controlling all the subexpression types.
13:25:39 <S3thc0n> napping: Cool, I'll look into that!
13:25:44 <napping> 7.8 or newer
13:26:12 <napping> Most basic case, just write a "_" in an expression, and you'll get a compiler error saying what type it expects there
13:26:17 <ReinH> athan: Can you use GND?
13:26:43 <napping> so you can at least do something like turning larger and larger expressions around the error into a hole until you are back somewhere you understand
13:26:59 <napping> How did you controll the subexpression types? With annotations you didn't include in the paste?
13:27:12 <S3thc0n> napping: I see! That's very useful I think, thanks for the hint. :D
13:27:33 <S3thc0n> napping: I pasted them into GHCi and used :t on them :b
13:27:37 <geekosaur> marcelocamargo, that should just work
13:27:59 <napping> Ok. Throwing some type annotations straight into your program might help more
13:28:12 <S3thc0n> napping: What you said sounds like a much better idea, yes :)
13:28:24 <napping> I wonder what you get if you just added code that uses it?
13:28:25 <athan> ReinH: What do you mean?
13:28:30 <ReinH> and ioActionProducingAFileList >>= mapConcurrently downloadFile
13:28:45 <geekosaur> (>>) discards the result of the thing on the left and produces the result of the thing on the right. in newer ghc that may elicit a warning if you do not bind the result; the way to deal with that is to bind it vacuously (_ <- ...) or use Dtaa.Functor.void to ignore the result
13:28:47 <ReinH> athan: deriving (Unbox) with GeneralizedNewtypeDeriving?
13:28:50 <geekosaur> Data.Functor.void
13:28:56 <bwe> glguy: The library glirc has build-depends on base. The executable on glirc. But at the same time the executable has build-depends on base. Is this duplication intended? If, why?
13:29:12 <athan> ReinH: That's what I tried :\
13:29:14 <glguy> bwe: Because both the executable and library use base
13:29:16 <ReinH> athan: oh
13:29:16 <athan> it doesn't look possible
13:29:45 <ReinH> bwe: base is required for the Prelude
13:29:58 <ReinH> Pretty much everything requires base
13:30:08 <marcelocamargo> I get a big Couldn't match type `[()]' with `()'
13:30:21 <napping> S3thc0n: hey, you're listing separate testcases. Could you use a library?
13:30:25 <bwe> glguy: What would happen if I removed the base from the executable -- will it not get it from the library?
13:30:27 <ReinH> marcelocamargo: what's your full code?
13:30:36 <ReinH> (use a paste)
13:30:40 <S3thc0n> napping: You'd get exactly the same error, only that the quoted expressions now include the type annotations.
13:30:41 <glguy> bwe: Then it wouldn't compile due to not listing a direct dependency
13:30:41 <ReinH> s/paste/pastebin
13:30:46 <ReinH> ?lpaste
13:30:47 <lambdabot> Haskell pastebin: http://lpaste.net/
13:31:03 <napping> S3thc0n: I was hoping it would get far enough to complain about applying "test" to assignment6
13:31:04 <glguy> bwe: To import a module from a package you have to have a build-depend for that package
13:31:06 <napping> no luck
13:31:21 <S3thc0n> napping: I'd love to, but this is a graded assignment where only stuff we had in the lectures is allowed :|
13:31:24 <ReinH> bwe: no, again, one section doesn't inherit or get anything from another section
13:31:33 <ReinH> you have to be explicit
13:31:55 <glguy> bwe: You can clone the repository and try editing things to see what happens in different cases
13:31:55 <bwe> ReinH: Now I've got it!
13:32:24 <geekosaur> marcelocamargo, please lpaste the actual failing code and full error message
13:32:25 <geekosaur> @lpaste
13:32:25 <lambdabot> Haskell pastebin: http://lpaste.net/
13:33:05 <geekosaur> :t (>>)
13:33:07 <lambdabot> Monad m => m a -> m b -> m b
13:33:12 <marcelocamargo> Full-code: 
13:33:13 <marcelocamargo> https://gist.github.com/haskellcamargo/857a4577e7dac50a266c02c432f2167f
13:33:46 <marcelocamargo> Look at Main.hs. I've created a function called Test.
13:33:50 <marcelocamargo> It returns IO [()].
13:34:05 <S3thc0n> napping: Thanks again for your help :> You made me a happy Haskeller again :D
13:34:07 <napping> S3thc0n: looking at HUnit might give you good ideas. At the most basic, you have cases of different types so you need to at least put the == into your list
13:34:12 <marcelocamargo> Whenever I do, for example, putStrLn >> test param, I get a type mismatch by IO () for IO [()]
13:34:42 <napping> Haskell doesn't let you use types like [exists a . (Eq a) => (a,a)]
13:35:11 <marcelocamargo> This line fails: https://gist.github.com/haskellcamargo/857a4577e7dac50a266c02c432f2167f#file-main-hs-L50
13:35:22 <marcelocamargo> Well, advices: it uses a lot of Cabal packages, haha
13:35:24 <napping> at least not without a wrapper like "data Test = forall a . (Eq a, Show a) => Test a a"
13:35:24 <ReinH> marcelocamargo: What is the error message?
13:35:41 <ReinH> And please try to provide a minimal example
13:35:44 <mnoonan> dang marcelocamargo, did do-notation run over your dog or something?
13:35:46 <geekosaur> ok, the problem there is that parseAndInstall is inferred as producing IO ()
13:35:54 <S3thc0n> napping: What would that mean? I've only seen forall like this in error messages :b
13:36:03 <geekosaur> likely because the other case alternatives produce IO ()
13:36:16 <geekosaur> so you need test depList >> return ()
13:36:20 <ReinH> Yeah, that's a lot worse than the do notation alternative
13:36:28 <marcelocamargo> Main.hs:50:20:
13:36:28 <marcelocamargo>     Couldn't match type `[()]' with `()'
13:36:28 <marcelocamargo>     Expected type: IO ()
13:36:28 <marcelocamargo>       Actual type: IO [()]
13:36:28 <marcelocamargo>     In the return type of a call of `test'
13:36:30 <bwe> Can I specify only parts of a module in build-depends like I would do import MyModule(MyFunction) ?
13:36:30 <marcelocamargo>     In the second argument of `(>>)', namely `test depList'
13:36:33 <marcelocamargo>     In the expression: (putStr . show) depContent >> test depList
13:36:35 <marcelocamargo> Failed, modules loaded: NeedIt.
13:36:36 <ReinH> which was literally added to be an improvement on your code
13:36:38 <geekosaur> or change the definition of test to downloadDeps tuples >> return (), and its result type to IO ()
13:36:59 <marcelocamargo> Haha, I didn't try do-notation yet, but I'll do.
13:37:01 <mnoonan> also, I really like "\case" whenever you have the construct "\x -> case x of" for readability
13:37:02 <ReinH> or, again, use void
13:37:03 <napping> S3thc0n: It's this extension: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#existentially-quantified-data-constructors
13:37:08 <mnoonan> but that might just be me
13:37:08 <marcelocamargo> I don't like it so much, haha
13:37:26 <napping> that will give you a type Test with a constructor (Test :: (Eq a, Show a) => a -> a -> Test)
13:37:31 <geekosaur> marcelocamargo, specifically every other code path in that function invokes nop :: IO ()
13:37:40 <geekosaur> therefore the last case alternative must also produce IO ()
13:37:42 <ReinH> If you're only giving x a name so you can use it as the clause to a case statement, \case can be better
13:37:50 <napping> You might like that because a [Test] can have different types inside each item in the list
13:37:54 <geekosaur> so, test depList >> return ()
13:38:07 <napping> like, [Test (reverse "abc") "cba", Test (1+1) 2]
13:38:08 <marcelocamargo> Yeap, everything is IO () by default. Should I need to "force" a IO [()]?
13:38:19 <geekosaur> all branches must produce the same type
13:38:32 <ReinH> That's what geekosaur's above suggestion does, yes
13:38:37 <marcelocamargo> I'll try it. I come back soon!
13:38:41 <geekosaur> this is exactly the same type error as (if 3 == 4 then 5 else "foo")
13:39:03 <napping> and pattern matching on the constructor lets you use the typeclasses it mentions, even though you didn't know what type "a" was going to be
13:39:08 <ReinH> There are languages where such things are allowable, but Haskell is not one of them.
13:39:34 <napping> like, check :: Test -> Bool; check (Test a b) | x == y = True | otherwise = error (show (a,b))
13:39:53 <geekosaur> the thing is, there are no statements in Haskell, only expressions, and types of expressions must match. this is true even in do, which looks like statements but actually turns into a big expression
13:40:24 <geekosaur> and case is also a big expression so all case alternatives must produce the same type
13:40:43 <S3thc0n> napping: I see! So that's how this would be solved :D
13:41:24 <napping> S3thc0n: Haskell isn't quite polymorphic enough to do it the way you wrote. that "Test" is one way, or just call some function like your "assertEqual" in each item.
13:41:42 <ReinH> (having the type of a statement depend on the value of a boolean condition is exactly what is meant by "dependent types")
13:41:43 <napping> Just give it a shorter name like "~~" or something
13:41:47 <ReinH> s/statement/expression
13:42:00 <bwe> cabal: Encountered missing dependencies:   Measures -any, Stat -any, doctest >=0.8.0 -- What does it try to tell me here?
13:42:14 <S3thc0n> napping: So that extension effectively allows type constraints in data types?
13:42:24 <napping> One thing about existential types like that is that you can only use the type class constraints
13:43:01 <napping> and with Eq and Show all you can do is compare or show
13:43:31 <napping> so you kind of might as well use "test a b = (a==b,show a,show b)" instead of that "Test" constructor
13:43:59 <S3thc0n> napping: Yes, but so much duplication :b
13:44:00 <geekosaur> bwe, you have listed that you need packages (not modules) named Measures and Stat, and a package doctest whose version is at least 0.8.0
13:44:13 <napping> In other words, turning on an extension to write a fancy type doesn't really gain anything in this example over just putting something like your "assertEqual"
13:44:42 <S3thc0n> napping: I don't think I'm allowed to sue that extension in this assignment, but I've made a mental note so I can make a more elegant solution next time.
13:44:45 <napping> If you have fancier stuff like names for your tests, or trees of test suites, or skipping tests by name, then it starts to make sense to give them types
13:44:50 <geekosaur> for the first two, I am guessing you wanted modules, and if those modules are not part of your library/application then you need to list the packages they come from, not the modules themselves
13:45:33 <geekosaur> if they *are* part of your library, you need to list them in exposed-modules or other-modules, not in build-depends
13:45:43 <napping> by the way, you can define operators locally
13:46:20 <napping> like tossing a "where test ?= expected = assertEqual (test,expected)" clause at the end of your definition of assignment6
13:48:16 <S3thc0n> napping: I see what you mean - but why would that being local be advantageous?
13:49:01 <napping> There's no big reason
13:49:08 <bwe> geekosaur: Got that now. cabal: Encountered missing dependencies: doctest >=0.8.0 -- but doctest --version says `doctest version 0.11.0`.
13:49:11 <napping> Just if you don't want to globally define a new operator you could do it locally
13:49:33 <geekosaur> ugh, executable dependencies
13:50:03 <geekosaur> bew, executable dependencies are ... problematic. it can check versions of libraries, and of a limited number of known programs
13:50:14 <geekosaur> er. bwe ^
13:50:14 <slack1256T> ls
13:50:22 <_matix> what would be a good way of building a "subtype" B which extends type A?  Would I just give it a property A?
13:50:36 <_matix> (apologies for bad terminology)
13:50:38 <S3thc0n> napping: So that'd be a  way to be close to == but still throw an error when a test fails.
13:51:23 <glguy> bwe: The build-depends section is about libraries, not executables. So you can still have a doctest executable laying around without having the doctest library installed
13:51:26 <geekosaur> bwe, also, I see doctest has a library --- but you may well have an executable from a different ghc installation, or built in a (different) sandbox
13:51:38 <geekosaur> so the executable is there but the library might well not be available
13:52:23 <_matix> (or if subtyping is an anti-pattern in haskell please direct me better!) 
13:52:43 <geekosaur> or built outside a sandbox, and if you are now building something inside a sandbox then it can't see the one built outside the sandbox because the sandbox replaced that part of the package search path
13:53:41 <lingxiao> geekosaur hey sorry was away for a bit .. ok i'm running the script now and seeing th effects
13:53:44 <geekosaur> _matix, subtypes aren't even an anti-pattern; they're not really possible
13:53:46 <napping> _matix: if you need a type like A but with more information, a new type with a field of type A is pretty reasonable
13:53:55 <bwe> geekosaur: The sandbox is the issue.
13:54:26 <napping> it's not going to do much else that you might expect from the term "subtype", but it should be reasonable
13:54:38 <_matix> geekosaur: I was leaning towards what napping has just mentioned
13:54:53 <_matix> napping: the only issue I see is if you repeat that a few times you get a long chain fairly quickly
13:54:53 <napping> like, you won't be able to pass a B where an A is expected or anything
13:54:55 <dmwit> _matix: If you give a few more details, we may be able to give more targeted advice.
13:55:20 <napping> trying to faithfully simulate a class hierarchy or something (especially a deep one) probably is an antipattern
13:55:20 <dmwit> _matix: As it is, the answer to "how do I subtype in Haskell?" is "you don't".
13:55:32 <_matix> dmwit: heh kk 
13:55:44 <Welkin> lol
13:55:45 <_matix> following some designs in a book i am reading
13:55:47 <napping> but just combining a few levels of records or something works out ok
13:55:48 <dmwit> What program are you trying to write?
13:56:04 <Welkin> _matix: gang of four?
13:56:25 <_matix> for an event system (in LISP) where they have a basic event consisting of only a timestamp and a value; and from there they extend for special events
13:56:26 <geekosaur> books that assume OO types are likely to mislead you; functional programming is fairly different, types behave much differently
13:56:34 <_matix> Welkin: nope not GoF 
13:56:45 <Welkin> lol geekosaur 
13:56:50 <Welkin> it's groundhog day every day in #haskell :D
13:57:10 <Welkin> the eternal struggle against oop
13:58:18 <_matix> so for example, Event would just have a timestamp and a value, whereas WeatherEvent could also have a temperature associated with it.  Now that I'm critically thinking about it, "value" seems useless.  I'm assuming the generic usage is for generic handling of events.
13:58:49 <napping> lisp books might be even harder to follow, especially if they go for extreme extensibility and dynamism
13:58:50 <_matix> So I guess in Haskell it would be that I would need to define a number of different event types, then implement some class for all of those events so that they can be handled by the same processing function?
13:59:27 <jle`> _matix: instead of having different event types, you could also potentially have one type that could represent all sorts of events
13:59:35 <ReinH> sum types!
14:00:01 <Welkin> _matix: not a class, just a function
14:00:15 <monochrom> maybe one event type
14:00:37 <napping> Why do they even want to jam a bunch of different event types through one generic handler?
14:00:40 <Welkin> data Event = MoveLeft | MoveRight | MoveUp | MoveDown
14:00:42 <_matix> jle` monochrom: Okay I will read into the use cases further and see if that's possible
14:00:43 <monochrom> read about "the expression problem" to see your options and what you're giving up
14:00:57 <Welkin> then you have a function :: Event -> Position
14:00:58 <Welkin> or whatever
14:01:15 <ReinH> The expression problem hinges on what sort of extensibility you actually require.
14:01:31 <bwe> MyModule.hs imports Data.List. Should Data.List be anywhere in my MyPackage.cabal at all (might qualify as stupid question)?
14:01:35 <_matix> napping: i'm not sure :P have not read that far through the book.  I will look more and observe requirements instead of  designs
14:01:50 <monochrom> It basically implies that extension in one direction forbids extension in another direction.
14:01:58 <dmwit> bwe: No. However, the package that exposes `Data.List` should be in your `build-depends`.
14:02:25 <dmwit> bwe: (In this case, `base`, which you almost certainly already have in that field.)
14:02:51 <_matix> btw really great community here (at least in this channel).  I have not received any negativity or criticism of lack of knowledge and ALL responses have been constructive. :)
14:03:02 <_matix> monochrom: will check it out
14:03:11 <napping> _matix: there are a few ways to make something like an extensible sum type, but they are usually overkill
14:03:17 <Welkin> _matix: that's the goal here, to learn and teach
14:03:18 <ReinH> _matix: to be fair, you've received criticism. It's just been constructive. :)
14:03:47 <ReinH> Well, *you* haven't. Your ideas have. Which is the goal.
14:03:53 <Welkin> _matix: you may find the way Elm (or Purescript) handles extensible types
14:04:07 <Welkin> just for an exercise
14:04:41 <Welkin> wait, does Elm have that?
14:04:44 <napping> Welkin: how is that? Do they have something like a language manual?
14:04:45 <Welkin> maybe it's just Purescript
14:05:13 <Welkin> well, it's done to mirror the way javascript hash tables work
14:05:16 <Welkin> so it's kind of weird
14:05:22 <bwe> dmwit: base is in build-depends. How can I find out by which package Data.List is exposed (not hackage in my browser, I want to do it here on the command line)? 
14:06:19 <Welkin> _matix: haskell has all kinds of crazy extensions though
14:06:26 <Welkin> many I have never used nor heard of
14:06:43 <Welkin> so you can probably find anything you can imagine as a compiler extension
14:08:10 <geekosaur> not quite, although as plugins catch on that might be literally true at some point
14:08:41 <geekosaur> I know someone's been working on a SAT solver plugin, and type-level naturals solvers
14:09:08 <zv> is his name z3 and he needs you to star his SAT solver plugin so he can appear to be a open-source star and get a job?
14:09:15 <zv> https://github.com/zv/z3-mode
14:09:21 <zv> err, zv
14:10:06 <Welkin> lol
14:10:29 <Welkin> in elisp??
14:10:33 <zv> believe it
14:11:26 <zv> well, it doesn't implement a SAT/SMT solver itself
14:11:42 <zv> it's an inferior process interaction mode, although i've done the sat/smt solver bit too in rust
14:12:12 <zv> nothing fancy like cvc4 or z3 mind you, but it's a seriously interesting domain that I'm blown away more people don't use on a regular basis (SAT/SMT solvers that is)
14:12:24 <Welkin> I don't even know what any of that is
14:13:22 <zv> thats ok, noone really does
14:14:38 <athan> Is there a function like `times :: Int -> (a -> a) -> a -> a`?
14:14:53 <ReinH> :t foldr (.) id . replicate n
14:14:53 <athan> something like iterate but without the list structure?
14:14:55 <lambdabot> error:
14:14:55 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚ÄòExpr‚Äô
14:14:55 <lambdabot>     ‚Ä¢ In the first argument of ‚Äòreplicate‚Äô, namely ‚Äòn‚Äô
14:15:04 <ReinH> :t \n -> foldr (.) id . replicate n
14:15:06 <lambdabot> Int -> (b -> b) -> b -> b
14:15:22 <athan> ahh snap, thanks ReinH
14:15:28 <athan> do you know if it's in base though?
14:15:40 <ReinH> Yes.
14:15:46 <ReinH> In Prelude even, I think.
14:15:47 <Welkin> hola athan 
14:15:58 <athan> como estas Sr. Welkin? :)
14:16:07 <jle`> athan: i use iterate
14:16:31 <ReinH> :t \n -> ala Endo foldMap . replicate n
14:16:34 <lambdabot> Int -> (a -> a) -> a -> a
14:16:35 <ReinH> such monoid wow
14:16:36 <athan> jle`: And then drop to the result or something?
14:16:37 <jle`> \n f x -> interate f x !! n
14:16:45 <jle`> *iterate
14:17:03 <jle`> there is an issue here though that iterate isn't strict so it builds up thunks, which might be a problem for large n
14:17:04 <athan> oh derp hm. Is !! pretty performant?
14:17:12 <athan> yeah that's what I'm seeing :\
14:17:14 <jle`> !! is at its optimal performance here
14:17:34 <jle`> this is the kind of rare situation that !! was built for
14:17:41 <glguy> the combination of iterate and !! isn't particularly fast, you actually build the list and deconstruct it
14:17:44 <athan> that's why I was hoping for one that just composes functions or something similar, I think ReinH's might be the ticket
14:17:45 <jle`> you'll be more hard pressed to find a situation more suited for !! :3
14:17:46 <glguy> along the way you're making a big thunk
14:18:01 <jle`> well, if iterate was strict, it'd be perfect :|
14:18:10 <athan> hah, thanks jle` 
14:18:14 <ReinH> :t \n -> (!! n) . iterate
14:18:15 <jle`> i don't think any list is ever built in any case
14:18:16 <lambdabot> error:
14:18:16 <lambdabot>     ‚Ä¢ Couldn't match type ‚Äòa -> [a]‚Äô with ‚Äò[c]‚Äô
14:18:16 <lambdabot>       Expected type: (a -> a) -> [c]
14:18:30 <ReinH> oh right
14:18:33 <glguy> jle`: it is, not the whole list, but the cons data is all allocated
14:18:43 <glguy> neither iterate nor !! inline
14:18:58 <glguy> and there isn't a rewrite for the combination of the two
14:19:04 <jle`> unfortunate
14:19:13 <jle`> i always write my own 'iterate' anyways when i'm doing this
14:19:19 <jle`> but it'd be kind of neat if it worked out of the box
14:19:33 <napping> glguy: there are fold/build rules
14:19:38 <glguy> ok
14:19:41 <ReinH> I expect the foldr version to fuse though?
14:19:57 <jle`> on the surface this looks like a perfect use case for !!, which is nice since !! has so few legitimate use cases lol
14:20:24 <jle`> but i can see where the abstraction might leak
14:20:28 <jle`> i just want to believe
14:20:29 <Welkin> jle`: for learning it does
14:20:32 <napping> {-# INLINABLE (!!) #-}
14:20:42 <athan> ReinH: That's what I'd expect
14:21:08 <jle`> if you write a strict !! (that evaluates the cells as it goes along) or a strict iterate (that evaluates the results as it goes along), the thunk problems go away
14:21:10 <athan> hmm, but iff `f` is strict in its argument maybe?
14:21:15 <jle`> source -- i tested it one lazy sunday afternoon
14:21:22 <jle`> one or the other is enough
14:21:47 <jle`> by thunk-problems-go-away i mean that it is constant-space
14:22:51 <jle`> > iterate succ 0 !! 1000000
14:22:54 <lambdabot>  *Exception: stack overflow
14:23:23 <jle`> @let iterate' f x = let y = f x in y `seq` (x : iterate' f y)
14:23:26 <lambdabot>  Defined.
14:23:29 <Welkin> > it
14:23:32 <lambdabot>  error:
14:23:32 <lambdabot>      ‚Ä¢ Variable not in scope: it
14:23:32 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
14:23:33 <jle`> > iterate' succ 0 !! 1000000
14:23:36 <lambdabot>  1000000
14:23:41 <jle`> yay
14:24:01 <athan> > let times n f = foldr (.) id (replicate n) in times 1000000 succ 0
14:24:04 <lambdabot>  error:
14:24:04 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò[a0]‚Äô with ‚Äòb1 -> b1‚Äô
14:24:04 <lambdabot>        Expected type: a0 -> b1 -> b1
14:24:04 <Welkin> > let it = 0 in iterate succ it
14:24:07 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:24:44 <athan> > let times n f = foldr (.) id (replicate n f) in times 1000000 succ 0
14:24:46 <jle`> @let (x:xs) !!! n | n == 0 = x | otherwise = x `seq` (xs !!! (n - 1))
14:24:47 <lambdabot>  *Exception: stack overflow
14:24:49 <lambdabot>  Defined.
14:24:50 <athan> :(
14:24:59 <jle`> > iterate succ 0 !!! 1000000
14:25:04 <lambdabot>  1000000
14:25:12 <athan> o_o
14:25:20 <jle`> you can use iterate' or !!!, one or the other, and it becomes constant space
14:25:43 <athan> thank you jle`
14:26:11 <jle`> if you use both then it becomes O(1/n)
14:26:28 <jle`> (disclaimer: it doesn't)
14:27:14 <jle`> that'd be cool though
14:27:45 <Welkin> I'm curious how many of you have shunned trasnformer stacks in favor of freer
14:29:23 <athan> Welkin: Freer? I really want to dig into edwardk's monad morphism stuff, but he hasn't released the code yet :\
14:29:52 <Welkin> http://hackage.haskell.org/package/freer
14:29:58 <jle`> it's like Free but more
14:31:27 <Welkin> I've only taken a look at Purescripts extensible effects system
14:31:35 <Welkin> this seems very similar
14:32:27 <dfeuer> carter, which variation on that PR do you want? 
14:32:29 <jle`>  -XTypeApplications is neat, it lets me pretend that the Proxy data constructor has an argument
14:32:37 <jle`>  Proxy @Int
14:32:46 <jle`> life is good
14:32:52 <dfeuer> I don't trust -XTypeApplications yet.
14:33:08 <dfeuer> Especially what it means for API design.
14:33:12 <jle`> is it because of the unpredictability of the order of appilcations
14:33:20 <jle`> or that a change in forall variable ordering is a breaking API change
14:33:27 <dfeuer> And I saw an SO question a day or two ago about the fact that SPECIALIZE doesn't support it.
14:33:32 <jle`> or that the error messages are unreadable
14:33:35 <dfeuer> And I doubt RULES do either.
14:33:41 <jle`> oh, interesting
14:33:44 <athan> isn't it just like scoped type variables?
14:33:47 <athan> in virtue anyway?
14:33:50 <dfeuer> The fact that a change in forall variable ordering is a breaking API change is huge.
14:34:01 <monochrom> I wonder if it is "pretend it has an argument" or "it has always had an argument, but I couldn't write it last year"
14:34:04 <dfeuer> athan, no, I don't think so.
14:34:41 <jle`> i only use it for things like (Proxy @n) for this reason
14:34:45 <jle`> er, those reasons
14:34:46 <dfeuer> *nod*
14:35:08 <jle`> and in ghci to give me nicer types
14:35:12 <jle`> :t fmap @[]
14:35:13 <lambdabot> error:
14:35:14 <lambdabot>     Pattern syntax in expression context: fmap@[]
14:35:14 <lambdabot>     Did you mean to enable TypeApplications?
14:35:15 <jle`> aw
14:35:29 <monochrom> hehe
14:35:40 <dfeuer> I'm not saying I'd never use it.
14:35:45 <jle`> but the error messages being very opaque made me stop using it for anything more complicated quickly
14:35:49 <dfeuer> I'm just not convinced yet.
14:35:52 <jle`> the message is literally "You cannot do that."
14:36:01 <jle`> with no description about why >_>
14:36:20 <Welkin> jle`: segfault
14:36:40 <dfeuer> It's not like ScopedTypeVariables, which I'm extremely convinced of, or FlexibleContexts, which I'm quite convinced of, or OverlappingInstances, which I'm quite certain is horrible.
14:36:53 <jle`> that's fair
14:37:29 <athan> So... I've got an IntMap with 10,000 elements in it, which are vectors 10,000 elements long, holding 32bit floats. I'm trying to :force it, but my computer just keeps breaking. Any ideas what I should actually do?
14:37:39 <dfeuer> (OverlappingInstances is horrible, rather than merely bad, because it's terribly intrusive. It breaks all sorts of assumptions that I and GHC would *both* like to be able to make.)
14:37:40 <jle`> just tried using guard syntax with lambas and it didn't work
14:37:42 <jle`> slightly sad
14:37:55 <jle`> but not super sad
14:38:01 <athan> using jle`'s iterate' and !!! is actually keeping my OS from breaking though :)
14:38:08 * dfeuer has to go finish cleaning up.
14:38:25 <athan> jle` doesn't that work with lambdacase?
14:38:44 <jle`> i just realized that my work flow is to hit compile and then immediately switch over to IRC and waste time even though the things compile very quickly
14:38:52 * jle` is bad at being productive
14:40:15 <athan> yeah this thing is just going to force forever :\
14:41:01 <jle`> i wonder if it's an intmap thing
14:41:06 <jle`> does it force fine as a list?
14:41:49 <Welkin> yeah
14:41:54 <Welkin> irc is a huge time waster
14:42:11 <Welkin> maybe you should make an appliation that stops you from wasting time on irc
14:42:18 <jle`> i just spend a minute coding until i have to recompile to check for type errors and then jump on irc for ten minutes
14:42:23 <monochrom> athan: which vector? Data.Vector.Unboxed? Data.Vector.Storable? Data.Vector? ...
14:42:34 <athan> monochrom: Unboxed
14:42:49 <athan> jle`: hmm, good question, I'll just try lists
14:43:27 <jle`> traversing every item in a list should have smaller constant factors than traversing every item in an intmap, i'd think
14:43:43 <jle`> or it's at least simpler
14:44:18 <jle`> your computer might be freezing in generating the BST that IntMap wraps
14:46:01 <jle`> cons is O(1) but intmap insert is O(ln n) i believe
14:46:18 <Welkin> ln n or log n?
14:46:48 <athan> Yeah it allocated a terabyte of vram, htop says haha
14:47:14 <glguy> Allocating a terabyte of virtual space is normal
14:47:16 <jle`> Welkin: log n and ln n are the same
14:47:20 <Welkin> o.o
14:47:22 <jle`> they're just a constnat factor apart
14:47:25 <athan> lowly athan only has 8 gigs D:
14:47:37 <jle`> log n = some constant number * ln n
14:47:46 <glguy> It's not allocating a terabyte of actual ram, just virtual address space
14:47:52 <Welkin> log is base 2 here
14:47:55 <Welkin> ln is base e
14:47:59 <jle`> same deal :)
14:48:09 <Welkin> okay
14:48:13 <Welkin> just never saw that before
14:48:24 <jle`> > logBase 2 100 / log 100
14:48:27 <lambdabot>  1.4426950408889634
14:48:38 <dmwit> bwe: ghc-pkg find-module Data.List
14:48:42 <jle`> > logBase 2 5923 / log 5923
14:48:44 <lambdabot>  1.4426950408889636
14:48:45 <Welkin> what
14:49:06 <jle`> > logBase 2 0.83 / log 0.83    -- etc.
14:49:09 <lambdabot>  1.4426950408889634
14:49:23 <bwe> dmwit: thx
14:49:48 <Welkin> > log 100
14:49:50 <lambdabot>  4.605170185988092
14:49:52 <dmwit> bwe: This assumes that GHC knows about that module, of course.
14:50:29 <Welkin> > log 2.718281828459
14:50:32 <lambdabot>  0.9999999999999832
14:50:42 <dmwit> bwe: Usually, though, you know which package exposes the modules you're using, because you're currently staring at their haddocks. =P
14:50:52 <jle`> Welkin: logarithms at any base only differ by a constant factor
14:50:56 <glguy> Welkin: This might be interesting to you: logBase x y =  log y / log x
14:50:56 <athan> Why isn't Double / Float bounded?
14:50:58 <dmwit> bwe: (Or because you have used them so many times you don't need to stare at their haddocks.)
14:51:47 <monochrom> athan: what would be the bounds?
14:52:27 <athan> monochrom: toFloat (maxBound :: Word32) or something, wouldn't it?
14:52:38 <dmwit> Well, that's not the answer I was expecting.
14:52:46 <glguy> yeah, didn't see that coming
14:53:09 <jle`> athan: what about toFloat (maxBound :: Word32) + 1 ?
14:53:18 <dmwit> athan: I don't think `toFloat` respects `compare` in the way you're probably hoping it does.
14:53:35 <dmwit> :t toFloat
14:53:37 <lambdabot> error: Variable not in scope: toFloat
14:53:38 <napping> jle`: that's going to be toFloat (maxBound :: Word32)
14:53:38 <monochrom> I have doubt about bounds for Word32 being related to 32-bit floating point representation at all
14:53:54 <glguy> jle`: That'd be a programmer error for exceeding athan's bound
14:53:55 <napping> but +Inf and -Inf are the only numbers that might make sense as maxBound and minBound
14:54:00 <dmwit> Without even knowing what `toFloat` does. =P
14:54:49 <napping> There are also tons of non-infinite floating point values above toFloat (maxBound :: Word32)
14:54:50 <dmwit> athan: Anyway, keep in mind that things with Float and Double are rarely simple. There's all kinds of fun and odd things in there, including NaN which compares in odd ways to non-NaNs.
14:55:00 <jle`> > fromIntegral (maxBound :: Word32) :: Double
14:55:02 <lambdabot>  4.294967295e9
14:55:12 <jle`> > fromIntegral (maxBound :: Word32) * 2 :: Double
14:55:12 <dmwit> athan: It's not clear to me that a Bounded instance for Double or Float would actually be useful.
14:55:12 <Welkin> napping: we have Ratio too
14:55:14 <lambdabot>  8.58993459e9
14:55:21 <glguy> We could just assert that the maximum Double was 155 and insist that everyone stay within the bounds
14:55:28 <vapid> > undefined
14:55:31 <lambdabot>  *Exception: Prelude.undefined
14:55:44 <monochrom> But I'm 156 years old, you need to accomodate for you.
14:55:44 <vapid> > import Network
14:55:47 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äòimport‚Äô
14:55:51 <monochrom> err, s/for you/for me/
14:56:00 <Welkin> > 1/0 % 2
14:56:02 <lambdabot>  error:
14:56:03 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M745234717250...
14:56:03 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
14:56:07 <athan> jle` yeah, that doesn't respect the actual largest Float / Double though :\
14:56:22 <vapid> 1/0 :: Integer
14:56:23 <athan> dmwit: Eh, not useful maybe, I'm not sure
14:56:24 <Welkin> > 1/0 % 2 :: Ratio
14:56:26 <lambdabot>  error:
14:56:26 <lambdabot>      ‚Ä¢ Expecting one more argument to ‚ÄòRatio‚Äô
14:56:26 <lambdabot>        Expected a type, but ‚ÄòRatio‚Äô has kind ‚Äò* -> *‚Äô
14:56:37 <vapid> > 1/0 :: Integer
14:56:38 <Welkin> > 1/0 % 2 :: Ratio Integer
14:56:39 <athan> I feel like `(maxBound :: Double) + 1` should wrap around, like Int
14:56:40 <lambdabot>  error:
14:56:40 <lambdabot>      ‚Ä¢ No instance for (Fractional Integer) arising from a use of ‚Äò/‚Äô
14:56:40 <lambdabot>      ‚Ä¢ In the expression: 1 / 0 :: Integer
14:56:41 <lambdabot>  error:
14:56:41 <lambdabot>      ‚Ä¢ No instance for (Fractional Integer) arising from a use of ‚Äò/‚Äô
14:56:41 <Welkin> lol
14:56:42 <lambdabot>      ‚Ä¢ In the first argument of ‚Äò(%)‚Äô, namely ‚Äò1 / 0‚Äô
14:56:46 <Welkin> wow lambdabot 
14:56:53 <dmwit> athan: There is `1/0` and `-1/0` if you need +/-Inf at type Double or Float.
14:57:07 <athan> hmm okay
14:57:12 <jle`> @let pattern Inf = 1/0
14:57:13 <lambdabot>  .L.hs:195:9: error:
14:57:13 <lambdabot>      Not in scope: data constructor ‚ÄòInf‚Äô
14:57:13 <lambdabot>      Perhaps you meant one of these:
14:57:19 <vapid> > (1 :: Float) / 0
14:57:22 <lambdabot>  Infinity
14:57:38 <dmwit> > (0/0) > (1 :: Float)/0
14:57:41 <lambdabot>  False
14:57:45 <dmwit> > (0/0) < (1 :: Float)/0
14:57:48 <lambdabot>  False
14:57:51 <dmwit> yaaaay
14:58:01 <Welkin> all Infinity's are not the same
14:58:02 <vapid> > (0 :: Float)/0
14:58:03 <jle`> good thing it matches the spec
14:58:04 <lambdabot>  NaN
14:58:16 <Welkin> haha
14:58:21 <Welkin> reminds me of javascript
14:58:24 <jle`> Welkin: 0/0 isn't an Infinity in ieee spec
14:58:24 <dmwit> 0/0 is not less than or greater than 1/0, therefore 0/0 is equal to 1/0.
14:58:27 <Welkin> where NaN has type "number"
14:58:38 <dmwit> Welkin: That is because Javascript's "number" type is semantically a Double.
14:58:43 <vapid> > :t NaN
14:58:45 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
14:58:55 <vapid> howdoidothis
14:58:57 <jle`> NaN is not a constructor 'unfortunately'
14:59:01 <dmwit> :t (0 :: Float)/0
14:59:03 <lambdabot> Float
14:59:16 <dmwit> :t read "NaN" :: Float
14:59:22 <jle`> but if i could make a prank change to base, i'd add it as a pattern synonym
14:59:23 <lambdabot> Float
14:59:32 <jle`> :t read "hello" :: Float
14:59:38 <lambdabot> Float
14:59:38 <dmwit> yes =)
14:59:46 <dmwit> But mine actually works. ;-)
14:59:51 <jle`> :p
15:00:02 <jle`> NaN is semantically different than bottom tho
15:00:15 <dmwit> So is `read "NaN" :: Float`.
15:00:25 <dmwit> Try it and see.
15:00:44 <jle`> > read "NaN" :: Float
15:00:47 <lambdabot>  NaN
15:00:48 <jle`> :o
15:00:56 <Welkin> :t NaN
15:00:58 <lambdabot> error: Data constructor not in scope: NaN
15:01:03 <jle`> NaN is not a constructor
15:01:08 <Welkin> :t read "NaN" :: Integer
15:01:10 <lambdabot> Integer
15:01:15 <Welkin> :t read "NaN" :: String
15:01:18 <lambdabot> String
15:01:22 <vapid> > let a = 5 in a
15:01:25 <lambdabot>  5
15:01:34 <vapid> > let a = a in a
15:01:40 <lambdabot>  mueval-core: Time limit exceeded
15:01:41 <Welkin> > a
15:01:42 <glguy> Yup, lambdabot still works
15:01:42 <jle`> Welkin: read "NaN" :: Integer is bottom
15:01:43 <lambdabot>  a
15:01:53 <jle`> vapid: you can also play with lambdabot in private message :)
15:02:29 <monochrom> "a = a" is a recursive definition that doesn't work out
15:03:50 <dmwit> > let –∞ = a in –∞
15:03:52 <lambdabot>  a
15:03:58 <monochrom> neato
15:04:35 <vapid> magic
15:05:06 <glguy> unicode hax
15:05:09 <glguy> HAX!
15:05:15 <dmwit> lambdabot runs infinite loops in mere seconds
15:05:57 <jle`> lambdabot has a built in general termination checker
15:06:13 <monochrom> I should have used that in my slides on unicode when it comes to "character vs glyph"
15:08:29 <ant123> I have parsec == 3
15:10:41 <vapid> > let x = if x /= 3 then 1 else 2
15:10:44 <lambdabot>  <no location info>: error:
15:10:44 <lambdabot>      not an expression: ‚Äòlet x = if x /= 3 then 1 else 2‚Äô
15:11:07 <vapid> > let x = if True then 1 else 2
15:11:10 <lambdabot>  <no location info>: error:
15:11:10 <lambdabot>      not an expression: ‚Äòlet x = if True then 1 else 2‚Äô
15:11:32 <ant123> I have two different versions of parsec installed. I wrote parsec == 3.1.11 in my building-depends, but cabal still cannot decide what version to choose. Can anyone help me please? 
15:11:35 <bwe> How do I get test coverage information? (doctest here) 
15:12:50 <athan> Anyone here use repa a lot?
15:12:55 <athan> er, sometimes? :)
15:14:11 <vapid> > take 1 [1..3]
15:14:14 <lambdabot>  [1]
15:14:28 <vapid> take 5 $ repeat 3
15:14:31 <geekosaur> vapid, in expression context you need let <bindings> in <expression>
15:14:45 <ReinH> vapid: please experiment via /query lambdabot
15:14:52 <vapid> right
15:15:01 <vapid> k
15:15:51 <geekosaur> ant123, can you lpaste the output from (a) your build attempt, with -v3 (b) the output from `cabal sandbox hc-pkg list` (if you are using a sandbox) and `ghc-pkg list`
15:15:53 <geekosaur> @paste
15:15:54 <lambdabot> Haskell pastebin: http://lpaste.net/
15:16:04 <geekosaur> ^ pastebot. plase do not paste into IRC
15:19:16 <geekosaur> ant123, also if you are not using a sandbox, consider doing so. (cabal sandbox init)
15:19:32 <geekosaur> ...
15:22:56 * hackagebot rosmsg 0.4.3.1 - ROS message parser, render, TH  https://hackage.haskell.org/package/rosmsg-0.4.3.1 (akru)
15:22:58 * hackagebot rosmsg 0.4.3.2 - ROS message parser, render, TH  https://hackage.haskell.org/package/rosmsg-0.4.3.2 (akru)
15:31:46 <athan> dangit, so I can merge 10,000 vectors of floats with +^ (repa), but not 100,000 :\
15:31:51 <athan> makes my comp bork
15:32:24 <athan> it's a list 10,000 long of vectors with length 10,000 - a fudged square matrix
15:32:55 <c_wraith> why aren't you using an actual square matrix? 
15:33:05 <c_wraith> that's what repa was built for. 
15:33:58 <athan> c_wraith: That's a good question, I'm not sure
15:34:14 <athan> I'm using an intmap of vectors as the main datatype so I can store it in acid-state
15:34:31 <athan> maybe I should convert it to a square matrix and flatten it with +^ somehow?
15:39:21 <athan> c_wraith: Would you use `foldP` to squash them?
15:39:31 <athan> foldP (+^)
15:39:50 <athan> er shoot foldS haha, I doubt my computer would be happy :|
15:39:56 <_matix> I have a function    func :: A -> B -> A    where I would like B to implement a custom typeclass TP.. how can I do this?
15:40:56 <_matix> Derp nvm
15:45:03 <bvaldivielso> _matrix I believe you can do it like this func :: (TP B) => A -> B -> A
15:45:10 <bvaldivielso> _matix *
15:45:44 <_matix> bvaldivielso: thanks! 
15:45:53 <bvaldivielso> well, it would probably be func :: (TP b) => A -> b -> A
15:46:16 <bvaldivielso> because b is a type variable
15:47:24 <lingxiao> hey all
15:47:33 <lingxiao> are there any hedge funds using haskell that you know of?
15:47:51 <lingxiao> like not stuff w/i blackrock, morgan stanly, or standard chartered
15:50:31 <geekosaur> I think you will not find many of them talking about it
15:50:49 <lingxiao> yeah it's true .. i figured this channel mght have the dl
15:58:01 <athan> sumP has nearly the same behavior :\
15:58:12 <athan> eats up all my ram and can't do anything
16:01:07 <dmwit> bwe: The only coverage tool I know is hpc. Not sure how it integrates with the various testing tools.
16:01:25 <bwe> dmwit: Merci.
16:02:40 <greymalkin> *fistpump* I had never noticed this snippet from the haskell/nix page: 
16:02:40 <greymalkin> Once that‚Äôs done, you can run cabal build and any other command for that project even outside of the nix-shell environment. 
16:03:26 <greymalkin> That really brings together why nix has been so highly adopted by the haskell community; for me anyway.
16:06:57 <lingxiao> geekosaur btw the script main.sh </dev/null   finished running
16:07:17 <lingxiao> I got a log file with the same error message, but I did get the output written to output directory as desired
16:07:25 <lingxiao> so it worked ... error nonwithstanding
16:09:18 <geekosaur> hm, so it does have the stty message? then I have to wonder where it is coming from, as it's not obvious in the repo
16:09:55 <athan> Man I feel like a dits, I shouldn't expect a square matrix of 100,000^2 with 32 bits each to force on a machine with 8 gigs of ram
16:10:01 <athan> isn't that 320 gigs?
16:10:10 <lingxiao> yup here is the message: stty: standard input: Inappropriate ioctl for device
16:10:22 <lingxiao> but wrote result to disk as desired
16:10:46 <glguy> athan Looks like ~37GB
16:11:37 <ReinH> Run everything with set -x?
16:12:10 <athan> er, yeah you're right glguy :s
16:13:31 <lingxiao> ReinH sorry are you talking to me
16:13:32 <lingxiao> ?
16:14:27 * geekosaur clones to do a better search, just in case he missed something
16:14:48 <geekosaur> nope, just in logs. has to be some shell config file somewhere
16:15:36 <ReinH> lingxiao: yes
16:15:53 <lingxiao> ReinH sorry where do i do "set -x"
16:16:02 <lingxiao> I'm submitting my main.sh file to some queue
16:16:11 <ReinH> sex -x will print every command executed by the script.
16:16:17 <ReinH> Set*
16:16:37 <ReinH> might help localize the error
16:17:28 <lingxiao> freudian slip 
16:17:39 <lingxiao> so do i put Set -x in my .sh file?
16:18:03 <athan> do you mean `:set -x` in ghci?
16:18:14 <geekosaur> no
16:18:16 <geekosaur> this is a shell option
16:18:34 <lingxiao> so I just have to put       set -x        in my shell script
16:18:35 <geekosaur> you'd put `set -x` at the top of main.sh right after the #! line
16:19:12 <geekosaur> (-x turns on trace mode, ever command run gets printed out and at least some versions of bash and zsh can include file and line number)
16:19:17 <geekosaur> *every command
16:19:19 <lingxiao> like this: http://lpaste.net/187766
16:19:20 <lingxiao> ?
16:19:52 <geekosaur> yes
16:20:05 <lingxiao> ok let me run that and get back to you 
16:21:55 <lingxiao> geekosaur actually i did something very interesting and my program worked
16:22:06 <lingxiao> as i i submitted it to the schedular and it worked
16:22:12 <geekosaur> well, it was always working. that warning is just noise, really
16:22:30 <lingxiao> no like it worked on remote, by simply submitting to schedular
16:22:40 <lingxiao> my program opens a bunch of .txt files and process them
16:22:54 <lingxiao> i took one of the txt files and copied and pasted its content intoa  new txt file, and saved it
16:22:57 * hackagebot rospkg 0.2.2.0 - ROS package system information  https://hackage.haskell.org/package/rospkg-0.2.2.0 (akru)
16:22:59 * hackagebot rospkg 0.2.2.1 - ROS package system information  https://hackage.haskell.org/package/rospkg-0.2.2.1 (akru)
16:23:02 <lingxiao> then i ran it on this file .. and it worked with the schedular
16:23:14 <lingxiao> could it be possible that theres some restrictions on the txt files?
16:24:02 <lingxiao> i scp them from some remote server .. and scped them to this server im using now, and then unzipped them there
16:24:10 <tmobile> Is anyone aware of a way to force stack not to use any precompiled packages for a build? My use case is using stack with nix-shell; my user's package database has packages built against libs in /usr.
16:24:19 <tmobile> And I'd like to avoid going back to cabal.
16:28:59 <Cale> tmobile: Any particular reason cabal wouldn't work fine there?
16:29:23 <tmobile> It would probably be fine. It would be nice to use the same tool for local development and deployment.
16:29:49 <Cale> Fair enough :)
16:30:04 <tmobile> But if there's no way to force stack to ignore (or rebuild) its precompiled packages then Cabal it is.
16:32:25 <johnw> I find nix-shell + cabal sandbox to be quite pleasant
16:38:45 <dfeuer> Ping wrengr 
16:46:07 <wrengr> dfeuer: pong
16:46:09 <tmobile> Seems like the easiest way to achieve this is setting the STACK_ROOT environment variable.
16:46:23 <dfeuer> wrengr, going to PM.
16:46:59 <greymalkin> I'm trying to translate a datastructure to an XML string (purely)... using HXT feels like a sledgehammer for this task, am I missing something?
16:47:31 <greymalkin> it's got runX runLA runSLA runSt .... but no 'run'
16:48:19 <greymalkin> I see no good reason to require IO just for XML output, but hxt seems to be the XML manipulator of choice.
16:49:48 <tmobile> greymalkin: Have you looked at xml-conduit?
16:50:02 <tmobile> My principal issue with HXT is that is uses Strings everywhere.
16:51:25 <monochrom> isn't runLA pure?
16:53:23 <greymalkin> monochrom: I have no idea -- I really don't want to throw *another* monad into the mix, even if it is pure.
16:53:52 <greymalkin> tmobile: I'll take a harder look at xml-conduit.  conduits fit well for this application anyway, though the output has to be de-conduitized for the consuming program.
16:54:48 <monochrom> Your code is your choice. But I want to clarify to the audience that runLA does not throw "another" "monad" into the mix, for the record.
16:56:41 <monochrom> HXT starts with X->[Y] as the most basic arrow, and rightfully so: if you ask so much for "the children of this node" you will get a list. IIRC runLA is about no more than X->[Y]
16:57:40 <greymalkin> monochrom: Ah, thank you for the clarification and I apologize.  I was only beginning to play with arrows as a result of hxt; it had otherwise not been something that I had had reason to investigate.
16:57:57 <monochrom> HXT then also provides more variations to add state or IO or both, but you don't have to use them.
17:01:30 <greymalkin> monochrom: So, am I correct in saying that `String` is only really useful because its functions are so thoroughly well described with Prelude?
17:02:46 <monochrom> I am not the right person to ask.
17:32:26 <kurt11> \exit
17:32:27 <kurt11> \q
17:46:11 <benzrf> yo NickHu
17:46:19 <benzrf> u should try out reflex-dom now c:
18:05:32 <lingxiao> geekosaur i think here's the bug
18:05:47 <lingxiao> when the .txt file is too large submitting into the queue fails ..
18:05:57 <lingxiao> but if the txt file is "sufficiently" small then it does owrk
18:08:03 <koz_> How would I create (for example) a list of 'things which are instances of Integral, but we don't know anything more'?
18:08:44 <ertes> koz_: how much of Integral do you need?
18:09:40 <koz_> ertes: + and Ord stuff.
18:10:04 <ertes> koz_: then you may want to just use a list of functions or pairs of functions
18:10:31 <koz_> ertes: I... don't quite understand.
18:10:42 <glguy> if you don't know that all of the elements of the list are the same type, Ord won't be super useful
18:10:48 <glguy> or do you?
18:13:10 <koz_> glguy: I don't know - I know I want them to all be integers (in the mathematical sense), but [Integer] could end up being really inefficient for my purposes, if I end up having something like [-1, 1, -1, 1, -1, 1, - hugeNumberHere]. Especially if these 'runs' of -1, 1 appear throughout. 
18:17:50 <ertes> koz_: note that Integer has a special case for machine-sized integers
18:17:57 <ertes> koz_: it may not be as inefficient as you think
18:18:27 <ertes> any representation that is type-agnostic is likely going to be worse
18:18:27 <koz_> ertes: Really? I didn't know that.
18:18:35 <geekosaur> @src Integer
18:18:35 <lambdabot> data Integer = S# Int#
18:18:35 <lambdabot>              | J# Int# ByteArray#
18:18:56 <koz_> geekosaur: That's pretty cool - I had no idea.
18:18:59 <geekosaur> as long as it fits in a machine word, it'l l use one
18:19:03 <benzrf> koz_: well, it does add a (probably constant-time) slowdown since it has to check whether it's the machine type or if it's the extended form
18:19:08 <ertes> koz_: however, if you *know* that all members will be small, you could use [Int] instead and eliminate even that indirection
18:19:22 * jonored would be surprised at any bigint that /didn't/ have an "Oh, I happen to be small, so I'll keep the cost to a small branch on that fact"
18:19:34 <koz_> ertes and geekosaur: OK, thanks - that changes things. I will think on it some more.
18:19:34 <ertes> performance-wise you can think of small Integer values as about as fast as something like Maybe Int
18:20:15 <koz_> ertes: OK, thanks.
18:20:28 <koz_> As a complete aside - is there some kind of community list of 'libraries/frameworks/other things that are good' for Haskell?
18:21:08 <ertes> koz_: asking on #haskell about specific topics is usually the best choice
18:21:08 <benzrf> koz_: are you *trying* to start an argument?
18:21:11 <benzrf> ;)
18:22:15 <koz_> benzrf: Not really. It's just that Hackage is enormous, and it's sometimes hard for a newbie like me to judge how good something is.
18:22:29 <koz_> But yeah, I can see how this could be argument-bait.
18:23:14 <ertes> koz_: even if not, just ask #haskell
18:23:21 <sm> it's a very reasonable question. There are several such lists, one of the best so far is on http://haskell-lang.org
18:24:32 <sm> http://haskelliseasy.readthedocs.io/en/latest/ is another
18:25:00 <koz_> sm: Do you mean this? https://haskell-lang.org/libraries
18:25:07 <sm> yup
18:25:19 <sm> and here is a third: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
18:26:06 <koz_> sm: Thank you - this is *exactly* what I sought.
18:26:59 <sm> sorry, there are too many good docs to stop: http://dev.stephendiehl.com/hask/
18:28:53 <sm> haskell.org and haskell-lang.org docs pages link to 1 and 2 of these respectively (alas)
18:33:26 <bwe> So I realise there is tasty, hspec and doctest. The problem is all three might be good. So, how should I pick? 
18:34:12 <ertes> bwe: pick between tasty and hspec by your personal taste (i.e. try both)
18:34:33 <ertes> bwe: doctest is orthogonal ‚Äì it solves a specific problem‚Ä¶  if you have that problem, use it
18:37:55 * glguy adds split screen view to glirc http://imgur.com/a/7BU8L
18:43:59 <koz_> Suppose I have a library. I wanna provide some tests for it, but those tests rely on parts of the library I don't really want to expose to the outside world. What's the best way to structure my library in this case?
18:44:52 <ertes> koz_: add the library source directory to hs-source-dirs
18:44:53 <glguy> koz_: Expose the modules but make it clear they are internal details, e.g. data.ByteString.Internal
18:45:13 <ertes> koz_: but yeah, glguy's suggestion is better
18:45:30 <glguy> If you add the library's hs-source-dirs to the test-suite yoiu also need to not depend on the library itself
18:45:49 <koz_> glguy: That's pretty neat - I'll have to remember that.
18:53:31 <sm> koz_: I would start with doctests, they run in the context of the file they are in
18:54:10 <sm> glguy: nifty
18:54:12 <tsani> I have a type family Foo whose result is Symbol (written out as literals); how can I recover KnownSymbol (Foo x) for some x in the domain of Foo ?
18:55:32 <glguy> tsani: You'll have a constraint KnownSymbol (Foo x) where you need one
18:56:03 <tsani> glguy: oh
18:56:07 <tsani> that's surprisingly simple
18:56:08 <tsani> thanks
19:26:59 <_matix> is it possible to have a function as part of a datatype?
19:27:43 <glguy> _matix: No
19:27:55 <_matix> glguy: thanks
19:28:06 <glguy> Unless I'm misunderstanding what you're asking
19:28:35 <systemfault> Let's reinvent object-oriented programming :)
19:28:52 <glguy> _matix: You can have fields of your data type that have function types
19:29:19 <glguy> data T = D (Int -> Int) String
19:29:50 <_matix> glguy: something along the lines of this http://lpaste.net/187861
19:30:10 <ongy> that should work as is
19:30:16 <glguy> _matix: Oh, that's fine.
19:30:43 <_matix> ongy glguy how about this http://lpaste.net/187861
19:31:33 <_matix> I'm getting "Illegal polymorphic or qualified type: forall a. Eq a => a -> Bool"
19:31:53 <glguy> _matix: You can do that using an extension, at least. ExistentialQuantification
19:32:03 <glguy> aFunc :: forall a. Eq a => a -> Bool
19:32:36 <glguy> Or you can just parameterize your type: data SomeType a = SomeType { aFunc :: a -> Bool }
19:34:11 <_matix> hm i'm totally confused now. 
19:34:28 <_matix> glguy: I understand how parameterizing the type would work
19:34:54 <_matix> glguy: is Existential quantification a feature that I would need to invoke?  by prepending the definition with forall a . 
19:35:24 <exio4> think of the meaning of that a inside SomeType
19:36:21 <_matix> exio4: right I understand why it's not working now.. so is "existential quantification" enabling it for every single data type i have in my program?  does that .. make sense even?
19:37:17 <geekosaur> _matix, ExistentialQualification ebales use of the `forall x y z .` syntax
19:37:21 <geekosaur> *enables
19:37:46 <geekosaur> note that this usually means you cannot retrieve the type again, so you can't do nearly as much with it as you might think
19:38:33 <_matix> geekosaur: maybe i'll avoid it for now.  
19:38:52 <_matix> geekosaur: i think i just need to take a step back from the problem and re-think it.  thanks again everyone
19:40:59 <MarLinn> Has anyone here played around with hell (the Haskell shell, not the fiery one) in the past?
19:41:58 <ashishnegi> hi.. i have `data A = B Int | C Int | D Int` i.e. all constructors start with `Int` which is id.. in doing `case a of B b -> .. C c -> .. D d ..`  Can i write it in better way when i only need the Int i.e. Id ??
19:42:32 <glguy> ashishnegi: You could have: data Tag = A | B | C | D; data TaggedInt = TaggedInt Tag Int
19:43:59 <ashishnegi> glguy:  uh.. putting it out.. that makes sense.. thanks.. i thought there would be a extention for this.. :) thanks again
19:44:03 <arulmani> hi
19:44:35 <arulmani> can i use haskell as a multipurpose programming language?
19:45:13 <glguy> permission granted
19:45:18 <arulmani> or is it specific to certain areas only?
19:45:28 <ongy> you can use it for pretty much anything
19:45:32 <ongy> but it may be a bad idea for some
19:46:44 <arulmani> why so? is it ok for beginners?
19:46:55 <systemfault> I wouldn't use it to write an OS kernel or device drivers.
19:47:17 <systemfault> Of course, it's okay for beginners.
19:47:26 <MarLinn> I would - if I could :(
19:47:33 <ongy> how would people start with it, if it wasn't?
19:48:06 <_matix> trull 
19:49:14 <MarLinn> arulmani: Do you have some specific purposes in mind?
19:49:50 <ongy> MarLinn: https://wiki.haskell.org/Kernel_Modules ? Not that it works with modern ghc (and not sure about modern kernels)
19:49:53 <arulmani> i would like to program in creating applications,,,,
19:50:30 <amalloy> sounds like a good thing to do with a programming language
19:52:36 <arulmani> what is the speciality of haskell among 1000s of programming languages? coz you guys are using it now and helping others in this channel.... 
19:54:25 <solrize> the thing that makes it most special is that it's better than all the rest
19:54:44 <eizua> now that's an endorsement :D
19:54:46 <MarLinn> ongy: thanks for the link. I've looked a bit into things like House in the past, but I think my knowledge gaps on the kernel side of things are way to large for anything meaningful right now
19:55:14 <ongy> MarLinn: last time I looked into it, there was no way to do it with modern compilers
19:55:27 <ongy> which was the main reason I didn't rally try it
19:55:50 <arulmani> : )
19:56:23 <arulmani> any good ebook that i can download to learn haskell?
19:56:48 <MarLinn> ongy: Good thing I have experiments with compiler technology on my radar then, I guess... XD
19:59:54 <MarLinn> @where lyah -- <- v- arulmani
19:59:55 <lambdabot> http://www.learnyouahaskell.com/
20:00:34 <arulmani> thanks guys.... i'll start learning it
20:01:04 <MarLinn> \o/ another recruit!
20:01:51 <Hafydd> "-- <- v-" is one of the worst things I've seen written with punctuation.
20:02:14 <_matix> can I store a monad in a data type?
20:02:37 <ReinH> What do you mean by "a monad"?
20:03:40 <_matix> ReinH: that's a great question i'm actually not entirely sure.  i want to store an arbitrary procedure in a datatype for use later.  now that i'm typing this, i'm realizing that it is certainly not how i want to code in haskell lol
20:03:57 <eizua> Is LYAH still recommended? I've read somewhere that there are better resources out there, but I haven't found any (I'm still learning Haskell myself)
20:04:03 <ReinH> :t Just (print "test")
20:04:04 <lambdabot> Maybe (IO ())
20:04:28 <shachaf> I liked Hutton's book, Programming in Haskell.
20:04:35 <shachaf> A new edition just came out.
20:05:12 <shachaf> I haven't read it, but the old edition was good and also somewhat out of date, so it seems like it would be good.
20:05:36 <MarLinn> Hafydd: please advise
20:05:48 <eizua> shachaf: Hopefully there's some PDF version of that somewhere
20:05:49 <amalloy> eizua: LYAH is fine still
20:06:31 <Hafydd> MarLinn: are you asking what I'd put instead? Probably "-- arulmani" or "arulmani, see below:"
20:06:34 <systemfault> With LYAH, you learn parts of the language... but at the end, still have no idea of how they work together.
20:06:47 <eizua> amalloy: I think it still is, then just turn to here or StackOverflow for more advanced topics :)
20:07:01 <amalloy> or do exercises to get practical experience
20:07:18 <amalloy> like IMO adventofcode is a great source of practice problems
20:07:29 <eizua> amalloy: aka, "build something real"
20:07:37 <_matix> 99 problems has been great for me
20:08:06 <_matix> also just working on an application that i would typically know how to build in any imperative language, and realizing i have no clue how to design it in haskell
20:08:36 <ashishnegi> hi.. i am replacing `Handle` in my game with `Chan` to make gameengine part network-agnostic.. Handle has read/write to client but Chan reads/write to itself.. do we have a wrapper that encapsulates two Chans to solve this problem ? should i just use (Chan InMessage, Chan OutMessage) ??
20:10:00 <wedify> _matix: it would help if you could tell us what you're trying to do
20:11:02 <_matix> wedify: i was commenting on the above conversation about ways of learning haskell.  unfortunately i'm not very clear in my thoughts.  what i meant to say is that a great way of learning is just to attempt to build an application (assuming you know how to write said application in an imperative language).
20:13:06 <pavonia> ashishnegi: What do you mean by "Handle has read/write to client but Chan reads/write to itself"?
20:14:06 <ashishnegi> pavonia: when we write to handle and read from it .. you donot get the same value.. what you write goes to client and what you read comes from client .. atleast in Network Socket Handle
20:14:32 <ashishnegi> pavonia: in case of Chan.. since it is internal resource.. you read/write what you write/read respectively
20:16:30 <ReinH> Not necessarily
20:18:44 <glguy> ashishnegi: I don't know of a commonly-used datatype for a pair of channels like that
20:19:22 <ashishnegi> glguy: pavonia thanks.. i would go with pair for now.. :)
21:30:48 --- mode: ChanServ set -q *!*@62.244.139.175
21:33:51 <lpaste> manyone pasted ‚Äústanding ovation code jam practice‚Äù at http://lpaste.net/187907
21:34:41 <xuxu> hello, how do i install the Control.Comonad into my stack based project?
21:35:48 <manyone> why do i get an error on "import io"? in my lpaste 'ovation'?
21:36:34 <glguy> manyone: The IO module is old tech. You can import System.IO these days
21:37:01 <manyone> glguy: thanks let me try that
21:37:08 <glguy> Or in your case you can just omit the import, it doesn't look like you're using anything from that module
21:38:29 <geekosaur> heh. lpaste even warns you about the h98 import
21:38:38 <lpaste> manyone revised ‚Äústanding ovation code jam practice‚Äù: ‚Äústanding ovation code jam practice‚Äù at http://lpaste.net/187907
21:38:48 <geekosaur> 5:1: Warning: Use hierarchical imports
21:38:51 * dmj hates old tech
21:43:46 <glguy> xuxu: You add the comonad package to your .cabal file
21:43:59 <glguy> specifically in the build-depends section
21:49:33 <dfeuer> Is it just me, or did github just recently start griping about lines that start with commas?
21:49:58 <dfeuer> This is extremely annoying for Haskell code.
21:50:22 <geekosaur> not just you. I first noticed it last night
21:50:51 <amalloy> imagine the frustration of brainfuck programmers
21:50:54 <glguy> What do the gripes look like? Have a URL handy?
21:51:46 <dmj> gripe hub
21:51:58 <dfeuer> geekosaur, https://github.com/haskell/containers/pull/339/files
21:52:22 <geekosaur> presumably you meant glguy 
21:52:22 <kadoban> wow, that looks terribad ...
21:52:24 <dfeuer> Actually, it seems to complain about commas in various circumstances I can't actually figure out.
21:52:26 <glguy> Yikes. Time to file a bug
21:53:03 <kadoban> Their syntax highlighting stuff is on github somewhere, isn't it? I forget where.
21:53:04 <dmj> yuck
21:53:05 <amalloy> someone probably made a bad edit to the syntax highlighter
21:53:37 <dfeuer> It's quite distracting.
21:53:45 <dfeuer> amalloy, that sounds like a good guess.
21:53:59 <kadoban> It's like pastebin's terrible haskell highlighting, but worse
21:54:15 <dmj> strange, some import code (which has commas) isn't affected
21:54:15 <amalloy> it's an open-source syntax highlighter so in theory you can send a PR, but i can't remember where it is
21:54:35 <dfeuer> geekosaur, glguy, I apologize that your nicks somehow blur in my head. I don't think I can fix that.
21:54:57 <dfeuer> dmj, it's all rather mysterious to me.
21:55:18 <dfeuer> It seems to have *something* to do with commas, but I don't know what.
21:55:28 <dmj> dfeuer: trying to see the exact pattern that warrants it
21:55:36 <dmj> isn't clear to me either
21:57:29 <amalloy> oh, they just use ace for highlighting now
21:58:58 <amalloy> https://github.com/ajaxorg/ace/commits/master/lib/ace/mode/haskell_highlight_rules.js maybe?
22:03:34 <dfeuer> amalloy, I don't think I'm going to be able to deal with it. Do you have time to open an issue? If so, please tag me in.
22:04:04 * dfeuer is a bit busy with various other things right now, and knows absolutely nothing about syntax highlighting anyway.
22:04:29 <amalloy> sure, i can make an issue. i fixed a thing in ace for clojure mode before, but it was a lot simpler than this haskell thing
22:04:49 <[k-> could it be the invalid: portion?
22:05:00 <dfeuer> Thanks, amalloy!
22:08:27 <ania123> if I have this term x\x.x and apply it variable renaming{x-->z}, we will obtain  z\z.z, but I want to distinguish free and bound variables, so I want variable renamimng to change only bound variables
22:09:04 <ania123> I really confuse, why variable renamimg is defind that strange way...
22:10:06 <pavonia> ania123: Where is it defined that way?
22:11:18 <ania123> pavonia: http://pastebin.com/Ui2Nqbz1
22:11:20 <ania123> here
22:17:13 <pavonia> ania123: Is z a fresh variable in that case?
22:17:59 <ania123> yes
22:26:52 <geekosaur> "yay" freenode
22:27:20 <pavonia> ania123: Ther 4th rule is a bit strange. It should be more like (Œªx.M){x-->y} = Œªx.M
22:27:50 <ania123> wh?
22:27:53 <ania123> why?
22:27:59 <ania123> it is variable renamimg
22:28:09 <ania123> not substituion applycation
22:28:20 <pavonia> Oh
22:28:52 <pavonia> Well then
22:30:41 <amalloy> dfeuer: is @treeowl you?
22:31:45 <amalloy> well, i'll assume yes. how many dfeuers can there be in the github haskell org
22:32:11 <mniip> geekosaur, "yay" internets
22:37:31 <pavonia> amalloy: countably infinitely many
22:50:47 <amalloy> why do (id <$> zip <*> tail) and (zip <$> id <*> tail) the same thing? i see that's going on with former, since fmap id === id and i unsterstand what (zip <*> tail) does, but the latter is a bit mysterious to me
22:52:23 <systemfault> amalloy: I'm a beginner... but fmap'ing functions just compose them (id . zip) is the same as (zip . id)
22:54:26 <amalloy> hm, that's an interesting way to think about it
22:59:01 <jle`> amalloy: there's no deep reason why
22:59:08 <jle`> just expand teh definition of (<$>)
22:59:13 <jle`> and (<*>) for lists
22:59:22 <jle`> er, for functions
22:59:27 <jle`> this isn't a property about functors in general
22:59:39 <jle`> so looking at functor laws is not going to give you any insight
22:59:49 <jle`> that's like using the functor laws to ask why take 5 = take (2 + 3)
23:26:17 <tsani> I'm writing a servant combinator that inspects the request body and computes a signature of it, to compare the signature with one given in a header
23:26:58 <tsani> the problem is that if I use any of the functions for reading the request body, the body is "gone" after; a later use of ReqBody or another combinator that reads the body will fail
23:28:10 <tsani> Is there some way around this?
23:37:56 <tsani> Ah, it appears that I can write the request body that I've read back into the request
23:42:14 <tsani> Er, that *could* have worked, if servant let you modify the Request, but alas you can only ever get access to a copy of it.
23:43:34 <tsani> In that case, I think my approach will be to created a SignedReqBody combinator, that performs the signature check and then reimplements ReqBody
23:55:39 <manyone> how do you get 
23:55:55 <manyone> how do you get ["a
23:56:16 <manyone> how do you get ["a","ab","abc","abcd"] from string "abcd"?
23:56:29 <lyxia> inits
23:57:54 <oherrala> there's probably simpler way, but:
23:57:57 <oherrala> > let s = "abcd" in map (\n -> take n s) [1..length s]
23:59:31 <manyone> oherrala: amazing! 
23:59:46 <ongy> "inits" was actually an answer for you
23:59:49 <ongy> > init "abcd"
23:59:52 <manyone> oherrala: thanks
23:59:53 <ongy> > inits "abcd"
