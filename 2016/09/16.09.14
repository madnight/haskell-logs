00:47:53 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
00:47:53 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
01:04:47 <norotartagen> tbh i think command pattern would be used more if languages had better support for case splitting
01:05:40 <norotartagen> evaluable data structures are super handy but take both product AND sum types to define
01:08:35 <Cale> norotartagen: Perhaps even "command pattern" doesn't quite capture what we're really trying to do a lot of the time in functional programming
01:09:09 <norotartagen> i agree
01:09:25 <Cale> norotartagen: The best examples tend to involve algebraic data types which are not only sums of products, but recursive as well -- creating a language of simple commands or problems to be solved, and ways of combining them together
01:09:45 <norotartagen> oh yes
01:10:30 <norotartagen> i've been building a DSL for making websites at work
01:10:51 <Cale> I've been using a DSL for making websites at work :D
01:11:07 <norotartagen> what kind?
01:11:10 <Cale> reflex-dom
01:11:20 <norotartagen> what's taht?
01:11:29 <norotartagen> that*
01:11:31 <Cale> Reflex, an underlying component, is a functional reactive programming library
01:11:54 <Cale> It gives you values which represent things that change over time in various ways, and primitives for combining those
01:12:14 <norotartagen> what do you do for element positioning?
01:12:37 <Cale> and then reflex-dom gives you the ability to describe "widgets" that construct parts of the DOM as well as produce these values which describe some related values that vary over time
01:12:48 <norotartagen> i see
01:12:56 <norotartagen> sounds like a reactive framework
01:13:05 <Cale> e.g. one of the things a simple textbox widget will give you as its result will be a value that describes its contents at any moment in time
01:13:15 <Cale> (and allows you to tell when they're changed)
01:13:32 <Cale> Yeah, it's a functional reactive programming system
01:13:57 <norotartagen> what kinds of websites to you make with it?
01:14:40 <Cale> One of our client projects is a site for connecting shippers and carriers (truckers) with one another, kind of like an ebay or uber for trucks :)
01:14:59 <norotartagen> sounds fun :)
01:15:54 <Cale> Another one is a competitor to Slack, an internal-to-company chat service, with a bunch of additional features for organizing tasks and messages after the fact.
01:16:32 <Cale> I actually find that I enjoy frontend work more than backend now
01:16:38 <norotartagen> really?
01:17:11 <Cale> Yeah, reflex-dom makes it so nice -- I don't have to write any HTML or Javascript :)
01:18:13 <norotartagen> that sounds nice indeed
01:18:41 <Cale> and it's really good at keeping track of changes to things over time, so in our framework, we can support all these really nice dynamic things by default, where changes come in from the backend and are automatically propagated down to anything which depends on them
01:19:18 <norotartagen> what do you mean, come in?  ajax?
01:19:32 <norotartagen> or web sockets, even?
01:20:01 <bartavelle> Cale, last time I checked ghcjs+reflex-dom compilation times made it unbearable, and the resulting code was very laggy ... what's your experience like ?
01:20:39 <Cale> bartavelle: Well, I could always use faster compile times, but the resulting code behaves quite well
01:21:21 <bartavelle> that's good to hear (compile times were several minutes long for me, but there was a ton of TH because of aeson derivations)
01:21:26 <Cale> norotartagen: We connect a websocket and we collect up from the widgets on the page a data structure consisting of information about what the user is looking at, basically, and then the backend sends back what are effectively patches against a bunch of data structures making up the view.
01:21:43 <norotartagen> analytics <3
01:22:04 <Cale> bartavelle: Yeah, template haskell in ghcjs has to spin up a node.js instance at present and it slows things down a lot
01:22:18 <bartavelle> oh!!! I didn't realize that was the reason!
01:22:40 <Cale> norotartagen: Well, this isn't really for analytics, it's just to make sure we're sending only what's relevant
01:23:03 <Cale> norotartagen: The backend is notified about changes to the database, and needs to decide what things to send out to users
01:23:22 <norotartagen> oh i see, html patches over a web socket
01:23:29 <norotartagen> reminds me of mflow
01:23:32 <Cale> not html patches, data structure patches
01:23:32 <norotartagen> lol
01:23:55 <norotartagen> oh okay
01:24:11 <Cale> There actually isn't HTML to speak of, our Haskell program compiled to Javascript is controlling the contents of the DOM directly.
01:24:36 <norotartagen> what about CSS?
01:24:40 <Cale> So the lower level parts of our frontend stuff are just creating and manipulating nodes as necessary
01:25:02 <Cale> There is CSS to deal with, but we're using Clay to generate it
01:25:10 <Cale> (which is a Haskell DSL for CSS)
01:27:00 <Cale> http://cale.yi.org/reflex/ -- I have a bunch of small reflex demos here...
01:27:30 <Cale> Nothing too impressive there, but I intend to take some of them and turn them into tutorials at some point
01:28:02 <Cale> If you go into any of those, the jsexe directory is the one which actually runs the demo
01:29:01 <Cale> For instance, I wrote this audio player the other day for a guy who was asking how to hook into HTML audio elements http://cale.yi.org/reflex/Audio/Audio.jsexe/
01:29:57 <Cale> So the 'main' there consists of the main elements of the UI, and then audioPlayer and progress are somewhat-reusable widgets that I defined in terms of some lower level pieces.
01:31:23 <Cale> progress is a clickable progress bar -- you give it a Dynamic pair of the current value of the progress bar and the maximum, and it gives you back an Event of a value which represents the clicks that the user makes, scaled appropriately between 0 and the max value.
01:32:49 <Cale> and of course, the audioPlayer widget gives you a Dynamic pair of the current time and duration of the song which is presently loaded, so we can hook those up to each other to let the user seek through the audio :)
01:32:57 <norotartagen> i want to play that game when it's made
01:33:04 <Cale> haha
01:33:19 <Cale> You're talking about the "GamePiece" thing/
01:33:20 <Cale> ?
01:33:30 <norotartagen> yeah
01:33:45 <norotartagen> those attachments remind me of my childhood
01:34:04 <norotartagen> plasma cannons and rangemaster units
01:34:19 <Cale> Yeah, the intention is to make a chess-like game where your pieces start out unable to move or attack, and you upgrade them with components that you purchase
01:34:36 <Cale> and which let them move in various directions as a chess piece would
01:35:35 <Cale> (and then in all sorts of weird other ways :)
01:36:49 <Cale> (hopefully enough different kinds of upgrades to randomise the available set of them at the start of game a bit, so that opening theory doesn't stagnate so much)
01:38:35 <norotartagen> how do you feel about the opening theory of chess or go?
01:39:11 <norotartagen> (also, rip go, long live alphago)
01:39:17 <Cale> I'm happier with how things are in go than chess.
01:39:39 <Cale> I don't really hate either one though
01:40:09 <Cale> I just think it's interesting when games do this kind of thing to force the opening to have strategic principles, but not completely specified lines.
01:42:48 <Cale> I'm going to be stealing a lot of ideas here from a game called Prismata ;)
01:44:41 <Cale> norotartagen: The really interesting thing about AlphaGo is that supposedly the version which runs on a single desktop machine without the massive cloud computing still has an appreciable fraction of the strength.
01:45:44 <Cale> But they still haven't released it...
01:46:08 <norotartagen> lol
01:59:35 <ph88> how should i read this line here?  https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Unicode.html#isSpace
02:00:11 <ongy> which line exactly?
02:00:29 <ongy> are you confused about the | guard syntax?
02:01:37 <ph88> ah yes
02:01:58 <ph88> ok now that you mention guard syntax i understand it again ^^
02:02:41 <Cale> ph88: If the numerical value of the character is less than or equal to 0x377, then it is a space if that value is 32, or if subtracting 9 gives a result less than or equal to 4 (why would they write it like that? I don't know), or if it's 0xa0
02:03:11 <Cale> otherwise, apply iswspace to determine whether it's a space
02:05:05 <ph88> Cale, maybe it's an unsigned and subtracting 9 does not make it go negative ? 
02:05:28 <ongy> it's cast to word, so it underflows and becomes huge
02:05:40 <ongy> unsigned data type
02:07:46 <ph88> ah ok .. but then if it becomes huge it's not smaller than 4 .. so they use it to select a range of 5 characters from 9 to 13
02:08:47 <ph88> what about this   foreign import ccall unsafe "u_iswspace"   iswspace :: Int -> Int    where does this lead to ?
02:09:04 <merijn> ph88: It's foreign importing some C function
02:09:24 <ph88> how can i find out where the function definition is ?
02:09:40 <ongy> ph88: find it in the library that's used
02:10:08 <ph88> #include "HsBaseConfig.h"  this ?
02:10:42 <ongy> I would think that this header includes the header that includes...
02:10:47 <Cale> https://github.com/ghc/ghc/blob/5d98b8bf249fab9bb0be6c5d4e8ddd4578994abb/libraries/base/cbits/WCsubst.c
02:10:55 <ph88> thx
02:11:31 <Cale> ah, that code is generated by a program
02:11:32 <ph88> i'm making a quickcheck generator for space, to generate the same thing my parser can parse as being a space ..
02:12:12 <ongy> I would suggest just using the normal ascii space (maybe add newline if relevant), and not bother with unicode
02:12:27 <Cale> > filter isSpace ['\0'..]
02:12:30 <lambdabot>  "\t\n\v\f\r \160\5760\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202...
02:12:38 <Cale> > length (filter isSpace ['\0'..])
02:12:41 <lambdabot>  22
02:12:48 <ongy> that's way less than I expected
02:12:51 <ph88> wow very clever Cale !
02:15:43 <ph88> will ghc make this a constant?   filter isSpace ['\0'..]
02:16:09 <ph88> how can i actually force that something will be calculated on compile time ?
02:17:15 <Cale> ph88: If you define it as a top-level constant, it will be computed at most once.
02:17:35 <ph88> still at runtime though ?
02:17:45 <Cale> If you want to compute it at compile time, you can perhaps wrap it in a TH splice which applies lift...
02:17:58 <ph88> template haskell splice ?
02:18:04 <Cale> yeah
02:19:32 <ertesx> ph88: compute it in GHCi, write the result as a literal
02:19:56 <ph88> yup that's one option i know :P
02:20:08 <lpaste> Cale pasted “spaces” at http://lpaste.net/194440
02:20:25 <Cale> Yeah, just writing the literal result is probably easier :P
02:20:39 <ph88> well it's a nice introduction to th :)
02:21:13 <Cale> lift is a type class function which turns values of various types into TH expressions
02:21:38 <Cale> lift :: Lift t => t -> Q Exp
02:22:29 <ph88> and $(   )  ?
02:23:01 <ph88> i put it like this     s <- elements $(lift (filter isSpace ['\0'..]))
02:23:18 <Cale> That's a splice. You put a Q Exp inside it, and it runs the code (Q is a monad) and splices in the resulting expression.
02:23:21 <ertesx> the reason i wouldn't use the TH variant in this case is that GHC actually has to compute (interpret!) it during compilation…  this one is quick enough, but encode a few more and you quickly notice the slower compilation times
02:23:30 <ph88> eh that's not entirely correct actually ^^ it should be many elements
02:23:50 <ertesx> it also has to recompute every time you :reload it in GHCi
02:23:58 <ph88> right :/
02:24:15 <Cale> ertesx: You can help that a good bit by putting things of this sort into a separate module which can be compiled once and then reused as long as you don't change it.
02:24:25 <Cale> But yeah, it hurts the overall compile time of the project to do it.
02:25:01 <ph88> good to know :)
02:25:17 <ertesx> yeah, a separate module is a good idea
02:26:01 <ertesx> might be the best solution actually…  just note that GHCi will probably recompute it on every reload anyway
02:26:15 <ertesx> (unless you use -fobject-code apparently)
02:39:54 <ocharles> Hey all, my memory might be off, but am I right in thinking that GHC is making progress on being able to do something like:  data Vector2D a = V2 {-# UNBOX #-] a {-# UNBOX #-} a?
02:40:49 <ocharles> Right now I'm working exclusively with `Vector2D Double`, and I know I can get significantly better performance if I literally have `data Vector2DD = V2' {-# UNBOX #-} Double {-# UNBOX #-} Double`, but it's a shame to have to redefine everything. (the `ad` library does this, for example)
02:42:30 <ocharles> wondering if levity polymorphism is anything to do with this
02:43:38 <ocharles> s/UNBOX/UNPACK/ too, I think
03:37:19 * hackagebot batch-rename 0.1.0.0 - Make linux or macos do things like "rename *.mp3 *.mp4" in Windows/MSDOS  https://hackage.haskell.org/package/batch-rename-0.1.0.0 (uppet)
03:37:21 * hackagebot batch-rename 0.1.0.2 - Make linux or macos do things like "rename *.mp3 *.mp4" in Windows/MSDOS  https://hackage.haskell.org/package/batch-rename-0.1.0.2 (uppet)
03:37:23 * hackagebot batch-rename 0.1.0.3 - Make linux or macos do things like "rename *.mp3 *.mp4" in Windows/MSDOS  https://hackage.haskell.org/package/batch-rename-0.1.0.3 (uppet)
03:37:25 * hackagebot batch-rename 0.1.0.4 - Make linux or macos do things like "rename *.mp3 *.mp4" in Windows/MSDOS  https://hackage.haskell.org/package/batch-rename-0.1.0.4 (uppet)
03:40:01 <ph88> in quickcheck how can i generate Text that does not contain newlines?
03:41:33 <phadej> ph88: generate any text and filter out the newline character?
03:41:49 <dibblego> @type (==>) -- ph88
03:41:51 <lambdabot> STestable prop => Bool -> prop -> Test.QuickCheck.Safe.SProperty
03:42:35 <lyxia> ==> is pretty bad here, since as the Text gets larger, the probability of it containing a newline tends to 1...
03:43:16 <dibblego> newtype NoNewLineText = NoNewLineText Text; nonewline :: Prism' NoNewLineText Text
03:44:39 <ph88> phadej, like this?  fmap (\\x -> x <> '\r' && x <> '\n') arbitrary
03:45:43 <phadej> if you generate `Text`, than more like fmap (Text.filter (`notElem` "\r\n")) arbitrary
03:45:46 <phadej> but yes
03:45:58 <phadej> but idea is the same yes
03:46:13 <ph88> eh rather:   fmap (\x -> x /= '\r' && x /= '\n') arbitrary
03:47:42 <lyxia> that generates a Bool.
03:55:50 <ph88> bbl
04:06:22 <a6a3uh> Hi! Following the NICTA course I stopped at Extend typeclass exercise. I really cant understand associativity restriction of that typeclass. It seems for me that will hold for any trivial implementation. For example in case of Extend List why (extended f) a = [f a] will not work?
04:07:49 <dibblego> a6a3uh: I am not sure what that answer means, but have you checked it is associative?
04:08:44 <dabd> Given an recursive definition of a binary Tree and a function size :: Tree -> Int when trying to write a property based test for it, I find that using structural induction I end up writing the test as the definition of the function I'm testing. For recursive data structures the definition is the inductive proof itself or am I wrong?
04:09:04 <a6a3uh> associative means that (extended f) . (extended g) = extended (f . extended g) and it seems holding for trivial implementation
04:09:05 <dabd> given a*
04:09:31 <dibblego> a6a3uh: have you checked that it holds for a trivial implementation?
04:10:34 <a6a3uh> well I provided mental experiment and it seems holding. but whether it holds or not will depend on f and g. maybe for some f or g it will not hold
04:10:42 <dibblego> a6a3uh: Try it :)
04:10:56 <a6a3uh> I cant find some counterexamples of f and g where it not works
04:11:07 <dibblego> Demonstrate this with the code
04:11:14 <a6a3uh> for example if f is length and g is reverese it seems working
04:11:24 <dibblego> have you shown this to yourself? if so, show the code
04:11:54 <a6a3uh> I see... well I really should try in code. I only tried it mentally. 
04:12:05 <dibblego> a6a3uh: surprise yourself first :)
04:14:43 <opqdonut> dabd: for simple cases yeah
04:14:56 <opqdonut> dabd: the same applies to many other functions like reverse
04:15:09 <opqdonut> dabd: i.e. a complete specification is also an implementation
04:15:30 <dabd> opqdonut: so I shouldn't bother writing a property based test?
04:15:39 <opqdonut> dabd: but if you consider something like red-black-rebalancing, the properties are easier to type out than the implementation
04:16:12 <opqdonut> dabd: for a tree sum I'd just have 5 hand-written test cases or so
04:16:25 <opqdonut> there aren't really any subtle bugs you can bake in
04:16:32 <opqdonut> unless you try
04:16:34 <dabd> opqdonut: for reverse we can write property like reverse(reverse(l)) == l
04:16:41 <opqdonut> yeah but that's not complete
04:16:58 <opqdonut> you can invent those types of properties for a tree sum too
04:17:12 <opqdonut> like "treeSum (Node l r) == treeSum (Node r l)"
04:17:45 <dabd> what do you mean by not being complete?  When we write properties we want to informally verify that a given implementation satisfies them.  Do we want to enforce a correct implementation from the properties too?
04:18:18 <opqdonut> I mean you need to have other properties in addition to "reverse(reverse(l)) == l" to be able to be sure that reverse is right
04:18:49 <opqdonut> and the simplest way of writing out a complete set of properties for "reverse" is pretty much the naive recursive implementation of "reverse"
04:18:53 <dabd> like the distributive property of reverse in relation to append for example
04:19:24 <opqdonut> i.e. "reverse [] == []; reverse (x:xs) == reverse xs ++ [x]"
04:19:51 <opqdonut> yeah the distributive property is just a generalisation of my last property there
04:22:41 <opqdonut> but anyway, testing is not an art not a science, just do whatever feels good
04:23:13 <dabd> I see property based testing as poor man's model checking
04:25:11 <opqdonut> yeah
04:33:29 <a6a3uh> dibblego: well I've tried my trivial implementation and it works at least for length and reverse functions in both orders of application. The following code uses names from course (<<= instead of standard extended and custom List implementation): let left = (length <<=) . (reverse <<=) ; right = (<<=) (length . (reverse <<=)); lst = (1 :. 2 :. Nil) in left lst == right lst
04:33:45 <boothead> Hi folks, is this a good place to ask about stack, or is there a sparate room?
04:34:38 <xa0> Cale: that has to be the first time ever I've been pinged accidentally in that way
04:34:41 <xa0> gg
04:36:30 <dibblego> a6a3uh: for what (<<=) ?
04:36:30 <maerwald> boothead: #haskell-stack
04:36:38 <boothead> thanks maerwald 
04:37:20 * hackagebot batch-rename 0.1.0.6 - Make linux or macos do things like "rename *.mp3 *.mp4" in Windows/MSDOS  https://hackage.haskell.org/package/batch-rename-0.1.0.6 (uppet)
04:37:22 * hackagebot batch-rename 0.1.0.7 - Make linux or macos do things like "rename *.mp3 *.mp4" in Windows/MSDOS  https://hackage.haskell.org/package/batch-rename-0.1.0.7 (uppet)
04:37:24 * hackagebot batch-rename 0.1.0.8 - Make linux or macos do things like "rename *.mp3 *.mp4" in Windows/MSDOS  https://hackage.haskell.org/package/batch-rename-0.1.0.8 (uppet)
04:37:24 <a6a3uh> in course (<<=) stays for "extended" in Data.Functor.Extend
04:37:26 * hackagebot batch-rename 0.1.0.9 - Make Linux or MacOS do things like "rename *.mp3 *.mp4"  https://hackage.haskell.org/package/batch-rename-0.1.0.9 (uppet)
04:38:04 <a6a3uh> dibblego: in course (<<=) stays for "extended" in Data.Functor.Extend
04:38:08 <dibblego> a6a3uh: the NICTA/course does not use Data.Functor.Extend
04:38:40 <a6a3uh> dibblego: they dont but thay are implemented the same functionality. 
04:38:51 <dibblego> the Extend instance for List is an exercise
04:38:59 <dibblego> what have you done for this exercise?
04:39:02 <a6a3uh> dibblego: so my code example uses NICTA terminology
04:39:24 <dibblego> I need to know the value for (<<=) to determine if the implementation is associative
04:40:40 <a6a3uh> dibblego: I'm implementing Extend typlass for List. My implementation od (<<=) is trivial f <<= a = (f a :. Nil). But it holds assocoativity at least for example Ive provided before
04:49:04 <dibblego> a6a3uh: yes I believe this is associative; usually, but not for List, there is an identity value which constrains it further
04:50:30 <a6a3uh> dibblego: so associativity constraint is not enougth? what else constraints should I take into account to make work correctly?
04:50:56 <Wizek> Anyone knows if it is possible to programmatically interact with GHCi, and if so, how? E.g. I am looking for a function that when invoked from within GHCi, behaves quite exactly like writing `:r` does. It's not a problem if invoking this function from outside of GHCi raises an exception. 
04:51:22 <dibblego> a6a3uh: the instance Extend List has tests with them
04:53:20 <pavonia> Wizek: You mean a function that can be used in your Haskell module?
04:53:53 <a6a3uh> dibblego: yes but those tests follows the rule I not aware of. It is stated that my code should typechecks and obey associativity. Well I provided it. but in tests thay use some different implementation that probably also typechecks and also satisfy associativity. So why their implementation correct while mine is not?
04:54:26 <Wizek> pavonia, hmm, well, initially I didn't plan on writing this to a file, but yes, eventually if that is possible then all the better.
04:54:45 <dibblego> a6a3uh: associativity is necessary but not sufficient; the tests should also pass.
04:55:39 <Cale> xa0, haha
04:55:57 <pavonia> Wizek: So if you only want to use it from GHCi, why do you want a function at all?
04:56:50 <boothead> is #haskell-stack channel still in use?
04:57:27 <a6a3uh> dibblego: ok. so I also should check tests and try implement accordingly... still want to understand what is the real value behind this typeclass and why it is implemented in particular way and what it is usefull for. if I knew how it is really used maybe I implemented it in different way instead of trivial implementation.
04:58:57 <dibblego> a6a3uh: it becomes useful when you implement ListZipper
04:59:53 <Wizek> pavonia, Sure, here is some context: I've been frustrated with tests taking 20-30 seconds to compile in some projects of mine, and I just realized that doing `:cmd return ":r \n hspec spec"` works at least an order of magnitude quicker, if not 2. And I am looking to see if I can re-load and re-run the tests whenever any source file changes.
05:01:04 <Wizek> btw, I've just stumbled into https://hackage.haskell.org/package/ghcid which seems quite promising for what I am trying to do
05:01:25 <Wizek> but I am still curious to hear if there is a simpler/different way too
05:01:27 <quchen> Wizek: If you compile tests with -O0 they’ll compile much faster (but run much slower), if that helps.
05:02:02 <Wizek> quchen, the above figures are already with -O0 :(
05:04:36 <Wizek> quchen, Also, what I've found really is a best of both worlds, since I can actually load all the modules as object code too, and hence they will run quick and also the feedback loop can be tight too! `stack ghci --test --ghci-options="-fobject-code"`
05:04:59 <quchen> But that won’t auto-reload
05:05:13 <Wizek> And that's exactly what I am trying to make work now
05:05:28 <quchen> I assume --file-watch does not help
05:05:45 <quchen> Or does it? Not sure what it does when you use ghci
05:06:26 <Wizek> Well, even if it did, I don't think it would have the curtesy of re-running my specs after reloading
05:06:31 <Wizek> but gonna try it soon
05:07:42 <Wizek> This is the closest I could get to the desired behaviour; behold the "very poor man's 'auto reload'": `:cmd return $ concat $ replicate 2 $ unlines $ ["", "threadDelay 2000000", ":r", "hspec spec"]`
05:07:47 <Wizek> quchen, ^
05:08:33 <jakub_> I suspect there might be (maybe in Control.Arrow) a concise implementation of (a -> b) -> (c -> d) -> (b -> d -> e) -> (a -> c -> e) but I fail to find it... the intent is a precomposition for 2 argument function, what would be the best way to do this? or where is such a function defined?
05:10:13 <quchen> :t \f g s a c -> s (f a) (g c) -- I think the explicit form is probably the clearest.
05:10:15 <lambdabot> (t1 -> t) -> (t4 -> t2) -> (t -> t2 -> t3) -> t1 -> t4 -> t3
05:10:29 <quchen> And I don’t think this is somewhere in the standard libs.
05:10:51 <jakub_> quchen: thanks! any idea how to name this thing?
05:11:30 <quchen> I don’t think it makes code more readable to use that function to be honest.
05:11:40 <quchen> So rather than naming it, I would avoid it.
05:11:55 <jakub_> quchen: oh, ok
05:12:06 <Wizek_> :t flip . ((flip . ((.) .)) .) . flip (.) -- Please don't do this :D
05:12:08 <lambdabot> (a1 -> b1) -> (a -> b) -> (b1 -> b -> c) -> a1 -> a -> c
05:12:13 <quchen> If you have a domain-specific use case there might be useful names, but the lambda on its own is a bit of a beast.
05:12:54 <jakub_> quchen: to me it is not that far from bimap/dimap but maybe you are right
05:13:17 <quchen> I would also not recommend using bimap too much. :-)
05:13:46 <quchen> BiReader :-)
05:13:47 <jakub_> :) yeah I am not very experienced, so I might be using the wrong constructs
05:14:10 <quchen> The construct is valid, I’m just saying that it’s not very readable in code.
05:16:12 <quchen> If I gave you a JS function   function(f){return function(g){return function(s){return function (a){return function(c){return s(f(a), g(c))}}}}}, you would probably complain, even if it was nicely formatted. ;-)
05:16:37 <koz_> quchen: Why would you even.
05:17:16 <quchen> There are a handful of function combining functions people use in Haskell, but they’re mostly (.) and normal function application.
05:17:42 <quchen> The rest leads to combinatorical explosion of all the possibilities, and nobody can remember all the fancy ways of swapping arguments and pre-post-composing.
05:17:46 <jakub_> well to me it is a lot better to think about something along the lines "there is a function that takes two things and produces another one, oh and by the way the two things i pass to it get preprocessed" rather than "look! we do some stuff with one thing then we do something else with a completely different thing and then we combine the results somehow"
05:20:07 <Insanity_> Quite basic question incoming: 
05:20:17 <Insanity_> How can I escape on '\'. For example this works
05:20:34 <Insanity_> > takeWhile (\x -> x /= '4') "165465\n"
05:20:37 <lambdabot>  "165"
05:20:45 <Insanity_> > takeWhile (\x -> x /= '\\') "165465\n"
05:20:48 <lambdabot>  "165465\n"
05:21:02 <Insanity_> I thought \\ would escape it but I seem to be wrong there
05:21:08 <jakub_> the problem is that there is no \ in the string
05:21:10 <quchen> \n is the newline symbol. \\n is an escaped backslash followed by an "n".
05:21:35 <quchen> > takeWhile (\x -> x /= '\\') "165465\\n"
05:21:37 <lambdabot>  "165465"
05:21:54 <Insanity_> well, I have a text file and when I read it in haskell
05:22:02 <Insanity_> it shows only one \n; but doesn't seem to interpret it as a newline
05:22:34 <Insanity_> As in,  it literally prints "bunchofData\n"
05:22:54 <quchen> Maybe you’re using “print” instead of “putStrLn”?
05:23:16 <quchen> print will apply “show” to its argument, and show on strings adds quotation marks and escape backslashes.
05:23:19 <Insanity_> The line is "putStrLn $ show (solve content)"
05:23:30 <Insanity_> Woops, I was a second to slow, it's the show then :-) 
05:23:57 <jakub_> Insanity_: yup, you usually dont want to "show" strings
05:24:07 <quchen> To print a string, use putStrLn. To print anything showable, use “putStrLn (show x)”, for which we have the standard shortcut “print x”.
05:24:30 <quchen> Insanity_: Try adding two "show"s and see what happens!
05:24:38 <quchen> > "Hello\n"
05:24:41 <lambdabot>  "Hello\n"
05:24:42 <quchen> > show "Hello\n"
05:24:45 <lambdabot>  "\"Hello\\n\""
05:24:48 <quchen> > show (show "Hello\n")
05:24:51 <lambdabot>  "\"\\\"Hello\\\\n\\\"\""
05:25:06 <Insanity_> quchen: Indeed, it became a mess
05:25:08 <quchen> Each "show" on strings will add its own quotation marks and escapes
05:25:18 <Insanity_> Yup, I see that now :D thanks!
05:25:28 <quchen> The reason is that show often generates output suitable for being pasted into Haskell source files
05:25:46 <quchen> Show is more of a dirty-debug-show than a "give me this as a nice string"
05:25:51 <Insanity_> Oh right, and indeed the newlines can be handy there
05:26:04 <Insanity_> Thanks for the explanation 
05:37:21 * hackagebot supermonad 0.1 - Plugin and base library to support supermonads in Haskell  https://hackage.haskell.org/package/supermonad-0.1 (JanBracker)
05:38:33 <koz_> What is a supermonad even?
05:40:23 <implementation> the lambda representation of superman
05:41:35 <phadej> seems to be indexed monads or even generalisation of them
05:59:20 <Maxdamantus> Supercool, superdude, superhip, supermonad.
05:59:53 <liste> supermonad = ad for a jamaican version of superman
06:01:33 <Insanity_> Lol
06:02:16 <Maxdamantus> (my comment was meant to be a refrence to https://www.youtube.com/watch?v=4SqdLsCsjYw fwiw)
06:09:41 <codedmart> I am looking at doing a client driver for arangodb. The interface to arango is HTTP so I thought I would use http-client. Any other suggestions? Also I need to be able to allow you to specify host, port, db, etc. and allow them to be able to change the db if they want. Should I use a state monad for that? First time starting a library from the ground up.
06:14:17 <codedmart> Really I only need the db and maybe one other option to be changeable. 
06:14:48 <zyla> Hi
06:15:07 <Forlorn> Is Haskellbook worth purchasing? Has anyone here read it?
06:15:10 <Insanity_> Hey
06:15:20 <zyla> I made a parser combinator library that works at the type level (computes using TypeFamilies) - https://zyla.neutrino.re/posts/2016-09-13-typoparsec.html
06:15:34 <zyla> What do you think? Do you have any suggestions for improvements?
06:15:36 <codedmart> Ah nevermind I have an idea.
06:17:59 <phadej> zyla: cool!
06:19:48 <zyla> phadej: Thanks!
06:20:23 <phadej> zyla: example of failing case in the end would be nice too
06:20:40 <phadej> actually cannot see any
06:21:55 <zyla> Right, there's only negative test case. I should add more.
06:24:48 <lingxiao> hey guys
06:25:52 <lingxiao> hey guys
06:25:55 <lingxiao> if i rm -rf a direotry
06:25:56 <zyla> hi
06:25:59 <lingxiao> is there a way to get it back?
06:26:10 <lingxiao> not a haskell question but im here all the time
06:28:16 <zyla> lingxiao: probably yes, but you should stop writing to the file system as soon as possible
06:28:27 <lingxiao> huh?
06:28:32 <lingxiao> im was doing this in bash
06:29:25 <zyla> to minimize the chance that new data is written in place of old one
06:33:39 <Hi-Angel> I noticed an inconsistency in types. Supose, I run "let foo :: f a -> Int; foo _ = 1", now I can do "foo (1,'f')". But what's the "a" type in the pair? Isn't it rather "f Int Char"? How does it work?
06:35:46 <hpc> Hi-Angel: (1, 'f') :: (Int, Char), or (,) Int Char
06:35:51 <ClaudiusMaximus> Hi-Angel: (Int, Char) ~ (,) Int Char ~ ((,) Int) Char   so   f ~ (,) Int   and   a ~ Char    (ignoring the polymorphism in 1 :: Num n => n)
06:35:54 <hpc> Hi-Angel: and f = ((,) Int)
06:36:20 <hpc> types can be curried too :D
06:36:37 <Hi-Angel> Oh, wow, thank you, I see
06:37:51 <[k-> ertesx: still here? Could be that maximumBy isn't inlined? or comparing isn't inlined? or the rules didn't fire for some reason?
06:41:56 <ertesx> [k-: i was told that maximumBy is implemented in terms of foldr1, but haven't checked myself
06:42:09 <ertesx> if that's the case, that explains its terrible performance
06:42:45 <clueless> http://lpaste.net/194754 help plz, I'm having difficulties adding user input
06:43:39 <mauke> clueless: name <- readLn; print (fib name)
06:45:35 <[k-> ertesx: I have a question about this line: fromInteger (toNanoSecs (t1 - t0)) / 10e9
06:45:48 <[k-> why did you divide it by 10e9?
06:46:07 <phadej> why not 1e0
06:46:09 <phadej> why not 1e9
06:46:28 <clueless> mauke: thanks a lot, I had been stuck w this for a bit
06:46:35 <phadej> > 1e9 == 1000* 1000 * 1000
06:46:37 <lambdabot>  True
06:47:12 <[k-> also, nanosecs is already 1e-9
06:47:55 <ertesx> oh shit!
06:50:04 <ertesx> so it wasn't the I/O after all…  it was me being stupid
06:50:50 <merijn> :)
06:51:59 <ertesx> that's quite terrible…  it means that the C version is faster by a factor of 14, not 1.4
06:53:05 <[k-> ertesx: Foldable []'s foldr1 isn't inlined, maximumBy also isn't inlined, comparing also isn't inlined
06:53:57 <ertesx> i don't have time to fix it right now, but i'll certainly come back to it…  this is unacceptable =)
06:55:00 <[k-> but... why did you divide though
06:56:12 <[k-> 1e-9/1e9 = 1e-18 s
06:56:26 <[k-> did... I get the math wrong?
06:57:31 <[k-> no, it's correct
06:58:18 <puregreen> [k-: toNanoSecs presumably gets nanoseconds, dividing by 1e9 turns it back into seconds
06:58:31 <puregreen> 'cause there are 1e9 nanoseconds in a second
06:58:36 <puregreen> I haven't seen the code though
06:58:43 <Boomerang> Does anyone know if the IORef "counter" in Language.Haskell.TH.Syntax is a per module reference or if it is globally accessible to the whole project?
07:00:26 <[k-> oh dear my math
07:01:12 <pavonia> Boomerang: It's global to the whole project, i.e. there's one one instance created when the TH library is loaded
07:01:20 <[k-> oh thanks puregreen, I fixed my misconception now :)
07:01:20 <pavonia> *only one
07:01:58 <Boomerang> Great thanks pavonia! :)
07:03:18 <jonored> but... if you compile into .o with separate commands, and then link?
07:04:31 <Boomerang> If you do that, I would assume you would have two different "counter" references. In my case I am compiling the whole project at once
07:04:43 <Boomerang> *two or more
07:27:44 <jchia_> I'm looking at the mtl package and trying to figure out Control.Monad.State.Strict. What does the '|' mean in "class Monad m => MonadState s m | m -> s where"?
07:28:22 <pkmx> functional dependencies
07:29:17 <jchia_> pkmx: Thanks, I'll read the haskell wiki for that
07:31:57 <Henson> would anybody with experience using Haskell in a commercial/industrial setting be interested in talking to me about it?  I'm trying to get a sense of how wise/unwise it would be to use it as the basis of an engineering project with a little bit of C/C++.
07:35:05 <ph88> hey guys, what do you think about using this instead of the standard prelude ?  http://tab.snarc.org/posts/haskell/2016-09-09-foundation.html
07:37:23 * hackagebot servant-quickcheck 0.0.2.0 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.2.0 (jkarni)
07:37:25 * hackagebot ansigraph 0.3.0.2 - Terminal-based graphing via ANSI and Unicode  https://hackage.haskell.org/package/ansigraph-0.3.0.2 (Cliff_Harvey)
07:51:55 <ashishnegi> Cale: if you are liking frontend.. try Elm-lang.. types all the way..
07:53:24 <c_wraith> ashishnegi: recommending Elm to someone using GHCJS is like recommending a yugo to someone driving a porsche. :P
07:54:11 <c_wraith> ashishnegi: sure, there are some added costs, but you just get so much more in exchange for them.
07:54:31 <ashishnegi> c_wraith: uh.. i read him saying that he/she uses react-dom 
07:54:46 <c_wraith> ashishnegi: yes, with ghcjs
07:55:05 <agocorona_> more than a posche, ghcjs is like a Bentley of 2.5 metric tons
07:55:24 <agocorona_> but very safe and comfortable
07:55:39 <c_wraith> Elm's better than a Yugo, too.
07:55:47 <c_wraith> It's a very nice economy car.
07:55:57 <c_wraith> But it isn't in the same league as a luxury vehicle.
07:56:07 <c_wraith> If you can afford the cost of the luxury vehicle. :)
07:56:55 <Cale> ashishnegi: reflex-dom
07:58:46 <c_wraith> Err, yeah.  Clearly I'm still working on more primitive bits with ghcjs.
07:59:23 <ashishnegi> Cale: have you/anyone written some blogs/resources about using ghcjs.. last time i checked a year ago, i became more confused.. i experience with elm is also good though. :)
07:59:43 <c_wraith> Cale: Do you have to deal with CORS requests?  I'm not sure if there's a library for ghcjs that handles them properly.
08:00:32 <Cale> c_wraith: I don't believe we've had to at any point, but I'm not sure about the other projects that Ryan and Ali did before I joined up
08:01:24 <Cale> c_wraith: In a few cases, we have our backend grab data from other locations, and serve it to users, which sort of sidesteps that whole issue.
08:01:36 <Cale> (but obviously isn't always going to be an option)
08:01:40 <c_wraith> Cale: yes, that is definitely a sidestep. :)
08:02:20 <agocorona_> What if i say that i can create a frontend-backend application in a single line
08:02:22 <agocorona_> ?
08:02:32 <Cale> ashishnegi: I plan to actually write some tutorials soon, perhaps when we're done with a client project we're in the last month of right now
08:02:55 <Cale> ashishnegi: But I have some little random demos that I've made for people here: http://cale.yi.org/reflex/
08:02:57 <c_wraith> agocorona_: then I'd ask how much work it takes to change what it does to something else.
08:03:15 <Cale> They're mostly not too spectacular, but they're small and hopefully it's possible to see how to do various things with them
08:04:01 <Cale> (look for the .jsexe directories to run the demos)
08:04:03 <agocorona_> main= keep . initNode . onBrowser $ getString Nothing `fire` OnClick >>= atRemote  . liftIO print
08:04:22 <ashishnegi> Cale: uh.. nice :+1
08:05:04 <c_wraith> agocorona_: are you the author of the library?  I've been trying to remember the name of it for a few days.
08:05:12 <Cale> http://cale.yi.org/reflex/Audio/Audio.jsexe/ is a cute example I did the other day for Welkin
08:05:14 <agocorona_> c_wraith:  yes
08:05:26 <c_wraith> agocorona_: can you remind me of its name? :)
08:05:31 <Cale> He wanted to know how hard it would be to hook into an HTML audio element
08:05:31 <agocorona_> it's ghcjs-hplay
08:05:50 <Cale> So I built a simple audio player widget and a clickable progress bar to seek the track
08:06:19 <agocorona_> it's part of transient 
08:06:32 <c_wraith> agocorona_: transient.  That's the one. :)
08:07:10 <Cale> The audio player takes as input a bunch of events to play/pause/stop playing, and an event to seek, and produces a Dynamic which says how far along in the track we are and what its duration is
08:08:04 <Cale> and then the progress widget takes a Dynamic for the current value and the maximum, and produces an Event which occurs when the user clicks on it, giving a value which is scaled between 0 and the max based on the x position of the user's click
08:09:21 <Cale> Those two things could very well go into a library somewhere -- probably you'd want to expand the audio player config with a few extra things in a real setting, but that's a decent start, and then in main you can see how we tie the components together
08:12:25 <Cale> The Armory thing is a probability calculator for a card-flipping game that's adjunct to a game called Prismata (not really part of the game itself, but you play to win unit skins and emotes and other cosmetic stuff)
08:21:25 <ashishne_> Cale: this is awesome :) i would definitely consider ghcjs for my next self-project.. hope you write some beginner tutorials by then.. would ping you then.. :) [feature-request: how to setup ghcjs]
08:22:06 <Cale> ashishne_: Oh, the easy way to get set up (at least if you have some disk space for it)
08:22:15 <Cale> https://github.com/reflex-frp/reflex-platform
08:22:35 <Cale> grab this repo, and there are some instructions and a bit of a tutorial on that page if you scroll down
08:24:22 <Cale> There's a try-reflex script in there, it uses the nix package manager (you don't need nixos, and it'll install the package manager for you), and it'll download known-working versions of everything you need to run ghcjs, and drop you into a shell that has ghc 8 and ghcjs 8 and all the packages ready to use.
08:25:07 <Cale> It's way faster and more reliable than waiting 2 hours or whatever for ghcjs to compile :)
08:29:49 <ashishnegi> Cale: can not find try-reflex script.. 
08:30:05 <Cale> ashishnegi: hm, if you clone that repo...
08:30:24 <Cale> it ought to be in the directory that you cloned it into
08:30:39 <Cale> like,  git clone https://github.com/reflex-frp/reflex-platform.git
08:30:55 <Cale> and then cd reflex-platform; ./try-reflex
08:32:13 <Cale> Is it really not there? What's in the directory?
08:32:58 <ashishnegi> Cale: i got disconnected for a while and lost some of your messages.. i see try-reflex in the repo.. thanks
08:34:21 <Cale> cool
08:35:01 <gummibears> hi room
08:35:25 <Cale> hello
08:35:26 <gummibears> is this a good place to ask newbie questions? or should i be in some other room?
08:35:32 <Cale> You're in the right place
08:36:03 <gummibears> I have a question. I'm writing a factorial function that takes a Word32
08:36:16 <gummibears> and I want it to return a Word64 
08:36:25 <Cale> fromIntegral ;)
08:36:43 <Cale> :t fromIntegral
08:36:45 <lambdabot> (Num b, Integral a) => a -> b
08:36:54 <gummibears> Thanks Cale. I'll check it out
08:36:58 <Cale> At least, if the question is how to convert between numeric types :)
08:37:01 <agocorona_> main= keep . initNode . onBrowser $  atRemote  waitEvents events >>=  rawHtml . H3
08:37:14 <gummibears> Yep it was how to convert from word32 to word64
08:37:25 * hackagebot darcs 2.12.4 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.12.4 (GuillaumeHoffmann)
08:37:26 <agocorona_> c_wraith:  this streams events from the server to the browser
08:37:27 * hackagebot http-client 0.5.3.2 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.3.2 (MichaelSnoyman)
08:37:29 * hackagebot http-client-openssl 0.2.0.4 - http-client backend using the OpenSSL library.  https://hackage.haskell.org/package/http-client-openssl-0.2.0.4 (MichaelSnoyman)
08:37:31 * hackagebot http-client-tls 0.3.1.1 - http-client backend using the connection package and tls library  https://hackage.haskell.org/package/http-client-tls-0.3.1.1 (MichaelSnoyman)
08:37:33 * hackagebot http-conduit 2.2.2 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.2.2 (MichaelSnoyman)
08:38:03 <Cale> Yeah, converting from an integer-like type to any numeric type, the answer is fromIntegral, and converting between fractional types, the answer is usually realToFrac
08:41:35 <gummibears> ok so i made a factorial function as follows:
08:41:37 <ongy> :t realToFrac
08:41:39 <lambdabot> (Real a, Fractional b) => a -> b
08:41:47 <gummibears> factorial :: Word32 -> Integer
08:41:47 <gummibears> factorial 0 = 1
08:41:48 <gummibears> factorial x = fromIntegral x * factorial (x - 1)
08:42:31 <gummibears> but i get a stack overflow exception in ghci if i try to calculate the factorial for 4294967295
08:42:53 <gummibears> I thought Integer had infinite precision
08:43:12 <ashishnegi> gummibears: where is your base case ?
08:43:24 <ashishnegi> gummibears: sorry saw it now
08:43:29 <gummibears> ok
08:43:34 <ongy> that's not a problem with the number being to big for integer, but you are building up to many calls
08:44:14 <gummibears> ok ongy. so how would one write it? should i try binary factorial?
08:44:22 <gummibears> lemme give it a try. one sec
08:46:59 <pavonia> gummibears: The expression you are building goes like 5 * (4 * (3 * (2 * 1))), i.e. you can only evaluate the whole thing if you reached the very last recursive call
08:47:09 <Cale> The factorial of 4294967295 probably uses too much memory to store regardless.
08:48:07 <Cale> Well, you might have enough memory to store the number itself... it'll be 43 gigabytes on its own.
08:48:30 <sm> lol
08:48:36 <ongy> and will take quite a while to compute
08:48:54 <ongy> Cale: how did you get that number?
08:49:06 <Cale> Taking the sum of base 8 logarithms
08:50:09 <clueless> http://lpaste.net/194902 can someone please help me do what I am trying to do, a little bit confused
08:50:14 <EvanR> yes, the number itself is not ridiculously big
08:50:21 <EvanR> what were you thinking of
08:50:32 <EvanR> storing that number of items
08:51:47 <ashishnegi> Cale: willn't haskell give stackoverflow much before that number ? he should be able to do at least that.. 
08:52:07 <Boomerang> clueless: I think you need to convert Integer to a String in check, try "show"
08:52:17 <sm> clueless: readLn returns a string, but check takes an integer
08:52:25 <Cale> ashishnegi: You can avoid a stack overflow easily with foldl' (or just use the product function and compile with -O or -O2)
08:52:39 <Cale> ashishnegi: But it doesn't change the fact that you'll almost surely run out of memory before you get there
08:52:48 <pavonia> :t readLn
08:52:51 <lambdabot> Read a => IO a
08:52:59 <sm> oh, my mistake
08:54:01 <Cale> You need enough memory not only for n! but also for (n-1)!
08:54:14 <Cale> (which you'll have in memory while computing the final product)
08:54:26 <ashishnegi> clueless: what is the confusion ?
08:54:36 <clueless> Boomerang: hey, that's what I thought (the int and string diff)
08:54:48 <Cale> So it's really more like 87GB.
08:54:53 <clueless> Boomerang: but are you saying to use show instead of print??
08:54:55 <ongy> I have access to a machine that could do it. But is there any reason to do so?
08:55:06 <Cale> ongy: probably not :P
08:55:46 <Cale> My desktop could store the result, but I don't think I could compute it
08:55:50 <sm> clueless: Boomerang means the two cases in check, the first is a string but the second is an integer
08:55:51 <clueless> Boomerang: oooh, I actually got
08:55:57 <ashishnegi> clueless: line 10 ; show (fib (n - 1))
08:55:59 <clueless> Boomerang: got it, thanks a lot!
08:56:00 <Cale> (I have 64GB)
08:56:03 <lpaste> ongy pasted “factorial tail-strict” at http://lpaste.net/194916
08:56:08 <EvanR> really, stack overflow?
08:56:11 * sm high-fives Boomerang and clueless 
08:56:19 <ongy> would that version work? For preventing the stack overflow?
08:56:23 <Cale> yes
08:56:25 <EvanR> i thought those were rare with the current default settings
08:56:27 <ClaudiusMaximus> iirc libgmp uses 32bit int instead of long for its size fields even on 64bit, so using Integer implemented with integer-gmp it'll abort (iirc) some time before the expected memory limits
08:57:10 <Cale> ongy: Actually, probably just compiling the same program with -O will have the same effect as adding the bang pattern, but the bang pattern is safer
08:57:53 <Cale> Well, "same" -- you'll get lots of other optimisations while you're at it
08:59:26 * Boomerang high-fives sm back!
09:00:32 <ongy> Cale: you mean if I don't add the bang pattern myself? So writing it in a tail recursive way is enough?
09:00:39 <Cale> ongy: yeah
09:00:47 <Cale> ongy: Strictness analysis will pick it up
09:01:07 <ongy> I tried in ghci, so I didn't want to rely on optimization
09:01:18 <gummibears> I dont' understand the version ongy pasted :(
09:01:25 <gummibears> I haven't come that far in haskell yet
09:01:30 <Cale> Of course, yeah, you might not want to rely on the strictness analyser, since in complicated situations it's a bit unpredictable
09:01:50 <Cale> So if you know that something is going to need to be evaluated early, adding a bang pattern or a seq is good.
09:02:10 <ongy> gummibears: The BangPattern language extion allows me to do the '!y' which forces eager evaluation. So thunks won't build up in the accumulator
09:02:51 <gummibears> ok. i kinda understand it
09:02:55 <Cale> gummibears: It's important to realise that lazy evaluation is outermost-first (GHC doesn't exactly use lazy evaluation, but it's a good approximation to what'll happen, especially with optimisations turned off)
09:03:10 <Cale> So, when you apply the function like  factorial (x - 1) (x * y)
09:03:26 <Cale> the pattern match against 1 will guarantee that the first argument will be evaluated
09:03:37 <Cale> But the second argument is only matched against a variable
09:03:47 <Cale> which means that there's no need to evaluate it right away
09:04:15 <Cale> and if we were following lazy evaluation to the letter, that would mean that a large unevaluated expression for the product would be built up in the second argument
09:04:59 <Cale> factorial' 5 1 -> factorial' 4 (5*1) -> factorial' 3 (4*5*1) -> ...
09:05:25 <Cale> and then when you get to the end, the product will start to happen
09:05:43 <Cale> It's important to realise that the stack in GHC is not what you'd normally think of as a call stack
09:06:07 <Cale> The things on the stack are for the most part pattern matches waiting to happen
09:06:20 <Cale> and in this case, they'll be pattern matches in the inside of the implementation of (*)
09:06:33 <Cale> (*) for Integer has to match on both its arguments
09:06:43 <gummibears> ok. where can i read more about the stack in GHC?
09:07:14 <gummibears> I've just started with learn you a haskell. which other book should i look into after i finish it?
09:07:48 <Cale> https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf has a good overview of some of the low level details, but it's actually at a lower level of abstraction than you'll usually need even when you're worrying about performance
09:08:17 <Cale> hmm... Simon Marlow's book on concurrency has some stuff on this as I recall...
09:08:39 <Cale> http://chimera.labs.oreilly.com/books/1230000000929/index.html
09:09:15 <Cale> He talks a bunch about how lazy evaluation works toward the beginning of the book
09:09:51 <Cale> But nobody really explains it the way I'd like it explained to beginners :)
09:10:01 <Cale> I really need to find some time to write a book someday
09:10:35 <EvanR> aint nobody got time
09:12:12 <Cale> gummibears: Most of the time when considering the time and space performance of Haskell code, it works fairly well to stay at a level of abstraction where you imagine expressions being rewritten by evaluation. Sometimes you need to think about the expressions as *graphs* rather than trees, because there can be cyclic things created by recursion.
09:12:20 <Cale> and things can be shared
09:12:26 <ongy> I mostly peaced it together from reading about thunks and hanging around here
09:12:30 <Cale> whenever you use a variable more than once
09:12:35 <gummibears> why do i get an error "parse error in pattern: factorial3'" on this line factorial3' x !y = factorial3' (x - 1) (x * y)
09:12:50 <ongy> gummibears: you need BangPatterns
09:13:00 <gummibears> ok
09:13:08 <ongy> you can put {-# LANGUAGE BangPatterns #-} at the top of your file to activate it
09:13:09 <Cale> add {-# LANGUAGE BangPatterns #-} to the top of the file
09:13:44 <gummibears> yes i just did. sorry i'd assumed it to be a comment
09:14:03 <Cale> gummibears: basically, the ! is a hint to the compiler that it should evaluate whatever expression is bound to y immediately
09:15:16 <Cale> With optimisations on, you could pretty safely expect GHC to figure out that it would be a good idea to evaluate y early here
09:15:26 <Cale> But this just makes sure that it's aware
09:15:29 <ongy> gummibears: {-# #-} are pragmas, the LANGUAGE pragma can be used to activate some language extension, you will find them rather often. Comments are {- -} (wihtout the '#')
09:15:48 <gummibears> ok understood
09:16:15 <Cale> Pragmas are also a form of comments of course, but they're ones which the compiler will actually look at and try to understand :)
09:20:28 <gummibears> Thanks ongy and Cale. You guys are great. I really appreciate you both taking time to help a newbie
09:20:50 <Cale> gummibears: no problem
09:24:30 <EvilMachine> Hi. Does anyone here have an idea how to deserialize in “object” from a mere string, if all I have is a text file that maps each string header type id to a library that I’m supposed to load dynamically? (Meaning I have zero clue about the type or if it even exists. All I know is that I may get an interface on it after loading the library.)
09:25:20 <EvanR> one component of the library java-bridge does something like that
09:25:28 <EvilMachine> It seems to me that Haskell can’t deal with an interface of unknown type, since it is deliberately not a dynamic language (and that’s a good thing)
09:25:40 <EvanR> its a more or less dynamically typed maps of functions of a dynamic type
09:25:40 <EvilMachine> EvilMachine: Ah, interesting!
09:25:56 <Welkin> EvilMachine: talking to yourself?
09:26:17 <EvilMachine> Welkin: lol, no, EvanR just starts with „Ev“ too. :)
09:26:21 <EvanR> talking to yourself and loading an unknown object of unknown interface dynamically are signs of insanity
09:26:44 <ongy> I'd say the second is worse
09:26:50 <EvilMachine> EvanR: Me being insane? … /That/ I already know. :D
09:26:52 <prsteele> (without a specific solution in mind) it sounds almost like you want a small interpreter layer
09:27:17 <ashishnegi> Cale: ghcjs setup done.. :) would read reflex-dom now.
09:27:28 <EvanR> dont you want to load the object and check that it has a desired interface?
09:27:35 <EvanR> if so, give it a proper type
09:27:56 <EvilMachine> I smell a large dose of inner-platform effect in there, but I fear that until I have a working … something… I’m unable to tell what the inner-platform part is. So would have to defer removing that to step 2.
09:28:03 <EvanR> and you can be liberal in the kinds of things you allow and uniformize it
09:29:27 <EvanR> if this is a library to shake and bake that process for any interface, then indeed you will be doing something like java bridg, and TH is probably a better bet
09:30:34 <EvilMachine> EvanR: Imagine a library that offero a CRUD interface, no matter what actual implementation you’re dealing with in the back-end. I can’t just go and hard-code a list of possible “plug-ins” into my code, since that kills the whole point of a plug-in system.
09:30:37 <Cale> EvilMachine: You can always specify through a type what the possible options are for the data you're looking at directly. If all you have are mappings from strings to strings you can use Map Text Text or something
09:30:56 <EvilMachine> offero → offers
09:31:16 <EvanR> the interface to the driver plug ins should be a specific type, not "anything"
09:31:38 <EvanR> something has to be defined somewhere (law of metaphysics)
09:31:59 <Cale> EvilMachine: A key approach is to work out what the operations are that you'd like to be able to perform on your thing of "unknown type", and then consider just making *that* the type!
09:32:12 <Cale> EvilMachine: i.e. just build a record consisting of the results of those operations
09:32:17 <Cale> (partially applied to the data)
09:32:38 <EvanR> yes, interface = record of functions / constants
09:32:44 <EvilMachine> EvanR: Yes. Let’s call the interface “CRUD”. It has the usual four functions. But it’s just an interface. The library would offer the actual implementation and type. There would be multiple libraries loaded at the same time. So the type could not be be the same.
09:32:57 <Cale> No, it could be the same
09:33:24 <EvilMachine> EvilMachine: interface = record of functions /constants, plus their closure. :)
09:33:27 <EvanR> youre contradicting, the library has "the" implementation? or there are many implementations
09:33:30 <Cale> It'd be the record of those 4 operations, however it is that the main part of your program is going to interact with them
09:34:02 <EvanR> each implementation would be a separate plugin, it sounds like
09:34:12 <Cale> You don't even have to say closure -- closures are an implementation detail -- they're just one of the possible implementation mechanisms for implementing functions.
09:34:24 <EvanR> yes closures are part of "function"
09:35:15 <Cale> You can implement functions which behave the same way in ways that don't involve closures though, which is why I usually avoid the word unless talking about how the compiler works.
09:36:19 <Cale> (e.g. lots of graph reduction mechanisms won't need an explicit data structure for closures, the edges in the graph will serve the purpose of capturing the right things)
09:36:58 <EvilMachine> EvanR: My library, named CRUD, exports the CRUD interface, and imports various libraries that export implementations for that interface, which themselves allow you to query the back-end. The query result will contain at least one string that must be deserialized to the CRUD interface too, using possibly another library with another implementation of that interface.
09:37:26 * hackagebot codex 0.5.0.1 - A ctags file generator for cabal project dependencies.  https://hackage.haskell.org/package/codex-0.5.0.1 (bitemyapp)
09:37:26 <EvanR> so youre offering N finished implementations with it
09:37:28 * hackagebot batch-rename 0.1.1.0 - Make Linux or MacOS do things like "rename *.mp3 *.mp4"  https://hackage.haskell.org/package/batch-rename-0.1.1.0 (uppet)
09:37:37 <EvilMachine> EvanR: And when I say “imports”, i mean dynamically, like a plug-in.
09:37:37 <EvanR> ok but you said you didnt like that
09:38:01 <EvilMachine> EvanR: Yes, I offer N finished implementations with it, but allow the user to add more.
09:38:14 <EvilMachine> EvanR: Even without my knowing.
09:38:38 <Cale> EvilMachine: When you're talking about serialisation of that sort, typically there will need to be some part of the deserialiser which has some measure of "omnipotence", even if you leave most of the work up to the client modules.
09:38:38 <EvanR> for converting results to a haskell data structure, the *sql-simple packages are interesting
09:38:56 <EvilMachine> Cale: correct.
09:38:59 <EvanR> it uses type classes
09:39:36 <EvanR> Cale: i dont get what you mean by omnipotence, or omnisentience
09:39:51 <Cale> oh, yeah, I meant to write omniscience
09:39:59 <EvanR> omniscience
09:40:05 <EvanR> i still dont get it ;)
09:40:13 <Cale> by which I mean you need to parse some initial thing which says which module it is that you wanted to use to deserialise -- so you have to know what the options are somewhere
09:40:24 <EvilMachine> EvanR: Hmm, my question would be, if sql-simple  can convert data types that were unknown at compile time, if it had access to another haskell module that would offer functionality to do so through a standard interface.
09:40:44 <EvanR> you just import more instances of the class
09:40:51 <EvanR> thats how it works
09:41:11 <EvanR> Cale: i dont see how thats necessary for this
09:41:39 <EvanR> if you pick your module to be compatible with your binary stream
09:43:17 <EvilMachine> EvanR: Interestingly, that (class + instances) is how i implemented it right now. (Sill missing dynamic loading.) But I stumbled over the problem, that I can’t convert my C>R<UD query results to a type unless I know the existence of that type.
09:43:19 <Cale> EvilMachine: sql-simple?
09:43:29 <Cale> Do you mean postgresql-simple?
09:43:42 <EvilMachine> Cale: Ask EvanR.
09:43:52 <Cale> oh
09:44:03 <EvanR> *sql-simple
09:44:04 <Cale> Yeah, he means a bunch of similar packages, okay
09:44:06 <EvanR> glob
09:44:18 <EvilMachine> ah, yeah
09:44:28 <Cale> I'm not even sure they're all that similar
09:44:33 <Cale> But yeah
09:44:39 <EvilMachine> I wondered if the star was supposed to be a … *gags* … pointer. :D
09:44:47 <EvanR> EvilMachine: the conversion of results is what i was referring to with classes, but the interface itself for drivers to implement... i would try a record first
09:45:45 <EvanR> and yeah, i am skeptical that storage backends are similar enough to allow a "one interface to rule them all"
09:45:52 <EvilMachine> EvanR: I tried a record type just before I entered this chat, and the problem was that I didn’t know how to get back a value of the correct (unknown at compile time!) type from a mere string.
09:45:58 <ggVGc> hey EvanR, what are you working on nowadays?
09:46:03 <EvanR> clearly databases vaguely do "storage" but what do they really have in common, mathematically
09:46:07 <EvilMachine> EvilMachine: You’d be surprised. :) 
09:46:21 <ongy> EvilMachine: still talking to yourself? :)
09:46:23 <EvilMachine> lol
09:46:23 <EvanR> i have been not surprised but disappointed by every attempt at this so far
09:46:28 <EvilMachine> EvanR: : You’d be surprised. :) 
09:46:51 <EvanR> sql, mongo, redis, etc
09:46:53 <EvanR> files
09:46:59 <EvanR> "its just storage"
09:47:02 <EvilMachine> EvanR: That’s exactly why I want to try to make a better one.
09:47:23 <EvilMachine> It goes far further, but i had to leave out details. Sorry.
09:47:26 <prsteele> anyone know of promising libraries for data science? E.g. replicating any of pandas, scikit-learn, numpy, in Haskell? I'd be interested in constributing what I can
09:47:42 <prsteele> I can google for existence, I'm more looking for the 'promising' part
09:47:47 <ongy> EvanR: files? I think that depends on the file system
09:48:08 <EvanR> file being defined as a blob of bytes
09:48:15 <Big_G> How would you all recommend getting values from the command line? I've seend a few libraries like optParse but I'm not seeing many examples for multiple values instead of a single massive object
09:48:22 <EvanR> ... in storage
09:48:35 <sm> prsteele: a haskell data science umbrella project was recently announced, check recent reddit posts
09:48:43 <prsteele> sm: thanks
09:49:02 <EvilMachine> EvanR: A file is as a data structure of a specific schema of its MIME type. :)
09:49:19 <EvanR> gross
09:49:34 <EvanR> thats at least file x mime-type
09:49:40 <EvilMachine> x?
09:49:46 <EvanR> (file,mime-type)
09:49:59 <EvilMachine> EvanR: Did you mean… ×? :D
09:50:19 <EvanR> same thing!
09:51:06 <EvilMachine> Oh wait, 😄
09:51:25 <ongy> that one doesn't render for me
09:52:10 <monochrom> it's an emoji. U+1F604
09:54:38 <EvilMachine> ongy: It’s just a “SMILING FACE WITH OPEN MOUTH AND SMILING EYES” ;)
09:57:55 <EvanR> ggVGc: currently... just math
09:58:07 <zomg> EvilMachine: or diarrhea face if you ask apple or whoever it was? :p
10:02:03 <ggVGc> EvanR: I'd like to get into math studies again, but time..
10:02:08 <ggVGc> started writing some PureScript
10:02:12 <ggVGc> quite like it
10:02:32 <ggVGc> not sure how I feel about the type signatures of extensible records though
10:02:41 <ggVGc> haskell feels terse compared to purescript
10:02:48 <ggVGc> because of extensible records and Effects
10:03:07 <ggVGc> but not sure I'm doing things right
10:03:19 <ggVGc> kind of wish haskell gets Effects though
10:03:21 <ggVGc> rather than IO
10:03:26 <ggVGc> it's refreshing
10:03:54 <EvanR> agda is pretty terse
10:04:08 <EvanR> despite cramming more info in the types
10:05:44 <codedmart> Can I have a constraint on data? I have `data ToJSON a => ...` but it says to use DatatypeContexts which gives me a warning that it is deprecated and considered a misfeature.
10:06:19 <EvilMachine> ggVGc: Effects? I hobe they’re not as “behind my back” as side effects. I find monads already too obfuscated.
10:06:47 <prsteele> codedmart: you *could* always just have your functions that operate on your data have that constraint. That should be enough to make the compiler realize that constraint needs to be enforced
10:07:34 <pavonia> codedmart: Having constraints in data types is commonly considered an anti-pattern in Haskell
10:07:36 <codedmart> prsteele: Yeah you are right :)
10:08:37 <codedmart> Thanks guys I guess I was getting carried away.
10:08:39 <ggVGc> EvilMachine: it means instead of saying "IO", you say "does mutation", or "Prints to screen" or "does network"
10:08:44 <ggVGc> so you have finer control
10:08:48 <codedmart> Forgot I already have ToJSON on the functions.
10:09:08 <EvilMachine> ggVGc: Hmm…
10:09:41 <ggVGc> EvilMachine: what do you mean with monads being obfuscated?
10:09:54 <ggVGc> also, monads are not directly related to side effects
10:09:58 <ggVGc> they're just a tool to represent them
10:10:03 <ggVGc> rather, the IO monad is
10:10:20 <clueless_> can someone help me understand the time complexity http://lpaste.net/194989 of this script
10:10:22 <ggVGc> purescript Effects are also a monad. The Eff monad
10:10:43 <ggVGc> but the Eff monad is parameterised on the effects you want to do, and extensible because of extensible records
10:11:19 <prsteele> clueless_: you should be able to do that in linear time (with dynamic programming)
10:11:30 <ggVGc> I find it a bit awkward in haskell how it's so strict with most thigns, but then goes "all side effects are just IO"
10:11:33 <prsteele> clueless_: but as stated I believe it is exponential unless the compiler is clever
10:11:56 <prsteele> clueless_: see e.g. the exponential time of the naive Fibonacci implementation 
10:13:22 <infandum> I have an issue of "resource exhaustion (too many open files)" with this code (skeleton code here): http://pastebin.com/TRkXwGJ9
10:14:18 <infandum> From what I understand while looking at the code, the "output" function from Turtle should close it's resources because it uses "using", correct? Why would all files remain open?
10:14:23 <clueless_> prsteele: 4^n thinking in the worst case scenario sounds right? do you mind explaining more what you mean by the linear time part?
10:14:59 <prsteele> clueless_: sure. How would you do this by hand? If you wanted tetra 10, you'd start by computing tetra 5, then tetra 6, and so on
10:15:12 <prsteele> clueless_: if you wrote down these answers as you went, each next step is only summing 4 numbers
10:15:35 <mizu_no_oto_work> ggVGc: I'm not sure how much I like the effects in Eff, to be honest.  You can't currently write combinators that might have an effect in an input row but definitely have it in an output row, and the rows often muck up inference when you're using monad transformers.
10:17:34 <ashishnegi> hi.. i have slowly made my way through Haskell.. writing simple Tron game in it.. what should be my next steps ? after Monad / Monad transformers ?
10:17:53 <lpaste> prsteele pasted “tetra” at http://lpaste.net/195006
10:17:57 <mizu_no_oto_work> ashishnegi: well, what do you want to do?
10:18:05 <prsteele> clueless_: see the paste
10:19:27 <ashishnegi> mizu_no_oto_work: i would make some personal projects in Haskell, webapps.. but some of them i see are using "lens"/"arrows".. uptill now i had : Monoid -> Functor -> Applicative -> Monad -> M Transformers.. How does the chain grow next ?
10:20:23 <clueless_> prsteele: ahhhh, I had to write it down to see it, I see what you mean
10:21:08 <mizu_no_oto_work> Lenses are pretty simple.  At its heart, a lens is a getter and setter for immutable data types.
10:23:50 <mizu_no_oto_work> i.e. a lens is a `getter :: a -> b` and a `setter :: b -> a -> a`.  They're nice because you can compose them, which makes it easy to set stuff in deeply nested records.
10:24:56 <prsteele> clueless_: if you want to read about this search for "dynamic programming" or "memoization"
10:25:26 <EvilMachine> ggVGc: Monads make it hard to tell at a given moment, what magic they do between the lines. You have to look up or be aware of the type. I prefer it when you can tell solely from the code at that place, what it will do.
10:25:47 <ashishnegi> mizu_no_oto_work: sure.. is there any list of concepts in haskell ?
10:26:42 <ashishnegi> clueless_: are you trying to solve fibonacci problem ?
10:27:10 <prsteele> ashishnegi: there was a paste about, it was some recursion that has a similar form
10:27:51 <ashishnegi> clueless_: there is time : log(n), memory O(1) algorithm : search for matrix solution of fibonacci .. 
10:27:58 <ashishnegi> prsteele: ^^
10:28:34 <prsteele> ashishnegi: yup, I'm familiar with that solution. I'm confident this problem can be solved in a similar way. the question was originally just about analyzing the complexity of the given solution, however
10:29:14 <prsteele> ashishnegi: the log n solution is really beautiful, though  
10:29:30 <monochrom> For the time complexity, CLRS's "Master Theorem" has it.
10:29:30 <mizu_no_oto_work> I'm not sure.  At any rate, the lens library uses a trick from Twan van Laarhoven to have a lens be a single modify function instead of a pair of functions.  It also just uses type synonyms instead of hiding the underlying types, which allows you to compose lenses with just normal function composition.  It's worth taking a look at.
10:29:31 <ggVGc> mizu_no_oto_work: yeah I don't know if I like them either. But I find it interesting needing to think about them
10:29:38 <ggVGc> so, I think it's on the right track
10:29:57 <prsteele> the master theorem is really useful
10:30:21 <infandum> Does anyone here use Turtle?
10:31:33 <mizu_no_oto_work> ashishnegi: at any rate, have you looked at servant?
10:32:51 <ashishnegi> mizu_no_oto_work: no.. i have not. Any benefits over others ?
10:33:53 <mizu_no_oto_work> One thing that's nice about servant is that it ensures that a REST server and client both use the same API, at the type level.
10:34:57 <mizu_no_oto_work> There was a pretty good talk at Boston Haskell on servant that was probably recorded and put on youtube
10:37:01 <ashishnegi> prsteele: this is f (x) = f(x-1) + f(x-2) + f(x-3) + f(x-4) ;; matrix for this is `M = [[1 1 1 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]]` so f(n) = M^n [2 1 1 0]
10:37:27 * hackagebot fixed-vector 0.9.0.0 - Generic vectors with statically known size.  https://hackage.haskell.org/package/fixed-vector-0.9.0.0 (AlexeyKhudyakov)
10:38:19 <ashishnegi> mizu_no_oto_work: nice.. also can u next things after Monad Transformers in haskell in systematic order to learn more..
10:39:04 <ashishnegi> clueless_: see my comment to prsteele if you are interested in yet another faster result. :)
10:39:45 <ashishnegi> mizu_no_oto_work: i meant can u "suggest" next things to learn.
10:41:45 <mizu_no_oto_work> Really, I'd just suggest picking a simple project, and learning any additional topics you might need to do it
10:42:39 <mizu_no_oto_work> Like picking up enough of the lens library to use it, or picking up servant.
10:42:53 <mizu_no_oto_work> Though looking into Free monads wouldn't be a bad idea
10:43:51 <ashishnegi> mizu_no_oto_work: thanks
11:18:14 <infandum> mizu_no_oto_work: Is the Free Monad a continuation of the monad transformer?
11:18:35 <infandum> I'm not too familiar with them but I heard about how they rival them in some way
11:19:49 <monochrom> not continuation and not rival.
11:20:42 <infandum> So they don't really have anything to do with monad transformers?
11:20:42 <infandum>  
11:24:39 <johnw> no, they do not
11:25:09 <johnw> the only "rivalling" you might have heard is different ways of encoding DSLs, which has been spoken about in recent blog articles by ocharles
11:25:27 <johnw> but I think rival is much too strong a word; there are different approaches to embedding
11:25:42 <ocharles> Have I said rival?
11:25:45 <ocharles> It does seem like a strong word
11:25:54 <johnw> I don't think you ever used that word, ocharles 
11:25:58 <ocharles> oh :)
11:26:01 <ocharles> also, hi johnw !
11:26:03 <johnw> but I could see how someone reading it shallowly might have gotten that impression
11:26:09 <johnw> hi ocharles!!
11:26:11 <johnw> ltns
11:26:39 <ocharles> indeed
11:26:57 <infandum> oh...burn...
11:28:38 <dmwit> Sometimes I wonder to myself: suppose you knew the answer to this question with absolute certainty. How would your behavior differ based on the different possible answers to the question?
11:29:21 <dmwit> This is one of those times. How can labeling free monads as rivals to monad transformers or not affect anything?
11:32:19 <postpunkjustin> Is anyone aware of a way to compile Haskell to PHP? I'm asking on behalf of a colleague with... unconventional tastes.
11:33:28 <infandum> dmwit: It could help someone who doesn't understand a concept as a familiar anchor to compare to.
11:34:35 <sm> postpunkjustin: there's several php things on hackage, including a DDC php code generator
11:35:48 <sm> hs-language-php also generates php
11:37:28 * hackagebot math-functions 0.2.0.2 - Special functions and Chebyshev polynomials  https://hackage.haskell.org/package/math-functions-0.2.0.2 (AlexeyKhudyakov)
11:37:44 <sm> or does it. dunno
11:42:00 <ashishnegi> hi.. i want to use `concurrent-dns-cache` and `http-conduit-downloader` . i put them in `build-depends` in myproject.cabal .. stack is giving me tons of errors and finally `stack solver` game a big list of packages with version number hardcoded..
11:42:35 <ashishnegi> I did not had this problem earlier when i was using a lot of packages like `stm, aeson` etc.. why with these two packages ?
11:43:23 <dcoutts> ashishnegi: presumably because those two packages are not in stackage, but they do work, just not with the fixed versions of things in stackage
11:43:31 <dcoutts> and so the cabal solver can find a solution
11:44:02 <ashishnegi> so, what should i do ? put the `stack solver` in `stack.yaml` ?
11:44:20 <ashishnegi> dcoutts: stack solver result in stack.yaml ?
11:45:05 <dcoutts> sorry, I don't know how stack does it, but it's calling cabal, so it means it ought to work with cabal
11:45:22 <dcoutts> stack solver calls cabal to find a solution outside of stackage
11:46:21 <prsteele> I've heard of the term "cabal hell" but I don't think I've ever experienced it. Was it solved (or at least mostly solved) with sandboxes?
11:47:21 <dcoutts> prsteele: yes, if imperfectly
11:47:36 <prsteele> dcoutts: thanks
11:47:41 <dcoutts> as cabal sandboxes are not that easy to use, and involve quite a bit of rebuilding
11:47:45 <ashishnegi> i put the stack solver result in stack.yaml.. it is now bulding.. and then at `HsOpenSSL-0.11.1.1...` bits/HsOpenSSL.h:3:10: fatal error: 'openssl/asn1.h' file not found .. #include <openssl/asn1.h>.. :(
11:48:10 <dcoutts> prsteele: cabal-1.24 has a tech preview of a new mechanism to replace sandboxes and make it all a lot more convenient
11:48:29 <prsteele> dcoutts: I'll take a look, thanks
11:48:36 <dcoutts> prsteele: "cabal new-build", google for the blog posts
11:49:12 <dcoutts> ashishnegi: you need to install the system openssl dev package
11:49:26 <prsteele> "For example, you no longer need to compile packages with profiling ahead of time; just request profiling and new-build will rebuild all its dependencies with profiling automatically." Awesome!
11:49:40 <dcoutts> right :-)
11:50:01 <Henson> dcoutts: does the "stack" build system replace cabal with something that handles dependencies better?
11:50:21 <dcoutts> Henson: no, it's just a different way of choosing which deps to use
11:50:41 <prsteele> I thought stack was something like a curated set of packages known to work well with each other
11:50:50 <prsteele> stackage, rather
11:51:06 <dcoutts> right, stackage is that, and stack works more or less exclusively with that style
11:51:41 <dcoutts> stackage can also generate cabal.config files for use with cabal
11:52:14 <dcoutts> and longer term we expect to have cabal support package collections natively
11:52:23 <dcoutts> so that it can support both workflows
11:52:31 <dcoutts> support both workflows conveniently
11:53:12 <gummibears>  
11:54:01 <hoppfull> How can I make an infinite list like this: mylist seed = [f(seed),f(f(seed)),f(f(f(seed)))...etc] without a generator?
11:54:18 <prsteele> :t iterate  
11:54:19 <hoppfull> Are there generators in haskell?
11:54:20 <lambdabot> (a -> a) -> a -> [a]
11:54:31 <prsteele> > take 10 (iterate succ 0)
11:54:34 <dcoutts> prsteele: so if your package doesn't work with the fixed versions in a stackage snapshot then you're kind of on your own as ashishnegi just discovered
11:54:38 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
11:54:48 <dcoutts> prsteele: that's a case where you may want a solver-based workflow
11:54:49 <hoppfull> prsteele: thanks!
11:55:43 <ANTItorture> STOP PSYCHIATRY!!!!                               "I believe psychiatry epitomizes what's evil."
11:55:43 <ANTItorture> Psychiatrist Peter R. Breggin,
11:55:52 --- mode: ChanServ set +o dcoutts
11:57:07 --- mode: ChanServ set +q *!*@gateway/web/cgi-irc/kiwiirc.com/ip.80.246.136.229
11:57:35 --- mode: ChanServ set -o dcoutts
11:58:10 <dfeuer> dcoutts, why set mode +q?
11:58:22 <dcoutts> dfeuer: wasn't me :-)
11:58:24 <geekosaur> they didn't; I did
11:58:43 <dfeuer> geekosaur, why did you?
11:58:45 <geekosaur> (mostly because it was what I had queued..._)
11:58:59 <dfeuer> (Doesn't +q make it harder to kick people?)
11:59:50 --- mode: ChanServ set +o geekosaur
12:00:05 --- mode: geekosaur set +b *!*@*.com/ip.80.246.136.229
12:00:13 <geekosaur> apparently
12:00:29 <dfeuer> So ... why would you do that?
12:00:36 <pharaun> heh
12:01:10 <geekosaur> because I didn't know that and just found out when it didn
12:01:15 <geekosaur> t do the kick part?
12:01:34 --- mode: ChanServ set -q *!*@gateway/web/cgi-irc/kiwiirc.com/ip.80.246.136.229
12:01:45 --- kick: ANTItorture was kicked by geekosaur (ANTItorture)
12:01:55 * geekosaur needs better ops tooling
12:02:09 <dfeuer> Oh.
12:02:20 --- mode: geekosaur set -o geekosaur
12:02:30 * dfeuer knows nothing about such and just googled the meaning of the flag.
12:03:27 <ashishnegi> dcoutts: so finally i am getting.. http-conduit-downloader-1.0.25/Network/HTTP/Conduit/Downloader.hs:354..‘C.checkStatus’ is not a (visible) constructor field name.. This is fault of library. right ? Is it possible that something is pushed that does not build ?
12:06:00 <hansihe> fairly new, i know i am probably doing something suboptimal here, would any of you write this in any different way? https://gist.github.com/hansihe/31875f86c8ebd2075e9dcb7501f9631f
12:06:23 <hansihe> the anonymous function seems like a suboptimal way of doing that, currying or something maybe?
12:06:53 <shachaf> NumberArg <$> num <|> SymbolArg <$> sym
12:07:02 <geekosaur> ashishnegi, that error combined with stack not liking versions makes me think it's a very old library no longer compatible with reasonably current versions of its dependencies
12:07:05 <shachaf> Or if you prefer fmap NumberArg num <|> fmap SymbolArg sym or something.
12:07:50 <prsteele> hansihe: also `\r -> return $ NumberArg r` can be written as `return . NumberArg`
12:09:02 <hansihe> thanks, those are a lot better
12:10:44 <chreekat> ashishnegi: my guess is that cabal was able to find a build plan, but it is actually wrong due to incorrect/incomplete bounds on dependency versions.
12:11:11 <geekosaur> ashishnegi, so the github source looks to be a year newer. also the library has very few upper bounds so it's asserting that no future changes to its deps can affect it, which is clearly wrong
12:11:40 <geekosaur> (unfortunately there are devs who think that's the correct way to do things, because who cares about mere users?)
12:12:07 <hansihe> quick follow up, what would the <$> operator be called?
12:12:17 <hansihe> it is a bit ungoogleable
12:12:20 <prsteele> it is an infix copy of fmap  
12:12:49 <prsteele> f <$> x = fmap f x
12:12:54 <shachaf> hansihe: You can look it up on Hoogle.
12:12:56 <shachaf> @where hoogle
12:12:56 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
12:14:27 <ashishnegi> geekosaur: i see that i get errors in line 354, about `C.checkStatus`.. in github it is at line #408 https://github.com/bazqux/http-conduit-downloader/blob/master/Network/HTTP/Conduit/Downloader.hs#L408 Has he not published for some time ?
12:14:43 <geekosaur> last release was april 2015 per hackage
12:14:57 <geekosaur> last github project update was april 2016
12:19:10 <ashishnegi> geekosaur: this is my second project in haskell.. any recommendations on what i can do next ? 
12:20:19 <prsteele> you could manually add a dependency on the old library and add a stricter upper bound
12:20:48 <geekosaur> all I can suggest is find something other than http-client-downloader
12:21:06 <geekosaur> and, pay attention to the "Last updated" on the hackage page for a package
12:21:16 <geekosaur> @hackage http-client-downloader
12:21:16 <lambdabot> http://hackage.haskell.org/package/http-client-downloader
12:24:16 <ashishnegi> @geekosaur just to confirm/ask.. this is not stack issue.. right ? stack is doing best to resolve dependencies. but as not major/minor version of dependencies is specified for data-default, it is taking latest and compiling fails. ?
12:24:16 <lambdabot> Unknown command, try @list
12:24:24 <ashishnegi> geekosaur: ^^
12:28:02 <geekosaur> ashishnegi, it is not a stack issue
12:29:33 <geekosaur> http-client-downloader is poorly maintained and does not correctly indicate what versions of its dependencies are needed, so any solver is going to have problems with it.
12:31:02 <ashishnegi> geekosaur: cool.
12:31:26 <infandum> I stopped including uppper bounds, but that's because stack allows for that as the stack resolver itself is bound. It looks like the maintainer of that package doesn't have anything similar to that technique.
12:31:58 <geekosaur> yes, that works fine as long as you mandate that everyone who wants to use your packages use only stack ever
12:32:12 <infandum> That's true, and that's a big downside
12:32:24 <infandum> but in my defense, it's made life a lot easier
12:32:28 <infandum> for me
12:32:29 <infandum> haha
12:33:08 <prsteele> is the following guideline reasonable? I find library X in version a.b.c.d; do I just apply the upper bound < (a + 1).*.*.* ? I.e. I assume anything less than a major version bump can only improve the interface without breaking it?
12:33:13 <infandum> It would technically be possible to not use stack by just looking at the versions of the packages in that resolver, but that would be a huge burdon to put on the user
12:33:55 <infandum> prsteele: I think the second index is api changes, not just the first
12:34:08 <prsteele> infandum: okay, thanks
12:34:19 <prsteele> so not quite semver 
12:34:43 <infandum> prsteele: I think it's bigChanges.apiChanges.apiAdditionsAndNoApiChanges.bugfixes
12:34:53 <infandum> From what I remember, at least that's how I do it
12:34:57 <prsteele> https://wiki.haskell.org/Package_versioning_policy agrees with you
12:35:39 <MarLinn> infandum: how about an "unstackify" script that pulls out the versions from the resolver automatically? One step more for the build system, no hassle for the user
12:36:05 <ongy> when you use cabal init to annotate the first index isn't specified. I would increment if there is some major change in how the library is used
12:36:07 <infandum> MarLinn: That's a really good idea! It should be super easy to implement too
12:37:03 <infandum> MarLinn: I should tell both projects to put that in to both of their programs haha
12:37:20 <infandum> makes an easy bridge from one to the other depending on the user preference
12:37:30 * hackagebot learn-physics 0.6.0.2 - Haskell code for learning physics  https://hackage.haskell.org/package/learn-physics-0.6.0.2 (ScottWalck)
12:37:49 <ph88> hey guys, what do you think about using this instead of the standard prelude ?  http://tab.snarc.org/posts/haskell/2016-09-09-foundation.html
12:38:12 <ashishnegi> http-conduit-downloader even does not even build on local machine.. lol
12:38:32 <geekosaur> I don't think I'd waste more time on that library tbh
12:38:33 <ashishnegi> has anyone used any `web-crawler` haskell lib ? 
12:38:46 <ph88> geekosaur, which ?
12:38:48 <infandum> I think there was one called "spider" that worked
12:38:55 <geekosaur> http-client-downloader
12:38:58 <infandum> used it about two or more years ago though
12:39:56 <infandum> Oh my goodness this too many open files problem is driving me crazy
12:41:40 <ashishnegi> geekosaur: no package with that name.. do u mean http-client ?
12:41:53 <geekosaur> what?
12:41:58 <geekosaur> never mind
12:42:16 <infandum> I thought Control.Monad.Managed was supposed to close resources!
12:42:27 <geekosaur> what library have you been continuously trying to use that is not working? I am trying to say find something ekse
12:53:26 <ph88> geekosaur, did you try foundation ?
12:54:25 <geekosaur> no
12:55:59 <haskellnstuff> Is there a better way to write this: filter ((18 ==) . view age) . filter (("uid1234" ==) . view uid) $ users 
12:56:55 <prsteele> haskellnstuff: filter (\u -> view uid == "..." && view age u == 18) users ?
12:57:17 <prsteele> haskellnstuff: /s/view uid/view uid u 
12:59:18 <haskellnstuff> prsteele: Yeah, maybe.
13:00:55 <MarLinn> ph88: I like these preludes that approach the problem from a specific viewpoint instead of just shuffling the basics. ClassyPrelude uses classes; SubHask starts in CT; Numerical Prelude solves Num first; and Foundation starts with representations instead. But I still hope that maybe, one day, someone will find a good way to *combine* the approaches
13:02:44 <ocharles> Does anyone know why +RTS -p .prof files report things with entries of "0" ?
13:02:47 <ocharles> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#cost-centres-and-cost-centre-stacks for example even shows this
13:03:08 <MarcelineVQ> are they always CAF's?
13:03:34 <ashishnegi> is this `class Monad m => Connector m c | m -> c where` the old way of writing ? what is the equivalent new way ?
13:04:13 <ashishnegi> getting compiler error : `The associated type ‘ConnectionData’ mentions none of the type or kind variables of the class ‘Connector m c’`
13:04:13 <koz_> ashishnegi: What do you mean by 'the old way of writing'?
13:04:19 <ocharles> MarcelineVQ: no
13:04:29 <ocharles> For example, to give you two lines from this current profile:
13:04:33 <ashishnegi> koz_: in old ghc haskell way.. ?
13:04:36 <ocharles>                         mappend                                      Reactive.Banana.Prim.Types             1727     112319    0.5    0.1     0.5    0.1
13:04:36 <ocharles>                          runReaderWriterIOT                          Control.Monad.Trans.ReaderWriterIO     1729          0    0.0    0.0     0.0    0.0
13:04:59 <ocharles> So mappend is entered 112319 times, but runReaderWriterIOT is entered 0 times, within that mappend
13:05:12 <koz_> ashishnegi: Can you paste the code where this error is coming from?
13:05:38 <ashishnegi> class Monad m => Connector m c | m -> c where
13:05:38 <ashishnegi>   type ConnectionData
13:05:38 <ashishnegi>   newConnection :: ConnectionData -> m c
13:06:12 <ocharles> I guess haskell's "non-linear" evaluation is cropping up here though of course, mappend doesn't actually call runReaderWriterIOT at all directly, but presumably one of the values being mappended does
13:06:24 <ashishnegi> koz_: there is no extension at top of file in above code ^^
13:08:10 <MarLinn> ashishnegi: ConnectionData must mention m or c or both
13:10:47 <ashishnegi> MarLinn: it used to compile year ago.. i guess.. trying to build a lib
13:35:11 <dxtr> Hi, I would like to parse numbers in an interesting way. I would like to allow '-X', '-X%', '+X' and '+X%' in addition to X. Any idea what'd be the best approach?
13:35:25 <dxtr> I can't come up with anything that doesn't feel very clunky
13:37:10 <dxtr> The idea is obviously that I want to do different things with them
13:37:31 * hackagebot systemd 1.0.3 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-1.0.3 (erebe)
13:37:33 * hackagebot systemd 1.0.4 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-1.0.4 (erebe)
13:37:35 * hackagebot systemd 1.0.5 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-1.0.5 (erebe)
13:38:03 <lightly> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Generic.html this "Generic" is distinct from generics as in GHC.Generics right?
13:38:24 <glguy> correct
13:39:36 <ph88> glguy, have you used foundation ?
13:40:40 <hoppfull> map f somelist where f = (+ (1 + 1)) - is (1+1) re-evaluated for every value in the list or can haskell optimize this?
13:41:05 <glguy> ph88: I haven't.
13:41:18 <koz_> hoppfull: If you only use part of the list, then I guess it could just apply to that part?
13:41:21 <ph88> MarLinn, foundation solves Num too, no /
13:41:22 <ph88> ?
13:41:26 <c_wraith> hoppfull, test! 
13:41:33 <koz_> Like, if you compose that with take 10, it only needs to do it to those 10, theoretically.
13:41:41 <c_wraith> hoppfull, that's what Debug.Trace is for
13:41:57 <hoppfull> c_wraith: How? I can't ... interesting! Didn't know about Debug.Trace. Thanks for the advice!
13:42:26 <c_wraith> hoppfull, Debug.Trace is really useful in a lot of cases. :) 
13:42:57 <c_wraith> hoppfull, just.. remember it's for debugging, not production logging. :) 
13:43:16 <hoppfull> c_wraith: I will remember this! Maybe! ; )
13:43:47 <benzrf> hoppfull: i'm not an expert, but i wouldnt be surprised if the haskell standard doesnt prescribe whether 1 + 1 gets re-evaluated
13:43:53 <benzrf> but i'm willing to bet that ghc would optimize that
13:45:09 <c_wraith> I'm pretty sure the standard allows for call-by-name, but no implementation does that. :) 
13:45:44 <hoppfull> benzrf: I'm just so impressed by haskell so far I wondered if it would. In my case I write 4294967295 instead of (2^32-1). The latter is more elegant and I don't think you should need worry too much about low level optimization in haskell.
13:46:46 <c_wraith> @quote oasis
13:46:46 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
13:47:31 <ReinH_> if an expression is shared then it will be evaluated at most once.
13:47:37 <hoppfull> heh
13:47:40 <ReinH_> Is (1 + 1) is an expression. Is it shared?
13:47:47 <ReinH_> s/Is //
13:48:07 <hoppfull> That's so cool
13:48:56 <hoppfull> Do we have type providers in Haskell like in F#?
13:49:09 <hoppfull> I've googled but I couldn't find anything.
13:49:22 <c_wraith> no. in theory, you could do the job with template haskell 
13:49:59 <c_wraith> but without a standard IDE to integrate with, a lot of what they do isn't nearly as strongly motivated 
13:50:11 <hoppfull> c_wraith: Template haskell is a superset to haskell, right? With meta programming
13:50:45 <c_wraith> hoppfull, yes. think of it as using haskell to generate haskell code at compile time. 
13:50:51 <ReinH_> You can look at options for generating (say) JSON parsers and printers for data structures with aeson for an example of the "haskell way" to acomplish something like what type providers accomplish.
13:51:38 <ReinH_> It would certainly be possible to generate Haskell types and parsers given a sufficiently well described API specification, but I don't know of much effort into actually doing so
13:55:20 <hoppfull> I'm tempted to create (|>) x f = f x because I think it makes my code more readable but I fear I might be trying to force a square peg in a round hole. Do any of you use the forward function pipeline?
13:55:49 <lyxia> hoppfull: We call it Data.Function.&
13:56:01 <lyxia> It's a recent addition to base
13:56:08 <hpc> fun fact, it's also return for Cont
13:56:54 <hoppfull> lyxia: Cool!, thanks!
13:57:32 <rschnck> I'm having a hard time understanding the definition of (<*>) in the Applicative instance of ((->) e). I've pasted the code for it here: http://paste.ubuntu.com/23179524/
13:57:59 <Prutheus> Hello! I got a mandelbrot code from an website, copied it and it is this: https://bpaste.net/show/0ab925bd6a59 but for some reason i get errors i don't understand: https://bpaste.net/show/ed06016c6a95 can you help me pls?
13:58:08 <rschnck> And I don't have an intuition for why the Functor instance of ((->) e ) is just fmap = (.). I can see how it follows from the type signatures, but it's not intuitive to me.
13:58:41 <rschnck> So I'm wondering if someone could explain how the definition of (<*)>) makes sense :)
13:58:54 <ReinH_> rschnck: what is the type of (<*>), specialized to ((->) e)?
13:58:55 <MarLinn> ph88: SubHask does, too. And both Foundation and SubHask use something akin to the Classy approach. There are no hard borders
13:59:06 <rschnck> To be honest, I actually also only have a vague understanding of (->) in general :)
13:59:15 <ReinH_> :t (<*>)
13:59:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:59:22 <ReinH_> Set f = ((->) e)
13:59:25 <johnw> rschnck: the intuition for Functor of ((->) e) is that the resulting value from calling the value is what you're mapping your function over; it's composition because that's how you'd apply a function to the result
13:59:31 <johnw> calling the function*
13:59:44 <ph88> MarLinn, do you use any custom prelude for yourself ?
13:59:48 <ReinH_> It might help to know that ((->) a) b = a -> b, just like ((+) a) b = a + b
13:59:58 <hpc> rschnck: some of those things with (->) don't really have a good intuition that someone can just say "oh, it's the blargle in the shoofle blip blap" and it all makes sense
14:00:11 <hpc> rschnck: and you just have to stare at it until your brain can follow the types
14:00:19 <ReinH_> ReinH: so, knowing those things, what is the type of (<*>) specialized to f = ((->) e)?
14:00:28 <ReinH_> er, rschnck^
14:00:32 <hpc> haha
14:00:43 <rschnck> (->) e (a -> b) -> (->) e a -> (-> e) b = e -> (a -> b) -> e -> a -> e -> b?
14:01:19 <ReinH_> You've omitted some parens that you aren't allowed to omit.
14:01:20 <hpc> you need to parenthesize it more
14:01:53 <MarLinn> ph88: I use the ClassyPrelude because yesod uses it. Right now I'm more concerned with getting the job done than shifting my whole foundation (pun semi-intended)
14:01:55 <rschnck> As a start, is this right: ((->) e) (a -> b) -> ((->) e) a -> (-> e) b 
14:02:08 <hpc> yes
14:02:10 <ph88> MarLinn, what job ?
14:02:28 <hpc> except for the last one is ((->) e)
14:02:33 <rschnck> Ah, right.
14:02:54 <Prutheus> i think i converted wrongly from lhs to hs script ... have a look in line 24 pls
14:03:07 <rschnck> ((->) e) (a -> b) -> ((->) e) a -> ((->) e) b = (e -> (a->b)) -> (e -> a) -> (e -> b)?
14:03:07 <Prutheus> are the # correct? I dont think so
14:03:09 <ReinH_> a -> ((->) e) b -> c = a -> (e -> b) -> c, not a -> e -> b -> c
14:03:16 <ReinH_> Yes, correct
14:03:18 <hpc> rschnck: that one is right
14:03:24 <ReinH_> Now, we have: a -> (b -> c) = a -> b -> c
14:03:31 <ReinH_> so we can reparenthesize as:
14:03:33 <rschnck> Wait. I don't understand why it's correct, though.
14:03:36 <rschnck> And why the other one isn't.
14:03:38 <ReinH_> (e -> a -> b) -> (e -> a) -> (e -> b)
14:03:48 <ReinH_> because a -> (b -> c) -> d is not the same thing as a -> b -> c -> d
14:03:55 <rschnck> That I understand.
14:04:11 <rschnck> But I don't understand why ((->) e) a = (e -> a)
14:04:26 <shachaf> That is the definition of (e -> a)
14:04:27 <ReinH_> Because (->) is being used as a prefix type constructor
14:04:28 <hpc> ((->) e) a = (->) e a = (e -> a)
14:04:38 <rschnck> Oh :D
14:04:41 <hpc> currying
14:04:42 <rschnck> Currying explains it
14:04:44 <rschnck> Right :D
14:04:46 <ReinH_> ((->) e) a = (e -> a) and ((+) x) y = x + y
14:04:46 <hpc> :D
14:04:56 <ongy> why do you usually write it as ((->) e) and not (e -> )?
14:05:10 <ReinH_> Because (e ->) is a syntax error
14:05:40 <ongy> can I not do sections with infix type constructors?
14:06:02 <ReinH_> Correct.
14:06:12 <lyxia> Prutheus: the # look ok. you need to convert maxIter using fromIntegral as well
14:06:16 <rschnck> Okay, so how do I go from  (e -> (a->b)) -> (e 
14:06:16 <rschnck>                  -> a) -> (e -> b)?
14:06:20 <dfeuer> The fact that (e ->) is a syntax error makes me sad.
14:06:29 <rschnck> Oops, sorry. Stupid irssi. To the actual definition of (<*>).
14:06:30 <lyxia> Prutheus: and turn on TypeFamilies
14:06:30 <ReinH_> dfeuer: TypeOperatorSections would be a nice extension.
14:06:39 <ReinH_> rschnck: Try to write an implementation for that type
14:06:44 <Prutheus> lyxia: how to turn them on?
14:06:57 <hpc> ongy: because you can write sections in the other way which has an effect like flip
14:07:00 <dfeuer> ReinH, they'd be limited to the first arguments, presumably. But they should exist, in the standard.
14:07:09 <hpc> which causes some issues with computability of types that abuse it
14:07:09 <ReinH_> What can you do with an (e -> a -> b), an (e -> a), and an e to produce a b?
14:07:11 <lyxia> Prutheus: add {-# LANGUAGE TypeFamilies #-} at the top of your file
14:07:36 <ReinH_> go eab ea e = ?
14:07:42 <lyxia> Prutheus: oh actually your NoMonomorphismRestriction is not at the top of your file so it is ignored as well
14:08:03 <ReinH_> rschnck: ^
14:08:05 <lyxia> Prutheus: I think if you move it above the first import you won't need to convert maxIter
14:08:19 * dfeuer very much wishes that the standard did not include the monomorphism restriction.
14:08:22 <lyxia> Prutheus: not explicitly.
14:08:46 * dfeuer also wishes that the standard had either left out type defaulting altogether or made it flexible enough to actually be useful.
14:10:03 <Prutheus> lyxia: okay now i get the error: http://ix.io/1mWl
14:10:21 <ReinH_> rschnck: what can you do with the arguments you are given? You have two functions and a (non-function) value. What can you do with functions?
14:10:35 <dfeuer> BTW, GHC's ExtendedDefaultRules does *not* come anywhere near satisfying me.
14:10:55 <rschnck> Compose them... :C?
14:11:02 <ReinH_> rschnck: What else?
14:11:10 <dfeuer> I don't know what I want from defaulting, but it's not that.
14:11:20 <ReinH_> What are functions for?
14:11:21 <lyxia> Prutheus: The advice given by the error is sound here too. You can add {-# LANGUAGE FlexibleContexts #-}
14:11:33 <rschnck> Transforming an input?
14:11:33 <ReinH_> @src (.)
14:11:34 <lambdabot> (f . g) x = f (g x)
14:11:42 <ReinH_> composition is implemented by doing what with the functions?
14:11:46 <hpc> hint: ($)
14:12:11 <ReinH_> What do you do with functions and values?
14:12:15 <Prutheus> oh sorry should have read it correctly
14:12:18 <rschnck> Apply the values to the functions ;_;?
14:12:20 <dfeuer> Unrelated: Does anyone know of a situation where FlexibleContexts can lead to any real trouble? Certainly FlexibleInstances allows for instances with poor resolution; does FlexibleContexts have any similar problems?
14:12:21 <rschnck> Gosh I feel stupid
14:12:26 <ReinH_> You apply functions to values.
14:12:26 <rschnck> Oops
14:12:30 <rschnck> Yes.
14:12:32 <rschnck> I meant that.
14:12:34 <ReinH_> So try to do that.
14:12:42 <ReinH_> What can you apply to what?
14:12:53 <rschnck> For f (<*>) x ?
14:12:56 <ReinH_> for go
14:13:01 <ReinH_> go eab ea e = ???
14:13:09 <ReinH_> go :: (e -> a -> b) -> (e -> a) -> e -> b
14:13:12 <hpc> rschnck: another hint, your result goal is of type b, so first look for things with b in the type
14:13:28 <hpc> rschnck: and then ways to make them yield b
14:13:49 <ReinH_> What is the type of eab's argument? What is the type of ea's argument?
14:14:25 <ReinH_> (given f :: a -> b, the type of f's argument is `a'.)
14:14:58 <rschnck> go eab ea e = \e -> (eab ea)? 
14:15:08 <ReinH_> rschnck: Can you answer the question?
14:15:20 <ongy> have you done pure for ((->) e) yet? I want to ask something but not spoil it
14:16:07 <rschnck> Type of eab's argument is (e-> a). ea's argument is just e.
14:16:16 <ReinH_> The type of eab's argument is not (e -> a)
14:16:21 <rschnck> Well shit
14:16:24 <ReinH_> eab is of type (e -> a -> b), not ((e -> a) -> b)
14:16:34 <ReinH_> e -> a -> b = e -> (a -> b), not (e -> a) -> b
14:16:34 <rschnck> But you said argument. Not arguments.
14:16:38 <ReinH_> Yes, argument.
14:16:45 <ReinH_> Every function in Haskell takes exactly one argument.
14:16:46 <rschnck> Then it's just of type e.
14:16:51 <ReinH_> Some of them return other functions
14:16:51 <rschnck> Okay, currying, right. 
14:17:03 <ReinH_> Ok, so eab takes an e and gives a what? ea takes an e and gives a what?
14:17:16 <rschnck> eab takes an e and gives a function (a -> b). ea takes an e and gives an a.
14:17:31 <lyxia> Prutheus: well sometimes the advice of GHC is not so good. When it mentions UndecidableInstances it's probably a good idea not to listen to it.
14:17:37 <ReinH_> so we can say: go eab ea a = let ab = eab e; a = ea e in ?
14:17:42 <ReinH_> we now have an ab :: a -> b and an a :: a
14:17:47 <ReinH_> what can we do with them to get a b?
14:18:12 <rschnck> in ab a
14:18:15 <ReinH_> right
14:18:19 <ReinH_> so now inline ab and a
14:19:01 <ReinH_> ab a = ab (ea e) (inline a)
14:19:15 <ReinH_> ab (ea e) = (eab e) (ea e) (inline ab)
14:19:34 <ReinH_> go eab ea = (eab e) (ea e) 
14:19:37 <rschnck> Wait, what's this "inline" stuff.
14:19:46 <ph88> how can i get this function right?  https://paste.fedoraproject.org/428159/73887937/
14:19:54 <ReinH_> if a = ea e then anywhere I see an a, I can replace it with (ea e)
14:20:00 <ReinH_> This is equational reasoning
14:20:11 <rschnck> Oh. I call that a substitution :D 
14:20:17 <ReinH_> Sure.
14:20:33 <ReinH_> so go eab ea a = (eab e) (ea e)
14:20:46 <ReinH_> now, since (f x) y = f x y, go eab ea a = eab e (ea e)
14:20:50 <ReinH_> replace smoe names, and:
14:20:51 <rschnck> Okay, pause just a quick. Let me rederive that myself.
14:20:56 <rschnck> quick sec*
14:20:59 <ReinH_> go f g x = f x (g x)
14:21:02 <ReinH_> *some
14:21:03 <ongy> ph88: look at (=<<)
14:21:07 <hpc> this might make it easier to follow, as well: http://lpaste.net/7874279868098150400
14:21:35 <ReinH_> @djinn (e -> a -> b) -> (e -> a) -> e -> b
14:21:36 <lambdabot> f a b c = a c (b c)
14:22:08 <ongy> what's @djinn? does it try to create a function?
14:22:12 <ReinH_> Yes.
14:22:23 <ongy> @djinn a -> b -> c
14:22:23 <lambdabot> -- f cannot be realized.
14:22:26 <hpc> (that paste borrows from agda's "IDE" solver features)
14:22:50 <ongy> @djinn (a -> b) -> (b -> c) -> (a -> c)
14:22:50 <lambdabot> f a b c = b (a c)
14:23:08 <ReinH_> :t (.)
14:23:09 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:23:12 <ReinH_> @. djinn t (.)
14:23:12 <lambdabot> Plugin `compose' failed with: user error (Unknown command: "t")
14:23:19 <ReinH_> @. djinn type (.)
14:23:22 <lambdabot> f a b c = a (b c)
14:24:07 <ph88> ongy, what would be the (a -> m b)  part ?
14:24:18 <ongy> ph88: rec
14:24:38 <hpc> rschnck: don't feel too bad about this being hard, it's juuuuuuust barely enough stuff to keep track of at the same time that it can be overwhelming if you also have to deal with keeping the notation straight
14:24:57 <ph88> ongy, i thought that second function i made looked rather ulgy .. 
14:25:28 <ongy> oh, also I just noticed: you could put 'a <- txt' in the do block
14:25:51 <lyxia> ph88: you can drop v <- pure version and replace v with version in the next line
14:26:24 <rschnck> hpc: Yeah, thanks. I think it's probably hard at first and then it clicks and it's easy. 
14:26:53 <joe9> regarding haskell green threads or OS threads,  http://www.glfw.org/docs/latest/group__context.html#ga1c04dc242268f827290fe40aa1c91157 talks about having a current context per thread. Do they mean context per haskell  green thread or do I need one OS thread for each thread?
14:26:56 <ph88> lyxia, so it would be another argument to rec ?  why do i even have to make a seperate function here ... can't i use these arguments directly ?
14:27:14 <ongy> :t fmap `asAppliedTo` (undefined :: ((->) e))
14:27:17 <lambdabot> error:
14:27:17 <lambdabot>     • Expecting one more argument to ‘(->) e’
14:27:17 <lambdabot>       Expected a type, but ‘(->) e’ has kind ‘* -> *’
14:27:29 <joe9> when I mean "green thread", I mean the thread created with forkIO and not forkOS
14:27:29 <ongy> :t fmap `asAppliedTo` (undefined :: ((->) a b))
14:27:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:28:08 <shachaf> :t fmap @(->)
14:28:10 <lambdabot> error: parse error on input ‘->’
14:28:18 <shachaf> Hmm.
14:28:21 <shachaf> :t fmap @Maybe
14:28:21 <rschnck> Is this correct? http://paste.ubuntu.com/23179657/
14:28:23 <lambdabot> error:
14:28:23 <lambdabot>     Pattern syntax in expression context: fmap@Maybe
14:28:23 <lambdabot>     Did you mean to enable TypeApplications?
14:28:30 <shachaf> Oh, I thought that was on.
14:28:33 <shachaf> Maybe not for :t?
14:28:46 <lyxia> ph88: instead of writing  "v <- pure version ; return Ter { ... t_version = v }", write "return Ter { ... t_version = version }"
14:29:15 <dfeuer> shachaf, no, it seems not at all.
14:29:18 <dfeuer> Er..
14:29:28 <ph88> lyxia, why can't i do the same with txt ?
14:29:29 <dfeuer> Sorry, I confused myself. Let me check that correctly.
14:29:48 <lpaste> ongy pasted “for ph88” at http://lpaste.net/195287
14:29:50 <dfeuer> No, shachaf, no type applications for you.
14:30:00 <hpc> :t let f <*> x = \e -> (f e) (x e) in (<*>)
14:30:01 <lambdabot> (t2 -> t -> t1) -> (t2 -> t) -> t2 -> t1
14:30:15 <hpc> rschnck: looks right
14:30:17 <ph88> oh ye that looks better ongy 
14:30:18 <ongy> ph88: because of the type. txt has type (Gen Text) while Version has type [Version]
14:30:20 <rschnck> :DDD
14:30:21 <lyxia> ph88: version is a pure value. txt is not, it's a generator of Text.
14:30:24 <rschnck> I understand :D
14:30:33 <rschnck> Thanks, ReinH_ and hpc :)
14:31:00 <ReinH_> rschnck: It is! Now you just have to prove that it satisfies the Applicative laws. :)
14:31:27 * dfeuer still kind of thinks Tagged+PartialTypeSignatures may be better than TypeApplications.
14:31:28 <ph88> looks much cleaner this way
14:31:29 <ReinH_> :t let go f g x = f x (g x) = [(<*>), go]
14:31:32 <lambdabot> error:
14:31:32 <lambdabot>     parse error on input ‘=’
14:31:32 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
14:31:37 <rschnck> ReinH_: The reference I'm using says the only one that matters is "f `fmap` x === pure f <*> x". Is that correct?
14:31:41 <ReinH_> :t let go f g x = f x (g x) in [(<*>), go]
14:31:43 <rschnck> Well, it says the only "interesting" one is that one.
14:31:43 <lambdabot> [(t1 -> t -> b) -> (t1 -> t) -> t1 -> b]
14:31:52 <dfeuer> rschnck, no, that is not correct.
14:32:10 <HelloItsMe> hello.
14:32:30 <rschnck> HelloItsMe: Hello me :D
14:32:48 <HelloItsMe> hello you !
14:33:40 <HelloItsMe> i'm here because i want to deepen my english so talk to me please !!
14:33:43 <hpc> dfeuer: eh?
14:34:06 <mauke> HelloItsMe: this channel is for haskell
14:34:20 <hpc> HelloItsMe: you should look for a channel dedicated to learning english
14:34:33 <HelloItsMe> oh ok..
14:34:45 <HelloItsMe> what is haskell ?
14:34:49 <dfeuer> hpc, I'm saying that the fmap=(pure f <*>) law is not the only interesting one.
14:34:59 <hpc> ah, k
14:35:05 <hpc> HelloItsMe: it's a programming language
14:35:16 <HelloItsMe> ohhh ok i'm not in the right channel lol
14:35:16 <rschnck> hpc: it's a *cool* programming language :)
14:35:32 <HelloItsMe> thanks bye !
14:35:38 <hpc> HelloItsMe: if you do find yourself wanting to learn it feel free to stick around, and we have some other... dang
14:36:29 <hpc> wanted to mention the non-english channels
14:37:32 * hackagebot arithmoi 0.4.3.0 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  https://hackage.haskell.org/package/arithmoi-0.4.3.0 (Bodigrim)
14:37:34 * hackagebot gdo 0.1.2 - recursive atomic build system  https://hackage.haskell.org/package/gdo-0.1.2 (seppeljordan)
14:37:59 <dfeuer> hpc, I think probably the most interesting may be the associative law (.) <$> u <*> v <*> w = u <*> (v <*> w), but the interchange law occasionally shows up.
14:39:35 <johnw> dfeuer: in much of the proofs that I do involving applicatives, the associative law is the one I use the least :)
14:39:48 <dfeuer> johnw, interesting.
14:40:08 <johnw> it's just a bit too specific
14:40:14 <johnw> rarely does my goal have the form needed to apply it
14:40:35 <joe9> hpc, any thoughts on haskell threads vs glfw/opengl threads? I am creating 1 window using forkIO and letting that window be managed by that thread.
14:40:48 <joe9> hpc, would that work? or, would i need a forkOS thread per window
14:41:59 <kamog> hello, can I get ghci to tell me documentation comments?
14:42:00 <siwica> I am trying hack for the first time and tried to add some build-depends to my cabal file. When omitting the version number hack complains that 'stack configuration has no specified version'. How can I make stack install he most recent version of the package without asking?
14:42:25 <hpc> joe9: not sure, haven't had to deal with it
14:42:34 <glguy> siwica: stack solver can help with that
14:42:37 <dfeuer> johnw, isn't associativity the one that produces the properties of *> and <*?
14:43:03 <hpc> personally, i would try it with whatever is easiest and see if it works consistently
14:43:24 <hpc> and then if it doesn't work, mess around with it until it does or ask here / in -game
14:43:27 <johnw> dfeuer: dunno, give me a theorem and I could find out :)
14:43:28 <joe9> hpc, when testing, everything is fine with a forkIO thread.
14:43:38 <hpc> it's probably fine then
14:43:49 <joe9> hpc, -game is a good idea. Thanks
14:43:56 <siwica> glguy: that yields 'cabal: failed to parse output of 'ghc-pkg dump'
14:44:22 <dfeuer> johnw, how about   fmap f u *> v = u *> v ?
14:45:17 <glguy> siwica: your cabal executable might be outdated, what version is it? cabal --version
14:46:18 <ph88> i'm not sure why fmap works here but <$> doesn't  https://paste.fedoraproject.org/428166/14738895/
14:46:21 <rschnck> ReinH_: First law...I think? http://paste.ubuntu.com/23179702/
14:46:39 <ph88> should i write <$> $   ?
14:46:41 <johnw> dfeuer: give me a few minutes
14:47:00 <agocorona_> forkIO the last morp of goto
14:47:05 <siwica> glguy: 1.20.0.3
14:47:08 <ph88> both options look ugly, and i don't want to use parenthesis
14:47:59 <siwica> glguy: just reinstalled haskell-plattform and ubuntu. Nothing done since except opening a hack sandbox
14:48:20 <dfeuer> Ping wrengr 
14:48:23 <glguy> siwica: Your cabal is too old for the version of GHC you're using
14:48:51 <wrengr> dfeuer: pong
14:48:53 <ongy> :t (*>)
14:48:55 <lambdabot> Applicative f => f a -> f b -> f b
14:48:57 <agocorona_> threads are like espaguetis
14:49:04 <dfeuer> siwica, that's usually best fixed by getting a new cabal binary. Trying to bootstrap your way up will be painful.
14:49:07 <wrengr> :q
14:49:31 <glguy> siwica: If you're going to use packages from your package manager you should mostly stick to only using packages from your package manager
14:49:45 <glguy> as far as Haskell development goes
14:50:01 <verement> ph88: ($) has lower precedence than (<$>)
14:50:06 <siwica> I am really new to all this. 
14:50:41 <siwica> Ubuntu only seems to have ghc 7.6.3 packaged 
14:51:09 <siwica> Yet in the hack sandbox hack installed and uses ghc 8.0
14:51:22 <dfeuer> wrengr, you have PM.
14:51:23 <johnw> dfeuer: you don't even need applicative laws for that theorem, only fmap composition
14:51:32 <johnw> dfeuer: https://gist.github.com/170ab95ad9315e3d752ddcd07048ef8e
14:51:33 <glguy> siwica: hack sandbox hack?
14:51:44 <siwica> also only 1.20.0.3 is packaged with ubuntu
14:52:22 <glguy> If you're using stack to install GHC you can uninstall the one from Ubuntu
14:52:32 <dfeuer> johnw, oh, sorry, got confused. FYI, proof by coq tactics is not the best way to communicate....
14:52:33 <glguy> You can use stack to install an up-to-date cabal-install, too
14:52:45 <glguy> stack install --resolver nightly cabal-install
14:52:56 <johnw> dfeuer: you didn't ask for a particular kind of proof; I've shown you that the proof exists
14:53:08 <siwica> I meant to say 'stack' not hack...
14:53:16 <siwica> sorry!
14:56:15 <oherrala> glguy: lts-7 was just released so probably no need to use nightly for a while :)
14:58:09 <ReinH_> rename simpl to "presto" and reflexivity to "change-o" and you'll have a lot more fun reading Coq proofs.
14:59:29 <johnw> or rewrite to change-o and reflexivity to same-o
15:00:34 <ph88> what does this error mean?  https://paste.fedoraproject.org/428169/89040114/
15:01:21 <ph88> i'm trying to generate Text without newlines   Gen Text
15:02:40 <verement> ph88: are you using OverloadedStrings?
15:02:51 <ph88> ya
15:02:52 <glguy> ph88: It means you're using OverloadedStrings and need a type signature on "\r\n", most likely
15:02:58 <glguy> :t notElem
15:03:00 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
15:03:26 <ph88> what type do i need?
15:03:37 <glguy> ("\r\n"::String) would be good
15:03:55 <ph88> are the parenthesis required ?
15:04:30 <glguy> Only as much as you want it to type-check
15:04:42 <ph88> hhmm ye it's a parse error without
15:05:36 <adam__> I'm coming back to haskell after a bit.  I've written a function applyMap so that e.g. applyMap (+1) [1,2,3] = [[2,2,3],[1,3,3],[1,2,4]] (it turns a map into a 'derivation').  Is there a name for this pattern?
15:06:10 <johnw> dfeuer: what it comes down to is that fmap (const id) (fmap k u) = fmap const id (which is what your theorem unfolds to, by definition; the applicative part adds nothing interesting)
15:06:56 <johnw> (sorry, missed parens there)
15:07:03 <c_wraith> adam__, not a common one. at least not that I've found in my searching for anything existing that does that. 
15:07:45 <c_wraith> adam__, (for what it's worth, holesOf in lens is a kind of generalization of that pattern) 
15:08:02 <dfeuer> johnw, yeah, I see that.
15:08:22 <adam__> c_wraith interesting, thanks
15:08:54 <ReinH_> johnw: heh
15:10:21 <ph88> with QuickCheck i can generate a certain value with pure, like  pure "foo"  .. how can i make this case-insensitive ?
15:11:18 <ggVGc> I haven't figured out how to use quickcheck yet
15:12:10 <ggVGc> it seems to me a fairly small subset of functions can be tested using it
15:12:16 <ggVGc> but I also think it's lack of imagination of my part :(
15:12:40 <johnw> ggVGc: quickcheck is useful any time where randomly generating data might yield interesting edge cases
15:12:52 <johnw> it's not just about "specifying math-like equational properties"
15:13:05 <johnw> that's what I thought at first too, and so I found myself hard-pressed to make use of it as well
15:13:19 <ggVGc> right, that's what I feel. Like I'm missing some imagination
15:13:25 <johnw> but nowadays I almost always use it, for its capacity to generate candidate data and then apply some expression to that data, looking for failure cases
15:13:26 <ggVGc> I think I need to see it in action some more
15:14:07 <johnw> any time you call the same function more than once in a test with different inputs, think: can I benefit from randomizing these inputs and automatically running 100 such cases?  If so, then you're asking for QuickCheck
15:14:56 <c_wraith> ggVGc, one thing I've done in the past is use quickcheck to generate a sequence of operations to ensure that supposed invariants are actually maintained over that sequence of operations 
15:15:05 <joeyh> I'm trying to use fast-logger, and my code compiles, but no matter how many messages I send to the logger, it never seems to output them.
15:15:17 <joeyh> is there an example of using fast-logger someplace?
15:15:23 <johnw> joeyh: my logging package uses it
15:15:32 <johnw> and I know for a fact that it outputs log messages
15:15:59 <johnw> @hackage loggin
15:16:00 <lambdabot> http://hackage.haskell.org/package/loggin
15:16:01 <johnw> @hackage logging
15:16:01 <lambdabot> http://hackage.haskell.org/package/logging
15:16:11 <joeyh> it was working using LoggerSet, but I switched to TimedFastLogger and no go
15:16:13 <johnw> hmm.. it should check that it actually exists before providing a link...
15:16:36 <joeyh> perhaps I should just use your package :)
15:16:46 <jchia_> I'm trying to get a deeper intuition on State/StateT, Particularly, I think I have a good idea of the s in "State s a" but not so much on a. I know it's the "return value", but in some cases where I might use a StateT, a seems unnecessary as I just want to pass around some state information that I can read or write. At first I thought maybe a is the action of a state transition in a state machine, but I don't think that's right. The main question I want to a
15:16:53 <johnw> logging is for application code that can afford to just rely on mutable state in IO
15:17:02 <johnw> it's not meant for libraries, or where abstraction is needed
15:17:42 <david_> Hi all! How do I change my GHC version with stack?
15:17:52 <johnw> jchia_: a is the output value computed during your state transition
15:18:02 <ph88> david_, i think there is something in the stack.yaml file about it
15:18:09 <joeyh> hmm, logger uses LoggerSet, like I was before
15:18:27 <johnw> jchia_: it's not required; if you fix a to (), then State s is just a function from state to state
15:18:33 <ph88> david_, i think it's the resolver
15:18:37 <johnw> (State s (), that is)
15:18:38 <agocorona_> jchia_:  think on s  as a hidden parameter (that is what really is)
15:18:58 <johnw> joeyh: so maybe the question then is really about TimedFastLogger
15:19:55 <joeyh> sendLogger l s = l (\t -> toLogStr t <> toLogStr s) :: TimedFastLogger -> String -> IO ()
15:20:07 <joeyh> seems like that should just work (and I also tried including my own newline)
15:22:12 <ph88> david_, which version of ghc you want ?
15:22:18 <jchia_> I have a case where I'm using a StateT of IO. The StateT is for reading and writing state info while I do things in IO. It seems that I don't have to involve a in this case. Does this sound right?
15:22:56 <agocorona_> jchia_:  that is right IMHO
15:23:00 <ph88> david_, try lts-7.0 for ghc-8.0.1    https://www.stackage.org/lts-7.0
15:24:16 <jchia_> agocorona: Thanks
15:24:35 <agocorona_> jchia_:  but in the monadic expression each computation return different values of different types. you can not accomodate them in the state
15:25:23 <agocorona_> since the state has a fixed type
15:26:06 <ph88> david_, maybe use  stack setup  to use the new resolver .. i'm not sure what is the right command
15:26:23 <jchia_> agocorona_: Not sure what you mean. Do you have a short concrete example?
15:27:47 <ph88> johnw, since you used quickcheck a lot do you know how to generate a particular string with mixed lower and upper case ?
15:28:38 <johnw> ph88: sure; but what do you mean by "particular"?
15:29:14 <ph88> johnw, string literal such as "foo" .. and then make random variations like "Foo", "fOo", "fOO" and so on ..
15:29:16 <joeyh> oh wow, it's a weird bug! The fast-logger works fine until after a threadDelay
15:29:25 <agocorona_> jchia_: from "StateT s m a"      s and m  are fixed.  a can adopt different types along the monadic computation
15:33:18 <polopolo> Hi! could someone help me implementing a binary search in haskell? Im learning and im kinda stucked http://lpaste.net/195363
15:33:38 <johnw> ph88: so, you would generalize this and create a function to do this, but: liftA2 (:) (frequency [(1, 'F'), (1, 'f')]) (liftA2 (frequency [(1, 'O'), (1, 'o')]) ((:[]) <$> frequency [(1, 'O'), (1, 'o')])
15:34:01 <johnw> abstract the pattern, call it "stringCases :: String -> Gen String"
15:34:39 <agocorona_> jchia_: try to practice and you will realize that you both s and a
15:34:51 <agocorona_> you need boot s and a
15:34:56 <ph88> ok thx johnw , i will try it tomorrow though :)
15:34:58 <jchia_> agocorona_: OK, I thought I meant that it was a problem (at 06:24:13 AM) when you used 'but', but I think you were just pointing out a detail
15:35:12 <johnw> btw, frequency [(1, 'F'), (1, 'f')] is the same as elements "Ff"
15:35:50 <dmwit_> So, with cabal's experimental new-* interface, is there a way to use cabal's fancy `Paths_foo` module?
15:36:18 <geppettodivacin> Are Haskell devs as rare outside the US as they are inside of it? Or, alternatively, do American Haskell devs just hide really well?
15:36:30 <ph88> johnw, so basically i get a lowercase version, uppercase version, then zip them to get list of 2 elements ..
15:36:33 <dmwit> In `cabal new-repl`, it doesn't seem like the files are "installed" in the place that `getDataFileName` is looking.
15:36:46 <johnw> ph88: yeah, pretty much
15:36:51 <johnw> ph88: let me try actually writing this
15:37:33 * hackagebot recursion-schemes 5 - Generalized bananas, lenses and barbed wire  https://hackage.haskell.org/package/recursion-schemes-5 (EricMertens)
15:37:56 <agocorona_> jchia_:  yes it's a detail
15:38:14 <dmwit> > zipWith (\cond -> if cond then toLower else toUpper) [False, True, True] "foo"
15:38:16 <lambdabot>  "Foo"
15:38:23 <johnw> ph88: yes, this does exactly what you asked for: https://gist.github.com/4b83178282496244dea970202fdde507
15:38:38 <ph88> zipWith (\a b -> [a,b]) (strToUpper str) (strToLower str) .. (i'm making up function names here) .. then i should get like ["Ff", "Oo", "Oo"]
15:38:43 <johnw> golf that to your hearts contents
15:38:57 <siwica> I installed haskell-plattform with Ubuntu, giving me ghc 7.6.3 and cabal 1.20.0.3. I now need to install a package that requires ghc 8.x and tried that in a stack project. Compiler version is ok there but 'stack solver' fails with "cabal: failed to parse output of 'ghc-pkg dump'" because the cabal version is seemingly too old for the version of ghc.
15:39:20 <dmwit> :t traverse (\char -> elements [toLower char, toUpper char])
15:39:23 <lambdabot> Traversable t => t Char -> Gen (t Char)
15:39:24 <siwica> How do I resolve this when I want to stick to my Ubuntu package (and to its version of cabal)?
15:39:35 <dmwit> johnw: My heart is now content.
15:39:49 <ph88> johnw, oh wow that looks so concise .. that was unexpected at first glace i thought it was wrong
15:39:59 <johnw> indeed, dmwit has it right
15:40:37 <johnw> stringCases = traverse (elements . liftA2 (:) toLower (return . toUpper))
15:40:54 <johnw> err, s/return/pure
15:41:21 <agocorona_> siwica: in theory you do not need haskell platform. if you start from a clean box, stack should install. that includes a version of cabal. An I right?
15:41:25 <johnw> the pointful version is better
15:41:39 <ph88> johnw, you mean the one from your paste ?
15:41:42 <johnw> stringCases = traverse (\ch -> elements [toLower ch, toUpper ch])
15:41:46 <johnw> that one, from dmwit
15:42:07 <johnw> "traverse the string, replacing each character with a generator selecting either a lower or upper case version of that character"
15:42:30 <johnw> "then compose the result into a generator yielding a string of such selections of the same length"
15:42:54 <ph88> ok but i don't want a result like [Gen a, Gen a, Gen a]  but Gen [a] with a being upper or lower case
15:43:09 <johnw> yes, that's what it will be
15:43:15 <dmwit> ph88: Check out the type that lambdabot spit out above. I think it will make you smile.
15:43:17 <ph88> if you say "replace each character with a generator"  ^^
15:43:18 <ph88> ah ok
15:43:19 <johnw> λ> sample' (stringCases "foo")
15:43:19 <johnw> ["FOo","FOo","FOo","foo","foO","foO","foO","fOO","fOO","foo","FOo"]
15:43:20 <shachaf> i,i traverse (elements . sequence [toLower, toUpper])
15:43:26 <polopolo> can someone help me revise and see whats wrong with my binary search? http://lpaste.net/195363
15:43:38 <johnw> shachaf: oohh
15:43:50 <ph88> johnw, that sample' functino where did you get it ?
15:43:54 <johnw> shachaf wins the golf master trophy today
15:43:59 <ph88> lol
15:44:08 <johnw> ph88: sample' is from Test.QuickCheck
15:44:20 <johnw> generators are really very simple things to work with
15:44:28 <ph88> ups sorry was searching the wrong doc page
15:44:36 <johnw> until you get into the arcane realm of shrinking, that is
15:44:37 <dmwit> polopolo: There is much wrong with your search.
15:45:44 <ph88> johnw, why use shrinking ?
15:46:00 <johnw> shrinking lets you find the minimal test cases
15:46:07 <dmwit> polopolo: 1. You can't print stuff in the middle of a pure function. Don't try. 2. Presumably you mean `Int` rather than `int`, though even after that change the type your propose leaves me baffled. 3. On `Int`, you should use `div` instead of `(/)`. 4. List indexing is done like `list !! index`, not `list[index]`.
15:46:23 <johnw> QuickCheck uses it to avoid just giving you the first random case that caused a failure; it tries to narrow it down to the smallest possible case
15:46:32 <agocorona_> polopolo:  the middle point is not (f-l)/2 + f ?
15:46:35 <dmwit> polopolo: ...and probably a fair bit more. I'm not sure what you're hoping `(f+l)/2 if blah then blah else blah` is going to do, to be honest.
15:46:41 <johnw> often, it can find the underlying edge case being triggered this way
15:46:50 <johnw> but if you write a custom generator, you have to teach it how to shrink
15:47:10 <johnw> but it's ok to ignore shrinking, it's a quality of report kind of thing
15:47:10 <ph88> sounds horrible :/
15:47:16 <ph88> ok ok
15:47:25 <agocorona_> sorry (l-f)/2+ f
15:48:18 <ph88> thanks for the help
15:48:37 <dmwit> ph88: Usually for lists it's not that bad. A halfway decent shrink function for lists is to propose the empty list, just the first element, just the first half, or all but the last element.
15:48:57 <siwica> agocorona_: How do I find this out?
15:49:43 <polopolo> dmwit: http://lpaste.net/195375 I know it is REALLY wrong, the thing is that Im trying to base myself of this script
15:51:09 <agocorona_> siwica: just install stack https://docs.haskellstack.org/en/stable/README/   and then   cd project; stack build
15:51:26 <agocorona_> works most of the time
15:51:52 <dmwit> polopolo: Perhaps you would prefer a type like `Eq a => [a] -> a -> Maybe Int`.
15:52:36 <dmwit> polopolo: But really for it to make sense to use binary search rather than linear search, you want to avoid linked lists. So then you would want that `[a]` to be an `Array a` or `Vector a` or similar... whether you want to make that change in this iteration or not is up to you of course.
15:55:09 <polopolo> dmwit: whats the difference with [a] and Array a?
15:56:08 <dmwit> `[a]` is best thought of as a linked list: each node contains a pointer to the value at that node and a pointer to the next node.
15:56:24 <dmwit> `Array a` is a contiguous chunk of pointers to values.
15:57:02 <siwica`> did anyone respond to me? I am havign connection issues.
15:57:04 <dmwit> The upshot is that indexing into a linked list requires following as many pointers as your index; whereas indexing into an array costs one addition and following one pointer.
15:58:31 <MarLinn> siwica`: <agocorona_> siwica: just install stack https://docs.haskellstack.org/en/stable/README/   and then   cd project; stack build
15:59:20 <MarLinn> @where logs siwica`: for future reference
15:59:21 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
16:01:38 <siwica`> MarLinn: That's what I did
16:02:42 <siwica`> But I then get 'foo-package' needed (-any), stack configuration has no specified version (latest applicable is 0.5.0)'
16:02:43 <siwica`>  
16:02:49 <MarLinn> siwica`: I wasn't the one who wrote that, I just copied. I don't even use stack. Sry.
16:02:51 <siwica`> You may also want to try the 'stack solver' command
16:02:52 <siwica`>  
16:20:03 <siwica`> Can I install a separate cabal in stack?
16:21:20 * sm ponders this
16:28:28 <fr33domlover> siwica`, `stack build cabal-install` ?
16:37:35 * hackagebot keysafe 0.20160914 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20160914 (JoeyHess)
16:54:32 <johnw> joeyh: I find it amusing when software uses the word "secure", since it hasn't withstood years of scrutiny and determined attack yet
16:54:49 <johnw> so really it should be "back up a secret key hopefully securely to the cloud"
17:08:58 <greymalkin> nix+cabal -- I'm in love.
17:09:28 <dcoutts> greymalkin: have you tried cabal new-build? it's based on the nix ideas (but isn't actually integrated with nix)
17:10:06 <mniip> where's merijn when you need him
17:10:33 <greymalkin> dcoutts: No, and unless it also manages to cover external, non-haskell dependencies, I probably won't (at least not for a long while)
17:11:17 <dcoutts> greymalkin: interesting data point, thanks
17:12:07 <dcoutts> greymalkin: we were discussing this issue at a recent hackathon, how to use system libs etc on different platforms, e.g. nix packages, debs, rpms etc, how to find out what's provided by what packages
17:14:38 <greymalkin> dcoutts: I'm in a bit of the "golden hammer" phase of nix at this point -- but after trawling through cabal conflicts, and then switching systems and realizing half the libraries that some of my personal tools used weren't installed, and I had to try to remember what they were... well.
17:16:12 <greymalkin> Now the programs that I wrote for scanning indicate that they require saneBackends to be installed; and nix takes care of installing that before building my silly scan-document program.
17:17:48 <greymalkin> The friction that I used to feel when considering whether it's worth the time to let the sandbox for a library build out, or to just keep it internal to the tool is much, much lower.
17:24:30 <haskellnstuff> With opt-parse applicative can I specify a default value for a required argument that is based on another required argument
17:26:26 <greymalkin> haskellnstuff: Wouldn't that make the argument technically optional?
17:26:45 <greymalkin> Something that is computed later, but that if it cannot be computed, that becomes the error...
17:26:50 <haskellnstuff> I want to have ths command line syntax: myprog -i somefile.txt    which would then cause -o to become "somefileModified.txt"
17:27:20 <haskellnstuff> Yeah, I suppose it would always be optional
17:27:45 <greymalkin> I would think it more intuitive that the default output be stdout.
17:27:58 <greymalkin> But... that's just me. I'm full of opinions this evening.
17:28:14 <haskellnstuff> greymalkin: Yeah, I should probably just change the input to be stdin by default and then output to stdout by default
17:29:03 <haskellnstuff> but it's quicker if I just could do: myprog somefile.txt and then that generates my output file at "somefilemodified.txt"
17:50:43 <dmwit> haskellnstuff: It's probably simplest to do that as a postprocessing path.
17:51:35 <dmwit> haskellnstuff: data Options = Options { inputFile :: FilePath, outputFile_ :: Maybe FilePath }; outputFile opts = case outputFile_ opts of Nothing -> modify (inputFile opts); Just fp -> fp
18:03:21 <dcoutts_> greymalkin: I certainly wouldn't want to disuade you from nix, I think it's a great system. That's why we're stealing the nix idea to use in cabal.
18:03:52 <dcoutts_> proper integration with system packages remains a TODO for now
18:04:07 <greymalkin> :)  Probably one of the few times that haskell has imported an idea (rather than export) ...
18:04:41 <greymalkin> dcoutts_: Try being a maintainer for a few weeks, and you'll be very very happy to have a well-established tool for it.
18:05:09 <dcoutts_> greymalkin: you mean the cabal2nix tool?
18:05:31 <acne> Hi
18:05:32 <acne> :D
18:06:01 <greymalkin> I meant nix; cabal2nix is a good start on one facet of overal system package maintenance.
18:06:37 <acne> Hi I am in High School and need someone willing to try something new for FREE?
18:06:53 <acne> Is that ok?
18:09:32 <tnks> I have this tagless encoding with type classes, building up constraints MTL style.  But I want to have two interpretations of the same expression, say A and B to calculate C.
18:09:56 <tnks> I can make a function A->B->C, but then I have to pass the expression to that function twice.
18:10:27 <tnks> which seems like an annoyance for users.
18:10:43 <tnks> not to mention the types don't make clear that the same parameter should be passed twice.
18:11:19 <tnks> Is there a way to get an abstraction I'm looking for?  Or is this a known problem people have beat upon with no great solution?
18:12:39 <acne> 8:06:20 PMacneHi I am in High School and need someone willing to try something new for FREE? 
18:12:39 <acne> 8:06:29 PMacneIs that ok?
18:13:17 <dcoutts_> acne: this is Haskell related right?
18:14:19 <dcoutts_> if so, you need to write less like a spammer ("FREE") and tell people what you're doing, you'll not get people volunteering for unknown things
18:15:14 --- mode: ChanServ set +o dcoutts
18:17:04 --- mode: ChanServ set -o dcoutts
18:25:56 <stanrifkin> where can i download "WinHugs-Sep2006.exe"?
18:26:40 <mniip> are you sure you want to use 10 year old software
18:27:25 <stanrifkin> i've got a book here and it uses hugs - so why not?
18:27:49 <Welkin> don't believe everything you read in a book!
18:27:52 <shachaf> You should use GHC instead.
18:28:17 <shachaf> It's probably an old book, so at the time it was written Hugs had more advantages over GHC than it does today.
18:28:32 <Welkin> lol
18:28:39 <Welkin> in haskell there is pretty much only ghc
18:28:46 <mniip> well
18:28:52 <mniip> starting from like 2010 anyway
18:28:59 <shachaf> Which book is it?
18:29:06 <dcoutts_> stanrifkin: it'd be perfectly ok to use hugs and the book for learning, but as soon as you move beyond the book you'll have to switch
18:29:54 <dcoutts_> stanrifkin: but using the exact same one your book uses may make it easier to follow along
18:30:24 <dcoutts_> stanrifkin: https://www.haskell.org/hugs/pages/downloading.htm
18:30:29 <stanrifkin> "Haskell, The Craft of Functional Programming" from 1999 ok old the new version cost 70 Euro instead of 1...
18:30:47 <stanrifkin> dcoutts: its down 
18:30:51 <shachaf> dcoutts_: The links on that page are broken, which is presumably why stanrifkin was asking.
18:31:00 <dcoutts_> oh ok, lets see...
18:31:29 <shachaf> Google Code is long gone.
18:31:40 <dcoutts_> stanrifkin: try https://www.haskell.org/hugs/pages/downloading-May2006.htm
18:32:30 <shachaf> Oh, you can even get https://www.haskell.org/hugs/downloads/2006-09/WinHugs-Sep2006.exe , which is probably the file you wanted.
18:32:43 <stanrifkin> dcoutts_: thanks
18:32:56 <shachaf> My opinion is that GHC would be easier overall even if it diverges from what's written in the book a bit.
18:33:11 <stanrifkin> how do you found it so fast?
18:33:55 <dcoutts_> stanrifkin: ah, and the sept one is there too
18:33:56 <dcoutts_> https://www.haskell.org/hugs/downloads/2006-09/WinHugs-Sep2006.exe
18:34:11 <dcoutts_> oh shachaf found it first :-)
18:35:11 <dcoutts_> shachaf: really small differences can be show stoppers for people just getting started, see e.g. the howls about Programming in Haskell and Char vs Data.Char
18:35:28 <shachaf> dcoutts_: What howls?
18:35:38 <dcoutts_> well ok, when the book came out
18:35:51 <shachaf> I can believe there were some howls about that book, I guess.
18:35:56 <shachaf> Presumably the new edition fixes it?
18:36:16 <Gurkenglas> How should I recommend an online coding competition site to update from GHC 7.6.3? Tell them to install stack? Some Haskell Platform? I'm feeling like if I'm lucky I might be able to get some admin to run a singular command, perhaps starting with apt-get.
18:36:17 <pyon> What are the Altenative laws again?
18:36:24 <dcoutts_> or it not being totally clear how some typeset operators mapped to ascii (even though we'd think it's totally obvious, and there was even a table)
18:36:42 <shachaf> dcoutts_: Yes, I did hear a complaint about the operators.
18:37:20 <shachaf> Oh, looks like the second edition is finally out of pre-order on Amazon.
18:37:26 <dcoutts_> Gurkenglas: if they're the kind of site where you can only use the shipped libs then getting them to use a recent Haskell Platform would be a good idea
18:37:27 <shachaf> When I looked a few days ago it wasn't.
18:37:35 <shachaf> Still in pre-order on the publisher's website.
18:55:07 <ReinH> Gurkenglas: You can suggest that they do it, it's up to them to decide how to manage and implement that change.
18:56:38 <ReinH> If they've implemented a system that runs untrusted Haskell code for thousands of people, surely they are competent to upgrade the GHC version on their own.
18:57:26 <Gurkenglas> The manual says to use print to output for debugging purposes, but there's no IO interface
18:57:57 <Gurkenglas> Last coding site was also just barely competent enough to install an old compiler, let me see if I can find the logs of some guy talking in this channel about it
18:58:49 <ReinH> Or maybe they aren't competent, in which case you won't be able to make them competent by sending them an email.
19:00:31 <Gurkenglas> They don't have to be competent, they just have to install the latest haskell platform
19:00:43 <ReinH> It can't possibly be that simple.
19:01:11 <benzrf> dcoutts_: what is "Char vs Data.Char"?
19:01:24 <dcoutts_> benzrf: module imports
19:01:45 <dcoutts_> In Haskell98 the module was called Char, these days it's Data.Char
19:02:14 <benzrf> oh
19:02:16 <benzrf> lol
19:02:22 <dcoutts_> (Haskell98 didn't allow '.' in module names)
19:02:30 <Welkin> Gurkenglas: are you talking about hackerrank?
19:02:32 <Welkin> lol
19:02:50 <Gurkenglas> nah
19:02:51 <Welkin> and their horrible haskell templates written by someone who obviously has never written haskell
19:03:08 <Gurkenglas> actually that might be the one the guy was talking about last time
19:05:58 <ego> hrm, since the topic of older Haskell is raised, I've got a li'l question -- been skimming 1st ed of Hutton, and I see he uses cases of 0 and (n + 1) for integer parameters in recursive functions. this no longer works in Haskell2010. I realize, at some point between the book's publication & now that the language moved the counter play to the RHS of the equation, but, and here's the semi-loaded question: why?
19:06:00 <ego> was it a matter of convention, or was there a technical reason that it became untenable to have something like "drop (n + 1) (_ : xs) = drop n xs" vs. "drop n (_ : xs) = drop (n - 1) xs"?
19:07:03 <geekosaur> you can turn it back on with -XNPlusKPatterns
19:08:59 <geekosaur> bleh, neither the 2010 Report nor the ghc users guide talk about why it was done. I vaguely recall the discussion on the haskell-prime list
19:09:20 <shachaf> It was considered an inelegant special case. It makes code that looks good, but isn't really pattern-matching in the usual sense.
19:09:21 <Welkin> overoading (.) ?
19:09:41 <shachaf> https://prime.haskell.org/wiki/RemoveNPlusK
19:09:59 <geekosaur> here we go http://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010
19:10:14 <geekosaur> ...late as usual, pfeh
19:10:23 <ego> thank you much, to both of you.
19:10:28 <ego> obliged :)
19:10:39 <geekosaur> shows an example of why it was an annoying "feature" though
19:12:41 <ego> i found it to be a particularly elegant way of expressing it, myself, but I had never seen it prior to the obv. dated 1st ed Hutton. glad i'm not reading through this as a first angle at Haskell, for sure, but I suppose that's what the 2nd ed is for.
19:13:23 <shachaf> The fact that it looks elegant is exactly why people think it's misleading.
19:18:02 <ego> geekosaur: mm, yeah, that's a rather prime example of the pattern's shortfall. excellent link as well, tx.
19:28:04 <ego> @karma+ shachaf 
19:28:04 <lambdabot> shachaf's karma raised to 96.
19:28:08 <ego> @karma+ geekosaur 
19:28:08 <lambdabot> geekosaur's karma raised to 33.
19:28:26 <Welkin> @karma lambdabot 
19:28:26 <lambdabot> lambdabot has a karma of 31
19:28:45 <Welkin> @karma c++
19:28:45 <lambdabot> c++ has a karma of 4
19:28:50 <Welkin> @karma c
19:28:51 <lambdabot> c has a karma of 2
19:29:09 <shachaf> This would be more appropriate for /msg.
19:30:03 <ego> i couldn't remember the karma incrementing syntax so I looked @ the lambdabot sources. nicely documented plugins. :)
19:36:15 <jchia_> I'm trying to figure out Lens. From the tutorial, it seems that you have to define an original record type with ugly field names (names with leading underscore) and when you access the fields you use non-ugly names. So, when I need to make a record value, I need to make it using ugly field names, e.g. Atom {_element = "C", _point = ...}. Is this a necessity of using Lens? Can I retain normal field names?
19:37:06 <benzrf> jchia_: you certainly don't /need/ to use the template haskell accessor generators to use lens
19:37:10 <benzrf> but they are very convenient
19:37:33 <geekosaur> the problem is that defining a record defines a bunch of old-style accessor functions
19:38:04 <geekosaur> so you can't reuse the names without doing something like banishing the actual record definition to a different module and importing without the accessors
19:38:07 <Hafydd> Hahaha. Are you calling non-lens facilities "old-style" now?
19:38:18 <geekosaur> yes, not because of lens but because of ghc8
19:38:33 <geekosaur> (which should integrate with lens without requiring the TH glue)
19:38:38 <dibblego> data-lens is old-style
19:39:13 <glguy> "rustic"
19:39:13 <Hafydd> What is the feature in GHC 8 that allows this?
19:39:15 <benzrf> glguy: whoa! whast
19:39:18 <ReinH> glguy: hahaha
19:39:18 <benzrf> *what
19:39:19 <benzrf> Hafydd++
19:39:22 <geekosaur> hm, actually maybe ghc8 is not quite up to that point, I know they didn't get done with the full set of changes
19:39:52 <Hafydd> Or what is the planned feature in GHC that would allow this?
19:40:19 <jchia_> benzrf: What do I use to define my own accessors?
19:40:28 <geekosaur> OverloadedLabels and DuplicateRecordFields are the parts that made ghc8. OverloadedRecordFields is the intended full implementation
19:41:01 <jchia_> i.e. if i don't use the template generator
19:41:11 <Hafydd> Interesting.
19:41:19 <benzrf> jchia_: well, you could also just do this https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-TH.html#v:makeLensesFor
19:41:39 <geekosaur> I am not certain but it is possible that those extensions by themselves *plus* lens would work, where what is missing from the full implementation would be a minimal reimplementation of the parts lens provides
19:42:44 <geekosaur> (enough to simulate old-style accessors)
19:43:40 <jchia_> benzrf: OK, then I'll still have to be careful that the accessor name is not the same as the field name, right?
19:43:53 <geekosaur> yes
19:44:03 <geekosaur> you can'; stop autogeneration of the default accessor
19:44:21 <geekosaur> which will then camp on the name of the lens-style accessor
19:45:14 <geekosaur> er, can't stop
19:45:34 <Welkin> can't stop, won't stop?
19:45:56 <glguy> either?
19:46:21 <Welkin> maybe
19:46:26 <geekosaur> addicted to the shindig...
19:47:49 <Welkin> lol
20:14:03 <buttons840> is monadIO magic?
20:14:14 <dibblego> Yes.
20:14:22 <Clint> no?
20:14:43 <Cale> The IO monad itself might be considered a bit magic (though only because its implementation is unnecessarily magical)
20:14:51 <Cale> The MonadIO type class is not magic at all
20:15:17 <buttons840> (note sure if your replying to me) I was noticing some monad transformers like ReaderT are monadIO instances, but they wont necissarily have IO in their monad stack, so how's it work?
20:15:30 <geekosaur> constraints
20:15:38 <Cale> Those rely on a MonadIO instance for the underlying monad being transformed
20:15:55 <dibblego> MonadIO exists for ReaderT a f as long as f is MonadIO, so IO need not appear.
20:16:56 <buttons840> so in the haddocks when it says ReaderT is instances of various typeclasses, some of those are conditional on constraints?
20:17:31 <buttons840> *is an instance*
20:17:33 <Cale> yes... and the Haddock should be explicit about it
20:17:56 <Cale> http://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT
20:18:30 <Cale> There is a small problem with it at present though: It displays an extra * for the kind parameter, even though that's implicit.
20:18:45 <Cale> But you can see that the instance is for MonadIO m => MonadIO (ReaderT r m)
20:18:51 <dibblego> yeah woss up with that? my children are going through CIS194 and sprung that on me this morning
20:18:51 <buttons840> ok, I don't understand all the syntax i'm seeing
20:19:21 <buttons840> ah, so m must be a MonadIO
20:19:30 <Cale> :k ReaderT
20:19:32 <lambdabot> * -> (k -> *) -> k -> *
20:19:53 <dibblego> buttons840: yes, m must be MonadIO for (ReaderT a m) to be MonadIO
20:19:53 <Cale> dibblego: ^^ ReaderT is kind polymorphic now, and Haddock is bad at dealing with what it sees
20:19:54 <buttons840> so ReaderT r m is a MonadIO if m is a MonadIO
20:20:18 <Cale> yes, exactly
20:20:20 <buttons840> heh, sounds like were on the same page, thanks for the clarification
20:20:58 <Cale> dibblego: It's putting in the explicit argument corresponding to the kind-forall (which funnily enough, :k left out)
20:21:47 <Cale> Probably there's no reason for ReaderT to even be kind polymorphic in this way
20:22:05 <dibblego> Cale: ah ok
20:22:05 <Cale> since if k was anything other than *, you wouldn't even have a Monad instance
20:22:17 <Cale> But it's probably just happening automatically
20:23:29 <c_wraith> yeah, GHC infers kind polymorphism in a fair number of places if -XPolyKinds is enabled
20:24:25 <buttons840> in servant, what is ServerT ? the haddocks don't show it being a Monad instance, but it's named like a Monad and acts like a Monad?
20:25:00 <buttons840> (well, i'm assuming all SomethingT are monads by naming convention)
20:25:14 <c_wraith> which servant package?
20:25:20 <buttons840> servant-server
20:27:00 <c_wraith> Ah, in this case, the T suffix is not for transformer
20:27:02 <c_wraith> It's for type
20:27:17 <c_wraith> as ServerT is an associated type of the HasServer class
20:28:08 <buttons840> ok
20:28:38 <c_wraith> (There can't even be instances, since it's a type alias)
20:28:46 <shachaf> Good suffix.
20:28:55 <shachaf> If it didn't end with T I'd have no idea it was a type,
20:28:58 <shachaf> s/.$/./
20:29:01 * Clint chokes.
20:29:28 <c_wraith> It's *almost* the Henning school of naming.
20:29:45 <buttons840> c_wraith: yet, I can do liftIO inside a function with type ServerT MyAPI Handler ?
20:30:15 <c_wraith> buttons840: because whatever type the alias resolves to is an instance of MonadIO
20:31:01 <glguy> Not necesarily all ServerT layout m types are MonadIO instances, but your particular use of ServerT is
20:31:17 <buttons840> i see, the docs say `type ServerT layout m :: *` so ServerT is a type alias of what?
20:31:35 <buttons840> * ?   meaning anything?
20:31:36 <c_wraith> buttons840: depends on the HasServer instance
20:31:37 <glguy> You can ask GHCi  :kind! ServerT MyAPI Handler
20:31:50 <c_wraith> buttons840: it's an associated type - aka a type function
20:32:07 <buttons840> what is HasServer? it's using some extensions isn't it?
20:32:27 <c_wraith> buttons840: yes, TypeFamilies is the extension that's tripping you up right now
20:41:08 <glguy> docs up https://hackage.haskell.org/package/servant-server
20:42:42 <buttons840> glguy: nice, I've been missing those :)
20:47:03 <buttons840> `f :: a -> b -> c; g :: m a; h :: m b` can I get c without using temporary "variables", like in do notation?
20:47:39 <glguy> :t liftA2
20:47:41 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:48:10 <buttons840> ty :)
20:48:11 <amalloy> you can't get a c, but you can get m c with liftA2
20:48:46 <dfeuer> Here's a fun one: What does this do for the [] Alternative?  f x xs = xs <**> (pure (const x) <|> pure id)
20:50:33 <caThe> I seem to be missing some basic syntax here, can I pattern match on tuples?  ie: case (t1,t2) of (Just t, Just (tsub1, tsub2)) -> something etc?
20:50:53 <dfeuer> amalloy, did you ever figure out how to report the GitHub syntax highlighting bug to the *right* syntax highlighter people?
20:50:57 <glguy> caThe: sure
20:51:03 <amalloy> no
20:51:29 <dfeuer> Oh well.
20:54:05 <dfeuer> caThe, some people like to do it like that, actually.
21:12:33 <buttons840> i have `f :: ReaderT AppEnv Handler Text;  f = do x <- ask; let v = g x; ...` I want to get rid of the "x" binding, and tried `... do let v = g =<< ask; ...` but get an error?
21:13:19 <jle`> can you paste what you're talking about?
21:13:32 <jle`> and also what the error is?
21:13:52 <buttons840> yes, one sec
21:13:59 <jle`> also you might want `do v <- g <$> ask`
21:14:02 <jle`> or fmap g ask
21:14:13 <amalloy> or `do v <- asks g
21:15:36 <lpaste> Buttons840 pasted “Don't want "x" binding in makeToken” at http://lpaste.net/195710
21:21:56 <jle`> you can v <- gen <$> ask or v <- fmap gen ask, but also, fmap f ask = asks f
21:22:07 <jle`> so v <- asks gen should work too
21:22:23 <jle`> assuming the one you pasted already compiles
21:22:35 <buttons840> it does
21:22:45 <buttons840> :t asks
21:22:47 <lambdabot> MonadReader r m => (r -> a) -> m a
21:23:02 <buttons840> :t ask
21:23:06 <lambdabot> MonadReader r m => m r
21:23:29 <jle`> in your case, for ReaderT, ask :: ReaderT r m r
21:23:38 <jle`> and asks :: (r -> a) -> ReaderT r m a
21:23:47 <jle`> it's like asks but applies the function on the result first
21:23:54 <jle`> asks f = do x <- ask; return (f x)
21:25:37 <buttons840> jle`: that doesn't work, the MVar Gen never leaves the monad
21:25:47 <buttons840> nevermind
21:25:48 <geekosaur> that's what the <- does
21:26:04 <buttons840> i was thinking your wrote let v = ...   which you obviously didn't :)
21:26:47 <buttons840> so that make sense, in my beginners terms, I can see that you "fmap over the value in the monad, and then extract that value"
21:27:30 <jle`> i might avoid the term "value in the monad", and talking about extracting values
21:27:38 <jle`> i think you can say that you can fmap over the result
21:27:39 <jle`> and name the result
21:30:42 <jle`> not sure where the terminology "extract the result" came from
21:30:47 <jle`> but it's kind of common for some reason
21:30:56 <jle`> maybe everyone is hearing it from the same place?
21:31:17 <buttons840> jle`: well, if "something's in the monad" and then it's not, it was "extracted"
21:31:34 <buttons840> isn't it reasonable to say a value is in a monad? Monad is kind * -> * ?
21:31:56 <jle`> that just means that the type is applied to the type constructor
21:32:00 <jle`> but that doesn't say anything about values
21:32:16 <dibblego> Monad is kind (* -> *) -> Constraint
21:32:28 <jle`> most common monads don't actually "contain" any values of the type they are applied to
21:32:29 <buttons840> :k Monad
21:32:32 <lambdabot> (* -> *) -> Constraint
21:33:04 <buttons840> then what is altered if you fmap over those monads? can you give an example?
21:33:29 <jle`> sure, getLine is an IO String, a description of an IO action that gets a string from stdin
21:33:46 <jle`> fmap length getLine is an IO Int, a descirption of an IO action that gets a string from stdin and returns the length
21:33:58 <jle`> neither getLine or fmap length getLine contain any strings or ints
21:34:13 <jle`> well, they at least not the ones in their results
21:34:21 <jle`> it looks like you're also familiar with Reader
21:34:35 <jle`> a `Reader r Bool` doesn't contain any Bools
21:34:59 <jle`> fmapping a Reader r Bool returns a new Reader r, and it modifies the result
21:35:01 <buttons840> depends on how you think of it conceptually, right? getLine :: IO String conceptually contains a immutable string from the future ;)
21:35:24 <jle`> i don't think that respects referential transparency
21:35:33 <jle`> because two getLine's are identical programs
21:35:38 <jle`> but their results can be different strings
21:35:51 <buttons840> ah, so getLine != getLine
21:36:18 <jle`> getLine == getLine, but if getLine contained an "immutable future string" (?), they would not be equal
21:36:30 <jle`> every getLine in a program is identical
21:36:55 <buttons840> hmmm
21:37:20 <jle`> when you fmap over an IO action, you're returning a new IO action with a modified result
21:38:06 <jle`> and when you bind the result of an IO action, you're not extracting a value from an IO action ... that doesn't really make any sense
21:38:11 <jle`> what you're doing is naming the result of the action
21:38:38 <jle`> which honestly sounds a lot less vague and much less mystical
21:39:08 <buttons840> i was going to say that IO contains an action, but you don't extract an action, you extract a String (for example)
21:39:58 <buttons840> eh, i'm not even sure about that
21:41:06 <buttons840> so monads have "results" rather than "containing" things?
21:41:20 <jle`> when you use a do block, you can sequence actions like do x; y; z ..., but the results of x and y and z are lost forever that way.  do notation lets you bind/name those results so you can refer to them later -- do r <- x; y; z; ..., and now any actions later on can refer to r, the result of x :)
21:41:23 <glguy> IO actions have results
21:41:27 <buttons840> what terminology would you use when talking about a in `m a`?
21:42:08 <jle`> for types like IO where it would make sense, you could call it the type of the result
21:42:12 <buttons840> jle`: i realize do can be rewritting with >>= and >>
21:42:30 <buttons840> (and possibly some `fail` magic)
21:44:18 <buttons840> jle`: you criticized me for saying Reader "contained" a value, because that way of thinking doesn't apply to all monads; and now your talking about IO having "results" even though that doesn't apply to all monads
21:44:52 <buttons840> (i mean that in good humor) :)
21:45:12 <glguy> Yeah, having results is a property of an action, not of Monad
21:46:17 <buttons840> is it one of those things where words start to fall short and you just have to rely on the types and the math?
21:46:56 <buttons840> in general, how would you speak about the `a` in `m a`?
21:47:02 <jle`> yup, sorry :)
21:47:14 <glguy> I'd talk about a being a parameter of m
21:47:22 <glguy> or maybe m being indexed by a or something
21:48:46 <buttons840> jle`: well, no promises I wont use the word "contains" again :)  but you did give me an interesting new angle to think about things with your IO examples
21:49:57 <buttons840> and thanks for the help with my code
21:50:21 <GLM> How can I view all the messages being sent through cloud Haskell in a list instead of singularly?
21:54:49 <jle`> if you know how many messages you expect, you can use replicateM ?
21:55:12 <jle`> haven't really worked closely with cloud haskell to know if that's a good thing to do though
21:55:32 <GLM> jle`: The issue is that I don't know how many to expect.
21:55:33 <c_wraith> you can use unsafeInterleaveIO to terrify your friends and coworkers. :)
21:56:16 <jle`> GLM: well, how are you planning to know when to end the list?
21:56:53 <GLM> jle`: After a certain amount of time (i.e. 10 seconds)
21:57:44 <buttons840> c_wraith: well, halloween is coming
21:58:50 <GLM> We're all wearing Lambda man shirts, right?
22:08:42 <adelbertc> GLM: i want that lambda man shirt
22:08:50 <adelbertc> assuming youre referring to the one wadler wears
22:10:09 <norotartagen> oh yeah
22:10:40 <norotartagen> that would make a great halloween costume
22:18:59 <framesquestions> Can I make the type of something by providing the string representation of a type using Data.Typeable? For example: castFromString "Int" 1 :: Maybe Int
22:19:36 <liste> framesquestions: you are already providing the type Int in the type annotation
22:19:48 <glguy> and an Int with 1
22:21:22 <framesquestions> liste: No I won't have it. I will be querying a cassandra database for the type and it will return "org.apache.cassandra.db.marshal.Int32Type". When I get this I want my castFromString type to lookup that string in a map, which will return the string representation of Int, then try and do the same cast I did above.
22:22:29 <framesquestions> I want it to work kind of like Frames, but instead of inference I want to use the fact that I know the types before hand.
22:22:45 <glguy> framesquestions: You can make a data type: data TypesInCasandra = CasandraInt Int | CasandraDouble Doube | etc
22:23:06 <liste> framesquestions: what would be the type of that cast function?
22:23:08 <glguy> and a function: String {- ^ name of type -} -> String {- ^ value as string -} -> Maybe TypeInCasandra
22:23:48 <framesquestions> glguy: I think that will work
22:23:58 <framesquestions> liste: I think what glguy posted would be it
22:24:19 <liste> framesquestions: yep, that's the "standard" solution
22:37:42 * hackagebot synthesizer-alsa 0.5.0.5 - Control synthesizer effects via ALSA/MIDI  https://hackage.haskell.org/package/synthesizer-alsa-0.5.0.5 (HenningThielemann)
23:26:33 <John[Lisbeth]> I need to implement a krivine machine
23:26:51 <John[Lisbeth]> or alse any more minimal lambda calulus evaluator than a krivine machine
23:29:01 <John[Lisbeth]> the equations for the krivine machine are here: https://hal.archives-ouvertes.fr/hal-00154508/document
23:29:05 <John[Lisbeth]> I do not understand these equations
23:29:42 <Cale> What equations are you talking about?
23:29:48 <John[Lisbeth]> they are in the paper
23:30:03 <John[Lisbeth]> here is another paper explaining them: http://pop-art.inrialpes.fr/~fradet/PDFs/HOSC07.pdf
23:32:58 <Cale> John[Lisbeth]: I mean, what is confusing about what's there?
23:33:07 <John[Lisbeth]> I don't understand the equations
23:33:14 <Cale> Where do you get stuck?
23:33:27 <John[Lisbeth]> (M N, S, E)
23:33:44 <John[Lisbeth]> This syntax is unfamiliar to me
23:34:43 <John[Lisbeth]> In second three there is an equation fora  standard k machine
23:36:02 <Cale> So, M N is meant to represent an application term, S is the current stack, and E is the current environment
23:36:31 <John[Lisbeth]> I understand what a stack is
23:36:36 <John[Lisbeth]> I do not know the other ones
23:36:47 <John[Lisbeth]> well I know what an environment is
23:37:04 <Cale> and this line is telling you that the machine proceeds by putting the pair (N,E) on top of the stack, and proceeding to evaluate M next
23:37:58 <Cale> So every lambda calculus term is a variable (which in that presentation will be represented by a numerical index), an application, or a lambda
23:38:01 <Cale> right?
23:38:11 <John[Lisbeth]> sure
23:39:49 <Cale> So, yeah, those rules in Figure 1 of the second paper you linked are telling you what steps the machine will take when it's faced with evaluating a particular expression, given that the stack and environment contain certain things.
23:40:21 <John[Lisbeth]> I have to understand the logic behind how it works
23:41:20 <Cale> The environment consists of bindings for the variables in scope
23:42:04 <John[Lisbeth]> that part makes sense
23:42:08 <John[Lisbeth]> the stack also makes sense
23:42:11 <Cale> (which since the variables are encoded as numbers, it just relies on the position of the bindings in the list)
23:43:23 <Cale> I'm not sure that's essential to the description of how the machine handles things -- one could imagine not using De Bruijn indices, and letting the environment be a dictionary mapping names to values
23:44:19 <Cale> Just below Figure 1, there are English language descriptions of what the rules in Figure 1 mean
23:46:46 <John[Lisbeth]> so let me put it in my own words. It takes arguments to make a new closure environment
23:47:07 <John[Lisbeth]> that's my limited understanding of it
23:57:27 <John[Lisbeth]> It is very important to my work that I be able to understand these formulas. Any help you can give would be appreciated
23:59:49 <Cale> John[Lisbeth]: Okay, I mechanically translated it into Haskell, one sec
