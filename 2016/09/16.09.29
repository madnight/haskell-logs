00:06:28 <koz_> I'm having a bit of trouble understanding the functor instance of ((->) e).
00:06:56 <koz_> What does fmapping a function into it even *do* exactly?
00:07:37 * hackagebot incremental-parser 0.2.5 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.2.5 (MarioBlazevic)
00:07:37 * hackagebot tcp-streams 0.5.0.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.5.0.0 (winterland)
00:12:58 <jchia1> If I want to have a newtype that's an instance of Num that's not supposed to be multiplied, is there a way to express that and make using (*) on the newtype a compile-error?
00:13:27 <hvr> johnw: it's so tedious to have to always disambiguate cabal/cabal-install in discussions; tbh, I hate to type out cabal-install, so I always write cabal even though I mean cabal-install :-)
00:13:57 <Koterpillar> jchia1: no
00:14:08 <Koterpillar> jchia1: Nums are supposed to be multiplied
00:15:06 <jchia1> I'm trying to define numbers that have units in them. E.g. (Distance 2) * (Force 3) == Energy 6
00:15:29 <grantwu> jchia1: Consider https://hackage.haskell.org/package/units ?
00:15:32 <jchia1> I think it can't be done using the standard operators in Haskell.
00:16:06 <jchia1> grantwu: I'm looking at it now.
00:16:31 <Koterpillar> jchia1: but why can't you multiply them?
00:17:16 <jchia1> Dimensions don't match. 2 meter times 2 meter should not be equal to 4 meters it should be equal to 4 meter^2, a different unit
00:17:39 <jchia1> i have one newtype for each unit
00:17:52 <jchia1> E.g. Distance is one newtype, Force is another
00:17:56 <Koterpillar> then you can't even compile your own example above
00:18:08 <Koterpillar> because
00:18:11 <Koterpillar> :t (*)
00:18:12 <jchia1> i can't use (*), but i can defined my own operators
00:18:12 <lambdabot> Num a => a -> a -> a
00:18:22 <jchia1> that's why i want to disallow (*)
00:18:38 <Koterpillar> then I suggest avoiding Num entirely
00:19:00 <jchia1> then i lose the ability to use unboxed vectors
00:19:19 <jchia1> it's a tradeoff
00:19:52 <Koterpillar> why do you want Distance and Force to be of different types?
00:20:34 <jchia1> for safety. calculations involving quantities of various units are expressed in the code. enforcing that units match is one way to prevent errors
00:20:40 <grantwu> do you suggest allowing the ability to add distance and force?
00:20:45 <jchia1> no
00:20:45 <grantwu> @Koterpillar
00:20:45 <lambdabot> Unknown command, try @list
00:20:58 <Koterpillar> grantwu: ah, right, didn't think about that
00:21:01 <jchia1> i should allow adding only two things of the same unit
00:22:48 <jle`> how can i define associated types with more than one "case" ?
00:23:12 <jle`> ghc yells at me about conflicting defitions if i do type Foo ... = ...; type Bar ... = ...
00:23:14 <jle`> er
00:23:20 <jle`> type Foo ... = ...; type Foo ... = ...
00:24:41 <jchia1> 'type' means type synonym. What does it mean to define two synonyms for Foo? What does it mean for Foo to mean two different things?
00:24:59 <jle`> jchia1: it's for a type family/associated type
00:25:32 <jle`> type family Foo a
00:25:35 <jle`> type instance Foo Int = String
00:25:43 <jle`> type instance Foo Bool = Double
00:25:53 <jle`> it works with that syntax, but i'm not sure how to get it to work for associated types, heh
00:26:07 <jle`> because the syntax for associated types is just "type Foo a = ..."
00:28:58 <jchia1> jle`: Ah, didn't know you were talking about type families. I only started reading on type families yesterday.
00:33:33 <hexagoxel> jle`: but you'd have those type declarations in different instances. seems to work for me, unless i misunderstand the requirements.
00:35:26 <jle`> hexagoxel: in this case, the instance is a kind, and it's the kind of the RHS
00:35:53 <jle`> class Foo k where type Bar (a :: j) :: k, say
00:36:02 <jle`> s/j/Baz
00:37:09 <jle`> nvm i just declared a closed type family outside using closed type family syntax and then set the associated type to call it, heh
00:47:33 * hackagebot fay 0.23.1.16 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  https://hackage.haskell.org/package/fay-0.23.1.16 (AdamBergmark)
00:47:35 * hackagebot pandoc-vimhl 0.1.1.0 - Pandoc filter for native Vim code highlighting  https://hackage.haskell.org/package/pandoc-vimhl-0.1.1.0 (lyokha)
01:03:43 <quchen> Are there reasons to use Proxy over Proxy#?
01:05:24 <jle`> maybe if you want Proxy# + _|_
01:07:42 <quchen> jle`: That’s almost tautological. Do you have an example where we need the ⊥?
01:07:59 <quchen> I can’t think of one
01:08:51 <jle`> answer was slightly tongue in cheek ._.
01:11:17 <quchen> Oh. Okay. :-)
01:47:34 * hackagebot from-sum 0.1.0.0 - Canonical fromMaybeM and fromEitherM functions.  https://hackage.haskell.org/package/from-sum-0.1.0.0 (cdepillabout)
01:50:11 <ababywipe> Hello everyone. Functional noob here. All I'm trying to do is implement my on version of LCM. Can someone tell me where I'm going wrong? http://lpaste.net/232719
01:51:02 <liste> ababywipe: the do in line 5
01:51:20 <liste> ababywipe: use let..in instead
01:51:37 <liste> > let x = 4; y = 5 in x + y
01:51:39 <lambdabot>  9
01:53:32 <liste> > do { let x = 4; let y = 5; x + y }
01:53:34 <lambdabot>  <hint>:1:34: error: parse error on input ‘}’
01:54:30 <ababywipe> Ok, i'll keep working on it. Thanks.
02:06:17 <saurabhn_> broadcasting here for wider circulation: https://www.reddit.com/r/haskell/comments/54umkh/haskell_for_large_codebases_looking_for_first/
02:06:42 <YellowOnion> Is there a room for web specific talk?
02:09:23 <liste> YellowOnion: #html, #css, ##programming?
02:09:33 <YellowOnion> I mean haskell specific
02:10:04 <YellowOnion> I can't see one, maybe I'm blind.
02:11:32 <zomg> YellowOnion: I don't think so, but you can ask here
02:11:47 <zomg> I've mainly used haskell with web stuff myself and my main area of expertise is web development in general :)
02:13:41 <YellowOnion> sweet as, just seems strange that there's a room for embedded haskell and game dev, but not I would assuem is the most well developed area in haskell atm.
02:15:47 <YellowOnion> But anyway, friend needs an invoicing system, maybe something to replace roundcube mailing, and eventually I would like to re do the sight with model friendly layout.
02:16:19 <YellowOnion> s/model/mobile/
02:17:40 <liste> YellowOnion: I'm sure #css can help out on that, even if you use Clay or something like that
02:18:53 <YellowOnion> liste, that is true not really haskell specific, I guess I'm more interested in getting an invoicing backend setup.
02:21:03 <toon_> what is the best signing method to be used for a JWT (used in link in email to our customers). Symmetric / Asymmetric?
02:21:54 <YellowOnion> toon_, Umm I'm no cryptographer, but I don't think symetrical makes any sense.
02:22:20 <toon_> the token in validated on our premises, so the key never leaves the house
02:22:41 <toon_> but still, the thought that anyone with the key could generate tokens on its own...
02:24:29 <YellowOnion> toon_, you need the key to verify the signing.
02:24:59 <YellowOnion> so yeah, asymetrical makes the most sense.
02:25:21 <saurabhn_> broadcasting short-term Haskell opportunity again -- https://angel.co/vacation-labs/jobs/175267-haskell-developer-for-a-small-proof-of-concept-webapp
02:26:19 <toon_> YellowOnion: the thing is the key never leaves the house, but note that about 3M tokens are generated, and validated every month
02:26:29 <toon_> so symmetric would be less cpu intensive
02:26:49 <toon_> YellowOnion: and what about key rotation?
02:27:23 <YellowOnion> 3M in a month?
02:27:29 <YellowOnion> thats a performanec issue?
02:27:46 <toon_> YellowOnion: I don't think so, no..
02:28:46 <{AS}> Is there a nice if were one can use view patterns?
02:29:15 <{AS}> like if | Just a <- bla = ...; | otherwise = ...
02:30:57 <{AS}> https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/syntax-extns.html#multi-way-if <-
02:30:58 <{AS}> found it
02:34:48 <{AS}> so the parsing could be nicer
02:34:54 <{AS}> i.e. it could allow , under |
02:39:11 <merijn> {AS}: Pattern guards in a where?
02:44:44 <{AS}> merijn: There was actually the feature I was looking for
02:44:54 <{AS}> the multi-way if
02:45:08 <merijn> I meant pattern guards do allow ,
02:45:32 <{AS}> merijn: Yeah, I know
02:45:44 <{AS}> but it parses the following not as I like
02:46:27 <{AS}> if | Just a <- e
02:46:27 <{AS}>     , Just b <- e 
02:46:37 <{AS}> You have to indent the comma a bit
02:46:43 <{AS}> It's not the end of the world :)
02:47:14 <{AS}> It would just have looked a tiny bit better if they were aligned
02:47:35 * hackagebot network-msgpack-rpc 0.0.3 - A MessagePack-RPC Implementation  https://hackage.haskell.org/package/network-msgpack-rpc-0.0.3 (iphydf)
02:49:40 <lyxia> oh yeah.
02:49:47 <lyxia> Maybe you can submit it as a bug.
02:50:09 <lyxia> you can do that alignment in a definition
02:50:41 <{AS}> lyxia: how do I submit a bug?
02:51:13 <lyxia> https://ghc.haskell.org/trac/ghc
02:51:17 <{AS}> Thanks
02:51:28 <YellowOnion> zomg, what are you currently using for web dev, and what kinda site is it?
02:52:16 <lyxia> {AS}: you need to sign up to get access to "new bug/feature" on the left panel
02:52:50 <{AS}> Yeah
02:52:53 <{AS}> I am doing that
02:52:59 <{AS}> now it thinks I am spammer
02:53:11 <{AS}> so I have to get through the CAPTCHA
02:54:02 <{AS}> It asked me what 'G' in GHC stands for 
02:54:05 <{AS}> I answered Glasgow
02:54:10 <{AS}> and somehow it rejected me still
02:54:56 <{AS}> I did get through however
02:55:08 <zomg> YellowOnion: nodejs :) saas stuff
02:56:00 <YellowOnion> zomg, oh no haskell?
02:56:15 <zomg> practical matters such as being able to hire people who know the stack somewhat limit the choice :p
02:56:36 <zomg> we did do a small component in haskell but it was fairly short lived so it didn't matter I was the only person in the company who was able to understand the code
02:56:39 <zomg> lol
02:57:06 <zomg> But I've used Yesod in the past and quite liked it, for personal projects only though
02:57:58 <YellowOnion> zomg, yeah, I would probably avoid nodejs, I've tried writting userscripts before and that was enough for me :P
02:58:15 <zomg> hehe :)
02:58:27 <volhovm> Hey everybody! I have a set of local packages (< 10) that depend on each other. I'm thinking of a proper hierarchy of nix expressions for them.
02:58:37 <zomg> javascript is not that bad, but yeah it comes with the usual dynamic language disclaimers :)
02:58:38 <volhovm> I'd like to place default.nix in repo of each one.
02:58:52 <volhovm> How do i import A as dependency of B if A has default.nix in its repo root?
03:00:11 <volhovm> Currently each package holds all dependencies (lots of them), so if i update some package i should bump it in lots of places which is _really_ sad.
03:00:26 <volhovm> what is*
03:01:32 <YellowOnion> zomg, no hating, just that it means I have to learn another language, and I would probably go back to writing more python instead.
03:02:22 <{AS}> One could probably use PureScript or what not for JS development
03:02:40 <{AS}> TypeScript also works well enough
03:02:41 <YellowOnion> Most jobs here are C#/.NET, no one has any creativity :(
03:03:07 <{AS}> "creative" is not what you look for in business
03:03:11 <{AS}> dependable is
03:03:49 <srhb> volhovm: Have you seen ocharles wiki on the subject?
03:03:54 <srhb> volhovm: I think it still applies
03:03:59 <YellowOnion> There's plent of languages that are dependable, that aren't C# :P
03:04:55 <srhb> volhovm: In case you hadn't: http://wiki.ocharles.org.uk/Nix#multiple-project-usage
03:05:35 <volhovm> srhb: didn't see it for sure, thanks
03:05:58 <YellowOnion> {AS}, (I'm in NZ) and Java I don't think caught on, infact, Jade was pretty popular for a while (a JVM lang), so what I assume happened is people jumped shit when C# came out.
03:06:14 <YellowOnion> ship* when
03:07:05 <volhovm> srhb: it doesn't apply because nothing github-related is covered at all
03:07:32 <srhb> volhovm: You can replace the includes with fetchFromGithub, can't you?
03:07:41 <volhovm> self.callPackage's?
03:07:47 <srhb> Yes, sorry.
03:08:00 <volhovm> You sure i can?
03:08:04 <volhovm> Ok, ill try to
03:08:04 <volhovm> :)
03:08:12 <srhb> volhovm: Not sure sure, but I think so. :-P
03:08:14 <tdammers> I think a huge selling point for C# is how well it integrates with the rest of the MS stack, which is what many businesses are heavily invested in
03:08:40 <tdammers> corporate IT loves Windows because they can remotely control all the machines on the network
03:08:43 <volhovm> srhb: i think that fetchFromGithub downloads something and returns path to the sources
03:08:52 <volhovm> so it doesn't build a derivation
03:08:59 <tdammers> HR also loves Windows because everyone already knows how to use it
03:09:09 <srhb> volhovm: You're right of course.
03:09:23 <tdammers> management loves Windows because they use it themselves and have absolutely no time learning anything else
03:11:05 <YellowOnion> tdammers, you're indeed very right there, plus it dosen't help that C# is actually from what I've heard, a pretty good language, fixing alot of the issues java had.
03:11:33 <zomg> yeah I always found C# nicer to use than Java :)
03:11:42 <zomg> F# was also interesting but didn't really use it that much
03:12:51 <jchia1> I'm trying to figure out how to use Data.Metrology by following the example in the documentation: http://hackage.haskell.org/package/units. I got this error: http://lpaste.net/232762. What am I missing?
03:12:53 <tdammers> YellowOnion: yep. C# is definitely nicer than Java
03:13:15 <tdammers> being easy to learn for old C++ windows programmers was of course another big plus
03:13:43 <tdammers> I basically picked up the language in two weeks, coming from a background of writing games in C++
03:14:29 <YellowOnion> Unity uses .NET as well, GC global stall is excellent for video games /sarc
03:15:14 <zomg> must be some workarounds for that considering there have been several bigger/AAA'ish Unity-games these days
03:15:38 <zomg> Hearthstone and Cities: Skylines come to mind (though from what I understand, Cities is actually somewhat limited because of some engine related problems)
03:16:03 <YellowOnion> zomg, yeah they eventually wrote their own GC, and have some serious guidelines to help.
03:16:07 <maerwald> tdammers: and there is F# and now F* ...which potentially makes for an extremely nice programming language stack
03:16:37 <tdammers> maerwald: probably. I'm still unlikely to willingly touch Windows again in the near future.
03:16:45 <maerwald> so instead of hitting every problem with haskell, you could: 1. solve imperative problems with C#, 2. solve abstraction problems with F#, 3. solve security-sensitive sysems with F* and carry out static proofs
03:16:53 <volhovm> srhb: oh, by "local" i meant "local within a company"
03:16:55 <tdammers> and without Windows, there's not a very compelling incentive to go .NET
03:17:00 <maerwald> and have it all interact in one software stack
03:17:09 <volhovm> They're all on github/labs with different permissions and so on
03:17:09 <YellowOnion> zomg, System Shock Remastered is in Unity, current system requirements are about 16GB of RAM hah.
03:17:19 <zomg> YellowOnion: woah...
03:17:28 <zomg> Finally something to do with my 32 gigs of it then
03:17:29 <zomg> :P
03:17:32 <YellowOnion> it's still in alpha
03:17:42 <tdammers> and IMO there are better ways of doing polyglots than compiling everything to the same bytecode and running it on a common VM
03:17:54 <YellowOnion> most games start off with "master" polys and textures.
03:18:04 <tdammers> OTOH, that's exactly what the javascript ecosystem looks like today (except most people are still hacking bytecode by hand)
03:18:12 <zomg> YellowOnion: yeah that's true, much bigger than the final ones :)
03:18:56 <zomg> we're actually considering adding Flow to our JS stack now... add some typing guarantees in there
03:19:17 <zomg> although it seems like TypeScript actually has one or two features which Flow is missing right now
03:25:27 * Maxdamantus wonders if Flow has the same modifiable structural subtyping issues as TS.
03:25:34 * Maxdamantus suspects so.
03:28:53 <NickHu> I'm guessing in this channel people prefer stuff like PureScript and GHCJS
03:30:50 * Maxdamantus thought this was ##javascript
03:32:52 <Maxdamantus> tbh, I'd be reasonably happy with something like TypeScript but without an emphasis on structural subtyping (since it's completely unsound on mutable structures)
03:33:17 <Maxdamantus> TypeScript doesn't seem to really have the ability to define nominal types though.
03:33:38 <YellowOnion> NickHu, GHCJS looks like a lot of fun if you can somehow cache your binary, and not worry about the 3MB file size.
03:33:45 <Maxdamantus> you can kind of emulate them using generics, but that would be very tedious.
03:33:58 <ggVGc> but the GHCJS FFI isn't at all as nice as the purescript one, imo
03:34:10 <NickHu> Maxdamantus: You might be interested in PureScript
03:34:12 <ggVGc> and also, the laziness of haskell vs the strictness of JS is awkward
03:34:19 <NickHu> It's basically the full haskell typesystem on a javascript
03:34:25 <ggVGc> and adds a lot of the code output overhead afaik
03:34:27 <ggVGc> because it needs a runtime
03:34:38 <NickHu> The purescript documentation is kinda stupid though
03:34:44 <ggVGc> I've been enjoying purescript
03:35:10 <Maxdamantus> NickHu: but it's a pure language right? So what you write probably isn't going to correspond very directly into JS.
03:35:24 <NickHu> Maxdamantus: idk to be honest
03:36:02 <ggVGc> Maxdamantus: it's a strict language where the syntax is heavily inspired by haskell, and a lot of the same data structures and libraries exist. It maps really well to javascript actually
03:36:10 <ggVGc> e.g the output is very easy to map to your purescript code
03:36:19 <ggVGc> GHCJS on the other hand is just a huge blob
03:36:31 <ggVGc> because it has to run lazy code within strict javascript
03:36:32 <jchia1> Can Data.Metrology be used with Integral types instead of Fractional types? From the type signature, it seems that Fractional is a requirement.
03:36:36 <ggVGc> so it needs an entire runtime around it
03:37:07 <ggVGc> Maxdamantus: also, Purescript has a record system competely different from what haskell has
03:37:14 <tdammers> ggVGc: you can implement non-strict semantics in JS without a full-blown runtime just fine
03:37:32 <YellowOnion> ggVGc, the real power of GHCJS is the runtime though. I could see it being great if a compile flag could target WebGL instead of openGL.
03:37:39 <NickHu> When I was looking around for something to write a frontend in, I thought purescript was basically like haskellers who were forced to write javascript
03:37:47 <tdammers> ggVGc: a much heavier task is mapping Haskell's green-thread execution model onto JavaScript's callback hell
03:37:49 <NickHu> In the end I opted for Elm because using purescript for UI seems PITA
03:38:42 <ggVGc> NickHu: but Elm is ever-changing and really immature in general
03:38:52 <ggVGc> while purescript is quite stable and has a lot of the same libraries that haskell has
03:39:03 <NickHu> ggVGc: Yeah but at least I understand what Elm is doing
03:39:12 <ggVGc> but yeah, Elm is fine. But imo purescript is trying to be much closer to haskell than Elm is
03:39:20 <ggVGc> Elm is trying to be something quite different
03:39:22 <NickHu> Purescript is hundreds of lines of boilerplate to do the most basic of things
03:39:27 <ggVGc> really?
03:39:31 <ggVGc> it's just like haskell for me
03:39:40 <NickHu> I'm not arguing that purescript isn't just like haskell
03:39:46 <ggVGc> are you talking about purescript or about some specific purescrpit library?
03:39:49 <NickHu> Maybe Haskell has the same problems with UI development
03:40:05 <NickHu> I looked at the idiomatic way to do frontend in purescript
03:40:19 <tdammers> NickHu: my assessment of the serious contenders so far: PureScript - language looks better than Haskell in many ways, but the tooling isn't mature enough for my needs, and too JavaScript-y (npm, etc.); GHCJS is great but lacks documentation and a good equivalent of hackage etc., and just getting a working setup going took me ages of fiddling and experimentation; Elm is nice in that the initial learning curve
03:40:22 <tdammers> is very smooth, but it's too much of a moving target, and too immature, to bet a project's success on
03:41:14 <NickHu> I'm not a professional, just a student who has some things he wants to do, so that's fine with me :P
03:41:55 <tdammers> if I had to pick one today, I'd probably roll with GHCJS
03:42:18 <ggVGc> NickHu: I made a small game in Elm less than a year ago, and currently the entire core design of the language that it was built on has been revamped, so I'd have to just rewrite the whole thing I think
03:42:23 <ggVGc> it's really very changing atm
03:43:13 <zomg> ggVGc: hah yeah, I wrote a proto of something a while back with Elm, then wanted to do something with it and boom everything broke because they just made everything completely different
03:43:15 <ggVGc> anyway, I've been enjoying purescript lately. I think the FFI is great, and the record system is much nicer than in Haskell, and working with Effects rather than IO is intersting, although I'm not sure I prefer it
03:43:17 <zomg> o well :)
03:43:39 <ggVGc> ghcjs is better I thikn if you already have an application that you just wnat to build for the web
03:43:40 <YellowOnion> tdammers, isn't the key benfit of ghcjs is that you can probably run any code off hackage as long as it doesn't use the CFFI?
03:44:43 <YellowOnion> with emscripten that's not even a hard limit either :P
03:47:36 * hackagebot text-binary 0.2.1.1 - Binary instances for text types  https://hackage.haskell.org/package/text-binary-0.2.1.1 (JakubWaszczuk)
03:47:38 * hackagebot x86-64bit 0.4.1 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.4.1 (PeterDivianszky)
03:51:32 <YellowOnion> ggVGc, I really want to be able to take an app, and with a flag recompile it to the web, for example FTL: Faster than Light, and Super Hexgon, both have web versions using asm.js and emscripten.
03:57:58 <YellowOnion> Anyone here got opinions on using servant vs yesod/snap/etc?
03:58:07 <NickHu> YellowOnion: servant is GOAT
03:58:45 <YellowOnion> NickHu, that was so quick, I'm wonder if that was an automated response...(what is GOAT?)
03:58:52 <NickHu> As someone who's never done any web dev before, I'm really enjoying using it
03:58:57 <NickHu> greatest of all time
03:59:12 <NickHu> I just happened to be looking at the chat when you asked
03:59:27 <liste> YellowOnion: servant and spock both look very promising. yesod seems very rapid if you do things its way, but it's a pretty complex veast
03:59:43 <liste> beast*
04:04:03 <NickHu> Servant lets you encode your API specification to guarantee that if your app compiles, all the routes resolve to something
04:04:16 <NickHu> liste: What's spock like?
04:04:54 <YellowOnion> servant advertises itself as an API, not a web framework, does that mean its basically just the routing layer?
04:05:27 <tdammers> YellowOnion: yes, pretty much
04:05:44 <tdammers> YellowOnion: but you also get to use most of the existing Haskell toolchain
04:06:09 <tdammers> which is nice, because that stuff, despite Cabal Hell and all the bikeshedding in the community, is actually pretty good
04:06:24 <tdammers> oh, and you also get to reuse code between server and client
04:06:32 <YellowOnion> tdammers, indeed, haskell really benefits to pluggable stuff.
04:06:38 <tdammers> (what JS folks call (shudder) "isomorphic")
04:07:17 <YellowOnion> haha wow
04:07:32 <NickHu> There's a servant-elm plugin which I am keen to use
04:07:34 <tdammers> anyway, I haven't used haskell for serious frontend projects yet, but I did write a proof-of-concept app that included an implementation of a reactive mini-framework based on virtual-dom
04:09:43 <YellowOnion> yeah I want a way to place orders, route payment through paypal or bank account.
04:10:13 <NickHu> sounds like you could write that with any web framework under the sun
04:10:21 <YellowOnion> currently my friend is doing it all manually, and its taking a lot of time out of her day.
04:10:28 <liste> NickHu: it's a bit like Ruby's sinatra, but with eg. type-safe routing, and batteries included
04:10:40 <NickHu> liste: I wasn't all the into Ruby
04:10:50 <liste> NickHu: me neither, but Sinatra is nice
04:10:52 <tdammers> you could do that without any javascript, if you have to
04:10:55 <NickHu> tbh servant is the only web framework I have ever properly used
04:11:00 <NickHu> Could you maybe compare it to that?
04:11:49 <YellowOnion> tdammers, thats actually what I'm thinking, the website is mostly there, I just need someway to do the backkend stuff.
04:12:36 <YellowOnion> actually did anyone want to see the site?
04:12:50 <liste> NickHu: it's more function-focused, where Servant is more type-focused
04:13:23 <NickHu> liste: I looked at the spock tutorial very briefly but at a glance I couldn't really understand the code
04:13:27 <NickHu> But I am not a web developer
04:13:27 <Benzi-Junior> hey guys is Haskell 2010  the latest language standard ?
04:13:46 <liste> Benzi-Junior: yes
04:13:58 <Benzi-Junior> liste: ok thanks
04:14:35 <YellowOnion> I'm the kind of person to over engineer and worry about security, before I get any code even started. :\
04:15:51 <liste> NickHu: https://www.spock.li/tutorial/#hello-world `main' here does initialization and starts the server, where `app' defines how the server responds to "GET /" and "GET /hello/<name>" requests
04:16:23 <NickHu> yeah but all the cruft around it
04:16:40 <NickHu> DummyAppState, PCNoDatabase etc.
04:17:18 <liste> it's Spock's "batteries included", it includes HTTP session management, RDBMS connections, app configuration management
04:17:24 <liste> things most web apps need
04:17:45 <volhovm> phadej: i don't really understand how binary-orphans dependencies
04:17:45 <volhovm>           work  [14:15]
04:17:45 <volhovm> <volhovm> why do you have so many "smaller than" restrictions?  [14:16]
04:17:46 <volhovm> <volhovm> That leads to lots of problems with compiling your package with nix
04:17:50 <volhovm> <volhovm> can we get rid of them?
04:17:52 <NickHu> Interestingly is there an idiomatic way of doing servant app configuration rather than wrapping it in a ReaderT?
04:17:53 <volhovm>  
04:17:56 <volhovm> [Thu Sep 29 2016]
04:18:01 <volhovm> *** Topic for #haskell: https://www.haskell.org |
04:18:01 <volhovm>     https://wiki.haskell.org/IRC_channel | Paste code/errors:
04:18:38 <phadej> hmm
04:18:54 <phadej> well, let's wait for him to return
04:21:33 <phadej> NickHu: ReaderT / partial applications is one
04:21:47 <phadej> or then check "implicit configurations" functional pearl
04:22:01 <NickHu> phadej: I'm looking at https://github.com/parsonsmatt/servant-persistent/blob/master/src/Config.hs
04:22:06 <NickHu> It seems to be sane
04:23:09 <phadej> NickHu: I do something like: https://github.com/futurice/haskell-mega-repo/blob/5d4d13e7375008d5eb528e43a421c131b7e7481b/contacts-api/src/Futurice/App/Contacts.hs#L26
04:23:14 <phadej> i.e. just part apply
04:23:53 <phadej> but it's only nuances, which one works better for you
04:25:37 <NickHu> I don't really understand your approach too well
04:27:58 <phadej> instead of `ReaderT Config foo` i just use Config -> foo
04:28:33 <phadej> most endpoints start with something "give me connection from the pool", and then don't care about configuration
04:31:46 <{AS}> So is small check to generally be used for depth 7 or less?
04:32:22 <{AS}> It seems like it takes a lot of time for more complex depths
04:32:45 <lyxia> yes, that's why it's Small
04:33:27 <lyxia> the depth you can go to depends on the datatype and the time you have
04:33:47 <{AS}> really complex data type I guess
04:34:13 <{AS}> also what is "depth" in small check
04:34:18 <{AS}> does that include like list size?
04:35:20 <lyxia> say you have a binary constructor C, then depth (C a b) = max (depth a) (depth b) + 1 
04:35:38 <{AS}> Aha
04:35:43 <{AS}> so it is depth of constructors?
04:35:49 <{AS}> Thanks
04:35:50 <lyxia> testing-feat is another library for enumeration, based on size.
04:36:07 <{AS}> so I am using lazy smallcheck
04:36:15 <{AS}> because I have hard to satisfy pre-conditions
04:36:43 <lyxia> {AS}: that's the usual definition but you can more or less customize it because SmallCheck's combinators can take functions instead of actual constructors.
04:37:03 <{AS}> lyxia: I see
05:04:25 <vervain> I could use help with an error: "Couldn't match expected type ‘a -> a’ with actual type ‘a’"
05:04:49 <vervain> My code and error output is here: https://gist.github.com/wcravens/23f8ec6dc8b1bcf6447521314d7300e2
05:07:11 <lyxia> vervain: you're missing an argument to stepReverseSign
05:07:29 <lyxia> So it thinks that here you're using piCalc' applied to a function
05:07:56 <lyxia> and tries to unify a with a -> a
05:08:56 <vervain> lyxia: Thank you so much.  That's exactly right!  The compiler error had me focusing on pi'
05:09:53 <lyxia> yeah that wasn't a very helpful error
05:30:36 <Jaweds> Hello, do you know how can I dectect if < or > is used in a function?
05:30:55 <Jaweds> detect string is quite idiot, and I do not have figure out how to do otherwise.
05:33:06 <lyxia> grep " [<>] "
05:37:38 <implementation_> redefine (<) and (>) to something with a bizarre type and see if the compiler throws an error on usage
05:39:48 <Jaweds> Thanks
05:55:11 <byorgey> implementation_: that only works if you are compiling the source code of the function, in which case presumably this is simple (just grep)
05:55:23 <byorgey> oh, Jaweds left.
05:55:57 <byorgey> This sounds like an XYZ problem.  I think the correct answer is "What are you actually trying to accomplish?"
05:56:37 <piyush-kurur> byorgey: hey how are you? I hope your trip back was good
06:01:40 <ania123> 2^2
06:01:55 <ski> > 2^2
06:01:58 <lambdabot>  4
06:02:01 <soLucien> hi ski
06:02:05 <ania123> hi ski
06:02:13 <ania123> > 2^2
06:02:15 <lambdabot>  4
06:02:19 <ski> hello soLucien,ania123
06:02:30 <soLucien> would you like to continue the discussion we had last night
06:02:30 <ania123> > 2^32 : Int
06:02:32 <soLucien> about the monad ?
06:02:32 <lambdabot>  error:
06:02:33 <lambdabot>      • Data constructor not in scope: Int :: [a]
06:02:33 <lambdabot>      • Perhaps you meant one of these:
06:02:36 <soLucien> i was trying to make
06:02:41 <ski> > 2^32 :: Int
06:02:43 <lambdabot>  4294967296
06:02:45 <soLucien> i got a suggestion from ReinH to implement the fmap
06:02:48 <ania123> > 2^32 :: Int
06:02:52 <soLucien> because it would make it easier
06:02:53 <lambdabot>  4294967296
06:02:59 <ania123> > 2^52 :: Int
06:03:01 <lambdabot>  4503599627370496
06:03:07 <ania123> > 2^62 :: Int
06:03:09 <lambdabot>  4611686018427387904
06:03:10 <ski> soLucien : hm, i (briefly) saw
06:03:17 <ski> > maxBound :: Int
06:03:19 <lambdabot>  9223372036854775807
06:03:20 <ania123> > 2^72 :: Int
06:03:23 <lambdabot>  0
06:03:27 <soLucien> i've tried  (and am still trying to do it)
06:03:27 <ski> > 2^72 :: Integer
06:03:29 <ania123> > 2^63 :: Int
06:03:30 <lambdabot>  4722366482869645213696
06:03:31 <lambdabot>  -9223372036854775808
06:03:35 <ania123> > 2^63 :: Int
06:03:37 <lambdabot>  -9223372036854775808
06:03:38 <soLucien> would you like to see what i've came up with so far ?
06:03:39 <ania123> why? -?
06:03:58 <soLucien> maybe point me in the right direction
06:04:00 <ski> > maxBound + 1 :: Int
06:04:02 <lambdabot>  -9223372036854775808
06:04:05 <ski> > minBound :: Int
06:04:08 <lambdabot>  -9223372036854775808
06:04:14 <ski> it wraps around
06:04:23 <ski> > logBase 2 9223372036854775808
06:04:26 <lambdabot>  63.0
06:04:47 <ski> soLucien : sure
06:04:49 <ania123> ski: what is range of Int?
06:04:52 <byorgey> ania123: google for "two's complement" if you want to know the details (this is not specific to Haskell, it is just how fixed-precision integer arithmetic works)
06:05:03 <ski> > [minBound,maxBound] :: [Int]
06:05:05 <lambdabot>  [-9223372036854775808,9223372036854775807]
06:05:29 <ski> `Integer' is unbounded, though
06:05:39 <ania123> ski: ok
06:06:34 <soLucien> ski http://lpaste.net/2772336045935558656
06:06:40 <soLucien> i feel i might be close to the fmap
06:07:31 <soLucien> well this doesn't even parse
06:07:36 <ski> i think your thought process is roughly (not quite) right
06:07:45 <ski> but you can't have lambda-patterns
06:08:03 <soLucien> i see.. this doesn't even parse , 
06:08:16 <ski> so you need to express what you're thinking in a way that Haskell understands
06:08:24 <soLucien> but the left side of the = has to be a lambda
06:08:26 <soLucien> function
06:08:42 <soLucien> because SubsM is a function
06:08:54 <ski> (also you're missing a `SubsM' in the latter case .. not that it matters, though, since the code will be reworked anyway)
06:09:04 <ania123> ski: how can I check value of bool type class?
06:09:22 <ski> ania123 : which type class ? `Bool' is a type, not a type class
06:09:54 <ski>   fmap f (SubsM g) = SubsM ...
06:10:01 <ania123> Bool is a type which contains two values True and False
06:10:05 <ski> soLucien : ^ is a good point to resume from
06:10:09 <ski> yes
06:10:10 <byorgey> soLucien: the left side of the = has to be a function, but you cannot pattern-match on functions
06:10:10 <ania123> how can I check values of Bool
06:10:30 <ski> ania123 : the *direct* way would be using pattern-matching which works for all `data' types
06:10:36 <byorgey> case boolValue of
06:10:39 <byorgey>   True -> ...
06:10:42 <byorgey>   False -> ...
06:10:50 <ski> ania123 : for `Bool' specifically, you can also use guards, and `if'-`then'-`else' expressions
06:11:06 <ania123> ski: [minBound,maxBound] :: [Int]
06:11:10 <ski> ania123 : .. then there's also some library functions operating on `Bool', just as for other `data' types
06:11:15 * byorgey likes case on Bool a lot better than if-then-else
06:11:21 <ania123> using it u checked diapason of Int
06:11:43 <ski> byorgey : showed how to pattern-match on it using `case', in case you've seen that before ..
06:11:56 <ski> > [minBound,maxBound] :: [Bool]
06:11:58 <lambdabot>  [False,True]
06:11:58 <ania123> is there way to check Bool values like u did for Int
06:12:04 <ania123> ah
06:12:04 <ania123> ok
06:12:06 <ania123> thx
06:12:10 <ski> `minBound' and `maxBound' only works for types in the type class `Bounded'
06:12:14 <ski> @type minBound
06:12:16 <lambdabot> Bounded a => a
06:12:16 <ski> @type maxBound
06:12:18 <lambdabot> Bounded a => a
06:12:29 <ski> both `Int' and `Bool' are in that type class
06:12:30 <soLucien> ok so then i have to use the g
06:12:36 <soLucien> to extract what i want from it ?
06:12:42 <ski> soLucien : yes. if you prefer, you could rename it to something better
06:12:56 <ski> soLucien : yep
06:13:43 <ania123> ski:
06:13:44 <ania123>  [minBound,maxBound] :: [Char] "\NUL\1114111"
06:13:51 <ania123> what this means?
06:13:58 <ski> soLucien : .. fwiw, i'm thinking that something similar to what you pasted *would* actually work, if one extended the syntax for pattern matching a bit. but that's not currently in any implementation of Haskell i know of, so ..
06:14:12 <ski> > '\0'
06:14:15 <lambdabot>  '\NUL'
06:14:27 <ski> that's the "least" character, the nul character
06:14:37 <ski> as you see, it can be spelled in more than one way
06:14:58 <ania123> ok
06:15:16 <ski> apparently the "greatest" character in unicode (i suppose in current unicode ?) is `\1114111'
06:15:21 <ski> > ord '\0'
06:15:25 <lambdabot>  0
06:15:49 <ania123> > sqrt 2 :: Float
06:15:51 <lambdabot>  1.4142135
06:15:53 <ski> > [ord c | c <- ['0','1','2','3','4','5','6','7','8','9']]
06:15:56 <lambdabot>  [48,49,50,51,52,53,54,55,56,57]
06:16:07 <ski> > ord '\1114111'
06:16:10 <lambdabot>  1114111
06:16:20 <ania123> > sqrt 99999 :: Float
06:16:23 <lambdabot>  316.2262
06:16:29 <ski> > sqrt 99999
06:16:31 <lambdabot>  316.226184874055
06:16:41 <ania123> ski, look
06:16:44 <ania123> > sqrt 2 :: Float
06:16:44 <soLucien> fmap f (SubsM err) = 
06:16:44 <soLucien>     let err = SubsM(\_ -> Error e )
06:16:44 <soLucien>     in SubsM (\_ -> Left (Error e))
06:16:46 <ania123> > sqrt 99999 :: Float
06:16:46 <lambdabot>  1.4142135
06:16:47 <soLucien> still
06:16:48 <lambdabot>  316.2262
06:16:50 <ski> it'll default to using `Double' there, in case you don't insist on using `Float' (or something else)
06:16:53 <soLucien> i am lost
06:16:56 <soLucien> how to pattern match g ?
06:17:00 <soLucien> it is still a function
06:17:05 <ski> soLucien : answer : no
06:17:12 <ski> you don't pattern match on it
06:17:32 <ski> soLucien : first concentrate on filling out the `...' in the body
06:17:41 <ski> (or rather, filling it out more)
06:18:00 <soLucien> which ... ?
06:18:17 <ania123> ski, after decimal point number of digits is not same, why?
06:18:21 <ski> soLucien : i'm not sure that you'll need that `err' there, btw
06:18:23 <ania123> > sqrt 99999 :: Float
06:18:25 <ania123> > sqrt 2 :: Float
06:18:26 <lambdabot>  316.2262
06:18:28 <lambdabot>  1.4142135
06:18:58 <ski> soLucien : anyway, you should probably replace `_' by a real variable name (like `cxt' or something), because you can't assume apriori that yuo won't need it
06:19:31 <soLucien> okay , done
06:19:37 <soLucien> now what to dow ith the g ?
06:19:45 <ski> ania123 : `Float' and `Double' are (single-precision vs. double-precision) floating-point numbers
06:20:10 <soLucien>   fmap f (SubsM g) = SubsM (\cxt -> Left (Error e))
06:20:11 <ania123> and?
06:20:27 <ski> ania123 : roughly, they work with a fixed number of digits (counting both left and right of the decimal point), and then a separate indicator to tell where to place the decimal point
06:20:43 <ski> ania123 : you can compare it to "scientific notation", if you know about that
06:21:09 <ania123> ski, does haskell has double type?
06:21:14 <ski> soLucien : remove `Left (Error e)', replacing it with a fresh hole, since you'll need to put something different there
06:21:16 <shapr> :t 1 :: Double
06:21:17 <ski> ania123 : yes
06:21:19 <lambdabot> Double
06:21:31 <ski> ania123 : do you know about floating-point types ?
06:21:40 <ania123> not really
06:21:43 <ski> @where floating-point
06:21:43 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
06:21:43 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
06:22:08 <ski> you could at least skim the first link there to get a rough impression, then later revisit it
06:22:20 <ania123> ok
06:22:39 <ski> very briefly, floating-point numbers are *approximations* of real numbers, by keeping track of a fixed number of digits
06:22:56 <Taxz> what code are you working with?
06:23:09 <ski> so, the larger (in absolute value) your number is, the fewer significant digits to the right of the decimal point you'll have
06:23:29 <ski> > 10000000000000000000000000.0
06:23:32 <lambdabot>  1.0e25
06:23:32 <ski> > 10000000000000000000000000.0 + 1
06:23:35 <lambdabot>  1.0e25
06:23:42 <ski> > 10000000000000000000000000.0 + 1 == 10000000000000000000000000.0
06:23:45 <lambdabot>  True
06:23:59 <ski> obviously, that equality doesn't hold for the corresponding real numbers
06:24:58 <ski> but the digit `1' just before the decimal point in the *real* answer will get cut away, because a floating-point number only keeps track of a fixed number of significant digits (and counting from the most significant digit, iow "from the left")
06:25:06 <ski> ania123 : makes sense ?
06:26:32 <ski> soLucien : anyway .. you then need to think about how you can *use* `g' inside that hole
06:27:13 <ski> (and the idea would be to effect more or less what you attempted to do with your lambda patterns. except that you can't write it in that way, as noted)
06:31:37 <soLucien> what can i do to functions
06:31:44 <soLucien> except composition?
06:31:47 <ski> you can apply them
06:31:59 <ski> that's the basic thing you can do with a function
06:32:08 <ski> if `f :: A -> B' and `x :: A', then `f x :: B'
06:33:41 <ski> in your case, `g :: Context -> Either Error (a,Env)', so if you can find an input `...' of type `Context', then `f (...)' would have type `Either Error (a,Env)' .. and then you could do further work on that result
06:34:19 <ski> soLucien : so .. *can* you find an input of type `Context', to feed to `g' inside the hole `?0' in :
06:34:21 <kuribas> Does there exist a typeclass for element by element operations on a structure?
06:34:25 <ski>   fmap f (SubsM g) = SubsM (\cxt -> ?0)
06:34:27 <ski> soLucien : ?
06:34:45 <kuribas> like elemByElem (+) [1, 2] [3, 4] = Just [4, 6], or elemByElem (+) [1, 2] [3, 4, 5] = Nothing
06:34:54 <kuribas> or elemByElem (+) (1, 2) (3, 4) = (4, 6)
06:34:58 <lyxia> you create functions with \x -> ... and you apply them f x. And lambda calculus is born.
06:35:02 <soLucien> I can create one, yes
06:35:26 <ski> soLucien : .. don't go over the stream, to find water
06:35:59 <ski> the local context, in the hole `?0' in
06:36:02 <ski>   fmap f (SubsM g) = SubsM (\cxt -> ?0)
06:36:04 <ski> is
06:36:05 <kuribas> I am pretty sure something by ekmett would be applicable...
06:36:12 <ski>   f :: a -> b
06:36:18 <ski>   g :: Context -> Either Error (a,Env)
06:36:21 <ski>   cxt :: Context
06:36:44 <ski> and the desired type for the hole itself is given by
06:36:54 <ski>   ?0 :: Either Error (b,Env)
06:37:25 <ski> soLucien : this summarizes your "current situation" at the hole `?0'. the "current game state", if you will
06:37:50 <soLucien> yes, i understand ..
06:37:55 <ski> you have to pick a valid move in the game, at this point. hopefully one that leads to winning
06:38:17 <soLucien> so g someContext will give me a Either
06:38:35 <ski> soLucien : yes, but how to get that `someContext' ?
06:38:50 <soLucien> call a context-creating function ?
06:38:54 <soLucien> a helper function ?
06:39:19 <ski> soLucien : do you see how to get a value of type `Context', from the local variables whose type signatures where given above ?
06:39:24 <ski> s/where/were/
06:39:36 <soLucien> well cxt is one
06:40:10 <ski> yes :)
06:40:32 <ski> so, applying `g' to that input, gives a value of which type ?
06:40:43 <soLucien>  Either Error (a, Env)
06:40:47 <ski> right
06:41:08 <ski> but the desired type of your hole was `Either Error (b,Env)', which isn't quite the same
06:41:18 <soLucien> yes i need to apply f to b
06:41:24 <soLucien> f to a
06:41:36 <ski> (from your POV, `a' and `b' are to be treated as opaque abstract data types, not known to be identical, so you have to treat them as different)
06:42:05 <ski> so, you'll need to delve more into the `Either' part of your `g cxt :: Either Error (a,Env)'
06:42:10 <ski> agree ?
06:42:35 <soLucien> yes .. so if i pattern match the return of g cxt
06:42:51 <soLucien> i can get the a
06:42:52 <ski> that's the right idea :)
06:43:09 <soLucien> Left gives the same error
06:43:13 <hexagoxel> kuribas: like this? https://github.com/lspitzner/brittany/blob/master/src/Language/Haskell/Brittany/Config/Types.hs#L266
06:43:25 <soLucien> Right gives the new tuple
06:43:30 <ski> do you see how to try doing that ("pattern match the return of g cxt") ?
06:43:34 <ski> yes
06:44:24 <kuribas> hexagoxel: yeah, but for standard types, lists, tuples, etc...
06:45:26 <hexagoxel> kuribas: Applicative on ZipList provides your specific example
06:46:53 <ski> hexagoxel : not with the `Maybe' for non-matching structure
06:47:23 <soLucien> fmap f (SubsM g) = SubsM (\cxt -> h where
06:47:23 <soLucien>    if g cxt = Right (x,env) then h = Right ( f x, env)
06:47:23 <soLucien>    if g cxt = Left err then h = Left err
06:47:23 <soLucien>   )
06:47:38 <soLucien> i have no idea how to write it
06:47:40 * hackagebot hw-string-parse 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-string-parse-0.0.0.1 (haskellworks)
06:47:42 * hackagebot SFML 2.3.2.3 - SFML bindings  https://hackage.haskell.org/package/SFML-2.3.2.3 (sulami)
06:48:02 <ski> soLucien : you can either define a helper function, that pattern-matches
06:48:03 <kuribas> hexagoxel, ski: my idea was for something like unification in a logic language.
06:48:20 <ski> soLucien : or you can use a `case'-`of' expression to pattern-match directly
06:48:31 <hexagoxel> ski: right, but that seems to be specific to lists anyway; at least it makes no sense for other instances that come to mind.
06:48:36 <soLucien> case
06:49:00 <ski> kuribas : your `elemByElem (+) [1, 2] [3, 4] = Just [4, 6]' didn't sound like that :)
06:49:14 <kuribas> ski: I was going for a simple example.
06:49:21 <Mortomes|Work> Looks like a case of monads to the rescue to me.
06:49:22 <ski> hexagoxel : you could match trees by structure
06:49:24 <kuribas> perhaps too simple ;-)
06:49:51 <ski> soLucien : have you seen `case' yet ?
06:50:01 <ski> soLucien : have you seen `let'-`in' yet ?
06:50:12 <soLucien> i have , but don't remember the synthax off the top of my head
06:50:18 <soLucien> i'm looking at it\
06:50:21 <soLucien> as we speak
06:50:51 <ski> kuribas : my unification was something like `(=@=) :: Unifiable a => a -> a -> LP a'
06:51:07 <soLucien> seen it and used it, but i've only been doing haskell for less than 20 days
06:51:22 <kuribas> ski: and you defined Unifiable for the standard types yourself?
06:51:28 <ski> soLucien : should i sketch the two ways to do it ?
06:51:40 <soLucien> i'm on it 
06:51:47 <ski> kuribas : yes. also for my `LogVar' type
06:52:22 <ski> kuribas : did you see the "typing logical variables" (iirc) paper by Claessen, building on an earlier paper by Seres and Spivey ?
06:53:01 <kuribas> ski: my logic variables are very simple, they only represent numbers :)
06:53:04 <ski> soLucien : by "the two ways to do it" i mean just the two ways to effect the pattern-matching here. not the full solutions
06:53:27 <ski> kuribas : including numeric constraints ?
06:53:49 <kuribas> ski: the only constraints are equality constraints.
06:53:55 <ski> ok
06:54:08 <kuribas> it's metafont basically
06:54:15 <soLucien> instance Functor SubsM where
06:54:15 <soLucien>   fmap f (SubsM g) = SubsM (\cxt -> case g cxt of
06:54:15 <soLucien>    Right (x,env) -> Right ( f x, env)
06:54:15 <soLucien>    Left err -> Left err
06:54:15 <soLucien>   )
06:54:15 <hexagoxel> ski: true. requirements are unclear :p my CZip on the other hand is more polymorphic, which might not be desired for homogeneous structures.
06:54:22 <soLucien> still getting error
06:54:33 <soLucien> oh
06:54:33 <soLucien> \
06:54:37 <soLucien> it was the indentation
06:54:39 <ski> soLucien : yes, that's the right way to write what you pasted
06:54:49 <ski> soLucien : now, to fix the other problem
06:54:59 <ski> oh, sorry
06:55:04 <ski> no other problem
06:55:12 <soLucien> the other problem is the monad
06:55:21 <ski> (yes, you need to indent that closing bracket more)
06:55:21 <soLucien> which should now be easier to implement
06:55:48 <soLucien> i have pure/return, i have fmap
06:56:10 <ski> anyway, i'll just display the other way to write this, to show the possibilities to choose from
06:56:19 <ski>   fmap f (SubsM g) = SubsM (\cxt -> 
06:56:50 <ski>     let check (Left  err    ) = Left  err
06:57:07 <ski>         check (Right (x,env)) = Right (f x,env)
06:57:23 <ski>      in check (g cxt))
06:57:36 <ski> a variation of this is
06:57:37 <soLucien> i didn;t know of the 'check' function
06:57:44 <ski> well, i just defined it above
06:57:59 <ski> you can rename it to anything you like, perhaps `match' or `frobnicate'
06:58:11 <soLucien> FROBNICATE !!!
06:58:12 <ski> anyway, variation :
06:58:29 <soLucien> so check is the helper functon
06:58:30 <soLucien> function
06:58:35 <soLucien> for pattern matching the either 
06:58:44 <ski> yes
06:58:49 <nshepperd> frobnicate, the hacker's favourite function - it can do anything
06:58:50 <ski>   fmap f (SubsM g) = SubsM (check (g cxt))
06:58:53 <ski>     where
06:58:58 <ski>     check (Left  err    ) = Left  err
06:59:01 <ski>     check (Right (x,env)) = Right (f x,env)
06:59:26 <nshepperd> missing a \cxt -> there
06:59:36 <ski> er, you're right
06:59:42 <ski>   fmap f (SubsM g) = SubsM (\cxt -> check (g cxt))
06:59:43 <ski> or
06:59:51 <ski>   fmap f (SubsM g) = SubsM (check . g)
06:59:56 <ski> (using function composition)
07:00:37 <ski> btw, note that if `cxt' had been used in any of the bodies of the defining equations of `check', then you'd have needed to pass `cxt' as a separate argument to `check' here, since in this latter version, `check' isn't defined inside the `\cxt ->'
07:02:05 <ski> soLucien : makes sense ?
07:02:57 <soLucien> yes thank you ski
07:03:06 <soLucien> i have learned something today
07:03:51 <ski> soLucien : the main point of this is to being able to "follow the types", checking what's expected in a hole, and also checking how you can play with the local data you have available
07:05:20 <ski> soLucien : for more complicated things, you'll also have to apply some intuition about what you're actually trying to do. but "follow the types" works surprisingly often to a surprisingly large extent. it tends to work best for polymorphic operations, though
07:17:42 <ania123> ski
07:17:48 <ania123> ’a’ :: Char
07:18:02 <ania123> > ’a’ :: Char
07:18:05 <lambdabot>  <hint>:1:1: error: lexical error at character '\8217'
07:18:22 <ania123> what error is it?
07:18:35 <lyxia> > 'a' :: Char
07:18:38 <lambdabot>  'a'
07:18:40 <lyxia> your quotes
07:18:55 <lyxia> they're too fancy
07:19:08 <pavonia> > ord '’'
07:19:11 <lambdabot>  8217
07:28:29 <volhovm> hello! How do i fetchFromGithub if it's private gitlab repo?
07:28:44 <volhovm> And i have keys already installed in `.ssh/`
07:29:32 <byorgey> volhovm: is this a Haskell question?
07:29:53 <volhovm> No, sorry, missed the channel
07:29:54 <volhovm> :(
07:30:19 <byorgey> volhovm: ok, no worries =)
07:32:02 <simukis_> is there a variant of `toUpper :: Char -> String` which correctly handles `ß` -> `SS` conversion?
07:32:20 <lyxia> byorgey: have you tried testing-feat before? I found that it solves the same problem as generic-random, I just forgot about it until recently.
07:32:33 <simukis_> Data.Char.toUpper is Char -> Char and therefore cannot apply this conversion
07:32:52 <srhb> simukis_: toUpper :: Text -> Text may do this
07:33:17 <ph88> does someone wanna take a look at this haskell question?  https://www.reddit.com/r/haskellquestions/comments/551nzh/change_data_structure_content_and_structure_itself/
07:33:56 <simukis_> srhb: something that works from Char would be ideal
07:34:08 <byorgey> lyxia: I haven't tried it, though I know about it
07:34:13 <srhb> simukis_: I don't know of any, but you can convert your Char to Text first.
07:34:17 <byorgey> lyxia: it works by enumeration though, which I expect is O(n^2)
07:34:35 <simukis_> srhb: okay, I’ll check it out, thanks
07:34:37 <byorgey> though with clever memoization etc. it may be fast in practice, I am not sure
07:34:52 <srhb> simukis_: eg toUpper . singleton
07:35:06 <byorgey> it would be interesting to actually compare the performance of the two packages
07:35:28 <lyxia> That's what I had in mind too.
07:36:21 <byorgey> lyxia: also, it uses TemplateHaskell which seems more fragile than Generics, though it seems Jonas is still keeping the package up to date
07:37:38 <lyxia> Oh. Well it looks like I found another project to practice my Generics-fu on.
07:37:44 <byorgey> hehe
07:41:11 <lyxia> ph88: your traversals look like some uniplate and other *plates thing
07:47:41 * hackagebot ghc-typelits-natnormalise 0.5.1 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.5.1 (ChristiaanBaaij)
07:47:43 * hackagebot ghc-typelits-knownnat 0.2.2 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.2.2 (ChristiaanBaaij)
07:47:45 * hackagebot ghc-typelits-extra 0.2.1 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.2.1 (ChristiaanBaaij)
08:14:40 <benzrf> hey, i'm using hdevtools to get on-the-fly typechecking in vim, and i'm having an issue where it seems to just break when the file includes (or depends on another file that includes) certain usages of template haskell
08:15:05 <benzrf> and when i say "just break", i mean that it stops reporting any errors except for some really basic ones like nonexistent variables
08:18:39 <benzrf> is this a known issue?
08:20:38 <soLucien> ski in the case of the applicative for SubsM
08:20:46 <soLucien>   --(<*>) :: Applicative f => f (a -> b) -> f a -> f b
08:20:48 <soLucien> where
08:20:57 <soLucien>  newtype SubsM a = SubsM {runSubsM :: Context -> Either Error (a, Env)}
08:21:13 <soLucien> the f is not SubsM , but Applicative
08:21:16 <soLucien> right ?
08:21:20 <soLucien> the Applicative type
08:21:45 <soLucien> so what i have to do is wrap the computation in the Applicative
08:28:40 <jchia_> is there an analog of id in the type space?
08:31:48 <mnoonan__> jchia_: is this what you are after? https://hackage.haskell.org/package/type-functions-0.2.0.4/docs/Data-TypeFun.html
08:31:50 <monochrom> yes, look for Identity from Data.Functor.Identity (also re-exported by Control.Monad.Identity)
08:32:10 <jchia_> *->*, returns the same type as the input
08:33:18 <mnoonan__> monochrom, that isn't really the identity on * though
08:33:25 <lyxia> soLucien: f is SubsM. Applicative is a typeclass, not a type.
08:33:53 <mnoonan__> I think it sounds like jchia_ is after something more like a type family
08:34:08 <soLucien> so in the <*> i have to say what happens when f (a->b) is applied to f a 
08:34:18 <soLucien> where f is SubsM
08:34:54 <lyxia> yeah
08:41:16 <byorgey> jchia_: you can define   type Id a = a,  but it is not very useful, because type synonyms have to be fully applied
08:41:32 <byorgey> jchia_: so you cannot pass Id to another type expecting an argument of kind  * -> *
08:42:14 <byorgey> jchia_: the best you can do is use the Identity functor (which is a newtype), and then deal with wrapping/unwrapping the newtype constructor
08:42:50 <jchia_> Well, i'm trying to solve a problem with the last two lines here: lpaste.net/232876. The last two lines cause compilation error. The context is here: http://lpaste.net/232763. I'm trying to modify the code in the second link so that I can divide the same unit by itself to get back a regular Integral.
08:44:47 <lyxia> jchia_: Why are you defining instance of Rep for Int32
08:44:51 <jchia_> I thought I could do "toRep = TypeIdentity" and "toUnit = TypeIdentity", but maybe I should think about why the compiler is complaining "Not in scope: data constructor Int32"
08:44:52 <lyxia> jchia_: it should be for your units
08:45:22 <jchia_> I want to be able to divide Distance by Distance and get back Int32
08:45:37 <lyxia> ah
08:45:48 <lyxia> jchia_: toRep = id, toUnit = id
08:46:19 <lyxia> toRep and toUnit are just regular functions, not type-level
08:47:17 <soLucien> http://lpaste.net/2772336045935558656
08:47:24 <soLucien> what's wrong with my applicative?
08:47:41 <soLucien> if f is SubsM, then i should be able to pattern match a->b
08:47:47 <soLucien> and apply it using fmap
08:48:06 <soLucien> retutning the f b that is requider
08:48:10 <soLucien> required
08:48:13 <jchia_> lyxia: Seems to work, at least it compiles. I was not thinking clearly. Now it's obvious that toRep and toUnit are just regular functions
08:48:17 <jchia_> thanks
08:48:31 <lyxia> soLucien: func is not of type (a -> b)
08:48:31 <soLucien> it doesn't type check, but why?
08:48:53 <lyxia> soLucien: it has type Context -> Either Error (a -> b, Env)
08:49:14 <soLucien> i see
08:49:37 <lyxia> so when you use fmap, you would expect g to have type SubsM Context, and to result in type SubsM (Either Error (a -> b, Env))
08:49:42 <soLucien> i mean that's what the compiler is alsy saying
08:49:43 <soLucien> but why ?
08:49:58 <lyxia> because that's how you defined SubsM
08:50:34 <lyxia> the type SubsM has one constructor, SubsM, with a single field of type Context -> ...
08:50:34 <soLucien> in the applicative, you want to run a function f (a-> b) where f is SubsM
08:51:20 <lyxia> well it's not really a function. It's some value of type SubsM (a -> b)
08:51:35 <lyxia> (<*>) :: SubsM (a -> b) -> SubsM a -> SubsM b
08:51:40 <soLucien> yep
08:52:24 <soLucien> so wait. in order to create this Applicative
08:52:34 <soLucien> i have to somehow CREATE this a->b ?
08:52:40 <soLucien> then use fmap to apply it ?
08:52:43 <lyxia> no
08:52:49 <lyxia> don't try to use fmap
08:52:59 <lyxia> I'm not sure how you've come to that conclusion
08:53:09 <soLucien> well i looked at the types
08:53:13 <soLucien> from the applicative and fmap
08:53:43 <lyxia> well no, fmap is not the only way you can go from SubsM a to SubsM b
08:54:31 <soLucien> if i remember correctly
08:54:45 <soLucien> fmap gives a nondeterministic result
08:54:54 <soLucien> well that's in the list ..
08:55:05 <prsteele> you're mis-interpreting nondeterminism, I think
08:55:12 <prsteele> it doesn't mean 'random', it means zero or more results
08:55:20 <prsteele> in the context of lists
08:55:31 <soLucien> prsteele for the list there were 2 applicatives
08:55:35 <soLucien> a non-deterministic on
08:55:36 <soLucien> one
08:55:42 <soLucien> and one with the zipWith
08:56:23 <prsteele> I know they are described that way, so apologies if I'm muddying the waters, but here non-deterministic doesn't mean 'random'
08:57:57 <Cale> > [(+), (*)] <*> [2,3,5] <*> [10,100,1000]
08:57:59 <lambdabot>  [12,102,1002,13,103,1003,15,105,1005,20,200,2000,30,300,3000,50,500,5000]
08:58:11 <soLucien> exactly .. this uses fmap 
08:58:19 <Cale> That's using <*>
08:58:54 <soLucien> <*> is implemented using fmap 
08:59:08 <Cale> It might be...
08:59:22 <soLucien> so i wanted to do the same for my SubsM
08:59:32 <Cale> It's pretty natural to implement as a list comprehension: fs <*> xs = [f x | f <- fs, x <- xs]
08:59:46 <Cale> But you could also use concatMap a couple times
09:00:07 <soLucien> okay so my Applicative
09:00:18 <Cale> fs <*> xs = concatMap (\f -> concatMap (\x -> [f x]) xs) fs
09:00:24 <soLucien> for newtype SubsM a = SubsM {runSubsM :: Context -> Either Error (a, Env)}
09:00:26 <ertes> i'm writing a monoid tutorial, and early feedback is welcome: https://github.com/esoeylemez/tutorials/blob/master/Monoid.md
09:00:35 <Cale> and of course, the inner concatMap can be simplified
09:00:44 <Cale> fs <*> xs = concatMap (\f -> map (\x -> f x) xs) fs
09:01:39 <Cale> ertes: Feel free to steal my example :) https://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
09:01:56 <ertes> if anyone can think of interesting exercises regarding semigroup morphisms and perhaps an example of a *proper* semigroup morphism between two monoids that is *not* a monoid morphism, i'd like to hear about them
09:03:39 <ertes> Cale: the topmost comment?
09:04:08 <Cale> ertes: yeah, the comment I linked to, from cgibbard
09:04:32 <ertes> ah, it's highlighted
09:04:46 <barfoo> Is there a neat way to rewrite [ [ f ar bc | bc <- b ] | ar <- a ] when f is m1 b0 instead of b0?
09:05:18 <barfoo> sequence [ sequence [ f ar bc ....?
09:05:39 <ertes> Cale: explaining this monoid sounds like a good exercise in the "difficult" category =)
09:06:18 <barfoo> oh. sequence worked.
09:06:30 <barfoo> now I just need monadic versions of groupBy/sortBy etc.
09:06:45 <ertes> Cale: if i may, i'll just link to or quote that comment instead of just copying/rewriting your explanation
09:06:50 <Cale> Sure
09:07:35 <ertes> thanks =)
09:07:52 <soLucien> what should an Applicative do
09:07:55 <soLucien> in english ? :D
09:08:05 <soLucien> i mean in the case of SubsM
09:08:09 <soLucien> what could it do ?
09:08:10 <barfoo> hm no. sequence [ sequence doesn't work
09:08:22 <soLucien> newtype SubsM a = SubsM {runSubsM :: Context -> Either Error (a, Env)}
09:08:30 <soLucien> okay apply left is left .. cool
09:08:36 <soLucien> but on the right side
09:08:43 <soLucien> what would it do conceptually ?
09:08:57 <erisco> exist
09:09:39 <barfoo> also there's no syntax sugar for do { f <- bar; case f of ... so you can just write case bar of?
09:09:43 <ertes> soLucien: depending on whether Error is a Monoid there could be at least two valid Applicative instances
09:10:04 <soLucien> Error is a single error, it does nto get propagated
09:10:07 <soLucien> concatenated 
09:10:09 <soLucien> or anything else
09:10:10 <erisco> barfoo, maybe, depends if you have access to the constructors
09:10:13 <ReinH> barfoo: LambdaCase allows bar >>= \case
09:10:21 <ertes> barfoo: unfortunately not…  you could try to use -XLambdaCase together with (>>=), but it's rather ugly
09:10:28 <barfoo> Hm. ok. 
09:10:30 <soLucien> so i guess it's not a monoid
09:10:31 <ReinH> I like it
09:10:35 <soLucien> it's the first errors that occurs
09:10:44 <soLucien> oh hi ReinH
09:10:46 <ertes> soLucien: are you going to implement a Monad instance?
09:10:47 <soLucien> i implemented the fmap
09:10:49 <soLucien> yes
09:10:53 <soLucien> that is the point
09:10:55 <barfoo> Can you lift groupBy so that it accepts (a -> a -> m Bool)?
09:10:58 <soLucien> i need to implement the monad
09:11:01 <ertes> soLucien: then ignore what i said…  one of the two instances is not a monad
09:11:10 <erisco> :t groupBy
09:11:12 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
09:11:15 <erisco> no
09:11:20 <soLucien> but i thaught Applicative would maybe be easier
09:11:40 <soLucien> ReinH http://lpaste.net/2772336045935558656
09:11:47 <soLucien> i implemented the functor 
09:12:00 <soLucien> you said it's easier then the monad
09:12:05 <erisco> it is a bit unfortunate but there needs to be a second definition for the Monad version
09:12:09 <ertes> soLucien: there are at least two possible semantics for (Either e)…  one of them is only Applicative, but not Monad and requires 'e' to be a Monoid
09:12:11 <soLucien> and gives hints on how that is acheived
09:12:30 <ertes> soLucien: the other one has no constraints on 'e' and is a monad:  it's called "left catch"
09:12:31 <barfoo> there's Control.Monad.ListM though
09:12:48 <barfoo> are there perfomance implications when switching from groupBy to groupByM?
09:12:49 <soLucien> ertes i don't need to implement the applicative necessarily
09:12:54 <ertes> soLucien: you do
09:12:58 <soLucien> my purpose is the monad
09:13:01 <erisco> barfoo, yes
09:13:10 <soLucien> it used to be <*> = ap
09:13:13 <ertes> soLucien: you need to anyway, though you could use 'ap'
09:13:37 <soLucien> yes, but i was thinking that it may give a hint on how to implement the monad
09:13:40 <ReinH> func is not of type a -> b
09:13:48 <soLucien> i know, that's wrong
09:13:53 <ertes> soLucien: so if it's a monad, you don't have much choice:  you have a Context reader and an Env writer
09:14:02 <soLucien> yes
09:14:06 <ertes> together with a left-catch Either
09:14:17 <mnoonan__> ertes: There is a weird example that Tom Leinster once told me where Y is a rig, X is a subset of Y that does not include 0 or 1, yet X is also a rig (but with different additive and multiplicative identities)
09:14:36 <erisco> what's a rig
09:14:49 <mnoonan__> dumb pun: riNg without Negatives
09:14:50 <ertes> erisco: a ring without *n*egatives =)
09:15:00 * erisco *facepalms*
09:15:17 <mnoonan__> that's the appropriate response
09:15:38 <barfoo> yeah but I need to access my State inside the groupBy function
09:15:41 <soLucien> ReinH it is not , so i'll do the Monad instead and call this ap
09:15:47 <soLucien> but how ? 
09:15:59 <ertes> mnoonan__: i think that goes too far into math…  i'd like to keep the examples relevant to software engineering, at least to some reasonable degree
09:16:21 <erisco> can't have too much math in my programming
09:16:42 <hjulle_> Is there a way to make an alias for a set of constraints?
09:16:44 <mnoonan__> ertes: there might be a way to say it in terms of ADTs.. let me think a few minutes..
09:16:47 <ertes> otherwise i might find myself explaining affine spaces in that tutorial =)
09:17:09 <geekosaur> hjulle_, you can make a type alias, might need an extension though
09:17:18 <ertes> hjulle_: for concrete constraints you can just use tuple syntax with type synonyms
09:17:35 <ertes> hjulle_: type C a = (C1 a, C2 a, C3 a)
09:17:46 <geekosaur> that, yes
09:18:17 <geekosaur> hm, no extension I guess, it falls out of the weirdness where the Constraint kind is the same as * internallt
09:18:38 <soLucien> http://lpaste.net/2772336045935558656
09:18:44 <ertes> huh?  i would have expected it to need an extension
09:18:47 <soLucien> where do i go from here ?
09:19:08 <soLucien> should i use fmap in the >>= implementation ?
09:20:34 <geekosaur> ertes, I did too but last time someone asked we determined it didn't
09:20:48 <geekosaur> or at least didn't need the obvious ones
09:21:12 <hjulle_> ertes: Thanks
09:21:29 <geekosaur> I'm still a bit confused by that, and all I can figure is that the silent mapping of Constraint to * internally is what allows it to work
09:22:18 <hjulle_> geekosaur: It asked me to use Constraint kinds though.
09:22:25 <geekosaur> ah
09:22:39 <geekosaur> ok, guess it does then. or may depend on compiler version
09:22:43 <geekosaur> confusing
09:22:53 <barfoo> I can see ghc is still very sparse on details for parse errors
09:24:48 <ertes> mnoonan__: does this example need rigs?  because i wasn't going to go much further than groups, i.e. single functions
09:25:22 <ertes> and really only touch groups briefly, as they're not that important in the context of SE
09:26:22 <mnoonan__> ertes: yeah, I can't think of a way to do without; it involves equivalence classes in N[x] / (x = 1 + x + x^2).
09:27:13 <ertes> ouch…  yeah, that goes way too far =)
09:27:22 <soLucien> Am I on the right track ?
09:27:26 <soLucien> http://lpaste.net/2772336045935558656
09:28:17 <lyxia> yeah
09:28:40 <mnoonan__> ertes: on the elementary side, how about 2^X under union and the morphism f_y(x) = x `union` y?
09:29:38 <barfoo> rewriting a bunch of code that didn't use State nor I/O is complete PITA :(
09:31:58 <ReinH> soLucien: there is no g
09:32:17 <soLucien> it's f there
09:32:18 <ertes> mnoonan__: nice one, thanks…  that one is a proper semigroup endomorphism
09:32:18 <soLucien> sorry
09:32:23 <soLucien> i corrected it
09:32:36 <soLucien> apply f to the initial context
09:32:42 <soLucien> to get the current state
09:32:50 <soLucien> then i have to run g 
09:33:00 <soLucien> and return Right/Left
09:33:03 <soLucien> depending on the resutl
09:33:05 <soLucien> result
09:34:20 <ertes> (except when y = mempty)
09:35:48 <prsteele> hm. I have a computation which I can prove only terminates if throwExcept is used (Control.Monad.Except). I'd really like to not guard against the Right termination case, is there a more appropriate construct for modeling a computation that runs until explicitly halted?
09:38:11 <isovector> good morning -- is there a type-safe way i can get vacuous `Show` instances for the uninhabited instances of an open data family?
09:38:37 <dominik> Hi, what's the best way to turn an exception from the underlying base monad into an exception of the monad transformer that sits on top of the base monad?
09:39:13 <dominik> e.g. say I have a transformer like: `ExceptT Error IO a`
09:39:29 <dominik> and I want to lift a computation of IO into a computation inside this transformer?
09:40:14 <dominik> how can I then map exceptions being thrown in IO to exceptions inside my `ExceptT Error IO` monad?
09:41:41 <soLucien> http://lpaste.net/2772336045935558656 .. cannot parse this
09:41:56 <soLucien> please give me some suggestions ..
09:42:46 <barfoo> \o/. Done.
09:42:57 <barfoo> Let's just hope it doesn't screw up performance/laziness somewhere
09:43:18 <ertes> dominik: catch them
09:44:50 <ertes> dominik: but what's the point of the ExceptT?  it seems like you're just reinventing IO exceptions
09:45:58 <dominik> ertes: well, I'd like to convert certain IO error values to my custom `Error` type values.
09:46:51 <dominik> ertes: so you say something like "liftIO (potentiallyFailingIOAction ...) `catchError` (\err -> ...) will do the right thing?
09:47:25 <ertes> dominik: no, you need to 'catch' the IO error
09:47:44 * hackagebot yi-language 0.13 - Collection of language-related Yi libraries.  https://hackage.haskell.org/package/yi-language-0.13 (DmitryIvanov)
09:47:46 * hackagebot yi 0.13 - Yi editor  https://hackage.haskell.org/package/yi-0.13 (DmitryIvanov)
09:47:46 <dominik> ok, but then how, do I re-throw it?
09:47:48 * hackagebot yi-core 0.13 - Yi editor core library  https://hackage.haskell.org/package/yi-core-0.13 (DmitryIvanov)
09:47:50 * hackagebot yi-frontend-pango 0.13 - Pango frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-pango-0.13 (DmitryIvanov)
09:47:52 * hackagebot yi-frontend-vty 0.13 - Vty frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-vty-0.13 (DmitryIvanov)
09:48:56 <dominik> ertes: something like `liftIO $ potentiallyFailingIO `catchError` (\ioErr -> throwError <try to throw a transformed error>)` doesn't seem to be right either.
09:48:59 <ertes> dominik: you ExceptT-rethrow it:  liftIOWithExceptions c = ExceptT (fmap Right c `catch` (pure . Left))
09:49:30 <ertes> note that this turns *all* IO exceptions into ExceptT ones and assumes that Error = SomeException
09:49:33 <byorgey> soLucien: Your closing paren on line 55 is too far to the left
09:50:06 <dominik> ertes: thanks!
09:50:25 <dominik> ertes: isn't something like this provided out of the box though? Similarly to `liftIO` ?
09:50:33 <ertes> dominik: i think i haven't done you a favour though…  it seems like everything you're doing is covered by IO exceptions
09:51:16 <dominik> ertes: well, my actual use case is Servant, where I want to convert certain IO errors to corresponding Servant HTTP error messages.
09:51:38 <ertes> dominik: does servant use ExceptT?
09:51:57 <dominik> ertes: yes, a servant handler is defined by `Handler = ExceptT ServantErr IO`
09:52:16 <ertes> i see…  that's rather weird
09:52:33 <ertes> ExceptT is pretty much redundant if you have IO, too
09:52:54 * hackagebot yi-ireader 0.13 - Yi editor incremental reader  https://hackage.haskell.org/package/yi-ireader-0.13 (DmitryIvanov)
09:52:56 * hackagebot yi-keymap-cua 0.13 - Cua keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-cua-0.13 (DmitryIvanov)
09:52:58 * hackagebot yi-keymap-emacs 0.13 - Emacs keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-emacs-0.13 (DmitryIvanov)
09:53:00 * hackagebot yi-keymap-vim 0.13 - Vim keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-vim-0.13 (DmitryIvanov)
09:53:02 * hackagebot yi-misc-modes 0.13 - Yi editor miscellaneous modes  https://hackage.haskell.org/package/yi-misc-modes-0.13 (DmitryIvanov)
09:53:23 <dominik> ertes: you mean because of IO's custom definable user errors?
09:55:39 <ertes> dominik: i can't think of something you can do with ExceptT that you can't do with IO exceptions except "not using IO as the base monad"…  IO has a dynamically typed Either built-in with a rather powerful interface for catching
09:57:38 <dominik> ertes: hmm..
09:58:04 * hackagebot yi-mode-haskell 0.13 - Yi editor haskell mode  https://hackage.haskell.org/package/yi-mode-haskell-0.13 (DmitryIvanov)
09:58:06 * hackagebot yi-mode-javascript 0.13 - Yi editor javascript mode  https://hackage.haskell.org/package/yi-mode-javascript-0.13 (DmitryIvanov)
09:59:02 <soLucien> okay the parenthesis fixed it
09:59:08 <soLucien> but i get type error
10:05:06 <dominik> ertes: thanks anyways, your proposed error mapping works fine for me :-)
10:06:51 <mantovani> http://paste.scsys.co.uk/534589
10:06:54 <mantovani> at #java channel
10:07:04 <mantovani> how some stupid idiot can say that about Haskell ?
10:07:32 <hpc> :t fix$(<$>)<$>(:)<*>((<$>((:[{- J��r�� -}])<$>))(=<<)<$>(*)<$>(>>=)(+)($))
10:07:34 <lambdabot> error:
10:07:34 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ [a] -> [a]
10:07:34 <lambdabot>       Expected type: ([a] -> [a]) -> [a] -> [a]
10:07:41 <hpc> aha!
10:07:47 <hpc> clearly hello world is actually much harder than that
10:07:51 <hpc> ;)
10:08:11 <mantovani> 12:57 < edj> mantovani: Why do you think I program in Java?  ;)
10:08:14 <mantovani> 12:58 < mantovani> actually I think you don't program at all (but is just a guess I never would assume something like that)
10:08:17 <srhb> mantovani: Please don't take this here.
10:08:18 <mantovani> hahahahha
10:08:21 <mantovani> sorry
10:09:55 <soLucien> http://lpaste.net/2772336045935558656
10:09:59 <soLucien> am i getting any closer ?
10:10:03 <soLucien> ReinH ?
10:11:18 <ReinH> soLucien: once you have an `a', you can just apply g.
10:12:00 <soLucien>     Right (a, env) -> g a
10:12:00 <soLucien>  ?
10:12:06 <ReinH> Ask our compiler.
10:12:08 <ReinH> *your
10:12:12 <soLucien> not
10:12:26 <soLucien> it does not compile
10:12:56 <ReinH> what is the error?
10:13:09 <soLucien> Couldn't match expected type `Either Error (b, Env)'
10:13:09 <soLucien>                 with actual type `SubsM b'
10:13:18 <soLucien> so i have to pattern match it again
10:13:23 <soLucien> with left-right ?
10:15:06 <soLucien> but i can't pattern match functions
10:15:13 <soLucien> god dammit i have to execute again
10:17:02 <ReinH> soLucien: You're wrapping the SubsM constructor around it yourself
10:17:12 <soLucien> yes i am
10:17:15 <ReinH> so stop doing that
10:17:53 <ReinH> the a -> m b function will provide the context
10:19:13 <ReinH> Or match on the result of g yourself to unwrap the SubsM constructor
10:19:15 <ReinH> rather
10:19:23 <ReinH> don't do the first thing I said, do the second thing I said
10:20:25 <soLucien> yes i tried the first thing and i can't
10:21:26 <soLucien> ReinH the result is a function ..
10:21:32 <ReinH> The result is not a function.
10:21:39 <ReinH> The result is a SubsM b
10:21:46 <soLucien> g a returns a SubsM b
10:21:49 <soLucien> where b is a function
10:21:54 <ReinH> But SubsM b is not
10:22:09 <ReinH> SubsM b can be pattern matched
10:22:36 <ReinH> and `b' is not function either
10:22:49 <ReinH> A SubsM b value contains a function, but b is not necessarily a function type.
10:23:11 <soLucien> f >>= g = SubsM (\cxt -> case f cxt of
10:23:11 <soLucien>     Left propagateErr -> Left propagateErr
10:23:11 <soLucien>     Right (a, env) -> case g a of
10:23:11 <soLucien>       SubsM b -> b
10:23:11 <soLucien>    )
10:23:25 <ReinH> Does it compile?
10:23:30 <soLucien> in this case b is not a Either Error (b, Env)
10:24:00 <soLucien> it is a `Context -> Either Error (b, Env)'
10:24:03 <soLucien> no it does not
10:24:26 <ReinH> And how can you get an Either Error (b, Env) from a Context -> Either Error (b, Env)?
10:24:26 <soLucien> so again i probably have to execute it
10:24:33 <ReinH> and a Context
10:24:38 <soLucien> executing it with a Context
10:24:43 <ReinH> applying it
10:24:45 <ReinH> to a contet
10:24:50 <ReinH> context
10:24:51 <soLucien> yes.. applying it
10:24:54 <ReinH> and you have a context
10:25:14 <soLucien> i have the cxt, yes
10:25:19 <soLucien> but this is the next step
10:25:28 <ReinH> So apply b to the context
10:25:56 <soLucien> should i build a new context ? the 'next step context' from the result of applying f to cxt ?
10:26:02 <ReinH> You can't build a new context
10:26:11 <ReinH> There is no "next step context"
10:26:14 <ReinH> the context does not vary
10:26:50 <soLucien> a Context is type Context = (Env, PEnv)
10:26:55 <soLucien> where Env changes
10:26:57 <soLucien> every step
10:26:58 <ReinH> It doesn't matter what the type of context is
10:28:06 <ReinH> At least, I don't think it does, and you can write (>>=) without knowing what it is.
10:28:15 <ReinH> Maybe your instructor has a different idea, but they haven't made that clear
10:29:10 <hpc> i would expect the context to not change simply because it would make (>>= return) different from id
10:29:39 <soLucien> I see
10:29:49 <ReinH> hpc: Ah yes
10:30:01 <hpc> actually hang on, why is it f >>= g and not (SubsM f) >>= g?
10:30:44 <soLucien> it is now
10:30:46 <soLucien> and compiled
10:30:54 <ReinH> woo
10:31:06 <soLucien> instance Monad SubsM where
10:31:06 <soLucien>   return x = SubsM ( \_ ->Right (x, Map.empty ) )
10:31:06 <soLucien>   fail s = SubsM ( \_ -> Left (Error ("Failed to execute step " ++ s)))
10:31:06 <soLucien>   --(>>=) :: Monad SubsM => SubsM a -> (a -> SubsM b) -> SubsM b
10:31:06 <soLucien>   SubsM f >>= g = SubsM (\cxt -> case f cxt of
10:31:07 <soLucien>     Left propagateErr -> Left propagateErr
10:31:09 <soLucien>     Right (a, env) -> case g a of
10:31:11 <soLucien>       SubsM b -> b cxt
10:31:13 <soLucien>    )
10:31:16 <soLucien> should i stop doing this
10:31:20 <soLucien> and use lpaste instead? 
10:31:24 <MarcelineVQ> yes :>
10:31:26 <hpc> much yes
10:31:31 <hpc> very fo shizzle
10:31:34 <soLucien> ok my apologies
10:31:39 <hpc> wow, such paste ;)
10:34:05 <soLucien> thanks ReinH and hpc, i'll try to put this to work now
10:34:17 <hpc> one more thing i anticipate, actually
10:34:22 <hpc> is that you're throwing away env
10:34:59 <ReinH> This is a strange monad. I think you have to.
10:35:10 <ReinH> Wait
10:35:17 <hpc> unless Env is supposed to be some kind of state and PEnv is the reader
10:35:40 <hpc> in which case you do need to mess around with cxt and env to pass the right thing to b
10:35:47 <ReinH> This is equivalent to ReaderT Penv (StateT Env (Either Error)) a
10:35:49 <hpc> it's really hard to say
10:35:56 <hpc> yeah
10:35:58 <ReinH> since (a,b) -> c <=> a -> b -> c
10:36:12 <ReinH> So we *can* update the Env
10:36:21 <ReinH> This is just written in a stupid way that makes this non-obvious
10:37:13 <soLucien> yes the Env i believe
10:37:16 <soLucien> should be updated
10:37:18 <ReinH> And in a stupid way that allows this law-abiding instance that probably doesn't do what the instructor wants
10:37:30 <ReinH> Well, the state instance is arbitrary too
10:37:33 <ReinH> so that's a non-starter
10:38:20 <soLucien> this is an interpreter , SubsM is a step of the interpretation 
10:38:42 <joe9> I am building a shared haskell library to be used from C: Skb_stub.h:1:19: fatal error: HsFFI.h: No such file or directory -- is the error.
10:38:59 <soLucien> right now it seems that it only checks whether there's an error or not
10:39:02 <joe9> https://paste.pound-python.org/show/k4XZUP3Abp2504LZfYtd/ is the total error
10:39:28 <joe9> this works: TMPDIR=/tmp/ghc stack exec ghc -- --make -no-hs-main -optc-O2 test-libSkb.c skb.o -L. -I. -lSkb && ./a.out
10:39:50 <joe9> but, I cannot change the C program build to use ghc as above. Hence, want to to check how I can do the above using gcc.
10:41:04 <soLucien> During the interpretation of a SubScript program we need to keep track of a context
10:41:04 <soLucien> for the statements and expressions to be executed in. The context consists of two
10:41:04 <soLucien> parts: (1) a variable environment mapping variable names to values; and (2) a read-only
10:41:04 <soLucien> primitives environment mapping names of built-in functions and operators (primitives)
10:41:13 <soLucien> so basically this context is the scope
10:41:16 <soLucien> of the function
10:41:51 <soLucien> for example you can have a local variable x inside any function
10:41:55 <soLucien> this is not the same x
11:01:20 <ski> soLucien : great :)
11:02:00 <soLucien> ski but this monad
11:02:06 <soLucien> is not doing anything
11:02:12 <soLucien> i mean it's error checking
11:02:19 <soLucien> it's like the Maybe
11:02:22 <ski> it does "plumbing"
11:02:23 <soLucien> with error propagation
11:02:43 <soLucien> instead of the Nothing, you get an error
11:02:53 <soLucien> right ?
11:02:58 <ski> but using only `return' and `(>>=)', you can't build a non-trivially effectful action, correct
11:03:20 <ski> you need specific auxilary actions, apart from those afforded by `Monad', to be able to do anything interesting
11:03:31 <ski> (and something similar holds for `Applicative')
11:03:32 <soLucien> i would also need it to keep track of the environment
11:03:34 <soLucien> or the context
11:03:35 <soLucien> right ?
11:03:40 <soLucien> meaning update the env
11:03:56 <ski> yes, that's what somethings like `local' is good for
11:04:11 <MichaelK> Hi, quick sanity check: is (c1 = unsafeCoerce) always equal to (c2 = fmap unsafeCoerce), where c1, c2 :: Functor f => f a -> f b ?
11:04:33 <ski> `MonadReader Context SubsM' should be possible, e.g.
11:04:54 <soLucien> hmm shouldn't the bound function
11:05:01 <soLucien> also modify the env ?
11:05:12 <soLucien> if this monad is to keep track of state
11:05:31 <soLucien> then all state change should be implemented inside it
11:05:32 <soLucien> right ?
11:06:31 <soLucien> so if i do setAto10 >>= setBto11 >>= compareAandBforEquality it would say 'false'
11:07:00 <MichaelK> soLucien: how is state kept if instead we use (>>)? 
11:07:28 <ski> yes, but ultimately `setAto10' and `setBto11' and `compareAandBforEquality' would need to boil down some something *else* than `return' and `(>>=)' (in addition to those two)
11:07:39 <ski> soLucien ^
11:08:14 <ski> soLucien : "then all state change should be implemented inside it" -- actually changing the state would not be implemented by the operations of the `Monad' type class
11:08:48 <ski> the `Monad' type class only takes care of threading the state around in the intended sense, relying on you writing other operations to actually look at, or change, the state
11:08:59 <ski> and similarly for the environment, and your exceptions
11:09:22 <nitrix> MichaelK: The state can be kept even with >>. f >> g = f >>= \_ -> g
11:09:34 <ski> MichaelK : i think it's hard to even determine if, and in that case, when, your question is meaningful
11:10:19 <ski> soLucien : oh, actually your `SubsM' has no state. i forgot that
11:10:24 <nitrix> MichaelK: Consider  State MyState Result, \_ has type Result. MyState is carried around by >>=, even when you use >>
11:10:58 <ski> soLucien : if you want state as well, then you need to change the definition of `SubsM', or make a new type which includes it
11:11:41 <MichaelK> nitrix: sorry, that was meant to be a rhetorical question to show state can be "parallel" to 'a' in 'm a'
11:12:01 <ski> soLucien : anyway, implementing the operations in `Monad' for a type doesn't suffice to make a non-trivial monad. and similarly for `Applicative'
11:12:17 <MichaelK> ski: I'm casting to Any inside some structure
11:12:24 <nitrix> MichaelK: Never heard to terminology "parallel" to refer to this. I can't help further.
11:13:07 <MichaelK> ski: never mind, GADTs and the like kinda kill the idea
11:13:23 <ski> MichaelK : they do ?
11:14:28 <MichaelK> ski: data C a where Con :: Num a => C a; instance Num (C a)
11:17:04 <ski> MichaelK : but `C' isn't a functor, no ?
11:17:45 <ski> (also, itym `Con :: Num a => a -> C a')
11:17:51 <MichaelK> oh. yeah
11:18:25 <ski> since it's not a functor, i don't see why it would kill the idea
11:19:03 <MichaelK> you're right. hmmmm
11:19:05 <ski> the idea with `unsafeCoerce :: a -> b' is that you promise that `a' and `b' will be equal when you apply it (though the type system doesn't see it)
11:19:41 <ski> or, at least, that you go from an `a' to `Any' some number of times, and then back from `Any' to `b'
11:20:01 <ski> and `unsafeCoerce = id' in the first case, and `unsafeCoerce . ... . unsafeCoerce = id' in the latter case
11:20:48 <ski> and since `fmap id = id', `fmap unsafeCoerce' should be equivalent to `unsafeCoerce', assuming that both alternative uses satisfies the proof obligations
11:21:03 <soLucien> i was thinking of this as >> would reset the environment
11:21:14 <soLucien> to something empty
11:21:20 <ski> ideally, one'd have an equivalence between the proof obligation for one, and for the other, though i'm not immediately seeing that this must hold
11:21:26 <ski> soLucien : no
11:21:29 <MichaelK> ski: oh, that's a neat approach. so you're saying unsafeCoerce should commute when applied correctly?
11:21:34 <soLucien> while >>= would keep the state inside the monad
11:21:59 <soLucien> and change it depending on what the execution chain is saying
11:22:02 <ski> MichaelK : i'm saying that it should be `id', denotationally, when the proof obligations are satisfied
11:22:12 <soLucien> okay , so evrything happens somewhere else
11:22:49 <ski> MichaelK : just like `unsafePerformIO act' can be seen as having a proof obligation that `act' is denotationally equal to `return x', for some `x' (which then is what `unsafePerformIO act' evaluates to)
11:23:02 <MichaelK> ski: *nods* I'm trying to see how much I can do things like: let t = unsafeCoerce <$> (0, t) :: (Int, Any) before it blows up in my face with undecidable things
11:23:14 <ski> (this model promises nothing whatsoever (iow UB), in case the proof obligation here isn't fulfilled)
11:23:51 <ski> MichaelK> :t t
11:24:21 <ski> (itym s/undecidable/unsound/ ?)
11:25:02 <MichaelK> ski: it works in tests: t :: (Int, (Int, (Int, (Int,.... but only a finite section is viewed at any point
11:25:13 <MichaelK> (*some tests)
11:25:23 <ski> soLucien : `(>>=)' is the glue with which you can glue individual primitive actions together with, in a "dynamic sequence"
11:25:52 <ski> soLucien : it just propagates the effects appropriately, it doesn't actually introduce any (proper, non-trivial) effects by itself
11:25:58 <ski> similarly for `return'
11:26:23 <ski> MichaelK : oh, i missed the cycle there
11:26:23 <soLucien> okay , but each primitive one should take care of returning the correct env and context
11:26:36 <ski> MichaelK : ok, so this basically corresponds to an equi-recursive type, then
11:26:54 <ski> `nu r. (Int,r)'
11:27:01 <MichaelK> yeah, otherwise everything blows up in my face pretty quickly
11:27:08 <soLucien> so this is like a Maybe written in a fancy way
11:27:23 * ski isn't quite sure what soLucien means by "blows up in my face" .. UB ?
11:27:28 <soLucien> not me
11:27:45 <MichaelK> undecidable type equality
11:28:06 <ski> soLucien : "each primitive one should take care of returning the correct env and context" -- yes (though you don't return a context. you (possibly) *depend* on it)
11:28:32 <ski> MichaelK : i'm not sure how that is relevant ?
11:29:03 <ski> plain equi-recursive types aren't allowed in Haskell, period
11:29:25 <ski> but you could (allow and) consider them in a model where Haskell types gets interpreted
11:30:05 <ski> but `unsafeCoerce' defers typechecking, relying on you having done your back-of-envelope proof that it won't go wrong
11:30:53 <MichaelK> they're not allowed, but I'm seeing how much I can get. I think I might be able to get more or less automatic type equality (with Data.Type.Equality) for some simple cases 
11:31:15 <ski> (so there would no need to require an algorithm for deciding the equality between `a' and `b' in a use of `unsafeCoerce :: a -> b'. we're only requiring / relying on that you *have* a proof of the particular equality `a = b', not that you have an algorithm which can decide it in general)
11:31:41 <kalleklovn> why would anyone use haskell, python is vastly superior
11:31:45 * ski is possibly not on the same page as MichaelK, though ..
11:32:37 <oherrala> kalleklovn: you should try trolling a bit more harder than that :D
11:32:39 <ski> kalleklovn : you forgot to say, superior for which purposes/ends ..
11:33:28 <kalleklovn> python has a higher number of layers of integrated hierarchies over multiple domains, that works globally aswell as locally
11:34:35 <kalleklovn> i am a python developer
11:34:37 <MichaelK> ski: I'm doing something like this: Rec (c X) represents the type "c (c (c (c..". I can create the value like so: "let t = unsafeCoerce <$> c t in Rec c". If I'm lucky, I can make type classes to decide some instances of "Rec (c X) ~ Rec (d X)"
11:34:55 <soLucien> ski here's what one of my colleagues did 
11:35:03 <soLucien> i can't tell if his and mine are the same 
11:35:04 <soLucien> http://lpaste.net/1080542256173154304
11:35:51 <soLucien> i think he's actually changing the env
11:36:40 <ski> soLucien : oh .. that's definitely not the same
11:37:08 <soLucien> yeah it seems like the env is being swapped
11:38:05 <ski> soLucien : so, apparently out of the `Context', being `(Env,PEnv)' here, the `PEnv' part is what i would call an environment in the effectful sense, while the `Env' part there, together with the `Env' in the result pair type, actually implement a state, according to that paste
11:38:14 <ReinH> Yeah I think you're supposed to, but they've done a good job of making that hard to see.
11:38:29 <ski> soLucien : iow, there's no output/writer/logger of `Env', as i assumed earlier
11:38:38 <ReinH> ski: It's secretly ReaderT PEnv (StateT Env (Either Error )) a
11:38:49 <ReinH> They just jumbled it up in a confusing way
11:38:52 <ski> (soLucien : i didn't look closer at how `Context' was defined, so i didn't spot this)
11:39:07 <ReinH> ski: Indeed, defining Context only obfuscates this fact
11:39:07 <ski> ReinH : yes, i was just about to spell that out ?
11:39:12 * ski agrees
11:39:15 <soLucien> he got this from his friend who wrote his master thesis about haskell and types, so it must be correct
11:39:31 <ski> it's a correct `Monad' instance
11:39:32 <ReinH> It can be correct, but other things can be correct to
11:39:37 <ReinH> There are multiple correct instances
11:39:45 <ReinH> You have to divine the one your instructor intends you to write
11:40:08 <ski> but i'd argue collecting `Env' and `PEnv' together there into `Context' is a bit misleading, to a casual reader of the type
11:40:19 <ReinH> Yes, I assumed it was a weird ReaderT Context
11:40:32 <ReinH> That's a bad design.
11:40:46 <ReinH> Since it leads people to make wrong conclusions.
11:41:01 <ski> soLucien : one could express it as `PEnv' being a "read-only" part of the context, while `Env' is a "readable and writable" part of the context
11:41:14 <ski> soLucien : .. however, i would prefer to not express myself along those lines
11:41:33 <soLucien> yes
11:41:36 <soLucien> that is the case
11:41:39 <soLucien> so the env actually changes
11:41:43 <ski> (but i can imagine that the person writing this had something like that in mind behind using the name `Context' for `(Env,PEnv)')
11:41:45 <soLucien> across >>= s
11:41:45 <ReinH> It can change.
11:41:57 <ReinH> Yes, a new Context can be constructed from the old PEnv and the new Env
11:42:06 <soLucien> yes
11:42:07 <ReinH> but you aren't *required* to do so to have a valid Monad instance
11:42:12 <soLucien> that was what i was trying to say earlier
11:42:21 <ski> so, in the technical sense used when discussing monad transformers, the `Env' part doesn't form an environment, but a state
11:42:24 <soLucien> that i have to pattern match the context
11:42:29 <ReinH> So yeah, I think you really want to pattern match on the tuple that Context secretly is
11:42:30 <soLucien> to get the penv and swap the envs
11:42:35 <ReinH> yep
11:42:45 <ertes> type synonym spaghetti
11:42:47 <ReinH> and then construct a new one with tuple notation again
11:42:51 <ReinH> It's an awful type synonym
11:43:13 <ski> soLucien : ok, sorry if we didn't get this before
11:43:30 <ReinH> ski: I blame the instructor
11:43:57 <ReinH> exercises shouldn't be made artificially more difficult by shoddy question design
11:43:57 <soLucien> no worries
11:44:01 <soLucien> i have learned a lot
11:44:11 <ReinH> yay
11:44:20 <soLucien> i think it's very difficult for someone with no functional programming experience whatsoever
11:44:29 <soLucien> in his 3rd week of courses.
11:44:37 <ski> @quote blame.me
11:44:38 <lambdabot> OlinShivers says: My God, no one could blame me -- no one! -- if I went off the edge and just lost it completely one day.
11:44:45 <ski> @quote blame.haskell
11:44:45 <lambdabot> lennart says: [August 1990] DON'T BLAME HASKELL WHEN THINGS GO WRONG
11:44:47 <ReinH> heh
11:44:56 <ReinH> I mean, unless it's Haskell's fault.
11:45:12 <the_2nd> is it possible to define monoid on something where the average between two values is chosen?
11:45:13 <ski> would you argue with augustss ?
11:45:43 <ski> the_2nd : problem is that that's not associative
11:46:06 <soLucien> brb smoke
11:46:11 <the_2nd> ski, just noticed :/
11:46:47 <ski> the_2nd : perhaps you could replace `a' with `(a,a)', the minimum and maximum of the values seen so far. the obvious binary operation on that would be associative
11:47:09 <ReinH> and a monoid
11:47:16 <ReinH> or at least a semigroup
11:47:16 <the_2nd> I wanted to use monoid to mix colors, but I guess that simply wont make sense
11:47:20 <ertes> the_2nd: i'd go with a product monoid:  count number of items and the sum of the items
11:47:23 <ski> the_2nd : then at the end, you could perhaps take the average of the global result
11:47:34 <ertes> ski: min/max don't give you average though
11:47:40 <ski> yes, perhaps `Maybe (a,a)' instead
11:47:41 <ReinH> the_2nd: You can define a monoid that calculates the average
11:47:46 * hackagebot linked-list-with-iterator 0.1.1.0 - A pure linked list which is mutable through iterators.  https://hackage.haskell.org/package/linked-list-with-iterator-0.1.1.0 (CindyLinz)
11:47:47 <ski> ertes : i didn't say
11:48:53 <MichaelK> Is "type family F a b = c | b c -> a" still unsupported?
11:48:55 <ski> the_2nd : perhaps it would be nicer to keep track of the sum of all the values seen so far, tupled with a count of them. and then finally divide one by the other. then you'd actually get the average of all the individual values (with equal weight)
11:49:02 <ReinH> Take a sum and a count, then divide when you're done.
11:49:17 <ReinH> This also minimizes floating point error.
11:49:29 <ski> (what ReinH said)
11:49:36 <ReinH> And can be extended to other statistical measurements.
11:49:41 <ReinH> http://www.johndcook.com/blog/2016/06/08/computing-higher-moments-with-a-fold/
11:50:04 <ReinH> The foldl package lets you do this sort of thing nicely
11:50:45 <ertes> the_2nd: as said, you can use a product:  each color should also include a count
11:51:08 <dfeuer> Data.Distributive.collect smells of some Yonedaish modification of distribute. Is there some formal connection?
11:51:55 <ReinH> Then the fun question is: how do you make count a monoid? (Hint: if it's a monoid, there must be a way to calculate it from the free monoid, i.e., making a list of all the things you see.)
11:52:11 <ReinH> (assuming finite lists here, since the question is already non-sensical for infinite lists)
11:52:32 <dfeuer> Summing floating point stuff requires some care. Generally, you want to sum the small bits first.
11:52:33 <ertes> well, there must be a way to construct "unit" colours
11:52:54 <dfeuer> So  sum . sort  will be more precise than just sum.
11:53:10 <the_2nd> ski, ReinH I guess for my special usage case, this is fine : http://lpaste.net/232964
11:53:16 <dfeuer> But that, of course, won't be efficient.
11:53:18 <ReinH> (ok, no surprises here: the length of that list is the count)
11:53:21 <ski> hmm .. i wonder whether one could do a "delaying trick" with sums of floating-points ..
11:53:27 <the_2nd> since I dont't really want to mix many different currently
11:53:55 <ReinH> dfeuer: If the numbers differ significantly in magnitude, yes. Do these?
11:54:12 <dfeuer> ReinH, sorry, I only just saw the latest part of the convo.
11:54:30 <dfeuer> ReinH or ski, do you know about the distribute/collect question?
11:54:37 <ReinH> dfeuer: (This is related to the fun and surprising fact that a tree fold of floating point number is more accurate than a left- or right-fold)
11:54:48 <ski> dfeuer : what's that ?
11:54:50 <dfeuer> Tree fold?
11:55:09 <ReinH> (a+b)+(b+c) instead of a+(b+(c+d))
11:55:14 <ReinH> tree-shaped fold
11:55:40 <dfeuer> ski, https://hackage.haskell.org/package/distributive-0.5.0.2/docs/Data-Distributive.html  .  The MINIMAL methods are  distribute|collect. Is collect some Yonedaish modification of distribute?
11:55:49 <ReinH> Which is in turn related to the fun and surprising fact that a tree-shaped fold of Integers is asymptotically faster than a left- or right-fold.
11:55:57 <dfeuer> ReinH, ah, yes.
11:56:10 <ReinH> despite performing the same number of operations
11:56:16 <Rembane> A tree-shape is a binary tree?
11:56:25 <ertes> ReinH: i think you're making some ordering assumption
11:56:26 <ReinH> It's a binary operation, so yes.
11:56:32 <ReinH> ertes: Not at all.
11:57:10 <dfeuer> Oh, I guess just sorting is wrong.
11:57:11 <dfeuer> Hmmm.
11:57:19 <dfeuer> This actually sounds tricky!
11:57:41 <dfeuer> I vaguely remember some Price is Right game that feels related.
11:57:58 <ertes> ReinH: then i don't get it…  if the numbers are random, i don't see how (a + b) + (c + d) can be faster than a + (b + (c + d))
11:58:10 <ertes> … in general
11:58:14 <dfeuer> ertes, Integers get bigger as they get bigger.
11:58:22 <ReinH> Integers take longer to multiply as they get bigger
11:58:22 <amalloy> the numbers can be negative though
11:58:29 <dfeuer> sizeOf n ~= log n
11:58:29 <ertes> ah, now i see
11:58:43 <ReinH> Naively, it's O(nm) in the size of both integers.
11:58:57 <ReinH> GMP is a bit better
11:59:04 <ski> dfeuer : "Is collect some Yonedaish modification of distribute?" -- yes, due to how they relate via `fmap'
11:59:18 <ertes> yeah, understood…  i've actually done it myself for that exact reason
11:59:27 <ReinH> (negative integers get bigger as they get smaller, the size of the rep is proportional to log |n|)
11:59:35 <bollu> guys
11:59:41 <bollu> assuming I want to implement my own STG
11:59:44 <bollu> where do I start reading?
11:59:51 <ReinH> bollu: SPJ's book.
11:59:53 <merijn> bollu: The STG paper is pretty decent
11:59:58 <bollu> ReinH: which one?
11:59:59 <ReinH> And the eval/apply paper.
12:00:08 <kuribas> Is anyone interested in typography and haskell?
12:00:09 <ertes> ReinH: ok, anyway, the numbers in question weren't random…  you were still making a distribution assumption =)
12:00:09 <merijn> https://pdfs.semanticscholar.org/5c70/ed80977204a5b84f1f02764d6c3b5d9b8185.pdf
12:00:15 <bollu> merijn: the paper uses a lot of terminology I'm not super familiar with (it's the STG one right?)
12:00:16 <merijn> kuribas: Yes
12:00:30 <merijn> bollu: What terminology are you unfamiliar with?
12:00:30 <ReinH> @google SPJ the implementation of functional programming languages
12:00:32 <lambdabot> No Result Found.
12:00:35 <ReinH> really
12:00:40 <ertes> kuribas: i'm interested in both
12:00:51 <ReinH> ertes: I'm really not.
12:01:21 <ReinH> Well, unless one of the numbers is 0.
12:01:23 <dfeuer> ski, is it Yoneda or Coyoneda? I was playing with writing Distributive instances for length-indexed vectors, and there seemed to be a lot of fmap happening in naive distribute. collect (IIRC) looked better that way, but ended up building tail.(tail.(tail...)), which doesn't seem like the best order to compose that function.
12:01:37 <bollu> whoaa nice
12:01:43 <bollu> there's an entire book? sweet
12:01:44 <ReinH> Otherwise, the magnitude of the numbers strictly increases as you go up the tree
12:01:45 <kuribas> ertes, merijn: I am working on a truetype loading/writing library, I could use any help ;-)
12:01:47 <bollu> ReinH: is it expensive?
12:01:54 <ReinH> bollu: Is free expensive?
12:01:58 <ski> bollu : "The Implementation of Functional Programming Languages" by Simon Peyton Jones in 1987 at <http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/>
12:01:58 <ReinH> You can download it.
12:02:10 <merijn> kuribas: I'm only a bit familiar with the TrueType/OpenType formats
12:02:14 <ertes> ReinH: let the numbers be uniformly distributed between -100 and 100, then the optimisation doesn't make a difference and the way it has to be coded may make things worse (can't use lazy lists for example)
12:02:15 <ReinH> But maybe you have some ridiculous data fees ;)
12:02:28 <ReinH> ertes: why not?
12:02:34 <ReinH> And yes, you can use lazy lists.
12:02:41 <ski> ReinH : any handy abbreviation or other short term for that book title ?
12:03:12 <kuribas> merijn: so am I... However there is this:  https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html , and this:   https://www.microsoft.com/typography/otspec/otff.htm
12:03:15 <bollu> ReinH: thanks :)
12:03:15 <dfeuer> ReinH, so for most precise floating point addition, you presumably want to carry around something like a multiset? Take two minimal elements out, add them, and put the result back? Or is there a way to be even more clever about it?
12:03:22 <ski> dfeuer : `CoYoneda', i suppose
12:03:33 <merijn> kuribas: Yes, I implemented a parser based on the microsoft one in Go a few years back :)
12:03:37 <ertes> ReinH: but you have an extra cost now, because skipping is not free
12:03:52 <ReinH> dfeuer: If you're essentially doing symbolic arithmetic, why are you using floats at all?
12:04:03 <ReinH> ertes: skipping?
12:04:04 <ertes> ReinH: normally cheap, but in the context of adding integers the extra cost may very well outweigh the benefit
12:04:19 <ertes> ReinH: ah, nevermind
12:04:23 <dfeuer> ReinH, I'm doing symbolic arithmetic? You must be talking about something that happened earlier in the conversation....
12:04:36 <ReinH> ertes: Sorry, I wasn't specific enough.
12:04:36 <ski> dfeuer : `f b = exists a. (f a,a -> b)' if `Functor f'. also `f a = forall a. (a -> b) -> f b'
12:04:50 <ReinH> ertes: What I meant to say is: a tree shaped fold for the *product* of integers
12:04:55 <kuribas> merijn: I want something less low-level, but not less usefull..
12:05:04 <ReinH> Your objection is entirely accurate given my misstatement of the problem
12:05:28 <kuribas> merijn: more haskell-like datatypes.
12:05:28 <ertes> ReinH: ah, i was thinking of addition as a special case =)
12:05:32 <soLucien> okay so i modified it .. and it's cleaner this way http://lpaste.net/5986105836961792000
12:05:40 <ReinH> The magnitude of the integers has to monotonically decrease with depth (ignoring 0)
12:05:45 <ertes> mainly because the_2nd was talking about averages
12:05:52 <ReinH> ertes: ah yes, it's entirely my fault
12:05:58 <merijn> whats your goal?
12:06:46 <ertes> ReinH: i see a way to do it efficiently (i.e. with little extra cost) now, even for integer addition, if your tree is reasonably shallow
12:06:49 <kuribas> merijn: creating fonts
12:06:58 <dfeuer> ski, that doesn't really look the same as collect v. distribute, but I still feel like there's a connection. What am I missing?
12:07:15 <ertes> ReinH: but it requires mutation (a small mutable vector of running sums)
12:07:30 <merijn> kuribas: tbh, I don't think you want to do truetype/opentype directly if you wanna do that
12:07:44 <kuribas> why not?
12:07:59 <merijn> kuribas: have you looked at, e.g., metafont?
12:08:08 <ReinH> ertes: :) did I nerd snipe you?
12:08:33 <ReinH> dfeuer: I mean: if you're keeping a structure of future operations around, you're more or less doing this symbolically
12:08:38 <kuribas> merijn: I am implementing metafont :-)
12:08:41 <ertes> ReinH: depends…  what does "nerd snipe" mean? ;)
12:08:54 <ReinH> ertes: cause you to become intereted in a problem at the expense of other more important tasks
12:08:58 <ReinH> *interested
12:08:58 <merijn> kuribas: ah.. :)
12:09:07 <kuribas> merijn: Actually because metafont doesn't support truetype, or any modern format.
12:09:24 <merijn> ertes: https://www.xkcd.com/356/
12:09:33 <ertes> ReinH: ah, then no, not at the expense of more important tasks =)
12:09:51 <kuribas> merijn: and as DSL in haskell, the metafont language is pretty arcane.  I doubt anyone actually understands it.
12:09:56 <ReinH> dfeuer: If you care so much about lower error magnitudes that you're willing to throw away most of the benefit of floating point math by storing and operating on structures representing operations to be performed, why not go fully symbolic?
12:10:22 <merijn> kuribas: I think you'll have a hard time making opentyoe "clean"
12:10:40 <ertes> hahaha
12:11:20 <merijn> kuribas: the format is well documented, but it has lots of real world mess in it, so I think the approach to defining haskell datatypes for it is: suck it up, sadly
12:11:35 <kuribas> merijn: something in between, I suppose.
12:11:38 <dfeuer> ReinH, oh, I see. Well, there are actually reasons. Not everything has a nice closed form, and giving it as the limit of some strange process or other may not be so hot. Also, sometimes someone might give you floating point *measurements*, in which case that's all you've got.
12:12:20 <dfeuer> I guess you could always convert them all to Rational and work that way, but you might run out of memory.
12:12:21 <kuribas> merijn: preferably something someone could use without having to look up the spec.
12:12:54 <ReinH> dfeuer: Right, but you can put an escape hatch in your symbolic representation for "Ok fine this is just a float" ;)
12:13:14 <ertes> ReinH: you know, what's worse than nerd sniping?
12:13:19 <ReinH> ertes: ?
12:13:25 <ertes> :t \mx -> case mx of x : _ -> Just x; _ -> Nothing  -- this is a social experiment
12:13:27 <lambdabot> [a] -> Maybe a
12:13:28 <merijn> kuribas: I'm a bit slow atm, as the cat has claimed my irc keyboard :p
12:13:47 <ski> dfeuer : `forall f a. Functor f => f (g a) -> g (f a)  =  forall f a. Functor f => (exists b. (f b,b -> g a)) -> g (f a)  =  forall f a b. Functor f => (b -> g a) -> f b -> g (f a)', not just interchange `a' and `b'
12:13:50 <ReinH> ertes: go on
12:13:54 <ertes> ReinH: when i make you think about a problem and prevent you from responding to it, because i wrote "this is a social experiment" =)
12:14:06 <ReinH> god damn it
12:15:10 <dfeuer> ski, ah, so it's Yoneda rather than Coyoneda?
12:15:49 <dfeuer> Er...
12:15:50 <dfeuer> No,
12:15:54 <dfeuer> I confused myself.
12:16:10 <kuribas> merijn: no problem
12:16:12 <dfeuer> Coyoneda.
12:16:28 <dfeuer> er....
12:16:31 <dfeuer> Wait a sec.
12:17:04 <merijn> kuribas: tbh, I have similar design issues with a graph file format and optional fields, etc. I haven't come up with a decemt solution yet
12:17:32 <kuribas> merijn: https://github.com/kuribas/haskell-truetype/blob/master/Data/Truetype.hs
12:17:34 <dfeuer> Those things look very similar.
12:17:43 <kalleklovn> hey, i am watching my neighbours daughter and i had to change her diaper, i sorta just touched her pussy and checked it out it was great i wanna do it again, is it legal? I dont see the harm
12:18:03 <bollu> how does one intuitvely implement the type liftFree :: Functor f => f a -> Free f a
12:18:08 <dfeuer> @where ops
12:18:09 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
12:18:23 <ReinH> Intuition is overrated.
12:18:34 <bollu> ReinH: ehh, really>
12:18:43 --- mode: ChanServ set +o monochrom
12:18:52 --- mode: monochrom set +b *!*@51.174.19.26
12:18:52 --- kick: kalleklovn was kicked by monochrom (kalleklovn)
12:18:53 <ReinH> Except when it comes from practice.
12:18:59 <merijn> kuribas: looks reasonable enough
12:19:01 <bollu> ReinH: I think "plug in the types" is a bad heuristic for this sort of thing
12:19:08 <bollu> ReinH: I want to sort of.. "feel" the implementation
12:19:12 --- mode: monochrom set -o monochrom
12:19:15 <bollu> why does liftFree look the way it looks?
12:19:19 <johnw> dfeuer: hello?
12:19:24 <kuribas> merijn: things like compacting the bezier definitions is done by the library.
12:19:28 <dfeuer> johnw, just needed an operator.
12:19:28 <ReinH> Because if it looked some other way, it wouldn't be liftFree.
12:19:31 <johnw> dfeuer: ah, I see
12:19:36 <ertes> bollu: try to write a different implementation
12:20:13 <ReinH> Sometimes there really is an obvious way to do something, and sometimes that is actually the only way to do something (up to bottoms).
12:20:21 <ReinH> In some sense, this *is* the intuition for free objects.
12:20:40 <bollu> ReinH: I.. see :P I think I get where you're coming from (put as much structure as needed, no more)
12:21:16 <joe9> is it ok to build a shared library (.so) file using cabal? ghc builds a .so file fine from the command line, but, I keep getting some issues when i add "ghc-options: -dynamic -shared -fPIC" to the .cabal file for building the library.
12:21:57 <joe9>  https://paste.pound-python.org/show/iYUIw9VBXeVpe9lQLcy6/ 1st issue is with ghc-options: -dynamic -shared -fPIC
12:22:03 <ertes> bollu: the intuition is that liftFree is the function that constructs single-layer actions
12:22:06 <joe9> 2nd issue is with : -shared -fPIC
12:22:24 <ertes> bollu: where by "action" i mean "a value of type (Free F a) for some 'a'"
12:22:53 <ertes> bollu: that's why the outer layer is Free, while the inner (or "result") layer is Pure
12:23:16 <ertes> then you would typically use (>>=) to cascade those layers
12:23:22 <kuribas> merijn: I changed some bitvalues to sum types when possible.
12:23:50 <ertes> bollu: for most functors that are used in practice you can read "layer" as "command"
12:24:59 <kuribas> merijn: funny thing is some are defined by microsoft only, some by apple only.
12:25:10 <bollu> ertes: hmm, thank you for the intuition! :)
12:25:17 <bollu> ertes: much appreciated
12:25:29 <ertes> bollu: i hope it works for you…  certainly doesn't for everybody =)
12:25:29 <merijn> kuribas: yes, they merged their own two formats into a single one
12:25:41 <bollu> ertes: yes, It seems to make things clear for me
12:26:13 <kuribas> merijn: I am not sure if I should support all the glyph mappings, or just the ones for unicode...
12:26:55 <kuribas> Like 8 bit only makes sense for old iso- encodings, mixed 8/16 for japanese/chinese.
12:27:08 <merijn> kuribas: I'd start with just unicode and add support for old stuff later
12:27:24 <merijn> kuribas: Presumably you care more about generating new fonts than generating fonts for old systems
12:27:29 <kuribas> yes
12:29:10 <ertes> bollu: if you look at Free (the constructor) itself, (Free :: f (Free f a) -> Free f a), you could view the (f (Free f a)) is the "f of futures"…  a Pure is an action that is already done, i.e. has no future
12:29:31 <ertes> you can lift any 'f a' to an "f of futures" that has no future:  fmap Pure :: f a -> f (Free f a)
12:29:59 <ertes> then you can hand that to Free, giving you an action with no future actions
12:30:02 <kuribas> merijn: legacy encodings, unicode etc,  it's all pretty boring stuff...
12:30:20 <kuribas> merijn: Some of it is interesting, but a lot isn't...
12:30:27 <merijn> word:)
12:30:53 <ertes> bollu: of course the "future" analogy only works for set-of-commands-like functors
12:34:55 <joe9> for this command, is there any of getting the -lHSrts-ghc8.0.1 automatically or from a script? TMPDIR=/tmp/ghc stack exec ghc -- -O2 -dynamic -shared -fPIC -o libSkb.so Skb.hs skb.c -lHSrts-ghc8.0.1
12:35:43 <Tuplanolla> This sounds familiar, joe9. Let me take a look.
12:36:32 <joe9> Tuplanolla: I am trying to build a haskell shared library to be usable from C. I cannot get it to build from cabal. I cannot add -shared -dynamic -fPIC to ghc-options of library in the cabal file.
12:36:45 <joe9> Tuplanolla: Just want to check if you were able to get this to work from cabal.
12:36:54 <monochrom> joe9: If you use cabal, try my http://www.vex.net/~trebla/haskell/so.xhtml#cabal
12:37:05 <Tuplanolla> Here's how I did it, joe9: https://github.com/Tuplanolla/ld-prehaskell
12:37:30 <Tuplanolla> It's not the best, but works.
12:37:55 <joe9> monochrom: Tuplanolla, Thanks a lot guys. I have been struggling with it since morning.
12:38:17 <soLucien>   return x = SubsM ( \context -> let (e, penv) = context in Right(x, e))
12:38:24 <soLucien>   return x = SubsM ( \_ ->Right (x, Map.empty ) )
12:38:32 <soLucien> they are not quite right the same thing
12:38:51 <soLucien> i don't get what is happening in the first one
12:39:33 <soLucien> so let (e, penv) = context is pattern mapping
12:39:45 <joe9> monochrom: That is exactly the guide I followed. the issues are that the configure script there fro some reason does not create the buildinfo file.
12:40:12 <soLucien> then Right (x,e) is creating it and returning it
12:40:20 <soLucien> with e from the context
12:40:32 <soLucien> however, in a return i'm supposed to lift the function
12:40:34 <joe9> monochrom: and, the created .so file does not have the __stginit_skb function defined (That symbol is left undefined)
12:40:35 <Tuplanolla> As the name suggests, my use case involves LD_PRELOADing a Haskell library, so it probably breaks when deployed as a package, joe9.
12:40:45 <soLucien> into the monad context
12:40:57 <monochrom> do you have "build-type: Configure"?
12:41:13 <joe9> Tuplanolla: ok, Thanks. will keep that in mind. I could probably use the methodology.
12:41:25 <soLucien> so is the second one correct as well ?
12:41:47 <joe9> monochrom: Let me push the build contents to github, so, it can give you the full info. I need some 10 or so minutes to do that.
12:42:20 <Tuplanolla> Pardon the lack of documentation too, joe9. I just slapped my keyboard until it worked and by that time I was already sick of it.
12:42:33 <soLucien> return is the same as pure
12:42:56 <soLucien> so it should always return the same thing
12:44:34 <joe9> monochrom: https://github.com/joe9/skb/blob/master/skb.cabal is the cabal file. I do not see any output from the configure script though (permissions are +x)
12:44:52 <joe9> monochrom: is the dir listing https://paste.pound-python.org/show/lVQvbMpq3fahhKS9K2zq/
12:45:11 <soLucien> ski or reinh ?
12:47:17 <joe9> monochrom: nothing for this command: find . -iname skb.buildinfo
12:47:18 <joe9> - ( 0  ~/dev/apps/wayland/skb  master ) -
12:47:47 * hackagebot pushme 2.0.1 - Tool to synchronize directories with rsync, zfs or git-annex  https://hackage.haskell.org/package/pushme-2.0.1 (JohnWiegley)
12:47:49 <joe9> Tuplanolla: ok, Thanks for sharing. as long as it works, I think I can figure it out.
12:47:49 * hackagebot pushme 2.0.2 - Tool to synchronize directories with rsync, zfs or git-annex  https://hackage.haskell.org/package/pushme-2.0.2 (JohnWiegley)
12:47:52 * hackagebot rethinkdb 2.2.0.7 - A driver for RethinkDB 2.2  https://hackage.haskell.org/package/rethinkdb-2.2.0.7 (codedmart)
12:48:06 <ski> soLucien : "i don't get what is happening in the first one" -- it is passing (/threading) on the state `e', while ignoring the environment `penv'
12:48:19 <soLucien> i got it
12:48:19 <joe9> monochrom: if you notice, I added echo statements to configure, but, I do not get any output.
12:48:27 <soLucien> it is the same as   return x = SubsM ( \(env, penv) -> Right (x, env) )
12:48:32 <soLucien> and i think more correct
12:48:38 <joe9> monochrom: makes me wonder if configure is running properly.
12:48:53 <soLucien> however, i am not sure whether it is correct as a return statement
12:49:00 <soLucien> because the env changes
12:49:14 <monochrom> DId you issue the command "cabal configure"?
12:49:31 <ski> soLucien : "so is the second one correct as well ?" -- depends on whether you want the parts typed by `PEnv' to behave as a state, or as an environment, and an (unrelated) accumulation/writer/logger
12:50:09 <soLucien> my first one was   return x = SubsM ( \_ ->Right (x, Map.empty ) )
12:50:19 <ski> soLucien : judging from the paste from your colleagues, they wanted the former
12:50:19 <soLucien> so in this one
12:50:28 <joe9> monochrom: and the created .so file https://paste.pound-python.org/show/L2ATPGrEr2HpeJ2ewx4z/ does not have __stginit_Skb or __stginit_skb
12:50:32 <soLucien> in this one the context is irrelevant
12:50:33 <ski> .. whee
12:50:47 <joe9> monochrom: but it has this __stginit_skbzm0zi1zi0zi0zm9F2JxDgccgY3rofjiwKExF_Skb
12:51:01 <soLucien> the environment is a empty map
12:51:01 <joe9> monochrom: not sure if that would be the same as __stginit_skb
12:51:12 <monochrom> DId you issue the command "cabal configure"?
12:51:24 <joe9> monochrom: TMPDIR=/tmp/ghc stack build --file-watch
12:51:26 <ski> soLucien : `\context -> let (e, penv) = context in Right(x, e)' is basically the same as `\(env, penv) -> Right (x, env)' (the only difference is in strictness properties)
12:51:35 <joe9> monochrom: I just did that. did not run the cabal configure.
12:51:47 <monochrom> I don't know stack and I don't know how much it respects cabal conventions.
12:51:51 <joe9> monochrom: I am under the impression that stack does that.
12:51:57 <soLucien> i thaught they are equal
12:52:00 <joe9> monochrom: ok, will try cabal configure
12:52:04 <soLucien> i'll google strictness properties
12:52:52 <ski> soLucien : you need to tell, when you say "the environment" if you mean the environment in the monad transformer sense (which would be (only) `PEnv' here). or if you perchance mean `Env', or perhaps both of them
12:52:55 <joe9> monochrom: cabal configure:  https://paste.pound-python.org/show/Ky5s1Ur2StCfJZNfxUt2/
12:53:13 <ski> (since clearly there's conflicting terminology is use here)
12:53:14 <joe9> monochrom: I have ghc-7.10.3 system-wide, but, stack was using ghc-8.0.1
12:53:16 <soLucien> when i say environment i mean env
12:53:18 <joe9> monochrom: for this build
12:53:54 <joe9> monochrom: but, atleast it seems to be running configure as I see the echo statements.
12:54:39 <ski> soLucien : re strictness, with `\(x,y) -> ..x..y..', the function will start by forcing the input pair, while with `\xy -> let (x,y) = xy in ..x..y..', it will only force the input pair when any of `x' and `y' are actually forced/demanded
12:54:59 <ski> soLucien : .. often you wouldn't care that much over that difference
12:55:33 <soLucien> i think the let synthax is confusing
12:56:28 <ski> soLucien : btw, `\xy -> let (x,y) = xy in ..x..y..' is the same as `\xy -> ..(fst xy)..(snd xy)..'
12:56:54 <soLucien> oh .. i don't really see the difference
12:57:16 <soLucien> i like the `\(x,y) -> ..x..y..' more
12:58:37 <joe9> monochrom: after running the "cabal configure" command, now the stack clean && build is running the configure.
12:58:45 <joe9> monochrom :https://paste.pound-python.org/show/aPwkkJu7mFoI56XnVTg6/
12:59:16 <joe9> monochrom: https://paste.pound-python.org/show/nynkuL9vmy0MK97Nzsnl/
13:02:43 <joe9> monochrom: I can add the lib dir to the configure
13:06:00 <monochrom> This is strange because I don't run into the "Missing C library" error.
13:07:29 <monochrom> using -v3 I can see that cabal automatically adds -L/usr/local/haskell/ghc-8.0.1-x86_64/lib/ghc-8.0.1/rts whenever it calls gcc so HSrts-ghc8.0.1 should always be found successfully
13:07:43 <joe9> monochrom: let me try the -v3
13:08:07 <joe9> monochrom: are you trying through cabal or stack? are you cabal configure?
13:08:38 <joe9> monochrom: for some reason, stack does not detect changes to the configure file. I have to run cabal configure and then stack build.
13:08:39 <monochrom> In fact you see that I put my GHC in a non-standard location so you can't chalk it up to "non-standard location"
13:08:44 <monochrom> cabal configure -v3
13:09:15 <monochrom> I don't understand stack, and every minute lurking on #haskell decreases my incentive to.
13:09:31 <joe9> monochrom: but, cabal configure should not work as I have ghc 7.10.3 in my system wide install. but, stack is using ghc-8 for this package.
13:09:47 <joe9> monochrom: oh, I ran into the cabal hell and lost a week
13:10:00 <joe9> monochrom: and, then I gave up on cabal and stack has been awesome since.
13:10:10 <joe9> monochrom: this is the first time I had an issue with stack.
13:10:44 <monochrom> stack is like windows
13:10:45 <joe9> monochrom: even, then it is something that there are alternatives. With cabal, once I ran into the issues, I could not get out.
13:11:14 <cocreature> jle`: just out of curiosity: do you know of anything specifically missing from tensor-ops that’s stopping someone (e.g. myself :)) from implementing an accelerate backend or have you simply not gotten around to looking into it?
13:11:17 <joe9> monochrom: stack has been good. I think when working with the latest packages, it is a god send.
13:12:34 <laudiacay> hey does anyone see a pretty way to eta reduce the following: map ($ x) [f, g, h]
13:12:44 <joe9> monochrom: https://paste.pound-python.org/show/tlnIMhQaugIT3dStSTER/ this is with cabal configure -v3. It is probably not that useful as stack and cabal are using different versions.
13:12:57 <laudiacay> i'm re-implementing filter to take a list of filters, for context
13:13:09 <hvr> joe9: what problems do you encounter with latest packages when using cabal?
13:13:44 <leshow> does anyone here actually use the 'backbird combinator' in code they write
13:13:50 <leshow> i saw some youtube video on it
13:13:54 <joe9> hvr: I cannot recall. I ran into the package dependency issues when trying to aeson with some other packages. I tried fixing it for a week and then gave up and stack has been well.
13:14:36 <cocreature> laudiacay: I’m not sure how you want to eta reduce that. eta reducing means turning \x -> f x into f but you don’t have something like x here
13:15:16 <laudiacay> cocreature: i want the x to go away- sorry, i didn't include the function. it should be filterAll ls x = map ($ x) ls
13:15:25 <laudiacay> and I want to eta-reduce away the x
13:15:28 <Rembane> laudiacay: Can you use a fold to turn the list of functions into one function?
13:16:23 <laudiacay> Rembane: not really sure what a fold is, but i /think/ that's what I was doing before. we're supposed to use map in this iteration of the assignment... and I have that solution above, i just want that x to go away so it's prettier haha
13:16:47 <cocreature> @pl \x -> map ($ x) [f, g, h]
13:16:47 <lambdabot> flip map [f, g, h] . flip id
13:16:56 <laudiacay> this is optional work so don't worry, y'all aren't getting my grades for me
13:16:58 <cocreature> (don’t use that)
13:17:01 <laudiacay> cocreature: what is that?
13:17:16 <laudiacay> i'm sorry i've been haskelling for 3 days total
13:17:17 <MichaelK> Hi, why aren't wildcards allowed in instance declarations? It's easy enough to bypass and get the derived type anyway
13:17:19 <leshow> what does @pl do
13:17:25 <grantwu> @help pl
13:17:25 <lambdabot> pointless <expr>. Play with pointfree code.
13:17:31 <leshow> cool
13:17:36 <laudiacay> what does pointfree mean?
13:17:39 <laudiacay> @help pointfree
13:17:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:17:40 <leshow> lol
13:17:42 <laudiacay> oh
13:17:46 <leshow> means without points
13:17:50 <leshow> :P
13:17:51 <cocreature> @pl transforms code into a so called “pointfree” form that doesn’t mention the parameter on the left side of the definition
13:17:52 <lambdabot> (line 1, column 35):
13:17:52 <lambdabot> unexpected '\128'
13:17:52 <lambdabot> expecting variable, "(", operator or end of input
13:18:04 <cocreature> leshow: nah pointfree usually has more points in haskell :)
13:18:30 <laudiacay> dont 100% get it, but i think i at least have an idea
13:18:51 <cocreature> lambdabot: but tbh, in your case I really wouldn’t use it
13:18:53 <laudiacay> so are y'all saying there's no really elegant way to eta reduce that thing above? 
13:18:55 <cocreature> eh ^ laudiacay 
13:19:00 <cocreature> yep
13:19:01 <leshow> \x -> f g x == f . g
13:19:04 <laudiacay> could i maybe use flip?
13:19:06 <cocreature> sometimes a lambda is just prettier
13:19:06 <laudiacay> idk
13:19:10 <leshow> thats the pointfree form of that function
13:19:13 <laudiacay> yeah doesn't matter :) 
13:19:17 * erisco 's client lights up like a Christmas tree
13:19:18 <laudiacay> thanks though for the help
13:19:49 <cocreature> you can use flip like lambadbot showed but imho the cases where flip actually makes code easier to read are pretty small
13:19:59 <lyxia> you're using "eta-reduce" to mean "make this definition pointfree"
13:20:29 <leshow> foldl (flip (:)) 
13:20:35 <laudiacay> i still don't entirely get pointfree :(
13:21:13 <erisco> neither do I
13:21:35 <lyxia> the parameter x in your function is what is sometimes called "point", and a pointfree definition is one without such a point.
13:21:37 <grantwu> by "get" do you mean "understand how it works" or "understand why anyone would write completely pointfree code"
13:22:03 <koz_> grantwu: Oddly, the more Haskell I write, the more pointfree my style becomes.
13:22:11 <Tuplanolla> Think of "points" as points in the "type space", not orthographic points in the source code.
13:22:14 <koz_> Like, a lot of my simpler functions fall into that style naturally.
13:22:43 <leshow> @pl \f g (a,b) -> (f a, g b)
13:22:43 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
13:22:44 <leshow> lol
13:22:49 <leshow> so much easier to read
13:23:10 <koz_> leshow: Lol.
13:23:20 <erisco> :t \f g (a,b) -> (f a, f b)
13:23:22 <lambdabot> (t2 -> t1) -> t -> (t2, t2) -> (t1, t1)
13:23:33 <erisco> :t (&&&) :: (t2 -> t1) -> t -> (t2, t2) -> (t1, t1)
13:23:34 <lambdabot> error:
13:23:34 <lambdabot>     • Couldn't match type ‘t4’ with ‘(t4, t4)’
13:23:34 <lambdabot>       ‘t4’ is a rigid type variable bound by
13:23:48 <erisco> :t (***) :: (t2 -> t1) -> t -> (t2, t2) -> (t1, t1)
13:23:49 <lambdabot> error:
13:23:49 <lambdabot>     • Couldn't match type ‘t6’ with ‘t4 -> t5’
13:23:49 <lambdabot>       ‘t6’ is a rigid type variable bound by
13:23:54 <erisco> well I thought it was one of those
13:23:59 <leshow> what are you trying to do
13:24:18 <cocreature> :t bimap
13:24:20 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
13:24:29 <cocreature> ^ leshow that’s what you’re looking for
13:24:32 <erisco> yeah there is bimap but that is a bit more esoteric
13:24:42 <koz_> erisco: For no good reason IMHO.
13:24:53 <cocreature> dunno I find bifunctors a lot less esoteric than arrows
13:25:13 <leshow> the only thing i was "trying" to do was find something that would look horrible in pointfree form lol
13:25:24 <koz_> cocreature: What's the deal with arrows anyway? It seems they were really popular for a while, and then stopped.
13:26:21 <erisco> oh, I wrote it wrong, that is why
13:26:30 <erisco> :t \f g (a,b) -> (f a, g b)
13:26:31 <lambdabot> (t2 -> t) -> (t3 -> t1) -> (t2, t3) -> (t, t1)
13:26:41 <erisco> :t (***) :: (t2 -> t) -> (t3 -> t1) -> (t2, t3) -> (t, t1)
13:26:42 <lambdabot> (t2 -> t) -> (t3 -> t1) -> (t2, t3) -> (t, t1)
13:26:46 <erisco> there we go :)
13:27:08 <koz_> Also, do I understand correctly that the functor for ((->) e) is basically just function composition?
13:27:17 <cocreature> koz_: not sure I think apart from some frp libs they are only really used as tuple combinators for functions. iirc arrows are equivalent to category + applicative but I think they were introduced before them so maybe that’s why they were more popular at that point
13:27:34 <koz_> cocreature: I see.
13:27:34 <cocreature> koz_: more precisely fmap  is just function composition
13:27:53 <dfeuer> Why the heck does mono-traversable need vector-algorithms?
13:28:06 <koz_> cocreature: OK, *that* makes a bit more sense.
13:28:09 <dfeuer> Also, I really wish there were an easy way to find the answer to that question.
13:28:38 <leshow> erisco: no idea what you're doing with the *** ive never seen that before
13:28:40 <dfeuer> I wish even more that there were an easy way to ask which *modules* on Hackage use each *function* in the containers package.
13:28:49 <koz_> dfeuer: Can't you just ask the maintainer for mono-traversable?
13:29:05 <koz_> I mean, that doesn't solve the more general problem, but at least you'll have an answer for that.
13:29:13 <dfeuer> koz_, that sounds like a huge waste of time for the maintainer of the package....
13:29:23 <cocreature> koz_: ftr you can find the functor instance here https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-638
13:29:29 <cocreature> it’s literally fmap = (.)
13:29:34 <koz_> dfeuer: Well, it's their decision to respond to that or not, but it's worth asking all the same IMHO.
13:29:42 <koz_> cocreature: Yeah, shoulda RTFS.
13:29:53 <ComposerMike> I just upgraded to Sierra and the Haskell Platform is broken
13:30:05 <Tuplanolla> You should just import Data.Aviary and write your code with those.
13:30:15 <monochrom> joe9: How did you obtain your GHC 7.10.3? From a linux distro? I think you're missing some distro packages. Linux distros love to shred GHC into multiple packages to confuse you.
13:30:30 <koz_> monochrom: Which distros do this, out of interest?
13:30:33 <ComposerMike> I’m getting “xcrun: error: invalid active develop path (/Library/Developer/CommandLineTools), missing xcrun….
13:30:34 <cocreature> koz_: if you are not aware of it: haddock shows "source" links next to the instances of your class which are quite handy in those cases, e.g. see https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor.html
13:30:42 <monochrom> debian ubuntu fedora
13:30:47 <koz_> cocreature: I was aware of this - it just didn't occur to me.
13:30:54 <koz_> monochrom: OK, none of the ones I use, then. :P
13:31:18 <leshow> i wasnt aware of Control.Arrow
13:31:22 <alanz> ComposerMike: see https://mail.haskell.org/pipermail/ghc-devs/2016-September/012922.html
13:32:15 <ComposerMike> alanz: oh my… 
13:32:28 <erisco> laudiacay, here is a derivation for a pointfree form of your example http://lpaste.net/233028
13:33:21 <laudiacay> erisco: thank you!
13:33:43 <laudiacay> erisco: that is terrifying
13:33:43 <erisco> laudiacay, oh I think I made a mistake :) but maybe you can find it
13:33:45 <laudiacay> but thank you
13:34:02 <laudiacay> i will fruitlessly stare at it and try to learn something new :D
13:34:15 <ComposerMike> alanz: btw, do you know how to uninstall the Haskell Platform in OS X?
13:34:39 <alanz> ComposerMike: I do not use Mac at all. Just saw that mail earlier today
13:35:17 <dfeuer> koz_, OTOH, it makes a case for adding room in .cabal files for explanations of *why* each package dependency is there.
13:35:31 <monochrom> joe9: basically the error messages are saying that libHSrts-ghc7.10.3.so is found but it refers to stuff in base not found. e.g. "/usr/lib64/ghc-7.10.3/rts/libHSrts-ghc7.10.3.so: undefined reference to `base_GHCziWord_W16zh_con_info'"
13:35:33 <ComposerMike> I am not sure it’s the same issue. after the upgrade to Sierra a number of programs had their configuration lost, so I wonder if I just need to reinstall the Haskell Platform
13:35:50 <koz_> dfeuer: It does. It'd be interesting to actually do some kind of graph analysis of Hackage based on dependencies by function usage.
13:36:02 <dfeuer> koz_, oh? 
13:36:19 <erisco> ah I forgot a flip on $
13:36:35 <erisco> laudiacay, here is the corrected version http://lpaste.net/233030
13:36:46 <dfeuer> koz_, I've been wanting that for a *long* time, to see how/if each function is being used, for optimization, deprecation, etc.
13:36:58 <koz_> dfeuer: Well, the technology is there.
13:37:11 <koz_> If I didn't have a PhD to do, I might even consider performing such an analysis myself.
13:37:25 <Tuplanolla> Add language extensions to that analysis.
13:37:46 <dfeuer> koz_, how do I use this technology? I don't want a dependency graph analysis; I just want to see the functions I'm personally responsible for.
13:37:59 <dfeuer> I mean, more is better, but just that would be lovely.
13:38:01 <erisco> @pl \ls -> \x -> map ($ x) ls
13:38:01 <lambdabot> flip (map . flip id)
13:38:20 <erisco> I came up with  (. flip ($)) . flip map  so there is clearly more than one way to do it! :)
13:39:06 <monochrom> joe9: could you show me the output of ls /usr/lib64/ghc-7.10.3/base_HQfYBxpPvuw8OunzQu6JGM ? That may be simpler.
13:39:08 <koz_> dfeuer: You'd need to scrape the source code of all packages on Hackage to determine which packages use your functions. Then construct a graph of that, and do some kind of centrality analysis to determine which functions are most used.
13:39:14 <koz_> And/or other kinds of analysis as needed.
13:41:10 <koz_> dfeuer: I'd have to think on this a bit before I can give you a more complete answer - would you like a report of some kind? :P
13:41:25 <koz_> (no seriously, I would consider it if you gave me a bit of time to ponder)
13:43:23 <laudiacay> erisco: you're awesome
13:45:55 <joe9> monochrom: Thank you so much for the advice. I am sure you can fix it if you wish. But, I do not think that it is a valid use of your time. I do not want to go the cabal route. stack has made my life so much easier that I cannot bear to go back to using cabal. I will just use the makefile approach and run the ghc stuff in a makefile and avoid the cabal or stack architecture for this.
13:46:22 <ski> soLucien : yes, unless you care about the difference, you'd normally write it as `\(x,y) -> ..x..y..'
13:48:58 <monochrom> joe9: if you use a makefile, you can still have a "make configure" stage that does "ghc --numeric-version" to help you automate "-lHSrts-ghc<what do you put here>"
13:49:36 <joe9> monochrom: yes, that is what I will do.  both these options work https://paste.pound-python.org/show/Cr1NIvT3zDXO0LNIU5Cp/
13:49:51 <joe9> monochrom: I will use the first option as i do not have much control over the C program build.
13:50:04 <joe9> monochrom: and in the make file use ghc --print-libdir
13:50:05 <hvr> joe9: fwiw, you'll miss out on the new stuff that'll available to cabal we're working on then
13:50:34 <joe9> monochrom: and ghc --numeric-version to get the actual library name.
13:53:12 <monochrom> I need someone to give me a research grant so I can do a proper comparatory study on cabal and stack :)
13:53:19 <joe9> hvr, I am sure there are great things happening in the cabal land. I have been using haskell for more than a decade and cabal has mostly stayed the same throughout. I will jump on to the cabal bandwagon if the new stuff materializes. I use gentoo portage and appreciate the source based build and architecture. but, for development work, where you are trying out the latest packages, that architecture does not fly (imho). you just want a
13:53:19 <joe9> "stack solver" to get the latest and greatest version of packages that will work with this package.
13:54:08 <joe9> hvr, and move on, instead of tweaking your system configuration packages. I think cabal sandbox might do what stack does.
13:54:23 <joe9> hvr, but, I have not tried it, so, i do not know what it does.
13:54:39 <hvr> joe9: cabal sandboxes will be removed
13:55:00 <hvr> as they are not needed anymore
13:55:18 <hvr> or rather will not be needed anymore
13:55:30 <joe9> hvr, for stable haskell stuff, such as xmonad, etc. that I am not tweaking or building on, I use cabal. But, while building a package, it is much easier to use stack to build something and then worry about getting it to work with cabal at the end.
13:56:09 <erisco> laudiacay, turns out there is an easy Applicative way to think about it, which leads to lambdabot's answer
13:56:17 <hvr> joe9: are you referring to stackage or stack?
13:56:38 <erisco> laudiacay, based on the "intuitions" I posted here http://stackoverflow.com/a/34536499/260584 you can quickly find  map <$> flip ($)
13:57:27 <erisco> because  map <$> flip ($)  is  \x -> map (flip ($) x)  by the intuition, which is  map ($ x)  using section notation
13:57:43 <hvr> joe9: also what specifically makes it much easier to use stack for you?
13:57:45 <erisco> so then you just need to use flip to get the argument order you want, hence  flip (map <$> flip ($))
13:57:47 <joe9> hvr, stack solver -- this command is a god send and the fact that stack build uses a clean install for every package.
13:57:56 <erisco> flip id is the same as flip ($), which is what lambdabot gave
13:58:03 <erisco> and <$> is the same as .
13:58:06 <hvr> joe9: you do know that 'stack solver' is effectively 'cabal'?
13:58:25 <joe9> hvr, I understand that it is cabal library.
13:58:37 <hvr> joe9: no, literally, 'stack solver' calls 'cabal-install'
13:58:42 <joe9> hvr, but, the fact that it runs in a clean environment is so much helpful.
13:59:34 <hvr> joe9: and that very 'clean environment' is what the current tech-preview cabal features provide as well
13:59:40 <joe9> hvr, when building or developing something using haskell, I tend to try out a bunch of latest packages. When I want to install and try the latest packages, I do not want them to touch my stable cabal build.
14:00:08 <joe9> hvr, I just want something to work soon.
14:00:09 <hvr> joe9: so in future you can use cabal or stack, and it'll be essentially the same ideas, but with a different UI
14:00:28 <erisco> laudiacay, I do not know the whole story yet, but variables seem to be a complicated convenience for humans
14:00:44 <joe9> hvr, i have no issues if cabal can do clean builds for a certain package.
14:00:50 <erisco> laudiacay, it is much simpler to work with a system that is without them
14:01:09 <hvr> joe9: I'm trying to tell you that in future your current complaints won't apply to cabal anymore :)
14:01:10 <erisco> simpler when you are doing analysis of that system itself, such as evaluating it
14:01:33 <hvr> joe9: and the gap between cabal & stack will be very small
14:01:49 <monochrom> Both the cabal people and the stack people should bribe me to write a favourable review :)
14:01:55 <joe9> hvr, actually, it is a pita to maintain stack and cabal config files. Glad to know that we will not need that forever.
14:02:04 <monochrom> (and that's what I mean by "research grant" :) )
14:02:46 <hvr> joe9: heh... well, cabal has 'cabal.project' files, as the equiavlent to 'stack.yaml' files :))
14:03:24 <erisco> possibly variables are not actually that great, only that we've been brought up on them
14:03:43 <joe9> hvr, atleast, I would not have to figure out whether it is stack or cabal that is doing something weird, when something bad happens. I think anyone would stick with cabal if what you say will happen happens.
14:04:13 <hvr> joe9: well, unless you want to use e.g. 'intero' or other tools that are currently made stack-exclusive
14:04:17 <Tuplanolla> Yeah, where's NeedleArrows when we need them, erisco?
14:04:24 <soLucien> modify :: (Env -> Env) -> SubsM ()
14:04:29 <erisco> I am not familiar
14:04:33 <soLucien> what does the last () come from
14:04:36 <Tuplanolla> https://scrambledeggsontoast.github.io/2014/09/28/needle-announce/
14:04:37 <soLucien> and is it necessary ?
14:05:18 <dfeuer> Do sequences and non-empty sequences have enough in common to justify a common superclass for shared operations (cons, snoc, singleton, reverse, inits, tails, and maybe a few more)?
14:05:34 <monochrom> clearly, "SubsM" alone doesn't make sense, you have to put something after. And if not (), then what could you put there instead?
14:05:42 <erisco> Tuplanolla, lol
14:05:45 <soLucien> a function .. i get it
14:05:51 <soLucien> it's the 'null'
14:05:52 <soLucien> type
14:06:02 <soLucien> so that haskell can typecheck it
14:06:15 <joe9> hvr, I have not tried intero. but, I find the haskell development tools to be a nuisance rather than a help. too much noise.
14:06:20 <dfeuer> Conceptually, the singleton operation in sequences goes together with foldMap, whereas the one in non-empty sequences goes with FoldMap1, so the laws are different.
14:06:23 <erisco> if it was graphical rather than drawn with ASCII maybe there is something there
14:06:34 <joe9> hvr, i actually am liking stack build --file-watch
14:06:56 <joe9> hvr, for instant feedback. actually, prefer it to the haskell dev tools.
14:06:56 <monochrom> yeah, I'm not impressed with ASCII art
14:08:35 <erisco> a nice thing about variables is it is one system to express many forms
14:08:53 <hvr> joe9: what does --file-watch do exactly? retrigger recompilation as soon as file changes are detected?
14:09:17 <erisco> whereas pointfree approaches tend to become verbose, and thus difficult to find by hand
14:09:22 <joe9> hvr, yes.
14:09:43 <joe9> hvr, also detects if any of the child dependent projects have changed.
14:10:00 <hvr> joe9: ok, that sounds basically what 'while :; do cabal new-build;done' would result in as well
14:10:03 <erisco> this presumes you have some fixed set of constructs in your pointfree toolset
14:10:06 <joe9> hvr, for example, when I am building a package, and have a dependency that I am also working on
14:10:45 <hvr> joe9: yeah, we have that in cabal too w/ new-build: http://cabal.readthedocs.io/en/latest/nix-local-build.html#local-versus-external-packages
14:11:07 <joe9> hvr, good to know that cabal has that.
14:11:08 <hvr> joe9: i.e. you can have local packages you work on
14:11:37 <erisco> f (g x) (h x)  seems easy to think about, but if you tried to find this by hand with S and K it would be much more challenging
14:12:16 <joe9> hvr, that is cool. the nix-style local builds -- it is cabal 1.24?
14:12:40 <joe9> hvr, does it work well. there is no reason for me to use stack if it does.
14:12:43 <dibblego> dfeuer: Control.Lens.Cons
14:13:03 <hvr> joe9: 1.24 was the first to have it as tech-preview; and there's been a lot of work going improving it for the next release after cabal 1.24 (which will be 2.0)
14:13:16 <erisco> but maybe a fallacious way of thinking… with variables we derive new concepts, such as folds and Applicative and so on
14:13:21 <hvr> joe9: next year we'll probably make new-build the default mode
14:13:22 <joe9> hvr, oh, ok. better wait for 2.0 then. When is it due?
14:13:25 <erisco> and so you might so the same with S and K
14:13:29 <joe9> hvr, ok. Thanks.
14:13:39 <hvr> joe9: 2.0 sometime later this year
14:15:30 <joe9> hrv, thanks.
14:15:33 <hvr> np
14:16:27 <mgsloan> joe9: Pretty soon stack will share all packages, including extra-deps
14:16:39 <soLucien> ski am i correct to say that
14:16:43 <dagda1> why is foldr and not foldl used in this function isIn x xs = foldr ((||) . (== x)) False xs
14:16:56 <mgsloan> We've had package sharing for quite a bit longer than cabal, and you need to use the new-build.  Might want to look at the issue tracker before jumping in
14:17:04 <erisco> what is the difference of $, ($), and <$> ? some funny things …
14:17:21 <erisco> and [$], haha
14:17:23 <hvr> mgsloan: and matrix.hho had package sharing before stack had it ;)
14:17:29 <soLucien> in order to start testing stuff i need write half of my interpreter?
14:17:31 <erisco> oh that is a parse error, darn
14:17:41 <soLucien> been looking at what I actually have acheived
14:17:51 <soLucien> after 2 full days of writing this monad
14:17:56 <soLucien> and it's actually nothing ..
14:17:58 <amalloy> erisco: $ and <$> are different functions (infix operators, if you prefer)
14:18:00 <soLucien> i can't run anything
14:18:11 <dfeuer> dibblego, that doesn't really seem to get to the heart of the question at all. Sensible views of  the left or right of a non-empty container look very different from ones for a nullable container. And I guess there's no harm in sharing reverse. I'm more asking whether it makes sense to have a lawless shared singleton method with cons and snoc determined only by that, or whether to have separate methods.
14:18:23 <erisco> there is possibly a :$ too
14:18:24 <mgsloan> hvr: Cool!  I didn't know that and have never heard of it, unless you're talking about the build matrix.  There seems to be a chronic issue of poor marketing of tech
14:18:42 <monochrom> dagda1: foldr ((||) . (== x)) can quit early, foldl can't.
14:19:00 <erisco> yes there is, heh
14:19:32 <mgsloan> hvr: It really doesn't matter who had it first, it matters what does it best ;)
14:19:34 <erisco> the dollar sign journey through Haskell
14:19:38 <dfeuer> dibblego, those Cons and Snoc classes are perfectly sensible for nullable containers, but entirely wrong for nonempty one.
14:21:02 <hvr> mgsloan: I'm really referring to the build matrix :-) ... and evne the fpco blog quoted me on that (https://www.fpcomplete.com/blog/2015/09/stack-more-binary-package-sharing)
14:21:23 <mgsloan> Cool!  I'm confused why this tech would be in the build matrix and not provided to users, but still nifty
14:21:25 <dfeuer> For a non-empty container, you'd want  _ConsNE :: Lens s t (a, Maybe s) (b, Maybe t), or something like that.
14:21:36 <monochrom> Don't be afraid to throw away code you spent two days or two years writing.
14:21:50 <mgsloan> jaa
14:21:56 <Rembane> monochrom: Your teachings are painful.
14:21:57 <monochrom> Throwing away code en masse is a necessary step in both learning and prototyping.
14:22:05 <dfeuer> Very true that.
14:22:10 <hvr> mgsloan: because in the matrix I experimented with the idea, whereas later it was implemented more principled in cabal proper
14:22:16 <monochrom> Do not succumb to the sunk cost fallacy. Do throw away code.
14:22:17 <hvr> (and not by me)
14:22:21 <mgsloan> I see! Cool beans
14:22:39 <hvr> I built on top of cabal's sandbox features
14:22:47 <dfeuer> What is this build matrix y'all are talking about? Where should I look for the perfect version?
14:22:59 <hvr> while new-build was redesigned from the grounds up
14:23:02 <dagda1> monochrom why can foldl not quit early?
14:23:08 <dfeuer> Oh, new-build.
14:23:25 <monochrom> foldl is defined to walk the whole list before doing anything useful.
14:23:34 <dfeuer> dagda1, it calls itself for each list element no matter what.
14:24:03 <dfeuer> foldl per se is *almost* useless. foldl' performs useful work as it goes.
14:24:14 <hvr> mgsloan: but the main reason I didn't extract matrix' sandbox sharing feature as a tool and published it is because I knew that new-build was already in the works
14:24:51 <dfeuer> foldl, unless GHC optimizations kick in, only does useful work when that work is allocating a constructor.
14:25:21 <dfeuer> Because GHC does not defer application of *lazy* constructors.
14:27:50 <dfeuer> I suspect the average Haskell programmer actually encounters a problem to which foldl of a list is the correct solution less than once a year.
14:28:07 <monochrom> I agree
14:28:13 <dfeuer> It's not quite as rarely the right tool for the job as scanr for a list, but it's pretty bad.
14:28:56 <monochrom> oh, scanr, I really have trouble motivating scanr too :)
14:29:01 <dibblego> you generalise the Optic from Cons to achieve non-empty
14:29:01 <erisco> that's because everyone is using foldl1' obviously
14:30:14 <dfeuer> dibblego, ooh, that sounds interesting. I guess Cons optic s t a b | ..., s -> optic  or so?
14:31:30 <dfeuer> dibblego, it still doesn't get to the heart of the matter, which is that singleton/foldMap demonstrates a free monoid whereas singleton1/foldMap1 demonstrates a free semigroup.
14:31:43 <dagda1> I'm new to haskell and foldl is what I would use for reduce in other languages
14:32:05 <dfeuer> dagda1, yeah, well, in Haskell, what you want is almost certainly foldl'..
14:32:18 <dfeuer> For plain reducing.
14:32:31 <dfeuer> For fancier stuff, foldr or mapAccumL.
14:32:45 <dagda1> this the first use for foldr to short-circuit an infinite list
14:33:22 <dfeuer> (or of course you could get even fancier with monadic folds and all, but those are generally defined in terms of foldr)
14:34:28 <Rembane> Isn't foldM a left fold?
14:35:03 <monochrom> yes
14:35:09 <dfeuer> > foldr (\x r -> print x >> r) (pure ()) [1..5]
14:35:12 <lambdabot>  <IO ()>
14:35:36 <dfeuer> Rembane, yes, but it's defined in terms of foldr, and can't be defined in terms of foldl.
14:35:40 <monochrom> actually, it might not be that clear-cut
14:35:43 <monochrom> @src foldM
14:35:43 <lambdabot> foldM _ a []     = return a
14:35:43 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:35:49 <Rembane> dfeuer: That is wildly confusing. 
14:35:50 <dfeuer> :t foldM
14:35:52 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
14:36:52 <nomeata> Recruitement mail from AlphaSheets, taking about “author of one of the most downloaded Hackage packages”. I guess if I get that for arbtt, many of you got this as well, indicating that these mails were sent out with little care and research?
14:36:57 <monochrom> The @src version is outdated
14:37:20 <Rembane> dfeuer: So if I do: f a x `op` ... fold* -- I have a right fold?
14:38:47 <monochrom> haha great, "foldM = foldlM"
14:39:37 <dfeuer> foldM f init xs = foldr go pure xs init where go x r acc = f acc x >>= r , if I'm not mistaken.
14:39:44 <monochrom> yeah
14:39:55 <dfeuer> Rembane, I'm not quite sure what you mean there.
14:40:10 <monochrom> and just for fun, foldrM f z0 xs = foldl ...
14:40:32 <monochrom> Love is Hate, Freedom is Slavery, Left is Right.
14:41:08 <dfeuer> Note that foldM can begin producing actions (in appropriate monads) before it finishes the list.
14:41:16 <monochrom> The futility of dichotomizing "left fold, right fold".
14:42:06 <Rembane> dfeuer: I mean, if I look at the structure of a recursive function, can I figure out if it is a left fold or a right fold?
14:42:27 <Rembane> So why does a left fold work for a monadic fold but not for a fold over a list?
14:42:34 <Rembane> And what happens if I use foldM on a list? 
14:42:59 <dfeuer> ???
14:43:03 <dfeuer> Parse error.
14:43:14 <grantwu> not all recursive functions are folds.
14:43:22 <dfeuer> Actually, my type checker failed.
14:43:40 <monochrom> It is a good idea to look at the recursion to see what it does.
14:43:52 <dfeuer> Rembane, any function consuming a list can be written (one way or another) using foldr.
14:44:09 <dfeuer> It is a universal list consumer.
14:44:29 <dfeuer> In particular,  foldr (:) [] = id
14:44:49 <dfeuer> So you can always fold over the list to produce a new copy and then do what you like with it (not that you ever should do that).
14:44:50 <monochrom> and sometimes, if you can't figure out what the code says, test with an infinite list, that usually bootstraps your understanding.
14:45:17 <dfeuer> foldl and foldl' can be written in terms of foldr. The converse is not true.
14:45:43 <Rembane> monochrom: So an infinite list is a good test to find if something quacks like a foldl?
14:46:02 <dfeuer> foldl f b xs = foldr (\x r acc -> r (f acc x)) id xs b
14:46:10 <grantwu> Not all recursive functions are folds or even operate on lists or something that can be folded over
14:46:17 <monochrom> I wouldn't think in terms of "quacks like a foldl".
14:46:33 <monochrom> I wouldn't think in terms of any false dichotomy in general.
14:46:49 <dfeuer> foldl' f b xs = foldr (\ x r acc -> r $! f acc x) id xs b
14:47:09 <dfeuer> Except that GHC 7.10 accidentally changed the meaning of foldl', nomeata.
14:47:20 <Rembane> Okay, then I'll drop the idea of classifying functions in the categories: (foldl, foldr, other)
14:47:24 <monochrom> But infinite lists are usually good tests for refuting most wrong theories.
14:47:25 <dfeuer> And no one has come to a conclusion about what to do about that, as far as I can tell.
14:48:23 <dfeuer> foldl f b = foldr (flip f) b . reverse, by the way. but the converse does not hold.
14:48:31 * dfeuer is getting silly.
14:48:44 <monochrom> The irony is that foldlM is implemented by a foldr, foldrM is implemented by a foldl. All is lost.
14:48:54 <dfeuer> monochrom, the case of foldM for reader is a bit interesting.
14:48:58 <MarcelineVQ> dfeuer: what do you mean by changed the meaning of foldl'?
14:49:48 <dfeuer> MarcelineVQ, it changed to foldl' f b xs = foldr (\x r !acc -> r (f acc x)) id xs b, IIRC. It was a mistake, and unlike some more serious mistakes, it wasn't mine.
14:49:53 <Tuplanolla> You can classify recursion schemes to an extent, Rembane. Here's some reading: http://maartenfokkinga.github.io/utwente/mmf91m.pdf
14:50:04 <jle`> cocreature: i think it should technically be ready for an accelerate backend, except the methods in the tensor typeclass might have to be re-written to be monadic (and therefore runTensorOp and gradTensorOp, as well).
14:50:38 <dfeuer> MarcelineVQ, see https://ghc.haskell.org/trac/ghc/ticket/12173
14:50:55 <jle`> cocreature: but, implementing a backend from scratch ais also made needlessly complicated because of how i designed the tensor typeclass (i decided to generalize inner, outer, scala, matrix, matrix-vector products under one method for no reason)
14:51:19 * dfeuer will refrain from mentioning some of his more serious mistakes, for fear of being crucified and then burned at the stake.
14:51:28 <MarcelineVQ> dfeuer: thank you
14:51:56 <jle`> cocreature: so i might be making a nicer way to implement backends in the near future, so a written-from-scratch backend might be inconsistent and needlessly more complicated if written at this point :)
14:52:26 <Rembane> Tuplanolla: That looks like great fun! Thank you!
14:52:27 <monochrom> "foldM (\_ x -> print x) () [0..]" vs "foldrM (\x _ -> print x) () [0..]" can show some difference
14:52:50 <monochrom> they are both infinite loops but the former produces output
14:52:55 <jle`> well, one advantage of generalizing inner/outer/scalar/matrix/matrix-vector products was that i implemented their derivative/gradient altogether in one go, but that might make it hard for backends to optimize, too.
14:53:30 <monochrom> "foldrM (\x _ -> print x) () [0..9]" can also show order
14:54:36 <monochrom> And now I wonder what foldrM does when the monad is the like of Control.Monad.State.Lazy
14:55:40 <dfeuer> > foldM (\acc x p -> x + p : acc) id [1..4] []
14:55:42 <lambdabot>  error:
14:55:42 <lambdabot>      • Couldn't match expected type ‘[[t]]’ with actual type ‘a0 -> a0’
14:55:42 <lambdabot>      • Probable cause: ‘id’ is applied to too few arguments
14:56:47 <dfeuer> That's not what i meant.
14:57:19 <dfeuer> monochrom, are *both* foldlM and foldrM strict in the list spine for Reader?
14:57:59 <dfeuer> (but for different reasons?)
14:58:10 <monochrom> foldrM is going to be strict in the list spine because it's a foldl
14:59:08 <monochrom> foldM is a "foldr (... >>= ...)" so the strictness is controlled by (>>=).
14:59:39 <monochrom> for example it can be non-strict and quit early for Maybe when you hit Nothing
15:01:20 <monochrom> > foldM (\_ _ -> Nothing) () [0..]
15:01:22 <lambdabot>  Nothing
15:01:33 <monochrom> in fact, the sharpest we can get is:
15:01:41 <monochrom> > foldM (\_ _ -> Nothing) () (0 : undefined)
15:01:43 <lambdabot>  Nothing
15:02:07 <dfeuer> monochrom, foldlM (\_ _ _ -> ()) () [1..] ()  is an infinite loop
15:02:42 <monochrom> which monad is that? (->) Something?
15:03:00 <dfeuer> Yeah.   (->) ()
15:03:40 <dfeuer> You get the *function* immediately, but trying to apply it is a black hole.
15:03:45 <monochrom> most monad's (>>=) are pretty strict
15:04:11 <evmorov> \quit
15:04:21 <nomeata> Λquit
15:04:31 <tmood> ...
15:04:39 <nomeata> ∕quit
15:04:42 <Rembane> IRC elimination.
15:04:49 <dfeuer> monochrom, for m >>= f, IO is strict in m but not f. Reader is strict in f but not m.
15:04:53 <nomeata> ⎳quit
15:05:00 <nomeata> ⋰quit
15:05:04 <monochrom> yeah, "seq (foldlM (\_ _ _ -> ()) () [1..]) 4" is pretty successful
15:05:06 <nomeata> the IRC server is really picky
15:05:16 <nomeata> ╳quit
15:05:57 <dfeuer> Hrrm.
15:06:06 <dfeuer> I was hoping he'd have something to say about the foldl' bug.
15:06:23 <monochrom> IO is where effects and evaluation of your list are interleaved so "strict vs non-strict" is insufficient to describe what happens.
15:06:38 <monochrom> But let's just say IO's foldM is productive
15:06:41 <dfeuer> Yes.
15:07:02 <dfeuer> You're right.
15:07:09 <dfeuer> return () >>= f is certainly strict in f.
15:07:29 <dfeuer> Unless you have a very expansive view of productivity.
15:07:50 <dfeuer> "I did something! I passed the buck!"
15:22:51 <monochrom> after much calculation, here is an illustration of what foldrM does:
15:23:08 <monochrom> foldrM f z0 [0,1,2] = f 2 z0 >>= \z1 -> f 1 z2 >>= \z -> f 0 z
15:23:29 <monochrom> maybe you could rewrite it as (\z1 -> (\z -> f 0 z) =<< f 1 z1) =<< f 2 z0
15:44:01 <soLucien> modify :: (Env -> Env) -> SubsM ()
15:44:13 <soLucien> is the () a wildcard
15:44:24 <soLucien> or does it have to be specifically empty ?
15:45:14 <geekosaur> it has to be empty
15:45:19 <geekosaur> :t ()
15:45:20 <lambdabot> ()
15:45:47 <grantwu> () is the only inhabitant of the unit type
15:46:13 <grantwu> basically, it's a type that has only one value, and sometimes it's nice to have that
15:46:22 <grantwu> It's kind of like void, at least in the context of IO
15:46:35 <soLucien> I see
15:47:01 <soLucien> geekosaur, were you following the discussion earlier
15:47:01 <grantwu> so for example
15:47:02 <grantwu> :t main
15:47:04 <lambdabot> error:
15:47:04 <lambdabot>     • Variable not in scope: main
15:47:04 <lambdabot>     • Perhaps you meant ‘min’ (imported from Data.Ord)
15:47:08 <geekosaur> no, I wasn
15:47:09 <geekosaur> t
15:47:17 <grantwu> :/ Okay but main is actually of type IO ()
15:47:30 <soLucien> can you help me out figure out the semantics of this operation
15:47:33 <soLucien> in the context of 
15:47:52 * hackagebot hw-string-parse 0.0.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-string-parse-0.0.0.2 (haskellworks)
15:47:54 * hackagebot hw-diagnostics 0.0.0.4 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-diagnostics-0.0.0.4 (haskellworks)
15:47:56 * hackagebot hw-mquery 0.1.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-mquery-0.1.0.1 (haskellworks)
15:47:56 <grantwu> oh wait never mind, main can be IO anything, it's just usually ()
15:48:15 <joe9> Tuplanolla: this is how your used your stuff: https://github.com/joe9/skb/blob/master/makefile Thanks again.
15:48:53 <Tuplanolla> Oh, --numeric-version looks useful, joe9.
15:48:55 <soLucien> http://lpaste.net/2772336045935558656
15:49:18 <soLucien> so if i have a function modify :: (Env -> Env) -> SubsM ()
15:49:27 <soLucien> what is it supposed to do in your opinion
15:49:59 <soLucien> i'm supposed to implement it , but there's no specific definition of what it should do
15:50:52 <grantwu> how are you supposed to implemet something when you don't know what you want it to do
15:51:06 <soLucien> do you think i should use the return/ >>= from the monad ?
15:51:24 <soLucien> i don't know, i didn;t come up with this assignment
15:51:45 <soLucien> (e) Implement the following utility functions for working with the context:
15:51:59 <soLucien> this is the first one
15:52:10 <soLucien> it doesn't say what's supopsed to happen so i have to guess
15:52:15 <ContessaTP> Well it's taking in a function (Env -> Env)
15:52:19 <soLucien> so i have this function,
15:52:29 <grantwu> I don't think it'll be easy for anyone to understand what you are trying to do unless they have the entire assignment
15:52:41 <ContessaTP> and it's doing some operation in the SubsM monad. I'd say it's something like
15:52:56 <soLucien> i posted it .. this is the relevant part
15:53:09 <soLucien> it's a AST interpreter
15:53:42 <ContessaTP> actually, what is the SubsM monad like?
15:53:52 <soLucien> http://lpaste.net/2772336045935558656
15:54:16 <soLucien> lines 43-51
15:55:36 <ContessaTP> alright, gonna try it out locally
15:56:15 <soLucien> i haven't posted all the code because not all of it is relevant .. might not compile
15:56:39 <grantwu> soLucien: If you have TAs to ask it might be more helpful to ask them
15:56:55 <soLucien> i guess it's a bit too late for that
15:57:04 <soLucien> doubt anyone is up at 1 AM
15:57:24 <grantwu> Haven't you been working on this for a while? :/
15:57:31 <soLucien> yes .. 
15:57:33 <soLucien> weeks
15:57:37 <Tuplanolla> Hey, 2 am is a good time to be up.
15:57:40 <ContessaTP> well, looking at it I think it's taking in a function (Env -> Env), then it invokes it and somehow you end up within the SubsM monad's context without a return value
15:57:50 <soLucien> i've read LYAH, typeclassopedia , lots of monad tutorials
15:57:50 <Tuplanolla> It's among the most productive hours.
15:57:57 <soLucien> implemented the monad
15:58:10 <soLucien> and now i'm at the part where i'm actually doing the assignment
15:58:54 <ContessaTP> So I think what modify is
15:59:13 <ContessaTP> is that it takes in a function that modifies the environment using the function it's taking in
15:59:18 <ContessaTP> That's what it semantically means
15:59:36 <soLucien> yep .. i also thaught of it this way
16:00:32 <ContessaTP> penv = primitive environment?
16:00:37 <soLucien> yep
16:00:48 <ContessaTP> SubsM = substitution monad?
16:01:01 <soLucien> i guess that's what it means
16:01:09 <soLucien> or SubscriptMonad
16:01:43 <soLucien> the assignment is called a Subscript interpreter - an interpreter for a subset of javascript
16:01:51 <ContessaTP> that would make sense then
16:01:55 <soLucien> but i think substitution is closer to what it does
16:02:09 <soLucien> it runs a function, and updates the environment
16:04:09 <ContessaTP> Well the environment is being passed along with each bind call, right?
16:04:25 <soLucien> yes
16:04:42 <ContessaTP> whatever's in the monad is either of the form
16:04:49 <ContessaTP> Left (Error (String) )
16:04:53 <soLucien> exactly , the Context holds the environment (scope variables) and the primitive environment
16:05:00 <ContessaTP> or Right (x, env)
16:07:46 <ContessaTP> This reminds me of the State monad in a way. You're carrying around state (environment) with each call, right?
16:09:05 <ContessaTP> actually try this out soLucien
16:09:12 <ContessaTP> would it be legal to do:
16:09:21 <soLucien> yes i am .. the Env is the state
16:09:29 <soLucien> variables and functions defined
16:09:34 <ContessaTP> modify (Right (func, env)) = blah...
16:09:45 <ContessaTP> you just apply the env to func
16:10:02 <ContessaTP> so I guess it is: modify (Right (func, env)) = func env
16:10:43 <ContessaTP> I'm new to Haskell too, but I'm guessing that might work
16:23:33 <soLucien> modify f = SubsM (\(env, penv) -> Right ((), f env) )
16:23:49 <soLucien> type checked
16:27:05 <ContessaTP> nice, so it works soLucien ?
16:27:20 <soLucien> it type checks
16:27:29 <ContessaTP> that's a start :-)
16:27:34 <soLucien> i'm not at the stage where i can actually test it
16:41:26 <haasn> What's a good solution for doing by-tag search in Haskell? I have about 3 million entries I need tagged, and I need efficient lookup by tag (and tag expressions including logical AND or OR), as well as a way to list all tags available. I need to be able to insert arbitrary tags (so I can't delcare them up-front). Tags are strings.
16:42:12 <haasn> I might try xapian which can definitely do tagging, but the focus of xapian seems to be efficient full-text search (which I don't need); plus I don't know if there are any solid xapian bindings for haskell
16:44:35 <Axman6> SQLite? =)
16:47:53 * hackagebot hw-prim 0.3.0.3 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.3.0.3 (haskellworks)
16:47:55 * hackagebot validity 0.3.0.3 - Validity typeclass  https://hackage.haskell.org/package/validity-0.3.0.3 (Norfair)
16:47:57 * hackagebot validity-text 0.1.0.0 - Validity instances for text  https://hackage.haskell.org/package/validity-text-0.1.0.0 (Norfair)
16:47:59 * hackagebot genvalidity-text 0.1.0.1 - GenValidity support for Text  https://hackage.haskell.org/package/genvalidity-text-0.1.0.1 (Norfair)
16:48:01 * hackagebot validity-containers 0.1.0.1 - Validity instances for containers  https://hackage.haskell.org/package/validity-containers-0.1.0.1 (Norfair)
16:48:21 <hpc> haasn: is running a separate server and the haskell being a client to it a viable option?
16:48:50 <haasn> hpc: You mean like running a MySQL server or something? If so, yes that's a solution I'd be happy with
16:49:07 <haasn> (Although I'd prefer it to be self-contained and in a directory structure of its own)
16:49:43 <haasn> SQLite might be an option, but I'm not too good at designing SQL schemas for this sort of thing, especially considering that I want searching by tag to be fast (log n?)
16:50:01 <nshepperd1> haasn: tags :: Map Text (Set EntryID)?
16:50:09 <hpc> in this casae it's pretty easy
16:50:16 * nshepperd1 suggests the dumb option
16:50:18 <haasn> Doing something like a list of maps from tags to IDs would definitely be an option
16:50:37 <hpc> create table items (id whatever primary key, other columns);
16:51:07 <hpc> create table tags (tag varchar, item_id whatever);
16:51:17 <hpc> create index tags.varchar or however the syntax goes;
16:51:31 <haasn> I wonder if I could reasonably use a Map Text (Set EntryID) with acid-store
16:51:41 <haasn> I'll try that first I suppose :)
16:51:51 <hpc> oh, maybe
16:51:58 <hpc> if you think you can keep the whole index in memory at once
16:52:52 <haasn> Actually I'm pretty sure I can rule acid-store out already
16:53:03 * hackagebot validity-text 0.1.0.1 - Validity instances for text  https://hackage.haskell.org/package/validity-text-0.1.0.1 (Norfair)
16:53:05 * hackagebot genvalidity-containers 0.1.0.2 - GenValidity support for containers  https://hackage.haskell.org/package/genvalidity-containers-0.1.0.2 (Norfair)
16:53:07 * hackagebot genvalidity-hspec 0.2.0.5 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.2.0.5 (Norfair)
16:53:09 * hackagebot validity 0.3.0.4 - Validity typeclass  https://hackage.haskell.org/package/validity-0.3.0.4 (Norfair)
16:53:11 * hackagebot genvalidity 0.2.0.3 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.2.0.3 (Norfair)
16:53:14 <hpc> it'd be neat to have a generic indexing library that's less janky than IxSet
16:53:20 <haasn> I don't want to pay the cost of loading all O(n) things into memory just to do a search
16:53:29 <hpc> and an alternative to acid-state that lets part of the state leave memory
16:53:38 <haasn> And acid-store implies loading them into memory by design
16:53:55 <hpc> you mean acid-state?
16:53:58 <haasn> Oops, yes
16:54:18 <haasn> The main benefit to acid-state to me is how easy it is to use
16:54:20 <Boomerang> To speed up lookupsyou could keep a small bloom filter of the list of tags for each ID
16:54:22 <haasn> SQL is much more annoying to implement
16:54:55 <haasn> Actually what I could do is use N many acid state databases
16:55:06 <haasn> one for the set of tags overall, and another one for each tag
16:55:24 <haasn> e.g. openLocalStateFrom ("tags/" </> tagName) Set.empty
16:55:37 <haasn> That way I only ever have to pay the O(n) cost of loading all things matching that tag into memory, but that's a given
16:55:52 <haasn> (Because there's no way to list all things matching a tag without paying the O(n) cost anyway)
16:56:18 <hpc> ooh, bloom filters are pretty neat
16:56:21 <Boomerang> :)
16:56:36 <hpc> a very cheesy way to optimize for sparse elements, but still
16:57:01 <haasn> (One downside of this approach is that I can't do a reverse lookup from the ID to each of its tags, although I could store that separately)
16:57:21 <hpc> indexing in both directions is one of the big strengths of RDBMSs
16:57:33 <haasn> My filesystem is essentially already a RDBMS :)
16:58:10 <haasn> well, a really really dumb one
16:58:19 <hpc> filesystems aren't really that relational
16:58:42 <Boomerang> with the bloom filter you have to keep the list of tags anyway (to check if there a tag match because bloom filter can give you false positives), but they don't have to be loaded into memory if there is no match with the bloom filter
17:00:01 <haasn> I'm still sort of evaluating the possibility of just abusing symlinks tricky for this; i.e. tags/foo/ being a directory populated with symlinks to the files that match
17:00:21 <haasn> That works well for listing single tags but it makes boolean expressions hard
17:00:31 <hpc> it's to tries what hashtables are to binary trees
17:04:41 <haasn> Something to consider is that I will have some tags that are extremely dense (e.g. almost every file is tagged) and other tags that are extremely scarce
17:05:27 <haasn> So I will still have to see if acid-state can handle a single Map with millions of entries in a reasonable fashion (including not paying the entire cost per update. Not sure how it serializes its state)
17:08:22 <haasn> Axman6: do you have a favorite haskell binding / front-end to sqlite? I see there are lots of things floating around (persistent-sqlite, hsql-sqlite, sqlite, sqlite-simple, etc.)
17:09:45 <Axman6> I've decided {sqlite,postgresql}-simple is the easiest way to do exactly what you want, but leaves you to manage migrations yourself. this hasn't really been a problem for me
17:09:59 <haasn> Shouldn't be a problem for me either
17:10:12 <Axman6> "exactly what you want" = the collective you, not necessarilly you specifically
17:10:57 <haasn> sqlite-simple seems to be a bit lower level than something like the ‘sqlite’ package, in that it has me writing SQL, but if I'm wanting to manage indices myself I suppose that's going to be beneficial
17:14:30 <soLucien> what's wrong with this code? it won't parse
17:14:31 <soLucien> http://lpaste.net/610148384124174336
17:14:42 <soLucien> i tried with case as well
17:14:55 <bethebunny> having a lot of trouble with monad application in general; http://pastebin.com/U3aeSkXW
17:14:59 <Axman6> you use = not -> to define functions
17:15:40 <bethebunny> can anyone explain why it really wants Vector.! to return a vector type on line 23?
17:15:50 <bethebunny> general suggestions for code style also appreciated :)
17:15:57 <Axman6> bethebunny: compare `F.on` (\(x, y) -> y) is also known as "comparing snd" (comparing is very handy, in Data.Ord)
17:16:31 <soLucien> Axman6 still parse error
17:16:32 <bethebunny> oh, yeah, was looking for that function first but stackoverflow suggested this :)
17:16:34 <Axman6> bethebunny: it would help (us) if you put some type signatures on your functions
17:16:35 <bethebunny> thanks
17:16:44 <bethebunny> sec
17:16:51 <Axman6> soLucien: I think the where clause has to be outside the lambda too
17:17:12 <soLucien> parse error
17:17:19 <soLucien> how should i restructure it?
17:17:24 <soLucien> i believe it's the lambda as well
17:18:26 <Axman6> soLucien: does the annotation on http://lpaste.net/610148384124174336 work?
17:18:41 <grantwu> what is the type of Value?
17:18:57 <bethebunny> http://pastebin.com/jeNzHcnW
17:19:17 <bethebunny> apparently I don't actually understand the signature of vCollatz but I think that's because I haven't resolved the other type errors
17:19:23 <bethebunny> I think it should be Int -> (Int -> Int)
17:19:41 <johnw> \*
17:20:31 <soLucien> Axman6 env is not in scope
17:20:33 <soLucien> anymore
17:20:59 <grantwu> I would convert this to a let I think
17:21:04 <grantwu> soLucien: What's the type of value though
17:21:10 <soLucien> data value
17:21:44 <grantwu> it seems like the type of getVar name is going to be a SubsM <function type> though
17:21:45 <soLucien> http://lpaste.net/610148384124174336
17:21:52 <soLucien> updated with type ov Value
17:22:25 <grantwu> Yeah, I don't think that's going to typecheck...
17:22:27 <Cale> bethebunny: I don't think you want a do there.
17:22:28 <Axman6> bethebunny: so, the return type of (>>=) when applies to Vectors is definitely going to be a vector
17:22:39 <Axman6> applied*
17:23:19 <bethebunny> hmm, maybe I still don't understand >>= then
17:23:33 <bethebunny> I thought the return type should be the return type of the rightmost function?
17:24:27 <Axman6> :t (>>=)
17:24:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:24:55 <Axman6> :t (>>=) `asAppliedTo` (undefined :: Vector Int)
17:24:57 <lambdabot> error:
17:24:57 <lambdabot>     Not in scope: type constructor or class ‘Vector’
17:25:02 <Axman6> :t (>>=) `asAppliedTo` (undefined :: V.Vector Int)
17:25:03 <lambdabot> error:
17:25:03 <lambdabot>     Not in scope: type constructor or class ‘V.Vector’
17:25:03 <lambdabot>     No module named ‘V’ is imported.
17:25:08 <Axman6> :(
17:25:12 <soLucien> changed it to Let
17:25:15 <soLucien> and magically worked
17:26:24 <bethebunny> ah, so in this case it's operating in the vector monad (?) so m == Vector?
17:26:31 <bethebunny> so it's essentially a vector transformation
17:26:31 <soLucien> http://lpaste.net/610148384124174336
17:26:32 <Axman6> anyway, yes
17:26:37 <soLucien> pretty weird, isn't it ?
17:26:38 <Cale> bethebunny: It's ambiguous which monad it's in
17:26:41 <Axman6> I assume Vector had a Monad instance
17:26:57 <Axman6> actually Cale's right
17:26:58 <Cale> Vector doesn't have a monad instance, I think
17:27:28 <grantwu> soLucien: I have no idea why that typechecks
17:27:31 <Cale> There's no reason for that do
17:27:35 <Cale> in vCollatz
17:27:47 <Cale> You should just use  let ... in ...
17:27:58 <Cale> (no return either)
17:28:07 <soLucien> why wouldn't it ?
17:28:21 <bethebunny> that makes sense
17:28:34 <bethebunny> the do is leftover from when I was slapping dos everywhere :P
17:28:38 <grantwu> soLucien: Is the lambda of type Value?
17:29:31 <soLucien> the lambda is newtype SubsM a = SubsM {runSubsM :: Context -> Either Error (a, Env)}
17:29:52 <soLucien> whare a = Value in this case
17:29:56 <soLucien> where
17:30:17 <grantwu> no, the lambda makes no reference to SubsM....
17:30:19 <Cale> I also have no idea what the heck that definition of y is meant to be doing there...
17:30:32 <Cale> It's using >>= in a weird way, and I don't know what the intention is.
17:31:21 <bethebunny> Oh man I did it :P
17:31:36 <bethebunny> (v V.// [(x,y'')]) V.! x
17:31:56 <Cale> ah, okay, it's just supposed to be gone :)
17:33:16 <Cale> Somehow, I don't imagine this will be very efficient... you're allocating a new array for each of those modifications...
17:33:34 <bethebunny> Oh wait what I am?!
17:33:43 <Cale> yeah
17:33:47 <bethebunny> That would explain why it's so freaking slow
17:33:54 <Cale> It's an immutable vector
17:33:56 <Cale> It would make more sense to use a *boxed* Vector and just define the elements from the outset recursively
17:34:13 <Cale> Or if you want to do mutation, use mutable vectors
17:34:25 <bethebunny> I thought I was using mutable vectors >.>
17:34:27 <Cale> (but then you'll need it to be in IO or ST)
17:34:31 <monochrom> the worst of both worlds
17:36:23 <pavonia> :t (\~(a, s) -> s)
17:36:24 <lambdabot> error: parse error on input ‘->’
17:36:32 <pavonia> ^ Why does this happen?
17:36:40 <Axman6> why indeed!
17:36:52 <Axman6> :t (\(~(a,b))->a)
17:36:54 <lambdabot> (t, t1) -> t
17:37:04 <Axman6> bleh, really? so lisp
17:37:20 <bethebunny> oh this resulted from reading https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/vector.md#mutable-vectors carefully enough :/
17:37:29 <bethebunny> it clearly says "first let's implement using immutable vectors"
17:37:54 <bethebunny> that's why I had do's everywhere is because I was trying to make these mutable
17:37:59 <monochrom> > let x \~ y = x && y in True \~ False
17:38:02 <lambdabot>  False
17:38:04 <monochrom> That's why.
17:38:25 <Cale> bethebunny: But just sprinkling do everywhere doesn't actually... do anything :)
17:38:25 <exio4> insane 
17:38:27 <pavonia> Oh!
17:38:55 <pavonia> monochrom: Thanks!
17:39:05 <bethebunny> Cale: yeah, except give me an ulcer
17:39:10 <Cale> You've got to use the actions defined in Data.Vector.Unboxed.Mutable or some such
17:39:18 <bethebunny> essentially I'm ajust trying to implement this guy: http://pastebin.com/F1d3ds0g
17:39:22 <Cale> To read and write the things explicitly
17:40:11 <bethebunny> what's the best way to actually evaluate them? something like ST.runST $ do ?
17:40:32 <bethebunny> somehow this tutorial gets away without doing anything like that
17:41:48 <monochrom> the tutorial uses the IO flavour of mutable vectors
17:43:08 <monochrom> it leaves the ST flavour as an exercise
17:43:44 <bethebunny> yeah, I'm noticing a pattern of tutorials that do that :/
17:44:06 <monochrom> err, no, it uses V.modify which already does runST for you
17:44:07 <bethebunny> is there a name for things that should be to the right side of (<-) in a do?
17:44:22 <monochrom> action
17:44:34 <bethebunny> okay
17:44:39 <Axman6> > do 7
17:44:41 <lambdabot>  7
17:44:55 <bethebunny> is there a way to conditionally store the result of an action, otherwise store the result of a pure function?
17:44:56 <Axman6> do 7 + (do 8)
17:44:58 <Axman6> > do 7 + (do 8)
17:45:00 <lambdabot>  15
17:45:30 <monochrom> x <- if True then getLine else return "x"
17:46:12 <bethebunny> ah okay
17:46:27 <bethebunny> so return has type (a -> action a) essentially?
17:46:36 <Axman6> or pure "X" if you want to save two characters >_>
17:46:36 <bethebunny> or is it special somehow?
17:46:43 <Axman6> :t return
17:46:44 <lambdabot> Monad m => a -> m a
17:47:02 <bethebunny> I should get better at using that
17:47:15 <bethebunny> is there something similar that shows docstrings ala python help()?
17:47:20 <Axman6> it is in no way special, other than being one of the functions defined in the Monad typeclass (and is no more special than any other typeclass function)
17:47:51 <Axman6> there's Haddock, but it doesn't have a comparable idea afaik
17:48:05 <Axman6> hmm, GHCi doesn't have some support for haddock docs does it?
17:48:26 <monochrom> no
17:48:28 <dmwit> bethebunny: http://hackage.haskell.org/package/haskell-docs
17:49:31 <dmwit> But I have to admit that mostly I view Hackage's haddocks.
17:52:20 <bethebunny> ghc compile errors make me miss g++
17:52:47 <dmwit> Really? I've found GHC's messages quite detailed and targeted for most things.
17:53:16 <bethebunny> I'm sure they are once you learn to read them
17:53:25 <dmwit> My memory of C++ hacking was that errors were either obvious things, for which a line number sufficed, or template errors where the compiler spewed a thesis on how wrong you were.
17:53:42 <bethebunny> the second is how I feel every time ghc doesn't compile
17:53:58 <dmwit> Share! Perhaps we can explain. =)
17:54:02 <dmwit> ?lpaste
17:54:02 <lambdabot> Haskell pastebin: http://lpaste.net/
17:55:26 <bethebunny> I like the linter there :)
17:55:27 <bethebunny> http://lpaste.net/7790357465559728128
17:55:40 <bethebunny> it doesn't show the same error ghc is though
17:55:55 <dmwit> Yes, you have to include the error yourself if you want us to see it.
17:56:06 <geekosaur> hlint is a heuristic linter, it doesn't run ghc
17:56:14 <bethebunny> kk
17:56:16 <geekosaur> you can install hlint from hackage and run it locally
17:57:06 <dmwit> I admit that the error I'm seeing from GHC is fairly verbose. =)
17:57:08 <geekosaur> (although a word of warning: hlint can be wrong and suggest a type error. heuristics often fail in the presence of higher order types, for example)
17:57:18 <geekosaur> or even just passing a function as a value, sigh
17:58:23 <dmwit> bethebunny: Okay, the first error I see includes a suggestion for fixing it. ("Use FlexibleContexts to permit this")
17:58:53 <dmwit> bethebunny: Many GHC error messages will tell you to turn on an extension in this way, so it makes sense to learn to quickly scan for this. Turning on the extension isn't *always* the right thing -- but most times it is.
17:59:26 <grantwu> Sometimes after a bad typo GHC suggests "Perhaps you meant to use Template Haskell".
17:59:26 <dmwit> bethebunny: The next error I get is because `vCollatz` appears to be a monadic action in some monad, and you're trying to print it without running it first.
17:59:32 <grantwu> This is almost never the right thing to do.
18:00:27 <dmwit> bethebunny: If you give type signatures for all your top-level functions and values (which is often considered best practices) you may get a clearer error message there.
18:01:20 <bethebunny> I glanced through the flexiblecontexts wiki but still don't understand it
18:01:45 <dmwit> bethebunny: However, starting up ghci with -fdefer-type-errors and asking for the type of `vCollatz` gives me something so horrendous that I can only assume you've really screwed up inside its implementation.
18:01:56 <bethebunny> let alone how to enable it
18:02:04 <bethebunny> undoubtedly true :P
18:02:08 <dmwit> bethebunny: Oh! Okay, well, all extensions are enabled in the same way.
18:02:21 <haasn> Axman6: hpc: Boomerang: I ended up using Xapian-Haskell, which was slightly bitrotten but I got it to work. Xapian is an almost perfect match for my use case, because it literally implements an efficient tag-store with natural language boolean lookup
18:02:25 <dmwit> bethebunny: Either pass -XExtensionName to GHC, or add {-# LANGUAGE ExtensionName #-} to the top of your module.
18:02:41 <haasn> Far less work than designing my own database schema from scratch and suffering my way through SQL :)
18:02:41 <dmwit> bethebunny: Or, if you're using cabal, list it in the appropriate extension stanza of your cabal file.
18:02:54 <bethebunny> ic
18:03:06 <dmwit> bethebunny: Again, if you give a type signature for vCollatz saying what type you think it ought to have, you will probably get a much more targeted complaint out of GHC.
18:03:31 <bethebunny> the hope was this would be relatively simple, since it's quite easy to get very good performance in both c and python with base language features ie no import/include
18:03:33 <dmwit> ...the call to unsafeCoerce makes me quite nervous as well. What is that about?
18:03:59 <dmwit> I can't imagine why something named "collatz" should need to do any coercing at all.
18:04:03 <bethebunny> ah I think that was leftover
18:04:05 <bethebunny> right?!
18:04:30 <bethebunny> but basically the first action of vCollatz is creating a collatz instance with a storage section for the first n results
18:04:41 <monochrom> collatz is pretty simple in C, after you have learned C well.
18:04:54 <monochrom> likewise, collatz is pretty simple in Haskel, after you have learned Haskell well.
18:04:54 <bethebunny> monochrom: http://pastebin.com/F1d3ds0g
18:05:04 <bethebunny> yeah, I have about 6 working implementations
18:05:15 <bethebunny> none of them get within 5 orders of magnitude of c performance
18:05:40 <bethebunny> and my understanding is that shouldn't be necessarily the case, that haskell can achieve very good performance
18:06:07 <grantwu> I think the problem is that you're having issues with memoization, right?
18:06:13 <bethebunny> yeah
18:06:25 <dmwit> bethebunny: um
18:06:35 <grantwu> Maybe https://hackage.haskell.org/package/memoize would be helpful?
18:06:43 <grantwu> "This technique relies on implementation assumptions that, while not guaranteed by the semantics of Haskell, appear to be true." -_-
18:06:56 <dmwit> bethebunny: `v` is a monadic action. You're trying to `read` from it. That doesn't make sense. You read from vectors, not actions.
18:07:32 <dmwit> bethebunny: I think you have severely misunderstood how to use mutable vectors in Haskell.
18:07:41 <bethebunny> dmwit: I definitely agree
18:09:08 <geekosaur> grantwu, as I understand it, an implementation is only required to be non-strict. precisely how it does that is up to the impl, but the one used by ghc (and in the past by hugs, nhc98, yhc, uhc, jhc, etc.) is the simplest on most CPUs, so it's reasonably safe
18:09:28 <bethebunny> grantwu: here's some of the previous attempts: http://lpaste.net/484046220168265728 while these all work as expected, the performance is quite slow comparatively
18:09:45 <grantwu> geekosaur: I'm still kind of new to Haskell - how did you figure out that the assumption was that Haskell impls are lazy?
18:09:58 <geekosaur> because I've seen that package before
18:10:09 <grantwu> oh, ok
18:10:35 <geekosaur> and it's not really lazy vs. non strict. it's thunks vs. some other impl
18:10:39 <dmwit> bethebunny: I'll take a stab at it and let's compare notes.
18:10:52 <geekosaur> but there aren't many other impls; thunks are easy, obvious, and give the required semantics
18:11:06 <geekosaur> (obvious to an implementor, that is)
18:12:00 <geekosaur> truly lazy isn't actually useful; it'd mean some external mechanism would be needed to force evaluation. non-strict means you can specify ways to force evaluation (as Haskell does; primarily, pattern matching)
18:14:05 <geekosaur> um. mre specifically shared thunks
18:14:15 <geekosaur> and it's the shared-ness that enables memoization to work
18:14:49 <geekosaur> something could choose not to do it, but it would waste memory and often require extra work to be done, so you don't usually see non-shared thunks except by deliberate machinations
18:15:33 <geekosaur> (or failed attempts at memoization >.> )
18:16:07 <grantwu> haha
18:27:39 <Cale> bethebunny: heh, played around with your code a bit http://cale.yi.org/reflex/Collatz/Collatz.jsexe/
18:28:16 <dmwit> bethebunny: http://pastebin.com/Z68J7uL7
18:28:31 <Cale> bethebunny: (try just mashing large numbers into the text input box :)
18:30:34 <dmwit> bethebunny: Seems to be competitive with your C code on my machine.
18:31:15 <monochrom> well that's disappointingly fast. javascript compiled to haskell and it feels instant responses
18:31:25 <monochrom> err, haskell compiled to javascript.
18:33:01 <dmwit> But it computes a different function than bethebunny seems to want, doesn't it? Given i, he wants j<=i which maximizes the length of the collatz sequence starting at j.
18:34:03 <exio4> Cale: what's the easiest way to get a working compiler/setup for reflex development?
18:35:00 <bethebunny> interesting
18:35:18 <Cale> exio4: I would say reflex-platform
18:35:18 <bethebunny> will undoubtedly learn a lot from trying to understand both of these :)
18:35:30 <Cale> https://github.com/reflex-frp/reflex-platform
18:35:55 <Cale> (There's instructions and a short tutorial if you scroll down)
18:36:33 <bethebunny> Also, what's the difference between $ and <$>?
18:36:39 <grantwu> :t $
18:36:40 <lambdabot> error:
18:36:41 <lambdabot>     parse error on input ‘$’
18:36:41 <lambdabot>     Perhaps you intended to use TemplateHaskell
18:36:44 <Cale> $ is simply function application
18:36:48 <Cale> f $ x = f x
18:36:50 <grantwu> .-. no I did NOT intend to use TemplateHaskell
18:36:53 <grantwu> :t (%)
18:36:55 <lambdabot> Integral a => a -> a -> Ratio a
18:36:55 <grantwu> oops
18:36:56 <Cale> But $ is defined to have really low precedence
18:36:59 <grantwu> :t ($)
18:37:02 <lambdabot> (a -> b) -> a -> b
18:37:07 <grantwu> :t (<$>)
18:37:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:37:14 <Cale> (whereas function application normally has higher precedence than any infix operator)
18:37:30 <Cale> Yeah, (<$>) is fmap, but infix
18:37:38 <DJFLEXX> 300 POUNDS BITCH IN MY DIAMOND JACUZZI
18:37:52 <bethebunny> I see
18:38:00 --- mode: ChanServ set +o Cale
18:38:09 --- mode: Cale set +b *!*@ip68-228-139-82.hr.hr.cox.net
18:38:09 --- kick: DJFLEXX was kicked by Cale (DJFLEXX)
18:38:15 --- mode: Cale set -o Cale
18:39:50 <bethebunny> anyway thanks a ton, learned(-ing) a lot!
18:40:19 <exio4> Cale: Reflex looks so easy.
18:40:36 <Cale> It's pretty great
18:41:02 <Cale> If you do complicated things, you can still get yourself into tricky situations, like with anything.
18:41:29 <Cale> But generally, it's very nice, and it scales up to quite complicated applications pretty well.
18:41:57 <exio4> and I am learning PHP at uni :/
18:43:08 <exio4> Cale: what's the most comprehensive resource you know for Reflex?
18:43:47 <Cale> exio4: Well, there's some haddocks for the new branch here:
18:43:48 <Cale> http://web.mit.edu/greghale/Public/reflex/html/reflex/index.html
18:43:52 <Cale> http://web.mit.edu/greghale/Public/reflex-dom-new/html/reflex-dom/index.html
18:44:50 <Cale> I'm hoping to get a bunch of time soon to work on some more comprehensive tutorials
18:45:43 <exio4> Cale: well, guess I gotta play with it 
18:45:45 <Cale> There's a #reflex-frp where the reflex people hang out (e.g. ryantrinkle will probably not see your questions in #haskell, but he's hanging out there a lot more often)
18:46:25 <exio4> you'll see my questions there in a few weeks ;) 
18:46:32 <Cale> http://cale.yi.org/reflex/
18:46:40 <Cale> I have a bunch of little demos of various things here
18:47:10 <Cale> Some toys that I built for myself + some things I built in response to people's questions about it
18:49:50 <monochrom> Cale: you're probably off by 1 because "if (n==1) return 1" but "pureCollatz 1 = 0"
18:50:50 <exio4> I will be installing a clean distro in the next week, and try reflex there, thanks!
18:52:30 <Cale> exio4: reflex-platform *will* chew up a decent few GB of space, since it uses nix to install literally all of the dependencies, but it does ensure a certain nice amount of consistency
18:52:58 <exio4> Cale: not a problem currently :) 
19:09:15 <haasn> pattern match failures inside a MonadPlus do block get compiled to mzero, right?
19:10:05 <haasn> Oh wait, that was ‘fail’ in Monad, which has apparently been moved to MonadFail now?
19:11:09 <haasn> Doesn't seem like my monad implements MonadFail or ‘fail’ :(
19:12:55 <haasn> Fortunately, with the MonadFailProposal I can now define an orphan instance :D
20:06:14 <koz_> Could someone explain me something about free monads? I basically get how the construction works (you basically 'wrap up' your Pure with multiple onion layers of functor and Free, which kinda looks like a sequence of operations), but what I don't get is how you would then have it behave as a particular monad by introducing the 'right' functor.
20:06:37 <koz_> What I'm trying to do seems like it needs a four-transformer stack, and I was wondering if I'd lose less sanity by doing it using free monads instead.
20:08:31 <haasn> koz_: The way I kept seeing was to define your evalMonad by recursively pattern matching the ‘Free’ and doing the right thing in each step
20:09:53 <koz_> haasn: So basically, suppose I wanted a stack of RandT StdGen, WriterT [Text], ReaderT (Int, Int) and StateT Int, with a Vector a inside, would the thing I wrap into the Free monad just carry all the necessary state, and then the 'doing the right thing' is just 'go from one instance of the whole deal to the next' or something?
20:10:03 <koz_> (and I'm not kidding - I *actually* need something like that)
20:10:20 <koz_> (with possibly a MaybeT in there as well)
20:11:31 <haasn> Writer/Reader/State sounds like RWST
20:11:59 <koz_> haasn: That makes things a bit simpler, but my question still stands.
20:12:58 <koz_> (also, the kind for RWST is hilarious)
20:13:40 <Cale> koz_: I find it tends to help to focus on a *specific* monad that happens to be free before approaching the general construction from an arbitrary functor
20:13:42 <haasn> but if you have a functor stack (Free baggage excluded) like FooOp a (BarOp b (FooOp c ...)) you can write your eval function like eval (FooOp a c) = do {- implement stuff necessary for ‘foo a’ -} >> eval c
20:13:44 <Cale> Consider something like...
20:13:52 <benzrf> :k RWST
20:13:54 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
20:13:55 <benzrf> goodness
20:14:10 <Cale> koz_: Well, are you familiar with State s a?
20:14:26 <Cale> (the usual implementation of that)
20:14:33 <Cale> I'm guessing you are :)
20:14:42 <haasn> where eval can be a type like :: Free FooF a -> CrazyMonadStack a
20:14:43 <koz_> Cale: Not *very*. I certainly don't feel too comfortable answering questions about it or teaching it to someone else.
20:15:27 <Cale> koz_: Okay, but you get the general idea that values of type State s a represent computations which ultimately produce some result of type a, while manipulating a state of type s
20:15:34 <koz_> Yeah, *that* I get.
20:15:43 <haasn> Of course, this approach doesn't solve the problem of the crazy monad stack being *there*. If somebody else can think of a way to do that, I'd love to know
20:16:01 <Cale> The usual definition is to do something like   newtype State s a = S (s -> (s,a))
20:16:07 <Cale> But let's take a different approach
20:16:44 <Cale> Instead, we could recognise that any such action will fall into one of three sorts:
20:17:07 <Cale> It might just return a constant value of type a without manipulating the state at all
20:17:39 <Cale> It might start off by setting the state to some new value of type s, before proceeding with some other State s a computation
20:18:27 <Cale> Or it might start off by getting the current state, and following that up with some computation depending on the state that it read, which we'll record as a function  s -> State s a
20:18:41 <Cale> Based on this, we might define:
20:19:01 <Cale> data State s a = Return a | Put s (State s a) | Get (s -> State s a)
20:19:12 <koz_> Corresponding to the usual operations provided by State, OK.
20:19:15 <Cale> yeah
20:19:25 <Cale> So we can define the usual operations as follows:
20:19:39 <Cale> put s = Put s (Return ())
20:19:42 <prsteele> Hello everyone. I'm finding System.Random to be quite slow. Surprisingly, System.Random.Mersenne.Pure64 is even *slower*. Am I doing something wrong?
20:19:48 <Cale> get = Get Return
20:20:20 <koz_> OK, I follow - that lines up nicely with the types the conventional definition of State has.
20:20:51 <Cale> prsteele: Nope, those are both pretty slow.
20:21:17 <prsteele> Cale: (checks the authors of MonadRandom...) any suggestions then? Preferably without involving ST or IO?
20:21:40 <prsteele> I'm doing something finicky where I'd need to thread in and out of IO/ST repeatedly
20:21:51 <prsteele> which perhaps tells me I'm doing somethign wrong, but I like the design otherwise
20:23:11 <dmj`> prsteele: check
20:23:14 <dmj`> @packages mwc-random
20:23:14 <lambdabot> http://hackage.haskell.org/package/mwc-random
20:23:16 <Cale> Well, I don't know if there's something really fast that doesn't involve IO
20:23:18 <Cale> or ST
20:23:34 <Cale> mwc-random is one of the things I'd recommend otherwise
20:23:45 <dmj`> anything bos :) 
20:23:55 <Cale> http://hackage.haskell.org/package/Xorshift128Plus -- maybe try this?
20:24:05 <prsteele> alright. I'll keep trying to shoehorn my approach into mwc with ST.
20:24:10 <prsteele> also I'll look at xorshift
20:25:05 <Cale> http://hackage.haskell.org/package/xorshift has an instance of RandomGen
20:25:05 <koz_> OK, Cale, so we have this sum type for State.
20:25:09 <Cale> koz_: Okay
20:25:26 <Cale> koz_: So, maybe we should just finish the picture with runState
20:25:35 <Cale> runState :: State s a -> s -> (s,a)
20:25:45 <Cale> runState (Return v) s = (s,v)
20:26:05 <Cale> runState (Put s' x) _ = runState x s'
20:26:21 <Cale> runState (Get f) s = runState (f s) s
20:26:47 <koz_> So basically, the State we've described gives us a structure representing a sequence of operations, and runState makes them manifest?
20:26:51 <Cale> So, this sort of splits up the work of defining the monad a little differently -- we got to decide the operations we wanted up front, basically
20:27:02 <Cale> and then runState got to be a little more work to write
20:27:41 <Cale> but, well, get and put were easy to write before, so maybe not the clearest example of how those became simpler, as they were already pretty trivial
20:27:53 <Cale> But in general, this approach puts more of the work into the 'run' function.
20:27:59 <koz_> Yeah, I get that.
20:28:14 <Cale> okay
20:28:24 <Cale> So, this generalises
20:28:45 <Cale> Well, hm, maybe I should actually define the Monad instance
20:28:59 <Cale> return = Return
20:29:10 <Cale> Return v >>= f = f v
20:29:36 <Cale> (Put s x) >>= f = Put s (x >>= f)
20:29:57 <Cale> (Get k) >>= f = Get (\s -> k s >>= f)
20:30:15 <koz_> OK.
20:30:24 <koz_> That actually makes a surprising amount of sense.
20:30:51 <Cale> Okay, so you might believe that we could decide up front to include lots of other operations, and we'd be able to extend the definition of (>>=) without having to think too hard
20:31:16 <Cale> But runState would have to include some interesting implementation of our new operations
20:31:58 <Cale> It's possible to actually factor this whole mechanism apart, so we don't have to redefine the Monad instance as we add new "commands"
20:32:14 <koz_> (in this case meaning new parts of the sum type, right?)
20:32:17 <Cale> yeah
20:32:23 <koz_> Uh-huh, I see.
20:33:42 <Cale> So, first of all, let's pull out the commands like this... we had:
20:33:47 <Cale> data State s a = Return a | Put s (State s a) | Get (s -> State s a)
20:33:56 <Cale> So, we'll define
20:34:20 <Cale> data StateCommand s x = Put s x | Get (s -> x)
20:34:49 <Cale> and we can then redefine State s a in terms of this:
20:35:11 <Cale> data State s a = Return a | Command (StateCommand s (State s a))
20:35:33 <koz_> OK, so we basically have a 'just finish' part and a 'build up bigger computation' part.
20:35:34 <Cale> Of course, this would be silly if we didn't plan to go a bit farther...
20:35:37 <Cale> yeah
20:35:51 <Cale> The next thing is just to factor out StateCommand s altogether
20:36:15 <Cale> data Free f a = Return a | Command (f (Free f a))
20:36:28 <koz_> Now, f has to be a functor for this to work, right?
20:36:51 <Cale> Yeah, that helps us to define the Monad instance
20:37:03 <Cale> So, for StateCommand, we'd have
20:37:09 <Cale> instance Functor (StateCommand s) where
20:37:23 <Cale>   fmap f (Put s x) = Put s (f x)
20:38:09 <Cale>   fmap f (Get k) = Get (\s -> f (k s))
20:38:32 <koz_> So basically, the functor instance 'builds up' the computation by incorporating f?
20:39:39 <Cale> Yeah, basically
20:39:53 <Cale> It's doing the obvious thing based on the type
20:40:06 <prsteele> can I trust the disclaimers of Control.Monad.ST.Trans? I.e. I can throw a State monad inside it and things will work out?
20:40:11 <Cale> fmap :: (a -> b) -> StateCommand s a -> StateCommand s b
20:40:40 <koz_> OK, I think I'm seeing what you're driving towards.
20:41:00 <koz_> Basically, now if we wanted StateFrobnicateCommand later, we can just define it, make it a functor, and then it'll magically work?
20:41:33 <Cale> koz_: Yeah, and of course, we can get other monads without Get and Put, but with differently-shaped operations
20:41:49 <Cale> This functor just determines the shape of the operations that we want
20:42:08 <koz_> OK, I think I follow. So what would a State-specific Free look like? The one above is generic to what it produces.
20:42:19 <koz_> Would it be Free f (s, a) or something?
20:42:35 <Cale> I thought I started with the State-specific Free :)
20:42:43 <Cale> That's what my alternative definition of State was :)
20:43:31 <koz_> OK, let me rephrase. The 'Free f a = Return a | Command (f (Free f a))' definition works for any a, which doesn't have to be State-resembling in any way.
20:43:44 <Cale> works for any *f*
20:43:54 <Cale> (which is a functor)
20:43:57 <koz_> (as long as f is a functor)
20:44:03 <Cale> and that f doesn't have to look like StateCommand s
20:44:33 <Cale> a there is the result type, and the thing wouldn't be a monad or a functor if that wasn't completely arbitrary
20:44:47 <Cale> (at least not a monad on this category)
20:44:58 <koz_> OK, so what would runState's type now look like, then?
20:45:05 <koz_> (I mean, using the Free construction above?)
20:46:24 <Cale> Well, runState (Return v) = v as before
20:46:40 <koz_> Cale: I meant the type, not the definition.
20:46:48 <koz_> If I see the type, the definition will be obvious anyhow.
20:46:57 <Cale> runState :: Free (StateCommand s) a -> s -> (s,a)
20:47:17 <koz_> OK, that explains what I was trying to ask.
20:47:31 <koz_> So the kind of monad we have is determined by what functor we pin it to.
20:47:37 <Cale> yeah
20:47:39 <koz_> (or rather, what said monad is meant to do)
20:47:58 <Cale> and note that all the real work that get/put do is described by the implementation of runState
20:48:17 <koz_> Cale: Not the implementation of StateCommand?
20:48:51 <Cale> Yeah, the implementation of StateCommand basically says "hey there are these operations Get and Put, and here are their types"
20:49:00 <Cale> but it doesn't say how to implement them
20:49:07 <Cale> We could implement them a completely different way
20:49:13 <koz_> That's the job of the interpreter, hence the logic living in runState.
20:49:32 <Cale> yeah
20:49:40 <koz_> And we could implement evalState and execState without ever caring about what StateCommand even was, right?
20:49:58 <koz_> (for instance)
20:49:58 <Cale> You mean, given runState?
20:50:05 <Cale> Or what?
20:50:20 <koz_> Cale: Never mind, I worded that badly.
20:50:28 <koz_> I think I basically get the idea.
20:50:49 <koz_> So for what *I* want to do, I guess I should first decide what operations I want, and write a type to describe them.
20:50:54 <koz_> (like StateCommand above)
20:50:58 <koz_> Then wrap the whole thing in Free.
20:51:01 <f-a> Hello, I was jotting down an idea for simple 2d, tile based game. When doodling, i found myself thinking "ok, every game object has coordinates x:y, some more specific object have a speed/acceleration attribute too, etc.". I can use typeclasses (and =>) to express this. More difficult is to 'plug' this together, i.e.: say I have a list of Objects a, then I'd like to know which of those are 'affected by gravit
20:51:05 <koz_> Then write an appropriate interpreter?
20:51:07 <f-a> y' (Solid), but of course there is no way of doing that (I cannot filter for it). I feel I took the wrong approach.
20:51:17 <Cale> koz_: Yeah
20:51:44 <koz_> Cale: OK. Now, do you think this is easier than the monad transformer route, especially for someone like me (who has a pretty tenuous grasp on both)?
20:52:01 <Cale> koz_: and if you pick up some library for the free monad on a functor, like Ed's "free", it'll have a bunch of tools which may help to write interpreters
20:52:11 <koz_> Cale: I'm already looking at Ed's free.
20:52:20 <koz_> (specifically Control.Monad.Free.Church)
20:52:36 <f-a> so the question lies in: is there a 'proper' way to do it?
20:53:23 <Cale> koz_: So, if you look at, say, foldFree
20:53:47 <koz_> Cale: foldF, you mean?
20:54:15 <Cale> uhhh
20:54:31 <Cale> Oh, you're looking at the Church one, so yes
20:54:53 <koz_> I'm just trying to make sense of its type.
20:54:57 <Cale> This basically says "Give me a way to interpret the operations, and I will give you an interpreter"
20:55:35 <dmwit> f-a: One possibility would be to use the instance for "gravity-unaffected" types just do nothing when asked to take account of gravity.
20:56:14 <koz_> OK, I gotta dash, but thanks *so* much for the explanation, Cale.
20:56:21 <koz_> I think I'll use free monads for what I need to do.
20:56:25 <Cale> Cheers!
20:56:56 <dmwit> f-a: But I suspect your idea to use type classes is going to be a source of pain later. If you want to store a bunch of things in a container, they're all going to have to have the same type.
20:56:57 <Cale> koz_: I can't say they're better or worse than monad transformers, but having this option in your head will help you make better decisions.
20:57:30 <dmwit> f-a: So you might as well embrace that up front and have a single type. But then typeclasses buy you little, since you'll also then only have one instance.
20:57:31 <Cale> koz_: At some point, ask me about van Laarhoven free monads
20:58:03 <Cale> koz_: There's another way we can encode monads in terms of their operations, and sometimes it's a little easier to apply
20:58:41 <f-a> dmwit: mhhh indeed a single sum type would make things similar to dynamic. I guess if there are no other choices that's the way to go
21:00:31 <dmwit> Unless your sum has an incredibly high number of terms, a sum type is going to still give you a lot more promises than Dynamic. =)
21:03:25 <f-a> haha I meant dynamic as the typing, not the lib! In any case, that would mean I have to hardcode everything, right? Basic Int Int | Gravitoon Int Int Int Int <-- the first two ints are coords, but now I need two write two functions (or well, two lines of a function) to fetch them, right ?
21:03:55 <prsteele> how would I go about embedding state inside an ST computation? I'd like to be able to be in any function inside the ST computation and, for example, `ask` or `get` a value that is bound to the ST computation
21:04:38 <jchia1> How come cereal package has Data.Serialize.Put.putWord64le but no putInt64le? What can I do if I want to put an Int64 with a specific endianness?
21:04:44 <f-a> seems doable albeit a bit messy dmwit
21:05:40 <dmwit> I'm not sure what you mean by "hardcode".
21:06:33 <dmwit> Okay, I think I know what you mean.
21:06:52 <f-a> dmwit: with typeclasses, I could have written class Object a where... coords :: a -> (Int, In-
21:07:08 <dmwit> If there are attributes that *all* kinds of objects share, you can factor that out to its own type; or you can use record syntax; or you can just write functions, and you won't have to write more than you would have with your other approach anyway.
21:07:18 <dmj`> why does "class F a where f :: Rep (Either String a) x" compile but "class F a where f :: Rep (Except String a) x" doesn't?, that latter saying Rep isn't injective
21:07:25 <dmwit> f-a: Yep, and you would have had to write two instances. So two clauses in your function doesn't seem worse.
21:07:35 <f-a> i see
21:08:01 <bashhack> Sorry to bother - is anyone else getting server capacity errors (503) when running a stack new command or trying to reach haskellstack.com?
21:10:43 <Axman6> bashhack: yep
21:12:30 <dmwit> dmj`: Seems there is no Generic instance for Except.
21:12:51 <dmj`> dmwit: ah, hm
21:12:56 <dmwit> dmj`: Compare the outputs of `:kind! forall a x. Rep (Either String a) x` and the `Except` version.
21:13:23 <dmwit> dmj`: The former reduces a lot, the latter not at all. Possibly if it could reduce more unification could happen.
21:15:18 <dmj`> dmwit: ah, yea it seems like Except lacks compile time metadata
21:16:03 <dmwit> Although I'm not sure of this explanation. After adding `deriving instance Generic (ExceptT e m a)` it still doesn't compile.
21:16:26 <bashhack> Axman6 thanks for the confirmation!
21:17:57 <dmwit> dmj`: Well, this is fun. If I put the `class` declaration in `test.hs`, it doesn't compile. But if I leave it out and write the class declaration in ghci, it's accepted.
21:18:00 <dmwit> (wut)
21:20:18 <dmwit> dmj`: I can offer no explanation for why a file and ghci disagree in this way.
21:20:48 <cath_> I have an acid-state db comprised of a fairly straight-forward string/record key/value pair.  It's about 2gb on disk and it takes about 20 minutes to load when my executable starts up.  Is there anything I can do to speed this up?
21:21:22 <schell> cath_: have you done a … checkpoint? i think that’s what it’s called
21:22:08 <f-a> dmwit: ok, I'll follow that path. Seems a tad coarse but it'll do!
21:22:34 <dmj`> dmwit: well I'm glad it's not just me :]
21:22:48 <Axman6> yeah checkpoints seem like the appropriate thing to do there...
21:23:20 <cath_> I checkpointed and it seemed to slow down even more
21:24:02 <dmj`> cath_: checkpointing might take a while, since it has to serialize and write everyting to disk
21:24:23 <dmj`> but it should delete old log files after checkpointing
21:26:08 <cath_> Hm, I have two .log files, one is ~ 2gb, the other (.extsion + 1) is 0 bytes
21:26:50 <cath_> which actually should be the case since there were no inserts before the checkpoint
21:31:46 <dmwit> dmj`: https://ghc.haskell.org/trac/ghc/ticket/12643#ticket
21:33:27 <dmj`> dmwit: wow, thanks.
21:37:32 <dmj`> dmwit: it was fine on 7.10.3 apparently
21:37:44 <dmj`> dmwit: but yea, 8 is problem it seems
21:38:15 <jchia1> I have a type inference question: Is the type inference in GHC known to be non-exhaustive/"not-too-proactive"? I.e. if there is only one possible type inference that works for a program, can GHC still complain about ambiguous type variables and give two potential instances that exist, so that when I add type annotation compatible for one instance, compilation still fails but when I add type annotation compatible with the other instance, compilation works? I h
21:38:59 <jle`> jchia1: hindley-milner is designed to give the most general type possible
21:39:46 <jchia1> jle`: What does that mean? Since GHC gave two possible instance, I'm wondering why it won't try them and see which one makes sense.
21:40:08 <jchia1> because one of them is nonsensical
21:40:21 <jle`> hm, can you show an example?
21:40:45 <jchia1> it's not a trivial project. let me extract the pertinent parts
21:40:53 <Cale> jle`: But that's HM with no extensions -- and even basic Haskell extends HM with things like type classes
21:41:11 <Cale> (which result in potentially ambiguous types)
21:45:02 <geekosaur> also note that context plays no part in instance selection, and that an instance can be added in the future without needing to recompile existing uses meaning they cannot resolve at compile time
21:52:42 <jchia1> Here's code that repros the problem I was talking about: http://lpaste.net/233162
21:53:00 <jchia1> Basically, I'm trying to implement my own quantity types that have unit-aware arithmetic operators.
21:53:29 <jchia1> The ambiguity problem occurs on the last line, and it involves instances of Mult & Add
21:55:26 <jchia1> jle`: ^
22:08:37 <ania123> :t head head :: [a] -> a
22:08:38 <lambdabot> error:
22:08:38 <lambdabot>     • Couldn't match expected type ‘[[a1] -> a1]’
22:08:38 <lambdabot>                   with actual type ‘[a0] -> a0’
22:08:48 <ania123> here 'a' is a type variable
22:08:55 <ania123> what is a type of that variable?
22:09:11 <grantwu> a is any type
22:09:36 <liste> ania123: that's a variable on a type level, so it has a kind, not a type
22:09:38 <Axman6> it could be Int, Bool, String, Either [Text] () or anything else
22:10:04 <liste> on the type level*
22:10:28 <liste> ania123: its kind is *
22:10:41 <liste> @kind Int
22:10:42 <lambdabot> *
22:10:49 <ania123> kind Int?
22:10:51 <liste> @kind Maybe Word
22:10:52 <lambdabot> *
22:10:57 <grantwu> I highly doubt explaining kinds to ania123 is helpful
22:10:59 <ania123> ifword mght be
22:11:01 <liste> ania123: Int has a kind of *
22:11:14 <liste> so `a' can be Int
22:11:17 <ania123> * ? what is this? kleen star?
22:11:25 <grantwu> ania123: Don't worry about kinds
22:11:33 <grantwu> ania123: a is a variable that can stand for any type
22:11:45 <ania123> I undestand that
22:11:59 <grantwu> Does that answer your question?
22:11:59 <ania123> but head takes a list and returns its first element
22:12:01 <ania123> for example 
22:12:05 <grantwu> correct
22:12:11 <ania123> head [1,2,3] returns 1
22:12:13 <grantwu> you have applied head to the function head
22:12:15 <ania123> why
22:12:22 <ania123> 1,2,3 and 1 has same types?
22:12:27 <grantwu> no
22:12:32 <Axman6> :t head
22:12:33 <lambdabot> [a] -> a
22:12:40 <liste> ania123: [a] is a list of a's, a is a single a
22:12:49 <grantwu> [1,2,3] has type [Integer] and 1 has type Integer
22:12:59 <ania123> ah
22:13:00 <ania123> clear
22:13:01 <ania123> thx
22:13:03 <ania123> :)
22:13:19 <ania123> i considered type of list as type of tuple
22:13:20 <ania123> :)
22:30:30 <ania123>  :t uncurry (take 5)
22:30:34 <ania123> > :t uncurry (take 5)
22:30:36 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
22:30:39 <geekosaur> no leading space
22:30:44 <ania123> ?
22:30:50 <ania123> >:t uncurry (take 5)
22:31:03 <Cale> :t uncurry (take 5)
22:31:04 <lambdabot> error:
22:31:05 <lambdabot>     • Couldn't match type ‘[a]’ with ‘b -> c’
22:31:05 <lambdabot>       Expected type: [a] -> b -> c
22:31:07 <geekosaur> your first attempt was " :t uncurry (take 5)"
22:31:22 <geekosaur> with a leading space that caused the bot to ignore it
22:31:24 <ania123> yes, that is clear
22:31:34 <ania123> but, now
22:31:36 <Cale> :t uncurry take
22:31:36 <ania123> >:t uncurry (take 5)
22:31:38 <lambdabot> (Int, [a]) -> [a]
22:31:48 <Cale> No, you can't have the >
22:31:49 <geekosaur> >:t is not a thing
22:31:55 <geekosaur> nor is > :t
22:31:58 <ania123> :t uncurry (take 5)
22:31:59 <lambdabot> error:
22:31:59 <lambdabot>     • Couldn't match type ‘[a]’ with ‘b -> c’
22:31:59 <lambdabot>       Expected type: [a] -> b -> c
22:32:12 <ania123> :t uncurry (take 5)
22:32:14 <lambdabot> error:
22:32:14 <lambdabot>     • Couldn't match type ‘[a]’ with ‘b -> c’
22:32:14 <lambdabot>       Expected type: [a] -> b -> c
22:32:19 <ania123> why it gives error
22:32:20 <ania123> ?
22:32:23 <Cale> Yeah, your expression is a type error
22:32:26 <Cale> :t uncurry
22:32:27 <Axman6> because it doesn't make sense
22:32:27 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:32:31 <Cale> :t take 5
22:32:33 <lambdabot> [a] -> [a]
22:32:43 <Cale> There's no way to make [a] -> [a] line up with a -> b -> c
22:32:55 <ania123> :t  (take 5)
22:32:56 <lambdabot> [a] -> [a]
22:33:07 <geekosaur> :t uncurry . take 5
22:33:08 <lambdabot> error:
22:33:08 <lambdabot>     • Couldn't match type ‘[a1]’ with ‘a -> b -> c’
22:33:08 <lambdabot>       Expected type: [a1] -> a -> b -> c
22:33:09 <ania123> Cale, in unccrried form
22:33:15 <ania123> it should return same type
22:33:16 <ania123> no?
22:33:18 <Cale> huh?
22:33:26 <Cale> :t uncurry
22:33:27 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:33:31 <ania123> for
22:33:35 <ania123> take 5 
22:33:38 <Axman6> take 5 does not have a type which can match a -> b -> c
22:33:42 <ania123> type in curried and uncurried form
22:33:43 <Axman6> it has a type of the form a -> b
22:33:45 <ania123> should be same
22:33:47 <geekosaur> :t curry (take 5)
22:33:49 <lambdabot> error:
22:33:49 <lambdabot>     • Couldn't match type ‘(a, b)’ with ‘[a1]’
22:33:49 <lambdabot>       Expected type: (a, b) -> [a1]
22:33:51 <ania123> syntactically
22:33:51 <geekosaur> whoops
22:33:53 <geekosaur> sigh
22:34:03 <Axman6> :t uncurry take
22:34:05 <lambdabot> (Int, [a]) -> [a]
22:34:09 <Axman6> :t
22:34:16 <Axman6> :t take
22:34:17 <lambdabot> Int -> [a] -> [a]
22:34:49 <Axman6> take accepts two arguments*, uncurry expects a function which takes 2 arguments*. (take 5) only accepts one argument
22:35:02 <Axman6> * all functions only take one argument, I'm sorry dibblego 
22:35:38 <ania123> ok
22:35:48 <dibblego> 'tis ok
22:36:13 <Clint> :t uncurry 5
22:36:15 <lambdabot> Num (a -> b -> c) => (a, b) -> c
22:36:24 <Axman6> Clint: stop that :P
22:36:28 * Clint runs away.
22:48:03 * hackagebot yi 0.13.0.1 - Yi editor  https://hackage.haskell.org/package/yi-0.13.0.1 (DmitryIvanov)
22:48:05 * hackagebot yi-core 0.13.0.1 - Yi editor core library  https://hackage.haskell.org/package/yi-core-0.13.0.1 (DmitryIvanov)
22:48:07 * hackagebot yi-frontend-pango 0.13.0.1 - Pango frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-pango-0.13.0.1 (DmitryIvanov)
22:48:09 * hackagebot yi-frontend-vty 0.13.0.1 - Vty frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-vty-0.13.0.1 (DmitryIvanov)
22:48:11 * hackagebot yi-ireader 0.13.0.1 - Yi editor incremental reader  https://hackage.haskell.org/package/yi-ireader-0.13.0.1 (DmitryIvanov)
22:53:13 * hackagebot yi-keymap-cua 0.13.0.1 - Cua keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-cua-0.13.0.1 (DmitryIvanov)
22:53:15 * hackagebot yi-keymap-emacs 0.13.0.1 - Emacs keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-emacs-0.13.0.1 (DmitryIvanov)
22:53:17 * hackagebot yi-keymap-vim 0.13.0.1 - Vim keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-vim-0.13.0.1 (DmitryIvanov)
22:53:19 * hackagebot yi-language 0.13.0.1 - Collection of language-related Yi libraries.  https://hackage.haskell.org/package/yi-language-0.13.0.1 (DmitryIvanov)
22:53:21 * hackagebot yi-misc-modes 0.13.0.1 - Yi editor miscellaneous modes  https://hackage.haskell.org/package/yi-misc-modes-0.13.0.1 (DmitryIvanov)
22:58:23 * hackagebot yi-mode-haskell 0.13.0.1 - Yi editor haskell mode  https://hackage.haskell.org/package/yi-mode-haskell-0.13.0.1 (DmitryIvanov)
22:58:25 * hackagebot yi-mode-javascript 0.13.0.1 - Yi editor javascript mode  https://hackage.haskell.org/package/yi-mode-javascript-0.13.0.1 (DmitryIvanov)
23:00:26 <Lokathor> http://lpaste.net/233184 is this a "sane" way to format a case statement?
23:04:47 <Axman6> you probably want MultiWayIf
23:04:52 <MarcelineVQ> case k == R.key_resize of ?
23:07:23 <Axman6> also, what you've written is just an if statement: if i == R.key_size then ... else ...
23:07:34 <Axman6> (resize*)
23:11:43 <Lokathor> well, yes, but later I'll need more cases
23:12:18 <Lokathor> and each othe case will also be testing against a constant defined in a foreign module, so i can't just write the constants in myself
23:49:48 <saurabhnanda> snap poll: how would you react to collaborating on https://github.com/vacationlabs/haskell-webapps/issues on a "bounty" model. Fix a PR and get paid a small bounty? What would be a reasonable amount for the bounty?
23:49:56 <saurabhnanda> snap poll: how would you react to collaborating on https://github.com/vacationlabs/haskell-webapps/issues on a "bounty" model. Fix a PR and get paid a small bounty? What would be a reasonable amount for the bounty?
23:50:17 <Axman6> you know you can already do that right?
23:50:55 <Axman6> https://www.bountysource.com
23:52:38 <kqr> Lokathor, http://lpaste.net/3805807461999312896
23:52:38 <saurabhnanda> Axman6: no I didn't. Thank you :)
23:52:46 <kqr> Lokathor, that's how I'd write it if I didn't want to enable -XMultiWayIf
23:53:15 <Lokathor> hmmmm
23:53:32 <Lokathor> well the whole file ended up like this for now https://github.com/Lokathor/fullainth/blob/master/src/Main.hs
23:54:20 <saurabhnanda> Axman6: is there any way of figuring out whether it really works? How many bounties have been claimed through that site?
23:55:05 <Axman6> no idea, but I know a few have been added to TerriaJS, which my project is based on and people have claimed the rewards
23:57:03 <saurabhnanda> any other alternative to bountysource?
