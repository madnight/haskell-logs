00:00:10 <allenj12> still thinking of something I can do tho :D
00:00:26 <jle`> one thing you can do is just to switch all of your daily programming to haskell :3
00:00:29 <jle`> worked for me haha
00:01:06 <allenj12> jle`: thats the plan for me too, I usually go for the sink or swim method of learning :P
00:01:45 <jle`> the nice thing about haskell is that it's a joy to refactor old code
00:02:05 <jle`> so if you do it that way, when you are more experienced, you have a bread crumb trail of fun projects to refactor in your spare time haha
00:02:43 <allenj12> haha :D
00:03:19 <ongy> or a trail of shame and sorrow
00:03:21 <jle`> i never thought i'd find refactoring old projects fun before i found haskell :3
00:03:32 <jle`> that's one of the reasons why i probably can't leave haskell heh
00:04:16 <NickHu> Just wait until all of your programs start with 10 language pragmas :DDDD
00:04:18 <jle`> the thought of refactoring my old ruby/python/java projects makes me feel sick v.v
00:04:34 <allenj12> one thing that always gets me in haskell is order of operations, i.e listDirectory = liftM (filter notDots) . getDirectoryContents, If you didnt know what liftM was it would be hard to tell if you compose the functions first or use liftM first. Its just something I have to get use to
00:04:47 <ongy> refactoring something that doesn't have static typing is the wors imo
00:04:48 <jle`> it's something you get used to fast actually :o
00:05:06 <jle`> because function application always binds tightest
00:05:08 <jle`> without exception
00:05:11 <jle`> except for that one exception
00:05:18 <jle`> but, it's tighter than any operator :)
00:05:19 <allenj12> haha :P
00:05:31 <jle`> it's always tighter than any operator, so you don't have to think too much
00:05:38 <cocreature> jle`: which exception?
00:05:54 <Axman6> edwardk: Hey, you mentioned the other day regarding my foldl-statistics package that you preferred monoidal things to folds so you can do nice paralle things. I added some support for that in the lastest version: https://hackage.haskell.org/package/foldl-statistics-0.1.4.0/docs/Control-Foldl-Statistics.html#v:fastLMVSK (see also LMVSKState)
00:05:54 <jle`> record syntax
00:06:03 <allenj12> gotcha D
00:06:08 <cocreature> oh yeah that always annoys me
00:06:15 <jle`> foo x { y = z } k
00:06:20 <jle`> is foo (x { y = z }) k
00:06:24 <jle`> so that's the one weird thing
00:06:47 <jle`> i usually put parentheses around it when i use record syntax, because i'm so used to function application binding tightest
00:06:57 <cocreature> yeah I do too
00:07:05 <ongy> I never got the idea to do it without
00:07:10 <jle`> relying on the precedence and omitting parentheses there should be considered bad practice >_>
00:07:17 <jle`> let me file a motion
00:08:50 <edwardk> Axman6: nice =)
00:09:04 <jle`> i've officially filed a motion to the comittee of haskell bad practices
00:11:39 <edwardk> Axman6: i think https://github.com/analytics/analytics/blob/alternative-syntax/src/Data/Analytics/Numeric/Moments.hs was somewhere around the last time i kept this stuff in analytics
00:12:56 <edwardk> jle`: i pretty much take the opposite stance and like minimalist syntax and no random prophylactic parenthesis. i find it a lot easier. opinions vary obviously
00:13:49 <Axman6> edwardk: looks like that's entending the linear regression stuff I've got to work over more than two series? that's pretty cool
00:13:50 <edwardk> the record notation we have is weird because it violates the ' ' binds tighter than everything guideline.. just like @.
00:14:02 <dibblego> we had a recent gotcha with mod and div given different precedence. I agree that the mistake is on the reader, not the code (absent parens)
00:14:23 <edwardk> Axman6: i forget. i wrote it years ago, wired it up to compensated then promptly forgot about it. =)
00:14:29 <jle`> i guess my stance is 'redundant parentheses only when they help readability', but then you have to think about to what degree you want to commit to re-training what you think is readable
00:14:36 <Axman6> ha =)
00:14:55 <Axman6> looks very similar :)
00:15:15 <jle`> there are extremes either way
00:15:37 <Axman6> I got bitten by parens the other day in some code (thanks dibblego!)
00:15:46 <dibblego> Axman6: I was referring to that incident :)
00:16:04 <edwardk> i'm pretty parenthesis phobic. i think i may have been attacked by a lisper in a former life.
00:16:18 <jle`> but if lack of parentheses can cause bugs due to misinterpreted code, then aren't we the same as those apple people who forgot to use braces after an indented if block?
00:16:20 <jle`> in C ?
00:16:39 <Axman6> I'm still anoyed about that. I should've gone back to BODMAS though and realised x - 1 `div` y does dumb things
00:16:40 <dibblego> I'm redundant-syntax phobic
00:16:51 <edwardk> i'm the same way in c/c++. though i do include "redundant" parens in macro expansions where they aren't redundant in practice.
00:16:52 <bollu1> in a free language, if I end a Free DSL () with Done, it cannot be composed anynore, right?
00:16:54 <bollu1> anymore*
00:17:00 <bolly> ni
00:17:02 <dibblego> in a not-stringly-typed language...
00:17:03 <Axman6> I'd even considered writing succ x `div` y -_-
00:17:26 <edwardk> re `div` and `mod`, i tend to write those prefix anyways =)
00:17:34 <bollu> in a Free DSL, if I end a sequence of free instructions with Done
00:17:38 <Axman6> yeah that's what I ended up doing
00:17:39 <edwardk> yes, i realize that gives me parens
00:17:41 <bollu> you can't compose it anymore, right?
00:17:52 <bollu> since the interpreter stops at the Done>
00:17:53 <bollu> ?
00:17:58 <Axman6> div (x - 1) y was much more readable
00:17:59 <jle`> there was that high profile bug where a team added another line to a one-line if statement and forgot to add braces, but because of the indentation, they thought that both statements were a part of the if block
00:18:12 <edwardk> jle`: the openssh one?
00:18:26 <Axman6> bollu: that would depend on what say >>= does
00:18:31 <jle`> something like that
00:18:34 <edwardk> er openssl
00:18:40 <jle`> yeah, i think it was an ssl bug
00:18:44 <Axman6> usually you'd have some Done a >>= f = f a in there somewhere
00:18:53 <jle`> i feel like i should be defensive against potential errors like that
00:19:05 <Axman6> that was Apple's goto fail; bug no?
00:19:06 <edwardk> https://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/
00:19:18 <edwardk> Axman6: yeah
00:19:29 <Axman6> which isn't actually openssl is it? didn't they have their own?
00:19:30 <jle`> there is a degree to which you can trust the reader to be able to interpret your code
00:19:38 <ongy> wasn't that deletion/refactor? I don't think that was added (more *not* removed)
00:19:52 <Axman6> I was surprised to see how quickly Apple canned OpenSSL for LibreSSL, they're not usually that proactive
00:20:08 <jle`> but div/mod mixing is potentially a case where i'd be defensive against a misinterpreting reader
00:20:30 <edwardk> Axman6: apple is pretty proactive any time they can endorse their own lock-in distinctive way to do things and claim that it might somehow let them be a 2% more secure or more special or whatever
00:21:01 <edwardk> witness: metal vs. vulkan, that opengl support is locked at 4.1 and will never be improved, their gcc extensions and subsequent move to clang...
00:21:10 <Axman6> I'd just forgotten that would could assign fixities to binary non-operator functions
00:21:32 <edwardk> jle`: sure, hence just accepting and moving them to prefix =)
00:21:36 <Axman6> their move to Clang has been a really good thing IMO
00:21:38 <bollu> Axman6: doesn't (>>=) in free insert into the Pure nodes?
00:21:44 <edwardk> Axman6: i largely agree there
00:21:44 <Axman6> metal was pre vulcan right?
00:22:11 <edwardk> Axman6: there were some noises about vulkan support and then it all shriveled up
00:22:16 <bollu> Axman6: but when we lift the end structure into the Free level, we just say end ::Free DSL (), end = Free End ?
00:22:35 <jle`> bollu: what's the definition of Done ?
00:22:39 <jle`> er, of DSL ?
00:22:45 <Axman6> bollu: yeah you're hitting my limits of Free knowledge
00:23:05 <edwardk> but i can think of dozens of examples given time. apple threadlocal support vs. c++ standard threadlocal, because they didn't want to deal with complex initializers
00:23:07 <jle`> if DSL is a nullary constructor with no arguments, then yeah, >>=-ing to it is a no-op
00:23:15 <Axman6> edwardk: yeah Apple's graphics stack is pretty bizarre, I'll give you that
00:23:18 <edwardk> so rather than just sucking it up and doing what everyone else does they just say nah.
00:23:56 <lpaste> bollu pasted “free DSL” at http://lpaste.net/228930
00:24:08 <bollu> jle`: http://lpaste.net/228930
00:24:10 <edwardk> bollu: If I hand you an empty list, nothing you do with >>= will 'put data in it'
00:24:13 <bollu> jle`: makes sense?
00:24:16 <edwardk> bollu: your "Done" is morally the same
00:24:18 <Axman6> yeah I remember TLS causing plenty of issues in GHC on OS X, and generally just slowing it down because they couldn't pin registers to the TLS pointer (or something like that)
00:24:22 <bollu> edwardk: ah, right. 
00:24:45 <edwardk> if I hand you a singleton list, then >>= will expand completely
00:24:54 <bollu> edwardk: in my intuition, the way >>= on Free works is it accesses Pure and then "expands" them according to the f value, right?
00:25:02 <edwardk> yep
00:25:10 <bollu> edwardk: right, and since in a free language, the next is a Pure (), the >>= will wind up expanding it?
00:25:38 <jle`> bollu: >>= for Free works by "fmapping" over the value, so fmap _ End = End, >>=-ing onto End will do nothing
00:25:43 <bollu> edwardk: so, now, a Free language snippet that does not end with a End is illegal, right? since it doesn't "end correctly". It's only a snippet, not the entire program?
00:25:47 <jle`> s/so/and
00:25:49 <bollu> jle`: hmm
00:26:06 <bollu> jle`: right, I suppose thinking of >>= as a monoid helps here
00:26:07 <edwardk> i'd basically view your edsl of 'get/set/end' as a monad that has get and set operations and a sort of 'error state' indicated by End
00:26:09 <ocramz> good morning all
00:26:26 <edwardk> Pure a    is different than Free End
00:26:28 <bollu> edwardk: since the End does not compose with anything else? like, the interpreter stops there?
00:26:42 <edwardk> the former acts like [a] the latter acts like []   when it comes to >>=
00:26:44 <bollu> edwardk: because Pure a can still be "expanded out" right?
00:26:55 <edwardk> Free End >>= f = Free End
00:26:58 <edwardk> Pure a >>= f = f a
00:27:14 <bollu> edwardk: Pure a >>= f = Pure (f a) ?
00:27:22 <edwardk> no
00:27:24 <edwardk> just 'f a'
00:27:30 <bollu> wait, what?
00:27:35 <jle`> bollu: think about the type of f
00:27:40 <edwardk> return a >>= f = f a
00:27:41 <edwardk> is a law
00:27:43 <edwardk> return = Pure
00:27:49 <bollu> ohh right
00:27:51 <bollu> hmm
00:27:51 <jle`> bollu: f is (a -> Free f b)
00:27:59 <jle`> so 'f x' is Free f b
00:28:08 <bollu> right, nice!
00:28:23 <jle`> you might be thinking of fmap
00:28:28 <jle`> fmap f (Pure x) = Pure (f x)
00:28:33 <bollu> jle`: yes, I was thinking of fmap
00:29:12 <bollu> edwardk, jle`so, what is the equivalent of, say, "return 0" (that is, stop gracefully and do nothing more" ? that's End, right?
00:29:33 <bollu> End == don't allow any more actions to be interpreted. Pure () == allow more actions to be appended
00:29:34 <edwardk> bollu: 
00:29:35 <edwardk> no
00:29:49 <edwardk> 'Free End' is more like 'fail "ARRRRGHHH" than return ()
00:29:53 <bollu> hmm
00:29:57 <jle`> do you mean 'return 0' in a language like C ?
00:30:03 <bollu> jle`: yes :) 
00:30:10 <bollu> jle`: probably a bad analogy
00:30:11 <edwardk> fail "ARRGHH" >>= f = fail "ARRGHH"
00:30:32 <bollu> edwardk: so, how do I represent "graceful success" ?
00:30:34 <jle`> in that case, yeah, it can be used as a way to close off any more effects
00:30:35 <edwardk> return () >>= f = f ()
00:30:40 <edwardk> bollu: 'return ()' =)
00:30:51 <jle`> hm
00:30:51 <edwardk> i mean it _IS_ a monad, right? =)
00:30:52 <bollu> edwardk: :) but that lets me "append more"
00:30:55 <edwardk> yes
00:30:59 <bollu> edwardk: I don't want to allow you to "append more"
00:31:07 <bollu> edwardk: but not "fail" :P
00:31:16 <bollu> edwardk: I suppose it's a question of the way you think of failure?
00:31:19 <edwardk> what role does End play?
00:31:44 <edwardk> i mean yes you can now have an instruction stream that may or may not end in End.
00:31:44 <bollu> edwardk: End lets you "plug up" the end of a Free DSL snippet, which doesn't allow you to >>= or >> any more actions
00:31:57 <jle`> i suppose you could have gracefulEnd :: Free DSL Void; gracefulEnd = Free End
00:32:05 <edwardk> that is a perfectly legitimate free monad, but you still have to deal with 'unfinished' streams or something if you add it
00:32:05 <jle`> hm
00:32:19 <edwardk> and it doesn't stop someone from calling >>= on the 'capped off' result
00:32:20 <bollu> I see
00:32:28 <jle`> bollu: hm, if you want to only be able to "run" something that has been capped off
00:32:33 <edwardk> they can >>= they just get no effect
00:32:35 <jle`> you can make your run function take a (forall a. Free DSL a)
00:32:41 <edwardk> if that is what you want to represent that is fine
00:32:46 <edwardk> i mean i do the same thing inside machines
00:32:52 <bollu> jle`: how will that work?
00:32:58 <edwardk> there is both a Done  and a Return a  constructor in the plan machinery for instance
00:33:01 <jle`> the only non-bottom member of (forall a. Free DSL a) is one where the final >>='d thing is End
00:33:06 <jle`> there just ain't another
00:33:14 <bollu> jle`: ah, I see.
00:33:19 <bollu> jle`: that's slick :)
00:33:24 <jle`> except for potentially infinite ones i guess, like forever x ?
00:33:46 <bollu> edwardk: I've read that interpreting a Free DSL is like quotienting. How correct is this notion?
00:33:54 <edwardk> but yeah Free DSL Void is probably how i'd go. as you can't instantiate it without nasty things without using something like End
00:33:57 <bollu> edwardk: and can we make this notion of quotienting precise? (like a group quotient)
00:33:59 <edwardk> bollu: well, let's take your EDSL
00:34:04 <bollu> edwardk: sure
00:34:08 <edwardk> you have no law relating Get and Set operations from Free.
00:34:14 <bollu> edwardk: what's the "E" in EDSL?
00:34:14 <edwardk> unlike, say, state.
00:34:19 <edwardk> embedded
00:34:25 <bollu> edwardk: ah. okay :
00:34:29 <bollu> edwardk: right, okay, go on
00:34:33 <Axman6> edwardk: on https://github.com/analytics/analytics/blob/alternative-syntax/src/Data/Analytics/Numeric/Moments.hs#L56 is the reason for unpacking the V.Vector because it can always be unpacked, but the U.Vectors can't be unpacked because their representation depends on a?
00:34:36 <jle`> yeah i guess any issues with Free DSL Void is also an issue with (forall a. Free DSL a), so might as well
00:34:42 <edwardk> though sadly some people use 'e' for external dsl, which makes the whole fricking thing really confusing
00:35:12 <edwardk> Axman6: yeah
00:35:29 <bollu> edwardk: okay, so we have the EDSL
00:35:32 <Axman6> a system a colleague of mine build uses s and e for start and end, but my beain couldn't get away from them being stop and enable
00:35:35 <edwardk> anyways, Get and Set have no laws relating them
00:35:56 <edwardk> so a perfectly legitimate 'interpreter' for Free DSL could just always give you the same value or bump a counter every time you get it
00:35:57 <bollu> edwardk: right, okay
00:36:03 <edwardk> or do something not-very-state-like
00:36:12 <edwardk> the laws don't contain enough of your semantics
00:36:20 <edwardk> the dsl probably isn't really free.
00:36:28 <bollu> edwardk: right, because we separate the language from the interpreter, the interpreter can "do whatever"
00:36:44 <edwardk> well, i usually try to use free dsls when the thing i want really is free =)
00:37:06 <bollu> edwardk: okay, so in this case? :) 
00:38:08 <edwardk> here i'd likely use 'MonadState' and build an instance for a little custom monad if i needed the io thing.
00:38:50 <edwardk> because then MonadState has some laws relating getting and setting operations
00:38:57 <bollu> I'l have to check what MonadState does
00:39:14 <bollu> edwardk: and what about the whole quotient stuff?
00:39:26 <bollu> edwardk: where can you see the notion of a quotient of a Free DSL?
00:40:47 <edwardk> bollu: you'd be more likely to find folks talking about 'quotients of sets', where instead of comparing things on equality you're viewing them as equivalent up to some other equivalence relation.
00:41:32 <bollu> edwardk: right, I was looking for some sort of first isomorphism law for Free DSL quotients :) (from group / ring theory)
00:41:34 <edwardk> e.g. if you break integers up into even and odd, you can show that (+) respects that quotienting. e.g. even + even = even, odd + odd = even, _ + _ = odd
00:41:43 <nshepperd1> Is there a sort of Free for indexed monads? Because you could implement a End that can only be included once with some kind of indexed i think
00:42:19 <bollu> edwardk: like, I wanted to port a lot of my free group intuition to free dsl's
00:42:33 <edwardk> these things are going to be pretty boring, as they are 'monoid'-like not 'group'-like (its a monoid in a different category actually), so there is a lot less structure to play with
00:42:37 <bollu> edwardk: can we concretely draw such an analogy? (interpretation of a free dsl is quotienting)
00:42:50 <edwardk> well, sort of.
00:42:57 <edwardk> let's think about what a monad homomorphism is
00:42:58 * hackagebot yesod-bin 1.4.18.5 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18.5 (MichaelSnoyman)
00:43:00 * hackagebot pid1 0.1.0.0 - Do signal handling and orphan reaping for Unix PID1 init processes  https://hackage.haskell.org/package/pid1-0.1.0.0 (MichaelSnoyman)
00:43:54 <edwardk> a monad homomorphism is a natural transformation that preserves the monad laws. f (fmap g a) = fmap g (f a);   f (return a) = return a;    f (m >>= k) = f m >>= f . k
00:43:55 <edwardk> right?
00:44:50 <bollu> edwardk: right, I suppose I can see that
00:45:02 <edwardk> `Free f` is a monad such that every natural transformation from f to m, where m is a monad is in 1-1 correspondence with monad homomorphisms from Free f to m.
00:45:41 <edwardk> that _every_ monad homomorphism from Free f to m can be derived in this way and that every natural transformation from `f` to the functor you get if you forget that `m` is a monad is what matters here.
00:46:11 <bollu> edwardk: I'm a little lost, but go on :) I'll ask questions once I hear the entire explanations?
00:46:23 <edwardk> `Free f` is 'the simplest thing includes the structure of `f` and happens to pass the monad laws.
00:47:01 <bollu> edwardk: sure :) okay, yeah
00:47:16 <edwardk> you can remove anything from it and still pass the laws. you can't add anything without saying more than is required to do those things
00:47:25 <edwardk> so far so good?
00:47:57 <bollu> edwardk: yes, gotcha
00:48:29 <edwardk> so we can take a monad homomorphism and ask if it is injective or surjective just like a function. epic or monic if you've seen those bits of vocabulary, since you brought up groups =)
00:49:16 <bollu> edwardk: hmm, sure. With you so far :)
00:49:55 <edwardk> and this notion that 'interpreting a free dsl' is like quotienting is just saying that you want to allow multiple input DSL programs to get mapped onto the same interpretation.   e.g. that maybe in your interpreter it shouldn't matter if you get 3 times in a row. the state monad laws aren't 'free'
00:50:00 <edwardk> the [] monad laws aren't free.
00:50:05 <bollu> edwardk: so you'll think of quotients in terms of G -f-> H => G/(ker f) ~= H?
00:50:29 <edwardk> because they say something about how get/put relate in the former case and that you can't observe the associativity of things in the latter.
00:51:12 <bollu> edwardk: can we write every monad m as an interpretation of some Free f?
00:51:18 <edwardk> groups have a _ton_ of structure because they have inverses. monoids don't.
00:51:21 <bollu> edwardk: some type of cayley's theorem?
00:51:26 <edwardk> no
00:51:28 <bollu> edwardk: right, yeah.
00:51:29 <edwardk> free isn't initial
00:51:34 <bollu> edwardk: ah
00:51:40 <bollu> edwardk: so is there an "initial monad"?
00:51:44 <edwardk> sure
00:51:48 <edwardk> Identity
00:51:49 <bollu> edwardk: something like Sn for monads?
00:51:51 <bollu> edwardk: :/
00:51:54 <edwardk> Proxy is the terminal monad
00:51:56 <bollu> edwardk: but that has 0 structure
00:52:03 <bollu> edwardk: like, I wanted something like the symmetric group
00:52:08 <edwardk> yes, so does the initial group =)
00:52:24 <bollu> edwardk: :P damn
00:52:30 <edwardk> () is initial in set
00:52:34 <edwardk> Void is terminal there
00:52:34 <bollu> edwardk: right
00:52:42 <bollu> edwardk: Z in intitial in Ring, right?
00:53:01 <edwardk> yes, there is a unique ring homomorphism from Z to every Ring.
00:53:18 <bollu> edwardk: okay, one more question. I "know" that you have the cofree comonad stuff that gives you interpreters for a Free monad
00:53:30 <bollu> edwardk: so, given a cofree comonad, can you reconstruct the language it accepts?
00:53:43 <bollu> edwardk: given the interpreter, can you explicitly reconstruct the language?
00:54:53 <edwardk> so the question here comes down to whether you want this in hask or another category. ultimately there is the idea that you can substitute in sums for products and products for sums, pairs with concrete values vs. functions from values so that whenever one needs to make a decision you have a value to deal with it.
00:55:00 <edwardk> but it doesn't work in general
00:55:11 <edwardk> i wrote some article a few years back on 'zapping adjunctions'
00:55:36 <edwardk> and some random australians have lately been giving talks on pairing functors =)
00:55:42 <edwardk> but in general such pairings aren't unique
00:55:44 <bollu> edwardk: uhh, let's say Hask?
00:56:01 <edwardk> f -| g -| h   both f and h 'cancel' with g.
00:56:51 <edwardk> so the 'pairing functor' for a functor isn't uniquely determined
00:57:02 <bollu> edwardk: that's the adjunction syntax you're using?
00:57:58 <edwardk> now in hask you can say, aha! there is only one adjunction from Hask -> Hask, which is the (,) e -| (->) e   adjunction... and you'd be right, but adjoints aren't the only source of pairings, so its all a mess. =P
00:58:12 <bollu> hmm
00:58:14 <edwardk> this is why i packaged up pairings as a data type rather than instances back when i bothered to support them
00:58:19 <bollu> what are the other ways to have pairings?
00:59:39 <edwardk> well you might have data Pair a = Pair a a    and  data Foo a = L a | R a   -- which pair. one is a product cancelling with a sum. but then you can algebraically contort that to see it as Bool -> a    and (Bool, a) respectively, turning it back into a (,) e -| (->) e situation
01:05:51 <ocramz> q: I'd like to transpose nested IntMap's, but apparently IntMap doesn't have an Applicative instance so sequenceA doesn't apply. Is there another general way of doing this?
01:06:39 <lyxia> what would that do
01:06:57 <edwardk> amusingly you can have an Apply instance, as IntMap is 'semiapplicative' but that doesn't lead to transposition in a nice way
01:07:25 <edwardk> you can transpose using linear, iirc
01:07:59 <ocramz> linear uses sequenceA for dense arrays IIUC
01:08:00 <edwardk> oh, the linear transpose isn't super general
01:08:02 <edwardk> its just distribute
01:08:05 <edwardk> https://github.com/ekmett/linear/blob/master/src/Linear/Matrix.hs#L381
01:08:18 <lyxia> [(1, [(2, 12), (3, 13)]), (4, [(5, 45), (6,46)])] -> [(2, [(1, 12)]), (3, [(1, 13)]), ...] ?
01:08:27 <ocramz> lyxia: precisely
01:09:23 <edwardk> what gets in the way of foldMapping your way to glory?
01:09:39 <edwardk> other than the monoid for map?
01:10:07 <ocramz> foldMapping my way to glory :D yes, I guess I'll do that :) thanks
01:10:13 <lyxia> My example wasn't the best because inner maps don't share any key but I think I got the idea.
01:10:25 <edwardk> ifoldMap with lens 'll get you the keys
01:11:26 <edwardk> you can of course choose to not use lens =)
01:11:52 <ocramz> lyxia : when inner maps are sparse one should fold over the intersection of the index sets
01:13:21 <ocramz> edwardk : I haven't imported lens in this project yet; I'll try rolling my own ifoldMap and see what happens
01:13:27 <lyxia> shouldn't it be the union
01:13:42 <lyxia> if it were the intersection my example would result in the empty map
01:13:45 <ocramz> lyxia: yes indeed sorry, intersection would lose information
01:14:14 <lyxia> I don't have a better idea than ifoldMap :)
01:14:31 <ocramz> so I'll run with that. Thanks lyxia and edwardk
01:14:43 <edwardk> note with ifoldMap you'd want to use a custom monoid, as the default mappend isn't unionWith
01:15:08 <edwardk> you can also do the whole thing as a left fold or whatever since the tree flattens and you don't get any sharing anyways
01:16:26 <ocramz> custom monoid using unionWith, noted
01:16:47 <edwardk> which of course makes things fairly absurd because you can just sort of do the naive translation to/from lists without losing anything asymptotically.
01:20:14 <edwardk> something like foldl f IntMap.empty [ (k2, (k1, z) | (k1,ys) <- toList xs, (k2,z) <- toList ys ] -- for a suitable 'f' would do it all in one go.
01:20:56 <edwardk> using discrimination it could even be linear time =P
01:38:25 <ocramz> edwardl : what do you mean by `discrimination` in the context of the example above?
01:38:31 <ocramz> ^ edwardk
01:41:26 <jle`> probably referring to his O(1) sorting library
01:41:58 <quchen> Is LEM equivalent to “cancelling not”, or is one more special than the other? Formally, (¬¬A ⇒ A) ⇔ (A ∨ ¬A)?
01:43:27 <quchen> What’s the ¬¬ law called anyway?
01:44:14 <Rarrikins> Law of the excluded middle, negation elimination or something like that
01:44:28 <ocramz> jle` : found it, thanks
01:44:42 <Rarrikins> Double negation elimination
01:45:01 <ocramz> jle` : very cool work on tensor-ops as well, btw
01:45:47 <jle`> oh, thanks! i'm pretty sure someone has already done something similar, but it was mostly the result of being on a two week vacation and thinking about how you could do type-safe AD at the tensor level heh
01:46:14 <jle`> hopefully i can implement decently fast backends
01:46:16 <quchen> Rarrikins: Thanks! That brings up quite a few results. “DNE” seems like an established abbreviation
01:47:12 <jle`> type-safe reverse-mode AD. one of those projects where many notebook pages were filled before any code was written.  like all of my favorite haskell projects :)
01:47:12 <ocramz> jle` what do you use as a backend currently? and what's the dimensionality of the examples? you use a number of type-level trickery I'm still not able to parse completely
01:48:06 <jle`> yeah the API is not very optimized at the user-level
01:48:13 <jle`> but the backend i used with the demo was just nested []'s
01:48:22 <jle`> kind of the dumbest backend
01:48:49 <ocramz> I see
01:48:53 <ocramz> repa could be of use here
01:48:54 <jle`> so a rank 4 tensor would be [[[[Double]]]] essentially
01:49:25 <jle`> yeah, the system/ad is written to be backend-independent, so this one was just drawn up as a proof of concept
01:49:58 <ocramz> jle` I've already advertised tensor-ops on the DataHaskell slack
01:50:01 <jle`> i kind of see what would be possible with, say, accelerate
01:50:39 <jle`> haha in that case um i should probably add a disclaimer that the user-level API is more or less non-existent
01:50:56 <ocramz> have to start from somewhere
01:51:14 <jle`> indeed :)
01:51:59 <ocramz> there's a good mix of theory and application in that group, so chances are someone will pick it up and just start tinkering with it
01:54:12 <jle`> haha it'll be interesting to see where it can go :) the main reason i wrote it was becuase i got tired of implementing backprop for every single different type of neural network i made heh.  i saw that tensorflow does ad automatically and i thought why not haskell
01:55:14 <jle`> ocramz: btw, what happened to OrganizationTasks ?
01:55:33 <jle`> w/ DataHaskell ?
02:03:46 <ocramz> jle` : it moved to a Trello board
02:04:18 <jle`> ah i see
02:04:34 <ocramz> if you jump onto the #development-team channel @nickseagull will give you access to that
02:05:23 <jle`> oh, i think i found it :)
02:06:45 <jle`> ocramz: is that a channel on freenode?
02:08:53 <ph88^> is it true that i can use Traversable to change all strings in a data structure? I read the chapter on traversable but there is nothing about this. For example i have such structure and i want to uppercase all String  https://paste.fedoraproject.org/436971/47505366/
02:09:01 <Saizan> anyone using intero? how do i make it pass -fobject-code to ghci?
02:09:39 <ocramz> jle` no it's still a slack channel
02:09:54 <jle`> oh, which slack?
02:10:00 <ocramz> DataHaskell one
02:10:33 <tdammers> ph88^: depending on the data structure, Functor should be enough
02:10:38 <jle`> ph88^: you can use Functor/fmap on a parameterized type to map all "occurrences", but yeah, that only works on parameterized types
02:10:47 <jle`> not like the ones you have there
02:12:04 <tdammers> ph88^: you're probably looking for something like MonoTraversable
02:12:22 <tdammers> or rather, MonoFunctor
02:12:27 <fp_preist> ph88^: Or you can just use Clojure.
02:12:32 <fp_preist> ph88^: Kidding ;)
02:13:28 <tdammers> fp_preist: you could also use the Clojure approach in Haskell, using Dynamic or Data.Aeson.Value for all your data structures
02:13:40 <tdammers> yh
02:14:54 <tdammers> ph88^: in this particular case, you could make both Foo and Bar instances of MonoFunctor, with String as the element type
02:15:54 <tdammers> ph88^: another approach that uses MultiParamTypeClasses instead of TypeFamilies is what Pandoc uses in its Walkable class, here: http://hackage.haskell.org/package/pandoc-types-1.16.1.1/docs/Text-Pandoc-Walk.html
02:16:08 <tdammers> ph88^: I don't know of a generalized standalone package that provides this though
02:16:48 <ph88^> why do i even need packages for this problem ?
02:17:03 <tdammers> ph88^: because it's not in base
02:17:06 <tdammers> vOv
02:17:40 <ph88^> can i derive something automatically ?
02:17:41 <jle`> in *this* case i  would probably recommend just writing a function to map over the string.  there is no "built-in" way, no.
02:17:45 <tdammers> ph88^: and you don't necessarily need packages, writing the Walkable typeclass and instances for your types isn't hard
02:18:16 <tdammers> ph88^: if you want something you can derive automatically, you could try generalizing your types from String to a polymorphic type
02:18:25 <tdammers> ph88^: and then derive functor
02:19:07 <tdammers> ph88^: the downside there is that you can only pick one of the types, so you can't have another Functor instance to modify the integers
02:19:35 <ph88^> that's certainly not an option then !
02:20:37 <ph88^> data structures transformation is easy in php don't need library for it -___-
02:20:39 <tdammers> ph88^: anyway, there are lots of reasons why this isn't in base; the most pressing one is because it's impossible to tell whether all the parts of your data structure that happen to be of a particular type are supposed to be touched by a walk function, and if not, which ones
02:21:03 <tdammers> transforming data structures is ridiculously difficult in PHP
02:22:12 <tdammers> quick, tell, me, what is the correct way to get the first element from an "array" in PHP - such that it works on all flavors of arrays, returns NULL for empty arrays, and doesn't have any side effects?
02:22:39 <tdammers> (hint: [0] is wrong, reset() is wrong, foreach is wrong)
02:23:39 <ph88^> why return NULL, reset() returns FALSE
02:23:57 <tdammers> what if the first element in the array is FALSE?
02:24:19 <tdammers> but, OK, let's roll with FALSE
02:24:22 <ph88^> same problem you have with null
02:24:24 <tdammers> reset() is still wrong
02:24:33 <tdammers> because it has a side effect
02:24:56 <tdammers> you see, PHP arrays maintain an internal iteration position, and reset(), well, resets it
02:25:10 <ph88^> you still get the first element
02:25:14 <ph88^> which is what you want
02:25:17 <tdammers> yes, but you also modify the array
02:25:23 <tdammers> which is what you *don't* want
02:25:30 <ph88^> no you only modify the internal pointer which is ok
02:25:34 <tdammers> no, it's not
02:25:38 <tdammers> it's a side effect
02:25:45 <Myrl-saki> so. like. i understand monads now(well, like a year ago already, actually). But how was it thought of? I mean, I can get the specific use cases, but how did they think, "oh wait, lists and IO has a common pattern?"
02:25:45 <ph88^> that's ok
02:26:07 <tdammers> no, it's not. I've been bitten by this way too often
02:26:09 <ph88^> normally in php you don't really need this pointer as you use foreach al the time
02:26:32 <tdammers> but you can't be sure
02:26:43 <tdammers> and you can't tell
02:26:54 <ph88^> you can be sure if you look at the code ^^
02:27:07 <tdammers> looking at all the code is not a realistic option
02:27:30 <tdammers> "Want to get the first element from a list? better review the entire codebase. Every time."
02:27:36 <tdammers> *that* is the problem, really
02:27:52 <tdammers> and that is how Haskell makes me extremely productive
02:28:05 <ph88^> ok but this is another problem
02:28:17 <ph88^> my problem is just how to traverse data structures, and in php i can do this without extra library
02:28:45 <tdammers> you can do it, but not without introducing unnecessary problems
02:28:59 <tdammers> you have to sacrifice at least one of maintainability, correctness, or performance
02:29:30 <kqr> Myrl-saki, mathematicians are crazy i tells ya!
02:29:38 <Myrl-saki> kglo
02:29:45 <tdammers> i.e., you can use [0], sacrificing correctness, or you can use reset() or foreach, sacrificing maintainability, or you can use array_values($a)[0], sacrificing performance
02:29:45 <Myrl-saki> kqr: lol
02:30:23 <tdammers> in Haskell, you don't have to sacrifice either, but you have to choose between adding a suitable package, or writing the required boilerplate yourself
02:30:42 <tdammers> both are relatively benign compared to the PHP situation IMO
02:31:19 <ocramz> hullo!
02:31:47 <kqr> Myrl-saki, but I'd guess it's mostly a process of "hey I have this new shiny operation with a few laws. I wonger what types I can make fit inside it. gee who would have thought this worked out so well?"
02:31:55 <ocramz> is there an abstraction for keeping and inspecting the previous N states during `execState`, and deciding termination using these ?
02:32:04 <ocramz> I'm thinking of iterative algorithms
02:33:58 <Myrl-saki> kqr: I don't know what was harder to have thought of genrealizing. join or (>>=)
02:34:09 <NickHu> Does anyone have any suggestions for Undergraduate level texts to learn category theory from?
02:34:25 <Myrl-saki> kqr: I dunno where in the world where someone would have thought that "Hmmm... IO (IO a)? let me do some magic with that.)
02:34:32 <Myrl-saki> s/)/"/2
02:34:47 <NickHu> I've got a copy of Awodey's book but I'm finding it kinda dense - my eyes started glazing over when it talked about UMPs
02:35:11 <Myrl-saki> kqr: It doesn't seem to have anything to do with Functor laws either. That was something that was added later.
02:36:07 <kqr> Myrl-saki, join in terms of IO is actually fairly easy to imagine for me. if you want to do something stupid simple like `putStrLn(getLine) :: IO (IO a)` you need a way to fold together the two
02:36:53 <Myrl-saki> kqr: Hmmm.. true.
02:37:01 <Myrl-saki> :t putStrLn
02:37:02 <kqr> well that's an incorrect type but you seem to get the point
02:37:03 <lambdabot> String -> IO ()
02:37:16 <Myrl-saki> kqr: Oh yeah. For a second there, I thought I was going crazy. xD
02:37:26 <Myrl-saki> kqr: It sounded *kinda* correct.
02:37:42 <ph88^> tdammers, tbh i'm upset it seems to trivial and it's not in the $70 book i bought
02:38:21 <ph88^> in php you can traverse ast by 4 methods https://github.com/nikic/PHP-Parser/blob/master/lib/PhpParser/NodeVisitorAbstract.php
02:38:31 <Myrl-saki> kqr: Anyways, with that said. That still relies on it being a functor.
02:38:56 <Myrl-saki> kqr: Assuming we're going on the IO (IO a) idea.
02:39:00 <ph88^> also because it's not statically typed you can just traverse anything you want to matter which class get passed (which is not in that particular snipper)
02:39:10 <ph88^> snippet
02:39:35 <kqr> Myrl-saki, sure. are you asking from a maths standpoint or a haskell standpoint? because a lot of haskell has been shamelessly ripped from maths
02:39:55 <kqr> Myrl-saki, which makes the answer to "how was this invented in haskell" often turn out to "well we looked at how they solved it in maths"
02:40:00 <Myrl-saki> kqr: Oh wait. Now that I think about it. `join` "inherently" requires it being a functor anyway.
02:40:33 <Myrl-saki> kqr: Unless we're going with more obvious examples such as lists.
02:40:48 <ph88^> especially since haskell tauts itself as being great to write compilers and now i can't even do tree to tree transformations ... what the fuck
02:41:07 <Myrl-saki> ph88^: Tree to tree? Explain.
02:41:27 <Myrl-saki> kqr: Anyways, were monads relevant in math?
02:41:46 <EvanR> NickHu: i was directed to awodey after i had the same reaction to CFTWM
02:43:06 <ph88^> Myrl-saki, https://en.wikipedia.org/wiki/Tree_(data_structure)
02:43:22 <Myrl-saki> ph88^: Yes. I understand.
02:43:32 <Myrl-saki> ph88^: What kind of transformations are you talking about?
02:43:46 <kqr> Myrl-saki, depends on what you mean by "relevant"!
02:44:14 <kqr> Myrl-saki, some mathematicians study things purely for the sake of studying them, disregarding any usefulness they may have outside of their studies
02:47:44 <kqr> Myrl-saki, they basically invent laws and operations, throw them at the wall and then they see what sticks and makes sense with the rest of the stuff they have
02:47:56 <tdammers> ph88^: PHP allows you to attempt traversal of things that cannot be meaningfully traversed at all. If that is something you want, then Haskell is probably not for you.
02:47:56 <Myrl-saki> kqr: I see.
02:48:05 <kqr> Myrl-saki, some of it turns out to be very useful, other things less useful. some of it may turn out to be useful 50 years later when we figure out how to use it
02:48:47 <tdammers> ph88^: and it's not that tree transformations cannot be done in Haskell; you just have to be more specific as to how you want them done
02:48:59 <Myrl-saki> kqr: Yeah. Makes sense. Thanks. :D
02:49:09 <ph88> Myrl-saki, https://i.imgur.com/YYgVDAp.png
02:49:44 <tdammers> ph88^: in fact, people (including myself) have given you *several* solutions for your particular situation; none of them is perfect, but neither are the PHP ones
02:49:49 <ph88^> forgot to draw lines between nodes there
02:50:04 <ph88^> yes something in pandoc and monofunctor
02:50:45 <tdammers> ph88^: btw., given an arbitrary PHP class that implements a tree structure similar to how your Haskell data type does, you can't just traverse it either
02:51:40 <ph88^> it needs some kind of interface
02:52:22 <tdammers> yes
02:52:36 <tdammers> and which built-in PHP function automatically creates that interface for you?
02:52:56 <ph88^> php doesn't have derive
02:53:00 <ph88^> i expect more from haskell
02:53:24 <tdammers> it's fair to expect more, but you can't expect magic
02:53:36 <ph88^> php is stuck at reflection and code generation, does not have macro system too
02:54:19 <tdammers> yes; haskell can do better in these regards, but it still cannot derive information that isn't there, it still cannot read your mind
02:54:43 <tdammers> one thing it cannot tell, for example, is if you write this data structure:
02:55:06 <tdammers> data Foo = FooTerminal String | FooSubtree String [Foo]
02:55:32 <tdammers> i.e., a tree structure of strings with additional string labels on the non-terminal branches
02:55:52 <tdammers> and you want to traverse it such that a String -> String function gets applied to the elements
02:56:23 <tdammers> how is the deriving mechanism supposed to tell whether you want to operate on the leaf branch strings, the non-leaf branch labels, or both?
02:56:38 <tdammers> are they both the same type by accident, or do they actually mean the same thing?
02:56:57 <tdammers> there is no right or wrong answer here for the general case, which is why no generalized solution exists in base
02:57:15 <ph88^> i want to traverse all
02:57:18 <ph88^> so in this case both
02:57:30 <ph88^> just to find "all String" in data structure
02:58:39 <tdammers> that's a fair decision, but it's not something we can reasonably generalize
02:58:52 <ph88^> if it's FooTerminal then just take the STring, if it's FooSubtree also take the string but also map the function over the list of Foo
02:59:05 <tdammers> yes
02:59:18 <tdammers> so normally, you'd use Functor for this
02:59:37 <tdammers> writing it as data Foo a = FooTerminal a | FooSubtree a [Foo}
03:00:01 <tdammers> which, btw., also expresses your decision that both the 'a' types in the definition are the same type on purpose
03:00:11 <tdammers> then you *can* just derive Functor for your data structure
03:00:28 <tdammers> but there can only be one Functor instance for any given type, so that limits you to, well, that.
03:01:07 <tdammers> MonoFunctor would be a typeclass that allows you to have a functor instance for your type that doesn't require making it polymorphic, but you can still have only one instance
03:01:26 <tdammers> (which limits its usefulness, and is the reason why it's not in base)
03:02:16 <ph88^> this was suppose to be a solution to a problem that might have other solutions
03:02:38 <ph88^> not that i don't need to know this too, but it might not be the best approach
03:02:57 <tdammers> indeed
03:03:31 <tdammers> the best approach in this case, I believe, is to take a step back, realize that what you want is actually quite specific to your particular use case, and write less generalized functions to do the thing
03:03:41 <tdammers> e.g., walkFoo :: (String -> String) -> Foo -> Foo
03:04:04 <ph88^> i have quickcheck comparing two structures, namely concrete syntax tree. But it generate a CST with sourcepositions which don't make sense. Then i parse and then generate a new tree and the source positions are correct. But quickcheck says it fails because of source positions don't match .. but for now i don't care about the source positions
03:04:10 <tdammers> walkFoo f (FooTerminal s) = FooTerminal (f s)
03:04:32 <tdammers> walkFoo f (FooBranch s children) = FooBranch (f s) (map (walkFoo f) children)
03:04:34 <tdammers> there, that's it
03:04:49 <ph88^> for every node it's just a random sourceposition  https://github.com/mrkkrp/megaparsec/blob/6a7c41d88998d5358b10920497fb6efe388ab3a5/tests/Util.hs#L249-L253
03:05:10 <Myrl-saki> ph88^: Nothing's stopping you from doing that at all.
03:05:15 <Myrl-saki> ph88^: You can do it with lens, probably.
03:06:03 <saurabhnanda> broadcasting this here, for wider feedback: https://www.reddit.com/r/haskell/comments/54umkh/haskell_for_large_codebases_looking_for_first/
03:07:14 <synruby> in other news i just put reddit and twitter on the hosts file. too much distraction
03:07:44 <synruby> ...without getting actual work done
03:07:50 <synruby> ......bye
03:08:11 <tdammers> apparently freenode is now also on the hosts file.
03:10:37 <Myrl-saki> saurabhnanda: "but also a language that holds your hand (whether you like it or not!)" lol
03:10:55 <saurabhnanda> Myrl-saki: :)
03:11:40 <tdammers> I wouldn't call it hand-holding, it's more like a pedantic a-hole sitting next to you and slapping you in the face whenever you say anything that isn't 100% logically coherent
03:14:25 <Myrl-saki> tdammers: it's the pedantic a-hole you'll thank when you return to the project years later though.
03:19:50 <tdammers> Myrl-saki: definitely
03:20:28 <tdammers> it's like a savant whose incredible single talent just happens to save the day time and again
03:20:43 <tdammers> that's why you have him sit next to you in the first place
03:27:32 <AfC> I know there are a couple libraries that use a quasi-quoter to emulate a multi-line string. Can anyone particularly recommend 'heredoc' or 'here' or...
03:39:31 <saurabhnanda> what's a good job board to find haskell programmers?
03:43:01 * hackagebot servant-purescript 0.6.0.0 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.6.0.0 (eskimo)
03:44:03 <AfC> saurabhnanda: you're looking to _hire_ programmers? Well, there's lots of places; potentially advertise your positions using haskellers.com, or any of stackoverflow or reddit. "Functional Works" also runs a decent enough site.
03:44:17 <saurabhnanda> AfC: thanks
03:44:33 <saurabhnanda> AfC: yes, looking to hire a Haskell expert for a very short project first. Might turn into something larger later.
03:45:30 <AfC> saurabhnanda: ... or you could mention your job here :)
03:45:52 <saurabhnanda> let me write it up
03:47:14 <AfC> saurabhnanda: to save you some needless followup, include stuff like whether you can have someone work remotely, or whether you need them to visit, or whether you need them on site (permanently or otherwise; if long term you're offering relocations, etc, of course). 
03:47:36 <saurabhnanda> AfC: thanks for the tip
03:47:47 <AfC> saurabhnanda: by the way, everyone is a Haskell Expert. Yup.
03:48:18 <saurabhnanda> AfC: ?
03:48:46 <eklavya_> AfC: I find that offensive, when there is an absolute newb like me around
03:49:11 <MarcelineVQ> you don't get payed to be a newb though :> everyone that wants to be hired is an expert in whatever you're hiring them for, even if they haven't heard of it
03:49:24 <AfC> Everyone who contacts you will claim to be an expert if that's what you ask for. You might need to qualify a bit better what you _need_ to work out which particular expertise you need. (and people who have no idea what they're talking about will also self-identify as experts, wheee)
03:49:31 <eklavya_> just kidding
03:49:42 <AfC> MarcelineVQ: exactly
03:49:48 <saurabhnanda> AfC: I think I have PLENTY of questions to qualify experts :)
03:50:13 <saurabhnanda> AfC: more than I can handle, in fact
04:02:17 <tdammers> I think the gist is that describing what kind of project you have and what kind of work you need done is going to be a lot more useful than expressing your wishes in terms of "level of expertise" or "years of experience"
04:02:51 <tdammers> because the latter produces many false positives (incompetent people overestimating their skills) and false negatives (impostor syndrome)
04:03:12 <saurabhnanda> tdammers: got it. makes sense.
04:08:23 <ongy> I have no idea how to judge my skilllevel
04:08:31 <ongy> I would always asume terrible
04:17:07 <tdammers> ongy: false negative it is :D
04:24:27 <yangit11> Hi, does anyone know how to load 2 .hs files in ghci? sorry for asking such a basic question
04:24:50 <zomg> you should be able to just load them one by one
04:26:08 <yangit11> in < LEARN YOU A HASKELL FOR GREAT GOOD> , there is an example, in one .hs file, it uses a function defined in another .hs file 
04:28:16 <yangit11> and when I was trying to load both, it told me "module ‘main@main:Main’ is defined in multiple files:"
04:28:55 <yangit11> seems should google first, sorry
04:29:23 <tdammers> well, if you don't explicitly write a module declaration, then it defaults to Main
04:30:02 <tdammers> and you can't have two modules of the same name loaded at once, so it fails
04:30:07 <yangit11> thanks a lot, the first chapter goes a little far, I will try it later
04:30:23 <tdammers> so just give one module an explicit name (or both)
04:30:51 <tdammers> in fact, it's a good habit to always write a module declaration, even for module Main
04:31:07 <tdammers> and ofc Main should only be used for the module that contains your main function
04:31:12 <tdammers> s/function/action/
04:33:55 <yangit11> ok, thank you tdammers! : )
04:39:03 <andreabedini> hello awesome haskell community, I seem to have trouble getting gtk2hs to compile (on osx), https://github.com/gtk2hs/gtk2hs/issues/183 could anyone help?
04:43:03 * hackagebot linked-list-with-iterator 0.1.0.0 - A pure linked list which is mutable through iterators.  https://hackage.haskell.org/package/linked-list-with-iterator-0.1.0.0 (CindyLinz)
04:50:52 <byorgey> @tell slack1256 re: a diagrams exectuable you can feed code, yes, such a thing exists in the diagrams-builder package
04:50:53 <lambdabot> Consider it noted.
04:56:24 <haskell218> hello all
04:57:03 <liste> hello haskell218 
04:57:03 <haskell218> can some one help me to understand reader monad and how and where i could use it
04:58:36 <haskell218> after reading so many tutorials i can't get it 
05:01:00 <zomg> One example could be if your app has some list of settings, for example loaded via command line args
05:01:41 <zomg> you can put those settings into a Reader monad and the rest of your program can easily get the values from there where needed
05:06:18 <AfC> haskell218: (in larger programs you tend to have stacks of Monad [Transformers] all synthesized into a single monad that is what you run your main application logic in. One of those layers would inevitably have the application configuration / environment / command line settings stashed in it. The thing it would be stashed in would be a ReaderT somewhere in that stack)
05:07:10 <AfC> This is not the only way to do things, and it's cumbersome enough that we're all vaguely desperately looking for better ways to do things, but it is a fairly common pattern at any kind of scale.
05:20:52 <saurabhnanda> anyone interested in a short-term Haskell webapp project: https://angel.co/vacation-labs/jobs/175267-haskell-developer-for-a-small-proof-of-concept-webapp
05:22:13 <michi7x7> AfC: I tend to just use StateT IO and don't care about mutability. lifting is just too bothersome for me ^^'
05:22:45 <saurabhnanda> anyone interested in a PAID short-term haskell webapp project: https://angel.co/vacation-labs/jobs/175267-haskell-developer-for-a-small-proof-of-concept-webapp
05:31:54 <sbrg> sounds interesting. wish I had the time
05:40:28 <tdammers> saurabhnanda: sounds interesting, but the short time frame makes it not very tempting
06:03:56 <bollu> quick question about cones
06:04:19 <bollu> let's consider F: J -> C
06:04:25 <bollu> where F is a functor and J is the indexing category
06:04:48 <bollu> now, I get the "tip" of the cone c \in C by the functor delta: J -> C, where delta(_) = c, correct?
06:05:08 <bollu> and the "bottom" of the cone is from any "legitimate" functor G: J -> C?
06:05:20 <bollu> so now I have two functors at play, the delta_c functor, and the G functor?
06:05:26 <bollu> wait, I didn't need F
06:05:27 <bollu> but anyway
06:05:32 <bollu> am I thinking of the cone right?
06:05:42 <bollu> and the "edges" of the cone is the mapping from c -> G(j) ?
06:07:15 <Hafydd> PAID!
06:07:45 <Hafydd> I don't know about that. I usually work for FREE.
06:14:59 <cocreature> bollu: what do you ned your delta functor for?
06:15:49 <bollu> cocreature: for the "vertex" of my cone
06:15:52 <cocreature> you are right that c is your tip and the edges are morphisms c → G(j) such that they commute
06:15:59 <bollu> cocreature: in the sense that, my "edges" of my cone are for the vertex
06:16:11 <cocreature> bollu: I don’t see what you gain by creating that contant functor instead of just talking about c directly
06:16:17 <bollu> cocreature: okay, so now the "limit" is the object l \in C such that any other cone c \in C factors through l, correct?
06:16:31 <bollu> cocreature: I wanted to ask about the limit of G
06:16:40 <bollu> cocreature: so I wanted to talk about the tip of the cone first
06:16:56 <cocreature> sure but the tip is just some object in C
06:17:19 <cocreature> and your explanation of limit looks fine
06:17:30 <bollu> cocreature: cool, thank youc
06:17:35 <bollu> cocreature: so, in some sense
06:17:47 <bollu> cocreature: I'm forming a "category of cones"? (idk how to make this precise)
06:17:56 <bollu> cocreature: and the limit is the terminal object in this category?
06:19:45 <cocreature> I guess you could make a category of cones and have a morphism from c to c' if there is a unique morphism from c to c' such that everything commutes. then the limit would be the terminal object
06:20:33 <bollu> cocreature: hmm, right. makes sense I guess
06:20:40 <bollu> cocreature: but the "everything commutes" is a little iffy
06:21:06 <cocreature> bollu: well you can write it down precisely but I’m too lazy for that :P
06:21:25 <bollu> cocreature: hahaha, okay
06:22:12 <cocreature> when talking to people who actually know category (I only know very little), they usually just say that “the obvious things commute”
06:22:34 <cocreature> which is pretty terrible tbh but surprisingly it is clear in most cases what they mean
06:23:33 <cocreature> wikipedia constructs the category of cones based on comma categories but I forgot what they were :/
06:23:56 <bollu> cocreature: what's the comma category?
06:24:54 <cocreature> just looking that up again myself :)
06:26:42 <cocreature> so you need two functors S:A→C and T:B→C, then your objects are triples (a,b,f) with a∈A,b∈B and f:S(a)→T(b), morphisms are then pairs g:a→a', h:b→b' such that everything commutes :)
06:26:50 <cocreature> here’s the diagram https://wikimedia.org/api/rest_v1/media/math/render/svg/b2071b8e1b080f0de284278bbe28bc8cbe23c2d0
06:27:29 <cocreature> for cones you let S be the constant functor and T the index functor or whatever that is called
06:27:57 <ski> NickHu : i realized later that if `Lst' is the category of list types, and *all* Haskell functions between them, then it's *not* the image of the list functor ..
06:31:02 <ski> bollu : .. sounds reasonable
06:31:45 <bollu> ski: cool, ty 
06:33:24 <ski> bollu : though usually it's the functor from `C' to `C^J'/`J -> C' which would be called `Delta', and your cone construction is then a right adjoint to this
06:33:47 <bollu> ski: what's C^J / J?
06:34:30 <ski> `C^J' is the category with objects all functors from `J' to `C' (and morphism being natural transformations between such functors)
06:35:26 <ski> `J => C' or `J -> C' would be more a "type theoretical" way to denote it
06:35:33 <ski> (or sometimes `[J => C]', iirc)
06:36:19 <bollu> I see
06:36:46 <bollu> so you have a functor C —f—> [J => C] ?
06:37:11 <bollu> ski: not able to visualize this
06:38:19 <ski> yes, `Delta c = (_ |-> c)', basically `const' in Haskell terms
06:38:47 <bollu> ski: hm, okay. I usually visualize it as a functor that "collapses" everything in J into c \n C
06:39:07 <ski> (however, if you haven't got to adjoint functors, or free&cofree functors yet, probably the adjunction description doesn't help at this point)
06:39:21 <ski> yes, that is the functor `Delta c'
06:39:29 <bollu> ski: I understand adjoints, but I don't understand the thing they're adjoint _to_ :
06:39:30 <bollu> :)
06:39:48 <ski> for every `c' in `C', the functor `Delta c' collapses the whole diagram in `J' to just `c' in `C'
06:40:22 <ski> and then, there's a functor that maps `c' in `C' to the functor `Delta c' in `C^J', namely the functor `Delta'
06:40:45 <ski> let's consider `J = 2 = 1 + 1' for the moment
06:41:23 <ski> then `Delta c = (c)_{i : 2} = (c,c)', mapping an object `c' in `C' to the object `(c,c)' in `C^2'
06:41:44 <bollu> ski: ah
06:41:46 <ski> so we have the diagonal functor `Delta' from `C' to `C^2'
06:42:02 <bollu> omg, okay, now I got your "const" definition
06:42:10 <ski> the cone construction now is a right adjoint to this functor, which is a functor `(*)' from `C^2' to `C'
06:42:14 <bollu> ski: so it's like f(c) = const c
06:42:20 <ski> which maps `(c0,c1)' to `c0 * c1'
06:42:27 <ski> bollu, yes
06:43:05 * hackagebot iridium 0.1.5.5 - Automated Local Testing and Package Uploading  https://hackage.haskell.org/package/iridium-0.1.5.5 (lspitzner)
06:43:07 * hackagebot modbus-tcp 0.2 - Communicate with Modbus devices over TCP  https://hackage.haskell.org/package/modbus-tcp-0.2 (RoelVanDijk)
06:43:16 <bollu> ski: this matches the free/forgetful definition doesn't it?
06:43:27 <bollu> we "forget" structure to get from C^2 to C
06:43:31 <bollu> the delta functor that is
06:43:43 <bollu> and to go from C to C^2, we do the "free" thing (copy c)
06:43:47 <oreqizer> hi guise
06:43:56 <bollu> oreqizer: hey :)
06:44:09 <ski> (and cocones ("nes" ?) would then be *left* adjoints to the diagonal functor, in this case `(+)', the categorical coproduct)
06:44:33 <oreqizer> is there any1 who knows how to implement Data.Vector.Unboxed? been trying for 3 days now
06:44:38 <oreqizer> my attempt https://github.com/oreqizer/minicraft/blob/master/haskell/naive1.hs#L40
06:44:44 <oreqizer> your eyes will bleed probably
06:44:59 <ski> (btw, note that the diagonal functor `Delta : C -> C^J' is the curried version of `Pi_0 : C * J -> C')
06:44:59 <ski> bollu : makes sense ?
06:45:30 <bollu> ski: makes sense cause currying, but I can't see it
06:45:32 <ski> bollu : no, the `Delta' functor goes from `C' to `C^2', not the other way around
06:45:39 <bollu> ski: wait, what?
06:45:50 <oreqizer> i just couldn't find a vanilla explanation of the module
06:46:13 <ski> sure, we have `Delta --| (*)' (and also `(+) --| Delta')
06:46:28 <oreqizer> i want to learn to do it 'vanilla' before using http://hackage.haskell.org/package/vector-th-unbox-0.2.1.6/docs/Data-Vector-Unboxed-Deriving.html
06:47:35 <ski> in the latter case, `(+) --| Delta', you *could* think of `Delta : C -> C^J' as going, from `J'-tuples of `C' which *must* be constant, to arbitrary `J'-tuples of `C', and thus you could think of `Delta' as "forgetting" that these `J'-tuples must be constant
06:48:03 <bollu> ski: hm
06:48:16 <ski> and then `(+)' is the corresponding free functor, which maps any `J'-tuple of `C's to a constant `J'-tuple of `C's
06:48:32 <ski> .. it's a bit of a stretch, but i think one could think of it in this way
06:49:41 <bollu> ski: yeah, can't visualize it :) will take some time
06:49:43 <ski> however, if you want to consider the `Delta --| (*)' situation, with `Delta' left adjoint to the corresponding right adjoint `(*)', you'd have to somehow be able to view `(*)' as the "forgetful functor", to be able to view `Delta' as the "free functor"
06:49:51 <ski> i'm not sure whether this makes sense at all
06:50:11 <ski> usually, a forgetful functor would be faithful, and, iirc, also full
06:50:37 <ski> ("forgetful functor" is a bit of a vague concept, afaik)
06:50:57 <ski> (and also "free functor" then, since it's defined as "left adjoint of a forgetful/underlying functor")
06:51:37 <ski> however .. you could probably think of `(*)' as a *cofree* functor to the forgetful (in the same sense as above) `Delta', by just dualizing
06:52:09 <lyxia> oreqizer: does your code not work?
06:53:22 <ski> bollu : by "`J'-tuples of `C' which *must* be constant" i mean something like `{F : C^J | forall j0,j1 : J. F(j0) = F(j1)}'. in the `J = 2' case, this would be `{(c0,c1) : C^2 | c0 = c1}', which is obviously isomorphic (or equivalent) to just `C'
06:58:56 <Tuplanolla> Not that you can't scare the uninitiated with abstract nonsense, but there's ##categorytheory for this. It's very nice. You should come visit.
06:59:25 <ski> bollu : hmm .. `(*)' in `Set' isn't faithful since `(f,g) |-> <f,g>' with `f : 0 -> 0', `g : A -> B' isn't injective, different `g's will map to `<[],g> = []'
06:59:51 <bollu> Tuplanolla: heh, neat! I'll join
07:00:04 <bollu> ski: your (*) is within the category of Set, right?
07:00:16 <ski> bollu : in the last statement, yes
07:00:29 <ski> (otherwise it was meant to be for an arbitrary category `C')
07:00:47 <bollu> ski: right, yeah
07:01:31 <ski> (the `{F : C^J | forall j0,j1 : J. F(j0) = F(j1)}' was intended as a rough idea. i'm not sure under which conditions one could use such notation in general for subcategories)
07:04:44 <ski> (er, actually i meant `(f,g) |-> f * g', being the morphism-part of the `(*)' functor. sorry. the statement still holds, though. `[] : 0 -> A' is the empty "coupling", while `<f_0,f_1> : T -> A_0 * A_1' with `f_i : T -> A_i' would be the binary "tupling" of `(f_i)_{i : 2}')
07:05:49 <oreqizer> lyxia: it does, but is slow
07:05:55 <leshow> are all functors in the typeclass functor endofunctors?
07:06:02 <oreqizer> and I kinda don't understand what's going on in those Unbox definitions :(
07:06:51 <Tuplanolla> Yes, if you admit that Haskell types form a category, leshow.
07:06:51 <ski> leshow : yes
07:06:51 <ski> leshow : in particular, endofunctors on `*'/`Hask'
07:07:32 * ski would perhaps like a more general (polymorphic) `Functor' class, possibly along the lines of the new `Typeable'
07:08:35 <ski> (however, `tmap :: forall f g. (forall a. f a -> g a) -> (t f -> t g)' isn't the same as `tmap :: forall f g. (Functor f,Functor g) => (forall a. f a -> g a) -> (t f -> t g)' ..)
07:10:19 <leshow> if a monad is a monoid in the category of endofunctors, and all haskell functors are endofunctors. doesnt that mean that all monoids are monads
07:10:40 <ski> no
07:13:40 * ski isn't quite sure how leshow meant to reason there ..
07:14:09 <c_wraith> leshow: the Monoid class describes monoids in the category of simple types.  (a * a) -> a.  That quote is about monoids in a different category: (f * f) a -> f a
07:14:09 <ski> anyway, "monoid in a monoidal category" is a generalization of the usual definition of "monoid"
07:14:33 <ski> and a monad is a monoid in this generalized sense, for the specific monoidal category of endofunctors
07:14:59 <c_wraith> Or as we'd put those operations in Haskell, a -> a -> a vs f (f a) -> f a
07:16:17 <ski> perhaps it would be possible to *view* any monoid (in the restricted sense, or even the generalized sense) as a monad, iow a (generalized) monoid in a *specific* category of *endofunctors* .. in some more or less trivial way
07:16:35 <ski> i'm not sure whether that would really give any more insight, though
07:32:59 <quchen> Stack has no garbage collector for ~/.stack, yes. But can I manually throw out things from there somehow? Like "stack --uninstall lts-4.0"?
07:33:18 <quchen> I suspect deleting the corresponding folder might break things, so I’m hesitating doing that.
07:33:26 <quchen> There’s also the classical full wipe, of course.
07:33:43 <Tuplanolla> Isn't Stack supposed to solve that problem?
07:34:07 <quchen> I don’t think so, no. Stack is primarily for building things, not for removing them. :-)
07:34:19 <MarcelineVQ> stack will rebuild things that are missing, feel free to delete anything in the snapshots folder confidently
07:35:14 <quchen> MarcelineVQ: How about the "programs" dir? Can I delete GHC 7.8?
07:35:33 <MarcelineVQ> afaik, you may need to run stack setup if your project can't find it's compiler though
07:36:27 <quchen> Sure.
07:36:45 <quchen> I just wanted to know whether some packages have symlinks to other LTS builds, for example.
07:36:58 <quchen> Those would break if I just ripped out part of the snapshot DB.
07:38:42 <MarcelineVQ> there shouldn't be
07:39:10 <MarcelineVQ> at least, I've got a pretty stacked up snapshots folder and didn't find any simlinks
07:39:37 <quchen> Fair enough.
07:39:46 <quchen> Worst case I can just delete .stack and start from scratch.
07:43:06 * hackagebot pqueue 1.3.2 - Reliable, persistent, fast priority queues.  https://hackage.haskell.org/package/pqueue-1.3.2 (lspitzner)
07:44:41 <cocreature> quchen: some binaries (I’ve only seen this with alex) refer to the build directory which is the snapshot dir so even if you ran stack install to copy them to .local/bin deleting the snapshot directory can break them
07:45:30 <quchen> cocreature: Hmm, alright. So things might break, but not silently at least.
07:57:58 <michi7x7> Uptime: 15 minutes
08:00:53 <ongy> that's not much
08:02:25 <michi7x7> ongy: yeah, just wanted to know what this command does in my IRC client
08:15:03 <soLucien> could not find module tasty it is a member of the hidden package
08:15:08 <soLucien> what am i doing wrong ?
08:15:25 <cocreature> soLucien: add it to build-depends in your cabal file
08:16:35 <soLucien> build-depends: tasty ?
08:17:21 <cocreature> yep
08:17:39 <cocreature> probably build-depends: base, tasty, … where you replace … by any other dependencies your project has
08:19:27 <Guest21157> hello all haskellers !!
08:20:03 <Tuplanolla> (1458 greetings omitted.)
08:21:54 <Guest21157> can anyone help me to understand about how to use reader monad .... after reading lots of tutorials i can't get it ..how to actually use it and when i will need
08:23:05 <ski> when you get tired of carrying around lots of "configuration" arguments into your functions
08:23:25 <ski> moreso, if you're already using a monad or idiom (aka applicative functor)
08:24:22 <ski> and even moreso (advanced use), if you really need to sandwich your `ReaderT r' *inbetween* two other monad transformers
08:24:43 <Guest21157> <ski> but how ....can you give me concrete example of some implementation  ....please .... i am totaly confused right now 
08:25:41 <ski> (please don't write "<ski>" if you mean to address me. it looks like you're quoting me. IRC custom is to begin the message with the nick in question, e.g. followed by a comma or a colon, and then the message)
08:26:15 <ski> (also, please don't write "@ski" either. not saying you did this, but sometimes people do)
08:26:25 <ski> Guest21157 : if you have something like
08:26:36 <ski>   fooWith :: Config -> A -> B -> C
08:26:56 <Guest21157> ski : ok thanks i don't know
08:27:00 <ski>   fooWith config a b = ..(fooWith config (...) (...))..(barWith config (...))..
08:27:22 <ski> then instead of repeating `config' all over the place, to pass your configuration into the places that needs it, you can instead use
08:27:35 <ski>   foo :: A -> B -> Reader Config C
08:28:02 <ski> but then you'll have to use monadic or idiomatic style for your body .. so it's less of a burder if you're already doing that
08:29:04 <ski> (keep in mind that `Reader Config C' is basically the same as `Config -> C', just hiding the "distribution" of the `Config' "environment" in the plumbing of `return'/`pure' and `(>>=)' alt. `(<*>)')
08:29:32 <ski> Guest21157 : makes sense ?
08:29:53 <Guest21157> ski : yeah
08:29:56 <Tuplanolla> Oh, but who will save us from `fooWith :: Config -> A -> B -> IO C`?
08:30:24 <ski> Guest21157 : .. however, if you really want to use the *same* `config' always, *and* you're only doing it *locally*, then it'd often be better to just use static scoping :
08:30:35 <ski>   fooWith :: Config -> A -> B -> C
08:30:40 <ski>   fooWith config = foo
08:30:41 <ski>     where
08:30:46 <ski>     foo :: A -> B -> C
08:31:04 <Guest21157> ski : but actually i have read all these ... want i want is the real implementation of reader or readerT to have actual intuition how to use local, ask,etc
08:31:05 <ski>     foo a b = ..(foo (...) (...))..(bar (...))..
08:31:13 <ski>     bar :: D -> E
08:31:19 <ski>     bar d = ...
08:31:58 <ski> Guest21157 : `ask' is to actually get the value of your `config', when you really need to look at it (as opposed to just pass it on)
08:32:21 <ski> Guest21157 : `local' is when, for a local subcomputation, you want to *change* your `config' value into something different
08:32:23 <Guest21157> ski : yes that i got
08:32:53 <ski> Tuplanolla : `foo :: A -> B -> ReaderT Config IO C' is the suggestion here
08:33:42 <ski> yet another version is to use implicit parameters : `foo :: (?config :: Config) => A -> B -> C'
08:33:48 <Guest21157> ski : can you share with me some real code or link ....with use of all these
08:34:12 <byorgey> implicit parameters, eek
08:34:27 <ski> i don't have anyone handy, off the top of my mind
08:34:34 * ski smiles at byorgey
08:34:57 <ski> (implicit parameters is basically what is called "dynamic scope" in other contexts)
08:35:06 <Guest21157> ski : or any one you know 
08:35:36 <ski> Guest21157 : one common example of `ask' and `local' would be to make an interpreter of a language with bound variables
08:35:53 <byorgey> Guest21157: here is some real code using ReaderT I just wrote the other day: https://github.com/byorgey/discrete-lang/blob/master/src/Typecheck.hs#L132
08:35:54 <ski> Guest21157 : you'd use `Reader'/`ReaderT' to keep track of the value environment
08:35:59 <byorgey> it is a typechecker for a simple functional language
08:36:07 <byorgey> see also the definition of 'lookup' and 'extend' in that file
08:36:09 <ski> Guest21157 : as byorgey suggested, you can also use it for type environments, in type checking
08:36:16 <Tuplanolla> I just looked at Yesod and Hakyll without finding uses of Reader, but I suspect some exist.
08:37:20 <ski> Guest21157 : Cale would, iirc, suggest that in most cases, just passing an explicit parameter instead of using `Reader'/`ReaderT' is better
08:37:38 <Guest21157> yeah actually i am implementing a toy assembler in haskell and for that i needed reader for keeping track of symbol table
08:38:08 <Tuplanolla> Download some packages and exercise the use of grep, Guest21157.
08:38:12 <Cale> Reader/ReaderT are okay *once you already have some monad transformers in place*, but they're almost never worthwhile on their own.
08:38:18 <byorgey> yes, that sounds like a good use for Reader
08:38:33 <Cale> Maybe if you're getting lots of use out of 'local'
08:38:41 <byorgey> Reader is good anytime you have some notion of local scope/context (this is what 'local' does)
08:38:56 <Cale> Yeah, that might be okay
08:39:25 <byorgey> Cale: but even so I tend to agree about Reader not being that useful on its own.  In the example I linked it is part of a 4-monad stack
08:39:29 <Cale> I tend to warn people away from casually using ReaderT or StateT over IO
08:39:43 <ski> Guest21157 : multi-pass assembler ?
08:39:54 <Guest21157> yes 
08:40:11 <Guest21157> ski : yes 
08:40:26 <Cale> It's almost never a better result, simply because you incur so much noise through having to do liftIO everywhere, and dealing with things like forkIO or exception handling becomes more annoying.
08:41:51 <Cale> But if you're already paying that price, it's fine
08:42:29 <Guest21157> byorgey : thanks for the link
08:43:00 <byorgey> Guest21157: you're welcome.  There are other uses of Reader in that repository as well if you want to poke around.
08:43:08 * hackagebot hamsql 0.7.0.0 - HamSql  https://hackage.haskell.org/package/hamsql-0.7.0.0 (quabla)
08:43:10 * hackagebot effect-monad 0.7.0.0 - Embeds effect systems into Haskell using graded monads  https://hackage.haskell.org/package/effect-monad-0.7.0.0 (DominicOrchard)
08:43:29 <Ucenna> Non-haskell(JavaScript) specific functional question: Let's say I'm passing an funciton as an argument to a function. Is it bad practice to then assign the value of that argument to a variable.
08:43:49 <Ucenna> i.e. f(x) var y = x()
08:44:25 <Ucenna> I'm still getting used to when it is, and isn't okay to use variables. What is or isn't considered bad practice.
08:44:28 <Guest21157> tuplanolla : i can't get what are you trying to say me... can you elaborate for me...
08:45:21 <Tuplanolla> If you want to find uses of Reader, it might be worthwhile to navigate to Hackage, download a large package and search for uses of Reader in it, Guest21157.
08:46:36 <ski> Ucenna : i don't know much ECMAscript, but i'm not seeing why it would be bad practice to *initialize* a variable with some value
08:46:39 <Guest21157> ok ... can you give me some example or name of any .... to be seen , tuplanolla.
08:46:56 <Ucenna> I have a function to verify that another function is passed a variable. f(g) where g() is user input. If they enter nothing, I need to verify and pass the function back.
08:47:20 <ski> Ucenna : what is typically frowed upon in (pure) functional programming is *re*assigning to a (mutable) variable (or other location, e.g. inside an array or record or object, or behind a pointer/reference)
08:47:21 <Ucenna> Okay, I wasn't sure if it was bad practice to couple that with recursion.
08:47:56 <ski> s/frowed/frowned/
08:48:02 <Tuplanolla> Try Pandoc for example, Guest21157.
08:48:21 <Ucenna> Okey dokey, I think I got it.
08:49:18 <Guest21157> ok thanks, tuplanolla.
08:49:47 <ski> Ucenna : fwiw, i wouldn't say "assign the value of that argument to a variable" here. i would say something like "name the *result* of that callback / (argument) function"
08:50:28 <ski> Ucenna : since `y' after `var y = x()' will not contain the argument itself (which was `f'), it will contain the *result* of calling that function, iow the result of evaluating the expression `f()'
08:51:45 <ski> Ucenna : similarly, i wouldn't say "f(g) where g() is user input", but rather "f(g) where g is user input". if `g' is a function, then `g()' need not be a function. `()' isn't something you tack on to the end of a name to emphasize that it's a function. it means "*call* this function (possibly with some arguments, if expected)"
08:51:52 <ski> Ucenna : i hope that helps ..
08:58:34 <Ucenna> Okey dokey. I got it. The calling of g was intentional. Something like f(g) { var result = g(); if (!g) {return f(g)} else {return g}}
08:58:56 <Ucenna> * else {return result}}
08:59:57 <ski> Ucenna : should it be `!result' in place of `!g' ? otherwise, shouldn't the `var result = g();' be inside the `else'-branch ?
09:00:22 <ski> hmm
09:01:22 <Ucenna> Whoops. Yes, sorry.
09:01:51 <Ucenna> Thanks!
09:02:19 <ski> Ucenna : you're repeatedly calling `g', until it returns a non-false value ?
09:02:38 <Ucenna> yes
09:02:53 <Ucenna> I'm still learning, there's probably a better way to do it.
09:02:58 <ski> Ucenna : remind me, does ECMAscript implementations typically have tail calls ?
09:03:14 <Ucenna> Yes, as of ECMA 6 I believe.
09:03:40 <ski> for any syntactic tail call ? even to a function argument ?
09:04:14 <ski> or merely for statically-known calls ? possibly only in the same "module" ? possibly only recursive (or mutually recursive) calls ?
09:04:58 <Ucenna> I believe it's any, but I'm not certain. I just picked up the language this week.
09:05:01 <ski> ok
09:05:35 * ski assumes Ucenna has some familiarity with tail-calls from some other context, then, perhaps Scheme
09:06:07 * Ucenna admits that's it's somewhat less than that.
09:06:39 <Ucenna> I have a fair ammount of programming experience, but I'm completely new to functional programming
09:06:49 <Ucenna> *mostly completely new
09:07:01 <ski> anyway, if that recursive call to `f' is actually implemented as a tail call (which is probably the case, from what you said), then that should be an ok loop iterating over `g'
09:07:25 <ski> (otherwise i'd instead suggest `while' or whatever primitive ECMAscript has for looping)
09:07:42 <e> it is a sad world where we still have to worry about whether things are actually implemented as things
09:07:52 <Ucenna> I believe it's recursive. My code runs, so it must be.
09:07:55 <Ucenna> Definitely!
09:08:12 <ski> (.. well, one shouldn't be too afraid of (general) recursion either. especially when you can break stuff down into a (conceptual) tree, with more than one (non-tail, say) recursive calls)
09:08:38 <Ucenna> yeah
09:08:58 <ski> e : yes, i prefer the Scheme example, where it's not an optimization, because it's required by the specification
09:09:00 <Ucenna> I'm almost certain it's optimized, but I couldn't say 100%
09:10:08 <ski> (they specify that you should be able to have an unbounded number of activations of tail calls, in bounded space. however there is no requirement to implement this in the typical TCO fashion. the point is the space behaviour)
09:11:56 <Ucenna> Okey dokey. I'm probably going to have to verify at some point. For now though, just being able to test it in something that I'm semi familiar with is great!
09:12:26 <ski> .. much of the confusion here comes from thinking that "normally, a function call will have to push stuff on the stack", while really it's more like "computing the result of subexpressions, *remembering* the result of the former while evaluating the latter, requires pushing stuff on a stack"
09:13:31 <ski> (iow, non-trivial expressions (typically calls) in *non*-tail-position)
09:14:56 <Ucenna> Yeah
09:15:49 <ltcmelo> can anyone explain what’s behind this particular function syntax: ` (foo a b) c = a + b + c ‘ ? in particular, I mean the parenthesis. this comes from the grammar rule `funlhs ::= ( funlhs ) apat { apat } ‘ in the report
09:16:20 <ski> @type let (foo a b) c = a + b + c in foo
09:16:22 <lambdabot> Num a => a -> a -> a -> a
09:16:24 <Ucenna> ski: Yeah. It took me a while to get that. Thanks for all the help!
09:16:42 <ski> Ucenna : no problem. have fun !
09:16:49 <Ucenna> Thanks! :)
09:16:49 <Ucenna> ttfn
09:17:51 <ski> ltcmelo : hm, can you provide a link to where that grammar rule is seen ?
09:18:27 <ltcmelo> ski: https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17500010
09:18:35 <ski> ltcmelo : anyway, one typical use of using brackets in the definiendum would be something like `(f . g) x = f (g x)', defining an operator which when supplied arguments on both sides will return a function
09:18:43 <ltcmelo> ski: notice that you can define a top-level declaration in that way
09:19:03 <ski> @type let (a `foo` b) c = a + b + c in foo
09:19:05 <lambdabot> Num a => a -> a -> a -> a
09:19:13 <ski> also works, which is nice, imho
09:20:25 <ski> @type let (bar x) Node {rootLabel = y,subForest = ts} = (x,y,ts) in bar
09:20:27 <lambdabot> t -> Tree t1 -> (t, t1, Forest t1)
09:20:29 <ski> @type let bar x Node {rootLabel = y,subForest = ts} = (x,y,ts) in bar
09:20:30 <lambdabot> t -> Tree t1 -> (t, t1, Forest t1)
09:20:40 <ski> (you don't need the brackets in that case)
09:21:02 * ski awaits webserver response ..
09:21:53 <ski> in any case, i'm for being able to use redundant brackets in patterns, for the same reason they're allowed in expressions
09:22:08 <ski> (and similarly for the non-redundant ones)
09:22:27 <ltcmelo> ski: I’m trying to digest it… 
09:23:14 <ski> @type let (  a `f` b  ) = a * b in f  -- unfortunately this doesn't work, breaking the correspondence :(
09:23:16 <lambdabot> error: Parse error in pattern: a `f` b
09:23:40 <ltcmelo> ski: I think you’re example isn’t derive by that rule
09:23:46 <ski> @type let (  (a0,a1) <*> (b0,b1)  ) = (a0 * b0,a1 * b1) in f  -- nor this
09:23:47 <lambdabot> error:
09:23:47 <lambdabot>     Parse error in pattern: (a0, a1) <*> (b0, b1)
09:23:50 <ltcmelo> ski: (f . g) is not a funlhs
09:24:16 * ski is still waiting for the page to respond, so can't comment on that yet ..
09:24:42 <ltcmelo> ski: actually it can be
09:26:07 <colo> if i have a list 'a' and a list of indices 'b' what is the best way to get a new list that is 'a' with 0s in each position whose index is in 'b'?
09:26:54 <ski> you could do it with `zipWith' ..
09:27:08 <ski> if `b' is sorted, then you could do it more efficiently
09:27:50 <colo> b is not sorted, how could i use zipWith?
09:28:51 <ski> > zipWith (\i a -> if i `elem` [5,2,7,2] then 0 else a) [0 ..] [2,3,5,7,11,13,17,19]
09:28:53 <lambdabot>  [2,3,0,7,11,0,17,0]
09:29:54 <ltcmelo> ski: do you see any other use of it apart from binding functions to other functions?
09:29:55 <ski> colo : ok ?
09:30:07 <colo> yes so there is no way to avoid iteration all over a
09:31:28 <ski> colo : obviously not .. apart from that if `b' is sorted (or you sort it, or at least find the maximum), then you could stop the scan through `a' past that index
09:31:51 <NickHu> ski: Isn't the image of the list functor going to end up being the same thing as Lst though?
09:32:17 <colo> ski: ok thanks
09:32:20 <ski> NickHu : no, the image of the list functor only has morphisms of the form `map f', for a morphism `f : A -> B' in `Set'
09:32:43 <ski> NickHu : e.g. `reverse_A : [A] -> [A]' is not in the image
09:32:49 <schell> i’m having a problem with a custom cabal Setup.hs where stack/cabal/ghc can’t find a module i’ve included in the build-depends field of my cabal file - has anyone ran into this?
09:33:14 <ski> ltcmelo : for some reason i don't seem to get an answer for the server atm ..
09:33:18 <NickHu> ski: That is a good point, I see
09:33:50 <schell> i’m trying to mimic https://github.com/ekmett/gl/blob/master/gl.cabal, which seems to be able to pull in the hxt, split, etc libs where Setup.hs can find them
09:35:51 <schell> ooh, i think i may have figured it out
09:35:53 <ski> ltcmelo : .. anyway, i'm not sure i'd call it "binding functions to other functions"
09:35:55 <ltcmelo> ski: ok, thanks anyway. but if realize something later, please let me know. I’m going over the grammar and I’m trying to make sure I don’t miss any fundamental concept. this case, for instance, doesn’t seem be one, but the I couldn’t make much sense of it first :-)
09:36:09 <ltcmelo> ski: what would you call?
09:36:17 <ski> i think i'd just call it "ordinary grouping" (for overriding precedence, or just for emphasis)
09:36:35 <ltcmelo> ski: you’re right, that’s not really binding one function to another
09:36:40 <dcoutts> schell: with the latest version of cabal you can specify dependencies for your Setup script itself
09:36:57 <ski> ltcmelo : one could imagine stuff like `(if ... then (f,g) else (g,f)) x y = ..x..y..', though
09:37:01 <schell> dcoutts: oh that would be great! i’m guessing that’s just in the docs then?
09:37:13 <ski> ltcmelo : conditionally defining `f' and `g' to be one of two functions, depending on `...'
09:37:40 <dcoutts> schell: https://cabal.readthedocs.io/en/latest/developing-packages.html#custom-setup-scripts
09:38:00 <schell> dcoutts++ ! :)
09:38:14 <dcoutts> :-)
09:38:19 <ltcmelo> ski: sorry, didn’t understand your last example
09:38:20 <ski> ltcmelo : for that matter, i'd also like `if ... then {f x = ...; g y = ...} else {f x = ...; g y = ...}'
09:39:04 <ltcmelo> ski: where does that parethesized syntax appear in that case?
09:39:04 <ski> er, sorry, that example is a bit broken actually
09:39:14 <ski> (let me see if i can make a sensible version)
09:41:54 <joe9> I want to add tests to a library which just has pure functions. I want the tests to work with stack. Is quickcheck the best bet?
09:42:09 <ski> ltcmelo : well, to make things simple, say just `(if ... then f x y else f y x) z = ..x..y..z..'
09:42:29 <nate_b_> If I have an ADT `data Foo a = Foo a | Bar | ...` and want to have a function of type `Foo a -> Foo b` that does the a to b conversion for the Foo constructor but otherwise just returns the value of Bar, etc., is there shorthand for this?  Or do I need to type out all of the enum cases?  I tried pattern matching on anything and returning it, but unsurprisingly it didn't work.
09:42:40 <ski> ltcmelo : so, depending on `...', we either name the first argument `x' and the next `y', or vice versa. the last we name `z', regardless
09:42:52 <ltcmelo> ski: but still `(if …)’ is not a funlhs
09:43:09 * hackagebot parconc-examples 0.4.4 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  https://hackage.haskell.org/package/parconc-examples-0.4.4 (SimonMarlow)
09:43:24 <ski> ltcmelo : however, i'd also like `if' (and `case') at the declaration level as well (conditional declarations. however all branches should bind the same identifiers)
09:43:40 <ski> ltcmelo : it's currently not a `funlhs', sure
09:43:54 <ski> i'm just imagining a more general pattern language
09:43:54 <ltcmelo> ski: does this help you (since you can’t access the page)? funlhs ::= 
09:44:04 <ltcmelo> sorry, hit enter, retyping..
09:45:07 <ski> (the point with the `if' at declaration level above would be that `...' should be evaluated once, not every time both `f' and `g' are called, nor once for `f' and once for `g')
09:45:20 <ski> (oh, and also it's more concise)
09:45:27 <ltcmelo> ski: I suspect that I understand your point, but I think other gramar rules would cover that. this one in particular must realy match a `funlhs’. the rule is `funlhs ::= var apat {apat} | pat varop pat | (funlhs) apat {apat} ‘
09:45:50 <ltcmelo> ski: your `(f . g) x = f (g x)’ would match it
09:45:58 <ltcmelo> s/your/your example
09:46:12 <ski> i suppose i'm not sure why there's brackets in the last alternative there
09:46:22 <leshow> is there anyway to make a helper function local to a parent functions multiple branches
09:46:52 <leshow> for example: something (Pat a) = cmp a; something (Patt b) = cmp b; where cmp a = ...
09:47:05 <ski> @let data Person = MkPerson {name :: String,age :: Int} deriving Show
09:47:06 <lambdabot>  .L.hs:161:1: error:
09:47:07 <lambdabot>      Multiple declarations of ‘Person’
09:47:07 <lambdabot>      Declared at: .L.hs:158:1
09:47:08 <leshow> so cmp is available to all the branches of something
09:47:58 <ski> @kind Person
09:48:00 <lambdabot> *
09:48:15 <ski> (ok, fixed it)
09:48:55 <dmwit_> nate_b_: GHC can derive `Functor`.
09:49:08 <ongy> in general?
09:49:13 <ski> @type let merge MkPerson {name = n0,age = a0} MkPerson {name = n1,age = a1} = MkPerson {name = n0 ++ n1,age = a0 + a1} in merge
09:49:15 <lambdabot> Person -> Person -> Person
09:49:27 <dmwit> nate_b_: So, `{-# LANGUAGE DeriveFunctor #-}; data Foo a = Foo a | Bar | ... deriving Functor`
09:49:30 <dmwit> ongy: yes
09:49:43 <ski> .. oh
09:49:53 <ski> sorry, i misread the rule
09:50:04 <dmwit> nate_b_: Then you will have `fmap :: (a -> b) -> Foo a -> Foo b`, assuming it can be implemented at all in a law-abiding way.
09:50:21 * ski was thinking it was talking about record syntax. on closer inspection, that's obviously not the case
09:50:45 <nate_b_> dmwit: I did not know Functor was derivable.  That's perfect!  Thank you.
09:51:25 <ski> ltcmelo : so it's just claiming that you can add redundant brackets in the definiens (aka `funlhs' here)
09:51:33 <ski> er, s/definiens/definiendum/
09:51:45 * ski shouldn't confuse the terms ..
09:52:08 <ltcmelo> ski: I guess so
09:52:09 * ski has forgot ltcmelo's question ..
09:52:45 <ski> @type let f ((x)) = x in f
09:52:47 <lambdabot> t -> t
09:52:52 <ltcmelo> ski: what would be the point/benefit of that syntax
09:52:55 <ski> (you can already add redundant patterns in an `apat')
09:53:06 <nate_b_> dmwit: Really, really perfect.  Deleting so much boilerplate right now...
09:53:27 <ski> ltcmelo : the obvious point is to allow `(f . g) x = f (g x)' (and also allows more)
09:53:47 <ltcmelo> ski: sure, this one I got
09:54:03 <ltcmelo> ski: after you mentioned ;-)
09:54:25 <ski> sometimes i like to emphasize that i'm thinking of a curried function as one which returns a new function
09:54:32 <ltcmelo> ski: one case is enough to make it worth
09:54:40 <ski> so i might write `(f x y) z = ..x..y..z..' to emphasize this
09:54:46 <ski> e.g. say we have
09:54:54 <ski>   f :: X -> Y -> T
09:55:03 <ski> where `T' is actually a type synonym for a function type
09:55:03 <ltcmelo> ski: that’s actually an interesting argument
09:55:29 <ski> so, to emphasize that the "extra" argument `z' here comes from `T', i might define `f' like this
09:55:52 <ski> another version would be something like
09:55:59 <ski>   map :: (a -> b) -> ([a] -> [b])
09:56:11 <ski>   (map f) [   ] = ...
09:56:12 <ski>   ...
09:56:23 <ski> where i'm already adding redundant brackets in the type signature, for emphasis
09:57:19 <ski> ltcmelo : "one case is enough to make it worth" -- yes, but i think they could have made the `(f . g) x = f (g x)' case work, without *too* much of a hassle, without allowing this more general case
09:57:52 <ski> (but i'm happy that they did allow it. though really i'd prefer it if it was `(funlhs) {apat}' rather than `(funlhs) apat {apat}')
09:58:49 <ski> ltcmelo : .. another possible motivation would be some variant of "message dispatching syntax"
09:59:14 <ski> (my term)
09:59:44 * ski just noticed the page has responded now
10:00:38 <ltcmelo> ski: I think that  `(funlhs) {apat}’ would lead to nasty ambiguities with the rule `apat ::= …’
10:02:25 <ltcmelo> ski: in fact, it would lead to at least one ambiguity: `apat ::= (pat)’ where pat derives through `apat ::= (pat)’
10:02:54 <ltcmelo> so there would be two derivations for a function with no parameters
10:03:39 <ski> hm, yes, because of `decl' possibly being `(funlhs | pat) rhs'
10:03:43 <ltcmelo> I mean `apat ::= var ‘ above
10:04:07 <ski> (though if there's no parameters, then it's syntactically not a function declaration)
10:04:18 <ltcmelo> yes…
10:04:58 <ltcmelo> although, from a imperative programming perspect, would behave like one, that’s actually how I’m modeling it in my tool
10:05:25 <ltcmelo> instead of modeling an immutable var, I let it be a no-arg function
10:05:40 <ski> that's an implementation issue
10:05:43 <ltcmelo> the binding corresponds to the return
10:05:47 <ltcmelo> sure, it is indeed
10:05:56 <ski> every function in Haskell takes exactly one argument
10:06:05 <ski> (otherwise it's not a function)
10:06:30 <ltcmelo> yes
10:07:17 * ski ponders how one'd need to rephrase the grammar, in order to allow it, but avoid the ambiguity
10:08:21 <ski> hm, i suppose the simplest would be to explicitly allow outer grouping with brackets in `decl' (and the other similar syntactic categories)
10:09:10 * ski idly wonders why it's `var' instead of `pat' in `cdecl' and `idecl'
10:09:45 <ski> (otherwise one'd just define `lhs ::= (funlhs | pat) | ( lhs )', i think)
10:10:38 <ltcmelo> ski: don’t you need names in that case?
10:11:16 <ltcmelo> either varsym or varid? those from cdecl and idecl are not top-level
10:11:56 <ltcmelo> they belong to the class, I don’t see how you could match patterns there...
10:12:03 <ski> i don't see why i shouldn't be able to do `instance ... where (foo,bar) = ...'
10:12:30 <ski> (where `foo' and `bar' would be methods of the corresponding type class)
10:13:29 <ltcmelo> hm… ok
10:13:49 <ski> (of course, one could imagine doing silly things like `True = ...', but then `...' would simply not get evaluated, as usual)
10:14:06 <ski> > let True = False in True
10:14:08 <lambdabot>  True
10:16:34 <int-e> it's irrefutable!
10:17:02 <phadej> > let !True = False in True
10:17:04 <lambdabot>  *Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern !True
10:17:28 <phadej> > let !True = 1 == 0 in True
10:17:30 <lambdabot>  *Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern !True
10:17:33 <int-e> actually... that error doesn't make sense to me.
10:18:37 * int-e thought the "irrefutable pattern failed" can only occur if something that was bound irrefutably is later forced... but nothing is bound here, on the surface. So how is the let !foo = bar in ... translated?
10:19:05 <int-e> > let x@True = False in x `seq` True
10:19:07 <lambdabot>  *Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern x@True
10:19:31 <int-e> like that, maybe?
10:19:48 <NickHu> Can someone help me with this type error? This transformer stack is giving me a headache
10:19:50 <NickHu> http://lpaste.net/231259
10:19:55 <int-e> > case True of False -> True -- in contrast to this
10:19:57 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
10:20:07 <ski> in that case, the error message wasn't satisfactorily translated back along the code transformation ..
10:20:22 <athan> is constant-space transcoding... possible?
10:20:54 <lyxia> NickHu: why are you using pure
10:21:03 <int-e> athan: I suspect you need to elaborate that question.
10:21:12 <NickHu> because that gave me a less scary error than when I didn't lyxia 
10:21:17 <lyxia> do { pure stuff ; rest } is equivalent to rest
10:21:26 <lyxia> pure is discarded
10:21:34 <athan> int-e: Sure :) I mean between two different bit encodings, like base16 and base64 for instance
10:21:55 <athan> but, without using bits at all, strictly using polynomials of the bases, and modular arithmetic
10:22:15 <athan> I'm trying to unfold while I fold, but I'm losing information
10:22:27 <lyxia> NickHu: that approach doesn't seem to work very well with transformers.
10:22:37 <NickHu> mm
10:22:43 <athan> if I foldr the character values together with `base^n * c`, then I get a "total value"
10:23:03 <athan> which I can deconstruct with `quotRem`
10:23:04 <lyxia> NickHu: so, what's the error if you remove pure
10:23:16 <NickHu> I updated the paste :)
10:23:30 <athan> but, the trick is, I _can't_ deconstruct via quotRem _while_ I'm folding
10:23:59 <athan> because the `quot` and addition of polynomials is all convoluted or something
10:24:07 <absence> is there something like scastie.org for haskell?
10:24:10 <athan> int-e: shoot I hope this makes sense
10:24:13 <lyxia> NickHu: it's complaining that there is no EitherT in your stack
10:25:04 <NickHu> The thing is, Handler is supposed to be a type synonym for EitherT ServantErr IO
10:25:15 <lyxia> Ah.
10:25:48 <athan> > let b = 2 in snd $ foldr (\c (n,acc) -> (n+1, acc + (b^n * c))) 0 [1,1,1]
10:25:50 <lambdabot>  error:
10:25:50 <lambdabot>      • Could not deduce (Integral a0)
10:25:50 <lambdabot>        from the context: (Num (a, b), Num b, Integral a)
10:25:55 <athan> erm
10:26:02 <lyxia> NickHu: but the EitherT layer won't go through runSqlPErsistMPool because it returns an IO
10:26:20 <NickHu> Hmm, I thought that might be the case
10:26:33 <athan> > let b = 2 in snd $ foldr (\c (n,acc) -> (n+1 :: Int, acc + (b^n * c) :: Int)) 0 [1,1,1]
10:26:35 <lambdabot>  error:
10:26:35 <lambdabot>      • No instance for (Num (Int, Int)) arising from the literal ‘0’
10:26:35 <lambdabot>      • In the second argument of ‘foldr’, namely ‘0’
10:26:39 <athan> >< sorry one sec
10:26:40 <NickHu> Is there a way of lifting the runSqlPersistMPool into the EitherT layer?
10:27:18 <athan> > let b = 2 in snd $ foldr (\c (n,acc) -> (n+1, acc + (b^n * c))) (0,0) [1,1,1]
10:27:20 <lambdabot>  7
10:27:36 <athan> that's where I'm building the representation
10:27:43 <athan> then to deconstruct it:
10:28:25 <lyxia> NickHu: the only solution I see is to remove the EitherT layer, apply runSqlPersistMPool, and wrap it back.
10:29:01 <NickHu> How would I do that?
10:29:22 <ski> > let b = 2 in foldr (\c rec n -> rec (n+1) + b^n * c) (\_ -> 0) [1,1,1] 0
10:29:24 <lambdabot>  7
10:30:36 <ski> > let b = 2 in foldr (\(n,c) acc -> acc + b^n * c) 0 (zip [0 ..] [1,1,1])
10:30:39 <lambdabot>  7
10:31:11 <athan> > let b = 2; go c | c <= 0 = [] | otherwise = c `mod` b : go (c `div` b) in reverse $ go 7
10:31:13 <lambdabot>  [1,1,1]
10:31:16 <lyxia> NickHu: let me annotate it. What's the type of addHeader BTW?
10:31:22 <athan> > let b = 2 in snd $ foldr (\c (n,acc) -> (n+1, acc + (b^n * c))) (0,0) [1,0,1,0]
10:31:25 <lambdabot>  10
10:31:28 <athan> > let b = 2; go c | c <= 0 = [] | otherwise = c `mod` b : go (c `div` b) in reverse $ go 10
10:31:30 <lambdabot>  [1,0,1,0]
10:31:35 <athan> see, this works fine
10:32:00 <lyxia> NickHu: you're using EitherT and not ExceptT, right?
10:32:01 <athan> but the trick I'm trying to figure out is how to stream it
10:32:05 <NickHu> lyxia: https://www.stackage.org/haddock/lts-7.1/servant-0.8.1/Servant-API-ResponseHeaders.html
10:32:14 <EvanR> what is the name of that thing where you can compute on encrypted states without decrypting them
10:32:14 <NickHu> To be honest I'm not entirely sure
10:32:19 <athan> instead of hoping I have enough space in my accumulator (10 and 7 in these cases)
10:32:59 <EvanR> homomorphic computing or something
10:33:15 <int-e> > foldr (\c rec n m -> if n == 3 then m : rec 1 c else rec (n+1) (m + c*2^n)) (\n m -> [m]) [1,0,1,1,1,0,0,1,1,1] 0 0
10:33:17 <ski> athan : one base being a divisor of the other ?
10:33:17 <lambdabot>  [5,3,6,1]
10:33:34 <athan> ski: Nope :)
10:33:47 <athan> I want to handle arbitrary bases
10:33:51 <int-e> athan: honestly, I probably just wouldn't try to use any fold or unfold.
10:34:10 <NickHu> lyxia: Ooh my documentation says that Handler is ExceptT ServantErr IO
10:34:13 <athan> int-e: What would you try?
10:34:14 <ski> athan : MSD-first or LSD-first ?
10:34:16 <athan> I'm forced to use Ints here :\
10:34:26 <NickHu> Maybe I was reading outdated documentation before
10:34:30 <athan> ski: I could go either way
10:34:53 <athan> I was using a foldr in this case because the strings are naturally MSD-first
10:35:07 <ski> athan : my feeling is that LSD-first could work, but that MSD-first wouldn't, in the general case
10:35:18 <harwiltz> Hello all. I have defined a type as type Phasor a = (a,a,CoordSyst) and I want to have it displayed in a custom way by default, if that makes sense. I think I want to do some instance Show (Phasor a) where... but I get an error on (Phasor a) in that line.
10:35:19 <EvanR> i wonder if theres a way to have some ciphertext and then multiple keys, each key gets a particular plaintext view
10:35:40 <int-e> athan: write a function [Int] -> Int -> Int -> [Int], where the first argument is the list being consumed, the second contains a numerical value for some bits, and the third keeps track of how many bits are currently known. Whenever the third argument exceeds the chunk size of the output encoding, the function can produce one output element.
10:35:41 <athan> yeah :\ I'd see myself holding on to an array of values to-be-given-their-SD to collapse at the end with MSD
10:36:02 <Zemyla> Is there anything like a TraversableT typeclass?
10:36:10 <athan> int-e: That's where I'm at :\
10:36:32 <athan> I can't figure out how I could "remove" a (least) significant digit without borking the polynomial
10:36:50 <athan> herm, sorry everyone. Thank you for your help
10:36:58 <athan> I must boil this problem it seems
10:37:00 * ski isn't sure what polynomial athan is thinking about
10:37:07 <lyxia> NickHu: are you also not using userId?
10:37:28 <NickHu> No, I'm not, but eventually I might, that's why the binding is there
10:37:29 <athan> ski: b^n*c_n + b^n-1 * c_n-1 + ... + b^0 * c_0
10:37:33 <ski> ok
10:37:34 <NickHu> The effect is necessary though
10:37:38 <athan> as a representation of the characters. The folding we were doing
10:38:43 <lpaste> lyxia annotated “No title” with “NickHu” at http://lpaste.net/231259#a231336
10:38:46 <harwiltz> I'm getting 'Illegal instance declaration for 'Show (Phasor q)' (All instance types must be of the form (T t1 ... tn)
10:38:50 <harwiltz> Not sure what that means
10:39:12 <int-e> athan: note that you're in trouble if the two bases (16 and 64 in your example) can't be written as powers of the same base (2 in this case, or 4 if you like)
10:39:21 <athan> Zemyla: You mean something like `embed` from mmorph?
10:39:31 <lyxia> harwiltz: is Phasor a type synonym
10:39:35 <athan> int-e: Why is that?
10:39:41 <ski> int-e : which is a special case of one being a divisor of the other one, which athan said they didn't want to assume
10:39:43 <Zemyla> Like it has traverseT :: (Traversable f, TraversableT t) => (Traversable (f t) => t f a -> r) -> r?
10:39:54 <harwiltz> lyxia: Oh shit, that's what that meant. I have type Phasor a = (a,a,CoordSyst)
10:39:59 <harwiltz> I'll try something else
10:40:58 <harwiltz> lyxia: I tried instance Show (a,a,CoordSyst)... but now I'm getting a slightly different error
10:41:07 <int-e> athan: because then, usually, every input digit affects the lowest output digit
10:41:20 <harwiltz> CoordSyst is defined: data CoordSyst = Rectangular|Polar
10:41:24 <ski> Zemyla : is `f t' well-kinded ?
10:41:38 <Zemyla> ski: Whoops, I meant t f.
10:41:45 <athan> Zemyla: traverseT :: (Traversable f, TraversableT t) => Applicative z => t f (z a) -> z (t f a) ?
10:41:55 <int-e> athan: (usually... what I wrote is true if the two bases are coprime, and sometimes true even when they have common factors)
10:41:57 <lyxia> harwiltz: that's areather bad idea  because there is already an instance of Show for tuples
10:42:02 <ski> Zemyla> :k t
10:42:07 <athan> int-e: ahh hmm
10:42:43 <harwiltz> lyxia: Ok, so my best bet is to just create a function to display it?
10:43:01 <athan> well shoot
10:43:05 <ski> harwiltz : i'd advice that, yes
10:43:07 <athan> so I guess this is a hard problem :x
10:43:11 * hackagebot atl 17072 - Arrow Transformer Library  https://hackage.haskell.org/package/atl-17072 (MatthewFarkasDyck)
10:43:12 <harwiltz> ski: Ah, ok. Thanks
10:43:50 <athan> holy wat? atl...
10:43:57 <ski> harwiltz : "I want to have it displayed in a custom way by default" generally would imply "Don't use `Show'" then
10:44:50 <ski> harwiltz : `Show' is for rendering a value as a string representing a *Haskell* expression (that when evaluated, in the relevant environment, will yield an equal value. also being able to use `Read' to get the same value is good)
10:45:20 * ski . o O ( "nahuatl" )
10:45:24 <int-e> athan: this is the reason why we don't have, for example, a base80 encoding. (Actually there is a base92, but it's really a base8192 with the digits then represented in base92)
10:45:38 <harwiltz> ski: What I meant was, say I instantiate a Phasor, change it a few times, and then type its name in ghci, I would like it to show something else rather than the standard tuple notation
10:46:01 <ReinH> Don't use a tuple
10:46:05 <int-e> > 92^2 >= 8192
10:46:08 <lambdabot>  True
10:46:31 <NickHu> lyxia: http://lpaste.net/231259
10:46:37 <harwiltz> ReinH: What else can I use? Sorry for dumb question
10:46:42 <NickHu> Now it's complaining I have an EitherT rather than an ExceptT
10:46:49 <ReinH> A data type
10:46:50 <NickHu> So I guess left is the wrong function to use...
10:46:55 <athan> int-e: Yeah, I'm using base58 :\
10:47:07 <harwiltz> ReinH: I'll have to look into that, thanks
10:47:13 <lyxia> NickHu: indeed
10:47:35 <harwiltz> Alright thanks guys. Laptop is about to die
10:47:37 <lyxia> NickHu: throwE
10:47:48 <ski> (soon, there'll be Hackage packages with documentation written in aymara as well ..)
10:48:25 <NickHu> Great! It compiles :D
10:48:34 <lyxia> hah
10:49:05 <NickHu> I have the line liftIO . flip runSqlPersistMPool pool $ do as the first line of all of my handlers
10:49:20 <NickHu> Do you think I should switch them all? I don't really understand this transformer stack too well
10:50:03 <lyxia> NickHu: if the "do" part does not use ExceptT it's fine
10:50:29 <int-e> athan: okay then it'll only be constant space in the sense that you typically have upper bounds on the encoded numbers.
10:50:59 <NickHu> Is there any sort of notable efficiency difference though?
10:51:20 <NickHu> Or is one a preferrable style?
10:52:54 <lyxia> NickHu: You can't really compare them. In the thing I wrote the do block has type EitherT ServantErr (... IO) ...
10:53:56 <lyxia> NickHu: and in your other functions, if they compile, the type of the do block is just (... IO) ...
10:54:10 <athan> eff. I hit the upper bound on my accumulated value really quickly
10:54:26 <athan> I can't transcode 32 bit characters for instance :\
10:54:30 <athan> er 33
10:54:47 <NickHu> I see
10:55:20 <NickHu> I understand what a monad transformer is, and how they work, but is working with a large transformer stack something you just get used to?
10:55:59 <athan> NuckHu: Yeah, for me at least
10:56:07 <athan> I just let mtl mash them all together
10:56:07 <lyxia> I think so.
10:56:20 <athan> foo :: (MonadBanana m, MonadTomatoe m) => ...
10:56:22 <lyxia> yeah mtl can help you manage complexity
10:56:52 <lyxia> somewhat. Persistent typeclasses are kinda scary
10:56:59 <athan> MonadDepravity m =>
10:57:01 <NickHu> How do you mean?
10:57:09 <NickHu> I've not used mtl much
10:57:13 <Wizek> Do you guys ever find yourself with having to interrupt a let block with bindings in a do block? e.g. `do { let { f = ... }; b <- f ...; let { c = b ... } }` It's bugging me. Do you know of a way to keep the lets in one block even if some of them depend on the binds?
10:57:41 <NickHu> Isn't the idea to have typeclasses to have a family of monads to do something, like MonadIO is a typeclass of IO-like monads?
10:57:41 <ski> Wizek : abstract on `b'
10:58:15 <lyxia> NickHu: instead of a big transformer stack, mtl style consists in using typeclass constraints on an abstract monad to give access to the features provided by various layers of your stack
10:58:16 <ski> Wizek : `do {let {f = ...; c b = b ...}; b <- f; ...}'
10:58:20 <athan> NickHu: mtl typeclasses additionally induct over the recursive monad stack to find the effect you're looking for
10:58:36 <athan> so MonadLogger can fetch LoggingT
10:58:44 <athan> or MonadReader can fetch the ReaderT in your stack
10:59:03 <athan> but generally, there can only be one [tm] monad per effect
10:59:12 <NickHu> How does that stop them from being nested into a huge stack?
10:59:19 <ski> `mtl' also assumes you'll never want to have e.g. more than one `StateT' layer in your monad stack
10:59:20 <athan> er, not generally, currently* (in mainstream mtl code)
10:59:34 <athan> NickHu: It doesn't
10:59:40 <athan> you have to be clever to manage that :)
10:59:42 <ski> (e.g. `StateT s0 (ContT o s1 (StateT s1 m))')
11:00:00 <athan> like some people build out a set of accessors and stuff
11:00:16 <ski> NickHu : it doesn't, but it makes it simpler (in first-order cases) to access the individual layers
11:00:44 <athan> { runDatabaseAction :: forall m. MonadDatabase m => m a -> IO a, ... } for each of your effects, then you just use the runner instead of the mtl typeclass lookup
11:00:51 <NickHu> Oh can you do something like (MonadLogger m, MonadReader m) => m a which will accept LoggingT (Reader a) and ReaderT (Logging a)?
11:00:58 <ski> yes
11:01:15 <ski> (though it's not clear whether the one you didn't had in mind will do anything sensible there)
11:01:27 <ski> (unless they commute, of course)
11:02:44 <NickHu> Does the type inference just "give you the right one" at the end though?
11:02:45 <ski> (for this reason, i'd prefer to manage an ordered sequence of effect descriptions. preferably they should be accessible by (custom) names, rather than by the particular `mtl' class used)
11:02:49 <NickHu> When it comes to using it etc.
11:03:10 <ski> NickHu : it gives you the *only* matching one (and forbids you from trying to have more than one)
11:03:32 <NickHu> Yeah, that's kinda what I was expecting.. That's pretty cool
11:03:57 <ski> (if you try to have more than one, then you're back to using `lift')
11:04:45 <NickHu> Do you need to lift if you manually specify the type you want?
11:05:58 <Unicorn_Princess> so like, how does pattern matching values work for types not part of the Eq typeclass?
11:06:33 <NickHu> Unicorn_Princess: Because you're matching on types not values
11:06:42 <jle`> Unicorn_Princess: haskell tries to resolve what constructor was used to create the value
11:06:55 <jle`> @let data Foo = Bar Int | Baz String
11:06:56 <lambdabot>  Defined.
11:07:02 <ski> NickHu : manually, how ?
11:07:16 <jle`> > case (Bar 10) of Bar i -> i + 10; Baz s -> length s
11:07:16 <ski> NickHu : using `mtl', no
11:07:18 <lambdabot>  20
11:07:38 <jle`> Unicorn_Princess: the value (Bar 10) was created using the 'Bar' constructor, so it matches on the Bar i pattern :)
11:07:40 <ski> Unicorn_Princess : `Eq' isn't involved in the picture at all
11:07:50 <jle`> and yeah, note that my 'Foo' type was not an instance of Eq
11:07:56 <Unicorn_Princess> huh. makes sense, thanks
11:08:03 <jle`> so it doesn't use Eq
11:08:09 <ski> Unicorn_Princess : in fact, instances of `Eq' would typically be defined, through pattern matching
11:08:24 <ski> @src [] (==)
11:08:24 <lambdabot> []     == []     = True
11:08:24 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
11:08:24 <lambdabot> _      == _      = False
11:09:02 <NickHu> Doesn't that need x and y to be part of the Eq typeclass too?
11:09:24 <jle`> @let instance Eq Foo where Bar x == Bar y = x == y; Baz x == Baz y = x == y
11:09:26 <lambdabot>  Defined.
11:09:30 <ski> note that the latter use of `==' in the middle defining equation there is a recursive call. however, `x == y' is not a recursive call. it calls `(==)' for the *element* type)
11:09:30 <ReinH> x and y have the same type, and yes.
11:09:54 <ski> NickHu : yes, it's `instance Eq a => Eq [a] where ...'
11:09:55 <NickHu> Yes
11:10:00 <jle`> Unicorn_Princess: i implemented (==) for my type using pattern matching there :)
11:10:00 <ReinH> Eq a => Eq [a]
11:10:16 <ski> jle` : forgot the failing case :)
11:10:20 <jle`> aw
11:10:25 <jle`> :'(
11:10:35 <athan> I wonder what homomorphisms over the act of deriving instance would look like
11:11:03 <ski> athan : "deriving instance" is typically an ad hoc process ..
11:11:37 <truth-about_psyc> Truth :                 "You have no idea how cruel psychiatry is.
11:11:37 <truth-about_psyc> ... This is really a battle between good and evil."
11:11:37 <truth-about_psyc> Psychiatrist Peter R. Breggin,
11:11:51 <ski> truth-about_psyc : .. do you have a Haskell-related question or comment ?
11:12:01 <geekosaur> no, this is repeated spam
11:12:03 --- mode: ChanServ set +o geekosaur
11:12:08 <truth-about_psyc> Ski ...... Help me
11:12:09 --- mode: geekosaur set +b *!*50f68805@*.com/ip.80.246.136.5
11:12:10 --- kick: truth-about_psyc was kicked by geekosaur (truth-about_psyc)
11:12:19 <athan> or homomorphisms over expressions or something :s
11:13:35 --- mode: geekosaur set -o geekosaur
11:24:44 <tokmaster78> hi
11:25:18 <dmj`> tokmaster78: hi
11:25:37 <tokmaster78> any proposals for gui programming ?
11:25:47 <dmj`> tokmaster78: proposals?
11:26:03 <tokmaster78> dmj`, suggestions
11:26:05 <schell> tokmaster78: what platform are you targeting?
11:26:09 <dmj`> tokmaster78: ah, web gui programming or desktop?
11:26:24 <tokmaster78> dmj`, schell , Linux Desktop
11:27:14 <schell> tokmaster78: i’m pretty sure there are GTK bindings
11:27:32 <schell> or you could go with opengl, but you have to write your own
11:27:36 <NickHu> gtk2hs
11:27:41 <NickHu> Looks like a nightmare though
11:27:43 <schell> (your own gui lb)
11:27:45 <NickHu> But so is using gtk
11:28:10 <puregreen> how can I write a custom Formatting formatter? basically I have a newtype and I want to have something like «node = "[" % build . getNodeId % "]"»
11:28:17 <schell> if you’re okay with experimental gui stuff (very experimental) i’ve got a small imgui library going backed by opengl
11:28:26 <EvanR> tokmaster78: so, coincidentally i am looking at a quick desktop gui solution
11:28:30 <Tuplanolla> If you just want to make interactive animations, Gloss is a good idea, tokmaster78.
11:28:34 <EvanR> tokmaster78: i found this thing, nw.js
11:28:51 <Tuplanolla> I don't know about proper interfaces though.
11:29:02 <EvanR> with ghcjs, you could dump your haskell code into that and get a webkit environment
11:29:07 <tokmaster78> I want to write a visualization for AI algorithms
11:29:26 <EvanR> that gives you canvas, webgl, or whatever js graphics libs
11:29:27 <NickHu> EvanR: Javascript desktop applications are so horrible though
11:29:38 <EvanR> i know atom is horrible, but hypothetically .......
11:29:45 <NickHu> tokmaster78: The haskell diagrams package is great apparently
11:29:57 <EvanR> diagrams is great for static images
11:30:03 <NickHu> I hate how popular node has become
11:30:16 <EvanR> supposedly it can do animated diagrams which would be like... a killer app and a half
11:30:19 <tokmaster78> libghc-gtk-dev
11:30:29 <tokmaster78> ubuntu : libghc-gtk-dev
11:30:35 <EvanR> GTK+...... 
11:30:37 <schell> tokmaster78: here is a small example of my imgui, just in case you get adventurous! (https://github.com/schell/odin/blob/master/app/MapMaker.hs#L223)
11:30:41 <EvanR> haskell or not, its not going to be pleasant
11:31:07 <maerwald> EvanR: I used the gif interface once
11:31:10 <NickHu> EvanR: exactly lol
11:31:13 <maerwald> it's rather painful
11:31:21 <NickHu> I think there's supposed to be a fltk interface which isn't terrible
11:31:22 <maerwald> because you need everything pure -.-
11:32:01 <EvanR> i really want to make animated diagrams
11:32:03 <EvanR> somehow
11:32:13 <EvanR> pretty sure i would be rich
11:35:16 <NickHu> Not really haskell related, but figured I might as well ask incase there are some webdevs in here
11:35:30 <NickHu> What HTTP code should I return if someone tries to POST create something that already exists?
11:36:16 <phadej> NickHu: 409 Conflict
11:36:18 <tokmaster78> okay I use gtk
11:36:24 <phadej> Indicates that the request could not be processed because of conflict in the request, such as an edit conflict between multiple simultaneous updates.
11:36:31 <Tuplanolla> You should at least take a look at Gloss, tokmaster78.
11:36:46 <Tuplanolla> See if it fits your needs.
11:36:52 <NickHu> phadej: Okay cool, any headers I ought to send back? The reason I asked is because stackoverflow seems to have 10 different opinions but the question is from 2010
11:37:13 <tokmaster78> Tuplanolla, yeah not too bad
11:37:25 <dmj`> NickHu: are you trying to update the record, or is this an anomaly
11:37:33 <phadej> NickHu: read thru answers, and judge them yourself. Cannot really comment.
11:37:34 <NickHu> dmj`: It's an invalid request
11:38:00 <phadej> NickHu: e.g. you can just return 400 Bad Request too
11:38:30 <akegalj> I have installed ghcjs with stack but can't figure out how to compile library with it. Cabal file contains `library` but I don't know where is it compiled. 
11:38:35 <EvanR> i would go with 400 just to keep it simple
11:38:48 <akegalj> Has anyone have experience with stack + ghcjs?
11:40:47 <muyfine> is there a short cut in lens for something like this? criteria <- (^. sPassFailCriteria) <$> (^. iScenario) <$> fromDataFile inputData
11:40:50 <dmj`> akegalj: sure
11:41:13 <NickHu> What's the difference between the Link and Location HTTP headers?
11:42:57 <ReinH> jle`: I got Wadler's blessing to write some exercises for his monads paper!
11:43:37 <EvanR> the god father of monads
11:43:59 <NickHu> What paper?
11:44:06 <ski> (is Moggi the holy spirit, then ?)
11:44:21 <EvanR> lol
11:44:48 * ski . o O ( Leibniz' monadology )
11:44:53 <akegalj> dmj`: I have simple example that exports one functions to javascript...  http://lpaste.net/231600  when I do `stack build` everything finishes ok, but I can't figure out where the lib is installed
11:45:41 <dmj`> akegalj: you need to define an executable section it seems
11:46:04 <sssilver> Hey guys, I know several programming languages reasonably well (Python/Swift/Java/Rust/old C++) and I know some Haskell as in I can write simple programs in in, but my knowledge is purely syntactic, and I struggle designing practical programs from scratch that do useful things. What should I read/see/hear/do to overcome this?
11:46:18 <akegalj> dmj`: :/ what if we intend to import this function and just call exported functions ?
11:46:26 <Desu> sssilver: just write more code
11:47:10 <Desu> also http://dev.stephendiehl.com/hask/
11:47:16 <NickHu> sssilver: Read World Haskell might be suitable for you, but it is 8 years out of date
11:47:20 <lyxia> NickHu: Location says where you can find the stuff you're looking for, Link points at related stuff that you might be interested in.
11:47:32 <dmj`> sssilver: read/write more haskell code and think of novel ways to apply what you've learned to practical problems.
11:47:38 <NickHu> lyxia: Should you give a Location on a 409 Conflict?
11:48:17 <EvanR> sssilver: attempt to write a program in haskell, become frustrated and bash your head against the wall until you get an epiphany, repeat
11:48:57 <dmj`> akegalj: that's fine, importing things from library and running them in an executable is ideal
11:49:02 <lyxia> NickHu: I don't know, sorry.
11:49:28 <NickHu> No problem, I think I'll just moan about why the request failed in the response body
11:49:47 <EvanR> good
11:49:48 <NickHu> Got to say, servant makes doing web dev bearable
11:49:53 <EvanR> many APIs dont tell you why it 400ed
11:49:57 <alercah> NickHu: if you're trying to create something that already exists, I would give a 409 Conflict. Using a Location header is not defined for 409 Conflict so I'd avoid it
11:50:01 <dmj`> NickHu: preach
11:50:10 <alercah> RFC 7231 is your friend
11:50:11 <NickHu> alercah: yup that's the approach I'm gonna go for
11:50:16 <sssilver> I guess I have several problems. One, is it idiomatic to define something as a function if it's only being invoked once from once place and will probably never be invoked from any other place?
11:50:30 <EvanR> yes
11:50:32 <dmj`> any Generics masters online?
11:50:40 <EvanR> sssilver: you could also put it in a where clause
11:50:46 <alercah> NickHu: you could also give 303 See Other
11:51:05 <alercah> but that depends on whether you want to make it a genuine error or just say "Oh, I have that already, look here."
11:51:11 <NickHu> I think I'll go for the 409 - it really should never happen
11:51:29 <tokmaster78> http://pastebin.com/vYxE7Zdm
11:51:32 <NickHu> dmj`: Oh god that stuff is hell
11:51:41 <EvanR> if it doesnt matter, stick to more basic codes like 400 which more things are probably expecting to handle
11:51:56 <EvanR> on the other hand, it doesnt matter
11:52:18 <lyxia> Generics <3
11:52:31 <lyxia> dmj`: of the GHC kind?
11:52:33 <alercah> EvanR: if your code doesn't handle an unknown 4XX error like a 400, it's broken
11:52:41 <EvanR> welcome to the entire internet
11:52:51 <NickHu> lol
11:52:54 <dmj`> lyxia: yes
11:53:03 <dmj`> NickHu: heh
11:53:16 <NickHu> I'm not a web dev, so I'd rather do things the "correct" way and not care about compatability ;)
11:53:17 <int-e> Can Haskell break the internet?
11:53:35 <EvanR> 409 for the sake of it when its probably not even going to matter... just seems like a bikeshed
11:53:48 <lyxia> dmj`: well now I'm curious about your question if you have one
11:53:54 <dmj`> lyxia: trying to do something complex
11:55:38 <akegalj> dmj`: I am watching compiled code for binary and I don't get it how I can call js_callback from javascript in this example http://lpaste.net/231600
11:55:45 <akegalj> dmj`: but thank you anyway
11:55:48 <dmj`> lyxia: I'm trying to construct a parser for a type using its generic rep. and a type-level DSL
11:56:52 <tokmaster78> http://pastebin.com/vYxE7Zdm can anyone halep me with this error ?
11:56:58 * ski misses the old `faq' command in lambdabot
11:57:33 <EvanR> i think they removed it because two years ago someone discoverd a thing haskell cannot do
11:57:56 <geekosaur> tokmaster78, I think you need to use "on"
11:58:03 <EvanR> they should have just attached "except that" to the bot message
11:58:16 <dmj`> akegalj: I think your Callback should be defined in test_callback
11:58:29 <dmj`> akegalj: I'd check ghcjs-dom source code for the correct way to specify that, or luite's posts
11:59:33 <tokmaster78> geekosaur, no sure
12:00:10 <Denommus> have you guys heard about websharper?
12:00:43 <dmj`> Denommus: yea
12:02:04 <Denommus> dmj`: do you know if there's any similar project for Haskell?
12:03:08 * geekosaur is trying to dig it out but buttonClicked is an event id and you use on to register a handler for the event
12:03:17 <akegalj> dmj`: I am looking at that, thankx
12:03:25 <dmj`> Denommus: I think reflex-dom probably
12:04:10 <Denommus> dmj`: that only covers the front-end :-/
12:05:19 <NickHu> http://lpaste.net/231650
12:05:24 <NickHu> What's the idiomatic way of fixing this?
12:05:30 <NickHu> Where type Username = Text
12:05:45 <dmj`> Denommus: what does websharper do on the server?
12:06:11 <lyxia> NickHu: encode to ByteString
12:06:23 <shapr> sharpr
12:06:25 * shapr cackles
12:06:40 <dmj`>  (err409 {errBody = "User " <> userUsername usr <> " exists"})’
12:07:09 <dmj`> Data.Text.Encoding.decodeUtf8 (userUserName usr)
12:07:26 <dmj`> why make the username ByteString?
12:07:33 <Denommus> dmj`: websharper allows you to compile your code to either backend or front-end with some directives, and you can even share code and values between them
12:07:47 <NickHu> dmj`: It's a Text, not a ByteString
12:07:48 <geekosaur> hm, this stuff looks out of date
12:07:55 <dmj`> oh :) it is ByteString
12:08:03 <dmj`> just ignore me
12:08:04 <dmj`> heh
12:08:12 <EvanR> because names are all in ASCII obv
12:08:21 <geekosaur> thought things like onClicked had been replaced by a general on function. maybe they undid it in the wake of Data.Function.on...
12:08:28 <dmj`> Denommus: you can share types on client and server with ghcjs
12:08:34 <dmj`> EvanR: :) 
12:08:55 <ReinH> (sharing values between a client and a server is literally what clients and servers are designed to do)
12:10:01 <Denommus> dmj`: ah, yes, I have setup something like that. But what is lacking is the shared values. Like a reactive Behavior that you use in both sides and gets translated to a websocket, for instance
12:11:00 <Denommus> ReinH: ok, but can you abstract that sharing away in your code, or do you need to manually make requests and create responses? :P
12:11:00 <geekosaur> tokmaster78, so it looks like the deprecated forms onButtonClicked and onDestroy still exist and can be used. and tutorials all seem to still use them
12:12:58 <dmj`> Denommus: interesting, how does it handle disconnects?
12:13:13 <geekosaur> woops
12:13:24 <geekosaur> guess they fell out of channel
12:14:10 <rribeiro> Hi! I want some help on using QuickCheck to test a function on a length-indexed list (a.k.a. vectors).
12:14:19 <Denommus> dmj`: good question, I don't know. That looks like a use-case for exceptions
12:14:35 <rribeiro> My trouble is that GHC is complaining about a constraint that has an ambiguous variable
12:14:36 <cocreature> rribeiro: what exactly do you need help with? do you have some code to illustrate your problem?
12:14:39 <ski> @type vector  -- rribeiro ?
12:14:41 <lambdabot> Arbitrary a => Int -> Gen [a]
12:15:13 <rribeiro> cocreature: I have put the code on the following gist: https://gist.github.com/rodrigogribeiro/8708eb2a71a64b192f37f1c0b6b60281
12:15:23 <Denommus> dmj`: I'm only asking this because I'm considering getting a solution like that together, but I don't want to reinvent the wheel if someone have already started it
12:15:31 <cocreature> rribeiro: could you add the error message?
12:15:41 <rribeiro> cocreature: of course
12:15:44 <NickHu> err409 {errBody = "User " <> Data.Text.Lazy.Encoding.encodeUtf8 (TL.fromStrict $ userUsername usr) <> " exists"}
12:15:54 <NickHu> This is pretty horrible, is there really no better way of doing this?
12:16:27 <Denommus> NickHu: lenses would make it a little prettier, but not completely pretty
12:16:39 <Denommus> NickHu: you have a problem with string concatenaton, right?
12:16:52 <rribeiro> cocreature: I've updated the gist with the error message
12:16:57 <NickHu> It's more needing all this conversion stuff from Text to lazy ByteString
12:18:34 <dmj`> NickHu: check out
12:18:37 <dmj`> @packages string-conversions
12:18:37 <lambdabot> http://hackage.haskell.org/package/string-conversions
12:18:37 <cocreature> rribeiro: you need to add a type signature in the call to quickCheck
12:18:51 <ski> rribeiro : why do you have `Show' in the context of those instances ?
12:18:51 <cocreature> rribeiro: e.g. quickCheck (toList_correct :: Vec Z Int -> Bool)
12:18:53 <dmj`> you just us the 'cs' function and it converts automatically
12:19:18 <cocreature> rribeiro: if you intend to test it for multiple lengths that’s going to get tricky
12:19:26 <Denommus> NickHu: why don't you import qualify Data.Text.Lazy.Encoding?
12:19:58 <rribeiro> cocreature: the problem is that it will fix the 'length' of the vector
12:20:00 <NickHu> what should it be? TLE? lol
12:20:15 <rribeiro> cocreature: is there a way to generate vectors of arbitrary length?
12:20:20 <geekosaur> @tell tokmaster78 https://www.stackbuilders.com/tutorials/haskell/gui-application/ is how modern gtk2hs worked, but for the older form you wanted onButtonClicked and onDestroy, I think
12:20:20 <lambdabot> Consider it noted.
12:20:25 <cocreature> rribeiro: yeah, I’m currently thinking about if there is a way to generate vectors of arbitrary length
12:20:54 <Denommus> NickHu: yeah, probably
12:21:10 <rribeiro> ski: Well, I've put all these Show constraints in a moment of despair trying to solve this error message... :)
12:22:03 <dmj`> ...that feeling when your types check after 5 hours of trying...
12:22:24 <tdammers> Do, or do not. There is no trying.
12:22:25 <erisco> "why does it work now?"
12:22:32 <cocreature> dmj`: unsafeCoerce? :P
12:22:35 <tdammers> erisco: done much php lately?
12:22:45 <erisco> tdammers, none, why do you ask?
12:22:57 <tdammers> because you mention the "why does it work now" effect
12:23:14 <dmj`> cocreature: haha :P shhh
12:26:01 <cocreature> rribeiro: hm sorry I can’t come up with a solution right now
12:26:16 * ski always disliked that "no trying" quote
12:26:23 <cocreature> and that’s pretty embarrassing
12:26:44 * erisco laughs at cocreature
12:26:48 <rribeiro> cocreature: No problem! I realize that this is not an easy problem... In fact, it a simplification of something that I'm working on
12:27:30 <cocreature> erisco: stop laughing and find a solution :)
12:28:03 <erisco> never used quickcheck before, sorry
12:29:02 <cocreature> I wonder if it’s actually impossible because you need full dependent types for it but I’m sure about it
12:31:09 <erisco> just try it with some lengths of your choosing
12:32:24 <isthatit> I'm not sure how you're supposed to use Data.Aeson to parse JSON accurately. For example I want 1.0 a float, not a scientific number. Because once it's a scientific number, it's consider as an integer.
12:32:37 <EvanR> if you need full dependent types, isnt that technically possible in haskell, by moving your entire problem into the type level?
12:32:47 <EvanR> and some weird tricks to get runtime values 
12:33:03 <joe9> isthatit: tried fromIntegral ?
12:33:09 <cocreature> EvanR: what weird trick do you use for getting the random values at the typelevel?
12:33:24 <NickHu> EvanR: I read something about singleton that is used to abuse types
12:33:26 <joe9> isthatit: or, just define the data type to be Double or Float.
12:33:29 <EvanR> coincidentally i was just doing that ;)
12:34:10 <NickHu> https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/
12:34:13 <cocreature> my first idea was to first generate random numbers indicating the size of the vector and then calling the function at the appropriate type but you don’t get a type out of it
12:34:17 <dmj`> EvanR: use TH to generate the types X-)
12:34:26 <NickHu> I think kinds and types are the same thing now in GHC or something
12:34:41 <EvanR> you implement a random number generator at the type level, and encode a seed into the type. then make sure never to forget the type-level history of the use of that generator
12:35:21 <cocreature> that’s a more work than I’m willing to put into this :P
12:35:41 <dmj`> type RandomIO = (reify (unsafePerformIO (runIO randomRIO)) :: Nat)
12:35:44 <isthatit> joe9: I just want a parser that returns an (Either Int Double). Depending on the underlying json string. "1.0" -> Right 1.0 ; "1" -> Left Int
12:35:50 <isthatit> joe9 I dunno if it makes sense
12:36:00 <geekosaur> isthatit, Scientific is not an integral type, it sounds like you're doing something wrong
12:36:23 <geekosaur> like trying to extract its components instead of using an appropriate conversion
12:36:49 <mizu_no_oto_work> isthatit: json doesn't distinguish between floats and ints, right?  Since Javascript doesn't have ints.
12:37:09 <isthatit> geekosaur, I'm trying to do like python would do: loads("1.0") -> float(1.0), and loads("1") -> int(1)
12:37:38 <isthatit> but with Data.Aeson, it just parses it at as a Number
12:37:50 <dmj`> EvanR: type-level RNG...
12:37:55 <isthatit> without preserving what's the json string underneath
12:38:11 <mizu_no_oto_work> isthatit: Is this to maintain compatibility with an external json-consuming service?
12:38:23 <isthatit> mizu_no_oto_work, correct
12:38:47 <EvanR> dmj`: random numbers are too important to be untyped
12:39:00 <geekosaur> python would be doing it wrong, as nobody anywhere guarantees that "1" in JSON is an integral vs. a float which happens to not have anything after the decimal point. that's part of why aeson uses Scientific
12:39:48 <dmj`> :) 
12:39:51 <tdammers> isn't JSON kind of underspecified wrt numbers?
12:39:55 <geekosaur> yes
12:39:57 <isthatit> well, you can debate on who's doing right or wrong. My concerned is how do manipulate the underlying string representation
12:40:03 <isthatit> my concern*
12:40:19 <isthatit> s/how do/how to/
12:40:21 <geekosaur> that's the point. aeson is punctilious about this, regardless of what incorrect assumptions other JSON implementations might make
12:41:57 <mizu_no_oto_work> isthatit: I think your best option might be to make an internal fork Aeson, and change the parser and replace Scientific with Integer and Float in the JSON AST
12:42:05 <tdammers> the way I see it, reasonable choices are a) choose a data type that can represent both integers and floats accurately (enough), b) argue that all numbers are floats in JavaScript, and thus treating all JSON numbers as floats
12:42:23 <erisco> maybe you really do not need to distinguish 1 and 1.0
12:42:30 <tdammers> however, IIRC, a JSON implementation is supposed to treat 1.0 and 1 as the same thing
12:42:50 <tdammers> so in that sense, Python *is* doing it wrong
12:43:13 * hackagebot mikrokosmos 0.2.0 - Lambda calculus interpreter  https://hackage.haskell.org/package/mikrokosmos-0.2.0 (mroman42)
12:43:15 * hackagebot ginger 0.3.5.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.3.5.0 (TobiasDammers)
12:43:16 <geekosaur> possibly you want http://hackage.haskell.org/package/aeson-1.0.1.0/docs/Data-Aeson.html#g:3
12:43:17 <tdammers> (just like it would be wrong to use different string-like types depending on whether or not a JSON string contains anything non-ascii)
12:43:29 <erisco> if you need more specific and precise number encodings, maybe do not use JSON
12:43:49 <geekosaur> it sounds like they are working with some already existing json service
12:43:50 <tdammers> JSON can represent arbitrarily precise numbers
12:44:01 <tdammers> many implementations, however, cannot
12:44:22 <erisco> yes but it seems the problem here is you may want different types of numbers
12:44:36 <erisco> integers, floats, maybe scientific numbers, complex numbers, who knows
12:44:38 <tdammers> sure, but JSON doesn't really cater for that
12:44:52 <EvanR> next aeson should make a choice that absolves rails's decision to treat empty array in json as nil
12:45:23 <EvanR> (in the request decoder)
12:45:43 <allenj12> how do you import things in project.cabal in stack? I have a comma seperated field, with 'writert, trans' at the end but I get this error msg "
12:45:43 <allenj12> "
12:45:53 <erisco> rational numbers
12:45:56 <allenj12> woops copy past didnt work
12:46:00 <tdammers> well, unityped languages are somewhat excuses as long as the incorrect representation behaves like the correct one in further usage
12:46:15 <mizu_no_oto_work> erisco: it seems likely that they're interoperating with a legacy system that does something different with ints and floats; "rewrite it from scratch" is likely not a particularly practical suggestion.
12:46:19 <tdammers> idk what Ruby does when you try to get the length of nil, or the nth element
12:46:30 <isthatit> json does care for this
12:46:40 <allenj12> trans must match -any, but the stack configuration has no specified version
12:46:40 <allenj12>  
12:46:59 <geekosaur> json better not care for it, because javascript doesn't *have* integers
12:47:33 <erisco> okay, well, test if the result is a whole number. If it is, assume it is Integer, otherwise assume it is Float
12:48:19 <isthatit> erisco, I can't because I want the string "1.0" to be a float
12:48:21 <EvanR> erisco: json is decidedly not any rational number, because of 1/3
12:48:21 <tdammers> http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf
12:48:30 <tdammers> wow, this is ridiculously underspecified
12:48:49 <erisco> isthatit, what is the significance of it being float?
12:49:06 <EvanR> tdammers: method length not defined for nil error
12:49:41 <EvanR> whats wrong with scientific?
12:49:42 <tdammers> EvanR: then nil is not OK for empty arrays, and Ruby is wrong
12:50:06 <EvanR> tdammers: i know its wrong, and a pain in the ass. but they have "reasons"
12:50:13 <tdammers> EvanR: I believe isthatit's problem is that they want to build logic based on whether 1 is represented as 1 or 1.0 in the JSON
12:50:18 <EvanR> and from the issue description they cant fix it if they wanted to
12:50:51 <EvanR> 1 = 1.0 in the higher inductive type of json ;)
12:50:57 <tdammers> I'm beginning to think that the whole "we only have Rails" thing isn't all there is to it as far as Ruby's lack of mainstream traction is concerned
12:51:00 <EvanR> so no
12:51:32 <tdammers> well, I just read the JSON spec again (see above), and it is painfully silent on the question whether 1 and 1.0 should be considered equivalent or not
12:51:33 <erisco> the JSON grammar is simple, you could write a Parsec parser for it
12:51:46 <EvanR> moral json
12:51:55 <tdammers> erisco: you could probably write a Read parser for it
12:52:24 <tdammers> considering the JS roots, it would make sense to say they should be considered equivalent
12:52:48 <EvanR> assuming "json" has only one number type, called number, then it seems highly unlikely that this number type has two different "1" values, which ive never heard of ever
12:52:54 <erisco> I wonder if any legacy systems exist where leading or trailing zeroes are significant
12:53:20 <geekosaur> unixy stuff still likes to treat leading 0 as octal...
12:53:40 <allenj12> is there a way to include the latest version of a package in your project.cabal?
12:53:45 <EvanR> 2.00000000... = 3 for very large number of zeros
12:54:03 <pikajude> as we all know, the number gets bigger the more zeroes you have
12:54:13 <EvanR> infintesimally
12:54:21 <Unicorn_Princess> erisco: in both C and C++, a leading zero indicates the number is in octal
12:54:27 <mizu_no_oto_work> pikajude: 1.0 < 1.00?
12:54:28 <tdammers> PHP too
12:54:37 <EvanR> 1.0 is not >= to 1.00 ;)
12:54:44 <EvanR> we report you decide
12:54:48 <pikajude> mizu_no_oto_work: I was thinking more on a salary basis
12:54:54 <tdammers> I bet the PHP parser accidentally treats a lone 0 as octal, and nobody ever noticed, because hey look, it works
12:55:07 <erisco> I mean specifically with JSON
12:55:10 <pikajude> if I've done my math correctly, octal 0 is the same as decimal 0
12:55:16 <tdammers> pikajude: that is the joke
12:55:21 <EvanR> same with 01
12:55:33 <pikajude> oh, oops
12:55:35 <mizu_no_oto_work> And 007
12:56:08 <pikajude> i was hoping someone could double check my math
12:56:26 <erisco> if some systems distinguish between 1 and 1.0 in JSON I then wonder what other assumptions they make, such as leading and trailing zeroes
12:56:36 <EvanR> name a system that does
12:56:56 <tdammers> erisco: I've seen systems that rely on the ordering of entries in JSON objects
12:57:03 <Zemyla> Why don't the types in GHC.Generics have Eq1/Ord1/Read1/Show1 instances?
12:57:08 <tdammers> actually, it was YAML, but the same logic applies
12:57:13 <EvanR> oh geez, actually, they exist
12:57:28 <erisco> tdammers, people assume objects have order in JavaScript, so much so it was added to the spec
12:57:47 <tdammers> erisco: well, it explicitly doesn't hold in YAML
12:58:09 <EvanR> http://lpaste.net/231717
12:58:14 <tdammers> at some point, we were deploying to EngineYard, where deployments are scripted in Ruby
12:58:35 <EvanR> 123 is Fixnum, 123.0 is Float
12:58:42 <tdammers> so I thought, awesome, I can use a little Ruby script to parse our default config file, inject some stuff from EY-provided environment vars, and write it back out
12:58:45 <EvanR> were all fooked
12:58:50 <erisco> what is that? Ruby?
12:58:52 <tdammers> obviously things broke epically
12:59:10 <EvanR> json is the emperor who has no clothes
12:59:27 <NickHu> I wrote something that let me use aeson to parse "1", 1, and 1.0
12:59:34 <NickHu> https://github.com/NickHu/untest/blob/master/src/Untest/Parser.hs#L63
12:59:51 <tdammers> because Ruby stores YAML objects in hashmaps, which is 100% correct and to-spec, but our code wanted things to remain in the same order, which PHP's weird monster bastard data structures will do for you
13:00:12 <erisco> you mean arrays
13:00:21 <tdammers> that's what PHP calls them
13:00:30 <tdammers> for some reason that is entirely beyond me
13:01:13 <EvanR> no better name?
13:01:22 <EvanR> they are kind of defying characterization
13:01:47 <EvanR> if they had foresight they would have called them acme-php's
13:01:52 <allenj12> imports are confusing 
13:03:09 <erisco> it is simple, if an array has integer indexes then it behaves one way, and if it has other indexes it behaves another
13:03:17 <EvanR> clojure lets you use hashes as functions, i wonder why they dont get as much flak for this sort of conflation
13:03:30 <erisco> there is a convenient built in iterator
13:04:54 <EvanR> erisco: it is simple, its a container
13:05:13 <EvanR> sometimes, a context
13:06:27 <erisco> it denotes a function  Either String Int -> IO Dynamic  where using a non-existent index raises an error
13:07:13 <Rembane> Can't the php arrays have both numerical indexes and "other" indexes at the same time? Thus becoming somekind of strange ordered hashmap?
13:07:31 <erisco> they are generally ordered maps, yes
13:08:04 <ph88> tdammers, are you around ?
13:11:17 <mjhoy> Z
13:15:43 <Wizek> Anyone knows why this fails `[p| (a@b)@c |] $> runQ $> fmap ppr` while this `[p| a@(b@c) |] $> runQ $> fmap ppr` succeeds? (where ($>) = flip ($))
13:16:00 <ph88> what's |] even ?
13:16:14 <pigworts2> Can you put a constraint on a rank-2 type to constrain it to classes that have Num as a superclass (i.e Fractional, Floating)?
13:16:19 <Wizek> template haskell's quote
13:17:31 <geekosaur> ph88, that's a quasiquote [quoter| string |]
13:17:58 <ph88> Wizek, maybe because (a@b)@c doesn't follow the natural order of your data ?
13:18:04 <ph88> hi geekosaur 
13:18:11 <akegalj> dmj`: I figured it out finaly. Thanks for holding my hand
13:18:22 <dmj`> akegalj: for sure
13:18:29 <ReinH> Yes, (a@b)@c is an affront to god and nature. >_<
13:18:51 <geekosaur> but if that's a haskell pattern, (a@b)@c seems wrong
13:19:16 <geekosaur> as-patterns are name@expr not expr@expr
13:19:34 <Wizek> geekosaur, really? hmm
13:19:47 <Wizek> :t AsP
13:19:50 <lambdabot> error: Data constructor not in scope: AsP
13:20:09 <Wizek> > import Language.Haskell.TH; :t AsP
13:20:11 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
13:20:21 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17 first production of apat
13:20:24 * dmj` releases akegalj's hand
13:20:36 <pigworts2> Can you put a constraint on a rank-2 type to constrain it to classes that have Num as a superclass (i.e Fractional, Floating)?
13:21:44 <cocreature> pigworts2: are you looking for "f :: (forall a. Num a => a -> a) -> ()"
13:22:25 <NickHu> Can someone explain to me the purpose of quasiquotation?
13:22:31 <cocreature> that’s not quite what you seem to be asking but I don’t understand why you would want to constrain it to classes that have a specific superclass
13:22:32 <DavidEichmann> Is there a way to automatically SPECIALIZE functions?
13:22:50 <DavidEichmann> A ghc option or something?
13:22:59 <cocreature> DavidEichmann: if ghc is able to inline functions it will specialize them
13:23:10 <cocreature> DavidEichmann: so making sure that ghc can inline your function is often enough
13:23:27 <geekosaur> NickHu, originally it was a way to generate an AST by writing the Haskell code instead of having to write out the AST directly. it was extended to allow arbitrary quasiquoters that can parse whatever and generate an AST
13:23:43 <pigworts2>  cocreature: I mean like: forall a b. (b < Num, b a) => a -> a (with ConstraintKinds)
13:23:56 <NickHu> geekosaur: How is it different from `ordinary' TH?
13:24:17 <geekosaur> you're writing Haskell code instead of AST constructors?
13:24:24 <NickHu> ohhh I see
13:24:24 <Tuplanolla> The difference is that it's not horrible suffering, NickHu.
13:24:29 <NickHu> lol
13:24:41 <Wizek> geekosaur, oh yeah just noticed that `AsP :: Name -> Pat -> Pat` indeed takes Name as first arg and not Pat.
13:24:41 <cocreature> pigworts2: you can’t do that but tbh I also don’t get why you would want to do so
13:24:56 <geekosaur> pigworts2, typeclasses don't work that way. there aren't actually superclasses, so much as there are prerequisites
13:25:09 <cocreature> pigworts2: just knowing that b has Num as a superclass doesn’t give you anything that Num b wouldn’t give you
13:25:47 <joe9> uint32_t == Haskell's Word32, correct?
13:25:52 <lpaste> joobus pasted “Is it possible to parse multiple yaml documents from a single file?” at http://lpaste.net/231767
13:25:58 <hpc> joe9: yes
13:26:04 <joe9> hpc, Thanks.
13:26:12 <hpc> Word = unsigned, Int = signed, then the number is in bits
13:26:26 <tdammers> ph88: yo
13:26:35 <joobus> does anyone have experience parsing multiple yaml documents from a single file?
13:26:39 <hpc> if there's no number, it can be any size (within some limits) but with ghc it's the machine word size
13:27:43 <hpc> scientists are still working to determine if there is a Wordeger analogous to Integer
13:27:50 <hpc> the results are sure to shake the very foundations of haskell
13:27:52 * Clint shudders.
13:28:00 <ReinH> we'll get the scientists working on the tube technology immediately
13:29:04 <cocreature> hpc: I’m sure heidegger knows the answer
13:29:18 <Tuplanolla> Can you get mathematicians to call natural numbers wordegers without using violence?
13:30:11 <hpc> i have an idea for a new acme package
13:30:42 <ReinH> Asking a mathematician to do that is an act of violence in and of itself.
13:30:51 <soLucien> if i want to write unit tests
13:30:53 <verement> there's always Numeric.Natural.Natural
13:31:02 <soLucien> how to get my unexported functions under test?
13:31:04 <geekosaur> is it? just make it the foundation of some new formulation of number theory >.>
13:31:07 <soLucien> simply export out ?
13:31:09 <hpc> Data.Data.Data.Numeric.Natural.Natural
13:31:11 <soLucien> export all ?
13:31:24 <dagda1> any way I clean up the 2 similar conditions on lines on lines 8 and 11 of this https://gist.github.com/dagda1/a77716866b5fd3282dda3b10335b61d4
13:31:34 <soLucien> is there some cool pattern you guys use for that ?
13:32:59 <ReinH> dagda1: use `compare'
13:33:03 <ReinH> and pattern match
13:33:08 <ReinH> > compare 1 2
13:33:10 <lambdabot>  LT
13:33:31 <ReinH> also reduces the number of comparisons (potentially) performed
13:33:54 <ski> dagda1 : factor out the common `guess number attempt attempts' ?
13:34:01 <ReinH> soLucien: put them in a module called Whatever.Internal and export them
13:34:10 <ReinH> then import then in Whatever and your test
13:34:12 <ReinH> *them
13:34:28 <Tuplanolla> Check out `exposed-modules`, soLucien: https://hackage.haskell.org/package/vector-0.11.0.0/src/vector.cabal
13:34:44 <ski> dagda1 : .. if you wanted to, you could keep track of the nearest bounds the user has entered so far, and say "See above" instead, in case a guess is outside of that interval
13:35:19 <NickHu> Tuplanolla: Mathematicians can't even agree on whether 0 is a natural number or not
13:35:41 <ski> dagda1 : instead of `getLine' and `read', you could use `readLn' .. though better would probably be to not abort in case the parse fails
13:35:52 <ski> dagda1 : what is the point with comparing with `0' ?
13:36:18 <dagda1> ski I'm passing in 0 for the initial turn
13:36:42 <NickHu> soLucien: Are you sure you want to be writing unit tests instead of quickcheck tests though?
13:36:54 <NickHu> Haskellers generally only use unit tests for IO stuff
13:37:12 <ski> dagda1 : ok, then why not call `guess' directly from `numberGuess', instead of calling `turn' ?
13:37:36 <soLucien> NickHu i'm not so good with quickCheck synthax
13:37:42 <ski> dagda1 : also, did you mean to check whether `attempts' have reached zero, somewhere ?
13:37:43 <soLucien> and abstractions
13:37:46 <dagda1> ski yes, good point
13:37:56 <soLucien> so i would rather stick to something i know from imperative programming
13:38:01 <soLucien> namely unit tests
13:38:13 <NickHu> well, unit tests in Haskell are no picnic either..
13:38:35 <ReinH> they aren't?
13:38:46 <ReinH> I haven't had much trouble with them.
13:38:51 <NickHu> In my (limited) experience they are no easier than quickcheck
13:39:00 <shapr> I use QuickCheck or HUnit
13:39:03 <NickHu> But I rarely write "real code"
13:39:07 <ski> dagda1 : did you figure out the factoring of `guess number attempt attempts' in `turn' ?
13:39:16 <ReinH> quickcheck is pretty easy
13:39:22 <ReinH> once learned
13:39:23 <shapr> HUnit seems equally easy
13:39:24 <dagda1> ski yes, I've done that
13:39:37 <NickHu> ReinH: I still have to look up the quickcheck syntax every time though
13:39:44 <ReinH> *once learned*
13:39:44 <dagda1> ski guess number attempts attempts
13:40:10 <ski> dagda1 : so `guess number attempt attempts' occurs only once, in the body of `turn' ?
13:41:01 <NickHu> Yeah, I'm not saying it's impossibly hard either, more I need to read/use it more
13:41:11 <NickHu> Any good resources for quickcheck?
13:41:27 <NickHu> I remember I read some of the old documentation for it which has been around forever
13:41:32 <dagda1> ski actually no, sorry I've removed the | attempt == 0
13:42:03 <ski> well, don't be sorry for that
13:43:14 * hackagebot dictionaries 0.1.0.0 - Tools to handle StarDict dictionaries.  https://hackage.haskell.org/package/dictionaries-0.1.0.0 (zohl)
13:43:16 * hackagebot yesod-csp 0.2.1.0 - Add CSP headers to Yesod apps  https://hackage.haskell.org/package/yesod-csp-0.2.1.0 (boblong)
13:43:55 <ski> dagda1 : oh, just noticed that the `attempt' argument to `guess' is unused
13:44:42 <NickHu> woah the debian creator killed himself
13:47:19 <dagda1> ski I added this | attempts == 0 = putStrLn "You lose"
13:47:41 <ski> ok
13:47:47 <erisco> a poetic line of code
13:47:53 <dagda1> :)
13:48:15 * ski would probably use `attempts <= 0', out of defensive habit
13:49:07 <erisco> | otherwise = putStrLn ("unknown number of attempts" ++ show attempts)
13:49:29 * ski idly recalls writing a "guess the number" game on a programmable calculator, that would randomly move the secret number around a bit, as you got close enough to it
13:49:48 <erisco> 7 tries every time
13:50:21 <ski> > logBase 2 20
13:50:23 <lambdabot>  4.321928094887363
13:50:36 <erisco> > logBase 2 100
13:50:38 <lambdabot>  6.643856189774725
13:50:47 <ski> yeah, but it said `20' :)
13:52:36 <erisco> I am guessing an infinitesimal number between 1 and 1
13:53:08 <hpc> is it 0.99999 repeating?
13:53:18 <ski> that's a singleton, so the only infinitesimal number there is `1' itself
13:53:34 <NickHu> erisco: hyperreals..?
13:53:41 <ski> however, `{1 + x | x^2 = 0}', otoh ..
13:55:02 <nitrix> Curiously, why is newIORef not :: a ?
13:55:15 <ski> @type newIORef not
13:55:17 <lambdabot> error:
13:55:17 <lambdabot>     • Variable not in scope: newIORef :: (Bool -> Bool) -> t
13:55:17 <lambdabot>     • Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
13:55:27 <nitrix> What's the side-effect at play?
13:55:34 <ski> @type Data.IORef.newIORef not
13:55:36 <lambdabot> IO (GHC.IORef.IORef (Bool -> Bool))
13:55:50 <ski> nitrix : creating a new reference, which is distinct from any other reference
13:55:59 <ski> nitrix : think of it as incrementing a global counter
13:56:25 <nitrix> ski: Is this because IORef has an Eq instance that this guarantee is necessary ?
13:56:34 <ski> (recall `instance Eq (IORef a)' (*not* requiring `Eq a', not even looking at the contents behind the reference))
13:56:36 <erisco> I am thinking of a number between the md5 preimage of cfcd208495d565ef66e7dff9f98764da and c81e728d9d4c2f636f067f89cc14862c
13:56:37 <ski> yes
13:57:03 <ski> nitrix : well, it'd still be necessary, without the `Eq' instance
13:57:57 <ph88> tdammers, i made this in php which demonstrates what i would like to do in haskell with traversing https://paste.fedoraproject.org/437538/09323914/
13:58:13 <nitrix> ski: Would it break referential transparency if it was implemented with unsafePerformIO ?
13:58:19 <iphy> http://lpaste.net/231826 <- how would I do this?
13:58:56 <ski> nitrix : if `newIORef :: a -> IORef a', then `(newIORef x,newIORef x)' would be equal to `join (,) (newIORef x)', so `newIORef' would have to give the *same* `IORef a', when given an equal input
13:59:04 <ski> nitrix : yes
13:59:12 <iphy> I'm getting "NB: ‘DocDataType’ is a type function, and may not be injective"
13:59:38 <ski> nitrix : by "would be equal" i mean that contextual equality, not `(==)'
13:59:44 <ski> s/that //
13:59:56 <nitrix> ski: You run into the risk of having `(newIORef x, newIORef x)` getting memoized and having both be Eq equal even though they have their own references.
14:00:28 <ski> iphy : `data DocDataType f'
14:00:43 <nitrix> ski: So one would have to use INLINE and other nastyness. Do I understand this right?
14:01:30 <erisco> what's a program without a bit of risk involved
14:02:08 <iphy> ski: wow
14:02:10 <nitrix> erisco: Jokes aside, there's important work on my side behind these questions.
14:02:11 <magneticduck> nitrix: c4ca4238a0b923820dcc509a6f75849b?
14:02:11 <iphy> why?
14:02:27 <nitrix> magneticduck: What's that?
14:02:58 <ski> iphy : hm, or maybe an explicit type ascription would help
14:02:59 <erisco> magneticduck, correct
14:03:00 <magneticduck> I mean, the md5 preimage of it -- I'm playing guess-the-hash-number
14:03:16 <magneticduck> nitrix: sorry, wrong tab nick
14:03:34 <ski> nitrix : rather `NOINLINE' i suppose .. but it still breaks the declarative semantics
14:03:46 <nitrix> ski: Are you aware of something similar that'd allow newIORef to be pure? Presumably STRef, but with the extra constraint that you can have interchangeable `forall s. s` ?
14:04:55 <ski> nitrix : i'm not. i'm thinking it can't exist
14:05:00 <nitrix> Or has no such mechanism been developed so far, because, while mine works, it's very magical to say the least.
14:05:05 <ski> the effect lies in the "new" part of it
14:05:29 <erisco> you have to play with numbers on order of 10^15 or so before it becomes interesting
14:05:35 <nitrix> I was hoping to re-develop a little library that's more principled and uses good idioms rather than GHC hackery.
14:06:00 <ski> (and i don't know what you mean by "interchangeable `forall s. s`")
14:08:53 <nitrix> ski: At the foundation of my library needs to lie a system similar to the work previously done by SPJ on memoization.
14:09:33 <nitrix> ski: But even his solution used unsafePerformIO.
14:10:16 <nitrix> I think? Actually re-reading that paper would be nice.
14:11:12 <nitrix> Yeah, just checked. It is unsafePerformIO, but it's at the compiler level :/
14:11:18 <nitrix> I want to do memoization as a library.
14:11:51 * ski fails to see how that relates to removing `IO' from `newIORef'
14:12:07 <nitrix> ski: I simplified the scope c:
14:14:06 <magneticduck> nitrix: in Rust, programmers are forced to write 'unsafe' code that circumvents safety features in the language in order to product programs whose correctness we can be confident in but aren't permitted by the language; it's interesting to see that Haskell also has analogous situations here and there, where we essentially introduce "axioms" (fundamental properties that can't be implemented "safely" or
14:14:08 <magneticduck> efficiently) into the language 
14:14:19 <nitrix> http://hackage.haskell.org/package/memoize
14:14:22 <nitrix> "The library constructs pure memo caches without the use of unsafePerformIO. This technique relies on implementation assumptions that, while not guaranteed by the semantics of Haskell, appear to be true."
14:14:35 <nitrix> Apparently, work has been done in that area. I just need to look around.
14:15:07 <ski> @hackage MemoTrie
14:15:07 <lambdabot> http://hackage.haskell.org/package/MemoTrie
14:15:19 <ski> @hackage data-memocombinators
14:15:19 <lambdabot> http://hackage.haskell.org/package/data-memocombinators
14:15:23 <Ed___> Hey guys. If my function has an output type of IO (Int, Int) can I only have print followed by a tuple? 
14:15:27 <ski> &c.
14:15:37 <nitrix> ski: Those weren't good though, they had lookup tables.
14:15:41 <ski> ok
14:15:49 <Clint> Ed___: what?
14:16:12 <Rarrikins> Ed___: You can print whatever you want, as long as you eventually get to returning (Int, Int).
14:16:19 <Ed___> Ah. Thanks
14:16:29 <Rarrikins> Ed___: Printing itself returns (), so that won't be the last "step" anyway.
14:16:56 <magneticduck> I suppose the ultimate extension of language design is formal verification, where the job of the 'compiler' is to implement a formal spec written in math -- and that job can be done by humans in conjunction with computers, since it's often not trivial
14:17:19 <joe9> I want to call haskell functions from C. https://paste.pound-python.org/show/ow7IEKHl75XyUDLT2YXF/ is the state that I want to pass as an argument to the haskell function when called from C. Is that possible? Can haskell function pointers be interfaced between C and Haskell?
14:17:27 <Ed___> How unsafe is the IO monad?
14:17:35 <iphy> http://lpaste.net/231826 <- is there any way to derive Show for the DocDataTypes?
14:17:56 <Rarrikins> joe9: Haskell has a foreign function interface (FFI) for that. I haven't used it, but that's what you can search for.
14:18:05 <nitrix> Ed___: Why the monad particuliarly?
14:18:22 <iphy> can I require a Show instance to be defined for instance member types?
14:18:43 <joe9> https://github.com/joe9/lookup-keycode/blob/master/src/State.hs is the full source code of the module.
14:19:10 <ski> iphy : `StandaloneDeriving' ?
14:19:23 <ski> Ed___ : not at all
14:19:27 <Ed___> Somebody said if my funtion operates on the IO monad, that it "tags" the function as being impure and that it has some side effects
14:19:51 <nitrix> That a crude way to think of it.
14:19:55 <Ed___> that made me feel like its some kind of hack is best avoided
14:20:00 <ski> Ed___ : s/side effects/effects/
14:20:15 <Ed___> *that is best left avoided
14:20:21 <Rarrikins> Ed___: No, you should learn how to use it. You should also learn how to write pure functions.
14:20:55 <Rarrikins> Ed___: Then, you can apply the pure functions inside the IO code to do whatever.
14:20:56 <ski> (also s/being impure and that it has/having/)
14:21:07 <nitrix> If you avoid all I/O, you get a program that possibly do something, but cannot be interacted with.
14:21:17 <Ed___> thanks
14:21:19 <ski> (`IO' is as pure as the rest of Haskell)
14:21:38 <ski> however .. `IO' is still harder to reason about, so you should avoid it when not necessary, for this reason
14:21:51 <iphy> ski: yep, that works, thanks
14:21:55 <magneticduck> I suppose every language that has to both represent an implementation strategy and a specification is faced with a fundamental impossibility -- and the artifacts of this are either unsafety (generalized as "programs can be written that do no useful work") or inexpressiveness (generalized as "programs that satisfy a useful specification cannot be written")
14:22:21 <nitrix> Ed___: The only valid concern about IO is that it is too broad. It allows too much and makes it hard to reason about what the extent of the function go.
14:22:31 <Ed___> got it
14:22:40 <tdammers> yeah, it's definitely not a hack
14:22:58 <tdammers> think of IO as a pure type that represents effectful computations
14:23:10 <magneticduck> nitrix: what sort of subset of IO would you like?
14:23:13 <nitrix> Ed___: But it is not the daemon you described. It's not some tagging system, it's not a "hack", IO is actually pure from Haskell's standpoint.
14:23:18 <tdammers> using Haskell, we can take values of that type and combine them in a pure fashion
14:23:39 <magneticduck> it seems like it would be hard to divide it up more than ST, at least in a reliable way
14:23:48 <Ed___> with haskell being type-safe language. How can IO be pure given how broad it is
14:23:51 <nitrix> magneticduck: I don't think they can be classified, but if I had too, I'd use monad transformers.
14:24:13 <tdammers> Ed___: being broad and purity are orthogonal
14:24:13 <nitrix> magneticduck: e.g. NetworkableT, FileSystemableT or whatever names.
14:24:32 <magneticduck> nitrix: well, that would be possible if the OS were written in Haskell ;)
14:24:39 <Ed___> got it
14:24:43 <nitrix> People hate monad transformers on IO though. :(
14:25:20 <tdammers> Ed___: how it works is that we do not write "do this, then do that", we write "main is the action that consists of the getLine action bound to the function putStrLn, which is a function of String onto another IO action"
14:25:23 <EvanR> i resemble that remark
14:25:37 <tdammers> main = getLine >>= putStrLn
14:26:00 <tdammers> it literally reads "main is getLine bound to putStrLn"
14:26:39 <tdammers> that code itself is pure, in the sense that constructing (evaluating) main has no side effects
14:26:53 <tdammers> we just define an IO action in terms of other IO actions
14:27:03 <tdammers> however, *executing* said IO action isn't pure
14:27:08 <dmj`> Ed___: if you had a data type like, data Foo = Foo (IO ()) Int, then you could construct it, mkFoo = Foo (putStrLn "foo") 4; mkFoo :: IO () -> Int -> Foo; notice you defined IO purely, but you're not *in* IO
14:27:10 <Ed___> So is Haskell type-safe?
14:27:18 <magneticduck> Ed___: hehe, somewhat
14:27:24 <ski> Ed___ : a value of type `IO T' (for any type `T'), an `IO'-action, can be seen as a "recipe", a "list of instructions", for how to perform some I/O
14:27:30 <magneticduck> our type system is the best for miles around!
14:27:46 <hpc> it's not typesafe as far as you can perform unsafe type coercions
14:28:01 <ski> Ed___ : actually executing the instructions is conceptually not done by Haskell (but rather the run-time system, the context in which Haskell evaluates)
14:28:02 <Tuplanolla> You can imagine the runtime system performing one unsafePerformIO on main when the program begins, except it's more like safePerformIO in that context, Ed___.
14:28:03 <hpc> but it's typesafe in that if you do, you have a great big literal "unsafe" staring you down in your source code
14:28:11 <tdammers> Ed___: strictly speaking, no, not in the academic sense; but it's one of the strictest type systems in a real-world programming language I've ever seen
14:28:29 <ski> Ed___ : the cake is not the recipe. which is why an `IO String' is not a `String'
14:28:35 <hpc> and there are no implicit type coercions or typecasts or that sort of thing
14:28:44 <nitrix> Ed___: Type correctness is much more complicated than that is commonly referred to. In that regard, Haskell's type system does a terrible job, but it's probably much better overall than the more popular mainstream alternatives.
14:28:50 <Ed___> Looks like im going to have to save this chat lol
14:29:04 <EvanR> sometimes a safe language is defined as "instead of segfaults, you get dynamic type errors"
14:29:14 <EvanR> in haskell, you get segfaults sometimes, therefore its not safe
14:29:14 <tdammers> fsvo safe
14:29:34 <EvanR> instead of dynamic type errors
14:29:36 <tdammers> (btw., how do you make Haskell segfault without using FFI?)
14:29:57 <EvanR> use a library that is doing FFI wrong, thats one way
14:30:02 <Tuplanolla> I guess you can unsafeCoerce something suitable, tdammers.
14:30:03 <joe9> https://paste.pound-python.org/show/GxAWRMNtZomLnfFRN887/ I am trying to follow this tutorial https://wiki.haskell.org/Calling_Haskell_from_C
14:30:07 <EvanR> unsafeCoerce
14:30:18 <tdammers> ah, right, forgot about that little sucker
14:30:41 <Ed___> thanks guys. i got to get back to coding. really appreciate all the help. great community
14:30:54 <joe9> Ed___: check out HoTT
14:31:17 <Ed___> Homotopy?
14:31:19 <EvanR> the understand haskell you must first understand homotopy type theory
14:31:22 <Tuplanolla> Ed___: http://homotopytypetheory.org/book/
14:31:24 <EvanR> just kidding
14:31:37 <Ed___> ill bookmark it. thanks
14:31:43 <Tuplanolla> It's all fun and games until you reach chapter 2.
14:31:57 <nitrix> Isn't that the very specialized thery about isomorphisms?
14:32:09 <EvanR> equivalences
14:32:27 <nitrix> I see. It was brought up during my learning of category theory.
14:32:44 <nitrix> Should I dare to ask if homotopy is useful?
14:33:18 <geekosaur> well, it's a different formulation of type theory
14:33:28 <Rarrikins> Is homotopy type theory supposed to be learned after the book Types and Programming Languages?
14:33:28 <nitrix> Or phrased differently, have we seen practical uses resulting from the new theory yet?
14:33:42 <EvanR> theres a blog somewhere that claims that category theory and related discplines are useful for programming
14:33:44 <geekosaur> that ties it to existing mathematical concepts, which iirc has been an ongoing wart with type theory
14:33:53 <joe9> imho, set theory has issues and I do not think it can ever fit exactly with proof-based programming.
14:33:57 <geekosaur> not sure if it's practically useful though
14:34:28 <geekosaur> it's also still new enough that it might be asking a bit much to find examples of it making a difference
14:34:41 <EvanR> nitrix: hott led to cubical tt, which is actual software for doing proofs
14:34:45 <geekosaur> (and, is it yet accepted enough that anyone has actually tried)
14:34:53 <EvanR> and yt another type theory
14:35:59 <EvanR> we still dont have a nice version of rationals implemented with idris, for actual use , maybe the higher inductive way to do that is somehow better, at some point
14:36:09 <EvanR> in language X
14:36:52 <EvanR> you might come to think that many tasks in programming are tasks in math
14:37:01 <EvanR> then youll want math better than what you typically use for programming
14:37:06 <EvanR> which ime is almost none
14:38:25 <EvanR> antisymmetrically, the hott book claims that it is math better than you typically use for math
14:38:51 <allenj12> what is the differnce between the IO monad and the Control.Monad.IO.Class.MonadIO
14:39:21 <EvanR> MonadIO monads support liftIO
14:39:24 <EvanR> :t liftIO
14:39:26 <lambdabot> MonadIO m => IO a -> m a
14:39:40 <allenj12> but otherwise they are similar?
14:39:46 <EvanR> basically let you do IO in them, IO itself is a trivial instance of MonoidIO
14:39:48 <EvanR> MonadIO
14:39:54 <ski> `IO' is a type. `MonadIO' is a type class
14:40:15 <allenj12> gotcha
14:40:47 <ski> Rarrikins : depends on whether you're interested in programming languages or not
14:42:05 <allenj12> -
14:42:42 <Rarrikins> ski: Yeah, I'm interested in that.
14:43:15 * hackagebot exp-pairs 0.1.5.2 - Linear programming over exponent pairs  https://hackage.haskell.org/package/exp-pairs-0.1.5.2 (Bodigrim)
14:43:34 <hpc> allenj12: an example of another type that's an instance of MonadIO is Q, which is the template haskell monad
14:43:46 <hpc> allenj12: the MonadIO instance means you are able to perform haskell IO at compile time
14:44:18 <hpc> ... unless i am misremembering
14:45:18 <hpc> oh yes, i am remembering right, it's just not listed in the docs for some reason
14:45:28 <allenj12> lol :P gotcha
14:45:35 <ski> no, that's just a consequence of where `Q'-actions are allowed (in splices)
14:46:01 <hpc> ah, fair enough
14:46:12 <joe9> need some advice, please? I am writing a simpler xkb to lookup key symbols. I want to call the functions from wlc (a C wayland compositor). the C program sends state on each call to the library. My current state is  https://paste.pound-python.org/show/h8ec5vOlrWbdWS1C6xif/ . But, I am not sure if I can use function pointers when transferring state between C and Haskell
14:46:32 <hpc> but yeah, a good example anyway of the kind of thing that can be a non-trivial instance ;)
14:48:10 <{AS}> How does Haskell handle polymorphic IORef type safety issues?
14:48:28 <{AS}> ML has the value restriction as far as I remember, does Haskell have the same thing?
14:49:08 <allenj12> hpc: so liftIO takes a type and lifts it to an Monad.....MonadIO right?
14:49:36 <ski> {AS} : avoids it because `newIORef :: a -> IO (IORef a)', rather than `newIORef :: a -> IORef a'
14:49:48 <ski> no value restriction in Haskell
14:49:50 <allenj12> :type liftIO
14:49:59 <allenj12> :t liftIO
14:50:00 <lambdabot> MonadIO m => IO a -> m a
14:50:01 <{AS}> ski: but why would that not break things ?
14:50:06 <joe9> https://github.com/joe9/lookup-keycode/blob/master/src/State.hs is full codebam j
14:50:24 <ski> {AS} : you can't construct a polymorphic reference
14:50:40 <ski> ({AS} : .. unless you use `unsafePerformIO', of course)
14:50:54 <ski> (therefore `unsafePerformIO' entails `unsafeCoerce')
14:51:00 <{AS}> ski: Hmm, I am unsure why wrapping it in IO wouldn't allow me that
14:51:08 <{AS}> could you try explicating it a bit please?
14:51:34 <ski> {AS} : you can construct `forall a. IO (IORef (Maybe a))', but not `IO (forall a. IORef (Maybe a))'
14:51:38 <allenj12> so in a do block where we have x <- y, y has to be the same type if we do that multiple times correct?
14:51:50 <ski> {AS} : without the intervening `IO', those'd be the same thing
14:52:00 <{AS}> Ah I see
14:52:03 <ski> {AS} : you need the latter, to get a polymorphic reference
14:53:15 <Ed___> So I'm back guys... =/... In my code I have to do a putStr (show something) and then on a next line I have putStr " " and then i have to do putStr (show some_other_type) and then putStr "\n" Is there a more compact way of doing this? 
14:53:16 <{AS}> Thanks
14:53:33 <grantwu> can't you just
14:53:41 <Ed___> problem is I tried to put them all in a list and tried to mapM_
14:53:44 <Ed___> but they are diff types
14:53:47 <grantwu> putStr (show something ++ " " ++ show some_other_type)
14:53:58 <Ed___> like one is Int, another is [Int] another is [Char]
14:53:58 <ski> Ed___ : `do print something; putChar ' '; print some_other_type'
14:54:16 <Ed___> both solutions work great. thanks
14:54:21 <Rarrikins> Ed___: The last part can be done with putStrLn.
14:54:32 <ski> Ed___ : oh, well, not `print' for the first one. missed that you didn't want a newline there
14:55:02 <ski> Ed___ : another approach is `putStrLn (concat [show something," ",show some_other_type])'
14:56:10 <geekosaur> or mapM_ putStr [...]
14:56:30 <Ed___> tried that. problem was the list contained diff types
14:56:43 <geekosaur> not after show it doesn't
14:56:45 <ski> would work if you repeated the `show's
14:57:01 <Ed___> ah ok
14:57:36 <geekosaur> you can't factor the show out without introducing a type error, but you don't want to do show on the separating space anyway
14:57:50 <Rarrikins> putStrLn (show x ++ (' ':show y))
14:59:31 <allenj12> why cant I use liftM instead of liftIO, it seems liftIO is used for transformers, but arent transformers themselves monads?
15:00:11 <Rarrikins> allenj12: I think liftM merely lifts the function into the outermost monad. liftIO will go digging into the stack for the IO monad.
15:00:44 <allenj12> Rarrikins: yea looking at the type kinda confirms that, kinda weird naming
15:01:15 <c_wraith> liftM and liftIO have rather unrelated purposes. 
15:01:44 <ski> `liftIO' is more related to `lift'
15:01:58 <c_wraith> but they both are examples of doing the sanest thing possible with the type they have. 
15:02:09 <allenj12> c_wraith: yea im going through this example http://pastebin.com/txavYizJ really confused why liftIO is needed and what it actually turns to
15:02:38 <c_wraith> allenj12, I mean.. the type of liftIO basically says everything. 
15:03:08 <ski> allenj12 : it turns into a sequence of `lift's
15:03:17 <c_wraith> allenj12, it's for converting IO actions to actions in some more complex type that happens to build on top of IO
15:03:22 <allenj12> :t lift
15:03:23 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
15:03:50 <ski> how many `lift's depends on the "depth" of the "monad transformer stack"
15:04:00 <ski> in you case, it looks like just one
15:04:16 <c_wraith> you also have opaque types that implement MonadIO
15:04:24 <allenj12> ski: so could I replace liftIO with lift there?
15:04:26 <c_wraith> so lift isn't even available 
15:04:28 <ski>   lift :: IO a -> WriterT [(FilePath, Int)] IO a
15:04:31 <ski> allenj12 : yes
15:04:36 <geekosaur> the trick is, you derive MonadIO for transformers over MonadIO instances (most provided transformers already do this, so you only care about your own newtypes), and that lets liftIO expand to the necessary number of lift-s to reach the IO
15:04:55 <geekosaur> plus a degenerate instance of MonadIO for IO itself
15:05:08 <geekosaur> (instance MonadIO IO where liftIO = id)
15:05:20 <c_wraith> I thought we called that the base case. :P
15:05:23 <ski> (yes, that's a sequence of zero `lift's :)
15:06:55 <allenj12> ok 
15:08:25 <joe9> geekosaur: can you please help me with an FFI issue? I wrote a library in haskell that I want to call from C. I created the data type in Haskell. The C library just hands me a pointer to my State data type. Do I have to still define the data type in a C header file and use that for the haskell data type?
15:09:02 <geekosaur> you do, because C can't cope with Haskell values
15:09:11 <joe9> geekosaur:  for every call the C program calls library, it just  hands me a pointer (which I had previously provided it)
15:09:18 <geekosaur> (for one thing, they may be unevaluated thunks, not actual data values)
15:09:47 <geekosaur> and handing C a random pointer to Haskell data doesn't work because the Haskell value could move around if a gc happens
15:09:59 <joe9> geekosaur: 2 issues, for unevaluated thunks, I could just Vector Storable or Vector unboxed, correct?
15:10:17 <geekosaur> so you must marshal to a pinned Storable for C and unmarshal back to Haskell
15:10:28 <geekosaur> Storable yes, Unboxed no
15:10:37 <joe9> geekosaur: oh, this is my current data type
15:10:56 <joe9> geekosaur: The C library on start up calls teh haskell library with initState
15:10:58 <joe9> https://paste.pound-python.org/show/TVY3nUmL9AMpVV2K3ptM/
15:11:09 <joe9> geekosaur: where I return a pointer to the current State.
15:11:27 <joe9> geekosaur: and then for any further call from C, it provides that pointer.
15:11:56 <joe9> geekosaur: I can define the data type State in C . But, how do I go about the function pointers?
15:12:09 <joe9> geekosaur: Should I get the function pointers out?
15:12:23 <Ed___> Say I have a function `foo` that returns type IO(Integer) how can I set a variable in another function equal that foo's return? I get an error of unexpected types...
15:12:44 <joe9> geekosaur: and then have an integer and a lookup table from integer to a datatype that would have these function pointers?
15:12:49 <geekosaur> you need to use foreign export if they are to be called from C. if not, I think you can just use FunPtr
15:13:02 <fjawo> how could I compose an ADT constructor with a (:) operator in order to make a function that creates an ADT and adds it to a (given) list? 
15:13:05 <Ed___> It was actual type is IO (...) but expected type is (...)
15:13:26 <ski> Ed___ : show your code ?
15:13:31 <ski> fjawo : `(:) . Blah' ?
15:13:46 <Ed___> its sooo long... but ok... ill pinpoint the line. one sec
15:13:52 <geekosaur> but, I am not sure I'd pass that thing to C, but instead build a Map Haskell-side from a Storable value (say, CInt) to Haskell-side State values, and give C the CInt
15:13:54 <joe9> geekosaur: such as : So, having function pointers in the State datatype is not a big deal? I could just create the State data type in C and marshall/fill it with values from haskell?
15:13:55 <Rarrikins> Ed___: Usually, you run the pure function inside the IO.
15:14:12 <lpaste> Ed_ pasted “No title” at http://lpaste.net/231948
15:14:13 <joe9> geekosaur: oh, ok. That was what I was thinking. Makes perfect sense.
15:14:25 <Ed___> probllem is line 61
15:14:31 <geekosaur> if it's changeable, then you make it a Map CInt (IORef State) instead
15:14:56 <joe9> https://github.com/joe9/lookup-keycode/blob/master/src/State.hs geekosaur  is the full code if you are wondering.
15:15:02 <Rarrikins> Ed___: Don't use IO for debug prints
15:15:08 <ski> Ed___ : what is the variable you want to set, and what is the other function ?
15:15:13 <Ed___> they're not debug prints
15:15:30 <Ed___> line 61
15:15:33 <fjawo> ski: Oh, that's what I tried. I put "x = (:) . Blah" in the REPL and it said "parse error at ="
15:15:43 <ski> Ed___ : you already said that
15:15:44 <Rarrikins> Ed___: Don't put IO in pure functions like that. What you want to do is to do the pure booths computation and return what you should print.
15:15:45 <joe9> geekosaur: no it is not changeable from C or at runtime. It is just changeable at start up, maybe.
15:15:55 <fjawo> ski: erm, "parse error on input '='" to be precise
15:15:55 <geekosaur> fjawo, unless you have ghc8, you need a "let"
15:15:58 <ski> fjawo : oh, in the interactor you have to use `let' to define stuff
15:16:03 <Rarrikins> Ed___: Then, you do something like putStrLn (booths a b c d) or whatever.
15:16:08 <fjawo> Ohhh, I see, thanks guys!
15:16:34 <Ed___> But i can't do a putStrLn inside a function if its not IO (...) type
15:16:53 <joe9> geekosaur: Thanks a lot. That was very helpful.
15:17:04 <Ed___> I did it like that because I needed to print every step of the iteration of the algorithm
15:17:35 <Rarrikins> Ed___: You can do that with a list, since lists are lazy.
15:17:48 <Rarrikins> Ed___: You have booths return the data for every single line of the output.
15:18:48 <Rarrikins> Ed___: So, you'd have a bunch of (count, md, ac, mq, mq1) elements in a list.
15:19:04 <Ed___> I thought about doing that. But I took this approach instead..
15:19:09 <Rarrikins> Ed___: Then, inside IO, you'd get that list and start printing out the nicely-formatted output.
15:19:35 <Ed___> So, you can't set a variable equal to the result of a function who's return type is IO(...)?
15:19:54 * ski is still not sure what Ed___ meant by "set a variable equal to the result of a function who's return type is IO(...)"
15:19:59 <joe9> geekosaur: IORef, would it be maintained by haskell when haskell is used as a library?
15:20:14 <Ed___> foo :: Int -> IO (Int)
15:20:20 <Ed___> let x = foo 3
15:20:27 <joe9> geekosaur: I guess IORef works similar to garbage collection. haskell just does it even when called from C, etc.
15:20:35 <Rarrikins> Ed___: You can do that, but the type will be IO Int.
15:20:41 <Rarrikins> Ed___: The type of x, I mean.
15:21:14 <Ed___> so How is line 61 different in my code then?
15:21:19 <Ed___> http://lpaste.net/231948
15:22:18 <Ed___> because (ac, _,_,_,_) is not IO((_,_,_,_,_)) type..
15:22:30 <geekosaur> joe9, I don't understand the question. the IORef wouldn't be exposed to C, you'd still be sending the CInt. what you gain from the IORef is being able to update the State without having to rebuild the Map and ensure that anything that needs to see the updated value has it (this matters for things like callbacks, which you will care about when calling into Haskell from C)
15:22:30 <soLucien> how does Haskell know
15:22:35 <soLucien> which return to use?
15:22:43 <Rarrikins> Ed___: The IO type will be what the last line in the do block returns.
15:22:46 <fjawo> ski: the resulting type is a bit weird. :t Blah :: Int -> String -> Blah; but :t Compose :: Int -> [String -> Blah] -> [String->Blah]
15:22:59 <geekosaur> soLucien, type inference usually
15:23:37 <Ed___> So on line 74 returns (count, md, ac, mq, mq1) and on line 61 I "let (count, md', ac, mq', mq1) = ...)
15:23:55 <fjawo> is that supposed to be the correct type? I'm trying to use "compose 1 "string" []" but it gives me a type error
15:23:57 <geekosaur> if you are in a do block (or equivalently a chain of >>= and/or >>) then the monad must be the same across all calls, and that tells it what return to use
15:24:41 <Rarrikins> Ed___: Yes.
15:24:44 <Ed___> this is the error "Couldn't match expected type ‘(t, t1, t2, t3, t4)’                 with actual type ‘IO ([Bit], [Bit], [Bit], [Bit], Bit)’"
15:25:23 <Ed___> I can definetely just go without having a booths function, but I wanted to make it for simpicity in the main function
15:25:50 <joe9> geekosaur: my question was, C program call init, we give it a CInt and store the mapping (CInt -> State) in an IORef. Now, the C program takes over does something and calls the haskell program with the same CInt again. when the haskell function reads the IORef, it would find the previously stored (CInt -> State) mapping, correct? So, haskell is keeping that IORef somewhere even when the haskell program is not in use (stack,etc).
15:26:05 <soLucien> newtype SubsM a = SubsM {runSubsM :: Context -> Either Error (a, Env)}
15:26:31 <soLucien> is this the type of the SubsM ?
15:26:44 <soLucien> a function that maps a context to a Either ?
15:26:56 <soLucien> where the left is an error, and the right is a tuple ?
15:27:14 <geekosaur> joe9, why use an IORef there? the idea is that the mapping is static. you could store the State in an IORef if it needs to change, but the mapping from CInt to the (possibly in an IORef) State should be constant otherwise it's useless
15:27:32 <ski> Ed___ : tried replacing `let (count, md', ac, mq', mq1) = ' with `(count, md', ac, mq', mq1) <- ' ?
15:27:47 <ski> Ed___ : on line 61, i.e.
15:28:03 <Ed___> ski: that worked
15:28:14 <Ed___> whats the difference?
15:28:36 <ski> Ed___ : roughly speaking, `<-' "executes" the action to the right
15:28:46 <geekosaur> @quote /bin/ls
15:28:46 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:28:48 <ski> Ed___ : with `let x = act', `x' and `act' will have the same type
15:29:04 <geekosaur> IO ... is not the same as ..., it is an executable action that can produce a ...
15:29:06 <ski> Ed___ : with `x <- act', if `act' has type `IO T', then `x' will have type `T'
15:29:21 <ski> (Ed___ : this works for any monad in place for `IO'. .. but in your case, you had `IO' there)
15:29:21 <Ed___> Beautiful
15:29:59 <ski> Ed___ : still, whenever reasonable, it's nicer to avoid having stuff in `IO'
15:30:35 <ski> Ed___ : so i'd try and see whether Rarrikins' suggestion would work in your case
15:30:40 <Ed___> Next time I'll store the intermediary results in a list..
15:30:50 <joe9> geekosaur: as correctly pointed out by you, the function pointers in the state do not change. But, the modifier values change. I cannot treat the modifiers as constant. https://paste.pound-python.org/show/GZX7xW1ZAtt74s1TfnqZ/ . and, C does not read the state back from me. It just provides me a pointer to the state that I gave it when doing init.
15:31:15 <geekosaur> then you do not want the CInt to State mapping itself to be in an IORef
15:31:16 <lpaste> Ed_ revised “No title”: “No title” at http://lpaste.net/231948
15:31:17 <joe9> geekosaur: First call of C, Shift key is pressed, haskell program updates the modifiers and stores it in an IORef.
15:31:23 <geekosaur> you want Map CInt (IORef State)
15:31:29 <Ed___> Thanks ski and Rarrikins'
15:31:40 <Rarrikins> No problem.
15:32:57 <geekosaur> you can't even sensibly look up an IORef (CInt -> State), and it isn't what you think anyway (it's a function, and I can't see why you'd want to change it)
15:32:57 <joe9> geekosaur: another question, haskell program gets garbage collected when I use it this way, correct?
15:32:57 <geekosaur> it does, yes
15:32:57 <geekosaur> this is another reason to pass the CInt, you don't care and the C side of things doesn't care
15:33:15 <geekosaur> on the C side, it's an int, it doesn't change, it's not magic in any way
15:33:37 <joe9> geekosaur: my worry was that IORef would lose the value between C calls to the haskell program.
15:33:50 <geekosaur> the whole point of IORef is not to lose such things
15:33:56 <lpaste> Ed_ revised “No title”: “No title” at http://lpaste.net/231948
15:34:38 <joe9> geekosaur: ok, Thanks. I presume haskell somehow stores the IORef in a stack somewhere when it hands over control to the C program.
15:35:07 <geekosaur> well, you I guess need to arrange for the Map to be held somewhere across invocations from C, that might require the unsafePerformIO global hack
15:35:57 <joe9> geekosaur: oh, that was what I was worried about. Saving the haskell state between C calls as haskell program is not running a separate process.
15:36:00 <geekosaur> it's still better than trying to make C deal, unless you want to constantly marshal/unmarshal and pass back a new marshaled State to C wth each call
15:36:06 * ski . o O ( interesting word order )
15:36:31 <joe9> geekosaur: I agree. the IORef idea is a lot better. just want to get my head around the intricacies.
15:37:14 <geekosaur> it does become complex when you're driving it from the C end :/
15:38:27 <jchia_> I have some code defining 3 quantities representing distance, force and energy (energy = distance * force) and the arithmetic (.+, .-, .* ./, .%) operations I can do with them. I find it rather verbose. How can I simplify it? http://lpaste.net/231981
15:39:41 <jchia_> The user of this module can construct values of Force, Distance, Energy, and use the 5 operators I defined.
15:43:27 <allenj12> Im trying to do basic eight puzzle a* to get the hang of things, what is the data structure preffered if you need indexing and swapping?
15:50:41 <NemesisD> hi all, i'm trying to transport a cabal sandbox between 2 machines to cache the build. for both machines, cabal --version reports compiled using version 1.24.0.0 of the Cabal library but on build i get the Cabal version changed from Cabal-1.22.5.0 to Cabal-1.24.0.0
15:52:35 <NemesisD> i've blown away the sandbox and rebuilt everything and it still persists. maybe a cabal clean would do it?
15:53:53 <jchia_> allenj12: Without more specifics, since you have a 3x3 array, I would suggest using a 9-element vector
15:54:28 <geekosaur> NemesisD, Cabal-the-library lives in ghc's global package db
15:54:29 <jchia_> you could also use a good old list. since there are only 9 elements, the indexing cost for list is probably not terrible
15:54:55 <allenj12> jchia_: yea, I think I might get it done with lists and then convert it to vectors later
15:55:09 <NemesisD> geekosaur: so is cabal --version reporting a different version of cabal than the one that is used or...
15:55:12 <allenj12> jchia_: are 2D lists/vectors a pain in haskell
15:55:14 <allenj12> ?
15:55:22 <geekosaur> cabal --version reports the one it was compiled with
15:55:39 <geekosaur> not the one the Setup program it compiles to do the configure phase will be compiled with
15:55:41 <jchia_> allenj12: I don't see why. in most languages, it's not hard to emulate a 2D array with a 1D array with some index calculation
15:55:52 <NemesisD> geekosaur: so what can i do to ensure this mismatch doesn't occur between both machines?
15:56:23 <geekosaur> you could try installing Cabal-1.24.0.0 in the sandbox?
15:56:33 <jchia_> allenj12: if you want a list of lists or a vector of vectors, then i suppose it depends on how you use them. in haskell, the data is immutable
15:56:39 <allenj12> jchia_: yea your right, it really dosnt matter was just wondering if there was some special reason
15:56:58 <ski> allenj12 : you could consider using an array, as well ..
15:57:00 <soLucien> i want to test the type Primitive = [Value] -> SubsM Value lefhand side
15:57:06 <soLucien> how can i pattern match it ?
15:57:18 <geekosaur> sadly, this does matter because the ghc-specific package management options it has to pass to Setup and read back from its output change depending on Cabal library version
15:57:20 <soLucien> the [Value] in the function
15:58:07 <NemesisD> geekosaur: so just in the same dir as my sandbox do cabal install Cabal-1.24.0.0?
15:58:17 <geekosaur> yes, that should work
15:58:20 <geekosaur> I think
15:58:26 <geekosaur> Setup has some special rules though
15:59:04 <geekosaur> soLucien, so you are given a Primitive value? that value is a function
15:59:17 <geekosaur> it doesn't have a [Value], it expects to be *given* a [Value]
15:59:36 <soLucien> okay geekosaur, can i make a pastebin with some stuff
15:59:37 <geekosaur> if you are *writing* such a function, you can pattern match
15:59:40 <geekosaur> @paste
15:59:40 <lambdabot> Haskell pastebin: http://lpaste.net/
15:59:42 <soLucien> hep me get started with something
16:00:43 <NemesisD> fml, i have a transitive dependency on the mysql package (which seems to basically be abandoned) and that won't compile with cabal 1.24
16:03:15 <soLucien> geekosaur http://lpaste.net/2772336045935558656
16:03:31 <soLucien> so i'm trying to start this assingnment .. i've got a lot of stuff to implement
16:03:44 <soLucien> but it will go smooth once i figure out how to test this stuff
16:03:54 <soLucien> i have to build the monad 
16:04:06 <soLucien> i'm trying to first build the return
16:04:17 <soLucien> unit test it with the given function
16:04:23 <soLucien> of course it's wrong, 
16:04:47 <soLucien> but i need some ideas on how to start this .. mainly, how do i test a Primitive 
16:05:00 <soLucien> Primitive is a function
16:05:24 <soLucien> addition , multiplication, division, mod, Array.new
16:05:34 <soLucien> i was given the code for Array.new
16:05:40 <geekosaur> you have not defined IntVal that I see here
16:05:52 <soLucien> it is defined
16:06:00 <soLucien> i only gave you a small subset of the assignment
16:06:10 <soLucien> IntVal is a wrapper for int
16:06:57 <soLucien> geekosaur i added it http://lpaste.net/2772336045935558656
16:07:27 <soLucien> this is basically a very rudimentary interpreter for JavaScript
16:07:35 <soLucien> aimed to help me understand monads
16:07:53 <soLucien> and well .. allow me to get to the exam ..
16:08:21 <geekosaur> you can't really do it that way since SubsM includes a function and functions cannot be compared
16:08:39 <soLucien> i wanted to pattern match
16:08:42 <soLucien> the output
16:08:56 <geekosaur> you can't pattern match a function either.
16:09:41 <soLucien> i mean running the arrayNew [IntVal 2] will return [UndefinedVal, UndefinedVal]
16:10:09 <soLucien> okay so i can't really test anything until i write a lot of code. this is horrible
16:10:14 <geekosaur> then you need to invoke the function to pattern match against it
16:10:29 <geekosaur> you can't match a SubsM value, only the result of runSubsM
16:10:37 <soLucien> shit
16:10:38 <ski> soLucien : `(>>=)' must be defined for anything nontrivial to happen
16:10:39 <soLucien> well that's the monad
16:11:12 <soLucien> i'm screwed .. i was hoping to build around it a bit
16:11:53 <ski> soLucien : if you define it, then you could say `fmap = liftM'
16:12:06 <ski> soLucien : and `pure = return' and `(<*>) = ap'
16:12:12 <soLucien> it is very hard to define for me
16:12:14 <soLucien> yes i did that
16:12:17 <soLucien> sure , i did that as well
16:12:21 <soLucien> forgot to add it to the paste
16:13:12 <ski> `SubsM' looks like its equivalent to `ReaderT Context (EitherT Error (Writer Env))'
16:13:15 <soLucien> also   fmap f m = m >>= \a -> return (f a)
16:13:31 <ski> @src LiftM
16:13:31 <lambdabot> Source not found. It can only be attributed to human error.
16:13:34 <ski> @src liftM
16:13:34 <lambdabot> liftM f m1 = do
16:13:34 <lambdabot>     x1 <- m1
16:13:34 <lambdabot>     return (f x1)
16:13:41 <ski> which is the same as what you said
16:14:30 <ski>   newtype SubsM a = SubsM {runSubsM :: ReaderT Context (EitherT Error (Writer Env)) a} deriving (Functor,Applicative,Monad)
16:15:06 <soLucien> does the return i defined
16:15:08 <soLucien> make sense ?
16:17:32 <ski> @hackage either
16:17:33 <lambdabot> http://hackage.haskell.org/package/either
16:17:36 <ski> soLucien : yes
16:18:37 <ski> actually, sorry, it should be `ReaderT Context (WriterT Env (Either Error))' (and then you don't need that package)
16:18:40 <ski> @unmtl ReaderT Context (WriterT Env (Either Error)) a
16:18:40 <lambdabot> Context -> Either Error (a, Env)
16:19:10 <ski> soLucien : if you really want to, you could define it by hand, though ..
16:19:26 <soLucien> i'm supposed to create this monad
16:19:29 <ski> .. would you like to think about how to do it ? or perhaps you'd like me to show how ?
16:19:41 <soLucien> SubsM is a execution step in the interpreter
16:19:48 <soLucien> it reads stuff from the context
16:19:52 <soLucien> and changes the environment
16:19:54 <ski> the environment `Context' should be distributed everywhere it's needed
16:20:16 <ski> `Either Error' should abort execution on `Left's
16:20:27 <soLucien> yep
16:20:29 <ski> `Env's should be merged
16:20:35 <ski> that's it
16:20:40 <soLucien> it returns a new Env
16:20:40 <ski> now just follow the types !
16:20:43 <soLucien> on every step
16:21:35 <soLucien> yes, it's nice that I got the return right
16:22:03 <ski> in `return' there was nowhere to distribute the environment, so you just ignore it, right
16:22:16 <ski> and there's no source of failure, so you always succeed, iow `Right'
16:22:45 <ski> and `Map.empty' will be a neutral element to map joining, so it amounts to "outputting no information", which is what `return' should do
16:23:03 <ski> (and obviously `x' should be the monadic result)
16:23:22 <ski> now you have
16:23:28 <ski>   f >>= m = ?0
16:23:30 <ski> where
16:23:38 <ski>   f :: SubsM a
16:23:40 <soLucien> i'm giving it some thaught
16:23:44 <ski>   m :: a -> SubsM b
16:23:50 <ski>   ?0 :: SubsM b
16:24:32 <ski> and your first goal is to figure out how to produce something of type `SubsM b', filling the hole `?0', possibly by introducing more holes for the argument(s) of the construction you picked
16:28:24 <soLucien> so what is the b 
16:28:30 <soLucien> after running m
16:28:52 <soLucien> well i can say what it is , but i am unsure about how to write it
16:28:54 <ski> `b' is the monadic result type
16:29:10 <ski> it's just some unknown type, from the perspective of `(>>=)'
16:29:19 <soLucien> yes, how does b change
16:29:27 <ski> you could think of it as an abstract data type `B', that you know nothing about
16:29:28 <soLucien> after running m
16:29:37 <soLucien> that's what i have to write now
16:29:54 <ski> why would `b' change ?
16:32:05 <soLucien> what i have to write now after the = is
16:32:14 <soLucien> m b in terms of f and m
16:32:18 <soLucien> right ?
16:34:46 <ski> soLucien : rather an expression of type `SubsM b', in terms of `f' and `m'
16:34:57 <ski> which is what i meant by
16:34:59 <ski>   f >>= m = ?0
16:35:02 <ski>   ?0 :: SubsM b
16:35:15 <soLucien> i see
16:35:48 <ski> (there is no type `m' for you. or, if you prefer, `m = SubsM')
16:36:14 <soLucien> i'm writing the fail, i think i got it
16:38:24 * ski wouldn't bother with `fail', unless you really think you want it
16:39:05 <soLucien>   fail s = SubsM ( \_ -> Left (Error ("Failed to execute step " ++ s)))
16:39:21 <soLucien> however, i think the \_ should somehow be the context
16:39:46 <soLucien> but again, i don't know how to pattern match the function
16:40:30 <ski> "pattern match" which function ?
16:40:49 <soLucien> newtype SubsM a = SubsM {runSubsM :: Context -> Either Error (a, Env)}
16:40:57 <soLucien> i want the Context
16:41:42 <geekosaur> again, you can't
16:41:44 <geekosaur> it's a function
16:41:52 <geekosaur> it does not have a Context
16:41:58 <geekosaur> it expects to be *fed* a Context
16:42:17 <soLucien> okay i think i got it
16:42:34 <geekosaur> and if you fed it a Context then you have the Either Error (a, Env), not a Context -> Either Error (a, Env)
16:44:32 <soLucien> am i allowed to pattern match f or m in f >>= m ?
16:44:48 <ski> yes
16:45:06 <ski> (and you're already trivially pattern matching, by using the variable names `f' and `m' there)
16:45:27 <ski> you could use a compound pattern instead of `f', if you prefer
16:45:33 <ski> it's not required
16:46:29 <ski> `m' is a function, so you can't pattern-match on it in a nontrivial sense (except by using an extension that i don't think will help particularly much here)
16:46:44 <soLucien> a lambda ?
16:46:58 <ski> you can't write lambda patterns (unfortunately, imho)
16:48:01 <ski> (.. in MetaML, you can write quoted lambda patterns .. though that's not the kind of thing i had in mind here)
16:50:08 <jle`> that's so meta
16:50:14 <soLucien> it's the first time in years i feel so stupid
16:50:27 <jle`> no need to feel stupid :)
16:50:55 <ski> soLucien : well, let's go back to `f >>= m = ?0', where `?0 :: SubsM b'. you need to construct a value of type `SubsM b'
16:51:09 <ski> soLucien : what's the most basic/primary way to construct a value of type `SubsM b' ?
16:51:32 <soLucien> with a lambda , like  i did on the return
16:51:36 <soLucien> but instead 
16:51:54 <ski> a lambda would produce something of type `T -> U', for some types `T' and `U'
16:52:07 <ski> the type `T -> U' does not match the type `SubsM b'
16:52:09 <soLucien> i need to capture the environment from the previous
16:52:23 <soLucien> and create the Context to feed it in the function 
16:52:28 <soLucien> from the previous call
16:52:34 <ski> so you couldn't write `f >>= m = \cxt -> ?1'
16:52:55 <ski> also, "capture the environment from the previous" is the wrong way to think about it
16:52:58 <soLucien> sure, but the cxt needs to be something from f
16:53:04 <ski> it's more like "capture the environment from the future"
16:53:18 <ski> or "wait into the future, for the environment to arrive"
16:53:31 <ski> soLucien : "the cxt needs to be something from f" -- no, that's backwards
16:54:01 <geekosaur> f does not have a cxt, f *needs* a cxt
16:55:01 <geekosaur> let's try this. you had a definition of return as SubsM ( \_ -> ... )
16:55:12 <geekosaur> where in that definition was this cxt you expect to retrieve?
16:56:21 <soLucien> i need to create this cxt by creating a Context (previousEnvThatWasOutputted initialContext)
16:56:30 <geekosaur> that's not the point
16:56:56 <soLucien> well i get part of it from the right side
16:57:07 <soLucien> and part of it by calling initialContext, which is another function
16:57:12 <soLucien> that returns the PEnv
16:57:30 <geekosaur> the point is that SubsM ( \_ -> ... ) does not have a cxt in it. at all. you cannot retrieve what does not exist. you can only give it a cxt; it cannot give *you* oen
16:57:50 <soLucien> yes, i need to give it one
16:58:00 <soLucien> i know how to create one
16:58:10 <geekosaur> you would have had to include the cxt in the SubsM ( \_ -> ...) to have any chance of pulling it out
16:58:55 <geekosaur> it does not matter where else you might get a cxt. those places are not SubsM ( \_ -> ...)
16:59:20 <geekosaur> and SubsM ( \_ -> ...) does not have within it a cxt, only something that expects to be given a cxt sometime in the future
16:59:37 <soLucien> okay , yes 
16:59:51 <juri_> haskell headache. :/
17:02:29 <jle`> hang in there :)
17:04:48 <ski> @quote is.the.solution
17:04:48 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
17:05:25 <juri_> http://lpaste.net/232084
17:05:57 <juri_> vars is unused. how do i remove it, and the '\' (lambda?) before it?
17:06:14 <juri_> it's not an anonymous function..
17:07:17 <geekosaur> not enough information here, I presume it is related to OModule?
17:07:44 <geekosaur> if OModule is giving you something you don't want, presumably you want const $ do ...
17:07:48 <soLucien> so far f >>= m = SubsM (\cxt -> ... )
17:08:04 <soLucien> i'm still where i was 2 hours ago
17:08:20 <ski> soLucien : this is progress
17:08:34 <ski> soLucien : now what is the type of `...' (and of `cxt', but that should be obvious) ?
17:08:42 <lpaste> f-a pasted “MVar blues” at http://lpaste.net/232090
17:09:49 <soLucien> Either
17:10:03 <soLucien> i mean it's using the either left-right
17:10:10 <soLucien> where left is the error
17:10:11 <geekosaur> f-a, the first poll did not putMVar so the second one will block forever
17:10:28 <ski> soLucien : the complete type, please :)
17:10:32 <geekosaur> because the MVar is empty and there is no other thread to fill it
17:10:33 <f-a> geekosaur: so for every takeMVar there should be a put?
17:10:49 <geekosaur> as you are using it there, yes
17:10:58 <soLucien> Either Error (a, Env)
17:11:01 <ski> ty
17:11:02 <juri_> I'm not sure if it's related or not.
17:11:03 <geekosaur> any takeMVar requires a preceding putMVar (or the one done by newMVar)
17:11:06 <f-a> wait, does take erase the value?
17:11:10 <geekosaur> yes
17:11:12 <geekosaur> that's the whole point
17:11:13 <ski> soLucien : now, do you know yet whether to use `Left' or `Right' ?
17:11:21 <isovector> is there a type-safe way i can get vacuous `Show` instances for the uninhabited instances of an open data family?
17:11:28 <soLucien> i can use any of them
17:11:29 <geekosaur> an MVar is a synchronization primitive. the content is a token, and only one thread can hold that token
17:11:39 <soLucien> it depends whether the computation fails or not
17:11:42 <f-a> ok, gotcha
17:11:45 <juri_> I'm still learning this codebase.
17:11:49 <ski> soLucien : and do you know that yet ?
17:12:23 <soLucien> i know i'm supposed to use right it succeeds. in the f>>=m i have no idea 
17:12:30 <soLucien> whether it succeeds or fails
17:12:35 <soLucien> this is the step
17:12:37 <soLucien> right ?
17:12:37 <f-a> thanks geekosaur , works now
17:12:39 <ski> soLucien : right. so you have to use something ele
17:12:50 <ski> soLucien : you have `f',`m',`cxt' currently to play with
17:12:56 <ski>   f :: SubsM a
17:13:04 <ski>   m :: a -> SubsM b
17:13:08 <ski>   cxt :: Context
17:13:09 <geekosaur> f-a., you may have been looking for Chan
17:13:19 <ski> soLucien : which of these would you try using now ?
17:13:29 <soLucien> you just told me that i can't do anything to the cxt
17:13:33 <ski> .. or perhaps i should ask, which *can't* you sensibly use, atm ?
17:13:34 <soLucien> because it has to be constructed
17:13:49 <ski> it has been constructed by the future, and passed to you
17:13:56 <ski> you can check it out, if you like
17:13:57 <Welkin> the FUTURE
17:14:06 <geekosaur> although you still have a problem there because it'd block if nothing else can feed the Chan. or if you just want to pass values around, use an IORef possibly with the atomic ops
17:14:37 <ski> (perhaps s/has been/will be/, but still "passed" ;)
17:14:54 <ski> soLucien : can you use `m' ?
17:15:03 <soLucien> m is SubsM
17:15:50 <soLucien> actually no
17:16:01 <soLucien> m will tell me whether it succeded or failed
17:17:15 <soLucien> by looking at a and executing it, i will know whether it failed or not
17:18:09 <soLucien> is that correct, ski ?
17:18:38 <ReinH> Perhaps this would be easier to discuss in the context of a simpler... context... like Maybe?
17:18:58 <soLucien> I have to use Either
17:19:04 <soLucien> it's a sadistic assignment
17:19:09 <ReinH> I thought you were using "SubsM"
17:19:24 <ReinH> But Either is barely more complicated than Maybe, so that should be fine
17:19:41 <allenj12> can you have an array of an Algebraic data type?
17:19:51 <soLucien> i know what it's supposed to do
17:20:00 <soLucien> but not how to tell haskell how to do it
17:20:06 <Koterpillar> allenj12: yes, but what did you actually mean?
17:20:58 <allenj12> array (0,100) $ zip [1..3] [One,Two,Three] where One... is part of an algebraic type
17:21:01 <ski> soLucien : `m' is a function
17:21:02 <allenj12> throws an error
17:21:04 <Koterpillar> soLucien: maybe try from examples? I missed what SubsM is, but if you take two simple values of type SubsM and try to bind them, can you figure out the result?
17:21:25 <ski> allenj12 : sure
17:21:35 <ski> allenj12 : use `listArray'
17:22:04 <ski> allenj12 : if you wanted `Array Int (Int,ADT)', i.e.
17:22:56 <allenj12> ski: yea for what im doing I was probably going to use Ints, however was curious since all the exapmle of IArrays only have Ints involved
17:23:06 <ski> allenj12 : otherwise, you probably want to give a value for every component of the array
17:23:21 <soLucien> it has to 1) get the env that is returned by the previous call (if it is Right) 2) construct a Context from it (if you have the Env, constructing Context is easy) 3) execute the function and check whether to go left or write, depending on the output 4) on right, return the newly changed Env
17:23:34 <ski> allenj12 : if you want to, you could also use your custom data type for the indices
17:23:46 <Koterpillar> soLucien: can you give some simple example of a SubsM value?
17:24:04 <soLucien> no i can't really .. it's a convoluted piece of shit 
17:24:07 <ski> soLucien : 1) is backwards. there is no "the env that is returned by the previous call"
17:24:11 <allenj12> ski: that makes sense, but only with listArrays right?
17:24:23 <ski> allenj12 : `listArray' is a thin wrapper around `array'
17:24:30 <allenj12> ski: IArrays can only implement primitives?
17:24:32 <soLucien> Koterpillar http://lpaste.net/2772336045935558656
17:24:33 <ski> @type listArray
17:24:35 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
17:24:36 <ski> @type array
17:24:37 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
17:25:09 <ski>   listArray ix es = array ix (zip (range ix) es)
17:25:10 <allenj12> interesting
17:25:25 <ski> @type range
17:25:26 <lambdabot> Ix a => (a, a) -> [a]
17:25:30 <ski> > range (-3,5)
17:25:32 <lambdabot>  [-3,-2,-1,0,1,2,3,4,5]
17:25:37 <ReinH> soLucien: So your job is to implement the instances for SubsM?
17:25:39 <Koterpillar> soLucien: here's one value for you: const (Right (1, M.fromList [("x", 2))
17:25:46 <ski> `listArray' assumes that you're listing the components in the standard order
17:25:50 <ski> `array' doesn't assume so
17:26:15 <soLucien> ReinH my job is to create the monad, then write a parser for a subset of javascript
17:26:24 <soLucien> including list comprehensions and other kind of shit
17:26:25 <Koterpillar> soLucien: and here's another: const (Right (1, M.fromList [("y", 3)])
17:26:25 <allenj12> ski: if thats the only case, then why does (0,100) $ zip [1..3] [1..3] fail? if [1..3] are the indices
17:26:31 <ReinH> Maybe start by writing the Functor instance?
17:26:31 <Koterpillar> soLucien: combine them, please
17:26:34 <ski> soLucien : .. therefore, you already *have* a `Context' (namely `cxt'), so no need for 2)
17:26:46 <ski> soLucien : 3) and 4) is right
17:26:56 <ReinH> javascript has list comprehensions?
17:27:05 <soLucien> no, the assignment is to add them
17:27:09 <ReinH> Array comprehensions are a proposed extension.
17:27:11 <ski> allenj12 : you should include all valid indices, `[0 .. 100]'
17:27:24 <Welkin> ReinH: javascript has anything you want these days
17:27:28 <Welkin> implemented as a library
17:27:29 <ski> array comprehensions are nice
17:27:35 <soLucien> this is the assignment given to us in the second week of Haskell .
17:27:41 <ReinH> you can't implement new syntax in a library
17:27:42 <soLucien> i failed it so i have to resubmit
17:27:48 <Welkin> ramda is quite nice actually, of the available "functional js" libraries
17:27:49 <soLucien> basically they give us an AST 
17:27:53 <Welkin> yes you can
17:27:54 <Welkin> lol
17:28:07 <Welkin> there are many libraries that implemented lambdas as strings
17:28:08 <ReinH> No you can't. Lol.
17:28:11 <Welkin> they just parse the string
17:28:12 <soLucien> and we have to make a interpreter for it
17:28:14 <ReinH> That's not syntax.
17:28:24 <Koterpillar> that's a compiler
17:28:28 <ReinH> You can't change the javascript grammar in a library.
17:28:57 <allenj12> even if I change the first tuple to hold only 1..3 it fails.  array [1..3] $ [1, 2, 3] `zip` [One, Two, Three], ill paste the error
17:29:29 <allenj12> o woops
17:29:33 <allenj12> im dumb
17:29:33 <Koterpillar> allenj12: the first argument is not a list
17:29:37 <allenj12> yea
17:30:12 <ReinH> soLucien: how about implementing fmap?
17:31:14 <soLucien> fmap over functions ?
17:31:42 <allenj12> Koterpillar: even with the correct syntax of with the tuple I get this error Non type-variable argument in the constraint: IArray a Tile
17:31:42 <allenj12>       (Use FlexibleContexts to permit this) which was the original error :P
17:32:14 <verement> > array (0,1) $ zip [0 ..] [False ..]
17:32:16 <lambdabot>  array (0,1) [(0,False),(1,True)]
17:32:23 <Koterpillar> allenj12: paste the whole thing
17:32:26 <Koterpillar> ?where paste
17:32:26 <lambdabot> Haskell pastebin: http://lpaste.net/
17:32:57 <ReinH> soLucien: fmap for SubsM
17:33:27 <soLucien> i correctly implemented the return, so i have the context .. fmap would probably do something like
17:33:40 <ReinH> You don't need return to implement fmap.
17:34:06 <allenj12> Koterpillar: http://lpaste.net/232113
17:34:34 <soLucien> sure .. but i have implemented fmap already
17:34:41 <soLucien>   return x = SubsM ( \_ ->Right (x, Map.empty ) )
17:34:42 <ReinH> Ok, show me
17:34:47 <ReinH> That's not fmap
17:34:48 <soLucien>   fmap f m = m >>= \a -> return (f a)
17:34:55 <ReinH> Ok, have you implemented >>=?
17:34:59 <soLucien> no
17:35:06 <soLucien> that's what i am trying to figure out
17:35:10 <ReinH> Then you haven't implemented fmap yet.
17:35:26 <soLucien> yes you are right
17:35:27 <ReinH> Implementing fmap directly will teach you something that will help you to implement >>=
17:35:34 <allenj12> verement: its weird, when I pasted what you wrote into my repl I got the same error
17:35:41 <allenj12> > array (0,1) $ zip [0 ..] [False ..]
17:35:44 <lambdabot>  array (0,1) [(0,False),(1,True)]
17:36:06 <Myrl-saki> :t array
17:36:08 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
17:36:22 <ski> > listArray (0,1) [False ..]
17:36:24 <lambdabot>  array (0,1) [(0,False),(1,True)]
17:36:25 <fjawn> if I have  [(String, Int)] , how can I store it to file?
17:36:37 <ReinH> fmap (SubsM f) = SubsM ???
17:37:08 <allenj12> ski: why do these things work here but not in my repl!!
17:37:33 <Koterpillar> allenj12: maybe you do need FlexibleContexts, as the message says?
17:37:36 <fjawn> ie how could I convert a list of tuples into Text?
17:37:52 <Koterpillar> fjawn: JSON is one way
17:38:00 <ReinH> fjawn: pack . show, binary, json
17:38:04 <ReinH> depends on your needs
17:38:05 <Koterpillar> fjawn: using Show on the whole thing is another
17:38:34 <verement> allenj12: I would guess it is because you're importing Data.Array.IArray instead of Data.Array
17:38:44 <fjawn> Thank you very much!
17:38:51 <allenj12> verement: ill try changing that
17:39:02 <ReinH> soLucien: Also (>>=) will be harder to implement than fmap, so if you are struggling with the latter then you should try the former.
17:39:15 <allenj12> verement: now it works
17:39:17 <verement> allenj12: and there isn't a known suitable instance for IArray a Tile, as the error points out
17:39:30 <Myrl-saki> ReinH: lol
17:39:49 <ReinH> Myrl-saki: ?
17:41:22 <fjawn> oh also is there a function that removes all the non-letter characters ie $%^#£? 
17:41:26 <fjawn> (it's for NLP)
17:42:40 <ReinH> Text.filter
17:42:46 <Koterpillar> filter (flip elem "$%^#£?")
17:42:56 <ReinH> not .
17:43:18 <Koterpillar> filter (not . isLetter)
17:43:21 <ReinH> Or, filter isAlphaNum
17:43:31 <ReinH> Koterpillar: you have that backwards
17:43:45 <ReinH> filter keeps the ones for which the predicate is true
17:43:48 <Koterpillar> right, sorry
17:43:49 <ReinH> > filter even [1..10]
17:43:51 <lambdabot>  [2,4,6,8,10]
17:44:11 <ReinH> so filter isLetter, depending on whether isLetter is the right predicate
17:44:23 <soLucien> ReinH i think the difficulty is the same
17:44:26 <Koterpillar> > filter isLetter "oh also is there a function that removes all the non-letter characters ie $%^#£? "
17:44:28 <soLucien> it has to do the same thing
17:44:28 <lambdabot>  "ohalsoisthereafunctionthatremovesallthenonlettercharactersie"
17:44:38 <Koterpillar> fjawn: ^
17:45:17 <ReinH> soLucien: No, it does not.
17:45:22 <ReinH> It has to do a different, easier thing.
17:45:52 <ReinH> Also, given that I know how to implement them and you do not, I think I am in a better place to judge their relative difficulty.
17:45:55 <soLucien> i mean for me the difficulty is the same .. of course , it is easier , but it still has to somehow modify this functin
17:46:27 <Myrl-saki> ReinH: i'm laughing because it is true.
17:47:03 <soLucien> and i have no idea. All monads i've seen in lyah, typeclassopedia and evrywhere else are about types
17:47:06 <soLucien> not functions
17:47:16 <soLucien> all except (->)
17:47:29 <ReinH> functions have types
17:47:37 <ReinH> State contains a function type
17:47:42 <ReinH> @unmtl State s a
17:47:43 <lambdabot> s -> (a, s)
17:47:44 <soLucien> and it was tough to get one
17:47:49 <verement> > length $ filter isLetter [minBound ..]
17:47:51 <lambdabot>  102725
17:48:08 <soLucien> tough to get it * the (->) r
17:48:13 <Koterpillar> verement: isAlpha is a better name
17:48:15 <soLucien> this is the same
17:48:27 <ReinH> This is more like State than like (->) r
17:48:45 <verement> > > length $ filter isAlpha [minBound ..]
17:48:47 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
17:48:50 <verement> oops
17:48:57 <verement> > length $ filter isAlpha [minBound ..]
17:49:00 <lambdabot>  102725
17:49:04 <fjawn> Thanks a lot Koterpillar & ReinH (and thanks for tagging me cos I was about to miss it)
17:49:05 <Koterpillar> verement: but yes, there is a lot of letters
17:50:32 <ReinH> soLucien: I'm just saying you should do fmap before you do (>>=). If you want to make your life more difficult by doing (>>=) first then I can't really stop you.
17:50:55 <soLucien> i have no idea about how to do either of them
17:51:04 <soLucien> i know what they need to do conceptually
17:51:39 <soLucien> but i can't reconcile the Context and the Env
17:51:48 <soLucien> i don't see how they can fit together
17:52:03 <soLucien> the state is s -> (a, s)
17:52:05 <Koterpillar> soLucien: perhaps remove Context from everywhere now
17:52:06 <soLucien> perfect, i get that
17:52:18 <soLucien> but this is ctx -> a, s
17:52:24 <soLucien> where s is a part of ctx
17:52:36 <Koterpillar> where did the state go?
17:53:02 <Koterpillar> to combine s -> (a, s) and ctx -> r, you just... combine both
17:53:04 <soLucien> ctx = s + smth else
17:54:05 <ReinH> For fmap, it doesn't matter what Context is.
17:54:16 <ReinH> Since you can't change it anyway
17:54:21 <ReinH> you can only use it as is
17:55:27 <fjawn> Reinh Koterpillar: If we go back to the isLetter example, how can I change the predicate to "isLetter or Space"
17:55:33 <fjawn> (I want the words to remain words)
17:55:40 <ReinH> soLucien: How do you write fmap for State s?
17:56:04 <ReinH> (\c -> isLetter c || isSpace c)
17:56:28 <ReinH> (liftA2 (||) isLetter isSpace), if you're into unnecessary uses of the ((->) r) applicative.
17:57:10 <fjawn> ReinH: Thanks a lot :) 
17:57:15 <ReinH> yw
17:57:48 <soLucien> it needs to apply the function to the state
17:58:14 <ReinH> Not to the state, to the `a'.
17:59:20 <ReinH> so, newtype State s a = State (s -> (a, s))
17:59:35 <ReinH> fmap f (State g) = State $ ???
18:00:31 <soLucien> fmap f (State g) = State (f g)
18:00:43 <ReinH> what is the type of f?
18:01:08 <ReinH> :t fmap
18:01:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:01:14 <soLucien> (a->b)
18:01:18 <ReinH> What is the type of g?
18:01:38 <soLucien> f a
18:01:43 <ReinH> No.
18:01:44 <soLucien> sry
18:01:44 <soLucien> a
18:01:47 <ReinH> No.
18:01:57 <ReinH> newtype State s a = State (s -> (a, s))
18:02:01 <soLucien> State g is f a\
18:02:24 <ReinH> there is no f here
18:02:30 <ReinH> (at the type level)
18:02:44 <ReinH> fmap :: (a -> b) -> State s a -> State s b
18:02:47 <ReinH> is the type we are working with
18:03:12 <ReinH> newtype State s a = State (s -> (a, s))
18:03:24 <ReinH> What is the type of the value given to the State constructor?
18:03:36 <ReinH> It's the thing on the right hand side, after "State"
18:03:57 <soLucien> s ?
18:04:01 <ReinH> The whole thing
18:04:20 <ReinH> in data Foo = Foo Bar, the type of the argument to Foo is Bar
18:04:40 <ReinH> the type of the argument to the data constuctor State is what?
18:04:40 <soLucien> so the function s -> (a,s) ?
18:04:43 <ReinH> Yes.
18:04:52 <ReinH> Can you apply f :: a -> b to g :: s -> (a, s)?
18:05:20 <soLucien> yes
18:05:31 <soLucien> s->(b,s) ?
18:05:44 <ReinH> So you're saying that `s -> (a, s)' and `a' are the same type?
18:06:11 <allenj12> is there a way to get a list of all the possible paths for an ADT
18:06:29 <c_wraith> soLucien: don't guess about types.  Reason through them - the computer isn't smarter than you, and it gets them right.  (It does have better memory than you, though)
18:06:47 <soLucien> it's 3 AM
18:06:49 <ReinH> You can write this in a Haskell file and try to compile it.
18:06:54 <ReinH> Rather than guessing.
18:07:02 <ReinH> If you can compile it, you are right.
18:07:05 <ReinH> If you can't, you are wrong.
18:07:12 <c_wraith> and the message may help
18:07:17 <ReinH> allenj12: probably, depending on what you mean.
18:08:22 <allenj12> data Tile = Space | One | Two | Three | Four | Five | Six | Seven | Eight , I would basicall want [Space..Eight] functionality, ordering dosnt have to matter, and you can assume I would always want the whole set
18:08:41 <c_wraith> allenj12: derive Enum
18:08:43 <ReinH> deriving (Enum)
18:08:49 <ReinH> And that will literally work.
18:08:49 <allenj12> gotcha
18:08:50 <allenj12> thanks
18:09:14 <ReinH> > [False .. True]
18:09:16 <lambdabot>  [False,True]
18:09:35 <c_wraith> allenj12: oh, you will need a space before the first .
18:09:38 <c_wraith> allenj12: or it confuses the parser
18:09:41 <geekosaur> and if you also derive Bounded you can [minBound .. maxBound] :: [Tile] (type annotation only needed if it can't be inferred)
18:09:49 <c_wraith> > [False..True]
18:09:51 <lambdabot>  error:
18:09:51 <lambdabot>      Not in scope: ‘False..’
18:09:51 <lambdabot>      No module named ‘False’ is imported.error:
18:10:04 <allenj12> o I was just getting confused by that :D
18:10:07 <Welkin> > [1..2]
18:10:09 <lambdabot>  [1,2]
18:10:17 <Welkin> > [ 1 .. 2 ]
18:10:20 <lambdabot>  [1,2]
18:10:21 <allenj12> haskell syntax sometimes makes me sad
18:10:22 <allenj12> lol
18:10:24 <Welkin> > [ True .. False ]
18:10:27 <lambdabot>  []
18:10:34 <Welkin> lol
18:10:35 <soLucien> i'll call it a night, it's beem 3 hors since i made any progress. I'm a bit disappointed
18:10:42 <Welkin> > [ False .. True ]
18:10:45 <lambdabot>  [False,True]
18:10:48 <c_wraith> There are some warts.  qualified module names definitely are one of them.
18:11:09 <Welkin> allenj12: 
18:11:29 <c_wraith> They happen to use syntax that could alternately be a couple other things, and the determination is done by whitespace use.
18:11:29 <allenj12> Welkin: it worked! thanks
18:11:30 <Welkin> allenj12: the fact that you are even using haskell is something to celebrate
18:11:55 <allenj12> is it wrong I want a haskell but with lisp syntax?
18:11:58 <Welkin> those poor saps who don't know what they are missing
18:12:23 <c_wraith> yes. :P
18:12:24 <Welkin> allenj12: you can do that if you want
18:12:31 <Welkin> add in unnecessary parentheses
18:12:49 <soLucien> spent tens of hours reading hundreds of pages about these things, and they're still in a fog
18:12:54 <allenj12> Welkin: yea but wouldnt be idiomatic haha :D plus I wouldnt get macros for free
18:13:07 <allenj12> c_wraith: but why!
18:13:16 <Welkin> allenj12: I don't think I should tell you are Template Haskell... oops
18:13:18 <c_wraith> In my experience, lisps have tons of weird syntactic idiosyncrasies too.  But they vary from version to version.
18:13:21 <Welkin> don't abuse it
18:13:27 <Welkin> tell you about*
18:13:54 <jmcarthur> Just abuse it. Make enough people want something better so that somebody makes a better Template Haskell.
18:13:59 <soLucien> thanks for the help ReinH, ski, Koterpillar
18:14:16 <c_wraith> Most of those are the result of macro invocation using the same syntax as function application.
18:14:30 <allenj12> Template haskell is like a DSL framework/macro system?
18:14:53 <c_wraith> Except that in a macro invocation, the following tokens aren't assigned the semantics you would normally expect.
18:15:03 <Welkin> Template Haskell is the backbone of most snoyberg libraries
18:15:03 <Welkin> lol
18:15:16 <c_wraith> I like rust's choice to make macro invocation use ! to distinguish it from function calls
18:15:51 <Welkin> I must admit it is really nice to use Persistent because of the TH
18:15:54 <c_wraith> allenj12: template haskell is literally an extension that allows you to generate haskell code from haskell code, at compile time.
18:16:25 <allenj12> c_wraith: i like that too, but I havent run into problems not being able to differeniate functions from macros. So idk 
18:16:31 <allenj12> c_wraith: gotcha
18:19:07 <juhp> just realised geany has basic (not bad) haskell support (maybe not Cabal by default)
18:19:43 <Welkin> lol
18:19:48 <Welkin> haven't used geany in years
18:43:19 * hackagebot hailgun 0.4.1.1 - Mailgun REST api interface for Haskell.  https://hackage.haskell.org/package/hailgun-0.4.1.1 (RobertMassaioli)
18:57:51 <Ed___> So, I'm simulating an ALU. Is it better to create a data type say "data Bit = O | I" or just work with Int and 1's and 0's?
18:59:07 <alercah> What do you do if you get a 2?
18:59:22 <Koterpillar> you'd have to define an awful lot of partial functions with Int
18:59:47 <Ed___> I'm more worried about space consumption
19:00:10 <Ed___> The way I have my code written I can just replace every O with a 0 and every I with 1 and every Bit with an Int
19:00:16 <mgsloan> If you're worried about space consumption then use types like Word32 or, probably better yet, Word64
19:01:54 <mgsloan> For small enum-like types, I don't think you actually need to pay for more than just the pointer.  With GHC, the pointer uses the bottom few bits to represent whether the thunk has been evaluated, and for the first few constructors, which constructor it is.  Since these do not have fields, there is no need for 'Bool' to take up space beyond its pointer
19:02:11 <mgsloan> At least, if I remember correctly, I haven't verified that 'Bool' doesn't take space beyond its pointer
19:02:53 <mgsloan> I would probably just use 'Bool', it matches your usecase
19:03:00 <mgsloan> And comes with boolean operations
19:03:31 <Koterpillar> but you don't want it to be used in an if accidentally
19:03:45 <Ed___> thanks
19:04:31 <mgsloan> Koterpillar: One hack would be to turn on RebindableSyntax and define `ifThenElse = error "No if for you!!"` ;)
19:05:03 <mgsloan> You could even use if, but redefine it to "ifThenElse :: Bool -> Bool -> Bool -> Bool"
19:07:48 <mgsloan> Also you can trivially define "f :: Bit -> Bool"
19:08:04 <mgsloan> Unless of course the Bit constructors are hidden
19:10:05 <Koterpillar> mgsloan: such an f would be called isO and isI, which makes more sense
19:19:07 <allenj12> > [(+1), (*1)] <*> [2]
19:19:10 <lambdabot>  [3,2]
19:19:14 <Ed___> Is there a way to convert from the string "O" to just O?
19:19:59 <Koterpillar> Ed___: awaytoconvert "O" = Just O; awaytoconvert "I" = Just I; awaytoconvert _ = Nothing
19:20:08 <allenj12> this might sound stupid, but what is an applicative functor that does a 1-1 correspondence rather than a cartesian product
19:20:16 <allenj12> just map I guess
19:20:17 <allenj12> ?
19:20:51 <pavonia> > Just succ <*> Just 1
19:20:53 <lambdabot>  Just 2
19:21:42 <allenj12> dosnt work on lists tho
19:21:55 <allenj12> cause I want a 1-1 
19:22:06 <Ed___> but that solution will print out the "Just", correct Koterpillar?
19:22:17 <Koterpillar> Ed___: that solution doesn't print anything
19:22:18 <pavonia> allenj12: Hhm, I don't understand you question then
19:22:23 <pavonia> *your
19:22:27 <Ed___> returns....
19:23:00 <allenj12> pavonia: example [(+1), (*1)] operation [2, 3] => [3, 3]
19:23:32 <Koterpillar> Ed___: what do you want "Z" to be converted to?
19:23:33 <ski> > getZipList (ZipList [(+1), (*1)] <*> ZipList [2,3])  -- allenj12
19:23:35 <lambdabot>  [3,3]
19:23:39 <Ed___> Z
19:23:49 <Koterpillar> Ed___: what is the type of that Z?
19:24:09 <Ed___> because I created my own data type Bit = O | I and I want to take input from a text file (as a string) and convert it to a Bit type
19:24:20 <Koterpillar> right, so O and I are of type Bit, but Z?
19:24:35 <Ed___> Z wouldn't be part of the tinput
19:24:39 <Ed___> *input
19:24:42 <allenj12> ski: ahh thanks, Im probably going through this the wrong way, but I was curios anyway. Im taking my Array and trying to + and - the indexes to know the positions of the next possible board possitions
19:25:26 <Koterpillar> Ed___: then you can omit Just in that definition, and the Nothing clause, and blame yourself when Z appears
19:26:12 <Ed___> Ok. Would I just throw an error on the otherwise clause?
19:26:53 <Koterpillar> well, of course you can, but why not do it the proper way?
19:27:04 <Ed___> What would be the proper way?
19:27:15 <Ed___> By the way, thanks for bearing with me.
19:27:21 * ski . o O ( <https://en.wikipedia.org/wiki/High_impedance> )
19:27:44 <Koterpillar> using Maybe as above, or Validation if you want better error messages
19:27:49 <Ed___> return type Maybe Bit?
19:27:51 <Koterpillar> yes
19:28:00 <Ed___> Thanks
19:29:15 <allenj12> > ZipList [1, 2]
19:29:17 <lambdabot>  ZipList {getZipList = [1,2]}
19:29:41 <ski>   newtype ZipList a = ZipList {getZipList :: [a]}
19:30:04 <ski>   instance Applicative ZipList
19:30:05 <ski>     where
19:30:21 <ski>     pure a = ZipList (repeat a)
19:30:48 <Ed___> then how do you go from Just X to X
19:30:48 <ski>     ZipList iab <*> ZipList ib = ZipList (zipWith ($) iab ib)
19:30:57 <Koterpillar> Ed___: and then you can build on it: readBits :: String -> Maybe [Bit]; readBits = traverse awaytoconvert . lines
19:31:06 <ski> Ed___ : you match in the caller
19:31:12 <allenj12> ski: its interesting, I must be messing up the imports again as it dosnt work in my repl haha :D
19:31:25 <ski> Ed___ : providing something to do in case you get `Nothing'
19:31:26 <prsteele> Ed___ If you encounter Nothing, do something sensible from main like printing an error and exiting
19:31:26 <allenj12> ski thanks for the instace though really clears it up
19:31:39 <Ed___> got it thanks
19:39:01 <allenj12> ski: imma head out thanks!
19:39:08 <allenj12> thanks everyone for your help tonight!
19:43:21 * hackagebot dns 2.0.6 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.6 (KazuYamamoto)
19:43:23 * hackagebot fast-logger 2.4.7 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.7 (KazuYamamoto)
19:59:09 <lpaste> prsteele pasted “Style question” at http://lpaste.net/232287
19:59:18 <prsteele> style question. how would you write the above paste?
20:01:46 <cocreature> prsteele: I’d probably try to flip the argument order of the runFoo* functions
20:01:56 <ski>   x = runFoo1T (m `runFoo4` x `runFoo3T` y `runFoo2T` z)
20:02:08 <prsteele> so my issue isn't necessarily nesting with the variables. it's how damn long the line is
20:02:24 <prsteele> I'm hitting 100 chars wide ><
20:02:31 <amalloy> it would be more convenient if your runFoo functions took arguments in the other order
20:02:32 <ski>   x = runFoo1T
20:02:48 <ski>     $ (`runFoo2T` z)
20:02:57 <prsteele> I can trivially save intermediate states, but that isn't necessarily the most readable solution
20:02:59 <ski>     . (`runFoo3T` y)
20:03:12 <ski>     . (`runFoo4` x)
20:03:16 <ski>     $ m
20:04:18 <ski> well, i'd probably change the first `$' into a `.', as well
20:04:45 <prsteele> you think the, uh, hanging style is reasonable?
20:04:51 <ski> yes
20:05:10 <prsteele> thanks
20:05:53 <ski> if `x =' is long, i'd break line immediately after that `=' instead
20:06:21 <prsteele> I will. a lot of the length comes from pattern matching on the nested tuples that accrue.
20:06:37 <joe9> trying to figure out between StablePtr vs IORef http://stackoverflow.com/questions/8964362/haskell-stableptr . I have a similar situation where the data is maintained in haskell and C gets an opaque pointer to the data. I understand that if I use StablePtr, I cannot change the value referenced by the StablePtr, correct?
20:06:52 <ski> is it the `runFooX' lines that are long, or the `m' ?
20:07:07 <joe9> But, with an IORef, I do not have this issue. I can mutate the values all I want.
20:07:26 <prsteele> ski: both, but the left-hand side is short on its own
20:07:26 <joe9> But, the StablePtr to the IORef remains the same.
20:07:29 <ski> if only the latter, i would possibly instead break line after the `$' (especially if there's a `do', then i'd break after it)
20:09:16 <lpaste> prsteele pasted “Answer” at http://lpaste.net/232304
20:10:03 <prsteele> hm. with Applicative-Do, I might be able to write this using the applicative instance for (-> r), which is just function composition, right?
20:10:06 <ski> (next time, you could annotate the original paste with the update)
20:10:10 <prsteele> ah my bad
20:11:04 <ski> "which is just function composition, right ?" -- no, it distributes, as usual
20:11:22 <ski> @src (->) pure
20:11:22 <lambdabot> pure = const
20:11:23 <ski> @src (->) (<*>)
20:11:23 <lambdabot> (<*>) f g x = f x (g x)
20:11:26 <ski> @src (->) return
20:11:26 <lambdabot> return = const
20:11:29 <ski> @src (->) (>>=)
20:11:29 <lambdabot> f >>= k = \ r -> k (f r) r
20:11:35 <prsteele> I must have been thinking of something else then. I remember deriving that (something) was just (.)
20:11:46 <ski> you're thinking of `fmap'
20:11:52 <ski> @src (->) fmap
20:11:52 <lambdabot> fmap = (.)
20:11:56 <prsteele> ah
20:12:02 <prsteele> thanks
20:12:05 <ski> also
20:12:08 <ski> @type flip
20:12:10 <lambdabot> (a -> b -> c) -> b -> a -> c
20:12:19 <ski> can be generalized to an arbitrary functor
20:12:38 <ski>   flip :: Functor f => f (b -> c) -> (b -> f c)
20:12:43 <ski> (used to be in lambdabot)
20:13:51 <ski> `(<*>)'/`ap' is the `S' combinator
20:13:57 <ski>   S f g x = (f x) (g x)
20:14:28 <ski> (and join is the warbler, iirc)
20:15:14 <prsteele> thanks for the help!
20:16:38 <ski> np
20:17:29 <prsteele> adhering to style guides is a good idea, but sometimes irksome
20:20:05 <cocreature> joe9: StablePtr (IORef a) might do what you want
20:21:21 <joe9> cocreature: Thanks.
20:22:20 <joe9> I want a list that will have atleast 1 element. There seem to be a lot of choices. Which is the recommended one? non-empty, semigroups, NonEmptyList, NeverEmptyList
20:22:32 <joe9> mono-traversable
20:22:59 <ReinH> ski: indeed Applicative gives us the whole SKI :D
20:23:02 <cocreature> I would use Data.List.NonEmpty from base
20:23:04 <cocreature> ^ joe9 
20:23:10 <joe9> cocreature: Thanks.
20:23:27 <ReinH> Which makes it Turing complete or something probably
20:23:27 <benzrf> warbler?
20:23:48 <ReinH> So take that, "applicative isn't as powerful as monad"
20:25:14 <haskellsyntaxisc> yes
20:25:20 <haskellsyntaxisc> goddammit irc
20:25:43 <haskellsyntaxisc> I named myself "haskellsyntaxisconfusing", it stripped it down to "haskellsyntaxisc".
20:25:45 <haskellsyntaxisc> :(
20:26:20 <ReinH> ...
20:27:25 <cocreature> haskellsyntaxisc: you don’t need to put your complaint/question in your nickname you can just write it as a message
20:27:29 <benzrf> :]
20:28:19 <haskellsyntaxisc> ok
20:31:13 * pavonia reads the c as concise, comprehensible and charming
20:32:29 <amalloy> C-like
20:43:22 * hackagebot incremental-parser 0.2.5 - Generic parser library capable of providing partial results from partial input.  https://hackage.haskell.org/package/incremental-parser-0.2.5 (MarioBlazevic)
20:49:54 <ski> benzrf : <http://dkeenan.com/Lambda/>
20:56:01 <haskellsyntaxisc> So, https://github.com/bitemyapp/learnhaskell recommends against installing Haskell Platform, while http://learnyouahaskell.com/introduction suggests it. wat i do?
20:56:24 <grantwu> Don't install Haskell Platform
20:56:55 <haskellsyntaxisc> grantwu: Why, though?
20:57:04 <haskellsyntaxisc> Is it haskell with shit included?
20:57:16 <grantwu> What languages are you familiar with?
20:57:29 <grantwu> Also (https://mail.haskell.org/pipermail/haskell-community/2015-September/000014.html) is useful
20:57:50 <grantwu> If you're familiar with Python, the Haskell Platform would be the equivalent of Python + pip install a bunch of common libraries.
20:57:54 <haskellsyntaxisc> JS, C, PHP, Python
20:58:02 <grantwu> Except the libraries aren't the newest version
20:58:10 <grantwu> And you will have lots of fun if you have something that depends on a newer version
20:58:48 <grantwu> It's really not easier than just using stack
20:58:53 <haskellsyntaxisc> grantwu: Ah, I get it now. Thanks!
20:59:18 <haskellsyntaxisc> But, can't cabal deal with different versions of the same package?
20:59:40 <grantwu> It can, but from what I've heard it's not... great at it
21:00:45 <grantwu> Other people would know more
21:07:14 <johnw> cabal is very soon going to be a heck of a lot better at it
21:07:30 <johnw> the "new-build" machinery is still in testing, but should be pretty awesome when it comes
21:08:21 <johnw> (when talk about "cabal" here, we're talking about the cabal-install tool; both cabal-install and stack both use the Cabal library)
21:14:45 <ReinH> johnw: For me this is yet another build system that emacs doesn't work with yet :/
21:14:49 <jchia1> Question about unboxed vectors: If I have a newtype Foo that just wraps Int32, which can be used as an element type for an unboxed vector, what do I need to do to allow Foo to also be used in an unboxed vector?
21:14:54 <ReinH> I had just gotten it working decently with stack too
21:15:10 <johnw> ReinH: it's the editor employment program
21:15:12 <ReinH> but yes I agree that the new system is much better per se
21:15:57 <ReinH> jchia1: deriving (Unboxed) and GeneralizedNewtypeDeriving
21:16:29 <joe9> https://paste.pound-python.org/show/XYEOw8bkr4Gl92oKwSZg/ what is the type of the pattern? https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html
21:16:59 <joe9> When I use the code, I get warnings about the pattern synonyms
21:17:18 <ReinH> johnw: it matches values of type BlendMode
21:17:36 <jchia1> ReinH: Thanks
21:17:44 <geekosaur> what warnings?
21:17:46 <jchia1> i think i need to do this for both mutable and immutable vectors
21:19:04 <joe9> https://paste.pound-python.org/show/q2Lwos6DdK8gNnMXrEAb/ geekosaur  from this code: https://github.com/joe9/lookup-keycode/blob/master/src/KeySymbolDefinitions.hsc
21:19:34 <joe9> geekosaur:  I could just add those type signatures as I am generating that stuff anyway.
21:20:00 <geekosaur> ah, that. I think for this usage you could just disable that warning; the problem with adding type signatures is if you want to use that code on a different platform that may have different types
21:20:25 <ReinH> geekosaur: how would it have different types on different platforms?
21:20:45 <ReinH> They're of type KeySymbol on all platforms, no?
21:20:57 <joe9> ReinH: yes, I think so.
21:21:03 <geekosaur> but that maps to a C type and I have seen that differ per platform
21:21:17 <jchia1> ReinH: Seems to not work somehow. I'm deriving both the mutable Unbox and the regular Unbox. I'm getting "No instance for (Data.Vector.Generic.Mutable.Base.MVector MU.MVector Price) arising from the 'deriving' ..." Price is the newtype I'm making.
21:21:19 <joe9> geekosaur: newtype KeySymbol = MkKeySymbol { unKeySymbol :: Word32 } deriving (Eq, Show)
21:21:20 <geekosaur> X11 in particular has had *lots* of bugs of that nature (discovered by xmonad dumping core unexpectedly)
21:21:25 <geekosaur> ok
21:21:32 <ReinH> The C type might, but how would XK_Return :: KeySymbol ever be wrong?
21:21:47 <jchia1> i'm using GeneralizedNewtypeDeriving together with FunctionalDependencies and I don't know whether there are weird interactions between them.
21:21:49 <geekosaur> they specified Word32 instead of doing something dumb
21:22:05 <ReinH> jchia1: not afaik
21:22:07 <geekosaur> jchia1, fundeps shouldn't have anything to do with GND
21:22:11 <ReinH> GHD got fixed up
21:22:14 <ReinH> *GND
21:22:19 <grantwu> Oh, it did?
21:22:36 <ReinH> with roles http://cs.brynmawr.edu/~rae/talks/2013/hiw-roles.pdf
21:22:36 <geekosaur> there are otger things that interacted but fundeps shouldn't have been one of them
21:22:55 <jchia1> ReinH: Yeah, I just stripped down the code and the error is still there.
21:23:23 <grantwu> ReinH: I read through this thread and found it... inconclusive https://mail.haskell.org/pipermail/haskell-cafe/2015-April/118970.html
21:23:51 <geekosaur> ReinH, specifically when 64-bit linux became popular a bunch of badly C-typed X11 APIs were exposed by causing core dumps
21:24:19 <ReinH> geekosaur: But how does that affect the type declaration needed at (say) line 88?
21:24:20 <geekosaur> mostly because the programmers had assumed sizeof (int) == sizeof (long)
21:24:54 <geekosaur> it doesn't. I had missed that decl so did not know if it could run into something liek this. since it specifies bits, it's not likely to cause such a problem (hopefully)
21:25:11 <jchia1> ReinH: I suspect I also need to derive the constraints of the Unbox
21:25:21 <geekosaur> (except lazy C programmers can usually find some way to screw things up...)
21:25:44 <jchia1> is there a way to automatically derive the directly or indirectly implied constraints?
21:26:26 <geekosaur> jchia1, a newtype is a fiction living inside the typechecker. GND should pass the underlying type through completely, which is what you want
21:26:50 <dagda1> how can I do something like this sqrt (zipWith (+) arr arr)
21:27:10 <geekosaur> that makes no sense as written
21:27:19 <joe9> geekosaur: ReinH: I am getting an error when I add the type definition https://paste.pound-python.org/show/AhMFSuTzd7vo78G1C9rZ/
21:27:19 <geekosaur> what are you actually looking for?
21:27:35 <dagda1> I am looking for the sqrt of the result of the zipWIth function
21:27:37 <joe9> relevant code: https://paste.pound-python.org/show/MmOImhJxfUwnjvQ535kj/
21:27:45 <jchia1> zipWith gives you a list
21:27:48 <geekosaur> the result of zipWith is a list
21:27:50 <jchia1> how do you sqrt that list?
21:27:53 <joe9> geekosaur: I think I should just disable the warnings, correct?
21:28:06 <dagda1> right of course
21:28:10 <jchia1> do you want to fmap sqrt?
21:28:28 <geekosaur> joe9, that's not the problem
21:28:45 <geekosaur> the problem is that names starting with uppercase are constructors
21:29:14 <geekosaur> the Haskell X11 bindings map those names to xK_...
21:29:51 <joe9> geekosaur: ok, will do that. Thanks.
21:30:18 <geekosaur> I think what you really need here is bidirectional patsyns, and you can specify types in those
21:30:55 <dmj`> M1 constructor type variable letters are 'i c f p', heh
21:30:57 <geekosaur> (in fact you seem to be assuming them, but IIRC those patsyms are not written as bidirectional)
21:31:32 <joe9> geekosaur: What do you think I am missing? From the article, I think I defined them as bidirectionaly
21:31:55 <joe9> geekosaur: https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html I followed this.
21:31:58 <geekosaur> I thought you needed extra stuff to indicate the types in scope in pattern vs. expresison context
21:32:02 <geekosaur> oh
21:32:07 <geekosaur> patsyns changed
21:32:16 <geekosaur> the 2014 version wasn't flexible enough
21:33:00 <geekosaur> although I'm not sure if that triggered for ghc7.10; there were certainly changes in ghc8 to fix shortcomings in bidirectional patsyns
21:33:38 <joe9> oh, ok. I will try with xK version
21:33:55 <geekosaur> but you don't seem to have types *in the patsyn definition*, and you need to put them there; you cannot write the signatures spearately
21:34:12 <geekosaur> if you use patsyns then you want the initial uppercase
21:34:26 <geekosaur> if you use initial lowercase then you want to use normal bindings and not patsyns
21:35:03 <geekosaur> oh, I misremembered it
21:35:18 <joe9> geekosaur: oh, seems to like the devil and the deep sea?
21:35:18 <geekosaur> change your type signature to:  pattern XK_... :: type
21:35:27 <geekosaur> (note initial pattern keyword)
21:35:33 <joe9> geekosaur: I think I tried that. let me try again.
21:35:36 <geekosaur> I thought it went inside the patsyn
21:36:14 <geekosaur> without the pattern keyword you will get the error you got because it thinks you're trying to give a constructor a type signature
21:36:59 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#typing-of-pattern-synonyms but note that 7,10 does bidirectional patsyns slightly differently
21:37:03 <joe9> gee
21:37:12 <joe9> geekosaur: I think you are correct. Adding the pattern helped.
21:37:31 <jchia1> geekosaur: Then I've no idea why I can't GND Unbox.
21:37:50 <geekosaur> jchia1, possibly it's just too fancy to be GND-ed
21:38:18 <geekosaur> I think Unbox may be one of the inspirations for a current proposal to extend the deriving mechanism, come to think of it
21:38:39 <jchia1> OK
21:39:10 <geekosaur> that would mean you would need to find the Unbox definition for the base type and copy it as the definition for your newtype
21:39:32 <jchia1> i'll try that. the code looks a bit arcane to me
21:39:41 <geekosaur> thats not surprising
21:39:54 <geekosaur> if it looks arcane to you, it probably looks arcane to GND
21:40:02 <geekosaur> GND is not really that smart
21:41:19 <jchia1> The Int32 instance uses a "#define primMVector(ty, con)"
21:41:59 <jchia1> What does "#define" mean?
21:43:26 <geekosaur> it's C preprocessor syntax
21:43:29 <geekosaur> it's a macro
21:43:37 <jchia1> in a hs source file?
21:43:52 <geekosaur> yes. look for {-# LANGUAGE CPP #-} at the top
21:44:17 <jchia1> OK, it's there
21:44:38 <Clint> you have confirmed that geekosaur is correct
21:45:00 <geekosaur> it's kinda terrible that we use the C preprocessor (and in fact causes a fair number of problems on systems without gcc; clang can't disable ANSI mode fully and can explode quite impressively when it sees some Haskell constructs) but it's been a thing for years and we have to live with it now
21:45:40 <geekosaur> mostly because CPP makes a number of portability issues more tractable than they would be otherwise
21:45:52 <Clint> it also seems to break doctest not infrequently
21:46:33 <Lokathor> I admit it, I have written code that uses the CPP
21:46:58 <Lokathor> I needed a way to check the bits of an Int# during compilation and compile the right version
21:46:58 <jchia1> so, i suppose I have to figure out what that macro is doing. I can't find where MV_Int32 is defined. Any idea?
21:47:40 <geekosaur> at a guess, somewhere in the source related to mutable vectors
21:47:46 <jchia1> nevermind, i found it
21:47:52 <jchia1> it's a data constructor for a newtype
21:49:44 <joe9> geekosaur: That worked well. Thanks.
21:50:42 <jchia1> So Data/Vector/Unboxed/Base.hs has a primMVector CPP macro that's used to defined an instance. I suppose I would have to copy that macro into my code in order to use it and when I upgrade the vector package, I'd have to be careful to sync to the new version, correct? Sounds dangerous.
21:51:24 <geekosaur> it does sound dangerous, but I suspect it does not change often
21:52:04 <geekosaur> because changing it could lead to incompatibility in or between programs using it
21:54:05 <jchia1> geekosaur: I'll think I'll take the simple approach and used a boxed vector for now, but it's a little sad that we can't easily have unboxed vectors for newtypes based on simple types.
21:54:50 <geekosaur> it is. I suspect it's also Hard. and like I said, I am vaguely recalling the Unbox situation being one of the inspirations for a deriving extension that's being discussed
21:55:34 <geekosaur> it's not going to be in any 8.0.x release but might make 8.2 if they get it ironed down (and the bikeshedders do seem to have agreed on a color finally...)
21:55:59 <geekosaur> ghc-devs mailing list is good to follow for this kind of thing
21:56:53 <jchia1> well, it'll be good to have. it'll be even better if i can use the same field name for different records unqualified
21:57:04 <jchia1> it's unrelated, but i find that issue more pressing
21:57:25 <geekosaur> that's a different extension and I don't know its current status. there's sme of the machinery in 8.0 but the rest is pending
21:59:17 <jchia1> I think it's OverloadedRecordFields
21:59:29 <geekosaur> yeh
21:59:44 * geekosaur just found the 8.2.1 plans page, deriving strategies is definitely a candidate
22:00:10 <Lokathor> does OverloadedRecordFields make a fake typeclass and then shove all the correct record types into that class or something?
22:01:05 <geekosaur> doesn't sound like ORF is in the 8.2.1 plan as yet
22:01:25 <geekosaur> Lokathor, essentially. HasField indexed by a type level string
22:01:33 <geekosaur> which is the field name
22:01:49 <Lokathor> fancy
22:02:28 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1 has pointers
22:02:56 <geekosaur> actually DuplicateRecordFields is already in
22:03:11 <geekosaur> full overloading is yet to be completed
22:31:47 <haskell797> i did like. hello = hello. Then i next if i type "hello==hello", it doesnot show prompt anymore and i have to inturrupt by Ctrl+c. Why is that?
22:33:13 <haskell797> i did like. hello = hello. Then next if i type, "hello==hello", it does not show prompt anymore and i have to interrupt by "Ctrl+c". Why is that?
22:33:43 <haskell797> Anyone can help please?
22:34:34 <implementation_> haskell797: you've built an endless loop.
22:34:51 <implementation_> or endless recursion, if you prefer that word
22:34:58 <haskell797> how it is a endless loop?
22:35:23 <Myrl-saki> I need frp halp.
22:35:30 <Myrl-saki> I need some kind of stateless IO.
22:36:05 <Myrl-saki> Errr
22:36:08 <implementation_> haskell797: for "hello == hello" you need to evaluate "hello". "hello" expands to "hello", which expands to "hello" and so on.
22:36:19 <Myrl-saki> By that, I mean that successive calls on the same time results in the same result.
22:36:36 <haskell797> ahh got it. Thanks!!
22:36:58 <Lokathor> haskell797, remember that when you write "hello = hello", it doesn't evaluate that right away, it saves that for later and only does it if it needs to, which is why the hello==hello is the trigger problem
22:41:32 <saurabhnanda> anyone interested in a PAID haskell web-dev project: https://angel.co/vacation-labs/jobs/175267-haskell-developer-for-a-small-proof-of-concept-webapp
22:43:24 * hackagebot tcp-streams 0.5.0.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.5.0.0 (winterland)
22:44:14 <joe9> When using FFI, is there a difference between using CInt vs Int? I read that even Int is marshallable. Then, why bother with CInt?
22:45:35 <pacak> joe9: CInt is 32 bit always. Int can be 64 bit.
22:45:52 <joe9> pacak: so, safer to stick with CInt then.
22:46:12 <joe9> pacak: Thanks.
22:46:28 <Lokathor> joe9, are you using inline-c perhaps? I'd look into it if you're doing FFI stuff. Makes FFI a breeze
22:46:36 <ongy> until we get a platform where the CInt is something different than 32bit. Wasn't it 16bit on x86 (with out _64)
22:48:28 <geekosaur> no, it was 16 bit on 80286 and earlier
23:49:35 <glguy> joe9: Int is marshalable and it maps to HsInt in the C world.
23:50:28 <glguy> if you're importing an existing C procedure you wouldn't use that, but if you're defining one in you package you might
23:58:17 <dfeuer> Data.Distributive.collect smells like a Yoneda improvement of distribute. Is there a Coyonedaish version?
