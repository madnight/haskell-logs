00:00:11 <erisco> briefly, strict means you evaluation arguments before application, and lazy means you evaluate application before arguments
00:00:29 <ongy> erisco: I didn't fail at a point where it wasn't usuable. I failed at a point where I didn't like what I was doing and stopped
00:00:53 <erisco> ongy, I think you've got the wrong person
00:01:09 <nshepperd> IO actions are indeed *executed* in order though
00:01:44 <erisco> they're executed at the time they evaluate, yes, thankfully
00:01:51 <ongy> I was repsonding to "would have to fail spectacular"
00:02:23 <ReinH> kody1: do notation is sugar for normal expressions with >>= and >>, and normal expressions use lazy evaluation rules.
00:02:29 <ReinH> This means that do notation also uses lazy evaluation rules.
00:02:39 <Cooler> @src (++)
00:02:39 <lambdabot> []     ++ ys = ys
00:02:39 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
00:02:39 <lambdabot> -- OR
00:02:39 <lambdabot> xs ++ ys = foldr (:) ys xs
00:02:45 <erisco> ongy, oh, well, I was just saying that worrying about data structure performance for a mindsweeper clone is probably not going to have any noticeable effect
00:02:52 <kody1> okay. thanks a lot guys
00:03:02 <ReinH> evaluation happens "outside in", but values are only produced when demanded (by case scrutinization, a.k.a. pattern matching)
00:03:20 <ReinH> in do notation, this looks a lot like "top-down"
00:03:34 <ReinH> but it is not strictly accurate to say that evaluation in Haskell is "top-down"
00:03:53 <ReinH> an expression "above" another expression may not be evaluated at all
00:04:15 <erisco> oh, that sort of "top-down" … like top-to-bottom i.e. procedural
00:04:24 <ReinH> at least, that's how I took it
00:04:47 <Kvasir> I'm doing the little prompt screen at the top of haskell.org
00:04:49 <Kvasir> its pretty cool
00:04:51 <Kvasir> :D
00:04:53 <erisco> Haskell is not procedural but you'll find code that purposefully looks like it is
00:05:31 <erisco> so that you may just think procedurally when it suits
00:05:37 <ReinH> > do let x = undefined in return (1 + 1) :: Maybe Int
00:05:40 <lambdabot>  Just 2
00:05:52 <ReinH> let x = undefined would cause a runtime error if x were scrutinized
00:06:02 <ReinH> but x is not scrutinized, so it does not
00:06:11 <ReinH> despite it being "above" return (1 + 1)
00:06:18 <kody1> Wow. Thanks a lot!
00:07:11 <erisco> composition looks procedural, or Kleisli arrows
00:07:36 <nshepperd> execution is not evaluation
00:07:37 * hackagebot fixfile 0.6.0.0 - File-backed recursive data structures.  https://hackage.haskell.org/package/fixfile-0.6.0.0 (rev_null)
00:07:37 * hackagebot posix-acl 0.2.0.1 - Support for Posix ACL  https://hackage.haskell.org/package/posix-acl-0.2.0.1 (NicolaSquartini)
00:08:11 <erisco> nshepperd, what distinction do you have between these?
00:08:17 <nshepperd> IO actions in a do block are executed strictly in order. variables and things are evaluated whenever they are needed, and no sooner
00:08:55 <erisco> there is nothing special about how IO actions are evaluated, no special rules for executing them in order
00:09:06 <nshepperd> the output of (putStr "foo" >> putStr "bar") is "foobar"
00:09:13 <ReinH> sequencing is enforced by >>= and >>
00:09:14 <nshepperd> (to the console)
00:09:30 <nshepperd> this has nothing to do with any special evaluation order
00:09:37 <nshepperd> it's execution order
00:09:39 <erisco> for an analogy, because you can't clearly see under the hood of IO, look at State
00:09:50 <erisco> there are no special execution order rules
00:10:01 <erisco> I am not sure how execution and evaluation are different to you though
00:10:28 <nshepperd> execution is 'when does an IO action happen'
00:10:55 <nshepperd> 'when is something actually printed, when you use putStr?'
00:11:31 <erisco> okay, well, it is executed when it is evaluated
00:11:37 <nshepperd> the answer is that the meaning of 'putStr "foo" >> putStr "bar"' is 'first print "foo" then print "bar"'
00:12:07 <nshepperd> erisco: 'putStr "foo" `seq` ()' doesn't print anything
00:12:19 <erisco> what is seq? this is a GHC thing
00:12:45 <nshepperd> mixing up evaluation and execution really isn't helpful
00:13:02 <erisco> it isn't mixed up, it is just that execution happens when evaluation happens
00:13:22 <erisco> when else should it happen? seems to be the point of the design of IO
00:13:30 <amalloy> that's not true, though
00:13:36 <nshepperd> why are you asking people to reason about evaluation order just to know when things are printed???
00:13:38 <amalloy> you can evaluate an IO action without executing it
00:14:10 <erisco> amalloy, how do you do this?
00:15:04 <cocreature> erisco: seq
00:15:21 <erisco> I don't know what seq is, just that it is a GHC thingie
00:15:22 <cocreature> I can seq my IO actions, write them to an IORef, pass them around, … all without executing them
00:15:22 <erisco> is there any other example?
00:15:37 <erisco> seq is cheat codes, I don't care about that so much
00:15:48 <nshepperd> or by putting it into a strict field then case matching it out again. if you insist on pretending only Haskell98 exists
00:16:38 <erisco> I don't understand the sense you're getting at
00:16:48 <erisco> what is being evaluated?
00:17:13 <erisco> an IO action is a function looking for the world state
00:17:25 <erisco> you can evaluate to the function, but the function isn't applied, that isn't evaluated
00:17:25 <nshepperd> now that's a GHC thingie
00:17:44 <nshepperd> you don't have to implement IO as awful RealWorld# hacks
00:18:13 <ReinH> RealWorld#, which is neither Real nor a World.
00:18:18 <nshepperd> and you certainly don't need to tell people who are trying to understand how IO works all about the GHC implementation
00:18:37 <ReinH> Much as grapenuts are neither a grape nor a nut.
00:18:41 <erisco> I could read it, but how does the language spec define it?
00:19:03 <erisco> that may be how GHC chooses to do it, but I don't see it as unreasonable, seems as straight-forward as State is
00:19:23 <Cooler> nshepperd, isn't the evaluation order forced by >> and >>= too?
00:19:40 <nshepperd> erisco: in the haskell report, IO is an abstract type
00:19:46 <Cooler> to evaluate f in x >>= f you need x?
00:19:56 <ReinH> erisco: I mean, do you know what the state is that is encapsulated by IO?
00:20:12 <ReinH> (in the GHC impl.)
00:20:20 <erisco> ReinH, know in what sense?
00:20:35 <erisco> that I am aware RealWorld has no value?
00:21:03 <erisco> all I am interested in is the same picture State gives
00:21:26 <erisco> this seems like a reasonable understanding of IO to me
00:21:38 <erisco> I would be interested to hear your other formalisation
00:21:40 <nshepperd> Cooler: for some monads
00:22:45 <erisco> "x >> y" means "do x then do y" isn't a precise description
00:22:54 <nshepperd> erisco: IO can be implemented as a free monad over some functor listing all the primops
00:23:03 <nshepperd> erisco: but you're mixing up the implementation and the interface
00:23:23 <nshepperd> "do x then do y" is a perfectly sensible description of the interface
00:23:33 <erisco> nshepperd, I am not, I am just choosing the example of State as the meaning
00:23:41 <erisco> you want to choose something else, that is fine, but it doesn't seem precise to me
00:23:45 <erisco> not as precise as State, for example
00:24:54 <erisco> there is this semantics which I also like https://wiki.haskell.org/IO_Semantics
00:25:24 <ReinH> yeah, that's the free monad approach nshepperd mentioned
00:25:31 <erisco> yes
00:25:46 <Cooler> nshepperd, i think what erisco's point is that the evaluation order forces the execution order?
00:26:38 <nshepperd> my point is that even thinking about evaluation order is a completely wrongheaded way to understand IO
00:26:40 <erisco> Cooler, well, it seems more nuanced than this, so it is probably not worth thinking of it that way
00:26:59 <erisco> if you're thinking in terms of State it is correct, for what I can tell
00:27:05 <nshepperd> especially when the understanding using evaluation order is a total lie as exhibited by seq
00:27:32 * hackagebot psi 0.1.0.0 - Yet another custom Prelude.  https://hackage.haskell.org/package/psi-0.1.0.0 (fractalcat)
00:27:42 <ongy> nshepperd: but why does 'putStr "str" `seq` ()' not print? how is execution triggered?
00:28:00 <erisco> it isn't seen by main
00:28:21 <erisco> main yields a sequence of instructions to be executed
00:28:26 <dkasak> ongy, it's triggered by an IO value getting "sent" to the RTS from main.
00:28:27 <erisco> if your instruction isn't there it isn't executed
00:28:44 <amalloy> ongy: the only IO action in your entire program that gets run is the one named "main". main is typically composed of smaller IO actions combined together with >>=, but seq doesn't do that: it just throws away its left argument
00:28:59 <erisco> at least this is another story you can tell :P
00:29:00 <ReinH> in what sense is 'putStr "str" `seq` ()' evaluating putStr "str"?
00:29:25 <ongy> so it's about the way >>= works in IO and not forcing the value that evaluates the IO?
00:29:32 <erisco> seq evaluates to whnf or some such
00:29:38 <ReinH> Because I think "evaluation up to WHNF" and evaluation as used above are different things
00:29:39 <ongy> amalloy: then how does unsafePerformIO play into this?
00:29:49 <amalloy> cheat codes, pretend it doesn't exist
00:30:02 <erisco> and the State interpretation predicts that whnf of an IO action does not execute the IO action
00:30:09 <slack1256> that is the gameshark of the console ;-)
00:30:18 <erisco> so it is no counter-example in that regard
00:30:20 <nshepperd> ReinH: in the usual haskell sense of evaluating values to whnf?
00:31:00 <nshepperd> of course I know what erisco meant was probably "taking out the function from IO, applying it to a value, then evaluating the result"
00:31:10 <ReinH> If you expect putStr "str" `seq` () to print "str", do you expect Just undefined `seq` () to throw a runtime error?
00:31:11 <nshepperd> but that's not what they said
00:31:12 <cocreature> ReinH: in the sense that undefined `seq` () would throw an exception. so the left hand side is at least evaluated until you can determine that it’s not bottom
00:31:35 <hamme> man my hand's cramping
00:31:37 <ReinH> cocreature: yes, up to WHNF.
00:31:41 <hamme> minesweeper rpg is p great
00:31:46 <erisco> nshepperd, well this is what the RTS does with main, it does runState
00:31:57 <ReinH> but main is not evaluated up to WHNF
00:32:42 <ReinH> so I don't see what seq has to do with the evaluation of main
00:32:51 <nshepperd> see, now you've confused everyone with the talk of low level implementation details in terms of evaluation order
00:33:07 <erisco> nshepperd, if you think I am talking low-level implementation details then I presume you missed what I've said
00:33:28 <erisco> you are choosing the free monad interpretation, that is fine, I like that one too
00:33:31 <Cooler> is execution even talked about in the haskell spec?
00:33:36 <nshepperd> which could have been avoided by just referring to the free monad semantics that make perfect sense and have no evaluation order complications
00:33:37 <erisco> I was choosing the State interpretation, which also works
00:33:45 <erisco> there is nothing low level about either
00:33:50 <erisco> they are both semantics for IO
00:34:16 <erisco> you just have your favourite semantics for IO, it seems :P
00:34:30 <nshepperd> actually I really mean abstract semantics
00:34:46 <erisco> I don't know what the difference is
00:34:49 <Cooler> is execution even talked about in the haskell spec?
00:34:58 <erisco> I don't care how GHC does it, I don't know how it does it
00:35:06 <erisco> I am not referring to GHC in any way
00:35:48 <ongy> then what's "well this is what the RTS does with main, it does runState"?
00:35:53 <erisco> with the State semantics, the evaluation order corresponds to the desired execution order, that is all I am saying
00:36:33 <erisco> ongy, I don't know, what is your objection?
00:36:34 <nshepperd> so when someone comes in here asking if IO actions in haskell are executed in order
00:36:35 <Cooler> anyone?
00:36:43 <ReinH> Cooler: https://www.haskell.org/onlinereport/io-13.html
00:36:53 <nshepperd> you say "yes, they are executed at the same time they are evaluated"
00:37:16 <erisco> that's right
00:37:25 <nshepperd> and then this person goes away thinking you've told them something about the actual evaluation order of things in an actual implementation of haskell
00:37:51 <erisco> that is the actual order, and it is no more a claim about how GHC works than your favourite semantics is
00:37:52 <nshepperd> and probably all sorts of completely confused ideas about what is actually going on
00:38:35 <erisco> it precisely describes what is going on, it is not confused
00:38:36 <nshepperd> gah
00:38:54 <nshepperd> no it doesn't
00:39:04 <erisco> okay, well, that's enough circles :P
00:39:20 <nshepperd> you didn't even elaborate on the difference between evaluating (runIO f) and (runIO f s)!
00:39:36 <erisco> I wasn't asked, and I don't know what runIO is
00:39:54 <nshepperd> no, because you just said 'evaluation order'
00:40:13 <ReinH> The Haskell Report has very little to say about any semantics for IO
00:40:15 <erisco> because it is correct
00:40:53 <ReinH> It says some things about the behavior of particular IO actions, and some hand wavey things about sequencing.
00:41:35 <nshepperd> why do you need to implant confusing ideas about evaluation order in people's heads in order to explain what IO means?
00:41:48 <Cooler> ok what exactly do they mean preserve the sequencing?
00:41:58 <erisco> you think it is confusing, that is fine, you have a semantic you prefer, use it, I am not stopping you
00:42:05 <erisco> share it with others, I am also not complaining
00:42:08 <Cooler> "Haskell 's I/O monad provides the user with a way to specify the sequential chaining of actions, and an implementation is obliged to preserve this order."
00:42:11 <erisco> I happen to like it as well
00:42:18 <Cooler> what way are they talking about?
00:42:26 <Cooler> >>= and >> ?
00:42:27 <erisco> the State one just isn't wrong, so I have no qualms with using it
00:42:32 <nshepperd> Cooler: yes
00:42:58 <amalloy> i think erisco's point is that the only meaningful way to make an IO action become needed, barring "cheat codes" like seq, is in fact for main to include it
00:43:01 <Cooler> nshepperd, but >>= and >> create data dependencies that force evaluation order
00:43:05 <nshepperd> erisco: is the State on a correct interpretation of the free monad implementation of IO?
00:43:14 <Cooler> they don't sequence anything
00:43:14 <ongy> The sequencing is that 'print "foo" >> prit "bar"' is foobar and not barfoo
00:43:21 <amalloy> at which point you can reasonably enough say that as soon as the IO value is evaluated it is executed
00:43:32 <erisco> nshepperd, could you rephrase the question?
00:43:33 <merijn> amalloy: No, you really can't
00:43:53 <ongy> Cooler: that's implementation detail (if it's correct, I have no idea)
00:44:22 <erisco> amalloy, I don't think there is any argument about main's involvement
00:44:38 <Hijiri> > (putStrLn "blah") `seq` 5
00:44:40 <nshepperd> erisco: is your State 'interpretation' correct with respect to a data type I personally define using Free and a Functor listing all the primops?
00:44:42 <ReinH> The only thing it really says is that IO actions "must be ordered in a well-defined manner".
00:44:46 <lambdabot>  mueval-core: Time limit exceeded
00:44:46 <lambdabot>  mueval: ExitFailure 1
00:44:49 <merijn> amalloy: Try doing "map force $ map print [1..10]" (force being from deepseq which forces it's argument completely
00:44:50 <Cooler> ongy, well the creating the data dependencies isn't implementation detail is it?
00:44:57 <Cooler> part*
00:45:12 <allenj12> hey, its been a while since I touched haskell and I think someone mentioned a replacement for cabal last time? If cabal still sux? im also on windows till next week if it matters
00:45:24 <nshepperd> erisco: this data type being exactly equal in expressive power to the actual IO in ghc?
00:45:27 <amalloy> of course, merijn. but erisco is talking about a world with no operations like seq, just pure computation of IO values which main eventually executes
00:45:33 <hamme> I learned about the markers
00:45:40 <hamme> now I cleared minesweeper rpg faster
00:45:40 <erisco> nshepperd, how am I to know your personal definition? oO
00:45:57 <Hijiri> amalloy: in that case you could still evaluate an IO action once and get multiple executions
00:45:58 <nshepperd> erisco: use your imagination
00:46:08 <Hijiri> so evaluations don't match up with executions
00:46:09 <ReinH> Cooler: where do you get the idea that >>= and >> "create data dependencies that force evaluation order"?
00:46:20 <Hijiri> like let x = putStrLn "blah" in x >> x
00:46:20 <erisco> nshepperd, they are different semantics and describe the same thing, so yes either can be used
00:46:27 <merijn> amalloy: Even in that world (especially in that world!) evaluating and execution are completely independent
00:46:34 <nshepperd> erisco: what same thing
00:46:56 <erisco> amalloy, as far as I understand seq, seq is not a problem for the State semantics, as I have explained
00:47:12 <cocreature> amalloy: removing the ability to evaluate IO actions just removes the ability to easily observe that evaluation and execution are different things
00:47:17 <nshepperd> erisco: and why would you describe my implementation of IO as a semantics
00:47:23 <merijn> seq is a problem for anything, as seq doesn't have any denotational meaning :p
00:47:43 <ReinH> merijn: it isn't a problem for IO, because neither does IO!
00:47:53 <merijn> ReinH: true :p
00:48:31 <allenj12> I think it was this https://docs.haskellstack.org/en/stable/README/ is stack still used over cabal?
00:48:35 <erisco> nshepperd, I am confused as to what you're trying to get at. I do not understand where your objection lies, other than you find it confusing, which is fine
00:48:56 <ReinH> I still think there is some equivocation going on in the use of "evaluate", and that seq is being used as evidence for the wrong one.
00:49:01 <Cooler> ReinH, uh it doesn't?
00:49:05 <allenj12> well i think most ppl use cabal still, but as an alternative?
00:49:21 <ReinH> Cooler: How can >> create a data dependency?
00:49:36 <ReinH> Why must >>= create a data dependency?
00:49:49 <erisco> terminology has been an issue, as well as what we're talking about… semantics, implementation, GHC, main, so on
00:49:53 <nshepperd> augh
00:49:55 <ReinH> in ``return "foo" >>= ...'', what data dependency is created?
00:50:21 <Cooler> well then what do they mean by a way to sequence in the spec?
00:50:31 <ReinH> that one thing must come before another thing
00:50:32 <merijn> Cooler: That's unspecified
00:50:41 <ReinH> other than that, we don't know
00:50:48 <merijn> Cooler: HOW you sequence things is left up to the specific implementation
00:50:50 <Cooler> do they literally mean that if you write   x >>= f    x needs to be executed first then f or something?
00:50:58 <merijn> Cooler: GHC happens to do one thing, but that's not mandatory
00:50:59 <erisco> I probably am not being as precise as I could be because I am really tired
00:51:01 <ReinH> We don't know.
00:51:04 <merijn> Cooler: Yes
00:51:22 <hamme> nshepperd, on " mixing up evaluation and execution really isn't helpful", is it better to say that the construction of IO values and the execution of IO () are different?
00:51:44 <merijn> hamme: Yes
00:51:48 <merijn> hamme: Because they are
00:52:09 <ReinH> construction of IO values is not evaluation of IO values
00:52:18 <ReinH> Just like construction of [1..] is not evaluation of an infinite list
00:52:24 <erisco> there was an article that plainly walks through the State example, but not likely to find it now oO
00:52:29 <merijn> hamme: Although, if we're pedantic ReinH is correct
00:52:41 <ReinH> merijn: if not that, then what?
00:53:12 <merijn> ReinH: Fair enough
00:53:14 <Cooler> i thought the execution order was forced by creating data dependencies on the previous actions so they would HAVE to be executed first
00:53:26 <ReinH> I mean, the subject of this debate is in large part the meaning of terms like "evaluation" so being pedantic on that point seems especially justified
00:53:33 <merijn> Cooler: That is what GHC *does*, but it's not required by the language standard
00:53:40 <erisco> I agree that construction of IO values is not evaluation of IO values, this is not what I meant by it, as I tried to clarify when seq was brought up
00:53:55 <erisco> and State also makes this clear
00:54:00 <merijn> Cooler: If you find some other way to do it, even magic, you're allowed to when you implement Haskell
00:54:02 <Cooler> merijn, but like ReinH said how does >> create a data dependency?
00:54:02 <ReinH> erisco: I was responding to hamme 
00:54:19 <erisco> ReinH, and I was howling into the night sky :P
00:54:37 <hamme> The rest that I know of, and I've only glossed over the chapter in the book, merijn nshepperd , is that IO also prevents charing since it needs to presuppose uniqueness of IO values, because things liek getLine are necessarily not non-unique
00:54:39 <ReinH> TIL I am the night sky
00:54:48 <merijn> Cooler: Now you're asking a different question, specifically: How does GHC implement the IO monad such that it creates data dependencies
00:54:59 <ReinH> hamme: getLine is unique
00:55:03 <ReinH> every getLine is the same getLine
00:55:10 <merijn> Cooler: To which the answer is: Read the "Lazy Functional State Threads" paper, which describes exactly this :)
00:55:51 <geekosaur> don't even need that, just consider State
00:56:00 <ReinH> in exactly the same way that every () is "the same" ()
00:56:23 <hamme> It also said that "State" and "Realworld" don't do much for what IO does
00:56:36 <ReinH> said by whom?
00:56:55 <geekosaur> in the sense that neither is relevant to how IO can perform I/O actions, that is correct
00:57:13 <geekosaur> otherwise put" IO is not weird because it is a monad; it is weird because it is IO"
00:58:08 <hamme> "However [state] is less meaningful or helpful than you think
00:58:39 <ReinH> Who said that?
00:58:44 <nshepperd> erisco: my main complaint is that vaguely talking about evaluation order in order to explain execution order without precisely describing what you are talking about is guaranteed to totally and utterly confuse newbies. It is doing actual damage to their understanding
00:59:08 <ReinH> I don't like responding to what "they" said. "They" can say anything.
00:59:15 <nshepperd> secondary is that in any implementation that doesn't use this State stuff, your interpretation is literally wrong
00:59:17 <erisco> nshepperd, 1) it isn't vague, see State, 2) it is precise, see State
00:59:31 <hamme> Next paragraph, it doesn't tell you much what State# does underneath IO
00:59:49 <erisco> it isn't wrong, it doesn't matter what the implementation uses
00:59:57 <nshepperd> you can map things to this State world with 'evaluation order', but that will be different to the actual evaluation order
00:59:58 <erisco> it matters than it has the same actions in the same sequence
00:59:59 <ReinH> hamme: next paragraph of what?
01:00:08 <nshepperd> in which things are actually evaluated
01:00:11 <nshepperd> in real life
01:00:15 <nshepperd> in the actual machine
01:00:18 <hamme> First Principles, p1001, first page of the IO Chapter
01:00:30 <hamme> So expect it not to be complete, but not wrong
01:00:38 <nshepperd> erisco: _what you said_ was vague
01:01:06 <nshepperd> erisco: if you had sent a link to a paper, that wouldn't have been vague
01:01:11 <ReinH> That sounds like an opinion.
01:01:17 <ReinH> Rather than a statement of fact.
01:01:23 <erisco> nshepperd, okay, *shrug*, I don't think so. I would also direct you to a suitable article but I do not have one at hand right now
01:01:33 <hamme> "State#'s not meaningful because the state value, RealWord has no value, there's no interaction you'd expect from state, normally"
01:01:38 <nshepperd> exactly!
01:01:43 <nshepperd> you would but you didn't
01:01:47 <ReinH> hamme: that is certainly true
01:01:50 <ReinH> Real
01:01:51 <nshepperd> do everyone's loss
01:02:08 <ReinH> RealWorld is neither Real nor a World.
01:02:10 <erisco> nshepperd, um, may I remind you that I was the one to link to the article describing your semantics?
01:02:57 <erisco> particlewaves are neither particles nor waves XD
01:02:59 <hamme> Anyways, the most I can scrounge up on this page is that it's more or less to assert the uniqueness of IO Actions, not necessarily values/constructions, and the ordering of IO Actions
01:03:12 <ReinH> erisco: grapenuts are neither grapes nor nuts.
01:03:29 <erisco> peanuts are neither peas nor nuts. er, wait…
01:03:35 <nshepperd> 03:11:08         erisco | okay, well, it is executed when it is evaluated
01:03:39 <nshepperd> is this precise?
01:04:08 <hamme> Evaluation can construct values, instead of an execution of an IO Action
01:04:20 <erisco> the evaluation order satisfies the desired execution order
01:04:28 <ReinH> fsvo "it", "executed", "when", "it", "evaluated", and "is", it is precise.
01:05:00 <hamme> construction seems to do whatever
01:05:03 <ReinH> erisco: correct (on peanuts)
01:05:10 <nshepperd> i'm told that peanuts are actually legumes
01:05:59 <hamme> I'm told that humans are apes
01:06:08 <hamme> (because THEY ARE)
01:06:21 <hamme> definition of a Hominid
01:06:43 <hamme> (because YOU STILL ARE ONE)
01:06:50 <Cooler> abs are not a or bs
01:07:22 <erisco> nshepperd, I believe this is the article here that I recall https://wiki.haskell.org/IO_inside
01:07:36 <shachaf> This all seems to have moved far away from the topic of this channel.
01:07:54 <shachaf> The Haskell part would maybe best be continued in #haskell-overflow
01:08:24 <hamme> Looking at the topic
01:09:05 <hamme> only talks about off-topic channel, and the mod channel
01:10:01 <ongy> how many haskell-* channels are there?
01:10:05 <hamme> uh
01:10:08 <Cooler> so with regards to how GHC implements things, can you say that execution order is forced by evaluation order?
01:10:09 <hamme> 30+
01:10:53 <erisco> I don't know how the compiler and runtime implement things
01:10:56 <hamme> not necessarily? Someone said above that a function above another function can be lazy about the above function
01:11:00 <int-e> Cooler: what's the difference of the two concepts, in your mind?
01:11:13 <erisco> all I know is that you can use evaluation order to determine the desired execution order
01:11:15 <Cooler> what 2 concepts?
01:11:24 <int-e> Cooler: execution and evaluation
01:11:37 <hamme> well let me tell you
01:11:50 <hamme> evalState, and execState are pretty different
01:11:55 <hamme> :^)
01:12:06 <Cooler> well evaluation is beta reduction in lamda calculus as i read in "Haskell programming from First Principles"
01:12:48 <hamme> It gets interesting in the chapter of non-strictness, but I'm not that far
01:12:51 <Cooler> and execution is done of the IO action given as main
01:14:22 <ReinH> Ok, I figured it out. This is the Haskell version of "how a bill becomes a law".
01:14:26 <hamme> It seems a bit more general than that since you can have stranger forms of execution. Strict and Lazy IO
01:14:38 <hamme> Seems like a structural thing
01:14:42 <erisco> ReinH, do we have to know how it works in real life first?
01:14:43 <Cooler> ReinH, as in it never does?
01:15:26 <erisco> hamme, lazy IO is advised against, instead use pipes or conduit
01:15:52 <hamme> but then you have strange things like mindful lazy IO in attoparsec
01:15:54 <int-e> Cooler: okay. then yes, the way IO is encoded in ghc (each action being a function taking a real world token and returning a new one), execution order is encoded as a data dependency so any possible evaluation respects the execution order.
01:16:04 <hamme> Lazy stream of strict bytestring chunks
01:16:13 <hamme> when dealing with an iterating parser
01:16:31 <hamme> heard about it from the recent paper on Twisted Functors, Yorgey et al
01:16:44 <hamme> namely, the second to last page iirc
01:17:15 <Cooler> int-e, but ppl seem to suggest thats not the only way you can do it
01:17:21 <erisco> the problem with lazy IO, other than you don't know when it happens in relation to other IO actions, is you cannot catch errors
01:17:48 <erisco> have you worked with an ORM in OOP? remember how they execute database queries when you read an object property? same thing
01:17:57 <erisco> unpredictable disaster :P
01:18:07 <hamme> so that in lies the confusion/seperablity of exxecution and evaluation of IO
01:18:09 <ReinH> Lazy IO is not advised against. Lazy IO is fine for many things.
01:18:11 <hamme> seemingly, anyways
01:18:16 <erisco> with the benefit of being simpler when it is all working
01:18:34 <hamme> Object Relation M?
01:18:56 <erisco> hamme, "lazy IO" is a thing different than what we have been talking about for the past while
01:19:24 <hamme> It's not true IO?
01:19:30 <erisco> this is things like unsafeInterleaveIO
01:19:39 <hamme> by golly, it puts sugar in its grits
01:19:55 <erisco> ReinH, what things do you have in mind?
01:20:25 <erisco> straw house uses? easy to set up, easy to blow down?
01:20:47 <int-e> Cooler: Yes, it's an implementation detail. For example, instead of the token, one could pass around continuations. putStrLn :: String -> (() -> a) -> a. Or have a concrete datatype  IO a where PutStrLn :: String -> IO ()  and a free monad on top of that.
01:21:02 <ReinH> Reading files, writing to files. The usual sort of things you do with IO.
01:21:31 <ReinH> It has tradeoffs, as does non-lazy IO
01:21:51 <erisco> non-lazy IO is the brick house, it is more work to set up, but it is sturdy
01:22:02 <ReinH> Nah
01:22:09 <ReinH> It depends what you're doing
01:22:18 <Cooler> erisco, i think the use is for stuff like where you try to get the contents of a file
01:22:26 <erisco> but you'd agree that it is an engineering decision, i.e. trade-offs, yes?
01:22:38 <Cooler> instead of reading the entire contents, it reads as needed
01:22:59 <erisco> this is mistaken though, Cooler, because lazy IO is not necessary for streaming files
01:23:14 <erisco> look to pipes or conduit for an alternative
01:23:47 <Forlorn> for list = [(3,2), (4,3), ...] is it possible to do something like: getifany (\(x,y)-> x*y % 3 == 0) list
01:23:57 <Forlorn> it should stop directly after finding one item
01:24:20 <lyxia> what's getifany
01:24:20 <Forlorn> this is just an example, I am going to use it for something else entirely
01:24:30 <lyxia> is it find?
01:24:31 <Forlorn> that's the function I am wondering aobut
01:24:37 <Forlorn> about*
01:24:39 <Forlorn> ah
01:24:39 <ongy> what does it return?
01:24:58 <Forlorn> the first time which satisfies the condition
01:25:03 <Forlorn> item*
01:25:06 <lyxia> so it's find
01:25:10 <Forlorn> thank you
01:25:20 <Cooler> @src find
01:25:20 <lambdabot> find p = listToMaybe . filter p
01:25:45 <erisco> int-e, hamme, not seeing your whole discussion, it is should be noted that method X isn't just an implementation detail just because that is how GHC does it
01:25:50 <Cooler> doesn't filter return everything that matches? not just one?
01:26:17 <ongy> Cooler: but listToMaybe only takes the first element of the list
01:26:28 <ongy> and thanks to lazy evaluation, nothing further is evaluated
01:26:32 <erisco> int-e, hamme, any semantic necessarily describes what the program is, so you can just interpret this semantic as your implementation
01:27:43 <Cooler> is lazy evaluation forced by the spec?
01:27:49 <merijn> erisco: This is why we distinguish operational and denotational semantics
01:28:00 <int-e> erisco: in my preferred semantics, IO a would be completely abstract, and I would then specify how a >>= b and the IO operations are executed.
01:28:09 <merijn> erisco: Discussions on operational semantics are fine, but it should be clarified that we're using that
01:29:06 <int-e> erisco: (and I may have no room in there for lazy IO, since it leaks an implementation detail)
01:29:12 <ReinH> > listToMaybe . filter (== 1) $ [1 ..]
01:29:15 <lambdabot>  Just 1
01:29:19 <ReinH> Cooler: ^
01:29:30 <hamme> that takes the first value
01:29:39 <hamme> if any
01:29:45 <Cooler> yeah
01:29:54 <erisco> lazy IO is more cheat codes, so, I wouldn't try too hard on it :P
01:29:59 <hamme> until you get screwed with the realisationt ha tit only returns when there is a value
01:30:18 <hamme> rip in codata
01:30:20 <ReinH> filter isn't guaranteed to produce any values
01:30:29 <ReinH> but if it does, find will as well.
01:30:46 <hamme> filter on an infinite doesn't necessarily return a value, let alone normalise
01:31:46 <hamme> so, find takes the first value as well? Or am I forgetting that lookup is analogous
01:31:47 <Cooler> is lazy evaluation forced by the spec?
01:32:02 <ReinH> Yes.
01:32:14 <ReinH> well, no
01:32:17 <ReinH> non-strict evaluation is
01:32:22 <int-e> > take 4 [1..]
01:32:23 <ReinH> lazy evaluation is one way to achieve that
01:32:25 <lambdabot>  [1,2,3,4]
01:32:40 <hamme> don't stare into the abyss
01:32:44 <hamme> of laziness
01:32:54 <int-e> (Any Haskell implementation where that bottoms out will be useless.)
01:32:57 <hamme> you might find the wuji
01:33:08 <erisco> merijn, what does operational semantics mean to you?
01:33:18 * hamme has their chakras well and thoroughly blitzed
01:33:30 <Cooler> so no implementation can be strict?
01:33:40 <ReinH> Correct.
01:34:06 <hamme> you can have both, that's why strict analysis became a thing
01:34:21 <int-e> Cooler: You can make a strict implementation but I suspect that there is almost no Haskell code out there that you could run on it.
01:34:44 <ReinH> No implementation that follows the spec, at least
01:34:45 <erisco> I thought strictness analysis was just to optimise cases where it made no difference semantically
01:34:51 <erisco> (though there are no official Haskell semantics, oddly)
01:34:57 <Cooler> int-e, well i mean an implementation based on the spec
01:35:12 <ReinH> strictness analysis has nothing to do with the haskell spec
01:35:14 <hamme> all I know is that it's throwing bang patterns, and reading GHC Core to see where laziness should be removed
01:35:16 <merijn> erisco: Operational semantics are "what actually happens in a specific implementation". If we're talking operational semantics, we're talking GHC, State#, GHC implementation of thunking, etc.
01:35:38 <ReinH> and the haskell spec has likewise nothing to say about strictness analysis
01:36:03 <hamme> So, can the conversation be moved where it is talked about
01:36:06 <hamme> Like GHC
01:36:13 <erisco> merijn, I would have said something else. I am not quite sure how to clearly qualify that definition
01:36:29 <erisco> though I am not sure how to clearly qualify operational semantics even as I'd say it
01:37:00 <ReinH> operational semantics is the semantics of program execution rather than program meaning.
01:37:05 <ReinH> (which is denotational semantics)
01:37:34 <erisco> which is you have an initial state and a sequence of instructions which operate on this state, i.e. a machine
01:37:53 <erisco> if you describe a program in this fashion you're describing it operationally, as a sequence of "do this and then do that"
01:37:58 <merijn> erisco: That's what you do in, e.g. C, because your machine is too much of a mess
01:38:10 <hamme> So denotational semantics is the meaning of a program
01:38:18 <merijn> erisco: You define an "abstract virtual machine" and then describe operational semantics on the machine
01:38:19 <erisco> semantics is meaning, full stop
01:38:29 <Cooler> erisco, you could just say State Machine
01:38:48 <ReinH> hamme: well, with operational semantics, we just say that what the program does *is* what it means, but yes.
01:38:48 <merijn> hamme: Denotational semantics is "the abstract meaning of a program", i.e. not related to execution, CPUs, compilation, etc.
01:38:55 <erisco> merijn, I do not think we're disagreeing here
01:39:16 <erisco> merijn, I would just add then when we're talking about how GHC works we may be doing so denotationally
01:39:22 <int-e> Cooler: I'm trying to actually find that in the specs... https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-600003.17.2 may be the best we have?
01:39:39 <merijn> erisco: No, that doesn't make sense
01:40:03 <hamme> Oh man, ReinH you were write about fickle humans
01:40:03 <erisco> merijn, okay, well, then we mean different things
01:40:06 <merijn> erisco: Denotational semantics assumes we map program source to a mathematical object with defined behaviour and reason about that
01:40:09 <int-e> (there's a formal semantics below)
01:40:17 <hamme> I want to continue reading this
01:40:24 <merijn> erisco: In that sense there's no way to tie GHC into things
01:40:38 <erisco> merijn, that's right, and so if we're talking about how GHC does IO are we talking about registers or free monads or State or what?
01:40:56 <merijn> erisco: If you use a different meaning for denotational semantics...you are bound to get into a lot of confused discussions
01:41:00 <hamme> burritos
01:41:06 <erisco> I am not changing the meaning here
01:41:07 <merijn> erisco: For operational semantics all of those are fair game
01:41:16 <ReinH> There is no denotational semantics for IO.
01:41:19 <merijn> erisco: If we're talking denotational semantics, then none of those make sense
01:41:37 <hamme> because that's the point to operational semantics, having differences?
01:41:42 <erisco> okay, there is perhaps imprecision here again
01:41:44 <merijn> erisco: ReinH is right, there is no denotational semantics for IO. So if we're talking IO we can not be talking denotational semantics
01:41:51 <erisco> by "IO" I mean "IO actions", not the effects of those actions
01:42:05 <merijn> erisco: IO as a whole has no denotational semantics
01:42:15 <erisco> I disagree, this is clearly not the case!
01:42:16 <merijn> erisco: Because you can't give one without accounting for effects
01:42:43 <erisco> https://wiki.haskell.org/IO_Semantics is one such example
01:42:43 <merijn> erisco: Let me rephrase: No one has ever defined a useful denotational semantics for IO
01:42:55 <ReinH> That is not a denotational semantic.
01:43:10 <erisco> why does that not qualify to you?
01:44:06 <ReinH> Well, what form of denotational semantics is it?
01:44:11 <ReinH> Scott-Strachey?
01:44:43 <erisco> I'm only at the part they go on about lattices
01:44:47 <Cooler> ReinH, i think because it isn't operational semantics, it has to be denotational instead?
01:45:01 <Cooler> the only 2 possibilities?
01:45:05 <ReinH> There are others
01:45:15 <merijn> Cooler: No
01:45:16 <erisco> but in the sense that you can map syntax to semantics, yes, it is Scott-Strachey afaik
01:45:26 <merijn> Cooler: There's plenty of things that are neither
01:45:36 <ReinH> As far as I can tell, that post just uses "semantics" in an informal way.
01:45:48 <merijn> Cooler: "gkwlhwl" is not an operational semantics, that doesn't mean it's denotational semantics
01:45:50 <ReinH> The fact that it contains the word "semantics" does not mean that it gives a denotational semantics for IO.
01:46:08 <Cooler> merijn, well i mean its not nonsense, its accurate about the program
01:46:19 <erisco> it is informally given, but can be formalised with all the mathy symbols if you'd like
01:46:23 <ongy> which still doesn't mean it's semantics
01:46:27 <erisco> it isn't a particularly friendly way to explain it
01:46:36 <ReinH> Can it?
01:46:50 <erisco> you're going to ask I do this?
01:46:52 <ReinH> How do you know that it can be?
01:46:54 <Forlorn> what's wrong with the following code: http://sprunge.us/aLDd
01:46:54 <Forlorn> ?
01:46:58 <ReinH> If you're going to assert that it is so, yes
01:47:07 <ReinH> Otherwise it is an unfounded assertion
01:47:17 <erisco> I'm not that motivated to convince you :P
01:47:19 <Cooler> i think because it describes IO semantics AND because its not operational semantics therefore its denotational?
01:47:27 <ReinH> And I am not motivated to believe you.
01:47:38 <ReinH> Cooler: again, no
01:47:40 <erisco> seems fair
01:47:41 <merijn> Cooler: There's other semantics
01:47:44 <ongy> Forlorn: what's digs?
01:47:46 <ReinH> First, it isn't any sort of formal semantics
01:47:50 <erisco> there are axiomatic semantics, for example
01:47:52 <ReinH> second, they are not a dichotomy
01:47:55 <merijn> Cooler: Also, I'm noy convinced this IS a semantics
01:47:59 <erisco> though if there is a fourth category I am unaware of it
01:47:59 <Forlorn> ongy, http://sprunge.us/bXNC
01:48:09 <Forlorn> a list
01:48:34 <ReinH> merijn: The title says "semantics", so obviously this must be a formal denotational semantics
01:48:39 <ReinH> just, you know, without the "mathy bits"
01:48:52 <ReinH> You can't prove that I can't prove that it isn't.
01:48:53 <Forlorn> oh it is Bool not Boolean
01:49:44 <ReinH> This is becoming somewhat of a common refrain for me, but it's once again applicable:
01:49:58 <ReinH> thing are not true until proven false
01:50:19 <ReinH> It isn't a denotational semantics *because I can't prove that it is not*
01:50:22 <erisco> ReinH, I didn't just read the title, if that is what you were implicating
01:50:34 <Cooler> well things CAN be true until proven false
01:50:39 <erisco> nor did I make any assertion that it is because you can't prove it isn't
01:51:15 <Cooler> ReinH, also a person is innocent until proven guilty
01:51:18 <erisco> you can investigate it yourself, which is the only reason I asked if you were going to make me do it
01:51:37 <ReinH> The truth value of things is unknown until it is proven one way or another
01:51:53 <ReinH> but we don't go around assuming that every notion is true just because we thought of it
01:51:57 <Cooler> Therefore Unicorns are real!, i dare you to prove me wrong
01:52:01 <Cooler> XD
01:52:10 <erisco> Cooler, they found the unicorn already, you know
01:52:24 <ReinH> I think Louis CK actually said this one best. You can't have "nothing isn't".
01:52:33 <Cooler> O_o
01:52:50 <merijn> That article is far too informal and underspecified to work as a formal semantics
01:53:18 <merijn> Additionally, far smarter people, such as Conal Elliott have tried to define a denotational semantics for IO repeatedly and failed
01:53:20 <ReinH> It's possible that it could be worked into a formal semantics
01:53:20 <erisco> it certainly isn't given formally, that isn't being questioned
01:53:28 <ReinH> but that wouldn't be Haskell's semantics
01:53:32 <hamme> question, Ford_Prefect 
01:53:35 <ReinH> just what some person would like Haskell's semantics to be
01:53:39 <hamme> Where is digs defined
01:53:41 <erisco> we are just talking about what qualifies as denotational
01:53:55 <erisco> but it is also worth asking what we're trying to capture in the meaning of IO
01:54:11 <ongy> hamme: they posted that one a bit later, but realized it was the wrong type (Boolean instead of Bool)
01:54:12 <Cooler> well let me try
01:54:12 <erisco> I imagine conal was aiming for something much greater
01:54:20 <hamme> yep, ongy 
01:54:21 <Cooler> x >>= f   x has to be executed before f
01:54:22 <ongy> also you highlighted the wrong person
01:54:26 <Cooler> there you go
01:54:39 <hamme> i'm out of it
01:54:47 <erisco> the semantics I am interested in here says absolutely nothing as to the content of the actions
01:54:53 <erisco> not a single thing, they are nothings, they are just names
01:55:15 <erisco> then perhaps conal was trying to give meaning to the actions themselves
01:55:38 <merijn> erisco: That doesn't work, because one of the key properties of denotational semantics is that "Soundness: All observably distinct programs have distinct denotations"
01:55:40 <erisco> we were only ever talking about order earlier, and these semantics are just about order
01:56:03 <erisco> merijn, that is just a question of what you're looking at
01:56:13 <merijn> erisco: What you what is only possible if we say that EVERY program has the same denotation, because we can't distinguish the actions anyway
01:56:15 <Cooler> erisco, i think what you are trying to capture is one-wayness?
01:56:25 <merijn> erisco: So all programs are equivalent
01:56:37 <merijn> erisco: At which point your semantics might be correct, but also useless
01:56:43 <erisco> under a sufficiently weak denotation all programs are equivalent, of course
01:56:46 <erisco> I see no problems with this
01:57:12 <erisco> there is no reason a denotation has to capture every single notion, in fact it is incoherent to even pose that
01:57:16 <erisco> the denotation is what it is
01:59:21 <Cooler> if every program is the same then every program has the same order
01:59:32 <erisco> so, unsatisfactory because it says nothing about the content of IO actions, yes, absolutely
02:01:05 <ReinH> If you're arguing about the definition of a word, one way out is to redefine it into oblivion.
02:01:13 <Cooler> what semantics are we even talking about other than >>= and >>?
02:01:40 <erisco> haha, well I am fine disagreeing on what qualifies as denotational semantics
02:01:56 <erisco> I'll try to make it clear when I am talking about my fucked up version of it
02:02:04 <ReinH> perhaps by using a different word
02:02:05 <Gurkenglas> Requesting an inhabitant of "MaybeT (StateT s []) a -> MaybeT (StateT s []) a -> MaybeT (StateT s []) a" that does not inhabit "Monad m => MaybeT m a -> MaybeT m a -> MaybeT m a"
02:02:12 <erisco> erisco semantics
02:02:32 <ReinH> that's just, like, your program's opinion, man
02:02:34 <erisco> there is nothing incompatible about this with Scott-Strachey that I can discern
02:02:46 <Gurkenglas> ("How do I get at the hidden Alternative instance?")
02:03:08 <ReinH> well, so far we don't have anything we can compare with Scott-Strachey
02:03:35 <ReinH> so either two incomparable things are compatible, or the notion of compatibility between two incomparable things is itself meaningless
02:03:35 <erisco> the semantic function is not precisely defined, you're right
02:03:44 <ReinH> I guess I don't care which you choose
02:04:01 <lyxia> Gurkenglas: \a b -> get >>= \s -> a <|> (put s >> b)
02:04:28 <ReinH> We also don't have a formal denotational semantics (in the usual sense) to compare anything to
02:04:33 <ReinH> since, again, IO doesn't have one
02:04:53 <erisco> we can talk about what the semantics must include
02:05:08 <ReinH> We could, but we can't say anything normative
02:05:14 <erisco> do you acknowledge a semantics that does not include the content of actions?
02:05:32 <merijn> That's just haskell's evaluation
02:05:39 <erisco> if you don't then there is no hope from the get-go
02:06:32 <Cooler> erisco, so you mean the actions have different names depending on their effects but the effects have nothing else to do with the semantics?
02:06:33 <ReinH> Without the content of IO actions, IO is an incredibly boring state monad that does nothing at all
02:06:42 <ReinH> in GHC, at least
02:06:46 <ReinH> and in Haskell, it has no meaning whatsoever
02:07:00 <ReinH> it does literally nothing
02:07:26 <ReinH> there is nothing that requires a semantics in the first place
02:07:59 <erisco> Cooler, in the semantic you can see different action names, the sequence of actions, and input, but you cannot see what actions do to the outside world
02:08:00 <ReinH> the only things that the report says about IO are that computations must be sequenced, and that certain actions do certain things.
02:08:12 <erisco> Cooler, so in that sense the actions have no content in the semantics
02:09:08 <erisco> I don't know how you could begin on that task without first modeling the whole world
02:09:17 <Cooler> ReinH, it says certain actions do certain things? like what?
02:09:28 <erisco> making some fairly arbitrary choices as to what this model should contain
02:09:52 <erisco> if we're interested in file systems then we can include file systems in the semantics
02:10:12 <ReinH> The IO chapter of the report is short, and most of it gives examples of particular IO actions
02:10:13 <erisco> can it be a semantic easily adaptable to new features? maybe, I don't know
02:10:35 <erisco> to give a generic semantics? no idea
02:11:04 <Cooler> ReinH, wait thats the actual spec? i thought that was just a high level overview
02:11:19 <ReinH> That's the report that defines the language.
02:11:22 <Cooler> this is the actual spec? https://www.haskell.org/onlinereport/io-13.html
02:11:26 <ReinH> Most of it is less hand wavey
02:11:36 <ReinH> The I/O chapter is notable because it's entirely hand wavey
02:11:53 <ReinH> that's the 1998 report, the 2010 report is https://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1420007
02:12:03 <ReinH> but this chapter is basically the same between them
02:12:21 <erisco> ReinH, it is retrofitting semantics, like https://en.wikibooks.org/wiki/Haskell/Denotational_semantics does
02:12:24 <Cooler> i was reading that thing as a tutorial
02:12:29 <erisco> unofficial but attempts to describe what is going on
02:12:36 <ReinH> the rest gives a formal grammar for the syntax, etc
02:13:01 <ReinH> erisco: and says nothing about IO
02:13:13 <erisco> that link? no, it doesn't
02:13:27 <erisco> I am just offering it as an example of retrofitting
02:13:47 <erisco> you said the report says nothing about IO, well, that link is also unofficial
02:14:04 <erisco> despite the report we can try and describe what is going on
02:14:17 <ReinH> we can make up stuff
02:14:50 <erisco> we're not shackled to the report
02:16:48 <Cooler> how does it qualify something as a IO action if IO is so abstract?
02:16:54 <Cooler> i mean so undefined
02:17:37 <merijn> erisco: We are if we're talking about haskell
02:17:40 <erisco> where is conal's work on IO semantics?
02:18:05 <erisco> that
02:18:10 <erisco> 's just nonsense
02:18:27 <erisco> we don't get to the next report, push the language forward, if we bar ourselves from ever talking outside the scope of the previous one
02:18:30 <merijn> erisco: If you want to make up a new implementation of Haskell that has more specific definitions than we can talk about that
02:18:45 <merijn> erisco: But then don't claim to talk about Haskell semantics
02:19:28 <erisco> so erase that wikibooks article?
02:19:29 <merijn> erisco: You're free to discuss alternative semantics. It might even be useful and interesting. But if you do so while claiming to discuss *haskell* semantics, you're simply wrong, because those details you're referring to are unspecified
02:20:15 <merijn> That wikibook seems, at first glance, to stick to the denotational semantics of Haskell
02:20:19 <merijn> Which *are* in the report
02:20:34 <erisco> where in the report are these things, I certainly didn't see it
02:20:51 <merijn> erisco: The places where it describes equivalence of evaluation
02:21:15 <merijn> It's not in one specific places, but the semantics of evaluation *are* described in the report
02:22:24 <merijn> erisco: In fact, the pattern matching section includes both a "formal" and "informal" semantics section
02:23:28 <merijn> including bottoms, etc.
02:23:30 <erisco> seems like a lot of threads to tie up to see if wikibooks gives a compatible semantics
02:23:38 <Cooler> merijn, but weren't we talking about IO semantics? not evaluation semantics?
02:23:46 <erisco> and IO is clearly undefined on the other hand, okay
02:24:15 <erisco> so on the topic of IO in Haskell we don't know much
02:24:34 <merijn> Cooler: erisco was arguing that he was free to add additional definitions to IO because people we're doing the same thing. I'm pointing out that the semantics of evaluation are actually covered in the report
02:25:38 <erisco> I wouldn't be too surprised if you could tie together "different actions", "sequence of actions", and "input", which is all the IO semantic was offering
02:25:41 <merijn> So, we can discuss semantics of IO for some specific implementation of Haskell, even one that does not exist. As long as we don't pretend we can generalise it to ALL haskell implementations. Because haskell implementations are free to do pretty much anything in the report
02:25:54 <erisco> I may try and do this but I am too tired right now, but I have the report section bookmarked
02:26:30 <merijn> erisco: Feel free to try. If you succeed in a useful way you might make a lot of people including me very happy. But given my personal efforts I'm not very optimistic about your odds ;)
02:26:36 <erisco> then, upon failing, yes, we can try and describe GHC
02:26:39 <Cooler> i think erisco asked the question what are we trying to capture with IO semantics
02:27:08 <Cooler> the order and one-wayness?
02:27:16 <erisco> merijn, do you need the content of actions in the semantics?
02:28:49 <erisco> if you do not need that then the task is drastically simplified
02:29:12 <erisco> I do not know how you give a semantic generically, i.e. not closed to a particular set of actions
02:29:21 <Cooler> erisco, how would actions be different without the content?
02:29:23 <erisco> and then even closed to a particular set of actions it could be woefully unpleasant
02:29:29 <erisco> Cooler, they have different names
02:30:19 <erisco> the semantic is enough that you can interpret it and add effects to these actions
02:30:30 <erisco> where is conal's work on this?
02:31:11 <Cooler> erisco, well the name could just be the content encoded in some language
02:32:22 <merijn> erisco: Dunno if it was ever published. You can probably just email him about it or ask him next time he's here
02:32:26 <erisco> ah and I am sure your going to want to through the concurrency wrench in there too
02:33:00 <erisco> you're, throw *
02:34:05 * Maxdamantus wishes someone would write a nicer implementation of IO so people stop talking about GHC's one.
02:34:18 <merijn> Maxdamantus: The problem is not the *implementation* of IO
02:34:25 <merijn> Maxdamantus: It's "what do we want it to mean?"
02:34:52 <erisco> I have never done anything concurrently in Haskell ... maybe once
02:34:59 <erisco> I cannot recall what this looks like
02:35:07 <Maxdamantus> So it's just the problem that all programming languages haev.
02:35:15 <merijn> Maxdamantus: Yeah
02:35:25 <Maxdamantus> What does it mean when someone does `FILE *f = fopen("foo", "rw");`
02:35:39 <merijn> Maxdamantus: All the effects stuff is not about IO being bad, but "what does it all mean?" and finer-grained control
02:35:40 <erisco> it gets the file
02:35:40 <Cooler> well don't you want IO to somehow capture the physical world?
02:35:46 <ongy> first of all we tell the kernel to ask the file system to....
02:36:22 <ongy> erisco: I would argue that that's plainly wrong, but that's really off topic since it's not even haskell related
02:36:57 <erisco> ongy, I would argue it is not even wrong ;) I am chuckling to myself over an awful IO lib which had just this nonsense
02:38:02 <erisco> merijn, we can have the discussion on what would be satisfactory as a semantic informally
02:38:25 <erisco> we have to first decide what we're interested in … though that can be the larger part of the problem
02:39:44 <Cooler> i still don't understand why you need more than to say x >>= f executes x and then f
02:39:49 <Cooler> to be formal
02:40:33 <erisco> the semantic I would be satisfied with tells you bupkis about what the actions are doing
02:41:28 <merijn> erisco: What *would* it tell you, then?
02:41:45 <erisco> which actions happen in which order, and what the inputs are
02:42:54 <erisco> then, say you know these things, you have a sequence of actions
02:42:57 <Cooler> and thats what i just said
02:42:59 <Cooler> the order
02:43:11 <erisco> you're then open to give semantics to these actions, i.e. what they actually do
02:43:21 <ongy> Cooler: that's only sequencing. If you want to say anything meaningful about IO you will have to formalize input/output
02:43:43 <Cooler> you mean what does "Execute" mean?
02:43:47 <erisco> IO is an open thing, external, and so it only makes sense to give the burden out in the same way
02:43:56 <merijn> erisco: But the report already specifies the sequencing of IO
02:44:34 <erisco> well then the idea outlined by https://wiki.haskell.org/IO_Semantics may be supported by the report
02:45:03 <Cooler> what about this
02:45:18 <Cooler> you sequence IO action1 before IO action2
02:45:33 <merijn> Now define what sequence means ;)
02:46:01 <Cooler> and you use the >>= or >> symbol to do it
02:47:09 <Maxdamantus> The effects of `a >> b` are the effects of `a` followed by the effects of `b`.
02:47:25 <Cooler> well if i "Execute" IO actions by giving the name of the IO action to something and pressing a button
02:47:39 <Cooler> then sequence means i give it IO action1 first
02:47:53 <ongy> Maxdamantus: when is an effect done?
02:48:05 <erisco> what is an effect? XD
02:48:09 <Maxdamantus> ongy: when the operation is run.
02:48:37 <erisco> if we want to talk about file manipulation then we need a formal model of the file system
02:48:46 <erisco> it is the only way we can talk about it in the semantic of file system actions
02:49:07 <erisco> given that IO does all sorts of stuff, an open world, this is untenable
02:49:43 <Cooler> although come to think of it IO action1 might involve activating a time machine to go back in time and put in IO action 2's anme first and pressing the button
02:50:29 <erisco> the most we can do for sure is say what actions our program wants to do, in order, and what inputs it awaits
02:50:37 <Maxdamantus> If you're willing to allow god hypotheses, you can't specify anything.
02:50:42 <erisco> everything else is up for grabs
02:50:59 <Maxdamantus> What if the program knows how to modify the memory used in normal evaluation?
02:51:25 <Cooler> but theres stuff that can already do that
02:51:39 <marrrk> Shouldn't overloaded strings take care of this:
02:51:39 <marrrk> checkForPrefix :: String -> [String] -> Maybe String
02:51:40 <marrrk> checkForPrefix prefix txt = L.find (T.isPrefixOf prefix) txt
02:51:41 <marrrk> ?
02:51:56 <Cooler> its not just a hypotheses
02:51:56 <Maxdamantus> Cooler: and we don't care, it's under the category of unsafe things.
02:51:58 <ongy> marrrk: no, OverlaodedStrings is for literals
02:52:04 <ongy> not for implicit conversions
02:52:11 <marrrk> Okay.
02:52:30 <marrrk> So I need to do something like pack or unpack explicitly, right?
02:53:04 <lyxia> What are the morphisms of the category of unsafe things?
02:53:04 <Cooler> Maxdamantus, well its not just god hypotheses then, its a lot of real things too
02:53:09 <ongy> yes
02:53:24 <ongy> also why are you passing around strings, if you want to do Text operations?
02:54:13 <marrrk> Umm
02:54:14 <erisco> maybe this goes off the mark, but at 6:00am this seems right … you tell your roommate "go to the store and buy some milk", what is the meaning of this?
02:54:50 <marrrk> So String always stands for [Char]?
02:54:59 <erisco> play around with that question and I think the nature of IO becomes clearer
02:55:20 <Cooler> erisco, well according to your semantics, its just a IO action with a name and no special meaning
02:55:24 <Cooler> or content
02:55:44 <marrrk> Ah right, it works with T.Text instead.
02:55:58 <marrrk> I thought String was overloaded to whatever was then actually used by the program
02:56:04 <erisco> Cooler, well, that is my conclusion, but the example is to explain towards that conclusion
02:56:06 <Cooler> erisco, also you have a notion of time
02:56:50 <ongy> no, String is always [Char]. OverloadedStrings is an extension for literals. It was explained to me that it just expands all string literals to (fromString ...)
02:57:14 <marrrk> Can I import only the Type Text so that I don't have to write T.Text all over?
02:57:22 <ongy> import Data.Text (Text)
02:57:26 <marrrk> ah alright
02:57:35 <marrrk> and then I can import it qualified afterwards?
02:57:47 <Cooler> erisco, the problem is you said you want order in your semantics and order is a notion based on execution
02:57:55 <Cooler> which lies outside your semantics
02:58:14 <ongy> yup
02:58:42 <erisco> order is in the semantics, do this then do that
02:59:00 <Cooler> expect "do" isn't in your semantics
02:59:18 <erisco> yes
02:59:27 <Cooler> what does do mean?
02:59:36 <Cooler> theres no content to "do"
02:59:36 <erisco> I am agreeing, it is not in the semantics
02:59:45 <Cooler> yeah
03:00:27 <marrrk> cool thanks
03:00:44 <erisco> in the exchange with the roommate, it would be incorrect to say that the meaning was, for example, "one less milk at the store, one more milk in the refrigerator"
03:00:49 <Cooler> i don't think you can formalize the real world
03:00:50 <hansihe> I seem to remember there being a repo/list of parsers for common languages implemented with parsec
03:01:04 <Cooler> atleast not from inside the real world
03:01:13 <hansihe> does anyone know about such a thing somewhere?
03:01:20 <erisco> why is this? because we do not control our roommate
03:01:52 <erisco> all we can do is make noises, which our roommate can hear, and our roommate has to give meaning to these noises and act on them
03:02:37 <marrrk> and in the REPL, how do I create a Text ?
03:02:44 <erisco> and so similarly, the semantics make noises, and an observer can listen to these noises and act on them
03:02:47 <Cooler> erisco, i mean you can break it down to quarks if you really wanted to
03:02:57 <Cooler> but thats off-topic
03:03:29 <erisco> this is what it truly means to be an outside effect, it is outside our purview
03:03:55 <erisco> if we pull in a complete understanding into our semantics then it is no longer outside
03:05:01 <Cooler> instead of going for IO as it is now, would it be better to restrict IO to something that you can model and formalize?
03:05:20 <ongy> marrrk: maybe you can start it with -XOverloadedStrings, or (T.pack "str") (if you have imported Data.Text as T)
03:05:28 <erisco> I am saying if you did that then it would no longer resemble what we cherish about IO
03:05:37 <Cooler> yes
03:05:44 <Cooler> but it may still be acceptable
03:06:44 <erisco> well, "cherish" may be too emphatic, but it is the open, non-omniscience that characterises it
03:06:46 <Cooler> like the switch from analog to digital, you lose infinite precision but you get 100% accuracy in return
03:07:20 <erisco> you can, yes, pull things into the semantics
03:07:32 <erisco> if you want to work with file systems and be precise about it you can do that
03:08:12 <Cooler> this leads to that Haskell OS
03:08:40 <marrrk> ah okay cool thansk
03:10:13 <Cooler> \
03:10:24 <erisco> note that in this sense I am not just using "IO" as a name for certain tasks, like writing to sockets or reading a file, or 
03:11:01 <Cooler> i think it even stops being IO
03:11:04 <erisco> I am using it in the sense of side effect, external effect
03:11:42 <Cooler> its not even Input/Output just interaction between quantum mechanical systems
03:11:46 <erisco> anything brought under our umbrella of knowledge ceases to be external
03:14:27 <Cooler> i think in that sense when it says "yet has all of the expressive power found in conventional programming languages."
03:14:41 <Cooler> i am not sure thats a good thing that its unrestricted
03:15:20 <erisco> Haskell itself you're saying?
03:15:29 <Cooler> yes
03:15:36 <athan> Cooler: It's good that you think that way :)
03:15:48 <erisco> well it seems to be a craggy cliff
03:15:49 <Cooler> because you can't formalize something thats unrestricted in that way
03:15:55 <DefinitelyNotAFK> > let x = if x /= 1 then 0 else 1 in x
03:16:02 <lambdabot>  mueval-core: Time limit exceeded
03:16:12 <athan> Cooler: Wait, what skill level are you with haskell?
03:16:20 <DefinitelyNotAFK> 3
03:16:20 <Cooler> learning
03:16:21 <erisco> look at languages, the Chomsky Hierarchy
03:16:45 <erisco> you can take, say, CFG and add indexes, and now you have some CSG-lite abomination
03:17:17 <erisco> you obtain startling capabilities with simple systems
03:17:32 <Cooler> yes a turing machine
03:17:38 <Cooler> can do anything
03:17:40 <erisco> from there it becomes increasingly mangled to add on features without bumping into the next level
03:18:09 <erisco> or so it seems … it doesn't seem that simplicity is uniform over the space of possibilities
03:18:38 <erisco> as something as simple as untyped LC and you have TM
03:18:59 <erisco> you have to get more complicated with STLC to reign it in
03:19:04 <erisco> funny how that works
03:21:51 <Forlorn> [1,4,9,16] if 4 is divisible by any greater number within the same list, 4 should be removed from the list
03:22:02 <Forlorn> I can't get my head around how to achieve this, any suggestions?
03:22:38 <mauke> numbers generally aren't divisible by greater numbers
03:23:30 <Forlorn> oh sorry
03:23:39 <Forlorn> I mean if a smaller numbers divides a greater number
03:24:01 <Forlorn> such as 4 divides 16 evenly
03:24:07 <mauke> 1 divides all of them
03:24:42 <Forlorn> yeah, so 1 should be removed
03:24:48 <erisco> Forlorn, sounds like you should start with filter
03:25:01 <erisco> that is good at removing elements
03:25:19 <mauke> Forlorn: is the input list sorted?
03:25:20 <Forlorn> I figure iterate and filter perhaps?
03:25:25 <Forlorn> idk
03:25:31 <erisco> filter iterates for you
03:25:32 <Forlorn> mauke, yeah
03:25:59 <Cooler> erisco, 2 loops
03:26:15 <erisco> filter (\x -> x `isNotFactorOf` xs) xs  seem like a start Forlorn?
03:26:48 <mauke> that rescans xs from the beginning each time
03:26:58 <erisco> are we going for performance awards?
03:27:14 <mauke> no, the other version is still O(n^2)
03:27:23 <Cooler> erisco, within reason, always
03:27:26 <mauke> but why waste work?
03:27:51 <erisco> do you hit ctrl+c as quickly as you can when you realise you've sent your program into an infinite loop?
03:27:54 <Forlorn> yeah, and perhaps `any` too
03:28:01 <mauke> > tails [1,4,9,16]
03:28:05 <lambdabot>  [[1,4,9,16],[4,9,16],[9,16],[16],[]]
03:28:23 <erisco> well, I do that :P
03:29:03 <erisco> anyways, if the problem is difficult to find any solution for, my last concern is exacerbating it with performance concerns
03:29:31 <erisco> find any solution first, that's the biggest problem out of the way, then refine if you want
03:30:49 <erisco> takes some seasoning to paint a masterpiece from the first stroke
03:31:15 <ongy> erisco: there are no mistakes
03:31:29 <mauke> x | x : xs <- tails [1,4,9,16], not (any (\t -> t `mod` x == 0) xs)
03:31:30 <erisco> only core dumps
03:31:37 <mauke> happy little core dumps
03:31:50 <Forlorn> [4,9,16] \\ filter (\x -> (any (\y -> y `mod` x == 0  )) ([4,9,16] \\ [x]) ) [4,9,16]
03:31:58 <Forlorn> I think something like this perhaps
03:32:12 <mauke> never \\
03:32:34 <[k-> you might have something there with the list comprehension 
03:32:46 <erisco> :t (\\)
03:32:49 <lambdabot> Eq a => [a] -> [a] -> [a]
03:32:55 <erisco> list difference, ah ha
03:33:09 <ongy> hm, I really don't know if that list comprehension is more readable than concatMap on itself
03:33:18 <ongy> I think it's set difference and assumes sets
03:33:24 <ongy> > "11" \\ "1"
03:33:27 <lambdabot>  "1"
03:33:38 <erisco> I liked  filter (\x -> x `isNotFactorOf` xs) xs  followed by filling in the definition for `isNotFactorOf` :P
03:34:32 <fr33domlover> or even this: filter (`isNotFactorOf` xs) xs
03:34:38 <[k-> filter can be done with a list comprehension!
03:34:49 <erisco> fr33domlover, you must have missed the sections debacle earlier
03:35:04 <erisco> [k-, list comprehensions are hideous!
03:35:16 <[k-> noooooooo you got them wrong!
03:35:17 <fr33domlover> erisco, yeah I probably missed them :P
03:35:32 <[k-> list comprehensions are beautiful!
03:35:51 <[k-> it's a do for lists only!
03:35:55 <mauke> @. pl undo [x | x : xs <- tails [1,4,9,16], not (any (\t -> t `mod` x == 0) xs)]
03:35:55 <lambdabot> (line 1, column 29):
03:35:55 <lambdabot> unexpected "{"
03:35:56 <lambdabot> expecting variable, "(", operator or ")"
03:36:15 <erisco> [k-, oh, they've generalised them
03:36:33 <[k-> what generalised what?
03:37:13 <int-e> what information does the hackage server display under "readme for <package>"? see, for example, http://hackage.haskell.org/package/haskell-src-exts (there's a headline "Readme for haskell-src-exts" immediately followed by another headline "Readme for haskell-src-exts-1.18.2")
03:37:40 <erisco> [k-, https://ghc.haskell.org/trac/ghc/wiki/MonadComprehensions
03:39:14 <Forlorn> [z | (x:xs) <- [4,9,16,32], y <- any (\v -> v `mod` x == 0) xs, z <- x, y == False]
03:39:17 <Forlorn> hmmm
03:39:22 <[k-> At least I can say, comprehension used to only work with lists
03:39:23 <Forlorn> I am failing
03:39:25 <mauke> never == False
03:39:43 <Forlorn> use `not var`?
03:40:02 <mauke> yes, but ... <- any ... makes no sense
03:40:06 <mauke> any doesn't return a list
03:40:18 <[k-> let y = any ...
03:40:22 <erisco> I am frugal with syntax, and list comprehensions do not pass muster… too niche, too complicated
03:40:36 <mauke> Forlorn: that looks a lot like my solution, though
03:40:50 <[k-> erisco -XNoFancySyntax
03:40:59 <Forlorn> mauke, I haven't looked at your solution
03:41:17 <erisco> [k-, is that real?
03:41:38 <[k-> I don't think so, I made it up, but there is a possibility 
03:41:41 <implementation> > ghc: unrecognised flag: -XNoFancySyntax
03:41:44 <lambdabot>  error: Variable not in scope: ghcerror:
03:41:44 <lambdabot>      Variable not in scope: unrecognised :: t0 -> aerror: Variable not in sco...
03:41:44 <lambdabot>      Data constructor not in scope: XNoFancySyntax :: [a]
03:41:54 <implementation> oh, sorry lambdabot
03:42:19 <ongy> is do notation fancy syntax?
03:42:33 <erisco> yes, but justified due to the marching problem
03:42:34 <[k-> It must be
03:42:58 <[k-> you could just indent at the same level!
03:43:40 <ongy> [k-: what's the connection with do and indention?
03:43:53 <[k-> the marching problem
03:43:54 <erisco> though do-notation is obscenely complicated
03:45:05 <[k-> is [1,3..99] part of list comprehension?
03:45:12 <Forlorn> mauke, [x | (x:xs) <- [4,9,16,32], not (any (\v -> (v `mod` x == 0)) xs)]
03:45:18 <Forlorn> why isn't this working, I get an error.
03:45:22 <Forlorn> :'(
03:45:26 <erisco> no, that's sugar on enumFromTo or some such
03:45:30 <ongy> Forlorn: what kind of error?
03:45:41 <Forlorn> Non type-variable argument in the constraint: Num [t]
03:45:43 <[k-> enumFromThenTo
03:46:05 <erisco> it is more syntax, but also fairly simple … I wouldn't miss it either
03:46:29 <[k-> i would miss the ability to be so expressive
03:47:00 <Forlorn> I don't see or understand the error
03:47:04 <mauke> Forlorn: because 4 is not a list
03:47:51 <ongy> Forlorn: try to add an explicit type annotation, the error gets a bit more readable
03:47:57 <fr33domlover> When list comprehensions make the code look like the math, they're nice. But I rarely use them. Only in those simple cases where they make the code reflect the idea
03:48:08 <Forlorn> ongy, how do I do that?
03:48:24 <ongy> if you are doing this in ghci just add ':: [Int]' to the end
03:48:32 <ongy> after the closing ']'
03:49:24 <iputra>  /quit
03:49:26 <iputra> exit
03:49:29 <mauke> > [x | (x:xs) <- [4,9,16,32], not (any (\v -> (v `mod` x == 0)) xs)] :: [Int]
03:49:31 <erisco> concision is important, no doubt … I have a feeling you could replace list comprehensions entirely with only slightly more verbose combinators
03:49:32 <lambdabot>  error:
03:49:32 <lambdabot>      • No instance for (Num [Int]) arising from the literal ‘4’
03:49:32 <lambdabot>      • In the expression: 4
03:49:47 <mauke> ah, that's basically what I said
03:50:30 <Forlorn> No instance for (Num [Int]) arising from the literal 4, what does this mean?
03:50:31 <erisco> and then there is TH to boot
03:50:46 <mauke> Forlorn: you're trying to use 4 as a list but it isn't one
03:50:49 <erisco> that means 4 is not a list of numbers
03:51:32 <[k-> i find ghc's errors are not presented in an intuitive manner
03:52:04 <Forlorn> I don't see where I am treating 4 as a list
03:52:15 <mauke> Forlorn: by matching it against x:xs
03:52:16 <Forlorn> x == 4, no?
03:52:19 <mauke> no
03:52:19 <erisco> maybe you're treating a list as a number
03:52:23 <erisco> one of the ways around
03:52:38 <Forlorn> x isn't 4 the first time around?
03:52:42 <mauke> no
03:52:43 <[k-> 4 cannot be pattern matched to x:xs
03:52:46 <mauke> Forlorn: your code is doing the equivalent of case 4 of x : xs -> ...
03:53:18 <mauke> <- iterates over the list
03:53:24 <mauke> the left side gets each element in turn
03:53:48 <mauke> _ : _ on the left side only makes sense if the right side is a list of lists
03:54:23 <erisco> [k-, using TH I added regex, on the back of tdfa-regex or whatever it is called
03:54:43 <Forlorn> ah I see
03:54:48 <Forlorn> now I understand what tails is for
03:55:09 <Forlorn> thank you
03:55:28 <erisco> [k-, would never wish it as part of the language like in JavaScript
03:55:48 <erisco> remember that syntax is canon, libraries are debatable
03:56:31 <erisco> take list comprehensions, for example, it arbitrarily chooses how to take the product
03:56:49 <erisco> > [(x,y)|x<-[1,2,3],y<-[4,5,6]]
03:56:52 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
03:57:13 <erisco> why that way, hm? doesn't work for infinite lists, for example
03:57:35 <mauke> eh? because it desugars to >>=
03:58:21 <erisco> this doesn't seem like a great reason to me
03:58:51 <erisco> I don't think the origin of list comprehensions was on how to make >>= with lists easier to read and write
03:58:57 <erisco> was it?
03:59:17 <erisco> or was it from the idea of set construction?
03:59:25 <erisco> set builder notation, or whatever it is called
03:59:51 <erisco> i.e. saying it desugars to >>= seems just the same as saying it arbitrarily chooses that order
04:00:47 <mpickering> list comprehensions are so called because they are like set comprehensions.
04:01:56 <ggVGc> I think one could argue that if you're using a list comprehension it should matter which order the elements come out. If you want a specific ordering, then a list comprehension might be the wrong tool
04:02:32 <parsnip> > do x <- [1, 2, 3]; y <- [4, 5, 6]; return (x, y)
04:02:34 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
04:02:54 <mpickering> I think erisco 
04:03:04 <mpickering> 's argument is that he wants the enumeration to be by diagonals
04:03:50 <ggVGc> I just realised I never use list as a monad
04:04:07 <erisco> I am saying that syntax is canon whereas libraries are debatable
04:04:12 <ggVGc> but that it might be useful
04:04:21 <erisco> so if you're going to make it official syntax it better be right, not arbitrary
04:04:40 <ongy> for some definition of "right"
04:04:45 <erisco> that comprehensions are generic to monads helps them greatly, though, it seems much more justified
04:04:45 <mpickering> and you can get that behaviour by choosing a different monad, such as Omega or LogicT
04:04:52 <mpickering> and you can do this by turning on MonadComprehensions 
04:05:30 <mpickering> isn't baking monads into the syntax too opinionated? 
04:06:11 <erisco> sans MonadComprehensions it is too expensive syntactically for its worth … just my preference on it
04:06:18 <erisco> I realise it is subjective
04:06:38 <ggVGc> I remember reading something about making do-notation more generic, e.g not being sugar specifically for Monad. What happened to that?
04:06:52 <mpickering> Do you mean RebindableSyntax?
04:06:57 <ggVGc> not sure, let me google
04:07:11 <mpickering> or maybe you mean ApplicativeDo
04:07:12 <implementation> ApplicativeDo?
04:07:30 <erisco> arrow notation?
04:07:37 <Cooler> @src Google
04:07:38 <lambdabot> Source not found. Are you typing with your feet?
04:08:31 <ggVGc> mpickering: yeah, I think that might have been it
04:08:37 <ggVGc> man, there are so many GHC extensions
04:08:45 <ggVGc> I hardly use any so far
04:08:45 <mpickering> I used it a few times and it was always quite fiddly
04:09:08 <mpickering> I hardly use any as well, in my latest project I've not even used the state monad.. 
04:09:23 <erisco> it is really a special thing that Haskell lets you override syntax as it does, which seems to be a particular benefit of type classes, i.e. static interfaces
04:09:26 <ongy> what's an example for a type that's applicative but not a monad?
04:09:27 <ggVGc> yeah I never got into using State either
04:09:30 <mpickering> the beautiful thing about Haskell is that it is easy to understand and very declarative
04:09:55 <ggVGc> I use LambdaCase a lot though
04:09:57 <marrrk> How would you parse a date like this: "Sun, 11 Sep 2016 12:52:38 +0200" ?
04:10:00 <ggVGc> but it's a very simple extension
04:10:09 <erisco> very declarative, much purity, such old memes
04:11:02 <ggVGc> haskell becomes fairly easy to understand when you know most of the commonly used operators
04:11:18 <ggVGc> but before that it's like alien mumbojumo
04:11:23 <ggVGc> at least it was for me
04:11:38 <erisco> Applicative but not a Monad … hm …
04:11:54 <mpickering> ongy: http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
04:13:05 <dibblego> Const, ZipList, Validation
04:13:25 <erisco> well those are some clever stupid examples
04:14:00 <erisco> not to you dibblego, was talking to the SO page
04:15:30 <erisco> ah, ZipList is on there
04:15:44 <marrrk> come on, what's a library that can parse dates?
04:15:55 <erisco> @hackage dates
04:15:55 <lambdabot> http://hackage.haskell.org/package/dates
04:16:02 <erisco> erm, good job lambdabot
04:16:33 <DavidEichmann> woooh! Go lambdabot!
04:16:41 <marrrk> Good
04:16:54 <marrrk> I never trust my googling
04:17:23 <Cooler> newtype T a = T (a -> Int)
04:17:28 <Cooler> whats happening herE?
04:18:15 <ongy> it's a new type T that takes a function from a to Int as argument (is that the right word here?)
04:18:21 <erisco> there is my, er, what did I call it … Spry or something
04:18:52 <erisco> that has a Monad instance though, whoops, now that I recall … it just happens to be an interesting one
04:19:47 <erisco> right, a spry is a list where no adjacent elements are equal
04:20:13 <erisco> this builds up to an interesting consequence at Monad
04:21:41 <DavidEichmann> Cooler, "newtype" is basically the same as "data" but you can only have one constructor with a single argument. At compile time the compiler will "erase" the newtype so all your T (a -> Int) values will actually just be (a -> Int) values. On the other hand this is different from "type T a = a -> Int" in that that "newtype" will typecheck, but "type" will not.
04:22:17 <dibblego> newtype is also strict in that argument
04:22:52 <Cooler> what do you mean it won't typecheck?
04:23:13 <DavidEichmann> so if you have...
04:23:17 <erisco> I describe Spry at the end of this answer here … http://stackoverflow.com/a/36971495/260584
04:23:25 <DavidEichmann> > type T a = a -> Int
04:23:28 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
04:23:52 <DavidEichmann> damn it lambdabot!
04:24:00 <erisco> it also includes ramblings on what "purity" means … I anticipate my notes being controversial
04:24:05 <DavidEichmann> $ type T a = a -> Int
04:24:24 <DavidEichmann> $ f :: T String
04:24:30 <erisco> if you figure out the answer I'll confirm it for you :D
04:24:33 <lyxia> > let f (Identity x) = () in f (Identity undefined)
04:24:33 <DavidEichmann> $ f str = length str
04:24:36 <lambdabot>  ()
04:24:42 <lyxia> dibblego: ^ not quite
04:25:58 <DavidEichmann> and you have.. (sorry for the long example)
04:25:58 <lyxia> hmm it doesn't contradict what you said actually
04:26:20 <DavidEichmann> $ g :: T String -> Int
04:26:53 <DavidEichmann> $ g tStr = tStr 42 
04:27:09 <DavidEichmann> ups.. I mean
04:27:36 * hackagebot bitcoin-payment-channel 0.2.3.1 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.2.3.1 (runeks)
04:27:36 <DavidEichmann> $ g tStr = tStr "hello" + 1
04:27:48 <DavidEichmann> then you can do this no problem:
04:27:58 <erisco> newtype is one of those ignorable things … just a performance tweak
04:27:59 <DavidEichmann> $ g f
04:28:17 <DavidEichmann> and it will give you 6
04:28:24 <erisco> someone is going to jump on about bottoms right? :)
04:28:57 <DavidEichmann> But if you had
04:29:23 <DavidEichmann> $ newtype T a = T (a -> Int)
04:30:30 <DavidEichmann> then f would need to use the T constructor else it would have the type (String -> Int) which is not the same as (T String)
04:30:54 <[k-> erisco: (about list comprehension) it's not arbitrary! It's a specific order!
04:31:05 <[k-> it's like nested for loops 
04:31:11 <Forlorn> how can I take the union of a list of lists?
04:31:30 <DavidEichmann> > Data.List.union
04:31:34 <lambdabot>  <[()] -> [()] -> [()]>
04:31:37 <erisco> [k-, arbitrary and random are different
04:31:53 <erisco> arbitrary and undefined are also different
04:32:11 <erisco> arbitration is to make one choice out of many, which list comprehensions have done
04:32:13 <[k-> it was not chosen arbitrarily!
04:32:14 <Forlorn> DavidEichmann, Data.List.union [[1,2], [2,3]]
04:32:31 <erisco> sure it was
04:32:38 <erisco> there are many possibilities for it
04:32:53 <Forlorn> I suppose I have to use union in combination with fold?
04:33:22 <DavidEichmann> you could use nub and concat
04:33:28 <DavidEichmann> > nub . concat
04:33:31 <lambdabot>  <[[()]] -> [()]>
04:33:32 <[k-> arbitrary
04:33:32 <[k-> ˈɑːbɪt(rə)ri/
04:33:32 <[k-> adjective
04:33:32 <[k-> 1.
04:33:32 <[k-> based on random choice or personal whim, rather than any reason or system.
04:33:39 <erisco> when you add in MonadComprehensions the design is no longer arbitrary, because it doesn't arbitrate the Monad … put in your own
04:33:39 <[k-> sorry 4 spam, oops
04:33:48 <Forlorn> foldl (\x y -> x `union` y) [] [[1,2], [2,3]]
04:33:50 <Forlorn> must be it
04:34:22 <erisco> [k-, yes that's right, one choice from many
04:34:23 <DavidEichmann> I think that would work, but you can simplify
04:34:34 <DavidEichmann> foldl union [] [[1,2], [2,3]]
04:34:51 <[k-> isn't without a reason the key meaning? o_O
04:35:17 <Forlorn> hm this is not giving the effect I want
04:35:25 <erisco> if the reason portion is to mean anything it must also reason against the alternatives
04:35:28 <Forlorn> [[],[2,2],[3,2],[2,2,2],[3,3],[5,2],[3,2,2],[7,2],[5,3],[2,2,2,2],[3,3,2],[5,2,2]]
04:35:37 <erisco> otherwise we're just arbitrating reasons
04:35:48 <[k-> erisco: I'm..
04:35:51 <[k-> lost
04:36:03 <erisco> just because it has a reason doesn't mean it isn't arbitrary
04:36:09 <Forlorn> I want to merge all the lists, so if we merge [2,2,2] with [3,2] we'll get [2,2,2,3]
04:36:11 <erisco> of course there is a reason, that is trivial to add to any choice
04:36:41 <[k-> Oh are you referring to what the List monad stands for?
04:36:46 <DavidEichmann> So Data.List.union treats duplicates differently:
04:36:51 <DavidEichmann> Duplicates, and elements of the first list, are removed from the the second list, but if the first list contains duplicates, so will the result. It is a special case of unionBy, which allows the programmer to supply their own equality test.
04:36:53 <[k-> that it represents possibilities?
04:36:55 <erisco> to make it not arbitrary you have to reason why all the other options are unsuitable
04:37:12 <ongy> Forlorn: do you want [2, 2, 2, 3, 2]? then it's just concat
04:38:15 <marrrk> How do I go from Either a b -> Maybe b ?
04:38:39 <ongy> @hoogle Either a b -> Maybe b
04:38:43 <lambdabot> Data.Either.Combinators leftToMaybe :: Either a b -> Maybe a
04:38:43 <lambdabot> Music.Theory.Either fromLeft :: Either a b -> Maybe a
04:38:43 <lambdabot> Agda.Utils.Either maybeLeft :: Either a b -> Maybe a
04:38:45 <erisco> and in this case, without the presumption that we need to be making a choice at all
04:38:53 <erisco> that is the point I am making against more syntax
04:39:37 <DavidEichmann> Forlorn, as ongy said you can just do concat, but that will leave duplicats. Is that what you want?
04:39:44 <marrrk> Hmm
04:39:48 <[k-> I'm lost, erisco, lost!
04:39:51 <marrrk> ongy they are all on the left value
04:40:06 <ongy> I am confused aswell. Maybe you will have to define it yourself (I remember doing that)
04:40:25 <erisco> [k-, okay, lets just consider two possibilities. One of them is as it is now, and another is diagonalisation (like Cantor)
04:40:29 <[k-> This is the problem with IRC, we dont have topic sentences!
04:40:40 <marrrk> Hmm.
04:40:48 <ongy> int-e: is it weekend for you now? You told me to remind you about Lambdacase
04:40:59 <[k-> what are we finding the possibilities for?
04:41:12 <erisco> the order of product
04:41:20 <erisco> > [(x,y)|x<-[1,2,3],y<-[4,5,6]]
04:41:22 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
04:41:52 <[k-> erisco: it's similar to a nested for loop 
04:42:14 <erisco> our language currently does not have list comprehensions, we're working on a new proposal
04:42:48 <erisco> how do we justify list comprehension syntax in place of "let the libraries handle it"
04:42:50 <[k-> erisco: ok, so you are proposing a mock language here
04:42:58 <Forlorn> ongy, DavidEichmann, no, [2,2,2] `operation` [3,2] will give us [2,2,2,3]. NOT [2,2,2,3,2]. [1,1,1,1,1] `operation` [1,1,1] = [1,1,1,1,1]
04:43:14 <erisco> I am trying to explain the sense in which it is arbitrary
04:43:25 <DavidEichmann> marrrk Data.Either.Combinators.rightToMaybe
04:43:35 <Forlorn> so if we have [2,2,2,2,2] `op` [2,2,2,2] `op` [2,2,2] `op` [2,2] `op` [2
04:43:37 <ongy> Forlorn: so you want all elements not yet in the first argument, but keep duplicates?
04:43:38 <Forlorn> ]
04:43:43 <Forlorn> [2,2,2,2,2]
04:43:49 <Forlorn> equals ^
04:44:02 <marrrk> thanks
04:44:23 <[k-> oh, when you explain it that way, I get it. But this way, I reckon, is the most intuitive (for me, at least)
04:44:26 <DavidEichmann> > concat [[2,2,2],[3,2]]
04:44:28 <lambdabot>  [2,2,2,3,2]
04:44:35 <erisco> if you start off the top assuming it has to be syntax and it has to be >>= then you're going to miss the point
04:44:35 <Forlorn> ^ incorrect
04:44:48 <DavidEichmann> What do you expect?
04:44:55 <soLucien> how can i make sure that my data Curve = Curve[Point]
04:44:55 <soLucien>  cannot be instantiated with an empty list ?
04:45:00 <Forlorn> [2,2,2,3]
04:45:30 <erisco> from here, I've acknowledged that with MonadComprehensions the proposal is no longer arbitrary, because we can stick in our own Monad instances
04:45:56 <erisco> then lauded Haskell's typeclasses for letting us do this
04:45:57 <maerwald> soLucien: smart constructors, don't export Curve
04:45:59 <[k-> didn't you say the proposal was already integrated
04:46:04 <Forlorn> it only retains the maximum degree of a number
04:46:18 <Forlorn> like
04:46:21 <erisco> MonadComprehensions? I don't know if it is on by default
04:46:32 <[k-> oh, because monadcomprehensions follow list comprehensions, it is not arbitrary 
04:46:37 <maerwald> soLucien: or use a non-empty list for that
04:46:41 <[k-> but list comprehension is arbitrary 
04:46:50 <[k-> is that what you were trying to say?
04:47:00 <maerwald> soLucien: https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-List-NonEmpty.html
04:47:22 <ongy> Forlorn: you may want to change the representation (something like (val, count)) and do something like: map max . group . concat
04:47:35 <erisco> [k-, follow them? I am not sure what you mean
04:47:44 <DavidEichmann> I still don't understand what you want.
04:47:47 <ongy> whre you have to define max and group on your own (there's groupBy for this, not sure what's the best for max)
04:48:11 <Forlorn> DavidEichmann, [1,2,3], [3,3,2], [3,7,11, 11], [3,3,3,3,2,11]       -->    [3,3,3,3,  11,11,  2]
04:48:18 <Forlorn> is the pattern more clear now?
04:48:40 <DavidEichmann> right I see
04:48:41 <Forlorn> sorry -->    [1, 3,3,3,3,  11,11,  2]
04:48:49 <Forlorn> and 7
04:49:05 <[k-> it needs to be enabled with {-# LANGUAGE MonadComprehensions #-}
04:49:27 <erisco> I don't know if I can succeed in explaining at this point :P
04:49:52 <[k-> erisco: I'm confused at what you are saying and you are confused about what I am saying!
04:50:37 <ongy> Forlorn: have you seen my suggestion?
04:51:35 <[k-> monadcomprehensions isn't arbitrary because we can decide the monad??
04:52:18 <Forlorn> ongy, yes, I am trying ^^
04:52:34 <erisco> MonadComprehensions truly turns the syntax into sugar on Monad, and we can supply our own Monad instances, yes
04:53:03 <Forlorn> ongy, [[],[[2,2]],[[3],[2]],[[2,2,2]],[[3,3]],[[5],[2]],[[3],[2,2]],[[7],[2]],[[5],[3]],[[2,2,2,2]],[[3,3],[2]],[[5],[2,2]]]
04:53:03 <[k-> list comprehension is the same for the list monad
04:53:07 <erisco> whereas initially list comprehensions is based on set builder notation and from that premise the product order is arbitrary
04:53:26 <[k-> what is the set builder notation
04:53:30 <Forlorn> I get a list like this, now I need to only keep the lists with the most duplicates
04:53:40 <Forlorn> and remove the rest
04:53:57 <erisco> [k-, https://en.wikipedia.org/wiki/Set-builder_notation
04:54:06 <ongy> Forlorn: let's take a smaller example
04:54:08 <ongy> :t groupBy
04:54:11 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
04:54:30 <Forlorn> ongy, [[[2,2]],[[3],[[2,2,2,2]]]
04:54:36 <erisco> lets take a completely different example of the same sense of arbitrariness
04:54:44 <erisco> are you familiar with Alternative for Maybe?
04:54:51 <Forlorn> ongy, [2,2] has smaller length than [2,2,2,2] therefore [2,2] must be removed
04:55:03 <ongy> > groupBy (\x y -> head x == head y) . concat $ [[[2,2]],[[3],[[2,2,2,2]]]
04:55:05 <[k-> I'm not familiar with alternative
04:55:06 <lambdabot>  <hint>:1:73: error:
04:55:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:55:13 <erisco> are you familiar with Monoid?
04:55:21 <[k-> no :(
04:55:24 <ongy> > groupBy (\x y -> head x == head y) . concat $ [[[2,2]],[[3]],[[2,2,2,2]]]
04:55:32 <lambdabot>  mueval-core: Time limit exceeded
04:55:32 <lambdabot>  mueval: ExitFailure 1
04:55:34 <ggVGc> are there any plans to bring an Effects system like in PureScript to Haskell?
04:55:46 <erisco> well this my example not so good then
04:56:06 <Cooler> erisco, a monoid is just a ring?
04:56:10 <minn> With locally nameless representations of lambda-terms, do you need to do any shifting when performing substitutions or beta-reducing (assume call-by-value with no reduction under binders)? I'm starting at some code, and not seeing anything jump out.
04:56:34 <erisco> Cooler, a group sans inverses
04:56:41 <[k-> a wedding ring?
04:57:30 <erisco> Cooler, just an identity and associativity
04:57:58 <Cooler> erisco, so no + -
04:58:44 <erisco> I suppose so
05:00:32 <Forlorn> ongy, that doesn't work
05:00:38 <erisco> [k-, the brief summary is that type class instances are unique, you only get one per type
05:00:49 <ongy> Forlorn: it got a bit more complicated than I like but, so I'll give you a version: map (maximumBy (comparing length)) . groupBy (\x y -> head x == head y) . sortOn head  . concat
05:00:52 <erisco> [k-, so what if there are many possible instances for a given type?
05:01:21 <ongy> tehre's one problem here: This uses 'head' which throws an error if you have an empty list (as you had in your first example) so you have to filter them out
05:01:30 <[k-> you mean like how Maybe has functor, applicative and monad, etc?
05:01:40 <DavidEichmann> are you sure that works, ongy?
05:01:54 <ongy> > map (maximumBy (comparing length)) . groupBy (\x y -> head x == head y) . sortOn head  . concat $ [[[2,2]],[[3]],[[2,2,2,2]]] -- DavidEichmann 
05:01:57 <lambdabot>  [[2,2,2,2],[3]]
05:02:09 <erisco> [k-, there is more than one possible Alternative instance for Maybe, for example, yet it chooses one arbitrarily
05:02:29 <ongy> It's neither pretty, nor do I think it's fast, but it works
05:02:39 <[k-> oh, you mean like the monadplus discussion yesterday?
05:02:48 <erisco> I wasn't around, but possibly, yes
05:03:51 <erisco> this is a failing of type classes
05:04:20 <erisco> something which newtypes help, a bit, debatable
05:04:25 <erisco> see Product and Sum
05:04:32 <[k-> as a matter or fact or an opinion?
05:04:34 <DavidEichmann> ok, but what input are you using?
05:05:05 <DavidEichmann> is that after doing a groupBy?
05:05:31 <erisco> there is zero or one instance per class per type, for some classes and types there is more than one possible instance, so this is a factual failure
05:05:53 <erisco> opinion is the efficacy with which newtypes solves this
05:05:54 <ongy> it's using the input that Forlorn gave as example, so you will have to ask them
05:05:58 <Cooler> erisco, whats Alternative?
05:06:16 <Forlorn>  ongy yaaay
05:06:17 <Forlorn> thank you
05:06:18 <ongy> @src Alternative
05:06:18 <erisco> Alternative is Monoid for kinds * -> *, simply
05:06:19 <lambdabot> class Applicative f => Alternative f where
05:06:19 <lambdabot>     empty :: f a
05:06:19 <lambdabot>     (<|>) :: f a -> f a -> f a
05:06:21 <[k-> I'm sure erisco didn't want to go into that haha
05:06:46 <erisco> it is a sub class of Applicative
05:07:10 <ongy> I get the felling that Forlorn is trying a social experiment: How far can I get an application purely by asking in IRC
05:07:11 <[k-> It is defined in Control.Applicative
05:07:41 <Forlorn> ongy, actually, I am trying to learn
05:07:44 <Cooler> erisco, but what does it mean?
05:07:49 <Cooler> whats it for
05:08:07 <erisco> Cooler, it has the same laws as Monoid, so it means the same thing there, it is just for kinds * -> * instead
05:08:35 <Cooler> why is it called Alternative?
05:08:46 <DavidEichmann> keep in mind that groupBy only does runs of numbers,
05:08:54 <ongy> Forlorn: I don't mind you asking. The only general advice I would give you is to think a bit more about intermediate steps give a bit more
05:08:57 <erisco> because they have to keep coming up with new names for mostly similar things
05:09:10 <DavidEichmann> > groupBy (==) [1,1,1,1,2,2,2,2,2,1,1,1,1]
05:09:13 <lambdabot>  [[1,1,1,1],[2,2,2,2,2],[1,1,1,1]]
05:09:21 <ongy> *steps given
05:09:34 <ongy> DavidEichmann: that's why I pust the sortOn in there
05:09:49 <Forlorn> ongy, it was quite difficult to explain it, I am sorry
05:09:56 <erisco> how do you think they got MonadPlus? beats me
05:10:06 <erisco> desperation? probably
05:10:08 <DavidEichmann> there is also GHC.Exts.groupWith
05:10:25 <[k-> It's so hard to name things
05:10:25 <DavidEichmann> > groupWith (==) [1,1,1,1,2,2,2,2,2,1,1,1,1]
05:10:28 <lambdabot>  error:
05:10:28 <lambdabot>      Variable not in scope:
05:10:28 <lambdabot>        groupWith :: (() -> () -> Bool) -> [Integer] -> t
05:10:41 <Forlorn> ongy, map (maximumBy (comparing length)) . groupBy (\x y -> head x == head y) . sortOn head . concat $ map (\x -> group $ factor x) [1..10]
05:10:47 <[k-> most of the time, we try to rely on what other people have already named it
05:11:18 <Forlorn> the factors give the product 2520 which is the smallest number that can be divided by each of the numbrs from 1 to 10 without any remainder
05:11:36 <Forlorn> plugging in 1..20 would possibly give the numbers 1 to 20
05:11:41 <Cooler> erisco, the <|> function is suggestive, what does it do? choose one given 2 values?
05:12:03 <erisco> Cooler, no, it can do whatever it wants, it just has to satisfy the laws
05:12:29 <erisco> > ("hello" <|> "world", Just "hello" <|> Just "world")
05:12:31 <Forlorn> ongy, it worked!
05:12:32 <lambdabot>  ("helloworld",Just "hello")
05:12:36 <Forlorn> ongy, https://projecteuler.net/problem=5
05:13:12 <Forlorn> https://projecteuler.net/problem=5
05:13:13 <Forlorn> ops
05:13:47 <bjs> Cooler: it's practically another name for another monoid typeclass is what erisco is trying to say i think and they're all pretty much the same except for the constraint that f has to be Alterative for Applicative, Monad for MonadPlus
05:14:10 <bjs> Cooler: that said, I think lots of places try (by convention) to use <|> as some kind of choice operator (See things like Parsec)
05:14:26 <erisco> Parsec is Alternative
05:14:31 <erisco> so, that isn't an accident really
05:14:40 <bjs> erisco: I didn't say it was an accident
05:15:14 <erisco> well I am not sure what you mean by convention then, other than we try and give type class instances when possible
05:15:24 <[k-> "it was an accident" sounds wrong *wink* *wink*
05:16:08 <erisco> I misunderstood then, sorry
05:16:23 <Cooler> erisco, ok a better question is then whats the usefulness?
05:17:58 <erisco> Cooler, some, many, optional
05:18:27 <Cooler> because with strings it seems to concatenate
05:18:41 <Cooler> and with maybe it chooses one of them
05:18:43 <erisco> with lists generally, yes
05:18:55 <erisco> it chooses the first, arbitrarily, could have chose the last
05:19:48 <[k-> If it's arbitrary it can't be pure right 
05:19:52 <Cooler> so why would you make such a type class, what do you need it for?
05:20:22 <erisco> Cooler, I gave three functions: some, many, optional
05:20:32 <erisco> I don't have a list longer than that off hand
05:20:32 <Cooler> what?
05:20:36 <[k-> erisco needs to be paid for this
05:20:48 <DavidEichmann> Forlorn, what that for solving the project euler question?
05:20:50 <Cooler> @src some
05:20:51 <lambdabot> some v = some_v
05:20:51 <lambdabot>   where many_v = some_v <|> pure []
05:20:51 <lambdabot>         some_v = (:) <$> v <*> many_v
05:20:59 <erisco> well if you want to use those functions you need an Alternative, so that is the use it has
05:21:11 <erisco> in addition to all other functions which require Alternative
05:21:36 <erisco> same reason you'd bother to implement any other type class, because there are functions you can use if you do
05:21:48 <Forlorn> DavidEichmann, yea
05:22:14 <Forlorn> DavidEichmann, I solved it manually, no code needed really, but I wanted to know how to do it in Haskell
05:22:17 <erisco> > optional "hello"
05:22:19 <lambdabot>  [Just 'h',Just 'e',Just 'l',Just 'l',Just 'o',Nothing]
05:22:47 <[k-> the list represents the sample space?
05:22:48 <Forlorn> DavidEichmann, I am running through these problems to learn haskell actually
05:23:07 <DavidEichmann> Forlorn oh cool, well done.
05:23:33 <Cooler> what does some do?
05:23:52 <Cooler> :t some
05:23:54 <lambdabot> Alternative f => f a -> f [a]
05:23:59 <erisco> some is one or more, many is zero or more
05:24:39 <Cooler> that explained nothing
05:24:48 <erisco> > many Nothing
05:24:50 <lambdabot>  Just []
05:25:24 <erisco> > some Nothing
05:25:25 <Cooler> some creates a list from a single element wrapped in a Alternative?
05:25:27 <lambdabot>  Nothing
05:25:58 <erisco> lol, that is as well as I can explain it, you'll have to look at the definitions
05:26:18 <liste> Cooler: for me, some and many first made sense as parsers
05:26:26 <liste> (which are usually Alternative)
05:27:04 <liste> eg "some 'a'" means 0-1 'a's, and "many 'a'" means 0-n 'a's
05:27:11 <Cooler> why would anyone make all this stuff without a concrete use case?
05:27:20 <liste> parsers are one concrete use case
05:27:31 <liste> but it generalizes from there
05:27:37 * hackagebot derive-storable 0.1.0.0 - Deriving Storable instances using generics.  https://hackage.haskell.org/package/derive-storable-0.1.0.0 (mkloczko)
05:27:39 * hackagebot derive-storable-plugin 0.1.0.0 - GHC core plugin supporting the derive-storable package.  https://hackage.haskell.org/package/derive-storable-plugin-0.1.0.0 (mkloczko)
05:28:04 <erisco> also, there are many people willing to work without what you'd consider concrete uses :P
05:28:04 <int-e> ongy: yes, thanks
05:28:07 <Cooler> liste, erisco said some is one or more not 0-1
05:28:28 <Cooler> some 1-n as and many 0-n as?
05:28:29 <liste> Cooler: yes, you're right. some is 1-n, many is 0-n
05:28:50 <liste> so for regex that would be + and *
05:29:08 <erisco> some and many are particularly devious, I am not aware of examples outside parsers
05:29:15 <Cooler> why is it called some and many?
05:29:16 <erisco> most other things you try will just give you bottom
05:29:30 <liste> @hackage regex-applicative -- here they literally translate to regex +'s and *'s
05:29:31 <lambdabot> http://hackage.haskell.org/package/regex-applicative -- here they literally translate to regex +'s and *'s
05:29:53 <erisco> as opposed to oneOrMore and zeroOrMore?
05:29:57 <[k-> ah, yes + and * are useful for regex
05:30:04 <Cooler> yes
05:30:21 <erisco> short cute names are preferable
05:31:14 <Cooler> some atleast makes sense as 1-n as
05:31:21 <Cooler> many doesn't mean 0-n as
05:31:37 <Cooler> many as means a lot of as
05:31:51 <erisco> how many are there? zero
05:32:01 <erisco> do you have some? yes I have one
05:32:02 <Cooler> that would be size
05:32:11 <Cooler> len list
05:32:49 <erisco> yes, looks the same
05:32:53 <[k-> do you have some, no I have none
05:33:01 <Cooler> ^
05:33:02 <[k-> it doesnt work!
05:33:09 <erisco> what? that is it working
05:33:21 <erisco> if you have none you do not have some, that is why some does not include zero!
05:33:32 <[k-> wat
05:33:45 <Cooler> do you have many? yes i have 0?
05:33:52 <Cooler> wth
05:33:59 <erisco> it is "how many"
05:34:21 <erisco> look, they had to be called something, this is what you'll have to put up with
05:34:28 <Cooler> yes ofc you can add words that aren't in the function name to try and make it make sense
05:34:29 <[k-> we now have a look into how geniuses think
05:36:34 <Cooler> erisco, this is like giving function one letter names
05:36:40 <Cooler> functions*
05:36:44 <erisco> no no, that is just for variables
05:36:55 <Cooler> the name needs to be descriptive of what it does
05:37:11 <Cooler> because theres way too many functions to memorize
05:37:17 <erisco> no it doesn't, that is a waste of space
05:37:24 <erisco> here is how you figure out what it does http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#g:2
05:37:57 <Cooler> erisco, its not a waste of space if it saves you the effort of thinking about it
05:38:12 <erisco> you clearly couldn't understand the brilliance of lens functions https://github.com/ekmett/lens/wiki/Operators
05:38:27 <Cooler> a waste of space would be redundancy
05:40:03 <Cooler> how does it help with parsers
05:40:22 <erisco> some is +, many is *, if we're talking regex notation
05:40:38 <Cooler> yes but how do you use it?
05:40:59 <erisco> some (char 'a')  is  a+
05:41:05 <Cooler> parse some 4 "afaf234edfa"
05:41:58 <Cooler> parse (some 4) "afaf234edfa"
05:43:06 <rmrfroot> anyone know of a lambda calculus compiler/interpreter you can use to experiment with when reading up on the subject? 
05:43:26 <erisco> rmrfroot, the untyped?
05:43:40 <int-e> @wiki Introduction
05:43:46 <lambdabot> https://wiki.haskell.org/Introduction
05:44:20 <erisco> @hackage lambda calculus untyped
05:44:24 <lambdabot> http://hackage.haskell.org/package/lambda calculus untyped
05:44:31 <erisco> this is a stupid extension
05:44:36 <int-e> > (\case () -> ()) ()
05:44:38 <rmrfroot> erisco: just started reading about the subject, so starting with untyped and then go onto typed is the way to go, right? 
05:44:46 <lambdabot>  ()
05:44:54 <erisco> rmrfroot, I suppose so, seems right
05:45:03 <erisco> http://hackage.haskell.org/packages/search?terms=lamabda%20calculus%20untyped lots of options
05:45:06 <[k-> @hackage nonsense-here
05:45:12 <lambdabot> http://hackage.haskell.org/package/nonsense-here
05:45:19 <rmrfroot> erisco: alright, thanks!
05:45:46 <int-e> erisco: FWIW, saying "this is a stupid extension" is not going to change anything.
05:46:14 <phadej> uh,there're a lot packages for lc-stuff
05:46:15 <erisco> lambdabot wouldn't be lovable if it was perfect
05:47:32 <Cooler> if you try to feed an int into / is that a type error?
05:47:42 <Jarl> I'm apparently a bit confused about the topology of modules. The time package has the module Data.Time.Clock and in it getCurrentTime, so I would think I would import it like so: import Data.Time.Clock (getCurrentTime) instead I do it like so Data.Time (getCurrentTime)
05:47:51 <liste> > (5::Int) / (2::Int)
05:47:58 <ongy> :t (/)
05:47:59 <ongy> :t div
05:48:00 <lambdabot>  error:
05:48:06 <lambdabot> Fractional a => a -> a -> a
05:48:08 <lambdabot> Integral a => a -> a -> a
05:48:14 <lambdabot>      • In the expression: (5 :: Int) / (2 :: Int)
05:48:25 <Cooler> ok
05:48:53 <liste> Jarl: http://hackage.haskell.org/package/time-1.6.0.1/docs/src/Data.Time.html Data.Time re-exports Data.Time.Clock
05:48:58 <liste> and 3 other modules
05:50:39 <marrrk> man it's hard to parse some datetime string
05:52:31 <Jarl> liste: Thanks. What still is weird though is that I get "No instance for (Show time-1.5.0.1:Data.Time.Clock.UTC.UTCTime)" when I try to print the result of getCurrent when I import it with import Data.Time.Clock (getCurrentTime) whereas there are no issues with import Data.Time (getCurrentTime)
05:52:38 <erisco> Jarl, it re-exports the module
05:52:51 * erisco can't read anymore
05:53:09 <erisco> good night
05:53:20 <erisco> Cooler, if you really want a headache try to figure out the purpose of Arrow
05:53:44 <erisco> someone spent a lot of time on it, too
05:59:19 <marrrk> What do I do with a FormatTime t ?
05:59:28 <marrrk> How do I actually get the result of the parsing?
05:59:48 <[k-> erisco: night!
06:00:03 <[k-> and thanks!
06:01:22 <rmrfroot> marrrk: what is it you are trying to do? 
06:01:23 <liste> :t formatTime -- marrrk
06:01:26 <lambdabot> error: Variable not in scope: formatTime
06:01:52 <liste> lambdabot can't import it :(
06:02:23 <marrrk> I am trying to get some kind of type from a string that looks like this: "Sun, 11 Sep 2016 04:12:50 -0700"
06:02:34 <marrrk> Anything that has an Ord instance
06:03:25 <liste> marrrk: http://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Format.html#v:parseTimeM
06:03:45 <liste> that uses ParseTime, not FormatTime
06:03:50 <liste> FormatTime is time -> string
06:03:54 <liste> Parsetime is string -> time
06:04:13 <marrrk> I used parseTimeOrError
06:04:17 <marrrk> that's wrong?
06:04:39 <liste> marrrk: no
06:04:41 <liste> it's good too
06:04:52 <marrrk> So I did this
06:04:53 <liste> for testing code
06:05:05 <liste> marrrk: I wouldn't use it for real code though
06:05:19 <marrrk> let v = parseTimeOrError True defaultTimeLocale "ddd, DD mmm YYYY HH:MM:SS tt" "Sun, 11 Sep 2016 04:12:50 -0700"
06:05:25 <marrrk> I'm pretty sure the format string is wrong
06:05:28 <marrrk> I get a value
06:06:06 <marrrk> Of type ParseTime t => t
06:06:19 <liste> marrrk: http://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Format.html#v:rfc822DateFormat
06:06:32 <lingxiao> hey all
06:06:36 <lingxiao> so in stack init 
06:06:39 <liste> marrrk: you need to specify the return type you want
06:06:40 <lingxiao> ed a basic project
06:06:47 <lingxiao> with src, app, and test  direcotries
06:06:53 <lingxiao> i'd like to add a new directory called lib
06:07:04 <liste> marrrk: add a type annotation for v
06:07:07 <lingxiao> and move all files from src to lib
06:07:09 <marrrk> so instead of let v it would be let v :: UTCTime?
06:07:12 <lingxiao> and some files from app to src
06:07:35 <Cooler> can someone point me a implementation of ping-pong in hs?
06:07:37 <lingxiao> i did that and did stack build ... however i get message: ignrogin unkown section type: source
06:07:41 <liste> marrrk: both: let v :: UTCTime; v = ...
06:07:57 <liste> Cooler: as in the video game?
06:08:03 <Cooler> there was a specific one linked by someone here, i can't find that on google
06:08:03 <marrrk> ah very good
06:08:25 <Cooler> liste, yeah
06:09:03 <liste> Cooler: here's a start http://andrew.gibiansky.com/blog/haskell/haskell-gloss/#_drawing_pong
06:09:32 <lingxiao> hey is someone here familiar with stack and can help me?
06:09:48 <marrrk> Okay, so now I need to get the format string and the Locale right
06:09:51 <liste> lingxiao: can you paste your .cabal file?
06:10:02 <lingxiao> http://lpaste.net/190385
06:10:04 <lingxiao> liste pasted, 
06:10:13 <lingxiao> I added the section library
06:10:43 <lingxiao> it was this:  http://lpaste.net/190388
06:10:55 <Cooler> liste, it was a github page
06:11:08 <lingxiao> and that ---^ worked with directory structure:   src, app, test
06:11:48 <liste> lingxiao: that line 45 - what do you want to build? that part is supposed to define the deliverable
06:12:09 <liste> line 16 specifies how to build a library, line 73 specifies how to build an executable
06:13:05 <lingxiao> oh that's also a library ... in line 45
06:13:18 <lingxiao> actually  no, everything in source was ain app
06:13:44 <lingxiao> but now I want to separate them so app directory is not overlowing with modules
06:14:20 <[k-> Cooler: you could try searching the logs linked in the topic above
06:14:34 <liste> lingxiao: so, what's in src now?
06:14:58 <lingxiao> things that used to be in app
06:15:17 <lingxiao> everything that was in src, is now moved to new directory in lib
06:15:40 <liste> lingxiao: so can you just remove lines 45-72 and change se source directory in line 74?
06:15:45 <lingxiao> so it goes ....    :      src -MoveTo-> lib    app -MoveTo-> src
06:16:04 <lingxiao> no app still exts
06:16:09 <marrrk> liste: So the parseTimeMonad version can I use that with Maybe?
06:16:10 <lingxiao> it now only has main.hs and mainsubroutines.hs
06:16:22 <lingxiao> where before it had those two files ---^
06:16:28 <lingxiao> and everthing that is now in src
06:16:56 <liste> lingxiao: so then remove 45-72 and add src to line 74, so there will be 2 hs-source-dirs
06:19:06 <lingxiao> like this: http://lpaste.net/190415  ?
06:19:10 <lingxiao> see line 47
06:19:15 <lingxiao> im getting an error while stack build
06:19:31 <lingxiao> in line 59  for somereason
06:20:04 <lingxiao> wait hold on nvm
06:20:33 <lingxiao> ok worked in think thanks!
06:20:54 <liste> lingxiao: yw (:
06:22:08 <Berra> I'm sort of thinking I'd want to use an Applicative Map that behaves similarly to ZipList. Does this sound reasonable or is there something I might not be seeing?
06:22:35 <Cooler> can't find it in the logs
06:23:12 <Narfinger> hiho, I am now majorly confused about haskell web frameworks. Which is a modern small framework that can integrate websockets?
06:23:48 <Narfinger> I already have an application using acid and happstack but now I want to use websockets too
06:24:35 <rmrfroot> Narfinger: isn't there a library that allows websocket use in Happstack?
06:24:45 <liste> Berra: seems worth trying to me
06:24:51 <Narfinger> yes but it is not in stack if I see correctly
06:24:52 <[k-> Cooler: did you try searching the previous days?
06:25:10 <rmrfroot> Naringer: ah, I see!
06:25:29 <Narfinger> I looked at wheb but that didn't get any commits since a year so I assume it is dead
06:26:08 <Narfinger> and while spock uses wai (what ever that is) it probably can use wai-websockets but I cannot find a tutorial for that or if spock needs to support it directly
06:26:19 <Cooler> [k-, yes
06:26:21 <lingxiao> hey all does anyone know how i can put a file such as   Lib.hs in directory lib so that it exports all modules in lib
06:26:36 <liste> lingxiao: you need to re-export them yourself
06:26:38 <lingxiao> so i dont have to do something like:   import libFile1  import libFile2
06:26:41 <Cooler> Cale, was it you who posted a link to pingpong
06:26:42 <Cooler> ?
06:26:47 <lingxiao> is theree an example of such a thing?
06:27:15 <liste> lingxiao: http://hackage.haskell.org/package/time-1.6.0.1/docs/src/Data.Time.html
06:27:39 * hackagebot timezone-series 0.1.6 - Enhanced timezone handling for Data.Time  https://hackage.haskell.org/package/timezone-series-0.1.6 (YitzGale)
06:27:41 * hackagebot antiprimes 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/antiprimes-0.1.0.0 (wokibe)
06:27:43 * hackagebot derive-storable-plugin 0.1.0.1 - GHC core plugin supporting the derive-storable package.  https://hackage.haskell.org/package/derive-storable-plugin-0.1.0.1 (mkloczko)
06:27:45 * hackagebot derive-storable 0.1.0.1 - Derive Storable instances with help of GHC.Generics.  https://hackage.haskell.org/package/derive-storable-0.1.0.1 (mkloczko)
06:27:47 * hackagebot derive-storable-plugin 0.1.0.2 - GHC core plugin supporting the derive-storable package.  https://hackage.haskell.org/package/derive-storable-plugin-0.1.0.2 (mkloczko)
06:31:29 <Jarl> should import Data.Time (getCurrentTime) and import Data.Time.Clock (getCurrentTime) be equal? Because one gives me an error about no Show instance when trying to print the result and the other doesn't.
06:32:36 <[k-> yes lingxiao
06:32:46 <[k-> create a new module in Lib.hs
06:32:49 * hackagebot derive-storable 0.1.0.2 - Derive Storable instances with help of GHC.Generics.  https://hackage.haskell.org/package/derive-storable-0.1.0.2 (mkloczko)
06:33:02 <rmrfroot> Jarl: it's the same function in both imports, but the instance implementation is not imported when you do import Data.Time.Clock
06:33:39 <lingxiao> ok got it thanks gusy!
06:34:05 <[k-> lingxiao: in the export list follow this syntax module Lib ( module M1, module M2, etc) where { import M1; import M2 }
06:34:23 <Jarl> rmrfroot: why is the UTCTime Show instance implementation not included in one but is with the other?
06:34:26 <lingxiao> nice, yeah the link given has no commas for somer reaon, but still works
06:35:15 <[k-> oh, the link... oh the comma is at the end lingxiao
06:35:43 <lingxiao> ahhh ..im so used to seeting commas at the beginning haha
06:38:14 <anitagrad> >
06:38:17 <[k-> I like writing them at the beginning too
06:38:33 <rmrfroot> Jarl: the show instance is probably defined somewhere else as an orphan instance. so when you do the specific import the module you don't get the module with the oprhan instance imported.
06:38:38 <[k-> Is there a haskell style guide that has a huge following?
06:40:04 <Tehnix_> [k-: kinda the johan-tibell style
06:40:45 <[k-> thx, checking that out
06:40:49 <rmrfroot> Jarl: The show instance for UTCTime is defined in Data.Time.LocalTime. Try importing that module and see if it resolves your problem.
06:40:49 <Tehnix_> [k-: you could also take a look at hindent to automatically enforce that style on your code. If you follow /r/haskell then you might have noticed a lot of discussion recently to "perfect" a common community style
06:41:57 <rmrfroot> Jarl: Sorry, I mean Data.Time.Localtime.Localtime
06:42:24 <rmrfroot> Jarl: Haha. LocalTime, not Localtime.
06:43:57 * rmrfroot needs coffee
06:44:44 <Jarl> it confuses me a bit. Even though I'm explicitly only importing getCurrentTime the fact that the module I import it from exports Data.Time.LocalTime is of consequence? Is this correct?
06:45:14 <umib0zu> Hey all. How is concurrency handled in Haskell when doing IO? I’m sort of coming over from the node camp, so I’m wondering if there is a concept of non-blocking IO in Haskell.
06:45:55 <umib0zu> Another thing, do I have to worry about concurrency in web development using Haskell?
06:46:09 <umib0zu> I’m guessing no but I’m not sure
06:47:23 <rmrfroot> Jarl: I'm not 100% sure, but if you look at the exports of Data.Time you can see that the Data.Time.LocalTime is re-exported. But in Data.Time.Clock it is not re-exported. Maybe the module needs to be re-exported for the instances to follow?
06:47:56 <zennist> say I have: f1 x = let resultList = complexOp in (resultList !! x) VS f2 = let resultList = complexOp in \x -> resultList !! x 
06:48:02 <Jarl> rmrfroot: Thanks for the help.
06:48:05 <zennist> do you expect f1 to be significantly slower than f2?
06:48:32 <liste> umib0zu: the purity of Haskell makes concurrency much easier (less surprising) than many other languages
06:49:10 <liste> umib0zu: also, the blocking/non-blocking concept is a bit different than other languages
06:49:24 <ben> its basically like go
06:49:46 <liste> umib0zu: even normal ("blocking") sequencing of actions is done via callbacks
06:50:26 <liste> (well, combining actions, more specifically)
06:50:47 <liste> @undo do { val <- getLine; putStrLn "hello " ++ val }
06:50:47 <lambdabot> getLine >>= \ val -> putStrLn "hello " ++ val
06:51:17 <liste> that \ val -> is an anonymous function
06:51:48 <liste> and >>= is a function called `bind'
06:52:53 <liste> so it would be something like bind(getLine, function (line) { putStrLn(line); }); in JavaScript
06:53:36 <liste> you could say Haskell does non-blocking IO by default
06:54:04 <umib0zu> hm… so is there a library/blog post that helps with this? I’m thinking of trying to get into server development so I was looking for libraries where I can compose non-blocking steps. Like if I have a step that requires a database call that’s IO, then another step that sends a response back to a user, I obviously want other requests to be handled while the database call is processing.
06:54:10 <zennist> to whoever interested in my previous question: I just did a test and YES, capturing a result ABOVE a function scope can memoize that result whereas simply declaring that in the current function scope wouldn't
06:55:04 <marrrk> How do I get a field in some record?
06:56:05 <lingxiao> hey guys 
06:56:06 <liste> umib0zu: you don't really need to worry about that, all server libs handle requests concurrently by default
06:56:10 <lingxiao> so i have an engeering problem
06:56:20 <lingxiao> I have 300 + large text files, 100 mb + each
06:56:23 <liste> marrrk: the field name is a function
06:56:28 <lingxiao> and I need to access items in it fast
06:56:39 <marrrk> okay
06:56:39 <liste> @let data MyRecord = MyRecord { field1 :: Int, field2 :: String }
06:56:40 <lingxiao> they're google n-grams, so it seems like binary tree is one option here
06:56:43 <lambdabot>  Defined.
06:56:47 <lingxiao> you know by alphabetical order
06:56:55 <lingxiao> or er .. just alphabetical
06:56:59 <ben> umib0zu: haskell does that sort of thing with threads, really
06:57:00 <liste> > let rec = (MyRecord 4 "spam") in field1 rec
06:57:04 <lambdabot>  4
06:57:08 <ben> umib0zu: ghc has green threads so we pretend they're basically free
06:57:28 <liste> ben: and haskell doesn't have a call stack, so they really are almost free
06:57:50 <rmrfroot> umib0zu: Have you read this? http://stackoverflow.com/questions/3847108/what-is-the-haskell-response-to-node-js Contains some interesting comparisons.
06:59:16 <ben> theres some magic revolving around what ghc does if you do ffi calls that would block the underlying OS thread, i think
06:59:32 <ben> but i guess that's just grabbing another thread and making that evaluate the other green threads 
07:01:37 <rmrfroot> umib0zu: if you are interested in implementing your own server I suggest you start with understanding how forkIO works. here's a simple tutorial to get you started practically: http://no-fucking-idea.com/blog/2013/12/12/forkio-and-friends/
07:06:22 <Jupelius> How does the interpreter interpret the following expression: "cycle [1, 2, 3]"
07:06:42 <Jupelius> It starts to output [1, 2, 3] forever which is something you could expect
07:07:07 <Jupelius> But at what point does it decide to spit you with output?
07:07:15 <ongy> @cycle
07:07:15 <lambdabot> Unknown command, try @list
07:07:19 <ongy> @src cycle
07:07:19 <lambdabot> cycle [] = undefined
07:07:19 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
07:07:38 <ongy> this get's expanded to [1, 2, 3] ++ cycle [1, 2, 3]
07:08:31 <Jupelius> So it's infinite recursion and the (interactive) interpreter prints [1, 2, 3] in each step?
07:10:03 <ongy> it's an infinite recursion
07:10:45 <ongy> but it's not direclty [1, 2, 3] each time, it's (informally) "when the element after 3 should be accessed, return cycle [1, 2, 3]"
07:11:15 <ongy> I just noticed, the definition uses xs', not cycle but that doesn't change it
07:12:36 <ski> it constructs a cyclic list
07:13:06 <ski> then the printer that the interactor calls loops around this again and again
07:14:46 <rmrfroot> so this has to do with laziness, right? if we called the cycle function without laziness it would never output anything?
07:16:12 <ongy> it would never return anything since it builts an infinite list. So nothing would ever be printed
07:16:21 <rmrfroot> exactly
07:17:58 <[k-> it would take up so much memory until it crashes
07:18:43 <[k-> this doesn't happen with laziness as the memory is able to be released as the part of the list is printed 
07:18:52 <zell> can't you tie the knot?
07:19:47 <ski>           Objective Caml version 3.12.1
07:19:53 <ski>   # let rec myCyclicList = 1 :: 2 :: 3 :: myCyclicList;;
07:19:55 <zell> I always wanted to understand hire that worked. I guess you would have to retain something to recognise a repeated traversal
07:19:57 <ski>   val myCyclicList : int list =
07:20:00 <ski>     [1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;
07:20:02 <ski>      ...]
07:20:13 <ski> seems to work fine, in an eager language
07:21:21 <ski> (however, using list append (`(@)') there wouldn't work, since the `let rec' wants a syntactic value ..)
07:21:32 <zell> But you can just use take, I can't see why you would ever want the final result to be infinite
07:22:16 <ski> (otoh, in Prolog it would work fine. possibly you could get it to work in Mercury as well, assuming you can get past the mode checker)
07:23:40 <ongy> ski: is the let rec some fancy magic that makes this poosible?
07:23:45 <ski> ongy,[k- : the point is that it (with the obvious implementation) (operationally) builds a cyclic list, not an infinite list
07:23:51 <rmrfroot> so the question was when/where is the decision made to return/print the part of the result since it's infitine
07:24:37 <ongy> ski: then how would e.g. take 5 work on a cyclic list?
07:24:40 <ski> ongy : as long as the cyclic references are down a path of only constructors (or otherwise delayed inside abstractions), it's ok
07:25:15 <zell> > take 5 $ repeat 5
07:25:17 <lambdabot>  [5,5,5,5,5]
07:25:21 <ongy> oh right, persistance, we copy don't modify
07:25:34 <[k-> if it's a cyclic list, then won't the last node just refer to the first
07:26:21 <[k-> or rather why don't the last node refer to the first
07:26:24 <zell> it makes infinite copies as they are needed
07:26:59 <kgadek> withAdvert $ \_ -> hi! You may (or not) recall me from Flowbox — those guys that make VFX software; Haskell inside, _some_ Luna language, etc. We're currently expanding our interests, we're looking for opportunities to use Haskell anywhere possible. If anyone needs a group of Haskellers with professional experience to get the job done (and done provably well with TC of course!), reach me at kgadek@flowbox.io
07:27:08 <zell> The last thing is the recursive call
07:27:38 <[k-> and we call it a cyclic list?
07:28:39 <zell> It's recursively defined
07:28:43 <ski>   # let rec take n l = if n <= 0 then [] else match l with [] -> [] | h::t -> h :: take (n-1) t;;
07:28:48 <ski>   val take : int -> 'a list -> 'a list = <fun>
07:28:52 <ski>   # take 5 myCyclicList;;
07:28:53 <ski>   - : int list = [1; 2; 3; 1; 2]
07:28:57 <ski> ongy ^
07:30:06 <ski> [k- : yes, the last node will point back to the first (or perhaps some intermediate one)
07:30:49 <buglebudabey> would someone be able to give me direction on how to solve the "minimum number of jumps to reach end of list" dynamic programming problem in haskell? http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/. Here is what I have so far http://lpaste.net/190570
07:32:38 <rmrfroot> is this what thunks are used for internally? keeping track of values produced in lazy evaluated functions?
07:34:19 <buglebudabey> Cale thanks for that solution, just received it
07:35:04 <[k-> ohhh, so that's what Cale was actually doing
07:35:48 <[k-> buglebudabey, someone has a solution up on the nets already, do you mind if I link you to it? I do not understand how it works or what it does though
07:35:59 <buglebudabey> [k- please do
07:36:08 <buglebudabey> trying to understand Cale's at the moment myself
07:36:20 <zell> How could you recognise during branched cyclic datatype if you are retracing your steps?
07:37:27 <zell> Traversal of a*
07:38:17 <nut> httpLBS is lazy, what does it mean?
07:38:49 <nut> I use it to get a web page into a response
07:38:54 <zell> You can use toStrict
07:39:08 <[k-> buglebudabey: cale.yi.org/reflex/Jumps/Jumps.jsexe/
07:39:18 <buglebudabey> oh that's what im looking at now [k- 
07:39:20 <nut> What does the lazy part of the function mean?
07:39:28 <zell> :t Data.ByteString.Lazy.toStrict
07:39:29 <[k-> oh lol
07:39:30 <lambdabot> BSLC.ByteString -> BSC.ByteString
07:39:48 <nut> zell, I know how to turn it into strick
07:40:03 <zell> So what's the problem?
07:40:05 <nut> Just curious about the benefit of being lazy
07:40:22 <zell> Then you can handle infinite lists
07:40:37 <nut> like when the page is huge and httpLBS can read it one bit at a time ?
07:40:50 <zell> And start processing streams before they close
07:41:42 <zell> Is the question, does a lazy bytestring use less ram?
07:42:29 <nut> yeah? does it ?
07:42:38 <zell> And, does a strict bytestring load the whole structure into ram?
07:43:01 <zell> Did you do any profiling?
07:43:33 <nut> no
07:43:43 <zugz_> any suggestions for a clear explanation of the basic principles of how garbage collection works in GHC? e.g. if I have an infinite list and various references to it, and I force some of the list, I'd like to know under what circumstances the result will be kept in memory
07:43:44 <zell> I'm sure someone could link a common benchmark reference
07:44:10 <Cooler> how do you use data in ghci?
07:44:32 <[k-> data A = A
07:44:33 <zell> Prefix with let Cooler
07:45:38 <buglebudabey> zugz_ https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC may be your best bet
07:45:42 <ongy> Cooler: also I think it has to be in one line. So where you would put a linebreak in normal code, put ;
07:45:51 <liste> or use :{ and :}
07:46:00 <ggVGc> zell: are you using haskell now? (same zell as in lowtech?)
07:46:37 <rmrfroot> nut: are you using httpLbs in Network.HTTP.Client?
07:46:42 <zell> ? No comment
07:46:54 <nut> rmrfroot, yes
07:46:57 <ggVGc> zell: mixed you up with someone else I guess
07:46:59 <ggVGc> sorry
07:49:06 <ggVGc> nut: if you want to get a feeling for why laziness matters, write haskell for a while and then try something like PureScript
07:49:16 <ggVGc> and it'll start showing it's face
07:49:17 <Cooler> zell, no
07:49:25 <Cooler> that gives a parse error on data
07:49:47 <zugz_> buglebudabey: thanks, but I'm afraid I don't understand enough to understand that page
07:50:04 <nut> Why PureScript?
07:50:09 <ggVGc> nut: because of laziness in haskell, you can write functions dealing with lists in a very consise way, which would lead to infinite recursion in a strict language
07:50:29 <ggVGc> nut: it was just an example, because PureScript is very similar to haskell, but strict instead of lazy
07:50:37 <nut> Ok...
07:50:54 <nut> I thought PureScript is Haskell
07:51:00 <buglebudabey> zugz_ those algorithms listed may provide some help as to how the gc happens
07:51:06 <Cooler> how do you use data with ghci?
07:51:42 <zugz_> buglebudabey: Cheney's algorithm?
07:51:43 <ggVGc> nut: both Elm and PureScript are very similar to haskell on a syntax level, but they are strict in evaluation, which is quite a big difference from haskell
07:51:57 <zell> If let does not work then I'm stumped
07:52:12 <rmrfroot> nut: alright! the funciton itself is strict, it will download the whole request and close the connection directly. it just uses lazy bytestring as the storage type. 
07:52:29 <buglebudabey> zugz_ it seems that way, i'm not familiar with the gc myself
07:52:41 <ggVGc> nut: my point is that if you write a function dealing with lists in haskell, and then compile it with for example Elm, it will proably compile, but if you run it it'll never return because it evaluates strictly
07:52:55 <Cooler> well just using data without let works
07:52:58 <ggVGc> nut: if you write some haskell and some elm/purescript, you get a much better feel for how laziness works
07:53:04 <buglebudabey> zugz_ that wiki has the most comprehensive info besides the source itself, which is well commented and documented
07:53:10 <zugz_> buglebudabey: ok thanks, led me to https://en.wikipedia.org/wiki/Tracing_garbage_collection  which seems readable (and I assume applies to ghc)
07:54:51 <nut> ggVGc, can ghc compile those languages ?
07:54:59 <ggVGc> no
07:55:11 <nut> It's time consuming to set up new environments
07:55:27 <buglebudabey> paging Cale
07:56:00 <nut> rmrfroot, so what's the benefit of storing it as a lazy bytestring?
07:56:10 <buglebudabey> Cale would you mind explaining the logic behind the line "[n | i <- takeWhile (<= h) [l+1 .. l+(xs ! l)], (xs ! i /= 0 || i == h), Just n <- [a ! i]]" which is basically the engine of the function i gather
07:56:27 <rmrfroot> nut: according to the docs, it's more memory efficient. 
07:58:42 <rmrfroot> nut: lazy bytestring is normally used to handle large amounts of data, since it takes care of handling what parts of that data is actually loaded into memory. 
08:00:18 <[k-> buglebudabey, seems like l is the lowerBound of the array and h is the upperBound of the array
08:00:29 <buglebudabey> [k- i got that part
08:00:49 <[k-> so takeWhile <= h [l (...)
08:01:02 <zell> lol cooler
08:01:17 <rmrfroot> nut: makes sense? :)
08:01:45 <[k-> argh, well basically, it just gets the highest jump possible
08:01:54 <[k-> it tries to skip as much elements as possible
08:03:06 <[k-> there is a limit there as you don't want to create an infinitr list 
08:03:53 <[k-> then the second part, if this part is true, then the next part is evaluated
08:04:03 <[k-> if it is not, then the next part is not evaluated 
08:04:49 <[k-> so if it is not evaluated, then you don't have n added to the resulting list
08:05:49 <[k-> the first condition tests if it jumps to a zero, if it does, then it cant continue, so it is ignored 
08:06:52 <nut> rmrfroot, sure ;) Im sure i'll get a more physical feeling of it later
08:07:15 <[k-> wait im confused
08:07:15 <[k-> sorry
08:07:30 <buglebudabey> its ok i am too
08:07:57 <[k-> damnit Cale annotate your code!
08:08:26 <buglebudabey> im gonna try to write it out and see if i can reason through it that way
08:08:40 <nut> In http-conduit, the reponse is defined as data Response body :: * -> *
08:08:48 <nut> How to understand it?
08:09:14 <nut> The data takes an argument?
08:09:42 <nut> of anytype and gives out another data of any type?
08:09:58 <ben> That's a kind signature, I guess
08:10:20 <ben> Response takes a fully-applied type and returns a fully-applied type, itself not being fully-applied? Not sure if that's the right terminology
08:11:39 <hydraz> it's equivalent to `data Response a b`.
08:11:39 <ben> It's like lists, [] is not a proper type with regular old values in it, but if you add a type, you get a type like [Int]!
08:12:20 <zell> Can you link this code you want annotated?
08:12:43 <buglebudabey> zell http://cale.yi.org/reflex/Jumps/Jumps.jsexe/
08:13:06 <buglebudabey> zell namely the 4th to last line
08:13:24 <ben> hydraz: I'm not sure that's right?
08:13:39 <ben> Looks like it's just parameterized over the response's body
08:13:47 <zell> What's the problem with that line?
08:14:08 <buglebudabey> zell simply don't understand the logic behind it
08:15:44 <zell> That line just gets the values in the range prescribed by the element l
08:16:36 <buglebudabey> it does more than that, it's a lazy self constructing array
08:17:19 <zell> Yes it uses I enumFromTo
08:17:42 <zell> :t enumFromTo
08:17:44 <lambdabot> Enum a => a -> a -> [a]
08:18:19 <zell> That's what the [a..b] syntax means
08:18:32 <buglebudabey> youre explaining a part i understand
08:18:41 <liste> zell: it's syntactic sugar for enumFromTo
08:18:48 <zell> Thanks
08:18:54 <liste> zell: [a..b] = enumFromTo a b
08:19:00 <zell> Yar
08:19:11 <buglebudabey> i know what the actual parts mean but the logic behind the organization of the parts is the problem
08:19:30 <zell> Just in that line?
08:19:49 <buglebudabey> the combination between minJumps and a
08:20:13 <zell> [n | i <- takeWhile (<= h) [l+1 .. l+(xs ! l)], (xs ! i /= 0 || i == h), Just n <- [a ! i]]
08:21:11 <zell> I don't get your question
08:21:29 <[k-> HE REFERRED TO A
08:21:29 <[k-> omg!
08:21:41 <[k-> he!
08:21:46 <[k-> omg!
08:22:00 <[k-> this... I... cannot
08:22:05 <buglebudabey> i knew this
08:22:15 <zell> Get away from this channel
08:22:23 <MarLinn> I assume <that line> = a?
08:22:27 <ski> (i think `xs ! i /= 0 || i == h' would possibly read better if you used implication ..)
08:23:06 <buglebudabey> ski like xs == 0 -> i ==h ?
08:23:12 * ski laments the fact that "less than or equal" is written `<=', in Haskell
08:23:29 <ski> buglebudabey : `->' is reserved, so can't use that
08:23:40 <liste> ski: any alternatives?
08:23:41 <buglebudabey> well yeah but i meant logic wise not haskelly
08:23:54 <buglebudabey> is there an implies operator in haskell?
08:24:06 <ski> liste : Prolog and Erlang has `=<' instead of `<=', if that's what you're asking about
08:24:15 <ski> (more sensible, imho)
08:24:33 <liste> yeah, that's what I'm asking about
08:25:00 <buglebudabey> ski, when you think about it, the -> in haskell really does mean the same thing as implies, just in the context of types
08:25:03 <ski> buglebudabey : you can define it .. or you can use `<=', but .. that might give you wrong associations, because ^
08:25:20 <Adeon> I grew up with <> meaning not equal
08:25:22 <Adeon> that was basic
08:25:31 <Adeon> not sure if any non-basic uses <>
08:25:42 <ski> buglebudabey : yes, though i was rather thinking of the use of `->' in abstractions and `case'-expressions
08:25:51 <liste> Adeon: SQL does
08:25:55 <buglebudabey> ah ok
08:26:00 <ski> Adeon : SML as well, i think
08:26:16 <marrrk> how do I get the value of a Just a or some supplied a instance I guve?
08:26:18 <marrrk> give*
08:26:27 <ski> also OCaml
08:26:28 <[k-> it's getting clearer
08:26:32 <[k-> Cale makes sense!
08:26:38 <liste> :t fromJust -- marrrrk
08:26:39 <lambdabot> Maybe a -> a
08:26:45 <liste> :t fromMaybe -- marrrk
08:26:47 <lambdabot> a -> Maybe a -> a
08:26:49 <buglebudabey> marrrk pattern matching works too
08:26:56 <ski> marrrk : better not to use `fromJust'
08:26:56 <liste> marrrk: the latter one is what I meant
08:27:00 <buglebudabey> [k- enlighten me please
08:27:01 <liste> marrrk: don't use fromJust
08:27:13 <liste> the first one was just a brainfart
08:27:25 <zugz_> so how can you stop something being GCd? If I force out an expensive data structure, and I know I'll want to use the results again in a few seconds, can I make sure it won't get recalculated? Or does that that need explicit memory management with IORefs or similar?
08:27:32 <Cale> buglebudabey, [k-: hello!
08:27:41 * hackagebot transient 0.4.4 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.4.4 (AlbertoCorona)
08:27:43 <buglebudabey> -stops rain dance-
08:27:44 * hackagebot deriving-compat 0.3.3 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.3.3 (ryanglscott)
08:28:00 <Cale> Was there a question about that code?
08:28:10 <glguy> zugz_: Name the value and then use the same name twice
08:28:25 <buglebudabey> yes Cale, thank you for your solution, I'm trying to make sense fo the logic behind the 4th to last line with the list comprehension
08:28:40 <Cale> Ah, there's a bunch of stuff going on there
08:28:51 <Cale> Most of it is just taking care of some annoying edge cases
08:29:12 <Cale> Actually, that /= 0 should probably be a > 0
08:29:38 <zugz_> glguy: how do you name the value rather than a thunk which will evaluate to the value? e.g. say I have an expensive infinite list l, and we're talking about taking the first 100 values
08:29:49 <Cale> So, okay, the situation we're in is that we're at position l, and we're trying to decide how many jumps is the minimum to get to position h
08:29:53 <buglebudabey> Cale i understand your predicate, and i understand that you're taking elements until it equals h, but the relationship to previous results is what's boggling me, it seems more complicated than similar things ive done
08:30:07 <glguy> zugz_: When a thunk is evaluated, it replaces the thunk with the result
08:30:09 <buglebudabey> apologies, you may continue
08:30:36 <Cale> buglebudabey: Oh, if the predicates make sense, then note that a ! i is the same thing as minJumps i h
08:30:51 <glguy> zugz_: So if you have: xs = [1..], and you use the first 100 elements of it, those 100 elements will remain evaluated and reachable from xs
08:30:53 <Cale> buglebudabey: Because of the way that a is defined
08:31:11 <buglebudabey> Cale just the middle pred makes sense
08:31:14 <Cale> buglebudabey: The only difference is that since a is a constant array, we only compute each of its elements at most once
08:31:49 <buglebudabey> Cale i think the explanation you were about to give was going to solve my issue :)
08:31:54 <Cale> Ah, okay, so the generator  i <- takeWhile (<= h) [l+1 .. l+(xs!l)]  is choosing where to hop next
08:32:03 <Cale> We're at l
08:32:06 <zugz_> glguy: oh! that doesn't seem to happen in ghci
08:32:16 <Cale> and we're allowed to move at most xs!l steps from there
08:32:31 <Cale> and we don't want to move past h
08:32:40 * ski . o O ( `max' )
08:32:41 <buglebudabey> gotcha so far
08:32:46 <[k-> buglebudabey I did it!
08:32:47 <Cale> Yeah, we could have used max
08:32:49 <glguy> zugz_: GHCi disabled the Monomorphism Restriction. What can happen in that case is that things that look like they should be reused won't be because they've inferred a type that is too polymorphic
08:32:50 <Cale> :)
08:33:03 <Cale> I thought it was a little clearer to understand written this way somehow
08:33:13 <Cale> Actually, it would be min
08:33:19 <ski> er, right
08:33:24 <buglebudabey> now im getting confused
08:33:34 <Cale> which is the sort of confusion I wanted to avoid :D
08:33:50 <glguy> zugz_: So if you had let xs = [1..], and xs :: Num a => [a], then you wouldn't get the reuse behavior
08:33:53 <buglebudabey> i understood your first explanation, i derives from a list of possible places to jump given the current element
08:34:01 <Cale> yeah, okay
08:34:08 <glguy> zugz_: But if you had let xs = [1 :: Int ..], you would
08:34:09 <[k-> Did you!
08:34:09 <[k-> I'm uploading it now...
08:34:23 <Cale> So we pick i, the index we're going to consider jumping to
08:34:51 <[k-> ahhh my internet flopped 
08:35:05 <[k-> Cale: buglebudabey: http://lpaste.net/2851290777630277632
08:35:06 <Cale> and then we just make sure that either we're not going to be stuck there: if xs ! i is 0, then we wouldn't be able to move again, so we'd better be at the end at that point
08:35:22 <buglebudabey> Cale gotcha, and we have to see we arent on the last elem
08:35:43 <[k-> I received like 50 pending msgs from irc as i was uploading
08:36:02 <Cale> Well, if i == h, then we're allowed to jump there even if xs ! i is 0 because we wouldn't need any fuel to go further, because we'd be at our destination
08:36:15 <zugz_> glguy: ha, right!
08:36:21 <buglebudabey> Cale ah yes that's right
08:36:28 <zugz_> glguy: thanks, that helps alot
08:36:43 <Cale> and then we look at a ! i, which is Maybe the minimum number of steps to get from i to h
08:36:44 <buglebudabey> and so n derives from the possible jumps we've taken to get to L?
08:37:02 <Cale> If that's Nothing, then it's impossible to go from i to h, and we shouldn't pick i
08:37:26 <Cale> But if it's Just n, then n is a possible number of steps from i to h
08:37:30 <[k-> ah I see I got that part wrong
08:37:45 <zennist> anyone knows how to switch between different .ghci for ghci?
08:38:04 <zennist> if i launch a ghci in sandbox it tries to read my default .ghci which contains extra packages that it can't use
08:38:06 <Cale> Perhaps I should have written the "1 +" inside the list comprehension, which would give this list a bit more meaning
08:38:32 <buglebudabey> Cale like n+1 instead of n?
08:38:37 <[k-> that wouldn't clear anything up!
08:39:01 <Cale> If it was [n+1 | i <- takeWhile (<= h) [l+1 .. l+(xs ! l)], (xs ! i /= 0 || i == h), Just n <- [a ! i]], then that's the list of possible minimum numbers of steps to get from l to h, depending on which position we choose for our immediate next jump
08:39:31 <zugz_> glguy: so is the point that if you have something of polymorphic type, e.g. Integral i => [i], then each time it's forced a brand new thunk is created, even if the type turns out to be the same as one previously forced?
08:39:38 <Cale> If that list is empty, then it's impossible to get from l to h
08:39:52 <Cale> If it's nonempty, then its minimum is the minimum number of steps from l to h
08:40:01 <zugz_> glguy: (hope 'forced' is the right term here)
08:40:32 <glguy> zugz_: Yeah, the value has to be recomputed each time; GHC doesn't memoize the value by type
08:40:39 <Cale> Make sense?
08:40:58 <buglebudabey> Cale i'm processing, is it alright if i private message you to try to explain it back?
08:41:03 <[k-> yes
08:41:16 <Cale> As it is, the list is the list of minimum numbers of steps *after* we take that first one, and so we add 1 after taking the minimum
08:41:17 <zugz_> glguy: makes sense. Thanks muchly!
08:41:30 * ski . o O ( what about us lurkers wanting to see how the story ends ? )
08:41:39 <[k-> since I have already done most of the heavy lifting, I can understand \o/
08:41:59 <Cale> Basically, I translated and bugfixed some C code which did pretty much the same thing
08:42:20 <Cale> (The C code sort of mismanaged some edge cases though, I think)
08:43:16 <[k-> since I managed to figure out Cale's code to some extent, I think I'm more prepared to handle the industry's horrors!
08:43:24 <Cale> lol
08:43:51 <[k-> yes! finally I'm funny
08:43:52 <buglebudabey> Cale, ok so 1. i is derived from list of possible places we can jump to based on current element
08:44:02 <MarLinn> Cale: I don't know the context so forgive me if I'm misinterpreting the intent. But it seems like it might have helped a lot if the the variables and checks had more meaningful names like "lower", "upper", "wouldIBeStuck", and "destinationReached"
08:44:26 <[k-> yes MarLinn yes!
08:44:30 <Cale> MarLinn: yeah, possibly -- I followed similar conventions to the C program which buglebudabey linked the other day
08:44:43 <buglebudabey> Cale 2. as long as the current element is not 0, unless we are on the last element
08:44:45 <Cale> I wrote this because he asked how to translate it into Haskell
08:45:13 <buglebudabey> Cale 3. n derives from the minimum number of jumps from i to h
08:45:19 <[k-> does the C code have comments?
08:45:54 <buglebudabey> Cale so now we have a list of the minimum number of jumps from various indices
08:46:00 <Cale> buglebudabey: yes, that's right
08:46:42 <Cale> 2 is a little unclear: the point there is that we don't want to consider jumping somewhere that there's no fuel unless it's our final destination
08:46:42 <buglebudabey> Cale so the minimum of that would be the smallest amount of jumps to h from the index which has this property
08:46:45 <lolisa> Hi, I am reading about finger trees (http://andrew.gibiansky.com/blog/haskell/finger-trees/), can anyone tell me what if Affix is >4 or <4 instead of 4?
08:47:04 <Cale> buglebudabey: from l to h
08:47:28 <buglebudabey> Cale why from l to h if the list is the minimums from a set of indices?
08:47:33 <Cale> Well, once we add one to it, to account for the jump from l to i
08:47:55 <pavonia> What are the rules from which GHCi decides which command name to choose if you abbreviate the name? If I e.g. define a command :rh it is preferred over :reload though it appears later in the lexical order
08:47:57 <buglebudabey> Cale ok i think this is where my understanding ended
08:48:30 <Cale> Well, what we're computing overall, minJumps l h is supposed to be the minimum number of jumps to get from l to h
08:48:53 <Cale> given that xs is an array telling us how much fuel is available at each position
08:49:12 <Cale> (and thus how far we're allowed to jump from there)
08:49:14 <[k-> pavonia: you mean :r<tab_autocomplete>?
08:49:17 <buglebudabey> yup
08:49:31 <pavonia> [k-: Without the tab
08:49:40 <Cale> So, we compute the minimum number of jumps from each of the places we're allowed to go next
08:49:53 <Cale> and add 1 to the minimum of those
08:50:03 <[k-> pavonia: preferred in what sense?
08:50:06 <buglebudabey> ding
08:50:07 <buglebudabey> ok
08:50:29 <buglebudabey> that was long and drawn out and i very much appreciate you walking me through that Cale
08:50:42 <Cale> and this array a records the minimum number of jumps to our destination from each point
08:51:07 <Cale> It's basically just the minJumps function in the form of a data structure
08:51:29 <pavonia> [k-: I usually just type ":r <enter>" to relaod a module. Now I defined a command named ":rh" and suddenly got an unexpected reloading when running ":r", which was causes by it silently running my new command instead of the default :reload command
08:51:37 <Cale> Another thing I just noticed is that passing around h is redundant, since it never changes, and it's in scope from where it's bound by minJumpsArray
08:51:54 <ericdwhite> Hi is there a more idiomatic way of find the first matching item of list than this:
08:51:55 <ericdwhite> L.head $ L.filter (\role -> roleId role == id) availableRoles
08:52:25 <ericdwhite> data Role = Role { roleId :: UUID }
08:52:25 <ski> @type find
08:52:27 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
08:52:28 <ericdwhite> where a role is defined: data Role = Role { roleId :: UUID }
08:52:32 <joe9> The other day I had read about a haskell pattern to use when I am waiting for events on two channels. I cannot recall it now. Any suggestions on what it can be, please?
08:52:47 <buglebudabey> Cale when considering the list of things where we can jump to, we start from l+1 because it'd be pointless to stay in the same spot, correct?
08:53:07 <ericdwhite> thanks ski
08:53:22 <ski> ericdwhite : so `find ((id ==) . roleId) availableRoles' ?
08:54:27 <buglebudabey> Cale also is the time complexity of this O(n^2) as in the C implementation?
08:54:32 <[k-> pavonia: so you wanted :r to do what?
08:55:03 <[k-> oh dear it's very late, I have to go to school tmr
08:55:22 <pavonia> [k-: Ideally, to use the :reload command, but I'm fine with just knowing the rules from which it chooses the command name too
08:56:00 <pavonia> I guess a part of it is "new defined commands are preferred"
08:56:10 <[k-> hmm, well I don't know about that but it could be that user defined commands are preferred 
08:57:11 <[k-> or the shortest levenstein distance is chosen
08:57:33 <[k-> there are multiple possibilities, we have to look at ghci's documentation to find out
08:57:42 <Cale> buglebudabey, [k-: better variable names: http://cale.yi.org/reflex/Jumps/Jumps.jsexe/
08:57:57 <Cale> buglebudabey: Yeah, it ought to be O(n^2)
08:58:46 <[k-> i see... no change... should I clear cache?
08:59:28 <Cale> yes
08:59:44 <Cale> Shift-click your refresh button
09:00:15 <buglebudabey> very cool, i'll try to implement this on my own
09:00:22 <buglebudabey> thank you Cale 
09:00:34 <Cale> oh, yeah, I also wanted to move the +1 in, done
09:01:02 <Cale> I guess I should also indent that a bit more :P
09:01:09 <Cale> there
09:02:29 <[k-> could you maybe give a name for this: [here + 1 .. here + (fuel ! here)]
09:03:35 <[k-> and this `fuel ! next /= 0` eg. not impasse or whatever
09:03:38 <Cale> If I must. That's the list of reachable positions given the amount of fuel we have here
09:04:40 <Kvasir> haskell
09:04:41 <Kvasir> is c00l
09:04:44 <[k-> yes I know, but I can't read that
09:05:17 <[k-> At least I know I need to refactor my codebase now
09:05:28 <buglebudabey> [k- im glad youre so invested in this
09:05:31 <[k-> More readable names
09:05:54 <[k-> buglebudabey: :), but I need to go sleep now 
09:06:05 <buglebudabey> good luck, id be thinking about this in my sleep
09:06:59 <leshow> hey guys, whats the ghc extention that lets you write record@{..}
09:07:04 <leshow> any ideas about the ghc ext?
09:07:34 <buglebudabey> Cale does your code account for if the first element is 0?
09:07:38 <leshow> record@{..}
09:07:55 <leshow> and the members of record are available in the fn body?
09:07:58 <MarLinn> pavonia: the doc states "The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands" - so basically, don't rely on anything I suppose
09:08:10 <[k-> it does, I tested it myself
09:08:23 <Cale> buglebudabey: It does, of course you can try it right there :)
09:08:36 <Cale> buglebudabey: Did you try entering a list of numbers? :)
09:08:42 <pavonia> MarLinn: Oh, thank you
09:08:54 <liste> leshow: https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html
09:09:02 <liste> ie. RecordWildCards
09:09:08 <leshow> thats the one
09:09:10 <leshow> thanks man
09:09:13 <buglebudabey> ah i see, because next is empty
09:09:37 <pavonia> That makes perfect sense why this strange behaviour just started at some seemingly random point
09:09:46 <buglebudabey> or the set of next jumps i mean
09:10:02 <liste> leshow: though I prefer http://www.blaenkdenum.com/notes/haskell/#named-field-puns
09:10:35 <Cale> buglebudabey: right
09:10:49 <Cale> buglebudabey: This is a case that wasn't very well handled by the C code
09:10:54 <leshow> liste: im not sure i follow that one
09:11:12 <buglebudabey> Cale did you go to where I sent you for that @ geeksforgeeks or somewhere else
09:11:13 <liste> leshow: instead of writing Record{..}, you write Record{field1, field2}
09:11:15 <leshow> youre jsut renaming the field?
09:11:21 <Cale> buglebudabey: I just used your link
09:11:54 <buglebudabey> gotcha ok, there were two dynamic implementations, it seems you chose the second one which builds from right to left
09:12:01 <leshow> greet IndividualR { person = PersonR { firstName = fn } } = "Hi, " ++ fn
09:12:04 <leshow> is firstname renamed here?
09:12:05 <buglebudabey> Cale is that right?
09:12:18 <[k-> Cale: to be honest I preferred MarLinn's names
09:12:21 <Cale> Well, this is actually neither or both, in the sense that I don't say what order to compute the elements of the array
09:12:27 <liste> leshow: yes, that example doesn't use NamedFieldPuns
09:12:32 <liste> leshow: the latter one does
09:12:35 <buglebudabey> Cale bc it's lazily filled
09:12:45 <Cale> [k-: You have the source code, feel free to work on it ;)
09:12:51 <Cale> buglebudabey: right
09:12:55 <monochrom> leshow: Suppose I have "data X = X{whee::Bool}". Then NamedFieldPuns means I can write "f X{whee} = not whee". It will mean "f X{whee=v} = not v".
09:13:38 <Cale> buglebudabey: So the array elements will just be computed as they are needed, but at most once
09:13:40 <monochrom> It is not renaming. It is pun on field names
09:13:51 <buglebudabey> gotta love haskell
09:14:16 <buglebudabey> i'm practicing dp problems in preparation for google interviews, so i wanna get used to doing them in haskell
09:14:23 <leshow> monochrom: cool
09:14:34 <Cale> buglebudabey: Another library you might like to know about
09:14:39 <leshow> monochrom: i thoiught you could destructure like that without the = anywya though
09:14:45 <hamme> DP Problems? buglebudabey 
09:14:47 <Cale> http://hackage.haskell.org/package/data-memocombinators
09:14:53 <Cale> hamme: Dynamic programming
09:14:57 <buglebudabey> hamme out of context i know it's not great
09:15:25 <hamme> Well, I'm too green to know what's great or not, but it sounds interesting
09:15:35 <Cale> Which is a sort of ill-conceived name for recursive algorithms where you remember the results of subproblems after computing them the first time
09:15:59 <Cale> (because you would otherwise need to compute them repeatedly)
09:16:00 <ski> top-down dynamic programming is often nice
09:16:11 <buglebudabey> Cale so this memocombinators allows you to write in a naive recursive way while having the intermediate results memoized?
09:16:16 <Cale> Yeah
09:16:44 <buglebudabey> i think that's useful in practice but not for me currently trying to understand the concept :)
09:16:46 <Cale> You can start with the naive thing, stick in a memoiser in the way of the recursion, and get a dynamic programming solution
09:16:47 <Cale> heh
09:16:51 <monochrom> Almost naïve. You have to be sophisticated enough to write open recursion.
09:17:47 <buglebudabey> Cale it would be pretty sneeky in an interview: "oh is there a way we can optimize this from O(2^n) to O(n^3)?" - *sticks in Memo.whatever*
09:18:14 <hamme> Open recursion?
09:18:31 <buglebudabey> not sure what you mean by that
09:18:32 <suzu_> nah
09:18:34 <suzu_> what you guys need
09:18:37 <suzu_> for DP
09:18:40 <suzu_> is this:
09:18:52 <suzu_> http://jelv.is/blog/Lazy-Dynamic-Programming/
09:18:54 <monochrom> you could press the <return> key fewer times.
09:19:03 <suzu_> lol yeah my bad
09:19:04 <buglebudabey> suzu_ that's exactly what cale did
09:19:13 <suzu_> oh i didnt see
09:19:15 <suzu_> my mistake
09:19:23 <buglebudabey> it's alright it's been a long topic
09:19:44 <suzu_> i've also seen some people do crazy dp things using memofix and such
09:19:46 <suzu_> it makes my head spin
09:19:58 <Cale> hamme: By open recursion, monochrom means the sort where you take the function to be used recursively as an argument.
09:20:04 <suzu_> my understanding of fixpoints fail the longer i think about them
09:20:09 <Cale> (rather than just using the function being defined directly)
09:20:12 <buglebudabey> yeah im happy just doing the imperative mutable equivalent in haskell using that LDP
09:20:44 <suzu_> yeah you can just power through it using StateT and runStateT lol.
09:20:59 <hamme> So
09:21:17 <Cale> suzu_: The way I find helps to think about fix is just to imagine the recursive definition you'd give, for example
09:21:29 <Cale> fac n = if n == 0 then 1 else n * fac (n-1)
09:21:35 * ski would rather call it open recursion if something like `fix' is eventually used
09:21:52 <Cale> and just turn the function and its arguments into function arguments:
09:21:55 <hamme> recur f g n = recur (recur recur g) g (g n)
09:21:58 <Cale> \fac n -> if n == 0 then 1 else n * fac (n-1)
09:22:20 <Cale> and now applying fix will recover the recursive factorial
09:22:23 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
09:22:37 <suzu_> wtf.
09:22:51 <Cale> -> let f = (\fac n -> if n == 0 then 1 else n * fac (n-1)) f in f
09:23:00 <suzu_> my brain is spilling on the floor
09:23:08 <Cale> -> let f = (\n -> if n == 0 then 1 else n * f (n-1)) in f
09:23:13 <suzu_> i get that it works but if i think about why then i get confused pretty fast
09:23:27 <hamme> We all want to get off Mr Fix's Wild Ride
09:23:30 <monochrom> ski: Something like memofix is eventually used, it's OK :)
09:23:32 <suzu_> yes plz
09:23:57 <ski> monochrom : not exported by <http://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html>
09:24:03 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
09:24:06 <lambdabot>  3628800
09:24:13 <monochrom> I didn't check my spelling.
09:24:49 * ski did do an exact spelling match, anyway
09:24:54 <ski> s/did/didn't/
09:25:19 <Cale> suzu_: So this function  (\fac n -> if n == 0 then 1 else n * fac (n-1))  transforms a function 'fac' somehow.
09:25:32 <Cale> suzu_: Let's think about what it does to fac
09:25:49 <Cale> It doesn't matter what fac might do at 0, the resulting function will give 1 there.
09:26:07 <monochrom> ski: it's in the "memoize" library instead.
09:26:17 <Cale> and at any other n, the resulting function will multiply n by whatever fac produces at n-1
09:26:25 <suzu_> yup
09:26:31 <suzu_> and that fac
09:26:34 <suzu_> is just.. this function
09:26:46 <Cale> Well, when we apply fix, that will be true
09:26:57 <suzu_> hm
09:26:59 <suzu_> fix f = f $ fix f
09:27:06 <Cale> fix f = x where x = f x
09:27:10 <suzu_> so fix fac = fac $ fix fac
09:27:13 <suzu_> ?
09:27:13 <Cale> to put it another way
09:27:23 <Cale> sure
09:27:29 <ski> (monochrom : i was confused because the mentioned package didn't seem to suggest what i'd take to be open recursion ..)
09:27:29 <suzu_> so fix fac 8
09:27:34 <suzu_> = fac (fix fac) 8
09:27:43 * hackagebot probability 0.2.5.1 - Probabilistic Functional Programming  https://hackage.haskell.org/package/probability-0.2.5.1 (HenningThielemann)
09:27:45 * hackagebot antiprimes 0.1.0.1 - Initial project template from stack  https://hackage.haskell.org/package/antiprimes-0.1.0.1 (wokibe)
09:27:52 <suzu_> which expands to 8 * (fix fac) (n-1)
09:27:56 <suzu_> ooo
09:27:56 <Cale> right
09:27:59 <defanor> is there a drop-in mapM replacement that evaluates IO actions in parallel? i'm vaguely recalling that there was one, but failing to find it
09:27:59 <suzu_> I GET IT
09:28:07 <suzu_> man that's trippy
09:28:08 <v3x> hi
09:28:17 <liste> hi v3x 
09:28:28 <v3x> hi all
09:28:39 <Cale> > fix (1:)
09:28:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:28:48 <ski> hello v3x
09:29:09 <ski> > fix error  -- as long as we're fixing stuff, let's fix this ..
09:29:11 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:29:29 <liste> defanor: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:forkMapM
09:29:30 <Cale> suzu_: So one way to think about it (the way which inspires the name 'fix') is that we're producing something which is unchanged by further applications of the function.
09:29:51 <liste> defanor: there's also the `async' package which may be useful
09:29:55 <Cale> suzu_: and more specifically, we're producing the least-defined thing which is a fixed point of the function
09:29:59 <defanor> liste: thanks
09:30:20 <Cale> suzu_: Even if we pass a completely undefined function to (\fac n -> if n == 0 then 1 else n * fac (n-1))
09:30:31 <Cale> we end up with a function which is defined at 0, at least
09:30:33 <liste> defanor: https://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html#v:mapConcurrently
09:30:42 <Cale> > (\fac n -> if n == 0 then 1 else n * fac (n-1)) undefined 0
09:30:45 <lambdabot>  1
09:30:50 <Cale> > (\fac n -> if n == 0 then 1 else n * fac (n-1)) undefined 1
09:30:54 <lambdabot>  *Exception: Prelude.undefined
09:30:57 <Cale> of course, it's still undefined everywhere else
09:31:07 <monochrom> ski: I see now, data-memocombinators uses a different style from memoize.
09:31:11 <Cale> If we continue applying this function though... let's give it a name...
09:31:23 <Cale> @let mkFac = (\fac n -> if n == 0 then 1 else n * fac (n-1))
09:31:25 <lambdabot>  Defined.
09:31:36 <Cale> > mkFac (mkFac undefined) 0
09:31:39 <lambdabot>  1
09:31:41 <Cale> > mkFac (mkFac undefined) 1
09:31:43 <defanor> liste: ah, yup, that's the one i thought of -- mapConcurrently
09:31:44 <lambdabot>  1
09:31:52 <Cale> > mkFac (mkFac (mkFac undefined)) 2
09:31:55 <lambdabot>  2
09:32:08 <Cale> the more we apply mkFac, the closer we'll get to having a factorial function
09:32:39 <Cale> and fix basically computes the limit of this process
09:32:47 <suzu_> :S
09:32:54 <liste> defanor: both do basically the same thing, but forkMapM keeps track of possible exceptions
09:33:09 <liste> I guess mapConcurrently just fails once one is encountered (?)
09:33:58 <Cale> suzu_: Since it computes the least-defined fixed point, any function f for which f undefined = undefined will result in fix f = undefined
09:34:09 <Cale> > fix sin 5
09:34:11 <Cale> er
09:34:12 <lambdabot>  error:
09:34:12 <lambdabot>      • Could not deduce (Floating (t0 -> t1))
09:34:12 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
09:34:12 <Cale> > fix sin
09:34:18 <lambdabot>  mueval-core: Time limit exceeded
09:34:27 <liste> lambdabot's no jesus
09:34:33 <suzu_> rofl
09:34:55 <Cale> > sin undefined
09:34:57 <lambdabot>  *Exception: Prelude.undefined
09:35:29 <Cale> otoh, (1:) is a function for which (1:) undefined isn't the same as undefined
09:35:36 <Cale> > (1:) undefined
09:35:39 <lambdabot>  [1*Exception: Prelude.undefined
09:35:54 <Cale> > head ((1:) undefined)
09:35:57 <lambdabot>  1
09:36:10 <Cale> and so fix does something interesting
09:36:15 <Cale> > fix (1:)
09:36:18 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:36:38 <Cale> fix (1:) = x where x = (1:) x
09:37:06 <suzu_> > fix $ "A" ++
09:37:09 <lambdabot>  <hint>:1:13: error:
09:37:09 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:37:17 <Cale> > fix ("A" ++)
09:37:19 <lambdabot>  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
09:37:19 <suzu_> > fix ("A" (++))
09:37:22 <lambdabot>  error:
09:37:22 <lambdabot>      • Couldn't match expected type ‘([a0] -> [a0] -> [a0]) -> a -> a’
09:37:22 <lambdabot>                    with actual type ‘[Char]’
09:37:25 <suzu_> oops
09:37:28 <suzu_> yeah
09:37:29 <suzu_> heh
09:37:38 <Cale> > fix error
09:37:41 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:37:56 <suzu_> rofl
09:38:11 <suzu_> > fix undefined
09:38:15 <lambdabot>  *Exception: Prelude.undefined
09:38:38 <suzu_> hmm
09:38:42 <suzu_> > fix (0 +)
09:38:48 <lambdabot>  mueval-core: Time limit exceeded
09:38:53 <suzu_> makes sense
09:38:55 <Cale> > 0 + undefined
09:38:58 <lambdabot>  *Exception: Prelude.undefined
09:39:15 <MarLinn> so if fix finds "a least-defined point" - does that make it a dual to conal's "unamb"?
09:39:16 <Cale> There are some types of numbers for which fix (1+) wouldn't be undefined
09:39:32 <buglebudabey> Cale this seems useful and complicated, is way i could have known that this existed, how can i know to look for useful topics like this
09:39:47 <buglebudabey> is there a way*
09:39:52 <suzu_> the fixpoint is on the haskell wikibook i think
09:39:54 <Cale> buglebudabey: uh, hanging around in #haskell? :D
09:40:19 <buglebudabey> like suzu_ im cleaning up the mess my brain made when it fell
09:40:25 <suzu_> heh
09:40:27 <suzu_> i think i get it now though
09:40:33 <suzu_> after enough brain-mopping
09:40:57 <MarLinn> (I'm referring to http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice)
09:40:58 <Cale> buglebudabey: Least fixed points are a standard topic in most serious introductions to functional programming
09:41:14 <buglebudabey> frankly you lost me at fix f = x where x = f x
09:41:16 <conal> MarLinn: not that i know of. but they're closely related. unamb is a special case of least-upper-bound (lub), which is the same "least" as in "least fixed point".
09:41:17 <Cale> MarLinn: I'm not sure I'd say dual, but you can use the same sort of thinking to analyse what's going on
09:41:44 <conal> MarLinn: i.e., in a partial ordering of information content
09:41:45 <Cale> The sense of "least" is the same there
09:41:49 <Cale> yeah
09:41:51 <saurabhnanda> does anyone know how to pattern-match a bytestring?
09:42:02 <Cale> saurabhnanda: With a variable pattern
09:42:09 <Cale> That's about it
09:42:14 <saurabhnanda> Cale: how does that work?
09:42:21 <Cale> foo x = ...
09:42:23 <conal> MarLinn: that ordering and lub are foundational in the meanings of languages with recursion, which is formalized via fix
09:42:28 <Cale> x might be a bytestring
09:42:44 <ongy> saurabhnanda: Cale is telling you that you can't do more than naming it
09:42:46 <saurabhnanda> Cale: more complicated that that
09:42:52 <Cale> You can add guards
09:42:52 * ski . o O ( .. view pattern ? )
09:42:56 <glguy> Or with overloaded strings you can have: foo "stuff" = ...
09:43:01 <saurabhnanda> Cale: following doesn't work due to 'toS' // catcher _ (UniqueViolation (toS "idx_unique_tenants_backoffice_domain")) = return . Left NonUniqueBackofficeDomainError
09:43:16 <saurabhnanda> glguy: Cale: don't want to use overloaded strings. Find them **really** weird
09:43:21 <saurabhnanda> glguy: Cale: is that the only way to do this?
09:43:31 <joe9> which is recommended ? Yampa or reactive-banana?
09:43:35 <Cale> Well, that's basically what you're asking for
09:43:47 <Cale> joe9: reactive-banana of those two
09:44:01 <glguy> saurabhnanda: It's probably just worth taking a couple minutes to learn overloaded strings than to avoid them for long
09:44:01 <Cale> joe9: Of course, I have to mention reflex ;)
09:44:03 <saurabhnanda> Cale: why can't I use toS in the pattern match? Also, will view patterns help me? How to use them?
09:44:23 <Cale> saurabhnanda: You can't match against functions
09:44:42 <Cale> and there's no way to know that the bytestring you got is really obtained by applying toS
09:44:53 <Cale> Haskell isn't magic, it can't invert arbitrary functions
09:45:17 * ski . o O ( Mercury )
09:45:29 <saurabhnanda> Cale: got it. How should I proceed here? OverloadedStrings? or view patterns?
09:46:53 <Cale> saurabhnanda: You could just use a guard
09:47:01 <saurabhnanda> View patterns extend our ability to pattern match on variables by also allowing us to pattern match on the result of function application.
09:47:24 <Cale> catcher _ (UniqueViolation s) | s == toS "idx_unique_tenants_backoffice_domain" = return . Left NonUniqueBackofficeDomainError
09:47:48 <Cale> But sure, a ViewPattern would work
09:47:58 <saurabhnanda> Cale: is the compile-time/run-time behaviour of the two cases any different? specifically in terms of compile-time safety?
09:48:05 <Cale> hm?
09:48:11 <Cale> Of which two cases?
09:48:30 <Cale> A ViewPattern would basically immediately result in the same thing as this guard
09:48:44 <joe9> Cale, I just stumbled upon reflex. It seems highly regarded too. Thanks for the recommendation.
09:48:54 <saurabhnanda> Cale: constructor pattern match vs guard?
09:49:15 <Cale> joe9: We use reflex in production applications, so I can be pretty confident that it's reasonably viable :)
09:49:45 <MarLinn> conal: I think you just opened a whole new rabbit hole for me to descend into. Thank you! :)
09:49:51 <joe9> saurabhnanda: check out https://hackage.haskell.org/package/string-conversions-0.4/docs/Data-String-Conversions.html
09:49:52 <Cale> joe9: and reflex-dom is a lot of fun -- I actually enjoy the frontend work on our web applications more than working on the backend now thanks to it
09:49:58 <conal> MarLinn: :D
09:50:34 <joe9> Cale, Thanks. will check out reflex. My frontend is opengl (glfw), so, reflex-dom is not for me (I think)
09:52:29 <joe9> Cale, any articles you recommend for starting with frp and reflex?
09:52:59 <Cale> joe9: Well, maybe pick up reflex-dom to start with, because most of the tutorial content is in that form at the time being
09:53:24 <Cale> But we really would like someone to build some kind of GL binding ;)
09:53:43 <Cale> https://github.com/reflex-frp/reflex-platform
09:53:53 <Cale> If you scroll down there's a bit of a tutorial there
09:54:01 <Cale> and instructions for getting set up
09:56:48 <Cale> joe9: I *really* need to write more tutorials and stuff
09:57:25 <Cale> joe9: I've been helping various people out with things, and posting little examples here: http://cale.yi.org/reflex/
09:57:38 <Cale> But they're sort of random things
09:58:37 <joe9> Cale, Thanks. will check it out.
09:58:58 <c_wraith> Hmm. Does GHCJS.DOM.XMLHttpRequest support CORS on IE?
09:59:24 <Cale> and there's a talk about reflex given by Ryan Trinkle here: https://www.youtube.com/watch?v=dOy7zIk3IUI
09:59:29 <joe9> Cale, I read about time-leak with FRP. Does reflex suffer from the issue too?
09:59:31 <c_wraith> I've checked FF and Chrome, but IE is hard to find.  In this house.
09:59:49 <c_wraith> and IE is the weird one with respect to CORS
10:00:16 <Cale> joe9: Time leaks as in, not being able to finish computing a frame before the next one?
10:00:42 <Cale> joe9: There are various things which are just fundamental issues that you have to contend with no matter how you program a system.
10:00:54 <joe9> Cale, ok. Thanks.
10:01:05 <monochrom> Time leaks like an arrow.
10:01:23 <monochrom> Syntax rules like a macro.
10:01:37 * ski grins
10:01:48 <Cale> joe9: One thing you still have to be cautious about is not describing a system which is paradoxical, or underdetermined
10:02:13 <Cale> joe9: It's possible, using recursion, to describe an event which is firing if and only if it is firing.
10:02:35 <Cale> (I mean, when you go to try to figure out whether the event is firing, you end up in an infinite loop)
10:02:44 <ski> @remember monochrom Time leaks like an arrow. Syntax rules like a macro.
10:02:46 <c_wraith> That's less paradoxical than an event that's firing only when it isn't firing.
10:02:46 <lambdabot> Done.
10:02:52 <Cale> c_wraith: for sure :)
10:03:11 <ski> (can you even express that ?)
10:10:41 <Cale> ski: Well, in Reflex, you can't quite express that
10:11:11 <JonReed> Hi, can anybody help me with this minimalistic example: http://lpaste.net/190943 I'm basically trying to wrap three shell-conduit commands in a free monad so that I can have my own interpreters for them later. But I'm probably doing free monads wrong. It typechecks, but there is an infine loop on one line. I can't figure out how to model / wrap those commands correctly without creating the infinite loop. Thanks!
10:11:57 <Cale> ski: But you can take some clock :: Event t (), and try to define an event paradox :: Event t () which is firing when clock is firing and paradox is not.
10:12:15 <Cale> (and you'll just get an infinite loop if you do that)
10:13:33 <mpickering> How do I modify a vector index?
10:13:54 <c_wraith> What does that even mean?
10:14:18 <mpickering> I want to modify the 3rd element in a vector
10:14:26 <c_wraith> Ah.  Change the value at an index.
10:14:31 <c_wraith> First, is it a mutable vector?
10:14:36 <mpickering> Yes, that first statement was very unclear sorry
10:14:54 <mpickering> I can change the representation to whatever is most convenient 
10:15:17 <Cale> Immutable vectors are much more convenient in a lot of other ways
10:15:36 <Cale> but if you're going to do a lot of index-based writes, you probably want a mutable vector
10:15:59 <Cale> write :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()
10:16:12 <Cale> m = IO will work
10:17:07 <Cale> mpickering: But, what is it that you're doing? If you haven't yet decided what data structure to use, perhaps you might also want to consider Map or IntMap
10:17:18 <mpickering> eh, I'm trying to efficiently represent a function "Colour -> Int" and it seemed the best way was to use a vector of some kind
10:17:35 <mpickering> So, Colour is of fixed size (4 in this case)
10:17:46 <Cale> Yeah, you definitely don't want a mutable vector
10:17:52 <mpickering> and has Enum instance etc
10:18:14 <Cale> It sounds like you just want to define an immutable vector all at once, and shouldn't need to alter its value at a single index
10:18:26 <monochrom> Using Data.Vector.* for Colour is going to beg the question :)
10:18:59 <mpickering> The point is that this function needs to be update as it represents the scores in a game
10:19:19 <mpickering> so the initial specification is that "f = const 0" 
10:19:35 <mpickering> and is updated periodically when players (colours) score points
10:20:07 <Cale> mpickering: I would just use a Map Colour Int
10:20:25 <monochrom> A vector of 4 and the (//) operator aren't too shabby.
10:20:34 <Cale> Yeah, you *can* do that
10:20:46 <mpickering> ok, with strict fields I guess?
10:20:49 <Cale> But Map Colour Int is going to be nicer
10:21:15 <monochrom> true. Map Colour Int is very little to code up
10:22:51 <Cale> Also, as far as data structures go, I would consider it more important to learn to use Map before almost anything other than lists.
10:23:13 <monochrom> That's what Perl and Python do to people.
10:23:33 <monochrom> And the consequence is that now people don't know anything outside hash tables.
10:25:22 <deni> am I mistaken in assuming that this: (_, xs) <- globDir [compile "*.txt", compile "*.md"] "/tmp/dinamo" would filter /tmp/dinamo3/dinamo3.txt and not just top level files like "/tmp/dinamo/dinamo1.txt"?
10:25:25 <deni> cause it doesn't
10:25:38 <deni> it levaes dinamo3.txt in there as if it's not matched by "*.txt"
10:25:38 <mauke> pfft, a perl programmer could just have done my ($player1, $player2, $player3, $player4) = \(@scores);
10:25:44 <mauke> and then $$player1 += 1; etc
10:26:06 <deni> btw I'm using the Glob package
10:26:09 <deni> (latest version)
10:27:14 <deni> although now I read this: "Any results deeper than in the given directory are enumerated lazily, using unsafeInterleaveIO." and I'm not sure if I should be using this package at all
10:27:32 <c_wraith> deni: that is questionable, yeah
10:30:34 <hamme> Cale, at 29:33 in the video, when he asks for someething that can delete values... we have Witherable that can do that right?
10:32:04 <Cale> hamme: yes, that now exists.
10:32:38 <Cale> It's sort of reasonable... that library goes a little off the rails with the punny names
10:32:49 <Cale> But it's basically what we want
10:32:57 <Cooler> :t length
10:32:59 <lambdabot> Foldable t => t a -> Int
10:33:17 <Cooler> why does it return a Int and not a Integral i
10:34:17 <MarLinn> :t genericLength
10:34:19 <lambdabot> Num i => [a] -> i
10:35:05 <MarLinn> > maxBound :: Int -- probably because of that
10:35:08 <lambdabot>  9223372036854775807
10:35:10 <Cale> Cooler: It probably should produce a result of any Num type, but Int is fast.
10:35:30 <Cale> Personally, I kind of wish that Int were not in the Prelude though.
10:35:50 <hamme> Well
10:35:56 <ongy> in favor of Integral?
10:35:56 <Cooler> Cale, why should it produce a result of Num a?
10:36:05 <Cooler> the length can only be integers
10:36:08 <hamme> Isn't that half of what inspires the names in Haskell Libraries? Cale 
10:36:09 <deni> c_wraith: do you know of any other libary that handles unix style wildcard file path matching?
10:36:34 <Cale> Cooler: Because no operations of Int would be required
10:36:41 <Cale> er, sorry, no operations of Integral
10:36:46 <Cale> you don't need to be able to divide
10:36:54 <Cale> You only need 0, 1, and (+)
10:37:04 <Cale> That's all stuff available from Num
10:37:37 <Cooler> well the point is to constraint the co-domain to be as small as possible
10:37:47 <mauke> how about Int?
10:37:51 <mauke> that's pretty small
10:37:58 <Cooler> Int is too small, what if the list exceeds Int's range?
10:38:05 <MarLinn> Cooler "Be conservative in what you emit and forgiving in what you accept" - and the constraint is something a function *accepts* from outside
10:38:07 <mauke> then you've run out of memory
10:38:44 <Cooler> mauke, what?
10:39:03 <ongy> > length . take (fromIntegral (maxBound :: Int) + 1) $ [1..]
10:39:04 <Cooler> > maxBound :: Int
10:39:06 <lambdabot>  0
10:39:08 <lambdabot>  9223372036854775807
10:39:23 <Cooler> oh its a 64 bit int
10:39:30 <Cale> mauke: Not necessarily... though your program will have been running for a very long time on a 64 bit machine
10:39:50 <Cale> Cooler: It's a whatever-your-machine-architecture-dictates int
10:40:06 <ongy> why is it 0? I thought it would overflow "the normal way"
10:40:15 <Cooler> MarLinn, no the constraint is only on the output
10:40:40 <mauke> :t take
10:40:41 <Cooler> length :: Integral i => [a] -> i
10:40:41 <Cale> ongy: take accepts an Int argument ;)
10:40:42 <lambdabot> Int -> [a] -> [a]
10:40:52 <mauke> > fromIntegral (maxBound :: Int) + 1 :: Int
10:40:55 <lambdabot>  -9223372036854775808
10:41:13 <mauke> > take (fromIntegral (maxBound :: Int) + 1 :: Int) [1,2,3]
10:41:16 <lambdabot>  []
10:41:18 <ongy> > length . (++) [0] . take (maxBound :: Int) $ [1..]
10:41:18 <deni> c_wraith: found this: https://hackage.haskell.org/package/filemanip seems better
10:41:23 <ongy> now it will run out of time
10:41:25 <lambdabot>  mueval-core: Time limit exceeded
10:41:53 <Cale> The main problem with using Int is that because it appears in those Prelude types, it's easy for things to accidentally end up being Int when you expected them to default to Integer, and they might be involved in other arithmetic for which Int is ill-suited
10:42:29 <Cooler> well its not a big deal for most uses
10:42:40 <Cale> Yeah, most of the time it's not going to be too much trouble
10:42:44 <deni> or not: import System.IO.Unsafe (unsafeInterleaveIO)
10:42:46 <ongy> also if we are talking about length, and it has to be integers: it can't be negativ, so Word would even be better
10:42:51 <ongy> same for take and a few others
10:42:56 <Cale> But every once in a while, you get a bug which is quite difficult to notice.
10:43:45 <ongy> but I think Int (and I guess Word) are a usability thing. is there a good benchmark how much slower Integer is on numbers that can fit Int?
10:43:46 <Cooler> :t Word
10:43:48 <lambdabot> error:
10:43:48 <lambdabot>     • Data constructor not in scope: Word
10:43:48 <lambdabot>     • Perhaps you meant variable ‘ord’ (imported from Data.Char)
10:43:57 <ongy> Cooler: Int is signed, Word is unsigned
10:44:03 <ongy> > maxBound :: Word
10:44:06 <lambdabot>  18446744073709551615
10:44:07 <ongy> > minBound :: Word
10:44:09 <lambdabot>  0
10:45:22 <Cooler> well you still want to be able to do arithmetic
10:45:36 <ongy> is there a way to get progress output when doing the stupid >maxBound list length example?
10:45:36 <Cooler> especially -
10:46:04 <mauke> yeah, remove the 'length'
10:46:35 <MarLinn> Cooler: yes, the constraint restricts output. But whatever uses the function provides the constraint as "input" at compile time. It feels a bit backwards, but what counts is the result: have your stuff be usable in as many contexts as possible
10:46:58 <ongy> mauke: I think that's enough output to get slowed down by the terminal
10:47:02 <ongy> but it's a stupid idea either way
10:48:01 <Cooler> MarLinn, there are functions like fromIntegral for that
10:48:20 <ongy> Cooler: then why not use Word when it's the better fitting type?
10:48:26 <Cooler> sure Word
10:48:28 <ongy> there's fromIntegral if you want to do -
10:49:00 <MarLinn> why would I use an explicit conversion if I could just rely on the type system to figure out what I want?
10:50:12 <Cooler> this isn't about convenience
10:50:28 <Cale> ongy: Of course, the real reason is that when length was first defined in the Haskell Report, Word didn't exist.
10:50:44 <ongy> oh, Word is new-ish?
10:51:03 <Cale> Word doesn't appear anywhere in the Haskell report
10:51:11 <Cale> But that's not much of an excuse
10:51:27 <ongy> does the Haskell report explicitly mention length?
10:51:29 <Cale> Especially now that the type of length includes Foldable now
10:51:35 <Cale> yes
10:51:50 <ongy> how does Foldable matter here?
10:52:02 <Cale> Well, Foldable also doesn't occur in the Report
10:52:34 <ongy> ah. But changing it would be worse
10:52:37 <Cale> But the generalisation to Foldable is less of an incompatibility in some ways
10:52:46 <Cale> If you quietly change Int to Word
10:52:55 <Cale> then via type inference, you can create lots of other bugs
10:53:14 <Cale> So every program ever needs to be audited
10:53:47 <Cale> If the change from [a] -> Int to (Foldable f) => f a -> Int causes problems, they'll just be type errors
10:54:02 <Cale> They won't be runtime failures
10:54:13 <ongy> I agree that it shouldn't be changed. I just think it's weird. I really dislike how much Int is used over word when Word is the fitting type
10:54:22 <ongy> but it's to an extend that I do it myself because I forget
10:54:24 <Cale> I would prefer Integer
10:54:55 <ongy> we do have genericLength. I always so the non-generic ones as performance optimization
10:54:58 <Cale> Or of course, it would be really nice to have an unbounded Natural type with good performance
10:55:17 <ongy> unbounded and good performance? do those exist?
10:55:28 <cocreature> some people (I’m undecided whether I agree) also claim that unsigned types cause more problems than they solve because underruns are so easy to produce
10:55:54 <Cale> ongy: Well, Integer exists, and Natural would just have to get rid of the representation of negative numbers.
10:56:28 <ongy> cocreature: I think that's mostly getting used to. Since most people are used to signed types (I kind of blame java since it's often an introductory language)
10:56:33 <Cale> Yeah, the instance of Num for Natural is awkward, because subtraction is weird
10:56:57 <ongy> @src Num
10:56:58 <lambdabot> class Num a where
10:56:58 <lambdabot>     (+), (-), (*)       :: a -> a -> a
10:56:58 <lambdabot>     negate, abs, signum :: a -> a
10:56:58 <lambdabot>     fromInteger         :: Integer -> a
10:57:01 <Cale> ongy: It's more that Integer is a ring, and Natural is not
10:57:35 <ongy> :t div
10:57:36 <lambdabot> Integral a => a -> a -> a
10:57:50 <ongy> > (5 :: Float) div 2
10:57:53 <lambdabot>  error:
10:57:53 <lambdabot>      • Couldn't match expected type ‘(Integer -> Integer -> Integer)
10:57:53 <lambdabot>                                      -> Integer -> t’
10:57:59 <Cale> I could probably get behind the idea of having a Natural type for which underflows result in 0
10:58:16 <Cale> because this coincides with how drop interacts with lists :)
10:58:37 <cocreature> ongy: it’s onemmore thing that you need to pay attention to. basically every check of the form "x - y < z" will create problems
10:59:08 <ongy> technically that's alwasy true, just that values don't tend to be that low/high :)
10:59:13 <hesk> How do i get the type of a data type, like (getType foo) == b? 
10:59:36 <Cale> hesk: You know it at compile time
10:59:39 <cocreature> ongy: sure, but it gets vastly more important for unsigned types
10:59:46 <mauke> hesk: if you could, what would you do with it?
10:59:48 <ongy> and outside that awkward numbers "x < z + y" would work
10:59:59 <hesk> I want to use it in a predicate 
11:00:03 <Cale> hesk: Types actually don't exist at runtime
11:00:06 <mauke> hesk: such as?
11:00:23 <ongy> that's whay I say, it's getting used to. But I agree that a sudden change would introduce avoidable bugs
11:00:27 <hesk> mauke: such as if (getType foo) == b then bar
11:00:41 <mauke> hesk: you're assuming types support ==
11:00:43 <mauke> hesk: they don't
11:00:47 <Cale> hesk: The compiler removes them all -- at runtime, all that's left is a bunch of untyped pointer manipulation and arithmetic and such :)
11:01:01 <cocreature> bounded types are weird anyway, e.g. abs doesn’t guarantee that it returns a positive number in most languages
11:01:03 <mauke> also, that would break polymorphism
11:01:07 <cocreature> > abs (minBound :: Int)
11:01:17 <lambdabot>  mueval-core: Time limit exceeded
11:01:17 <lambdabot>  mueval: ExitFailure 1
11:01:17 <hesk> Maybe I'm confusing terms here. I have a defines a data type: data Bar = foo String String | baz String String
11:01:24 <cocreature> oO
11:01:31 <cocreature> > abs (minBound :: Int)
11:01:31 <hesk> And I want to retrieve foo or baz to be used in a function
11:01:39 <mauke> hesk: use case .. of
11:01:40 <lambdabot>  mueval-core: Time limit exceeded
11:01:41 <Cale> hesk: Pattern matching
11:01:42 <cocreature> weird
11:01:50 <Cale> Also, foo and baz need to be uppercase
11:02:05 <Cale> Data constructors always start with an uppercase letter
11:02:06 <ongy> @src abs
11:02:06 <lambdabot> Source not found. Take a stress pill and think things over.
11:02:27 <cocreature> @undefine
11:02:28 <lambdabot> Undefined.
11:02:29 <Cale> ongy: It's a class method
11:02:30 <cocreature> > abs (minBound :: Int)
11:02:31 <hesk> Oh okay. I'll try that. But am i able to return Foo? 
11:02:33 <lambdabot>  -9223372036854775808
11:02:46 <Cale> hesk: Foo is a function, sure you could return that function...
11:03:02 <hesk> oh.. so value constructors are functions? 
11:03:05 <Cale> yes
11:03:09 <hesk> But type constructors are not?
11:03:20 <ongy> :t geInt
11:03:22 <lambdabot> error: Variable not in scope: geInt
11:03:22 <Cale> Well, they're functions if they have arguments
11:03:30 <Cale> They might not be functions
11:03:42 <imPure> Is it possible to write a plugin that runs some of the bindings it finds?
11:03:44 <Cale> and similarly, type constructors may or may not be type-level functions
11:03:55 <Cale> Integer is a type constructor which is not a type level function
11:04:04 <Cale> Maybe is a type constructor which is a type level function
11:04:12 <hesk> So in my expression Bar is a type-level function?
11:04:13 <Cale> :k Integer
11:04:15 <lambdabot> *
11:04:16 <Cale> :k Maybe
11:04:17 <lambdabot> * -> *
11:04:22 <mauke> hesk: no, it has no arguments
11:04:28 <Cale> Bar is not, because it has no type arguments
11:04:31 <hesk> isn't it a null-value function? :S 
11:04:37 <Cale> hm?
11:05:09 <mauke> hesk: then what does "function" even mean if it includes non-functions?
11:05:11 <hesk> nullary I mean
11:05:15 <ongy> > negate (5 :: Word)
11:05:17 <lambdabot>  18446744073709551611
11:05:23 <ongy> oh...
11:05:31 <Cale> hesk: "Nullary function" is a bit of a questionable choice of terminology
11:05:50 <hesk> Oh okay, so there are no 0-argument functions in haskell
11:06:00 <Cale> All functions are 1-argument functions in Haskell
11:06:03 <mauke> all functions have exactly one argument
11:06:10 <hesk> I see
11:06:20 <Cale> Those which appear to take more arguments are actually producing other functions as their result
11:06:23 <imPure> hesk: In a stateless language, what's the difference between 0 arguments and a constant?
11:06:25 <Cooler> every function has exactly one parameter as input and exactly one output
11:07:03 <mauke> imPure: depends on how you call functions
11:07:22 <hesk> imPure: I guess it's a matter of definition, you'd have to define them to be equivalent
11:07:25 <imPure> mauke: w.r.t. correctness, not complexity, if that's what you're getting at.
11:07:32 <Cooler> imPure, 0 arguments doesn't mean its constant, just that its not a function, its a value
11:07:34 <mauke> imPure: what?
11:07:39 <Cooler> it could be something like a IO action
11:08:01 <imPure> Ok, I confused people. The exact opposite of my intent with that rhetorical question.
11:08:08 <imPure> Ignore I said anything.
11:08:44 <imPure> Cooler: I did say stateless (AKA pure) ;)
11:08:56 <Cooler> oh right
11:09:44 <imPure> Bottom line, if every time you call a function with the same inputs, you get the same outputs, then a nullary function is morally equivallent to a constant w.r.t. correctness.
11:09:58 <imPure> It may vary in complexity depending on implementation details.
11:10:08 <mauke> that assumes you can call nullary functions
11:10:15 <mauke> in haskell, you can't
11:10:24 <Cale> "call" is weird terminology with respect to Haskell
11:10:27 <imPure> > 5
11:10:27 <mauke> there's only function application, not calling
11:10:29 <lambdabot>  5
11:10:45 <Cale> I mean, it roughly amounts to the same thing as function application
11:10:57 <Cale> But it indicates that you're thinking about things in a strange way
11:11:10 <mauke> the difference is that functions are applied to an argument
11:11:13 <imPure> Cale: Thanks!
11:11:20 <mauke> a "call" could be without arguments
11:11:24 <imPure> Cale: Assuming you meant me.
11:11:32 <Cale> I was just speaking generally :)
11:11:43 <imPure> Cale: But I think you meant mauke
11:11:53 <Cale> But I suppose you were the one who said "call" in the first place
11:12:09 <mauke> the other weird issue you get into is that if values are nullary functions, what do those functions return?
11:13:00 <imPure> Calling conflates binding with execution.
11:13:18 <imPure> To call something implies that an action occured, which isn't very pure
11:13:26 <Cooler> mauke, they return themselves?
11:13:46 <imPure> In IO and other monads, binding may occur at a time, and coincident with that a stateful update may occur
11:14:10 <imPure> In pure Haskell, only binding occurs, logically, so there is no call...
11:14:35 <mauke> Cooler: then calling or not calling them makes no difference
11:14:47 <mauke> in which case you might wonder in what sense they really are "functions"
11:14:48 <imPure> But if someone here is new to Haskell and isn't familiar with laziness, what I said earlier about complexity... An evaluation does occur at some point, and that takes time to execute.
11:14:49 <Cooler> which is why they are equivalent to a constant
11:15:22 <imPure> Or... may execute.
11:15:25 <imPure> And may not.
11:15:49 <Cooler> you could define calling a nullary function as beta reduction
11:16:37 <imPure> Cooler: But only in pure Haskell, right?
11:16:49 <Cooler> yes
11:17:03 <mauke> ok, how do you beta reduce 42?
11:17:11 <imPure> Cooler: I'm genuinley asking, I'm not so great at fundamentals.
11:17:17 <imPure> mauke: Build a planet.
11:17:43 <mauke> my next questions will be how to beta reduce x and \x -> x
11:18:07 <Cooler> mauke, well beta reduction stops when there are no arguments left to apply
11:18:07 <ongy> mauke: \x -> x isn't nullary, is it?
11:18:27 <mauke> that's the third awkward part, btw: you'd have to say that \x -> x is both a nullary function (because every value is) and a unary function
11:18:33 <Cooler> mauke, also i am not arguing that values are functions
11:18:39 <imPure> Sorry to crash the party, but if anyone here knows about Haskell Plugins I'm here because I have a question.
11:18:47 <hpc> \x -> x is also a 2-ary function and a 3-ary function and ...
11:19:04 <hpc> > (\x -> x) (+) 5 6
11:19:07 <lambdabot>  11
11:19:10 <monochrom> @quote monochrom 17-ary
11:19:10 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
11:19:17 <mauke> hpc: only through the lens of currying :-)
11:19:48 <hpc> sure but as long as we're discussing the arity of functions in "haskell" it's something to consider
11:21:05 <hpc> (or possibly put arity in quotes instead, depending on how the conversation ends up going)
11:23:40 <hesk> hpc: that's how I, being a haskell noob, intepret arity in Haskell aswell. It feels more compatible to the languages of logic and math. 
11:27:11 <hpc> yeah, it's more of a casual definition of arity, just thinking in terms of how many arguments can be applied
11:27:45 * hackagebot implicit-logging 0.2.0.0 - A logging framework built around implicit parameters.  https://hackage.haskell.org/package/implicit-logging-0.2.0.0 (rev_null)
11:33:14 <hamme> Huh, thanks for that talk, it had a lot of leads to look into, Cale . I'm curious where one can find Red Line, do hackathons release contestant sources?
11:36:12 <Cale> hamme: I think RedLine still exists somewhere... it was compiled against a super-early version of reflex and the performance therefore sucks
11:36:16 <Cale> I could try to dig it up
11:36:30 <Cale> But really, we should just get it working against a modern reflex-dom :)
11:41:32 <hamme> I'm getting the impression that you are one of the maintainers of Reflex-Dom, Cale 
11:42:17 <Cale> hamme: I have commit access anyway ;)
11:42:27 <Cale> hamme: I'm working for Obsidian Systems
11:42:33 <Cale> which is Ryan's company
11:43:25 <Cale> Legal Hackers had the Redline demo up and running somewhere...
11:43:36 <hamme> Hitting next door is good enough for gov't work
11:43:47 <Cale> I'm just not sure where it is now :)
11:44:19 <flippant> how do you convert a bytestring to an integer?
11:44:31 <c_wraith> flippant: how is it encoded?
11:44:39 <flippant> it's a utf8 string
11:44:58 <c_wraith> So..  decimal representation using digit characters?
11:45:09 <flippant> i guess
11:45:11 <Cale> at some point not too long ago, it was apparently at https://www.hackerleague.org/hackathons/code-the-deal/hacks/obsidian-redline
11:45:14 <ania123> as I see factorial in lambda calculus can be encoded as follows: - fact = λn. cond (isZero n) 1 (Mult n (fact (Pred n)))
11:45:19 <Cale> but the DNS doesn't resolve for me now
11:45:40 <hamme> me neither
11:45:59 <ania123> why do I need fixpoint combinator? I can calculate fact 3 witout any problems with this encoding, why do I need to use fixpoint?
11:46:09 <flippant> c_wraith: i'm trying this: >  let raw = r ^. responseBody; read $ unpack raw
11:46:23 <monochrom> flippant: I think Data.ByteString.Char8 has one for it.
11:46:28 <flippant> thanks
11:46:36 <Cale> hamme: I found this picture of Ali demoing it :D http://www.meetup.com/legalhackers/photos/24615002/412606902/
11:46:38 <hpc> ania123: you're calling fact from within the definition of fact
11:47:00 <hpc> ania123: which is what fix encodes
11:47:02 <ania123> hpc: and what is a problem?
11:47:12 <ania123> why we need fix at all?
11:47:29 <hpc> we don't NEED it any more than we need Bool
11:47:30 <ania123> λn. cond (isZero n) 1 (Mult n (fact (Pred n))) 3
11:47:36 <hpc> but we can define it and it's useful sometimes so it's there
11:47:39 <ania123> I can calculate without using fix
11:48:07 <c_wraith> ania123: if you syntactically forbid recursion, how are you going to calculate recursive problems?
11:48:12 <hpc> perhaps you are writing some other recursive thingy and you don't feel like giving it a name
11:48:22 <monochrom> ania123: depending on which variant of lambda calculus you're reading, there may or may not be "=" to begin with. If you don't have "=", you can't even write a recursive definition.
11:48:26 <c_wraith> ania123: well, that's what fixed-point combinators do.  They recover recursion when you can't use it directly.
11:48:27 <hpc> in which event you do need fix in order to write it anonymously
11:48:40 <monochrom> But if your variant has "=", good for you.
11:49:33 <ania123> if I have untyped lambda calculus\
11:49:42 <ania123> pure lambda calculus
11:49:51 <monochrom> Church's original untyped lambda calculus did not have "=".
11:49:57 <ania123> right
11:50:04 <ania123> do I need "="
11:50:05 <ania123> ?
11:50:19 <monochrom> It was not a system for making definitions. It was only a system for writing expressions.
11:50:23 <ania123> I can encode factorial directly as
11:50:40 <ania123>  λn. cond (isZero n) 1 (Mult n (fact (Pred n)))
11:50:50 <ania123> I can say it is ancoding of fact
11:51:13 <Cale> Church's original lambda calculus was almost completely unrecognisable
11:51:44 <flippant> is there any way to turn something of the type (Read (IO a)) into (IO a)?
11:51:45 <monochrom> You have a free variable "fact" there and I don't know what to do with it.
11:51:58 <c_wraith> Well, wasn't Church a logician?  
11:52:06 <c_wraith> Things tend to look very different from that side
11:52:07 <monochrom> And you are forbidden "=" so you can't answer me with "fact = what your just wrote"
11:52:21 <Cale> https://docs.google.com/file/d/0B0CU-A1oqzzLd3VfWm1ja1E2WDQ/view
11:52:22 <geekosaur> flippant, that looks like a constraint to me (and an incorrect one, to boot). can you provide the context for this?
11:53:00 <monochrom> Overall you're taking something for granted, something sensible in a practical language, but you don't know it and you think like "what's the big deal?"
11:53:13 <monochrom> Well we can't answer until you know you're taking something for granted.
11:53:32 <flippant> geekosaur: i've got a function that does calls a rest endpoint which gives me a string which i then have to cast as a int64
11:53:41 <geekosaur> oy. no "cast"
11:53:45 <ania123> monochrom
11:53:52 <monochrom> Breathing is easy and trivial. What's the big deal with astronauts and divers needing so much equipment just to breathe?
11:53:53 <flippant> i'd like the caller to only have to care about the io
11:54:11 <monochrom> And don't call my name in vain.
11:54:17 <int-e> . o O ( once we know what ania123 is taking for granted we can fix it )
11:54:29 <c_wraith> monochrom: can I curse your name?
11:54:34 <monochrom> Yes!
11:54:39 <flippant> geekosaur: ok, no casting :P
11:54:40 <c_wraith> cool, thanks.
11:54:42 <geekosaur> flippant, (a) there is no "cast", this is not C (b) (Read (IO a)) does not look like a type, it looks like a constraint. you got that from somewhere, presumably an error message. please provide the source code and the full error message
11:54:53 <monochrom> "Damn monochrom, he's right again" is highly recommended!
11:55:19 <geekosaur> (c) if I were forced to guess, what you did was pass an IO a to the `read` function and it is complaining that it doesn't know what to do with it. which means you need to use (>>=) or do notation
11:55:20 * hamme 10/10 would recommend monochrom again
11:55:30 <ania123> true = λ u. λ v. u 
11:55:35 <flippant> geekosaur: http://lpaste.net/191056
11:55:38 <ania123> is it legal in lambda calculus
11:55:39 <ania123> ?
11:55:58 <monochrom> No. The "=" there is at the meta level. Not within the lambda calculus.
11:56:15 <ania123> aha
11:56:30 <ania123> since fact appers rhs, it is illegal
11:56:30 <hamme> I think the right hand side is legal
11:56:31 <ania123> no?
11:57:00 <Cale> btw, when Church encoding algebraic data structures, I find it helps to name the variables after what would be your data constructors
11:57:08 <geekosaur> flippant, and the full error message? but I already see one error: you declare maxItemID :: IO Int64, but you are not producing a value in IO at the end
11:57:09 <flippant> geekosaur: ah. that makes sense
11:57:25 <Cale> It's easier to work out what's going on if you write (λ true. λ false. true)
11:57:26 <flippant> that fixes it
11:57:28 <monochrom> Church was like "Do a macro expansion when you see 'true'". But you would rather not allow recursive macro expansions such as what fact needs.
11:57:31 <flippant> i forgot to return
11:57:42 <flippant> thanks
11:58:02 <Cale> and then if you like, you can define True as shorthand for (λ true. λ false. true)
11:58:14 <hpc> if you expand a recursive macro, the result is an infinite term
11:58:21 <ania123> in this definition: fact = λn. cond (isZero n) 1 (Mult n (fact (Pred n)))
11:58:26 <hpc> under that notion
11:58:30 <hamme> So
11:58:46 <ania123> if we drop fact from rhs, then everything is OK
11:58:46 <hamme> What's being taken for granted is the meta-notion of macros?
11:58:47 <ania123> no?
11:58:49 <Cale> ania123: So that definition doesn't work in the lambda calculus
11:59:05 <Cale> You'll need a fixed point combinator
11:59:17 <Cale> You can write  λfact. λn. cond (isZero n) 1 (Mult n (fact (Pred n)))
11:59:20 <int-e> hpc: but you can define a calculus where unfolding a "macro" is an explicit computation step.
11:59:40 <int-e> hpc: of course that won't be the pure lambda calculus.
11:59:47 <c_wraith> So..  Is there like a ghcjs-dom-dumbinternetexplorerthings package?
11:59:56 <ania123> Cale: why it is not neede here:true = λ u. λ v. u
12:00:01 <Cale> c_wraith: hah, I don't think that exists yet
12:00:19 <Cale> c_wraith: All the dumbest IE things are old enough that ghcjs doesn't work at all anyway?
12:00:32 <Cale> ania123: There's no recursion
12:00:51 <Cale> ania123: We're not referring to true on both sides of that definition
12:00:56 <c_wraith> Cale: the specific thing I'm hitting is that Firefox, Chrome, and Edge all do CORS the same way, but IE is different, and the way it does it isn't supported by ghcjs-dom
12:01:02 <ania123> clear
12:01:05 <ania123> thx
12:03:32 <Cale> ania123: In an untyped lambda calculus, it's possible to construct a term fix so that for any f, we have fix f = f (fix f)
12:04:21 <Cale> ania123: One such term is the Y combinator:  Y = λf. (λx. f (x x)) (λx. f (x x))
12:04:57 <hpc> note that it is not a recursive definition as well
12:05:02 <Cale> right
12:05:11 <Cale> and if we apply it, we can see that:
12:05:15 <Cale> Y f
12:05:22 <Cale> = (λx. f (x x)) (λx. f (x x))
12:05:44 <Cale> = f ((λx. f (x x)) (λx. f (x x)))
12:05:54 <Cale> = f (Y f)
12:06:58 <Cale> There are actually many more ways to construct such fixed-point combinators, the Y combinator is just one of the simplest
12:07:30 <Cale> and with that, we can accomplish general recursion
12:07:56 <Cale> If we apply our fixed point combinator to that function above:  λfact. λn. cond (isZero n) 1 (Mult n (fact (Pred n)))
12:09:00 <Cale> fix (λfact. λn. cond (isZero n) 1 (Mult n (fact (Pred n))))
12:09:02 <Cale> we have
12:09:06 <Zemyla> Two questions. (a) Does anything break if you compare two STRefs with different types for equality? (b) Assuming STRef is nominal (or it's in a newtype wrapper that makes it so), if x :: STRef s a and y :: STRef s b compare to equal, is it sound to assume a ~ b?
12:09:25 <hpc> Zemyla: how are you comparing them?
12:09:50 <Cale> Well, let's define  Fact = fix (λfact. λn. cond (isZero n) 1 (Mult n (fact (Pred n))))
12:10:10 <Cale> Then we have  Fact = (λfact. λn. cond (isZero n) 1 (Mult n (fact (Pred n)))) Fact
12:10:19 <Cale> and so
12:10:34 <Cale> Then we have  Fact = λn. cond (isZero n) 1 (Mult n (Fact (Pred n)))
12:11:03 <Cale> So we've accomplished what is effectively a recursive definition without actually needing recursion
12:11:37 <Cale> Perhaps there was something a bit unclear there, I should have added another step
12:11:50 <Zemyla> compSTRef :: STRef s a -> STRef s b -> Maybe (a :~: b); compSTRef = let { comp :: STRef s a -> STRef s a -> Maybe (a :~: a); comp x y = if x == y then Just Refl else Nothing } in unsafeCoerce comp -- hpc
12:11:58 <Cale> When I wrote Fact = (λfact. λn. cond (isZero n) 1 (Mult n (fact (Pred n)))) Fact, I was using the property that fix f = f (fix f)
12:12:51 <Cale> Zemyla: hmmm...
12:12:55 <hpc> Zemyla: here's the Eq instance on STRef:
12:12:56 <hpc> -- Just pointer equality on mutable references:
12:12:58 <hpc> instance Eq (STRef s a) where STRef v1# == STRef v2# = isTrue# (sameMutVar# v1# v2#)
12:13:20 <Cale> Ah, sameMutVar#
12:13:21 <hpc> Zemyla: so... most likely?
12:13:24 <Cale> Yeah, that'll be okay
12:13:28 <Cale> It's not just pointer equality
12:13:35 <Cale> If it was, then I'd worry
12:14:04 <Zemyla> Yeah, it's more... handle equality, I guess is the term?
12:14:22 <Cale> (Because then the GC might move your STRefs around in the middle of trying to compare them)
12:14:34 <hpc> "pointer" "equality" ;)
12:15:12 <Zemyla> Okay, good, so I can use STRefs as keys in a heterogenous map of some kind.
12:15:31 <hpc> you should be able to, yes
12:15:33 <hpc> also ew
12:15:54 <Cale> Zemyla: Have you seen Vault?
12:16:06 <Cale> http://hackage.haskell.org/package/vault
12:16:21 <Cale> It might be what you're trying to implement :)
12:18:26 <bollu> if I want study category theory by studying topology
12:18:29 <bollu> what's the right way to do this?
12:18:36 <bollu> I know basic topology and very little algebraic topology
12:19:10 <bollu> I'd like to do the whole sheaves -> grothendieck style stuff -> hopefully category theory? (I think that's the right order?)
12:24:20 <benzrf> nooooooooo it isn't
12:24:30 <benzrf> sheaves and grothendieck style stuff *build* on category theory
12:24:46 <benzrf> unless by "category theory" you mean the really high level stuff, as opposed to just the basic concepts
12:27:47 * hackagebot MemoTrie 0.6.5 - Trie-based memo functions  https://hackage.haskell.org/package/MemoTrie-0.6.5 (ConalElliott)
12:37:05 <SrPx> Is there a simple way to read an Int from IO? I.e., something like `readInt :: IO Int; readInt = fmap (read :: String -> Int) getLine`
12:38:37 <mkoenig> hi. is it possible to automatically derive some instances (eq, show, read etc) for all adts in the module/file without using the deriving keyword every time?
12:38:52 <glguy> mkoenig: No
12:39:04 <mkoenig> :( ok
12:41:54 <glguy> SrPx: readLn
12:41:54 <parsnip> :t readLn
12:41:56 <lambdabot> Read a => IO a
12:41:58 <begriffs> SrPx: you could do `readLn :: IO Int`
12:42:13 <glguy> Looks like a photo finish, time to consult the logs
12:42:33 <begriffs> Give it a type hint like that and it'll know to return int. But you might want something like readMay from the Safe package so you don't blow up on unparsable integers.
12:42:33 <glguy> and it's glguy by a nose! http://tunes.org/~nef/logs/haskell/16.09.11
12:43:22 <hesk> When creating a typeclass is it possible to use different type signatures for the default instances and the "specified" ones? 
12:43:22 <parsnip> glguy: not on my screen :)
12:43:37 <glguy> parsnip: Right, which is why we had to consult an independent receiver
12:43:51 <parsnip> ah
12:45:25 <parsnip> time is marked as identical though
12:45:39 <glguy> It just comes down to the order that the network processed the messages
12:49:41 <c_wraith> hesk: there is an extension that allows that.
12:50:06 <hesk> c_wraith: Which one? 
12:50:14 <c_wraith> Looking it up
12:50:49 <Cale> DefaultSignatures
12:51:25 <Cale> hesk: c_wraith: ^^
12:51:39 <hesk> Cale: Thanks! 
12:51:40 <c_wraith> ah, I knew it started with Default, but somehow that didn't help me track it down
12:52:02 <Cale> hesk: The default will then only apply when the type signature given unifies with the one required for the instance
12:52:12 <Cale> (and of course, you leave the definition out)
12:52:34 <Darwin226> Hey guys. Is it possible to have a type family associated with a typeclass instance? I want each instance to be able to define it's own type family
12:52:37 <Cale> ghc --supported-languages | grep Default
12:52:40 <c_wraith> hesk: thanks to cale providing the name.. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XDefaultSignatures is the full documentation for it
12:52:41 <Cale> would have turned it up :)
12:52:58 <hesk> c_wraith: thanks :). I'll look it up
12:53:14 <glguy> Darwin226: You can have a "associated type family" with a class and then each instance can provide an instance of that associated type family
12:53:38 <Cale> That's not what he's asking for though...
12:54:29 <Darwin226> glguy: My class has a polymorphic function with a type not mentioned in the head. The type of the function is something like myFunc :: a -> m (Result a). I want each instance to be able to define it's own Result type family
12:54:48 <Darwin226> The class is something like class MyClass m where...
12:54:57 <Cale> Darwin226: That doesn't sound like you want a whole type family...
12:55:04 <Cale> per instance
12:55:17 <Cale> You just want one type instance per instance of the class, no?
12:55:30 <Darwin226> The `a` can be anything
12:55:49 <Cale> Well, maybe it would help to know what this class is for and what the operation is
12:56:04 <glguy> Darwin226: You'll have: class C a where type Result a x
12:56:41 <n__dles> How can I check if a parameter is not a list?
12:56:58 <Cale> n__dles: That... doesn't make sense.
12:57:06 <Darwin226> glguy: Yeah, that part works but then the type definition has to work for every a independent of what a is
12:57:15 <Cale> n__dles: If its type indicates that it is a list, then it must be a list, and you don't have to check
12:57:28 <geekosaur> n__dles, you cannot conditionalize on the type
12:57:30 <Cale> n__dles: If its type indicates that it is not a list, then it is never a list
12:57:45 <Cale> In either case, you don't have to check.
12:57:57 <MarLinn> Darwin226: I agree that it's unlikely that you actually want what you think you want, but could add something like a parameter of kind (* -> Constraint)
12:58:08 <MarLinn> +you
12:58:09 <glguy> Darwin226: you can have more than one type instance in the typeclass instance
12:58:22 <Darwin226> glguy: How?
12:58:36 <Fairy> Could anyone explain this Haskell code?  [ x | x <- a, _ <- a ]   I'm having a hard time understanding what it does :S
12:58:53 <SrPx> Is there any short way to express `do { x <- readLn :: IO Int; y <- readLn :: IO Int; return (x,y) }`?
12:58:57 <glguy> Darwin226: add two lines
12:59:06 <Cale> Fairy: It picks an x from the list a, and then it also picks an element of a which it doesn't give a name to
12:59:17 <Darwin226> glguy: Hmm, yeah, it's letting me do this but then it complains when i put in a catch-all at the end
12:59:20 <Cale> Fairy: and for each pair of selections, it produces the element x in the resulting list
12:59:32 <glguy> Darwin226: you probably don't get to have a catch all
12:59:38 <david-md> Fairy: it squares the list
12:59:41 <glguy> You'd need closed type families for that
12:59:45 <Cale> Fairy: It might help to first look at the result of  [ (x,y) | x <- [1,2,3], y <- [1,2,3]
12:59:47 <Cale> oops
12:59:47 <glguy> and associated type families aren't closed
12:59:53 <Cale> > [(x,y) | x <- [1,2,3], y <- [1,2,3]]
12:59:55 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:00:01 <Cale> (I missed a bracket there)
13:00:16 <Cale> > [x | x <- [1,2,3], y <- [1,2,3]]
13:00:18 <glguy> Darwin226: You could have the associated type be another assocated *data*type
13:00:18 <lambdabot>  [1,1,1,2,2,2,3,3,3]
13:00:19 <amalloy> SrPx: you could write: (,) <$> readLn <*> readLn :: IO (Int, Int)
13:00:30 <Cale> > [y | x <- [1,2,3], y <- [1,2,3]]
13:00:31 <lyxia> SrPx: liftA2 (,) readLn readLn
13:00:33 <lambdabot>  [1,2,3,1,2,3,1,2,3]
13:00:47 <amalloy> (which is the same as the liftA2 approach)
13:00:59 <SrPx> yep, liftA2 looks better
13:01:44 <lpaste> glguy pasted “for darwin226” at http://lpaste.net/191135
13:01:55 <SrPx> finally, any short way to sort a tuple? :) or to return a list instead of a tuple on that case... without lambda (liftA2 (\ a b -> [a,b]))
13:02:28 <Fairy> Cale: ohh, that makes sense, thanks! ;)
13:02:35 <SrPx> we don't have a generic sort, right?
13:02:38 <hesk> Does anyone know of a good writeup of typeclasses? Learnyouahaskell isn't thorough enough.
13:03:11 <Cale> SrPx: Tuple types are all completely distinct and unrelated to one another apart from the similar-looking syntax
13:03:22 <Cale> SrPx: It doesn't really make sense to sort them, usually.
13:03:26 <SrPx> I meant a pair, not any tuple
13:03:39 <glguy> Darwin226: If you wanted the "fallthrough" behavior you could get close using a GADT as the associated type
13:03:48 <SrPx> just `\ (x,y) -> (min x y, max x y)`
13:04:38 <lyxia> SrPx: I don't think there is a standard function for that.
13:05:04 <amalloy> uncurry min &&& uncurry max would do it, with Control.Arrow.&&&
13:05:12 <amalloy> i think
13:05:33 <Cale> Yes, though that's both less clear and longer than the lambda :)
13:05:47 <geekosaur> :t (::[])
13:05:49 <lambdabot> error: parse error on input ‘::’
13:06:00 <geekosaur> whoops, right, can't do that :/
13:06:11 <jonored> SrPx: It's relatively unusual to have a pair where the types are both the same /and/ the values are interchangeable (and not "x and then y" or something like that).
13:06:18 <lpaste> glguy annotated “for darwin226” with “for darwin226 (annotation)” at http://lpaste.net/191135#a191142
13:06:23 <glguy> Darwin226: OK, I think this is what you wanted
13:07:33 <Cale> SrPx: Though one of the miscellaneous tiny libraries we have at my work is a SortedPair type which behaves like Set constrained to 1 or 2 elements.
13:08:02 <biscarch> Does anyone know if hasql supports postgres' large objects?
13:08:14 <Darwin226> glguy: Yeah, that's exactly it. So I just need to define another type family out side of the instance.
13:08:53 <SrPx> fair enough, I think I'll just `liftA2 (\ a b -> [a,b]) readLn readLn`. I was just trying to avoid lambdas to make it look prettier
13:09:50 <amalloy> traverse [readLn, readLn]?
13:10:06 <glguy> sequence
13:10:30 <amalloy> :t traverse
13:10:32 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:10:42 <MarLinn> replicateM 2 ;p
13:10:48 <amalloy> oh. still trying to get the hang of traverse
13:11:24 <amalloy> right, traverse is mapM
13:11:27 <SrPx> ha, good one
13:11:28 <Darwin226> Btw the usecase is a bit difficult to explain but essentially I want the same functions to be able to be used inside of some monad (and their effect immediately executed) or to build an AST
13:11:51 <Darwin226> but some return values don't make sense outside of an AST so I need the result to be piped through a type family
13:12:07 <Darwin226> and I need it to differ based on the instance
13:14:56 <hamme> Mamono Sweeper is great
13:15:25 <david-md> I tend to use (@SomeType id) a lot in my code in the place of proxies in GHC 8. I don't this idiom much in other peoples code, am I using this construct wrong?
13:15:49 <david-md> * (id @SomeType)
13:18:08 <lyxia> I would rather use :: SomeType
13:19:40 <david-md> @lyxia ah, is that in GHC, what's it called?
13:19:40 <lambdabot> Unknown command, try @list
13:20:06 <lyxia> david-md: Uh, type annotations?
13:20:29 <nshepperd> heh, that's cute
13:21:06 <david-md> oh sorry I thought you were talking about (:: String) which is equivalent to (id :: String -> String) in some dialects of haskell
13:21:20 <nshepperd> the type of (id @SomeType) unifies with (proxy SomeType), so you can use it as an actual proxy, in the polymorphic interface
13:21:33 <nshepperd> but you can also apply it to constrain things types
13:21:53 <geekosaur> david-md, that's actually slated for a later 8.x version 
13:22:04 <geekosaur> (it was in the list for 8.0.1 but wasn't ready)
13:22:20 <lyxia> Ah I misunderstood what you meant.
13:22:47 <lyxia> I like ([] :: [SomeType]) as my proxy.
13:23:11 <lyxia> I've never seen it used by other people though.
13:23:12 <david-md> geekosaur: it's a great feature, I find it much easier to think about than @Types which tend to wrinkle my brain a little
13:24:05 <nshepperd> (:: SomeType) would be nice also since the :: has lower precedence than everything
13:24:34 <nshepperd> so you don't have to wrap the SomeType in more parentheses
13:25:08 <david-md> and it's kind of intuitively makes sense to me, an empty string is identical to id, so you're just saying the type of nothing
13:26:26 <SrPx> ok, so, my friend is doing some beginner programmer excercises and I'll be sending haskell answers for the same problems he completes so he can get used to it from the beginning - this is the code I'll send him for the first one http://lpaste.net/191150
13:27:48 * hackagebot hoogle 5.0.4 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.4 (NeilMitchell)
13:27:50 * hackagebot telegram-api 0.5.0.1 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.5.0.1 (klappvisor)
13:28:09 <lyxia> SrPx: I'd move "from the console" up one line.
13:28:10 <SrPx> I'll let him know how he can change Int by Integer, Double or whatever he wants and the code is compiled properly... also how GHC seemingly manages to compile that to the O(1) algebraic formula (wtf???)
13:28:32 <Welkin> is there a way to install ghcjs through stack?
13:28:33 <SrPx> lyxia: ah I wanted to make a point on the IO
13:29:08 <SrPx> could as well use replicateM 2 readLn, right
13:29:54 <lyxia> Hm. That could work as a comment about the IO right.
13:30:18 <geekosaur> Welkin, https://docs.haskellstack.org/en/stable/ghcjs/ says yes
13:30:44 <geekosaur> configure stack.yaml for ghcjs and `stack setup` will install it, provided your stack is recent enough
13:30:56 <Welkin> okay
13:32:12 <SrPx> "let [min, max] be the first values; of the sorted list; of two lines read from the console; and interpreted as ints"
13:32:14 <SrPx> better, right? :)
13:32:30 <amalloy> if you're writing it for a beginner, i think just using do notation to execute readLn twice is more readable
13:38:56 <SrPx> amalloy: hmm maybe
13:39:54 <Welkin> and to play the waiting game
13:39:59 <Welkin> while ghcjs compiles
13:43:03 <Welkin> oh boy
13:43:20 <Welkin> my computer sounds like it is getting ready to fly down the runway
13:43:37 <Welkin> stack compiles on all available cores by default, right?
13:43:55 <SrPx> the waiting game?
13:44:01 <Welkin> yeah
13:44:06 <Welkin> waiting for ghcjs to compile
13:44:21 <geekosaur> stack attempts to, ghc itself is not so good at all cores
13:44:28 <grantwu> I believe so.  My partner in the compilers class I'm taking and I refer to fans spinning as the "haskell alarm"
13:44:43 <SrPx> I don't have a waiting game to play I fear
13:47:46 <geekosaur> now you know why there's so much overlap between #haskell and ##crawl >.>
13:49:08 <Welkin> geekosaur: do I also need to use the same lts version that I used to compile ghcjs?
13:49:10 * MarLinn adds "Haskell-based IRC game bot?" to his "reviewables" list
13:49:15 <Welkin> or can I use a newer one?
13:49:33 <geekosaur> I think you can use a newer one as long as that newer one is using the same ghcjs
13:49:43 <geekosaur> since compiler version is part of the resolver
13:50:07 <geekosaur> (otherwise, it shouldn't break, just it'll start out by installing the different version)
13:50:14 <Welkin> and ghcjs is only for up to 7.10.3 right now, right
13:50:15 <Welkin> ?
13:50:22 <geekosaur> I believe so
13:50:30 <Welkin> I haven't even installed ghc 8 yet anywhere
14:09:50 <hesk> Could someone look at this http://lpaste.net/191190? I'm trying to patternmatch in a class but it's not working. 
14:10:04 <hesk> erm http://lpaste.net/191190 
14:10:28 <amalloy> you cannot treat constructors as wildcards
14:10:40 <Cale> hesk: You can't pattern match against arbitrary functions
14:11:02 <hesk> :/ Would've been nice to do
14:11:23 <amalloy> i think you are confused about what a typeclass does anyway
14:11:30 <hesk> So I have to type out each instance of constructors? 
14:11:31 <Cale> also, you can't pattern match a variable whose type you know nothing about with anything more complicated than a simple variable pattern or wildcard
14:11:45 <Cale> Why this class?
14:12:02 <Cale> I think you just want to be writing a function of type  Bar -> Bar -> Int
14:12:23 <Cale> ?
14:12:24 <hesk> Well I'm trying to define a function which takes two data types 
14:12:34 <Cale> Bar and what else?
14:12:59 <hesk> Some  other "data Biz = Biz String String String " 
14:13:56 <Cale> Okay, fair enough
14:14:00 <Cale> So, you can write something like
14:14:03 <Cale> class Foo a where
14:14:07 <Cale>   f :: a -> a -> Int
14:14:13 <Cale> instance Foo Bar where
14:14:29 <Cale>   f (Baz _ _) (Baz _ _) = ...
14:14:33 <Welkin> let jargon = Biz "Enterprise" "Cloud" "WebScale"
14:14:34 <Cale>   f (Baz _ _) (Taz _ _) = ...
14:14:38 <Cale> etc.
14:14:41 <Cale> and then
14:14:46 <Cale> instance Foo Biz where
14:14:54 <Cale>   f (Biz x y z) = ...
14:15:19 <Welkin> is Bar short for Barmitzvah?
14:15:29 <amalloy> also, if you have two constructors which are identical except for the constructor name and you want to treat them similarly, you may want to factor that into a single constructor with an extra "tag" argument
14:15:35 <hesk> Cale: True. But the thing is that I want to mix the data types under a function. 
14:15:49 <Cale> hm?
14:15:52 <hesk>     f (Baz _ _) (Biz _ _ _) = ...
14:15:56 <Cale> nope
14:15:58 <amalloy> data BarTag = Baz | Tiz; data Bar = Bar BarTag String String
14:16:01 <fnurglewitz> Welkin: nah, I suppose it's just half a foobar :)
14:16:01 <Welkin> hesk: use a sum type
14:16:40 <Welkin> or you could use functional dependencies
14:16:40 <Cale> hesk: That doesn't completely make sense. What are you *actually* trying to do? It might help if the data types had more realistic names.
14:16:43 <Welkin> or type families for that
14:16:45 <Welkin> right
14:16:45 <Welkin> ?
14:17:09 <Cale> Welkin: It's currently so unclear what hesk is trying to represent that it's not worth suggesting anything fancy
14:17:27 <Welkin> okay
14:17:46 <Welkin> Cale: I'm installing ghcjs again to try reflex-dom
14:17:51 <hesk> Im trying to measure difference between a list and a list of lists with different interal structures 
14:18:06 <hesk> internal* 
14:18:14 <Cale> Welkin: btw, if you want to save yourself hours of compiling, I very much recommend using reflex-platform
14:18:26 <Welkin> Cale: haha, too late, already halfway through
14:19:07 <hesk> Welkin: havent heard of sum types. I'll look them up, thanks
14:19:35 <Welkin> hesk: it is just a union type
14:19:51 <Welkin> data Direction = North | South | West | East
14:19:53 <fnurglewitz> data SumType = A | B | C 
14:21:58 <hesk> Welkin: I don't know what a union type is. The data I have is currently data type who I want to unite under a class in order to apply a function to both data types. 
14:22:41 <Welkin> hesk: ys, you don't need that
14:22:49 <Cale> hesk: with the class you gave, you're not allowed to mix and match which type 'a' is though
14:22:51 <Welkin> haskell has Algebraic data types
14:23:04 <Cale> But I don't think you actually want different types
14:23:05 <Welkin> you can nest your types however you wish
14:23:13 <Cale> You want one type, with more constructors
14:23:30 <Cale> because you appear to want to use values of these "different types" interchangeably
14:23:52 <fnurglewitz> I don't know if the comparison is allowed (or precise) but the concept is similar to C unions
14:24:01 <hesk> Cale: No i'd prefer if they were the same, but it's specified that they have to differ. 
14:25:09 <fnurglewitz> using Welkin example, if you have: foo :: Direction -> String
14:25:15 <fnurglewitz> you can only apply 1 direction
14:25:23 <Welkin> data Viking = Berserker Int String | Archer String String Int
14:25:25 <Welkin> for example
14:25:32 <fnurglewitz> North OR South OR West OR East
14:26:19 <fizbin> Things I should not do right before I have to run out the door: attempt to add {-# LANGUAGE TypeFamilies #-} to a previously compiling program.
14:26:20 <Welkin> a constructor can have zero or more fields
14:26:37 <Cale> hesk: What are you actually doing though?
14:26:41 <fizbin> Now it's got all these errors about a (rigid, skolem) variable.
14:26:43 <Welkin> in the case of `Direction`, none of them have any fields
14:26:49 <Cale> hesk: What does the program you're trying to write do?
14:27:22 <Cale> hesk: It's very hard to give advice about types without having the big picture of what the program is
14:27:50 * hackagebot servant-github-webhook 0.2.0.0 - Servant combinators to facilitate writing GitHub webhooks.  https://hackage.haskell.org/package/servant-github-webhook-0.2.0.0 (tsani)
14:27:53 * hackagebot llvm-tf 3.1.0.1 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.1.0.1 (HenningThielemann)
14:28:02 <fizbin> Is there a handy reference page someone can point me at for why adding {-# LANGUAGE TypeFamilies irc://chat.freenode.net:6697/#-} introduced a bunch of type variables like "Couldn't match type ‘gr0’ with ‘gr’ because type variable ‘gr’ would escape its scope. This (rigid, skolem) type variable is bound by ..." ?
14:28:51 <fizbin> (Since I need to step out now, but if it's a common enough question that there's already a good writeup I can't find because I'm searching for the wrong stuff, I'll load that up and read it later)
14:29:54 <Cale> fizbin: What the...
14:30:12 <hesk> Cale: I have two different datatypes Data1 and Data2 which have multiple value, one of which is an integer. Also Data1 can become Data2 with a transform, what I want is to define a typeclass to perform this transform and then compare the data. 
14:30:35 <fizbin> Stupid IRC client added a URL in front of #- 
14:30:41 <Cale> fizbin: I can't really say why that might be happening without seeing the code...
14:30:54 <Cale> hesk: Still too abstract
14:31:07 <Welkin> hesk: show your code in a paste
14:31:09 <fizbin> Ugh, okay. I guess I will try to simplify when I get back.
14:31:10 <fnurglewitz> why do you need a typeclass?
14:31:12 <Welkin> @where lpaste
14:31:12 <lambdabot> http://lpaste.net/
14:31:25 <Cale> hesk: What does the real program actually do? What does your *actual* code look like?
14:31:30 <fnurglewitz> transform :: Data1 -> Data2 isn't enough?
14:31:42 <Cale> Data1 and Data2 don't help me figure out what the heck is going on
14:31:59 <Cale> But yeah, it sounds more like you need a function than a type class
14:32:26 <fnurglewitz> if you want a typeclass I see it like you need a Data3
14:32:36 <fnurglewitz> typeclass "TransformableIntoData3"
14:32:53 <fizbin> Cale: unfortunately, the code is huge and proprietary. The error looks vaguely like what's shown on http://stackoverflow.com/questions/12719435/what-are-skolems but what I'm particularly irritated by is that adding LANGUAGE TypeFamilies - and nothing else, so not actually adding type families - seems to trigger this error.
14:33:17 <fizbin> But as I said, I'll try to simplify down to a test case I can share when I get back.
14:33:48 <Cale> fizbin: Anyway, I can explain the terms...
14:34:05 <fnurglewitz> btw I feel really stupid but I'm having problems understanding what's happening on the Reader monad instance
14:34:06 <fnurglewitz> (Reader ra) >>= aRb = Reader $ \r -> runReader (aRb (ra r)) $ r
14:34:15 <fnurglewitz> why is r applied again?
14:34:15 <hesk> Well it's alot of code... Maybe I've read the specification wrong. Too tired.. Thanks for your help though. Hopefully it'll be clear in the morning 
14:34:43 <Cale> A rigid type variable is one which is bound by a quantifier from the outside, so it's not allowed to be unified with some particular type like Integer, for example
14:35:10 <Cale> In this case, the type variable b is rigid because it occurs *as a type variable* in your signature
14:35:10 <dmwit> fnurglewitz: Because both `ra` and the return value of `aRb` are monadic, hence require the value being read as arguments.
14:35:11 <geekosaur> fnurglewitz, because a value of type Reader r a is a function from r to a
14:35:55 <fnurglewitz> but
14:35:57 <fnurglewitz> ra :: r -> a
14:36:02 <Cale> For that matter, it won't unify with any other variable apart from itself
14:36:05 <ski> fnurglewitz : both arguments to `(>>=)' will depend on the environment
14:36:06 <fnurglewitz> aRb :: a -> Reader r b
14:36:25 <dmwit> fnurglewitz: Right. Hence (up to newtyping), `aRb :: a -> r -> b`.
14:36:33 <ski>   ra r :: a
14:36:40 <ski>   aRb (ra r) :: Reader r b
14:36:48 <ski>   runReader (aRb (ra r)) :: r -> b
14:36:55 <ski>   runReader (aRb (ra r)) r :: b
14:37:02 <ski>   \r -> runReader (aRb (ra r)) r :: r -> b
14:37:13 <ski>   Reader (\r -> runReader (aRb (ra r)) r) :: Reader r b
14:37:28 <ski> (omitting the redundant `$'s)
14:38:09 <Cale> hesk: Feel free to link us to a github repo or paste a bunch of code on lpaste.net
14:38:28 <fnurglewitz> ski, I see this lambda as r->b : \r -> runReader (aRb (ra r))
14:38:31 <fnurglewitz> that's my problem
14:38:31 <Welkin> or mail it tp our P.O. Box
14:38:40 <Cale> hesk: I'm usually much happier having way too much code to look at than too little to give reasonable advice
14:38:48 <ski> fnurglewitz : no, it's `\r -> runReader (aRb (ra r)) r'
14:39:15 <ski> fnurglewitz : or, `\r -> (runReader (aRb (ra r)) $ r)' (extra redundant brackets added, for emphasis)
14:39:50 <dmwit> fnurglewitz: `\r -> runReader (aRb (ra r))` has type `r -> r -> b`. The first value of type `r` is bound to `r`; then it returns the function you get from `runReader`, which needs another `r`.
14:40:01 <ski> fnurglewitz : `\r -> runReader (aRb (ra r))' would have .. what dmwit said
14:40:03 <dmwit> :t runReader
14:40:05 <lambdabot> Reader r a -> r -> a
14:40:45 <dmwit> :t let aRb :: a -> Reader b; aRb = undefined; ra :: r -> a; ra = undefined in \r -> runReader (aRb (ra r))
14:40:46 <ski> fnurglewitz : you have to feed `r' to both arguments of `(>>=)'
14:40:47 <lambdabot> error:
14:40:47 <lambdabot>     • Expecting one more argument to ‘Reader b’
14:40:47 <lambdabot>       Expected a type, but ‘Reader b’ has kind ‘* -> *’
14:40:55 <dmwit> :t let aRb :: a -> Reader r b; aRb = undefined; ra :: r -> a; ra = undefined in \r -> runReader (aRb (ra r))
14:40:56 <lambdabot> r1 -> r -> a
14:41:01 <ski> fnurglewitz : iow, *use* `r' twice
14:41:09 <fnurglewitz> iow?
14:41:13 <fnurglewitz> in other words? :O
14:41:14 <ski> "in other words"
14:41:16 <fnurglewitz> ok
14:41:21 <hesk> Cale: Actually your advice helped a lot. I think I was just overanalyzing the specs. Not sure if i'll paste since this is for uni.
14:42:31 <ski> fnurglewitz : in `ra r', you're passing `r' to the left argument, that will produce an `a' which will fit into the right argument, as `aRb (ra r)'
14:42:42 <fnurglewitz> ski, yes
14:42:48 <fnurglewitz> aRb (ra r)
14:42:50 <fnurglewitz> is a Reader r b
14:43:18 <ski> fnurglewitz : then you have to also pass `r' into that, either by matching the result of `aRb (ra r)' with a pattern like `Reader rb', continuing with `rb r'
14:43:30 <ski> fnurglewitz : .. or, just use `runReader' as you did it
14:43:39 <ski> fnurglewitz : with pattern-matching, it'd be e.g.
14:44:01 <ski>   Reader (\r -> let Reader rb = aRb (ra r) in rb r) :: Reader r b
14:44:13 <ski> (`case' would also work)
14:44:34 <fnurglewitz> I just can't see why I'm applying r two times
14:44:47 <ski> because you've got two `Reader' things as input
14:44:51 <ski> one `Reader r a'
14:45:03 <ski> and one `Reader r b', as soon as you get an `a' from the previous one
14:45:11 <ski> each of these will require an `r' as input
14:45:26 <fnurglewitz> hah
14:45:30 <fnurglewitz> one is Reader r a
14:45:38 <fnurglewitz> the other is Reader r (a -> b)
14:45:42 <fnurglewitz> hence the second r
14:45:46 <ski> no, the other is `a -> Reader r b'
14:45:58 <ski> if you feed it the `a' from the former one, then you get your `Reader r b'
14:46:14 <ski> (`Reader r (a -> b)' would be `Applicative', not `Monad')
14:46:18 <fnurglewitz> yep, sorry
14:46:25 <fnurglewitz> was just thinking about that
14:46:44 <ski> think of `(>>=)' as building a node in your tree
14:46:52 <ski> you want to pass `r' down both branches of your tree
14:47:01 <ski> distribute the environment
14:47:46 <fnurglewitz> hm
14:47:53 <ski> unless you do something special in a "tree node", you'll just copy and distribute the same "config" down every branch of the tree
14:48:07 <ski> ("do something special" is e.g. using `local')
14:48:21 <ski> fnurglewitz : makes any sense ?
14:48:22 <fnurglewitz> the second r is the r->b 
14:48:29 <fnurglewitz> "the r in r->b"
14:48:37 <ski> that's where you pass the second `r', yes
14:48:47 <fnurglewitz> after applying a value to the lambda i get a b
14:48:50 <ski> (or the second copy)
14:48:57 <fnurglewitz> but "un-applied" it's still an r->b
14:49:02 <ski> yes (s/lambda/function/)
14:49:13 <ski> what is "un-applied" ?
14:49:19 <fnurglewitz> the lambda itself
14:49:24 <ski> oh, before you provide the `r'
14:49:24 <ski> yes
14:49:26 <fnurglewitz> *function
14:49:26 <fnurglewitz> yes
14:50:10 <fnurglewitz> I'm defining an r->b function
14:50:26 <fnurglewitz> but since i'm composing multiple functions i have to declare who's using r and where
14:50:28 <ski> what is complicating the "tree" view of this somewhat is that the second branch in `(>>=)' node will also depend on the "result value" (your `a') of the first node
14:51:00 <fnurglewitz> if i was to remove the second r it would be like declaring id as this: let id = \r -> 
14:51:18 <fnurglewitz> which is obviously a syntax error
14:51:21 <ski> well .. that's a syntax error
14:51:33 <fnurglewitz> yep, so it is \r -> runReader (aRb (ra r))
14:51:35 <ski> but your wrongful attempt above was just a type error
14:51:59 <fnurglewitz> yes
14:52:10 <ski> (i.e. doesn't yield something of the type you wanted to get)
14:52:55 <ski> fnurglewitz : did the version using `let' help you better understand `(>>=)' for `Reader r' ?
14:53:27 * ski would like it, if one could define `(>>=)' here like
14:53:31 <fnurglewitz> actually thinking about the types helped
14:53:38 <ski>   runReader (ma >>= amb) r = b
14:53:40 <ski>     where
14:53:59 <ski>     a = runReader   ma    r
14:54:00 <ski>     b = runReader (amb a) r
14:54:22 * ski nods to thinking about the types
14:54:46 <fnurglewitz> but
14:54:54 <fnurglewitz> without using the second r in the lambda
14:54:59 <ski> yes ?
14:55:12 <fnurglewitz> I cannot be sure that ra and the last r->b use the same value
14:55:13 <fnurglewitz> for r
14:55:14 <fnurglewitz> right?
14:55:36 <ski> you can be sure that the last `r -> b' doesn't get fed a `r' at all .. in this piece of code
14:55:50 <fnurglewitz> \r -> runReader (aRb (ra r)) r
14:55:53 <ski> it stays "un-applied"
14:56:09 <fnurglewitz> this way I'm 100% sure that the 2 r are the same value
14:56:16 <fnurglewitz> \r -> runReader (aRb (ra r))
14:56:19 <fnurglewitz> this way I'm not
14:56:28 <fnurglewitz> or am I wrong?
14:56:33 <ski> well
14:56:34 <ski> your
14:56:36 <ski>   \r -> runReader (aRb (ra r))
14:56:40 <ski> is the same as writing
14:56:46 <ski>   \r0 r1 -> runReader (aRb (ra r0)) r1
14:56:51 <ski> (by eta expansion)
14:57:11 <ski> iow, you're here taking *two* `r's, and passing one in one place, and another in another place
14:57:31 <fnurglewitz> so the Reader monad is actually the Applicative "inverted"?
14:57:35 <fnurglewitz> f (g x) x
14:57:39 <fnurglewitz> instead of f x (g x)
14:57:43 <ski> whoever will eventually supply these two `r's could make sure to always supply the same `r' value for both
14:58:04 <ski> fnurglewitz : yea .. it's a bit funny that it looks almost the same, except argument ordering
14:58:49 <ski> (you could view that as a queer accident)
14:59:07 <fnurglewitz> lol
14:59:23 <fnurglewitz> btw probably the id example was bad because of the syntax error
14:59:30 <ski> yes, 'twas
14:59:32 <fnurglewitz> let f = \r -> (+r) 
14:59:37 <fnurglewitz> let f' = \r -> (r+r)
14:59:58 <ski>   f :: Num r => r -> r -> r
15:00:01 <fnurglewitz> yep
15:00:02 <ski>   f' :: Num r => r -> r
15:00:43 <fnurglewitz> i need to get used to this =)
15:00:51 <fnurglewitz> (not for this simple example :P)
15:01:12 <ski> yeah .. getting used to inferring types in head is good practice
15:01:34 <fnurglewitz> I wasn't seeing that the whole lambda (function) needed to evaluate to b
15:01:38 <fnurglewitz> and not to r->b
15:02:04 <ski> it's because you had `Reader $ \r -> ...', and then here `...' should have type `b'
15:02:23 <ski> for `\r -> ...' to have type `r -> b', and `Reader $ \r -> ...' have type `Reader r b'
15:02:23 <fnurglewitz> yes
15:02:39 <fnurglewitz> i wasn't seeing that
15:02:45 * ski nods
15:03:26 <fnurglewitz> I'm not trained to think about types
15:03:30 <ski> with practice, it gets easier and faster
15:03:35 <fnurglewitz> but I'm trying to change that
15:03:40 <ski> just keep trying
15:03:55 <fnurglewitz> heh, it's all about time =)
15:04:07 <fnurglewitz> I suppose 
15:04:15 <fnurglewitz> (where time = practice)
15:04:21 * ski nods
15:05:01 <fnurglewitz> I just dusted my old whiteboard to write down expressions
15:05:10 <fnurglewitz> and write over the types
15:05:18 <ski> we'll have you read inference rules notation for type systems before breakfast soon, i'm sure ;)
15:05:21 <fnurglewitz> It's better than the monitor
15:05:30 <fnurglewitz> lol
15:05:56 * ski heard someone used the window to do quick calculations like that
15:06:37 <fnurglewitz> lol
15:06:42 <fnurglewitz> my wife would kill me
15:06:48 <fnurglewitz> if I wrote on the window =P
15:07:06 <ski> .. as long as it's erasable ?
15:07:18 <glguy> That seems like an extreme response!
15:07:35 <fnurglewitz> :D
15:08:26 <fnurglewitz> another question :)
15:08:28 <fnurglewitz> about return
15:08:37 <fnurglewitz> return a = Reader $ \r -> a
15:09:27 <fnurglewitz> I'm not sure how this "works" :)
15:09:34 <ski> in this case, we're so to speak at a leaf of the tree, and the environment/config `r' is then just dropped on the floor
15:09:59 <fnurglewitz> \_ -> a
15:10:29 <ski> so, if you don't do anything "special", your initial `r' value that you feed into your tree at the top/root, will get distributed (by copying) down every branch, and then get dropped/ignored in all the leaves
15:10:39 <ski> yes, that would also be fine here
15:11:07 <ski> if you actually want to inspect the distributed environment at some point, you need to use `ask'
15:11:16 <ski> (or `asks', which is a variant)
15:12:15 <ski> (and, if you want to change which `r' gets distributed down a particular subtree, then you use `local' at that point. other "parallel" subtrees are unaffected (unlike with `State s'))
15:13:07 <fnurglewitz> :t return (+1) :: Reader String (Int -> Int)
15:13:09 <lambdabot> Reader String (Int -> Int)
15:13:15 <ski> (`local' takes a function of type `r -> r', to modify the environment that gets passed to the "`local' node", before passing it on to the subtree described by its other argument, of type `Reader r a')
15:13:43 <fnurglewitz> so with return the first type is completely irrelevant
15:13:54 <ski> @type local (+1) (return False) :: Reader Integer Bool
15:13:56 <lambdabot> Reader Integer Bool
15:14:20 <fnurglewitz> :t local
15:14:22 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
15:14:29 <ski> fnurglewitz : yes .. which is required since `return x' should be an action which has no (`Reader r') "effects"
15:14:44 <fnurglewitz> yep, never touch the structure
15:15:02 <ski> in this case, an "effect" would be interacting with the `r' environment, like reading it, or modifying it (for a subtree)
15:15:42 <ski> consider e.g. `return a >>= amb'
15:15:55 <ski> this will first copy the to-be-input `r'
15:16:05 <ski> then the `return a' part will discard one of the copies
15:16:28 <ski> the other copy is passed on to `amb' (after passing the `a' result "horizontally", to the right)
15:16:48 <ski> so, instead of copying, and then discarding one copy, we could just omit those two parts altogether
15:17:08 <ski> iow `amb a' (pass `a' directly to the (formerly) right sub-tree)
15:17:25 <ski> this is one of the monadic laws : `return a >>= amb  =  amb a'
15:17:42 <Welkin> does anyone know about ghcjs?
15:17:55 <dmwit> ?where justask
15:17:55 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
15:18:05 <Welkin> I followed the install instructions exactly and am getting this error http://lpaste.net/1701484610371715072
15:18:23 <Welkin> installed with stack
15:18:27 <Welkin> https://docs.haskellstack.org/en/stable/ghcjs/
15:18:32 <ski> fnurglewitz : did you see the monadic laws, yet ?
15:19:45 <geekosaur> um. that looks to me like a "shouldn't happen"
15:19:56 <geekosaur> make sure you have the latest stack?
15:19:58 <fnurglewitz> ski, I'm thinking about it
15:20:07 <fnurglewitz> ski, on ghci :P
15:20:07 <Welkin> geekosaur: I do
15:20:12 <david-md> is there a good guide to type level programming floating around?
15:20:14 <Welkin> I just did `stack upgrade` too
15:21:43 <ski> fnurglewitz : would you like to see a more fleshed-out derivation of the above law, for `Reader r' ?
15:22:22 <fnurglewitz> ski, what do you mean with "fleshed-out"?
15:22:57 <ski> fnurglewitz : showing each step of the proof
15:23:04 <fnurglewitz> do you have a link?
15:24:18 <ski> fnurglewitz : i was more typing this up on the fly
15:24:22 <ski> here :
15:24:26 <ski>      return a >>= amb
15:24:30 <ski>   =  Reader (\r -> a) >> amb
15:24:36 <ski>   =  Reader (\r -> let Reader rb = aRb ((\r -> a) r) in rb r)
15:25:00 <ski>   =  Reader (\r -> let Reader rb = aRb a in rb r)
15:25:11 <ski>   =  Reader (let Reader rb = aRb a in rb)
15:25:18 <ski>   =  let Reader rb = aRb a in Reader rb
15:25:20 <ski>   =  aRb a
15:25:38 <ski> in the first step, we expand the definition of `return' for the `Reader r' monad
15:25:50 <ski> (sorry, it should be `>>=' there, not `>>')
15:26:01 <Welkin> well, what should I do
15:26:09 <Welkin> I just spent over an hour waiting for ghcjs to compile
15:26:15 <fnurglewitz> ski, no problem, i understood that :)
15:26:20 <ski> then, in the next step, we use the following definition of `(>>=)' that i suggested above :
15:26:44 <c_wraith> Make some elements appear on a page
15:26:51 <c_wraith> Welkin: ^^
15:26:58 <Welkin> c_wraith: it doesn't work
15:27:02 <Welkin> I can't even compile anything
15:27:04 <ski>   Reader ra >>= amb  =  Reader (\r -> let Reader rb = amb (ra r) in rb r)
15:27:07 <Welkin> http://lpaste.net/1701484610371715072
15:27:09 <fnurglewitz> ok
15:27:10 <c_wraith> Welkin: did you run ghcjs-boot?
15:27:18 <ski> in this case with `\r -> a' replacing `ra'
15:27:19 <Welkin> I installed with `stack setup`
15:27:26 <c_wraith> Oh, then I have no idea
15:27:46 <ski> next, i just simplify (beta-reduction) `(\r -> a) r' to `a'
15:27:52 * hackagebot rosmsg 0.5.0.0 - ROS message parser, render, TH  https://hackage.haskell.org/package/rosmsg-0.5.0.0 (akru)
15:27:57 <hoppfull> I need advice. Is it hard to implement a pseudo random function with signature: (Int -> Int) that basically just takes a number and returns a seemingly random number (though still deterministic) with good periodicity and uniformity?
15:28:20 <Welkin> hoppfull: http://hackage.haskell.org/package/random
15:28:30 <ski> next, i eta-reduce `\r -> ... r' to just `...' (where `...' doesn't mention `r'. in this case `...' was `let Reader rb = aRb a in rb')
15:28:34 <c_wraith> hoppfull: With that exact type, it's very difficult
15:28:54 <fnurglewitz> so when I lift a function into the Reader monad I'm giving it an additional paramter which is ignored by the returned function but not from the next ones? 
15:28:56 <ski> next, i "float" the `let'-binding outside of the `Reader' constructor
15:29:29 <ski> finally, if `Reader r b' is equal to `aRb a', and we're returning `Reader rb', then we're returning `aRb a' (since they're equal)
15:29:37 <ski> so we get just `aRb a' at the end
15:29:38 <hoppfull> c_wraith: The more I look into it I get that impression. I saw a tutorial way back on shifting bits around, some multiplication here, some modulus here.
15:29:49 <hoppfull> But I can't find it.
15:30:08 <ski> (sorry, apparently i happened to use my name `amb' at the start, and your name `aRb' at the end. they were meant to be the same thing)
15:30:12 <c_wraith> hoppfull: Well, the "problem" is that Haskell functions are pure.
15:30:24 <ski> fnurglewitz : that should hopefully explain the steps of the proof
15:30:27 <hoppfull> c_wraith: That's not a problem.
15:30:27 <fnurglewitz> ski, no problem, noticed that 
15:30:46 <fnurglewitz> ski, i'm copying everything on a file
15:31:05 <hoppfull> c_wraith: I expect it to produce same value every time with same input.
15:31:09 <ski> fnurglewitz : btw, on close look, i did omit one step
15:31:10 <c_wraith> hoppfull: (Int -> Int) is just a poor choice.  It implies that the entire state of your PRNG must be captured by its output.
15:31:22 <ski> fnurglewitz : `let Reader rb = aRb ((\r -> a) r) in rb r' really means `let Reader rb = aRb ((\r -> a) r) in (rb r)'
15:31:32 <hoppfull> c_wraith: I don't want it to have state. This is useful actually.
15:31:51 <ski> fnurglewitz : we first need to rewrite this into `(let Reader rb = aRb ((\r -> a) r) in rb) r' (possible since the `r' part doesn't depend on `rb')
15:32:21 <ski> fnurglewitz : and *then* we can eta-reduce `\r -> (let Reader rb = aRb ((\r -> a) r) in rb) r' to just `let Reader rb = aRb ((\r -> a) r) in rb'
15:32:25 <c_wraith> hoppfull: I mean, you can use something like one round of an LCG, but you're not going to have any decent statistical properties with the state being the same as the output
15:32:56 <c_wraith> hoppfull: I suppose you just wanted a reference to an LCG - linear congruential generator.  That's what you'd be describing with some bitshifts, additions, and modulus operations
15:33:02 <ski> (i didn't do the beta-reduction here first, apparently .. well, it doesn't matter, could be done in that order as well)
15:33:21 <hoppfull> c_wraith: If I want a series of 100 random numbers I call "map random [1..100]"
15:33:38 <hoppfull> c_wraith: thanks mate!
15:34:06 <ski> > take 100 (randomRs (0,9) (mkStdGen 1234))
15:34:08 <lambdabot>  [7,5,1,6,1,2,1,9,1,5,2,0,3,0,6,5,1,1,2,0,0,1,8,4,2,9,7,5,8,0,3,2,0,9,8,7,9,5...
15:35:01 <hoppfull> ski: cool
15:36:42 <ski> fnurglewitz : anyway .. the other two monadic laws are `ma >>= return  =  ma' and `(ma >>= amb) >>= bmc  =  ma >>= (\a -> amb a >>= bmc)'
15:37:10 <ski> fnurglewitz : you could try to make a derivation/proof of the former of those, at least, in the `Reader r' case
15:37:44 <ski> fnurglewitz : btw, have you seen what these three monadic laws means, in terms of `do'-notation ?
15:37:50 <fnurglewitz> ski, yes
15:37:57 <ski> good
15:38:07 <fnurglewitz> but I find more clear the "normal" syntax
15:38:15 <fnurglewitz> than the do notation
15:38:24 <ski> (by which i assume you mean using `(>>=)' explicitly9
15:38:25 <ski> )
15:38:27 <fnurglewitz> yes
15:38:34 <fnurglewitz> if you take the list monad
15:38:40 <fnurglewitz> the do notation looks like magic
15:38:45 <fnurglewitz> >>= does not
15:38:51 <ski> it's basically the same as a list comprehension
15:38:57 <fnurglewitz> yes
15:39:04 <ski> the list monad feels a bit like writing Prolog code
15:39:08 <fnurglewitz> lol
15:39:13 <ski> (the backtracking part, not the logic variable part)
15:39:41 <ski>   grand_father(Person,GrandFather) :-
15:39:44 <geekosaur> whence LogicT
15:39:50 <ski>     parent(Person,Parent),
15:39:58 <ski>     father(Parent,GrandFather).
15:40:06 <ski> vs.
15:40:27 <ski>   grandFather aPerson = do
15:40:34 <ski>     aParent <- parent aPerson
15:40:42 <ski>     aGrandFather <- father aParent
15:40:47 <ski>     return aGrandFather
15:42:04 <fnurglewitz> aPerson >>= aParent >>= aGrandFather ?
15:42:16 <ski> (the `:-' in the Prolog means "if", and the `,' at the end of the middle line means "and". the whole clause reads as "A grand father of `Person' is `GrandFather', if a parent of `Person' is `Parent', and also a father of `Parent' is `aGrandFather'.")
15:42:17 <fnurglewitz> aPerson >>= parent >>= grandFather ?
15:42:24 <fnurglewitz> the functions :P
15:42:40 <fnurglewitz> well, father
15:42:46 <ski>   grandFather aPerson = parent aPerson >>= father
15:42:53 <dmwit> gradFather = parent >=> father
15:42:54 <ski>   grandFather aPerson = father =<< parent aPerson
15:43:01 <ski>   grandFather = father <=< parent
15:43:23 * ski blinks at dmwit
15:43:30 <MarLinn> Huh... interesting perspective. I only thought of the type system in terms of logic programming yet, but not the "actual" code.
15:43:33 <fnurglewitz> kleisli?
15:44:14 <ski> it's kleisli composition, yes, in case you know about that
15:44:54 <fnurglewitz> (a -> m b) -> (b -> m c) -> (a -> m c)
15:45:16 <fnurglewitz> should be the type of (>=>)
15:46:12 <ski> @type (>=>)
15:46:13 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:46:24 <ski> @type (<=<)
15:46:26 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:46:27 <ski> @type (.)
15:46:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:46:37 <fnurglewitz> @type flip (.)
15:46:39 <lambdabot> (a -> b) -> (b -> c) -> a -> c
15:46:58 <MarLinn> (>=>) and return form the famous monoid in the category of endofunctors if understand correctly - another way to formulate the laws
15:47:16 <ski> actually a category, not just a monoid
15:47:30 <ski> (for a monoid, it'd be `(a -> m a) -> (a -> m a) -> (a -> m a)')
15:48:01 <MarLinn> ah... so... the famous quote is wrong?
15:48:16 <ski> hm, or perhaps i misunderstood what you meant ?
15:48:34 <geekosaur> the quote is about category theory, not about Haskell
15:48:49 <ski> no, i think you misunderstood (and misquoted) the quote
15:49:09 <ski> the monoid it is talking about is formed by `return' and `join', not `return' and `(>=>)'
15:49:10 <fnurglewitz> http://james-iry.blogspot.it/2009/05/brief-incomplete-and-mostly-wrong.html
15:49:22 <bollu> :t join
15:49:23 <lambdabot> Monad m => m (m a) -> m a
15:49:29 <ski> @type return
15:49:30 <lambdabot> Monad m => a -> m a
15:49:36 <ski>   return :: Id -> M
15:49:38 <fnurglewitz> this should be the origin of the quote
15:49:40 <bollu> ski: >=> is the (.) of the kleisli category right?
15:49:41 <ski>   join :: M . M -> M
15:49:54 <ski> bollu : yes
15:49:59 <ski> (well, flipped)
15:50:02 <MarLinn> ahhh
15:50:07 <bollu> ski: uhh, flipped?
15:50:13 <bollu> :t (>=>)
15:50:14 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:50:19 <bollu> :t (.)
15:50:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:50:21 <zennist> if I define 'type X = ()' in my module, how can I make sure that users don't mix use of X with ()?
15:50:25 <geekosaur> remember (.) "flows" left
15:50:25 <bollu> why flipped?
15:50:28 <ski> @type (<=<)
15:50:30 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:50:32 <bollu> ohh, okay, right
15:50:34 <fnurglewitz> but stackoverflow gives a better link: https://books.google.it/books?id=MXboNPdTv7QC&pg=PA138&lpg=PA138&dq=%22monoid+in+the+category+of+endofunctors%22+mac+lane&source=bl&ots=feQWTkH2Uw&sig=tv-1JwaMOygKGmFE2vM2FhJVS9o&hl=en&ei=5iWsTJCkBIPSsAPQwJ36Aw&sa=X&oi=book_result&ct=result&redir_esc=y#v=onepage&q&f=false
15:50:49 <zennist> is it enough to just export 'X' without '(..)' or I need to not export that altogether?
15:50:56 <ski> zennist : you can't, so don't do that, if you don't want them to mix those up
15:51:05 <Welkin> ...
15:51:17 <ski> (unfortunately), type synonyms are always exported concretely
15:51:29 <zennist> even if I don't export the name at all?
15:51:38 <fnurglewitz> ski, I must really go to bed, 00:51 here 
15:51:42 <fnurglewitz> ski, thank you
15:51:45 <fnurglewitz> ski, good night :)
15:51:45 <geekosaur> if you need to not mix them up, use newtype
15:51:56 <ski> if you don't export the name `X', then users of the module can't mix `X' up with anything, since they can't refer to it
15:52:00 <ski> (obviously)
15:52:08 <ski> fnurglewitz : good night and pleasant dreams
15:52:15 <fnurglewitz> thanks
15:52:30 <zennist> I'm reading Real World Haskell on ffi and it says a convention for opaque foreign data is: type Opaque = ()
15:52:38 <zennist> not sure if this is actually good then
15:52:56 <geekosaur> it is a convention, yes. as is just using () directly without even a type alias
15:53:01 <geekosaur> if you really care: data X
15:53:17 <geekosaur> because it's only ever used as Ptr X
15:54:33 <geekosaur> (at least, if it really is opaque)
15:55:28 <zennist> right - what happens when user constructs a Ptr () passes into your function that's calling into ffi?
15:55:47 <geekosaur> if you used type X = (), it works
15:55:57 <geekosaur> if you used data x, they get a type error
15:56:00 <geekosaur> er, data X
15:56:24 <zennist> yes that would be what I expect - but 'it works' would mean it crashes right?
15:56:50 <geekosaur> presumably, yes. "it works" means it allows the call even though you know it will be nonsense
15:57:05 <geekosaur> the () convention is Haskell98 and predates things like `data` without data constructors
15:57:31 <geekosaur> which came in with Proxy (in the days when the () convention was used for opaque FFI pointers, one used undefined as a proxy)
15:58:14 <zennist> okay, the good old days
15:58:51 <zennist> i suppose i'll favor typed pointers a bit more... type synonym on () really isn't doing anything more - it's as good as a void pointer in c
15:59:11 <zennist> if the user wants he can throw in rubbish
15:59:24 <geekosaur> Ptr () is exactly a void pointer, as the FFI sees it
16:07:38 * ski idly waits to see whether dmwit's client will auto-reconnect
16:08:19 <glguy> ski: auto-reconnect from a K-line?
16:08:34 <ski> glguy : got help with removing it
16:13:05 <algorithmer> hey
16:13:14 <algorithmer> guys I need a help about an algorithm
16:13:42 <hamme> shoot
16:14:50 <ski> wb dmwit
16:15:14 <dmwit> Thanks, ski.
16:15:21 <geekosaur> o.O
16:15:25 <dmwit> That was a new experience for me.
16:15:28 <lordcirth> What's the cleanest way to get a partially-applied function where you've supplied the second argument, not the first?  Use flip?
16:15:29 <hamme> ?
16:15:34 <ski> e helped me out in removing the K-line
16:15:53 <hamme> @type flip const
16:15:54 <lambdabot> b -> c -> c
16:16:24 <dmwit> lordcirth: That's pretty much the exact reason for `flip` to exist, yep.
16:16:25 <ski> lordcirth : or a section
16:16:36 <hamme> ^ cheeky
16:16:37 <Welkin> how can I choose a specific compiler to use with cabal?
16:16:42 <Welkin> it's one that I installed with stack
16:16:46 <lordcirth> ski, a section?
16:16:49 <dmwit> Welkin: Most commands accept -w
16:16:50 <hamme> uh
16:16:51 <ski>   (`foo` secondArg)
16:16:53 <ski> alt.
16:16:54 <algorithmer> I need to find maximum count of an item in an unordered list, I know the list size  and also items are string, but what can i do the maximum counts are the same?
16:16:59 <ski>   foo `flip` secondArg
16:17:03 <Welkin> I don't want to have to use cabal by itself, but stack screwed up and I don't know what else to do
16:17:15 <joe9> I am trying to figure out how FRP can help with this code? https://github.com/bsl/GLFW-b-demo/blob/master/src/Main.hs . Will all the "event writing to a channel and reading and pattern matching the event code" go away?
16:17:25 <hamme> @type \a -> a `const` 
16:17:26 <lordcirth> ski, oh I see!  That makes sense too.  Thanks
16:17:27 <lambdabot> error:
16:17:27 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
16:17:35 <hamme> @type (\a -> a `const`)
16:17:36 <lambdabot> error: parse error on input ‘)’
16:17:46 <hamme> pls
16:17:50 <ski> @type \a -> (a `const`)
16:17:52 <lambdabot> a -> b -> a
16:18:02 <hamme> @type \a -> (`const` a)
16:18:03 <lambdabot> b -> a -> a
16:18:05 <ski> @pl \a -> (a `const`)
16:18:05 <lambdabot> const
16:18:14 <hamme> shhh
16:18:27 <hamme> @pl \a -> (`const` a)
16:18:27 <lambdabot> const id
16:18:45 <hamme> @pl \a -> (+ a)
16:18:46 <lambdabot> (+)
16:23:27 <joe9> Cale you areound?
16:27:53 * hackagebot mailchimp 0.1.0 - Bindings for the MailChimp API  https://hackage.haskell.org/package/mailchimp-0.1.0 (jpvillaisaza)
16:32:26 <lordcirth> I am new to IO Actions.  How do I convert [IO Handle] to [Handle] ?  <- isn't a function that I can map, is it?
16:33:07 <dmwit> you dont
16:33:24 <peddie> lordcirth: you can't convert [IO Handle] to [Handle], but you can convert it to   IO [Handle]
16:33:28 <dmwit> but IO [Handle] is okay
16:33:39 <dmwit> :t sequence
16:33:40 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
16:34:00 <dmwit> :t sequence @[]
16:34:01 <lambdabot> error:
16:34:01 <lambdabot>     Pattern syntax in expression context: sequence@[]
16:34:01 <lambdabot>     Did you mean to enable TypeApplications?
16:34:22 <lordcirth> And then ' handles <- IO [Handle] ' ?
16:34:47 <dmwit> yeah
16:34:47 <lordcirth> where handles :: [Handle] ?
16:34:55 <lordcirth> Great.  Thanks guys
16:35:06 <geekosaur> no, that's not quite right
16:35:31 <geekosaur> sequence gets you from [IO Handle] to IO [Handle], then <- gets you to [Handle]
16:36:16 <lordcirth> Isn't that what I said?
16:36:40 <orion> I need to read digital signal data from a USRP (using the UHD API) and feed it to a Haskell application for processing. What's the fastest way to transport the data in to my application, assuming a POSIX environment? Should my C++ application write to a memory mapped file... or something? I assume reading from stdin would be terribly slow.
16:36:43 <ski> 'tis
16:38:54 <geekosaur> actually [11 23:34] <lordcirth> And then ' handles <- IO [Handle] ' ?  if you meant that literally then you;d get an error that the data constructor IO is not in scope
16:39:02 <lingxiao> hey all
16:39:13 <geekosaur> handles <- sequence (<here gos the expression that was giving you [IO Handle]>)
16:39:15 <lordcirth> geekosaur, I meant, handles <- (thing with type of IO [Handle] )
16:39:36 <lingxiao> suppose i want to represent Gigs of files containing phrases into a binary tree
16:40:02 <lingxiao> so each node is a token ... and complete path from root to leaf form one phrase
16:40:19 <lingxiao> ie ... path   100101...001  = good but not great
16:40:29 <lingxiao> for fast searching ..
16:40:48 <lingxiao> is there some package that'll take the data and do it for me?
16:41:10 <lordcirth> lingxiao, these phrases will only need binary search?  That is, you don't need fulltext/substring search?
16:41:54 <lingxiao> sorry what's fulltext search?
16:42:05 <lingxiao> i may need substring search im not sure
16:42:28 <lordcirth> lingxiao, same thing, fulltext search is what database/SQL people usually call it
16:42:43 <lingxiao> ok i may need that too
16:42:49 <lingxiao> what's teh data structure i need ?
16:43:20 <lordcirth> I'm no expert but I don't think a b-tree will get you substring search, only starting-string search.
16:44:14 <Cale> lordcirth: How are you originally getting that list of type [IO Handle]? If it's by applying map, then perhaps you'd prefer to use mapM or forM
16:44:43 <lordcirth> Cale, handles args = map (`openFile` ReadMode) (words args)
16:45:03 <Cale> yeah, you just want to use mapM instead of map
16:45:07 <ski> then use `mapM' instead
16:45:08 <Cale> :t mapM
16:45:10 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
16:45:12 <Cale> heh
16:45:13 <lordcirth> Right ok.
16:45:23 <ski> (and then skip the `sequence')
16:45:33 <Cale> I'm always surprised to see the Traversable generalisation still
16:45:40 <ski> @src mapM
16:45:40 <lambdabot> mapM f as = sequence (map f as)
16:46:16 <amalloy> why isn't it just mapM = traverse?
16:46:38 <amalloy> :t traverse
16:46:39 <ski> `traverse' is in terms of `Applicative'
16:46:40 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:46:49 <amalloy> right, but Monad implies Applicative now
16:46:58 <ski> (this was from before `Applicative' became a superclass of `Monad')
16:47:00 <amalloy> sure
16:47:22 <amalloy> i just sorta expected the implementation to be replaced. i guess there's no particular reason for that to have happened
16:47:29 * geekosaur wonders if @src has any relationship to reality here...
16:48:33 <ski> (hm .. i suppose for a collating exceptions thing, `mapM' and `traverse' would be different ?)
16:48:37 <geekosaur> in any case, the likely reason is that changing types like that sometimes breaks programs that were relying on type inference that suddenly doesn't work any more
16:49:14 <geekosaur> FTP caused enough of that as it was, without dragging in a potential AMP source as well
16:50:14 <lordcirth> lingxiao, I'm no expert on data structures, but I'd suggest looking for a library.
16:50:35 <lingxiao> yeah im looking, just wondring if anyone know of a good lib to use
16:51:30 <lordcirth> lingxiao, well, I see this, but it's probably not want you want? https://hackage.haskell.org/package/sphinx
16:52:03 <hoppfull> Can I write C in a haskell source file?
16:52:15 <geekosaur> if you're after full text search, that sphinx package or maybe https://github.com/hunt-framework/hunt
16:52:33 <lingxiao> ok both of these are good
16:52:37 <geekosaur> hoppfull, http://hackage.haskell.org/package/inline-c
16:52:44 <lingxiao> im doing naive implementation and oh man it's intractable
16:52:47 <lingxiao> even on remote
16:53:17 <lingxiao> so wait my text files are in a direotry somewhere
16:53:29 <lingxiao> and i'm quering for occureences of  "good not great"
16:53:32 <lingxiao> or "* not *"
16:53:36 <lingxiao> where * is wildcard matching any word
16:53:57 <lingxiao> so just to be sure this is the setting im in, so the frameworks are approriate right?
16:54:15 <geekosaur> for that you want one of those packages, yes
16:54:18 <hoppfull> geekosaur: thanks
16:54:21 <lordcirth> lingxiao, as a Linux server admin, this sounds like a problem for 'grep' :P
16:54:40 <geekosaur> grep isn't the best tool for that
16:55:03 <geekosaur> well, if it's a one-off it will do. for repeated searhces in particular, you want the smart indexing from a full text search library
16:55:21 <MarLinn> amalloy: I checked out of curiosity and mapM is now part of Traversable and indeed just defaults to traverse
16:55:43 <lingxiao> geekosaur is that the one you sent 
16:55:45 <lingxiao> hunt?
16:55:54 <geekosaur> both hunt and sphinx
16:56:16 <lingxiao> ok are there online tutorials .. the documentation seem sparse
16:57:06 <geekosaur> sphinx itself is a daemon, possibly not appropriate for your use unless you can either reach it or install/configure it yourself on the batch host(s)
16:57:16 <geekosaur> (the haskell library is a client that talks to the daemon)
16:57:35 <geekosaur> hunt is the search engine underlying hayoo.fh-wedel.de
16:57:38 <lordcirth> geekosaur, from the readme, Hunt also appears to be a daemon?  Albeit one written in Haskell
16:57:42 <geekosaur> and the source for that is probabluy the only example
16:58:19 <geekosaur> that.. wouldn't surprise me much. the older standalone FTS libs were painful when used with concurrent searches
16:59:59 <lingxiao> geekosaur im going to assume i cannot install or configure it on the host
17:00:03 <lingxiao> so i shold use hunt?
17:00:14 <lingxiao> how do i use a daemon?
17:00:37 <lordcirth> lingxiao, you run it, and then use it's API to talk to it, I would guess.
17:00:59 <lordcirth> lingxiao, https://github.com/hunt-framework/hunt/tree/master/hunt-client
17:01:07 <lordcirth> There's a client library as well
17:01:34 <lingxiao> ok im going to play with it and i'll be back with Tons of questions
17:01:36 <lingxiao> thanks guys!
17:01:37 <lordcirth> So you'd run the daemon in the background, (systemd service or whatever) and then your program would import the library and talk to it
17:01:54 <geekosaur> probably not going to fly on the batch hosts :)
17:01:58 <geekosaur> (systemd, that is)
17:02:42 <lingxiao> yeah ... i'm worried about that ..
17:02:54 <lordcirth> Where are these batch hosts from?
17:03:05 <lingxiao> well its the schools system
17:03:08 <lordcirth> Ah I see
17:03:13 <lingxiao> i submit my script into a que and it runs it
17:03:18 <lingxiao> well yeah
17:03:34 <geekosaur> well, you can run it within your batch job
17:03:43 <geekosaur> start server, run your program that sues it, stop server
17:03:48 <geekosaur> *uses it
17:04:03 <lordcirth> lingxiao, is your script allowed internet access, and to write temp files?
17:04:09 <lingxiao> i doubt it
17:04:11 <lingxiao> i can ask the admin
17:04:25 <lingxiao> but he's been helping me over th elast three days with a bug so i feel bad asking him some more
17:04:41 <lingxiao> i can write temp files yeah
17:04:45 <geekosaur> it's his job, make him earn his pay :p
17:04:45 <lingxiao> i dont know about internet access
17:04:52 <lingxiao> :( he's so nice though
17:05:13 <lordcirth> lingxiao, can you submit data files to work on with your script?
17:05:18 <lingxiao> i can def write to disk , i have an account
17:05:26 <lordcirth> Just a single bash file would be quite limiting...
17:05:44 <lingxiao> um .. i can scp data to the host 
17:05:54 <lingxiao> but i can only submit a bash script for my jobs
17:06:01 <lordcirth> lingxiao, right.  So you can scp the server binary and your data files.
17:06:17 <lingxiao> ok so wait what's the workflow here? im honesty so very new to this :(
17:06:23 <lordcirth> Then your script &'s the server, calls your haskell program, and kills the server when you're done.
17:06:34 <lingxiao> what's &'s the server?
17:06:50 <lordcirth> lingxiao, sorry, forks it with & in bash
17:07:09 <lingxiao> ok oh boy i think im gona get to know the admin some more in the coming weeks
17:07:15 <geekosaur> lingxiao, actuallu I have one question: do the data files (on the batch servers) change, or are they always the same?
17:07:31 <lordcirth> So your bash would be: " ./server &; ./haskell; killall server "
17:07:35 <lingxiao> wait by data files we are talking about the input to my programs right?
17:07:39 <geekosaur> if you are changing the data files a lot, this won't help you very much because it will have to reindex on every startup
17:07:42 <geekosaur> yes
17:07:43 <lingxiao> ok i gotta copy and paste that
17:07:56 <lordcirth> lingxiao, yes, but with the data files, you can send your program, server, etc.  Because files are files.
17:08:15 <lingxiao> geekosaur no they are there once there
17:08:20 <lingxiao> so they wont change ..
17:08:29 <geekosaur> if the data files are always or mostly the same, you don't need to reindex and searches should be much faster. although in either case you still gain the ability to ignore intervening whitespace/punctiation/etc.
17:08:33 <lingxiao> so i build the binary on local ... and send it to remote is that what you have in mind?
17:08:47 <lingxiao> wait what would make them change?
17:08:54 <lingxiao> like i wont run any processes that change them
17:08:54 <lordcirth> lingxiao, yeah, and then your bash script just does setup and launches it
17:08:57 <lingxiao> i dont know about the admin
17:09:14 <lingxiao> wait if this stuff is fast i can run it on local right?
17:09:34 <lingxiao> i have 8Gig of ram ... more like 3 available when computer is quiet
17:11:11 <lingxiao> lordcirth are you here a lot?
17:11:19 <lingxiao> so i may ask you questions in the next 3 days :)
17:11:35 <lordcirth> lingxiao, yes I am.  But I may not be the best to ask :P
17:11:44 <lingxiao> better than myself!
17:13:13 <lingxiao> ok so top level tasks ... i have 93 Gigs of text files
17:13:40 <lordcirth> fun
17:13:43 <lingxiao> i need to find a way to query it using hunt
17:13:47 <Gurkenglas> Can "equalPairOfBits m n = minimum [2^i|i <- [0..], mod (xor m n + 1) (2^i) == 0]" possibly give divide by zero?
17:13:48 <lingxiao> yeah it's google ngram
17:14:48 <Gurkenglas> Oh of course, when i hits 32. <.<
17:24:20 <Welkin>  .stack-work/dist/x86_64-osx/Cabal-1.22.8.0_ghcjs/: does not exist
17:25:00 <Welkin> has anyone solved this?
17:29:02 <lingxiao> hey if i want to init a stack project with src and app, compile from app
17:29:11 <lingxiao> what do i put here:   stack new my-project [...]
17:29:14 <lingxiao> in the [..]
17:29:42 <Welkin> who knows
17:29:55 <Welkin> stack is broken for me when I use the templates
17:29:57 <Welkin> at least for ghcjs
17:29:58 <MarcelineVQ> the default should have a src and app folder already so​I'm not sure what you're after
17:30:44 <lingxiao> oh ops
17:30:45 <lingxiao> thanks
17:57:51 <lingxiao> hey all
17:58:01 <lingxiao> im tring to to install hunt : https://hackage.haskell.org/package/hunt-searchengine
17:58:19 <lingxiao> but putting   hunt-searchengine     in my build-depends throws error
17:58:44 <lingxiao> http://lpaste.net/191321
18:00:17 <lingxiao> putting this here:   hunt-searchengine-0.3.0.1 
18:00:21 <lingxiao> gets parse error
18:02:40 <lingxiao> ping anyone?
18:04:01 <geekosaur> it's not in stackage
18:04:29 <lingxiao> oh boy :(
18:04:31 <lingxiao> what should id o
18:04:36 <lingxiao> what's what im afraid of 
18:04:46 <lingxiao> maybe i hsould just use python
18:05:29 <geekosaur> https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
18:07:17 <lingxiao> uh this is my yaml file: http://lpaste.net/191323
18:07:24 <lingxiao> getting parse error though
18:07:29 <Welkin> yeah
18:07:37 <Welkin> stack is broken
18:07:40 <Welkin> I'm dealing with issues tonight
18:08:00 <lingxiao> D:
18:08:09 <lingxiao> i have an advisor meeting tomorrow and im fighting w/ this shit
18:08:16 <lingxiao> sorry for the french
18:09:27 <zyhn> If I have a ParsecT p, is there an easy way to make a parser (not p) that accept everything except what p accepts?
18:10:32 <lpaste> fizbin pasted “Why won't this compile” at http://lpaste.net/191327
18:10:56 <Welkin> zyhn: fmap not?
18:11:06 <lingxiao> geekosaur any inputs
18:11:07 <lingxiao> ?
18:11:34 <Welkin> I haven't worked with parsec in a long time
18:11:35 <fizbin> That ^^^ is a reduced example of one of the compile issues that using the "TypeFamilies" extension causes, without any actual type families added.
18:11:42 <Welkin> don't remember much about it
18:12:28 <fizbin> It appears that somehow saying {-# LANGUAGE TypeFamilies #-} can break type inference in weird ways I don't understand
18:12:50 <geekosaur> lingxiao, aside form not indenting line 12, no
18:13:06 <lingxiao> indenting as in 4 spaces?
18:13:39 <jle`> fizbin: you get used to it :)
18:13:41 <lingxiao> wait no my erro was elsewhere
18:13:44 <lingxiao> nvm got it thanks1
18:13:45 <geekosaur> yes, because all examples show no indentation. this is yaml not haskell
18:15:19 <hoppfull> I've figured out how to compile C to DLL and call from Haskell with FFI. Apparently I can write C in my Haskell source files with something called TemplateHaskell. Is there any point in me learning TemplateHaskell right now? I've been doing Haskell for about a week so far.
18:15:32 <fizbin> jle`: Um.. get used to what, exactly?
18:15:55 <fizbin> Type inference going to hell unpredictably for no reason?
18:15:59 <jle`> lol
18:16:01 <jle`> yes v.v
18:16:09 <jle`> but eventually it gets slightly less unpredictable
18:16:10 <fizbin> Or TypeFamilies being not ready for real use?
18:16:15 <knx32542>  Hello. I am playing around with hsqml. A tutorial used `runengineloop defaultEngineConfig {initialDocument = fileDocument "qmlfile.qml"}`. However, this proves problematic when using `stack build`, because the path to "qmlfile.qml" is relative from the execution location. Is there a way to bake either the qml file or the path to the qml file into the haskell executable?
18:16:44 <jle`> you start to notice patterns in the errors you get, and things get a bit less of a crazy adventure every time you compile
18:17:04 <fizbin> jle`: Ah. So you haven't actually looked at my paste.
18:17:23 <Axman6> hoppfull: using language-c-inline might be waht you want if you're wrapping some C library (https://hackage.haskell.org/package/language-c-inline)
18:17:46 <geekosaur> fizbin, I would actually report that one in #ghc or on ghc trac, it seems like the extension shouldn't do anything without actual type families (and the docs so imply)
18:17:50 <Welkin> or just use the c ffi
18:18:01 <geekosaur> hoppfull, did you even notice my linking you to inline-c earlier?
18:18:23 <geekosaur> or by Template Haskell are you referring to its quasiquotes?
18:18:37 <hoppfull> geekosaur: Yeah.
18:18:40 <geekosaur> if so, just follow the examples, don't worry about the rest
18:18:55 <geekosaur> you shouldn't need actual TH, just use the quasiquotes
18:19:00 <fizbin> geekosaur: Also, that I can fix it by changing the definition of initialSet - something with an explicit type with no variables in it - is very bizarre.
18:19:03 <hoppfull> geekosaur: oh okay
18:19:23 <Welkin> hoppfull: are you a beer elf?
18:19:32 <jle`> well, i clicked on it >_>   <_<
18:19:37 <hoppfull> Welkin: Excuse me?
18:19:39 <lingxiao> http://lpaste.net/191332
18:20:03 <Welkin> hoppfull: full of hopps
18:20:09 <lingxiao> im getting an error again
18:20:22 <lingxiao> but i think its correct?
18:20:28 <lingxiao> though clearly not
18:20:31 <geekosaur> knx32542, https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
18:20:34 <Welkin> just keep trying then
18:20:37 <glguy> lingxiao: indent it as you indented packages
18:20:45 <hoppfull> Welkin: heh maybe.
18:21:14 <lingxiao> i did
18:21:30 <geekosaur> lingxiao, that error looks familar. what version of stack?
18:21:34 <lingxiao> i also did tab, but then got a compalint about F'dound a  tab ccharacter that vioalte"
18:21:39 <lingxiao> uh not sure
18:21:43 <knx32542> geekosaur: Thanks
18:21:45 <glguy> lingxiao: No, don't do it like you did in the paste
18:21:53 <lingxiao> sorry?
18:21:56 <lingxiao> hwo so?
18:22:03 <geekosaur> lingxiao, "stack --version"
18:22:12 <lingxiao> Version 0.1.10.1 x86_64 
18:22:13 <glguy> the indentation of extra-deps and packages is different, make extra-deps look like packages
18:22:17 <geekosaur> sorry I forgot I have to give you explicit directions (also note glguy)
18:22:34 <geekosaur> 0.1? you need to upgrade it, and it's old enough that "stack upgrade" probably won't work
18:22:43 <glguy> lingxiao: You-ll probably also need to list a version number on hunt-server
18:22:46 <geekosaur> and that is why your;e getting the error, it's a bug
18:22:49 <Welkin> lol...
18:22:58 <lingxiao> how do i updagrade it?
18:23:02 <lingxiao> oh boy .. :(
18:23:04 <Welkin> lingxiao: just delete it and reinstall
18:23:04 <geekosaur> ... rght
18:23:11 <glguy> lingxiao: Invalid package identifier: \"hunt-server\" means you forgot the version number
18:23:16 <Axman6> stack upgrade :\
18:23:16 <geekosaur> that;s not detailed enough for lingxiao 
18:23:18 <lingxiao> wow im hving all the funs tonight
18:23:24 <geekosaur> stack upgrade tends to fail from 0,1
18:23:32 <geekosaur> ... never mind carry on
18:23:35 <lingxiao> doing it now crossing my fingers
18:23:50 <Welkin> lingxiao: delete everything but the steam folder
18:24:05 <lingxiao> hopefully it wont fail with eror
18:24:15 <Welkin> maybe it will fail with child?
18:24:15 <lingxiao> wait if stack upgrade terminate w/ no error it means it upgraded right?
18:24:26 <glguy> lingxiao: before you upgrade stack you should fix the version number of hunt-server
18:24:36 <lingxiao> https://hackage.haskell.org/package/hunt-server
18:24:51 <lingxiao> ah so i'll do hunt-server-0.3.0.2 right?
18:25:03 <lingxiao> anyone use hunt before?
18:25:09 <lingxiao> last commit is like 2 - 6 months ago
18:25:17 <lingxiao> even though ther's some  downloads in recent days
18:25:27 <Welkin> you need a server to search?
18:25:33 <Welkin> isn't that built into postgres and others?
18:25:41 <lingxiao> maybe i should jsut do that ..
18:25:46 <lingxiao> actually  im not sure how
18:25:57 <lingxiao> i have 93 gigs of text file i need to search
18:26:20 <lingxiao> looking for specfiic phrases like "good and great" but also something like "* and great *"
18:26:27 <lingxiao> where star matches any string
18:26:40 <lingxiao> someone recommendeded hunt
18:26:43 <Welkin> use grep?
18:26:46 <lingxiao> but you're saying i should just do postgres
18:26:59 <lingxiao> someone recommneded that too
18:28:09 <Welkin> why woudl you set up a server just to search some text files? O.o
18:28:10 <geekosaur> grep is not ideal for this
18:28:22 <geekosaur> Welkin, do you understand full text search?
18:28:37 <geekosaur> grep is line oriented search, does not handle how words actually work, etc.
18:28:49 <lingxiao> yeah icant really grep it
18:29:05 <lingxiao> my goal is to get the fasted thing going w/ the least amount of code and can of worms i have to open
18:29:24 <lingxiao> i have never used hunt, or posgres for that matter
18:29:24 <geekosaur> it would be nice if people still used the old standalone searchers for something like this, but they all went to concurrent backends a decade ago
18:29:28 <lingxiao> so what's my options?
18:29:47 <geekosaur> postgres is also server based, the server is just a lot more complicated and your sysadmin WILL have to be involved
18:30:55 <lingxiao> ok and w/ hunt i can rely it on being simple and usable?
18:31:04 <lingxiao> like theres no documentation
18:31:20 <Welkin> you'll need to get used to that
18:31:21 <lingxiao> just this: https://hackage.haskell.org/package/hunt-searchengine
18:31:24 <lingxiao> yeah ...
18:31:25 <Welkin> most things don't have any documentation
18:31:31 <Welkin> if they do, it is sparse at best
18:31:31 <lingxiao> its just a tradeoff
18:31:40 <lingxiao> between that and reading more papers :(
18:31:45 <lingxiao> i wish i had 30 hrs a day
18:32:20 <geekosaur> hunt is a research project¸ if you are after polished and end user ready then (a) there are no end user ready full text search databases, pretty much by definition, and (b) it will not be polished
18:32:39 <lingxiao> ok tha'ts good information
18:32:44 <lingxiao> it actually simplifies my situation
18:32:48 <lingxiao> if i have no options then one will do
18:33:07 <lingxiao> wait why by defn though
18:33:07 <lingxiao> ?
18:33:14 <geekosaur> becuase it's not an end user thing
18:33:30 <lingxiao> id like to be a user :)
18:33:51 <geekosaur> which is why all of them are servers these days. it's a backend service, and usually wants customization for specific use cases although for yours you can likely avoid that
18:34:08 <geekosaur> (like, hunt has the ability to be customized for Haskell search which is how hayoo works)
18:34:15 <geekosaur> (but you don;t want that)
18:35:06 <lingxiao> ok i'll customize it for myself then
18:35:16 <geekosaur> again you should nto need to
18:35:20 <lingxiao> an unfair quetions, how long would it take me?
18:35:29 <lingxiao> or i mean write a wrapper around it or what have you
18:35:42 <lingxiao> the goal is to be atlbe to put in:  * although not *
18:35:53 <lingxiao> and it returns a list of all occurences of it in store
18:35:56 <geekosaur> the default will work for you. custimization is for (a) special cases, like hayoo doing Haskell type searches, and (b) heavy use like a globally published search interface
18:36:26 <geekosaur> in fatc I am not sure how you decided you needed to customize for yourself from [12 01:33] <geekosaur> (but you don;t want that)
18:37:38 <hoppfull> I'm currently working with Haskell in Notepad++ with no intellisense or code completion or anything like that. Is that the normal way to do it or is there a Haskell IDE that I haven't heard about?
18:38:07 <lingxiao> oh sorry i didnt mean customize
18:38:11 <lingxiao> i meant like write a wrapper
18:38:31 <benzrf> hoppfull: i think people usually use non-haskell-specific text editors, but often with haskell-related plugins
18:38:53 <benzrf> e.g., i myself use vim, but with automatic typechecking-on-save and a type lookup shortcut
18:38:57 <hoppfull> benzrf: Alright, thanks
18:39:29 <geekosaur> IDEs are somewhat thin on the ground. apparently there is a plugin for IntelliJ
18:39:44 <geekosaur> there used to be a plugin for eclipse but last I heard they'd stopped developing it
18:40:49 <dfeuer> I spent a while using Emacs with several Haskell plugins. It made quite a nice IDE, although I hate Emacs.
18:40:49 <benzrf> theres that web ide from fpcomplete
18:40:57 <MarcelineVQ> the various atom plugins work reasonably well as long as your tools themselves are set up properly
18:40:59 <Welkin> benzrf: looooooool
18:41:21 <benzrf> atom is just emacs reinvented to use js instead of lisp
18:41:31 <benzrf> and DOM instead of whatever probably-saner thing emacs uses
18:41:34 <Welkin> benzrf: atom is a pile of shit, you mean
18:41:46 <dfeuer> That hardly sounds like an improvement.
18:42:11 <benzrf> Welkin: thats my inclination
18:42:11 <dfeuer> I wish the Emacs clone build on MIT Scheme (I think it was called Edwin) had taken off.
18:42:14 <benzrf> but i mean
18:42:18 <lingxiao> sublime w/ syntax highlting here 
18:42:20 <benzrf> emacs lisp is dynamically scoped
18:42:22 <dfeuer> That would have been a pretty sweet platform.
18:42:23 <lingxiao> so not an ide
18:44:19 <dfeuer> It'd also be pretty cool to have an editor I could program/configure in Haskell.
18:45:02 <boj> yi?
18:48:07 <dfeuer> boj, is that currently a practical editor as good as vim or emacs for Haskell programming? It sure wasn't last I checked.
18:48:48 <boj> dfeuer: i was curious myself and am installing it now. haven't used it in a year
18:48:56 <dfeuer> *nod*
18:49:38 <fizbin> Is anyone familiar with working with MonoLocalBinds and the ST monad ?
18:50:39 <fizbin> I've got accept MonoLocalBinds because I want to use TypeFamilies and right now it appears that every binding that's in the ST monad is going to need an explicit type.
18:53:25 <lingxiao> omg it worked
18:53:26 <lingxiao> !
18:53:26 <dmwit> dfeuer: Supposedly there was recently a tool released for configuring emacs in Haskell.
18:53:27 <lingxiao> yah sleep
18:53:29 <lingxiao> thnaks guys!
18:53:36 <lingxiao> geekosaur in particular
18:54:10 <dfeuer> dmwit, interesting/weird.
18:54:26 <dfeuer> fizbin, MonoLocalBinds is usually just fine. You might need a few extra type signatures.
18:55:21 <fizbin> dfeuer: "a few" - it seems everything in the ST monad now needs an explicit signature.
18:55:34 <dfeuer> fizbin, for example, if you want to define an ST action in a let or where clause, then you *may* have to give it an explicit signature.
18:55:50 <dfeuer> fizbin, show your code?
18:56:01 <fizbin> (Otherwise, it gets generalized to something that doesn't include the necessary "forall s" bit of the type)
18:56:43 <dfeuer> fizbin, note that if you write your ST action so it doesn't depend on surrounding bindings, it can be lifted out, avoiding MonoLocalBinds.
18:56:53 <dfeuer> (lifted out automatically, that is)
18:57:08 * dfeuer generally doesn't mind adding type signatures.
18:57:28 <dfeuer> But that's because I tend to find code without type signatures hard to read.
18:58:31 <dfeuer> Most of the time I'm writing something to do with ST, I'm either writing a top-level binding (or one that can be lifted to the top level) or I'm writing runST $ ....  Your usage pattern seems different.
18:58:44 <hoppfull> I guess Stack or Cabal downloads a package in the form of a tar.gz file from hackage and compiles it or is already compiled?
18:58:56 <dfeuer> hoppfull, it's definitely not already compiled.
18:59:11 <geekosaur> they download and build a .tar.gz. stack will cache such compiles and reuse them if they are compatible
18:59:34 <geekosaur> (I think cabal new-build, in cabal 1.24+, should also do so)
18:59:38 <hoppfull> ok thanks
18:59:48 <fizbin> dfeuer: I'm going to try reducing my code to a shareable example.
18:59:49 <geekosaur> (but new-build is still a development snapshot in 1.24)
19:00:24 <hoppfull> I've been doing it manually so far with ghc. I wish I could stay innocent but I guess I can't stay away from stack or cabal.
19:02:42 <dmwit> Doing things manually is good practice.
19:02:50 <dmwit> It helps you understand what the automatic tools are doing for you.
19:09:13 <hoppfull> dmwit: You're the first person to say that. I've gotten some less than nice comments because I want to try things out without an IDE for example.
19:09:49 <hoppfull> Not in this channel, I should add.
19:10:00 <dmwit> I do things the hard way a lot.
19:10:10 <geekosaur> the other day I was trying to help out someone in another channel who turned out to be utterly helpless if their IDE didn;t have a button to do whatever it was they needed
19:11:25 <hoppfull> I'm not just saying this but this is probably the nicest channel I've been in.
19:14:31 <dmwit> I got quite a shock last time I had a C design question and thought, "I know, I'll ask some experts... I'll head to ##c".
19:15:00 <hoppfull> dmwit: What happened?
19:15:13 <dmwit> Not only did I get called several derogatory names, I got advice to change my approach that turned out to be really detrimental.
19:15:52 <hoppfull> dmwit: Wow. Sorry but I'm sort of glad I'm not the only one that has experienced this.
19:32:22 <fizbin> When defining a type family inside a class, is there some way to require the instances of the type family to also be instances of something else?
19:32:53 <glguy> class Else (TypeFamily1 a) => Class a
19:33:32 <fizbin> That is, can I say "everything that's an instance of DictStorable has an associated Key type, and that Key type must be an instance of Ord"?
19:33:47 <fizbin> glguy: That's not what I want, I think.
19:34:29 <glguy> what i said does that
19:35:20 <geekosaur> more specifically, you can do that in the class that defines the associated type family
19:35:46 <fizbin> Oh. Huh. Okay, maybe I understand.
19:37:40 <fizbin> Okay, yes, that worked. Thank you - I didn't think to try using the type family before it was defined like that.
19:53:15 <dfeuer> dmwit, may I ask what angered the ##c people?
19:57:31 <lpaste> nathyong pasted “Storable mess” at http://lpaste.net/191347
19:57:53 <nathyong> so I've got this pattern of functions in my FFI-interfacing module
19:58:08 <nathyong> is there a way to clean this up so I don't end up going all the way to call17?
19:58:40 <nathyong> I know if I convert it into pointfree it should be possible (so then the arguments get tacked onto the end nicely) but I'm not sure how to do that transformation.
20:01:25 <dfeuer> nathyong, sorry, I don't know FFI. But I think any FFI code that doesn't confuse the heck out of you is probably good enough.
20:01:47 <nathyong> It's mostly just a translation process from some C binding code that I wanted to use
20:02:26 <nathyong> judging by the automatic pointfree converter results I don't think it's possible
20:02:28 <nathyong> oh well
20:03:25 <pavonia> TH maybe
20:03:30 <dmwit> dfeuer: I guess I could dig up my logs.
20:04:00 <nathyong> pavonia: would you know of a (readable) intro to TH?
20:04:44 <dfeuer> dmwit, it doesn't matter enough for *that*.
20:05:00 <dfeuer> nathyong, that's something I'd love to see too.
20:05:04 <pavonia> nathyong: Hhm, no, sorry
20:05:31 <nathyong> pavonia: that's all right, thanks for the suggestion though
20:06:01 <pavonia> Most TH code if written was following the types of the TH Syntax module
20:11:34 <dmwit> dfeuer: It turns out my memory is faulty. I was only insulted in passing; the toxic comments were aimed at somebody else.
20:12:09 <dmwit> Choice quotes include, "Are you a human being or a cabbage in disguise?" and "In order to become less deranged, I want you to imagine that your C compiler targets javascript.".
20:12:14 <dmwit> http://lpaste.net/6354642476526993408
20:12:24 <dmwit> However, my memory of receiving bad advice was correct. =P
20:18:12 <nathyong> so I found my issue
20:18:18 <nathyong> :t (>>=)
20:18:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:18:45 <nathyong> there's no overloading version of (>>=) that lets me return, say, (a -> b -> c -> d -> m e)
20:19:40 <dmj> nathyong: what are you trying to do
20:19:46 <dfeuer> dmwit, that's pretty bad.
20:19:58 <nathyong> dmj: generalise this pattern into one function http://lpaste.net/191347 
20:20:02 <geekosaur> [12 02:57] <lpaste> nathyong pasted “Storable mess” at http://lpaste.net/191347
20:20:13 <geekosaur> whoops, slow >.>
20:20:37 <dfeuer> geekosaur, the timing was so tight I initially mistook you for the paste bot.
20:21:04 <dmj> nathyong: so you're trying to make a variadic function
20:21:12 <nathyong> dmj: ..yeah, that sums it up
20:21:49 <nathyong> I guess this is the reason why we have zip[3..7]
20:22:07 <dfeuer> nathyong, that usually involves ugly-looking classes. But you might be able to do it.
20:22:15 <dmj> nathyong: http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
20:22:50 <nathyong> hey, this is the purely functional data structures guy right?
20:22:58 <dfeuer> No.
20:23:21 <dfeuer> nathyong, that's Okasaki. okmij is Oleg Kiselyov, the mad computer scientist.
20:23:32 <nathyong> oh, the typed final person then
20:23:37 <dfeuer> Yeah.
20:23:44 <nathyong> uhh,tagless final
20:23:44 <dmwit> nathyong: I can barely parse the types you've written. They're crazy!
20:23:45 <nathyong> yeah
20:23:49 <dmwit> Do they need to be that crazy?
20:23:58 <dmj> nathyong: Oleg is from the future, hey came back in time to give us insight, understanding
20:24:02 <dmj> he*
20:24:22 <dmj> nathyong: this too, http://stackoverflow.com/a/3467806
20:24:35 <nathyong> dmwit: basically I've got a struct of function pointers; I first need to get the function pointers out, and then I need to turn them into Haskell functions
20:25:00 <nathyong> dmj: so that's how printf is implemented.. cool!
20:25:54 <dfeuer> nathyong, you're going to want {-# INLINE #-} pragmas in every instance to make this efficient, I think.
20:26:05 <nathyong> dfeuer: yeah, I just realised that would be an issue
20:26:07 <dfeuer> If you can figure out how to do it at all.
20:26:26 <dfeuer> {-# INLINE #-} is pretty effective if you use it right.
20:26:48 <glguy> nathyong: To call a C function pointer from Haskell you need a dynamic wrapper. Here's an example https://github.com/glguy/irc-core/blob/v2/src/Client/CApi/Types.hsc#L82
20:27:23 <glguy> nathyong: In fact that module also gets the function pointers out of a struct
20:27:40 <glguy> nathyong: See line 91 for such a struct
20:27:42 <nathyong> hmm, maybe this is a better example
20:31:14 <nathyong> glguy: yeah, this looks like a much better example than what I've got at the moment
20:31:25 <nathyong> adding the Dynamic type alias already helped a lot
20:32:15 <pavonia> dmwit: The worst part is that Zhivago is an operator in that channel
20:34:05 <dmwit> Thanks all for commiserating with me. It really is appreciated. Also, to keep this channel positive, let's take the remainder of the complaints to -blah or -offtopic.
20:36:54 <nathyong> glguy: are you using any extensions or modules to instantiate the Storable instance? I'm not familiar with the #peek infrastructure (I've been using c-storable-deriving)
20:38:16 <glguy> nathyong: I'm using the hsc2hs tool that comes with GHC. Note the .hsc file extension
20:39:59 <nathyong> all righty..
20:45:52 <nathyong> Yeah, I think that I'm actually looking for variadic arguments, unfortunately...
20:46:14 <buttons840> whats the fastest way to build a Text one character at a time? make a [Char] and pack it?
20:46:24 <dmj> nathyong: have you checked out inline-c?
20:46:49 <glguy> nathyong: to call a variadic function via the FFI you can use the CApiFFI extension
20:47:01 <glguy> you'll still need to know what type you're calling the function at, but you can call it
20:47:18 <glguy> If you want to call such a function with a runtime-known type you can use something like libffi
20:48:28 <nathyong> yeah, I think my use case is actually somewhat uniqu
20:48:35 <geekosaur> buttons840, maybe http://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy-Builder.html ?
20:48:41 <nathyong> I'll fire up an example
20:48:58 <dmj> buttons840: you want to go from Text to String to what?
20:49:02 <geekosaur> or if it really is always 1 char a a time, probably just pack
20:52:05 <buttons840> dmj: what do you mean? I'm trying to create a random string (a token) for a Servant API
20:52:18 <lpaste> nathyong pasted “Special case of dynamic function” at http://lpaste.net/191350
20:52:55 <nathyong> (regarding the use case, it's similar to the use case for "this")
20:53:20 <dmj> buttons840: for purposes of authentication?
20:54:46 <glguy> nathyong: Is there a problem in the paste or is everything working and you're sharing?
20:54:55 <nathyong> glguy: nope, there's no problem
20:55:04 <nathyong> Ideally I would like to abstract it out, but oh well
20:55:15 <nathyong> I'll just write a Python script to write the code for me
20:55:18 <dmj> buttons840: I'd just use the JWT package
20:55:32 <buttons840> dmj: kind of, i'm making a site where people can make a tournament bracket; they will create a new bracket, and get a token they can email (or whatever) and anyone visiting a link with that token can see the bracket -- the goal being to avoid making anyone create an account, the security will just be keeping a link secret, but I think this is fine since there's nothing sensitive people will use it for
20:55:34 <dmj> buttons840: but the fastest way to generate random data would probably be with mwc-random
20:56:13 <dmj> buttons840: ah, I got you, in that case since all you need is the uniqueness property, a UUID may suffice
20:56:33 <buttons840> UUID's are semi guessable aren't they?
20:56:36 <dmj> buttons840: pg has a UUID field as well
20:56:43 <dmj> buttons840: not in this lifetime
20:57:22 <dmj> 50% chance of having a collision after 100 years
20:57:27 <dmj> using 256 exabytes
20:57:39 <dmwit> Having a collision is not the same as guessing.
20:57:42 <buttons840> dmj: some UUID schemes only have a few random characters I thought? the rest of the caracter being determined by host name and time, etc
20:58:08 <glguy> buttons840: No, modern UUIDs are almost completely random
20:58:14 <buttons840> unique is not necissarily the same as hard to guess, and UUID was designed to be unique, but I'm not sure about hard to guess
20:58:18 <nathyong> glguy: dmj: dfeuer: thanks for all your help!
20:58:19 <dmwit> Choosing numbers sequentially will never produce a collision. But if you get an answer from my "sequential" service, it will be very easy for you to guess somebody else's answer.
20:58:41 <pikhq> The UUID schemes are either almost entirely random or entirely deterministic, depending on the scheme.
20:58:50 <dmwit> I don't know enough about UUIDs to say whether they give both properties, though.
20:59:04 <pikhq> If it has any actual randomness at all, though, it's entirely random.
20:59:46 <buttons840> pikhq: so i'd just have to choose the right scheme
20:59:46 <glguy> buttons840: There are a number of generation algorithms for UUIDs, you have to know which one is  being used. 
21:00:50 <dmj> buttons840: you could use a secret key /and/ require a valid session as well, when they click the link. Extra layer of security
21:00:56 <pikhq> The most common non-random scheme involves the time and date + the MAC of the computer.
21:01:00 <dmwit> Looks like these days it's popular to take an easily guessable UUID scheme with a fair bit of randomness in, then hash it to make it basically impossible to guess one UUID given another.
21:01:02 <boj> buttons840: for your purposes i imagine any old uuid will do, heh
21:01:15 <pikhq> That one is quite obviously easily guessable.
21:01:29 <dmwit> Just from a 30-second browse of Wikipedia, though, so take that comment with a grain of salt.
21:01:32 <pikhq> But there's another one which is now quite popular which has 122 bits of entropy.
21:18:12 <dmj> buttons840: you could throttle requests too, for a given IP, on a certain endpoint, making guessing very difficult
21:24:13 <fizbin> Suppose I have a class that applies to types of kind * -> *
21:25:20 <fizbin> Is there a way to require "if given an Ord instance, you return an Ord instance" for instances of this class?
21:26:58 <dmj`> (Ord a, Ord b) => a -> b ? 
21:27:51 <fizbin> Um... maybe I should come up with a concrete example.
21:27:53 <dmj`> fizbin: what do you mean "for instances of this class" ?
21:27:59 <dmj`> is this a different class
21:28:57 <fizbin> So I have a class Foo. Foo is a class whose instances are types of kind * -> *
21:29:40 <fizbin> Now if I wanted to say "to be an instance of Foo, your type must fist be an instance of Monad", that's easy: class (Monad x) => Foo x where ...
21:29:45 <dmwit> fizbin: I think there is an Ord1 class lying around on Hackage somewhere.
21:30:01 <dmwit> Oh, it's even in base.
21:30:04 <dmwit> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Classes.html#t:Ord1
21:31:18 <fizbin> What I want to say is "to be an instance of Foo, your type T must have the property that (T c) is an Ord instance whenever c is an Ord instance"
21:32:46 <geekosaur> only in base for ghc8 / base 4.9 iirc
21:33:41 <fizbin> dmwit: That seems to be reaching toward my problem, but I don't see how to use it.
21:33:44 <MarLinn> something like this? bar :: forall a b (c :: * -> Constraint) f.(c a, c (f b)) => a -> f b
21:36:49 <dmwit> fizbin: Use `liftCompare compare` for whatever you were going to use `compare` for. It has type `(Ord1 f, Ord a) => f a -> f a -> Ordering`.
21:37:17 <dmwit> fizbin: So make `Ord1` a superclass of your class.
21:37:36 <dmwit> fizbin: Then you also have `liftCompare compare :: (YourClass f, Ord a) => f a -> f a -> Ordering`.
21:38:07 <fizbin> dmwit: And if I need to call some library function with an Ord constraint?
21:39:49 <dmwit> newtype, if necessary
21:40:47 <dmwit> newtype UseOrd1 f a = UseOrd1 (f a); instance Ord a => Ord (UseOrd1 f a) where compare (UseOrd1 x) (UseOrd1 y) = liftCompare compare x y
22:26:55 <ongy> :t liftCompare
22:26:57 <lambdabot> error: Variable not in scope: liftCompare
22:28:03 * hackagebot time-parsers 0.1.1.0 - Parsers for types in `time`.  https://hackage.haskell.org/package/time-parsers-0.1.1.0 (phadej)
22:28:05 * hackagebot foldl-statistics 0.1.0.0 - Statistical functions from the statistics package implemented as  Folds.  https://hackage.haskell.org/package/foldl-statistics-0.1.0.0 (AlexMason)
22:59:02 <eklavya> what will happen if the handle is closed and I write to it using hput?
22:59:22 <eklavya> will it throw an exception?
22:59:37 <eklavya> how to find out if some method can throw an exception
22:59:44 <eklavya> hPut docs don't say anything about that
23:01:36 <geekosaur> in general exceptions are not well documented. but if a file is closed, the OS will return an error code and that will be translated to an IOError exception
23:02:06 <eklavya> ok
23:02:20 <joe9> eklavya: check out safe-exceptions?
23:02:21 <geekosaur> sorry IOException https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/Control-Exception-Base.html#t:IOException
23:02:38 <eklavya> do I should just put a bracket/try/etc on all blocks just like Java/Scala ?
23:02:53 <eklavya> joe9: ok
23:03:29 <joe9> eklavya: I was thinking the same and then I read somewhere about how checking for error messages like we do in C is a bad pattern
23:04:34 <eklavya> this mix is not good, maybe exceptions are unavoidable
23:04:37 <joe9> eklavya: I think the program control should not be littered with exception handling code (from what I gathered. the exception handling code should be handled by the caller, etc.)
23:04:42 <eklavya> there should be some type hint
23:05:16 <eklavya> joe9: what do you mean? I am the caller so I have to litter my code, no?
23:05:59 <joe9> eklavya: I cannot recall where I read that article and the exception mechanism made sense after. and, since then I have been feeling that the haskell exception mechanism is awesome.
23:06:37 <eklavya> joe9: how are safe-exceptions different from what is described in Parallel and concurrent programming by Simon Marlow?
23:06:45 <eklavya> what do I gain by using it?
23:09:05 <eklavya> joe9: also please can you give me that article's link if possible?
23:10:25 <joe9> eklavya: did you read the article about safe-exceptions?
23:10:38 <eklavya> which one?
23:10:51 <eklavya> I just found out there is a cookbook on github
23:10:57 <eklavya> are you talking about that?
23:11:22 <eklavya> and there is an article on haskell-lang.org
23:12:12 <eklavya> I am a total newb so if you could tell me what benefits there are to using this over the standard (?) way?
23:13:03 <joe9> eklavya: this seems to be the pattern: http://c2.com/cgi/wiki?LetExceptionsPropagate
23:14:07 <joe9> eklavya: the safe-exceptions distinguish between async and sync exceptions. and make some of the functions safe to handle asynchronous exceptions.
23:15:25 <eklavya> I don't know what that means but I guess it's better than? :P
23:15:28 <joe9> eklavya: https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices#the-bad
23:16:06 <eklavya> whoa
23:16:13 <jle`> a/b 30
23:16:18 <eklavya> it rejects ExceptT IO pattern
23:16:28 <eklavya> that's all over the place
23:16:46 <eklavya> I read it so many times in Haskell codes/books
23:17:01 <eklavya> I did it that way in my project too
23:17:06 <eklavya> is that not good?
23:17:36 <synruby> currently downloading HaskellPlatform-8.0.1-full-x86_64-setup-a.exe
23:18:17 <synruby> im a newb actually
23:19:17 <synruby> 854 KB/s - 149 MB of 229 MB, 1 mins left
23:19:34 <joe9> eklavya: https://haskell-lang.org/tutorial/exception-safety
23:19:39 <joe9> eklavya: seen that too?
23:20:15 <eklavya_> I think it's even mentioned in the haskell programming book
23:21:17 <hamme> Yeah, there's a chapter on exceptions, not sure if there's a full discussion of this or that kind of exceptions
23:21:28 <hamme> Typed, not typed, what kind of generalisation...
23:21:38 <eklavya_> no I mean it says use ExceptT IO
23:21:46 <eklavya_> (I think)
23:21:47 <hamme> Uh
23:21:49 <hamme> No
23:22:01 <hamme> It says ExceptT IO is an anti-pattern
23:22:08 <eklavya_> it does?
23:22:15 <eklavya_> let me re read that part
23:22:36 <eklavya_> I imagine I saw it being discussed as used commonly in haskell projects
23:22:40 <eklavya_> or something like that
23:22:40 <hamme> -> https://www.schoolofhaskell.com/user/commercial/content/
23:22:47 <hamme> -> exceptions-best-practices#exceptt-io-anti-pattern
23:23:07 <eklavya_> I was talking about the "the haskell programming book"
23:23:09 <joe9> eklavya_: yes, I found that my library became a lot more easier to understand once I removed the ExceptT IO pattern.
23:23:36 <hamme> I'm curious what many forms of "slightly better exceptions" there are
23:23:52 <hamme> (later, not now, gotta do them chapters)
23:23:58 <akegalj> if I have imported something in ghci, how can I hide this import ?
23:24:17 <hamme> uh :m -<import>
23:24:49 <akegalj> hamme: thank you <3
23:25:00 <hamme> Or if it's an import of a loaded file, then you may need to make the source file not export that import, akegalj 
23:25:16 <akegalj> hamme: no, this is exactly what I wanted
23:25:31 <hamme> alternatively, but this'll wipe all imports other than the loaded file, use :r
23:25:49 <hamme> What's good, synruby 
23:27:19 <joe9> eklavya_: the gist I got was to not change your program flow for exceptions. Exceptions are "Exceptions" and should not be "regular program flow". They should be treated by the caller as only the caller would know what to do when a certain exception occurs. such as retry or exit, etc.
23:27:19 <hamme> There's someone currently active in #haskell-beginners
23:27:26 <hamme> ski 
23:27:46 <ski> hamme : there is ?
23:27:57 <hamme> you are them, ski 
23:28:05 <ski> oh .. i see
23:28:11 <hamme> can you help synruby , they are downloading haskell platform, and have no idea what to do
23:28:42 <joe9> eklavya_: the callee would not know what to do with an exception as he would not know the whole context or importance of his task.
23:28:44 <hamme> [I use stack, because I had no idea what I was doing :^)]
23:28:53 <joe9> eklavya: does that make sense?
23:28:54 * ski deosn't know much about haskell platform problems
23:29:02 <eklavya> joe9: yes
23:29:19 <hamme> I tihnk it's more of a "newb with no idea what to do" problem, ski
23:30:21 <joe9> eklavya: that changed my thinking to realize why checking for exceptions after every statement is an anti-pattern.
23:30:51 * ski hasn't seen synruby declaring a problem, yet
23:31:01 <hamme> I uh
23:31:02 <hamme> noticed that
23:31:04 <hamme> quickly
23:31:07 <hamme> whoops
23:33:39 <eklavya_> joe9: is there any talk/article about MonadIO/MonadThrow and the likes?
23:33:52 <eklavya_> sorry my network is hating me right now
23:34:00 <eklavya_> I don't know if you have been replying :(
23:34:01 <hamme> A few months ago, there were several reddit threads about exceptions
23:34:09 <hamme> It comes in phases
23:34:16 <eklavya_> :D
23:35:10 <joe9> eklavya_:  I vaguely recall reading about MonadThrow and why it is not a great idea. I do not recall the details. I felt that throwM of Control.Exception.Safe was good enough for my needs and I left it ath.
23:35:15 <joe9> s/ath/that/
23:35:24 <eklavya_> wait
23:35:25 <eklavya_> what
23:35:29 <eklavya_> oh man
23:35:51 <eklavya_> MonadIO is in a different group from MonadThrow?
23:36:05 <joe9> eklavya_: I think I read that when building a library, you want to have the library functions to be without the transformer stack, etc.
23:36:15 <eklavya_> that article says use MonadThrow
23:37:00 <joe9> eklavya_: for flexibility and ease of use. When I started using just an IO for my library functions, throwM or throwIO was sufficient for my needs.
23:37:24 <eklavya_> joe9: well, I don't want to throw at all
23:38:01 <eklavya_> it will take me forever to learn haskell it seems
23:38:48 <eklavya_> well I can always write working sub optimal, non standard code :D
23:39:01 <eklavya_> and improve when I understand
23:39:26 <joe9> eklavya_: interesting, why not? anyway , this was another article that helped me http://neilmitchell.blogspot.com/2015/05/handling-control-c-in-haskell.html
23:39:54 <eklavya_> joe9: I am not saying that specifically for exceptions
23:40:10 <eklavya_> I got to know today that ExceptT IO (which is everywhere) is bad
23:40:13 <joe9> eklavya_: you have seen these 3 articles, I presume: http://learnyouahaskell.com/input-and-output#exceptions , https://haskell-lang.org/tutorial/exception-safety , https://haskell-lang.org/library/safe-exceptions
23:40:37 <eklavya_> not the first one
23:40:39 <eklavya_> but the rest two
23:40:40 <eklavya_> yes
23:41:14 <hamme> When did haskell.org move to hask-lang.org
23:41:46 <eklavya_> never
23:42:06 <eklavya_> different websites
23:42:18 <hamme> When did let data Voi in Void move to haskell-lang.org
23:42:31 <hamme> Voi*
23:42:36 <joe9> eklavya_: From my personal experience, https://github.com/joe9/streaming-betfair-api/commit/7529aaa2f152bf9ec2082b09c676118f15f9fc14 see how simple the function calls became after removing the ExceptT IO pattern.
23:43:08 <synruby> hamme, hi
23:43:28 <hamme> Hello
23:43:38 <synruby> are you a brogrammer?
23:43:43 <hamme> I'm a goober
23:43:57 <hamme> An oscar mayer weiner
23:44:05 <Axman6> @where ops
23:44:05 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
23:44:09 <hamme> (check's in the mail for this advertisement)
23:44:47 <eklavya_> joe9: so, you replaced ExceptT IO with a plain IO?
23:44:57 <eklavya_> where's that MonadIO thingy?
23:45:00 <Axman6> your particular form of trolling is pretty ineffective hamme, I'm curious what you get out of doing it
23:45:01 <joe9> eklavya_: yes
23:45:14 <hamme> I'm an idiot, Axman6 
23:45:24 <hamme> And excitable
23:45:30 <joe9> eklavya_:  not there. I did not use MonadIO
23:45:43 <joe9> eklavya_: just read about it.
23:46:11 <dibblego> hamme: immediately expedite discontinuance
23:46:28 <hamme> ok
23:48:42 <eklavya> joe9: the network is really bad today, sorry
23:48:47 <eklavya> I hope I can catch you later
23:48:54 <joe9> eklav
23:49:05 <joe9> eklavya: no need to be sorry. good luck.
23:49:12 <eklavya> it's impossible to have a discussion today
23:49:19 <hamme> I see a lot of ExceptT and code being removed int he diff, is the MonadThrow in Context a, or is this just using the MonadThrow in IO
23:49:20 <eklavya> it just keeps dropping
23:49:25 <joe9> eklavya: there was an article differentiating the lisp exception model vs C
23:50:21 <joe9> eklavya: and, after reading that, I realized that the haskell exception handling mechanism is closer to the lisp model.
23:50:52 <ski> no restartable conditions .. :(
23:52:18 <joe9> eklavya: and, it made sense. The ExceptT IO pattern fails when you realize that there could be a Ctrl-C happening at any piece of code. Next thing, you know every line of code should have a ExceptT for handling the asynchronous exception.
23:52:39 <eklavya> in your commit
23:52:46 <eklavya> you have replaced it with simple IO
23:53:05 <eklavya> but there is no MonadIO in the signature
23:53:15 --- mode: ChanServ set +o edwardk
23:53:24 --- kick: hamme was kicked by edwardk (hamme)
23:53:24 --- mode: edwardk set +b hamme!*@*
23:53:34 <joe9> eklavya: realized that IO was good enough for my purposes. I did not need MonadIO
23:53:40 --- mode: edwardk set -o edwardk
23:53:46 <eklavya> are you saying IO should throw when it wants and we should just wrap it in bracket?
23:54:21 <joe9> eklavya: the caller wraps it in a bracket.
23:55:19 <joe9> eklavya:  or, recovers from it and does something else.
23:55:39 <joe9> s,or,and/or,
23:56:17 <eklavya> understoof
23:56:27 <eklavya> and that is a good practice?
23:56:47 <joe9> eklavya: http://schemer.in/aeh.html
23:57:40 <eklavya> hmm
23:57:51 <eklavya> let me see if I can remove the ExceptT parts
23:58:00 <eklavya> also throwM is MonadThrow, right?
23:58:40 <eklavya> also even Servant uses ExceptT, is it really bad?
23:59:47 <joe9> eklavya: this article seems better http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html
