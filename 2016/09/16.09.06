00:04:12 <Gribo> Is there a reason as to why one would use Int instead of Integer?
00:04:46 <Reshi> Gribo: Size, Integer is unbounded
00:05:09 <Gribo> Reshi, So performance?
00:06:01 <EvanR> you would want to use Integer because its unbounded
00:06:12 <Gribo> Yeah but why would you use Int?
00:06:13 <EvanR> you want to use Int because the stdlib usually uses it
00:06:17 <Reshi> Gribo: Yeah, if you know you won't require integers bigger than your machine int size, then you could stick with Int
00:06:18 <Gribo> Ah.
00:06:55 <EvanR> if youre doing FFI to C, then Int simplifies passing ints
00:07:11 <Gribo> I don't know what that is but I'm certainly not doing it.
00:07:17 <Axman6> Ints ususlly optimise better, and can be unboxed into registers. they also have a fixed size so they're more suitable for serialisation/storing in flat memory
00:07:36 <alphonse23_> Does anybody remember this line of code from "Learn you a Haskell"?
00:07:37 <Gribo> I don't understand most of what that means, Axman6.
00:07:41 <alphonse23_> infixr 5 :-:  
00:07:41 <alphonse23_> data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)  
00:08:02 <alphonse23_> it's from this chapter: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
00:08:12 <quchen> alphonse23_: Sure, that’s a valid list type definition.
00:08:15 <cocreature> alphonse23_: just ask the question you have directly :)
00:08:15 <alphonse23_> when I stick it into GHCi it doesn't work
00:08:18 <Axman6> Gribo: Ints fir in registers, Integers don't (always)
00:08:31 <Axman6> can you define types in GHCi?
00:08:48 <alphonse23_> what is the :-: operator?
00:08:56 <quchen> To define things in GHCi, you have to use ‘let’
00:09:02 <alphonse23_> and can't find where it's defined anywhere in the book.
00:09:15 <quchen> You can also write it in a file and then :l that file.
00:09:16 <Axman6> alphonse23_: it's an infix data constructor, and that is its definition
00:09:27 <Reshi> alphonse23_: Not an operator, its an infix Data constructor you are making
00:09:36 <Axman6> just like how (:) is defined in data [a] = [] | a : [a]
00:09:48 <wedify> Axman6: yes you can define types in ghci
00:09:53 <alphonse23_> k, here's what happens though when I put it into ghci:
00:09:56 <alphonse23_> :{
00:09:56 <alphonse23_> Prelude| let infixr 5 :-:
00:09:56 <alphonse23_> Prelude|     data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
00:09:56 <alphonse23_> Prelude| :}
00:09:56 <alphonse23_> <interactive>:81:1:
00:09:57 <alphonse23_>     parse error in let binding: missing required 'in'
00:09:57 <alphonse23_> Prelude>
00:10:16 <alphonse23_> is it not aligned correctly?
00:10:20 <Axman6> hmm, does indentation matter? try removing those spaces
00:10:46 <quchen> You should really put this into a file.
00:10:47 <Reshi> alphonse23_: that line works in my ghc
00:10:54 <alphonse23_> same error: parse error in let binding: missing required 'in'
00:11:03 <Reshi> without let
00:11:05 <Axman6> which version of ghci?
00:11:16 <cocreature> it looks like infixr causes problems in ghci
00:11:17 <alphonse23_> how do you check the version?
00:11:31 <wedify> the fixity declaration is not accepted though
00:12:04 <Reshi> works in ghci 7.10, without let-> data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
00:12:10 <Reshi> 7.10.3
00:12:21 <alphonse23_>  ghc --version
00:12:21 <alphonse23_> The Glorious Glasgow Haskell Compilation System, version 7.10.2
00:12:55 <alphonse23_> so try it without let
00:13:33 <cocreature> alphonse23_: in general ghci behaves a bit weird and the differences between the syntax accepted by ghci and ghc can be confusing so I recommend writing your code in a normal .hs file and only loading that in ghci
00:13:49 <Axman6> cocreature++
00:13:52 <alphonse23_> what I get without the let <interactive>:93:1: parse error on input ‘infixr’
00:14:10 <cocreature> I don’t think you can use the fixity specification in ghci
00:14:13 <Axman6> yeah ghci probably doesn't accept fixity annotations
00:14:16 <alphonse23_> well, that's a bit round about isn't it. I'm just rereading Learn you a Haskell...
00:14:44 <wedify> alphonse23_: yeah it is weird
00:15:02 <alphonse23_> from the chapter, isn't :-: like a Cons operator?
00:15:11 <wedify> yes
00:15:19 <alphonse23_> but it's right associative
00:15:30 <Axman6> it is if you define its fixity
00:15:57 <Axman6> wihtout the infixr line, it isn't associative, so you get: Prelude> 1 :-: 2 :-: Empty
00:16:17 <Axman6> <some error about Non type-variable argument in the constraint>
00:16:34 <Axman6> so you explicitly need to write 1 :-: (2 :-: Empty)
00:16:56 * hackagebot relational-record 0.1.5.1 - Meta package of Relational Record  https://hackage.haskell.org/package/relational-record-0.1.5.1 (KeiHibino)
00:16:58 * hackagebot ddc-core 0.4.3.1 - Disciplined Disciple Compiler core language and type checker.  https://hackage.haskell.org/package/ddc-core-0.4.3.1 (BenLippmeier)
00:17:00 * hackagebot ddc-core-simpl 0.4.3.1 - Disciplined Disciple Compiler code transformations.  https://hackage.haskell.org/package/ddc-core-simpl-0.4.3.1 (BenLippmeier)
00:17:02 * hackagebot ddc-core-salt 0.4.3.1 - Disciplined Disciple Compiler C code generator.  https://hackage.haskell.org/package/ddc-core-salt-0.4.3.1 (BenLippmeier)
00:17:04 * hackagebot ddc-core-llvm 0.4.3.1 - Disciplined Disciple Compiler LLVM code generator.  https://hackage.haskell.org/package/ddc-core-llvm-0.4.3.1 (BenLippmeier)
00:17:16 <MarLinn> you can define fixity in ghci, but it must be on the same line
00:17:36 <MarLinn> data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord); infixr 5 :-:
00:19:00 <Axman6> oh nice
00:19:04 <Axman6> MarLinn++
00:19:28 <alphonse23_> That didn't produce any errors: MarLinn
00:19:40 <alphonse23_> but I still got this error when running the example from the book:
00:19:43 <alphonse23_> Prelude> 3 :-: 4 :-: 5 :-: Empty
00:19:43 <alphonse23_> <interactive>:102:1:
00:19:43 <alphonse23_>     Non type-variable argument in the constraint: Num (List a)
00:19:43 <alphonse23_>     (Use FlexibleContexts to permit this)
00:19:43 <alphonse23_>     When checking that ‘it’ has the inferred type
00:19:43 <alphonse23_>       it :: forall a.
00:19:43 <alphonse23_>             (Num a, Num (List a), Num (List (List a))) =>
00:19:44 <alphonse23_>             List (List (List a))
00:20:29 <Axman6> yeah I get the same thing, that doesn't seem to work MarLinn 
00:20:39 <ongy> maybe ghc version?
00:20:50 <ongy> works for me on ghc-8
00:20:57 <Axman6> doesn't work in 7.10
00:20:59 <MarLinn> that's... weird... why would it be accepted but non-working
00:21:46 <wedify> it works for me but i did the infixr first
00:22:06 * hackagebot ddc-core-tetra 0.4.3.1 - Disciplined Disciple Compiler intermediate language.  https://hackage.haskell.org/package/ddc-core-tetra-0.4.3.1 (BenLippmeier)
00:22:08 * hackagebot ddc-core-flow 0.4.3.1 - Disciplined Disciple Compiler data flow compiler.  https://hackage.haskell.org/package/ddc-core-flow-0.4.3.1 (BenLippmeier)
00:22:46 <wedify> actually it works both ways for me
00:22:58 <alphonse23_> so is it a difference in version between 7.10.2 and 7.10.3
00:23:31 <wedify> ghc 8.0.1
00:24:17 <alphonse23_> and 8.0.1
00:24:29 <alphonse23_> oh well. So should I just try updating to 8.0.1
00:24:43 <alphonse23_> that means it's a known bug right?
00:25:34 <MarLinn> workaround: fixity seems to be working for normal functions, so maybe just create :-: as an alias for a constructor
00:26:39 <alphonse23_> how do you do that?
00:27:39 <wedify> MarLinn: I don't think you can. operators beginning with ':' are infix constructors
00:28:01 <Axman6> not so much a bug, but a feature that hadn't been implemented yet, being able to define data types in GHCi is a very recent addition
00:28:17 <Axman6> the fixity thing is pretty annoying, but obviously fixed
00:29:28 <alphonse23_> so is there a ticket on trac to implement it? just asking out of curiosity. I'm a little familary with ghc's processes, but only recently.
00:29:54 <MarLinn> ugh... fixity also seems to choke when the function starts with a colon...
00:30:46 <wedify> alphonse23_: you have two choices i think, upgrade to ghc 8 or use Cons a (List a) instead of :-:
00:31:12 <wedify> well, three. write it in a file and load it
00:31:23 <cocreature> which is by far the easiest option
00:31:27 <alphonse23_> I used Cons a (list a) instead
00:31:40 <alphonse23_> and I got everything to work
00:32:30 <alphonse23_> but it's a big crux for haskell beginners that while reading learn you a haskell, the code printed in the book doesn't work immediately through ghci
00:33:06 <alphonse23_> and I only kinda understand Cons because this is my second time reading it.
00:33:09 <hackesharp> I'm reading "learn you a haskell" right now, that has definitely been a problem
00:33:25 <Axman6> it hasn't introduced how to write this stuff in a file and load it?
00:33:57 <hackesharp> It wasn't obvious at first
00:35:04 <alphonse23_> it doesn't, but that doesn't happen until the next chapter. :/
00:35:04 <hackesharp> Still glad I'm learning haskell though
00:35:29 <alphonse23_> I mean it does, but it doesn't until the chapter after the :-: stuff
00:35:35 <Reshi> Yeah, the snippets runnable in ghci have the prefix ghci> in the chapters
00:36:02 <alphonse23_> so it's confusing, and it shows you pretty much have to read it mulitple times, since there are circular dependencies...
00:37:48 <alphonse23_> it's kind of strange to that haskell differs between what happens when you load something from a file and what happens in it's REPL.
00:38:20 <quchen> alphonse23_: For me, reading technical books is most often like hammering in a nail. You have some progress, but then you need to reiterate from the beginning, this time getting a bit further. So don’t despair :-)
00:39:06 <ent> I'm not sure if hammering nails is like that
00:39:34 <chreekat> I've also been confused by ghci setting things differently from ghc. I seem to have glommed on to most of the differences, now, but I have to wonder if there are some I haven't figured out yet...
00:40:47 <Reshi> REPL also is generally for evaluating single expressions, where as a full program is not just an expression.
00:41:31 <hackesharp> You could argue that a single expression is a program, just not a very useful one.
00:42:09 <Gribo> Does anyone know a good theoretical book on functional programming?
00:42:25 <alphonse23_> would it be worth while to remember these problems with fixity, incase it would be worthwhile to mention this to the ghc developers?
00:42:30 <quchen> Gribo: Depends on your focus. 
00:42:57 <quchen> Tapl by Pierce is a fairly good intro to FP concepts.
00:42:59 <Gribo> quchen, I'd like to have a deep understanding of it.
00:43:00 <ski> definitions =/= expressions
00:43:19 <ski> @where TaPL
00:43:19 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
00:43:24 <intothem1untains> Is there something like iterateUntilM but that checks for the condition after taking a step?
00:43:52 <LordBrain> there's a lot of stuff in the monad-loops package, did you browse it?
00:44:02 <Gribo> quchen ski, is it a hard read?
00:44:07 <quchen> No.
00:44:15 <Cale> intothem1untains: Generally I find that even before one gets to things like iterateUntilM, just writing a recursive loop ends up being clearer.
00:44:18 <Gribo> Alright great, just what I was looking for then.
00:44:34 <quchen> I think it’s fairly easy to read (given that it’s a book about a technical subject).
00:44:37 <LordBrain> intothem1untains, did you check monad-loops package?
00:44:38 <ski> alphonse23_ : .. it's the same in Prolog interactors/RPPLs (Read-Prove(/Solve)-Print-Loops)
00:44:48 <quchen> I also enjyed Thompson, which is more theoretical than Tapl. https://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
00:44:54 <intothem1untains> LordBrain: yes, iterateUntilM is from there
00:45:10 <ski> Gribo : TaPL is about types and type systems
00:45:33 <lpaste> YellowOnion pasted “polymorphic trees.” at http://lpaste.net/185186
00:45:48 <Cale> Yeah, for the most part, monad-loops is a bit overboard -- it becomes difficult to remember the differences between all the variations on the loops.
00:46:15 <ski> Gribo : it's not clear whether by "FP concepts" you had types in mind, or something else
00:46:31 <intothem1untains> This like untilJust are awesome though
00:46:31 <ski> some people like SICP ..
00:46:57 <wedify> alphonse23_: you can shoot bonus@learnyouahaskell.com an email. reference this chat. i'm sure they'd be interested to hear of these issues
00:47:15 <Gribo> ski, Well it doesn't need to be restricted to FP. I have very little "academic" knowledge about programming languages.
00:47:31 * ski idly wonders how long it was since BONUS frequented the channel
00:47:42 <YellowOnion> as to the lpaste, I'm trying to make a k-d Tree which can store /any/ type of value that has a specific property (something like duck typing.)
00:48:15 <Gribo> Basically I want to understand all these concepts that people like Simon Peyton and Carmack mention when talking about FP and programming
00:48:30 <alphonse23_> @wedify there's lot of these problems through out the book though. And isn't this more of a problem with ghc/ghci? And I think the author of LYAH probably doesn't care if his code works in GHCi or not, other wise he would have mentioned how to use :{ }: brackets and lets.
00:48:30 <lambdabot> Unknown command, try @list
00:48:44 <ski> Gribo : a working familiarity with the lambda calculus, as well as familiarity with equational reasoning (including induction) could possibly help
00:48:49 <intothem1untains> is it possible to use guards inside do notation?
00:49:13 <liste> :t when -- intothem1untains 
00:49:14 <ski> @type guard  -- intothem1untains
00:49:15 <lambdabot> Applicative f => Bool -> f () -> f ()
00:49:15 <YellowOnion> in the case of a kd tree things I store in side it needs to have a position.
00:49:16 <lambdabot> Alternative f => Bool -> f ()
00:49:27 <Cale> alphonse23_: I forget exactly the timing of it, but it is entirely possible that when LYAH was written, neither of those features were in GHCi
00:49:51 <LordBrain> intothem1untains, could fall back to the old 'fix' approach
00:49:55 <Gribo> Oh SICP, I've seen this cover a lot.
00:50:06 <ski> @where SICP
00:50:06 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized
00:50:06 <lambdabot> Packages"
00:50:19 <dmiles> i been trying to see if any event calculus programs exist in haskell
00:50:38 <ski> hello dmiles :)
00:51:04 <dmiles> hi.. of course your saying of Prolog trigger my attention
00:51:09 <dmiles> :)
00:52:07 <ski> YellowOnion : do you intend the `_position' field to contain a polymorphic value ?
00:52:32 <alphonse23_> k, copied a transcript of the conversation here, I'll send it to  bonus@learnyouahaskell.com , to see if he cares. Otherwise, I could also see if anybody cares on the GHC mailing list.
00:52:37 <ski> dmiles : any source for "event calculus" ?
00:52:50 <Cale> alphonse23_: hmm, GHC 7.0.1 introduced :{ and that was out in November 2010. LYAH was published in 2011, but I don't know what month.
00:53:27 <Cale> alphonse23_: I dunno, BONUS kinda disappeared after publishing the book
00:53:56 <YellowOnion> ski, it can be a float or a double, but the issue is the kd tree, line 10, I don't know how to contruct such a type. something is hinting GADTs
00:55:06 <ski> YellowOnion : i'm not convinced `_position' is declared to express what you want
00:56:01 <dmiles> ski:  well actualy i lump situalion calculus and even calculus together so pragmatically i was refering to https://en.wikipedia.org/wiki/Situation_calculus
00:56:09 <dmiles> sitcal and evntcalc
00:56:19 <YellowOnion> ski, I want to expression a point in 3D space? is that not correct?
00:57:16 <dmiles> sitcalc and eventcalc  .. event calc usualyl though is more about how time divides things ..  sitcalc tends to also havbe to take on teh eventcalc domains
00:58:11 <ski> YellowOnion : are you sure `data System = ...' shouldn't be `data System a = ...' ?
00:58:47 <dmiles> i think the problem is these domains expect to be too dynamic and things like compilation in haskell inst optimizaing them 
00:58:56 <ski> YellowOnion : then you could use `System a' as type of `point'
00:59:01 <intothem1untains> ski, liste: sorry for the stupid question, but how do I use those
00:59:02 <intothem1untains> ?
00:59:20 <dmiles> (cant be expected to optimizae the situations so not much incentive to show examples in haskell)
01:00:57 <YellowOnion> ski, I think you miss understand, the System type is an example of what I want to put inside the kdtree, (I made a typo with the type)
01:01:32 <liste> > do { putStrLn "hi"; when (2 > 1) (putStrLn "world")} -- intothem1untains 
01:01:35 <lambdabot>  <IO ()>
01:02:27 <dmiles> the reason i was asking about EventCalc and SitCalc in #haskell is i was commmouing up short finding expamples.. I was going to use it as an excuse to finnaly learn Haskell
01:02:41 <intothem1untains> liste: cheers!
01:02:50 <Insanity_> is "elem" the best way to check if a list contains an element?
01:03:17 <YellowOnion> ski, I guess the best way I can describe my problem that perhaps I want the point to be anything that has a Typeclass of "Positionable"
01:03:29 <wedify> alphonse23_: the text you originally came to us works if you leave out the let and put a semicolon after the fixity declaration
01:03:55 <alphonse23_> yah, but I still get an error when I try out :-:
01:03:59 <Cale> dmiles: I don't know, it looks like the sort of thing that Haskell would do just fine at if anyone cared to implement it. This is the first I've heard of either of them, myself.
01:04:19 <dmiles> one of the groups of Interactive Fiction programmers are explaoring as to which programming language well use for the system
01:04:25 <alphonse23_> let me try updating to 8.0, to see if that fixes things.
01:04:30 <ski> YellowOnion : perhaps try `data KdTree v a = Positionable a => KdNode {...} | KdEmpty'
01:05:01 <dmiles> so we were tinking of starting with https://hackage.haskell.org/package/atp-haskell
01:05:03 <Cale> dmiles: It looks slightly related to the FRP systems that various people have worked on, though the general approach is different.
01:05:06 <ski> Insanity_ : unless you know more about the list (e.g. that it is ordered), yes
01:05:28 <ski> intothem1untains : also `unless'
01:05:53 <Cale> dmiles: Fluents in the situation calculus look somewhat like behaviours in FRP to me.
01:05:55 <Insanity_> I have to check for a large deal of numbers, if they are prime. I'm doubting between using an "isPrime" for each number, or just looking them up in a pre-generated list
01:07:18 <dmiles> Cale: yeah Fluents are somewhat behavoural .. they can be a result of mother nature or physics or the result of agents intentional try to create some outcome state
01:07:59 <ski> Insanity_ : with a definite upper bound ?
01:08:00 <intothem1untains> ski: is there something similar to if-then-else?
01:08:13 <ski> intothem1untains : yes, `if'-`then'-`else'
01:08:20 <intothem1untains> :S
01:08:24 <Insanity_> Yeah ski, primes below 10^8
01:08:57 <liste> > do { if 2 > 1 then (putStrLn "yep") else (putStrLn "nay"); putStrLn "all done" }
01:08:59 <lambdabot>  <IO ()>
01:09:03 <ski> Insanity_ : perhaps you could consider building a large table
01:09:30 <ski> liste : redundant brackets detected
01:09:35 <Insanity_> A question about how lists work though, if I have something in the "where" statement, is that list evaluated for each run?
01:09:39 <YellowOnion> ski, I mean I'm not asking how to write out a type signature there's plenty of resources to do that, my problem is in the implementation.
01:10:10 <Cale> Insanity_: Whatever part of the list is needed will be evaluated each time
01:10:19 <ski> Insanity_ : nothing to do with lists. it depends on whether the `where' attaches to a function definition or not
01:10:23 <Cale> (and only when it is needed)
01:11:07 <Insanity_> I see.. Well, so I'm going to compare it to Java. Is it possible to have a "class variable" which would be the list of primes. So I wouldn't have to create the list each time anew
01:11:14 <ski> YellowOnion : did you try my suggestion ?
01:11:16 <Cale> 'where' doesn't actually cause evaluation, it just defines things locally. Each time you apply the function that the where clause is in, you'll get a new thing defined.
01:11:44 <Cale> Insanity_: If you want that, just lift the definition out of the where clause
01:11:49 <Insanity_> That is probably quite bad for the performance of the prime-list approach :P
01:12:12 <Cale> Insanity_: Well, it's quite good for its space performance
01:12:24 <Insanity_> That is true, but I'm trying to decrease runtime at the moment
01:12:31 <ski> Insanity_ : since the list is probably ordered, you probably don't want to use `elem' with it
01:12:36 <Insanity_> it's for one of the projecteuler challenges, which aim to get runtime below 1 min
01:12:43 <Cale> ah
01:12:49 <Insanity_> The solution I have works - but is just incredibly slow
01:12:49 <Cale> Which problem btw?
01:12:56 <Insanity_> 357
01:12:58 <ski> Insanity_ : you can also consider using another data structure than a list
01:13:12 <alphonse23_> is the only way to unstall ghc 8.0.1 is by downloading it? it's not registered with any of package managers?
01:13:23 <alphonse23_> *install ghc 8.0.1
01:13:37 <liste> alphonse23_: you can install it with stack
01:13:42 <ski> YellowOnion : by "the implementation", you mean how to declare the data type, yes ?
01:14:00 <Insanity_> Yeah ski, but I'm quite new to haskell and I haven't really seen a wide variety yet.. Mostly lists, tuples
01:14:22 <Insanity_> Cale: https://projecteuler.net/problem=357
01:14:27 <ski> Insanity_ : perhaps you could try arrays
01:14:30 <Cale> Insanity_: Yeah, found it.
01:14:47 <Cale> hmm
01:15:23 <alphonse23_> k, trying that liste:
01:15:40 <Cale> So if n has a repeated prime factor, say p^2 divides n. Then p divides n/p, and so p divides p + n/p
01:15:43 <Insanity_> Looking into arrays now ski
01:16:11 <ski> YellowOnion : .. anyway, i don't see anything polymorphic about your `KdTree' type
01:16:58 <Cale> However, p + n/p is not equal to p, and so it must be reducible.
01:17:08 <ski> Insanity_ : there's both immutable and mutable arrays. in your case, one could perhaps try an immutable array of `Bool's
01:17:10 <Cale> (which implies it's not prime)
01:17:16 <LordBrain> intothem1untains, you asked for somethign similar to if-then-else, if you mean a function form without the 'else' keyword in there, then there is Data.Bool.bool
01:17:27 <Cale> So any n having a repeated prime factor is excluded
01:17:37 <LordBrain> :t bool
01:17:39 <lambdabot> a -> a -> Bool -> a
01:17:53 <ski> @src bool
01:17:53 <lambdabot> bool f _ False = f
01:17:53 <lambdabot> bool _ t True  = t
01:17:57 * hackagebot ddc-core-babel 0.4.3.1 - Disciplined Disciple Compiler PHP code generator.  https://hackage.haskell.org/package/ddc-core-babel-0.4.3.1 (BenLippmeier)
01:17:59 * hackagebot ddc-source-tetra 0.4.3.1 - Disciplined Disciple Compiler source language.  https://hackage.haskell.org/package/ddc-source-tetra-0.4.3.1 (BenLippmeier)
01:18:01 * hackagebot ddc-build 0.4.3.1 - Disciplined Disciple Compiler build framework.  https://hackage.haskell.org/package/ddc-build-0.4.3.1 (BenLippmeier)
01:18:03 * hackagebot ddc-driver 0.4.3.1 - Disciplined Disciple Compiler top-level driver.  https://hackage.haskell.org/package/ddc-driver-0.4.3.1 (BenLippmeier)
01:18:05 * hackagebot ddc-code 0.4.3.1 - Disciplined Disciple Compiler base libraries.  https://hackage.haskell.org/package/ddc-code-0.4.3.1 (BenLippmeier)
01:18:10 <Insanity_> Thanks for the help Cale & ski 
01:18:19 * ski . o O ( "PHP code generator" ? )
01:18:29 <YellowOnion> ski, Thats the exact point, I want it polymorphic, I want it to have a point that can be /anything/ that has the property of a position in space, I want duck typing or what ever it's called, and I don't know how that is implemented.
01:19:03 <ski> YellowOnion : except that isn't polymorphic
01:19:56 <ski> (at least not in the sense of parametric polymorphism, which is what "polymorphic", unqualified, means in Haskell, and most FP contexts)
01:20:20 * ski still wonders whether YellowOnion tried the suggestion
01:21:41 <Cale> I wonder if there's a nice one-liner to compute the infinite list of Möbius numbers
01:22:26 <srhb> @oeis möbius
01:22:28 <lambdabot>  Sequence not found.
01:22:31 <srhb> aw
01:22:36 <Cale> https://en.wikipedia.org/wiki/M%C3%B6bius_function
01:22:51 <YellowOnion> ski, No I haven't tried the suggestion yet.
01:23:02 <srhb> @oeis A008683
01:23:04 <lambdabot>  https://oeis.org/A008683 Möbius (or Moebius) function mu(n). mu(1) = 1; mu(n...
01:23:04 <lambdabot>  [1,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,0,1,1...
01:23:07 * hackagebot ddc-tools 0.4.3.1 - Disciplined Disciple Compiler command line tools.  https://hackage.haskell.org/package/ddc-tools-0.4.3.1 (BenLippmeier)
01:23:08 <srhb> Aha!
01:23:33 <ski> oh, Möbius inversion ?
01:23:39 <Cale> oh, interesting, lambdabot took the absolute value
01:23:42 <Cale> heh
01:38:31 <lpaste> wedify pasted “why doesn't this stop?” at http://lpaste.net/185233
01:39:22 <quchen> wedify: foldl' never terminates when you fold an infinite list.
01:41:21 <wedify> quchen: how do i make it lazy?
01:42:13 <quchen> foldr allows generating data structures lazily.
01:42:41 <quchen> foldl for lists has to consume the entire list, and is usually used for summaries of lists, not for building up data structures.
01:42:55 <quchen> sum is an example of something you might want to implement with a foldl', not a foldr.
01:43:37 <lyxia> wedify: check out scanl
01:44:31 <lyxia> > scanl 0 [1..]
01:44:33 <lambdabot>  error:
01:44:34 <lambdabot>      • No instance for (Typeable a0)
01:44:34 <lambdabot>          arising from a use of ‘show_M477746585227119663526999’
01:45:45 <lyxia> > take 100 (scanl (+) 0 [1 ..]) :: [Int]
01:45:48 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
01:47:13 <wedify> lyxia: thanks
01:49:38 <hackesharp> > take 10 (cycle "HELLO")
01:49:40 <lambdabot>  "HELLOHELLO"
01:49:43 <hackesharp> huh
01:58:54 <Insanity_> huh? :p
01:59:41 <Insanity_> > take (length "HELLO"*10) (cycle "HELLO")
01:59:43 <lambdabot>  "HELLOHELLOHELLOHELLOHELLOHELLOHELLOHELLOHELLOHELLO"
02:00:03 <hackesharp> > take (5 * 10) (cycle "What?")
02:00:05 <lambdabot>  "What?What?What?What?What?What?What?What?What?What?"
02:00:35 <lyxia> There's echo in this room.
02:00:54 <hackesharp> echo "Hello"
02:00:57 <hackesharp> dang
02:01:49 <tracysmith> Hello
02:01:59 <ski> goodbye
02:02:23 <Gribo> is lambdabot open source?
02:02:35 <hackesharp> I was just wondering that
02:02:44 <ski> @version
02:02:44 <lambdabot> lambdabot 5.1
02:02:44 <lambdabot> git clone https://github.com/lambdabot/lambdabot
02:02:51 <Gribo> thanks
02:18:58 * hackagebot synthesizer-llvm 0.8.1 - Efficient signal processing using runtime compilation  https://hackage.haskell.org/package/synthesizer-llvm-0.8.1 (HenningThielemann)
02:19:00 * hackagebot ddc-code 0.4.3.2 - Disciplined Disciple Compiler base libraries.  https://hackage.haskell.org/package/ddc-code-0.4.3.2 (BenLippmeier)
02:19:19 <hackesharp> > :t (==)
02:19:21 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:19:30 <Insanity_> :t (==)
02:19:31 <lambdabot> Eq a => a -> a -> Bool
02:19:36 <hackesharp> there ya go
02:19:54 <Insanity_> ;)
02:27:23 <minad> Hi, has anyone used multiplate? It seems that it subsumes uniplate in principle. But I am missing some kind of generic/derive/th mechanism, is there something?
02:30:58 <tracysmith> what is multiplate?a system?
02:32:30 <Cale> tracysmith: It's a library for working with (algebraic) datatypes in a generic way (performing operations on the tree structures)
02:32:47 <minad> the nice thing is, that it can be used for mutually recursive types
02:33:15 <minad> uniplate is easy to use, but it seems to be more restricted
02:33:23 <tracysmith> thx@Cale
02:33:48 <lyxia> minad: the haskellwiki page on multiplate starts with a section about making instances, so it might be that it's hard to do generically somehow?
02:33:53 <lyxia> or the authors just didn't bother
02:34:06 <Cale> I think it came about a little before people really got into using GHC Generics to do this stuff.
02:34:15 <minad> Cale: yes, I guess it came before
02:34:34 <Cale> and TH existed for sure, but that's substantial effort
02:34:53 <minad> Cale: actually, I've seen a TH gist somewhere
02:34:55 <Cale> (still, it ought to be reasonably doable)
02:35:35 <minad> I find TH easier than generics, but I would prefer generics
02:36:01 <Cale> Oh, I suppose this would really *need* TH, if you wanted it to define your plate types
02:36:22 <minad> no, I would like to define a plate type and then just say instance Multiplate MyPlate
02:37:35 <minad> it could still be that this only works with TH, my understanding of Generic is limited (the idea is easy to grasp, but to get something done...)
02:40:36 <minad> maybe I just try the TH variant. should be faster
02:50:19 <muzzle> hi, I'm trying the amqp package. When I publish a message using publishMsg, the function blocks forever and no exceptions are thrown
02:51:47 <pavonia> Do you compile with -threaded?
02:51:53 <muzzle> yes
02:52:04 <muzzle> is that a problem?
02:52:22 <pavonia> No
02:54:22 <muzzle> My rabbitmq-server is configured with default options
02:56:00 <muzzle> and I use newMsg where I just set msgBody
02:56:08 <muzzle> everythin default otherwise
03:15:21 <muzzle> is the haskell amqp library actually stable?
03:15:45 <muzzle> has anyone here worked with it?
03:18:15 <oherrala> muzzle: amqp publishMsg doc says ''NOTE: This method may temporarily block if the AMQP server requested us to stop sending content data (using the flow control mechanism). So don't rely on this method returning immediately.''
03:20:51 <muzzle> oherrala I read that, but it blocks forever in my case
03:21:02 <muzzle> or at least it doesn't return after 15 minutes
03:21:32 <muzzle> and the rabbitmq-server runs on my local machine with default configurations
03:21:43 <muzzle> and i only try sending a single test-message
03:21:56 <muzzle> from a yesod app
03:22:00 <Cale> hm
03:35:43 <woffs> muzzle, I work in production with that amqp lib
03:36:13 <woffs> I have running an amqp consumer with client certificate authentication
03:36:14 <Jaxan_> What is the typical linear algebra package one would use? I see several bindings to blas and the like... I need to compute eigenvectors of big matrices.
03:38:38 <woffs> muzzle, I had to build it against connection-0.2.4 because rabbitmq refused the client certificate when build against connection-0.2.5 for unknown reasons.
03:45:31 <muzzle> woffs I just don't get why publishMsg would block forever
03:49:31 <muzzle> I'm not even using authentication
03:49:51 <woffs> muzzle, you should try some system debug tools like strace or tcpdump
03:50:13 <Cale> Jaxan: perhaps hmatrix?
03:50:32 <muzzle> woffs maybe it's because I'm on OS X
03:53:57 <pavonia> muzzle: Are there some other functions to test whether the connection to the server is established correcty?
03:54:12 <Insanity_> Is compiling haskell code significantly faster than using ghci for simple functions?
03:54:36 <Cale> Insanity_: It's incomparably better.
03:54:49 <Cale> Insanity_: Sometimes it'll even be asymptotically better (though that's rare)
03:55:03 <muzzle> pavonia The connection to the server is established correctly as far as I can tell from the RabbitMQ Management plugin
03:55:08 <Insanity_> Thanks, I should learn how to make a main function :P
03:55:13 <muzzle> pavonia And the channel is also correctly detected
03:55:22 <muzzle> pavonia So everything seems to be in order
03:55:45 <Cale> Insanity_: You could start with just  main = print (... whatever ...)
03:56:00 <merijn> Cale: Asymptotically better isn't even rare
03:56:12 <Insanity_> You need to use the -O switch though, right?
03:56:26 <merijn> Cale: Unless you misuse asymptotically to mean "obtain a lower complexity class" :p
03:56:30 <Cale> Insanity_: Yeah, I'd usually just go straight for -O2
03:57:06 <Cale> merijn: What would you have it mean?
03:57:14 <Insanity_> Oh, I guess this is an outdated docs page I'm on then Cale :D
03:57:27 <Cale> Insanity_: Which docs page?
03:57:36 <Insanity_> was just the first google result: https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/options-optimise.html
03:57:40 <Insanity_> But it is from version 7
03:57:46 <Insanity_> States : "At the moment, -O2 is unlikely to produce better code than -O." 
03:58:06 <Cale> Yeah, but it also doesn't make compiling small programs all that much slower
03:58:10 <Cale> So you might as well do it
03:58:20 <Insanity_> Oh okay, cheers
03:58:46 <merijn> Cale: The traditional definition of "asymptotically better" I know is "Better performance for sufficient large input"
03:58:57 <Insanity_> So you compile and it gives you ".o" 
03:59:00 <merijn> Cale: Being a lower complexity class is a sufficient condition for being asymptotically better
03:59:13 <merijn> Cale: It's however, not necessary :)
03:59:13 <Cale> Insanity_: you should get an actual executable
03:59:30 <Cale> Insanity_: what did you run?
03:59:31 <Insanity_> Oh yeah, completely looked over that
03:59:38 <Insanity_> ghc --make -O2 file.hs
03:59:51 <Insanity_> It works though, no worries :-)
03:59:53 <Cale> --make is the default now, you can leave that off :)
03:59:58 <merijn> Cale: Consider two implementations of an algorithm where one traverses a list once and the other traverses it twice. Both are O(n), but the single traversal is still asymptotically better :)
03:59:58 <Insanity_> Oh, thanks :)
04:00:55 <Cale> merijn: I suppose that's fair enough -- looking at the difference of the times
04:01:18 <Insanity_> Mhm.. but if I want to actually get the execution time I'll need to do that in code now though I'm assuming
04:01:27 <Insanity_> I can't run the compiled file with ":set +s"?
04:01:33 <Cale> Insanity_: You can run  time ./foo
04:02:07 <Cale> Though that'll measure a bit differently from :set +s
04:02:21 <Insanity_> Beautiful, thanks :-)
04:04:17 <NickHu> merijn: No, it's approximately twice as better, not asymptotically better
04:04:28 <NickHu> (i.e. polynomially better)
04:05:06 <merijn> NickHu: It IS asymptotically better. It is better for a sufficiently large input, where in this case, "sufficiently large" happens to be "any size"
04:05:50 <Insanity_> Well
04:05:58 <NickHu> Wait I got that bit about polynomially bigger wrong
04:06:16 <Insanity_> in my case, the ghci runtime was "123.37" sec measured with the ":set +s" option. Using "Time" and running the compiled version was 8.21s
04:06:28 <NickHu> But that's not true merijn because there's a linear relationship of (*2), which you can describe as a constant factor
04:07:06 <Insanity_> I guess I'll compile from now on :D
04:07:07 <NickHu> merijn: For a sufficiently large input, let's say the first function takes time T, then the second will take time approx 2T
04:07:12 <NickHu> 2T isn't asymptotically bigger than T
04:09:05 <NickHu> f is asymptotically larger than g iff lim_(x->infty) (f(x) / g(x)) = infty
04:09:32 <merijn> NickHu: That's not the definition of asympotically better used in complexity analysis
04:09:34 <muzzle> woffs pavonia maybe it's because it's running in a yesod-app?
04:09:51 <merijn> NickHu: "By this measure, a linear algorithm (i.e., f(n)=d*n+k) is always asymptotically better than a quadratic one (e.g., f(n)=c*n2+q). That is because for any given (positive) c,k,d, and q there is always some n at which the magnitude of c*n2+q overtakes d*n+k."
04:10:00 <pavonia> muzzle: No idea, sorry
04:10:38 <NickHu> Yes that's because the second function is a higher degree polynomial
04:10:44 <merijn> NickHu: In complexity analysis a function is asymptotically better, IF there exists an 'n' such that for any value larger or equal to 'n' f(n) >= g(n)
04:10:48 <NickHu> I.e. O(n) vs O(n^2)
04:11:11 <NickHu> O(n) is equal to O(2n) though
04:11:27 <merijn> There is no "O(2n)" that doesn't make sense in big O notation
04:11:32 <NickHu> Or more generally for any constant k, O(n) = O(k n)
04:11:35 <NickHu> Yeah but you get what I mean
04:11:38 <woffs> muzzle, I'm not running yesod and have not used publishMsg yet, sorry ;-)
04:11:39 <merijn> Additionally any function that is O(n) is also O(n^2)
04:11:48 <NickHu> Yes I know
04:12:56 <NickHu> Here's what I mean:
04:13:30 <merijn> NickHu: Which still doesn't invalidate my point that the COMMON definition of asymptotically better in complexity analysis is: "Given two functions f and g, if there exists an input 'n' that has the property that for any 'x >= n' f(x) > g(x) then we say that 'g' is asymptotically better than 'f'"
04:13:33 <NickHu> \BigTheta (n) = \BigTheta (m) where m = k n where k is any number
04:15:34 <merijn> NickHu: Clearly, if I have one implementation (f) that traverses a list once and one (g) that does so twice, then they are both O(n), yet the former is asymptotically better than the latter, because there exists an 'n' such that for all values greater or equal to n, then f(x) < g(x). And in this specific case this happens to hold for ALL 'n', but that's just coincidence
04:15:50 <lyxia> "asymptotic better" is a much more precise notion than comparing big Os 
04:15:55 * hackagebot stackage-upload 0.1.0.6 - A more secure version of cabal upload which uses HTTPS  https://hackage.haskell.org/package/stackage-upload-0.1.0.6 (lehins)
04:16:04 <NickHu> merijn: By your definition, you could say that a function which takes an additional constant amount of time is asymptotically better than a function which does not
04:16:17 <merijn> NickHu: Yes
04:16:29 <NickHu> For example, let's say that f takes precisely n time, and g takes precisely n+1 time
04:16:40 <NickHu> Then f would be asymptotically better than g
04:16:42 <merijn> NickHu: Yes
04:16:44 <NickHu> Which seems absurd
04:16:47 <merijn> NickHu: Why?
04:16:54 <NickHu> That's not what asymptotically means
04:17:16 <NickHu> Because as n -> infty, the difference tends towards 0
04:17:53 <NickHu> I think the common understanding of asymptotically better is based on this notion of asymptotic sizes of functions, which is what Big O captures
04:18:03 <merijn> NickHu: I gave you the common definition of "asymptotically better" in complexity analysis, which does map entirely to other uses of asymptotically in, e.g. numerical analysis. So the only thing you could disagree with is "that's not the common definition in complexity analysis", in which case, please provide some source for that
04:18:42 <merijn> NickHu: That definition completely covers any cases of comparing different Big O classes
04:18:48 <NickHu> Here's what you quoted: http://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec19-asymp/review.html#1
04:20:22 <NickHu> "asymptotically better" is a specific type of "better"; I can't find anything which might suggest that the common understanding of "asymptotically better" is what you're describing; could you provide a source?
04:22:26 <ertes> without questioning what is common, why is it absurd?  it seems like a perfectly useful definition to me
04:22:30 <merijn> "My theoretical CS lectures", I can dig up CLRS when I get home and see what it says, but I don't have it in the office
04:22:35 <tdammers> the difference between "asymptotically better" and "better" is that "better" is absolute, i.e., f performs better than g for *all* n, not just for all n above some threshold
04:22:52 <tdammers> also, that definition is perfectly reasonable
04:23:59 <tdammers> btw., "as n -> infty, the difference tends towards 0" is just blatantly false; in the given example, the difference tends towards infinity
04:24:39 <NickHu> merijn: I took a course in algorithm complexity this year and I don't think it supports your definition
04:25:26 <NickHu> tdammers: "better" can also mean it's faster due to constant factors; you can get an algorithm which has great asymptotic runtime but is unusable because it has huge constants in it
04:25:49 <NickHu> I don't understand what you mean about my example being wrong, could you please elaborate?
04:25:50 <merijn> NickHu: How does his definition exclude constant factors?
04:26:15 <ertes> |n - (n + 1)| tends toward 1 as far as i see
04:26:21 <NickHu> merijn: It doesn't, really
04:26:24 <NickHu> ertes: You have to do division
04:26:38 <tdammers> NickHu: it's wrong simply because given f(x) = 2x and g(x) = x, lim f(x) - g(x) { x -> +oo } = lim x { x -> +oo } = +oo
04:26:44 <ertes> NickHu: why?  we're not doing calculus
04:27:08 <tdammers> the *relative* difference, if you want to do that, is constant
04:27:10 <tdammers> not 0
04:27:18 <NickHu> Because that's how you determine whether a function is asymptotically larger than another
04:27:21 <tdammers> f(x) = 2 g(x) for all x
04:27:38 <NickHu> tdammers: Yes
04:27:58 <NickHu> ertes: Basically it's a convergence/divergence test
04:29:49 <ertes> don't you need the value rather than the change rate to see which one is actually faster in the limit?
04:30:13 <NickHu> Anyway, the main thing is, I relate "asymtotically better" to the algorithm has "asymptotically smaller running time/memory usage" rather than some general notion of "better for all inputs"
04:30:39 <NickHu> ertes: What do you mean?
04:31:43 <ertes> NickHu: for all n, n + 1 > n, but the change rate does not reveal that…  you need to look at the value to see that, because local information doesn't reveal it
04:32:18 <tdammers> "asymptotically better" isn't "better for all inputs", only "better for all inputs above a finite threshold"
04:32:32 <merijn> tdammers++
04:33:33 <merijn> And functions that are "better" (i.e., for ALL inputs) are necessarily a strict subset of the functions that are asymptotically better
04:35:47 <ertes> n is asymptotically better than n + 1, but they are in the same complexity class of linear functions
04:36:14 <NickHu> Oh I see what you guys mean now
04:36:17 <ertes> "in a better complexity class" ≠ "asymptotically better"
04:36:25 <NickHu> I'm conflating asymptotically better with asymptotically smaller
04:37:38 <chreekat> Hm, as I was taught it, asymptotically better DOES mean "in a better complexity class". Now I'm all spooked and reading Wikipedia's article on Time Complexity, but it seems to agree with me
04:37:56 <merijn> ertes: Although it does follow that a better complexity class is necessarily asymptotically better :)
04:38:06 <NickHu> I thought that's what I was taught too, but I guess I'll have to think about it a bit...
04:38:17 <chreekat> I could understand either definition based solely on the definition of "asymptotic", however
04:38:49 <NickHu> I can't actually find any direct reference to the phrase "asymptotically better"
04:39:01 <merijn> chreekat: Wouldn't be the first time people have taught and used slightly different terminology.
04:39:17 <merijn> chreekat: Which is why it's usually useful to be extremely precise about the definitions your using :)
04:39:18 <chreekat> right :)
04:40:23 <ertes> bottom line: before using "asymptotically better", define it ;)
04:40:38 <NickHu> Yeah I suppose
04:42:51 <NickHu> If we look at this: https://en.wikipedia.org/wiki/Asymptotic_analysis , it seems to imply that asymtotically better => asymtotically smaller, unless I am misunderstanding something
04:43:21 <NickHu> But this really only contributes towards my argument about your "common usage" point
04:44:30 <lyxia> what "asymptotically smaller" are you talking about
04:47:32 <NickHu> better complexity class
04:48:04 <ertes> in my local crypto workshops i have to define the set of natural numbers almost every single time
04:48:23 <NickHu> ertes: Ooh, I'm taking the coursera crypto course at the moment, it's really interesting
04:49:47 <ertes> in 2016 we're still arguing whether zero is a natural number =)
04:50:13 <merijn> ertes: What kinda of heretic doesn't think zero is a natural number?!
04:51:06 <ertes> merijn: it might be a local thing, but it seems that a lot of people here use the ℕ and ℕ_0 convention, whereas i prefer to ℕ and ℕ_+ convention
04:51:19 <NickHu> merijn: In my group theory lectures, the lecturer didn't like to include 0 in N
04:51:41 <ertes> (or in fact just ℕ \ {0}, because i don't like notation for stuff nobody uses)
04:51:42 <NickHu> But.. group theory isn't actually part of my course, it was for maths students
04:51:57 <lyxia> NickHu: To me "asymptotically" simply refers to a property that holds beyond some finite threshold. So the "natural" definition of "asymptotically smaller" would be the one of "asymptotically better" in this discussion.
04:52:20 <NickHu> lyxia: Yeah, we clearly had different definitions in mind
04:52:58 <NickHu> My definition of "f is asymptotically smaller than g" iff "g asymtotically dominates f"
04:53:06 <merijn> Anyway, I think we've talked this to death and everyone agrees that no one really disagrees, except perhaps on what constitutes "common usage" ;)
04:53:22 <NickHu> Yeah
04:55:02 <tdammers> on a totally different node, I just discovered a new use case for Haskell: I'm now using it as a thinking tool for designing JS applications...
04:55:04 <ertes> an easy way out would be to switch to type theory, and when people question why i have zero : ℕ, i just say: "without it writing plus is a major PITA"
04:55:22 <tdammers> prototype the architecture in Haskell, then implement it in JS
04:55:39 <merijn> tdammers: Why not skip the second step? >.>
04:56:00 <tdammers> merijn: because I have to cooperate with lesser minds who are not ready for Haskell
04:56:02 <tdammers> yet
04:56:42 <tdammers> if I were spending my own money, I'd roll with ghcjs right away
04:58:01 <tdammers> but as it stands, the reality is that I'll be handing this project off in the near future, and the person to inherit it will probably be someone fresh out of college
04:58:05 <merijn> tdammers: Tell them that if it's good enough for Utrecht, it's good enough for you ;)
04:58:10 <tdammers> muahuahua
04:58:49 <ertes> tdammers: you could implement iteratees in JS…  that effectively forces them to learn haskell anyway
04:59:09 <tdammers> I already poisoned the production codebase with ramda.js
04:59:59 <tdammers> and I have made a habit of casually dropping the words "typescript" and "purescript", and uttering random factoids about functional programming in conversations
05:00:03 <ertes> also use CPS-transformed ADTs, because then you can have pattern-matching in JS and force them to learn haskell even more =)
05:00:43 <tdammers> well, for the thing I'm working on right now, I basically copied the Elm Architecture
05:01:01 <tdammers> implemented it in Haskell first, so I could think things out without my head exploding
05:01:08 <tdammers> and then I wrote it in JS, and it works fine
05:01:13 <ertes> (poor man's pattern matching, but still pattern matching…  better than switch/if/"prototype polymorphism")
05:02:39 <tdammers> (R.prop(message.what, handlers) || () -> throw new InvalidMessageException())(message)
05:02:51 <NickHu> I'm quite excited to play with Elm a bit
05:02:55 <JonReed> Hi, are infix operators with three arguments possible without using brackets to group arguments? Like `(.+) :: Num a => a -> a -> a -> a; (.+) a b c = a + b + c;` and then `2 .+ 2 5` should give `9`. It only works however with brackets `(2 .+ 2) 5` can it be made to work without them?  
05:03:25 <NickHu> JonReed: Afaik it only works that way because of a byproduct of currying
05:03:50 <NickHu> Infix operators are really designed for two operands
05:04:06 <ertes> JonReed: you can't have that:  x ... y z = x ... (y z)
05:04:25 <ertes> application has the highest precedence, and you can't override it
05:04:49 <JonReed> Ok :(
05:05:15 <ertes> you don't want to either =)
05:05:25 <JonReed> Why not?
05:05:34 <lyxia> 2 :+ 2 $ 5
05:06:04 <NickHu> Because it stops you from shooting yourself in the foot
05:06:28 <NickHu> You could join up the second and third arguments together in some sort of data type
05:06:32 <ertes> JonReed: syntactical special cases come at a cost and quickly deliver diminishing returns
05:07:19 <ertes> JonReed: ((x .+ y) z) isn't too terrible, is it?  i think it's rather beautiful and easy to read
05:07:58 <MarLinn> tdammers: I haven't looked into them too closely, but I suppose the js-code produced by Haste or Sunroof isn't suitable, either?
05:07:59 <ertes> now introduce a special case and make people wonder what "y z" means, because now it no longer follows from the syntax
05:09:39 <JonReed> Conceptually it's just moving f in front of one argument: "f a b c" "a `f` b c" . If you can shoot yourself with `f` can't you just as easily shoot yourself with f. I mean you still have to know about how many arguments f accepts, especially if you encounter pointfree style. 
05:10:22 <NickHu> No I'm talking about if you could override the precedence of application
05:11:00 <ertes> agda can override it, and it's horrible…  looking at agda code you can draw almost no conclusions
05:11:20 <NickHu> Then suddenly you have f a b c and you don't know whether you're getting f (a (b c)) or f ((a b) c) or (f a b) c etc.
05:12:35 <ertes> or any of them =)
05:12:39 <tdammers> MarLinn: more like, I can't afford to burden my colleagues with learning any of those
05:13:02 <ertes> "f a b c" could mean: b applied to (f a) and c
05:13:11 <Cooler> what are applicative functors?
05:13:21 <MarLinn> An "easy" way to make interfix less ambiguous would be to have an operator at each separation like "then" or "else" in if-expressions. But then you can already to that with $ or a custom data type...
05:13:23 <ertes> Cooler: do you understand monads?
05:13:49 <ertes> the easiest way to make mixfix usable is:  forget it exists
05:14:39 <Cooler> ertes, i just found the google code challenge
05:15:03 <ertes> Cooler: that doesn't answer my question
05:15:31 <Cooler> yes monads implement bind and return and follow the monad laws
05:15:46 <Insanity_> google code challenge?
05:16:22 <NickHu> Applicative functors are like an upgrade from fmap
05:16:25 <ertes> Cooler: ok, monadic bind means that given the result of a monadic action you can construct a new action using that result
05:16:41 * hackagebot sdl2 2.1.3 - Both high- and low-level bindings to the SDL library (version 2.0.2+).  https://hackage.haskell.org/package/sdl2-2.1.3 (tejon)
05:16:43 * hackagebot purescript-bridge 0.8.0.0 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.8.0.0 (eskimo)
05:16:45 * hackagebot servant-purescript 0.3.1.4 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.3.1.4 (eskimo)
05:16:47 * hackagebot data-msgpack 0.0.2 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.2 (iphydf)
05:16:49 * hackagebot network-msgpack-rpc 0.0.1 - A MessagePack-RPC Implementation  https://hackage.haskell.org/package/network-msgpack-rpc-0.0.1 (iphydf)
05:16:53 <ertes> Cooler: monads are highly dynamic in that sense
05:16:59 <MarLinn> tdammers: my thought was more along the line of having them to try to understand the generated code instead of the "source". Possibly by generating code and then refactoring+commenting that instead of a complete rewrite.
05:17:00 <MarLinn>  But I don't expect that to be much easier than writing it from scratch
05:17:04 <NickHu> So instead of having (+1) <$> Just 2, you can have Just (+1) <*> Just 2
05:17:19 <MarLinn> *-to
05:17:25 <ertes> Cooler: applicative functors are a restriction that keeps actions static:  you can still combine multiple actions, but you can only combine their results using a pure function
05:18:15 <ertes> Cooler: compare:
05:19:37 <ertes> fmap  ::   (a -> b) -> F a -> F b  -- you can only modify the result of an action
05:19:37 <ertes> (<*>) :: F (a -> b) -> F a -> F b  -- you can combine the results of two actions
05:19:37 <ertes> (>>=) :: (a -> F b) -> F a -> F b  -- you can construct an action from the result of another action
05:19:48 <ertes> whoops…  the last one is flip (>>=)
05:20:31 <bartavelle> is there a maintained FTP library I missed ?
05:20:51 <bartavelle> it seems only "curl" is, and I'd rather use something less complicated
05:24:14 <Cale> bartavelle: Is there a maintained FTP server I missed? ;)
05:24:43 <ertes> Cale: ftp.kernel.org =P
05:24:45 <bartavelle> Cale, I work in the industry, everything is from the 80's
05:25:04 <bartavelle> but yes, that's a valid answer
05:25:19 <bartavelle> sucks for me thouhg
05:25:55 <Cale> I was mostly kidding, but yeah... hmm
05:26:13 <Cale> http://hackage.haskell.org/package/ftp-conduit
05:26:14 <Cale> ?
05:26:24 <Cale> Pretty minimal
05:26:31 <NickHu> If you don't need to do anything more complicated than download things off an FTP server I'm sure you could just use a HTTP library
05:26:35 <bartavelle> last upload 2012, I suspect the conduit dependency will require changes
05:26:42 <Cooler> ertes, fmap  ::   (a -> b) -> F a -> F b  -- you can only modify the result of an action
05:26:45 <Cale> NickHu: that... that isn't true
05:26:52 <Cale> They're two completely different protocols
05:26:54 <Cooler> ertes, what do you mean modify the result?
05:27:24 <Cale> Cooler: Well, think about what the type F a consists of
05:27:30 <NickHu> Cale: I could be completely wrong.. I do vaguely recall that I used a HTTP library in the past to download from FTP
05:27:33 <bartavelle> Cale, also I need to list files *and* upload files, so the minimal library won't help me here
05:27:34 <ertes> Cooler: getLine :: IO String;  fmap length getLine :: IO Int  -- this is a modified version of 'getLine' that applies the 'length' function to the result of getLine
05:27:36 <NickHu> But then again, maybe I just used curl..
05:27:42 <ertes> Cooler: you can do that, because IO is a functor
05:27:54 <Cale> Cooler: The values of type F a are being thought of as computations which, if they finish normally, will produce a result of type a
05:28:03 <bartavelle> NickHu, curl will handle both, but the curl library is very complicated and the FTP usage non trivial to me
05:28:13 <Cooler> F a and F b could be 2 completely different actions, not the same action with a modified result
05:28:27 <ertes> Cooler: the "F b" is the result of fmap
05:28:48 <ertes> fmap takes an (a -> b) and an (F a) and returns an (F b)
05:29:07 <Cale> NickHu: Yeah, if it was curl, that's just smart enough to see that you gave it a URL starting with "ftp:" and do the right thing -- the actual communication which goes over the line is quite different.
05:29:14 <ertes> which is the (F a) with its result modified by applying the (a -> b)
05:29:44 <NickHu> Cale: I see, thanks for clarifying
05:30:01 <Cooler> ertes, thats why i said
05:30:03 <Cooler> F a and F b could be 2 completely different actions, not the same action with a modified result
05:30:32 <NickHu> Cooler: I always found this to be helpful: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
05:30:55 <ertes> Cooler: fmap doesn't have a lot of choice in what it does with its second argument due to parametricity (remember, it doesn't know what 'a' and 'b' are) and the functor laws
05:31:10 <ertes> in particular it can't switch effects
05:31:52 <ertes> switching effects leads to (fmap id ≠ id) pretty much instantly
05:31:58 <NickHu> ertes: I'm sure it could if you use unsafePerformIO ;)
05:32:37 <ertes> NickHu: i'm pretty sure even unsafePerformIO doesn't help much there
05:32:52 <NickHu> By switching effects, don't you mean do another IO action?
05:33:26 <ertes> you can think of "switching effects" as synonymous with "breaking the functor laws" =)
05:33:35 <ertes> because "effect" is a vague concept
05:33:53 <ertes> but in the case of IO yes, doing another effect that actually has an observable effect
05:34:57 <NickHu> So couldn't you use unsafePerfomIO in your function passed to fmap to cause an effect inside an IO functor which isn't the original one?
05:35:49 <Cooler> ertes, i don't get it, why would fmap id =/= id?
05:35:50 <ertes> NickHu: you don't need unsafePerformIO to do that, but you might break the functor laws
05:36:37 <NickHu> I see
05:36:58 <ertes> Cooler: imagine (fmap f c) would be the action 'c', but with 'f' applied to its result (fmap has no choice there), but with an additional effect like printing debug info
05:37:25 <ertes> Cooler: fmap id (pure ())  -- this should be (pure ()) by the functor identity law
05:37:43 <ertes> but it isn't, because fmap introduced an extra effect:  printing the debug info
05:38:26 <Cooler> ertes, why could not just have a special case for id?
05:38:34 <Cooler> fmap id = id
05:38:37 <ertes> Cooler: try to write a special case for id =)
05:38:51 <ertes> Cooler: how do you recognise that it's id?
05:38:58 <Cooler> ugh
05:39:14 <Cooler> okay.......
05:39:21 <ertes> parametricity prevents you from doing that
05:39:50 <ertes> fmap also can't recognise that it's being composed with another fmap
05:39:53 <Cooler> whats parametricity?
05:40:08 <NickHu> The stuff in your type signatures like a -> a -> b
05:40:13 <ertes> while 'fmap (f . g)' would introduce only one extra effect, 'fmap f . fmap g' would introduce two
05:40:16 <dibblego> onad
05:40:18 <dibblego> oops
05:40:18 <NickHu> So that you can say "a is Int" and "b is String"
05:40:37 <ertes> Cooler: it basically means that you can't ask which types you got
05:40:49 <Cooler> you mean reflection?
05:40:51 <ertes> your fmap implementation can't tell an 'a' from any other 'a'
05:40:53 <ertes> yeah
05:41:28 <eklavya> if I need to do "if x > 0 decrement x" in an STM
05:41:40 <NickHu> Right, fmap should behave in the same way for [Int], [String], [a]
05:41:43 <eklavya> can STM work for this?
05:41:53 <eklavya> also how will it decide the ordering?
05:42:08 <eklavya> and what if x <= 0
05:42:17 <ertes> eklavya: STM actions are memory transactions…  you can pretend that they all run in sequence
05:42:23 <NickHu> eklavya: STM is for software transactional memory, where you need a guarantee of atomicity (i.e. in concurrent programming)
05:42:26 <Cooler> ertes, can't tell an a from any other a? if a is Int, you can do a == x to see if its x or not
05:42:38 <Cooler> the same for lots of things
05:42:44 <NickHu> Cooler: That's because Int is an instance of the Eq typeclass
05:42:51 <Cooler> yes
05:42:56 <NickHu> But fmap makes no such imposition, thus cannot use (==)
05:43:06 <wilornel__> Hey #Haskell! I am trying to learn Haskell and was playing around in ghci. I tried `let blarg = (myfunc) <$> Just 2 <*> Just 4`;`blarg $ (Just 2)`, but was stopped with the error: `     • Couldn't match expected type ‘Maybe (Integer -> Integer) -> t’ with actual type ‘Maybe (Integer -> Integer)’` . I know I was supposed to do `blarg <$> Just 2`, but was wondering, what does `‘Maybe (Integer -> Integer) -> t
05:43:18 <wilornel__> (let me know if my message cut off, if we don't see my question mark)
05:43:23 <ertes> Cooler: you're the implementor of fmap, and your type signature is:  (a -> b) -> F a -> F b
05:43:28 <eklavya> ertes: NickHu AFAIU STM will keep a log and auto resolve when it can
05:43:35 <eklavya> if it can't it will rollback
05:43:39 <ertes> Cooler: you don't get any extra information about 'a' and 'b'…  they are *some types*
05:43:50 <ertes> eklavya: yeah
05:43:51 <NickHu> eklavya: That's kind of what a transaction is
05:43:59 <Cooler> ertes, why can't you do reflection?
05:44:01 <eklavya> how does that work in this scenario?
05:44:05 <MarLinn> wilornel__: yes.
05:44:10 <ertes> Cooler: because haskell doesn't support it (deliberately)
05:44:17 <NickHu> eklavya: Order of operations is sequenced by the order you write it in the do expression
05:44:24 <ertes> Cooler: you can do reflection, but only with extra information (e.g. the Typeable class)
05:44:25 <jonored> wilornel__: You've got something that you're trying to use as a function from a Maybe (Integer -> Integer) to something, but is actually just a Maybe (Integer -> Integer).
05:44:33 <Cooler> ertes, so at runtime all type information gets erased?
05:44:38 <ertes> Cooler: correct
05:44:47 <Cooler> i mean when the program is compiled
05:44:51 <eklavya> NickHu: many threads are doing it from different places
05:44:55 <ertes> Cooler: yeah
05:45:11 <Cooler> so its like c, where the thing occupies some amount of memory?
05:45:18 <ertes> Cooler: or interpreted…  at run-time all type information that you didn't keep is lost
05:45:23 <Cooler> and thats it
05:45:26 <NickHu> eklavya: Then the logic of which order each transaction is done is outside somewhere else
05:45:32 <NickHu> i.e. where you call the STM functions
05:45:52 <ertes> Cooler: you could say that, yeah
05:46:21 <ertes> Cooler: i'd compare it to C++ instead, which has parametric polymorphism
05:47:08 <Cooler>  (<*>) :: F (a -> b) -> F a -> F b  -- you can combine the results of two actions
05:47:19 <Cooler> what do you mean combine the results?
05:47:59 <eklavya> NickHu: I am still not sure how it would resolve conflicts, what will the transaction logs have?
05:48:03 <ertes> Cooler: (<*>) receives two actions and the resulting action has the effects of both, and combines their results by applying the first action's function to the second action's result
05:48:42 <NickHu> eklavya: It's hidden by the abstraction. The guarantee you get from STM is either it all happens at once, or none of it happens
05:49:21 <MarLinn> Cooler: You could alternatively define Applicative to have a function comma :: f a -> f b -> f (a,b) . That makes clearer what "combine" means here imho. You can define comma in terms of (<*>) and vice versa
05:49:24 <ertes> Cooler: example:  fmap (\line -> (++) line) getLine  -- this is an action of type IO (String -> String), right?
05:49:42 <ertes> Cooler: getLine  -- and this is an IO String
05:50:41 <ertes> Cooler: fmap (\line -> (++) line) getLine <*> getLine  -- this is the action that gets one line (let's call it str1) and gets another line (str2)…  the result is the function ((++) str1) applied to str2
05:50:48 <ertes> resulting in:  str1 ++ str2
05:51:00 <eklavya> NickHu: understood, just wanted to learn more about how the magic is happening, if you don't mind telling me :)
05:51:27 <NickHu> eklavya: I don't actually know how STM works under the hood but I imagine it's some mutex magic further down
05:51:56 <merijn> NickHu: Not really, it uses optimistic locking
05:52:05 <eklavya> I saw a talk which said STM performs better than locking
05:52:13 <merijn> eklavya: The STM paper is pretty readable, should be linked from the STM docs
05:52:26 <merijn> eklavya: STM performs better than locking *given the right conditions*
05:52:29 <NickHu> merijn: I'm sure you can do it in a bunch of different ways though, right?
05:52:30 <ertes> Cooler: in other words: whenever you want to combine two actions' results, you modify the first action to return a function, then combine it using (<*>) with the other action
05:52:41 <eklavya> merijn: when the conflicts are less?
05:52:59 <merijn> eklavya: STM is VERY good when you do not have lots of conflicts
05:53:20 <merijn> eklavya: i.e. shorter fine-grained transactions that are not hotly contending a single TVar
05:53:41 <eklavya> merijn: also I wondered they would have to have a lock on the log itself, right?
05:53:47 <merijn> eklavya: STM is not so good when you have large transactions, lots of threads blocking on a single TVar
05:54:35 <merijn> eklavya: Large transactions increase the cost of rollback and increase the risk of conflicts
05:54:51 <merijn> Lots of threads blocking on a single TVar leads to thundering herd problems
05:54:56 <eklavya> merijn: but it has to lock on the log, how can it perform better?
05:55:07 <merijn> eklavya: Which log?
05:55:29 <eklavya> the transaction log which it keeps to resolve conflicts and commit
05:55:40 <merijn> It doesn't resolve conflicts
05:55:44 <NickHu> eklavya: You can do something called lockless concurrency with a hardware instruction called CAS (compare and swap). I don't know if STM utilises this
05:55:59 <merijn> eklavya: If it reaches the ends of a transaction and no input has changed, the transaction is committed
05:56:10 <NickHu> The CAS instruction looks at a bit of memory, and if it's what you expect it to be, you write to that memory, otherwise you fail
05:56:12 <eklavya> oohhh
05:56:18 <merijn> eklavya: If any TVar that was read has changed, the transaction is aborted and retried
05:56:19 <NickHu> In that way you don't need to hold a lock on that memory
05:56:41 <eklavya> merijn: and in case of multiple writes?
05:57:26 <buglebudabey> im trying to install codeworld-api through stack, but the package can't be found, does anyone already have it installed?
05:57:31 <merijn> eklavya: I don't remember all the details, see the paper linked here: https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM.html
05:57:44 <eklavya> sorry :P
05:57:50 <eklavya> thanks merijn NickHu :)
05:59:52 <merijn> Note that the performance of STM is not aversely affected by the number of concurrent transactions (assuming they don't overlap/conflict), so actually having a ton of fine-grained STM transactions is actually a best-case scenario :)
06:00:24 <eklavya> understood
06:00:32 <merijn> (since small fine-grained transactions are very likely to commit uninterrupted, unless HIGHLY contended)
06:01:06 <merijn> As opposed to locking, where lots of fine-grained locking is really expensive
06:01:17 <merijn> Making you want to minimise locks
06:01:35 <eklavya> got it
06:01:43 <NickHu> I stumped upong mapConcurrent in Control.Concurrent.Async the other day - it's super cool imo
06:02:20 <NickHu> Sorry, it's mapConcurrently
06:03:09 <eklavya> is hackage down?
06:06:24 <MarLinn> Doesn't seem to be to me
06:06:24 <cocreature> eklavya: worksforme™
06:06:41 <eklavya> yeah it worked now
06:07:31 <eklavya> merijn: that link is opening SPJ's home page
06:07:38 <eklavya> let me google
06:10:38 <merijn> eklavya: Oh, yeah, Microsoft Research fucked up their links this year :\
06:10:43 <merijn> eklavya: Use Google Scholar
06:13:23 <fryguybob> eklavya: I can fill you in on under the hood details of STM if you want.
06:14:17 <eklavya> fryguybob: that would be great, please :)
06:14:26 <eklavya> merijn: found it
06:15:36 <fryguybob> eklavya: STM is about two things, expressing computations in atomic chunks (we get this for free in Haskell as we can craft types that give this), and an implementation that uses speculation to execute these chunks (built into the runtime system in GHC).
06:16:30 <eklavya> fryguybob: how do types help in saying something is atomic?
06:17:49 <fryguybob> eklavya: It allows us to limit the effects avilable to transactions.  So you can only build up compositions of pure computations, new, read, and write operations to TVars.
06:18:16 <fryguybob> eklavya: Putting some other effect like writing to a file does not type check.
06:18:32 <eklavya> right, ok
06:18:48 <fryguybob> eklavya: Converting an STM action to one that will be executed defines the atomic block:  atomically :: STM a -> IO a
06:19:11 <fryguybob> eklavya: The action we give to atomically is what we call a transaction.
06:20:16 <fryguybob> eklavya: Under the hood a frame is pushed with atomically that will attempt to commit the tranaction when execution returns to it.
06:20:31 <NickHu> Can someone give me a line on when to use TVar, and when to use MVar?
06:21:15 <merijn> NickHu: MVar if you're going to have lots of threads blocking on it, TVar if you need to manipulate it in some atomic transaction
06:21:16 <fryguybob> NickHu: If you need to compose operations involving multiple objects, use TVar
06:21:31 <fryguybob> NickHu: If you *need* fairness, use MVar
06:21:36 <fryguybob> NickHu: Otherwise, benchmark.
06:21:48 <merijn> fryguybob: Not just fairness
06:21:57 <merijn> fryguybob: Also avoiding thundering herd
06:22:04 <fryguybob> merijn: That is fairness.
06:22:11 <merijn> fryguybob: No, it's not
06:22:39 <merijn> fryguybob: fairness is about guaranteeing equal odds of getting to access the "variable"
06:23:06 <merijn> Thundering herd is a problem where you produce a lot of activity churn by redundant wakeups
06:23:47 <merijn> The implementation of MVar happens to deal with both, but that doesn't make them the same thing
06:24:08 <merijn> You can avoid thundering herd without being fair, for example
06:24:12 <NickHu> My use case is basically this: I want to write a lot of things into a hashmap, but I'm only writing to each key once, so maybe I don't need to lock at all
06:24:14 <merijn> Just wake up a single random thread
06:24:55 <NickHu> I'm currently using the STMContainers.Map data structure, but I don't really know how its concurrency model works
06:25:23 <fryguybob> NickHu: What do you mean by only writing to each key once?
06:25:51 <NickHu> As in, I write to a key and then that data is never written to again
06:26:02 <NickHu> Each write performs on a unique key
06:27:58 <fryguybob> NickHu: Does anything attempt to read from keys before they are written?
06:28:05 <NickHu> Nope
06:28:31 <NickHu> In fact I don't try to read from the map at all until I'm completely done writing to it
06:29:17 <fryguybob> NickHu: So is it even a shared structure as it is constructed.  Could it be just local structures that are later merged?
06:30:07 <NickHu> fryguybob: I suppose it could be, but I couldn't think of how to model it lik ethat
06:30:42 <fryguybob> merijn: Fairness is usually stated in terms of progress guarentees for threads.  Releasing all threads when only one will make progress is not fair.
06:31:09 <merijn> fryguybob: Sure, but that doesn't make thundering herd and fairness the same
06:31:17 <fryguybob> eklavya: Each transactional action is logged in the implementation, so readTVar looks at the TVar and records its value in a thread-local log
06:31:32 <fryguybob> eklavya: Subsequent reads will be from the log and any writes will be to the log.
06:31:34 <merijn> fryguybob: As evidenced by the fact that I can come up with a million implementations that aren't fair, but don't suffer from thundering herd
06:32:09 <merijn> Like having single-wakeup up LIFO queue
06:32:38 <fryguybob> eklavya: The commit then happens by checking that the values held by the log still hold, acquiring locks for the TVars that need to be written, then checking again that no read values have changed.
06:32:57 <fryguybob> eklavya: Then the values are written to the TVars themselves and locks are released.
06:33:35 <fryguybob> eklavya: Read-only transactions take no locks and no deadlocks can happen.  GHC's implemenation, however can livelock.
06:33:46 <eklavya> so it performs the transactions in a separate memory block and writes the result after checking the starting conditions still hold?
06:34:08 <fryguybob> eklavya: Yes that is the idea.
06:34:52 <eklavya> so the only time it locks is when it's finally writing?
06:36:10 <mrm> So, I've decided to use a number theory class as an excuse to finally getting around to learning haskell. Can someone point me at either some built-in functions related to primes, or a friendly introduction to how packages work in this corner of the world?
06:36:54 <nshepperd> NickHu: sounds like you really just need a shared (Key, Value) log
06:37:10 <fryguybob> eklavya: Right in the simplest case.  Two additional features are in GHC's STM: blocking and composition.
06:37:29 <mrm> I'd rtfm, but I'm not sure what the right fm is atm.
06:37:35 <nshepperd> NickHu: when you're done, you could use one thread to merge each key value pair into a final map
06:38:17 <NickHu> I don't really see how a shared (Key, Value) log is any different from a map
06:38:24 <spirit1> Друзья, подскажите с профилировкой:
06:38:27 <fryguybob> eklavya: Blocking is called `retry` and it will block the thread until something changes that may allow it to make progress (i.e. one of the read TVars changes).
06:38:46 <spirit1> Программа запускается с входными параметрами
06:38:58 <spirit1> как туда просунуть правильно +RTS -P?
06:39:09 <spirit1> типа ./main -RTS -P <args>
06:39:17 <fryguybob> eklavya: Composition is `orElse` which takes two STM actions and attempts the first, if it reaches `retry` discards its effects and attempts the second.
06:39:34 <NickHu> nshepperd: What's the advantage over my current approach of many threads inserting into a concurrent map? Just less memory usage while I'm building the structure?
06:39:52 <fryguybob> eklavya: Note that for `orElse` to commit it must hold that the first part still would result in `retry`.
06:39:56 <spirit1> whoops, i thought it's ru room
06:40:13 <spirit1> how to pass +RTS -P with other args?
06:40:19 <spirit1> like
06:40:23 <spirit1> ./main -RTS -P <args>
06:40:34 <spirit1> *+RTS
06:40:41 <lyxia> spirit1: pass the other args first?
06:40:54 <geekosaur> you accidentally told yourself how, albeit reversed
06:41:01 <geekosaur> +RTS +P -RTS ...
06:41:15 <eklavya> fryguybob: still <- ??
06:41:19 <geekosaur> (or --RTS to prevent anything else following from being read by the RTS)
06:41:31 <geekosaur> or indeed just reorder parameters
06:41:32 <fryguybob> eklavya: I don't understand.
06:41:48 <spirit1> can you write an example?
06:41:57 <eklavya> fryguybob: first part retried that's why we did the second, why would we check again?
06:42:19 <spirit1> if i type +RTS first, than parser inside a programm throw errors
06:42:26 <nshepperd> NickHu: it's not really different I guess
06:42:35 <nshepperd> a log just seems likely to be efficient
06:42:48 <spirit1> if RTS is going last then programm throw black screen with 100% cpu consume
06:43:10 <NickHu> nshepperd: But the write events are coming in at different times; with a log, wouldn't I need to hold a lock on it for each write event?
06:43:16 <fryguybob> eklavya: Oh, I'm saying that  a `orElse` b  if  a  executes  `retry` execution moves to b, but by commit time, something has changed and a could exeucte the the transaction will not commit, it will start over and run a.
06:43:23 <geekosaur> spirit1, that sounds like something else is wrong
06:43:27 <fryguybob> So `orElse` is left-biased.
06:43:35 <NickHu> (this may be what STMContainer.Map does under the hood anyway)
06:44:02 <geekosaur> and, if [06 13:40] <geekosaur> +RTS +P -RTS ...  is not an example, what is an appropriate example?
06:44:11 <fryguybob> NickHu: STMContainer.Map is a data structure built with TVars
06:44:30 <fryguybob> NickHu: One TVar per trie node.
06:44:50 <NickHu> fryguybob: Does that mean if I am writing to two different keys in two different threads they actually happen at the same time?
06:45:06 <spirit1> geekosaur: do you meen ./main +RTS -P arg1 arg2?
06:45:11 <spirit1> it doesn't work
06:45:17 <fryguybob> NickHu: Quite often yes.
06:45:29 <geekosaur> spirit1, do you see this? :     -RTS
06:45:47 <NickHu> Excellent; I didn't really understand whether triggering a write in one key would lock the whole map until that write was finished
06:45:56 <NickHu> I love when I accidentally do things the correct way first time
06:46:13 <fryguybob> NickHu: Inserting into that structure involves copying the existing data in the node then updating a single TVar to point to the new node.
06:47:00 <NickHu> Oh, is this how STM in general works without locking?
06:47:12 <fryguybob> As long as the writes are to different nodes and the written node is not along the read path down the tree to the other node they will not conflict
06:47:48 <eklavya> fryguybob: ok
06:47:53 <NickHu> In that case, could you perhaps explain how MVar and TVar are different? I've often heard TVars are MVars with more safety for transactions in them
06:48:02 <fryguybob> NickHu: It does lock the TVars, but only durring commit.  Locks are held for a finite number of steps (given an OS that schedules fairly)
06:48:49 <NickHu> fryguybob: Can the pointer update not be done in a CAS?
06:48:51 <nshepperd> TVars are more like IORefs that can be accessed together in an atomic transaction
06:49:00 <fryguybob> NickHu: MVars are quite different.  They are either full or empty
06:49:18 <nshepperd> TVars can't be empty
06:49:55 <merijn> NickHu: The point is that you can update multiple TVars atomically
06:50:14 <fryguybob> NickHu: When you try to do something to an MVar and the value is not available your thread blocks and goes to sleep right away.  This is pretty pessimistic and can be slow, but gives fairness because when a value becomes available it wakes threads in the order they attempted to access.
06:50:53 <fryguybob> NickHu: In the case of the STMContainer's map, yes.  For STM in general you need nCAS which is not supported by hardware generally.
06:51:20 <DangerousDav3> Hello, if I have a function func :: (Num a) => a->a->a
06:51:21 <fryguybob> NickHu: The CAS version of the STMContainer's map is CTrie.  It is a little bit faster.
06:51:28 <DangerousDav3> can the result be double while the inputs are integers?
06:51:35 <byorgey> DangerousDav3: no
06:51:39 <DangerousDav3> OK
06:51:41 <fryguybob> NickHu: But you cannot compose operations into atomic blocks.
06:51:48 <byorgey> in  'a -> a -> a', all the a's have to be the same type
06:51:59 <DangerousDav3> byorgey: So should I use (Num a,b) => a->a->b?
06:52:26 <NickHu> Oh so STMConcurrent.Map is build on top of CTrie
06:52:27 <byorgey> DangerousDav3: that's probably not what you want.  That means for *any* numeric inputs it can give *any* numeric output the caller wants
06:52:34 <byorgey> DangerousDav3: there are not many useful functions with that type
06:52:36 <fryguybob> merijn: I wasn't trying to equate thundering hurd with fairness, just saying that on the on hand you may *need* composition as a property, so use TVar.  You also may *need* fairness, use MVar.
06:52:42 <byorgey> DangerousDav3: why not just  Integer -> Integer -> Double  ?
06:53:09 <DangerousDav3> Just asking
06:53:18 <DangerousDav3> because It might be different types
06:53:27 <DangerousDav3> maybe Float->Float->Int
06:53:39 <byorgey> DangerousDav3: what will the function do?
06:53:41 <DangerousDav3> the inputs are the same and the output is different
06:53:56 <fryguybob> NickHu: No, it is built with TVar's, but the same data structure Hashed Array Mapped Trie has a CAS only implmenetation called CTrie and there is a package on Hackage for it.
06:54:04 <fryguybob> Don't try to run it on ARM though...
06:54:09 <byorgey> I am having trouble imagining a function that can have the type  Int -> Int -> Double  and *also*  Float -> Float -> Int
06:54:12 <byorgey> other than e.g.  f _ _ = 3
06:54:27 <NickHu> DangerousDav3: Then your (Num a, b) => a -> a -> b signature would be correct
06:54:45 <fryguybob> f _ _ = 3 is one of my favorite functions.
06:55:05 <DangerousDav3> fryguybob: I like it too, thats why I have asked that question
06:55:27 <byorgey> sure, if you really have a function that can take two numeric arguments and can return *any* other numeric type, that would be the correct type
06:55:34 <DangerousDav3> and how can I set an constraint over a type when using record syntax?
06:56:01 <byorgey> my claim is that functions like  f _ _ = 3  are basically the only functions that could have that type.
06:56:15 <byorgey> DangerousDav3: I'm not sure what you mean.  Can you give an example?
06:56:25 <mrm> I've installed a package through cabal install, but it's not working with import. Is there some extra step?
06:56:53 <byorgey> mrm: are you in a cabal sandbox?
06:56:54 <NickHu> byorgey: You could have a function which takes two integers, i.e. 3 and 14, and gives you a decimal number 3.14
06:56:58 <DangerousDav3> byorgey: I want to create a data type that holds 2 numbers of any type, how can I do that?
06:57:11 <byorgey> NickHu: that would not have type  (Num a, Num b) => a -> a -> b
06:57:16 <mrm> byorgey: I have no idea what that means.
06:57:20 <ph88> can someone help me understand this error?  https://paste.fedoraproject.org/422897/73170204/
06:57:20 <byorgey> because it can't e.g. return an Integer
06:57:26 <byorgey> mrm: OK, never mind then =)
06:57:59 <tdammers> MarLinn: they would also need to modify the code at some point, and then what?
06:58:13 <mrm> I'm using the interpreter from emacs haskell-mode on a file.
06:58:26 <byorgey> DangerousDav3: you can do that with existential types, but most likely you don't really want to do that
06:58:32 <byorgey> DangerousDav3: why do you want such a data type?
06:58:41 <byorgey> there is probably a better way to do whatever you are trying to do
06:58:41 <NickHu> I think you can do it with GADTs too but I might be wrong
06:58:58 <byorgey> yep, GADTs are a nice way to encode existential types
06:59:21 <DangerousDav3> byorgey: Actually I don't want that one, I want to create a K nearest neighbor learner that holds k the number of neighbors to look on and the meteric that is used for distance calculation.
06:59:27 <geekosaur> mrm, perhaps you should show us exactly what you are doing
06:59:28 <geekosaur> @paste
06:59:28 <lambdabot> Haskell pastebin: http://lpaste.net/
06:59:32 <byorgey> mrm: you might need to reload emacs, I think haskell-mode caches some info about installed packages
06:59:40 <geekosaur> ^ code to the pastebin not pasted into irc
07:00:30 <byorgey> DangerousDav3: OK, then it sounds to me like you should just pick concrete types for everything
07:00:43 <byorgey> I don't think you would really gain anything by trying to make things polymorphic
07:01:03 <DangerousDav3> byorgey: the metric function might get integers, doubles floats or whatever
07:01:56 <geekosaur> DangerousDav3, keep in mind that it's not enough to just say you accept some type --- you also have to provide code that does so *and* that code cannot do so by inspecting the type it received
07:01:57 <byorgey> DangerousDav3: oh, I see.  In that case make the KNNLearner type polymorphic.   data KNNLearner n = KNN Integer (n -> n -> Double)
07:02:24 <pkmx> ph88: beware of the precedence of ($), your line is equivalent to: wp ((text "--" *> return) (T.pack (manyTill anyChar eol)))
07:02:29 <byorgey> where  n -> n -> Double  is the metric function that gives you the distance (a Double) between two things of type n
07:02:39 <DangerousDav3> byorgey: how can I make constraint that the n is a number?
07:02:44 <mrm> Ah, thanks, reloading worked.
07:02:55 <byorgey> DangerousDav3: Why do you need it to be a number?
07:02:57 <infandum> What is the best library for sparse matrices?
07:03:14 <DangerousDav3> byorgey: because metric is between numbers?
07:03:19 <byorgey> why not Strings?  Or Trees?  As long as you have a metric function it should still work, right?
07:03:22 <mrm> I initially killed the interpreter buffer and reloaded, but didn't realize the process was still going on in the background.
07:03:26 <DangerousDav3> byorgey: the relevant metric(actually vectors)
07:03:47 <MarLinn> tdammers: well they would have the (semi-generated) js code. No one would even need to know your dirty little Haskell secret. Again: provided the output of the generators is of high enough quality. 
07:04:02 <byorgey> right, typically n will actually be a vector of numbers, right?
07:04:18 <ph88> pkmx, that's what i intended .. i think ^^
07:05:09 <DangerousDav3> byorgey: I can't make it polymorphic because it is an instance of a class of a data type and not a data constructor
07:05:32 <pkmx> ph88: `text "--" *> return` will not type check
07:06:09 <MarLinn> tdammers: afaik ghcjs generated js has a lot of rts stuff that you wouldn't want to pass on as human-maintainable code. But maybe one of the alternatives produces something more... plain
07:06:49 <byorgey> DangerousDav3: sorry, I don't think I understand what you mean
07:07:08 <mrm> byorgey: Thanks :-)
07:07:21 <byorgey> mrm: sure, glad it worked =)
07:08:14 <NickHu> byorgey: It's kinda contrived, but you can do this:
07:08:20 <NickHu> f :: (Num a, Num b, Show a, Read b) => a -> a -> b
07:08:22 <NickHu> f x y = read $ show x ++ "." ++ show y
07:08:23 <tdammers> MarLinn: not worth it
07:08:44 <tdammers> MarLinn: once you know the right architecture and all that, and you're disciplined enough, writing the JS by hand is OK
07:08:44 <NickHu> And then have to call it by explicitly annotating the return type you want lol
07:08:57 <tdammers> MarLinn: no worse than the alternatives anyway
07:09:03 <byorgey> NickHu: yes, and if you ask for an Integer it will crash ;-)
07:09:05 <pkmx> ph88: i think you probably want something like: text "--" *> (T.pack <$> manyTill anyChar eol)
07:09:09 <tdammers> MarLinn: frankly, my JS looks a lot like Lisp anyway
07:09:21 <NickHu> byorgey: Hey you asked for a function, not necessarily a good one
07:09:25 <byorgey> haha
07:11:17 <NickHu> I just tried to look up my local Haskell usergroup but they haven't done a meetup since 2014 :(
07:13:47 <ph88> pkmx, i changed it as your suggestion https://paste.fedoraproject.org/422909/14731711/
07:14:54 <pkmx> ph88: what's `wp`?
07:14:59 <ph88> with position
07:15:01 <geekosaur> that shadowing of `space` seems worrisime
07:15:07 <geekosaur> *worrisome
07:15:28 <ph88> pkmx, wp :: Parser a -> Parser (M.SourcePos, a)      wp parser = do;  pos <- M.getPosition;  a <- parser;  return (pos, a)
07:15:35 <geekosaur> probably safe but best not done
07:16:14 <ph88> space = wp $ T.pack <$> some M.spaceChar
07:16:39 <geekosaur> and, I think you cannot use $ where you did --- needs to be an applicative, like what you just showed
07:16:55 <MarLinn> tdammers: I guess if you'll pass on the codebase soon anyway it's no use trying to change the approach that works. Especially if you can make them learn Lisp XD
07:17:01 <geekosaur> because manyTill does not produce a String, it produces a Parser String
07:17:15 <ph88> geekosaur, ah that's probably it !
07:17:35 <NickHu> Does anyone have any suggestions of good haskell podcasts to listen to? I'm just about to finish the Haskell cast
07:17:57 <ph88> hhmm it's not .. still same error
07:18:21 <sm> http://softwareengineeringdaily.com had one haskell episode recently
07:19:16 <pkmx> ph88: it's `T.pack <$> manyTill anyChar eol`, not $
07:19:43 <ph88> pkmx, yes geekosaur just told me .. i already changed this part .. but i get the same error as in my paste
07:21:02 <ph88> here is a new paste  https://paste.fedoraproject.org/422917/71634147/
07:21:20 <geekosaur> I don't think it would be literally the same error, just a similar one from a similar mistake elsewhere
07:22:42 <DangerousDav3> when I declare a data type as an instance of type class, instance typeclass (t
07:23:14 <tsahyt> Hello! I was wondering, how do you go about placing the right version bounds for libraries? The library I'm working on didn't build on the production machine at first because Control.Monad.Except was added to mtl in a later version than the one installed there. That got me thinking, what's the most efficient way to find which version bounds one should place? Ideally without being too restrictive of course.
07:24:00 <ph88> geekosaur, the line position matches :/
07:25:17 <geekosaur> mrrr. it's confused about what monad you're in
07:26:29 <ph88> ooh i see
07:26:56 <ph88> I thought i was always in the Parser monad
07:27:41 <geekosaur> the ((,) M.SourcePos) tells me it thinks it's in ((->) r) for some reason
07:27:59 <geekosaur> partially applied tuple constructor as the function
07:28:58 <mnoonan> merijn: the other day you mentioned ghc blowing up on data types with 20+ constructors.. I was planning on making use of some of those, is there something specific I should watch out for?
07:29:38 <merijn> mnoonan: It can take a lot of memory and time to compile modules with them. Especially if you use deriving
07:29:48 <merijn> mnoonan: Might wanna see if manual instances ends up compiling faster
07:29:58 <ph88> geekosaur, which function is a partially applied tuple constructor in my code ?
07:30:44 <geekosaur> \a -> (M.SourcePos, a) -- I am not seeing why though
07:30:57 <infandum> I'm having trouble understanding the linear library. Let's say I have an IntMap, x, how can I get the "column" 5 from it? It seems like, from the example in the documentation, view (column _5) x would work, but the types are ambiguous.
07:31:05 <geekosaur> it almost feels like now an applicative is being used when it shouldn't, so it's treating the tuple as the applicative
07:31:58 <ph88> geekosaur, maybe because wp doesn't guarantee to give back (M.sourcePos, Text) ?
07:32:18 <geekosaur> looks to me like it does via the type signature, though
07:32:22 <ph88> oh ok
07:32:30 <ph88> how can i debug this ?
07:32:31 * geekosaur is too tired for this :/
07:33:07 <geekosaur> I still find myself wondering if the `space <- space` is contributing to this somehow. but it should expand to a lambda, not a recursive let...
07:34:31 <ph88> geekosaur, i have a record with a field called text   maybe this is going wrong with    text "--"  ?
07:34:53 <geekosaur> uh. that could be relevant, yes
07:35:14 <geekosaur> reusing names like that is just begging for confusing type errors
07:35:42 <ph88> so i should use hungarian notation for record fields or is there a better solution 
07:35:44 <ph88> ??
07:36:26 <geekosaur> I think you're stuck with hungarian notation or similar, or qualified imports (which end up being the same thing with slightly different syntax)
07:36:34 <ph88> like if i prefix all record fields with r_ i know it's a record function
07:36:57 <ph88> i already heard that records in haskell are pretty bad, this is the first time i use a record
07:37:05 <ph88> maybe this is why they are bad
07:37:11 <geekosaur> pretty much, yes
07:37:56 <ph88> is this fixed in the new ghc ?
07:38:09 <geekosaur> field projection functions cause conflicts, and the stuff being worked on doesn't help with *this* case because the conflict is now between a projection function and a normal function, not two different projection functions
07:38:57 <cocreature> it’s weird that you don’t get an error if both the record text and text from parsec are in scope
07:39:41 <geekosaur> presumably they're not in the exact same scope, so the record one shadows
07:39:57 <pkmx> well, parsec doesn't have `text`, what he wants is `string` I think
07:40:02 <ph88> i've read this before https://nikita-volkov.github.io/record/  maybe i can use this safely ?
07:40:27 <pkmx> :t Text.Parsec.string
07:40:29 <lambdabot> Text.Parsec.Prim.Stream s m Char => String -> Text.Parsec.Prim.ParsecT s u m String
07:40:34 <cocreature> ph88: I would just prefix record names.
07:40:36 <geekosaur> -Wname-shadowing (-fwarn-name-shadowing) might help
07:40:43 <ph88> cocreature, i use megaparsec and i put import qualified
07:40:55 <geekosaur> so try M.text
07:41:13 <cocreature> megaparsec doesn’t seem to have a “text” parser either
07:41:17 <ph88> yes i use M.string ^^
07:41:19 <cocreature> I think pkmx is right, you want string
07:41:31 <cocreature> you don’t your code calls “text”
07:41:38 <geekosaur> hm, right
07:41:53 <cocreature> so name shadowing or prefixing won’t help. your just calling the wrong thing
07:41:57 <geekosaur> this is not string as in String but string as in a random string of text input
07:41:57 <pkmx> so you ended up using a record selector that is completely unrelated, hence the confusing error
07:42:00 <slavam2605> @pl \x -> x
07:42:00 <lambdabot> id
07:42:17 <geekosaur> *textual input
07:42:24 <geekosaur> too many English overloads >.>
07:42:50 <slavam2605> @pl \f -> a (b (c, d f) . e) . g
07:42:50 <lambdabot> (. g) . a . (. e) . b . (,) c . d
07:43:05 <ph88> i wish i could just use dot-notation like    record.field    person.name
07:43:42 <geekosaur> dot means too many things already
07:43:42 <cocreature> the problem is that . is already used for function composition
07:43:42 <merijn> ph88: On the one hand, yes. On the other, what would you turn into function composition if not . (assuming you were designing a new language?)
07:43:56 <cocreature> but iirc there was a proposal for this at some point
07:44:10 <geekosaur> everone wants that, it will never happen unless (.) goes away, breaking pretty much every Haskell program in existence
07:45:22 <ph88> eh i think it's a big difference between "." and " . " visually
07:45:54 <cocreature> ph88: but you don’t need to use spaces if you use . for function composition
07:46:00 <cocreature> :t \f g -> f.g
07:46:02 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:46:09 <geekosaur> (which already means that qualified syntax has some screw points)
07:46:20 <pkmx> lens and makeFields can get you quite close
07:46:43 <geekosaur> M.x means different things if M is a qualified module vs. a constructor
07:47:01 <geekosaur> which are different namespaces so you can have both
07:47:04 <chreekat> You're still left with the fight between type-directed name resolution and type inference though, right? If we had a record.field operator, that is.
07:47:32 <geekosaur> basically . is a tangled mess already and any attempt to use it for record.field can only make it worse
07:48:41 <EvanR> space/lackthereof considered harmful
07:50:52 <pkmx> hmm i never considered what would happen if you have a constructor and qualified import of the same name
07:51:25 <pkmx> seems like C.x always parses as qualified name while C . x is function composition
07:51:42 <geekosaur> yes. there's a note somewhere in the ghc users manual about this
07:51:55 <MarLinn> I suppose if we want a single-char record-field connector, we would have to look at unicode anyway - so why not just use a unicode dot...
07:52:13 <geekosaur> `o` >.>
07:52:38 <MarLinn> Record`o`field?
07:52:43 <MarLinn> sounds irish
07:53:58 <Cale> It still occasionally makes me sad that they went with '.' for the module qualification syntax
07:54:30 <MarLinn> what would have been your preference?
07:54:39 <geekosaur> yeh, you can see why old Ada (and old Perl) used ' for module qualification and other languages use ::, etc.
07:54:47 <Cale> I don't know what other thing would be ideal, but something which isn't the most commonly used infix operator would be better.
07:56:59 <lyxia> : for type annotations, :: for qualification, screw lists
07:57:18 <EvanR> forward slash
07:57:25 <EvanR> wait, backslash!
07:57:37 <EvanR> C:\Data\Map
07:57:38 <geekosaur> so much for lambdas >.>
07:57:38 <MarLinn> @hoogle (\)
07:57:41 <lambdabot> Data.List (\\) :: (Eq a) => [a] -> [a] -> [a]
07:57:41 <lambdabot> GHC.OldList (\\) :: (Eq a) => [a] -> [a] -> [a]
07:57:41 <lambdabot> Data.IntMap.Lazy (\\) :: IntMap a -> IntMap b -> IntMap a
07:58:13 <geekosaur> "we're out of syntax"
07:58:14 <MarLinn> aww.. we could have so much more craziness...
07:58:56 <pkmx> Control\Monad\State\Class
07:58:58 <pkmx> eww
07:59:20 <EvanR> \ as a separator just looks drunk
07:59:27 <[k-> reminds me of windows
07:59:33 <MarLinn> @ is only used in patterns, right?
07:59:41 <geekosaur> visible type application in ghc8
07:59:49 <MarLinn> ah, yeah.
07:59:51 <EvanR> > let (@) = (+) in 2 @ 2
07:59:53 <lambdabot>  <hint>:1:6: error: parse error on input ‘@’
07:59:57 <EvanR> noooo
08:00:04 <pkmx> could just use /, and it will go nicely with the directory layout in filesystem
08:00:17 <geekosaur> but then you have a conflict with division
08:00:26 <MarLinn> Class@State@Monad@Control...
08:00:29 <geekosaur> haskell's version of perl's confusion between division and s//
08:00:44 <MarcelineVQ> division wouldn't start with an item with a capital though
08:01:15 <EvanR> spaces around operators anyone?
08:01:18 <jonored> MarcelineVQ: It could, though.
08:01:36 <pkmx> EvanR: yes! and lisp-case
08:01:41 <jonored> It might be a nullary constructor for a type that has division.
08:02:32 <MarcelineVQ> :(
08:07:03 * MarLinn .( import Control{Monad{State{Class}}} )
08:08:21 <[k-> nonononono
08:09:36 <EvanR> i thought .•( was literally part of the suggestion
08:10:08 <MarLinn> it's my version of ". o O ( ... )"...
08:10:32 <MarLinn> but  was one of the options I had in mind when I mentioned unicode
08:11:47 <ph88> maybe sometime .. https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
08:14:46 <Cooler> instance Functor IO where  
08:14:46 <Cooler>     fmap f action = do  
08:14:46 <Cooler>         result <- action  
08:14:46 <Cooler>         return (f result)  
08:15:00 <Cooler> doesn't the <- operator use bind?
08:15:12 <Cooler> does that mean it has to be a monad first to be a functor?
08:16:17 <EvanR> nope
08:16:45 * hackagebot functor-infix 0.0.4 - Infix operators for mapping over compositions of functors. Lots of them.  https://hackage.haskell.org/package/functor-infix-0.0.4 (vi)
08:16:45 <EvanR> actually yes, in that case. but in general no
08:17:28 <Cooler> EvanR, but isn't Applicative F => Monad F ?
08:17:42 <Cooler> and Functor F => Applicative F?
08:17:59 <EvanR> thats what the class declarations look like
08:18:29 <Cooler> so how can you use >>= in the Functor instance?
08:18:37 <EvanR> it means that if you have a monad, then it has to have an applicative, and by transitivity, functor (the arrow is backwards)
08:18:49 <EvanR> it doesnt mean that monad must be defined in terms of fmap
08:20:10 <EvanR> fortunately because that would be a ridiculous restriction to have "just because"
08:21:28 <Cooler> EvanR, what?
08:21:46 <EvanR> note that you can get into trouble if Monad and Functor were defined in a recursive way for a given type
08:22:01 <EvanR> if you do it wrong, then fmap or >>= will loop
08:22:24 <Cooler> so you CAN do it this way?
08:22:47 <NickHu> Cooler: All monads are also functors
08:22:58 <pkmx> you can't use >>= if you only have a Functor f, but in the instance declaration you already know f ~ IO, so you can use all classes that IO is an instance of
08:23:01 <EvanR> yes, you wrote the default fmap for any monad
08:23:05 <Cooler> NickHu, no we are talking the other way around
08:23:18 <NickHu> In Haskell, all monads are applicative functors and all applicative functors are functors too
08:23:19 <MarLinn> Cooler: if you have a monad you can always implement fmap in that way. That's basically the *reason* why Functor => ... => Monad
08:23:38 <thomasd> has anyone here ever used cookies in web.spock.shared/
08:24:30 <Cooler> EvanR, so why would anyone instance Functor and Applicative first?
08:24:30 <EvanR> Cooler: another similar situation is the default implementation == as not /=,  and also /= as not ==
08:24:46 <Cooler> why not leave the default implementation as is?
08:24:49 <EvanR> you have to define something as a base
08:25:16 <Cooler> why not instance Monad directly and leave fmap to the default
08:25:23 <NickHu> Cooler: You can write a more efficient implementation than the one that's given to you
08:25:27 <EvanR> sometimes thats more convenient sometimes its not
08:25:29 <NickHu> sometimes
08:25:52 <EvanR> in the case of IO the monad action is really the primitive
08:26:07 <EvanR> well the primitive has the type of bind
08:26:30 <EvanR> in some other type fmap might but its own operation and >>= builds on that
08:26:54 <ph88> hey guys, i have a function where the first argument is a do block. So i do    func $ do ...          but now i have added a second argument to my function .. where can i place this argument? on the line after return ?
08:27:40 <EvanR> you can do func (do ... \n ... \n) x y but thats going to look ugly
08:28:11 <EvanR> rearrange the order of arguments or do func foo x y where\n  foo = do
08:28:28 <ph88> aah ok
08:28:30 <pkmx> flip func y $ do ...
08:28:40 <ph88> what's better   where   or let .. in ?
08:29:09 <EvanR> flipping might be possible, theres also func $$ x $$ y $$ do ... if its more than one argument
08:29:27 <EvanR> but consider the poor children
08:31:07 <xcmw> Why is this template haskell code erroring? http://lpaste.net/185524
08:31:08 <merijn> ph88: I would always say where
08:31:22 <Welkin> because it's template haskell
08:31:40 <merijn> xcmw: I would say that 'a' is a variable, not a name
08:32:13 <ph88> what's this parse error here ?   https://paste.fedoraproject.org/422990/14731759/
08:32:37 <Cooler> why are parsers monads?
08:32:39 <EvanR> ph88: ive tended to put almost everything in a function in a big main where
08:32:43 <Cooler> reader monad?
08:33:07 <Welkin> because otherwise they would be useless
08:33:08 <ph88> Cooler, i think because they can succeed or fail while parsing
08:33:12 <EvanR> ubt for more sequential reading you can
08:33:18 <EvanR> let x = ... in
08:33:20 <Welkin> monads let you make decisions at each point in the computation
08:33:21 <EvanR> let y = ... in
08:33:23 <EvanR> ...
08:33:43 <merijn> ph88: Not indented enough
08:33:46 <EvanR> but where more easily lets you have multiline and nested ...
08:34:11 <merijn> ph88: As soon as you indent less than 't' it will insert an implict closing } for the where
08:34:55 <Cooler> Welkin, hmm?
08:35:02 <Cooler> what do you mean?
08:35:16 <Cooler> i would think parsers are simple string operations
08:35:18 <ph88> merijn, bringing the indentation up to   do   would probably be nicest, no ?
08:35:32 <ph88> Cooler, that can fail if it's not the right string
08:36:42 <NickHu> Cooler: Parsing is more like walking through tokens to generate a syntax tree
08:36:44 <Cooler> ph88, so just return a Maybe Int
08:36:52 <Cooler> Maybe a
08:37:43 <jonored> Cooler: Maybe is a monad.
08:37:59 <merijn> ph88: I would go with this: http://lpaste.net/33015542453370880
08:38:32 <geekosaur> Cooler, parsers have state (the current parse position), and often need to be able to make decisions based on what has already been parsed
08:38:35 <jonored> it's a hard pattern to avoid, and if you can't avoid it, you might as well supply the common interface and get access to the generic monad stuff.
08:39:14 <geekosaur> the former puts you in applicative, the latter in monad (but you can still use applicative when it doesn't need to make such a decision)
08:40:49 <Cooler> geekosaur, isn't decision making just a if else?
08:41:09 <Cooler> or switch case
08:41:13 <EvanR> saying something can be encoded as a bunch of if then else doesnt say much
08:41:29 <geekosaur> the question is not the condition, but the value you are testing
08:41:34 <geekosaur> you can't get that value with Applicative
08:41:41 <geekosaur> you can with Monad
08:42:13 <geekosaur> more specifically, Applicatives cannot make a decision *based on the result of the previous action*
08:42:16 <Welkin> that is the difference between applicative and monad
08:42:19 <EvanR> Applicative doesnt let you change the course of the computation, in a sense
08:42:56 <Cooler> when you say computation, doesn't that involve decision making?
08:43:08 <EvanR> no!
08:43:08 <geekosaur> all they can do is pass that result on to something else; they can't inspect it. to inspect it, you need something stronger: Monad
08:43:39 <EvanR> deterministic computation, all decisions have been made and theres only one next action
08:44:07 <EvanR> or next state
08:45:02 <ph88> anyone know a better way to write this function?     char char version = ter (T.pack . (\x -> [x]) <$> M.char char) version
08:45:29 <pkmx> ph88: what?
08:46:05 <Welkin> `\x -> [x]` can just be `pure`
08:46:07 <ph88> refactor
08:46:16 <infandum> Is there a reason why this function: 
08:46:16 <infandum> "lookupWithError err x = fromMaybe (error err) . Map.lookup x" takes up 67% of the memory in my program? Is it that function in particular or the function calling it?
08:46:24 <ph88> how it knows which pure to choose ?
08:46:37 <Welkin> because of T.pack?
08:46:45 <geekosaur> infandum, 67% of the memory?
08:46:52 <ph88> ah ok
08:46:56 <infandum> ya
08:47:00 <infandum> It's a big map
08:47:04 <infandum> called lots of times
08:47:07 <ph88> i tried to map   [] over a char at first .. didn't work ^^
08:47:13 <Welkin> :t Data.Text.pack . pure
08:47:15 <lambdabot> Char -> T.Text
08:47:21 <ph88> Ye !
08:47:24 <geekosaur> ok, then my assumption is that it's forcing all the values in the Map
08:47:34 <jonored> ph88: Same as return, in fact. return would also work in that position, but imposes more constraints for no useful reason.
08:47:36 <infandum> geekosaur: I'm using a strict map
08:47:41 <pkmx> ph88: I think you really need to avoid reusing same names, it is getting confusing :o
08:47:51 <infandum> It's a simple String -> Int map
08:48:20 <infandum> Basically, I need to convert the Strings to rows and columns in a matrix, so I have an ID map that I need to call for the conversion
08:48:24 <pkmx> btw, Data.Text has singleton
08:48:27 <ph88> pkmx, which same names ?
08:48:28 <pkmx> :t Data.Text.singleton
08:48:30 <lambdabot> Char -> T.Text
08:48:48 <geekosaur> are you certain of that? Map is a bit weird: "strict" and "lazy" Maps are the exact same thing, it's the *functions* that differ between them. accidentally use a Data.Map.Lazy function instead and your strict Map isn't so strict any mroe
08:49:19 <EvanR> didnt realize that
08:49:23 <infandum> geekosaur: I imported Data.Map.Strict as Map, which is in that function, so it should be good
08:49:39 <EvanR> type safety be damned
08:49:56 <pkmx> ph88: the `char` in your example, it is both the name of the function and argument
08:50:01 <ph88> i changed the function to this now:    char c = ter $ T.singleton <$> M.char c
08:50:38 <pkmx> ph88: yeah that looks good
08:51:04 <DangerousDav3> Question about polymorphism in haskell: http://pastebin.com/sKxVKz0Y
08:51:12 <hexagoxel> infandum: not if you use any instance methods on the map.
08:51:44 <infandum> hexagoxel: What do you mean? I only am using the Map functions, no generalized functions
08:51:57 <EvanR> DangerousDav3: so, you probably want to start with not using type classes for this
08:52:10 <Cooler> EvanR, with regards to decision making, certain computations can be rewritten as branchless
08:52:21 <Cooler> like branchless min and max
08:52:27 <Cooler> or abs
08:52:39 <EvanR> create a record with train and classify functions in it
08:53:04 <hexagoxel> infandum: ok. i just point out that e.g. fmap is Map.Lazy.map, even for the strict Map.
08:53:04 <DangerousDav3> EvanR: So use pattern matching for everything?
08:53:05 <EvanR> then you can have many implementations of that interface
08:53:08 <Cooler> so is decision making a fundamental limitation that you have to surpass using a monad?
08:53:27 <Cooler> or can you refactor the computation so its branchless sometimes?
08:53:41 <EvanR> Cooler: on a more abstract level im going to say computation isnt about decision making
08:53:42 <infandum> hexagoxel: Ah, that's good to know. But in this case I'm not using that, only using the lookup function from Data.Map.Strict
08:53:52 <{AS}> Is there a reason why there is not if_then_ :: Default a => Bool -> a -> a ?
08:54:33 <anohigisavay> hi.
08:54:46 <Cooler> EvanR, sure but do you get what i am trying to say?
08:54:49 <EvanR> Cooler: as far as monads go, thats just an interface to adhere to, not a magic new ability
08:55:07 <pkmx> does there exist a library that can serialize cyclic structures?
08:55:09 <EvanR> DangerousDav3: not necessarily, that doesnt follow what i was saying
08:55:15 <anohigisavay> how do you guys deal with data constructor name conflicts?
08:55:39 <MarLinn> :t bool -- {AS}
08:55:41 <lambdabot> a -> a -> Bool -> a
08:55:47 <{AS}> MarLinn: Ah thanks
08:55:55 <Welkin> {AS}: `case ... of` and guards
08:56:09 <jonored> Cooler: I think you're coming at this backwards: it's not so much that you can't write those things without using the Monad typeclass, it's that once you've got them, you probably have something you could provide appropriate definitions for bind and return for.
08:56:15 <{AS}> Welkin: Yeah, but if I miss the pattern it will return an error
08:56:20 <{AS}> instead of a good default value :)
08:56:44 <{AS}> I am a bit tired of writing `_ -> Nothing` and `else Nothing`
08:56:50 <Welkin> your default is `otherwise` for guards, and `_` for case
08:56:51 <{AS}> but I guess it's not a major issue :)
08:56:51 <Cooler> so it becomes a monad if it involves decision making?
08:56:56 <EvanR> no
08:57:06 <Welkin> lol Cooler 
08:57:16 <infandum> geekosaur: It's crazy though: that function takes up more space than an n^2 matrix of that same n!
08:57:17 <Welkin> just look at the definition of Applicative and Monad
08:57:19 <Welkin> :t <*>
08:57:21 <lambdabot> error: parse error on input ‘<*>’
08:57:24 <Welkin> :t (<*>)
08:57:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:57:27 <Welkin> :t >>=
08:57:29 <lambdabot> error: parse error on input ‘>>=’
08:57:33 <Welkin> :t (>>=)
08:57:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:57:39 <geekosaur> infandum, you did say String
08:57:47 <DangerousDav3> EvanR:  EvanR> then you can have many implementations of that interface
08:57:48 <geekosaur> for grins and giggles, try Text
08:57:49 <Welkin> eh, the types don't tell you
08:57:50 <Welkin> lol
08:57:54 <DangerousDav3> What do you mean by this
08:57:56 <geekosaur> (String has *really* high overhead)
08:57:57 <Welkin> @src (>>=)
08:57:57 <lambdabot> Source not found. Are you on drugs?
08:58:03 <infandum> geekosaur: it might be Text, hold on
08:58:12 <MarLinn> {AS}: Default has its enemies because almost always what is "default" is more dependant on the context than the type
08:58:22 <EvanR> DangerousDav3: if you put the two functions in a record, then whatever uses this interface can just take an argument which is that record type
08:58:25 <infandum> geekosaur: It's text
08:58:44 <Welkin> a good program should be easy to read not easy to type
08:58:53 <geekosaur> ok, then I think we'd need to see more of the program to be able to understand what's going on
08:59:00 <DangerousDav3> Oh I get it, but if each classifier has different records?
08:59:04 <Welkin> maybe you should use perl if you want something you can make obscure
08:59:05 <{AS}> MarLinn: I guess that is true
08:59:08 <infandum> That function is inside of a biggie though: 
08:59:08 <infandum> pairs f l = [f x y | (x:ys) <- tails l, y <- ys]
08:59:18 <{AS}> but F# has kind of support for this :)
08:59:21 <EvanR> DangerousDav3: they wouldnt, why would they?
08:59:48 <EvanR> each instance cant have different methods
08:59:52 <DangerousDav3> EvanR: oops I was confused
09:00:09 <Welkin> geekosaur: I've used String for a huge 18 mb file with parsec
09:00:11 <Welkin> it worked fine o.o
09:00:16 <infandum> where f is a function that basically does a the lookupWithError for each pair
09:00:25 <infandum> and puts them in a tuple
09:00:33 <MarLinn> {AS}: If your type is something common like Maybe, you might gain something by using Applicative or Monad tricks or there might be an even more specialised function
09:00:40 <geekosaur> it will work. if it fuses, it may not even use much memory
09:00:45 <infandum> but I forced evaluation into that tuple (with bang patterns)
09:00:49 <geekosaur> fusion is String's only saving grace
09:00:49 <DangerousDav3> EvanR: Isn't it wired? shouldnt typeclasses be used to set a constraint of functions work over a data type?
09:01:07 <{AS}> MarLinn: It is Maybe
09:01:14 <{AS}> which tricks are you referring to? :)
09:01:30 <geekosaur> when thing fuse you get very low memory usage and very tight code. but if they don't fuse, it's pretty much the worst of all worlds
09:01:53 <EvanR> DangerousDav3: for this purpose, the record way satisfies your requirements. after you understand this way, it would be instructive to go back and see what using typeclasses, if possible, would get you beyond that
09:01:54 <MarLinn> {AS}: that depends on the context... care to lpaste some code?
09:02:06 <ph88> is there a nicer way to write this function?    nter parser version = fmap (\t -> NTer {nt_token=t, nt_version=version}) parser
09:02:24 <EvanR> DangerousDav3: you can also call this way, the "driver pattern", you have interface Driver and many drivers which are just values of type Driver that code can rely on
09:02:24 <{AS}> MarLinn: Is it OK if I make a minimal example?
09:02:36 <EvanR> its very useful
09:02:41 <MarLinn> {AS}: sure!
09:03:24 <EvanR> DangerousDav3: basically, you dont need genuinely different types for this
09:03:52 <Cooler> whats the definition of Applicative Functors?
09:03:55 <qknight> hey. https://notehub.org/kyc3j <- i've passed in semigroups_0_18_1 but why does it not work?
09:03:58 <EvanR> i mean, besides your polymorphic record, data Classifier x y = 
09:04:05 <Cooler> Functors are structure preserving maps between categories
09:04:10 <lpaste> “{AS}” pasted “posInt.hs” at http://lpaste.net/3885251480663359488
09:04:14 <{AS}> MarLinn: ^ :)
09:05:04 <EvanR> Cooler: applicatives are equivalent to operations unit :: f () and fuse :: f a -> f b -> f (a,b) which contains a monoid-like set of laws
09:05:13 <johnw> Cooler: Applicative functors are monoidal functors
09:05:29 <johnw> in CT they have more flavors
09:05:43 <Cooler>  Applicative functors are the programming equivalent of strong lax monoidal functors in category theory. 
09:05:46 <Welkin> just like quarks?
09:05:53 <Cooler> what does that mean?
09:05:59 <infandum> geekosaur: Actually, I might have a way to use that function a lot less if I use it earlier on
09:06:02 <Cooler> strong lax monoidal functors?
09:06:06 <johnw> Cooler: if you google, there is a good answer on stack overflow
09:06:44 <Welkin> https://en.wikipedia.org/wiki/Flavour_(particle_physics)
09:06:45 <Welkin> :D
09:06:53 <Welkin> they spelled flavor wrong though
09:06:58 <Welkin> someone submit a correction
09:07:12 <jonored> DangerousDav3: Does the trainingData's type vary? from the position in your class definition, it looks like that's the learned model.
09:07:21 <MarLinn> {AS}: ok, I thought the context was more complex. Hoogle found several functions of types like Bool -> a -> Maybe a
09:07:34 <{AS}> MarLinn: Ah cool
09:07:43 <{AS}> Thanks
09:08:01 <{AS}> MarLinn: Hmm
09:08:08 <{AS}> I can't seem to find one
09:08:30 <{AS}> One that does what I want :)
09:09:12 <DangerousDav3> jonored: Training data is the processed input(In KNN for example it will be the same but in ID3 decision tree it will be the tree)
09:12:50 <MarLinn> {AS}: https://hackage.haskell.org/package/hsdev-0.1.6.6/docs/Data-Maybe-JustIf.html
09:12:57 <{AS}> MarLinn: Thanks
09:13:20 <MarLinn> {AS}: But you could always fall back to tricks like \n -> n <$ guard (n > 0)
09:13:30 <{AS}> Thanks
09:13:40 <MarLinn> np
09:13:52 <MarcelineVQ> if p a then Just a else Nothing, is pretty succinct
09:15:25 <MarcelineVQ> importing Data.Bool or a hackage module just for that is kinda weird :>
09:16:12 <MarLinn> Yeah... But I must say I don't particularly like the concrete types either. So un-generic.
09:16:13 <Welkin> not just weird, but dumb
09:16:21 <Welkin> and makes it worse for anyone using your program
09:16:52 <sdrodge> Yeah, using standard libraries ruins everything :P
09:17:17 <Welkin> what standard libraries?
09:17:38 <sdrodge> > importing Data.Bool
09:17:42 <lambdabot>  error:
09:17:42 <lambdabot>      Not in scope: data constructor ‘Data.Bool’
09:17:42 <lambdabot>      No module named ‘Data’ is imported.
09:17:56 <Welkin> I never even knew that existed
09:18:00 <infandum> geekosaur: Nevermind, I do need ot use it that many times
09:18:19 <pkmx> Data.Bool is in base
09:18:32 <jonored> DangerousDav3: ...okay, where I was going with that I don't think would be that pretty. Both getting settings like the distance metric into train /and/ getting a model out, without constraining one or the other to be common across all types, probably requires a bit much extensions.
09:18:36 <geekosaur> @let import Data.Bool
09:18:39 <lambdabot>  Defined.
09:19:07 <MarcelineVQ> well bool doesn't really save you anything in this case I just mentioned it to be complete, \p x -> bool Nothing (Just x) (p x)
09:19:09 <MarLinn> The lib I linked to is not so standard though. sry.
09:19:37 <Cale> MarLinn: I do think there's not enough appreciation of the generality of certain algebraic data types
09:21:12 <np356> hello there. I'm still learning haskell and its type system. Is this the right way of designing an authentication system from a type perspective? http://lpaste.net/185557
09:21:21 <ph88> be back later
09:21:27 <np356> or a typeclass would be more appropriate here?
09:22:04 <Cale> np356: Looks sensible. I don't know what the type class would be.
09:22:32 <{AS}> np356: Is it a client application, or do you want to prove something about your authentication system? :)
09:22:35 <np356> Cale, essentially, I would like to distinguish between authenticated an unauthenticated users,machines,services, etc.. at the type level.
09:22:56 <np356> thanks.
09:22:56 <MarLinn> Cale: Could be. Maybe looks so... harmless.
09:22:57 <johnw> that seems reasonable to me too
09:23:09 <np356> cool, thanks everyone.
09:23:23 <Cale> np356: btw, consider using Text instead of String in most real world use
09:23:29 <np356> why?
09:23:46 <johnw> you could say here that Authenticated is a "predicate" on objects, supplying evidence of the authentication that's also available at runtime
09:24:12 <Cale> It's far more compact (String is a lazy linked list of 32 bit wide Char values) and thus faster, and it also has more operations
09:24:32 <Cale> token should probably be a ByteString though
09:24:35 <johnw> you don't need a type class because Authenticated is already generic over any other type
09:24:49 <Cale> Well, depending on what your tokens look like
09:24:56 <Cale> and DateTime should perhaps be UTCTime?
09:25:15 <Cale> I don't know where DateTime would be defined
09:25:17 <np356> {AS}, I'm trying to learn the haskell type system.
09:25:47 <{AS}> np356: Ah, yeah then it is fine as the other said :)
09:26:46 <np356> Cale: https://hackage.haskell.org/package/datetime-0.3.1/docs/Data-DateTime.html
09:26:59 <Cale> huh
09:27:04 <Cale> I've never seen anyone use that :)
09:27:51 <np356> alright, thanks everyone! you're really helpful :)
09:28:53 <Cale> Mostly people use Data.Time.* from the time package, or there's a package called thyme which gives up on using Integer in certain places in order to get more performance -- other than the Int/Integer differences, it's almost a drop-in replacement for time
09:29:42 <pkmx> Does anyone know if there exists a library that can serialize cyclic (tying the knot) structures?
09:30:26 <Cale> pkmx: I generally wouldn't attempt that. If I need serialisation, the graph just gets stored differently in the first place.
09:32:02 <Cale> pkmx: It's difficult to distinguish a cyclic data structure from an infinite one, and when it's somewhat possible, it's usually because you've stuffed vertex IDs into the thing anyway (which you'll assume occur only once in the graph)
09:32:24 <Cale> and at that point, you often aren't much worse off just using a Data.Map or Data.IntMap
09:32:41 <EvanR> otoh there are some tricks with observable sharing
09:32:49 <EvanR> but thats not generally applicable
09:33:22 <Welkin> does anyone actually use anything other than an adjacency list (or matrix) for graphs anyway?
09:33:38 <Cale> Map Vertex (Set Vertex)
09:33:46 <Welkin> it seems impossible to represent an actual graph in any programming language
09:34:03 <Cale> What do you mean by "an actual graph"?
09:34:21 <Cale> A set of vertices and a set of edges?
09:34:25 <Welkin> no
09:34:33 <ggole> Various representations using pointers are pretty common
09:34:36 <Cale> (That's how mathematicians usually define them)
09:34:54 <Welkin> yes, tha tis the easiest way to do it
09:35:02 <Welkin> using an adjacency list
09:35:09 <Cale> That's not a list
09:35:12 <Welkin> "list"
09:35:16 <Welkin> I don't mean a literal linked list
09:35:19 <Welkin> it could be whatever
09:36:03 <Cale> A graph consists of a collection of vertices and the information about their adjacency
09:37:16 <EvanR> Map, Set work for finite graphs
09:38:00 <Cale> There are a bunch of distinct ways to record that information about adjacency, but they're mostly equivalent (well, some ways put orderings on the collection of vertices or edges which otherwise wouldn't be present)
09:38:01 <EvanR> for vertex type V, adjacency is a function V -> _
09:38:30 <EvanR> V -> V -> Prop ;)
09:38:31 <johnw> i think we're mixing theory and representation here
09:38:36 <Cale> Where they differ primarily has to do with performance
09:38:44 <johnw> graphs don't exist
09:38:49 <EvanR> o_O
09:38:56 <Cale> heh
09:38:58 <johnw> but there are lots of data structures that can be used to express graphs
09:39:00 <EvanR> (g : Graph) -> Void
09:39:17 <Cale> Natural numbers don't exist, but there are lots of data structures that can be used to express natural numbers.
09:39:21 <johnw> exactly
09:39:40 <EvanR> data structures to express _ dont exist
09:39:46 <ggole> Data structures don't exist, really - they're just degenerate graphs.
09:39:54 <padre_angolano> EvanR: what is _ ?
09:40:04 <EvanR> {graphs | natural numbers}
09:41:07 <EvanR> the data structure techniques, concepts, and individual instances dont exist
09:41:29 <EvanR> non existence doesnt exist
09:41:41 <Cale> I don't know in which sense people are expecting things to exist or not exist here, but it doesn't seem to be one with which I'm familiar.
09:41:42 <johnw> anyway
09:42:11 <Cale> I mean, these are mathematical concepts, they exist in a formal sense.
09:42:24 <johnw> i meant, exist in the forms of bits in memory
09:42:31 <johnw> but the point is not worth debating
09:42:35 <Cale> They exist as ideas in our heads :)
09:42:36 <Welkin> leci n'est pas une pipe
09:42:43 <Cale> and in books and on blackboards
09:42:47 <johnw> if it didn't make immediate sense, ignore what I said
09:44:02 * ggole crawls into a stove to figure it out
09:44:10 <EvanR> Kiri-kin-tha's First Law of Metaphysics "Nothing unreal exists."
09:44:51 <EvanR> -- star trek IV
09:45:42 <Cale> There's a bit of trouble you can get into because we use the word "exist" for a few too many things.
09:45:48 <Cale> But mostly it's not a problem.
09:46:12 <johnw> when EvanR said "actual graph", that was the point I was making; there is no "actual graph" in the sense that I read him as meaning
09:46:30 <johnw> but since this has all veered into nonsense now, it's better to just get back to code
09:46:40 <Cale> I just don't know what an "actual graph" would be... or what "actual" would mean there :)
09:46:59 <Welkin> you can't have people thinking about things now
09:47:07 <Welkin> just keep your head down and do as you're told
09:47:16 <Welkin> don't ask questions
09:48:08 <Cale> In all of the contexts in which the word "graph" means something to me in the sense that we were talking about it, graphs exist.
09:48:13 <Cale> :)
09:48:44 <johnw> sigh.  I didn't mean that sense of existence.
09:48:52 <johnw> I meant, BITS IN MEMORY, not thoughts that you are able to think
09:49:19 <Cale> But we do certainly arrange bits in memory in ways which we regard to be graphs
09:49:27 <Cale> :)
09:49:52 <Cale> But yeah, the word requires a new definition there
09:50:08 <Cale> and we have some options to pick from
09:51:46 <EvanR> i didnt say actual graph!
09:52:04 * EvanR pouts at the departed johnw
09:52:42 <EvanR> Welkin ffs
09:52:53 <anohigisavay> hi. is there any hashmap-like datastructure that can preserve the order of insertion?
09:53:27 <Welkin> ahihi: use an IntMap
09:53:32 <anohigisavay> like what OrderedDict in python
09:53:42 <Welkin> and track the key
09:53:58 <NickHu> Another common representation of graphs other than an adjacency list is an adjacency matrix
09:54:06 <Welkin> NickHu: already mentioned too
09:54:16 <NickHu> my bad, need better irc filters
09:54:54 <ahihi> Welkin: I refuse
09:55:13 <Welkin> ahihi: ...who are you?
09:55:32 <ahihi> I'm the person you highlighted!
09:55:39 <Welkin> oh
09:55:41 <Welkin> oops
10:06:27 <johnw> Cale: my apologies for arguing; I'm a bit grumpy this morning
10:07:35 <Cale> johnw: No worries, I was just confused :)
10:08:08 <nitrix> Some hackage packages actually have flags (that sometimes modify their API). How do I go about putting those in my cabal file so those are already preselected to ease others work on the project out of the box?
10:08:30 <nitrix> e.g. SDL2 recently got no-linear
10:08:49 <nitrix> *sdl2
10:09:43 <merijn> nitrix: You can't
10:09:48 <maerwald> it's a bug. Cabal doesn't know about flags, so you can't properly depend on them (ofc you can configure cabal to do that, but that's not part of the dependency resolution... the build will just fail)
10:09:58 <merijn> nitrix: Also, kick those package maintainers until they stop
10:10:05 <nitrix> merijn: Seems like stack can
10:10:24 <maerwald> that's not a problem that should be solved that way
10:11:32 <merijn> No, it should be solved by Backpack making feature flags redundant, so that they're only used for compile time build tweaking, instead of controlling the API
10:11:33 <nitrix> Should or shouldn't, there are still many packages that have those flags and cabal is unequipped to make this easy.
10:11:41 <hvr> nitrix: that's by design
10:11:46 <nitrix> I'll just use stack and make it clear I wont support cabal anymore.
10:11:59 <hvr> nitrix: stack can't either, since it uses cabal
10:12:32 <hvr> nitrix: and the kind of flag settings you can set in stack.yaml, you can set via cabal.project for cabal
10:12:35 <nitrix> hvr: I refered to cabal as the executable, which is cabal-install, not Cabal the library.
10:12:57 <nitrix> stack doesn't uses cabal, it uses Cabal.
10:13:08 <hvr> nitrix: fair, but you can't declare a dependency on a flag setting inside a .cabal file
10:13:21 <merijn> hvr: Cabal can't handle it either, afaik?
10:13:21 <nitrix> hvr: Why can I do it inside stack.yaml?
10:13:30 <merijn> hvr: Which is also by design
10:13:33 <merijn> eh
10:13:35 <hvr> merijn: indeed
10:13:37 <merijn> s/hvr/nitrix
10:13:40 <nitrix> If stack has it, why cabal is doing such a poor job?
10:14:00 <hvr> nitrix: what you do in stack.yaml  is the equivalent of using a freeze-file 
10:14:28 <hvr> nitrix: i.e. you impose additional constraints on your install-plan; but that's outside of .cabal
10:14:41 <nitrix> hvr: Except the project wont compile if said flags happens to modify the API...
10:14:57 <nitrix> hvr: And I know many packages do this on hackage.
10:15:26 <hvr> nitrix: well, as was already said: those packages are doing it wrong
10:15:56 <nitrix> There's crowd that seems to think "this is not the intended use" and another "well, there's no better solution right now", and in the middle are the users that are stuck with a build tool that doesn't have better support for either cases because the community hasn't settled on the matter.
10:16:03 <nitrix> Meanwhile, stack is proactive.
10:16:14 <maerwald> nitrix: you don't fix those problems by using methods of a tool that can be optionally used on top of cabal. There are only two options: 1. make cabal understand package configuration (that's the devils path, ask gentoo devs) 2. don't change API based on flags
10:16:14 <merijn> nitrix: Cabal (note, cabal, not cabal-install) was intentionally designed to make this hard to stop people from doing things they shouldn't
10:16:50 <geekosaur> bsd ports and macports have a lot of experience with this as well (gentoo's the latecomer)
10:16:51 <nitrix> maerwald: Yeah but you don't get it. I'm a user.
10:16:57 <nitrix> maerwald: It's not my choice.
10:17:03 <merijn> nitrix: Of course, people never fucking listen, even if (especially if) you try to stop them from hurting themselves
10:17:05 <hvr> maerwald: btw, we may want an FAQ entry on why build-depends doesn't and shouldn't support flag settings
10:17:11 <maerwald> nitrix: it makes it worse for users too, because the resolver becomes a LOT more complex
10:17:20 <hvr> maerwald: if you have any pointers... :-)
10:17:56 <geekosaur> flags = combinatorial explosion. they look viable when only one or two packages are affected, but it doesn't scale at all
10:18:23 <saurabhnanda> how can I "lift" a record's field (value0 into the type-system? For example. if I have a Tenant record having a tenantStatus field, how do I ensure (at compile-time) that certain functions are called only on a Tenant with tenantStatus=active?
10:18:26 <maerwald> there are package manager that can deal with it, but it opens a lot of edge cases and complexity that must be implemented
10:18:40 <maerwald> and it requires users to understand what is happening too
10:18:46 <maerwald> because resolution errors become more complex
10:18:47 <geekosaur> stack sweeps this under the rug; one hidden price they haven't run into yet (but will eventually if they continue to support it) is making stackage useless unless it includes a particular flag setting
10:18:50 <nitrix> geekosaur: I agree... but meanwhile, cabal allows projects to define flags, so it should also also flags on dependencies.
10:18:51 <geekosaur> for every package
10:19:31 <nitrix> geekosaur: You can't create problems like that and not offer at least _one_ solution.
10:19:35 <nitrix> What do I do as the user?
10:19:35 <merijn> nitrix: The flags are there because sometimes you need to do things like change implementations/etc. to be portable, like windows, etc.
10:19:36 <maerwald> nitrix: no, it should not
10:19:52 <maerwald> nitrix: you file a bug upstream
10:20:13 <nitrix> maerwald: Meanwhile I have to use that library...
10:20:17 <merijn> nitrix: Adding flags to the dependencies will make things objectively worse in the long run, so that's never an option
10:20:25 <maerwald> nitrix: well, you put that configuration in your local cabal file
10:20:39 <nitrix> maerwald: This is what's terrible.
10:20:41 <geekosaur> all the ports-style package systems have run into this, all of them have tried to solve it. all of them have failed
10:20:43 <merijn> nitrix: Patch it and yell at the maintainer. You're suggesting we poison/destroy everything to save some immediate hassle now
10:21:08 <nitrix> merijn: If every users has the same local configuration, it makes the local part unecessarily hard for no reason.
10:21:31 <nitrix> Just like the dependency hells with C libs.
10:21:35 <merijn> nitrix: If every user has the same local configuration you can just distribute the compiled library
10:21:58 <prsteele> saurabhnanda: you could split into an InactiveTenant and ActiveTenant data structures, but then there would be some overhead for functions that can operate on both. maybe a typeclass for the shared functionality
10:22:02 <nitrix> merijn: Please hear me.
10:22:20 <geekosaur> are yoiu listening to anyone else, in return?
10:22:25 <maerwald> geekosaur: it scales, but it also exposes users to that complexity
10:22:26 <nitrix> merijn: What the library does is out of my control.
10:22:27 <merijn> nitrix: I understand your issue, I've run into it too. I also understand that your suggestion is worse than the current pain I have
10:22:44 <maerwald> geekosaur: and I don't think it makes really sense for the haskell ecosystem, it probably just makes thing worse
10:22:56 <geekosaur> maerwald, please tell that to the freebsd ports maintainers, and the macports maintainers, and the gentoo maintainers
10:22:57 <merijn> nitrix: Yes, so patch it, use a different one, or depend on a fork
10:23:08 <geekosaur> they will laugh at your naivete
10:23:09 <maerwald> geekosaur: been a gentoo dev for 4 years, so I'll tell that myself
10:23:22 <saurabhnanda> prsteele: I was goofing around with DataKinds and GADTs. Any solutions in that direction?
10:23:31 <merijn> nitrix: The "solution" to your problem as implement by macports, freebsd ports, etc. is to throw countless manhours into fixing things
10:23:36 <maerwald> geekosaur: the problem is not so much the resolver, but the input
10:23:37 <prsteele> saurabhnanda: I haven't used them enough to say, sorry
10:23:38 <merijn> nitrix: It's not a viable solution
10:23:55 <nitrix> merijn: If cabal offer flags, it needs to support dependencies that needs those flags. Not in a local file; for everyone using that project.
10:24:10 <maerwald> geekosaur: writing correct package definitions and not messing up becomes a lot easier with that added complexity, because a lot more cases pile up that can make resolution fail 
10:24:20 <merijn> nitrix: No. Flags are functionally useful in a way that is hard to implement otherwise
10:24:20 <maerwald> s/easier/harder/
10:24:36 <nitrix> Evil or not, you can't have a partial feature that's half there just enough to shot yourself in the foot with no way out.
10:24:38 <merijn> nitrix: That usefulness is NOT controlling dependencies/APIs
10:24:40 <saurabhnanda> prsteele: okay, thanks for your suggestion though.
10:24:52 <merijn> nitrix: It's not a partial feature. It works fine for it's intended purpose
10:25:05 <maerwald> geekosaur: I agree though that it doesn't scale on most distros that tried it, because they don't have strict enough rules for the input
10:25:22 <nitrix> merijn: So you're telling me to fork haskell-game/sdl2 ?
10:25:23 <maerwald> which is basically the thing: let's keep the input simple
10:25:26 <merijn> nitrix: You can't remove them, because that eliminates necessary functionality. And extending the solver isn't viable
10:25:43 <merijn> nitrix: And/or submit a patch upstream that fixes their broken flag usage
10:25:56 <nitrix> merijn: It was _just_ introduced.
10:26:14 <merijn> nitrix: Then better to stop that nonsense now by filing a bug report + fix
10:27:11 * nitrix sigh
10:27:15 <nitrix> I'll fork as better-sdl2.
10:27:39 <MarLinn> saurabhnanda: Maybe try a phantom type with DataKinds. Makes it harder to put tenants in a structure though
10:27:55 <nitrix> merijn: Since the reason why they used flags in the first place was because people couldn't agree on the new API.
10:28:03 <saurabhnanda> MarLinn: by "structure" you mean?
10:28:22 <maerwald> nitrix: how about just making a package sdl2-linear where it's unconditionally enabled
10:28:26 <merijn> nitrix: Uusually I keep a local copy lying around that already has the patch I submit upstream so I'm unblocked and then not actually fork unless the maintainers are stubborn
10:28:37 <nitrix> maerwald: sdl2-no-linear in my case.
10:28:40 <maerwald> or that
10:29:24 <maerwald> although that's not the perfect solution either... depends on what parts of the API is changed
10:29:45 <maerwald> but it at least gets you forward, you can deprecate the package later
10:30:23 <MarLinn> saurabhnanda: lists, maps, sets, etc. Phantom types make it easy to distinguish tenant types by changing, well, the type. But two things with different types in a list needs some extra work, one way or the other
10:30:26 <zv> Is anyone a member of an institution with access to worldscientific?
10:30:38 <nitrix> I would be totally fine with their flag if I had a mean to ensure it'd be automatically provided for people compiling my game.
10:30:51 <Denommus> hi
10:31:01 <nitrix> It's a bad approach only for libraries using other libraries where the flag might conflict.
10:31:10 <nitrix> In my case, it's an executable, it's the end of the dependency chain.
10:31:21 <saurabhnanda> MarLinn: ah okay. But the problem with PhantomTypes is that they can be indexed with **any** type. Not particularly the values of TenantStatus type
10:31:23 <nitrix> I don't see the complexity.
10:31:36 <saurabhnanda> MarLinn: phantom types with DataKinds?
10:32:23 <MarLinn> saurabhnanda: That's where GADTs can help. If your tenant-type-markers are part of a class, you can restrict the marker to that class
10:33:16 <saurabhnanda> MarLinn: "If your tenant-type-markers are part of a class" >> Please elaborate that
10:33:30 <maerwald> nitrix: you're not thinking globally. Package A depends on 2 flags of package B, which has ~5 flags, totally inconsistent between versions, so now the resolver has not only to figure out which package can be used, but also what to do when there is no valid package... suggest you change configuration? Which one? Which version?
10:33:30 <maerwald> what happend if the maintainer of B bumps the package and a flag vanished and is unconditionally enabled? What about the opposite?
10:33:36 <maerwald> there are so many ways...
10:34:26 <nitrix> maerwald: They have default values.
10:34:33 <maerwald> yeah
10:34:37 <nitrix> maerwald: It just overrides the value by your choice if the flag is found...
10:35:00 <MarLinn> saurabhnanda: preparing some code...
10:35:01 <maerwald> it's not about defaults here
10:35:07 <saurabhnanda> MarLinn: thanks :)
10:35:45 <nitrix> maerwald: The flags are versioned too... when you upgrade to a major version, you obviously would pay attention to those.
10:35:57 <maerwald> you need additional syntax, e.g. gentoo does sys-devel/gcc[openmp(-)] ... which means "if gcc does not have openmp flag, assume the feature is not there, so the resolution must fail"
10:36:02 <maerwald> and that's just one gotcha
10:36:19 <nitrix> maerwald: "Changelog, version 5.6.5, made foobar enabled by default. This better reflects intended use, bla bla".
10:36:31 <maerwald> the defaults are orthogonal to what I'm talking about
10:37:07 <thomasd> has anyone here ever used cookies with spock-0.10.0.1?
10:37:11 <nitrix> maerwald: You're talking about someone getting caught off guard by a newly introduced, removed, or modified flag.
10:37:40 <maerwald> nitrix: it requires a completely different workflow which hackage does not provide at all
10:37:41 <Darwin226> Hey guys. I have a GADT with a case like SomeCase :: Context a => Text -> MyGADT a. When I pattern match on SomeCase, how can I get to the `a` type there? Do I need to have a proxy as a field?
10:37:56 <nitrix> maerwald: How's that any different than a new function, removed or modified?
10:37:57 <maerwald> it requires real coordination, otherwise the dependency graph will be forever broken
10:38:00 <lpaste> MarLinn pasted “Phantom Types demo” at http://lpaste.net/185587
10:38:02 <nitrix> maerwald: That's a problem versioning solves.
10:38:09 <maerwald> no
10:38:11 <MarLinn> ^saurabhnanda
10:38:23 <nitrix> maerwald: There's no such thing. The user of that flag is at the end of the dependency graph.
10:38:31 <saurabhnanda> MarLinn: checking
10:38:38 <maerwald> nitrix: wat?
10:38:44 <maerwald> no
10:38:47 <nitrix> maerwald: sdl2 has this no-linear thing.
10:38:48 <maerwald> you're not thinking globally
10:39:00 <maerwald> you're only thinking about your package which has one dependency
10:39:26 <saurabhnanda> MarLinn: shouldn't it be -- data (TenantMarker m) => Tenant m where ?
10:39:42 <nitrix> maerwald: Of course, because that case could be supported, but it isn't. That's what makes me mad.
10:40:09 <maerwald> nitrix: and I was trying to explain the complexity that introduces to you
10:40:29 <maerwald> complexity that must be solved by a different level of coordination, additional syntax and people understanding what they are doing
10:40:42 <saurabhnanda> MarLinn: also, TenantActive and TenantInactive are no longer an ADT, thus losing the ability to do case matching
10:40:48 <maerwald> you are making the input more complex and allow for more edge cases and resolution failures
10:41:09 <MarLinn> saurabhnanda: No. You can have different constructors with different constraints, therefore the constraint is on the constructors
10:41:21 <saurabhnanda> MarLinn: ah okay
10:41:59 <maerwald> nitrix: and given that people don't seem to be aware of the complexity it introduces I don't think it's a good idea to have it. You'd need to educate people on how to deal with these things.
10:42:15 <MarLinn> saurabhnanda: And yes to case matching. But then the matching is in the types, not the values. The type level equivalent to matching would be classes
10:42:19 <maerwald> otherwise we have another "cabal hell"
10:42:24 <maerwald> and stack would have it too
10:42:39 <nitrix> maerwald: stack already support those flags...
10:42:48 <MarLinn> saurabhnanda: You could go with ADT though, I just didn't bother
10:43:08 <maerwald> nitrix: the resolver?
10:43:42 <nitrix> maerwald: I understand the risks and complexity involved, but why is there no way out in cabal, since Cabal itself introduce this very flag feature, yet its stack that has to take the lead on the matter.
10:43:51 <nitrix> maerwald: The resolver doesn't even need to know about it.
10:43:58 <maerwald> uhm??
10:44:00 <nitrix> You're thinking way, way too far.
10:44:05 <nitrix> My case is me, using sdl2.
10:44:12 <saurabhnanda> MarLinn: basically, how to encode this recurring invariant -- a record's field can have one of many states. We need to ensure that certain functions accept records in a few known states, whereas certain functions can accept records in any state?
10:44:14 <nitrix> maerwald: sdl2 has a flag that I need to use. Period.
10:44:24 <nitrix> maerwald: stack supports it, cabal doesn't.
10:44:27 <maerwald> nitrix: you asked for a feature in cabal though ;)
10:44:27 <nitrix> That's a problem.
10:44:31 <maerwald> so I explained why it isn't there
10:44:47 <roberth> DataKinds question: suppose we have f :: (ka, kb) -> *, which is a type constructor that takes a lifted pair of things. We can then implement forward :: forall (f :: (ka, kb) -> *).
10:44:47 <roberth>        (forall (ab :: (ka, kb)).     f ab)
10:44:48 <roberth>     -> (forall (a :: ka) (b :: kb).  f '(a, b))
10:44:48 <roberth> forward x = x
10:44:48 <roberth> Can we also implement backward :: forall (f :: (ka, kb) -> *). (forall (a :: ka) (b :: kb). f '(a, b)) -> (forall (ab :: (ka, kb)). f ab) ? If possible, it is not trivial.
10:45:26 <nitrix> maerwald: It seems like a falacious argument. I'd sure hope people know what they're doing. It's not a field suited for unicellular oganisms.
10:45:49 <nitrix> maerwald: But I've already a fork of sdl2 made, so I'll just adapt it and fly on my own.
10:46:00 <nitrix> It's really frustrating though.
10:46:23 * Clint wonders why hdiff doesn't have yaml 0.8.18.5
10:46:38 <geekosaur> nitrix, the problem with that assertion is that you assume people can deal with unbounded complexity
10:46:43 <MarLinn> saurabhnanda: Idealistically? Phantom types plus classes for everything plus dynamic wrapping and unwrapping with smart constructors and stuff. Pragmatically? Just switch on the flag and return a Maybe (or something better)
10:46:45 <maerwald> nitrix: you can't have only parts of the resolution. If you allow flags to change API, all the things I told you will happen.
10:47:03 <geekosaur> which is what it becomes as soon as you go beyond what one project for one developer is involved
10:47:09 <maerwald> exactly
10:47:32 <maerwald> we already have problems with people not understanding what upper bounds are for and how to use them
10:47:41 <saurabhnanda> MarLinn: "Pragmatically? Just switch on the flag and return a Maybe (or something better)" >> which "flag" are you referring to?
10:48:49 <nitrix> maerwald: Okay. Let me state the problem again. It's not about the flag being able to change the API or not. That, it can already do and some people are stupid enough to incorrectly misuse the feature. What bugs me out, is that stack lets you specificy a flag for the project (assuming you commit the stack file) but cabal can't.
10:49:04 <MarLinn> saurabhnanda: The value level flag. Also, what prsteele suggested is a nice middle ground for some cases
10:49:12 <maerwald> nitrix: I can do that in my cabal sandboxes
10:49:15 <nitrix> maerwald: In other words, Cabal created a feature that cannot be depended on reliably for homogeneity.
10:49:18 <geekosaur> cabal did, once. the results were not good
10:49:21 <nitrix> maerwald: But why local?
10:49:48 <MarLinn> saurabhnanda: flag = state marker
10:50:02 <saurabhnanda> MarLinn: so, pragmatically move every thing to runtime instead of compile time?
10:50:19 <nitrix> geekosaur: Local configurations are painful. Most of the stuff can and should be shared so that you have a uniform dev environment for everyone.
10:50:26 <saurabhnanda> MarLinn: adding the expected type to the signature is also self-documenting in nature
10:50:52 <geekosaur> but sharing it is exactly what lands you in a complexity soup that rapidly exceeds human comprehension
10:50:55 <maerwald> nitrix: yeah, you can also use containerization for that or whatever
10:51:02 <maerwald> cabal is not a tool for sharing dev environments
10:51:10 <geekosaur> and in such a way that programming a computer to do it for you is also beyond human comprehension :/
10:51:16 <kurt11_> In a cabal file, if I define different executables/test-suites with different dependencies, what are the cabal entries called? Are those packages? Or just cabal entries?
10:53:22 <merijn> kurt11_: I don't think they specifically have a name
10:56:14 <MarLinn> saurabhnanda: You are right. And you can indeed build some machinery for that. The question is: Does the extra machinery help you detect bugs or does it hinder development?
10:57:21 <saurabhnanda> MarLinn: this is the first time I'm trying to put so many verifications at compile-time. I don't know how to tell.
11:01:43 <MarLinn> saurabhnanda: only experience can tell, I guess...
11:07:40 <EvanR> wait what https://twitter.com/puffnfresh/status/773043984843145216
11:07:59 <EvanR> ghcvm?
11:08:02 <EvanR> java??
11:08:26 <Clint> i'm terrified
11:08:42 <geekosaur> yes, it's a work in progress
11:08:51 <geekosaur> which is probably why they're still having problems with IO
11:09:23 <pkmx> Finally! Haskell is enterprise-ready!
11:10:54 <srhb> EvanR: It was/is one of the summer of Haskell projects, I believe.
11:11:50 <merijn> yeah
11:11:59 <srhb> Results to be announced in six days! Very exciting :-)
11:12:44 <MarLinn> Now all we need is a JVM in Haskell...
11:13:31 <NickHu> Apparently way back they did try to target the JVM
11:13:42 <NickHu> I heard it in a Haskell Cast with Simon Peyton Jones
11:14:12 <NickHu> https://overcast.fm/+BH8gDgUWE
11:14:18 <geekosaur> yes, there've been several attempts before
11:14:33 <pkmx> I wonder how that will interact with java's OO system, can we define a new class and inherit from some other java classes in Haskell?
11:14:59 <NickHu> Isn't using the FFI like "all bets are off when it comes to types"?
11:15:14 <geekosaur> I think that's one of the things that causes attempts to target the JVM to founder
11:16:52 <ReinH> NickHu: :)
11:17:06 * hackagebot concurrent-output 1.7.7 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.7.7 (JoeyHess)
11:17:06 * hackagebot lentil 1.0.3.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.0.3.0 (fffaaa)
11:18:14 <EvanR> NickHu: IO generally, for the most part
11:18:42 <the_2nd> I have issues with ambigous "try"s  within : http://lpaste.net/2205150142363860992
11:18:58 <the_2nd> how can I correctly constrain the type to catch the readFile exception(s) ?
11:19:25 <NickHu> Is there a "good way" to have two constructors of different data types to have the same name, or is it universally bad practice?
11:19:30 * MarLinn will be so happy when he can finally run his programs with only 100 times the memory consumption after minutes of startup time. Wohoo!
11:19:56 <EvanR> NickHu: you can put them in different modules
11:20:10 <EvanR> but its going to be easier if they have different names
11:20:14 <NickHu> EvanR: That's no good for me in this particular usecase
11:21:00 <EvanR> you can name them different things and use a type class to pun them later
11:21:17 <NickHu> I'm trying to model input and output from a shell command; input could be the argument list, stdin or some file, output could be stdout or some file etc. I guess they should be different types anyway?
11:21:21 <EvanR> not worth the effort in my experience
11:21:59 <EvanR> sure
11:22:10 <EvanR> especially if output cant be an argument list
11:22:15 <NickHu> It just seems kinda weird to have to have a FileIn and FileOut constructor for what seems to me to be quite connected..
11:23:04 <EvanR> many types are isomorphic but we dont want them to all be the same type or be called all the same thing, the names help keep things straight
11:23:35 <EvanR> up to a certain limit i say use more types
11:24:40 <NickHu> It's just I'm using aeson to parse JSON and I can't help but feel like I'm drowning in type-soup lol
11:24:51 <jle`> having types that are isomorphic being different to the type system is one of the most commonly used type system tricks used for writing maintainble haskell!
11:27:18 <the_2nd> Can anyone help me with my try? Can't get it to work since the result is amigous http://lpaste.net/2205150142363860992 
11:29:14 <EvanR> whats the actual error?
11:30:06 <NickHu> Say I have f, and in the body of f I call g, which is defined in a where clause at the end and uses a closure to access a variable in the body of f. Now I need to use g elsewhere; should I just add an extra parameter to it?
11:30:16 <the_2nd> EvanR, http://lpaste.net/932386302735679488
11:30:20 <EvanR> NickHu: yep
11:30:38 <EvanR> closures are just the lazy way to add extra parameters
11:30:49 <EvanR> and doing partial application
11:31:02 <jle`> NickHu: you can also sometimes get away with a let binding inside f
11:31:22 <NickHu> jle`: How so?
11:31:25 <EvanR> the_2nd: so you need to specify which exception you want on line 2
11:31:32 <jle`> it depends on the specific case
11:31:44 <jle`> you can define g within a let binding inside lf
11:31:46 <jle`> *f
11:31:57 <NickHu> Yeah, then I could just move it to top-level verbatim
11:31:59 <jle`> and the let binding might have the "closure" of everything available in f.
11:32:45 <EvanR> the_2nd: content <- try (readFile ...) :: IO MyException String
11:32:46 <jle`> yeah you'd be moving the definition of g into the definition of f, basically
11:32:50 <NickHu> Oh I see what you mean; in this particular case, I need to call it inside a different instance, so I guess I have no choice but to move it to top level
11:32:54 <EvanR> er IO (Either MyException String)
11:34:36 <the_2nd> EvanR, I think I have to define the readFile exception which is thrown to catch it correctly, but I'll give it a "try" ;)
11:35:16 <joe9> the_2nd: when dealing with exceptions, I found the article on safe-exceptions helpful too.
11:35:43 <NickHu> Is there a way to get ghc to warn me about partial functions btw?
11:36:08 <EvanR> you can warn about incomplete pattern matching
11:36:30 <shachaf> It can warn you about incomplete pattern matches with -Wall.
11:36:44 <shachaf> Of course it can't rule out all partial functions without false positives.
11:36:51 <NickHu> Sorry, I meant in ghci
11:37:03 <shachaf> Same thing in ghci.
11:37:37 <the_2nd> EvanR, seems incorrect
11:37:53 <the_2nd> cabal repl
11:37:55 <the_2nd> txtFromFile "ssdfsdf"
11:37:56 <the_2nd> *** Exception: ssdfsdf: openBinaryFile: does not exist (No such file or directory)
11:38:09 <EvanR> which exception did you try to catch?
11:38:49 * geekosaur wonders if this is because it's lazy I/O --- have to force the first char *inside* the try to get the exception
11:39:01 <EvanR> oh yah
11:39:13 <EvanR> lazy I/O strikes again
11:39:15 <ReinH> It's quite possible that the try does nothing.
11:39:31 <glguy> No, I don't think that readFile is lazy in the opening of the file
11:40:25 <glguy> it's the case that try will catch the does not exist exception if you use try at the IOError type around readFile filepath
11:40:39 <nitrix> readFile name   =  openFile name ReadMode >>= hGetContents
11:41:27 <EvanR> :: IO (Either IOError String)
11:41:59 <nitrix> openFile is.... FD.openFile, file descriptors :D
11:42:08 <nitrix> Which afaik is strict.
11:44:19 <nitrix> mkFD...
11:44:52 <nitrix> which returns an FD {}
11:44:54 <nitrix> fdFD :: {-# UNPACK #-} !CInt,
11:44:56 <geekosaur> I don't think that's the file descriptor one
11:44:56 <nitrix> glguy: There :)
11:45:11 <geekosaur> it should be the Handle one, since hGetContents doesn't take a file descriptor
11:48:53 <dolio> If readFile were lazy about opening the file, people wouldn't get in situations where they use it to open thousands of files all at once.
11:49:56 <the_2nd> EvanR, glguy got to go, will try it tomorrow, and maybe come back
11:53:36 <NickHu> When should I use newtype instead of data?
11:55:17 <nitrix> geekosaur: Double checking, System.IO.readFile uses openFile imported from GHC.IO.Handle.FD, which uses openFile' from the same module, which does FD.openFile where that FD is GHC.IO.FD, the openFile there uses mkFD, which returns FD {} which is a strict constructor on a CInt.
11:55:24 <jonored> NickHu: newtype is probably preferable when it applies; it basically just declares a little bit more to the compiler.
11:55:45 <NickHu> I can't use newtype for sum types is the other difference right?
11:56:14 <jonored> NickHu: Yep, just when you have one constructor with one value - specifically when the representations can be the same.
11:57:08 <ReinH> NickHu: glad you enjoyed that Haskell Cast episode :)
11:57:25 <NickHu> ReinH: I have listened to them all over the past could of days at work haha
11:57:29 <cocreature> ReinH: any new episodes planned? :)
11:57:32 <ReinH> nice
11:57:32 <NickHu> They're great! I wish there were more though
11:57:44 <ReinH> When we can schedule one. Right now we're both sort of busy with Other Things.
11:57:54 <ReinH> But we are planning on doing more
11:57:57 <NickHu> Also I was a bit stumped by the soundcloud links being broken on the website btw
11:58:01 <NickHu> idk if you are aware
11:58:02 <jonored> So newtype is for "I want a special Foo that the type system won't let me confuse with other Foos, but it really /is/ just a Foo".
11:58:04 <cocreature> I hope the good kind of busy
11:58:10 <ReinH> NickHu: Hmm... I'll look into that
11:58:13 <nitrix> geekosaur: I'm still convinced opening the file with readFile is strict, as it must obtain a file descriptor from the constructor being strict?
11:58:23 <NickHu> I looked on the soundcloud page, and it seems to only have clips for the latest 2 episodes
11:58:26 <ReinH> cocreature: Chris seems to keep moving from one continent to another...
11:58:43 <glguy> nitrix: The strictness of opening a file with readFile isn't really in question, readFile opens the file before returnning
11:58:46 <EvanR> newtypes are also handy for hiding the implementation of an ADT
11:58:52 <geekosaur> actually all of this is kinda irrelevant because the lazy I/O is hidden inside hGetContents
11:59:09 <cocreature> ReinH: that seems … exhausting?
11:59:10 <geekosaur> so yes, opening is strict regardless of how it's doing it
11:59:22 <ReinH> cocreature: yeah
11:59:25 <NickHu> So.. to flip the question on its head, when would I want data instead of newtype (only considering non-sum types)
11:59:38 <nitrix> 14:40:07          glguy | No, I don't think that readFile is lazy in the opening of the file
11:59:48 <EvanR> is all lazy I/O ultimately based on unsafeInterleaveIO ?
11:59:50 <glguy> OK, I should have been more forceful
11:59:55 <geekosaur> EvanR, yes
11:59:55 <nitrix> glguy: I was making sure (it's also a good learning exercise to dig GHC).
11:59:57 <ReinH> If something can be made a newtype, there isn't usually an advantage to using data instead
12:00:02 <ReinH> if you for some reason *want* the indirection, you might
12:00:13 <glguy> revision: WRONG! No, readFile is not lazy in opening the file
12:00:17 <geekosaur> NickHu, when you want a bottom (or equivalently, a chance to introduce laziness)
12:00:19 <nitrix> glguy: It's not you, don't worry. I just used the situation as an excuse to peek GHC :)
12:00:26 <NickHu> geekosaur: Ah, I can understand this
12:00:32 <glguy> OK (I wasn't worried ;-) )
12:00:51 <EvanR> so by induction, readFile cant be lazy in opening the file
12:01:13 <EvanR> since its only use of uIIO is via hGetContents
12:01:37 <EvanR> the matrix rebooted
12:01:42 <dfeuer> UGH.
12:01:56 <xcmw> I pretty sure this is impossible, but is it possible to get this to work? http://lpaste.net/185623
12:03:00 <shachaf> What's the intent of Transform Maybe?
12:03:08 <shachaf> You can't use a type synonym like that.
12:03:54 <xcmw> shachaf: Ok. I though it was most likely impossible.
12:03:57 <nitrix> glguy: I'm assuming this is why you can't readFile "foo" >>= writeFile "foo" ?
12:04:14 <mizu_no_oto_work> xcmw: why not just z :: Data Maybe?
12:04:14 <nitrix> glguy: Since you'd have two handles opened on the same resource, one read-only, the other read-write?
12:05:01 <nitrix> Or whatever you'd connect those. I haven't looked at the types.
12:05:22 <nitrix> Seems sensible.
12:05:35 <EvanR> you can do that on linux
12:05:44 <NickHu> Is there a more idiomatic way of doing the [Text] -> [String] conversion than map unpack?
12:05:53 <EvanR> but it voids your warranty
12:06:07 <nitrix> EvanR: Does linux create new inodes on write?
12:06:35 <xcmw> mizu_no_oto_work: I should have seen that. Thanks.
12:06:36 <nitrix> BTFS maybe does :/ ?
12:06:51 <nitrix> *BTRFS
12:06:58 <EvanR> i dont know what happens
12:07:28 <EvanR> nitrix: thats damn idiomatic
12:07:29 <hesk> Could someone explain the difference between "not $ x `elem`list  && ... " and "not (x `elem` list) && " I thought they were the same but I get different returns.
12:07:31 <jonored> I think you get consistent inode numbers from btrfs, but you do get copy-on-write internally.
12:07:31 <EvanR> NickHu: 
12:07:42 <NickHu> Also, is there an idiomatic way of pulling data out of a singleton defined like data A = A "data"?
12:07:59 <EvanR> data A = A { getA :: B }
12:08:00 <kadoban> hesk: The first is not (x `elem` list && ...)
12:08:13 <NickHu> EvanR: Ah, I thought I should define it as a singleton record
12:08:13 <kadoban> hesk: The second is (not (x `elem` list)) &&
12:08:29 <hesk> kabodan: Oh I see! That makes sense
12:08:30 <EvanR> note that in this case you probably want newtype
12:08:35 <hesk> kabodan: thanks.
12:08:36 <ReinH> hesk: not $ a && b = not (a && b), not (a) && b = (not a) && b
12:08:39 <kadoban> Sure
12:08:44 <NickHu> EvanR: Yup
12:08:55 <EvanR> @src Sum
12:08:55 <lambdabot> newtype Sum a = Sum { getSum :: a }
12:09:11 <NickHu> Is fmap unpack good to do for [Text] -> [String]?
12:09:20 <EvanR> yes
12:09:59 <dfeuer> Ain't no better way, anyhow.
12:10:08 <EvanR> with lazy text itll be real smooth
12:10:19 <EvanR> i guess either text
12:11:30 <NickHu> I've heard that people should pretty much always use Text instead of String (unless for some reason they really want [Char]), but if I need to convert to String at some point down the line because of whatever-library, does that negate the benefit?
12:11:54 <EvanR> no because you can efficiently stream a list of chars from a text
12:12:20 <EvanR> as long as the consumer is lazy
12:13:06 <JonReed> Can anybody explain why `f "hello" ++ "world"`, where f :: [a] -> [a]; (e.g. f = map id) works, but `print "hello" ++ "world"` where `print :: a -> IO ()`does not?
12:13:41 <JonReed> I mean that for print you have to `print ("hello" ++ "world")` but for `f` you don't have to
12:13:54 <EvanR> think about the types
12:14:03 <EvanR> what is print "hello"
12:14:13 <ReinH> JonReed: f a ++ b = (f a) ++ b
12:14:25 <geekosaur> JonReed, because it's doing the same in both, running (f "hello") + ..., but the type for the furst matches but for the second doesn't
12:14:42 <ReinH> so f "hello" ++ "world" = (f "hello") ++ "world", which works (but probably not the way you expect).
12:14:47 <JonReed> Ahh. Sure. 
12:14:53 <ReinH> but print "hello" ++ "world" = (print "hello") ++ "world", which is a type error.
12:15:11 <nitrix> JonReed: You probably meant print ("hello" ++ "world")
12:15:37 <nitrix> JonReed: Function application has the highest precedence, so your snippet reads as (print "hello") ++ "world"
12:15:45 <geekosaur> they said that, yes
12:15:47 <nitrix> IO () cannot be concatenated (++) with a String.
12:15:58 <ReinH> @quote fugue
12:15:59 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
12:16:07 <EvanR> ((++) (print "hello") "world")
12:16:08 <nitrix> :t (++)
12:16:08 <jonored> > let f = map (const 'x') in f "hello" ++ "world"
12:16:13 <lambdabot> [a] -> [a] -> [a]
12:16:13 <lambdabot>  "xxxxxworld"
12:16:41 <EvanR> use lisp syntax to make it easier to read
12:16:46 <EvanR> :t ((++) (print "hello") "world")
12:16:48 <lambdabot> error:
12:16:48 <lambdabot>     • Couldn't match expected type ‘[Char]’ with actual type ‘IO ()’
12:16:48 <lambdabot>     • In the first argument of ‘(++)’, namely ‘(print "hello")’
12:16:52 <EvanR> oh duh
12:18:21 <hc> :t (print ((++) "hello" "world"))
12:18:23 <lambdabot> IO ()
12:19:02 <EvanR> (IO ())
12:19:23 <EvanR> https://github.com/zjhmale/Ntha
12:21:15 <nitrix> JonReed: (++) :: [a] -> [a] -> [a], as the error says `[Char]` cannot be matched with `IO ()`, which is the result of `print "hello"`, so the concatenation which has lower precedence fails to type check.
12:22:19 <JonReed> nitrix: Yeah. I get it now. I was reading about precedence and how it deals with infix operators and special forms for the whole day.
12:22:44 <JonReed> nitrix: Just did not click for me.
12:22:58 <nitrix> JonReed: There are a few tables online. The one that probably wont be listed is function application, which is always the highest precedence.
12:23:06 <EvanR> and function application (by juxtaposition) binds tighter than any operator
12:23:08 <nitrix> JonReed: That rule alone helps reads a lot of code.
12:24:00 <cocreature> why does "index" from Data.Text claim in the docs that it has O(n) runtime? It seems like this should be possible in O(1)?
12:24:06 <EvanR> because of that it took some getting used to forall a . a -> a -> a -> a 
12:24:50 <EvanR> cocreature: it has to scan forward through the underlying array of chars
12:25:05 <EvanR> because its an array of utf16 units
12:25:25 <cocreature> oh right
12:25:26 <cocreature> thx
12:25:48 <nitrix> JonReed: Thus `f g h` reads as `(f g) h`. It actually even does so when `f` has 2 arguments. The first argument is applied, the result is a function which is then applied to the second argument. Functions in Haskell all denotionally take one value and yield another.
12:26:29 <nitrix> JonReed: So these two things work hand-in-hand. It's pretty elegant when you realise it :)
12:27:03 <JonReed> nitrix: It's a bit mind-bending. I was using it for a while without realizing how it actually works.
12:27:07 <EvanR> another way to say it is -> has only two sides
12:28:31 <nitrix> JonReed: `a -> a -> a` being the same as `a -> (a -> a)`
12:28:48 <EvanR> instead of variadic functions we have (A,B,C) -> (D,E,F) like functions explicitly using tuples
12:29:00 <EvanR> and (A,B) -> C is equivalent to A -> B -> C
12:31:58 <nitrix> JonReed: You can prove/demonstrate it simply with something called Extensionality.  `foo x y = undefined` vs. `foo x = \y -> undefined` vs. `foo = \x -> \y -> undefined`. They all have the same types, yet `foo` "appears" to have different numbers of arguments, but it doesn't. It always has one.
12:32:05 <nitrix> EvanR: That's only when they're curried though :/
12:32:21 <EvanR> huh
12:32:27 <nitrix> EvanR: Or was that a different syntax I'm not familiar with?
12:32:38 <maerwald> he said "equivalent"
12:34:09 <soLucien> hello guys ! I'm trying to install haskell 7.10.3 on a windows machine
12:34:20 <soLucien> is it possible to use cabal to install ghci
12:34:22 <ph88> what am i doing wrong here with this error?   https://paste.fedoraproject.org/423110/19042714/
12:34:34 <soLucien> cabal seems to work fine as a package manager 
12:34:35 <geekosaur> soLucien, cabal cannot install ghc
12:34:38 <EvanR> another way to say that is that haskell is a cartesian closed category
12:34:53 <nitrix> EvanR: Hask or Haskell ?
12:35:07 <EvanR> shrug
12:35:18 <soLucien> cool .. so basically what i need to do is 1) unzip 2) add to path
12:35:21 <soLucien> and i'm done
12:35:23 <soLucien> is that correct ?
12:35:40 <soLucien> i want to do it right from the first time
12:36:17 <nitrix> soLucien: If you really want a out-of-the-box-batteries-included experience, I believe that's the original goal of the Haskell Platform. There are also tutorials to start solely with stack and let stack manage the rest from there.
12:36:24 <geekosaur> ph88, (snd . fst) ct
12:36:31 <geekosaur> resp. (snd . snd)
12:36:40 <nitrix> soLucien: Why 7.10.3 and not 8.0.1 ?
12:36:40 <soLucien> okay, stack
12:36:50 <ph88> geekosaur, . takes precedence, no ?
12:36:52 <soLucien> because that's what my uni teachers told me
12:36:57 <soLucien> the latest stable version ..
12:37:11 <geekosaur> ph88, yes it does. which means it is snd . (fst ct)
12:37:15 <nitrix> soLucien: https://www.haskell.org/ghc/
12:37:17 <soLucien> i installed 8.0.1 then cabal failed to install ghc-mod
12:37:21 <nitrix> soLucien: 8.0.1 is the latest.
12:37:26 <geekosaur> oh, we understand precedence the wrong way
12:37:34 <geekosaur> function application is *always* high precedence
12:37:44 <ph88> ooh i see
12:37:46 <geekosaur> the only thing with higher precedence is record update syntax
12:38:15 <maerwald> 7.10.3 is fine too though, there are probably still some hackage packages left that don't build with 8.0.1
12:38:29 <ph88> geekosaur, do you know of a nicer way to write this function ?
12:38:43 <soLucien> yes 
12:38:50 <soLucien> old-time failed to install
12:38:57 <soLucien> so i could not install hlint
12:39:01 <soLucien> i want a linter ..
12:39:09 <nitrix> soLucien: Haskell Platform provides all of those.
12:39:20 <nitrix> *whispers* Painlessly.
12:39:25 <maerwald> and latest stack LTS is ghc-7.10.3 too afais
12:39:30 <geekosaur> ph88, that definition looks reasonable to me. you can define it in other ways, but readability is something I'd prioritize over other notions of "nicer"
12:39:49 <ph88> oki thx
12:41:41 <soLucien> "GHC is the Glasgow Haskell Compiler.  For consistency, you are required to use GHC version 7.10.3 for all Haskell submissions.  Haskell code written for other GHC versions can be incompatible with 7.10.3."
12:42:17 <ReinH> Then you should use that version.
12:42:49 <Clint> maerwald: plenty of them
12:42:54 <maerwald> using 8.0.1 and proving that the teachers exercises don't compile would be fun though :P
12:43:03 <maerwald> but won't get you bonus points
12:47:59 <nitrix> soLucien: There are earlier versions of the Haskell Platform for the version 7.10.3. That one doesn't have stack though, but it should have everything else.
12:48:23 <mizu_no_oto_work> How many bckwards incompatible changes were added for 8.0.1, though?
12:48:48 <soLucien> ok i installed Stack then ran stack setup --resolver lts-6.13 to install 7.10.3
12:48:58 <soLucien> is it possible to install ghc-mod now ?
12:49:03 <nitrix> I'm insisting on HP because if you're a student, you probably want to just look at haskell code and not think about the ecosystem/tooling too much (at least to get started).
12:49:13 <nitrix> soLucien: It'll probably fail on old-time and similar, but try it.
12:49:19 <soLucien> VSCode (my IDE) has some plugins that turn on automatic linting
12:49:30 <soLucien> what do you guys use, btw ?
12:49:38 <mizu_no_oto_work> Vim
12:49:49 <soLucien> :)
12:50:05 <soLucien> i never got the point of it ..
12:50:51 <mizu_no_oto_work> It makes editing text really easy
12:50:59 * geekosaur would like to note that hlint is opinionated, and sometimes wrong because heuristics don't handle higher order stuff well --- it can suggest rewrites that are type errors
12:53:10 <maerwald> soLucien: https://wiki.haskell.org/IDEs
12:56:05 <dfeuer> RRRRR
12:56:13 <dfeuer> Sorry.
12:56:24 <maerwald> plenty of options... or just use whatever you like + a ghci prompt if you don't care for highlighting and in-editor errors
12:58:33 * dfeuer would like to note that thanks to the GHC inliner's notion of function arity, taking HLint's suggestions regarding eta reduction can sometimes lead to slow code.
12:59:23 * dfeuer would also like to note that HLint sometimes produces suggestions that make code harder to read.
13:00:11 <maerwald> it's basically not a particularly powerful tool due to the lack of configuration options
13:00:32 <mizu_no_oto_work> soLucien: at any rate, the main reason for the "Haskell code written for other GHC versions can be incompatible with 7.10.3" comment is that there were a couple things that were cleaned up in the standard library, recently.  So code written for e.g. 7.6 might not compile for 7.10, but the fixes are trivial.
13:01:24 <maerwald> dfeuer: also, you mean this probably https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x---
13:01:25 <maerwald> ?
13:01:49 <maerwald> I actually filed a bug about that at lpaste :P
13:02:34 <dfeuer> maerwald, pretty much.
13:15:15 <JonReed> What still bends my mind is how $ works. I get that $ = id and that I can go `id' = id; infixr 0 id'` and then `print `id'` "hello" ++ "world"`. But what does that translate to? It does not seem that it does this (print $) "hello" ++ "world", which is what should happen if function application always happens first and consumes first argument.
13:16:32 <shachaf> ++ is infixr n for some n > 0
13:16:37 <shachaf> So it's stickier.
13:17:02 * hackagebot docker 0.3.0.0 - An API client for docker written in Haskell  https://hackage.haskell.org/package/docker-0.3.0.0 (denibertovic)
13:18:17 <athan> JonReed: That works if you wrap ("hello" ++ "world")
13:18:28 <kadoban> JonReed: $ is an operator, it isn't syntactically valid for it to be an argument to print.  So it's more like (print) $ ("hello" ++ "world")
13:18:39 <athan> oh derp
13:19:09 <kurt11_> In a stack+cabal project, how do I run a test-suite? If I do `stack test`, I get `my-test-suite: executable not found`. This is with test-suite type `exitcode-stdio-1.0` and with `main-is` file properly defined. I can run `stack ghci my-project:test:my-test-suite` and then run `main` to get my tests running by way of the ghci repl.
13:19:11 <kadoban> So yes function application is very high precedence, but that doesn't override ever other part of syntax.
13:19:27 <JonReed> What I don't get is why does "a $ b" translates to this (a) (b).
13:19:33 <geekosaur> JonReed, ($) is just function application (a $ b = a b) but at very low precedence
13:19:37 <ReinH> JonReed: in `1 + 2`, (+) is not an argument to 1
13:19:38 <geekosaur> infix 0 $
13:19:41 <kadoban> JonReed: Because $ is *very* low precedence
13:19:47 <ReinH> 1 and 2 are arguments to (+)
13:20:08 <geekosaur> sorry, infixr 0 $
13:20:08 <jonored> JonReed: It translates to (($) a) (b)
13:20:11 <ReinH> so in f $ g, ($) is not an argument to f
13:20:14 <ReinH> f and g are arguments to ($)
13:20:28 <ReinH> i.e., f $ g = ($) f g
13:20:50 <ReinH> and if ($) = id, then ($) f g = id f g = (id f) g = f g
13:20:59 <ReinH> since id x = x
13:21:21 <ReinH> so ($) *could* be defined as id, but it is instead defined as f $ x = f x
13:21:49 <JonReed> How would that translate to with id `print $ "hello" ++ "world"`?
13:22:08 <ReinH> print $ "hello" ++ "world" = ($) (print) ("hello" ++ "world")
13:22:44 <ReinH> ($) print ("hello" ++ "world") = id print ("hello" ++ "world") = print ("hello" ++ "world")
13:23:16 <ReinH> or, (print) $ ("hello" ++ "world") = (print) ("hello" ++ "world")
13:23:22 <ReinH> (parens added for clarity)
13:23:48 <geekosaur> it translates as (id print ("hello" ++ "world")), with id :: (b -> b) -> (b -> b) as a specialization of id :: a -> a
13:24:00 <geekosaur> hm. not that last
13:24:02 <geekosaur> eh
13:24:38 <geekosaur> no, that's right, it's how you get id that takes 2 parameters
13:24:51 <JonReed> But there are not brackets around `"hello" ++ "world"` $ adds them somehow. This is why I don't get.
13:25:09 <jonored> JonReed: The same way that you get brackets around (4*5) in 5+4*5
13:25:10 <ReinH> JonReed: do you understand how 1 + 2 * 3 "adds brackets" around (2 * 3)?
13:25:23 <ReinH> precedence (sometimes known as "order of operations")
13:25:45 <ReinH> f $ 2 * 3 is not different, conceptually, from 1 + 2 * 3
13:25:57 <ReinH> (*) has higher fixity than ($) or (+)
13:26:22 <ReinH> so they are evaluated as f $ (2 * 3) and 1 + (2 * 3), respectively
13:26:32 <JonReed> So it starts with `$ 
13:26:34 <parsnip>  `... $ ... $ ...` is like `(... $ ...) (...)` is like `((...) (...)) (...)`. 
13:26:41 <ReinH> what does?
13:26:55 <JonReed> Eh, I think I need to find source of how it parses it to understand.
13:26:56 <parsnip> wait, i think i got that backwards
13:27:22 <ReinH> JonReed: most languages evaluate 1 + 2 * 3 as 1 + (2 * 3). It is the same concept.
13:27:37 <kurt11_> Anyone know how to run test-suite with stack?
13:27:40 <ReinH> So if you expect 1 + 2 * 3 = 1 + (2 * 3), you can carry that expectation to print $ "hello" ++ "world'
13:27:46 <ReinH> kurt11_: stack test?
13:28:22 <parsnip> is there a simple example with two $ in it? 
13:28:24 <ph88> does anyone know why i'm getting these errors?  https://paste.fedoraproject.org/423130/19367014/
13:28:36 <ReinH> map $ id $ [1,2,3]
13:28:55 <ReinH> > map $ id $ [1,2,3]
13:28:57 <lambdabot>  error:
13:28:57 <lambdabot>      • Couldn't match expected type ‘a -> b’
13:28:58 <lambdabot>                    with actual type ‘[Integer]’
13:29:16 <ReinH> parsnip: isn't that wrong? it's infixr, not infixl
13:29:43 <parsnip> ReinH: yeah, it doesn't look right, i usually don't have to think about it >.<
13:29:53 <ReinH> Arguably, it *should* be infixl, but in fact it is infixr
13:30:02 <ReinH> That is, we'd like my example to work
13:30:26 <ReinH> > succ $ id $ 1
13:30:29 <lambdabot>  2
13:30:31 <ReinH> > succ (id 1)
13:30:33 <lambdabot>  2
13:30:38 <ReinH> not (succ id) 1
13:30:47 <lyxia> > not (succ id) 1
13:30:51 <lambdabot>  error:
13:30:51 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
13:30:51 <lambdabot>                    with actual type ‘Bool’
13:30:55 <athan> Is there a way to map over a vector in O(1) in parallel?
13:31:03 <MarcelineVQ> ph88: What's the type of snd t_text?
13:31:08 <athan> Or, some way to merge two vectors with some binary operator in parallel?
13:31:11 <parsnip> > (succ id) 1
13:31:14 <lambdabot>  error:
13:31:14 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M340370108143...
13:31:14 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
13:31:37 <parsnip> i guess i'm looking for an example where some stuff actuall happens in between the $
13:31:50 <ReinH> > succ $ pred $ 1
13:31:52 <parsnip> so maybe like `f a $ g b $ h c`
13:31:53 <lambdabot>  1
13:32:18 <ReinH> > head $ map toUpper $ "hello"
13:32:21 <lambdabot>  'H'
13:32:35 <parsnip> (f a) ((h b) (g c)) apparently
13:32:42 <ReinH> Yes
13:33:29 <jonored> $ can end up looking a lot like a backwards version of a shell |
13:33:33 <ReinH> if you want a rule of thumb for (only one) ($), wrap the longest expression on either side with parens. If you don't want a rule of thumb, learn how fixity works.
13:33:37 <athan> I think I can go back & forth to REPA arrays at least :s
13:33:56 <parsnip> > (*) 2 $ (+) 3 $ (-5) 8
13:34:00 <lambdabot>  error:
13:34:00 <lambdabot>      • Could not deduce (Num t0)
13:34:00 <lambdabot>        from the context: (Num (t -> a), Num t, Num a)
13:34:08 <parsnip> > (*) 2 $ (+) 3 $ (subtract 5) 8
13:34:11 <lambdabot>  12
13:34:27 <parsnip> > (*) 2 $ (+) 3 $ (/ 5) 8
13:34:30 <lambdabot>  9.2
13:34:59 <parsnip> > (*) 2 . (+) 3 $ (/ 5) 8
13:35:03 <lambdabot>  9.2
13:35:30 <shachaf> If your heuristic is too far from the truth, it becomes a dictatorship of thumb.
13:35:39 <parsnip> > (*) 2 . (+) 3 . (/ 5) $ 8
13:35:42 <lambdabot>  9.2
13:36:01 <ReinH> shachaf: heh
13:36:26 <ReinH> on the tyranny of thumbs
13:36:39 <shachaf> anticheirocracy
13:36:55 <EvanR> . is backwards shell for sure
13:37:18 <lpaste> Kevin pasted “foldl1'” at http://lpaste.net/185668
13:37:21 <parsnip> pipe? 
13:38:19 <EvanR> est un pipe
13:38:28 <ph88> MarcelineVQ, i made a new paste https://paste.fedoraproject.org/423132/14731942/
13:39:27 <MarcelineVQ> ph88: I'd say Data.List.concat is the wrong thing to use to combine a list of Text. T.concat, which you used in getComments is what you use to concat a list of Text
13:47:53 <ph88> oh yes that was it, thx MarcelineVQ 
13:48:13 <MarcelineVQ> You can let the compiler determine it for you if you like using mconcat, since Text and lists are both Monoids it can choose what's appropriate.
13:48:29 <MarcelineVQ> > mconcat ["1","2","3"]
13:48:32 <lambdabot>  "123"
13:48:44 <MarcelineVQ> > mconcat (map T.pack ["1","2","3"])
13:48:47 <lambdabot>  "123"
13:51:19 <ReinH> :t fold
13:51:21 <lambdabot> (Monoid m, Foldable t) => t m -> m
13:51:24 <ReinH> :t mconcat
13:51:29 <lambdabot> Monoid a => [a] -> a
13:51:32 <ReinH> for even more generality, there's fold!
13:51:43 <MarcelineVQ> pssshhh well sure, if you like concise clear things
13:52:49 <mszczygiel> > fst (1, 2)
13:52:52 <lambdabot>  1
13:53:01 <parsnip> > foldMap Sum [1,2,3]
13:53:04 <lambdabot>  Sum {getSum = 6}
14:00:05 <ReinH> > ala Sum foldMap [1,2,3]
14:00:09 <lambdabot>  6
14:01:58 <EvanR> :t ala
14:02:00 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
14:04:36 <athan> Are boxed vectors safeCopy-able?
14:10:43 <dmj> athan: should be
14:11:22 <dmj> athan: boxed vectors aren't paremetrized on a primitive state token, unless you're referring to mutable boxed vectors
14:12:46 * dmj <3's vector
14:13:12 <hsk3> In my stack project, I run "stack ghci" to try things out.
14:13:12 <hsk3> After modifying code, is there a way to recompile my project from within ghci?
14:13:13 <hsk3> Something quicker than existing GHCi and running "stack ghci" again
14:13:24 <hsk3> s/existing/exiting
14:13:30 <MarcelineVQ> :r
14:14:11 <hsk3> MarcelineVQ: that isn't doing the same thing. doesn't seem to compile everything
14:14:12 <MarcelineVQ> If you've added new modules you might need to exit out though, I'm not sure
14:14:13 <athan> thanks dmj :)
14:17:03 * hackagebot lp-diagrams 2.0 - An EDSL for diagrams based based on linear constraints  https://hackage.haskell.org/package/lp-diagrams-2.0 (JeanPhilippeBernardy)
14:17:08 <dmj> athan: np ;)
14:17:54 <geekosaur> hsk3, no, ghci is not stack
14:18:16 <geekosaur> stack is running ghci, but there is no way for ghci to "call back" into stack
14:22:06 <ph88> this LogicalNameList has a lot of Terminal and NonTerminal in it .. is there a way to have just  LogicalName  instead of  NonTerminal LogicalName ??  https://paste.fedoraproject.org/423147/31968511/
14:23:05 <ReinH> No. That's the price you pay for using newtypes.
14:23:29 <ph88> oki
14:31:51 <ph88> that feeling when everything type checks :>
14:41:16 <joe9>  Any suggestions on how I can get the canvas to be redrawn https://github.com/joe9/baby-steps-to-building-a-chart-with-diagrams/blob/master/app/Step021RenderDynamicallyUsingCairo.hs is my code.
14:41:23 <joe9> For some reason, the new chart is overlaying the old one. So, I get the old chart and the new chart.
14:41:37 <joe9>  I am not sure how to clear up canvas and then redraw the new chart. Any suggestions, please? line 126 is where I am redrawing the new chart  [14:37]
14:41:49 <joe9> this is using gtk2hs canvas widget
14:52:38 <lingxiao> hey all
14:52:47 <lingxiao> I have problem compiling main
14:52:51 <lingxiao> I built my project using stack
14:53:12 <lingxiao> and when i do ghc -o Main Main.hs  
14:53:18 <lingxiao> im getting a bunch of cannot find modules error
14:54:33 <NickHu> You want stack ghc -- -o Main Main.hs
14:54:33 <jle`> lingxiao: if your main is an executable in the cabal file, you should just be able to "stack build" or "stack install"
14:54:41 <NickHu> oh yeah I mean stack build lol
14:54:56 <geekosaur> stack exec -- ghc
14:55:06 <geekosaur> but really, don't do that; use stack to build the main executable
14:55:10 <NickHu> ^^^
14:55:13 <geekosaur> that's what it exists for
14:55:20 <athan> Is there a vector implementation where snoc/cons are O(1)?
14:58:05 <NickHu> Data.Sequence
14:58:09 <NickHu> But it's not really a vector
14:58:13 <athan> Yeah :\
14:58:22 <athan> I really want a vector, so I can plug it into repa
14:58:27 <NickHu> repa?
14:58:33 <athan> :)
14:58:37 <athan> @hackage repa
14:58:37 <lambdabot> http://hackage.haskell.org/package/repa
14:58:45 <lingxiao> ok jle` and geekosaur i'll do that
14:58:49 <lingxiao> and get back to you guys
14:59:39 <geekosaur> what makes a vector a vector is that its spine is fixed. this means it can't be enlarged or shrunk without copying, aside from cleverness in the representation that requires pre-allocation at the maximum expected size and tracking what part is in use
15:00:23 <athan> geekosaur: Thank you :) is the same said for arrays?
15:00:27 <geekosaur> yes
15:00:47 <athan> hrm, so really pure list-wise or a Seq is the only way to go for that, huh
15:00:53 <athan> because they're all cons-based from the get-go
15:01:21 <geekosaur> or cleverness where you chain together larger chunks instead of single elements, which gets you intermediate performance
15:01:53 <geekosaur> and *amortized* big-Os (a cons/snoc that has to add a new segment will be more expensive than one that can use an unused part of an existing segment)
15:02:13 <athan> ahh, hm. Thank you for your wisdom, geekosaur :)
15:02:22 <johnw> athan: If you know the size of your input set, you can add padding to the beginning and ending of your vector, so that as long as there are that many slots free, it's a constant time "cons" and "snoc".   You'll have to manage pointers to the real beginning and ending of the initialized part of the vector manually.
15:02:54 <geekosaur> right, thats what I meant by the cleverness in the representation thing
15:03:05 <johnw> it's sort a "buffered vector", which ByteString actually uses
15:03:54 <johnw> ah, right, I see now that you said exactly that geekosaur :)
15:04:00 <athan> that's really interesting, but nope, it's gotta be completely dynamic
15:04:04 <athan> a bit out of my reach right now :)
15:05:18 <dmj> athan: you should be able to do it with Stream
15:06:10 <athan> dmj: A snoc?
15:06:17 <athan> I've never heard of them before :x
15:06:27 <dmj> athan: you can unfoldr into a Bundle and convert that into a Vector iirc
15:06:54 <dmj> bundle is away of the size
15:06:57 <dmj> aware*
15:07:26 <dmj> you could just keep snoc'ing onto an empty bundle
15:07:58 <athan> :o crimeny alright I'll do some homework
15:08:25 <dmj> athan: unstream :: Vector v a => Bundle v a -> v a
15:08:31 <dmj> O(n) Construct a vector from a Bundle
15:09:16 <athan> holy crap what is this, shewt
15:09:43 <athan> dmj: Do you know of any primers on this kind of vector work? I'm only familiar with very basic concepts :\
15:10:01 <dmj> athan: Bundle is a wrapper over dcoutt's Stream type, everything is inlined until the Stream data type exists in place of other function defintions, and that's how intermediate allocations are removed, afaik
15:11:37 <dmj> athan: there's like 4 papers
15:12:03 <athan> :D gimme gimme gimme
15:12:04 <lingxiao> hey guys when i stack build im getting some `Could not find module ... it is a hidden module in the package ...` error
15:12:11 <athan> jk I'll look them up
15:12:15 <athan> thanks dmj!
15:12:19 <lingxiao> but i exported those modules from lib
15:12:37 <lingxiao> in the section  other-modules
15:13:20 <dmj> athan: this one is latest I think, https://www.cs.drexel.edu/~mainland/publications/mainland13exploiting.pdf
15:13:28 <glguy> "other-modules" are the modules you didn't expose
15:14:10 <glguy> All the modules of your package need to go into either exposed-modules or other-modules
15:14:21 <dmj> athan: there's also this INLINE_FUSED pragma that is used a lot, http://stackoverflow.com/questions/23711923/inline-fused-pragma-in-haskell
15:15:05 <lingxiao> ah ok
15:15:07 <NickHu> lingxiao: Edit your cabal file, not your stack.yaml
15:15:29 <lingxiao> glguy so in lib the exposed-modules section has Lib only
15:15:37 <lingxiao> how can I get Lib to reexport everything?
15:16:05 <dmj> athan: basically, if you stick with the Generic interface, you get most of the benefits for free, in those modules everything is defined in terms of stream / unstream for the most part
15:18:42 <lingxiao> geekosaur im sorry so how do i use stack to create an executable main?
15:19:31 <joe9> Is there a channel to ask about gtk2hs issues?
15:19:57 <athan> thanks dmj, saving my neck
15:20:08 <geekosaur> lingxiao: you're supposed to set up a stack project using stack-installed packages. https://docs.haskellstack.org/en/stable/README/#start-your-new-project
15:20:19 <NickHu> stack init should create a template for you
15:20:23 <dmj> athan: fp complete has a /great/ article on vector
15:20:36 <lingxiao> geekosaur yeah i did that
15:20:39 <lingxiao> and i did stack setup
15:20:49 <lingxiao> and stack build
15:21:08 <lingxiao> but i guess i was expecting a executable main in the app folder
15:21:32 <geekosaur> not until you stack install
15:21:43 <NickHu> You do get that; you have to do stack exec <project-name>-exe
15:21:54 <dmj> athan: this, https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/vector.md
15:21:57 <NickHu> afaik you don't need to stack install to do that
15:22:19 <geekosaur> right, but it doesn't get installed for use outside of stack until you stack install
15:22:33 <geekosaur> (which is what I understand "in the app folder" to mean)
15:23:56 <jonored> geekosaur: The "new project" templates have a src/ with library stuff and app/ with a main; I'd read that as "an executable in the same directory as the source file including main".
15:25:26 <geekosaur> ok, yeah, it doesn't drop it beside the main. it doesn't drop the actual libraries it uses beside their source either, just leftover build artifacts
15:27:38 <lingxiao> wait so am i to understand that when i do stack install i get some executable?
15:27:47 <lingxiao> i need to call this executable in some .sh file
15:27:54 <lingxiao> hence the need for its existence
15:28:40 <NickHu> stack install will install it to your global stack directory, which is probably referenced in your PATH
15:29:51 <geekosaur> usually ~/.local/bin
15:31:40 <lingxiao> could i ask why does it install there?
15:32:53 <NickHu> So you can remove it easily, and so you know which things stack installed
15:33:23 <kadoban> lingxiao: Gotta install it somewhere. Can't use the global spots, since those require higher privs, typically.
15:33:33 <geekosaur> well, I suspect it's intended to be general --- there is no real convention for per-user bin directories, but that one seems a logical extension to XDG
15:33:37 <NickHu> If you really want to know where the binary for your project file is, run "stack exec which <project-name>-exe"
15:33:42 <lingxiao> oh ok ... so I think im a bit confused as to what stack install is meant to do
15:33:45 <NickHu> You could probably just copy it from there to wherever
15:33:59 <meinteil> ss
15:34:01 <kadoban> lingxiao: It's meant to install the executables from a specified package, so you can run them.
15:34:35 <NickHu> lingxiao: Stack is meant to behave differently depending on which directory you're in - if you're in myproject1, you only get libraries and executables for that exposed
15:34:43 <NickHu> myproject2, the same but for myproject2
15:34:55 <NickHu> If you're not inside a project directory, you get the system-wide stuff instead
15:35:05 <NickHu> Which is stuff installed by stack install
15:35:18 <lingxiao> oh i see interesting .. but thats on my machine though?
15:35:41 <lingxiao> so if i distribute the project on some remote server, then i need do stack install  there correct?
15:35:57 <lingxiao> and in my .sh file i need to write down the path to that file ?
15:36:21 <kadoban> lingxiao: You need to do stack install there, sure. I don't understand the next question there.
15:36:30 <NickHu> The stack.yaml file is basically a recipe for stack to get all the dependencies it needs
15:36:39 <NickHu> It's supposed to "just work TM" unlike cabal
15:36:49 <lingxiao> ok great next question isnt that important :)
15:37:00 <qknight> when building glib-0.13.2.2 i notice a .c file which is generated during configuration/build time when compiling glib. how does this work? https://github.com/gtk2hs/gtk2hs/issues/181 <- dist/build/System/Glib/StoreValue_hsc_utils.c is the file in question
15:37:01 <lingxiao> ok i see yeah i like the yaml file
15:37:13 <NickHu> You can see the files stack installs on a project-specific basis by going to the .stack-work hidden directory in your project folder
15:38:50 <lingxiao> ok so when i do `stack exec which GoodGreatIntensity-exe `
15:38:59 <lingxiao> i see  ..../GoodGreatIntensity-exe 
15:39:04 <hexagoxel> lingxiao: `stack path --local-bin-path`
15:39:10 <lingxiao> that GoodGreatIntensity-exe is the executable right?
15:39:23 <NickHu> Sure
15:39:57 <lingxiao> but i cant cd into this directory though?
15:40:08 <lingxiao> Id like to get it out of the hidden directory and put it in top, or app
15:40:15 <lingxiao> just for easy access later
15:40:36 <parsnip> i'm trying to avoid external dependencies to stack curated stack, is there any curated version of https://hackage.haskell.org/package/combinat-0.2.8.1
15:40:52 <NickHu> It should give you a full path to the binary
15:41:21 <parsnip> It is a member of the hidden package ‘combinat-0.2.8.1@combi_HlXGgk6GULi6Yvk4HcgRAS’.
15:41:59 <kadoban> parsnip: https://www.stackage.org/package/combinat doesn't look like it's in any stackage resolver if that's what you mean. Not really any problem using it from hackage if it builds fine though.
15:42:00 <lingxiao> oh yup i got it
15:42:26 <kadoban> parsnip: That message means you didn't add it to the .cabal file, unless I'm missing something.
15:43:26 <parsnip> kadoban: oh yeah, i removed it from cabal file because it said i had to add it to stack.yaml, and i'd like to avoid that. maybe i'll try reducing version constraint in .cabal to see if it finds a curated version. 
15:44:15 <jonored> lingxiao: I think you can also just do "stack install --local-bin-path <dir-to-copy-to>" (which is the same thing as "stack build --copy-bins --local-bin-path <dir>")
15:44:21 <NickHu> I didn't think you were supposed to touch stack.yaml unless you wanted to add something that was only available on a private git repo or something
15:44:26 <kadoban> parsnip: You can see on the page I linked that it's not in any stackage resolvers. It doesn't matter what you do in the .cabal file, it won't find it in a resolver, unless you're making your own or something. You'd need to add it to the extra-deps in stack.yaml (there's really no issue with doing so, unless it won't build)
15:44:47 <kadoban> NickHu: That's not really true
15:45:14 <NickHu> I'm a stack novice at best, but the documentation seemed kinda confusing to me...
15:45:18 <parsnip> kadoban: sure, just seemed like the external dependencies are what slow me down more when i go to change some build or something. i'm a little shaky on these concepts, sorry. 
15:46:29 <kadoban> Nothing to apologize about really. But I've run into very few problems doing so, really just ... sometimes they don't build and then you either ... have to fix it yourself or ... find something else usually. But in terms of reproducability or ability to upgrade later, very few issues.
15:51:09 <parsnip> i used to have `text` in there too, and a few others, and i now try to avoid it, because if i changed something, it seemed to spin the battery for rebuilding those. i guess i can look forward to removing `combinat` once i remove that "cheat" solution to that euler problem :)
15:52:19 <kadoban> text is in like every resolver ever, AFAIK
15:53:01 <parsnip> yeah, maybe i had some version, or pointless inclusion in ext-deps:
15:53:23 <kadoban> Could be, hehe.
15:53:54 <parsnip> thanks, i think i see now how to use stackage.org to see if a package is in a resolver! :)
15:54:45 <kadoban> If you use one of the common browsers, one of their like, search things you can "install" from stackage.org lets you look up packages too, which is a nice time saver.
16:01:01 <parsnip> well, i finally added the hoogle search result tool (need to add wikipedia back too). but i didn't see an add-on for stackage. 
16:01:44 <hpc> if you're using firefox, set a bookmark for the search page with a search term of %s
16:01:48 <hpc> then give it a keyword
16:01:58 <hpc> and in the location bar you can type "stackage foo" and it will search for foo
16:02:04 <NickHu> Is there a way to make hoogle search through more libraries than what seems to be just the core?
16:02:06 <kadoban> parsnip: There should be another one of the search result tools, whatever those are actually called. One is like hoogleish, the other one just does package names
16:02:08 <lingxiao> hey all
16:02:23 <kadoban> NickHu: Use other hoogles, like the one on stackage.org or use hayoo
16:02:24 <lingxiao> using createDirectory here: https://hackage.haskell.org/package/directory-1.2.7.0/docs/System-Directory.html
16:02:36 <lingxiao> I'd like to create a directory in the top level of my project folder
16:02:39 <parsnip> ah, okay that makes sense. 
16:02:51 <NickHu> Ah, I didn't know there was a stackage hoogle! Thanks
16:03:31 <lingxiao> so ie .. if my project is named fooBar createDirectory "<STUFF>/newDir"  should create a directory here: fooBar/newDir
16:03:51 <lingxiao> is there a way to reference top level of my project folder?
16:07:12 <lingxiao> nvm got it
17:04:19 <JonReed> @import Debug.Trace
17:04:19 <lambdabot> Unknown command, try @list
17:04:34 <JonReed> @let import Debug.Trace
17:04:37 <lambdabot>  .L.hs:135:1: error:
17:04:37 <lambdabot>      Debug.Trace: Can't be safely imported!
17:04:37 <lambdabot>      The module itself isn't safe.
17:04:52 <JonReed> Of course.
17:06:15 <JonReed> The evalution order of (+) is mysterious
17:06:54 <JonReed> let five = (trace "5") 5
17:09:04 <JonReed> Am I right to assume that in (a + b) b executes first?
17:09:22 <jle`> do you mean 'b is evaluated first'?
17:09:43 <jle`> i don't think that that is defined behavior
17:09:44 <JonReed> `undefined + five` outputs "5" first then error
17:09:56 <jle`> and it would also be based on the Num instance you're using, too
17:10:07 <JonReed> So it basically random
17:10:17 <jle`> not random, but probably not defined
17:10:32 <JonReed> Yeah, I mean it can be in any order compiler chooses
17:10:33 <jle`> might be deterministic in a lot of simple cases
17:10:53 <jle`> potentially.  but also, the Num instance itself can have a say in it
17:11:00 <jle`> remember that evevry type implements its own +
17:11:18 <jle`> the answer you are looking for probably depends on how + is defined for whatever type you're asking about
17:11:26 <JonReed> Ah yeah right. 
17:11:37 <jle`> so it might not be up to the compiler, but up to how + is defined.
17:14:32 <JonReed> It's interesting that plus in `Num Int` is defined as `I# x + I# y = I# (x +# y)` but second argument still executes first if you trace it
17:16:49 <athan> whaaa? What's this hairy syntax: `newtype instance MVector s ...`?
17:17:16 <jle`> athan: it looks like a data family instance declaration
17:17:47 <athan> hrm, thanks jle`
17:18:18 <athan> So unboxed vectors aren't mutable, they just contain `Unbox`ed data?
17:22:38 <Axman6> yes
17:23:10 <niteria> does anyone know what the status of hoogle 5 is? http://hoogle.haskell.org/ has a big warning that type search doesn't work, but it does appear to work
17:23:12 <Axman6> mutable/immutable and boxed/unboxed are orthogonal properties of vectors 
17:23:34 <ReinH> JonReed:  In (say) print (x+ y), it doesn't matter whether x or y is evaluated first. They mean the same thing. A Haskell compiler is free to evaluate either x or y first. Debug.Trace lets you observe GHC implementation details in this way.
17:24:06 <ReinH> Depending on implementation of (+)
17:25:59 <ReinH> When both evaluation orders are denotationally equivalent, GHC has to pick one. Debug.Trace lets you observe this. It's marked unsafe for a reason.
17:27:05 <JonReed> ReinH: Yeah, I know since it's pure evaluation order does not matter. But it still interesting why it would choose the second one first.
17:27:36 <ReinH> It really isn't interesting ;)
17:27:50 <ReinH> Flip a coin ;)
17:27:50 <hpc> it's just picking one or the other
17:27:58 <JonReed> It's illogical
17:28:07 <hpc> there are /far/ more interesting bits to ghc than that
17:28:08 <ReinH> It's perfectly logical
17:28:22 <ReinH> If it doesn't matter, either order is as good as the other
17:28:47 <ReinH> It's illogical to think that it's illogical
17:29:06 <ReinH> It means you have a bias
17:29:49 <ReinH> You prefer one order over the other for no reason. Illogical.
17:30:54 <verement> > undefined * 0
17:30:57 <lambdabot>  *Exception: Prelude.undefined
17:31:04 <hpc> JonReed: i can see the assumptions behind your expecting it to be the other way around, but ghc's models are quite different from a simple interpretation of haskell's denotational semantics
17:31:07 <verement> > 0 * undefined
17:31:09 <lambdabot>  *Exception: Prelude.undefined
17:31:37 <verement> hmm, that's different than GHC 7.10.3
17:31:47 <ReinH> If two choices are equivalent, a preference for one is illogical.
17:32:19 <hpc> JonReed: if you're up to it, check out the ghc commentary and documentation
17:32:22 <hpc> @where commentary
17:32:22 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary
17:32:57 <ReinH> If I will give you a dollar for heads and a dollar for tails, preferring heads is illogical.
17:33:13 <hpc> it's fun to take apart if you have enough prerequisite understanding to get through it
17:33:35 <hpc> (and if not, you'll get there eventually - it's worth the effort)
17:34:44 <JonReed> hpc: Thx. I'll check it out.
18:03:15 <jchia> I've been scratching my head trying to understand the code here: http://www.yesodweb.com/blog/2014/01/conduit-transformer-exception . The first code block, the one that follows "yields that sum:", seems wrong. the do block are in the monadic context of a ConduitM but he just calls get for the State Monad without any lifting. Is it wrong or am I missing something?
18:03:57 <lyndon> Hey Haskellers. Is there a type-class based parser that can work off sum types?
18:04:53 <lyndon> Not a very well thought out question I know haha.
18:05:17 <lyndon> So, basically you structure your parser definition as a collection of sum types.
18:10:24 <ReinH> :t get
18:10:27 <lambdabot> MonadState s m => m s
18:10:56 <ReinH> jchia: get uses a typeclass so lifting isn't necessary
18:11:36 <ReinH> This is provided by mtl
18:11:42 <jchia> not in transformers?
18:11:50 <ReinH> Nope
18:12:07 <ReinH> mtl adds this to transformers
18:13:16 <jchia> ReinH: If I use both mtl and transformers, I'll get some name clashes, righT?
18:13:26 <ReinH> So stacks that include a StateT s "layer" can be given MonadState s instances and use get from mtl
18:13:46 <ReinH> Yes, you can just import from mtl though
18:15:04 <ReinH> lyndon: can you give an example?
18:15:56 <jchia> ReinH: Do you mean when I import, I can specify which package to import from? If so, how do I do that?
18:17:04 <dibblego> lyndon: there is hackage/parsers which generalises parsec/trifecta/attoparsec like parsers, but that doesn't relate specifically to sum types [what does that mean?]
18:17:43 <ReinH> jchia: the module names don't clash.
18:18:39 <jchia> ReinH: You're right, I just looked at the names and realized they are different
18:19:37 <ReinH> It would be pretty annoying if they did.
18:20:12 <jchia> ReinH: Does that mean I have to use StateT from mtl instead of transformers in order to use the more 'forgiving' get?
18:20:51 <ReinH> They are the same. mtl is based on transformers.
18:21:22 <ReinH> StateT in mtl is imported from transformers and reexported.
18:22:23 <jchia> ReinH: I didn't know that. Good to know. Thanks.
18:23:45 <lyndon> ReinH: Sure, say if I had a Sum-Type representing line endings "data LE = Unix | DOS | Mac" and I'd like to create a parser instance for what each constructor matches, then have the parser 'fill in the blanks'...
18:24:23 <lyndon> dibblego: Mmm, I've used megaparsec etc. but that's more generalising the stream rather than the parser...
18:24:29 <ReinH> lyndon: <$ can be useful here
18:24:53 <ReinH> e,g., Unix <$ string "\r\n"
18:25:08 <lyndon> ReinH: is that from Parsec?
18:25:16 <dibblego> Data.Functor
18:25:17 <ReinH> It's from Functor
18:25:22 <lyndon> Oh right!
18:25:29 <dibblego> @type fmap . const
18:25:31 <lambdabot> Functor f => b -> f b1 -> f b
18:25:41 <ReinH> The unreasonable effectiveness of combinator!
18:25:50 <ReinH> Combinators
18:26:18 <lyndon> Yep... I see. I can definitely create the parser this way, but I'm interested if there's a way to 'underspecify' it via this instance idea.
18:26:40 <ReinH> What kind of code would you like to write?
18:26:40 <lyndon> I'll try to come up with a better example to share.
18:28:03 <dibblego> you can generalise the constructor of that specific data type using a classy prism
18:28:58 <lyndon> dibblego: This sounds like it might be a good fit
18:32:16 <dibblego> class AsUnix a where _Unix :: Prism' a (); instance AsUnix LE where _Unix = prism' (const Unix) (\a → case a of Unix -> Just (); _ -> Nothing)
18:32:54 <lyndon> http://lpaste.net/1277924659446153216
18:33:02 <lyndon> Something like this?
18:42:00 <lyndon> dibblego: and could you convert the prism into a traversal to pull all instances out of a string?
18:44:00 <dibblego> all prisms are traversals, but it is traversing all the () values in a LE
18:44:30 <dibblego> the _Unix prism/traversal will traverse all the () values (that is, one of them if it is Unix, and zero of them if it is anything else)
18:46:41 <cads> Hey do you guys know how to make a database that distributes itself across users? Like "Feel free to use the database, as long as you download some important chunks of the database and serve it to others"
18:47:10 <ReinH> That is not a Haskell question. That is a very difficult non-Haskell question.
18:47:28 <Axman6> projects to do that do exist
18:47:53 <cads> not haskell projects?
18:49:11 <cads> The bittorrent protocol is similar, but it doesn't handle database updates or complex queries
18:49:19 <peddie> @hackage kademlia
18:49:20 <lambdabot> http://hackage.haskell.org/package/kademlia
18:49:21 <lyndon> dibblego: cheers
18:49:54 <peddie> cads, that ^ is a haskell package that implements a distributed hash table
18:58:37 <cads> huh, this is not a simple problem
18:58:48 <geekosaur> no, no it is not
18:59:23 <peddie> cads: not at all, but there is a lot of research out there on it (which has nothing to do with haskell)
18:59:40 <cads> peddie, I'm not sure how to implement things like queries over a hash table, apart from a really ugly brute force march through the key list
19:00:18 <cads> peddie, well, I'm trying to decide/discover if haskell has any pre-existing tools here, and if it's even the right language
19:00:23 <peddie> cads: I'll bet you could read the code for the package I linked above to find out
19:01:16 <cads> I think that the user nodes would have to be running in the browser or on mobile apps
19:01:48 <peddie> cads: you could see whether that package will build with ghcjs
19:01:55 <peddie> @hackage dht
19:01:55 <lambdabot> http://hackage.haskell.org/package/dht
19:02:18 <peddie> oops
19:03:05 * cads is reading the kademlia paper to see what kinds of queries it can handle
19:11:09 <ReinH> It's a DHT, so not many
19:17:10 * hackagebot hspec-golden-aeson 0.2.0.2 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.2.0.2 (mchaver)
19:18:25 <cads> Yeah I'm reading the kad paper and if I squint very hard it seems like the FIND_VALUE primitive could be turned into a query lookup primitive. But I'm betting I can find better algorithms 
19:19:10 <ReinH> Distributed data structures in Byzantine systems are especially difficult
19:19:21 <peddie> cads: you could see what GNUnet do, I seem to recall they support certain classes of text search
19:20:46 <LordBrain> Is your study motivated by a specific project cads?
19:21:37 <LordBrain> even if it is vapor ware, vaguely defined in your mind, i'm curious.
19:22:25 <LordBrain> having some nice haskell library for distributed data would be cool
19:22:35 <LordBrain> not sure what is already out there
19:23:12 <cads> Sure, I'd like to make a microservice that serves data from the USDA Nutrient Database, and I'd like to make it a kind of self-sustaining public good. Here's the database: https://www.ars.usda.gov/northeast-area/beltsville-md/beltsville-human-nutrition-research-center/nutrient-data-laboratory/docs/usda-national-nutrient-database-for-standard-reference/
19:24:43 <cads> Here's the database in the ASCII form that it's distributed in: https://github.com/maxsu/USDA-SR28
19:25:13 <cads> The schema is kinda neat: https://github.com/maxsu/USDA-SR28/blob/master/schema.png
19:25:29 <dfeuer> I'm really confused. Why does GHC warn that pattern guards are non-standard when run as Haskell2010?
19:25:41 * Clint squints.
19:25:55 <dfeuer> Is that just a bug?
19:26:41 <LordBrain> hmmm can you do a pastebin dfeuer, maybe its the sort of pattern guards, not all of them...
19:27:31 <lpaste> dfeuer pasted “GHC warning bug?” at http://lpaste.net/5792384957733142528
19:27:38 <dfeuer> LordBrain, there you go.
19:27:57 <dfeuer> There doesn't seem to be anything remotely weird about that use, but maybe I'm missing something.
19:29:07 <geekosaur> probably an oops nobody spotted because -XHaskell98 and -XHaskell2010 have been broken for so long anyway
19:29:13 <benzrf> hah
19:29:22 <geekosaur> and even when they worked, nobody bothered
19:29:46 <cads> LordBrain, I'll keep you updated on what I find, if you'd like
19:29:56 <dfeuer> geekosaur, I get the same warning if I specify neither of those.
19:29:59 <LordBrain> sure, thanks
19:30:02 <geekosaur> odd
19:30:09 <geekosaur> ok, that seems like a bug somewhere
19:30:13 <dfeuer> That is, I *always* get the warning if I don't specify PatternGuards.
19:31:45 <cads> LordBrain, right now I'm thinking it's going to be something that gets built on something ugly, like node, since I'm not confident that I have the experience I need to target JS in the browser from GHCJS.
19:31:48 <dfeuer> geekosaur, can you reproduce?
19:32:21 <glguy> I don't get the warning with either -XHaskell2010 or without specifying a flag on GHC 8.0.1
19:32:32 <LordBrain> hmm
19:32:39 <glguy> Maybe you're working in a package.cabal with default-language: Haskell98
19:32:50 <LordBrain> i didnt know you meant to target js
19:33:32 <LordBrain> i'd rather see it implemented in haskell, client end and all
19:33:37 <dfeuer> glguy, I'm on GHC 7.8 right now, and containers.cabal does not have a default-language line.
19:34:16 <glguy> Oh, I don't have 7.8 around to test with
19:34:23 <geekosaur> I'm not getting it with 7.10.3
19:34:40 <dfeuer> This is weird.
19:34:48 <dfeuer> I'm also not getting it in GHCi.
19:34:54 <dfeuer> Maybe there's something funny...
19:35:00 <LordBrain> javascript doesnt work everywhere as well as it is reputed to, for example i use the netsurf browser, and its js implementation is almost useless for most non-trivial stuff on the internet
19:35:33 <geekosaur> javascript is the new "write once, debug everywhere" >.>
19:35:38 <dfeuer> Noooo...
19:35:45 <LordBrain> but, if you're on really low-end machine, such as rasberry pi or worse, you know, netsurf actually runs much better than firefox
19:36:14 <cads> LordBrain, I'd like the users themselves to spawn a database node when they visit a web viewer or other app that uses the database.
19:36:53 <LordBrain> cads, do you know what i miss, protocols with built-in shells... remember the old ftp
19:37:01 <cads> Lol, yeah
19:37:02 <LordBrain> or telnet
19:37:04 <benzrf> 22:32 <cads> LordBrain, right now I'm thinking it's going to be something that gets built on something ugly, like node, since I'm not confident that I have the experience I need to target JS in the browser from GHCJS.
19:37:08 <benzrf> this is what i would expect, but
19:37:17 <benzrf> i finally tried out using ghcjs for the browser recentlyish
19:37:22 <benzrf> and it is shockingly polished
19:37:28 <filthy_casual> hmm "->" is the free magma on the base types, no? ("is the" is probably not quite the right words there)
19:37:35 <benzrf> "base types"?
19:37:37 <LordBrain> how can we bring back the special-purpose shell approach?
19:38:00 <dfeuer> geekosaur, LordBrain, I can't reproduce it with GHC. Could cabal be somehow defaulting to Haskell 98?
19:38:05 <filthy_casual> Just types other than function types, is all I mean.
19:38:14 <benzrf> then no
19:38:16 <geekosaur> I would think people owuld have noticed
19:38:17 <dfeuer> OR some similar compat mode?
19:38:18 <benzrf> 1 -> 1 = 1
19:38:28 <cads> LordBrain, but it could be written in haskell or java as a library that spins up a database node when it's called - this makes it easier to target mobile apps
19:38:29 <geekosaur> since h'98 used a different prelude throughout 7.x
19:38:40 <geekosaur> and was incompatible with like 90% of packages as a result
19:38:42 <benzrf> (assuming we're quotienting by isomorphism)
19:38:42 <LordBrain> dfeuer, newer cabal i think requires you to specify, older ones probalby default to 98 if you dont
19:38:46 <geekosaur> (likewise h'2010)
19:38:54 <filthy_casual> benzrf: bizzarly enough I am not.
19:39:06 <benzrf> well, if so -
19:39:15 <geekosaur> well, not through all of 7.x, but ever since Num lost the "superclasses"
19:39:16 <dfeuer> LordBrain, but even if I specify Haskell2010, I get this stupid warning. Is there a way to tell Cabal not to mess with the language?
19:39:17 <benzrf> then that's true of literally any binary type constructor
19:39:25 <cads> LordBrain, then again I'm not sure if it's a good idea to expect mobile apps to "carry" much of this database
19:39:32 <geekosaur> you could try -v3 or something to see what it's actually feeding ghc
19:39:53 <filthy_casual> benzrf...yes it is isn't it. Okay I was overthinking this.
19:39:59 <benzrf> lol
19:41:25 <cads> benzrf, it'd be great to code this puppy in haskell
19:41:48 <filthy_casual> Though a type system that was up to iso would be interesting. 
19:42:04 <filthy_casual> Not sure if you could actually check it.
19:42:10 <LordBrain> it would be awesome if all these web protocols had shells, and online help
19:42:43 <LordBrain> then people would make all sorts of UIs around them i bet
19:43:02 <LordBrain> but, not having that convenience, people dont bother
19:43:05 <cads> friendly chatbots
19:43:08 <LordBrain> yeah
19:43:27 <cads> "hey sooooo, I notice you don't know how to use this protocol, can I halp?"
19:43:32 <dfeuer> geekosaur, yeah, it's passing -XHaskell98 for some reason. How can I tell it not to?
19:43:34 <LordBrain> aha
19:43:59 <LordBrain> well, just having a standardized help command that lists the various commands categories etc would be good enough
19:45:17 <LordBrain> we dont need the paper clip
19:45:21 <LordBrain> :)
19:46:21 <benzrf> cads: i tried using reflex-frp and it seems to, like
19:46:23 <benzrf> Just Work™
19:46:45 <jonored> Apparently there's been research that suggests that the main failing of the paperclip was that it put itself into a social role, and then acted like a nosy co-worker who can't mind it's own business and let you work.
19:46:59 <geekosaur> sounds about right
19:47:20 <geekosaur> dfeuer, I have no idea :/
19:47:31 <benzrf> i did run into an issue with one external library, but
19:47:40 <benzrf> it was comparatively niche
19:47:59 <benzrf> lens, text have worked perfectly
19:48:01 <geekosaur> is this thing up somewhere? (I assume it is not the current release of containers on hackage)
19:48:05 <jonored> (and that similar ideas that /don't/ do screw up on that work reasonably well.)
19:48:08 <cads> benzrf, if you're using Just Work™ in the context of GHCJS you can color me impressed. I will try to build it in windows just to be sadistic.
19:48:17 <benzrf> lmao
19:48:30 <benzrf> i mean, you may run into issues - but they seem to be the exception rather than the norm
19:48:42 <geekosaur> ghcjs has had a lot of work put into it to have it Just Work
19:48:47 <benzrf> fwiw, i'm using reflex-platform's tool for setting up a working environment using nix
19:48:49 <dfeuer> geekosaur, give me a few minutes to get it on GitHub.
19:48:53 <benzrf> it may be a pain if you try to figure it out from scratch
19:49:20 <cads> imo, a GHCJS that that Just Works will be _huge_ for Haskell. Makes it Webscale™
19:49:56 <benzrf> my usage of it has been by and large near-identical to my normal programming workflow
19:50:19 <benzrf> write some code, hit build, tab to the browser and reload, poke it to make sure the code works, blah blah blah
19:50:27 <geekosaur> I gather getting ghcjs installed is a pain though
19:50:34 <cads> I mean... works in production, deploys reliably... that is game changing 
19:50:50 <benzrf> the aforementioned semi-niche external library issue is the only significant arcane thing i've run into
19:50:54 <benzrf> i think
19:50:54 <geekosaur> the downside is it comes with a JS port of runtime+base which is a lot of code
19:50:58 <benzrf> ya
19:52:54 <LordBrain> i tried ghcjs some years ago, and it was pretty cool, but yeah, its a lot of code, and yo have to build it
19:53:44 <LordBrain> if you look at the webkit examples, you can make your program actually not be js, just a regular binary too, which i liked
19:54:01 <LordBrain> same code, just build it different, get a different target
19:54:43 <cads> webkits lets us deploy native binaries too, right?
19:54:58 <cads> webkit*
19:58:42 <LordBrain> what was the name for the part of the URL which is usually www ? I forget
19:58:54 <cads> gosh that would be so neat - a distributed database that pushes itself out to the users without having to install an app, and if the target environment has a native environment, it pushes a precompiled binary
19:58:59 <zomg> LordBrain: subdomain
19:59:25 <cads> native client*
19:59:54 <dfeuer> geekosaur, check out https://github.com/treeowl/containers/tree/map-min-max  and run cabal test set-properties (which will immediately build Data.Set.Internal, triggering the bogus warning, at least on my machine).
19:59:54 <LordBrain> oh, i thought that, but i wasnt sure, some reason i thought that subdomain might be after the www and before the domain or something
20:00:20 <LordBrain> Anyway, we should make a w3m subdomain convention
20:00:31 <LordBrain> so that there's a w3m friendly version of your page
20:00:47 <zomg> LordBrain: protocol://subdomain.domain.top-level-domain?querystring#hash :)
20:01:03 <LordBrain> thanks
20:01:36 <zomg> oh and also /path :P
20:01:51 <LordBrain> www is so common, that its kind of funny, because it is subdomain technically, but is used like a top level
20:02:37 <zomg> my understanding is that it comes from the old days when you would have things like mail server, web server, etc.
20:02:50 <zomg> so mail.domain.com would be the mail server, www.domain.com would be the web server and so forth
20:03:37 <filthy_casual> Oh, that makes sense.
20:05:01 <LordBrain> there should be a specifically text-specific one, www is not specific enough, in the age of web apps
20:08:06 <ongy> there's also standard ways to encode username+password into the uri.
20:08:29 <geekosaur> hm. I cant even configure it
20:08:32 <geekosaur> The following packages are involved in a dependency cycle ChasingBottoms-1.3.1, containers-0.5.8.0, test-framework-quickcheck2-0.3.0.3, test-framework-0.8.1.1, xml-1.3.14, text-1.2.2.1, binary-0.8.4.1, regex-posix-0.95.2, regex-base-0.93.2, QuickCheck-2.8.2, test-framework-hunit-0.3.0.2
20:08:54 <geekosaur> in a sandbox, with global only having the stuff from hvr's 7.10.3 package
20:09:25 <geekosaur> (cabal install --only-dependencies --enable-tests)
20:14:06 <filthy_casual> Um, okay I think this is me having a brain fart, but is the free monad on F just Fix (\ a -> F a + a)?
20:15:54 <cads> hey guys, is haskell-blah being deprecated in favor of -offtopic?
20:16:19 <LordBrain> one of them requires you connect using tls, the other does not
20:16:32 <jle`> cads: i don't think so
20:16:36 <jle`> the two co-exist
20:17:06 <dfeuer> geekosaur, oh, sorry. You need to install the deps manually. You can see what to install in .travis.yml.
20:17:37 <dfeuer> (There aren't many deps, but cabal won't help)
20:19:56 <dfeuer> geekosaur, you still there?
20:20:12 <geekosaur> yes, I'm installing deps (around network dropouts)
20:20:22 <geekosaur> (and watching CONCACAF qualies >.> )
20:22:43 <geekosaur> just built and ran test successfully
20:22:52 <geekosaur> dfeuer, ^
20:23:02 <benzrf> filthy_casual: yeah looks right
20:24:20 <dfeuer> geekosaur, and you didn't get any spurious warnings about PatternGuards?
20:24:38 <geekosaur> nope
20:24:51 <dfeuer> geekosaur, what version of cabal-install are you running?
20:25:08 <dfeuer> (and Cabal)
20:25:45 <geekosaur> oh, hm, I did not get the one I expected
20:25:50 <dfeuer> Oh?
20:25:57 <geekosaur> cabal-install version 1.22.6.0
20:25:57 <geekosaur> using version 1.22.4.0 of the Cabal library
20:26:11 <dfeuer> Hmm... I'm using 1.24 at the moment.
20:26:12 <geekosaur> which "should" have been from hvr's ppa
20:26:57 <dfeuer> I'm going to open this as a PR and see what Travis has to say about it.
20:27:28 <dfeuer> This whole thing is majorly mysterious to me.
20:27:34 <geekosaur> still no warning with 1,24
20:27:36 <geekosaur> cabal-install version 1.24.0.0
20:27:36 <geekosaur> compiled using version 1.24.0.0 of the Cabal library
20:27:47 <dfeuer> o.O
20:28:48 * geekosaur had a different cabal in his private .bin, whoops
20:29:17 <dfeuer> geekosaur, but ... why would I be getting this stupid warning?
20:29:25 <geekosaur> I have no idea :/
20:29:31 <dfeuer> This is Deeply Mysterious to me.
20:31:13 <dfeuer> Well, I guess I can just add the stupid "extension" anyway, but that seems a bit silly.
20:38:38 <dfeuer> Why do I seem to have to perform my own call pattern specialization here? I'd have thought GHC could handle this :-(
20:47:18 <barret> :t unfold
20:47:20 <lambdabot> error:
20:47:20 <lambdabot>     • Variable not in scope: unfold
20:47:20 <lambdabot>     • Perhaps you meant one of these:
20:47:49 <jle`> :t unfoldr
20:47:51 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:49:38 <barret> > take 5 $ unfoldr (\ b -> Just (0,0)) 0
20:49:40 <lambdabot>  [0,0,0,0,0]
20:51:00 <barret> (barret) > unfoldr (\ b -> if b== 0 then Nothing else Just (b,b-1)) 5
20:51:12 <barret> > unfoldr (\ b -> if b== 0 then Nothing else Just (b,b-1)) 5
20:51:14 <lambdabot>  [5,4,3,2,1]
20:51:47 <barret> Is that like state?
20:51:49 <glguy> barret: You can play with lambdabot with: /msg lambdabot "example"
20:52:50 <glguy> Is what like state?
20:53:12 <barret> The (a,b)
20:53:59 <barret> Does that make sense?
20:55:26 <glguy> In "(b -> Maybe (a, b)) -> b -> [a]", b is like the state of the operation that is carried along as elements are generated
20:55:42 <barret> Perhaps that's not the way to call it, but it seems like the way people use state and traverse
20:56:40 <dfeuer> glguy, it looks like Travis runs into the same issue, at least for some versions (they're not all done building yet). https://travis-ci.org/haskell/containers/jobs/158063552
20:56:48 <dfeuer> Er ..
20:56:52 <dfeuer> Sorry, I meant geekosaur 
20:58:00 <barret> But I was referring to the State monad, which I understand is like a combination of a Reader and a Writer monad
20:58:06 <geekosaur> weeeeird
20:58:49 <barret> :t scanr
20:58:51 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
20:59:34 <barret> It looks a bit like that too
21:00:00 <ReinH> State is not like a combination of Reader and Writer
21:00:07 <barret> Can I implement unfold using the State monad?
21:00:55 <barret> Or the correct combination of Reader and Writer?
21:02:50 <barret> Is carrying the value of type b less restrictive than folding the list as it's generated?
21:03:13 <tracysmith> :t scanr
21:03:15 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
21:03:44 <tracysmith> :t scanl
21:03:46 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
21:04:01 <dfeuer> geekosaur, I'm just going to manually slam PatternGuards. I wish I understood what's going wrong, but I can't really deal with it now.
21:04:12 <barret> What are you illustrating tracysmith?
21:04:50 <tracysmith> no,just try to play with lambdabot
21:05:01 <dfeuer> tracysmith, type  /query lambdabot    
21:05:05 <dfeuer> And then talk privately.
21:05:17 <dfeuer> Or /msg lambdabot message to lambdabot
21:05:33 <tracysmith> ok:-D@dfeuer
21:10:46 <barret> Sorry I got disconnected
21:13:51 <barret> I guess I'm confused about the various ways to determine the new element. Is the type of unfold so general as to capture for example various different folds implemented using traverse? I guess that as the b was around as the new elements are created that even the whole growing list could be stored to determine the new element
21:15:09 <barret> Is this the same question as, are there operations over a list which can't be expressed with a fold?
21:15:30 <dfeuer> barret, your question is a bit hard to parse. Are you talking about folds or unfolds? What does traverse have to do with it?
21:16:04 <dfeuer> Every operation on a list can be expressed with a fold, at least formally.
21:16:17 <barret> To determine the new element from the list you should fold it, retaining b during unfold seems équivalant
21:16:46 <dfeuer> In particular, barret,  foldr (:) [] = id, so you can always fold the list to make a copy and then work with the copy...
21:17:06 <dfeuer> Hrm?
21:17:12 * hackagebot servant-aeson-specs 0.5.1.1 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.5.1.1 (mchaver)
21:17:14 * hackagebot JuicyPixels-scale-dct 0.1.1.2 - Scale JuicyPixels images with DCT  https://hackage.haskell.org/package/JuicyPixels-scale-dct-0.1.1.2 (phadej)
21:17:16 * hackagebot bits-bytestring-lazy 0.1.0.1 - Bits instance for lazy bytestrings.  https://hackage.haskell.org/package/bits-bytestring-lazy-0.1.0.1 (semaj)
21:17:18 * hackagebot ec2-unikernel 0.9.1 - A handy tool for uploading unikernels to Amazon's EC2.  https://hackage.haskell.org/package/ec2-unikernel-0.9.1 (AdamWick)
21:17:23 <dfeuer> I can't quite see what you're getting at. unfolds *produce* lists. Folds *consume* lists.
21:18:09 <joe9> dcoutts_: dcoutts: need some help with gtk2hs. From what I understand, gtk3 deprecated the gdk_draw family of functions. Is there any sample to use gtk2hs with cairo? Can you please help?
21:19:16 <barret> To produce a list you need to generate elements from the only thing in scope which is the list you are generating, folding this list returns the new element, this is equivalent to the implementation above retaining b to contain the days from folding the list (accessing each element during the unfold)
21:19:59 <barret> Data*
21:22:00 <barret> This seems to indicate the only way to generate the new element us by folding, which seems quite far reaching and raises the questions above
21:22:14 <barret> Is*
21:23:32 <barret> Is fold capable of representing all operations over lists?
21:24:37 <dfeuer> barret, yes, although not always in a meaningful way.
21:25:15 <dfeuer> But I still have no clue what you're trying to get at.
21:25:44 <barret> A foldable instance provides [a] - b, are you saying all m a -> b define a foldable instance for m?
21:26:15 <barret> ->*
21:26:55 <barret> (Probably need a basecase)
21:27:53 <barret> Is there a formal description of this phenomina?
21:28:35 <barret> All measurable containers are Foldable?
21:28:44 <Cooler> doesn't fmap cover bind?
21:29:02 <barret> :t bind
21:29:04 <lambdabot> error:
21:29:04 <lambdabot>     • Variable not in scope: bind
21:29:04 <lambdabot>     • Perhaps you meant one of these:
21:29:10 <Cooler> a -> m b same as a -> c ?
21:29:32 <barret> :t (>>=)
21:29:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:29:42 <Cooler> :t fmap
21:29:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:30:04 <barret> Seems to contain a fold
21:30:08 <barret> As;
21:30:15 <barret> :t join
21:30:17 <lambdabot> Monad m => m (m a) -> m a
21:30:24 <barret> :t fold
21:30:27 <lambdabot> (Monoid m, Foldable t) => t m -> m
21:32:29 <barret> I'm pretty sure all containers are isomorphic to list, and if they are not then they cannot be used to determine a measure via fold
21:33:20 <barret> Do we have recursive datatypes which are not foldable?
21:33:31 <dibblego> yes, lots
21:33:39 <dibblego> NonEmptyList is foldable and not isomorphic to list
21:34:19 <barret> Not foldable and not isomorphic to list was the requirement
21:34:30 <Cooler> why do you need >>= when you have fmap?
21:34:38 <barret> To join
21:35:03 <barret> :t concatMap
21:35:05 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
21:35:23 <dibblego> () is not foldable and not isomorphic to list
21:35:49 <barret> Is it the only one?
21:36:18 <barret> It's the archetypal useless container in that it can retain no contents
21:36:23 <johnw> trees are not isomorphic to lists
21:36:33 <barret> But they are foldable
21:36:42 <johnw> folding does not require isomorphism
21:36:47 <johnw> just catamorphism
21:36:47 <dibblego> the set of things not foldable and not isomorphic to list, is enormous
21:36:50 <barret> My guess is all recursive datatypes are foldable
21:37:05 <johnw> all recursive inductively defined types are indeed foldable as a general principle
21:37:23 <barret> Woot
21:37:30 <barret> Can I get a reference?
21:37:34 <johnw> i'm not sure if all GADTs are foldable...
21:38:01 <barret> Does the phenomena have a name?
21:38:33 <dfeuer> johnw, I doubt folding them is terribly useful in general. Eliminators that reveal the type evidence are usually what you really want.
21:38:42 <dfeuer> barret, the word "phenomena" is plural.
21:38:50 <johnw> barret: it depends on what aspect of this statement you want a name for
21:38:57 <dfeuer> A dictionary will tell you what its singular form is.
21:39:38 <dfeuer> eliminator, catamorphism, fold, ....
21:39:41 <johnw> initial...
21:39:47 <barret> So all foldable things have a toList, and if they have an alternative instance then they are isomorphic to list
21:39:55 <johnw> not isomorphic
21:39:58 <barret> Yes
21:40:00 <johnw> isomorphism is a really strong requirement
21:40:08 <barret> Because of the alternative instance
21:40:19 <johnw> lists have no internal structure, so anything that you flatten into a list loses its structure
21:40:20 <dibblego> Maybe is alternative, is foldable, and is not isomorphic to list
21:40:50 <barret> Can fold the list resulting from toList using Applicative to obtain the inverse
21:40:58 <dfeuer> ????
21:41:08 <johnw> no
21:41:15 <johnw> "anything that you flatten into a list loses its structure"
21:41:33 <dfeuer> Unless it had no extra structure to begin with.
21:41:36 <johnw> right
21:41:43 <barret> :t (foldr (<|>) empty).toList
21:41:44 <lambdabot> error:
21:41:45 <lambdabot>     Ambiguous occurrence ‘toList’
21:41:45 <lambdabot>     It could refer to either ‘F.toList’,
21:41:54 <dfeuer> In which case foldMap and singleton together show the structure to be a free monoid :-)
21:41:56 <johnw> data MyType a = Foo a (MyType a) | Bar a (MyType a).
21:42:09 <johnw> if you use toList on that, you'll never know where the Foo's and Bar's where
21:42:18 <johnw> it is not isomorphic to a list
21:42:27 <johnw> (add a Nil to my definition, please)
21:42:41 <barret> :t (foldr (<|>) empty).(foldr (:) [])
21:42:42 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
21:42:57 <barret> Oh
21:43:45 <ReinH> The only foldables that are isomorphic to [a] are those that are isomorphic to [a]
21:44:10 <ReinH> e.g., data TotallyNotAList a = Nil | Cons a
21:44:32 <johnw> dibblego used Maybe as an example up above
21:44:33 <barret> So we have a well defined notion of "shape" or "structure" as you call it
21:44:45 <johnw> yes, it's the definition of the type itself
21:44:55 <barret> I like the example with two constructors
21:45:13 <barret> (3)
21:45:17 <dfeuer> Er ... I guess a foldable can have *less* structure than a list, in which case folding doesn't lose anything but it's not a free structure.
21:45:22 <dfeuer> not a free monoid I mean.
21:45:26 * dfeuer is sleepy.
21:45:48 <johnw> dfeuer: I'm not sure there are even laws to say that all the elements that it *could* fold over must be folded over, are there?
21:45:58 <barret> Why is it Free and not just a Monoid?
21:46:01 <dfeuer> johnw, oh, that's another point.
21:46:44 <barret> No you could easily implement fold to skip elements
21:46:46 <dfeuer> Can someone give me a clue why I need to perform call-pattern specialization manually here? Why can't GHC do the job for me? https://github.com/haskell/containers/pull/337/files#diff-5366b4e8a4694a42b87f15d68e307e9dR610
21:46:52 <nshepperd> johnw: the Traversable laws say that, if it happens to also be Traversable
21:47:01 <johnw> nshepperd: right
21:47:01 <barret> Oooh
21:47:16 <nshepperd> but otherwise yeah fold can be arbitrary
21:47:32 <ReinH> Identity is Foldable as well
21:47:33 <nshepperd> 'fold = const mempty' works for anything
21:47:36 <barret> So no empty values equivalent to empty lists in a list of lists?
21:48:15 <barret> Or no skipping?
21:48:32 <barret> (In these traversable laws)
21:49:04 <ReinH> Const and Proxy are foldable and don't contain any elements at all.
21:49:19 <barret> I'm interested in unfolding something with two applicative instances
21:49:26 <barret> That's the point here
21:49:34 <dibblego> [] and ZipList
21:50:16 <barret> ?
21:50:33 <ReinH> (They use nshepperd's definition)
21:50:47 <ReinH> Are two applicative instances for lists
21:51:25 <ReinH> Not sure what Applicative instances have to do with unfolding though.
21:51:44 <barret> Yes it's only isomorphic to list if it is an instance of some class defining synonyms to cons and empty list (I call this stack)
21:52:32 <dfeuer> ARGH.
21:52:54 <dibblego> data MyList a = MyList (forall b. (a -> b -> b) -> b -> b) -- isomorphic to list, does not define cons and nil synonyms
21:52:58 <barret> Applicative I thought have the ability to fold the list generated by toList, but really it needs (:) not (++)
21:53:12 <barret> (<|>)*
21:53:18 <dibblego> data NotMyList a = Cons a (NotMyList a) | Nil | Hai a -- no isomorphic to list, defines synonyms to cons and nil
21:53:46 <barret> Hmm
21:53:54 <ReinH> X is only isomorphic to list if there are functions f :: [a] -> X and g :: X -> [a]  such that f . g = id and g . f = id
21:54:09 <ReinH> If and only if
21:54:51 <barret> Anyway that's where I see the second alternative instance, for joining using the Hai constructor
21:55:10 <barret> So the problem is unfolding such a type
21:56:25 <barret> If it could be done I guess it would give an isomorphism to list which we have established does not exist, so that an unfold instance is impossible using the definition given
21:56:51 <barret> Unfolder I think adresses this by giving the user a choice of constructor
21:57:44 <barret> https://hackage.haskell.org/package/unfoldable/docs/Data-Unfolder.html
21:58:30 <barret> Is that right?
21:59:04 <ReinH> I think we got sidetracked with tall of isomorphism and I still don't know what you want
21:59:09 <ReinH> Talk
22:02:28 <barret> I was just ensuring it was understood about this constructor confusion to the unfolding process for non list shaped (there's a word for this?) containers
22:03:45 <dfeuer> type Iso s t a b = forall p f . (Profunctor p, Functor f) => p a (f b) -> p s (f t)
22:04:05 <dfeuer> type Iso' s a = Iso s s a a
22:04:25 <dfeuer> Something of type  Iso' s a  is one way to express an isomorphism  between s and a.
22:04:42 <barret> I've been getting to grips with that and wanted to establish the best context i could in summary of my thoughts in absence of a concrete formulation which I guess I obtain when Im done
22:04:50 <ReinH> I think we've decided that we don't have Isis here
22:05:01 <ReinH> Isos
22:05:06 <ReinH> Or Isis I guess
22:05:39 <barret> I have my own type Switch for the job
22:05:50 <barret> (Iso)
22:08:45 <barret> It seems reasonable practice to make isomorphism instances when defining newtypes and give names to conversion functions unType.f.Type, Type.f.unType. It's a little extra overhead but it gives these functions then in the same way that record syntax gives a deconstructer
22:10:04 <barret> I expect these 4 functions always exist for newtypes. I have a paste but I'm keeping it under wraps for now
22:10:28 <geekosaur> :t ala
22:10:31 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
22:10:59 <barret> If anyone knows anything about if any of the concepts I'm addressing could lead me toward publication I would appreciate any pointers
22:11:07 <ReinH> over and under
22:11:14 <dfeuer> o.O
22:11:30 <dfeuer> geekosaur, I never understood that ala thing.
22:11:44 <geekosaur> it's from lens
22:11:47 <glguy> The one to understand is
22:11:49 <glguy> :t au
22:11:53 <lambdabot> Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a
22:11:54 <barret> It's nice to see I'm slowly deriving lens
22:11:59 <ReinH> Which borrowed it from Conor iirc
22:12:10 <glguy> ala is just a convenience function for calling au with a well-known Iso
22:12:32 <dfeuer> glguy, au is pretty mysterious too. Do all these come from some paper?
22:12:41 <Alper> newbie question, dropping the last char of a string. I used reverse, drop 1 and reverse again. Is there a better way?
22:12:55 <glguy> Alper: init is all but the list
22:12:57 <dmj> > init "foo"
22:13:00 <lambdabot>  "fo"
22:13:21 <ReinH> @hackage newtype
22:13:21 <lambdabot> http://hackage.haskell.org/package/newtype
22:13:35 <dmj> @src init
22:13:35 <lambdabot> init [x]    = []
22:13:36 <lambdabot> init (x:xs) = x : init xs
22:13:36 <lambdabot> init []     = error "Prelude.init: empty list"
22:13:36 <ReinH> Oh I thought it linked to McBride's work
22:13:50 <Alper> oh cool, I knew there had to be a better way. Thanks. haskellbook did not mention it in the chapter.
22:14:01 <barret> Alper, i think under the hood this is the only way to do it
22:14:04 <dfeuer> When you see that you're reversing a list twice, you can be fairly confident that there's a better way. It's also rather likely that you shouldn't be using a list.
22:14:13 <ReinH> Just a vague reference to Epigram
22:14:18 <barret> @src init
22:14:18 <lambdabot> init [x]    = []
22:14:18 <lambdabot> init (x:xs) = x : init xs
22:14:18 <lambdabot> init []     = error "Prelude.init: empty list"
22:14:20 <glguy> Alper: If you're working with some type, the thing to do is to read the documentation for the modules associated with that type to see what operations are available:
22:14:29 <glguy> http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html
22:15:04 <ReinH> dfeuer: anyway I guess go find some epigram papers
22:15:30 <barret> @src reverse
22:15:31 <lambdabot> reverse = foldl (flip (:)) []
22:15:32 <Alper> glguy so Data-List lib is available by default?
22:15:45 <Alper> I can run it in ghci and it works.
22:15:52 <glguy> Alper: Yes, everything in the "base" package is available by default
22:15:56 <dfeuer> ReinH, do you have any thoughts on my call pattern specialization question?
22:16:07 <Alper> great, thx again.
22:16:20 <ReinH> dfeuer: none whatsoever!
22:16:30 <dfeuer> ReinH, did you have a chance to glance?
22:16:45 <ReinH> I did. Glancing was not helpful!
22:16:48 <geekosaur> in any case, ala was clear to me on first viewing even without knowing about Iso et al. typeclasses defining types that can be wrapped and unwrapped and relating the wrappers, so as to auto-apply them given a wrapper (thus e.g. ala Sum)
22:16:51 <dfeuer> :(
22:17:05 <ReinH> dfeuer: sorry
22:17:29 <dfeuer> ReinH, I imagine you inferred the non-specialized code from what was there? Or do you want to see it?
22:17:51 <eklavya> does GHC auto parallelise anything or do I have to explicitly use threads always?
22:18:15 <dfeuer> eklavya, you have to use threads explicitly.
22:18:17 <glguy> It does not auto-parallelize, you have to either use threads or "sparks" depending on the situation.
22:18:29 <barret> Link to example of ala Sum? What's the minimal syntax to obtain this function?
22:18:55 <eklavya> so if there is a program without a single fork in it, and I give the RTS N = 2, it will only use a single thread?
22:19:14 <glguy> eklavya: See http://hackage.haskell.org/package/parallel-3.2.1.0/docs/Control-Parallel.html
22:19:20 <geekosaur> eklavya, there are papers about attempts to autothread; but a quick summary is "it doesn't work well at all"
22:19:37 <f-a> hello, I just received a bug report on a package of mine ( http://hackage.haskell.org/package/lentil ): Could not find module ‘Data.Semigroup’ It is a member of the hidden package ... etc. etc. Why is it my cabal not having the same problems? Should I add 'semigroups' and forget about it?
22:19:44 <eklavya> I thought it could compute pure functions in parallel
22:19:52 <ReinH> > ala Sum foldMap [1,2,3]
22:19:54 <lambdabot>  6
22:19:58 <ReinH> It can if you tell it to.
22:20:07 <geekosaur> eklavya, it can. deciding when it's worthwhile is another question
22:20:17 <glguy> f-a: semigroups was recently merged into base, if you don't have your version constraints set correctly someone could be using an older version of base than you support
22:20:31 <glguy> f-a: It's highly unlikely that base == 4.* is the right bound
22:20:39 <f-a> mhhhh
22:20:39 <barret> No way it made Monoids!!!!! Sick!
22:21:05 <ReinH> Eh?
22:21:14 <ReinH> Ah.
22:21:22 <geekosaur> basically, it ends up wasting a lot of effort parallelizing things that gain nothing from it (it takes as long to create the thread as to just compute the value, even with Haskell's lightweight threads)
22:21:24 <f-a> glguy: but 'using a new version of base' would force them to switch GHC, right?
22:21:37 <glguy> f-a: Yes, base versions are tied to GHC versions.
22:21:47 <f-a> mhh, then I'll add semigroups
22:21:55 <ReinH> f-a: you can support both with CPP preprocessor macros if you really want.
22:22:05 <barret> I need this in my life. Can I get ala definition in one line using only Prelude functions?
22:22:23 <eklavya> geekosaur: understood
22:22:27 <geekosaur> barret, no, because Prelude does not have mappings between wrapper functions
22:22:33 <geekosaur> lens does, and uses them
22:22:59 <glguy> f-a: It would be good to figure out which versions of GHC you want to support, and then use CI to verify that your package builds with those versions of GHC. If you don't support a version you can indicate this to your users with teh correct bounds to avoid bug reports
22:23:06 <eklavya> so basically when I see all cores being used it means that almost all haskell packages are written to use all available resources
22:23:18 <geekosaur> someone *could* define those typeclasses independently of lens, but I doubt it'd make base much less Prelude
22:23:38 <dolio> CPP isn't necessary to depend on semigroups together with one version range of base, or just base for other versions.
22:23:48 <geekosaur> ^
22:23:53 <geekosaur> can just use an if impl()
22:24:00 <barret> Sorry
22:24:15 <barret> What do you mean wrapper fictions?
22:24:18 <f-a> I see, thanks for explaining
22:24:26 <barret> Functions*
22:24:59 <geekosaur> barret, for example knowing that Sum (a newtype providing one of two standard Monoid-s that apply to e.g. Int) goes with getSum to extract the value
22:25:21 <geekosaur> and likewise for the other standard Monoid, Product
22:25:33 <barret> Oh so this iso class
22:25:45 <ReinH> class Newtype t where wrap :: a -> t a; unwrap :: t a -> a
22:25:48 <barret> That's tiny
22:25:49 <geekosaur> it's a generalization of this
22:26:12 <geekosaur> the class itself is tiny, but you also need an instance for everything you want to (and can) use something like ala with
22:26:44 <barret> Thanks for the names ReinH I'll update my code I like that convention
22:26:53 <ReinH> instance Newtype Sum where wrap = Sum; unwrap = getSum and etc
22:26:56 <geekosaur> suppose in theory you could use generics to derive them
22:26:58 <ReinH> See:
22:27:19 <ReinH> @hackage newtype, where someone has done this for you already
22:27:19 <lambdabot> http://hackage.haskell.org/package/newtype, where someone has done this for you already
22:28:45 <barret> :t hof
22:28:47 <lambdabot> error: Variable not in scope: hof
22:29:19 <barret> I guess that's from Arrow
22:29:52 <geekosaur> it's just shorthand for "higher order function"
22:30:35 <ReinH> Like map or, indeed, (+)
22:30:38 <zq> is it the case that (=>)'s ordering is reversed for class versus instance decls?
22:30:54 <barret> It's the function used to define ala in NewType
22:31:09 <Alper> Another beginner question, is there a split function in the standard libs?splitOn is not available in ghci.
22:31:17 <ReinH> Then it's probably defined somewhere in newtype
22:31:41 <geekosaur> Alper, if you mean base then no; there are many different ways to split
22:31:44 <glguy> Alper: splitOn usually comes from the split package.
22:31:48 <ReinH> @hackage split
22:31:48 <lambdabot> http://hackage.haskell.org/package/split
22:32:06 <ReinH> Is quite extensive
22:32:06 <geekosaur> Data.List.Split comes from the split package and gives you many different ways to split
22:32:25 <barret> Oops it was an argument name, doh
22:32:29 <Alper> say if you want to split the words in a sentence, the first thing comes to mind is to split by space.
22:33:10 <geekosaur> base itself is small and sheds bits somewhat regularly; things being in base means they must ship with the compiler and often can only be upgraded by upgrading the compiler. this is Bad so as much as possible is split away from base
22:33:25 <ReinH> > words "this is a sentence"
22:33:28 <lambdabot>  ["this","is","a","sentence"]
22:33:33 <ReinH> A few are already defined
22:33:43 <barret> @src words
22:33:43 <lambdabot> words s = case dropWhile isSpace s of
22:33:44 <lambdabot>     "" -> []
22:33:44 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
22:34:31 <geekosaur> well, base must be upgraded with ghc. "bootlibs" are packages other than base that ship with ghc, and usually cannot be safely upgraded without upgrading ghc because they are part of its interface (via template haskell or ghc-api)
22:34:45 <dmj> > splitOn " " "this is a sentence"
22:34:47 <lambdabot>  ["this","is","a","sentence"]
22:35:30 <geekosaur> note the difference
22:35:59 <geekosaur> > (words "  this  is a    sentence ", splitOn " " words "  this  is a    sentence ")
22:36:02 <lambdabot>  error:
22:36:02 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
22:36:02 <lambdabot>                    with actual type ‘[[Char]]’
22:36:05 <geekosaur> bah
22:36:22 <geekosaur> oh, copypasta :/
22:36:31 <geekosaur> > (words "  this  is a    sentence ", splitOn " " "  this  is a    sentence ")
22:36:34 <lambdabot>  (["this","is","a","sentence"],["","","this","","is","a","","","","sentence",...
22:36:39 <Alper> lambdabot compiles the haskell code in the chat window?
22:37:05 <geekosaur> when prefixed with "> " (or @run command), yes
22:37:19 <geekosaur> available packages are restricted and IO is blocked
22:37:54 <enobayram> I've discovered that you can also PM lambdabot with commands
22:37:59 <geekosaur> ye
22:38:00 <geekosaur> s
22:38:28 <Alper> I'm following the haskellbook and it has not talked about importing libs and etc. The chapter talks about the main string functions
22:38:36 <Alper> like take, drop, !! and etc.
22:38:59 <Alper> so I am not sure if I need to import a lib to find the last word in a sentence.
22:39:02 <barret> > foldl (\(b:bs) x-> if x == ' ' then ([]:b:bs) else ((a:b):bs)) "hello world"
22:39:04 <geekosaur> yes. Data.List is in base and doesn't need additional packages installed, although you still have to import it for anything beyond the basics
22:39:04 <lambdabot>  error:
22:39:04 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Expr]’
22:39:04 <lambdabot>        Expected type: [[Expr]]
22:39:40 <barret> > foldl (\(b:bs) x-> if x == ' ' then ([]:b:bs) else ((a:b):bs)) [[]] "hello world"
22:39:43 <lambdabot>  [[a,a,a,a,a],[a,a,a,a,a]]
22:39:51 <barret> Hmm
22:40:01 <Alper> barret I have not learned foldl yet :)
22:40:11 <barret> Oh that's a must
22:40:18 <barret> :t foldl
22:40:21 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
22:40:22 <geekosaur> you failed to define "a" and it took the one from simple-reflect
22:40:25 <geekosaur> :t a
22:40:27 <lambdabot> Expr
22:40:33 <Xnuk> > foldl (\(b:bs) x-> if x == ' ' then ([]:b:bs) else ((x:b):bs)) [[]] "hello world" 
22:40:35 <lambdabot>  ["dlrow","olleh"]
22:40:58 <barret> O guess it needs foldr
22:41:58 <barret> Apparently all functions on lists are folds...
22:42:44 <glguy> which fold is tail?
22:43:27 <Alper> Example from the haskellbook:Now write expressions to perform the following transformations, just with the functions you’ve seen in this chapter. You do not need to do anything clever here. -- Given "Curry is awesome!" -- Return "awesome!"
22:43:33 <barret> Apparently not...
22:43:42 <augur> can i get feedback on a WIP blog post about plotkin's CBN+CBV paper?
22:44:01 <Alper> so the chapter does not talk about foldl, isSpace etc.
22:44:31 <Alper> Trying not to be clever.
22:45:03 <barret> > dropWhile (/='a') "Curry is awesome!"
22:45:06 <lambdabot>  "awesome!"
22:45:35 <glguy> > drop 9 "Curry is awesome!"
22:45:37 <lambdabot>  "awesome!"
22:45:53 <glguy> > const "awesome!" "Curry is awesome!"
22:45:55 <lambdabot>  "awesome!"
22:46:11 <ReinH> reverse . take 8 . reverse
22:46:27 <glguy> Alper: You'll need to be more clever about not being clever
22:46:43 <ReinH> over (iso reverse reverse) (take 8)
22:46:53 <Alper> wait there is more..Now take each of the above and rewrite it in a source file as a general function that could take different string inputs as arguments but retain the same behavior.
22:47:36 <Alper> I take that as the function should work with strings other than "Curry is awesome!"
22:47:37 <glguy> Alper: With only one example all of the solutions above would have the "same behavior"
22:47:55 <barret> [a|a <- "curry is awesome", a `elem` "awesome"]
22:47:57 <ReinH> Then I guess glguy's with const is the winner
22:48:07 <glguy> Good job glguy!
22:48:11 <barret> > [a|a <- "curry is awesome", a `elem` "awesome"]
22:48:13 <lambdabot>  "sawesome"
22:48:21 <ReinH> It's the only one that returns "awesome!" for an arbitrary string.
22:48:31 <barret> Damn...
22:48:43 <ReinH> But I'm pretty sure it's not the one they want.
22:49:34 <Alper> I think it can be boiled down to return the last word in a sentence using only head, tail, take, drop and !!
22:49:46 <barret> How do I write a generator for each letter?
22:49:55 <ReinH> You can't do that, since you can't detect words.
22:49:57 <Alper> as those are the functions mentioned in the chapter.
22:51:03 <ReinH> That particular problem is impossible, so I assume it's not a correct problem statement.
22:52:18 <Alper> Maybe there are more functions I can use mentioned in chapter 1 and 2 that I have not thought about.
22:55:21 <barret> > let (a,f) = ("curry is awesome",\n -> drop n s) in head  [ f n | n <- [1.. length s], ((=='a').head.f) n]
22:55:23 <lambdabot>  error:
22:55:23 <lambdabot>      • Couldn't match expected type ‘[a1]’ with actual type ‘Expr’
22:55:23 <lambdabot>      • In the second argument of ‘drop’, namely ‘s’
22:55:51 <barret> > let (s,f) = ("curry is awesome",\n -> drop n s) in head  [ f n | n <- [1.. length s], ((=='a').head.f) n]
22:55:53 <lambdabot>  "awesome"
22:56:09 <ReinH> Well, it's not impossible if you use recursion and pattern matching, but that can't be the solution the book wants
22:56:18 <barret> lol
22:57:09 <barret> I guess it should use takeWhile
22:59:44 <barret> I'm sure scan and dropwhile will do but I need to get back to my unfold thing so I'll stop looking into ala
23:00:46 <barret> Is there something like NewType for non list shaped recursive types?
23:01:08 <Alper> Agreed ReinH
23:01:48 <barret> Does anyone know about the link between multiple Alternative instances and Unfolded?
23:04:10 <glguy> What should I call this syntax for specifying keyboard shortcuts: "C-a" and "M-x"? emacs?
23:04:15 <barret> Oh actually I wrote a generalisation of my stack type to include an index parameter, maybe someone could look at it?
23:05:23 <geekosaur> glguy, that's the usual description/name, yes. (see for example XMonad.Util.EZConfig.mkKeymap and friends)
23:06:17 <pavonia> glguy: What does 'M' stand for in this?
23:06:21 <glguy> meta
23:07:09 <pavonia> Is that Alt on Windows?
23:07:18 <glguy> It's Alt on most systems
23:07:33 <glguy> But for whatever reason actual terminal alt is different
23:07:38 <geekosaur> emacs' key names come from Lisp Machine terminals
23:07:49 <geekosaur> er, keyboards
23:08:34 <geekosaur> also, in X11 whether meta maps to Alt or Win or ... depends on your keymap
23:09:40 <barret> Emacs sounds friendlier than lisp to refer readers to documentation of the syntax
23:15:08 <geekosaur> lispm isn't the language though, it's https://en.wikipedia.org/wiki/Lisp_machine
23:17:15 * hackagebot hans 3.0.1 - Network Stack  https://hackage.haskell.org/package/hans-3.0.1 (TrevorElliott)
23:17:17 * hackagebot lentil 1.0.3.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.0.3.1 (fffaaa)
23:18:22 <barret> That's just a history lesson
23:18:26 <glguy> I switched my IRC client docs to describe the keyboard shortcuts using emacs notation instead of using the caret notation for control commands. I kind of like ^C over C-c, but then I don't have a good name for M-a
23:19:18 <barret> Ctrl-a,Alt-a obvs
23:19:57 <barret> Windows style popular via ctrl+alt+delete
23:20:26 <barret> By far the most widely understood at present
23:20:34 <glguy> that seems too verbose for a long list of them
23:21:04 <glguy> but for writing out a single one it's certainly OK
23:21:22 <eklavya> how about ~A
23:21:43 <glguy> I've not seen that one used that i recall
23:21:59 <eklavya> no it's not
23:22:15 <eklavya> but you might also have to explain ^C to some people :P
23:22:33 * MarLinn tries to remember what AutoHotkey was using
23:23:00 <barret> Maybe it's just an indentation issue so print pretty. I don't like naming functions as letters unless they are polymorphic arguments, the point is it might seem like less syntax to use an acronym but it's obscuring
23:23:55 <barret> You avoid a lesson in etymology by just using the descriptive label
23:24:49 <glguy> https://github.com/glguy/irc-core#keyboard-shortcuts
23:25:03 <glguy> specific list (not an abstract question)
23:26:09 <barret> It's up to the user of alternative systems to understand how their nomenclature translates to the industry standard. I like the Android keyboard "keyboard with ctrl key"
23:26:37 <shachaf> glguy: You can use ␛
23:27:13 <shachaf> Or how about ⎇
23:28:08 <glguy> oh yeah, that symbol is fun
23:42:22 <lpaste> YellowOnion revised “polymorphic trees.”: “No title” at http://lpaste.net/185186
23:42:49 <YellowOnion> could someone how me with the type classes here^
23:45:04 <pavonia> YellowOnion: You prbably want v in the class definition too
23:46:33 <pavonia> And class contraints in type definitions are not recommended, move them in the function using these types
23:52:36 <YellowOnion> pavonia, if I put v in there, then I probably should put b as well (as per line 50), then I have to define it explicitly in the instance, is that nesscary? all seems a bit redundant.
23:56:13 <pavonia> YellowOnion: Yes, you'll need some restrictions on the result type. Keep in mind that the caller of positionAt can choose what the types of v and b are atm
23:56:44 <pavonia> There are no restrictions, so it could be anything
23:57:11 <YellowOnion> and then it taints the kdTree as well
