00:04:14 <hackerstudent93> Hello
00:07:46 * hackagebot huckleberry 0.10.0.2 - Haskell IOT on Intel Edison and other Linux computers.  https://hackage.haskell.org/package/huckleberry-0.10.0.2 (tkmsm)
00:07:47 * hackagebot dlist 0.8.0.2 - Difference lists  https://hackage.haskell.org/package/dlist-0.8.0.2 (SeanLeather)
00:14:13 <Hi-Angel> Hi
00:14:16 <liste> hi Hi-Angel 
00:14:50 <Hi-Angel> No, it's hi to hackerstudent93 :)
00:15:08 <liste> oh
00:15:25 <liste> seems he left though :(
00:15:31 <Hi-Angel> ☹
00:17:29 <mkoenig> hi. what is the preferred way to convert Int to Text? is it "T.pack . show $ 5" ?
00:18:39 <oherrala> mkoenig: that works
00:20:17 <liste> @hackage formatting -- mkoenig also check this out for more control
00:20:17 <lambdabot> http://hackage.haskell.org/package/formatting -- mkoenig also check this out for more control
00:21:34 <EvanR> > printf "%.02f" 13.37
00:21:37 <lambdabot>  error:
00:21:37 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M639305096149...
00:21:37 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
00:21:43 <EvanR> > printf "%.02f" 13.37 :: Text
00:21:45 <lambdabot>  error:
00:21:45 <lambdabot>      Not in scope: type constructor or class ‘Text’
00:22:24 <sbrg> don't think that printf can do Text by default.
00:22:25 <sbrg> IIRC
00:24:16 <EvanR> in any case im surprised lambdabot doesnt know Text
00:25:46 <mkoenig> liste: thank you. that's what I have been looking for.
00:26:38 <liste> @let import qualified Text as T
00:26:39 <lambdabot>  .L.hs:140:1: error:
00:26:39 <lambdabot>      Failed to load interface for ‘Text’
00:26:39 <lambdabot>      Use -v to see a list of the files searched for.
00:26:51 <liste> @let import qualified Data.Text as T
00:26:53 <lambdabot>  Defined.
00:26:59 <liste> oh, it can do that
00:27:05 <liste> I'm sure it couldn't before
00:28:52 <akfp2> is there a package that can read yaml/json files, a template, and output "merged" results (replacing fields with the contents from yaml/json)?
00:29:26 <akfp2> I don't want something over-engineered.  No compile-time checking, nothing that's engineered to "scale".
00:32:19 <kadoban> Maybe hastache? I don't know how to hook up the yaml/json parts, though I know stack is doing that.
00:32:35 <kadoban> It may be obvious from the docs, I barely looked.
00:38:53 <nico_> Is there a kind level composition operator, like (,): * -> * -> *, which would be (*->*) -> (*->*) -> * -> * ?
00:39:11 <shachaf> It's often called :*:
00:39:28 <Cale> Data.Functor.Compose?
00:39:38 <Cale> Or... oh, you want product of functors
00:39:47 <mniip> :k (:*:)
00:39:49 <lambdabot> error:
00:39:49 <lambdabot>     Not in scope: type constructor or class ‘:*:’
00:39:49 <lambdabot>     Perhaps you meant ‘:~:’ (imported from Data.Typeable)
00:40:02 <Cale> http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Product.html
00:40:03 <mniip> :t (:*:)
00:40:04 <lambdabot> error: Data constructor not in scope: :*:
00:40:08 <mniip> shame
00:40:09 <Cale> http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html
00:40:24 <shachaf> @let import Data.Functor.Product
00:40:26 <lambdabot>  Defined.
00:40:27 <nico_> thank you
00:40:58 <nico_> :k Compose
00:41:00 <lambdabot> error:
00:41:00 <lambdabot>     Not in scope: type constructor or class ‘Compose’
00:41:04 <shachaf> If :*: is pointwise product, :~: must be pointwise equality.
00:49:09 <jle`>  :*: is already in GHC.Generics
00:49:32 <jle`>  in base
01:08:10 <{AS}> Is there a way to specify alternative patterns in Haskell?
01:08:46 * hackagebot servant-aeson-specs 0.5.0.0 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.5.0.0 (mchaver)
01:12:02 <cocreature> {AS}: not sure if I understand your question correctly but maybe you are looking for pattern synonyms
01:12:27 <{AS}> cocreature: I want to match on multiple constructors
01:12:39 <{AS}> i.e. if I have data ABC = A | B | C
01:12:43 <cocreature> you can do that with view patterns
01:12:55 <{AS}> I want to do case abc of A | B -> f1 ; C -> f2
01:12:59 <{AS}> cocreature: OK, thanks!
01:13:19 <{AS}> so I have to do a view pattern for each possible case I want?
01:13:34 <cocreature> yep
01:14:49 <pavonia> cocreature: Could you give a small sample how that would look like?
01:19:55 <pkmx> let f A = True ; f B = True ; f _ = False ; case abc of (f -> True) -> ...
01:21:03 <pkmx> To make it prettier, you can define pattern AOrB <- (f -> True) and then write: case abc of AOrB -> ...
01:21:54 <cocreature> yeah that’s what I was thinking of
01:22:29 <verement> why not just: case abc of x | f x -> …
01:23:57 <pkmx> verement: that works in this case, but you can also consider: data ABC = A Int | B Int | C Char
01:24:00 <pavonia> Hhm, there should be a real multiple case alternatives extension, IMHO
01:24:11 <cocreature> verement: that works if you have these enum like constructors, what pattern synonyms give you is the ability to bind variables
01:24:40 <pkmx> let f (A x) = Just x ; f (B x) = Just x ; f (C _) = Nothing ; case abc of (f -> Just x) -> ...
01:25:15 <{AS}> Thanks for the suggestions :)
01:25:29 <pkmx> but you can also write case abc of x | Just y <- f x I guess
01:26:28 <merijn> pavonia: The simplest approach for "multiple case" is just name the relevant code in where/let and use that in all branches
01:26:56 <pavonia> That's what I usually does but it's not very nice
01:27:03 <pavonia> *do
01:59:28 <merijn> pavonia: Ocaml style multi patterns would be nice, yes. But I don't think they're that crucial
02:09:47 * hackagebot servant-aeson-specs 0.5.1.0 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.5.1.0 (mchaver)
02:17:58 <ongy> I am currently using ghc-mod in vim to get type information. It takes a moment to figure out what the type of an expression is. When I don't change the line, I get following requests instantly. Is there a to extend that to the file? 
02:23:12 <merijn> ongy: It runs a daemon in the background and only recompiles the file if it changed
02:23:35 <ongy> merijn: then I have to have something wrong with my setup.
02:23:37 <merijn> ongy: It's using GHC-the-library to compile and query type info
02:24:12 <merijn> ongy: hmm, you mean it's slow on other lines after that?
02:24:27 <merijn> ongy: Also, try specifying "-O0 -fno-code" that should speed up typechecking a lot
02:24:29 <ongy> slow and spikes one core cpu usage
02:24:58 <merijn> (I'm using hdevtools atm, so not too sure about ghc-mod)
02:27:22 <ongy> hm maybe I will look into hdevtools
02:27:55 <merijn> Not sure how it's maintenance state is atm. Last time I picked up an unpublished fork from github for GHC 7.10
02:28:17 <ongy> cabal install worked for 8.0.1
02:28:18 <ph88> can someone comment on my attempt to make haddock comment with doctest + quickcheck ??  https://paste.fedoraproject.org/421896/16816147/
02:42:28 <ongy> merijn: does hdevtools need stack?
02:42:55 <merijn> ongy: I've never used stack, so I'm going to go with "no" :)
02:43:04 <ongy> ok, then I'm quite confused
02:43:08 <ongy> do you mind helping me set it up?
02:43:32 <merijn> ongy: Depends what the problem is? :)
02:44:04 <merijn> oh, there's a new release since last sunday, apparently
02:45:16 <ongy> ah, that one doesn't complain about stack not existing
02:46:07 <ongy> now I get some linking error
02:46:16 <ongy> looks like it doesn't have the template haskell stuff in my project
02:49:09 <ongy> hm, works in a different project that does not have TH
02:58:44 <ongy> merijn: found my error: https://github.com/bitc/vim-hdevtools/issues/27
03:03:38 <Insanity_> The order of filters in list comprehension do not impact the performance, right? So if I'd have to first make a list with the most important filter (performance-wise), and afterwards pass this list on to another function with a second filter? 
03:04:42 <lyxia> it does impact performance
03:05:59 <Insanity_> so if I first have my filter which can make a list significantly smaller, but has a low performance-hit, and then have as a second filter my computation-heavy filter, that second filter will happen on the list produced by filter 1?
03:06:51 <lyxia> right
03:07:01 <Insanity_> I see, handy, thanks :)
03:10:14 <Cale> Insanity_: Actually, probably there is no intermediate list, but still, if the first condition fails, the second won't be computed.
03:10:47 <Cale> (at least, if you have optimisations turned on)
03:11:06 <Insanity_> I'm not sure what "optimisations turned on" would signify
03:11:19 <Cale> Ah, the elimination of intermediate lists
03:11:21 <Insanity_> But I see what you mean, each entry goes through the filters consecutively
03:11:32 <Insanity_> Yes, but how would I turn them on?
03:11:39 <Cale> Oh, -O or -O2
03:11:44 <Insanity_> Thanks :-)
03:25:39 <ongy> both the haddock link and link on 'GHC' in section 2 of https://wiki.haskell.org/GHC/As_a_library are broken. I also can't find a package on hackage. Is there a current documentation somewhere?
03:26:05 <ertes> Insanity_: you can get a better feeling for how the performance of list comprehensions behaves by desugaring into 'concatMap' manually
03:26:32 <Insanity_> I'm not sure what that entails unfortunatelly
03:27:21 <ertes> > [ x + y | x <- [1..5], odd x, y <- [10,20,30] ]
03:27:24 <lambdabot>  [11,21,31,13,23,33,15,25,35]
03:28:30 <ertes> > concatMap [1..5] $ \x -> if odd x then concatMap [10,20,30] (\y -> [x + y]) else []
03:28:32 <lambdabot>  error:
03:28:32 <lambdabot>      • Couldn't match expected type ‘[b0] -> [b]’
03:28:32 <lambdabot>                    with actual type ‘[Integer]’
03:28:41 <ertes> d'oh
03:28:59 <ertes> > concatMap (\x -> if odd x then concatMap (\y -> [x + y]) [10,20,30] else []) [1..5]
03:29:01 <lambdabot>  [11,21,31,13,23,33,15,25,35]
03:29:34 <ertes> Insanity_: every "<-" translates into a concatMap, and every predicate translates into an 'if' with a [] in the 'else' branch
03:30:14 <ertes> and the stuff left of "|" translates into a singleton list
03:31:57 <Insanity_> I see, thank you :D
03:32:03 <Insanity_> It helps to think of this in terms of if-else
03:32:26 <ertes> Insanity_: concatMap is your map-and-filter-on-steroids =)
03:33:17 <ertes> > concatMap (\x -> if even x then [x - 1, x + 1] else []) [11,22,33,44]
03:33:19 <lambdabot>  [21,23,43,45]
03:33:38 <Insanity_> that is cool :D
03:38:00 <mpickering> ongy: http://downloads.haskell.org/~ghc/latest/docs/html/ ?
03:38:29 <ongy> thx
03:42:42 <dinnu93> How to do a Regexp query on Bloodhound ?
03:42:55 <merijn> ls
03:43:09 <cocreature> merijn: wrong window :)
03:43:58 <merijn> cocreature: I know :p
03:46:46 <bjs> cocreature: the correct response is to pretend to be merijn's terminal
03:47:16 <cocreature> bjs: that’s only fun if someone types sudo :)
03:50:21 <merijn> cocreature: That never happens, because I use su :p
03:51:22 <maerwald> it's a common problem with irssi that people confuse terminal and irc
03:52:20 <merijn> Especially when you use tmux and left half of your screen is irssi and the right is your shell. Don't notice your cursor is on the IRC half and whoops
03:52:42 <linduxed> i don't like to use su: root on my computers hasn't got the terminal configured to my liking
03:53:48 <ertes> make sure your configuration is portable between your regular user and root
03:54:33 <ertes> usually just a matter of adding a few 'if' and/or 'case' to your shell config
03:56:23 <dave24> would it be theoretically possible to write a haskell compiler that generates executables without runtime garbage collection?
03:56:37 <merijn> dave24: Sure
03:56:50 <dave24> without leaking of course
03:56:57 <merijn> dave24: Making it have reasonable performance/memory consumption will be rather tricky
03:56:57 <ertes> dave24: you can disable GC using an RTS flag
03:57:31 <dave24> oh i see, so ghc already does that. Because one of the biggest problems I have with ghc is the massive runtime
03:57:51 <merijn> dave24: That still includes the RTS, but just disables GCing
03:57:51 <ertes> dave24: you can't get rid of the runtime though…  GC is only a small part of it
03:58:01 <merijn> dave24: Why do you care?
03:58:49 <dave24> merijn: because big runtimes are not nice, they take up ram
03:59:57 <MarcelineVQ> how much ram is that?
04:00:37 <ertes> dave24: i don't have a single piece of hardware that doesn't measure RAM in gigabytes, so i'm not too worried =)
04:01:00 <bjs> ertes: you're the reason we need machines that measure ram in gigabytes :)
04:01:16 <merijn> bjs: The runtime is like 3-4 MB max
04:01:21 <bjs> yes
04:01:46 <ertes> bjs: not really…  i wouldn't write the coreutils suite in haskell ;)
04:01:49 <merijn> So worrying about that is a clear sign of not caring about results, but focussing on the wrong details
04:02:09 <cocreature> or it’s a sign that for your usecase haskell is probably not the right language :)
04:02:18 <ertes> memory is pretty cheap compared to some other resources like CPU time
04:02:22 <cocreature> i.e., if you are doing embedded and actually care about 3mb of ram
04:02:49 <merijn> bjs: I mean, I have shells taking up more memory than that
04:03:04 <bjs> cocreature: i'm going to be honest, i've never seen haskell employed in an embedded setting and am wondering how well it would go
04:03:24 <ph88> can someone comment on my attempt to make haddock comment with doctest + quickcheck ??  https://paste.fedoraproject.org/421896/16816147/
04:03:24 <merijn> bjs: Now that "embedded" devices have GBs of memory too, probably ok
04:03:39 <bjs> merijn: haha, i guess
04:03:40 <ertes> systemd is using 5 MiB here
04:03:43 <ertes> and it does nothing
04:03:44 <ertes> nothing
04:03:53 <cocreature> bjs: most attempts I’ve seen use a haskell dsl to compile to something more lowlevel like C
04:04:21 <cocreature> merijn: at that point there is little reason to make the distinction between embedded and “normal” hardware :)
04:04:25 <bjs> cocreature: interesting, but that seems a pretty standard approach
04:11:49 * hackagebot http-proxy 0.1.0.4 - A library for writing HTTP and HTTPS proxies  https://hackage.haskell.org/package/http-proxy-0.1.0.4 (ErikDeCastroLopo)
04:11:51 * hackagebot irc-fun-types 0.2 - Common types for IRC related packages  https://hackage.haskell.org/package/irc-fun-types-0.2 (akrasner)
04:11:53 * hackagebot purescript-bridge 0.7.0.1 - Generate PureScript data types from Haskell data types  https://hackage.haskell.org/package/purescript-bridge-0.7.0.1 (eskimo)
05:02:15 <saurabhnanda> is there an easy way to export all lenses related to a record?
05:02:54 <cocreature> saurabhnanda: no (well you might be able to throw in some TH but I haven’t seen that anywhere)
05:03:11 <saurabhnanda> cocreature: best to make a module and export everything from there?
05:03:34 <cocreature> I tend to just put it manually in my export list
05:07:15 <quchen> saurabhnanda: I recommend generating lenses for X in X.Lens, and exporting everything.
05:07:28 <quchen> Your lenses don’t pollute your Haddock, you can import them qualified, …
05:07:45 * hackagebot HaLeX 1.2.2 - HaLeX enables modelling, manipulation and animation of regular languages  https://hackage.haskell.org/package/HaLeX-1.2.2 (joaoSaraiva)
05:07:47 * hackagebot servant-subscriber 0.5.0.1 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.5.0.1 (eskimo)
05:07:49 * hackagebot irc-fun-messages 0.4 - Types and functions for working with the IRC protocol.  https://hackage.haskell.org/package/irc-fun-messages-0.4 (akrasner)
05:07:51 * hackagebot servant-purescript 0.3.1.2 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.3.1.2 (eskimo)
05:08:33 <saurabhnanda> cocreature: boilerplate, no
05:08:56 <saurabhnanda> quchen: right, that's what I was thinking. Make a module only for the purpose of exporting stuff easily.
05:09:06 <cocreature> saurabhnanda: sure it’s boilerplate but you write it once and it’s not complicated boilerplate that causes a maintenance overhead
05:10:25 <saurabhnanda> cocreature: umm... what's complicated boilerplate? boilerplate is boilerplate. Stuff that is repetitive and adds no value. We have a complete language dedicated to extracting out high-level abstractions, but are completely alright with mundane boilerplate? doesn't make sense to me.
05:10:50 <saurabhnanda> boilerplate in Haskell is unacceptable.
05:12:12 <cocreature> saurabhnanda: if I have to write boilerplate code that breaks on updates and can contain bugs, it adds a significant maintenance overhead. if I just have to maintain a list of names that doesn’t change very often I prefer that to having to create separate modules. avoiding boilerplate is great but I think you can drive it too far
05:12:47 <saurabhnanda> cocreature: try looking at it from another angle. Programmer UX.
05:12:59 <bartavelle> avoiding boilerplate at all costs also drives the "meta problem" problem, where you never get anything done
05:13:05 * bartavelle is an expert on that
05:14:31 <cocreature> saurabhnanda: don’t get me wrong, if I could just say “export all lenses” in my export list, I would totally do that. but having to create a separate module is also not great programmer ux or whatever you want to call that
05:14:45 <quchen> Sure it is.
05:14:54 <quchen> New module, import old one, add to .cabal file.
05:14:59 <quchen> One minute. Done.
05:15:15 <cocreature> add 5 names to an export list. one minute. done.
05:15:28 <saurabhnanda> Someone should add this to the Haskel2020 project. Basic friction points that shouldn't exist.
05:15:51 <saurabhnanda> cocreature: not so fast. Not if you're dealing with a big domain containing 50 tables mapping to 50 record types.
05:16:00 <bartavelle> I usually have way more than 5 names
05:16:26 <cocreature> anyway I don’t think this discussion is helpful. we have to agree to disagree :)
05:16:27 <srhb> saurabhnanda: Add what, exactly? "Export all lenses keyword"?
05:16:48 <saurabhnanda> srhb: yes. something like that.
05:16:48 <MarLinn> 50 record types in one module? I hear an antipattern screaming in agony
05:16:52 <Guest623> is there no way of somehow putting the lenses for a data type in a common namespace?
05:16:52 <srhb> saurabhnanda: :|
05:17:38 <saurabhnanda> MarLinn: why anti-pattern? and how does it matter if it's a single  module or multiple modules? The pain of exporting lenses is the same.
05:17:50 <bartavelle> MarLinn, you can't really do it otherwise in certain cases, for example if you use persistent
05:18:16 <bartavelle> as for some reason it won't generate foreign key constraints if you don't do it all in a single TH statement
05:19:25 <saurabhnanda> bartavelle: that too.
05:19:40 <MarLinn> That's a limitation of persistent. If you can work around it with an antipattern, that doesn't make it good
05:20:03 <bartavelle> MarLinn, didn't say it was good, just that you can't just create more modules
05:20:15 <bartavelle> also I don't think 50 type declaration in a single module is that high
05:20:25 <saurabhnanda> aaaand yet another boilerplate. what's with enumerating every single module in cabal files?
05:20:25 <Guest623> Haskell doesn't use enough namespaces :(
05:20:54 <tdammers> Guest623: Haskell's namespace mechanism is too simple
05:21:14 <Guest623> Yes
05:21:22 <tdammers> Guest623: if it were more powerful, i.e., if we had first-class modules and such, then I'm sure people would find ways to use them productively
05:21:23 <MarLinn> But yes, exporting from multiple modules is not a good answer as well. All I'm saying is there seem to be bigger issues in the background
05:21:44 <tdammers> Guest623: also, it's kind of unfortunate that record fields are not namespaced to the record type, or even the value constructor
05:22:09 <tdammers> i.e., you can't have data Foo = Foo { name :: Text } and data Bar = Bar { name :: Text } in the same namespace
05:22:18 <Guest623> tdammers: Yes, that's really bad
05:22:44 <Guest623> I'm thinking about moving each record definition to its own module…
05:22:52 <Guest623> But so many modules then…
05:23:02 <srhb> Guest623: Doesn't really help that much. Also, solutions are coming to that issue with TDNR
05:23:04 <tdammers> yes, that's a very common approach
05:23:04 <srhb> Afair.
05:23:13 <tdammers> the alternative is to say data Foo = Foo { fooName :: Text }
05:23:21 <bartavelle> that's what they do in many OOP languages, one file per class
05:23:26 <tdammers> which is about as awesome as "namespaces" in C
05:23:42 <Guest623> or classes in python
05:23:44 <bartavelle> tdammers, well, you can makeClassy and use the lens ...
05:23:57 <Guest623> how does the makeClassy thing work?
05:24:44 <srhb> Guest623: class HasFoo ... where 
05:24:46 <bartavelle> makes an HasField instance for your lens if I'm not mistaken (I use plain makeLenses)
05:25:41 <bartavelle> http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-TH.html#v:makeClassy
05:25:53 <tdammers> Simplified: class HasName a where { name :: a -> Text }; data Foo = Foo { fooName :: Text }; instance HasName Foo where { name = fooName }
05:26:13 <tdammers> except that name is a lens, not a plain getter, and that the whole typeclass and instance are generated for you
05:26:31 <zoran119_> my cabal project has src/Main.hs and i have added src/api/Core.hs but cabal keeps saying that 'Failed to load interface for Api.Core'. do i need to add the new file to cabal config somehow?
05:26:38 <Guest623> That's nice
05:26:53 <tdammers> zoran119_: filenames must match module names, case-sensitively so
05:27:17 <bartavelle> anyway, even with record overloading the record update syntax is terrible, so I don't think lens users would care
05:27:17 <tdammers> zoran119_: Api.Core, thus, must be in src/Api/Core.hs, not src/api/Core.hs
05:27:50 <zoran119_> tdammers: ah, ok. what's the convention, Api/Core.hs or api/Core.hs?
05:27:52 <bartavelle> would be nicer to derive JSON instances though, without messing with the options
05:28:11 <srhb> zoran119_: There's no choice, it's Api/Core.hs
05:28:22 <tdammers> zoran119_: it's not a convention, it's a hard rule. Module names must match directory names case sensitively, and since module names must start with an uppercase letter, it has to be src/Api/Core.hs
05:28:40 <srhb> zoran119_: Or APi, or API...
05:29:07 <zoran119_> tdammers: i see, that has fixed it, thank you very much
05:30:11 <Guest623> What's the state of TDNR?
05:30:50 <geekosaur> "unlikely to ever happen"
05:31:00 <Guest623> :_(
05:35:16 <Guest623> What about the state of nested modules?
05:39:00 <MarLinn> I suppose our answers for such namespace deficiencies are classes, phantom types, and proxies. Of course if you insist on records, lenses and TH you can't really use those tools.
05:40:40 <Guest623> How can phantom types and proxies be used to solve namespacing issues?
05:42:18 <saurabhnanda> asking again -- classy-prelude vs protolude vs overture?
05:43:10 <MarLinn> Guest623: roughly, by pulling the record accessor out of the record and adding such a type parameter to direct what it does. 
05:43:51 <bartavelle> turn records into dictionnaries and query a key ?
05:43:55 <Guest623> MarLinn: do you not have to define all accessors manually then?
05:44:58 <MarLinn> There's probably something you can do with TH if you really want...
05:45:35 <bartavelle> well you can have Symbols, so you can have ad-hoc types like that
05:45:58 <bartavelle> there was a library not too long ago along those lines
05:46:02 <bartavelle> using type-level sets
05:48:08 <MarLinn> after all data declarations are just some implicit switch statements and a record only adds some functions and sugar to that. There are other ways to get tools with the same power
05:48:14 <bartavelle> this: https://turingjump.com/blog/bookkeeper/
05:49:54 <Guest623> bartavelle: I was reading https://nikita-volkov.github.io/record/
05:50:26 <bartavelle> this one uses TH if I'm not mistaken, bookkeeper doesn't but requires GHC 8
05:55:45 <maerwald> yeah, I wouldn't want TH to be that deep into my types
06:06:17 <haskell277> hello everyone
06:06:50 <haskell277> is there someone to help me about parsing in haskell
06:07:38 <haskell277> is there someone to help me about parsing in haskell
06:07:46 <{AS}> What should I do when verboseCheck hangs?
06:07:51 <srhb> haskell277: Just state your question, people can then determine if they can help :)
06:08:02 <{AS}> It says passed 100 tests
06:08:02 <mauke> haskell277: we're not psychic
06:08:11 <zomg> haskell277: try repeating it a few more times to make sure you get the prize
06:08:11 <{AS}> but when I use verboseCheck to see what tests it generated
06:08:17 <{AS}> It just hangs
06:08:51 <bartavelle> {AS} are you generating potentially infinite test input where the test doesn't need to process all of it ?
06:09:22 <{AS}> bartavelle: i am deriving arbitrary
06:09:37 <bartavelle> it really depends on what the input type is
06:09:53 <{AS}> bartavelle: It is a lambda calculus
06:09:59 <bartavelle> {AS}, does the "sample" function hang too for that type ?
06:10:08 <{AS}> bartavelle: let me try
06:10:14 <mahdi> is there a strict version of foldM, just like foldl'? 
06:11:10 <{AS}> bartavelle: it doesn't hang
06:11:14 <{AS}> just produces a very large term
06:11:38 <haskell277> I have to write a simple interpreter and then a commplex one for that I need parsing, for parsing i came about various libraries like parsec etc but i am stucked that where to start from...I am a beginner so could anyone suggest what Should i do ..or suggest some tutorial links or something else...
06:11:54 <bartavelle> {AS}, no more ideas then :)
06:12:00 <{AS}> bartavelle: Could it be that it generated an infinite term?
06:12:07 <{AS}> I mean it keeps printing etc.
06:12:13 <bartavelle> {AS}, can it ?
06:12:40 <{AS}> bartavelle: I am deriving arbitrary :P
06:12:50 <{AS}> So I am not sure what terms it can generate
06:13:00 <lyxia> how are you deriving it
06:13:07 <lyxia> and what's the type like?
06:13:26 <mauke> presumably with 'deriving (Arbitrary)'
06:13:31 <{AS}> lyxia: It is a `data` lambda calculus
06:13:35 <{AS}> I use derive to derive it
06:13:42 <mauke> oh?
06:13:42 <{AS}> derive makeArbitrary ''Term
06:13:45 <{AS}> I can copy
06:14:09 <bartavelle> haskell277, perhaps you should start with running a very simple parser, then working from this
06:14:31 <bartavelle> haskell277, choose a single library (I'd say megaparsec, as it's a cleaned-up parsec with better error messages)
06:14:46 <{AS}> https://www.irccloud.com/pastebin/XHGP8vP2/
06:14:52 <{AS}> The above ^
06:15:07 <bartavelle> {AS}, you should use http://lpaste.net/ as it's specialized for haskell
06:15:25 <lpaste> “{AS}” pasted “No title” at http://lpaste.net/201876992058982400
06:15:33 <{AS}> bartavelle: thanks
06:15:54 <bartavelle> {AS}, Term has Zero and Var, so it shouldn't generate truly infinite terms, but it can generate huge ones
06:16:08 <lyxia> https://github.com/ndmitchell/derive/issues/10 {AS} 
06:16:19 <haskell277> <bartavelle> is it important to know how parsing libraries work ...bcoz i don't have ... i downloaded parsec but can't get where to start reading the code
06:16:45 <mauke> haskell277: you're not supposed to read the code
06:16:52 <{AS}> lyxia: bartavelle Ah thanks
06:16:55 <bartavelle> haskell277, I *think* that as a beginner you souldn't worry about that
06:17:06 <{AS}> What are your suggestions to fix this?
06:17:16 <{AS}> for me to fix this
06:17:26 <bartavelle> haskell277, my very first haskell program was a complex parsec parser, and I didn't even understand monads
06:17:30 <merijn> {AS}: Write an instance by hand instead of deriving?
06:17:39 <{AS}> merijn: Does that help?
06:17:43 <bartavelle> haskell277, it's entirely possible to just get in, and bruteforce your way to success
06:18:09 <bartavelle> {AS}, you can assign lower probabilities to recursive constructors, reducing the average size of constructs
06:18:21 <{AS}> Ah, thanks
06:19:03 <merijn> {AS}: That issue suggests it generates huge values because the way the derived instances are generated
06:19:31 <{AS}> merijn: Ah I see
06:19:41 <merijn> Basically, what bartavelle said :)
06:19:54 <{AS}> any guide on writing arbitrary instances ? :P
06:20:06 <merijn> {AS}: Pretty sure there's a bunch online somewhere
06:20:14 <bartavelle> {AS}, the haddocks ;)
06:20:20 <haskell277> <mauke> but without that how could i understand what is going beneath ..as like in a function from that library that builds ast given a language and some other stuffs but it doesn't works as I like ....so how to fix this
06:20:31 <ertes> {AS}: -XDeriveGeneric =)
06:20:45 <ertes> oh, wait…  that was smallcheck
06:20:47 <mauke> haskell277: you don't
06:20:56 <{AS}> ertes: Thanks! But I was actually having issues with that :)
06:21:42 <bartavelle> haskell277, this is a parser combinator library, you build your parser from the pieces it provides.
06:21:51 <{AS}> so I use the `frequency`function
06:21:56 <bartavelle> haskell277, it *should* let you built arbitrary parsers
06:22:01 <{AS}> right?
06:22:02 <bartavelle> {AS}, that looks about right
06:22:16 <{AS}> Thanks :)
06:22:24 <bartavelle> another solution is to write a "oneOf" instance and not use "arbitrary" for the subcases but another function
06:22:27 <bartavelle> emulating smallcheck
06:22:27 <ertes> it's amusing that QuickCheck can derive everything via Generic except 'arbitrary'
06:22:40 <bartavelle> ertes, can't it ? I think it can
06:23:34 <haskell277> so what  should i do whether I should try to write from scratch
06:24:36 <lyxia> {AS}: there's my library for that too http://hackage.haskell.org/package/generic-random-0.3.0.0/docs/Generic-Random-Data.html#v:generatorSR
06:24:47 <bartavelle> haskell277, I think you should start with loading the file you need to parse, then try to parse it with a very basic parser and handle parse errors
06:24:53 <{AS}> lyxia: Thanks!
06:24:58 <bartavelle> then you can build your parser incrementally from this
06:25:21 <bartavelle> haskell277, at least that's what I did when learning Haskell. It kind of worked for me, but might not for you!
06:26:31 <haskell277> <bartavelle> right now i just have to parse for simple arithematic expressions and later i have planned to move for some small language
06:27:25 <bartavelle> haskell277, then you should be aware of this module https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Expr.html  that does a lot of hard work for you
06:27:36 <bartavelle> even though I distinctly remember the examples to be completely cryptic
06:28:25 <{AS}> lyxia: Is there a guide on how to use your generator
06:28:40 <Guest623> bartavelle: a problem I find with a lot haskell libraries
06:29:00 <bartavelle> haskell277, message me directly if you want to, I can guide you with the process during (my) afternoon
06:29:12 <ejbs> Hi, the error msg is cryptic. What's wrong with: foldl' (\x y -> x and elem y "ACGT") True "Hello there"
06:29:34 <bartavelle> x and elem y "ACGT" parses as you apply the function x to 4 arguments
06:29:51 <ejbs> Ooh
06:29:59 <bartavelle> x && elem y "ACGT" is probably more like you want it
06:30:13 <ejbs> Yup, there we go
06:30:21 <lyxia> {AS}: for your types this should just work      arbitrary = sized generatorSR
06:30:31 <{AS}> lyxia: Thanks!
06:30:32 <bartavelle> ejbs, you should look at the "all" function too
06:30:38 <bartavelle> ejbs, does the folding for you
06:31:22 <ejbs> bartavelle: I see. So really just: all (`elem` "ACGT") list
06:31:34 <bartavelle> yup
06:31:38 <ejbs> Nice!
06:32:18 <lyxia> {AS}: I'm still trying to figure out how to make it more understandable.
06:32:31 <{AS}> lyxia: More examples
06:32:36 <{AS}> I think everything else is good :)
06:33:32 <haskell277> <bartavelle> ok thanks so now i have to move to megaparsec from parsec library....~~~Q
06:33:50 <{AS}> lyxia: I think examples for each possible function/use case would come a long long way
06:33:57 <lyxia> {AS}: the README also has lambda calculus as an example
06:34:01 <bartavelle> haskell277, it's very close, it mostly has better error messages
06:34:10 <lyxia> {AS}: Yeah good point
06:34:37 <haskell836> @pl flatMap f a = flatten (map f a) 
06:34:37 <lambdabot> flatMap = (flatten .) . map
06:35:15 <ejbs> string2seq "lamb" "RAG" :: MolSeq . MolSeq is RNA | DNA (and depending on branch string2seq returns RNA or DNA). Does it give me that because Haskell can't tell if it returns DNA or RNA?
06:35:40 <lyxia> haskell836: concatMap?
06:35:59 <{AS}> lyxia: Wow, works much better :)
06:36:20 <lyxia> {AS}: Great!
06:36:30 <bartavelle> ejbs, hard to answer, you should paste more code I think
06:36:33 <{AS}> Although: λ> quickCheck prop_typesafe; *** Gave up! Passed only 4 tests.
06:36:39 <{AS}> But it is a hard property I am testing :)
06:36:53 <{AS}> So it is fine
06:37:17 <{AS}> at least it doesn't hang on verboseCheck
06:37:38 <ejbs> bartavelle: Nah, it's alright, I'm gonna read up a bit more instead :)
06:37:51 <quchen> {AS}: Write your own generator that generates more suitable test cases if ==> yields too few results
06:38:14 <{AS}> quchen: Actually, I want to test the random test generator for some research purposes :)
06:38:21 <{AS}> but thanks for the suggestions!
06:38:41 <haskell277> <bartavelle> then can you guide me how to start ...bcoz already i have invested 3 days in parsec library ...can you give me a path to follow bcoz i want to understand from basics so as to modify and develop on my own ...at the same time also have the knowledge what the library is doing and how
06:39:58 <vlopez> hi! i'm doing a heap retainer profile to debug a leak, and I get a big retainer that's named 'SYSTEM'. what does it mean, and how can I know which part of 'SYSTEM' is responsible? thanks!
06:40:01 <bartavelle> k, see your private messages
06:41:09 <ph88> can someone comment on my attempt to make haddock comment with doctest + quickcheck ??  https://paste.fedoraproject.org/421896/16816147/
06:44:17 <cocreature> vlopez: I think system is basically “couldn’t be attributed to anything else”
06:47:53 <vlopez> cocreature: oh. … Is there a way of helping GHC attribute it then? most of this memory shows as 'VOID' in the biographical profile, so I'd be interested in not keeping it around
06:48:31 <ocramz> hullo!
06:48:34 <merijn> SYSTEM also contains pinned memory, afaik
06:48:39 <cocreature> vlopez: sorry not sure if that is possible
06:48:42 <merijn> Such, ByteString
06:49:10 <cocreature> oh yeah that would make sense I guess
06:50:54 <vlopez> cocreature, merijn: hm … in this case it's mostly a big record that holds the state in a strict state monad
06:58:51 <Insanity_> Does Haskell keep checking each step of a recursive predicate? I'm not sure how to word it so the code is this (partly)
06:58:55 <Insanity_> "allPrimes x (y:ys) = isPrime (y + div x y) && allPrimes	x ys"
06:59:12 <Insanity_> if the first statement evaluates to false, will it still continue with the second one
07:00:00 <lyxia> np, && will lazily skip the second argument
07:00:04 <lyxia> no
07:00:24 <Insanity_> Thanks :)
07:00:34 <lyxia> > False && undefined
07:00:36 <lambdabot>  False
07:01:05 <lyxia> You can check whether things are evaluated by replacing them with an error like that.
07:01:25 <Insanity_> I see, thank you :)
07:03:34 <camm> Does this function (>>) has a special name? Like (>>=) that is called as `bind`.
07:04:13 <liste> @src (>>)
07:04:13 <lambdabot> m >> k = m >>= \_ -> k
07:04:17 <ahihi> it is sometimes called "then"
07:04:26 <phadej> camm: http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators
07:04:50 <phadej> indeed, "then"
07:05:06 <camm> Thanks :-D
07:07:24 <merijn> tbh, if you said "then" I would have no idea you'd refer to ">>"
07:09:47 * hackagebot postgresql-simple-migration 0.1.7.0 - PostgreSQL Schema Migrations  https://hackage.haskell.org/package/postgresql-simple-migration-0.1.7.0 (ameingast)
07:10:20 <lyxia> semicolon  m >> k = do { m ; k }
07:13:46 <Benzi-Junior> can lists not be used as arguments to foreign functions ?
07:14:04 <geekosaur> lists are not defined in C
07:15:10 <ph88> doctest doesn't find the test, i don't know why
07:15:19 <ggVGc> Benzi-Junior: ypu'd have to marshal the list into something that C understands. Which would probably mostly be an array
07:18:13 <Benzi-Junior> damn
07:19:53 <Benzi-Junior> aren't the low level implementations of haskell's datastructures algorithimically generated so it would be possible to have a program generate them as C structs ?
07:22:12 <srhb> benzi-junior: newArray :: Storable a => [a] -> IO (Ptr a) ?
07:23:05 <srhb> Benzi-Junior: So as long as your elements have a Storable instance, it's trivially easy.
07:24:14 <merijn> Benzi-Junior: Sure, but then you need to write custom C to use these structs anyway?
07:25:43 <Benzi-Junior> merijn: yes
07:26:16 <Benzi-Junior> merijn: but I don't suppose anyone has made such a program 
07:33:43 <m4lvin> is there an irc channel for stack?
07:34:09 <geekosaur> #haskell-stack
07:34:17 <geekosaur> but most people ask in here
07:34:48 <Benzi-Junior> does anyone here know of  a structure for trees with variable branching other than rose tree ?
07:35:51 <m4lvin> geekosaur: thanks
07:35:52 <m4lvin> I have this problem https://github.com/commercialhaskell/stack/issues/1582 but the solution there does not work. Anyone here with Stack + OS X expertise?
07:36:39 <ejbs> I wanna reduce over two lists, summing up the difference between them (so "abc" "bbc" = 1), is there a good way of doing that in Haskell? I searched for (b -> b -> a) -> a -> [b] -> [b] -> a but found none
07:37:23 <Insanity_> > length "abc" \\ "bbc"
07:37:25 <ongy> :t sum . zipWith (-)
07:37:26 <lambdabot>  error:
07:37:26 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Int’
07:37:26 <lambdabot>      • In the first argument of ‘(\\)’, namely ‘length "abc"’
07:37:27 <lambdabot> (Foldable ((->) [c]), Num [c], Num c) => [c] -> [c]
07:37:59 <ongy> oh right, . doesn't work when to arguments are missing
07:38:02 <Insanity_> I wouldn't take advice from me though ejbs, I'm learning Haskell, but if I import Data.List and use \\ and thelength, it does work
07:38:40 <ejbs> I'll check out zipWith and \\
07:38:40 <Benzi-Junior> it is fairly simple to write with list comprehension 
07:38:44 <Insanity_> >length("abc" \\ "bbc")
07:38:44 <geekosaur> m4lvin, the stated "fix" has nothing to do with the problem, so it's not surprising that it didn't work
07:39:12 <Insanity_> I'm being an idiot here and spamming this channel with the same thing, but I'm trying to let lambdabot evaluate that XD
07:39:15 <Insanity_> > length("abc" \\ "bbc")
07:39:17 <lambdabot>  1
07:39:32 <geekosaur> the problem may be a buggy version of make; apple's shipped a few of those over the years, and both macports and homebrew install a newer known-good one as a result
07:40:00 <geekosaur> (but I don't know offhand if stack will use it automatically)
07:40:29 <ongy> Insanity_: when you notice something like that, you can move to query lambdabot 
07:40:45 <Insanity_> Different Channel?
07:40:53 <ongy> private messages
07:40:57 <Insanity_> Oh right, thanks :)
07:41:10 <ejbs> Insanity_: I'm gonna go with the zipWith solution, since I understand order of evaluation better with that one
07:41:30 <Insanity_> I'd take his advice as well ejbs ;-)
07:41:46 <ongy> ejbs: they are doing different things. (\\) is set difference
07:43:13 <ejbs> ongy: Yeah, that's what it seemed like
07:44:01 <m4lvin> geekosaur, true ;-) is is there a way to use a different make version on mac?
07:47:01 <ph88> can someone comment on my attempt to make haddock comment with doctest + quickcheck ??  https://paste.fedoraproject.org/421896/16816147/
07:47:48 <{AS}> Is there a way I can convert a (a -> Maybe b) to a Maybe a -> b ?
07:48:02 <{AS}> Maybe (a -> b) *
07:48:24 <lyxia> const Nothing
07:48:53 <felko> {AS}: Why would you want that ?
07:49:17 <{AS}> felko: I need it in some more complex progarm
07:49:23 <lyxia> {AS}: there's no safe conversion
07:49:31 <{AS}> Oh :(
07:50:02 <avctr> lyxia what do you mean?
07:50:04 <felko> {AS}: Give some context because that's not really making sense to convert like this
07:50:41 <avctr> so you basically want to invert a function?
07:50:52 <geekosaur> avctr, see correction
07:50:54 <{AS}> felko: So if it doesn't make sense, I will se if I can structure my code differently!
07:50:56 <{AS}> thanks :)
07:51:09 <ejbs> log is in base e by default, yes? (I tried log 2 and log 10 and it seems to be true)
07:51:19 <{AS}> avctr: I want to convert a -> Maybe b to Maybe (a -> b)
07:51:40 <MarLinn> ejbs: yes. For other bases there's logBase
07:51:59 <felko> Is implementing a restricted number set as a long datatype considered as passable code ? like `data Digit = D0 | D1 | D2 | D3 | D4 | .. | D9`
07:52:11 <felko> or is it a bad practice ?
07:53:05 <felko> knowing that my datatype is actually for [0, 100], not just [0, 9]
07:53:24 <MarLinn> felko: You would need a lot of boilerplate for that. A newtype around an Int would be much nicer
07:53:26 <{AS}> felko: I think that would be bad 
07:53:57 <felko> Ok but I have a second question: How would one implement a type-safe weighted list ?
07:54:18 <felko> like, a weighted list where the total of the weights doesn't exceed 1
07:54:43 <merijn> felko: First step would be "implement type level floats", I suppose
07:54:51 <merijn> felko: At which point any sane person runs away screaming
07:55:03 <geekosaur> {AS}, the problem with that is you cannot determine whether it is Just _ or Nothing until you apply it to a value
07:55:13 <MarLinn> why so complicated...
07:55:15 <geekosaur> think about what Maybe (a -> b) means
07:55:27 <felko> merijn / MarLinn: smart constructor then ?
07:55:51 <merijn> felko: As far D0 ... D100 is a bad idea because GHC is known to blow up on data types with large amounts (20+) of constructors
07:56:01 <merijn> felko: Smart constructor is the simplest solution, yes
07:56:08 <felko> ok thanks marienz 
07:56:08 <{AS}> geekosaur: Yeah, I see :|
07:56:13 <felko> oops, merijn 
07:57:04 <{AS}> I will just use exceptions instead of Maybe :P
07:57:25 <{AS}> (It is easier for my particular use case)
07:57:31 <felko> merijn: but how would I implement my smart constructor in the case where the given number is not in the numebr set I want ?
07:57:40 <ph88> doctest is not finding my test
07:57:44 <felko> do I just return a bottom-typed value ?
07:58:01 <merijn> felko: Generally smart constructors return "Maybe MyType"
07:58:12 <merijn> felko: So you can just return Nothing
07:58:24 <felko> merijn: thx
08:00:31 <lyxia> felko: about weighted lists, maybe a GADT looking like this would work    data WList n a where { Nil :: WList n a ; Cons :: KnownNat n => Proxy n -> a -> WList (n + m) a }
08:01:45 <lyxia> seems like a lot of work though
08:01:51 <felko> lyxia: yeah you can restrict n to be KnownNat but how would you restrict also n + m ?
08:02:08 <felko> you would have to use < or > operators
08:02:37 <felko> well that'd be a nice introduction to type families, I'll reconsider after that
08:03:11 <felko> (if type families can support type level numeric operations, can they ?)
08:04:30 <lyxia> !hackage ghc-typelits-knownnat
08:04:39 <lyxia> @hackage ghc-typelits-knownnat
08:04:39 <lambdabot> http://hackage.haskell.org/package/ghc-typelits-knownnat
08:04:52 <chpatrick> hey guys
08:05:04 <chpatrick> any idea why OpenCL would work directly from C but not from haskell?
08:05:18 <chpatrick> here's a minimal test case: https://github.com/chpatrick/oclwtf
08:05:40 <chpatrick> if you make the executable in cbits, it should work, but stack exec oclwtf will not
08:05:50 <chpatrick> at least for me with nvidia opencl on arch
08:06:17 <chpatrick> both the C and haskell executables do nothing except call the same C function
08:06:23 <nut> where is the stack.yaml on windows ?
08:06:27 <nut> the global
08:06:39 <nut> i want to update it to use the latest lts version
08:07:37 <geekosaur> the C one executes from the main thread; the Haskell one will, because it is marked "safe", execute from a separate "bound" thread. some libraries care about this
08:07:50 <chpatrick> geekosaur: unsafe doesn't work either
08:08:02 <sm> nut: stack path
08:08:37 <nut> thanks
08:08:50 <geekosaur> the other thing that comes to mind is that the runtime by default sets an itimer to go off every 0.02 seconds
08:09:04 <chpatrick> geekosaur: +RTS -V0 also doesn't work
08:09:05 <geekosaur> run with +RTS -V0 to disable that timer
08:09:41 <geekosaur> ok, those are the only two things that come to mind. I guess if I had to deal with this I'd try strace next (although having to resort to strace usually indicates desperation...)
08:10:05 <chpatrick> geekosaur: I've tried that too but I'm not sure what to look for :(
08:10:12 <chpatrick> it's pretty bizarre
08:10:20 <geekosaur> and that's why strace is a desperation measure :)
08:10:49 * hackagebot snaplet-purescript 0.5.2.0 - Automatic (re)compilation of purescript projects  https://hackage.haskell.org/package/snaplet-purescript-0.5.2.0 (AlfredoDiNapoli)
08:11:17 <geekosaur> (and I don't know what to look for either, aside from using unsafe and +RTS -V0 and comparing trace output to see what happens differently. which, ugh
08:11:19 <geekosaur> )
08:11:38 <maerwald> chpatrick: I get the same output for both
08:11:50 <chpatrick> maerwald: what do you get?
08:11:57 <maerwald> Result: -1001 Platform count: 0
08:12:07 <chpatrick>  that's the bad outcome
08:12:11 <chpatrick> does clinfo work for you?
08:12:53 <maerwald> I don't know what clinfo is
08:13:03 <chpatrick> ah ok :)
08:13:08 <chpatrick> do you have opencl set up?
08:13:14 <maerwald> no
08:13:32 <chpatrick> ok, this needs opencl
08:13:49 <maerwald> why does it build then?
08:14:30 <chpatrick> maerwald: you probably have the generic headers installed but no actual drivers for it
08:15:14 <maerwald> I have proprietary nvidia drivers
08:16:42 <maerwald> clinfo seems to be something that only ati drivers provide
08:17:03 <chpatrick> maerwald: on arch you can just install it
08:17:49 <felko> lyxia: is there a way to pull a type level value to the value level ? like taking the n of Proxy n into the function body (as a value, not the ScopedTypeVariable thing)
08:18:06 <Freundlich> maerwald: Aren't you on gentoo? You need nvidia-drivers[uvm] then.
08:18:15 <maerwald> Freundlich: no
08:18:24 <maerwald> chpatrick: https://github.com/Oblomov/clinfo it seems it's this
08:19:02 <chpatrick> maerwald: yep
08:20:17 <maerwald> chpatrick: that prints "0 platforms" too
08:20:59 <geekosaur> felko, I believe that requires a KnownNat constraint
08:21:22 <felko> geekosaur: yes but the type constraint is at the type level
08:21:24 <lyxia> felko: natVal
08:21:31 <felko> oh ok thank you
08:21:39 <lyxia> GHC.TypeLits.natVal
08:21:47 <geekosaur> and I think that is what KnownNat gives you
08:22:08 <lyxia> right
08:22:58 * geekosaur was looking that up... a bit slower than usual today :/
08:23:08 <geekosaur> (and I am not a type level bit-banger)
08:23:54 <ph88> anyone experience with doctest ?
08:24:12 <sm> ph88: go ahead and ask your real question :)
08:25:09 <maerwald> chpatrick: ah, now I can reproduce
08:26:45 <Cooler> since functors are structure preserving maps between categories
08:26:58 <Cooler> doesn't that mean functors are functions?
08:31:27 <bartavelle> at least in haskell arbitrary functions can change the structure of what they are applied on
08:31:38 <bartavelle> not sure how that translate to math-language :)
08:32:34 <bartavelle> (also there is a Functor instance for  (->) r )
08:42:46 <ertes> bartavelle: i don't see anything in the API that does it
08:42:55 <ertes> (quickcheck 'arbitrary' deriving)
08:44:07 <bartavelle> ertes, neither can I!
08:44:14 <ejbs> I need to divide two Integers into Double, how do I do that?
08:44:43 <ongy> \x y -> fromIntegral x / fromIntegral y
08:44:45 <bartavelle> ejbs, first convert them to Double. You can also convert them to "Ratio", which will not loose precision
08:45:16 <ph88> sm, i have this piece of code but when i run doctest it says i have 0 tests  https://paste.fedoraproject.org/421896/16816147/
08:46:26 <ejbs> bartavelle: ongy: Hey, it worked. This fromIntegral stuff is hard
08:47:51 <bartavelle> ejbs, not sure that's the hardest part about learning Haskell :)
08:48:56 <ongy> it's just part of "no implicit conversions"
08:56:54 <ertes> :t (/) `on` fromIntegral
08:56:56 <lambdabot> (Integral a, Fractional c) => a -> a -> c
09:08:59 <ongy> I wonder if I will ever remember on
09:10:45 <Cooler> are functors simply functions?
09:10:57 <monochrom> No.
09:11:38 <Cooler> why not?
09:11:39 <Guest59860> Cooler: recommended: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
09:11:50 * hackagebot servant-purescript 0.3.1.3 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.3.1.3 (eskimo)
09:11:52 * hackagebot xmobar 0.24.3 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.24.3 (JoseAntonioOrtegaRuiz)
09:12:43 <Cooler> structure preserving maps between categories sounds like just a function
09:12:47 <ertes> Cooler: if you use set theory and if objects and morphisms are sets, then functors are functions
09:13:01 <ertes> pairs of functions
09:14:09 <ertes> Cooler: category theory doesn't quite stand on its own…  it needs a calculus to make sense of things like "mappings"
09:16:10 <Cooler> ertes, something that implements fmap is a instance of functor
09:16:18 <Cooler> right?
09:16:21 <Guest59860> I'm searching for something like Control.Monad.Loops.whileM but I want to be able to use the list of results up to that point in the boolean condition, any idea?
09:16:38 <ertes> Cooler: a haskell Functor (an instance of Functor) is an endofunctor on the category Hask
09:17:00 <ertes> Cooler: that one is a pair of things, one of which is a type function (* -> *) and another is a regular function
09:17:46 <ertes> Cooler: so "the Maybe functor" is the pair of (Maybe :: * -> *) and (fmap :: (a -> b) -> (Maybe a -> Maybe b))
09:18:29 <ertes> Cooler: more conventionally: s/type function/type constructor/
09:20:54 <ertes> Cooler: a functor is fully specified by an fmap function, if that's all you're asking
09:21:23 <haskell845> @pl \a b -> a
09:21:23 <lambdabot> const
09:21:47 <haskell845> @pl \a b -> b
09:21:47 <lambdabot> const id
09:22:37 <ph88> be back later
09:23:27 <haskell845> \a b c -> c
09:23:33 <haskell845> @pl \a b c -> c
09:23:33 <lambdabot> const (const id)
09:25:22 <Cooler> ertes, so a functor maps from Hask to Hask/
09:25:26 <Cooler> ?
09:25:46 <ReinH> haskell845: please experiment with lambdabot via pm
09:26:02 <haskell845> what is pm?
09:26:32 <haskell845> project manager?
09:26:37 <ReinH> Private message, /query
09:26:50 <glguy> Yes, please speak with your project manager to query lambdabot
09:27:17 * Clint prepares a gantt chart.
09:28:54 <haskell845> No such nick/channel: pl
09:29:16 <yyyyy> also, relevant: http://math.andrej.com/2016/08/06/hask-is-not-a-category/
09:30:06 <byorgey> haskell845: do  /query lambdabot  ,  then talk to lambdabot in the resulting window
09:30:30 <ReinH> pl? Its nick is lambdabot
09:30:58 <haskell845> @yyyyy @ReignH thanks
09:30:58 <lambdabot> Unknown command, try @list
09:31:13 <haskell845> f*ck
09:31:21 <pavonia> This isn't Twitter
09:31:51 <ReinH> A message starting with @ triggers lambdabot
09:32:51 <ertes> Cooler: yeah
09:32:55 <pie_> you guys know any irc channels for constraint solving or something like that?
09:33:27 <monochrom> project leader is also lambdabot? :)
09:34:02 <ertes> @botsnack
09:34:02 <lambdabot> :)
09:34:15 <ertes> there's a good…
09:34:17 <ertes> … thing
09:34:26 <ReinH> Heh
09:34:44 <Cooler> ertes, doesn't it have to do that for every object and morphism in Hask?
09:35:19 <Guest59860> Is there anything like :: ((a, [b]) -> Bool) -> (a -> (a, b)) -> a -> a that applies the second argument to the third while the first is true?
09:35:21 <Cooler> map every object in Hask to objects in Hask and every morphism in Hask to morphisms in Hask
09:35:44 <ertes> we should anthropomorphise lambdabot a bit more…  how about lambdaboy?
09:35:49 <Cooler> and all the source and targets of the morphisms have to line up before and after?
09:36:04 <ertes> Cooler: what are the objects of Hask?
09:36:26 <Cooler> haskell types? your the one who brought up the category Hask
09:36:35 <ertes> Cooler: correct…  do you see how Maybe maps types to types?
09:36:57 <Cooler> ertes, okay.....
09:37:26 <ertes> it is of kind * -> *, which means that for any type A, Maybe A is a type
09:37:37 <ertes> in other words:  it takes a type and returns a type
09:37:50 <Cooler> yes
09:38:13 <ertes> Cooler: that's one of three parts of the Functor deal…  the second is the part that maps morphisms
09:38:16 <ertes> and that's fmap
09:38:41 <Cooler> :t fmap
09:38:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:38:50 <ertes> given any (f :: a -> b), fmap turns that into (fmap f :: Maybe a -> Maybe b)
09:38:59 <ertes> and the third part is the functor laws
09:40:09 <Cooler> ok so far
09:40:16 <yyyyy> note though there is no way inside of haskell to enforce the laws
09:40:19 <ertes> that's it
09:41:15 <ertes> (for haskell Functor functors)
09:41:42 <Cooler> what are the laws?
09:42:18 <ReinH> You should know them
09:42:27 <ReinH> Since you looked up functots
09:42:32 <ReinH> Or functors
09:42:42 <Cooler> yeah but i keep forgetting
09:42:51 <ReinH> So go look them up again
09:43:03 <glguy> ?hackage base
09:43:03 <lambdabot> http://hackage.haskell.org/package/base
09:43:16 <glguy> the laws are in the documentation for Functor
09:43:24 <ertes> Cooler: there is an easy place to find them:  in the haddocks of the class definition…  this convention is ubiquitous in haskell
09:45:54 <Cooler> id and composition
09:46:52 <Cooler> :t id
09:46:54 <lambdabot> a -> a
09:48:33 <Cooler> so after mapping the id morphism it goes from a -> a to Maybe a -> Maybe a
09:49:00 <Cooler> and fmap id = id
09:49:18 <yyyyy> :t fmap id
09:49:20 <lambdabot> Functor f => f b -> f b
09:49:40 <Cooler> so literally nothing should happen to id?
09:50:05 <ReinH> fmap id should be the same as id
09:50:37 <ReinH> You can prove this using the definition for fmap for Maybe and the definition of id
09:50:50 <Guest59860> Any known generalization for https://paste.debian.net/810600/?
09:52:42 <yyyyy> intuitively it says that f is unchanged by fmapping
09:53:12 <yyyyy> (id)
09:54:45 <mniip> perhaps it should be said
09:54:51 <mniip> fmap @F (id @X) = if @(F X)
09:55:43 <Cooler> yeah the laws make sense
10:00:24 <dinnu93> How do I do a regexpQuery in Bloodhound ?
10:01:18 <ertes> Cooler: if you have some experience in group theory you might recognise those laws
10:01:50 <ertes> Cooler: they are on-steroids versions of the monoid morphism laws
10:03:10 <ertes> Cooler: in fact a functor mapping a single-object category to a single-object category is exactly a monoid morphism
10:09:35 <Arguggi> I'm trying to use @=~ from the scalpel library but I can't seem to figure out how to create something that satisys the  (RegexLike re String) constraint, can anyone help? (function here: https://hackage.haskell.org/package/scalpel-0.3.1/docs/Text-HTML-Scalpel.html#v:-64--61--126- )
10:12:51 * hackagebot cpphs 1.20.2 - A liberalised re-implementation of cpp, the C pre-processor.  https://hackage.haskell.org/package/cpphs-1.20.2 (MalcolmWallace)
10:22:52 * dfeuer hopes Wren wasn't too busy at barbecues this weekend to get started on Data.IntMap.Merge....
10:23:12 * dfeuer didn't go to *any* barbecues, which seems a bit unfortunate.
10:23:13 <Cooler> why doesn't maybe instance functor, applicative and monad here hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#Maybe?
10:23:43 <dfeuer> Cooler, it does that somewhere else in the file, I think.
10:23:58 <dfeuer> Quite sure, actually.
10:24:01 <geekosaur> Arguggi, https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#v:makeRegex (or one of the other three)
10:24:16 <Cooler> where?
10:24:35 <dfeuer> There's not much point asking *why* code is placed on one line rather than another in a module. Different people like to organize code differently and some people don't like to organize code at all.
10:25:03 <dfeuer> Cooler, I dunno. Search for instance *Monad *Maybe, perhaps?
10:25:13 <ongy> Cooler: somewhere :) I would suggest looking at the haddock generated doc for something like that. For Maybe: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html
10:25:48 <dfeuer> Cooler, https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-665
10:26:27 <dfeuer> If you open up Haddocks for the Prelude (or Data.Maybe) you should be able to find the instance and click through to its source.
10:33:21 <Arguggi> geekosaur, I tried with makeRegex before but I'm still getting type errors: http://lpaste.net/184863
10:33:42 <geekosaur> siiigh
10:33:50 <geekosaur> Text.Regex is baroque
10:34:12 <geekosaur> it's a prime example of "just because you can do something, doesn't mean you should"
10:34:30 <monochrom> but that's avant garde
10:34:54 <geekosaur> arguably it is both :)
10:35:42 <Arguggi> (unfortunatly the library uses that kind of regex, if there is a better solution I'd love to switch, I don't like it either)
10:36:26 <ph88> hi guys
10:36:51 <ph88> does anyone know why doctest can not find this test?   https://paste.fedoraproject.org/421896/16816147/
10:37:57 <Cooler> if something is a instance of functor does that mean theres a inverse to get back the original types?
10:38:21 <geekosaur> not necessarily
10:38:22 <Cooler> like a way to get back a from Maybe a
10:38:30 <Cooler> in order to implement fmap
10:38:31 <geekosaur> IO is a functor but you can't get back a from IO a
10:38:49 <geekosaur> for Maybe, that would only be defined for Just _, not for Nothing
10:38:59 <geekosaur> (and you can't define it only for some values)
10:39:50 <PaulePanter> Hi. How do I build a GHC bindist?
10:39:51 <Cooler> in general the way you implement fmap given f :: a -> b and Functor F => F a
10:40:00 <dfeuer> You can get back the original *types*, but not necessarily the original *values.
10:40:15 <PaulePanter> ./platform.sh $PATH_TO_GHC_BINDIST_TARBALL
10:40:27 <Cooler> would be to inverse F a and get back a so you can feed it to f and then wrap f a in F f a right?
10:40:34 <dfeuer> type family Argument a where Argument (f x) = x
10:40:44 <PaulePanter> I build GHC 8.0.1, but no idea, what the binary(?) distribution is.
10:40:50 <monochrom> That is almost always the wrong way to implement fmap.
10:40:50 <geekosaur> PaulePanter, you don't build that, you download it.
10:40:51 <dfeuer> Cooler, no, that's not how it works.
10:41:12 <dfeuer> Except for the Identity functor.
10:41:23 <monochrom> Try to implement fmap for []. You will find that inverting is nonsense.
10:41:26 <dfeuer> But the identity functor is quite unusual.
10:41:56 <dfeuer> I think the identity functor is the *only* one you can implement that way.
10:42:15 <geekosaur> well, you could build it but it's not the default. generally you get one from https://www.haskell.org/ghc/download_ghc_8_0_1#binaries and point platform.sh to the file you downloaded
10:42:22 <dfeuer> (although if you broaden the description a bit, I guess any "decorated" identity will work.
10:42:55 * dfeuer kicks QuickCheck in frustration.
10:43:07 <Cooler> monochrom, ok so you are not really inverting, just getting back the original types
10:43:07 <geekosaur> if you really want to build your own, go back into the ghc source tree and `make binary-dist`
10:43:21 <dfeuer> QuickCheck is really useful, but its API leaves much to be desired.
10:43:21 <monochrom> No, that is still nonsense.
10:43:56 <Cooler> well with Maybe a you get back a
10:43:59 <monochrom> Implement fmap for [] yourself. Do not speculate. Practice. Get it to work.
10:44:06 <Cooler> and with [a] you get back a
10:44:11 <PaulePanter> geekosaur: Where from?
10:44:17 <geekosaur> ?
10:44:22 <monochrom> See what happens. Do not sit and think.
10:44:23 <PaulePanter> geekosaur: I’d like to build everything from source.
10:44:35 <Cooler> monochrom, fmap = map
10:44:35 <PaulePanter> geekosaur: What do I download that tarball from?
10:44:54 <monochrom> OK, and map "gets back the original type"? I don't think so.
10:45:01 <Cooler> yes
10:45:03 <Cooler> ?
10:45:10 <geekosaur> I guess I needed to exploicitly name you on the other lines...
10:45:15 <Cooler> map f [] = []
10:45:27 <geekosaur> PaulePanter, you could build it but it's not the default. generally you get one from https://www.haskell.org/ghc/download_ghc_8_0_1#binaries and point platform.sh to the file you downloaded
10:45:35 <geekosaur> PaulePanter, if you really want to build your own, go back into the ghc source tree and `make binary-dist`
10:45:41 <Cooler> map f (x:xs) = f x : map f xs
10:45:47 * geekosaur waits to be kicked for repeating... sigh
10:45:52 <monochrom> That looks like getting stuck in [a] and [b] types rather than "gets back to a".
10:45:59 <geekosaur> (spambot, sometimes hyperactive)
10:46:50 <Cooler> monochrom, you get back a from [a] by accessing the individual elements
10:46:53 <PaulePanter> geekosaur: Thank you.
10:46:57 <PaulePanter> geekosaur: https://gist.github.com/mzero/156554bb60cb3cb613f8
10:47:07 <PaulePanter> … now I understand it a little better.
10:47:08 <Cooler> x :: a
10:47:09 <monochrom> and yet "fmap f [] = []" has no individual elements
10:47:15 <PaulePanter> Let’s see if it’ll work.
10:47:36 <Cooler> monochrom, did you see the other case?
10:47:41 <monochrom> It is stuck with []::[a] and []::[b].
10:47:47 <monochrom> No. Did you see the base case?
10:48:15 <Cooler> map f (x:xs) = f x : map f xs
10:48:58 <Cooler> there x :: a
10:49:07 <dfeuer> monochrom, maybe Cooler's trying to get at the fact that fmap works with each value of type a? I dunno.
10:49:07 <monochrom> Sure.
10:49:48 <Cooler> in fact f only works with a so if you can't get back a then you have a type error when you try to use f
10:51:13 <monochrom> I think I am objecting to the "back" part.
10:51:24 <Cooler> what i am trying to get at is that when a Functor maps objects to object(Hask types to Hask types)
10:51:43 <Cooler> its a isomorphism
10:51:52 <dfeuer> Cooler, not necessarily.
10:51:55 <Cooler> you can get back the original type
10:52:19 <dfeuer> Cooler, consider the functor  data Boring a = Boring deriving Functor
10:52:38 <monochrom> If you just try to get a value of type "a", sure, you need it. But it is not "get back". It is not like there is always something to restore.
10:53:05 <monochrom> For example newtype S a = S (s -> (a, s))
10:53:05 <dfeuer> Or the functor   newtype Const a b = Const a deriving Functor
10:53:11 <alercah> it's still an isomorphism of types
10:53:25 <monochrom> there is no "original a to go back to". does not exist.
10:53:33 <dfeuer> alercah, neither Boring nor Const a is an isomorphism of any sort.
10:53:44 <Cooler> ok let me rephrase
10:54:10 <alercah> it's not a useful isomorphism though
10:54:12 <Cooler> if your implementation of fmap uses the function f that its supposed to map
10:54:13 <monochrom> "I need to get an a" yes. "I need to get back an a" no, there is no back, in fact sometimes there is only going forward.
10:54:19 <Cooler> then you need to be able to get back a
10:54:24 <Cooler> from F a
10:54:31 <alercah> Cooler: also not true
10:54:47 <alercah> Functor (-> r) violates that
10:55:00 <monochrom> ((->) r)
10:55:22 <Cooler> i don't even know what that is
10:55:27 <monochrom> I have said everything I need to say.
10:55:51 <alercah> err yes, monochrom is right
10:56:06 <Cooler> monochrom, yeah ok you need to get an a
10:56:10 <alercah> Cooler: ((->) r) a is r -> a
10:56:50 <alercah> instance Functor ((->) r) where fmap f g = f . g
10:57:21 <Cooler> so its not a isomorphism
10:58:18 <alercah> not even close
11:00:22 <dfeuer> Why do I get the message "    accepting non-standard pattern guards (use PatternGuards to suppress this message)"? Pattern guards are standard in Haskell 2010, and this is on GHC 8.
11:03:58 <tippenein> http://lpaste.net/184876 trying to fmap inside a Dynamic with this reflex code. Any suggestions what I'm doing poorly?
11:06:28 <cocreature> tippenein: your result type has to be Dynamic t () instead of m ()
11:07:25 <cocreature> but that doesn’t seem to have a Monad instance
11:07:34 <Gurkenglas> tippenein, fmap books is (Dynamic t Bookshelf -> Dynamic t Book). What do you want to do if there is no bookshelf?
11:08:27 <sm> ph88: I don't see a doctest there.. check docs ?
11:08:42 <Gurkenglas> If nothing, you could use fmap (maybe [] books) instead
11:09:41 <tippenein> cocreature: I think `display` does something like Dynamic t a -> m ()
11:10:04 <Gurkenglas> By the way, m is equal to Dynamic t here.
11:10:10 <tippenein> Gurkenglas: well, since I'm trying to map over the fmap result, I'd expect it to be [Book] not Book
11:10:28 <Gurkenglas> Oh right my mistake, it's Dynamic t Bookshelf -> Dynamic t [Book]
11:10:41 <Gurkenglas> You still need to figure out how to use a Dynamic t (Maybe Bookshelf) instead
11:10:45 <sm> ph88: hmm, doctest 0.9.2 or greater ? haddock 2.13.0 or greater ? (not sure if that's required, but worth a try)
11:12:37 <tippenein> I can return Nothing here, and mapM_ id Nothing works
11:13:52 * hackagebot diagrams-builder 0.7.2.4 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.7.2.4 (BrentYorgey)
11:13:54 * hackagebot directory-tree 0.12.1 - A simple directory-like tree datatype, with useful IO functions  https://hackage.haskell.org/package/directory-tree-0.12.1 (BrandonSimmons)
11:13:56 * hackagebot messagepack 0.5.2 - Serialize instance for Message Pack Object  https://hackage.haskell.org/package/messagepack-0.5.2 (rodrigosetti)
11:13:58 * hackagebot unagi-bloomfilter 0.1.1.0 - A fast, cache-efficient, concurrent bloom filter  https://hackage.haskell.org/package/unagi-bloomfilter-0.1.1.0 (BrandonSimmons)
11:13:59 <Schrostfutz> Hi, I have a syntactic problem in the following code. I try to write a function "splitWith" that splits a list according to a predicate. This is my attempt, however the compiler refuses to do its magic on it: http://sprunge.us/UgKA?hs
11:14:07 <lpaste> tippenein revised “fmapping inside Dynamic”: “fmapping inside Dynamic” at http://lpaste.net/184876
11:15:09 <Schrostfutz> http://sprunge.us/bKGb?hs <- "correct" version... 
11:18:00 <dfeuer> Schrostfutz, break doesn't return a Maybe.
11:18:38 <dfeuer> Schrostfutz, at least not if it's the standard break.
11:18:50 <Schrostfutz> dfeuer: but my safeTail does: http://sprunge.us/eMWK?hs
11:19:38 <Gurkenglas> But you aren't using it in the version for which you're asking us why it doesn't work
11:19:50 <dfeuer> Schrostfutz, what does safeTail have to do with anything?
11:20:40 <Schrostfutz> In the updated version I use it on line five, don't I?
11:21:20 <Berra> Is there some good goodline for multi-line signatures? 
11:21:26 <Berra> guideline*
11:21:47 <Gurkenglas> Schrostfutz, the updated version still doesn't work? What do you mean by "\"correct\""?
11:21:55 * ski often aligns `->'s (and with `=>')
11:22:37 <Schrostfutz> Gurkenglas: That I noticed the mistake of not using 'safeTail'. It refuses to compile because of an syntax error on 'Just'
11:23:40 <Gurkenglas> Lines 6 and 7 need to be inlined past the r in rest
11:25:49 <Gurkenglas> splitWith is groupBy . const though btw
11:25:57 <Berra> ski: Say you needed this sig to be shorter, how would you indent it? http://lpaste.net/184887
11:26:00 <Gurkenglas> No wait nvm safeTail.
11:28:13 <Gurkenglas> :t unfoldr (_2 ?safeTail . break ?f) -- lens dependency :P
11:28:15 <lambdabot> (?safeTail::[a] -> Maybe [a], ?f::a -> Bool) => [a] -> [[a]]
11:29:17 <Schrostfutz> Gurkenglas: I'm sorry, I can't follow. I should replace the rest by the expression in where?
11:30:28 <Gurkenglas> Schrostfutz, nvm my last 3 lines, but heed the 4th of mine above this: you could, for example, insert three extra spaces to the left of "Just something" and "Nothing"
11:31:39 <Gurkenglas> Though you could just write rest as "drop 1 tail"
11:32:31 <monochrom> Schrostfutz: in "safeTail tail", that "tail" is not what you think.
11:33:22 <monochrom> Here is a hint. Rename your two "tail"s to "monochrom". See what happens.
11:33:26 <Schrostfutz> monochrom: I just noticed... But Gurkenglas' solution works better anyway, I didn't know drop's behavior on empty lists.
11:34:54 <Gurkenglas> Schrostfutz, you'll run into a problem though: What happens once the list is empty?
11:35:04 <Gurkenglas> Wait nvm missed line 2
11:36:12 <Gurkenglas> safeTail is tailMay from the safe package btw
11:42:36 <pffffffft> is haskell really a pure functional programming language?
11:44:20 <monochrom> should we argue semantics for that question? :)
11:45:21 <tombert> dumb question; I want to write a service that converts a video from whatever to h264; the obvious choice for that is FFMpeg. What haskell FFMpeg library is more or less the standard one nowadays?
11:45:28 <tombert> and/or the best, and if so, why?
11:47:42 <tombert> is the standard way to just talk to libav or something, or are the ffmpeg bindings better?
11:51:07 <fizbin> It's awfully hard to track down a performance problem with compiling with profiling on makes the problem vanish.
11:51:24 <fizbin> .... "when" ....
11:52:53 <monochrom> yes, I don't trust profiling
11:56:09 <Squarism> Even if its apperently flawed / ambigious - i like the idea of BPMN. Easy pictures that can explain some simple code in seconds. I wonder if anyone know of a graphical notation that doesnt suffer from the incompleteness/ambiguity of BPMN. Preferably something that has a 1-1 transformation with some subset of haskell 
12:00:13 <fizbin> Seriously, my library's stress-test binary takes 46 seconds with --disable-profiling and when compiled with --enable-profiling and run with +RTS -p it runs in ~ 6 seconds. WTF.
12:01:43 <merijn> fizbin: That's...surprising
12:05:09 <srhb> fizbin: Multithreading?
12:07:06 <fizbin> srhb: I don't use multithreading explicitly, but I do compile with -threaded
12:07:09 <dmwit> tombert: `system "ffmpeg ..."`?
12:09:48 * hackagebot microspec 0.1.0.0 - Tiny QuickCheck test library with minimal dependencies  https://hackage.haskell.org/package/microspec-0.1.0.0 (TomMurphy)
12:11:37 <srhb> fizbin: Apparently I may have imagined an issue where profiling disabled threading altogether or confused it with an SMP issue, but either way, it was a long shot and I can't find the sources now.
12:13:50 <dcz> Hello 
12:13:57 <dcz> i am using wreq library and in ghci this works. let key = parse ^? responseBody . key "key" . _String
12:14:36 <dcz> However in Main.hs i get this error,  https://paste.kde.org/px3dbv2iw
12:15:16 <monochrom> maybe add a type signature. or maybe turn on NoMonomorphismRestriction
12:15:34 <monochrom> no, that won't help
12:15:47 <dcz> i am new at haskell , i dont know those things :D
12:15:54 <fizbin> srhb: Also, changing around whether -threaded is on or not, or whether I used -O or -O2, it doesn't seem to matter: profiling on is fast, profiling off is really slow.
12:16:16 <monochrom> the cause ought to be more elemetary, for example typo
12:16:20 <ReinH> dcz: what is parse?
12:16:28 <dcz> here is my code
12:16:36 <black0range> What kind of equality is Data.Eq ment to represent? 
12:16:51 <dcz> https://paste.kde.org/p1sujo93a
12:16:54 <hesk> What does the "n" mean in the expresssion (\_ n -> n+1) ? 
12:17:05 <hesk> Is it a second variable?
12:17:08 <ggVGc> black0range: what kinds of equality are there?
12:17:12 <ggVGc> in haskell equal means equal
12:17:16 <ggVGc> value equal that is
12:17:16 <monochrom> black0range: the Eq class. does that help?
12:17:17 <ggVGc> afaik
12:17:21 <ReinH> hesk: yes
12:17:33 <hesk> thanks
12:18:24 <dmwit> black0range: I usually program as if `x == y` implies that forall `f`, `f x == f y`.
12:20:19 <dmwit> I suppose I probably also assume `x /= y` implies that there exists `f` for which `f x /= f y`.
12:20:56 <dmwit> That law doesn't say much, though, since `f = id` probably fills the hole.
12:21:22 <dcz> okey i found the problem, let key = .... , the key word is the problem there
12:21:32 <black0range> dmwit: A pretty decent one anyways
12:21:50 <dcz> i think it is mixed with the actual library keyword thats why 
12:21:55 <dcz> my bad :D
12:22:29 <shachaf> dmwit: You should call it something like the coinjectivity of equality.
12:22:52 <monochrom> Leibniz
12:23:29 <Berra> Can a Bifunctor be a Setoid?
12:23:32 <the_2nd> what's a good solution for wrapping throwing functions so they'll return Maybe/Either on error?
12:23:48 <Gurkenglas> dmwit, you could replace the second one by the assumption that there is an f which has Bool as its codomain
12:24:42 <Gurkenglas> the_2nd, spoon for Maybe and unsafe, try for Either and IO
12:26:53 <hesk> How does the function "reverse = foldl (\xs x -> x:xs) []" work? From what i understand of foldl it begins by "[]:x" which doesn't work in prelude. 
12:26:56 <byorgey> the_2nd: there was http://hackage.haskell.org/package/spoon , hasn't been updated in a while but probably still works
12:27:07 <Gurkenglas> fizbin, you could try inserting traces - for examples, tracing in every line to the trash bin and seeing whether it becomes fast
12:27:13 <byorgey> oh, Gurkenglas already said that, I missed it
12:28:01 <monochrom> @type foldl (\xs x -> x:xs) []
12:28:03 <lambdabot> Foldable t => t a -> [a]
12:28:03 <byorgey> hesk: notice the order of the arguments to the lambda  (\xs x -> x:xs)
12:28:05 <roboguy`> hesk: the arguments are reversed from what you're thinking
12:28:12 <the_2nd> Gurkenglas, byorgey thanks guys
12:28:26 <dmwit> Gurkenglas: Doesn't help, then `(==y)` fills the hole trivially.
12:28:57 <dmwit> "You can distinguish these two terms if you can distinguish these two terms." Thanks
12:29:07 <fizbin> Gurkenglas: I'm not sure what that means (tracing in every line to the trash bin) or even what you mean by "inserting traces"
12:30:07 <Gurkenglas> Debug.Trace provides stuff to unsafely log messages for debugging, which is slightly safer than using unsafePerformIO yourself.
12:30:09 <ReinH> :t foldl
12:30:11 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:30:32 <Gurkenglas> To the trash bin just means that you might gain some information even if you ignore what is traced.
12:30:47 <ReinH> hesk: look at the order of the types
12:30:58 <hesk> :t foldr
12:31:00 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:31:03 <ReinH> you produce a `b`, and the first argument to the function is a `b`.
12:31:11 <monochrom> foldr and foldl are different.
12:31:21 <hesk> Trying to wrap my head around it
12:31:24 <monochrom> Focus on one and get it done first.
12:31:37 <monochrom> In fact best to consider them unrelated.
12:31:52 <Gurkenglas> dmwit, indeed, if there is an Eq instance; if whoever implemented == can provide a function that distinguishes x and y then they are not equal.
12:32:29 <the_2nd> does readFile throw or simply return "" ?
12:32:43 <dibblego> hesk: this might help, http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
12:32:43 <Gurkenglas> It throws
12:32:49 <dmwit> Gurkenglas: I'm not sure I'm on board with that. I could imagine implementing an abstract type which has terms that are distinguishable beneath the abstraction barrier but not above.
12:32:57 <fizbin> Gurkenglas: So... you're suggesting I trace various bits of the code, hoping to catch in there the forcing that fixes things?
12:33:07 <monochrom> if file not found at first, it throws. but if you get past that, you get "".
12:33:23 <monochrom> err, you get "" for other errors.
12:33:28 <Gurkenglas> Ah monochrom probably knows better than me.
12:33:55 <fizbin> I just don't understand why turning on profiling makes things faster - profiling shouldn't be forcing anything.
12:33:59 <hesk> dibblego: thanks! Quite long but I'll save it for later
12:34:34 <Gurkenglas> dmwit, if == is implemented above the abstraction barrier, then (==y) does not work
12:34:47 <Gurkenglas> *does not distinguish
12:34:54 <monochrom> dmwit: It is why when you said "for all f", the question could be raised "is it really for all f, or is it just for all f buildable from the exported API"
12:35:03 <dmwit> Gurkenglas: Yet it may not be implemented above the abstraction barrier.
12:35:24 <monochrom> And in fact Data.Ratio is the prime example of that consideration.
12:35:27 <dmwit> monochrom: Right. I am happy enough if it is true for all `f` buildable from the exported API.
12:35:41 <Gurkenglas> Then the Eq instance is unlawful by the law you call assumption x)
12:35:53 <monochrom> But I didn't raise it because usually we say "everyone knows we just mean the exported API"
12:37:08 <monochrom> This is fun fodder to add to any discussion on purity, referential transparency, etc.
12:37:25 <dmwit> Gurkenglas: Yes. My point being that the second law, the one about "exists `f`", isn't doing any interesting work.
12:37:37 <dmwit> Gurkenglas: All the interesting work is happening in the first law.
12:37:48 <monochrom> One day someone needs to write a biography for me. "monochrom: the man who knew equality"
12:38:30 <monochrom> Oh, maybe I should do that myself, and set up a cron job to publish it after I die.
12:41:41 <Gurkenglas> How does it know when you died? A day passing without you saying something about equality? :D
12:42:46 <dolio> Dead man's switch.
12:45:47 <EvanR> some forms of equality are more equal than others
12:51:14 <f-a> Map has an "ord" constraint so it's more efficient, but I found myself using it on tuples (x, y), is there maybe a better choice for that?
12:51:42 <f-a> (use: I'll frequently ask "get me values between (a,b) (c,d)")
12:52:53 <ReinH> A sorted list?
12:53:38 <f-a> ReinH: isn't a map very similar to a sorted list with unique elements?
12:53:45 <ReinH> No?
12:54:09 <tombert> dmwit: I'm not opposed to just doing things with a raw command line call, but I thought there might be a better, more idiomatic way of doing stuff
12:54:30 <minad> EvanR: john major equality? ^^
12:54:35 <f-a> I forgot how condescending you were, ReinH
12:55:05 <ReinH> ...
12:55:10 <cocreature> f-a: a set is similar to a sorted list with unique elements
12:55:13 <ReinH> You asked a yes or no question and I answered it.
12:55:33 <cocreature> f-a: a map is more like [(k,v)] sorted by k and uniqued on k
12:55:42 <f-a> woops, I meant to say an assoclist, cocreature 
12:56:24 <ReinH> Maps and sorted list have different asymptotics
12:56:43 <cocreature> ofc
12:57:21 <ReinH> What's important here is that a range query on a sorted list can be done with a single traversal in O(n)
12:58:02 <ReinH> Map doesn't expose an interface to the underlying tree to allow something similar.
12:58:34 <dolio> It might, actually.
12:58:47 <cocreature> I think the constructors are all exposed in internal modules now
12:59:00 <ReinH> Oh?
12:59:23 <cocreature> Data.Map.Base
12:59:59 <ReinH> In the very latest version, released a few days ago.
13:00:02 <ReinH> lol
13:00:27 <cocreature> yeah that’s why I remember it. it was in the release notes :)
13:00:40 <ReinH> Fair enough
13:01:27 <minad> new containers release?
13:01:40 <cocreature> yep
13:02:49 <minad> btw, is there a stupid rule at which size to use the unordered hash map instead of the sorted one
13:02:57 <minad> (if one doesn't care about the sorting)
13:03:15 <cocreature> minad: the rule is benchmark and chose the one that is faster :)
13:04:10 <minad> hehe, too lazy for that right now ;) You are right of course, but I just thought maybe someone has some experience
13:05:13 <ReinH> Yes, experience tells us to benchmark.
13:05:49 <cocreature> minad: I think there are too many factors to give general advice here. just to name two: the performance of your comparison and hashing functions
13:07:19 <minad> cocreature: Ok, lets take a simple case like a symbol table with short identifiers (Strings)...
13:08:09 <minad> but maybe I should just play with criterion, I guess this is what you recommend
13:08:23 <cocreature> minad: then you still have the question of what “short” means and other factors. I think if you care about the performance difference there is no way around benchmarking and if you don’t care then choose whatever you want
13:09:01 <minad> just to get some intuition, I cannot get a universal answer. and in the end I should benchmark
13:09:26 <shock_one> Hi. Having a type constructor Get as in the gist, is there a way to restrict it's parameter to valid HTTP codes? https://gist.github.com/shockone/14076bf2cbedce316a6ba696e913ad00 Besides using DatatypeContexts, which'd impose users to add the constraint to every place Get is used in.
13:09:41 <minad> cocreature: 10 characters, uniformly distributed. something like that
13:09:52 <shock_one> Actually, it's a simplified version of the type from servant.
13:09:58 <cocreature> minad: sorry I can’t tell you anything better than “benchmark” :)
13:10:48 * hackagebot edge 0.9.1.1 - Top view space combat arcade game  https://hackage.haskell.org/package/edge-0.9.1.1 (infrared)
13:10:50 * hackagebot text-markup 0.1 - A data structure for mapping metadata to text subsequences  https://hackage.haskell.org/package/text-markup-0.1 (JonathanDaugherty)
13:10:52 * hackagebot haste-compiler 0.5.5.0 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.5.0 (AntonEkblad)
13:11:25 <ReinH> shock_one: No, types cannot depend on values in this way in Haskell.
13:12:18 <pffffffft> how's I/O still pure? it's not pure?
13:13:26 <shock_one> ReinH: do you happen to know the formal name of the feature that's missing to do that? Or any googlable words that'd help me find something about it. I'd be interested to conduct some more research.
13:14:00 <minad> shock_one: dependent types? promoted data types?
13:14:26 <Ulrar> Is there an easy way to make a non-rest web app in Haskell ? I need to handle calls to ugly URLs like /?task=send (it's not actually a variable, it's more of a path)
13:15:34 <shock_one> minad: maybe something more specific to type parameter constraints? I mean, I can definitely define a function `foo (Proxy :: Proxy [200, 400])` which would accept only integers I want.
13:16:52 <glguy> pffffffft: Evaluation in Haskell doesn't have side-effects. Evaluating an IO action doesn't actually perform the IO
13:17:03 <ReinH_> ReinH: Sorry, I misread your gist and then irccloud died before I could tell you that I misread your gist
13:17:13 <ReinH_> er, shock_one 
13:17:22 <minad> shock_one: I have to take a look at your gist ;)
13:19:40 <ReinH_> pffffffft: Evaluation of IO actions is pure.
13:20:21 <pffffffft> what's evaluation of IO?
13:20:23 <ph88> sm, doctest 0.11.0 and haddock-2.17.2   i'm trying to run doctest by: stack exec doctest
13:20:43 <ReinH_> The same as evaluation of other expressions.
13:21:10 <ReinH_> Execution of main by the runtime is impure, but no one expects it to be pure.
13:21:21 <ReinH_> If it were pure, Haskell would actually be useless.
13:21:57 <ReinH_> Rather than just called "useless" in a joking way by SPJ.
13:22:13 <shock_one> Here's the proxy trick I was talking about, ReinH_, minad. It actually works as advertised. https://gist.github.com/shockone/dab2d00cc2a60f706596b7d15b7850cc
13:23:58 <minad> ah and you want to achieve the same with the type level nats?
13:24:06 <ReinH_> shock_one: yep, of course writing all the instances without template haskell will be a pain
13:25:11 <monochrom> ReinH_: would you like to argue semantics on the topic of "is Haskell pure? is Haskell IO pure?"? :)
13:25:17 <minad> shock_one: I mean for the data type. restrict the data type?
13:25:37 <shock_one> minad: not choosing any implementation strategy, I want to restrict the set of integers that can be applied to Get.
13:26:42 <monochrom> shock_one: interesting. neat.
13:26:59 <minad> shock_one: you already mentioned datatype contexts, right?
13:27:10 <monochrom> but now you have to make sure that I can just add my own HttpCode instances.
13:27:17 <monochrom> err, s/can/can't/
13:29:28 <ReinH_> monochrom: I should just find / write an answer to that question, since it is asked so frequently
13:30:04 <monochrom> We need "frequently unanswered questions" too :)
13:30:05 <ReinH_> monochrom: But yes, usually "what does pure mean?" is involved at some point.
13:30:48 <shock_one> minad: are you familiar with servant? That's the restriction I'd like to here here: https://github.com/haskell-servant/servant/blob/master/servant/src/Servant/API/Verbs.hs#L26 . Using datatype contexts is a breaking change (because of a new requirement to add the constraint to user code), and won't be accepted for sure.
13:32:19 <dmj`> shock_one: I'd use type level Elem
13:32:41 <shock_one> monochrom: Are you talking about the second gist (proxy.hs)? Isn't it a widespread technique? 
13:33:07 <monochrom> Yes. I don't know.
13:33:31 <dmj`> shock_one: specify the Nats that are allowed, then use a closed type family (Elem) to recurse through them and ensure that the Verb's Nat is in them
13:34:09 <shock_one> Thank you, dmj`. Those words hardly make sense to me now, but I'll dig into it.
13:34:11 <monochrom> I don't pay attention to type-level tricks (techniques?), so I don't know what is widely used, so every time I see one I am impressed (if I understand it; else I declare "obfuscation" :) ).
13:34:18 <dmj`> shock_one: but let's be honest, how often are you changing your response codes
13:35:04 <shock_one> It's still a shame to advertise yourself as a type-safe framework and allow to put not existing HTTP codes, isn't it, dmj`.
13:35:32 <minad> dmj`: sounds good. the type family acts as a type-level function then?
13:36:29 <shock_one> dmj`: maybe you could sketch some code for me? It'd be very helpful.
13:37:37 <dmj`> shock_one: It'd be trivial for the servant authors to add. One problem is that some http client might have the spec wrong (very, very common), and be expecting you need to provide. So you'd need type level concat (++) to allow for extensibility
13:37:49 <dmj`> expecting codes*
13:38:40 <shock_one> dmj`: is it possible to have this concat in Haskell?
13:38:47 <dmj`> shock_one: sure
13:39:02 <dmj`> shock_one: we have type-level cons
13:39:55 <shock_one> Wow, I was just watching your video the other say, dmj`.
13:40:12 <shock_one> *day.
13:41:17 <cocreature> shock_one: how about something like http://lpaste.net/184951
13:44:13 <shock_one> cocreature: I'm not sure what's happening, but I can declare `type A = Get 200` and it compiles.
13:44:31 <cocreature> hm right I just tested that myself
13:44:40 <cocreature> are type synonyms not type checked?
13:46:07 <cocreature> I’m confused
13:46:18 <monochrom> type synonyms are still checked.
13:46:37 <monochrom> you (or the computer) expands them and check normally.
13:47:43 <cocreature> so why does this typecheck?
13:49:03 <monochrom> Now I see what you mean. I don't know why.
13:49:25 <cocreature> even x :: Proxy API1; x = Proxy typehcecks
13:49:40 <cocreature> I’m clearly not understanding something about typefamilies
13:50:38 <minad> cocreature: it seems you have to create an instance
13:51:11 <minad> the type error is only triggered then when I try it
13:51:29 <minad> this means TypeError actually returns something like void
13:51:38 <cocreature> minad: create an instance for what?
13:51:42 <minad> which is a valid but uninhabited type
13:51:50 <minad> Get 1000
13:52:13 <cocreature> then I run into Illegal type synonym family application in instance: API1
13:52:38 <cocreature> which is probably a deal breaker anyway for shock_one but I still would like to know why it doesn’t break before that
13:52:57 <dmj`> shock_one, minad: here's a contrived example, http://lpaste.net/5946940515520872448
13:53:12 <dmj`> only codes present in the type-level list of Nats are allowed
13:53:27 <minad> cocreature: I tried that http://lpaste.net/184951
13:53:35 <dmj`> ~ is enforcing a constraint between True and the type computed by Elem
13:53:47 <dmj`> you can get fancy and add custom ErrorMessages
13:54:50 <cocreature> minad: hm yeah but that doesn’t help if you want a Proxy API1 to not typecheck
13:54:57 <minad> dmj`: but the type error is only triggered when you makeGet
13:55:22 <minad> if you write, undefined :: Get 1000 it not working
13:56:38 <minad> cocreature: yes, would be interesting to see how this can be done
13:56:46 <dmj`> minad: right, so hide the constructor (Get) in your list of exports and only expose the smart constructor
13:57:06 <dmj`> sure, undefined inhabits all types
13:57:15 <minad> yes
13:57:29 <minad> the point was if it was possible to construct a type which is no type ;)
13:57:34 <minad> which is not I guess ;)
13:59:42 <dmj`> minad: probably not, if you inspect servant all the type constraints are enforced in the Has-* instances
14:00:06 <elliptic00> hi, anyone know what is the different between :t  and :info in Prelude?
14:00:33 <elliptic00> I can use :info String, but I can't get anything from :t String
14:01:03 <cocreature> elliptic00: :t returns the type of an expression while :info looks up information about a single identifier
14:01:16 <cocreature> String is not a value so checking the type of it doesn’t make sense
14:01:17 <monochrom>  :t is :type. clearly, type != info
14:01:49 <monochrom>  :info is fairly general and tells you about types, data constructors, classes, anything that has a name.
14:01:49 <minad> dmj`: to rephrase - the question is, if it is possible to have a type constructor which fails when I try to make the type, not when I try to instantiate it
14:02:18 <monochrom> But it doesn't always tell you what :type would tell you (if applicable)
14:02:39 <monochrom>  :type wants an expression, not a name.
14:02:46 <dmj`> minad: I've never seem type variable constraints in defintions
14:04:41 <shock_one> Can I use smart constructors in type-level DSL, dmj`?
14:04:49 <minad> that's the question!
14:08:21 <ph88> does someone know a better way to write this?  https://paste.fedoraproject.org/422485/09669147/
14:09:50 <dmj`> shock_one, minad: I don't think so. But I'd like to be proved wrong
14:11:03 <ReinH_> ph88: I'm not sure what you're doing there, but one thing would be to qualify imports if you want to avoid namespace collisions
14:11:49 * hackagebot darcs 2.12.1 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.12.1 (GuillaumeHoffmann)
14:11:51 * hackagebot generic-records 0.1.0.0 - Magic record operations using generics  https://hackage.haskell.org/package/generic-records-0.1.0.0 (kcsongor)
14:12:10 <ReinH_> e.g., if `space` is imported from `Data.Foo`, then `import qualified Data.Foo as Foo` and use `Foo.space` instead.
14:12:42 <ReinH_> I don't understand what `c` is doing
14:13:26 <ReinH_> It seems nonsensical to me.
14:13:35 <elliptic00> import Data.Char (chr, ord)
14:13:57 <elliptic00> can anyone explain to me what does the above line mean?
14:14:21 <elliptic00> what is (chr, ord) here?
14:14:33 <ReinH_> elliptic00: it imports the identifiers `chr` and `ord` from the package `Data.Char`
14:14:40 <ReinH_> A list of identifiers
14:15:02 <ReinH_> @google haskell wiki import
14:15:02 <lambdabot> https://wiki.haskell.org/Import
14:15:12 <elliptic00> thx.. 
14:15:44 <ph88> ReinH_, good idea, what about the record though ?
14:15:58 <ReinH_> ph88: what about it?
14:17:03 <pi____> ?
14:17:13 <ReinH_> One way you can clean up the pretty definition is with record wildcards
14:17:40 <ReinH_> so you say pretty TextToken{..} = P.text (concat [text, space, comment])
14:19:01 <ReinH_> I don't know what you're trying to do with the comment, but I can guarantee that the let binding isn't doing it
14:19:19 <ReinH_> It doesn't even typecheck.
14:19:23 <ReinH_> :t let c = concat [fst . snd c, snd . snd c]
14:19:24 <lambdabot> <no location info>: error:
14:19:24 <lambdabot>     not an expression: ‘let c = concat [fst . snd c, snd . snd c]’
14:19:27 <ReinH_> :t let c = concat [fst . snd c, snd . snd c] in c
14:19:29 <lambdabot> error:
14:19:29 <lambdabot>     • Couldn't match expected type ‘(a5, a3 -> (a4, c1))’
14:19:29 <lambdabot>                   with actual type ‘[a0]’
14:20:16 <ReinH_> You should run your code through the compiler before you ask for help with it, because advice about nonsensical code is usually also nonsensical.
14:22:30 <dmj`> minad, shock_one: seems like data type contexts was your best bet, and it's removed now
14:22:51 <ReinH_> I mean, it was removed because it doesn't do anything...
14:22:56 <ReinH_> would it have actually done something here?
14:23:30 <monochrom> GADTs can help you enforce a context.
14:24:04 <dmj`> minad, shock_one: http://lpaste.net/4188485341516136448
14:24:15 <dmj`> monochrom: ooo! 
14:24:16 <minad> ReinH: I guess it would have
14:24:30 <minad> still doesn't type error?
14:25:35 <minad> dmj`: it is probably the same problem, you just create a void context which is not instantiated
14:25:47 <minad> and thus no error
14:25:49 <elliptic00> hi, I use Prelude to find definition of functions all the time, but sometimes I don't know the package name. How can I get the package name from a function name? 
14:26:09 <elliptic00> so that I can import in Prelude
14:26:25 <elliptic00> e.g. listArray
14:26:30 <dysfun> hayoo?
14:26:51 <dysfun> hoogle?
14:27:33 <elliptic00> yep, I know I can use hoogle, but is there any way I can get the info from Prelude?
14:28:03 * geekosaur is going to assume "Prelude" here means ghci
14:28:13 <geekosaur> in which case you want :i (:info)
14:28:32 <ReinH_> If the identifier isn't in scope, ghci won't be able to give you information about it
14:28:34 <buttons840> what is the best source for random number used to create random passwords?
14:28:47 <geekosaur> ("Prelude" is not the program name, it's the module loaded by default if you didn't specify one)
14:28:53 <ReinH_> if it is in scope, it's because you already imported it
14:28:55 <dmj`> ReinH, monochrom, minad: yea, seems like it http://lpaste.net/184976
14:29:20 <ReinH_> dmj`: huh
14:30:58 <ReinH_> So if the question is "how do I find the module from which I imported an identifier", the answer applies. If it's "how do I find the module from which I *can* import an identifier", it doesn't.
14:31:32 <ReinH_> the question seems to be the latter, but it's a bit unclear
14:31:54 <ReinH_> The answer to the latter would be hoogle or hayoo
14:32:08 <geekosaur> and if it's the latter, you can't do it from ghci. you can map module names to packages with ghc-pkg, but you can't look up functions that way
14:32:19 <geekosaur> I generally use hayoo since it indexes all of hackage
14:32:32 <ReinH_> I generally use stackage's hoogle, since I also generally use stackage.
14:32:46 <cocreature> http://hoogle.haskell.org/ also indexes all of stackage
14:33:55 <dysfun> yeah, but stackage is always the right version
14:34:53 <buttons840> stackage's formatting of the docs in ugly IMO
14:35:01 <buttons840> well, not ugly
14:35:12 <elliptic00> hi, I import many packages from my ghci.config file, and it causes the long package name on my console e.g. System.IO System.Environment Text.Regex.Posix Text.Regex Data.List.Split Text Data.Array.IArray>
14:35:20 <dysfun> i'm not mad keen on it either, but it doesn't change the information
14:35:41 <elliptic00> How your guys resolve the long packages name in console?
14:36:47 <cocreature> elliptic00: I have :set prompt "❯ " in "~/.ghci"
14:37:09 <monochrom> Firstly they are modules not packages.
14:37:36 <monochrom> Secondly I :load a file that imports all those modules, so my prompt is just "*Main> "
14:38:00 <dmj`> minad: think this is only possible with dep. types. What we're trying to say is, "Compute a type after we have a value". 
14:38:31 <monochrom> A file is also much more editable and persistent than hand-typing "import X" "import Y", "import YYZ" every day.
14:39:10 <dmj`> minad: idris can probably do this
14:39:11 <dysfun> actually since haskell-mode got so good, i rarely even use ghci directly any more
14:39:24 <minad> dmj`: the problem is that it doesn't seem to be possible to define a function on the kind level
14:39:28 <athan> is there a semigroup for Fractional a => Average a?
14:39:43 <monochrom> yeah, me too, so in reality my prompt is haskell-mode's default which is a Greek letter.
14:39:44 <minad> in idris, yes it should work
14:39:58 <athan> also, what's the property called s.t. `forall a. a <> a = a`?
14:40:19 * athan wishes there was a detexify for algebraic properties :x
14:40:34 <monochrom> But I still totally don't enter "import TTY" at the prompt. Unless it's a rare one-off thing that I throw away in a minute.
14:40:59 <monochrom> By the time you import the 4th thing you should seriously write a file and :load it.
14:41:07 <dysfun> yeah, i'm very unlikely to import at the terminal these days
14:41:43 <monochrom> Writing your code in the REPL doesn't scale. A REPL is not an editor.
14:42:09 <dysfun> but writing your data to /dev/null does scale
14:44:02 <monochrom> heh
14:45:58 <ReinH_> athan: an average is the product of a sum and a count.
14:46:06 <ReinH_> doing it this way also avoids massive floating point error.
14:47:02 <ReinH_> athan: and the property is idempotency
14:47:16 <ReinH_> @hackage idempotent
14:47:16 <lambdabot> http://hackage.haskell.org/package/idempotent
14:48:12 <athan> ahh thanks ReinH_\
14:49:14 <athan> I thought idempotency was a property of unary operators :s
14:49:21 <athan> i.e. `f (f x) == f x`
14:49:30 <ReinH_> apparently idempotent can be pronounced /ēdemˌpōt(ə)nt/
14:50:17 <ReinH_> athan: https://en.wikipedia.org/wiki/Idempotent_(ring_theory)
14:50:29 <dmj`> athan: o/
14:53:09 <athan> suuuup dmj` :)
14:53:24 <lpaste> sm pasted “dbglog with file lock issue” at http://lpaste.net/184988
14:53:37 <athan> thanks again ReinH_!
14:54:08 <sm> what would be a decent way to make that ^ work without file lock errors ?
14:55:03 <ReinH_> athan: yw
14:55:32 <dmj`> sm: you could isolate the writes by using a Chan
14:55:59 <Gurkenglas> sm, define a single global handle with unsafePerformIO and use that for each tracing call?
14:56:54 <sm> dmj`: does that mean writing in a separate thread ?
14:56:55 <Gurkenglas> Hmm that doesn't gurantee the handle's only opened once
14:57:02 <sm> Gurkenglas: right
14:57:25 <Gurkenglas> sm, open a handle in main, put it into an ioref, globally define access to that ioref, only use that to read
14:57:32 <Gurkenglas> Or be sane and just pass the handle
14:58:17 <dmj`> sm: yea, you'd pass the chan around. Alternatively, use a logging library
14:59:26 <Gurkenglas> Although it doesn't gurantee that the handle is only opened once in the same way Debug.Trace doesn't trace twice, so that's already as good as you're gonna get right
15:01:14 <Gurkenglas> You'll have to be careful though that the global definition doesn't get inlined, like https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Debug.Trace.html#trace does
15:01:25 <Gurkenglas> -does+is
15:02:10 <sm> I didn't know appendFile locked the file, I always though of append as free of this concern
15:03:27 <Gurkenglas> sm, why not just use Debug.Trace though?
15:04:03 <sm> Gurkenglas: does it have a file logging function ? I need one because this is a vty app
15:04:42 * sm thinks not
15:05:18 <sm> dmj`, Gurkenglas: thanks!
15:05:36 <Gurkenglas> Dunno what vty is but you can either pipe stderr into a file from the command line or use System.IO stuff to replace stderr with a file
15:06:53 <sm> vty is curses. And that's another good idea, stderr is probably still working
15:07:04 <sm> and I can redirect it as you say
15:07:13 <Gurkenglas> Dunno what curses is :P
15:08:38 <sm> full-window terminal app
15:09:05 <sm> and before you say it.. here's a picture :) http://hledger.org/images/hledger-ui/hledger-ui-bcexample-acc.png :)
15:10:17 <geekosaur> I doubt there is a guarantee of atomic log writes with unsafePerformIO though
15:10:51 <sm> indeed, maybe I shouldn't even try
15:11:45 <Squarism> if would like to write expressions like : a > b ... but really capture what "references" are used in the expression like : (int "a") > (int "b") . Anyone got an idea on how to accomplish that? 
15:12:01 <sm> for now, I just logged a little less & kept it happy. It came in pretty handy.
15:12:12 <Squarism> so somehow record a reference + return the value
15:12:49 <Squarism> ...and i know it might require some monad trickery + do to accomplish!?
15:12:50 * hackagebot react-flux 1.2.3 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-1.2.3 (JohnLenz)
15:12:52 * hackagebot deriving-compat 0.3.2 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.3.2 (ryanglscott)
15:13:11 <EvanR> stupid monad tricks
15:13:38 <Squarism> well i dont know, thats why im asking 
15:14:25 <Squarism> i want to be able to deterime what "references depend on what"
15:14:33 <ReinH_> What do you mean by "references"?
15:14:48 <Squarism> string labled variables
15:15:04 <Squarism> whose value would be in some map eventually
15:15:08 <Squarism> values
15:15:36 <ReinH_> (>) <$> int "a" <*> int "b"
15:15:44 <geekosaur> monads can't help you with that. you want an AST, but the AST only exists inside the compiler. your code might be able to poke at it using TH (note that this means all such expressions must be available at compile time in that module). unless you are actually saying you want to *write* a compiler, or at least the part of one that goes from source to AST
15:15:49 <ReinH_> for some suitable int which looks up identifiers in an environment
15:16:15 <Squarism> geekosaur, they will be available at runtime
15:16:31 <ReinH_> Assuming you don't mean looking Haskell identifiers up
15:16:45 <Squarism> geekosaur, ehh.. at compile time i mean
15:16:52 <ReinH_> ...
15:16:57 <ReinH_> Then I really don't know what you're asking
15:17:05 <ReinH_> runtime would have made sense
15:18:10 <ReinH_> I thought you meant something like
15:18:12 <ReinH_> > (>) <$> lookup "a" <*> lookup "b" $ [("a", 1), ("b", 2)]
15:18:12 <geekosaur> compile time makes sense iff it means reifying an expression in TH and examining the resulting AST. but I suspect the constraints needed for that to work will be tighter than they want...
15:18:14 <lambdabot>  False
15:18:31 <ReinH_> looking up identifiers in an environment
15:21:02 <Squarism> ReinH, i want to let users of this DSL like thing write conceise / easy readable expressions - but in order to detect circular references i need to check these manually
15:21:41 <ReinH_> Is this an embedded DSL?
15:21:59 <Squarism> ReinH, yeah
15:22:13 <ReinH_> I don't see how you can do that then.
15:22:18 <Squarism> geekosaur, where can you read about this AST? google didnt give me an obvious "I feel lucky"
15:22:40 <Squarism> Language.C.Syntax.AST ?
15:22:45 <Squarism> sounds low level
15:23:00 <geekosaur> that's for C, not for Haskell
15:23:01 <ReinH_> That's an AST for the C language.
15:23:53 <geekosaur> you want the documentation for Template Haskell, and possibly https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/KeyDataTypes
15:24:46 <dysfun> i don't know that recommending TH to someone who says "sounds low level" is where you want to go
15:24:55 <geekosaur> the haskell-src-exts package also provides a generic Haskell AST with some ghc extensions, but it's intended for runtime. (I think there is some TH integration but it's more or less a duplication of the package using TH's AST instead of its own?)
15:25:14 <geekosaur> true, but low level is the only way to do this
15:25:54 <eAio> I installed ghc-heap-view using Cabal and now I need to "load the included ghci script". How do I do that?
15:25:58 <dysfun> i suppose nobody believes you when you say TH is crack and just don't try and do the thing you wanted to do until they've tried for themselves
15:26:01 <geekosaur> (I have a suspicion they're imagining python or perl)
15:26:26 <monochrom> If you design a DSL, and implement your own interpreter, then you can design the whole thing to let you detect circularity. But only circularity in someone's use of your DSL, not circularity in Haskell.
15:26:31 <geekosaur> (that is, interpreted from an AST which is available at runtime and can be inspected then)
15:27:07 <geekosaur> if you're trying to do this in an EDSL, the only way to do it is to poke at compiler internals, which is pretty much by definition low level
15:27:09 <ReinH_> I feel like instead of wanting to do this, they should not want to do this.
15:27:11 <monochrom> In other words, only the meta-level can detect circularity in the target level. And even then it requires intelligent design.
15:27:15 <geekosaur> very likely, yes
15:27:38 <ReinH_> monochrom: intelligent design is a myth
15:27:58 <hpc> haha
15:28:17 <geekosaur> which is why my parenthetical above; you can do this kind of thing in perl or python, you can't really do it in a compiled-to-native-code (fsvo native; don't try it in Java either) language
15:29:09 <monochrom> this is a good time to mention https://ro-che.info/ccc/9
15:33:29 <geekosaur> eAio, it's usually easiest to create a ~/.ghci (on windows that's something like %APPDATA%/ghci.ini)
15:33:34 <Squarism> ok.. well you've made it clear im on a bad route then
15:34:02 <geekosaur> and add the script's contents to that, along with any other ghci configuration you might have
15:35:33 <eAio> geekosaur, I don't know what contents I need to add
15:36:24 <eAio> Is it something like "import ghc-heap-view"?
15:36:24 <geekosaur> it should have told you a filename
15:36:28 <geekosaur> I see http://hackage.haskell.org/package/ghc-heap-view-0.5.7/src/ghci
15:37:34 <eAio> During the install?
15:38:50 <Welkin> reboot during install
15:38:55 <Welkin> it clones the pokemon you are tading
15:38:57 <Welkin> trading
15:39:04 <Welkin> but the other one is lost to the aether
15:40:18 * geekosaur is looking at the part of Setup.hs which outputs the instructions to set it up, and is wondering what part of that did not get output or was not understood
15:41:13 * geekosaur is also too tired to handhold without descending into sarcasm, so someone else should probably step in :(
15:41:45 <monochrom> This is best done as a paid job.
15:45:07 <eAio> I think I installed ghc-heap-view while trying to install ghc-vis, and then when I --reinstall'd it it didn't output any messages.
16:02:41 <kurt11> I have a stack+cabal project with a single unit test. haskell-mode in emacs doesn't seem to recognize that my test source file is part of the test-suite and doesn't recognize the `import Test.HUnit`. How do I fix?
16:04:02 <ReinH_> What's the error message?
16:21:22 <athan> Is there a concept of `unionWith`, where null values are recognized? Something like `unionWith' :: (Maybe a -> Maybe a -> Maybe a) -> Set a -> Set a`?
16:21:32 <athan> I know it breaks a lot of indexing properties, but... idk
16:24:25 <athan> er, derp
16:24:39 <athan> `unionWith' :: (Maybe a -> Maybe a -> Maybe a) -> Map k a -> Map k a`?
16:24:40 <athan> it
16:24:45 <athan> it's only useful for indexed sets
16:30:43 <roboguy`> athan: null values?
16:31:47 <TheCoffee> Hi, I'm new at programming, Haskell is a good language to start with?
16:32:54 <ggVGc> maybe
16:32:54 <mpickering> how come you decided Haskell? But sure, there's no reason why not.
16:32:55 <ggVGc> I think so
16:33:00 <ggVGc> not everyone agrees it is
16:33:20 <ggVGc> TheCoffee: do you have any previous programming experience at all?
16:33:35 <Welkin> being the best programming language isn't saying much
16:33:36 <TheCoffee> nope
16:33:40 <Welkin> programming is a pain in the ass much of the time
16:33:42 <ggVGc> TheCoffee: I think maybe trying out Elm first is better
16:33:49 <ggVGc> it's a good start for later going to haskell
16:33:51 <Welkin> Elm is very simple
16:33:53 <ggVGc> and easier to get started with
16:33:55 <Welkin> I like it
16:33:55 <Gurkenglas> athan, what's the first argument?
16:34:11 <Gurkenglas> Concretely, that is. Because maybe there's another way
16:34:20 <ggVGc> Welkin: yes, but also it has a much more beginner-friendly community and more resources for novice programmers
16:34:23 <TheCoffee> Elm?
16:34:27 <Welkin> but it's only for browser apps
16:34:30 <mpickering> I think there are much better resources for getting started with Haskell though, there are many books
16:34:31 <Welkin> it is not general purpose
16:34:33 <ggVGc> TheCoffee: it's a variant of haskell that compiles to javascript
16:34:42 <Welkin> Elm is not a variabt of haskell
16:34:45 <ggVGc> Welkin: but very good for learning programming basics I think
16:34:48 <Welkin> it is a different language
16:34:58 <ggVGc> Welkin: not from the perspective of a complete beginner
16:35:03 <Welkin> the compiler is written in haskell thoguh
16:35:05 <Welkin> though*
16:35:11 <ggVGc> all this doesn't matter for a beginner
16:35:24 <Welkin> it is not lazy
16:35:33 <Welkin> it has no kinds
16:35:34 <Gurkenglas> athan, shouldn't it be (Maybe a -> Maybe b -> Maybe c) -> Map k a -> Map k b -> Map k c though?
16:35:48 <Welkin> it has no typeclasses
16:35:59 <ggVGc> TheCoffee: you can try Elm in the browser, and it has less advanced features than haskell making it easier to not get confused when starting out(haskell can easily sidetrack you with advanced things you actually don't need at first)
16:36:10 <ggVGc> Welkin: how is this relevant for a person who has never programmer?
16:36:12 <ggVGc> programmed*
16:36:19 <TheCoffee> lol, K
16:36:20 <Welkin> because it's not haskell
16:36:35 <monochrom> It is relevant for a person who will write a lot of programs.
16:36:57 <ggVGc> don't you think someone who starts learning elm and then looks at haskell after some experience will learn all these things
16:37:00 <ggVGc> and understand the differences
16:37:01 <Gurkenglas> athan, also this sounds kinda bad because the first argument presumable shouldn't be called with two Nothings. Perhaps Map k a -> Map k b -> Map k (These a b)?
16:37:03 <ggVGc> when it's needed
16:37:25 <monochrom> Everyone was once upon a time a person who has never programmed.
16:37:29 <Welkin> maybe
16:37:42 <monochrom> Every car was once upon a time a new car.
16:37:54 <monochrom> The future matters. The past doesn't.
16:38:00 <ggVGc> TheCoffee: anyway, I think haskell is an okay start, but I think Elm is a much better introduction to programming, and it's a good language heavily inspired by haskell. So if you learn it and then want to go into haskell, you'll have a fairly easy time. The community around Elm is also actively focused on being beginner friendly
16:38:01 <Welkin> every atom was once a star
16:38:17 <Welkin> the problem with elm is the lack of learning materials
16:38:22 <Welkin> it is not set up for new programmers
16:38:25 <ReinH_> If Elm is a variant of Haskell then JavaScript is a variant of Java.
16:38:37 <Welkin> it is made for javascript programmers who want to use a functional language
16:38:41 <monochrom> Both are variants of J.
16:38:55 <ggVGc> well, the problem with approaching haskell learning materials as a beginner is that you within a minute end up in monads, and within an hour probably have references to research papers in front of you
16:38:58 <Welkin> haskell has better learning materials
16:39:00 <monochrom> On your next CV, write: "I know J/Java/Javascript" for maximum profit :)
16:39:08 <shachaf> @quote c/c++
16:39:08 <lambdabot> Plugin `quote' failed with: user error (parseRegex for Text.Regex.TDFA.String failed:"c/c++" (line 1, column 5):
16:39:08 <lambdabot> unexpected '+'
16:39:08 <lambdabot> expecting empty () or anchor ^ or $, an atom, "|" or end of input)
16:39:13 <shachaf> Hmm.
16:39:17 <shachaf> @quote c/c\+\+
16:39:17 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
16:39:17 <TheCoffee> there's some site or kind of it to start with this.. Elm?
16:39:25 <ReinH_> I don't think we should start by confusing beginners and then hope that they eventually figure out that we misled them 
16:39:31 <ggVGc> the fact Elm doesn't have type classes I think is very very good when learning basics of programming
16:39:32 <shachaf> @quote c/c\+\+
16:39:32 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
16:39:51 <athan> Is there a way to do `foldWith :: (a -> a -> a) -> a -> f a -> a`?
16:40:00 <athan> Just so I don't need to rely on a monoid instance :s
16:40:02 <ggVGc> ReinH_: the question wasn't about how to learn haskell. It was "I want to learn programming, is haskell a good start". I think Elm is a better start on the path of programming than haskell is
16:40:11 <ggVGc> but that's only my recommendation
16:40:13 * athan maybe should make a monoid and newtype instead...
16:40:16 <ReinH_> ggVGc: That is not what I am responding to, as I think you know.
16:40:28 <Gurkenglas> :t foldr -- athan
16:40:30 <ReinH_> I am responding to your assertion that Elm is a variant of Haskell
16:40:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:40:34 <ggVGc> sorry
16:40:38 <ReinH_> They share some superficial similarities.
16:40:44 <Welkin> start with haskell, even if elm is simpler, because elm does not have the proper learning materials for a beginner and haskell does
16:40:45 <ReinH_> But so do Java and JavaScript.
16:40:52 <monochrom> but kmc goofed. it is better to have a nice prefix chain such as J/Java/Javascript
16:41:01 <TheCoffee> Now i am confused: S
16:41:05 <ReinH_> monochrom: C/C+/C++
16:41:06 <Welkin> TheCoffee: lol
16:41:06 <TheCoffee> ** :S
16:41:16 <Welkin> @where learnhaskell -- TheCoffee 
16:41:16 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:41:23 <shachaf> C/C+/C+run
16:41:52 <monochrom> pugs is written in haskell, too.
16:43:06 <ReinH_> Ok, good work everyone
16:43:29 <ReinH_> Really nailed that introduction to Haskell
16:43:30 <monochrom> sorry
16:44:28 <Welkin> you haven't seen a proper introduction until you've seen the one in #lua
16:44:31 <ReinH_> if they're a beginner and they went to the trouble to seek out Haskell and #haskell, I think the least we should do is attempt to teach them *Haskell*.
16:44:42 <ReinH_> Rather than pawn them off on some other vaguely similar language.
16:44:49 <Welkin> typically, it goes like this "lua sucks, it's a shit language. You can't even tell the difference between ~= and ==."
16:44:53 <athan> Gurkenglas: You just blew my mind somehow
16:44:55 <athan> thank you :D
16:45:07 <shachaf> Who? What?
16:45:29 <ydl> in "Control.Foldl", "fold" is implemented in terms of "Foldable.foldr" (I assume so that it can work on infinite sequences?) (function here: https://github.com/Gabriel439/Haskell-Foldl-Library/blob/master/src/Control/Foldl.hs#L432 ). I am trying to understand how this behaves with lazy evaluation and fusion. In the absence of fusion, will the "F.foldr cons done as" term fold over the whole list and allocate a giant function (i suspect
16:45:29 <ydl> it does since there is no way to just yield the "first element")?
16:46:33 <Welkin> ydl: foldr can short-circuit because lazy evaluation
16:46:41 <ReinH_> :t foldr
16:46:42 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:46:49 <ReinH_> ydl: for starters, count the number of arguments to foldr there
16:47:01 <ReinH_> does this surprise you?
16:47:55 <ydl> ReinH_: i understand how the function produces output (as in, I understand that it is correct). i am trying to understand under what circumstances it be efficient (allocate little intermediate memory)
16:48:18 <ReinH_> ydl: So you understand that the result of foldr is a function that is applied to begin.
16:48:29 <ReinH_> of `foldr cons done as`, rather
16:48:30 <ydl> ReinH_: yes
16:49:19 <Gurkenglas> ydl, it won't allocate the giant function: The $! part makes it so step x a is evaluated before k is applied to it
16:49:23 <ydl> ReinH_: but in order to construct this function the list (or in general foldable) has to be processed. I am wondering when this processing can happen inline so that the outer fold gets compiled to a loop
16:50:12 <ydl> Gurkenglas: but if we expand the foldr (say for a lazy list input) we get
16:50:55 <ReinH_> ydl: Does it surprise you to know that foldl' is already defined in terms of foldr in base?
16:50:55 <ydl> cons a0 (cons a1 ...)
16:51:31 <ReinH_> GHC 7.10 introduced optimizations which allowed foldr/build fusion to operate on this definition of foldl'
16:51:58 <ReinH_> So since 7.10, this sort of thing is indeed optimized
16:52:08 <ReinH_> Here is some info on that optimization http://www.joachim-breitner.de/publications/CallArity-TFP.pdf
16:52:16 <ReinH_> Hopefully it answers your question :)
16:52:32 <ydl> thank you very much! but am i right to think that without fusion this would be a poor strategy?
16:52:38 <ReinH_> Yes.
16:52:42 <Gurkenglas> ydl, before the runtime sees the (cons a1 ...) part, it replaces the cons a1 k x with k $! step x a1 and evaluates the step x a1
16:52:49 <ReinH_> And before 7.10 it was a bad strategy *with* fusion, since it didn't fuse.
16:53:27 <ReinH_> This optimization enabled a performant definition of foldl' in terms of foldr
16:53:48 <Gurkenglas> "replaces the const a0 k x with k $! step x a0 and evaluates the step x a0", dammit
16:54:00 <Gurkenglas> -t :(
16:54:33 <ReinH_> Gurkenglas: yes, but that isn't sufficient without fusion
16:54:48 <ReinH_> because deforestation is necessary to get the optimization you want
16:54:53 <ydl> Gurkenglas: ideally, but if you look at the source, it could be rewritten (F.foldr cons done as) begin
16:55:40 <ydl> ReinH_: this is very detailed, but do you know if such optimizations are applied at the repl (ghci?)?
16:56:05 <Welkin> probably not
16:57:21 <ReinH_> ydl: nope
16:57:25 <ReinH_> they require compilation
17:01:38 <ydl> is there any effort or interest to add JIT to haskell then? it seems like lots of idiomatic code relies heavily on compiler optimizations. alternatively, i guess then it still sometimes make sense to have the direct definition of foldl' to protect from failed optimization.
17:01:45 <Gurkenglas> Oh, I see, you mean the sort of optimization where in the end you don't even have a list to fold over.
17:03:24 <ydl> Gurkenglas: exactly
17:08:11 <ReinH_> ydl: Most JIT optimizations target dynamic language features
17:08:27 <ReinH_> as such, it has lower utility for a language like Haskell
17:10:43 <solrize> java?
17:11:00 <dcz> hello
17:11:01 <Welkin> solrize: bad dog
17:11:13 <dcz> i did something which is this , https://github.com/dyrnade/logstopaste/blob/master/src/Main.hs
17:11:25 <ReinH_> solrize: JIT works pretty well on Java.
17:11:30 <dcz> however file content over hastebin looks like this , http://hastebin.com/dobemiwibo
17:11:43 <dcz> new lines and spaces looks awful , why is that ?
17:12:21 <ydl> ReinH_: maybe i was unclear, i actually found an option for GHC that seems like it should compile code entered at the repl, -fobject-code . does this mean that these folds will be optimized? is there a way to pass -On options if they are necessary? actually at what optimization level will this fusion be triggered?
17:12:35 <Welkin> dcz: it is urlencoded
17:13:08 <dcz> means ?
17:13:12 <geekosaur> dcz, that looks to me like a GET string submitted as a POST string
17:13:29 <geekosaur> (urlencoded being an aspect of that)
17:13:35 <ReinH_> ydl: you *can* load compiled code into ghci with that option, yes http://stackoverflow.com/questions/27881725/how-can-i-load-optimized-code-in-ghci
17:14:08 <dcz> the file content is this one , https://github.com/dyrnade/logstopaste/blob/master/README.md
17:14:10 <Welkin> I thoght all data sent over http is urlencoded into base64
17:14:11 <geekosaur> in fact that looks like the body of a POST that was incorrectly encoded as for a GET
17:14:27 <geekosaur> POST body uses different encoding, urlencoding is only for URLs
17:14:55 <dcz> what i need to change , i didnt understand 
17:16:05 <ReinH_> (:=) creates an application/x-www-form-urlencoded POST body
17:16:13 <ReinH_> I don't know what hastebin accepts, but apparently not that
17:16:49 <ReinH_> I would guess that it accepts the source as the POST body without encoding, given its treatment of the url encoded version.
17:17:00 <geekosaur> does look that way
17:17:08 <dcz> ("Content-Type","text/html"),("Content-Encoding","gzip")
17:17:27 * geekosaur does not know this from the API end, sadly (I'm a sysadmin, I know what the network side looks like, rather less so the API side...)
17:17:30 <ReinH_> so try post "http://hastebin.com/documents" contents
17:17:56 <ReinH_> dcz: That doesn't answer my question.
17:18:28 <Welkin> send the string as json
17:18:36 <Welkin> dunno if it accepts that
17:18:43 <Welkin> or plaintext
17:18:46 <ReinH_> Maybe read http://hastebin.com/about and see what it expects
17:19:14 <ReinH_> It looks like it just wants a plaintext POST body
17:19:34 <geekosaur> it doesn't say what it expects, aside from that it expects you to use their ruby gem
17:19:46 <geekosaur> would have to inspect that to see what it's doing
17:19:53 <Welkin> lol
17:20:10 <ReinH_> geekosaur: Well, it does link to the source of the client
17:20:23 <ReinH_> So in some not very useful sense, it does say what it expects
17:20:24 <Welkin> maybe don't use hastebin?
17:20:38 <dcz> ReinH : http://hastebin.com/sifopavola.vbs for "http://hastebin.com/documents" contents
17:21:08 <dcz> there is python version here but no clue about encoding, https://gist.github.com/meunierd/1668147
17:21:30 <ReinH_> dcz: so is that correct then?
17:21:43 <ReinH_> Oh, you are getting an error
17:21:46 <dcz> no gives me error
17:21:48 <ReinH_> you didn't create that hastebin via your program
17:21:53 <ReinH_> You can perhaps understand my confusion
17:22:03 <dcz> yeap 
17:22:36 <ReinH_> Well, I don't know what instances Postable has
17:22:38 <ReinH_> but apparently not String
17:22:44 <geekosaur> the vb client just does uploadString
17:22:49 <geekosaur> not x-www-form-urlencoded 
17:22:57 <geekosaur> so it is indeed raw
17:23:29 <Squarism> dcz, i think the problem can be that the file you sent is utf8 and the webserver, will after urldecode it, assume its ascii
17:23:45 <ReinH_> You can try converting it to a ByteString, which has instances.
17:23:50 <ReinH_> for both strict and lazy
17:24:01 <geekosaur> no, it's treating the x-www-form-urlencoded stuff as part of the content
17:24:14 <geekosaur> it wants the raw string, not a urlencoded form with fields
17:24:23 <Welkin> so hastebin has a crappy api
17:24:27 <dcz> :D
17:24:31 <Squarism> generally, its really bad sending non ascii stuff text in url, use body for that (the relies on Content-Encoding header)
17:24:32 <ReinH_> It has a crappily specified API
17:24:36 <geekosaur> well, it's clearly supposed to be a minimal API
17:24:40 <ReinH_> perhaps because it doesn't intend anyone to use the API
17:24:48 <geekosaur> unfortunately the API documentation is likewise minimal
17:25:00 <ReinH_> Well, I see no indication that they intend for people to use the API
17:25:04 <ReinH_> aside from via their official client
17:25:10 <geekosaur> that,  yes
17:25:26 <ReinH_> So not documenting something that isn't supposed to be used is not a problem
17:25:38 <geekosaur> no real thought for it, they provide a ruby gem client and everyone else can just read and reverse engineer that :/
17:25:44 <geekosaur> very v7 unix of them
17:25:54 <ReinH_> I mean, they don't expose an API. That's fine, I guess, it's their decision.
17:25:56 <dcz> how does that little python code do it properly , maybe i am wrong 
17:26:03 <ReinH_> dcz: Did you try what I suggested?
17:26:04 <ReinH_> It should work.
17:26:15 <ReinH_> ByteString.pack your string
17:26:18 <geekosaur> (or early X11; the window manager API documentation was the source to twm)
17:26:27 <kurt11> How do I tell `stack ghci` to use the build-depends section from my test-suite when working on my test-suite?
17:26:48 <dcz> okey i will research and try it
17:27:14 <geekosaur> well, I'd suggest encoding to utf8 rather than just pack
17:27:22 <ReinH_> try post "http://hastebin.com/documents" (BS.pack contents), assuming you have import qualified Data.ByteString as BS
17:27:25 <geekosaur> unless you know the file is ASCII
17:27:38 <Squarism> dcz, we had this problem at my company because a ace "architect" thought he invented some revolutionary rest method. Ended up with reconfiguring all the web-/applicationsservers just to be able to send utf8 in urls
17:27:46 <ReinH_> geekosaur: Sure
17:28:03 <geekosaur> (andnote that I do not mean ISO8859-1, but the charset whose range is 0x00-0x7f)
17:28:19 <dcz> file is UTF-8
17:28:21 <ReinH_> Squarism: Ok, but that has nothing to do with this problem
17:28:31 <ReinH_> dcz: it doesn't matter what the *file* is.
17:28:41 <ReinH_> But try this first to see if it at least works
17:28:43 <geekosaur> aside from "theres a remarkable amount of stupid out there in web APIs"
17:28:52 <geekosaur> >.>
17:28:56 <dcz> okey o moment
17:28:59 <ReinH_> I mean, this API seems fine, and their reasons for not documenting it also seem fine.
17:29:17 <ReinH_> You can't complain that a private API is poorly documented. I mean, you *can*, but I don't have to listen to you. :p
17:29:47 <ReinH_> If you're posting some text to a pastebin, posting that text as the POST body seems like a perfectly reasonable way to do it.
17:31:44 <dcz> https://paste.kde.org/prgvljd1d
17:38:56 <eAio> I have an infinite loop which I thought wouldn't happen because of laziness. How can I see what's going on?
17:39:38 <hpc> maybe look at Debug.Trace
17:39:54 <hpc> which has an impure version of print just for debugging
17:40:05 <hpc> trace x y = when y is evaluated, print x
17:40:29 <hpc> or putStrLn, but the distinction isn't terribly important for this
17:40:37 * hpc hasn't had to use it in a while
17:40:42 <hpc> :t trace
17:40:44 <lambdabot> error: Variable not in scope: trace
17:40:47 <hpc> pah
17:40:56 <eAio> thanks
17:41:53 <geekosaur> :t Debug.Trace.trace
17:41:54 <lambdabot> String -> a -> a
17:42:02 <hpc> ah, ta
17:43:24 <wedify> i think take should have type (Integral a) => a -> [b] -> [b]
17:47:56 <ReinH_> dcz: Yeah, sorry, I should have told you to encode the string as utf-8 liie geekosaur suggested
17:49:55 <ReinH_> You're probably going to want to `(Data.Text.Encoding.encodeUtf8 . Data.Text.pack $ contents)`
17:50:46 <ReinH_> but at this point it would be better to use Data.Text.IO so you can use Text instead of String from the start
17:51:27 <ReinH_> s/liie/like
17:59:47 <dcz> yeah that worked Data.Text.Encoding.encodeUtf8 . Data.Text.pack $ contents
17:59:51 <dcz> thank you
18:06:41 <divVerent> @pl \ xs -> xs == isSorted xs
18:06:42 <lambdabot> ap (==) isSorted
18:06:51 <athan> Is there a way to export the state of an acid-state database so I could import it in another instance?
18:07:00 <athan> "a way" being really vague intentionall :)
18:07:02 <divVerent> @pl \ xs -> f xs == g xs
18:07:02 <lambdabot> liftM2 (==) f g
18:07:23 <divVerent> @pl \ xs -> f xs == xs
18:07:23 <lambdabot> (==) =<< f
18:07:40 <divVerent> I see
18:07:47 <athan> that one hurt my brain divVerent haha
18:08:20 <athan> I had no idea `x ->` was a monad
18:08:32 <divVerent> I knew it was, but wouldn't have figured out this one
18:08:37 <divVerent> liftM2 yes, but ap...
18:09:10 <divVerent> in fact, I don't find any of the two pointfree versions (ap or =<<) convincing vs just liftM2 (==) id isSorted
18:09:12 <divVerent> ;)
18:09:41 <divVerent> that one basically reads as "Do id and isSorted return the same result", which seems natural
18:09:42 <geekosaur> ap is just @pl not knowing about Applicative
18:09:44 <athan> (==) <*> isSorted -- yeah, there's an implicit "hey, the left side is monadic" there
18:10:02 <athan> oh hm
18:10:40 <geekosaur> and ap was as close to Applicative as Haskell got before the evolution from Arrows to idioms to Applicatives
18:11:05 <divVerent> yes, but even (==) <*> isSorted doesn't seem very readable to me yet :)
18:11:22 <divVerent> I mean, I somewhat am looking for the second arg of (==) here
18:12:08 <hpc> divVerent: it's not very readable ;)
18:13:08 <divVerent> hm... this seems better though
18:13:14 <divVerent> (==) <$> reverse <*> id
18:13:27 <divVerent> (usign reverse for playing around here)
18:13:35 <hpc> for detecting palindromes?
18:13:46 <divVerent> actually I am trying to write a "clean" and "readable" bubblesort for fun :)
18:13:51 <divVerent> seems actually hard to do
18:13:51 * geekosaur is not actually very fond of <$> and <*>. but, we're kinda short on meaningful short operators these days >.>
18:14:04 <hpc> i think they're okay
18:14:19 <hpc> they have very definite visual shapes to them
18:14:26 <hpc> which imo is important for an operator to have
18:14:38 <Clint> reverse >>= (==) is purtier
18:15:29 <dcz> thank you so much guys, i appreciated for your help especially ReinH_ .
18:15:45 <divVerent> but anyway... how would one do a "clean" bubblesort in Haskell?
18:15:53 <divVerent> Tracking this boolean seems tedious no matter how I do it...
18:16:03 <divVerent> so my starting approach was "bubbleSort =until isSorted bubble"
18:16:13 <divVerent> (the bubble function itself is easy)
18:16:40 <divVerent> but then I both dislike duplicating most logic in bubble and isSorted, so I thought of reusing bubble to perform isSorted
18:17:16 <hpc> divVerent: you shouldn't need to test for if it's sorted at all
18:17:42 <hpc> divVerent: after every "pass" of bubbles through the list, one more element can be considered in place at the end of the list
18:17:43 <divVerent> right, I'm doing that as a replacement for tracking the boolean sorted state
18:17:51 <divVerent> oh, right, THAT variant
18:17:53 <hpc> and you can reduce the list that you bubble on until it's nothing
18:17:57 <divVerent> but that's not what people call bubblesort anymore IMHO
18:18:17 <hpc> https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif
18:18:19 <divVerent> typically the whole reason to use it is to get especially fast runtime if the list is already sorted
18:18:22 <divVerent> (or mostly sorted)
18:18:35 <divVerent> but yes, the "input independent code path" solution is what you describe
18:18:40 <divVerent> essentially the sorting network
18:18:51 <dcz> have a good night all bb
18:19:30 <hpc> ah, fair point
18:22:17 <divVerent> hpc: so essentially, my "real" question is
18:22:43 <divVerent> how would one best handle such an intermediate value like bubblesort's exit condition boolean in pure functional programming
18:23:04 <divVerent> essentially wondering if this is a good case for the State monad
18:23:23 <divVerent> or if one would better track it explicitly as a Bool argument/return value
18:25:28 <hpc> hmm
18:25:33 <hpc> what if you had something like
18:26:06 <hpc> bubblePass :: [a] -> ([a], [a]), where one of those was the sorted end part and the other was the unsorted beginning part
18:26:38 <hpc> and if the unsorted list part was [] you were done
18:27:09 <hpc> then you aren't shrinking the list by exactly one element with every pass, and with a fully sorted list you're shrinking the list entirely in one pass
18:27:38 <hpc> it might also perform better on mostly-sorted lists
18:28:07 <ReinH_> > (==) <*> reverse $ "radar" -- divVerent 
18:28:09 <lambdabot>  True
18:28:36 <ReinH_> plugging `id` in isn't necessary
18:30:26 <hpc> divVerent: i am trying to approach it as what's the most convenient operation that would make a chunk of the algorithm trivial to describe
18:30:42 <hpc> and then how hard that operation is to write
18:32:52 <divVerent> ReinH_: I know it's not, but it makes it a lot more readable to me
18:32:55 <ReinH_> in fact, f <$> id <*> g = f <*> g, since f . id = f
18:33:13 <ReinH_> I think that means you haven't internalized what <*> does for ((->) r)
18:33:29 <ReinH_> and are instead relying on a rule of thumb
18:34:14 <ReinH_> That said, I don't think the Applicative instance of ((->) r) is particularly nice to work with anyway
18:34:49 <ReinH_> I usually find explicit application to be more readable, e.g., isPalindrome s = s == reverse s
18:36:23 <ReinH_> Maybe banana brackets would be nicer: (| id == reverse |)
19:45:14 <dmj`> anyone have example of a memo table using weak pointers
19:46:59 <EvanR> the weak pointer docs i thought
19:48:14 <dmj`> EvanR: not the ones I see
19:48:16 <dmj`> https://hackage.haskell.org/package/base-4.9.0.0/docs/System-Mem-Weak.html
19:49:58 <EvanR> the second paragraph relates a short parable about the idea
19:51:29 <EvanR> the whole section there is basically a "what if" about memotables
19:52:49 <dmj`> EvanR: Right, I'm looking for a way to relate a function, and it's arguments, unevaluated, to an already evaluted object. To keep from recreating the same objects needlessly
19:53:10 <dmj`> to cache the results of certain invocations
20:07:31 <EvanR> maybe look at the library "memocombinators"
20:07:39 <EvanR> sounds like its going to involve some hocus pocus
20:12:51 * hackagebot unix-time 0.3.7 - Unix time parser/formatter and utilities  https://hackage.haskell.org/package/unix-time-0.3.7 (KazuYamamoto)
21:13:52 * hackagebot legion 0.3.0.0 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.3.0.0 (taphu)
21:13:54 * hackagebot messagepack 0.5.3 - Serialize instance for Message Pack Object  https://hackage.haskell.org/package/messagepack-0.5.3 (rodrigosetti)
21:19:05 <manyone> hoW do i ask for help to improve my code?
21:20:29 <Axman6> you say "Hey, I've written this awesome code, prove me wrong!" and provide a link to it
21:20:42 <peddie> manyone: post your code at lpaste so everyone can see it; explain what part of your code you aren't happy with
21:20:47 <Axman6> or, provide a link and ask if anyone can give you tips on making it better
21:21:26 <Heasummn> This isn't specifically a Haskell problem, but rather a functional one
21:21:44 <Heasummn> I'm using OCaml if it matters, but it shouldn't
21:22:05 <Heasummn> I have a variant type that looks like: TInt | TFloat | TArrow(tp, tp)
21:22:26 <Heasummn> TArrow's bind like arrows in haskell
21:22:48 <Heasummn> I wanna take a list of types, and convert that into a TArrow
21:25:25 <slack1256T> RULES seem really fragile. Is there a paper that discusses robust alternatives for term rewriting?
21:25:33 <slack1256T> I am interested in the confluence property
21:26:19 <dmj> Heasummn: maybe try writing it in haskell first, would probably get better results here
21:27:03 <Heasummn> I think the only difference between this in Haskell and OCaml is that types are defined using the type keyword instead of data
21:27:32 <Heasummn> so something like: data tp = TInt | TFloat | TArrow tp tp
21:27:35 <peddie> Heasummn: so you have a function that takes two inputs and a list of arguments and you want to combine the arguments into a single value using that function?
21:27:48 <peddie> Heasummn: could you use `foldr`?
21:27:59 <Heasummn> yeah
21:28:30 <Heasummn> I have a function that takes a > 2 element list. And wants to convert it to a TArrow()
21:28:57 <peddie> so convert (x:xs) = foldr TArrow x xs or so?
21:29:20 <Heasummn> yeah
21:29:36 <Heasummn> but, I want the TArrow's to bind left
21:29:52 <peddie> maybe use  foldl'  then instead of  foldr
21:30:03 <Heasummn> so like [Tint, Tint, Tint] would be TArrow(TInt, TArrow(TInt, TInt))
21:30:09 <Heasummn> oh
21:30:12 <Heasummn> I'm an idiot
21:30:17 <Heasummn> foldl
21:30:38 <peddie> Heasummn: foldl' is probably what you want
21:30:52 <peddie> with an apostrophe
21:32:17 <Heasummn> what's the difference between foldl and foldl'?
21:32:22 <Reshi> Ocaml won't have that problem
21:32:25 <pkmx> Huh? TInt `TArrow` (TInt `TArrow` TInt) would be foldr
21:32:34 <lpaste> manyone pasted “counting sheep” at http://lpaste.net/185111
21:33:03 <Reshi> OCaml has strict evaluation, from what I remember
21:33:13 <Heasummn> yeah
21:33:16 <Heasummn> Not lazy
21:33:17 <pkmx> foldl' would give: (TInt `TArrow` TInt) `TArrow` TInt
21:33:43 <Heasummn> Can I share my OCaml code, and hope that you guys can understand it? The syntax and general ideas aren't different
21:34:07 <manyone> i just pasted my newbie code in  lpaste under 'counting sheep'
21:34:27 <Heasummn> https://bpaste.net/show/4a3569a0b85f
21:35:20 <manyone> i just pasted my newbie code 'counting sheep' here: http://lpaste.net/185111
21:35:50 <peddie> Heasummn: did you try `List.fold_right` like `pkmx` suggested and see wehther that gives you the result you want?
21:37:03 <Reshi> manyone: For starters you could follow the aesthetic suggestions below the lpaste, and add type signatures to functions. This is all aesthetic 
21:38:30 <Reshi> manyone: Type signatures and better variable names will make it more easy to read and understand your solution
21:40:51 <peddie> manyone: in  find_sheep  you can use a pattern-match to check whether b is empty and separate the two cases
21:41:02 <lucky0604> #javascript
21:41:40 <peddie> manyone: just like you did in  remove
21:41:57 <Heasummn> Thanks everyone. I was able to debug a bit and figure out how to get it to work
21:42:02 <Heasummn> I gtg now
21:42:14 <manyone> peddie: i will try that
21:42:59 <buttons840> does anyone know of an example of generating a cryptographically random string?
21:43:10 <peddie> manyone: you can replace  remove  with the  filter  function
21:43:14 <peddie> :t filter  -- manyone
21:43:16 <lambdabot> (a -> Bool) -> [a] -> [a]
21:43:28 <peddie> > filter (==2) [1..10]   -- manyone
21:43:30 <lambdabot>  [2]
21:43:44 <peddie> oops, I mean
21:43:47 <buttons840> i'm looking at Crypto.Random.DRBG and trying to follow the types, but an example would be nice
21:43:53 <peddie> > filter (/= 2) [1..10]  -- manyone
21:43:55 <lambdabot>  [1,3,4,5,6,7,8,9,10]
21:44:56 <peddie> > filter (\x -> not $ x `elem` [1, 3, 5]) [1..10]  -- manyone
21:44:59 <lambdabot>  [2,4,6,7,8,9,10]
21:50:00 <Gribo> I'm getting a parse error when compiling this let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]   
21:50:34 <lpaste> manyone revised “counting sheep”: “counting sheep” at http://lpaste.net/185111
21:51:17 <lpaste> manyone revised “counting sheep”: “counting sheep” at http://lpaste.net/185111
21:52:04 <alercah> >  let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] 
21:52:06 <lambdabot>  <no location info>: error:
21:52:06 <lambdabot>      not an expression: ‘let triangles = [ (a,b,c) | c <- [1..10], b <- [1..1...
21:52:12 <alercah> >  let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] in triangles
21:52:14 <lambdabot>  [(1,1,1),(2,1,1),(3,1,1),(4,1,1),(5,1,1),(6,1,1),(7,1,1),(8,1,1),(9,1,1),(10...
21:52:39 <peddie> manyone: the usual style is to surround the function arrow -> with spaces:  Int -> Int -> [Int] -> String
21:53:34 <manyone> peddie : will do
21:53:46 <peddie> manyone: did you see my messages above about  filter  and  elem?
21:54:27 <manyone> peddie: i did but i want to REMOVE after i find out the digit is there
21:54:49 <manyone> peddie: i see you meant the lambda? let me try
21:55:08 <peddie> manyone: I'm not sure what you mean by "you want to REMOVE after you find out the digit is there"
21:55:47 <peddie> manyone: I think  remove  could be written   remove n = filter (/= n)
21:56:20 <manyone> peddie: your filter is the key - it already "removes" the matched digits
22:00:14 <peddie> manyone: I see, you only want to remove the first occurrence of a digit
22:01:15 <manyone> peddie: no, your filter is correct but it wont let me use it in this:removelist a b = filter (\x -> not $ x `elem` a) b
22:01:29 <manyone> peddie: something about binding
22:02:03 <peddie> manyone: sorry, "something about binding" doesn't tell me too much (I am no wizard); can you paste the exact error in a comment in your lpaste?
22:02:42 <peddie> manyone: you could try  (\x -> not (x `elem` a))  in case it's to do with $ and precedence
22:02:56 <peddie> manyone: it worked for me above though
22:03:00 <lpaste> manyone revised “counting sheep”: “counting sheep” at http://lpaste.net/185111
22:03:25 <buttons840> > map (+1) (1, 1)
22:03:27 <lambdabot>  error:
22:03:27 <lambdabot>      • Couldn't match expected type ‘[b]’
22:03:27 <lambdabot>                    with actual type ‘(Integer, Integer)’
22:04:00 <peddie> manyone: I get what the function is, but can you paste the error the compiler gives you in the comment?
22:04:58 <peddie> manyone: is it because  removeList  is spelled with a capital L for the signature and lower-case l for the function definition?
22:05:02 <manyone> peddie: sheep.hs:17:1: error:     The type signature for `removeList' lacks an accompanying binding
22:05:54 <lpaste> manyone revised “counting sheep”: “counting sheep” at http://lpaste.net/185111
22:07:00 <peddie> manyone: now you don't need  remove  at all anymore, and you can follow the suggestions at the bottom
22:07:33 <lpaste> manyone revised “counting sheep”: “counting sheep” at http://lpaste.net/185111
22:08:44 <manyone> peddie: i see that - i dont need remove anymore - thanks for the tips! 
22:09:17 <lpaste> manyone revised “counting sheep”: “counting sheep” at http://lpaste.net/185111
22:10:13 <peddie> manyone: the helpful suggestions at the bottom of your paste (e.g. "use `notElem`") are made by a program called hlint.  you can install hlint on your machine and run it on your code to get those suggestions locally
22:12:43 <lpaste> manyone revised “counting sheep”: “counting sheep” at http://lpaste.net/185111
22:13:19 <lpaste> manyone revised “counting sheep”: “counting sheep” at http://lpaste.net/185111
22:14:34 <manyone> peddie: im running under windows so maybe hlint is only for linux - what is the eta reduce error? my program runs
22:15:17 <glguy> manyone: hlint errors aren't actually errors
22:15:43 <glguy> They're just source code style suggestions
22:16:31 <peddie> manyone: I don't know why it's labeled an error; it's just a suggestion.  I think it suggests "eta reduce" so the reader of your code doesn't have to keep track of that argument 
22:18:01 <peddie> manyone: I think the author of hlint uses windows primarily; I'd be surprised if it only ran on linux
22:18:32 <manyone> peddie: my next question is about the strategy - i used procedural thinkign to start with all [0..9]  but each trial removes digits from it until []- it's solved.  is that typical - im passing the list around at every call
22:20:10 <peddie> manyone: well, the starting value of 1692 is a little confusing to me; I don't know where that comes from (but I didn't read the problem statement)
22:20:28 <manyone> peddie: maybe the eta reduce has something to do with the fact that there's the same argument on both sides
22:20:45 <peddie> manyone: that's exactly what it is
22:21:10 <peddie> manyone: in general having a recursive function like `findSheep` seems pretty reasonable to me
22:21:26 <manyone> 1692 is oyt of the blue.
22:24:04 <peddie> manyone: does the program still give the right answer?
22:26:43 <manyone> peddie: yes it does - its working except i cant help thinking it looks like a fold problem because i start with [0..9] and i get an answer when it's [] after a fold
22:27:01 <ReinH> Passing state around via arguments to functions is extremely typical.
22:27:21 <peddie> manyone: I'm sure you could rewrite it as a fold, but I'm not sure it'd be any easier to understand
22:27:28 <peddie> manyone: it could be a good exercise though
22:27:34 <ReinH> It's even a reasonable definition of functional programming.
22:27:52 <manyone> peddie: i'm not there yet
22:28:14 <ReinH> It's so typical that we have a bunch of helpers for common cases like foldr and friends
22:29:43 <manyone> ReinH: i havent had enough experince with writing helpers yet 
22:30:15 <manyone> ReinH: is that the same exercise as rewriting map using fold?
22:31:34 <Gribo> alercah, Can you explain what it is that you changed?
22:31:52 <Gribo> I'm learning from here http://learnyouahaskell.com/starting-out#texas-ranges
22:32:20 <manyone> peddie: thanks for your help - i hope i catch you again next time i visit
22:32:57 <peddie> manyone: only one way to get there :)
22:33:05 <peddie> manyone: you're very welcome; keep up the good work
22:35:48 <xuxu> does anyone have time to walk through this problem with me? http://lpaste.net/184480
22:37:11 <peddie> xuxu: do you know the type of foldr?
22:38:14 <xuxu> peddie: yeah
22:38:29 <liste> :t foldr -- see how many arguments the 1st argument has
22:38:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
22:38:45 <dibblego> 1
22:39:02 <ReinH> > foldr (:) [] [1,2,3]
22:39:03 <peddie> (xuxu: thanks for the very clear problem description by the way)
22:39:05 <lambdabot>  [1,2,3]
22:39:16 <ReinH> Is (:) fed only []?
22:39:25 <Gribo> > let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]
22:39:27 <lambdabot>  <no location info>: error:
22:39:27 <lambdabot>      not an expression: ‘let triangles = [ (a,b,c) | c <- [1..10], b <- [1..1...
22:39:32 <ReinH> xuxu: ^
22:39:54 <dibblego> (foldr f z list) replaces (:) with (f) and [] with (z) in (list). All functions in Haskell take one argument. If it is a function, it takes one argument.
22:40:25 <ReinH> dibblego: I know how foldr works
22:40:40 <dibblego> (foldr (:) []) is an identity because (:) is replaced with (:) and [] with []
22:40:44 <dibblego> ReinH: I know you know.
22:41:12 <Gribo> Can anyone explain why this line of code doesn't work?
22:41:12 <ReinH> Then let xuxu answer please.
22:41:56 <peddie> Gribo: lambdabot only evaluates expressions, and you have to have 'let . . . in . . .' to form an expression.  it's not like ghci where you can type 'let . . .' at the prompt
22:41:58 <dibblego> ReinH: ok
22:42:34 <ReinH> I'm trying to make a point about treeInsert by comparison
22:42:50 <Gribo> Oh, but if I write that line of code inside somefile.hs and load it in ghci it will give me an error. Why is that?
22:43:29 <peddie> Gribo: the only place you can type  let  without a corresponding  in  is if you're typing into the ghci prompt
22:43:59 <Gribo> Oh.
22:44:19 <peddie> Gribo: if you want to define the triangles in a haskell source file, just get rid of the leading  let
22:44:23 <Gribo> What's the different between writing triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] and using let .... in
22:44:34 <ReinH> The top-level scope of a Haskell module (file) is for definitions (e.g., id x = x)
22:45:00 <ReinH> let ... in ... is an expression, which is not valid there.
22:45:31 <ReinH> You also can't just put `1` or `"hello"`
22:45:59 <Gribo> I don't really understand what you mean
22:46:12 <ReinH> "Hello" is a value.
22:46:17 <Gribo> Yeah
22:46:23 <ReinH> id x = x is an expression.
22:46:35 <Gribo> and let isn't an expression?
22:46:38 <ReinH> Ugh, is a definition
22:46:40 <xuxu> ReinH: i know that curryng turns everything into partial application. i believe foldr (:) [] [1,2,3] evaluates to something like this 1:(2:(3:[]))
22:46:41 <ReinH> Sorry
22:46:56 <ReinH> id x = x is a definition
22:47:19 <Gribo> oh so let is just telling ghci to define it?
22:47:39 <Gribo> Is that a good way to think of it?
22:47:48 <ReinH> The context of ghci is a modified do block
22:47:53 <ReinH> For IO actions
22:48:03 <Gribo> What's a do block?
22:48:08 <ReinH> So you use let a = b there
22:48:15 <Gribo> Oh yeah do block
22:48:22 <Gribo> I haven't gotten there yet in the tutorial
22:48:38 <xuxu> ReinH, peddie: i might give up tonight and ask tomorrow when i have a little more mental energy
22:48:49 <Gribo> thanks ReinH and peddie
22:48:55 <peddie> xuxu: I think you're almost there: think about what happens if you use  treeInsert  in place of  :  and  emptyTree  in place of  []
22:48:58 <wedify> xuxu: if we had foldr treeInsert nums EmptyTree would it make more sense?
22:49:00 <peddie> xuxu: ok, see you later
22:49:28 <ReinH> xuxu: so if (:) takes two arguments in that foldr, why would treeInsert only take one in your fold?
22:50:16 <ReinH> (To make dibblego happy, it takes one argument and returns a function that takes one argument and returns a value that, in this case, is not a function.)
22:50:35 <dibblego> I am always happy.
22:50:39 * glguy is happy now
22:51:13 <shachaf> I'm never happy.
22:51:19 <shachaf> (According to #haskell.)
22:51:52 <ReinH> wedify: how would that make more sense?
22:52:17 <wedify> well we're starting from the end and working to the left
22:52:33 <wedify> the f changes the value thats "at the end"
22:52:38 <dibblego> no, foldr does not start from the end and work to the left
22:52:51 <ReinH> I don't think a type error makes more sense than a working function.
22:52:52 * dibblego is still happy
22:53:48 <wedify> we can think of it as having (a:b:c) x. then we apply the f and get a:b:f c x
22:53:59 <ReinH> And evaluation of foldr proceeds outside-in, like everything else.
22:55:10 <ReinH> > foldr (||) False (repeat True)
22:55:12 <lambdabot>  True
22:55:23 <wedify> i was trying to give an intuitive model, not precise semantics
22:55:25 <ReinH> foldr can't start from the end.
22:56:30 <ReinH> The question calls for precise semantics, not incorrect intuitive models.
22:56:33 <dibblego> It is my experience that this model is consistently unintuitive, inaccurate and unhelpful
22:56:58 <ReinH> If someone is confused, incorrect models won't make them less confused.
23:00:02 <wedify> it goes down to the end though right? it works out to f a (f b (f c x))
23:00:16 <ReinH> Look at my example,
23:00:21 <ReinH> There is no end.
23:00:47 <xuxu> yeah, i'm definitely too tired for this tonight, but if i do treeInsert EmptyTree [1,2,3], i think the first value in foldr is 3 and the accumulator is an EmptyTree so i think it pattern matches to singleton 3 
23:00:52 <dibblego> wedify: no, for example, there is no end, as in the example above, and so could not have possibly gone there.
23:00:57 <xuxu> the output of treeInsert EmptyTree [1,2,3] is Node 3 (Node 2 (Node 1 EmptyTree EmptyTree) EmptyTree) EmptyTree
23:01:03 <xuxu> not seeing a singleton
23:01:21 <dibblego> it associates to the right, which is a subtle and important difference
23:01:35 <ReinH> xuxu: but you aren't doing treeInsert EmptyTree [1,2,3]
23:01:45 <dibblego> but then again, so does (:) associate to the right, so it is better (intuition) to just think of foldr in terms of constructor replacement
23:02:31 <xuxu> ReinH: i'm sorry, i meant foldr treeInsert EmptyTree [1,2,3]
23:02:35 <peddie> xuxu: wouldn't  Node 1 EmptyTree EmptyTree  in the middle of your predicted output be a singleton?
23:04:37 <wedify> ReinH, dibblego: ok. i admit i have no idea how foldr works on a infinite list
23:04:59 <ReinH> It works by replacing every (:) with f and every [] with z
23:05:04 <dibblego> wedify: (foldr f z list) replaces (:) with (f) and [] with (z) in (list). There may not be a [].
23:05:13 <ReinH> There can be at most one []
23:06:29 <xuxu> peddie: i don't know if a pattern for that exists
23:06:37 <ReinH> @quote fugue
23:06:37 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
23:06:55 <ReinH> Not really contrapuntal this time
23:07:40 <ReinH> xuxu: write out the steps of your foldr
23:07:44 <ReinH> One by one
23:07:49 <ReinH> @where lazy
23:07:49 <peddie> xuxu: not sure what you mean -- what I mean is that output  Node 1 EmptyTree EmptyTree  looks like you called   singleton 1
23:07:49 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
23:07:52 <ReinH> Like this
23:08:35 <ReinH> No substitute for seeing exactly what is happening
23:09:04 <ReinH> xuxu: read the whole thing, but especially the "case study: foldr"
23:09:26 <xuxu> ReinH: this is the kind of step through i was hoping to get, but i realize it would take time
23:09:39 <ReinH> You can do it yourself
23:09:53 <xuxu> i will, thank you for the link
23:10:00 <ReinH> yw
23:10:22 <xuxu> time for bed over here, looking forward to trying that
23:11:06 <ReinH> There is no magic, there is only applying definitions and rules of evaluation.
23:12:46 <EvanR> Magic -> Void
23:13:00 <EvanR> obv
23:19:00 <wedify> wasn't there a site that let you visualize evaluation of expressions?
23:19:17 <wedify> i remember playing with it but i don't remember where
23:19:19 <chreekat> I remember that
23:19:25 <chreekat> ditto
23:19:25 <ski> @where stepeval
23:19:25 <lambdabot> <http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi>,<https://github.com/bmillwood/stepeval>
23:19:27 <ski> perhaps
23:20:50 <wedify> ski: not it but it's good. thanks
23:22:47 <dibblego> wedify: you mean this one? http://foldr.com/ and this one? http://foldl.com/
23:24:04 <EvanR> awesome
23:35:01 <ReinH>  Nice
23:37:18 <wedify> ok working with stepeval was helpful
