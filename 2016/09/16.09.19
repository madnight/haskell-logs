00:01:48 <hololeap> is there a way to compile haskell for arduino?
00:02:33 <maybecia> I am unable to use the constructor Data.Aeson.Types.UntaggedValue. I am getting the error, Not in scope: data constructor ‘UntaggedValue’
00:05:30 <maybecia> hololeap, follow these steps: https://github.com/blitzcode/hue-dashboard#raspberry-pi
00:06:00 <maybecia> hololeap, but it is not straightforward
00:06:37 <Axman6> Raspberry Pi /= Arduino...
00:07:09 <Axman6> hololeap: not really, but there are systems which can be used to write code which can be run on an Arduino in a nicer language than C(/C++)
00:07:27 <geekosaur> check what version of aeson you have
00:07:31 <hololeap> Axman6: please, tell me :)
00:07:37 * hackagebot xlsx-tabular 0.1.0.2 - Xlsx table decode utility  https://hackage.haskell.org/package/xlsx-tabular-0.1.0.2 (KazuoKoga)
00:07:37 * hackagebot yaml 0.8.18.7 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18.7 (MichaelSnoyman)
00:07:56 <Axman6> Trying to remember their names. Ivory and Tower are designed for that space
00:08:09 <hololeap> the micromanaging of loops and functions is killing me :)
00:08:19 <Axman6> http://ivorylang.org/ivory-introduction.html
00:08:53 <Axman6> there's another one based on building streams which quarantees constant memory loops
00:08:59 <geekosaur> maybecia, check what version of aeson you have. I'm looking at 0.7.0.4 and it has SumEncoding but no UntaggedValue constructir
00:09:20 <geekosaur> (1.0.1.0 has it)
00:09:31 <geekosaur> (I did not bisect to see when it was added)
00:10:15 <maybecia> geekosaur, shit im on 0.11.2.1
00:10:24 <maybecia> that one doesnt have that constructoe
00:10:43 <geekosaur> yep
00:10:57 <Axman6> hololeap: Atom is what I was thinking of, can't find a nice tutprial: http://hackage.haskell.org/package/atom
00:11:52 <Axman6> hmm, no it wasn't Atom, it was something built on top of atom
00:12:48 <Axman6> hololeap: Copilot! http://leepike.github.io/Copilot/
00:13:42 <koz_> Axman6: That's really neat!
00:13:48 <MarcelineVQ>  copilot last update was a year ago but it's not like C has changed radically in that timespan
00:14:03 <koz_> Before, I used to be 'Haskell and C are my languages'. Now, it's just Haskell. :P
00:14:16 <MarcelineVQ> Oh my bad, it just moved :(
00:14:18 <koz_> Also, could someone explain to me the difference between 'ContT (ListT Identity)' and 'ListT (ContT Identity)'?
00:14:29 <MarcelineVQ> It's very up to date
00:16:31 <Axman6> hololeap: you might find http://stackoverflow.com/questions/1263711/using-haskell-for-sizable-real-time-systems-how-if useful 
00:17:31 * hackagebot servant-purescript 0.4.0.1 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.4.0.1 (eskimo)
00:17:33 * hackagebot alphachar 0.0.1 - A character between a-z  https://hackage.haskell.org/package/alphachar-0.0.1 (TonyMorris)
00:17:35 * hackagebot avwx 0.2.0.0 - Parse METAR weather reports  https://hackage.haskell.org/package/avwx-0.2.0.0 (hc)
00:18:56 <ParkeT> Hey guys.  I have a question. In function type definition, if i use type variables 
00:19:18 <ParkeT> olo :: a -> b -> Int , for example
00:19:59 <grantwu> If I ignore the output of a Writer monad, does laziness mean that the computations required to create the output aren't run?
00:20:00 <ParkeT> Does it mean than type of `a` MUST differ of type `b`?
00:20:04 <liste> ParkeT: no
00:20:05 <grantwu> ParkeT: No
00:20:40 <sbrg> ParkeT: nope. but it means it *can* differ.
00:20:50 <lpaste> arianvp pasted “No title” at http://lpaste.net/203145
00:20:51 <Axman6> :t const
00:20:52 <sbrg> where if you had a -> a -> Int, then the two `a`s are the same
00:20:52 <lambdabot> a -> b -> a
00:21:01 <Axman6> > const (1 :: Int) (2 :: Int)
00:21:03 <lambdabot>  1
00:22:13 <ParkeT> Ok. It is clear. Thank you. I have red this article https://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/
00:22:39 <grantwu> i.e. a Writer equivalent of evalState
00:22:49 <ParkeT> And author sad, that (in section Explanation), that the MUST differ
00:23:12 <ParkeT> that they*
00:23:23 <dibblego> ParkeT: it means the type of a might, or might not, differ from b
00:23:48 <dibblego> ParkeT: if they were both a, then they are definitely the same type.
00:23:54 <grantwu> I'm not sure RankN types are relevant to this at all
00:24:13 <ParkeT> It is clear, thank you. So, author is wrong, when he sad that `it would expect the type variables a, b and c to be different concrete types, so ([a] -> Int) might become`
00:24:20 <dibblego> > fst (1, undefined) -- grantwu, like this?
00:24:22 <lambdabot>  1
00:24:24 <ParkeT> different is bold, so he sad it MUST be
00:24:40 <shachaf> That doesn't look like a very helpful explanation of rank-n types.
00:25:10 <grantwu> dibblego: Hrm, yeah, I could always use runWriter and ignore the output myself.
00:25:25 <grantwu> ParkeT: I'm pretty sure you shouldn't worry overmuch about rank N types
00:25:36 <ParkeT> But i want :)
00:25:52 <shachaf> grantwu: The motivation for this question was understanding rank-n types.
00:26:27 <liste> ParkeT: yeah, that part looks wrong. maybe the author just meant that the function can't assume that a, b and c can be the same type
00:26:44 <liste> or, rather, the type checker can't assume that
00:27:38 <grantwu> shachaf: Oh, I see.  I assumed that understanding a -> b -> Int was sort of prerequisite to understanding rank N types, but if the article is leading to that confusion
00:27:54 <ParkeT> Sure. There no type `a`, were `a` == `b` and `a` == `c` in his example. It is clear.
00:28:12 <ParkeT> But the should not be different in all cases
00:28:37 <grantwu> So my partner profiled our compiler
00:28:46 <grantwu> Turns out it is allocating 16 GB of memory on 6 MB of input
00:29:38 <shachaf> The situation on the type level is the same as on the value level: f x y = x*2 +y*3
00:29:42 <sbrg> grantwu: your own compiler? 
00:30:30 <grantwu> sbrg: Yes
00:30:42 <sbrg> grantwu: and 6 MB of input is 6 MB of code? 
00:31:06 <Axman6> that sounds pretty inefficient...
00:31:08 <grantwu> sbrg: No, a trivial int main() { return 1; } and 6 MB of a comment
00:31:10 <grantwu> http://www.cs.cmu.edu/~janh/courses/411/16/
00:31:17 <sbrg> aaaah. 
00:31:17 <grantwu> Axman6: Yep :P
00:31:22 <sbrg> how on earth does that happen?
00:31:24 <Axman6> ha
00:31:27 <sbrg> written in haskell?
00:31:35 <grantwu> Yes, of course
00:31:43 <grantwu> Megaparsec is being a bad, presumably?
00:31:43 <Axman6> grantwu: what's your comment parser look like?
00:31:53 <Axman6> sounds like you're being bad ;)
00:31:57 <grantwu> It's the skipBlockCommentNested parser from Megaparsec
00:32:24 <grantwu> https://github.com/mrkkrp/megaparsec/blob/82994e45d4b98c874ff4f83a5f35f90ba122e5f2/Text/Megaparsec/Lexer.hs#L179
00:32:38 <sbrg> considered just using happy?
00:32:57 <ParkeT> Once again. StackOverflow, yairchu's answer http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
00:33:18 <sbrg> happy can output some pretty efficient code, I believe. 
00:33:22 <grantwu> Well... we've already written it with Megaparsec.
00:33:35 <sbrg> the lexer? 
00:33:39 <grantwu> The entire parser
00:33:42 <Axman6> wait... how does that even terminate
00:33:45 <grantwu> We're not using a separate parser
00:33:47 <grantwu> er, lexer
00:33:48 <ParkeT> "Hmm.. why does GHC infer that the tuple must contain two of the same type? Let's tell it they don't have to be", yairchu sad. And type difinition is: liftTup :: (x -> f x) -> (a, b) -> (f a, f b)
00:33:48 <sbrg> I see
00:34:02 <ParkeT> But they can! :/ 
00:34:04 <grantwu> I have vague thoughts of using Alex first
00:34:06 <ParkeT> This confusing me
00:34:15 <sbrg> eh, I meant Alex, actually
00:34:24 <sbrg> for lexing
00:34:38 <grantwu> Oh.  Well then, yes, that is something we are considering
00:34:43 <sbrg> but allocating 6 GB to skip a really long comment is absolutely insane
00:34:51 <grantwu> Yeah
00:34:52 <sbrg> 16*
00:35:02 <Axman6> yeah I feel using void (manyTill ...)is a _really_ bad idea
00:35:07 <grantwu> My newbie mind guesses "excessive laziness somewhere"
00:35:18 <Axman6> because it will be building up a huge thunk
00:35:22 <sbrg> almost definitely. sounds like it's creating a huge thunk
00:35:22 <sbrg> yeah
00:35:51 <grantwu> so uh
00:36:01 <grantwu> Where do we put the !
00:36:03 <grantwu> :P
00:36:11 <Axman6> something that looks like (:) <$> p <*> ((:) <$> p <*> ...) <|> pure []) <|> pure []
00:36:22 <Axman6> which is horrible
00:36:23 <pavonia> ParkeT: What's confusing about it?
00:36:30 <geekosaur> ParkeT, the problem is that (x -> f x) will be monomorphic; it'll pick one x and stick to it, and if you're applying it to both elements of the tuple they end up having to be the same type. you need to use forall to get around that
00:36:38 <sbrg> maybe you can rewrite the comment parser to a be a bit smarter. I wrote a compiler for a course last year(we had to use C) and I decided to write on in Haskell as well afterwards. didn't get very far, lost interest, but my initial idea was also to use parsec(or friends) to just write a lexer and a parser in one go.
00:36:47 <Axman6> is there a manyTill_ which doesn't return the parsed bits?
00:36:49 <ParkeT> `Let's tell it they don't have to be` liftTup :: (x -> f x) -> (a, b) -> (f a, f b)
00:37:02 <sbrg> but I kind of came to the conclusion that it's not a very good idea. you may have to do some magic to get the performance and semantics that you want, etc. 
00:37:03 <ParkeT> But, `a` can be == `b`
00:37:05 <sbrg> so I went with alex and happy
00:37:10 <geekosaur> (forall x. x -> f x)
00:37:23 <grantwu> Axman6: Apparently my partner said he wrote such a version and it wasn't very useful
00:37:50 <Axman6> I wouldn't mind seeing that definition...
00:38:06 <sbrg> grantwu: hm? if the manyTill_ version doesn't collect the results then they should be garbage collected immediately
00:38:11 <sbrg> thus no thunk
00:38:36 <grantwu> manyTill_ p end = go where go = (() <$ end) <|> (p *> go)
00:38:37 <ParkeT> geekosaur, this is also clear. But Why he decide, that `a` can not be equal `b` in liftTup :: (x -> f x) -> (a, b) -> (f a, f b)
00:38:49 <geekosaur> huh?
00:38:54 <ParkeT> geekosaur, `Let's tell it they don't have to be`
00:39:18 <geekosaur> yes, you keep saying that, what is the evidence by which you conclude that a can not be equal to be?
00:39:23 <geekosaur> *to b
00:39:34 <Axman6> grantwu: I can't see how that could not help, unless that's not the only problem
00:40:09 <Axman6> ParkeT: all that says is that a MAY not equal b
00:40:14 <sbrg> grantwu: did you run a heap profile?
00:40:21 <grantwu> Yeah
00:40:55 <geekosaur> ParkeT, in fact, please show the code that is failing for you and the full error message
00:40:56 <geekosaur> @paste
00:40:56 <lambdabot> Haskell pastebin: http://lpaste.net/
00:41:05 <geekosaur> & use pastebin, do not paste into irc
00:41:42 <sbrg> grantwu: if you do a profiling run and look at the output you should see which part of your code is responsible for allocating all that memory
00:42:05 <ParkeT> Axman6, ok. Thank you, maby i misunderstand that phrase. English is not my native lang, as you can see :)
00:42:18 <Axman6> no worries :)
00:42:27 <grantwu> sbrg: It is that part
00:42:32 <grantwu> the block comment part
00:42:35 <sbrg> i see
00:42:52 <geekosaur> ParkeT, "may or may not be equal"
00:42:56 <ParkeT> Axman6, geekosaur, pavonia, dibblego, grantwu, thx for you answers, guys!
00:43:17 <geekosaur> they are allowed to vary, it expresses no relationship between them so they might have the same type or might noit
00:43:38 <geekosaur> there are ways to force constraints on types, but as it turns out "is not the same type" is very hard to express
00:43:52 <geekosaur> so you don't actually see that one very often
00:45:00 <grantwu> sbrg: According to the profile, 99.8% of time and 100% of memory allocations are being spent on parsing
00:45:23 <grantwu> 61% of allocations are spent merely on the block comment parser
00:45:26 <geekosaur> hope that parser is not written in a way that causes a lot of backtracking...
00:46:08 <grantwu> It's just parsing a comment
00:46:18 <grantwu> There shouldn't be much backtracking involved :/
00:46:19 <Axman6> really inefficiently
00:46:29 <Axman6> every call to <|> is backtracking
00:46:43 <grantwu> oh.
00:47:18 <sbrg> you could probably write a new parser that just uses a stack to keep track of the nested comments. I think that would work
00:47:24 <grantwu> The fact that I didn't write the parser is showing
00:47:30 <athan> Is there a way to pack a text file into haskell source, besides copy-pasting?
00:47:43 <grantwu> athan: cat?
00:47:58 <athan> I just want the text to be in the executable
00:48:03 <athan> grantwu: ?
00:48:05 <jle`> athan: there are some TH libraries that puts it in at compile-time
00:48:12 <jle`> er, grammar
00:48:17 <athan> jle` Ah! I knew it
00:48:25 <sbrg> or actually since you don't want to keep the results you can just use an integer or something. add 1 to the int whenever you see an opening comment, and subtract when you see a closing comment. if it ever goes < 0 it's an error. I think that would work?
00:48:30 <jle`> hooray for unrestricted compile-time IO
00:48:35 <geekosaur> look for "heredoc" or "here document"
00:48:41 <athan> it puts it in the sdist or else it gets... uh.. tired :v
00:48:45 <geekosaur> (which is what the shell calls that)
00:48:48 <sbrg> I think it's similar to the way bison does it. it has "stages" or some such
00:48:50 <grantwu> I meant, you can do something silly like concatenating the text files
00:49:02 <athan> thanks :)
00:49:10 <geekosaur> also beware that large files will expose the fact that ghc encodes string literals in an especially wasteful and slow way
00:50:22 <geekosaur> (well, not quite true. it stores them sensibly, but then at runtime it unpacks them into String before possibly applying OverloadedStrings, yuck)
00:50:44 <athan> oh, shoot :\
00:50:56 <athan> you don't think there's one for lazy text?
00:51:11 <athan> eh screw it I'm not gonna complain
00:51:14 <athan> not mission critical here
00:51:30 <geekosaur> most probably not, it'd need to use internals or go through OverloadedStrings and I suspect most just do the latter
00:51:58 <glguy> geekosaur: text has rewrite rules to avoid going via string
00:52:21 <geekosaur> how does that interact with the way string literals are stored?
00:52:29 <glguy> positively
00:53:37 <geekosaur> ok, maybe it won't be completely nightmarish. but I bet it still duplicates it, because Text doesn't expect its backing array to be in the data segment (or possibly the code segment since it's a constant; I haven't looked at how ghc does that part)
00:53:59 <geekosaur> s/in the data segment/outside the heap/
00:54:17 <glguy> it's stored in utf8 and text inflates that for you
00:56:09 <geekosaur> ok, so you;d still need magic of some kind to arrange for a Text literal to be compiled in instead of being duplicated
00:59:08 <shachaf> That seems trickier since Text is stored in a GHC array.
01:12:33 <Geraldus_> Hi folks!
01:13:03 <Geraldus_> Can someone give a glue how to become a package co-maintainer (I want to be able upload new version of some packages to Hackage)?
01:13:45 <MarcelineVQ> That can be a sticky subject
01:14:21 <sshine> Geraldus_, do you mean besides talking with the current maintainer?
01:15:26 <merijn> Geraldus_: You can only become one if a current maintainer adds you OR you follow the procedure for abadonned packages
01:16:56 <Geraldus_> sshine: merijn: hi friends!  How current maintainer should add me as co-maintainer?
01:18:07 <merijn> Geraldus_: Email them and ask them to add your username to the maintainers list? :)
01:22:30 <guillaum2> Hello. I'm stuck with an ambiguous type when using polymorphic literals. I don't know how to explain it, so a short explain may help : http://lpaste.net/203228
01:22:54 <guillaum2> guillaum2: as a result I must force the type using type annotation everywhere.
01:24:12 <merijn> guillaum2: Usually inference would solve that for you
01:24:25 <merijn> but there's no general way to resolve ambiguous types
01:24:53 <merijn> oh, wait, I guess inference can't help here.
01:25:27 <merijn> guillaum2: Someone might be able to invent a workaround, but as it is there's no way around just annotating the type
01:27:12 <guillaum2> merijn: ok ;( I can understand the issue, but why this kind of thing works in another context ? For example, `show 5` should be ambiguous, but `5` defaults to `Integer`. Why it does not default to `Integer` in my case ?
01:28:30 <geekosaur> because only a certain set of blessed typeclasses listed in the language Report allow it, mainly because the compiler knows how they work
01:28:48 <grantwu> I am curious as to why it's called the language report
01:29:02 <geekosaur> ghci does use an extension which extends that set to some user-defined classes following strict rules
01:29:08 <grantwu> Makes it almost sound like somebody went out and investigated how people were writing Haskell in practice
01:29:12 <grantwu> And wrote up their empirical findings
01:29:22 <merijn> grantwu: That's what the report is supposed to be
01:29:28 <grantwu> oh
01:29:44 <merijn> grantwu: The report is "standardising what we've done up to now"
01:30:25 <grantwu> I thought it was more like a spec
01:30:35 <grantwu> I suppose it is
01:30:37 <merijn> grantwu: So Haskell98 standardised a bunch of stuff from Haskell1.4 and earlier. Haskell2010 updated it (a tiny bit) compared  to Haskell98. The new Haskell Prime committee is tasked with writing up a new
01:30:59 <merijn> grantwu: It is a spec, but rather than "spec first, implement later" it's "implement first (as extension), standardise after"
01:31:17 <guillaum2> geekosaur: thank you, that's a "good" reason ;)
01:31:52 <grantwu> merijn: I see, thanks for the info
01:32:29 <merijn> grantwu: The hope is that Haskell Prime will standardise a bunch of common GHC extension in the next report
01:33:10 <merijn> grantwu: But one of the issues is that some extensions that are used a lot don't have a declarative definition yet and the report wants to avoid implementation assumptions. For other extensions their theoretical soundness is in question
01:33:11 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extended-default-rules is how ghci extends it, and I misremembered, it just requires that one of the known typeclasses be involved, it doesn't try to figure out how unknown ones work
01:34:06 <merijn> grantwu: i.e. the (broken) "ImpredicativeTypes" extension isn't so much broken in implementation, as much as "no one really knows how it's supposed to work in theory, so how do you tell if the implementation is correct?"
01:36:05 <geekosaur> ("knows how they work", btw, actually means "their definitions are specified by the Report so all implementations can safely assume that the definitions are at least compatible with that, and allow type inference to work accordingly")
01:36:50 <geekosaur> for user defined classes, it's rather difficult for the typeclass to not be an impassable brick wall to type inference
01:39:49 <Geraldus_> merijn: oh, that's so simple?  So, all I need to do is to add my email to in cabal file?
01:41:25 <merijn> Geraldus_: No. The hackage website lets maintainers add other maintainers
01:41:41 <merijn> Geraldus_: You can't do anything. Only one of the current maintainers can do it
01:41:42 <Geraldus_> Ahh, let me see
01:43:16 <Geraldus_> Thank you!
02:52:49 <pavonia> Is there a typeclass for parametrised values with an empty element that allows for checking if a value is that empty element?
02:53:14 <ph88_> hi guys, i found a couple of diff libraries to diff two data structures. But i'm not sure which one to use, anyone knows?
02:53:28 <ph88_> https://hackage.haskell.org/package/gdiff-1.1/docs/Data-Generic-Diff.html
02:53:30 <Insanity_> Any recommendations for a mysql library? Mysql-Simple? 
02:53:36 <ph88_> https://hackage.haskell.org/package/HUnit-Diff
02:53:46 <ph88_> https://hackage.haskell.org/package/gdiff-ig
02:53:54 <ph88_> https://hackage.haskell.org/package/debug-diff
02:54:32 <sbrg> Insanity_: I'd use persistent and esqueleto(sp?) personally
02:55:36 <Insanity_> Cheers, I'll check them out
03:17:35 * hackagebot do-list 1.0.1 - Do notation for free  https://hackage.haskell.org/package/do-list-1.0.1 (TarasSerduke)
03:19:10 <Aleksejs> Hi, can there be a Haskell program with other constructor than IO?
03:19:42 <Aleksejs> for main function I mean
03:19:42 <hpc> do you mean can you give main a type that isn't IO a?
03:19:47 <Aleksejs> yes
03:19:54 <hpc> no
03:21:12 <hpc> " The value of the program is the value of the identifier main in module Main, which must be a computation of type IO t for some type t (see Chapter 7). When the program is executed, the computation main is performed, and its result (of type t) is discarded."
03:21:16 <hpc> https://www.haskell.org/onlinereport/modules.html
03:21:51 <hpc> Aleksejs: btw, it's easy to get in the habit of calling main a function from other languages, but in haskell it is not the case
03:22:06 <hpc> Aleksejs: in haskell, the only values that are functions are the ones with a type that has (->) at its root
03:23:29 <hpc> generally things with IO or something similar at their root will be called "actions", or some other similar word
03:25:24 <hpc> (just something to be aware of so you aren't confused by other discussion that happens here)
04:17:37 * hackagebot vector-split 1.0.0.0 - Initial project template from stack  https://hackage.haskell.org/package/vector-split-1.0.0.0 (fho)
04:17:39 * hackagebot machines-process 0.2.0.7 - Process (system) utilities for the machines library  https://hackage.haskell.org/package/machines-process-0.2.0.7 (aloiscochard)
04:17:41 * hackagebot french-cards 0.1.1 - French Playing Cards  https://hackage.haskell.org/package/french-cards-0.1.1 (TarasSerduke)
04:17:43 * hackagebot http-pony-serve-wai 0.1.0.0 - Serve a WAI application with http-pony  https://hackage.haskell.org/package/http-pony-serve-wai-0.1.0.0 (JinjingWang)
04:20:33 <iphy> hi, I want to cross-compile a program that uses happy, but cabal tries to cross-compile happy and then tries to run that cross-compiled happy, which doesn't work because it's for the host, not the build platform
04:21:06 <iphy> I tried installing happy with the build platform's cabal, but then the host cabal can't find it and tries to build another one itself
04:34:14 <iphy> I now solve this by installing the host happy (cross-compiled) first, then installing a build happy, and then copying the build happy binary over the host happy binary
04:40:51 <srk> is there a way to cleanly achieve what acid state does (sending update messages and queriying state) but without keeping actual log or journal. I'm only interested in last state
04:41:29 <merijn> srk: The log *is* what acid-state does...I'm not quite sure what'd be left if you took that away...
04:41:42 <srk> indeed
04:41:52 <srk> now I have channel that threads send updates to
04:42:08 <srk> which I'm now changing to also keep state of things for queries by other threads
04:42:40 <srk> seems quite common but I've never heard of such thingie
04:42:58 <merijn> I still have no idea what you're trying to do
04:43:51 <M2tias> merijn: do you listen to Marijn?
04:44:30 <merijn> M2tias: I don't understand the question?
04:44:57 <M2tias> I'm listening to an album by Machinefabriek called Marijn
04:46:01 <jmcarthur> srk: Is it just that you want aci-state instead of acid-state?
04:46:30 <srk> jmcarthur: heh, I think so
04:46:38 <merijn> M2tias: Never heard of them
04:47:01 <M2tias> :D
04:47:04 <srk> I have a client / server arhitecture and server is runing commands on behalf of clients and needs to keep a global state based on updates of long running commands
04:47:12 <jmcarthur> srk: Do you have requirements that would make a simple MVar not work?
04:48:01 <bartavelle> srk, or even something like the mvc package ?
04:49:29 <swaraj> Hi everyone - is there a more up to date version of the "GHC as a library" article? (https://wiki.haskell.org/GHC/As_a_library)
04:49:42 <swaraj> I wanted to use GHC's parsing features, but can't see where they are
04:49:42 <srk> jmcarthur: dropped MVar in favor of TChan due to locking concerns
04:50:42 <jmcarthur> locking concerns?
04:51:02 <srk> if there are too many threads trying to write to a MVar
04:51:30 <srk> jmcarthur: based on this http://chimera.labs.oreilly.com/books/1230000000929/ch07.html#sec_conc-logger
04:51:44 <jmcarthur> A TChan doesn't have the ACI semantics it sounded like you are after. I guess that's the problem? You want something more concurrent than MVar but TChan kills your consistency?
04:51:48 <merijn> srk: That sounds like a case where TChan would be worse than MVar
04:52:54 <jmcarthur> Actually I think I just don't understand how the TChan is being used.
04:52:58 <srk> jmcarthur: I'm more interested in saving on updating global state myself
04:53:18 <srk> not doing it manually when message comes
04:53:33 <jmcarthur> I'm usually confused when people switch from MVars to channels of any sort without intended to change semantics. Maybe there is some technique using channels I don't know.
04:54:25 <jmcarthur> What do you mean by saving? I thought you *didn't* want it to save persistently.
04:54:48 <srk> based my code on this https://github.com/tattsun/conlogger/blob/master/src/Control/Concurrent/ConLogger.hs
04:55:25 <srk> jmcarthur: istead of using state monad I now have messages that are used to update the state in runner 
04:59:03 <srk> I think I can just use acid-state and don't care about database much 
04:59:43 * merijn gets out his "acid-state is not a database" mantra
05:00:07 <srk> :)
05:00:45 <hpc> it's closer to a database than sqlite though :P
05:01:38 <merijn> hpc: No it's not
05:01:53 <merijn> SQLite *is* a database
05:02:10 <jmcarthur> hpc 'bout to get schooled
05:02:21 <srk> :D
05:02:39 <merijn> hpc: A database would require 1) a schema of the data stored and 2) language agnostic querying
05:02:52 <merijn> and possibly 3) constraints on the data within the schema
05:03:33 <merijn> 4th optional requirement: Ability to deal with large datasets (perhaps not a defining feature, but something I'd demand of a proper database)
05:03:52 <hpc> acid-state has 1 and 3, and i could argue 2 isn't valid unless you consider sql not a language in itself
05:04:01 <merijn> SQLite has all 4, acid-state fails everything except maybe 3
05:04:12 <jmcarthur> I'm curious why (2) is a requirement.
05:04:34 <jmcarthur> And how it is true of SQL databases.
05:04:38 <srk> what is considered a large dataset?
05:04:39 <rubystallion> I'm curious how floating point numbers work in haskell. Why is 8/3=2.6...67 when using Float, but =2.6...65 when using Double?
05:04:46 <hpc> the schema and constraints are the type being stored and the operations on that type
05:04:51 <merijn> jmcarthur: I'm not sure how to formulate my feeling on 2
05:04:58 <hpc> it definitely fails #4 but so does sqlite
05:05:06 <iphy> Has anyone here tried to cross compile Haskell code to arm?
05:05:19 <merijn> hpc: They do not exist independently of the specific compiled instances in your executable for acid-state
05:05:25 <Ke> iphy: you mean cross-compile?
05:05:26 <Insanity_> rubystallion: float is single precision, double is .. double precision. 
05:05:31 <iphy> Yes
05:05:34 <merijn> hpc: I cannot determine the schema of acid-state by inspecting it
05:05:37 <hpc> in databases, "large" is considered to mean above tens of gigs at the very least
05:05:41 <Insanity_> the difference in precision could explain the difference there ;-)
05:05:44 <Ke> iphy: nvm you said that, somehow missed that word
05:05:51 <merijn> hpc: SQLite can handle billions of entries just fine
05:06:03 <merijn> hpc: I would expect acid-state to crash and burn in the low 10,000s
05:06:07 <jmcarthur> rubystallion: https://en.wikipedia.org/wiki/IEEE_754-1985
05:06:25 <merijn> Maybe 100k entries, I've not benchmarked it, but that would surprise me, tbh
05:06:32 <srk> how big is hackages's acid-state db?
05:06:36 <iphy> I'm getting unsupported elf machine number 0 errors from LD
05:06:38 <srk> and how much memory does it need?
05:06:39 <jmcarthur> rubystallion: We are not still on the 1985 standard, but the single and double precision specs are still valid.
05:07:17 <merijn> hpc: SQLite can certainly deal with datasets several orders of magnitude bigger than acid-state
05:07:18 <rubystallion> jmcarthur: OK, thanks!
05:07:38 <iphy> When linking executables
05:07:39 <hpc> sure, but not enough orders to consider it meeting #4 imo
05:08:13 <jmcarthur> srk: It depends how much data you throw into it. The in-memory state should just be the size of your state. The log could be linear in the total size of all transactions, but it can be shrunk down to the size of the state occasionally.
05:08:15 <hpc> even mysql, the laughingstock of other rdbms', can support distributed databases in the terabyte range
05:08:50 <merijn> hpc: It's more than enough to cover, say, 80% of usecases
05:08:59 <jmcarthur> merijn: I don't see any particular reason acid-state would fail on large data sets. It all comes down to what in-memory representation you choose for it.
05:09:10 <hpc> 80% of that 80% is firefox's config backend :P
05:09:28 <merijn> hpc: You'd be surprised how much stuff uses sqlite
05:09:29 <srk> jmcarthur: so historical queries are fetched from disk?
05:09:39 <merijn> hpc: And how surprisingly well-tested and robust it is
05:09:39 <jmcarthur> srk: There is no such thing as a historical query.
05:09:44 <iphy> The .o files in the .a files produced by cabal show "no machine" when I use file(1)
05:09:50 <jmcarthur> srk: It's a transaction log.
05:10:07 <merijn> jmcarthur: The usualy "acid-state as a database" approach uses an IntMap
05:10:17 <srk> ah
05:10:19 <jmcarthur> srk: Its purpose is to be fast enough to now slow down normal usage while allowing you to reply changes you haven't snapshotted yet when you restart the process.
05:10:30 <iphy> It seems the object files are somehow damaged
05:10:32 <merijn> jmcarthur: Or multiple, but that doesn't scale to reasonable query speeds
05:10:32 <hpc> merijn: if you want to emulate a relational database perhaps
05:10:56 <iphy> It works when I cross compile for x86 android but not for arm
05:11:12 <merijn> hpc: So what kinda database would acid-state compete with instead, in your opinion?
05:11:43 <hpc> a non-relational database that stores algebraic data
05:12:18 <hpc> it's not necessarily a good one, but it meets acid and you can generally consider your data safe in it
05:12:32 <merijn> Don't get me wrong, I *like* acid-state
05:12:38 <hpc> same
05:12:48 <hpc> the way i see it, "database" just means it meets acid
05:12:54 <merijn> But it's no good at 80-90% of the usecases people ahve in mind when they say "database"
05:13:10 <merijn> hpc: No, I've seen people try to store relational/indexed data in acid-state before...
05:13:14 <hpc> merijn: 90% of people think "database" means "relational" :P
05:13:24 <merijn> The sorta stuff SQLite would be perfectly suited to store...
05:13:48 <hpc> acid-state does make a crap relational database
05:13:52 <merijn> I prefer marketing acid-state as "persistent heap data with acid guarantees"
05:13:54 <jmcarthur> I kinda wish 100% of people would think databases were relational so we would stop arguing over what a database is. :)
05:14:13 <hpc> Map isn't suitable for it, and ixset is a bit weird
05:14:15 <jmcarthur> "Is MongoDB really a DB?"
05:14:17 <merijn> jmcarthur: Naah, key-value stores like BerkelyDB are acceptable database too!
05:14:33 <merijn> jmcarthur: MongoDB is an inefficient /dev/null :)
05:14:43 <jmcarthur> :)
05:14:50 <jmcarthur> Is /dev/null a database?
05:15:00 <merijn> jmcarthur: It's a service!
05:15:02 <hpc> if it doesn't meet acid, i would consider it a data store (or something more specific like key-value store for redis)
05:15:13 <merijn> jmcarthur: https://devnull-as-a-service.com/
05:15:15 <bartavelle> it has distributed strict consistency
05:15:18 <hpc> daemonized /dev/null
05:15:29 <jmcarthur> I do believe /dev/null satisfies all four requirements.
05:15:41 <hpc> hah
05:15:46 <hpc> the schema is ""
05:17:21 <hpc> but yeah, all that's totally my opinion in any event
05:17:32 <hpc> i just consider acid useful enough on its own to merit being the definition of database
05:17:38 * hackagebot machines-process 0.2.0.8 - Process (system) utilities for the machines library  https://hackage.haskell.org/package/machines-process-0.2.0.8 (aloiscochard)
05:17:40 * hackagebot result 0.2.5.1 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.2.5.1 (srijs)
05:17:41 <hpc> and it largely fits with how it's currently used
05:17:42 * hackagebot language-cil 0.3.1 - Manipulating Common Intermediate Language AST  https://hackage.haskell.org/package/language-cil-0.3.1 (TomLokhorst)
05:17:44 * hackagebot language-cil 0.4.0 - Manipulating Common Intermediate Language AST  https://hackage.haskell.org/package/language-cil-0.4.0 (TomLokhorst)
05:24:58 <rmrfroot> Is there something like Backus-Naur-Form which can be used to define a grammar that you can somehow validate? I'm using attoparsec to parse a simple plain text language right now, but I would like to create some sort of formal definition of the language that I also can use some kind of "proof assistant" on. Sorry if the question is vague, it's just that I have a very vague idea of what I want to do :P
05:25:35 <Cale> Well, attoparsec won't do that for you...
05:26:19 <Cale> But one could imagine writing a parser combinator library which could also produce descriptions of the parsers. It couldn't support the Monad operations though, since the right hand argument to every (>>=) is effectively a black box
05:27:01 <Cale> I believe at one point there was (at least a proof of concept) Arrow-style parsing library which could describe what the parsers you constructed expected as input.
05:28:03 <Cale> That was a *long* time ago I remember seeing that though...
05:28:20 <rmrfroot> Cale: Yeah, that much I understand :D Ah, alright! Could Coq be something to look at? 
05:29:03 <Cale> http://hackage.haskell.org/package/PArrows -- perhaps it was this.
05:29:23 <Cale> Coq is a dependently typed programming language and proof assistant.
05:30:05 <Cale> You should probably look into both Coq and Agda if you're interested in such things
05:30:13 <rmrfroot> Cale: Ah, ok! I just had a vague memory that some people have used Coq to define grammars and such
05:31:01 <Cale> Trying to prove things about grammars in Coq is perhaps not the easiest way to start out, but it should be possible :)
05:34:30 <rmrfroot> Cale: Hehe ok! Well, thanks for the advice. Have started trying to learn more about the math/format side of Haskell, hence all my vague/abstract questions :P
05:34:40 <rmrfroot> formal*
05:37:56 <funfun> ls
05:38:52 <funfun> ^-- sorry, wrong terminal. :(
05:39:14 <rmrfroot> funfun: erc user? ^^
05:39:22 <joe9> HOTT seems pretty cool.
05:42:23 <swaraj> I want to use GHC to parse Haskell code, but it doesn't look like the parsing feature is present in the latest version of GHC (or at least hasn't been documented) - is there anything I can check out to get this to work?
05:42:43 <swaraj> (i.e., I want to "use GHC as a library")
05:42:47 <merijn> swaraj: Parse it into what?
05:42:52 <jonored> Cale: Is applicative enough?
05:43:05 <jonored> (for self-describing parsers, I mean.)
05:43:27 <Cale> jonored: Should do.
05:43:48 <swaraj> merijn: parse it into some internal Haskell type, I guess
05:44:29 <swaraj> merijn: have you ever used the ghc library to do that? 
05:45:20 <merijn> swaraj: No, but hdevtools (and presumably ghc-mod) do, so maybe look at their code
05:45:30 <jonored> So there's even ApplicativeDo, at least.
05:45:33 <swaraj> https://wiki.haskell.org/GHC/As_a_library -- this is the article I'm talking about, but it seems outdated
05:46:30 <swaraj> merijn: thanks, I'll look into those. would you happen to know why ghc as a library got deprecated?
05:46:32 <ongy> swaraj: have you seen https://hackage.haskell.org/package/haskell-src-1.0.2.0/docs/Language-Haskell-Parser.html
05:46:37 <merijn> swaraj: It's not
05:46:43 <merijn> swaraj: What makes you say it is
05:46:55 <merijn> ongy: That's not GHC and not 100% compatible
05:47:06 <swaraj> merijn: it doesn't seem to be supported for newer versions of ghc
05:47:21 <merijn> swaraj: What does "doesn't seem to be supported" mean?
05:47:27 <ongy> merijn: It might be better for what swaraj wants to do though
05:47:39 <merijn> swaraj: GHC itself is implemented as a wrapper around GHC-the-library, so that wouldn't make sense
05:48:26 <ongy> swaraj: the documentation can be a bit tricky to find, but there's haddock for current https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/ghc-8.0.1/GHC.html
05:49:38 <swaraj> ongy: thanks, those links seem helpful - ideally I'd like to be able to parse source code describing gadts so that I can manipulate their structure
05:50:51 <ongy> from what I have seen Language.Haskell might be the better fit for this. But I do not know how complete it is and merijn has pointed out that it isn't 100%
05:51:01 <rmrfroot> Are there any other examples of an injective function besides a perfect hashing function?
05:51:18 <swaraj> merijn: I'm not actually sure what I mean by "doesn't seem to be supported"... I saw that there was GHC.Parser or something like that but it only works for version 6.something and below
05:52:20 <lyxia> rmrfroot: (+1)
05:53:51 <swaraj> lyxia: for a second I thought you were bumping rmrfroot's post :P
05:54:20 <rmrfroot> Hehe, one internet point more for me
05:54:51 <jonored> rmrfroot: Lots, basically, it's not a high bar to cross.
05:56:19 <jonored> (,) Nothing, id, every lossless compression algorithm...
05:57:27 <rmrfroot> Do you talk about injection in functions with more than 1 argument? Or is that only for (A -> A) functions?
05:58:03 <swaraj> jonored: don't you mean Just, and not Nothing?
05:58:25 <jonored> swaraj: That was ((,) Nothing) - Just is by itself, though.
05:58:41 <swaraj> ah, my bad
06:00:13 <lyxia> rmrfroot: functions with multiple arguments can be seen as functions with one argument which is a tuple
06:00:26 <lyxia> or by currying as a function returning a function
06:00:55 <lyxia> in both cases you can still talk about injectivity
06:02:49 <jonored> What you get from that injectivity is different in those cases, though. const is injective when viewed curried but not when viewed as a function on a tuple.
06:02:57 <rmrfroot> lyxia: ah, alright! 
06:05:07 <rmrfroot> When reading about injectivity I tried to work out if + was injective or not. And my conclusion was that it was not injective since you could get the same result with different arguments. Is that the wrong way to think about it?
06:05:52 <lyxia> You got the right idea.
06:07:38 <rmrfroot> lyxia: Awesome! Sometimes it feels like I get more confused the more I read about abstract algebra, category theory and stuff like that :P
06:07:55 <dememorized> lyxia, rmrfroot: Wouldn't reverse be injective?
06:08:28 <lyxia> dememorized: it is
06:08:58 <lyxia> in a bottomless world at least
06:09:12 <jonored> Oh, that's sort of neat: both steps of + when viewed curried /are/ injective, but the net result is definitely not.
06:12:10 <rmrfroot> jonored: yeah, that's is neat! 
06:17:39 * hackagebot streaming-commons 0.1.16 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.16 (MichaelSnoyman)
06:17:41 * hackagebot machines-binary 0.3.0.3 - Binary utilities for the machines library  https://hackage.haskell.org/package/machines-binary-0.3.0.3 (aloiscochard)
06:20:00 <jeltsch> dememorized: For reverse to be injective, you need to throw away both ⊥ and infinite lists. So in Agda, reverse on lists would be injective; in Haskell, it is not.
06:21:15 <jeltsch> dememorized: reverse (False : ⊥) ≡ reverse (True : ⊥) ≡ ⊥; reverse (repeat False) ≡ reverse (repeat True) ≡ ⊥
06:30:16 <dememorized> jeltsch: Oh, edge cases :)
06:39:55 <joe9> Cale, data structure: http://bpaste.net/show/d1c7126c109c usage,  http://bpaste.net/show/280af16948ea . I cannot shake the feeling that this is what FRP is about.  this is how I am using the Drawable http://bpaste.net/show/490be5f7af1a . I do not understand FRP. just want to check if it fits the FRP model.
06:42:27 <Gurkenglas> Huh, reverse is stricter than necessary
06:45:06 <Strikingwolf> joe9: Just a quick comment on that code paste you made, you have a function to `IO (IO ())` in one of your data structures, which can be reduced to `IO ()` because of `join`
06:46:48 <haskell339> hello
06:47:10 <lyxia> Gurkenglas: how so
06:48:27 <Gurkenglas> rev (x:xs) a is never empty, so you could factor out the (:) and then people could evaluate the spine of reverse's result streamingly
06:48:50 <Cale> joe9: This looks like ordinary OOP to me, rather than FRP
06:49:22 <Cale> joe9: What's a Behavior or an Event here?
06:52:04 <[k-> /topic FRP: A week and counting!
06:53:24 <[k-> //topic FRP: A week and counting!
06:54:48 <siwica`> I am trying to understand a seemingly simple Applicative Functor Example: '(+) <$> (+3) <*> (*100)'
06:55:06 <lingxiao> hey all
06:55:42 <lyxia> siwica`: what are you having trouble with
06:56:04 <lyxia> @unpl (+) <$> (+3) <*> (*100)
06:56:04 <lambdabot> (((+) <$> \ a0 -> a0 + 3) <*> \ a0 -> a0 * 100)
06:56:08 <lyxia> uh
06:56:50 <siwica`> At first '(+) <$> (+3)' should give me something like '+ x (\a -> a + 3)', right?
06:57:50 <lyxia> Gurkenglas: So reverse (_|_ : _|_) is (_|_ : _|_) ?
06:58:15 <lyxia> I'll have to think more about this to know if I like it or not.
06:59:16 <bartavelle> siwica`, '(+) <$> (+3)' is '\x y -> (x + 3) + y
07:00:29 <siwica`> ok, understood!
07:00:30 <bartavelle> siwica`, however, (+) <$> (+3) <*> (*100) is \x -> (x + 3) + (x * 100)
07:01:04 <bartavelle> you can check this by replacing the operators with their definitions for the ( (->) a ) applicative
07:01:10 <siwica`> I just want to do it step by step
07:02:18 <Gurkenglas> http://lpaste.net/203647 hmm this is only the topmost vertebra, which makes "null $ reverseLazy [1..]" work, lets see if I can make it work for arbitrary n in "null $ drop n $ reverseLazy [1..]"
07:03:17 <bartavelle> siwica`, you need to know about the applicative definition (http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-641) and the functor one (http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-638)
07:06:12 <siwica`> bartavelle: I understand the <$> definition, which is just function composition
07:06:44 <siwica`> But I am having trouble understanding the <*> definition '(<*>) f g x = f x (g x)'
07:06:45 <siwica`> )
07:07:28 <bartavelle> > ((+) <*> (*100)) 3
07:07:31 <lambdabot>  303
07:07:52 <bartavelle> > (+) 3 ( (*100) 3 )
07:07:55 <lambdabot>  303
07:08:03 <bartavelle> > 3 + 3*100
07:08:06 <lambdabot>  303
07:08:47 <bartavelle> siwica`, perhaps something that isn't obvious is that   "a <$> b <*> c"  is "(a <$> b) <*> c"
07:09:28 <bartavelle> and for this instance, (<*>) :: (a -> a -> b) -> (a -> a) -> a -> b
07:13:36 <mannny> is there a Monad super class that defines monad unwrapper method.. like fromLeft or unsafePerformIO
07:13:36 <mannny> supserset*
07:13:36 <lyxia> bleh, a typeclass of partial/unsafe functions
07:13:52 <bartavelle> mannny, that would be fromRight
07:13:53 <mannny> yeah
07:14:28 <bartavelle> "m a -> a" is from comonad when it's not partial though
07:14:36 <bartavelle> it's "extract"
07:14:59 <jonored> class (Monad a) => PleaseRuinEverything a where ...
07:15:08 <mannny> :t extract
07:15:10 <lambdabot> error:
07:15:10 <lambdabot>     • Variable not in scope: extract
07:15:10 <lambdabot>     • Perhaps you meant ‘bextract’ (line 198)
07:15:56 <bartavelle> :info Comonad
07:16:03 <bartavelle> :(
07:16:30 <bartavelle> https://www.stackage.org/haddock/lts-7.0/comonad-5/Control-Comonad.html#v:extract
07:16:42 <bartavelle> I just realized now that they use w for upside-down m !
07:17:04 <lyxia> mannny: are you really using a Monad™
07:17:05 <mannny> Comonad is extractable Monad?
07:17:34 <lyxia> or is it just a type * -> * that you call monad for lack of a better name
07:17:41 * hackagebot conduit-extra 1.1.13.3 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.13.3 (MichaelSnoyman)
07:17:43 * hackagebot jukebox 0.2.9 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.2.9 (NickSmallbone)
07:17:43 <mannny> lyxia?
07:18:16 <Cale> class Comonad ɯ where ...
07:18:27 <bartavelle> :)
07:19:18 <bartavelle> class pɐuoW ɯ where !
07:19:43 <bartavelle> mannny, no it's not an extractable Monad, some monads are also comonads, but it's not a rule
07:27:14 <lyxia> mannny: there is no general Monad m => m a -> a function
07:27:20 <lyxia> mannny: how would you extract from a Proxy
07:28:36 <mannny> it wouldn't have to be a general function, when it is not part of monad class
07:30:22 <lyxia> Comonads have such a function, it's just another class.
07:30:50 <lyxia> mannny: I'm wondering what this has to do with monads.
07:32:04 <siwica`> bartavelle: Sorry, I had to go afk.
07:32:33 <siwica`> The thing I dont understand is the meaning of the definition '(<*>) f g x = f x (g x)'
07:32:40 <mannny> lyxia that class would be a monad superset
07:32:53 <mannny> it would support every monadic operation, + extract
07:32:57 <bartavelle> siwica`, do you understand its type ?
07:33:29 <siwica`> I understand Applicative Functors in general
07:33:41 <siwica`> (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:33:42 <siwica`>  
07:34:29 <siwica`> So f refers to the Functor (->), g to (a -> b) and x to b?
07:34:43 <bartavelle> siwica`, there is a new (I think) feature on hackage, look at http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Applicative
07:34:55 <bartavelle> and "expand" the definition for ((->) a)
07:34:57 <amalloy> siwica`: the functor is not (->), but ((->) a)
07:35:21 <amalloy> or well, ((->) r), for some r that is not the same as the a or the b in the type of (<*>)
07:35:30 <bartavelle> siwica`, this will give you the types specialized for the particular instance
07:35:43 <sbrg> bartavelle: aaah that's cool
07:36:02 <bartavelle> yes, I think so!
07:37:06 <rui> Anyone uses nixos and ihaskell on jupyter? If so, any examples on how to set it up, choose packages it can see, etc?
07:37:32 <siwica`> So the pattern matching would be: f = ((->) r), g = (a -> b) and x = a?
07:39:20 <bartavelle> siwica`, why ?!?
07:39:29 <bartavelle> (<*>) :: (a -> a -> b) -> (a -> a) -> a -> b
07:39:46 <bartavelle> f <*> g  implies (f :: a -> a -> b) and (g :: a -> a)
07:39:57 <amalloy> in the definition of (<*>) for functions, f x (g x), the types are: f :: r -> a -> b, g :: r -> a, x :: r
07:40:05 <bartavelle> well, I'm sure "implies" isn't the right word here
07:46:02 <siwica`> amalloy: Ok, I got it
07:46:02 <siwica`> Sorry for being so stupid ;)
07:46:02 <siwica`> It's hard to wrap your head around when not too familiar with Haskell
07:46:02 <bartavelle> siwica`, it is!
07:52:43 <siwica`> b
07:53:18 <ph88_> Does anyone know how these diff packages compare? https://paste.fedoraproject.org/431017/42967491/  i want to diff two data structures (of the same type)
08:32:37 <bs0d> Hello
08:33:07 <bs0d> I am looking for some help with convex optimization problem. Maybe I am in the wrong channel, but could anyone help me?
08:34:27 <sbrg> Well, this is #haskell, which is for help with the Haskell programming language. That said, I'm sure there are plenty of people here that wouldn't mind helping you out, but #haskell-blah may be a more appropriate place for that
08:37:59 <siwica`> Is there a reason that (->) is not in Eq?
08:44:23 <ClaudiusMaximus> siwica`: i guess practically it's very hard to handle potentially infinite input values (eg lists) if you were to try to do something like  instance (Enumerable a, Eq a, Eq b) => Eq (a -> b)   which would also be woefully inefficient for most interesting 'a' types (thinking "compare output at every input value")
08:45:40 <ClaudiusMaximus> siwica`: having said that, in my 'bitwise' library I do do case analysis over Bool -> Bool and Bool -> Bool -> Bool to lift them to bitwise operations, ultimately to accelerate bitpacked array operations
08:57:19 <ertes> siwica`: be more precise
08:57:19 <ertes> instance Eq (a -> b)  -- if you're looking for function equality, this one is impossible
08:58:55 <lambdabot> Hello.
08:59:02 <ph88_> Does anyone know how these diff packages compare? https://paste.fedoraproject.org/431017/42967491/  i want to diff two data structures (of the same type)
09:05:01 <johnw> ph88_: you could try 'these', and the Alignable type class
09:22:54 <felko> i'm having trouble defining the monad instance of a failable state (basically data FailableState e s a = State (s -> (a, s)) | Failed e)
09:23:50 <johnw> why not use StateT s (Either e) a?
09:24:05 <felko> johnw: because it is exercise
09:24:10 <johnw> ah, good
09:24:10 <benzrf> felko: imo it would make more sense to do `data FailableState e s a = State (s -> Either e (a, s))'
09:24:13 <johnw> can you show me the error?
09:26:09 <benzrf> in fact i think what you have right now might not even be a monad - not sure
09:26:09 <felko> it seems that i'm facing a "meta data" problem, the thing that forces you to define an arrow and not a monad
09:26:09 <johnw> I'm not familiar with you said, can you explain?
09:26:09 <benzrf> felko: if i did `join $ State (\s -> Failed "error!")'
09:26:09 <felko> johnw: i'm pasting something, you'll understand
09:26:09 <benzrf> what should that result in?
09:26:09 <benzrf> er, that should be -
09:26:09 <benzrf> felko: if i did `join $ State (\s -> (Failed "error!", ()))'
09:28:28 <felko> benzrf: exactly, this is the problem i'm facing
09:28:28 <benzrf> felko: well, it's possible that your type is just not a monad
09:28:28 <felko> benzrf: but i want it to be a monad 
09:28:28 <johnw> the paste should make everything clear
09:28:28 <benzrf> that doesn't mean it is one
09:28:28 <johnw> let's not debate in the abstract
09:28:28 <benzrf> oh, hold on
09:28:28 <benzrf> felko: when i say it's possible that "your type is just not a monad", i mean that it's possible that there is no monad instance you can write which is law-abiding
09:28:28 <benzrf> not all types can be given monad instances - some just don't have them
09:28:28 <benzrf> i am not sure whether this is one like that
09:28:38 <lpaste> felko revised “No title”: “No title” at http://lpaste.net/203891
09:28:48 <felko> benzrf: johnw here
09:28:52 <johnw> just continue the error there
09:29:04 <johnw> you'll need to use a different constructor from State in your definition
09:29:04 <johnw> one sec
09:29:55 <felko> benzrf: i know but in my small project i have to use a monad
09:30:18 <johnw> oh, never mind, this is not a monad
09:30:33 <johnw> exactly for the reason benzrf allude to
09:30:45 <benzrf> @djinn Either e (s -> (Either e (s -> (a, s)), s)) -> Either e (s -> (a, s))
09:30:45 <lambdabot> -- f cannot be realized.
09:30:53 <benzrf> felko: see, there's no total function of that type
09:31:08 <benzrf> (which is equivalent to the type of `join' for your FailableState)
09:31:26 <felko> i faced this problem several times and many people told me that this problem could be solved by making an Arrow instance rather than a Monad
09:31:37 <benzrf> that doesn't sound true
09:31:38 <johnw> you need a state variable to continue your computation, but if there's been a Failed event, there is no such state variable
09:31:44 <benzrf> if they mean an instance for Kleisli
09:32:25 <felko> benzrf: no, like, changing the data to data FailableState e s a b = ...
09:32:29 <benzrf> oh
09:32:39 <felko> and then making an arrow instance
09:33:14 <benzrf> felko: why don't you use (s -> Either e (a, s)) instead
09:33:23 <felko> `data FailableState e s a b = State (a -> (b, s)) | Failed e` i suppose
09:33:42 <johnw> felko: I don't know what their suggestion to "make an Arrow instance" has to do with this
09:33:53 <felko> benzrf: well thats an option but arrows are cool too
09:34:20 <felko> johnw: because for some reason it allows us to abstract meta data (here, the ma)
09:34:29 <felko> *the meta data is the state
09:34:43 <johnw> yeah, I don't see what that means here
09:34:46 <benzrf> do you mean (s, a) -> (b, s) up there
09:34:51 <johnw> "abstract the metadata"
09:34:58 <benzrf> that's not a very useful arrow
09:35:03 <benzrf> you can't fail as a result of an input
09:35:13 <benzrf> you have to have a failure that's statically known before doing anything stateful
09:35:28 <felko> benzrf: why (s, a) -> (b, s) ?
09:35:42 <benzrf> i just mean instead of a -> (b, s)
09:35:49 <benzrf> should probably said (a, s) -> (b, s)
09:35:57 <felko> oh yes ok i think i know why
09:36:00 <felko> thanks
09:36:05 <benzrf> felko: this is not the Arrow you want
09:36:09 <benzrf> 12:36:00          benzrf │ you can't fail as a result of an input
09:36:11 <benzrf> 12:36:10          benzrf │ you have to have a failure that's statically known before doing anything stateful
09:37:01 <felko> benzrf: in my project (a mini bank managing program), i need that because the password of the account can be wrong (for example)
09:37:19 <felko> johnw: i'm not really familiar with arrows yet so i can't explain, sorry
09:38:22 <benzrf> felko: do you understand what i mean by that, though?
09:38:32 <benzrf> if i'm not explaining it well, please tell me so
09:40:06 <benzrf> i'm not trying to just beat you over the head with words - i want you to see my point, so that you can decide whether it's right
09:40:09 <felko> benzrf: im not sure i understand, when you say input you mean the original state ?
09:40:09 <benzrf> more or less, yes
09:40:09 <benzrf> i mean - ok, well, look at your type
09:40:14 <benzrf> a FailableState can be something that uses the state value, or it can be a failure
09:40:29 <benzrf> but it *can't* be something that uses the state value, and then possibly fails as a result
09:40:47 <benzrf> you choose between failure and taking a state - not between returning failure or success after taking the state
09:40:56 <felko> ok i get it
09:40:59 <felko> thanks
09:41:02 <benzrf> oh good :)
09:41:50 <benzrf> ah i have to go
09:41:51 <felko> i guess i'm going to use something like StateT s Either a
09:41:52 <benzrf> good luck
09:42:03 <benzrf> felko: you can still define your own type - it just has to be something slightly different!
09:42:06 <benzrf> later though
09:42:09 <felko> benzrf: thanks for your explanation, bye
10:00:09 <dmj`> can I conditionally define an executable sections via cabal's if-then-else syntax
10:03:02 <sm> dmj`: no, but you can conditionally set buildable: false inside them
10:11:35 <av_> g'evening everyone
10:12:04 <av_> I need some help with these: http://lpaste.net/203953 and http://lpaste.net/203958
10:12:36 <av_> my benchmark is equivalent C code, and I'm trying to optimize the Haskell code for speed as much as I can
10:13:23 <av_> problem: straight Haskell takes 4x as long as simple a straight-forward C to run, so I tried using Repa to get closer to C
10:13:48 <av_> problem #2: with Repa, the code is slower by another factor of 2, about 8x the runtime of C
10:13:50 <av_> what am I doing wrong?
10:14:48 <av_> (as you can see in the Repa code, I already played around with computeS and INLINE, as mentioned in the Repa docs, and even DeepSeq, without any improvement whatsoever)
10:15:04 <dfeuer> :-(. I think I just found a place where I really want to use type families, but I think some people would be very upset about it.
10:15:04 <michi7x7> av_: have you profiled your program?
10:15:09 <av_> (oh, I compile with -O2, and that's the only switch I use for ghc)
10:16:03 <av_> michi7x7: not yet, because profiling such a simple program usually doesn't give me any new insight -- is it worth it?
10:16:34 <michi7x7> av_: maybe
10:17:45 * hackagebot MemoTrie 0.6.7 - Trie-based memo functions  https://hackage.haskell.org/package/MemoTrie-0.6.7 (ConalElliott)
10:19:29 <av_> michi7x7: here we go: http://lpaste.net/203975 -- does that tell us anything?
10:20:13 <joe9> av_: Have you checked out Vector.Unboxed?
10:20:34 <joe9> av_: I found my runtime went from 13 seconds to 30 ms when using that.
10:20:41 <av_> joe9: as a replacement for what? the list?
10:20:53 <joe9> av_: yes.
10:21:21 <av_> joe9: no, but I can try
10:21:46 * av_ is looking up Vector.Unboxed
10:22:00 <lyxia> I don't think linear is meant to be performant
10:22:53 <lyxia> and repa is for paralelism, and I suppose it comes with some overhead as well
10:24:03 <av_> lyxia: Repa claims to achieve very close to C performance, with parallelism as a bonus provided you have multiple cores available, which I haven't in this case (long story)
10:26:39 <mettekou> Can anyone vouch for Haskell with GHCJS for client-side web development in large production apps as an alternative to Elm or PureScript?
10:29:59 <dolio> av_: Your repa code still makes a big list.
10:30:00 <Cale> mettekou: We've been using it quite successfully at Obsidian Systems
10:30:07 <dolio> In fact, it might make more of a list than your original code.
10:30:53 <dolio> Because your original code uses a bunch of fusable functions.
10:30:53 <dolio> But deep-seqing the list will materialize it into memory.
10:30:58 <mettekou> Cale: How is its JavaScript FFI? I need to use D3.js in my app.
10:31:19 <Cale> I can't say anything about D3.js in particular, but the Javascript FFI is really good.
10:31:19 <danza> Cale, you are co-authors. I think that the learning curve is still too steep for most users
10:31:50 <Cale> danza: Well, to a fair extent, I agree with you, there's not enough documentation and tutorials
10:31:51 <infandum> For DuplicateRecordFields, how come the compiler can't automatically figure out the types for everything? It has an explanation of "Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere.", but if that function has a type annotation why wouldn't it work? 
10:32:15 <danza> mettekou, for datavis i recommend Purescript. Their bindings to D3 are the most reasonable i've ever seen
10:32:18 <Cale> danza: But if you talk to the people in #reflex-frp and #ghcjs, there are usually people around willing to help
10:33:08 <danza> yeah it's true but practically i think before picking it one should be confident about the source code of Reflex, at least
10:33:35 <Cale> Oh, you *definitely* should not attempt to understand all the details of how Reflex works internally before trying it.
10:33:45 <Cale> I certainly don't understand them
10:33:59 <Cale> I think the only person who does actually understand it completely is Ryan
10:34:05 <danza> :)
10:34:18 <Cale> It's similar to GHC in that respect
10:34:35 <Cale> If you waited to understand all of GHC before using Haskell, you wouldn't get anywhere.
10:34:53 <danza> probably i went too far
10:35:31 <danza> but i tried to build something on GHCJS and Reflex, and i felt that needed a lot of Haskell experience ... i would currently recommend Purescript
10:36:12 <danza> also, there is a big advantage in using Purescript: it integrates with existing React components
10:36:24 <danza> there are some web widgets you don't really want to rebuild ... and retest
10:38:37 <infandum> Oops, the documentation actually says "However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver."
10:38:37 <ashishnegi> hi.. is there a library to find `extension/kind of file` from a url.. like "http... /abc.css?asdf" would give ".css" .. and "http...abc.com" would give "" ?
10:38:37 <Cale> danza: Yeah, if you don't have someone around to coach you, that's likely to be hard. There have been people whose first Haskell program ever was a reflex-dom web application, but it's not something that you're likely to have a good time at on your own.
10:38:37 <danza> :)
10:38:54 <danza> lucky peps
10:39:09 <Cale> danza: But yeah, if you ever feel like taking another shot at it, hang around in #reflex-frp and bug people there (really, we're happy to help whenever we're around)
10:40:41 <Cale> I've been making lots of little demos for people, and hope to eventually take the best bits from them and turn it into some kind of coherent tutorial
10:40:41 <danza> to be honest, the difficult in integrating with existing components demotivates me a bit
10:40:41 <Cale> http://cale.yi.org/reflex/ -- you can see a bunch of things here
10:40:41 <Cale> I haven't found any specific difficulty in integrating with external JS libraries -- at least, whenever we've needed to do that, it hasn't been a problem so far.
10:40:41 <c_wraith> ashishnegi, you'd want a URL parser for that. you want to look at the end of the path segment for that. 
10:40:57 <danza> Cale, cool i remember the doc about the Javascript foreign interface wasn't very easy, to me
10:41:07 <danza> but i tried many months ago
10:42:01 <ashishnegi> c_wraith: Network.URI has uriPath... that give "http://abc.com/abc.html?a=d" => "/abc.html" .. but i would have to handle many cases :) or use it with `filepath` lib..
10:42:04 <av_> dolio: thanks, but DeepSeq is irrelevant when I use Repa, at least there's no difference in runtime
10:42:18 <Cale> danza: If you see like 3 or 4 examples of someone using it, it's not terribly hard. You can basically take arbitrary snippets of Javascript code and FFI import them, with $1, $2, etc. parameters in the snippet getting filled in with the arguments to the thing you've imported.
10:42:32 <Cale> http://cale.yi.org/reflex/Bootstrap/BootstrapModal.jsexe/ -- there's a trivial example I made for someone here
10:42:39 <Cale> (just today, actually)
10:42:42 <danza> yeah but what when you have a callback?
10:43:10 <danza> anyway, maybe i should just have a look at the whole stack again
10:43:11 <danza> Cale, i was also quite confusing about the different versions of GHCJS ... the way it's handled makes me think still of an experimental tech
10:43:19 <danza> *confused*
10:44:56 <Cale> danza: There's a type JSFun, and some ways of producing values of it, though I haven't actually needed a lot of that, since most event handler binding stuff I use through GHCJS.DOM's interface.
10:45:31 <danza> i mean it's feasible but it's a lot of effort
10:46:25 <ClaudiusMaximus> av_: (still compiling linear to run tests) but i think lazy lists with fusion will be fastest here, as it can run using a tiny amount of memory, instead of allocating a large array to do a small amount of computation with
10:46:25 <Cale> http://stackoverflow.com/questions/19415306/ghcjs-how-do-i-import-a-high-order-javascript-function-using-ffi/19437842#19437842 -- there's a little example here of how to import something which takes a callback
10:46:25 <Cale> (and then wrap things up a bit to make the type a bit nicer)
10:48:35 <danza> Cale, thanks for your availability, i hope that i will have the time to look into that again ... but nowadays it's already difficult enough to bring a client to Purescript ... that's my best tradeoff for now
10:56:12 <av_> ClaudiusMaximus: that's about what my straight-Haskell code is, but as you see, it's a factor off C, which is where Repa claims to be... thus my attempt at using Repa
10:56:20 <ClaudiusMaximus> av_: http://lpaste.net/203953 annotated your paste with an optimized version (twice as fast as the version using linear, on my machine; but has some unaesthetic parts)
10:56:53 <NemesisD> is there such a thing as lifting ADT constructors to the type level? I feel like I've seen some sort of automatic type lifting support in haskell. I'm looking for if i have data Foo = A | B to get a type A and a type B
10:57:11 <NemesisD> and ideally a way to go from the type to the constructor
10:57:27 <av_> ClaudiusMaximus: thanks, will look at it in a moment, have to get away from the keyboard for a short while
10:58:17 <ClaudiusMaximus> NemesisD: -XDataKinds afaik
11:03:56 <NemesisD> lol this is so weird. so data Foo = A | B, data FooTagged (a :: Foo) = FooTagged; fooA :: FooTagged A
11:06:50 <joe9> Is Integer = Int64? I want to use an Integer in Vector.Unboxed value. But, Vector.Unboxed does not have an instance for Integer, just for Int64
11:07:10 <ClaudiusMaximus> Integer is arbitrary precision, so variable size, so can't be unboxed
11:09:47 <joe9> can I represent the seconds time from getPOSIXTime in Int64?
11:10:39 <joe9> I am trying to figure out how to store a time in microseconds in an unboxed vector. Int64 good enough?
11:12:23 <michi7x7> > round<$>Data.Time.Clock.POSIX.getPOSIXTime
11:12:24 <lambdabot>  error:
11:12:24 <lambdabot>      Not in scope: ‘Data.Time.Clock.POSIX.getPOSIXTime’
11:12:24 <lambdabot>      No module named ‘Data.Time.Clock.POSIX’ is imported.
11:12:35 <michi7x7> well, this would give you seconds
11:13:21 <ClaudiusMaximus> > 1970 + floor (fromIntegral (maxBound :: Int64) / (1e6 * 60 * 60 * 24 * 365)) -- joe9, this should be the year you could store microseconds until, unless i messed up somewhere
11:13:23 <lambdabot>  294441
11:13:37 <joe9> michi7x7: I know how to get seconds or milliseconds. I am not sure on how to store in an unboxed vector
11:14:12 <joe9> ClaudiusMaximus: That is way cool.
11:14:59 <ClaudiusMaximus> > (maxBound :: Int64) + 1  -- but note the overflow behaviour...
11:15:01 <lambdabot>  -9223372036854775808
11:15:30 <glguy> The old Y29k problem
11:15:48 <ggVGc> hate that
11:15:49 <glguy> err 294k
11:16:35 <michi7x7> joe9: round.(*1e6)<$>Data.Time.Clock.POSIX.getPOSIXTime :: IO Data.Int.Int64 -- prints 1474308838965070 on my machine
11:16:44 <glguy> You're just creating problems for your grand^9800 children
11:16:50 <michi7x7> and (maxBound :: Data.Int.Int64) `div`  1474308838965070 is over 6000
11:23:07 <joe9> ClaudiusMaximus: Isn't Double variable length too? there is a Vector.Unboxed instance for it though.
11:23:07 <ClaudiusMaximus> joe9: no, Double is 8 bytes
11:23:07 <joe9> ClaudiusMaximus: Thansk.
11:23:07 <joe9> ClaudiusMaximus: Thanks.
11:23:28 <hsk3> When I specify a package on Hackage in "extra-deps" in my stack.yaml, it finds the package.
11:23:28 <hsk3> This is because Stack automatically searches for the package on Hackage, right?
11:23:29 <hsk3> What if the package is not on Hackage but on my own GitHub repo? How do I make stack find the package then?
11:27:16 <srhb> hsk3: https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location
11:29:33 <hsk3> srhb: yeah thanks
11:29:39 <hsk3> nice
11:30:03 <Cale> mettekou, danza: One other thing I wanted to mention but forgot: probably the easiest way to get set up with ghcjs quickly (whether you're using reflex-dom or not) is to use the try-reflex script in the reflex-platform repo which is available here: https://github.com/reflex-frp/reflex-platform
11:30:38 <lgstate> if ghcjs was as easy to use as cljs I'd be soo happy
11:31:02 <av_> ClaudiusMaximus: thanks a lot, I made a version that's only slower than C by about 1.6x, much much better than before, and all I needed to do was to replace Linear...
11:31:03 <mpickering> I second what Cale said
11:31:29 <joe9> need some ideas, please? http://dpaste.com/10BA9WR is my Scale typeclass. http://dpaste.com/1WXX0MS is a datatype using a data type which must belong to the Scale typeclass.
11:31:46 <joe9> Is there a way to represent this without using existential types extension?
11:32:08 <Cale> I don't know how easy cljs is to use, so I can't compare for you, but that script I just mentioned will use the nix package manager to set you up with all the dependencies and such in a very reproducible way, which is also quite useful when you go to production for ensuring that the server machines are running the same software you built locally.
11:32:31 <lgstate> Cale: I think i joined the channel after you posted a link.
11:32:48 <Cale> Ah, I was referring to the try-reflex script in the reflex-platform repo which is available here: https://github.com/reflex-frp/reflex-platform
11:33:15 <Cale> Which regardless of whether or not you choose to use reflex-dom, is probably the quickest and simplest way to get ghcjs set up.
11:34:02 <lgstate> lol; the easiest way to get ghcjs setup is to install a package manager which allows you to pin package envs, then rebuild an entire 'above the kernel layer' using particular packages?
11:34:15 <Cale> Well, it works! :)
11:34:15 <lgstate> I think cljs wins the 'easier to setup' award here :-)
11:34:28 <Cale> There are lighter-weight ways to do it as well
11:34:55 <Cale> It's just nice to know that you're running byte-for-byte the same software in production and testing.
11:35:29 <Cale> and it's certainly much quicker than any method which has you compile ghcjs
11:36:01 <Cale> (assuming you have a reasonable download speed)
11:36:01 <lgstate> is there any realistic plans to have ghcjs integrated into ghc?
11:36:12 <lgstate> it's just a new backend doing stg -> js right?
11:36:15 <lgstate> so why isn't it accepted yet? :-)
11:36:16 <Cale> I don't know, you'd have to ask luite. It's not unreasonable.
11:36:29 <srhb> luite argued against that, i believe. Let me see if I can find it.
11:36:30 <delYsid> newbie here, my 100 day old project fails to build because stream-fusion apparently has problems with ghc8.  What to do?
11:36:44 <srhb> delYsid: More information needed.
11:36:57 <Cale> There are a number of additional dependencies once you get to the libraries required to do anything substantial with it
11:37:14 <lgstate> delYsid: srhb: best if you can github the code and gist-paste the actual build error
11:37:22 <Cale> There's a huge GHCJS.DOM binding library which also has support for webkit-gtk when compiled with plain GHC
11:37:33 <delYsid> srhb: Ambiguous occurrence ‘MonadPlus’, It could refer to either ‘Control.Monad.Stream.MonadPlus’ or ‘GHC.Base.MonadPlus’
11:38:23 <srhb> delYsid: Import only one of them? It has nothing to do with stream fusion.
11:38:24 <Cale> lgstate: and at present, I believe Template Haskell for ghcjs requires spinning up a node.js instance to run the compiled-to-javascript-at-compile-time splices.
11:38:49 <delYsid> srhb: But I'me getting this on cabal install fusion-stream
11:39:00 <lgstate> Cale: I can see the ghc team not being happy with putting webgtk / node.js into haskell platform
11:39:00 <Cale> lgstate: So there's definitely a bunch of additional machinery you're going to want in addition to a standard GHC install, if you actually want to use the thing.
11:39:04 <srhb> delYsid: Then it has become incompatible with GHC.Base including MonadPlus now.
11:39:23 <srhb> delYsid: If it were not exported before, there was no conflict.
11:39:38 <Cale> It might be possible to separate it out and still include the core part of the GHCJS compilation into GHC itself eventually.
11:40:05 <hsk3> In cabal files, is author and maintainer and other fields required?
11:40:07 <srhb> Hm, I can't find luites comment on the merging ghcjs as just another backend. perhaps I imagined it.
11:40:15 <srhb> hsk3: Other fields yes, those two no.
11:40:30 <hsk3> putting an email address there opens things up for spam..
11:41:04 <delYsid> srhb: Yup.  My question is, whom do I let know, and how?
11:41:37 <dmwit> delYsid: Perhaps a Hackage trustee would be able to decrease the upper bound on base for that package.
11:41:51 <srhb> delYsid: You could follow the home page link on the Hackage page, or even fix it and send a patch to the maintainer :)
11:42:02 <dmwit> delYsid: This will not fix your problem, but will cause it to fail fast instead of slow. =)
11:43:25 <delYsid> srhb: Am I on the right track thinking that the fix will probably involve some hiding directive?
11:43:34 <srhb> delYsid: Yes, if that's the only issue. :)
11:43:55 <delYsid> ok, let me play a bit, thanks.
11:44:09 <srhb> delYsid: You can cabal unpack packagename - if you didn't know
11:47:35 <hsfor> I want to precompute a Data.Map and keep it around as a lookup table; anyone have advice on how to do that?  Will a global no-argument foo :: Data.Map equation do that?
11:48:34 <dmwit> hsfor: It will, if `foo`'s type is not typeclass-polymorphic.
11:48:42 <kadoban> hsfor: That should do the trick, yeah if it's monomorphic.
11:49:06 <hsfor> awesome thanks
11:49:08 <dmwit> `Control.Concurrent.Async.async` lets us start an `IO` action and ask for its result later.
11:49:24 <dmwit> Is there something similar which will wait until the result is requested to start the `IO` action?
11:49:25 <hsk3> Should I worry about exposing an email address in a cabal file? It could lead to spam.
11:49:39 <srhb> hsk3: Only if you worry about spam.
11:50:25 <kadoban> hsk3: Well, I mean if you publish the package publicly, maybe, if you care. I consider email addresses essentially public information at this point though. Is there any human who actuall uses email and isn't on a bunch of spam lists already?
11:50:39 <joe9> hsfor: check out IORef to keep stuff around
11:51:09 <dmwit> joe9: If you're going to pass around an `IORef`, but don't actually plan on changing the contents, why not just pass around the contents?
11:52:00 <joe9> dmwit: thought he was changing it. sorry about that.
11:52:41 <hsfor> also: is there an easy (some template haskell trick?) way to just make it compute my lookup table at compile time?  (It’s totally pure, so it seems like it could be possible …)
11:54:22 <kadoban> hsfor: It's very likely there is. Though if it being done once at startup is a problem, it'd have to be pretty huge or complicated, no?
11:55:22 <hsfor> kadoban: yeah I was mainly curious for if it comes up somewhere else (this case is fine to do at startup)
11:55:22 <ClaudiusMaximus> dmwit: return :: IO a -> IO (IO a)  ?
11:55:22 <dmwit> hsfor: It's a shame reddit search is so terrible. I've commented on a thread discussing how one might go about implementing that, but I can't find it now...
11:55:57 <hsfor> ah
11:56:10 <dmwit> ClaudiusMaximus: If I `await` that multiple times, it will run my action multiple times. I want to demand it many times, and have it run at most once -- possible never, if I never demand it.
11:57:35 <dmwit> hsfor: https://www.reddit.com/r/haskell/comments/4jbyuz/constant_lists_of_intdoublewhatever_as/
11:57:50 <dmwit> hsfor: From that thread:
11:57:52 <dmwit> ?hackage lookup-tables
11:57:53 <lambdabot> http://hackage.haskell.org/package/lookup-tables
11:57:53 <ClaudiusMaximus> dmwit: ah, i see, so you want something with the type i gave that wraps with a caching behaviour - could be tricky depending what you want to happen on exceptions...
11:58:18 <dmwit> ClaudiusMaximus: Rethrowing or returning a `Maybe` would both be fine.
11:59:18 <dmwit> ClaudiusMaximus: But I do want it to be thread-safe, that is, a second thread may demand it while it's still running for the first thread's demand.
11:59:41 <hsfor> dmwit: nice; that’s pretty cool
11:59:42 <dmwit> ClaudiusMaximus: I think I can cook it up myself. I was just hoping it might already be written...
12:00:14 <ClaudiusMaximus> dmwit: sure
12:05:30 <joe9> It appears that whenever I use typeclass, I end up refactoring to a data type. Is that a common experience?
12:06:01 <mauke> ghc experiences that all the time
12:11:33 <EvanR> joe9: yeah, data types are more flexible but you have to pass more stuff around
12:12:09 <EvanR> agdas way of dealing with this is pretty interesting
12:33:20 <danza> someone told me that defining own typeclasses is a common pitfall for who comes from an object oriented background. Here i defined a type class of things which can be converted to time series https://github.com/danse/exmargination/blob/master/ToTimeSeries.hs ... i would appreciate some feedback. Is the typeclass superfluous? How else can i express that?
12:33:58 <smorele1> do someone know Hakyll ?
12:34:28 <srhb> smorele1: If you ask your specific question, people might be better able to gauge if they can help you. :)
12:35:09 <smorele1> srhb: yep but I do not know if my issue is related to Hakyll or Haskell :(
12:35:25 <smorele1> Failed to load interface for ‘Hakyll’
12:35:55 <smorele1> according to google it's seems to be an Haskell issue but I'm a newcomer and I do not understand what happend
12:36:54 <srhb> smorele1: Is that the entire error message? If you get more, you can paste it on lpaste.net
12:37:03 <srhb> It does not look like a Hakyll specific error.
12:37:14 <smorele1> mbp:haskell-101 smorele$ runghc site.hs build
12:37:14 <smorele1> site.hs:4:1: error:
12:37:14 <smorele1>     Failed to load interface for ‘Hakyll’
12:37:14 <smorele1>     Use -v to see a list of the files searched for.
12:37:15 <smorele1> mbp:haskell-101 smorele$ 
12:38:18 <srhb> smorele1: How did you install Hakyll?
12:38:31 <srhb> That error is what you would get if you simply didn't have the module in any packages GHC can see.
12:38:42 <smorele1> srhb: sack install hakyll 
12:38:47 <smorele1> stack
12:39:16 <smorele1> yep this I what I've undertstood too but … I don't know why
12:39:35 <prsteele> what do I need to be on the lookout for when I enable UndecidableInstances? Is it sufficient that my program compiles?
12:40:08 <srhb> smorele1: I'm not very familiar with stack, but I would assume it does not expose its packages to the system GHC, so you would need some stack equivalent command to run instead of simply runghc ...
12:40:21 <srhb> smorele1: That way you will invoke a ghc that actually has the stack packages in "scope"
12:40:40 <danza> yeah i also think that might be the problem
12:41:34 <smorele1> hum yeah I tjink I understand. Another command is: stack exec site rebuild
12:41:53 <srhb> smorele1: That sounds more right :)
12:42:09 <danza> so `stack exec site build` should do what you want
12:42:31 <smorele1> but if I have a missprint or a glitch, this command does not show error, stack site.hs build do it
12:43:33 <srhb> smorele1: Sorry, I didn't understand your last message.
12:44:43 <smorele1> srhb: sorry I'm french. I meant 'stack site.hs build' gives me error in my file, 'stack exec site build' does not
12:46:04 <srhb> smorele1: I'm not sure how they differ. Perhaps someone more knowledgable in stack can assist.
12:46:36 <smorele1> yep I guess srhb thanks for your help
12:47:17 <sshine> hej srhb :)
12:47:26 <srhb> sshine: o/
12:56:57 <danza> srhb, smorele1 it might be that `stack exec` would run an executable visible in the sandboxed environment, without rebuilding it, and thus it won't show compilation errors on the modified file
12:57:23 <danza> srhb, but if `stack site.hs build` works for you, there is no problem, right?
12:58:18 <smorele1> nope danza, "stack site.hs build" returns Failed to load interface for ‘Hakyll’
12:58:23 <smorele1> then I use "stack exec site build" instead
12:59:10 <danza> hum maybe stack is not intended to be called using Haskell source files as arguments
13:04:23 <mpickering> Which are the popular html generating dsls?
13:06:58 <jackhill> danza: (re: calling stack on haskell files) I'm not quite sure, but maybe https://docs.haskellstack.org/en/stable/GUIDE/?highlight=#script-interpreter will help?
13:06:58 <sm> lucid, shakespeare, blaze-html
13:06:58 <ggVGc> I've only really heard about Hakyll
13:06:58 <mpickering> smorele1: Does "stack exec site build" rebuild if you change "site.hs"?
13:06:58 <danza> smorele1, jackhill yes, Stack can be used to run Haskell scripts, i just found https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter. But i am rather sure that this is not targeted at smorele1's use case
13:06:58 <smorele1> mpickering: nope I try to do some changes but nothing happend :(
13:07:04 <mpickering> I think you want "stack ghc site.hs"
13:07:21 <jackhill> danza: yeah. When I did Hakyll stuff, I made it a full stack/cabal project to build one executable, and ran that on my inputs
13:07:25 <jackhill> mpickering: that sounds good. Or maybe runghc?
13:07:44 <sm> or stack exec -- site.hs ... 
13:08:20 <mpickering> I thought stack exec executed a command in the proper environment sm
13:08:29 <mpickering> So you would need stack exec ghc site.hs ?
13:08:59 <mpickering> I don't know how runghc is different to ghc, I thought runghc was just a thin wrapper around ghc
13:09:11 <dcoutts> runghc runs a Main.hs
13:09:18 <sm> mpickering: yes, it will ensure site.hs sees the stack-installed Hakyll package. I forgot to say I'm assuming that site.hs has been made into an executable script
13:09:18 <dcoutts> rather than compiling it
13:09:35 <sm> when I'm tweaking a hakyll site, I usually run it that way 
13:09:59 <suppi> check out the next steps guide: https://haskell-lang.org/get-started
13:10:40 <mpickering> ah right, I usually just use ghc on it directly. Good tip, he could set the top to run the proper stack command and then just ./site.hs would work
13:11:33 <mpickering> thanks dcoutts 
13:11:46 <mpickering> so he definitely wants "stack ghc site.hs" does that work smorele1?
13:12:12 <mpickering> Phew, managed to negotiate 4 interleaved conversations. 
13:12:24 <mpickering> I will use blaze-html I guess, thanks for the tips sm
13:13:00 <suppi> mpickering, blaze-html works, lucid is also an option
13:13:05 <joe9> danza: just a thought, in your code regarding the time series, have you thought of using an unboxed vector instead of a list?
13:13:32 <suppi> but you already got that suggestion i see. sorry!
13:16:25 <smorele1> well in fact I have to do: "stack build" and then "stack exec site rebuild" to see my updates
13:17:48 * hackagebot http-pony 0.1.0.1 - A type unsafe http library  https://hackage.haskell.org/package/http-pony-0.1.0.1 (JinjingWang)
13:19:27 <mpickering> Is the site.hs listed as an executable in your cabal file?
13:19:28 <suppi> you can also use stack's --file-watch flag to make it build automatically on file changes i think
13:20:25 <danza> thanks for your feedback joe9, performance is not a concern for me at the moment, i just cared about correctness and style
13:20:31 <sm> yeah, does stack build --fast --file-watch work ?
13:21:33 <sm> or maybe stack build --fast --file-watch --exec 'stack exec site build'
13:22:31 <sm> or even stack build --fast --file-watch --exec 'stack exec site watch'
13:23:49 <sm> then in another window, livereloadx -p 10000 --static .
13:23:53 * sm is on a roll
13:24:21 <sm> http://localhost:10000 should then give you live updates when you save site.hs or content files
13:24:51 <JonReed> Hi, let's say I have an `f :: String -> OtherArgs...` and I want to move `String` from an argument to a context in which this function executes. What would be the way to accomplish it with minimal amount of boilerplate? E.g. in mtl it seem to be that you need 6 lines to wrap a custom reader: http://lpaste.net/204236  Is this the least verbose way to do it?
13:26:20 <EvanR> Reader String
13:26:40 <JonReed> EvanR: I mean if I anticipate several Readers.
13:26:41 <EvanR> ask :: Reader String String
13:26:56 <EvanR> if you instead put all your readerable things in a record then you can use
13:27:09 <EvanR> asks :: (a -> b) -> Reader a b
13:27:27 <EvanR> asks field1
13:27:40 <JonReed> oh ok
13:28:02 <JonReed> Thx
13:29:11 <EvanR> honestly for a simple Reader seriously contrast all this with just passing the record in as a normal argument
13:53:17 <av_> ClaudiusMaximus: thanks for your help, the simple code is much faster without Linear (though the other tricks such as monomorphic type and unpack etc. didn't help)
13:53:55 <av_> ClaudiusMaximus: now, I want to use all that with AD, so here's a piece of code derived from the current optimum in terms of speed: {-# LANGUAGE TypeFamilies, DeriveFunctor, DeriveTraversable #-}
13:53:59 <av_> module Main where
13:54:01 <av_> import Data.List
13:54:04 <av_> import Numeric.AD
13:54:06 <av_> n = 100
13:54:09 <av_> data V3 t = V3 !t !t !t
13:54:09 --- mode: ChanServ set +o shachaf
13:54:11 <av_>           deriving (Show, Functor, Foldable, Traversable)
13:54:12 --- kick: av_ was kicked by shachaf (av_)
13:54:21 --- mode: shachaf set -o shachaf
13:54:32 <av_> sorry, my irc client confused me...
13:54:35 <shachaf> av_: Please use a paste website such as hpaste.org for more than a line or two of code.
13:54:42 <av_> should have been this link: http://lpaste.net/204257
13:54:50 <av_> shachaf: sure, wasn't intentional
13:55:46 <av_> ClaudiusMaximus: so just computing that gradient costs me a factor of 15 in runtime, which I find a bit excessive...
13:55:54 <av_> any ideas?
13:57:13 <hsk3> Is it possible to create and work with an IORef in the middle of a Haskell program?
13:57:22 <hsk3> As opposed to creating it in main and propagating it into the program
13:57:57 <srhb> hsk3: Any IO action will suffice.
13:59:05 <hsk3> srhb: but if I create a new IORef with newIORef, how do I access that same IORef later?
13:59:16 <hsk3> i.e., where do i store it?
13:59:23 <srhb> hsk3: You pass it as an argument to whatever needs to use it.
14:03:47 <hsk3> srhb: i'm trying to create a function :: IO () that only does something once. on the second run of function, it does nothing.
14:03:54 <hsk3> that's all.
14:04:07 <hsk3> it's pity i have to pollute surrounding code with IORef parameters to do this...
14:04:11 <hsk3> is that the only way?
14:04:47 <srhb> hsk3: If that's _really_ all you want, no strings attached, then you can unsafePerformIO
14:04:59 <srhb> hsk3: To create whatever value it is you needed.
14:05:11 <srhb> But down this road lie many dangers. :-)
14:06:06 <kadoban> hsk3: Why would that require polluting surrounding code with IORefs? Wouldn't only the IO action itself have the code that checks if it's been done already or not?
14:06:44 <hsk3> kadoban: well, i need a "global" variable to mark if it's done or not. hence the ioref idea
14:06:57 <hsk3> well, i guess i could write out a file someplace
14:07:07 <hsk3> but meh. no way to do it in memory?
14:07:13 <hsk3> (other than ioref)
14:07:21 <lyxia> unsafePerformIO is better than writing to a file
14:07:30 <ClaudiusMaximus> av_: maybe try some of the other AD modes?  not sure which is best for your use case; afaik default is Reverse, there is mention of a Forward.Double that allows things to be unboxed, but with worse asymptotics (constant factors may win out)
14:07:56 <lyxia> Please don't take what I said out of context.
14:08:48 <srhb>  @addquote lyxia unsafePerformIO is better than writing to a file
14:08:54 <EvanR> i read that line out of context
14:09:26 <Liskni_si> hsk3: I think the correct way to solve this problem is to create a doOnce :: IO () -> IO () that handles the ioref stuff and then use that in your function :: IO ()
14:09:44 <Liskni_si> hsk3: this way the pollution is isolated
14:10:46 <ClaudiusMaximus> hsk3: you could write a combinator  doOnce :: IO a -> IO (IO a)  (which would wrap an io action so that the result only performs the passed argument action once, and caches the result - be wary of thread safety and exceptions etc - i think dmwit was working on this earlier today)
14:10:48 <ongy> lyxia: then how is: usafePerformIO . withFile "file" ModeWrite . flip hPutStr
14:11:29 <EvanR> unsafePerformIO to write files o_O
14:11:38 <hsk3> scary. maybe i'll just pass an ioref in there safely
14:11:47 <av_> ClaudiusMaximus: thanks, I'll try that next -- though, last time I went through the modes, the defaults were best-performing by quite a margin in my case
14:11:55 <ongy> that one is really not a good idea. don't take it as advice
14:12:19 <hsk3> if only someone had already put this on hackage
14:12:21 <hsk3> doOnce
14:12:29 <lyxia> ongy: are you missing an argument?
14:13:04 <lyxia> oh nvm
14:13:14 <ongy> lyxia: it's WriteMode not ModeWrite. But then the whole thing should take a String to write. I made it up on the fly, so may have an error
14:13:50 <lyxia> I just momentarily forgot what withFile does
14:14:03 <ClaudiusMaximus> av_: ok.  not sure why it's quite so ill-performant for you.  if it's possible to write explicitly, that'll be likely faster than anything automatic, but more code to write and maintain and loses some elegance...
14:14:30 <c_wraith> ongy, unsafePerformIO on a file write is terrifying. you would need to force the () to trigger the write. that isn't nice. 
14:15:01 <MarcelineVQ> hsk3: incidental hoogle discovery https://www.stackage.org/haddock/lts-7.0/extra-1.4.10/Control-Concurrent-Extra.html#v:once
14:15:14 <ongy> is it not obvious that I wanted to add to the out of context with combining both things? Or are you all trying to feed the troll
14:15:30 <EvanR> fix unsafePerformIO
14:15:46 <lyxia> Let's create a new school of programming around wrapping all of System.IO in unsafePerformIO.
14:15:47 <hsk3> MarcelineVQ: very nice :)
14:15:59 <EvanR> :t fix (return . unsafePerformIO)
14:16:01 <lambdabot> error:
14:16:01 <lambdabot>     Variable not in scope: unsafePerformIO :: m a -> a
14:17:10 <ongy> it returns
14:17:27 <EvanR> unsafePerformIO II: it returns
14:17:51 <ongy> @src fix
14:17:51 <lambdabot> fix f = let x = f x in x
14:18:07 <ongy> so this is fix point iteration, right?
14:18:22 <EvanR> fix f = f (fix f)
14:19:22 <EvanR> it magically computes the value x for which f x = x
14:19:46 <grantwu> It's not magic and it doesn't always work
14:19:48 <ongy> why does it ever return? I don't get the condition when it would stop
14:19:56 <grantwu> Non strict evaluation
14:19:58 <EvanR> it does always work... if you believe in _|_
14:20:13 <grantwu> If f can return without needing the value in x, it terminates
14:20:42 <EvanR> it can stop, or it could keep going and still be useful like
14:20:49 <EvanR> > fix (1:)
14:20:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:20:52 <ongy> > fix (\x -> min (x - 1) 0)
14:20:58 <lambdabot>  mueval-core: Time limit exceeded
14:21:08 <ongy> > fix (\x -> max (x - 1) 0)
14:21:14 <lambdabot>  mueval-core: Time limit exceeded
14:21:41 <latro`a> how do you do the equivalent of pcolor in Matlab/Octave from a haskell package? I can't really make heads or tails of the gnuplot package :/
14:21:43 <EvanR> ⊥
14:22:15 <ongy> oh, so I don't get x where x == f x, but literally f x = x, which are totally different things
14:22:26 <EvanR> not ==
14:22:44 <EvanR> in that case f ⊥ = ⊥
14:22:59 <ongy> I was always so confused about this. I learned about fixpoint iteration I the same day I found fix, I guess that messed something up
14:23:26 <latro`a> it's not fixed point iteration in the sense of numerical analysis
14:24:08 <phadej> well, s, GHC is just to dump to realise that max (x- 1) x for all x
14:24:21 <phadej> max (x - 1) x = x, for all x
14:24:32 <phadej> (actually it isn't for Int)
14:24:58 <ongy> neither for Word
14:26:09 <phadej> but you can teach ghc with RULES max (x :: Word) 0 = 0
14:26:26 <phadej> which is a slight lie,
14:27:25 <EvanR> is it?
14:27:29 <ongy> wouldn't that match 'max (2 :: Word) 0'?
14:27:41 <phadej> ah max (x :: Word) 0 = x
14:28:02 <EvanR> min x 0 = 0
14:28:28 <phadej> I meant min (x - 1) 0
14:28:42 <phadej> but anyway, my point was that with RULES one could get those to converge
14:28:56 <ongy> cheats!
14:31:49 <phadej> Well, it depends. Relying on the rule to fire is dangerous, but otherwise, why not.
14:32:08 <dmwit> ongy: You don't get `x` where `x == f x` if `==` is from Haskell's `Eq` class; you get (the least) `x` where `x = f x` where `=` is the semantic equality in the semantic lattice.
14:33:36 <ongy> dmwit: I used == to emphasise that I want equality, not as operatior from Eq
14:33:39 <dmwit> I do not believe RULES can make `fix (\x -> max x 0)` converge.
14:33:52 <dmwit> At best you will get `fix (\x -> x)`, for which `undefined` is still a fine fixpoint.
14:34:27 <dmwit> ongy: That was a bad way to emphasize that, since `==` is the name of the operator from `Eq`...
14:35:52 <ongy> > fix (intersect "asdf") -- shouldn't this evaluate with your description?
14:35:58 <lambdabot>  mueval-core: Time limit exceeded
14:36:11 <dmwit> ongy: Convince me it should evaluate.
14:36:25 <dmwit> I will do my best to highlight where your understanding is not correct.
14:37:27 <dmwit> To start with: what should it evaluate to, in your opinion?
14:37:40 <ongy> []
14:37:53 <dmwit> [] is a perfectly good fixpoint. But it is not the least fixpoint.
14:37:56 <NemesisD> is it possible without TH to demote a nullary constructor from DataKinds to the corresponding value?
14:38:12 <dmwit> To be careful: here "least" is in the defined-ness ordering; again, this is completel unrelated to Haskell's `Ord` class.
14:38:14 <ongy> I'm currently wondering if the list as Set is a (semi) lattice
14:38:27 <NemesisD> i.e. data Foo = A | B, I want to get from (Proxy :: Proxy 'A) -> A
14:38:49 <ongy> so we build the lattice over how good something is defined?
14:38:56 <dmwit> ongy: In all types, `undefined` is the least value. So if `undefined` is a fixpoint, you will get that.
14:39:11 <dmwit> ongy: And in particular `undefined` is a fixpoint of `intersect "asdf"`.
14:39:33 <dmwit> ongy: Yes, the lattice is the defined-ness one.
14:39:45 <ongy> then it makes sense to not return
14:39:57 * dmwit nods agreeably
14:40:13 <ongy> but how does the = here differe from ==?
14:40:27 <ongy> or better: how is the equality on this lattice defined?
14:40:49 <dmwit> = is beta-equality
14:40:58 <ongy> beta is renaming?
14:41:05 <dmwit> renaming + evaluation
14:41:34 <dmwit> (Beta reduction is turning `(\x -> e) e'` into `e [e'/x]`.)
14:42:53 <dmwit> NemesisD: Yes, this is what singletons do.
14:42:54 <ongy> ok, this makes way more sense now
14:43:07 <NemesisD> dmwit: doesn't that require TH?
14:43:13 <dmwit> No, just GADTs.
14:43:48 <NemesisD> cool. sounds like exactly what i need. where could i find more information?
14:43:57 <dmwit> Oh, well. The singletons package uses TH to make them easier to use. But you can do what you want without TH.
14:45:31 <dmwit> NemesisD: http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf perhaps?
14:46:14 <ongy> dmwit: the undefined you use here is not the same as haskell undefined, is it? Is it _|_?
14:46:45 <dmwit> NemesisD: But the short version is: `class Demote x where demote :: proxy x -> Foo; instance Demote A where demote _ = A; instance Demote B where demote _ = B`.
14:46:59 <joe9> any glfw users here? With glfw, I disabled all my callbacks. But, still glfwWaitEvents is returning. I cannot figure out what event has been triggered. Any suggestions on how to figure it out, please? I am getting an almost continuous event firing and I cannot figure out what it is.
14:47:06 <joe9> http://dpaste.com/2KJCCY2 is the haskell code
14:47:20 <dmwit> ongy: Haskell's `undefined` is the canonical completely-undefined value -- hence the least value in any type's lattice.
14:47:44 <ongy> then why is it not equal to
14:47:50 <ongy> > intersect "asdf" undefined
14:47:52 <lambdabot>  "*Exception: Prelude.undefined
14:47:55 <NemesisD> dmwit: i guess its kind of a tricky situation. if i want to avoid TH i have to write this mapping by hand, so I may as well just write a plain function and not bother with singletons *or* abandon this datakinds approach
14:48:16 <dmwit> ongy: You are supposed to pretend that exceptions are infinite loops. ;-)
14:48:38 <dmwit> Semantically they are equated. The fact that we can distinguish them is an observation that GHC is not quite faithful to the semantics (but in a useful way).
14:49:52 <ClaudiusMaximus> av_: looking at profiling output, it seems to redo the whole ad calculation for each grid point, when i wonder if there's a way to do the ad once and share that effort across the grid - didn't manage to achieve that yet in my tests
14:51:44 <ClaudiusMaximus> av_: but i think you can use ad with an expression tree data type and use the results for code generation (perhaps with llvm or similar), if you need fastest
14:54:24 <ongy> > fix Just
14:54:26 <lambdabot>  error:
14:54:26 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ Maybe a
14:54:26 <lambdabot>        Expected type: Maybe a -> Maybe a
14:54:43 <ongy> > fix (join . Just)
14:54:49 <lambdabot>  mueval-core: Time limit exceeded
14:55:00 <dmwit> :t Fix
14:55:01 <lambdabot> error:
14:55:02 <lambdabot>     • Data constructor not in scope: Fix
14:55:02 <lambdabot>     • Perhaps you meant one of these:
14:55:17 <dmwit> :t In
14:55:18 <lambdabot> f (Mu f) -> Mu f
14:55:23 <dmwit> > fix (In . Just)
14:55:27 <lambdabot>  error:
14:55:27 <lambdabot>      • No instance for (Show (Mu Maybe))
14:55:27 <lambdabot>          arising from a use of ‘show_M91648280373295018845813’
14:55:47 <MarcelineVQ> can't you see you're hurting her?
14:55:57 <dmwit> Odd. Hackage claims there's a `Show` instance.
14:57:13 <dmwit> > let show' (In x) = "In (" ++ show (show' <$> x) ++ ")" in show' (fix (In . Just))
14:57:15 <lambdabot>  "In (Just \"In (Just \\\"In (Just \\\\\\\"In (Just \\\\\\\\\\\\\\\"In (Just ...
14:57:48 <dmwit> ongy: ^^
14:59:59 <ongy> ah, I guess join breaks it
15:00:22 <dmwit> yup, `join (Just undefined) = undefined`
15:03:39 <ongy> I'll go to bed and probably dream about function iteration. Good night
15:04:18 <hsk3> How can I make this code prettier? http://lpaste.net/1892302778903035904
15:04:18 <hsk3> I want to avoid those nested if else -- the pyramid of death
15:05:52 <dibblego> hsk3: unless/when will help you
15:06:27 <hsk3> dibblego: not really, because those still continue execution...
15:06:53 <hsk3> oh..
15:07:05 <hsk3> i see
15:07:11 <dibblego> I don't know what that means
15:07:15 <hsk3> but that still requires me to create a nested do
15:07:25 <dmwit> hsk3: http://stackoverflow.com/q/33005903/791604
15:08:47 <dibblego> woops sorry I edited it instead of annotatingn it
15:10:06 <dmwit> tangent: print = putStrLn . show
15:17:51 * hackagebot derive-storable 0.1.0.3 - Derive Storable instances with help of GHC.Generics.  https://hackage.haskell.org/package/derive-storable-0.1.0.3 (mkloczko)
16:04:27 <madgen> Hello, can out of line primops be interrupted by the GC?
16:07:46 <dmwit> madgen: That question is certainly on-topic here, but you may have better luck in #ghc (and I believe it would be considered on-topic there, too).
16:08:05 <madgen> alright, thanks!
16:08:11 <dmwit> Probably just about everybody in #ghc is in here, too, but your question is less likely to disappear from scrollback before they notice in there.
16:47:50 <hackrilege> hi, i have been researching Data.Array and find that it relies upon the Control.Monad.ST. i gather it uses this module to implement mutability, I was wondering about the speed of the mutable Array that results compared to an implementation using []
16:49:13 <Axman6> for most operations the ST based functions will be faster than what you can do with lists _for things which lists aren't better at than arrays, like random access_
16:50:11 <hackrilege> how does use of ST allow faster non linear access?
16:50:24 <hackrilege> (random access, whatever its called)
16:50:37 <c_wraith> well. STArray is an actual flat array 
16:50:47 <Axman6> it generally allows for faster updates, but that depends on how much you're updating
16:50:54 <clueless> someone help plz.. whats wrong with my code, supposed to add the last four elements in a list.. or all of them if its less than 4 http://lpaste.net/204489
16:50:55 <c_wraith> if you need random access by index, nothing beats that. 
16:51:09 <Axman6> if you're just updating one item, then it has to copy everything
16:51:53 <hackrilege> clueless, parse error on input \
16:53:12 <Axman6> clueless: that's going to be horribly inefficient - length take O(n) time, and lists are not arrays
16:53:37 <hackrilege> i dont understand why c_wraith and Axman6 last statements are true
16:54:17 <hackrilege> c_wraith if you need random access by index, nothing beats that. 
16:54:17 <hackrilege> Axman6 if you're just updating one item, then it has to copy everything
16:54:33 <Axman6> yes, because the old array has to stay immutable
16:54:58 <hackrilege> i thought using ST made it mutable
16:55:05 <clueless> hackrilege: sorry, the sum has to be added to the front of the list
16:55:28 <clueless> Axman6: forgot to say the sum has to be placed in the front of the list
16:55:35 <clueless> Axman6: what is your suggestion?
16:55:36 <Axman6> clueless: have you seen the reverse function?
16:55:43 * jakk rips the soft folds of eL_Bart0's vagina to shreds with her teeth. 
16:55:43 * jakk winks at lattenwald and walks towards him "hey daddy~! Are u ready for me yet?"
16:55:46 * jakk conjures a knife and carves herself out some juicy oelewapperkesteak. "Mmm Mm~^^"
16:55:49 * jakk moans deeply as he nuzzles into lattenwald's planty mane, his tentacles squeezing and massaging the hermaphrodite's penis. "I-I neeeeeed this..."
16:55:52 * jakk groans as she feels her "pregnancy" shift downward from her stomach towards her equine half, where it still balloons out monstrously. "Unh... p-please dextertzu... help..."
16:55:53 <Axman6> @where ops
16:55:53 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
16:55:54 --- mode: ChanServ set +o glguy
16:55:54 --- mode: glguy set +b *!*@2602:ffca:b:15d::357e
16:55:54 --- kick: jakk was kicked by glguy (jakk)
16:55:56 <hackrilege> why not use (a->drop ((length a)-4) a)
16:56:25 <dcoutts> glguy: ta
16:56:48 --- mode: glguy set -b+b *!*@2602:ffca:b:15d::357e *!*@2602:ffca:b:15d:*
16:57:17 <Axman6> glguy++
16:59:09 <hackrilege> so the question about mutability afforded by ST, am i correct in thinking that updating a single element of an immutable type is costly because it has to copy the whole thing, and this is somehow avoided my using ST?
16:59:11 <benzrf> what the shit
16:59:17 --- mode: glguy set +b-o $a:jakk glguy
17:00:30 <Axman6> hackrilege: it always depends on what the type is. updating the head of a list is cheap, updating its tail is very costly (potentially infinitely expensive). updating one element of an array is always linearly expensive because every element (or ever pointer to every element) has to be copied
17:00:54 <benzrf> Axman6: i think you mean updating its last
17:00:59 <benzrf> tail is just the second element of the cons cell
17:01:14 <Axman6> uh, yes, updating its last element*
17:01:27 <hackrilege> as you could simply update the head of the tail, yeh i get that
17:01:28 <benzrf> sorry, not super helpful >_>
17:02:02 <hackrilege> im confused, Array is faster because it uses ST?
17:02:50 <clueless> Axman6: I see.. but I still don't see how I would do it differently (i would still basically call reverse array!!1 + reverse array!!2+.... 
17:03:10 <clueless> Axman6: so i guess could you help me with the implementation of only calling the first four elements?
17:03:22 <hackrilege> it seems to be something to do with "STArray is an actual flat array"
17:04:00 <Axman6> clueless: if you reverse the _list_ (it's not an array) then the last four elements will be the first 4 elements of the reveresed list
17:04:45 <hackrilege> then the !! access is faster
17:05:00 <hackrilege> because it does not have to discard the whole list
17:05:02 <Axman6> you can just use sum . take 4
17:05:10 <clueless> Axman6: yes I know, but how would u get them? 
17:05:23 <clueless> Axman6: I think thats the part im being really inefitient with
17:05:49 <Axman6> pattern match? use sum . take 4?
17:05:56 <Axman6> > sum [1..10]
17:05:58 <lambdabot>  55
17:06:05 <Axman6> > sum . take 4 $ [1..10]
17:06:07 <lambdabot>  10
17:07:16 <hackrilege> > let f a = if length a > 4 then (sum . (take 4) . reverse) a else sum a in map f [[1,2],[1..10]]
17:07:19 <lambdabot>  [3,34]
17:08:33 <hackrilege> > take 4 [1,2]
17:08:35 <lambdabot>  [1,2]
17:08:37 <hackrilege> oh
17:09:06 <hackrilege> let f a =  (sum . (take 4) . reverse) in map f [[1,2],[1..10]]
17:09:12 <hackrilege> > let f a =  (sum . (take 4) . reverse) in map f [[1,2],[1..10]]
17:09:14 <lambdabot>  [<[Integer] -> Integer>,<[Integer] -> Integer>]
17:09:19 <Axman6> calling length on a list is almost always not what you want to do
17:09:29 <hackrilege> oops
17:09:45 <hackrilege> let f =  (sum . (take 4) . reverse) in map f [[1,2],[1..10]]
17:09:50 <hackrilege> you get the idea
17:10:01 <hackrilege> thats the function you want anyway
17:10:13 <hackrilege> (sum . (take 4) . reverse)
17:10:58 <c_wraith> Cale: did you ever try to build webkit-gtk on OS X?
17:10:58 <hackrilege> Aexman, any idea what im getting mixed up about with Array?
17:17:53 * hackagebot bond-haskell-compiler 0.1.4.1 - Bond code generator for Haskell  https://hackage.haskell.org/package/bond-haskell-compiler-0.1.4.1 (blaze)
17:17:55 * hackagebot bond-haskell 0.1.4.1 - Runtime support for BOND serialization  https://hackage.haskell.org/package/bond-haskell-0.1.4.1 (blaze)
17:20:30 <alex_new> Hey, I am using stack with NixOs. My application uses gnuplot, and when I run it in "stack ghci" it produces a graph, while when I compile it and run as "stack exec" it does not. it also doesnot produce any error
17:20:39 <alex_new> how do I troubleshoot it?
17:21:48 <Koterpillar> alex_new: we don't know anything about your app so far; are you even calling it the same from GHCi?
17:23:00 <alex_new> I just type "main" in ghci,and it works - (produces normal log)
17:23:11 <alex_new> I just type "main" in ghci,and it works - (produces normal log)
17:23:18 <alex_new> produces some data... then I just use "plotPath"
17:23:57 <Koterpillar> alex_new: did you do "stack build"?
17:24:29 <alex_new> yes
17:24:33 <alex_new> here is the app http://paste.ofcode.org/rve2m3KGc5tZygXmGLhBgL
17:24:45 <alex_new> the relevant part is at the end....
17:24:55 <alex_new> in function computeAll and main
17:25:04 <Koterpillar> so, does it at least print the computation time?
17:28:21 <alex_new> in function computeAll and main
17:28:21 <alex_new> maybe I write my stack.yaml wrongly? here it is... http://paste.ofcode.org/36UdidD528efpC6GEv3SnJw
17:28:21 <alex_new> if I surround "plotPaths" by " print "hey" " -> they are printed... 
17:28:44 <alex_new> yes
17:29:01 <alex_new> it does... 
17:29:32 <alex_new> here is the cabal file http://paste.ofcode.org/GpKhu6xfkBzmRC5rsZb9MM
17:30:16 <alex_new> I used to have "pure: true" in stack.yaml file, but removing it did not help
17:30:27 <alex_new> I used to have "pure: true" in stack.yaml file, but removing it did not help
17:30:31 <alex_new> Is it a good idea to use stack in nixos anyway?
17:30:54 <Axman6> does this require calling some binary that's part of gnuplot?
17:32:13 <alex_new> I do not know how haskell-gnuplot wroks. But it could be it... I am going to check what gnuplot has in the NixOs store.. maybe add it to extra libs
17:33:53 <alex_new> I do not know how haskell-gnuplot wroks. But it could be it... I am going to check what gnuplot has in the NixOs store.. maybe add it to extra libs
17:38:38 <buglebudabey> are there any packages that make use of and therefore require files other than .hs ones such as scripts or text files or what have you?
17:39:18 <Axman6> you can add them to the cabal file as dependencies, possibly under extra-files
17:39:20 <Koterpillar> buglebudabey: yes, but this question is a bit vague
17:39:59 <buglebudabey> Koterpillar for instance, I want to make a CNN that relies on a set of training data offered by Google that converts words to vectors
17:40:12 <buglebudabey> Koterpillar specifically this https://code.google.com/archive/p/word2vec/
17:42:09 <Koterpillar> buglebudabey: and?
17:42:50 <buglebudabey> do packages made by stack let's say support this kind of dependency
17:42:50 <alex_new> now my irc is not working... (
17:42:54 <buglebudabey> and can i reflect it on hackage
17:43:50 <Koterpillar> buglebudabey: you can add the files to your package
17:44:18 <Koterpillar> buglebudabey: some packages rely on system files but AFAIK there's no way to formally acknowledge this
17:44:54 <buglebudabey> Koterpillar so if someone were to download my package on hackage and run it, my library could utilize the script without needing the user to do anything? (as long as i set up the functions to use it i mean)
17:44:58 <Axman6> buglebudabey: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code and also search for data-files on that page
17:45:15 <Koterpillar> buglebudabey: if you bundle it, yes
17:45:23 <buglebudabey> awesome, perfect
17:45:48 <buglebudabey> thanks Axman6 
17:45:54 <buglebudabey> and Koterpillar 
17:55:33 <luite> srhb: i'm not against it, but it'll take more time to prepare the code for that, and at the moment i don't really have much time for that
18:01:31 <alex_nnew> sorry, my internet is bad. has anyone advised me anything? about gnuplot?
18:08:27 <zyhn> stack question... i'm building one of my projects on two computers (ubuntu 16.04 on both). on one of them, it builds without a problem. on the other i get: Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1"
18:08:43 <zyhn> any ideas?
18:08:53 <Axman6> hmm, stack update?
18:10:27 <zyhn> nope. didn't help
18:12:15 <Axman6> hmm, very strange
18:15:27 <dmwit> I find the terminology in shake's `--help` puzzling: "-o FILE: Consider FILE to be very old and don't remake it.". If it's old, wouldn't that mean you *should* remake it?
18:16:18 <Axman6> yeah, I wouyld've called it -t for touch so it appears to have been modified and needs an update
18:16:27 <dmwit> Or should I interpret that to mean "We won't remake it this time, but we'll let it be rebuilt on later runs because we still consider it to be old."?
18:17:59 <dmwit> Axman6: Well, there is a `--touch`, with help text "Assum targets are clean.".
18:18:11 <Axman6> wut
18:18:14 <dmwit> So now we have both an "old/new" metaphor and a "clean/dirty" metaphor, and I'm not sure how if at all they are related.
18:18:16 <Axman6> this is all wrong D:
18:18:26 <geekosaur> ot
18:18:28 <geekosaur> erp
18:18:38 <Axman6> wot
18:18:40 <Axman6> twerp
18:18:40 <geekosaur> sadly it's copying (old?) make docs
18:18:43 <Axman6> you got cut off
18:18:44 <Axman6> =)
18:18:53 <Axman6> oh dear :(
18:19:25 <geekosaur> I did figure out what they intended by that "consider to be very old" but it's really not how people think :/
18:19:48 <dmwit> I don't suppose you still have the details paged in enough to explain it to me?
18:20:27 <geekosaur> not very, no. I needed an explanation from the old V7 UNIX docs to get it :/
18:20:53 <geekosaur> but it's a reference to the way V7 make worked internally
18:21:55 <geekosaur> possibly other make programs work sufficiently identically that something that sounds backwards still makes sense, but imo it should never have leaked into the docs *or* the ui
18:22:24 <geekosaur> (aside from internals documentation)
18:22:34 <dmwit> Okay. I will play with it a little bit tomorrow.
18:22:43 <dmwit> Thanks for making me feel better about not understanding it, at least.
18:24:41 <alviprofluvium> How can I specify the same typeclass for diferent parameters in an instance? I'm using instance (Eq a, Eq b) => ...
18:24:43 <geekosaur> (you kinda have to turn your understanding of how make-like programs work inside out to get why anyone would consider that description to make sense at all. it does make sense once you do so, but it's still a bit weird even then)
18:24:50 <alviprofluvium> there is a better way?
18:25:00 <Axman6> not really
18:25:16 <geekosaur> and that viewpoint is.. well, if it were a useful view, I'd still remember it; not like I don;'t deal with build systems daily...
18:25:31 <Axman6> it's possible to define type level functions like All Eq [a,b,c] where All is a type family
18:26:30 <alviprofluvium> mmm but it isnt prettier, at least for my example. Thanks Axman6
18:27:03 <Axman6> yeah it's worth it if there are lots of parameters you need to instantiate a certain class, but it's generally not that useful
18:28:00 <Axman6> sometimes the opposite is kinda useful: Instances a [Eq, Ord, Num, Binary]
18:28:47 <Axman6> anyone know if you can partially apply ~? so you could use Instances a [(~ Int), Eq] (contrived example)
18:30:02 <dfeuer> Axman6, you cannot partially apply ~, but you can write a class using it that you can partially apply.  class a ~ b => Same a b
18:30:09 <dfeuer> instance a ~ b => Same a b
18:30:27 <Axman6> right
18:54:31 <pavonia> Is there a package providing a solution the problem of finding a minimum subset of a set of ranges that covers another given range completly?
19:18:17 <dfeuer> Annoyingly, polymorphic variadic functions seem to be impossible in Haskell 2010.
19:19:02 <dfeuer> Otherwise I'd consider compile-time IntMap and Seq builders.
19:34:20 <Cale> c_wraith: I personally haven't, but I know Ryan does it to make sure reflex-dom works on it.
19:34:43 <c_wraith> I somehow never managed to get pkg-config to know about webkit-gtk
19:34:51 <c_wraith> But that's one of those pain points of everything non-linux
19:39:44 <geekosaur> you generally have to set PKG_CONFIG_PATH
19:40:55 * geekosaur has gotten it to work, not specifically for webkit-gtk but for many other things. but there's a number of confounding factors to deal with, including third party stuff that installs its own pkgconfig (xamarin mono used to do this on os x)
19:56:20 <prsteele> :i Real
19:56:26 <prsteele> sorry wrong window ><
20:03:48 <lgstate> in haskell speak, what is clojure's transducer ?
20:04:17 <maybach> hey guys, what's the best way to learn me some haskell. Is this still a great start? http://learnyouahaskell.com/
20:04:44 <lgstate> learnmesomehaskell.com
20:05:42 <peddie> @where learnhaskell
20:05:43 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:05:49 <peddie> maybach: ^
20:07:01 <maybach> thank you guys
20:08:20 <argent0> exit
20:08:39 * argent0 :-)
20:17:57 * hackagebot hasql 0.19.15.1 - An efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.15.1 (NikitaVolkov)
20:26:15 <dmj`> question
20:26:24 <dmj`> is it possible to unbox a recursive data type
20:26:33 <dmj`> I assume not
20:27:10 <amalloy> can you unbox anything with more than one constructor?
20:28:10 <dmj`> amalloy: tuples
20:28:27 <amalloy> a tuple has one constructor, with two arguments
20:28:57 <dmj`> oh, unboxed sum types
20:29:12 <dmj`> https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes
20:31:14 <dmj`> amalloy: for example, I want to unbox something like this: data X = X [X]
20:34:01 <dmj`> amalloy: oh nvm
20:34:02 <dmj`> :)
20:39:44 <prsteele> how do I help the compiler out when it can't resolve types? I can offer an explicit type annotation, but I'd really like to avoid having to have my users put annotations everywhere
20:39:50 <prsteele> any tricks to help it out?
20:41:18 <prsteele> alternatively, is there any way to restrict a class to be closed?
20:45:42 <jle`> prsteele: hard to help without more details :)
20:47:13 <prsteele> jle`: understandable. Okay, so I used RebindableSyntax to let numeric literals be lifted to `data Constant = ...` where the details aren't important. Howwever when I implement a class that takes a Constant as a first argument, it just complains that it doesn't know exactly what the numeric value should be
20:47:20 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
20:47:20 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
20:58:55 <c_wraith> prsteele: there are several ways to make a closed class, but none that let GHC use that fact.
20:59:45 <glguy> What about a default declaration?
21:00:13 <prsteele> damn, I was hoping a post I was following on "closed type classes" might generalize to my case, but if it's only to make it closed to programmers and not for GHC to know then that doesn't help
21:00:23 <prsteele> glguy: intuition for why that would help?
21:04:12 <knack> m
21:05:10 <glguy> prsteele: Because that's what default declarations are for. You'll need to enable the ExtendedDefaultRules extension for it to apply to your custom class
21:05:30 <prsteele> looking up that extension, thanks
21:06:23 <glguy> I'm checking that it works with rebindable syntax though
21:09:01 <lpaste> glguy pasted “for prsteele” at http://lpaste.net/204808
21:09:19 <glguy> prsteele: Seems like it doesn't interact with rebindablesyntax nicely, though, unfortunately
21:09:42 <prsteele> glguy: thanks though! This might help
21:17:58 * hackagebot HDBC-mysql 0.7.0.0 - MySQL driver for HDBC  https://hackage.haskell.org/package/HDBC-mysql-0.7.0.0 (ryantm)
21:18:00 * hackagebot hspec-core 2.2.4 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.2.4 (SimonHengel)
21:18:02 * hackagebot hspec-discover 2.2.4 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.2.4 (SimonHengel)
21:18:04 * hackagebot hspec 2.2.4 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.2.4 (SimonHengel)
21:18:09 <prsteele> this is frustrating. I think I'm going to have to give up on compile-time safety of expressions to move forward
21:24:16 <jchia> I'm defining a monad transformer stack where there's is some read-only context I need to use when updating the state. This is all happening with IO as the base. Concretely, I'm reading a file where a header provides the context I want to store in a ReaderT and the rest of the file are records that I read one at a time to update the state, making use of the context stored in the ReaderT. Should I use a "StateT st (ReaderT ctx IO)" or a "ReaderT ctx (StateT st 
21:24:25 <prsteele> rather I have fully type-safe expressions, but I have to hand-annotate every numeric literal
21:25:17 <glguy> jchia: Doesn't matter:
21:25:18 <glguy> ?unmtl StateT s (Reader r) a
21:25:18 <lambdabot> s -> r -> (a, s)
21:25:23 <glguy> ?unmtl ReaderT r (State s) a
21:25:24 <lambdabot> r -> s -> (a, s)
21:25:43 <grantwu> huh.
21:25:47 <grantwu> :t unmtl
21:25:48 <lambdabot> error: Variable not in scope: unmtl
21:26:07 <jchia> what's unmtl?
21:26:17 <grantwu> I think it might be a lambdabot thing
21:26:17 <geekosaur> a bot command
21:26:17 <glguy> It unfolds the newtype definitions
21:26:35 <glguy> Reader and State commute, so it doesn't matter what order you put them in.
21:26:36 <geekosaur> it expands the newtypes that comprise mtl monads
21:26:52 <jchia> Is there something similar outside of lambdabot, e.g. in ghci?
21:27:25 <grantwu> hrm, so
21:27:39 <geekosaur> there's a thing that can hook a local lambdabot installation into ghci, but not as far as I know an implementation of unmtl separate from lambdabot
21:27:48 <jchia> I suppose I could use lambdabot in a private chat
21:27:50 <geekosaur> and lambdabot is infamously a bear to install
21:29:07 <grantwu> ?unmtl ExceptT s (State s) a
21:29:07 <lambdabot> ExceptT s (State s) a
21:29:17 <grantwu> does this mean it doesn't commute?
21:29:21 <grantwu> oh wait
21:29:25 <grantwu> ?unmtl ExceptT e (State s) a
21:29:25 <lambdabot> ExceptT e (State s) a
21:29:39 <glguy> ?unmtl ErrorT e (State s) a
21:29:39 <lambdabot> s -> (Either e a, s)
21:29:50 <glguy> unmtl predates the exceptT revolution
21:30:42 <jle`> @unmtl StateT s (Either e) a
21:30:42 <lambdabot> s -> Either e (a, s)
21:31:02 <grantwu> so... they don't commute
21:31:33 <jle`> nop
22:17:59 * hackagebot foldl-statistics 0.1.1.0 - Statistical functions from the statistics package implemented as  Folds.  https://hackage.haskell.org/package/foldl-statistics-0.1.1.0 (AlexMason)
22:22:12 <Axman6> hey that's me
22:28:25 <jle`> ayy
22:36:37 <joe9> any suggestions on how to fix this issue, please? http://bpaste.net/show/c80eada8e086
22:36:49 <joe9> stack fails build
22:37:13 <joe9> log: https://gist.github.com/212e409808e155310b1e9092b4fcb51a
22:37:30 <joe9>  another log: https://gist.github.com/ac75277488f26bfe329381b7e7f4ef6d
22:38:03 <dmj`> joe9: stack install gtk2hs-buildtools
22:38:28 <Axman6> can you add tools like that as deps of the build?
22:40:25 <dmj`> Axman6: no, but it's probably just looking for that executable in the path
22:40:37 <mgsloan> It's because stack does not yet support some new cabal features, and gtk2hs switched to using them without leaving in build-tools deps
22:40:40 <mgsloan> IIRC
22:40:51 <mgsloan> Should have left it as a build-tool dep to still support stack
22:46:28 <glguy> mgsloan: Welcome back to chatting in #haskell ^_^
22:46:45 <glguy> (felt like it had been a while)
22:51:37 <joe9> dmj`: Thanks, That helped.
22:52:54 <dmj`> joe9: cheers
22:57:53 <mgsloan> glguy: It has been a while!  Burning man preparations + the event itself + etc
23:02:11 <mgsloan> Been out of the Haskell loop for a while, keen to get back in it
23:02:34 <Axman6> so about that, we don't do loops
23:02:35 <Axman6> :P
23:02:57 <mgsloan> Hahaha, so now the term is freed up for other uses ;)
23:03:14 <mgsloan> Also, the loops package would disagree!
23:03:14 <cocreature> Axman6: ofc we do, we even have a whole package called monad-loops
23:03:34 <EvanR> fix (():)
23:03:48 <EvanR> ^ loop monster
23:04:24 <cocreature> and ghc even shows you "Exception <<loop>>"
23:04:35 <Axman6> you try and tell a C/C++/Java programmer and they'll look at you funny
23:04:49 <mgsloan> Haha, yeah even GHC is loop-gnostic!
23:04:59 <cocreature> they already look at you funny if you mention haskell
23:05:10 <Axman6> "GHCi, the world's most loop-gnostic interpreter"
23:18:01 * hackagebot sixfiguregroup 0.0.1 - A six figure group of time  https://hackage.haskell.org/package/sixfiguregroup-0.0.1 (TonyMorris)
