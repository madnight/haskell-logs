00:00:35 <John[Lisbeth]> I appreciate this very much
00:02:36 <lpaste> Cale pasted “K machine step” at http://lpaste.net/195914
00:02:45 <Cale> John[Lisbeth]: ^^
00:03:00 <John[Lisbeth]> alright this is something I can hack away at
00:03:05 <Cale> John[Lisbeth]: Note that there are a bunch of unhandled cases to take care of
00:03:36 <Cale> and you probably want to write something to run the steps in a loop until the machine gets stuck
00:03:56 <Cale> step should probably really be State -> Maybe State, with all other possible cases resulting in Nothing
00:04:46 <Cale> Note that since I'm using lists as stacks, they're backwards from how the paper has them
00:04:54 <Cale> (top of the stack is the start of the list)
00:05:59 <John[Lisbeth]> I'll have to teach myself some more haskell in order to read it
00:07:22 <John[Lisbeth]> First I've got to understand how to use it and then I've got to write a repl in it
00:07:25 <lpaste> Cale revised “K machine step”: “K machine step” at http://lpaste.net/195914
00:07:38 * hackagebot keysafe 0.20160914 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20160914 (JoeyHess)
00:07:38 * hackagebot synthesizer-alsa 0.5.0.5 - Control synthesizer effects via ALSA/MIDI  https://hackage.haskell.org/package/synthesizer-alsa-0.5.0.5 (HenningThielemann)
00:07:41 <Cale> I edited it a bit to line things up in nice columns
00:08:36 <John[Lisbeth]> Is it possible to start programming in this thing?
00:08:43 <John[Lisbeth]> a function i can call and give arguments to use it
00:08:57 <Cale> Yeah, let's make a reasonable example to evaluate...
00:10:12 <John[Lisbeth]> according to my firend you just need nand
00:10:25 <Cale> nand doesn't really have anything to do with this
00:11:04 <John[Lisbeth]> I'm gonna need nand at some point or something like it
00:13:42 <John[Lisbeth]> let me put it this way
00:14:03 <John[Lisbeth]> you can feel free to define things such as not as haskell's not or + as haskell's +
00:14:17 <John[Lisbeth]> or define true as haskell's true
00:22:18 <saurabhnanda> help with opaleye, please: https://github.com/tomjaguarpaw/haskell-opaleye/issues/92#issuecomment-247253054
00:44:49 <oherrala> There's online Haskell course starting in next week: https://www.futurelearn.com/courses/functional-programming-haskell/
00:49:51 <bartavelle> oherrala, is it know what the grading system will be like ?
01:42:33 * hackagebot synthesizer-llvm 0.8.1.1 - Efficient signal processing using runtime compilation  https://hackage.haskell.org/package/synthesizer-llvm-0.8.1.1 (HenningThielemann)
02:00:03 <Athas> Sweet, I got my code working with GHC 8.
02:01:21 <jophish> What makes a good programming ability test?
02:01:43 <oherrala> bartavelle: I don't care. I just attend to fill the gaps I might have and to learn new things
02:02:55 <Athas> jophish: spend ten years writing programs, then show them to one of your peers.
02:04:12 <quchen> What’s the formal description of Γ in logical statements such as Γ ⊢ Σ? It’s usually just called “context”, but I don’t understand its structure. In ordinary logic (constructive or classical) I can view it as the set of true things, and ⊢ as an “element” relation. But in substructural logic, a set is not good enough: I might want to have elements multiple times, or in different orders.
02:04:47 <quchen> (Coming from the typing rules of the recently proposed linear logic GHC extension, but the question is general)
02:04:47 <bartavelle> oherrala, I asked because I followed (watching FP beginners) the coursera scala one, where grading is based on grading of user submitted programs, and that was a lot more compelling than those based on multiple-choice thingies
02:05:01 <bartavelle> so I wondered if you could recommend this one
02:05:07 <jophish> Athas: I think you misunderstand, I'm constructing a test for candidates to do to gauge whether they can read documentation and string a program together :)
02:07:32 <oherrala> bartavelle: FAQ says grading depends on the course :)
02:07:42 <bartavelle> nicely informative!
02:13:43 <merijn> quchen: In type theory it's often a set
02:13:46 <hoppfull> Hey, I seem to remember there being a cabal command to install ghc
02:14:02 <merijn> quchen: A set of term variable + type pairs, to be exact
02:14:02 <hoppfull> I just can't find it. I'm starting to doubt my memory.
02:14:29 <ongy> hoppfull: you may be thinking about stack
02:14:34 <merijn> quchen: If, for convenience, we assume not having to deal with alpha-renaming/capture-avoiding
02:14:42 <hoppfull> ongy: That's probably it. Thanks.
02:20:30 <ocharles> People often say that in core, "in general" let allocates and case evaluates. Are there other places evaluation can happen?
02:21:34 <jophish> ocharles: FFI boundary perhaps
02:21:56 <merijn> ocharles: I think it's just case
02:22:02 <merijn> jophish: I think that's still just case
02:22:08 <ocharles> oh sorry, I meant allocation
02:22:12 <ocharles> whoops, that was quite a typo llol
02:22:28 <jophish> ah, thanks merijn 
02:22:28 <merijn> ocharles: Partial application can result in allocating a closur
02:22:41 <merijn> ocharles: See the Fast Curry paper for details
02:22:46 <ocharles> ah, thanks
02:22:54 <merijn> ocharles: Although, I don't think that exists in Core
02:23:15 <merijn> ocharles: When translating Core/STG to assembly you have to allocate closures, though
02:24:12 <merijn> hoppfull: GHC is not a cabalized project, because Cabal depends on the compiler. So clearly you can't build the compiler using Cabal, because then you can never bootstrap :)
02:25:24 <hoppfull> merijn: thanks mate
02:25:32 <hvr`> merijn: GHC as a whole is not cabalized
02:25:47 <hvr`> merijn: but sub-components are :)
02:25:59 <merijn> hvr`: You mean the boot-libraries?
02:26:17 <hvr`> merijn: actually, even the compiler component is a .cabal file
02:26:23 <hvr`> merijn: ghc-bin.cabal
02:26:39 <merijn> hvr`: Oh? I don't remember seeing that last time I looked at the source
02:26:44 <hvr`> merijn: but the problem is the cyclic dependency you'd get when cabal had to build the whole thing
02:27:12 <hvr`> merijn: cabal would have to first build a first stage, and then build a 2nd stage using the first stage as the new compiler
02:40:41 <quchen> merijn: But a set won’t do in, say, linear logic, because if it was one then Γ, x:T = Γ, x:T, x:T.
02:42:42 <merijn> quchen: The linear relationship is normally tracked in a SEPARATE context
02:42:54 <merijn> Lemme look up the slides I read
02:43:41 <merijn> quchen: http://pauillac.inria.fr/~fpottier/slides/fpottier-2007-05-linear-bestiary.pdf
02:44:27 <quchen> A linear type system is one that has neither contraction nor weakening.
02:44:35 <quchen> As far as I know, at least.
02:44:49 <merijn> quchen: Note slide 43, which has a context for types and a separate environment for capabilities
02:44:58 <merijn> quchen: The linearness is enforced by the capabilities
02:45:53 <merijn> quchen: Which, indeed, don't have weakening
02:46:03 <merijn> (I forgot what contraction was, so can't say)
02:51:49 <pavonia> Is there a web service you can upload Cabal packages to and it will try to find the widest range of dependencies' versions your package is still buildable with?
02:52:21 <quchen> merijn: Contraction is throwing away duplicate values/premises
02:52:29 <merijn> pavonia: I thought hvr` had something like that?
02:52:44 <quchen> weakening is adding them
02:55:17 <pavonia> merijn: Any more information about this?
02:55:36 <merijn> pavonia: No, but he was here like 20 minutes ago, so I was hoping he would chime in :p
02:58:41 <dcoutts> pavonia: sort-of, there is matrix.hackage.haskell.org which is a builder service
03:02:37 <pavonia> dcoutts: does this only check for base versions?
03:03:06 <pavonia> or GHC versions rather
03:08:29 <Valoo> Hello
03:08:37 <Cale> Hello!
03:08:40 <liste> hello Valoo 
03:08:52 <ongy> hello
03:09:27 <dibblego> why does lambdabot have @src some but not @src many?
03:09:28 <Valoo> Why does 'putStrLn $ readFile "list"' doesn't work but 'z <- readFile "liste; putStrLn z' does?
03:09:44 <ongy> because @src is a manually managed list
03:09:56 <liste> Valoo: because $ doesn't compose IO actions
03:10:06 <liste> > putStrLn <$> readFile "list"
03:10:09 <lambdabot>  <IO (IO ())>
03:10:15 <liste> > putStrLn >>= readFile "list"
03:10:18 <lambdabot>  error:
03:10:18 <lambdabot>      • Couldn't match expected type ‘IO () -> String -> b’
03:10:18 <lambdabot>                    with actual type ‘IO String’
03:10:23 <jacco> Valoo, because putStrLn returns a "IO String" typed value, while putStrLn expects a "String" typed value
03:11:07 <Valoo> So, doing 'z <- readFile "list"' makes z a (non-IO) String ?
03:11:18 <liste> Valoo: yes
03:11:24 <Valoo> Also, what is the difference between $ and <$> then?
03:11:29 <dibblego> ongy: ta
03:11:39 <jacco> Valoo, yes sort of, please see http://learnyouahaskell.com/input-and-output#hello-world
03:11:47 <ongy> :t ($)
03:11:48 <liste> @undo do { z <- readFile "list"; putStrLn z } -- Valoo, this what do really is
03:11:49 <lambdabot> readFile "list" >>= \ z -> putStrLn z
03:11:49 <lambdabot> (a -> b) -> a -> b
03:11:50 <ongy> :t (<$>)
03:11:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:11:59 <jacco> it explains the difference between things like Strings and IO Strings
03:13:04 <ongy> Valoo: <$> is the infix form of fmap. If that helps you
03:13:25 <liste> Valoo: "do { z <- readFile "list"; putStrLn z }" combines the actions `readFile "list"' and `putStrLn' into one action that reads the file and prints it
03:14:05 <liste> Valoo: that's more than simple nested function calls
03:15:42 <liste> > readFile "list" >>= putStrLn
03:15:45 <lambdabot>  <IO ()>
03:15:58 <liste> so instead of $ you can use >>=
03:16:21 <liste> >>= is the operator that combines actions (it's called `bind')
03:18:55 <Valoo> I am still having trouble understanding monads and some functions like fmap. I am a beginner and I find the doc somewhat spartan.
03:20:17 <liste> @where learnhaskell
03:20:18 <lambdabot> https://github.com/bitemyapp/learnhaskell
03:20:28 <liste> Valoo: what study materials are you using?
03:22:01 <Valoo> I am mostly using a Wikibook (https://en.wikibooks.org/wiki/Haskell) and a tutorial from OpenClassrooms, along with trying to do small projects by myself
03:23:43 <tdammers> relevant: http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
03:25:34 <tdammers> in a nutshell: 1. learn some basic Haskell, 2. learn and understand types and Haskell type signatures, 3. read the types that define Monad (or actually, start with Functor and Applicative)
03:25:57 <tdammers> 4. use actual monads and functors in real-world code until you develop an intuition
03:26:01 <tdammers> that's it
03:27:09 <cocreature> most importantly: just accept that there is not a good analogy and wait until you develop an intuition
03:41:10 <ngWalrus> but basically monads are a lot like jalapeno poppers
03:42:39 <liste> ngWalrus: they're not, they don't taste good :(
03:42:57 <ngWalrus> What kind of monads are you eating :^)
03:44:03 <ongy> IO, it's quite bitter
03:46:09 <knupfer> The docs of GHC.Generics say, that a user shouldn't rely on the nesting strategy of (:+:) and (:*:).  Is it a safe assumption that something like data A = A B C D results in more or less (B:*:(C:*:D))?
03:49:10 <agocorona> my best intuition is that monads are like chemical reaction pipelines: http://thumb101.shutterstock.com/display_pic_with_logo/878986/288859187/stock-vector-chemistry-infographics-template-showing-various-tests-being-conducted-in-laboratory-glassware-using-288859187.jpg
03:53:03 <quchen> Corollary. For each monad analogy, there is a monad that does not follow this analogy.
03:53:35 <quchen> agocorona: Proxy is a Monad, but not a pipeline. Reverse State is a mess, not a pipeline.
03:54:17 <quchen> Unspecified evaluation order means that certain monads can be evaluated from the end of the >>= chain to the beginning.
03:57:36 * hackagebot QuickCheck 2.9.2 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.9.2 (NickSmallbone)
03:58:50 <ertes> knupfer: that's exactly what you shouldn't rely on, but you can rely on the fact that (:+:) and (:*:) are associatve w.r.t. isomorphism
04:00:24 <saurabhnanda> why do people spend so long in explaining monads. Isn't it just a bunch of functions/interfaces that a datatype has to follow?
04:00:37 <ertes> saurabhnanda: correct
04:00:52 <ertes> Monad is like Monoid in that respect:  an API specification
04:01:03 <saurabhnanda> or like a functor
04:01:07 <saurabhnanda> what's the big deal
04:01:15 <parsnip> if i'd like to learn some more haskell, by trying to serve images from a server, what should i start with? Servant? 
04:01:29 <saurabhnanda> I'll tell you the big deal. The big deal is internalising Monads to be able to use it in **your own code**
04:01:38 <liste> parsnip: Scotty maybe, it has the least magic
04:01:43 <saurabhnanda> just like one would be using parameterized data types
04:01:45 <parsnip> liste: thank you
04:02:21 <liste> what do the green version numbers mean in Hackage?
04:03:11 <piyush-kurur> saurabhnanda: there are couple of things that formalising monads helps us understand
04:03:15 <knupfer> ertes: If I've got a product type and flatten every product to let's say an Int via Generics, is the [Int] in the same order as the products of the type?
04:03:38 <saurabhnanda> piyush-kurur: what do you mean by "formalising monads"?
04:04:06 <piyush-kurur> saurabhnanda: the main deal here is not the type class per se but the monad laws that come with it
04:04:24 <piyush-kurur> As with any type class. The main thing is the laws 
04:04:31 <saurabhnanda> piyush-kurur: what about them?
04:04:51 <liste> parsnip: and Spock is a nice next step, it resembles scotty but is more type safe (which means using more advanced type system features)
04:04:58 <piyush-kurur> monad laws abstract the notion of sequential computation
04:05:12 <liste> (and it has more bells and whistles that scotty)'
04:05:39 <ertes> knupfer: usually they follow source code order, but if you rely on that, you will code undefined behaviour…  one way to get some ordering guarantees is to first collect *all* product components and then sort them e.g. by their field names
04:05:46 <saurabhnanda> so, I always wanted to ask this question. What's the point of **explicit** 'return' and 'lift' in code?
04:06:01 <ertes> knupfer: you limit yourself to certain products that way, of course:  it requires named fields
04:06:05 <saurabhnanda> piyush-kurur: do you know of any monad which has a non-boilerplatish 'return' or 'lift' definition?
04:06:51 <piyush-kurur> without return how will you inject something into the monad
04:06:54 <ertes> knupfer: also you have to be careful to use sharing properly in this case, otherwise you will perform that ordering every single time at run-time
04:07:08 <saurabhnanda> piyush-kurur: why do I need to specify it **explicitly**
04:07:33 <piyush-kurur> saurabhnanda: what do you mean by **explicitly**
04:07:36 <piyush-kurur> ?
04:07:37 <saurabhnanda> piyush-kurur: if a certain function is in a monad, and I'm using a non-monadic value, what else can I do apart from 'return' or 'lift' ? why can't compiler inject it automatically during compilation?
04:08:06 <ertes> saurabhnanda: in a sense 'pure' is always boilerplate:  you don't get to choose what your 'pure' is, but the laws dictate it and specify it to be unique
04:08:18 <merijn> saurabhnanda: Because that's a recipe for disaster. You'd never know how your compiler would insert it
04:08:25 <ertes> not sure if that counts for 'lift', too
04:08:29 <saurabhnanda> merijn: isn't there just one way to do it?
04:09:47 <piyush-kurur> saurabhnanda: you mean to say that when ever there is a context where a monadic value is expected and you give the pure version of it you want the compiler to automatically fill in the return?
04:09:56 <knupfer> ertes: Thank you!
04:10:07 <ertes> you're welcome!
04:10:21 <merijn> saurabhnanda: Imagine 'x' is an Int and I write "x True", the compiler infers that I apply "Int" to "Bool", so it decides to lift "x" into the "((->) Bool)" monad by changing it to "(return x) True"
04:10:30 <piyush-kurur> saurabhnanda: I would be very suspicious of such an arrange ment
04:10:39 <merijn> saurabhnanda: Imagine how impossibly confusing the errors you end up getting will be
04:11:46 <merijn> saurabhnanda: Automatically lifting always ends up affecting more expressions than you'd think
04:12:30 <ejbs> I have tuple (A,B,C), how do I get C?
04:12:44 <piyush-kurur> saurabhnanda: consider f :: IO a -> something. And I use f x where x has type IO b
04:12:46 <ertes> ejbs: pattern-matching
04:12:58 <ertes> ejbs: (or a lens, if you already depend on 'lens')
04:13:00 <cocreature> ejbs: case abc of (_,_,c) ->
04:13:11 <piyush-kurur> should return be added to such a context ?
04:13:11 <ejbs> ertes: cocreature: Ok, got it
04:13:33 <saurabhnanda> piyush-kurur: yes. I hate boilerplate
04:14:01 <saurabhnanda> piyush-kurur: please rephrase. missed your question.
04:15:10 <piyush-kurur> I am rephrasing with another monad. f :: Maybe a -> Foo say and x :: Maybe Int. Should I have a return inserted by the compiler in an expression like f x?
04:15:18 <piyush-kurur> that would be insane
04:15:50 <saurabhnanda> doesn't that depend on the surrounding context of 'f x'
04:16:09 <saurabhnanda> what's the monad for the overall 'do' 
04:16:10 <cocreature> no it will always return Foo
04:16:24 <piyush-kurur> what if you made a mistake in the surrounding context?
04:17:18 <piyush-kurur> don't you want the compiler to yell at you ?
04:18:15 <saurabhnanda> piyush-kurur: most functions are written in one monad
04:18:20 <saurabhnanda> piyush-kurur: which is in the top-level type-sig
04:18:28 <saurabhnanda> piyush-kurur: what's the chance of error?
04:18:39 <saurabhnanda> piyush-kurur: uptil now, I've never written a function in two monads
04:19:00 <saurabhnanda> piyush-kurur: if something is in two monads, it inner monad usually becomes a sub-function (either toplevel or in a 'where' clause)
04:19:07 <saurabhnanda> *the inner monad
04:19:10 <piyush-kurur> I do not want to take those chances even if it is small
04:19:19 <saurabhnanda> language extension
04:19:24 <saurabhnanda> -XPragmaticHaskell
04:19:28 <saurabhnanda> :)
04:19:56 <Cale> It's often the case that you want to return another action
04:20:08 <Cale> and sometimes that action is something constructed with return as well
04:20:13 <saurabhnanda> Cale: that's there in the top-level type-sig, right?
04:20:27 <Cale> There might not be a top-level type signature
04:20:36 <Cale> It might be in an argument to a higher order function
04:21:09 <piyush-kurur> saurabhnanda: your suggestion is rather dangerous much like auto truncation in C
04:21:11 <Cale> Just the other day...
04:21:20 <piyush-kurur> I would not want such a "feature" 
04:21:53 <lpaste> Cale pasted “Simple Reflex terminal IO driver setup” at http://lpaste.net/196246
04:22:05 <Cale> That code has a return (return ()) in it :)
04:22:32 <Cale> I think it would be pretty confusing if it just read return (), or (), and the rest was somehow implicit
04:23:13 <piyush-kurur> saurabhnanda: you can avoid a tail return using the applicative notation. (The applicative notation is much more readable)
04:23:38 <Cale> That's not the most interesting example, it's just the last time it happened to me (which happened to be yesterday when I was writing this example for someone :)
04:24:23 <saurabhnanda> well... stuck with type-level boilerplate (return/lift)
04:24:26 <saurabhnanda> and liftIO
04:24:36 <piyush-kurur> for monad transfomers you can have a meaningful names to your lift's. Say you have the monad StateT IO. You can rename lift to doIO
04:24:38 <Cale> I don't see it as boilerplate at all
04:24:40 <cocreature> return/lift is not typelevel
04:25:00 <Cale> return takes a value and constructs the computation which always has that value as the result when you run it
04:25:05 <saurabhnanda> anyways, not the biggest issue with Haskell. 
04:25:08 <ongy> the only thing I see, is that it would be nice to have more things in 'MonadIO m => m a' instead of IO a
04:25:28 <saurabhnanda> Cale: do you have any interesting example of return -- where the function definition is doing something intereting?
04:25:56 <ashishnegi> what Env variable does `stack` uses for ghc ? i have ghc-7.10.3 default, i installed ghcjs with reflex-platform and it messed with "something" and now on every project with no ghc version, `stack` fails to build until i set the resolver to ghc-7.10.3.. it complains about ghc 8 being asked by project but not having in system..
04:27:19 <Cale> saurabhnanda: Oh, in another example that came up recently, I had an STM action which needed to produce an IO action as its result, to be run when the transaction committed.
04:27:44 <saurabhnanda> Cale: I mean the core definition of 'return', not usage of 'return'
04:28:17 <Cale> Well, most of them do *something*
04:28:24 <piyush-kurur> return for list for example
04:28:31 <Cale> or StateT
04:28:36 <Cale> or Parser
04:29:52 <piyush-kurur> saurabhnanda: I am surprised that you think the return in haskell is boilerplate but all the C-like languages you need a return to just define functions
04:29:56 <Cale> It's typically going to be something simple, because of the monad laws
04:30:10 <Cale> return v >>= f = f v, and x >>= return = x
04:31:13 <Cale> So it's not allowed to have too much of an effect -- but nonetheless, it's usually doing some amount of construction, and apart from the identity monad, it's usually going to involve some allocation.
04:31:55 <piyush-kurur> saurabhnanda: consider defining max or min as a function in C. Now that I would call boilerplate
04:31:55 <Cale> In Cont it's basically function application. :)
04:32:25 <Cale> return v = Cont (\k -> k v)
04:33:12 <Cale> and similarly for other continuation-passing-style implementations of monads
04:34:23 <Cale> e.g. for the Prompt monad http://hackage.haskell.org/package/MonadPrompt-1.0.0.5/docs/src/Control-Monad-Prompt.html#Prompt
04:39:00 <saurabhnanda> Cale: that's where my idea is coming from
04:39:07 <saurabhnanda> Cale: in the end 'return' is not doing anything interesting
04:39:14 <saurabhnanda> Cale: it's pretty similar to typecasting for me
04:40:26 <Cale> It's doing something simple, but it is doing *something*.
04:40:40 <Cale> and what it is that it's doing depends on the choice of monad
04:41:22 <merijn> saurabhnanda: Implicit typecasting is also a TERRIBLE idea, btw
04:43:13 <piyush-kurur> saurabhnanda: have a look at http://hub.darcs.net/ppk/calculator/browse/src/calc.hs . See the way I have renamed lift so that the code looks clean
04:44:10 <Cale> saurabhnanda: Let's put it this way: if you were to use unsafeCoerce instead of return, most of the time, your program will segfault
04:47:40 <exio4> there's lot of code outside that doesn't simply need a single "return x" but "return (return x)" and you might not need it.
04:48:03 <piyush-kurur> saurabhnanda: would you be happy if the compiler fills in Just whenever you have used a term of type a instead of type Maybe a?
04:48:43 <exio4> do { x <- a1; a2; y <- a1; return (return y) }
04:50:03 <exio4> do { x <- a1; a2; y <- a1; a2; return (do {w <- a3; if w (return y) else a4}) } -- I don't know, I use return in lots of places :P
04:50:44 <piyush-kurur> exio4: looks like code smell to me are you sure you have got your code correct
04:53:54 <exio4> you might have IO actions returning other IO actions
04:54:14 <exio4> which might do different things depending on variables on its closure
04:55:35 <piyush-kurur> exio4: you might also want to break up large unweildly do body in to smaller functions
04:55:58 <exio4> generateRandGen :: Something -> IO (IO Int) 
04:56:23 <piyush-kurur> which library is that?
04:56:52 <exio4> I am thinking of a possible use case, while working with IO sometimes, things like that are handy ^
04:57:37 * hackagebot inline-c 0.5.5.8 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.8 (FrancescoMazzoli)
04:57:39 * hackagebot inline-c 0.5.5.9 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.9 (FrancescoMazzoli)
04:57:47 <piyush-kurur> exio4: while I cannot deny that you might need such things sometimes, I cannot think of the last time I had some thing like that.
04:59:11 <exio4> piyush-kurur: I don't remember for which exact problem I used this but I will write it down if I use it again :)
05:00:39 <piyush-kurur> exio4: I am curious to see a use case. so let me know when you have one such example.
05:00:49 <piyush-kurur> particularly IO inside IO.
05:01:27 <piyush-kurur> inview of the fact that you have the join operation for monad 
05:01:49 <piyush-kurur> @t join
05:01:49 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
05:02:01 <piyush-kurur> @type join
05:02:03 <lambdabot> Monad m => m (m a) -> m a
05:02:17 <cocreature> piyush-kurur: IO (IO a) can be useful if you are working while having acquired a lock. you can then decide what the inner io action is going to be while you still have the lock but release it before you actually execute it
05:02:44 <cocreature> replace lock by any other resource that you want to acquire temporarely
05:02:54 <knupfer> pixush-kurur: I'm using now a lot of IO (Maybe (IO a))
05:03:32 <piyush-kurur> cocreature: let me think about it. do you have some sample code
05:04:28 <piyush-kurur> knupfer: in what context ?
05:05:01 <cocreature> piyush-kurur: https://blog.melding-monads.com/2015/11/21/announcing-linux-inotify-0-3/ has an example
05:05:04 <knupfer> It's usefull if you want to choose between various actions if the chosing needs IO, but you want to execute the inner IO action only if it matches, and only the first match of a list
05:05:10 <cocreature> join $ withLock bufferLock $ do …
05:07:32 <knupfer> foo :: IO [Maybe (IO a)] -> IO a
05:10:39 <exio4> knupfer: what happens wit that function if it nothing matches? :P 
05:10:41 <exio4> with* 
05:11:11 <knupfer> exio4: consider [Maybe (IO a)] to be an infinite stream
05:11:47 <knupfer> exio4: so it's just fine to call (fromJust . msum)
05:12:18 <piyush-kurur> cocreature: I am happy to see such an example but I would not call this a usual situation
05:12:38 <piyush-kurur> it would be one of the extraordinary situations when you want such a type
05:13:08 <piyush-kurur> note: I am not saying it is wrong but would be surprised if someone is encountering that kind of types very often
05:13:15 <exio4> knupfer: alright, that's better :P 
05:14:32 <cocreature> piyush-kurur: sure I’ve never claimed that you need this all the time. but it is quite useful sometimes
05:15:11 <exio4> also, another example is emulating OOP :P 
05:15:58 <exio4> data Something = Something { something_set :: Int -> IO (); something_get :: IO Int; }
05:17:02 <exio4> newSomething :: Int -> IO Something ; newSomething defValue = do { ref <- newIORef defValue; return (Something { something_set = writeIORef ref; something_get = readIORef ref; }); }
05:19:52 <Arguggi> just to add an example cachedIO uses IO (IO a) https://github.com/SumAll/haskell-cached-io/blob/master/src/Control/Concurrent/CachedIO.hs
05:39:41 <[k-> helloooooo
05:39:52 <liste> hi [k- 
05:40:00 <[k-> :)
05:53:33 <Insanity_> Hey [k-
05:54:57 <saurabhnanda> anyone using opaleye here?
05:55:30 <saurabhnanda> Opaleye users. Quick poll: How much glue code did you have to write to enable common operations on top of the Opaleye API?
05:58:41 <knupfer> Is there a function with :: a -> IO SizeInMemory
05:59:05 <merijn> knupfer: What, exactly, do you need that for?
05:59:31 <knupfer> I want an lru cache which doesn't store an amount of elements but is defined by possible size in memory
06:00:07 <merijn> knupfer: And what if something is stored in it, but not evaluated yet?
06:01:04 <knupfer> merijn: Well, the cache could take only fully evaluated elements
06:03:36 <codedmart> I am seeing this `No instance for (Exception String)`. Shouldn't there be an instance for that?
06:03:43 <merijn> codedmart: Why?
06:03:57 <codedmart> merijn: Guess I assumed :)
06:04:23 <merijn> codedmart: Better of defining a newtype/write a small wrapper for throwIO
06:04:27 <codedmart> Never used exception
06:04:33 <codedmart> OK
06:05:12 <knupfer> merijn: What do you think, is a cache like that possible, or should I just limit the elements and hope for the best?
06:05:28 <merijn> knupfer: Seems like it'd be hard to implement in Haskell
06:06:14 <hpc> i can see such a thing having trouble with knot tying as well
06:06:14 <Xnuk> @hoogle Eq b => (a -> b) -> [a] -> [[a]]
06:06:16 <lambdabot> Data.List.Key group :: Eq b => (a -> b) -> [a] -> [[a]]
06:06:17 <lambdabot> Data.List.Extra groupOn :: Eq b => (a -> b) -> [a] -> [[a]]
06:06:17 <lambdabot> Extra groupOn :: Eq b => (a -> b) -> [a] -> [[a]]
06:07:01 <hpc> as you traverse the things a value references, you have to paint them somehow to make sure you aren't infinitely traversing the same thing referencing itself
06:07:38 * hackagebot constrained-categories 0.3.0.0 - Constrained clones of the category-theory type classes, using ConstraintKinds.  https://hackage.haskell.org/package/constrained-categories-0.3.0.0 (leftaroundabout)
06:07:40 * hackagebot free-vector-spaces 0.1.1.0 - Instantiate the classes from the vector-space package with types from linear  https://hackage.haskell.org/package/free-vector-spaces-0.1.1.0 (leftaroundabout)
06:07:42 * hackagebot ndjson-conduit 0.1.0.4 - Conduit-based parsing and serialization for newline delimited JSON.  https://hackage.haskell.org/package/ndjson-conduit-0.1.0.4 (srijs)
06:07:44 * hackagebot mime-mail-ses 0.3.2.3 - Send mime-mail messages via Amazon SES  https://hackage.haskell.org/package/mime-mail-ses-0.3.2.3 (MichaelSnoyman)
06:07:46 * hackagebot mono-traversable 1.0.1 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.1 (MichaelSnoyman)
06:07:52 <knupfer> hm
06:08:34 <hpc> or maybe you don't and just get the size in memory of the reference, \_ -> return 4 -- ;)
06:08:46 <knupfer> :)
06:09:23 <cocreature> hpc: 8 would probably be more accurate on most systems these days :)
06:09:23 <ggole> Sharing would mean that summing the "size" of every element would give you wrong results anyway
06:10:03 <hpc> cocreature: obviously that code is running on a platform with 16-bit bytes :P
06:10:28 <knupfer> Perhaps I could ask the operating system about the free ram before and after the insertion for a rough estimate
06:11:24 <cocreature> that won’t work, insertion does not copy the element so it won’t allocate it
06:12:07 <ggole> You could require elements to support a size estimate operation
06:12:35 <ggole> Seems better to just go with number of elements tbh
06:12:48 * hackagebot ndjson-conduit 0.1.0.5 - Conduit-based parsing and serialization for newline delimited JSON.  https://hackage.haskell.org/package/ndjson-conduit-0.1.0.5 (srijs)
06:13:26 <nikivi> I wish haskell was taught in european universities
06:13:30 <nikivi> really jealous of uk
06:13:34 <knupfer> I wanted to cache pure responses of a webserver, but the responses could contain from nearly nothing to let's say an image
06:13:49 <merijn> nikivi: There's at least two universities in the Netherlands that teach Haskell...
06:13:53 <hpc> i wish it was taught in US universities
06:14:03 <nikivi> merijn I actually attend a uni in Netherlands, Eindhoven
06:14:06 <hpc> (outside of new england)
06:14:07 <nikivi> and no sign of haskell here 
06:14:18 <merijn> nikivi: You want Utrecht or Twente for Haskell
06:14:40 <merijn> Especially Utrecht
06:14:50 <Cale> knupfer: You could store the bytestrings and just keep track of the total size directly
06:15:28 <merijn> Or have varnish in front of your webserver and have that manage caching of files
06:16:04 <knupfer> Cale: Yes, It'll be a bit more complicated for streams, but perhaps they are anyway to big
06:16:18 <Insanity_> merijn: wouldn't Delft teach it?
06:16:35 <merijn> Insanity_: Don't think they do...what makes you say that?
06:16:44 <merijn> Delft is all wannabe electrical engineers anyway...
06:17:04 <Insanity_> I could be completely wrong but I thought that Erik Meijer was teaching there - and that he actually takes a liking to Haskell
06:17:34 <knupfer> Thank you all, I'll think about it
06:17:49 <Insanity_> Yeah that part confused me :-) I thought it was electrical engineers more than coding. But considering he was teaching there I thought they must have some good compsci courses
06:18:09 <merijn> Insanity_: afaik Erik Meijer is affiliated with Delft, but not teaching?
06:18:38 <Insanity_> Really? I thought that he was teaching one course there at least. I might be wrong though, I'll check
06:18:57 <merijn> He has a part-time professor appointment
06:19:10 <Insanity_> Ah there we go :-)
06:24:13 <m4lvin> nikivi merijn: we have a Haskell course in Amsterdam http://homepages.cwi.nl/~jve/courses/16/fsa/
06:26:03 <Insanity_> Looks like a fun course
06:26:05 <merijn> m4lvin: Which university is that affiliated with? Is it the new joint VU/UvA degree, or?
06:26:29 <m4lvin> we mainly have students from the Master of Logic at UvA
06:26:43 <exio4> Master of Logic sounds fun
06:26:48 <merijn> oh, that's logic...
06:27:03 <m4lvin> but also some computer science people from the VU. I have no idea if that is a joint degree now.
06:27:06 <merijn> For a second there I thought someone snuck functional programming back in the CS bachelor while I wasn't looking...
06:27:53 <merijn> Oh well, guess I'll have to go back to continuing to annoy the administration into putting it back :p
06:29:10 <nikivi> what editor / ide you guys use to write your haskell?
06:29:20 <ggVGc> vim
06:29:23 <saolof> My local college in Gothenburg, Sweden teaches Haskell to CS freshmen as their first language, since it tends to be equally difficult for complete newbies and for people with some programming experience
06:29:25 <ggVGc> to write *
06:29:25 <oherrala> nikivi: emacs
06:29:27 <merijn> vim
06:29:35 <ertes> nikivi: emacs
06:29:38 <merijn> Oh, yeah, Sweden has some Haskell universities too
06:29:39 <Cale> nikivi: Almost anything which can convert tabs to spaces will do, provided you're comfortable with using it.
06:29:48 <saolof> I use emacs with evil-mode
06:29:58 <Cale> I've been using Sublime Text recently, before that I was using vim.
06:30:08 <Insanity_> emacs here
06:30:09 <m4lvin> kate ;-)
06:30:14 <nikivi> Cale what made you switch to sublime from vim
06:30:15 <hpc> or any other editor, if you aren't already in the habit of using tabs
06:30:19 <nikivi> usually its the other way round
06:30:36 <ertes> nikivi: "emacs" is not quite specific enough:  emacs with haskell-mode and haskell-interactive-mode
06:30:51 <exio4> I use nano! 
06:30:51 <dnvriend> Visual Studio Code with lint plugin here
06:31:18 <[k-> brackets here
06:31:18 <Cale> nikivi: Gradually my annoyance with the keys built up -- specifically little things like 'i' for insert and 'u' for undo being next to one another, and there was really nothing tying me to it.
06:31:20 <merijn> ggVGc: I could've told you that based on just your name :p
06:31:32 <ggVGc> merijn: maybe it's a diversion
06:31:47 <nikivi> ggVGc speaking of your name, I think I've seen a screenshot of it somewhere 
06:31:56 <nikivi> about the fact that you can do it shorter or something
06:31:59 <Insanity_> [k- brackets? The web-programming IDE?
06:32:00 <ggVGc> haha..
06:32:06 <[k-> w/ source code pro
06:32:18 <ggVGc> nikivi: well.. http://ggvgc.com
06:32:22 <merijn> nikivi: Yes
06:32:31 <merijn> "ggcG" does the same
06:32:46 <ggVGc> nikivi: it kept happenign so often I made a paste out of it, then it became a factoid in #vim, then I gave it a domain
06:33:09 <nikivi> ggVgc so you are a big irc user I see :)
06:33:23 <Cale> Despite the fact that I've been using vim for like 15 years, I still don't really use many of its features apart from the things which practically any text editor will have.
06:33:37 <merijn> Cale: I use movement *a lot*
06:33:43 <ertes> is ggVGc a vim command or something?
06:33:45 <merijn> Cale: That's the main value
06:33:53 <merijn> ertes: It's a string of commands
06:34:01 <ertes> gg, VGc, like that?
06:34:04 <merijn> ertes: 'gg' jump to first line, first column
06:34:34 <Cale> merijn: I use the arrow keys, home, end, and page up/down. :D
06:34:42 <Cale> That's about it :)
06:35:04 <merijn> ertes: 'VG' is line visual mode (V - selecting entire lines) combined with 'G' (movement to end of line at end of file)
06:35:11 <ggVGc> Cale: wich is funny since pretty much no vim user uses the arrow keys
06:35:19 <merijn> ertes: 'c' is "erase selected text and enter insert mode'
06:35:20 <ggVGc> but whatver gets your job done
06:35:32 <ertes> i see
06:35:39 <merijn> Cale: Right, so you've not actually been using vim ;)
06:35:49 <Cale> ggVGc: On the other hand, I have used hjkl for *games*
06:36:30 <ertes> i'm not going to change my nick to the emacs equivalent of that =)
06:36:40 <Cale> (especially dogfighting-in-space sort of games where you have 4 strafe directions and then yaws and rolls)
06:36:48 <frontendloader> I like sublime's multiline edit mode a little better than vim
06:36:59 <merijn> ertes: The shorter 'ggcG" would simplify this into 'gg' and 'cG' which is "change (delete and enter insert mode)" combined with the 'G' movement, which has the same effect of deleting the entire file and entering insert mode
06:37:00 <frontendloader> or multicursor if you wanna call it that
06:37:18 <Cale> Yeah, the multiple cursors thing I thought was a bit gimmicky at first, but it is handy quite a lot while working on Haskell code
06:37:36 <merijn> That's like block-visual mode, yeah?
06:37:39 <Cale> no
06:37:41 <Cale> But kinda
06:37:59 <Cale> It literally gives you multiple cursors, and typing will insert text at all of them
06:38:07 <Cale> (or delete, or whatever)
06:38:16 <frontendloader> it's good for refactoring/renaming things within a scope
06:38:23 <frontendloader> when you don't want to find/replace across the whole file
06:38:38 <merijn> Cale: Looks like something I'd replace with macros
06:38:41 <nikivi> so how did you guys get introduced to haskell
06:38:45 <nikivi> I am curious
06:39:02 <hpc> vim can do replacement within a visual range
06:39:05 <frontendloader> I saw some haskell code once and was like "what the hell does that even do"
06:39:12 <frontendloader> the rest is history
06:39:18 <exio4> nikivi: some friend talked about it, after we did a functional programming MOOC.
06:39:36 <hpc> i would expect it to be best used for things like modifying multiple cases that are layout-indented differently
06:39:37 <ertes> i had a multiple-cursors extension for emacs, but uninstalled it…  i can see how they can be useful, if you have highly irregular text (manually mark all the spots where cursors should be, then edit), but i don't seem to encounter cases that can't be done better and safer with macros
06:39:57 <Cale> I got introduced to Haskell around 2001 when I mentioned to an acquaintance that I was interested in algebraic approaches to music theory, and he pointed me at Paul Hudak's work on Haskore
06:40:27 <merijn> hpc: Sure, but that's where macros with movements are well-suited
06:40:57 <hpc> yeah
06:41:08 <ertes> the same guy who wrote the multiple-cursors extension also wrote a "mark multiple" extension that gives you multiple regions at the same time…  again: nice idea, but never really found a use case for it
06:41:13 <hpc> usually i don't even go all the way to macros
06:41:21 <nikivi> so is computer music really a thing
06:41:37 <hpc> i have my terminal set to paste on right-click, so i just write the "macro" i want into notepad, copy it, then right-click until i am happy
06:41:56 <hpc> i have done that maybe 3 or 4 times in my whole vim career
06:42:06 <ertes> nikivi: half the popular music would qualify as "computer music" =)
06:42:21 <hpc> all of those times on html of all things
06:42:32 <merijn> hpc: I do "qq" to start recording, fix the first line and position cursor for next one" hit 'q' again to end recording, then "@q" to run macro and then just keep doing "." to rerun it :)
06:46:02 <hpc> oh right, that thing
06:46:02 <ertes> i think you can name your macro "@" in vim
06:46:02 <ertes> q@, @@
06:46:02 <merijn> ertes: No, @@ is "replay last macro"
06:46:02 <ertes> ah
06:46:02 <Cale> Though Haskore isn't quite the sort of thing I was thinking of, it's a straightforward approach to representing music in a combinator library sort of fashion, where you start off with single notes, and then you can compose them serially or in parallel, and then there are various operations for acting on chunks of music built up like that.
07:06:21 <quchen> Would it be illegal to evaluate `undefined >> Nothing` to `Nothing` for a Haskell implementation?
07:06:23 <quchen> If so, why?
07:07:02 <quchen> http://lpaste.net/196459
07:07:11 <quchen> This would be one reduction strategy.
07:07:13 <merijn> quchen: Strictly speaking? Yes
07:07:19 <merijn> quchen: Morally? No
07:07:20 <quchen> I’m not sure the last transformation is valid
07:07:35 <codedmart> Isn't try suppose to catch exceptions? I am playing around with some different things and I don't get why try seems to not be doing anything for me.  When I use https://gist.github.com/codedmart/2bf8f0d070c0efedc06a2ab34752580d#file-main-hs-L1-L7 in ghci I expect to see  `r` printed then my `Left` message. But I see `*** Exception: JSONError ...` from line
07:07:35 <codedmart> 41?
07:07:40 * hackagebot jukebox 0.2.8 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.2.8 (NickSmallbone)
07:07:42 * hackagebot hOpenPGP 2.5.2 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.5.2 (ClintAdams)
07:07:48 <quchen> Since Maybe is algebraic, does `case` not have to scrutinize it?
07:07:51 <c_wraith> quchen: it would depend on how strictly (pun intended) you hold to the law that a >> b === a >>= \_ -> b
07:07:55 <merijn> quchen: Fast and Loose Reasoning is Morally Correct!
07:08:16 <quchen> c_wraith: Even if that law holds
07:09:31 <quchen> See my paste
07:09:44 <soLucien> hello guys ! I'm having trouble importing a module when using ghci
07:10:06 <lyxia> quchen: I don't think the last transformation is valid
07:10:31 <Insanity_> soLucien: what seems to be the problem?
07:11:10 <c_wraith> quchen, (>>=) needs to perform a case analysis of its first argument before it knows what constructor it is returning 
07:11:35 <quchen> c_wraith: Not if the compiler knows that all branches yield the same result
07:11:45 <quchen> The question is now whether it’s valid to optimize that away
07:13:08 <quchen> Probably not. At least the formal semantics in the Report doesn’t say anything about it.
07:13:51 <codedmart> Does try not work in ghci?
07:15:41 <soLucien> hi guys ! I am having touble using the Import statement on a file located in a relative path
07:15:52 <soLucien> what could it be, and how do i fix it ?
07:16:31 <soLucien> basically i have SubsInterpreter.hs which does 'import SubsAst' 
07:17:01 <soLucien> SubsAst is located in the same folder as SubsInterpreter.hs
07:17:11 <c_wraith> soLucien: module names are never relative
07:18:04 <lyxia> codedmart: why wouldn't it
07:18:08 <c_wraith> soLucien: if you have modules Foo.Bar and Foo.Baz, and want to import the former into the latter, it's still import Foo.Bar
07:18:38 <c_wraith> soLucien: what directory the modules are located in is irrelevant to import names. (It is relevant to ghc finding the files)
07:22:18 <soLucien> c_wraith sorry i got disconnected
07:22:21 <soLucien> so you were saying
07:22:25 <soLucien> module names are never relative
07:22:43 <soLucien> what am I supposed to do in order to make Haskell load the files in a certain directory ?
07:22:50 <soLucien> i am running "stack ghci ..."
07:23:07 <c_wraith> soLucien: Name the modules correctly, set your source directory correctly.
07:23:10 <tdammers> I don't think the language itself facilitates this at all
07:23:28 <tdammers> there is no "import all modules in this directory" language construct
07:24:00 <soLucien> ok .. how do i set the source directory ?
07:24:02 <tdammers> I believe you *can* pass source filenames to ghci explicitly on the command line though
07:24:18 <soLucien> cool , stack ghci -h is not really helpgul
07:24:21 <tdammers> source directory is typically defined in your .cabal file
07:24:33 <soLucien> i don't have that.. should i create one ?
07:24:41 <tdammers> depends... if you're working on a project, yes
07:24:47 <soLucien> it's a uni assignment
07:24:55 <soLucien> not really a project
07:25:01 <soLucien> it's a javascript interpreter assignment :)
07:25:12 <soLucien> but i'm not going to share it with anyone
07:25:13 <tdammers> (btw., there's an ongoing discussion on the haskell-cafe mailing list wrt project-based vs. compiler-based workflows, and how stack is optimized for a project workflow)
07:25:23 <soLucien> just want to get things going
07:25:27 <tdammers> sharing is an orthogonal concern
07:25:29 <codedmart> @lyxia: did you see my previous question a little ways back? I plaster a gist with it.
07:25:29 <lambdabot> Unknown command, try @list
07:25:53 <soLucien> any suggestions  ? 
07:25:55 <codedmart> *Posted
07:25:56 <tdammers> if your plan is to build an application or library eventually, might as well set up a stack project right now and use that as your environment for experimentation
07:27:55 <soLucien> i tried :load SubsAst.hs followed by :load SubsInterpreter.hs
07:28:45 <c_wraith> If you have multiple modules, you probably should have a cabal file.
07:28:51 <soLucien> when i load the interpreter, it says it does not find SubsAst
07:29:39 <c_wraith> soLucien: try putting them both in one :load line
07:30:12 <c_wraith> That won't solve your problem, but it would at least get them both in scope at the same time.
07:30:17 <soLucien> it worked
07:30:47 <umib0zu> Is there a socket library for haskell to communicate between browser and server code?
07:30:52 <c_wraith> Ok, maybe it will solve the problem. :)
07:31:17 <c_wraith> umib0zu: It feels like there are hundreds. :)
07:31:21 <jonored> import also works iteratively on the ghci commandline.
07:31:36 <c_wraith> jonored: import and load are not the same thing, though
07:33:08 <jonored> c_wraith: True - load brings in things that aren't exported, I think?
07:33:25 <c_wraith> jonored: sometimes.
07:33:32 <lyxia> codedmart: you are catching HttpExceptions
07:33:35 <tdammers> umib0zu: sockets don't work between browsers and web servers. You're looking for websockets
07:33:44 <lyxia> codedmart: is JSONError one?
07:33:48 <c_wraith> jonored: It will do that if it interprets the file, instead of loading it from  a .hi and .o file
07:33:49 <tdammers> umib0zu: I believe there's a library that implements them on top of WAI
07:34:11 <Guest35292> A design question here: I have a PlayerType data type that is just a collection of methods. Each method of each player type should accept some kind of config as a parameter. I have a PlayerConfig data type with different constructors, each for each player type. But each player type should only be able to work with one of these constructors. How could I redesign this?
07:34:11 <[k-> Insanity_: yes, but whether it can be considered an IDE, I don't know
07:34:22 <Insanity_> I'd say it is
07:34:27 <tdammers> umib0zu: http://hackage.haskell.org/package/wai-websockets
07:34:30 <c_wraith> jonored: but the big difference is that loading is for *files*.  importing is for *modules*.
07:34:31 <Insanity_> I liked it, used it a couple years back when it was in beta
07:34:38 <umib0zu> thanks I’ll check it out
07:34:53 <[k-> that is if you work with web stuff though
07:34:59 <c_wraith> jonored: that means you can import things from packages that are visible, even if you don't know where a file is located.
07:35:07 <codedmart> lyxia: Hmm... ok I guess that makes sense when you put it that way.
07:35:09 <[k-> if you don't, then it's just a glorified text editor 
07:35:14 <tdammers> umib0zu: there's also http://hackage.haskell.org/package/MFlow, which IIUC takes a holistic approach - haven't played with it myself though
07:35:29 <c_wraith> jonored: it also means you can do things like load a bunch of files, but only import some of them into scope.
07:36:13 <soLucien> okay what does the arrow mean when you define a type ? 
07:36:22 <soLucien> type Primitive = [Value] -> SubsM Value
07:36:41 <Cale> A -> B is the type of functions which accept an argument of type A, and produce a result of type B
07:36:46 <codedmart> @lyxia No JSONError is one of my errors that I created.
07:36:46 <lambdabot> Unknown command, try @list
07:37:42 <lyxia> codedmart: then you need to specialize "try" to catch your error
07:38:11 <codedmart> lyxia: Maybe this is a stupid question but can I catch both?
07:38:23 <codedmart> New to the exceptions thing.
07:38:44 <lyxia> codedmart: call try twice
07:40:14 <merijn> You can actually do surprisingly complex things
07:40:55 <merijn> I recommend reading "An Extensible Dynamically-Typed Hierarchy of Exceptions" which explains all the fancy stuff you can do
07:41:31 <merijn> codedmart: Including, how to create "subclassing" so you can say "these three error types are in one class and I want to catch everything in that class"
07:41:56 <merijn> PDF here: http://community.haskell.org/~simonmar/papers/ext-exceptions.pdf
07:42:18 <codedmart> merijn: OK Thanks
07:44:27 <codedmart> lyxia: Thanks!
08:03:36 <pflanze> Hey. Is there a good idiom for handling expensive calculations whose results are to be shared for efficiency?
08:04:43 <pflanze> My example right now: a purely functional collection of objects that also allows to access them by field value, indexing the field to be searched on demand.
08:04:44 <merijn> pflanze: Name them
08:05:05 <merijn> pflanze: "let x = myExpensiveCompution in {- x appears here multiple times -}"
08:05:10 <Cale> pflanze: Well, depending on what you mean -- any expression which is bound to a variable will be evaluated at most once, and the result of any evaluation which is done will be shared between the occurrences of the variable.
08:05:12 <merijn> pflanze: Or inside a where clause
08:06:18 <Cale> One trick which might not be terribly obvious until you've seen it is that you can have arrays whose entries are determined lazily in a way which uses other entries in the array (recursively).
08:06:54 <pflanze> What I mean is I've got a value x somewhere (state somewhere, i.e. in a monad). I might need a value y which is derived from x and expensive to calculate; so I want to reuse the result.
08:06:58 <Cale> and then when any particular entry in the array gets evaluated, it will remain so, which is useful when you want to do a dynamic programming sort of algorithm
08:07:14 <pflanze> But y changes when x changes so y is worthless once x changes.
08:07:21 <Cale> ahhh
08:07:29 <pflanze> I mean, the previously calculated y becomes worthless.
08:07:31 <bek> hello i'm haskell beginner, and i need some help with implimenting a mesh data structure, i woud like to be able to :
08:07:39 <bek> 1)update single value in the mesh
08:07:41 * hackagebot servant-purescript 0.4.0.0 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.4.0.0 (eskimo)
08:07:43 * hackagebot code-page 0.1 - Windows code page library for Haskell  https://hackage.haskell.org/package/code-page-0.1 (ryanglscott)
08:07:44 <Cale> So I kind of want to say that you're looking for FRP :)
08:07:45 * hackagebot linearmap-category 0.1.0.0 - Native, complete, matrix-free linear algebra.  https://hackage.haskell.org/package/linearmap-category-0.1.0.0 (leftaroundabout)
08:07:47 * hackagebot dimensional 1.0.1.3 - Statically checked physical dimensions,  using Type Families and Data Kinds.  https://hackage.haskell.org/package/dimensional-1.0.1.3 (dmcclean)
08:07:47 <bek> 2)update multiple values in the mesh (from array)
08:08:08 <bek> 1)update single value in the mesh 2)update multiple values in the mesh (from array) 3)update multiple values in the mesh (using a function) 4)have good (read / write) performence 5)to be able to do point (2 3 4) in parallel
08:08:30 <pflanze> It's just x and f x, where I want f x to be memoized.
08:09:00 <Cale> That's sort of a heavy-handed solution to your issue, but it's sort of the logical conclusion of that kind of "something has updated and all the things which depend on it are now invalid and will need recomputing, please take care of keeping track of this for me" scenario.
08:09:02 <bek> i tryed to use repa but it does not have function to do the firt point
08:09:04 <pflanze> But additionally, f x *can* be reused, i.e. I could write an f' which takes the new x and the old y and calculates the new y
08:09:18 <pflanze> Cale, hmm hmm.
08:09:40 <pflanze> Kinda interesting way to frame it, FRP.
08:09:44 <Cale> (that's basically what reflex *is*)
08:10:21 <pflanze> Yeah I should look into that.
08:10:44 <Cale> a whole bunch of fancy stuff keeping track of which things depend on which other things, and which cached behaviours are still valid and which will need recomputing if their value is demanded
08:11:13 <Cale> That's the low-level view of it, anyway
08:11:45 <pflanze> I was hoping to just have some sort of monad magic. But perhaps FRP *is* in a monad? Need to find out.
08:11:48 <Ethilin> Hello>
08:12:09 <Cale> pflanze: There's a few different monads which are involved, and some functors
08:12:18 <dmj`> class MonadMagic m
08:12:45 <Cale> pflanze: A basic idea of FRP is that there are (at least) two basic ways in which you can have something which changes over time:
08:12:55 <Cale> You have things which always have a value whenever you care to look at them
08:13:43 <Cale> Things like the current position of the mouse, the current contents of a text field, the current hitpoints of a monster, the current scene graph to be displayed on the screen, or even the current time
08:13:54 <Cale> These are referred to as "behaviours"
08:14:17 <bek> can anyone help please
08:14:22 <Cale> and they're basically "pull-only", they might change more quickly than you have the ability to observe them (or even continuously)
08:14:51 <Cale> bek: I might be able to help in a little bit, hang on :)
08:14:57 <Cale> (if nobody else does)
08:15:21 <Cale> pflanze: and then you have things which occur at particular moments in time, and have a value at those times
08:15:30 <bek> ok tank you
08:15:38 <bek> thank you
08:16:15 <Cale> Things like the sequence of keystrokes or mouse clicks, the sequence of updates to a text field, the sequence of requests made to a server, or responses coming back, the sequence of attacks made by a monster, the sequence of audio clips to be played, and so on.
08:17:03 <Cale> Those are generally referred to as "events" -- any one event value referring to a sequence of values occurring at particular points over time
08:17:54 <Cale> They're "push-only", you're notified when a new value arrives, and basically have to do something with it right then, or it will be gone.
08:18:22 <Cale> and then there are a bunch of operations for combining together events and behaviours to form new events and behaviours
08:19:05 <Cale> Both Event and Behavior are functors, and Behavior is additionally a monad.
08:19:20 <pflanze> Ok, cool.
08:19:33 <pflanze> Need to play with that.
08:19:44 <pflanze> Thanks!
08:20:47 <Cale> There are a bunch of different FRP libraries which capture these ideas in different ways. My favourite right now is called reflex, and right now its major application is reflex-dom, a library for building web application UIs
08:21:01 <Cale> https://github.com/reflex-frp/reflex-platform has a tutorial and instructions to get started
08:22:34 <Cale> But yeah, the reflex library more generally can be used to handle these sorts of interactions in other settings, and so we hope to eventually have not only libraries built on top of reflex for interacting with other sorts of GUIs, but also for, e.g. lots of server and database-related tasks
08:23:51 <Cale> https://www.youtube.com/watch?v=dOy7zIk3IUI -- there's a good overview talk about it here too :)
08:24:42 <pflanze> cool, thanks!
08:25:13 <exio4> Cale: you seem like a good investment when it comes to marketing, eh :p 
08:25:26 <Cale> hehe
08:27:08 <Cale> Well, Ryan and I worked on a bunch of earlier FRP systems at iPwn Studios, and a lot of the ideas we had there about how FRP should work and how to implement it have made it through to Reflex. So while I haven't directly had much hand in creating Reflex, I'm quite happy to see it get some use out in the world.
08:28:28 <Cale> (and perhaps I'll contribute some to it myself in time)
08:33:39 <mizu_no_oto_work> Cale: were you guys in Boston when you were working on iPwn?
08:34:24 <JohnTalent> A Monad is an ID coupled with the ability to return that ID. Simple.
08:35:12 <Cale> mizu_no_oto_work: Ryan was
08:35:22 <Cale> I was up in Canada same as now
08:35:33 <MarLinn> reflex might be good but the reflex-dom+ghcjs approach is horrifying tbh... But I guess instead of cowering in fear I should come up with good alternatives to stop it... XD
08:35:49 <ggVGc> I MarLinn why is it horrifying?
08:36:01 <mizu_no_oto_work> JohnTalent: What do you mean by 'ID'
08:36:15 <Cale> bek: Still around? You had a bunch of questions about how to represent data?
08:36:41 <JohnTalent> mizu_no_oto_work: Identification.
08:36:58 <ggVGc> that doesn't sound like a monad to me
08:37:04 <mizu_no_oto_work> Nor to me
08:37:19 <JohnTalent> ggVGc: How is it not?
08:37:41 <ggVGc> well, I'm not great with CS or haskell, but I don't see any way in which it is
08:37:48 <Cale> MarLinn: I've found reflex-dom quite fun to use, personally. There are some sharp edges where it comes into contact with the DOM API and you need to implement new primitive widgets, you have to think about what it is that you're doing somewhat carefully, but that's hard to avoid.
08:37:48 <ggVGc> a monad carries a context
08:37:51 <ggVGc> in my view
08:37:51 <bek> yes , i'm here
08:37:55 <JohnTalent> ggVGc: Let me know when you want to disprove it.
08:38:12 <JohnTalent> ggVGc: Yes, it's context is it's unique ID.
08:38:34 <ggVGc> then why call it an ID rather than context?
08:38:47 <mizu_no_oto_work> What is the Id in the List monad?
08:38:50 <ggVGc> an ID sounds like something rigid and immutable to me
08:39:08 <bek> i'll pastbin my code so you can see what i want to do
08:39:19 <JohnTalent> If a Monad didn't have an ID, it would not be a Monad. :)
08:39:23 <mizu_no_oto_work> Or the `(->) r` monad?
08:39:34 <mizu_no_oto_work> JohnTalent: Why not?
08:40:13 <JohnTalent> mizu_no_oto_work: Because without an ID it would only return and nothing else.
08:40:21 <Cale> bek: Yeah, repa doesn't make it easy to modify a single element because anything which does a bunch of that is going to destroy performance generally
08:40:42 <Cale> (particularly when it comes to parallelising operations)
08:40:42 <JohnTalent> I can't stand people who try to make ivory towers of sciences. Say it , say it simple and move on to bigger and better things.
08:40:43 <ggVGc> if I have a computation in the list monad, and the current context is [1,2,3], and another computation where the context is also [1,2,3], it doesn't seem unique to me
08:41:12 <mizu_no_oto_work> JohnTalent: What do you mean 'it would only return and nothing else'?
08:41:16 <MarLinn> ggVGc: html is harmless, css is harmless. Both together can achieve great things in purity, performance, and safety, and a bit of js can improve thing greatly. But reflex-dom and ghcjs make it too easy to replace this simple working system with throwing huge blobs of unnecessary, unauditable code at my poor tiny box with my poor struggling connection
08:41:33 <Cale> JohnTalent: I disagree with your definition of what a monad is. How is the type of lists an ID together with an ability to return that ID?
08:41:53 <JohnTalent> ggVGc: One comes before or after the other computation, it's position in the program and the sequence is known by the process of computation..
08:42:02 <ggVGc> JohnTalent: this is not an ivory tower. This is literally no one understanding what you mean
08:42:09 <Zekka> (in class, but passively spectating -- I haven't seen john's description before and am curious about it)
08:42:11 <Cale> JohnTalent: How many examples of monads have you come across? Can you list some?
08:42:27 <Zekka> JohnTalent: can you write some code that uses your description?
08:42:31 <bek> http://pastebin.com/BW9aQrCY
08:43:09 <Zekka> your ID sounds suspiciously like (whatever type)'s monad instance to me, but I don't trust myself
08:44:20 <JohnTalent> Cale: If a Monad doesn't have the ability to identify itself to it's language or intepreation, what can this type of new Monad do?
08:44:46 <JohnTalent> Zekka.... As in infants witout skulls?
08:44:48 <nitrix> Is ID and the concept of Identity being conflated here?
08:45:34 <Zekka> JohnTalent: You keep mentioning properties that sound like they could be uesful but I don't totally know how you get to them
08:45:58 <JohnTalent> nitrix: yes, identity.
08:46:00 <JohnTalent> sorry.
08:46:00 <Cale> JohnTalent: I mean, monads have names, but I think somehow that you're missing most of the actual definition...
08:46:01 <JohnTalent> ha.
08:46:06 <nitrix> JohnTalent: A monad only need object and morphisms. Additionally, you have laws of identity and composition.
08:46:10 <JohnTalent> I mean't identify instead of ID.
08:46:10 <ggVGc> the best part of monads is that they let you use do-notation in haskell!
08:46:15 <Cale> nitrix: ... what
08:46:17 <sm> MarLinn: sounds like it's sure to catch on then :)
08:46:20 <Zekka> I think your design sounds like "let's treat every monad instance as a name" -- so, instance Monad [] might have one ID, and instance Monad Reader might have another ID
08:46:35 <Cale> nitrix: I think you just... started describing a category?
08:46:39 <nitrix> Cale: Whoops
08:46:42 <JohnTalent> sorry, identity.
08:46:44 <JohnTalent> ha.
08:46:45 <nitrix> Cale: I'm sleepy.
08:46:58 <nitrix> But the Identity vs. ID point still hold.
08:47:02 <bek> i was wandring if i can  maps without sacrificing performence
08:47:05 <mizu_no_oto_work> JohnTalent: What do you mean 'identify itself to it's language or intepreation'?  In what sense does the monad for `(->) r` identify itself?
08:47:18 <Cale> JohnTalent: Okay, so do you know what a parametric type is?
08:47:23 <nitrix> JohnTalent: I think it's less of a ivory tower than you using terminology no one is familiar with.
08:47:28 <Zekka> I still feel like code (or at least pseudocode) would work here
08:47:34 <JohnTalent> Amoungst our Monad weaponry is 1) and identity 2) the ability to return 3) nice red uniforms.
08:47:55 <myridium> I have a quick question for you folks about the syntax of Cost Center Modules. In the expression: "({-# SCC cc1 #-} foo $  {-# SCC cc2 #-} bar)", does the cost center module "cc1" measure the time it takes to evaluate "foo bar", but not the time taken to evaluate "bar"?
08:47:59 <Zekka> because it sounds like you hvae a specific idea of "it would be nice to have these properties" but I'm not totally sure what those properties are or how you get them
08:48:05 * ski stares blankly
08:48:06 <MarLinn> sm: That's what makes it so horrifying... -_-
08:48:08 <ejbs> http://lpaste.net/206786826873077760 how is this wrong? I get the infinite type error but it seems like it all lines up :/
08:48:15 <ejbs> (first time using do-notation)
08:48:27 <mizu_no_oto_work> JohnTalent: do you know what 'return' does in the context of a monad?
08:48:41 <Zekka> ejbs: What's the type of readSequence?
08:48:51 <nitrix> ejbs: Give a type signature to readSeqs.
08:49:17 <Cale> myridium: I think it measures both -- in the profile you'll see both the individual and inherited time
08:49:39 <Zekka> (fyi a common debugging step in this case, ejbs, is to attach typesigs to things until you figure out where Haskell disagrees with you)
08:49:48 <myridium> Cale: Are you the same Cale from #math ?
08:49:53 <Cale> myridium: yes
08:50:07 <ejbs> Zekka: String -> MolSeq
08:50:11 <ejbs> I'll try that out
08:50:34 <myridium> Hmm in the .prof file, it's not indented in a way that makes it look inherited
08:50:40 <Zekka> Sorry, wish I could have given you something more specific
08:50:52 <nitrix> JohnTalent: I think you can probably just simplify monads to  join :: m (m a) -> m a.
08:50:56 <Cale> myridium: ah... that's interesting
08:51:08 <myridium> Ah, you know what, cc1 has less time than cc2. Herp
08:51:15 <Cale> ah, okay
08:51:22 <Boomerang> ejbs: are you sure you want to declare "lines" as a variable? Or is that the lines from Prelude you're trying to use?
08:51:29 <Cale> So it really is just measuring the time spent on the function itself then
08:51:46 <nitrix> JohnTalent: At least, as far as Hask is concerned.
08:51:52 <ejbs> Boomerang: Oh dear, I guess that'd shadow that function
08:51:53 <mizu_no_oto_work> JohnTalent: And what exactly do you mean by an identity?  The ability to do reference equality or something?  The ability to have a label on an expression inside the compiler? Something else?
08:51:56 <Cale> myridium: What happens if you add another SCC outside the parens there?
08:52:10 <ejbs> Boomerang: HAha yeah, now it works
08:52:15 <Boomerang> :D
08:52:20 <ejbs> lines -> lines' did the trick :)
08:52:30 <JohnTalent> mizu_no_oto_work: By identify, I of course mean a data value or some sort.
08:52:36 <JohnTalent> Identity.
08:52:37 <JohnTalent> sorry.
08:52:46 <JohnTalent> s/or/of
08:52:51 <myridium> Cale: Seems so. I was unsure about whether it would stop to the left of the "$". Documentation says " An SCC annotation extends as far to the right as possible when parsing." I will test an exterior CCM in a second
08:53:02 <nitrix> JohnTalent: I find `join :: m (m a) -> m a` more descriptive, even without the laws.
08:53:35 <nitrix> JohnTalent: You could actually even come up with sane monad laws by yourself just by thinkering with the type annotation.
08:53:35 <mizu_no_oto_work> JohnTalent: That is to say, your object contains some sort of data, regardless of what you're able to do with said data?
08:53:37 <Cale> myridium: Yeah, I expected it to scope over the ($) as well
08:53:58 <JohnTalent> nitrix: That example is a monad. but it is not *the* Monad.
08:54:24 <nitrix> JohnTalent: It's monad as per the Hask category.
08:54:36 <nitrix> JohnTalent: What other Monad are you referring to?
08:54:47 <JohnTalent> mizu_no_oto_work: do you know what a Monad is?
08:55:45 <myridium> Cale: Well I ran it again like "{cc1} foo ({cc2} bar $ {cc3} sheep)". Result is that it is indented in the log file, as though cc3 inherits from cc2 from cc1. However time spent on cc3 > cc2 > cc1
08:55:56 <JohnTalent> nitrix: If a Monad is self referencing it is already an extra process, typically though such a beast would be useful in renentrant or recusive functions.
08:56:19 <nitrix> JohnTalent: Self referencing?
08:56:20 <bennofs> Is there a predefined function to run a state computation with the state from another state computation, but discarding its changes?
08:56:30 <JohnTalent> It appears to me, you people are more interested in what I know that what actually is.
08:56:43 <myridium> Cale: Wait no, I'm stupid, I was looking at Individual time. Both are displayed. Yes they DO inherit.
08:56:45 <JohnTalent> Lemon Curry?
08:56:56 <bennofs> It would work like: discardState action = do saved <- get; action <* put saved
08:56:59 <mizu_no_oto_work> JohnTalent: A monad is a monoid object in a monoidal category.  In Hask, one example of a monad is isomorphic to a triple of functions (pure :: a -> m a, join :: m (m a), map :: (a -> b) -> m a -> m b).
08:57:20 * ski . o O ( .. "thinkering", hmm )
08:57:59 <JohnTalent> A monad is a monad. Beautiful, carry on, because we all know Monads are hard to describe. </cheekyness off>
08:58:44 <nitrix> Describing them by not describing them seems like easy way out when they're the subject of the discussion.
08:58:49 <ertes> the Monad type class actually does a decent job explaining them
08:58:58 <ski> (s/a monoidal category/the monoidal category of endofunctors/)
08:59:18 <mizu_no_oto_work> ski: I was just about to make that correction >_<
08:59:18 <nitrix> mizu's description is on point, excepted the `pure` and the `map` are already convered by `Functor` and `Applicative` which our class Monad represents nicely.
08:59:27 <JohnTalent> ski: yes, i've seend that slide too. :)
09:00:18 <nitrix> (Via the constraints)
09:00:19 <JohnTalent> s/syntax keyboard error/
09:00:35 <myridium> So what are some applications of Haskell in the domain of computer science/mathematics? Is it used in anything like Theorem Provers?
09:00:46 <nitrix> myridium: Rarely ever.
09:01:04 <JohnTalent> A Monad is essentially an Envelope.
09:01:06 <myridium> Tell me it's useful for something at least :P
09:01:12 <nitrix> myridium: Agda and Coq are better suited for theorem proving.
09:01:29 <nitrix> myridium: One of the reasons that I know, is that the laws in Haskell aren't enforced/verified by the compiler.
09:02:09 <myridium> I thought that Haskell was strongly typed? What else could the compiler enforce that it doesn't?
09:02:12 <slack1256> there is much more math outside of theorem provers though
09:02:41 <slack1256> I intent to use the diagrams library for my topology diagrams presentation
09:02:51 <nitrix> myridium: Sure. The type system is one of the strong points of the language (despite people whishing we had dependent typing too).
09:03:09 <myridium> slack1256: To generate the data? How will you generate the diagrams themselves from this data?
09:03:11 <Zekka> JohnTalent: fwiw I think that's an acceptable analogy but it also means different things to different people
09:03:15 <nitrix> myridium: But verifying mathematical laws is beyond what types can do.
09:03:16 <mizu_no_oto_work> JohnTalent: That's sounds like 'a monad is a burrito/spacesuit/barrel for nuclear waste'
09:03:31 <Zekka> a monad isn't literally an envelope, of course, because envelopes are physical objects and monads are not
09:03:40 <JohnTalent> Zekka: Isn't that the beauty of art inside of science?
09:04:21 <Zekka> Well, I think that's a good property for some things, but often when programming you want to be understood pretty well by other people
09:04:23 <slack1256> is not raw data, I can put the curves I want
09:04:24 <JohnTalent> Zekka: To the transistors the Monads are very real my friend. ;)
09:04:30 <mizu_no_oto_work> JohnTalent: In what way is the monad instance for (-> r) like an envelope?
09:04:42 <mizu_no_oto_work> err, ((->) r)
09:04:45 <myridium> nitrix: Are you able to explain the requirements of a language for first-order logic in a simple way? I thought that languages like Java, C++, Haskell etc. are all Turing Complete and I thought that made them enough for verifying mathematical laws; even if it's stupid.
09:04:47 <Zekka> you usually can't be perfectly understood by other people, but some tools like analogies can make that harder
09:05:09 <Zekka> JohnTalent: I don't know, I'd say that "monad" is a way of describing the transistors. Ways of describing are usually not physical
09:05:15 <slack1256> the monads as envelope is a good *initial* approximation
09:05:29 <slack1256> nobody goes from no-knowing to full-understanding in one step
09:05:33 <Zekka> it's kind of like how words aren't "real" from the point-of-view of sound waves, even though sound waves subserve words
09:05:43 <mizu_no_oto_work> myridium: Agda is implemented in Haskell.
09:05:58 <mizu_no_oto_work> Agda being a dependently typed language / theorem prover
09:06:19 <ertes> myridium: GHC-haskell is approaching type theory these days, so you can do quite a lot, but it is still not a (useful) proof assistant
09:06:34 <mizu_no_oto_work> So Haskell is used as an implementation language for some theorem provers, but isn't itself a theorem prover
09:06:39 <JohnTalent> mizu_no_oto_work: Everything outside the () in your example would be view it and something to open and something to evaluate.
09:06:40 <ertes> myridium: haskell is a programming language, strictly…  you use it to run code, not to just type-check it
09:06:56 <nitrix> myridium: I'm not the best equipped to answer, but I know many concepts are borrowed from category theory; functors, monads, we transform these powerful ideas into type classes in our language, guaranteeing those are going to be solid and provide the generalization we're after, but then, defining instances of type that belong in that class is what's tricky, as they have to abide a set of laws.
09:07:00 <Zekka> (well, you don't have to run haskell programs if you don't want to)
09:07:06 <JohnTalent> s/view it and/viewed as
09:07:09 <nitrix> myridium: Verifying those laws automatically, is what's complicated.
09:07:42 * hackagebot pusher-http-haskell 1.1.0.1 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.1.0.1 (willsewell)
09:07:44 * hackagebot manifolds 0.2.3.0 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.2.3.0 (leftaroundabout)
09:07:46 <myridium> Ah okay. So theorem-proving requires a lot of specially abstraction in the language then I guess.
09:08:05 <ertes> myridium: interestingly turing completeness actually *hinders* theorem proving
09:08:08 <Zekka> the motivation for putting monads into haskell was less "we want to check if things are monads (this is hard to do) and more 'if things are monads, and programmers vouch for that, maybe that enables us to do useful monad-flavored things'"
09:08:10 <nitrix> myridium: It's much beyond a sound type system, correct.
09:08:22 <ertes> myridium: the languages of proof assistants are deliberately *not* turing-complete
09:08:41 <JohnTalent> Zekka: Tell that to the bank's cash deposit slot. :p
09:08:44 <Zekka> looking at programs in a turing-complete language and figuring out exactly what they do is very hard. (for instance, in general, it's impossible to figure out if a program terminates)
09:09:04 <mizu_no_oto_work> JohnTalent: For (->) r, join :: (r -> a) -> (r -> a -> b) -> (r -> b).  Do you consider a function to be an envelope?
09:09:07 <ertes> Zekka: s/very hard/impossible in general/
09:09:49 <JohnTalent> mizu_no_oto_work: it depends on it's contents. Monads, never so, unless it's not actual program environment.
09:10:10 <mizu_no_oto_work> What's the contents of a function?
09:10:16 <myridium> If a language isn't Turing Complete, then it must have something else going for it then though right? Do you have to give up Turing Completeness for those benefits?
09:10:18 <JohnTalent> mizu_no_oto_work: exactly.
09:10:42 <Zekka> Yeah, a lot of them are designed specifically around making it possible to figure out that programs terminate
09:10:43 <mizu_no_oto_work> Yet functions (r -> a) are monadic.
09:11:06 <Zekka> so for instance, you can't write a function that calls itself without also proving that it doesn't call itself forever
09:11:12 <tsahyt> myridium: some domain specific languages aren't turing complete and get by just fine
09:11:25 <ertes> myridium: turing-completeness makes type theory inconsistent, so you can prove false stuff
09:11:25 <JohnTalent> There is no mystification, if you can leave the ivory towers of lofty classfulness.
09:11:26 <Zekka> (disclaimer -- I've used Haskell a lot, and I've stroked Agda and Coq from a distance with a ten-foot pole.)
09:12:10 <JohnTalent> Zekka: yes, computers 101 the halting problem. Not needed in real programming warefare.
09:12:20 <JohnTalent> warefare. ha.
09:12:22 <ertes> myridium: as far as i know it's unknown when and by how much that is a practical limitation, because we have a few formal tricks to compensate, for example coinduction
09:12:23 <JohnTalent> warfare.
09:12:32 <Zekka> JohnTalent: Yeah, it doesn't come up that much unless you're trying to write a program that analyzes programs
09:12:36 <mizu_no_oto_work> myridium: There's an interesting theorem that theorems in certain logics are isomorphic to types in a corresponding type theory, and proofs are isomorphic to programs.
09:12:47 <JohnTalent> Zekka: that always happens. :)
09:12:49 <Zekka> It's useful if you're working on design stuff for a programming language or a logic system though
09:13:00 <tsahyt> Zekka: it does pop up in compiler design
09:13:12 <tsahyt> the obvious example would be a totality checker
09:13:17 <Zekka> Oh yeah, and even after you're working on a compiler
09:13:25 <ertes> myridium: as a programmer in such a language you can probably still write all programs you want to write, but you will have to express yourself differently…  you can't use potentially infinite loops
09:13:29 <tsahyt> we've also got UndecidableInstances for related reasons
09:13:35 <JohnTalent> Zekka: oh what a rabbit hole we can grow with self analysis programs.
09:13:36 <Zekka> a lot of things people would like compilers to do are pretty hard to do in general
09:13:47 <Zekka> (read: frequently impossible)
09:13:55 <mizu_no_oto_work> myridium: So there's a class of theorem prover that's basically a non-turing complete programming language with a type system that corresponds to an interesting logic.
09:13:57 <myridium> This stuff really fascinates me but I have little formal education in related matters. Is this more the domain of Mathematics or of Computer Science, and can you recommend any resources?
09:14:25 <myridium> FYI: I have a Bachelor's in Physics and Mathematics; basically Applied Math
09:14:26 <tsahyt> myridium: compsci. the part of compsci that's a branch of maths though
09:14:37 <tsahyt> theoretical computer science would be the more precise answer
09:14:46 <Zekka> it is sometimes worth it to cheat -- you can say "maybe this variable is assigned" or "this variable is absolutely never assigned" by checking if any assignment statements exist for that variable
09:14:56 <mizu_no_oto_work> JohnTalent: it's not mysticism, it's just that 'envelope' is a useful analogy for *some*, but not all, monads.
09:15:25 <Zekka> you can't in general say whether a user ever assigns a variable, but you can still figure it out in some of the easy cases
09:15:52 <ertes> myridium: what i described is logic or mathematical foundations, but there is a lot of overlap
09:15:53 <mizu_no_oto_work> There's a simple non-mystical definition for these things, and handwaving about 'returning' and 'identity' is useless.  Something's a monad if you can define a couple functions that fulfill a couple laws.
09:16:00 <JohnTalent> mizu_no_oto_work: Then in addition to being an envelope that returns an identity, they are more than just Monads,not less.
09:16:02 <ertes> s/mathematical/mathematics/
09:16:17 <Zekka> I think it's probably fine to be handwavy and indefinite if being handwavy and indefinite buys me something
09:16:30 <slack1256> yep
09:16:36 <Zekka> I can get handwavy and indefinite sometimes when I'm trying to figure something out abductively
09:16:45 <slack1256> no everybody know group theory to be familiar with algebraic definitions of monad
09:16:48 <JohnTalent> mizu_no_oto_work: you need to prove it before you spout it. Monads are indeed simple.
09:17:05 <Zekka> I'll frequently say "this doesn't sound totally honest" about something and handwave the details about why I don't beileve it
09:17:05 <MarLinn> "envelope" is an analogy for some forms of Pointed or CoPointed. It has no relation to monads other than monads being Pointed
09:17:13 <JohnTalent> Functional programming does mirror this Hindu religion though.
09:17:16 <Zekka> I'm not sure monads are a thing you want to do this for thuogh
09:17:17 <JohnTalent> I have to laugh at that.
09:17:34 <JohnTalent> A Caste of Knowledge.
09:17:40 <mizu_no_oto_work> JohnTalent: Yes, 'monoid object in the monoidal category of endofunctors', once you do all the definition-chasing, is pretty simple. 
09:17:45 <JohnTalent> A Fistfull of Casts More.
09:18:51 <Zekka> "monad" is pretty specific, but you can specialize the underlying concept in enough ways that I bet you could learn a lot of instances of it and not learn the concept
09:19:01 <slack1256> which is great if you want to know what a monad is, not that much if you want to know what a haskell Monad m is
09:19:12 <Zekka> In which case I bet you could get pretty good at recognizing "this looks like a monad" without thinking about the definition
09:19:19 <Zekka> or even knowing the definition, necessarily
09:19:40 <JohnTalent> mizu_no_oto_work: never said that slide wasn't a good approximation but it leaves analogies closed up until you learn category theory. Which isn't much of a sweat.
09:19:59 <Zekka> (I think "lift" is a better example of where this has happened -- there are a lot of operations in Haskell with very different typesigs which all get called 'lifts' -- and I think you often develop lift-sensing powers without having to rigorously define it)
09:20:03 <mizu_no_oto_work> JohnTalent: do you think that all 'envelopes that return an identity' are monads?
09:20:05 <MarLinn> "pure and kleisli composition form a category" - yet another way to define a monad precisely and simply
09:20:26 <ertes> i think "monads are envelopes" is fine
09:20:34 <ertes> just like space-suits and burritos
09:20:37 <Zekka> Well, keep in mind that whether these definitions actually work depends on concepts introduced outside those definitions
09:20:45 <mizu_no_oto_work> JohnTalent: 'monoid object in the monoidal category of endofunctors' isn't an approximation or analogy, it's a definition.
09:20:54 <Zekka> So when you say that it's a precise and simple definition you're also asking the reader to assume that all the terms you used have precise definitions too
09:20:57 <JohnTalent> mizu_no_oto_work: Monads can do what you like but yes, they all 'inherit' those descriptions.
09:21:30 <ertes> as long as it works for you, picture them as whatever you want…  but if you tell people "monads are envelopes!", and they don't get it, don't be surprised…  it's *your* metaphor
09:21:44 <mizu_no_oto_work> JohnTalent: I don't understand what you mean by that
09:22:13 <Zekka> What do you think are some examples of things that aren't monads?
09:22:27 <Zekka> I don't think people are monads, but I could be wrong
09:22:40 <nshepperd> Burritos are nothing like monads. I've never had a monad leak all over me while trying to eat
09:22:52 <mizu_no_oto_work> Zekka, JohnTalent: Or better yet, what are some things that are *nearly*, but not quite, monads?
09:22:58 <JohnTalent> Category Theory makes hard cruel math of us all.
09:22:59 <Zekka> (I mean, a person is like an envelope that might contain a new person sometime later)
09:23:19 <ertes> ever since byorgey's article, there seems to be a general "don't ever use metaphors!" attitude in the community, which IMO is stricter than necessary
09:23:23 <JohnTalent> Love isn't a Monad. ;)
09:23:40 <Zekka> ertes: I think there are a lot of ways to get understanding which don't involve definitions
09:24:01 <Zekka> I don't think the haskell community has a history of intentionally exploiting them, but I think they've done it by accident. (I used lifting as an example earlier)
09:24:15 <MarLinn> nshepperd: comonads are like burritos: they can leak easily, but you can always try to re-wrap them ;)
09:24:59 <JohnTalent> Zekka: A person is not a meatbag wrapped in skin? :p~~~
09:25:16 <ertes> painting a picture is a great way of learning…  it's imprecise and usually over-specialised, not only for monads, but for many things, but on the other hand it's not that important to get "the bigger picture" immediately, as long as you pay attention not to break the rules
09:25:19 <tsahyt> JohnTalent: the good old skin endofunctor
09:26:12 <minad> hi, is there a library to derive Show1, Show2, Eq1, etc?
09:26:13 <Zekka> there's a tempting thing in haskell where a lot of things were probably invented by somebody who formalized them at some time -- but realistically you have a bunch of nonmathermaticians interpreting them, and there's probably gonna be some linguistic drift
09:26:17 <nshepperd> I don't think wrapping a person in another person is a standard operator
09:26:22 <mizu_no_oto_work> ertes: sure, as long as you don't push the metaphor too far, or insist that 'X is only $METAPHOR and nothing more.'
09:26:39 * MarLinn . o O ( Skinned meatbag -> (meatbag -> Skinned alien) -> Skinned alien )
09:26:45 <JohnTalent> What endofunctors suggest backs up the theory of Simulcra. A Universe of endless mirrors pointing at or from each other.
09:26:53 <Zekka> "monad" is still a concept that appears to be pretty close to an original formal meaning -- "lift" and "FRP" appear to have diverged from that
09:27:40 <Zekka> you can probably still teach "monad" pretty rigorously but I think you will have to use cheesy or imprecise methods to talk with beginners about terms like "lift" or "FRP"
09:27:43 <mizu_no_oto_work> MarLinn: Sounds like the 'To Serve Man' function
09:27:48 <JohnTalent> nshepperd: look up emotions or contextual stimuli.
09:28:17 <Zekka> I'm not sure what role "monad" has in JohnTalent's philosophy -- this seems a little free-associative to me
09:28:18 <ertes> mizu_no_oto_work: i don't think people usually do that (for a long time)
09:28:45 <conal> The original rigorous/precise FRP is very simple. It got muddled a few years ago, and that confusion spread by imitation.
09:28:53 <Zekka> It's imho not wrong to be free-associative -- human brains are really good at free association and we can get at important meaning that way -- but I don't think it happened that way
09:28:54 <ertes> Zekka: 'lift' and FRP are actually pretty formal
09:29:04 <JohnTalent> Zekka: What I've always said is don't let the Universe describe you, because it can't.
09:29:12 <Zekka> ertes: Well, that's kinda my point -- they were introduced in a formal way and they now get used in a really informal way
09:29:19 <jonored> Maybe Leibniz's monads?
09:30:16 <ertes> Zekka: FRP has been stretched to the point of meaninglessness, but there are libraries that still follow the original formulation rigorously (reactive-banana, reflex, sodium, wires)
09:30:17 <jonored> (which have essentially nothing to do with mathematical monads, so far as I am aware.)
09:30:25 <JohnTalent> MarLinn: :)
09:30:35 <ertes> Zekka: and i refuse to call others "FRP" =)
09:30:39 <Zekka> I'm not saying the original formal usages aren't good or useful
09:30:44 <ertes> Zekka: probably even more so than conal himself =)
09:31:03 <Zekka> I think the meanings of words just changes a bit when they get away from the source
09:31:24 <Zekka> when people learn to use those words from people who distorted the meaning of those words, those words get harder to formally define
09:31:33 <conal> ertes: i may be pickier than you. if it's missing my two main criteria (precise denotation & continuous time), it's not FRP to me.
09:31:36 <Zekka> the formal definitions aren't bad or wrong but they don't cover some of the meaning those words eventually get
09:31:41 <tsahyt> speaking of FRP, how do I choose an FRP library these days?
09:31:55 <tsahyt> as someone trying to wrap my head around it and find some use for it, which one should I look at?
09:32:18 <ski> jonored : the category terrorists "stole" the term from the philosophers, yes
09:32:19 <Zekka> Cale: Feel like pitching Reflex? IIRC you are a big fan of it
09:32:44 <JohnTalent> For those of you watching from home: https://www.acronymfinder.com/FRP.html
09:32:57 <ertes> tsahyt: if you bind to a callback-based UI toolkit, use reactive-banana; for everything else i recommend reflex
09:33:13 <tsahyt> @hackage reflex
09:33:13 <lambdabot> http://hackage.haskell.org/package/reflex
09:33:24 <ertes> tsahyt: if high performance/real-time is of concern, try my AFRP library 'wires'
09:33:32 <tsahyt> what does the A stand for?
09:33:37 <ertes> arrowized
09:33:53 <Zekka> what would you write if it was applicative instead?
09:34:05 <nitrix> ertes: What's state of the art with performance that keeps the original denotational semantics from conal?
09:34:06 <ertes> Zekka: it's both =)
09:34:07 <JohnTalent> Slave to the Symbol.
09:34:10 <jonored> ski: The question is whether JohnTalent is talking philosophy-monads rather than mathematics-monads or programming-monads.
09:34:23 <ski> Zekka : "IFRP", of course
09:34:32 <jonored> Or just free associating in general and throwing in "spanish inquisition" jokes for good measure.
09:34:36 <Zekka> It sounds like the letter of the day is "A."
09:34:43 <tsahyt> would reading through the original paper(s) be useful? This discussion makes it seem like FRP is now very far removed from what it used to be
09:34:49 <ski> jonored : i suspect neither
09:35:03 <nitrix> ertes: I didn't like how banana has states all over the place. reflex seemed really nice with the naming and the concept of PushM and PullM.
09:35:26 <nitrix> ertes: But I've heard people complaint of performance and leaks about reflex as well :/
09:35:30 <Zekka> tsahyt: conal is around so you may want to ask him, but I am guessing he would say yes
09:36:05 <JohnTalent> jonored: The real question is 'What exactly does JohnTalent know?'.
09:36:14 <conal> Last I talked with Ryan, reflex doesn't have a (precise) denotation at all.
09:36:33 <JohnTalent> jonored: If I may be so bold.
09:36:35 <ertes> nitrix: yeah, i discovered a few memory leaks in reflex, one of them still open…  it's relevant in real-time scenarios where you have an event that rarely fires
09:36:57 <ertes> nitrix: also reflex, while being really fast, doesn't quite beat AFRP yet
09:37:08 <nitrix> tsahyt: Not to put conal's words in his mouth, but it seemed his general feeling was that the libraries out there branched from the original idea, maybe for practicality, but they were loosing the denotational essence and turning it into operational, which he complained a few times about to me.
09:37:13 <Zekka> JohnTalent: I think you're being taken on two levels here -- the people who are trying to figure you out are trying to figure out (1) what they mean (2) whether they can dismiss you
09:37:18 <nitrix> tsahyt: But of course, speaking to him directly would be more productive.
09:37:24 <nitrix> tsahyt: (And polite)
09:37:34 <Zekka> what you mean*
09:37:47 <conal> nitrix: exactly. without a spec, it's just code. an answer without a question. not even wrong.
09:37:50 <Zekka> some of the stuff that feels a little more hostile or a little more like a knowledge test is probably (2) -- (2) is normal, of course, especially when you say weird stuff
09:38:27 <JohnTalent> nitrix++!
09:38:37 <Zekka> I have a habit of saying weird things so I'm used to being interrogated or dismissed -- imho people aren't wrong when they're looking for a reason to dismiss you usually
09:38:51 <ertes> nitrix: i hope that we can bury AFRP soon, but until then there is wires (or Yampa, if you want more built-in stuff)
09:39:01 <JohnTalent> nitrix: It's the new state of function programming. A once happy place taken of by the perhaps once Lisp elite.
09:39:47 <ongy> hm, I wonder. How can it be nick++ in #haskell?
09:39:47 <nitrix> ertes: So what's left? AFRP and/or netwires?
09:40:05 <JohnTalent> Zekka: Yes, weird is not computational correct. Are you weird?
09:40:08 <ertes> nitrix: note: wires, not netwire
09:40:13 <ertes> netwire is deprecated
09:40:30 <nitrix> ertes: https://hackage.haskell.org/package/wires, reading.
09:40:39 <GLM> Does anyone where have experience with cloud haskell?
09:41:03 <nitrix> ertes: So wires is the most promising right now?
09:41:14 <Zekka> JohnTalent: It's actually been a month or two since I last said weird stuff in #haskell -- but usually I just ask people to sell me on their ideas, and sometimes I get a little bit trolly to try to extract more hints
09:41:40 <JohnTalent> Zekka: Yes, you play on their emotions I gather.
09:41:58 <nitrix> ertes: Oh my, it re-exports Control.Category. How promising already :P
09:42:38 <Zekka> It's not really that intentional, because I developed some of those habits accidentally when I was in high school and wanted to be the class expert
09:43:02 <ertes> nitrix: there is also Yampa, but i don't like it that much, because it shares a problem with netwire: stuff
09:43:09 <ertes> there is stuff, and stuff, and more stuuuufffff
09:43:36 <JohnTalent> curious.
09:43:36 <Zekka> when you learn to be a little nasty and insulting to people it can get hard to turn that off -- I usually try to play it up in a really irreverent way but a guy in another channel told me I was kinda being a jerk, so I've been trying to cool down on that
09:44:03 <nitrix> ertes: I'll give you that. As far as FRP goes, I'd rather be given just the building blocks and build the more practical things myself.
09:44:45 <ertes> nitrix: yeah, for wires i designed a very small core language…  it doesn't even have built-in time
09:45:00 <nitrix> ertes: I love it.
09:45:12 <nitrix> conal would hate you for removing time :P
09:45:23 <ertes> nitrix: time is still there semantically
09:45:26 <JohnTalent> Zekka: Take me back to high school. <wisha wu wisha wu wisha wu> <fades out>
09:45:31 <MarLinn> Is there by any chance a profunctor-based frp library out there? as that seems to be the modern way to replace arrows
09:45:32 <ertes> nitrix: but not as an actual behaviour
09:45:41 <nitrix> Yeah, you have things like Varying.
09:45:53 <nitrix> Which is an interesting take to the problem.
09:46:11 <ertes> nitrix: Varying is the same thing as Dynamic in reflex
09:46:21 <ertes> i just changed the name, because "Dynamic" is quite overloaded
09:46:40 <nitrix> +1
09:46:45 <Zekka> Lately I've been looking for another way to look like I don't know what I'm doing, because when people think I know what I'm doing on some level, then there's social consequences for being out-of-line
09:47:02 <nitrix> ertes: Ban fan so far. I'll play with it tonight, maybe even jump on it.
09:47:14 <nitrix> ertes: How do you tie IO a the end of behaviors?
09:47:34 <ertes> nitrix: see the .Controller module
09:48:15 <nitrix> Ohhh.
09:48:27 <Zekka> ideally I look like kind of a stupid kid who occasionally has an idea that's useful to someone
09:48:29 <nitrix> Oh that's very interesting.
09:48:43 <ertes> nitrix: usually you use 'control' and then pick whatever you need from 'animate', 'newEvent' and 'onEvent'
09:49:01 <ertes> if you want to keep control and write the main loop yourself, use 'stepWire' instead of 'control'
09:49:09 <nitrix> ertes: So the whole wire executing happens in a monad, which likes you embed monadic events as well.
09:49:20 <nitrix> Can't english.
09:49:43 <ertes> nitrix: yeah…  the concept is almost identical to r-b/reflex
09:50:04 <nitrix> ertes: Somehow it's more clear.
09:50:38 <nitrix> ertes: Quick question, do I have an easy way to save a wire and restore it?
09:50:54 <JohnTalent> Zekka: Don't sell yourself short kid. Schooling is a caste based on the tiers of liquidation. 
09:51:14 <ertes> nitrix: nope…  i had a concept of explicit serialisation/deserialisation as extra constructors, but abandoned it
09:51:25 <ertes> nitrix: i think jle`'s library 'auto' does that
09:51:47 <nitrix> ertes: Can you dynamically connect wires still?
09:52:04 <ertes> nitrix: sure, see the switching section in .Core
09:52:09 <nitrix> I'm okay with recreating the graph again. I just want to be able to save the states somehow.
09:52:11 * MarLinn should have followed the suggestion before asking...
09:52:23 <ertes> nitrix: i'm also going to reintroduce more principled variants of netwire's (<|>)
09:52:34 <Zekka> JohnTalent: Well, if people see you as an expert they don't expect you to have limits, and they often don't try to get a second opinion
09:52:35 <nitrix> ertes: My problem with reactive banana was that you couldn't look at all the individual accumE or something, to save the current state.
09:52:56 <ertes> nitrix: wanna move this to #haskell-game?  less noisy =)
09:52:58 <JohnTalent> Zekka: Meditation.
09:53:02 <nitrix> ertes: sure
09:53:13 <JohnTalent> sorry. i'm out.
09:53:15 <Zekka> People asked me for advice a few times and I gave them advice and warned them I wasn't sure it was right
09:53:33 <Zekka> but they used it anyways because they thought I was probably right and it seemed good enough
09:54:12 <Zekka> it's usually not good to be someone's last line of defense against a bad idea, unless you're really smart
09:54:33 <Zekka> JohnTalent: Have a nice day!
09:55:50 <JohnTalent> Zekka: Likewise my friend! :)
09:59:31 <JohnTalent> Zekka: By the way. It is no business of yours what people think you of.
10:01:05 <phonman> for so many people, there's so few talking. Social anxiety or laziness?
10:01:38 <geekosaur> or busy doing other things but lurking
10:01:40 <ski> phonman : or just a consequence of IRC customs ..
10:01:52 <geekosaur> nice of you to go for the most negative interpretations first...
10:02:10 <Zekka> I'm in and out
10:02:12 <monochrom> laziness is right.
10:02:13 <phonman> hehe
10:02:14 * ski disputes laziness being negative
10:03:00 <exio4> phonman: multiple reasons, I keep my IRC client connected overnight, there wasn't any topic going where my comment would have been helpful, and I am (supposed to) work on something :p
10:03:10 <Zekka> On: the: topic: of: laziness: though: _
10:03:22 <exio4> phonman: half the channel might be sleeping :)
10:03:54 <monochrom> try #ubuntu for more talking. intractibly more talking.
10:05:50 <dmj`> is there a good matrix type that would let me easily interchange row and column positions
10:06:44 <Zekka> dmj`: Could you perhaps use a normal matrix type, then switch between two sets of accessors? (one taking column, then row, the other row, then column)
10:07:26 <Zekka> You could hide this behind a type like "data Flippable = Normal Matrix | Flipped Matrix"
10:07:44 * hackagebot http-client-tls 0.3.2 - http-client backend using the connection package and tls library  https://hackage.haskell.org/package/http-client-tls-0.3.2 (MichaelSnoyman)
10:07:46 * hackagebot hopenpgp-tools 0.19.3 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.19.3 (ClintAdams)
10:07:48 * hackagebot aivika-experiment-chart 4.3.2 - Simulation experiments with charting for the Aivika library  https://hackage.haskell.org/package/aivika-experiment-chart-4.3.2 (DavidSorokin)
10:07:50 * hackagebot attoparsec 0.13.1.0 - Fast combinator parsing for bytestrings and text  https://hackage.haskell.org/package/attoparsec-0.13.1.0 (BenGamari)
10:07:52 * hackagebot hasktags 0.69.2.1 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  https://hackage.haskell.org/package/hasktags-0.69.2.1 (jhenahan)
10:38:33 <dmwit_> Zekka: Seems like with that representation you'd have to reimplement all the matrix operations like addition and multiplication, which I assume is what dmj` is trying to avoid.
10:39:14 <dmwit> dmj`: You might ping cartazio or ekmett; I think they were working on something that let you linearize matrices in memory in different orders.
10:42:19 <dmwit> Zekka: Also, with regards to your previous comments: have you tried choosing a nick that makes you look stupider? ;-)
10:43:33 <srpx_> I have a function `getFoo :: IO Foo` which gets Foo as a line from the console. I want it to crash the program with an error if `parseFoo :: String -> Maybe Foo` fails. What is an elegant way to do it?
10:43:52 <srpx_> error "theerror" (Just (Foo ...)) with a fake foo looks bad...
10:43:56 <dmj`> Zekka: hey, so think I'm going to just use Data.Matrix and a sum type
10:44:08 <dmj`> it has switchCols, and switchRows
10:44:24 <dmj`> data Item = FirstThing String | SecondThing Int... etc
10:45:02 <dmwit> srpx_: case parseFoo s of Nothing -> throwError "yuck!"; Just v -> return v -- ?
10:45:40 <dmwit> srpx_: In case `parseFoo` is `readMaybe`, consider just `readLn` in place of `getFoo`, which does this by default.
10:45:52 <dmwit> ?src readLn
10:45:53 <lambdabot> readLn = do l <- getLine; r <- readIO l; return r
10:45:58 <dmwit> ?src readIO
10:45:58 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:46:01 <dmwit> too bad
10:46:16 <ashishnegi> hi.. my server has a wai-websockets thread listening and a tcp-socket thread listening for events.. when my server is stopping, should i do `killThread wsThread .. killThrad tcpThread` ?? Do i need to handle the exception in those threads ? These threads talk with the server over channels.. so they do not need any cleanup to do.
10:46:41 <nibble_zero> can I have list of 2 lists, but each of those 2 lists have different data types inside them?
10:46:59 <dmwit> nibble_zero: nope
10:47:20 <dmwit> nibble_zero: However, it is generally quite cheap to make a new type that can have values of several other types inside.
10:47:23 <Cale> nitrix: btw, do you know who was complaining about reflex performance? Perhaps we could get them some help.
10:47:36 <nibble_zero> dmwit: thanks
10:47:38 <dmwit> nibble_zero: `Either` is the canonical such, but it is often good practice to make your own type with more descriptive constructors anyway.
10:48:02 <srpx_> dmwit: thanks. Also, in case parseFoo is `readMaybe`? What do you mean? 
10:48:39 <dmwit> srpx_: Your question was quite general, so I answered about the general case. But there are handy functions for more specific cases.
10:49:09 <dmwit> srpx_: In particular, if you asked about `parseFoo` but it turns out that the implementation of `parseFoo` is to just call a `read`-alike, then you should consider writing less code and using the standard library's existing functions for this.
10:51:07 <dmwit> Pfft, the implementors of `readLn` didn't understand the Monad laws.
10:51:17 <srpx_> dmwit did you mean to write "but if* it turns out that the..."?
10:51:48 <dmwit> srpx_: I don't think so. Perhaps you missed the "if" earlier in the sentence?
10:51:59 <srpx_> oh damn. sorry
10:52:39 <srpx_> Ok I get what you are saying. parseFoo is implemented directly though :) let me try what you suggested 
10:52:50 * dmwit nods agreeably
10:53:06 <dmwit> I think the sentence has the same meaning if you move the "if" from earlier to the place you suggested, anyway. So it all works out. =)
10:54:29 * srpx_ notices he is stupid because `error` doesn't require a fake value obviously
10:54:48 <srpx_> dmwit: yep I blame the small letters 
10:58:44 <jitzin> hello!
10:58:48 <dmwit> srpx_: For IO, `throwError` is preferred to `error`.
10:59:24 <dmwit> or `ioError` if you don't like mtl.
11:00:22 <dmwit> (Because it can potentially be caught; and probably interacts with the runtime system more cleanly in other ways as well.)
11:00:43 * dmwit waves in jitzin's direction
11:02:10 <jitzin> glad I found this community - looks like there's tons of people. I'm just diving into haskell, reading some tutorials and what not. 
11:02:39 <ski> hello jitzin
11:02:57 <jitzin> hey ski
11:04:41 <ski> jitzin : just note that the channel (or IRC in general) is sometimes a bit slow, so don't give up if you don't get an answer immediately
11:05:14 <jitzin> thanks ski, I'll be sure to remember that. I figure it takes patience learning how to program anyway ;) 
11:05:21 <ski> (that's probably the most common mistake newbies to IRC make .. asking a question, and then disappear without around 5 or 15 minutes, before anyone's had a chance to react)
11:05:37 <ski> (er, s/without/within/)
11:06:01 <jitzin> yeah it's been an interesting few days / week. Been probably 10+ years since I've used irc. 
11:06:32 <ski> ok
11:07:45 * hackagebot glirc 2.17 - Console IRC client  https://hackage.haskell.org/package/glirc-2.17 (EricMertens)
11:07:47 * hackagebot cabal2nix 2.0.2 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.0.2 (PeterSimons)
11:07:49 * hackagebot system-info 0.1.0.2 - Get information about CPUs, memory, etc.  https://hackage.haskell.org/package/system-info-0.1.0.2 (dtaskoff)
11:07:51 * hackagebot octane 0.16.2 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.16.2 (fozworth)
11:08:36 <jhpy1024> Hey guys, an exercise wants me to make a function called blowup that when given a string a1a2a3a4... returns a1a2a2a3a3a3a4a4a4a4...
11:08:53 <jhpy1024> But I can't think of a recursive way to do this with one function
11:09:27 <ski> you're probably allowed to use a helper function, if you think it'll be easier that way
11:09:38 <koala_man> jhpy1024: it should look for e.g. a4 and then repeat that 4 times?
11:10:21 <jhpy1024> koala_man: So it should repeat the first character one times, second character two times and so on.
11:10:52 <ski> > blowup "abcd"  -- like this, yes ?
11:10:56 <lambdabot>  "abbcccdddd"
11:11:14 <monochrom> w00t
11:12:27 <int-e> > replicate 2 'b'
11:12:30 <lambdabot>  "bb"
11:12:45 <jhpy1024> ski: like that yep
11:13:03 <jhpy1024> I can do it easily with a list comprehension and repeat but the book hasn't shown those yet so
11:14:12 * ski has to leave shortly ..
11:14:36 <jhpy1024> > replicate 3 'b'
11:14:39 <lambdabot>  "bbb"
11:14:47 <ski> jhpy1024 : i'd suggest try to use a helper function, possibly defined in a `where'-clause
11:14:53 <int-e> > reverse . concat . transpose . inits . reverse $ "abcd" -- needlessly strict and complex
11:14:56 <lambdabot>  "abbcccdddd"
11:15:23 <ski> int-e, heh
11:16:01 <jhpy1024> > [replicate b a | (a,b) <- let str = "abcd" in zip str [1 .. length str]]
11:16:04 <lambdabot>  ["a","bb","ccc","dddd"]
11:16:13 <int-e> :t zipWith
11:16:14 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:16:27 <ski> > zip "abcd" [1 ..]
11:16:31 <lambdabot>  [('a',1),('b',2),('c',3),('d',4)]
11:16:50 <ski> (no need to give an upper bound there. `zip' will cut to the length of the shortest list anyway)
11:17:06 <jhpy1024> ski: Aaah of course, I'm not used to this whole lazy eval thing yet :P 
11:17:10 <ongy> > concatMap (uncurry replicate) . zip [1..] $ "abcd"
11:17:13 <lambdabot>  "abbcccdddd"
11:17:19 <amalloy> > zipWith replicate [1..] "abcd"
11:17:22 <ongy> hm zipwith makes even more sense
11:17:22 <lambdabot>  ["a","bb","ccc","dddd"]
11:17:37 <monochrom> int-e: you are a genius
11:18:38 <ski> jhpy1024 : are you familiar with `map' and `concat' ?
11:19:08 <ski> jhpy1024 : you could also do it in a directly recursive way, with a counter
11:23:09 <jhpy1024> ski: Familiar with map, not with concat yet (although I can imagine what it does)
11:30:00 <lgstate> clojure has clj-refactor, which is amazing for refactoring clojure code in emacs.
11:30:05 <lgstate> Does Haskell have something similar?
11:36:34 <johnw> lgstate: not that I know of yet; there have been efforts made at supporting complex refactoring, such as HaRe, but I'm not sure of their current status
11:37:13 <squall> Hi, I'm reading; real time deques with catenation by Kaplan and Trajan and I hit an interesting but I would like help understanding, possibly with links to appropriate resources.
11:37:29 <squall> Here's the excerpt; Driscoll et al. [1989] described how to make
11:37:29 <squall> pointer-based structures persistent using a technique called node-splitting, which
11:37:29 <squall> is related to fractional cascading [Chazelle and Guibas 1986] in a way that is not
11:37:29 <squall> yet fully understood.
11:37:50 <squall> Oh god sorry for the flood
11:37:54 <lgstate> johnw: thanks for confirming
11:38:25 <lgstate> I think the other thing is that with sexps, it's easy to know when a expr 'ends'
11:38:33 <lgstate> which makes refactorikng easier / appear more magical
11:39:07 <lyxia> squall: https://www.cs.cmu.edu/~sleator/papers/another-persistence.pdf ?
11:39:44 <lyxia> squall: That seems to be the thing that excerpt refers to. Did you have a specific question?
11:40:13 <squall> About progress on the supposed gap in understanding
11:40:51 <squall> How is node splitting related to fractional cascading?
11:44:36 <shapr> squall: some related links can be found on https://en.wikipedia.org/wiki/Double-ended_queue if that helps any.
11:45:15 <lyxia> squall: Sorry I have no knowledge about either concept.
11:45:48 <squall> Thanks for the paper it's perfect. I guess operations on displacement paths is the overlap with zippers I was looking for. It would be good if any more of these new terms relating zippers to persistent types
11:46:59 <squall> of*
11:53:01 <squall> I was reading about Data.Sequence, which seems to achieve fast concatenation using finger trees which supersede deques. Are there papers based on this approach regarding persistence and mutuability?
11:56:03 <razzi53> I've written an interative python function used as follows: truncate_amounts_based_on_total_maximum([10, 10], 15) -> [10, 5]
11:56:12 <razzi53> I'm curious if there's a simple functional approach
11:56:18 <razzi53> full iterative implementation here: https://gist.github.com/razzius/943908ffb9a787965fee007d169c1666
11:56:23 <lyxia> squall: do you know about Purely Functional Data Structures by Okasaki
11:56:47 <squall> I was literally reading it just then
11:57:12 <squall> He gives an independent derivation of deques
11:57:57 <squall> Razzi, it isn't clear what that function is doing
11:58:23 <lyxia> razzi53: yours has quadratic complexity BTW
11:59:06 <lyxia> you can do it recursively by pattern matching on the list
11:59:20 <razzi53> squall: it's taking amounts from a list until a maximum is reached, possibly truncating the last amount
12:01:01 <prsteele> razzi53: scanl1 might help you start
12:01:06 <prsteele> > scanl1 (+) [1..10]
12:01:10 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
12:02:25 <squall> (\l n ->[x|<-l,x<n] ++ ((last l)-b) ([10],5)
12:02:37 <razzi53> prsteele: nice yeah then I could takewhile < maximum, and truncate the final amount
12:03:07 <lyxia> > let f i [] = [] ; f i (x : xs) | x < i = x : f (i-x) xs | otherwise = [i] in f 15 [10, 10]
12:03:10 <lambdabot>  [10,5]
12:06:13 <razzi53> lyxia: that's smart to decrease the maximum as you go. Nice answer
12:08:26 <squall> (squall) >  (\l n ->let (y,z) = (last z, [x|<-l,x<n]) in z ++ (if y<n then y else b)) ([10,20],15)
12:09:46 <exio4> that sounds awfully broken 
12:10:14 <squall> I'm trying to type on a phone I think I gave up
12:10:43 <exio4> > (\l n ->let (y,z) = (last z, [x|<-l,x<n]) in z ++ (if y<n then y else b)) [10,20,30,40] 40
12:10:47 <lambdabot>  error:
12:10:47 <lambdabot>      Variable not in scope: (|<-) :: Expr -> [Integer] -> Boolerror:
12:10:47 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘Expr’
12:11:13 <squall> Nvm
12:11:30 <lyxia> razzi53: in your snippet you keep computing the sum of truncated from scratch, you could keep the sum in a variable to update it in constant time instead
12:11:39 <squall> I wanted to talk about persistence really
12:11:55 <lyxia> from there you're one step away from storing everything in one variable as I did
12:42:08 <StarsC> can haddock document executables? and install man pages?
12:42:28 <dmwit> I don't think so, and no.
12:42:41 <StarsC> Setup.hs can not helpin this?
12:42:44 <dmwit> I think xmonad install some man pages; you might look at how they do it.
12:42:59 <StarsC> ty, will try
12:44:50 <dmwit> It seems they use pandoc to convert from markdown to man-page format.
12:45:21 <ertes> StarsC: haddock can document executables, but doesn't by default
12:45:42 <tdammers> StarsC: fwiw, pandoc can output man pages and read haddock IIRC
12:46:38 <OnOut2k16> http://ilredentore.dynv6.net updated :)
12:48:43 <grantwu> Is there a good way to "inherit" behavior of Show but modify it slightly
12:48:47 <ongy> ertes: afaik the exectuable documentation is about documenting the executables code, not man-page style
12:49:04 <geekosaur> grantwu, no
12:49:34 <geekosaur> and Show is really only useful for debugging; if you want to do something else, consider a prettyprinting library
12:50:12 <geekosaur> StarsC, ongy makes a good point there: haddock is for API documentation, not so much executable usage
12:54:43 <MarcelineVQ> it's off topic but StarsC is an amazing name
12:56:56 <StarsC> i was under impression that Setup.hs can perform something useful like converting docs to man and install.
12:57:07 <StarsC> MarcelineVQ: ty :)
12:59:47 <jle`> > [1,2,3] |<- 10
12:59:50 <lambdabot>  [10,10,10]
13:03:32 <Taneb> jle`, what
13:04:10 <dmwit> Taneb: Presumably he ?let a function named `(|<-)`, e.g. `(|<-) = flip ($>)`.
13:04:18 <dmwit> :t (|<-)
13:04:20 <lambdabot> Functor f => f b -> a -> f a
13:04:23 <dmwit> :t (<$)
13:04:25 <lambdabot> Functor f => a -> f b -> f a
13:04:33 <dmwit> :t ($>)
13:04:35 <lambdabot> error:
13:04:36 <lambdabot>     • Variable not in scope: $>
13:04:36 <lambdabot>     • Perhaps you meant one of these:
13:07:48 * hackagebot crypto-simple 0.1.0.0 - A simple high level encryption interface based on cryptonite  https://hackage.haskell.org/package/crypto-simple-0.1.0.0 (RistoStevcev)
13:09:46 <jle`> @let import Data.Functor
13:09:50 <lambdabot>  Defined.
13:09:53 <jle`> :t ($>)
13:09:56 <lambdabot> Functor f => f a -> b -> f b
13:10:40 <tsahyt> Is wires the "successor" to netwire?
13:11:11 <jle`> i suppose you can say so, because they're made by the same developer
13:11:40 <tsahyt> alright. netwire hasn't received any updates in quite a while now too.
13:12:34 <jle`> the developer is on this channel normally -- ertes -- if he is willing to give a more definitive answer
13:13:26 <ertes> tsahyt: yeah, netwire is deprecated
13:14:04 <tsahyt> ertes: ok. thanks for the answer!
13:15:02 <ertes> tsahyt: BTW, about that palindrome code…  i made a rather embarrassing mistake: the timing info is off by a factor of 10 =)
13:15:14 <ertes> where i wrote 10e9 i should have written 1e9
13:15:26 <tsahyt> that's bad because I just copied that line
13:15:54 <tsahyt> I even looked at it myself because the time output was so close to being 10x the clock output
13:15:58 <tsahyt> and I didn't catch that
13:16:05 <ertes> i have to remember that trick for an underhanded haskell contest =)
13:18:07 <tsahyt> ertes: it does make some sense though because reimplementing the same IO stuff using explicit seek etc (with the unix library) brought no noticable speedup
13:18:31 <tsahyt> at this point I thought that it's maybe a problem with building the bytestring itself, and decided not to pursue this any further
13:18:45 <tsahyt> also, mmap should be pretty much instant I think
13:19:35 <Squarism> what Data.Map mehtod works like flatMap in scala? 
13:19:54 <Squarism> filter + fmap combined so to speak
13:20:10 <ertes> tsahyt: i guess B.readFile is just fast enough
13:20:25 <gummibears> hi room
13:20:41 <ertes> tsahyt: can't imagine that it makes a noticable difference
13:21:05 <tsahyt> ertes: no it's definitely fast enough. I couldn't see any difference between readFile, mmap, and the handrolled version.
13:21:20 <tsahyt> except for memory stats, which are of course much better with mmap because they don't include the file itself
13:22:01 <squall> Hi gummybears
13:22:04 <gummibears> what happens if I have a function like this? f :: [a] -> Integer
13:22:04 <gummibears> f [] = 3
13:22:04 <gummibears> f (_:xs) = f xs
13:22:16 <ongy> Squarism: can you describe what you want? Looking at flatMap on google I don't see how it would work
13:22:17 <adelbertc> what are people's thoughts on quickspec? just learned about it and the premise seems really cool, interested in hearing how it fares "in practice"
13:22:27 <gummibears> Does ghc automatically recognize that it is always 3 and optimize it
13:23:00 <squall> No
13:23:03 <ongy> gummibears: I wouldn't rely on it. Also what if you pass [1..] to it?
13:23:12 <mauke> gummibears: it's not always 3
13:24:24 <gummibears> why isn't it always 3? sorry I'm a newbie. An explanation would be appreciated
13:24:41 <Squarism> ongy : oh maybe my mind betrays me. But what i want is something that lets med determine if each entry should be included or not and return a Maybe of a new type 
13:24:54 <mauke> gummibears: it's only 3 when it reaches []. not all lists contain []
13:25:11 <mauke> gummibears: for example, 'repeat 42'
13:25:20 <gummibears> i thought all non-empty lists were of the form x:y:...:[]
13:25:25 <mauke> yes
13:25:31 <mauke> er, no
13:25:37 <jle`> allOnes = 1 : allOnes
13:25:42 <jle`>  ^ there's a list with no [] :)
13:25:47 <prsteele> gummibears: that ... can be infinite, though  
13:25:55 <jle`> @let allOnes = 1 : allOnes
13:26:00 <lambdabot>  Defined.
13:26:07 <jle`> > take 10 allOnes
13:26:10 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
13:26:53 <tsahyt> ertes: I've tried running the ping pong examples in the wires repository and it complains about getGCStats being unsupported. any idea how to fix this?
13:27:39 <tsahyt> oh nvm
13:27:59 <tsahyt> I keep forgetting that I need to put -- before arguments when using stack exec
13:28:13 <ertes> tsahyt: this may become the first FAQ entry =)
13:28:26 <ertes> ah, yeah, that's different
13:28:56 <ertes> the GC stats thing isn't really necessary…  i just had it in there to make sure that i don't have any memory leaks
13:29:16 <tsahyt> on first try I just replaced it with a constant
13:29:32 <tsahyt> but it's nice to see that memory is behaving well
13:30:13 <tsahyt> :t (-<)
13:30:16 <lambdabot> error:
13:30:16 <lambdabot>     • Variable not in scope: -<
13:30:16 <lambdabot>     • Perhaps you meant one of these:
13:30:23 <tsahyt> -< is arrow notation then, right?
13:30:27 <ertes> yeah, this is so useful that i'm actually thinking of exposing it in a utility module
13:30:29 <ertes> yeah
13:31:37 <tsahyt> ertes: so why did you write wires and deprecate netwire?
13:33:03 <tsahyt> I noticed that the Wire type looks a lot simpler now than it did in netwire
13:33:57 <squall> Does anyone know anything about deques in Haskell?
13:34:52 <tsahyt> squall: Data.Sequence?
13:35:16 <squall> That's finger trees...
13:35:40 <geekosaur> and?
13:35:42 <tsahyt> So? It can be used as a deque
13:35:48 <geekosaur> deques are not fundamental structures
13:35:54 <squall> But yes, I'm investigating the performance of that module
13:36:18 <squall> Hmm, i though it might be like a cons and snoc list
13:36:18 <Squarism> ongy, mapMaybeWithKey and mapMaybe seems to do the job
13:38:09 <squall> I don't think I understand how it achieves it's performance.. I guess it splits the list over the branches and somehow can concatinate it faster as a result
13:38:18 <squall> Is that close?
13:41:07 <squall> Similarly with dlist, am i correct in thinking the constant concat time is because it leaves the list as symbolically composed ++ operations, as if it were using (:) to add a list onto a list of lists that would later be subject to concat?
13:41:58 <ertes> tsahyt: netwire is too complicated and overengineered…  it's difficult to maintain…  i wrote a new library in order to change the abstraction and introduce a minimal core semantics that is supposed to be reasonably stable
13:42:45 <tsahyt> alright. I guess I'll read conal's paper tomorrow, learn how arrow notation works, and then I'll dive into it.
13:43:12 <ertes> tsahyt: for the arrow notation part i recommend the GHC user guide
13:46:10 <prsteele> has anyone thought about type-safe cross products? I'm reaching for template haskell to try to come up with a sane answer, and I want to check to see if I'm off base
13:46:18 <squall> Do difference lists achieve constant concat time by composing lists with (++) without executing it?
13:46:34 <jle`> prsteele: cross products?
13:46:58 <prsteele> jle`: uh, cartesian products, sorry
13:46:59 <jle`> maybe just use a type that only has three elelments?
13:47:21 <jle`> hm, what do you mean by a type-safe cartesian product
13:47:25 <jle`> why doesn't liftA2 (,) work?
13:47:39 <jle`> > liftA2 (,) "hello" [False,True]
13:47:39 <prsteele> jle`: cross that with _another_ set
13:47:42 <lambdabot>  [('h',False),('h',True),('e',False),('e',True),('l',False),('l',True),('l',F...
13:47:53 <prsteele> you end up with typse of the form (a, (b, (c, d))), which is cumbersome
13:48:23 <jle`> so you're asking about more convenient tuples?
13:48:31 <prsteele>  basically
13:48:38 <jle`> > liftA3 (,,) "hello" [False,True] [1,2,3]
13:48:42 <lambdabot>  [('h',False,1),('h',False,2),('h',False,3),('h',True,1),('h',True,2),('h',Tr...
13:48:42 <Zemyla> prsteele: HList?
13:49:29 <ertes> squall: no, they make sure that all applications of (++) are right-associated
13:49:37 <prsteele> Zemyla: it looks like the lengths need to be known at compile time, which doesn't work for me
13:49:59 <ertes> squall: good: xs ++ (ys ++ zs); not good: (xs ++ ys) ++ zs
13:50:19 <kadoban> prsteele: If the lengths aren't known at compile time, doesn't sound like a tuple.
13:50:25 <nomeata> Hi. What is the status of ghcjs these days? Will we see a release any time soon there?
13:50:28 <lyxia> > (,,,,) <$> "Never" <*> "gonna" <*> "give" <*> "you" <*> "up"
13:50:31 <lambdabot>  [('N','g','g','y','u'),('N','g','g','y','p'),('N','g','g','o','u'),('N','g',...
13:50:34 <prsteele> jle`: while you could just use liftA2 (,) this *also* means that a `cross` (b `cross` c) doesn't have the same type as (a `cross` b) `cross` c
13:50:50 <prsteele> kadoban: the length of the tuples is known, but not the number of them
13:50:56 <squall> Oh, just so it can concat in a single pass etres?
13:51:01 <jle`> prsteele: you can use hlists for that
13:51:34 <jle`> (Int,Bool,String) would be HList [Int,Bool,String]
13:52:19 <ertes> squall: if you look at the definition of (++) you will notice that it doesn't really matter what the second argument is…  it only becomes relevant, as soon as the first argument is fully traversed, at which point the first argument is already forgotten
13:52:22 <kadoban> prsteele: What?
13:52:28 <prsteele> jle`: and I could take the cartensian product of that HList with another HList?
13:52:30 <jle`> the number of fields would be known at compile-time
13:52:38 <jle`> prsteele: yes
13:52:46 <jle`> no
13:52:48 <jle`> a list of hlists
13:53:01 <jle`> hlist [Int,Bool] replaces your (Int,Bool)
13:53:17 <Guest35292> Any networking library suggestion for a P2P game?
13:53:21 <prsteele> kadoban: plain old set theory, e.g. A x B x C has elements (a, b, c)
13:53:29 <jle`> so you could product an [(Int,Bool)] with a [(String,Double)] to get a [((Int,Bool),(String,Double))]
13:53:46 <squall> But that just sounds like garbage collection for better memory use, i don't get how it actually ends up concatenating faster, perhaps I'm confused about something
13:53:47 <jle`> and an [HList [Int,Bool]] and an [HList [String,Dobule] to get an [HList [Int,Bool,String,Double]]
13:54:04 <prsteele> jle`: right, but now we have the weird pairing structure again, which is what I'm hoping to avoid (and hence reaching for template haskell)
13:54:47 <ertes> squall: ((x:xs) ++ ys) ++ zs = (x : (xs ++ ys)) ++ zs = x : ((xs ++ ys) ++ zs)
13:54:56 <ertes> squall: two reduction steps neede to find the first element
13:55:33 <squall> Hmm
13:55:46 <squall> So it just does the first of those
13:56:10 <squall> But then why does it not simply half the concat speed?
13:56:35 <jle`> prsteele: what pairing structure do you mean?
13:56:47 <ertes> squall: (((a : as) ++ bs) ++ cs) ++ ds = ((a : (as ++ bs)) ++ cs) ++ ds = (a : ((as ++ bs) ++ cs)) ++ ds = a : (((as ++ bs) ++ cs) ++ ds)
13:56:47 <jle`> if you combine [Int] with [Bool, String], you get [Int,Bool,String]
13:56:52 <ertes> squall: three reduction steps
13:56:54 <squall> It seems to reduce it from order n to order 1
13:56:59 <jle`> prsteele: if you combine [Int,Bool] with [String, you get [Int,Bool,String]
13:57:02 <squall> Ah ok
13:57:04 <jle`> same result either way, it's commutative :)
13:57:05 <squall> Awesome
13:57:26 <ertes> squall: if you have 20 lists cascaded like that, you need 20 steps for every element of the first list, before it drops to 19, then 18, etc.
13:57:32 <squall> Thanks, that's a decent optimisation
13:57:39 <squall> First I have seen
13:57:40 <jle`> er, s/commutative/associative
13:57:49 <ertes> squall: if you right-associate (++), every element takes only one reduction step
13:58:34 <prsteele> jle`: alright I'm going to look actually install HList and check it out
13:58:43 <squall> So cool, thanks
13:59:17 <squall> And that's the principle of difference lists?
13:59:24 <ertes> squall: it's not even an optimisation…  it just makes sure you use lists the way they're supposed to be used =)
13:59:32 <ertes> squall: yeah, pretty much
14:00:00 <ertes> squall: here is an extreme example:  cycle xs = xs ++ cycle xs  -- try flipping that
14:00:12 <ertes> @let badCycle xs = badCycle xs ++ xs
14:00:16 <lambdabot>  Defined.
14:00:23 <ertes> > badCycle "… try this!"
14:00:29 <lambdabot>  mueval-core: Time limit exceeded
14:01:15 <squall> Brilliant. Now I have to learn about mutuability. (I guess if you used DList that would work)
14:01:34 <codedmart> I am trying different things and am looking for some suggestions now. I have this https://gist.github.com/codedmart/c808cd0c70fad1f4243d302bf2c78d69#file-main-hs-L34-L36. I am using `run` to kick everthing off, but in the highlighted lines if `hasMore` is true I want to make anothre request to get more, but concat those with the results from the previous
14:01:34 <codedmart> request until `hasMore` is false. Then return all results.
14:02:23 <squall> What are you getting stuck with codedmart?
14:03:31 <squall> Nice code btw
14:04:24 <squall> I'm not to sure about get, so I can't really comment
14:05:09 <codedmart> squall: Not sure how to approach it for sure. I was thinking of passing an initial accumulator with makeRequest, but when I start that it felt off.
14:09:22 <squall> I don't get what you mean, i don't know much about get
14:09:48 <codedmart> What do you mean get?
14:11:06 <squall> Are you looking for suggestions in general or are you unable to achieve something? If the latter, what?
14:15:17 <lyxia> codedmart: so what you are returning should be a list?
14:15:41 <ReinH> dfeuer: that's a cool SO question
14:15:51 <codedmart> lyxia: Well not always, but yes it is possible. 
14:15:56 <lyxia> codedmart: do you want to make the same query
14:16:18 <ReinH> dfeuer: I would guess that there are more elegant ways, but they fail on performance.
14:16:26 <lyxia> codedmart: what do you mean "not always"
14:16:30 <codedmart> lyxia: Just a slightly different url using some info from the response I have.
14:16:37 <lyxia> okay
14:16:55 <codedmart> lyxia: Meaning that when I make a request I could get a list of items or a single item.
14:17:17 <codedmart> But hasMore would be False if it was just a single item.
14:17:46 <ReinH> squall: the principle of difference lists is that composition of monoid actions is function composition!
14:19:28 <lyxia> codedmart: do you get them one at a time, hence why you need to make more requests?
14:20:11 <squall> I'm trying to get the hang of (:) and (++) and the mutuability
14:20:31 <ReinH> What mutability?
14:21:52 <codedmart> lyxia: No if I am requesting one then I only get one and hasMore will always be false. But if I request a collection hasMore could be true or false depending upon how many items are in that collection.
14:22:01 <squall> I want eg to pass the head of a list to the tail of another to implement (++) but I would like to be able to do this one element at a time (not actually (++) the lists, just shift some of one into the other) without having to copy the unaffected elements
14:22:18 <codedmart> Everything works now other then if hasMore is true I never go get more.
14:22:55 <codedmart> I have started with a few different ideas but they all feel wrong so far.
14:23:02 <ReinH> What do you mean by "copy the unaffected elements?"
14:23:27 <ReinH> Everything that you do with lists must be done one element at a time.
14:23:35 <prsteele> jle`: Okay I see where I was misunderstanding you. You weren't suggesting I have an HList of HLists, but rather a regular list containing HList elements. This might work
14:23:39 <ReinH> That's the only way to access a list
14:23:39 <grantwu> Should I replace usages of Data.List with Data.List.Stream to take advantage of better list fusion, or does GHC do that already?
14:24:11 <ReinH> Normal lists fuse.
14:24:19 <jle`> prsteele: yeah, the only awkward thing is that your 'crosses' only work directly on things that are already in hlists
14:24:25 <jle`> sort of like how ++ only works on twp lists
14:24:27 <jle`> *two
14:24:39 <prsteele> jle`: I think I can hide that, I'm trying to make a library
14:24:41 <lyxia> codedmart: I feel like there is a misunderstanding. You make a request, you get a value a0, and some stuff, including a flag, that could be false, in which case a0 is your result, or it's true, then you ask for one more value a1, and look at the hasMore flag of that one, etc, till you get some list [a0, a1, ...] ?
14:25:04 <prsteele> jle`: maybe a class
14:25:53 <jle`> prsteele: you could also get some inspiration from the (:)/(++) roles and have (*++) :: [HList as] -> [HList bs] -> [HList (as ++ bs)] as well as a (*:) :: [a] -> [HList as] -> [HList (a : bs)]
14:25:59 <ReinH> grantwu: but you can always verify for yourself by performance testing
14:26:46 <ReinH> @src (++)
14:26:46 <lambdabot> []     ++ ys = ys
14:26:46 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:26:46 <lambdabot> -- OR
14:26:46 <lambdabot> xs ++ ys = foldr (:) ys xs
14:26:59 <codedmart> lyxia: Yes that is about right. Here https://gist.github.com/codedmart/c808cd0c70fad1f4243d302bf2c78d69#file-main-hs-L9-L16. Is what I get back. result is what can be a single item or multiple. 
14:27:27 <ReinH> squall: is there something in this implementation that you are trying to change?
14:29:08 <lyxia> codedmart: to me "a" looks like a single item. I'm trying to understand whether a single ArangoResponse is supposed to contain one item at a time.
14:30:57 <lyxia> codedmart: I think you should return a list of elements, and in the case where you have just one element it would just become a singleton list
14:31:43 <codedmart> lyxia: Yeah might not be the best code :). There is only one ArangoResponse, but result can be one item or multiple.
14:32:55 <lyxia> codedmart: okay so you can't know whether you got a list or a value before actually inspecting it?
14:34:02 <lyxia> It's not something you're currently checking, but you intend to, is that right?
14:35:18 <alex_new> hey, I am tring to write "iterateM f x = f x >>= (\newX -> return (x:) <*> iterateM f newX)" but it does not work... it cycles forever... even when I use only first elements
14:35:50 <codedmart> lyxia: Yeah I do, just haven't come up with a good way to recusivly make a new request while building up the result if it is a list and hasMore.
14:35:55 <alex_new> how do you write correct iterateM?
14:38:10 <alex_new> It is even possible?
14:38:11 <alex_new> )
14:38:20 <lyxia> alex_new: you can't
14:38:28 <lyxia> well it won't work for a lot of monads
14:39:21 <carter> Dimwit dmj` ask again on #numerical-haskell and I can answer there? Don't have scroll back atm 
14:40:11 <dmj`> carter: hm?
14:40:39 <carter>  Matrix layout thingy?
14:40:39 <ph88^> johnw, when i use shachaf's golf master trophy function i get this error https://paste.fedoraproject.org/428654/73975579/ i think i have to specify it to be of type String somewhere since i use overloaded strings for Text .. but i'm not sure how to get it right (tried a few possibilities)
14:41:03 <shachaf> You probably shouldn't actually use that code.
14:41:03 <lyxia> codedmart: what would the new query be? the previous one with the new a?
14:41:17 <dmj`> carter: dimwit?
14:42:00 <dmj`> carter: yea, just using Data.Matrix for now, it let's me switch the columns and rows
14:42:10 <dibblego> @type let iterateM f a = do x <- f a; y <- iterateM f x; return (x:y) in iterateM
14:42:12 <lambdabot> Monad m => (t -> m t) -> t -> m [t]
14:42:20 <ph88^> shachaf, why not ? everyone seemed to think it was the best code ^^
14:42:23 <carter> dmj`:  dmwit  typoes ;)
14:43:00 <shachaf> This channel is incentivized to reward clever code, not good code.
14:43:01 <jle`> that iterateM isn't super useful for most Monad instances, heh
14:43:02 <ph88^> i can't get it to work either with the less slick version:  ci_gen = traverse (\ch -> elements [toLower ch, toUpper ch])
14:43:15 <shachaf> You should give your thing an explicit type signature anyway.
14:43:18 <carter> dmj`: tell me more on other channel and I can help :). Gotta shower before a date. Also there was a shooting as I walked to subway.  Might be the first time I heard gun fire in real life
14:43:18 <dmj`> carter: heh ;)
14:43:22 <dibblego> is too
14:43:27 <ph88^> shachaf, what would you say is the best code ?
14:43:28 <jle`> oh, that's the issue that alex_new is having
14:43:56 <dmj`> carter: oh wow, yes be careful, /me joins #numerical-haskell
14:44:11 <jle`> alex_new: for a trivial example as to why that doesn't work for most monads, look at Maybe
14:44:15 <jle`> er, not trivial, but simple
14:44:26 <prsteele> damn, HList has bounded definitions for hToTuple
14:44:40 <carter> dmj`: police foot chased a guy around the corner and then 3-5 fire cracker sounds ensured
14:44:46 <jle`> alex_new: in order to get the "first" item of the result, you'd need to know if the result is Just or Nothing
14:44:58 <carter> Weirdly lots of folks were sort of following the chase on foot
14:45:06 <codedmart> @lyxia no just a slightly different URL that I would use the id from the ArangoResponse to create. I think I have most of that worked on in my head. Just the recursiveness of re requests that I haven't nailed yet.
14:45:06 <lambdabot> Unknown command, try @list
14:45:10 <jle`> alex_new: but it's impossible to know if the result is Just unless you loop infinitely
14:45:38 <jle`> alex_new: if f is ever Nothing, then iterateM f x will terminate at that point and you'll get Nothing as your Maybe [a] result
14:45:40 <alex_new> yes
14:45:42 <alex_new> I see )
14:45:44 <dmj`> carter: :/ yikes
14:45:51 <jle`> alex_new: but if f is never Nothing, your iterateM will never return
14:45:52 <alex_new> thanks
14:46:20 <jle`> alex_new: if you're familiar with State, that's also a convincing example
14:46:33 <jle`> because when you runState (iterateM f x) x, you also get the "final state"
14:46:39 <jle`> but you can't get the final state unless you iterateM infinitely forever
14:47:03 <alex_new> monad are no lazy!
14:47:06 <alex_new> =D
14:47:12 <prsteele> I feel like I've implemented iterateM for []
14:47:20 <ph88^> can i do list-like operation on Text ? like pattern match (x:xs)
14:47:27 <dibblego> > take 5 (evalState (iterateM (\a -> state (\s -> (a * 2, s + 1))) 12) 33)
14:47:28 <dibblego> [24,48,96,192,384]
14:47:32 <lambdabot>  error:
14:47:32 <lambdabot>      • Variable not in scope:
14:47:32 <lambdabot>          iterateM :: (Integer -> m0 Integer) -> Integer -> State Integer [a]
14:47:41 <dibblego> oops
14:48:10 <jle`> alex_new: there are specific monads in which it will work, though :)  just not many useful ones, heh
14:48:24 <codedmart> @lyxia: just thought of something I am going to try but still open to suggestions.
14:48:24 <lambdabot> Unknown command, try @list
14:48:39 <jle`> a basic intuition is that even though you only want a little bit of the result, you still need to "execute" all of the infinite effects
14:49:35 <alex_new> yes... that is why monad are not lazy =D
14:49:42 <alex_new> monads*
14:49:54 <jle`> so it would only works on monads with no "effects" (like Identity), or some weird monads implemented with lazy effects
14:50:14 <alex_new> like IO
14:50:41 <alex_new> actually, my case is exactly Identity case
14:51:14 <alex_new> I am working with repa, and "computeP" live in any monad.
14:51:27 <lyxia> type LazyIO = Identity ; instance MonadIO LazyIO where liftIO = return . unsafePerformIO
14:51:45 <lyxia> *bam* lazy effects in one line
14:52:04 <lyxia> Don't do this at home.
14:52:13 <eikke> is there a way in stack to loosen a dependency bound of an extra-dep ?
14:52:39 <kadoban> eikke: There are no bounds in an extra-dep in stack.yaml, you specify *exactly* what version.
14:52:43 <squall> Sorry dropped connection, lost the log
14:53:09 <kadoban> This is by design, otherwise builds aren't repeatable. So, no I don't think there is.
14:53:33 <eikke> kadoban: sure, the point is that the package has too restrictive bounds in hackage :)
14:53:43 <eikke> kadoban: and I dont really feel like forking it or anyything like that
14:54:04 <ph88^> can anyone have a look if i can make my Text function more elegant?  https://paste.fedoraproject.org/428656/97638614/
14:54:35 <kadoban> eikke: Oh, that. I dunno, if it works correctly with wider bounds, maybe just submit a PR to the original thing? In the meantime, it's not hard to use your own copy of the package in stack.
14:55:09 <ReinH> squall: do you want to change the definition of (++) somehow?
14:55:22 <dmj`> isn't there a convenient function for flip map? or flip fmap
14:55:27 <ReinH> @src (++)
14:55:27 <lambdabot> []     ++ ys = ys
14:55:27 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:55:27 <lambdabot> -- OR
14:55:27 <lambdabot> xs ++ ys = foldr (:) ys xs
14:55:30 <ph88^> i notice a lot of Text functions are "subject to fusion"  what is that ? should i worry about that ?
14:55:42 <ongy> ph88^: (toLower x:toUpper x:[]) is [toLower x, toUpper x]
14:55:42 <ReinH> dmj`: lens uses <&>
14:55:44 <eikke> kadoban: I think the original, while small, may be somewhat undermaintained, and this is just me toying around. Would like others to be able to reproduce though. This seems like a missing feature in Stack to me
14:55:49 <ongy> which I think is more readable
14:56:01 <eikke> kadoban: IIRC with plain Cabal you can override bounds on the command-line
14:56:04 <squall> I was describing my desire to progress a zipper version of partial (++) do that the unchanged elements are not copied, something about mutability or persistence
14:56:32 <dmj`> ReinH: there should be like 'for = flip fmap' in Data.Function / Data.Functor or something I'd assume
14:56:51 <lyxia> ph88^: you can probably use mono-traversable
14:56:58 <ReinH> squall: how?
14:57:05 <ph88^> lyxia, whats a mono-traversable ?
14:57:22 <dmj`> ReinH: not sure I want it infix but that could work...
14:57:38 <lyxia> @hackage mono-traversable ph88^ 
14:57:39 <lambdabot> http://hackage.haskell.org/package/mono-traversable ph88^
14:58:03 <suzu_> man
14:58:13 <squall> Maybe it's automatic from a non strict zipper, thats my question
14:58:21 <suzu_> at work today, my manager was cool with me writing the project in haskell
14:58:26 <suzu_> best day of my life
14:58:34 <suzu_> then he finds out that his manager is not cool with it
14:58:40 <suzu_> rewrrrrrrrrrriting in java
14:58:41 <lyxia> ph88^: ci_gen = otraversable (\c -> elements [toUpper c, toLower c])
14:58:43 <suzu_> T_T
14:59:03 <kadoban> eikke: Not sure, if it's possible I don't know how except by using 'stack unpack', changing the bounds in the .cabal file and using that instead of the extra-dep from hackage
14:59:06 <ongy> suzu_: take 2 days to rewrite it in java. just to show how productive haskell is
14:59:19 <suzu_> heh
14:59:24 <suzu_> so i was using a lot of conduit to get the work done
14:59:26 <lyxia> ph88^: s/otraversable/otraverse 
14:59:36 <suzu_> now im trying to.. work with java streams but i havent touched java in a while
14:59:48 <MarLinn> suzu_: compile with Frege, then decompile to Java? ;)
14:59:52 <suzu_> haha
14:59:59 <eikke> kadoban: but that's not reproducible, so no-go for me :)
14:59:59 <suzu_> i think it'll make a mess
15:00:01 <squall> Does that make sense RienH?
15:00:01 <ReinH> squall: not quite sure what you're asking for, but you can't access the end of a list except by stating at the head.
15:00:02 <suzu_> :P
15:00:07 <ReinH> starting
15:00:23 <suzu_> ongy: tbh im pretty slow at writing haskell
15:00:39 <suzu_> i spend more time at my desk bending my head around a problem
15:00:43 <suzu_> like 99% of my time
15:00:47 <suzu_> and then 1% writing the thing
15:00:54 <kadoban> eikke: Sure it is, you just package it with your thing.
15:01:15 <suzu_> basically i spend most of my type playing type-lego in my head
15:01:19 <suzu_> most of my time *
15:01:26 <kadoban> (Or put it on github or wherever and use that as the dep, etc.)
15:01:27 <ggVGc> freudian slip
15:01:29 <dmj`> suzu_: that still counts :)
15:01:54 <ggVGc> I grow slower and slower at writing programs
15:01:56 <suzu_> i feel like i'd be faster just powering through the problem in some hack n' slash mutable language
15:02:10 <suzu_> and i'm probably right, as long as the project is <2k lines
15:02:14 <ggVGc> in 100 years I'll stare at my screen for a year, then write 5 lines fulfilling all the requirements of my task
15:02:15 <squall> That's ok, in a zipper the previously accessed elements are stored backwards, so you just ask for the head... I guess there is no choice but to reverse the traversal afterward or reverse one of the lists pre concatenation
15:02:18 <suzu_> after that, gg maintaining it.
15:02:27 <MarLinn> suzu_: careful with those java streams. The first (and only) time I tried them I ran into stack overflows all the time and had to rewrite everything again...
15:02:34 <suzu_> ah shit
15:02:37 <suzu_> well thanks for the heads up
15:02:42 <suzu_> i miss conduit already
15:03:03 <ReinH> squall: you still have to concatenate either way
15:03:06 <ggVGc> suzu_: quick, implement conduit in java
15:03:12 <suzu_> :|
15:03:37 <ReinH> If the lists are reversed then the order you concatenate in is reversed, and now the problem is accessing the end of the other list
15:03:51 <squall> For arguments sake can assume the left hand list has been cast to a snoc list, which is just a backward list
15:03:59 <MarLinn> suzu_: might have been birthing pains, I think I tried them early in their lifetime. But seeing how bad Java is at recursion I wouldn't count on it
15:04:21 <ReinH> ok, still the same problem, just flipped around some more.
15:04:50 <monochrom> There is no "cast". Conversion takes linear time and probably also linear space.
15:04:57 <ReinH> You have to access the end of one list and the start of the other. One of those takes O(n).
15:05:54 <suzu_> hm
15:05:55 <monochrom> When encountering a doubly-ended problem, some people say, "I know, I'll use a list and I'll reverse it". Now they have two problems.
15:05:57 <suzu_> ok
15:06:02 <ReinH> Concatenating two snoc lists happens the same way as two regular lists, you just swap ends
15:06:17 <ph88^> lyxia, do you think that otraverse is implemented for Text ?
15:06:32 <squall> My point is if I just transfer a single element, i would hope the whole list wasn't copied each time. I guess it isn't since I can use a zipper on infinite lists, so I conclude that the zipper it's lazy and achieves persistent mutability. Is that right?
15:07:18 <ReinH> I don't know what "persistent mutability" means.
15:07:32 <ReinH> Those two words are usually used as opposites.
15:07:41 <squall> That's what I'm driving at
15:07:44 <johnw> it never becomes immutable in the future? :)
15:07:51 * hackagebot cryptonite 0.20 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.20 (VincentHanquez)
15:07:53 * hackagebot x509 1.6.4 - X509 reader and writer  https://hackage.haskell.org/package/x509-1.6.4 (VincentHanquez)
15:07:55 * hackagebot x509-validation 1.6.4 - X.509 Certificate and CRL validation  https://hackage.haskell.org/package/x509-validation-1.6.4 (VincentHanquez)
15:07:58 <ReinH> I.e., A structure is either persistent or mutable.
15:08:13 <squall> So which is the zipper?
15:08:23 <ReinH> Persistent.
15:08:37 <ReinH> If we're talking about the usual ones.
15:09:01 <suzu_> ZipSource
15:09:06 <suzu_> conduit docs talk about it for like
15:09:07 <suzu_> two lines
15:09:12 <suzu_> its so damn powerful omfg.
15:09:31 <squall> But it's lazy like i suspect? It does not copy unchanged elements during partial concatenation?
15:10:29 <ReinH> What elements are unchanged? In some sense, none of the elements change.
15:11:16 <squall> Suppose I changed one
15:11:24 <ReinH> xs ++ ys shares ys, but not xs
15:11:49 <squall> Shares?
15:12:05 <ReinH> You can't change one, you can create a new zipper that differs by that element.
15:12:15 <monochrom> dcoutts hath spoken. My faith in cabal is restored!
15:12:30 <squall> That copies all elements?
15:12:44 <ReinH> Depends on how you do it.
15:12:51 <squall> Hmm
15:13:03 <squall> I thought it must because it's immutable
15:13:53 <ReinH> You can"change" the nth element of a list without copying the rest of the structure (n + 1, ...)
15:14:03 <ReinH> That's what concatenation does.
15:14:49 <ReinH> It changes the head of one list without copying the rest, but it must traverse the other list entirely too do so, creating new constructors as it goes
15:15:05 <ReinH> @src (++)
15:15:05 <lambdabot> []     ++ ys = ys
15:15:05 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:15:05 <lambdabot> -- OR
15:15:05 <lambdabot> xs ++ ys = foldr (:) ys xs
15:15:31 <ReinH> ys is unchanged, xs is deconstructed and reconstructed at the head of ys
15:15:36 <squall> No I'm using a zipper, so I the backward part is retained separately
15:15:47 <ReinH> Zippers are made of lists.
15:16:06 <johnw> squall: your zipper itself is never modified "in place"; each "change" you make results in a new version of the zipper that shares some data (but not all) with the previous version
15:16:11 <squall> You only need to do this copying when obtaining a single list
15:16:24 <ReinH> So my answer applies, modulo the implementation of zipper operations in terms of list operations
15:17:04 <ReinH> squall: how do you know that that is true?
15:17:48 <squall> Ok it might copy it but it does not change so it seems wasteful
15:18:02 <ReinH> What is "it"?
15:18:14 <ertes> squall: i suggest that you stop thinking in terms of "modifying memory" or even "immutable memory"…  think of values, functions and equations like in math
15:18:26 <johnw> ertes: I was thinking of saying this too
15:18:38 <ReinH> Can something be wasteful if there are no alternatives to compare it against?
15:18:58 <squall> ([a],a,[a]) it being fst,thrd
15:19:09 <ReinH> It uses exactly as much as it requires, and no more.
15:19:52 <codedmart> @lyxia any suggestions? 
15:19:52 <lambdabot> Unknown command, try @list
15:19:55 <ReinH> What operation are you taking about specifically?
15:20:31 <ReinH> And what do you believe is being wasted by that operation?
15:21:12 <squall> I'm trying to understand what okasaki was getting at
15:21:21 <Welkin> squall: with shared data structures?
15:21:24 <ReinH> I.e., what unnecessary work or space usage?
15:21:38 <Welkin> for any linked structure, you can have multiple nodes pointint at the same data
15:21:57 <Welkin> so a modification to a list only creates new nodes up until that node that was modified
15:22:00 <Welkin> but shares the rest
15:22:16 <monochrom> Is there any actual code you're analysing? Or is it all just empty talk?
15:22:52 <ReinH> Getting at with what specifically? Okasaki got at a lot of things.
15:23:37 <ReinH> Just show us something concrete that we can talk about
15:23:45 <zell> (\(xs,x,ys)->(x:xs,head ys,tail ys)) ["pointed",' ',"zipper"]
15:23:49 <zell> > (\(xs,x,ys)->(x:xs,head ys,tail ys)) ["pointed",' ',"zipper"]
15:23:52 <lambdabot>  error:
15:23:52 <lambdabot>      • Couldn't match expected type ‘([a], a, [a1])’
15:23:52 <lambdabot>                    with actual type ‘[[Char]]’
15:24:19 <ReinH> zell: square brackets
15:24:20 <zell> > (\(xs,x,ys)->(x:xs,head ys,tail ys)) ("pointed",' ',"zipper")
15:24:22 <lambdabot>  (" pointed",'z',"ipper")
15:24:29 <ph88^> this function works fine with an infered type, how can i fix the type?   https://paste.fedoraproject.org/428663/47397822/
15:24:36 <ReinH> That shares xs and the tail of ys
15:25:16 <zell> meaning they are coppied?
15:25:19 <Welkin> no
15:25:21 <Welkin> they are shared
15:25:28 <Welkin> it's the same data
15:25:32 <ReinH> ph88^: it can't be [a], you use Chars
15:25:47 <zell> it kind of "points" somehow
15:26:04 <ReinH> Both values refer to the same xs and the same tail of ys
15:26:07 <ph88^> ReinH, do i have to use =>  ?
15:26:22 <geekosaur> ph88^, make sure you have OverloadedStrings turned on in all places
15:26:31 <ReinH> What would => do?
15:26:42 <ph88^> geekosaur, eh i just have 1 file and i put it on the top
15:26:51 <ph88^> ReinH, not sure, set some kind of constraint maybe?
15:26:57 <ReinH> Your type claims that your function works for any type a, but you explicitly use Char
15:27:09 <ReinH> So it can't work for any type a
15:27:22 <zell> yeah, the commenting out your type works?
15:27:30 <zell> -the*
15:28:08 <jle`> ph88^: wherever you have 'a' in your type signature, write Char
15:28:18 <geekosaur> I think the assertion is that they got that signature from ghci's inferred type
15:28:20 <jle`> ie (Gen Char -> Gen [Char]) -> Gen (M.SourcePos, Text)
15:28:22 <jle`> oh
15:28:30 <geekosaur> which makes me think OverloadedStrings was in effect then
15:28:33 <ReinH> That can't be so
15:28:53 <ReinH> There's no mention of IsString
15:29:22 <mpickering> does anyone know how to view the reflex-todomvc example? the directory seems empty apart from a nix expression
15:29:23 <mpickering> https://github.com/reflex-frp/reflex-platform/tree/develop/reflex-todomvc
15:29:30 <mpickering> do I just need to runt he expression somehow?
15:29:37 <ReinH> And it can't work for any IsString instance, only for instances of the form [a]
15:29:54 <geekosaur> ok, maybe I'm misunderstanding the assertion (if it works for an inferred type, did you ask ghci for the inferred type?)
15:30:03 <geekosaur> ph88^
15:30:25 <ReinH> The inferred type surely used Char
15:30:32 <ReinH> Instead of a
15:31:14 <geekosaur> probably, yes, if I am now understanding it. I am asking if ph88^ thought to ask ghci (or ghc, via the appropriate -fwarn or -W option) what the inferred type was
15:31:23 <ReinH> geekosaur: I believe ph88^ supplied this type and doesn't understand why it doesn't type check
15:31:24 <jle`> hm
15:31:33 <jle`> it would be nice to see where the type error is happening
15:31:45 <geekosaur> never mind, I will try again if I can figure out how to ask the question I want to ask instead of the one you are answering
15:31:57 <zell> T.pack
15:31:59 <ReinH> jle`: surely it's due to the string literal
15:32:27 <ReinH> geekosaur: I understand your question now
15:32:33 <ph88^> geekosaur, i did not ask ghci for the infered type because i still have other errors, so i have to fix them first before i can ask type of functions ..
15:32:45 <geekosaur> ok
15:32:51 <ReinH> ph88^: try to work with only one error at a time
15:33:01 <ReinH> Otherwise you won't know how wrong your code is
15:33:05 <geekosaur> I think they are, they were answering my question...
15:33:09 <jle`> if it was the string literal then wouldn't it say Expected Gen [a], Actual Gen String ?
15:33:14 <ReinH> Make sure it compiles before you make more changes
15:33:22 <ph88^> i am but i started to refactor my code and suddenly i had to change stuff all over the place to get it working again !
15:33:27 <geekosaur> althoiugh that then leaves how it could have "worked"
15:34:00 <ReinH> jle`: when does GHC ever report [Char] as String?
15:34:06 <geekosaur> so anyway, the preceding guidance is correct, you can;t be generic there because you are using it at a particular type (Char) and therefore cannot say "caller gets to specify any type"
15:34:11 <jle`> hm
15:34:16 <ph88^> ReinH, geekosaur now i have a problem with the function that uses space_gen .. but this is a function of QuickCheck that is like   Gen a -> Gen [a]  so i can not make this function into type  Gen Char -> Gen String  .. not sure what to do   https://paste.fedoraproject.org/428665/39786271/
15:34:32 <zell> pass the literal as an argument
15:35:09 <geekosaur> ph88^ you do not have to change the type of the actual function, only of the function formal parameter to space_gen
15:35:38 <geekosaur> because the actual function is capable of specializing to the one you need, but space_gen cannot generalize in the other direction to any type
15:35:38 <ph88^> eh ok
15:35:51 <zell> [Text]
15:35:57 <ph88^> so i have to change it on arbTer also to  Gen Char -> Gen String  ?
15:36:21 <ph88^> i thought when i do that that i can not longer use the function that works on more types  a   ^^
15:36:24 <geekosaur> what is arbTer?
15:36:52 <geekosaur> the only change you need here is space_gen :: (Gen Char -> Gen String) -> Gen (M.SourcePos, Text)
15:37:38 <geekosaur> you do *not* need to make the same change to the declaration function that you pass to space_gen, as long as its type can be specialized to Gen Char -> Gen String (which Gen a -> Gen [a]) does)
15:37:50 <geekosaur> *declaration of the function
15:37:51 <zell> you can pass the string and the function T.pack as arguments
15:38:04 <ph88^> geekosaur, arbTer is the function on line 10  https://paste.fedoraproject.org/428665/39786271/  it generates an arbitrary Token given a Text generator, function to control spaces and token version
15:38:10 <ReinH> > id 'a'
15:38:13 <lambdabot>  'a'
15:38:26 <ReinH> id can be applied to a Char even though its type is
15:38:31 <ReinH> :t id
15:38:33 <lambdabot> a -> a
15:38:43 <geekosaur> yes, that;ll be the same issue
15:39:11 <ph88^> geekosaur, ok so there i also change to to   Gen Char -> Gen String  (i already tried this, it type check now)
15:39:19 <ph88^> thx geekosaur & ReinH 
15:42:54 <ydl> why isn't foldable monomorphic? what i mean is that the typeclass "Foldable t" doesn't actually use the fact that t can hold arbitrary types. it would not be less flexible to have "Foldable t a" with "foldr :: (a -> b -> b) -> b -> t -> b". is this only done to avoid multiparamtypeclasses or typefamilies in base?
15:45:09 <jle`> ydl: i think it's so that Traversable can require Functor
15:45:47 <johnw> ydl: what you're suggesting is addressed very ably by lens
15:45:51 <jle`> but they do probably want to avoid mpc/type families
15:46:08 <jle`> the monotraversable package also has the Foldable that you're thinking of, using type families
15:46:24 <johnw> in fact, you can use lenses for what Foldable and Traversable do, and much more flexibly; Foldable and Traversable just give you some convenience when the structure is functorial
15:46:24 <jle`> johnw: maybe, but lens is a bit different because it doesn't enforce a "canonical" folding/traversing
15:46:35 <mpickering> what does that mean
15:46:41 <johnw> as far as I know, there is no such thing as a canonical fold
15:46:48 <mpickering> I think johnw is right
15:46:59 <mpickering> the foldable class is  lawless anyway
15:47:00 <johnw> this has been discussed on the libraries list in the past, btw
15:47:07 <jle`> as in, consistent and associated with that type for all use situations
15:47:19 <jle`> similar to how it'd be not-so-great to have a selectable ord instance
15:47:32 <jle`> if you had the same Set, you would hope that every time it's used, the Ord instance of the contained items are the same instance
15:48:28 <johnw> jle`: see https://mail.haskell.org/pipermail/libraries/2015-February/024943.html and the long thread that resulted
15:48:53 <johnw> well, just ~20 messages, not so long
15:49:28 <johnw> sclv even wrote it up as an IFL 2014 submission: https://ifl2014.github.io/submissions/ifl2014_submission_12.pdf
15:49:55 <jle`> hm perhaps i don't mean canonical, but coherent
15:50:19 <mpickering> I'm not sure what you mean at all
15:50:26 <mpickering> coherent with what?
15:51:28 <ydl> but all this makes putting a foldable constraint almost inherently too restrictive. the particular issue I am annoyed with is that this means Control.Foldl does not work with monomorphic containers at all, for absolutely no reason.
15:52:45 <mpickering> you can use either folds in the lens library (recommended by me and johnw)
15:52:53 <mpickering> or the other monotraversable class 
15:53:44 <mpickering> I think the class is like it is because it is intuitively functors which are foldable and then it allows the methods to be parametric over a and b
15:53:50 <ydl> johnw: you also mention that Foldable gives extra convenience if the structure is functorial. what convenience are you referring to? it seems being a functor adds nothing to the capabilities of foldable
15:53:59 <mpickering> which gives you certain free theorems about their behaviour 
15:54:33 <mpickering> If you have a MPTC "Foldable a b" then the method is no longer parametric
15:54:54 <johnw> ydl: never mind, Foldable doesn't require Functor, I withdraw the comment
15:55:31 <johnw> it was something edwardk said to me about why Traversable is worth still using, when one has lens traversals; but now I'm failing to recall exactly what his point was
15:55:55 <mpickering> You can implement fmap if you have foldable as you can implement traverse right?
15:56:04 <dibblego> johnw: maybe this https://github.com/ekmett/lens/wiki/Derivation
15:57:15 <dibblego> you can get functor and foldable from traversable, as fmapDefault and foldMapDefault
15:57:19 <johnw> how could foldable let you implement fmap?
15:57:31 <dibblego> it cannot
15:57:43 <mpickering> also ydl do you have a functional dependency on your type class?
15:57:48 <mpickering> otherwise type inference might suffer
15:59:27 <mpickering> oh right you get this weaker method https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Foldable.html#v:traverse_
15:59:52 <mpickering> I don't understand really why people are happy with the foldable typeclass when they are usually so insistent that type classes should have laws.
16:00:03 <EvanR> who is happy with it?
16:00:12 <mpickering> It exists in base
16:00:22 <EvanR> that explains why you cant get rid of it
16:00:26 <EvanR> but not who is happy with it
16:00:40 <monochrom> I am happy with it and I don't think it's lawless.
16:00:55 * EvanR calls the witness to the stand
16:01:10 <glguy> monochrom: Can you confirm that you are people?
16:01:20 <ReinH> foldr has plenty of laws
16:01:26 <monochrom> perhaps I am against the people
16:01:31 <mpickering> Err it only moved into base in a very recent ghc version
16:01:36 <ReinH> Many are used to implement fusion rules
16:02:31 <ReinH> foldr f z . fmap g = foldr (f . g) z, etc.
16:03:43 <johnw> I fought the law... but then realized it was just Foldable
16:03:54 <mpickering> That is a free theorem which arises from naturality of a?
16:04:13 <mpickering> maybe just the free theorems are sufficient 
16:04:23 <EvanR> what is naturality of "a" ?
16:04:42 <johnw> I would say it arises from the functor laws
16:05:31 <mpickering> I guess I should say naturality in a rather than of a
16:06:12 <ReinH> https://core.ac.uk/download/pdf/22879638.pdf, etc
16:06:16 <ydl> mpickering, johnw: you guys suggest using lens, but the intention of that library is not efficient iteration, as is the intention of Control.Foldl . I can even give a small example; suppose you want to iterate over the digits of an integer. i can define "data Digits = Digits Int", and a "foldrDigits f a (Digits n) = fr a n where fr a n = if n > 0 then fr (f (n `rem` 10) a) (n `quot` 10) else a". this is a perfectly good fold! but
16:06:16 <ydl> suppose i wanted to find the average of the digits in an idiomatic way. if Control.Foldl wasn't monomorphic i could do "import qualified Control.Foldl as L; L.fold ((/) <$> L.sum <*> L.genericLength) $ Digits n" to get the average of the digits in only a single pass. does lens have combinators to do this?
16:07:38 <johnw> ydl: see also http://hackage.haskell.org/package/folds, but the author of lens
16:07:53 * hackagebot exinst 0.1.2 - Derive instances for your existential types.  https://hackage.haskell.org/package/exinst-0.1.2 (RenzoCarbonara)
16:07:55 * hackagebot exinst-aeson 0.1.0.2 - Derive instances for the `aeson` library for your existential types.  https://hackage.haskell.org/package/exinst-aeson-0.1.0.2 (RenzoCarbonara)
16:07:57 * hackagebot exinst-bytes 0.1.0.2 - Derive instances for the `bytes` library for your existential types.  https://hackage.haskell.org/package/exinst-bytes-0.1.0.2 (RenzoCarbonara)
16:07:59 * hackagebot exinst-hashable 0.1.0.2 - Derive instances for the `hashable` library for your existential types.  https://hackage.haskell.org/package/exinst-hashable-0.1.0.2 (RenzoCarbonara)
16:08:01 * hackagebot exinst-deepseq 0.1.0.1 - Derive instances for the `deepseq` library for your existential types.  https://hackage.haskell.org/package/exinst-deepseq-0.1.0.1 (RenzoCarbonara)
16:08:18 <johnw> by*
16:08:47 <mpickering> I will have to think more about the proof of the fusion law
16:09:36 <johnw> actually, I can fabricate a Foldable instances that breaks that "law"
16:09:58 <johnw> so while I can believe it holds for the definition of foldr on lists as given in the Haskell report, I don't believe it's a law that pertains in general to Foldable
16:10:21 <mpickering> thanks johnw, make sense
16:10:35 <johnw> let me actually prove that I can do that....
16:12:19 <mpickering> I'm seeing a quote which says the proof relies on the uniqueness principle of folds
16:12:50 <mpickering> which is quite a different situation to what we have here as we don't set up all our datatypes as fixed points of functors
16:14:11 <mpickering> this is the precise problem with the class! It's so hard to get a handle on what the expected semantics are.
16:25:38 <johnw> well, I haven't found a way to break it so far, but I must turn to other things
16:25:47 <johnw> so until then, maybe ReinH is right
16:26:56 <ReinH> I am right until proven otherwise
16:28:49 <johnw> works for me :)
16:35:26 <kosh_> hey, does Repa.fftw work in parallel?
16:38:05 <lpaste> koz_ pasted “Confused about how to use lenses properly here” at http://lpaste.net/197405
16:39:23 <mpickering> kosh_: How do the lenses for v and e get defined
16:39:39 <koz_> mpickering: The TH invocation just below.
16:39:49 <koz_> It basically defines them in the default way 
16:39:51 <mpickering> right but what do they look like
16:40:01 <mpickering> It doesn't seem like they should work
16:40:20 <mpickering> can you paste the output of -ddump-spices
16:40:25 <mpickering> -ddump-splices
16:40:27 <koz_> mpickering: Yeah, now that you mention it - they'd have to allow GraphBits to be a and b simultaneously.
16:40:31 <shachaf> kosh_: There's no good way to do that with the lens library as it is. v and e can't change the type individually.
16:40:36 <shachaf> I mean koz_:
16:40:56 <shachaf> koz_: There was a proposal for a somewhat hacky way of making it work. But I don't think it ever happened.
16:41:04 <koz_> shachaf: I see... That's rather annoying. I guess I can just manually define its Functor instance.
16:41:13 <koz_> mpickering: Thanks for making me think about it in the right way.
16:42:01 <koz_> Or I can write a special type-transformer lens - it's actually just a graph relabelling.
16:42:02 <mpickering> A lens is the witness to the product structure of your datatype. However here you can't separate out the product structure as the two fields depend on each other via the type variables.
16:42:24 <koz_> mpickering: Yeah, I get that now. This is what I get for coding with a migraine, lol. :P
16:44:09 <koz_> mpickering: Technically, I guess what I have here is an iso, provided that the function turning as into bs is bijective, right?
16:44:25 <mpickering> An iso between?
16:44:56 <koz_> mpickering: ... never mind, I'm just dumb. Isos go between types, not between different instantiations based on a type parameter.
16:45:36 <mpickering> you could have an Iso (Graph a) (Graph b)
16:46:17 <mpickering> but then you might as well just have a functor instance
16:46:17 <koz_> mpickering: Yeah, I guess that's what I was trying to get at. But if the labelling of the vertices has to be unique, then the function converting as to bs (internally) has to be a bijection.
16:46:27 <koz_> Yeah, I'm thinking a functor instance wouldbe much easier.
16:46:31 <mpickering> right of course
16:50:27 <suzu_> conduit vs pipes
16:50:27 <mniip> hey shachaf
16:50:29 <suzu_> any opinions?
16:50:37 <shachaf> hiip
16:51:07 <mniip> is lem provable from contraposition of implication?
16:51:40 <johnw> ReinH: actually, I can prove you right, due to the free theorem for foldr
16:51:46 <mniip> I'm looking at curry-howard of the problem and I can't see any way to "produce" negations
16:51:47 <shachaf> What, from forall a b. (a -> b) -> Not b -> Not a?
16:51:48 <johnw> ReinH: https://gist.github.com/59399c3a7995a3cb2ece7fb851dc431e
16:52:18 <mniip> no, the other one
16:52:21 <shachaf> Or the other way around, I guess.
16:52:25 <shachaf> (Not a -> Not b) -> b -> a
16:52:30 <ReinH> johnw: presto same-o!
16:52:31 <mniip> . yes
16:52:47 <shachaf> Sure.
16:53:46 <shachaf> ((a -> Void) -> b -> Void) -> b -> a; apply the function to the b, get ((a -> Void) -> Void) -> a
16:54:09 <shachaf> Probably better using r than Void, but whatever.
16:54:13 <mniip> uh
16:54:25 <mniip> no voids
16:54:34 <shachaf> Then what?
16:54:43 <mniip> Not is considered elementary
16:54:58 <shachaf> By whom?
16:55:07 <mniip> well, by this thing
16:55:37 <shachaf> OK, then use whatever Not rules you're allowed to use.
17:01:36 <luite> ohayou gozaimasu! anyone already near nara/osaka for icfp? (or not for icfp but still nearby :) )
17:15:28 <johnw> luite: sadly, I cannot see you at this year's ICFP, it was too far
17:21:14 <ReinH> same :(
17:24:56 <mniip> shachaf, hmm looks like it isn't provable in my axiom set
17:25:22 <mniip> and, well, contraposition is the only "Not rule" I'm allowed to use
17:25:24 <shachaf> mniip: Are you asking people whether propositions are true without telling them your axioms?
17:25:42 <mniip> 1473983445 [02:50:45] <mniip> is lem provable from contraposition of implication?
17:25:53 <mniip> only |-, nothing about propositions being true :p
17:26:24 <luite> it will be a quiet ICFP :(
17:26:40 <mniip> thing is, there is no way to prove (a -> _|_) -> Not a
17:26:51 <mniip> because there's no 'a' to apply
17:26:53 <shachaf> Then how do you prove Not a?
17:27:04 <mniip> exactly
17:27:04 <mniip> you don't
17:27:34 <mniip> you can take apart a "Not": Not a -> a -> _|_ is provable
17:27:41 <mniip> via contraposition
17:27:51 <mniip> but not vice versa - you can't construct a "Not"
17:29:10 <shachaf> Doesn't sound very useful.
17:29:30 <mniip> right
17:36:01 <zennist> when people talk about - it's refering to the *evaluation* not execution right? 
17:36:08 <zennist> talk about lazy 
17:37:13 <c_wraith> zennist: yes
17:37:43 <c_wraith> zennist: lazy execution is *mostly* frowned on these days.  It's available via unsafeInterleaveIO, if you really want to go there. :)
17:37:44 <zennist> so evaluation is a runtime thing 
17:38:09 <c_wraith> So is execution
17:38:24 <c_wraith> The difference is what the code is defined in terms of.
17:38:43 <c_wraith> Evaluation is performing graph reduction on expressions.
17:38:58 <c_wraith> Execution is crazy real-world stuff the runtime does with IO, ST, STM, and other things built into it.
17:39:36 <zennist> i see - makes sense
17:39:47 <zennist> but this means that execution might not be as well-defined
17:40:03 <c_wraith> That's true.
17:40:29 <c_wraith> People sometimes refer to IO as the "sin bin" because you can throw *anything* into it, well-defined or not
17:40:37 <zennist> i guess the only real constraint to it is that if an IO comes after another, it's executed in the same order
17:41:04 <c_wraith> As long as unsafeInterleaveIO doesn't get involved, anyway...
17:41:29 <zennist> yeah i know - but we can remove that from discussion for now :)
17:41:41 <c_wraith> Usually, execution of IO actions drives the evaluation of expressions.
17:42:05 <c_wraith> The various unsafe functions allow evaluation to drive execution
17:42:13 <zennist> but what's interesting is that - say evaluation order and execution order is independent, then the compiler chooses to evaluate something that will be executed way later - this means that i would get slower performance for that first execution to occur right?
17:42:45 <osa1> which library exports the kind Constraint ?
17:42:45 <c_wraith> Well - In theory, the compiler could choose to evaluate things in a different order than required for execution
17:43:06 <osa1> ah, found it
17:43:16 <zennist> i see - so it's really up to it to determine what would be 'faster'
17:43:24 <c_wraith> But in practice, everyone uses a model where evaluation is tied to execution, so that things are only evaluated when needed.
17:43:50 <zennist> which goes back to your point: execution -> evaluation
17:44:23 <zennist> the other question I have: how does evaluation/execution order relate to gc
17:45:07 <zennist> say a ForeignPtr, I know it would be deleted once nothing refers to it - but how can you know nothing is refer to it if you got lazy structure and things are hidden inside?
17:45:11 <c_wraith> That gets very compiler-specific.  I can answer some questions about GHC, but it's specific to GHC.
17:45:19 <zennist> yeah that's fine
17:45:32 <c_wraith> hah.  That one is actually covered somewhat in the docs.  See touchForeignPtr
17:46:59 <c_wraith> It exists purely to be an IO action that indicates "until this is executed, that ForeignPtr still has a live reference"
17:47:18 <zennist> reading it - but from the doc seems like the only thing it says is that touchForeignPtr can make compiler know that it should be alive
17:47:25 <zennist> i see
17:48:17 <zennist> so this promise of detecting anything 'refering to it' is a bit fake - if one doesn't use withForeignPtr or touchForeignPtr, this would happily delete it
17:48:41 <c_wraith> yeah..  Those are the mechanisms by which it "detects" it.
17:48:47 <c_wraith> It's not magical.
17:49:32 <zennist> i'm also curious how the compiler detects all these touchForeignPtr calls - doesn't it have to evaluate all IO actions to understand at which point in execution it can drop the pointer? kinda breaking our previous assumption of the evaluation/execution order
17:50:00 <c_wraith> Eh, the only thing special about touchForeignPtr is that it's not optimized out as an obvious no-op
17:50:20 <glguy> I don't think it's that smart, if it looks like the ForeignPtr is still being referred to somewhere it won't be GCd
17:50:37 <c_wraith> I mean, ultimately, it's still a copying collector.
17:50:47 <zennist> the trouble i'm having is understanding how it does that precisely
17:50:49 <glguy> the touches are just explicit references to the foreign ptr so that there's definitely a reference which is tied to execution
17:50:49 <c_wraith> It traverses the object graph, and keeps the things it detects as live
17:51:27 <zennist> when you traverse the object graph - that's the evaluated object graph?
17:51:33 <c_wraith> No
17:51:35 <glguy> You don't actually need to use any touches to keep a foreign ptr alive, but touching is still a good idea
17:51:42 <c_wraith> This is at a lower level.
17:51:52 <c_wraith> The GC doesn't care if something is evaluated or not
17:52:07 <c_wraith> The only thing it cares about is how many words the constructor is, and which of them are pointers.
17:52:17 <c_wraith> And that at the STG level
17:52:21 <dmwit> zennist: Things that are not fully evaluated yet have a table at the front pointing to all the things they need to keep alive to make sense.
17:52:28 <c_wraith> so the constructor could be for an unevaluated expression.
17:52:35 <dmwit> zennist: The "graph" has these things as nodes and the pointers as edges.
17:52:57 <zennist> i see, so basically the unevaluated representation of the code needs to guarantee at least, it's consistent such that it holds the necessary pointers
17:53:09 <c_wraith> yeah.
17:53:09 <dmwit> zennist: The compiler starts from a few places -- notably, the IO action that's currently being executed -- and declares those and anything they eventually point to as "alive".
17:54:38 <zennist> but this seems to imply that these pointers needs to be allocated before things are evaluated ... which doesn't quite make sense? (e.g. we have a foreign pointer and one would obviously assume it's only allocated when the IO is executed)
17:55:18 <dmwit> You need to differentiate between Haskell-level pointers and runtime-level pointers, I think.
17:55:23 <zennist> unless they use some sort of secondary representation that wraps around the pointer to be allocated
17:55:48 <c_wraith> conceptually, it is a different thing.
17:56:07 <zennist> dmwit: haskell-level pointers would be pointers to expressions..?
17:56:08 <c_wraith> But it turns out that you can optimize them to the same thing for runtime efficiency.  But yeah, they are conceptually different.
17:56:26 <dmwit> zennist: ForeignPtr is what I'm calling the Haskell-level pointer.
17:57:26 <zennist> i thought that would only be available after evaluation...
17:57:59 <zennist> i guess in my mind 'thunk' is really like a thunk - there is nothing much inside
17:58:25 <zennist> aside from some instruction in it allowing the runtime to evaluate the thunk when requested
17:58:52 <c_wraith> an unevaluated thunk is usually implemented with a closure
17:59:05 <zennist> but now given that haskell pointers exsit before evaluation, there must be some actual useful content in it
17:59:08 <c_wraith> Which is a combination of a function pointer and a table of values
17:59:09 <ben> where do i go for a prelude that has (++) defined on monoids, these days
17:59:55 <c_wraith> by the way, this is important for understanding space leaks in haskell.  a *huge* object graph can be reachable only via a thunk
18:00:25 <zennist> i see.. is there some good reading on these topics..?
18:00:27 <c_wraith> It's called a space leak when evaluating some of it would allow the object graph to be collected.
18:00:53 <dmwit> ben: Why not use (<>) instead? It's just as short, and just as infix, and boring old base has it.
18:01:07 <zennist> i find my brain just hurts more and more given how little i know these details
18:01:17 <ben> I've never heard of <>
18:01:28 <c_wraith> zennist: ezyang's blog is a good reference.  He talks about ghc internals a bunch.
18:01:52 <c_wraith> zennist: and no worries.  There's a huge amount of foundational knowledge here.  If you don't know it, the next step is rough.
18:01:54 <dmwit> zennist: The "Spineless Tagless Z-Machine" is often recommended, and then there's the paper on "eval/apply" vs. "push/enter" that I think talks about a slightly more modern approach.
18:02:13 <c_wraith> zennist: http://blog.ezyang.com/
18:04:27 <zennist> great thx.. sometimes i think about the two different ways to understand haskell: one is to enter from a mathematical front and get the correct behavior without the need to understand how the internals work / the other is to actually understand how these are implemented such that good code can be written
18:04:43 <dmwit> Both are important.
18:04:58 <zennist> i found materials on later are probably lacking
18:05:45 <dmwit> "Implementing lazy functional languages on stock hardware" http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3729&rep=rep1&type=pdf
18:06:08 <dmwit> "Making a fast curry for higher-order languages" http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.9317&rep=rep1&type=pdf
18:06:49 <c_wraith> zennist: recall that GHC is the result of well over 20 years of development now.  It wasn't simple to get where it is now.
18:06:59 <dmwit> And this particular series on ezyang's blog is probably a great starting point related to this discussion: http://blog.ezyang.com/2011/04/the-haskell-heap/
18:07:55 * hackagebot stack 1.2.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.2.0 (borsboom)
18:07:57 * hackagebot kawhi 0.2.1 - stats.NBA.com library  https://hackage.haskell.org/package/kawhi-0.2.1 (aaron)
18:08:37 <zennist> awesome - going to be a weekend filled with reading
18:13:41 <glguy> Oh, new stack
18:18:09 <kosh_> how is that happen tat Text.Printf takes arbitrary large number of arguments
18:18:56 <glguy> kosh_: Have you looked at its type?
18:19:01 <glguy> and the instances of the class that it uses?
18:19:21 <dmwit> kosh_: http://stackoverflow.com/q/7828072/791604
18:19:33 <kosh_> thanks
18:20:07 <shachaf> As an exercise, write a function that counts the number of arguments you give it. Or gives them to you in a list.
18:20:15 <kosh_> I was shocked a little bit at first)
18:20:36 <Hafydd> f _ = 1
18:20:44 <Hafydd> f x = [x]
18:20:49 <Hafydd> Next question.
18:25:33 <ashishnegi> hi.. i have a basic `stack` question .. i use a package `scalpel` which is not on `stackage` so i need to add it to stack.yaml .. right ? to get it fetched from hackage ??
18:26:41 <glguy> Yes to your extra-deps! from hackage!!
18:28:50 <peddie> kosh_: how'd you go with your FFTs?
18:29:33 <ashishnegi> ok.. so once i add it.. when i add packages like `stm` to .cabal file after `scalpel` , stack fails with --  Failure when adding dependencies: stm: needed (-any), stack configuration has no specified version (latest applicable is 2.4.4.1)
18:30:03 <glguy> You need to tell stack which version you want to use
18:30:37 <ashishnegi> glguy: in .cabal file. ?
18:30:43 <kosh_> peddie: I moved to repa )
18:30:58 <glguy> ashishnegi: Which resolver are you using?
18:31:02 <kosh_> peddie: not only because of ffts
18:31:08 <ashishnegi> glguy: ghc-7.10.3
18:31:28 <peddie> kosh_: cool, how is it?
18:31:31 <glguy> ashishnegi: OK, the ghc-* resolvers require you to specify all packages you're using in your extra-deps including what version
18:31:47 <glguy> of all your transitive depenedencies not just the stuff used by your package and listed in the cabal file
18:31:52 <kosh_> peddie: fine so far...  But still, I only did linear part of PDE
18:31:55 <glguy> "stack solver" can help populate that
18:32:21 <peddie> kosh_: always got to start with that, anyway :)
18:32:30 <ashishnegi> glguy: oh.. so if i have to use `ghc-*` resolver than i have to put version for each dependency..
18:32:44 <nshepperd_> quchen did a talk about stg machine: https://www.youtube.com/watch?v=-MFk7PIKYsg
18:32:51 <nshepperd_> which I enjoyed
18:33:02 <ashishnegi> glguy: what happens if i do not put any `resolver` ? how does stack finds right versions on other's machines ?
18:33:04 <peddie> kosh_: cool, I hope it goes well!  do let me know if you put your code on github
18:33:26 <glguy> ashishnegi: I suspect you'll just get an error message if you omit the resolver
18:33:28 <kosh_> peddie: I will, just need to make everyting more or less right
18:33:46 <glguy> ashishnegi: when someone else makes their own stack.yaml with stack init they can pick the resolver
18:35:27 <glguy> The range of packages that your package supports are captured in your package's .cabal file which will inform other users about which resolvers are expected to work
18:37:12 <ashishnegi> glguy: cool.. actually my first project, i used resolver: lts-6.12 and i did not faced any such problem; this is my second project.
18:37:54 <glguy> unlike the ghc- resolvers, the lts resolvers have many pre-selected packages
18:40:40 <ashishnegi> glguy: what is the recommended way to go with resolvers ? lts-* or ghc-*
18:41:29 <glguy> They do different things. if you want the versions selected in an lts resolver, use that. If you want to specify the versions yourself using ghc-
18:41:43 <glguy> The lts path is the easiest if the versions in lts are what you need
18:42:51 <ashishnegi> glguy: thanks.. you cleared a lot of doubts.. thanks :)
18:44:24 <kappter> clear
19:07:57 * hackagebot u2f 0.1.0.0 - Haskell Universal Two Factor helper toolbox library thing  https://hackage.haskell.org/package/u2f-0.1.0.0 (ebutleriv)
19:26:43 <heebo> hello i have a question , why cant i use ``` (fmap . fmap ) fa2b (EitherT fga) ```
19:28:21 <koz_> heebo: Because the Functor definition for Either operates on Right, and does nothing if it's a Left.
19:28:27 <koz_> (also, I'm not sure that compiles)
19:28:51 <heebo> koz it doesnt :P , i wanted to know why
19:29:09 <heebo> just working through haskellbook
19:29:39 <koz_> heebo: The use of EitherT there is suspect, but I'd wait for someone more knowledgeable about monad transformers than me.
19:30:11 <heebo> and I see that EitherT is a monad that contains another monad That contains an either
19:31:19 <heebo> and I just want to apply a function to the Right value of the innermost either, and i think since monads are functors i can just compose fmaps and drill all the way down to the innermost type
19:31:33 <heebo> GHC barfed at me instead , and i cant figure out why
19:35:23 <koz_> heebo: EitherT is a monad transformer. Why do you have nested Eithers? Do you just want an Either something?
19:35:36 <koz_> Also, 'Either' is not a constructor - you would use Left or Right, depending on what you wanted.
19:37:13 <ReinH> (Either is a type constructor, not a data constructor)
19:37:19 <heebo> ok it was meant to be kind of pseudocode, ill create a gist 
19:37:32 <heebo> because i dont think ive explained the question very well
19:39:04 <koz_> heebo: That would help. Generally, to help with Haskell code, we need Haskell code. :)
19:41:37 <lpaste> heebo pasted “whats up with swapEitherT'” at http://lpaste.net/197413
19:42:35 <heebo> its just swapEitherT' that I am concerned about
19:43:31 <heebo> its an utterly useless function that swaps Right and Left on an either, but I would like to compose fmap to drill into it
19:44:46 <koz_> heebo: Either doesn't contain both a Left and a Right. It's *made* either using Left or using Right. So I don't get what 'swapping' you're trying to do. Are you trying to turn arbitrary Lefts into arbitrary Rights?
19:45:06 <heebo> yes , its an exercise from a book
19:46:06 <heebo> its pretty pointless , the question is: I have a newtype , that is a functor , which contains a monad, and I want to apply a function to something right in the centre
19:46:06 <koz_> Well, let's do this real simple: let's just have an Either a b, and you want an Either b a. Let's avoid all the wrapping.
19:46:08 <peddie> heebo: have you looked at how the Functor instance for Either works?  it doesn't treat Left and Right the same way
19:46:16 <koz_> Also, what peddie said.
19:47:28 <heebo> I shouldnt have to consider how it works, i know its a functor I just want to  fmap that **it
19:48:38 <peddie> heebo: you don't need to know how it's implemented, but you need to know what its behaviour is.  `fmap` only operates on things contained in a Right, without touching the Right constructor.  if you call it on a Left value, it doesn't do anything.
19:49:09 <heebo> peddie right but it should still compile shouldnt it?
19:49:50 <heebo> maybe its the newtype containing a functor is not the same as a functor of a functor
19:50:03 <peddie> >  \eT -> (fmap . fmap )  (either Right Left)  eT
19:50:05 <peddie> er
19:50:06 <lambdabot>  error:
19:50:06 <lambdabot>      • No instance for (Typeable f0)
19:50:06 <lambdabot>          arising from a use of ‘show_M221217351526288630825287’
19:50:10 <peddie> :t  \eT -> (fmap . fmap )  (either Right Left)  eT
19:50:12 <lambdabot> (Functor f1, Functor f) => f (f1 (Either b a)) -> f (f1 (Either a b))
19:50:19 <peddie> seems to type check OK here . . .
19:51:06 <heebo> hmm maybe intero is lying to me, ill try to compile on the cli
19:52:47 <peddie> heebo: I don't think its type matches your type declaration, though
19:54:07 <heebo> yes , its weird im missing something .... I think
19:54:09 <peddie> heebo: if `EitherT e m` is the Functor `f1` in lambdabot's type above, then you're going to return something with type `EitherT e m (Either a b)`
19:54:21 <peddie> plus another functor outside it
19:55:19 <peddie> heebo: I suggest you take a look at how `fmap` is defined for Either and EitherT, and then build up your expression bit-by-bit from the simplest case (just swapping an Either)
19:55:35 <heebo> peddie: thanks
19:56:05 <peddie> heebo: have fun :)
20:03:49 <slack1256T> anybody using qtah here? I want to ask some questions
20:06:14 <heebo> ive concluded ... that i dont understand , will look again in the morning . night all
20:07:13 <khumba> slack1256T: I'm the author, if that counts :).
20:08:22 <b28000> :r
22:27:53 <d34df00d> Hi there!
22:28:57 <Axman6> Hello!
22:29:37 <d34df00d> Let's say I have a library with a typeclass and a few instances like this: http://melpon.org/wandbox/permlink/l2XRp9ZXyI8veaWv . Let's say I want to write a generic implementation for columnTypes so tha tI don't have to convert my datatypes to tuples or write the instance explictly. I gave a shot to GHC Generics, and it worked well for other methods (not mentioned in this code), but I can't seem to make it work with this one.
22:30:41 <d34df00d> The problem I'm facing is that the only dependency of `columnTypes` on `a` is via Data.Proxy, so all I get in my generic function is a U1 ctor (since `data Proxy a = Proxy`).
22:30:46 <d34df00d> What are my best options?
22:31:31 <Axman6> perhaps you can use something from typeable?
22:31:45 <glguy> d34df00d: Where do you get stuck using Generics?
22:32:38 <d34df00d> Axman6: I briefly considered it, but too briefly perhaps :) Should I try more with it?
22:33:09 <Axman6> generics doesn't feel like the right thing here
22:33:31 <d34df00d> glguy: well, how do I get the generic representation for the `a` behind the `Proxy a` type, if the instance of the type doesn't depend on a?
22:34:09 <glguy> You don't need to get one, you just need to drive the instances with Rep a
22:34:10 <d34df00d> My gut feel is that in order to use generics I need some kind of run-time object (not a type!) dependent on the variable I'm trying to handle "generically". Ther eis no such variable in this case, just type.
22:34:21 <d34df00d> glguy: but how do I get Rep a?
22:34:23 <glguy> I think this is going to be a very appropriate use of generics
22:34:28 <glguy> You don't need one
22:34:34 <glguy> It's a type, you don't need a value of it
22:34:43 <glguy> Proxy (Rep a)
22:34:48 <d34df00d> Well, yes, but I could only manage to get Rep (Proxy a)
22:35:07 <d34df00d> Which is a U1 wrapped into a couple of M1s.
22:35:21 <glguy> gcolumnTypes :: Proxy (f p) -> [ColumnType]
22:35:26 <d34df00d> (this is my first try with generics, so I hardly grasped that fully yet)
22:35:37 <glguy> I'll take the Pepsi challeng
22:35:59 <d34df00d> glguy: hmm, let me think about this...
22:40:52 <lpaste> glguy pasted “for d34df00d” at http://lpaste.net/197551
22:41:00 <glguy> d34df00d: Don't peek until you're ready
22:51:01 <d34df00d> Yay, I got this:
22:51:09 <d34df00d> http://bpaste.net/show/11b613603a49
22:51:33 <glguy> Looks pretty close to mine
22:51:34 <d34df00d> glguy: many thanks, that hint about the signature of gcolumnTypes was very, very good :)
22:51:52 <glguy> d34df00d: You actually only need a Proxy f, rather than Proxy (f p) as it happens
22:51:59 <glguy> (not much different but slightly simpler)
22:52:25 <glguy> You can see it together in http://lpaste.net/197551
22:52:32 <eklavya> how do I pass parameters to an exe in stack exec?
22:52:38 <d34df00d> glguy: what's the purpose of p in my code BTW? The page on Haskell wiki says it's about future compatibility (wut?), but it rather reminds me the rank-2 trick for ST.
22:52:46 <geekosaur> stack exec -- program args
22:52:55 <geekosaur> the -- keeps stack from gnu-eating options
22:52:56 <d34df00d> Or not in my code, but, like, at all.
22:53:01 <glguy> d34df00d: The extra parameter allows the Rep and Rep1 stuff to share types
22:53:07 <eklavya> thanks geekosaur :)
22:53:15 <d34df00d> Oh, makes sense.
22:54:12 <glguy> d34df00d: but like I mentioned you don't actually need to use the p here
22:54:42 <glguy> newtype Par1 p = Par1 {unPar1 :: p}
23:11:39 <d34df00d> glguy: hmm, could you please explain why the signature for genericColumnTypes is like this? Why can't one write just Proxy a as the type of the argument?
23:13:26 <glguy> d34df00d: I don't understand. Could you show me the alternative in question?
23:22:08 <d34df00d> glguy: just genericColumnTypes :: Proxy a -> [ColumnType]
23:22:22 <d34df00d> It gives the following for me:
23:22:23 <glguy> Oh, that'd be fine
23:22:30 <d34df00d> http://bpaste.net/show/d1245fe555e2
23:22:47 <d34df00d> Replacing with your version of the signatures fixes things.
23:23:40 <glguy> So you mean: genericColumnTypes _ = gcolumnTypes (Proxy :: Proxy (Rep a))
23:23:48 <glguy> why not: genericColumnTypes _ = gcolumnTypes (Proxy :: Proxy a)
23:23:49 <glguy> ?
23:24:36 <d34df00d> glguy: what'd be the type then?
23:24:43 <glguy> These ambiguous types are because you omitted the forall, I think
23:24:56 <d34df00d> glguy: yes, and I wonder why exactly forall is needed in this case.
23:25:06 <glguy> ScopedTypeVariables extension
23:26:25 <d34df00d> I'm not sure that's enough of a hint for me :)
23:26:29 <glguy> The forall indicates you want the variables mentioned to use the extension
23:26:55 <d34df00d> Oh, otherwise that would be a "distinct" a?
23:27:10 <glguy> yeah, the a found inside the definition wouldn't be related to the one in the type signature
23:27:19 <d34df00d> So you don't need to forall proxy, right?
23:27:25 <d34df00d> ...I just checked, right.
23:27:29 <glguy> It's all or nothing
23:27:43 <glguy> The forall'd proxy is so I can use a lowercased proxy in the type
23:27:56 <glguy> rather than insisting that genericColumnTypes only work with Data.Proxy.Proxy
23:28:00 <d34df00d> But you still can use the uppercase one? Or, at least my ghci allows me to.
23:28:08 <d34df00d> Oh, makes sense.
