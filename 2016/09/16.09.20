00:18:02 * hackagebot binary-parsers 0.1.0.0 - Extends binary with parsec/attoparsec style parsing combinators.  https://hackage.haskell.org/package/binary-parsers-0.1.0.0 (winterland)
00:18:04 * hackagebot http-pony-transformer-case-insensitive 0.1.0.0 -   https://hackage.haskell.org/package/http-pony-transformer-case-insensitive-0.1.0.0 (JinjingWang)
00:54:45 <ph88_> uf johnw even more options ..
01:05:15 <elliptic00> can anyone elaborate on my thought? is functor similar  to homomorphism in Group Theory? e.g. (G1, +) (G2, *), x1, x2 in G1. y1, y2 in G2. then theta(x1 + y1) = theta(x2*y2). theta is homomorphism    
01:05:58 <elliptic00> or they are completely different concept?
01:07:03 <opqdonut> elliptic00: a functor is a category homomorphism, in some sense
01:07:27 <opqdonut> even wikipedia says "Functors can be thought of as homomorphisms between categories."
01:07:44 <opqdonut> it's a structure-preserving mapping
01:13:33 <Cale> elliptic00: not only that, but any group (or monoid) has a corresponding category, which just has a single object, and then the elements of the group are the arrows from that object to itself, and composition is group multiplication
01:14:41 <Cale> elliptic00: If you work out what a functor between two such categories is, it's exactly a group homomorphism
01:15:17 <Cale> (well, what it does to the arrows is, while there's no choice about what to do with the objects)
01:22:31 <johnjoe> I need a good haskell category theory project idea for my 4th year project.
01:27:54 <Velizar> How can I rewrite this without explicit recursion? https://gist.github.com/VelizarHristov/17e7569b58f5cdd7d777b476f04401e5
01:29:43 <Cale> Velizar: btw, that type signature is flipped around
01:30:13 <Velizar> oh yes, fixed
01:31:26 <Velizar> it's like (x >>= f) >>= f ... infinite times, but also all intermediate results are outputted
01:31:40 <Velizar> also, order doesn't matter for my use case
01:34:32 <thecoconut> can someone please explain me the use of myabe (the fold over Maybe). I don't really unserstand how it can be useful.
01:35:13 <Cale> thecoconut: It's useful in a lot of the cases where case would be useful
01:35:28 <Cale> If you happen to have some nice default value and function to apply
01:35:51 <Cale> and don't want to bother naming the variable in the Just case
01:36:18 <Cale> But often I find myself replacing clever uses of maybe with explicit case expressions later
01:37:04 <thecoconut> thank you
01:37:28 <Velizar> anyway, should I avoid all explicit recursion in favor of higher-order functions? I see explicit recursion as a sort of a code smell, don't know if that's justified.
01:37:49 <ongy> :t \fun root -> concat $ iterate (concatMap fun) (return root) -- Velizar. But I think your version is more readable
01:37:50 <lambdabot> (a -> [a]) -> a -> [a]
01:39:09 <Cale> Velizar: It sometimes is, but in this case, I don't see it as too terrible
01:40:38 <Velizar> how about in the case where my function is already quite long and complex even with explicit recursion? like some code I wrote for calculating min-cost _directed_ spanning tree.
01:41:17 <Cale> If your code is long and complicated, it might be worth trying to factor out whatever patterns you can see
01:42:00 <Cale> But if it was *just* getting rid of explicit recursion, then 'fix' would be the answer to all problems, when it isn't.
01:42:02 <Velizar> it's just that the algorithm is complicated even on paper
01:42:32 <Cale> The thing is just to try to understand what is being expressed better, and try to reflect that understanding in the code.
01:43:51 <Velizar> I'm pretty sure 'fix' is a worse programming convention than recursion :D
01:44:26 <Cale> Sometimes it's better than nothing
01:44:53 <Velizar> but I get it. Use whichever is clearer. 
01:45:04 <Cale> If the only usage site of your recursively defined thing is the point immediately after where it was defined
01:45:21 <Cale> then fix might be better -- it's a bit of a toss-up
02:03:14 <athan> Is there a heredoc for binary data? :D
02:04:19 <ongy> @pl \fun root -> concat $ iterate (concatMap fun) (return root) -- should I understand what lambdabot is doing here?
02:04:19 <lambdabot> (join .) . (. return) . iterate . (=<<)
02:04:27 <athan> er, theredoc
02:04:51 <athan> ongy: Not really honestly. I mean, you can try of course haha
02:05:15 <ongy> > join ["a", "bc", "def"]
02:05:17 <lambdabot>  "abcdef"
02:05:39 <athan> Why would you concat after iterate, ongy?
02:06:31 <ongy> athan: this was an answer to a question earlier, so I kept the type
02:06:42 <athan> ahh
02:17:58 <ongy> :t \xs -> [y | x <- xs, y <- x]
02:17:59 <lambdabot> [[t]] -> [t]
02:18:05 * hackagebot http-pony-transformer-http 0.1.0.0 -   https://hackage.haskell.org/package/http-pony-transformer-http-0.1.0.0 (JinjingWang)
02:18:07 * hackagebot http-pony 0.1.0.2 - A type unsafe http library  https://hackage.haskell.org/package/http-pony-0.1.0.2 (JinjingWang)
02:38:52 <ph88_> Does anyone know how these diff packages compare? https://paste.fedoraproject.org/431017/42967491/  i want to diff two data structures (of the same type)
02:44:41 <Reisen> I had a newtype: newtye Foo = Foo { unFoo :: Text }, which I would pattern match in my method definition:  somethingWithFoo (Foo val) = doSomethingWith val
02:45:10 <Reisen> I've introduced PatternSynonyms, and redone this as newtype Foo = Foo_, with a pattern Foo val <- Foo_ val
02:45:26 <Reisen> The problem is, this now gives me non-exhaustive warnings for somethingWithFoo saying I'm not matching on "somethingWithFoo _"
02:46:45 <liste> ph88_: those have very different use cases. gdiff is the generic one, the rest are pretty much for adapting diffs for other libraries and debugging
02:47:38 <Reisen> Is there something I can do to get rid of the warning that doesn't involve just having an undefined match for _?
02:48:37 <ph88_> liste, so pretty much only the generic one is usuable to me
02:48:48 <opqdonut> ccccccdltdluujeelkrjkedgurjrrbetvigtebdfthgu
02:48:55 <opqdonut> woops
02:49:23 <liste> ph88_: probably
02:49:37 <ph88_> ok thx liste 
02:50:08 <liste> ph88_: I'm using this https://hackage.haskell.org/package/Diff
02:51:11 <liste> ph88_: for calculating deltas a wiki engine
02:51:13 <liste> for a*
02:51:35 <ph88_> liste, i just have two data structures (of the same type) that need to be compared
02:51:42 <ph88_> do you recommend Diff over gdiff ?
02:52:18 <liste> ph88_: no, Diff is for lists of objects
02:52:25 <ph88_> oh ok
03:18:06 * hackagebot rl-satton 0.1.0 - Collection of Reinforcement Learning algorithms  https://hackage.haskell.org/package/rl-satton-0.1.0 (SergeyMironov)
03:25:59 <dmwit> Reisen: You could try filing a bug with the GHC folks. I bet they'd be sympathetic to that complaint.
03:26:21 <lyxia> https://ghc.haskell.org/trac/ghc/ticket/8779
03:29:51 <dmwit> nice!
03:30:10 <Guest59458> Hi, why can't I have type changing local?
03:30:45 <dmwit> What are you trying to do?
03:30:54 <dmwit> I don't understand the question (yet).
03:31:02 <Guest59458> like local :: (MonadReader m r, MonadReader m1 s) -> (r -> s) -> m1 s -> m r
03:31:30 <Guest59458> I guess that leaves m1 too uncontrained
03:31:33 <dmwit> yes
03:31:38 <Reisen> lyxia, thanks, that's perfect
03:31:46 <dmwit> Guest59458: There's mapReaderT, I think.
03:31:53 <dmwit> :t Control.Monad.Reader.mapReaderT
03:31:55 <lambdabot> forall k k1 (m :: k -> *) (a :: k) (n :: k1 -> *) (b :: k1) r. (m a -> n b) -> ReaderT r m a -> ReaderT r n b
03:32:23 <dmwit> no...
03:33:33 <Guest59458> That's the opposite thing... Leaves the environment the same
03:33:42 <dmwit> Hence my "no...". ;-)
03:34:14 <koz_> Could someone please explain to me the difference between 'ContT (ListT Identity)' and 'ListT (ContT Identity)'?
03:34:36 <lyxia> :t Control.Monad.Reader.withReader
03:34:38 <lambdabot> (r' -> r) -> Reader r a -> Reader r' a
03:35:23 <ilyanok> lyxia: cool, sounds almost like it. Wonder if there's a ReaderT version
03:35:30 <dmwit> of course
03:35:51 <lyxia> indeed there's withReaderT
03:36:51 <ilyanok> lyxia: thanks
03:38:53 <lyxia> koz_: Unrolling the definition, they become "(a -> [r]) -> [r]" and "([a] -> r) -> r"
03:39:31 <koz_> lyxia: ... Why didn't I think of doing that? Thank you - that explains it perfectly.
03:39:55 <lyxia> yw
03:40:04 <dmwit> ?unmtl Cont r a
03:40:05 <lambdabot> (a -> r) -> r
03:40:16 <dmwit> ?unmtl ListT Identity a
03:40:17 <lambdabot> [] a
03:40:20 <dmwit> oh my
03:40:27 <dmwit> ?unmtl ContT (ListT Identity) a
03:40:27 <lambdabot> Plugin `unmtl' failed with: `ContT (ListT Identity) a' is not applied to enough arguments, giving `/\A. (A -> a (ListT Identity)) -> a (ListT Identity)'
03:40:46 <dmwit> ?unmtl ContT r (ListT Identity) a
03:40:47 <lambdabot> (a -> [] r) -> [] r
03:40:56 <dmwit> ?unmtl ListT (ContT r Identity) a
03:40:56 <lambdabot> ([] a -> r) -> r
03:41:44 <koz_> dmwit: I didn't know about unmtl.
03:41:50 <dmwit> Except lambdabot's ListT is the crappy one that is only sometimes right. =/
03:42:09 <koz_> dmwit: What do you mean 'only sometimes right'? I thought that the big issue with ListT is that it's not lazy enough?
03:42:39 <dmwit> For lambdabot's definition of `ListT`, `ListT m` is only a monad if `m` is a commutative monad.
03:43:03 <dmwit> I would be kind of surprised if `Cont` were commutative.
03:43:15 <dmwit> (Though `Identity` certainly is.)
03:43:32 <koz_> dmwit: Sorry, what do you mean by a 'commutative monad'?
03:43:38 <dmwit> (commutative roughly means that `liftM2 (,) x y = liftM2 (flip (,)) y x`)
03:43:49 <dmwit> (in other words: it doesn't matter what order you execute the side effects in)
03:44:06 <koz_> Ah, right. Yeah, I could see how that'd be a problem with Cont.
03:45:12 <dmwit> https://wiki.haskell.org/ListT_done_right discusses this a little, I think
03:45:27 <koz_> dmwit: I think I read this stuff when I was looking at pipes.
03:46:52 <dmwit> Having played with the "good" ListT a bit now, I wonder whether anybody has written a comparison between ListT and the various iterator packages.
03:47:02 <dmwit> Or even between ListT and any one of the iterator packages. =P
03:47:10 <dmwit> iteratees, pipes, conduits, etc.
03:47:29 <jmcarthur> iteratees is the most different, of those, because it doesn't push you into a ListT-like monad
03:48:29 <koz_> I think it'll soon be the time when I have to use monad transformers For Realz.
03:48:48 <jmcarthur> That's the right time to use transformers
03:49:42 <dmwit> What does ListT do badly that motivates these other libraries?
03:49:48 <koz_> I also really wish I could get what the whole 'co-whatever' stuff is all about. Like, there seems to be 'co-' versions of everything, and I never quite get what they're all about.
03:50:32 <jmcarthur> ListT doesn't do anything badly. The other libraries just add more features to it.
03:51:10 <dmwit> ok
03:51:13 <jmcarthur> I think the most significant additional feature is that instead of Nil, these libraries give you the ability to tack on some "return" value.
03:51:35 <dmwit> That seems like a liability, not a feature.
03:51:46 <dmwit> What does `(<|>)` (or their equivalent) do with these return values?
03:51:51 <jmcarthur> It would be like if lists were defined as   data List r a = Nil r | Cons a (List r a)
03:52:36 <jmcarthur> Instead of (<|>), it's an alternative (>>=), and the return for that monad is Nil.
03:53:07 <jmcarthur> In fact, most of these libraries use this monad as the "default" monad most people are meant to use most of the time.
03:53:28 <dmwit> oh, interesting
03:54:32 <jmcarthur> This also makes the more standard list monad possible to define in a more general way (as an indexed monad), but most libraries don't bother because indexed monads aren't as well supported.
03:54:37 <dmwit> hum
03:54:45 <dmwit> That almost sounds like WriterT now.
03:54:54 <jmcarthur> Why?
03:55:41 <jmcarthur> Sorry, I made a mistake.
03:55:52 <jmcarthur> That generalization requires an additional feature beyond the return value.
03:56:32 <jmcarthur> One that not all of these libraries even support.
03:56:45 <dmwit> Well, `ListT r m a` uses monad `m` to compute a bunch of `a`s, then produces a value of type `r`. Bind passes the `r` along to the next action to use as input before deciding what to do.
03:56:53 <jmcarthur> Ah
03:56:56 <dmwit> That sounds a lot like what `WriterT [a] m r` does.
03:57:28 <jmcarthur> Well, there is some relationship, but a difference is that WriterT [a] doesn't allow you to consume the elements on demand.
03:57:30 <dmwit> (Though perhaps with a better story about laziness. I'm just trying to get some intuition at the moment.)
03:57:35 <dmwit> right
03:57:42 <jmcarthur> Not sure I'd call it laziness.
03:58:12 <jmcarthur> Nevermind, laziness is a fine way to describe it when we're not talking about a transformer.
03:58:28 <dmwit> Laziness in the sense of lazy IO, I guess. =P
03:58:32 <dmwit> Which I agree is not laziness.
03:58:37 <jmcarthur> With a transformer and effects and all that, you're getting some   m a  each time, so to get the a you have to bind on it.
03:59:06 <dmwit> ?unmtl WriterT [a] m r
03:59:06 <lambdabot> m (r, [a])
03:59:12 <dmwit> Yes, this is not a good type.
04:00:02 <dmwit> Thanks for the explanations. They were very clear.
04:00:09 <dmwit> jmcarthur++
04:00:18 <jmcarthur> Anyway, this type is to me the essense of what all these libraries offer. Various libraries offer additional features.
04:01:31 <jmcarthur> A common one is to make the tail of the list dependent on some input, like a state machine kind of thing.
04:01:49 <jmcarthur> data List r i a = Nil r | Cons a (i -> List r i a)
04:02:06 <jmcarthur> Err...
04:02:14 <jmcarthur> Sorry, that is a less common version of this.
04:02:47 <jmcarthur> The version I just wrote is something pipes has (in its Proxy type), which allows somebody who is consuming values to return other things to the pipe as they go.
04:03:17 <jmcarthur> A slightly different idea:   data List r i a = Nil r | Cons a (List r i a) | Await (i -> List r i a)
04:03:35 <jmcarthur> That type is able to interleave producing values and awaiting values in arbitrary order.
04:03:59 <jmcarthur> That's the more common way of acccepting streaming inputs.
04:07:04 <tsahyt> ?unmtl ReaderT r (WriterT w (StateT s)) a
04:07:04 <lambdabot> Plugin `unmtl' failed with: `StateT s (a, w)' is not applied to enough arguments.
04:07:11 <tsahyt> ?unmtl ReaderT r (WriterT w (StateT s Identity)) a
04:07:11 <lambdabot> r -> s -> (a, w, s)
04:07:27 <Forlorn> if I have `data Mood = Blah | Woot deriving Show` how can I create a function `toggleMode`? Page 111 of Haskell programming from first principles wants me to write this kind of function without having learnt me about guards.
04:07:35 <tsahyt> ?unmtl RWST r w s Identity a
04:07:35 <lambdabot> r -> s -> (a, s, w)
04:07:51 <Forlorn> or so it seems anyhow
04:08:04 <jmcarthur> Forlorn: toggleMode is supposed to be of type   toggleMode :: Mode -> Mode   ?
04:08:10 <tsahyt> ?unmtl ReaderT r (StateT s (WriterT w Identity)) a
04:08:10 <lambdabot> r -> s -> (a, s, w)
04:08:11 <Forlorn> jmcarthur, yeah
04:08:17 <tsahyt> ah, this way round
04:08:31 <pkmx> toggleMode Blah = Woot ; toggleMode Woot = Blah ?
04:08:34 <jmcarthur> Forlorn: If it's just supposed to invert the mode, you don't need guards for that. Just normal pattern matching.
04:08:57 <Forlorn> jmcarthur, what is normal pattern matching? It hasn't been stated in the book.
04:09:09 <dmwit> jmcarthur: Thanks, I was out for a second. Reading now.
04:10:34 <jmcarthur> Forlorn: According to http://haskellbook.com/progress.html it's covered in the section on Functions
04:10:54 <jmcarthur> Forlorn: Is that before or after where you are?
04:12:05 <Forlorn> jmcarthur, that's after where I am
04:12:15 <Forlorn> jmcarthur, I am at "Basic Datatypes"
04:12:48 <smorele> what do you think about the haskellbook ?
04:13:34 <Forlorn> It feels incomplete, but that's probably because it is, it needs a lot of revision. Like I couldn't hand this to my non-programmer friends and expect them to learn anything.
04:14:19 <jmcarthur> Forlorn: I found this on http://haskellbook.com/assets/img/sample.pdf . It looks like there is a short explanation of pattern matching with the question.
04:14:35 <jmcarthur> Forlorn: In that PDF I think it's on page 68
04:15:34 <jmcarthur> "We’re doing something here called pattern matching." etc etc
04:15:56 <Forlorn> Oh, on my book it is on page 111
04:16:14 <jmcarthur> Yeah the pdf is just a sample and probably also a different revision
04:16:30 <Forlorn> but my book doesn't have an explanation for pattern matching, perhaps I have to update my book
04:16:38 <jmcarthur> huh
04:18:08 * hackagebot rl-satton 0.1.1 - Collection of Reinforcement Learning algorithms  https://hackage.haskell.org/package/rl-satton-0.1.1 (SergeyMironov)
04:18:10 * hackagebot rl-satton 0.1.2 - Collection of Reinforcement Learning algorithms  https://hackage.haskell.org/package/rl-satton-0.1.2 (SergeyMironov)
04:18:12 * hackagebot rosmsg 0.5.2.0 - ROS message parser, render, TH  https://hackage.haskell.org/package/rosmsg-0.5.2.0 (akru)
04:19:13 <cloudhead> Forlorn: should be section 7.4
04:38:25 <Insanity_> hey Forlorn! 
04:38:38 <Forlorn> Hey
04:38:40 <Forlorn> :)
04:39:49 <athan> Hey everyone, I'm trying to run some IO code at compile time. Can someone show me where I'm wrong? http://lpaste.net/205340
04:40:32 <athan> Doesn't $() unquote?
04:41:51 <liste> athan: `s' isn't known at compile time
04:42:00 <jmcarthur> athan: I'm confused about what you are trying to do. At a glance, it looks like you are trying to use dynamically obtained data statically.
04:43:07 <athan> jmcarthur: That's exactly what I'm trying to do
04:43:10 <athan> hmm
04:44:01 <jmcarthur> What is it you were hoping would happen?
04:44:28 <athan> I'm hoping it would "pack" my binary data in my executable :\
04:44:32 <athan> like a heredoc for bytestrings
04:44:54 <athan> but it looks like `runQ` would just turn it back into IO v_v
04:45:13 <cocreature> athan: it seems like you are implementing https://hackage.haskell.org/package/file-embed-0.0.10/docs/Data-FileEmbed.html
04:45:21 <athan> !!
04:45:40 <athan> incredibe :) thank you cocreature 
04:45:42 <cocreature> np
04:47:21 <cocreature> the source is pretty simple if you want to look at it
04:49:30 <athan> shoot, there's no way around it is there, liste
04:57:59 <liste> athan: you could do that for a statically known list of values and then pick from them
04:58:59 <athan> liste: Dang, good idea!
04:59:43 <liste> athan: but yeah, there exists multiple ways to embed files in executables
05:00:01 <liste> athan: Cabal has one (Paths_<xxx>) and there's that FileEmbed
05:00:37 <athan> man... I feel like I never stop learning in this language
05:00:47 <cocreature> that’s a good thing :)
05:00:48 <liste> though I'm not sure if Paths_ really embeds the files or just copies them...
05:02:14 <aukeroorda> Hello. I've been looking for a haskell GUI library, and things don't look so good so far. I am trying to create a small background application, and to have a print-screen like button, but instead record your speaker sound OUTPUT. I am quite new to Haskell, so if you think this is a no-no, then please say so. I have created a small design for it in 
05:02:14 <aukeroorda> illustrator: http://prntscr.com/ck6sy4 Can someone recommend a library for interfaces for Haskell?
05:02:36 <aukeroorda> Btw, ignore the chromo logo, heh
05:05:32 <athan> cocreature, liste: Works like a charm :) statically linked web servers ftw!
05:05:50 <athan> (then using electron or just webkit as the frontend)
05:05:59 <athan> extreme app development to the max >:O
05:06:31 <aukeroorda> How do you guys feel about wxHaskell?
05:09:50 <michi7x7> aukeroorda: this looks like something I probably wouldn't do in Haskell. C++ and Qt has way better and consistent support for audio interfacing and GUI. Why'd you choose Haskell?
05:10:35 <incog> freenode is spying on you: Head over to #antispammeta @ freenode & type ;investigate & your usual nick to see a snitchbot spam your info
05:10:52 <aukeroorda> Hmm, because I want to learn about Haskell and functional programming. I have been programming OO for some time, and recently followed a course on Functional programming, and want to get some experience
05:11:11 <aukeroorda> I have found this audio recording/playback: https://github.com/peterhil/hs-openal-proto/tree/master/src/Sound/OpenAL/Proto
05:12:07 <aukeroorda> michi7x7: Or do you strongly advice against trying to use functional programming here?
05:13:27 <liste> aukeroorda: I think wxhaskell+reactive-banana are pretty awesome together
05:15:05 <liste> aukeroorda: I think functional programming (especially FRP) suit well for GUI
05:15:25 <athan> Has anyone here made a completely statically linked executable before?
05:16:44 <athan> I just checked out Cheplyaka's blog post on it, and applied the ghc options, but I'm getting some daughting warnings - in that the glibc shared lib version will need to be available at runtime
05:17:03 <liste> athan: including statically linked glibc?
05:17:11 <liste> athan: I don't think that's a good idea
05:17:15 <ongy> athan: there's also an issue on most setups that you will not have the dependencies installed for static linking
05:17:30 <Clint> athan: glibc isn't great for static linking, especially with regard to nss
05:17:34 <athan> ongy: That's what I'm trying to avoid :\
05:17:47 <athan> Clint, liste: yeah it's my first rodeo ._.
05:17:50 <liste> athan: do you have native dependencies?'
05:18:00 <athan> native? I'm not sure
05:18:04 <ongy> athan: I mean on the system you link on. You will run into libraries where you have the .so but not the .a and it's a hassle
05:18:16 <athan> I'm just trying to link against libsodium, without needing it on every machine I distribute to
05:18:34 <athan> hmm, I'm not sure ongy
05:18:42 <liste> athan: libsodium would be a native dependency
05:18:59 <athan> ahh I see, then yes :)
05:19:59 <liste> athan: can you link the blog post?
05:20:39 <athan> liste: https://ro-che.info/articles/2015-10-26-static-linking-ghc
05:20:44 <oggy> i'm getting linker errors (about undefined symbols) when trying to compile my project; i'm not using any non-Haskell libraries. is this likely a ghc bug?
05:22:08 <liste> athan: you can either use some statically linkable C library, like musl (hard) or keep the glibc version at sync for each platform you install on (harder)
05:22:57 <ongy> athan: you don't have to build all of it as static to do that. (I'll asume linux here) you should be able to add the libsodium.a (as object file for link step) instead of adding it to library dependencies. At least that's how it works when linking something statically into C projects 
05:23:03 <athan> liste: Heh, thanks :)
05:23:35 <athan> ongy: Yeah that makes sense, I'm just a noob
05:50:32 <athan> Hah! til `data Foo` == `newtype Foo = Foo (Ptr Foo)` S_S
05:51:12 <merijn> huh
05:52:08 <athan> merijn: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html#id655194
05:52:12 <athan> in virtue at least
05:54:36 <merijn> athan: It's not the same, it just serves the same function
05:54:46 <merijn> Note that you don't need an extension for EmptyDataDecls
05:55:17 <merijn> Since they're included in Haskell2010
05:55:54 <jophish> Am I correct in thinking that GHC8 shouldn't flag invalid "missing pattern" warnings when using pattern synonyms any more
05:57:21 <merijn> jophish: You mean it should, or should not warn for missing patterns? AFAIK it should
05:59:24 <jophish> merijn: I'm getting a warning when all the cases are covered, one of the cases is a pattern synonym.
05:59:29 <jophish> I'm making a minimal testcase now
06:04:01 <jophish> merijn: https://gist.github.com/expipiplus1/bfb25352c1217b734f3e591b77eb365c
06:04:19 <jophish> I was under the impression that this kind of thing was handled a little better in GHC 8
06:04:56 <merijn> jophish: So was I
06:05:03 <merijn> jophish: I'd check the bug tracker and file a bug?
06:07:00 <jophish> This is somewhat related https://ghc.haskell.org/trac/ghc/ticket/8779
06:09:30 <jophish> Seems like it was bikeshedded out of 8.0.1
06:12:21 <jophish> Interestingly synonyms aren't mentioned on this page https://ghc.haskell.org/trac/ghc/wiki/PatternMatchCheck
06:14:45 <jophish> merijn: I think I might have seem that in a dream, I can't find anything announcing better exhaustiveness checking in the context of pattern synonyms announced for ghc 8
06:17:16 <merijn> jophish: I know GHC 8 has (is supposed to have?) better exhaustiveness checking for GADTs
06:17:33 <merijn> jophish: I was under the impression this included the ability to peer through pattern synonyms, but I'm not sure
06:17:40 <merijn> Gotta run for a bit
06:17:45 <jophish> yeah, there's a big page on that, but no mention of synonyms
06:17:49 <jophish> I think we imagined this, merijn 
06:17:55 <jophish> :)
06:21:02 <johnjoe> Anybody have any good Haskell category theory project ideas?
06:21:47 <lyxia> do something about the fact that Hask is not a category
06:23:06 <byorgey> johnjoe: what kind of project?  how much category theory do you know?
06:23:41 <ilyanok> Hi, I'm defining the type class with the following method mymap :: (forall s. a s -> b s) -> f a s -> f b s
06:23:59 <ilyanok> is there an existing name (library) for this?
06:24:02 <johnjoe> Its for my fourth year project on college; so preferably some that i can "demonstrate"; I have completed learnyouahaskell
06:25:08 <ilyanok> (f is a simple Functor in s if that matters)
06:26:05 <soLucien> i'm trying to install stylish-haskell on windows, and i can't build it because of this
06:26:08 <soLucien> how can i fix it ?
06:26:09 <soLucien> http://pasteboard.co/5nfuCyHEW.png
06:26:48 <soLucien> basically as far as i can see, it attempts to create a nre directory every time
06:27:05 <soLucien> stack*some-random-number*
06:30:03 <ilyanok> It looks like the first argument to f should be a Functor itself, so instead of passing a function I do pass a natural transformation, right?
06:30:44 <ilyanok> So f is kinda high-order Functor? Is there even such thing?
06:32:32 <ilyanok> Ok, it looks like HFunctor from category-extras is the name...
06:32:48 <byorgey> ilyanok: yes, f is a higher-order functor.  I have seen an HFunctor class defined several times.
06:33:07 <byorgey> it is in category-extras but that package is deprecated.  I am not sure if it ended up in a different package.
06:35:00 <lyxia> hoogle finds one in compdata, which has been updated recently enough
06:36:05 <byorgey> yeah, you beat me to it =)
06:36:14 <ilyanok> byorgey: lyxia: thanks, I'll take a look
06:38:05 <byorgey> although the one in compdata only has an hfmap, it is missing ffmap
06:38:37 <byorgey> a higher-order functor should map functors to functors as well as natural transformations to natural transformations
06:39:02 <ertesx> ilyanok: what about <https://hackage.haskell.org/package/hask-0/docs/Hask-Category.html#g:2>?
06:39:50 <byorgey> ertesx: ?  that is not the same at all
06:40:03 <jchia_> conduit question: I'm reading from a ByteString input _one_ item of type A that has a Get instance, and then many items of type B that also has a Get instance. I'm using Data.Conduit.Cereal.conduitGet2 to read the A value. How to I prevent it from taking in too many bytes and affecting what I read for B?
06:40:18 <ertesx> byorgey: isn't it?  it looks like a more general class
06:41:13 <ertesx> type Dom f a b = forall s. a s -> b s
06:41:28 <carado> hi ! I’m probably missing something simple, but let’s say I have a data D a = D (a Int) (a Char), how can I use deriving for Show on D such that it uses a’s instance of Show it has one and doesn’t derive if not ?
06:41:58 <ertesx> type Cod f a b = forall s. f a s -> f b s
06:43:39 <ertesx> carado: that's basically what you get anyway
06:43:59 <ertesx> carado: instance (Show (a Int), Show (a Char)) => Show (D a)
06:45:44 <jchia_> http://lpaste.net/205493 How do I prevent the reading of Context by conduitGet2 from taking too many bytes? I find that it's taking extra bytes so that the ssSink starts reading the Snapshots later than it should.
06:47:54 <carado> thanks !
06:53:01 * ski . o O ( `instance (forall a. Show a => Show (f a)) => Show (D f)' )
07:06:35 <soLucien> how does one get monads ?
07:07:04 <merijn> soLucien: Study type (signatures), study typeclasses, study monad laws, realise there just isn't that much to "get" :)
07:07:08 <merijn> Also
07:07:17 <merijn> @google you could have invented monads sigfpe
07:07:20 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
07:07:20 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
07:07:23 <merijn> That one
07:07:27 <carado> I hear http://dev.stephendiehl.com/hask/#monads is good advice
07:07:50 <merijn> soLucien: Incidentally, the original monad paper by Wadler is pretty accessible, no clue why every prefers shitty blogposts over the paper :)
07:07:53 <tdammers> particularly http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
07:08:02 <merijn> http://roman-dushkin.narod.ru/files/fp__philip_wadler_001.pdf
07:08:14 <soLucien> my teacher advised me to do so by reading https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/wadler-essence-fp.pdf
07:08:31 <soLucien> but i find it hard
07:09:13 <merijn> soLucien: Try my link, at first glance it looks simpler
07:09:37 <soLucien> because the guy simply states how he got there, and how it works and not the underlying concepts of how the "light bulb" lit up for him
07:09:41 <jophish> is it a bug in GHC if "foo :: C a => x; foo = ..." compiles but "type Constraints a = C a; foo :: Constraints a => x; foo = ..." dosn't compile?
07:09:53 <tdammers> soLucien: the alleged light bulb doesn't exist
07:09:56 <merijn> soLucien: That's because the light-bulb paper by Wadler is the one I linked ;)
07:10:10 <merijn> jophish: No
07:10:16 <tdammers> soLucien: if anything, it's "so there really isn't anything more to monads than bind, return, fail, and the laws"
07:10:17 <merijn> jophish: That requires -XConstraintKinds
07:10:26 <jophish> merijn: yeah, I'm using that :D
07:10:32 <jophish> I think this is a little more interesting
07:10:33 <tdammers> the magical thing is that there is no magic
07:11:32 <jophish> merijn: I *think* that this is because 'a' isn't free in x
07:12:00 <jophish> however it is constrained enough in C to not be ambigious
07:12:02 <merijn> jophish: Naah, that should be fine
07:12:08 <soLucien> my homework after 2 weeks and a half of Hakell is write an interpreter + a parser for Javascript that supports list comprehensions
07:12:47 <jophish> merijn: ah, this compiles fine in GHC 7.10
07:13:55 <merijn> jophish: hmmm, I wonder why that wouldn't work for GHC8
07:14:19 <jophish> annoyingly this example is quite complex
07:16:15 <carado> Parsec is nice for parsing, but for most cases ReadP works fine, and it’s simpler.
07:16:31 <merijn> carado: It's also horrifically slow compared to Parsec :)
07:17:10 <c_wraith> ReadP is also bizarrely more general than its practical use.
07:17:18 <carado> welp, I know why people use parsec now.
07:17:44 <c_wraith> ReadP supports ambiguous parses, but I don't know of any use of it that does.
07:18:02 <merijn> carado: Which is also why "read" is an awful function to use for parsing data :)
07:18:12 * hackagebot transient-universe 0.3.5 - Remote execution and map-reduce: distributed computing for Transient  https://hackage.haskell.org/package/transient-universe-0.3.5 (geraldus)
07:18:14 <tdammers> ReadP is simpler in a bad way
07:18:47 <carado> well, I use read when I expect correct strings and readsPrec when I want to handle failures
07:19:13 <merijn> carado: FYI, GHC nowadays has "readMaybe" in Text.Read :)
07:19:27 <merijn> carado: But I was more referring to being awful because of it's speed (or lack thereof)
07:19:40 <carado> performance is rarely a concern of mine when I’m doing parsing
07:20:05 <merijn> carado: Sure, but it helps to know for that one time you *do* need speed :)
07:20:15 <carado> oh cool, readMaybe wasn’t in base last time I checked.
07:20:25 <merijn> carado: It's been there since 7.8 or 7.8, I think :)
07:22:09 <_NickHu> Hi, I have super patchy internet; I'm trying to get stack to download ghc 8.0.1 but it hangs intermittently because the connection dies
07:22:24 <_NickHu> Then I have to do stack setup again and it downloads ghc from the beginning
07:22:36 <c_wraith> I'd file that as a stack bug.
07:22:39 <_NickHu> Is it possible for me to download a ghc tarball from my browser and point stack setup to that instead?
07:22:50 <c_wraith> Probably.
07:24:22 <_NickHu> Which would be the correct file to download from here? https://www.haskell.org/ghc/download_ghc_8_0_1#linux_x86_64
07:24:32 <c_wraith> I'd check the stack-specific channel.  Not that I can remember its name..
07:37:55 <ertesx> Monoid and Monad have one particularly interesting thing in common: the way you learn them
07:39:03 <ertesx> Monoid:  look at two examples, understand the composition pattern, look at more examples, learn to abstract over monoids (e.g. mconcat)…  now You Understand Monoid
07:39:39 <grantwu> Hrm... not necessarily
07:39:40 <ertesx> Monad:  look at two examples, understand the composition pattern, look at more examples, learn to abstract over monads (e.g. mapM)…  now You Understand Monads (even if you don't think you do)
07:40:09 <grantwu> Monoids were obvious for me.  Monads took me a while.
07:41:11 <danza> ertesx, what do you mean by "understand the composition pattern" for monads?
07:41:34 <ertesx> danza: understand (>>=) and return in terms of types and laws
07:42:17 * ski . o O ( quotient monads )
07:43:04 <danza> :t (>>=)
07:43:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:45:13 <danza> i thought i had an understanding of monads, until i had to work with monad transformers. That got mind bending. Unfortunately they seem to be very useful for interactive client-side code developed with GHCJS
07:46:09 <ertesx> danza: you understanding monoids doesn't automatically mean that you understand monoid morphisms, and it's the same thing with monads and monad transformers (the monad equivalent to monoid morphisms)
07:46:26 <ertesx> danza: so if you learn monad transformers, you are actually learning a new concept that is not part of Monad
07:46:54 <danza> ertesx, thanks that's motivating :)
07:47:20 <ertesx> my pleasure =)
07:52:02 <argyris> hi everyone, is there any way to make getPairs' in this example (http://lpaste.net/205568) work? I'm trying to have an expression as a pattern based on an binding from a previous pattern match
08:01:20 <EvanR> ertesx: wait... transformers are monad morphisms?
08:01:32 <mizu_no_oto_work> argyris: n+k patterns were removed from Haskell 2010
08:01:54 <mizu_no_oto_work> Though I'm not sure that an n+k pattern would have worked in that context, anyways
08:04:37 <ertesx> EvanR: MonadTrans instances are special monad morphisms, yeah
08:05:09 <ertesx> they map monads:  (* -> *) -> (* -> *)
08:05:34 <ertesx> structure-preservingly:  lift (c >>= f) = lift c >>= lift . f;  lift . return = return
08:06:37 <tsahyt> is there some kind of filter function for Maybe?
08:06:58 <Clint> tsahyt: yes
08:07:12 <ertesx> tsahyt: a few
08:07:15 <ertesx> :t mfilter
08:07:17 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
08:07:19 <ertesx> :t guard
08:07:20 <lambdabot> Alternative f => Bool -> f ()
08:07:26 <tsahyt> mfilter seems to fit
08:07:29 <tsahyt> thanks!
08:07:37 <ertesx> :t filterM
08:07:39 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
08:07:44 <ertesx> huh?
08:07:52 <tsahyt> btw, ertesx I'm currently playing around with wires and trying to use SDL for input and output
08:07:56 <ertesx> oh, ignore filterM
08:08:07 <ertesx> tsahyt: great =)
08:08:11 <tsahyt> I thought I'd do a small asteroids clone, maybe even sans asteroids for the time being
08:08:25 <tsahyt> I got the ship physics down on the CLI, now I'm trying to wire it all up with SDL
08:11:42 <ertesx> tsahyt: if you run into any problems, find bugs or have suggestions, hit me…  also consider joining #haskell-game =)
08:12:10 <tsahyt> so far it's mostly smooth sailing, except for my obvious lack of experience with FRP, arrows, and SDL
08:13:01 <nitrix> tsahyt: I can help with the sdl2 part. Again, #haskell-game.
08:13:51 <tsahyt> thanks! If I run into problems I'll ask there. It doesn't look too complicated so far, and I've done some toy projects with SDL in C a few years ago
08:14:00 <tsahyt> so I've got a rough idea of how things could work
08:14:21 <Zemyla> How much of Haskell is written in C?
08:14:55 <ertesx> Zemyla: the RTS and a parts of a few haskell libraries (notably: crypto algorithms) are written in C
08:15:06 <nitrix> Zemyla: The RTS is about 50k lines of C.
08:15:07 <tsahyt> GHC has some platform specific parts that are written in C
08:15:18 <tsahyt> and an MD5 implementation that might just as well be written in Haskell
08:15:41 <prsteele> Zemyla: http://www.aosabook.org/en/ghc.html has some counts for the compiler
08:15:49 <Zemyla> Because I am half-wondering if it could be made to not depend on the standard C library. :V
08:15:56 <Zemyla> At least for Windows.
08:16:27 <ertesx> tsahyt: not quite…  it's easier in haskell to introduce side channel vulnerabilities
08:16:50 <tsahyt> ertesx: I'd agree if MD5 was usable for crypto or even used for crypto in this particular case
08:16:55 <prsteele> ertesx: do you mean e.g. timing attacks?
08:16:55 <tsahyt> it's just used in GHC.Fingerprint
08:17:44 <ertesx> tsahyt: for MD5 there are still a few valid crypto use cases, for example as the underlying hash function of a key derivation function like PBKDF2
08:17:54 <Zemyla> Like, openFile using the Windows file opening implementation instead of going through open() and such.
08:17:55 <Eliel> What's the reason RTS is written in C? Performance?
08:18:00 <ertesx> tsahyt: it shouldn't be used, but it is used, and it's curretnly secure
08:18:07 <ertesx> prsteele: yeah
08:18:13 * hackagebot wavefront 0.7.0.2 - Wavefront OBJ loader  https://hackage.haskell.org/package/wavefront-0.7.0.2 (DimitriSabadie)
08:18:20 <Zemyla> ertesx: If you're using MD5 for crypto, you're going to use one that comes in an actual crypto library.
08:18:38 <tsahyt> fair enough, but I think in the case of GHC.Fingerprint (which is really just used for Typeable), side channel attacks are irrelevant
08:18:46 <ertesx> Zemyla: sure, i'm just clarifying *why* you do that =)
08:19:40 <Zemyla> Actually, shouldn't you write it in assembly language to keep compiler optimizations and transformations from introducing side channel attacks?
08:19:56 <ertesx> tsahyt: in that particular case it may actually pay off to use a collision-resistant hash function, otherwise you might be tricked into using the wrong function in a StaticPtr setting =)
08:20:09 <tsahyt> nitrix: is there any nice way to extract key data from an Event in sdl2? The structure is quite deeply nested.
08:20:24 <tsahyt> pattern matching gets a bit tedious here
08:21:26 <Zemyla> tsahyt: ViewPatterns?
08:21:47 <ertesx> tsahyt: one layer you can ignore most of the time, just use 'eventPayload', then pattern-match using catMapE for the appropriate event type (e.g. KeyboardEvent)
08:21:58 <tsahyt> ertesx: md5 is adequate here imo. It's good enough, it's not like collisions occur with any reasonable probability by accident. You can construct them, but I don't think it's relevant in this setting.
08:22:12 <tsahyt> :t catMapE
08:22:14 <lambdabot> error: Variable not in scope: catMapE
08:22:21 <ertesx> tsahyt: catMapE is part of wires
08:22:33 <ertesx> (a -> Maybe b) -> Event a -> Event b
08:22:50 <nitrix> tsahyt: https://github.com/nitrix/lspace/blob/master/src/Engine.hs#L27
08:22:56 <nitrix> tsahyt: Haven't found a nicer way yet.
08:23:54 <tsahyt> ok, that's basically what I was about to do
08:24:00 <tsahyt> just written up nicer
08:24:17 <tsahyt> I was half expecting the answer to be lens
08:24:58 <ertesx> tsahyt: if you never actually use the event timestamp, just construct an (Event EventPayload) in the first place and import SDL hiding (Event)…  that way you also avoid the name clash between wires and sdl2
08:25:16 <nitrix> tsahyt: As far as I know, sdl2 doesn't define any lenses.
08:25:35 <ertesx> a lens can't do it…  it would have to be a traversal/prism
08:25:43 <prsteele> how do I play around with running type families in GHCi? E.g. if I've defined type family F (x :: SomeKind) where ...; how do I see the result of F x ?
08:25:47 <tsahyt> nitrix: it doesn't but it does have Generic instances everywhere. I don't know much about lenses but I thought you might be able to create orphan instances using Generic
08:26:30 <nitrix> You could write some, but at that point, it boils down to the same amount of work, even maybe noisier, than just writing down specific handler functions.
08:27:05 <ertesx> you don't save much, because you need to match on a few things, too, like modifiers
08:27:15 <nitrix> Plus, the handler functions turned out helpful in my case. As you can see, sometimes you need additional logic to intercept keycode when you have UIs opened, or modifier keys, etc.
08:27:26 <nitrix> Yup.
08:28:35 <ertesx> note that catMapE is very cheap (free if you don't actually use the constructed event), so really just construct all events you need and then forget about how you constructed them
08:29:14 <lambdafan> how can I see the code produced from DeriveFunctor?
08:32:20 <geekosaur> -ddump-deriv?
08:32:48 <lambdafan> there's some stack incantation I am missing
08:33:09 <dfeuer> geekosaur, do you happen to know if DeriveFunctor tries to be smart about <$, or whether DeriveFoldable tries to be smart about foldl' and foldr'?
08:33:14 <lambdafan> I put --ddump-deriv in .cabal, but running 'stack build' doesn't produce anything
08:33:31 <geekosaur> it's writing it to a file somewhere in its build area
08:33:35 <{AS}> Is there something like ML's local ... in ... end in Haskell?
08:33:38 <geekosaur> under .stack-work
08:33:50 <dfeuer> lambdafan, you have to dig into the .stack-work thingum in some weird place. It's kind of bizarre where these end up.
08:34:19 <lambdafan> dfeuer: any idea of the file name it might be producing, I can grep for that
08:34:51 <dfeuer> lambdafan, I *think*  it has the word dump in it, but I'm not sure.
08:35:49 <nitrix> lambdafan: .stack-work, e.g. .stack-work/dist/x86_64-linux/Cabal-1.22.5.0/build/foo/foo-tmp/Main.dump-deriv
08:38:46 <lambdafan> nitrix: Found It thanks :)
08:43:32 <lyxia> {AS}: what does that do
08:43:55 <{AS}> lyxia: local is like let but on definition level
08:44:06 <EvanR> haskell doesnt have modules
08:44:07 <{AS}> so you have local <<definitions>> in <<definitions>> end
08:45:03 <nitrix> let x = 42 in (let y = x in y)
08:45:24 <EvanR> too many parens ;)
08:45:31 <nitrix> Trying to make it readable.
08:45:55 <EvanR> > sort "let x = 42 in (let y = x in y)"
08:45:57 <lambdabot>  "          ()24==eeiillnnttxxyy"
08:47:59 <lyxia> {AS}: aren't local definitions just those that aren't exported?
08:48:14 <{AS}> lyxia: well you can have multiple local blocks
08:48:29 <{AS}> so you can name things similarly in two diffrent local blocks
08:48:33 <nitrix> What's the ultimate goal?
08:49:14 <EvanR> in ML theres additional nice functionality that comes with that
08:49:28 <{AS}> nitrix: to define common functionality in separate functions
08:49:32 <{AS}> You can use where-blocks
08:49:37 <{AS}> but they only work for one particular clause
08:49:50 <EvanR> like being able to locally use a module in some scope and close it again, also modules can be parameterized by arguments
08:53:16 <{AS}> I mean I can perfectly fine do it by renaming everything differently :)
08:53:38 <{AS}> but sometimes it's nice to be able to reuse names where appropiate
08:53:38 <EvanR> in haskell you have to use another module, in another file
08:53:47 <{AS}> Yeah, which is a bit annoying
08:54:15 <EvanR> otoh it does keep each file pretty simple
08:54:40 <{AS}> Well, I can perfectly fine decide my own file structure :)
08:55:11 <{AS}> but now I am just ranting
08:55:21 <{AS}> Anyway, it seems there is no similar thing
08:55:25 <{AS}> Thanks for answers! :)
08:55:29 <nitrix> It's not as bad as you might think.
08:55:32 <EvanR> module systems are one of those things no one really is interested in figuring out
08:55:51 <nitrix> Parameterized modules is probably the most annoying.
08:56:35 <EvanR> the way it is is probably how miranda did it
08:56:51 <EvanR> not the most interesting area to innovate ;)
09:05:24 <carado> hi again, is what I’m trying to do doable ? http://paste.awesom.eu/9Imn
09:08:05 <Cale> carado: If you have Traversable t, then t :: * -> *
09:08:39 <Cale> If you have C a, it's clear that also a :: * -> *, because of the way that a is used by the type class method f
09:08:46 <Cale> So t a doesn't make sense.
09:08:53 <Cale> (it doesn't kind-check)
09:09:26 <Cale> Moreover, there's an additional issue in the fact that you're trying to write an instance of C for something which involves no type constructors.
09:11:38 <Cale> You should generally try to ensure that every instance of a type class matches at least one type constructor in the instance head, because an instance of this shape (provided you did something which kind-checked) would match any type application whatsoever, indepdendently of whether the constraints on it held
09:11:55 <Cale> The constraints on an instance are only considered at all *after* committing to the instance.
09:13:30 <Cale> The design is arranged so that instances in new future modules don't change the way we would expect already compiled code to behave.
09:14:45 <Cale> You can never rely on the fact that some other instance isn't present as a reason to not select some given instance, because it might be added later, which would result in general confusion with regard to what ought to have been selected.
09:15:13 <Cale> (but you can fail altogether when you don't find an instance that you need)
09:18:15 * hackagebot ghcjs-hplay 0.3.4.2 - Client-side web EDSL for transient nodes running in the web browser  https://hackage.haskell.org/package/ghcjs-hplay-0.3.4.2 (geraldus)
09:21:26 <nitrix> ertesx: foo :: Wire m a b,  foo -< () :: Wire m () b  ?
09:24:36 <nitrix> I can't find -< anywhere.
09:24:52 <EvanR> :t (-<)
09:24:53 <lambdabot> error:
09:24:53 <lambdabot>     • Variable not in scope: -<
09:24:53 <lambdabot>     • Perhaps you meant one of these:
09:25:01 <EvanR> Control.Arrow?
09:25:08 <carado> I think I sorta-understand, this typeclass has to apply to a type constructor, a * -> *. but then, is it impossible to do what I’m trying to achieve ?
09:26:02 <geekosaur> nitrix, it's Arrow syntax
09:26:07 <geekosaur> not an operator
09:26:38 <nitrix> geekosaur: Can it at least be given a type?
09:26:46 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation
09:26:51 <geekosaur> no more than <- in do can
09:26:58 <nitrix> geekosaur: <- can be explained as >>=
09:27:04 <ertesx> nitrix: i highly recommend reading this: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation
09:27:22 <geekosaur> well, that one sort of can, I guess, but I'm under the impression Arrow syntax can't be turned into library functions
09:27:31 <ertesx> nitrix: "-<" doesn't have a nice, simple translation for arrows, and in fact neither does "<-"
09:27:36 <carado> nitrix, not really, it’s expanded as >>= and \ ->, and \ -> isn’t an operator either
09:27:44 <geekosaur> ^
09:29:09 <nitrix> Reading the 56 pages paper.
09:29:12 <joe9> need some advice on how to debug this, please? There is a bug in a package that I corrected locally. Using stack, when I run a project with a minimal example, the project runs fine. But, in a bigger project, I change the stack.yaml to use the local package too. But, for some reason, it is using the old version of the package.
09:29:13 <nitrix> Thanks I suppose.
09:29:32 <ertesx> nitrix: i hate to say this, but try not too hard to guess what it desugars into (it's a mess)…  just know that there is a desugaring, and that you could write it by hand using combinators if necessary
09:35:22 <sm> joe9: stack exec -- ghc-pkg list to see what package versions are being used
09:37:56 <dabd> how would you implement a library for specifying and running DAG-structured computations such as https://github.com/plumatic/plumbing.  Would you use Arrows or Free Monads?
09:44:29 <ertesx> dabd: that's an "apples or bananas?" question…  but in general: don't use arrows, unless you're forced to use them
09:45:19 <dabd> ertesx, for this specific problem what would you use?
09:45:28 <Cale> dabd: What's the specific problem?
09:45:58 <dabd> Cale, a library for declaring and running DAG-structured computations such as https://github.com/plumatic/plumbing
09:46:10 <Cale> "Do graph structured computation" sounds like it isn't really a one-size-fits-all kind of thing...
09:46:40 <ertesx> dabd: i don't understand the problem well enough to answer that…  free monads, when given a monad, expose the compositional structure of that monad, so if that sounds like something you need, you can probably use them
09:47:04 <ertesx> (Free IO) is like IO, but you can examine each (>>=)
09:47:21 <Cale> But yeah, Arrow (or something similar to it) is useful if the goal is to expose the binding structure between computations.
09:47:52 <dabd> I want something that will allow me to specify a dependency graph of functions, find some execution strategy and run them.
09:47:59 <ertesx> dabd: Applicative also allows that kind of exposition, but it's less powerful than Monad
09:48:21 <ertesx> dabd: you could take some inspiration from 'shake'
09:48:25 <ertesx> @package shake
09:48:25 <lambdabot> http://hackage.haskell.org/package/shake
09:48:45 <dabd> ekmett made an interesting comment here regarding Applicatives and Arrows https://www.reddit.com/r/haskell/comments/4fkkzo/when_does_one_consider_using_arrows/d2be2zw
09:48:47 <Cale> ertesx: Less powerful, but easier to do analysis on
09:49:25 <Cale> dabd: Ed's comment there is certainly true for most libraries...
09:49:58 <ertesx> dabd: the difference between arrows and free monads in that regard is that even with Free the exposition is dynamic
09:50:16 <ertesx> you can only look at the compositional structure *as you execute the action*
09:50:32 <Cale> There are things which Arrow exposes about the way that the computation is built up which I don't believe you can get from Applicative. But few people want to head down the road of manipulating typed heterogeneous graphs to simplify their computations before running them.
09:50:34 <ertesx> the future of the action is still a black box, until you reach it
09:50:46 <ertesx> so Free probably isn't suitable for dependency graph building
09:51:21 <Cale> and usually the structure exposed by Applicative is enough to do the kinds of simplification people usually want to do
09:52:27 <ertesx> Applicative + Category is also worth mentioning
09:52:35 <ertesx> it's very similar to Arrow
09:53:22 <Cale> It really depends pretty finely on what you're actually writing, and what combinations of your primitives you want to be able to look for. You could also just physically build graph representations using something like Data.Map to represent adjacency directly.
09:54:10 <ertesx> well, if you have an Arrow, chances are you also have an Applicative (i haven't found a counterexample)…  you can just implement both interfaces
09:55:51 <Cale> ertesx: In one of our older AFRP systems, I ended up building Applicative-style UI widget combinator library.
09:56:35 <nshepperd__> Arrow notation is sort of like the ApplicativeDo we wish we had, imo
09:57:01 <ertesx> Cale: i did something similar in my AFRP web framework research with forms
09:57:37 <ertesx> nshepperd_: we do have -XApplicativeDo since GHC 8
10:02:59 <nshepperd__> Well, what i mean is that when you're writing arrow code usually all you're doing is just applicative stuff
10:03:09 <alexkosh> hey, comming back with my problem. I use stack in NixOs. I use gnuplot binding. when I run my program in ghci, it producec a graph, when I compile and run, it does not. cabal file - http://paste.ofcode.org/mX4Q58eZHwn3DcTFYNTeFD and stack file http://paste.ofcode.org/39p4fA2Awwb3V2Kh36cuLYy . moreover, easyplot works...
10:04:07 <nshepperd__> But unlike actual ApplicativeDo, arrow lets you write composable things that take inputs without going full pointfree
10:04:47 <sm> alexkosh: add trace statements to check how gnuplot is being called in each case, or use strace ?
10:05:17 <dmj`> strange how MonadIO m => (HtmlT m) exists, but toHtml is constrained to be pure Monad m => a -> HtmlT m
10:06:16 <alexkosh> sm: let me try. could you please elaborate what is strace?
10:07:50 <alexkosh> sm: already found on haskell wiki! thanks
10:09:28 <sm> np
10:14:49 <geekosaur> dmj`, is that a problem? toHtml is more general
10:18:17 * hackagebot http-conduit 2.2.2.1 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.2.2.1 (MichaelSnoyman)
10:19:56 <dmj`> geekosaur: yes, I have a type that looks like data Foo = Foo { thing :: IORef Int }, I'd like ToHtml instance let me do { val <- liftIO (readIORef ref); pure $ div (toText val) } or something
10:20:34 <alexkosh> well, my gnuplot function is called with same arguments when I do it in ghci and after compilation
10:20:44 <alexkosh> but one time it plots, other does not...
10:22:26 <alexkosh> sm: where is "strace"? hoogle cannot find it
10:22:37 <dmj`> geekosaur: I think it needs to be more specific I guess
10:22:55 <dmj`> it's just strange since there already is a MonadIO constraint...
10:23:52 <geekosaur> dmj`, if it knows the specific m, it will not lose the availability of a MonadIO
10:28:09 <ertesx> nshepperd_: can't confirm that in the context of AFRP, but the cases when (.) is necessary can be very subtle
10:28:58 <dmj`> geekosaur: it can't deduce MonadIO
10:29:46 <geekosaur> oh, instance definition, no that won't work
10:32:38 <alexkosh> hm, I found one clue... I put 10 graphs, of the same structure "plotDots [] [(1::Double,2::Double),(3,4)]". and only 3 of them were ploted. It seems like program is closing before it can plot graph... how can I make it wait for IO action to finish?
10:33:46 <dmj`> geekosaur: :( 
10:33:58 * dmj` reaches for unsafePerformIO
10:34:53 <geekosaur> dmj`, suspect there's good reason they didn't include MonadIO and therefore you can't get away with it anyway
10:34:54 <dmj`> I could put pure (IO ()) actions in there, then sequenceA
10:35:52 <dmj`> geekosaur: the docs say MonadIO is there to give you IO during html construction, yet the toHtml instsances (meant for constructing html) are void of that
10:42:05 <alexkosh> well, I solved the problem with putting "thredDelay". it seems to be a bug of gnuplot binding. 
10:45:15 <sm> alexkosh: why did it not work when compiled ?
10:47:23 <alexkosh> sm: program finishes before it plots the graph... (I do not know why exactly) so if I put "threadDelay" after the plot command, it plot the graph alright...
10:47:46 <sm> aha
10:48:00 <alexkosh> I am tring to put a bug-ticket but cannot figure out how =)
10:48:09 <sm> I expect when compiled, it is threaded, in GHCI not
10:48:16 * geekosaur scans back for pastes and sees everything but the program in question
10:49:11 <geekosaur> ghci is always threaded. I am wondering if misuse of lazy I/O is involved and interpreted bytecode is just slow enough that the errant hClose is delayed to after the final data is written
10:49:31 <alexkosh> here is the code
10:49:34 <alexkosh> http://paste.ofcode.org/35MGxhcM9YzyK7YRc2yQzSi
10:50:08 <alexkosh> the relevant part is at the end
10:50:14 <alexkosh> main and computeAll function
10:51:24 <geekosaur> oh, not anything in your code controlling that. so quite likely it's the library that is buggy about it. and threading might well be involved if it's using a thread internally, since terminating the main thread terminates all subthreads as well
10:51:36 <geekosaur> (there is no way to make it wait for them to finish)
10:52:41 <geekosaur> (this is a limitation/restriction of both the posix and windows thread interfaces; you have to use a wrapper such as the async library to get the ability to wait for threads, and even if the plot library does so it doesn't expose anything you could use to wait)
10:56:42 <alexkosh> eh, anyway, gnuplot is still probably the best option. eventually I will need use latex labels in my graphs.
10:58:32 <geekosaur> actually that can't even be bytecode slowness since the plot is the last thing it does. so it's just continuing to runt he thread in the background when you get the ghci prompt back
10:58:57 <geekosaur> (you could probably test that by using runhaskell instead of compiling it)
11:00:58 <alexkosh> well, unfortunatly I cannot do it quicly. I just starting with NixOs, and I didnot created haskell envoroment for my needs yet. So I use stack
11:01:20 <geekosaur> stack can runhaskell for you
11:01:30 <alexkosh> oh, how?
11:01:32 <geekosaur> if it's a recent stack, stack foo.hs
11:01:40 <geekosaur> if not, stack exec -- runhaskell foo.hs
11:01:52 <alexkosh> ok, sek
11:04:08 <alexkosh> well - runhaskell works without threadDelay.
11:04:41 <alexkosh> but the program is much slower with it, so it maybe artificial threadDealy? =)
11:04:58 <alexkosh> 23sek vs 3 sek'
11:05:08 <alexkosh> 23sec vs 3 sec
11:05:36 <prsteele> is there an easy way to get GHC to use type aliases in error messages? E.g. replace errors with "Foo Bar Baz" with "Fooer" ?
11:06:42 <shapr> ooh, that would be handy
11:06:56 <shapr> though sometimes a verbose type error shows you why what you expected to match doesn't
11:07:06 <prsteele> I'm using type-level naturals and I want e.g. 'S ('S 'Z) to come out as Quadtratic
11:07:34 <prsteele> Constant, Linear, Quadratic, ..., for some hard-coded number of names
11:08:14 <Phillemann> I'm looking for a library to make HTTP GET requests containing some headers that return JSON. Any recommendations?
11:08:15 <glguy> prsteele: No, you can't do that specifically, but there is some support in GHC 8 for custom type errors that's worth knowing about if you're going down this road
11:08:31 <prsteele> glguy: thanks, I'll keep an eye out  
11:09:05 <prsteele> "n this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error. " why yes that is _exactly_ what I want
11:11:14 <mzabani> howdy, folks! Has anyone had trouble when building postgresql-libpq on Nixos? I'm getting "setup: The program 'pg_config' is required but it could not be found."
11:11:40 <shapr> mzabani: install the postgresql dev packages, that'll get you pg_config, I think
11:12:03 <ertesx> that doesn't help with nix
11:12:16 <mzabani> shapr: I already have pg_config on my PATH
11:12:23 <shapr> oh, I don't know then
11:13:06 <ertesx> mzabani:
11:13:10 <ertesx> % nix-build "<nixpkgs>" -A haskellPackages.postgresql-libpq
11:13:10 <ertesx> /nix/store/a93imsq2wk69g4q8crvv1j422b65ddsq-postgresql-libpq-0.9.1.1
11:13:14 <ertesx> works for me
11:13:24 <ertesx> i'm on the unstable channel
11:13:54 <ertesx> but i seem to be slightly outdated
11:13:58 <mzabani> I'm on the 16.03 stable channel only
11:14:21 <mzabani> In fact, I have to use lts-5.9 here, anything newer won't work, do you know why?
11:14:39 <ertesx> sorry, i have no experience with LTS
11:15:13 <ertesx> you might have more luck in #nixos, and if not, you should submit a bug report
11:15:19 <ertesx> (for nixpkgs)
11:16:24 <mzabani> ertesx: do you use nightly then?
11:16:56 <ertesx> mzabani: just to clarify: are you using nix to build haskell, or are you just using nix as a package manager and then cabal-install/stack?
11:17:34 <mzabani> I'm using nix: enable in my stack.yaml file
11:17:55 <mzabani> and then I use stack
11:18:16 <ertesx> i see…  in that case scratch everything i said…  i have no experience with stack =)
11:18:18 * hackagebot ekg-cloudwatch 0.0.1.3 - An ekg backend for Amazon Cloudwatch  https://hackage.haskell.org/package/ekg-cloudwatch-0.0.1.3 (parsonsmatt)
11:18:20 * hackagebot ekg-cloudwatch 0.0.1.4 - An ekg backend for Amazon Cloudwatch  https://hackage.haskell.org/package/ekg-cloudwatch-0.0.1.4 (parsonsmatt)
11:18:43 <mzabani> oh, I see, thank you for your attention, anyway!
11:32:15 <hackd2> Howdy all
11:32:45 <hackd2> Whats your story of beginning to program in haskell? 
11:33:40 <shapr> I was trying to figure out how to make Python code that worked *right* and I discovered the idea of referential transparency on my own. A friend asked me why I was writing Haskell in Python, so I looked up Haskell.
11:34:00 <hackd2> Ha! Awesome. 
11:34:00 <shapr> Then angels came down and told me my life would be forever better.
11:34:21 <shapr> So I decided to start an IRC channel for the Haskell language.
11:34:26 <hackd2> How long have you been writing haskell 
11:34:29 <coolguy> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/ is this worth putting on my Google/Microsoft/Facebook/Oracle resume
11:34:31 <coolguy> ?
11:35:16 <hackd2> Im on q queat for the programming language ill be most productive in since i read beating the averages 
11:35:29 <hackd2> Quest*
11:36:08 <shapr> hackd2: Haskell is a good and powerful option, but also check out other options. What matters most is what fits your brain, so make sure to try a bunch of different languages.
11:36:36 <hackd2> Exactly, the most productive language for me
11:36:42 <shapr> hackd2: I've been writing Haskell for about 15 years, and I'm still learning things that stretch my brain and help me write better code in other languages.
11:37:15 <hackd2> Whee, thats a lot of time.
11:37:17 <shapr> I've been paid to write Haskell some years, but at this moment I'm writing Python for work.
11:38:01 <shapr> hackd2: Haskell is pure functional, you may also want to learn some Prolog to get a feel for a logic language. If you haven't done imperative, Python is a good easy place to start there.
11:38:09 <hackd2> shapr: how is your python different, after doing a lot of haskell
11:38:51 <coolguy> Will someone answer my question?
11:38:53 <shapr> hackd2: almost zero global state, everything is explicitly passed into functions, and I consider 95% of mock objects to signal a flaw in code design
11:39:12 <shapr> coolguy: you asked a resume queqstion, I don't have a good answer.
11:39:38 <coolguy> shapr: Ok
11:39:41 <shapr> coolguy: you will be a better programmer after going through that lesson?
11:39:43 <hackd2> shapr: did mostly php, vb, c#, js
11:39:48 <coolguy> shapr: Yes
11:40:00 <shapr> hackd2: there's some cool stuff in C#, I really enjoyed LINQ
11:40:32 <hackd2> shapr: what do you mean by mock objects signaling flaws? 
11:41:16 <shapr> For cases like building a pretend filesystem or network socket, I think mock objects are okay. So I figure your test suite should max out at no more than five different mock objects ever.
11:41:45 <shapr> Past that, it means you're mocking up global state, when your code would be easier to test/debug when given an explicit input
11:42:12 <mizu_no_oto_work> shapr: do you tend to use objects much in python?  Or just functions and data?
11:42:22 <shapr> For example, a parser that mixes reading the file with parsing, can't be tested without having a pretend filesystem, but splitting that into file read and parse input suddenly makes tests easy.
11:42:53 <shapr> mizu_no_oto_work: I use objects built by others when that's the shortest path, but I haven't built an object by choice in my last few years of Python coding.
11:43:16 <shapr> One of my interview questions for this job expected multiple objects, but I did the whole thing in three list comps
11:43:51 <shapr> I'm sure there are still cases where an object is a better approach, but I don't know those cases.
11:44:10 <sm> I find it hard to reconcile the apparent lack of need for "objects" today, with their seeming indispensability and incredible productivity in smalltalk
11:45:00 <shapr> sm: mind you, SmallTalk's default method return was self/this, in Python it's None, so you can't chain method calls as you would in SmallTalk
11:45:18 <shapr> That was one reason code composition was easier in SmallTalk
11:45:49 <shapr> On the other hand, smalltalk codebases I've seen end up with a bazillion tiny bits of code, sort of reminds me of the Prelude
11:45:55 <shapr> sm: What do you think?
11:46:29 <sm> I wonder if the "objects" used there are mostly equivalent to our modules
11:55:36 <soLucien> in a 2-tuple i can use fst and snd . What is the n-tuple alternative 
11:55:46 <mauke> pattern matching
11:56:04 <soLucien> i have let a  = ('foo', 'bar', 'baz')
11:56:07 <soLucien> i want baz
11:56:14 <soLucien> i udnerstand pattern matching
11:56:21 <soLucien> butr how do i use it in a language construct 
11:56:36 <mauke> what
11:56:37 <soLucien> what's the next step in ghci ? 
11:56:45 <mauke> case a of (x, y, z) -> y
11:57:15 <mauke> except z
11:57:25 <mauke> but that should be "baz", not 'baz', anyway
11:58:16 <shachaf> i,i case a of (x, y, z) -> (z, y)
11:59:29 <soLucien> okay i was trying something else
11:59:31 <soLucien> thanks a lot
11:59:43 <soLucien> so case . dully noted
11:59:59 <soLucien> duly*
12:00:16 <shachaf> case or any other sort of pattern matching
12:00:37 <shachaf> (\(x,y,z) -> y), f (x,y,z) = y
12:05:45 <soLucien> i tried the second option  f (x,y,z) = y
12:05:45 <soLucien> <interactive>:50:11: parse error on input `='
12:08:39 <prsteele> soLucien: if you're defining that in GHCi then you need "let f (x, y, z) = y"
12:09:00 <soLucien> cool, thanks !
12:09:15 <soLucien> that worked
12:09:41 <prsteele> soLucien: so GHCi is actually running in an IO () loop, so each statement needs to either be something monadic (like print x) or a let statement
12:10:04 <prsteele> the details might be slightly off but the intuition should be correct
12:10:25 <geekosaur> except ghc8 made the let optional...
12:10:47 <prsteele> geekosaur: I didn't know that, haven't moved to 8 yet. I take it from the ... that you don't like it?
12:10:59 <geekosaur> no, just saying it breaks your intuition
12:11:04 <prsteele> ah okay
12:11:13 <geekosaur> (if things like import and being able to do data Foo ... didnt already)
12:11:18 <crobbins> geekosaur: what part is optional in ghc 8 ?
12:11:39 <geekosaur> you don't need the 'let' in ghc8, you can do it like at the top level of a file
12:11:45 <geekosaur> foo ... = ...
12:11:51 <crobbins> ...
12:11:53 <crobbins> how sweet
12:12:26 <crobbins> hey, and lts haskell is now on ghc 8
12:16:33 <geekosaur> I'm actually a little surprised they did that; thought they were waiting on a bugfix planned for 8.0.2
12:17:02 <joe9> Where is the haskell definition of CUInt32 or CUInt64 , not in Foreign.C and in Foreign.C.Types
12:18:19 * hackagebot stratosphere 0.1.5 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.5 (jdreaver)
12:18:25 <crobbins> it's a little irrational, but i'm pretty excited about the removal of the `let` requirement in ghci
12:19:21 <geekosaur> hayoo says there isn't one
12:19:42 <geekosaur> FFI only defines standard C types
12:19:48 <mauke> uint32_t is standard
12:22:58 <prsteele> has anyone worked with the numeric prelude, or have any insight on it's quality, state of development, goals...
12:23:00 <drdo> What's this "stack" thing?
12:23:05 <dxtr> So, uuh, how do I bring up the intero repl?
12:23:12 <joe9> I am sure there is some ffi bindings to a fuction using uint32_t or uint64_t . not sure how to find it though.
12:24:15 <dxtr> Oh, C-c C-l. Sorry. :p
12:24:16 <joe9> It would be wrong to use CUInt for uint32_t or uint64_t, correct?
12:24:25 <mauke> indeed
12:24:40 <ongy> CUInt for uint32_t would work on x86_64, but may break for others
12:25:09 <mauke> ooh!
12:25:38 <mauke> joe9: Word32 has a Storable instance
12:26:01 <ongy> which only helps with pointers iirc
12:27:27 <ongy> mauke: are you sure (u)int*_t is standard? Iirc it's implemented in all libc, but is not in the C standard (maybe that changed with C11 or so)
12:27:40 <mauke> has been standard since C99
12:27:59 <mauke> though technically the fixed-width types are optional, but only if your implementation doesn't have them
12:28:16 <mauke> i.e. if your machine doesn't support 32-bit integers, int32_t won't exist
12:29:13 <mauke> int_least32_t is required, though
12:29:56 <shapr> Anyone here in or near Atlanta? I'm giving a Haskell talk next month at the Atlanta Functional Programming meetup!
12:31:08 <prsteele> shapr: will it be broadcast (no, not near Atlanta)
12:31:42 <joe9> someone seems to have stumbled upon this too: http://haskell-cafe.haskell.narkive.com/CryiK8FY/additonal-types-for-foreign-c-types
12:31:50 <shapr> prsteele: Nah, we don't have the AV skills to broadcast, but we might be able to record and upload
12:31:54 <carado> is this normal ? http://paste.awesom.eu/WUeB I’ve come upon it when a liftM2 I had in my code simply didn’t run its first argument
12:31:58 <joe9> cannot figure out the conclusion of that discussion though.
12:32:03 <shapr> prsteele: I'll be talking functor, applicative, monad so basic stuff for some Haskell people.
12:32:12 <prsteele> shapr: ah cool, good luck!
12:32:52 <shapr> My last Haskell talk was an intro workshop where we built a word histogram from scratch for people with no prior coding experience.
12:32:56 <joe9> mauke: Should I use Word32 and Word64?
12:32:57 <alexkosh> is it correct, that when compled with "--with-rtsopts=-N" the program will try to use all avaliables cores?
12:34:06 <alexkosh> + "-threded -rtsopt"
12:35:28 <geekosaur> alexkosh, yes
12:35:47 <carado> fmap similarly doesn’t seem to work
12:35:55 <mauke> joe9: yes
12:36:01 <joe9> mauke: there is an Int32 in Foreign. But, no CInt32.
12:36:15 <alexkosh> thanks
12:36:46 <joe9> mauke: Can I use Int32 instead of Word32? or, is there a specific reason to use Word32 ?
12:36:55 <geekosaur> carado,
12:36:58 <geekosaur> :t liftM2 (\x y -> print (x,y)) (return 1) (return 2)
12:37:00 <lambdabot> Monad m => m (IO ())
12:37:02 <geekosaur> ^
12:37:13 <mauke> joe9: Word32 is uint32_t, Int32 is int32_t
12:37:26 <joe9> mauke: oh, makes sense. Thanks.
12:37:27 <geekosaur> Prelude Control.Monad> liftM2 (\x y -> print (x,y)) (return 1) (return 2) >>= id
12:37:27 <geekosaur> (1,2)
12:38:03 <geekosaur> or equivalently use join
12:39:07 <carado> oh, indeed. I must be misunderstanding something then, sorry.
12:40:09 <carado> right, liftMn takes a (a -> b -> .. -> r), not (a -> b -> .. -> m r)
12:41:08 <siwica> I am using emacs with haskel-mode. Is there a simple way there to open a repl and have all function definitions of a particular file in scope?
12:54:18 <aarvar> siwica: haskell-process-load-file?
12:56:02 <dmj`> mutable vectors should have an append function
12:56:39 <shapr> siwica: #haskell-emacs may also have more detail
12:57:34 <np356> hello, what does this syntax mean? someFunction somethingOne@SomethingTwo{..} = undefined
12:57:49 <np356> I never saw that kind of pattern matching before
12:58:10 <geekosaur> it's an as-pattern, lets you give a name to something you are also pattern-matching internally
12:58:40 <np356> ok, and what about the {..} part?
12:58:46 <geekosaur> instead of someFunction somethingOne = case somethingOne of SomethingTwo{..} -> ...
12:59:02 <geekosaur> that is a record pun, which exposes all the fields of the records with their names
12:59:42 <geekosaur> so if data SomethingTwo = SomethingTwo {foo :: Integer, bar :: String}, that will bind foo and bar without your having to name them
13:00:05 <geekosaur> well, named field pun iirc
13:00:09 <VitorCBSB> Oh wow, that is super useful. I'm going to start using that.
13:00:42 <np356> that is cool
13:00:45 <np356> thanks
13:01:13 <geekosaur> it's an extension, need {-# LANGUAGE NamedFieldPuns #-}
13:01:35 <geekosaur> (annoying;y the documentation calls them both record puns and named field puns, but only accepts the latter as the name of the extension)
13:01:59 <geekosaur> as-patterns are standard though
13:02:10 <siwica> thank you, guys!
13:02:39 <np356> https://github.com/alphaHeavy/consul-haskell/blob/master/src/Network/Consul.hs
13:02:52 <np356> I don't see NamedFieldPuns there
13:03:04 <geekosaur> check the cabal file too
13:03:09 <geekosaur> you can specify extensions to apply to all source files
13:03:13 <np356> ahh, RecordWildCards maybe
13:03:19 <np356> yeah, or cabal. right
13:03:29 <geekosaur> hm, maybe I have them confused
13:03:49 <athan> has anyone here done much peeking around at the resulting binary code from an executable build?
13:03:57 <athan> I've got a peculiar question...
13:04:17 <geekosaur> oh right, that one is RecordWildCards, punning is doing that for one field at a time (saying Foo { a, b } instead of Foo {a = a, b = b})
13:04:24 <geekosaur> gleh
13:04:31 <athan> if I generate a seed at compile time, with runIO or something?
13:04:48 <athan> and if I can, would that constant number be somehow visible in the resulting binary code?
13:05:10 <athan> geekosaur: It's all javascripty :x
13:05:34 <c_wraith> uh. are you asking if the binary can contain a number without containing it.. I think you know the answer. 
13:05:44 <geekosaur> the constant number will be visible, but not necessarily in a way that is useful for you
13:05:54 <geekosaur> for one, it'll be a binary representation
13:07:00 <np356> RecordWildCards is super helpful. It should be part of the core language imho.
13:07:38 <geekosaur> propose it! the language committee has been resuscitated and is accepting proposals for standardization
13:07:42 <crobbins> i actually like that pure Haskell with no extensions is really simple, and the user can extend it as desired
13:08:06 <crobbins> that way teams can decide which features can be used and which ones shouldn't
13:08:12 <geekosaur> I think they;re still using the haskell-prime list
13:08:22 <crobbins> that way we don't end up with a kitchen sink
13:08:53 <geekosaur> enh. it's not like that steals syntax that would otherwise mean something else
13:10:34 <geekosaur> (BangPatterns being an example of that one; you lose the ability to define infixes that include !)
13:10:37 <np356> I'm not sure if extending the language itself should be a commonplace practice. Though I come from a C/C++ background, so I might not get this yet.
13:11:01 <np356> I think that its better to implement things as libraries rather than changes to the language syntax
13:11:13 <geekosaur> the more ghc diverges from the standard and the more people use those divergent features, the harder it is for another compiler to be developed
13:11:23 <crobbins> that's fair, but then again, there are some aspects that might be undesirable, like using Foo{..} to use names in scope to construct a Foo
13:11:40 <geekosaur> andf these are things you can't implement as libraries (barring TH. which has its own portability issues)
13:14:28 <bjorn123> test
13:16:28 <np356> works
13:18:04 <bjorn123> np356: thanks. im testing the emacs irc client erc 
13:18:20 * hackagebot hakyll-sass 0.2.1 - Hakyll SASS compiler over hsass  https://hackage.haskell.org/package/hakyll-sass-0.2.1 (meoblast001)
13:18:29 <bjorn123> anyone using haskell to write emacs extension ?
13:19:59 <geekosaur> suddenly being terrified by the notion of a ghc-to-elisp compiler
13:20:13 <higgs> Is there a Haskell to LLVM compiler?
13:20:22 <geekosaur> ghc -fllvm
13:20:28 <higgs> nice
13:20:39 <michi7x7> > [(a,b,c)|a<-[1..99],b<-[1..99],c<-[1..99],a+b*c==42]
13:20:42 <lambdabot>  [(1,1,41),(1,41,1),(2,1,40),(2,2,20),(2,4,10),(2,5,8),(2,8,5),(2,10,4),(2,20...
13:20:45 <janosp> hey one question: Assuming I have two functions : f :: a -> Maybe a     and   g :: a -> Maybe a
13:20:54 <janosp> is there a way to put them together?
13:21:01 <janosp> without unwrapping the result?
13:21:02 <pharaun> time to implement a llvm -> elisp
13:21:39 <geekosaur> f x >>= g
13:22:40 <janosp> geekosaur: can I chain also like 5 functions
13:22:43 <np356> > [1..10]
13:22:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:22:49 <np356> nice
13:22:56 <np356> > [1..]
13:22:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:23:03 <geekosaur> sure
13:23:04 <michi7x7> janosp: yeah, this uses the Monad instance
13:23:06 <np356> i see
13:24:48 <geekosaur> :t let f :: Int -> Maybe Int; g :: Int -> Maybe String; h :: String -> Maybe String; f = undefined; g = undefined; h = undefined in f 5 >>= g >>= h
13:24:54 <lambdabot> Maybe String
13:25:05 <janosp> cool
13:25:17 <janosp> And is there a way to combine Either a b and Maybe a
13:25:35 <Clint> janosp: https://hackage.haskell.org/package/errors-2.1.0/docs/Control-Error-Util.html
13:25:40 <janosp> f :: a -> Either b a   ,   g :: a -> Maybe a
13:26:06 <koz_> janosp: What do you mean by 'combine'?
13:26:18 <janosp> something like f >>= k
13:27:01 <Clint> use 'note' or 'hush'
13:27:03 <jle`> janosp: you'd have to convert one or the other into a common type before you can use >>=
13:27:35 <jle`> so you'd use something like note/hush, yeah ... or you can alos just manually use "either" and "maybe" from the standard libraries
13:28:01 <janosp> OK I see
13:28:12 <jle`> janosp: so you could use (note e . g) to make g an a -> Either e a, so that'd work
13:28:20 <jle`> or (hush . f) to make f an a -> Maybe a, so that'd work too
13:29:02 <jle`> i was going to complain about hoist being oddly named in that module but then i looked at the author
13:30:41 <janosp> note ? hush ?
13:31:09 <geekosaur> Control.Error.Util
13:31:50 <janosp> ah I see
13:31:53 <janosp> awesome..
13:31:54 <geekosaur> from the errors package
13:31:54 <jle`> janosp: or `maybe (Left "hey") Right` or `either (const Nothing) Just`
13:32:19 <janosp> thanks!!!
13:32:43 <janosp> oh, one more question
13:32:45 <janosp> :D
13:33:05 <janosp> what if it's f :: a -> IO Maybe a     and     g :: a -> IO Maybe a
13:33:10 <janosp> does that work the same?
13:33:26 <Xnuk> @hoogle </>
13:33:29 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
13:33:29 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
13:33:29 <lambdabot> Filesystem.Path (</>) :: FilePath -> FilePath -> FilePath
13:33:58 <jle`> janosp: do you mean a -> IO (Maybe a) ?
13:34:06 <janosp> yes
13:34:22 <jle`> the defaul >>= can't compose them directly, so you can use do notation and pattern matching
13:34:46 <jle`> but there's a newtype wrapper in the transformers package that can give you a >>= that works with short-circuiting
13:35:33 <jle`> janosp: you can't do f <=< g, but you can do (MaybeT . f) <=< (MaybeT . g)
13:35:43 <jle`> i'm not sure how familiar you are with newtype wrappers
13:35:58 <janosp> not familiar at all
13:36:16 <jle`> so sometimes in Haskell we wrap types in newtypes so we can give them different instances
13:36:20 <jle`> do you know about typeclasses?
13:36:59 <janosp> yes, I believe I have a basic understanding
13:39:19 <jle`> for example, the Monoid typeclass lets you "combine" values of a certain type in a neat way
13:39:30 <jle`> but it's not clear how numeric values can implement Monoid
13:39:48 <jle`> so instead of deciding, we can write a newtype that wraps them, and write a different typeclass instance for every type
13:39:53 <jle`> > Sum 1 <> Sum 10
13:39:55 <lambdabot>  Sum {getSum = 11}
13:39:57 <jle`> > Product 1 <> Product 10
13:40:00 <lambdabot>  Product {getProduct = 10}
13:40:15 <jle`> :t (<>)
13:40:17 <lambdabot> Monoid m => m -> m -> m
13:40:25 <jle`> it's kind of a type system hack
13:40:52 <jle`> so MaybeT wraps an IO (Maybe a) so that when you use (>>=), it gives you short-circuiting behavior instead of the normal unwrapped behavior
13:41:44 <janosp> ah interesting
13:41:46 <janosp> I see
13:42:09 <janosp> Does such a wrapper also exist for IO (Either a b) ?
13:46:18 <janosp> OK, I find that myself :)
13:46:20 <janosp> EitherT
13:46:21 <jle`> yeah, the common one is ExceptT, in transformers :)
13:46:25 <janosp> Thank you for the help!
13:46:33 <jle`> transformers has both MaybeT and ExceptT
13:46:35 <jle`> np!
13:46:36 <janosp> *found
13:46:41 <janosp> awesome thanks!
13:46:48 <jle`> i'm not sure if i'd still recommend EitherT in this day and age
13:46:56 <jle`> despite its nice name
13:47:08 <janosp> why?
13:47:21 <jle`> transformers is a more canonical package
13:47:26 <jle`> it's actually included with ghc
13:47:49 <jle`> and almost all projects will already have transformers as a dependency
13:48:06 <jle`> it's sort of basically a de facto standard library that you can expect most projects to already be using
13:48:25 <jle`> EitherT came about only because transformers didn't have it
13:48:41 <jle`> but since then, transformers added EitherT, but called it ExceptT
13:48:58 <janosp> ah ok
13:50:12 <janosp> is there a reason why they called it ExceptT
13:51:14 <maninalift> It's used to model something like an exception
13:52:09 <maninalift> (i.e. it is either a result or a failure)
13:54:01 <maninalift> I hope people don't mind mind if I ask a stack related question here. - no response in #haskell-stack yet, and I have had more success here in the past
13:55:35 <maninalift> I have created a docker image with based on fpco/stack-build with ghcjs installed and known to stack.
13:55:40 <jle`> janosp: the author of transformers wanted to give it a name that matched the semantics of the type
13:56:01 <jle`> there was actually a bit of back and forth about it among maintainers
13:56:11 <jle`> but eventually it was just shipped because it wasn't worth the bikeshedding heh
13:56:17 <janosp> hehheehe
13:56:38 <maninalift> I have a project which I am able to build with ghcjs by copying the project into the docker container and building it
13:57:39 <maninalift> however, if I try to build the project locally (with the appropriate docker section added to the stack.yaml) it complains that it can't find the ghcjs compiler
13:58:04 <maninalift> it is as if it is looking for the compiler locally instead of in the container
13:58:17 <maninalift> anyone know if this is the intended behaviour?
13:58:51 <maninalift> I have all the docker files and stack configs to hand but didn't want to overload with information to begin
13:58:52 <maninalift> :)
14:18:22 * hackagebot simple-effects 0.1.0.2 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.1.0.2 (darwin226)
14:18:24 * hackagebot simple-effects 0.2.0.0 - A simple effect system that integrates with MTL  https://hackage.haskell.org/package/simple-effects-0.2.0.0 (darwin226)
14:18:26 * hackagebot stratosphere 0.1.6 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.6 (jdreaver)
14:24:42 <janosp> @jle` : I was reading a bit about the stuff you told me, and it seems that it's all combined in the Control.Error package
14:24:42 <lambdabot>  Parse failed: Parse error: :
14:25:03 <janosp> but it uses EitherT 
14:25:19 <janosp> should I maybe start of with that one?
14:39:02 <athan> could the output binary of a program ever be obfuscated?
14:39:16 <athan> idk if that's "DRM" or not
14:39:55 <athan> even if it's just a number, do you think there would be a way to "hide" it?
14:39:56 <carado> I think you mean the content binary, not the output binary
14:40:09 <athan> (because it's a seed)
14:40:42 <athan> carado: I think you're right, but I'm trying to talk about an executable file
14:40:46 <prsteele> athan: strictly speaking something like this could work https://github.com/xoreaxeaxeax/movfuscator
14:40:55 <athan> or possibly object files too, I don't know jack about linking :\
14:41:05 <prsteele> athan: express the seed as some computation, and put that computation through something like the movfuscator
14:41:43 <carado> though I can hardly imagine something like a fixed seed remaining hidden for long if your executably ever finds its way in a motivated internet community
14:41:47 <athan> prsteele: I'm goign to generate the value randomly at compile time with TH, so I should be all set :)
14:42:04 <athan> yeah
14:42:11 <athan> I need an update system maybe :x
14:42:11 <carado> what’s your aim ?
14:42:32 <athan> authenticity of a web server, without TLS and for cheap
14:42:50 <athan> because you're not expecting it to be exposed to the word
14:42:53 <athan> world*
14:44:31 <carado> you want your executable to be able to connect to the server but not other programs ?
14:45:15 <carado> if so, not really doable, and sounds like a terrible idea.
14:50:46 <athan> Or, I could just hold a really massive private key
14:50:55 <athan> private and secret
14:51:29 <athan> agh shoot I think there's more to this than I thought
14:51:33 <carado> and do what with it ?
14:51:50 <soLucien> is there some way of knowing what methods typeclasses implement?
14:52:04 <carado> yeah. In my experience, desperately trying to accomplish something which is in the long run undoable only results in abominations.
14:52:09 <athan> er derp wrong channel :x
14:52:12 <prsteele> soLucien: in GHCi, :i SomeClass
14:52:21 <prsteele> soLucien: hoogle is useful too
14:52:25 <prsteele> ?where hoogle
14:52:25 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
14:53:03 <soLucien> so if i want to implement Eq on my own type, i would have to look at :i of Eq
14:53:17 <soLucien> then i overwrite whatever functions that seem fit
14:53:22 <soLucien> for my object
14:53:25 <soLucien> is that correct ?
14:53:28 <geekosaur> usually we derive things like Eq. but yes, you need to look it up
14:53:30 <prsteele> soLucien: yes. However Eq can generally be sensibly derived automatically in a deriving clause
14:53:41 <geekosaur> and... "object" are you leading yourself into an OO tarpit?
14:53:54 <geekosaur> haskell is not OO, you will just get into trouble if you try to force it
14:54:01 <soLucien> damnit .. i've only been at it for 15 days
14:54:10 <soLucien> after 5 years of OO
14:54:31 <prsteele> soLucien: don't use typeclasses for 'methods' on 'objects'. For that just use functions. Use typeclasses for polymorphism over different data types.
14:55:28 <soLucien>  thanks 
15:18:23 * hackagebot proto-lens 0.1.0.3 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.1.0.3 (gnezdo)
15:18:25 * hackagebot proto-lens-protoc 0.1.0.3 - Protocol buffer compiler for the proto-lens library.  https://hackage.haskell.org/package/proto-lens-protoc-0.1.0.3 (gnezdo)
15:19:22 <dmwit> athan: I've been on a project here at work studying cryptographic program obfuscation for a few months now. It can be done, but the state of the art has resulting programs that are 10-12 orders of magnitude (!) slower than bare metal.
15:19:33 <dmwit> athan: So whatever program you want to obfuscate better be pretty damn simple. =P
15:20:58 <athan> dmwit: Wow, I had no idea
15:20:59 <athan> thank you
15:21:01 <siwica> Using the diagrams library I stumbled across the operator ^& 
15:21:13 <athan> It doesn't need to be the whole program though I think
15:21:15 <siwica>  I couldn't figure out its meaning though
15:21:45 <athan> maybe just a part that takes a user supplied seed, and returns a new seed (with the secret key hashed in there)
15:21:56 <athan> dmwit ^
15:22:35 <MarcelineVQ> siwica: it's local to diagrams, it's also called pr appearantly https://www.stackage.org/haddock/lts-7.0/diagrams-lib-1.3.1.4/Diagrams-Coordinates.html#v:-94--38-  
15:23:11 <siwica> MarcelineVQ: Oh, thank you! I was wondering since I couldnt find it on Hoogle
15:24:05 <dmwit> athan: As far as I know, nobody has managed to turn a symmetric encryption scheme into an asymmetric one using iO in that way for any reasonable ssecurity parameter and have it run in reasonable (read: sub-month) time scales.
15:25:11 <dmwit> siwica: http://hoogle.haskell.org/?hoogle=%28^%26%29
15:25:12 <MarcelineVQ> siwica: you can try http://hayoo.fh-wedel.de/ or https://www.stackage.org/ if you can't find something on hoogle, often I'll just start with those unless it's something I know hoogle will have
15:25:35 <dmwit> siwica: The new Hoogle is better for by-name searches (but doesn't support by-type searches).
15:26:21 <dmwit> athan: However, you might look into TPMs. They offer pretty much exactly that operation and are secure against all but physical attacks.
15:26:31 <siwica> dmwit: I was querying https://www.haskell.org/hoogle/?hoogle=(%5E%26)
15:26:34 <MarcelineVQ> that's kind of confusing :o http://hoogle.haskell.org/ vs https://www.haskell.org/hoogle/
15:26:40 <siwica> Is that a "different" Hoogle?
15:27:01 <dmwit> siwica: Yes, that's what I'me referring to as "old Hoogle" in my previous comment.
15:27:31 <siwica> dmwit: Oh I see. What are the differences among the two?
15:28:23 <dmwit> I think new Hoogle has pushed the "choose which packages you're searching in" feature more to the front of its UI.
15:28:32 <dmwit> Other than that (and disabling type-based search), not much.
15:28:37 <siwica> MarcelineVQ: Thank you for the link to Hayoo!
15:28:50 <dmwit> New Hoogle also happens to have indexed more packages.
15:29:12 <MarcelineVQ> dmwit: being able to restrict searches by author/package/tag is pretty neat
15:29:20 <siwica> Ok, perfect. Very good to know. Thanks!
15:30:26 <dmwit> athan: https://en.wikipedia.org/wiki/Trusted_Platform_Module#Platform_integrity
15:30:48 <sm> new hoogle should get released already
15:31:00 <dmwit> sm: No type-based search is a pretty big drawback.
15:31:07 <sm> finished and released
15:31:21 <dmwit> As long as we're signing up other people for work, yeah, sure, why not. =)
15:31:35 <soLucien> If i want to create a data type that does not allow null constructor
15:31:45 <soLucien> what is the best way to acheive it ?
15:32:02 <prsteele> soLucien: what do you mean by a null constructor?
15:32:18 <soLucien> data Curve = [Point]
15:32:33 <prsteele> soLucien: data Curve = Curve Point [Point] ?
15:32:38 <dmwit> data CurveWithAtLeastOnePoint = Curve Point [Point]
15:32:39 <soLucien> yes
15:33:06 <dmwit> or just `type Curve = Data.List.NonEmpty Point`
15:33:28 <dmwit> err, `Data.List.NonEmpty.NonEmpty`, I mean
15:33:41 <soLucien> i belive Point [Point] is a bit cleaner, right ?
15:34:05 <prsteele> the advantage would be getting all the typeclass instances that Data.List.NonEmpty happens to provide
15:34:10 <dmwit> Not really. From the source: `data NonEmpty a = a :| [a]`. So pretty much identical.
15:34:14 <prsteele> and other functions
15:36:51 <MarcelineVQ> ah that was confusing, there's a package called NonEmpty that is just like NonEmptyList except that's pretty much just a data declaration.
15:37:18 <prsteele> I have to run now, but I might be back later. I'm segfaulting the compiler running makeLenses, and I'll try to isolate a minimal example (if I can't figure out why it's happening for some reasonable reason)
15:37:24 <MarcelineVQ> I'm like, "What is the advantage of pulling a package for this"
16:07:22 <soLucien> how can i pattern match a list with one element ?
16:07:45 <glguy> [x] or (x:[])
16:07:47 <soLucien> I am trying to build a min and max function, but the first thing i have to do is make it work for one element
16:07:51 <soLucien> before makign it recurive
16:08:03 <soLucien> [x] is not working
16:08:19 <glguy> yikes
16:08:25 <kadoban> soLucien: What does "is not working" mean?
16:08:30 <soLucien> i have data Curve = Curve Point [Point] deriving (Eq, Show)
16:08:48 <soLucien> then i try to match [p] as a single point
16:08:53 <soLucien> a curve with a single point
16:08:56 <Koterpillar> show the code
16:09:14 <soLucien> minPoint :: Curve -> (Point -> Double) -> Double
16:09:20 <soLucien> minPoint [p] axis = axis p
16:09:28 <buglebudabey> something that utilizes min or max has to implement Ord, right?
16:09:37 <Koterpillar> well, [p] is a list of something, you want a Curve
16:09:42 <soLucien> where axis is pointX or pointY on the point
16:09:53 <Koterpillar> so minPoint (Curve _ [p]) = something
16:09:54 <soLucien> isn't curve an array of points?
16:10:08 <glguy> No, a curve is a distict type
16:10:15 <geekosaur> you broke the list apart so you need to match it as such
16:10:33 <soLucien> should i change the signature to minPoint :: [Point] -> (Point -> Double) -> Double
16:12:33 <buglebudabey> soLucien you can take advantage of the max/min maximum/minimum functions if you derive Ord for your datatype
16:12:39 <buglebudabey> or create an instance
16:12:41 <soLucien> i cannot
16:12:47 <soLucien> because it's on x or y axis
16:12:48 <ReinH> [p] matches a list (of one element). It does not match a Curve.
16:13:10 <soLucien> i cannot order points according to some rule
16:13:13 <ReinH> If you have a Curve, you need to pattern match on its constructor(s).
16:13:51 <Koterpillar> as for the signature, whatever seems convenient
16:15:29 <Darwin226> Hey. I have a class like this `class C1 a b | a -> b, b -> a`. Now I want a class like this `class C1 a b => C2 a`
16:15:46 <Darwin226> but GHC is not letting me do this. Saying b is not in scope
16:15:59 <Darwin226> What gives? I though the fundep would fix his issue
16:16:16 <prsteele> Darwin226: you might try associated types? I'm not that it will fix it, but it might
16:17:00 <Darwin226> prsteele: I mean that could work but then I have to chose one of those types to be in the head and the other to be returned from the type family
16:17:07 <Darwin226> I don't like that idea
16:17:14 <prsteele> fair  
16:17:58 <glguy> it's not much more arbitrary than deciding which goes in the first position and which in the second. (and might be the only way forward)
16:18:48 <siwica> To get familiar with Diagrams I reproduced a knight tour example. I can compile it but can produce any images.
16:19:02 <siwica> http://lpaste.net/206323
16:19:13 <Koterpillar> siwica: and you want it to only produce some images?
16:19:24 <siwica> ghc --make knight-tour.lhs
16:19:40 <siwica> ./knight-tour -o chessboard.png -w 400
16:19:56 <siwica> But the latter did not create a file
16:20:06 <siwica> Koterpillar: yes
16:20:38 <siwica> I don't even know how to debug this unfortunately
16:20:54 <Koterpillar> not familiar with diagrams, but what's even parsing -o and -w?
16:22:28 <siwica> knight-tour.lhs compiles into a binary that then can create images
16:22:43 <siwica> -o is the output name of the image and -w its width
16:23:18 <ReinH> Your main just returns a diagram, which doesn't do anything since the runtime ignores the return value of main
16:23:40 <ReinH> you haven't implemented anything that would write to a file
16:23:50 <Darwin226> glguy: I still want it bidirectional. How do I get that with associated types?
16:24:20 <siwica> ReinH: Ok, good point. Thank you!
16:24:34 <ReinH> siwica: you want to use something like mainWith, as the examples do
16:24:46 <siwica> ReinH: The original said '> main = mainWith (example :: Diagram B)' but that would not compile
16:24:56 <ReinH> Well, that's the thing you need to make compile
16:25:05 <glguy> Darwin226: with two associated types and a super class constraint relating them
16:25:07 <ReinH> Rather than doing something else which compiles but doesn't do anything
16:25:52 <siwica> '    Couldn't match type `IO (Diagram B)'
16:25:53 <siwica>                   with `QDiagram B (V B) (N B) Any'
16:25:53 <siwica>     Expected type: Diagram B
16:25:53 <siwica> '
16:26:06 <ReinH> @lpaste
16:26:06 <lambdabot> Haskell pastebin: http://lpaste.net/
16:26:13 <ReinH> Please use a pastebin for multiple lines
16:26:20 <siwica> sorry
16:26:32 <Koterpillar> siwica: rough guess: example >>= mainWith
16:27:59 <siwica> Koterpillar: perfect. This worked
16:29:40 --- mode: ChanServ set +o dibblego
16:29:43 --- mode: dibblego set -b *!*@107-147-70-64.res.bhn.net
16:29:50 <Darwin226> glguy: So something like `class a ~ F (G a) => C a` where F and G are my associated types?
16:29:57 --- mode: dibblego set -o dibblego
16:32:13 <Darwin226> Can I make associated types injective?
16:40:33 --- mode: ChanServ set -q *!*@107-147-70-64.res.bhn.net
16:52:27 <Darwin226> Yes I can. Great.
17:20:09 <cheater> is there any interesting abstraction over n-tuples that lets you generalize things like uncurry, arrows, etc? you'd think you could write a version of uncurry once and it'd work for all tuple sizes
17:20:44 <geekosaur> you'd think, but every tuple is a distinct type
17:21:19 <geekosaur> IIRC someone once did something with typeclasses but the result was almost as bad as the status quo
17:21:20 <cheater> sure but so are lists and trees and still we have functors
17:21:50 <geekosaur> they are recursive types. tuples are not
17:21:52 <Koterpillar> lists and trees are the same types regardless of size/length
17:22:32 <geekosaur> (a,b,c) has no relationship to (a,b), not even a recursive one the way [a,b,c] is a:[b,c] is a:b:c:[]
17:23:33 <cheater> [1, 2, 3] has no relationship to Tree (Leaf 1) (Leaf 2) either
17:25:31 <geekosaur> those are manageable as a separate typeclass for each type because they are both recursive; you don't need an instance for each size of each structure
17:25:47 <geekosaur> "yes you can do this. no it is not worth it"
17:26:17 <cheater> yeah that's crappy
17:26:26 <cheater> that's definitely not the kind of thing i was thinking about
17:27:03 <geekosaur> if you've ever looked at basic typeclasses like Eq, they have to have a separate definition for each tuple type (but only out to n=16 iirc because it's already unreasonable by then)
17:27:17 <prsteele> cheater: you might be able to do something by mimicking cons cells, e.g. instead of (a, b) and (a, b, c), ..., you have (a, b), (a, (b, c)), ...
17:36:42 <benzrf>     A 200-tuple is too large for GHC
17:36:43 <benzrf>       (max size is 62)
17:36:45 <benzrf>       Workaround: use nested tuples or define a data type
17:36:49 <benzrf> bullcrap
17:36:53 <benzrf> im gonna write my own compiler
17:37:22 <jpl> Famous last words... "I'm gonna write my own compiler"
17:38:20 <soLucien> if i want to create a max/min function in haskell, this is how i started
17:38:48 <soLucien> pointMax (Curve p c) axis = \ c -> axis c
17:39:05 <soLucien> i want this lambda to compare evrything with a value max
17:39:16 <soLucien> and assign it in case max < lambda value
17:39:19 <soLucien> is it possible ?
17:39:43 <prsteele> soLucien: can you back up a step? You have a Curve which is a nonempty list of... points in some vector space?
17:39:56 <soLucien> yes
17:40:08 <prsteele> soLucien: and you want to find the biggest/smallest point in the curve, for some definition of biggest/smallest? presumably along some dimension?
17:40:09 <soLucien> i want the max/min point on the x axis
17:40:19 <soLucien> and on the y axis
17:40:33 <soLucien> because i want to bound it inside a rectangular boz
17:40:35 <soLucien> box
17:41:03 <prsteele> ?hoogle maximumBy
17:41:04 <lambdabot> Data.List maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
17:41:04 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
17:41:04 <lambdabot> GHC.OldList maximumBy :: (a -> a -> Ordering) -> [a] -> a
17:41:14 <soLucien> i want to implement it myself
17:41:28 <prsteele> okay. have you seen
17:41:31 <prsteele> :t foldr
17:41:32 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:42:01 <prsteele> the foldr function will let you walk along a list and compute some summary value (in this case the max or min)
17:42:22 <soLucien> so what i have until now is http://pastebin.com/vWtC2H7v
17:42:31 --- mode: ChanServ set +o dibblego
17:42:32 --- mode: dibblego set -q *!*@107-147-70-64.res.bhn.net
17:42:40 --- mode: dibblego set -o dibblego
17:42:40 <soLucien> hmm can't i use lambdas ? .. or a foreach ?
17:42:56 <prsteele> you can use lambdas, sure, they're just un-named functions
17:42:57 <soLucien> i'm a beginner , so i would like to understand how to do this
17:43:01 <prsteele> :t map
17:43:04 <lambdabot> (a -> b) -> [a] -> [b]
17:43:07 <prsteele> is probably what you mean by foreach
17:43:07 <soLucien> before i start abusing the standard lib
17:43:49 <prsteele> soLucien: okay, if you want to do this with as little of the built-in functions as possible, I'd suggest by first writing a function with type `Curve -> [Point]`
17:44:20 <prsteele> that removes one layer of complexity -- you don't have a curve any more, just a list of points
17:44:23 <soLucien> i have that
17:44:25 <soLucien> toList
17:44:47 <prsteele> now, can you write a function with type `Point -> Point -> Ordering`?
17:44:53 <prsteele> :i Ordering
17:45:20 <prsteele> soLucien: Ordering has three constructors, LT, EQ, and GT representing less than, equal, and greater than
17:45:27 <prsteele> since lambdabot isn't responding
17:45:55 <geekosaur> lambdabot doesn't do :i
17:46:03 <prsteele> geekosaur: my bad, thanks!
17:46:19 <geekosaur> (output tends to be a bit large)
17:46:23 <soLucien> i can't for Point
17:46:30 <geekosaur> maybe if there were a sensible way to focus it...
17:46:31 <prsteele> soLucien: you'll eventually want two of these functions, one for 'max along x-axis' and one for 'max along y-axis'
17:46:45 <soLucien> i can do ordering on the x axis and ordering on y
17:46:51 <prsteele> soLucien: I assure you you can. try naming them `compareX` and `compareY`
17:47:06 <amalloy> is there an instance like this? alternatively, why is there not an instance like this? newtype Max a = Max a; instance (Bounded a, Ord a) => Monoid (Max a) where mempty = Max minBound; mappend (Max a) (Max b) | a<b = b; | otherwise = a
17:47:54 <amalloy> and likewise for Min of course, in the same way there are Any/All monoid wrappers for Bool
17:47:55 <prsteele> amalloy: you can use `comparing` from Data.Ord, and use the monoid instance for Ordering
17:48:39 <jle`> amalloy: your types exist in the semigroups package, but only have semigroup instances
17:48:43 <prsteele> soLucien: the key here is that writing a function of type `Point -> Point -> Ordering` isn't claiming to be a _universal_ ordering, just one particular ordering... you are free to write _more_ functions with that type
17:48:51 <jle`> oh wait
17:48:54 <jle`> no, they have Monoid instances too
17:49:08 <prsteele> soLucien: this is distinct from writing an Ord instance for Curve, which would imply only one ordering
17:49:09 <jle`> amalloy: yup, what you are describing is in the semigroups package, in Data.Semigroup
17:49:22 <amalloy> okay
17:49:25 <geekosaur> they arguably shouldn't since there isn't always a sensible mempty (of course maybe they ignored Float/Double)
17:49:36 <jle`> amalloy: actually, they are in base
17:49:41 <jle`> so you can import them now today
17:49:46 <cheater> geekosaur: yeah, i know Eq has separate defs for different tuple sizes
17:49:46 <jle`> no extra packages required :)
17:49:55 <soLucien> prsteele so write my bubble sort for x and y axis ?
17:50:04 <jle`> @let import Data.Semigroup
17:50:06 <geekosaur> as of ghc8 semigroups is partially imported into base iirc?
17:50:06 <lambdabot>  Defined.
17:50:22 <prsteele> soLucien: I mean, you _could_ get the min/max by sorting, but that's not how you'd find the max of a list yourself, is it?
17:50:24 <jle`> > foldMap Max [1,10,8,11,-3]
17:50:28 <lambdabot>  error:
17:50:28 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M869430437368...
17:50:28 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:50:36 <jle`> > foldMap Max [1,10,8,11,-3] :: Max Int
17:50:39 <lambdabot>  Max {getMax = 11}
17:50:48 <jle`> it truly is the future
17:50:49 <soLucien> no, i'd iterate through it once
17:51:05 <soLucien> comparing with a temp variable
17:51:12 <soLucien> is it possible to do this in haskell ?
17:51:16 <prsteele> soLucien: good, so no bubble sort here. But yes, you'll be writing two functions with that signature, one for x axis and one for y axis
17:51:25 <jle`> > mempty :: Max Int
17:51:27 <prsteele> soLucien: yes, you want a 'fold'
17:51:27 <lambdabot>  Max {getMax = -9223372036854775808}
17:51:30 <prsteele> :t foldl
17:51:31 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
17:51:32 <prsteele> :t foldr
17:51:33 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:51:35 <jle`>  ^ amontez 
17:51:38 <jle`> * amalloy 
17:51:42 <jle`> sorry
17:52:05 <soLucien> okay i'll use fold
17:52:21 <soLucien> it seems like a very important operation
17:52:37 <soLucien> i've used maximum and minimum function, and i failed the assignment
17:52:37 <prsteele> soLucien: in particular check foldr1, which doesn't need a default argument but requires a nonempty list... which you know you have
17:52:39 <lpaste> glguy pasted “generic curry” at http://lpaste.net/206433
17:52:47 <glguy> cheater: check that out
17:53:19 <prsteele> soLucien: because maximum/minimum require an Ord instance, and you can only have one Ord instance per data type (but you could define newtypes for different instances...)
17:53:23 <soLucien> because they were partial functions
17:53:45 <soLucien> how was i to know that after 5 days of working with the language
17:54:05 <prsteele> soLucien: I mean, maximum is a partial function -- oh you mean a *human* objected to using a partial function?
17:54:17 <prsteele> soLucien: foldr1 is partial as well then, use foldr
17:54:22 <soLucien> yes
17:54:34 <prsteele> (although provably non-partial for your use case...)
17:54:54 <soLucien> the TA that corrected my assignment failed me
17:55:05 <soLucien> because he could construct a empty curve
17:55:16 <soLucien> and i was usin partial functions
17:57:30 <soLucien> Problem:
17:57:30 <soLucien>   It appears that you are using these functions:
17:57:30 <soLucien>     maximum, minimum, tail
17:57:30 <soLucien>   These are partial functions. We advise against using them, since they
17:57:30 <soLucien>   may lead to undefined behaviour. Consider implementing them yourself,
17:57:31 <soLucien>   in a non-partial way.
17:57:35 <soLucien> sorry
17:57:44 <soLucien> for the wall of text
17:57:56 <soLucien> thaught it's going to be one line
17:58:12 <monochrom> maximum is a problem for empty lists, just watch out for that.
17:58:20 <EvanR> they are total if you have appropriate assumptions on the domain satisfied, which haskell wont enforce for you
17:58:41 <EvanR> manual dependent types
17:58:42 <Eduard_Munteanu> That isn't quite *undefined* behavior.
17:58:57 <prsteele> unfortunately a bunch of functions in the standard lib are partial. head, tail, maximum, minimum, fold{l,r}1...
17:59:08 <shachaf> maximum is a problem for unbounded types
17:59:09 <EvanR> the behavior is to return bottom, therefore its undefined ;)
17:59:15 <jle`> :p
17:59:34 <jle`> i wouldn't mind if all of those partial functions were taken out of prelude
17:59:46 <jle`> and let's get foldl out of there too while we're at it
17:59:47 <EvanR> and replaced with?
17:59:58 <jle`> and requiring users to import them explicitly
17:59:58 <shachaf> I'm partial to them, myself.
18:00:07 <jle`> heh heh
18:00:17 <prsteele> explicit imports would be nice
18:00:19 <Eduard_Munteanu> I mean maximum fails spectacularly for [], which is a lot nicer than having implementation-specific outputs.
18:00:20 <jle`> but yeah, that's what we already do with, say, fromJust
18:00:21 <prsteele> import Prelude.Partial
18:00:33 <EvanR> theres so much importing already ;_;
18:01:14 <EvanR> if you have more imports than code, seems lop sided
18:01:31 <soLucien> okay so let's say i don't want to use any partial stuff, no folds, and i want to implement maximum
18:01:33 <cheater> what's the best way to only depend on a package and create a binary in my .cabal if i am building tests?
18:01:37 <soLucien> seems fold is also partial
18:01:47 <soLucien> can i do it by pattern matching?
18:02:03 <Eduard_Munteanu> Sure.
18:02:13 <prsteele> foldr isn't partial unless the list is infinite...
18:02:17 <Eduard_Munteanu> foldl/foldr are ok too
18:02:41 <EvanR> foldr isnt necessarily partial when the list is infinite, foldl is
18:02:52 <prsteele> did I have that backwards?
18:03:13 <monochrom> No, you said it right.
18:03:16 <Eduard_Munteanu> In the general case.
18:03:27 <monochrom> Just that people always feel like adding more and more patches.
18:03:44 <EvanR> it might be partial when the list is finite!
18:04:25 <Eduard_Munteanu> > foldr const 0 [1..]
18:04:27 <lambdabot>  error:
18:04:27 <lambdabot>      Ambiguous occurrence ‘const’
18:04:27 <lambdabot>      It could refer to either ‘Data.Function.const’,
18:04:46 <EvanR> handy
18:04:48 <Eduard_Munteanu> > foldr Data.Function.const 0 [1..] -- ??
18:04:50 <lambdabot>  1
18:07:43 <benzrf> > foldl Data.Function.const 0 [1..]
18:07:55 <lambdabot>  mueval: ExitFailure 1
18:13:20 <soLucien> !paste
18:13:32 <soLucien> !pastebin
18:13:42 <prsteele> http://lpaste.net/new/haskell
18:13:50 <prsteele> not sure the incantation to find that automatically
18:13:53 <prsteele> ?paste
18:13:53 <lambdabot> Haskell pastebin: http://lpaste.net/
18:14:04 <soLucien> http://lpaste.net/5521317601608728576
18:14:07 <EvanR> @where paste
18:14:07 <lambdabot> Haskell pastebin: http://lpaste.net/
18:14:13 <soLucien> this is very incorrect
18:14:21 <soLucien> how do i fix it ?
18:15:39 <prsteele> a more specific question might help, soLucien . Are you getting a compiler error you can't parse?
18:15:41 <glguy> soLucien: what are you using to learn Haskell syntax?
18:15:56 <soLucien> visual studio code
18:16:17 <soLucien> i just don't know how the recursive logic should be for my max function
18:16:53 <soLucien> so i've set the base case  : when there's an element, return it
18:16:56 <cheater> this contains a good place to rip off a test suite cabal http://hackage.haskell.org/package/hashable-1.2.4.0/hashable.cabal
18:17:17 <glguy> cheater, did you see the generic curry?
18:17:55 <Eduard_Munteanu> soLucien, max :: [a] -> a   can only be partial
18:18:06 <prsteele> soLucien: you use the term `max`, where does that come from? (Note: `max` is a built-in function, so if you define a variable with that name you are shadowing it)
18:18:27 * hackagebot servant 0.9 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.9 (SoenkeHahn)
18:18:29 * hackagebot servant-server 0.9 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.9 (SoenkeHahn)
18:18:31 * hackagebot servant-client 0.9 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.9 (SoenkeHahn)
18:18:33 * hackagebot servant-docs 0.9 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.9 (SoenkeHahn)
18:18:35 * hackagebot servant-foreign 0.9 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.9 (SoenkeHahn)
18:18:39 <soLucien> now i want to say : when there are more than one element, recurse
18:18:40 <Eduard_Munteanu> Er, max :: Ord a => [a] -> a
18:18:56 <soLucien> returning the larger element
18:19:06 <VitorCBSB> :t maximum
18:19:08 <lambdabot> (Foldable t, Ord a) => t a -> a
18:19:18 <prsteele> soLucien: the pattern (x:xs) will match an element, and then the rest
18:19:42 <prsteele> soLucien: (x:xs) could match to xs == [], but you already have the single element case
18:22:45 <cheater> when i run cabal test, it says my dependencies have not been met. how do i force cabal to install them? i normally do "cabal install" to do that, but the dependencies (QuickCheck) only exist for the test suite in the .cabal's test-suite section.
18:23:07 <prsteele> cabal install --enable-tests I think
18:23:10 <dcoutts> cheater: cabal install --only-dependencies --enable-tests
18:23:18 <glguy> cabal install --dep --enable-tests
18:23:27 * dcoutts notes that with cabal new-build this "just works" without fussing
18:23:35 <cheater> oh, ok, thanks guys
18:23:37 * hackagebot servant-js 0.9 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.9 (SoenkeHahn)
18:23:52 <cheater> glguy: i haven't seen the generic curry.
18:24:08 <prsteele> does anyone know the rules for hackagebot? Does it choose randomly to display packages, or does it list them when they're updated? or something else?
18:24:08 <cheater> let me scroll up while ghc is building the universe
18:24:44 <Koterpillar> prsteele: updated
18:24:50 <prsteele> Koterpillar: thanks
18:25:25 <glguy> prsteele: lists on upload
18:25:56 <cheater> glguy: that's pretty cool. i won't pretend to understand the generics code at first glance.
18:26:31 <cheater> is uncurry simple as well? is there something like :*: for function types?
18:27:29 <glguy> uncurry would be the same sort of thing, you wouldn't use the generic representation of the function
18:28:07 <glguy> you'd still use the generic representation of the product type
18:28:25 <cheater> oh
18:28:48 <cheater> i kinda find it difficult to imagine :)
18:28:58 <cheater> but that's because i'm not that great with generics :)
18:29:11 <cheater> pretty cool code though
18:29:43 <boccato> Hi, I had some OOM problems installing stack and haskell in a server. To uninstall stack, is it sufficient to delete the .stack/ directory?
18:30:22 <Koterpillar> boccato: how did you [try to] install it?
18:31:33 <boccato> I used this "wget -qO- https://get.haskellstack.org/ | sh".
18:32:18 <prsteele> that is vaguely terrifying
18:32:28 <boccato> Sorry, I think I expressed myself wrong. Stack installed, I got out of memory while setting up a haskell environment using lts-7.0
18:32:38 <Koterpillar> and what do you want to do now?
18:32:55 <boccato> just remove everything stack downloads
18:33:08 <systemfault> These "please paste some terminal commands" installers scare me...
18:33:12 <lpaste> glguy revised “generic curry”: “generic curry and uncurry” at http://lpaste.net/206433
18:33:13 <boccato> I am almost certain it puts everything on .stack/
18:33:14 <glguy> cheater: 
18:33:16 <mgsloan> prsteele: That's a pretty normal thing to do
18:33:22 <Koterpillar> boccato: then yes, it's ~/.stack
18:33:24 <mgsloan> Consider that TH can do whatever it wants to your computer
18:33:32 <boccato> I know... but it is a server that is just for testing things.
18:33:41 <mgsloan> and realize that every time you are building haskell packages, you are executing random code from hackage
18:33:49 <mgsloan> So it is delusional to be afraid of "wget ... | sh"
18:33:53 <mgsloan> Or rather
18:33:54 <kadoban> systemfault: They're not really any worse than a lot of other installers ... pretty much anything other than "install from your OS's package manager" really.
18:34:03 <mgsloan> it is delusional to be afraid of that but not othe rthings :)
18:34:06 <mgsloan> Right
18:34:07 <jmcarthur> It's inconsistent, at least.
18:34:10 <mgsloan> Yes
18:34:26 <mgsloan> Better term, thanks jmcarthur 
18:34:45 <boccato> I am usually a bit delusional, lol.
18:34:53 <boccato> @Koterpillar thanks
18:34:53 <lambdabot> Unknown command, try @list
18:35:01 <prsteele> I hadn't considered TH to be (potentially) harmful. I take it then that TH has access to IO? I've only ever used it via things like lens   
18:35:40 <kadoban> prsteele: TH can do arbitrary IO, yeah.
18:36:05 <prsteele> _in_teresting... okay I suppose that's potentially as harmful as wget ... | sh
18:36:20 <prsteele>  potentially as -> as
18:36:37 <kadoban> Yes. It's why I'm pretty wary of using random haskell packages, I always check the code.
18:36:44 <kadoban> Which is ... annoying.
18:36:53 <mgsloan> One of the points of safe haskell is disallowing stuff like TH
18:37:11 <mgsloan> I wish we could restrict TH to a more semantic set of actions like "can read files from package subdir"
18:37:15 <prsteele> I was just googling that before I asked an easily-googlable question
18:37:24 <mgsloan> There's a nice security research paper in this idea maybe :)
18:37:31 <cheater> glguy: heh is it that simple
18:37:36 <cheater> nice!
18:39:03 <mgsloan> I mean really all you need is a capabilities system, or perhaps reuse the UCSD work on labeled IO, or similar
18:40:08 <prsteele> how easy would it be to e.g. call `makeLenses ''Foo`, dump the generated haskell code, replace makeLenses with the generated code, and then remove TH so you can mark your module as safe?
18:40:52 <dfeuer> prsteele, you certainly won't get anything very maintainable that way.
18:41:01 <geekosaur> I think people have done this? but it's not maintainable
18:41:10 <geekosaur> there was also zeroth but that bitrotted iirc
18:41:24 <dcoutts> mgsloan: and there's a dozen or more other places you'd need to nail things down to make building packages untrusted safe
18:41:32 <prsteele> I've seen comments like "It's easy to just write lenses here..." so I thought maybe the gen'd code would be fairly readable
18:41:47 <glguy> You'd want to make sure that the package didn't have any code in it
18:41:51 <glguy> so that it didn't attack you at runtime
18:42:04 <soLucien> nailed it http://lpaste.net/5521317601608728576
18:42:09 <dfeuer> glguy, any code in it?
18:42:27 <jonored> How much TH actually needs IO?
18:42:29 <dcoutts> Setup.hs scripts, {-# OPTIONS_GHC -F #-}, any other potentially-trickable pre-processors
18:42:32 <prsteele> soLucien: nice!
18:42:41 <soLucien> thanks a lot
18:42:49 <mgsloan> dcoutts: Right, like Setup.hs for one
18:42:57 <mgsloan> That old thorn in the tooling's side
18:43:15 <glguy> Sure, the package could have malicious definitions in it, maybe the containers implementation not only stores key-value pairs but it also uploads private date to the pastebin?
18:43:20 <prsteele> soLucien: so now that you have an answer... you can make it even _less_ partial by writing a function that carries around the incumbent max as a parameter
18:43:22 <glguy> TH is a red herring
18:43:31 <dcoutts> {-# OPTIONS_GHC #-} can be persuaded to run external pre-processors and load compiler plugins
18:43:41 <prsteele> soLucien: pointMax' is partial, it doesn't handle the [] case. This is fine, since you only call it with a non-empty list, but...
18:43:47 <mgsloan> Good point glguy, code is meant to be executed, so there is intrinsically a matter of trust
18:44:07 <dcoutts> mgsloan: that one is comparatively simple, only allow as "safe", packages using build-type: Simple.
18:44:20 <VitorCBSB> While we're at it, this is something that has always puzzled me. What's the purpose of the Setup.hs file? It always seems to be main = defaultMain or something like that.
18:44:30 <dcoutts> mgsloan: but yeah, in general it's a game of whack-a-mole
18:44:37 <soLucien> prsteele how could i do that ? Carry a parameter around
18:44:38 <mgsloan> dcoutts: Unfortunately, it is very hard to write anything that's truly useful that's also safe
18:44:46 <mgsloan> sure, I'm not saying it's easy
18:44:51 <mgsloan> Just that it is interesting
18:44:54 <soLucien> should i add it to the function signature ?
18:45:09 <mgsloan> I don't think Haskell is the right place to solve it.  Maybe solve it by 2050 or something
18:45:14 <dcoutts> mgsloan: I think we agree, it's not a very practical thing to try and achieve, and we might not like if we did :-)
18:45:32 <cheater> is there a way to make test-framework output colourised?
18:45:39 <mgsloan> Probably just need sandboxed execution for everything
18:45:44 <mgsloan> Oh hey, like stack's docker support ;)
18:45:56 <dcoutts> VitorCBSB: to allow non-trivial packages to do extra random stuff when configuring / building. It's the general get-out for customisation.
18:46:21 <geekosaur> VitorCBSB, go look at ghc2hs's Setup.hs
18:46:52 <geekosaur> there are other packages that do simple things in it, but most packages can and do just use defaults
18:47:23 <VitorCBSB> geekosaur: You mean gtk2hs? Couldn't find a ghc2hs on a quick Google search.
18:47:26 <geekosaur> (tl;dr: gtk2hs's Setup.hs preprocesses the gtk C source to Haskell definitions)
18:47:33 <geekosaur> sorry yes
18:47:42 <geekosaur> thinkoed :/
18:47:47 <geekosaur> or something
18:48:25 <dcoutts> mgsloan: so the container only has access to the packages being built, and cannot reach the internet to exfiltrate your code? :-)
18:48:27 <prsteele> soLucien: http://lpaste.net/206486
18:48:46 <mgsloan> dcoutts: You know the answer to that
18:48:47 <cheater> when using the quickcheck provider for test-framework, how can you use something like ==> ?
18:48:51 <dfeuer> Another problem is that some unsafe features are *really useful*.
18:49:12 <cheater> i would like to test a property that only takes positive integers.
18:49:34 <prsteele> soLucien: ... and change my Integer's to Double's to make this easy to implement  
18:50:04 <dfeuer> When you write a bunch of code and you want it all to be fast, it's fairly likely that at *some* point you'll want unsafeCoerce, unsafePerformIO, reallyUnsafePtrEquality#, etc.
18:50:06 <dcoutts> mgsloan: I don't, but I assume the containers are for reproducibility and not for security (which is perfectly sensible)
18:50:11 <mgsloan> Yep
18:50:35 <VitorCBSB> geekosaur: I see it now. Thanks for the help.
18:51:20 <dfeuer> And both unsafeCoerce and unsafePerformIO are pretty much essential for certain low-level library work.
18:51:51 <prsteele> cheater: I know there are property modifiers, but I generally just write a newtype and an arbitrary instance for things like that. newtype PosInt = PosInt Integer; instance Arbitrary PosInt ...
18:51:52 <mgsloan> But with a concerted effort we could take what we have and upgrade it to the point where the trusted components are relatively little (container implementation, our security implementation, kernel, computer hardware, etc)
18:52:09 <mgsloan> But buildtime security is not a current priority of stack, just a future dream
18:52:29 <mgsloan> You can get execution time security via things like kubernetes or docker-compose
18:54:04 <mgsloan> So we are pretty close to being in an ideal world, without too much effort
18:54:24 <mgsloan> So I backpedal, as usual we have a habit in Haskell of reaching for the complex solution, particularly the more traditional style
18:54:34 <mgsloan> We have a very pragmatic approach of adopting non haskell tools when appropriate
18:54:58 <dcoutts_> mgsloan: oh I agree, this is a case where OS facilities make sense, plus securing the package sources
18:55:31 <mgsloan> How's the progress on that going, btw?  Our solution is working swimmingly, but hackage is still a potential source of vulnerability
18:55:44 <mgsloan> Also, you guys screwed up stack support by breaking SSL, IIRC
18:55:51 <mgsloan> Sorry I shouldn't say it that way
18:55:53 <mgsloan> My bad :)
18:56:05 <dcoutts_> mgsloan: well the stack mirror now uses hackage-security so it's now secured in the same way cabal is
18:56:07 <mgsloan> Dunno if you have anything to do with that :) !
18:56:21 <soLucien> prsteele thanks a lot !
18:56:28 <dcoutts_> mgsloan: yeah, cockup that got resolved a few hours later
18:56:41 <mgsloan> Oh good, I only saw the screwup not the resolution
18:56:52 <mgsloan> That's fast turnaround, thanks!
18:56:53 <dcoutts_> it wasn't breaking SSL, it was breaking basic auth over SSL
18:57:09 <dcoutts_> due to proxy mis-configuration
18:57:39 <mgsloan> I see!  Well that is more understandable than a Haskell code error orso.  Devops is quite a challenge
18:58:15 <dcoutts_> mgsloan: so yes, now cabal and the stack mirror don't need to rely on SSL (which was incomplete anyway between the CDN and origin server)
18:58:40 <glguy> Speaking of stack and hackage, could stack do something to check that stub .cabal files have been filled out before uploading them?
18:59:23 <slack1256> not haskell-specific. If you have good concurrency primitives (Mvars, TVars, etc) why would you still use the OS IPC mechanism? (thinking unix domain sockets)
18:59:36 * geekosaur has already seen one stubbed in a way that would be difficult to spot
18:59:50 <grantwu> slack1256: How would you communicate between processes?
18:59:58 <geekosaur> slack1256, the Haskell primitives work between threads, not processes
19:00:01 <benzrf> is there something like a node-labelled tree zipper but where it's efficient to zip to a node by its label
19:00:31 <dcoutts_> mgsloan: the remaining step is integrating package signing so we're not just securing the conduit
19:00:54 <glguy> Lots of stack users don't seem to realize they're uploading packages that haven't been configured with the package's name or url or email adddress or description, etc
19:01:14 <dcoutts_> glguy: doesn't hackage reject those?
19:01:23 <glguy> Is that a new feature?
19:01:27 <geekosaur> but Ive already seen one which looks incompletely unstubbed in a way that might be difficult to determine
19:01:43 <geekosaur> (i.e. a partially unstubbed github url)
19:01:52 <mgsloan> dcoutts_: We have our own package signing implementation based on gpg
19:02:00 <mgsloan> It's already used by stack upload
19:02:08 <EvanR> slack1256: theres cloud haskell which is supposed to work between processes
19:02:16 <EvanR> like erlang
19:02:17 <glguy> dcoutts_: Most recent announcement 2016/16.09.19:04:17:37 * hackagebot vector-split 1.0.0.0 - Initial project template from stack  https://hackage.haskell.org/package/vector-split-1.0.0.0 (fho)
19:02:26 <mgsloan> I think for the last 2 released versions
19:02:43 <glguy> That or "Author name here" is a prolific member of the community
19:02:46 <kadoban> I imagine that the templates shouldn't actually be filling in bogus descriptions like that.
19:02:50 <glguy> and has a lock on example.com email addresses
19:02:53 <geekosaur> as for why you'd use processes instead of threads: (1) security isolation (2) to make it easier to swap out one component without having to swap out or restart the whole thing
19:02:59 <kadoban> Maybe a commented out one, so it gets rejected?
19:03:01 <slack1256> grantwu: if you have to communicate with an daemon then yes it makes sense. But the stories of C programming say that usually they decomposed a problem in different processes and comunicated by IPC (shared memory concurrency was not common)
19:03:06 <dcoutts_> glguy: hmm, ok we should add an upload check on synopsis
19:03:49 <geekosaur> keep in mind that C for a long time did not have threads, and even now that it has them they're painful enough to use that separate processes are still the rule for many things
19:03:53 <glguy> I count 76 hackagebot announcements so far of the Initial project template from stack
19:04:11 <slack1256> which connects with the geekosaur question, if you have thread (and thus shared memory space) but also GC and explicit mutable variables the problem the process vs thread possed seem arcaic
19:04:16 <dcoutts_> mgsloan: yeah I know but it's not quite solving the same problem
19:04:16 <EvanR> forking a process and using stdio to communicate line by line works
19:04:28 <geekosaur> security isolation is not archaic
19:04:31 <mgsloan> glguy: Good advertising, huh?  (not the intention ;) )
19:04:31 <EvanR> thats how im doing cocoa
19:04:42 <dcoutts_> mgsloan: at least at the moment. It's possible with gpg + extra metadata.
19:04:54 <geekosaur> it just isn't understood by far too many programmers :/
19:04:57 <slack1256> geekosaur: still in 2016 threads are harder than processes? I though the pthreads wars were over...
19:05:02 <mgsloan> To us it is adequately solving the security problem
19:05:11 <geekosaur> pthreads is a painful interface
19:05:29 <geekosaur> even haskell's easy to use threads led to the async package
19:05:37 <geekosaur> and C ... isn't really up to that level of abstraction
19:05:39 <grantwu> slack1256: I think it depends on what you are trying to do.
19:05:46 <slack1256> security isolation as a problem is not arcaic, thinking that separate memory address as an answer I think it is
19:06:06 <EvanR> if you had a programming language with security isolation in mind, mayb
19:06:07 <slack1256> grantwu: yeah, I don't have a good background on the problems they where trying to solve
19:06:20 <EvanR> theres a new language monte with that in mind
19:06:22 <grantwu> If you are writing your own application, then in 2016 in languages that support it well I think threading over forking can be a big win
19:06:24 <mgsloan> I am not drenched in security lore, however, I do not see why package security is such a hard problem
19:06:29 <geekosaur> it's ot just separate address spaces, it's also attack surface
19:06:46 <slack1256> ot?
19:06:47 <geekosaur> and privilege separation, which is far more significant
19:06:50 <geekosaur> *not
19:06:52 <dcoutts_> mgsloan: it is a little surprising
19:06:53 <slack1256> ah
19:07:01 <dcoutts_> mgsloan: how tricky it is I mean
19:07:02 <mgsloan> It's a hard problem if you want to solve it perfectly, but it is not hard if you want to solve it "well enough"
19:07:23 <mgsloan> Solutions are always along the continuums of bad to perfect, and non-existent to existent
19:07:28 <mgsloan> We prefer Good and Existent
19:07:42 <EvanR> well the security status quo can be "good enough" be definition
19:07:43 <slack1256> !! that is a angle I haven't thought, different process can have... different priviledges 
19:07:50 <ReinH> Lawful Evil for me
19:08:03 <grantwu> slack1256: Also consider systems written in multiple programming languages
19:08:26 <mgsloan> EvanR: Right, but there is engineering and there is theory.  Haskell would love them to be one and the same, but engineering practicality means that it lags the cutting edge of academia
19:09:30 <dcoutts_> mgsloan: that's true it is a continuum, but one still has to be fairly careful or you end up not meeting the "good enough" expectations, e.g missing attacks that go round your road-blocks
19:09:31 <mgsloan> Also, btw, dcoutts_, I am totally not up to date on emails and recent community stuff.  I've been preparing for + away at + coming back from Burning Man, so have a huge backlog of github / email / reddit
19:09:42 <mgsloan> Not that it matters!
19:10:08 <dcoutts_> mgsloan: ooh, fun :-)
19:10:18 <mgsloan> dcoutts_: OK, but we need something now that fixes the problem.  Think also of the temporal coverage and protection
19:10:25 <mgsloan> Right now we are completely unprotected!
19:10:28 <mgsloan> Unless you use stack
19:10:37 <mgsloan> Even then most people aren't uploading that way
19:10:47 <mgsloan> Probably, not sure actually of the stats there
19:10:58 <grantwu> slack1256: Microkernels are also something that is an interesting thing to consider
19:11:11 <slack1256> grantwu: yes, althought if I had to solve a new problem from scratch, I wouldn't decompose it using the OS IPC mechanism unless different parts had different priviledges (that where enforced by the OS)
19:11:17 <mgsloan> So like, existing is a feature.  Delaying is a bug
19:11:18 <dcoutts_> mgsloan: well, if you mean uploading via ssl then cabal and stack have been doing that for some time
19:11:25 <mgsloan> I mean like package signing
19:11:32 <grantwu> slack1256: Yeah, I agree
19:11:33 <slack1256> grantwu: actually, I read an article on lwm discussin microkernel and then my doubt surged
19:11:43 <dcoutts_> mgsloan: which only covers a small subset of packages
19:11:49 <mgsloan> gpg already provides network of trust identities for contributors
19:11:52 <grantwu> slack1256: At least, for Haskell
19:12:19 <mgsloan> I don't see why Haskell needs to reinvent the wheel for security
19:12:27 <mgsloan> The more code you right, the more likely there are to be bugs
19:12:28 <geekosaur> hah, they're actually thinking about it now?
19:12:42 <mgsloan> *write
19:12:44 <grantwu> slack1256: I mean, that is lwn
19:12:59 <SShrike> What's a good example of a Haskell library that wraps a RESTful API? I'm looking at writing a Haskell wrapper for the Matrix (think like Slack, Gitter, or IRC) Client-Server API, for a first project.
19:13:05 <mgsloan> The more code you "right", the more "wrong" there's gonna be to fix, unless you use some trusted existing component like gpg
19:13:06 <ReinH> Reinventing the wheel is generally not a good way to make yourself secure
19:13:08 <slack1256> yeah, the thing is that haskell is my first language, so it is alien to me the idea of comunicating programs through the explicit IPC (instead of reusing a library)
19:13:26 <mgsloan> Exactly, ReinH has it!  We need to trust code that's already been in use for a decade or more
19:13:30 <mgsloan> And that's what we are doing.
19:13:46 <EvanR> haskell can do better, lets prove that a system is immune to security flaws up to byzantine tolerance
19:13:50 <ReinH> While for an Erlang programmer this is a totally natural thing
19:13:51 <dcoutts_> mgsloan: there's certainly something to that, but note that the security policy you're after doesn't fit the gpg web-of-trust, so you need extra stuff already
19:13:51 <grantwu> mgsloan: Sorry I haven't really been following the conversation at all
19:14:02 <grantwu> mgsloan: What is up with package security?
19:14:26 <slack1256> I meant lwn.net . that linux site news
19:14:27 <mgsloan> Well, right now stack has a solution. dcoutts_ is the expert on the status of cabal's solution
19:14:55 <mgsloan> dcoutts_: Well, you are convinced that we're after what you have proposed, but I don't think we are
19:15:09 <mgsloan> Well maybe not convinced, but that statement sounds like it has that assumption
19:15:33 <mgsloan> It's "You don't realize you don't have what you want.  I know what you want"
19:15:35 <grantwu> slack1256: I know
19:16:00 <grantwu> Linux chose not to go the microkernel route
19:16:01 <mgsloan> Well, we are pretty happy with what we have, and wish that cabal would adopt it so we can put this issue behind us and stop wasting valuable haskeller time
19:16:10 <dcoutts_> mgsloan: what you've proposed requires a bunch of extra metadata and using gpg to check chains of trust that don't match a web of trust
19:16:11 <mgsloan> But if you like the problem, feel free to keep at it!
19:16:21 <dcoutts_> mgsloan: unless it's been simplified since
19:16:35 <mgsloan> I did not do the implementation dcoutts_ , but I trust my coworkers did something quite reasonable
19:16:39 <grantwu> So, I am unsurprised lwn thinks microkernels are silly
19:17:03 <geekosaur> that's a long time Linus-ism
19:17:04 <mgsloan> And I am familiar with the basics
19:17:25 <mgsloan> dcoutts_: I would love to see a direct criticism of our implementation
19:18:17 <geekosaur> (*very* long time, it was one of the reasons Linus wrote his own OS instead of working with Minix which is a microkernel)
19:18:58 <slack1256> it wasn't an article poking fun at microkernels. It was one discussing different new IPC mechanism (kdus, better posix queues (0MQ ?)) and how microkernels used to have "message passing"
19:22:01 <geekosaur> there's a difference, the kernel itself is still monolithic
19:22:57 <grantwu> I find this pretty funny https://lkml.org/lkml/2015/6/23/657
19:24:44 <geekosaur> that sounds like linus, all right >.>
19:25:37 <geekosaur> you think that's funny, you should read his reaction to poettering trying to push init auto-restart into the kernel to work around systemd bugs
19:27:15 <slack1256> yeah. I also think (k)dbus shouldn't be used if you really want performance. They are used for the versatility but that can be donde un userspace
19:27:30 <slack1256> s/donde/done/
19:28:10 <dcoutts_> mgsloan: any idea where the new sig-archive is?
19:33:14 <mgsloan> dcoutts_: https://github.com/commercialhaskell/sig-archive
19:37:25 <dcoutts_> mgsloan: oh thanks, it's in the test branch. Sorry for the confusion.
19:41:37 <prsteele> so type families and type operators are awesome
19:42:14 <prsteele> I can write (x <<< y) => ... to indicate that the type variable x must be at most y, where x and y are type-level Nats
19:45:43 <EvanR> x ≤ y → in agda, where x and y are regular nats ;)
19:46:12 <prsteele> well then. This took me a good two evenings to figure out in Haskell :)
19:46:29 <slack1256> yes, but remember that type families are not type level function, they are "type level functional relations" which is a little different semantically
19:47:04 <prsteele> well I use this along with ConstraintKinds to generate an (infinite) family of instances
19:48:37 <EvanR> erm... functional relations
19:49:35 <prsteele> ... I think I mean instances. I have a class IsAtMost x y which I recursively define with reasonable base cases, and then let x <<< y expand to IsAtMost x y
19:51:17 <EvanR> is the difference that you can expect to go backwards with a relation?
19:52:00 <prsteele> I go backwards by checking constraints on the class
19:52:25 <slack1256> the diference is that a function is defined on the whole domain, ie forall x in the domain exist only one x' such that the function f(x) = x'
19:52:52 <slack1256> the functional relation tells you the you can have (x ~ x') for some x then that x' is unique
19:53:09 <slack1256> yet you could have a x not related to *any* element
19:53:46 <slack1256> (which is why typefamilies get stuck at reduction on undefined cases)
19:54:08 <lpaste> prsteele pasted “<<<” at http://lpaste.net/206582
20:00:36 <EvanR> oh right
20:01:59 <EvanR> describing type families that way in the first place would have saved me some brain trauma back when i was trying to grok em
20:02:26 <EvanR> its just a functional relation between types whats the problem
20:02:55 <slack1256> actually that is the problem, we wanted to do "function programming at type level"
20:03:12 <slack1256> no transitivity checking between functional relations
20:04:42 <slack1256> yeah, they ought to put empasis on that. 
20:06:19 <slack1256> the big problem is type families that take kind * as an argument, because it has infinite inhabitants. With DataKinds and specific kinds you can really do "type level function programmin"
20:08:45 <EvanR> pattern matching on types of kind * heh
20:08:50 <cheater> hi
20:08:58 <cheater> i've made an implementation of pollard's rho discrete log and it seems to work for the example in wikipedia but it doesn't seem to work for any other numbers... could someone help me debug it please? the code is here: https://bitbucket.org/cheater/pollard-rho-simple/overview
20:09:01 <EvanR> what a world
20:18:30 * hackagebot hOpenPGP 2.5.3 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.5.3 (ClintAdams)
20:18:32 * hackagebot hopenpgp-tools 0.19.4 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.19.4 (ClintAdams)
20:45:00 <jle`> prsteele: why don't you just call IsAtMost (<<<) ?
20:45:13 <jle`> oh i see the voidness
20:45:24 <prsteele> although I haven't gone back to see if I can get rid of that
20:45:44 <prsteele> I was just happy to get something working :)
20:48:59 <jle`> iktf :)
20:58:39 <lispy> cheater: when you tried other examples did you change n?
20:58:53 <lispy> cheater: because n' needs to be a prime not just n+1
21:03:45 <lispy> cheater: I don't see anything obvious wrong with your program compared to the C version
21:08:33 <lispy> cheater: but I'm not sure the C code matches the algorithm.
21:09:07 <lispy> In particular, It's not clear to me that a_{2i} and b_{2i} are calculated the same way in both
21:10:09 <begriffs> What's the most convenient way to pull a path out of an aeson object and verify that it equals another object? For instance to check that `{"a":{"b":1}}` has value `{"b":1}` at key "a"? (Except traversing deeper than just one key)
21:11:09 <begriffs> Something tells me lens...
21:12:02 <Koterpillar> "X except traversing deeper than one Y" == foldr X
21:18:32 * hackagebot legion-extra 0.1.0.0 - Extra non-essential utilities for building legion applications.  https://hackage.haskell.org/package/legion-extra-0.1.0.0 (taphu)
21:18:34 * hackagebot legion 0.4.0.0 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.4.0.0 (taphu)
21:18:41 <begriffs> Perhaps some combo of (.:?) and (>>=) can help me get into an aeson object without lenses
21:20:37 <amalloy> :t foldM
21:20:38 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
21:21:00 <Nadeem> how to use tpb to display osd for volume , brightness, etc on thinkpad with debian??
21:21:44 <johnw> Nadeem: this channel is for discussion of the Haskell language
21:22:33 <Nadeem> sorry johnw 
21:32:09 <jchia> Is there such a thing as vector comprehension, analogous to list comprehension, or do I have to call Data.Vector.toList and use list comprehension?
21:33:14 <johnw> are you looking for a way to build vectors using list-comprehension syntax?  or are you looking to consume a vector and produce a list of results?
21:33:14 <lgstate> (I checked google already) -- are there any haskell bindikngs for *any* snes emulator? I just want to (1) capture screeh and (2) send keystorkkes back
21:34:00 <jchia> no, i got a Vector a and an IntMap b and I'm trying to get [(a, b)] from them and iterate through it
21:36:22 <johnw> you could IntMap.foldrWithKey, and use the index to access the Vector
21:37:11 <jchia> johnw: Good idea, I'll try that.
22:10:07 <buttons840> if i do `stack exec myproject` what RTS options get used by default?
22:12:35 <kadoban> buttons840: stack doesn't randomly add RTS options as far as I know. I have a feeling I'm missing the point of the question?
22:14:07 <buttons840> kadoban: i probably don't understand how the RTS options are typically used
22:14:28 <kadoban> buttons840: They're typically not. It's fairly rare to need them.
22:14:32 <buttons840> kadoban: i guess you can give RTS options to a haskell binary, right? and that stack doesn't give any (meaning i have to set them myself)
22:15:13 <kadoban> buttons840: You can give RTS options, yes. And yes stack would have no reason to do that for you.
22:15:23 <buttons840> my question is probably more about the RTS options in general than about stack then
22:16:08 <buttons840> i compiled a haskell binary with -threaded, do i need to use any +RTS to take advantage of this?
22:16:18 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html
22:16:34 <geekosaur> think you need +RTS -N
22:17:08 <lpaste> glguy revised “generic curry and uncurry”: “generic curry and uncurry extended for sums” at http://lpaste.net/206433
22:18:33 * hackagebot binary-parsers 0.2.0.0 - Extends binary with parsec/attoparsec style parsing combinators.  https://hackage.haskell.org/package/binary-parsers-0.2.0.0 (winterland)
22:19:19 <buttons840> geekosaur: i think your right
22:21:05 <buttons840> i have 2 hyperthreaded cores and +RTS -N will use 4 cores, which ends up being slower than using 2 cores
22:22:01 <geekosaur> so +RTS -N2
22:22:37 <buttons840> geekosaur: yeah, that's how i learned that 2 cores is fastest (although actually no faster than a single thread in this case)
22:35:41 <cheater> lispy: yes. actually the C code matches the algorithm. For all things i tried it yielded the same results. but i am unable to calculate gamma from what the algorithm yields.
22:37:39 <cheater> lispy: so what i meant was that the C code matches my code.
22:37:59 <cheater> but i don't know if it matches the pseudocode algorithm, i wasn't able to make heads or tails of that.
22:38:51 <cheater> @tell prsteele thanks
22:38:51 <lambdabot> Consider it noted.
22:40:22 <adelbertc> is there a way to remove the binaries produced in ~/.local/bin from a `stack install` ?
22:40:34 <adelbertc> do i just remove the binaries manually via `rm` or is there a `stack` command that somehow figures out what to do
22:41:51 <adelbertc> ill move my inquiry to #haskell-stack
22:42:49 <geekosaur> there is no such command, you have to do it manually
22:43:50 <adelbertc> geekosaur: alright, thanks!
23:18:34 * hackagebot glirc 2.18 - Console IRC client  https://hackage.haskell.org/package/glirc-2.18 (EricMertens)
23:18:36 * hackagebot brick 0.10 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.10 (JonathanDaugherty)
