00:00:59 <grantwu> In general, if for any reason CMU determines that the use of the funds for the stated purpose should no longer be possible or appropriate, CMU may use the funds to support other projects or purposes that CMU believes closely align with the educational and/or charitable intentions of the project.  Thus, if CMU determines that (i) the project cannot be performed in whole or in part because it is not fully
00:01:00 <grantwu> funded, CMU may use the funds that cannot be used for the project to support other projects or purposes that CMU believes closely align with the educational and/or charitable intentions of the project, or (ii) the funds raised for the project exceed the financing needs of the project (which may occur if the goal is exceeded), CMU may apply the excess funds to support other projects or purposes that CMU
00:01:02 <grantwu> believes closely align with the educational and/or charitable intentions of the project.    
00:01:04 <grantwu> ...oops wrong channel
00:20:43 <saurabhnanda> what's a reasonable bounty to pay-out for something that should take 1-2 hours for someone with some experience on that task?
00:21:03 <Axman6> $50? depends what it's worth to you I guess
00:21:20 <Lokathor> 100 bucks maybe
00:21:22 <liste> $100
00:21:32 <Lokathor> but what Axman6 said, it depends on how much you want it really
00:21:46 <liste> and that's from a Northern Europe viewpoint
00:22:04 <grantwu> Are there really nontrivial things that can take 1-2 hours
00:22:05 <liste> of course the costs are different in South Asia, for example
00:22:48 <liste> so it'd be N hours for exploring the codebase + 1-2 hours to do the thing
00:22:50 <grantwu> I'd imagine there's a bunch of overhead in reading surrounding code/getting project setup/figuring out what exactly needs to be done/verifying correctness
00:23:47 <saurabhnanda> hmm, didn't factor-in the project-specific learning phase
00:24:25 <saurabhnanda> what're the kind of rates in Asia/Eastern Europe/Africa/Latin America (basically non US/EU/ANZ)? are there any haskell devs/consultancies in this part of the world?
00:26:05 <saurabhnanda> anyone from Asia, Eastern EU, or Africa on this channel?
00:27:22 <saurabhnanda> no one?
00:28:19 <liste> I think there's many Russians here (or at least in #-blah)
00:29:11 <saurabhnanda> what's #-blah?
00:29:26 <saurabhnanda> what're the usual hourly rates in Russia?
00:29:33 <liste> so: #haskell-blah
00:29:40 <liste> saurabhnanda:  
00:29:50 <liste> #haskell-blah
00:29:55 <liste> it's tls-only though
00:30:07 <saurabhnanda> hmm interesting
00:30:08 <saurabhnanda> what's it for?
00:30:30 <liste> saurabhnanda: one of #haskell's off-topic channels (so stuff unrelated and only tangentially related to haskell)
00:30:54 <saurabhnanda> can't connect with SSL turned on
00:31:01 <saurabhnanda> liste: can't connect with SSL switched on
00:32:54 <saurabhnanda> what're the usual hourly rates in Russia?
00:33:57 <liste> maybe mniip knows
00:34:20 <saurabhnanda> mniip: can you help me with the usual hourly rates in Russia for Haskell dev?
00:49:48 <quchen> hpc: Remember our discussion in may 2014 on IRC? Sure you do! Okay, maybe not. But we briefly talked about how naively taking "=>" as a function arrow with a dictionary on the left is not enough to implement polymorphic recursion.
00:50:08 <quchen> See a couple of lines here: http://ircbrowse.net/browse/haskell?events_page=506060
00:50:40 <quchen> kosmikus: the above snippet is what I meant when we talked about dictionaries the other day. 
00:51:55 <quchen> Anyway, that’s where my feeling “someone said dictionaries are not enough for polymorphic recursion” came from.
01:42:55 <newb123> @pl \xs -> map snd . sort $ zip xs [1..] 
01:42:55 <lambdabot> map snd . sort . flip zip [1..]
01:43:25 <newb123> ha, that was an easy one, thanks @pl
01:48:07 * hackagebot linearmap-category 0.1.0.1 - Native, complete, matrix-free linear algebra.  https://hackage.haskell.org/package/linearmap-category-0.1.0.1 (leftaroundabout)
01:48:09 * hackagebot bitcoin-payment-channel 0.4.0.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.4.0.0 (runeks)
01:56:06 <danza> hey, has anybody read https://blog.pusher.com/latency-working-set-ghc-gc-pick-two/ ? Did it show up on Reddit?
01:57:34 <danza> oh yes it showed up, obviously https://www.reddit.com/r/haskell/comments/4j0imi/ghc_cannot_achieve_low_latency_with_a_large/
02:17:46 <koz_> Cale: So, about the van Laarhoven free monads you mentioned?
02:17:55 <koz_> (does this have anything to do with the lens construction?)
02:20:31 <chiller> Hello, I ran stack setup to update my project to use ghc8 and now I get this error on build or ghci Invalid package ID: "array-0.5.1.1 base-4.9.0.0 binary-0.8.3.0 bytestring-0.10.8.1"
02:20:52 <chiller> Does anyone know what that is about?
02:21:08 <glguy> chiller: old version of stack?
02:23:00 <chiller> I will try to update stack
02:26:00 <{AS}> Does there exist a generalisation of catMaybes?
02:26:12 <{AS}> like Foldable t => t (Maybe a) -> t a?
02:26:27 <{AS}> although I would guess Foldable is not enough
02:26:43 <ahihi> http://hackage.haskell.org/package/witherable-0.1.3.3/docs/Data-Witherable.html#v:catMaybes
02:27:25 <{AS}> thanks!
02:28:03 <ahihi> first hayoo result for "t (Maybe a) -> t a" ;)
02:28:41 <{AS}> I guess I should have removed the Foldable t => constraint
02:29:17 <merijn> {AS}: Witherable?
02:32:07 <chiller> I think updating stack helped, it was quite outdated. Thank you
02:34:01 <fjdsaofhdsa> ping
02:35:59 <srhb> fjdsaofhdsa: pong
02:48:09 * hackagebot bitcoin-payment-channel 0.4.0.1 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.4.0.1 (runeks)
02:48:11 * hackagebot genvalidity 0.2.0.4 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.2.0.4 (Norfair)
02:48:13 * hackagebot introduction 0.0.1.0 - A prelude for safe new projects  https://hackage.haskell.org/package/introduction-0.0.1.0 (Norfair)
02:48:15 * hackagebot introduction-test 0.0.1.0 - A prelude for the tests of safe new projects  https://hackage.haskell.org/package/introduction-test-0.0.1.0 (Norfair)
02:48:17 * hackagebot hsparql 0.2.9 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  https://hackage.haskell.org/package/hsparql-0.2.9 (RobStewart)
03:18:36 <Oddasat> Hi. Looking at the Option type in Yesod.Forms.Fields, is my understanding correct when I say that you can't mark an item in a list constructed by selectFieldList as 'selected'?
03:20:25 <saurabhnanda> requesting feedback on **content** of this page (design is being fixed): http://vacationlabs.staging.wpengine.com/haskell-internship/ -- is the information given here enough?
03:25:51 <saurabhnanda> no feedback?
03:35:03 <JuanDaugherty> maybe confirm or not that you are looking for unpaid labor, the normal connotation of that job title, nowhere clarified in the text in my scan
03:36:04 <JuanDaugherty> otherwise clarify rationality, value proposition
03:36:08 <saurabhnanda> JuanDaugherty: you're right. Not looking for unpaid labour :)
03:37:05 <JuanDaugherty> if any
03:37:52 <saurabhnanda> didn't understand the last part -- rationality, value prop?
03:39:04 <JuanDaugherty> somehow over my career, "internship" morphed from the thing I observed in IBM principally but other companies where grad students worked in industry for the experience
03:39:40 <saurabhnanda> JuanDaugherty: what was it in IBM?
03:39:40 <JuanDaugherty> now it appears to be some kind of scam commercial shops run for the privilege of working for them at a sub market wage
03:40:08 <bollu> guys, quick question
03:40:17 <bollu> what does it mean to have a cofree comonad interpreter?
03:40:24 <bollu> in the sense of, how is it "infinite" ?
03:40:39 <bollu> I'm not sure how to interpret the pairing
03:42:18 <saurabhnanda> JuanDaugherty: isn't sub-market wage reasonable, given that the person is learning AND doing. The intern is going to take longer and will make mistakes along the way. As opposed to a seasonal professional.
03:45:05 <JuanDaugherty> saurabhnanda, no, not when the intention is to use the labor as a normal albeit lower grade production unit. The interns I was referring to were not employees although they often converted after graduation.
03:45:44 <saurabhnanda> JuanDaugherty: what do you mean by "lower grade production unit"?
03:46:11 <JuanDaugherty> they were real interns, not scammed new entrants to a high value labor market
03:46:42 <Rembane> JuanDaugherty: So they were actual students? 
03:46:46 <JuanDaugherty> so their learning experience is what their tenure was about
03:46:53 <saurabhnanda> JuanDaugherty: again, what do you mean by "real interns"?
03:47:03 <JuanDaugherty> Rembane, yeah but this was a generation ago
03:47:12 <JuanDaugherty> stuff has changed since then
03:47:34 <Rembane> JuanDaugherty: Generation as in thirty years?
03:48:03 <JuanDaugherty> y
03:48:11 * hackagebot manifolds 0.3.0.0 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.3.0.0 (leftaroundabout)
03:48:13 * hackagebot haxl 0.4.0.0 - A Haskell library for efficient, concurrent,  and concise data access.  https://hackage.haskell.org/package/haxl-0.4.0.0 (algoriddle)
03:48:15 * hackagebot dynamic-plot 0.2.0.0 - Interactive diagram windows  https://hackage.haskell.org/package/dynamic-plot-0.2.0.0 (leftaroundabout)
03:48:54 <Rembane> JuanDaugherty: I got the impression that Fog Creek did this ten years ago and that they still do, but maybe they are the exception to the rule.
03:48:54 <JuanDaugherty> igess last would be IBM Research in Westchester c. '96/97 so 20
03:49:43 <bollu> wow, this is mad: https://hackage.haskell.org/package/manifolds-0.3.0.0
03:49:55 <Rembane> JuanDaugherty: Or I'm 100% wrong on this. Bah. https://www.fogcreek.com/jobs/summerintern
03:50:01 <bollu> I had no idea you could encode the notion of a manifold without explicitly referring to the atlas for computational purposes
03:50:05 <bollu> that's insanely cool
03:50:09 <bollu> but, like, how does that work?
03:51:18 <bollu> also, a category theory question
03:51:38 <bollu> what does a "colimit" do? a limit sort of gives you the "most universal cone"
03:51:49 <bollu> I'm guessing the answer would be "most universal cocone"
03:51:53 <bollu> but.. what's a cocone?
03:52:24 <bollu> like, the limit of a functor F: J -> C gives you the "most general" x \in C that replicates J's diagram in C
03:52:28 <quchen> (obvious “ne up to isomorphism” joke now)
03:52:28 <bollu> what's the colimit doing?
03:52:44 <bollu> quchen: what's the joke?
03:52:58 <quchen> cocoX.
03:53:24 <quchen> Anyway, I remember a talk by sclv at the last Haskell Exchange about colimits.
03:53:39 <saurabhnanda> JuanDaugherty: how does this sound: "This is a paid internship. The compensation will depend on how many hours you’re willing to devote and your skill level. However, please do not expect top-tier consulting rates! If unsure, please reach out and we can work something out."
03:54:40 <Lever> man
04:00:30 <bollu> quchen: do tell
04:00:32 <bollu> Lever: ?
04:01:29 <quchen> bollu: https://skillsmatter.com/skillscasts/6587-programming-with-universal-properties
04:01:32 <quchen> That’s the talk.
04:01:40 <quchen> But maybe ask Gershom in here directly.
04:01:51 <quchen> I don’t know anything about cocones.
04:02:29 <quchen> I found learning about category theory to have an extremely low return on investment and went in a different direction.
04:02:53 <vapid> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
04:07:56 <Hafydd> Is a coconut just a "nut"?
04:12:35 <quchen> Does anyone know a resource on the semantics of or-patterns? Naively, I would translate “case xx of (Left x | Right x) -> e” to “case xx of Left x -> e; Right x -> e”.
04:15:26 <saurabhnanda> quchen: is an 'or' possible in a case? didn't know that.
04:15:50 <quchen> In Haskell (or even GHC) it’s not.
04:16:19 <quchen> I’m wondering why, and what it would take to put it in.
04:20:17 <phadej> quchen: it's ROI is neglecable
04:20:34 <phadej> e (either id id xx)
04:21:18 <phadej> syntactic sugar for something quite easy to make combinator for
04:21:41 <quchen> For Either sure. For a huge sum type with constructors of different arities for business logic not so much.
04:22:00 <quchen> case x of (HostAndPort x _ | HostOnly x) ->
04:22:36 <quchen> case x of 1 | 2 | 3 -> a; other -> other
04:22:53 <ongy> wouldn't that be a usecase of record syntax and smart naming?
04:23:35 <phadej> quchen: pull rhs into a named value, and case x of { HostAndPort x _ -> comb x; HostOnly x -> comb x }
04:23:57 <quchen> That’s what or-patterns desugar to, but done manually.
04:24:07 <quchen> Hardly an improvement in readability.
04:25:25 <dominik_> does anyone know how to specify attributes that don't take any value in blaze-html?
04:25:28 <quchen> case err of ErrorCode (Foo | Bar) description -> ...; ErrorCode other description -> …
04:34:25 <dominik_> nvm, I got it. Since AttributeValueS are monoids, we can always supply `mempty` as an empty attribute value.
05:03:48 <dkk> dkk
05:04:03 <dkk> hello 
05:05:04 <Kneiva> is there a plnkr or fiddler kind of site for haskell?
05:05:07 <dkk> if some one could help me to use a reader monad with IO
05:26:40 <zyhn> Kneiva: something like tryhaskell.org?
05:27:09 <Kneiva> zyhn: yeah, but so that you can save and share
05:27:17 <zyhn> dkk: have you looked at ReaderT?
05:29:08 <zyhn> Kneiva: like pastebin?
05:30:16 <flonk> http://lpaste.net/1926760768942899200
05:30:16 <flonk> uhm
05:31:44 <flonk> Can I.. can I fix this somehow?
05:31:49 <flonk> I don't have more RAM on this thing.
05:32:50 <merijn> flonk: How old is your cabal-install version?
05:33:54 <flonk> A couple of months maybe, but I haven't updated since installing it.
05:34:28 <flonk> Also no idea how up-to-date the amazon aws repositories are :)
05:34:40 <Wizek> flonk, Do you have swap/paging disabled?
05:35:32 <flonk> Wizek, not me certainly, but no idea how to tell
05:35:37 <flonk> It's pretty much a stock ubuntu
05:35:43 <Wizek> flonk, as a workaround idea: Maybe you could do the update locally and rsync it to the aws?
05:35:51 <Wizek> *aws instance
05:36:37 <Wizek> flonk, $ grep SwapTotal /proc/meminfo
05:36:51 <flonk> 0kB!
05:38:07 <Wizek> flonk, yeah, that explains things. Do you want to use this vm for e.g. running production code, or developing on it remotely?
05:38:15 <Kneiva> zyhn: tryhaskell + pastebin is what I would like to have
05:38:54 <flonk> Wizek, just fooling around. Wanted to check out ZipperFS but I don't have any unixoid other than my vm
05:41:59 <zyhn> Kneiva: like a jupyter notebook. I seem to remember there was experimental support for haskell
05:42:36 <Wizek> flonk, it seems enabling swap is not as easy as just running a single command: https://wiki.archlinux.org/index.php/swap What do you think of the workaround idea to copy the local cabal updated files to the vm instance? Or maybe you can limit virtual memory usage of cabal +RTS option as another option..
05:46:23 <Kneiva> zyhn: ok, thanks.
05:46:27 <Wizek> flonk, additional relevant discussion: https://www.reddit.com/r/haskell/comments/3a5c0e/cabal_on_low_memory_device/
05:49:03 <flonk> Wizek, hmm
05:49:05 <Wizek> Kneiva, zyhn It does indeed, with the IHaskell kernel.
05:49:33 <flonk> Wizek, maybe it's easiest if I rent a bigger aws instance for an houd and mount the hard drive there
05:49:51 <flonk> I'll work something out I guess, I just figured that maybe theres some cabal flag I can set
05:50:00 <flonk> *for an hour
05:50:15 <flonk> Wizek, thanks for the help though :)
05:53:04 <Wizek> flonk, Glad if it helps :) Also: there is nearlyfreespeech.net too, where you only need to pay for as much or as little resources you use, and they have ghc (and I think cabal too) preinstalled on their machines. The only thing is it is not Linux but rather FreeBSD that they are running. Which may or may not be a problem in your case.
05:55:12 <flonk> Wizek, I'll check it out!
05:55:59 <Wizek> Now, if only anyone could tell me if/how I could use Jupyter + IHaskell in the context of a stack/cabal project (just like `stack ghci`)! :) https://github.com/gibiansky/IHaskell/issues/692
05:56:47 <Wizek> Or alternatively: How to use ghci in a way that is more multi-line friendly than doing :{ \n :
05:57:45 <Wizek> Whoops, premature carriage return. ... more multi-line friendly than doing ":{ \n :}"s, or even ":set +m"
06:14:43 <mnoonan> Wizek: I think you'll need to make a custom kernel that runs ihaskell's kernel within stack's ghci
06:17:19 <ski> soLucien : "am i correct to say that","in order to start testing stuff i need write half of my interpreter?" -- probably, yes
06:17:55 <ski> soLucien : that `modify' looks correct (and is the obvious thing something with that type signature should do, since `Env' is to behave as a state in your monad)
06:19:23 <Benzi-Junior> has happstack been completely discontinued ?
06:20:24 <ejbs> [(a,b,c):t] is a valid destructuring of [(Tree a, Tree a,Double)], right?
06:21:13 <Wizek> ejbs, Try ((a,b,c):t)
06:21:39 <ski> or just `(a,b,c):t'
06:22:03 <ejbs> Wizek: Ah yeah, that's correct. I've been going from Prolog and Haskell and you mix up the syntax a bit :-)
06:22:18 <ski> ejbs : `[(a,b,c):t]' could have type `[[(Tree a,Tree a,Double)]]', but not `[(Tree a,Tree a,Double)]'
06:22:31 * ski nods to ejbs re Prolog and Haskell list syntax
06:22:54 <ejbs> ski: Ooh, okay
06:22:56 <ski> (also in Erlang)
06:23:50 <ski> (iow, `[(a,b,c):t]' is a list having exactly one element (iow, is a singleton list), being a list starting with the element `(a,b,c)', and continuing with the elements of the list `t')
06:24:17 <Wizek> mnoonan, hmm, yeah, I might consider doing that actually, since in theory the only change is needed is replacing the invocation of "ghci" with "stack ghci" somewhere in there.
06:25:17 <mnoonan> Wizek: the only thing I'm not sure about is whether the kernel is launched in the working directory of the notebook or not. So there might be some fiddling to get stack's ghci pointed at the right project.
06:28:43 <Wizek> mnoonan, makes sense
06:39:55 <ania123> I want to define function mylength
06:40:07 <ania123> mylength :: [a] -> Int
06:40:18 <ania123> I get errors when I define types like this
06:40:20 <ania123> why?
06:40:35 <pkmx> what error?
06:40:38 <Wizek> ania123, What error do you get?
06:41:25 <ski> btw, that's not "defining a type", that's "writing a type signature (for `mylength')"
06:41:52 <ania123>  test.hs:1:2: error:     The type signature for ‘mylength’ lacks an accompanying binding
06:41:56 <ski> (defining a type would involve using one of the keywords `type',`data',`newtype')
06:42:10 <ania123> could you tell me please
06:42:14 <ania123> how can I define type
06:42:17 <ski> ania123 : you also need to have one (or more) defining equations like `mylength ... = ...'
06:42:26 <ski> you don't need to define a type here
06:42:36 <ski> you could start with
06:42:37 <mauke> ania123: you didn't define the function
06:42:40 <ski>   mylength = undefined
06:42:41 <ski> or
06:42:51 <ski>   mylength = error "not defined yet !"
06:43:08 <ania123> I want to define a function mylength
06:43:16 <ski> if you want to check that your type signature was ok, before starting to actually define `mylength' itself
06:43:19 <ania123> before I define it, I need to define its type
06:43:20 <ania123> no?
06:43:21 <ski> yes
06:43:23 <ski> no
06:43:37 <ania123> no?
06:43:48 <ski> before the actual definition, you *can* specify a type signature for `mylength'
06:43:57 <ski> (you don't have to, but it's generally recommended)
06:44:11 <ski> it's not "define its type", it's "writing a type signature for it"
06:44:25 <ania123> could u please
06:44:30 <ania123> write type signature
06:44:33 <ania123> for length
06:44:37 <ski> you already did it
06:44:37 <srhb> ania123: Your signature was fine.
06:44:37 <ania123> for mylength
06:44:40 <ski> it's fine
06:44:45 <ania123> if it is fine
06:44:50 <ania123> why it does not compiles
06:44:50 <ania123> ?
06:44:58 <ania123> why it gives error
06:45:00 <ski> it's complaining that it hasn't seen an actual definition of `mylength' to go with the type signature
06:45:00 <ania123>  test.hs:1:2: error:     The type signature for ‘mylength’ lacks an accompanying binding
06:45:05 <ski> so go on to define it
06:45:13 <srhb> ania123: Please don't use return as punctuation. And the error tells you exactly why. You can't have a type signature without the equation defining the actual value.
06:46:18 <ania123>  mylength :: [a] -> Int mylength [] = 0 mylength (_:xs) = 1+ mylength xs
06:46:24 <ski> yes
06:46:27 <ski> (on separate lines)
06:46:27 <srhb> ania123: ania123 On separate lines.
06:46:35 <ania123> yes
06:46:37 <ania123> separate lines
06:46:40 <ski> that should work
06:46:40 <ania123> and it gives error
06:46:44 <ski> which error
06:47:24 <{AS}> $ doesn't work at type-level?
06:47:31 <mauke> > let { mylength :: [a] -> Int; mylength [] = 0; mylength (_:xs) = 1+ mylength xs } in ()
06:47:32 <ski> {AS} : right
06:47:33 <lambdabot>  ()
06:47:35 <mauke> no error
06:48:15 * hackagebot pptable 0.1.0.0 - Pretty Print containers in a tabular format  https://hackage.haskell.org/package/pptable-0.1.0.0 (gdevanla)
06:48:17 <ski> {AS} : possibly you could do something like `type f $ a = f a'
06:48:29 <{AS}> ski: Thanks
06:48:40 <srhb> Needs a colon first, doesn't it.
06:48:46 * ski doesn't recall
06:49:09 <{AS}> it seems to work
06:49:11 <srhb> I think it may just be for data constructors
06:49:11 <ski> (they changed the rule for infix operators in types)
06:49:15 <{AS}> I added TypeOperators
06:49:18 * ski nods
06:49:57 <ski> ania123 : which error does it give you ?
06:50:06 <ski> ania123 : or have you managed to get rid of the error now ?
06:50:37 <{AS}> ski: I hopes that becomes standard
06:51:26 <ania123> \it works
06:51:29 <ania123> thx
06:53:08 <quchen> mauke: May I suggest a small refactoring to make your code more efficient? ;-)
06:53:43 <ski> ania123 : ok
06:56:13 <mauke> quchen: I don't think you can get much faster than ()
06:56:48 <quchen> mauke: Well, delete the “let”.
06:56:52 <quchen> Hence the smiley.
07:02:31 <lyxia> >  { mylength :: [a] -> Int; mylength [] = 0; mylength (_:xs) = 1+ mylength xs } in ()
07:02:33 <lambdabot>  <hint>:1:1: error: parse error on input ‘{’
07:02:39 <lyxia> nope doesn't work
07:10:06 <{AS}> warning to everyone using QuickCheck: suchThat can go into an infinite loop
07:10:32 <{AS}> I was debugging for hours, and couldn't find any place in my program that had infinite loops
07:11:01 <{AS}> apparently using suchThat with a very hard condition to satisfy was the actual cause
07:11:01 <quchen> Hah, indeed it does!
07:11:20 <quchen> SuchThat is a loop that increases the size parameter on each iteration
07:11:29 <quchen> But it never gives up for false predicates :-)
07:11:41 <{AS}> I switched it to suchThatMaybe
07:11:44 <{AS}> everything terminates now
07:11:58 <{AS}> I mean, it's better that it gives up than eats 12 GB of my memory
07:12:04 <quchen> If you do that, all you get is a “constant Nothing generator”.
07:12:49 <{AS}> quchen: So the condition can be satisfied
07:13:14 <quchen> Oh, I misunderstood suchThatMaybe.
07:13:33 <{AS}> it is just that on some tries it happens to not be able to satisfy it 
07:13:51 <{AS}> so yeah, suchThatMaybe will return you Nothing
07:14:02 <{AS}> but it will at least let another round go through
07:14:19 <quchen> suchThatMaybe uses the size parameter to generate a number of candidates and bails with Nothing if none works.
07:14:25 <{AS}> Yeah
07:14:26 <ski> {AS} : can you use `forAll' and `(==>)' instead ?
07:15:01 <{AS}> ski: I do that as well
07:15:22 <{AS}> so the result might now generate a Maybe a
07:15:26 <quchen> ==> is more for special test cases, I think. If you have an AST with invariants, you want the generator to give you nice things, not the test to filter out bad generator output.
07:16:24 <{AS}> and I usee forAll maybeInpGen (\maybeInp -> isJust maybeInp ==> let inp = fromJust maybeInp in ... )
07:16:26 <ski> iow, instead of   forAll (gen `suchThat` \x -> p x) $ \x -> ..x..  use   forAll gen $ \x -> p x ==> ..x..
07:16:43 <{AS}> ski: but I don't put the suchThat there
07:16:52 <ski> ok
07:16:52 <{AS}> I am generating another complex input structure
07:16:57 * ski nods
07:17:03 <{AS}> Thanks for the tip anyway :)
07:17:32 <{AS}> I wish there was a forAllMaybe though
07:18:34 <ski> (using `(==>)' would cause the test generation to give up after a while, if it can't find enough cases satisfying the predicate. while, iiuc, `suchThat' wouldn't cause that to happen)
07:19:51 <ski> i suppose you could use `forAll (gen `suchThatMaybe` \a -> p a) $ \m -> isJust m ==> ..(fromJust m)..' ?
07:21:41 <{AS}> ski: That is what I do now (except I don't inline the suchThatMaybe think here, since it's a part of a larger generator)
07:26:06 <ski> {AS} : ok
07:27:06 <ski> {AS} : so you have `Gen (..(Maybe T)..)' or `Gen (Maybe (..T..))' ?
07:27:37 <ski> (i suppose the latter is `MaybeT Gen (..T..), then .. which might perhaps be helpful in constructing it)
07:33:14 <athan> Is there a way to force a module to be recompiled upon rebuild? (in stack or cabal)
07:33:24 <athan> I've tried --force-dirty in stack, but it ain't do it
07:34:03 <dmj`> athan: if it hasn't changed why rebuild it
07:34:17 <dmj`> athan: o/ :) 
07:39:23 <athan> dmj` yo :)
07:39:28 <athan> so get this
07:39:33 <dmj`> sup
07:39:48 <athan> I'm using TemplateHaskell to generate public/secret keypairs
07:39:53 <athan> as a means to a cert
07:40:29 <athan> so every time I rebuild, I have baked in authentication (ish)
07:40:39 <athan> (given the module actually rebuilds)
07:42:37 <athan> an attacker would have to parse the binary to extract my cert keys, but I think it's good enough for now
07:42:54 <dmj`> athan: I see, hm. Using runIO I assume
07:43:02 <divVerent> Technically you should bump the module version to rebuild then, and maybe derive the secret directly from the module version + an on-system secret, instead of a real RNG.
07:43:04 <athan> to ensure my client / server are _only_ speaking to verified clients / servers (and version restricted too!)
07:43:11 <athan> dmj` exactly :)
07:43:38 <athan> divVerent: What do you mean by module version?
07:43:54 <athan> well, I have secrets being generated at runtime too
07:44:06 <athan> but I'd like one generated at compile time as well, so I can stamp my distributed software
07:44:13 <divVerent> to turn low-entropy data into a seed for a good PRNG, IIRC stuff like PBKDF2 is popular
07:44:13 <divVerent> essentially, don't create a new secret each build
07:44:13 <divVerent> but have the secret be a function of the version number + some data on your system
07:44:24 <divVerent> and maybe use a cronjob to bump the version of your keys package to a number like YYYYMMDD
07:44:51 <athan> scrypt is nice too :)
07:44:55 <divVerent> basically lets you have some more control and e.g. rebuild the binary
07:45:02 <divVerent> with a small fix, without invalidating the key
07:45:13 <divVerent> athan: right, that too
07:45:17 <divVerent> or Argon2, whatever :)
07:45:26 <lyxia> I think there's a package that allows you to inject data directly into your binaries
07:45:30 <divVerent> for this application it doesn't have to be perfect, given the key is shared with end users anyway
07:45:41 <athan> divVerent: Well, the issue I see with that is it would be easier for an attacker to recreate those keys
07:45:41 <athan> yet, I'd still need the keys to be static
07:45:46 <divVerent> just saying that it may be a good idea to have the keys be reproducible
07:46:03 <divVerent> an attacker can easily steal the keys from the binary anyway
07:46:07 <athan> well...
07:46:09 <athan> idk
07:46:16 <athan> I'm considering using a MOV obfuscator too :x
07:46:28 <divVerent> I bet it'd take me like 30 minutes given two "sufficiently similar" versions of the binary
07:46:45 <divVerent> when I was a kid, I once made a game, and used some secret to protect the highscores file
07:46:51 <lyxia> http://hackage.haskell.org/package/file-embed-0.0.10/docs/Data-FileEmbed.html "Inject into an executable"
07:46:53 <divVerent> I "obfuscated" the secret by making it look like code
07:47:06 <dcoutts> athan: --ghc-options=-fforce-recomp
07:47:10 <athan> hmm!
07:47:25 <divVerent> essentially, char secret[] = "\xb8\x13\x00\xcd\x10\xc3";
07:47:25 <athan> dcoutts: !!! You're power is too great :)
07:47:32 <divVerent> little did I know that there are separate code and data segments :)
07:48:11 * ski . o O ( "code is data" )
07:48:16 <int-e> divVerent: tsk... it would have worked for a .com file ;-)
07:48:17 * hackagebot carettah 0.5.0 - A presentation tool written with Haskell.  https://hackage.haskell.org/package/carettah-0.5.0 (KiwamuOkabe)
07:48:19 * hackagebot carettah 0.5.1 - A presentation tool written with Haskell.  https://hackage.haskell.org/package/carettah-0.5.1 (KiwamuOkabe)
07:48:22 <divVerent> int-e: hehe
07:48:40 <divVerent> int-e: also, could have been smarter to just have used the range between two function pointers :)
07:48:44 <divVerent> (and not ever changing the compiler)
07:49:34 <{AS}> ski: I have Gen (Maybe (..T..))
07:50:11 <divVerent> as for mov obfuscators... no, I don't trust them too much...
07:50:23 <divVerent> they make awfully slow code and don't gain that much once you know how they work
07:50:37 <divVerent> might be more effective to translate the program to brainfuck, then to a turing machine ;)
07:50:42 <{AS}> or well I propagate the Maybe
07:51:24 <athan> divVerent: Just for the keys I mean (somehow) <~$> (. Maybe)
07:51:27 <divVerent> sure, this can still be somewhat easily reversed... but the translation to BF already loses so much control flow, it stops being funny
07:52:02 <divVerent> athan: interesting idea, but well, eventually the key will sit in RAM
07:52:13 <divVerent> I must know, I did some minor cracking (never released, don't worry) on my own when I was at school
07:52:19 <divVerent> like, SoftICE was a tool I knew
07:52:38 <divVerent> turns out that in most cases, people succeed at hiding a secret from the binary
07:52:41 <divVerent> but in RAM it's still exposed
07:52:53 <divVerent> and debugging live programs is easier than analyzing binaries
07:53:01 <athan> divVerent: Yeah :\ I mean, should I expect the OS to be _that_ insecure?
07:53:05 <ski> {AS} : nod. so would `MaybeT' help then ?
07:53:07 <divVerent> the OS?
07:53:19 <divVerent> you mean you only allow running on an OS that doesn't let the owner of the system be root?
07:53:23 <athan> to the degree that every program's program code is available to any user?
07:53:33 <athan> ahh yeah idk
07:53:35 <athan> hm
07:53:45 <divVerent> no, it's only available to THE user who's running it
07:53:45 <divVerent> that's bad enough :)
07:53:53 <athan> yeah haha
07:54:06 <divVerent> I mean, I know on Unix you can make the binary 711 so non-root can only execute, not read it
07:54:18 <divVerent> but reading it from RAM by using a debugging functionality is permitted on virtually every OS
07:54:42 <athan> hrrrmmmm alright
07:54:46 <bob_twinkles> I mean, if you think about it that has to be the case right?
07:54:46 <divVerent> even Android and iOS let nonroot freely use ptrace()
07:55:01 <bob_twinkles> the CPU does need the code at some point =P
07:55:14 <divVerent> sure, but said debug facilities don't strictly NEED to exist
07:55:30 <divVerent> in theory an OS could limit that access to admin/root/system/whatever users
07:55:44 <divVerent> in practice, nobody would want such an OS
07:56:01 <divVerent> or rather, developers don't, and without developers, there won't be applications
07:57:05 <divVerent> in any case, if you want to somewhat obfuscate a secret...
07:57:23 <divVerent> the probably best way regarding cost/effectiveness is to use some kind of VM to perform the operations involving the secret
07:57:42 <divVerent> and to hardcode the secret within the VM, if somehow possible
07:58:37 <divVerent> by that I mean inlining as many as possible decisions involving the secret
07:58:38 <{AS}> ski: Yeah, I use MaybeT intermediately
07:59:14 <{AS}> It is just that writing all the lift's is a bit annoying I guess :)
07:59:17 <athan> s_s yeah idk
07:59:25 <bob_twinkles> I think the real solution is probably going to be "never trust the client" =P
07:59:28 <{AS}> ski: I guess I kind of hoped for a MonadGen :)
08:00:57 <bob_twinkles> ultimately your code is running on an untrusted system, so the only thing you can do is make it as difficult as possible to comprimise and then pray that whatever your protecting is worth less than the effort required to break your protection scheme
08:01:47 <athan> bob_twinkles: Yeah :\
08:01:57 <athan> I think mov obfuscation might be the best route
08:02:05 <bob_twinkles> *compromise *one of those your s should be a you're
08:02:30 <bob_twinkles> I was asked to reverse a Haskell program once, the STG is a pretty effective means of obfuscation by itself =P
08:04:04 <athan> daaaaaamn those binaries actually differ greatly just from a deep rebuild
08:04:12 <divVerent> athan: yes, mov obfuscating MIGHT be somewhat working (like the VM I mentioned) as long as you make sure the secrets are actually compiled in and used in a few places in different ways
08:04:34 <athan> hmm, right on :)
08:04:47 <divVerent> at the very least you shouldn't store the secrets in their "standard" order, ideally not even contiguously
08:04:58 <divVerent> but yes, if you can compile the operations involving the secret into raw Haskell instead
08:05:00 <divVerent> that'd work as well :)(
08:05:18 <divVerent> just make sure the secrets don't exist as a contiguous memory block, and the nonexistence of proper reversing tools for Haskell will do the rest
08:06:02 <{AS}> ski I mean QuickCheck is already really great, but there is room for improvement in some parts of the interface :)
08:08:12 <divVerent> like, if you can somehow make sure the compiled code contains/builds the tree structure Data.Sequence uses, you're likely already fine :)
08:11:11 <jluttine> mikeizbicki: your rss feed is somehow broken: https://izbicki.me/feed.rss
08:11:30 <jluttine> it's a very interesting blog, would like to get a feed from it :)
08:14:56 <ski> {AS} : (`MonadGen') hm, i see. perhaps not a bad idea. *nod*
08:15:13 <jluttine> i'm new to haskell but interested in using (i.e., learning to use) haskell for data science / bayesian inference / machine learning. do you have any suggestions on some good resources (packages, blogs, web sites, books, papers, whatever) or collaborations/groups (packages, mailing lists, irc channels, etc)?
08:15:44 <oherrala> jluttine: this is handy for learning: http://dev.stephendiehl.com/hask/
08:15:55 <cocreature> jluttine: for collaboration take a look at http://datahaskell.github.io/ (github & slack channel)
08:15:57 <jluttine> i know hlearn and haskell data science cookbook
08:16:27 <jluttine> oherrala cocreature: thanks, i'll take a look!
08:20:15 <{AS}> Is it not possible to derive Data for GADTs?
08:21:06 <lyxia> Not at the moment.
08:21:29 <{AS}> OK, thanks :)
08:23:00 <lyxia> There are a lot of tricky things about it.
08:27:53 <ania123> i have a problem
08:27:55 <ania123> http://pastebin.com/n8uBcvV8
08:29:01 <dmj`> ania123: what is the problem you see
08:29:57 <ania123> :load "qqq.hs" [1 of 1] Compiling Main             ( qqq.hs, interpreted ) Failed, modules loaded: none.  qqq.hs:3:1: error: parse error on input ‘where’
08:30:16 <ski> ania123 : indent `where' more
08:30:18 <srhb> ania123: It needs to be indented. By at least one space, in this case.
08:30:37 <ania123> in front?
08:30:42 <ski> yes
08:31:29 <ania123> thx
08:38:53 <kuribas> Is it possible to make a macro mkStr, so 'mkStr a becomes a = "a" ?
08:39:03 <kuribas> with template haskell?
08:40:35 <srhb> kuribas: What exactly do you mean by macro?
08:41:02 <kuribas> a function over syntax
08:41:17 <kuribas> like macro in LISP
08:41:32 <srhb> kuribas: I don't think you can reliably get that without using quasiquoters.
08:41:52 <kuribas> ok, thank
08:42:09 <cocreature> the syntax would then be [mkStr| a]
08:42:18 <cocreature> eh [mkStr| a|]
08:43:47 <kuribas> In my library mkVariable "a" creates a variable named a, so I thought I might simplify it using TH.
08:43:59 <kuribas> so mkVar a, instead of a = mkVariable "a"
08:46:45 <ski> hm, `$(mkVar "a")' would be possible, no ?
08:48:48 <kuribas> ski: yeah, that's a bit better
08:53:08 <mnoonan> argh, I can never remember what modules end up in "Control.*" vs "Data.*".
08:54:35 <mnoonan> I reach for catMaybes to shape a computation.. Data.Maybe. I reach for a lens to represent a data location.. Control.Lens. :|
08:54:52 <cocreature> for a lot of things it’s simply arbitrary where they are
08:55:07 <cocreature> e.g. it makes no sense that it’s Data.Functor but Control.Applicative
08:55:17 * mnoonan nods.
08:56:11 <cocreature> for Maybe and Lens you might be able to argue that Maybe is a datatype so it belongs in Data and Lens is more of an “operational concept” so it belongs in Control but in the end there are no clear rules
08:56:23 <cocreature> I never understood why we have this weird module hierarchy
08:56:48 <Clint> someone thought it was a good idea
08:56:59 <mnoonan> with a few exceptions, I think replacing "Data.Foo" and "Control.Bar" with "Foo" and "Bar" would be a win.
08:57:20 <eklavya> how can I insert a delay of 1-2 seconds amongst all hspec tests?
08:58:15 <cocreature> eklavya: You might be able to get that by using one of the “after” hooks or whatever they’re called but tbh if you need to do that it seems like you are doing something wrong
08:58:38 <eklavya> cocreature: it's ok in this case
08:58:52 <eklavya> I have a cluster of 3 cassandra nodes
08:58:55 <eklavya> I write on one
08:59:01 <eklavya> and immediately read from the other
08:59:08 <eklavya> which fails sometimes (expected)
08:59:26 <eklavya> I need to put some wait time so that the cluster converges
09:00:04 <eklavya> this is what I think is happening, can be confirmed after I have put some wait
09:01:42 <cocreature> eklavya: are you sure that your cluster always converges after 3s? otherwise you are introducing a race condition in your tests which is a pain to debug and really annoying
09:02:10 <eklavya> 3s for all nodes on localhost is good enough :P
09:02:49 <cocreature> fair enough :)
09:05:38 <ania123> can one tell me how to implement init? for example, init [1,3,5]  returns [1,3]
09:06:26 <ania123> ski
09:06:28 <thewormkill> ania123: well, telling directly is boring :) so how would you approach this problem yourself?
09:06:48 <thewormkill> ie. what do you think a possible implementation would look like?
09:06:57 <ania123> myint [] = []
09:07:24 <ania123> myint (x:xs) = xs
09:07:35 <ania123> err
09:07:36 <ski> > init []
09:07:37 <cocreature> that’s tail not init
09:07:38 <lambdabot>  *Exception: Prelude.init: empty list
09:07:46 <thewormkill> these two points ^
09:08:06 <ski> if you want to behave similarly to `init', then you should not give a defined result for the empty list
09:08:20 <ski> iow, just omit the case, or, alternatively, use `undefined' or `error'
09:08:27 <ania123> using last
09:08:40 <cocreature> last is not very useful when implementing init
09:08:41 <grantwu> You could yield a Maybe
09:09:12 <ania123> i do not want to use
09:09:20 <ania123> x : init xs
09:09:30 <thewormkill> that's the right thing though
09:09:38 <cocreature> you just need to find the basecase
09:09:42 <ania123> is there way to do without it
09:09:45 <ania123> ?
09:09:50 <cocreature> without recursion?
09:10:10 <ania123> init [] = []
09:10:23 <thewormkill> that's not the basecase, as init [] is undefined
09:10:39 <thewormkill> ania123: what is the shortest list you can safely apply init to?
09:10:40 <ania123> ibit (x:xs) = x : init xs
09:10:51 <cocreature> that would just return the input list
09:10:57 <cocreature> you need to drop the last element
09:11:16 <ania123> could one write it for me
09:11:39 <Clint> someone already did. it's called "init"
09:12:02 <pavonia> ania123: Think about what should happen for a list wih just one element
09:12:04 <ski> ania123 : how would you write a function that given a list with at least three elements, returned a list having just those three elements ?
09:12:19 <eklavya> cocreature: thanks :)
09:12:28 <eklavya> I used before and it works
09:12:39 <ski> ania123 : sorry, returned a list having exactly the *first* three elements
09:12:47 <ania123> foo x = x
09:12:49 <eklavya> also I was not expecting threadDelay to take nanos :P
09:13:02 <cocreature> ania123: what should init [x] return?
09:13:23 <ania123>  init [x]  = []
09:13:31 <ski> ania123 : `foo [0,1,2,3] = [0,1,2,3]', not `[0,1,2]'
09:13:35 <cocreature> yes!
09:13:44 <ski> (sorry i wasn't precise enough, at first)
09:13:57 <cocreature> there you have your basecase
09:14:25 <ania123> ski: please i need it urgently
09:14:28 <ania123> could u show me code
09:14:32 <ania123> I can not think now
09:14:49 <cocreature> ania123: if you want to see the code just look at the source for init
09:15:14 <ski> ania123 : either you could go on with the alternative (hopefully helping) exercise i had in mind .. or you could continue with what cocreature has been elaborating
09:16:03 <ski> ania123 : if you want to, i can show how `firstThree' could be defined. do you want me to ?
09:16:41 <ania123> please show
09:16:43 <ski>   firstThree :: [a] -> [a]
09:16:44 <ski>   firstThree (x0:x1:x2:xs) = [x0,x1,x2]
09:16:57 <ski> this works for any list having at least three elements
09:17:12 <ski> for lists of zero elements, or one element, or two elements, it's not defined
09:17:38 <ski> if we also wanted to define it in those cases, by simply returning a list of the (less than three) elements we have, we could do that as follows :
09:17:41 <ski>   firstThree :: [a] -> [a]
09:18:02 <ski>   firstThree [           ] = [        ]
09:18:07 <ski>   firstThree [x0         ] = [x0      ]
09:18:22 <ski>   firstThree [x0,x1      ] = [x0,x1   ]
09:18:38 <ski>   firstThree (x0,x1,x2:xs) = [x0,x1,x2]
09:18:51 <ski> (extra alignment for extra prettiness)
09:18:55 <ski> ania123 : do you follow ?
09:19:26 <ski> the last defining equation handles both the case of exactly three elements, and also the case of more than three elements
09:20:08 <ski> ania123 : the point is to realize that you can use patterns like `[x0,x1]' and `[x0]' (and also `x0:x1:x2:xs') when defining functions on lists. it doesn't have to be only the two cases `[]' and `x:xs'
09:20:33 <ski> (also, i typoed, the last equation above should have `:'s, not `,'s in the pattern)
09:30:20 <tommd> > const "pong" "ping"
09:30:23 <lambdabot>  "pong"
09:38:43 <DrEntropy> Does there exist a relativiely straightforward web framework (like "Flask") for haskell that doesn't depend on a million different dependancies?
09:39:12 <tommd> No, they all have at least 2^20 dependencies, sorry.
09:39:50 <srhb> DrEntropy: Spock, Scotty?
09:39:51 <cocreature> DrEntropy: spock is relatively straightforward but I’m not sure about the number of deps
09:40:45 <srhb> I don't think number of dependencies is a very good metric anyway. Haskell tends to benefit a lot from generalizations that you can simply import.
09:40:50 <srhb> So you shouldn't be afraid of it. :)
09:41:03 <athan> DrEntropy: nested-routes! :v
09:41:07 <athan> (just kidding)
09:48:10 <nwf> Sigh.  It looks like something broke about cmdlib's... interesting implementation of (%>) on modern ghc.  Anyone else encountered this?
09:48:10 <DrEntropy> srhb maybe you are right, I should just get over that :)
09:48:20 * hackagebot haxl 0.4.0.1 - A Haskell library for efficient, concurrent,  and concise data access.  https://hackage.haskell.org/package/haxl-0.4.0.1 (algoriddle)
09:49:42 <kuribas> how come makeLenses doesn't need to be quoted?
09:49:46 <DrEntropy> Spock looks pretty cool... i might have to spend my weekend trying that out :)
09:49:51 <kuribas> because it returns a declaration?
09:49:52 <DrEntropy> Ty all
09:50:14 <srhb> DrEntropy: As an example, most frameworks now -- including Spock -- use the http-types library
09:50:36 <srhb> DrEntropy: Meaning a lot more code sharing _between_ frameworks. I think that's a huge plus. :)
09:50:54 <kuribas> never mind, it says so in the ghc guide.
09:57:52 <srhb> nwf: I've never used it, but it looks like the strings just need to be fixed to a specific type?
10:00:49 <nwf> srhb: In particular, the problem is that I am hitting the error branch of toKey in System.Console.Cmdlib.Attribute's 'instance ToKey (a -> b)'.
10:02:20 <srhb> Oh!
10:04:32 <apriori> is there a special channel related to building ghc?
10:04:54 <lyxia> #ghc ?
10:05:02 <apriori> ah, ty
10:05:06 <jle`> @djinnn ((a -> b) -> a) -> a
10:05:06 <lambdabot> -- f cannot be realized.
10:05:15 <srhb> nwf: Oh, is this because of polykinded Typeable?
10:05:58 <nwf> I have no idea why it's happening.
10:06:26 <ski> @djinn NotNot (((a -> b) -> a) -> a)
10:06:26 <lambdabot> f a =
10:06:26 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
10:06:47 <ski> @djinn Either a (Not a) -> ((a -> b) -> a) -> a
10:06:47 <lambdabot> f a b =
10:06:47 <lambdabot>     case a of
10:06:48 <lambdabot>     Left c -> c
10:06:50 <grantwu> nwf: I feel the same way, tbh, whenever something goes wrong with Haskell :P
10:06:50 <lambdabot>     Right d -> b (\ e -> void (d e))
10:07:15 <jle`> :t (\f -> f (let x = x in x)) :: ((a -> b) -> a) -> a
10:07:16 <lambdabot> ((a -> b) -> a) -> a
10:07:43 <jle`> ski: oh neat
10:07:49 <ski> hrm. this is `J b a -> a', i suppose
10:07:59 * ski . o O ( `runJ' )
10:08:23 <ski> hm, or i'm confusing it
10:09:20 <jle`> it's peirce's law, in case that wasn't evident
10:09:44 <ski> it was evident, to me :)
10:09:55 <ski> aka `call-with-current-continuation'/`callCC'
10:10:48 <ski> hm, thinking on it, i think `(a -> b) -> a' really is `J b a'
10:10:50 <jle`> maybe we can just preface all haskell functions with an implicit Either a (Not a), and then we can get LEM back
10:10:59 <ski> (would have to check it up, to be certain)
10:11:25 <nwf> srhb: This implementation of toKey is... ooooooh.  Oh I understand.
10:11:46 <nwf> The callstacks are now part of the exception text as Show produces, so the comparison against "up" is going to fail.
10:12:02 <ski> @djinn ((a -> NotNot b) -> NotNot a) -> NotNot a
10:12:03 <lambdabot> f a b = void (a (\ c -> void (b c)) b)
10:12:33 <ski> @djinn ((a -> Cont o b) -> Cont o a) -> Cont o a
10:12:33 <lambdabot> f a b = a (\ c _ -> b c) b
10:12:56 <ski> (there, no `void' in it)
10:12:59 <DrEntropy> BTW it is friday, everyone have a great weekend, but please, please, stay away from unsafePerformIO..  Nah, at least have a drink first though/
10:13:22 <ski> (just set `o' to `Void' to recover the `NotNot' type, still with no `void' in the solution)
10:13:49 <jle`> neat :o
10:14:09 <nwf> Bah.  Fixing that sends it into an infinite loop.
10:14:14 <nwf> Time to find a new library, I think. ><
10:14:18 <jle`> but you can trivially make it work by replacing b with a lot of things
10:14:37 <jle`> er, by ((a -> m b) -> m a) -> m a
10:15:01 <jle`> for specific m's
10:15:02 <ski> replacing `b' by `((a -> m b) -> m a) -> m a' ??
10:15:14 <jle`> yeah, forget that first line heh
10:15:26 <jle`> but i guess 'Cont o' is special here
10:16:12 <jle`> but i could do ((a -> Maybe b) -> Maybe a) -> Maybe b, is what i'm saying
10:16:33 <ski> `const Nothing', e.g.
10:16:59 <ski> or `($ const Nothing)'
10:17:35 <jle`> mhm. but i guess Cont is different becuase there's no `forall a. Cont o a` term.  or is there?
10:17:46 <ski> i'm not sure what you're asking
10:18:18 <ski> you can write `forall a. Cont o a' as a type, but i'm not sure what that would have to do with the topic above
10:18:21 <jle`> i was saying that `(a -> Maybe b) -> Maybe a) -> Maybe a` is not very impressive because you cna just pull out a handy (forall a. Maybe a)
10:18:31 <ski> ah
10:18:57 <jle`> so why is (a -> Cont o b) -> Cont o a) -> Cont o a more impressive?  just because you can't do have a similar forall a. Cont o a?
10:19:00 <ski> well, there's `($ undefined) :: forall a. Cont o a'
10:19:26 <ski> but possibly, yes
10:19:27 <jle`> oh, i guess having a `forall a. Cont o a` is equivalent to LEM
10:19:34 <jle`> s/guess/propose maybe
10:19:45 <ski> also, with `Cont o', it'll correspond to `call-with-current-continuation' in Scheme
10:20:09 <jle`> @djinn Cont o a
10:20:09 <lambdabot> -- f cannot be realized.
10:20:16 <jle`> @djinn Either a (Not a) -> Cont o a
10:20:17 <lambdabot> -- f cannot be realized.
10:20:31 <jle`> ski: oh yeah, that's proably the more interesting part
10:21:43 <ski> with LEM, `(a -> o) -> o' is `Either (a,Not o) o', hmm
10:22:18 <ski> with `o = Void', that'd become just `a' (of course)
10:22:18 <jle`> i already figured out that my previous proposition was incorrect, heh
10:22:59 <ski> @djinn Either o (Not o) -> ((a -> o) -> o) -> Either (a,Not o)
10:22:59 <lambdabot> Error: kind error: (KVar 6,KStar)
10:23:08 <ski> @djinn Either o (Not o) -> ((a -> o) -> o) -> Either (a,Not o) o
10:23:08 <lambdabot> -- f cannot be realized.
10:23:16 <ski> hm
10:23:44 <ski> @djinn Either a (Not a) -> Either o (Not o) -> ((a -> o) -> o) -> Either (a,Not o) o
10:23:44 <lambdabot> f a b c =
10:23:44 <lambdabot>     case a of
10:23:44 <lambdabot>     Left d -> case b of
10:23:44 <lambdabot>               Left e -> Right e
10:23:44 <lambdabot>               Right f -> Left (d, f)
10:23:46 <lambdabot>     Right g -> Right (c (\ h -> void (g h)))
10:23:54 <ski> @djinn Either (a,Not o) o -> ((a -> o) -> o)
10:23:54 <lambdabot> f a b =
10:23:54 <lambdabot>     case a of
10:23:54 <lambdabot>     Left (c, d) -> void (d (b c))
10:23:54 <lambdabot>     Right e -> e
10:23:56 <jle`> lol
10:24:10 <lyxia> is that indentation legal
10:24:11 <ski> (apparently you needed it for both)
10:24:19 <ski> should be
10:24:35 <ski> you could even dedent the branches further
10:24:59 <lyxia> oh indeed
10:25:11 * lyxia doesn't understand the oddities of Haskell indentation.
10:25:33 <jle`> yeah i usually just pick an indent style and stick with it
10:25:46 * ski often writes stuff like
10:25:52 <ski>   foo x y z = case blah of
10:25:59 <ski>     C a b -> ...
10:26:01 <ski>     ...
10:26:17 <jle`> yeah, i only realized i could do that recently
10:26:21 <ski> (possibly with something [3~`i=' and `blah')
10:26:22 * prsteele just uses whatever Emacs spits out
10:26:52 <lyxia> yeah but it seems different from the case being on a separate line, and the patterns being to the left of it
10:27:04 <ski> it's not
10:27:39 <ski> the implicit `{' is inserted *just* before the first non-whitespace (also excluding comments) token after the layout-introducing keyword
10:28:03 <Tuplanolla> This is even better: "f g x = let\n  y = g x in\n  y"
10:28:12 <ski> i sometimes use that as well
10:28:12 <lyxia> Ah I see.
10:28:33 <ski> (though with `in' on the next line)
10:28:36 <jle`> Tuplanolla: that's neat
10:28:51 <DrEntropy> One guy i play with calls the novice "No Vice", i don't know if he is kidding 
10:28:51 <Tuplanolla> It's not even bad once you get used to it.
10:29:18 * ski possibly first saw it in the MLs
10:29:36 <DrEntropy> *wrong channel sorry. 
10:29:51 * ski is also fond of sometimes using multiply nested `where's
10:32:15 <lyxia> For some reason I don't like those. I prefer using one 'where' per toplevel definition and 'let' otherwise.
10:33:47 <ski> in my case, they're required, or i'd have to rephrase the code
10:34:13 <ski> (because the definitions in each `where' depends on the parameters of the definig equation they belong to)
10:34:28 * ski also misses `local'-`in'-`end' in Haskell .. :/
10:36:19 <ski> (i suppose i could use `let' instead of the `where's, but i'd not read as nicely then, i think)
10:36:36 <jle`> sometimes i end up using where's in let's
10:36:38 <jle`> and i feel dirty
10:36:47 <jle`> s/'//
10:36:56 * ski sees no reason to
10:37:10 <jle`> you are already too far gone, ski
10:37:12 <ski> (`where's attaching to `case' branches can also be nice)
10:37:14 * ski grins
10:37:16 <Tuplanolla> I always let. Fight me.
10:37:27 <Tuplanolla> I like the fact that they're expressions.
10:37:48 <jle`> i wouldn't mind a where-like construct for case branches.  but calling it where might be inconsistent
10:38:00 <ski> why ?
10:38:13 <jle`> right now where is only used as a part of declaration syntax
10:38:17 <ski> no
10:38:25 <ski> > case () of () -> x where x = ()
10:38:27 <lambdabot>  ()
10:38:36 <jle`> :O
10:38:42 <jle`> i thought you were proposing a change
10:38:44 <ski> you can also add guards to each branch
10:38:46 <jle`> i didn't realize that that was already a thing
10:38:47 <ski> no, not at all :)
10:38:52 <jle`> ah yeah, i knew about guards
10:38:53 <ski> standard Haskell98
10:38:54 <jle`> hm
10:39:01 <jle`> i might start using where's there then
10:39:13 <jle`> i don't like how let statements make you lose a level of indentation
10:40:25 <Tuplanolla> They don't, if you write them funny.
10:41:21 <jle`> i'm not a fan of humor
10:42:02 <ski> @remember jle` i'm not a fan of humor
10:42:02 <lambdabot> Good to know.
10:42:20 <jle`> let the record show
10:42:30 <jle`> in  #haskell
10:42:40 <ski> (sorry, couldn't resist. one can use `forget' to remove it, if you'd prefer)
10:42:53 <jle`> it's ok i thinkit's kind of funny
10:42:55 <sigrlami> Does someone encounter build error with ghc 8.0 - gcc' failed in phase `Linker' ? Ubuntu 16.10; can't undestand why it's happening
10:43:16 <amalloy> jle`: surely that means you are not a fan of it
10:43:24 <anewnewbie> Hello, in stephen diehl's What I wish I know when learning Haskell, an HList implementation is described (http://dev.stephendiehl.com/hask/#hlists). It is not immediatelly clear to me how to fmap the HList to get another HList. I would use the HList library but it is not yet supported on GHC 8.0.1
10:43:25 <Tuplanolla> Stop before we reach Russel's paradox, jle`.
10:43:27 <dmj`> jle`: let the record (deriving Show)
10:44:00 <EvanR> if you have an ordered monoid, does this guarantee that for any x > y, theres a z where y + z = x
10:44:03 <anewnewbie> Does anyone have an example of how to do this?
10:44:47 <jle`> anewnewbie: you can't have a Functor instance for hlists
10:44:53 <jle`> it's the wrong kind
10:45:06 <jle`> well, that's just the first issue, heh
10:45:13 <anewnewbie> right, what I really wan to have is the equivalent of mapM_
10:45:34 <anewnewbie> but I figured fmap would be simpler
10:45:46 <EvanR> you need hlist induction
10:45:47 <jle`> anewnewbie: one way would be to get the "lifted" versions
10:45:53 <geekosaur> very little is simple with hlist >.>
10:46:11 <anewnewbie> geekosaur: Yes, I've noticed :)
10:46:54 <jle`> it's a little bit nicer to work with a varient parameterized by a functor
10:47:02 <jle`> *variant
10:47:09 <lyxia> what do you mean?
10:47:19 <anewnewbie> Vinyl?
10:47:53 <jle`> data Prod (f :: k -> *) (ts :: [k]) :: * where Nil :: HList f '[]; (:::) :: f t -> HList f ts -> HList f (t ': ts)
10:48:03 <jle`> to build off of the one you linked
10:48:58 <lyxia> uh, what can you do with that
10:49:32 <jle`> a lot of tasks become simpler
10:49:41 <jle`> you can write a nicer zip
10:49:50 <jle`> and also mapping is nice if f is a GADT
10:50:02 <anewnewbie> mmm
10:50:13 <lyxia> (forall t. f t -> g t) -> Prod f xs -> Prod g xs
10:50:17 <lyxia> ?
10:50:19 <jle`> yes
10:50:32 <lyxia> hmmm yeah, ok.
10:50:34 <jle`> sometimes people call that map1 of a typeclass Functor1
10:51:13 <jle`> otherwise without the f parameter, the closest analogy is (forall a. a -> a) -> HList as -> HList as, and that's a little silly :)
10:52:42 <anewnewbie> jle`: hmm, this seems a bit too complicated for my understanding. I'll take a look and if I can't use it I'll resort to something simpler
10:52:52 <anewnewbie> Thanks though!
10:53:01 <jle`> anewnewbie: do you understand the new parameterized type?
10:53:10 <jle`> sorry, i typed it wrong earlier, HList should be Prod there, heh
10:53:19 <jle`> it's just the same as HList, except you always have (f a)'s instead of a's
10:53:29 <anewnewbie> Oh!, it did look a bit weird :)
10:53:36 <ski> EvanR : consider the commutative idempotent monoid `{0,a,b0,b1,1}' with partial order generated by `0 =< a =< 1',`0 =< b0 =< b1 =< 1', and `0',`+' being nullary and binary supremum wrt that ordering ?
10:53:38 <jle`> yeah, it's different on one line heh
10:53:38 <anewnewbie> I thinks I've seen this before, just a sec
10:53:45 <jle`> yeah, it's called record/vinyl, i think
10:53:57 <jle`> but it's also here http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Data-Type-Product.html
10:54:32 <jle`> so your "fmap" function would be fmap1 :: (forall a. f a -> g a) -> Prod f as -> Prod g as
10:54:44 <jle`> go over and map every (f a) and replace it with a (g a), but of the *same* 'a'
10:55:01 <jle`> that way, the 'as' remains unchanged, because every item is replaced with an item of the same 'a'
10:55:10 <ski> EvanR : hm, on second thought, that doesn't work
10:55:20 <EvanR> i didnt realize you could do it with a finite set
10:55:28 <EvanR> unless it were trivial
10:55:30 * ski wouldn't know
10:55:49 <EvanR> what? im flabbergasted
10:56:01 <ski> ignore my nonworking example
10:56:17 <EvanR> i will not, just to make sure that such a thing needs to be infinite
10:57:02 <ski> (i didn't think of idempotency when i thought i had an example)
10:57:03 <amalloy> EvanR: i don't think so. imagine: instance Monoid Bool where mempty = True; mappend True True = True; mappend _ _ = False
10:57:13 <ski> (so, perhaps one could make one which isn't idempotent)
10:57:30 <jle`> anewnewbie: from there, you could write a traverse1 :: Applicative h => (forall a. f a -> h (g a)) -> Prod f as -> h (Prod g as)
10:57:38 <ski> (.. or rather, idempotency in combination with binary supremum)
10:57:40 <amalloy> which really i guess is just the All newtype
10:58:03 <anewnewbie> jle1`: I see, I think I've got it
10:58:06 <jle`> anewnewbie: but if all you need is mapM_, it'd be a lot easier to just write foldMap1 :: Monoid m => (forall a. f a -> m) -> Prod f as -> m
10:58:22 <amalloy> False < True, but there's nothing you can mappend to False to get back a True
10:58:24 <jle`> foldMap1 is a lot easier.  and you can implement traverse1_ in terms of it :)
10:58:31 <anewnewbie> jle`: Let me see if I can get it to work
10:58:33 <jle`> er i mean, a lot easier than writing a full traversal
10:59:12 <jle`> you can directly write traverse1_, too -- traverse1_ :: Applicative h => (forall a. f a -> h b) -> Prod f as -> h ()
10:59:34 <jle`> traverse1_ / foldMap1 should be simpler than fmap1, even :)
11:00:38 <EvanR> amalloy: does this preserve ordering
11:00:59 <jle`> because the Foldable methods don't need to preserve the structure, but Functor/Traversable ones do
11:01:16 <amalloy> what do you mean by preserve ordering?
11:01:26 <EvanR> if x < y, for all z, x * z < y * z, False < True, but False * False < True * False, False < False which isnt the case
11:02:30 <amalloy> maybe i don't understand what you mean by an ordered monoid. i thought you just meant an Ord instance, but it sounds like you are talking about something else
11:02:30 <EvanR> the interaction of the ordering and the operation adds some structure
11:02:50 <EvanR> just that * respects ordering
11:02:54 <ski> <https://en.wikipedia.org/wiki/Ordered_semigroup>
11:03:02 <EvanR> in my case, talking about a total order 
11:03:06 <ski> oh
11:03:16 <bollu> EvanR: oh, so the monoid operation is also a isotone mapping?
11:03:20 * ski assumed partial order, or maybe preorder
11:03:40 <EvanR> uhm, yeah
11:03:45 <dolio> Requiring that it preserve inequality is kind of unusually strong.
11:04:08 <ski> well, inequality in each argument, one at a time ?
11:04:16 <EvanR> well, im trying to get a strong result ;)
11:04:18 <bollu> EvanR: interesting. I can think of very few natural examples though. (+) and (*) on N come to mind, but what else?
11:04:21 <EvanR> that you can do subtraction
11:04:35 <EvanR> not *
11:04:36 <ski> EvanR : do you want `z' to be unique as well ?
11:04:37 <amalloy> (*) on N doesn't work
11:04:53 <EvanR> no z doesnt need to be unique
11:04:55 <nshepperd1> Monoid of nonpositive numbers with saturating +
11:05:02 <ski> then how can you do subtraction ?
11:05:12 <Hijiri> are we considering N to not have 0
11:05:18 <nshepperd1> Finite, ordered, no subtraction
11:05:19 <EvanR> forget that i called it that
11:05:30 <napping> amalloy: why not? x <= y --> 0*x <= 0*y
11:05:48 <bollu> amalloy: why not?
11:06:14 <amalloy> EvanR said he is working with total ordering, right? otherwise the All newtype around Bool would also qualify
11:06:21 <bollu> EvanR: can you classify all of these?
11:06:33 <bollu> amalloy: ah, N - {0}, sorry :)
11:06:35 <bollu> N+
11:06:35 <EvanR> i dont know
11:06:54 <bollu> EvanR: the structure seems unsually rigid :P
11:07:20 <EvanR> well from what ive seen, total ordering on a *-group makes things pretty rigid
11:07:37 <bollu> EvanR: *-group? what are those? or do you mean * as is wildcard?
11:07:43 <EvanR> semigroup, monoid, group
11:07:44 <napping> amalloy: N with 0 is totally ordered, what's the problem?
11:08:00 <amalloy> napping: x<y does not imply that x*0<y*0
11:08:07 <bollu> EvanR: right
11:08:24 <EvanR> but is it rigid enough to get a "inverse"
11:08:36 <napping> So it's not an ordered semigroup like https://en.wikipedia.org/wiki/Ordered_semigroup
11:08:51 <bollu> EvanR: I don't think so, but I think it is rigid enough that you can show that it only has one generator is what I feel
11:08:53 <bollu> EvanR: idk
11:08:54 <EvanR> i didnt understand nshepperd1s  construction
11:09:11 <EvanR> a generator would solve it
11:09:28 <EvanR> but since Q with + is such a thing, i dont see how thats possible
11:09:32 <bollu> EvanR: why are you considering this object anyway?
11:09:37 <bollu> EvanR: infinitesimal generator?
11:09:55 <napping> amalloy: it's strange to use < rather than <=
11:09:55 <dolio> Is * on positive integers an example?
11:09:59 <bollu> EvanR: I shall proceed to handwave about "lie algebras" :) I don't really now much about them
11:10:02 <bollu> dolio: yep
11:10:08 <amalloy> napping: i agree
11:10:19 <amalloy> that's why i first proposed the All monoid
11:10:28 <bollu> amalloy: why do you want this structure anyway?
11:10:29 <EvanR> dolio: good one
11:10:30 <amalloy> which is a simplified version of *
11:10:34 <amalloy> i don't! EvanR does
11:10:42 <bollu> EvanR: why do you want this structure?
11:11:09 <soLucien> hi guys ! I am trying to figure out this monadic context
11:11:14 <soLucien> so i was trying this : 
11:11:25 <soLucien> stm (VarDecl varName (Just expr)) = updateEnv varName (evalExpr expr)
11:11:28 <soLucien> didn't typecheck
11:11:30 <EvanR> i attempted to do a proof of this:
11:12:01 <soLucien> i peeked on some other solution and ended up with this
11:12:02 <soLucien> stm (VarDecl varName (Just expr)) = do
11:12:02 <soLucien>   result <- evalExpr expr
11:12:02 <soLucien>   updateEnv varName result
11:12:03 <EvanR> if for all t > 0, you have a t' such that 0 < t' < t, then t is dense in R
11:12:09 <soLucien> this did typecheck
11:12:10 <ski> soLucien : `do val <- evalExpr expr; updateEnv varName var' ?
11:12:19 <soLucien> what is the difference ?
11:12:27 <ski> soLucien : ok, also `stm (VarDecl varName (Just expr)) = updateEnv varName =<< evalExpr expr'
11:12:58 <ski> soLucien : `evalExpr expr' doesn't have type `Value', it has type `SubsM Value' (or whatever monad you're using here)
11:13:02 <bollu> EvanR: okay, can't you just show a bijection to the rationals?
11:13:06 <soLucien> yes
11:13:28 <EvanR> that would do it, but thats impossible thanks to your exmaples
11:13:40 <napping> EvanR: are those primes all right? You sa "for all t", but then want to conclude "t is dense in R"
11:13:40 <EvanR> my oriignal proof was not that complex, but it relies on subtraction
11:13:42 <bollu> EvanR: heh, okay, fair
11:14:00 <dolio> EvanR: So, 3 > 2 but there's no 2/3. Right?
11:14:01 <EvanR> napping: i mean T is dense, t : T
11:14:34 <nshepperd1> EvanR: consider [0..10] with saturating + and standard <= reversed
11:14:36 <soLucien> so if i have an expression of type Monad
11:14:41 <soLucien> i can chain stuff with the do
11:14:45 <bollu> nshepperd: what do you mean by saturated?
11:14:48 <soLucien> and to whatever i want
11:15:01 <napping> if for any t : T with 0 < t , you have t' : R such that 0 < t' < t, conclude T is dense in R??
11:15:03 <EvanR> nshepperd1: sure but i was doing strict
11:15:06 <ski> bollu : presumably `max (10,x+y)'
11:15:12 <nshepperd1> bollu: x + 10 = 10
11:15:13 <ski> er, `min'
11:15:19 <EvanR> napping: t' : T
11:15:29 <bollu> nshepperd: ohh, okay
11:15:37 <bollu> nshepperd: was not aware of that notation
11:15:39 <nshepperd1> EvanR: strict what
11:15:44 <EvanR> <
11:15:52 <napping> what else?
11:15:52 <EvanR> dolio: uhm, i dont get that
11:16:09 <napping> {1/n for n in 1,...} has no least element
11:16:18 <EvanR> right
11:16:48 <napping> is that a counterexample?
11:16:52 <EvanR> no
11:16:59 <napping> that's not dense in R
11:17:13 <EvanR> its also not a nordered mooid
11:17:21 <dolio> EvanR: Positive integers with *, x > y doesn't mean that y divides x into an integer.
11:17:32 <napping> what condition on T did you have?
11:17:47 <EvanR> right
11:17:56 <EvanR> that shoots down the subtraction hypothesis
11:17:59 <napping> and isn't that an ordered monoid under multiplication?
11:18:41 <EvanR> oh, interesting...
11:18:49 <soLucien> so ski .. why is that ?
11:19:07 <ski> hm, i suppose just `{1,2,3,6}' is enough, then (with idempotent multiplication)
11:19:09 <napping> do you insist the order be the order from R?
11:19:16 <ski> soLucien : why is what ?
11:19:22 <EvanR> 1/n looks isomorphic to positive N and *
11:19:36 <soLucien> why does the do work but i can't do the non-monadic form
11:19:39 <soLucien> that i tried initially
11:19:57 <soLucien> is there an intuition to it
11:20:02 <soLucien> when i should use the do
11:20:04 <EvanR> napping: no, but i believe whatsever you come up with can be embedded in R such that it respects R ordering
11:20:07 <ski> EvanR : do you require that if `a + b = c', then `a =< c' ?
11:20:32 <EvanR> uhm, is it possible for that to not be the case?
11:20:40 <napping> EvanR: you said you had a proof of something, what't the original statement you were after?
11:20:43 <ski> (iow more or less the opposite of what you're trying to get)
11:21:09 <mnoonan> EvanR: Do you know about the natural partial order relation associated to any monoid?
11:21:14 <napping> with no other conditions on T it's trivially false
11:21:15 <EvanR> napping: i had a broken proof
11:21:28 <EvanR> mnoonan: nope
11:21:30 <mnoonan> it seems like you might be crossing that with whatever other order happens to be present
11:21:48 * ski was having in mind what mnoonan just mentioned
11:21:52 <EvanR> napping: T is an ordered monoid
11:21:53 <mnoonan> EvanR: if you have a monoid M and x,y in M, define x < y when there is a z with x <> z = y
11:22:03 <napping> Do you only require T a subset of (R,<=) which is an ordered monoid
11:22:08 <napping> well, then you need also a unit
11:22:12 <mnoonan> it plays nicely with the monoid structure, but isn't always a "nice" order
11:22:27 <napping> you've got 1/1 thre
11:22:29 <EvanR> you need a unit?
11:22:32 <napping> where did this problem come from
11:22:33 <bollu> mnoonan: <= 
11:22:40 <bollu> mnoonan: 0 + 0 !< 0
11:22:43 <EvanR> mnoonan: interesting
11:22:44 <mnoonan> bollu: ah, agreed.
11:22:44 <napping> if you say "monoid" instead of "semigroup" you are insisting on a unit
11:23:10 <napping> but 1/1 is in that set
11:23:16 <EvanR> yep, there is definitely a 0 such that x + 0 = x
11:23:21 <nshepperd1> In that case i think your theorem is true
11:23:35 <EvanR> wait what
11:23:44 <napping> hmm, if you negate the fractions I think you can make the order agree with R
11:26:04 <EvanR> your monoid 1/n with * is isomorphic to N+ with *
11:26:13 <EvanR> which directly embeds in R
11:26:29 <napping> reversing the order, though
11:26:40 <EvanR> well it was alreadybackwards
11:26:44 <napping> -1/n probably works
11:26:58 <napping> why do you think there is a theorem like that?
11:27:09 <napping> is it an exercise somewhere or what?
11:27:18 <EvanR> we disproved my original question
11:27:27 <napping> or trying to relax assumptions on another theorem?
11:28:05 <napping> I think insistiting T be a subfield of R would make it go through
11:28:34 <napping> even a subgroup of <R,+>
11:28:40 <EvanR> backtracking, prove or disprove: if we have ordered monoid T such that for any t > 0, a t' such that 0 < t' < t, then T is isomorphic to a dense subset of R with ordering in R, and + on R
11:28:48 <EvanR> no fields
11:29:39 <napping> {0}
11:30:08 <EvanR> whats that 
11:30:45 <napping> a counterexample
11:30:53 <mnoonan> he's making your condition vacuously true
11:31:47 <EvanR> isnt {0} a dense subset of R
11:32:06 <napping> uh, what do you mean by "dense subset" of R
11:32:08 <mnoonan> are you thinking of "closed subset"?
11:32:12 <napping> it's certainly not dense in all of R
11:32:12 <EvanR> no
11:32:28 <EvanR> a dense subspace
11:32:49 <napping> a subspace?
11:33:03 <EvanR> if not, then let me add that T is non trivial
11:33:14 <napping> that's probably best
11:33:35 <napping> you want to claim that the image of T ends up being distributed vaguely like Q, right?
11:33:39 <EvanR> the real key here is the infinite microscopic available values
11:33:50 <nathanjackson> What would you say is the best thing about Haskell?
11:33:52 <EvanR> yes, though thats not precise
11:34:30 <napping> nathanjackson: purity and types
11:34:42 <napping> our two main weapons are ...
11:35:07 <EvanR> nathanjackson: the gateway to crazy math topics
11:35:19 <nathanjackson>  napping: Where did you learn Haskell from?
11:35:26 <napping> EvanR: I'm very sceptical that that forces arbitrarily large values
11:35:34 <napping> nathanjackson: long ago
11:36:05 <napping> between the "Gentle Introduction" and the manual and examples in papers
11:36:19 <nathanjackson> napping: way back in the day in a place called West Deer Park
11:37:18 <mnoonan> Am I remembering correctly that there is no way to write Template Haskell code that adds stuff to the module export list?
11:37:20 <EvanR> this is kind of hilarious that i found a paper vaguely related to this https://www.math.lsu.edu/~madden/tomonoids.pdf from LSU math
11:37:30 <mnoonan> (moral judgments aside)
11:37:34 <EvanR> which i attended 
11:37:38 <dmj`> mnoonan: judged
11:38:16 <geekosaur> mnoonan, you remember correctly
11:38:26 <mnoonan> dmj`: ok, but first come over here and finish writing these files that are 50% boilerplate and exports of boilerplate for me
11:38:29 <nathanjackson> buglebudabey: Totally ordered commutative monoids
11:39:07 <napping> EvanR: how about starting with the subset of R >= 0 under +, and taking the image under the bijection tanh
11:39:12 <dmj`> mnoonan: ;) think you can get info about a module, but not generate one. Who/what is generating these files
11:39:41 <mnoonan> I'm writing some code that does generic AST manipulation on a bunch of different kinds of syntax trees
11:39:57 <mnoonan> the code is much nicer when using F-algebra machinery, except..
11:40:01 <EvanR> napping: the question was to give a counterexample or prove it for all T... are you trying to come up with a counterexample?
11:40:15 <mnoonan> it's very noisy to have "Fix Foo" "Fix Bar" all over the place in various patterns.
11:40:31 <mnoonan> so I've been writing and exporting pattern synonyms that wrap up the "Fix" layer
11:40:50 <napping> EvanR: I think that's a counterexample
11:40:51 <mnoonan> but each one of these types has ~30 constructors, so..
11:40:59 <napping> at least if you want to be dense in all of R
11:41:32 <yulax> hi, i'm looking for a good tutorial on recursion
11:41:34 <EvanR> erm, i would be OK if it ended up being dense in an interval of R
11:41:52 <mnoonan> every module starts with a bunch of "pattern X1, .. pattern X30" exports, and ends with a bunch of boilerplate pattern definitions
11:42:10 <napping> EvanR: yeah, you are being pretty vague about what you want
11:42:43 <mnoonan> EvanR: maybe you just want it to have a limit point in R? I don't think you can do better than that.
11:42:45 <EvanR> no, i add 2 more conditions since the question
11:43:11 <napping> do you have a precise goal in mind, or are you trying to see what statements you can prove?
11:43:11 <EvanR> mnoonan: really?
11:43:25 <mnoonan> I may well not be understanding your conditions.
11:43:35 <EvanR> intuitively, it seems like you can use these smaller and smaller bits to construct any number close enough to any other number you want
11:43:46 <EvanR> though it might have to be positive or something
11:44:13 <napping> If you insisted on using exactly +, then probably
11:44:41 <EvanR> it would look like this on the R side
11:44:42 <mnoonan> oh, I missed that you want a monoid homomorphism
11:45:35 <napping> but tanh is a nice order-preserving isomorphism between [0,1) and [0,infty)
11:46:38 <napping> mnoonan: are you already generating the code?
11:46:39 <EvanR> yeah
11:47:00 <EvanR> or tan
11:47:16 <joncol> Does anyone know if Tony Morris' Nicta course is runnable using Stack?
11:47:17 <EvanR> [0,pi/2)
11:47:23 <mnoonan> napping: not the AST type itself, but I'd like to generate the rest (patterns, exports).
11:47:40 <mnoonan> maybe it would be better to generate the whole thing though..
11:48:21 <napping> You could try just not having an export list
11:48:24 * hackagebot postgresql-typed 0.4.5 - A PostgreSQL library with compile-time SQL type inference and optional HDBC backend  https://hackage.haskell.org/package/postgresql-typed-0.4.5 (DylanSimon)
11:48:53 <napping> but if your problem is that the export list is so huge that writing it is much of the work, I don't know what you could do
11:49:12 <mnoonan> I didn't realize that was an option! Though I guess I have written "module Main where..", so I should have known better.
11:50:19 <napping> as long as you can avoid generating anything you don't want to export, that should work
11:50:30 <mnoonan> I think that would work, nothing in the module really needs to be hidden, and I can generate the pattern synonyms with TH.
11:50:38 <mnoonan> thanks!
11:51:30 <napping> Language.TH.Syntax doesn't have anything that looks like an export list
11:52:00 <geekosaur> no, in general you can only splice what is legal for where the splice is, and there's no way to splice into the export list
11:52:26 <geekosaur> TH would have to expand into general tinkering with the compiler innards to change that (which might even be possible...)
11:53:00 <duckbob> :t build
11:53:02 <lambdabot> error:
11:53:02 <lambdabot>     • Variable not in scope: build
11:53:02 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
11:53:28 <duckbob> :t GHC.Base.build
11:53:30 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
11:53:36 <duckbob> what is that!?
11:53:49 <int-e> :t foldr
11:53:51 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:55:11 <geekosaur> part of an optimization mechanism. you can rearrange some things into a fold+build which enables further optimizations, notably fusion. https://www.reddit.com/r/haskell/comments/19p6w3/the_build_function_explained/
11:55:11 <int-e> duckbob: (forall b. (a -> b -> b) -> b -> b) is a list of a's, represented by a foldr over that list; build constructs the list by passing (:) for the first argument and [] for the second one.
11:56:13 <duckbob> Super shrt version: build converts one list representation to another, and is useful as an intermediate code optimization function.
11:56:20 <duckbob> from https://github.com/quchen/articles/blob/master/build.md
11:56:36 <EvanR> napping: i think you asked where this train of thought came from. in this game players take turns choosing moves to execute a time strictly greater than the latest move's time. if they are picking rational numbers, then you could have a michevious player Zeno who plays moves at times closer and closer in a way which holds up the progress of time
11:57:01 <EvanR> so before figuring out what to do about that, i wondered what is the minimal condition on the time type which lets that happen
11:57:14 <EvanR> and if it causes the type to be "like Q"
11:57:43 <duckbob> > let myLambdaList = \cons nil -> 1 `cons` (2 `cons` (3 `cons` nil))  in (+) 0 (build myLambdaList)
11:57:46 <lambdabot>  error:
11:57:46 <lambdabot>      • Variable not in scope:
11:57:46 <lambdabot>          build :: ((Integer -> t0 -> t0) -> t0 -> t0) -> a
11:57:49 <napping> I think having a limit point does it
11:59:04 <napping> Is it a two-player gamer?
11:59:09 <EvanR> N players
11:59:17 <napping> The second player could just take bigger steps if they want
11:59:46 <EvanR> no, because anyone who chooses a time greater than the minimum chosen is ignored and asked again in the next round
11:59:56 <duckbob> foldr f a (build f) = g f a
11:59:57 <EvanR> so Zeno can interrupt everyone infinitely
11:59:59 <duckbob> is that right?
12:00:18 <napping> I don't see how that involves a monoid at all
12:00:31 <napping> and they can do that as long as there is a limit point in the future
12:00:39 <EvanR> since im programming it, i have to specify what the time type can be to play
12:00:42 <EvanR> so i picked ordered monoid
12:00:59 <duckbob> foldr f a (build g) =? g f a
12:01:05 <EvanR> good point
12:01:58 <napping> Going through R may be confusing things
12:02:30 <EvanR> i would like any game which doesnt end to extend past any point in time
12:02:39 <duckbob> :t \g = g (:) []
12:02:40 <lambdabot> error:
12:02:40 <lambdabot>     parse error on input ‘=’
12:02:40 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
12:02:47 <napping> You might be able to say that an ordered monoid T with that propery has a dense order
12:02:50 <duckbob> :t \g > g (:) [] -- sorry
12:02:52 <lambdabot> error: parse error on input ‘>’
12:02:57 <duckbob> :t \g -> g (:) [] -- sorry
12:02:58 <lambdabot> ((a -> [a] -> [a]) -> [t1] -> t) -> t
12:03:07 <EvanR> dense order?
12:03:28 <napping> dense with respect to itself - if t1,t1 in T with t1 < t2, then there is a t3 in T with t1 < t3 < t2
12:03:35 <duckbob> how is that the same as; (forall b. (a -> b -> b) -> b -> b) -> [a] ?
12:04:07 <EvanR> is that a real order theoretic thing
12:04:13 <napping> yes
12:04:23 <napping> https://en.wikipedia.org/wiki/Dense_order
12:05:56 <EvanR> Georg Cantor proved that every two densely totally ordered countable sets without lower or upper bounds are order-isomorphic. thats what i thought
12:06:14 <EvanR> well, the bounds thing is news to me
12:07:09 <EvanR> so if i want to use a dense time type, what can i do to stop Zeno from griefing time
12:07:21 <napping> change the rules
12:07:31 <EvanR> like
12:07:47 <napping> why did you do this minimum of voted times thing anyway?
12:08:28 <EvanR> that models a set of concurrent processes that interrupt each other in the process of doing things
12:08:42 <napping> or, why use a dense time?
12:08:54 <napping> in that case, it makes sense to put a limit on interruption rate
12:09:01 <EvanR> i wanted the option
12:09:19 <EvanR> rather than requiring a non dense type
12:09:46 <napping> If it's like a simulation, that should probably be a per-process setting
12:10:12 <EvanR> i thought of that, each player has a t > 0 which they cant go faster than
12:10:21 <napping> don't restrict the time type, just restrict clockspeeds
12:10:37 <napping> I think most systems rely on some kind of speed bound
12:10:44 <EvanR> for T = Nat, then each player could pick 1
12:11:04 <duckbob> is this game some kind of lorentz boost!?
12:11:21 <EvanR> theres no relativity built in
12:11:57 <duckbob> pretty sure c is a function of g(x)
12:12:06 <EvanR> c is a speed in the motion sense
12:12:13 <EvanR> were talking about frequency
12:12:33 <duckbob> beat packets can exceed c
12:12:43 <duckbob> so c should be infinite
12:13:16 <EvanR> a coin which is falling over spinning reaches infinite frequency, i wonder why time continues ;)
12:14:06 <duckbob> finite slip condition
12:14:14 <Tuplanolla> Once again I have no idea what's going on here, but it sure sounds like heresy.
12:14:34 <duckbob> how do i construct a list using build?
12:15:00 <napping> > build (\c n -> c 1 (c 2 n))
12:15:02 <lambdabot>  error:
12:15:02 <lambdabot>      • Variable not in scope:
12:15:02 <lambdabot>          build :: ((Integer -> t0 -> t0) -> t0 -> t0) -> t
12:15:44 <duckbob> [1,2]
12:15:55 <duckbob> !?!?
12:16:09 <napping> > GHC.Exts.build (\c n -> c 1 (c 2 n))
12:16:11 <lambdabot>  error:
12:16:11 <lambdabot>      Not in scope: ‘GHC.Exts.build’
12:16:11 <lambdabot>      No module named ‘GHC.Exts’ is imported.
12:16:37 <duckbob> > GHC.Base.build (\c n -> c 1 (c 2 n))
12:16:39 <lambdabot>  error:
12:16:39 <lambdabot>      Not in scope: ‘GHC.Base.build’
12:16:39 <lambdabot>      No module named ‘GHC.Base’ is imported.
12:16:44 <duckbob> oh sry
12:17:28 <Tuplanolla> I think lambdabot responds to private messages too, duckbob.
12:17:46 <duckbob> it worked a second ago
12:18:02 <napping> I don't know how to call the right build
12:18:09 <duckbob> :t GHC.Base.build
12:18:11 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
12:18:56 <napping> build isn't very useful except that foldr f x (build l) = l f x
12:18:58 <geekosaur> @let import GHC.Base
12:18:59 <duckbob> this is some kind of voodoo function i swear
12:19:00 <lambdabot>  .L.hs:134:1: error:
12:19:00 <lambdabot>      GHC.Base: Can't be safely imported! The module itself isn't safe.
12:19:00 <bollu>  EvanR context on discussion please?
12:19:04 <geekosaur> ok, that's why
12:19:25 <lyxia> oh GHC.Exts has a lot of cool stuff, I never thought of looking in there.
12:19:37 <duckbob> this breaks my mind
12:19:38 <Tuplanolla> If you're familiar with Scheme, you can think of c as cons and n as nil, duckbob.
12:19:39 <napping> duckbob: I don't think there is ever a reason to call build yourself
12:19:55 <napping> except to implement that optimization
12:19:57 <bollu> :t build
12:19:58 <lambdabot> error:
12:19:59 <lambdabot>     • Variable not in scope: build
12:19:59 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
12:19:59 <duckbob> im writing unfolder
12:20:56 <duckbob> @def build g = g (:) [] :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
12:20:58 <lambdabot>  .L.hs:173:5: error:
12:20:58 <lambdabot>      • Couldn't match expected type ‘(forall b.
12:20:58 <lambdabot>                                       (a2 -> b -> b) -> b -> b)
12:21:09 <duckbob> the whole thing seems completely broken
12:21:58 <napping> that's the wrong type
12:22:18 <duckbob> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
12:22:52 <napping>  @def build g = g (:) [] :: (forall b . (a -> b -> b) -> b -> b) -> [a]
12:23:09 <duckbob> from; https://github.com/quchen/articles/blob/master/build.md and https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#%2B%2B
12:23:20 <napping> > build (\c n -> c 1 (c 2 n))
12:23:22 <lambdabot>  error:
12:23:22 <lambdabot>      • Variable not in scope:
12:23:22 <lambdabot>          build :: ((Integer -> t0 -> t0) -> t0 -> t0) -> t
12:24:26 <napping> oh, wrong place for a type signature
12:24:27 <EvanR> bollu: well i explained that earlier, this is a game which i am using to model concurrent programs
12:25:20 <bollu> EvanR: ah, I see.
12:25:29 <bollu> EvanR: so you want these algebraic sturctures because..?
12:26:04 <duckbob> convergence i guess
12:26:19 <EvanR> the model is in idris  right now so i want to be specific about the interface to this game
12:26:27 <napping> @def build :: (forall b . (a -> b -> b) -> b ->  b) -> [a]; build g = g (:) []
12:26:28 <lambdabot>  .L.hs:174:1: error:
12:26:28 <lambdabot>      Duplicate type signatures for ‘build’
12:26:28 <lambdabot>      at .L.hs:172:1-5
12:26:39 <napping> > build (\c n -> c 1 (c 2 n))
12:26:42 <lambdabot>  [1,2]
12:27:16 <duckbob> that is so cool
12:28:01 <napping> If you want the types mixed into the definition it could be build (g :: forall b . (a -> b -> b) -> b -> b) = g (:) []
12:28:27 <napping> the way you wrote it, you claimed the body evaluated to something with that funny type (when it should just give a [a])
12:28:32 <lyxia> int-e: concatenating the three lines of lambdabot's output would make it quieter
12:29:01 <napping> Then some functions can be written ready for build
12:29:44 <EvanR> bollu: https://github.com/evanrinehart/interruption
12:29:44 <duckbob> so the thing im doing is more like Map, where a type parameter is left polymorphic to allow the user to specify an accessor type.
12:30:19 <EvanR> after talking about dense ordering, i see i probably dont need a monoid
12:30:43 <napping> duckbob: check this
12:30:46 <duckbob> so build says "regardless of the pattern used to compose a sequnce, i can fold it as if it were a list"
12:30:52 <napping> > let enumFromTo' x x' c n = c x (if x == x' then n else enumFromTo' (x+1) x' c n) in build (enumFromTo' 1 10)
12:30:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:31:18 <napping> then you define something like enumFromTo x x' = build (enumFromTo' x x')
12:31:22 <napping> and sum = foldr (+) 0
12:31:40 <duckbob> monoid + dense ordering is Fractional
12:32:01 <napping> and then inling and unfolding stuff will turn sum (enumFromTo 1 10) into foldr (+) 0 (build (enumFromTo' 1 10))
12:32:15 <EvanR> :t fromRational
12:32:16 <napping> and now the fold/build rule applies, simplifying to enumFromTo' 1 10 (+) 0
12:32:17 <lambdabot> Fractional a => Rational -> a
12:32:36 <duckbob> exactly
12:32:56 <napping> Hmm, not tail recursive, I guess something with foldl would be needed
12:33:06 <duckbob> now you an generate things arbitrarily close to one another
12:33:46 <EvanR> kind of ?
12:33:47 <napping> anyway, build isn't for direct use, just for people who want to write new functions that would participate in list fusion
12:33:51 <EvanR> not sure what laws Fractional has
12:34:12 <napping> Also, if the foldr/build rule doesn't fire, the complier tries to get rid of all the builds for more directly written functions
12:34:21 <EvanR> even if it preserves ordering, mapping from rational doesnt necessarily get you dense
12:34:37 <napping> how do you get that?
12:34:42 <EvanR> perhaps if you said, continuous 
12:34:52 <napping> I'm pretty sure an order-preserving mapping does preserve density
12:35:00 <napping> well, order-preserving bijection at least
12:35:26 <napping> [-2,-1) [0,1] is densely ordered
12:35:58 <EvanR> for strict ordering right
12:36:25 <bollu> EvanR: what algebra are you looking for?
12:36:48 <EvanR> this is not the algebra youre looking for *waves hand*
12:37:14 <duckbob> !? sure it is
12:37:27 <duckbob> its dense at least
12:37:40 <bollu> what? -_^
12:37:44 <EvanR> that was a joke
12:38:41 <duckbob> he said he want to constrain them to be dense monoids, so i say use Fractional, as rational numbers are dense countable
12:38:51 <dmj`> is there a recommendation tool to fix cyclical module imports
12:38:52 <EvanR> no
12:39:07 <duckbob> and closed so monoids
12:40:25 <bollu> oh, so you want monoids that are dense with respect to itself?
12:41:21 <duckbob> its a lie group no?
12:41:46 <EvanR> no, i think i just need any ordered type for time
12:42:08 <EvanR> but if you choose a dense one, then its possible for zeno to fuck with the progress of time
12:42:10 <napping> EvanR: what are you planning to analyze or simulate?
12:42:35 <EvanR> pretty much anything, on there right now ihave blackjack
12:42:51 <EvanR> but its using Nat for time
12:43:04 <duckbob> quantised time!?
12:43:12 <EvanR> sure why not
12:43:13 <bollu> EvanR: have you seen the way the active package does it?
12:43:18 <bollu> EvanR: they have a cool notion of time
12:43:19 <EvanR> no
12:43:19 <duckbob> you just broke realisty
12:43:40 <bollu> EvanR: I was investigating it when I was writing animations with diagrams
12:44:03 <duckbob> your dyson expansion would get messed up. i guess you would use summation by parts...
12:44:08 <EvanR> something like a synthesizer which samples some wave at a high frequency, combined with another periodic sampler at a diffeerent frequency, would beenfit from rational time though
12:44:34 <bollu> EvanR: http://projects.haskell.org/diagrams/haddock/Data-Active.html#t:Time
12:44:37 <bollu> EvanR: check that out
12:44:48 <bollu> EvanR: it's the most sensible Time definition I've ever seen
12:45:01 <EvanR> enough integer math nonsense
12:45:44 <EvanR> what is n in Time n
12:45:57 <duckbob> RealFrac
12:46:12 <EvanR> huh
12:46:21 <EvanR> im like Functor Time, and like whats the parameter
12:46:49 <bollu> EvanR: http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFrac n => http://hackage.haskell.org/packages/archive/base/4.7.0.2/doc/html/Prelude.html#t:RealFrac (http://projects.haskell.org/diagrams/haddock/Data-Active.html#t:Time n)
12:46:51 <bollu> fuck
12:47:08 <bollu> RealFrac n => RealFrac (Time n)	
12:47:15 <bollu> so it's sort of advisable to use a RealFrac n
12:47:29 <EvanR> i see that, i still dont know what n is supposed to mean
12:48:22 <duckbob> well you said you wanted it to be dense and closed so i guess your asking what is, and Fractional is i think dense and closed...
12:48:26 * hackagebot legion 0.5.0.0 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.5.0.0 (taphu)
12:48:28 * hackagebot anki-tools 0.1.0.0 - Tools for interacting with Anki database  https://hackage.haskell.org/package/anki-tools-0.1.0.0 (zohl)
12:48:30 <EvanR> i didnt
12:49:02 <duckbob> my mistake
12:49:08 <bollu> EvanR: it's any time that has a RealFrac instance
12:49:14 <bollu> type*
12:49:19 <EvanR> i know...
12:49:33 <EvanR> oh is Time a dummy newtype wrapper?
12:49:48 <bollu> EvanR: no, it's generic, but it's meant to work with RealFrac AFAIK
12:49:54 <bollu> byorgey: ping on Active questions :)
12:50:28 <duckbob> is your point about density that you would like the events to be ordered in a way that you can always insert an event between two events?
12:53:47 <duckbob> type Time = Double
12:54:44 <duckbob> speed of light is infinite in absence of gravity
12:58:53 <duckbob> probably Real is as important as Rational
13:00:51 <EvanR> what
13:01:22 <daig> fun c question: is it safe to `castFunPtr` to change the return type? Say I have a `FunPtr (Ptr Foo -> IO CInt)` and want to throw away the `CInt` and get a `FinalizerPtr Foo`
13:05:17 <monochrom> I think it will be very wrong.
13:05:47 <monochrom> "Ptr Foo -> IO CInt" and "Ptr Foo -> IO ()" are pretty different at the ABI level
13:06:37 <daig> thanks, so the only way is to write new c? ;_;
13:07:09 <Tuplanolla> What are you casting, daig?
13:07:17 <monochrom> I can't answer that. I don't even know why you are thinking along this line.
13:08:38 <duckbob> i think its called the yang mills band gap problem. (re quantised time)
13:09:09 <bollu> duckbob: that's millenial problem, no?
13:09:24 <duckbob> yeah
13:09:52 <daig> Tuplanolla, third party c library has a "free" function that returns an error code if it fails. I want to make it a `FinalizerPtr` so I can stick it in a `ForeignPtr`
13:10:22 <Tuplanolla> What C types are involved, daig?
13:10:22 <duckbob> mass gap*
13:11:25 <duckbob> i would argue the vacuum is the identity and that there exists no mass gap by inductive reasoning on cascading length scales
13:11:34 <duckbob> can i have a million dolla?
13:12:00 <Tuplanolla> Yeah, ($) is in Prelude, duckbob.
13:12:19 <EvanR> constructive physics
13:12:23 <duckbob> :t repeat ($)
13:12:24 <lambdabot> [(a -> b) -> a -> b]
13:12:48 <EvanR> thats awesome
13:12:52 <daig> Tuplanolla, it's `int Free(BigObjectHandle handle)`. So the natural FFI is `Ptr () -> IO CInt`
13:13:12 <duckbob> *le sigh*
13:13:59 <tsani> duckbob: I think you'd prefer `replicate 10^6 ($)` ;)
13:14:05 <EvanR>  > repeat ($)
13:14:09 <duckbob> i assure you i would not
13:14:26 <tsani> mm come to think of it
13:14:29 <duckbob> no instance show (a->b) -> a -> b
13:14:29 <EvanR> [($),($),($),($),...
13:14:30 <tsani> you're definitely right
13:14:35 <greymalkin> :(  Was getting really excited about MFlow -- but it appears to be phasing itself out (too many dead links)
13:16:11 <Tuplanolla> Even when Haskell is uninvolved, you can't cast a pointer to an int and back without summoning demons, daig.
13:16:41 <duckbob> dear year 2000, can i haz $ plz
13:16:44 <MarcelineVQ> how about a uint?
13:16:51 <Tuplanolla> No.
13:16:52 <sssilver> @Tuplanolla those demons *may* be harmless though
13:16:52 <lambdabot> Unknown command, try @list
13:16:54 <monochrom> duckbob, are you done being off-topic?
13:17:15 <sssilver> ultimately it's all a bunch of bytes. If you know those bunch of bytes well, you can cast them to whatever the hell you want.
13:17:48 <sssilver> that's why I always make all parameters, variables, and return types in my C++ functions to be void*. More flexible and powerful that way.
13:18:22 <Tuplanolla> I don't remember if trapping is allowed there, but you can't expect the result to always make sense regardless.
13:18:47 <daig> I'm not casting a pointer to an int, I'm casting a `FunPtr (Ptr () -> IO CInt)` to `FunPtr (Ptr () -> IO ())` I'm just trying to throw away the result
13:18:57 <duckbob> conversely finite state machines produce all results therefor there is no precision in the measurements that would require an arbitrarily fine representation of a system. so lazy evaluation in hylomorphic coarse graining gives rise to a mass gap
13:18:59 <Tuplanolla> Besides void pointers may be incompatible with function pointers.
13:19:13 --- mode: ChanServ set +o monochrom
13:19:19 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.92.40.249.72
13:19:19 --- kick: duckbob was kicked by monochrom (duckbob)
13:19:23 --- mode: monochrom set -o monochrom
13:20:25 <bollu> "conversely finite state machines produce all results therefor there is no precision in the measurements " what?
13:20:37 <monochrom> duckbob was a noise generator.
13:20:38 <johnw> sounds like a markov generator
13:20:48 <MarcelineVQ> I've seen markov's more able to keep on topic
13:20:53 <MarcelineVQ> oop :>
13:21:00 <bollu> oh, I see
13:22:38 <EvanR> ya mama was a noise generator
13:22:57 <monochrom> EvanR, you may be next.
13:23:20 <MarcelineVQ> on a long enough timeline the survival-rate for everyone drops to zero
13:23:27 <Tuplanolla> That's certainly an annoying problem, daig.
13:29:47 <Tuplanolla> You can't really wrangle a FunPtr, because the Fun is elsewhere. You can however discard the result at the call site.
13:33:10 <DrEntropy> It's hard to tell noise generators from real content on #haskell... :):)
13:34:03 <monochrom> yes, but I do that very well.
13:37:28 <Tuplanolla> I reckon you could still perform the cast, assuming the returned int occupies a register as usual, but that's playing with fire, daig.
13:38:30 <monochrom> it may be more benign than I made it sound like
13:39:16 <monochrom> "Ptr X -> IO ()" to "Ptr X -> IO CInt" is of course a disaster. but the reverse direction may be harmless.
13:39:49 <Tuplanolla> Verifying the safety of that at compile time is its own kind of hell, too.
13:39:52 <monochrom> but the safe way is not significantly harder. you could add a wrapper, and it could be Haskell or C.
13:47:20 <V7P32> Hello
13:47:26 <bollu> V7P32: hey
13:47:27 <prsteele> hello V7P32 
13:47:43 <V7P32> How's everybody doing today?
13:48:26 <daig> can confirm it caused a segfault '_'
13:48:27 * hackagebot arpack 0.1.0.0 - Solve large scale eigenvalue problems  https://hackage.haskell.org/package/arpack-0.1.0.0 (ThomasTuegel)
13:48:29 * hackagebot opml-conduit 0.6.0.0 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.6.0.0 (koral)
13:48:58 <monochrom> daig: To be absolutely sure it is the cause, you must verify that the safe way doesn't segfault :)
13:49:33 <joe9> with FFI , Is it safe to return Word8 if the C calling program is expecting an int? Would C automatically do a cast from Word8 to int?
13:49:40 <bollu> V7P32: tired, finishing of a pthreads assignment and sleeping
13:50:19 <plevexier> V7P32: it's friday 5pm, could be worse :)
13:50:51 <monochrom> joe9: No.
13:50:53 <benzrf> joe9: C does not have "casting" except at compile time, as far as i know
13:51:02 <benzrf> oh wait ignore that
13:51:48 <monochrom> In fact you're looking at it from the wrong angle.
13:51:55 <Tuplanolla> Why isn't there CBool for C99 and C11 by the way?
13:52:05 <V7P32> I hear ya! Man, Im just now trying AndroIRC and don't even know how to directly message someone back. The struggles.
13:52:50 <ski> V7P32 : you being by typing their nickname (or the first few characters of it, then press <tab>) ..
13:53:00 <monochrom> C does the conversion, but that's for C-to-C, and only when C source code is seen and all the type sigs are in place etc etc.
13:53:33 <monochrom> with Haskell FFI, you are not really calling C (even though we say it colloquially). you are calling asm. asm is not going to convert for you.
13:54:34 <V7P32> ski still not figuring this out haha
13:54:50 <Maxdamantus> joe9: even in C that's basically invalid.
13:55:14 <Maxdamantus> joe9: if a function is meant to return a uint8_t, it has to return a uint8_t.
13:55:33 <Maxdamantus> joe9: that's enforced based on the signature, just as in Haskell.
13:56:38 <Maxdamantus> If you define some `uint8_t foo(void){ .. }`, you can pass it to a function of type `void (uint8_t (*)(void))`
13:57:50 <Maxdamantus> If you write `return 4;` inside that `foo` definition, the conversion happens there. It still returns a uint8_t.
13:58:27 <joe9> Maxdamantus: oh, ok. Thanks. So, we have to stick with whatever the C return type is. Thanks.
13:58:51 <ph88> Uniplate has similar goals to the original Scrap Your Boilerplate work, but is substantially simpler and faster. -- i see uniplate requires to write some instances of Uniplate http://stackoverflow.com/a/4907163/1833322  and SYB has less boilerplate http://stackoverflow.com/a/2341021/1833322     can anyone comment on this? What are the differences between libraries?
13:58:58 <joe9> monochrom: Thanks.
13:59:49 <ski> how about passing the function defined by `uint8_t *bar(void){ .. }' into the one defined by `void (void *(*)(void))' ?
14:00:08 <ski> (or, of type)
14:00:08 <Maxdamantus> ski: that's also invalid to call.
14:00:16 <ski> nice
14:00:20 <Maxdamantus> The bit that's invalid is actually the call itself, not the pass.
14:00:40 <Maxdamantus> You can convert between any function pointer type in C, but the call has to match the definition.
14:00:44 <ski> what's the difference ?
14:01:10 <Maxdamantus> What I just said.
14:01:15 <Tuplanolla> In a similar vein: you can point past the end of an array, but not access.
14:01:25 <ski> what's the difference between "the call itself" and "the pass"
14:01:27 <ski> ?
14:01:36 * ski nods to Tuplanolla
14:01:37 <ph88> what's this called  |  sum or product ?
14:01:45 <ski> ph88 : in which context ?
14:02:06 * ski can think of three different uses of it, in Haskell
14:02:22 <Maxdamantus> You have to make sure the type of the function pointer part of the call expression has a return type compatible to the return type in the actual definition.
14:02:24 <ski> (i suppose four, with extensions)
14:02:31 <bollu> ski: uses of?
14:02:43 <ski> bollu : where `|' is used, syntactically speaking
14:03:12 <bollu> ski: ah. | for sum types, guards, list comprehensions
14:03:14 <Maxdamantus> So you can pass that function pointer around as something like `void (*)()` if you want, but when you call it you'd have to write something like `((uint8_t (*)(void))fn)()`
14:03:14 <monochrom> [ x+1 | x <- [0..5] ] is one usage
14:03:23 <monochrom> f x | x>0 = ...  is another usage.
14:03:42 <monochrom> When I'm naughty, -- | this is for haddock  is one more
14:03:47 <bollu> data Maybe a = Just a | Nothing
14:04:01 <ski> and the fourth one
14:04:57 <ski> (perhaps another extension could count as a different use as well, not sure)
14:05:00 <bollu> ski: what's the fourth one? TH?
14:05:04 <ski> yes
14:05:11 <ski> quasiquotation
14:05:21 <Tuplanolla> Is it a single token in that context?
14:05:32 <ski> [foo| ... |]
14:05:33 <jle`> ph88: it's called a pipe normally
14:05:57 <ski> Tuplanolla : the first one should be. the second one, dunno
14:06:28 <jle`> it's also use in FunDep syntax
14:06:37 <jle`> and injective type family syntax
14:06:40 <jle`> and pattern guard syntax, heh
14:08:10 <jle`> so that's 7 uses?
14:08:15 <ski> nice :)
14:08:18 <monochrom> "data Maybe a = Just a | Nothing" is a sum type
14:08:30 <ski> aka "algebraic data type"
14:09:13 <ski> > [True|True|True]
14:09:15 <lambdabot>  [True]
14:10:32 <monochrom> actually sometimes I feel like being a pedant and I don't like calling "data C = C1 (Int -> C) | C2 Int C" an algebraic type. It has exponentiation and it is a limit (from the recursion). It is no longer algebraic. It is an analytic type.
14:11:01 <jle`> oh, is exponentiation not considered algebraic?
14:11:02 <ski> it's algebraic in `Int -> C', `Int' and `C' ?
14:11:24 <ski> if it's a finite exponent, it's probably still considered algebraic
14:11:24 <Tuplanolla> It's the self-reference, jle`.
14:11:34 <jle`> ah
14:12:30 <ski> so, `data X = MkX (X -> X)', as an inductive type (no bottoms), should be algebraic, then
14:13:01 * ski ponders
14:13:15 <ski> oh, i suppose that doesn't make sense :/
14:13:17 <monochrom> "algebra" is when you just have polynomials
14:13:17 <soLucien> ski if i have a monad
14:13:23 <soLucien> will fmap work on it ?
14:13:39 <soLucien> i mean inside the do context
14:13:44 <soLucien> does fmap work the same ?
14:13:50 <EvanR> so ... C1 (C -> Int) |... should be algebraic
14:13:51 <monochrom> but C is an infinite series, plus other stuff. it is analytic.
14:13:52 <jle`> fmap is just a normal function
14:14:19 <soLucien> i have data Expr = Call FunName [Expr]
14:14:28 <EvanR> oh nevermind
14:14:31 <EvanR> same issue
14:14:44 <soLucien> i want to fmap evalExpr on the [Expr] list
14:15:08 <ski> soLucien : you probably want `mapM' instead ?
14:15:24 <monochrom> But don't worry, I'm only this pedantic on a few Fridays.
14:15:25 <ski> (or `forM')
14:15:31 <soLucien> okay, i was doing the old x:xs way
14:15:40 <Tuplanolla> Isn't Int -> C fine since Int is bounded, monochrom?
14:15:46 <EvanR> monochrom: or perhaps its because of the double new moon
14:15:49 <monochrom> OTOH I did encounter a few clean slates asking about it.
14:16:40 <bollu> monochrom: what is the series?
14:17:53 <monochrom> bollu, it's easier to illustrate with the simpler "data D = Nil | Cons Int D". This is saying 1 + Int + Int^2 + Int^3 + ...
14:18:06 <erisco> is the join formulation of  m >>= f = join (fmap f m)  ?
14:18:10 <bollu> monochrom: right, I can see that
14:18:22 <EvanR> for example the list type is () + a + a^2 + a^3 + ...
14:18:27 * ski . o O ( `1 / (1 - Int)' )
14:18:46 <EvanR> but thats only finite lists
14:18:53 <ski> (`/' and `-' belong to algebra, right ?)
14:19:25 <ski> erisco, yes
14:19:37 <erisco> fmap is not possible with return and join?
14:19:54 <ski> @src liftM
14:19:55 <lambdabot> liftM f m1 = do
14:19:55 <lambdabot>     x1 <- m1
14:19:55 <lambdabot>     return (f x1)
14:20:06 <bollu> ski: "generating functions of ADTs" would be interesting
14:20:16 <erisco> that example is not particularly insightful
14:20:40 <ski> bollu : talk to byorgey (or read his blog posts) about combinatorial species
14:20:53 <bollu> wait, seriously?
14:21:00 <bollu> ski: link?
14:21:07 <ski> @. pl undo \f m1 -> do x1 <- m1; return (f x1)
14:21:07 <lambdabot> fmap
14:21:10 <ski> bah
14:21:14 <bollu> ohh what the FUCK math is awesome
14:21:35 <EvanR> what the bleep
14:22:45 <bollu> huh, it was his these
14:22:47 <bollu> so cool
14:22:56 <bollu> wow, he has a PhD? :O
14:23:19 <monochrom> erisco, that is an interesting question no one has tried to answer. Because the convention is that when you talk about "M a" at all, the prerequisite is that M is a functor.
14:23:51 <bollu> monochrom: what is the question?
14:24:14 <monochrom> can you have "return" and "join" but no "fmap"
14:24:36 <erisco> it was explained to me that because fmap is derivable from return and bind that that is why Functor is a super class
14:24:57 <monochrom> actually the law for "join" is sufficiently interwined with fmap that it's hard to tear fmap away from the discussion.
14:24:59 <erisco> so the question is if you only define return and join, is fmap derivable from this?
14:25:28 <bollu> monochrom: join implies it's a monoid, and since we're talking of endofunctors, don't you somewhat "naturally" get the functor structure? 
14:26:37 <ski> bollu : <https://byorgey.wordpress.com/tag/combinatorial-species/>,<http://www.math.ucr.edu/home/baez/week202.html>,<http://math.ucr.edu/home/baez/qg-fall2003/>,<http://bergeron.math.uqam.ca/species/>,"Combinatorial Species and Tree-like Structures" by François Bergeron,Pierre Leroux,Gilbert Labelle in 1998
14:26:53 <bollu> ski: thank you
14:26:59 <johnw> erisco: neither return nor join changes the type that is mapped over
14:27:28 <bollu> this maybe stupid, but I started reading the HoTT book by just skipping the first chapter
14:27:33 <bollu> I used to get stuck at some weird nook
14:27:37 <bollu> I said "fuck it" this time
14:27:40 <bollu> let's see how far it takes me
14:27:48 <ski> bollu : also papers by André Joyal, but they all seem to be in french, and not available on the net .. (if you find any in english, do tell)
14:27:55 <bollu> is it possible to buy the book in print?
14:27:57 <bollu> ski: will do!
14:28:26 <monochrom> yes
14:28:32 <ski> bollu : i dunno. i wanted to suggest the local uni library to get it ..
14:28:56 <bollu> ski: I see. I didn't realize the book was in print
14:29:07 <bollu> I'll see. Worst case I'll just get it printed
14:29:20 <ski> (perhaps it wasn't, at the time i looked at it the issue, last)
14:29:31 <bollu> "fundamental infinity-groupoid" woo boy
14:29:44 <bollu> I know all those words, but what the hell is a infinity-gropoid?
14:29:47 <bollu> groupoid*
14:29:55 <monochrom> https://homotopytypetheory.org/book/ has links to lulu.com for physical copies
14:30:34 * ski figured bollu meant the species book
14:30:37 <erisco> what fully characterises functions? some examples… application, identity, return, bind, compose…
14:30:51 <bollu> ski: both
14:31:27 <Tuplanolla> Products and evaluation, erisco.
14:31:39 <erisco> Tuplanolla, can you elaborate please?
14:31:45 <ski> @type \ab -> (=<<) . (return .)  -- erisco, anyway ..
14:31:47 <lambdabot> Monad m => t -> (a -> b) -> m a -> m b
14:31:54 <ski> @type (=<<) . (return .)  -- rather, oops
14:31:55 <lambdabot> Monad m => (a -> b) -> m a -> m b
14:32:03 <johnw> erisco: it depends; in some cases, the laws and parametricity are enough to characterise them; in other cases, only the definition is enough to do so; in dependently-typed languages, you can have a type that's expressive enough to characterise their semantics
14:34:02 <erisco> johnw, I suppose I need to be more particular about what I mean by "characterise"
14:34:23 <johnw> that would help :)
14:35:12 <Tuplanolla> Categorically it can be done as follows, erisco. A function object from a to b is an object z together with the morphism f : z * a -> b such that for any other object y with a morphism g : y * a -> b there is a unique morphism h : y -> z that factors g through f, as in g = f . (h * id).
14:36:12 <Tuplanolla> Here f is evaluation.
14:38:16 <johnw> Tuplanolla: anywhere I can read further about this approach?
14:38:39 <Tuplanolla> You'll have to dig up a category theory book or browse nLab, johnw.
14:38:52 <erisco> hm, for functions, bind is application lifted under the arrow
14:39:02 <johnw> i've read several cases of universal properties, but hadn't seen them related to function objects in general before
14:39:58 <Tuplanolla> I don't have a source handy.
14:40:08 <johnw> Tuplanolla: thanks for the presentation, though, I like it
14:40:28 <EvanR> https://ncatlab.org/nlab/show/exponential+object
14:40:40 <erisco> :t let compose f g = f >>= return g in compose
14:40:42 <lambdabot> Monad m => m a -> m b -> m b
14:40:51 <johnw> EvanR: excellent
14:40:58 <erisco> mm, no =\
14:40:59 <EvanR> im not clear how this relates to monads though
14:42:52 <EvanR> that page doesnt have a good picture of the diagram for exponential 
14:43:03 <EvanR> https://upload.wikimedia.org/wikipedia/commons/1/19/ExponentialObject-01.png
14:46:12 <joe9> For FFI with C enum types, in haskell land, should I treat the value as Word32?
14:46:47 <joe9> and, then read (toEnum) it into a haskell data type defined with deriving Enum?
14:47:11 <EvanR> you might want to implement Storable
14:47:32 <EvanR> possibly with Enum
14:48:28 * hackagebot webdriver 0.8.4 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.8.4 (AdamCurtis)
14:49:59 <erisco> I am thinking of  (a → b) → (a → b → c) → a → c  which is different than bind
14:50:27 <erisco> it is application under the arrow
14:51:01 <johnw> that looks like a bind to me
14:51:22 <erisco> it isn't, it is flip (<*>)
14:51:22 <johnw> if ((->) a) ~ m, then m b -> (b -> m c) -> m c
14:51:56 <glguy_> joe9: You should use CInt for the enums
14:52:05 <joe9> glguy_: ok, Thanks.
14:52:16 <erisco> the bind is  (a → b) → (b → a → c) → a → c
14:56:13 <int-e> :t ap
14:56:15 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:58:03 <lwm> Is there a way to reload a single file in ghci. When I run a plain old `:r`, it reloads all my modules?
14:58:16 <lwm> I tried doing `:r Foo` but it doesn't seem to be working
14:58:19 <lwm> clear
14:58:46 <johnw> erisco: I don't think there's any difference between b -> a -> c and a -> b -> c.
14:59:27 <johnw> how do I ask lambdabot for @src at a particular type again?
14:59:44 <erisco> if we're talking specifically about functions rather than Applicative and Monad then yes, I think they should be the same
14:59:50 <int-e> :t flip ap `asTypeOf` ((. flip) . (>>=))
14:59:51 <lambdabot> (a -> b1) -> (a -> b1 -> b) -> a -> b
15:00:13 <erisco> so there should be a more basic property of functions than both <*> and >>=
15:00:29 <int-e> @src Maybe return
15:00:29 <lambdabot> return = Just
15:00:38 <int-e> johnw: ^
15:01:07 <johnw> not working for >>= for (->) a
15:01:34 <int-e> @src (->) (>>=)
15:01:34 <lambdabot> f >>= k = \ r -> k (f r) r
15:01:44 <johnw> grr, of course
15:02:07 <int-e> johnw: that was my second attempt... it's not really *that* intuitive
15:02:34 <johnw> oh, hmm.. it seems that flip <*> and >>= coincide for ((->) a)
15:02:37 <nitrix> How do I pick a random constructor for a given data type?
15:02:51 <erisco> with a fair dice roll
15:02:56 <nitrix> Maybe even better, randomly constructed habited values.
15:03:11 <nitrix> This seems like a problem quickcheck probably already tackled.
15:03:19 <soLucien> what is the difference between mapM and mapM_ ?
15:03:33 <nitrix> soLucien: mapM_ discards the results.
15:03:35 <erisco> soLucien, look at the types
15:03:39 <soLucien> i did
15:03:51 <soLucien> before i asked this question
15:04:09 <soLucien> didn't understand what m () does
15:04:53 <erisco> the type alone does not tell you uniquely what it does
15:04:59 <erisco> :t mapM
15:05:01 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:05:16 <nitrix> soLucien: You'd normally get `m (t b)`, that is, a monadic value representing a foldable `t` of values of type `b`.
15:05:39 <nitrix> soLucien: An example of such type could be, e.g.  IO [Bool]
15:06:05 <soLucien> so mapM presents a list of monads
15:06:11 <nitrix> soLucien: If you use mapM_, then the applications still happens, but the results are discarded, leaving you with `m ()`, so `IO ()`,
15:06:14 <soLucien> in the [] context
15:06:29 <nitrix> soLucien: Not sure what you mean.
15:06:44 <soLucien> mapM_ was what i was looking for , 
15:06:56 <erisco> sticking to lists, this is  f x1 >>= \y1 -> f x2 >>= \y2 -> … f xn >>= \yn -> return [y1, y2, … yn]
15:07:02 <soLucien> i was getting     Couldn't match type `[()]' with `()'
15:07:33 <erisco> mapM_ on the other hand is  f x1 >> f x2 >> f x3 … >> return ()
15:07:35 <nitrix> soLucien: mapM applies a monadic action on each element of a traversable, it collect the results in the same traversable.
15:07:51 <soLucien> that's greatt
15:08:04 <nitrix> Maybe an example would help:
15:08:06 <soLucien> thanks , i got the difference, and understand what to use in my situation
15:08:18 <nitrix> mapM_ putStrLn ["Hello", "World!"]
15:08:57 <nitrix> Gives you `IO ()`, instead of `IO [(), ()]` if you used mapM.
15:09:15 <soLucien> () () is the result of each of the calls
15:09:17 <erisco> you mean IO [()] or return [(), ()]
15:09:31 <soLucien> great
15:09:41 <nitrix> erisco: It cannot be `IO [()]` for mapM_.
15:09:55 <erisco> "instead of `IO [(), ()]` if you used mapM"
15:10:28 <nitrix> Oh, yeah.
15:10:57 <int-e> johnw: they don't coincide; if you look closely, the second argument has its arguments flipped.
15:11:04 <nitrix> That's an interesting mistake, conflating values and types.
15:12:08 <nitrix> Dependent typing! :D
15:12:56 <johnw> int-e: right; I meant they are the same up to isomorphism
15:14:08 <erisco> IO doesn't have constructors, and () and () have the same name, and [x] and [x] are different things
15:14:21 <erisco> some syntactic confusion
15:36:35 <EvanR> has anyone had success with ghcjs and something like elektron
15:38:00 <Vandelay> hi, how can i turn a string into a list of strings (each element in the list being a string) eg "meh" -> ["m", "e", "h"]
15:38:10 <Vandelay> complete noobness
15:38:44 <grantwu> > map ([]) "meh"
15:38:46 <lambdabot>  error:
15:38:46 <lambdabot>      • Couldn't match expected type ‘Char -> b’ with actual type ‘[t0]’
15:38:46 <lambdabot>      • In the first argument of ‘map’, namely ‘([])’
15:39:02 <grantwu> hrm, darn
15:39:12 <grantwu> well there's always
15:39:22 <grantwu> map (\x -> [x]) "meh"
15:39:32 <grantwu> > map (\x -> [x]) "meh"
15:39:34 <lambdabot>  ["m","e","h"]
15:39:44 <grantwu> @pl map (\x -> [x]) "meh"
15:39:44 <lambdabot> map return "meh"
15:39:45 <Vandelay> much love :D thanks
15:40:01 <grantwu> map return...? it's rather weird to be dropping into the list monad but shrug
15:40:15 <Tuplanolla> Shorter: map pure
15:40:30 <grantwu> or not dropping into but using a function from the monad definition
15:40:33 <ntpttr> who
15:40:37 <grantwu> > map pure "meh"
15:40:39 <lambdabot>  error:
15:40:39 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M268652729832...
15:40:39 <lambdabot>        prevents the constraint ‘(Show (f0 Char))’ from being solved.
15:40:48 <ntpttr> oops wrong window there
15:40:59 * ntpttr sees himself out
15:41:07 <Tuplanolla> > pure <$> "meh" :: [String]
15:41:09 <lambdabot>  ["m","e","h"]
15:43:35 <ski> > pure <$> "meh" `asTypeIn` concat
15:43:37 <lambdabot>  ["m","e","h"]
15:48:30 * hackagebot chart-unit 0.1.0.0 - A set of native haskell charts.  https://hackage.haskell.org/package/chart-unit-0.1.0.0 (tonyday567)
15:49:13 <grantwu> :t asTypeIn
15:49:14 <lambdabot> a -> (a -> b) -> a
15:49:32 <grantwu> @src asTypeIN
15:49:32 <lambdabot> Source not found. My mind is going. I can feel it.
15:49:34 <grantwu> @src asTypeIn
15:49:34 <lambdabot> a `asTypeIn` f = a where _ = f a
15:49:34 <lambdabot> infixl 0 `asTypeIn`
15:58:20 <soLucien> okay so i have a file that i can execute using runhaskell
15:58:34 <soLucien> it uses module Main (main)
15:58:43 <soLucien> the file name is Subs.hs
15:58:48 <soLucien> now i want to import this file
15:58:55 <soLucien> into my Tasty tests file
15:59:03 <soLucien> and use its functions
15:59:12 <soLucien> however, it says that File name does not match
15:59:22 <geekosaur> you can't, generally. refactor so the things other than main are in a module
15:59:27 <soLucien> how would you guys get over this ?
15:59:55 <soLucien> how do i refactor this ?
15:59:56 <geekosaur> (even if you could get past your problem, you can't link against it)
16:00:35 <soLucien> should i create a separate file
16:00:38 <soLucien> Main.hs
16:00:49 <soLucien> and put the module main inside it
16:00:50 <soLucien> ?
16:01:30 <soLucien> and then keep the rest of the logic in Subs.hs ?
16:02:08 <geekosaur> yes
16:02:15 <geekosaur> importing that module into Main.hs
16:18:39 <saulzar> I've been playing around with ways to do static dimensions for an arbitrary Tensor shapes, seems tricky get really good type inference behavior. Interested if there's anything out there already or if anyone has any ideas on this kind of thing... https://gist.github.com/Saulzar/568665c16506cbe2068123350cee9904
16:20:23 <saulzar> Explored three ways of writing a 'concat' function.. to append arrays together, first with a type function to compute output shape - which seems quite bad for inference, second with explicit constraints .. third using classes to try to help inference a bit
16:21:55 <Alper> Hello, I have a beginner question typeclasses
16:22:05 <Alper> about typeclasses that is.
16:22:39 <saulzar> I'm looking at writing a proper neural nets library for Haskell, I think it'd be a great fit along with Pipes etc. and there's not an enormous amount of work if you just defer most of the work to already written GPU libs ..e.g. NVidias cudnn
16:23:07 <saulzar> Alper, Ask away :)
16:23:13 <Alper> Are typeclasses in Haskell similar to interfaces in Java / C#?
16:24:04 <geekosaur> not reallt
16:24:15 <saulzar> Alper, A little - they're the most similar to interfaces - but quite different in other ways
16:24:15 <jle`> i think they are comparable
16:24:25 <jle`> thinking of them as interfaces as a good starting point for learning more about them, i think
16:24:30 <sbrg> i don't think it hurts to think of them a bit like that if it's familiar to you
16:24:35 <sbrg> yeah what he said
16:24:46 <Alper> great, thanks.
16:25:04 <jle`> fwiw i still think about eq/ord as interfaces
16:25:17 <jle`> don't judge me :|
16:25:25 <EvanR> can you have something like the Read class in java?
16:25:29 <EvanR> :t read
16:25:31 <lambdabot> Read a => String -> a
16:25:49 <Aruro> Alper: typeclasses are collecitons of types with common functions on them
16:25:49 <saulzar> They're serving the same purpose where Eq/Ord are concerned :)
16:26:04 <geekosaur> the problem with thinking of them that way is that the rest of the typesystem isn't like java or c# so trying to apply them the same way tends to lead to type cul-de-sacs
16:26:04 <saulzar> EvanR, No.. because you can't overload by the return type (I think)
16:26:14 <Aruro> Alper: like birds, birds are different but all can fly -> all in typeclass Birds
16:26:19 <jle`> "more expressive/powerful interfaces" is a good starting point i think, until you learn more.  unlike other ill-fated analogies in haskell learning, this one doesn't hold you back as much
16:26:34 <jle`> good point geekosaur 
16:26:34 <EvanR> Aruro hmm, i dunno about this analogy
16:26:52 <Alper> When I see something like Num a => a, I am thinking this is a number but I don't know if it is a integer, double etc.
16:26:57 <Aruro> we already leared that Haskell folks are not good with analogies :D
16:27:07 <Cale> It's like birds. What are birds? We just don't know.
16:27:10 <Alper> But I know it supports some arithmetic functions.
16:27:30 <Alper> Similar to multiple types implementing the same interface in Java / c#
16:27:36 <geekosaur> and this is the point where it diverges: in Java it could be any of them, in Haskell you can *only* assume the things directly in Num
16:27:55 <jle`> ah yeah, i do see that trap often
16:27:55 <geekosaur> you can't query it to see if it does more, all you can know is Num
16:28:13 <jle`> hm
16:28:16 <Aruro> Alper: there are more specific classes for Integers and Doubles
16:28:24 <Aruro> there u can know what it is
16:28:29 <EvanR> Alper: it helps to learn about polymorphism first. when you see a polymorphic type, it means that before you can use it at runtime, a variables will need to be filled in with some concrete type. In the case of Num a => a, a can be any type that has a Num instance
16:28:38 <jle`> "you can think of them as interfaces for haskell types" might be a good starting point, but the picture is still incomplete.
16:28:40 <EvanR> without the Num a =>, a could be anything
16:28:46 <Alper> Aruro that sounds like Eagle and Pigeon implementing the IFly interface.
16:28:59 <Aruro> yep
16:29:03 <jle`> it's not as bad as the "functors are boxes" analogy or any of the other haskell teaching tricks that actively hold people back
16:29:10 <EvanR> containers!
16:29:17 <Aruro> Alper: pretty basic logical idea
16:29:47 <Aruro> can we give it a rest with containers? they worth more than their critics here :D
16:30:46 <Aruro> i love that guy who was telling me that kinds are formulas and containers are bad, and words are also bad
16:30:52 <Aruro> he was true math guru
16:31:13 <Aruro> im still wondering what he was doing in chat though
16:31:14 <EvanR> you werent being abstract enough
16:31:15 <jle`> at their first inception, typeclasses were made to allow principled polymorphisms so that you can write the same function to work on a family of types (like +, ==, etc.), and interfaces in java fulfil a similar design space
16:32:45 <jle`> typeclasses have grown to be something more powerful than we initially had expected/inventend them to be, and the nuances of parametric polymorphism and haskell's type system make that picture a lot different than it does for interfaces in java
16:33:03 <jle`> but i think it's safe to say that they both originally came from a similar need
16:37:46 <Aruro> Alper: definition of typeclass written in haskell is pretty self explanatory? no? class Num a where (someStuff involving _a_)
16:39:29 <EvanR> thats generally what record type definitions look like too, but means something completely different
16:41:41 <lgstate> are clojure transducers just an "init :: r" "accum :: r -> a -> r" and  "postProcess :: r -> r" all bundled into one?
16:46:42 <EvanR> according to a few blog posts about this, a transducer is a reducer transformer
16:46:54 <EvanR> http://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/
16:47:03 <EvanR> and to make that actually work in haskell youll need rank N types
16:48:32 * hackagebot giphy-api 0.5.0.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.5.0.0 (passy)
16:52:58 <athan> Has anyone here seen differing behavior when using `System.Process.proc` to run a process?
16:53:21 <athan> by differing, I mean: supplying arguments via the [String] list, yet it's not supplying the args "correct"Y
16:53:24 <athan> correctly*
16:56:31 <geekosaur> can you show an example?
16:56:53 <soLucien> nice (Map env) = forM_ (Map.toList env) (\(n,v) -> putStrLn $ n ++ " = " ++ nice v)
16:57:12 <soLucien>     Not in scope: data constructor `Data.Map'
16:57:17 <soLucien> how do i fix this ?
16:57:38 <soLucien> data constructor Map
16:57:40 <soLucien> sorry
16:57:51 <soLucien> so i want to pattern match the Map
16:58:06 <soLucien> how can i do this ?
16:58:29 <geekosaur> if you imported Data.Map qualified then you need to use the qualified name
16:58:45 <soLucien> import qualified Data.Map           as Map
16:58:50 <soLucien> that's what i did
16:58:54 <geekosaur> then Map.Map
16:59:18 <geekosaur> it's not unusual to see a double import for that case:  import qualified Data.Map as M    import Data.Map (Map)
16:59:33 <soLucien>     Not in scope: data constructor `Map.Map'
16:59:41 <geekosaur> that said, I am not sure you can match a data constructor for Map at all because those are hidden
16:59:42 <geekosaur> so don
16:59:43 <geekosaur> t
16:59:52 <soLucien> what can i do then ?
16:59:52 <geekosaur> you don't actually need the constructor there
16:59:59 <geekosaur> nice env = ...
17:00:03 <geekosaur> you need no data constructor
17:00:19 <geekosaur> and the constructors, could you see them, are not what you think
17:03:04 <EvanR> maybe we could get a 50% savings on import lines if we could do double imports on one line
17:03:45 <athan> geekosaur: I can, but I think I may ignore this issue for now
17:03:49 <EvanR> and before you tell me to put a semicolon, maybe we can get 50% savings on double import line widths with some snazzy double import syntax
17:04:00 <athan> I manually `unwords`'d the array and command together, and that actually worked :\
17:04:00 <EvanR> thats 75% savings right there
17:04:10 <geekosaur> it's been bikeshedded at least once on cafe...
17:09:32 <geekosaur> athan, I am curious... but is this Windows? it's kinda a mess there because Windows doesn't natively use separate parameter strings
17:10:05 <geekosaur> so the proc form has to be flattened into a string and then the receiving program breaks them up again, and if they don't agree as to the convention things go wrong
17:10:12 <Welkin> lol
17:10:17 <Welkin> athan? using windows?
17:11:02 <soLucien> http://lpaste.net/9129401356463898624
17:11:09 <soLucien> i'm trying to replace line 34
17:11:12 <soLucien> with line 24
17:11:20 <soLucien> however, i can't get the types right 
17:11:27 <soLucien> what is different ?
17:11:33 <athan> geekosaur: Right? ubuntu :\
17:11:58 <geekosaur> athan, then I'd check what the strings are composed of
17:12:06 <athan> I have haha
17:12:16 <athan> I've logged the unworded string, run it, works fine
17:12:27 <geekosaur> soLucien, this is not quite what you claimed it is. you need a constructor for Value, not for Map, and I don't know what those are
17:12:52 <soLucien> env is Map Ident Value
17:12:59 <soLucien> Ident is String
17:13:11 <geekosaur> data Value = ... | WHATISTHIS? (Map Ident Value) ...
17:13:45 <soLucien> Value is something that i'm importing from SubsAst
17:13:45 <Maxdamantus> athan: are you running something via a shell?
17:13:51 <soLucien> it's abstract synthax tree symbol
17:13:59 <soLucien> so instead of nice env
17:14:01 <soLucien> it should be 
17:14:09 <soLucien> nice ?? 
17:14:18 <geekosaur> soLucien, you are not understanding
17:14:20 <athan> Maxdamantus: I _am_ running fish as my primary chsh shell
17:14:26 <athan> which is nonstandard and breaking :)
17:14:29 <Maxdamantus> athan: I mean through `proc`
17:14:46 <Maxdamantus> Something like `proc "/bin/sh" ["sh", ..]`
17:14:52 <athan> No I am not
17:14:55 <geekosaur> Value consists of: IntVal, TrueVal, FalseVal, StringVal, UndefinedVal, ArrayVal, and *some constructor name* meaning it has a Map Ident Value within it
17:15:07 <geekosaur> what is *some constructor name*?
17:15:42 <Maxdamantus> athan: okay, well passing the argument "foo bar baz" and passing the arguments "foo", "bar" and "baz" are quite different.
17:16:06 <athan> Maxdamantus: ? How do you mean?
17:16:26 <Maxdamantus> athan: if you're running a program that expects a single argument with delimeters, then naturally you'd convert your data into a single string before calling it.
17:16:36 <athan> my code looks like `proc "foo" ["--arg=\"arg1\"", "--arg=\"arg2\""]`
17:16:56 <soLucien> data Value = IntVal Int | TrueVal | FalseVal | StringVal ...... etc
17:17:03 <soLucien> i have nice for all of them
17:17:18 <Maxdamantus> The first value in that list should probably be the name used to invoke the executable.
17:17:28 <soLucien> now i want a nice for a String -> Val map
17:17:31 <geekosaur> soLucien, you are doing a very good job of not answeing the question
17:17:37 <athan> ?? dang, why is that Maxdamantus?
17:17:37 <lambdabot> Plugin `compose' failed with: user error (Unknown command: "")
17:17:56 <geekosaur> soLucien, please add the full definition of Value to your paste
17:18:17 <Maxdamantus> athan: dunno. Probably so programs know what to print in help text.
17:18:47 <Maxdamantus> athan: eg, if you write `ls --help` or `/usr/bin/ls --help`, the program will know how it was invoked and usually include the right form in the first line.
17:19:00 <geekosaur> athan, lose the embedded quotes
17:19:07 <soLucien> http://lpaste.net/9129401356463898624
17:19:17 <geekosaur> those are only needed in the shell, and you are avoiding the shell
17:19:32 <soLucien> my apologies , i did not understand the question properly
17:19:39 <Maxdamantus> $ //../././//../bin/./ls --help | head -1
17:19:39 <Maxdamantus> Usage: //../././//../bin/./ls [OPTION]... [FILE]...
17:19:48 <geekosaur> (depending on what arg1 and arg2 are, you may not actually need them in the shell either; superstitious quoting is common)
17:20:22 <geekosaur> soLucien, you don't have an env in there anywhere
17:20:45 <geekosaur> nor a map of any kind
17:20:57 <geekosaur> it will be difficult to extract a map from something that doesn't have a map in it
17:22:39 <geekosaur> soLucien, you cannot write your `nice` to accept either a Value or a Map; either the Map has to be available as a variant of Value, or you need a separate function for it
17:23:23 <geekosaur> *possibly* you could use a typeclass for this the way Show does, but you might still need to wrap the Env in a constructor if you ever find yourself wanting to support some other variety of Map
17:24:24 <Maxdamantus> Oh, actually, proc does that for you, nvm.
17:25:15 <geekosaur> `proc "foo" ["--arg=arg1", "--arg=arg2"]`
17:26:36 <geekosaur> the quotes that were there were to tell the shell how to break it up correctly and not to expand things that look like variables or file wildcards, etc. if you use proc, you are handling that yourself and not involving the shell
17:26:47 <geekosaur> so you don't need shell quotes
17:28:02 <Maxdamantus> In most shells you should be able to write `echo` at the beginning of the command and pretty much see what it actually passes.
17:28:21 <Maxdamantus> except it adds spaces between the arguments there which can't be disambiguated from spaces within arguments.
17:28:35 <geekosaur> but with --options (or -options for that matter) you'd need a preceding -- to turn option processing off for echo
17:29:13 <Maxdamantus> echo in bash doesn't seem to handle --
17:29:14 <athan> geekosaur: ! oh wow okay
17:31:18 <geekosaur> echo is in fact a bit nightmarish in that regard, different shells do different things and the one in /bin or /usr/bin probably does something else
17:31:31 <geekosaur> and historically there were two variants that did different things
17:32:08 <geekosaur> autoconf-generated configure scripts have a big chunk of crud at the top to decipher exactly what perversions the local "echo" has
17:32:55 <Maxdamantus> cat <<<"hello world"
17:33:03 <Maxdamantus> or is <<< bash-specific?
17:33:06 <geekosaur> it is
17:33:10 <Maxdamantus> Damn.
17:33:56 <Maxdamantus> Probably also wasteful spawning `cat` processes to do things that are likely built-in if you use `echo`.
17:34:17 <geekosaur> yep
17:34:37 <geekosaur> although these days you'd need to be on one of those tiny arm boxes to notice, probably
17:34:52 <caente> quick question, I've been wanted to start taking haskell seriously, as my "next" programming lang, I've been working with scala for the last few years, very focused on the functional aspect of it. I've read about haskell, I'm already relatively familiar with its syntax. But what's worries me is all the language extensions I keep seeing at the top of haskell files, and I read somewhere that they are almost intrinsic to the l
17:34:52 <caente> anguage. Do the make it hard to read code if one is not familiar with what they are bringing? In other words, is it necessary to understand every single language extension in the top of a given file to understand what the code is doing? 
17:34:59 <Maxdamantus> or cygwin.
17:38:07 <EvanR> caente: i did haskell for a long time not knowing what most extensions did, and learned them incrementally 
17:38:10 <grantwu> Does anyone have any tips for dealing with https://ghc.haskell.org/trac/ghc/ticket/5539 sort of thing
17:39:01 <caente> that's encouraging evanR
17:39:24 * EvanR checks how many are used in game project
17:39:55 <grantwu> We're using megaparsec and attempting to aggressively inline as per the module author suggests
17:39:59 <soLucien> so geekosaur
17:40:09 <soLucien> basically it works in the lambda function
17:40:13 <soLucien> but i cannot extract it
17:40:37 <soLucien> i mean the version on line 46 typechecks
17:40:40 <EvanR> caente: huh, im using on average 1 extension per file for stuff like TupleSections, LambdaCase
17:40:58 <EvanR> which you dont really need, but they make certain things slightly shorter
17:41:02 <soLucien> but i cannot extract the method to place it on line 24
17:41:05 <EvanR> but DeriveFunctor is kind of a time saver
17:41:16 <geekosaur> soLucien, you can extract it, what you cannot do is try to use it in a function Value -> ...
17:41:25 <geekosaur> because a Map Ident Value is not a Value
17:41:44 <soLucien> geekosaur i'm doing this to support unit testing
17:41:54 <soLucien> basically this file allows me to read a AST file
17:42:06 <soLucien> and print out the env at the end of the evaluation
17:42:12 <soLucien> what i want is to put it in HUnit
17:42:31 <geekosaur> then make a different function that is Env -> String
17:42:42 <geekosaur> don't try to do it in nice :: Value -> String
17:42:56 <soLucien> well i want nice to be Env-> String
17:43:03 <EvanR> caente: certain real life frameworks may be using lots of extensions, in which case you probably have to understand them all to hack on the framework itself
17:43:03 <soLucien> or nice'
17:43:16 <EvanR> but not necessarily to use it
17:43:53 <geekosaur> soLucien, so define that. don't try to do it as part of the nice :: Value -> String that you already have
17:44:13 <soLucien> i tried .. the issue is Env is not exported
17:44:21 <soLucien> can i somehow do it so that 
17:44:53 <soLucien> it is not exported ? I mean on line 46 it doesn't seem to care
17:45:22 <geekosaur> Env is just a type alias
17:45:42 <geekosaur> nice' :: Map String Value -> String
17:45:48 <soLucien> great
17:48:33 * hackagebot legion-extra 0.1.0.1 - Extra non-essential utilities for building legion applications.  https://hackage.haskell.org/package/legion-extra-0.1.0.1 (taphu)
17:48:35 * hackagebot readme-lhs 0.1.0.0 - See readme.lhs  https://hackage.haskell.org/package/readme-lhs-0.1.0.0 (tonyday567)
17:49:55 <geekosaur> you could have gotten that from ghci, import the file and :t \res -> forM_ (Map.toList res) (\(n,v) -> putStrLn $ n ++ " = " ++ nice v)
17:50:37 <geekosaur> although actually that is not -> String, it is -> IO ()
17:50:44 <soLucien> putStrln expects smth io
17:50:55 <geekosaur> so actually, nice' :: Map String Value -> IO ()
17:50:55 <soLucien> i yes
17:51:28 <soLucien> can i convert it to string somehow
17:51:50 <soLucien> instead of putstrln use smth else?
17:52:25 <soLucien> HUnit will compare strings
17:52:29 <soLucien> not IO()
17:52:31 <geekosaur> you would replace the putStrLn $ n ++ " = " ++ nice v with something that produced a string
17:52:45 <geekosaur> in fact, you have most of it there already
17:52:53 <soLucien> like show ?
17:53:07 <geekosaur> you don't need show
17:53:14 <geekosaur> look at what is there, think about what you need from it
17:54:57 <soLucien> i shouldn't use forM_ then
17:55:04 <soLucien> i'm not in the IO context anumore
17:55:07 <soLucien> anymore
17:56:26 <geekosaur> correct
17:57:03 <geekosaur> so I'll give you a hint: one thing you need is just a removal, and the other is replacing forM_ with something simple that is in the Prelude
17:57:29 <soLucien> i removed the putStrln already
17:57:31 <geekosaur> what the heck, I'll throw in that second part too: it's unlines
17:57:33 <soLucien> map ?
17:58:06 <geekosaur> well, not exactly.
17:58:53 <soLucien> unlines
17:58:57 <soLucien> and  somethign else
17:59:00 <soLucien> like map
17:59:03 <soLucien> to convert the tuple
17:59:05 <soLucien> into a string
17:59:07 <geekosaur> you're not very good at this so I suppose I need to provide it.   unlines $ map (\(n,v) -> putStrLn $ n ++ " = " ++ nice v) (Map.toList res)
17:59:34 <caente_> EvanR: I'm a little worried about the ecosystem, coming from scala, where the ecosystem is not very homogeneous, I wouldn't wan to walk into another caveats minefield...
17:59:35 <soLucien> i got the unlines $ map
17:59:45 <geekosaur> we want the non-monadic thing, and for is just flipped map
17:59:47 <soLucien> but not the putStr:m
17:59:58 <geekosaur> oh whoops forgot to delete thart
18:00:09 <caente_> I asked about the lang extensions because they seem to be where most lang caveats might come from
18:00:35 <geekosaur> unlines $ map (\(n,v) -> n ++ " = " ++ nice v) (Map.toList res)
18:01:25 <soLucien> yes !
18:01:29 <soLucien> thanks , geekosaur
18:01:40 <soLucien> i would have probably gotten to this as well
18:01:47 <soLucien> but it would take me 1 more hour
18:02:09 <soLucien> but i understand everything we did
18:03:34 <ReinH> excellent!
18:20:35 <behappy> hello every one
18:20:58 <benzrf> hi behappy
18:21:15 <behappy> i'm new to haskell
18:21:18 <behappy> hahah
18:22:12 <behappy> and i holp i can get some help
18:22:19 <behappy> learn haskell is a hard way
18:22:31 <benzrf> you might find #haskell-beginners more helpful if you're new :)
18:22:38 <behappy> i'm from china
18:22:44 <saulzar> Also, just ask any question :)
18:22:45 <benzrf> 你好
18:22:56 <behappy> 你好
18:22:59 <benzrf> there's #haskell-cn, i think!
18:23:03 <benzrf> i don't know how active it is
18:23:12 <behappy> i will try
18:23:55 <behappy> i'm now learn this: https://github.com/NICTA/course
18:24:43 <Welkin> benzrf: 跟说英语！
18:25:09 <behappy> in the FileIO.hs I got confused about:    lift2 (<$>) (,) readFile
18:25:37 <behappy> readFile :: String -> IO String
18:26:07 <benzrf> Welkin: 我不知道“跟”
18:27:08 <behappy> how can "lift2 (<$>) (,) readFile" equals "List String -> IO (List String)" 
18:27:46 <behappy> ow can "lift2 (<$>) (,) readFile" equals "List String -> IO (List (String, String))"
18:28:23 <benzrf> what type is lift2?
18:28:36 <behappy> just like liftA2
18:28:38 <dibblego> Apply f => (a -> b -> c) -> f a -> f b -> f c
18:28:46 <dibblego> s/Apply/Applicative
18:29:05 <benzrf> what the fuck?
18:29:08 <benzrf> that doesn't look well-typed
18:29:16 <behappy> func1 :: String -> Maybe (String, String) func1 = liftA2 (<$>) (,) func2  func2 :: String -> Maybe String func2 a = Just a
18:29:24 <dibblego> it is well-typed
18:29:25 <behappy> this works too
18:29:35 <benzrf> :t liftA2 fmap (,) readFile
18:29:37 <lambdabot> FilePath -> IO (FilePath, String)
18:29:46 <benzrf> oooh wait, i see
18:29:50 <benzrf> ok
18:29:59 <benzrf> behappy: the Apply is not IO - it's ((->) FilePath)
18:30:46 <behappy> look at this: func1 :: String -> Maybe (String, String) func1 = liftA2 (<$>) (,) func2  func2 :: String -> Maybe String func2 a = Just a
18:30:51 <behappy> it's the same
18:31:41 <soLucien> so i'm getting this error when running my test .. where is the IO coming from?
18:31:41 <behappy> i just can't understand : liftA2 (<$>) (,) func2
18:31:42 <soLucien> http://lpaste.net/9129401356463898624
18:31:56 <benzrf> behappy: do you understand how ((->) r) is an Apply?
18:32:23 <behappy> no i don't
18:32:44 <soLucien> i don't understand it 
18:32:57 <dibblego> behappy: when NICTA/course is run in-person, the Applicative exercises are usually done before FileIO, so that this is emphasised
18:33:04 <behappy> instance Applicative ((->) t) where
18:35:11 <behappy> ((->) t)  make me confused too
18:36:01 <dibblego> @type lookup
18:36:02 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
18:37:13 <behappy> Prelude> :k (->) (->) :: * -> * -> *
18:37:45 <benzrf> behappy: imagine that a value of type "a -> b" is a value of type "b" that has some holes in it, and you need to give an "a" to plug those holes
18:38:10 <soLucien> okay i figured out... i was missing some parentheses
18:38:11 <behappy> yes
18:38:13 <behappy> and then
18:38:14 <soLucien> now one more thing :
18:38:20 <soLucien> how do i run the tasty tests
18:38:21 <soLucien> ?
18:38:23 <benzrf> behappy: but in the meantime, if you have an "a -> b" and an "a -> c", you can combine the "b with holes" and the "c with holes" and get something else that still has holes
18:39:35 <geekosaur> soLucien, I wonder if you really want the @?= there at all... separate the test from the test case. from there, http://hackage.haskell.org/package/tasty-0.11.0.4/docs/Test-Tasty.html#g:2
18:40:26 <l_zzie> anyone know who I could bug about downloads *and* signatures only being available over http here? https://www.haskell.org/ghc/download
18:40:29 <soLucien> strOut (runProg (Prog [VarDecl "x" (Just (Number 42))]))
18:40:30 <soLucien>         @?= "x = 42"
18:40:37 <soLucien> what's wrong with this test ?
18:40:37 <geekosaur> that is, testCase should be something you can use without Tasty. then your test is testCase @?= "x = 42", and you use one of the runners
18:41:40 <geekosaur> although I suppose you can leave them together if that's really how you want it and you will not want access to testCase without the actual test
18:42:48 <soLucien> i want the input and output to be kept together .. one AST should be interpreted in a single way
18:43:03 <behappy> in "lift2 (<$>) (,) readFile"  ,"(,)" and "readFile"  both should be "Applicative a"
18:43:08 <soLucien> and it's easier to read if they are in the same place
18:43:22 <behappy> but how "(,)" be a applicative
18:43:51 <l_zzie> :t (,)
18:43:53 <lambdabot> a -> b -> (a, b)
18:43:59 <behappy> yes
18:44:06 <behappy> not a Applicative
18:44:16 <dibblego> behappy: it's not being used as Applicative
18:45:46 <behappy> i can't get u
18:46:33 <Welkin> : liftA2 (<$>) (,) readFile
18:46:36 <dibblego> behappy: first accept, all functions take one argument
18:46:38 <Welkin> :t liftA2 (<$>) (,) readFile
18:46:40 <lambdabot> FilePath -> IO (FilePath, String)
18:46:57 <l_zzie> :t (<$>)
18:46:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:47:11 <l_zzie> :t liftA2 (<$>)
18:47:13 <lambdabot> (Applicative f, Functor f1) => f (a -> b) -> f (f1 a) -> f (f1 b)
18:47:20 <Welkin> the way that is written is confusing by itself
18:47:31 <Welkin> <$> is just fmap
18:47:39 <dibblego> ah fah fuck's sake forget it
18:48:07 <behappy> haha, thank u
18:48:07 <l_zzie> behappy, where is this code? what are you trying to do or understand? 
18:48:24 <behappy> from here: https://github.com/NICTA/course
18:48:34 <behappy> in "FileIO.hs"
18:48:35 <dibblego> behappy: join #scalaz where the author of all of that code can help you
18:48:58 <behappy> thank u
18:48:58 <Welkin> scalaz?
18:49:03 <Welkin> why
18:49:23 <Welkin> I thought you wrote it dibblego 
18:49:53 <l_zzie> behappy: https://github.com/NICTA/course/blob/master/src/Course/FileIO.hs ? I don't see it
18:50:31 <l_zzie> or are you tring to write one of the mocked-out functions?
18:50:51 <dibblego> the code in question is in the answers, not the exercises
18:53:10 <khouli_> hi
18:56:22 <khouli_> can experienced people point me to a list of common haskell functions I should know?
18:56:48 <Welkin> khouli_: undefined
18:56:51 <soLucien> okay so i am running tests using stack exec runhaskell -- -Wall Tests.hs
18:56:59 <soLucien> however, i have defined 2 mains
18:57:03 <Welkin> khouli_: there really isn't
18:57:12 <soLucien> one in my Subs.hs (for command line execution)
18:57:20 <soLucien> and one in my Tests.hs
18:57:34 <khouli_> Welkin: such a list doesn't exist or there isn't a consensus on what such a list should include?
18:57:34 <soLucien> is it possible to somehow keep both ?
18:57:53 <soLucien> and choose which main to run from the command line arguments ?
18:57:54 <Welkin> soLucien: make two executables in your cabal file
18:58:05 <Welkin> and make your program a library that they import
18:58:21 <Welkin> that is the standard way to do it
18:59:04 <Welkin> if you use stack to create a new project template, it will already be set up like this
18:59:26 <Welkin> khouli_: I have to look at docs and search around for the functions I need all the time
18:59:49 <Welkin> if it doesn't exist, you define your own
19:00:07 <Welkin> or if you don't want to import a library for it, or if you don't like how it is implemented
19:00:27 <Welkin> the only ones that are using in everything are the typeclass methods for Functor and Monad
19:00:30 <Welkin> pretty much
19:00:33 <khouli_> Welkin: I'm a beginner looking for basically common functions I should know of just to have a starting foothold
19:00:34 <Welkin> used*
19:00:53 <Welkin> @where learnhaskell --  khouli_: start here
19:00:53 <lambdabot> https://github.com/bitemyapp/learnhaskell
19:00:58 <EvanR> clojure has a list like this, i wish haskell did
19:01:36 <Welkin> foldr/foldl', putStrLn, putStr
19:01:40 <Welkin> can't think of too many more
19:01:43 <khouli_> Welkin: thanks for the link, reading now
19:01:45 <EvanR> i think haskell has just way too many functions for that
19:02:52 <soLucien> is there a haskell function to strip traling newline from a string ?
19:02:56 <soLucien> trailing
19:03:07 <EvanR> :t chomp
19:03:09 <lambdabot> error:
19:03:09 <lambdabot>     • Variable not in scope: chomp
19:03:09 <lambdabot>     • Perhaps you meant ‘chop’ (imported from Data.List.Split)
19:03:12 <EvanR> :t chop
19:03:12 <khouli_> it doesn't need to be everything, but I feel like there does exist a basic set of functions every Haskeller should know and I'd like to just memorize that list to get that out of the way
19:03:14 <lambdabot> ([a] -> (b, [a])) -> [a] -> [b]
19:03:41 <soLucien> chomp as in ruby's chomp ?
19:03:47 <EvanR> khouli_: maybe this http://www.cse.unsw.edu.au/~en1000/haskell/inbuilt.html
19:04:32 <khouli_> EvanR: I did find that but it's slightly more basic than I was hoping for
19:04:58 <grantwu> you are probably better off just becoming more proficient at Hoogle-fu
19:05:05 <Welkin> :t trim
19:05:06 <lambdabot> error: Variable not in scope: trim
19:05:07 <EvanR> less basic than that is to look through the haddocks for base
19:05:26 <EvanR> which essentially consists of a giant list of functions
19:05:34 <geekosaur> if you know it's a newline, try init?
19:05:47 <geekosaur> > init "foobie bletch\n"
19:05:50 <lambdabot>  "foobie bletch"
19:06:06 <khouli_> EvanR: probably not a bad suggestion, do you suggestion online or through command line?
19:06:16 <soLucien> great fix
19:06:22 <EvanR> might as well learn to build haddocks locally now ;)
19:06:22 <soLucien> yes, i know it's newline
19:06:38 <khouli_> grantwu: is the suggested use of hoogle online or through command line?
19:06:40 <soLucien> it's from the unlines :)
19:11:15 <khouli_> what's the term for types that depend on other types? like Maybe; ("dependent-type" seems natural but apparently that's a type that depends on a value)
19:11:45 <dibblego> khouli_: type constructor, in that it constructs a type, there is no dependency
19:12:55 <khouli_> dibblego: I thought "type constructor" could refer to any statement in haskell that defines a new type? even if it doesn't depent on another type
19:13:21 <behappy> problem solved, thank dibblego
19:13:21 <dibblego> khouli_: you might mean data type
19:13:27 <dibblego> behappy: you're welcome
19:14:26 <Welkin> khouli_: there are two namespaces
19:14:33 <Welkin> one for types and one for values
19:14:44 <EvanR> Maybe is a parameterized type, parameterized by some other type
19:14:45 <athan> Hmm. is interruptProcessGroupOf intended to interrupt the parent process as well?
19:14:47 <ReinH> khouli_: "dependency" isn't an accurate way to describe it
19:14:54 <EvanR> another way to say it is Maybe :: * -> *
19:14:58 <EvanR> a function from types to types
19:15:17 <ReinH> Would you say that succ depends on a value??
19:15:20 <khouli_> Real World Haskell gives "data BookInfo = Book Int String [String] deriving (Show)" and then says "BookInfo" is a type constructor; BookInfo doesn't depend on another type
19:15:54 <ReinH> "depend" already means something different
19:15:59 <ReinH> so it's confusing to use it here
19:16:12 <khouli_> ok bad choice of wording, so a function form types to types, is there a common phrase to express that?
19:16:25 <Welkin> yes
19:16:26 <ReinH> "higher-kinded"
19:16:28 <Welkin> a type constructor
19:16:57 <khouli_> what does "depend" mean in a haskell context?
19:17:09 <ReinH> in a type theory context, dependent types are types which depend on values
19:17:25 <ReinH> if you call something a dependent type and you don't mean that it depend on values, that is confusing
19:17:55 <khouli_> fair enough, but as a newbie that does seem odd
19:18:27 <ReinH> All disciplines have their own vocabularies
19:19:16 <EvanR> haskell aint got no dependent types
19:19:44 <khouli_> is there a good way to complete this sentence? "Maybe _ on another type"?
19:20:04 <ReinH> Not really.
19:20:20 <EvanR> Maybe a is a type for any type a, Maybe a has a type parameter
19:20:24 <khouli_> is there a good way to reword it and complete the blank?
19:20:39 <amalloy> khouli_: by adding the "on" there, you've sorta tied everyone's hands
19:20:49 <ReinH> Maybe takes a type (of kind *) and gives a type (of kind *)
19:20:53 <amalloy> Maybe has a type parameter is a common way
19:21:00 <khouli_> amalloy: ah, good point
19:21:50 <athan> If anyone knows the answer, I'd really appreciate any help ._. http://stackoverflow.com/questions/39802378/is-interruptprocessgroupof-intended-to-interrupt-the-process-calling-the-funct
19:21:52 <geekosaur> just saying "depends" is a bit oversimplified, once you start getting into kinds
19:22:09 <EvanR> (a,b) is a type for any types a and b, it has two parameters
19:22:17 <EvanR> :k (,)
19:22:18 <lambdabot> * -> * -> *
19:22:23 <geekosaur> athan, you need to include a flag to createProcess to tell it to put the child in a new process group
19:22:52 <geekosaur> otherwise, yes, the calling program is also in the same process group. and other processes may be as well, especially if for some reason your shell doesn't support job control
19:23:46 <ReinH> :k (,) Int
19:23:48 <lambdabot> * -> *
19:24:06 <ReinH> If you want to be really pedantic, (,) takes a type (of kind *) and gives a type (of kind * -> *)
19:24:15 <athan> geekosaur: !!!! You're fricking incredible, thank you so much
19:24:22 <geekosaur> athan, it's create_group 
19:24:26 <EvanR> by all means lets be pedantic as hell
19:25:02 <athan> thank you :)
19:25:24 <ReinH> I mean, if the question is "what is correct?" then I guess we should try for maximum correctness.
19:26:12 <khouli_> agreed, I just want to know how to best express that concept
19:26:13 <EvanR> correctness sup
19:27:04 <khouli_> is there a special way to refer to types with no type parameters?
19:27:15 <ReinH> The terminology is rather annoying
19:27:32 <ReinH> Some sources refer to them as types of type "type"
19:27:51 <ReinH> We can say "type of kind *" or "inhabited type", since only types of kind * are inhabited by values.
19:28:03 <ReinH> er, types of kind "type", I mean
19:28:23 <ReinH> Often it's clear from context what is meant.
19:28:36 <khouli_> that terminology is a bit rough
19:28:40 <EvanR> Int is a concrete type
19:28:46 <ReinH> You are not wrong.
19:28:48 <EvanR> though i could have just made that up
19:29:09 <khouli_> I was sort of expecting "concrete" might be the word, but it isn't?
19:29:19 <geekosaur> I use it that way but it' not common
19:29:29 <geekosaur> unfortunately, there doesn't seem to be a common term for it :/
19:29:34 <ReinH> It's not widely used
19:29:49 <EvanR> the common way is to say type of kind *
19:29:49 <ReinH> And in fact means something else in other contexts
19:30:01 <geekosaur> (also "concrete" is wrong because `Maybe a` is kind * but has a type variable and therefore isn't really concrete
19:30:08 <ReinH> e.g., http://dreuarchive.cra.org/2002/heise/typeComp.html
19:30:11 <EvanR> which involves a show and dance before you can say stuff like that to beginners
19:30:33 <EvanR> Maybe A is concrete, for whatever A you want
19:30:58 <EvanR> it "has no parameters"
19:31:24 <ReinH> In the literature, * is a "primitive type", except that it is not a type: it is a kind.
19:31:36 <ReinH> We can sometimes call a type of kind * a nullary type constructor.
19:31:46 <ReinH> Which is in opposition to our treatment of functions at the value level
19:31:47 <geekosaur> (except that in ghc8, kinds and types were unified! /o\ )
19:31:53 <ReinH> so () is a nullary type constructor, but not a nullary function.
19:32:15 <ReinH> So yes, plenty of confusion to go around
19:32:17 <khouli_> geekosaur: is there a webpage/paper describing that unification?
19:32:59 <EvanR> keep the confusion alive
19:33:00 <khouli_> ReinH: I'll be honest, I was confused there
19:33:10 <EvanR> make no attempt to establish something reasonably standard
19:33:34 <EvanR> wed just be ruining the party
19:33:57 <ReinH> Kinds are the type of types. If you aren't confused enough yet, I can keep going.
19:34:18 <khouli_> ReinH: I did know that much!
19:34:46 <geekosaur> khouli_, doesn't look like it. release foo has "Support for reasoning about kind equalities, which gives promotion of GADTs to kinds, kind families, heterogeneous equality (kind-indexed GADTs), and * :: *. There is some discussion in DependentHaskell/Phase1, but that's very low-level. I (Richard) have no good user-oriented write-up yet, but there shouldn't be much in the way of new syntax -- just fewer type errors. (​Phab:D808)"
19:34:55 <ReinH> Kinds can themselves have types, which we call sorts.
19:35:07 <ReinH> I don't know what the type of sorts is called. Maybe varieties? I forget.
19:35:11 <geekosaur> which references https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell/Phase1
19:35:16 <ReinH> (They all have the same sort in Haskell.)
19:35:18 <khouli_> ah, I haven't heard the word sort used in that context, now you have me really confused!
19:35:21 <ReinH> And of course this has nothing to do with sorting things.
19:35:27 <grantwu> http://www.bbc.co.uk/worldservice/learningenglish/grammar/learnit/learnitv310.shtml
19:35:33 <geekosaur> one runs out of words for these things
19:35:38 <EvanR> nevermind the type of sorts, whats the kind of sorts
19:35:40 <grantwu> i,i Kinds, sorts, types and even varieties can all be used interchangeably :P
19:36:42 <khouli_> grantwu: is "varieties" really used that way? is it a higher-sort?
19:37:03 <geekosaur> and then there are the languages where they just keep going on forever, like Ωmega
19:37:14 <EvanR> ive seen sorts used to "type" basic syntax elements
19:37:17 <grantwu> khouli_: I know very little about this.  I just googled "kind sort type variety" and found something I thought was funny.  do not take what I said seriously
19:37:21 <EvanR> yet another thing
19:40:39 <geekosaur> khouli_, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#kind-polymorphism-and-type-in-type may be of interest
19:42:20 <khouli_> geekosaur: this is a lot to take in but it's on my to-read pile now, thanks
19:42:27 <geekosaur> yes, yes it is
19:46:10 <saulzar> Does anyone know if I can implement this with GHC TypeLits? Is there a way to convert a TypeLit Nat into a peano nat?  https://gist.github.com/Saulzar/247118bc6f15badbcf05b3abc94830f9
19:46:58 <khouli_> it's getting late here on the east coast of the US but I'll probably be back tomorrow for more drinks of water from this fire hydrant, thanks guys
19:48:33 <EvanR> rock on
19:48:36 * hackagebot scotty-resource 0.2.0.0 - A Better way of modeling web resources.  https://hackage.haskell.org/package/scotty-resource-0.2.0.0 (taphu)
19:48:38 * hackagebot canteven-log 2.0.0.0 - A canteven way of setting up logging for your program.  https://hackage.haskell.org/package/canteven-log-2.0.0.0 (taphu)
19:56:20 <Squarism> Anyone know why facebook choose ocaml over haskell? 
19:57:49 <Welkin> nthere is likely no reason
19:57:59 <Zekka> Did they completely eliminate Haskell? IIRC they use haskell for a few projects, which is probably good for your question because it means there might be a reason in some cases
19:58:01 <Welkin> or the reason is not meaningful
19:58:10 <Zekka> But I haven't ever worked at Facebook so I don't know the situation
19:58:13 <Welkin> there is a team that uses haskell for fraud detection
19:58:20 <Welkin> ocaml is only used for Hack
19:58:24 <Welkin> or whatever it's called
19:58:44 <Welkin> why did they choose php?
19:58:54 <Zekka> It could also just be arbitrary -- the guy running this project liked this language
20:05:45 <evincar> Is there an established way to write "synchronicity-polymorphic" monadic actions?
20:05:56 <evincar> That is, where the caller decides whether to run an action synchronously.
20:06:08 <evincar> My intuition says "free monads".
20:06:27 <evincar> Or some class of which IO and Async are instances.
20:08:08 <evincar> I guess you could always use Async, and toss in a "wait" on the outside if you want?
20:19:53 <grantwu> Is there an idiomatic way to turn a maybe into a single element or empty list
20:20:19 <pavonia> :t maybeToList
20:20:20 <lambdabot> Maybe a -> [a]
20:20:26 <grantwu> aha!
20:20:34 <grantwu> > maybeToList Nothing
20:20:36 <lambdabot>  []
20:20:51 <grantwu> I could've hoogled for this, hrm.
20:33:45 <dmwit_> > foldMap return Nothing
20:33:48 <lambdabot>  error:
20:33:48 <lambdabot>      • Ambiguous type variables ‘m0’, ‘a0’ arising from a use of ‘show_M49220...
20:33:48 <lambdabot>        prevents the constraint ‘(Show (m0 a0))’ from being solved.
20:33:55 <dmwit> > foldMap return Nothing :: [Int]
20:33:57 <lambdabot>  []
20:34:31 <benzrf> Nothing^..traverse
20:34:35 <benzrf> > Nothing^..traverse
20:34:38 <lambdabot>  []
20:34:59 <dmwit> I was trying to come up with something using traverse. That's particularly pretty.
20:35:04 <dmwit> > Just 3^..traverse
20:35:07 <lambdabot>  [3]
20:36:36 <jmorris> im trying to write a function that converts hexadecimal to base64, im using Data.Hex and Data.Bytestring.Base64
20:36:42 <jmorris> hexToBase64 s = encode (unhex s)
20:36:58 <jmorris> i thought this would work by encode is not working how i would expect
20:37:04 <jmorris> and im not sure how to use encode
20:37:15 <Axman6> > M.singleton 7 ["Hello","Goodbye"] & at 7 . traverse . ix 0 %~ toLower
20:37:18 <lambdabot>  error:
20:37:18 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
20:37:18 <lambdabot>        Expected type: (Char -> Identity Char)
20:37:26 <Axman6> hmm
20:37:58 <benzrf> > M.singleton 7 ["Hello","Goodbye"] & ix 7 . traverse . ix 0 %~ toLower
20:38:00 <lambdabot>  fromList [(7,["hello","goodbye"])]
20:38:02 <benzrf> `at' is different
20:38:07 <Axman6> oh bleh, thanks
20:38:20 <dmwit> jmorris: Well, there's not much we can do with what you've said so far.
20:38:21 <Axman6> I've never got my head around the difference between ix and at
20:38:27 <dmwit> jmorris: At the very least you'll have to tell us what you expected.
20:38:30 <Axman6> :t at
20:38:32 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
20:38:35 <dmwit> jmorris: It would be polite to also tell us what happened instead.
20:38:51 <jmorris> i expected it to give a base64 encode string
20:38:59 <jmorris> from a decoded hex string
20:39:16 <dmwit> Any old base64 encoded string? I bet not!
20:39:38 <jmorris> im trying to solve this https://cryptopals.com/sets/1/challenges/1
20:40:14 <benzrf> Axman6: `at' always succeeds, but it focuses on a Maybe
20:40:19 <benzrf> Axman6: `ix' can fail
20:40:22 <Axman6> :t at
20:40:23 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
20:40:24 <benzrf> but focuses on the actual value
20:40:40 <benzrf> > M.empty^..at "foo"
20:40:44 <lambdabot>  [Nothing]
20:40:45 <benzrf> > M.empty^..ix "foo"
20:40:47 <lambdabot>  []
20:40:52 <Axman6> ah, I see
20:41:03 <benzrf> in particular, this means that youc an replace a Nothing with a Just, which lets you *insert*
20:41:06 <benzrf> ix only lets you replace, at best
20:41:16 <dmwit> jmorris: Perhaps you would like something like `case unhex s of Nothing -> {- ??? -}; Just s' -> encode s'`.
20:41:28 <jmorris> hm
20:41:29 <benzrf> so there's no At instance for lists, because it's not clear how it should work
20:41:38 <benzrf> > "abcde"^..at 2
20:41:40 <lambdabot>  error:
20:41:40 <lambdabot>      • No instance for (At [Char]) arising from a use of ‘at’
20:41:40 <lambdabot>      • In the second argument of ‘(^..)’, namely ‘at 2’
20:42:06 <Axman6> man, GHC's error messages sure did get prettier with 8.0
20:42:29 <soLucien> in Tasty is it possible to test for exceptions ?
20:43:08 <soLucien> Should not be able to add boolean values to Strings: FAIL
20:43:09 <soLucien>       Exception: Error "Interpreter error: cannot add boolean values"
20:43:27 <dmwit> jmorris: Actually, `encode <$> unhex s` looks a lot cleaner to me.
20:43:27 <soLucien> this should actually be a OK
20:43:35 <soLucien> because i'm getting that exception
20:43:37 <dkk> hello all
20:43:47 * dmwit waves in dkk's general direction
20:44:11 <dkk> is there someone to help me with reader monad
20:44:18 <dmwit> ?where justask
20:44:18 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
20:44:45 <benzrf> dmwit: you know, i've always hated justask
20:44:58 <jmorris> ok thanks
20:45:04 <benzrf> i ask to ask all the time because if i dont know that someone specific is listening, i feel like i'm shouting into the void
20:45:20 <dmwit> But asking to ask is not shouting into the void?
20:45:35 <benzrf> it is, but it doesn't use as much breath :)
20:45:55 <dmwit> lazy benzrf =P
20:46:15 <benzrf> laziness is a virtue
20:46:22 <benzrf> this is #haskell
20:46:36 <benzrf> dkk: anyway i can probably help you with reader
20:47:19 <dmwit> Perhaps the question is actually the one he asked. In which case the answer is probably "yes".
20:47:29 <dkk> I want to implement a simple binding table with lookup and insert facility with Reader ... is it possible
20:47:41 <EvanR> is the question the question, thats the question
20:47:54 <ania123> hi, any english native speaker here?
20:47:58 <Welkin> no
20:48:04 <EvanR> too late
20:48:05 <Welkin> you cannot modify the contents of reader
20:48:08 <Welkin> it is read only
20:48:27 <dmwit> dkk: That depends. Reader is pretty good for when you want to make no changes (i.e. no inserts) or when changes should be "scoped" to particular actions as in implementations of lexically-scoped DSLs.
20:48:28 <Welkin> you want State instead
20:48:38 * hackagebot canteven-log 2.0.0.1 - A canteven way of setting up logging for your program.  https://hackage.haskell.org/package/canteven-log-2.0.0.1 (taphu)
20:48:40 * hackagebot jose 0.5.0.0 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.5.0.0 (frasertweedale)
20:48:42 * hackagebot canteven-http 0.1.1.2 - Utilities for HTTP programming.  https://hackage.haskell.org/package/canteven-http-0.1.1.2 (taphu)
20:48:50 <EvanR> you probably dont actually want State
20:48:51 <dmwit> dkk: If you want to be able to do inserts in one action and have them stick around for later actions, you probably want State instead of Reader, as Welkin suggested.
20:49:36 <dmwit> :t local -- the way of doing scoped changes to the value being read
20:49:37 <dkk> ohk so that can be done using reader's local or some other hack
20:49:38 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
20:50:00 <EvanR> local is weird
20:50:01 <dmwit> :t modify -- the way of doing changes that will stick around
20:50:03 <lambdabot> MonadState s m => (s -> s) -> m ()
20:50:36 <dmwit> EvanR: local is quite natural for certain things.
20:50:55 <dkk> i wanted this similar functionality but using reader ;;;> lp env = do  47 >   input <- getLine  48 >   case words input of  49 >     ["n",x,"=",y] -> putStrLn ("added " ++x) >> lp (M.insert x (read y::Int) env)  50 >     ["l",x] ->  putStrLn (p $ M.lookup  x env) >> lp env  51 >     _ -> lp env
20:51:09 <dmwit> ?where lpaste
20:51:09 <lambdabot> http://lpaste.net/
20:51:11 <EvanR> also, why is it limited to r -> r
20:51:25 <dmwit> EvanR: Because mtl.
20:51:37 <dmwit> EvanR: You can make a less limited version if you are okay with not being typeclass-polymorphic.
20:51:43 <dmwit> :t mapReaderT
20:51:44 <lambdabot> forall k k1 (m :: k -> *) (a :: k) (n :: k1 -> *) (b :: k1) r. (m a -> n b) -> ReaderT r m a -> ReaderT r n b
20:51:51 <dmwit> not that one =P
20:51:52 <dkk> http://lpaste.net/234327
20:52:08 <dmwit> :t withReaderT
20:52:10 <lambdabot> forall k r' r (m :: k -> *) (a :: k). (r' -> r) -> ReaderT r m a -> ReaderT r' m a
20:52:14 <dmwit> EvanR: there
20:52:48 <EvanR> good, now i can do whatever i want
20:53:06 <dmwit> dkk: I think this would be a fine use case for StateT Environment IO.
20:53:43 <dkk> ohh actually i wanted to know or get a intuition how to use local
20:54:14 <dmwit> This can be done with local, too, I guess, if you want.
20:54:55 <dkk> yes i wanted that thing but in addition i don't want to pass the env as an argument always
20:55:03 <dmwit> The clause of interest would be the `["n",x,"=",y]` one; which would change to something like `liftIO (putStrLn ...) >> local (M.insert x (read y::Int)) lp`.
20:59:44 <grantwu> Hlint just suggested a functor law refactor
20:59:59 <grantwu> We need a clippy avatar for HLint
21:00:23 <grantwu> "Hi! It looks like you're attempting to use: Functors.  Do you want me to fix your code?"
21:01:44 <dmwit> > fmap fix return "lol"
21:01:46 <lambdabot>  "lol"
21:05:18 <ReinH> a neat trick
21:06:00 <EvanR> :t fmap fix return
21:06:02 <lambdabot> b -> b
21:06:07 <EvanR> :t fmap fix
21:06:09 <lambdabot> Functor f => f (b -> b) -> f b
21:06:27 <dmwit> :t fix . const
21:06:29 <lambdabot> b -> b
21:06:38 <EvanR> what is f ?
21:07:50 <dkk> hello sorry my connection was lost last time .... are you guys here
21:08:49 <EvanR> (b ->)
21:09:17 <dkk> i wanted help with reader monad ...
21:09:37 <Axman6> dkk: we can't help without knowing what your question is =)
21:10:26 <dmwit> dkk: Did you see my last message, starting, "The clause of interest..."?
21:10:40 <dmwit> The clause of interest would be the `["n",x,"=",y]` one; which would change to something like `liftIO (putStrLn ...) >> local (M.insert x (read y::Int)) lp`.
21:11:13 <dkk> dmwit : ya ... but i can't understand that
21:11:41 <dmwit> Okay. Well, a slightly more targeted question would be good, then.
21:14:24 <dkk> can you show how to use local in real code
21:16:32 <dkk> Axman : I wanted to know how to use local in real code ... or get an intuition of it
21:16:41 <dmwit> Is my code not real for some reason?
21:17:05 <ReinH> nothing is real
21:17:24 <ReinH> which unfortunately makes the question unanswerable
21:18:53 <dkk> :dmwit actually i didn't get your answer ... can you please modify my code and use pastebin or lpaste for that
21:21:04 <dkk> dmwit : actually i didn't get your answer ... can you please modify my code and use pastebin or lpaste for that
21:21:32 <dmwit> It might help you more if you give it a shot yourself first.
21:23:16 <dkk> dmwit : ok i will ... so you understood what i am trying to do and approved that ..it is possiible to do it with Reader thing ...
21:26:18 <dkk> ok ... can some one give me an exercise by doing which i could get a better intuition for how to use reader monad 
21:28:19 <EvanR> write some function with a normal argument. then rewrite the function using Reader instead of that argument
21:30:11 <dkk> EvanR : that i have done .... some more
21:30:25 <EvanR> thats all there is to it
21:31:09 <EvanR> maybe you want to try ReaderT over IO
21:33:39 <dkk> EvanR : yeah .... I wanted to do something like have an environment of bindings Map of (string ->Int) and have something like user interacts with this ...like user could lookup for any string and insert new binding in Env ...can it be done using Reader
21:33:58 <dmwit> Yes.
21:34:02 <EvanR> yeah, if you put IORefs in the env
21:34:14 <dmwit> Even if you don't do that it can be done.
21:34:29 <ania123> myinit x = reverse(tail(reverse x))
21:35:06 <ania123> i have implemented myinit
21:35:31 <ania123> obviously it is very inefficient 
21:35:33 <dkk> how ... i tried for the last whole day but not get it done using readerT and IO 
21:35:51 <dmwit> Show us what you tried.
21:36:55 <ania123> is there way to implement it using builtin functions? 
21:37:02 <ania123> in a simple way
21:37:11 <ania123> without x: recursion
21:37:15 <ania123> construction
21:37:57 <EvanR> doing anything with a list without recursion is going to be tough
21:39:20 <ania123> EvanR: I want to use recursion, 
21:39:28 <EvanR> oh
21:39:52 <EvanR> then walk down the list look at two items at a time (if it has at least two)
21:39:53 <ania123> but I do not want to construct list like x :
21:40:12 <EvanR> take the item until you see theres only one left, then stop
21:40:53 <EvanR> you want to construct a new list without using the constructor?
21:41:04 <ania123> right
21:41:20 <EvanR> what makes you think thats possible
21:41:25 <geekosaur> o.O
21:41:27 <dkk> ok ... see what i have done .... main part is the loop function ..http://lpaste.net/234327
21:41:31 * Clint claps.
21:41:33 <ania123> myinit [x] = [x] 
21:41:46 <dmwit> > init [x]
21:41:48 <lambdabot>  []
21:41:51 <ania123> myinit (x:xs) = x :  myinit xs
21:41:52 <dmwit> wrong already =P
21:42:09 <ania123> I do not want this
21:42:59 <EvanR> agreed
21:45:58 <dkk> any comments ....
21:46:27 <dmwit> Yes. Try using ReaderT in your implementation of loop. Same comment I've been giving for some time now.
21:48:07 <dkk> dmwit : ok .... actually i don't know how to access the env when the reader is stacked inside some other monad
21:48:15 <dmwit> :t ask
21:48:17 <lambdabot> MonadReader r m => m r
21:48:39 <EvanR> it has nothing to do with Readers, but sounds like you would be interested in writing this function: replWith :: s -> String -> (s -> String -> Maybe (String, s)) -> IO ()
21:48:53 <EvanR> then using it to write your interactive program
21:50:19 <dkk> EvanR : ok you are using something like state ... i wanted to do it with reader ..is it not possible
21:51:22 <EvanR> its not even State
21:51:50 <EvanR> just plain boring functions
21:52:16 <dkk> EvanR : then what s resembles there 
21:52:35 <EvanR> thatd be your env that the user will possibly update
21:53:17 <dkk> EvanR : that i don't want to pass as an arguement
21:53:36 <EvanR> after you write this function, the passing is done for you
21:53:49 <Hi-Angel> Is it possible to just download a package with Stack? I.e. to not compile.
21:54:19 <dkk> EvanR : if that would be the case ... then its trivial for me also
21:55:40 <dkk> EvanR : what i wanted is that the Env is there and according to the input of user i would modify that how that env would be read 
21:55:58 <dkk> and keep that env untouched
21:57:24 <dkk> ok thanks i got some trick to do it using reader only
21:57:45 <dkk> if done then i would show you guys !!
21:57:49 <orzo> is there a place online where computer vision gurus or students hang out?
21:57:56 <dmwit> Hi-Angel: cabal fetch does that. Dunno what the stack equivalent is.
21:59:33 <Hi-Angel> Yeah, stack didn't have "fetch" :( I just need to check the difference between upstream in one package, which might be the reason for some errors upon installing from stack.
22:01:01 <EvanR> good question, orzo maybe try #electronics
22:01:54 <Hi-Angel> orzo: might be #opencv
22:01:58 <soLucien> is it possible to capture the type in a variable?
22:02:12 <soLucien> like Reflection in imperative programming languages
22:02:53 <soLucien> i'm trying to implement something like : you can iterate over String and array, but you cannot iterate over anything else
22:03:10 <ReinH> Reflection in Haskell works the other way: reifying terms into types.
22:03:19 <geekosaur> the way we do that is to use a typeclass and only provide instances for the things that support it
22:03:23 <ReinH> The only way to do that would be to make a typeclass of which only... yes.
22:03:55 <koz_> Couldn't you also do something like what Gabriel Gonzales proposed with his 'scrap your typeclasses' thing for doing exactly that?
22:03:56 <soLucien> so i am doing smth like 
22:03:56 <soLucien> case exprVal of
22:03:56 <soLucien>     String s -> doSmth
22:03:56 <soLucien>     Array xs -> doSmthElse
22:03:56 <soLucien>     someType _ -> fail "cannot iterate over " ++ someType
22:04:19 <geekosaur> typecase is not a thing
22:04:42 <ReinH> I think this is some expression AST
22:04:52 <ReinH> with unfortunate names for data constructors
22:05:10 <soLucien> i'm implementing array comprehensions
22:05:15 <ReinH> I also don't see how the someType line could possibly work
22:05:22 <soLucien> i know it is illegal
22:05:30 <ReinH> then why are you doing it?
22:05:54 <soLucien> i was asking if something like getType () in C# exists
22:05:59 <ReinH> No.
22:06:11 <soLucien> so i gave an example of how i would like it to work :D
22:06:14 <ReinH> Haskell is designed to not allow that.
22:06:18 <ReinH> since it is bad
22:06:48 <ReinH> having parametricity is more important than having typecase
22:07:00 <soLucien> i'm implementing array comprehensions in my interpreter
22:07:03 <EvanR> thats not even trying to get a type, its trying to check your data constructors
22:07:18 <EvanR> which... is something you totally can and should do in haskell
22:07:36 <EvanR> except in your case the operation is invalid in some of the constructors
22:07:37 <ReinH> if String and Array are data constructors, that is
22:07:48 <soLucien> so i have to make both var squares = [ for (x of xs) x * x ];
22:07:49 <soLucien>  and var y = [for (x of 'abc') x];
22:08:01 <ReinH> Generally it's better to not try to do things you know won't work.
22:08:13 <ReinH> Your language's types have nothing to do with Haskell's types.
22:08:42 <EvanR> soLucien: if you want to do it like javascript, youll just have to throw an error if the user tries something wrong
22:08:53 <soLucien> so i can iterate over xs (an array) and a string . For all the other expression types i want to output a fail
22:08:58 <EvanR> eventually you might want to learn how to apply types to your program to make that not possible
22:09:05 <ReinH> Then do that.
22:09:23 <ReinH> If your expression type for the language contains Array and String data constructors, you can match on them and then do different things
22:09:32 <soLucien> and i am
22:09:39 <ReinH> then why are you asking about refletion?
22:09:42 <soLucien> i was asking how to say "otherwise fail"
22:09:46 <ReinH> no you weren't
22:09:49 <ReinH> you literally never asked that
22:09:51 <soLucien> and in the error message i want to say
22:10:01 <soLucien> "cannot iterate over" + theType
22:10:14 <soLucien> that is why i wanted to know whether reflection is possible
22:10:22 <soLucien> so that i could dynamically get theType
22:10:25 <ReinH> You are confusing the types in the language you are parsing with Haskell types
22:10:33 <ReinH> This has nothing to do with Haskell
22:10:39 <ReinH> er, with Haskell types
22:10:43 <ReinH> and it has nothing to do with reflection
22:10:54 <EvanR> "cannot iterate over " ++ myTypeOf theValue
22:11:07 <ReinH> where myTypeOf (String _) = "string" and etc
22:11:14 <ReinH> No reflection or typecase is required
22:11:29 <ReinH> you are not casing on Haskell types
22:11:32 <ReinH> at all
22:12:11 <soLucien> i understand
22:13:16 <ReinH> you are casing on Haskell *values*, which is a perfectly reasonable thing to do
22:13:24 <ReinH> indeed it's how the entire language works
22:15:47 <ReinH> I am really beginning to suspect that your instructor is not a very good instructor.
22:16:08 <ReinH> Or that you are not asking them for help effectively.
22:16:54 <soLucien> they don't seem to care
22:17:03 <soLucien> and no , i don't really ask them for help
22:17:49 * geekosaur considers some of the TAs for lower level courses he's had...
22:17:53 <soLucien> if they did care , we wouldn't have had been assigned to read LYAH in one week
22:18:13 <geekosaur> although *that* sounds more like the prof
22:18:35 <soLucien> the course in general, yes
22:18:41 <soLucien> they give too little and ask too much
22:19:42 <soLucien> after 8 hours of lecture, where he briefly introduces monads, we're supposed to write an interpreter
22:20:12 <soLucien> another 4 hours and we have to write a parser using ReadP or Parsec
22:20:31 <kqr> that moment when you're browsing the tutorial, not getting a thing and then saying to yourself "screw it" and going on hackage to follow the types and everything becomes much clearer
22:20:36 <kqr> what is going on with me
22:20:51 <kqr> this is a good tutorial too
22:22:04 <soLucien> i'm supposed to learn Prolog by Sunday , and model the relationships in a social network :)
22:22:15 <DrEntropy> easy peasy
22:22:32 <soLucien> without using functions from the standard lib
22:23:50 <soLucien> types don't get exported, do they ?
22:24:04 <soLucien> type SomeType
22:24:27 <soLucien> oh wait. my bad
22:24:44 <augur> does GHC do optimizations for do notation/bind to determine when things can be lifted out of the binds into lets?
22:25:43 <augur> like..  if i wrote   do { x <- mx ; y <- my ; ... }   where my doesnt use x, then my can be lifted out to    do { let my' = my ; x <- mx ; y <- my' ; ... }
22:25:54 <augur> in case my is some big complicated computation
22:26:37 <geekosaur> if it can inline (>>=) then possibly. otherwise I don't think what you describe is really a win anyway
22:32:03 <nitrix> augur: What would presumably be the benefit of this?
22:34:19 <augur> geekosaur: nitrix: the benefit is that if computing my is a complex thing, it shouldn't be repeated unnecessarily
22:34:46 <geekosaur> why would it be repeated?
22:34:52 <augur> if the monad is []
22:34:56 <augur> or something list-y
22:35:29 <geekosaur> ok, ok, you want it to be available for further let-hoisting
22:35:39 <geekosaur> I think it already does that
22:35:43 <augur> ok :)
22:35:48 <nitrix> augur: I'm confused. `my` or `my'` is evaluated only once, then you obtained a result which is bound to `y`. You can re-use `y` as often as you want from then on.
22:36:04 <augur> nitrix: it's evaluated once for each value of x
22:36:16 <nitrix> Oh. Oh that's what you meant.
22:36:48 <geekosaur> (I meant oh, ok up there... sorry if it implied I was grumping)
22:36:59 <augur> geekosaur: no worries :)
22:38:10 <bollu> quick hott question
22:38:14 <geekosaur> anyway as far as I know it should let-hoist already in that case, at least if optimized; you can check the generated core to be certain, and possibly ask in #ghc if it's not
22:38:17 <bollu> so, if T is a type
22:38:24 <bollu> why is x:T, y:T x = y a type?
22:40:10 <augur> bollu: there's a hott channel i think
22:40:29 <bollu> hm, very well
22:41:17 <EvanR> ##hott
22:41:26 <bollu> thanks :)
22:41:33 <bollu> but, does anyone know the answer?
22:41:37 <bollu> I asked over there as well
22:41:58 * EvanR squints
22:42:12 <EvanR> not in the last few days
22:42:21 <bollu> ski: I haven't seen Baez's stuff
22:42:26 <bollu> ski: I'll check it out :)
22:44:00 <fm1> Hi all. a short question on choosing a data structure. I've got a mapping from unicode points to strings. I read the mapping at startup from a file, so it's constant afterwards. What would be a efficient data type for fast lookup. Is array a good choice? (It's in a script, and I want to minimise the overwall running time). 
22:44:20 <bollu> fm1: Data.Mp?
22:44:21 <bollu> Map*
22:44:49 <EvanR> if its consecutive integer codepoints
22:45:01 <EvanR> a Vector would be pretty fast, i am told
22:45:45 <geekosaur> for dense consecutive integers, Vector; for sparse, IntMap
22:45:49 <fm1> yes, it's consequtive.
22:46:17 <fm1> Ah, I see. Then I'll try vector.
22:46:30 <fm1> thank!
22:46:39 <fm1> hmm, with an s.
22:48:41 * hackagebot psi 0.1.1.0 - Yet another custom Prelude.  https://hackage.haskell.org/package/psi-0.1.1.0 (fractalcat)
22:48:43 * hackagebot pptable 0.1.0.1 - Pretty Print containers in a tabular format  https://hackage.haskell.org/package/pptable-0.1.0.1 (gdevanla)
22:56:14 <benzrf> do ghc and/or ghcjs only output code for terms that are transitive dependencies of the entry point, or do entire libraries get indiscriminately pulled in?
22:56:15 <piyush-kurur> bollu: just answered your question on #hott
22:56:19 <benzrf> (when building an executable)
23:10:31 <piyush-kurur> bollu: It is ##hott not #hott just in case you did not already notice. I too was fooled by the more official looking #hott 
23:23:08 <soLucien> how can i tell if an object is Traversable ? I tried for String 
23:23:17 <soLucien> String :: Traversable
23:23:56 <ongy> do you want to check if an existing Type is Traversable?
23:24:00 <soLucien> yes
23:24:55 <soLucien> i actually want to pattern match all Traversable instances
23:25:02 <soLucien> if that is possible
23:26:16 <benzrf> you can't do that
23:26:24 <ongy> you could make a dummy function with type: Traversable a => a -> a. and see if application typecheckes. But that's hacky 
23:27:43 <dmwit> soLucien: `:i Traversable` in ghci will tell you what instances there are.
23:28:03 <koz_> :i Traversable
23:28:10 <dmwit> "in ghci"
23:28:13 <koz_> Aww, lambdabot won't do it...
23:28:26 <soLucien> i did that
23:28:29 <ongy> @instances Traversable
23:28:31 <soLucien> cool
23:28:34 <soLucien> thanks
23:28:35 <lambdabot> Array i, Complex, Dual, First, Identity, Last, Maybe, Product, Proxy, Seq.Seq, Seq.ViewL, Seq.ViewR, Sum, Tree, ZipList, []
23:29:06 <ongy> koz_: ^ Lambdabot wants a longer command
23:29:19 <koz_> ongy: Ah, OK.
23:33:01 <ongy> is there a commant to list all classes a type is an instance off?
23:33:50 <EvanR> :info Int
23:33:57 <EvanR> or :i
23:36:24 <Guest57129> while defining a multiargument function, does the order of the type declaration matter?
23:36:39 <mauke> Guest57129: huh?
23:36:59 <Guest57129> i mean, is there a difference between a->b->c and b->a->c ?
23:37:12 <Guest57129> where a,b,c are type variables
23:37:52 <mauke> no
23:38:10 <Cale> It kind of does matter...
23:38:58 <mauke> I know of two exceptions: when it's part of a larger context and the variables are used elsewhere, and explicit type application
23:38:59 <Cale> Not only for convenience -- you can partially apply functions to their first arguments and obtain a function of the remaining ones to pass along to higher order functions, or otherwise use multiple times
23:39:48 <Cale> But also for efficiency -- you can have part of the work happen after the first parameter is supplied, obtaining a more efficient function of the remaining parameter(s)
23:40:06 <Guest57129> Okay. Thanks
23:40:29 <Cale> e.g. you might have some function which takes a regular expression and a string, and tells whether the string matches.
23:40:48 <Guest57129> The reason I ask is I'm stuck at this quote in LYAH. "How about a function that nudges a shape? It takes a shape, the amount to move it on the x axis and the amount to move it on the y axis and then returns a new shape that has the same dimensions, only it's located somewhere else."
23:40:50 <Cale> If the regular expression is first, you can compile the regular expression to some sort of efficient automaton
23:41:07 <Cale> and then produce a function which will use *that* automaton which you construct just once
23:41:10 <Guest57129> And he defines the nudge function to have the fuollowing type
23:41:26 <Guest57129> nudge :: Shape -> Float -> Float -> Shape
23:42:03 <Guest57129> My question is why not have Float -> Float -> Shape -> Shape
23:42:13 <mauke> ok, that's different
23:42:17 <mauke> there are no type variables here
23:42:24 <Guest57129> Right
23:42:27 <Cale> That first order is best if you expect to use the same shape with many different translation amounts
23:42:41 <Cale> The second order is best if you want to translate many shapes by the same amount
23:43:12 <Guest57129> Cale : How are you able to say that just by looking at the type?
23:43:26 <Cale> Oh, I just realised why mauke answered the way he did the first time :)
23:43:43 <Cale> Guest15006: You want the most-constant-like things first
23:43:58 <Cale> Just think about what happens when you apply the function partially
23:44:20 <Cale> So in the first case, you apply it to a Shape, and obtain a function Float -> Float -> Shape
23:44:36 <Cale> So you can use that function with many different pairs of arguments to translate that initial Shape by different amounts
23:44:41 <Ashy> im using insertBy from persistent but still getting SqlErrors for duplicate keys when the record already exists, has anyone seen that before?
23:44:55 <Ashy> insertBy is supposed to return a Left Key if the record violates any uniqueness constraints
23:44:57 <Guest57129> Oh! Thanks a lot. It's clear now
23:45:05 <Cale> In the second case, you can apply the function Float -> Float -> Shape -> Shape to a couple of Floats, and obtain a function Shape -> Shape
23:45:13 <Cale> which you can then apply to many different shapes
23:45:55 <Guest57129> So if I define this function without explicitly declaring a type declaration, 
23:46:04 <Guest57129> and ask Haskell to tell me it's type,
23:46:09 <Guest57129> which one will it show me?
23:46:15 <Guest57129> the first or the second?
23:46:18 <Cale> Whichever one you wrote.
23:46:28 <Cale> Based on the order of the arguments in your implementation
23:46:39 <Guest57129> Ahh. 
23:46:42 <Guest57129> Okay.
23:46:43 <Guest57129> Thanks a lot!
23:47:06 <Cale> There's actually two (sometimes competing) principles for how to order arguments
23:47:32 <Cale> 1) They should generally be in increasing order of expected rate of change, so "more constant" things come first.
23:48:10 <Cale> 2) If you can have something like T -> T at the end, that can be good, because any pair of functions T -> T will compose with one another.
23:49:08 <Guest57129> Okay. 
23:49:55 <Cale> So Float -> Float -> Shape -> Shape is nice because it contributes to the language of functions of type Shape -> Shape. You can imagine that many other operations on Shapes would also result in such functions, which could then be freely composed together.
23:50:27 <Guest57129> So it all depends on what you want..
23:50:49 <Cale> yeah
23:51:17 <athan> Anyone here FFI to C++ much?
23:51:21 <Cale> Of course, if the arguments are in the wrong order for you, there's always lambda
23:51:33 <athan> I saw there's something like `import foeign cplusplus ...`, but I might be wrong
23:53:28 <ongy> https://www.haskell.org/onlinereport/haskell2010/haskellch8.html mentions it as possibility. But I don't think it's implemented
23:53:32 <Cale> athan: That's generally done by doing some FFI on the C++ side to export C functions, and then importing those as you would other C functions on the Haskell side...
23:54:10 <slack1256> plus hoppy seems to be able to help with that
23:54:11 <athan> Cale: Yowza, right on
23:55:10 <athan> thanks slack1256
