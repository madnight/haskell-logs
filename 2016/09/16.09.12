00:00:43 <joe9> eklavya: I do not know about Servant. I can only speak from my limited experience humbly.
00:01:06 * ski . o O ( "Restarting conditions" by Riastradh (WIP) at <https://mumble.net/~campbell/proposals/restart.text>,<http://mumble.net/~campbell/proposals/restart.scm> )
00:01:07 <eklavya> ok
00:01:24 <eklavya> thank yo so much for your time joe9 :)
00:01:32 * ski . o O ( <http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html>,<http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html>,<http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Error-System.html>,<http://www.scheme.com/tspl4/exceptions.html> )
00:01:37 <eklavya> I have a lot to read now :P
00:03:18 <eklavya> I will try and ask about it again tonight, maybe glguy Cale merijn will be around then
00:59:54 <coconut> I've got this definition for the length function: length = foldr (\_n.1+n) 0  Can someone maybe show me how for example lenght [1,2,3] could be reduced?
01:00:58 <amalloy> coconut: what part of that are you having trouble doing yourself? you should only need to substitute the definition of foldr a few times
01:01:17 <coconut> yes I did this but <i think it's wrong...
01:01:44 <oherrala> coconut: https://wiki.haskell.org/Fold#List_folds_as_structural_transformations
01:01:54 <ongy> coconut: can you share what you have done, if you think it's wrong?
01:03:16 <coconut> of course: let's define (\_n.1+n) as #. I've got 1#(2#(3#0))
01:04:00 <cocreature> btw the haskell syntax is (\_ n -> 1 + n)
01:05:25 <cocreature> coconut so what do you get if you try to evaluate one step of \(_ n -> 1 + n) 1 (2#(3#0))
01:06:22 <coconut> the first step is 1 + 1, right? 
01:06:46 <cocreature> you just need to substitute the arguments
01:07:20 <cocreature> i.e., replace _ with 1 (which means ignoring it) and replace n with 2#3#0
01:07:42 <coconut> hm I think I found my problem. I started substituting on the wrong side... 
01:08:11 <coconut> but thanks anyway and of course it's not 1+1 in the beginning. I've overseen the _
01:11:04 <bagaren> hi
01:11:28 <bagaren> anyone got time to help me with a problem in haskell?
01:11:53 <cocreature> bagaren: just asking your question directly usually works better :)
01:12:06 <bagaren> okay, here we go
01:14:45 <bagaren> I got a matrix, but in the form of [(Int, Int, Int)]. I wanna add two matrices together, and right now I'm complicated double lambda to do that
01:15:03 <bagaren> and btw, I can only use std lib for this. 
01:15:28 <cocreature> does each (Int, Int, Int) represent a row in your matrix?
01:15:38 <bagaren> represents a column
01:16:19 <cocreature> alright, what do you want to do if your matrices don’t have the same number of columns? just ignore additional columns?
01:16:51 <bagaren> return error if they dont have the same dims
01:18:42 <cocreature> so you basically have two possibilities, either first check the dimensions by calling length on both matrices and comparing the results, if that checks succeeds you can just use zipWith (\(a,b,c) (a',b',c') -> (a+a',b+b',c+c')) to add the two matrices
01:19:22 <cocreature> the other possiblity is to manually recurse through both matrices and when you are at the end of one matrix but still have columns in the other matrix you return an error
01:20:19 <cocreature> I would probably go for the first approach
01:20:28 <bagaren> sounds less complicated then my current implementation. ill try it out and get back later today
01:26:36 <hansihe> Beginner here, i'm using parsec, parsec.many seems to return a list of the parsec monad instead of a list wrapped in the parsec monad
01:26:37 <hansihe> https://gist.github.com/hansihe/eeca3e3f9cff13b82185f5770f7d756f
01:27:15 <hansihe> I probably have some conceptual misunderstanding here, any ideas?
01:27:22 <ongy> :t sequence -- hansihe 
01:27:23 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
01:27:41 <Axman6> can you give more information? what are the types of comments and items?
01:27:42 <ongy> for the general situation, I have no idea about parsec, so it may do something you aren't intending to do
01:28:06 <merijn> ongy: It's impossible to say without knowing the types of anything
01:28:07 * hackagebot google-oauth2-jwt 0.1.2.0 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.1.2.0 (MichelBoucey)
01:28:09 * hackagebot timezone-olson-th 0.1.0.2 - Load TimeZoneSeries from an Olson file at compile time.  https://hackage.haskell.org/package/timezone-olson-th-0.1.0.2 (petterb)
01:28:11 * hackagebot hsini 0.5.0 - Package for user configuration files (INI)  https://hackage.haskell.org/package/hsini-0.5.0 (MagnusTherning)
01:29:02 <[k-> cocreature: have you seen quchen's informative article? https://github.com/quchen/articles/blob/master/useful_techniques.md#avoiding-length-in-list-functions
01:30:28 <dni> :t length
01:30:33 <lambdabot> Foldable t => t a -> Int
01:30:37 <dni> cool
01:31:41 <hansihe> Axman6: I updated the gist with some more type signatures, is that enough or should I include the full code?
01:31:58 <hansihe> It's a bit noisy, so it would probably be best to avoid that
01:33:39 <cocreature> [k-: I have, I have, but I don’t think it really applies here. matrices don’t tend to be infinite and if you don’t calculate the length in advance you start returning results lazily even on a dimension mismatch which might not be desirable
01:34:23 <[k-> cocreature: Thanks for enlightening me :)
01:36:04 <hansihe> I figured it out, nevermind me :)
01:36:23 <merijn> @tell quchen You should keep up the work of writing up my advice for me by extending your "useful techniques" article with a section on "tortoise and hare" inspired list functions
01:36:23 <lambdabot> Consider it noted.
01:36:51 <cocreature> eand sure, the sameLength function will perform better, but if you are storing matrices as lists of tuples you don’t care about performance anyway
01:38:07 <ongy> merijn: you are right. and I noticed that pretty much when I sent it, which is why I added the second line
01:38:15 <cocreature> s/eand/and/
01:39:19 <amalloy> hansihe: what was wrong? your code looks right to me
01:40:21 <merijn> cocreature: Matrices only exist inside LAPACK and BLAS, right? :p
01:40:52 <hansihe> amalloy: yeah, that part of the code was fine, i think the error was due to some other function being incorrect and the inferred type signature messing things up?
01:40:56 <[k-> how can you store matrix-like structure efficiently? I was using a Data.IntMap.Strict.IntMap (Data.IntMap.Strict.IntMap Char) 
01:41:23 <ongy> isn't it called LINPACK?
01:41:31 <amalloy> yes, if you wrote this without type signatures and had errors elsewhere i could imagine that error message
01:41:40 <amalloy> a lesson in the value of writing type signatures
01:41:57 <merijn> ongy: I dunno, I'm baller, so I roll my own sparse matrix stuff and pretend it's graphs ;)
01:42:28 <merijn> [k-: Sparse or dense? What size?
01:42:46 <merijn> IntMap is probably fine for small things
01:42:59 <merijn> For large things you're probably stuck writing your own tools anyway
01:42:59 <dabd> Is there a good way to quickcheck zipWith?  How do you find properties for such a function?
01:43:06 <merijn> Because everything is terrible :p
01:43:14 <merijn> (Not just in Haskell)
01:43:16 <[k-> I was modeling a square grid
01:43:25 <[k-> So two dimensions 
01:43:30 <hansihe> amalloy: adding type signatures for the gist is actually what narrowed the error down to the correct location, lesson learned :)
01:43:59 <merijn> [k-: What size dimensions? tens, hundred, millions?
01:44:28 <[k-> From 1 to 5000 for each side
01:44:42 <merijn> hansihe: In case of confusing type errors the best first step is to add more type annotation so that you can check whether what you THINK is the type is actually right :)
01:44:50 <merijn> [k-: Sparse or dense?
01:45:06 <[k-> (technically I only need up to 50 but it was fun seeing it do 2000+)
01:45:19 <[k-> what's the meaning of sparse or dense?
01:45:35 <cocreature> merijn: exactly :)
01:45:56 <Insanity_> sparse means most elements are '0'
01:46:04 <Insanity_> dense is the opposite of that
01:46:08 <merijn> [k-: Does every position have a value or no. i.e., if all fields in the matrix are 0, except like 5 which have a value, it's sparse. If every field has a value it's dense
01:46:29 <[k-> ah, every field has a value
01:46:38 <[k-> so it's dense
01:46:43 <merijn> [k-: If you have a matrix that's large but sparse (i.e. mostly zero) you can get away with only storing the non-zero bits :)
01:47:02 <merijn> Incidentally, there's also hmatrix as library for matrix manipulation
01:47:18 <[k-> Oh, I see, that's a nice tip :)
01:47:44 <merijn> [k-: Not sure how tricky it is to build, since it uses BLAS
01:47:56 <merijn> On the upside, that means it's probably faster than you'll reasonably need :p
01:48:50 <[k-> Yes, IntMap is fast :>
01:51:07 <[k-> I had one large intmap holding 2000 IntMaps which held 2000 Chars each
01:54:33 <[k-> The IntMaps were only intermediate data structures for my program though 
01:54:45 <[k-> they were thrown away once they are done
01:55:03 <ongy> [k-: Char? what are you doing?
01:55:52 <[k-> I was printing randomly generated letters to the screen
01:56:16 <ongy> over which range did you generate?
01:56:54 <[k-> range?
01:57:50 <[k-> the characters? they were user supplied actually
01:57:54 <ongy> randomly generated letters. Are those form Ascii, or some more interesting set of letters
01:57:57 <ongy> ah, ok
02:01:53 <[k-> It was something like this: https://drive.google.com/file/d/0Bwc34geqbVNbd09tbHZqX2RfMW8/view?usp=drivesdk
02:28:08 * hackagebot hruby 0.3.4.2 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.4.2 (SimonMarechal)
02:28:10 * hackagebot language-puppet 1.3.1.1 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3.1.1 (SimonMarechal)
02:31:53 <[k-> erisco: while you were gone, I found out how list comprehensions could be horrible for understanding
02:32:05 * [k- *shudders*
02:40:50 <Insanity_> [k- did you take a picture with your phone of that rather than taking  a screenshot? :P
02:46:01 <[k-> Insanity_: yes, I sent it to someone on Telegram 
02:46:14 <[k-> and then I recovered it from Telegram
02:46:27 <Insanity_> Oh I see.. Not familiar with 'Telegram', but I'll assume it's a phone thing :)
02:49:03 <[k-> You guessed right, it has a web version too 
02:49:10 <ongy> one of the many crypto messengers. iirc a mix between berlin and russian based
02:58:19 <[k-> People have proven its crypto is not secure though 
02:58:29 <[k-> because they rolled their own crypto
02:58:44 <[k-> and there was a flaw
02:58:49 <Insanity_> mhm
03:00:50 <[k-> I use it so I don't have to give my phone number to people on the internet 
03:01:31 <[k-> but this is off topic 
03:15:54 <nathyong> Is there any way to get stack to force recompile on test?
03:19:08 <phadej> nathyong: why'd you want force recompile?
03:19:19 <nathyong> phadej: because I'm changing my test files
03:19:31 <nathyong> and the changes aren't detected all the time
03:20:15 <phadej> some template-haskell includes?
03:20:32 <nathyong> nope, just normal Haskell..
03:21:19 <phadej> do you have them listed in *.cabal in "other-modules" ?
03:21:29 <nathyong> should be, yeah
03:21:44 <nathyong> actually it's under main-is
03:21:54 <phadej> anyway, either there's a bug in stack or you do something strange. Feel an issue to stack
03:22:00 <phadej> fill*
03:22:45 <nathyong> Cool, good to know I'm not going crazy..
03:24:32 <ski> [k- : "how list comprehensions could be horrible for understanding" ?
03:28:10 * hackagebot aeson-compat 0.3.6 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.6 (phadej)
03:31:40 <[k-> if you express a complex algorithm into a list comprehension, it likely wouldn't have comments at all 
03:32:41 <ski> how would that differ from and compare to other means of solving the problem, with no comments ?
03:32:59 <ski> (or do you mean that it's more likely to not have comments for list comprehensions ?)
03:33:10 <[k-> the second one
03:34:22 <[k-> list comprehensions should be as simple as possible
03:34:36 <ski> .. or perhaps you find them intrinsically harder to understand ?
03:35:25 <[k-> they are harder to understand with complex algorithms because most of the time they aren't used that way 
03:35:29 * ski assumes [k- hasn't tried any Prolog, or any other logic programming language
03:36:10 <ski> do you perhaps have an example of a more complex algorithm, expressed using list comprehensions, that you think does a poor job for readability ?
03:36:20 <[k-> You guessed right! \o/
03:36:58 <[k-> This was improved from yesterday: http://cale.yi.org/reflex/Jumps/Jumps.jsexe/
03:37:22 <[k-> I just wanted to tell erisco that I agreed :>
03:40:29 <ski> oh, that dynamic programming thing from yesterday ?
03:41:25 <[k-> yes
03:44:35 <sgflt> hello. i'm looking for a server provisioning tool written in haskell that i came across once, but forgot to bookmark. maybe someone can help me out with a name?
03:45:34 <srhb> sgflt: propellor?
03:45:57 <sgflt> srhb: that may be it, looking at it at the momentt
03:46:19 <haskeaven> >mfw I made it to haskeaven and you're all still stuck here in haskell
03:46:32 <haskeaven> Truly amazing to have ascended
03:47:19 <sgflt> srhb: yeah, i think that's it. do you have any practical experience with it?
03:47:20 <ski> haskeaven : do you have a question or comment, related to Haskell ?
03:48:40 <srhb> sgflt: Only a little bit.
03:48:51 <srhb> sgflt: It was too ansible like for my taste.
03:49:00 <ski> [k- : how would you prefer the list comprehension to be expressed instead ? with `map' and `filter' ? or with some kind of direct recursion in a helper function ? something else ?
03:49:29 <sgflt> srhb: could you elborate what "too ansible" is in this case?
03:49:31 <haskeaven> ski: yes, I just made my comment :^)
03:50:05 * ski doesn't see how it was relevant to Haskell and related topics ..
03:50:18 <srhb> sgflt: Mutating a mutable system and hoping for the best. :)
03:51:03 <sgflt> srhb: i see. do you know of any working/successful system that handles this fundamentally different?
03:51:10 <srhb> sgflt: NixOS.
03:51:44 <ski> @wn ansible
03:51:46 <lambdabot> No match for "ansible".
03:52:17 <sgflt> srhb: i'll check out their channel, thanks
03:52:24 <srhb> sgflt: :)
03:53:07 <tsahyt> How can I see which rewrite rules are being used during compilation?
03:55:12 <mpickering> -ddump-rule-rewrites
03:55:26 <mpickering> The best way to find flags is to use "ghc --show-options | grep ..."
03:55:52 <tsahyt> hmm using this via stack --ghc-options produces no output. that's strange, but it might explain why I'm using so much memory
03:57:44 <cocreature> tsahyt: make sure you are actually recompiling and you need to select a project i.e. "stack build --ghc-options -ddump-rule-rewrites projectname" because otherwise stack will hide output to prevent concurrent builds from interfering
03:58:16 <tsahyt> cocreature: I tried compiling the relevant file with GHC directly and the result was the same
03:58:20 <tsahyt> apparently list fusion just isn't happening at all
03:58:47 <cocreature> are you compiling with optimizations?
03:59:45 <[k-> ski: yes, and with comments!
04:00:11 <kuribas> Is there a way to document datatype members in non-record type constructors?
04:00:20 <tsahyt> cocreature: I thought -O1 was the default?
04:00:24 <tsahyt> but yes I've tried that too
04:00:38 <cocreature> hm I think you’re right
04:01:00 <tsahyt> actually it's wrong
04:01:11 <tsahyt> compiling with -O1 manually does give me some output
04:01:19 <kuribas> Using haddock.  like "data Transform = Transform Int Int Int Int -- | Transform xx xy yx yy
04:02:11 <tsahyt> but I still only have 27.5% productivity. That won't do
04:02:28 <kuribas> I tried "-- ^" but it works only on record types
04:03:13 <ski> [k- : i'm not convinced the code would be clearer with `map' and `filter'
04:03:53 <ski> (comments for the thee items in the list comprehension would improve readability, yes)
04:05:20 * ski would perhaps also hide the arrays a bit more, making it look more like the non-dynamic-programming direct solution
04:05:24 <tdammers> don't newer Haddock versions support -- ^ on arguments?
04:05:56 <cocreature> maybe {- ^ doc -} after the type works?
04:05:58 <tdammers> failing that, I believe a somewhat standard practice is to put a literal example invocation in the haddock for the function / constructor itself
04:05:59 <kuribas> tdammers: hmm, I must have an older version then.
04:06:14 <tdammers> I could be wrong, mind you
04:06:18 <tdammers> let me try
04:07:05 <kuribas> I could use a bulletted list in the doc, it's not as elegant...
04:07:59 <kuribas> https://www.haskell.org/haddock/doc/html/ch03s02.html#idm140354810892736
04:10:41 <[k-> ski: I think it does though, perhaps being explicit helps me because I'm not experienced with haskell yet
04:10:50 <lpaste> tdammers pasted “haddock on function arguments” at http://lpaste.net/191420
04:10:56 <tdammers> kuribas: ^
04:12:16 <kuribas> tdammers: But I have a data type, like "data Transform = Transform Int Int Int Int"
04:12:35 <kuribas> tdammers: And I don't want to pollute the namespace with a record type.
04:12:40 <tdammers> right, let me try that
04:12:45 <ski> [k- : this was why i wondered whether you had any logic programming experience ..
04:13:44 <[k-> Yes, and I said that you hit the nail with your assumption 
04:14:54 <tdammers> kuribas: heh, seems like that does not work
04:14:57 <tdammers> :(
04:15:03 <kuribas> :(
04:15:45 <tdammers> although I'm thinking, if your constructor arguments require documentation, then they probably also deserve explicit names
04:16:47 <tdammers> in the Transform case, I'd pick one of two routes: either name the fields and expose them, or only expose a set of smart constructors instead of the real constructor fields
04:16:59 <tdammers> I mean, just because you name your fields doesn't mean you have to use the names anywhere
04:17:20 <ski> you could think of the list comprehension here as doing a simple (anglic) nondeterministic search to find the number of jumps required to reach the destination, when considering the different options available at this point
04:17:52 <kuribas> tdammers: the problem is that I have a sum type, so they would become partial functions.
04:18:18 <tdammers> ah
04:18:26 <ski> then the overall algorithm takes the minimum of all those, for each current position (of fails with `Nothing' in case it's impossible for a position), and uses recursion to stich all of these together
04:18:47 <tdammers> you could of course have separate types for the data in each constructor, but that would introduce extra types
04:19:06 <[k-> I had some sort of the context in my mind when parsing the list comprehension, yes, but i didn't get the Nothing part 
04:19:45 <ski> `Nothing' can only be generated by two things there
04:19:47 <[k-> I don't have much practice in reading haskell code or any other code from other programming languages 
04:20:02 <[k-> I tend to skim over them
04:20:06 <ski> (i'm assuming `here <= destination')
04:20:34 <ski> the first case covers `here == destination', so in the recursive case, we even have `here < destination', under the above precondition
04:21:06 <ski> (well, `here' comes from `[source .. destination]', actually, so the precondition is necessarily fulfilled)
04:21:23 <haskell389> is there a generic type level function which goes from kind * to String and displays the constructors of a given type as a string ?
04:21:41 <ski> anyway, in case `fuel ! here' is zero (or negative), then the list used to select `next' from will be empty
04:22:22 <ski> if `here < destination', then `here + 1 <= destination', so the `takeWhile' will not take a non-empty list into an empty list
04:22:51 <ski> so, if there's no `next' to choose, the whole list comprehension will be the empty list, and so `Nothing' will be generated in this case
04:23:20 <ski> and, as we saw, this can happen when `fuel ! here' is not positive
04:23:52 <ski> the other source of `Nothing' is from the "recursive call", iow `Just n <- [minJumpsFromA ! next]'
04:23:58 <[k-> so that's where Nothing came from
04:24:14 <[k-> but that is pattern matched 
04:24:21 <ski> but they must ultimately come from their fuel being non-positive
04:24:38 <ski> (the base case never gives `Nothing', so that's not an alternative source)
04:25:35 <ski> (note btw that `fuel ! destination' is always ignored)
04:26:17 <ski> haskell389 : i'd doubt it
04:27:05 <[k-> this is orders of magnitude higher than go functions i would normally write 
04:27:18 <haskell389> it looks like a show of a representation of a type
04:27:31 <haskell389> generic representation
04:27:35 <ski> "go functions" ?
04:28:11 * hackagebot svg-tree 0.5.1.2 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.5.1.2 (VincentBerthoux)
04:28:35 <[k-> you know in the base package you see a lot of local functions named go
04:28:49 <ski> ok, helper/worker functions, you mean
04:28:58 <[k-> yes
04:29:36 <ski> as i said, i'd probably hide the arrays more
04:29:51 <ski> so that there is no explicit mention of `minJumpsFromA', e.g.
04:29:54 <haskell721> ski : indeed it can not exist
04:30:23 <[k-> sorry I'm currently doing my physics homework so my mind is in a mess
04:30:30 <haskell721> but there is typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep
04:30:41 <ski> [k- : nw
04:30:52 <haskell721> which makes sense as it needs to be known at compile time.
04:31:02 <[k-> nw?
04:31:06 <ski> "no worry"
04:31:13 <haskell721> so bounding it by Typeable makes sense
04:31:30 <[k-> I thought it stood for "no way"
04:31:39 <ski> hm .. maybe for some people ?
04:31:42 * ski doesn't know
04:34:06 <[k-> most of the time I have a lot of "helper functions" which shows how data is transformed step by step like so: https://github.com/SkyBirdSoar/grid/blob/text/src/Canvas.hs
04:36:09 <lyxia> why don't you put these functions at the toplevel
04:38:42 <[k-> I knew they would be the same whether at top level or local, but I did it at the local level since IntMap is only ever used there
04:42:55 <haskell721> Is there a function Typeable t => Exists N /  j<N -> (String, exists aj. aj -> t)
04:43:11 <haskell721> that would split a data type onto its constructors at type level
04:50:12 <tsahyt> is there a nicer way to write if length a > length b then a else b?
04:50:38 <tsahyt> other than maximumBy (comparing length) [a,b], because that's just about as long and apparently slower
04:51:39 <[k-> :t bool
04:51:41 <lambdabot> a -> a -> Bool -> a
04:52:09 <[k-> bool a b (length a > length b) maybe?
04:52:22 <fizbin> If I've got a (multi-file program) setup using cabal, and I want to compile a particular file with -ddump-simpl to investigate some parts of it to see if I can make them faster, how do I do that?
04:52:50 <fizbin> Is there a command to tell cabal "recompile just this file with this flag"? Or a command to get the actual ghc command line cabal is using?
04:52:59 <[k-> this function is biased towards b if a and b are of the same length though
04:55:38 <tsahyt> @hoogle a -> a -> (a -> a -> Bool) -> a
04:55:42 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:55:42 <lambdabot> CorePrelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:55:42 <lambdabot> Text.XML.HaXml.Schema.Parse (|||) :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)
04:55:52 <tsahyt> I wonder if I can use this somehow
04:55:56 <tsahyt> :t (>) `on` length
04:55:58 <lambdabot> Foldable t => t a -> t a -> Bool
04:56:54 <[k-> tsahyt have you seen bool?
04:57:24 <tsahyt> yes but I still have to mention both lists twice for that
04:57:32 <tsahyt> e.h. bool a b (length a > length b)
04:57:37 <tsahyt> e.g*
04:57:37 <fizbin> tsahyt: You could manually define something like:
04:57:39 <fizbin> > let {foo a b (_:_) [] = a; foo a b [] _ = b; foo a b (_:as) (_:bs) = foo a b as bs; longer a b = foo a b a b} in longer [1,2,3,4,5] [1,2,3,0,0]
04:57:42 <lambdabot>  [1,2,3,0,0]
04:58:01 <tsahyt> that has the added benefit of early termination
04:58:03 <tsahyt> I like that
04:58:37 <fizbin> It's not short though.
04:58:49 <tsahyt> doesn't matter, I can use some performance here and early termination would help
04:59:02 <erisco> I used my internal @pl processor and came up with …
04:59:12 <erisco> curry (uncurry ($) . (bool fst snd . uncurry (<) . (length *** length) &&& (id *** id)))
04:59:20 <ski> fizbin : define `foo' inside `longer', to avoid carrying around the `a' and `b'
04:59:22 <erisco> maybe you can golf from there
05:00:03 <ski> (fwiw, it would also be possible to make it slightly lazier)
05:00:24 <[k-> erisco: lambdabot?
05:00:32 <tsahyt> why the foo anyhow? why not longer a [] = a; longer [] b = b; longer (a:as) (b:bs) = longer as bs?
05:00:38 <erisco> my wetware
05:00:39 <tsahyt> this is untested, might be wrong
05:00:48 <ski> tsahyt : doesn't work
05:00:52 <ski> you need the two original lists
05:00:56 <tsahyt> ah right
05:01:08 <fizbin> ski: point. Also, it might be a tiny bit faster to define foo based on null and tail rather than on pattern matching.
05:01:31 <fizbin> Since tsahyt's primary concern is speed, that might matter.
05:01:50 <tsahyt> null and tail is faster than pattern matching?
05:02:09 <erisco> tsahyt, that was for you by the way
05:02:58 <tsahyt> erisco: thanks, I did see it
05:03:02 <[k-> erisco: that's like: `bool - gone wrong`
05:04:22 <ski> > let longer as0 bs0 = foo as0 bs0 where foo [] (_:_) = bs0; foo _ [  ] = as0; foo (_:as) (_:bs) = foo as bs in longer [0,1,2,3] [4,5,6,7,8]  -- changed tie condition
05:04:24 <lambdabot>  [4,5,6,7,8]
05:04:28 <[k-> 'in an attempt to be point free, we came up with this monster of a function'
05:04:54 <ski> fizbin : i don't see why `null' and `tail' would be faster. if anything, i'd expect them to be slower
05:05:18 <erisco> id *** id  is just id, so there is one simplification
05:05:24 <[k-> null and tail are just pattern matching
05:06:30 <erisco> I don't think the rest gets much better
05:06:57 <[k-> @pl bool a b (length a > length b)
05:06:57 <lambdabot> bool a b (length a > length b)
05:07:09 <[k-> lambdabot agrees 
05:07:20 <erisco> @pl \a b -> bool a b (length a > length b)
05:07:21 <lambdabot> liftM2 ap bool ((. length) . (>) . length)
05:08:02 <[k-> this is so complex, like ((.).(.).(.))
05:08:32 <reactormonk> I'm running some haskell in my xmonad config, but xmonad crashes without a stacktrace or anything - are there some compiler options I could use?
05:08:41 <erisco> maybe not, but I'll have to think of what liftM2 ap is
05:09:34 <lyxia> :t liftM2 ap
05:09:36 <lambdabot> (Monad m1, Monad m) => m (m1 (a -> b)) -> m (m1 a) -> m (m1 b)
05:10:08 <[k-> compile xmonad with ghc options -prof -fprof-auto and run the xmonad with +RHS -xc (i hope this works)
05:10:48 <Cale> reactormonk: Does it print anything on the terminal? It just closes silently?
05:11:47 <erisco> are there helpers for getting Bool from Ordering?
05:11:50 <reactormonk> Cale, just closes silently. I'm forking off an emacs process, and after that has finished loading and forking off by itself (emacs dameon), xmonad just dies.
05:12:05 <Cale> hmm
05:12:12 <ski> erisco : `(>= EQ)', &c. ?
05:12:25 <reactormonk> Cale, exactly.
05:12:42 <erisco> > (LT < EQ, EQ < GT, LT < GT)
05:12:44 <lambdabot>  (True,True,True)
05:13:30 <reactormonk> Cale, actually also crashed ghci.
05:13:55 <erisco> ski, what is &c. ?
05:14:15 <Cale> What code are you running exactly?
05:14:28 <Cale> erisco: et cetera
05:14:29 <reactormonk> got spawnEnv env cmd arguments = liftIO $ getEnvironment >>= executeFile cmd True arguments . Just . Data.List.unionBy ((==) `on` fst) env
05:14:48 <reactormonk> https://gist.github.com/b46b45800edbda639b5f7f6bd261364c
05:15:02 <reactormonk> I'll also take comments on my haskell.
05:15:35 <reactormonk> spawnEnv [("FOO", "bar")] "echo" ["foo", "bar"]
05:15:38 <reactormonk> ^ kills ghci
05:15:42 <Cale> reactormonk: Oh, you don't want executeFile
05:15:45 <reactormonk> or rather, exits.
05:15:55 <Cale> That's like execv, it replaces the current process with the one given.
05:16:03 <reactormonk> oh fuck
05:16:30 <reactormonk> Which one's the right one?
05:16:54 <Cale> http://hackage.haskell.org/package/process-1.4.2.0/docs/System-Process.html -- I would use something from here...
05:17:20 <Cale> Perhaps spawnProcess
05:17:21 <erisco> so you can ((<= EQ) .) . comparing length  or  (return . (<= EQ) <=< comparing length)  or some such
05:17:47 <MarLinn> :t liftA2 (<*>) bool ((<) `on` length)
05:17:49 <lambdabot> Foldable t => t a -> t a -> t a
05:18:29 <erisco> oh, that "on" thing
05:18:50 <reactormonk> Cale, gotta use something that sets env
05:19:09 <erisco> so now it is just a wonder of what liftA2 (<*>) is
05:19:21 <bollu> erisco: why are you showing the ordering on LT, EQ, GT?
05:19:29 <bollu> erisco: is it to show that absolutely mad definition of lex ordering?
05:19:43 <[k-> Haskellers sure use some weird short forms...
05:19:50 <erisco> bollu, to determine what I should use, which happens to be <= EQ
05:19:55 <bollu> erisco: ahh, okay
05:19:56 <Cale> reactormonk: ah, those things exist there too -- runProcess will do it
05:20:10 <reactormonk> which is deprecated.
05:20:21 <Cale> Well, you can use createProcess
05:20:36 <reactormonk> Time to find out how to use constructors.
05:20:39 <Cale> Is it actually deprecated?
05:20:56 <reactormonk> It's under "old deprecated functions"
05:21:27 <Cale> Ah, you won't actually get a complaint from the compiler (yet?) though.
05:21:52 <Cale> http://hackage.haskell.org/package/process-1.4.2.0/docs/src/System.Process.html#runProcess -- you can look at the code for it
05:21:58 <Cale> It just calls createProcess
05:23:25 <Cale> You can probably skip all the stuff related to stdin/out/err
05:24:34 <Cooler> Cale, did you post a ping pong link?
05:24:41 <Cale> Cooler: no?
05:25:01 <Cooler> a link to a github page of ping-pong.hs
05:25:14 <Cale> Cooler: yeah, that wasn't me
05:25:21 <Cooler> who was it then
05:25:24 <ashishnegi> i am using `import qualified Aeson.Types as AT`  i now have to use `AT..=` in code.. looks a little ugly.. is there a way to just write `.=` without removing `qualified` ??
05:25:25 <Cooler> i forget
05:25:58 <Axman6> ashishnegi: on another line, add `import Aeson.Types ((.=))`
05:27:19 <erisco> hm, bit tough to wrap the mind around at the moment, but okay
05:27:33 <ashishnegi> Axman6: thanks.. works like a charm !!!
05:28:08 <erisco> so, liftAn is f (g1 x) (g2 x) … (gn x)
05:28:10 <[k-> Cooler: there is only one result: https://github.com/search?utf8=✓&q=ping-pong.hs
05:28:12 * hackagebot quantum-random 0.6.2 - Retrieve, store and manage real quantum random data.  https://hackage.haskell.org/package/quantum-random-0.6.2 (Cliff_Harvey)
05:28:21 <ashishnegi> Axman6: writing in `(..)` only loads those fns right ? even without qualified and all ?
05:28:38 <erisco> so then  liftA2 (<*>) is  f x <*> g x  which is  f x y (g x y)
05:28:39 <Axman6> if you happen to use Sublime Text, there's a smnippet that will expand to a qualified and unqualified verion of a library - really useful for Text and ByteString where you don't want to write BS.ByteString everywhere
05:28:42 <Cooler> [k-, yeah i found that one thats not it
05:28:50 <Axman6> ashishnegi: yes
05:29:06 <Cooler> oh yes, it was something to do with arrows
05:29:15 <Cooler> this type of arrow -<
05:29:27 <erisco> that is a bit obtuse to reason about it seems
05:31:38 <ski> erisco : `(liftA2 . liftA2) ($) f g'
05:31:46 <dabd> when using quickcheck do you try to write properties that enforce a correct implementation, or is that not the goal of PBT?  I think the goal of PBT is to check that a given implementation satisfies some properties but not the other way around. Thoughts?
05:31:58 <Cooler> is it frp that uses -< ?
05:32:14 <Cooler> arrowised frp
05:32:17 <Cooler> ?
05:32:47 <Cale> Cooler: That's part of the proc/do notation for Arrows
05:32:51 <erisco> ski, that helps a bit but what am I to make of liftA2 . liftA2 now
05:33:06 <Cooler> i think it might have been ReinH ?
05:33:26 <erisco> actually that seems straight-forward from the signature
05:33:42 <erisco> okay, quite nice … then the obscurity is just in ($)
05:33:43 <reactormonk> Looking for IO a -> IO () - anything specific for that?
05:33:50 <Axman6> void
05:33:53 <Axman6> :t void
05:33:54 <lambdabot> Functor f => f a -> f ()
05:34:05 <Axman6> (which is just fmap (const ())
05:34:07 <Axman6> )
05:34:24 <ski> erisco : "propagate an input to both arguments, twice"
05:34:28 <reactormonk> What's the correct syntax to append it?
05:34:48 <Axman6> huh?
05:34:52 <erisco> :t liftA2 . liftA2 -- type makes it obvious
05:34:53 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
05:34:56 <MarLinn> :t ( () <$ ) 
05:34:56 <Axman6> void (myIOAction)
05:34:58 <lambdabot> Functor f => f b -> f ()
05:35:01 * ski thinks that that `void' ought not to be in `Data.Functor',`Control.Monad'
05:35:06 <reactormonk> Axman6, and as postfix?
05:35:06 <erisco> and  liftA2 . liftA2 … . liftA2  is clear as well
05:35:13 <ski> (unless under another name)
05:35:21 <Axman6> uh, myIOAction & void, I guess
05:35:26 <Cooler> found it
05:35:27 <Cooler> 10:08:29 <ertesx> geekosaur: https://github.com/esoeylemez/wires/blob/master/examples/ping-pong.hs
05:35:27 <[k-> Cooler: why not you grep all the github links and tell by the link
05:35:46 <Axman6> :hoogle f a -> b -> f b
05:35:48 <erisco> quite a wonderful little thing
05:35:51 <Axman6> @hoogle f a -> b -> f b
05:35:54 <lambdabot> Control.Lens.Getter (>$) :: b -> f b -> f a
05:35:54 <lambdabot> Data.Tagged asTaggedTypeOf :: s -> tagged s b -> s
05:35:54 <lambdabot> Data.Functor.Compat (<$) :: a -> f b -> f a
05:36:12 <Cooler> the reason i needed that was to ask someone to explain that
05:36:56 <Cooler> what does -< do?
05:37:05 <reactormonk> spawnEnv addedEnv dir cmd arguments = void (liftIO $ getEnvironment >>= (\xmonadEnv -> runProcess cmd arguments (Just dir) (Just (Data.List.unionBy ((==) `on` fst) addedEnv xmonadEnv)) Nothing Nothing Nothing))
05:38:09 <Cale> Cooler: It tends not to occur on its own, and because it's part of this syntax which desugars into a whole bunch of different operations, it's not so easy to explain in isolation either.
05:38:09 <erisco> it is quite the leap from  liftA2 . liftA2 to bool through ($)
05:38:30 <Axman6> reactormonk: you could use void . liftIO $ ...
05:38:34 <Axman6> to avoid some brackets
05:38:46 <erisco> you have to clearly see  bool :: a -> a -> (Bool -> a)
05:39:05 <Cooler> Cale, can you explain with respect to that link?
05:39:37 <reactormonk> Axman6, any way to convert (Just dir) into something without () ?
05:39:40 <Cale> which link?
05:40:03 <Axman6> reactormonk: into "something"?
05:40:26 <reactormonk> An expression which means the same.
05:40:30 <Cale> Cooler: The idea is that when you have a line like  y <- f -< x  where f is of some type a b c,  where a is an instance of Arrow, it means that f is going to get x :: b as its input and produce the result y :: c
05:40:57 <Cale> Cooler: and the proc/do syntax will insert whatever operations are required in between to wire the results up appropriately
05:40:58 <Axman6> you could write pure dir, but it's the same number of characters...
05:41:31 <Axman6> reactormonk: it'll look cleaner if you spread it over more lines, that's quite a busy expression for a single line
05:42:20 <Cale> (mostly applications of arr which manipulate nested pairs)
05:42:30 <Cooler> Cale, that just sound like function application
05:42:35 <Cooler> sounds*
05:42:46 <Cooler> f :: b -> c
05:42:56 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation
05:42:57 <Cooler> you feed it x :: b and get a y :: c
05:43:15 <MarLinn> Cooler: arrows where invented as a generalization of functions
05:43:17 <Cale> Yeah, in the case of (->), it almost is
05:43:45 <Cooler> MarLinn, which arrows? ->  or -<?
05:43:49 <MarLinn> Cooler: I would suggest starting here: https://en.wikibooks.org/wiki/Haskell/Understanding_arrows
05:43:52 <Cooler> or both?
05:43:57 <Cale> Cooler: The type class
05:44:18 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html
05:44:55 <ski> Cooler : an arrow can have an internal/local state so that the next `x' it is fed will sometimees make it produce produce a different `y', even if the next `x' was equal to the one before
05:46:31 <Cooler> ski, so its not pure?
05:46:32 <Cale> It's awkward that we use the term "arrow" to refer both to the type level function, and to the values
05:46:53 <ski> Cooler : the point of it is to be able to express certain effectful computations, yes
05:47:05 <Cooler> isn't that why we have monads?
05:47:28 <Cale> Arrow is like Monad, but with different operations for combining together the computations
05:47:40 <ski> no, idioms (aka applicative functors) could also be said to be about expressing (a certain kind/class of) effects
05:47:59 <Cooler> (Thanks to Cale Gibbard for the improved artwork.)
05:48:11 <Cooler> is that the same Cale?
05:48:14 <Cale> yes
05:48:17 <Cooler> nice
05:48:20 <Cale> Applicative and Monad and Arrow aren't really *about* the effects, they're just ways to combine some things together.
05:48:35 <Cale> and sometimes those things we're combining happen to describe effects
05:48:48 <Cale> (usually, one might even say)
05:49:35 * ski takes it as axiomatic that they're describing effects :)
05:50:43 <ski> (well, or perhaps a better way to say it would be that i want to define "effect" (in one of these three restricted senses) to be anything expressible by these signatures)
05:51:01 <Cale> Yeah, that's fair enough :)
05:51:16 <Cale> Though there are some degenerate cases
05:51:23 <Cale> like with the (->) arrow, or the identity monad
05:52:28 <Cale> Perhaps effects are "whatever stuff distinguishes my monad from the identity monad" or similarly with regard to Arrow and (->)
05:52:49 <Cooler>   arr :: (b -> c) -> a b c
05:53:06 <Cooler> i haven't seem a b c in type signatures
05:53:10 <Cooler> what does that mean?
05:53:28 <erisco> Arrow, the bad parts
05:53:38 <Cooler> is it the type returned by applying a to b and then to c?
05:53:43 <MarLinn> it feels like arrows also add a definition of coeffect - but I think arrows where largely abandoned before coeffects came onto the scene
05:54:20 <jle`> Cooler: 'a' is a type constructor here, just like in any other case
05:54:23 <jle`> :t (>>=)
05:54:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:54:28 <jle`> it fulfills the same role as 'm' there
05:54:29 <erisco> Cooler, (b -> c) is (->) b c, it is converting from the Arrow (->) to any other Arrow
05:54:44 <Cale> Cooler: yes
05:55:00 <jle`> Cooler: you might have encountered Either before
05:55:19 <Cale> :t map :: (->) ((->) a b) ((->) ([] a) ([] b))
05:55:21 <lambdabot> (a -> b) -> [a] -> [b]
05:55:25 <jle`> (a b c) might be (Either Int Bool), so a would be Either, b would be Int, c would be Bool
05:55:31 <jle`> (Either isn't an instance of Arrow though)
05:56:36 <jle`> it's just that we usually don't see 'a' as a type constructor, by convention, so it does feel weird at first
05:56:43 <jle`> that's why i like arr :: (a -> b) -> r a b
05:57:13 <jle`> or arr :: Arrow (~>) => (a -> b) -> (a ~> b) hehe
05:57:17 <jle`> wait is that allowed
05:57:34 <jle`> ah no, ~> can't be a type variable
05:57:42 <jle`> arr :: Arrow r => (a -> b) -> (a `r` b)
05:57:45 <ski> Cooler : `a' is a type function, yes
05:57:58 <MarLinn> it's allowed with -XTypeOperators I think
05:58:17 <ski> `(~>)' used to be a valid type operator
05:58:20 <Cooler> so is a of kind * -> * -> * ?
05:58:22 <jle`> MarLinn: with TypeOperators, it still can't be used as a type variable
05:58:31 <jle`> just like Foo can't be used as a type variable
05:58:32 <ski> alas, no more
05:59:08 <MarLinn> ah... how sad
05:59:45 <ski> (for some reason, they wanted e.g. to have not only `(:+)' as a type constructor operator, but also steal `(+)' from variables to constructors ..)
06:00:00 <ski> (that's just being an example, of course)
06:00:44 <kamog> hmm, silly question: how to compose with a two parameter function?
06:00:44 <erisco> the syntax tyranny will soon overtake all the characters
06:00:50 * ski used `Arrow ar => (a -> b) -> ar a b', before type operators
06:01:10 <erisco> kamog, what are you composing it with?
06:01:11 <MarLinn> but it seems that does also not mean (:+) can be used on the value level 
06:01:12 <ski> Cooler : yes
06:03:01 <erisco> kamog, are you looking for  f (g x y)  ?
06:03:12 <jle`> kamog: you mean like foo x y = (x * y) + (x * y), maybe?
06:03:22 <kamog> erisco: any other suitable one parameter function. It would be nice to write comp2 instead of a lambda. 
06:03:28 <jle`> what would comp2 do?
06:03:37 <jle`> can you define what you are thinking for us
06:03:43 <jle`> comp2 f g _ _ = ?
06:03:52 <kamog> comp2 f g x = f . g x
06:04:03 <jle`> ah
06:04:15 <jle`> well, you can define comp2 yourself :)
06:04:27 <erisco> (f .) . g, fmap f . g, (fmap.fmap) f g
06:04:29 <jle`> a lot of people define it locally as (.:) in their own projects sometimes
06:04:37 <jle`> just don't do anything like the three examples erisco gave :)
06:04:47 <erisco> the last one is an excellent option
06:05:29 <erisco> you might want to have ret = fmap
06:06:28 <kamog> erisco: oh, that's what I need. Thank you.
06:06:41 <jle`> wait don't actually use that in real code please
06:06:47 <jle`> unless your goal is obfuscation
06:07:00 <erisco> it is well explained, see Semantic Editor Combinators by conal
06:07:07 <jle`> it is well explained
06:07:09 <jle`> but not well readable
06:07:12 <ski> @where SEC
06:07:13 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
06:07:20 <erisco> very readable, just say ret = fmap
06:07:34 <jle`> that is a debatable stance
06:07:54 <erisco> apparently
06:08:23 <jle`> pretty sure you're not going to find a consenus that (ret.ret) f g is immediately readable
06:08:53 <erisco> you are editing the return value of the return value, (ret.ret) is the path to what you are editing
06:09:00 <erisco> f is the editor, g is the subject being edited
06:09:17 <erisco> ret = (.), arg = flip (.)
06:09:46 <jle`> i know it makes sense :)  but it's definitely less than immediately readable, and definitely less readable than f (g x y)
06:10:47 <MarLinn> So the relation between monads and arrows is through app :: arr (arr b c, b) c. Extrapolating from that I come to the conclusion that a relation between comonads and arrows might be gained by coApp :: arr b (arr b c, c). Does that sound reasonable? (I'm still new to comonads)
06:11:33 <Cooler> erisco, whats wrong with comp2 f g x = f . g x
06:11:52 <Cooler> why do you need to use fmap
06:12:30 <erisco> there isn't anything wrong with it, it is typically named .:
06:12:50 <Cooler> so why would you do any of these? (f .) . g, fmap f . g, (fmap.fmap) f g
06:13:26 <jle`> i suggested potential use cases earlier :)
06:13:30 <erisco> (f .) . g  you will see sometimes and is something lambdabot likes to spew out
06:13:32 <jle`> *potential motivations
06:14:54 <erisco> fmap f . g  is like, for example, what you'd see when working on lists
06:16:06 <Cooler> fmap needs F a whats the functor here?
06:16:26 <erisco> in fmap f . g? it is a free choice
06:16:55 <Cooler> what if theres no functor
06:17:03 <erisco> fmap (*2) . take 10   for example is a form of something you might see
06:17:20 <erisco> then there is no difference between this, working on lists, and working on functions
06:17:51 <erisco> (fmap.fmap) i.e. (ret.ret) comes from conal's Semantic Editor Combinators
06:18:55 <erisco> Cooler, I don't understand the concern
06:19:00 <Cooler> fmap f.g needs a functor what if g doesn't return a  functor?
06:19:15 <erisco> well then it doesn't work, so what? :P
06:19:36 <Cooler> because the point was to compose a 2 parameter function with a single parameter function
06:19:47 <erisco> that's right, that is what it does
06:19:52 <Cooler> why bring functors into this and make it less general?
06:19:58 <erisco> it is more general
06:20:01 <erisco> look at the type signatures
06:20:07 <jle`> Cooler: if `g :: a -> b -> c`, `g x` is indeed something you can fmap
06:20:13 <Cooler> no it needs a functor now that you are using fmap
06:20:13 <jle`> g x :: b -> c
06:20:18 <jle`> and you can fmap that
06:20:32 <jle`> g x :: b -> c is indeed a fote
06:21:31 <jle`> it's `f c`, where f is (b ->), and (b ->) is a Functor
06:21:41 <Cooler> you can fmap b -> c because -> is a Functor?
06:22:00 <erisco> (a->) is a Functor, yes
06:22:23 <kamog> aw, that's cute (.).(.)
06:23:18 <Cooler> erisco, sometimes i feel like it would be better to use a visual editor and literally wire stuff together
06:24:03 <erisco> go a head and try and let me know how making edits in 2D works out
06:24:25 <MarLinn> Cooler: you're not the only one... :)
06:24:27 <kamog> and a comp3 is just (.).(.).(.) too
06:25:04 <Cooler> erisco, i mean its not better, it quickly gets out of hand for non trivial programs
06:25:18 <erisco> add a character pushes the line, add a line pushes the rest of the lines
06:25:25 <erisco> what happens in 2D when you need to insert something?
06:25:35 <erisco> what happens when you delete something?
06:25:59 <tdammers> what happens in 2D stays in 2D
06:26:44 <erisco> except dot product, because it is weird like that
06:26:47 <Cooler> erisco, huh? i mean something like this http://www.gginteractive.com/wp-content/uploads/2014/12/movement.png
06:27:01 <erisco> Cooler, yeah, I am thinking of the same thing
06:27:19 <Cooler> when you delete a node it goes away?
06:27:25 <MarLinn> But we *are* using visual editors. They just happen to be a bit too generic
06:27:28 <Cooler> i am not sure what the problem is
06:27:29 <erisco> and leaves a hole
06:27:37 <ongy> I have used a programming language like that (not for long, someone showed it to me). I don't think it's that great
06:27:56 <Cooler> MarLinn, perhaps graphical is a better term then?
06:27:58 <erisco> when you delete a character the hole is filled in by the character after
06:28:14 * hackagebot http-conduit 2.2.1 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.2.1 (MichaelSnoyman)
06:28:16 * hackagebot quantum-random 0.6.3 - Retrieve, store and manage real quantum random data.  https://hackage.haskell.org/package/quantum-random-0.6.3 (Cliff_Harvey)
06:28:18 * hackagebot atp-haskell 1.14 - Translation from Ocaml to Haskell of John Harrison's ATP code  https://hackage.haskell.org/package/atp-haskell-1.14 (DavidFox)
06:28:19 * hackagebot rosmsg 0.5.1.0 - ROS message parser, render, TH  https://hackage.haskell.org/package/rosmsg-0.5.1.0 (akru)
06:28:41 <erisco> when you delete a "box" (we'll call it), it just leaves a blank spot
06:28:47 <Cooler> so?
06:29:04 <erisco> imagine if your text editor worked like this
06:29:08 <Cooler> no
06:29:19 <MarLinn> Also, why use data flow programming? Functional programming can use its own visual style e.g. one very similar to the textual one we use now anyway
06:29:39 <Cooler> why would you want your visual scripting tool to work like a text editor?
06:30:02 <erisco> I don't know how else to convey this huge usability issue
06:30:08 <erisco> try using one for a while, I guess
06:30:21 <Cooler> erisco, well for trivial scripting its fine
06:30:26 <erisco> see how much time you spend manually rearranging things
06:30:40 <frontendloader> if you've ever used SSIS
06:30:50 <frontendloader> yuck
06:31:10 <Cooler> erisco, a text editor is also better because it uses screen space more efficiently
06:31:45 <erisco> the Lego Mindstorms editor had the most reasonable thing I've seen yet
06:32:04 <erisco> they have "rails" which you attach blocks to, which implicitly sequences them
06:32:10 <Cooler> i was just saying when we are trying to compose things all the time, and a lot of structures are built up just to compose things
06:32:17 <erisco> but now since it is effectively linear you don't have the same editing problem
06:32:21 <Cooler> a visual editor seems better
06:32:24 <erisco> and you can add multiple rails for concurrency
06:32:54 <erisco> but if your language doesn't have sequencing then it doesn't help
06:33:08 <ongy> I recently thought about functional programming entry points. And actually that was one of the things I thought of. The lego mindstorms editor
06:35:32 <fizbin> ongy: Have you seen http://david-peter.de/cube-composer/ ?
06:36:10 <erisco> that game where you try random orders until it works XD
06:36:10 <fizbin> Does anyone know how to get cabal to show me the ghc command line it's using when compiling something?
06:38:01 <cloudhead> what would you call the action of filling a type's type variables with types? ex: [a] -> [Int] ?
06:38:52 <erisco> substitution, instantiation, specialisation, unification … *shrug*
06:39:29 <cloudhead> thanks, I think specialisation works in my context!
06:39:41 <ongy> fizbin: I had not. It's qute
06:40:00 <fizbin> I'd call it specialization, since when you explicitly want ghc to make custom versions of a generic function for performance reasons, the pragma you use is SPECIALIZE.
06:40:00 <ongy> fizbin: add -v until it works I think
06:40:33 <erisco> GHC has templates? oh boy
06:40:50 <cloudhead> fizbin: ah that's right
06:41:02 <cloudhead> I think it's the most layman of the terms too
06:41:34 <cloudhead> and the opposite of generalize, so works well
06:42:47 <fizbin> ongy: Duh; I hadn't thought it could be that simple. Right. Just -v when building
06:46:49 <maybefbi> can i use rational numbers to handle currency?
06:47:30 <fizbin> maybefbi: That's a slightly unusual choice, but I don't see why not.
06:48:00 <maybefbi> fizbin, thanks
06:48:19 <fizbin> Just be sure to remember to round in the proper places.
06:50:37 <fizbin> That is, often in currency calculations there will be times when you need to round a particular transaction to the nearest small unit for that currency - 0.01 for USD, CAD, EUR, GBP, 1 for JPY and who knows what for other currencies - and you sometimes need to round partial calculations too.
06:51:00 <fizbin> Knowing where rounding is expected in currency calculations can be tricky.
06:53:48 <Cooler> fizbin, isn't that why there are libraries for it?
06:54:20 <erisco> ret = fmap, arg f = unFlip . contraFmap f . Flip  I see conal has this set up in TypeCompose
06:54:34 <fizbin> What I've seen in other environments (not haskell) was equivalent to saying in Haskell "All currency is kept as an Integer, and represents that many micros (10^(-6)) of local currency". So, for example, calculations in USD were done internally to the nearest thousandth of a cent but any number that had to show up on a report was rounded to the nearest cent and the rounded value was used in further calculations.
06:55:26 <conal> erisco: and now I'd write arg = inFlip . contraFmap, SEC-style
06:55:56 <conal> or inNew . contraFmap, using a Newtype instance
06:56:37 <fizbin> Cooler: I've found that where rounding needs to happen is a really business-specific question, and the kind of thing that can't be encoded into generic libraries. Libraries can be written to do the rounding, but knowing when to do it and which rounding mode to choose are going to depend on the kind of precise details you need to consult an accountant and occasionally a lawyer about.
06:56:59 <pavonia> There are also crypto-currencies which require an even higher precision
06:57:19 <tdammers> libraries can be written to provide a DSL that user code can use to explicitly define where and how to round
06:57:24 <haskell249> is haskell-mode and intero compatible on emacs ?
06:57:50 <fizbin> pavonia: True. I should check with my old colleagues at that place that used bigints-of-micros and ask them how (or whether) they're representing BTC.
06:58:08 <erisco> ah, which has the nice definition unFlip ~> Flip
06:58:32 <erisco> I recall some generalisation of wrapping and unwrapping … not quite sure though
06:58:38 <conal> erisco: yep. or Flip <~ unFlip
06:59:09 <conal> erisco: see newtype or newtype-generics.
07:01:54 <fizbin> (bigints were used because of an embarrassing overflow on a 64-bit integer around 2005 caused by Turkey's currency going into an inflation death spiral. In general, overflowing a 64-bit int is hard but inflation death spirals are exponential processes)
07:03:18 <lolisa> Hi, this is a bit out of place (apololgy for not knowing where else should I go), but in http://www.cse.chalmers.se/~coquand/TRIESTE/BridgesReeves.pdf, it said "for Brouwer math preced logic". Can anyone explain what it mean? As someone who use coq for a while (and know abit about ZFC) I dont really get it...
07:05:39 <erisco> I suppose not too helpful here
07:13:43 <Cooler> what does <$> do?
07:13:51 <Cooler> has the same signature as fmap
07:14:02 <Cooler> @src (<$>)
07:14:03 <lambdabot> f <$> a = fmap f a
07:14:10 <mizu_no_oto_work> Cooler: <$> is the same as fmap
07:14:10 <Cooler> oh
07:14:19 <mizu_no_oto_work> just infixified
07:15:07 <Cooler> i don't like that, i like to think of fmap as a function that takes one parameter
07:15:15 <Cooler> which is actually the case
07:15:46 <srhb> Cooler: And it's still the case (in so much as it taking two arguments is also still the case)
07:16:22 <mizu_no_oto_work> It's common to see it used with <*>, as in if you have an f :: X -> Y -> Z, and an x :: M X and y :: M Y, you might say f <$> x <*> y to get a M Z.
07:16:23 <srhb> Cooler: And <$> looks very neat when used in conjunction with <*> of Applicative.
07:17:35 <mizu_no_oto_work> Cooler: Functions and operators are fundamentally the same thing in Haskell
07:18:21 <Cooler> fmap f looks better
07:18:30 <mizu_no_oto_work> The difference is really just parsing-wise; i.e. operators are infix while functions are prefix
07:19:34 <Cooler> :t average
07:19:35 <lambdabot> error: Variable not in scope: average
07:19:40 <jle`> Cooler: there are multiple ways to look at fmap that each give insight to its usage :)
07:19:45 <Cooler>     fps <- hold 0 . (fmap recip <$> average 25) -< deltas
07:19:57 <Cooler> whats average and hold?
07:21:11 <jle`> it looks like they are library-defined functions
07:21:26 <mizu_no_oto_work> What does that file import?
07:22:00 <Cale> Cooler: If I had to guess, average n probably takes an average of the last n values of that stream
07:22:35 <Cale> ah, and it must be a stream of Events
07:22:42 <Cale> which occur at some moments and not others
07:23:29 <Cale> what hold 0 does is turn that "event" into a "behaviour" which always has a value, starting out at 0, and updating to whatever the last seen value was
07:24:00 <Cale> But these are guesses based on the names and general knowledge of FRP, I don't know which library you're using, so they might be a little off
07:24:28 <Cooler> wires
07:24:29 <Cooler> https://github.com/esoeylemez/wires/blob/master/examples/ping-pong.hs#L41
07:24:54 <Cooler> https://github.com/esoeylemez/wires/blob/master/examples/ping-pong.hs#L42
07:24:59 <Cooler> had to make it 42
07:25:07 <Cale> Cooler: But basically, it's saying that fps is this quantity which starts out at 0, and then whenever an average of the last 25 time deltas is available, it becomes the reciprocal of that
07:25:38 <ccapndave> Hey everyone.  Is is standard style to use <$> instead of fmap even outside of Applicatives?
07:26:02 <Cale> ccapndave: I use both interchangeably, depending on what seems to read better in any given instance
07:26:19 <ccapndave> Ok cool
07:26:21 <ccapndave> Ta
07:26:35 <mizu_no_oto_work> Cooler: https://github.com/esoeylemez/wires/blob/8f7e332a5f78d748ff284703275adc55dd08846d/examples/Utils.hs  https://github.com/esoeylemez/wires/blob/3febd7d67e196846e90599049f47bf39fc2dfbce/Control/Wire/Core.hs
07:26:55 * jonored might go for a "generally <$> for using it right there, and fmap for passing it to a combinator" heuristic.
07:27:15 <ccapndave> jonored: Right - that makes good sense
07:27:45 <ccapndave> What other very commonly used infix operators are there in Haskell apart from <$> and <*> ?
07:27:53 <Rembane> >>=
07:27:53 <jle`> +, -, *
07:27:57 <jle`> /
07:27:57 <Rembane> =<<
07:28:01 <Cooler> Cale, is hold an accumulator that updates to the latest value when there is one?
07:28:01 <jonored> But that's just a heuristic, really. I'm not used to <$> yet.
07:28:15 * hackagebot zip-archive 0.3.0.5 - Library for creating and modifying zip archives.  https://hackage.haskell.org/package/zip-archive-0.3.0.5 (JohnMacFarlane)
07:28:30 <Cooler> so not an accumulator, more like state
07:28:44 <Rembane> I'm really fond of <$> since it works exactly the same as $ apart from the functor part.
07:28:50 <ccapndave> Those are the most common ones then?  <$>, <*>, >>= and =<<
07:28:58 <ccapndave> (Don't care about the mathematical operators)
07:29:15 <jle`> i wouldn't call >>= and =<< common on the same level as <$> and <*>
07:29:19 <ccapndave> And $ is just function application right?
07:29:25 <jle`> (.) is pretty common
07:29:29 <ccapndave> The same as <| in F# or Elm
07:29:35 <jle`> f $ x =  f x
07:29:49 <ccapndave> Right
07:29:51 <ccapndave> What does (.) do?
07:29:59 <jle`> @src (.)
07:29:59 <lambdabot> (f . g) x = f (g x)
07:30:06 <ccapndave> Oh right
07:30:11 <ccapndave> Composition
07:30:15 <Cale> Cooler: yes
07:30:39 <mizu_no_oto_work> >=> is pretty fun.
07:30:59 <ccapndave> I was considering making a little helper library for Elm with some commonly used infix functions, but since there are no typeclasses you have to make one per module
07:31:34 <Cooler> Cale, uh so why not use state
07:31:40 <ccapndave> Sounds like <$> and <*> are the most important ones
07:34:03 <mizu_no_oto_work> Cooler: you mean "why not use the state monad or a mutable variable of some sort"?
07:34:17 <Cooler> yes
07:34:59 <mizu_no_oto_work> Well, you're already using FRP, right?  Why introduce another mechanism for something when you're already using  perfectly good one?
07:35:30 <mizu_no_oto_work> Unless you're really asking 'why use FRP in the first place'
07:35:54 <Cooler> i am not even sure what frp is
07:36:07 <Cooler> its basically callbacks?
07:36:59 <conal> Cooler: http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#comment9673470_1030631
07:37:11 <Welkin> ...
07:37:15 <Welkin> Cooler: wtf no
07:37:16 <Welkin> O.o
07:37:34 <Welkin> but most people don't know what frp is
07:37:40 <Welkin> so they call React "frp"
07:37:48 <Welkin> and every new javascript thing is called "frp"
07:38:02 <Welkin> even though it is not functinal, nor reactive
07:38:04 <conal> Cooler: rather, http://stackoverflow.com/a/1030631
07:39:16 <Cooler> oh right, i know about react
07:39:23 <Cooler> i keep forgetting though
07:39:33 <Welkin> Cooler: react is not frp though
07:39:41 <Welkin> and it uses mutal state all over the place
07:39:44 <Welkin> mutable*
07:40:07 <alviprofluvium> Hello
07:40:55 <lyxia> alviprofluvium: hello
07:40:56 <Welkin> alviprofluvium: why does your name look like a pharmaceutical?
07:40:56 <alviprofluvium> Is there a way to restrict some input using types? For example I want my function to only accept positive integers.
07:41:12 <Welkin> it sounds like an erectile dysfunction drug
07:41:13 <Cale> Cooler: FRP is a principled way of *avoiding the need for callbacks* :)
07:41:20 <alviprofluvium> Do I need to use guards and a default "negative" answer, or there is a better way?
07:41:30 <alviprofluvium> jajja
07:41:39 <Welkin> alviprofluvium: create a new type
07:41:40 <alviprofluvium> its diahrrea in latin
07:41:41 <alviprofluvium> jaj
07:42:09 <lyxia> Word is the unsigned int of Haskell, though not as common.
07:42:36 <Welkin> oh yeah, you could use Word, too
07:42:57 <Cale> Cooler: It does this by giving you values that represent the manner in which "something changes over time", and then ways to combine those to produce new representations of "something which changes over time".
07:43:23 <Cale> Cooler: I'm using scare quotes there because I need to actually say what those things are more precisely.
07:43:52 <Welkin> but those are double primes, not quotes!
07:43:57 <Cale> Cooler: Basically, there are at least two fundamental ways that we identify that something might be changing over time
07:44:15 <lyxia> alviprofluvium: most programmers are lazy and just use Int + guards
07:45:04 <Cale> There are things which always have a value whenever you care to look at them -- these are called "behaviours"
07:45:04 <alviprofluvium> does Word maxbound is twice as big as Int's?
07:45:06 <Cale> things like
07:45:29 <lyxia> > (maxBound :: Word, maxBound :: Int)
07:45:31 <lambdabot>  (18446744073709551615,9223372036854775807)
07:45:40 <lyxia> alviprofluvium: looks like it
07:45:51 <Cale> The current location of the mouse, the currently pressed set of modifier keys, the current hitpoints of a monster, the current scene to be drawn on the screen
07:46:05 <Cale> Even perhaps the current time
07:46:05 <alviprofluvium> oh, ok
07:46:07 <alviprofluvium> Thanks!
07:46:34 <Cale> Then there are things which occur at particular instants in time, and have a value just at those moments when they occur
07:47:13 <jonored> Out of curiosity, is there a usual "positive Integer" kicking around, or is that relegated to various libraries/not useful enough?
07:47:39 <Cale> Things like the sequence of keystrokes or mouse clicks, the sequence of attacks made by a monster, the sequence of audio clips to be played, the sequence of requests made to an external server, or the sequence of responses coming back
07:47:40 <fr33domlover> alviprofluvium, note that the bit size is the same, 64 for both on 64bit machines
07:48:04 <fr33domlover> Word just starts from 0, while for Int, 0 is in the middle of its range
07:48:05 <Cale> any such sequence is referred to as an "event"
07:48:43 <Cale> (any particular event might occur many times, or never)
07:49:21 <alviprofluvium> so its "just" the unsigned int. Ok
07:49:31 <lyxia> jonored: there's Numeric.Natural in base
07:49:50 <jonored> Ah! Thanks for satisfying my curiosity :)
07:50:08 <mizu_no_oto_work> "A Word is an unsigned integral type, with the same size as Int." - https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Word.html
07:50:09 <Cale> Cooler: So, FRP systems provide some way of representing behaviours and events, and then a bunch of ways to combine them and construct new behaviours and events from existing ones (and perhaps some lower level ways to get hold of events and/or behaviours from whole cloth in terms of lower level IO)
07:51:48 <Cale> In Arrow-style FRP, generally the inputs and outputs of your arrow computations are implicitly Behaviours, and you have an Event type that gets used explicitly
07:52:19 <Cale> (this isn't necessarily the case, but it's true of most of the Arrow-style FRP systems)
07:53:26 <Cale> There's also a style of FRP where both Events and Behaviours are first class values, and you have parametric types Event a and Behaviour a for events and behaviours whose values have type a
07:53:44 <Cale> Reflex is an example of such a system
07:55:14 <Cale> Cooler: anyway, I might say more about it, but I don't know if you're still here :)
07:55:35 <Welkin> he went off to avenge the death of his brother and father
07:55:48 <Welkin> he will only return once
07:55:50 <Welkin> in metal form
07:56:28 <tsahyt> I've been playing around with finding the longest palindrome in a string using a zipper, but it consumes a lot more space than I'd like it to. can someone help me in finding out why? http://lpaste.net/8006481482614833152
07:57:16 <Cooler> Cale, yes i am still here
07:57:17 <tsahyt> according to the heap profile longestPalindrome.go accumulates a lot of space but I'm not sure why it would do that
07:57:38 <Cooler> why is it called Behaviours instead of Varying?
07:57:49 <Cale> It's just tradition
07:58:05 <Cale> Practically all the FRP systems use this terminology, so it's not worth changing it now
07:58:13 <Cale> and I believe it actually predates FRP
07:58:20 <tsahyt> with a lot of space I mean roughly 1G of maximum residency on a 10M input file
07:58:49 <Cale> and goes back to earlier work on semantics describing systems of interacting components
07:59:05 <Xioouves> Hi, haskell newbie here. Does anybody have useful resources for writing parsers and compilers?
07:59:30 <Cale> Xioouves: There's a book by Simon Peyton Jones which is now freely available
07:59:37 <tsahyt> Xioouves: checkout "write yourself a scheme in 48 hours"
07:59:40 <Xioouves> That's cool
07:59:43 <Xioouves> Thank you
08:00:44 <Cale> Xioouves: I would link you, but the URL has apparently changed, one moment
08:00:55 <Xioouves> I think I found it
08:01:12 <Xioouves> on wikibooks
08:01:53 <Cooler> Cale, aren't events just callbacks though?
08:01:58 <dabd> I'm having a hard time reading Haskell code. What are the types of nil and cons here? https://gist.github.com/erd17/0934c1aa3b58e7152e94b801e82b4960
08:02:25 <Cale> Xioouves: The one I'm thinking of is called "The Implementation of Functional Programming Languages" and it's from 1987. It's not actually using Haskell, but Miranda, which is the immediate predecessor to Haskell and is very similar.
08:02:49 <Cale> (Haskell was originally conceived as a kind of open-source redo of Miranda)
08:03:32 <Cale> Cooler: No, they're representations of a sequence of values which occur at particular moments in time.
08:03:54 <Xioouves> I'll make sure to check it out. Never heard of Miranda. Thank you for the help!
08:04:00 <lyxia> dabd: you can have ghc infer it by adding partial annotations above them "nil :: _" "cons :: _"
08:04:09 <lyxia> infer and print the types
08:04:10 <Cale> Cooler: Event a is very roughly like [(Time, a)], where the sequence of times is strictly increasing
08:04:36 <Cale> Cooler: Of course, internally, it may have a very different looking representation.
08:05:17 <zennist> what's the current status of interfacing with C++?
08:05:18 <greymalkin> Should I use mtl or transformers?
08:05:31 <zennist> i just found a library called hoppy that claims to do that - anyone tried?
08:06:17 <Cale> Cooler: In Reflex, for instance, the internal representation of events is quite complicated, and has to do with all the different ways in which one can construct an Event initially https://github.com/reflex-frp/reflex/blob/develop/src/Reflex/Spider/Internal.hs#L182 -- you usually don't actually think about this though when using the FRP system (any more than you'd think about the manner in which GHC is compiling your 
08:06:17 <Cale> code into assembly)
08:06:33 <dabd> lyxia: like this? https://gist.github.com/erd17/0934c1aa3b58e7152e94b801e82b4960
08:06:43 <dabd> when I reload it I get a lot of errors
08:07:05 <lyxia> dabd: yes it's in the errors
08:07:10 <eklavya> glguy: Cale should one not use ExceptT?
08:07:12 <Cooler> Cale, i mean you still think of it in terms of inlining
08:07:40 <lyxia> dabd: it tells you "'_' standing for 'some -> type'"
08:07:43 <tsahyt> why does building my code with cabal/ghc 7.8 result in an executable that only uses half the memory over the one built with stack/ghc 7.10.3?
08:07:55 <tsahyt> it's still way too much, but that I did not expect
08:07:56 <Cooler> why wouldn't you just implement events as callbacks? isn't that the most performant?
08:08:10 <Cale> Cooler: absolutely not -- it does something *much* fancier
08:08:26 <dabd> lyxia: I get nil :: t -> [t1]  which doesn't help me much
08:08:47 <dabd> cons is cons :: a -> ([b] -> [c]) -> [b] -> [c]
08:09:16 <Cale> Cooler: It works out which things actually need to be notified, building up a graph the computation being done, effectively, and is able to take various shortcuts based on the form of the event
08:09:37 <lyxia> dabd: nil has type t -> [u], but is used as [b] -> [c].
08:09:48 <dabd> lyxia: I am trying to translate that function to Scala, since type inference in Scala sucks I need to know the precise types to help the compiler
08:10:41 <Cooler> Cale, so "hold" comes into this how?
08:10:45 <Cale> Cooler: As a simple example, if you have an event which turns out it's never going to fire going into a hold, then you know that the hold isn't going to change its value, and you can treat that Behaviour as a constant
08:11:07 <Cale> and then from the fact that the Behaviour is a constant, you can avoid doing lots more work...
08:11:29 <jonored> It is probably appropriate that Events "feel like" that, though - and IO in a do block "feels like" straight imperative code much of the time - but is fancier and a cleaner abstraction to work with.
08:11:37 <lyxia> dabd: okay, so nil :: [b] -> [c]
08:11:41 <tsahyt> building with stack/ghc 7.8.4 by forcing lts-2.22 results in the same behavior as with 7.10.3. why does building with cabal make my stuff run better?
08:11:59 <Cale> Cooler: hold is the fundamental way in which things get remembered over time
08:12:20 <Cooler> Cale, oh hold converts Events into Varyings
08:12:32 <Cale> yeah
08:12:55 <Cale> Into Behaviors (I'm going to use that term, because all the FRP systems use it, so you might as well get used to it)
08:13:22 <Cooler> i think of Varying from Opengl
08:13:56 <tsahyt> does maximumBy get fused with list fusion?
08:14:20 <[k-_> you have to look at the rules
08:14:33 <Cale> It takes an initial value, and an Event, and produces a Behavior whose initial value is the given one, and at any time after the present moment when that Event occurs, the value of the Behaviour changes immediately afterward to become the Event's value.
08:15:22 <Cale> Note that occurrences of the Event which occurred in the past, before we executed the hold, are ignored, which means that we don't have to store them
08:15:58 <Cale> and that at the moment when the event is firing, the Behavior will still have its old value, rather than the one it is being updated to.
08:16:51 <Cale> That may seem like an arbitrary convention, but it's actually rather important, because in conjunction with some other operations, it's what allows us to make a comparison between the old and new value
08:17:31 <Cale> (and to implement things like accumulators in terms of hold and recursion)
08:19:12 <Cale> another relatively fundamental thing (though it's not actually a primitive in Reflex, it was a primitive in some earlier FRP systems I worked on and I still mostly think of it as one)
08:19:54 <Cale> attach :: Behavior a -> Event b -> Event (a,b)
08:20:29 <Cale> This allows us to measure the value of a Behavior at the moments that an Event is occurring, pairing up the two.
08:20:44 <Cale> There are a bunch of variations on this...
08:21:30 <tsahyt> nope, that wasn't it either. I'm really at a loss here. Does anyone have any idea why this code would use so much memory?
08:21:33 <Cooler> Cale, is that haskell?
08:21:39 <Cale> Cooler: basically, yes
08:21:44 <Cooler> a haskell library i mean
08:21:49 <tsahyt> here's the link again, for reference, http://lpaste.net/8006481482614833152
08:21:51 <Cale> http://web.mit.edu/greghale/Public/reflex/html/reflex/Reflex-Class.html
08:22:01 <Cale> I left out some type parameters for clarity, but you'll find it here
08:22:13 <Cale> attach :: Reflex t => Behavior t a -> Event t b -> Event t (a, b)
08:22:20 <Cale> Is the real type in Reflex :)
08:23:22 <Cooler> so why use Wires if you have Reflex?
08:23:31 <Cale> Well, Reflex is newer
08:23:48 <Cale> and it was really really hard to implement
08:24:10 <Cale> but Ryan's finally got it to a point where it's practical for real world applications
08:24:25 <Cooler> well sure if you are doing some fancy graph construction of the dependencies
08:24:31 <Cooler> and reducing that
08:25:22 <Cale> Yeah, I'm not even really the right person to talk about that stuff in the case of Reflex, because I barely understand what's going on in there -- I worked on an earlier arrow
08:25:30 <Cale> arrow-based FRP system with Ryan
08:25:59 <[k-_> tsahyt: I don't know how to read haskell code proficiently but I know that if you want to make a program fast (and use less memory), make it do less. (At least, that was what I did for my project which I reduced from taking 60+s to taking only 0.06s)
08:26:04 <Cale> We build the better part of an action RPG in Haskell with that before running out of money for it :)
08:26:44 <tsahyt> [k-_: this is specifically about allocations. I spend most of the time just garbage collecting.
08:26:45 <ongy> Cale: did anything of that ever get released?
08:27:03 <Cale> ongy: Not directly, but Reflex embodies a lot of what we learned there
08:27:49 <cheater> Cale: did it include graphics?
08:27:49 <[k-_> hmm, that means you are allocating too much?
08:27:50 <tsahyt> [k-_: usually this points to laziness making some problems. something here is too lazy for its own good but I can't figure out what
08:28:02 <cheater> or was it text based?
08:28:13 <Cale> cheater: Yeah, there was a dynamically loaded open world
08:28:16 * hackagebot timezone-series 0.1.6.1 - Enhanced timezone handling for Data.Time  https://hackage.haskell.org/package/timezone-series-0.1.6.1 (YitzGale)
08:28:18 * hackagebot bookkeeper-permissions 0.1.0.0 - Permissions for bookkeeper records  https://hackage.haskell.org/package/bookkeeper-permissions-0.1.0.0 (pkamenarsky)
08:28:22 <cheater> ah, right, like in GTA
08:28:49 <cheater> Cale: if you wanted to do this today, what lib would you use for the graphics backend?
08:28:50 <Cale> uh, I guess?
08:29:00 <[k-_> tsahyt: you could try using some language extensions like -XStrict -XStrictData to see if laziness is the problem
08:29:07 <Cale> I don't know. I haven't looked carefully at graphics libraries in a while
08:29:08 <tsahyt> I'm not on ghc 8
08:29:09 <cheater> afaik GTA is the first popular game that streamed its levels
08:29:41 <Cale> cheater: But probably what I would do is build some 3D library on top of reflex.
08:29:48 <cheater> OK
08:29:50 <Cale> (and something else)
08:30:01 <cheater> something else for what purpose?
08:30:06 <cheater> input?
08:30:08 <Cale> Well, for actually drawing
08:30:09 <[k-_> :o those are ghc 8? sorry, I'm still a beginner to haskell and programming
08:30:31 <mizu_no_oto_work> Cale: did you guys make a kickstarter?
08:30:51 <cheater> yes, OpenGL and the likes are just so terrible to work with for a sane person
08:31:03 <Cale> mizu_no_oto_work: No, I'm actually not certain how exactly Ryan funded us -- I think it was kind of an out-of-pocket venture.
08:31:17 <Cale> mizu_no_oto_work: Sort of 50% game development, 50% research project
08:31:52 <Cale> The game didn't get released, but we learned a lot, and are making money with the ideas now, so the research can probably be said to be successful :)
08:32:13 <mizu_no_oto_work> Have you thought about open sourcing it or going back to it at some point?
08:32:39 <Cale> I kind of would like to go back to it at some point, but like, none of the code would really be what I want it to be now :)
08:33:55 <Cale> But some of the ideas for the game itself were interesting. The idea was you smash monsters with a giant hammer, and then the magic system involves the blood spatter in various ways.
08:34:28 <[k-_> tsahyt: is a space leak when an object is persisting in the heap longer than it should be?
08:34:34 <Forlorn> Hi what's wrong in this function?
08:34:35 <Forlorn> http://sprunge.us/jaFD
08:34:44 <tsahyt> [k-_: it's when you build up lots of thunks
08:34:51 <tsahyt> see the discussions on foldl
08:35:05 <Forlorn> I think I don't understand how to convert correctly
08:35:23 <Cale> We hadn't actually done all of that part (well, there was some code for blood flow...), but you could fight against melee and ranged AIs and run around in the (mostly empty) world, and there was collision detection, and we had a visual map editor.
08:35:24 <tsahyt> [k-_: https://hackhands.com/lazy-evaluation-works-haskell/ this is a pretty good read
08:35:35 <tsahyt> I think my problem here might be the opposite. I'm too strict
08:35:52 <tsahyt> due to something I retain a lot of thunks that are no longer needed while unfolding
08:36:02 <Forlorn>  = floor (fromInteger (n) * log n)
08:36:08 <Forlorn> a =
08:36:11 <tsahyt> I only need one zipper at a time but it's obvious that all the 10 million zippers stick around to some degree
08:36:28 <Forlorn> a needs to be an integer
08:36:34 <Forlorn> n is an integer too
08:37:04 <Cale> mizu_no_oto_work: It was a little frustrating to drop it at the point we got to, since it was just starting to actually be fun to play, you could set up some combat scenarios and fight a bunch of enemies.
08:37:33 <Cale> Oh, and it also had touch input -- the plan was to be able to run it on iPhones and other mobile devices.
08:37:44 <[k-_> tsahyt: thanks for the link
08:38:35 <glguy> eklavya: The question is too general to give much of an answer for. There are cases where it's useful and cases where it's not.
08:38:36 <ertes> what was the FRP topic?  how to choose between reflex and wires?
08:39:04 <amalloy> Forlorn: you can't call log on an Integer
08:39:05 <amalloy> :t log
08:39:06 <lambdabot> Floating a => a -> a
08:39:27 <Forlorn> a = floor (fromInteger (n) * log fromInteger(n))
08:39:30 <Forlorn> amalloy, like so then?
08:39:54 <amalloy> yes, although i would extract that four-times-repeated fromInteger into a where clause
08:40:00 <amalloy> m = fromInteger n
08:40:46 <mnoonan> Forlorn: that would parse like log(fromInteger) (n), you want log (fromInteger n)
08:41:00 <lyxia> why does stack haddock put highlight.js and style.css in my source directories
08:41:24 <Forlorn> amalloy, that sounds much more reasonable
08:41:33 <Forlorn> thanks
08:41:37 <Forlorn> mnoonan, oh, I didn't know
08:42:06 <lyxia> oh it's fixed in stack 1.2
08:42:38 <mnoonan> really (log fromInteger) (n), but I hope what I wrote was clear enough as a Haskell/C amalgam :)
08:42:53 <ongy> Cale: sounds like a real shame you had to stop
08:45:21 <Cale> ongy: Somewhat, but I don't feel too bad about it at this point. The most important aspects of what we did were in figuring out stuff about how to make FRP practical, and most of that knowledge has been largely encoded into Reflex. (There was some more stuff about revising Arrow which is unneeded in Reflex, but maybe I'll try to push that forward at some point)
08:46:02 <Cale> ongy: What I *would* like to see is more infrastructure around Reflex to make writing games and not just web applications easier to do
08:46:11 <Cale> But web applications are much easier to pay the bills with :)
08:46:18 <ongy> reflex-gl?
08:46:20 <Cale> yeah
08:46:27 <maerwald> reflex-gtk plz
08:46:29 * glguy wants to look into reflex-vty
08:46:39 <Cale> Yeah, all these things ought to exist
08:46:48 <maerwald> go write it for us :D
08:47:03 <Cale> It just, requires time from people who know the system well enough.
08:47:12 <ongy> wouldn't reflex-sdl be better for games?
08:47:15 <Cale> It doesn't require understanding reflex at the very low level
08:47:59 <ertes> reflex-sdl is better in general architecturally:  one thing to note about reflex is that its controller semantics is almost stateless except for updating behaviours
08:48:06 <srhb> ongy: I've had a go at it recently. Doing the low level integration is easy enough, but making anything useful of the sdl events is... Less obvious.
08:48:12 <Cale> But just the middle level of abstraction, Reflex.Host.Class
08:48:14 <ertes> in other words:  binding to something callback-based like GTK is actually surprisingly difficult with reflex
08:48:28 <glguy> Cale: Suppose I wanted to learn enough reflex to implement reflex-vty, would the reflex library on its own be enough to dive into?
08:48:31 <ertes> those are the things reactive-banana actually handles better than reflex
08:48:34 <glguy> I don't know that ecosystem
08:48:39 <maerwald> ertes: ah, interesting
08:48:41 <Forlorn> can you find in reverse?
08:48:54 <Forlorn> oh nvm
08:48:58 <Cale> glguy: Yeah -- I would recommend playing around with reflex-dom for a bit, just to get a sense for how it's used
08:49:10 <maerwald> unfortunately reactive-banana only has a few toy wxwidgets bindings
08:49:14 <jonored> Is there a web server + websockets reflex yet? :)
08:49:14 <Cale> glguy: and then just the reflex library itself would be what you use
08:49:19 <ertes> reflex handles things better that have inverted control like a main loop with event polling: like SDL
08:49:32 <ertes> or vty
08:49:58 <ertes> (or preferably event *waiting* of course)
08:50:10 <Cale> jonored: There's like some servant-reflex stuff, I don't know how it is to use, I haven't tried it yet.
08:50:26 <Cale> (and I don't know whether it does websockets stuff)
08:50:27 <jonored> I would love to just pipe events/behaviors to and from a server with reflex-dom on clients for the sorts of things I use haskell for :)
08:51:05 <Cale> But yeah, the backend infrastructure is definitely something we *need* to put some time into, especially if we're going to continue doing these complex web applications for clients
08:51:21 <ertes> if you want to write anything with FRP framework X using toolkit Y, i suggest not waiting for the X-Y library to appear…  neither do i suggest writing it
08:51:21 <jonored> Would also just plain be neat to do a MUD.
08:51:38 <ertes> i suggest understanding the controller semantics of the FRP system and just using the portions you need for the application
08:51:52 <Cale> ertes: Well, that's fair.
08:52:02 * jonored is certainly not going to wait, he's just going to avoid duplication of effort if he can.
08:53:49 <ertes> as for reflex vs. AFRP: if you can, use reflex
08:53:50 <Cale> We've just been using a bunch of relatively boring libraries built on top of snap and websockets and postgres-related stuff for our backends, but the fact that we can build these really dynamic UIs has sort of put us in a spot where the backends needed to support it have gotten trickier and trickier to write.
08:53:58 <ertes> if not, talk to me =)
08:54:56 <srhb> ertes: I'd love to see some actual handling of what would otherwise be an SDL main loop. I find it completely nonobvious despite assurances that Reflex does it well. :-P
08:55:00 <ongy> ertes: why? will you make us be able to use reflex?
08:55:01 <srhb> If you ever happen upon any, that is.
08:55:08 <Sonolin> how do I get DPI in haskell?
08:55:20 <Cale> ertes: I'm not 100% sure I agree with respect to the remark that it's hard to interact with callback-based libraries using reflex. After all, that's what we're doing with the DOM :)
08:55:20 <Sonolin> all I really need is a way to get display width/height (in inches/whatever)
08:55:24 <ertes> srhb: with reflex?
08:55:31 <srhb> ertes: Yes.
08:55:45 <ongy> Sonolin: which OS are you on?
08:55:53 <Sonolin> Linux using X11
08:56:08 <alviprofluvium> im trying to install quickcheck with stack. But I can't. It says that it's not in my indices. (I've already added it to my global stack.yaml). Google doesnt help me :S
08:56:23 <ertes> srhb: this might help you: http://lpaste.net/177975
08:57:22 <ertes> ongy: no, but reflex can't be used for everything right now, especially when it comes to real-time stuff with *lots* of moving parts
08:57:25 <glguy> Is anything in particular holding reflex up from using GHC 8?
08:57:30 <ongy> Sonolin: you can get it by binding against the x11 library. It's rather low level though
08:57:51 <ertes> ongy: and i'm working on a new AFRP library to replace netwire
08:57:53 <Sonolin> yea I'm looking at http://hackage.haskell.org/package/X11-1.6.1.2/docs/Graphics-X11-Xrandr.html
08:58:08 <Sonolin> assuming its likely there somewhere
08:58:13 <ertes> glguy: reflex itself works with GHC 8
08:58:21 <ertes> not sure about reflex-dom or the other stuff built on it
08:58:21 <kadoban> alviprofluvium: It's case sensitive, QuickCheck. Also "stack install QuickCheck" makes little sense, if that's what you're doing. QuickCheck has no executables. In what context are you trying to use QuickCheck?
08:58:29 <glguy> ertes: OK, just waiting on a release?
08:58:46 <ertes> Cale: but you're keeping some extra state, right?
08:59:12 <ertes> Cale: because you can't just "register a callback" with reflex the way you can with reactive-banana
08:59:40 <ertes> glguy: oh, let me try building 0.4.0
09:00:31 <alviprofluvium> im trying to add a test to some function (¡just to learn how to use it). I'm calling it from repl
09:01:00 <ertes> glguy: built
09:01:24 <alviprofluvium> but i can't load my source file. because it says that it can't find the module QuickCheck
09:01:38 <glguy> ertes: OK, so it needs someone to edit the constraints on hackage?
09:01:52 <Cale> ertes: I'm not sure what you mean by the "extra state" part...
09:02:21 <kadoban> alviprofluvium: 'stack ghci --package QuickCheck'
09:02:51 <kadoban> (you can add multiple --package options if you need more)
09:03:03 <ertes> Cale: the MonadWidget class adds extra state, as far as i understood…  it basically does what r-b's Network type does
09:03:38 <ertes> Cale: in order to have a text box that updates as a behaviour updates, you need the main loop to somehow build that connection
09:04:04 --- mode: ChanServ set +o monochrom
09:04:18 --- mode: monochrom set -b *!*@81.193.61.235
09:04:27 --- mode: monochrom set -o monochrom
09:04:37 <Cale> ertes: Well, there are a bunch of basic parts that MonadWidget (now) decomposes into
09:04:38 <ertes> glguy: i don't know, but i might be 1-2 weeks out of date with hackage
09:04:44 <Cale> One of those is PerformEvent
09:04:48 <Sonolin> in case anybody is curious, I think I found out how to get screen w in mm
09:04:57 <Sonolin> its widthMMOfScreen in Graphics.X11.Xlib.Screen
09:05:19 <Cale> I don't think that's a reader in any sense
09:05:37 <alviprofluvium> Thanks!!! That worked
09:06:17 <Forlorn> test
09:06:56 <hoppfull> Hey. I have a minor problem. It's not really important. I'm using windows and I always open cmd in folder so when I run GHCi it doesn't load .ghci in users/me/
09:08:01 <hoppfull> Is there a way to make GHCi open .ghci somewhere without having to put it inside all my project folders?
09:08:38 <ertes> Cale: well, i can say this much: reflex' controller semantics (ReflexHost and related classes) definitely can't do it by itself…  you can only fire events and then see which events fired in response in the same frame, like a Dynamic's change event
09:09:18 <Cale> ertes: But yeah, a lot of that interaction with the DOM is done via performEvent and wrapDomEvent, and I'm not sure what additional state is involved in either of those, I can't think of any. In wrapDomEvent, all it's doing is creating a new trigger event and setting the JS event handler to run some given action to obtain the value for your Event and then pass that to the trigger.
09:10:33 <ertes> Cale: yeah, that's outside of reflex semantics…  the reason i mentioned r-b in this context is that it has this part built-in
09:10:58 <Cale> hm
09:11:15 <ertes> see e.g. r-b's fromAddHandler function
09:11:26 <Cale> I wouldn't expect anything dealing with the external callback-based libraries to have particularly good semantics :)
09:11:40 <hoppfull> Wait, I solved it. If I have my users/me directory in environment variables then ghci will find .ghci
09:12:00 <ertes> Cale: i agree, but it does make r-b easier to use for toolkits like GTK and wx =)
09:12:10 <ertes> reflex is a lot closer to AFRP in this regard: it doesn't take control
09:12:22 <ertes> and that's why i generally prefer reflex over other FRP frameworks
09:12:33 <ertes> but it does add some burden on the controller
09:12:49 <eklavya> glguy: ok, it was mentioned in an article shared earlier here today
09:13:10 <Cale> Sure, perhaps I don't have enough experience using r-b at that level to really know what the convenience is that you're referring to
09:14:17 <ertes> Cale: you really only need to look at fromAddHandler to understand my point:  you create a GTK widget and register the callbacks you need with r-b, which in turn gives you an Event
09:15:06 <ertes> it's in Reactive.Banana.Frameworks, i believe
09:15:50 <ertes> Cale: "Moment" is basically r-b's "SpiderHost" counterpart
09:16:27 <ongy> Cale: can you say how much of your code has useful testcases?
09:17:17 <ertes> Cale: BTW, it's nothing you couldn't build on top of reflex in an extra library that you might call reflex-banana or something =)
09:17:36 <Cale> ertes: Yeah, I suppose that roughly corresponds to the part on the reflex-dom side of things which is wrapDomEvent/PerformEvent. I think the plan might be to move PerformEvent into Reflex proper.
09:17:53 <Cale> Since there's not a whole lot which is DOM-specific about what that stuff does
09:17:54 <ertes> Cale: i'd ask ryan not to do that
09:18:08 <Cale> I mean, into the library -- you can still choose not to use it
09:18:33 <Cale> But it's likely something which would be useful in implementing a lot of other hosts
09:18:35 <ertes> Cale: yeah, it's nothing you couldn't build on top of reflex, but it doesn't really belong into the core/host semantics
09:19:01 <Cale> (it definitely shouldn't be part of the Reflex type class)
09:19:25 <ertes> it shouldn't be part of any of the current host classes either =)
09:20:19 <Cale> But as a utility on top of that stuff, I think you'll often want it (or something reasonably close), for the same reason you'll want fromAddHandler
09:23:49 <Cale> ertes: I don't know if you've looked at the new reflex-dom refactor stuff, but it's almost completely separated out now, and MonadWidget has just become a constraint synonym
09:24:39 <ertes> Cale: but it still requires control, right?
09:24:42 <Cale> ertes: and I don't think the PerformEvent class really has anything JS or DOM specific in it, so I *think* you could literally just rip it out and put it in the other package.
09:26:00 <ertes> Cale: the main issue i have with r-b and PerformEvent is that it needs control, and with the current host semantics i see no way for it to work without taking control
09:26:11 <Cale> I'm a little uncertain, just because the module happens to import a JS-specific thing, but I think that's just for some instance lifting HasJS over PerformEventT
09:26:54 <hoppfull> Is it possible to install packages from hackage with ghc directly or do I have to use cabal or stack?
09:26:57 <Forlorn> I am trying to apply this fact in Haskell: nlnn+n(lnlnn−1)<pn<nlnn+nlnlnn for n≥6
09:27:00 <Forlorn> http://math.stackexchange.com/questions/1257/is-there-a-known-mathematical-equation-to-find-the-nth-prime
09:27:21 <Forlorn> to get the nth prime
09:27:22 <jonored> hoppfull: ghc doens't do that part, no.
09:27:23 <Forlorn> http://sprunge.us/haSG
09:27:28 <Cale> Forlorn: you really should try to press the spacebar a little more frequently there ;)
09:27:30 <hoppfull> jonored: thanks
09:27:48 <Forlorn> nthprime 10 = nthprime 11 = 31
09:27:57 <Forlorn> but that is not true
09:28:03 <prsteele> Forlorn: those are bounds
09:28:08 <Forlorn> Cale, Yeah, I am sorry
09:28:18 * hackagebot clckwrks 0.23.19 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.19 (JeremyShaw)
09:28:20 * hackagebot MemoTrie 0.6.6 - Trie-based memo functions  https://hackage.haskell.org/package/MemoTrie-0.6.6 (ConalElliott)
09:28:22 * hackagebot workflow-types 0.0.0 - Automate keyboard\/mouse\/clipboard\/application interaction.  https://hackage.haskell.org/package/workflow-types-0.0.0 (sboo)
09:28:24 * hackagebot workflow-windows 0.0.0 - Automate keyboard/mouse/clipboard/application interaction.  https://hackage.haskell.org/package/workflow-windows-0.0.0 (sboo)
09:28:29 <prsteele> Forlorn: sorry, I missed that you're applying 2 bounds
09:28:32 <Forlorn> prsteele, indeed they are.
09:29:25 <Forlorn> have I failed somewhere in my code?
09:29:32 <Forlorn> I can't spot the error
09:30:23 <Forlorn> I'd like to use this method since `primes !! huge_number` is really slow with the sieve method
09:31:22 <jonored> hoppfull: (It is of course possible to go slowly and manually without cabal-install, stack, nix, or some other package manager but it's not something I would recommend in the slightest.)
09:31:25 <Cale> Forlorn: Well, you're taking the floor of both bounds, which seems fishy
09:32:08 <Forlorn> Cale, taking the ceiling of the latter bound does not change that
09:32:15 <prsteele> the bounds are fine for the example he posted (n = 10), though, they give 21 and 31 (10th is 29)
09:32:20 <hoppfull> jonored: I've found a compromise. I'm using cabal to install a sandbox in my directory and then I've got batch files to organise compilation and stuff like that.
09:32:25 <Forlorn> Cale, that nthprime 10 = nthprime 11 = 31
09:32:39 <Cale> fair enough, yeah, it doesn't matter in this case
09:32:54 <Cale> So clearly the bounds are too weak?
09:33:25 <Forlorn> Cale, yeah, the latter bound is too weak, so this theorem does not appear to hold?
09:33:37 <Forlorn> s/latter/upper/
09:33:47 <Cale> Well, the prime number theorem holds
09:33:56 <prsteele> Forlorn: no, the bounds hold, you just need to count more carefully. it is the case that the 10th prime is between 21 and 31
09:34:02 <Cale> It's just not providing you enough information to pinpoint a single prime here
09:34:13 <Forlorn> ah
09:34:15 <Forlorn> sorry
09:35:10 <hoppfull> Isn't there a theorem by some guy with a name beginning with R that is about complex numbers and a conjecture that if this theorem is proven, then you'd find all the prime numbers or something.
09:35:26 <Forlorn> prsteele, thank you!
09:35:33 <dysfun> the Riemann Hypothesis?
09:35:34 <Cale> hoppfull: There's the Riemann hypothesis, but that's not at all what it says
09:35:36 <dysfun> not quite
09:35:38 <int-e> Forlorn: I think a good plan would be to take those bounds, sieve the range, simultaneously evaluating the prime counting function for the lower bound, and then return the prime. (there is some synergy there, https://en.wikipedia.org/wiki/Prime-counting_function may provide some ideas).
09:35:39 <hoppfull> dysfun: yeah
09:35:47 <hoppfull> Cale: okay
09:36:34 <dysfun> the riemann hypothesis is essentially the suggestion that the primes are perfectly randomly laid out
09:36:34 <prsteele> Forlorn: you have a reference on the 2^x - 2 `rem` x bit?
09:37:19 <Forlorn> prsteele, that's derived from fermat's little theorem
09:37:34 <prsteele> Forlorn: thanks
09:37:35 <Forlorn> although it could give me pseudo-primes
09:37:46 <dysfun> at this point, we basically assume Riemann was correct, so a proof that he was wrong would be far more interesting
09:38:35 <Forlorn> prsteele, also look at the relationship between the binomials and pascal's triangle
09:39:15 <Forlorn> prsteele, look at the first proof, https://www.artofproblemsolving.com/wiki/index.php?title=Fermat%27s_Little_Theorem
09:39:25 <int-e> Forlorn: and of course your primality test doesn't really work. 341 divides 2^341 - 2, for example.
09:39:33 <Forlorn> yes exactly
09:39:38 <Forlorn> pseudo primes
09:39:54 <Forlorn> int-e, sieving is ideal
09:40:20 <Forlorn> have to figure out how to do it from an arbitrary position
09:40:27 <Cale> So, you need a better approximate inversion of the prime counting function...
09:41:11 <prsteele> if you're trying to be pragmatic, I'd probably compute (or hard-code) some benchmarks, e.g. the 10th, 100th, 1000th, etc, primes and start from the nearest benchmark
09:42:26 <Forlorn> prsteele, that's a good suggestion!
09:42:36 <Forlorn> ty
09:43:28 <Cale> There's a fancy algorithm described in this paper https://cr.yp.to/bib/1996/deleglise.pdf
09:43:31 <Cale> for computing pi(x)
09:43:37 <Cale> (the number of primes less than x)
09:43:57 <Cale> Apparently it's the one which Mathematica uses
09:44:52 <Cale> and if you can compute pi(x) effectively, then you're in a good position to search for the nth prime
09:57:08 <dmiles> meant to ask.. are there text muds in haskell?
09:57:20 <dmiles> that people here are developing
09:58:26 <sm> dmiles: no! which is very bad
09:59:28 <verement> dmiles: http://hackage.haskell.org/package/EtaMOO
10:00:06 <sm> sweet, I stand corrected
10:01:11 <dmiles> awesome
10:01:42 <sm> needs a live demo
10:28:20 * hackagebot Win32-console 0.1.0.0 - Binding to the Win32 console API  https://hackage.haskell.org/package/Win32-console-0.1.0.0 (siracusa)
10:28:22 * hackagebot rospkg 0.2.3.0 - ROS package system information  https://hackage.haskell.org/package/rospkg-0.2.3.0 (akru)
10:28:24 * hackagebot dockercook 0.5.0.3 - A build tool for multiple docker image layers  https://hackage.haskell.org/package/dockercook-0.5.0.3 (AlexanderThiemann)
10:36:24 <Wizek_> Hey, anyone knows why TH quotations such as [| 33 |] return `Q Exp` instead of `Exp`?
10:37:19 <Wizek_> And is there a way to quote an expression and get an Exp instead of having to write AST, such as `LitE (IntegerL 33)`?
10:38:23 <johnw> runQ [| 33 |]
10:38:47 <johnw> hmm... n/m
10:39:55 <Fairy> testFunction :: (Int a, Double b) => a -> b -> (a, b)
10:39:56 <Fairy> testFunction x y = (x, y)
10:40:18 <mauke> Int/Double are types, not classes
10:40:21 <Fairy> Why does that not work? As opposed to  testFunction :: Int -> Double -> (Int, Double)
10:41:24 <prsteele> Fairy: you could do something like testFunction :: (Integral a, Floating b) => a -> b -> (a, b)
10:41:32 <amiller> it seems like it isn't possible to have (MonadReader Int m, MonadReader String m) => m ()..... is there any way around this? 
10:41:59 <amalloy> Fairy: the syntax (Foo a) => ... is a constraint, not declaring them to be equal
10:42:00 <amiller> this article seems to be about that problem but it doesn't leave with a solution https://ro-che.info/articles/2014-06-11-problem-with-mtl
10:42:10 <amalloy> Int is a type, not a constraint
10:43:51 <Fairy> ahh, that makes sense, thanks ;)
10:44:52 <pavonia> amiller: MonadReader (Either Int String) m => m ()?
10:45:10 <pavonia> Or (Int, String)
10:46:44 <amiller> well say i have bar :: MonadReader Int m => m Int, and baz :: MonadReader String m....    and I'd like to do something like foo = do { x <- bar; y <- baz; return ((show x) ++ y) }
10:51:21 <pavonia> amiller: What is the error you get for this?
10:52:32 <amiller>     Couldn't match type Int with [Char]
10:52:32 <amiller>     arising from a functional dependency between constraints:
10:52:49 <amalloy> presumably the error is that bar and baz are in different monads, so you can't combine them in a do block
10:55:39 <hpc> amiller: when you use do-notation that way, it desugars to using (>>=), which has this type
10:55:42 <hpc> :t (>>=)
10:55:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:56:21 <amiller> here's a codepad btw illustrating it http://codepad.org/FXvJHRqu
10:56:28 <hpc> amiller: both of those 'm's are the same, so when you combine bar and baz, the class constraint on the result is (MonadReader Int m, MonadReader String m)
10:56:49 <hpc> amiller: and there's a functional dependency on MonadReader which forbids both of those constraints from being matched at the same time
10:57:18 <hpc> class Monad m => MonadReader r m | m -> r where
10:57:19 <amiller> i see, i didn't realize monadreader came with a functional dependncy
10:57:49 <amiller> well that sucks, can i just generalize MonadReader not to have the functional dependency
10:58:07 <hpc> i wouldn't recommend it
10:59:00 <amalloy> how can the same monad be a reader for both Int and String? wouldn't it be simpler to have a reader of (Int, String) or similar?
10:59:14 <hpc> fundeps (and the mtl ones in particular) make type inference much more pleasant
11:01:19 <amiller> well in my example i had bar and baz as separate monad actions, suppose those were already given to me
11:01:34 <saurabhnanda> is it possible to pass a Symbol (type-level string) as a regular string-value to a function?
11:01:34 <amiller> each of them has a reasonable constraint on its own
11:02:45 <hpc> amiller: you'll need something at the value level (ie, write something specific to your use case) that says how to combine them reasonably
11:23:48 <lyxia> saurabhnanda: symbolVal
11:24:13 <saurabhnanda> lyxia: thanks
11:26:45 <SrPx> Is there any fast implementation of modPow in Haskell?
11:28:21 * hackagebot http-client-tls 0.3.1 - http-client backend using the connection package and tls library  https://hackage.haskell.org/package/http-client-tls-0.3.1 (MichaelSnoyman)
11:32:19 <hpc> SrPx: as in similar to quotRem and divMod?
11:33:23 <SrPx> hpc yes... 
11:33:40 <hpc> or do you mean https://en.wikipedia.org/wiki/Modular_exponentiation
11:33:57 <SrPx> for crypto stuff, `(10 ^ 10) `mod` 31` takes age, while on most bignum implementations there is a modPow that does the same instantly
11:34:10 <SrPx> hpc yes, modular exponentiation 
11:34:32 <hpc> ah cool, i don't even know what it would be for the former
11:34:37 <hpc> > 5 `quotRem` 3
11:34:40 <lambdabot>  (1,2)
11:35:35 <hpc> ghc uses libgmp which seems to have a mpz_powm() function
11:36:00 <SrPx> but how can I access that primitive?
11:36:01 <hpc> so you could give that a foreign import and some wrappings to make it behave right on Integer
11:36:47 <hpc> oh wait, disregard that
11:36:59 <hpc> https://hackage.haskell.org/package/integer-gmp-1.0.0.1/docs/GHC-Integer-GMP-Internals.html#v:powModInteger
11:38:28 <SrPx> :) 
11:39:27 <SrPx> blazingly fast, great find! thank you hpc
11:39:33 <hpc> i don't know why, but seeing that integer-gmp is BSD3 and that the maintainer is @gnu.org makes me happy
11:39:57 <SrPx> interestingly, it doesn't show up on Hoogle...
11:40:06 <hpc> hoogle doesn't get everything
11:40:21 <SrPx> hm.. honestly, elaborate on why it makes you happy?
11:40:39 <hpc> no idea
11:41:23 <SrPx> but...
11:41:23 <SrPx> well ok
11:43:26 <SrPx> Noow... just wondering, what is the fastest `isPrime :: Integer -> Bool` implementation available on hackage?
11:43:47 <SrPx> Ideally, something cached... perhaps that built an infinite binary tree lazily....
11:43:52 <ski> hpc : nice :)
11:44:02 <SrPx> ski really nice :) it is so fast
11:44:16 * ski doesn't see a discrete logarithm operation, mod `m', though
11:44:19 <MarcelineVQ> idk about fastes, primes packages uses wheel sieves and is pretty fast though
11:44:25 <SrPx> ski hahahah
11:44:25 <MarcelineVQ> *package
11:45:47 * SrPx reminds how much he missed haskell
11:45:53 <SrPx> things are so easy here...
11:46:07 <hpc> ski: i think that "inverse" one mentioned in the see-also might be it?
11:47:19 <ongy> I do remember correctly, that that one shouldn't be fast, right? I'm not mixing things up
11:48:47 <Welkin> OverloadedStrings seems to not work with this reflex-dom example
11:49:45 <Welkin> http://lpaste.net/4073485247113592832
11:50:37 <ReinH> Welkin: look again
11:50:50 <Welkin> look at what?
11:50:56 <luigy_> http://lpaste.net/4073485247113592832#line9   
11:51:13 <ReinH> The error. It is not about your overloaded string.
11:51:23 <Welkin> I just copied the example from here https://github.com/reflex-frp/reflex-platform
11:51:24 <kadoban> :t show
11:51:25 <lambdabot> Show a => a -> String
11:51:35 <Welkin> yeah, I know that
11:51:39 <Welkin> but how would it ever work then
11:52:04 <Welkin> unless there used to be a custom `show` used in Reflex for Text
11:52:08 <ReinH> I don't know. I am just reading the error.
11:52:20 <merijn> Welkin: Maybe the API changed and they forgot to update the README?
11:52:24 <kadoban> Probably the types changed. Pretty sure lots of reflex stuff changed from String to Text recently, though I don't know what version you're using.
11:52:25 <ReinH> Maybe their example is wrong.
11:53:50 <Welkin> okay
11:53:59 <Welkin> I changed it to fmap (pack . show)
11:54:42 <merijn> Welkin: Wait, you're showing the Text and then turning it back into Text?
11:54:55 <Welkin> it's an Int
11:55:14 <merijn> ah, that's even odder
11:55:28 <Welkin> it's just the example they give
11:55:43 <MarcelineVQ> it's it text? it's from a textbox
11:55:58 <Welkin> no, it is the keypress event
11:56:04 <Welkin> the keycode
11:56:07 <MarcelineVQ> I see
11:56:22 <glguy> In the initial import  dynText :: MonadWidget t m => Dynamic t String -> m ()
11:56:31 <glguy> but then later it was converted to Text
11:56:46 <glguy> In a commit called "refactor everything"
11:56:51 <Welkin> lol
11:57:41 <MarcelineVQ> Be sure to mention the inconsistency in #reflex-frp if you're sure it's broken, ryantrinkle and the reflex guys are reasonably active there
12:13:20 <ski> hpc : nope, that's reciprocal, not logarithm
12:13:46 <hpc> ah
12:18:47 <ski> hpc : e.g. `map (\n -> logBaseModInteger 3 n 7) [1 .. 6]' should be `[0,2,1,4,5,3]' (result is modulo `phi 7')
12:20:28 <ski> (another term for it is "index" (due to Gauß, i think))
12:24:02 <jonored> ski: ...Are you looking for a general discrete logarithm implementation?
12:25:04 <jonored> (or one specialized to integers mod n, at least?)
12:31:40 <Forlorn> "I use a bit array where if bit (n) is set then (n*2 + 3) is prime."
12:31:51 <Forlorn> ^ someone stated this
12:32:42 <Forlorn> 2^5 * 2 + 3 = 35
12:32:56 <Forlorn> 2^4
12:32:57 <Forlorn> sorry
12:33:19 <Forlorn> 2^4 * 2 + 3 = 35 which is not prime
12:34:08 <kadoban> Forlorn: That's not a formula for determining what's prime or not, it's a way of storing a mapping of Number -> Bool in a space efficient manner.
12:34:40 <ongy> also it would miss 2
12:34:57 <kadoban> Presumably that's special cased or something, though I'm not sure why you'd do that.
12:35:06 <Forlorn> ah I see
12:35:27 <merijn> kadoban: Or you don't care about small primes
12:35:31 <Forlorn> so you store compressed information in a bit array of what is prime
12:35:39 <merijn> kadoban: If you're doing crypto you only care about large primes anyway :)
12:35:42 <kadoban> Also possible, yeah. That'd make more sense.
12:36:08 <kadoban> But then most of the time you're doing crypto, any kind of list of all primes is going to be insane too.
12:36:30 <kadoban> Maybe as like a first-pass cut out the small primes type thing, where you check %2 first and then your small-ish list.
12:41:44 <kamog> well, it looks like haskell is too advanced for me.
12:43:57 <mmaruseacph2> it won't look the same after some working&learning it
12:44:26 <kadoban> kamog: Very unlikely. What kind of learning materials have you tried?
12:45:10 <Forlorn> but then how would he store 23?
12:45:43 <Forlorn> this statement seems fishy
12:47:28 <kadoban> Forlorn: The 10th bit stores the status of 23
12:48:07 <et09> can someone give me a 1 sentence description of STM 
12:48:08 <Forlorn> kadoban, ah, now I see
12:48:32 <mauke> et09: it's like mutable variables but in a transaction
12:48:42 <mizu_no_oto_work> et09: 'database-like transactions for mutable variables'?
12:49:06 <kamog> kadoban: I don't have any which could provide any intuition into the type system. Like I fail to understand the meaning of (.)(.), yet deriving its defining equation and the type signature are just labourous exercises, but are pretty doable.
12:49:47 <et09> ah
12:50:22 <jonored> kamog: Point-free stuff is not really required for learning and using haskell...
12:50:32 <mizu_no_oto_work> et09: STM means 'Software Transactional Memory', fwiw
12:50:49 <et09> that would explain it
12:51:09 <kadoban> kamog: Well, a lot of intuition comes with time, I'm not sure it's something that can be provided to you.
12:52:32 <prsteele> kamog: writing it out with named parameters might help, e.g. try defining `compose'` with the same type signature as (.) (.)
12:53:54 <mauke> you can deal with it syntactically, sort of
12:54:02 <kamog> kadoban: yes, of course, but for example, if you want to get intuitive understanding of calculus, you get a textbook and solve many problems. No such books on that aspect of combinorial logic/or whatever it is called.
12:54:38 <mauke> 2(.) 3(.) = (3(.) 2.)
12:54:47 <kamog> prsteele: yeah, I did, and I still don't understand the meaning.
12:54:59 <mauke> ((.) .) is like a suspension
12:55:09 <mauke> it's waiting for an argument
12:55:18 <mauke> ((.) .) f = ((.) . f)
12:55:38 <aarvar> It might be easier to think of it as a specific case of fmap fmap
12:55:39 <mauke> ((.) . f) is waiting for another argument (because that's what . does)
12:55:42 <kadoban> kamog: Tried http://haskellbook.com/ ? It has many exercises. Beyond that, you have to just get experience while using the language. And knowing intuitively what (.) (.) means is not necessary, nobody writes code like that in general.
12:55:57 <mauke> ((.) . f) x = (.) (f x)  -- definition of .
12:56:08 <mauke> which in turn is (f x .), another suspension
12:56:15 <mauke> (f x .) g = (f x . g)
12:56:24 <mauke> (f x . g) y = f x (g y)
12:56:30 <lyxia> :t (.) (.)
12:56:32 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
12:56:43 <aarvar> :t fmap fmap
12:56:45 <lyxia> @djinn (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
12:56:47 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
12:56:49 <lambdabot> f a b c d = a b (c d)
12:57:06 <ertes> kamog: one thing to learn from mauke's reductions is that to understand some things, you have to actually apply them, if only to placeholder variables
12:57:17 <tsahyt> so I managed to cut memory consumption roughly in half by switching to vectors for the unfolding and maximum operations, but this still takes *way* more memory than it should.
12:57:19 <tsahyt> http://lpaste.net/1472536594064867328
12:57:24 <tsahyt> any ideas where to look next?
12:57:30 <ertes> what is "f . g"?  good question, until you apply it to a placeholder argument:  (f . g) x = f (g x)  -- definition of (.)
12:59:32 <kamog> ertes: yeah, I've done the reduction too
13:00:35 <ertes> kamog: is there anything particular you found or still find difficult?
13:02:13 <kamog> ertes: the most "intuitive" that I've got is pseudo-code for type signatures. And there is nice transition from (.) to (.)(.). I don't understand why.
13:02:43 <ertes> kamog: me neither…  that seems pretty random without context
13:03:08 <ertes> kamog: i advise you not to look at pseudo-code when learning haskell…  look at real code
13:06:41 <kamog> ertes: pseudo-code helps me understand the mathematical idea. Like (.) maps a function to a space where objects are functions from the same origin, but (.)(.) does the same but over an additional parameter.
13:07:07 <ertes> tsahyt: try to avoid lists that live in memory
13:07:21 <tsahyt> where else would they live?
13:07:53 <ertes> tsahyt: ideally only in your semantics, lazily, with only a small part of them in memory
13:08:29 <ertes> kamog: would you find the concept of "function composition" harder to understand?
13:08:32 <tsahyt> well that's pretty much what I'm trying to do
13:09:36 <ertes> tsahyt: example: longer !x !y = if length x > length y then x else y
13:10:02 <ertes> this is pretty much guaranteed to have terrible memory behaviour on GHC due to sharing
13:10:51 <tsahyt> ertes: how should I write this instead then?
13:10:56 <prsteele> (without having looked at the code) shouldn't it be possible to specialize length for your type?
13:10:57 <ertes> tsahyt: unfortunately this requires a trick to avoid
13:11:24 <prsteele> e.g. newtype TrackingList a = TrackingList Int [a]
13:11:25 <ertes> tsahyt: but before we do that, are x and y both in memory anyway?
13:11:50 <tsahyt> ertes: yes they should be
13:12:03 <tsahyt> the whole zipper is traversed, so they should appear sooner or later
13:12:14 <ertes> ok, then it doesn't really matter, but note that 'length' actually needs to left-fold the lists
13:12:15 <kamog> ertes: yes, in the context of haskell, the composition is difficult for me to understand, because it lives in the same "space" as objects.
13:12:33 <ertes> kamog: what are "objects" in your interpretation?
13:12:57 <ertes> tsahyt: to really reduce the memory usage of this, avoid lists altogether
13:13:23 <tsahyt> I'm not sure how I should avoid lists while using a zipper, because that was kinda the point of the whole thing
13:13:56 <kamog> ertes: hmm, well, I don't even know how to apply it haskell. Members of types?
13:14:05 <ertes> kamog: values?
13:14:10 <kamog> Yes.
13:14:28 <tsahyt> ertes: FWIW, the relevant parts of the zipper during each iteration should be relatively short
13:14:31 <ertes> kamog: functions are values in haskell, or do you mean something else?
13:15:02 <tsahyt> i.e. x and y may be relatively short too
13:17:30 <ertes> tsahyt: is this code just trying to find the longest palindrome in a string?
13:17:47 <tsahyt> ertes: yeah it's just a toy. I wanted to see how a zipper based solution performs
13:17:56 <ertes> like:  longestPalindrome "abxyzyxcd" = "xyzyx"
13:18:12 <tsahyt> almost, it only returns one half of the palindrome
13:18:22 <tsahyt> I know it's not the optimal algorithm
13:18:22 <ertes> zippers generally perform quite well in a lazy setting that really benefits from keeping things local *most of the time*
13:18:34 <ertes> in pretty much every other case i'd rather avoid them
13:18:41 <ertes> ah
13:19:11 <tsahyt> that was roughly the idea behind it, I want to look at the surroundings of some list element
13:19:41 <tsahyt> the way zippers are built I can just literally zip it up until I get two non-matching characters
13:20:09 <tsahyt> {e,s}zip are just separate because I need to take even and odd palindromes into account
13:21:08 <ertes> tsahyt: i'd suggest just using the most straightforward way, and do that with vectors instead of lists
13:21:28 <ertes> that gives you a surprisingly efficient naive algorithm that takes very little memory
13:21:34 <tsahyt> ertes: I've got a different implementation of the same thing using vectors. but no zippers unfortunately.
13:21:46 <tsahyt> I like the elegance of this zipping thing
13:21:57 <t0by> fsestini, o/
13:22:01 <ertes> tsahyt: first write isPalindrome
13:22:55 <ertes> @let isPalindrome xs = xs == reverse xs  -- you can make this twice as fast by abort after half the list/vector
13:22:57 <lambdabot>  Defined.
13:24:12 <tsahyt> ertes: is that reverse on lists? I thought they were to be avoided?
13:24:24 <kamog> ertes: yes, it feels like I have conceptual problems with mapping functions with functional arguments.
13:24:25 <amalloy> not quite twice as fast, because you're performing the whole reverse either way. you only make the (==) call twice as fast
13:24:30 <ertes> tsahyt: yes, you should use vectors for this one
13:24:43 <ertes> and not use 'reverse', but actually iterate from the back
13:24:56 <tsahyt> ertes: my first naive implementation was the following
13:25:00 <tsahyt> maximumBy (comparing length) . filter (\x -> reverse x == x) . (init . tails >=> tail . inits)
13:25:08 <tsahyt> this should be usable with vectors straight away
13:25:11 <ertes> > filter isPalindrome (tails "abxyzyxcd" >>= inits)
13:25:13 <lambdabot>  ["","a","","b","","x","xyzyx","","y","yzy","","z","","y","","x","","c","","d...
13:25:17 <ertes> hehe
13:25:35 <ertes> yeah, that's really not a bad naive implementation, if you do it with vectors
13:26:10 <ertes> kamog: can you point to specific examples you have trouble with?  then we can work on them
13:26:10 <tsahyt> I wonder if the (init . tails >=> tail . inits) construct is a good idea though
13:26:23 <ertes> tsahyt: i've used it more than once
13:26:39 <ertes> except without the 'init' and 'tail'
13:27:18 <tsahyt> ertes: it just got rid of some empty lists
13:27:51 <ertes> yeah, though in this case you probably shouldn't
13:27:54 <tsahyt> looks like vector doesn't have tails/inits
13:29:40 <ertes> tsahyt: they're pretty straightforward to write using iterate/unfoldr
13:30:10 <ertes> vtails :: (Vector v a) => v a -> [v a]
13:33:35 <int-e> tsahyt: it's better to put the inits first, complexity wise.
13:34:00 <et09>     config <- Config.load [ Config.Required config_filename ]
13:34:04 <et09> what is going on in this syntax ?
13:35:15 <tsahyt> okay so I've implemented the naive vector version
13:35:16 <et09> is that a list?
13:35:21 <tsahyt> it's hilariously slow compared to the zipper though
13:35:32 <et09> nevermind hah
13:36:42 <tsahyt> interestingly it also uses more memory
13:37:23 <tsahyt> mind you I'm working on rather large inputs here, roughly 10 million characters
13:37:37 <tsahyt> but on anything "normal" sized the zipper version performs well enough
13:38:12 <ertes> tsahyt: that's surprising…  did you use compact vectors like unboxed or storable vectors?
13:38:34 <tsahyt> I wanted to use unboxed at first, but apparently I can't have nested unboxed vectors (which I needed for tails/inits)
13:38:52 <ertes> tsahyt: oh!
13:38:55 <ertes> no, use lists
13:38:58 <atoll> Hello, I'm trying to learn about Continuation. I tried to hand write chainCPS but I don't understand what I'm doing wrong `:t let chainCPS s f = f (s (\x -> x))  in chainCPS :: ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)`
13:39:16 <ertes> tsahyt: as i wrote:  vtails :: (Vector v a) => v a -> [v a]
13:39:18 <ertes> similar for inits
13:39:22 <tsahyt> ah, I missed that
13:39:31 <ertes> (Vector is from D.V.Generic)
13:40:48 <ertes> tsahyt: you're using a single vector for the original string and the fact that vector slicing is O(1) in both time and space…  for the actual search control you use lists
13:41:03 <ertes> that should result in an O(1) memory algorithm
13:41:17 <ertes> well, O(n), where n is the length of the original string
13:44:54 <tsahyt> ertes: this version now seems to use constant memory (ignoring the input list), but it's very slow compared to the zipper version
13:45:01 <tsahyt> to be fair it's not exactly the same algorithm
13:47:05 <ertes> tsahyt: you can implement the better algorithm now, but instead of a zipper use a vector together with an index
13:47:30 <tsahyt> :/ but that's what I wanted to avoid in the first place
13:47:38 <ertes> tsahyt: you can make it opaque and its interface zipper-like
13:47:52 <tsahyt> it's disappointing that FP can express things so nicely but falls flat on its face in terms of performance sometimes
13:48:51 <ertes> zippers are best for local modifications on lazy things…  to be honest i've never found a practical use for them that wasn't better handled by e.g. lenses
13:50:22 <ertes> in other words:  zippers solve a particular problem in a very beautiful way…  however, it's a problem you better avoid having in the first place =)
13:51:05 <nshepperd_> Nested unboxed vectors shouldn't normally be necessary, i think. You get most of the benefit from boxed vectors of unboxed vectors
13:52:35 <kamog> ertes: only (.)(.) yet (which I'm still trying to fix).
13:53:41 <ertes> kamog: that doesn't seem like a very useful construct anyway, and you can really construct much much more complicated useless constructs, if you want…  try not to focus on it too much
13:54:40 <tsahyt> maybe I'll reimplement the zipper algorithm using vectors tomorrow. might as well just use suffix trees though. trees should mesh well with FP and it's the asymptotically faster algorithm anyhow
13:54:52 <ertes> kamog: you understand how it reduces, and there really isn't much more to it…  the reason you have trouble understanding may be that there really just isn't anything to understand
13:56:56 <ertes> kamog: here is a function:  f x y = sin x + x**3 - 30 + exp (sqrt x)
13:58:08 <ertes> you could now try to understand the essence of it, what it means, and how it fits into the bigger picture, but let me tell you: it's just a random function i came up with =)
13:59:05 <ertes> (and please no remarks on constant functions, initial objects or reader monads)
13:59:23 <ertes> s/initial/terminal/
13:59:58 <tsahyt> ertes: when reading a large file into one of those vector based solutions, how would I go about it?
14:00:08 <tsahyt> V.fromList <$> readFile foo?
14:00:27 <tsahyt> large meaning anything up to a gigabyte here
14:00:58 <ertes> tsahyt: read into a ByteString or Text (beware: UTF-16)
14:01:16 <ertes> tsahyt: both of them have the O(1) slicing property
14:01:31 <tsahyt> ok
14:02:08 <jmcarthur> tsahyt: What exactly is the program you are writing?
14:02:18 <jmcarthur> tsahyt: I mean what is it supposed to do?
14:02:29 <tsahyt> jmcarthur: just playing around with finding largest palindrome substrings in large amounts of data
14:02:34 <tsahyt> nothing useful really
14:02:39 <jmcarthur> Ah
14:02:44 <jmcarthur> That sounds like a good exercise.
14:03:03 <tsahyt> basically I just want to show that haskell can be fast. I've failed so far. which is weird considering that I've done nothing but writing performance critical haskell code this summer...
14:03:12 <kamog> ertes: there is an instance Functor (-> a) in the prelude which defines fmap = (.). That's very insightful and clear, because it's an actual functor from * to the cosplice of * under a. That's so good, but I don't understand why I fail to use it for (.)(.).
14:03:17 <ertes> basically avoid String like the plague for…  well…  everything =)
14:03:37 <yyyyy> tsahyt: isn't it better to move to pipes or conduit for that?
14:03:53 <ertes> kamog: there are a few perspectives on (.) (.)
14:03:58 <tsahyt> yyyyy: maybe, but it's not important enough to learn how to use these things now
14:04:05 <kgadek> tsahyt: just got into this discussion. Curious, what does "not fast" mean? 2x slower? 10x? 30x? 100x?
14:04:14 <tsahyt> the code I usually write is CPU bound, so I don't have much experience with those streaming solutions
14:04:31 <tsahyt> kgadek: I'd like to stay within 2x of the C implementation.
14:04:34 <jmcarthur> Is there an algorithm you're using other than the obvious n^3 one I'm thinking of?
14:04:37 <ertes> kamog: fmap (.)  -- for any Functor it partially applies function composition
14:04:47 <kgadek> tsahyt: and what did you achieve?
14:04:56 <tsahyt> jmcarthur: there's a pretty obvious n^2 one that the C implementation used
14:05:26 <tsahyt> kgadek: in terms of time spent in the mutator, just that. but due to doing a lot of allocations, the GC time outshadowed that and put me more into about 10x territory
14:06:29 <kgadek> tsahyt: ok, so 10x. Usually, the question "why" is irrelevant, the clients do not care :<
14:06:35 <kgadek> so… yeah, you're making me sad
14:06:50 <kgadek> because this is basically what I expect of Haskell nowadays
14:07:20 <jmcarthur> tsahyt: What is the n^2 algorithm? It's not obvious to me.
14:07:25 <yyyyy> tsahyt: do you have to check every possible substring of the entire corpus, or can you choose a “limit” window of lengths
14:07:45 <ertes> kamog: (fmap .)  -- compose with a function that maps the morphism first…  this may be best understood in the context of hom-functors:  ((->) e) is a covariant almost-hom-functor from Hask to Hask (if you accept Hask as an approximation of Set)
14:07:54 <ertes> kamog: that's why fmap = (.)
14:08:04 <yyyyy> (or does it only considers separate words and not sentences?)
14:08:28 <ertes> kamog: and then there is the most general (fmap fmap), which is best understood by just looking at its type
14:08:30 <ertes> :t fmap fmap
14:08:31 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
14:09:09 <jmcarthur> kgadek: I generally expect Haskell to perform similarly to C on algorithms like this, honestly, but sometimes people don't realize they are not actually implementing the same algorithm as the C version.
14:09:25 <jmcarthur> Not that I necessarily think that's the case here.
14:10:05 <kgadek> jmcarthur: I think that one can nearly always get to 1-2x "C" (whatever that means), but in process you actually write C in Haskell
14:10:09 <jmcarthur> tsahyt: Nevermind, I think I just realized what the n^2 algorithm is.
14:10:10 <kgadek> using obscure things
14:10:30 <kgadek> unless you find something clever that GHC understands well enough
14:11:02 <tsahyt> yyyyy: in the worst case the whole string might be a palindrome
14:11:03 <kgadek> had the same thing with SBCL (common lisp compiler) — got into "C/C++ zone" only when rewrote the stuff to look like C
14:11:14 <jmcarthur> kgadek: Nah, there are plenty of ways to get GHC to optimize e.g. vector code well.
14:11:21 <tsahyt> which is where the n^2 algorithm performs the worst. it's decent in the average case though
14:11:29 <jmcarthur> I'm going to give this problem a shot (but I don't have a C program to compare to, so I don't know what my target really is.)
14:11:36 <ertes> tsahyt: you said that the zipper variant is much faster, which i actually find quite surprising
14:11:44 <ertes> tsahyt: are you still using 'reverse'?
14:11:55 <shachaf> jmcarthur: What's the problem?
14:12:07 <tsahyt> ertes: from vector yes. but as I said, the vector version is the n^3 algorithm, so that's not surprising
14:12:18 <tsahyt> I haven't gotten to do the n^2 one with vector yet
14:12:18 <kgadek> jmcarthur: don't know the general case. I suspect that in Haskell world it's the blend of nice tricks (like CPS in attoparsec afair) and ugly code
14:12:23 <ertes> tsahyt: it's an O(n^2) algorithm, if implemented properly
14:12:29 <jmcarthur> shachaf: Read in a big string and find the longest substring which is a palindrome.
14:12:33 <tsahyt> ertes: I'll look into it tomorrow
14:12:37 <kgadek> where ugly = mutate everything in IO / ST
14:12:44 <tsahyt> anyways, thanks for all the help! I'll go catch some sleep.
14:12:44 <jmcarthur> kgadek: Nah. I don't think ugly code is really necessary most of the time.
14:13:42 <ertes> kgadek: even in cases when you have to use mutation it's not that bad…  you still have a functional language with first-class actions
14:14:30 <kgadek> ertes: why yes, that's why I'm here ;D you wrap it into some nice interface, write few rewrite rules and you're rather happy (vectors do that to my knowledge)
14:14:42 <kgadek> but sometimes getting into this "C zone" is very tricky
14:15:07 <jmcarthur> kgadek: Do you have an example?
14:15:46 <kgadek> jmcarthur: no, unfortunately. Did not write in Haskell for half a year :<
14:15:55 <kgadek> which makes me sad
14:15:58 <kamog> ertes: that fmaps inside a functor type constructor applied to the type of functions, but it's given there as a type of objects. By partial application of function composition you mean that it does a composition with partially applied ternary functions?
14:16:17 <joe9> http://bpaste.net/show/27caef3ba5c7 I cannot figure out how to do this in haskell. These are the relevant function definitions.  this is the relevant C code.
14:16:34 <joe9> I can get a BufferObject by doing makeBuffer ..
14:16:48 <joe9> but, I cannot figure out how to set that using bindBuffer
14:18:23 <ertes> kamog: you were using categorical terminology in the context of (.) (.), so i assumed you were trying to understand it categorically
14:18:36 <ertes> kamog: to be honest i didn't understand your question
14:18:42 <ertes> (your latest one)
14:20:20 <kaction> Hello! Is there high-order function typeclass with 'fmap1 :: (forall a. f a -> g a) -> h f -> h g'?
14:20:22 <joe9> I think the key is the type of StateVare
14:20:32 <joe9> s/StateVare/StateVar/
14:23:08 <ski> atoll : follow the types
14:23:13 <shachaf> kaction: Not (forall a. f a -> g a) -> (forall a. h f a -> h g a)?
14:23:38 <atoll> ski: I am trying but my brain is melting
14:23:45 * ski supposes `h :: (* -> *) -> *'
14:23:59 <ski>   chainCPS :: ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
14:24:00 <kamog> ertes: sorry, I missed for "any functor part". It was about (.)(.).
14:24:15 <ski>   chainCPS s f = ?0
14:24:25 <ski>   s :: (a -> r) -> r
14:24:34 <ski>   f :: a -> ((b -> r) -> r)
14:24:39 <shachaf> ski: That's certainly a legitimate functor, but I think it's less common than h :: (* -> *) -> * -> *
14:24:41 <ski>   ?0 :: (b -> r) -> r
14:25:01 <shachaf> I guess Fix is one instance.
14:25:12 <ski> atoll : now, if we had an `a', we could pass it to `f', and get something matching the type of the hole, `?0', agree ?
14:26:29 <kaction> ski: yes, 'class Function2 (h :: (* -> *) -> *) where fmap1 :: (forall a. f a -> g a) -> h f -> h g
14:26:47 <ski> shachaf : or some concrete tree type with parameterized on indirections
14:27:02 <kaction> Functor2*, but is something standard?
14:27:07 <shachaf> ski: Yes. I guess that's actually pretty common.
14:27:08 <ski> s/with //
14:27:29 <ertes> kaction: definitely not standard, probably nothing common either
14:27:36 <ski> (or the input could be a shape functor for the nodes)
14:27:45 * ski eyes atoll
14:27:45 <shachaf> kaction: I don't think I've ever seen that particular class. But certainly it would be an instance of some more general functor class.
14:28:01 <shachaf> (It's a functor : (~>) -> (->), or something like that.)
14:28:48 <atoll> ski: that is what I am trying to do
14:29:13 <atoll> in my head s (\x -> x) should return a
14:29:15 <ski> atoll : agree or not ?
14:29:19 <atoll> yes
14:29:54 <ski> atoll : now, since `s :: (a -> r) -> r', if we could set `r' to `a', then we could pass `id :: a -> a' to `s', getting an `a' ..
14:30:07 <kaction> shachaf: that's what I am searching for. I can't imagine it wasn't already implemented by ekmett in some terribly generic way
14:30:18 <ski> atoll : but .. we have no say in which types `a',`b',`r' are. they could all be different. the caller of `chainCPS' decides that
14:30:25 <ski> atoll : so that plan doesn't work, agree ?
14:31:15 <atoll> yes that's true
14:31:17 <shachaf> kaction: Oh, if you want something general, sure, you can find it in any category theory library.
14:31:27 <atoll> I see why I am horribly wrong
14:31:32 <shachaf> kaction: E.g. maybe https://github.com/ekmett/hask/blob/master/wip/Univariant.hs
14:31:35 <atoll> thanks!
14:31:37 <ski> (atoll : i just realized your `\x -> x' was the same as my `id'. so i just explained why `s (\x -> x)' doesn't work, i hope you see that)
14:32:02 <ski> atoll : .. do you want me to continue with the proof search, or you want to try some more on your own ?
14:32:44 <ski> atoll : .. perhaps i should better explain *why* we have no say in picking `r' (to be `a', e.g.) ?
14:32:45 <atoll> ski: I am gonna try to search on my own for a bit but thanks a lot!
14:32:56 <atoll> Oh yes that would be very nice
14:33:18 <ski> (since it seemed that you thought `s :: (a -> r) -> r' would mean that `s' was polymorphic in `a' and `r', in which case what you tried would have worked)
14:33:32 <ski> atoll : ok, the real type signature of `chainCPS' is
14:33:42 <ski>   chainCPS :: forall a r b. ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
14:33:52 <ski> the `forall' part is the key part here
14:34:19 <atoll> I see, my definition only work in the for some case
14:35:13 <ski> it means that whoever is using/calling `chainCPS', will get to pick particular types for `a',`r',`b', say `T0',`T1',`T2', and then be able to use `chainCPS' with type `((T0 -> T1) -> T1) -> (T0 -> ((T2 -> T1) -> T1)) -> ((T2 -> T1) -> T1)'
14:35:13 <zennist> is there a way to instruct ghc to merge an external library into my final ffi binding lib?
14:35:38 <ski> atoll : now, when you type a type signature like
14:35:40 <ski>   chainCPS :: ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
14:35:53 <ski> in Haskell, that's an abbreviation for
14:35:57 <ski>   chainCPS :: forall a r b. ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
14:36:27 <ski> explicitly quantifying the (free) type variables in the type, *just* after the `::' in the type signature
14:36:33 <kamog> ertes: what actually f (a -> b) is? You had an analogy with the Set category which is cartesian closed and I can't into cartesian closed categories.
14:36:48 <ski> (*unless* any of the type variables are already in scope, in which case they don't get an implicit quantification)
14:37:03 <ski> atoll : it's the `forall' part that actually signifies polymorphism
14:37:09 <ski> atoll : makes sense, so far ?
14:37:14 <atoll> I think so yes
14:37:41 <ski> however, the two *arguments* `s' and `f' of `chainCPS' here will *not* be polymorphic
14:38:56 <ski> (one can have polymorphic arguments, with the `Rank2Types' extension. it would look something like `foo :: (forall a. [a] -> [a]) -> String -> String', e.g. .. in this case `foo' is *not* polymorphic, but it'll require that its first argument will be a polymorphic function)
14:39:12 <aarvar> shachaf: is there a library that works with ghc 7.10?
14:39:20 <ski> (if you want to, i could expand a bit on that in a minute. but back to `chainCPS')
14:39:27 <shachaf> aarvar: I don't know.
14:39:29 <ski> so
14:40:11 <ertes> kamog: haskell functors as represented by the Functor class are endofunctors on Hask…  now Hask is very similar to Set (it's Set with bottoms), so if ((->) e) is an endofunctor that maps objects to functions from 'e', it seems natural to view it as a family of covariant hom-functors from Hask
14:40:44 <ski> conceptually, what first happens, when `chainCPS' is used, is that the `forall a r b.' quantifier part in this specific *use* of `chainCPS' will be removed, and `a',`r',`b' will be replaced by whatever concrete types (like `T0',`T1',`T2') the *user/caller* of `chainCPS' wants them to be
14:40:49 <ertes> s/to functions/to sets of functions/
14:41:07 <ski> atoll : btw, what i'm saying here obviously applies to every polymorphic operation, not just `chainCPS'
14:41:11 <ski> atoll : following ?
14:41:36 <ertes> kamog: and if you're familiar with the Hom(A,-) construction, you can see how fmap would be just (.)
14:42:36 <ertes> kamog: whether that helps is a different matter…  at this point i'm not sure if you're trying to learn haskell for programming or for algebra
14:43:18 <ertes> kamog: if you want to write programs with haskell, all of this is way beyond necessary
14:43:31 <atoll> ski: I need to think a bit :D
14:44:28 <ski> do you want me to try to explain some point more thoroughly ?
14:44:45 <ski> otherwise, tell if/when you want me to continue
14:48:07 <atoll> ski: sorry I had to do something else. Let me read carefully all you've written
14:48:39 * ski waits
14:54:14 <atoll> ski: I am still confused. It seemed to me that the signature of s impled that we could decide the type of r by providing the right function (here id)
14:54:20 <atoll> implyed*
14:54:43 <atoll> but at the same time I guess I am missing the forall part
14:54:56 <ski> right, we can't pick the type of `r'
14:55:09 <ski> (`we' being the implementor of `chainCPS')
14:55:29 <kamog> ertes: nope, I'm poorly aquainted with internal homs (it makes my linear algebra bad, lol), so I just viewed them not as an endofunctor, but as a functor between Hask and Hask over e. What do bottom values do algebraically? Just provide every set with an element?
14:55:50 <ski> atoll : perhaps we should take a simpler example first
14:56:02 <ski>   map :: forall a b. (a -> b) -> [a] -> [b]
14:56:02 <atoll> we can't choose it because r is not bound in the function returned right ?
14:56:38 <ertes> kamog: uhm
14:56:56 <atoll> we return (b -> r) -> r so we can't bound in advance r to a. Is that the reason ?
14:57:19 <ertes> kamog: to answer your latter question:  every type in haskell has an extra inhabitant called "bottom", which denotes computations that never finish
14:57:32 <ski> atoll : "we can't choose it because r is not bound in the function returned right ?", no
14:58:00 <ski> shall we take a look at `map', first ?
14:58:05 <atoll> yes please
14:58:14 <ertes> kamog: for example computations that loop or throw an exception, never really *resulting*
14:58:14 <ski> consider the following *use* of it
14:58:20 <ski>   map digitToInt "496"
14:58:22 <ski> where
14:58:27 <ski> @type digitToInt
14:58:29 <lambdabot> Char -> Int
14:58:55 <ski> atoll : let's first walk through how the type checking of this works
14:58:59 <ertes> kamog: about the former question: i suggest that you don't approach haskell categorically…  better view it as just another programming language for now
14:59:06 <kamog> ertes: yeah, I know meaning of a bottom, but what's different between the category of Sets and it with a bottom?
14:59:15 <ski> first, as you should know, this expression desugars (left-associativity of application) as
14:59:20 <ski>   (map digitToInt) "496"
14:59:52 <atoll> map:: (Functor f) => f a -> (a -> b) -> f b ?
14:59:58 <ski> no
15:00:23 <ski> atoll : now, we start here from the "leaves" in this expression "tree", which here have types as follows :
15:00:35 <ski>   map :: forall a b. (a -> b) -> [a] -> [b]
15:00:42 <kamog> ertes: the only thing I notice is that it doesn't have the empty set, so no initial elements.
15:00:42 <ski>   digitToInt :: Char -> Int
15:00:47 <ski>   "496" :: String
15:00:48 <ertes> kamog: well, there are a few differences to be aware of:  for example in Set the empty set is an initial object, but in Hask it's not
15:00:49 <ski> however
15:00:51 <ski> @src String
15:00:51 <lambdabot> type String = [Char]
15:01:01 <ski> so the last one is really the same as
15:01:04 <ski>   "496" :: [Char]
15:01:09 <ski> atoll : ok, so far ?
15:01:12 <ertes> kamog: yeah, you could say that there is actually no "empty type"
15:01:13 <atoll> yes
15:01:44 <ski> atoll : now, we start by looking at the first application node in this tree, just "above" the first two leaves, namely `map digitToInt'
15:02:07 <ski> atoll : we want to match the type of the argument here with the argument type of the function
15:02:24 <ski> but `map' is polymorphic (since its type starts with a `forall'
15:02:24 <ertes> kamog: however, very often we just pretend that Hask is actually Set and just make sure we never produce bottoms where it matters…  we call that "fast and loose reasoning"
15:03:01 <atoll> so a is set to Char and b to Int ?
15:03:03 <ski> atoll : looking past that for the moment, we see that we'd like to match the function argument type `a -> b' of `map', with the type `Char -> Int' of the argument
15:03:16 <jmcarthur> kgadek: fyi, my first working program spends only 2% of its time in gc, and i haven't done any optimizations yet.
15:03:59 <ski> atoll : yes, so the *first* step, *before* actually typing this application, is to *instantiate* the polymorphic `map' to the specific types chosen in place of the type variables that are controlled by the polymorphism (`forall') here
15:04:07 <kgadek> jmcarthur: sounds good. Got any comparisons? preferably using criterion for both?
15:04:16 <ski> so, as a *first* step, we get from
15:04:17 <ski>   map :: forall a b. (a -> b) -> [a] -> [b]
15:04:18 <ski> to
15:04:30 <ski>   map :: (Char -> Int) -> [Char] -> [Int]
15:04:52 <atoll> Yes I follow so far
15:04:59 <ski> by removing the `forall a b.' part, and simultanously replacing all occurances of `a' by `Char', and all occurances of `b' by `Int'
15:05:26 <jmcarthur> kgadek: I don't have a C version to compare with.
15:05:44 <jmcarthur> kgadek: Ah, you mean vs. tsahyt's?
15:05:50 <kgadek> jmcarthur: both
15:05:57 <ski> only *then* can we actually perform the function argument type to actual argument type matching of the application, getting something that has the type that is the remaining function result type
15:06:01 <ski> iow
15:06:09 <kgadek> jmcarthur: do you have O(n) or O(n^2)?
15:06:13 <ski>   map digitToInt :: [Char] -> [Int]
15:06:21 <jmcarthur> My algorithm is n^2
15:07:01 <atoll> ski: ok so I think I understand the forall part now. ChainCPS should work even if a != r and that's not the case here
15:07:09 <ski> atoll : it's important to realize that the specialization/instantiation step of the polymorphic operation is separate (and happens before), the actual handling of using `map' (here by applying it to an argument expression)
15:07:13 <kgadek> jmcarthur: right, so forget about wiki's implementation — it's O(n)
15:07:37 <atoll> so the type checker will not transform id from a -> r to a -> a but keep a -> r
15:07:58 <ski> atoll : it's a separate step, even if it happens to be implicit in the syntax, due to not having to write anything in particular to make the polymorphic `map' specialize to a particular version for this usage of it
15:08:03 <atoll> sorry if my englush is a very approximate
15:08:04 <jmcarthur> wiki's?
15:08:07 <atoll> english*
15:08:39 <ski> atoll : anyway, let's get back to the signature of `map' (since i think you get the rest of the type checking of `map digitToInt "496" now, right ?))
15:08:47 <jmcarthur> kgadek: I think I am missing some context. I was only aware of what the problem to solve was, not what algorithm to use (my impression was that tsahyt was using a n^2 algorithm)
15:09:07 <atoll> so whenever I use non bound type, they are always replace by a forall rule in haskell, is that right ?
15:09:11 <atoll> replaced*
15:09:36 <kgadek> jmcarthur: yeah, missed that context too :D just now thinking about that
15:09:36 * ski would like to explain it for `map' once more, but now in terms of *implementing/defining* it, rather than *using* it
15:10:25 <ski> atoll : not always, but usually. the exception is in case the tyvar is already in scope before the type signature
15:10:44 <atoll> tyvar ?
15:10:44 <ski> (or the inferred type, in case of no type signature present)
15:10:47 <ski> type variable
15:11:07 <atoll> I see
15:11:13 <atoll> Thanks a lot!
15:11:30 <ski> atoll : should i go on, or not ?
15:11:41 <atoll> I think I got it.
15:12:28 <kgadek> jmcarthur: when you'll finish, show us the code
15:12:40 <ski> i was intending to mention a term that often gets thrown around with stuff like this
15:12:50 <ski> (also by GHC's type error messages)
15:12:51 <jmcarthur> @tell tsahyt Here's my implementation of the n^2 algorithm I suspect you were referring to. This implementation appears to only spend 2% of its time in the GC. I have no C program to compare with, though. http://lpaste.net/192067
15:12:51 <lambdabot> Consider it noted.
15:12:53 <jmcarthur> kgadek: ^^
15:13:05 <atoll> ski: so if I should reword what I said before, the type should check forall a r b, provided that we give the right arguments and that is not the case in my implementation
15:13:39 <ski> atoll : i can't interpret that, so i can't tell whether you've got it right or not ..
15:13:56 <jmcarthur> kgadek: There's a bit of silly boilerplate due to me not settling on any particular kind of Vector type...
15:14:30 <jmcarthur> kgadek: And obviously I did not attempt to use Text, which would have been nice (but slower, of course)
15:15:27 <jmcarthur> kgadek: I'm not going to optimize any further since I have nothing to compare with. That's why I went ahead and shared it.
15:16:02 <jmcarthur> s/any further/at all/   ... but of course I wrote it to be fairly fast from the beginning
15:16:21 <atoll> ski: well let just say that what I am doing can't compile because a could be different than r and the function id is too specialized
15:16:29 <atoll> is that right ?
15:16:38 <jmcarthur> It'd be pretty bad if that append isn't actually avoided in the generated code. I haven't looked.
15:17:26 <ski> atoll : yes. `a',`r',`b' would be (replaced by) skolems/rigids (by the type checking machinery), and different skolems can't be matched to each other
15:17:49 <MarcelineVQ> ertes: thank you for your vector and palindromes talk earlier, I've now learned how to use vector in a basic fashion due to it
15:18:15 <ski> (as opposed to different metavariables/placeholders, which *can* match with anything (apart from when that would create an infinite type))
15:18:22 <jmcarthur> Heh, I could have just sliced the result out of xs instead of all that appending and junk.
15:18:33 <atoll> skolems and rigids are for another day :D It's much clearer. I will try to write ChainCPS now
15:18:49 <ski> they're the same thing, just two names for it
15:19:21 <ski> metavariables are what you get when you *use* a polymorphic value
15:19:34 <ski> skolems are what you get when you *define* a polymorphic value
15:19:56 <ski> both are related to quantifying typevariables with `forall'
15:20:32 <ski> typevariables are a thing you'll see in actual types. metavariables and skolems are only used behind the covers, in the type checking algorithm
15:20:42 <jmcarthur> kgadek: I think even the 2% of time in GC is a bit sad for this program, since really it should be done with basically 0%.
15:21:05 <buglebudabey> paging Cale
15:21:19 <kgadek> jmcarthur: give me a while. Long not written in C/C++ but… let's play a game :D 
15:21:19 <ertes> MarcelineVQ: my pleasure
15:21:21 <ski> .. but imo, it helps to have a basic idea of them, to understand better why some things type check and others don't
15:21:34 <ski> (and to understand the type error messages you'll get in the latter case)
15:21:58 <jmcarthur> kgadek: Sounds fun! But of course I expect to lose if it comes down to heavily optimized C.
15:22:10 <ski> atoll : i'll leave it at that for now, then
15:22:13 <kgadek> jmcarthur: I'm not a good C/C++ programmer
15:22:16 <jmcarthur> kgadek: Also a matter of whether I have the time to continue the game. :)
15:22:23 <ski> @where C/C++
15:22:23 <lambdabot> "C/C++ : A new language for the new Millennium" by Richard Heathfield in 2005-02 at <http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html>
15:22:25 <jonored> I got as far as "let palindromes v = map (c->last $ (0:) $ takeWhile (\l->Just True == liftM2 (==) (v !? (r-a)) (v !? (r+a)) $ [1 .. V.length v]) [1 .. V.length v]" but didn't manage to check whether the list fusions I'm hoping for are happening.
15:22:33 <Cale> buglebudabey: hi!
15:23:07 <buglebudabey> hi! would you mind if i private messaged you for some professional advice seeking?
15:23:22 <kgadek> jmcarthur: sure :) I'm not even sure I'll finish before I'll feel too tired to finish the C/C++ ver
15:23:26 <jonored> (and of course that's only odd-length palindromes.)
15:23:40 <buglebudabey> Cale ^
15:23:47 <jmcarthur> jonored: woops, mine has that problem
15:23:49 <Cale> buglebudabey: I don't mind
15:23:52 <jmcarthur> I didn't even think about it.
15:23:57 <jmcarthur> kgadek: I cheated.
15:24:40 <kgadek> ok, so let's stick to that
15:24:44 <kgadek> only odd palindromes
15:25:04 <atoll> ski: I found the right implementation:  :t let chainCPS s f = \k -> s (\x -> f x k)  in chainCPS :: ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r). It makes a lot of sense, thanks
15:25:48 <ski> atoll : yay ! you even got the eta-reduction :)
15:26:28 <ski> (otherwise you'll probably not get tail-calls where you'd expect, and so could e.g. leak memory)
15:26:58 <atoll> just to be sure. Where I have done an eta reduction ?
15:27:11 <ski> the eta-long version is
15:27:17 <ski>   chainCPS s f = \k -> s (\x -> f x (\y -> k y))
15:27:19 <jonored> Only odd palindromes is at worst a factor of 2, anyways :)
15:27:24 <ski> with `y' of type `b'
15:28:01 <ski> atoll : ok ?
15:28:07 <atoll> Oh I see
15:28:12 <atoll> but I didn't do it on purpose
15:28:14 <atoll> :D
15:28:27 * hackagebot do-list 1.0.0 - Do notation for free  https://hackage.haskell.org/package/do-list-1.0.0 (TarasSerduke)
15:28:36 <ski> good that you spotted that you could plug `k' in ther directly, anyway
15:28:58 <ski> (instead of just blindly introducing a new lambda to match the type of that hole)
16:12:14 <myname_> hi
16:12:57 <lambdabot> Hello.
16:13:10 <pie_> are there any/can you guys reccommend any security analyses of haskell/using haskell?
16:14:14 <pie_> im interested in things more detailed than "type checking prevents 99.9999% of problems"
16:15:45 <simon__> exit
16:15:51 <Welkin> pie_: it seems like you are expecting a stupid response, so why bother asking?
16:17:35 <pie_> Welkin, things i found on the internet really :I
16:17:47 <pie_> i guess i could have just left that out.
16:18:57 <schell> pie_: i haven’t read anything about people specifically attacking programs written in haskell, but if you find some, please let us know! 
16:19:14 <Welkin> schell: there are plenty of misinformed people on the internet
16:19:27 <Welkin> I have heard the most hilarious things about haskell
16:19:48 <Welkin> like that "purely functional" means that you are unable to mutate data, so it is a useless language
16:19:56 <schell> i meant attacking as in attempting sql injection, buffer overflow, etc 
16:19:59 <Welkin> lol
16:20:11 <schell> no doubt there are lots of nay sayers
16:20:38 <schell> lol - i’ve been all willy nilly with mutation lately
16:20:40 <Welkin> oh, well security doesn't depend so much on the language as the implementation
16:20:55 <zv> pie_: i am disassembling a haskell binary now
16:21:02 <pie_> sure but id still like to read about it
16:21:07 <zv> pie_: many c runtime functions are used
16:21:16 <zv> the invulnerability to RE is wildly overstated
16:21:27 <zv> IDA reconstructs haskell binaries perhaps even better than C++
16:21:50 <zv> I haven't seen any security mishaps, but there is runtime code that appears to be written in C
16:21:53 <Welkin> what now about reverse engineering?
16:21:55 <pie_> huh. strange because i have read that reversing haskell binaries isnt necessarily a walk in the park.
16:21:59 <Welkin> anything can be reverse engineered
16:22:04 <zv> Welkin: sure
16:22:07 <Welkin> it is, in fact, all the same machine code in the end
16:22:08 <pie_> with symbols stripped anyway
16:22:24 <zv> Welkin: but that doesn't change that some reverse engineering is very easy and some is hard
16:22:34 <pie_> Welkin, i agree :P but yes/no isnt the question, its about difficulty
16:22:36 <schell> no need to reverse engineer when you can get tho source to the runtime, correct?
16:22:43 <zv> schell: thats correct
16:22:54 <pie_> what do you guys mean by that?
16:23:01 <zv> but it's important to get the relevant handlers passed into rts schedule
16:23:25 <zv> I'm not really a haskell programmer and actually just was about to ask a haskell disassembly question but then I saw a bit aobut haskell security and I couldn't resist
16:23:30 <zv> so this is all new to me
16:23:53 <zv> a lot of very long and laborious scheduling code
16:23:54 <schell> zv: ah - well you’re already talking beyond my c comprehension!
16:24:03 <pie_> i havent even written any haskell yet :x (shame shame)
16:24:22 <zv> pie_: it is a cool language but if you are security minded there is no substitute for ocaml + python
16:24:24 <jmcarthur> zv: I'm curious what a Haskell program looks like in IDA.
16:24:33 <Welkin> zv: why?
16:24:34 <zv> not because of any inherent advantage of either, but because of historical preference
16:24:48 <pie_> zv, now you must post obligatory screenshots :P
16:25:25 <pie_> hm, ran across this https://downloads.haskell.org/~ghc/7.4.2/docs/html/users_guide/safe-haskell.html whatever it means
16:25:26 <jmcarthur> zv: I would expect it to have some issues, due to how thunks work and that GHC's calling convention isn't really common.
16:25:34 <zv> jmcarthur: yeah, I had read that online as well
16:25:40 <zv> like I said, this all came as quite a surprise to me
16:25:53 <zv> I had heard it would be nigh impossible, I'm no genius reverse engineer either
16:26:22 <pie_> i just started reading the ida book a couple days ago, but univ starting is probably going to get in the way of progress on that, how hard would it be to add some instrumentation with idapython?
16:27:05 <pie_> idahaskell pls :P
16:27:06 <Cale> zv: Yeah, it's weird / different from most assembly code, but not impossible at all to understand what's going on with a debugger.
16:27:54 <jmcarthur> Reading Cmm is quite reasonable, and I would expect reading whatever IDA figures out to be easier than that.
16:28:16 <jonored> pie_: safe haskell is neat, although it doesn't prevent some "just eat a lot of resources" attacks on it's own. It's part of how you can do things like "execute arbitrary code from the internet without much risk", though.
16:28:28 * hackagebot store-core 0.2.0.2 - Fast and lightweight binary serialization  https://hackage.haskell.org/package/store-core-0.2.0.2 (borsboom)
16:28:30 * hackagebot store 0.2.1.2 - Fast binary serialization  https://hackage.haskell.org/package/store-0.2.1.2 (borsboom)
16:28:32 <pie_> neat.
16:28:41 <Cale> I actually had the occasion not too long ago to step through a bunch of the Javascript generated by GHCJS when trying to track down a weird issue, which is pretty similar given that it still compiles via Cmm.
16:28:49 <pie_> from a layman outsiders perspective resource leaks seem scary with haskell :(
16:28:59 <zv> pie_: its not so much different from other code, although strangely when I tried to load Flirts sigs from haskell code that wasn't stripped, IDA pro segfaulted
16:29:07 <zv> anyway: http://imgur.com/a/mg53n
16:29:12 <zv> that is some scheduler code in the runtime
16:29:14 <pie_> zv, should have written ida in haskell :P
16:29:15 <Cale> It was quite possible to work out what was going on -- maybe a little easier than usual because there will be the occasional relatively-complete Javascript object
16:29:58 <pie_> i find debuggers and disassemblers and analyzers and stuff like that choking on input rather perverse :I
16:30:00 <jmcarthur> zv: Ah, I'd expect that to be trivial for IDA.
16:30:24 <jmcarthur> zv: I'm more curious about code generated from some actual Haskell.
16:30:45 <zv> pie_: i just wrote some Idac to locate some important internal objects, Haskell keeps referencing a 16byte struct and then calling a particular address - it was fairly easy to enumerate all the instances 
16:31:23 <Cale> The RTS itself is written in C, so it'll be perfectly normal looking.
16:31:27 <zv> pie_: beyond that I'm not sure what you had in mind with IDAPython, I've never used it for anything beyond the basics of "get me a list of all these things" or running regular expressions on .text sections
16:31:45 <Cale> The weird bit will be what happens with all the actual Haskell code :)
16:32:02 <Cale> But it is possible to decipher what's going on
16:32:32 <zv> Cale: one big problem that I'm having is that a bunch of actual execution happens in what appears to be a dl_open call
16:32:48 <zv> i.e some so is being loaded with haskell code??!???
16:32:50 <pie_> zv, i dont really know but someone i know apparently mentioned reimplementing an architecture iplugin in idapythong
16:33:06 <zv> like I said, I actually joined this channel to ask for help so I am definitely no expert
16:33:21 <pie_> Cale, what does rts mean?
16:33:25 <zv> runtime
16:33:28 <pie_> ah
16:33:42 <Cale> Which is basically the garbage collector and thread scheduler
16:34:02 <jmcarthur> A lot of GHC primitives have direct rts support, too.
16:34:40 <jonored> pie_: I mean, for Safe Haskell that's mostly a "we can't solve the halting problem, and this doesn't provide your kill-the-process-that's-taking-too-long mechanism itself" issue. In terms of laziness-induced memory consumption stuff, yeah, that's easier to screw up, but laziness is also very good for other parts, and there are some abstractions that help you write code that doens't have those leaks.
16:35:32 <Cale> zv: What sort of Haskell program is it?
16:35:47 <jmcarthur> zv: I wouldn't be surprised to see any program loading a .so, really. Not sure why this is surprising?
16:36:22 <Cale> It is totally possible for Haskell programs to load modules dynamically -- 'plugins' is a Haskell package to help with doing that, which might be in use.
16:36:46 <jmcarthur> But it also doesn't even have to be a Haskell module.
16:36:53 <Cale> Yeah, that's true
16:37:00 <zv> jmcarthur: sure, but this is runtime relocations being generated here
16:37:05 <zv> which, while we're on the security topic
16:37:14 <zv> means write and execute memory
16:37:47 <Cale> oh, it might also be iconv?
16:37:58 <pie_> jonored, thanks
16:38:21 <zv> now, i have no idea if that has any security consequences, but loading a .so and dynamically generated plt relocations is not something *I* see everyday, although I'm not a virus hunter or anything like that 
16:38:26 <zv> Cale: that is an interesting idea
16:40:56 <zv> Cale: strangely enough it appears to be 'libgcc'
16:41:25 <zv> i haven't used it before but I'd guess it had to do with compiling code at runtime
16:41:40 <Cale> huh....
16:41:59 <jmcarthur> zv: What is this program?
16:42:24 <zv> jmcarthur: if i knew i wouldn't be disassembling
16:42:48 <jmcarthur> Ah, I thought this was an exercise using a known program.
16:42:51 <zv> although I compiled a test haskell that does a simple bubblesort and then prints the result and it appears to work as well
16:42:58 <Cale> https://ghc.haskell.org/trac/ghc/ticket/12486
16:43:13 <ben> How much time do people typicall spend worrying about monad transformers relative to relatively unmonadic code?
16:43:23 <zv> Cale: aha!
16:43:34 <ben> I feel like any time I want to write a toy program, I run into monad transformers really soon and then I get a headache.
16:43:57 <glguy> ben: You can go a long way not using monad transformers
16:43:58 <zv> jmcarthur: what I should have said is that it contains the string as well after calling _dl_export_whatever
16:43:59 <jmcarthur> ben: I pretty rarely use transformers.
16:44:40 <ben> Like, I'm like "ok I guess I need to do IO here but I also wanna do..." and before I know it I'm reading the source to Control.Monad.Trans.Control to figure out what's up
16:44:47 <jonored> I spend pretty little time on monad transformers, but a good half of my usage is for machine assist on logic/word puzzles.
16:45:10 <ben> I guess I'm doing it wrong.
16:45:43 <jmcarthur> ben: Not necessarily.
16:45:47 <Cale> ben: Well, if you're already using IO, perhaps try instead just adding a function argument for the first few "I also want" things, assuming it was just going to be reader, writer or state
16:45:50 <jmcarthur> ben: It may depend on the kind of program you are writing.
16:46:28 <Cale> and then make a proper record type for those things you're passing around
16:47:02 <Cale> maybe, maybe you'll end up with a ReaderT eventually, but usually it's fine to pass around this configuration parameter a bit
16:47:10 <jle`> there's rarely any cases where you actually need monad transformers ...
16:47:33 <Welkin> jle`: are you an anti-transformer person?
16:47:57 <jmcarthur> I guess I do often work with monad transformers, but the fact that they are monad transformers is kind of secondary. That is, I don't really design it with the goal of making a monad transformer.
16:48:36 <Cale> I end up using transformers on a regular basis mostly just because other people's libraries define them
16:48:37 <jmcarthur> Kind of like with monads, etc. I tend to make things that are monads and perhaps even consider it "nice" or "cute" when it's monad, but it's not the objective.
16:48:51 <Cale> and there are some actual reasonable cases
16:49:33 <Cale> But I see a lot more frivolous ReaderT and StateT over IO than anything.
16:49:41 <jle`> 43ththe only situation i've ever 
16:49:59 <glguy> zv: One way to generate mprotect syscalls with GHC compiled executables is to export Haskell values via the FFI using "wrapper" exports
16:50:09 <glguy> specifically mprotect with read/write/execute
16:50:18 <jle`> Welkin: i am not anti-monad-transformer, but a lot of usage of monad transformers is mostly for convenience and to remove boilerplate
16:50:28 <jle`> like what is probably the case in ben's situation
16:50:39 <jle`> a lot of work only to remove boilerplate, when it might not even be wort it
16:50:50 <zv> glguy: oh, interesting
16:51:01 <jle`> like, pattern matching on Maybe instead of using its Monad instance
16:51:18 <ben> Well it's more the thing where there's neat looking libraries that I want to shoehorn into my hobby coding
16:51:23 <zv> i mean, in principle a perfectly-typed language would have no need of of memory protection, because there would never been memory corruption exploits
16:51:30 <jle`> you rarely ever *have* to use the Monad instance for Maybe.  you could just manually pattern match and deal with the boilerplate
16:51:34 <zv> but it would be a nice security blanket
16:51:50 <glguy> zv: This is how you can turn a runtime generated function or action into code callable from C
16:53:03 <jle`> ben: if you're running into monad transformers really soon for toy projects, you might be really just shoehorning monad transformers where they don't add any benefit
16:53:13 <jle`> i can't imagine a project quickly running into a situation where they need monad transformers
16:53:20 <zv> glguy: do you know much about the low-level implementation of haskell?
16:53:44 <ben> jle`: right now the situation is "hm i want to do a thing that involves a network connection, better pull in pipes-network" and there i go
16:53:51 <zv> the code that is called from stginit doesn't appear to be valid machine code
16:53:56 <ben> and i guess i'm trying to figure out if i just have self-destructive patterns of behavior
16:54:17 <glguy> zv: I don't know what would cause that specifically
16:54:30 * jmcarthur kind of feels like pipes and conduit are overused
16:55:04 <jmcarthur> Or if not overused, overrecommended. I don't think they should necessarily be the first thing to reach for, at least.
16:55:08 <glguy> I wasn't aware they were that commonly used so as to be overused
16:55:17 <jle`> unless they were going out of their way to use them
16:55:42 <Welkin> lol
16:55:49 <Welkin> I used pipes just to learn how to use it
16:55:55 <Welkin> haven't used it since
16:56:06 <ReinH> Some people seem to think that pipes/conduit is the only good way to do IO
16:56:10 <ReinH> That lazy IO is always bad
16:56:17 <ben> is there a good way to do io. i remain to be convinced.
16:56:41 <johnw> these days I think lazy I/O is fine
16:57:02 <ReinH> Plenty of things you want to do with IO fit trivially into memory, etc
16:57:06 <jle`> does pipes-network really make you work with monad transformers?
16:57:09 <jmcarthur> Well, I do think lazy IO is usually bad, but that doesn't mean you have to use a streaming library to get something done. Streaming libraries aren't bad either, but they do require learning a lot more and thinking in a possibly less straightforward way, especially for things that should be pretty simple to begin with.
16:57:16 <jle`> well, besides working with the specific types in the library
16:57:26 <jle`> like, "monad transformers in general"
16:57:34 <jmcarthur> For toy programs, lazy IO should normally be fine.
16:57:36 <ben> i mean it's not making me write my own ones
16:57:44 <jle`> in that case you might not actually be having problems with monad transformers, but just a problem with a specific type
16:57:54 <jle`> that's like saying you have a problem with monoids when you really want to do 'take 5' on a list
16:58:31 <ben> Monoids seem a lot less dangerous than monad transformers
16:58:35 <jmcarthur> pipes sort of forces you to think in transformers for certain kinds of things. For example, it's the only nice way to share a state between two composed pipes without an IORef, afaik.
16:58:46 <jle`> lists are monoids, but it's not like learning to use lists is just "how do i use monoids"
16:59:02 <shachaf> It pretty much is.
16:59:03 <ben> I didn't mean that I'm scarred by the abstract concept of monad transformers
16:59:15 <ben> just that I'm trying to use specific ones because they look neat
16:59:15 <jle`> if i wanted to ask how to take the first five elements in a list, and i'm having trouble, i would go on stack over flow and ask "questions about working with monoids"
16:59:18 <ben> and then I suddenly have a headache
16:59:49 <jle`> ben: ah.  in that case, the fact that they are monad transformers is probably not super relevant to your headache
16:59:54 <jle`> it's probably just the actual type itself
17:00:06 <jmcarthur> I guess another way to share the state would be to pass it back and forth between the two pipes, but then you're messing with proxies and tupling and good grief this doesn't sound fun.
17:00:21 <jle`> the fact that the type happens to be a monad transformer might be incidental and irrelevant to your problems :)
17:00:34 <Sonolin> ben: something I usually do is wrap a function in the transformer, but "hide" the transformer using "run*T" before
17:00:59 <Sonolin> so for something like ContT it would like something like: runContT (ContT function) id
17:01:55 <jle`>  ^^ those are the types of answers you'll get if you ask about working with monad transformers :)
17:04:28 <jle`> possibly good general advice, but will it make working with pipes-network easier? not in a direct way, probably
17:11:47 <flippant> Hi folks. Is there solution for this yet? `data Update = Update { updateItems :: [Int64], updateProfiles :: [String] }`
17:12:11 <flippant> i current have to prefix record field with `update`
17:12:14 <flippant> *currently
17:16:30 <Welkin> flippant: yes, in ghc 8
17:16:55 <Welkin> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/DuplicateRecordFields
17:18:44 <flippant> Thanks
17:30:11 <joe9> what is the difference between gl package and opengl or openglRaw package?
17:30:49 <Welkin> gl is the newer bindings
17:30:56 <Welkin> they are more faithful to the opengl api
17:31:05 <joe9> I just tried the opengl package and I notice that the GLSL version supported is 1.30 whereas with C I can get 330 GLSL script to compile.
17:31:30 <Welkin> gl is complete raw bindings
17:31:31 <joe9> Welkin: ok, Thanks. I guess gl is the recommended version then.
17:32:15 <joe9> Welkin: Do you know what version of opengl is supported by gl?
17:33:06 <Welkin> check on hackage
17:33:21 <Welkin> http://hackage.haskell.org/package/gl
17:33:46 <jmcarthur> joe9: gl is an alternative to OpenGLRaw, but not really an alternative to OpenGL.
17:33:54 <Welkin> core 32 through core 45
17:34:11 <jmcarthur> joe9: OpenGLRaw is the raw bindings used by OpenGL, which is intended to be a somewhat higher level interface than OpenGLRaw.
17:34:34 <jmcarthur> joe9: OpenGL being higher level also means there are some maintainance costs to keep it up to date with the newest versions, so it lags behind.
17:34:39 <joe9> jmcarthur: I have a bad experience with OpenGL. It cannot compile a GLSL version more than 1.3. whereas with C, I can get GLSL 3.30 to work on the same computer.
17:34:53 <jmcarthur> joe9: gl is generated straight from the specification and should basically always be up to date as far as I know.
17:35:35 <joe9> jmcarthur: I was debating just using the C version and am thinking about interfacing from haskell to that C program. It appears that I should try gl before doing that.
17:35:39 <jmcarthur> joe9: OpenGLRaw should generally be pretty up to date, too.
17:35:49 <jmcarthur> joe9: (but I like gl)
17:36:42 * geekosaur wonders if joe9 is on os x
17:36:53 <joe9> jmcarthur:  Thanks. I will give gl a try. All the abstractiongs OpenGLRaw, OpenGL and GLUtil makes things confusing imho.
17:36:59 <joe9> geekosaur: no, linux
17:37:23 <geekosaur> ok. OS X has some weirdness in that area
17:37:56 <joe9> jmcarthur: Welkin, any examples using gl, please?
17:38:44 <jmcarthur> joe9: gl mirrors the specification very closely, so you should be able to basically just look at any C example.
17:41:03 <joe9> jmcarthur: ok, Thanks.
17:41:29 <joe9> jmcarthur: Do you use glfw? haskell bindings? glfw-b?
17:41:47 <joe9> I find that glfw is also lagging behind the release by more than an year.
17:41:59 <joe9> Not sure if that is expected.
17:42:10 <joe9> or, if it is not being maintained anymore.
17:42:59 <jmcarthur> joe9: Give sdl2 a shot.
17:44:02 <jmcarthur> joe9: https://github.com/haskell-game/sdl2/tree/master/examples
17:46:12 <joe9> jmcarthur: quick question, with gl, how do I find the haskell definition of the glGenBuffers? when I grep in the gl source tree, I find these http://bpaste.net/show/1ec18f5ec68e
17:47:30 <joe9> jmcarthur: isn't sdl2 a wrapper over opengl?
17:49:47 <Welkin> not quite
17:49:59 <joe9> jmcarthur: from reading the above link, it appears that sdl2 is a replacement for glfw
17:49:59 <Welkin> the sdl renderer does wrap opengl in some way
17:50:02 <Welkin> but it is limited
17:50:25 <joe9> it is a window manager similar to glfw, it appears(?)
17:50:26 <Welkin> sdl handles input, window creation, and audio
17:50:37 <Welkin> usually you use sdl2 to handles everything but rendering
17:50:44 <Welkin> and create a rendering context in which you use opengl
17:51:13 <Welkin> sdl2 is usually used together with opengl
17:51:33 <joe9> Welkin: ok, cool, makes sense. one quick question, with glfw, i can create multiple windows with one window per green (haskell async) thread.
17:51:48 <joe9> Welkin: Can I do that with sdl2, please?
17:51:53 <Welkin> you can have multiple windows in sdl2
17:53:35 <joe9> Welkin, quick question, the above sdl2 link is using OpenGL and not gl
17:54:15 <joe9> Welkin, my issue is that OpenGL is not complaining when I use a GLSL file with a version > 1.30
17:54:27 <joe9> s/is not complaining/is complaining/
18:03:22 <joe9> quick question, when you get to this package: https://hackage.haskell.org/package/gl the modules are not hyperlinked. I understand that the files are generated. but, how can one check these files?
18:04:47 <glguy> joe9: I'll see if the docs builds
18:10:14 <glguy> Neat error trying to generate the documentation for that package: haddock: internal error: /var/folders/t0/04lb5h5n1sb6w_ghq4vgpgjw0000gn/T/.haddock-94842: removeDirectoryRecursive: resource exhausted (Too many open files)
18:10:21 <glguy> edwardk: Did you find yourself hitting that?
18:13:28 <c_wraith> woo, haddock bug!
18:13:59 <glguy> It might just be the OS X limit being too low by default, trying with a higher limit now
18:14:50 <c_wraith> Unless the OS limit is like 20, I'm calling that a haddock bug.
18:15:22 <geekosaur> 256
18:16:47 <glguy> joe9: https://hackage.haskell.org/package/gl
18:16:53 <jaspervdj> sounds like lazy IO doing its thing
18:23:42 <linoge> So suppose I've got module A with an ADT T = { a1 :: t1, a2 :: t2 }. If I want to use T { a1 = v1, a2 = v2 } from within another module... Must I write module A (T, a1, a2) where ...?
18:24:00 <linoge> Is there no better way? I might have complex ADTs with many many fields D:
18:27:33 <brn> Hi, I'm having trouble with megaparsec. When I try to parse something, my program just run forever and I don't really see why http://lpaste.net/192311
18:29:50 <jonored> linoge: module A (T(..)) I think is the syntax for "and all it's constructors and record names".
18:30:46 <linoge> jonored: that'd be really cool, let me see ^^
18:31:36 <jonored> Either way, there is definitely an "and all it's things" syntax, I just might have gotten it not quite right.
18:32:14 <linoge> jonored: you got it all right :D. Thank you very very much
18:32:46 <linoge> I got a leave to use Haskell in an actual (though small) project at work and I'm quite excited x)
18:32:57 <glguy> brn: You have an infinite loop in bParser
18:33:15 <glguy> err, hold on, I'm not ready to say that
18:33:26 <glguy> brn, OK, here's how:
18:33:33 <glguy> aParser can parse the empty string
18:33:39 <glguy> space can parse the empty string
18:33:55 <glguy> then on line 15 you go back into expression parser
18:34:12 <glguy> and loop
18:34:29 <brn> oooh I see
18:37:19 <joe9> glguy:  Thanks.
18:37:24 <brn> I had this problem for like the whole day haha thank you glguy, I just changed "many" to "some" and everything is working now
18:37:56 <glguy> Yay! You're welcome.
18:40:50 <c_wraith> I figured it was infinite left recursion on empty input, but I didn't realize space accepted the empty string
18:40:56 <c_wraith> So I wasn't sure how it was doing it.
18:41:21 <glguy> I wasn't sure, either. I "cheated" with http://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Char.html#v:space
18:51:49 <lordcirth> Is there an up to date guide on installing Leksah IDE on Ubuntu 16.04?
18:52:15 <lordcirth> There's a bunch of different guides, not sure what's best, and half are for Ubuntu 8 or 9
18:52:53 <lordcirth> Oh nvrm I think I found it
18:52:55 <hamishmack> lordcirth: https://github.com/leksah/leksah#building-from-source
19:10:14 --- mode: ChanServ set +o glguy
19:10:14 --- mode: glguy set -q OMGilluminated*!*@*
19:12:55 --- mode: glguy set -bbb *!*@99.32.15.3 *!*@79.98.158.170 *!*hejhekj@37.98.192.*
19:13:10 --- mode: glguy set -o glguy
19:38:33 <codygman> I see there is a Haskell antlr library. Has anyone used it? I need to parse cql statements and yanking the antlr grammar directly from Cassandra and getting an AST to use from Haskell immediatley sounds pretty nice.
19:59:53 <codygman> Alright, let's try this instead. I'm wanting to write a Golang parser in Haskell that needs to be fast (will be used with a linter). Should I use Parsec? Megaparsec? Attoparsec? Happy? Earley? Which will get me there the fastest? I've been reading this thread but it doesn't really answer my question: https://www.reddit.com/r/haskell/comments/46u45o/what_is_the_current_state_of_parser_libraries_in/?st=it0w2ldf&sh=898e9d9f 
20:08:25 <geekosaur> attoparsec is fastest but at the price of terrible parse errors
20:09:05 <geekosaur> usually one starts with parsec/megaparsec and then switches to attoparsec once the parser is debugged, if you really need the performance
20:09:52 <ReinH> Trifecta!
20:10:03 <glguy> attoparsec will be fast if you write a fast parser. you'll need to make sure to factor the grammar appropriately
20:10:13 <glguy> it won't help you to do that though
20:11:09 <glguy> you'll be playing the role of parser compiler yourself rather than allowing a tool like happy to do that
20:21:45 <dmwit> codygman: Consider starting with http://hackage.haskell.org/package/language-go and only doing your own implementation work if that turns out to be insufficient.
20:22:24 <codygman> dmwit: I would but the license is gpl and I'm not sure if that's okay for my use case.
20:25:38 * dmwit nods sadly
20:40:40 <glguy> dmwit: Check out the deps on that package: Dependencies: array, base (==3.*), parsec (>=3), utf8-string [details]
21:00:10 <codygman> How can I represent this as an ADT: tuple_literal ::=  '(' term ( ',' term )* ')'
21:00:48 <codygman> example is from a cql statement:  VALUES ('ev1', (3, 'hours'))
21:00:53 <c_wraith> I'd probably represent it as a tuple constructor then a list of arguments.
21:01:13 <c_wraith> Like..  NTuple [Value]
21:01:43 <codygman> c_wraith: Makes sense. Thanks
21:04:09 <ReinH> NTuple <$> term `sepBy` comma
21:48:23 <joe9> glguy: same issue with this package too. http://hackage.haskell.org/package/OpenGL-3.0.1.0 the modules are not hyperlinked.
21:49:39 <buttons840> should I use "True" or "otherwise" in the catchall of my guard statement?
21:51:01 <pkmx> @src otherwise
21:51:01 <lambdabot> otherwise = True
21:51:17 <geekosaur> either but "otherwise" is generally preferred just for readability
21:51:32 <geekosaur> Lispers would probably use True >.> (compare "cond")
21:52:53 <buttons840> otherwise is a long word; i guess "else" is taken as a keyword though?
21:53:40 <buttons840> not that any of this matters much :\
21:55:23 <lpaste> manyone pasted “hackerrank problem” at http://lpaste.net/192564
21:55:36 <geekosaur> t = True -- (cond expr ... (t default))
21:55:39 <geekosaur> :p
21:58:33 <manyone> when i run my code in hackerrank i get compile error on "sum c" but i can get the function to run in gchi
21:59:51 <geekosaur> you should include the full error message
22:00:07 <geekosaur> (there;s an "annotate" link in the paste you can use to add it)
22:00:44 <glguy> manyone: You'll need to convert your Ints to Doubles explicitly
22:01:01 <glguy> p, l, and r have type Int, but you're trying to use them like Double
22:01:07 <geekosaur> I will however note that common sources of differences between compiled programs and ghci are: (1) ghci has NoMonomorphismRestriction turned off (2) ghci has ExtendedDefaultRules turned on
22:01:18 <geekosaur> er, has MonomorphismRestriction turned off
22:01:18 <glguy> err, not p but q
22:01:44 <kadoban> When you're using something like hackerrank, they use a pretty old GHC too. Like 7.8.4, which is somewhat likely not what you're using locally.
22:01:47 <manyone> i get these"[1 of 1] Compiling Main             ( solution.hs, solution.o )  solution.hs:5:22:     Couldn't match type `Int' with `Double'     Expected type: [Double]       Actual type: [Int]     In the first argument of `sum', namely `c'     In the expression: sum c  solution.hs:5:47:     Couldn't match type `Int' with `Double'     Expected type: [Double]       Actual type: [Int]     In the second argument of `map', namely `c'     
22:02:04 <glguy> manyone: You can convert from Int to Double with fromIntegral
22:02:05 <kadoban> Though I don't see anything there that differs between versions.
22:03:41 <manyone> why does it think that c is Int?
22:04:06 <glguy> manyone: It doesn't, it thinks it's a list of something
22:04:23 <glguy> but what that something is is confused because it's a mix of Int and things that can't be Int
22:04:49 <glguy> It's trying to match [Int] and [Double] and objecting that Int isn't Double
22:05:21 <glguy> You can't do this, for example: l+0.001  where l is an Int
22:06:07 <geekosaur> Haskell is not C, it never changes the type of something to make it fit elsewhere
22:06:18 <glguy> joe9: http://hackage.haskell.org/package/OpenGL
22:06:38 <manyone> but i need to increment by 0.001
22:06:39 <geekosaur> if you use an Int in an expression that wants a Double, it will not be "promoted" to Double the way C/C++/Java would
22:06:53 <geekosaur> the answer is to explicitly convert: fromIntegral l + 0.001
22:07:10 <manyone> let me try that
22:07:28 <glguy> Keep in mind you need to convert in more places than this one
22:07:38 <geekosaur> that will probably just switch the error elsewhere because you make the same mistake multiple times
22:08:08 <glguy> If you were to put an explicit type signature:  c :: [Double], it would help you get more useful error locations
22:08:49 <manyone> i get the same error. let me try the explicit type
22:09:27 <geekosaur> you probably got similar error, not same error. same expression different variable
22:09:35 <glguy> manyone: You're going to keep getting errors until you fix all the places you used an Int as a Double, there were about 4 of them
22:09:41 <geekosaur> because you assumed an Int will automatically become a Double *everywhere* in that expression
22:11:42 <manyone> no change
22:12:00 <glguy> OK, keep going
22:14:03 <dgloe> Using cryptonite, I would like to use a Digest SHA3_256 as a cipher key, but I can't figure out how to convert it to a ByteArray. Any ideas?
22:15:28 <glguy> dgloe: You can use the ByteArrayAccess instance for Digest a
22:17:02 <dgloe> glguy I figured something like that but I'm new, not quite sure how classes/instances work
22:17:36 <glguy> Data.ByteArray.convert :: (ByteArrayAccess bin, ByteArray bout) => bin -> bout
22:19:59 <dgloe> ah the convert helped, thanks
22:27:30 <Cooler> could not find module System.Clock
22:27:50 <Cooler> when trying to run a .hs script
22:28:12 <Cooler> doesn't System.Clock come with the default install?
22:28:36 * hackagebot bond 0.6.0.0 - Bond schema compiler and code generator  https://hackage.haskell.org/package/bond-0.6.0.0 (chwarr)
22:29:24 <glguy> Cooler: It doesn't
22:29:33 <geekosaur> so far as I know there is no System.Clock. do you mean Data.Time.Clock?
22:29:35 <kadoban> Cooler: It appears to be in the 'clock' package. Never heard of that package myself, not sure if it comes with GHC or not.
22:29:44 <Rarrikins> Cooler: I don't have it here, but installing the `clock` package should get it.
22:29:57 <koz_> Cooler: http://hackage.haskell.org/package/clock <-- this is where it's from, and no, it's not part of GHC.
22:30:04 <koz_> Whoever can shove whatever into System.Whatever.
22:30:12 <koz_> Just because it's part of System, doesn't mean it comes with GHC.
22:39:23 <neonfuz> Is there a good haskell compiler/interpreter that has a GC that doesn't stop the world?
22:41:32 <Cooler> why does Bool instance Ord?
22:42:01 <glguy> Cooler: Because there is a sensible total order which makes it possible to use, for example, as a key for a Map
22:42:37 <Cooler> what?
22:42:49 <glguy> Lots of non-numeric types have Ord instances to support being used as Map keys, in Sets, etc
22:43:52 <Cooler> > True > False
22:43:54 <lambdabot>  True
22:44:32 <Cooler> why does it need to instance Ord for being used as key/
22:44:35 <Cooler> ?
22:44:39 <ski> Cooler : if you want to express the condition that in case `foo' holds, then `bar' must also hold, you can express that implication in terms of the ordering `foo <= bar'
22:45:18 <ski> Cooler : `Map' operations require `Ord' for keys, and `Set' operations require it for elements
22:45:33 <ski> in order to enable a more efficient implementation
22:45:43 <kadoban> Cooler: It's a requirement for Data.Map and Data.Set (which are something fairly close to binary search trees)
22:45:56 <liste> @hackage unordered-containers -- there's also this
22:45:56 <lambdabot> http://hackage.haskell.org/package/unordered-containers -- there's also this
22:46:07 <liste> that requires Hashable
22:51:31 <glguy> neonfuz: The good Haskell compiler/interpreter is GHC, so that'll be the place to start looking to see if it does what you need
23:03:46 <Cooler> 5. instance Read Bool – Read parses strings into things. Don’t
23:03:46 <Cooler> use it. No seriously, don’t.
23:03:52 <Cooler> why not?
23:05:27 <dmj`> > read "true" :: Bool
23:05:27 <kadoban> > read "Hi" :: Bool
23:05:30 <lambdabot>  *Exception: Prelude.read: no parse
23:05:30 <lambdabot>  *Exception: Prelude.read: no parse
23:05:39 <dmj`> kadoban: jinx!
23:05:44 <glguy> Read is generally slow and doesn't provide feedback on failure
23:05:48 <kadoban> dmj`: Yours was better too :-/
23:05:52 <glguy> it's suited for debugging
23:06:29 <dmj`> Cooler: Text.Read.readMaybe :: Read a => String -> Maybe a is safe, but slow still
23:06:41 <dmj`> kadoban: yours was friendlier
23:06:50 <kadoban> :)
23:08:23 <Cale> Cooler: Read is okay, it's read (lowercase) which is spooky because it doesn't let you deal with failure.
23:08:45 <Cale> Read the type class gives you operations with which you can tell if parsing was successful or not also though.
23:09:15 <glguy> the lack of feedback is that it can't tell you anything about the failure other than that it failed
23:10:05 <Cale> Well, yeah, in some settings, that also becomes an issue, and you'll want a more sophisticated parser.
23:11:33 <neonfuz> glguy: unfortunately the GHC GC is world stopping, there aren't any other good haskell interpreters / compilers?
23:11:53 <Cooler> Cale, why would you implement read if its slow AND it doesn't have basic features?
23:12:36 <Cale> Cooler: Apart from the fact that it parses String values, it's not necessarily slow -- it's typically fast enough.
23:13:09 <Cale> Cooler: and it can be derived, so you get it for free by adding "deriving (Read)" to the data declaration for your type.
23:13:32 <Cale> Cooler: It can be handy to have an easy way to parse some values without needing to hand-write a parser.
23:15:00 <Cale> neonfuz: At the point when GHC switched to having a parallel GC, they experimented with the option of making the GC concurrent as well, i.e. having each thread do minor garbage collections separately -- it didn't turn out to be beneficial, so they didn't go with that approach
23:15:05 <geekosaur> ...although as a parser it's horribly slow
23:15:51 <glguy> if you want to see Read grind to a halt throw in some infix data conductors
23:16:02 <glguy> constructors
23:16:23 <Cale> neonfuz: However, if you're interested in it, you might be able to resuscitate that ability somehow. Talk to Simon Marlow perhaps (JaffaCake on IRC, he's often in #ghc).
23:25:33 <neonfuz> Cale: alright, thanks for the info. I'm mostly asking because I'm interested in using haskell for game development, but I'm afraid a world stopping GC would be bad because it would cause frame stutering
23:25:41 <neonfuz> for the same reason that java isn't amazing for games
23:27:04 <geekosaur> I believe ghc's gc only stops the world very briefly
23:27:40 <geekosaur> at least in parallel mode, if I understood the code correctly
23:28:38 * hackagebot mios 1.4.0 - A Minisat-based SAT solver in Haskell  https://hackage.haskell.org/package/mios-1.4.0 (shnarazk)
23:29:07 <dmj`> neonfuz: use Weak References, GC doesn't follow them
23:29:09 <Cale> neonfuz: Back when I was working on a game project in 2011-2012 or so, on desktop machines the GC wasn't too noticeable -- obviously it depends on how much work you're giving to the garbage collector to do
23:29:17 <MarcelineVQ> GC being a problem is more of an issue on consoles than pc but the solution is the same, do less of the things that create garbage
23:30:04 <MarcelineVQ> typically this involves manual memory management though, like preallocating something large to work from so I'm not sure how that translates for haskell
23:31:41 <Cale> neonfuz: It was quite noticeable on the older iPhones available at the time (minor GCs were pretty much fine, major GCs which occurred about every 5 minutes would be about 300ms), so our plan there was to have a very simple C++ program that drew stuff to the screen as indicated by the Haskell program sitting on top of it, and it could continue playing animations through the delay to smooth over the gap and make it not 
23:31:42 <Cale> so noticeable.
23:32:36 <Cale> (A 300ms input delay that happens once every 5 minutes is not nearly so noticeable as a 300ms frame delay)
23:32:55 <neonfuz> yeah
23:33:18 <neonfuz> I guess I'll do that approach (c/c++ rendering program with haskell backend)
23:33:31 <Cale> I have no idea if that kind of thing would be necessary on modern phones though
23:33:41 <neonfuz> yeah
23:33:47 <neonfuz> I'll see how bad it is
23:36:48 <ent> is it possible to force gc?
23:37:30 <Cale> yeah, System.Mem.performGC
23:37:36 <Cale> https://hackage.haskell.org/package/base-4.9.0.0/docs/System-Mem.html
23:37:48 <Cale> There's some other relevant stuff in there
23:37:50 <geekosaur> I don;t think you can force minor vs. major though
23:37:58 <Cale> You can.
23:38:14 <ent> cool
23:38:21 <Cale> performMajorGC and performMinorGC
23:39:59 <Cooler> shouldn't it be Real a => Fractional a?
23:40:06 <Cooler> instead of Num a
23:41:48 <Rarrikins> Reals aren't necessarily fractional.
23:42:01 <Cale> Fractional has division in it. You want to be able to divide complex numbers
23:42:37 <Forlorn> How may I perform an operation between every adjacent "*" in the list and get its product? ["123", "*", "453", "+", "43", "*", "23"]
23:43:32 <liste> Forlorn: sounds like a job for pattern matching
23:44:25 <Cooler> Cale, so is there another typeclass Rational?
23:44:53 <Cale> hm?
23:45:11 <Cooler> Real a => Rational a?
23:45:28 <liste> > let f :: [String] -> Int; f ("+":x:xs) = (read x) + f xs; f [] = 0; in f ["+", "12", "+", "72"]
23:45:31 <lambdabot>  84
23:45:32 <geekosaur> Rational is a type alias (for Ratio Integer), not a class
23:45:42 <Cale> Real is perhaps misnamed -- if you were to rename it, it might be better off being called Rational (apart from the fact that we'd perhaps like to use that for the Rational type)
23:45:59 <Cale> The method that the Real typeclass gives you is
23:46:02 <Cale> :t fromRational
23:46:04 <lambdabot> Fractional a => Rational -> a
23:46:07 <Cale> oh, oops
23:46:11 <Cale> :t toRational
23:46:12 <Cale> yeah
23:46:12 <lambdabot> Real a => a -> Rational
23:46:13 <Cale> heh
23:46:33 <Cale> fromRational can be accomplished using division from Fractional, as well as fromInteger from Num
23:46:35 <Forlorn> liste, thanks for your insight!
23:47:04 <liste> Forlorn: yw (:
23:47:13 <Cale> toRational is a way to insist that there's a way to regard the elements of your numeric type as rational numbers, which sadly isn't going to be the case for computable real types.
23:47:18 <Cooler> so there are no irrationals then?
23:47:37 <Cale> But the intention is "real" in the sense of "not complex"
23:48:18 <Cale> toRational might not make sense for the computable real sqrt 2, but it makes even less sense for sqrt (-1)
23:49:02 <Cale> and most of the fractional number types people typically use are floating point or fixed point and can provide rational representations.
23:49:40 <Cale> (if they're representations of real numbers at all)
23:50:25 <Cale> So that's the reason for the somewhat awkward name for the Real type class. It's a little unfortunate, but well, we're somewhat stuck with it.
23:51:38 <Cale> It's common for computable real libraries to provide an instance of Real anyway, and just approximate the values to some arbitrary extent, which will be good enough if you want to use realToFrac to convert them to Float or Double or something.
