00:00:27 <parsnip> Cooler: only rarely? 
00:00:34 <Cooler> no
00:00:47 <parsnip> @src Functor
00:00:47 <lambdabot> class Functor f where
00:00:47 <lambdabot>     fmap :: (a -> b) -> f a -> f b
00:00:52 <Cooler> why does it matter if its rarely or not?
00:01:00 <Cale> Cooler: Note that there's an important difference between the way that Comparable<T> works in Java and the way that Ord works in Haskell
00:01:05 <parsnip> Cooler: exception makes the rule ;)
00:01:23 <Cooler> Eq and Ord both give lots of default methods
00:02:31 <parsnip> oh right, but those are usually secondary, but still conceptually we are tasked to define some initial. 
00:02:34 <Cale> With Java interfaces, it's awkward to express the notion that the two arguments to the comparison must have the same type.
00:03:11 <dysfun> Cale: have you seen the scala answer to doing that? it's terrifying
00:03:17 <Cooler> parsnip, which is the same thing with interfaces
00:03:34 <parsnip> Cooler: okay, i concede there :)
00:03:42 <Cale> dysfun: No, have a link?
00:04:40 <Cale> Another major difference is that type classes can express not only predicates on types, but relations between types
00:04:47 <Maxdamantus> The way to model classes/instances in Java is to have singleton (or .. static-ish) implementations (instances) of interfaces (classes).
00:04:54 <Cooler> Cale, its not a perfect analogy
00:05:08 <Maxdamantus> but you can't represent Functor/Monad like that due to a lack of higher-kinded polymorphism.
00:05:16 <Cale> (via multiparameter type classes and associated type synonyms)
00:05:28 <Cooler> but comparing type classes to java interfaces and types to classes makes a lot more sense that comapring them to classes and objects
00:05:29 <Cale> Oh, and then higher kinded polymorphism, yeah :)
00:05:34 <nshepperd> OOP interfaces are usually conceived of as expressing facts about values rather than types
00:05:42 <Cale> But yeah, generally, they're in a similar space as interfaces
00:05:45 <liste> Cooler: that's true, for sure
00:05:45 <Maxdamantus> public interface Num<T> { public T plus(T a, T b); public T minus(T a, T b); .. }
00:05:48 <Cooler> comparing*
00:06:09 <Cale> nshepperd: Yeah, that's an interesting point
00:06:40 <nshepperd> if you receive a Iterable<Foo> in a function, all you know is that that value is an 'instance of' Iterable<Foo>
00:06:48 <Maxdamantus> public static final Num<Integer> NumInteger = new Num<Integer>(){ public Integer plus(Integer a, Integer b){ return a + b; } .. }
00:07:01 <nshepperd> you don't really know anything about its type
00:07:16 <Cooler> nshepperd, no, all you know is that whichever type that value is, that TYPE is iterable
00:08:18 <dysfun> Cale: http://www.scalaformachinelearning.com/2014/09/mixin-constraint-on-self-typed-method.html
00:08:57 <dysfun> actually no, that isn't quite it
00:09:17 <nshepperd> Cooler: if you like, but the only useful consequence of that is that the value is Iterable
00:09:27 <Maxdamantus> Hmm .. in https://en.wikipedia.org/wiki/Software_transactional_memory , where do statements like "they cannot perform any operation that cannot be undone, including most I/O." .. "In Haskell, this limitation is enforced at compile time by the type system." come from?
00:09:48 * Maxdamantus will probably fix it.
00:10:00 <Maxdamantus> The limitation comes from Haskell's purity, not the type system -_-
00:10:02 <Cale> Maxdamantus: There's a type STM a of STM transactions
00:10:12 <nshepperd> in terms of implementation it just means you can look into the vtable of that *value* for the Iterable methods and you'll find something
00:10:15 <cocreature> Maxdamantus: the type system is what forbids you to perform IO in STM
00:10:22 <Cale> and you turn them into IO actions with atomically :: STM a -> IO a
00:10:39 <Cale> which executes the transaction (as if atomically with respect to the rest of the system)
00:10:45 <Maxdamantus> cocreature: so what would it look like to do IO "in STM" if it weren't for the type system?
00:11:14 <Cale> You can't execute IO actions in the middle of an STM action, because there's no function IO a -> STM a handy
00:11:17 <Maxdamantus> What prevents you from doing IO is the fact that you only create one IO operation.
00:11:20 <Maxdamantus> and that is `main`p.
00:11:24 <mauke> Maxdamantus: do { putStr "hello world\n"; retry }
00:11:42 <Cale> If STM were an instance of MonadIO, you could perhaps liftIO things into it
00:11:48 <Maxdamantus> mauke: what do you pass that to?
00:12:02 <Cale> but that would defeat the purpose of having the STM monad be separate from IO
00:12:03 <mauke> main = do { putStr "hello world\n"; retry }
00:12:08 <mauke> maybe with an 'atomically' in there
00:12:09 <cocreature> Maxdamantus: you can’t pass it to anything because it doesn’t typecheck
00:12:25 <Maxdamantus> mauke: the thing to compare it to would be `atomically (putStr "hello world")`
00:12:32 <Maxdamantus> but that has nothing to do with the type system.
00:12:43 <mauke> eh?
00:12:47 <cocreature> if something doesn’t typecheck, it seems related to the type system
00:12:51 <Cale> Maxdamantus: Well, it's just that STM and IO are different types
00:13:04 <Cale> So you can't execute IO actions in the middle of an STM action.
00:13:14 <Maxdamantus> mauke: `putStrLn "hello world"` doesn't print anything.
00:13:27 <Maxdamantus> mauke: it's just an operation that can be performed by the thing that performs IO operations.
00:13:27 <mauke> Maxdamantus: ok, so?
00:13:36 <Maxdamantus> mauke: `atomically` does not perform IO operations.
00:13:47 <Cale> Maxdamantus: right?
00:13:49 <Maxdamantus> `atomically (putStr "hello")` is as silly as `atomically 4`
00:13:56 <mauke> do you have a point?
00:14:10 <Maxdamantus> The point is that the restriction doesn't come from the type system.
00:14:20 <mauke> of course it does
00:14:21 <Maxdamantus> I can implement `putStr` and `atomically` in JavaScript or Java or whatever.
00:14:22 <Cale> :t atomically (putStr "hello")
00:14:25 <lambdabot> error:
00:14:26 <lambdabot>     Variable not in scope: atomically :: IO () -> t
00:14:33 <Maxdamantus> atomically *WILL NOT* run the IO operation there.
00:14:39 <mauke> why not?
00:14:46 <Maxdamantus> Because that's not what it does.
00:14:53 <Cale> Maxdamantus: Actually, if we were to unsafeCoerce it...
00:14:55 <mauke> ok, cool story?
00:15:25 <nshepperd> Maxdamantus: there's an unsafeIOToSTM function :: IO a -> STM a somewhere for getting around this restriction
00:15:38 <Maxdamantus> What? Is the implementation of `atomically` just `atomically = unsafeCoerce id`?
00:15:44 <nshepperd> it's just a safety measure enforced by making the types different
00:16:01 <Maxdamantus> IO operations and STM operations are different things.
00:16:09 <Cale> λ> atomically (unsafeCoerce (putStrLn "hello!"))
00:16:09 <Cale> hello!
00:16:13 <Cale> ^^ from ghci
00:16:15 <Maxdamantus> You can't have a single operation that handles both of them, even in a dynamically typed language.
00:16:18 <mauke> Maxdamantus: why?
00:16:49 <Cale> It's possible to unsafeCoerce an IO action to make it a functioning STM action.
00:16:54 <Axman6> some times, you just gotta print from an STM transaction to tell someone things went bad
00:16:55 <Cale> At least in GHC
00:17:11 <Cale> (of course, you should use unsafeIOToSTM instead)
00:17:32 <Cale> But that's just to show that it *is* the type system which is the only thing standing in the way
00:17:51 <Cale> Literally the only thing  unsafeCoerce :: a -> b  does is to bypass the type system
00:18:44 <Maxdamantus> > unsafeCoerce (newTVar 4 >>= readTVar)
00:18:45 <Maxdamantus> Segmentation fault
00:18:46 <lambdabot>  error:
00:18:46 <lambdabot>      Variable not in scope: unsafeCoerce :: m0 b0 -> terror:
00:18:46 <lambdabot>      Variable not in scope: newTVar :: Integer -> m0 a0error:
00:19:16 <Maxdamantus> The fact that it did something the other way round is just some coincidence of messing with undefined things.
00:19:17 <mauke> did you mean: atomically
00:19:21 <Maxdamantus> No.
00:19:26 <Maxdamantus> I wanted to run the STM using IO.
00:19:31 <mauke> why?
00:19:59 <mauke> I mean, you're using unsafeCoerce at type STM a -> IO ()
00:20:08 <mauke> that's almost the type of atomically
00:20:23 <Maxdamantus> Yes, which is as silly as `Integer -> STM a`
00:20:28 <Maxdamantus> 19:13:27 < Maxdamantus> `atomically (putStr "hello")` is as silly as `atomically 4`
00:20:47 <Maxdamantus> They're just things that don't make sense.
00:21:07 <Maxdamantus> If you want to run an STM, you have to pass it to something that turns it into an IO operation.
00:21:24 * mauke shrugs
00:21:24 <Maxdamantus> then you have something run that.
00:21:31 <Maxdamantus> It doesn't have much to do with the type system.
00:21:36 <Cale> Maxdamantus: Did you see my example?
00:21:43 <mauke> it has everything to do with the type system
00:21:52 <cocreature> Maxdamantus: atomically (unsafeCoerce $ putStr "hello world") totally works
00:22:12 * Cale wonders if he's on Maxdamantus' ignore list or something.
00:22:32 <Maxdamantus> Cale: I read your comment. That's why I tried it the other way around, which segfaulted.
00:22:43 <nshepperd> er, well of course doing STM actions outside of an 'atomically' block would crash. 'atomically' does some important bookkeeping that you need
00:22:48 <Maxdamantus> Cale: so obviously `atomically` is not just `id` with some unsafeCoerce.
00:22:56 <cocreature> nobody claimed that it is
00:22:58 <mauke> Maxdamantus: no one claimed that
00:23:00 <mauke> except for you
00:23:05 <Maxdamantus> 19:15:47 < Cale> λ> atomically (unsafeCoerce (putStrLn "hello!"))
00:23:26 <Maxdamantus> What is he trying to demonstrate with that then?
00:23:31 <Maxdamantus> If not that STM == IO
00:23:46 <cocreature> Maxdamantus: that without a type system you can execute irreversible actions in STM
00:23:48 <Cale> Yeah, reading the TVar won't work out if the setup which gets done by atomically doesn't happen.
00:23:51 <Maxdamantus> (that STM == IO but the type system makes things safe)
00:24:01 <Cale> You can create the TVar using unsafeCoerce
00:24:25 <Cale> But readTVar relies on some stuff to have taken place which didn't happen because you unsafeCoerced it
00:24:39 <mauke> Maxdamantus: that you can perform I/O operations in STM if you bypass the type system
00:24:47 <Maxdamantus> Yes, this is again like trying to pass in an Integer when something expects a String or an STM a
00:24:52 <nshepperd> 'STM == IO' doesn't mean that you can read and write to unprepared memory without things crashing
00:25:02 <Maxdamantus> It's just passing in the wrong type, which is something you're not meant to do regardless of a type system.
00:25:22 <Cale> Maxdamantus: It's still actually executing the readTVar as if it were any other IO action there -- it's just that it happens to be an IO action that segfaults.
00:25:23 <cocreature> so your argument is that you should respect non existing type systems so it’s unrelated to the type system?
00:25:31 <mauke> you're thinking in types still
00:25:55 <Cale> Maxdamantus: Because it's not safe to execute STM actions just wherever you like
00:26:52 <Maxdamantus> Here's an implementation of `putStr` in JavaScript: function putStr(str){ return { runIO: function(cb){ print(str); cb(undefined); } }; }
00:27:19 <Cale> Prelude Unsafe.Coerce Control.Concurrent.STM> (unsafeCoerce atomically :: IO Integer -> IO Integer) (unsafeCoerce (newTVar 4 >>= readTVar))
00:27:19 <Cale> 4
00:27:23 <Cale> See?
00:27:44 <Cale> You just need to have the stuff that atomically does happen :)
00:27:45 <Maxdamantus> Here's an implementation of `readTVar` in JavaScript: function readTVar(tv){ return { runSTM: function(tx){ var state = tv.get(); tx.reads.add([tv, state]); return state.content; }; } }
00:28:13 <Maxdamantus> Nothing interesting is going to happen if you call `atomically(putStr("hello"));`
00:28:36 <Maxdamantus> It's not like JavaScript's type system is preventing `putStr` from printing anything there.
00:28:40 <Cale> Maxdamantus: Now, of course STM and IO might have totally different implementations which would mean that you'd be right.
00:28:45 <Maxdamantus> `atomically` just doesn't call the `runIO` method.
00:28:46 <mauke> Maxdamantus: how do you know?
00:28:47 <nshepperd> λ> atomically (unsafeCoerce ((unsafeCoerce (newTVar (4::Int)) :: IO (TVar Int)) >>= (unsafeCoerce readTVar :: TVar Int -> IO Int)) :: STM Int)
00:28:49 <nshepperd> 4
00:28:55 <cocreature> Maxdamantus: the fact that you can write a safe stm without a type system doesn’t mean that in haskell it’s not the type system making it safe
00:29:15 <Cale> But in GHC Haskell's case, it *really* is the case that only the type system is preventing you from treating STM actions as IO actions and vice versa
00:29:29 <Cale> Of course, if you don't apply atomically, you get a segfault.
00:29:52 <Maxdamantus> Cale: well, maybe if JavaScript had an `unsafeCoerce` it might happen to end up calling the `runIO` method in `atomically`.
00:30:31 <Maxdamantus> Pretty much all bets are off when you're talking about invoking things unsafely.
00:30:43 <Maxdamantus> Nasal demons etc
00:31:32 <Cale> Well, but if we're talking about obliterating the type system, basically if we want to understand what's going to happen, we need to go and look at the actual implementation.
00:31:58 <Cale> newtype STM a
00:31:58 <Cale>   = GHC.Conc.Sync.STM (GHC.Prim.State# GHC.Prim.RealWorld
00:31:58 <Cale>                        -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
00:31:58 <Cale>   	-- Defined in ‘GHC.Conc.Sync’
00:32:03 <Cale> newtype IO a
00:32:03 <Cale>   = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
00:32:03 <Cale>                   -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
00:32:03 <Cale>   	-- Defined in ‘GHC.Types’
00:32:17 <Cale> They're very similar as soon as we drop down one level of abstraction :)
00:32:36 <Cale> They end up being identical structurally in memory, which is why the unsafeCoerce works
00:33:31 <Maxdamantus> This is all fairly irrelevant.
00:33:42 <Maxdamantus> The point is that the safety of STM doesn't come from the type system.
00:33:54 <Cale> But in this case, it does!
00:33:58 <Maxdamantus> Those are still different types, which you can express in lots of type systems.
00:33:59 <mauke> you keep repeating that, but I don't believe you
00:34:36 <Maxdamantus> public class STM<A> { private final GHC.Prim.State<GHC.Prim.RealWorld, ..>; .. }
00:34:39 <Maxdamantus> public class IO<A> { private final GHC.Prim.State<GHC.Prim.RealWorld, ..>; .. }
00:34:43 <nshepperd> what part of being 'different types' doesn't come from the type system?
00:34:45 <Cale> If we switch the type system off, we can execute IO actions in the middle of STM transactions and they'll be carried out faithfully (as many times as the transaction attempts to commit)
00:34:46 <Maxdamantus> This is nothing particular to Haskell.
00:35:29 <Cale> So literally the only thing standing in the way of I/O unsafety of STM transactions is the type system here.
00:35:48 <Maxdamantus> But it's not *Haskell's type system*
00:35:55 <Cale> It's GHC's type system
00:35:59 <nshepperd> I don't think anyone claimed that any super special features of haskell's type system are involved in preventing you from converting IO to STM
00:36:02 <Maxdamantus> You're just saying "you're not allowed to do it because it's not assembly"
00:36:08 <nshepperd> just the ordinary features
00:36:09 <Cale> hm?
00:36:19 <nshepperd> like having types at all
00:36:27 <Cale> I'm saying you're not allowed to do it because STM is a distinct type from IO
00:36:35 <Maxdamantus> nshepperd: that's what the article suggests.
00:36:44 <Maxdamantus> nshepperd: and it's what mauke and Cale seem to be defending.
00:36:49 <Cale> and that's literally the only reason in GHC's implementation that you're not allowed to do it
00:37:37 <Cale> GHC would support carrying out IO actions in the middle of running transactions otherwise (as I've demonstrated)
00:38:10 <nshepperd> except in that the only reason people would ever use a STM type is because haskell has do notation and monads and stuff like that that make this usable
00:38:22 <nshepperd> I suppose
00:39:42 <nshepperd> well and the IO type
00:39:59 <Cale> Maxdamantus: Note that the wikipedia article doesn't say "only in Haskell"
00:40:01 <Maxdamantus> You can't add 5.4 and 3 in Java and get 4617765877924338077. I wouldn't credit that to Java's type system.
00:40:19 <Maxdamantus> You can do that using assembly for some machines.
00:40:24 <Cale> In other languages, you could do a similar thing, representing IO actions and STM actions as values of different types.
00:40:25 <Maxdamantus> and probably unsafeCoerce sometimes in Haskell.
00:40:34 <Cooler> Maxdamantus, when you say Haskell's purity, isn't that purity implemented by the type system?
00:40:35 <Cale> However, I don't know of any which actually do that...
00:40:52 <Maxdamantus> Cooler: no. Haskell is pure because it doesn't have an mutation operators.
00:40:58 <Maxdamantus> Cooler: or objects that you could mutate.
00:41:10 <Cooler> yeah immutable types only
00:41:19 <Maxdamantus> Cooler: it doesn't have much to do with types.
00:41:29 <Maxdamantus> Cooler: there are dynamically typed languages that are also pure.
00:41:51 <Maxdamantus> Cooler: they're just pure because they also lack things like assignment operators and primitive functions with side effects.
00:41:52 <mauke> it all depends on your point of view
00:42:03 <nshepperd> Maxdamantus: I think you're just misunderstanding what is being claimed
00:42:12 <mauke> ghc's implementation is impure
00:42:23 <Maxdamantus> (Haskell also lacks those things .. when excluding unsafe* and the FFI)
00:42:37 <Maxdamantus> that's why it's a pure language.
00:42:45 <Maxdamantus> not because it has an advanced type system.
00:42:51 <Cale> Because of the way that GHC implements things, there are many places in which if you ask it to disregard the type system, you can cause impure things to happen during expression evaluation.
00:42:52 <nshepperd> haskell could have implemented STM as a bunch of IO actions and then just trusted the user to use them safely
00:43:06 <nshepperd> that wouldn't have been very safe
00:43:38 <Cale> "Oops, you forgot to use atomically -> segfault" :)
00:44:01 <nshepperd> instead they made STM into a separate type from IO
00:44:08 <nshepperd> now you don't need to trust the user
00:44:27 <Maxdamantus> The segmentation fault is because Haskell isn't a safe language when you use unsafe*
00:44:45 <nshepperd> no
00:44:47 <Maxdamantus> You can induce segmentation faults in Java using sun.misc.Unsafe
00:44:48 <Cale> Yeah, but literally the only thing unsafeCoerce does is to bypass the type system
00:44:58 <nshepperd> Maxdamantus: no
00:45:12 <Maxdamantus> nshepperd: no what? Yo ucan't?
00:45:30 <Maxdamantus> They might be caught by the JVM since it usually catches segfaults to implement null checks.
00:45:32 <nshepperd> Maxdamantus: it's because newTVar uses areas of memory that are uninitialized before atomically is called
00:45:34 <Cale> The segmentation fault is because transaction log initialisation required for readTVar to work didn't take place, because you didn't apply atomically
00:46:11 <cocreature> I think the missunderstanding here comes from the difference between “the haskell type system has a specific property that other type systems lack that helps with stm” vs “in haskell the only thing making stm safe is that the type system prevents you from embedding io inside stm”
00:46:45 <Cale> nshepperd: newTVar is actually fine, interestingly enough
00:46:47 <Maxdamantus> Cale: yeah, and the reason you get a segfault when reading `foo[400000000]` after declaring `int foo[40]` in C is because you didn't make your array big enough.
00:47:07 <Cale> Maxdamantus: sure...
00:47:22 <Maxdamantus> This is all just reasoning about undefined behaviour.
00:47:27 <mauke> no
00:47:48 <Cale> This is reasoning about the real-world implementation of GHC
00:47:53 <Maxdamantus> You can come up with implementation-specific explanations of why you get certain behaviours when doing undefined things.
00:48:07 <mauke> yes
00:49:16 <Cale> If you want to talk about whether or not it's the type system preventing IO actions from being treated as STM actions, then you have no choice but to talk about the lower level implementation.
00:49:28 <nshepperd> undefined? there's nothing undefined about implementing STM as ordinary IO actions
00:49:49 <Cale> Because if you don't turn the type system off, it's certainly going to prevent you from writing the program which does IO in the middle of an STM transaction.
00:49:50 <nshepperd> it's a perfectly feasible API
00:49:56 <Maxdamantus> nshepperd: there's something undefined about using `unsafeCoerce` to turn an `STM a` into an `IO a`.
00:50:00 <nshepperd> just an unsafe one
00:50:00 <mauke> Maxdamantus: what do you mean by "undefined behavior" outside of the C standard?
00:50:04 <Cale> and turning the type system off will get you implementation-specific behaviour
00:50:18 <mauke> because I don't think the Haskell report defines "undefined behavior"
00:50:26 <Maxdamantus> mauke: doing things that are not offered by the interface.
00:50:31 <mauke> what
00:50:36 <Maxdamantus> and not restricted by the type system.
00:50:53 <Cale> Maxdamantus: You mean things that the type system would normally prevent you from doing?
00:51:06 <Maxdamantus> mauke: you can do `foo[40000000]` if you really want, and it might even do something you expect it to.
00:51:13 <Maxdamantus> mauke: but that's reasoning about some particular implementation.
00:51:21 <nshepperd> Maxdamantus: you don't need to use unsafeCoerce. the API could have been implemented with s/STM/IO/g, and everthing would have compiled and worked
00:51:40 <Maxdamantus> nshepperd: you mean `type STM = IO`?
00:51:45 <Cale> Maxdamantus: yes
00:52:04 <Maxdamantus> That's a completely different interface.
00:52:19 <nshepperd> ....
00:52:26 <Cale> Nah, it would be the same, except every occurrence of STM would be replaced by IO
00:52:36 <Cale> and existing Haskell programs would work the same way
00:52:42 <Cale> it would just be unsafe
00:53:24 <Cale> (I suppose this is disregarding type classes which one might use to distinguish STM and IO...)
00:53:55 <meditans> is there a commonly used way to upload the documentation of a package on hackage, if I'm using stack?
00:53:55 <mauke> Maxdamantus: foo[40000000] applies foo to a list containing one number
00:54:19 <Cale> But physically, at runtime, in GHC Haskell, STM actions *are* IO actions -- it's only the type system which is preventing you from seeing that.
00:55:02 <nshepperd> Maxdamantus: the *whole point* is that the decision to use an interface with STM being separate from IO was a *conscious* decision to prevent the unsafety associated with the 'type STM = IO' interface
00:55:13 <Maxdamantus> Cale: no. It's the type system that allowed them to be compiled to the same representation.
00:55:23 <nshepperd> Maxdamantus: by using the type system to separate STM actions from all other IO actions
00:55:54 <Maxdamantus> Cale: if it weren't statically typed, it might have to add tags when you write `newtype STM a = ..`
00:56:21 <Cale> Maxdamantus: If you wanted to do additional runtime checks to make certain that things were sane.
00:56:34 <Cale> Such checks don't happen in Haskell.
00:57:25 <Maxdamantus> GHC also seems to implement IO operations as functions that could be invoked probably through unsafeCoerce then normal function application.
00:57:40 <Cale> But it's pretty safe to say that STM *ought* to be implementable as IO, since the execution of IO actions can already do basically anything.
00:57:50 <Cale> yes
00:58:05 <Maxdamantus> It seems very weird to say that Haskell's IO is pure because the type system prevents you from unsafely coercing wrapped functions into functions that you can directly invoke.
00:58:38 <jle`> when people say that Haskell's IO is pure, they are probably talking about IO as an abstract data type
00:58:39 <nshepperd> who's talking about purity?
00:58:40 <Cale> The type system has a lot to do with Haskell's purity
00:58:45 <jle`> and the semantic interface it exports
00:58:53 <Cale> But yeah, it's sort of besides the point here
00:59:20 <nshepperd> sure, haskell's IO is *safe* because the type system prevents you from applying IO actions as functions
00:59:33 <Maxdamantus> jle`: well, here I mean it's pure in the sense that it doesn't involve calling impure "functions".
00:59:41 <Maxdamantus> jle`: at least, until you look at the implementation.
00:59:50 <Cale> With the abstractions in place that the type system is enforcing, you're free to imagine that IO is implemented in some other way, perhaps as some sort of free monad.
00:59:54 <nshepperd> it'd be pretty damn unsafe you could accidentally apply IO actions as functions willy nilly
01:00:19 <jle`> Maxdamantus: of course, there's pretty much 0 parts of an abstraction that apply when you look at the implementation
01:00:24 <jle`> that's the point of an abstraction :)
01:00:58 <Cale> But if you turn the type system off, all of a sudden you can ask lots of questions which otherwise you wouldn't be able to ask.
01:01:05 <jle`> the neat thing is that you can talk about properties of the abstraction, and reason with them
01:01:52 <nshepperd> like "why did my program suddenly make a thousand copies of the universe? oh, I accidentally used 'replicate 1000
01:01:52 <pavonia> Why does the encoding package define characters 1-31 to their ASCII representations instead of the correct Unicode codepoint according to https://en.wikipedia.org/wiki/Code_page_437?
01:01:59 <nshepperd> ' as an IO action" :p
01:02:35 <nshepperd> noo, damn apostrophe ruining my jokes :(
01:06:15 <cocreature> nshepperd: and that damn type system is preventing you from rolling back your mistake and redoing it
01:06:16 <Cale> pavonia: "Although the ROM provides a graphic for all 256 different possible 8-bit codes, some APIs will not print some code points, in particular the range 1-31 and the code at 127."
01:07:45 <Cale> pavonia: Of course, if it treated 10 as that white circle on a black background, you might be frustrated by the inability to have newlines...
01:08:55 <pavonia> Maybe I'm misunderstanding but isn't the codepage supposed to map to glyphs?
01:23:52 <Cooler> where can you get the source for monads?
01:23:59 <Cooler> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State.html
01:24:06 <Cooler> that doesn't seem to have anything
01:27:46 <mauke> Cooler: for which monads?
01:28:05 <Cooler> state monad
01:28:24 <fizruk> https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Class.html#MonadState
01:29:41 <Cooler> thanks
01:29:50 <mauke> Cooler: https://hackage.haskell.org/package/transformers-0.4.2.0/docs/src/Control-Monad-Trans-State-Lazy.html#line-192
01:29:53 <fizruk> Cooler: here you can see "Source" links to the right: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#t:MonadState
01:30:29 <fizruk> Cooler: I've link you to the class definition source, but there's also a bunch of instances
01:30:44 <fizruk> Cooler: there's a "Source" link for each instance, follow any
01:33:41 <Cooler> why is called lazy?
01:33:45 <Cooler> it*
01:34:34 <mauke> https://hackage.haskell.org/package/transformers-0.4.2.0/docs/src/Control-Monad-Trans-State-Strict.html#line-189
01:49:41 <jle`> Cooler: mtl doesn't actually implement any instances of its typeclasses, it's basically a package full of orphan instances
01:49:51 <jle`> common monad transformers are implemented in the 'transformers' package
01:51:29 <jle`> er, i guess they aren't orphan instances because the typeclasses are defined in mtl.  i gues i mean that it's a package full of typeclasses and instance definitions, but none of the actual types.
01:56:56 <Cooler> what do you mean no actual types? jle` ?
01:59:48 <fizruk> Cooler: e.g. StateT is defined in transformers, not mtl
02:00:05 <fizruk> Cooler: mtl only defines MonadState and instance MonadState s (StateT s)
02:00:17 <Cooler> do you usually use monad transformers or monads?
02:00:27 <Cooler> for example for random numbers
02:01:42 <{AS}> Hi, how do I install multiple Haskell versions?
02:02:32 <mauke> s/Haskell/ghc/
02:02:35 <Axman6> if you use stack, it's quite easy to switch between GHC versions
02:02:53 <{AS}> mauke: Yeah
02:03:00 <{AS}> Axman6: So it is a third party project
02:03:07 <Cooler> can someone explain whats going on here? class Monad m => MonadState s m | m -> s where
02:03:10 <{AS}> can I still use stack for third party projects?
02:03:31 <{AS}> Cooler: it states that MonadState s m requires m to be a Monad
02:03:36 <mauke> Cooler: it's defining a class called MonadState
02:03:41 <Axman6> I'm not sure I understand, that's what it's designed for, unless I'm misunderstanding
02:03:43 <{AS}> and that the second parameter determines the first one
02:03:46 <mauke> Cooler: MonadState has two parameters, s and m
02:03:50 <Cooler> i would have thought    instance Monad State a where
02:04:15 <{AS}> Cooler: MonadState is more general, since it is a class
02:04:21 <mauke> Cooler: that's what I linked you to
02:04:26 <mauke> Cooler: MonadState is a different class
02:04:32 <Axman6> Cooler: it basically says that for every m, there is only one instance allowed
02:05:21 <mauke> except mine says instance Monad (StateT s m) because State s is just an alias for StateT s Identity
02:06:09 <Cooler> so wheres the actual state monad?
02:06:21 <Cooler> the one used in random number generation examples
02:06:24 <Axman6> type State s a = StateT s Identity a
02:06:46 <Cooler> wheres the source for that?
02:06:55 <Axman6> @hoogle StateT
02:06:58 <lambdabot> Control.Monad.State.Lazy newtype StateT s (m :: * -> *) a
02:06:58 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
02:06:58 <lambdabot> Control.Monad.State.Strict newtype StateT s (m :: * -> *) a
02:08:13 <Cooler> is it this one https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Lazy.html?
02:10:14 <{AS}> Cooler: The nice thing about MonadState it also works with transformer stacks
02:10:53 <{AS}> so you can have MaybeT (StateT s IO) a and it still works with that :)
02:11:05 <jle`> it also works for types that aren't even related to StateT
02:11:14 <jle`> just as long as it offers the modify/get/put interface :)
02:13:11 <{AS}> jle`: Yeah 
02:13:57 <{AS}> so you can have one that work on newtype Unit1 a = Unit1
02:17:21 <Cooler> uh what?
02:17:54 <Cooler> which is the simple version of the state monad?
02:18:08 <Cooler> the one used in random number examples in the tutorials
02:18:17 <Cooler> wheres the source for that?
02:18:43 * hackagebot yaml 0.8.18.4 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18.4 (MichaelSnoyman)
02:18:52 <Elision> doesn't he go over that in lyah or something?
02:19:03 <Elision> http://learnyouahaskell.com/for-a-few-monads-more
02:19:32 <Elision> tldr; State a is approximately s -> (a, s)
02:20:11 <bollu> Elision: isn't State s a exactly the same as s -> (a, s)
02:20:46 <Cooler> no i am talking about the source, the actual implementation in ghc
02:21:00 <Elision> er, yeah, that, but there's some newtype stuff
02:21:39 <Elision> i am not an expert but i think that state is usually a synonym for statet identity so the source for statet is the source used
02:22:13 <Elision> but the article i linked has what it would look like for a bare lazy state monad, if that's something you're interested in
02:22:15 <Axman6> Cooler: https://www.stackage.org/haddock/lts-6.14/transformers-0.4.2.0/src/Control-Monad-Trans-State-Lazy.html#StateT
02:33:45 * hackagebot yesod-test 1.5.3 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.5.3 (MichaelSnoyman)
02:33:47 * hackagebot yesod-static 1.5.0.4 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.5.0.4 (MichaelSnoyman)
02:38:17 <lpaste> Insanity pasted “fibonacci” at http://lpaste.net/182876
02:38:27 <Insanity_> With that, I can generate fibonacci # x
02:38:35 <Insanity_> To create a List I would then use that function like
02:38:42 <Insanity_> [fib x | x <- [1..10]]
02:38:54 <Insanity_> But, how would I create that list *inside* the recursive function?
02:39:28 <lpaste> Insanity pasted “Simple list” at http://lpaste.net/182877
02:39:44 <Insanity_> For a simple list I can do something like that, which creates a list from n -> 0
02:42:48 <mniip> Insanity_, literally the same way?
02:43:40 <srhb> Insanity_: fib n = your current definition : fib (n+1) ?
02:43:45 * hackagebot yesod-auth 1.4.13.5 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.13.5 (MichaelSnoyman)
02:43:46 <srhb> Insanity_: What mniip said :)
02:43:48 <Cooler> Insanity_, isn't thatunsafe?
02:44:00 <Cooler> what if you do fib -1
02:44:18 <Insanity_> true Cooler
02:44:20 <Insanity_> mh
02:44:40 <Insanity_> I tried naively doing it the same way as with the first list, which resulted in some errors
02:44:51 <srhb> Insanity_: Which errors?
02:45:04 <Insanity_> Non type-variable argument in constraint Num[a]
02:45:05 <Cooler> change n == 0 = 0  to n <= 0 = 0
02:47:06 <jgzh6> Just wondering how I can fix this code (http://lpaste.net/182878) so that it doesn't crash and keep processing when an exception occurs
02:47:15 <Cooler> Insanity_, if you want to create a list of fibonacci numbers
02:47:47 <Cooler> generate the list as your computing the numbers, instead of recomputing everything each time
02:49:29 <Insanity_> I think I got it actually
02:49:42 <Insanity_> Maybe my approach was wrong. Instead of computing fib to #x
02:50:01 <Insanity_> I should create an "infinite amount" and use something like take to limit it?
02:50:19 <bollu> Cooler: are you showing him the slick recursive fib definition?
02:52:04 <ongy> bollu: "the"? there's only one?
02:52:17 <bollu> ongy: apologies, "one of" :)
02:53:49 <Cooler> you mean this one? fib = 1 : 1 : [a + b| (a, b) <- zip fib (tail fib)]
02:54:04 <Cooler> yeah and theres more than one
02:56:06 <bollu> Cooler: yes, that one
02:56:06 <mauke> that's a weird list comprehension
02:56:11 <mauke> you could just zipWith (+)
02:56:27 <Cooler> its from here https://www.youtube.com/watch?v=02_H3LjqMr8
02:56:29 <bollu> mauke: true, but sometimes list comprehensions are nicer to show
02:56:53 <bollu> I've been teaching haskell to linguists. It's.. interesting. They grasp categorical ideas quickly, but get confused at a list comprehension
02:57:50 <mniip> fib = 0 : scanl (+) 1 fib
02:58:46 * hackagebot lucid 2.9.6 - Clear to write, read and edit DSL for HTML  https://hackage.haskell.org/package/lucid-2.9.6 (ChrisDone)
02:58:50 <Insanity_> I have no idea how that works mniip but that is interesting
02:58:59 <bollu> :t scanl
02:59:00 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
02:59:06 <bollu> :t foldl
02:59:08 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
02:59:23 <bollu> ah, it's a fold with intermediate steps exposed?
02:59:36 <Cooler> well whichever way you do it, i was just saying you shouldn't generate the nth fib number and then compute n + 1th fib number and so on from the beginning each time
02:59:46 <bollu> > take 10 $ scanl (+) 1 [10..]
02:59:48 <lambdabot>  [1,11,22,34,47,61,76,92,109,127]
02:59:52 <mniip> > fix $ (0:) . scanl (+) 1
02:59:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:59:56 <Insanity_> Yeah Cooler, I understood why you said that, thanks ;)
03:00:17 <bollu> mniip: what does scanl do, exactly?
03:00:19 <Insanity_> I'm just playing with recursion in haskell
03:00:27 <bollu> accumulates the list with the fold operation right?
03:00:31 <bollu> while keeping intermediates?
03:00:34 <mniip> > scanl f (+) [x, y, z]
03:00:38 <mniip> err
03:00:38 <lambdabot>  error:
03:00:38 <lambdabot>      • No instance for (Typeable a0)
03:00:38 <lambdabot>          arising from a use of ‘show_M20310886868718914312321’
03:00:53 <mniip> crap
03:01:08 <bollu> > scanl (<>) "" ['a'..'z']
03:01:09 <mniip> > scanl f k [x, y, z] :: [Expr]
03:01:13 <lambdabot>  [k,f k x,f (f k x) y,f (f (f k x) y) z]
03:01:13 <lambdabot>  error:
03:01:13 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
03:01:13 <lambdabot>      • In the expression: 'a'
03:01:34 <bollu> right, gotcha
03:01:58 <bollu> mniip: what the hell does fix $ do?
03:01:59 <mniip> > scanl (*) 1 [1..]
03:02:04 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
03:02:04 <bollu> that's very curious
03:02:15 <mniip> @src fix
03:02:15 <lambdabot> fix f = let x = f x in x
03:02:38 <bollu> mniip: yes, I know what fix does. but I'm used to seeing it be used Y combinator style (encode recursion)
03:02:43 <bollu> :t fix $
03:02:45 <lambdabot> error:
03:02:45 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:02:55 <bollu> :t fix ($)
03:02:56 <lambdabot> a -> b
03:03:03 <mniip> um
03:03:06 <mniip> that's what I did
03:03:17 <mniip> Y combinator
03:03:28 <Cooler> is lambdabot written in haskell?
03:03:34 <mniip> Cooler, mostly
03:03:44 <Cooler> nice
03:04:05 <bollu> mniip: can you break this down for me? fix $ (0:) . scanl (+) 1
03:04:29 <mniip> fix $ (0:) . scanl (+) 1
03:04:41 <mniip> let x = ((0:) . scanl (+) 1) x in x
03:04:51 <mniip> let x = (0:) (scanl (+) 1) x) in x
03:05:02 <mniip> let x = 0 : scanl (+) 1 x in x
03:05:40 <bollu> mniip: slick
03:05:51 <bollu> mniip: how'd you come up with that?
03:06:12 <mniip> I don't think I did
03:06:24 <cocreature> it’s the standard code golfing solution to fibonacci numbers in haskell :)
03:06:40 <mniip> though I did come up with 'fix $ ([0,1] ++) . (zipWith (+) <*> zip)'
03:06:51 <mniip> errr
03:06:53 <mniip> though I did come up with 'fix $ ([0,1] ++) . (zipWith (+) <*> tail)'
03:07:04 <Aleksejs> Hi, can someone explain me why liftM on lists acts the same as map? I'm looking at the code liftM f  =  \a -> do { b <- a; return (f b) } and just can't get it
03:08:05 <mniip> Aleksejs, what part exactly do you not get?
03:08:08 <cocreature> Aleksejs: liftM is the same as fmap (or at least it should be and is for lists) and fmap is implemented as map for lists
03:09:19 <mniip> liftM f xs = xs >>= \b -> return (f b)
03:09:33 <mniip> = concatMap (\b -> return (f b)) xs
03:09:39 <ph88> how can i apply my wp function to the libraryClause function?  https://paste.fedoraproject.org/419740/81093214/
03:09:40 <Aleksejs> cocreature: there is instance Functor [] where fmap = map, so I can see why fmap acts like map. But in liftM I can see b <- a; return (f b). How exactly it knows that it should map through list? And what will be b here?
03:09:42 <mniip> = concatMap (\b -> [f b]) xs
03:09:58 <mniip> = map (\b -> f b) xs
03:09:59 <cocreature> Aleksejs: look at mniip explanation
03:09:59 <ph88> i want to chance the type that libraryClause returns so that it returns a tuple that also contains the source position
03:10:01 <mniip> = map f xs
03:10:03 <Aleksejs> ok
03:10:25 <Aleksejs> so is it defined as liftM f xs = xs >>= \b -> return (f b) somewhere?
03:10:26 <ph88> actually it would be better if each individual element has a source position
03:10:36 <mniip> Aleksejs, you just pasted it yourself
03:10:44 <mniip> the definition of liftM
03:11:21 <ph88> i expected this to work:  library <- wp <$> (text' "LIBRARY")
03:11:26 <Aleksejs> I got it now
03:11:28 <Aleksejs> thanks
03:11:48 <cocreature> ph88: why are you fmapping?
03:11:57 <cocreature> ph88: wp already takes a parser
03:12:29 <cocreature> ph88: btw is would be nice if you could use a pastebin that can highlight haskell code correctly such as http://lpaste.net/
03:12:33 <mniip> @undo liftM f  =  \a -> do { b <- a; return (f b) }
03:12:34 <lambdabot> liftM f = \ a -> a >>= \ b -> return (f b);
03:12:38 <mniip> Aleksejs, ^
03:13:02 <Aleksejs> mniip: yes, I got it, thanks!
03:13:56 <ph88> cocreature, so i use   library <- wp $ text' "LIBRARY"   instead ?
03:14:29 <cocreature> ph88: no that would only typecheck if the result of wp had type Parser a for some a
03:14:37 <cocreature> ph88: you can just use let result = wp $ …
03:14:45 <cocreature> ph88: whether that’s what you intend is a different question :)
03:14:58 <cocreature> ph88: maybe you want Parser (a, SourcePos)
03:15:09 <ph88> where ?
03:15:15 <cocreature> in the result type of wp
03:15:29 <ph88> the type signature of wp is not correct ?
03:15:58 <cocreature> ph88: it is a valid type signature. I just don’t think it is the type signature (and also not the implementation) you are looking for
03:15:59 <ph88> ok let's make a new wp function
03:16:30 <cocreature> ph88: you want to parse and record the source location at the same time, not return two parsers one for a and one for the source location
03:16:35 <ph88> wp :: Parser a -> Parser (a, SourcePos)
03:16:42 <ph88> ok ?
03:16:44 <cocreature> yep
03:17:06 <cocreature> now try finding an implementation for that (I’m happy to help you but trying it yourself first might be nice way to learn)
03:17:50 <ph88> yes i tried   wp Parser a = (a, getPosition)
03:18:02 <ph88> pattern match on data constructor not really working out it seems
03:18:02 <cocreature> ph88: that has type (Parser a, SourcePos)
03:18:18 <ph88> i thought i could just get the   a
03:18:26 <cocreature> ph88: you need fmap to implement it, but you can also use do notation if that is easier for you
03:18:49 <cocreature> actually you need Applicative, fmap is not enough
03:18:55 <cocreature> try it with do notation
03:19:12 <ph88> ok
03:19:17 <ph88> this is my next attempt by the way:  wp parser = fmap (\x -> (x, getPosition)) parser
03:19:26 <cocreature> start with "wp parserA = do a <- parserA; …"
03:20:49 <ph88> wp parser = do;  a <- parser;  return (a, getPosition)
03:21:34 <ph88> wp parser = parser >>= \x -> (x, getPosition)
03:21:42 <ph88> ok ?
03:22:04 <cocreature> ph88: not quite that will give you Parser (a, m SourcePos)
03:22:24 <cocreature> ph88: hint: Parser is an instance of the MonadParsec constraint you’re having on that m
03:22:47 <ph88> ah yes i need to get the position too in do block
03:22:48 <ph88> ok
03:23:40 <ph88> wp parser = do;  a <- parser;  pos <- getPosition;  return (a, pos)
03:23:59 <cocreature> exactly!
03:24:07 <ph88> :D
03:24:23 <ph88> and now i can do    library <- wp $ text' "LIBRARY"
03:24:40 <cocreature> yep
03:25:00 <ph88> ok i had to change my data type    data LibraryClause = LC (Text, SourcePos) LogicalNameList deriving (Eq, Show)
03:25:18 <ph88> i would like an alias for   (Text, SourcePos)  
03:25:42 <cocreature> then define one :)
03:25:49 <cocreature> LocatedText or something like that
03:26:35 <ph88> type TextP = (Text, Sourcepos)
03:28:08 <ph88> and here is the result of the program:  CC [CI_Library (LC ("LIBRARY",SourcePos {sourceName = "", sourceLine = Pos 1, sourceColumn = Pos 8}) (LNL [LN (IBasic "ieee")]))]
03:29:42 <mauke> > id@Int
03:29:45 <lambdabot>  error:
03:29:45 <lambdabot>      Pattern syntax in expression context: id@Int
03:29:45 <lambdabot>      Did you mean to enable TypeApplications?
03:30:05 <mauke> that error is a bit stupid
03:34:58 <ph88> how can i  change  some spaceChar  to  Text ?  i tried  T.pack $ some spaceChar   from https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Char.html#v:spaceChar
03:36:47 <Cooler> can someone explain this to me? https://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.State.Lazy.html#StateT
03:37:43 <Cooler> i was hoping for some simple source to understand how the state gets threaded through in random number generation
03:39:50 <mauke> ok, so the simplified version is: newtype State a = State{ runState :: s -> (a, s) }
03:39:56 <mauke> do you understand what this means?
03:42:15 <Cooler> mauke, i don't understand the {}
03:42:27 <Cooler> what do {} do in haskell?
03:42:56 <mniip> lots of things
03:43:07 <mniip> this is a record definition
03:43:28 <mniip> data Foo = Bar { x :: Int, y :: Float } is a record datatype
03:43:43 <mniip> same as 'data Foo = Bar Int Float' but you get two free accessor functions
03:43:52 <mniip> x :: Foo -> Int; x (Foo r _) = r
03:43:58 <mniip> err
03:44:01 <mniip> x :: Foo -> Int; x (Bar r _) = r
03:44:12 <mniip> y :: Foo -> Float; y (Bar _ r) = r
03:45:07 <Cooler> a record?
03:46:46 <Cooler> mniip, what exactly do you mean by a record
03:46:53 <Cooler> ?
03:46:59 <mniip> I literally just explained
03:47:10 <Cooler> that you get free getter functions?
03:47:50 <MarLinn> and free setter functions
03:47:56 <mniip> well you also have record constructors and substitution
03:48:07 <mniip> Bar{ x=3, y=1.5 }
03:48:42 <mniip> foo{x=5} is the same as (case foo of Bar x y -> Bar 5 y)
03:49:00 <Cooler> i don't understand, in data Foo = Bar { x :: Int, y :: Float }
03:49:03 <mauke> Cooler: it's like a tuple but the fields have names
03:49:09 <Cooler> are x and y in the global namespace now?
03:49:11 <mauke> yes
03:49:32 <mauke> and yes, this is (or can be) a problem
03:49:53 <Cooler> so in newtype State a = State{ runState :: s -> (a, s) } runState is now avaiable for use?
03:50:00 <mauke> yes
03:50:10 <Cooler> that does seem like a big problem
03:50:12 <mauke> runState :: State a -> (s -> (a, s))
03:50:19 <mauke> runState :: State a -> s -> (a, s)
03:50:37 <mauke> why?
03:51:11 <Cooler> because your polluting the global namespace with the names of member variables
03:51:31 <mauke> it's intentional here
03:51:38 <mauke> this is the normal runState function
03:52:32 <Cooler> ok so is the advantage that you don't have to implement these simple functions yourself?
03:52:47 <mauke> yes
03:52:51 <Cale> Cooler: You can think of it as shorthand for defining  newtype State a = State (s -> (a,s)); runState (State f) = f
03:52:53 <Cooler> because i don't think you would even want accessor functions
03:53:04 <Cooler> normally you just pattern match in functions
03:53:20 <Cale> It's literally just an accessor function, and you *do* want accessor functions quite often.
03:53:24 <Cooler> for example to get the value out of a tree
03:53:52 <Cooler> you just pattern match for Leaf a and Branch a
03:53:55 <Cooler> to get a
03:53:59 <Cale> Pattern matching is common too, but for things where you expect to introduce more fields in the future, it's often a bit nicer to use accessor functions.
03:54:12 <Cale> (and record syntax)
03:55:05 <Cale> For things like binary tree structures, that would be absurd. Moreover, you usually have multiple data constructors, which makes the accessors partial (which is ugly)
03:55:56 <Cooler> Cale so you  would only do this with newtype then? where theres only one constructor
03:55:58 <Cooler> ?
03:56:15 <Cale> Well, using it with newtype here is a mild abuse
03:56:30 <Cale> It just gets the extractor function defined a bit more quickly.
03:56:43 <Cale> runState :: State s a -> s -> (a,s)
03:57:47 <Cale> Of course, we chose the representation of the State monad to be such that this would be trivial to implement. If we'd chosen a different representation, runState would do more work.
03:58:18 <Cale> e.g. we might've had  data State s a = Return a | Get (s -> State s a) | Put s (State s a)
03:59:08 <bollu_> Cale: Let f(x + iy) =sqrt(|x||y|). Show that this satisfies CR equations at (0, 0) but is not differentiable there. any ideas? I'm not able to evaluate partial u / partial x
03:59:09 <Cale> The idea being that every State s a computation either simply returns some value, or it starts off by observing the state, and performing another State s a computation based on that, or it starts off by setting the state to some given value, and continuing with another State s a computation.
04:00:39 <Cooler> why do you call it a State s a computation?
04:01:03 <Cooler> i am thinking of something simple like random numbers
04:01:26 <Cooler> where its just a Int representing the current value of the prng
04:01:32 <Cale> Cooler: Well, the point of this is to somehow represent programs which may interact with some mutable state cell of type s, before producing a result of type a.
04:01:35 <Cooler> so State Int
04:02:16 <Cale> and runState will take such a program, and the initial state value of type s, and produce a pair of the final state and the result
04:02:19 <mauke> State Int a is not the state stored inside, it's the type of the whole computation
04:03:26 <Cale> :t do x <- get; put (x+1); return (show x) :: State Integer String
04:03:28 <lambdabot> StateT Integer Identity String
04:03:32 <Cooler> ok what i am trying to do is arrive at the more general version of the state monad from a simple version you might write to avoid the plumbing involved with random numbers
04:03:51 <Cooler> where you thread the prng value through each function
04:04:12 <Cale> So, let's take a quick look at how we might write runState for this other definition of the State monad, just to get a different approach
04:04:39 <Cale> runState :: State s a -> s -> (a,s)
04:04:50 <Cale> runState (Return v) s = (v,s)
04:05:07 <Cale> runState (Get f) s = runState (f s) s
04:05:24 <Cale> runState (Put s' x) s = runState x s'
04:05:58 <Cale> and then our lowercase primitives get and put can be implemented in terms of the constructors like this:
04:06:03 <Cale> get :: State s s
04:06:11 <Cale> get = Get (\s -> Return s)
04:06:16 <Cale> put :: s -> State s ()
04:06:25 <Cale> put s = Put s (Return ())
04:06:57 <ski> (.. and then `return' and `(>>=)')
04:07:01 <Cale> yeah
04:07:14 <Cale> return = Return, as the name suggests
04:07:50 <Cale> Return v >>= f = f v
04:08:07 <Cale> netsplit pls
04:08:25 <Cale> Return v >>= f = f v
04:08:51 <Cooler> the problem with this is its hard to tell whats going on
04:09:16 <ski> (`(>>=)' here is a bit similar to `(++)' for lists. it "appends" the "continuation"/remaining computation at the "end", by replacing the "innermost" `Return' with it. similar to how `(++)' replaces the `[]' in the first list with the second list)
04:09:57 <Cale> Maybe I should be writing more explanation of the steps of reasoning here
04:10:05 <Cooler> i am trying to invent monads from actual use case
04:10:25 <Cooler> for example like this http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
04:10:32 * ski disappears
04:10:38 <ph88> hey guys, how can i use my wp function so that basicIdentifier yields textP ? http://pastebin.com/2SYe3vqs  maybe i should use let .. in  ?
04:11:09 <Cooler> for random numbers what your trying to do is very clear
04:11:21 <Cooler> and the plumbing required
04:11:59 <Cale> Cooler: So, the idea here is that we want to be able to build up computations which have two basic operations: get :: State s s will have as its result the current state when run
04:12:14 <Cale> and put :: s -> State s ()  will set the current state to the given value when run
04:12:21 <Cale> (and have () as its result)
04:13:12 <Cale> and apart from that, we just want the thing to be a monad, so we can chain these operations together, one after the other, with the computation that follows potentially depending on the results of previous actions
04:13:50 <Cooler> Cale, why isn't  get :: () -> State a ?
04:13:57 <Cooler> like a IO action
04:14:01 <Cale> That would be a kind error
04:14:08 <Cale> State takes two type parameters
04:14:12 <Cooler> and put :: State a -> ()
04:14:22 <Cale> I don't understand
04:14:23 <Cooler> yes but why
04:14:41 <Cale> any function of type State a -> () is a constant function (or it doesn't terminate for some values)
04:14:48 <Cooler> why not    instance Monad State a wher3e
04:14:50 <Cooler> where*
04:14:56 <Cale> () has only one value
04:15:03 <Cale> So functions of type X -> () are boring
04:15:16 <Cale> and functions of type () -> X are basically the same thing as values of type X
04:15:37 <mniip> 1472814815 [14:13:35] <Cooler> like a IO action
04:15:42 <Cooler> ^
04:15:45 <Cale> ????
04:15:47 <mniip> even in IO get and put would have similar signatures
04:15:52 <Cooler> its not boring cause its updating the state
04:15:53 <mniip> get :: IO a, put :: a -> IO ()
04:15:54 <Cale> I don't get how it's like an IO action
04:16:05 <Cale> Cooler: What do you mean?
04:16:18 <Cooler> put :: State a -> ()
04:16:29 <Cale> That could only be a constant function
04:17:00 <Cooler> wait why have state
04:17:04 <Cale> Just from the type signature, we know that when we apply that function, it's either going to result in (), or it's going to loop forever
04:17:15 <Cale> and those are the only two possibilities
04:17:32 <mniip> non-terminate is a better description tbh
04:17:34 <Cooler> why not get :: () -> a and put :: a -> ()
04:17:37 <mniip> as it can be said to include errors
04:17:56 <mniip> Cooler, how would that even work
04:17:57 <Cale> Cooler: Well, if () -> a would do for get, then get :: a would surely work
04:18:05 <Cooler> i am thinking of get and put as getters and setters
04:18:11 <Cale> Cooler: But which value of type a should get be?
04:18:30 <mniip> but they are not
04:18:37 <Cale> Of course, also, if it's polymorphic, that would mean get can only be undefined
04:18:43 <Cooler> yes get :: a
04:18:49 <mniip> you are not modifying some structure with get/set
04:18:58 <Cooler> wait
04:19:02 <Cooler> get :: IO a
04:19:07 <Cooler> there
04:19:09 <Cale> The only value which inhabits every type is one which doesn't terminate
04:19:15 <Cale> Oh, that's entirely different
04:19:22 <mniip> you are taking a value from a chain of compositions, and putting a new one in
04:19:28 <Cooler> get :: IO a and put a -> IO ()
04:19:35 <Cooler> get :: IO a and put :: a -> IO ()
04:19:38 <Cale> So now get is a description of some things we can do to obtain a result of type a?
04:19:47 <Cooler> yes
04:20:06 <mniip> well now we aren't in State
04:20:07 <mniip> we are in IO
04:20:12 <Cooler> well
04:20:12 <mniip> the unescapable monad
04:20:22 <Cooler> state is io
04:20:25 <mniip> no
04:20:43 <mniip> 1) you can escape State
04:20:44 <Cooler> your storing the state somewhere and retrieving it
04:20:49 <mniip> 2) State doesn't use IO anywhere
04:20:50 <Cooler> in memory
04:20:50 <Cale> Cooler: How do you propose to write something analogous to runState?
04:20:58 <mniip> Cooler, that's exactly not how State works
04:21:04 <Cooler> why do you even need runState
04:21:12 <Cooler> you just need get and put
04:21:15 <Cale> Cooler: Let's consider a toy example problem
04:21:19 <Cooler> get and set to be more clear
04:21:27 <mniip> please be tree numbering
04:21:32 <Cale> Yes!
04:21:42 <mniip> !
04:21:47 <Cale> Okay, so consider the following tree type:
04:22:03 <Cale> data Tree a = Tip | Branch (Tree a) a (Tree a)
04:22:11 <Cooler> oh are you gonna explain how you thread the state through as a function parameter?
04:22:22 <Cale> Suppose we want to write the function  Tree a -> Tree Integer
04:22:23 <Cooler> instead of IO?
04:22:46 <Cale> which preserves the structure of the tree, but relabels it, from left to right, with values starting at 0
04:22:53 <Cale> e.g.
04:23:23 <Cale> relabel (Branch (Branch Tip "hello" Tip) "there" (Branch Tip "world" Tip))
04:23:37 <Cale> --> (Branch (Branch Tip 0 Tip) 1 (Branch Tip 2 Tip))
04:24:11 <Cale> If you try to write this in a direct recursive way by pattern matching, you'll immediately run into a problem: 
04:24:34 <Cale> relabel (Branch l x r) = Branch ...
04:24:44 <Cale> which label do we give to the root of the tree?
04:25:00 <Cale> Well, it's one more than the largest label we use in relabelling the left subtree
04:25:20 <Cale> But we don't want to relabel the left subtree, and then go searching through that for the largest label
04:25:52 <Cooler> Cale, stop
04:26:02 <Cale> So, the usual thing here, if you didn't have any extra machinery, is just to write a helper function, where we pass along the next available label, and return it along with our result
04:26:19 <Cale> okay
04:26:37 <Cooler> are you talking about a function relabel :: Tree a -> Int -> (Tree (a, Int), Int)
04:26:39 <Cooler> ?
04:26:47 <Cooler> Int being the label
04:26:49 <Cooler> the state
04:27:02 <Cale> I was thinking  relabel' :: Tree a -> Int -> (Tree Int, Int)
04:27:18 <ejbs> Is there a built in function for removing specific indices from a list?
04:27:20 <Cooler> sure that works too
04:27:27 <ejbs> like removeAt l 2
04:27:36 <Cale> ejbs: no
04:27:47 <Cooler> yes you can thread the state through as a extra function parameter and output instead of doing IO
04:27:59 <mniip> uncurry (++) . fmap (drop 1) . splitAt i
04:28:01 <Cale> ejbs: you can use take and drop, but really if you're using indices like that, probably a list isn't the greatest plan
04:28:19 <Cale> Or splitAt, yeah
04:28:24 <mniip> Cooler, "too"
04:28:24 <Cooler> Cale, but wth is runState? and what does it have to do with any of this
04:28:30 <Cooler> ?
04:28:33 <mniip> what is the other alternative
04:28:39 <ejbs> Cale: Yeah I know, crap complexity and stuff
04:28:42 <Cale> Cooler: Okay, so stare at the function which is the result of relabel' here
04:28:48 <Cale> Int -> (Tree Int, Int)
04:28:58 <Cale> That looks a whole lot like  State Int (Tree Int)
04:28:59 <Cooler> uh no
04:29:09 <ejbs> mniip: Thanks, I had something similar but wow! You guys are great at one liners
04:29:48 <Cooler> State is just  State a in my mind
04:30:03 <Cooler> State Int, State String, State Float
04:30:05 <Cale> Cooler: Then repair the definition in your mind :)
04:30:13 <Cooler> why
04:30:15 <Cale> Let's use the original one
04:30:30 <Cooler> i don't see any reason to have that more complex definitiojn
04:30:31 <Cale> Because I'm trying to teach you something, and it'll be unhelpful if you don't try to play along
04:30:33 <Cooler> definition*
04:30:38 <Cooler> ok fine
04:30:58 <Cale> newtype State s a = State { runState :: s -> (a, s) }
04:31:02 <Cale> this one
04:31:10 <mniip> the 'State' type represents a state-transforming function
04:31:13 <mniip> not a mutable variable
04:31:24 <mniip> fix your in-mind definition
04:31:47 <Cale> Yeah, a value of type State s a represents a computation which, given some initial state of type s, will produce a result of type a, along with a final state of type s.
04:31:57 <Cale> s is the type of states
04:32:16 <Cale> In our example application, it'll be Int
04:32:37 <Cale> So, let's write relabel' using State
04:32:38 <Cooler> you mean StateComputation then
04:32:53 <Cale> Yeah, except that's a really tediously long name
04:33:09 <Cooler> sigh
04:33:20 <Cooler> ok
04:33:49 <Cale> Now, first a short helper function
04:33:56 <Cale> fresh :: State Int Int
04:34:07 <Cale> fresh = do n <- get; put (n+1); return n
04:34:16 <Cale> (well, not a function :)
04:34:31 <Cale> This gets us the next available label
04:34:52 <Cale> and increments the state, so that each time we run it, it will produce a different number
04:35:05 <Cale> @let fresh = do n <- get; put (n+1); return n
04:35:09 <lambdabot>  Defined.
04:35:27 <Cale> > runState (do x <- fresh; y <- fresh; z <- fresh; return [x,y,z]) 0
04:35:30 <lambdabot>  ([0,1,2],3)
04:35:46 * mniip . o O ( relabel = runState 0 . traverse (const fresh) )
04:35:51 <Cale> lol
04:36:07 <Cale> That's a little too cute
04:36:13 <Cale> I just want to write the recursive one
04:36:27 <mniip> yeah not a good educational example
04:36:31 <mniip> hence . o O ()
04:36:34 <bartavelle> the traverse one was the one I used last week when I had to do that ;)
04:36:45 <Cale> relabel' Tip = return Tip -- if the tree is empty, we produce the computation which does nothing but to produce another empty Tree
04:37:55 <Cale> relabel' (Branch l x r) = ... -- if the tree is nonempty, consisting of some branch node
04:38:11 <Cale> relabel' (Branch l x r) = do l' <- relabel l  -- we first relabel the left subtree l getting some new relabelled tree l'
04:38:39 <Cale> relabel' (Branch l x r) = do l' <- relabel l; n <- fresh  -- only then do we get a new label for the root
04:38:57 <{AS}> ls
04:38:58 <{AS}> ls
04:39:09 <Cale> relabel' (Branch l x r) = do l' <- relabel' l; n <- fresh; r' <- relabel' r -- and then we relabel the right subtree, getting some result r'
04:39:35 <Cale> relabel' (Branch l x r) = do l' <- relabel' l; n <- fresh; r' <- relabel' r; return (Branch l' n r') -- and put everything together
04:39:48 <Cale> (sorry, I missed some primes in my earlier lines)
04:40:06 <Cale> Cooler: make sense?
04:40:11 <Cooler> yes
04:40:14 <Cale> So then we can write:
04:40:20 <Cale> relabel :: Tree a -> Tree Int
04:40:36 <Cale> relabel t = fst (runState (relabel' t) 0)
04:40:51 <Guest21837> Hello
04:40:54 <Cale> (or we could use evalState, which just takes the fst for us)
04:41:43 <Cale> It's this last step which is important -- you couldn't get a function Tree a -> Tree Int if somehow State were defined in terms of IO
04:42:16 <ongy> Cale: you scared them away
04:42:33 <Cale> ongy: heh
04:43:19 <Cale> (though perhaps you could get a function of type  Tree a -> IO (Tree Int), such a thing is very different in principle -- executing the resulting IO action might, e.g. do network access, or read the filesystem, we can't tell based on the type)
04:43:48 <Cale> Whereas a function Tree a -> Tree Int does nothing except to compute a tree of integers
04:43:49 * hackagebot http-client 0.5.3.1 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.3.1 (MichaelSnoyman)
04:45:19 <Cale> Of course, there's also a sense in which the function Tree a -> IO (Tree Int) is pure -- if you merely evaluate the result, no effects occur, and you are guaranteed the same IO action for the same value of type Tree a -- however, because IO is an abstract data type, you can't tell anything about which action it is, your only way forward is to execute it.
04:46:53 <Cooler> Cale, when you have State s a = s -> (s, a)
04:47:09 <Cooler> why do you even need runState?
04:47:18 <mniip> then State can't be a monad
04:47:22 <Cooler> s -> (s, a) is a function
04:47:23 <chomi> .
04:47:31 <Cooler> so just call it f
04:47:37 <Cooler> and give it a state to work on
04:47:47 <mniip> no monadic interface
04:47:57 <Cale> Cooler: The newtype wrapper there is just so we can define an instance of Monad
04:48:05 <Cale> and to sort of clarify what we're doing
04:48:13 <Cooler> relabel t = fst (runState (relabel' t) 0) becomes relabel t = fst (relabel' t 0)
04:48:21 <mniip> do l' <- relabel' l; n <- fresh; r' <- relabel' r; return (Branch l' n r')
04:48:23 <mniip> becomes
04:48:25 <mniip> a bunch of mess
04:48:38 <Cale> (>>=) :: (s -> (s,a)) -> (a -> s -> (s,b)) -> s -> (s,b)  would be fine, it's just... a little hard to mentally parse
04:49:02 <Cale> State s a -> (a -> State s b) -> State s b  is already enough of a mouthful :)
04:49:28 <Insanity_> Can someone explain something about Strings to me? 
04:49:28 <Insanity_> If I get it correctly, a String is just a List of characters. Hence something like this works: (show 123) !! 0 to get the "1". 
04:49:33 <Cooler> mniip, what do you mean it becomes a mess? it looks fine to me
04:49:37 <Insanity_> But a list operation on it is not working
04:49:43 <Cooler> do l' <- relabel' l; n <- fresh; r' <- relabel' r; return (Branch l' n r')
04:49:44 <mniip> Insanity_, which list opreation
04:49:50 <Insanity_> > intersect (show 123) [1..2]
04:49:52 <lambdabot>  error:
04:49:52 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
04:49:52 <lambdabot>      • In the expression: 1
04:49:56 <Insanity_> You type fast :P 
04:49:57 <Cale> Cooler: Well, you wouldn't be able to have the do-notation
04:50:06 <Insanity_> oh I'm an idiot
04:50:07 <{AS}> Insanity_: it should be '1' .. '2'
04:50:08 <bartavelle> Insanity_:
04:50:10 <Insanity_> yeah
04:50:11 <Cale> Cooler: Because you can't write a Monad instance for something which isn't a type constructor
04:50:14 <bartavelle> too fast :)
04:50:16 <Insanity_> As I send it I realised
04:50:22 <Insanity_> Thanks
04:50:22 <bartavelle> rubberducking ftw
04:50:27 <{AS}> :)
04:50:27 <Insanity_> indeed ^^
04:50:36 <Cale> Cooler: Like, there's no type level lambda for us to be able to write  instance Monad (\a -> s -> (s,a))
04:51:07 <mniip> (why, you might ask, because it makes typechecking undecidable)
04:51:09 <Cale> Cooler: So that's why we introduce the newtype wrapper
04:51:18 <Cooler> instance Monad State s a where
04:51:22 <Cale> yeah, and type classes wouldn't play nicely with it even if we had it
04:51:35 <Cale> it's   instance Monad (State s) where
04:51:38 <mniip> Cooler, that's ill-kinded
04:51:42 <Cale> State s is the monad for each type s
04:52:18 <Cale> Monads always have kind * -> *
04:52:28 <Cale> i.e. they take a type and produce another type
04:52:46 <Cooler> State s a is * -> *
04:52:54 <Cale> (which we usually think of as the type of results and the type of computations respectively)
04:52:59 <Cale> nope
04:53:01 <Cooler> s -> (s, a) is *->*
04:53:02 <Cale> :k State s a
04:53:04 <lambdabot> error: Not in scope: type variable ‘s’
04:53:04 <lambdabot> error: Not in scope: type variable ‘a’
04:53:06 <Cale> oops
04:53:10 <Cale> :k State Int String
04:53:11 <lambdabot> *
04:53:14 <Cale> :k State Int
04:53:16 <lambdabot> * -> *
04:53:23 <Cooler> oh
04:53:29 <Cooler> ok
04:53:30 <Cale> :k State
04:53:32 <lambdabot> * -> * -> *
04:53:33 <Cooler> yes
04:54:03 <Cale> Any type which actually has values will be kind *
04:54:21 <Cale> (ignoring some unboxed types with kinds like # and such)
04:54:32 <mniip> 1472817159 [14:52:39] <Cooler> s -> (s, a) is *->*
04:54:39 <mniip> :k forall s a. s -> (s, a)
04:54:40 <lambdabot> *
04:54:46 <Cooler> yeah i got it
04:55:08 <Cooler> so instance Monad State s where
04:55:15 <Cooler> whats the rest
04:55:16 <dabd> which algebraic structures would you use to model DAG-structured computation.  Say, a spreadsheet?
04:55:21 <Cale> The parens are required
04:55:29 <Cale> instance Monad (State s) where
04:55:34 <Cale>   return v = ...
04:55:37 <Cale> Let's do it :)
04:55:47 <Cale> Here, we want
04:55:48 <mniip> dabd, loeb/moeb :p
04:55:52 <Cale> return :: a -> State s a
04:55:58 <Cale> so we have v :: a
04:56:08 <Cale> and we want to produce something of type State s a
04:56:16 <Cale> So, we might as well use the data constructor
04:56:28 <Cale> return v = State ...
04:56:37 <Cale> and now we need to fill in a function of type  s -> (s,a)
04:56:45 <Cale> which might as well be a lambda
04:56:51 <Cale> return v = State (\s -> ...)
04:57:02 <Cale> and now we want to fill in a pair of type (s,a)
04:57:09 <Cale> we have s :: s, the initial state
04:57:27 <Cooler> wait a second
04:57:29 <Cale> and v :: a, the desired result of our computation which is supposed to "do nothing"
04:57:34 <Cooler> why not return v = State s v
04:57:45 <mniip> that's ill-typed
04:58:00 <Cale> Maybe we should name the data constructor differently from the type constructor to prevent confusion
04:58:13 <Cale> newtype State s a = S (s -> (s,a))
04:58:20 <Cale> Let's go with that
04:58:27 <Cale> return v = S (\s -> ...)
04:58:45 <Cooler> oh
04:58:47 <Cooler> ok
04:58:48 <Cale> S :: (s -> (s,a)) -> State s a
04:58:49 * hackagebot http-client 0.4.31.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.31.1 (MichaelSnoyman)
04:59:00 <ongy> newtype can have multiple type parameters?
04:59:06 <Cale> It can't.
04:59:10 <Cale> er, no it can
04:59:17 <Cale> Sorry, misread your question
04:59:32 <Cale> It can't have multiple *value* parameters to the data constructor
04:59:40 <Cale> It can have as many type parameters as you like
05:00:22 <Cooler> ok so return v = S (\s -> ...)
05:00:32 <Cale> right, so we have v :: a, and s :: s
05:00:33 <Cooler> ok so return v = S (\s -> (s, v))
05:00:37 <Cale> yep
05:00:45 <Cale> okay, so let's try (>>=)
05:00:56 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
05:01:07 <Cale> Before we do it, let's remind ourselves what it's supposed to do
05:01:27 <Cale> If we have some x :: State s a, and some f :: a -> State s b
05:01:39 <Cale> then x >>= f is supposed to be the computation which when we run it
05:01:47 <Cale> will first run x, getting some result v
05:02:05 <Cale> and then run (f v), and the result of that will be the result of the whole computation
05:02:24 <Cale> i.e. it's going to use f to decide what to do next, based on the result of running x
05:02:31 <Hi-Angel> Does stack support an alternative configuration syntax, i.e. besides Yaml?
05:02:53 <Cale> Okay, so
05:03:00 <Cale> x >>= f = ...
05:03:02 <Cale> We have
05:03:05 <Cale> x :: State s a
05:03:10 <Cale> f :: a -> State s b
05:03:17 <Cale> and our goal is  State s b
05:03:29 <Cale> Might as well use the constructor S:
05:03:33 <Cale> x >>= f = S ...
05:03:43 <Cale> now our goal is  s -> (s,b)
05:03:52 <Cale> might as well be a lambda, as before
05:03:58 <Cale> x >>= f = S (\s -> ...)
05:04:06 <Cale> now our goal is (s,b)
05:04:11 <Cale> i.e. the final state and result
05:04:15 <Cale> and we additionally have
05:04:16 <Cale> s :: s
05:04:18 <Cale> the initial state
05:04:35 <Cale> So, we said we wanted to first run x
05:05:00 <Cale> x >>= f = S (\s -> let (s',v) = runState x s ...)
05:05:16 <Cale> We're going to run it on the initial state s, getting some final state s', and result v
05:05:28 <Cale> So we have s' :: s
05:05:30 <Cale> and v :: a
05:05:38 <Cooler> stop wait
05:05:41 <Cale> okay
05:05:50 <Cooler> why runState x s and not x s
05:05:57 <Cale> x :: State s a
05:06:00 <Cooler> x >>= f = S (\s -> let (s',v) = x s ...)
05:06:05 <Cale> It's not a function type, can't apply it
05:06:16 <Cooler> x is a function
05:06:19 <Cale> nope
05:06:23 <Cooler> huh?
05:06:32 <int-index> `x` is a function wrapped in a newtype
05:06:34 <Cale> It's a value of type State s a
05:06:36 <Cooler> x :: s -> (s, a)
05:06:40 <Cooler> so give it s
05:06:43 <Cale> Where did I say that?
05:06:48 <Cale> I never wrote that
05:07:02 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
05:07:14 <Cale> So, the first argument to (>>=) has type State s a
05:07:17 <int-index> Cooler, there's a difference between `type` and `newtype`
05:07:20 <Cale> not s -> (s,a)
05:07:45 <Cooler> State s a is the same as a function s -> (s,a) write?
05:07:49 <Cooler> right*
05:07:56 <Cale> "the same as" in that there are functions in both directions
05:08:16 <Cale> S :: (s -> (s,a)) -> State s a  will turn a function (s -> (s,a)) into a value of type State s a
05:08:17 <int-index> At runtime it is the same, but the type checker treats them differently
05:08:24 <Insanity_> Sorry to keep bothering the chat with newbie questions, but what is a "Just"? I am trying to not only show the elements of a List, but also their index. So I have something akin to
05:08:34 <Cale> and  runState :: State s a -> (s -> (s,a))  will go back the other way
05:08:40 <Cale> and these functions are inverses of one another
05:08:43 <Insanity_> [ (x, elemIndex x xs) | x <- xs] 
05:08:46 <ongy> Insanity_: "Just" is one of the constructors of the Maybe type
05:08:47 <Insanity_> and xs is some List
05:08:52 <ongy> see Data.Maybe
05:09:00 <Cooler> Cale, ugh
05:09:00 <Insanity_> Mhm, so it is a constructor
05:09:06 <Insanity_> The output is (1, Just 0)
05:09:11 <Cooler> so runState is the inverse of S?
05:09:13 <Cale> Insanity_: A value of type Maybe a is either the value Nothing, or it is of the form Just x, where x :: a
05:09:38 <Cale> Cooler: yeah
05:09:38 <Cooler> i feel like i am losing my mind
05:09:55 <Insanity_> Thanks :-)
05:09:56 <bartavelle> Insanity_, also for your use case you'd probably want to use the "zip" function
05:10:14 <bartavelle> > zip "hello" [0..]
05:10:17 <lambdabot>  [('h',0),('e',1),('l',2),('l',3),('o',4)]
05:10:21 <Cooler> so State s a is not the same as a function that takes a state and does something with it and returns (s, a) ?
05:10:33 <Insanity_> I considered using zip, but wasn't sure if that was a performant way
05:10:34 <mstruebing> hey I read a file and print the contents to the terminal via putStr, but at the end of the file is always a %-sign, is there any way to get rid of this?
05:10:38 <Insanity_> the actual List is an infinite list of fib numbers
05:10:53 <bartavelle> Insanity_, it's much faster than using "elemIndex"
05:10:57 <int-index> Cooler, in the same sense that `newtype Length = L Int` is not the same as `Int`.
05:11:08 <Insanity_> I see, cheers
05:11:10 <ongy> mstruebing: I guess that's your shell inserting it, when there is no newline at the end of your output
05:11:29 <verement> mstruebing: try putStrLn
05:11:49 <mstruebing> okay thanks
05:11:49 <Insanity_> So, as it is slower, I'm assuming Haskell doesn't keep an index with the entries usually?
05:12:02 <Cale> Cooler: It's not *exactly* the same as that, it's just internally implemented as one of those
05:12:17 <int-index> Insanity_, in Haskell [] is a singly linked list (stack)
05:12:22 <Cooler> Cale, i was under the impression that we were just giving a name to the extra plumbing
05:12:46 <Cooler> the name "State s a" to a function  "s -> (s, a)"
05:12:54 <bartavelle> Insanity_, you can trust int-index to have an authoritative answer on how to find the integral index of something
05:13:07 <Cale> Cooler: The big idea here is that we're going to implement a bunch of operations and get to a point where we can forget about the data constructor S, because we'll have enough primitive values of type State s a and ways of combining them together that we won't have to reveal that they're internally implemented by functions
05:13:37 <Cale> Cooler: (and indeed, as I started to point out earlier, we could pick a different internal implementation -- functions are just convenient because they make implementing runState trivial)
05:13:48 <Insanity_> It's very fitting bartavelle ^^ thanks
05:14:29 <Insanity_> And the elemnIndex indeed has another problem
05:14:36 <Insanity_> my approach would fail if a list had duplicates
05:14:43 <bartavelle> yes
05:14:43 <Insanity_> would just return the first found entry I assume
05:14:51 <ongy> which the list of fibonacci numbers has
05:14:55 <Insanity_> indeed
05:14:55 <ongy> well, one pair of duplicates
05:14:56 <int-index> Cooler, "just giving a name" is what `type` does. `State` is defined as a `newtype`, which is more than a type synonym
05:14:58 <Insanity_> Yup
05:15:31 <Cooler> newtype is the same as type but with getter functions right?
05:15:40 <int-index> no.
05:16:01 <Cale> no, "type" just defines a new name for an existing type
05:16:19 <Cooler> ok why are we using newtype lets just say   type State s a = s -> (s, a)
05:16:20 <Cale> while "newtype" defines a genuinely separate data type, which won't be identified with the existing type
05:16:31 <Cale> Because then we can't write the Monad instance
05:16:52 <Cale> We need a genuine type constructor, not a synonym, in order to be able to write an instance of a type class
05:16:58 <bartavelle> Cooler, there is an example in base, type FilePath = String
05:17:14 <bartavelle> all functions that take a String work on FilePath, and vice versa, because they are the same thing
05:17:45 <Cale> Also, while in this case, it might be fine to expose the implementation, in general, perhaps we'd like to hide our internal implementation.
05:18:04 <Cale> We can simply not export our newtype's data constructor from the module in which we're defining this stuff
05:18:12 <Cale> (i.e. export State but not S)
05:18:24 <{AS}> So if someone releases a non-backward compatible package on cabal
05:18:30 <Cooler> so we are using newtype because we want >>= to do the plumbing for us and to get >>= we need to create a new type?
05:18:33 <Cale> and from outside the module, nobody will be able to tell that internally, values of type State s a are implemented using functions of type s -> (s,a)
05:18:47 <{AS}> the mainterns of dependent packages must ensure to properly bound their applications?
05:18:54 <Cale> To get the really proper (>>=) and not something which shadows the one in the Prelude, yeah.
05:19:21 <{AS}> Is there a reason why one can not specify that such package is backwards incompatible?
05:19:35 <Cooler> ok so S gives us that new type from s->(s,a)
05:19:43 <ongy> {AS}: usually that should be done by version scheme
05:19:56 <Cale> Yeah, S :: (s -> (s,a)) -> State s a
05:19:57 <{AS}> ongy: Yeah, so you have to properly bound your packages
05:19:59 <{AS}> right?
05:20:12 <bartavelle> {AS}, depends, classic debate ;)
05:20:12 <Cale> and  runState :: State s a -> s -> (s,a)
05:20:27 <Cooler> and runState gives us back the original function so we can run it
05:20:31 <Cale> yeah
05:20:34 <Cooler> ok
05:20:37 <Cooler> phew
05:20:46 <Cooler> where were we?
05:20:54 <bartavelle> {AS}, if you have the manpower to update your package often, it's much better to use tight upper bounds
05:20:57 <Cale> x >>= f = S (\s -> let (s',v) = runState x s ...)
05:20:57 <Cooler> x >>= f = 
05:21:09 <ongy> {AS}: I don't because I may not be concerned about some breaking change. But that means that I have to fix fast if things break for me. but that's my opinion and might be pretty bad
05:21:10 <Cale> If you want, we can go over the start of this again
05:21:41 <Cale> So we have x :: State s a, the computation we want to run first
05:22:13 <Cooler> no you can skip
05:22:14 <Cale> and we have f :: a -> State s b, the function which will produce the computation we want to run afterward, given the result of running x
05:22:18 <Cale> okay
05:22:31 <Cale> So, we run x on the initial state s
05:22:35 <Cale> and obtain some new state s'
05:22:40 <Cale> and result v
05:22:48 <Cale> and now we want to run (f v)
05:22:59 <Cale> and we're going to run it on the new state s'
05:23:18 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' ... )
05:23:26 <Cale> getting some final state s''
05:23:27 <{AS}> bartavelle: ongy Thanks
05:23:29 <Cale> and result w
05:23:40 <Cale> and those are going to be the final state and result of our combined computation
05:23:50 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'', w))
05:23:51 <{AS}> I guess what I wanted was somehow that packages specify the operations and type signatures they require from other packages
05:23:59 <Cale> Make sense?
05:24:00 <{AS}> and if these change, cabal could do something smart
05:24:04 <{AS}> like install the proper version
05:24:05 <Cale> We can simplify this a bit, to:
05:24:14 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in runState (f v) s')
05:24:30 <Cale> (but I find it often helps people to put that extra step in before simplifying)
05:24:41 <bartavelle> {AS} well, we don't have that ;)
05:24:54 <Cooler> yeah
05:25:10 <bartavelle> {AS}, although you can use stack, which let you "update everything at once" and you just have to worry about updating your own package
05:25:30 <bartavelle> {AS}, no dependency mismatch between two packages you required
05:25:34 <ph88> can someone tell me how i can combine these two functions ?  http://pastebin.com/2SYe3vqs
05:25:55 <Cale> Cooler: One interesting thing to note is that we can actually screw up this definition in a fun way
05:26:06 <Cale> Instead of  x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'', w))
05:26:13 <Cale> We can wire up the state backwards
05:26:17 <bartavelle> ph88, "wp basicIdentifier :: Parser (BasicIdentifier, SourcePos)" ?
05:26:27 <Cale> x >>= f = S (\s -> let (s'',v) = runState x s'; (s',w) = runState (f v) s in (s'', w))
05:26:48 <Cale> This actually works, and gets us a monad in which the state flows "backwards in time"
05:27:01 <bartavelle> ph88, basicIdentifier isn't too pretty!
05:27:38 <Cale> So, for example,  do xs <- get; put (1 : xs); return xs  will produce an infinite list of 1's in this weird backward state monad.
05:27:41 <markus1189> jii
05:27:58 <Cale> But anyway
05:28:02 <bartavelle> ph88, basicIdentifier = fmap T.pack ((:) <$> letterV <*> some (satisfy (\x -> x == '_' || isLetter x || isDigitx)) )   or something like that
05:28:06 <Cale> Let's just go with the non-crazy one :)
05:28:18 <Cooler> yes
05:28:36 <Cooler> is that for reversible computations or something
05:28:56 <Cooler> the crazy version
05:29:01 <Cale> It doesn't see a lot of use, but it might be useful for writing certain kinds of recursive values
05:29:21 <{AS}> bartavelle: ah thanks
05:29:27 <ph88> bartavelle, i mean i want basicIdentifier to yield the type of wp .. so i was thinking maybe i can use let .. in  or something ?
05:29:27 <Cale> It's very easy to write infinite loops by doing acausal things with the obtained state
05:29:44 <{AS}> unfortunately it is not my package
05:29:57 <bartavelle> ph88, I don't understand what you need to do
05:30:05 <Cooler> Cale, wait
05:30:09 <Cooler> in the crazy version
05:30:10 <Cooler> x >>= f = S (\s -> let (s'',v) = runState x s'; (s',w) = runState (f v) s in (s'', w))
05:30:22 <Cooler> (s'',v) = runState x s' needs s'
05:30:31 <Cooler> (s',w) = runState (f v) s needs v
05:30:32 <Cale> yep
05:30:39 <Cale> It's mutually recursive
05:30:42 <Cooler> so thats dependent on each other
05:30:44 <Cale> yes
05:30:52 <Cooler> so how do you even start
05:31:16 <bartavelle> ph88, you want basicIdentifier to have type (BasicIdentifier, SourcePos) ?
05:31:21 <ph88> bartavelle, basicIdentifier gives back Text  but i want it to give to give back TextP  and use the wp function to do it
05:31:40 <Cale> Well, you bind all these variables to not-yet-evaluated expressions at runtime, and they get evaluated only as needed.
05:31:45 <bartavelle> ph88, ah ok, just do that : basicIdentifier = wp $ do
05:31:45 <ph88> bartavelle, TextP = (Text, SourcePos)
05:31:50 <ph88> ah ok
05:31:51 <ph88> thx
05:32:04 <Cooler> Cale, sure but where do you even start or end
05:32:06 <mauke> > let { a = 0 : b; b = 1 : a } in a
05:32:08 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
05:32:16 <Cale> So, if we try to evaluate w, it'll start by evaluating runState (f v) s'
05:32:22 <bartavelle> ph88, the let x = do ... in wp x was perfectly valid, but I find this form simpler
05:32:23 <Cale> and only when that eventually uses s'
05:32:26 <ph88> bartavelle, is it possible to define my own  show  function for TextP  ?
05:32:34 <ph88> bartavelle, me too !
05:32:39 <Cale> sorry, extra quote there :)
05:32:42 <Cale> So, if we try to evaluate w, it'll start by evaluating runState (f v) s
05:32:42 <bartavelle> ph88, no you'll have to newtype it
05:33:13 <Cooler> and you need v so you evaluate runState x s'
05:33:22 <Cale> right
05:33:23 <Cooler> and you never stop evaluating
05:33:32 <Cale> well, *maybe* you need v
05:33:55 <Cale> Maybe f can produce some part of its result without pattern matching on all of v
05:33:56 <bartavelle> ph88, newtype WithPosition a = WithPosition { _getWithPosition :: (SourcePos, a) }  -- (it's better to have the a on the right of the tuple)
05:34:18 <Cale> and even if you need v, you might not need all of it -- you might need the top level data constructor to get started
05:34:28 <Cale> and then from there you can produce some part of the result without looking deeper
05:34:32 <bartavelle> ph88, however I usually use a pretty printer for that kind of thing, as show is supposed to print valid haskell code (that's just a convention)
05:34:44 <bartavelle> (but it's useful)
05:34:49 <Cale> For an example of a definition in a similar style...
05:34:57 <bartavelle> (you can copy'n'paste the output of show and use it in ghci)
05:35:08 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
05:35:11 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
05:35:15 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in odds
05:35:18 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
05:35:21 <Cooler> Cale, right ok
05:35:34 <Cooler> its like take 4 [1..]
05:35:38 <Cale> yeah
05:36:30 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
05:36:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:36:41 <Cale> ^^ primes by mutual recursion :)
05:36:50 <ongy> bartavelle: is ther an implementation reason the a should be on the right? or simply convention?
05:37:02 <ashishnegi> finally.. i have haskell app and where can i deploy it easily ? What is the experience with Heroku ? or setting up AWS box ?
05:37:10 <ph88> bartavelle, ah yes you're right it's a bad idea, i should use a pretty printer. Can you recommend one? i was looking at this one   https://hackage.haskell.org/package/mainland-pretty
05:37:11 <bartavelle> ongy, you get all the instances of (,) x that way
05:37:25 <Cale> (note that it's quite important to give it that 2 to start things off, or it won't get anywhere)
05:37:28 <Cale> anyway
05:37:40 <bartavelle> ph88, I usually use http://hackage.haskell.org/package/ansi-wl-pprint because it has colors
05:37:41 <Cale> Cooler: So we were almost done
05:37:45 <ongy> bartavelle: oh makes sense. never thought about that
05:37:47 <Cooler> yes
05:37:54 <Cale> Cooler: There's only a couple primitive things left to implement
05:38:01 <Cooler> >> and fail>
05:38:03 <Cooler> ?
05:38:06 <Cooler> fail*
05:38:20 <Cale> nah, (>>) has an okay default definition in terms of (>>=)
05:38:30 <Cale> and fail, well, fail shouldn't be part of Monad
05:38:35 <bartavelle> ongy, then you missed the FTP debates ;)
05:38:44 <Cooler> ok whats left then
05:38:52 <Cooler> the monad laws?
05:38:52 <Cale> get and put
05:39:02 <ongy> bartavelle: I don't sit in front of my irc all the time. Only when I don't sleep :)
05:39:07 <ph88> bartavelle, i'm not even sure what advantage pretty-mainland would give me .. i think i can do the line pragmas with ansi-wl-pprint, no ?
05:39:12 <Cooler> right we need get and put
05:39:21 <bartavelle> ongy, only saw them on reddit myself!
05:39:33 <Cale> get :: State s s  will be the computation which when we run it, will produce the current state as its result and not change the state
05:39:35 <ongy> also ftp=file transfer protocol?
05:40:00 <bartavelle> ongy, foldable/traversable proposal I think
05:40:28 <bartavelle> ph88, I don't know what the other does, only used the ansi one, and it does all kind of stuff pretty printers do
05:40:28 <Cale> and  put :: s -> State s ()  will produce the computation which when we run it, sets the current state to the given value, regardless of what it was before, and produce a boring empty tuple as its result
05:40:41 <bartavelle> ongy, when stuff in Data.List was generalized
05:40:56 <ph88> bartavelle, can i use it to output source code back into a file ? to reconstruct the original source code ?
05:41:03 <ongy> yeah, that was before I bothered with haskell. And I don't think I want to read up on history, yet
05:41:20 <Cale> If you want, those are good easy exercises
05:41:27 <bartavelle> ph88, I do that in my language-puppet package, using an unlawful Prism
05:41:52 <Cooler> Cale, whats the type?
05:42:00 <Cooler> get :: State s a -> s?
05:42:25 <Cale> get :: State s s
05:42:32 <ph88> bartavelle, don't know what an unlawful Prism is, but it sounds funny :p
05:42:37 <Cooler> why are there 2 ss?
05:42:46 <Cale> Because it produces the current state as its result
05:42:57 <Cale> So its result type is the same as the state type
05:43:05 <Cooler> right nvm
05:43:13 <bartavelle> ph88, it's in lens, but don't worry too much about this for now ;)
05:43:40 <bartavelle> ph88, there is a (scary) example of source code manipulation here : http://lpuppet.banquise.net/blog/2014/01/22/prisms-and-lenses-in-language-puppet/
05:43:51 * hackagebot servant-subscriber 0.5.0.0 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.5.0.0 (eskimo)
05:44:10 <Cooler> so get = S (\s -> (s, s)) ?
05:44:47 <Cale> yep!
05:45:09 <bartavelle> Cooler, well done!
05:46:03 <bartavelle> ongy, only thing that you might want to watch out for if you are used to other languages are the instances of the various tuples
05:46:07 <bartavelle> > length (1,2,3,4)
05:46:09 <lambdabot>  error:
05:46:09 <lambdabot>      • No instance for (Foldable ((,,,) t0 t1 t2))
05:46:09 <lambdabot>          arising from a use of ‘length’
05:46:23 <bartavelle> > length (1 :: Int,2 :: Int,3 :: Int,4 :: Int)
05:46:26 <lambdabot>  error:
05:46:26 <lambdabot>      • No instance for (Foldable ((,,,) Int Int Int))
05:46:26 <lambdabot>          arising from a use of ‘length’
05:46:28 <Cale> I think it might just be pairs
05:46:34 <bartavelle> right!
05:46:36 <Cale> > length (1,2)
05:46:38 <lambdabot>  1
05:46:45 <bartavelle> > length (1,2)
05:46:47 <Cale> > toList (1,2)
05:46:47 <lambdabot>  1
05:46:50 <lambdabot>  error:
05:46:50 <lambdabot>      Ambiguous occurrence ‘toList’
05:46:50 <lambdabot>      It could refer to either ‘F.toList’,
05:46:54 <Cale> > F.toList (1,2)
05:46:56 <lambdabot>  [2]
05:47:04 <bartavelle> why aren't they defined for other tuples ?
05:47:07 <Cooler> put :: State s a -> () ?
05:47:12 <ongy> so (a, b) has more instances than (a, b, c)?
05:47:17 <Cale> Probably because nobody loves other tuples
05:47:28 <Cale> People don't bother with triples very often
05:47:31 <bartavelle> Cale, if it's wrong then I don't wanna be right
05:47:34 <Cale> and 4-tuples are very rare
05:47:47 <Cale> Cooler: nope
05:48:12 <Cooler> put :: State s a -> State s () ?
05:48:16 <Cale> Cooler: put :: s -> State s ()
05:48:20 <Cooler> oh right
05:48:57 <Cooler> put = S(\s -> (s, ()) ? that can't be right
05:49:11 <Cale> correct, it can't be ;)
05:49:21 <Cooler> put ns = S(\s -> (ns, ()) ? that can't be right
05:49:25 <Cooler> put ns = S(\s -> (ns, ())
05:49:31 <Cale> That's right.
05:49:36 <Cooler> ok
05:50:06 <Cale> So, we now have this language with get, put, return and (>>=), and from there, we can build up lots more stuff without ever touching S again
05:50:30 <Cale> (if we choose)
05:51:26 <Cooler> what was going on earlier with Get, get and Put, put
05:51:37 <Cooler> and Return, return
05:51:41 <Cale> ah, so this was an alternate way to set up this language :)
05:52:08 <Cale> A way which was a bit more explicit from the outset about what operations we want to eventually support
05:52:42 <Cale> So, if you think about what a State s a computation might be
05:52:56 <Cale> There are three possibilities for the first thing it does
05:53:16 <Cale> Maybe it just does nothing involving the state and returns some constant result
05:53:34 <Cale> Maybe it reads the current state using get, and does something based on the result of that
05:53:51 * hackagebot servant-purescript 0.3.1.0 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.3.1.0 (eskimo)
05:54:00 <Cale> Or perhaps it starts off with a put, following that up with some other computation
05:54:13 <Cale> Yeah?
05:54:24 <Cooler> when you say put and something else
05:54:24 <Cale> So, we might choose to define State s a in a different way
05:54:35 <Cooler> why not separate that
05:55:08 <Cooler> put as one function and that something else as a different function
05:55:31 <Cale> Well, there is an approach where we put in a data constructor for (>>=)
05:55:38 <Cale> But that needs GADTs
05:55:59 <Cooler> whats GADT
05:56:06 <Cale> generalised algebraic data types
05:56:27 <Cale> With that extension, you get to say what the types of your data constructors are explicitly
05:56:39 <cocreature> and you can specialize type variables
05:56:45 <Cale> So that you can have constructors which produce specialised result types
05:57:23 <Cale> Like, we could do:
05:57:27 <Cale> data State s a where
05:57:36 <Cale>   Return :: a -> State s a
05:57:46 <Cale>   Bind :: State s a -> (a -> State s b) -> State s b
05:57:51 <Cale>   Get :: State s s
05:57:58 <Cale>   Put :: s -> State s ()
05:58:21 <Cooler> you can do that already with class
05:58:31 <Cale> This Return, Bind, Get and Put are inert data constructors
05:58:32 <Cooler>  class State s a where
05:58:36 <Cale> uh
05:58:40 <Cale> no
05:59:10 <Cale> instances of such a class would provide some sort of relationship between the types s and a
05:59:13 <Cooler> what do you mean inert
05:59:37 <Cale> I mean they're just values to be pattern matched on, and don't compute anything when we use them, they evaluate to themselves
06:00:20 <f-a> what's a graceful way to handle "hGetContents: invalid argument (invalid byte sequence) " (readFile)
06:00:22 <Cale> So we could write something like   Bind Get (\x -> Bind (Put (x+1)) (\_ -> Return x))
06:00:41 <dennisvennink> What is more idiomatic Haskell? `class Monoid m where empty :: m a` or `class Monoid m a where empty :: m`?
06:00:44 <Cale> and that's a data structure, we can pattern match on it
06:00:49 <f-a> as now it breaks my program, how to recover from it?
06:02:01 <Cale> f-a: Which readFile is that? The one in the Prelude? If you want to catch the exception, I would recommend using either the readFile for strict ByteString or strict Text
06:02:27 <Cale> f-a: which will force the exception to occur right away, rather than at some later point as you consume the result
06:02:49 <Cale> (making it easier to wrap in a catch)
06:02:54 <Cooler> Cale, aren't inert stuff then of type   Inert a :: () -> a
06:03:07 <Cooler> Inert a :: a
06:03:24 <Cale> Cooler: By "inert" I just mean that if we evaluate that expression, it just sits there -- it's already considered evaluated
06:03:29 <fizbin> Can anyone tell me how to name cost centers when using the -hc option to profiling?
06:03:35 <f-a> Cale: thanks
06:03:37 <fizbin> Clearly, I'm not doing it right.
06:03:43 <f-a> (and yes, it is prelude)
06:03:53 <Cale> fizbin: {-# SCC "name" #-} iirc
06:04:15 <Cale> fizbin: and you put that before the expression it applies to
06:05:14 <fizbin> Cale: Um, what I mean is that when trying to do -hcCostCenter I keep getting rejected and just have usage spit out.
06:05:28 <fizbin> Though I now see that it's complaining about something else.
06:06:37 <Cale> Cooler: anyway
06:06:37 <f-a> Cale: and I should catch with `catch`, right?
06:06:48 <Cale> f-a: Or try will work
06:06:51 <Cale> :t try
06:06:53 <lambdabot> Exception e => IO a -> IO (Either e a)
06:07:01 <f-a> cheers
06:07:13 <Cale> now we need to know which exception type it is that you want to try to catch
06:07:14 <fizbin> So, I'm trying to follow the directions here for doing biographical profiling: https://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/prof-heap.html#biography-prof
06:07:31 <f-a> Cale: that pesky hGetContents: invalid argument (invalid byte sequence) 
06:07:32 <Cooler> haskell has exceptions?
06:07:47 <Cale> Cooler: Yeah
06:07:59 <Cooler> i thought the type system made it unneccessary
06:08:32 <f-a> as long as there is someone watching a program running, I feel that won't be the case
06:08:32 <Cale> Cooler: The type system can't help you if you run out of disk space
06:08:41 <dabd> a more or less category theoretic question: given a dependency graph where each node is an endomorphism can we still form a monoid under composition, given that the order of evaluation matters?
06:08:41 <dabd> In other words, don't we lose associativity?
06:09:07 <Cale> dabd: I don't understand that question
06:09:10 <fizbin> Oh, user error. Never mind - I had heap profiling options in my .cabal file, and then when trying to use ones on the command line was hitting "multiple heap profiling options" errors.
06:09:18 <Cale> fizbin: ah
06:10:57 <dabd> Cale, Maybe I am confused in formulating the question:a set of endomorphisms form a monoid under composition right? If you have a dependency graph where each node is an endomorphism then order of evaluation matters.  Don't we lose associativity because of that?
06:11:26 <Insanity_> I can't define a function as being CReal -> CReal?
06:11:43 <Insanity_> probably making the same mistake as yesterday.. CReal is a typeclass or something? Not sure what the terminology was again
06:11:44 <mauke> > (id :: CReal -> CReal) 0
06:11:47 <lambdabot>  0.0
06:11:49 <mauke> works
06:11:55 <Insanity_> > x :: CReal - Creal
06:11:57 <lambdabot>  error:
06:11:58 <lambdabot>      Not in scope: type constructor or class ‘-’error:
06:11:58 <lambdabot>      Not in scope: type constructor or class ‘Creal’
06:12:01 <mnoonan> dabd: can you elaborate on the graph and evaluation you're talking about?
06:12:02 <Cale> dabd: I don't understand how arranging them into a dependency graph has anything to do with associativity
06:12:10 <Cale> dabd: What are we even multiplying?
06:12:16 <ongy> Insanity_: what did you try there?
06:12:16 <Insanity_> Doesn't work mauke. I'm trying to use it to define a function param + return
06:12:24 <Insanity_> as I would
06:12:29 <mauke> Insanity_: how does it fail?
06:12:35 <Insanity_> >test x :: CReal -> CReal
06:12:43 <mauke> that's a syntax error
06:12:52 <Insanity_> > text x :: Int -> Int
06:12:54 <lambdabot>  error:
06:12:54 <lambdabot>      • Couldn't match expected type ‘Int -> Int’ with actual type ‘Doc’
06:12:54 <lambdabot>      • Possible cause: ‘text’ is applied to too many arguments
06:12:57 <mauke> that's still a syntax error
06:13:07 <ongy> :t test :: CReal -> CReal
06:13:08 <lambdabot> error:
06:13:08 <lambdabot>     • Variable not in scope: test :: CReal -> CReal
06:13:08 <lambdabot>     • Perhaps you meant one of these:
06:13:14 * mauke sighs
06:13:56 <Cale> f-a: I think you just want to catch an IOException
06:14:00 <jgzh6> I was wondering if someone could help me fix the code (http://lpaste.net/182878) so that it doesn't crash at an exception (status 404) and keep processing the rest.
06:14:12 <Insanity_> My type definitions worked when I used Int instead of CReal though above my functions
06:14:24 <{AS}> Is there any way I can force cabal to not upgrade packages
06:14:28 <dabd> mnoonan, by dependency graph I mean this https://en.wikipedia.org/wiki/Dependency_graph
06:14:38 <f-a> Cale: that might be it. so try (something) >>= \e -> and then pattern match it, right?
06:14:40 <{AS}> when I try to install a library it automatically tries to upgrade the packages on the dependencies
06:14:49 <{AS}> but I don't want that for already OK packages
06:14:56 <dabd> I am thinking of structuring a complex computation as a DAG, specifically a dependency graph, much like a spreadsheet
06:15:15 <Cale> f-a: yeah
06:16:00 <{AS}> Oh I figured it out
06:16:03 <ongy> Insanity_: you can't do "test x :: CReal -> CReal" it should be "test :: CReal -> CReal" and "test x = ..." in another line
06:16:04 <{AS}> use --constraint 
06:16:11 <Cale> Cooler: anyway
06:16:15 <ongy> unless there's another error there that I don't see
06:16:19 <Insanity_> yeah ongy, that was a typo here in the chat :-)
06:16:23 <Cale> Cooler: Lemme show this other, non-GADT way
06:16:33 <Insanity_> But I figured it is because the value I'm actually returning different from the type sig
06:16:56 <Cale> Cooler: Because it generalises nicely -- you can construct monads which sort of have arbitrary operations which you'll implement later
06:17:32 <Cale> Cooler: So, we had   data State s a = Return a | Put s (State s a) | Get (s -> State s a)
06:17:37 <Cooler> yes
06:18:13 <dabd> but if the order of evaluation matters, because it is a dependency graph like for ex: C -> B -> A, then composing (A B) C is not the same as A (B C) because the former can't even be evaluated, since C needs to be computed first
06:18:52 * hackagebot random-fu-multivariate 0.1.1.1 - Multivariate distributions for random-fu  https://hackage.haskell.org/package/random-fu-multivariate-0.1.1.1 (DominicSteinitz)
06:18:57 <Cale> and the idea there is that the Put constructor takes the new state value (the argument to put), and then the computation which follows (which isn't a function of the result of the put, because put has only a boring () as its result)
06:19:26 <Cale> and the Get constructor just has as its argument a function of the result of that initial get
06:19:31 <mnoonan> dabd: aren't each of A,B,C just functions of type T -> T for some fixed T?
06:19:41 <dabd> mnoonan, yes
06:19:51 <ski> (the uncurried version of `() -> State s a' is just `State s a', you could say)
06:20:00 <Cale> Cooler: So, this way, we sort of put in the operations we want to end up with
06:20:02 <mnoonan> then this is just plain old associativity of function composition
06:21:02 <dabd> but A, B, C are part of a dependency graph like for example C -> B -> A so C needs to be computed first so B can be computed, etc.
06:21:17 <Cale> dabd: that... doesn't matter
06:21:31 <mnoonan> no, C needs to produce a result before B can, but you can still compose the various transformers together. and it's that composition that's associative
06:22:10 <dabd> ah I see, I am confusing the production of the result with the composition of the functions
06:22:49 <f-a> Cale: http://lpaste.net/2557419838108598272 <-- is this supposed to work, because I still get that hGetContents: invalid argument ...
06:22:57 <Cale> dabd: If I put on my socks, then (put on my shoes then tie my shoes), it's the same as if (I put on my socks then put on my shoes) then tie my shoes
06:23:25 <Cale> dabd: any dependencies between the computations don't affect the fact that "then" is associative
06:23:46 <f-a> (perr is a helper to print to stderr)
06:24:28 <Cale> f-a: If you're still using Prelude's readFile, the problem is that Prelude readFile is magic
06:24:36 <dabd> Cale, that is a good example. Wonder why I was confused
06:25:10 <ski> f-a : you must force the read string, inside the `try' call
06:25:27 <f-a> Cale: ohh, I see
06:25:33 <Cale> f-a: Prelude's readFile produces its String result immediately without actually reading the file
06:25:41 <Cale> f-a: and then only reads the file as you use the String
06:25:54 <Cale> which is not good if you want to deal with exceptions sanely
06:26:17 <f-a> ski: what would be the function
06:26:21 <Cale> That's why I recommended switching to using Strict ByteString or Text as appropriate (and converting to String if you have to).
06:26:35 <f-a> Cale: I see, can't use Bs, I"ll check text
06:26:36 <ski> would `readFile fp >>= evaluate' suffice, here ?
06:26:48 * ski isn't quite sure which kind of exception f-a wants to avoid
06:27:00 <Cale> ski: Only if the encoding error occurs immediately at the start of the file
06:27:04 <f-a> ski: hGetContents: invalid argument (invalid byte sequence)
06:27:09 <ski> oh, encoding errors
06:27:52 <ski> then you'll need to force the whole string
06:28:01 <ongy> would '\xs -> length xs `seq` xs' be a good idea to force something like that? 
06:28:12 <Cale> You could write something like  E.try (do x <- readFile fp; E.evaluate (length x); return x)
06:28:18 <Cale> but that's... awkward
06:28:43 <f-a> yeah it is, what's the module I should use Cale Data.Text?
06:28:45 <Cale> and I'm not even 100% certain that it'll work, since it doesn't technically force the characters in the list
06:29:14 <Cale> Data.Text.IO has readFile
06:29:32 <Cale> You can write something like
06:29:36 <Cale> import Data.Text (Text)
06:29:42 <Cale> import qualified Data.Text as T
06:29:50 <Cale> import qualified Data.Text.IO as T
06:30:05 <Cale> and then use T.readFile
06:30:16 <Cale> and if you want to convert back to String, it'd be T.unpack
06:30:22 <f-a> cheers
06:30:36 <f-a> since we're here, how do programs like vim don't choke on those?
06:30:38 <f-a> they guess?
06:31:02 <Cale> Yeah, vim has a bunch of file format detection.
06:32:48 <f-a> worked! Thanks Cale / ski 
06:33:46 * ski misses `Exception e => IO a -> (a -> IO b) -> (e -> IO b) -> IO b'
06:34:26 <Cale> f-a: If you're doing anything for which performance is any concern, Data.Text will be much better anyway
06:34:27 <ski> (call it `bindCatch' or something)
06:35:59 <MarLinn> :t Control.Exception.catchJust -- <- ski?
06:36:01 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
06:36:06 <Cale> ski: I usually use try and then case, which ends up having a similar structure
06:37:08 <ski> Cale : yes, but it feels redundant to construct an `Either' inside, just to deconstruct it immediately outside
06:37:40 <Cale> fair enough :)
06:37:43 <ski> (or the alternative, which is to have `IO (IO b)', and then `join')
06:38:41 <ski> also, as i understand it, it's nicer to state laws in terms of `bindCatch'
06:38:49 <ski> (see the paper "Exceptional Syntax")
06:39:12 <Cale> At one point, you didn't even have to write the bindCatch ;)
06:39:26 <Cale> (The relevant operations just took the two continuations)
06:39:50 <Cale> That was before I started using Haskell though
06:40:03 <ski> MarLinn : no, that doesn't allow the handler to do `IO', and it always does the "then" part, iiuc
06:40:23 <ski> (always, unless you get `Nothing' and reraise, of course)
06:51:00 <MarLinn> I see...
06:53:47 <ski> MarLinn : i think <http://lambda-the-ultimate.org/node/1193> has a link to the paper, in case you're interested
06:53:50 <ski> (Cale ^)
06:59:43 <Cooler> got dced
07:02:31 <MarLinn> found it at https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/exceptionalsyntax.pdf
07:03:42 <ski> yes, that's the one
07:04:29 <MarLinn> I must say somehow I seem to have managed to largely avoid the topic of exceptions in Haskell for now. Using existing libraries that do that for me certainly helped
07:04:30 <ski> they talk a bit about a new syntax form, but the essential part of it can also be expressed with a function like `bindCatch'
07:07:08 <MarLinn> Sounds interesting
07:11:01 <glguy> ski: try and catch aren't interchangeable, the difference is in masking (just mentioning having glanced through the backlog, might be irrelevant)
07:12:02 <mnoonan> Does update / (//) for Data.Array or Data.Vector do sharing, or do you get a full copy?
07:12:13 <mnoonan> Data.Vector.(//) says it is O(n+m), so presumably not in that case
07:12:48 <glguy> not shared
07:12:49 <mrtrump> happstack anyone?
07:13:31 <mnoonan> bummer. so is there a good option for a (Map k v)-like with a fixed set of keys that can share the tree structure and most of the values on edits?
07:14:07 <ski> glguy : ok, i hadn't considered that subtlety in this context
07:14:15 <glguy> you could use Map and not insert new keys
07:14:34 <mnoonan> glguy: if I modify a value, doesn't it still have to make a new spine?
07:14:50 <mrtrump> are things easier to do in haskell than say python?
07:14:58 <mrtrump> is it way more powerful?
07:15:07 <mrtrump> how can a shell scripter learn haskell?
07:15:44 <mrtrump> how can I do big data with haskell? like use a platoon of boxes together runing a free unix?
07:16:04 <mrtrump> is there any cluster image database software like google bigtable?
07:16:15 <frteodoro> mrtump: learnyouahaskell.com
07:16:26 <mrtrump> liek user space program that hoosk onto say 30 boxes, and I can then program it as 1 global space?
07:16:38 <Axman6> not really
07:16:59 <mrtrump> :)
07:17:10 <ongy> well, http://www.mathematik.uni-marburg.de/~eden/ exists, but I don't know how good it is
07:17:19 <henryford> oow
07:17:31 <Axman6> therefew people would consider Haskell easier than Python, but easy isn't necessarilly the metric you should be aiming for
07:17:48 <fizbin> Okay, I have a question about naming cost centers again and haskell heap profiling.
07:18:12 <fizbin> So I'm using -fprof-auto to name my cost centers
07:18:47 <fizbin> And I want to do "biographical profiling" as described https://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/prof-heap.html#biography-prof
07:18:49 <henryford> I want power
07:18:59 <ongy> henryford: define "power"
07:19:00 <henryford> I want to make millions by providing awesome apps.
07:19:06 * MarLinn . o O (   (foo >>=! bar :: Throws e) theCatcher  )
07:19:08 <henryford> using freebsd and haskell
07:19:24 <fizbin> So I profile with "+RTS -hc -hbdrag,void" as directed,
07:19:51 <Axman6> power, expressiveness and correctness are things I value. performance too, and Haskell does much better there than Python ever will
07:20:10 <henryford> so if i have 50 computers, each with hasekll 8, can 1 control the other 49? and instead of say spawning work locally dole it out?
07:20:14 <fizbin> And I discover that my worst memory usage is due to a cost center with a name that looks like: 
07:20:38 <henryford> haskell sounds awesome I must put aside time to learn
07:20:49 <henryford> will freebsd get ghc8 soon?
07:20:51 <fizbin> (1695)(1695)makeThingOne.expandEpsi...
07:21:01 <ongy> henryford: there's no builtin way to do that (afaik). but that eden compiler seems to aim for that and there may be a package on hackage
07:21:13 <fizbin> Oops. Not that, cost center looks like (1695)makeThingOne.expandEpsi...
07:21:29 <fizbin> Now, how do I focus a heap profile on that cost center?
07:21:40 <fizbin> -hc1695 doesn't work
07:22:20 <henryford> so haskell seems like a big box lang
07:22:28 <henryford> I need a big multi cpu box with raid 10
07:23:21 <fizbin> Even the .hp file doesn't seem to have the full name of the cost center, just the abbreviated (with "...") name.
07:23:28 <henryford> www.happstack.com seems awesome beyond beleif
07:23:45 <henryford> acid in ram database? like prevayler?
07:23:47 <henryford> data in ram
07:23:50 <henryford> blbos on disk
07:23:56 <henryford> I can get 512g ram box easy
07:24:09 <henryford> blobs on disk
07:25:17 <glguy> mnoonan: yeah, but it only has to rebuild the elements on the path to the value you updated
07:25:50 <henryford> can haskell get at bsd or linux cpu disk and load stats? and spit out a nice email alert?
07:26:05 --- mode: ChanServ set +o mauke
07:26:05 --- mode: mauke set +b $a:MrTrump
07:26:13 --- kick: henryford was kicked by mauke (protontorpedo)
07:26:33 <ongy> mauke: for the earlier username, or did you consider him to spammy?
07:26:42 <mauke> for being protontorpedo
07:27:00 <mauke> @protontorpedo
07:27:01 <lambdabot> why haskell over smalltalk? I thought smalltalked rocked
07:27:03 <mauke> @protontorpedo
07:27:03 <lambdabot> can haskell do same stuff as J2EE but nicer?
07:27:06 <mauke> @protontorpedo
07:27:06 <lambdabot> what is the best absolute beginner utorial for haskell?
07:27:08 <glguy> thanks mauke
07:27:10 <mauke> @protontorpedo
07:27:10 <lambdabot> why would u write a interpreter for perl in haskell?
07:27:22 <ongy> ah. good to know
07:28:13 --- mode: mauke set -o mauke
07:30:34 <Axman6> oh man, I'd forgotton about @protontorpedo
07:31:57 <raichoo> OK, maybe I'm missing an insider here… why is that called protontorpedo? O_o
07:33:18 <byorgey> raichoo: protontorpedo was their nick
07:33:21 <Axman6> IIRC it's a bunch of quotes from a user who used to be here
07:33:33 <raichoo> ah ok ^^
07:33:54 * hackagebot google-oauth2-jwt 0.1.0.0 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.1.0.0 (MichelBoucey)
07:33:56 * hackagebot lentil 1.0.0.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.0.0.0 (fffaaa)
07:34:55 <mauke> and who still comes here, asking inane bullshit questions
07:35:03 <mauke> (which see above)
07:35:26 <Axman6> woah, that was him?
07:35:39 <mauke> yes
07:36:04 <Axman6> I almost feel honoured to have seen him in action
07:40:35 <mnoonan> glguy: I think Data.Sequence might be the closest match to what I was after. I forgot about that one.
07:45:55 <AzureStigma> i am totally lost here http://lpaste.net/182965
07:46:56 <boj> AzureStigma: can you explain where you feel lost?
07:47:03 <ski> (mauke : protontorpedo = republicanDevil = chaoticEvil = ... ?)
07:47:21 * ski can't recall atm another nick the latter have often used
07:47:30 <AzureStigma> what is occuring at (1 :: Integer)
07:47:58 <AzureStigma> and if its a string how is (1 :: Integer) sensible
07:48:35 <Cale> You're applying the function to the argument (1 :: Integer)
07:48:37 <ski> the first argument is `1 :: Integer', which has type `Integer'
07:48:59 <ski> so the type of *this* particular use of `funcIgnoresArgs' is then `Integer -> Integer -> Integer -> String'
07:49:21 <ski> applying such a function to an `Integer' will leave you with a function of type `Integer -> Integer -> String'
07:49:24 <Cale> and it infers that, because the type signature for funcIgnoresArgs says that all three of the function's arguments must be the same type, the remaining two arguments must also be Integer values now
07:49:43 <Cale> and the result will still be a String
07:49:49 <AzureStigma> bc of the function saying that 
07:50:07 <boj> AzureStigma: what it is basically teaching you is that each argument gets applied one at a time. in this case you applied (1 :: Integer) which ends up being x, but there is y, and z, ultimately all of which are ignored because the function passes a string back
07:50:25 <Cale> If you change the type signature for funcIgnoresArgs to  funcIgnoresArgs :: a -> b -> c -> String
07:51:00 <Cale> then you'll get  b -> c -> String  after applying it to an Integer
07:51:07 <AzureStigma> so hes puprosley using the 1::Integer to ignore it
07:51:16 <boj> AzureStigma: exactly
07:51:21 <AzureStigma> thanks
07:51:52 <AzureStigma> cale can i pm you its a bit off topic
07:52:02 <Cale> sure
08:00:49 <nihliphobe> howdy all
08:01:54 <cloudhead> howdydy
08:03:55 * hackagebot google-oauth2-jwt 0.1.1.0 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.1.1.0 (MichelBoucey)
08:06:58 <mnoonan> if I define a function like "f x y = ... where t = expensiveComputation x", and then use it by doing "let f' = f x in (f' 1, f' 2, ...)" is the expensive computation (always? ever?) shared between the different invocations of f'?
08:08:57 <ski> mnoonan : in think in GHC, you should do f x = \y -> ..x..y.. where t = ..x..' there
08:09:05 <ski> (if you want it to be shared)
08:09:13 <mnoonan> I see.
08:09:59 <ski> (this is sometimes known as "serious currying". also one can sometimes think of it as "compiling" `x' into `\y -> ..x..y..t..')
08:10:55 <mauke> ski: yes, I have a whole collection of nicks
08:11:12 <jackhill> yay service desk INC1530823
08:11:20 <jackhill> oops, sorry
08:11:30 * ski has seen them on other channels as well
08:11:37 <ski> (e.g. #scheme,##prolog)
08:16:44 <dfeuer> What has ski seen on other channels?
08:17:09 <ski> other incarnations of protontorpedo
08:17:42 <ski> (generally being annoying)
08:18:03 <dfeuer> *shrug*
08:19:00 <dfeuer> Is bit shifter shifty and bitter?
08:19:18 <dfeuer> HI bitemyapp.
08:26:30 <jgzh6> title = html . allNamed (only "span") . attributed (ix "class" . only "alert alert-danger") . contents
08:27:03 <jgzh6> what does "ix" do in here?
08:27:48 <jgzh6> Would it make any difference if I just write 'attributed ("class" . only "...
08:28:23 <dfeuer> Hmmm... How can I make Travis build the benchmarks *only* for GHC 8? I don't want to take the time to build them for all the GHC versions...
08:30:26 <dfeuer> Because installing the dependencies for the bleedin' benchmarks blows up CI time really badly.
08:32:43 <glguy> jgzh6: It's extremely likely that you can't omit the ix function and get the same result
08:33:56 * hackagebot hmpfr 0.4.2 - Haskell binding to the MPFR library  https://hackage.haskell.org/package/hmpfr-0.4.2 (MichalKonecny)
08:33:58 * hackagebot servant-purescript 0.3.1.1 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.3.1.1 (eskimo)
08:34:37 <jgzh6> hm.. ix was a function..?
08:34:44 <jgzh6> What does it do..?
08:34:58 <glguy> Presumably it indexes something
08:35:05 <jgzh6> aha..
08:35:09 <jgzh6> thanks
08:35:45 <dfeuer> Anyone familiar enough with the Travis to help with that?
08:36:41 <jgzh6> I was wondering if someone could teach me how to fix http://lpaste.net/182878 so that the program doesn't crash at an exception (page status 404) and keep processing all the urls.
08:37:39 <Cooler> which is more efficient foldr (+) [1..10] or foldl (+) [1..10]?
08:37:40 <glguy> jgzh6: Which part fails? get?
08:37:51 <dfeuer> glguy, my guess too.
08:37:56 <jgzh6> I think so
08:38:12 <jgzh6> when the page status is 404, it just crashes.
08:38:13 <dfeuer> jgzh6, you either need to wrap that in an exception handler or use a version that handles the exception.
08:38:27 <glguy> Cooler: foldl' would be the most efficient, GHC might optimize the foldl version to be as efficient as the foldl' version
08:38:30 <dfeuer> I'm guessing a version that handles the exception makes more sense.
08:39:01 <glguy> jgzh6: You can wrap (get i) in (try) from Control.Exception
08:39:13 <Cooler> glguy, what?
08:39:23 <glguy> huh?
08:39:25 <Cooler> what is foldl'?
08:39:33 <dfeuer> No, that's wrong.
08:39:37 <dfeuer> glguy, we were wrong.
08:39:46 <dfeuer> get isn't likely throwing the exception.
08:39:53 <ski> @src foldl'
08:39:53 <lambdabot> foldl' f a []     = a
08:39:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:40:02 <dfeuer> It returns  IO (Response ByteString),
08:40:10 <glguy> It's foldl but with a strict accumulator
08:40:14 <dfeuer> and Response seems to include status codes.
08:40:46 <glguy> dfeuer: OK, but it's likely that an exception is still being thrown by get given that we know that an exception is being throw
08:40:47 <glguy> n
08:41:08 <glguy> so unless it's using lazy IO then it has to be get
08:41:13 <dfeuer> glguy, unless one of those thingumjiggers below is a partial function.
08:41:25 <Cooler> @src seq
08:41:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:41:44 <glguy> My money is on wreq supporting a non-exception mode where you could get 404 in the Response, but that by default it doesn't
08:41:51 <dfeuer> glguy, what's that ^. do?
08:41:51 <Cooler> ski, whats seq?
08:42:07 <glguy> dfeuer: That's the view from lens package, it's not throwing anything
08:42:15 <dfeuer> OK.
08:43:34 <Cooler> whats seq in foldl'?
08:43:47 <jgzh6> hm.. I just don't have a clue how to actually write that solution..
08:44:43 <dfeuer> jgzh6, *maybe* you need to use checkStatus to change the Options to getWith?
08:45:06 <dfeuer> But this seems .... weird.
08:45:49 <jgzh6> hm...
08:45:57 <Cooler> anyone?
08:46:04 <Cooler> @src foldl'
08:46:04 <lambdabot> foldl' f a []     = a
08:46:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:46:29 <Cooler>  foldl' f a (x:xs) = let a' = f a x in foldl' f a' xs
08:46:33 <dfeuer> jgzh6, I'll say this much: the wreq documentation leaves much to be desired.
08:46:37 <Cooler> that should be enough?
08:46:54 <glguy> Cooler: evaluating (seq a b) returns b while ensuring that a was evaluated enough to determine it's outermost constructor
08:47:12 <glguy> Cooler: so it's making sure that GHC knows that the accumulator is going to be used
08:47:25 <jgzh6> What could be a better alternative to wreq..?
08:47:27 <glguy> so it doesn't bother building up an unevaluated expression to pass as an argument to foldl' f
08:47:57 <jgzh6> many people seem to recommend to use wreq for webscraping
08:48:24 <glguy> Yeah, wreq is fine
08:48:29 <glguy> you just need to catch the exception
08:48:36 <dfeuer> jgzh6, I have no idea. It may be the best; I just don't think the documentation for get is very good.
08:48:56 * hackagebot lentil 1.0.0.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.0.0.1 (fffaaa)
08:49:27 <jgzh6> hard..
08:49:40 <Cooler> glguy, i am not sure what you just said
08:50:02 <Cooler> the accumulator might not be evaluated?
08:50:24 <Cooler> so you need to use seq to make sure it gets evaluated?
08:51:36 * dfeuer_ tends to pay a *lot* of attention to the quality and completeness of his documentation, and gets annoyed with people who don't.
08:52:17 <glguy> Cooler: Yes, to make sure it gets evaluated as it is being constructed
08:52:49 <glguy> so instead of the result of foldl (+) 0 [1,2,3] being   0+1+2+3, the result is 6
08:52:50 <Cooler> @src foldl
08:52:50 <lambdabot> foldl f z []     = z
08:52:50 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:53:54 <glguy> foldl (+) 0 [1,2,3]   is   foldl (+) (0+1) [2,3]
08:54:06 <glguy> but foldl' (+) 0 [1,2,3] is   foldl' (+) 1 [2,3]
08:54:21 <Cooler> ok
08:54:48 <Cooler> @src foldr
08:54:49 <lambdabot> foldr f z []     = z
08:54:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:55:46 <glguy> jgzh6: wreg's get can throw this : https://hackage.haskell.org/package/http-client-0.5.3.1/docs/Network-HTTP-Client.html#v:StatusCodeException
08:57:24 <glguy> so you have to write something like this: res <- try (get "http://google.com/no-such/path/exists") :: IO (Either HttpException (Response ByteString))
08:57:56 <dfeuer> glguy, that seems like an odd interface. I'd have expected an exception from, say, failure to open the network interface, but I'd have expected a non-exception way to deal with HTTP status codes. Weird design.
08:58:06 <glguy> Yes it would be good if that was obvious from the documentation for wreq's get, no I don't know how you were supposed to know that
08:58:43 <glguy> wreq uses the http-client package which can throw exceptions
08:59:25 <jgzh6> Thanks for the advice.
08:59:31 <dfeuer> *shrug* I guess with more documentation it'd be fire.
08:59:34 <dfeuer> fine.
08:59:48 <glguy> Probably just needs a concerned citizen to submit a PR
08:59:53 <dfeuer> Yup.
09:00:19 <dfeuer> But I'm busy with other things and I know practically nothing about that library, so I'm not the one to do it.
09:00:45 <dfeuer> [other things = getting another major release of containers out before GHC 8.2 closes up and also trying to find a job]
09:00:45 <glguy> and I have to wash my hair today, so I'm out
09:00:49 <dfeuer> HAAAAAA
09:00:57 <dfeuer> Is that an all-day affair?
09:01:14 <glguy> It is if I put it off all day
09:01:15 <jgzh6> Bryan O'Sullivan seems to be away from haskell nowadays.
09:01:47 <c_wraith> he's in "make enough money to retire" mode now. 
09:02:38 <c_wraith> maybe he'll come back to working on the public haskell ecosystem eventually. 
09:02:50 <jgzh6> That'll be great..
09:08:04 <Cale> dfeuer, glguy: Speaking of weird exceptions, the websockets package contains a function  parse :: Stream -> Atto.Parser a -> IO (Maybe a)  which throws an exception on parse errors.
09:09:53 <tomjaguarpaw> Is there any way of getting long contexts to wrap in Haddock?
09:09:59 <tomjaguarpaw> They really go a *long* way to the right
09:10:37 <dmj> Cale: hmm, maybe because it's incremental parsing. stream parsing in io-streams does the same
09:10:38 <glguy> Cale: On purpose?
09:11:29 <Cale> glguy: yes
09:11:35 <dmj>  go (Atto.Fail _ _ err) _ = throwIO (ParseException err)
09:14:19 <davean> Cale: I mena, failure to parse means the client is speaking the wrong protocol
09:14:22 <davean> thats pretty exceptional
09:14:46 <glguy> I went through and put in more human readable messages for the various exceptions I can get while using the connection package recently: https://github.com/glguy/irc-core/blob/v2/src/Client/EventLoop/Errors.hs#L48
09:15:19 <davean> So I don't actually see anything weird there
09:15:51 <ski> Cooler : `seq' is specified (not implemented) by `seq _|_ y = _|_' and `seq x y = y' in case `x =/= _|_'
09:16:14 <glguy> It would be nice if parse had documentation that mentioned what it did
09:16:26 <glguy> but perhaps you aren't meant to use it directly
09:16:34 <ski> Cooler : `seq x y' will evaluate to `y', but will also ensure that `x' will get evaluated (but not necessarily before `y', in fact, not even necessarily before this call to `seq' returns)
09:16:37 <glguy> http://hackage.haskell.org/package/websockets-0.9.7.0/docs/Network-WebSockets-Stream.html#v:parse
09:17:02 <Cale> davean: Well, this thing is taking the parser as an argument, and it's producing a Maybe result, so from the outside, you'd kind of expect that the Nothing case will mean that the parsing failed, but that potential Nothing only indicates that the Stream was closed.
09:17:14 <dmj> davean: maybe this is obvious, but why not return Left errMesage
09:17:32 <ski> Cooler : it's typically used as a hint that the value of `x' will be needed eventually, and so there's no point in delaying evaluating it 'til the very end
09:17:44 <dmj> davean: IO (Either Failure a), instead of IO (Maybe a)
09:17:53 <Cale> right
09:18:37 <ski> Cooler : in short, if `seq x y' is forced, then `y' will (obviously) be forced (since `y' is the result), but `x' will also be forced
09:18:41 <Cale> It's only weird because the thing is already producing a Maybe result
09:19:09 <Cale> and the Nothing case of that Maybe result is equally deserving of being an exception
09:19:17 <Cooler> ski, right
09:20:07 <ski> Cooler : in this case, it is used as a hint that it will be a good idea to keep evalauting the accumulator as we go, one step at a time, rather than evaluating all the accumulated steps only at the end of the recursion (where it's obvious that the accumulator will be needed)
09:20:11 <Cale> (but that doesn't mean it should be either -- I'd tend to prefer using Either, but that's a matter of taste)
09:20:31 <ski> Cooler : sometimes the strictness analyzer in GHC can figure out such things anyway. but not always
09:20:59 <davean> dmj: you'd need an inner Maybe still
09:21:10 <davean> and "speaking the wrong protocol" is rare, and generally non-recoverable
09:21:16 <davean> which would litter your code with edge case handling
09:21:26 <davean> like C does making you check return codes and errno on every call
09:21:34 <davean> it leads to terrible maintainability and readability
09:21:35 <Cooler> ski, is foldr ever a good idea?
09:21:50 <Cooler> foldr seems always less efficient
09:22:03 <Cale> Cooler: Whenever you want to process a very long or infinite list in a streaming way, or if you're searching through it
09:22:09 <ski> Cooler : `foldr' is good for infinite (or long lists). `foldl' (and its strict version) can't deal with infinite lists
09:22:12 <davean> When the client speaks the wrong protocol, theres generally not much more to do but disconnect them
09:22:19 <glguy> Cooler: foldr just isn't for summing lists
09:22:42 <davean> Where as you expect every connection to close
09:22:47 <ski> sometimes you want to be more eager, sometimes you want to be more lazy
09:23:06 <Cale> Basically, in any case where f might be able to produce some or all of its result using only its first argument, foldr f z might be the way to go
09:23:16 <Cale> because it can short-circuit
09:23:20 <Cale> @src foldr
09:23:20 <lambdabot> foldr f z []     = z
09:23:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:23:31 <Cooler> what? foldr stats evaluating from the right side
09:23:33 <Cale> foldr applies f in the recursive case
09:23:35 <glguy> > foldr (\x xs -> x:x:xs) [] "nope"
09:23:38 <lambdabot>  "nnooppee"
09:23:40 <ski> foldl  and  foldl'  always traverses the input list 'til the end (because they're tail-recursive)
09:23:48 <glguy> Cooler: No, all folds start from the beginning of the list
09:23:49 <Cale> Cooler: remember evaluation is outermost first
09:23:57 * hackagebot servant 0.8.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.8.1 (jkarni)
09:23:59 * hackagebot servant-server 0.8.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.8.1 (jkarni)
09:24:01 * hackagebot servant-client 0.8.1 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.8.1 (jkarni)
09:24:03 * hackagebot servant-docs 0.8.1 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.8.1 (jkarni)
09:24:05 <Cale> foldr is passing control to f there
09:24:06 * hackagebot servant-mock 0.8.1 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.8.1 (jkarni)
09:24:22 <Welkin> what Cooler means to say is that the accumulator is applied at the end of the list first
09:24:27 <Cooler> yes but foldr keeps recursing until theres no list left
09:24:29 <Cale> only if and when the second argument to f gets evaluated will the foldr continue
09:24:32 <Welkin> there seems to be a lot of confusion over that
09:24:33 <Cooler> and then starts returning
09:24:36 <Cale> no
09:24:40 <Cale> > foldr (:) [] [1..]
09:24:41 <Welkin> and some of you make it worse in here by arguing the semantics
09:24:43 <ski> "but foldr keeps recursing until theres no list left" <- no
09:24:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:24:48 <Cale> ^^ this wouldn't work if that were true
09:25:02 <Cale> > foldr (\x xs -> (10*x) : xs) [] [1..]
09:25:04 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
09:25:22 <Cale> > foldr (\x xs -> if x > 1000 then x else xs) 0 [1..]
09:25:25 <lambdabot>  1001
09:25:28 <glguy> Welkin: It's not nitpicking. It's a meaningful misconception
09:25:48 <Cale> Welkin: It isn't, you're also wrong :)
09:25:56 <ski> > foldr (\n f acc -> n : f (n + acc)) undefined [1 ..] 0
09:25:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:26:09 <Welkin> Cale: that is the entire difference between a left and right fold
09:26:12 <Cale> (also, there's no accumulator)
09:27:26 <Welkin> > foldr f g [x, y, z] :: Expr
09:27:27 <Cale> > foldr (\x xs s -> s : xs (x + s)) (const []) [1..] 0
09:27:29 <lambdabot>  f x (f y (f z g))
09:27:30 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
09:27:30 <Welkin> > foldl f g [x, y, z] :: Expr
09:27:33 <lambdabot>  f (f (f g x) y) z
09:27:48 <Welkin> `f g x`  vs `f z g`
09:27:55 <glguy> Welkin: You're getting confused by the fact that in printing out that result you're evaluating the whole thing
09:28:05 <Cale> f z g isn't going to happen until you reach the end of the list
09:28:10 <Welkin> sure
09:28:14 <Cale> and it may not happen at all
09:28:28 <Cale> e.g. ^^ all the examples with infinite lists
09:28:53 <Cale> It's weird to say that foldr f z "starts with" z in any respect, if it might never use z
09:28:58 <Welkin> the distinction matters though
09:29:09 <Welkin> for example, if writing a "remove" function
09:29:15 <Welkin> to remove a value from a list
09:29:21 <Welkin> fildl vs foldr work differently then
09:29:29 <Cale> sure
09:29:38 <Cale> If you were writing filter, you'd want to use foldr
09:29:40 <Cooler> ok so its foldl that starts from the end?
09:29:45 <Cooler> @src foldl
09:29:45 <lambdabot> foldl f z []     = z
09:29:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:29:51 <ReinH> "Arguing semantics", I.e., talking about what things mean, is exactly what people should be doing.
09:30:05 <davean> Cooler: Noen of them start from the end - they both start right at the begining
09:30:07 <Cale> foldl also starts at the beginning in some sense, but it only greedily applies itself to new arguments until it reaches the end of the list
09:30:18 <Cale> So no part of the result can be produced until it hits the end
09:30:28 <monochrom> foldl waits until the right end. but it still starts from the left end.
09:30:32 <Welkin> the dinstinction I am tryin to make is where the accumulator is first used
09:30:40 <Cale> You really just can't start processing a list anywhere except at the beginning of the list
09:30:53 <ReinH> foldr doesn't have an accumulatot
09:31:18 * ski nods to ReinH
09:31:19 <monochrom> consider "foldr (||) False (True : blah)"
09:31:26 <Cale> Yeah, it makes sense to call foldl's second argument an accumulator, but foldr's second argument is not in any sense.
09:31:35 <Welkin> see, it's this that confuses people
09:31:41 <Cale> hm?
09:31:42 <Welkin> why do I see this discussion happen so often in here?
09:31:43 <monochrom> first expansion is "True || foldr (||) False blah".
09:31:44 <ReinH> Understanding that bit of "semantics" is useful in understanding foldr.
09:31:48 <davean> Welkin: I tihnk you're the only one confused here
09:31:53 <Cale> Welkin: Because people aren't used to outermost-first evaluation
09:32:04 <monochrom> THE END. You don't even expand the "foldr (||) False blah" part.
09:32:21 <Cale> The evaluation order in Haskell is literally backwards from every other language you'll have used.
09:32:43 <ReinH> "You're just arguing semantics" is a ridiculous argument when the topic of discussion is literally semantics.
09:33:01 <monochrom> In other words, writing out "foldr (||) False (True : blah)" as "True || (x || (y ||..." is misleading too. You don't even get to see the x and the y and etc.
09:33:05 <Welkin> then the problem is miscommunication
09:33:08 <glguy> ReinH: You're just arguing the semantics of semantics
09:33:19 <ReinH> glguy: yes!
09:33:26 <Welkin> "it starts at the end/beginning" mean different things to everyone then
09:33:29 <Welkin> and that is the problem
09:33:31 <Welkin> what does that mean
09:33:55 <monochrom> This is especially important if "blah" happens to be an infinite list.
09:34:07 <ReinH> Welkin: so your concern is that the semantics haven't been clearly described? I guess we better argue semantics then.
09:34:30 <Welkin> I've run into trouble when I accidentally used a foldl when I should have used a foldr, for example
09:34:32 <monochrom> No one will spend infinite time expanding out the infinitely long expression first.
09:34:35 <Welkin> the order of operations was wrong
09:34:40 <Welkin> it was processing the list backwards
09:34:43 <monochrom> > foldr (||) False (True : repeat False)
09:34:46 <lambdabot>  True
09:34:49 <monochrom> O(1) time.
09:34:51 <davean> Welkin: they're different but that doesn't make it an order of operation thing really
09:35:04 <davean> thats not realyl the core way they're different
09:35:09 <monochrom> Any mental model that does not predict O(1) time for that is wrong.
09:35:20 <Cale> Also, both foldr and foldl are designed to preserve the order of the elements in the list in the expression they produce in terms of f
09:35:31 <Cale> Only the association of the function applications changes
09:35:40 <Cale> http://cale.yi.org/share/Folds.png
09:36:02 <Cale> you'll note that in these diagrams, the 1, 2, 3, 4, 5 stay in that order horizontally
09:36:21 <Welkin> yes, but the output isn't necessarily a list
09:36:29 <Cale> sure
09:36:36 <ejbs> Is there a function that goes through an infinite list until a predicate P is true and then returns that value, continuing off where it stopped next time it is called? Or will I have to write that myself?
09:36:37 <davean> thats why he shows "f"s
09:36:38 <Welkin> if could be something where the order of applications matters
09:36:57 <ejbs> So something like lazyFilter isOdd [1..]
09:37:15 <monochrom> that is "filter" already
09:37:19 <Cale> Welkin: It can't matter which order you evaluate the applications in, except in the case where you do it too strictly and don't terminate.
09:37:38 <Cale> Sorry, monochrom is here, I should say "too eagerly"
09:37:41 <Cale> :)
09:37:44 <monochrom> heh
09:38:11 <ReinH> lol
09:38:16 * ski . o O ( "eager nitpicking" )
09:38:19 <ejbs> monochrom: I ran filter (\n -> not $ n `mod` 2 == 0) [1..] and that wouldn't stop evaluating
09:38:35 <ongy> what's the . o 0 ()?
09:38:42 <ejbs> as in, it collects a list of all the right answers, and that list is of course infinite
09:38:51 <ski> it's supposed to depict a thought bubble
09:38:56 <ReinH> ejbs: yes, that's what a lazy filter would do.
09:38:57 <monochrom> OK, so add pattern matching.
09:39:02 <Cale> Welkin: There is a theorem which says that any order of evaluation which terminates will produce the same result, and it applies basically so long as you're not doing unsafePerformIO's
09:39:18 <ski> > take 10 (filter (\n -> not $ n `mod` 2 == 0) [1..])
09:39:20 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
09:39:21 <monochrom> > case filter (\n -> not $ n `mod` 2 == 0) [1..] of x:xs -> x
09:39:24 <lambdabot>  1
09:39:32 <ski> ejbs : just make sure to only use finitely many elements of the result list
09:39:36 <ski> (as many as you need)
09:39:40 <monochrom> In my example, I haven't used xs. But xs has "the rest".
09:39:56 <ejbs> ReinH: Yeah, I know, I tried... Oooh, okay. What ski said made me get it
09:39:59 <Cale> Welkin: But if we're talking about lazy evaluation (and it's probably a sensible place to begin), that will reduce the outermost application first
09:40:59 <monochrom> Remember that ghci thinks you want to print everything therefore you want everything.
09:41:12 <monochrom> ghci can destroy laziness.
09:41:26 <monochrom> by extension, most things in Debug.Trace can, too.
09:41:39 <ejbs> Yeah, exactly, but if I just put the 'value' of it in a var with let my program won't hang cuz I haven't taken any of it yet!
09:41:40 <monochrom> The want to print things destroys laziness.
09:41:48 <monochrom> Yes.
09:42:12 <ReinH> You also don't need to out value in scare quotes :)
09:42:22 <ReinH> *put
09:42:32 <Welkin> I'd like to point at that claiming "you are the one who is confused here" is not a solution, and in fact shows exactly what the problem is. Your explanations are confusing people, including me. (in reference to davean here)
09:42:41 <Cale> ejbs: Check this out:
09:42:55 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
09:42:59 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
09:43:08 <ReinH> I don't think it was intended to be a solution.
09:43:30 <ejbs> ReinH: I guess it's a value, but it's more like a thunk than like 'the actual value', right? Maybe you guys don't have to think about it that much though haha 
09:43:31 <Cale> Oh, sorry, this just randomly turns out to be similar to what you're doing :)
09:43:49 <ejbs> Cale: Oh yeah, that's cool
09:43:53 <ejbs> And makes sense hehe
09:44:03 <ReinH> thanks are an implementation detail of values.
09:44:12 <ReinH> Thunks
09:44:19 <ReinH> Stupid autocorrect
09:44:24 <ejbs> Yeah, you're right about that
09:44:29 <monochrom> Yeah, ReinH means you can just say value without quotes.
09:44:48 <Cale> I just wanted to demonstrate that definitions can refer to one another mutually like that, so you start using odds and evens to compute each other before either of them is done.
09:44:52 <davean> Welkin: No, actually I was pointing out you came in with self-contradictory beliefs
09:45:13 <davean> Welkin: When one's model isn't interally consistent, it often points to its own solution
09:45:55 <davean> Consider the constant-time-on-infinite-list examples
09:47:11 <Cale> I think the problem is really just that Welkin is saying things in a way that is suggestive of evaluation order, while really what is meant has something to do with the way the expression is associated.
09:47:38 <Welkin> I don't see what is self-contradictory about anything I said
09:47:55 <Welkin> > foldr (:) [] "Grasshopper"
09:47:58 <lambdabot>  "Grasshopper"
09:48:10 <Welkin> > foldl (flip (:)) [] "Grasshopper"
09:48:12 <lambdabot>  "reppohssarG"
09:48:55 <monochrom> It takes conscious effort to disconnect evaluation from parsing. HIghschool algebra brainwashes people to bundle them. "1+(2+3)" they taught you to compute the parenthesized part first.
09:49:02 <Welkin> (also, why does foldl expect it's folding function to take the parameters backwards?)
09:49:06 <Welkin> Elm fixed this
09:49:17 <monochrom> In Haskell "1+(2+3)" only tells you how to parse.
09:49:19 <Cale> > foldr (\x xs -> concat ["(f ",show x," ",xs,")"]) "z" "Grasshopper"
09:49:22 <lambdabot>  "(f 'G' (f 'r' (f 'a' (f 's' (f 's' (f 'h' (f 'o' (f 'p' (f 'p' (f 'e' (f 'r...
09:49:40 <Cale> > foldl (\xs x -> concat ["(f ",xs," ",show x,")"]) "z" "Grasshopper"
09:49:41 <ski> (in short : unlearning (specifically distinguishing between previously identified/conflated) notions is hard)
09:49:43 <lambdabot>  "(f (f (f (f (f (f (f (f (f (f (f z 'G') 'r') 'a') 's') 's') 'h') 'o') 'p') ...
09:49:55 <Welkin> I understand the difference between foldr and foldl
09:50:32 <Welkin> I am talking about how it affects the result though
09:50:37 <Welkin> like in the example I just showed
09:50:48 <Cale> In a way, foldl starts at the end of the list -- only its work has really been completed by that point. :)
09:50:58 <ski> Welkin : "why does .." -- one way to answer is that it's because of `foldl1' and `foldr1'
09:51:35 <Cale> It walks all the way to the end of the list, building up an expression whose outermost application involves the latest element of the list.
09:51:42 <ski> > foldr1 (+) [x,y,z]
09:51:46 <lambdabot>  x + (y + z)
09:51:47 <ski> > foldl1 (**) [x,y,z]
09:51:49 <lambdabot>  (x**y)**z
09:51:58 <Cale> and so once it finishes its task, you end up with an expression whose evaluation will begin with the end of the list
09:52:16 <ski> iow, they wanted one to be a differently associated version of the other, without having to flip the function argument
09:54:05 <ski> (however, iirc, in SML they have the same signature ..)
10:13:48 <ejbs>  Could not deduce (a ~ [a]) what does the tilde mean?
10:14:13 <kadoban> ejbs: It's type equality, or something similar
10:14:36 <kadoban> ejbs: It likely means you're treating a list as an element of a list, or the other way around.
10:14:49 <ejbs> Yeah, alright. I'll solve it!
10:16:00 <ejbs> Can I trace calls in ghci?
10:16:10 <et09> yes
10:16:18 <et09> https://wiki.haskell.org/Debugging
10:18:59 * hackagebot lentil 1.0.1.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.0.1.0 (fffaaa)
10:21:13 <et09> https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/ghci-debugger.html or more appropriate maybe
10:25:33 <puregreen> can anyone recommend a plotting library that works on Windows? maybe something browser-based
10:25:54 <puregreen> (I need something that can do 2D heatmaps, to be precise)
10:26:09 <Welkin> in haskell?
10:26:33 <puregreen> yep
10:26:49 <lightly> what's that paper/tutorial that explains the tricky parts of Haskell like I/O, exceptions?
10:26:53 <lightly> I think it's famous
10:27:05 <dmj> lightly: something about bananas and barbed wire
10:27:08 <puregreen> Tackling the Awkward Squad
10:27:21 <puregreen> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf
10:27:25 <et09> http://haskelldata.com/
10:27:50 <Welkin> puregreen: ihaskell? https://github.com/gibiansky/IHaskell
10:28:41 <et09> i would opt for an FFI for visualization 
10:29:16 <puregreen> Welkin: hm, the last time I tried to install IHaskell it was hard even on Linux but maybe I just got unlucky
10:29:34 <et09> https://wiki.haskell.org/Applications_and_libraries/Mathematics#Plotting
10:29:40 <et09> those are most of your options tho 
10:29:58 <puregreen> gnuplot×3, cairo×2
10:30:12 <puregreen> does Cairo install on Windows?
10:30:29 <et09> yes
10:32:10 <puregreen> okay, thanks, I'll investigate it when I get ahold of a Windows machine
10:37:41 <athan> I wish there was a monoid for Constraints
10:37:53 <athan> like a tuple for mappend and a unit for mempty
10:38:12 <athan> where deducability is the subject of the monoid I guess
10:38:32 <athan> actually an abelian monoid, but still
10:39:29 <LordBrain> maybe with constraintkinds you can get close?
10:39:31 <athan> And a first-class one, too, so `(,) :: Constraint -> Constraint -> Constraint` and `Unit :: Constraint`
10:39:47 <athan> LordBrain: Eh, I think you can do this
10:41:56 <athan> -XTypeOperators; class (a,b) => (a :: Constraint) ::+:: (b :: Constraint)
10:41:56 <athan> and class Unit (a :: k)
10:41:57 <athan> and then just make instances the same way
10:41:57 <athan> er
10:41:57 <athan> Unit should just be `class Unit` I think
10:45:24 <athan> hmm, class (a :: Constraint) ::+:: (b :: Constraint); instance (a,b) => a ::+:: b; avoids -XUndecidableSuperClasses
11:01:51 <ph88> bartavelle, are you here ?
11:03:41 <ph88> guys, how do i use wl-pprint ?
11:05:37 <Clint> ph88: ask a better question
11:07:35 <Hackrilege> Is there a way to pattern match on dataypes constructor wrapped up as a method of a class, e.g. class Consable f a where cons :: a -> f a -> f a
11:07:52 <ph88> Clint, i have a datastructure with Text and positing information ... to be honest i'm not even sure why i should use this package ..
11:08:29 <Clint> ok
11:09:02 <ph88> do you think this package is a good one to write back the source code to a file ?
11:09:19 <Hackrilege> to be used eg f :: Consable c => c -> ...; f (cons x as) = ...
11:09:23 <ph88> it would be nice to also be able to output it to the terminal in colors or to a html page .. but that is secondary
11:10:35 <ph88> can the pretty print package also just print without making it pretty ?
11:11:11 <Clint> you can certainly print things that doesn't look pretty
11:12:04 <ph88> i'm not sure how to get started ..
11:12:15 <sm> I think printing in colours for the web is a job for highlighting-kate or highlighter
11:12:45 <sm> the "PrettyPrint" libraries are more about breaking lines in the right place ? I could be wrong
11:12:56 <Hackrilege> I guess I can't pattern match on 'cons' like this because it's not a datatype constructor starting with a capital letter. I'm not sure but I guess it would also not work if cons was defined as an infix symbol. Maybe I can do it with type family's exporting a datatype and pattern matching its constructor. Any ideas? Will this work?
11:13:04 <Clint> sm: and colors
11:13:08 <ph88> sm, ah it's for breaking lines? ok i didn't know ^^
11:13:24 <Clint> indentation and alignment and colors and such
11:13:30 * sm hasn' grokked them either, clearly
11:13:45 <ph88> is there a mode where it doesn't apply any pretty functionality and just output the source code as is ?
11:13:53 <Clint> i don't know what you mean by "source code"
11:14:06 <ph88> the parsed source code
11:14:23 <ph88> source file -> parser -> concrete syntax tree -> printer -> source code
11:14:39 <hpc> Hackrilege: check out view patterns
11:14:51 <Hackrilege> Thanks
11:14:57 <Clint> presumably you have a Show instance for your "non-pretty" and a Pretty instance for your "pretty"
11:15:04 <hpc> Hackrilege: class Consable f a where cons :: f a -> (a, f a), or something like that
11:15:28 <ph88> Clint, how do i make a show instance ?
11:16:07 <Clint> ph88: ghc can probably derive one for you automatically
11:16:46 <Hackrilege> So long as I can pattern match on it. Basically I would like definitions which work over list to be translated so they work in anything Consable, so I need to pattern match like I would on (:)
11:17:05 <ph88> Clint, then how can i print it back to source file ?
11:18:07 <Clint> ph88: i guess you need something that's the inverse of your parser
11:18:21 <hpc> Hackrilege: maybe you want Foldable or Traversable then?
11:18:24 <mnoonan> Hackrilege: do you need to construct via cons too? can view patterns do what you want?
11:18:56 <hpc> Hackrilege: and then you can use the generic foldr or something similar
11:18:58 <ph88> Clint, i thought the wl-pprint package WAS the inverse of the parser ... o_O
11:19:36 <Clint> ph88: only if you write the instance that way
11:19:51 <Hackrilege> I should like to be able to simply replace (ctrl+h) : with ::: exported by Consable
11:20:36 <Hackrilege> Obviously changing the type manually to include a Consable constraint
11:21:24 <ph88> Clint, eh i'm confused now, you just said ghc can probably derive the instance automatically .. and now you suggest i write it myself ?
11:22:48 <Hackrilege> So that as long as there exists a well defined method to append an element and pattern match on it, functions defined over list should work on eg Consable Tree with simple translation
11:25:50 <mnoonan> Hackrilege: what about pattern synonyms? I think this might solve your use case: https://ghc.haskell.org/trac/ghc/ticket/11461
11:26:03 <Hackrilege> View types look hopeful but can't I do it eg just exporting (:::) by Consable? I'm just firing up my analog machine to check in ghc...
11:26:50 <mnoonan> I didn't suggest it before because you can't bundle them into typeclasses, but the trick with the constraint on the pattern seems like a good enough workaround
11:29:05 <Hackrilege> It says it is disallowed to bundle a pattern synonym with a type class
11:29:36 <Clint> ph88: it can derive a Show instance, which is not what you want if you want to transform some AST into something else
11:29:47 <Hackrilege> I'll get my compile on it give me two minutes
11:31:19 <Hackrilege> a compileon is the exchange particle mediating the compilational force
11:31:55 <ph88> Clint, i'm checking this tutorial now .. at least it's something to go on .. cuz i don't know where to start  http://watchchrislearn.com/blog/2015/01/20/pretty-printing-a-tree-with-text-dot-prettyprint/
11:32:34 <bjorn__> httpLbs gives me a bytestring, how to turn it into a string?
11:32:47 <Welkin> why do you want a string?
11:35:08 <bjorn__> for next step processing
11:35:18 <monochrom> yes, it depends on why you want a string.
11:35:19 <bjorn__> with the library Feed
11:35:23 <bjorn__> parseFeedString 
11:35:47 <monochrom> perhaps do a utf-8 decode? the "text" library can do it.
11:35:48 <bjorn__> i use httpLbs to get a RSS feed
11:36:16 <bjorn__> then i use Feed to parse it
11:36:24 <bjorn__> which needs a string as input
11:37:17 <EvanR> utf8 decode all the things
11:37:34 <glguy> Assuming the ByteString is UTF-8 encoded , you can use toString from  http://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-UTF8.html 
11:37:38 <ph88> Clint, i see in the documentation https://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.3/docs/Text-PrettyPrint-ANSI-Leijen.html  that i can choose from a view instances .. should i choose the Pretty one ?
11:38:01 <ParseError> Hi, I'm trying to fix a source file from a year ago. It has a parse error on a do block within a let statement within a do block 
11:38:01 <glguy> Or decode the ByteString to a Text and unpack the Text to a String using text package
11:38:16 <ParseError> did something change with nesting do's and let's? 
11:38:32 <kadoban> ParseError: Nope
11:38:38 <ParseError> weird
11:39:06 <glguy> With a name like that, it's not surprising your file doesn't parse
11:39:22 <monochrom> haha
11:39:34 <monochrom> no, you got the cause and effect wrong :)
11:40:02 <ParseError> ohhh, it's just printing my username. everything works fine
11:40:11 <glguy> ^_^
11:40:12 <kadoban> xD
11:40:21 <monochrom> Yeah
11:40:31 <glguy> http://lpaste.net if you want to share the problem code
11:40:50 <monochrom> > putStrLn "<IO ()>"
11:40:52 <glguy> Maybe we can make more sense of things that way
11:40:53 <lambdabot>  <IO ()>
11:41:04 <Clint> ph88: personally i'd use wl-pprint-terminfo instead but to answer your question I don't know what other typeclass would be relevant
11:41:17 <ParseError> i'm guessing stack doesn't use another parser either
11:41:30 <monochrom> no, stack just calls ghc
11:43:17 <ParseError> http://lpaste.net/183082 here you go, error is on line 150. the problem really is about the do/let/do. I tried swapping the let blocks to check.
11:44:05 <ParseError> > parse error (possibly incorrect indentation or mismatched brackets)
11:44:07 <glguy> ParseError: the do block should be more indented than "go"
11:44:08 <lambdabot>  error:
11:44:08 <lambdabot>      Variable not in scope: parse :: ([Char] -> a0) -> t0 -> terror:
11:44:08 <lambdabot>      Variable not in scope:
11:44:48 <ph88> hey guys this package only seems to have a method to go from String to Doc .. i only work with Text .. should i use a different package or unpack my Text back to String to make a Doc ?
11:45:03 <monochrom> if this was accepted by an old compiler, I want to know which. This is supposed to be a parse error due to not enough indentation.
11:45:37 <ParseError> thanks! it works!
11:45:51 <glguy> Perhaps that would be accepted with the NondecreasingIndentation extension
11:46:36 <monochrom> In fact, you can delete the second "let" now. You can use one single "let" for both go and finish.
11:47:03 <Clint> ph88: https://hackage.haskell.org/package/wl-pprint-extras-3.5.0.5/docs/Text-PrettyPrint-Free.html#v:pretty has Pretty instances for Text
11:47:04 <monochrom> And this is why part of go has to be more indented than go, and part of finish has to be more indented than finish.
11:47:34 <joe9> Is there a haskell library that can convert/translate/transform a value within (10 .. 50) to a value with (0  .. 10) ?
11:47:37 <hackrilege> ok - i wrote up the simple case; http://lpaste.net/183083
11:47:43 <lpaste> glguy pasted “surprisingly works for me” at http://lpaste.net/183085
11:47:53 <ParseError> monochrom: the last time it compiled successfully was on 2013 okt 25, and I updated regularly back then
11:47:57 <monochrom> joe9, that seems to be off by 1.
11:48:01 <joe9>  http://dpaste.com/1WXD7Y2 I can do that manually  as in line 30
11:48:13 <monochrom> Err no, nevermind
11:48:17 <glguy> monochrom: Do check out my paste
11:48:31 <glguy> Would you have expected that to work?
11:48:45 <joe9> monochrom: I am writing a simple scale module to help with a simple chart
11:49:02 <joe9> monochrom: and, I think there might be something in haskell library that can do such transformations.
11:49:10 <monochrom> glguy, no.
11:50:11 <ph88> oh there is a wl-pprint-text .. interesting ..
11:50:36 <monochrom> now this is interesting. why is it sometimes an error and sometimes not?
11:51:13 <ParseError> maybe it accepts when there's no ambiguity? 
11:51:24 <ParseError> like when there's only one difinition
11:52:12 <monochrom> but you had only one definition, too.
11:56:09 <ParseError> who knows, maybe it's about spaces/tabs. how silly that "let " is four chars wide.
11:56:10 <monochrom> yeah, so far I have to turn on NoNondecreasingIndentation to get an error
11:57:02 <hackrilege> this was basically what i was thinking of doing, but i dont think it will work; http://lpaste.net/183098
11:59:26 <hackrilege> i want a class to export a type constructor synonym
11:59:49 <ParseError> maybe stack calls ghc with stricter rules? dunno, the guy who wanted to use my code is using it for a CLaSH project
12:00:35 <hackrilege> that makes no sense to me sorry
12:01:26 <hackrilege> oh your talking about a different stack.. sorry crossed threads
12:01:43 <Enigmagic> domain_convolutions = []
12:01:44 <Enigmagic> for width in xrange(2, 7):
12:01:44 <Enigmagic>     with tf.variable_scope("ngram_convolution_{}".format(width)):
12:01:44 <Enigmagic>         convolution_filter = tf.Variable(
12:01:44 <Enigmagic>             tf.random_normal(
12:01:44 <Enigmagic>                 shape=(width, vocab_size, vocab_size*width)),
12:01:44 <Enigmagic>                 name="filter")
12:01:45 <Enigmagic>         domain_convolutions.append(
12:01:45 <Enigmagic>             tf.nn.conv1d(
12:01:46 <Enigmagic>                 value=z0,
12:01:46 <Enigmagic>                 filters=convolution_filter,
12:01:47 <Enigmagic>                 stride=1,
12:01:47 <Enigmagic>                 padding="VALID"))
12:01:52 <Enigmagic> bah shit
12:02:19 <Enigmagic> don't code and eat lunch at the same time
12:02:38 <Gurkenglas> For what f can I combine some LensLike f s t a b and some LensLike' f a b into some LensLike' f s t?
12:03:12 <joe9> monochrom: do you think I can use Data.LinearMap? I am not a math guy and I do not understand the library
12:03:25 <monochrom> which package is it?
12:03:25 <joe9> monochrom: and there are no easy examples to understand it.
12:03:45 <joe9> monochrom: vector-space
12:04:05 <Gurkenglas> (Specifically I wanted to somehow use _head to get a Traversal' [([a], Double)] [(a, Double)])
12:04:45 <ParseError> you guys are great! thx <3
12:05:37 <asthasr> Is there a library for generating JSON Schemas as defined in Haskell types?
12:05:38 <monochrom> This is pretty abstract. But probably no. "linear" in vector space parlance, then specialized to one dimension, means scaling only, no translation. In that parlance, (\x -> 5 * x) is linear, (\x -> 5 * x + 10) is not (it is "affine" not "linear").
12:05:52 <asthasr> that is, I'd like to be able to write Haskell and use that to produce a schema, not the other way around.
12:06:01 <monochrom> which of course is a different convention from highschool algebra's "it's 'linear' because it's a line"
12:06:13 <joe9> asthasr: aeson can do that automatically.
12:06:26 <asthasr> is there an example of it?
12:06:30 <lenshelp> Using lens aeson, given "[{ \"name\": \"nameX1\", \"config\": { \"connectTarget\": \"prod\" }}, { \"name\": \"nameY1\", \"config\": { \"connectTarget\": \"prod\" }}]" how would I set connect target to "preprod" if the name contains "X"? I have a feeling I'll be using set and over but can't seem to put it together. I feel that if I could view just the items in the list containing X I might be able to figure it out from there. Can 
12:06:44 <joe9> asthasr:  there are different ways. check out the aeson package
12:06:50 <joe9> asthasr: it has  examples
12:10:54 <joe9> I am searching for a scaling function that can transform a value in the range (10 .. 50 ) to a value in the range of (0 .. 10). Is there any haskell library that can provides it? I do not understand the vector-space LinearMap library, hence, I do not know if it can do it.
12:11:55 <suzu> why not write it?
12:12:13 <hackrilege> aha this is great, i found the original Wadler paper on views and now i know what he was talking about when he said if i could redo haskell he would have done snoc lists better, his use of views in patterns and expressions demanding an inverse mapping to the view type never caught on
12:12:16 <suzu> take the input, subtract 10, divide by 50, multiply by 10?
12:12:17 <Gurkenglas> lenshelp, try 'values . filtered (anyOf (key "name") (elem 'X')) . key "config" . key "connectTarget" .~ "preprod"'. Assuming that you simply dont want to do anything if there is no name.
12:12:23 <suzu> joe9 ^
12:13:33 <hackrilege> it seems i want Wadler views, but apparently these mess with equational reasoning
12:13:46 <hackrilege> does anyone know what that means?
12:13:59 <ReinH> hackrilege: like in Seq?
12:14:05 <hackrilege> http://homepages.inf.ed.ac.uk/wadler/papers/view/view.ps
12:14:23 <hackrilege> i dont know anything about Seq...
12:15:00 <joe9> suzu:  I do not want to write something that might already be in a library.  http://dpaste.com/1TQ0688 is where I want to use it. Line 30
12:15:00 <ReinH> https://www.stackage.org/haddock/lts-6.14/containers-0.5.6.2/Data-Sequence.html#t:ViewL
12:15:38 <suzu> joe9: looks like it's working then?
12:15:44 <ReinH> hackrilege: viewin and viewout are nicely packaged as Isos
12:15:48 <suzu> are you familiar with the left-pad fiasco?
12:15:52 <Gurkenglas> How do I get some Traversal' ((a, b), c) (a, c)?
12:15:53 <suzu> in node.js-land
12:15:56 <joe9> suzu, I want to make it more general. the ( 10 .. 50) and (0 .. 10), they could be different each time.
12:15:58 <hackrilege> viewL looks very much like what im talking about thanks
12:16:07 <suzu> ah ok
12:16:11 <ReinH> hackrilege: yeah, it's caught on in a few places
12:16:18 <suzu> well, you take the process i just described
12:16:20 <suzu> and parameterize it
12:16:54 <suzu> subtract inputMin, divide by inMin / inMax, multiply by outMax - outMin, add outMin
12:17:04 <suzu> err sorry
12:17:11 <suzu> subtract inputMin, divide by inMin - inMax, multiply by outMax - outMin, add outMin
12:17:28 <joe9> ok, Thanks.
12:17:30 <suzu> something like that
12:18:17 <joe9> suzu: http://dpaste.com/14MY2RT line 30 like this?
12:18:33 <suzu> sure
12:18:36 <suzu> use some where-clauses
12:18:51 <suzu> to reduce the noise and add a bit more meaning to the different values here
12:18:57 <suzu> that'd be good in my opinion
12:19:09 <hackrilege> i cant find methion of viewin viewout or Isos though
12:19:18 <hackrilege> mention*
12:20:36 <Gurkenglas> lenshelp, did that work?
12:21:06 <lenshelp> This is almost working, but it seems the setter needs to be of type "Value -> (a -> Const (Data.Monoid.First a) a) -> Value" according to this line where I inserted a type hole: :t "[{ \"name\": \"nameX1\", \"config\": { \"connectTarget\": \"prod\" }}, { \"name\": \"nameY1\", \"config\": { \"connectTarget\": \"prod\" }}]" ^? values . filtered (anyOf (key "name" . _String) (T.isInfixOf "X")) . key "config" . key "connectTarget" _ 
12:21:12 <lenshelp> Gurkenglas: ^^^
12:21:15 <ReinH> hackrilege: I mean that viewin and viewout, as described in that paper, are nicely packaged up in Isos, as implemented in lens.
12:21:57 <ReinH> Although in some cases attempting to do so points out flaws in the original viewin viewout pair
12:22:19 <ReinH> as with integers and lazy nats (for multiple reasons, in fact)
12:22:51 <hackrilege> i would prefer this feature without the rest of lens, so im going to try to implement it
12:22:53 <lpaste> mnoonan pasted “View pattern for :::” at http://lpaste.net/183114
12:23:04 <ReinH> I'm not saying you *need* lens
12:23:07 <mnoonan> ^ that's the best I've been able to figure out so far, hackrilege
12:23:40 <mnoonan> you get destructuring matches with :::, but not a constructor
12:23:55 <joe9> suzu: any suggestions how I can do logarithmic scaling ? http://dpaste.com/203KHVY
12:24:18 <ReinH> I'm just saying that the a (well-behaved) viewin viewout pair is an isomorphism, and that isomorphisms are implemented in lens.
12:24:18 <suzu> sure
12:24:21 <ReinH> s/the //
12:24:26 <Gurkenglas> lenshelp, ^? will give you back the current connect target wrapped in Just if there is one and the name contains X. if you want to set, you need to use something else
12:24:29 <suzu> what kind of transformation are you looking for joe9 ?
12:24:50 <hackrilege> thanks!!
12:25:15 <ReinH> joe9: steal d3.js's implementation?
12:25:17 <Gurkenglas>  :t "[{ \"name\": \"nameX1\", \"config\": { \"connectTarget\": \"prod\" }}, { \"name\": \"nameY1\", \"config\": { \"connectTarget\": \"prod\" }}]" & values . filtered (anyOf (key "name" . _String) (T.isInfixOf "X")) . key "config" . key "connectTarget" .~ "preprod" -- this should give you the json value that had its connection target changed to preprod if the name contains X
12:25:25 <suzu> you could simply let y = log_k x to convert x to a k-magnitude logarithmic scale
12:25:40 <mnoonan> I guess you really just need "Unconsable" for that case..
12:25:43 <Gurkenglas> ((&) is just a -> (a -> b) -> b)
12:26:27 <hackrilege> Deconstructable
12:26:38 <joe9> ReinH: yes, I want to recreate d3.js stuff with diagrams. With haskell's math stuff, I presume that it would be there in some library. https://github.com/joe9/baby-steps-to-building-a-chart-with-diagrams is what I am doing.
12:26:40 <ReinH> joe9: have you tried to compile this? minRange = sMinRange should be a type error, ditto maxRange = sMaxRange
12:26:57 <joe9> ReinH: It works. I just tested it too.
12:27:05 <hackrilege> I prefer Stack with push and pop
12:27:11 <Gurkenglas>  :t "[{ \"name\": \"nameX1\", \"config\": { \"connectTarget\": \"prod\" }}, { \"name\": \"nameY1\", \"config\": { \"connectTarget\": \"prod\" }}]" & values . filtered (anyOf (key "name" . _String) (T.isInfixOf "X")) . key "config" . key "connectTarget" . _String .~ "preprod" -- lenshelp, actually this as I just noticed the String part.
12:27:23 <ReinH> joe9: I don't believe you. minRange :: s -> Double, sMinRange :: Double
12:27:26 <joe9> ReinH: http://bpaste.net/show/76c2d6c1d04b
12:27:48 <joe9> ReinH: latest code: http://dpaste.com/1K7MAVK
12:28:03 <suzu> lol ReinH 
12:28:36 <ReinH> oh, never mind
12:28:40 <joe9> ReinH: http://bpaste.net/show/de523054388f
12:28:52 <ReinH> you're using the field accessor, not the value of the field itself
12:29:08 <hackrilege> its a shame not to be able to contruct using "pattern"
12:29:10 <ReinH> silly me
12:30:11 <joe9> ReinH: Any suggestions on how I can get some more of d3.js's stuff to haskell land. I love the d3.js philosophy of providing primitives and letting the user build the chart. I wish it could be done with haskell and diagrams.
12:30:26 <ReinH> I would suggest implementing lots of d3.js in Haskell.
12:30:38 <ReinH> and providing it as a library
12:30:40 <ReinH> or a set of libraries
12:31:00 <ReinH> Then one could use them with diagrams
12:31:23 <joe9> ReinH: I am not a math guy and the math code in d3.js (for calculating tickStep, scales, etc. trip me)
12:33:29 <joe9> the problem that I encountered is the svg + webbrowser architecture does not scale above a few thousand values.
12:34:04 <joe9> I think the range of haskell + gtk will be atleast 100k or so for simple charts.
12:36:11 <lenshelp> Gurkenglas: Indeed that worked! Thank you!
12:38:16 <ReinH> I mean, the math is the thing you're trying to implement
12:38:45 <ReinH> the algorithm should be the same regardless of the scale
12:41:17 <hackrilege> ohh i realised something about a recent discussion about Applicative without Alternative.
12:41:31 <hackrilege> the criticism was that this was just Monoid
12:42:04 <hackrilege> but i cant write instance Monoid (f a) => Something f where
12:42:32 <hackrilege> i should write Alternative f => Something f where
12:43:03 <hackrilege> but then im forced to define Applicative behaviour, when all i want is Monoid (f a)
12:44:14 <hackrilege> so i propose a class wrapping (<|>) and its identity on its own without the Applicative constraint
12:45:16 <lyxia> Applicative has arguments of different types with <*>
12:45:21 <lyxia> good luck doing that with a monoid
12:45:46 <hackrilege> the class Consable above is sufficient to provide overlapping Foldable and Alternative instances, except for requiring the Alternative constraint
12:46:32 <hackrilege> and then further to provide Monad and CoMonad overlapping instances also
12:46:40 <shachaf> Unless it was... A monoid in the category of endofunctors with Day convolution tensor product!
12:47:07 <hackrilege> whats  Day convolution?
12:47:41 <hackrilege> i can see https://ncatlab.org/nlab/show/Day+convolution
12:48:14 <lyxia> hackrilege: I can't find Consable above. How long ago was it mentionned?
12:48:33 <hackrilege> coends and profunctors, oh my days
12:48:45 <hackrilege> http://lpaste.net/183114
12:48:54 <hackrilege> lyxia^
12:50:09 <lyxia> thanks
12:51:29 <jle`> is there any comparison anywhere on System.Random + MonadRandom vs. System.Random.MWC ?
12:51:32 <lyxia> Oh right I misread you were saying Alternative is like Monoid. Nevermind me.
12:52:02 <jle`> afaik MonadRandom/System.Random has a bit of a simpler interface but mwc-random feels a little more performance/cryptographically secure-focused?
12:52:17 <jle`> is mwc-random more performant in generanl case?
12:53:55 <jle`> the docs for mwc-random only compare it to merseinne-random
12:55:58 <jle`> oh wait, mwc-random is not cryptographically secure, just suitable for statistical purposes
12:57:19 <hackrilege> i was saying that Alternative without Applicative is a thing. the argument against that was that it was just Monoid, but it isnt, its Monoid (f a) regardless of a
12:57:57 <EvanR> how does one come the conclusion that any rng software is cryptographically secure
12:58:59 <EvanR> look for the "approved by the NSA" label </joke>
12:59:49 <hackrilege> i guess you just require good random, that cant be inferred from your encrypted packets
13:00:40 <hackrilege> i mean i imagine thats what you mean by cryptographically secure random number generators
13:01:58 <hackrilege> so as it would depend on the method used to infer your rng, i guess it would be pretty hard to determine, as this requires information form the intruder
13:05:58 <hackrilege> i guess its about brute force attack on hmac signed data
13:09:49 <jle`> i just care about performance and suitability for statistics
13:12:04 <hackrilege> uninvertable mappings require various density preserving functions like modulo addition and bitflips
13:12:49 <hackrilege> so i guess a hash function should be a good addition to a rng
13:14:15 <hackrilege> assuming the composition of these functions gives good this density preserving property to the hash function, which i suppose all good hash functions ensure
13:16:12 <hackrilege> and making it much harder to infer the rng of course, even if the hash function is guessed to be common, so long as it resits attack, so should your rng
13:19:17 <hackrilege> as far as suitability for statistics, that the hash function is secure implies that the artifacts for its use in an rng are at least difficult to determine, and this implies a lack of correlation. it certainly adds noise, but its statistically well behaved noise in that it contains no determinable pattern
13:20:06 <hackrilege> from* its use
13:20:26 <EvanR> jle`: ive heard good things about mwc random, and am impressed with the speed and the diehard results when i did them on my own implementation
13:21:16 <hackrilege> knuth bigints method is reasonable for scientific monte carlo for example
13:21:33 <hackrilege> (not using a hash)
13:21:59 <hackrilege> just prime modulo
13:24:28 <hackrilege> Fisher–Yates shuffle looks good
13:25:40 <WarDaft> I'm having some trouble with a type signature... `forall c b x y. (Monoid b, c x, c y) => (forall a. c a => a -> b) -> (x,y) -> b`. GHC says things like it cannot deduce (c0 x, c0 y) or (c a), and suggests AllowAmbiguousTypes.
13:25:50 <EvanR> why was 6 afraid of Fisher? because Fisher-Yates 9
13:26:01 <hackrilege> oops no that requires a rndom number sorry, still looking for that bigints fortran paper
13:26:06 <glguy> WarDaft: Nothing specifies what c is going to be
13:26:14 <WarDaft> When I do allow ambiguous types, and fill in both `c` and `b` with a type application, it works, but if not, it doesn't typecheck.
13:26:35 <EvanR> AllowAmbiguousTypes seems like a dubious suggestion
13:27:29 <jle`> thanks EvanR 
13:28:02 <WarDaft> The function passed should specify c, shouldn't it? For example, if I give it `show`, then why wouldn't c be inferred as Show?
13:28:23 <jle`> WarDaft: remember that 'show' takes actual values
13:28:31 <jle`> so ghc isn't sure what value to pass in
13:29:12 <jle`> (Right 1 :: Either String Int) and (Right 2 :: Either Bool Int) are different values
13:29:26 <jle`> if i show (Right 1), which one should be passed to show?  it's not clear
13:29:56 <jle`> "cannot deduce" usually means that ghc can't figure out what instance to use for your types
13:30:13 <jle`> it could be Either String Int, or Either Bool Int, or Either Void Int ... who knows?
13:30:36 <WarDaft> I'm aware of that. The thing is, it seems to be trying to deduce some other constraint that can't be unified with c.
13:31:36 <jle`> can you post your error and your functino definition?
13:31:58 <ben> > 42
13:32:00 <lambdabot>  42
13:32:03 <ben> Can lambdabot snippets define types?
13:32:16 <glguy> WarDaft: Constraints don't match like that
13:32:29 <WarDaft> I see.
13:32:29 <jle`> you can declare types in lambdabot's scope with @let
13:32:36 <jle`> @let Foo = Foo Int deriving Show
13:32:36 <lambdabot>  Parse failed: Parse error: deriving
13:32:44 <jle`> aw
13:32:49 <jle`> @let data Foo = Foo Int deriving Show
13:32:51 <lambdabot>  Defined.
13:32:55 <jle`> > Foo 10
13:32:58 <lambdabot>  Foo 10
13:36:12 <monochrom> I wonder if I can give lambdabot my own instance code too
13:36:18 <WarDaft> https://gist.github.com/anonymous/e81e0eaff8348bc234d834a65e9cfdc4
13:36:42 <monochrom> @let data Monochrom = Monochrom; instance Show Monochrom where show _ = "<IO ()>"
13:36:44 <lambdabot>  Defined.
13:36:48 <monochrom> > Monochrom
13:36:50 <lambdabot>  <IO ()>
13:36:53 <monochrom> neat
13:37:16 <WarDaft> If nothing else, I can just use ambiguous types and hopefully fill in everything nicely with type application in a wrapper function.
13:37:22 <monochrom> yeah I guess it basically jump dumps everything in a file and load it
13:37:53 <ben> @let newtype Foo x = Foo (Foo x -> x)
13:37:53 <ben> > let y (Foo x) = x (Foo x) in y (Foo y) `seq` print 42
13:37:54 <lambdabot>  .L.hs:193:1: error:
13:37:54 <lambdabot>      Multiple declarations of ‘Foo’
13:37:54 <lambdabot>      Declared at: .L.hs:185:1
13:37:56 <lambdabot>  error:
13:37:56 <lambdabot>      • Couldn't match expected type ‘Foo -> t’ with actual type ‘Int’
13:37:56 <lambdabot>      • The function ‘x’ is applied to one argument,
13:38:09 <ben> @unlet Foo?
13:38:09 <lambdabot>  Parse failed: Parse error: EOF
13:38:26 <monochrom> I don't think there is a selective unlet.
13:38:50 <monochrom> you can only do a wholesale @undefine to erase everything
13:38:55 <geekosaur> there isn't
13:39:01 <ben> gee I wouldn't want to undefine other people's things
13:39:10 <monochrom> And I am not against erasing everything. I don't miss them.
13:39:43 <monochrom> There is an implicit contract that says that everything you add by @let is understood to be of temporary significance.
13:40:11 <ben> @undefine
13:40:11 <lambdabot> Undefined.
13:40:17 <ben> @let newtype Foo x = Foo (Foo x -> x)
13:40:17 <ben> > let y (Foo x) = x (Foo x) in y (Foo y) `seq` print 42
13:40:19 <lambdabot>  Defined.
13:40:20 <lambdabot>  error: Not in scope: data constructor ‘Foo’
13:40:26 <ben> Did I race
13:40:28 <ben> > let y (Foo x) = x (Foo x) in y (Foo y) `seq` print 42
13:40:31 <lambdabot>  <IO ()>
13:40:34 <ben> oh right.
13:40:39 <ben> > let y (Foo x) = x (Foo x) in y (Foo y) `seq` 42
13:40:44 <ben> I'll stop now.
13:40:45 <lambdabot>  mueval-core: Time limit exceeded
14:03:08 <nitrix> int-e: Are you agaisn't having a stack.yaml file for lambdabot ?
14:03:36 <nitrix> int-e: I'm trying to get it to compile and it's been a real pain so far. Making progress, but very painful.
14:04:49 <nitrix> The travis file seems to install the dependencies manually in turn globally?
14:10:21 <nitrix> One more question, what are the purpose of the 706 and 708 pristine ?
14:13:40 <geekosaur> presumably the default pristine is 7.10 and those are 7.6 and 7.8
14:13:52 <geekosaur> (ghc version compat)
14:14:06 <nitrix> It cannot be because it runs on GHC 8 currently.
14:15:16 <nitrix> That'd mean we skipped a pristine 710, or maybe I don't understand the scheme properly?
14:17:43 <glguy> nitrix: Usually it's not necessary to commit the stack.yaml in the repository, especially since it local settings go in it. Just running stack init --resolver=lts-6.14 --solver wasa enough for me to get lambdabot building as released on hackage
14:18:32 <nitrix> glguy: How will it find all the local dependencies?
14:18:44 <nitrix> glguy: Normally, those are added in the sandbox with add-source.
14:18:55 <glguy> stack'll search local directories for cabal files
14:19:05 <glguy> In my case it's getting them off hackage
14:19:22 <glguy> but it's pretty smart
14:19:22 <nitrix> That'd mean you'd have to be at the root?
14:19:34 <glguy> when you init? probably
14:19:35 <nitrix> But the root doesn't have a cabal file.
14:19:39 <glguy> but after that you can build wherever
14:20:22 <cocreature> nitrix: that doesn’t matter
14:20:28 <hackrilege> like in a browser?
14:20:50 <glguy> Yeah, like that
14:21:40 <hackrilege> i want to compile a haskell server to js in the browser
14:21:46 <nitrix> glguy: Ah you're right that worked.
14:22:52 <nitrix> I'll be working on per-user modules tonight :)
14:23:04 <nitrix> So we all have our own namespaces :)
14:23:51 <nitrix> If it's too complicated, then I'll get @undefine to let you specify a single function to undefine.
14:24:17 <hackrilege> awesome
14:25:02 <hackrilege> to import from another user?
14:25:08 <hackrilege> seems complicated
14:25:21 <nitrix> hackrilege: There are plans for `give` and `grab` to exchange definitions with other users, as well as import their entire namespace qualified into yours.
14:25:35 <hackrilege> good to send to hackage too
14:26:02 <nitrix> No guts, no glory, heh :P ?
14:26:15 <hackrilege> sounds noisy too, a -silent option?
14:27:19 <hackrilege> to be clear your talking about client accounts too lambdabot?
14:28:24 <nitrix> I had in mind only the IRC part if that's what you meant.
14:28:28 <hackrilege> is there a browser version of lambdabot?
14:28:51 <nitrix> But it might be complicated as they seem separated from one another.
14:30:19 <hackrilege> better if it works with any irc client
14:32:35 <hackrilege> oh, so your thing would log on to an irc channel like how lambdabot does and define namespaces for each username also on the channel?
14:33:28 <Gurkenglas> People can already put their personal preludes into an lpaste and use letlpaste
14:34:50 <hackrilege> so that calls to your program call lamdabot updated to the users namespace and returns the output?
14:37:25 <hackrilege> Gurkenglas, ok so the robot user could simply append a paste and call lambdabot with letpaste, can this be built into lambdabot?
14:38:42 <lenshelp> Given this very simple json, how could I delete the val key: "{\"val\": 0}" ^. sans "val"
14:38:49 <lenshelp> obviously my attempt didn't work
14:39:04 <hackrilege> it could then also check for the user that the code they write into a paste actaully compiles in lambdabot
14:40:16 <glguy> lenshelp: set (_Object . at "val") Nothing "{\"val\":0}"  -- If you're using the lens-aeson package
14:41:04 <glguy> lenshelp: Or like you were asking about: over _Object (sans "val")
14:41:39 <Gurkenglas> hackrilege, what do you mean can it be built in? lambdabot already checks whether letlpasted lpastes compile, afaik its just pretty much "mapM @let"
14:42:00 <lenshelp> glguy: the first seemed to fulfill my question, your second question is more along the lines of what I'm trying to do
14:42:00 <int-e> nitrix: Pristine.default still worked with ghc-7.10, last time I checked
14:42:10 <Gurkenglas> Except that definitions can be recursive? Ah I'm talking out of my ass there
14:42:35 <Gurkenglas> *mutually recursive
14:42:43 <lenshelp> glguy: My confusion was from not knowing that doing _Object gave me something that has the At instance
14:42:44 <int-e> nitrix: regarding stack.yaml, it would just go unmaintained (so even less maintained than lambdabot in general), since I wouldn't be using it.
14:44:04 <int-e> nitrix: finally, the travis configuration basically does morally a cabal install lambdabot with the latest hackage. the complication is all about caching previous package builds so that it doesn't take 20-30 minutes for every travis run.
14:44:08 <Gurkenglas> Why doesn't aeson-lens define an At instance along with its Ixed instance?
14:44:28 <glguy> Gurkenglas: Because not all Values are indexable
14:44:45 <Gurkenglas> Ah, makes sense
14:44:47 <hvr> int-e: where's the travis config?
14:45:08 <int-e> hvr: https://github.com/lambdabot/lambdabot/blob/master/.travis.yml
14:46:08 <hvr> int-e: that one looks like a good candidate for new-build :-)
14:47:10 <int-e> and I should be able to remove the extra cabal flags for ghc-8.0.1 by now.
14:49:02 <hvr> int-e: want me to give it a try creating a .travis config based on cabal new-build?
14:49:08 <zort> if I have a wrapper type around Data.Vector "newtype Special a = Special (Vector a)" but I still want to conveniently use all the standard Vector functions on it, I should use the Vector from classy-prelude and the extension GeneralizedNewtypeDeriving to derive IsSequence for Special?
14:52:08 <hackrilege> i get an error :( http://lpaste.net/183175
14:57:11 <int-e> hvr: well there's also the aspect that it cleans package versions that are no longer needed; otherwise I could just have used --upgrade-dependencies
14:58:01 <hvr> int-e: well, afaik that won't keep the travis cache from growing
14:58:02 <lenshelp> I'm confused at why the following code returns "\"stuff\" and unsure how to make it delete val (mapped crossed my mind): over _Object (sans "val") "\"stuff\":[{\"val\":0, \"val2\":1}]"
14:58:03 <hackrilege> got it; http://lpaste.net/183175
14:58:39 <lenshelp> From above, this was my last try actually:over (key "stuff" . _Object) (sans "val") "\"stuff\":[{\"val\":0, \"val2\":1}]"
15:02:48 <lenshelp> Whoops, had bad json. Here's good json and a new attempt: over (key "stuff" . _Object) (sans "val") "{\"stuff\":[{\"val\":0, \"val2\":1}]}"
15:02:59 <int-e> hvr: I'm pretty sure the deleted packages are no longer in the cache either
15:04:06 <hvr> int-e: I need to check how 'casher' works exactly, but so far I assumed it used a git repo, and created a new commit for each cache commit
15:04:52 <hvr> thereby retaining all previous cached states
15:05:36 <puregreen> doesn't it simply pack things into an archive and send them to Amazon?
15:06:27 <puregreen> “The caching tars up all the directories listed in the configuration and uploads them to S3, using a secure and protected URL, ensuring security and privacy of the uploaded archives.”
15:07:19 <int-e> hvr: oh you mean internally inside travis... well that would be their own fault then
15:08:28 <hvr> actually I think puregreen may be right
15:08:39 * hvr is looking at https://github.com/travis-ci/casher/blob/master/bin/casher
15:18:06 <hackrilege> can i have a zero pattern?
15:18:31 <hackrilege> pattern  :-:  <- (-> )
15:18:54 <hackrilege> i want to pattern match on it like []
15:19:25 <hackrilege> pattern x ::: xs <- (\(x:xs) -> Just (x, xs))
15:20:32 <hackrilege> pattern x ::: xs <- ((\(x:xs)->(x,xs))-> (x, xs))
15:20:38 <ReinH> hackrilege: pattern Empty <- (pop -> Nothing) ?
15:21:13 <hackrilege> i cant get my head how that works
15:21:30 <ReinH> it pattern matches the result of pop with Nothing
15:22:02 <ReinH> like \x -> case pop x of Nothing -> Empty
15:22:33 <hackrilege> so it gives the argument to pop and if it returns nothing then it provides no arguments with information in the function definition its being used in
15:23:29 <ReinH> The argument is provided to pop, just like it is in your ::: pattern
15:23:32 <hackrilege> f Empty = Empty ::?
15:23:40 <ReinH> and the result is pattern matched on, just like in your ::: pattern
15:24:25 <hackrilege> yeah i just dont get how it assigns no value though...
15:24:54 <ReinH> what do you mean?
15:25:21 <ReinH> Empty constructs a pattern, and takes no arguments. (:::) constructs a pattern and takes 2 arguments.
15:25:25 <hackrilege> x:::xs assigns value to x and xs, but Empty is provided with an argument and then just dissapears!
15:25:34 <ReinH> Empty is not provided with an argument
15:25:43 <hackrilege> pop is
15:25:52 <ReinH> (:::) isn't provided with x and xs
15:25:55 <ReinH> in that sense
15:25:58 <ReinH> pop is
15:26:09 <ReinH> x and xs are bound by the pattern
15:26:10 <ReinH> on the rhs
15:26:44 <ReinH> rather, pop is provided with the value that is an instance of Stack in both cases
15:26:58 <hackrilege> so if the lhs mentions no variables and nor does the rhs, then the scope is unaltered
15:27:06 <ReinH> I don't know what that means
15:27:16 <ReinH> I don't know what scope you are referring to
15:27:47 <hackrilege> the one provided with definitions of x and xs  in the function, the scope of the function
15:28:12 <ReinH> Remember, this is a pattern, not a function.
15:28:28 <ReinH> It uses pattern synonym syntax, not function syntax
15:28:41 <hackrilege> it can be used in a function definition or a case clause
15:28:49 <ReinH> So if you are confused because it is not behaving like a function, then you should stop expecting it to behave like a function
15:28:52 <ReinH> Yes, as a pattern.
15:28:59 <ReinH> That's what goes in those places.
15:29:10 <ReinH> Functions do not go in those places.
15:29:32 <hackrilege> it provides the scope of the function or the case clause with definitions of variables
15:29:46 <ReinH> Yes, that is one of the things that patterns do.
15:30:05 <ReinH> They also distinguish cases.
15:30:05 <hackrilege> wel thats the scope i was refeing to
15:30:07 <ReinH> Ok.
15:30:19 <ReinH> I just want to be clear that this isn't a function and doesn't behave like a functino.
15:30:29 <hackrilege> ok
15:30:59 <hackrilege> i like how empty does not alter the scope of the function its used to define
15:31:06 <hackrilege> Empty*
15:31:31 <hackrilege> thanks
15:31:33 <ReinH> Yeah, Empty doesn't "contain" anything, so there is nothing that needs to be given a variable binding.
15:31:41 <ReinH> just like []
15:31:56 <ReinH> (although in this case the notion of containing things is abstracted)
15:31:56 <jle`> @let data Foo = Foo deriving Show
15:31:57 <lambdabot>  .L.hs:159:1: error:
15:31:58 <lambdabot>      Multiple declarations of ‘Foo’
15:31:58 <lambdabot>      Declared at: .L.hs:157:1
15:32:16 <ReinH>  Of course someone defined Foo. Be more creative in your type names. :p
15:32:21 <jle`> :p
15:32:31 <MarcelineVQ> Foo1
15:32:39 <jle`> @let data Bar = Bar
15:32:40 <lambdabot>  Defined.
15:32:43 <hackrilege> > Foo
15:32:45 <lambdabot>  error:
15:32:45 <lambdabot>      • No instance for (Typeable x0)
15:32:45 <lambdabot>          arising from a use of ‘show_M521473936821606355527422’
15:33:52 <jle`> @let unbar x = case x of Bar -> 10000
15:33:53 <lambdabot>  Defined.
15:33:58 <jle`> > unbar Bar
15:34:01 <lambdabot>  10000
15:34:14 <jle`> Bar is just like Empty there.  it doesn't bind any values :)
15:34:57 <jle`> most of the commonly used constructors actually do'nt bind any values
15:35:08 <jle`> so constructors that bind values couild actually be considered the special case
15:36:19 <jle`> @let myIf b x y = case b of True -> x; False -> y
15:36:20 <lambdabot>  Defined.
15:36:29 <jle`> > myIf True "this is true" "this is not true"
15:36:31 <lambdabot>  "this is true"
15:36:56 <c_wraith> @let import Data.Bool
15:36:57 <jle`> hackrilege: ^ -- True and False, like your Empty, are constructors w/o arguments that don't bind any values
15:36:57 <lambdabot>  Defined.
15:37:00 <c_wraith> :t bool
15:37:02 <lambdabot> a -> a -> Bool -> a
15:39:16 <hackrilege> http://lpaste.net/183187
15:39:21 <hackrilege> it does not work
15:40:56 <jle`> hackrilege: you never match (_ ::: _)
15:41:01 <hackrilege> i know
15:41:03 <jle`> or, say, (2 ::: _)
15:41:20 <hackrilege> ohh
15:41:31 <hackrilege> so its not failing on Empty...
15:41:46 <jle`> > map (\xs -> case xs of [] -> "empty"; (1 : _) -> "starts with 1") [[],[1,2,3],[2,3]]
15:41:48 <lambdabot>  ["empty","starts with 1","*Exception: <interactive>:3:13-64: Non-exhaustive ...
15:42:00 <jle`> (2:[3]) matches neither [] nor 1:_
15:42:19 <hackrilege> ok simple thanks
15:42:35 <MarcelineVQ> if you enable -Wall it'll let you know about this kind of thing
15:43:15 <MarcelineVQ> Not quite as directly as jle` did there, but it'll let you know something is missing in this case
15:43:47 <jle`> -Wall could potentially give extraneous warnings when used with pattern synonyms tho
15:43:53 <jle`> so it's kind of weird
15:44:07 <jle`> it's one of the reasons i kind of gave up on pattern synonyms
15:45:21 <hackrilege> basically my whole project boils down to this generalisation to (:)
15:45:43 <hackrilege> it just defines isomorphisms to List and so gives fold and unfold from push and pop
15:45:57 <hackrilege> which are enough for Monad and Comonad
15:46:45 <hackrilege> so it gives a way to define Monoads and Comonads, folds and unfolds from synonyms to (:) and []
15:47:59 <hackrilege> with Overlapping Instances of course, so this datatype should be used with care. ill write the instances now
15:48:17 <hackrilege> and maybe it wont work
15:51:46 <chsn> is there anyway to install either ghcjs or haste via stack ?
15:52:58 <puregreen> chsn: https://docs.haskellstack.org/en/stable/ghcjs/
15:53:37 <puregreen> I also think you can just use “resolver: ghcjs-0.2.0.20160414_ghc-7.10.3” but not sure
15:53:46 <kriztw> chsn: also see https://www.reddit.com/r/haskell/comments/4zrld4/nightly20160826_ghcjs80/
15:54:11 * hackagebot alex-tools 0.1.0.0 - A set of functions for a common use case of Alex.  https://hackage.haskell.org/package/alex-tools-0.1.0.0 (IavorDiatchki)
15:54:17 <dmj> chsn: it's pretty easy w/ nix too
15:55:07 <kriztw> I have a project where I use a lot of files generated by hprotoc, do I have to add every single module to my .cabal file or is there a better way?
15:55:23 <kadoban> kriztw: Just to be clear, that's trusting whoever tolysz.org is to run code on your machine (your reddit link)
15:56:22 <kriztw> kadoban: oh, I didn't notice it was on his domain
15:57:13 <chsn> kriztw: I'm hesistant about pulling a compiler from a random url from a reddit comment :-)
15:57:49 <chsn> dmj: it's prety crazy we're close to pulling *an entire VM* in order to compile a basic hs -> js
15:58:18 <kriztw> chsn: yeah, I would be too, I just remembered he had posted build instructions but didn't check where it was hosted
15:58:32 <dmj> chsn: what OS are you on? I feel the pain. nixpkgs on OSX works well though, even with ghcjsi
15:58:49 <dmj> chsn: as long as you have no plans to use ghcjs-dom on the server
15:59:06 <chsn> dmj: I'm using ubuntu 16.04
15:59:25 <kadoban> chsn: The official stack docs have essentially the same info as the reddit link, if you trust whoever wrote the docs more than random-redditers.
15:59:30 <dmj`> hm, and you're compiling with stack?
15:59:32 <dmj`> chsn: ^
15:59:34 <kadoban> (with different URLs of course)
15:59:44 <chsn> dmj`: yes; I'm using stack
15:59:53 <chsn> kadoban: the aws url does not make me feel too much better either
16:00:04 <chsn> maybe I'm just too paranoid
16:00:29 <kadoban> chsn: I don't particularly trust it either, so I don't blame you. It's unclear who actually controls that.
16:03:13 <kadoban> It's my understanding that if GHCJS ever gets official releases the situation will be much easier to handle, but I have no if when/if that's going to happen.
16:03:26 <kadoban> no idea*
16:04:47 <hackrilege> http://lpaste.net/183194
16:04:50 <hackrilege> helpf
16:04:57 <hackrilege> i dont know why that overlaps
16:05:12 <hackrilege> it seems like it shouldnt
16:06:23 <roboguy`> hackrilege: the constraint solver system always checks the instance head first before looking at any constraints. So it essentially just sees it as "instance Foldable f where ..."
16:06:35 <roboguy`> For the purposes of finding instances anyway
16:06:46 <hackrilege> oh dear
16:06:52 <hackrilege> terrible news
16:06:54 <roboguy`> why do you want the foldable instance?
16:07:12 <roboguy`> Presumably, they would implement Foldable when they implement your class...
16:07:20 <hackrilege> because defining push and pop creates an isomorphism to list permitting an overlapping instance
16:07:21 <roboguy`> in fact, you could make Foldable a superclass if you wanted to
16:07:28 <hackrilege> nope
16:07:38 <hackrilege> wish to derive it from definitions of push and pop
16:07:56 <roboguy`> you'll have to wrap it up into a newtype
16:08:19 <hackrilege> the point is it doesnt even use [], it uses a wrapped newtype
16:08:36 <hackrilege> List
16:08:58 <hackrilege> even though no instance Stack [] definition is given, it still goes crackers
16:09:38 <roboguy`> the class system has an "open world" assumption since anyone can, at any point, add a new instance
16:10:04 <hackrilege> its ruining my code
16:10:09 <roboguy`> what are you trying to do?
16:10:21 <hackrilege> exactly what i wrote
16:10:25 <roboguy`> I feel like you might be able to use a data type instead of a class for Stack...
16:10:32 <roboguy`> I mean, is there a larger context to this?
16:11:05 <hackrilege> all isomorphisms to list should have foldable instances generated in this way
16:11:17 <hackrilege> that is the idea anyway
16:12:06 <hackrilege> it provides syntax for recursive definitions on isomorphisms to list based on the familiar pattern matching syntax
16:12:35 <hackrilege> this alone allows all Stack instances to instantiate all the things List does
16:12:41 <hackrilege> [] rather
16:13:33 <hackrilege> providing a foldable instance returns a toList function in terms of the constructor (:)
16:14:12 <hackrilege> alternatly providing a synonym to (:) allows a foldable instance to be generated
16:15:42 <roboguy`> why should all isomorphisms to list have foldable instances generated in that way?
16:15:59 <hackrilege> they dont have to, but there is that option
16:16:23 <hackrilege> infact these isomprphic datastructures do provide alternative folding to lists
16:16:45 <hackrilege> depending on the behaviour of the constructor
16:18:29 <f-a> is there a way to bind keys in ghci? (C-s, etc.)
16:18:46 <hackrilege> the choice is either to provide a foldable instance and work with lists or provide an alternative constructor and recieve a foldable instance generated by the resulting isomorphism to []
16:19:34 <roboguy`> hackrilege: hmm, why do this instead of just making an instance of Foldable and defining toList?
16:19:49 <roboguy`> a definition of toList seems like it would probably usually be pretty similar
16:19:56 <hackrilege> the point is that having defined a linear constructor, a foldable instance is immediately derivable from the existence of an isomorphism to []
16:20:42 <roboguy`> I guess I don't really see why that's a benefit...
16:20:51 <roboguy`> you can already automatically derive foldable, generally
16:21:34 <nmdanny> is it possible to have an alias for several typeclass constraints, for use in function type declarations? e.g type MonadAppFileSystem m = MonadReader Config m,MonadIO m
16:21:46 <hackrilege> its duplicating information to specify the behaviour of the constructor both in the data deceleration and the NEW foldable instance, so that it would only be necessary if a different folding behaviour war required other than the one infered from the isomporphism to list resulting from the Stack instance
16:22:28 <roboguy`> f-a: I don't think so
16:23:00 <hackrilege> since only a non trivial fold requires this Foldable instance for a Stack instance, i would rather describe an alternative constructor and recieve a new datatype constructed in a trivial way
16:23:40 <f-a> roboguy`: no worries!
16:24:11 <hackrilege> either you foldable datatype folds like a list or there is a datatype with the constructor isomorphic to (:) that should be generated from the Foldable instance...
16:24:12 * hackagebot Network-NineP 0.4.1 - High-level abstraction over 9P protocol  https://hackage.haskell.org/package/Network-NineP-0.4.1 (SergeyAlirzaev)
16:24:14 <roboguy`> nmdanny: yeah
16:24:17 <hackrilege> it doesnt work that way roundf
16:24:31 <roboguy`> nmdanny: pretty much just like that, IIRC. You might need ConstraintKinds enabled, I'm not sure
16:24:55 <parsnip> f-a: http://stackoverflow.com/questions/1825547/how-to-customize-the-readline-keybindings-of-ghci
16:25:19 <roboguy`> nmdanny: also, you'll probably need parens
16:25:20 <f-a> uhh quite nice parsnip 
16:25:43 <hackrilege> http://lpaste.net/183194
16:25:48 <parsnip> f-a: i googled `ghci readline' ;)
16:25:51 <et09> here's a question that's been nagging me - when is type not inferred/inferable by the compmiler
16:26:21 <f-a> do you happen to know if :set stop can take *multiple* commands? e.g. :set stop :list :! clear
16:27:10 <roboguy`> et09: RankNTypes would be one example
16:28:53 <hackrilege> i dont get why it doesnt compile, how do i stop it thinking that a Stack [] instance has been given?
16:28:56 <geekosaur> f-a, I think you have to use :def for that
16:29:17 <f-a> ok I'll try that, geekosaur 
16:30:37 <glguy> et09: The type can be ambiguous, for example (read . show)   without ExtendedDefaulting
16:30:56 <glguy> err, show . read
16:35:33 <roboguy`> hackrilege: you can't
16:37:10 <hackrilege> maybe its because i defined foldMap instead of foldl
16:38:02 <geekosaur> hackrilege, if this is http://lpaste.net/183194 then the problem is that contexts aren't involved in instance selection
16:38:16 <geekosaur> you would need a newtype
16:38:21 <roboguy`> hackrilege: it really is because of how instance resolution works. There's some info here https://stackoverflow.com/questions/1064232/haskell-overlapping-instances
16:38:53 <roboguy`> if you look up "open world assumption haskell", you'll probably find more info
16:38:58 <geekosaur> `instance Stack f => Foldable f` is, as far as instance selection is concerned, `instance Foldable f` which overlaps every other instance
16:39:08 <hackrilege> this is veerry bad
16:39:21 <hackrilege> i need to get something as colse as i can to this working
16:39:45 <roboguy`> hackrilege: do you have a particular use-case or example that you want to use this with?
16:40:41 <hackrilege> im certain at least that absence of this shouldn't change anything
16:41:26 <hackrilege> a trivial test case is sufficient
16:42:36 <hackrilege> it should only overlap instances of Stack
16:43:36 <hackrilege> as far as i can make out OverlappingInstances shouldnt behave this way, its certainly not how i would expect it to work and it messes up everything im doing
16:44:00 <geekosaur> open world assumption
16:44:12 * hackagebot dependent-map 0.2.3.0 - Dependent finite maps (partial dependent products)  https://hackage.haskell.org/package/dependent-map-0.2.3.0 (JamesCook)
16:44:19 <hackrilege> i dont care why it makes sense i just want to break it
16:44:30 <geekosaur> then use a newtype
16:44:39 <geekosaur> no, you cannot force it to work the way you want
16:44:53 <hackrilege> what do you mean use a newtype?
16:44:54 <hackrilege> i am
16:45:06 <hackrilege> and it complains about some other things
16:45:44 <hackrilege> http://lpaste.net/183194
16:46:23 <hackrilege> i think List is a newtype of List more or less
16:46:32 <hackrilege> of []*
16:46:40 <geekosaur> no, the newtype has to be for instances of Stack a
16:47:05 <geekosaur> so that you are not matching Foldable f in the instance head, but Foldable (YourNewtype f)
16:47:20 <geekosaur> so it doesn't overlap any more
16:48:29 <hackrilege> data MyFoldable f where MyFoldable :: forall f Foldable f => a -> f a
16:48:46 <hackrilege> something like that?
16:49:12 * hackagebot dependent-sum 0.4 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.4 (JamesCook)
16:49:29 <hackrilege> i dont know how to make a constrained newtype
16:49:39 <hackrilege> its like datatype contexts?
16:49:46 <hackrilege> somehow overcome with gadts
16:53:45 <hackrilege> geekosaur, how do you define such a newtype?
16:55:47 <roboguy`> hackrilege: you could define newtype MyStack f a = MyStack (f a) and then constraint the f argument in the instance definition
16:56:06 <hackrilege> datatype contexts is depreciated
16:56:28 <hackrilege> oh sorry misread
16:57:15 <geekosaur> what roboguy` said (I was preparing an lpaste and testing first...)
16:57:46 <hackrilege> thanks!
16:57:52 <hackrilege> makes sense
16:58:07 <lpaste> geekosaur annotated “horrible Stack error” with “horrible Stack error (annotation)” at http://lpaste.net/183194#a183206
16:58:11 <roboguy`> np
16:58:20 <koz_> What's a neat way to write 'if x and y are both positive, do foo; if they're both negative, do bar; otherwise, do baz'?
16:58:29 <koz_> (where x and y are both let-bound variables)
16:59:04 <hackrilege> cant i include the constraint in the newtype using gadts?
16:59:10 <koz_> Also, what package do you folks recommend for non-empty lists?
16:59:56 <roboguy`> koz_: that is in the base libraries these days
17:00:00 <roboguy`> http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List-NonEmpty.html
17:00:05 <hackrilege> :t all
17:00:07 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
17:00:08 <koz_> roboguy`: Wow, nice!
17:00:18 <koz_> Did not know that - will use.
17:04:36 <hackrilege> if x>0 then if y>0 then foo else baz else bar
17:05:18 <koz_> hackrilege: No way I can case that up or something? Sadface.
17:05:55 <hackrilege> denied. 10 points awarded to hackrilege
17:06:46 <geekosaur> hackrilege, there are ways to put a constraint in there but it won't do what you expect; it's local to the newtype, so each use of it would be independent constraint that don't unify
17:07:20 <geekosaur> hm, actually I am thinking of type, never mind
17:07:44 <geekosaur> anyway it's generally not a good idea because of things like that. just put the constraints where they are used
17:08:52 <roboguy`> koz_: you can use MultiWayIf to make it look a little cleaner
17:09:07 <hackrilege> i wouldnt want the user thinking Stackish made sense for non Stack parameters
17:09:13 * hackagebot lentil 1.0.2.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.0.2.0 (fffaaa)
17:09:18 <roboguy`> koz_: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#multiwayif
17:10:10 <hackrilege> id like to write data Stackish f a where Stackish :: Stack f => f a -> Stackish f a
17:10:20 <hackrilege> is that valid or close?
17:10:55 <geekosaur> you can do that, it's a bit heavier than newtype though (costs an extra indirection, introduces an extra potential bottom)
17:11:20 <hackrilege> whaat!?
17:11:39 <hackrilege> its ok i have indirection to spare
17:14:13 * hackagebot vty 5.10 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.10 (JonathanDaugherty)
17:22:16 <hackrilege> :r
17:23:59 <lpaste> koz_ pasted “How can I remove the code duplication here?” at http://lpaste.net/183212
17:28:18 <hackrilege> oh no!! i guess you warned me about this? http://lpaste.net/183215
17:29:32 <hackrilege> koz_ you could pass the function (>)
17:29:37 <geekosaur> I think you want lowercase after the =, since it's not a pattern
17:30:29 <Guest22412> Hi! I was wondering where I should put my resources in a stack project?
17:30:39 <geekosaur> otherwise you'd need to make the pattern bidirectional so it knows how to resolve the expression Basecase to basecase
17:30:47 <Guest22412> I have a bunch of .txt files my project needs access to
17:31:03 <hackrilege> ok i see
17:31:13 <f-a> thanks geekosaur , a simple :def myStep (\_ -> return ":!clear \n :list") did it
17:31:32 <hackrilege> but now i cant generate something of a type to pass to my monoid generating function
17:32:28 <hackrilege> oh mempty!
17:32:29 <hackrilege> sorry
17:32:34 <hackrilege> ok it works!
17:39:32 <parsnip> if you had a series of files for exercises, like p01,p02,..., would you make those as executables or libraries, if at all? 
17:39:54 <parsnip> *p[0-9]+.hs
17:40:07 <EvanR> ex-files
17:40:25 <sm> other options: standalone stack scripts, doctest examples
17:40:39 <kadoban> parsnip: I'd likely skip a .cabal file and just make them scripts using stack
17:40:57 <parsnip> but then can i still do profiling on them? 
17:41:34 <kadoban> AFAIK. You can just do arbitrary options in those
17:42:34 <parsnip> okay, thanks all
17:42:37 <hackrilege> http://lpaste.net/183222
17:42:40 <hackrilege> it works!
17:48:51 <parsnip> aha, https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter, very cool
17:50:11 <hackrilege> this one is shorter; http://lpaste.net/183227
17:54:10 <chsn> are there any large haskell progams build around http://shaffner.us/cs/papers/tarpit.pdf ? if not, what is wrong with this paper?
17:54:42 <parsnip> i have #!/Users/iam/.local/bin/stack at top of file, but ./file.hs gives Permission denied. 
17:55:00 <parsnip> but not if i write `stack ./file.hs'. 
17:55:27 <kadoban> parsnip: You have to set files executable to execute them. chmod +x thefile
17:55:27 <koz_> parsnip: Did you chmod the file?
17:58:02 <parsnip> ah yeah, chmod 744... i guess my memory is a mess on when exactly you need +x. 
17:58:21 <parsnip> i thought it was just if you wanted to omit the ./
17:58:35 <parsnip> but maybe that's the PATH part. 
17:59:57 <parsnip> thank you both
18:16:17 <Cale> chsn: The company I work for, Obsidian Systems, builds web applications using a functional reactive programming system, does that count? :)
18:17:50 <jmcarthur> chsn: That's a false dichotomy. It could be that there are no large haskell programs built around those ideas but there is still nothing wrong with the paper.
18:18:14 <Cale> I don't recall all of what that paper had to say about FRP
18:18:23 <jmcarthur> I guess the dichotomy was only implied, so apologies if I misinterpreted.
18:34:00 <koz_> Suppose I have something like 'foo >>= bar 1 >>= bar 3 >>= bar 6'. Is there a way I can write it something like 'frobnicate (\x y -> bar y x) foo [1, 3, 6]'? foldM is almost, but not quite, what I need, as I would need to 'unwrap' foo for this to work.
18:57:18 <parsnip> this seemed to be a minimal success in easy profiling, not sure it's possible without declaring an executable/library: 
18:57:20 <parsnip> stack build --executable-profiling; stack exec -- real-world-profiling 2 +RTS -p
18:57:55 <parsnip> so IIUC, it's not possible with `stack runghc ...'. 
18:59:36 <parsnip> or like standalone, i think this thing: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
19:04:09 <samsungy> hey is anyone on
19:05:08 <samsungy> i heard there are some fellow hackers in this chat room?
19:05:24 <samsungy> i need help creating a fake phishing login page
19:05:26 <Axman6> this is a channel for the Haskell programming language
19:07:50 <lpaste> koz_ pasted “Confused about ix implementation” at http://lpaste.net/183265
19:08:02 <koz_> If anyone could help, I would be much obliged ^
19:08:23 <glguy> koz_: Traversal' is a type synonym for a function
19:09:05 <glguy> type Traversal' s a = Traversal s s a a
19:09:05 <glguy> type Traversal s t a b = forall (f :: * -> *). Applicative f => (a -> f b) -> s -> f t
19:09:21 <koz_> glguy: Oh, so the second arg is the (a -> f b), and the third is the s?
19:09:39 <glguy> Correct.
19:09:44 <koz_> glguy: OK, that helps a tonne.
19:09:53 <koz_> Also, I'm a bit confused how ix handles out of bounds conditions.
19:10:10 <koz_> Since the function you pass in is based on Applicative, not Alternative.
19:10:26 <glguy> koz_: This is the out of bounds case: go [] _ = pure []
19:10:36 <glguy> Note that it doesn't use f
19:10:50 <koz_> So the 'pure' refers to the pure of whatever f is?
19:11:03 <Axman6> yep
19:11:07 <Axman6> :t pure
19:11:08 <lambdabot> Applicative f => a -> f a
19:11:19 <koz_> Axman6: OK, I think I get it now.
19:11:26 <Axman6> it's part of the Applicative class, which you'll notice is necessary or a Traversal
19:11:29 <Axman6> for*
19:11:39 <koz_> Because when you ^? into it, it's in a Maybe context.
19:11:45 <koz_> OK, *now* I understand. Thank you!
19:14:26 <koz_> Lenses are just screamingly abstract, and it's a bit hard for me to make sense of them sometimes...
19:14:51 <chsn> how does clean compared to haskell ?
19:15:25 <kadoban> Is "clean" a language?
19:15:49 <Axman6> koz_: yeah they can take a while, but they're actually really simple once you get used to them
19:15:51 <koz_> kadoban: https://en.wikipedia.org/wiki/Clean_(programming_language)
19:15:54 <chsn> http://clean.cs.ru.nl/download/doc/CleanLangRep.2.2.pdf
19:16:00 <geekosaur> yes, it's the one that went with uniqueness types instead of monads
19:16:22 <chsn> I guess clean lacks rank-n types, only has rank-2 so far
19:16:23 <koz_> Axman6: In my case, I have a complex underlying structure (my main reason for even resorting to lenses in the first place - I wanna get many of the cool lens things 'for free' by writing one or two functions).
19:16:29 <chsn> geekosaur: so I can't write LogicT in clean ?
19:16:34 <koz_> Axman6: So it doesn't help matters...
19:16:55 <chsn> I hate monads. Before hand, I couldn't understand them. NOw, I can't live without them.
19:17:03 <geekosaur> presumably not the same way. I am vaguely familiar with Clean but haven't written anything in it
19:19:10 <kadoban> Sounds vaguely interesting
19:20:34 <orion> Is it true that with the `linear` package, the largest matrix you can represent is 4x4?
19:20:41 <chsn> lol
19:20:52 <chsn> you have to be kidding me
19:20:58 <chsn> that's like an Int that only has 2 bits
19:21:24 <orion> Why then does the package define modules Linear.V0 through Linear.V4?
19:22:10 <chsn> https://hackage.haskell.org/package/linear
19:22:30 <chsn> I think there is special ahrd coding for dims 0-4
19:22:37 <chsn> then there's generic one that can store arbitray dimension
19:22:37 <Axman6> it's sedigned for working with small vectors, like coordinates, not for working with matricies
19:22:54 <Jenaf> perhaps faster implementation for the most usual cases
19:23:20 <Jenaf> also I don't really understand why there is thee need for a module for V0 but who knows?
19:23:49 <Axman6> always gotta have a base case =)
19:24:01 <parsnip> is stack --version 1.0.1 fine? 
19:24:41 <parsnip> can't put `build: ' in stack.yaml till 1.1.0, i guess i can live without. 
19:24:51 <Axman6> that seems quite old
19:25:02 <kadoban> parsnip: I'd really upgrade, that was quite a while back and stack is still young, moves fairly fast.
19:25:10 <Axman6> ok, not super old, but it's easy to update, stack upgrade
19:25:20 <cdsmith> Suppose I have f and g, which do the same thing; except that g is faster, and requires an Eq constraint on parameters.  Can I get GHC to rewrite f to g whenever it's applied to arguments with Eq instances?
19:25:22 <kadoban> That's like at least 5 releases back, probably more.
19:25:31 <Axman6> got to make sure you avoid the version which deleted your SSH keys...
19:25:50 <Axman6> cdsmith: that might be possible with RULES
19:26:11 <cdsmith> Axman6: That's what I'm trying, but I can't find the right magic incantation yet...
19:27:06 <cdsmith> {-# RULES "equality/builtin" (==) = (Prelude.==) #-} -- complains about missing the Eq constraint
19:27:08 <Axman6> what've you tried?
19:29:21 <cdsmith> {-# RULES "equality/builtin" forall (x :: Prelude.Eq a => a). (==) x = (Prelude.==) x #-} -- compiles, but I can find no evidence the rule fires
19:31:16 <cdsmith> I suspect in the latter case, the problem is that I'm requiring f to have a polymorphic type... but I can't figure out a syntax to do the right thing
19:31:25 <cdsmith> I mean x, not f
19:35:35 <xuxu> @src map
19:35:35 <lambdabot> map _ []     = []
19:35:35 <lambdabot> map f (x:xs) = f x : map f xs
19:37:07 <Welkin> xuxu: your nick reminds me of a character in FTL
19:37:15 <Welkin> the mantis species
19:37:33 <Welkin> I think they named all of the characters after real people
19:54:33 <koz_> Holy shit applicatives.
19:54:48 <xuxu> koz_: what about them?
19:54:55 <xuxu> @src isInfixOf
19:54:55 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
19:55:10 <xuxu> @src Data.List.isInfixOf
19:55:10 <lambdabot> Source not found. Just try something else.
19:55:39 <xuxu> hah, that's the actual source code :)
19:56:02 <xuxu> @src isPrefixOf
19:56:02 <lambdabot> isPrefixOf [] _          = True
19:56:02 <lambdabot> isPrefixOf _  []         = False
19:56:02 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
19:58:16 <koz_> xuxu: I had to use a lot of them, but it actually made sense.
20:08:06 <xuxu> koz_: very nice
20:09:26 <lpaste> koz_ pasted “xuxu: If you're interested” at http://lpaste.net/183295
20:10:47 <xuxu> that's neat, i haven't seen "type instance" before
20:11:18 <xuxu> i don't know what it does either :)
20:11:27 <koz_> xuxu: It's so that Ixed can have unified types.
20:12:00 <koz_> The type of ix is Index m -> Traversal' m (IxValue m)
20:12:18 <koz_> So those basically specify what types 'Index m' and 'IxValue m' are when m is 'Formula'.
20:13:58 <xuxu> thanks for the explanation!
20:14:19 <xuxu> that's a more advanced guard than i've seen in all the tutorials i've read
20:15:38 <koz_> xuxu: The structure I have is a pain in the ass - this is one reason I wanted to make a nice interface into it using lenses.
20:16:05 <koz_> Hence all the threading of applicatives through everything.
20:16:34 <parsnip> so `+RTS -p' has to be passed on the command line, not in any config file? 
20:17:32 <koz_> parsnip: I think you can 'bake in' runtime options in your .cabal.
20:17:37 <koz_> Let me double-check.
20:17:52 <kadoban> I think there's other ways to specify it, but that's the usual one. Yeah, I think you can at compilation time. Can you do an environment variable too maybe? I forget
20:18:26 <koz_> parsnip: In your ghc-options field, pass "with-rtsopts=-p".
20:18:31 <koz_> (in your case)
20:20:05 <xuxu> i have to run, but thanks for the explainer koz_. i'd love to figure out how that specific guard works someday. i've solved quite a few problems with haskell tonight, and i'm more excited than ever to keep using it
20:21:39 * koz_ actually answered actual questions from people.
20:21:43 <koz_> What the fuck is happening?
20:21:47 <parsnip> nothing i put in `build: ' seems to be acceptable. 
20:22:00 <koz_> parsnip: In your ghc-options field, pass "with-rtsopts=-p". <-- tried this?
20:22:36 <parsnip> target ‘with-rtsopts=-p’ is not a module name or a source file
20:22:49 <parsnip>   ghc-options:         with-rtsopts=-p
20:22:58 <koz_> parsnip: Wrap in quotes like I did.
20:23:02 <Axman6> pretty sure you want --with...
20:23:39 <koz_> parsnip: -with-rtsopts=-p
20:23:47 <koz_> Sorry, "-with-rtsopts=-p"
20:23:52 <parsnip> aha, `did you mean -with-rtsopts?' 
20:23:54 <koz_> Fucking hell, shoulda just copy-pasta'd.
20:23:55 <parsnip> thanks all
20:25:34 <glguy> koz_: chill on the language
20:25:46 <koz_> glguy: Sorry...
20:26:05 <koz_> Did not intend to offend anyone.
20:27:11 <parsnip> hmm, but i still had to pass +RTS -p on command line
20:27:44 <koz_> parsnip: That's odd - at least with -N, it seems to work OK.
20:32:33 <parsnip> i guess i should consider making a repro directory
20:33:49 <parsnip> or maybe i should just be okay with specifying it on command line
20:38:14 <parsnip> https://gist.github.com/bradyt/7b348201ac4500568f3b4dd42e363f60
20:39:37 <parsnip> then i run `stack build' and `stack exec -- real-world-profiling 2', but i have to include in the latter ` +RTS -p'. 
21:10:05 <pikajude> is there a library for readable time spans
21:17:27 <jle`> pikajude: like intervals?
21:17:34 <pikajude> yeah, sorry, intervals
21:17:44 <pikajude> NominalDiffTime -> String doesn't yield anything on hayoo
21:18:38 <jle`> i just use the human-readable-duration package for printing durations things from the time package
21:18:42 <jle`> it's kind of simple though
21:20:05 <pikajude> that's a nice long name
21:20:22 <pikajude> exactly what i needed
22:24:40 <Calvin_Frakes_> suuuuupppp!!!!
22:24:53 <Calvin_Frakes_> Whass happenin!!!!
22:25:17 <Calvin_Frakes_> whois acfoltzer
22:34:24 * hackagebot glirc 2.13 - Console IRC client  https://hackage.haskell.org/package/glirc-2.13 (EricMertens)
23:05:19 <codygman> I'm not quite sure how to go from a maybe to a MonadPlus m => m, which I think is what this error is asking for: http://lpaste.net/183408
23:06:11 <glguy> codygman: Add the actual code to that paste, too, please.
23:07:03 <codygman> glguy: Whoops sorry, here it is: http://lpaste.net/183408
23:08:07 <glguy> OK, You can use: maybe mzero return :: MonadPlus m => Maybe a -> m a
23:12:13 <koz_> What's a clean way of saying 'list of the first 10 powers of 3'?
23:12:32 <koz_> My first thought involved unfoldr, which is probably not the easiest or most concise.
23:12:51 <glguy> > take 10 (iterate (*3) 1)
23:12:53 <lambdabot>  [1,3,9,27,81,243,729,2187,6561,19683]
23:12:57 <koz_> glguy: Thanks!
23:13:45 <codygman> glguy: Trying that now
23:15:29 <hvr> int-e: would you be more interested in new-build, if there was a way to GC the cabal-nix-store to remove everything not relevant to the current cabal.project file?
23:16:09 <glguy> hold out for more!
23:20:40 <koz_> Some of the function names in lens are *hilarious*.
23:20:49 <koz_> I mean, come on, "isn't" is a function name in lens.
23:24:16 <EvanR> isn't it ironic
23:24:23 <Maxdamantus> don't you think?
23:24:39 <EvanR> its like a leeeyenns
23:25:00 <EvanR> when you can already see straight
23:27:12 <codygman> glguy: Thanks, that worked.
23:27:40 <codygman> I think I ran into a problem that would require a larger scale refactoring though: http://lpaste.net/183433
23:29:03 <cocreature> koz_: at least it’s pretty clear what isn’t does just from the name :)
23:30:13 <cocreature> codygman: you could just add a MonadIO constraint to parse 
23:30:23 <cocreature> whether that’s what you want is a different question :)
23:32:46 <chsn> why can't fay add type classes
23:32:49 <chsn> what's holding them back
23:37:14 <codygman> cocreature:  Can you give me a few reasons why that would be bad? Why would it be good besides the fact it gets things working for now?
23:38:15 <marrrk> Hello! I would like to run a web server that communicates via email. What libraries could I use for that?
23:39:21 <marrrk> Or should I create a gmail account and use that through an API?
23:40:17 <xuxu> :t $!
23:40:19 <lambdabot> error: parse error on input ‘$!’
23:40:23 <xuxu> :t ($!)
23:40:26 <lambdabot> (a -> b) -> a -> b
23:40:33 <xuxu> :sorc ($!)
23:40:40 <xuxu> :src ($!)
23:40:49 <EvanR> @src ($!)
23:40:49 <lambdabot> f $! x = x `seq` f x
23:41:02 <xuxu> :src seq
23:41:12 <EvanR> seq is a primitive
23:41:33 <EvanR> > (const 9) undefined
23:41:35 <lambdabot>  9
23:41:40 <EvanR> > (const 9) $! undefined
23:41:42 <lambdabot>  *Exception: Prelude.undefined
23:43:08 <xuxu> thanks EvanR. do you know when seq actually might be useful? 
23:44:27 <xuxu> i can't think of why it would be useful at the moment
23:45:54 <EvanR> its useful when you want to control by what and when stuff is evaluated
23:47:04 <EvanR> but if you use it indiscriminatly you might end up wasting cpu and memory
23:47:21 <EvanR> when in doubt be lazy
23:47:27 <xuxu> i figured :)
23:47:43 <xuxu> laziness is one of the most appealing things about the language
23:47:51 <EvanR> theres usually more convenient ways to do what seq does, $! is one way. another way is bang patterns
23:47:58 <EvanR> another way is strict record fields
23:48:47 <xuxu> i'm curious which use cases seq, $!, or strict record fields have been useful
23:49:09 <EvanR> im using strict record fields in a video game
23:49:21 <xuxu> why are you doing that?
23:49:39 <EvanR> while testing im tending to never examine most of the game state for rendering purposes
23:50:08 <EvanR> so each update of the state causes another thunk to layer on top of the previous one
23:51:02 <xuxu> oh, is the primary reason to conserve memory?
23:51:04 <EvanR> if you never look at any of them it will just keep expanding, it has no way to know youll never look at it unless you discard the data completely
23:51:26 <xuxu> i suppose so
23:51:47 <xuxu> thank you for sharing that example!
23:51:54 <EvanR> the game state logically remains about the same size, but if you only modify fields and dont use them for anything, it will by default pile up thunks
23:52:37 <EvanR> of course if you render or print out the state periodically the thunks will go away
23:52:41 <xuxu> is it a multiplayer game, if you don't mind me asking
23:53:11 <EvanR> i was planning on adding that
23:54:10 <xuxu> i would be very interested in hearing about how you plan to sync state, if propagators or crdts are possible candidates. 
23:54:36 <EvanR> i dont know what those are
23:54:53 <xuxu> okay, i guess that's not what is usually used then
23:55:06 <xuxu> how is sync usually synced in a game?
23:55:11 <xuxu> how is state* usually synced in a game?
23:55:24 <EvanR> for real time action games over the internet, its complicated
23:55:40 <EvanR> hopefully i find a simplification
23:56:48 <Guest623> Given some function f :: A -> B -> A, a list of arguments [B], and an initial A, how can I apply f to A sequentially with the list of args in [B]?
23:56:59 <EvanR> in my mind, its all about coming to a clear understanding of what youre trying to preserve, because the game state itself cant really stay in sync. starcraft, age of empires etc did a good job, but they either dropped you or slowed the game down
23:57:50 <EvanR> for action games slowing down is not an option
23:58:02 <codygman> Anyone have anything better than http://hackage.haskell.org/package/git-date for fuzzy date parsing in Haskell? Is there anything in pure Haskell? I'm also aware of the hourglass specific fuzzy date parser, but not sure I want to abandon time for hourglass.
23:58:30 <xuxu> Guest623: I'm not following your question
23:58:42 <EvanR> Guest623: map (f x) ys
23:58:44 <xuxu> i don't see a [B] in the type class
23:58:59 <xuxu> type declaration*
23:59:22 <EvanR> f x :: B -> A, map (f x) :: [B] -> [A]
23:59:51 <Guest623> xuxu: I have an initial A. To that A, I want to apply a function f which receives A and a B. That B comes from a list [B]. To the result, I want to apply the rest of the args in [B]
