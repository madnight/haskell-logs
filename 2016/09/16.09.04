00:00:40 <ertes> writing an HTTP server or a web application?  those are fundamentally different things
00:42:32 * hackagebot crawlchain 0.1.0.8 - Library for simulating user crawl paths (trees) with selectors.  https://hackage.haskell.org/package/crawlchain-0.1.0.8 (axm)
00:42:34 * hackagebot crawlchain 0.1.0.9 - Simulation user crawl paths  https://hackage.haskell.org/package/crawlchain-0.1.0.9 (axm)
01:21:10 <kamyar> Hello everyone
01:22:02 <kamyar> Please help me use MVar
01:22:29 <lyxia> what's the problem?
01:24:43 <arianvp> http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/
01:25:07 <arianvp> dhananjay: ^
01:29:17 <kamyar> I have a Python project which I am now porting to Haskell
01:29:33 <kamyar> There is a websocket server to which clients connect
01:30:05 <kamyar> and a ZMQ consumer which gets the message and sends its content to some selected websocket clients corresponding content data
01:30:32 <kamyar> I have to use MVar to hols connection state
01:30:38 <kamyar> I mean a list of connected websocketb client
01:30:42 <kamyar> clients
01:31:04 <kamyar> when a new user connects I must add the client to the list
01:31:16 <kamyar> and when the user disconnects I must cleanup list
01:31:36 <kamyar> Please give me clue about using MVar here
01:38:55 <ongy> kamyar: what part of using MVar do you not get? How to create/read/write? Or something different?
01:40:30 <kamyar> ongy: I have many ways and I am confused which to choose
02:04:37 <amx> too bad he left
02:04:41 <amx> there's a book about that hehe
02:06:07 <maybefbi> im looking for a :: Arrow a => a b b -> a [b] [b]
02:06:17 <maybefbi> hayoo and hoogle don't have them
02:06:19 <maybefbi> any ideas?
02:09:13 <pavonia> Is there a way to take a list of strings as the input parameters for printf?
02:09:30 <maybefbi> pavonia, which printf?
02:09:45 <pavonia> From Text.Printf
02:13:12 <maybefbi> pavonia, you have to write a, instance (IsString s) => PrintfArg [s] where
02:13:39 <maybefbi> as shown here https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Text.Printf.html#line-325 for characters
02:14:14 <maybefbi> follow explanation here: https://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Printf.html#g:2
02:15:52 <pavonia> Hhm, I don't want a new argument type for lists, but apply printf to all the elements in the list
02:17:06 <pavonia> Like apply s ["a", "b", "c"] = printf s "a" "b" "c"
02:18:56 <lyxia> maybefbi: I think you'll need ArrowChoice to deconstruct the list.
02:19:35 <maybefbi> lyxia, thanks
02:19:40 <maybefbi> let me check
02:20:04 <maybefbi> pavonia, it might be impossible to exactly that syntax
02:20:13 <maybefbi> *to have
02:20:45 <kamyar> ongy: Did u answer? Sorry I got dc
02:21:43 <ongy> kamyar: no. I don't think I can be of to much help. When I need them I just use what I think fits best 
02:22:27 <lyxia> maybefbi: I don't know if there's a library for that though.
02:23:39 <pavonia> maybefbi: You mean it's impossible to apply printf to a dynamic number of parameters?
02:27:35 <maybefbi> pavonia, printf can do  printf "%s %s\n" "Hello" "World"
02:28:10 <maybefbi> but the syntax you are asking is different
02:28:48 <maybefbi> it might need some TH shenanigans to convert the array on the left to AST nodes on the right
02:29:15 <pavonia> But that's static, I want dynamic application
02:30:31 <ongy> pavonia: are you building the format string during runtime aswell?
02:30:54 <maybefbi> consider doing lifting printf <$> "%s %s\n" <*> "Hello" <*> "World"
02:31:06 <maybefbi> but that needs format string to be known before hand
02:31:31 <pavonia> ongy: Yes
02:31:50 <maybefbi> well in that case you have to invent, instance (IsString s) => PrintfArg [s]
02:32:19 <ongy> pavonia: is there a reason you want to use printf, and don't use some (String -> String) functions?
02:33:28 <lpaste> lyxia pasted “Printf a list (to pavonia)” at http://lpaste.net/184316
02:33:42 <pavonia> ongy: At the moment it's just for strings, but I'd like to extend it to other types in the future, such that the whole power of printf can be used instead of writing all the formatting stuff again
02:34:13 <pavonia> lyxia: Wow, thank you!
02:34:51 <lyxia> :)
02:35:40 <cocreature> note that the list has to be homogenous so it’s not that useful
02:44:35 * hackagebot servant-auth-token-api 0.3.1.0 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.3.1.0 (NCrashed)
02:44:37 * hackagebot servant-auth-token 0.3.1.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.3.1.0 (NCrashed)
02:44:40 * hackagebot llvm-ffi 3.8.1 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.8.1 (HenningThielemann)
03:01:03 <Fadey> I dont get it
03:21:24 <lpaste> f-a pasted “pipes: >-> and different return values” at http://lpaste.net/184326
03:45:37 * hackagebot llvm-tf 3.1 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.1 (HenningThielemann)
03:45:39 * hackagebot text-metrics 0.1.0 - Calculate various string metrics efficiently  https://hackage.haskell.org/package/text-metrics-0.1.0 (mrkkrp)
03:45:41 * hackagebot llvm-extra 0.7 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.7 (HenningThielemann)
03:45:43 * hackagebot synthesizer-llvm 0.8 - Efficient signal processing using runtime compilation  https://hackage.haskell.org/package/synthesizer-llvm-0.8 (HenningThielemann)
03:45:46 <nmattia> :q
03:45:51 <nmattia> wops
03:50:36 <kamyar> Hello again
03:51:43 <amx> kamyar: there is a book about writing servers in haskell: http://chimera.labs.oreilly.com/books/1230000000929/index.html
03:51:50 <amx> there are code samples for what you are trying to do
03:52:17 <amx> chapter 12
03:53:15 <kamyar> amx: Thanks! But I have to make a trivial server before reading the book. I have not much time
03:53:54 <cocreature> f-a_: are you asking why the result is discarded or why you can’t compose pipes with different types if the result is discarded anyway?
03:55:01 <f-a_> cocreature: the latter
03:55:39 <nmattia> Is there a language extension that allows you to omit commas when breaking lines? or would that cause problems?
03:55:43 <cocreature> f-a_: when you have f >-> g and f terminates before g the result of f will be returned, if it’s the other way around the result of g will be returned. so the return type has to be the same
03:57:34 <suppi> kamyar: you do not have to read all of it btw. probably 10->12 might  be enough 
03:57:42 <f-a> cocreature: thanks. is there a trivial example of an f >-> g where f terminates before g?
03:58:31 <f-a> nmattia: do you mean when using unlines ["something something", "goo"]?
03:59:05 <cocreature> f-a: return "terminated" >-> cat
04:00:51 <f-a> very nice cocreature , thanks for the explanation
04:00:57 <cocreature> np
04:40:15 <infinity0> what's this thing "\x -> monad" called that composes over >=>
04:40:28 <infinity0> is there a short name for it, i mean
04:40:37 <mniip> kleisli arrows
04:41:13 <infinity0> got it, thanks
04:49:53 <bollu> I'm trying to write literate haskell + markdown, but ghc screws up with ### Heading in comment sections
04:49:57 <bollu> it seems to be a known bug
04:50:01 <bollu> does anyone have workarounds?
04:50:54 <mauke> setext-style headers?
04:51:38 <bollu> maybefbi: markdown style
04:51:43 <bollu> mauke: ^ sorry
04:53:56 <mauke> that's not a thing
04:54:13 <mauke> quoting from the reference documentation, "Markdown supports two styles of headers, Setext and atx."
04:57:53 <bollu> mauke: I suppose I meant atx style headers - which you create by stacking "#" symbols
05:01:15 <bollu> mauke: any fixes?
05:16:07 <mauke> ??
05:24:30 <cads> Hey guys, I was wondering if you guys know how to build a kind of "structured english" interface on top of a database
05:26:01 <cads> Similar to what wolfram alpha does, where you can give it a recipe, say, "1 cup brown rice, 1 raw egg, 1 tbsp butter, 1 tsp sesame seeds", and it pulls the nutrition data from the USDA database and composes it into a nutritional label: https://www5a.wolframalpha.com/Calculate/MSP/MSP5781hf85e0c8864b4g7000060b5g11b7gc90i54?MSPStoreType=image/gif&s=56
05:27:23 <cads> (btw that dish is called Tomago Gohan, it's the easiest breakfast ever, and I'm kinda obsessed with it)
05:28:19 <bollu> mauke: do you know how to fix the bug with markdown + lhs?
05:31:21 <pavonia> cads: What data does your DB store?
05:34:00 <MarLinn> cads: You mean you want to replicate their poorly documented, semi-working attempt at creating a bad interface for a very small group of people? Oh, that's easy. Just throw together some regex until it's "good enough".
05:34:22 <cads> pavonia, it's the USDA Standard Reference, it has entries like this: https://ndb.nal.usda.gov/ndb/foods/show/1?fgcd=&manu=&lfacet=&format=&count=&max=35&offset=&sort=&qlookup=
05:35:01 <cads> pavonia, it's all one big table
05:35:19 <benneh> When I give an instance declaration, I can either give full definitions of the class's methods or I can omit them and use the class's default definitions. Is there a middle ground? Can I give a partial definition and use the class's default definition for any cases not covered?
05:36:16 <cads> MarLinn, yes on the special use interface, but I'd like to do it with a less ad-hoc and laborious method than regexen ;)
05:37:21 <pavonia> Then replace regex by Parsec? :p
05:37:55 <pavonia> The grammar doesn't look to difficult here
05:41:07 <pavonia> benneh: You could give default definitions based on other definitions. I think that's what most of the classes do that can have different minimal complete definition sets
05:42:40 <cads> ideally a recipe is a comma delimited list of ingredients and quantities with a modifier. But there are multiple ways to say the same thing, and a few common ways to break the comma delimited list syntax.  Someone might say "One cup brown rice, cooked, 1 tbsp. butter, ", while someone else would say "One cup cooked brown rice, one TBSP butter"
05:43:28 <MarLinn> cads: what you could do is parse it like pavonia suggested, then feed it into a system that normalizes the parts (eg. turns it into lower case) and then tries to match them within some edit-distance.
05:44:03 <MarLinn> modifiers like "cooked" would need yet another special handler
05:44:12 <cads> parsec's great for a precise grammar, but I'm looking for a parser that's better at handling the slightly imprecise grammar that comes from natural language, even when the user is trying to speak in a fairly structured way
05:44:15 <benneh> pavonia: I have one method which has a default definition based on the other definitions. But I want to be able to give an instance declaration which overwrites that default definition only for some cases, using the the default definition for the remaining cases.
05:44:37 <MarLinn> And then the question is: What parts can the DB do, and which parts should Haskell do
05:45:25 <Reshi> And what libraries are good for NLP 
05:45:29 <pavonia> benneh: Yes, you can override individual default definitions
05:46:11 <cads> yeah I'm thinking I need to get with some theory of parsers specially designed to handle natural language, rather than trying to hack it
05:47:19 <cads> Check out the way Alpha handles it, it's actually really impressive: https://www.wolframalpha.com/input/?i=1+cup+brown+rice,+1+raw+egg,+1+tbsp+butter,+1+tsp+sesame+seeds
05:47:37 <MarLinn> benneh: so you want an equivalent to "foo(x){if bar(x) then myFoo(x) else super.foo(x);} ?
05:47:53 <benneh> pavonia: Sorry, I don't think I'm explaining myself well. I want to override the default definition with a partial function, and use the default definition as a fallback for any cases which the partial function does not cover.
05:48:22 <benneh> MarLinn: yes
05:48:48 <benneh> MarLinn: but the if statement will be a pattern match, if that makes any difference
05:49:57 <MarLinn> benneh: A simple way would be to factor out the default implementation into a "defaultFoo", have foo default to defaultFoo, and just fall back to defaultFoo in the pattern match as well
05:49:57 <cads> Lol, actually, it completely drops the ball on my "1 cup brown rice, cooked.." example.
05:50:16 <cads> I feel a little better about that, lol :D
05:52:32 <pavonia> benneh: I can't think of a way to access the default implementation if you give a more special version, so what MarLinn said is probably your best bet
05:53:19 <benneh> MarLinn: Currently, the module which contains the class definition imports the module which contains the instance declaration. If I were to define defaultFoo in the module with the class definition, that would cause a cyclic dependency.
05:53:39 <benneh> And if I were to define it in each module which contains an instance declaration, I'm not saving myself any work.
05:54:56 <NickHu> Hi, I'm just wondering if there is a way of doing something like val :: (Num a => a) to force haskell to intepret something as a member of the Num typeclass
05:55:34 <MarLinn> benneh: How can you define an instance if the class is not present?
05:56:53 <pavonia> NickHu: You can't cast it to another type, if you mean that
05:57:13 <benneh> MarLinn: sorry, ignore my last comment, it was clearly nonsense :)
05:58:10 <NickHu> pavonia: http://lpaste.net/184379
05:58:30 <NickHu> Essentially, I want to be able to parse anything that isn't already a string by `show`ing it first
05:58:52 <benneh> MarLinn: I think that will work. Thanks :)
05:58:52 <NickHu> But I'd like to put something like (Num a => Parser a) in place of Parser Integer
06:00:38 <Reshi> NickHu: What does your Test constructor look like?
06:00:38 <pavonia> NickHu: You have to know the intermediate type to do that, because the Show instances for e.g. Int and Double are different
06:01:04 <NickHu> data Test = Test {testName :: String, input :: String, output :: String} deriving Show
06:01:47 <pavonia> (and the FromJSON instances use different parsing functions too)
06:01:54 <NickHu> pavonia: Does that mean I have to duplicate that line for Float, Double, etc?
06:02:17 <pavonia> Yes
06:02:34 --- mode: ChanServ set +o mauke
06:04:26 <Reshi> NickHu: When you do 'fmap show', you want to build a list of strings?
06:05:00 <NickHu> No, not a list, but I'm applying show to the value inside the Parser functor
06:05:00 <Reshi> okay nevermind
06:05:57 <NickHu> Is there an infinite precision concrete type for non-integral numbers? Like Integer but for decimals
06:06:48 <pavonia> Scientific
06:07:24 <mauke> Rational?
06:07:47 <pavonia> Scientific is what aeson already uses for numbers, btw
06:10:29 <NickHu> Oh so I could just use that then; thanks!
06:16:48 <erik__> does anyone have any experience with SBV and time to hopefully quickly point out what I've done wrong? essentially I want to make a 2d array where the rows and columns have particular products, along with some constraints about which numbers are allowed and that there can only be a certain number of each
06:16:54 --- mode: morgan.freenode.net set +o ChanServ
06:17:10 <erik__> however when I get the models out the products of the rows and columns only mostly match what I've asked for :/
06:17:40 <erik__> I've stuck the code up here: http://lpaste.net/9106222745112281088
06:23:34 --- mode: mauke set -o mauke
06:27:31 <lpaste> mahdi pasted “stack, base conflict” at http://lpaste.net/184383
06:28:23 <mahdi> hey, as far as I understand this conflict can be resolved using base-4.7.0.2, but I keep getting this error ^
06:29:09 <cocreature> mahdi: the version of base is tied to the version of ghc so you need to use an older ghc (<7.10)
06:29:58 <mahdi> cocreature: oh, I see. thanks
06:48:41 * hackagebot yaml 0.8.18.5 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18.5 (MichaelSnoyman)
06:48:43 * hackagebot wai-websockets 3.0.1.1 - Provide a bridge between WAI and the websockets package.  https://hackage.haskell.org/package/wai-websockets-3.0.1.1 (MichaelSnoyman)
06:48:45 * hackagebot hdevtools 0.1.4.1 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.4.1 (ch1bo)
07:09:08 <doobie> Hi, stack has been stuck at copy/register (shakespeare) for nearly a half hour, is that normal?
07:09:41 <doobie> ^when I did stack buils yesod-bin
07:09:57 <bollu> what's a issue a GHC noob could take up?
07:10:07 <bollu> I've compiler GHC and played around with day 2 ghci
07:10:11 <bollu> stage 2*
07:16:25 <nmattia> f-a: not sure what you mean! 
07:16:38 <tsahyt> why do the functions in Data.Complex (from base) have specialize pragmas for Double, but not for Float?
07:19:04 <hpc> tsahyt: perhaps it was just forgotten?
07:19:25 <tsahyt> hpc: seems like it. Some things, like the Num instance, does specialise to both. other functions like conjugate do not.
07:19:31 <hpc> single-precision floats are so terrible that it's rare to see them used
07:20:16 <tsahyt> I'd say that depends a lot on the use case. They're very useful in computer graphics where precision isn't always *that* important.
07:21:03 <tsahyt> mostly because they can be faster using vectorization or even offloading computations to the GPU. GPUs that perform well on double precision numbers tend to be much more expensive (tesla etc)
07:33:05 <ggole> Graphics guys try to scrimp and use half-floats if they can get away with it
07:35:27 <MarLinn> That's an interesting perspective. Half of a whole lecture series I once attended was about methods to allow fast, infinite precision floating point numbers for geometric problems. Eg: how to be *really* sure if a line hits a shape? And as graphics = mostly geometric problems, both perspectives seem incompatible to me
07:37:18 <ggole> Graphics are *bounded* geometric problems
07:37:24 <ggole> (Usually.)
07:38:16 <ggole> I've seen some of the attempts at writing precise numeric primitives for floats
07:38:18 <ggole> Scary stuff
07:38:32 <ggole> It *really* shouldn't be that hard to compute the dot product!
07:41:11 <ahihi> f32 is also not uncommon in audio
07:41:37 <ahihi> although many algorithms do need the extra precision of f64
07:43:03 <Ke> and even more often people might not analyze, whether f64 is even enough
07:43:35 <Ke> but throwing double there makes sense, if it doesn't really matter
07:44:46 <MarLinn> well I wouldn't say it's "hard"... just use the common iterative techniques like that used for sqrt or log, double the precision in every round, add a decent error predictor to see if you current precision is enough, and you're good to go. Way slower than float, but exact
07:45:59 <marrrk> Hey I have an email body. I would like to only get the message from that. Is that possible? I used https://hackage.haskell.org/package/imap to get the body.
07:49:38 <marrrk> Maybe this: https://hackage.haskell.org/package/email-header ?
08:20:47 <xcmw> Is there any way to use makeFields from lens without the annoying prefix when using the constructor?
08:23:48 <lyxia> xcmw: makeFields = makeLensesWith defaultFieldRules, you can set your own rules to replace the default ones
08:23:51 <sm_> doobie: did it finish ?
08:26:21 <c_wraith> xcmw: note that the lens can't have the same name as the record field, if it's in the same module
08:27:49 <xcmw> Is there a way to construct an object using the lens name instead of the record field name?
08:29:15 <c_wraith> There is with a Prism, which is kind of a stronger lens
08:30:58 <xcmw> http://lpaste.net/184427
08:31:24 <marrrk> I have some C problems when building my code because of a dependency on OS X.
08:31:42 <marrrk> emailparse-0.2.0.6/csrc/codec.c:7:10:  fatal error: 'codec.h' file not found
08:33:51 <xcmw> c_wraith: How?
08:36:01 <NickHu> Is it considered better style to enable language extensions project wide by putting it in the cabal file, or at the top of each haskell source file?
08:36:15 <NickHu> Also, is it possible to define a project wide import if I want to use a different prelude?
08:54:18 <jophish_> Is there any linear-quickcheck-orphans package around?
08:59:09 <xuxu> in http://users.jyu.fi/~sapekiis/haskell-pitfalls/ how is the person able to type multiline statements without using :{ and :}
09:00:03 <xcmw> xuxu: :set +m
09:02:55 <mahdi> what should we do if a package is dependency of two other packages, without matching versions. e.g. a package requires transformers-0.3.0.0 and the other one transformers-0.5. something, I can't find a version which satisfies both.
09:04:07 <monochrom> yeah, I think that's unsolvable.
09:04:39 <Clint> mahdi: get them both to join stackage so that that doesn't happen
09:05:17 <amx> mahdi: which package
09:07:00 <thenakedmolerat> hey
09:08:15 <thenakedmolerat> what's up guys
09:09:28 <xuxu> that doesn't seem to do what i thought it would do
09:09:52 <xuxu> data myBool = myTrue
09:10:02 <mahdi> amx: transformers as a dependency of transformers-compact and network-simple, they do not match
09:10:02 <xuxu>            | myFalse
09:10:13 <mahdi> Clint: hmm, I'll create an issue on their github
09:10:17 <xuxu> parse error on '|'
09:10:30 <monochrom> use "My" instead of "my". you need capital case there.
09:10:36 <nitrix> Hi, I'm working on lambdabot's undefine to let you remove arbitrary bindings. I'm hitting a corner case where you might have classes and types with the same name.
09:11:02 <xuxu> monochrom: sorry, i typed it with cap in ghci
09:11:13 <xuxu> had a brain fart just now
09:11:18 <nitrix> Do I allow `@undefine class Foo`, `@undefine data Foo` or simply `@undefine Foo` which will erase both?
09:12:58 <Welkin> I like @undefine to erase everything :D
09:13:31 <nitrix> Welkin: The goal is to not erase everything.
09:13:37 <Welkin> you can load up an lpaste if you need something that complex
09:13:39 <amx> mahdi: did you mean transformers-compat?
09:13:56 <nitrix> Welkin: It's not about what you can and cannot do, it's about improving it.
09:14:02 <monochrom> I'm sure the erase-everything option will still be available
09:14:03 <nitrix> Welkin: I'm also working on per-user namespaces.
09:14:09 <nitrix> monochrom: Yup, still there.
09:14:11 <xuxu> oh, :set +m doesn't allow you to create a new type 
09:14:18 <xuxu> you still have to use :{ :}
09:14:29 <xuxu> :{ }:
09:15:25 <monochrom> xuxu, I just saw from the user guide that you can tell from the prompt, Prelude> vs Prelude|
09:15:49 <monochrom> it always pays to read the user guide itself rather than wait for hearsay to trickle down
09:15:59 <xuxu> yeah, i set prompt2 to be "| " and that's how i figured it out
09:16:07 <xuxu> reading it :)
09:16:08 <xuxu> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/interactive-evaluation.html#ghci-multiline
09:17:03 <monochrom> there is also a clause "A multiline command is prompted for when the current input line contains open layout contexts"
09:17:16 <monochrom> and "data" is not one of them
09:17:32 <mahdi> amx: yes
09:17:34 <xuxu> i don't understand what accounts for an open layout context
09:17:37 <sdrodge> Presumably would work if you ended the first line with |
09:17:38 <monochrom> whereas "let" and "do" are
09:17:52 <xuxu> seems class is open layout
09:18:01 <monochrom> no, "where" is
09:18:16 <monochrom> try "class X a". you'll see.
09:18:25 <xuxu> yep, you're right
09:18:38 <monochrom> for the full story you will have to read the Haskell 2010 Report section 2.7
09:18:56 <monochrom> but the short story is "those things that causes implicit { "
09:19:11 <amx> mahdi: then I guess the question is which versions you try to install, because the latest ones have compatible dependencies
09:19:48 <xuxu> thanks for the reference!
09:20:47 <monochrom> I need to write a blog on "the pitfall of reading blogs"
09:21:16 <xuxu> please do and link! 
09:21:22 <monochrom> "1. They don't tell you the necessary prerequisite and preparation that can let you reproduce their results."
09:22:00 <monochrom> "2. They don't tell you where in the complete documentation you can find the full story. They want you to cargo-cult."
09:23:00 <mahdi> amx: oh, you are right, I see. thanks
09:24:22 <monochrom> "3. They don't teach you the controversy." :)  "4. Their comment systems are crappy."
09:26:59 <xuxu> monochrom: i wanted to see what the haskell community was up to this summer, so i started browsing hackernews, which is how i came up with that blog post
09:27:28 <xuxu> https://news.ycombinator.com/item?id=12334135 https://news.ycombinator.com/item?id=12288640 https://news.ycombinator.com/item?id=12264376 https://news.ycombinator.com/item?id=12209889 https://news.ycombinator.com/item?id=12190562 https://news.ycombinator.com/item?id=12185277 https://news.ycombinator.com/item?id=11970390 https://news.ycombinator.com/item?id=11894393
09:30:04 <hsk3> How do I return Nothing from a MaybeT IO monad?
09:30:07 <hsk3> This doesn't work: https://bpaste.net/show/da18691439fd
09:30:14 <Welkin> o.o
09:30:35 <hsk3> I'd expect that to wrap Nothing into an IO action, and then return that
09:30:53 <Welkin> that is not MaybeT IO
09:31:25 <c_wraith> MaybeT (return Nothing)
09:31:55 <hsk3> c_wraith: ah ok thanks
09:31:56 <hsk3> coz
09:31:56 <pavonia> Or just fail ""
09:32:18 <c_wraith> pavonia: I don't think that'll work when fail is removed from Monad. :P
09:32:25 <jmcarthur> empty
09:32:44 <pavonia> c_wraith: When will that happen?
09:32:45 <jmcarthur> from Control.Applicative
09:33:04 <Welkin> pavonia: when you least expect it
09:33:17 <c_wraith> hsk3: alternatively, you could use mzero from the MonadPlus class
09:33:20 <jmcarthur> runMaybeT empty
09:33:30 <pavonia> Welkin: So 3 minutes ago? :p
09:34:01 <c_wraith> I know there have been discussions about it.  
09:34:19 <c_wraith> Like, among the same group that brought us AMP
09:34:37 <jmcarthur> https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail
09:34:56 <jmcarthur> We already have the proposed MonadFail type class, so it's moving along.
09:35:33 <jmcarthur> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-Fail.html#t:MonadFail
09:37:11 <hsk3> c_wraith: is that the recommended shortcut? in order to avoid lots of "MaybeT . return"
09:37:31 <c_wraith> hsk3: yeah mzero is probably the best approach
09:39:01 <pavonia> So it's already marked as being "removed in a future release"
09:44:47 <MarLinn> but mzero == empty, and "empty" has fewer restrictions, so it might be better to train yourself to use "empty". The same way you should strive to purge "return"
09:45:21 <MarLinn> s/should/might want to
09:46:00 <pavonia> :t (mzero, empty)
09:46:01 <lambdabot> (Alternative f, MonadPlus m) => (m a, f a1)
09:46:26 <ertesx> i'd consider mzero obsolete now
09:46:32 <ertesx> empty is the proper one
09:47:57 <pikajude> :t [mzero, empty]
09:47:58 <lambdabot> MonadPlus m => [m a]
09:51:45 * hackagebot vty 5.11 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.11 (JonathanDaugherty)
09:51:47 * hackagebot JuicyPixels 3.2.8 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.8 (VincentBerthoux)
09:52:07 <ertesx> hlint could actually check for stuff like 'return' and 'mzero' and become a useful tool instead of ruining my lpaste experience, because it thinks i'm overusing parentheses
09:56:04 <daf> is there a more idiomatic way to say CL.fold mappend mempty?
09:56:20 <ertesx> daf: what's CL?
09:56:34 <MarLinn> :t msum
09:56:36 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
09:56:38 <glguy> :t fold
09:56:40 <lambdabot> (Monoid m, Foldable t) => t m -> m
09:57:04 <daf> sorry: Data.Conduit.List
09:57:24 <ertesx> daf: in that case, if they haven't written a combinator for it, unlikely
09:58:23 <ertesx> daf: there is foldMap
09:58:27 <ertesx> daf: CL.foldMap id
09:58:58 <ertesx> and that's basically the conduit version of what glguy wrote
09:59:12 <daf> haha
10:00:02 <MarLinn> :t Data.Conduit.List.fold
10:00:04 <lambdabot> Monad m => (b -> a -> b) -> b -> conduit-1.2.7:Data.Conduit.Internal.Conduit.ConduitM a o m b
10:00:33 <MarLinn> why does their fold have the wrong type? o.O
10:01:17 <monochrom> \∩/
10:01:34 <ertesx> some would say that Data.Foldable.fold has the wrong type =)
10:01:47 <monochrom> There is no right type.
10:02:11 <monochrom> But there is an Either type. data Either a b = Wrong a | Right b
10:02:31 <ertesx> there is with -XDataKinds
10:02:41 <monochrom> but then it has the wrong kind.
10:02:43 <daf> actually, I think Data.Conduit.Combinators.fold is msum
10:02:46 <monochrom> :D
10:02:52 <MarLinn> ok... right is only a function, not a type...
10:02:53 <daf> to add to the fold confusion
10:03:15 <ertesx> lovely
10:03:23 <daf> I... want to like conduit
10:03:27 <monochrom> many-fold confusion
10:03:39 <ertesx> manifold nfusion
10:03:51 <daf> thanks everyone
10:04:10 <monochrom> I think conduit is only a few easy definitions away from your perfect liking
10:04:30 <ertesx> daf: if you have a choice, the pipes library tends to follow conventions more
10:04:43 <daf> I can never remember the order in the type signatures
10:04:45 <ertesx> and it's basically the same abstraction, except with less built-in stuff
10:05:07 <monochrom> I don't remember them either. I ask :type
10:05:10 <daf> in this case I'm constrained, but good to know
10:05:31 <monochrom> I ask :type even for the vanilla foldl and foldr. every time.
10:05:46 * MarLinn wonders if there is a library that provides folds with a type parameter to set the direction
10:05:54 <monochrom> There are more important things to remember.
10:06:01 <ertesx> there is a very useful key that tends to work in GHCi and your editor's haskell integration: tab
10:06:05 <ertesx> :t fold<tab>
10:06:07 <lambdabot> error:
10:06:07 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
10:06:35 <daf> I mean reading :t output it will tell me it's a ConduitM x y m z and I won't be able to remember which of x y and z are input/output/result
10:06:41 <monochrom> Such as the number "2.7" for the section number of the informal layout rules in Haskell 2010
10:07:22 <ertesx> daf: since it's a monadic abstraction, the last parameter is always the result, and since it's a transformer the second-to-last argument is the transformed monad
10:07:40 <ertesx> daf: the rest is just the usual left-to-right input-to-output
10:07:56 <monochrom> yeah it seems that z is doomed to be the "result". can't help you with x and y though
10:08:16 <ertesx> daf: if it would be an applicative/arrow abstraction, there would be some choice, but a monad has no choice
10:08:20 <monochrom> is ConduitM a type synonym?
10:08:32 <Welkin> probably
10:08:58 <daf> it is
10:09:09 <monochrom> then you need to always expand it for its true meaning
10:09:23 <ertesx> monochrom: except with pipes/conduit it really only adds to the confusion =)
10:09:26 <monochrom> which is why I am not fond of type synonyms
10:09:46 <ertesx> the base type is a crazy 6-argument beast
10:10:22 <monochrom> then it should be a newtype and a well-thought-out, non-leaky abstraction.
10:10:47 <Welkin> that is how all snoyberg libraries are
10:10:48 <daf> oh no, ConduitM is a newtype
10:11:03 <monochrom> then that's better
10:11:35 <ertesx> i can't speak for conduit, but with pipes it's the lens deal:  trade leaky for some extra power
10:11:57 <ertesx> that's why Pipe (the pipes equivalent to ConduitM) is a type synonym
10:12:16 <monochrom> yeah lens is approximately the only case that can justify type synonyms.
10:12:58 <MarLinn> -XPlugLeakyTypes
10:13:16 <monochrom> if you keep it as a type synonym, then the vanilla (.) just works. that is a valuable gain.
10:13:35 <monochrom> but 99% of the libraries aren't like that.
10:14:51 <sdrodge> Obviously there are more type synonyms than lenses that are demonstrably fine.
10:15:00 <daf> the regex libraries are very leaky in ghci if you don't constrain types
10:15:01 <ertesx> in the case of those streamers i wouldn't call it a leak though…  it's more a special case…  the trouble starts when type errors favour the base type over type synonyms for error reporting, in which case you need to be familiar with the base abstraction to understand the error
10:15:24 <sdrodge> e.g. type State s = StateT s Identity
10:15:58 <ertesx> which is the 6-argument beast called Proxy i was referring to (not the one from Data.Proxy)
10:16:33 <daf> hmm so newtypes will tend to be an error message win over type synonyms in these situations?
10:16:52 <MarLinn> -XReportAllTypeIndirectionLevelsOnError
10:17:32 <ertesx> daf: they are almost always an error reporting win and very often a safety win (preventing abstraction leaks), usually at the cost of some expressivity
10:19:07 <monochrom> the author needs to think it out what is a complete suite of functions so that the user never needs to know the implementation details
10:20:15 <nitrix> If people want me to help test the robustness of the @undefine lambdabot feature, head to #haskell-test :)
10:20:28 <monochrom> for example Text.PrettyPrint.HughesPJ is like that. Doc is an abstract, opague type. You don't want to know what's inside. But the provided combinators are already complete.
10:20:49 <monochrom> In fact they even wrote down the algebra laws for the combinators.
10:21:26 <ertesx> a pragma would be nice to help error reporting choose suitable type synonyms when appropriate and available
10:21:42 <monochrom> (but maybe they didn't write down the complete laws. still...)
10:21:48 <ertesx> e.g. tell GHC that a lens composed with a traversal is a traversal
10:21:59 <ertesx> or that a producer composed with a pipe is a producer
10:24:17 <ertesx> {-# RESULT_TYPE (f :: Lens a b c d) (g :: Traversal c d e f) -> (f . g :: Traversal a b e f) #-}
10:24:21 <ertesx> something like that
10:26:34 <MarLinn> maybe that could even be an extension to plain type synonyms. Why shouldn't a type synonyms have multiple (possibly overlapping) "instances"?
10:27:02 <EvanR> type directed name disambiguation
10:28:26 <ertesx> MarLinn: the RESULT_TYPE idea is in a sense the other direction: help the type system determine that a type should be a written in terms of a synonym when there is no other indication
10:28:26 <MarLinn> and in this case multiple possible results would not hurt anyone, as long as enough of them are reported
10:29:12 <ertesx> for example if you write (_1 . traverse), GHC will rightfully think of this as a: (Field1 s t (t1 a) (t1 b), Traversable t1, Applicative f) => (a -> f b) -> s -> f t
10:29:17 <the_2nd> I've been using the http packe to read websites. Now I have to also support https. Which package should I use?
10:29:22 <ertesx> it doesn't know that 'traverse' is actually a Traversal
10:29:58 <ertesx> the_2nd: for a high-level library see wreq
10:30:14 <ertesx> the_2nd: if you need a lower-level library see http-conduit
10:33:22 <the_2nd> ertesx, I basically only need to either read raw url data as bystring
10:33:33 <the_2nd> or the html code of a website
10:33:49 <sdrodge> I watched an SPJ talk on YouTube the other day and I noticed that even he only looked at the line number of the GHC error, and tried to figure out what was wrong from scratch without consulting any of the error text.
10:34:14 <MarLinn> ertesx: so RESULT_TYPE would not even have to "return" existing types, right? I'm sure there are some use cases for that
10:34:37 <glguy> sdrodge: Yeah, it's usually enough to be directed to the location of the error to find it when you know what you're looking for
10:35:28 <EvanR> in that case there should be a flag which only outputs line numbers
10:35:28 <sdrodge> glguy: Yes, but it's highly amusing given GHC's reputation w.r.t. to errors.
10:35:29 <ReinH> SPJ has read a lot of GHC errors, he's probably getting pretty good at it.
10:35:46 <sdrodge> glguy: Even the author finds them too verbose and annoying to read! :P
10:35:48 <ertesx> MarLinn: yeah, just a helper pragma to improve error reporting with libraries like lens and pipes, not even a language extension
10:35:56 <EvanR> but its probably more like a MUD where you dont really read anything, you just know from the shape of the text whats going on
10:35:58 <ReinH> It's also possible that he wrote the error message in question.
10:36:36 <EvanR> blond brunette redhead
10:36:37 <glguy> sdrodge: I think it's more likely that sometimes the error text is helpful and sometimes its not but that it's hard to know which errors are which
10:37:08 <sdrodge> I personally actually find the error messages quite helpful and don't understand the typical criticism.
10:37:27 <sdrodge> But given that the criticism exists and I saw this happen, it's pretty amusing.
10:38:10 <MarLinn> ertesx: sounds like a good plugin to write for a ghc beginner...
10:38:39 <monochrom> my impression is that the error messages are right on for professional code, and always guess wrong for beginner code
10:38:48 <ertesx> MarLinn: a lot of haskell beginners/intermediates would thank you =)
10:39:14 <monochrom> this is because you need a much larger dose of "do what I mean" for beginner code, e.g., wrong number of parameters
10:39:37 <monochrom> frankly this can't be helped. GHC is not an artificial intelligence yet
10:39:58 <ReinH> Wrong number of parens is particularly hard for beginners to debug.
10:40:01 * MarLinn extends his todo-list with yet another project
10:40:26 <ReinH> And for compilers to report accurately
10:40:38 <ggole> A bit of redundancy in the syntax helps
10:40:48 <dolio> I'm not sure they're useful for professional code.
10:41:06 <ReinH> You see lots of "why am I getting this entirely unrelated error?" "Count your parens"
10:41:08 <monochrom> as another example beginner code contains things like 1+"hello" (this is an exaggeration) and the error message is of course going to mumble something about classes, instances, Num.
10:41:27 <ertesx> well, GHC reports the error that happened…  with currying and polymorphism (you know, the proper kind of it) GHC really doesn't know that you just forgot an argument
10:41:35 <monochrom> clearly this "doesn't help" beginners but when you become professional you will want it.
10:42:04 <ertesx> it would need to think in context in order to report a better error there, and that's reserved for a future intelligent AI =)
10:42:38 <ggole> It wouldn't be hard to change the error messages so that 1 + "foo" produced something beginner friendly
10:42:44 <ggole> It would be a filthy hack, of course
10:42:51 <sdrodge> You could probably do some simple regrouping of terms to suggest missed parens, actually.
10:43:04 <ertesx> ggole: and then you need one for "foo" + 1, for ["foo", 1], for …
10:43:05 <sdrodge> Same with swapping arguments.
10:43:13 <ertesx> ggole: it doesn't scale
10:43:25 <ggole> You don't have to scale, you just have to do some common things like Num
10:44:11 <ertesx> ggole: or you let people experience the error messages and help them deal with them
10:44:23 <ertesx> there is a point when hand-holding starts to hurt
10:44:48 <ggole> Yeah, and it's waaaay after a beginner gets over the first hump
10:45:14 <monochrom> In the big picture, ideal error messages are unnecessary.
10:45:33 <Welkin> no error messages because there are no errors
10:46:07 <monochrom> I don't know whether ideal error messages can be done. But if it can be done, then Do-What-I-Mean and Fixed-It-For-You can also be done, at which point error messages are moot.
10:46:42 <xuxu> in http://learnyouahaskell.com/making-our-own-types-and-typeclasses i'm trying to understand the function treeInsert :: (Ord a) => a -> Tree a -> Tree a  
10:46:48 <xuxu> does anyone have the time to explain?
10:46:49 <MarLinn> > [1,"foo"] -- is that error message really the best we can do?
10:46:51 <lambdabot>  error:
10:46:51 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘1’
10:46:51 <lambdabot>      • In the expression: 1
10:47:37 <xuxu> i think this guard x == a = Node x left right is used for creating a root node 
10:47:39 <monochrom> It is more profitable to replace programmers than improve error messages.
10:47:53 <ertesx> ggole: you may be underestimating people
10:48:30 <xuxu> and this guard x < a = Node a (treeInsert x left) right has me completely baffled
10:48:32 <kadoban> MarLinn: It's rather hard to know what to say instead, that wouldn't be 95% lies.
10:48:37 <monochrom> Here is another angle I've observed here. Many people seem to have a mental block on error messages.
10:49:40 <Welkin> xuxu: that is just a binary search tree
10:49:59 <monochrom> If you do so much as print to them "This is an error message. Press <return> to make me go away."  They will panic and ask in #haskell "I get this error message. what should I do?"
10:50:33 <Welkin> have ghc ring your bell for every error
10:50:38 <ertesx> also i'd like to remind everybody that beginners are not stupid…  in fact beginning haskell programmers are very often very smart people
10:50:41 <xuxu> Welkin: i know, but i'm unable to grasp how this function works
10:50:42 <Welkin> like in windows
10:50:49 <monochrom> That is an exaggeration too. But we all witnessed real cases in which the error message literally says "turn on -XFlexibleInstances" and the asker apparently never saw it.
10:51:24 <sdrodge> monochrom: One could argue that's due to messages usually being verbose and unhelpful, training the programmer to not read them.
10:51:26 <ongy> monochrom: I have to admit, I sometimes overlooked something like that
10:51:27 <xuxu> i understand it's probably a lot of typing to answer this question, so maybe the question is unfair to ask
10:51:30 <Welkin> xuxu: ifthe node already exists, do nothing and produce the original tree, if the value is less than the currect node's value, go left, otherwise go right
10:51:32 <implementation_> xuxu: the guards are a little like if-then or case structures. if (x == a) then the result is (Node x left right)
10:51:34 <sdrodge> (I wouldn't necessarily argue that, though)
10:51:40 <monochrom> It's why I theorize that people's brain detect error messages and shut down on them.
10:51:52 <MarLinn> kadoban: "incompatible arguments in functor []; Can't unify types of the expressions 1 and "foo"" ?
10:51:56 <Welkin> xuxu: in your function though, it looks like it is replacing the node if the values are equal, which is not necessary
10:51:56 <ongy> especially when I was new to GHC. by now I have learned reading it's error messages, but if it prints 5 pages of (for me) nonsense and somewhere in between that, such a line...
10:52:16 <Welkin> you should never have that many errors o.o
10:52:29 <Welkin> unless you are refactoring
10:52:43 <monochrom> but the -XFlexibleInstances cases were not 5 pages.
10:52:44 <kadoban> MarLinn: That would be a lie though ... it could if [Char] has a Num instance. The compiler would have to know if you want that or not.
10:53:10 <monochrom> I mean, gcc error messages for C++ when you forgot to overload an operator, sure.
10:53:41 <ertesx> the problem with improving error messages is:  if you really want better error messages, GHC has to start deducing context
10:53:54 <ertesx> and that's what improving error messages means:  you do context guessing
10:54:07 <ertesx> and that's haaaaaaaaaaaaard
10:54:18 <implementation_> i think ghc already has *great* error messages
10:54:21 <monochrom> GHC error messages tend to be short in the "you need to turn on an extension" cases. Yes they're long in the "really can't unify two types" cases.
10:54:31 <ongy> I think so to. But as a haskell newby they can be quite hard to read
10:54:38 <ggole> Elm manages pretty well (although it has a considerably easier job)
10:55:08 <exDM69> ongy: yeah, I have the same issue... sometimes they use jargon that isn't familiar to me
10:55:16 <exDM69> other times, they are really helpful, though
10:55:18 <ertesx> ongy: if all else fails, you have us to help you =)
10:55:43 <ggole> "rigid, skolem type variable" certainly had me scratching my head 
10:55:57 <ertesx> there is a great way to deal with every type error you will ever get:  dump it into your pastebin of choice, along with the code, show it to #haskell
10:56:15 <ongy> I read that and I still have no idea what it is
10:56:17 <c_wraith> ghc has great error messages when you understand the type system.  When you don't, they can be infuriatingly obtuse.
10:56:34 <exDM69> c_wraith: well said...
10:56:43 <kadoban> I don't know that it's possible to make error messages all that understandable to beginners. At the very least it seems like it'd require a "beginner mode" so the compiler can choose a different level of ... language and lying.
10:56:46 <ertesx> "type variable s escapes"
10:56:48 <ertesx> =)
10:56:59 <exDM69> my knowledge of the type system doesn't extend much further than plain old hindley-milner
10:57:15 <ongy> I have heard that term before :)
10:57:30 <exDM69> ongy: it's the basic type inference mechanism
10:57:30 <ertesx> kadoban: we had such a beginner mode: helium
10:57:32 <nshepperd> sdrodge: I think I would argue that people have been trained not to read error messages. by other software
10:57:34 <ertesx> kadoban: nobody wanted it though
10:57:42 <exDM69> ongy: hindley, milner (and damas) were the guys who pioneered it
10:57:42 <c_wraith> rigid type variables show up in cases other than escaping skolems
10:57:45 <ertesx> kadoban: haskell without type classes is just …
10:57:55 <c_wraith> Like...
10:58:03 <sdrodge> nshepperd: Interesting idea.
10:58:05 <c_wraith> :t "foo" :: [a]
10:58:07 <lambdabot> error:
10:58:07 <lambdabot>     • Couldn't match type ‘a1’ with ‘Char’
10:58:07 <lambdabot>       ‘a1’ is a rigid type variable bound by
10:58:10 <monochrom> oh without type classes the error messages are so much easier
10:58:16 <c_wraith> See?  Rigid type variable!
10:58:36 <nshepperd> sdrodge: in which case the answer us to add lots of colors to the error messages, to make them seem different & more friendly :)
10:58:58 <saurabhnanda> any Opaleye experts here? Any thoughts about https://github.com/nomicflux/servant-opaleye-blog/issues/3 ?
10:58:59 <kadoban> ertesx: I don't think I suggested removing type classes, just choosing what to report differently. And even that would be a ... hard problem.
10:59:04 <ongy> a (not haskell related) experience here: I do tutoring for programming exersizes, and I tend to have people with ~as many lines of gcc warnings as code they wrote. They just don't read it and then wonder if nothing works
10:59:32 <ertesx> kadoban: exactly…  the only way to make this scalable is to restrict the language
10:59:34 <c_wraith> gcc error messages for C++ are an especially horrible usability case.
11:00:09 <xuxu> putting my question in #haskell-beginners. this room is full of amazing people, but i feel like this is a longer conversation which will add to the noise
11:00:12 <ertesx> kadoban: we already have lots and lots of special cases with a "perhaps you wanted to do this" kind of error message, but no matter how many more you add, it will never be enough
11:00:22 <ggole> And they were pushed into improving them immensely by LLVM actually giving a damn
11:00:38 <Welkin> ongy: my experience with "dynamic" languages
11:00:52 <Welkin> well, python to be specific
11:00:54 <nshepperd> there was a recent paper on LtU about generating nice error messages, by pretending haskell is dynamically typed (tagged), and showing a reduction graph with concrete examples that makes it crash
11:00:55 <the_2nd> how can I convert a lazy bytestring to a strict one?
11:01:01 <Welkin> the_2nd: toStrict
11:01:21 <nshepperd> that only works for unification errors though, no typeclasses
11:01:29 <ongy> well, if I'm allowed to I will add -Werror to our template
11:01:34 <kadoban> ertesx: The only hope I can think of would be to ... treat working code the same, but give *different* (restricted) suggestions when broken code comes up. Like the example above, there's almost no chance a beginner wants a Num [Char] instance to exist, so with --beginner-i-have-no-idea-what-im-doing that could maybe give a more clean lie instead of that message.
11:02:26 <ertesx> kadoban: "only hope"?  to be honest i think that the error messages are fine as they are
11:02:42 <kadoban> ertesx: Only hope for improvement in terms of making a beginner mode.
11:02:50 <Welkin> "you're my only hope"
11:03:00 <monochrom> Instead, I hope to replace human programmers.
11:03:18 <ertesx> kadoban: in my experience with haskell workshops there is no need for a beginner mode
11:03:39 <ertesx> and there is a chance that a beginner mode may hurt more than it helps
11:04:19 <the_2nd> ertesx, how can I "unwrap" a Response? https://hackage.haskell.org/package/wreq-0.4.1.0/docs/Network-Wreq.html#t:Response
11:04:42 <ertesx> the_2nd: see the functions just below that
11:04:54 <ertesx> the_2nd: oh, i see
11:05:02 <ertesx> wreq gives you lenses instead of just functions
11:05:22 <the_2nd> I had it correctly
11:05:30 <ertesx> the_2nd: example: myResponse ^. responseBody
11:05:32 <the_2nd> just a typo with "$" and "."
11:05:43 <ertesx> a
11:05:45 <ertesx> ah
11:06:51 <gargawel> Hi, what would be the go-to library for fixed-length list/vectors ? (preferably indexed by some Typelevel Nat and not Peano integers)
11:07:46 <xuxu> i will ask later i suppose :|
11:07:55 * xuxu decides to head outside for awhile
11:11:12 <zort> gargawel: Linear
11:12:06 <gargawel> zort: thanks! :)
11:12:21 <gargawel> I can't believe it took me that much time to find it
11:12:40 <zort> yeah well
11:17:53 <ph88> hi guys, i was trying to change this do-block   do;  identifier <- identifier;  return $ LN identifier    to   identifier >>= \x -> LN x    but it didn't work, what am i doing wrong ?
11:18:48 <cloudhead> ph88: you need to return in your lambda
11:19:14 <Welkin> @undo do { identifier <- identifier;  return $ LN identifier }
11:19:14 <lambdabot> identifier >>= \ identifier -> return $ LN identifier
11:21:59 <ph88> ah ok, thx !
11:23:20 <MarLinn> ph88_: you could also use "fmap LN identifier" or "LN <$> identifier"
11:24:36 <zort> gargawel: there's also Sext
11:25:35 <ph88> ah yes that's even better MarLinn  :)
11:25:51 <ph88> be back later
11:32:12 <tippenein> I'v ebeen so far unable to escape this ghcjs problem https://github.com/commercialhaskell/stack/issues/1496
11:32:17 <tippenein> The build plan exception and stack.yaml - http://lpaste.net/184491
11:36:37 <ph88> this is the first time i'm making an instance .. not sure what to make of this error message ..  https://paste.fedoraproject.org/421857/30141591/
11:37:02 <ph88> this is suppose to go with this package https://hackage.haskell.org/package/wl-pprint-text-1.1.0.4/docs/Text-PrettyPrint-Leijen-Text.html
11:37:28 <EvanR> on line 4 you have Pretty =>
11:37:32 <EvanR> but Pretty takes 1 argument
11:37:43 <ph88> why does it take one argument ?
11:37:47 <ph88> what argument ??
11:37:47 <EvanR> in that case youd probably want a variable that you use on the right side of =>
11:37:53 <EvanR> a type
11:37:58 <ph88> oh
11:38:00 <EvanR> you used one on the right side
11:38:09 <ph88> so i put it on the left side ?
11:38:24 <ph88> instance Pretty ExtendedIdentifier => Pretty ExtendedIdentifier where
11:38:26 <EvanR> it looks like youre trying something like instance Num a => Num (a,a)
11:38:42 <EvanR> if you just want Pretty ExtendedIdentifier, you dont need =>
11:38:55 <ph88> aah ok
11:39:23 <kadoban> tippenein: I don't quite understand what you're asking. That's a closed issue, right? Are you sure it's the same error message? What did you try based on the comments from the issue you linked? I don't see an error message that looks like the one from the issue?
11:39:56 <ph88> EvanR, now i get a new error  https://paste.fedoraproject.org/421861/30143631/
11:40:03 <kadoban> If I'm remembering right, that's the one about using some versions of node or npm or whatever that don't work with this, but ... so many comments there.
11:40:33 <EvanR> looks like ExtendedIdentifier is a type synonym
11:40:40 <ph88> ye !
11:40:55 <ph88> it was in the previous paste on line 1 and 2
11:41:01 <EvanR> i would try to enable FlexibleInstances and FlexibleContexts first and see if that helps, since thats a saner baseline for instance functionality
11:41:16 <ph88> oki
11:41:22 <EvanR> if that doesnt work, decide if you want to enable TypeSynonymInstances, or just instance it for the actual type itself
11:41:46 <ph88> what's against TypeSynonymsInstances ?
11:41:52 <saurabhnanda> can anyone help me with the following: https://github.com/vacationlabs/haskell-webapps/issues/1 -- trying to remove prefixes from ADT constructors
11:42:47 <EvanR> i dont actually know what that does, i guess it just lets you use type synonyms in the instance but it creates the instance of the real type itself
11:43:02 <ph88> ah i see
11:43:04 <EvanR> so if you know thats happening nothing is wrong with it
11:43:09 <ph88> it seems that FlexibleInstances was enough
11:43:18 <mpickering> saurabhnanda: You could use a GADT but there are associated costs
11:43:49 <saurabhnanda> mpickering: possible to post sample code on that github issue itself? And what are the costs? Cognitive or performace?
11:43:56 <mpickering> cognitive
11:44:03 <mpickering> the implementation is more difficult
11:44:42 <saurabhnanda> mpickering: please post some sample code, if you can.
11:46:44 <mpickering> I did
11:47:24 <mpickering> It's hard to explain what exactly is more difficult but you will see once you try and work with it
11:48:53 <ph88> EvanR, sorry to ask again .. but do you know where this error is coming from?  https://paste.fedoraproject.org/421868/14730148/
11:49:25 <mpickering> seems self-expanatory
11:49:45 <mpickering> P.text expects a string but you are passing it a text
11:50:23 <EvanR> right
11:50:35 <ph88> eh but in the Doc it says it takes a Text   https://hackage.haskell.org/package/wl-pprint-text-1.1.0.4/docs/Text-PrettyPrint-Leijen-Text.html#v:text
11:51:29 <EvanR> do :t P.text
11:51:38 <ph88> ok
11:51:52 <EvanR> looks like you are looking at the wrong module
11:52:02 <ph88> o_O
11:52:20 <EvanR> import Text.PrettyPrint.ANSI.Leijen as P
11:52:21 <ph88> ah maybe the import is wrong
11:53:29 <ph88> noobie mistakes :|
11:55:33 <ph88> now that is fixed, i seem to have a conflicting Text type too ..  https://paste.fedoraproject.org/421875/01529514/
11:55:48 * hackagebot JuicyPixels 3.2.8 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.8 (VincentBerthoux)
11:55:49 * hackagebot JuicyPixels-scale-dct 0.1.1.1 - Scale JuicyPixels images with DCT  https://hackage.haskell.org/package/JuicyPixels-scale-dct-0.1.1.1 (phadej)
11:56:12 <ph88> i have this import:   import Data.Text as T (Text, pack)
11:56:16 <EvanR> there are two Text types
11:56:18 <ph88> should i use the lazy variation ?
11:56:22 <EvanR> which one you get depends on which one you import
11:57:24 <ph88> well i think i don't have a choice since this package seems to work only with the lazy variant ..
11:57:34 <EvanR> there you go
11:57:44 <ph88> and it compiles again :)
11:57:51 <EvanR> also you can freely convert back and forth, up to performance differences
11:58:36 <EvanR> converting strict to lazy is pretty much free
11:58:47 <EvanR> the other way might entail some waste
11:59:08 <prsteele> wow, this is a new one to me "ghc: panic! (the 'impossible' happened)"
11:59:13 <ph88> can i also define another instance of Pretty that does the formatting in a different way ?
11:59:20 <EvanR> i like "ghci: my brian just exploded"
11:59:33 <ph88> i like to have one "mode" that prints the source code just plain .. and another one where formatting is applied
11:59:53 <EvanR> "plain" sounds like Show huh
12:00:07 <EvanR> in general you can make as many instances you want through newtypes
12:00:20 <EvanR> > (Sum 3) <> (Sum 3)
12:00:23 <lambdabot>  Sum {getSum = 6}
12:00:31 <ph88> show will show the structure of the concrete parse tree .. but i need a printing function to get the actual source code back
12:00:32 <EvanR> > (Product 3) <> (Product 3)
12:00:35 <lambdabot>  Product {getProduct = 9}
12:01:12 <ph88> i only have one type ..
12:01:33 <EvanR> <> is being used on "the same type" in two ways there
12:01:49 <EvanR> Sum and Product exist only to pick the monoid instance
12:03:21 <EvanR> newtype Plain = Plain { fancy :: YourType }
12:03:27 <EvanR> instance Pretty Plain where
12:04:02 <ph88> i see ^^
12:04:19 <zyla> prsteele: what program you are trying to compile?
12:04:57 <saurabhnanda> mpickering: your code seems easy to reason about
12:05:07 <saurabhnanda> mpickering: is it the error messages that make this hard?
12:05:55 <mpickering> the main problem I found is what if you want to store "Status" in a data structure 
12:06:01 <mpickering> then you need to use existential quantification 
12:09:34 <EvanR> "you need to use existential quantification" seems pretty false in haskell
12:10:42 <prsteele> zyla: just something I've written. I got the bug to 'go away' by adding -fsimpl-tick-factor=200, and *removing* this option also causes the bug to be gone now...
12:11:53 <prsteele> zyla: there was an underlying syntax error -- in fact I was compiling to find it, because I knew I left off in the middle of writing code yesterday. I'm guessing it spun its wheels trying to figure out... something... related to the bad syntax
12:12:41 <ph88> when i have a parser and a printer how can i use quickcheck to check certains parts?  parse "hello world" -> syntax tree -> printer -> output "hello world"   should be same again
12:13:19 <mpickering> EvanR: What else would you suggest?
12:13:35 <EvanR> i wasnt following what youre trying to do
12:15:19 <ralu> is there typeclass that provides list construction or more general something like Traversable t => a -> t a -> t a
12:16:53 <Gurkenglas> Why don't all the *By functions have an *On equivalent?
12:17:08 <EvanR> how would traversable help that operation
12:17:28 <EvanR> looks like you want a Cons class, but what laws would it follow
12:19:47 <mpickering> prsteele: I replied to the issue you posted
12:20:27 <prsteele> mpickering: noted, will try.
12:20:58 <mpickering> This problem is usually caused by a library adding INLINE pragmas everywhere and as a result GHC dutifully does a lot of work. 
12:21:12 <ph88> can someone comment on my attempt to make haddock comment with doctest + quickcheck ??  https://paste.fedoraproject.org/421896/16816147/
12:22:04 <saurabhnanda> mpickering: is the GADT approach extensible? https://github.com/vacationlabs/haskell-webapps/issues/1#issuecomment-244623301
12:22:27 <prsteele> mpickering: you appear to be correct, the bug has resurfaced.
12:23:00 <geekosaur> Gurkenglas, because we have `on`?
12:23:19 <mpickering> saurabhnanda: Maybe if you push hard enough you could get things to work. I don't find that it's worth it though
12:23:20 * geekosaur was surprised to see sortOn; what's the point of combinators if we're not going to use them?
12:23:22 <Gurkenglas> geekosaur, then whence sortOn
12:23:42 <geekosaur> feels non-FP
12:24:10 <Gurkenglas> Never needed sortBy where sortOn didn't fit better
12:24:46 <geekosaur> yes, because sortBy is a non-FP "reaching" for the `on` combinator concept
12:24:53 <ertesx> :t sortOn
12:24:55 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
12:24:57 <Gurkenglas> Same for maximumBy, so maybe someone thought we should phase out the *By functions?
12:25:46 <ertesx> Gurkenglas: sortBy is useful in cases when you don't have a ready-made Ord instance to go by
12:27:01 <glguy> A simple case of sortBy: sortBy (comparing snd) 
12:27:15 <mpickering> prsteele: Now if you want progress on this ticket, you should post a link to your project.
12:27:21 <glguy> certainly not getting rid of the by functions
12:27:28 <Gurkenglas> glguy, sortOn snd
12:27:30 <prsteele> mpickering: sure, will do
12:27:53 <glguy> Gurkenglas: Nothing gained using On there
12:28:04 <glguy> had to create some extra structure in the process
12:28:21 <glguy> On is more suited for a more expensive computation than snd
12:29:18 <glguy> or something like: (   comparing this <> comparing that )
12:29:44 <Gurkenglas> sortOn (liftA2 (,) this that)
12:29:49 <Squarism> if i have 2 data types and want both to be comparable in some class unifing them (both types are just construct that takes a string). How would i go about to accomplish that? 
12:30:07 <Squarism> constructor
12:30:11 <Gurkenglas> feels like a job for the optimizer, sortOn is the thing we're actually functionally doing while sortBy is more efficient
12:30:15 <glguy> Gurkenglas: and again you've created unnecessary extra structure
12:32:01 <glguy> It would be cool if the optimizer was super smart, though
12:32:16 <NickHu> If I've got a parameter for my function, "verbose", is there any better way to have all of the putStrLn statements inside that function not run than wrapping them all in if-then-else blocks?
12:32:36 <NickHu> I think this can be done with template haskell but that's like trying to crack a nut with a sledgehammer
12:33:25 <Gurkenglas> Doesn't sortOn only do more work for these finitely many short cases? We could just enumerate them and tell ghc to substitute with sortBy, removing it from the prelude. Unless you can show me a sort that's not by an ord instance :D
12:33:39 <prsteele> NickHu: maybe you could use something like the Writer monad to accrue messages, and then let something closer to main decide whether to print or ignore them?
12:33:51 <dolio> Why not just write sortBy, instead of trying to shoe-horn everything into sortOn?
12:34:13 <lpaste> ongy pasted “Comparable class” at http://lpaste.net/184532
12:34:19 <NickHu> prsteele: It's kind of important that the messages are sent to stdout as soon as they're ready, assuming I want them
12:34:20 <ongy> Squarism: something like that?
12:34:45 <Squarism> ongy, like what?
12:34:53 <Gurkenglas> Because sortOn captures the pattern more precisely, and sortBy is a relict from the times when we didn't have supersmart optimizers
12:35:02 <dolio> No.
12:35:04 <ongy> ah the paste 2 lines above
12:35:07 <Squarism> ongy, oh now i see
12:35:22 <mpickering> NickHu: Most people will write "when verbose (log "abcde")"
12:35:33 <mpickering> for suitable definitions of "verbose" and "log" 
12:35:38 <Squarism> ongy, exactlu
12:35:40 <mpickering> I don't see what template haskell will save you
12:35:41 <Squarism> y
12:35:42 <NickHu> Ah I see, that sounds better
12:35:44 <prsteele> NickHu: hm. instead of passing verbose, pass the function of type String -> IO () that should be used? and pass a dummy function when you don't want it?
12:36:01 <Gurkenglas> dolio, then give me an example where sortBy is better than sortOn and it's not just because the optimizer isn't smart enough. (These changes would all be slow enough that we can assume the optimizer to get smarter by the time they're implemented)
12:36:02 <ralu> @NickHuyou can wrap this in function printVerbosity ::  Show a => string -> a -> IO () 
12:36:02 <lambdabot> Unknown command, try @list
12:36:32 <dolio> I think both examples given are better with sortBy.
12:36:47 <dolio> But another is `sortBy (flip compare)`.
12:37:16 <balac> hi, i was trying to cabal install random-fu on windows, ghc 8.0.1, and got this error: http://pastebin.ca/3710896 . would someone know how to fix it?
12:38:15 <nshepperd> sortOn Down
12:38:28 <dolio> Generalizing over the comparison function seems plenty natural to me, and doesn't require inventing types that correspond to every choice of comparison.
12:39:34 <nshepperd> sortOn does seem to be frequently more concise
12:39:37 <Gurkenglas> Once you have complicated enough comparisons, I bet you're working on Num instances anyway and then you can use sortOn negate
12:39:48 <dolio> To me, sortOn only exists for optimization.
12:40:09 <MarcelineVQ> may da schwartz be witchu
12:40:15 <NickHu> If I'm using BasicPrelude, should I put my NoImplicitPrelude declaration in my cabal file, or is that considered bad? Also, can I put some sort of declaration in the cabal file to globally import BasicPrelude?
12:40:16 <dolio> When I would have to use `sortBy (comparing snd) . map (\x -> (x, f x))` instead.
12:43:20 <Squarism> ongy, you dont happen to know a strick to make it possible to use relational ops : (>),etc... ? 
12:43:43 <ongy> :t (>)
12:43:45 <lambdabot> Ord a => a -> a -> Bool
12:44:11 <ongy> Squarism: afaik you can't redefine the existing ones
12:45:03 <MarcelineVQ> ongy, why not? :D
12:45:30 <ongy> oh right you could hide the import
12:47:49 <lpaste> ongy annotated “Comparable class” with “Comparable class (annotation)” at http://lpaste.net/184532#a184538
12:48:28 <ongy> Squarism: right you can. But you may get something about ambigous occurence if the default ones are in scope
12:48:30 <mpickering> NickHu: You can do, I generally don't like putting extensions in my cabal file as it means tooling has a harder timer understanding files
12:51:29 <Squarism> ongy, hmm.. thanks. But i cant help to feel its alot of writing to accomplish something that feels simple =/
12:56:48 * hackagebot H 0.9.0.1 - The Haskell/R mixed programming environment.  https://hackage.haskell.org/package/H-0.9.0.1 (MathieuBoespflug)
12:56:50 * hackagebot wuss 1.1.1 - Secure WebSocket (WSS) clients  https://hackage.haskell.org/package/wuss-1.1.1 (fozworth)
13:01:19 <Squarism> You cannot define an instance for a class rather than a type?
13:02:33 <EvanR> its a type class not a classclass
13:06:03 <ertesx> Squarism: to me it sounds like you don't want two types and one class…  what you really want is one type
13:06:20 <ertesx> Squarism: if you try to do OOP in haskell, you will get sad
13:06:39 <ertesx> (i'd argue that if you try to do OOP, you will get sad)
13:06:51 <mitchty> silly easy (i hope) question, how do I change argv0? or do i have to do evil stuff like http://stackoverflow.com/questions/9503157/setting-argv0-in-haskell says to do
13:06:53 <EvanR> record of functiosn is workable
13:07:32 <ertesx> mitchty: https://hackage.haskell.org/package/base-4.9.0.0/docs/System-Environment.html
13:07:45 <ertesx> mitchty: withArgs, withProgName
13:07:59 <EvanR> record of functions oriented programming
13:08:21 <mitchty> ertesx: many thanks! was not looking forward to hacks
13:08:44 <glguy> mitchty: withProgName isn't going to affect the output of ps
13:08:47 <ertesx> mitchty: can't promise that it will change what 'ps' reports though
13:08:59 <ertesx> you probably need the 'unix' package for that
13:09:00 <mitchty> ah poop, that was the goal
13:09:35 <mitchty> was hoping to have my main daemon be foo, and sub daemons be foo bar/blah/etc/usw/...
13:10:05 <mitchty> i'll have a look at the unix package
13:10:28 <mitchty> this will never run on windows so no need for portability there
13:10:32 <ertesx> mitchty: i've checked, and the unix package doesn't seem to do it either
13:11:01 <mitchty> well hacks via c it is then, oh well
13:11:45 <mitchty> maybe i should write a library for this
13:11:47 <ertesx> mitchty: become the first to make a library for that =)
13:14:16 <ongy> mitchty: in the SO link you posted https://ghc.haskell.org/trac/ghc/ticket/9143 is also linked, which mentions a few pitfalls
13:15:01 <mitchty> yep been reading it, going to play around and see what happens
13:15:47 <mitchty> this is particularly hacky http://stackoverflow.com/questions/26657699/how-to-change-the-name-of-a-haskell-process-under-linux
13:16:29 <ertesx> mitchty: BTW, supervision trees should make most use cases for that obsolete
13:16:40 <hyuke> I'm thinking about using Haskell to write a pre-processor for a river model. I.e., holding model state and reading/writing io. I would normally use Python for something like this, but I've enjoyed Haskell so much, it seems like a fun project. It seems very difficult to reason about memory usage though. Does anyone have thoughts on this? 
13:17:02 <mitchty> ertesx: sure, but its still nice to have sub children named by function IMNSHO
13:17:18 <Squarism> ertesx, oh ok
13:17:24 <EvanR> hyuke: is it difficult to reason about memory usage?
13:17:49 <EvanR> moreso than python?
13:18:02 <hyuke> EvanR: I guess what I mean is that when I'm using C or something, I mentally visualize the memory block and know what I'm changing and how much memory is being used. In Haskell it seems a bit more abstracted away than that
13:18:10 <EvanR> i have used profiling to deterministically reduce haskell program memory usage
13:18:31 <ertesx> hyuke: you can do that in haskell most of the time, as long as you understand the scope of your values
13:18:33 <EvanR> mostly just strict fields in my records
13:19:07 <hyuke> EvanR: If I am storing a model in memory that has 500,000 floating points or something, and I change one by passing the model to another function and outputing another model, is the whole model re-created on the function call? Is the massively large object passed into the function or is it done by reference
13:19:34 <hyuke> Does the model need to exist twice in memory at the same time? 
13:19:36 <EvanR> a vector of 500000 floats is going to be inefficient to modify one at a time
13:19:54 <EvanR> unlesss you use  an IO vector, or use smarter modifications
13:20:09 <ertesx> anything of 500000 floats is probably going to be inefficient, except mutable vectors
13:20:16 <EvanR> if you can compose all the operations then you might be able to produce a new vector from the old in one go
13:20:29 <johnw> if it's a model, why not use functions
13:20:30 <nitrix> https://github.com/lambdabot/lambdabot/pull/151    Any feedbacks are welcome.
13:20:31 <EvanR> via fusion
13:20:45 <hyuke> are there any books written for Haskell that focus on these sorts of issues? 
13:21:07 <EvanR> to answer th question about copying vs passing pointers to functions, its definitely pointers
13:21:29 <EvanR> but thats handled for you
13:21:45 <hyuke> Cool :)
13:22:37 <hyuke> I guess I'll give it a go and ask more specific questions when I fail somewhere :P
13:22:42 <ertesx> hyuke: if all else fails you can always do what you have done in python and get the same or likely better efficiency
13:23:12 <hyuke> ertesx: How do I do what I've done in Python in Haskell? 
13:23:16 <EvanR> IO 
13:23:34 <hyuke> Ah. You mean just use the imperative-style syntx
13:23:36 <hyuke> *syntax
13:23:42 <ertesx> hyuke: since i'm not familiar with "river models", i don't know
13:24:29 <EvanR> you can create huge mutable vectors and modify them, whether thats what makes the most sense in the python case i dont know, everything is always like that in python
13:24:53 <johnw> hyuke: what is the purpose of this model?
13:25:00 <hyuke> ertesx: I guess it doesn't need to be a "river" model specifically. The US Geological Survey has a lot of models that input and output ASCII files, and it's easier to use a pre-processor to work with them. For instance, holding all the model parameters in a class and having methods like, "setSegmentLength()", "setBoundaryConcentration()", ect
13:25:20 <hyuke> and then have a method like, "writeModel()" and "runModel()"
13:25:37 <hyuke> basically, it's just holding a structure and performing IO on ascii files
13:25:43 <hyuke> but the structure could be VERY large
13:26:00 <ertesx> hyuke: and it needs to be in RAM?
13:26:20 <hyuke> ertesx: I guess not. But wouldn't that slow things down if it wasn't? 
13:26:20 <johnw> knowing how the data will be used is essential to giving you a good answer regarding representation
13:26:47 <ertesx> hyuke: depends…  there is your filesystem cache
13:27:22 <ertesx> hyuke: if you do a lot of *computation*, then keeping things in RAM makes sense, but if most of the data is just pass-through, then not so much
13:28:47 <hyuke> ertesx: I want to hold the state so I can have methods with convenient names to modify it
13:29:03 <ertesx> hyuke: those two things are orthogonal
13:29:16 <ertesx> don't confuse programming pattern with data representation
13:30:10 <hyuke> like 'm = importModel "<directory>"'  ...  setBoundaryConcentration m 1.0 ... writeModel m "<directory>"
13:31:19 <ertesx> readModelFrom "dir1" >-> setBoundaryConcentration 1.0 >-> writeModelTo "dir2"
13:31:28 <ertesx> this one does not hold the model in RAM
13:31:43 <ertesx> remember that this is haskell, not python…  we aren't bound by OO restrictions =)
13:32:23 <hyuke> ertesx: Haha, I think that's my problem. I have thought in C/Python for so long
13:33:14 <ertesx> now the code i just wrote is what streaming code would look like
13:33:39 <ertesx> if your models consist of sequences of values of the same type, this approach may be the most efficient
13:33:47 <hyuke> here's another question then. What if I wanted to make it a console application that accepted commands so I could put a graphical interface on it in another language? 
13:34:43 <EvanR> ive done that
13:35:01 <ertesx> hyuke: what's the question?
13:35:11 <EvanR> the GUI process does commands, queries, and listening on the haskell process through stdio
13:35:48 <EvanR> arguably this strategy is a pain in the ass and it should all be in haskell
13:36:02 <hyuke> ertesx, EvanR: Do you have any advice on libraries I should look at or concepts I should look into assuming that I've read through a couple basic Haskell books and haven't written anything substantial before
13:36:15 <ertesx> hyuke: if you want to do the GUI in another language, there isn't anything special to keep in mind
13:36:30 <EvanR> advice, write something substantial 
13:36:35 <hyuke> haha
13:36:49 <EvanR> then concepts youll need will be the ones you need by definition
13:36:56 <ertesx> hyuke: but if you want to do the GUI in haskell, you can save a lot of work
13:37:02 <hyuke> EvanR: That's probably all I can do. I won't know where I'm going to fail until I fail
13:37:17 <hyuke> there aren't really many good options for doing a GUI in Haskell are there? 
13:38:09 <EvanR> there arent good options for doing GUI in anything
13:38:32 <EvanR> but more practically, theres ghcjs for web stuff, and three-penny-gui
13:38:37 <ertesx> hyuke: we have abstractions like FRP that allow you to model interactions purely (i.e. toolkit-agnostic), then bind them to whatever toolkit you want to use (console toolkits like vty-ui, graphical toolkits like gtk, etc.)
13:38:39 <EvanR> which uses a browser
13:38:55 <ertesx> hyuke: but the trend is to do web UIs
13:39:02 <EvanR> there are gtk+ bindings, which doesnt fully count as a good option
13:40:05 <maerwald> "bind them to whatever toolkit you want to use" errrm
13:40:10 <maerwald> I think you are underestimating this
13:40:14 <hyuke> Isn't a web interface going to kill me if I'm having to transfer such big structures between haskell and javascript? 
13:40:34 <hyuke> javascript is slow anyway without having to get the values from a server first
13:41:09 <ertesx> maerwald: nope
13:41:13 <maerwald> yes you are.
13:41:29 <maerwald> hyuke: there are only rudimentary FRP bindings for stuff like gtk+, nothing you can properly use
13:41:31 <ertesx> maerwald: can you stop making assumptions, please?
13:41:54 <prsteele> lens question -- how would I set 2 values 'at once'? Is there convenient syntax for (set setter2 y (set setter1 x s)) ?
13:41:55 <maerwald> if you hear people telling you to write up those binding, then they are underestimating the effort of consistently creating those over a whole framework
13:42:20 <ertesx> it's not a lot of work, and i know it, because i have done it
13:42:20 <maerwald> hyuke: reflex-dom is an option, but that's well...
13:42:32 <puregreen> prsteele: there isn't, but you can do “s & setter1 .~ x & setter2 .~ y”
13:42:55 <maerwald> ertesx: can you show your FRP gtk+ bindings?
13:43:00 <EvanR> hyuke: are you trying to basically do something with matlab
13:43:07 <EvanR> "river model" + "gui"
13:43:11 <EvanR> matlab
13:43:13 <ertesx> maerwald: no
13:43:15 <maerwald> k
13:43:43 <prsteele> puregreen: thanks!
13:44:02 <ertesx> reactive-banana is a good library for GTK+ and other callback-based toolkits
13:44:06 <maerwald> no
13:44:25 <maerwald> it doesn't have gtk+ bindings, you have to come up with everything yourself
13:44:33 <hyuke> EvanR: No. I used to work on development of a desktop application for groundwater modeling. It was in C++, and I hated it. I'm trying to see what my options are for avoiding it. I've enjoyed Haskell, so I was thinking maybe Haskell for heavy lifting and PyQt for an interface might be an option for an independent project
13:44:34 <maerwald> and gtk+ has a lot of unclean stuff in the framework
13:44:37 <ertesx> there isn't much to come up with
13:44:51 <maerwald> ok, whatever :)
13:45:04 <hyuke> EvanR: That is, an independent project I might actually enjoy developing :)
13:46:20 <hyuke> EvanR: My thought was to try it out with a smaller model, so I've decided to develop a graphical interface around OTIS, which is a 1D river model developed by the USGS
13:46:33 <prsteele> this is a general lens question (first time trying to use them). Are lenses typically optimized away by the compiler? I.e. is there any real reason besides style to use / not use them?
13:46:40 <ertesx> maerwald: why do you think that you have to make a "GTK+ binding" first?  that's just stupid
13:46:50 <prsteele> I'm not worried about performance in the least (right now), just curious
13:46:50 <EvanR> hyuke: you can export a matlab project as a standalone program, i think
13:47:11 <hyuke> EvanR: I don't own a copy of Matlab anymore, and it looks awful
13:47:21 <orion> Mathematica FTW
13:47:23 <EvanR> heh
13:48:00 <puregreen> prsteele: there's a lot of optimisation work put into lens but I believe that in some cases they won't be fully optimised away
13:48:04 <hyuke> EvanR: For purely utilitarian purposes, I could do it entirely in PyQt, but that wouldn't let me investigate the possibility on doing another project later that required big data
13:48:17 <puregreen> one of those cases would be updating records, I think
13:48:25 <puregreen> I really should benchmark all that one day
13:48:45 <prsteele> puregreen: thanks. I suppose the real answer is 'benchmark', but I was mostly hoping I wouldn't hear horror stories
13:48:59 <hyuke> C++/Python works well for utilitarian purposes, and I can easily implement what I want that way. I just hate writing C++, so I'm considering alternatives :)
13:49:04 <glguy> For simple cases like updating records with known lenses the lens and update function inline and it's equivalent to doing the update directly
13:49:34 <glguy> You can defeat that if you were to pass lenses as arguments to another function which wasn't inlined
13:49:36 <prsteele> glguy: so a case where it might not happen would be passing lenses around as arguments?
13:49:44 <puregreen> glguy knows better, yeah, my knowledge about record updating & lenses is based on a several-years-old stackoverflow answer :)
13:49:49 <prsteele> glguys: cool, thanks
13:50:03 <glguy> But when you pass them as arguments you often do that at specialized types and so it's not necessarily a loss
13:50:32 <maerwald> ertesx: lol
13:51:02 <xcmw> Why does this error? When I put them in the same module it works. http://lpaste.net/184552
13:51:08 <glguy> for something like a nested map update it can be easier to write it efficiently with lens than without
13:51:56 <glguy> xcmw: Because if makeFields can't see that the class exists already it makes a new one
13:53:16 <xcmw> glguy: Doesn't haskell relize that the classes are identical?
13:53:50 <glguy> No, not for classes or data types or newtypes
13:54:16 <glguy> Every time you declare a new typeclass it's unique from all the other ones, even if they have the same names
13:55:22 <xcmw> Is there a way to fix it?
13:55:44 <monochrom> delete one of the classes.
13:56:10 <glguy> Yeah, put the class in a module and import that module in both of these modules
13:57:25 <xcmw> Is there some template haskell magic or do I have to do it by hand?
13:57:29 <monochrom> Watch the movie "The Prestige" for inspiration. 😈
13:59:24 <ertesx> (and for the most terrible ending you'll ever see)
14:01:46 <glguy> xcmw: You can see what's generated by TH with -ddump-splices and copy that into a module
14:07:35 <{AS}> Hi
14:07:41 <{AS}> Is there a way to enable n + k patterns?
14:07:57 <monochrom> NPlusKPatterns maybe
14:08:33 <monochrom> ghc --supported-extensions and then do a search or a simple "less"
14:08:42 <{AS}> Thanks
14:14:53 <glguy> My favorite way to find extensions is in GHCi I type: :set -X
14:14:57 <glguy> and then use tab completion
14:16:26 <prsteele> one of my least favorite experiences is knowing some trick like that _but not knowing how the tricks knows what to do_
14:17:30 <prsteele> e.g. knowing "I need to add the -lsome_lib flag and the compiler can find the library, but I don't know where it is myself..."
14:19:26 <monochrom> -lsome_lib is indeed a really long story
14:31:07 <koz_> How do I write 'the function corresponding to unary minus'?
14:31:19 <koz_> If I write (-), Haskell seems to assume I mean the binary one.
14:31:53 <kwantam> (0-) should work
14:32:06 <koz_> kwantam: Thanks!
14:33:05 <benzrf> koz_: negate
14:33:06 <benzrf> :t negate
14:33:10 <lambdabot> Num a => a -> a
14:35:17 <kwantam> Indeed. And the default implementation of negate is just (0-) :)
14:35:21 <benzrf> oh, haha
14:49:33 <prsteele> if I have `data Foo = Bar { _fooInt :: Int } | Baz { _fooBool :: Bool}` and run makeLenses ''Foo... am I getting _Prisms_ out?
14:51:41 <glguy> prsteel, no, Lenses
14:52:09 <glguy> err, Traversals, 
14:52:27 <prsteele> glguy: okay so in this case ^. complains about Foo not having a Monoid instance, which I think means I need to... treat it as a Traversal/Prism...?
14:52:27 <glguy> i don't think it's clever about making Prisms
14:52:55 <glguy> yeah, you'll need to use preview instead of view
14:53:18 <prsteele> glguy: okay, I supposet that makes sense in hindsight. I really need to sit down and derive the lens laws...
14:53:47 <glguy> I think that we talked about making Prisms in that case but I don't think I ever implemented it
14:54:13 <Squarism> Anyone got a good guess on the following hypothesis. A. storing ca 100 million of 100 value records of heirachical data. B. Analyze data by doing some "Read <record>" + lens-magic. C. Could this be a sane track to persue if the alternative is mysql?
14:54:35 <prsteele> glguy: so I want to think of the traversal as walking the different components of a sum type?
14:54:46 <Squarism> ..on a performance contest so to speak
14:54:58 <glguy> prsteele: If you wanted prisms there's makePrisms, also
14:55:19 <glguy> The traversals either do or don't visit the associated fields depending on the constructor
14:55:26 <Squarism> ...i know the question is supervague, but just curious if people do these things?
14:55:34 <prsteele> glguy: well I'm actually not sure what a prism is (again, first day with lenses) so I was kind of just scanning documentation to figure out what I might have, but thanks for the note
14:57:26 <Squarism> ...ie.. can mapreduce + lenses be made faster than mysql ? =D
14:58:15 <prsteele> glguy: I think I was confused because I had already pattern matched on the correct constructor, so (in my mind) the ^. was unambiguous
14:58:49 * hackagebot type-level-sets 0.8.0.0 - Type-level sets and finite maps (with value-level counterparts)  https://hackage.haskell.org/package/type-level-sets-0.8.0.0 (DominicOrchard)
14:58:51 * hackagebot glirc 2.14 - Console IRC client  https://hackage.haskell.org/package/glirc-2.14 (EricMertens)
14:59:05 <glguy> ah. Prisms correspond to the constructors of a sum type. Lenses to the fields of a record
14:59:26 <glguy> In this case with a sum of records the fields correspond to a Traversal
14:59:38 <prsteele> glguy: thanks!
14:59:41 <glguy> that's the short version
14:59:56 <prsteele> should be enough to let me read the docs efficiently now
15:20:43 <Squarism> is there some show variant that can pretty print highly nested datastructures.. Lik Record contain Map coontaing Record and so on.... to make them readable when printing instead of just a long string wo line breaks / indentation?
15:21:20 <ReinH> @hackage pretty-show
15:21:21 <lambdabot> http://hackage.haskell.org/package/pretty-show
15:22:20 <Squarism> thanks
15:22:34 <glguy> prsteele: Have you noticed that diagram on the front of http://hackage.haskell.org/package/lens ?
15:24:25 <prsteele> glguy: yes, but I hadn't tried to make sense of it ;) I will now
15:29:33 <ggVGc> is anyone here using purescript?
15:33:39 <prsteele> glguy: thanks for the help!
15:33:59 <Squarism> dont know if date and time is as infected as in java world, but what date time library should one use?
15:36:00 <amx> "time"
15:36:19 <yyyyy> Squarism: i like `hourglass`, but if compatibility is a goal `time` is the most widespread.
15:36:52 <Squarism> amx, yyyyy - thanks! ill go with time for now then
15:37:19 <glguy> I actually just like the time package, widespread or not
15:41:54 <yyyyy> glguy: i came to use it more recently, but hourglass had less conversions to deal with adding days to dates
15:42:22 <yyyyy> truth be told it was one tiny function away from being ok, and it's what i use on most projects now.
15:42:44 <yyyyy> maybe there should be a `time-extras` with utility functions
15:48:36 <tomleb> Hey guys, last time I got this script working thanks to ertesx and andromeda-galaxy
15:48:53 <tomleb> Now I'm trying to switch from Maybe a to Either a b
15:49:01 <tomleb> http://ix.io/1k2V The script in question
15:49:26 <tomleb> I'm having trouble converting from Maybe to Either (Except) ?
15:49:48 <tomleb> Which Monad am I supposed to use here, Error or Except ?
15:50:41 <glguy> Error implements fail so that you can catch it in Error, Except passes it through to the underlying Monad
15:50:55 <tomleb> Alright so it's gonna be an Except
15:51:02 <tomleb> but I think I found what I was looking for
15:51:11 <tomleb> It's the mapM function I think I need
15:52:09 <tomleb> I'll try on my own with mapM for now :p
15:52:11 <Clint> tomleb: you may or may not be interested in https://hackage.haskell.org/package/errors-2.1.0/docs/Control-Error-Util.html
15:53:27 <begriffs> Is there an unless function for IO (Maybe a)? So if it's a Just then it will perform an action on a, else will do nothing?
15:53:57 <begriffs> I started writing a case...of and thought there's probably a cool way to do it.
15:53:59 <tomleb> Clint: Oh, pretty cool thanks, I'll use my own functions for learning purposes but will surely look at them when I need to, thanks
15:54:36 <glguy> begriffs:  for_ :: Maybe a -> (a -> IO ()) -> IO ()
15:55:14 <tomleb> begriffs: Are you the guy from begriffs.com ?
15:55:26 <begriffs> tomleb: hi, yeah I am
15:55:47 <tomleb> begriffs: Is there going to be another `Pragmatic Haskell for Beginners` ?
15:56:51 <begriffs> I asked Alex Kurilin (the presenter) and he said he has been busy this summer on his business Front Row Ed. Since they cater to schools the summer is a nice window of time to fix code. But he says when things calm down then we can record the next video.
15:57:11 <tomleb> begriffs: Ok, cool
15:57:16 <tomleb> begriffs: Thanks for the info
16:00:04 <begriffs> tomleb: you could email him though just to let him know that people enjoy his series.
16:05:43 <codygman> Using the time library how can I instruct "ParseM" that a date like "2016-05-18 00:00:00" is in a specific time zone?
16:06:45 <glguy> codygman: parse it as a LocalTime
16:07:43 <glguy> codygman: then you can pair that with a TimeZone to get a ZonedTime
16:08:00 <glguy> Or localTimeToUTC :: TimeZone -> LocalTime -> UTCTime
16:08:13 <codygman> Ah, okay so I specify the TimeZone later on.
16:11:11 <grey__> begriffs: small request. add direct dl links for all videos. i like to watch videos on my tv with kodi, and embedded players don't allow that
16:12:04 <begriffs> grey__: for recent videos I do have download links actually, right under the player. Are you looking at an older one?
16:13:01 <begriffs> It looks like "Download Video: (HD / SD)."
16:13:53 <grey__> begriffs: some of them do which is awesome, thanks! but for example "A Sensible Intro to FRP" doesn't
16:14:27 <begriffs> Oh my mistake, let me fix that...
16:15:51 <grey__> begriffs: thanks. really appreciate the site btw.
16:26:13 <codygman> I have some files with dates that are a few hours off according to CST time zone. I need to parse these times into CST, fix them by subtracting 2 hours, and then update them accordingly in CST.  However I won't always know it's going to be CST, only that it's CT and then from there I'll need to see if CST or CDT applied to that date and select one, then do my modifications. Am I missing something or is there no immediatley obvious
16:26:19 <chsn> on ghc 8.0.1, after I do "cabal sandbox init; cabal install haste-compiler" -- where is hastec/haste-boot placed ?
16:35:50 <yyyyy> codygman: i'm not american, so i don't know what's CST and CDT, but how will you check the difference? is one UTC-x and the other one UTC-x-1?
16:35:55 <yyyyy> how do you tell them apart?
16:36:46 <codygman> yyyyy: I think I've found my answer, it involves using the tzdata package where the user specifies something like "America/Chicago" and then I build a TimeZone that the time package expects.
16:36:58 <chsn> https://www.google.com/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=timezone%20cst%20cdt
16:37:39 <yyyyy> ah, it's explicit. ok, makes sense.
16:40:06 <dolio> yyyyy: There's only like a 2-hour window where you wouldn't know based on the date and time, I think.
16:43:17 <dolio> Like, '2:xx AM central' on one day could be either CST or CDT.
16:47:21 <codygman> yyyyy: In case you were curious: http://lpaste.net/184582
16:48:33 <yyyyy> ah, i see
16:54:45 <yyyyy> dolio, codygman: is it common to deal with data using timezones explicitly instead of leaving it in the ISO8601 representation?
16:55:21 <pharaun> please do deal with tz
16:55:45 <yyyyy> here we only have 3. so we leave them as UTC-3, UTC-2, UTC-4 etc
16:56:07 <codygman> yyyyy: I don't know. I'm dealing with some data in a database that is mandated to be in CT format, which is why I have to do this. Not only is some of this data in CT format, but certain columns of data are known to be wrong by varying constant numbers.
16:57:12 <yyyyy> we would express it as “2016-09-04T20:56:17-03:00”, for instance
16:57:12 <nshepperd> I think the most common way to deal with dates and times is to break down and cry because all timezone handling libraries make no sense
16:58:00 <dolio> yyyyy: I imagine it's very common, unfortunately. :)
16:58:06 <yyyyy> codygman: CT is a timezone?
16:58:48 <codygman> yyyyy: Yes, consisting of CST or CDT. 
17:00:07 <yyyyy> i saw now. one is UTC-5 and the other UTC-6. now it makes sense. to me they were just random acronyms initially :)
17:02:41 <yyyyy> recently i migrated a smallish-sized database (2 TB) that suffered from that. everything was in UTC+0 and we had to compensate for the UTC-3 difference, but it was only one change.
17:02:46 <tomleb> Fiew.. 2 hours + later, I got either working lol. Damn I'm having a hard time :p.
17:03:00 <tomleb> Anyone of you wanna look at my code and comment on it ? http://ix.io/1k3R/haskell
17:03:13 <tomleb> (It's a small file)
17:03:41 <begriffs> grey__: do a hard refresh on one of the video pages. The download links should be there now.
17:06:55 <codygman> In this template Haskell Splice: $(includeTZFromDB "Europe/Budapest")     Is there a way I could pass in the String rather than always using "Europe/Budapest"?
17:07:13 <yyyyy> tomleb: i wouldn't export `lookupOr` and `conStrFromEnv`, i think.
17:07:45 <tomleb> yyyyy: True, I have to think about that.
17:08:12 <tomleb> yyyyy: I also refactored to use traverse instead of having a couple of x <- ExceptT . lookupOr
17:08:14 <kadoban> codygman: Well, I mean that happens at compile time, is the String available at compile time?
17:08:31 <tomleb> yyyyy: Is it more idiomatic to use `traverse` ?
17:08:39 <yyyyy> i was gonna say next to look into that `Except . lookupOr`
17:09:37 <yyyyy> i think the real question is if your co-workers can get it easily. if yes, then why now. if not that much then maybe just do a `f = Except . lookupOr` as a where clause
17:09:43 <yyyyy> why not*, sorry
17:10:26 <tomleb> yyyyy: True that, I'll keep both method, one commented, just so i can remember it
17:10:54 <codygman> kadoban: Yes. Perhaps I should give more of a background. I'm going to modify the `tabletypes` function used in Frames to include this time zone string: https://acowley.github.io/Frames/ so it'll be called like: tableTypes "User" "data/ml-100k/u.user" "America/Chicago"
17:11:28 <codygman> *used in frames as seen in the tutoria:
17:11:32 <tomleb> yyyyy: You said to not export lookupOr and conStrFromEnv, how'd you do that ? Can I unexport them ? Or do I have to export all others explicitly ?
17:12:42 <chsn> has anyone here managed to learn nix? I'm using it primarly for haskell, but in #nix, it seems like people there somehow managed to know nix, whereas I can't grok the manual at all
17:12:55 <yyyyy> `module Config (Environment(..), createConnectionPool, …) where
17:13:38 <tomleb> yyyyy: Thanks
17:13:58 <yyyyy> tomleb: i do it explicitly. maybe there are other ways.
17:14:40 <Squarism> i wonder why haskell is like the largest programming language group on freenode?
17:15:18 <kadoban> Because haskell is awesome and so is #haskell
17:15:38 <Squarism> whole lot of PhD's has forgotten screen-processes 
17:16:06 <Squarism> kadoban, true!
17:16:20 <dolio> ,
17:17:11 <glguy> ?
17:17:15 <yyyyy> or maybe we're all really old and miss the “everyone used IRC on my days, kids”
17:17:32 <Squarism> haha
17:30:22 <xtrntr> why do haskell libraries have such cool names?
17:31:26 <dibblego> Because look at us. Yeah, exactly.
17:33:05 <dolio> Haskell is designed for people who love puns, so obviously the names will be great.
17:41:56 <kszlim> Hi, I'm a new haskell programmer, and I was wondering if I could get some feedback on my project. It's over here: https://github.com/kszlim/wordbase it should be buildable via stack. It's essentially a tool for playing a wordsearch esque game.
17:42:37 <kszlim> I'd really love to get some feedback on writing more idiomatic haskell as well as possible performance improvements, though it's fast enough for its intended purpose.
17:52:09 <fizbin> Okay, I feel stupid - I can't seem to find anywhere any documentation on how to make record fields strict.
17:52:26 <tomleb> I thimk you have to prepend a `!` 
17:52:31 <tomleb> Not too sure though lol
17:52:44 <fizbin> That works for things that aren't record fields.
17:53:03 <fizbin> But if you're using record syntax to name your fields, that doesn't seem to work.
17:53:06 <jle`> fizbin: data Foo = Foo { bar :: !Int }
17:53:39 <fizbin> Oh! By the type. Ok
17:53:40 <jle`> @let data StrictInt = StrictInt { getStrictInt :: !Int } deriving Show
17:53:43 <lambdabot>  Defined.
17:53:47 <jle`> fizbin: yup, it's the same as w/o record fields
17:53:56 <jle`> you'd noramlly write data StrictInt = StrictInt !Int :)
17:54:16 <jle`> > case StrictInt undefined of StrictInt _ -> "hello"
17:54:18 <lambdabot>  "*Exception: Prelude.undefined
17:54:38 <jle`> it's consistent to without having record fields :)
17:55:39 <fizbin> jle`:  "the same as" rather, "it is consistent with the notation outside record fields". But there are several different ways one could be consistent.
17:56:14 <fizbin> StrictInt { ! getStrictInt :: Int } would also be the same as non-record fields.
17:56:21 <jle`> hm, how so?
17:56:27 <jle`> with non-record fields, the ! goes in front of the type
17:56:36 <jle`> not in front of the ... what would even be the analogous thing there?
17:56:43 <EvanR> as far as documentation goes
17:56:54 <fizbin> Or, with non-strict fields the ! goes in front of the whole field declaration.
17:57:02 <EvanR> strict fields are official haskell documented in the haskell report https://www.haskell.org/onlinereport/decls.html#strictness-flags
17:57:13 <fizbin> sorry, with non-record types the ! goes in front of the whole field declaration
17:57:42 <fizbin> Which is also in front of the type, because with non-record fields that's all there is.
17:58:12 <EvanR> data StrictPair a b = StrictPair !a !b
17:58:15 <fizbin> So when you add a name for the field, which side of that name the ! goes on isn't obvious.
17:58:49 <jle`> that's fair!  i guess you should interpret the ! as modifying the type, not the "field"
17:59:03 <fizbin> Yeah
17:59:23 <fizbin> I was interpreting it as modifying the constructor, the way bang patterns modify the function.
18:00:04 <EvanR> it doesnt modify the ctor since you can have different fields strict and others lazy
18:00:18 <EvanR> also StrictData lets you declare specific fields lazy with !
18:00:21 <EvanR> with ~
18:01:13 <fizbin> EvanR: I don't see how that's inconsistent with modifying the ctor. You're just annotating it to say "arguments 1, 3, and 5 are strict"
18:01:52 * hackagebot huckleberry 0.10.0.1 - Haskell IOT on Intel Edison and other Linux computers.  https://hackage.haskell.org/package/huckleberry-0.10.0.1 (tkmsm)
18:01:54 * hackagebot paprika 0.1.0.2 - The Haskell library and examples for the kids programming robot paprika  https://hackage.haskell.org/package/paprika-0.1.0.2 (tkmsm)
18:02:01 <EvanR> youre not modify the ctor, but the fields. i dont see what it has to do with ctors
18:02:26 <EvanR> its not even data Foo = !A a | !B b
18:02:38 <EvanR> or data Foo = !Foo { field :: A }
18:03:31 <fizbin> I suppose.
18:04:05 <nshepperd> it's modifying the ctor in that the constructor, as a function, is now strict in one or more arguments
20:16:51 <avctr> hey
20:17:35 <glguy> hi
20:28:13 <avctr> hi glguy
20:28:19 <avctr> how goes the long weekend
20:28:52 <EvanR> the world is crashing down around me, natural number indices are almost always symbolized by n, and if you need another one, m. for all n, m...
20:28:57 <glguy> Good so far, lots of Haskell programming!
20:29:04 <EvanR> *but m comes first* o_O
20:29:33 <glguy> EvanR: You need to plan ahead!
20:29:39 <koz_> I have a function 'bar' with the signature '(MonadPlus m, Foldable t) => Int -> t Int -> m Foo', where 'Foo' is a type I defined. When I try and run it in GHCi like 'bar 2 [1, 2, 3, 4] (basicFoo)', if nothing goes wrong, it just gives me a Foo, without wrapping it in any MonadPlus or throwing an error. Why does it do that? Shouldn't it balk at not having enough information to give a type to the result, as I
20:29:41 <koz_> haven't said what MonadPlus I wanted? 
20:30:06 <EvanR> whats the proper order to use these letters?
20:30:14 <jle`> koz_: ghci tries to assume things are IO
20:30:30 <jle`> if possible
20:30:52 <koz_> jle`: And I assume IO is an instance of MonadPlus?
20:31:29 <jle`> yes, it is :)
20:31:33 <EvanR> :t mzero :: IO Char
20:31:35 <lambdabot> IO Char
20:31:50 <EvanR> an IO action that returns '0'
20:32:03 <jle`> you can also check with ':i IO' in ghci
20:32:19 <koz_> jle`: OK, that explains it. Thanks!
20:32:26 <glguy> IO's a bit questionable since it doesn't satisfy the documented property that: v >> mzero   =  mzero
20:32:36 <jle`> mzero is throws an error, yeah
20:32:43 <koz_> jle`: I *just* discovered that.
20:35:40 <jle`> v >> mzero = mzero must also be why Either isn't a MonadPlus either
20:36:04 <jle`> but i think some people do argue that being a left-zero is good enough of a law for useful monadplussity
20:36:38 <jle`> er wait, nvm, Either would satisfy v >> mzero = mzero
20:36:53 <glguy> Well, what would mzero be?
20:37:18 <glguy> Left "v" >> mzero     would be   Left "v"
20:37:26 <glguy> not mzero
20:38:25 <glguy> > Left "v" >> undefined
20:38:27 <lambdabot>  Left "v"
20:44:07 <jle`> it'd be the identity of <|>.  ah yeah, you're right
21:11:03 <athan> Why in the frig is there not a monoid instance `(Monoid w, Monad m) => Monoid (m w) where; mempty = pure mempty; mappend = liftM2 mappend`?
21:13:07 <athan> something kinda cool is that with `m ()` is `mappend == *>`
21:13:10 <athan> wait...
21:13:27 <glguy> Because it would collide with all manner of instances and potential instances
21:13:48 <athan> glguy: oh hm, just monomorphic ones?
21:14:06 <athan> Or instances where you don't want this property?
21:14:16 <athan> or that this doesn't make sense in that case. Hm, shoot sorry
21:14:18 <glguy> or cases where m wasn't a Monad
21:14:29 <athan> because there's MonadPlus / Alternative too.. mm
21:14:49 <athan> I mean you could do so with Applicative
21:15:00 <athan> > liftM2 mappend [1,2,3] [4,5,6]
21:15:02 <lambdabot>  error:
21:15:02 <lambdabot>      • Ambiguous type variable ‘r0’ arising from a use of ‘show_M219162319141...
21:15:02 <lambdabot>        prevents the constraint ‘(Show r0)’ from being solved.
21:15:05 <athan> herp
21:15:57 <athan> thanks glguy
21:16:08 <jle`> athan: remember that ghc matches instances based on the head, and then checks the constraints after
21:16:09 <glguy> Remember that when you write:  instance _whatever_ => Monoid (m w)
21:16:21 <glguy> you're declaring an instance for ALL TYPES of the form: m w
21:17:02 <jle`> (also btw your proposed instance works for all Applicatives too)
21:17:09 <jle`> (yet another reason why liftM2 needs to go away :3 )
21:52:30 <benzrf> :t liftM2
21:52:32 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:52:45 <benzrf> huh, they shouldve changed the constraint after AMP :]
21:55:49 <tnks> there was a seminearring in `monoids`, which is deprecated and replaced by `reducers` but I don't see something like seminearrings there.
21:56:07 <tnks> any pointers?
22:33:02 <Axman6> t0by: 0x41daff524, is that one ok?
22:33:52 <t0by> Axman6, no idea what you're ytalking about
22:34:11 <Axman6> uh, meant for tnks >_< sorry
22:43:19 <ar53nic> trying out haskell for the first time tonight :)
22:43:40 <liste> ar53nic: nice
22:45:27 <glguy> ar53nic: this is a good place to ask questions as you're learning
22:47:25 <srhb> ar53nic: Welcome! :)
22:47:33 <ar53nic> thanks!
22:57:36 <jle`> benzrf: it's actually intentional, because it's meant to be liftA2 implemented using >>= and return, I think
22:57:59 <jle`> sort of like how liftM is meant to be fmap implemented using only >>= and return
23:09:00 --- mode: ChanServ set +o glguy
23:09:00 --- mode: glguy set -bbo *!*@207-119-113-235.dyn.centurytel.net *!*@5-12-173-236.residential.rdsnet.ro glguy
23:09:23 <eklavya> what is the standard way to have runtime config files? which library is the standard/recommended?
23:09:40 <dysfun> take your pick
23:09:53 <dysfun> partially it depends what format you want
23:10:17 <eklavya> dysfun: no preference, just anything commonly used
23:10:27 <dysfun> Aeson (json)?
23:10:40 <glguy> I like using my config format. aeson isn't particularly good, doesn't support comments (for a config file)
23:10:47 <glguy> There's yaml, toml, ini
23:10:56 * dysfun is quite fond of toml format
23:11:10 <eklavya> o
23:11:11 <eklavya> ok
23:11:25 <dysfun> (it's like ini++)
23:11:41 <glguy> http://hackage.haskell.org/package/config-value
23:11:58 <eklavya> in Scala world there is a standard lib for this, so any and all libraries can have their config in the same file
23:12:22 <eklavya> just wanted to know if there is something like this here, so all config for any lib I might use could be put in the same file
23:12:43 <eklavya> thanks glguy dysfun :)
23:12:43 <dysfun> well it can, sure, but you have to write the code that reads it
23:12:51 <eklavya> understood
23:13:13 <dysfun> we favour libraries over builtins for the most part
23:13:21 <MarLinn> why not use XML?
23:13:26 * MarLinn hides in a corner
23:13:49 <dysfun> MarLinn: we ran out of <>
23:13:56 <dysfun> we used them all on semigroups
23:14:32 <eklavya> :D
23:14:46 <MarLinn> Oh no! How am I supposed to write my enterprise app now?
23:14:59 <dysfun> actually, dotty (new scala compiler) has removed xml literal support
23:15:11 <dysfun> so it's basically total disaster over in enterprise jvm world
23:15:17 <eklavya> moved out to a lib
23:15:18 <glguy> now it has only figurative support?
23:15:58 <dysfun> probably more like implicit suppor
23:15:59 <dysfun> t
23:16:29 <dysfun> needs moar flatMap
23:16:58 <dysfun> anyway, i am using toml for config files in haskell at the minute
23:17:14 <eklavya> toml is nice
23:17:17 <eklavya> simple
23:17:49 <eklavya> dysfun: htoml?
23:18:11 * dysfun cannot remember, will quickly look at his repo
23:18:13 <Reshi> eklavya: https://github.com/toml-lang/toml
23:18:17 <Reshi> I think
23:18:17 <eklavya> wait, why would it depend on aeson?
23:18:25 <dysfun> because it uses aeson data
23:18:45 <eklavya> Reshi: I know about that, thanks :)
23:18:51 <Reshi> eklavya: oh you mean the haskell lib damn 
23:18:59 <eklavya> dysfun: internally?
23:19:02 <dysfun> yes
23:19:03 <eklavya> Reshi: :D
23:19:52 <dysfun> yes, htoml
23:20:54 <glguy> config-value doesn't depend on aeson and benefits from having a distinct "atom" type that is handy for distinguishing well known names from string literals
23:22:24 <eklavya> glguy: yeah looking into it now
23:22:39 <glguy> https://github.com/glguy/irc-core#configuration-file
23:22:44 <glguy> example usage
23:24:58 <eklavya> glguy: do I need to know lenses to query it?
23:25:59 <glguy> no, that's just for convenience. I'm not really using the config.lens module in the IRC client, for example
23:27:45 <glguy> s/really//
23:29:19 <eklavya> looks complex, I just really need a key value map sort of interface, nothing fancy
23:31:03 <glguy> it's definitely not complex, but if an INI file will cover what you need that's probably a safe choice
23:31:56 <eklavya> ok
