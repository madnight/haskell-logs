00:01:06 <Guest623> So I have a state (A) and to that state I want to apply with f all [B], in order
00:01:12 <EvanR> oh, you want to use the new A as the first arg
00:01:16 <jle`> Guest623: can you give an example for a given sized list
00:01:16 <koz_> cocreature: Or what it doesn't do, amirite? :P
00:01:23 <jle`> ie, map f [x,y,z] = [f x, f y, f z]
00:01:26 <koz_> Also, is there a natural language version of (^?!)?
00:01:27 <Guest623> EvanR: yes
00:01:57 <EvanR> then its a fold of some sort
00:02:01 <jle`> ie, foldr f z [a,b,c] = f a (f b (f c z))
00:02:12 <Guest623> Oh, yes
00:02:14 <Guest623> Of course!
00:02:17 <jle`> using your f and the arguments [x,y,z], what would the result be?
00:02:19 <Guest623> Thank you all!
00:04:55 <xuxu> Guest623: i think jle` was asking you a question, not answering your question
00:05:36 <xuxu> codygman: not ignoring you, just new to haskell. i can't help with your question regarding existing date parsing libs
00:06:26 <codygman> xuxu: No problem :)
00:06:42 <koz_> jle`: You wouldn't know what the non-operator version of (^?!) is in lens, would you?
00:07:28 <Guest623> jle`: it would be (f z (f y (f x a)))
00:07:33 <xuxu> i have a question that i thought the 2010 report might answer, but i didn't see it at https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4 
00:07:37 * hackagebot vty 5.10 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.10 (JonathanDaugherty)
00:07:37 * hackagebot glirc 2.13 - Console IRC client  https://hackage.haskell.org/package/glirc-2.13 (EricMertens)
00:07:51 <xuxu> why can't i declare something to be a Num type in ghci, i.e. 3 :: Num
00:07:59 <glguy> koz, there isn't one exactly, you can use singular to get closer
00:08:00 <koz_> xuxu: Num is a typeclass.
00:08:07 <xuxu> oh!
00:08:21 <koz_> glguy: I don't quite understand what you mean.
00:08:24 <xuxu> thanks koz_ 
00:08:29 <koz_> xuxu: You're welcome!
00:09:15 <xuxu> "The class Num of numeric types is..." it was staring at me the entire time
00:10:10 <augur> there's an interesting interaction between computation and behavior in the mechanical design of programs that i wish i had a good grip on :(
00:10:11 <glguy> look up 'singular' in lens
00:11:48 <xuxu> bedtime for xuxu. EvanR, good luck with your game!
00:11:57 <EvanR> thx
00:15:30 <koz_> glguy: Ah, OK. Thanks for that!
00:17:28 <lpaste> koz_ pasted “Confused about Prism' and APrism'” at http://lpaste.net/183464
00:21:07 <koz_> In general, what *is* the difference between the lens Prism' and APrism' types? I'm a bit confused about those.
00:27:39 <lyxia> koz_: functions that take prisms as arguments usually just use the APrism specialization
00:28:22 <lyxia> but when you write prisms, better use the polymorphic one, Prism, to have better static guarantees, and to be able to use prisms in various contexts
00:28:42 <lyxia> e.g. as a Traversal
00:29:15 <koz_> lyxia: OK, that explains compilation fun.
00:37:31 * hackagebot random-fu-multivariate 0.1.2.0 - Multivariate distributions for random-fu  https://hackage.haskell.org/package/random-fu-multivariate-0.1.2.0 (DominicSteinitz)
00:39:16 <koz_> What's a sensible way to check if a list has no 'runs' (consecutive identical elements)?
00:41:04 <lyxia> all (null . tail) . group
00:41:28 <koz_> lyxia: ... Wow, that's brilliant.
00:42:12 <lyxia> and . join (zipWith (/=) . tail)
00:42:22 <lyxia> :)
00:50:50 <chsn> i'm trying to install haskell haste
00:50:59 <chsn> it appears to depend on a number of deprecated / bit-rotted libraries
00:51:02 <chsn> is haste done for?
00:52:21 <geekosaur> Mon Oct 12 21:22:54 UTC 2009
00:52:38 <geekosaur> assuming you mean the pastebin tool and not the compiler (which is haste-compiler)
00:53:08 <chsn> I mean haste-compiler
00:53:24 <chsn> I can't get it to build via stack install
00:53:33 <chsn> then I git check out, I do  'stack install', it tries to pull from lts-5.5 and fails
00:53:44 <chsn> then I try "cabal install", and it tries to pull some package that hacakge has deprecated
00:53:53 <chsn> geekosaur: do you have haste-compiler working?
00:54:21 <geekosaur> haven't tried; I'm just looking at hackage
00:54:35 <geekosaur> most recent release looks to be not compatible with ghc8
00:55:01 <chsn> I'm on ghc 7.10.3
00:55:50 <geekosaur> which package is deprecated? (old-time? I saw that in tar's deps)
00:56:09 <chsn> something dealing with exception handling
00:56:16 <chsn> (don't have the error on hand, trying another approach)
01:01:56 <geekosaur> I wouldn't worry about the ErrorT/ExceptT thing much
01:02:32 * hackagebot lbfgs 0.1 - L-BFGS optimization  https://hackage.haskell.org/package/lbfgs-0.1 (IanWooKim)
01:03:38 <geekosaur> that is a very recent deprecation, and the issue is if you change it then you lose backward compatibility
01:04:08 <geekosaur> likewise various other warnings look to be compatibility with older ghc versions
01:05:36 <geekosaur> (in fact, iirc the deprecation and the replacement came in the same ghc release, which is something of a no-no specifically because it means there's no transition path for backcompat)
01:07:32 * hackagebot google-oauth2-jwt 0.1.1.1 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.1.1.1 (MichelBoucey)
01:07:45 <bennofs> geekosaur: well you can use http://hackage.haskell.org/package/transformers-compat I think to have ExceptT on older versions of GHC as well
01:08:53 <pkmx> are there any dirty tricks that allow you to write f :: forall (b :: Bool). Bool without using type classes?
01:09:14 <pkmx> so f @'True = True and f @'False = False
01:10:19 <bennofs> pkmx: i think you need singletons for the type <-> value mapping, so no
01:11:23 <mahe2> I wonder if there's a shorter way to write (runKleisli . first . Kleisli $ conversionProcess) `traverse` ((\td -> (td, td)) <$> targetDirEither)
01:11:24 <pkmx> bennofs: yeah, i was trying to see if there are unsafe tricks without using singletons
01:11:39 <geekosaur> other than that I get a build fail for bzlib because I don't have the bz2 dev package installed
01:12:03 <geekosaur> (it's not native, it's a binding... so you need the dev package for the library it binds)
01:12:03 <bennofs> pkmx: not really I think. the only way for values to depend on types is through type classes AFAIK
01:13:15 <bennofs> :t runKleisli . first . Kleisli
01:13:17 <lambdabot> Monad m => (b -> m c) -> (b, d) -> m (c, d)
01:15:21 <bennofs> mahe2: targetDirEither >>= \td -> (,td) <$> conversionProcess td ?
01:15:54 <bennofs> mahe2: oh hmm not actually sure if that's the same if I think about it some more
01:16:00 <bennofs> oh not it is not, sry
01:16:41 <bennofs> mahe2: but (\td -> (,td) <$> conversionProcess td) `traverse` targetDirEither should work I think?
01:20:06 <mahe2> bennofs: thx, works and looks simpler :)
01:20:33 <Taneb> Watching edwardk's talks seem to end up as "What's wrong with Haskell's standard libraries? Well, they don't let us talk about split epimorphisms in the category of monad transformers"
01:39:12 <M41px[m]> hello
01:50:35 <amx> I let users of my library pass in a A->B that will typically use pattern-matching on the input. Is there a way to force exhaustive pattern matching on a function?
01:54:38 <MarLinn> amx: I don't think so. But maybe you could let them pass in a bunch of functions, one for each case
01:55:12 <lyxia> I'd just write that in the documentation.
01:55:47 <amx> A and B are determined by the user as well. Yeah, I probably will just document it.
01:59:56 <pavonia> In this example, why is the pattern match on line 15 not allowed while the one on line 14 is? They should have the same types  http://lpaste.net/183553
02:01:22 <Cale> pavonia: Because there's no guarantee that it's a list of Int values
02:01:38 <Cale> pavonia: It'll be a list of values of type t
02:02:19 <pavonia> But shouldn't that be inferred from the types on the right-hand side?
02:02:25 <Cale> hm?
02:02:40 <Cale> You've said that fooToInt takes an argument of type Foo t, and produces an Int
02:03:09 <Cale> So suppose I apply fooToInt to some value of type Foo String
02:03:41 <Cale> (nevermind that I can't build one of those at the moment)
02:03:53 <koz_> Can I write this any more neatly? 'anyOf each (anyOf both (> 0))'
02:03:54 <Cale> Oh, actually I totally can
02:04:01 <Cale> FooList [] :: Foo String
02:04:30 <pavonia> Hhm
02:04:45 <Cale> Or perhaps it's  FooList [FooList [], FooList []] :: Foo String  :)
02:05:45 <pavonia> So there's no way to make such special cases in that function?
02:06:43 <pavonia> Or maybe ...
02:07:36 <Cale> It looks like you wanted fooToInt :: Foo Int -> Int
02:07:57 <Cale> Also, your existing fooInt is partial
02:08:31 <pavonia> "FooList ls@(FooInt _ : _) -> sum $ map fooInt ls" works
02:08:41 <Cale> surew
02:08:43 <Cale> -w
02:09:20 <Cale> But it doesn't cover the empty list case, or the case where it's a FooList of FooLists, or...
02:09:23 <koz_> How would you write a [(a, a)] -> [a] function using lens stuff?
02:09:53 <Cale> pavonia: But certainly if the list contains an element constructed by FooInt, you know that it's a list of values of type Foo Int
02:10:04 <puregreen> koz_: if “gathering all elements”, then “toListOf (each.both)”
02:10:15 <puregreen> (toListOf = ^..)
02:11:35 <koz_> puregreen: That makes sense - I forgot lenses compose in the wrong order. :P
02:12:15 <pavonia> Cale: In my real code the result types are different, so maybe that example was to simplified
02:13:00 <pavonia> The result types of the constructors, that is
02:15:35 <puregreen> koz_: you can just remember a rule of thumb: if you use operators then data always flows in one direction without jumping around. “foo ^. a.b” – left-to-right. “b . a $ foo” – right-to-left. “foo & a.b %~ f” – left-to-right.
02:16:10 <koz_> puregreen: I'm sure I'll adjust in time.
02:16:19 <koz_> Haskell is still a bit magical to me in places, I must admit.
02:16:35 <koz_> And the lens library includes not only batteries, but also a kitchen sink.
02:17:46 <koz_> Also, what's a Haskelly way to check 'is this list of numbers monotonically increasing'?
02:18:28 <puregreen> and $ zipWith (<) xs (tail xs)
02:18:36 <youser> hello friends
02:18:43 <koz_> puregreen: Thanks. Now I need to read and think how that works... :P
02:19:29 <puregreen> @undo do Just x <- [Nothing, Just 3]; return x
02:19:29 <lambdabot> [Nothing, Just 3] >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
02:22:34 * hackagebot gi-vte 2.91.7 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.7 (inaki)
02:24:27 <atc-> Anyone here familiar with Opaleye? I'm really struggling getting a query to run and return a Maybe
02:57:35 * hackagebot synthesizer-core 0.8 - Audio signal processing coded in Haskell: Low level part  https://hackage.haskell.org/package/synthesizer-core-0.8 (HenningThielemann)
03:07:36 * hackagebot synthesizer-dimensional 0.8 - Audio signal processing with static physical dimensions  https://hackage.haskell.org/package/synthesizer-dimensional-0.8 (HenningThielemann)
03:12:36 * hackagebot synthesizer-dimensional 0.8.0.1 - Audio signal processing with static physical dimensions  https://hackage.haskell.org/package/synthesizer-dimensional-0.8.0.1 (HenningThielemann)
03:22:36 * hackagebot synthesizer-core 0.8.0.1 - Audio signal processing coded in Haskell: Low level part  https://hackage.haskell.org/package/synthesizer-core-0.8.0.1 (HenningThielemann)
03:27:36 * hackagebot synthesizer-midi 0.6.0.3 - Render audio signals from MIDI files or realtime messages  https://hackage.haskell.org/package/synthesizer-midi-0.6.0.3 (HenningThielemann)
03:32:37 * hackagebot synthesizer-alsa 0.5.0.4 - Control synthesizer effects via ALSA/MIDI  https://hackage.haskell.org/package/synthesizer-alsa-0.5.0.4 (HenningThielemann)
03:42:37 * hackagebot jack 0.7.1 - Bindings for the JACK Audio Connection Kit  https://hackage.haskell.org/package/jack-0.7.1 (HenningThielemann)
04:21:28 <chsn> for a paritulcar haskell package, I need the latest from github. Is there a way to tell stack "use this particular location on my file system ,which contains a particular version from github" ?
04:22:38 * hackagebot chronos 0.1.0 - Initial project template from stack  https://hackage.haskell.org/package/chronos-0.1.0 (andrewthad)
04:25:26 <puregreen> chsn: https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
04:41:38 <int-e> hvr: I think I'd want to experiment with new-build first before putting it into a travis configuration. But yes, I would welcome a garbage collection feature (though I'm not sure what it would look like... would it take paths to all relevant cabal.project files?)
04:44:33 <bollu> guys, I want to contribute to GHC
04:44:37 <bollu> but I don't know where to start
04:49:25 <int-e> bollu: https://ghc.haskell.org/trac/ghc/wiki/Newcomers is a place to start
04:55:05 <bollu> int-e: I've actually taken up an issue
04:55:11 <bollu> but. the codebase is so vasy
04:55:12 <bollu> vast*
04:55:15 <bollu> who do I go to for help?
04:56:35 <int-e> bollu: be prepared to do a lot of reading... the bottom of the Newcomers page lists the ghc-devs mailing list and #ghc (which is less formal and quicker)
04:57:07 <lyxia> You can ask on #ghc or the ML
05:00:17 <bollu> int-e: I see, thank you
05:08:04 <Wizek> Any ideas why I run into an occurs check type error when I try to make the inject be a function of overrides as opposed to having it as a global, singleton reference? 
05:08:06 <Wizek> https://github.com/Wizek/exp-di-poc/commit/349813df7b87ab5e3decb31cfe383ce6ced6fbaa?diff=split
05:10:02 <Wizek> `Occurs check: cannot construct the infinite type: t ~ k -> (t -> t0) -> t0` I get a vague intuition that the type for inject would need to be infinitely recursive, but not sure if what I am trying to do is impossible or now. Could there be any way around this error?
05:19:37 <mniip> Wizek, what kind of function are you trying to write
05:24:36 <Wizek> mniip, Haven't we had a discussion about this previously? Your handle is somewhat familiar. Or maybe it was someone else. In either case: I'm taking another stab at trying to implement dependency injection in haskell, or at least a proof of concept. In Main9.hs the inject function is supposed to return its last argument in most cases, unless an override is defined in the Map. In which case the override value should be returned by 
05:24:36 <Wizek> inject
05:24:37 <niluje> what's the best way to install haskell packages? hsenv? cabal sandboxes?
05:25:31 <mniip> Wizek, I think you're hitting limits of rank1 polymorphism
05:25:39 <Wizek> niluje, I use https://docs.haskellstack.org/en/stable/README/ for that nowadays
05:25:57 <mniip> but I can't say I can see exactly the transformation you're making here
05:26:47 <ocramz> hullo!
05:27:30 <niluje> "curl -sSL https://get.haskellstack.org/ | sh"
05:27:33 <niluje> :(
05:27:53 <niluje> when will we stop doing this kind of stuff
05:27:54 <ocramz> niluje don't pipe to bash, not even if it's from FPCo
05:28:15 <ocramz> :D
05:28:26 <niluje> FPCo?
05:28:37 <Wizek> niluje, Are you on linux?
05:28:42 <niluje> osx
05:28:54 <Wizek> niluje, https://docs.haskellstack.org/en/stable/install_and_upgrade/#mac-os-x
05:29:23 <int-e> that reminds me of "twitch installs gentoo" (it ended up running a shellscript from a pastebin that downloaded an Arch iso image ...
05:30:15 <int-e> niluje: ah but at least it's https :P
05:30:34 <niluje> :)
05:30:55 <niluje> I prefer the homebrew alternative
05:31:18 <Wizek> mniip, Well, you see on the left side `overrides` is a global value, and on the right side I was trying to make this possible: `inject (Map.fromList [("k", value)]) "a" a` so that I can have different kinds of overrides for different calls to inject. Does that make more sense for you?
05:31:46 <ocramz> Q: what's the difference between using ForeignPtr and managing a Ptr within Control.Exception.bracket ?
05:32:00 <ocramz> in terms of safety and lifetime
05:32:40 <ocramz> does a ForeignPtr stay pinned to the same memory location?
05:32:58 <mniip> Wizek, try adding types for your original functions
05:33:06 <mniip> and see if they still make sense for your final functions
05:33:36 <mniip> 		  
05:33:36 <mniip>   -- inject :: String -> (String -> a) -> a
05:33:37 <mniip> that's wrong
05:34:47 <niluje> Wizek: what's the difference between the src and the app directories?
05:38:17 <MarcelineVQ> with stack? in a default project app happens to be where your executable's source files reside whereas src is for your library's source files. you can set it up however you like though, it's not especially important, that's just where the default .cabal file expects to find things
05:38:40 <niluje> okay
05:39:03 * dysfun usually moves the Main.hs out of app into the top level dir
05:39:15 <hvr> int-e: jfyi, hackage-server dogfeeds new-build in its travis config
05:39:23 <niluje> dysfun: and you put all you code in the src directory?
05:39:43 <dysfun> I put main.hs in / and everything else in src
05:39:58 <dysfun> where / = the root of the project
05:40:33 <dysfun> and then tweak the .cabal file not to refer to 'app'
05:40:42 <puregreen> a quick survey: if you have read LYAH but still consider yourself a beginner, please say whether you know about kinds or not
05:41:13 <dysfun> i don't think most people who would consider themselves beginners would be particularly comfortable with kinds
05:41:51 <puregreen> not “comfortable”, just whether reading something like “types have types too” makes you go “wait, what” or rather “thanks, captain obvious”
05:41:57 <niluje> okay
05:42:18 <niluje> wait, what?
05:42:19 <dysfun> well in some languages, types don't have a type
05:42:25 <niluje> :(
05:42:41 <dysfun> so i suppose it depends where you're coming from
05:43:08 <niluje> is it worth reading?
05:43:12 <ocramz> LYAH?
05:43:15 <niluje> yes
05:43:32 <niluje> http://learnyouahaskell.com/ this is it right?
05:43:36 <dysfun> that's the one
05:43:40 <ocramz> yeah it's a bit playful at times but it clarified a few things when I was beginning
05:43:44 <dysfun> and the content is fine, it's just a case of whether that style works for you
05:43:56 <niluje> I'll give it a try 
06:07:12 <ocramz> can anyone point me at a library that uses ForeignPtr and performs mutation on the underlying data?
06:08:41 <Axman6> isn't ByteString built on it?
06:09:25 <ocramz> and does in-place mutation?
06:09:47 <ocramz> I hadn't looked into its entrails yet.
06:10:12 <ocramz> I'd be more interested in seeing how this is used across the FFI
06:10:32 <Axman6> yeah, there's a good chance there's something, in anything which creates a ByteString from say a String
06:10:32 <ocramz> as in, mutable data on the C side
06:10:48 <Axman6> actually that probably uses something built in
06:13:23 <ocramz> Axman6 : have you written FFI stuff in the past?
06:14:54 <Axman6> not a whole lot, and it's been a while
06:17:16 <cocreature> ocramz: What exactly are you looking for? you work with a ForeignPtr exactly like you do with a Ptr. The only difference is that there is a finalizer that gets called if your haskell code no longer has any references to the ptr
06:19:10 <ocramz> cocreature: I get a SEGV when mutating a C array that's handled as a Ptr (with initializer and finalizer handled by `bracket`). 
06:19:28 <cocreature> ocramz: could you show the source?
06:19:34 <cocreature> or at least the interesting parts
06:20:02 <ocramz> sure, I'll prepare a gist
06:22:18 <cocreature> ocramz: also a tip if you are doing ffi: if you compile your program with -g you can run it in gdb/lldb and often get useful backtraces on segfaults that even show you the location in your haskell code where you did the ffi call
06:23:14 <ocramz> cocreature: this is very handy, thank you
06:23:44 <cocreature> I spent way too much time inserting print statements to figure things like this out before I realized I could just use -g :)
06:25:01 <ocramz> well I sort of know the culprit but e.g. ValGrind doesn't build on OSX
06:33:51 <suppi> is there a class like monoid that only has mempty?
06:34:13 <suppi> nevermind that's a stupid question
06:34:47 <cocreature> suppi: there is a Default class but it’s not really useful to have a class for that
06:35:11 <suppi> cocreature: yeah i guess so. thanks :)
06:42:25 <hpc> suppi: the other way there's semigroups which only have append ;)
06:42:41 <suppi> hpc: that i know :)
06:43:51 <ski> @type max
06:43:53 <lambdabot> Ord a => a -> a -> a
06:47:50 * hackagebot hakyll-shakespeare 0.1.0 - Hakyll Hamlet compiler  https://hackage.haskell.org/package/hakyll-shakespeare-0.1.0 (Eliza0x)
06:52:50 * hackagebot llvm-ffi 3.8.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.8.0 (HenningThielemann)
06:54:13 <haskell976> @pl Parser (\s -> (fmap (first f) (p s))) 
06:54:13 <lambdabot> Parser (fmap (first f) . p)
07:01:12 <haskell976> @pl (Parser (\s -> Just(a, s)))
07:01:12 <lambdabot> Parser (Just . (,) a)
07:02:04 <ski>   return a  -- ?
07:03:50 <Guest623> How can I apply a lens to an IO monad?
07:04:10 <dysfun> do you want to rephrase that?
07:04:45 <puregreen> if you want to use a lens with an IO action, just apply the lens directly: “each print [1,2,3]”
07:04:49 <Guest623> dysfun: I want to game^.board where game :: IO Game
07:05:11 <cocreature> do game' <- game; game' ^. board
07:05:21 <puregreen> “view board <$> game”
07:05:58 <Guest623> cheers!
07:07:33 <ski> (Guest623 : fyi (nitpicking), `game' is not an "IO monad", it's an "IO action", as puregreen said. `IO' (the type) itself (together with the implementation of `return' and `(>>=)' for it, satisfying a few reasonable laws) is the monad)
07:08:16 <Guest623> ski: thanks for explaining!
07:09:08 <ski> we can also say "monadic action" or just "action" (sometimes over words like "computation" are also used), if we don't care to say explicitly that the monad in question is `IO'
07:09:25 <ski> (er, s/over/other/)
07:10:08 <ski> e.g. `getLine :: IO String' is not a function, but an action
07:10:36 <ski> and `putStrLn :: String -> IO ()' is, strictly speaking, not an action, but a function that will return an action (when applied to a string)
07:11:20 <ski> (or at least not an `IO' action, but that was the intended monad here ..)
07:12:32 <ski> for short, we say that `putStrLn' will output the string passed to it, on standard output. a more correct explanation would be that it returns an action that *describes* the action of outputting the string
07:12:52 <ski> (aka : returns an action that, when executed, will output the string)
07:13:11 <alercah> ski: that's a useful theoretical model but the former is closer to the actual reality
07:13:42 * ski is talking about the language itself here, not about any particular implementation
07:15:00 <ski> if you're just beginning with `IO', or monads, then you probably shouldn't worry too much if you don't understand the above subtlety. but at some point, it will be useful to make this distinction
07:16:26 <ski> (alercah : in particular, i'm not talking about how a Haskell function can be *implemented*, say in terms of performing procedures in some procedural language, or, if you prefer, in terms of how machine instructions will execute on a machine)
07:17:40 <Narfinger> hiho, quick question: is there a way to write this piece of code more haskell like/shorter? http://lpaste.net/183799
07:18:18 <Narfinger> (except the redundant braces)
07:18:39 <ski> (.. of course, it can be helpful to have *some* idea about how that would happen, as well .. but it doesn't really help much with reasoning at the level of the language itself -- which i'd argue should be a priority)
07:19:16 <haskell976> @pl Parser (\s -> case p1 s of         Just (p1func, sRem) -> fmap (first p1func) (p2 sRem)         Nothing -> Nothing         )
07:19:16 <lambdabot> (line 1, column 58):
07:19:16 <lambdabot> unexpected '>'
07:19:16 <lambdabot> expecting operator
07:19:30 <haskell976> @pl (\s -> case p1 s of         Just (p1func, sRem) -> fmap (first p1func) (p2 sRem)         Nothing -> Nothing         )
07:19:30 <lambdabot> (line 1, column 51):
07:19:30 <lambdabot> unexpected '>'
07:19:30 <lambdabot> expecting operator
07:20:16 <MarLinn> Narfinger: you could try using fmap / (<$>)
07:20:26 <EverNarrator> test
07:20:41 <ski>   formatUTCToLocal t = TI.formatTime TI.defaultTimeLocale "Last Refreshed: %H:%M:%S, %e.%m.%_Y" . (`TI.utcToLocalTime` t) <$> TI.getCurrentTimeZone  -- Narfinger ?
07:21:22 <EverNarrator> How do I make stack get rid of an older version of a package in favor of a newer one?
07:21:33 <Narfinger> can you explain/give a documentation for .(`f` t)?
07:21:37 <Narfinger> I never saw that before
07:21:55 <EverNarrator> I.e. it installed megaparsec-4.4.0 rather than 5.0.1 (which is what I want)
07:22:14 <ski> @pl Parser (\s -> case p1 s of {Just (p1func, sRem) -> fmap (first p1func) (p2 sRem); Nothing -> Nothing})  -- i think `pl' doesn't do `case'
07:22:14 <lambdabot> (line 1, column 28):
07:22:14 <lambdabot> unexpected "{"
07:22:14 <lambdabot> expecting variable, "(", operator or ")"
07:22:27 <puregreen> EverNarrator: megaparsec-5.0.1 isn't on Stackage yet so you'll have to do this:
07:22:35 <EverNarrator> ah
07:22:37 <MarcelineVQ> if it installed megaparsec 4 and you didn't specify you wanted 5 it's because your resolver only has 4, you need to use a more current resolver, the nightly's have megaparsec 5 but they use ghc 8
07:22:42 <EverNarrator> then never mind
07:22:46 <EverNarrator> thank you
07:22:49 <ski> haskell976 ^
07:22:51 <puregreen> https://github.com/aelve/guide/blob/master/stack.yaml#L24
07:22:59 <MarLinn> > (5 `mod` 2, mod 5 2) -- Narfinger
07:23:01 <lambdabot>  (1,1)
07:23:02 <puregreen> you perfectly can do it
07:23:09 <ski> Narfinger : it's just another way to write `flip TI.utcToLocalTime t'
07:23:15 <puregreen> (at least I do it and nothing broke yet)
07:23:34 <puregreen> EverNarrator: ^
07:23:43 <ski> > map (`mod` 3) [0,1,2,3,4]
07:23:45 <lambdabot>  [0,1,2,0,1]
07:24:05 <ski> > map (`mod` 3) [0,1,2,3,4]  :: [Expr]
07:24:07 <lambdabot>  [0 `mod` 3,1 `mod` 3,2 `mod` 3,3 `mod` 3,4 `mod` 3]
07:24:43 <Narfinger> oh my god, I never heard of flip, that will make a lot of code soo much nicer. thanks!
07:25:06 <ski> Narfinger : if you think it's clearer (to you) with `flip', then go with that
07:25:08 <dysfun> flip is one of my favourite functions
07:25:28 <Axman6> flip always feels like a wart to me, I hate having to use it
07:25:46 <ski> > map (mod `flip` 3) [0,1,2,3,4]  -- another (possibly slightly silly ?) way to write it ?
07:25:48 <lambdabot>  [0,1,2,0,1]
07:25:56 <dysfun> Axman6: if you are doing extensible effects etc. it is great
07:26:00 <Narfinger> no the shortcut is good enough
07:26:16 <Axman6> dysfun: not sure I follow
07:26:33 <ski> Narfinger : i hope you've heard of `const' and `id', at least
07:27:18 <Narfinger> id yes, const not... but I don't know where they would be useful
07:27:18 <ski> (that infix `flip' version can perhaps be useful if the function expression isn't just a single identifier)
07:27:45 <ski> if you write `\_ -> x', then that could be `const x' instead
07:28:06 <hexagoxel> flip const == const id
07:28:08 <dysfun> Axman6: see top code example http://stackoverflow.com/questions/38993017/how-do-i-compose-freer-effects-in-haskell/38999214#38999214
07:28:22 <Axman6> I think someone, possibly Brian McKenna, wrote an n-flip library which gave you every possible flip combination up to something like 8 arguments
07:28:24 * ski . o O ( s/==/=/ )
07:28:52 <dysfun> heh, reminds me of writing stack rotators in forth
07:29:08 <Axman6> yeah
07:29:47 <ski> there's some Scheme code floating around for generating `caar',`cadr',`cdar',`cddr',`caaar',`caadr',`cadar',&c.
07:30:38 <Axman6> I got a laugh a few years ago when someone wrote a blog post about how Factor was a much more useful language than haskell because it had all these unique features, then wihtin an hour someone had written a haskell library which IIRC had exactly the sme syntax AND was type safe
07:30:50 <ski> dysfun : in fact, that's an interesting way to make a small concatenative DSL in Haskell
07:31:06 <dysfun> ski: what is?
07:31:23 <ski>   dup k a = k a a  -- (a -- a)
07:31:37 <dysfun> heh
07:31:38 <ski>   drop k a = k  -- ( a -- )
07:31:49 <ski>   swap k a b = k b a  -- ( a b -- b a )
07:32:04 <ski> then you can compose your words with `.'
07:32:14 <dysfun> it's a shame we won't be able to capitalise them
07:32:25 <dysfun> not proper forth unless the code is ugly as sin and impossible to comprehend once written
07:32:28 <ski>   lit c k = k c  -- ( -- c )
07:32:38 <ski> can be used to push a value on the "stack"
07:32:49 <ski> (and the stack will be heterogenously typed)
07:32:55 <haskell976> @pl (\c -> [c])
07:32:55 <lambdabot> return
07:32:58 <dysfun> heh
07:33:13 <ski> aka `(: [])'
07:33:14 <Axman6> haskell976: pure has less characters
07:33:39 <MarLinn> Ts. return is so pre-AMP
07:33:47 <Axman6> yeah
07:34:29 <ski> (also, word composition there by `.' is "left-to-right", as you'd expect from concatenative languages ..)
07:34:50 <Axman6> https://gist.github.com/fogus/2919520
07:36:01 <Axman6> I'm sure I've seen a version where the syntax was basically identical to forth's justaposition without the need for some kind of composition
07:36:06 <Axman6> function*
07:36:46 <dysfun> pity you can't make shouty-named functions in haskell
07:36:46 <haskell976> @pl (\a -> ())
07:36:47 <lambdabot> const ()
07:38:25 <Axman6> also https://www.reddit.com/r/haskell/comments/ptji8/concatenative_rowpolymorphic_programming_in/ apparently Okasaki showed how to do it without combinators
07:44:03 <mauke> class DVar (sym :: Symbol) a | sym -> a where { dval :: a }
07:46:31 <ski> with type application ?
07:48:48 <mauke> yep
07:49:07 <mauke> it's implicit parameters done manually
07:49:10 <Axman6> wait, how does you actually use that?
07:49:26 <Axman6> oh, dval @"foo"?
07:49:26 <mauke> foo y = dval @"x" + y
07:49:29 <mauke> yep
07:49:32 <Axman6> yeah nice
07:49:39 <mauke> the trick is how to call it
07:49:44 <mauke> because it requires defining a local instance
07:49:50 <Axman6> yeah, that's what stumped me
07:50:11 * hackagebot llvm-ffi 3.8.0 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.8.0 (HenningThielemann)
07:50:11 * hackagebot hakyll-shakespeare 0.1.0.0.1 - Hakyll Hamlet compiler  https://hackage.haskell.org/package/hakyll-shakespeare-0.1.0.0.1 (Eliza0x)
07:53:13 <mauke> Axman6: are you familiar with the reflection package?
07:55:05 * hackagebot hakyll-shakespeare 0.1.0.0.2 - Hakyll Hamlet compiler  https://hackage.haskell.org/package/hakyll-shakespeare-0.1.0.0.2 (Eliza0x)
07:55:49 <ocramz> cocreature : what TZ are you in? will you be reachable a couple hours from now?
07:55:49 <Axman6> acquanted but not familiar
07:57:43 <EverNarrator> is there a way to use Text.Megaparsec to extract a slice of it's input Data.Text matching some predicate? E.g. a Control.Applicative.many variant of some sort.
07:58:13 <puregreen> EverNarrator: no
07:58:18 <EverNarrator> damn
07:58:38 <puregreen> subscribe to this issue: https://github.com/mrkkrp/megaparsec/issues/106
07:58:46 <lpaste> mauke pasted “implicit parameters done manually” at http://lpaste.net/183814
07:58:52 <puregreen> maybe leave a comment to show that you need it, I don't know
07:59:08 <mauke> Axman6: ^
08:00:33 <Axman6> I have no idea what's going on there, but I'm literally falling sleep on the couch at the moment
08:01:36 <zennist1> anyone who uses shelly? I find that running a command that accepts stdin seems difficult
08:03:23 <zennist1> for example, in ghci, if I do shelly $ run_ "cabal" ["init"], the process immediately terminates 
08:03:52 <ski> mauke : hm, not `with :: forall a r. a -> (forall sym. DVar sym a => r) -> r' ?
08:04:16 <mauke> ski: how do you specify which variable to bind, then?
08:04:59 <mniip> with typeApplications
08:05:05 <f-a> I have a small haskell project (made using cabal), what's the best way to use https://downloads.haskell.org/~ghc/7.4.2/docs/html/users_guide/hpc.html on it
08:05:10 <mniip> with @"foo"
08:05:22 <ski> hm, i suppose you're right
08:05:37 <mauke> mniip: that has kind Symbol, not *
08:05:41 <f-a> the page is very thorough but it only seems to deal with 'plain' ghc, I'd like to check the coverate , say, after havin run tests
08:06:07 <amyers> Is there a map like function which has access to the portion of the structure which has been built from the map so far?  I could do this with a fold and Vector.snoc but am hoping for something more efficient
08:06:09 <mniip> oh I might be misremembering what this conversation began from?
08:06:19 <mniip> ah
08:06:23 <mniip> okay
08:08:27 <f-a> (apparently --enable-coverage)
08:13:41 <MarLinn> amyers: maybe you're looking for scanl/scanr or mapAccumL/mapAccumR
08:15:09 * hackagebot haskell-gi-base 0.18.2 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.18.2 (inaki)
08:15:49 <amyers> MarLinn, I think both of those will require me to build the Vector myself using snoc.  I was hoping there would be something that allocated the whole thing and passed me a view to the portion that was constructed so far
08:19:08 <amyers> Just found Vector.constructN, that might be what I need ...
08:20:09 * hackagebot cereal-plus 0.4.2 - An extended serialization library on top of "cereal"  https://hackage.haskell.org/package/cereal-plus-0.4.2 (NikitaVolkov)
08:24:51 <cocreature> ocramz: utc+2, not sure if I’ll have time in a few hours (or if I’m still awake depending on how long few is :))
08:35:09 * hackagebot memoize 0.8 - A memoization library  https://hackage.haskell.org/package/memoize-0.8 (JesseTov)
08:45:43 <haskell976> @pl \a b -> [a, b]
08:45:43 <lambdabot> (. return) . (:)
08:49:09 <david__> Need some help: I want to make a newtype to wrap a V2 (a 2d vector type). I want to use phantom types to keep track of the coordinate system of each vector.
08:49:33 <david__> that part is easy
08:49:56 <david__> > newtype SV2 space a = SV2 (V2 a)
08:49:58 <lambdabot>  <hint>:1:1: error: parse error on input ‘newtype’
08:50:53 <david__> but at that point space could by any type
08:51:49 <david__> is there a way to constrain it to only "valid" types?
08:52:03 <david__> I was thinking of using DataKinds and doing...
08:52:10 <david__> data Space = Window | World
08:52:13 <saurabhnanda> is there an good comparison of existing custom preludes? pros & cons of each?
08:52:26 <mauke> david__: yes, that's one way
08:53:42 <david__> this is what I want to do, but is not valid haskell:
08:54:08 <david__> newtype SV2 (space :: 'Space) a = SV2 (V2 a)
08:54:15 <mauke> how does it fail?
08:54:34 <puregreen> saurabhnanda: I have a comparison at https://guide.aelve.com/haskell/alternative-preludes-zr69k1hc but it's incomplete (feel free to add to it)
08:54:54 <david__> ..... parse error on the '
08:55:05 <david__> OMG if I remove the ' it works!
08:55:44 <saurabhnanda> puregreen: checking it out. If I could contribute, I wouldn't be asking.
08:55:58 <saurabhnanda> puregreen: as a newbie, I want to be guided to something that will work 90% of the time.
08:56:35 <puregreen> saurabhnanda: that's base-prelude then, it works like 100% of the time by not giving you anything that you couldn't already import from base :)
08:56:48 <saurabhnanda> puregreen: :)
08:58:19 <david__> FYI the code requires ghc extensions DataKinds (to promote the Space type) and KindSignatures (to allow specifying the kind of the space type parameter in SV2)
08:59:15 <saurabhnanda> puregreen: no-go: "Doesn't help with other commonly needed packages (such as text, vector, etc).'
08:59:58 <jmcarthur> david__: It's right that you shouldn't put the ' there. The ' is for lifted constructors.
09:00:10 * hackagebot memoize 0.8.1 - A memoization library  https://hackage.haskell.org/package/memoize-0.8.1 (JesseTov)
09:02:17 <david__> so now that Space is promoted, are there singleton data type that I could use?
09:04:52 <david__> I want to make a function like this: coerceSpace :: Space s => s -> SV2 b a -> SV2 s a
09:05:10 * hackagebot paprika 0.1.0.0 - The Haskell library and examples for the kids programming robot paprika  https://hackage.haskell.org/package/paprika-0.1.0.0 (tkmsm)
09:05:33 <mauke> coerceSpace :: SV2 b a -> SV2 (s :: Space) a
09:06:36 <david__> ok, so then the output space will be infered. What if I want to force the programmer to specify the output space?
09:07:19 <mauke> actually, coerceSpace :: SV2 b a -> SV2 s a should just work
09:07:40 <mauke> coerceSpace :: proxy s -> SV2 b a -> SV2 s a  if you want to take another argument?
09:09:06 <david__> right! yes.. where does the proxy function come from? Prelude?
09:09:14 <alercah> Data.Proxy
09:09:49 <pkmx> if you are targeting ghc >= 8.0, you can also use TypeApplications
09:10:44 <monochrom> w00t, I should use TypeApplications more often
09:11:16 <jmcarthur> Not a fan of TypeApplications due to things like this: https://gist.github.com/tonymorris/6c504df0ea4ee031073cee97c977a347
09:13:21 <david__> wow TypeApplications looks cool. I'm still on ghc 7.10.3 at the moment, though.
09:13:58 <david__> If I use Proxy, how do I actually inhabit the type?
09:14:05 <pkmx> I thought ghc probably should just restricted type applications to declarations with explicit forall's
09:14:15 <pkmx> the constructor is Proxy
09:14:24 <mauke> david__: proxy is not a function; it's a type variable
09:14:56 <mauke> david__: Proxy :: Proxy 'Window  -- I think
09:20:10 * hackagebot paprika 0.1.0.1 - The Haskell library and examples for the kids programming robot paprika  https://hackage.haskell.org/package/paprika-0.1.0.1 (tkmsm)
09:21:14 <jmcarthur> I'd like to make a quick shoutout to the rawr package http://hackage.haskell.org/package/rawr . There's an entire new generation of record libraries that came out around the same time and probably all have similar features. rawr is just the first one I looked at, and it's kind of amazing.
09:24:13 <david__> coerceSpace (Proxy :: Proxy World) someOtherSV2
09:28:12 <pkmx> jmcarthur: now i just need overloaded labels for patterns to make matching on the records nicer ;)
09:28:54 <david__> Thanks for the help, all.
09:30:04 <jmcarthur> pkmx: :)
09:30:18 <gp5st> is there a means to exhaustively check an integer range (so I ahve to cover x< 0, x > 0, x == 0, for isntance?
09:31:08 <saurabhnanda> is tomjaguarpaw around?
09:31:11 <glguy> example x | x > 0 = .... | x < 0 = ... | otherwise = ...
09:31:28 <glguy> or: example x = case compare x 0 of GT -> ...; LT -> ...; EQ -> ...
09:31:51 <Welkin> you could use bitwise operations to check
09:31:52 <Welkin> :D
09:32:04 <Welkin> signed integers have a 1 in the most significant bit
09:33:39 <gp5st> glguy: in that first example, will the compiler enforce all cases? (trying to get an example working, but i'm green, so it's taking longer :-p)
09:34:58 <pkmx> otherwise is sort of a fallback case that always succeed to match
09:35:07 <pkmx> @src otherwise
09:35:07 <lambdabot> otherwise = True
09:36:06 <Welkin> :t const . const
09:36:08 <lambdabot> a -> b -> b1 -> a
09:46:35 <mpickering> Does anyone have any opinion on which library library I should use to write a front-end for my website?
09:46:50 <jmcarthur> Everybody has an opinion.
09:47:11 <monochrom> use hxt to generate html :)
09:47:29 <mpickering> But does anyone want to offer their (sensible) opinion !
09:47:31 * monochrom does this
09:47:33 <Welkin> mpickering: that depends
09:47:35 <Welkin> what do you mean?
09:47:45 <Welkin> is ti server rendered?
09:47:49 <Welkin> or client rendered?
09:48:01 <mpickering> Well I haven't written a line of the front-end yet so it could be either
09:48:14 <dolio> I don't have an opinion.
09:48:20 <Welkin> well, if it is a website, it should be server rendered by default
09:48:29 <Welkin> if it is a web "app" it could be either
09:48:44 <glguy> dolio: How strongly do you not have an opinion?
09:48:46 <mpickering> dolio: Do you have any examples of code for vector-algorithms which show bad peformance due to lack of inlining/specialisation?
09:49:13 <int-e> what is wrong with plain html with lots of blink tags and animated gifs... ;-)
09:49:32 <monochrom> blink and animated are what's wrong :)
09:49:34 <Welkin> fo server rendered, I like shakespeare templates
09:49:39 <mpickering> All I wanted was one opinionated person to tell me what to do :*
09:49:39 <Welkin> you could also use blaze-html directly
09:49:46 <Welkin> (or lucid)
09:49:52 <int-e> mpickering: okay, use plain html!
09:49:59 <mpickering> lol thanks
09:50:26 <monochrom> mine has plain html, non-blink tags, and unanimated gifs. for example http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon
09:50:29 <dolio> mpickering: You mean, failing to inline within the library, or failing to inline the whole algorithm?
09:50:54 <mpickering> dolio: I don't know. Edward mentioned in a comment that I should look at examples from that library to see where GHC did a poor job optimising
09:52:05 <dolio> Well, for instance, if you take one of the big functions that's paramaterized by an ordering function, and remove the inline pragma, it will probably get much slower.
09:52:23 <monochrom> I strongly believe in static web pages.
09:52:37 <mpickering> that seems like the expected behaviour?
09:53:58 <mpickering> if you want to ensure cross module specialisation then you need at least an inlinable pragma
09:54:16 <dolio> This isn't cross-module. It's within a single module.
09:54:44 <dolio> I mean, it effectively won't get inlined into other modules, either.
09:54:59 <dolio> Because only the front-end function would get inlined.
09:55:11 <dolio> I don't know what you're looking for then, though.
09:55:44 <dolio> Having to inline all your (very large) code into its use site or suffer orders of magnitude worse performance seems bad.
09:56:56 <mpickering> that is true
09:57:24 <dolio> Not that I have a solution.
09:57:34 <mpickering> it seems to me that the performance hit comes from not specialising rather than not inlining
09:57:37 <dolio> Outside of radically reimagining how GHC works.
09:57:49 <dolio> Like, Ed's got his tracing jit idea, which effectively inlines at runtime.
09:58:04 <dolio> mpickering: you have to inline to specialize to a function.
09:58:20 <mpickering> This is what I am trying to understand  - https://youtu.be/YTaNkWjd-ac?t=185
09:58:36 <mpickering> You have to inline the class methods 
09:59:49 <mpickering> so especially the comment at 4:05 about the inliner giving up on recursive functions confuses me as GHC specialises recursive functions just fine
10:00:36 <dolio> Yeah, specializing a function should handle specializing the code to the contents of dictionaries.
10:00:58 <mpickering> then there isn't an example which performs badly in the the talk, so I asked him on reddit and he pointed me to vector-algorithms
10:01:20 <mpickering> which is how this conversation started
10:01:45 <dolio> Although the implementations of certain things is still sub-optimal, probably.
10:02:48 <dolio> Like, if you do `get >>= put` in `WriterT w (ReaderT r (State s a))`, it's probably worse than `lift . lift $ get >>= put`.
10:04:01 <dolio> mpickering: There was also a release of GHC where stuff I had marked inlinable just got a ton slower, and I couldn't figure out why, so I had to start inlining it.
10:04:19 <dolio> Which was actually worse that it was with inlinable working.
10:04:27 <mpickering> interesting...
10:04:31 <mpickering> as in, the core actually got worse?
10:04:45 <dolio> I should probably check if I can move it back to inlinable if I haven't.
10:05:26 <dolio> mpickering: I don't remember exactly what happened, but doing `sort` was far slower, presumably because it wasn't specializing.
10:06:16 <mpickering> sounds strange
10:11:21 <mpickering> them two examples you gave look like they optimise to the same function
10:11:30 <mpickering> but I'm never confident reading core, there is a lot of noise
10:13:04 <monochrom> there is a whole slew of -dsuppress-* to reduce noise. the entry level one is -dsuppress-all (but it isn't really all)
10:15:52 <mpickering> didn't know that one, thanks monochrom 
10:16:02 <ben> Why does ghc need rewrite rules? Can't it figure out that sort of stuff on its own, like some inlining stuff or w/e?
10:16:29 <monochrom> can it figure out "map f . map g = map (f . g)" on its own?
10:17:10 <monochrom> I can, but it took me 35 years of growing up to learn it.
10:17:50 <ben> seems fairly obvious, idk
10:17:53 <ben> im not a compiler
10:18:00 <merijn> ben: It can do a bunch of stuff like inlining
10:18:24 <merijn> ben: But most programmers want more reliable ways to make the compiler do what they want without crossing their fingers and hoping for the best
10:19:04 <monochrom> "map f . map g = map (f . g)" cannot be figured out by just inlining finitely many times.
10:19:50 <monochrom> You actually need to guess an induction hypothesis so you can finish the induction proof.
10:20:58 <monochrom> Similarly for those "foldr/build" fusion rules or whatever they're called.
10:21:21 <monochrom> All of which are obvious to sufficiently smart mathematicians to be sure.
10:21:41 <monochrom> But we don't have a smart mathematician's brain taken out and transplanted to GHC.
10:22:15 <monochrom> Humans overestimate and underestimate their own intelligence at the same time.
10:22:47 <ongy> I think they mainly underastimate the ability to skip *trivial* steps
10:22:55 <ongy> where trivial is highly subjective
10:23:21 <monochrom> underestimate: they think that advanced math is so easy for them, computers should be able to do it by now
10:23:37 <monochrom> overestimate: they think they can solve the halting problem whereas the computer can't.
10:24:39 <dolio> mpickering: The building blocks in that example might not be big enough.
10:25:02 <dolio> What if get and set were things that didn't inline because they're so small?
10:25:08 <int-e> monochrom: The last time I checked the Goldbach conjecture was still open. ;-)
10:26:04 <mpickering> I don't know, seems like this is a different problem to the one mentioned in the talk though
10:26:41 <mpickering> I'm trying to get some facts to add to the discussion because it seems like it would benefit improving things
10:26:57 <mpickering> (as in, having facts will make fixing things easier)
10:31:05 <dolio> mpickering: I don't know about the talk. The sort of thing Ed's mentioned to me before is that writing a chunk of ST code and then lifting it into `FooT (BarT (BazT (ST s))) a` tends to be better than writing the chunk of code generically and specializing it to the big monad.
10:31:48 <asdf11111> Hi, so if I have several type classes which all have the same exact function (except a different number of type variables), is there a way to DRY it out? In the case where there are extra type variables, they are always ignored.
10:32:03 <asdf11111> e.g.
10:32:14 <asdf11111> class (Enum a) => OneTypeVar a where
10:32:14 <asdf11111>   list :: [a]
10:32:15 <asdf11111>   list = [toEnum 0..]
10:32:36 <asdf11111> and then more classes such as
10:32:39 <asdf11111> class (Enum a) => TwoTypeVar a b where
10:32:40 <asdf11111>   list' :: [a]
10:32:42 <dolio> So even though you can abstract over ST-like monads, it can be worthwhile to write directly in ST and then lift, assuming your algorithm doesn't require anything but the ST stuff.
10:33:23 <dolio> And that can in principle apply to other things, too.
10:33:26 <lyxia> asdf11111: It's better to use lpaste.net when your snippet is more than 2 lines long.
10:33:35 <merijn> asdf11111: What's the 'b' doing there?
10:33:48 <merijn> asdf11111: It's not used in list', so that example can't possibly ever work
10:34:56 <asdf11111> merijn: the b is used in other functions in the class
10:34:57 <lambdafan> I'd like to use conduits to (1) read a binary file in chunks (2) take an md5 of that chunk (3) write the chunk to a file (4) write md5 to file. I'm looking at Data.Conduit.Binary. Do I want sourceFileRange for this task?
10:35:17 <merijn> asdf11111: Yeah, that is not going to work, you will never be able to use list'
10:36:20 <asdf11111> merijn: it does work in the actual code, I just gave that as a simplified example of my problem :)
10:37:51 <merijn> asdf11111: Then you should use lpaste to show a bigger amount of code
10:38:53 <asdf11111> http://lpaste.net/8268113628813590528
10:40:10 <asdf11111> so perhaps the example was exactly not on point, but I'm just trying to give the jist :)
10:40:12 * hackagebot pretty-types 0.2.3.0 - A small pretty printing DSL for complex types.  https://hackage.haskell.org/package/pretty-types-0.2.3.0 (SvenHeyll)
10:40:34 <asdf11111> not exactly*
10:40:43 <merijn> asdf11111: You could simplify sigma, but if there's other functions as well then that might not really help
10:41:28 <glguy> asdf11111: You probably don't need the class to be parameterized over all 3 of those type variables and might not even need to define a typeclass at all
10:42:16 <asdf11111> glguy: why not? Otherwise I need to define the same function for NFA, DFA, ENFA, PDA, GNFA, etc.
10:42:19 <merijn> "sigma :: proxy s -> Set s; sigma _ = [toEnum 0...]"
10:42:37 <glguy> asdf11111: No, it's not the case that you necessarily need a typeclass to use the same function at many types
10:42:38 <merijn> asdf11111: Because one implementation suffices for all of them? :)
10:43:06 <glguy> asdf11111: The fact that you're able to provide the implementation at the class definition is the hint for that
10:43:21 <glguy> rather than having to provide separate implementations at each instance definition
10:43:22 <asdf11111> merijn: whoaaa, that just might be exactly what I was looking for!!! Thanks!
10:44:01 <asdf11111> glguy: I see, I felt like there must be a better way, that's why I'm asking :D
10:44:29 <merijn> asdf11111: That version only works if you can rearrange the type arguments to have 's' last, but yeah
10:46:05 <Wizek_> With TemplateHaskell/QuasiQuotation, would you say it is possible to evaluate some values at compile time? E.g. `let a = [1,2] in [f| a |]` to get the values 1 and 2 somehow. AFAIK the most I can do is manipulate the AST, but not the values, since that would require executing the program at compile time.
10:46:08 <asdf11111> merijn: will I need some sort of type-level flip to make it work as is, or ?
10:47:17 <merijn> asdf11111: How many variations do you have?
10:47:59 <asdf11111> RegExp s, DFA q s, PDA q s z, etc.
10:48:20 <glguy> Wizek_: You can execute parts of the program at compile time in order to generate the AST that is spliced into the program.
10:51:51 <asdf11111> I suppose I could rearrange the s to always be last though
10:51:59 <asdf11111> thanks merijn and glguy 
10:52:00 <lpaste> xuxu pasted “Stuff in the book, but not in the web version of Learn You a Haskell” at http://lpaste.net/183949
10:55:32 <xuxu> i'm finding this bit of the book a little confusing
10:55:47 <xuxu> mulling it over, hoping to not ask too many questions in here :)
10:56:20 <lyxia> xuxu: this is a great place to ask questions
10:56:33 <xuxu> lyxia: yes, but i ask a lot of them :P
10:57:45 <ongy> so do I
10:58:00 <cocreature> xuxu: if people don’t want to answer or ask questions they wouldn’t be here :)
10:58:24 <Guest623> Using regex-tdfa "0" =~ "[:digit:]" :: Bool gives False. It's my first time using regexes in Haskell, am I missing something?
11:00:44 <xuxu> :t filter
11:00:46 <lambdabot> (a -> Bool) -> [a] -> [a]
11:01:11 <xuxu> > filter isDigit "123-4567"
11:01:13 <lambdabot>  "1234567"
11:02:14 <xuxu> in the paste, let intBook = Map.map string2digits phoneBook is a bit confusing to me
11:02:26 <ongy> hm, is map in scope?
11:02:30 <ongy> :t Data.Map.map
11:02:32 <lambdabot> (a -> b) -> M.Map k a -> M.Map k b
11:02:58 <xuxu> i don't understand how it knows to convert the phone number representations
11:03:11 <ongy> xuxu: that's the string2digits function
11:03:14 <xuxu> [("name", "123-4567")]
11:03:16 <ongy> it's defined somewhere in what you have pasted
11:03:21 <xuxu> yes
11:03:31 <xuxu> string2digits = map digitToInt . filter isDigit
11:03:53 <xuxu> i understand that function
11:04:06 <xuxu> but that function takes a String
11:04:19 <xuxu> we are feading in a phoneBook
11:04:23 <xuxu> which is a Map.Map
11:04:35 <ongy> the map from Map.map has the type lambdabot posted. not the usual Data.List map
11:04:45 <lyxia> Guest623: could it be "[[:digit:]]"
11:05:17 <Guest623> lyxia: oh, thank you!
11:05:22 <xuxu> oh, for each item in the map it access, it gets the value, i.e. the phone number
11:05:36 <Guest623> lyxia: But isn't [:digit:] posix?
11:06:15 <xuxu> :t Data.Map.mapKeys
11:06:17 <lambdabot> Ord k2 => (k1 -> k2) -> M.Map k1 a -> M.Map k2 a
11:06:24 <xuxu> @src Data.Map.mapKeys
11:06:25 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:06:32 <lyxia> Guest623: it seems [:digit:] is the name of the character class, but it musst be used within a bracket expression, leading to these two pairs of brackets.
11:06:44 <Clint> correct
11:06:56 <Xnuk> @hoogle Data.Map.mapKeys
11:06:59 <lambdabot> Data.Map.Lazy mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
11:06:59 <lambdabot> Data.Map.Strict mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
11:06:59 <lambdabot> Data.Map.Lazy mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
11:07:52 <Guest623> lyxia: oh, okay, i'm used to using the \d shorthand of python
11:08:17 <geekosaur> you may want one of the pcre bindings instead of posix then
11:08:57 <Guest623> yeah, maybe
11:09:06 * xuxu is trying to figure out how to get at the keys of the map
11:10:10 <Guest623> @hoogle Data.Map.keys
11:10:10 <lambdabot> Data.Map.Lazy keys :: Map k a -> [k]
11:10:10 <lambdabot> Data.Map.Strict keys :: Map k a -> [k]
11:10:10 <lambdabot> Data.Map.Lazy keysSet :: Map k a -> Set k
11:10:33 <ongy> xuxu: have you seen Data.Map.keys?
11:10:47 <xuxu> excellent! thanks ongy, that worked
11:12:14 <xuxu> i feel that i want to know more about Data.Map then what is presented here. time to use tab completion in ghci 
11:12:58 <ongy> xuxu: https://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map-Lazy.html is what I use
11:13:45 <xuxu> how does everyone here access the source code you are interested in understanding? i don't think if i ever start using haskell for work that i can come in here everyday and possibly annoy this list by asking lambdabot for source code :)
11:13:57 <geekosaur> lambdabot lies anyway
11:14:10 <xuxu> do you all just type in, e.g. "Data.Map.keys hackage" into google?
11:14:11 <ongy> there's `cabal get'
11:14:33 <xuxu> ongy: that's neat
11:14:35 <ongy> which get's you the package source, if you need it offline
11:14:36 <geekosaur> (@src is a manually curated database that was built initially from the compiler-independent implementations in various old versions of base)
11:14:52 <ongy> or if I want to look at something I just go to hackage. it works good enough
11:15:00 * geekosaur generally uses hayoo or goes straight to hackage, and uses the Source links at the right (or at the top for the whole file)
11:15:18 <ongy> oh wow, sounds terrible
11:16:42 <monochrom> I start at file:///home/trebla/.cabal/share/doc/x86_64-linux-ghc-7.10.3/index.html and browse.
11:16:43 <geekosaur> well, it's useful if you want a reference or tutelary implementation. useless if you want the one actually used by ghc
11:17:37 <monochrom> people spend nine lives browsing the web, and not even one second browsing their own hard disks.
11:18:03 * ongy has 3 linux kernel checkouts for searching...
11:18:18 <ongy> if you ever get stuck in a train, you learn to use local checkouts
11:18:38 <xuxu> geekosaur: hayoo links to source seem to be broken
11:18:53 <xuxu> is Sebastian Philipp here, maybe we can let him know
11:19:12 <geekosaur> not impossible, hayoo is under active development and breaks every so often
11:19:18 <geekosaur> seemed to be working for me last night though
11:19:27 <xuxu> guess i could just open an issue on https://github.com/hunt-framework/hayoo/issues
11:20:40 <xuxu> thanks for the feedback
11:20:49 * xuxu idles 
11:22:15 <ryandv> @pt \f g h a -> (f a) && (g a) && (h a)
11:22:15 <lambdabot> (. liftM2 (&&)) . (.) . liftM2 (&&)
11:22:19 <ryandv> blech
11:47:13 <the_2nd> Any way to define a type like : (wont compile)
11:47:14 <the_2nd> type InputProducer = (PaletteProducer b) => a -> b
11:47:34 <the_2nd> "anything to certain class"
11:49:11 <xuxu> https://wiki.haskell.org/Bottom maybe?
11:50:12 <geekosaur> "anything to certain clss" sounds dubious, but you are probably looking at existential types or equivalently GADTs
11:50:51 <the_2nd> well, let's say I have foo and bar which both are instances of C
11:51:14 <the_2nd> and want to define a type as "from any input to something which is a C"
11:51:27 <fr33domlover> the_2nd, what if 'a' and/or 'b' are type parameters of InputProducer?
11:51:39 <fr33domlover> also perhaps rank N types are related?
11:52:36 <fr33domlover> the_2nd, also, how do you write something using that type?
11:52:52 <fr33domlover> e.g. how would you write a function which has that type
11:52:59 <puregreen> the_2nd: to “something” or to “anything”?
11:53:10 <fr33domlover> without knowledge about the type, what can you do with it at all...
11:53:18 <puregreen> e.g. I often use “type IO_ a = MonadIO m => m a”
11:53:24 <the_2nd> fr33domlover, I want both a -> foo and a -> bar be correct signatures
11:53:45 <the_2nd> so I could make another function of e.g.
11:53:45 <geekosaur> without knowing what a is
11:53:47 <geekosaur> good luck
11:54:10 <fr33domlover> the_2nd, but how can you write a function if the param type isn't known, and is instead some generic"a"
11:54:17 <fr33domlover> * generic "a"
11:54:29 <geekosaur> (you can in fact do that, but you can't do much of anything with the result so it's useless)
11:54:35 <the_2nd> Int -> foo  
11:54:50 <fr33domlover> you need a concrete type for pattern matching, or at least class instance so you can apply its "methods" etc.
11:55:01 <fr33domlover> otherwise... what can you do with the value
11:55:24 <puregreen> the_2nd: maybe you want this? https://wiki.haskell.org/Existential_type#A_short_example
11:57:01 <puregreen> except that “a -> foo” is indeed weird because the only function that can produce something concrete from *any input whatsoever* is either a constant function or bottom
11:57:47 <the_2nd> puregreen, this would just be a named type
11:57:52 <the_2nd> no concrete signature
11:58:10 <the_2nd> e.g. type a -> a
11:58:15 <the_2nd> Int -> Int is valid
11:58:20 <the_2nd> Int -> Double not
11:58:29 <nshepperd> the ExY problem: you actually want to solve Y, but instead you ask about existential types
12:00:19 <puregreen> the_2nd: I confess that I don't understand what you tried to explain. Perhaps you could provide an example of code in which you want to use it? Or try to explain it from the beginning?
12:00:22 <nshepperd> the_2nd: how do you intend to use this
12:01:44 <the_2nd> on it
12:06:34 <the_2nd> yeah I think it's not gonna work
12:14:54 <parsnip> i am going to take a list of 6000 ints, and consider their product space and sum over them, like (x, y) -> x + y. so about 40,000,000 sums. my first messy attempt (using e.g. Data.Map) ran in about 10 seconds. i think i should try using Set, but if that isn't fast enough, i might try the unboxed mutable vector. is my thinking okay here? 
12:19:40 <prsteele> parsnip: you want to sum over the cartesian product of those integers?
12:21:15 <parsnip> prsteele: yes, but i will try to limit to upper half triangle. but since that might only cut time in half, it's not even a priority. i'd rather lean towards elegance, clean code, and the main stabs at efficiency. 
12:22:17 <parsnip> now i'm thinking set is fine, since i can probably stream the cartesian product in. still, when i calculate the lenght of the generated list, it still takes some seconds. if i feed it to set, will haskell optimize? 
12:23:23 <prsteele> I still think I'm missing something -- if your list is [1, 2, 3], you want 1 + 1, 1 + 2, 1 + 3, 2 + 2, 2 + 2, 2 + 3, 3 + 3 summed?
12:23:31 <merijn> parsnip Try IntSet?
12:23:39 <parsnip> > length $ liftA2 (+) [0..6000] [0..6000]
12:23:44 <merijn> parsnip: And/or IntMap?
12:23:45 <lambdabot>  mueval-core: Time limit exceeded
12:23:53 <merijn> parsnip: Those are considerably faster than regular Map
12:24:07 <parsnip> merijn: okay, will try those. 
12:24:36 <parsnip> but still, before i put those anywhere, wouldn't the time still be effected by same thing calculated above? 
12:25:05 <parsnip> i guess i can try, at least i have some minimal example now. 
12:25:17 <merijn> parsnip: Yes, not, maybe. Depends what's slow
12:25:26 <merijn> parsnip: Whether it's the computation, lookups in the map or both
12:25:33 <merijn> parsnip: IntMap will reduce the lookup time
12:25:44 <prsteele> parsnip: if you're doing this to learn data structures keep going, but if you are actually just summing I think you can get a more closed-form expression
12:26:17 <parsnip> prsteele: no, imagine the 6000 are indexing some numbers with no closed form :)
12:26:29 <kuznero> Hi All!
12:26:32 <parsnip> prsteele: https://projecteuler.net/problem=23
12:27:00 <kuznero> There is a problem I cannot solve... I hope somebody could help me with that. I cannot correctly read utf-8 file on windows. It works well on linux, but never on windows... It simply does not read special symbols like æ, ø, å (in this particular case), instead it reads something unreadable. Can anybody help?
12:27:06 <parsnip> but the [0..6000] i just came up with makes it easier to think about, so now there's hope for me yet. 
12:27:34 <parsnip> kuznero: do you have a hex reader? 
12:27:43 <parsnip> kuznero: or do you use emacs? 
12:27:49 <kuznero> parsnip: I use vim
12:27:58 <kuznero> it says utf-8 [linux]
12:28:09 <kuznero> It does so on windows too
12:28:44 <parsnip> kuznero: i'm some newb just offering half ideas, but i wonder if the actual file is encoded utf-8 or not. if you use a hex reader, that might give away. i don't know if emacs can tell you what the codepoints are or whatever. 
12:28:45 <geekosaur> chcp 65001
12:29:00 <parsnip> kuznero: oh, yeah might be more a haskell problem, i'll bow out now. 
12:29:35 <geekosaur> windows doesn't have a way to set a locale so the code page is used as a proxy. the default code page is understood to be iso8859; setting the unicode code page switches the inferred locale charset to utf-8
12:29:39 <kuznero> parsnip: I am pretty sure it is utf-8
12:30:07 <prsteele> parsnip: the only import I have for problem 23 is Data.Vector.Unboxed and runs in about 0.5s, so that could be a way to go
12:30:37 <parsnip> prsteele: ah, okay, i will try both as a learning exercise, thanks. 
12:30:41 <kuznero> geekosaur: how do I programmatically set it to the code page that will result in locale charset utf-8?
12:31:43 <Cartesianfox> Hi there!
12:31:48 <geekosaur> I suspect you have to set it before running the program... but https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/Win32-2.3.1.1/System-Win32-Console.html#v:setConsoleCP
12:32:05 <prsteele> hello Cartesianfox 
12:32:23 <geekosaur> (using the console code page for files is wrong, but no more wrong than the posix equivalent, just differently wrong :)
12:32:47 <geekosaur> it should be a file attribute but filesystems don't currently support that in a useful way :/
12:35:16 <kuznero> <geekosaur>: that is strange... file attributes should be irrelevant, it is the content of the file that matters, right? And I should be able to instruct `Prelude.readFile` that I am reading UTF-8 for example or any other encoding... But what I cannot understand now is how `Prelude.readFile` can be working differently on Linux and Windows... ?
12:36:05 <geekosaur> it's not like text files have standard headers saying whattheir content is/ you can try to infer it but you'll often be wrong
12:36:17 <xuxu> what is the term for an import that is not explicit or qualified?
12:36:26 <xuxu> e.g. import Very.Special.Module
12:36:38 <geekosaur> and it is different because modern linux defaults to a utf-8 locale but windows console still defaults to an iso8859 codepage
12:37:00 <kuznero> <geekosaur>: I got it now, thanks!
12:37:02 <geekosaur> and some programs break if you switch it (I;ve been told windows git doesn't work right with chcp 65001)
12:37:48 <geekosaur> file encoding is a perennial pain point :(
12:39:19 <geekosaur> someday the folks who develop OS and toolkit APIs will figure out that encoding needs to be a standardized attribute of a file. maybe in a couple decades they'll finally get it right. (modern filesystems already have appropriate APIs for this, there's just nobody using them. and it's pointless if ghc defines one and nobody else uses it)
12:39:32 <kuznero> <geekosaur>: surprizingly (or not) Windows 10 is still having default code page that is not UTF-8 :(
12:39:48 <geekosaur> like I already said, some programs break if you change it
12:40:04 <kuznero> sad story
12:40:15 * hackagebot gloss-juicy 0.2.2 - Load any image supported by Juicy.Pixels in your gloss application  https://hackage.haskell.org/package/gloss-juicy-0.2.2 (AlpMestanogullari)
12:42:00 <f-a> uhhh, I have a line like this "alpha, beta :: [Int]", but instead being just 2 functions, there are 20 of them
12:42:24 <f-a> is there a way to write this, multine (not to exceed 80 chars)?
12:42:40 <f-a> with a string, you would go \ \n \
12:42:43 <geekosaur> you can force an encoding from haskell, but the api is somewhat annoying. https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/GHC-IO-Encoding.html
12:43:02 <geekosaur> f-a, it should just work
12:43:34 <f-a> oh, indentation!
12:43:36 * f-a facepalms
12:43:36 <geekosaur> a, b,\n  c, d, e,\n  f, g, h :: Whatever
12:43:38 <kuznero> <geekosaur>: There is even an open ticket on this it seems... https://ghc.haskell.org/trac/ghc/ticket/4471
12:43:59 <kuznero> reported 6 years ago
12:44:02 <geekosaur> trailing comma might also be enough
12:44:42 <geekosaur> kuznero, like I said, perennial pain point
12:44:45 <f-a> thanks geekosaur 
12:44:54 <f-a> trailing comma doesn't seem enough
12:44:56 <geekosaur> people ignore locale / encoding until it bites them
12:47:04 <geekosaur> and get angry if you try to make them think about it; everyone thinks it should Just Work, nobody wants to do what's needed for it to Just Work, and it will never Just Work without additional information (like storing the encoding with the file) because you cannot reliably distinguish utf8 from iso8859 without actually knowing what the correct data should look like --- which for text usually means understanding the words in whatever language th
12:47:04 <geekosaur> ey might be in
12:47:27 <geekosaur> sorry, that kind of AI does not exist and doesn't look close
12:48:41 <kuznero> geekosaur: agree. thanks for clarifications!
12:58:46 <f-a> every release of my program I modify the release number (e.g.: 4.0.1.2) in: the program.cabal file, my Main.hs (--version) and other parts too, what's a clever way to have just one place where it is modified?
12:59:30 <alercah> you should store it in a constant somewhere in code if you reference it in multiple places
12:59:44 <alercah> other than that, not sure
13:00:04 <f-a> alercah: is a cabal file considered 'code'?
13:00:26 <sm> hm, I find most of the clever ways cause trouble for something or other
13:00:41 <f-a> hah, so you go manually for hledger, sm ?
13:00:42 <jmcarthur> f-a: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
13:01:44 * alercah quit reading as soon as she saw autoconf
13:02:14 <jmcarthur> alercah: That's a different section
13:02:27 <f-a> sweet, jmcarthur
13:02:32 <sm> f-a: IIRC I write it in .version, and make setversion inserts that into a bunch of version-sensitive files
13:04:05 <f-a> sensible, is setversion a unix util?
13:04:24 <sm> it's a rule in hledger/Makefile 
13:04:31 <f-a> ok
13:05:16 <sm> I see it only updates the package.yaml files (I use hpack), which takes care of the cabal files
13:05:40 <parsnip> yep, still takes some 10 seconds, time to try Vector
13:05:42 <parsnip> IS.size $ IS.fromList $ liftA2 (+) [0..6000] [0..6000]
13:05:49 <sm> I also have the version hard-coded in a macro doc/lib.m4 used in all docs
13:06:49 <sm> I stopped using the cabal thing jmcarthur mentioned because it made some things more fragile
13:07:30 <kuznero> geekosaur: as you said changing parent console process as `cmd.exe /K chcp 65001` and then starting my application actually works. Windows sucks yet another time...
13:07:54 <the_2nd> parsnip, just to make sure: enabled -O2 etc?
13:08:22 <parsnip> the_2nd: no, not compiled, just interactive. i would think i could get my time down in interactive? 
13:08:24 <sm> f-a: ah, and I also define VERSION with CPP
13:08:36 <f-a> what is that last one used for,  sm
13:08:52 <the_2nd> parsnip, compiled with O2 should be way faster than interpreted
13:08:54 <sm> hledger --version, eg
13:09:07 <f-a> I see
13:09:21 <parsnip> the_2nd: could using Vector be way faster even in interactive? 
13:09:41 <sm> I used to set that CPP definition in the cabal files, but that seems to have stopped when I moved to hpack
13:09:47 <parsnip> the_2nd: and/or, can i write that IS expression in some way that is faster in interactive/ 
13:09:54 <sm> in short: I'm all over the place. Hope it gives you some ideas
13:10:31 <f-a> since I have just 3 places, I'll keep it manual for now
13:11:02 <parsnip> the_2nd: i'm going to go to see if it's faster i guess, i really should finally give Vector a try. will be back on in a while. 
13:11:44 <the_2nd> parsnip, at least in c++ I'd think vector should be fastest for this
13:11:50 <the_2nd> also consider parallelism
13:12:05 <sm> f-a: congrats on lentil 1.0 btw, I want to run it again one of these days
13:12:55 <f-a> sm: thanks. it is a small utility but I receive patches/feedback/thanks yous monthly, so I am quite proud
13:13:32 <f-a> now I would like to enter ifcomp with an haskell program
13:13:34 <sm> it's not easy to build with stack, FYI
13:13:49 <f-a> ouch, not even iwth the new stack.yaml?
13:13:57 <jmcarthur> parsnip: What problem are you actually trying to solve?
13:13:57 <f-a> I asked a stacker to try it
13:14:23 <sm> oh nice. That probably works great. But it's not easy to just stack install it without the project source
13:15:00 <sm> it's out of date in stackage, and an explicit "stack install lentil-1.0.2.0" doesn't find an install plan
13:15:36 <sm> just FYI, some would-be users will try to install that way
13:15:36 <f-a> yeah, I stupidly upgrated to ghc-8 and I don't think as now it works with nightlies, even.
13:15:51 <parsnip> jmc https://projecteuler.net/problem=23 make my solution about ten times faster. 
13:16:01 <f-a> so the suggestion is to get it on stackage, sm ?
13:16:23 <parsnip> jmct: or jmcarthur ? my phone app makes them shorter
13:17:01 <parsnip> ah, extended nicks, twas jcma
13:17:03 <sm> f-a: yes, the most ideal would be to get the latest version in both stack lts and nightly
13:17:13 <sm> s/stack/stackage/
13:17:14 <glguy> f-a: cabal install lentil -- seems to do just fine, at least
13:17:18 <parsnip> jmcarthur: ^ :)
13:18:01 <f-a> glguy: thanks
13:18:11 <jmcarthur> parsnip: And you have a further constraint that it has to be fast in ghci, not just in compiled code?
13:18:41 <jmcarthur> parsnip: (ghci and ghc -O2 perform *very* differently)
13:18:54 <f-a> sm: thanks for the feedback, I'll have to wait until optparse applicative 0.13 is in nightly, but then I'll plan to add it
13:19:17 <sm> cool
13:19:21 <kadoban> Wait, what? lentil is in stackage, LTS and nightly, it's just a pretty old version.
13:19:40 <f-a> kadoban: no more
13:20:16 <kadoban> Oh I see, it's in a really old nightly. Failed to look at the date
13:20:51 <taksuyu> Oh wow this is really cool and just what I was looking for :3
13:21:20 <Squarism> Ok.. wierd question. I have this "problem". I have an set of variables with relations like "ask for A and B. if A == B then ask for a value of C. ..." and so it continues with sums, relational ops.. types are simple literals plus set of enums. I wonder if theres some smart way of creating a DSL that can both A. execute the "function :: Input -> Set Variable". B. Provide value dependencies :: Map Variab
13:21:20 <Squarism> le [Variable] 
13:22:07 <Squarism> dependencies :: Map Variable [Variable] 
13:22:08 <Squarism> even
13:23:40 <Squarism> "function"'s result : Set Variable - is the collection of all "ask X"
13:25:09 <Squarism> Arrows?
13:27:29 <jmcarthur> Squarism: What is the thing you are having trouble with? Modeling a session? Managing the variables?
13:28:36 <jmcarthur> Squarism: Do you need to be able to inspect the dependency tree separately from executing the program?
13:28:47 <Squarism> exactly
13:29:03 <jmcarthur> Squarism: Are all constraints of the form A==B?
13:30:05 <Squarism> they could be simple expressions of simple sorts... like A+B + C < G && C >= A
13:33:15 <jmcarthur> I think I need a little more help here before I can suggest anything. Suppose you have such a DSL which can be used to construct values of type MyDSL. What functions can you apply to MyDSL to "interpret" or "inspect" it?
13:33:22 <jmcarthur> *to a value of type MyDSL
13:33:44 <jmcarthur> s/can you/do you need to be able to/
13:34:41 <Squarism> questionsToAsk :: Map Variable Value -> Set Variable PLUS dependencies :: Map Variable [Variable]
13:35:02 <parsnip> jmcarthur: okay, thanks, i was just being lazy will compare compiled as well :)
13:35:10 <Squarism> --> jmcarthur
13:35:46 <jmcarthur> Squarism: Do you mean you need   (questionsToAsk :: MyDSL -> Map Variable Value -> Set)  and  (dependencies :: MyDSL -> Map Variable [Variable])  ?
13:35:54 <Squarism> exactly
13:37:08 <Squarism> if it wasnt that i needed the depencies i could just do with pure haskell
13:37:14 <jmcarthur> What is Set, exactly?
13:37:35 <jmcarthur> And what is Map Variable Value supposed to represent?
13:38:08 <jmcarthur> So far nothing here seems crazy. I just need more information.
13:38:55 <jmcarthur> Ah, I think I understand.
13:39:01 <Squarism> jmcarthur.. http://lpaste.net/184079
13:39:20 <jmcarthur> Set is meant to be the set of questions to ask. Map Variable Value is meant to be the questions that have already been asked and their answers. Is that correct?
13:39:24 <Squarism> a sort of brainstorm on proper basic types
13:39:44 <Squarism> exactly
13:41:09 <jmcarthur> Okay, and the Map Variable [Variable]... Supposing it has some 'key' mapping to 'variables', does that mapping mean that if I have 'key' then I need to ask 'variables'?
13:41:41 <Squarism> jmcarthur, its what i call VKey in the paste i sent
13:42:37 <jmcarthur> I'm not sure that answers my question.
13:42:55 <jmcarthur> How am I supposed to interpret the result of the dependencies function?
13:43:50 <jmcarthur> Sorry I've been not actually giving you answers to your question so far. I feel like I would just be very likely to say something unhelpful without understanding the answers to my questions.
13:44:03 <Squarism> ok.. ill try
13:45:19 <jmcarthur> I have part of an answer already formed in my mind though.
13:46:10 <jmcarthur> But it may not work for the dependencies function.
13:46:27 <Squarism> The "dependencies" Map X Ys - function mean all variables references (Ys) in the evaluation path that leads to "ask X" 
13:46:57 <jmcarthur> Squarism: Ah, so it means X should only be asked if we already have answers to all of Ys?
13:47:10 <jmcarthur> Squarism: Oops
13:47:55 <jmcarthur> Squarism: I meant something slightly different. I forgot to consider conditionals. I take the mapping to mean that X *could* be asked after having asked all of Ys, depending on some condition on Ys. Is that correct?
13:48:26 <Squarism> "[ask A, ask B] ++ (if A > B then [ask C] else [])" would mean dependencies = Map [(C,[A,B], (A,[]), (B,[])]
13:48:51 <jmcarthur> Got it.
13:49:02 <jmcarthur> Let me write up my answer in code.
13:49:30 <Squarism> wow.. id be so happy to get some inspiration! Looking forward to it
13:50:18 <chsn> how do I tell stack: yo, dont use stack-lts-idris, use idris-0.12.2 -- I've already added it to extra-deps, but it seems like it's still using 0.11 (stack lts) instead of 0.12 (my choice)
13:51:00 <jmcarthur> Squarism: Oh, you might be underwhelmed.
13:52:21 <kadoban> chsn: Adding it to the extra-deps is the correct way. What leads you to believe it's not working?
13:53:08 <biscarch> Are there recommendations for crypto libraries? (specifically looking for incremental sha256)
13:53:51 <dmj`> biscarch: https://hackage.haskell.org/package/cryptohash-0.11.9/docs/Crypto-Hash-SHA256.html
13:53:54 <Squarism> jmcarthur, kudos if you could add a constraint that read of variables only can be done if they were asked - which is determined by the DSL, not the input (as in last example - A and B are allways asked, so their value can thus can allways be read and they determine if C can be read)
13:54:24 <biscarch> dmj` indeed, but the description lists it as deprecated
13:54:28 <chsn> kadoban: I'm getting a type error that indiceates it' slinked vs 0.11
13:54:43 <chsn> kadoban: is ther ea way to verify what it's linking against ?
13:55:36 <kadoban> chsn: 'stack list-dependencies' possibly? Not sure.
13:56:12 <chsn> kadoban: okay, it's linking vs 0.12.2
13:56:15 <chsn> maybe my bug is elsewhere
13:56:15 <chsn> thanks
13:56:54 <kadoban> chsn: If it's still confusing, make sure you're on recent stack, maybe there's some weird bug you'd be hitting, but I wouldn't think it'd be likely at all (this is pretty well used functionality)
13:58:43 <jmcarthur> Squarism: In writing this out, I discovered an inconsistency in the spec. The dependencies need a richer structure. It could be that there is more than one set of questions that need to have been answer to lead to asking another question.
13:59:00 <jmcarthur> Squarism: For example, If could be that the answer to D could lead to asking C as well.
13:59:06 <jmcarthur> Squarism: Regardless of A and B.
13:59:52 <jmcarthur> Squarism: I'm going to use a Set (Set Variable) instead of a [Variable] there.
14:00:11 <dmj`> biscarch: yea, but it also says its still production ready, but the new stuff will go into cryptonite. So, no harm currently using it from what I see
14:00:27 <biscarch> dmj` fair, thanks!
14:00:44 <Squarism> true, sure... would be nice to have all paths separete if possible
14:01:07 <Squarism> --> jmcarthur 
14:01:22 <jmcarthur> Squarism: What do you mean by "all paths separate"?
14:01:36 <jmcarthur> Oh I think I see what you mean.
14:01:51 <jmcarthur> I just mean the type you gave me is able to express an AND relationship, but not an OR relationship.
14:01:53 <Squarism> that was my interpretion of your change =D
14:02:38 <Squarism> jmcarthur, which are you refering to?
14:02:54 <Squarism> the conditionals? 
14:03:16 <jmcarthur> dependencies :: MyDSL -> Map Variable [Variable]
14:04:12 <jmcarthur> Squarism: Here's an example that your model would not capture:   "[ask A, ask B, ask D] ++ (if A > B then [ask C] else []) ++ (if p D then [ask C] else [])"
14:04:25 <Squarism> ah ok.. yeah exactly, so maybe Map Variable (Set (Set Variable))
14:04:28 <Squarism> is more correct
14:10:02 <chsn> kadoban: fixed it! problem was not stack; problem was something else stupid that I did; thanks!
14:10:49 <kadoban> Ah okay, glad you figured it out
14:11:25 <chsn> kadoban: yeah, there was Foo.foo and Bar.foo and they had different type sigs, and I thought I was importing one but was importing another, so yadda yadda yadda
14:12:12 <kadoban> Hehe, woops. Yeah happens :)
14:16:40 <Squarism> jmcarthur, it must be a tree right? With all "ask's" (leafts) on same level+above) sent to every subtree evaluation?
14:17:06 <jmcarthur> Squarism: Well, not as specified, it doesn't, I think.
14:17:26 <jmcarthur> Squarism: The Variables kind of label the nodes, so you can flatten the tree without losing its structure.
14:17:27 <Squarism> oh.. ok
14:17:39 <jmcarthur> Squarism: It's like an explicit pointer model.
14:17:58 <Squarism> oh.. ill wait for your idea then! =D
14:18:08 <jmcarthur> I'm getting close now. Some of it is a bit less satisfying than I hoped for, but I don't really want to spend toooo much time on it.
14:18:16 <xuxu> data Person = Person { firstName :: String, lastName :: String }; persons = [ Person "xu" "xu", Person "xiut" "xu" ]
14:18:41 <xuxu> is that a common way of storing a data types or are they typically in a map?
14:18:48 <xuxu> is that a common way of storing a data types or are they typically stored in a map?
14:19:35 <Squarism> jmcarthur, im glad for any inspiration!
14:21:38 <xuxu> how might i get the person whose first name is "xiut"?
14:25:44 <xuxu> neat!
14:25:55 <xuxu> filter (\p -> firstName p == "xiut") persons
14:26:23 <xuxu> 1. is there a way to eliminate the lambda and make this more point free
14:26:44 <xuxu> 2. is this the typical way of storing data types? when would you use a map?
14:27:29 <suzu> if you need fast lookup
14:27:33 <suzu> then you do not put all the things in a list
14:27:43 <xuxu> map is faster?
14:27:44 <suzu> as you gotta look at every element, each time you do a lookup
14:27:46 <suzu> yep
14:28:24 <xuxu> okay, i will play around with storing several Person types in a map and see if i can access it
14:28:43 <suzu> a map uses a tree to store it's data, under the hood
14:29:05 <suzu> if you have a million Persons in a list and you look for a specific person, you will look at all million Persons in the worst case when doing your search
14:29:09 <tnks> if someone can save me time looking up the spec, what should happen if a module exposes a function that's defined in terms of an unexposed type?
14:29:12 <suzu> however, with a map, you look at 20 Persons in the worst case
14:29:43 <tnks> I'm guessing you just get a compile error when you reference the type explicitly as a consumer.
14:29:53 <suzu> tnks: i believe it works fine
14:30:01 <suzu> but you can't use it.
14:30:01 <glguy> tnks: The function is exported and consumes of that module will find they can't write the type signature of that function
14:30:08 <suzu> yep ^
14:30:15 <tnks> glguy: perfect, that's what I'd expect.
14:30:21 <glguy> You should consider it an error to do that
14:30:25 <glguy> but it works
14:30:31 <tnks> thanks for accepting my lazy-web-gift-card.
14:30:37 <suzu> it would confuse consumers of your library
14:30:40 <suzu> it's not a good thing to do
14:30:44 <suzu> keep all your hidden stuff hidden
14:31:03 <tnks> suzu: sure, but I just want to know the rules
14:31:07 <suzu> ok :)
14:32:19 <xuxu> i can't directly translate my Person example into a map since a map will require me to associate a key with each value
14:32:47 <suzu> yes, maps are for looking up stuff with a key
14:32:50 <lpaste> jmcarthur pasted “For Squarism” at http://lpaste.net/184113
14:33:23 <jmcarthur> Squarism: I'm not really happy with how the conditionals came out, but doing it more nicely would take a lot more time, I think.
14:33:38 <bschwb> i
14:33:45 <jmcarthur> Squarism: Anyway, I believe if you play with the example, you will see the outputs you expected.
14:33:52 <Squarism> jmcarthur, thanks alot. Ill will inspect it right away
14:34:31 <jmcarthur> Squarism: My approach was to encode the data type to be literally identical to the spec you gave me.
14:34:59 <Squarism> jmcarthur, sounds good!
14:35:01 <jmcarthur> Squarism: That's why I asked what ways you needed to be able to inspect the result.
14:36:07 <jmcarthur> Squarism: So basically it is impossible for the data type to be wrong, since it's what you gave me. But it's possible for the functions I defined to be wrong just because I didn't ask for a very precise specification for them.
14:37:28 <Squarism> jmcarthur, i havent digested your solution in its entirety yet - doing it as we speak
14:37:48 <xuxu> filter (\p -> firstName p == "xiut") persons -- is it possible to eliminate the lambda from this?
14:38:10 <jmcarthur> @pl filter (\p -> firstName p == "xiut") persons
14:38:10 <lambdabot> filter (("xiut" ==) . firstName) persons
14:38:12 <tnks> I keep on finding myself annoyed that Haskell doesn't have something like "export everything except" syntax.
14:39:34 <glguy> xuxu: If you're running out of lambdas you can borrow some of mine
14:40:47 <jmcarthur> Squarism: The thing I find annoying about this implementation is that you have to repeat the inputs and outputs of the conditional.
14:40:59 <xuxu> thanks jmcarthur 
14:41:12 <Squarism> jmcarthur, that could be solved by a monad right?
14:41:20 <xuxu> glguy: thanks, i'll borrow lambdas from you one day
14:41:22 <jmcarthur> Squarism: Well, I guess the outputs aren't repeated, but the inputs still are.
14:41:41 <jmcarthur> Squarism: No, because you cannot interpret the structure of a monadic computation without being able to at least simulate execution.
14:41:57 <Squarism> oh
14:42:00 <Squarism> true
14:42:07 <jmcarthur> I think an Applicative thing could be done
14:42:19 <Squarism> well if it was a tree then?
14:42:37 <Squarism> eh.. well no
14:43:30 <chemouna> @faq Is Predicate a functor?
14:43:30 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:44:41 <glguy> chemouna: It's a contravariant functor: http://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Predicate
14:45:51 <chemouna> glguy: thank you
14:49:34 <Squarism> jmcarthur, I like your solution in its simpleness. 
14:49:37 <Squarism> jmcarthur, but what if "ask" was a done in a bind? Wouldnt that provide you with asked questions as input to a conditional (that would also added in a bind)? 
14:49:56 <jmcarthur> I don't understand your question.
14:50:15 <jmcarthur> This is not monadic, so I don't know what you mean by ask being done "in a bind".
14:51:45 <jmcarthur> Squarism: You mean (ask A >>= \a -> ask B >>= \b -> if a == b then ask C else return ()) or something?
14:52:01 <jmcarthur> Squarism: If so, how would we be able to see anything about B or C without having received an answer to A already?
14:55:28 <Squarism> jmcarthur, id hoped they could be added wo evalatuating them. As something Conditional [..dependencies/or meta expressions with digestable references] trueCase falseCase
14:56:22 <Squarism> I mean a type that represents a conditional
14:56:44 <EvanR> :t bool
14:56:45 <lambdabot> a -> a -> Bool -> a
14:57:03 <Squarism> nice
14:57:33 <jmcarthur> Squarism: Yeah, you could encode it that way if you'd like, but it still wouldn't yield a monad, at least not one that works the way we've been discussing so far.
14:57:42 <Squarism> jmcarthur, sorry.. i guess im not making myself clear. But what i mean is that bind would allways provide info on "current" scope
14:58:03 <Squarism> i guess i meant list monad
14:58:04 <Squarism> =D
14:58:12 <EvanR> o_O
14:58:15 <jmcarthur> You can certainly have a tree structured thing, but you would not be able to inspect it deeply the way you can with this model.
14:58:26 <Squarism> utilizing bind to pass current scope
14:58:34 <jmcarthur> Unless you don't go monadic.
14:58:55 <EvanR> hes gone full functor
14:59:00 <jmcarthur> Bind on trees usually is just substitution at the leaves, which is not what (I think) we're talking about.
14:59:02 * Clint claps.
14:59:26 <jmcarthur> :)
15:02:16 <Squarism> jmcarthur, oh well.. ill just to utilize what you have done and see what i can do with it. More !! than glad for your time and input.
15:02:26 <Squarism> -to
15:03:33 <chsn> how do I tell "cabal run" everythin gis an arg to the thin you run, not to "cabal run" ?
15:03:55 <koz_> Would I be right in assuming that unboxed vectors are not lazy?
15:07:38 <Cooler> regarding the state monad, if all you wanted was to compose functions that take and output state
15:08:31 <Cooler> could have something that does that instead of the state monad?
15:08:50 <glguy> You mean function composition? (.) 
15:09:30 <Cooler> something like |- :: (a, s) -> (a -> s -> (a, s)) -> (a, s)
15:09:48 <Cooler> |- (a, s) f = f a s
15:09:56 <glguy> :t flip curry
15:09:58 <lambdabot> a -> ((a, b) -> c) -> b -> c
15:10:25 <glguy> :t flip uncurry -- oops
15:10:27 <lambdabot> (a, b) -> (a -> b -> c) -> c
15:10:34 <Cooler> yes
15:10:54 <Cooler> so you could do function composition with that
15:10:57 <Cooler> instead of >>=
15:11:21 <glguy> Yeah, if you just had functions:   ( (a,s) -> (a,s) ) , then function composition would be enough
15:11:52 <Cooler> so why do you need the state monad?
15:12:22 <glguy> You never need it, but it's convenient to not have to manually thread the state value yourself
15:12:47 <Cooler> but you can do that with the flip uncurry
15:13:02 <glguy> You have to write functions with the type: (a,s) -> (a,s)
15:13:11 <glguy> in doing so you'll have to find a way to get the input state threaded to the output
15:13:20 <Cooler> no you write functions of type a -> s -> (a, s)
15:13:26 <glguy> some problem
15:13:32 <glguy> same*
15:13:42 <Cooler> what?
15:14:02 <Cooler> your already doing that
15:14:02 <glguy> To write a function with type a -> s -> (a,s) you have to take the input state and use it in the result somehow
15:14:26 <xuxu> installing lambdabot now to get the ghci on acid experience
15:14:29 <Cooler> ok maybe i wasn't clear
15:15:02 <Cooler> a function   f :: a -> s -> (a, s) simply takes normal parameters and a extra state parameter
15:15:17 <Cooler> and outputs a tuple of output and final state
15:15:31 <Cooler> so the state gets threaded through
15:15:43 <Cooler> whether the state changes or not depends on the function
15:16:26 <Cooler> it doesn't even have to use the state really
15:19:47 <Cooler> so you would have flip uncurry represented by |-
15:20:15 <Cooler> and test1 s = f1 s |- f2 |- f3 |- f4
15:20:38 <lpaste> glguy pasted “for Cooler” at http://lpaste.net/184135
15:21:01 <EvanR> ghci on acid... so they finally added color?
15:21:52 <Cooler> glguy, what?
15:21:55 <glguy> Cooler: If the problem you're solving is simple enough that |- as defined there handles it, then go ahead and use that
15:22:18 <Cooler> yeah, whats the bigger problem here?
15:22:28 <Cooler> that you need the state monad to help
15:22:32 <glguy> The question is "why do you need the state monad?", that paste shows how the state monad makes a problem simpler than the direct function solution
15:23:21 <xuxu> yay!
15:23:26 <Cooler> what is this?
15:23:30 <xuxu> λ :src map map _ []     = []
15:23:30 <xuxu> map f (x:xs) = f x : map f xs
15:23:43 <xuxu> really about lambdabot in ghci
15:23:48 <xuxu> really happy about lambdabot in ghci
15:23:56 <glguy> So we've heard
15:24:14 <xuxu> sorry, maybe i'm giving tmi in here
15:24:42 <Clint> Cooler: a better question is "why would you want to reimplement State for no good reason?"
15:25:05 <glguy> That's certainly a loaded question :)
15:25:20 <Clint> better, loaded, what's the difference
15:25:52 <glguy> it's complicated
15:26:01 <koz_> I'm a bit confused about how to properly use 'ito' from lens. I get what it's trying to produce, but I have no idea how you can get an indexed getter from a function that converts a structure into a pair of index and value.
15:26:11 <Cooler> Clint, thats a stupid question
15:26:38 <c_wraith> koz_: isn't that what an indexed getter is essentially?
15:26:43 <Cooler> why wouldn't you want something simpler
15:26:56 <Clint> how is reimplementing State simpler than using State?
15:27:16 <glguy> Cooler: The simpler thing is only simpler when you limited it to a subset of what the state monad is for
15:27:24 <Cooler> i am not arguing that you should reimplement anything
15:27:27 <glguy> as shown in the paste
15:27:28 <koz_> c_wraith: I guess what I want is a read-only lens by index into a structure.
15:27:37 <koz_> c_wraith: So like, something that I can index into, but not change.
15:27:57 <c_wraith> koz_: ah, that is indeed different
15:27:59 <Cooler> glguy, in the problem you pasted
15:28:03 <koz_> s/into/with
15:28:15 <koz_> c_wraith: What should I be hunting for in lens, then?
15:28:26 <Cooler> is the point that flip uncurry isn't enough when you are arbitrarily using previous results?
15:28:31 <c_wraith> koz_: not completely sure, tbh.  Maybe an indexed fold?
15:28:56 <Cooler> and only the state gets passed through in a systematic way?
15:29:02 <koz_> c_wraith: Maybe. I'll investigate.
15:29:04 <glguy> Cooler: Yes, that's a big part of it.
15:29:30 <Cooler> glguy, what does <- expand to?
15:29:53 <glguy> Cooler: each line in that example corresponds to a line in the other version
15:30:28 <glguy> so:   a <- b s   corresponds to:   (a,snext) = b sprev
15:30:35 <glguy> err, a <- b
15:31:25 <koz_> c_wraith: ifolding appears to be somewhat like what I see.
15:31:30 <koz_> s/see/seek
15:31:40 <Cooler> glguy, how exactly does that work?
15:32:21 <Cooler> glguy, how does it know from >>= which variables you are talking about
15:32:23 <glguy> Cooler: In general a <- b from do-notation expands to:  b >>= \a ->
15:32:48 <glguy> and >>= is implemented in the instance declaration for Monad (State s)
15:32:48 <Cooler> ok
15:34:40 <Cooler> glguy, which i haven't found the source for yetr
15:34:54 <glguy> ?hackage transformers
15:34:54 <lambdabot> http://hackage.haskell.org/package/transformers
15:34:57 <Cooler> found monad transformer state lazy
15:35:14 <Cooler> but not the simple one
15:35:18 <glguy> http://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-State-Lazy.html#t:StateT
15:35:30 <glguy> and then click the "Source" link next to:Monad m => Monad (StateT s m)
15:36:05 <glguy> The "simple"/non-transformer State is a myth: type State s = StateT s Identity
15:36:12 <glguy> It's just a particular instance of StateT
15:36:25 <glguy> That doesn't have to be the case, but it is.
15:36:58 <glguy> It's a nice exercise to implement your own State type and corresponding instances for it
15:38:25 <Cooler> glguy, return a = StateT $ \ s -> return (a, s)
15:38:38 <Cooler> why is return used in return? its recursive?
15:38:51 <glguy> It is used at a different type than the one being defined
15:39:06 <Cooler> StateT is being defined right?
15:39:32 <glguy> Yes, the return on the left is the return for StateT s m a
15:39:39 <glguy> the return on the right is the return for m a
15:40:18 * hackagebot servant-foreign 0.8.1 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.8.1 (jkarni)
15:40:20 * hackagebot servant-js 0.8.1 - Automatically derive javascript functions to query servant webservices.  https://hackage.haskell.org/package/servant-js-0.8.1 (jkarni)
15:40:22 * hackagebot edge 0.9.1.0 - Top view space combat arcade game  https://hackage.haskell.org/package/edge-0.9.1.0 (infrared)
15:42:41 <Cooler> glguy, you mean the return for m (a, s) ?
15:43:08 <glguy> I guess I mean the return for m if we're being specific
15:43:48 <Cooler> ok
15:44:14 <glguy> Another benefit of State over function composition is the ability to reuse generic operations like 'traverse'
15:44:28 <Cooler> glguy, isn't runStateT supposed to be :: StateT s m a -> s -> m(a, s)
15:44:54 <glguy> Yeah, that's what it is
15:45:12 <Cooler> it says otherwise
15:45:13 <Cooler> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
15:45:27 <glguy> You're misreading that
15:45:42 <glguy> runStateT is a field on StateT s m a , which has type, s -> m (a,s)
15:45:55 <glguy> therefore the generated function (or selector) runStateT
15:46:06 <glguy> will have type :: StateT s m a -> s -> m (a,s)
15:46:15 <Cooler> oh so theres 2 different things with the same name
15:46:30 <glguy> Yeah, the field name, and the selector generated for that field
15:46:53 <Cooler> usually accessor function have get suffixed
15:47:02 <Cooler> functions*
15:47:09 <glguy> In the record constructor syntax: StateT { runStateT = x }, x :: s -> m (a, s)
15:47:32 <glguy> I don't know what you mean about getting "suffixed"
15:47:41 <Cooler> getFieldName()
15:48:08 <Cooler> "get" suffixed
15:48:26 <glguy> Oh, that varies wildly
15:48:35 <glguy> this runTypeName pattern is quite common
15:48:42 <glguy> in particular for newtypes
15:48:57 <EvanR> @src Sum
15:48:57 <lambdabot> newtype Sum a = Sum { getSum :: a }
15:49:21 <EvanR> Roll, unroll
15:49:26 <glguy> @src Identity
15:49:26 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
15:49:52 <glguy> It's a question of how the author thought about what the type represented when writing it
15:50:20 <Cooler> i mean to distinguish the field from the getter function
15:50:36 <glguy> This is just how Haskell works
15:50:40 <Cooler> int field;  int getField();
15:53:18 <Cooler> so a monad transformer is a function that takes a monad as input and returns a monad as output?
15:54:19 <Cale> Yeah, a type-level function
15:54:35 <Cale> :k StateT Integer
15:54:37 <lambdabot> (* -> *) -> * -> *
15:54:47 <Cale> :k Maybe
15:54:48 <lambdabot> * -> *
15:54:51 <Cale> :k StateT Integer Maybe
15:54:53 <lambdabot> * -> *
15:56:05 <Cale> Cooler: and in addition to that, you need to have a function lift:
15:56:08 <Cale> :t lift
15:56:09 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
15:56:23 <Cale> which turns an action in the original monad into an action in the transformed monad
15:56:46 <Cale> (and this is required to satisfy a couple of laws)
15:56:54 <shachaf> This use of "action" sure sounds like "group action".
15:59:46 <prsteele> I'm using postgresql-simple, and I'm getting some weird results when reading back text. Do I need to manually check for \NUL values? Because I seem to be getting the expected string, plus \NUL, plus garbage
16:00:40 <dmj> prsteele: you can paste your code on http://lpaste.net
16:01:58 <prsteele> I'm sorry, I've answered my own question, and the problem is postgreSQL itself doesn't allow \NUL in text fields. But QuickCheck doesn't have such a restriction.
16:16:45 <roguen4rc> howdy
16:18:12 <glguy> hello
16:19:13 <xcmw> What is the best way to represent a nested map in haskell? http://lpaste.net/184131
16:22:11 <glguy> xcmw: You can use a nested Map
16:23:35 <xcmw> glguly: This one? https://hackage.haskell.org/package/nestedmap
16:24:18 <glguy> I was thinking of https://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map-Strict.html#t:Map
16:24:19 <kadoban> xcmw: I believe they're referring to just Data.Map.Map, from containers, it's a pretty standard dictionary/map data structure.
16:25:12 <prsteele> xcmw: Data.Map K (Data.Map K' V)
16:27:06 <shachaf> herzen: Any relation to Alexander Herzen?
16:27:29 <xcmw> presteele: Where would b1 be in that case?
16:28:59 <prsteele> xcmw: Data.Map K (Either V (Data.Map K' V'))
16:29:31 <xcmw> prsteele: Ok, Thanks
16:30:17 <herzen> shachaf: no relation, but I am ethnically russian and live in the west (although us-born)
16:31:03 <shachaf> But the name comes from somewhere else?
16:31:07 <shachaf> Anyway I guess this is off-topic.
16:32:55 <herzen> no, the name comes from Alexander Herzen (I don't like using random strings for handles)
16:33:07 <shachaf> Ah, then that's a relation.
16:34:03 <shachaf> I saw Stoppard's _The Coast of Utopia_. It was great. [#haskell-offtopic for more]
16:42:57 <Cooler> is main the only function in haskell that can execute IO ?
16:43:19 <shachaf> main isn't a function, and it's not the only thing that can do I/O
16:43:28 <prsteele> Cooler: main is the entry point, and has type IO (), so you're going to start IO things there
16:43:35 <shachaf> Or: Would you say that in C, main() is the only function that can do I/O? If so, that's true in Haskell as well.
16:43:43 <shachaf> It's pretty much the same situation.
16:43:54 <prsteele> Cooler: but main can invoke other things of type `IO a`
16:44:16 <Cooler> is main a instance of the IO monad?
16:44:37 <shachaf> The phrase "instance of the IO monad" has no meaning in Haskell.
16:44:41 <prsteele> Cooler: (someone correct me if my language is wrong) main is a top-level declaration of type IO ()
16:45:12 <ben> whats the deal with conduits and pipes
16:45:12 <glguy> it doesn't have to be (), but that's a good choice
16:45:16 <ben> is that some vim vs emacs kind of thing
16:45:41 <prsteele> glguy: I didn't actually know that, thanks
16:45:45 * prsteele looks into that...
16:46:18 <Cooler> is main THE IO monad?
16:46:22 <ben> main is a value of a type whose constructor is an instance of the IO monad?? idk
16:46:28 <Maxdamantus> How do you do I/O other than through main? unsafePerformIO?
16:46:37 <ben> Cooler: its not magic because of its type or anything
16:46:50 <ben> Cooler: you can define a ton of top-level bindings with type IO ()
16:46:53 <Maxdamantus> Cooler: the IO monad is the `instance Monad IO`
16:46:55 <prsteele> Cooler: you can have plenty of declarations of type IO () (or IO a, IO Int, ...)
16:46:58 <shachaf> ben: The phrase "instance of the IO monad" still has no meaning.
16:47:05 <ben> shachaf: ok
16:47:17 <shachaf> The situation with main in Haskell is almost exactly the situation with main() in C.
16:47:18 <prsteele> Cooler: main just happens to be the one the compiler chooses as the entrypoint to your program
16:47:19 <Maxdamantus> Cooler: ie, the methods (>>=) and return as defined specifically for IO.
16:47:34 <shachaf> When you run your program -- C or Haskell -- you execute main. That's all.
16:47:57 <shachaf> You don't need the concept of a monad for that.
16:47:57 <prsteele> Cooler: you could define sub1' :: IO () and sub2'' :: IO (), and then main = sub1 >> sub2
16:48:18 <parsnip> > length $ liftM2 (+) [0..6000] [0..6000]
16:48:23 <lambdabot>  36012001
16:48:28 <parsnip> > length $ liftA2 (+) [0..6000] [0..6000]
16:48:34 <lambdabot>  mueval-core: Time limit exceeded
16:48:47 <parsnip> ??
16:49:08 <ben> which of pipes or conduits are the better monads
16:49:39 <shachaf> ben: Please don't troll in here.
16:50:11 <ben> shrug
16:51:35 <Cooler> so what does >>= and return do for IO? anybody have the source?
16:51:35 <prsteele> parsnip: I'm *NOT* certain, but applicative is more restrictive than monad. So although list's applicative and monad instances are the same, I think the compiler can't prove... something... about the monad instance
16:52:01 <prsteele> Cooler: are you asking specifically w.r.t. IO, or about >>= and return in general?
16:52:25 <Cooler> the IO source
16:52:34 <ben> shachaf: do yall have a lot of problems with trolls?
16:53:15 <shachaf> If you have questions about trolls, please raise them in #haskell-ops.
16:53:24 <pyon> I have a type constructor “Foo a”, with lawful instances “Functor Foo” and “Eq (Foo a)”. Can I prove that there must be some type “Bar” and some injective (not necessarily bijective!) function “listify :: Foo a -> [Either Bar a]”?
16:53:43 <Maxdamantus> The IO source in GHC isn't very nice since it's not very Haskell-like.
16:55:29 <Cooler> Maxdamantus, but what does >>= and return do with respect to IO?
16:56:06 <ben> Cooler: >>= takes two IO actions and gives you a bigger IO action that sorta does both of them
16:56:22 <Maxdamantus> Cooler: `return` is a function that gives you back an IO operation that results in the value you gave it.
16:56:28 <ben> you kinda use that to make your program do more than one thing ever
16:56:44 <Maxdamantus> ben: no. >>= takes one IO operation.
16:56:59 <shachaf> pyon: Hm, why are you expecting that?
16:57:03 <ben> the other one is just hiding in a function
16:57:36 <prsteele> Cooler: I think his description is accurate for >>, though
16:58:03 <ben> >>= is just a slightly fancier >> where the second action can use the result of the first one
16:58:06 <pyon> shachaf: If tries are sets/maps whose key type is a list type, I want some generalization of tries whose key type is some arbitrary tree type.
16:58:07 <parsnip> Cooler: for functions `f :: IO a; g :: IO b', then `f >> g' it does some IO stuff, consisting of f does some IO stuff, then g does some IO stuff. 
16:58:24 <pyon> shachaf: And I thought it would be a good idea to “represent” trees as lists of elements plus separators.
16:58:38 <glguy> parsnip: f and g aren't functions there
16:58:41 <pyon> Foo is the type constructor of trees. Bar is the type of separators.
16:59:14 <ben> sure, theyre functions behind a newtype
17:00:14 <parsnip> Cooler: for actions `f :: IO a; g' :: a -> IO b', then `f >> (\x -> g x)', you have f does some stuff, calculates a value x of type a in IO a, and pass that to the action `g' x', which does some IO stuff and calculates some value of type b. 
17:01:12 <pyon> shachaf: The point to representing trees as lists is that I already know how to make sets/maps whose key type are lists: tries. So I would have reduced my original problem to an already solved problem.
17:01:49 <shachaf> pyon: Eq is there to indicate that inhabitants contain a finite amount of information, or something like that?
17:02:31 <pyon> Yep.
17:02:46 <pyon> So, for instance, there are no functions with infinite domains.
17:03:09 <Cooler> parsnip, thats a high level overview
17:03:12 --- mode: ChanServ set +o shachaf
17:03:30 <Cooler> but what does it actually have do in order to do that?
17:03:36 <jmcarthur> Cooler: I'll give you an inaccurate model for IO that happens to be mostly sufficient for reasoning about it.   data IO a = Return a | PutStrLn String (IO a) | GetLine (String -> IO a) | ...; return = Return; Return x >>= f = f x; PutStrLn str io >>= f = PutStrLn str (io >>= f); GetLine k >>= f = GetLine (\str -> k str >>= f); ...
17:03:39 --- mode: shachaf set +b-o bitch*!*@* shachaf
17:03:51 <prsteele> pyon: could you do a breadth-first traversal of the tree, creating [Either Direction a], where data Direction = L | R | U, where L and R are used to indicate traversal directions and U is used to indicate a terminal node?
17:04:00 <jmcarthur> Cooler: So the idea is it's just a description of the effects to perform and how to react to their results.
17:04:03 <prsteele> pyon: or *any* traversal for that matter
17:04:28 <jmcarthur> Cooler: Note that I didn't include any particular *interpretation* of those actions here. It's just not modeled in IO. This is a downside to IO, but it is what it is.
17:04:45 <pyon> prsteele: Ah, sweet!
17:05:01 <pyon> prsteele: Yes, I could do that.
17:05:25 <prsteele> pyon: hope it works out!
17:05:28 <pyon> :-)
17:05:53 <jmcarthur> Cooler: For an example of that representation, the expression   getLine >>= \str -> putStrLn str >>= \() -> return 17  would be just a value  GetLine (\str -> PutStrLn str (Return 17))
17:06:00 <yamadapc> So, before Chris published his Websockets Shootout entry, I had just implemented it, without using channels; just an MVar with all clients and concurrent publishing of the messages. I hadn't gotten to benchmark properly on Linux (I'm an OSX user) so I don't know how it performs. I'm wondering what's the benefit of using unagi-chan instead of this approach... I looks like what I did is what the Node.js implementatio
17:06:00 <yamadapc> n is doing
17:06:27 <jmcarthur> Cooler: I like this representation for teaching because it shows that IO doesn't actually "do" anything interesting.
17:06:59 <jmcarthur> Cooler: It also shows why a value of type IO String is not necessarily convertable to a String.
17:07:37 <jmcarthur> Cooler: An example of such a value:   GetLine Return
17:07:48 <cloudhead> yamadapc: so each client had its MVar?
17:08:54 <jmcarthur> s/shows why/reflects that/
17:11:17 <Cooler> jmcarthur, getLine >>= \str -> putStrLn str >>= \() -> return 17 doesn't do any IO when its required in main?
17:11:46 <Maxdamantus> It's something other than `main` that *does* the IO.
17:11:46 <Cooler> it just gives you a IO 17 ?
17:13:53 <Cooler> Maxdamantus, what does the IO?
17:13:57 <cloudhead> Cooler: basically the evaluation and executation are separate steps in haskell
17:14:08 <Maxdamantus> function runIO(op){ switch(op){ case PutStrLn(x, cb): print(x); cb(undefined); break; case GetLine(cb): cb(readline()); break; .. } }
17:14:09 <cloudhead> execution*
17:14:09 <glguy> the runtime system does the actual effects
17:14:18 <prsteele> Cooler: the runtime *does* the IO, your program is just a description to the runtime of what to do
17:14:51 <Cooler> is that a virtual machine?
17:15:03 <Cooler> i thought haskell compiled into C?
17:15:31 <yamadapc> cloudhead: No, there just was an MVar with a list of clients
17:15:41 <Maxdamantus> GHC is one Haskell compiler that might be able to compile to C, though that's not the usual target atm.
17:16:35 <yamadapc> Lots of threads and ignoring errors, since it's a benchmark; but it might not be very good in terms of simplicity... Now that I think about it
17:17:07 <cloudhead> yeah, I think a type that gives you broadcast semantics by default makes more sense
17:17:12 <cloudhead> and would also perform better
17:17:13 <yamadapc> Hope Chris' implementation turns out fast with patches to the libraries
17:18:31 <cloudhead> MVar isn't great for fanout
17:19:03 <yamadapc> cloudhead: But that's the thing, why would "broadcast semantics" perform better than a loop? Aren't these channel libraries implemented like that?
17:19:07 <kadoban> Cooler: There's no VM or anything. The RTS is just like ... bundled code that does garbage collection and some pretty low level stuff. You can just consider it like a library of basic code that every GHC haskell program gets. It's an implementation detail.
17:19:56 <cloudhead> yamadapc: I think they are implemented on a lower level - so you wouldn't incur the overhead of reading/writing from mvars
17:21:24 <parsnip> is there a solution for `Did not find .cabal file for with Git SHA of ... Right Nothing' ? 
17:21:41 <parsnip> `Did not find .cabal file for ... with Git SHA of ... Right Nothing'
17:21:55 <cloudhead> yamadapc: for example unagi makes use of x86 atomic operations which aren't portable
17:22:04 <cloudhead> ex: https://en.wikipedia.org/wiki/Fetch-and-add
17:22:05 <kadoban> parsnip: I think that's a harmless message. IIRC it got fixed in a more recent version?
17:22:10 <Cooler> Maxdamantus, whats the actual target then?
17:22:23 <parsnip> hmm, just did `stack upgrade' last night. 
17:22:46 <Maxdamantus> Cooler: well, the ultimate target is code for some particular machine (like x86 or ARM) inside some particular executable format (like PE or ELF).
17:22:50 <parsnip> but, okay, i'll wait for newer versions to supplant. 
17:23:04 <kadoban> I might be wrong about the upgrade part, maybe I just stopped hitting that message for some reason.
17:23:08 <Maxdamantus> Cooler: though on the way it will use various intermediate formats, none of which is typically C atm.
17:23:22 <Maxdamantus> Cooler: I think C-- is something used along the way.
17:24:11 <Cooler> so the compiler evaluates the haskell program at compile time?
17:24:17 <Maxdamantus> No.
17:24:33 <Maxdamantus> Well, it will evaluate part of it in some sense.
17:24:36 <Cooler> the runtime code does the evaluation?
17:24:46 <Maxdamantus> The runtime doesn't really evaluate.
17:25:09 <Cooler> what does the lazy evaluation then
17:25:11 <Cooler> ?
17:25:34 <kadoban> Cooler: "evaluates" is a loaded term. The haskell program is parsed and compiled at compile time. At runtime, evaluation and execution happens, yes.
17:25:36 <Maxdamantus> The generated code.
17:26:03 <Cooler> yeah the runtime code
17:26:43 <Maxdamantus> "runtime" here refers to mostly static code that does things that are common across GHC programs.
17:26:51 <Cooler> and so it executes the minimum amount of IO actions at that point?
17:26:52 <jmcarthur> Cooler: "What does the IO?" is like "What evaluates the code?"
17:27:42 <Maxdamantus> The compiler is responsible for turning one representation of a program into another representation of a program.
17:27:42 <Cooler> Maxdamantus, right so a bundled virtual machine?
17:27:47 <Cooler> embedded vm
17:27:50 <Maxdamantus> so instead of being written in Haskell it might be written in x86.
17:28:03 <cloudhead> no there's no bytecode
17:28:08 <Maxdamantus> the "runtime" just refers to some helping code that is typically linked in.
17:28:27 <Cooler> what does the runtime do?
17:28:37 <Maxdamantus> 12:18:45 < kadoban> Cooler: There's no VM or anything. The RTS is just like ... bundled code that does garbage collection and some pretty low level stuff. You can just consider it like a library of basic code that every GHC haskell program gets. It's an implementation detail.
17:29:23 <cloudhead> Cooler: the semantics of the IO monad don't have much to do with how the runtime works
17:29:23 <Cooler> so a list of sub-routines?
17:29:41 <kadoban> Something like that
17:29:59 <Cooler> so a library
17:30:13 <Cooler> like a dll
17:30:19 <cloudhead> so if you're trying to understand how the IO type works, understanding the runtime won't help much
17:30:25 <Cooler> a statically linked library
17:30:41 <kadoban> Cooler: Sure
17:31:09 <Cooler> test = getLine >>= \str -> putStrLn str >>= \() -> return 17
17:31:30 <Cooler> does that actually do any IO to read in a line and display it?
17:31:36 <dmj`> ertes: hey
17:31:52 <jmcarthur> Cooler: That's just a value.
17:32:37 <jmcarthur> Cooler: It would have the be interpreted by something, and that something is not accessible from within Haskell.
17:32:39 <jmcarthur> *have to be
17:33:26 <kadoban> Cooler: It's a value. Vales of type IO a, when executed at runtime may do i/o, sure. You can tihnk of it like a recipe, instructions that may be follewed at runtime. (if they use it in 'main', for instance)
17:33:32 <jmcarthur> Cooler: Note that I'm speaking at somewhat cross purposes from some of the conversation above. In the implementation there is some real x86 code with some real system calls, but the model you should be thinking of is that it's just a value that needs to be interpreted.
17:35:08 <Cooler> jmcarthur, no i am talking about what happens when the program is executed
17:35:15 <Cooler> whats the output of the program?
17:35:27 <jmcarthur> Cooler: There is no main function in your code.
17:35:45 <Cooler> yeah i am having trouble with that
17:35:52 <Cooler> main = test >>= return show >>= putStrLn
17:35:56 <Cooler> gives an error
17:36:25 <jmcarthur> Cooler: Yeah, test is returning a number, but you are trying to apply `return show` to it, which doesn't make sense.
17:36:35 <jmcarthur> Cooler: Perhaps you meant `return . show`?
17:37:09 <Cooler> yes
17:37:45 <Cooler> ok so it does do IO
17:37:51 <Cooler> to read line and print line
17:38:25 <jmcarthur> Yeah, the so-called "main action" is a value of type IO a (for some reason is allowed to be any type in place of the a) which is actually executed.
17:39:52 <jmcarthur> Cooler: Try this:   main = test >> test >> test
17:40:11 <jmcarthur> Cooler: Note that test is not a function, and yet it's executed multiple times.
17:40:16 <Cooler> jmcarthur, the problem with saying test is just a value
17:40:22 * hackagebot servant-auth-token-api 0.3.0.0 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.3.0.0 (NCrashed)
17:40:23 <Cooler> is that i keep thinking test = 17
17:40:24 * hackagebot servant-auth-token 0.3.0.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.3.0.0 (NCrashed)
17:40:36 <Cooler> which is not the case
17:40:38 <jmcarthur> Cooler: Right, that's not correct. Test is not an Int. It's an IO Int.
17:40:57 <jmcarthur> Cooler: An IO Int is no more an Int than a (String -> Int) is.
17:41:18 <shachaf> It's even less so.
17:41:28 <jmcarthur> Cooler: (actually a (String -> Int) is more like an Int than an IO Int, since it can be memoized such that it actually stores Ints)
17:42:14 <cloudhead> it's also (mostly) guaranteed to return an int, given a string
17:42:16 <jmcarthur> Cooler: A more common example: an IO [String] is no more a list of strings than `ls` is a list of files.
17:42:27 <cloudhead> which IO Int isn't
17:43:00 <jmcarthur> I dislike the overloaded use of the word "return" there, especially since both meanings seem deceptively similar.
17:43:21 <cloudhead> s/return/evaluate to
17:44:06 <jmcarthur> Cooler: Consider this. What if test was actually defined like this:   test = getLine >>= \str -> putStrLn str >>= \() -> return str
17:44:12 <jmcarthur> Cooler: What would you think its value is then?
17:44:43 <antiMossad> Mossad dont inform israeli people about this fraud called: psychiatry
17:44:45 <Cooler> test >> test >> test did something different than expected
17:45:00 <Cooler> it read 3 lines and then printed them all at once
17:45:22 <Cooler> not sure how that works
17:46:26 <jmcarthur> Cooler: I think you must have changed something else. It does not do that.
17:46:55 <jmcarthur> Cooler: Or perhaps you are piping the results into something that is not line buffered by default?
17:47:14 <jmcarthur> Not exactly sure what that might be.
17:47:21 <Cooler> http://lpaste.net/5996966220115476480
17:47:24 <geekosaur> anything fed over a pipe :)
17:47:49 <Cooler> i am using intellij idea's haskell plugin
17:47:50 <geekosaur> not many programs override the default behavior of line-buffered if terminal, block buffered otherwise
17:48:34 <jmcarthur> Cooler: I suspect intellij is doing something weird.
17:48:52 <jmcarthur> Cooler: That program should ordinarily interleave reading and writing.
17:48:58 <Cooler> lpaste gives a warning to use >=>
17:49:08 <jmcarthur> That's just hlint being "helpful"
17:49:12 <jmcarthur> Style only
17:49:20 <jmcarthur> It's also wrong...
17:49:26 <jmcarthur> Good job hlint.
17:49:33 <jmcarthur> Ah wait
17:49:37 <jmcarthur> I didn't see where it meant.
17:50:51 <jmcarthur> I think it's still not the optimal suggestion.
17:51:13 <jmcarthur> I would write test like    test = getLine >>= putStrLn >> return 17
17:52:14 <Cooler> :t >=>
17:52:16 <lambdabot> error: parse error on input ‘>=>’
17:52:24 <jmcarthur> I think hlint is thinking of writing that as   test = getLine >>= putStrLn >=> \() -> return 17
17:52:28 <jmcarthur> :t (>=>)
17:52:30 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:52:43 <jmcarthur> :t getLine >>= putStrLn >=> \() -> return 17
17:52:45 <lambdabot> error:
17:52:45 <lambdabot>     Precedence parsing error
17:52:45 <lambdabot>         cannot mix ‘>>=’ [infixl 1] and ‘>=>’ [infixr 1] in the same infix expression
17:52:49 <jmcarthur> :t getLine >>= (putStrLn >=> \() -> return 17)\
17:52:51 <lambdabot> error: parse error on input ‘\’
17:52:51 <jmcarthur> gah
17:52:53 <jmcarthur> :t getLine >>= (putStrLn >=> \() -> return 17)
17:52:55 <lambdabot> Num b => IO b
17:55:48 <Cooler> :t test = getLine >=> \str -> putStrLn str >>= \() -> return 17
17:55:49 <lambdabot> error:
17:55:49 <lambdabot>     parse error on input ‘=’
17:55:49 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
17:56:01 <Cooler> :t getLine >=> \str -> putStrLn str >>= \() -> return 17
17:56:03 <lambdabot> error:
17:56:03 <lambdabot>     • Couldn't match expected type ‘a -> IO String’
17:56:03 <lambdabot>                   with actual type ‘IO String’
17:56:10 <jmcarthur> I just fixed that.
17:56:41 <jmcarthur> Ah you're trying something else.
17:56:49 <Cooler> thats weird
17:56:54 <jmcarthur> Yeah, that doesn't work because getLine is not a function.
17:57:08 <Cooler> isn't a -> IO String = () -> IO String?
17:57:22 <Cooler> = IO String?
17:57:26 <jmcarthur> The problem is getLine, not putStrLn
17:57:36 <Cooler> yeah i am talking about getLine
17:57:38 <jmcarthur> No, () -> IO String is not the same type as IO String
17:57:48 <dmj`> ertes: ping
17:58:06 <jmcarthur> They are roughly equivalent in some denotational sense, but not in the Haskell type system.
17:58:21 <Cooler> i thought everything was a function, even values
17:58:28 <Cooler> 5 :: () -> Int
17:58:30 <jmcarthur> You're exactly backward.
17:58:36 <jmcarthur> Everything is a value, even functions.
17:59:08 <verement> > 5 ()
17:59:10 <lambdabot>  error:
17:59:10 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M833065867572...
17:59:10 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:59:12 <Cooler> why is () -> Int /= Int
17:59:14 <Cooler> ?
17:59:15 <LordBrain> he might be thinking of John Backus's original concept of functional
17:59:22 <jmcarthur> That's just not how the type system in Haskell works.
17:59:51 <jmcarthur> There is nothing fundamentally stopping it except that it might be confusing.
18:00:04 <cloudhead> Cooler: () is a very specific type and value called 'unit'
18:00:04 <jmcarthur> And would probably result in a much more complicated type system.
18:00:13 <LordBrain> i think Backus may indeed have had something in mind where numerals and such are actually const functions
18:00:26 <nshepperd> Cooler: for one thing, you'd have Int = () -> Int = () -> () -> Int = () -> () -> () -> Int = ...
18:00:33 <nshepperd> which would be pretty silly
18:00:37 <jmcarthur> NumInstances is sort of a way to get our numerals to be functions if one wants them to be.
18:01:09 <Cooler> LordBrain, i thought that was already the case
18:01:10 <jmcarthur> Cooler: Actually, () -> () has more values than () anyway.
18:01:43 <Cooler> nshepperd, no that actually makes sense
18:01:52 <LordBrain> i know you said that, but its not, like they're all telling you
18:02:10 <LordBrain> i was speculating as to how you might have got that impression
18:02:22 <jmcarthur> Cooler: undefined :: ()  and  () :: ()  are all we get for the type (), but for ()->() there's  \() -> (), \_ -> (), \_ -> undefined
18:02:24 <nshepperd> anyway, 'everything is a function' is a big fat lie
18:02:40 <Cale> I don't know where people get that idea...
18:02:48 <LordBrain> oh
18:03:07 <nshepperd> i hope everyone who ever wrote that in tutorials regrets it deeply
18:03:17 <LordBrain> well i think Backus might have said something similar, but that was a long time ago, and Backus didnt invent haskell, or modern functional
18:03:25 <verement> conflation with OOP's "everything is an object" maybe?
18:03:29 <jmcarthur> Cale: I think it's because they think there is a naming convention that "functional language" means everything is a function in the same way that "object oriented language" means everything is an object (which also isn't necessarily true, but is often implied anyway).
18:03:31 <nshepperd> putting everything in the same mental bucket doesn't help, it just confuses people
18:05:04 <Cooler> jmcarthur, no it just makes sense to think of everything as functions
18:05:19 <Cooler> instead of 2 things, functions and values
18:05:26 <jmcarthur> Cooler: There is only one thing: values.
18:05:35 <jmcarthur> Cooler: Some values happen to be functions, is all.
18:05:49 <Cooler> yes but if you are right, there are things that are NOT functions
18:06:13 <verement> quite right
18:06:16 <c_wraith> Lots of values aren't functions.
18:06:17 <c_wraith> > ()
18:06:19 <lambdabot>  ()
18:06:24 <c_wraith> That one's not a function!
18:06:35 <LordBrain> > 'f'
18:06:37 <lambdabot>  'f'
18:06:53 <glguy> 'f' is a nullary int
18:07:06 <LordBrain> > 0xf
18:07:08 <lambdabot>  15
18:07:21 <nshepperd> Cooler: that's like saying it makes sense to think of everything as integers
18:07:29 <nshepperd> Cooler: or floating point numbers
18:07:34 <LordBrain> whatever, forget the everything is a function nonsense, it doesnt illuminate anything
18:07:46 <Cooler> nshepperd, but functions are more abstract that integers
18:07:58 <Cooler> or floats
18:08:08 <nshepperd> functions, numbers, strings, lists these are all different kinds of values
18:08:48 <LordBrain> neither does all are values, even if technically true, there are functions, and there are values, and functions technically do have higher arity than merely 1, the whole lamda calculus thing is just notational really.
18:08:53 <nshepperd> Cooler: that doesn't make any difference
18:10:05 <jmcarthur> Cooler: All practical (can be evaluated on real hardware) Haskell functions are representable as integers. They compile to a string of binary digits, after all. So which is more powerful? Functions, or integers?
18:10:28 <jmcarthur> Cooler: And my statement may be overly qualified.
18:10:43 <Cooler> jmcarthur, because the reals are bigger than integers
18:10:57 <LordBrain> there integer representation isnt cannonical tho
18:11:03 <jmcarthur> Cooler: Yeah, Haskell can't really reason about reals.
18:11:25 <ReinH> You might even call them different types of values.
18:11:48 <nshepperd> computers don't have reals anyway.. but that's besides the point
18:12:16 <ReinH> In Haskell it is simple: functions are values whose type is constructed with (->).
18:12:34 <shachaf> Computers have all the reals that are real.
18:12:36 <LordBrain> you could get the algebraic numbers
18:12:48 <jmcarthur> Objecting to some values being functions and some not being functions is like objecting to some being Maybes and some not being Maybes.
18:13:14 <jmcarthur> If the latter were not true we would be suffering from the billion dollar mistake. :)
18:13:59 <LordBrain> well, if you used a system for encoding algebraic numbers as your fundamental numbering system, then your numbers really are kind of like functions because what? they'd really be formulas for producing strings of digits out to some needed precision
18:14:21 <ReinH> CReal is exactly that
18:14:26 <nshepperd> Cooler: anyway, point is 'everything is a function' may sound like Deep Wisdom but it's simply not true
18:14:34 <jmcarthur> CReal is not the same as the reals, though.
18:14:59 <ReinH> "Everything is a value" isn't even true.
18:15:06 <jmcarthur> ReinH: Yeah, it's not.
18:15:21 <ReinH> jmcarthur: good thing I didn't make that claim.
18:15:24 <jmcarthur> What the heck is a data type? Not a value (in Haskell), that's for sure.
18:15:26 <shachaf> In fact CReal has measure 0.
18:15:39 <jmcarthur> ReinH: I think I had misunderstood what your statement about CReal was in response to.
18:15:51 <ReinH> Ah
18:16:11 <nshepperd> Cooler: and, if you only use 'function' for values whose type is '… -> …', you actually learn something useful from something being a function, namely that you can apply it to a value
18:16:21 <ReinH> Well, there are also types and kinds, neither of which are values.
18:16:32 <nshepperd> :(
18:16:47 --- kick: bitch was kicked by ChanServ (Banned: Inappropriate nickname prefix)
18:16:48 <nshepperd> the internet isn't a value either :)
18:17:08 <jmcarthur> Revision: Every expression in Haskell has (denotationally) a value, except for IO, because we don't know what IO is, but an IO action is still considered a "value" in the sense of representation.
18:17:32 <Cooler> got dced
18:17:36 <ReinH> nshepperd: your face isn't a value
18:17:47 <jmcarthur> Cooler: And look what happened while you were gone!
18:17:52 <LordBrain> god, dont pick on his face
18:17:58 <jmcarthur> We've reverted to insults.
18:18:07 <ReinH> That's an insult?
18:18:09 <LordBrain> your mom reverted to insults
18:18:13 <ReinH> There it is
18:18:22 <nshepperd> my face is higher kinded
18:18:27 <Cooler> face value
18:18:27 <LordBrain> lol
18:18:49 <jmcarthur> Dang, Cooler took my pun before I finished typing my sentence.
18:19:19 <LordBrain> there's a lesson in that... brevity
18:19:39 <jmcarthur> Ah, but my sentence would have been better.
18:19:40 <Cooler> so we were talking about how everything is a value?
18:19:51 <nshepperd> Cooler: if you only use 'function' for values whose type is '… -> …', you actually learn something useful from something being a function, namely that you can apply it to a value
18:19:53 <jmcarthur> Cooler: Yeah, but not quite everything.
18:19:59 <jmcarthur> Cooler: e.g. nshepperd
18:20:02 <jmcarthur> 's face
18:20:06 <LordBrain> lol
18:20:40 <nshepperd> if you just say 'everything is function' then well, 'function' becomes a pretty useless word
18:20:45 <LordBrain> this is what would happen if reddit wrote a haskell book
18:20:46 <nshepperd> we already have 'value'!
18:20:58 <jmcarthur> That statement generalizes to 'everyting is X'
18:21:02 <jmcarthur> *everything
18:21:16 <nshepperd> 'everything is tasty'
18:21:16 <LordBrain> we could generalize further to 'Y is X'
18:21:35 <jmcarthur> LordBrain: So "is" is useless?
18:21:56 <LordBrain> depends on what the meaning of "is" is
18:22:15 <ReinH> That depends on what your... God damn it.
18:22:30 <LordBrain> that statement during the 90s was clearly god's foreshadowing of ISIS
18:22:31 <nshepperd> heh, and this is perfect example of exactly why blindly generalizing is silly
18:22:35 <jmcarthur> Researchers of dependent types have been trying to answer that question for a while now.
18:22:42 <Cooler> everything is in your mind?
18:22:48 <nshepperd> the more you generalize, the less you can say
18:23:09 <ReinH> Cooler: that's an open research problem.
18:23:12 <nshepperd> being specific is a virtue
18:23:13 <Xnuk> "is" is is isis
18:23:34 <negatratoron> is is is
18:23:54 <jmcarthur> One of the nicest things about English is how many words there are.
18:24:41 <Cooler> everything is a SET
18:24:41 <ReinH> Is is not not is.
18:24:52 <Cooler> or category
18:25:00 <ReinH> Nope.
18:25:25 <Cooler> it guruanteed by an axiom
18:25:46 <Cooler> guaranteed*
18:25:50 <jmcarthur> That's going to be my excuse for weird claims I make from now on.
18:25:58 <ReinH> Only if your want your axiomatic system to be useless.
18:26:07 <negatratoron> is is is, is
18:26:12 <negatratoron> >.>
18:26:32 <ReinH> Ex falso and sjch
18:26:36 <ReinH> Such
18:26:37 <parsnip> hmm, this is still taking some 5 seconds, even though i'm using unboxed vector, and -O2: 
18:26:39 <parsnip> main = print $ V.length $ V.fromList $ liftM2 (+) [0..6000] [0..6000::Int]
18:27:00 <glguy> parsnip: The vector isn't relevant, you're doing the operation on lists
18:27:10 <jmcarthur> parsnip: fromList is generally slower than constructing directly
18:27:25 <parsnip> hmm, okay, will work on that, thanks. 
18:28:14 <parsnip> i can still use unboxed vector, or do i need mutable? 
18:29:03 <jmcarthur> parsnip: I don't actually expect this to be fast with vector either.
18:29:34 <parsnip> okay, but this operation seems to be an underlying part to project euler problem 23. 
18:29:38 <Cooler> ReinH, isn't haskell built on category theory which guarantees that everything is a category?
18:29:46 <parsnip> https://projecteuler.net/problem=23
18:29:48 <jmcarthur> Really?
18:29:58 <jmcarthur> Okay, I'll try to solve it.
18:30:06 <ReinH> How does category theory guarantee that?
18:30:11 <jmcarthur> I stink with math though, so it will be some effort.
18:30:18 <parsnip> jmcarthur: i think i have to work over 6000 abundant numbers. 
18:30:40 <parsnip> and so around 40,000,000 abundant sums. 
18:31:01 <ReinH> (Hint: it doesn't)
18:31:35 <parsnip> i think the other strategy considers each abundant number, and each number up to 27,000, and check if the difference is abundant. 
18:32:57 <parsnip> oh, maybe there's only 1400 numbers
18:34:09 <Cooler> ReinH, how can something not be a category?
18:34:40 <jmcarthur> Cooler: Like functions, if everything was a category, categories would not be very useful.
18:34:44 <parsnip> jmcarthur: hmm, when i replace 6000 with 1500, it's much more reasonable time. may have been my mistake there, so don't worry unless it just looks fun :)
18:34:44 <Cooler> data Category = Everything
18:34:55 <jmcarthur> Cooler: () is not a category.
18:35:01 <jmcarthur> Cooler: Your face is not a category.
18:35:03 <jmcarthur> :)
18:35:12 <ReinH> A category is an algebraic structure with properties.
18:35:19 <Cooler> right its a value
18:35:22 <ReinH> Not all things have those properties.
18:36:07 <Cooler> ok everything inside haskell is a category?
18:36:12 <ReinH> No.
18:36:20 <Cooler> and why would () not be a category?
18:36:29 <ReinH> Why would it be a category?
18:36:42 <ReinH> This isn't a reasonable way to argue.
18:36:51 <Cooler> because i can say its a category called empty tuple having one element ()
18:37:33 <ReinH> Ok, what is the rest of the structure?
18:38:00 <Cooler> uh, theres a function () from () to itself?
18:38:03 <parsnip> :t id :: () -> ()
18:38:04 <lambdabot> () -> ()
18:38:09 <ReinH> Right.
18:38:13 <jmcarthur> Cooler: Already we are talking about more than just ().
18:38:39 <Cooler> yeah its the associated structure that comes with every category
18:38:44 <ReinH> () is a trivial category.
18:38:49 <jmcarthur> Cooler: Is "foo" a category?
18:38:53 <Cooler> sure
18:39:03 <Cooler> every value is a category having one element
18:39:07 <glguy> Cooler: id :: () -> () isn't an element of ()
18:39:16 <ReinH> When equipped with id and (.)
18:39:17 <jmcarthur> Cooler: What is the use of identifying categories that way?
18:39:26 <jmcarthur> Cooler: Aren't those all just the same category?
18:39:29 <parsnip> take the minimal category containing () as an object. 
18:39:40 <jmcarthur> Cooler: This is like saying "everything is isomorphic to everything else"
18:39:43 <ReinH> It makes him not technically wrong, which is more important than concepts having meaning.
18:40:14 <ReinH> Like I said, this is a ridiculous way to argue.
18:40:22 <Clint> that does seem to be the long-running theme
18:40:38 <Cooler> so your saying a category has some rules associated with it?
18:40:48 <Cooler> some sort of non-trivial structure
18:40:53 <ReinH> Yes of course. Do you even know what a category is?
18:40:58 <Cooler> no
18:41:03 <ReinH> Go look it up then
18:41:13 <ReinH> What are we even talking about
18:41:31 <ReinH> How ridiculous.
18:42:10 <MarcelineVQ> hashtagsaturdayhaskell
18:42:12 <Cooler> yeah this one https://en.wikipedia.org/wiki/Category_theory
18:42:20 <ReinH> Yes, that one.
18:42:38 <Clint> this is apparently the only effective way to troll the channel for 4 hours
18:42:39 <Cooler> the structure is what i described
18:43:13 <ReinH> I'm not playing your silly game any more.
18:43:48 <Cooler> i am just finding out that everything that i thought about haskell is a lie
18:44:09 <ReinH> Ok.
18:44:42 <Cooler> i thought haskell was an attempt to implement Zermelo–Fraenkel set theory
18:44:55 <ReinH> Why on earth would you think that.
18:45:05 <Cooler> because there are videos on Youtube
18:45:13 <ReinH> Yeah right
18:45:21 <Cooler> by people you think know what they are talking about
18:45:26 <ReinH> Show me one.
18:45:50 <Cooler> i have to look it up, there are several
18:45:59 <ReinH> I don't believe you.
18:47:33 <jmcarthur> Yeah that seems a bit crazy to me.
18:47:54 <Cooler> this is one that gave me that impression https://www.youtube.com/watch?v=o6L6XeNdd_k
18:48:09 <jmcarthur> Do you have a timestamp to where they say that?
18:48:17 <jmcarthur> And hour and a half is a long time.
18:48:20 <jmcarthur> *an
18:48:20 <ReinH> That isn't a Haskell video.
18:48:25 <Cooler> they don't say that exactly
18:48:37 <Cooler> its my interpretation
18:48:46 <ReinH> Doeds it even mention Haskell?
18:48:57 <Cooler> yes
18:48:58 <jmcarthur> Ah I've seen this.
18:49:03 <jmcarthur> Yes, Haskell is mentioned.
18:49:08 <jmcarthur> But most of the talk is not about Haskell.
18:49:27 <ReinH> I'd need a specific timestamp.
18:49:54 <jmcarthur> iirc, the speaker even says the talk is not about haskell, explicitly
18:50:07 <Cooler> ok maybe its my fault
18:50:17 <Cooler> but its easy to get that impression
18:50:30 <ReinH> I don't think it is.
18:50:41 <ReinH> Since I have never ever heard anyone say that before.
18:52:54 <ReinH> None of the books and papers I've read, videos I've watched, or people I've talked to have ever made a claim that could even be reasonably misconstrued as saying that Haskell is an implementation of ZFC or w/e
18:53:04 <Cooler> ReinH, in that video near the end
18:53:20 <jmcarthur> how near the end
18:53:21 <Cooler> it mentions NLab and about how they believe everything to be a category
18:53:26 <ReinH> If set theory does come up, it's almost always to say explicitly that types are not sets.
18:53:36 <jmcarthur> What does that have to do with Haskell and ZFC?
18:53:38 <Cooler> and how physics in embedded as dynamics inside it or something like that
18:53:42 <ReinH> Ok, what does that have to do with Haskell or ZFC?
18:54:27 <Cooler> because like i said i thought haskell was an attempt to implement Maths specifically ZFC
18:54:43 <jmcarthur> I don't understand how the evidence you are presenting supports that idea.
18:54:45 <ReinH> No, we're asking why you though that.
18:54:51 <ReinH> Thought
18:55:06 <Cooler> jmcarthur, near the end the video sort of gets into some metaphysics
18:55:07 <ReinH> And you said it was because of a YouTube video
18:55:12 <Cooler> but anyway
18:55:30 <Cooler> like i said they don't say anything exactly like i said
18:55:38 <Cooler> so it is my fault
18:55:42 <ReinH> They didn't say anything at all like you said
18:59:10 <dmj`> ertes: ping
19:09:26 <Cooler> ReinH, https://youtu.be/o6L6XeNdd_k?t=4011
19:09:54 <Cooler> thats where i got the idea
19:10:41 <ReinH> That's not about Haskell?
19:11:05 <ReinH> It's a joke about physicists who use category theory
19:11:19 <Cooler> well i am talking about everything is a category
19:11:30 <ReinH> It's a joke.
19:11:32 <Cooler> and haskell is about category theory
19:11:36 <ReinH> He is making a joke.
19:11:56 <ReinH> Haskell is not about category theory. Haskell is a programming language.
19:12:05 <Cooler> well he says that the people at the NLab takes it seriously and as definitional even though he doesn't think so
19:12:19 <ReinH> He is making a joke.
19:12:41 <parsnip> /:t Cooler
19:12:49 <Cooler> sure but its not what he believes, its about what the theory is
19:13:03 <jmcarthur> Arguments about youtube videos should perhaps be taken to #haskell-blah
19:13:04 <Cooler> not about*
19:13:09 <Cooler> ok
19:13:23 <ReinH> You don't know what it is, since he was not describing anything accurately, since he is joking.
19:14:19 <ReinH> This has exactly nothing to do with Haskell.
19:15:53 <Cooler> right
19:16:58 <parsnip> @let allAbundants = map fromIntegral $ filter isAbundant [1..upperLimit] where isAbundant n = (> 2*n) $ sum $ divisors n; upperLimit = 28123
19:17:01 <lambdabot>  .L.hs:169:42: error: Variable not in scope: divisors :: t -> t0 t
19:17:03 <Cooler> this goes back to my original question of what does >>= and return do in terms of IO
19:17:12 <Cooler> and i mean the actual implementation
19:17:27 <Cooler> because i was given several high level explanations
19:17:28 <parsnip> > import Math.NumberTheory.Primes.Factorisation (divisors)
19:17:30 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
19:18:43 <ReinH> Denotationally, we don't know what IO does.
19:19:24 <ReinH> We do know some things about >>= and return, but they are true for all monads.
19:23:09 <Cooler> ReinH, looking at this https://www.haskell.org/onlinereport/standard-prelude.html
19:23:21 <Cooler>    (>>=)  = ...
19:23:21 <Cooler>    return = ...
19:23:36 <Cooler> which is really weird, i didn't know that was valid code
19:24:12 <ReinH> It isn't.
19:24:17 <ReinH> It's elided.
19:24:24 <Cooler> its what?
19:25:03 <ReinH> Elided. Omitted.
19:25:41 <ReinH> The implementation is not given in the report.
19:25:51 <Cooler> so its not the source?
19:26:04 <ReinH> No, it is the Haskell Report.
19:26:18 <ReinH> Which is a document that describes the Haskell language.
19:27:18 <ReinH> Read the first paragraph of that chapter.
19:28:10 <ReinH> Again, no, it is not.
19:28:14 <Cooler> right
19:28:30 <ReinH> Then read the other paragraphs, which include an explanation of the "..."
19:29:18 <Cooler> ok is this it?
19:29:19 <Cooler> http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#line-1093
19:29:28 <ReinH> If you want to understand something, it helps to read all of it.
19:30:25 <ReinH> Yes, but they implementation will not be useful to you, because GHC implements IO in a non-obvious way.
19:30:28 <jmcarthur> That's how GHC does it.
19:30:37 <ReinH> That*
19:30:47 <jmcarthur> It's not "Haskell", though, and it's unlikely to help.
19:31:14 <ReinH> What is being I implemented there is the passing around of a sentinel value in a state shaped monad.
19:31:35 <ReinH> s/I //
19:31:42 <Cooler> what do you mean its not Haskell? its not idiomatic?
19:32:08 <ReinH> It isn't defined by the report.
19:32:22 <ReinH> It is an implementation detail of GHC
19:32:32 <LordBrain> the distinction between ghc and haskell generally is going to get blurred if we dont maintain alternative implementations
19:32:54 <Cooler> so the specification is literally also the implementation to some extent?
19:33:11 <ReinH> No, the specification is the specification.
19:33:27 <Cooler> the specification is written in haskell code
19:33:29 <ReinH> Implementations need to conform to the spec.
19:33:48 <Cooler> for example Eq, Ord
19:33:54 <ReinH> The specification is the entire document.
19:34:16 <ReinH> Some of which is written in Haskell, most of which is not.
19:34:52 <Cooler> if the specification doesn't say anything about IO
19:35:10 <ReinH> Then implementations are free to make stuff up.
19:35:12 <Cooler> is that because IO is too general?
19:35:38 <jmcarthur> I don't know what "too general" means, but yes, IO is general enough that we don't have a good specification for it.
19:35:45 <LordBrain> IO is a one way monad
19:35:54 <LordBrain> it says that
19:36:58 <Cooler> what does that mean? the computations are irreversible?
19:38:00 <ReinH> Where does it say that?
19:38:02 <LordBrain> it means there is no inverse to return
19:38:17 <ReinH> That is generally true of all monads.
19:38:33 <ReinH> Or rather, of monads in general.
19:38:52 <LordBrain> no its not
19:39:03 <ReinH> It is true of monads in general.
19:39:23 <ReinH> There is no general way to write an inverse of return.
19:39:31 <LordBrain> well of course not
19:39:38 <LordBrain> otherwise there could be no one-way monads at all
19:39:38 <ReinH> There are specific ways for specific types.
19:40:04 <ReinH> Monad as a concept is "one way"
19:41:29 <LordBrain> i dont know why you object to the term, i didnt invent it
19:41:45 <LordBrain> but whatever, we both understand, so its purely semantic quibbling
19:42:57 <dmj`> johnw: ping
19:43:09 <Cooler> like a wise man once said "There's no point arguing semantics" XD
19:43:39 <ReinH> Of course there is.
19:43:49 <ReinH> That's exactly what you have been wanting to do.
19:44:07 <ReinH> You have been asking about the semantics of IO.
19:44:10 <Cooler> ik
19:44:14 <Cooler> it was a joke
19:44:23 <ReinH> Semantics is "what things mean", which is pretty important.
19:44:47 <Cooler> somebody did actually say that though
19:45:14 <ReinH> They are silly.
19:46:53 <LordBrain> hmmm actually the phrase does have a point tho, there is a distinction between arguments over what actually is, and arguments about what choice of words we use to say what is
19:47:05 <glguy> maybe the wise man said not to argue the same semantics for hours
19:48:34 <LordBrain> yeah, ReinH agrees that for specializations to specific monads, sometimes return has an inverse, and in general they dont, and that IO is not one of the cases for which there is an inverse of return, and that is basically all of the 'what is' part.
19:49:03 <glguy> the wise man also mentioned that this was a great weekend too try out glirc
19:50:05 <ReinH> Yes, the latter kind of argument is a prerequisite for the former.
19:50:11 <LordBrain> whether it is even warranted to give a special designation for those monads which do not have an inverse to their specialized return, may be something or what name that should be, he might have differing opinions on, but i just dont care about that. one-way monad is a phrase i have read, and learned, i didnt know it was at all controversial.
19:50:53 <ReinH> So says Wittgenstein, so it must be true.
19:51:35 <LordBrain> well, if you really want to make the case then, okay do, what is the objection to the term 'one-way monad' ?
19:52:03 <LordBrain> i think it serves well enough
19:54:46 <ReinH> That's just "monad".
19:54:49 <LordBrain> one way monads warrant a name i think of their own, because that is a specific use of monad, as in, IO is precisely useful because it is one-way and if it werent one-way it would be far less useful, as it is about isolation of effects from referentially transparent pure computation.
19:55:21 <LordBrain> it keeps the pure, pure
19:55:44 <LordBrain> if you could invert that return, which technically you can with unsafePerformIO, then actualy you end up wtih things that look pure, but arent
19:56:36 <LordBrain> not all monads warrant 'unsafe' written on their inverse-returns tho, which shows the concept of being one-way is not universal to monads and their proper use
19:59:32 <jonored> head is not unsafe, for instance.
20:00:47 <LordBrain> yeah, except well it does throw an exception on []
20:02:53 <ReinH> What's universal to monads are the things you can say with the given operations (and laws)
20:03:53 <ReinH> Something you can do with some but not all monads is, by definition, not universal.
20:03:57 <jonored> General monads don't guarantee that there /is/ a value to return.
20:04:09 <LordBrain> but the state monad provides an example, where you can write an inverse of return, using runState and fst
20:04:29 <ReinH> Yes, but that is not universal. That is the opposite of universal.
20:04:58 <LordBrain> well, it not being universal is my supportive statement for naming those monads which dont have that property 
20:05:02 <jonored> The correct thing to do isn't to make "monad without an inverse to return", it's to define "monad with an inverse to return".
20:06:12 <LordBrain> well, i can see that perspective, and that is better than making no nominal distinction, however i disagree, because the very fact that IO has no return is integral to its function, where as the non-one-way monads it is often incidental to their function that they happen to have an invertable return
20:07:51 <jonored> LordBrain: That means that you've got two classes now, and have code duplication for things that only rely on the monad properties.
20:08:26 <parsnip> but reading code, you usually rely on knowing that there is no inverse in a do monad, making it easier to read? 
20:08:30 <LordBrain> you mean literally making a separate type class? i never proposed any such thing
20:09:35 <LordBrain> we're just talking about the use of saying  'IO is a one way monad'
20:10:10 <jonored> ...But now you can't actually rely on knowing what the inverse is :)
20:10:17 <jonored> in generic code.
20:10:18 <LordBrain> because someone objected, but they probably only objected due to not hearing it before actually, and if they had like me seen it in print and so forth, would find it less objectionable i bet.
20:11:23 <jonored> MonadWithInverseReturn doesn't mess with anything to have as a literal typeclass. Possibly not useful, but...
20:11:29 <LordBrain> i suppose the fact that it adds another bit of vocab to our lexicon might itself be an objection worthy of considering, i dont find it a burden tho.
20:12:08 <LordBrain> if i did, i wouldnt remember it, or use it
20:12:12 <LordBrain> so i guess that goes without saying
20:13:15 <LordBrain> its actually a pretty easy to remember way of putting it, as in things only go one way, they go in to the monad, but they dont come out
20:14:10 <LordBrain> that's probably superior in practice to having some more nerdy sounding word that everyone forgets 100 times before it finally sticks.
20:15:40 <LordBrain> Now, Lets discuss Homocaminical Monads
20:16:17 <LordBrain> if i had used that word, ReinH would no doubt assume i must know what i am talking about, and might be shy to challenge hence portraying his ignorance.
20:16:34 <LordBrain> lol
20:18:59 <LordBrain> lets potentially risk obscuring even more and shorten it to Homocaminad, thus shorter type signatures in the case you want to make a type class.
20:21:09 <LordBrain> surely one way monad is just way to nice to the novices
20:21:26 <LordBrain> its almost unhaskelly nice
20:21:35 <dolio> What's the point of talking about these monads?
20:22:20 <LordBrain> they're used for maintaining purity for whatever definition of purity you are interested in
20:25:25 <dolio> Doubt it.
20:25:53 <LordBrain> in practice, not so easy really, unless you stick with just IO, but that's the idea
20:29:12 <LordBrain> i'm not super fond of the usual monad approach either, but that's what we got
20:30:17 <LordBrain> it would be cool if we built things like IO on top of other kinds of effect systems, so that we could have the advantages of the other thing, while maintaining the compatibility
20:31:51 <LordBrain> the effect-monad approach uses type level sets, i like the idea of it in theory
20:33:06 <LordBrain> if we become full on dependently typed, it might be worthwhile to start revamping our effect system fundamentally
20:34:48 <LordBrain> so IO becomes sort of a historical thing, that still works but is built off of more complex machinery under the hood and that complex machinery might be the goto for programs where the flexibility warrants it
20:35:10 <LordBrain> that's how i envision things anyway
20:37:34 <ongy> sounds like a nice way to confuse people. (Also I bet performance degration)
20:39:15 <LordBrain> well, it would be nice to have finer grain isolation than io gives
20:40:11 <LordBrain> say i want all of a specific piece of hardware isolated or something in the type system
20:40:55 <LordBrain> can do it with RIO, but then someone else wants to just use it as IO becuase they're not interested in it being restricted to that hardware or not, that's just not the concern from the other program
20:41:12 <LordBrain> so i need rioToIO now
20:41:47 <LordBrain> which is well, you know, clunkier than ideal.. as IO is conceptually made up of a lot of stuff put together really
20:42:53 <LordBrain> and if i just do RioToIO, then what happens when it goes back into a bit of code that again wants to understand the RIO meta.. whatever that was... i mean, ideally we'd temporarily obscure the extra information that is tracked but not irreversably destroy it
20:45:04 <ongy> if I understand you correctly you could do the rioToIO into IO (OpaqueType, a), and have the runIO take that again. Not that it's nice, but possible
20:45:05 <LordBrain> well maybe thats not the best case, i mean the person who is not interested could usually get away with using MonadIO 
20:45:27 <LordBrain> oh yeah thats an approach too
20:46:41 <LordBrain> i think MonadIO is better than that, but of course it requires the person to use that type class constraint, instead of assuming IO, and hmm that would imply use of 'liftIO' too 
20:48:47 <LordBrain> i like the type level sets approach personally
20:48:58 <ongy> but I agree to a bit finer grain. The thing I have come about, it would be nice to have internal IO (free/operations on memory) be different from i.e. file IO
20:49:11 <LordBrain> yeah
20:51:13 <LordBrain> it also makes sense to my mind, if we were building everythign from the ground up, as the language runs on bare metal or something, then we'd really want these finer grain things implemented first, and then once that is done, it seems unfortunate if they cant be somehow put-to-gether into the more general blackbox that is typical haskell IO
20:53:00 <LordBrain> so i'm thinking of something like MirageOS for example
20:53:08 <LordBrain> but haskell instead of ocaml
20:53:16 <ertes> dmj`: pong
20:53:18 <LordBrain> or haskell++ whatever... 
20:53:30 <LordBrain> haskell2020
20:53:33 <LordBrain> heh
21:00:38 <dmj`> ertes: I just wanted to say that I think what I was looking for was observable sharing
21:02:16 <dmj`> ertes: in the form of StableNames or Weak pointers, to make a memo table that aids in the construction of new data by re-using old data
21:05:41 <Maxdamantus> What would the distinction be between memory IO and file IO?
21:06:16 <Maxdamantus> They both seem equivalent to me. You can create memory-IO operations that do file IO operations by talking to different threads using shared memory.
21:06:56 <Maxdamantus> It would make sense to hawe realms of memory IO, like in ST.
21:09:48 <monochrom> you are right there is no difference if "memory" means shared memory.
21:10:01 <ongy> or mmaped file descriptors for that matter
21:10:12 <monochrom> but "memory" doesn't always mean shared memory. sometimes not even shared with another thread.
21:10:12 <ongy> (are the FDs mmaped or the files?)
21:12:00 <monochrom> this is why IO is an extrovert interacting with other people and ST is an introvert talking to self.
21:12:04 <Maxdamantus> Right, so for that there's pretty much ST.
21:12:21 <ertes> dmj`: i still think what you really want is to let the user code the sharing
21:12:58 <Maxdamantus> er, yeah,o you just mentioned that.
21:16:35 <ongy> I'm thking more in an FFI setting, where I may want to do some manipulation without (de)serializing fully. But it's not bad to use IO, it would just be a little nicer to have a type level destinction when something is actually passed to the outside world. But that may be quite a corner case
21:28:58 <Maxdamantus> ongy: serialising as in making sequential, or as in marshalling?
21:29:08 <ongy> marshalling
21:29:20 <Maxdamantus> FFI lets you declare things that don't need to run through IO.
21:29:41 <Maxdamantus> It's your job to make sure they behave pretty much purely.
21:30:04 <Maxdamantus> or to wrap around them so they do.
21:30:40 <Maxdamantus> once you're in the realm of FFI you might as well be using unsafePerformIO anyway.
21:31:04 <Maxdamantus> FFI can't guarantee safety of the things you're calling.
21:33:25 <LordBrain> i missed
21:33:26 <ongy> I know. I think you misunderstood me. What I would like is to have a type that allows peek/poke for manipulation but is not intended for calling outside effects. (I may be able to do that myself with unsafePerformIO, but I'm not sure)
21:33:47 <LordBrain> but FFI isnt my bag, i want a mirageOS kind of haskell, so you build the entire os and drivers in a dialect of haskell
21:34:15 <glguy> LordBrain: Like HaLVM?
21:34:16 <Maxdamantus> LordBrain: like House?
21:35:46 <LordBrain> yeah, but with more fine grain control, as in, haskell in its present form isnt quite fine grain enough for me, i want a near-assembly like thing, but with a powerful type system, and yet expressive enough to essentially have haskell as a subset
21:36:35 <LordBrain> so things like what happens with garbage collection and so forth is expressible in the language more, rather than being forced by the compiler
21:37:45 <LordBrain> and i'd like as part of this, that there was a finer grain version of isolation, as in, isolate all instructions that potentially communicate with the wifi on my pci bus or whatever, with type level marking, like IO
21:38:18 <Maxdamantus> So you'd have bounded pointers.
21:38:20 <LordBrain> once i have that, it seems a shame if we cant build IO out of these lower level things
21:39:00 <Maxdamantus> When you run a driver you pass it something it can use to dereference memory with a particular address range.
21:39:15 <Maxdamantus> and from that you can produce similar things that can be used to dereference subranges of that, etc
21:39:25 <LordBrain> okay
21:39:26 <Maxdamantus> (that would be a form of object capabilities)
21:40:15 <LordBrain> yeah, regions is the term i've heard in the past, same sort of idea
21:40:26 <Costar> Hi all
21:40:27 <LordBrain> maybe regions is more a generalization tho
21:41:21 <Maxdamantus> "regions" seems more vague. I'd be inclined not to use it to refer to global addressing.
21:41:58 <Maxdamantus> eg, ST, since you don't know what memory ST uses, just as you don't know what memory normal expression evaluation uses.
21:42:22 <LordBrain> well, the way i imagine it, this would be more exposed tho
21:42:50 <LordBrain> you dont know in standard haskell, but in this hypothetical personal ideal implementation you may know
21:44:40 <LordBrain> its somethign that i've wanted a long time, but i'm not sure if i will ever work on it now..
21:45:09 <ongy> Hi Costar 
21:50:18 <MarLinn> LordBrain: What would be the smallest next step towards such a hypothetical system?
21:51:32 <begriffs> I have a function (a -> IO a) and a record with a field of type a. How do I use a lens to update the field with my function?
21:52:21 <nitrix> <<~ probably
21:52:41 <LordBrain> MarLinn, if you want my personal ideal.. well, a very useful contribution would be to implement regions based on the effect-monad package
21:53:00 <LordBrain> so a variation of the regions package which makes use of type level sets
21:53:58 <nitrix> begriffs: Alternatively, <~
21:54:16 <MarLinn> but wouldn't you need a representation of regions as coeffects as well?
21:54:26 <LordBrain> i've already have some code set asside for an assembler that is source compatible wiht ghc, but it would be cool to have it in a regions like monad, but using type level sets ala effect-monad
21:54:35 <glguy> begriffs: yourLens yourFunction
21:55:42 <LordBrain> yes
21:56:00 <LordBrain> well, i think that is compatible with effect-monad
21:57:38 <begriffs> What lens do I use to set a field in a record? (Sorry, it's my first time with all this stuff)
21:58:02 <LordBrain> its a lot to chew
21:58:08 <LordBrain> but it should all be doable
21:58:48 <LordBrain> effect monad almost has it in a way, if you look at its variables with read write permissions and stuff
21:59:17 <LordBrain> what's a variable but a bit of memory after all
21:59:31 <glguy> begriffs: You'll need to make a lens corresponding to the fields in your record, possibly using Template Haskell and makeLenses, or defining them yourself
21:59:41 <LordBrain> well some variables are registers, but what are registers but memory on the cpu anyway
22:00:16 <begriffs> glguy: hm, I think I'll just write code that is less fancy!
22:00:40 <LordBrain> just look at the lens type
22:00:53 <LordBrain> you can write the lenses you need manually
22:01:25 <LordBrain> the template haskell stuff is to make it more convenient automatic, but if you're only interested in a particular field or whatever, thats not much 
22:52:36 <Cooler> LordBrain, what exactly would you be able to do with finer grained control?
22:52:49 <Cooler> prove stuff about drivers?
22:54:17 <LordBrain> well, you could substitute sometimes static gaurantees in place of run time ones, so for example, you could run code with escalated privilege without loss of security barrier, avoid penalties for context switches, but really its more the power than the specifics that i want.
22:59:13 <Cooler> LordBrain, would such a language model the hardware?
23:00:09 <LordBrain> certain aspects... things that you pretty much take for granted anyway, like the fact that you have a cpu and you have ram
23:07:01 <MarLinn> Cooler: Depending on how it's done you might be able to get compile-time information about what hardware machines need to run your program. E.g. do you need bluetooth? >=4GB ram? GPS?
23:11:32 <MarLinn> You could argue that both aspects are a bit orthogonal, but then if you want one, odds are you want the other on the same level without yet another indirection
23:15:28 <Cooler> LordBrain, you mentioned variables are ram and/or registers
23:15:33 <Cooler> theres also cache
23:18:55 <youser> hello friends
23:41:32 * hackagebot wai-extra 3.0.17 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.17 (MichaelSnoyman)
23:41:34 * hackagebot yesod-bin 1.4.18.3 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18.3 (MichaelSnoyman)
23:42:20 <Cooler> what package do you use for networking?
23:44:36 <ertes> Cooler: for what exactly?
23:45:38 <Cooler> ertes, just learning basics
23:45:53 <Cooler> something like a http server
23:46:15 <Axman6> that's very different from what would usually be considered networking
23:46:26 <Axman6> what exactly do you want to do?
23:46:37 <cocreature> do you want to write an http server or use one?
23:47:23 <LordBrain> Cooler, the network package is the old tried and true staple, its basically just a wrapper on sockets api, if you mean fancier there is the new fangled cloud haskell stuff
23:48:21 <cocreature> there is also a “socket” package. iirc I found the API to be a bit nicer than the one of network last time I looked at it
23:57:37 <ertes> (i wanted to avoid answering "network")
23:57:53 <ertes> (in 99/100 cases it's the wrong answer)
23:58:12 <cocreature> well if you want to write an http server it might be the right answer
23:58:41 <ertes> with happstack-server, snap-server and warp around?
23:59:07 <cocreature> he said he wanted to do it for learning purposes so the fact that there are existing http servers doesn’t change anything
23:59:50 <ertes> Cooler: so what would you like to learn?
