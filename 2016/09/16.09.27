00:00:33 <ocramz> does GHC build and run on Xeon Phi chips?
00:00:39 <Lokathor> it is the middle of the night
00:01:21 <liste> ocramz: I don't see why not, it's x64 right?
00:01:21 <ocramz> hi Lokathor , here it's 9 AM (GMT +1)
00:01:54 <Lokathor> hello, it's GMT-6 or -7 (i forget which; daylight savings)
00:03:04 <ocramz> liste : yes I guess it looks like an x86 from the outside
00:03:26 <ocramz> however I know it can be programmed to use very fine grained threading and cache use
00:03:34 <nshepperd1> jle`: is ++ a type family there? I don't think it can reason backwards like that unless it's one of the newfangled injective type families?
00:04:21 <jle`> nshepperd1: i got the singletons available, but yeah i ended up going another route
00:04:24 <jle`> thanks tho!
00:04:28 <ocramz> I'm not an Intel employee but 72 cores in a package sounds like a match made in heaven for green threads
00:05:47 <ocramz> I'd be curious to know if anyone ran any Xeon Phi + GHC benchmarks
00:07:36 * hackagebot wire-streams 0.1.1.0 - Fast binary io-streams adapter.  https://hackage.haskell.org/package/wire-streams-0.1.1.0 (winterland)
00:07:36 * hackagebot monoid-subclasses 0.4.3 - Subclasses of Monoid  https://hackage.haskell.org/package/monoid-subclasses-0.4.3 (MarioBlazevic)
00:08:22 <intothem1untains> How should I define a data type where I can choose between some values? data Direction = (1, 0) | (1, -1) | (0, -1) | …
00:08:41 <intothem1untains> Kind of a limited type synonym
00:08:51 <Koterpillar> intothem1untains: data Direction = N | NW | W | NE | ...
00:09:16 <intothem1untains> Koterpillar: I did that in the past, but how can I associate these values with it?
00:09:23 <Koterpillar> make a function
00:09:37 <Lokathor> directionToPair :: Direction -> (Int,Int)
00:09:46 <Koterpillar> or two functions
00:09:46 <intothem1untains> mh, fair enough!
00:09:52 <liste> intothem1untains: what Koterpillar said, but in general, "(Int, Int) -> Maybe Direction"
00:10:21 <Lokathor> if you don't care about the specific magnitude of the inputs, you can even have (Int,Int) -> Direction
00:10:52 <Koterpillar> Lokathor: (0, 0)
00:11:25 <Lokathor> ah, hm, guess it depends on if you have a direction for neutral in the datatype
00:11:35 <Lokathor> fair point
00:18:16 <enis_> I think the best would be (Int, Int) -> Either (Maybe Direction) Direction, (Right Direction) for nice inputs like (1,1), (Left Just Direction) for meh inputs like (2,1) and Nothing for really nasty ones like (0,0)
00:18:39 <Koterpillar> enis_: don't abuse Either and Maybe
00:18:54 <Koterpillar> enis_: just make another type you can pattern match on :)
00:19:33 <enis_> data PossibleDirection = Fine Direction | Meh Direction | Nasty
00:19:44 <Koterpillar> much better.
00:19:57 <liste> enis_: why not data Possible a = Fine a | Meh a | Nasty (:
00:34:32 <jle`> Maybe (Bool, a)
00:34:35 <jle`> type algebra is fun
00:35:48 <jle`> `Either (Maybe a) a` == (a + 1) + a == (2*a) + 1 == `Maybe (Bool, a)`
00:37:31 * hackagebot standalone-haddock 1.1.4.5 - Generate standalone haddock documentation for a set of packages  https://hackage.haskell.org/package/standalone-haddock-1.1.4.5 (RomanCheplyaka)
01:23:04 <khouli> hi
01:23:13 <liste> hi khouli 
01:23:41 <khouli> why hello there liste
01:26:50 <khouli> knowledgable people, I beseech you: how do I figure out where ghci loads modules from? where do I find the source code of builtin modules?
01:29:27 <liste> khouli: if you mean the `base' package, here: https://hackage.haskell.org/package/base, by clicking open a module and then the "source" option in top right
01:29:39 <grantwu> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html
01:30:03 <liste> khouli: ghc has a bunch of packages preinstalled and you can install more of them with cabal-install
01:31:13 <mstruebing> is there a docker image with stack integrated?
01:31:31 <khouli> nice, I hadn't noticed that on haskell.org, thanks
01:32:16 <khouli> what about on a typical linux install? how do I find the base package?
01:32:40 <Reshi> khouli: If you want the source on your system maybe `ghc --print-libdir`
01:33:33 <khouli> Reshi: perfect, thank you!
01:33:49 <Reshi> khouli: no worries :)
01:33:59 <liste> khouli: note that the packages are compiled, so you won't be finding any .hs files
01:35:23 <khouli> liste: you read my mind! so where they downloaded pre-compiled or are the source files hiding somewhere else?
01:35:36 <liste> khouli: probably downloaded pre-compiled
01:37:32 * hackagebot haiji 0.2.0.0 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.2.0.0 (NoriyukiOhkawa)
01:37:34 * hackagebot elm-export 0.4.1.1 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.4.1.1 (krisajenkins)
01:39:31 <enis_> khouli: If you intend to read the sources of specific functions in the base, you could hoogle those functions and access the source from the haddock
01:44:50 <Unhammer> if l is long and s is short, what's the fastest of l++s and s++l?
01:45:31 <khouli> enis_: I'm essentially a total beginnner, I just finished installing hoogle; does one typically use hoogle online or on the command line?
01:46:22 <lyxia> Unhammer: s++l, though laziness makes the comparison a bit trickier
01:47:00 <lyxia> Unhammer: if you only ever use a prefix that shorter than s, then both will take as much time
01:47:14 <Unhammer> ok, thanks lyxia. Well, I'm assuming the whole result is eventually run-through …
01:47:47 <liste> khouli: both, whichever is more handy (:
01:47:59 <liste> khouli: you can customize the database of a command-line hoogle though
01:48:06 <liste> khouli: we also use hoogle thru lambdabot
01:48:14 <liste> @hoogle (a -> b) -> [a] -> [b]
01:48:18 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
01:48:18 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
01:48:18 <lambdabot> GHC.OldList map :: (a -> b) -> [a] -> [b]
01:48:51 <grantwu> lyxia: Can't list fusion make things just as fast
01:48:58 <grantwu> Depending on the whole program
01:50:10 <lyxia> hmm that sounds possible
01:56:50 <intothem1untains> What should I do when I'm using a (a -> Maybe b) function I wrote that in this particular case if guaranteed to return Just? The function where I'm using it doesn't return a Maybe a
01:57:13 <intothem1untains> fromJust?
01:57:32 <merijn> intothem1untains: Why is it returning Maybe if it can always return Just?
01:58:25 <khouli> do folks have any strong opinions about "Real World Haskell"? it seems good even if it's heavy on the propaganda ((in the past I quickly went through "Learn You a Haskell for Great Good" a few months ago but since then it was more convenient to stick to languages I know and I've forgotten a bit)
01:58:30 <intothem1untains> merijn: the function f returns a Maybe, but the function g, which uses f, doesn't, because in the particular case where g uses f, it is not possible to get Nothing back
01:58:58 <merijn> intothem1untains: the *proper* way to do thing would be
01:59:00 <merijn> :t fromMaybe
01:59:02 <lambdabot> a -> Maybe a -> a
01:59:05 <merijn> or, alternatively
01:59:07 <merijn> :t maybe
01:59:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
01:59:21 <liste> khouli: I learned from it and am happy, but it's outdated in some parts
01:59:40 <intothem1untains> merijn: but what can i offer as a default? and, in the event the impossible happens, is it not better to be loud about it and break than just keep running?
01:59:44 <merijn> khouli: A bit dated, parts have bit-rotted, but still a reasonable introduction to the high-level design of many libraries
01:59:54 <merijn> intothem1untains: That depends on your specific situation
02:00:09 <merijn> intothem1untains: I would say that if there is a sane default then not crashing is preferable
02:00:43 <khouli> sounds like I should stay the course then; are there strong suggestions for where to follow up?
02:00:53 <merijn> khouli: For example, the parsec chapter is for parsec 2, rather than parsec3 or megaparsec, so the code won't run as-is. But the high level design of parsec3 and megaparsec and attoparsec are similar enough that it's still useful
02:00:58 <liste> intothem1untains: and in case of crashing, a more descriptive error is preferable to *Prelude.fromJust
02:01:00 <intothem1untains> I'm reversing a group of marbles - which is a starting position and a direction - so i guess i could return the same group back, but that's not really a sane default
02:01:07 <intothem1untains> liste: that's true
02:01:09 <liste> > fromJust Nothing
02:01:11 <lambdabot>  *Exception: Maybe.fromJust: Nothing
02:01:25 <merijn> khouli: I do think it's not particularly great for learning the language, so I tend to recommend it only as reference for libraries
02:01:28 <lyxia> I hope we'll soon get fromJust :: HasCallStack => Maybe a -> a
02:01:45 <merijn> intothem1untains: Which function is returning Maybe, and why?
02:02:05 <intothem1untains> reverseGroup = fromJust . toGroup . reverse . fromGroup
02:02:27 <intothem1untains> toGroup there is returning Maybe, because it is possible that a list of coords isn't a valid group
02:03:09 <merijn> And what is a group?
02:03:19 <khouli> merjin: is there a strong alternative? (my previous experience is mostly C++ and Python if that makes a difference)
02:03:28 <intothem1untains> merijn: essentially a starting position and a direction
02:03:47 <intothem1untains> (because all the coords in a group must be contiguous and aligned)
02:04:34 <intothem1untains> data Group = Mono Coord | Di Coord Direction | Tri Coord Direction
02:04:44 <intothem1untains> So the constructors represent how many marbles the group has
02:04:45 <merijn> khouli: I have heard a lot of good things about the Haskell book (but then also a bunch of complaints), there's also "Introduction to Functional Programming using Haskell" and "Thinking Functionally with Haskell" both by Richard Bird
02:05:18 <merijn> khouli: Did you do enough C++ to look at the C/C++ language standards?
02:05:46 <merijn> intothem1untains: And what does "fromGroup" do?
02:05:58 <intothem1untains> returns a list of coords given a group
02:07:20 <merijn> hmm, I don't see a particularly good way to do that differently, you better be very sure that reversing a group always produces a valid group, though :)
02:08:14 <intothem1untains> yeah, i guess ideally i shouldn't use toGroup, because that implies validation, which shouldn't be needed when reversing an existing group
02:09:27 <merijn> intothem1untains: Right, but with the existing definition of Group you can't really do something like mapping directly over the group, afaict (not sure what Coord and Direction are)
02:09:33 <khouli> merjin: I have a copy and I've looked up specific facts but I don't find standardese easy to read; I think an honest assessment compared the "average" C++ programmer is that I'm intermediate/advanced (but I'm hesitant to say that since I'm painfully aware of how much more there is to know)
02:10:11 <intothem1untains> merijn: type Coord = (x, y); data Direction = NE | E | SE | SW | W | NW
02:10:45 <khouli> merjin: what is the Haskell book? (author/website/link?)
02:11:16 <merijn> khouli: Right, the C standards are horrific, but if you've managed to parse parts of it, you could also try reading the Haskell Report (the Haskell) standard, which you'll find is orders of magnitude more readable :)
02:11:31 <merijn> khouli: Which can be found here: https://www.haskell.org/onlinereport/haskell2010/
02:11:44 <merijn> khouli: The Haskell book is here: http://haskellbook.com/
02:12:47 <khouli> merjin: ha, good to know it's worth trying; from C and C++ my gut reaction is that standards are not meant for mortals
02:13:04 <merijn> khouli: I've just noticed that some people used to C++'s masochism like reading the Haskell Report and then go to books. It's not something I'd recommend for someone having only done JS or something. But compared to the C standard the report is a breeze :)
02:14:00 <merijn> intothem1untains: Yeah, then I don't really know how to it differently :)
02:15:04 <merijn> I actually think more people should read the report in general, it's full of interesting tidbits and it makes clear that the language is actually a lot more consistent then many beginners seem to think
02:16:40 <khouli> merjin: well the Haskell Report does look surprisingly short compared to the 1500+ pg C++14 door stop; from a skim it's hard to believe that this specifies the language honestly
02:17:55 <merijn> khouli: Well, Haskell leaves a lot of the details up to the implementation and isn't too obsessed with low level details like memory layouts, so that helps :)
02:18:01 <{AS}> Is there a reason I can't import some names unqualified, and the rest of a module qualified in one sentence in Haskell?
02:18:31 <{AS}> like I have to use: `import Data.Map (Map); import qualified Data.Map as Map` now
02:18:51 <merijn> {AS}: "No one thought of that"
02:19:01 <merijn> {AS}: There was a proposal to remedy that a while back
02:19:01 <srhb> Or no one thought it necessary.
02:19:10 <merijn> Not sure if that's still alive
02:19:12 <{AS}> Oh, interesting
02:19:56 <merijn> So, is there a reason? Not really
02:19:56 <{AS}> Thanks
02:20:13 <khouli> does any implementation besides ghc have significant "market share"?
02:20:14 <{AS}> merijn: do you know what the proposal was named?
02:20:23 <{AS}> khouli: I think UHC a bit?
02:20:45 <{AS}> Hugs was popular a while ago, but I think it's unmaintained now
02:21:34 <srhb> Not sure if the Intel one is still alive.
02:22:12 <{AS}> srhb: What Intel one? 
02:23:04 <kqr> is there a convenient way to apply an operation to a value wrapped in a newtype? i.e. no explicit boxing/unboxing
02:23:30 <{AS}> kqr I think there are some libraries for that
02:23:59 <{AS}> Like lens
02:24:13 <srhb> {AS}: The Intel Haskell compiler. Not sure if it has another name.
02:24:20 <srhb> {AS}: It's internal anyway, afaik.
02:24:20 <{AS}> Ah thanks
02:24:25 <khouli> srhb: was the intel one publicly available? is this the one used in the ninja gap paper?
02:24:33 <srhb> khouli: No and yes.
02:24:39 <srhb> Or I think so, yes :-)
02:24:39 <{AS}> I thought it was a response to my question
02:24:43 <merijn> khouli: UHC and Mu, except Mu's market share is all internal and proprietary :)
02:24:53 <merijn> khouli: Intel had a Core to machine code compiler
02:25:04 <merijn> srhb: Intel didn't have a Haskell compiler
02:25:16 <kqr> {AS}, ah yes, Control.Newtype seems to export just the newtypey bits of lens
02:25:20 <merijn> srhb: They had a compiler that took GHC's Core and compiled that to machine code
02:25:27 <ongy> https://www.reddit.com/r/haskell/comments/4hokvy/is_there_any_way_to_get_my_hands_on_intels/ seems relevant
02:25:29 <merijn> kqr: coerce?
02:26:17 <kqr> merijn, maybe that's what I'm looking for
02:27:00 <khouli> ongy: nice link; that top comment is so mysterious, lol
02:28:32 <ongy> :t coerce
02:28:34 <lambdabot> error: Variable not in scope: coerce
02:29:03 <{AS}> I would guess their original purpose might have been something with the language they are doing at Epic?
02:29:40 <{AS}> It would make sense that they did a low-level compiler
02:29:48 <merijn> {AS}: Not sure they had a purpose. I was at a conference a few weeks after that compiler was published with some Intel people using Haskell who didn't even know other people at Intel were using Haskell :p
02:30:55 <narff> is there a way to automatically limit imported functions based on the actual use in the code? 
02:31:17 <srhb> merijn: Ah, thanks :)
02:31:19 <{AS}> merijn: http://www.leafpetersen.com/leaf/publications/dtp2013/lambda-aleph-overview.pdf <- same authors
02:31:21 <merijn> narff: What does that mean?
02:31:31 <tdammers> you mean, auto-edit imports to only include the functions you actually use?
02:31:38 <grantwu> narff: GHC can warn about unused imports, if that's what you mean
02:31:53 <{AS}> They were try to develop a dependently-typed language
02:31:58 <{AS}> I am not sure whatever happened to it
02:32:06 <narff> tdammers: yes
02:32:41 <{AS}> I would say it's not a totally bad guess, that their repurposed compiler for Haskell core was originally meant for that language
02:36:48 <kqr> is there a data structure that expresses isomorphism? something like a Data.Map, except you can look up both ways (and both keys and values are unique)
02:37:49 <kqr> ah yes, data.bimap
03:06:15 <lostman> hi all. got a question about MIN_VERSION macros: they accept three arguments. What do I do for libraries like template-haskell that require four? MIN_VERSION_template_haskell(2,11,0,0) won't work...
03:08:31 <jchia1> I want to make my own type that I can apply my own (+) and (-) functions to but I don't want to make it an instance of Num. I simply can't use my (+) and (-) together with those from Prelude unqualified, correct?
03:08:48 <pacak> lostman: Specify only first three?
03:09:21 <pacak> jchia1: Correct.
03:13:21 <lostman> pacak: hmm... can try. seems like an odd thing to do
03:14:06 <pacak> lostman: Change in the last digit shouldn't create any problems.
03:14:36 <pacak> lostman:  https://wiki.haskell.org/Package_versioning_policy
03:15:57 <lostman> pacak: cool. look like it works. got my code compiling with both ghc-7.6.3 and ghcjs-8.0.1 :)
03:17:06 <lostman> pacak: thanks a lot!
03:19:06 <eklavya> please help, there is a problem somewhere and I can't figure out where, how do I find out which mvar gets stuck where and when?
03:22:13 <NickHu> For sake of analogy, is it true that you can implement list comprehensions without the predicate filtering stuff with just Applicative, but for that stuff you need Monad?
03:23:43 <Rembane> NickHu: Is "that stuff" the filtering?
03:23:47 <NickHu> Yes
03:24:10 <NickHu> Ignore shims with how you can do it with more functions or using more advanced features
03:24:24 <NickHu> I'm just trying to illustrate some of the "obvious" differences between applicative and monad
03:24:35 <hpc> > [(x, y) | x <- [1..5], y <- [1..x]] -- no filtering, can't be done with applicative
03:24:38 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
03:24:43 <pacak> Applicative preserves shape of the container.
03:25:05 <pacak> (,) <$> [1..5] <*> [1..5]
03:25:08 <pacak> > (,) <$> [1..5] <*> [1..5]
03:25:10 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
03:25:17 <hpc> that contains (1,2) and my example doesn't
03:25:31 <NickHu> hpc: Ah, by filtering I did mean to also include depending on previously drawn values too
03:25:32 <hpc> note that y is from [1..x]
03:25:35 <NickHu> Sorry, I asked poorly
03:25:56 <pacak> hpc: Right. Because shape.
03:26:24 <NickHu> pacak: I don't understand this shape argument
03:27:42 <pacak> NickHu: If you have a computation of some shape - let's say 10 element list or Just value using applicatives resulting computation will have the same shape.
03:28:48 <NickHu> I see
03:28:57 <ski> > (,) <$> [0 .. 9] <*> [0 .. 9]  -- not a list of ten elements
03:29:00 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1,...
03:29:51 * ski would express it as `Applicative' being about static sequencing, and `Monad' about dynamic sequencing
03:30:16 <pacak> ski: That's combination of two computations.
03:30:38 <ski> it's a single computation, that's a combination of two computations, yes
03:31:09 <NickHu> So, if you had a list comprehension where each drawn element was independent of the others, and there was no filtering by predicate, that is always expressible in terms of Applicative combinators right?
03:31:32 <ski> yes
03:31:42 <NickHu> Thanks for clearing that up
03:31:58 <pacak> NickHu: list comprehension is just a fancy syntax for monad stuff.
03:32:07 <NickHu> Actually, could you do the predicate filtering stuff with just applicatives?
03:32:09 <NickHu> pacak: I know this
03:32:14 <ski> the structure of later effects doesn't depend on the intermediate values computed by earlier ones
03:32:27 <ski> (so "static sequencing")
03:32:33 <ski> <http://neilmitchell.blogspot.de/2014/07/applicative-vs-monadic-build-systems.html>
03:32:51 <ski> NickHu : no
03:33:21 <NickHu> Oh yes of course because the filtering is applied to each element as it's drawn rather than the resulting product list
03:33:49 <ski> `[... | x <- xs , p x]' is `[... | x <- xs , _ <- if p x then [()] else []]'
03:34:06 <ski> @src guard
03:34:06 <lambdabot> guard True  = pure ()
03:34:06 <lambdabot> guard False = empty
03:35:04 <NickHu> :t empty
03:35:05 <lambdabot> Alternative f => f a
03:35:07 <pacak> NickHu: In monad you can filter on intermediate computations as well
03:35:16 <NickHu> pacak: Yes I realise this
03:35:27 <pacak> [(x, y) | x <- [1..5], y <- [1..x], x /= y]
03:35:30 <pacak> > [(x, y) | x <- [1..5], y <- [1..x], x /= y]
03:35:30 <NickHu> Which is why you can do all of list comprehensions with monad
03:35:33 <lambdabot>  [(2,1),(3,1),(3,2),(4,1),(4,2),(4,3),(5,1),(5,2),(5,3),(5,4)]
03:36:58 <NickHu> ski: Do you mean to imply that if you had Alternative you could do list comprehensions with predicate filtering?
03:37:20 <ski> no
03:37:41 <ski> you need `Monad' in order to depend on the earlier result `x'
03:38:11 <liste> > [(x, y) | x <- [1..5], y <- [1..x]]
03:38:14 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
03:39:08 <NickHu> ski: Yes I understand that
03:39:27 <pacak> Alternative is just a monoid for Applicative
03:39:36 <NickHu> But could you do something like [... | x <- xs, p x] with Alternative?
03:39:41 <ski> you can't do filtering without having the predicate depend on the items you want to apply the filtering to
03:39:47 <NickHu> I see
03:40:00 <pacak> :info Alternative
03:40:10 * pacak pokes lambdabot
03:40:11 <NickHu> pacak: I know what Alternative is
03:40:17 <ski> lambdabot has no `info' command
03:40:30 <ski> @info [(x, y) | x <- [1..5], y <- [1..x]]
03:40:30 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [1 .. x]) [1 .. 5]
03:41:31 <NickHu> oh neato that's pretty cool
03:41:31 <pacak> empty is mempty and (<|>) is mplus
03:41:48 <NickHu> and ofc concatMap is bind for the list monad
03:58:22 <{AS}> Is there a f (a -> b) -> f (b -> c) -> f (a -> c) ? 
03:58:37 <{AS}> applicative/monadic compose operator
03:58:53 <{AS}> Hoogle didn't give me a useful answer
03:59:13 <MarcelineVQ> hayoo has some interesting prospects http://hayoo.fh-wedel.de/?query=f+(a+->+b)+->+f+(b+->+c)+->+f+(a+->+c)
03:59:27 <MarcelineVQ> that link may not work as written depending on your client
03:59:41 <{AS}> Thanks
03:59:49 <ski> @type liftA2 (.)
03:59:51 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
04:00:15 <ski> @type (>=>)
04:00:16 <{AS}> ski: Thanks
04:00:17 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:00:47 <{AS}> We need a search tool that combines the terms for you
04:01:18 <MarcelineVQ> a search + djinn sort of thing?
04:01:31 <ski> "combines the terms" ?
04:01:58 <{AS}> Yeah like what MarcelineVQ said
04:03:14 <merijn> If only our compiler could auto-suggest code for our types...
04:03:26 <{AS}> merijn: Exactly
04:03:38 <merijn> {AS}: You might wanna look a Conor McBride's PhD thesis and work on Epigram ;)
04:03:51 <{AS}> merijn: I know it's possible :)
04:04:00 <{AS}> I meant I want it for Haskell
04:04:05 <{AS}> but thanks for the pointer!
04:04:37 * ski idly wonders where {AS} wants to use such an operator
04:06:37 <merijn> Incidentally isn't that just liftA2 (>>>)
04:06:40 <merijn> :t liftA2 (>>>)
04:06:42 <lambdabot> forall k (f :: * -> *) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). (Category cat, Applicative f) => f (cat a b) -> f (cat b c) -> f (cat a c)
04:06:46 <merijn> eh...
04:06:52 <merijn> scarier than intended
04:07:19 <merijn> :t liftA2 (>>>) `asAppliedTo` (undefined :: f (a -> b))
04:07:20 <lambdabot> Applicative f => f (a -> b) -> f (b -> c) -> f (a -> c)
04:07:43 <ski> `(>>>) = (.)', yes
04:09:01 <merijn> No
04:09:06 <merijn> >>> = flip (.)
04:09:10 <merijn> :t (.)
04:09:11 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:09:15 <merijn> :t (>>>)
04:09:17 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
04:10:21 <ski> er, right. the other way around
04:16:27 <{AS}> I get a weird error when trying @check \(f,g) -> (flip f == g) ==> (flip g == f)
04:17:11 <srhb> {AS}: Is it that there's no Eq for functions?
04:17:26 <srhb> {AS}: Otherwise you might want to tell us what it is :-P
04:17:55 <{AS}> That is true
04:18:11 <{AS}> Well I can define Eq for Bool -> Bool
04:18:59 <{AS}> or for any two total functions of type ‹Finite Type› -> R
04:24:49 <ski> (your property is equivalent to `flip . flip = id', btw)
04:27:33 <tdammers> but telling total from partial functions isn't something the type system can do
04:28:03 <merijn> tdammers: In haskell... ;)
04:29:03 <tdammers> merijn: of course
04:37:36 * hackagebot ngx-export 0.1.1.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.1.1.0 (lyokha)
04:37:38 * hackagebot foldl-statistics 0.1.4.0 - Statistical functions from the statistics package implemented as  Folds.  https://hackage.haskell.org/package/foldl-statistics-0.1.4.0 (AlexMason)
04:40:58 <{AS}> ski: Yeah, I guess
05:02:02 <srhb> Were the Summer of Haskell results postponed, or did I miss them?
05:03:14 <Darwin226> Hey guys. A question. If we imagine that MonadState didn't have a fundep then code like this `f :: MonadState Int m => m (); f = put 1` wouldn't compile because the compiler doesn't know that the 1 is an `Int`
05:03:18 <Darwin226> But since the signature of `f` is explicitly given, 1 being anything other than `Int` is an error. Is there a way to express this?
05:03:54 <Darwin226> (the code above might actually compile due to defaulting, let's ignore that)
05:05:57 <Darwin226> a snarky reply would be "yes, with a fundep" but then we can't have more than one state. Ideally we could have multiple states and then be forced to annotate the functions, but if we only have one it should behave as if
05:05:59 <Darwin226> we have a fundep
05:06:08 <Darwin226> At least in the presence of a type signature.
05:06:19 <merijn> Darwin226: How would you disambiguate which state "put" should affect?
05:06:41 <Darwin226> merijn: The type signature only permits a single state in this case so there is no ambiguity
05:06:59 <Darwin226> If you had more than one then you'd need to annotate
05:07:23 <merijn> Darwin226: What if 'm' has multiple "StateT Int" entries?
05:08:02 <Darwin226> That wouldn't be allowed
05:08:03 <merijn> Darwin226: The type signature does not permit a single state, it permits a single *type* of state
05:08:09 <merijn> Darwin226: How?
05:08:23 <Darwin226> The instance would match the first StateT Int
05:08:35 <Darwin226> the search wouldn't continue past that
05:08:55 <Darwin226> I mean this is how it works now, except it stops at ANY StateT and then errors if the type doesn't match
05:09:39 <merijn> I'm still not quite sure how you intend this to work
05:10:24 <Darwin226> So basically, `put (1 :: Int)` in the above example would work, right?
05:10:49 <Darwin226> But `put (1 :: T)` for any concrete type `T` that's not `Int` would error
05:11:09 <Darwin226> It then makes sense to me that the type annotation is pointless
05:11:11 <merijn> What does "concrete" mean
05:11:48 <Darwin226> I don't mean it in any formal sense, though I guess there may be problems with polymorphic states
05:12:26 <ski> @let class Monad m => MS s m where msput :: s -> m ()
05:12:28 <lambdabot>  Defined.
05:12:42 <lyxia> So you want a defaulting rule that selects a type because it's the only one that can make instance resolution work.
05:12:44 <ski> @type let f :: MS Int m => m (); f = msput 1 in f
05:12:46 <lambdabot> error:
05:12:46 <lambdabot>     • Could not deduce (MS s0 m1) arising from a use of ‘msput’
05:12:46 <lambdabot>       from the context: MS Int m
05:12:52 <ski> @type let f :: MS Int m => m (); f = msput (1 :: Int) in f
05:12:56 <lambdabot> MS Int m => m ()
05:12:57 <ski> @type let f :: MS Int m => m (); f = msput (1 :: Integer) in f
05:13:02 <lambdabot> error:
05:13:02 <lambdabot>     • Could not deduce (MS Integer m1) arising from a use of ‘msput’
05:13:02 <lambdabot>       from the context: MS Int m
05:13:14 <lyxia> but that becomes incorrect if you define "instance MonadState s m"
05:13:15 <Darwin226> lyxia: Indeed
05:13:39 <Darwin226> What do you mean?
05:14:11 <lyxia> well then there are two overlapping instances in scope, the global MonadState s m, and the "local" MonadState Int m from the type signature
05:14:40 <Darwin226> Why would you define an overlapping instance?
05:15:30 <lyxia> I dunno
05:16:03 <merijn> Darwin226: Without an overlapping instance you can't define the generic recursive instance that makes "put" Just Work
05:16:14 <Darwin226> Also, just look at that error above. "Could not deduce MS s0 m1 from MS Int m"... Maybe there could be an extension that would take this and say "ok then, s0 ~ Int, m1 ~ m"
05:16:58 <Darwin226> merijn: Right.. You need one for the StateT that DOESN'T hold the correct type. Ok. So why would that be a problem?
05:17:08 <Darwin226> (besides he usual objections to overlapping instances)
05:18:19 <merijn> Darwin226: How do you make get/modify work?
05:18:51 <Darwin226> merijn: Is there a problem you forsee?
05:19:17 <merijn> Darwin226: modify with polymorphic functions, get passing results to polymorphic functions
05:20:22 * ski isn't quite sure what Darwin226 is suggesting ..
05:21:19 <merijn> ski: "magic" resolution for multiple StateT in the same stack that "Just Works"
05:21:34 <merijn> Which, would be partially doable for, say, put
05:22:05 <merijn> But it breaks down rather harshly and quickly when you use polymorphic state, use polymorphic functions to produce state, etc.
05:23:55 <tdammers> I, for one, much prefer the lesser pain of lifting explicitly
05:25:20 <lyxia> the point is that in practice there are cases where lifting explicitly shouldn't be necessary because the programmer's intent can be deduced
05:25:40 <Darwin226> merijn: I still don't see what the problem with with get is. In fact I have this "effect" library that implements state without a fundep and it works fine with annotations.
05:25:41 <lyxia> it's just not a principled solution
05:25:45 <{AS}> Is there a reason why, Haskell being a type safe language is exceptionally unsafe?
05:26:03 <merijn> Darwin226: Ok so what's the type of get?
05:26:07 <{AS}> I see many functions calling "error"
05:26:21 <{AS}> instead of throwing a typed exception
05:26:22 <merijn> {AS}: Historical accident and convenience
05:26:34 <merijn> {AS}: error throws an exception
05:26:36 <Darwin226> MonadEffect (GetState s) m => m s
05:26:50 <{AS}> merijn: Yeah, but it's like throwing RuntimeException everywhere :)
05:27:05 <{AS}> Instead of throwing something typed
05:27:26 <merijn> {AS}: Partial functions are generally considered poor form to use
05:27:36 <{AS}> merijn: I understand this
05:27:52 <{AS}> but using the total / maybe ones is a pain sometime
05:28:13 * ski would like an algebra of labelled, sometimes commuting, monad transformers, being reflected in the type systems
05:28:19 <ski> s/systems/system/
05:28:33 <{AS}> Especially when sometimes my things are really dependently typed
05:28:49 <{AS}> but I can't/don't want to use dependent types in Haskell
05:28:55 <merijn> {AS}: Well, didn't you answer your own question there?
05:29:13 <{AS}> merijn: I did?
05:29:35 <merijn> Why are there so many partial functions? "Because the total/ maybe ones are a pain sometimes"
05:29:46 <{AS}> That was not my question
05:29:55 <{AS}> My question was why aren't there typed exceptions :)
05:30:14 <merijn> {AS}: Ok, so what would the advantage of throwing typed exceptions be, according to you?
05:30:23 <{AS}> It's easier to catch
05:30:43 <tdammers> there are typed exceptions, it's just that not a lot of library code out there uses them
05:30:50 <merijn> {AS}: They're not.
05:30:52 <lyxia> It's easier to propagate than to catch
05:31:08 <{AS}> It is easier to catch a subset of them
05:31:11 <merijn> {AS}: Exceptions thrown in pure code (like error) are notoriously impossible to catch, to the point you're better of not trying
05:31:26 <{AS}> merijn: what do you mean?
05:31:30 <merijn> "throw" is effectively worthless if you plan to do anything other than crashing
05:31:52 <merijn> {AS}: Due to laziness exceptions thrown with "throw" can trivially escape out of the scope of a try/catch
05:32:04 <{AS}> merijn: Oh
05:32:10 <{AS}> Laziness or purity?
05:32:13 <merijn> The only way that you can reliably catch exceptions with try/catch is if they are thrown using throwIO
05:32:33 <merijn> {AS}: Laziness, the exception isn't raised until "error" (or "throw") is evaluated
05:32:47 <{AS}> So it would be possible in a strict language?
05:32:52 <merijn> {AS}: Yes
05:32:53 <tdammers> yes
05:32:58 <{AS}> Ah, thanks
05:33:21 <lyxia> I still think there is cool stuff to be done if we could distinguish errors. You could say "this thing throws a parseError when evaluated to WHNF"
05:33:26 <tdammers> it's similar to how passing lazy values through channels into other threads can lead to them being evaluated in an unexpected thread context
05:33:29 <lyxia> s/throws/may throw/
05:33:32 <merijn> {AS}: throwIO explicitly guarantees that the exception is thrown before the complete IO action completes, which means that "throwIO myError `catch` ..." will work
05:33:46 <merijn> lyxia: I was working on a prototype for that
05:33:54 <merijn> lyxia: But hard to find time
05:33:56 <{AS}> So the issue is basically that errors in pure non-strict semantics do not work well
05:34:01 <{AS}> because the time of evaluation is later?
05:34:22 <tdammers> purity has little to do with it, really; non-strict semantics is where the trouble arises
05:34:39 <{AS}> so why isn't catch "lazier" than the exception throwing?
05:34:49 <merijn> {AS}: Yes, so the only way to make it possible to reliably catch said errors is by using throwIO, which means the partial functions have to be in IO, which is obviously not acceptable for, e.g., head/tail
05:34:50 <ski> "when evaluated to WHNF" would be a fiddly thing to talk about in types, methinks
05:35:13 <tdammers> the catch would have to bind to the thunk somehow
05:35:26 <{AS}> tdammers: Yeah, exactly
05:35:45 * ski . o O ( continuations )
05:35:46 <merijn> ski: I had some sketches of a less partial language. So you could track *some* bottoms (exceptions), but not all (infinite recursion, because halting problem, etc.)
05:36:00 <tdammers> but that would mean that the catch itself would also have to be pure, or else you'll be violating the purity guarantee
05:36:14 <{AS}> tdammers: why would that be bad?
05:36:29 <tdammers> well, what would you want to do in the exception handler?
05:36:30 <merijn> {AS}: So the main reason so much code uses error is because, if they throw you can't reasonably catch them anyway, which means that having them typed is rather pointless
05:36:32 <ski> merijn : and you added annotation to type( expression)s for that ?
05:36:59 <{AS}> So thanks for the explanation :)
05:37:15 <{AS}> I didn't immediately see these issues
05:37:37 * hackagebot conduit-combinators 1.0.8 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.8 (MichaelSnoyman)
05:37:39 * hackagebot pandoc-vimhl 0.1.0.0 - Pandoc filter for native Vim code highlighting  https://hackage.haskell.org/package/pandoc-vimhl-0.1.0.0 (lyokha)
05:38:03 <merijn> ski: I was basically thinking about having two "parallel" type systems, one dealing with "values of things" and one dealing with "totality/throwing", so "throw" would have a "potentially throws exception X" annotation and expressions that (potentially) evaluate expressions like that ALSO potentially throw, etc.
05:38:19 <{AS}> tdammers: It could be something pure
05:38:22 <merijn> ski: And then for data fields you'd track whether the expression assigned to them would potentially throw, etc.
05:38:33 <tdammers> {AS}: sure; but then you essentially have EitherT
05:39:08 <{AS}> tdammers: Yeah
05:39:13 <{AS}> but without all the monadic stuff
05:39:32 <jonored> Sounds a lot like Java's exceptions, actually.
05:39:55 <ski> merijn : so something like `<guarded type> ::= <type> throws <exns>' and `<type> ::= <guarded type> -> <guarded type> | ...' ?
05:39:56 <tdammers> exceptions are intrinsically monadic, so "without the monadic stuff" sounds like a downside to me
05:40:23 <{AS}> tdammers: Or I would rather say
05:40:33 <{AS}> without all the pain of using the monadic lift operators
05:40:49 <merijn> ski: Something along those lines, but I didn't get too far in formalising my intuition. Too tired to program stuff like that after work, and no one closeby wanted to hire me for a phd in PLT :\
05:41:09 <ski> ok
05:41:38 <merijn> I hope to get back to it sometime
05:41:54 <merijn> But I'd have to find a job willing to give me some 20% time to hack on it, or part time work
05:42:36 <tdammers> hah, I want a job like that myself
05:44:14 <merijn> Or convince my GF to get a well-paying job so I can stay at home and hack when I get done cleaning/cooking :p
05:44:40 <munja> Sounds like a dream
05:52:47 <jaras> anyone have some recomendations for an xml parser if I don't have to query it but just transform it into a data structure? I have looked at xml-conduit but there isn't very much documentation and what there is seems to be saying that the streaming version of it havn't been updated for a long time
06:00:06 <tdammers> merijn: I did that for 2 months recently. It was heaven, but living on unemployment benefits isn't very maintainable unfortunately
06:01:22 <merijn> tdammers: That's why you need your SO to get a well-paying job ;)
06:21:10 <Denommus> hi
06:58:23 <Narfinger> hiho, I am wondering if there is an easy way to make any from Data.List parallel?
07:03:39 <Narfinger> oh I can probably do something with the parallel library but I wonder if there is something easier
07:03:44 <NickHu> Is there a list of names of subcategories of Hask?
07:04:02 <NickHu> I think Lst is generally accepted to be the subcategory containing haskell lists
07:04:02 <merijn> NickHu: Probably not, since I'm pretty sure there's an infinite amount :)
07:04:09 <NickHu> I meant common names
07:04:24 <NickHu> I mean, why Hask and why not Haskell in for first place for the category name?
07:04:28 <quchen> I’ve never seen Lst.
07:04:42 <NickHu> quchen: https://en.wikibooks.org/wiki/Haskell/Category_theory
07:10:14 <quchen> Now I’ve seen it once ;-)
07:10:56 <quchen> But from what people say in here, usually it’s called “The XXX category”, where XXX is “Maybe” for example.
07:12:05 <NickHu> Are you sure it isn't Mayb, or Myb, or Mybe? ;)
07:13:34 <Saizan> NickHu: when you are trying to draw a diagram a long name can be annoying, i assume that's why we have Cat, Mon, Grp, etc..
07:13:44 <NickHu> I see
07:13:50 <quchen> NickHu: There’s also Rsi. It’s short for the RdTWrTStTIo subcategory of Hask, which is short for ReaderTWriterTStateTIO category.
07:14:04 <NickHu> lol very intuitive
07:15:26 <ski> NickHu : "the subcategory containing haskell lists" ?
07:15:36 <dmj> .hs should be a valid TLD 
07:16:15 <ski> oh, list types
07:16:20 <NickHu> ski: Specifically the category where the objects are Haskell types of lists and the morphisms are Haskell functions between said types
07:16:31 <NickHu> Which is a subcategory of Hask
07:16:31 <ski> i suppose `Lst' is the image of the list functor, then
07:16:36 <NickHu> Yes
07:17:05 * ski idly wonders whether `Lst' is useful for anything
07:17:40 <NickHu> Explaining how functors in Haskell are related to category theory functors? ;)
07:17:44 <ski> (e.g. is there a left adjoint to the forgetful from `Lst' to `Hask' ?)
07:37:40 * hackagebot conduit 1.2.8 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.8 (MichaelSnoyman)
07:37:42 * hackagebot semibounded-lattices 0.1.0.1 - A Haskell implementation of semibounded lattices  https://hackage.haskell.org/package/semibounded-lattices-0.1.0.1 (xuhao)
08:04:43 <infandum> I have a bunch of lists I use as arguments for a calculation, so I do calculation <$> list1 <*> list2 <*> list3 etc. so I get all combinations. That calculation takes in those guys and returns IO a. I want to execute each IO computation in a parallel manner, so I figured I need to use something from async, specifically I used async-extras mapPool as I wanted only a certain number of processes at a time. However, I get the error "too
08:04:43 <infandum> many open files"...I don't know why. I assume each IO action holds open the input file it points to without terminating everything until everything is collected into the final string IO [a]? Either way, should I be using some other function here?
08:05:18 <infandum> I see parallel-io is a thing, how is that different from async, they look so similar.
08:05:36 <johnw> parallel-io is a bit more similar to async-pool
08:05:54 <johnw> async-pool is a copy of async, changed to add the notion of bounded worker pools
08:07:25 <infandum> johnw: Ah, I do remember seeing that but the documentation was a little more confusing than async-extras
08:07:45 <infandum> I don't know if I would have the same issue of too many open files, however
08:08:15 <johnw> use withFile to bound your file handle use
08:09:05 <infandum> johnw: I'm using Turtle, which includes that "with" and should be safely closing everything
08:09:20 <infandum> It's actually a bit messier...
08:09:38 <johnw> can you show me your code?
08:10:30 <infandum> My calculation function returns Shell Text, which I convert to IO using fold
08:10:34 <infandum> sure
08:11:36 <{AS}> What is the best way to debug infinite loops with very large input in Haskell when using quickcheck? :)
08:12:10 <biglambda> {AS} possibly use a trace function?
08:12:35 <{AS}> biglambda: Yeah, maybe just tracing something small might not be bad?
08:12:49 <biglambda> Yes
08:13:47 <{AS}> Thanks :)
08:13:48 <biglambda> I insert this little helper function in all my code: tr m x = trace (m++":"++show x) x
08:14:22 <biglambda> makes it easy to just put a string about what I’m evaluating.
08:14:30 <{AS}> Makes sense
08:15:20 <infandum> johnw: here is the skeleton code: http://pastebin.com/zpiHBSrR
08:15:55 <biglambda> Does anyone know how to use strictness annotation in record syntax?
08:16:12 <cocreature> biglambda: just put a ! before the type
08:16:25 <infandum> johnw: Also, I HATE my tuple hack. just wanted to do calc <$> l1 <*> l2 etc, but for multiprocessing it looked like it needed to be a list and it would compute the list before any kind of parallelization was done...
08:16:27 <Tuplanolla> Just don't forget the parentheses, biglambda.
08:16:29 <cocreature> data Point = Point {x :: !Int, y :: !Int}
08:17:00 <biglambda> Aha, the parenthesis!!
08:17:06 <infandum> johnw: Basically, I just want to run a string of programs using different combinations of arguments, a few at a time rather than one at a time
08:17:17 <infandum> because one at a time takes forever
08:17:21 <nshepperd1> Why would you want bounded worker pools in Haskell? Don't we already have green threads?
08:17:44 <johnw> infandum: so, it looks like inproc (which opens three file handles per invocation) is building up on you before they get garbage collected.  Are you folding over a really big list?
08:18:03 <johnw> nshepperd1: because concurrency is something you might need to manage
08:18:16 <johnw> nshepperd1: perhaps your machine can open 64 sockets at once, but you don't want to do that to the remote machine
08:18:23 <cocreature> nshepperd1: imagine you are writing a webcrawler and the website blocks you when you have more than 3 concurrent connections
08:18:29 <biglambda> My god the speedups!
08:18:33 <infandum> johnw: The combinations of the lists results in about 200,000 elements, so yes it's big
08:18:36 <infandum> or more
08:18:41 <johnw> infandum: so, using inproc is your problem
08:18:52 <joncol> Does anyone know of a library for exporting records and other types to nice looking html? I just tried pretty-show, but the results don't look too good out of the box.
08:19:00 <johnw> you need something that, within the Shell action, closes before it exits
08:19:45 <infandum> johnw: hmmm, I was under the assumption that it closes everything when it returns
08:20:18 <johnw> infandum: it creates a process, opening stdin/stdout/stderr, but you have no command there to close them as they finish; the only thing I see is that they will all be closed at least when "sh" is done
08:20:24 <infandum> johnw: I could use sh to execute all actions and convert back to IO, but it has type Shell a -> IO ()
08:20:28 <infandum> I need that string
08:20:47 <johnw> sure, you need to capture stdout in a string and return it yourself
08:20:56 <johnw> write a function Shell a -> IO Text
08:21:32 <infandum> am I not doing that?
08:21:44 <johnw> when yo'ure not forcing when the handles are closed
08:21:52 <johnw> your invocation of inproc leaves it up to the garbage collector
08:22:25 <johnw> you need a 'wait' in there somewhere
08:22:41 <infandum> ooohh, like foldIO from Turtle?
08:22:42 <johnw> (waitForProcess, actually)
08:22:45 <infandum> wait
08:22:48 <infandum> I AM doing that
08:22:48 <infandum> haha
08:22:58 <johnw> not in your skeleton, then?
08:23:15 <infandum> no, the fold line
08:23:20 <infandum> but that's fold, not foldIO
08:23:24 <infandum> I wonder if that's the clincher
08:23:30 <johnw> I don't think foldIO will help you here
08:23:40 <johnw> it still won't close anything on a schedule
08:23:52 <johnw> it will just let you keep opening processes as fast as you can in IO
08:24:10 <johnw> you need to bound your use of inproc with `bracket', to ensure they are closed as soon as you have the results you needed
08:24:27 <johnw> or maybe Turtle has a mechanism for this, I don't know
08:25:03 <johnw> what you have in your skeleton is equivalent to opening a ton of files in C without ever closing them, and then letting the _exit() function from the standard library do all the closing
08:25:38 <infandum> this is quickly getting a little advanced haha
08:25:46 <nitrix> Can one of the big FRP names breif me about its benefits again? I was trying to transpose a codebase to some FRP library (wires is really nice by the way), but I think I'm just not yet seeing the benefit. What does it accomplishes more than a custom monad, with derived MonadState and such cannot do?
08:26:05 <johnw> I hope not!  I'm just adding one new idea to your code: bound the lifetime of your subprocesses within the `calc' function
08:26:27 <johnw> let me see how you do that with inproc...
08:27:14 <johnw> oh, inproc should already be doing this for you
08:27:31 <johnw> i wonder if it's not happening because you're not forcing the answer
08:28:03 <infandum> johnw: Yeah, I thought it was supposed to guarantee it
08:28:09 <infandum> possibly
08:28:10 <grantwu> how can I simulate Seq.lookup with index pre Containers 0.5.8.1?
08:28:12 <johnw> please try adding this, just before the "let row": evaluate $ length result
08:28:16 <grantwu> i.e. how do I catch error
08:28:23 <johnw> you'll need to import Control.Exception, I think, to get evaluate
08:28:46 <infandum> johnw: Ah, I saw the stack overflow with the guy with the vector
08:28:50 <infandum> needing evaluate
08:29:09 <johnw> yeah, inproc is doing everything I suggested, include waitForProcess and using bracket to close...
08:29:46 <infandum> btw, how familiar are you with turtle? I used to have the loops be from "arg1 <- select ls" etc for each thing, doing the same this as I'm doing now, but I didn't know how to parallelize that
08:29:50 <infandum> would you know?
08:29:55 <johnw> i'm not familiar with turtle at all
08:29:58 <infandum> ok
08:29:59 <infandum> haha
08:30:06 <infandum> what about the horrible use of the tuple?
08:30:53 <johnw> why not a list?
08:31:15 <infandum> I didn't know how to parallelize that
08:31:27 <infandum> like, the tuple here creates the list
08:31:38 <infandum> I didn't know how to parallelize calc <$> l1 <*> l2 etc
08:31:59 <infandum> with (,,) <$> l1 etc that makes a list, then I can parallelize calc over it
08:37:42 * hackagebot ChasingBottoms 1.3.1.2 - For testing partial and infinite values.  https://hackage.haskell.org/package/ChasingBottoms-1.3.1.2 (NilsAndersDanielsson)
08:40:12 <infandum> johnw: Trying evaluate now, after the fold step (\x -> (flip fold Fold.list . calc $ x) >>= evaluate)
08:42:50 <grantwu> Is there a way to catch error?
08:43:54 <ertes> grantwu: 'error'?  it uses 'throw'
08:43:59 <ertes> so you can catch it in IO
08:44:11 <grantwu> urgh
08:44:23 <grantwu> is there an idiomatic way to convert it to a maybe?
08:44:51 <ertes> grantwu: there is no *correct* way to do it…  you're violating semantics if you do that
08:45:04 <ertes> remember that 'error' exceptions are indistinguishable from bottom
08:45:31 <grantwu> ertes: I'm hacking around the lack of lookup in Data.Sequence pre 0.5.8
08:46:14 <ertes> grantwu: 'lookup'?  as in: search a sequence of tuples for a key?
08:46:33 <grantwu> ertes: https://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Sequence.html#v:lookup
08:47:51 <ertes> grantwu: you can write it in terms of 'drop'
08:47:58 <ertes> and 'viewl'
08:48:22 <grantwu> ._.
08:49:10 <ertes> grantwu: same complexity, slightly worse constant factors…  do that until you can upgrade 'containers'
08:49:50 <ertes> if you call it 'lookup' all you need to do after the upgrade is to remove your own definition
08:50:03 <grantwu> Is it definitely the same complexity?  lookup in 0.5.8 seems to use the internal tree structure
08:50:25 <grantwu> I guess it should be
08:50:30 <ertes> actually you can do better performance-wise:  use 'index', but check the length first
08:50:44 <grantwu> oh, phes.
08:50:46 <grantwu> *phew.
08:50:50 <grantwu> That's silly of me, yeah
08:51:52 <nshepperd1> Drop/viewl may be better than index there since it doesn't hold on to the sequence
08:51:56 <ertes> Seq splits with known indices are all logarithmic, so 'drop' has the same complexity as 'index'…  but it still needs to recompute one path of the tree
08:52:29 <ertes> that's why 'drop' is always worse, unless it is optimised away by rules (unlikely)
08:52:53 <grantwu> I don't think we will be able to upgrade containers anytime soon
08:53:07 <grantwu> Alex is holding us back... somehow
08:53:10 <nshepperd1> If you don't force the value anyway
08:54:25 <grantwu> Oh well, apparently because Stackage doesn't have 0.5.8 yet?
08:59:20 <ertes> well, you could go with regular hackage
09:08:00 <grantwu> I think the Alex from stackage depends on the one from stackage?  We had containers in extra deps before but my partner changed it so presumably it didn't work
09:09:06 <Zemyla> Do you often see typeclass instances like instance (Whatever1 f, Whatever a) => Whatever (f a)?
09:10:26 <glguy> no
09:12:59 <johnw> infandum: the evaluate would need to be in `calc`, not after the fold
09:13:15 <johnw> it's the fold that's creating all those processes, if my guess is right
09:14:28 <infandum> johnw: Yeah, it just fails. It takes a while to run before failing.
09:14:32 <infandum> failed*
09:14:40 <johnw> even with evaluate inside calc?
09:14:53 <infandum> johnw: But the fold is for a SINGLE call
09:15:05 <johnw> oh, huh?
09:15:07 <infandum> it's to convert Shell a to IO [Text]
09:15:14 <johnw> at the point, add trace statements
09:15:26 <infandum> because all of these multiprocessing tools use IO
09:15:28 <johnw> add a traceM "got here" right after the call to inpro
09:15:29 <johnw> c
09:15:37 <johnw> and add (trace "result" result) where you use that value
09:16:39 <infandum> johnw: Are those inside calc or inside main?
09:16:50 <johnw> inside calc
09:18:58 <infandum> johnw: I did echo row inside calc and it does show the row
09:19:05 <infandum> incrementally
09:19:31 <infandum> and I did traceShow before the result in the row and it shows that too
09:19:40 <johnw> nice; you may actually need to copy into your project some of the functions from turtle, like "stream", and put debugging code in them, to ensure that closing is happening when you think it is
09:20:03 <infandum> oh man
09:20:48 <johnw> gotta found out why those file handles are being kept open
09:20:50 <infandum> it prints the row even without any evaluate call
09:20:52 <infandum> yeah
09:21:08 <johnw> if evaluate didn't fix the problem, then you don't need it
09:22:09 <infandum> johnw: I should mention that NO temporary files are being used here, it's just reading from a file
09:22:18 <infandum> wait
09:22:26 <infandum> no take that back, it's not reading anything
09:22:42 <infandum> there should actually be 0 files
09:22:43 <infandum> ...
09:22:48 <infandum> now I'm so confused
09:22:59 <infandum> there are no files at all, I have everything print to stdout
09:23:16 <infandum> I pipe it all into a giant file at the end
09:23:30 <infandum> (outside of this program)
09:23:46 <johnw> there are file handles used by createProcess
09:24:17 <infandum> even if it's stdout?
09:24:26 <infandum> wouldn't that be one handle?
09:24:44 <johnw> it has to create a file handle for talking to the subprocess that it creats
09:25:16 <infandum> ok
09:28:19 <infandum> johnw: Maybe I should use Turtle's fork function
09:28:31 <infandum> even though it would require a bunch of functions for supporting a pool
09:29:04 <johnw> mixing libraries like this is probably part of the problem, since neither was designed to work with the other
09:30:31 <infandum> johnw: It looks like turtle uses async
09:30:37 <infandum> http://www.haskellforall.com/2015/01/use-haskell-for-shell-scripting.html
09:30:40 <infandum> search for async
09:31:17 <infandum> but then I go full circle
09:31:42 <infandum> I can't do mapConcurrently because of every process shooting off, so I went to async-extras, etc. etc. and here I am
09:32:14 <johnw> what if you just do one process at a time for now?
09:33:12 <infandum> johnw: I could, and everything is fine, but then it's not concurrent haha
09:33:19 <infandum> and slower than it could be :(
09:37:45 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
09:37:45 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
09:38:22 <johnw> it's even slower if it doesn't work at all ;)
09:38:23 <colo> hello, does someone know how are tuples defined?
09:38:24 <infandum> haha true
09:38:24 <johnw> colo: do you mean, by the Haskell Report, or in GHC?
09:38:24 <infandum> but I feel like it *should* be simple and I'm just missing something
09:38:27 <colo> johnw: mmhh i don't kwon.. , i was just curious how one can define a data type that acts like a tuple.. 
09:38:27 <johnw> data Tuple a b = Tuple a b
09:38:30 <colo> johnw: what about tuples with more than two elements
09:38:32 <merijn> colo: "data Tuple3 a b c = Tuple3 a b c"? :p
09:38:34 <johnw> Tuple Int (Tuple Float String)
09:38:35 <johnw> (a,b,c) is isomorphic to ((a, b), c) and (a, (b, c))
09:38:35 <breadmonster> What's going on?
09:38:35 <johnw> so it depends on whether the representation matters to you
09:38:35 <breadmonster> netsplit?
09:39:11 <MasterPabu> Yo
09:39:35 <colo> ok, but i meant tuples with non fixed length nor types 
09:39:37 <infandum> this is why I need to hide join and quit messages
09:39:48 <johnw> what are tuples without types?
09:40:01 <merijn> colo: That's not a thing that exists
09:40:07 <colo> without fixed types
09:40:26 <merijn> colo: I'm not sure what that would mean?
09:40:31 <cocreature> are you trying to have dynamic types in haskell?
09:40:38 <Lokathor_> "data Tuple a b" will give you non-fixed types. each particular value would fill in a and b on their own
09:40:41 <Lokathor_> if that's wht you mean
09:41:12 <EvanR> dynamic types will not be tolerated, banish him to the Void
09:43:06 <Lokathor_> EvanR, don't pollute the void up like that
09:43:12 <colo> i'm not trying to have dynamic types, but tuples can be made from a number of variables with different types
09:43:27 <cocreature> we already have way too many bottoms in our Void type
11:46:54 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
11:46:54 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
11:56:52 <pikajude> Lens f l a b
12:07:35 <dmwit> Wow, there are a lot of fun words where every pair of letters is adjacent (like "stab" of lens fame).
12:07:57 <dmwit> "klutzy" is a particularly amazing one.
12:09:03 <dagda1_> how do I declare variables in a function, my let expressions are wrong https://gist.github.com/dagda1/a3c305f50d55fde866301daeb612faee
12:09:15 <Tuplanolla> What else could you use with lenses though? The pairs have to be in order.
12:09:19 <dmwit> "poke", "hits", and "stoned" join "stab" on the list of violent adjacency words
12:09:31 <dmwit> s/poke/polk/
12:10:10 <dmwit> Tuplanolla: What does "in order" mean?
12:10:10 <prsteele> dagda1_: let ... in ..., e.g. http://zvon.org/other/haskell/Outputsyntax/letQexpressions_reference.html
12:10:14 <Tuplanolla> For example "bats" shouldn't be acceptable, dmwit.
12:10:28 <dmwit> Tuplanolla: Why not?
12:10:56 <dmwit> dagda1_: Perhaps you would like to add "do", as in "starman n = do".
12:10:56 <Tuplanolla> It looks contravariant, because it's b -> a instead of a -> b, dmwit.
12:11:49 <prsteele> dagda1_: also you probably shouldn't be using unsafePerformIO, _especially_ since you're in a function returning IO () anyway
12:12:05 <dagda1_> prsteele why is that?
12:12:40 <dmwit> Tuplanolla: abdest, dexy, hiders, high, hist, klop, node, noop, stab, stop, tutu
12:12:46 <dmwit> Tuplanolla: And a bunch of others I've never heard of. =P
12:12:56 <prsteele> dagda1_: you can just call newStdGen in your IO sequence, e.g. "starman n = do gen <- newStdGen; (do something with gen)"
12:13:56 <Tuplanolla> We should also prohibit letter repetitions, unless of course we're looking for simple lenses, dmwit.
12:14:18 <Tuplanolla> Lens n o d e is nice though.
12:14:23 <dmwit> Tuplanolla: If you allow them to be in the other order, so long as all pairs choose the same order, you also have balk, balked, bats, feed, fets, onyx, polk, pouted
13:55:00 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
13:55:00 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
14:22:23 <ocramz> hullo
14:24:03 <joobus> hullo
14:27:51 <ocramz> is there a general way for transposing the order of traversal in nested structures? e.g. let's say we have lists of lists: I'd like to consider the head of all inner lists, then the second elements, and so on
14:28:24 <ocramz> my actual case is more complicated with nested intmaps, but I think it should carry over
14:30:21 <joobus> ocramz: (fmap . fmap) functionHere listOfLists
14:30:25 <joobus> ocramz: maybe
14:31:01 <Tuplanolla> Transposition sounds like a job for sequenceA, but I'm not sure that's what you're after, ocramz.
14:31:05 <ocramz> thanks joobus but (fmap . fmap) traverses both levels in the same 'direction'
14:31:30 <Tuplanolla> There's also Down for reversing orderings, ocramz.
14:31:47 <ocramz> Tuplanolla : where can I find Down?
14:31:54 <ocramz> I can look for sequenceA , thanks
14:32:12 <Tuplanolla> :i Down
14:32:18 <runawayfive> @barrucadu: Would you mind if I PM'd you regarding one of your projects?
14:32:18 <lambdabot> Unknown command, try @list
14:32:45 <Tuplanolla> http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Exts.html#t:Down
14:35:49 <ocramz> Tuplanolla : sequenceA looks good, thanks
14:36:06 <ReinH_> ocramz: http://stackoverflow.com/questions/12963733/writing-cojoin-or-cobind-for-n-dimensional-grid-type/13100857#13100857
14:36:47 <ReinH_> transposing is not always well behaved
14:37:03 <ReinH_> consider a list of different-length lists
14:38:44 <prsteele> I find myself wanting to have two distinct State levels in a transformer stack. Is an appropriate solution to newtype one of the states and provide a set of (distinct) functions for manipulating it? or is there another accepted approach?
14:39:10 <ocramz> yes indeed ReinH_ (thanks for the link btw). In fact I have nested IntMaps which are sparse at both levels. I'd love to find a general solution here
14:39:41 <dmj`> prsteele: use one state, and lenses to modify them
14:39:51 <dmj`> or just vanilla record updates
14:40:17 <bethebunny> trying to get my feet wet with haskell, doing project euler problems
14:40:24 <dmj`> prsteele: why have 2 states
14:40:29 <prsteele> bethebunny: awesome! that's how I started
14:40:32 <bethebunny> having trouble making any sort of memoization work well on collatz
14:40:35 <Welkin> bethebunny: that won't help you
14:40:53 <bethebunny> equivalent c/python code runs in under a second
14:41:18 <Welkin> bethebunny: just create a list of all possible values
14:41:22 <bethebunny> most of the memoization techniques on https://wiki.haskell.org/Memoization are actually worse than a basic recusive definition, which takes about 22 seconds
14:41:38 <prsteele> dmj`: half philosophical, half for safety. I'm making a simulation, and I have the state that the thing-being-simulated knows, and the state of the future trajectory of the simulation. The thing-being-simulated is not allowed to know about the future trajectory, so it would be nice if the type signature of policies being simulated demonstrate that it does not have access to it
14:41:39 <bethebunny> using ST I managed to get it down to about 6-7 seconds
14:41:45 <bethebunny> http://pastebin.com/WfE3KxLQ
14:41:51 <bethebunny> vs python http://pastebin.com/aUPRfNPG
14:41:57 <Welkin> project euler is a poor way to learn haskell
14:42:40 <bethebunny> Welkin: thanks for your input :) I'll be graduating to a new project in the near future, mostly need to get syntax / libraries / basic concepts down, would love some comments
14:43:11 <grantwu> I think switching to Int instead of Integer might help
14:43:49 <Welkin> Integer uses Int underneath for smaller values
14:43:52 <Welkin> I believe
14:44:24 <bethebunny> also the values are larger than i32 for n = 1 million, my test case
14:44:36 <Welkin> Int is Int64
14:44:41 <bethebunny> oh :)
14:44:41 <ertes> bethebunny: i suspect Map to be the main problem here
14:44:56 <bethebunny> ah, I'll try with Hashtable?
14:45:08 <grantwu> Maybe IntMap?
14:45:08 <prsteele> a plain vector might work, since you're indexing with ints anyway
14:45:27 <ertes> bethebunny: first, as grantwu suggested, switch to Int, then there are a few ways to make this fast
14:45:40 <ertes> bethebunny: the easiest way is not to do "memoisation" in that sense, but instead use a lazy vector
14:45:58 <bethebunny> lazy vector as opposed to list?
14:46:00 <ertes> from the 'vector' library
14:46:02 <ertes> yeah
14:46:12 <bethebunny> the list approach is commented out at the top an is much worse than the function approach :P
14:46:13 <ertes> a haskell "vector" is really just an array in memory
14:46:26 <bethebunny> yeah
14:47:08 <bethebunny> Integer -> Int made no difference performance wise
14:47:11 <ertes> Map is a good data structure for larger-scale problems, but if insertion and lookup are the most frequent operations, the tree traversal will kill your performance
14:47:24 <ertes> yeah, Integer drops to Int automatically, but you need Int for vectors
14:47:32 <Welkin> only because Map is a binary tree
14:47:33 <bethebunny> yeah makes sense, I much prefer hashmaps in general :)
14:47:38 <Welkin> HashMap isn't though
14:47:50 <ertes> bethebunny: hash *maps* or hash *tables*?
14:48:13 <Welkin> ertes: aren't they the same thing?
14:48:22 <Welkin> some call them hashmaps, others call them hashtables
14:48:27 <ertes> HashMap is basically IntMap, but on hashes (which alone would give you a speed boost)
14:48:31 <bethebunny> good question, I've never had a reason to differentiate
14:48:33 <ertes> it's still a tree
14:48:37 <bethebunny> it lookes like hackage has both :P
14:48:50 <ertes> and it's still an immutable functional data structure
14:49:01 <grantwu> you can try unboxing the int?
14:49:02 <ertes> a hash table is a mutable *array*-like data structure
14:49:28 <ertes> unboxing (except in constructor fields) is the least promising approach
14:50:06 <Welkin> what about beatboxing?
14:50:11 <geekosaur> hashtables is actually the ancient one, don't use it
14:50:16 <ertes> beatboxing is always a good idea
14:50:53 <ertes> you will get a major groove boost by careful beatboxing
14:51:33 <bethebunny> geekosaur: what should I use instead?
14:51:35 <geekosaur> (base used to have Data.HashTable; it was in IO and was painfully slow. when it got ejected, the hashtable package was added for backward compatibility for old packages that used the old HashTable, until they could be rewritten.)
14:52:02 <geekosaur> HashMap generally
14:52:02 <bethebunny> what about Data.HashTable.ST?
14:52:30 <ertes> bethebunny: the vector approach will beat the hash table approach in this case
14:52:59 <geekosaur> oh, hm this one is not the backwar compat one, it;s from google
14:53:20 <geekosaur> but it still implements a mutable (IO / ST) hash table. the pure HashMap is usually preferably
14:53:21 <bethebunny> Possibly, the issue with collatz memoizing is that it's sparse
14:53:27 <geekosaur> ... typing geesh
14:54:10 <ertes> bethebunny: then hash tables might actually pay off due to their better memory locality, but i would try IntMap first (since your keys are Int, HashMap will be the same thing)
14:54:12 <bethebunny> otherwise a simple approach like (map f [0..] !!) should also work pretty well?
14:54:27 <ertes> if only to get a speed comparison
14:54:53 <ertes> lists don't work well, because they don't support fast indexing
14:55:04 <bethebunny> okay, thanks, I'll try all of these :) as Welkin mentioned, euler is pretty contrived so implementing all these is proving to be a lot better for diving into libraries
14:59:40 <slack1256> does anyone know a diagrams-lib executable that I just feed it code and it output the svg,png file (a la dot)?
15:00:08 <slack1256> having to compile the executable to it print a image doesn't play well with (my current knowledge) of makefiles
15:05:30 <prsteele> slack1256: (I could be missing something, but) what if you just have the binary be a dependency of the image, and then provide a recipe to build the binary? e.g. cabal build
15:13:39 <barrucadu> runawayfive: Not at all
15:33:55 <dmwit> slack1256: runhaskell?
15:42:58 <infel> I'm new to haskell... is it possible to reverse an infinite list?... if i do main = print(last (reverse [0, 1..])) the online compiler says "killed"
15:43:19 <grantwu> how would you reverse an infinite list?
15:43:25 <Koterpillar> infel: what is the first element of such a list?
15:43:25 <grantwu> What would the first element be?
15:44:30 <infel> there is no first element... reversing such a list would pivot around the end of the list so to speak
15:44:44 <infel> that's why i use last
15:44:47 <grantwu> pivot around the end of the list?
15:44:56 <grantwu> there isn't really an end
15:45:16 <grantwu> Oh, I kind of see what you mean
15:45:22 <infel> there is... the end just gets reversed to the opposite direction
15:45:39 <grantwu> I kind of see what you mean, but that sort of reasoning is problematic
15:45:49 <infel> what i'm trying to do is create an infinite list is both ways
15:45:53 <infel> [..0..]
15:46:01 <grantwu> That's... not a thing, no
15:46:01 <Koterpillar> well, that is possible
15:46:09 <Koterpillar> just not with the standard list
15:46:10 <grantwu> Well I guess it is but
15:46:11 <Tuplanolla> I was about to suggest indexing with the last natural number, but this is actually reasonable.
15:46:26 <infel> where [..0..] !! x --returns x
15:46:53 <grantwu> so lists are just singly linked lists in Haskell
15:47:08 <grantwu> they always have a defined head
15:47:19 <Koterpillar> data Bilist a = Bilist { leftSide :: [a], rightSide :: [a] }
15:48:05 <grantwu> infel: last works by walking the list until it gets to [], at which point it gives you the last element it encountered
15:48:19 <grantwu> Does that help explain why what you're suggesting doesn't work?
15:49:03 <Koterpillar> actually, with this Bilist you would be able to implement your original thing
15:49:15 <grantwu> (right; I'm talking about with regular lists)
15:49:17 <Koterpillar> (I have a feeling Bilist is somewhere in the standard library, what's the name?)
15:49:20 <infel> i kind of understand
15:49:41 <Koterpillar> infel: reverse (Bilist l r) = Bilist r l
15:49:49 <Tuplanolla> It's just a contextless zipper, isn't it, Koterpillar?
15:49:58 <Koterpillar> yeah, I was too lazy to add the context
15:50:20 <geekosaur> isn't that BiList basically Seq?
15:50:24 <Koterpillar> infel: last (Bilist (x:_) []) = x
15:50:25 <geekosaur> (as in Data.Sequence)
15:50:30 <infel> how would i index a bilist?
15:50:42 <Koterpillar> infel: positive to the right, negative to the left
15:50:43 <infel> bilist !! -10?
15:50:54 <geekosaur> well, except Seq uses a fingertree instead of a circularly linked list
15:51:13 <Koterpillar> (Bilist _ xs) !! x | idx > 0 = xs !! idx
15:52:10 <infel> hmmm i think this kind of thing is too complicated for a functional programmer beginner :P
15:52:37 <Zekka> infel: Are you sure you need a list?
15:52:44 <NickHu> Could someone give me a hand with Haskell persistent?
15:53:02 <infel> i don't need it... i'm just screwing around with this language :P
15:53:08 <Zekka> oh, carry on then!
15:53:46 <NickHu> http://lpaste.net/227115
15:53:56 <grantwu> I wonder if GHC can turn last . reverse into head
15:54:02 <NickHu> I think I just need to manually put a type signature somewhere
15:54:08 <grantwu> Probably not, due to this case
15:56:29 <lyxia> NickHu: what's the type of replace
15:58:54 <dmwit> grantwu: `head` terminates too often compared to `last . reverse` =P
16:00:12 <NickHu> lyxia: https://hackage.haskell.org/package/persistent-0.3.1.3/docs/Database-Persist.html
16:00:20 <NickHu> replace :: PersistEntity val => Key val -> val -> m ()
16:01:18 <dmwit> NickHu: Here is a red flag: `pure x >> y` is the same as `y`. So if you have written that, you probably have misunderstood something fundamental.
16:02:10 <dmwit> s/if/since/
16:02:11 <lyxia> NickHu: that's a pretty old version
16:02:48 <NickHu> lyxia: So it is, I'm actually using a recent one but that was the first result on google
16:03:06 <NickHu> dmwit: Yeah, I see, this was after 10 tries or so to make the types line up
16:03:40 <lyxia> https://hackage.haskell.org/package/persistent-2.5/docs/Database-Persist-Class.html#v:replace but anyway dmwit found the problem.
16:04:28 <dmwit> Well, I found the problem. But I don't know enough about persistent to suggest a likely solution.
16:05:23 <dmwit> In any case I doubt `pure $ case usr of` is going to be a prefix of a correct replacement.
16:07:02 <dmwit> Probably you want something like `case usr of Nothing -> pure Nothing; Just x -> replace (entityKey x) newusr >>= f`, but I've no idea what `f` should be.
16:08:46 <NickHu> Why would I need bind if the return type of replace is m ()?
16:09:30 <dmwit> "Need" is such a strong word. I definitely didn't use it.
16:10:38 <lpaste> lyxia annotated “No title” with “NickHu” at http://lpaste.net/227115#a227183
16:13:30 <NickHu> dmwit: I updated the paste
16:13:42 <NickHu> lyxia: I tried using for, but it gives a huge error
16:15:56 <lyxia> NickHu: I wonder what it is. I suppose the hole should be pure (Just newusr)
16:16:18 <NickHu> huh seems to work
16:16:24 <NickHu> Could've sworn I already tried that...
16:16:42 <NickHu> Well, it is kinda late and that type signature is 300+ characters long lol
16:17:03 * lyxia shrugs.
16:17:15 <NickHu> oh
16:17:18 <NickHu> I see
16:17:31 <NickHu> pure $ pure newusr doesn't work
16:17:37 <NickHu> but pure (pure newusr) does...
16:17:48 <NickHu> I thought that they were the same
16:17:58 <lyxia> f a >> pure $ pure stuff
16:17:59 <Maxdamantus> pure . pure $ newusr
16:18:00 <geekosaur> depends on surrounding context
16:18:22 <geekosaur> the problem is that $ is very low precedence. it will "eat" too much if given the chance
16:18:22 <lyxia> becomes    (f a >> pure) (pure stuff)
16:18:36 <NickHu> ooh
16:18:39 <lyxia> but you want f a >> (pure (pure stuff))
16:18:52 <NickHu> So is the cleanest way to write it just with the brackets?
16:18:57 <geekosaur> yes
16:19:17 <geekosaur> although f a >> (pure $ pure stuff) would also work
16:19:25 <lyxia> IMO the cleanest way is to use for
16:19:41 <Tuplanolla> It's usually a good idea to avoid $ unless \, do or something else equally cumbersome is involved.
16:19:58 <Ed___> I need to create an 16-bit ALU. I could use Char as my data, or Bool. Whats the best for this situation?
16:20:01 <NickHu> I'm not really hugely familiar with the Traversable stuff, and I don't expect this function to change
16:20:56 <Ed___> having a bunch of True/False written out would look worse than '1' and '0' in my opinion.
16:20:59 <EvanR> Ed___: make a new datatype
16:21:07 <EvanR> you could also use Word16
16:21:19 <lyxia> Definitely not Char
16:21:21 <EvanR> newtype it to make it display however you want
16:22:52 <Ed___> data Boolean = One | Zero deriving (Show, Eq, Ord, Enum)
16:22:54 <Ed___> like so?
16:23:16 <Tuplanolla> You'll have to write Read and Show yourself or use a different formatting function, Ed___.
16:23:36 <Tuplanolla> In the latter case you might as well use Bool though.
16:24:10 <Ed___> so... Should i just use Word16?
16:24:28 <geekosaur> data Bit = O | I -- >.>
16:25:50 <Ed___> Why would I have yo write Read and Show myself, Tuplanolla?
16:26:34 <geekosaur> if you wanted it to display or input differently
16:26:41 <Tuplanolla> If you want them to be formatted nicely, Ed___. However geekosaur has a good solution too.
16:26:50 <geekosaur> (I think that may have been aimed at the Bool newtype idea)
16:27:22 <Ed___> so just data Bit = O | I ?
16:27:27 <Ed___> with no derivations?
16:27:36 <geekosaur> derivation as you see fit
16:28:03 <Ed___> thanks
16:33:31 <nshepper1> you can give it a Num instance if you want to write 0, 1 in your code. either a fake instance only implementing fromInteger or full Z₂
16:33:42 <Ed___> last question, so is data Bit = O | I then most efficient way?
16:35:38 <geekosaur> efficiency is probably the same regardless
16:35:56 <geekosaur> efficienly of the program, at least. efficiency of writing may be improved :)
16:41:27 <umib0zu> is there a preferred method to get started with a project using either stack or cabal? 
16:41:44 <umib0zu> I’m wondering what both of them are actually for
16:42:43 <RabitTrash> sup people :)
16:50:41 <slack1256> umib0zu: in cabal you issue 'cabal init' on your shell
16:51:19 <slack1256> that will ask you some questions and create a .cabal,license file and a src directory
16:51:52 <slack1256> I don't know stack but I would think they have something analogous (probably also called init)
16:52:19 <MarcelineVQ> stack new, stack init creates a stack project from an existing .cabal file
17:03:12 <lpaste> Ed_ pasted “Problem is on the second guard. ” at http://lpaste.net/227377
17:03:14 <dfeuer> I think I figured out what Enum should *actually* look like.  class Ord a => Enum a where getDiff :: a -> a -> Int; shiftByInt :: Int -> a -> a; shiftByInteger :: Integer -> a -> a
17:03:54 <Ed___> I have a problem with syntax. How do I make this work? http://lpaste.net/227377
17:04:17 <dfeuer> If I'm not mistakes, those operations would give people pretty much everything they actually *want* out of Enum, and allow it to work well with sequence types other than lists.
17:04:46 <dfeuer> Er... I meant to also have a shiftByInt
17:05:06 <dfeuer> And maybe have both diff and diffAsInteger.
17:05:32 <Cale> Ed___: 'where' scopes over multiple guarsd
17:05:35 <Cale> guards*
17:05:58 <dfeuer> Cale, do you think I'm right about that?
17:06:13 <Cale> Ed___: So seeing as you are defining the same things, you can just drop the first 'where'
17:06:25 <Ed___> they are different
17:06:43 <NickHu> Is there a better way of doing pack ((unpack x) ++ y) where x :: Text and y :: String?
17:06:50 <Ed___> second where clause has b' instead of b
17:07:01 <Cale> ah, yeah
17:07:25 <Cale> dfeuer: Uh, I've always thought of Enum as "how the list syntaxes are defined"
17:07:40 <Ed___> I really dont want to just copy paste what result and cout should be as that would make it really unreadable
17:07:40 <Cale> [a..], [a..b], [a,b..], [a,b..c]
17:08:05 <Cale> Ed___: maybe just make cout into a function of the bit which changes
17:08:21 <dfeuer> Cale, the trouble is that it doesn't work well for Seq or Vector or anything else.
17:08:49 <Cale> dfeuer: Sure...
17:08:50 <dfeuer> Oh wait, no, my attempt doesn't quite work either.
17:09:06 <dfeuer> But it gets really close!
17:09:20 <dfeuer> I think I just need to add a method to calculate  length [m .. n]
17:09:21 <Cale> dfeuer: I've never been super crazy about generalising every list operation to Seq and Vector... :)
17:09:37 <dfeuer> Why not/
17:09:38 <dfeuer> ?
17:10:01 <Cale> I dunno, some things make sense for lists which don't necessarily make sense for every sequence-like type
17:10:15 <Cale> and many things which make sense for other sequence types don't make sense for lists
17:10:20 <dfeuer> Well, I mean, some operations are pretty silly, like consing onto an Array. But enumerations seem to make perfectly good sense for all.
17:10:36 <Cale> [a..] doesn't make sense for Seq for sure
17:11:01 <dfeuer> Certainly.
17:11:26 <Cale> At least, until someone invents the industrial-accident-finger-tree
17:11:34 <dfeuer> Ouch!
17:11:51 <dfeuer> But  [a..b] and [a,b..c] make perfectly good sense.
17:11:54 <Cale> and we can have infinite nesting in a meaningful way
17:12:01 <Cale> yeah
17:12:27 <Cale> The Int-related stuff and the list-syntax related stuff don't really belong in the same class, I think
17:12:47 <dfeuer> Well, my goal above was to get the essence of what we need to support enumerations.
17:12:56 <dfeuer> And I think I pretty much got it.
17:14:03 <dfeuer> If you ignore Int vs. Integer stuff, there's just   diff :: a -> a -> Integer, applyDiff :: Integer -> a -> a, and countFromStepTo :: a -> Integer -> b -> Integer
17:14:30 <Cale> yeah, that seems plausible...
17:15:20 <dfeuer> Lists don't need countFromStepTo, but it's important for sequences. It could get a nice default for Integral types.
17:16:03 <dfeuer> > [False,True..]
17:16:05 <lambdabot>  <hint>:1:14: error: parse error on input ‘]’
17:16:35 <dfeuer> > [False,True ..]
17:16:37 <lambdabot>  [False,True]
17:16:40 <dfeuer> :/
17:17:05 <dfeuer> Eh, I can work around that :P
17:21:52 <benzrf> > [False..]
17:21:54 <lambdabot>  <hint>:1:9: error: parse error on input ‘]’
17:22:29 <benzrf> > [False ..]
17:22:31 <lambdabot>  [False,True]
17:25:58 <dmwit> dfeuer: Your type for `diff` seems problematic for, e.g., [1, 1.5 .. 10]
17:27:22 <dfeuer> dmwit, I'm not a big fan of enumerations for fractional types.
17:28:02 <Cale> > [1,3..10.0]
17:28:04 <lambdabot>  [1.0,3.0,5.0,7.0,9.0,11.0]
17:29:42 <dfeuer> Maybe Rational could be an option? Use a type/data family for the difference type?
17:29:58 <Cale> > [1,3..10%1]
17:30:00 <lambdabot>  [1 % 1,3 % 1,5 % 1,7 % 1,9 % 1,11 % 1]
17:30:23 <jle`> NickHu: you can drop the parentheses, if that's better :)
17:31:14 <Cale> (it will include elements that are less than a half step past the upper bound)
17:32:18 <Cale> I've always found that a bit of a questionable decision -- I can sort of understand the motivation for it, but I'm still not sure it's the right thing to do.
17:32:58 <Cale> It would be interesting to see some real cases where it was essential, or at least useful.
17:34:26 <dfeuer> I really can't imagine that it's ever essential.
17:34:52 <Cale> Well, if all else failed, you could rewrite the algorithm yourself.
17:36:03 <Cale> But yeah, cases where you really want that last element which is over the line
17:39:15 <yamadapc> I can't GET google with wreq or http-client on my computer; anyone knows what is the usual fix? "TlsException... HanshakeFailed ..."
17:41:43 <harwiltz> Hello all. I'm trying to write an addition function for a complex number type that I created. I have the function coordp :: (Eq a) -> Phasor a -> CoordSyst, where CoordSyst = Rectangular|Polar deriving (Eq, Show)
17:42:20 <harwiltz> But in my addition function, I have the clause ((coordp u == coordp v) and coordp v == Polar), and I'm getting errors
17:42:50 * hackagebot keysafe 0.20160927 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20160927 (JoeyHess)
17:43:01 <Koterpillar> harwiltz: paste the data types (see topic) and the errors
17:43:08 <harwiltz> Says Couldn't match expected type (t0 Bool -> Bool) -> (Phasor a0 -> CoordSyst) -> Phasor a -> CoordSyst
17:43:20 <harwiltz> with actual type 'Bool'
17:43:21 <Koterpillar> :t and
17:43:23 <lambdabot> Foldable t => t Bool -> Bool
17:43:25 <Koterpillar> :t (&&)
17:43:26 <lambdabot> Bool -> Bool -> Bool
17:43:41 <Koterpillar> harwiltz: see the above types, 'and' and '&&' are different
17:43:51 <harwiltz> Koterpillar: I tried &&, and then I got Could not deduce (Eq a) arising from a use of coordp
17:44:03 <harwiltz> But I have my CoordSyst deriving Eq
17:44:14 <Koterpillar> harwiltz: paste the data types (see topic) and the *full* errors
17:44:33 <harwiltz> Koterpillar: Ok, just a sec
17:44:46 <harwiltz> circuits.hs:69:10: error:
17:44:48 <harwiltz>     • Could not deduce (Eq a) arising from a use of ‘coordp’
17:44:50 <harwiltz>       from the context: Floating a
17:44:52 <harwiltz>         bound by the type signature for:
17:44:54 <harwiltz>                    addp :: Floating a => Phasor a -> Phasor a -> Phasor a
17:44:55 <Koterpillar> heh
17:44:56 <harwiltz>         at circuits.hs:67:1-56
17:44:58 <harwiltz>       Possible fix:
17:45:00 <harwiltz>         add (Eq a) to the context of
17:45:02 <harwiltz>           the type signature for:
17:45:04 <Koterpillar> ?where paste
17:45:04 <lambdabot> Haskell pastebin: http://lpaste.net/
17:46:03 <harwiltz> Sorry, got kicked for that
17:46:07 <Koterpillar> ?where paste
17:46:07 <lambdabot> Haskell pastebin: http://lpaste.net/
17:46:07 <geekosaur> yes
17:46:19 <harwiltz> Do I need to repast that?
17:46:24 <geekosaur> to lpaste.net yes
17:46:24 <harwiltz> *repaste
17:46:27 <geekosaur>  not into the channel
17:46:27 <harwiltz> Ok
17:46:52 <harwiltz> http://lpaste.net/227536
17:46:57 <harwiltz> Thats the error
17:47:02 <dfeuer> Cale, the goal there is to try to make the rounding work "right" for floating point. It's truly horrible.
17:47:14 <harwiltz> Only two data types so I'll write them here.
17:47:28 <harwiltz> data CoordSyst = Rectangular|Polar deriving (Eq, Show)
17:47:31 <geekosaur> and the error message tells you the fix
17:47:38 <harwiltz> type Phasor a = (a,a,CoordSyst)
17:47:45 <Cale> dfeuer: But it doesn't really account for floating point precision at all.
17:48:00 <Cale> dfeuer: and it also applies to Rational's instance...
17:48:02 <harwiltz> Floating is not Eq? But the CoordSyst has nothing to do with a
17:48:03 <Koterpillar> harwiltz: and the type of coordp?
17:48:08 <Cale> where there's no rounding error at all
17:48:14 <dfeuer> Cale, to quote the sage David Feuer, "It's truly horrible."
17:48:18 <harwiltz> coordp :: (Floating a) => Phasor a -> CoordSyst
17:48:19 <Cale> heh
17:48:29 <Koterpillar> harwiltz: just paste the whole file
17:48:40 <harwiltz> Koterpillar: Oh crap. Nvm, I think I found it
17:48:44 <Koterpillar> harwiltz: it's tedious trying to extract information from you line by line
17:48:44 <harwiltz> Lemme try something
17:48:47 <geekosaur> if it uses (==) then it needs to be able to find an Eq instance. Floating does not, in ghc, include Eq
17:48:50 <geekosaur> (it used to)
17:48:54 <harwiltz> Koterpillar: Yeah, sorry about this.
17:49:35 <harwiltz> I got it. I actually had coordp :: (Eq a) => Phasor a -> CoordSyst by mistake
17:49:42 <lpaste> Ed_ pasted “Which version is better?” at http://lpaste.net/227548
17:49:59 <harwiltz> Sorry guys. Thanks for the help
17:50:02 <Cale> I dunno -- maybe someone was thinking of these list enumerations as being intended to generate points to sample for drawing a graph -- in cases like that, you might want one point past the end, so that you could fit in a partial line segment that would get cut off.
17:50:56 <Ed___> So Version 0 does tail recursion, but has to use last and init, and Version 1 does head recursion but has to reverse both inputs and then reverse the output. Version 0 uses append, Version 1 does concat. whats better? http://lpaste.net/227548
17:50:58 <geekosaur> I thought it was a hack so you'd get the last element if the FP representation undershot
17:51:13 <Cale> geekosaur: If that's so, then it's *very* imprecise
17:51:39 <Cale> There are much tighter ways of accomplishing that...
17:52:12 <Cale> > [1,3..10.0] -- this is not even close to rounding error
17:52:14 <lambdabot>  [1.0,3.0,5.0,7.0,9.0,11.0]
17:52:50 <Cale> > [1,3..10%1] -- and here, there is no rounding error
17:52:52 <lambdabot>  [1 % 1,3 % 1,5 % 1,7 % 1,9 % 1,11 % 1]
17:53:40 <Cale> But that might be right nonetheless.
17:53:56 <Ed___> head recursion over tail recursion even if multiple reverses are needed?
17:54:57 <Cale> Ed___: I'd start from Version 1, and then look for any excuse I could to avoid the reverses after all
17:55:11 <Cale> Like, just change the convention so the lists are stored in the other order
17:55:36 <Ed___> They will only be reversed once anyways...
17:56:15 <Cale> Ed___: alu' has a serious problem:  xs ++ ys  takes O(length xs) time to compute
17:56:26 <Cale> (because that's the best you can do)
17:57:00 <Cale> also, last and init are similarly expensive
17:57:05 <Ed___> sweet
17:57:09 <Ed___> thats what i needed
17:57:13 <Ed___> thanks for you help
17:57:25 <Cale> So alu' will be O(n^2) time
17:57:30 <Cale> The reverses are linear
17:57:32 <Ed___> i guess i should just look at how ++ init and last are defined in haskell
17:57:40 <Cale> @src (++)
17:57:40 <lambdabot> []     ++ ys = ys
17:57:40 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:57:40 <lambdabot> -- OR
17:57:40 <lambdabot> xs ++ ys = foldr (:) ys xs
17:57:53 <Cale> @src init
17:57:53 <lambdabot> init [x]    = []
17:57:53 <lambdabot> init (x:xs) = x : init xs
17:57:53 <lambdabot> init []     = error "Prelude.init: empty list"
17:57:58 <Cale> @src last
17:57:58 <lambdabot> last [x]    = x
17:57:58 <lambdabot> last (_:xs) = last xs
17:57:58 <lambdabot> last []     = error "Prelude.last: empty list"
17:58:29 <Ed___> awesome... thanks Cale
17:59:15 <Ed___> better do those 3 x reverses over all those init, tail, ++
17:59:21 <Cale> yeah
17:59:29 <Cale> There's another option too
18:00:12 <Cale> which is to switch from building lists of type [Bit] to building functions of type ([Bit] -> [Bit]) which prepend some elements to the beginning of a given list
18:00:23 <Cale> Then (++) becomes (.)
18:00:39 <Cale> and (.) is constant time
18:00:58 <Cale> But still the inits and lasts are bad
18:01:22 <Ed___> I understand what you mean
18:01:49 <Ed___> difficulty level ^^^^^
18:02:14 <Cale> Well, here's a good example of that tactic
18:02:31 <Ed___> does it save time/resources?
18:02:33 <Cale> Suppose we have a type like  data Tree a = Tip | Branch (Tree a) a (Tree a)
18:02:35 <Cale> yeah
18:02:53 <Cale> Now, we might naively write an in-order traversal like:
18:03:05 <Cale> inorder :: Tree a -> [a]
18:03:08 <Cale> inorder Tip = []
18:03:24 <Cale> inorder (Branch l x r) = inorder l ++ [x] ++ inorder r
18:04:03 <Cale> The [x] ++ inorder r is no problem, since [x] is a list of length 1, but inorder l is an arbitrarily long list, so for left-leaning trees, this takes quadratic time
18:04:49 <Cale> So, the trick is, instead of directly building a list of type [a], we build a function [a] -> [a] which is going to add some elements to the beginning of a list
18:04:53 <Cale> [] becomes id
18:05:00 <Cale> [x] becomes (x:)
18:05:04 <Cale> and (++) becomes (.)
18:05:14 <Ed___> ok
18:05:18 <Cale> inorder' :: Tree a -> [a] -> [a]
18:05:22 <Cale> inorder' Tip = id
18:05:36 <Cale> inorder' (Branch l x r) = inorder' l . (x:) . inorder' r
18:05:36 <Ed___> parentheses around the last 2 x [a]
18:06:15 <Ed___> :t id
18:06:17 <lambdabot> a -> a
18:06:19 <Cale> Yeah, inorder' :: Tree a -> ([a] -> [a]) is how we're thinking of it (though you could write in the extra argument and it ends up looking a little different, I like explaining it this way)
18:06:22 <joe9> need some design advice, please? I have to define these values for use in haskell https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.7-4.6/+/jb-dev/sysroot/usr/include/X11/keysymdef.h . I could define it as : data KeySym = BackSpace | Tab | .. and have a function : KeySym -> Int (which pattern matches on KeySym)
18:06:29 <Cale> id is the function defined as  id x = x
18:06:45 <Ed___> i just wanted to make sure its defined in Haskell
18:06:47 <joe9> Or, is it better to represent it as HashMap? If I go the HashMap route, I would have to represent them as Strings.
18:07:00 <joe9> and, it does not look that clean with strings.
18:07:16 <Cale> So, now we've replaced our linear time (++) with constant time function composition
18:07:19 <joe9> But, I also want to be able to lookup both ways.
18:07:29 <Cale> So overall the algorithm is linear time in the size of the tree
18:07:50 <Ed___> amazing!
18:07:51 <jle`> joe9: using a data type is better than strings
18:07:54 <Cale> and we can recover our original intended type just by applying the resulting function to an empty list:
18:07:59 <Ed___> Im saving that for future reference
18:08:01 <Cale> inorder :: Tree a -> [a]
18:08:05 <jle`> joe9: the only problem is that the data type is "closed"
18:08:07 <Cale> inorder t = inorder' t []
18:08:10 <joe9> If I go the data route, I could use deriving Enum, and use that to lookup too.
18:08:23 <jle`> so you could maybe have a final constructor with an arbitrary string, but that's kinda ugly
18:08:25 <joe9> jle`: That should be ok. It probably does not change that much.
18:09:33 <Koterpillar> Cale: what's the canonical name for this pattern?
18:09:54 <Koterpillar> Cale: I know it as "partial lists" or something
18:10:02 <ClaudiusMaximus> joe9: you could do like 'gl' etc and newtype Int or so and use pattern synonyms for the friendly names - that way you're still extensible (Int has plenty of values) but can pattern match with nice names
18:10:23 <Cale> Koterpillar: I've heard it called the "worker-wrapper transformation" but that's really referring to this more general pattern of passing to some other type on which operations are more efficient
18:10:36 <Cale> Koterpillar: Also "Difference lists"
18:10:43 <Koterpillar> oh right, difference lists
18:11:00 <Koterpillar> thanks!
18:11:01 <Ed___> Thanks Cale. Just curious, are you a professor?
18:11:07 <ClaudiusMaximus> joe9: https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html for example
18:12:15 <Cale> Ed___: Not professionally ;)
18:12:43 <EvanR> professornal
18:12:43 <Ed___> Ha. I was definitely starting to think my professor frequents this IRC
18:13:27 <alex_kosh> why (mag2  x= realPart $ (conjugate x) * x) has the type (mag2 :: RealFloat a => Complex a -> a) instead of (mag2 :: Num a => Complex a -> a)
18:13:42 <alex_kosh> to be clear, I am using Data.Complex
18:13:44 <Cale> Ed___: I've been helping people learn Haskell on IRC for quite a few years now (over a decade). These days I'm working for Obsidian Systems building web applications entirely in Haskell for various clients.
18:14:14 <Ed___> is there work out there in Haskell?
18:14:17 <Cale> Some
18:14:28 <Ed___> im interested in the financial secor
18:14:30 <Ed___> sector*
18:14:50 <Cale> That's one of the main places it comes from at the moment
18:14:50 <muyfine> is there a lens that will return the count of a container?
18:15:09 <Cale> muyfine: What would setting it do?
18:15:17 <muyfine> good point
18:15:26 <johnw> muyfine: a Fold will do this, though
18:15:37 <Ed___> do you use yesod?
18:15:53 <muyfine> man, I've completely removed Map namespace from my code - now I have to bring it in to get a count with Map.size
18:16:17 <ClaudiusMaximus> alex_kosh: becuase the Num for Complex is  RealFloat a => Num (Complex a)  (because sqrt is needed for 'abs'...)
18:17:03 <Cale> Ed___: On the backend, we're using Snap, but that's overkill in some ways, given that we're mostly serving up single page applications -- all the complicated work on the backend is in deciding what to communicate over websockets.
18:17:29 <Cale> Ed___: On the frontend, we're using ghcjs and reflex-dom
18:17:42 <alex_kosh> thanks
18:17:47 <Cale> (which is the really fun part :)
18:18:12 <Ed___> front end with Haskell? oh my
18:18:18 <Cale> Yep!
18:18:33 <muyfine> oh wow, size is just a fold in HashMap - I'll just do a fold
18:18:56 <muyfine> I guess I was kind of expecting a size from lens because I can get contains
18:19:08 <Cale> It's actually rather nice -- when we add a new feature, typically it starts out in the modules common to both the frontend and backend that are used to define the database schema and how we communicate between the frontend and backend
18:19:29 <Ed___> so who would request a web app built in haskell?
18:19:35 <Cale> and then you just steamroll the compiler over things, fixing all the errors in the backend and frontend until you have it :)
18:19:37 <Ed___> over say django/python
18:19:47 <joe9> ClaudiusMaximus:  Thansk.
18:19:52 <joe9> ClaudiusMaximus:Thanks.
18:20:34 <Cale> Ed___: Well, it seems we've mostly had startups as clients.
18:20:46 <Ed___> who want to be hip, lol?
18:21:17 <Ed___> or are there some serious advantages with haskell? type-safe, etc...
18:21:18 <Cale> I don't think they've been particularly concerned about what language we use so long as we're productive and their application works.
18:21:30 <Ed___> ah ok.
18:21:34 <Cale> We've found it way more productive than anything else.
18:21:50 <Cale> It's certainly a hell of a lot better than anything else I've tried.
18:22:35 <Wizek> @pl \exp-> if monadicDeps == [] then exp else doExpr exp
18:22:35 <lambdabot> ap (if' (monadicDeps == [])) doExpr
18:22:53 <exio4> Cale: how good has been the "work done / bugs in the final program" rate been?
18:23:42 <Ed___> I hoped Haskell would be a good 2nd language to pair with C++, but its looking more like Haskell will be my primary...
18:24:33 <Ed___> I'm just skeptical about hireability
18:24:35 <Cale> exio4: It's been pretty good. These clients have a tendency to change the requirements a lot, and the fact that we can refactor things mercilessly because of the type system has been pretty important for keeping things sane.
18:25:01 <joe9> ClaudiusMaximus: That article is very relevant and informative. Thanks.
18:25:16 <ClaudiusMaximus> joe9: glad to be useful
18:25:20 <exio4> Cale: heh, so it's not just marketing? :P
18:26:19 <Cale> heh
18:27:10 <Wizek> Cale, Great to hear someones have so much success with Ghcjs! I've yet to give it a serious try but reading your lines makes me hopeful
18:28:06 <Wizek> Cale, Have you run into any performance issues perhaps? I read somewhere that emulating GHC's runtime in JS can result in even ~10x slowdown compared to hand-written js
18:28:45 <Cale> Wizek: If you want to try it out, one of the quickest ways to get started is to clone https://github.com/reflex-frp/reflex-platform and run ./try-reflex from there, which will set up a nix environment with all the dependencies and drop you into a shell with ghc and ghcjs 8
18:29:27 <Cale> Wizek: I dunno, I think Ryan's said his tests were somewhere around 4x the time against native code.
18:30:41 <Cale> Not sure what the factor is between JS and native code, but I would expect GHC-compiled code to usually outstrip Javascript... the performance of the JS implementations lately has been pretty good though.
18:30:45 <Wizek> Cale, That sounds super convenient! It is 3:29 AM here but I am quite tempted to give it a go
18:30:58 * Wizek risks not sleeping for many hours more
18:32:47 <Cale> (and there's a mini-tutorial for reflex-dom on that page when you do try it)
18:32:52 <Ed___> @src head
18:32:52 <lambdabot> head (x:_) = x
18:32:52 <lambdabot> head []    = error "Prelude.head: empty list"
18:33:51 <Wizek> Cale, Nix is already franticly setting up my environment, fingers crossed! :)
18:35:13 <joe9> ClaudiusMaximus: on a slightly different note, is there any way I can generate the code? I could write a sed script/ shell script to generate the .hs file. But, not sure if there is anything to do such automatically.
18:35:14 <Wizek> Cale, what size codebases do you work with ghcjs? Do you ever need to interop with hand-written js? And if so, how do you find the ffi for that?
18:35:56 <luite> Cale: It can still be quite a bit faster. I've told a few people at ICFP about a few improvements I have planned
18:36:33 <Cale> luite: :D
18:37:43 <Wizek> joe9, Sorry if this is irrelevant, haven't been following what your original question may be about, but could TemplateHaskell help you out with generating haskell code?
18:38:25 <luite> Cale: the main thing I want to try out is to structure the generated JS around assuming that thunks are already in WHNF, making the "already evaluated" path cheaper at the cost of sometimes repeating cheap (and nondestructive) operations
18:40:21 <luite> also I'd like to start planning for a WebAssembly target
18:41:08 <Wizek> Oh my, Nix is really going into town with this! About 4 GB of unpacked data and counting.
18:43:24 <Cale> Wizek: Oh, yeah, I probably should have warned you -- it really does install all the dependencies -- nix is all about reproducible builds, so it hashes absolutely everything.
18:43:53 <Wizek> luite, Hmm, yes, WebAssembly does sound very promissing indeed! That way the performance could be on par with js, or perhaps even greater!
18:44:12 <Cale> luite: Sounds cool!
18:44:36 <harwiltz> Hello all. I'm getting a 'possibly incorrect indentation or mismatched brackets', but I see no problem with my code. Here is the problematic code: http://lpaste.net/227747. Getting the error on line 6.
18:44:55 <geekosaur> missing = after otherwse
18:44:56 <Cale> luite: How much of WebAssembly is properly specified so far? I remember hearing about it early on and thinking it would be really nice
18:45:13 <harwiltz> geekosaur: Seriously. I'm an idiot
18:45:35 <Wizek> harwiltz, Don't be too hard on yourself :)
18:46:04 <harwiltz> Wizek: Lol. I was looking through it for a solid ten minutes
18:47:10 <harwiltz> Thanks all.
18:47:16 <Cale> Wizek: and that's a project which is a chat service with a bunch of extra features intended to make it easier to keep track of what things people agreed on and tasks and scheduling, stuff like that.
18:50:41 <Wizek> Cale, I know how nix works in principle, and I am really fond of the underlying idea. I am just surprised how much disk space that sometimes means in practice and wonder how much duplication may be inside despite its efforts of deduplicating identical dependencies already.
18:52:59 <Wizek> Cale, It's done btw, I really like this little sandbox shell it put me in, exploring it at the moment. I may have found a means to write my next gui app! :D
18:53:15 <Wizek> *with
18:53:24 <Cale> Yeah, we actually use reflex-platform as the basis for our real work
18:55:39 <Cale> There's a work-on script there which you can run like  ./work-on ghcjs path/to/project  (or ghc in place of ghcjs) and it'll put you in a shell with the appropriate compiler and the cabal deps for your project.
19:02:46 <Wizek> Ok, really tired now, going to bed. Cale thanks for the discussion so far, I may catch you later for some more questions! Gn!
19:03:06 <jmcarthur> Cale: What makes Reflex different from other FRP libraries?
19:03:55 <MarcelineVQ> A cooler name
19:42:52 * hackagebot binary-parsers 0.2.3.0 - Extends binary with parsec/attoparsec style parsing combinators.  https://hackage.haskell.org/package/binary-parsers-0.2.3.0 (winterland)
19:52:44 <hololeap> So, I'm trying to think of a way to implement an equivalent to Ruby's each_with_index method. I was thinking the easiest way to do this would be with a monad?
19:53:44 <ReinH> > zipWith [0..] "hello"
19:53:46 <lambdabot>  error:
19:53:46 <lambdabot>      • Couldn't match expected type ‘Char -> b -> c’
19:53:46 <lambdabot>                    with actual type ‘[Integer]’
19:53:50 <ReinH> > zip [0..] "hello"
19:53:53 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
19:53:55 <ReinH> No monad required.
19:54:28 <ReinH> ofc that isn't an equivalent to Ruby's each_with_index, but Haskell isn't Ruby and doesn't have methods or allow arbitrary effects
19:54:43 <ReinH> So you don't really want an *equivalent*, you want something that can do similar things.
19:55:46 <Cale> :t zipWithM
19:55:48 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
19:56:11 <hololeap> Sorry, I actually meant something more like some_array.map(&:some_method).with_index
19:56:32 <ReinH> Same difference.
19:56:40 <hololeap> So I want it to apply an arbitrary function to a list and also keep count
19:56:45 <ReinH> Ok.
19:56:55 <grantwu> keep count?
19:57:25 <grantwu> some sort of fold with an explicit counter?
19:57:25 <hololeap> I guess it would just be zip [0..] (map someFunc aList)
19:58:17 <ReinH> zip [0..] . map someFunc
19:58:34 <ReinH> > takeWhile ((< 3) . fst) . zip [0..] . map toUpper $ "hello world"
19:58:36 <lambdabot>  [(0,'H'),(1,'E'),(2,'L')]
19:58:39 <Welkin> let zipWithIndex f = zipWith f [0..] in zipWithIndex (,) "cardiff"
19:58:42 <Welkin> > let zipWithIndex f = zipWith f [0..] in zipWithIndex (,) "cardiff"
19:58:44 <lambdabot>  [(0,'c'),(1,'a'),(2,'r'),(3,'d'),(4,'i'),(5,'f'),(6,'f')]
19:59:46 <Welkin> > let zipWithIndex f = zipWith f [0..] in zipWithIndex (\index a -> show index ++ a) "cardiff"
19:59:48 <lambdabot>  error:
19:59:48 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
19:59:48 <lambdabot>        Expected type: [[Char]]
19:59:58 <Welkin> > let zipWithIndex f = zipWith f [0..] in zipWithIndex (\index a -> show index ++ [a]) "cardiff"
19:59:59 <lambdabot>  ["0c","1a","2r","3d","4i","5f","6f"]
20:01:16 <hololeap> So what if the arbitrary function also needed access to the counter? Would that require a monad?
20:01:27 <ReinH> hololeap: my arbitrary function accesses the counter
20:01:32 <ReinH> no monads required
20:01:34 <Welkin> lol hololeap 
20:01:39 <Welkin> just read the definition
20:02:21 <hololeap> Ok, let me explain. I've been reading this: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
20:03:39 <Welkin> a monad is just bind (>>=) and return
20:03:43 <Welkin> you don't need either of those here
20:03:53 <ReinH> Just bind, at this point.
20:04:19 <ReinH> (Since return is provided by the Applicative instance)
20:04:37 <ReinH> But it's true that nothing about this necessitates bind or return.
20:05:19 <ReinH> once you zip up a list with each element and its index, you are free to work with it however you want. map, fold, filter, etc.
20:05:57 <hololeap> I'm trying to understand the elementary concepts behind the language rather than just learn the syntax and make working programs.
20:06:07 <ReinH> you might be able to do it more directly by using zipWith rather than tupling and untupling each element
20:06:11 <ReinH> but the idea is the same
20:06:31 <Welkin> hololeap: monad is just a typeclass
20:06:37 <Welkin> it's nothing special
20:06:59 <grantwu> hololeap: https://github.com/bitemyapp/learnhaskell
20:07:00 <hololeap> And I've been thinking about how one could make programs like the ones I am used to in procedural languages without keeping state through global variables and the like.
20:07:01 <Welkin> learning category theory will not help you 
20:07:17 <ReinH> hololeap: You don't.
20:07:29 <ReinH> You make them in a different way than the ones you are used to
20:07:29 <Welkin> well, you *can*
20:07:35 <hololeap> And the answer seems to be that you have to pass the state along with each function call.
20:07:39 <ReinH> since Haskell is not a procedural language
20:07:44 <Welkin> you can program haskell like it was c if you wanted to
20:07:52 <Welkin> with global mutable state and all
20:08:17 <grantwu> but... don't do that
20:08:35 <mjhoy> hololeap: I'd say check out StateT, play around with it.
20:08:37 <ReinH> This just isn't a good question to use to explore monads.
20:08:38 <Welkin> the language doesn't make it easy, or pretty, to do though
20:08:50 <ReinH> Nothing about it suggests the use of a monad instance.
20:09:12 <ReinH> [] is a monad instance, but that is unrelated to the question
20:09:14 <Welkin> hololeap: if you want to explore monads, then try writing mond instances for existing types, like Reader, Writer, Maybe, List
20:09:41 <hololeap> So why does passing the debugging tree use a monad in the example, but you are saying that passing the counter state doesn't require one?
20:09:51 <ReinH> hololeap: there's no counter "state"
20:09:56 <hololeap> Not tree, don't know why I typed that...
20:10:06 <ReinH> once you zip the counters up with the elements, you're done
20:10:15 <hololeap> Ok, so I guess it was just a bad example then
20:11:12 <ReinH> hololeap: you should read http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
20:11:17 <hololeap> Don't list comprehensions use monads behind the scenes?
20:11:22 <ReinH> No, they don't.
20:11:29 <grantwu> wat
20:11:30 <ReinH> Their desugaring does not involve the list monad.
20:11:44 <ReinH> You can find it in the haskell report.
20:11:50 <hololeap> I don't know wtf I've been reading then
20:11:55 <ReinH> Me neither.
20:11:59 <amalloy> one thing that might be an interesting way to explore monads is to write a function that's specialized for a monad you know well, such as lists, and then see if you can generalize it to work with any monad. in many cases you can't, but it is easy to "co-invent" liftA2, for example
20:12:03 <Welkin> maybe you are thinking of this?
20:12:12 <Welkin> > sequence [[1,2],[3,4]]
20:12:14 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
20:12:22 <ReinH> hololeap: it *could* be implemented that way, but it is not.
20:12:35 <ReinH> > [ x + 1 | x <- [1..5] ]
20:12:37 <lambdabot>  [2,3,4,5,6]
20:12:43 <ReinH> > do x <- [1..5]; return (x + 1)
20:12:46 <lambdabot>  [2,3,4,5,6]
20:13:05 <hololeap> I see... So then my question *could* use monads but it would be overkill?
20:13:09 <Welkin> > map (+1) [1..5]
20:13:11 <lambdabot>  [2,3,4,5,6]
20:13:18 <ReinH> Your question doesn't use list comprehensions either
20:13:22 <Welkin> map only uses the Functor instance
20:13:37 <amalloy> i mean, anything that uses a list "uses monads", because lists are monads whether you want them to be or not. but you aren't really using that property of lists to do a zipWith
20:13:51 <Axman6> hololeap: I think your mental model for "monads" is making them into a much bigger th9ing than they actually are. for lists, the Monad instance is just (\x -> [x]) and concatMap
20:13:54 <Welkin> amalloy: that is a confusing way to say it
20:13:56 <hololeap> I think my brain is on the right track, but I am over-generalizing what monads are good for.
20:13:56 <Axman6> there's nothing magic going on
20:13:57 <ReinH> amalloy: I would say that using a list without using its (>>=) and return implementations is not "using a monad"
20:14:03 <Welkin> monad is just a typeclass
20:14:04 <ReinH> amalloy: a list *has* a monad instance
20:14:12 <Axman6> > concatMap (\x -> [x+1]) [1..10]
20:14:14 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:14:22 <Welkin> if you are not using the typeclass members, you are not using that typeclass
20:14:23 <ReinH> I don't think it's helpful to talk about "using a monad" when you just mean "using a list"
20:14:29 <Axman6> > [1..10] >>= (\x -> [x+1])
20:14:31 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:14:50 <ReinH> hololeap: this question doesn't involve list comprehensions. If you tried to do it with list comprehensions, you'd get the wrong answer.
20:15:04 <ReinH> > [(n, x) | n <- [0..], x <- "hello"]
20:15:06 <lambdabot>  [(0,'h'),(0,'e'),(0,'l'),(0,'l'),(0,'o'),(1,'h'),(1,'e'),(1,'l'),(1,'l'),(1,...
20:15:10 <ReinH> Woops
20:15:25 <ReinH> Ditto monads
20:15:32 <Welkin> moonads
20:15:34 <ReinH> You *can* do it with an applicative instance, but not the one for lists.
20:15:48 <ReinH> the *other* one for lists, given by the ZipList newtype
20:15:50 <ReinH> and its instance
20:16:07 <Welkin> "hello hell"
20:16:09 <ReinH> > (,) <$> ZipList [0..] <> ZipList "hello"
20:16:11 <lambdabot>  error:
20:16:11 <lambdabot>      • No instance for (Monoid (ZipList Char))
20:16:11 <lambdabot>          arising from a use of ‘<>’
20:16:20 <ReinH> woops
20:16:23 <Welkin> lambdabot is trying to tell us something
20:16:28 <ReinH> > (,) <$> ZipList [0..] <*> ZipList "hello"
20:16:30 <lambdabot>  ZipList {getZipList = [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]}
20:16:55 <ReinH> That is a use of an Applicative instance to answer the question
20:17:12 <hololeap> I don't even know what that is
20:17:18 <ReinH> but ZipList isn't a Monad.
20:17:27 <ReinH> http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#v:ZipList
20:17:34 <ReinH> List can have multiple applicative instances
20:18:07 <hololeap> Ok. I think I spare everyone any more noob questions for today.
20:18:37 <ReinH> noob questions are fine
20:19:07 <hololeap> In small doses :) I need to keep reading
20:19:21 <grantwu> hololeap: fwiw I found that article really helpful
20:19:25 <ReinH> you need to keep *doing*.
20:19:26 <Welkin> you don't need to worry about monads until you need to use them
20:19:29 <ReinH> not just reading
20:19:35 <Welkin> when you do, you'll realize they are nothing special
20:19:36 <grantwu> Although there are some typos in the random generation section
20:19:46 <Welkin> just a logical extension of applicative, which is a logical entension of functor
20:19:53 <hololeap> I wouldn't even care about monads if I hadn't read that article. That and apparently IO uses them.
20:20:05 <ReinH> We could do IO without them
20:20:13 <ReinH> it would be easy
20:20:18 <ReinH> and possibly less confusing
20:20:43 <ReinH> but since the thing we want to do with IO is the thing you can do with a Monad, we just use a Monad instance.
20:20:51 <ReinH> You should read the Wadler paper
20:20:51 <hololeap> I have another question then... How do you deal with state outside the programming language, like querying an SQL database?
20:20:54 <ReinH> it's very approachable
20:21:04 <ReinH> hololeap: by executing IO actions
20:21:12 <hololeap> Right...
20:21:25 <ReinH> imagine a function andThen :: IO a -> (a -> IO b) -> IO b
20:21:27 <ReinH> for example:
20:21:31 <hololeap> The Wadler paper explains how this is done without monads?
20:21:41 <ReinH> readFile "foo.txt" `andThen` \contents -> putStrLn contents
20:22:00 <ReinH> No, it explains how it's done *with* monads, and why the concept of a monad was added rather than doing it in this ad hoc way I am proposing
20:22:44 <hololeap> Doesn't readFile use IO though??
20:22:48 <ReinH> Yes.
20:23:14 <ReinH> I'm saying that IO doesn't require monads, it can be done in this ad hoc way
20:23:17 <grantwu> I think ReinH is saying, suppose IO weren't a monad
20:23:53 <hololeap> If I could read something that explains in detail how it could be done without a monad, and then I read this paper, I feel like I'll understand monads a lot better.
20:23:54 <ReinH> Monads are just "oh, this is the same thing in different forms, let's abstract it and give it a name"
20:24:01 <ReinH> "Oh, and we would like if that thing had some nice properties"
20:24:12 <ReinH> "Oh, that thing and its properties are already a thing somewhere else and we can just reuse it"
20:24:15 <ReinH> that's how monads happened
20:24:23 <ReinH> The paper talks about this more
20:24:41 <ReinH> e.g. we'd like to say:
20:24:44 <grantwu> hololeap: Basically, suppose we had a type IO a that represented an effectful computation
20:24:44 <ReinH> do a
20:24:59 <ReinH>    do b
20:25:01 <ReinH>       c
20:25:03 <ReinH> is the same as
20:25:04 <ReinH> do a
20:25:07 <ReinH>    b
20:25:07 <ReinH>    c
20:25:25 <ReinH> the extra do in there doesn't change the meaning
20:25:29 <ReinH> so that's a law
20:26:06 <hololeap> I'll check the paper out.
20:26:27 <jle`> hololeap: "how it can be done without a monad" doesn't really make sense as a question.  that's like asking how you can add numbers without group theory
20:26:35 <ReinH> Sure it does
20:26:40 <grantwu> wat
20:26:44 <ReinH> You can easily add numbers without group theory
20:26:48 <ReinH> you can do it in an ad hoc way
20:26:51 <grantwu> Toddlers can add numbers, they don't know group thoery
20:27:00 <hololeap> Well then I guess the other question is, why did they switch to using monads for IO?
20:27:14 <ReinH> hololeap: because it was a nice way to handle it
20:27:15 <grantwu> It was a useful abstraction
20:27:16 <jle`> yeah, you can add numbers without group theory, you can do IO without being aware that it's a Monad
20:27:19 <ReinH> it had the properties we wanted
20:27:22 <ReinH> and an awful name
20:27:26 <Welkin> a moonad
20:27:28 <ReinH> but mostly it had the properties we wanted
20:27:38 <hololeap> But IO is an abstraction, so why change what happens behind the scenes?
20:28:01 <ReinH> hololeap: it was literally a process of "Oh, these two things are similar. Let's extract out the similar bits. Oh, here's another."
20:28:06 <exio4> to make it easier for programmers :)
20:28:30 <ReinH> "Oh, here's an existing concept that maps directly onto the thing we extracted out, so let's just call it that"
20:29:04 <jle`> hololeap: it's not that we decided one day to "use monads for IO"; it's more that we just chose a different system for IO that was useful, and one small aspect of it was that it had a useful monadic API
20:29:14 <ReinH> hololeap: what do you mean "change what happens behind the scenes"?
20:29:15 <jle`> nobody really looked at IO and said "we need monads here"
20:29:39 <ReinH> Seriously, read the paper :)
20:30:00 <ReinH> jle`: Ok, I'm going to write a monad tutorial.
20:30:06 <ReinH> I've finally figured out what to write.
20:30:13 <jle`> hololeap: IO doesn't "use monads"
20:30:14 <exio4> that they are burritos?
20:30:16 <hololeap> Ok, so monads are a type of thing, there are many, many types of these things, but monads have a name, and that's the only thing that makes them special...?
20:30:18 <ReinH> jle`: It's going to be wadler's paper plus exercises.
20:30:46 <ReinH> hololeap: a monad is anything that you can write (>>=) and return for, it just turns out that there are lots of these and they are surprisingly useful
20:30:50 <jle`> hololeap: it's a name for a certain pattern that a lot of things seem to exhibit
20:30:52 <ReinH> jle`: and that's it
20:31:07 <hololeap> ok, makes sense :)
20:31:07 <jle`> ReinH: i can get behind this
20:31:19 <ReinH> hololeap: It isn't different in kind from "we need some sort of way to iterate over things. Oh, let's call it a for loop and give it some semantics"
20:31:30 <ReinH> Now we can do lots of things with for loops, yay!
20:31:36 <Narfinger> hiho, I am wondering if there is a good way to do the following: I have a list of Int but I know that they are all positive so now when I do minimum, it can stop searching when it finds a zero
20:31:57 <jle`> hololeap: IO itself is a very useful type with very useful semantics, etc., and it just happens to have a pattern that people also found in lists, Maybe, and a lot of other things that is neat
20:32:11 <ReinH> The fact that it was originally a mathematical concept is intimidating, but mostly irrelevant
20:32:17 <amalloy> Narfinger: foldr with a function that doesn't look at its second argument if the first argument is enough to know the answer
20:32:18 <Welkin> Narfinger: write a recursive definition
20:32:31 <hololeap> It all makes perfect sense. I was thinking that monads were the *only* way to do certain things.
20:32:39 <Narfinger> ok I will do that
20:32:46 <ReinH> lazyMin 0 _ = 0; lazyMin x y = min x y
20:32:52 <ReinH> foldr lazyMin
20:33:25 <jle`> hololeap: i wouldn't call monads a "way to do things".  for IO, te IO type *itself* is an implementation of a way to do IO ... a pretty nice way, actually
20:33:34 <Narfinger> by the way, in sml there was a speed difference between foldl and foldr, is that also the case in haskell?
20:33:40 <ReinH> hololeap: It depends.
20:33:46 <Welkin> Narfinger: use foldl'
20:33:55 <Welkin> foldr and foldl'
20:34:04 <ReinH> er, Narfinger: it depends
20:34:17 <ReinH> Generally you want foldl' instead of foldl though, as Welkin says
20:34:41 <Narfinger> ok thanks
20:34:42 <Welkin> but the compiler will optimize foldl into foldl' for you in most cases I think
20:36:07 <ReinH> Not really. Generally it's unwise to depend on strictness analysis.
20:36:20 <ReinH> In this particular case, you need guarded recursion, so foldl isn't an option.
20:36:39 <jle`> i sort of think of foldl' as a way to implement imerative algorithms where you process items in a list one-by-one into an accumulator
20:36:56 <jle`> i think of foldr as a way of breaking down a list's structure
20:36:59 <ReinH> I did run across a case where foldl was better than foldl' recently, but I can't remember what it was
20:37:01 <jle`> i'm not sure if this is a useful way of thinking of things
20:37:02 <ReinH> but they do exist
20:37:31 <ReinH> it's also important to remember that foldl' only forces the outermost constructor of the accumulator, which is often not enough.
20:37:40 <jle`> but one big thing is that foldr is necessary if you want to short-circuit
20:37:49 <jle`> as you appear to want in this case
20:38:10 <ReinH> Narfinger: I can probably convince you that foldr isn't necessarily slower than foldr by telling you that foldl' is implemented as a foldr.
20:38:18 <ReinH> er, than foldl'
20:38:33 <ReinH> (Ofc the optimization that allows that happened relatively recently)
20:39:23 <Narfinger> oh wow
20:40:12 <jle`> usually for a fold i use foldl', unless i want to short-circuit or if it's clear that i'm trying to take advantage of a list's structure
20:40:20 <jle`> (in which case i'd use foldr)
20:40:58 <jle`> for example, to implement a function that ||'s every item in a list, you can imagine transforming (x:y:z:...) into (x || y || z || ...)
20:41:07 <jle`> just replacing all the :'s with ||'s
20:41:16 <jle`> that's an idea that's well expressed with foldr
20:41:22 <ReinH> And (||) True is non-strict
20:41:33 <ReinH> > foldr (||) False (repeat True)
20:41:35 <lambdabot>  True
20:41:44 <ReinH> Same idea, really
20:41:52 <jle`> if you imagine a list as a maximally unbalanced tree, it's like replacing all the nodes with ||
20:42:10 <ReinH> since (||) is a non-strict max for booleans
20:42:27 <ReinH> > max True False
20:42:30 <lambdabot>  True
20:42:34 <ReinH> > max True undefined
20:42:36 <lambdabot>  *Exception: Prelude.undefined
20:42:57 <jle`> but a lot of times with folds you're implementing an imperative loop that chomps down items in a list one-by-one and outputs the result at the end, and that's something that's more naturally expressed with foldl'
20:43:18 <jle`> idk
20:43:22 <ReinH> jle`: the "lists as loops waiting to be executed" thing is a nice way to work with some data structures, like tries
20:43:47 <ReinH> e.g. implementing insert as a foldr over the string to be inserted
20:43:55 <ReinH> you can even implement delete in this way
20:44:58 <ReinH> As a side note, I really wish list-tries exported its constructors, but I am going to submit a patch that *does* expose its canonical church fold, which is almost the same thing.
20:45:18 <ReinH> (in the same way that foldr is the canonical fold for lists)
20:49:34 <muyfine> trying to figure out how to access a key in a maybe map with lenses
20:49:38 <muyfine> data Simple = Simple { _simpleMap :: Maybe (HashMap Text Text) }
20:50:02 <muyfine> If I'm holding on to a Simple piece of data
20:51:31 <ReinH> > Just (fromList [(1, 1)] :: Data.Map.Map Int Int) ^? _Just . ix 1
20:51:39 <lambdabot>  Just 1
20:52:28 <ReinH> I'm not sure if ix is kosher there actually
20:54:58 <ReinH> you would also need your lens for Simple
20:55:03 <ReinH> (iso, really)
20:55:25 <ReinH> although generating a lens called `map' sounds problematic
20:56:41 <muyfine> ahh - so it does have a lens - I exracted out a simple piece from the datastructure
20:57:45 <muyfine> I'm able to set it with somethign like: addSimple k v = simpleMap . _Just . at k ?~ v
20:58:05 <ReinH> yeah
20:58:08 <ReinH> something like that
20:58:11 <muyfine> but having trouble trying to get just the acc
20:58:15 <muyfine> access
20:58:27 <laudiacay> hey, my instructor's been doing some weird thing where he gets ghci to show him every step of evaluation on the way to getting an answer? does anyone know what this is or how to access it? examples near the bottom of http://cmsc-16100.cs.uchicago.edu/2016/Notes/arithmetic.php
20:58:41 <muyfine> I thought I could have done somethign like:
20:58:43 <muyfine> lookupSimple k v = simpleMap . _Just . at k
20:58:46 <muyfine> but no bueno
20:58:53 <ReinH> laudiacay: I'm pretty sure they're just writing that out manually
20:59:05 <ReinH> muyfine: ix
20:59:14 <ReinH> see my above
20:59:27 <laudiacay> ReinH: yikes that's really sad because i have no idea how haskell works on the inside and hahhahaha look at question 4 all the way at the bottom hahahha im going to get wrecked
21:00:09 <ReinH> laudiacay: it's really not that much to write
21:00:16 <ReinH> and writing it out will help you to learn it
21:00:19 <ReinH> which is the point
21:00:29 <laudiacay> i mainly have no idea where to start but oh well time to do some research about laziness
21:00:34 <laudiacay> in the form of netflix
21:00:40 <ReinH> @where lazy
21:00:40 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
21:00:43 <ReinH> Might be a useful read
21:00:48 <laudiacay> <3 thanks
21:00:59 <ReinH> This is once again why I think every Haskell tutorial should start with pattern matching and evaluation.
21:01:37 <ReinH> since that's about 90% of Haskell.
21:02:16 <ReinH> ADTs, pattern matching, leftmost-outermost evaluation, sharing. (The last two are what make up lazy evaluation.)
21:02:38 <ReinH> And, I guess, "=" and "::"
21:02:45 <laudiacay> i mean we are doing goofy function definitions mostly with some lefteval stuff, but the peano assignment has some pattern matching 
21:02:55 <ReinH> it's all patterm matching
21:03:08 <laudiacay> im really proud of my recursive definition of subtraction tbh
21:03:11 <ReinH> everything you do to the left of an = and the right of the identifier you are defining is pattern matching.
21:03:24 <laudiacay> day 2 of haskell and i am not crying as hard as i was over this class
21:03:26 <ReinH> id x = x involves pattern matching
21:03:29 <ReinH> yay :)
21:04:10 <laudiacay> yes :D im so glad my school does haskell for intro CS, if it was more python i might have died
21:04:19 <laudiacay> but this is mad interesting
21:04:21 <ReinH> that's pretty sweet
21:04:51 <ReinH> laudiacay: if you want to supplement your class, I'd recommend Hutton's brand new Programming in Haskell (2nd edition)
21:05:02 <ReinH> really good explanations of pattern matching, lazy evaluation, all the fundamentals.
21:05:18 <laudiacay> i have hard copies of real world haskell and learn you a haskell and zero money :(
21:05:21 <laudiacay> is there a copy online?
21:05:37 <ReinH> Not sure, maybe you can find one
21:05:53 <laudiacay> ooh piracy
21:05:56 <laudiacay> sneaky sneaky
21:05:58 <laudiacay> thanks :D
21:06:19 <geekosaur> @where rwh
21:06:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:06:22 <ReinH> RWH and LYAH aren't the best, but RWH is the better of the two (as long as you read all the comments in the online version that address the errata)
21:06:56 <ReinH> LYAH is superficial and lacks exercises :(
21:07:23 <laudiacay> ReinH: it's entertaining though
21:07:30 <laudiacay> and superficial is sorta what i need right now
21:07:40 <ReinH> I disagree
21:07:49 <laudiacay> just like quick and easy so i can get through an assignment and learn some other aspect more deeply
21:07:50 <ReinH> superficial makes you think you learn something you haven't actually learned
21:08:22 <ReinH> I think you can find Bird and Wadler's old Introduction to Functional Programming online, and while it's a bit dated, it remains one of the best FP books I've ever read.
21:08:24 <laudiacay> idk like, i'll learn thing y well eventually, but not when i only need a basic knowledge of y to get my deep knowledge of x
21:08:29 <laudiacay> oh shit yeah ill look at that
21:08:51 <ReinH> the first book to properly cover non-strict evaluation in print, afaik
21:09:11 <EvanR> RWH was freely available online at some point, with comments
21:09:23 <ReinH> has some cool stuff like minmax -> alphabeta pruning by equational reasoning
21:09:28 <ReinH> which I actually used recently
21:09:33 <ReinH> EvanR: still is
21:09:52 <ReinH> Was linked above :)
21:12:39 <EvanR> oh mr > 25 lines of scrollback, fancy
21:16:06 <ReinH> EvanR: :p
21:17:18 <EvanR> you must have one of these http://www.apple-forever.com/pix_big/34.jpg
21:20:35 <ReinH> nice
21:36:09 <joe9> What am I doing wrong with this? http://dpaste.com/20GMGMZ I am trying to follow the FFI RWH chapter to generate the .hs file from .hsc file using hsc2hs
21:36:30 <joe9> output http://dpaste.com/2GKJ2BZ
21:36:34 <joe9> it is the same as the input.
21:37:22 <joe9> https://paste.pound-python.org/show/qxES0uXg9n54AGDXVxvY/ is the --verbose output
21:41:27 <ReinH> joe9: I mean, you're missing an "}"
21:41:41 <geekosaur> missing all the final }s on lines
21:41:44 <joe9>  ReinH: #{const .. }?
21:41:49 <geekosaur> no
21:41:59 <joe9> oh, got it.
21:42:05 <joe9> in the definition of KeySymbol
21:42:14 <geekosaur> also in the pragmas at the top
21:42:24 <geekosaur> {-# LANGUAGE ForeignFunctionInterface #-
21:42:44 <geekosaur> since hsc2hs is not a full haskell parser, it probably thinks the whole file is a comment
21:42:50 <joe9> oh, got it.
21:43:08 <joe9> geekosaur: ReinH, :%s/}//g sometime ago.
21:43:25 <ReinH> Yeah, that seems like a bad thing to do.
21:47:20 <joe9> I cannot make up my mind if pattern synonyms make the code ugly or help.
21:47:45 <joe9> it defines an empty data Renderer in this example https://github.com/ocharles/blog/blob/master/code/2014-12-03-pattern-synonyms.hs
21:48:04 <joe9> any suggestions, please?
21:49:33 <joe9> it is probably cleaner to have the data with all the elements. after all, that code is generated by a sed or grep script
21:50:39 <jle`> why isn't foldl' in prelude ;_;
22:01:17 <EvanR> jle`: anymore?
22:02:00 <EvanR> maybe they are trying surpress knowledge of foldl', like its a blemish on haskells supposed beauty
22:02:44 <jle`> was it ever in prelude?
22:06:02 <dmj`> only in Data.List
22:08:17 <muyfine> I'm trying to update a Maybe Map with lenses
22:08:17 * geekosaur just wanted foldl1'
22:08:18 <Welkin> dmj`: 
22:08:25 <muyfine> I've been tried:   myMap . _Just . at k ?~ v
22:08:35 <dmj`> Welkin:
22:08:35 <Welkin> dmj`: what do you use for cors with servant?
22:08:41 <muyfine> but if the map is Nothing, I never can "initialize" the map
22:08:51 <Welkin> I got it working but it is polluting my api definitions
22:08:56 <dmj`> Welkin: http headers
22:08:59 <muyfine> this works: myMap %~ return . maybe (M.singleton k v) (M.insert k v)
22:09:07 <dmj`> Welkin: polluting? how so
22:09:13 <Koterpillar> muyfine: do you really need a Maybe Map?
22:09:18 <muyfine> but trying to figure out how to express that with lenses
22:09:23 <muyfine> Koterpillar unfortunately
22:09:24 <Welkin> dmj`: yeah, but without adding `Headers '[Header ... ] Type`
22:09:28 <Koterpillar> muyfine: or can you use an M.empty instead of Nothing
22:09:28 <Welkin> to every endpoint
22:09:37 <Welkin> and `addHeader` to every definition
22:09:45 <muyfine> it comes from a data structure that is given to me 
22:09:56 <muyfine> so can't use M.empty
22:10:06 <Welkin> I tried to install wai-cors with nix but it failed to build
22:10:33 <muyfine> Can I use non to setup the map if it's not there?
22:10:42 <dmj`> Welkin: you'd have to make your own combinator
22:11:24 <Welkin> or could I solve it by having my client served through the Raw endpoint?
22:11:46 <Welkin> any idea why wai-cors would fail to build in nix?
22:12:00 <Axman6> muyfine: I think you want: myMaybeMap & _Just . at k ?~ v
22:12:07 <Axman6> hmm, something tells me that won't work
22:12:38 <muyfine> Axman6 that's what I have that won't update if the map is nothing
22:12:48 <dmj`> Welkin: Raw becomes a black hole
22:12:54 <Axman6> > Just (M.singleton 1 "Hello") & _Just . at 1 ?~ "Bye"
22:12:58 <lambdabot>  Just (fromList [(1,"Bye")])
22:13:03 <Axman6> hmm, I guess it does!
22:13:24 <dmj`> Welkin: not w/o the error message
22:13:39 <dmj`> Welkin: addHeader isn't so bad
22:14:06 <Axman6> > Nothing & _Just . at 1 ?~ "Bye" :: Maybe (M.Map Int String)
22:14:08 <lambdabot>  Nothing
22:14:39 <muyfine> yeah, that's what I'm seeing :(
22:14:57 <Welkin> dmj`: http://lpaste.net/6070431365130616832
22:14:58 <Axman6> :t re _Just
22:14:59 <Welkin> it's long
22:15:00 <lambdabot> Contravariant f => LensLike' f a (Maybe a)
22:17:24 <dmj`> Welkin: wai-cors has -Werror / -Wall enabled
22:17:40 <dmj`> or GHC8 doesn't permit redundant constraints, one solution is to use an earlier compiler
22:18:24 <dmj`> Welkin: try 'nix-build --argstr compiler ghc7103'
22:18:25 <Axman6> :t non
22:18:25 <Hafydd_> That's something you never want to hear.
22:18:26 <lambdabot> (Profunctor p, Functor f, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
22:19:00 <Welkin> dmj`: but everything else is using ghc 8.0.1
22:19:32 <dmj`> Welkin: what is everything else?
22:19:49 <Welkin> the whole project
22:20:03 <dmj`> Welkin: you're using ghc8 specific extensions?
22:20:06 <Welkin> no
22:20:56 <dmj`> Welkin: well either override the wai-cors package in your config.nix, or try an earlier compiler
22:21:04 <dmj`> you can clone it, then specify packageOverrides
22:21:14 <Welkin> what do you mean by override?
22:23:25 <dmj`> Welkin: you define in ~/.nixpkgs/config.nix the name wai-cors, in a set, but callPackage to some location on your hard drive that has the fixed version of wai-cors
22:23:43 <dmj`> Welkin: or you can just override it in the file cabal2nix generates
22:25:43 <dmj`> cabal get wai-cors, cabal2nix in wai-cors, fix redundant constraint, then in your-project, wai-cors = pkgs.callPackage ../Desktop/wai-cors/wai-cors.nix {}, then pass that in as an arg to default.nix I think
22:28:09 <dmj`> can anyone talk about pull vs. push based FRP w/ me
22:39:23 <liyang> Would anyone mind running https://gist.github.com/liyang/7599a0449d5935fa27af4c502cc3b8b1 over their codebase? It ranks all the LANGUAGE extensions you've used.
22:44:54 <allenj12> is there a channel for emacs questions regarding haskell?
22:45:13 <johnw> there is #haskell-emacs, but it's fairly low traffic
22:45:30 <allenj12> ok, i was just there and I was the only one
22:45:52 <srhb> allenj12: Then you weren't there. Plenty of people.
22:46:17 <allenj12> must of mispelt it
22:46:32 <srhb> allenj12: :P
22:48:21 <allenj12> :D, was getting worried :D
23:05:44 <begriffs> Note for bay area people, we've been running a fun recurring Haskell hacknight in SF. If you're interested sign up for the announcement list. https://begriffs.com/haskell
23:08:16 <augur_> SF hack hack hack \o/
23:08:47 <johnw> hi begriffs!
23:09:38 <augur_> note: that's happening tomorrow at 6 at noisebridge
23:10:31 <begriffs> Thursday at 6
23:10:39 <begriffs> johnw: hi there!
23:10:51 <augur_> oops, todays still tuesday :)
23:11:07 <begriffs> The edge of Tuesday, that edge case. :)
23:11:39 <Axman6> waaa, it's thursday here... that can't be right
23:12:10 <begriffs> That crazy spinning sphere we call home, never can tell what time it is.
23:13:16 <NextHendrix> begriffs: http://everytimezone.com/
23:13:27 <NextHendrix> timezone maths is the worst kind, this is handy
23:14:06 <NextHendrix> you can drag the thing about, i use it to find out when new episodes of stuff comes out in america
23:16:21 <Axman6> that seems a lot less than every time zone
23:17:57 <bollu> I'm trying to grok free DSLs
23:18:18 <fp_preist> Checking out the video called "Purely Functional Linux with NixOS"
23:18:28 <bollu> so, since a Free monad on >>= fills up the "holes" in the structure and leaves the "Pure" nodes alone
23:18:38 <bollu> and since a Free DSL has only one "hole" (at the end)
23:18:55 <bollu> this lets us take advantage of do-notation to write a _sequential_ structure using Free, correct?
23:19:04 <srhb> fp_preist: Which video is that?
23:19:12 <bollu> is my intuition correct?
23:19:26 <srhb> fp_preist: (And you can come to #nixos if you want :-))
23:20:01 <fp_preist> I live in South Korea, it's a bit of a commute.
23:20:25 <Axman6> There is a local in your nearest major city
23:20:44 <fp_preist> Perfect Axman6.
23:21:13 <Axman6> local mirror*
23:21:16 <fp_preist> @srhb It's the first video on begriffs.com
23:21:16 <lambdabot> Source not found. Whoa.
23:21:49 <srhb> fp_preist: Ah. :)
23:23:59 <f-a> arrows: can someone translate the 'mean5' bit in desugared notation (i.e. loop ...) https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial#Recursive_bindings 
23:26:24 <joe9> I have a file that I am building with hsc2hs. The include directive is '#include "xproto/x.h"'. The actual x.h location is src/xproto/x.h . How do I tell cabal about the location of this file? when I run hsc2hs standalone, it runs fine.
23:26:36 <joe9> when I let cabal run hsc2hs, it cannot find the x.h file
23:26:55 <joe9> I just need the x.h file. It is not a library
23:27:06 <joe9> just an include file from which I want to use #define values
23:27:21 <srhb> joe9: includes: ?
23:27:35 <joe9> KeySymbolDefinitions.hsc:77:30: fatal error: xproto/keysymdef.h: No such file or directory
23:27:39 <joe9> is the erro message
23:27:51 <joe9> srhb: includes in the cabal file?
23:27:59 <srhb> joe9: Is it in the includes section in the hsc2hs library/executable section?
23:29:12 <joncol> Hello, is there a more succinct variant of the following Parsec code where I want to parse one of many options, but ignore the results? Note that the parsers parse different types: choice [ parseA >> return (), parseB >> return (), parseC >> return ()]. I want to avoid the repetition of >> return ()... How to?
23:30:24 <joe9> srhb: i can add it to the includes section. What should the #include path in the .hsc file be?
23:30:40 <joe9> srhb: Should it have any dist/build path prefix?
23:31:22 <srhb> joe9: I don't think it should. I've never actually done it with anything but a library, though
23:31:50 <srhb> joe9: For instance, I've includes: X11/XKBlib.h and in the hsc file, #include <X11/XKBlib.h>
23:32:03 <joe9> srhb: gotit, Thanks.
23:32:03 <srhb> I admit to some degree of cargo culting :-)
23:32:04 <Rarrikins> joncol: Maybe this: choice (map (>> return ()) [parseA, parseB, parseC])
23:32:20 <quchen> That won’t typecheck.
23:32:44 <srhb> Rarrikins: parseA, parseB and parseC have different types :)
23:32:51 <Rarrikins> srhb: Ahh.
23:32:58 <lyxia> joncol: void is a bit shorter, but you'll still repeat it.
23:33:11 <srhb> I think the question is: why are you doing this?
23:33:17 <srhb> Especially if there are a lot of them.
23:39:48 <soLucien>     instance Monad ((->) r) where  
23:39:51 <soLucien>         return x = \_ -> x  
23:39:52 <soLucien>         h >>= f = \w -> f (h w) w  
23:39:57 <soLucien> i dont get the last line
23:40:02 <soLucien> h >>= f = \w -> f (h w) w 
23:40:07 <soLucien> so \
23:40:21 <soLucien> in order to bind h to f
23:40:41 <Axman6> >>= :: (r -> a) -> (a -> r -> b) -> (r -> b)
23:40:41 <srhb> soLucien: Is that what you call h >>= f ?
23:41:00 <soLucien> take the output of h, and create a function
23:41:19 <soLucien> bind, right? in monads
23:41:24 <Axman6> hopefully that type helps, that's the type of >>= for the (r ->) monad
23:41:37 <soLucien> the >>= is bind ?
23:41:42 <augur_> yes
23:41:57 <srhb> soLucien: I've never heard f used as the thing you're binding "to." This is more usual, h >>= \x -> ... x ... -- and calling it bind to _x_
23:42:28 <srhb> soLucien: Anyway, that's just language...
23:42:41 <soLucien> yes, it's a "pipe" of sorts
23:42:53 * srhb shrugs
23:43:05 <augur_> soLucien: sort of, yeah :)
23:43:31 <soLucien> so \w -> f (h w) w
23:43:39 <augur_> mx >>= f   means "run the mx computation, then feed the result that it returns into f and run that computation"
23:43:56 <soLucien> \w is the result of the lefthand side of the bind
23:44:09 <soLucien> by pattern matching
23:44:09 <augur_> having args helps, so:    mx >>= \x -> f x   lets you think of x as the result that mx returns
23:44:09 <srhb> soLucien: No.
23:44:12 <soLucien> no ?
23:44:29 <jle`> soLucien: the *result* is a function
23:44:30 <joncol> lyxia: Thanks, didn't know about void
23:44:32 <srhb> soLucien: The function \w -> ... is the result of h >>= f
23:44:46 <jle`> er, result might be a weird word to use here
23:44:51 <soLucien> okay , i see
23:44:52 <jle`> (h >>= f) evaluates to a function
23:44:54 <Axman6> take a look at the type again soLucien 
23:44:56 <Axman6> >>= :: (r -> a) -> (a -> r -> b) -> (r -> b)
23:44:58 <jle`> and that function is (\w -> ...)
23:45:03 <allenj12> I have a question about do notation. When you declare a do the block of code has to correspond to a certain monad for when you '<-' right? how does it know which monad we are using
23:45:12 <jle`> allenj12: type inference :)
23:45:13 <soLucien> but w maps the result of the righthand side
23:45:21 <soLucien> sorry
23:45:23 <soLucien> lefthand
23:45:23 <soLucien> ?
23:45:26 <Axman6> m is (r ->) here (or, actually ((->) r) because we can't write those sections in standard Haskell)
23:45:28 <jle`> allenj12: `do x; y; z` is just x >> y >> z
23:45:35 <srhb> allenj12: Try to make a type error by having two lines in a do block correspond to different monads
23:45:44 <jle`> allenj12: so it's basically the same as using 1 + 2 + 3, and haskell picks which type to use + with
23:45:53 <jle`> nothing magical :)
23:46:10 <Axman6> > ra >>= arb = \r -> arb (ra r) r
23:46:11 <augur_> allenj12: sometimes it doesn't, but it doesnt for the same reason that haskell doesn't know what type   \x -> x   has, so it generalizes and says that it works for any monad whatsoever
23:46:12 <lambdabot>  <hint>:1:12: error:
23:46:12 <lambdabot>      parse error on input ‘=’
23:46:12 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
23:46:27 <augur_> allenj12: or any monad with certain properties
23:46:37 <Axman6> :t let ra >>= arb = \r -> arb (ra r) r in (>>=)
23:46:39 <lambdabot> (t1 -> t) -> (t -> t1 -> t2) -> t1 -> t2
23:46:48 <systemfault> The bind instance for (->) was my first WTF in haskell :/
23:46:54 <jle`> > [True, read "False", True]    -- it's similar here too, here haskell knows what type you want 'read "False"' to be
23:46:57 <lambdabot>  [True,False,True]
23:47:09 <augur_> systemfault: you want a real WTF? hows this:
23:47:11 <soLucien>  ra >>= arb = \r -> arb (ra r) r  cool .. so let me take it step by step
23:47:16 <soLucien> to see if i get it 
23:47:18 <NickHu> Do you mean instance for ((->) r)? ;)
23:47:20 <allenj12> jle`: yea, when your using do within a function that only has one monad in its type signature it seems obvious, but I kinda get confused if theres two monads 
23:47:21 <Axman6> systemfault: it's one of those things that can completely do your head in, but once you do it, it's obvious and mechanical
23:47:21 <jle`> uh oh is that this hour again
23:47:26 <augur_> > filterM (const [True,False]) [0..3]
23:47:28 <lambdabot>  [[0,1,2,3],[0,1,2],[0,1,3],[0,1],[0,2,3],[0,2],[0,3],[0],[1,2,3],[1,2],[1,3]...
23:47:36 <jle`> allenj12: what do you mean 'when there's two monads' ?
23:47:39 <allenj12> jle`: I had an example the other day, but forgot it
23:47:42 <systemfault> augur_: Wow
23:47:52 <Axman6> augur_, the god of powersets
23:47:55 <augur_> systemfault: powerset/powerlist in hardly a line!
23:48:02 <soLucien> the result of the bind operation is a function 
23:48:22 <jle`> soLucien: yeah, because the Monad you're talking about here is functions :)
23:48:25 <allenj12> jle`: something like w.e :: Monad m w => m a -> m w -> ma
23:48:28 <augur_> Soft: for the (e ->) monad,   yes :)
23:48:32 <jle`> soLucien: just like if you use >>= for lists, the bind returns a list
23:48:46 <jle`> allenj12: hm, i'm not sure that type signature makes sense
23:48:57 <soLucien> \r pattern matches
23:49:00 <soLucien> the type of ra
23:49:02 <allenj12> jle`: interesting, why not?
23:49:12 <jle`> allenj12: well, Monad only has one argument
23:49:16 <jle`> Monad m => ...
23:49:20 <augur_> soLucien: "\r" doesnt pattern match anything
23:49:20 <jle`> and 'ma' is, what?
23:49:23 <NickHu> allenj12: Monad has kind * -> *
23:49:27 <augur_> its just part of a lambda function
23:49:29 <Axman6> soLucien: \r is the argument of a lambda
23:49:29 <soLucien> what is it then 
23:49:37 <soLucien> okay, the argument
23:49:40 <Axman6> > (\x -> (x,x*x)) 7
23:49:40 <soLucien> what's it coming from ?
23:49:41 <jle`> soLucien: have you ever used lambdas in haskell?
23:49:42 <lambdabot>  (7,49)
23:49:46 <soLucien> yes i have
23:49:46 <jle`> > (\x -> x*3) 10
23:49:48 <lambdabot>  30
23:49:53 <jle`> it's lambda syntax :)
23:49:54 <augur_> it's the formal argument name, not the argument itself, i'd point out
23:50:03 <jle`> if you want, you can rewrite it without using lambda syntax
23:50:08 <jle`> if the lambda syntax is what is throwing you off
23:50:11 <allenj12> jle`: there was a type it was suppose to be  w.e :: Monad m w => m a -> m b -> ma
23:50:20 <NickHu> soLucien: it might be helpful to note that -> is right associative
23:50:22 <jle`> allenj12: 'Monad m w' still doesn't make sense
23:50:35 <NickHu> Try to write out the type signature for bind
23:50:44 <NickHu> Then replace m with your specific monad
23:50:46 <allenj12> jle`: how would you declare both m and w are both monads
23:50:46 <piyush-kurur> Any one wants to take ownership of yesod-admin please respond https://github.com/piyush-kurur/yesod-admin/issues/4 
23:50:56 <jle`> allenj12: (Monad m, Monad w) => ...
23:51:36 <allenj12> jle`: gotcha, thats what was intended then  w.e :: (Monad m, Monad w) => m a -> m w -> ma
23:51:40 <soLucien> arb (ra r) r is right associative
23:51:47 <jle`> soLucien: h >>= f = go;     where go w = f (h w) w
23:51:55 <soLucien> arb ((ra r) r)
23:51:58 <jle`> soLucien: there it is without lambda syntax :)
23:52:21 <NickHu> soLucien: no, function application is left associative
23:52:22 <jle`> allenj12: that still doesn't make sense, because 'm w' is not well-kinded
23:52:31 <jle`> allenj12: you can't have, say, IO Maybe
23:52:37 <systemfault> The last "w" was what I was finding weird.
23:52:41 <NickHu> But -> in a type signature is right associative
23:52:56 <soLucien> yes exactly
23:52:59 <soLucien> why the last w
23:53:02 <jle`> allenj12: m can only take types that have values, like Int, Bool, 'a' there, etc.
23:53:03 <allenj12> jle`: ugh that i know and thought i fixed sorry im filled with types last shot
23:53:04 <soLucien> that's what i dont get
23:53:09 <allenj12>  w.e :: Monad m w => m a -> w b -> ma
23:53:23 <allenj12> im dumd
23:53:25 <Koterpillar> is ma m a?
23:53:26 <Axman6> soLucien: because f has type a -> r -> b
23:53:27 <allenj12> dumb lol
23:53:43 <Axman6> it gets the a from (h r) because h :: r -> a
23:53:53 <jle`> allenj12: in any case, type inference usually is straightforward, as if it would be for +, :, or any other polymorphic function :)
23:53:56 <allenj12> w.e :: (Monad m, Monad w) => m a -> w b -> m a
23:53:57 <Axman6> so f (h w) has type r -> b
23:54:08 <jle`> > 10 + read "100" + 3     -- it knows that read "100" has to be Integer
23:54:11 <lambdabot>  113
23:54:17 <jle`> and that the answer is Integer
23:54:20 <jle`> because 10 and 3 are Integer
23:54:29 <jle`> > [True, read "False", True]
23:54:31 <lambdabot>  [True,False,True]
23:54:40 <jle`> there, it knows that the result is [Bool], because True and True are Bool's
23:54:55 <jle`> so, if you had do x; y; z, that's like (x >> y >> z)
23:54:59 <Axman6> > read @Integer "7"
23:55:01 <lambdabot>  error:
23:55:01 <lambdabot>      Pattern syntax in expression context: read@Integer
23:55:01 <lambdabot>      Did you mean to enable TypeApplications?
23:55:05 <Axman6> :(
23:55:11 <Axman6> yes I did lambdabot 
23:55:13 <jle`> and if you look at the type of (>>), you'll see that both arguments have to have the same Monad
23:55:16 <allenj12> jle`: alright, I guess it would just assume one untill i try to use '<-' in context of monad m then again in context of monad w. then throw a hissy fit when it sees both
23:55:17 <jle`> instace
23:55:37 <jle`> allenj12: it could start working the assumption from the "end", too
23:55:46 <jle`> it's the same error that you'd get if you did
23:55:52 <jle`> > True : False : "hello" : []
23:55:54 <lambdabot>  error:
23:55:54 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Bool’
23:55:54 <lambdabot>        Expected type: [Bool]
23:56:01 <NickHu> allenj12: are you sure you don't mean something like (Monad m, Monad w) => w (m a)?
23:56:14 <NickHu> And when you do the first do block, is it in w or m?
23:56:17 <jle`> so if you understand why True : False : "hello" : [] gives an error, then you should understand how do blocks type-infer :)
23:56:41 <allenj12> NickHu: no that was a type, me not understanding the syntax, I wanted two distinct monad types
23:56:46 <jle`> > read "True" : read "False" : True : []
23:56:48 <lambdabot>  [True,False,True]
23:57:05 <jle`> there it infers that the entire list is [Bool] because of one of the "last" arguments
23:57:11 <NickHu> m and w are two distinct monads
23:57:29 <allenj12> jle`: gotcha!
23:57:34 <allenj12> thank you
23:58:04 <allenj12> NickHu: sorry I guess I ment not nested
23:58:07 <jle`> np!  type inference can be a tricky thing to get used to if you're not used to relying on it
23:58:20 <jle`> and having it abstracted away with syntactic sugar can make it more confusing
23:58:23 <allenj12> jle`: most of my work now is in clojure :P
23:58:27 <allenj12> haha guess thats why
23:58:32 <jle`> but remember that 'do x; y; z' is just simple function application, x >> y >> z
23:58:44 <jle`> so >> works the same way that +, :, or any other polymorphic operator would work :)
23:58:54 <jle`> or any other polymorphic function for that matter :o
23:58:55 <allenj12> yea :D 
23:59:17 <jle`> well, welcome to haskell :)
23:59:58 <allenj12> thanks, I have mingled here and there in college but now I wanna do something serious in it and really understand it
