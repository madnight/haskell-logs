00:07:40 * hackagebot Gifcurry 2.0.0.2 - Create animated GIFs, overlaid with optional text, from video files.  https://hackage.haskell.org/package/Gifcurry-2.0.0.2 (lettier)
00:07:40 * hackagebot text-zipper 0.8 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.8 (JonathanDaugherty)
00:37:33 <adelbertc> are there examples of haskell libraries where you code in an EDSL and you can use it to extract/synthesize code from some external DSL?
00:42:15 <srhb> adelbertc: extract/synthesize? Can you give an example?
00:42:59 <adelbertc> i vaguely recall hearing about an EDSL that could generate some sort of HDL code
00:43:02 <adelbertc> hardware description language
00:43:14 <liste> @hackage atom
00:43:14 <lambdabot> http://hackage.haskell.org/package/atom
00:43:18 <srhb> adelbertc: Sure, and there's Atom to generate C for embedded devices.
00:43:25 <srhb> adelbertc: So that's quite common, yes. :)
00:43:27 <liste> and the HDL code was different
00:43:31 <liste> wait a sec
00:43:36 <liste> it was ClAsH
00:43:42 <liste> and Lava
00:43:59 <liste> @hackage clash-ghc
00:44:00 <lambdabot> http://hackage.haskell.org/package/clash-ghc
00:44:01 <adelbertc> ah Lava sounds familiar
00:44:14 <liste> @hackage kansas-lava
00:44:15 <lambdabot> http://hackage.haskell.org/package/kansas-lava
00:44:25 <adelbertc> how do these usually work? do they literally just convert the EDSL into some String form that gets written to a file? or is there a better way?
00:44:41 <srhb> adelbertc: That's one way, and often a fine way.
00:44:58 <srhb> adelbertc: You might also manipulate your data in Haskell before actually generating the final String.
00:45:07 <adelbertc> got it
00:45:27 <adelbertc> but generally the approach is to write it out in String form, perhaps after some optimizations or something?
00:46:10 <adelbertc> is there any literature that covers the general principles around this? or is it just the usual "an interpreter for an EDSL that happens to write to a file"
01:17:03 <ph88> is there a function for Char to String where String is a hexidecimal representation ?
01:19:29 <ongy> :t Numeric.printHex
01:19:31 <lambdabot> error:
01:19:31 <lambdabot>     Not in scope: ‚ÄòNumeric.printHex‚Äô
01:19:31 <lambdabot>     Perhaps you meant ‚ÄòNumeric.readHex‚Äô (imported from Numeric)
01:19:43 <ongy> :t Numeric.showHex
01:19:44 <lambdabot> (Show a, Integral a) => a -> ShowS
01:20:49 <ski> > showHex 100 ""
01:20:51 <lambdabot>  "64"
01:21:54 <dominik_> join #servant
01:22:10 <ongy> > concatMap (flip showHex "" . ord) $ 'Êº¢Â≠ó' 
01:22:12 <lambdabot>  error:
01:22:12 <lambdabot>      ‚Ä¢ Syntax error on 'Êº¢Â≠ó'
01:22:12 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
01:22:18 <ongy> > concatMap (flip showHex "" . ord) $ "Êº¢Â≠ó"
01:22:20 <lambdabot>  "6f225b57"
01:26:51 <ski> @type (`showHex` "")
01:26:53 <lambdabot> (Show a, Integral a) => a -> String
01:27:10 <ania122> x:xs is a represenantion for list
01:27:11 <ania122> no?
01:27:24 <ski> for a *non-empty* list, yes
01:27:46 <ania122> which splits list by head and tail
01:27:48 <ania122> no?
01:27:53 <ski> `x:xs' is the non-empty list whose first element is `x', and whose remaining elements (if any) are the elements of the list `xs'
01:27:58 <ski> while `[]' is the empty list
01:28:07 <ski> > 2 : [3,5,7]
01:28:09 <lambdabot>  [2,3,5,7]
01:28:24 <ph88> implode glue pieces = Data.List.concat $ intersperse glue pieces     nice huh
01:28:47 <ski> > let headAndTail [] = error "sorry, can't be done"; headAndTail (x:xs) = (x,xs) in headAndTail [2,3,5,7]
01:28:49 <lambdabot>  (2,[3,5,7])
01:29:46 <ski> ania122 : so if you use the `x:xs' syntax in an expression, it *constructs* a (non-empty) list, but if you use it in a pattern, like in `headAndTail (x:xs) = ..x..xs..', it *deconstructs* a (non-empty) list
01:29:47 <ph88> if i have two function i want to use on a list can i do    map (func1 . func2) []   ?
01:29:50 <ski> ania122 : makes sense ?
01:30:09 <ski> ph88 : sure, it's the same as `map func1 (map func2 [])'
01:30:27 <ania122> like [X|T]
01:30:29 <ania122> in prolog?
01:30:32 <ski> yes
01:30:41 <ski> `[X|T]' is like `x:t'
01:30:45 <ania122> ok
01:31:14 <ski> beware, when you use it in patterns, you often (not always), needs to wrap it in round brackets, like `(x:xs)'
01:31:40 <ania122> ok
01:31:44 <ski> this is because `f x:xs = ...' would actually be parsed as `(f x):xs = ...', which isn't what you intended. so you really need `f (x:xs) = ...' here
01:32:12 <ski> also note that in Haskell, you shouldn't write `[x:t]'
01:32:27 <ski> that would be a list having a *single* element, which is in turn a list
01:32:27 <ania122> clear, thx
01:32:57 <ski> (that's a relatively common mistake that newbies make .. they think "i want a list", and so they think they have to write `[...]')
01:33:28 <ggole> It does make a certain sense. Prolog does it that way
01:33:33 <polux> hello, I would like to replace the Core -> NativeCode part of GHC by Core -> SomethingElse (e.g., javascript)
01:33:42 <ski> ggole : 'swhy i mentioned it :)
01:33:53 <polux> I've looked at the plugins doc, but it looks like plugins can only do Core -> Core transformations
01:34:00 <ski> (since ania122 mentioned Prolog)
01:34:15 <polux> am I wrong? If not, how would you recommend I do that?
01:34:16 <ggole> Oh, my brain skipped right over that
01:34:22 <ggole> Sorry
01:34:28 <ski> no worry :)
01:34:29 <ggole> Sorry :)
01:34:35 <ggole> Er
01:34:43 <ggole> Right.
01:35:04 <merijn> ski: Wouldn't the composed version be *better* than two maps? :)
01:35:22 <ski> merijn : did i indicate otherwise ?
01:35:59 <merijn> ski: Well, "the same" to me implies that it's personal taste which you use, while I'd say the composed map is preferable
01:36:26 <ski> i just wanted to point out that they're equal, so that you can go between the two forms as you please
01:36:41 <merijn> polux: Is this a learning thing or aiming at something practical? If the latter, why not have a look at ghcjs?
01:37:00 <polux> nevermind, I think I've found an example in this core-to-js compiler: https://github.com/chrisdone/fore/blob/master/src/Main.hs#L503
01:37:19 <polux> merijn: it is for something practical, but my understanding of ghcjs is that it's a fork of ghc
01:37:28 <merijn> polux: It's not
01:37:29 <ski> (i think the non-composed version could be preferable, as an intermediate step, when you're doing proofs, e.g.)
01:37:41 <merijn> polux: It uses GHC-the-library to produce code
01:37:47 <polux> oh great then
01:38:11 <polux> I'll look at whether it does something different than the line I pasted above then
01:38:15 <polux> thanks!
01:51:14 <merijn> bleh, so when do we get proper dependent types? I keep finding myself needing them >.<
01:51:21 <ph88> what character is this?  '\160'
01:51:44 <rom1504> p
01:51:53 <merijn> > text "\160"
01:51:55 <lambdabot>  ¬
01:52:50 <danza> :t text
01:52:51 <lambdabot> String -> Doc
01:57:14 <merijn> That's just to make lambdabot output sane unicode
01:57:21 <merijn> > "\160"
01:57:23 <lambdabot>  "\160"
02:00:10 <danza> > chr 160
02:00:12 <lambdabot>  '\160'
02:00:56 <danza> > (showLitChar . chr) 160
02:00:58 <lambdabot>  <[Char] -> [Char]>
02:01:23 <ski> > ((`showLitChar` "lalala!") . chr) 160
02:01:25 <lambdabot>  "\\160lalala!"
02:01:50 <danza> i was looking for a way to show chars which is in the prelude
02:02:08 <ski> how about `show' ?
02:02:20 <danza> > show '\160'
02:02:21 <ski> or `putChar', if that's what you meant
02:02:22 <lambdabot>  "'\\160'"
02:02:29 <danza> doesn't help
02:02:39 <ski> it shows the character
02:02:47 <ski> (converting to a string)
02:03:12 <ski> if you meant to print it out, then `putChar' is the way
02:03:25 <merijn> How about just "putStrLn" or "putChar"?
02:03:25 <danza> right
02:03:33 <danza> > putChar '\160'
02:03:35 <lambdabot>  <IO ()>
02:03:44 <ski> @help run
02:03:44 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
02:03:53 <danza> > run (putChar '\160')
02:03:55 <lambdabot>  error:
02:03:55 <lambdabot>      ‚Ä¢ Variable not in scope: run :: IO () -> t
02:03:55 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
02:03:58 <merijn> danza: "show" produces "a representation of the value as Haskell string", which includes just escaping things
02:04:07 <merijn> danza: You can't use putChar in lambdabot, because no IO
02:04:11 <ski> @run 2 : [3,5,7]
02:04:13 <lambdabot>  [2,3,5,7]
02:04:14 <ski> > 2 : [3,5,7]
02:04:16 <lambdabot>  [2,3,5,7]
02:04:21 <ski> `> ' is sugar for `@run '
02:04:23 <danza> > run: putChar '\160'
02:04:25 <lambdabot>  error:
02:04:25 <lambdabot>      ‚Ä¢ Variable not in scope: run
02:04:25 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
02:04:32 <merijn> danza: See previous remark
02:04:36 <ski> also note "and no IO"
02:05:08 <danza> okay
02:06:24 <danza> yea `putChar (chr 0xef)` works in ghci. Thanks!
02:06:33 <ski> np
02:17:28 <danza> merijn, do you really need dependent types? For some commercial application or for research?
02:17:54 <merijn> Why the false dichotomy?
02:18:09 <danza> yeah it's kind of false ... but still ...
02:18:22 <danza> i don't often meet clients who care about reliability, unfortunately
02:18:28 <merijn> In this case neither, there's something I want to write for myself.
02:18:35 <danza> okay, i see
02:18:45 <merijn> The problem is that my data structure is dependent on runtime input
02:19:11 <Cale> There are plenty of real world problems which I'd love to have proper dependent types for
02:19:41 <merijn> i.e. I have a file-format that has optional parts and I want to write a loader that can load any of said files and safely interact with them
02:19:44 <danza> cool, i never realised that the usefulness of dependent types could be explained so simply: "data structure dependent on runtime input"
02:20:25 <merijn> So I have pairs of "property name" and "content type"
02:20:38 <merijn> And I need to represent at runtime the type specific properties actually have
02:21:53 <tsahyt> When using the new record field overloading extensions, do I want to use them where I define the records, or where I use the field names, or in both places?
02:23:36 <merijn> Cale: I welcome any advice how to workaround the lack of dependent types in Haskell without too much masochism :p
02:24:17 <Cale> merijn: Mostly -- just let things be runtime checks.
02:24:57 <Cale> There's only so much which it's actually reasonable to statically enforce, you can do a fair amount, but as you push past a certain point it just gets more and more painful.
02:25:06 <merijn> Cale: Yeah, that works well for code parts, but I don't know how to do that acceptably with data structures
02:26:19 <merijn> Everything becomes so stringly typed...
02:27:38 * hackagebot html-conduit 1.2.1.1 - Parse HTML documents using xml-conduit datatypes.  https://hackage.haskell.org/package/html-conduit-1.2.1.1 (MichaelSnoyman)
02:27:41 * hackagebot xml-conduit 1.4.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.4.0 (MichaelSnoyman)
02:27:43 * hackagebot xml-hamlet 0.4.0.12 - Hamlet-style quasiquoter for XML content  https://hackage.haskell.org/package/xml-hamlet-0.4.0.12 (MichaelSnoyman)
02:27:45 <merijn> Like the case of having name-type pairs for parts of the data. How can you make that usable...if I have a foo property of doubles I can easily parse the name, but what can I possibly return as contents, since the content depends on the parsed content
02:29:18 <Cale> I'm not completely sure I understand -- parsing might fail...
02:30:44 <merijn> Cale: Suppose I have a file that contains in addition to the generic stuff some doubles as values for some keys. The file contains the keys, the type of values contained by the key, and the actual values.
02:31:16 <Cale> Okay, so you have some sum type of possible types of values
02:32:25 <merijn> Cale: But now I need some way to expose to consumer of the datatype which functions you could actually use
02:32:57 <Cale> The consumer of the data type can pattern match on the data constructor which tells them which type of thing they're dealing with
02:33:14 <Cale> (isn't this just like what Aeson and other libraries do with JSON?)
02:34:07 <merijn> I just want dependent sums :(
02:34:11 <Cale> and if you're looking for some more specific structure there, you can invent a record type with properly typed fields, rather than fields of this Value type, and have another layer of possible failure.
02:34:20 <Cale> Well, there is DMap/DSum
02:34:38 <Cale> Where you invent some GADT for your keys
02:34:47 <tsahyt> So I've got a module defining a record type with some field names. an imported module defines another record which shares some field names. Why doesn't -XDisambiguateRecordFields suffice here?
02:35:02 <tsahyt> it compiles fine with DuplicateRecordFields
02:35:24 <Cale> DMap :: (* -> *) -> (* -> *) -> *
02:36:02 <Cale> DMap k v consists of a bunch of pairs, each of which for some type a has a key of type k a, and a value of type v a
02:36:32 <Cale> and there's DSum as well, which is basically just one of those pairs
02:37:14 <merijn> Cale: hmm, I'll just have to think about this a bit more
02:37:34 <Cale> I would try pretty hard to avoid DMap/DSum if I could
02:37:40 <merijn> Yeah
02:37:43 <Cale> Sometimes you really need it
02:38:26 <Cale> From what I've heard so far, I would probably try to structure things pretty much the way Aeson handles things.
02:38:38 <Cale> (and many other libraries, that's just the first that comes to mind)
02:39:30 <Cale> You can provide some initial deserialisation in terms of some Value type with constructors corresponding for what you know how to parse
02:40:11 <Cale> and then you can have some type class whose instances specify how you expect to further pick through that and construct something more structured
02:40:24 <Cale> (and those operations may all fail because you might not find the stuff you're looking for)
02:52:42 <tsahyt> Ok after playing around with it for just a bit, it seems that DuplicateRecordFields doesn't help much
02:52:47 <tsahyt> you end up with type annotations all over the place
03:04:26 <Cale> tsahyt: Yeah, you basically might as well put that information into the field names
03:05:52 <tsahyt> Cale: what I found particularly annoying is that even when the type of a is fixed by the type signature of the function, it still can't resolve the ambiguity
03:06:10 <Cale> Well, it's not actually looking at the type is it?
03:06:15 <Cale> It's looking at the data constructor
03:06:31 <Cale> Typechecking hasn't really even started yet
03:07:50 <Cale> Oh, or this is the new thing
03:08:06 <tsahyt> it's been in GHC since 8.0.1 I think
03:08:13 <Cale> yeah
03:08:24 <Cale> I was thinking about the older disambiguation
03:09:02 <Cale> It's kind of surprising to even try to disambiguate based on types before you can even tell what everything refers to
03:09:31 <Cale> It's hard to know the type of anything before you know which thing all the names refer to. :)
03:09:56 <tsahyt> yes, it seems that it needs an annotation right where the function is being used, e.g. foo (a :: Bar). a :: Bar being inferable somewhere else doesn't suffice it seems
03:27:40 * hackagebot conduit-combinators 1.0.7 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.7 (MichaelSnoyman)
03:57:40 <mstruebing> what do you use to test your haskell code?
04:00:50 <lyxia> QuickCheck, HUnit
04:07:44 <pavonia> Mostly just GHCi
04:08:25 <e19293001> mstruebing: Right now, I'm reading Haskell Programming from first principles. This teach me how to use QuickCheck and Hspec
04:08:56 <e19293001> mstruebing: that's a haskell book btw
04:10:07 <e19293001> use Hspec for unit testing and QuickCheck for property testing
04:10:42 <lyxia> doesn't hspec integrate QuickCheck? Or is the integration not that good?
04:12:04 <knupfer> It integrates well
04:15:54 <e19293001> what's the difference between monad and monoid?
04:16:24 <merijn> e19293001: Essentially everything
04:16:51 <merijn> e19293001: Besides the close looking name, there's no real similarity to them
04:17:35 <pavonia> Both are typeclasses
04:20:04 <{AS}> merijn: Well they have some categorical similarities :)
04:20:46 <merijn> {AS}: Which is utterly unhelpful to anyone asking that question in a Haskell channel :)
04:21:50 <{AS}> Yeah, I agree 
04:22:23 <{AS}> is there a nice way to lift a record update to functor level?
04:22:30 <{AS}> err applicative level*
04:22:55 <{AS}> say I have (\x -> c { field = x }) <$> fa
04:23:00 <e19293001> merijn: Thanks! I'm about to read about monoids now.
04:23:03 <{AS}> is there a better way to write this?
04:23:22 <merijn> {AS}: Besides lenses?
04:23:27 <{AS}> Yeah
04:23:35 <{AS}> I want to avoid lenses :)
04:23:37 <merijn> {AS}: Not really
04:23:41 <{AS}> OK, thanks
04:23:52 <{AS}> I mean they are useful and all, but it's a huge library for my small project
04:24:00 <absence> i'm a bit confused about how the streaming package relates to pipes. is it like pipes-group, but with the FreeT built into the Stream type for performance?
04:24:06 <{AS}> and their types are  really complex
04:24:28 <knupfer> {AS}: There are more minimalistic lens libs
04:24:37 <{AS}> knupfer: than lens?
04:24:43 <{AS}> any recommendations in particular?
04:27:41 * hackagebot binary-parsers 0.2.2.0 - Extends binary with parsec/attoparsec style parsing combinators.  https://hackage.haskell.org/package/binary-parsers-0.2.2.0 (winterland)
04:28:57 <ertesx> {AS}: microlens is popular
04:29:15 <{AS}> Thanks
04:29:51 <ertesx> {AS}: another is lens-family (or even just lens-family-core), but those are *really* minimalistic
04:30:47 <ertesx> microlens is like lens, but without the dependencies‚Ä¶  it provides all the functionality, but none of the instances that lens provides
04:31:25 <ertesx> s/all/most of/
04:32:38 <ertesx> absence: 'streaming' is in essence 'free'
04:33:57 <ertesx> absence: streaming can be captured as free monads over ((,) A) (producers of A) and ((->) A) (consumers of A)
04:39:03 <Insanity_> I'm trying to install HDBC-Mysql, but when I run "cabal install HDBC.." I get "could not resolve dependencies"
04:39:12 <Insanity_> But it doesn't list which deps?
04:39:39 <bartavelle> Insanity_, wild guess, but did you type the package name properly? it's HDBC-mysql
04:39:56 <Insanity_> Yeah, I just typed HD and pressed tab ^^
04:40:08 <bartavelle> then I have no clue ;)
04:40:18 <Insanity_> Okay, thanks anyway :-)
04:41:39 <dredozubov_> Frankly, i don't get the point of microlens. Lenses are at its best if you have all the machinery and instances.
04:43:16 <magistr> How to learn abstract nonsense?
04:43:55 <jacereda> I'm getting this error while building in profiled mode: "cannot find object file ‚Äò.stack-work/dist/x86_64-osx/Cabal-1.24.0.0/build/ghc-hare/ghc-hare-tmp/Paths_HaRe.dyn_o‚Äô    while linking an interpreted expression"
04:44:16 <jacereda> is there any workaround?
04:44:54 <jacereda> that object isn't there, there's instead a Paths_HaRe.p_o object
04:47:12 <LordBrain> all i can tell you is p_o is like .o with profiling info added i believe, and dyn_o must have some extra info for dynamically linking, tho i'm less sure about that... you probably already know this anyway, but noone else is talking so there it is for whatever thats worth.
04:48:43 <joe9> How do I safely close a TQueue? I have an async thread communicating using a TQueue. I could not figure out how to check if the TQueue has been closed.
04:49:07 <joe9> Wouldn't it be a space leak if I write and if the async thread had already closed?
04:49:47 <mauke> what do you mean, "close"?
04:51:07 <jacereda> LordBrain: ok, thanks, I'll do some googling... looks like stack-specific from what I've been told
04:51:38 <hpc> the most direct answer to the question as written is probably weak references, but that's horrible
04:51:53 <hpc> you likely want your own notion of the queue being done being used
04:51:57 <joe9> mauke, s/close/exited/
04:52:16 <hpc> and have the consumer threads not terminate until it's done being fed and done being consumed
04:52:25 <joe9> mauke: I start an async thread and the thread has completed it's job and exits
04:52:55 <joe9> mauke: How do I know if the TQueue that I am writing to belongs to an async thread that has been closed?
04:53:03 <joe9> mauke: Does that make sense?
04:53:36 <joe9> hpc, yes, I think that is the only way to avoid space leaks, correct?
04:53:58 <mauke> queues don't belong to threads
04:54:31 <bartavelle> jacereda, oh! if you are using stack then I had that happen to me too. For some reasons it sometimes doesn't build the profiling libraries for all libraries, or lose them when copying packages between snapshots.
04:54:35 <joe9> mauke: yes, after the async thread dies, empty the queue?
04:54:44 <hpc> joe9: if you keep holding onto a reference to that queue
04:54:53 <bartavelle> What I do is that I "stack exec ghc-pkg unregister package"
04:55:02 <hpc> which is probably a mistake anyway if you know you will not ever consume from it again
04:55:03 <bartavelle> where package is the name of the package you need to drop
04:55:19 <hpc> joe9: basically you have two high-level issues to consider
04:55:21 <bartavelle> THEN you need to run stack with --verbose, and look which snapshot it copies your faulty package from
04:55:26 <bartavelle> then unregister from it
04:55:31 <hpc> getting rid of references to the queue when it's no longer needed
04:55:49 <hpc> and what to do with items in the queue once the consumer is "done", and what "done" means
04:55:54 <Axman6> bleh, benchmarking is hard. Criterion is amazing when you can convince LLVM not to inline the arguments to the functions you're benchmarking and precompute the results :(
04:56:03 <hpc> because usually a consumer isn't done until the queue says so
04:56:28 <merijn> Axman6: Wheee! Someone else who understand my suffering!
04:56:40 <hpc> that's why i always use -fvia-c
04:56:43 * hpc ducks
04:56:49 <pavonia> hpc: Isn't the reference to the queue released if the thread finishes and doesn'T use it anymore?
04:57:11 <hpc> pavonia: the queue is GC'd if all references to it disappear
04:57:26 <hpc> it sounds like joe9 is holding onto it on the feeding side after the consuming side has gone away
04:57:29 <Axman6> merijn: I mean, maybe I'm just that good and these statistics really are running in 8ns and bos' are running in 10's of ms
04:57:38 <hpc> otherwise how else could things get stuck in it
04:57:57 <pavonia> Right
04:58:04 <merijn> Axman6: I'm at the "handwriting assembler to avoid optimiser messing with my benchmarks" levels right now >.>
04:58:13 <Axman6> heh
04:58:14 <hpc> maybe we're both reading different things from a vauge problem description
04:58:21 <hpc> or the same thing and ourselves communicating it vaguely?
05:00:08 <Axman6> merijn: the good news is that my foldl-statistics package is always faster than bos' statistics package, even when doing more work, and produces identical results
05:00:36 <joe9> hpc, I am holding the queue in a list :  http://bpaste.net/show/19f76387f458 . If I remove the close async from the list, that is as good as removing the reference to it, correct?
05:00:58 <joe9> hpc, s/close async/exited async/
05:01:06 <jacereda> bartavelle: that's not the problem in my case, it isn't failing with a dependency, but linking the final executable
05:02:06 <bartavelle> jacereda, you're building HaRe ?
05:02:26 <jacereda> bartavelle: yes
05:02:36 <bartavelle> then I have no clue, again
05:02:49 <jacereda> bartavelle: ok, thanks anyway
05:04:50 <bartavelle> jacereda, except to tell you that this is the special module that holds pathes to data file declared in the cabal file, but you certainly already know this
05:07:53 <absence> ertesx: but is it some kind of special case of pipes' Proxy type?
05:08:07 <absence> or not all that related
05:21:02 <ertesx> absence: you can express Proxy in terms of free monads, but i don't think that's what 'streaming' does
05:21:41 <ertesx> absence: Proxy is the pipes supertype‚Ä¶  everything is a Proxy
05:22:11 <ertesx> if streaming is designed in any way like i'd assume it is, then consumers, producers and other things are actually different types
05:23:22 <rly> Is joining #haskell like having an Instagram account these days?
05:24:26 <rockfruit> boring, no
05:24:30 <joe9> source : http://dpaste.com/3XDRM6P , warning: http://bpaste.net/show/963e74e35f6a . why do I get this warning? The function should work  for an empty or full list.
05:25:56 <joe9> do not worry, figured it out. sorry
05:29:29 <M2tias> default case?
05:31:52 <zyhn> rly: what does that mean? I don't know what Instagram is (although, I've heard of it)
05:32:06 <M2tias> wow
05:32:07 <absence> ertesx: seems like Producer is equivalent to Stream with (,), Consumer is a function from Stream (,) to monadic action, and Pipe is a function from Stream (,) to Stream (,). so i guess it works as a replacement for the basic downstream pipes interface at least? not sure about upstream
05:45:05 <joe9> hpc: mauke: sorry for the bother. http://bpaste.net/show/40e169624917 is my code. It is good enough that I remove the TQueue from the list, correct? That is equivalent to dereferencing the TQueue and will be garbage collected even if it has data, correct?
05:49:03 <Guest23479> I have the rather ambigious "Data foo = Str | Int". Can I somehow specify that I want to call the constructor of foo and not prelude?
05:49:51 <liste> @type Int
05:49:53 <lambdabot> error:
05:49:53 <lambdabot>     ‚Ä¢ Data constructor not in scope: Int
05:49:53 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
05:50:00 <merijn> Guest23479: That's not syntactically correct Haskell
05:50:10 <liste> I don't think there's a value-level Int constructor in Prelude, or Str either
05:51:00 <liste> Guest23479: so you can just use Str or Int value constructors because there's no clash
05:51:14 <liste> (unless there's some defined in some other module)
05:51:50 <Guest23479> Ah, I now see there was another problem. I'm just an idiot. Thanks.
05:55:13 <{AS}> how does one check if quickcheck is in an infinite loop?
05:57:21 <srhb> {AS}: Look hard at the code.
05:58:28 <{AS}> Ha OK
05:58:47 <{AS}> I meant more
05:58:55 <{AS}> can one put a progress bar or statistics or something?
06:04:22 <{AS}> oh it does show when I view it in the console
06:05:31 <Faucelme> absence: A Pipe is not a function between streams, a function is more powerful because it can detect EOF.
06:07:11 <ertesx> absence: you can't translate it like that‚Ä¶  the corresponding free monad for a pipe is over a coproduct of ((,) B) and ((->) A)
06:07:57 <ertesx> absence: if you need upstream communication, you need even more
06:08:17 <joe9> any advise, please? I am trying to avoid space leaks when using a TQueue. Removing it from a list (which is the only place where I have reference to that TQueue) will ensure that it is garbage collected, correct? http://bpaste.net/show/40e169624917 is my code. It is good enough that I remove the TQueue from the list, correct? That is equivalent to dereferencing the TQueue and will be garbage collected even if it has data, correct?
06:11:47 <ertesx> absence: BTW, i haven't really checked the API in detail‚Ä¶  if it actually only uses producers, the whole free monad deal seems pointless
06:13:39 <erisco> boo
06:15:45 <Cale> joe9: Yeah, if that's the last reference to the TQueue anywhere in your program, losing it will cause the whole TQueue to be garbage collected like anything else.
06:17:09 <joe9> Cale, Thanks.
06:17:21 <Narff> Is there a way to narrow down the functions I import based on the code?
06:17:24 <ph88> hi guys, does this parser consume \\ then fail ?    (M.char '\\' >> fail "")
06:18:00 <Cale> Narff: You can import Foo.Bar (list, of, names)
06:18:39 <erisco> ph88, is that megaparsec?
06:19:13 <ph88> yes :d
06:19:28 <erisco> can't you just run it in ghci and see?
06:19:34 <ph88> https://hackage.haskell.org/package/megaparsec-5.0.0/docs/Text-Megaparsec.html
06:20:01 <ph88> how can i be sure though ?
06:20:02 <Narff> Cale, do it automatically
06:20:15 <erisco> that it consumes \\ and fails? run it on \\ and see if it fails
06:20:54 <ph88> ok but how do i know if \\ was actually consumed ?
06:21:55 <ph88> erisco, not so easy  https://paste.fedoraproject.org/433444/36884147/
06:23:09 <erisco> I haven't used megaparsec, but there looks to be extra type parameters you have to supply
06:23:26 <erisco> something for ShowErrorComponent particularly
06:24:18 <buglebudabey> if i want to process a file that it supposed to return expressions, would the type be something like :: FilePath -> IO Expr?
06:24:35 <buglebudabey> so i can parse the file into expressions
06:24:53 <ski> parse into one expression only ?
06:24:55 <Cale> Narff: Not as far as I know. There might be some fancy editor plugin...
06:25:01 <erisco> buglebudabey, possibly. You might also have, say, Text -> Expr
06:25:23 <erisco> or Text -> Either Error Expr
06:25:23 <buglebudabey> ski well, parse into a list of expressions
06:25:29 <buglebudabey> ski im parsing a csv file
06:25:37 <buglebudabey> erisco thank you
06:25:42 <Cale> buglebudabey: Then that would be  FilePath -> IO [Expr]
06:25:46 <ski> `[Expr]', i suppose ?
06:26:10 <buglebudabey> Cale ok that's what i thought
06:26:13 <ph88> when quickcheck found a failing test case how can i repeat this same test ?
06:27:45 * hackagebot foldl-statistics 0.1.2.0 - Statistical functions from the statistics package implemented as  Folds.  https://hackage.haskell.org/package/foldl-statistics-0.1.2.0 (AlexMason)
06:27:47 * hackagebot jose-jwt 0.7.2 - JSON Object Signing and Encryption Library  https://hackage.haskell.org/package/jose-jwt-0.7.2 (LukeTaylor)
06:27:51 <lyxia> ph88: did it give you the seed it used?
06:28:00 <ph88> noes
06:28:56 <erisco> it is better to leave IO out of things
06:29:54 <buglebudabey> if i want to parse something that might be an int or might be a double, is parsec's try the best approach? or is there a simpler way
06:30:08 <lyxia> ph88: nor the inputs it used? How did you use QuickCheck
06:30:44 <Rembane> buglebudabey: Is that the only two things you are going to parse, or are there more things?
06:30:57 <lyxia> ph88: ah the printing the seed might be a feature of tasty
06:31:19 <buglebudabey> Rembane now that you mention it, it could be a bool or string as well
06:31:48 <tabaqui> hey, guys, what means SF {x = y}, where data SF a b?
06:31:53 <lyxia> ph88: but if you apply quickCheck to a function it will print a minimal input
06:32:02 <Rembane> buglebudabey: So the item you want to parse could be one of four things? Is there anything outside this parsing you want to do?
06:32:23 <buglebudabey> Rembane put those literals into a custom data type
06:32:30 <Cale> tabaqui: It means basically the same thing as SF y, assuming that x is the only field available
06:32:47 <ph88> lyxia, yes i found some stuff in the manual after you mentioned seed .. i will show you my code
06:32:56 <Cale> tabaqui: i.e. it just constructs a record with the x field equal to y.
06:33:30 <Rembane> buglebudabey: Then parsec might be overkill for your purposes.
06:34:03 <buglebudabey> Rembane what alternatives do you suggest
06:34:28 <Rembane> buglebudabey: Parse character by character.
06:34:34 <Adeon> yo, are there good mutable sets/hashsets packages for haskell?
06:34:37 <Adeon> or er
06:34:40 <Adeon> actually not exactly that
06:34:46 <Rembane> buglebudabey: Manually. That is build your own minimal parser.
06:35:01 <buglebudabey> Rembane seems a bit odd to do character by character no?
06:35:02 <Adeon> something I can store tens of gigabytes of Storable things and it works like if it was a set
06:35:08 <buglebudabey> Rembane why not word by word
06:35:12 <erisco> you can get a CSV parser as a package from hackage
06:35:12 <Adeon> and won't slow down everything to crawl by gc
06:36:32 <erisco> if it is good it will accommodate some of the variations in the format
06:36:47 <bitonic> Is it possible to measure CPU time for a single Haskell thread?
06:36:54 <bitonic> E.g. I want to time some operation in a multithreaded setting
06:37:14 <bitonic> And I want to get the CPU time in a certain section of that thread only
06:37:27 <Rembane> buglebudabey: Do you know the type of the word before you start parsing?
06:37:57 <buglebudabey> no, but could i implement something like 'try' and if parsing fails to try the next option?
06:38:05 <buglebudabey> Rembane ^
06:38:29 <erisco> I don't see how parsec is overkill when it offers a simple applicative notation for writing grammars
06:39:17 <Rembane> buglebudabey: Yes. OTOH, you might go with erisco's suggestions and use an existing package for csv files and parsec on top of that.
06:40:15 <buglebudabey> sorry erisco i completely glazed over the comments you gave, good suggestion
06:40:25 <buglebudabey> gtg for a bit, thanks for the help guys
06:40:38 <erisco> Parsec is O(1), but try is a backdoor to this allowing for arbitrary lookahead
06:40:45 <erisco> this is my understanding based on the documentation
06:41:10 <bitonic> Alternatively, is there a way to make a Haskell thread non-preemptable?
06:41:15 <bitonic> Like if it was executing an unsafe FFI call
06:41:31 <erisco> derp, wrong notation... not O(1)... it is lookahead 1
06:41:56 <merijn> bitonic: Have you looked at threadscope?
06:42:14 <bitonic> merijn: I know what it is, not sure how it's relevant in this case
06:42:20 <merijn> bitonic: Alternatively, you could write a C wrapper that was unsafe and pass it a C callback
06:42:28 <bitonic> merijn: yep, that's one option
06:42:36 <merijn> bitonic: Because it allows you to inspect runtimes of individual threads?
06:42:37 <bitonic> Was wondering if there was some built-in facility to do that
06:42:50 <erisco> in the case of string|bool|integer they have a unique starting character
06:43:02 <bitonic> merijn: I need to use this timings inside the program -- I need to monitor this program in real time even when it runs in production
06:43:18 <erisco> so you can get away with lookahead 1. On the other hand, integer|double does not have a unique starting character. There are a couple things you can do
06:43:34 <merijn> bitonic: Which OS are you running on in production?
06:43:41 <erisco> one is to use try, which is a simple option because you can use the existing parsers for integers and doubles
06:43:41 <bitonic> merijn: linux
06:44:11 <erisco> the other option is to parse an integer followed by an optional point and digit string
06:44:34 <Gurkenglas_> "\f -> groupBy (\x y -> f x == f y)" "groupBy . (\f x y -> f x == f y)" why aren't these equal?
06:44:59 <merijn> bitonic: I was thinking maybe DTrace, but that won't work on linux
06:45:04 <erisco> this grammar satisfies lookahead 1 and so you do not need try. On the other hand you need a bit more work constructing your AST as you must construct the possible double yourself
06:45:29 <merijn> bitonic: There's also the eventlog, but I dunno if you can do what you want using that
06:45:44 <merijn> Gurkenglas_: Define "not equal"?
06:46:02 <Gurkenglas_> Replacing one with the other produces a compiler error
06:46:04 <erisco> Gurkenglas_, do you have steps that show they should be equal? I am not sure what else to say other than they apparently are not
06:46:21 <phadej> they look like they have totally different types
06:46:21 <merijn> Gurkenglas_: Are you accounting for the binding of ->?
06:46:22 <{AS}> Is there a bounded quickcheck combinator?
06:46:29 <erisco> like, why is  \f x -> f x  and  \f x x -> f x x  not equal? *shrug* they just aren't
06:46:29 <{AS}> like one that generates a list of at most size?
06:46:33 <merijn> oh, wait
06:46:37 <merijn> phadej++
06:46:50 <Gurkenglas_> :t \f -> groupBy (\x y -> f x == f y)
06:46:51 <lambdabot> Eq a => (t -> a) -> [t] -> [[t]]
06:46:58 <merijn> phadej: oh, no, they're the same
06:47:01 <Gurkenglas_> :t groupBy . (\f x y -> f x == f y)
06:47:02 <lambdabot> Eq a => (t -> a) -> [t] -> [[t]]
06:47:04 <erisco> do you understand what \ is? how abstraction works?
06:47:06 <merijn> Gurkenglas_: I suspect precedence of ->
06:47:58 <erisco> I meant \f x -> f x x in my second example
06:48:57 <Gurkenglas_> groupBy . (\f x y -> f x == f y) is (.) groupBy (\f x y -> f x == f y) is \t -> groupBy ((\f x y -> f x == f y) t) is \t -> groupBy (\x y -> t x == t y), right?
06:49:24 * erisco opens up a text editor
06:49:56 <Squarism> Anyone know a good approach finalizing the update function? http://lpaste.net/210359
06:50:03 <Squarism> lenses?
06:50:36 <bollu> hey guys, are the authors of quipper on herE?
06:50:39 <bollu> here*
06:51:12 <erisco> Gurkenglas_, looks good to me, what is the compiler error?
06:51:15 <{AS}> Squarism: finalizing?
06:51:26 <{AS}> what should update do?
06:51:30 <Squarism> {AS}, ok.. "writing"
06:51:34 <erisco> maybe it is as merijn says and you are making an error regarding the precedence of ->
06:51:48 <erisco> try surrounding the expression with parentheses
06:51:51 <merijn> Well, not precedence
06:51:54 <{AS}> Squarism: I mean, sure replace ? with inp :)
06:51:54 <merijn> It's not an operator
06:52:01 <merijn> But the scoping of lambda's
06:52:04 <{AS}> You have to give us some specification
06:52:11 <Gurkenglas_> erisco, http://lpaste.net/3528672072999895040
06:52:12 <Squarism> {AS}, its NEARLY a map of map.. so yeah.. it should replace
06:52:44 <erisco> precedence is a murky thing with regards to parsing, so I wasn't really going to make any special distinction
06:53:09 <Gurkenglas_> I'll attach some type signatures, maybe that'll help the compiler
06:53:10 <{AS}> Squarism: so it should do what with the PathElem?
06:53:25 <Gurkenglas_> Code golf character count should omit type signatures >:c
06:53:46 <Squarism> {AS}, Path is the the address, Upd is the replacement
06:54:02 <Gurkenglas_> Adding "g :: Ord b => (a -> b) -> [a] -> [[a]]" makes it work again
06:54:05 <{AS}> but you are returning Input?
06:54:22 <Squarism> {AS}, yeah, its "mutating" the Input
06:54:34 <Gurkenglas_> Okay so maybe it shouldn't if it's having an impact on more than readable errors
06:54:45 <{AS}> Squarism: but nowhere is Upd used
06:54:47 <lyxia> Gurkenglas_: eta-expand
06:55:00 <Squarism> {AS} oh.. its meant as second arg to "update"
06:55:06 <lyxia> turn off monomorphism restriction
06:55:15 <Squarism> {AS}, update :: Path -> Upd -> Input -> Input 
06:55:16 <erisco> Gurkenglas_, I had no such problem
06:55:39 <Gurkenglas_> "g f = groupBy . (\h x y -> h x == h y) $ f" also works - but why?
06:55:42 <lyxia> extensions do not to go towards the character count if you do them on the command line
06:56:05 <Gurkenglas_> erisco, might it be because of the ghc 7.6.3 used on that site?
06:56:34 <lyxia> @where monomorphismrestriction
06:56:34 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
06:56:53 <erisco> I did not have the problem when entering each line on ghci
06:56:58 <erisco> loading from file I did have a problem
06:57:04 <lyxia> Gurkenglas_: ^
06:57:16 <erisco> and so I was just about to suggest what lyxia did
06:57:39 <Gurkenglas_> Nooooo I told them that print suggested by their readme doesn't work if they don't give us IO access and they should reroute stderr to us so we can use Debug.Trace, and now the readme says to use print and unsafePerformIO :(((
06:57:40 <erisco> some obscure rule no one can be expected to understand
06:57:42 <{AS}> Squarism: I am pretty sure this seems either like a homework assignment or something you should try continue a bit more with yourself :)
06:58:17 <Squarism> {AS}, Well im just wondering if its a perfect task for lenses or if i should do it manually
06:58:33 <Squarism> ..if the task is clear enough
06:59:22 <{AS}> Squarism: I am unfortunately not a lens expert, so I will let someone else on the channel answer that
07:00:00 <Squarism> ..and no homework. Im just a haskell newb
07:00:16 <Squarism> ...that wanna CREATE =D
07:00:57 <erisco> as someone who doesn't understand lens, I recommend not finding excuses to use it
07:01:04 <Gurkenglas_> Squarism, what do you do if a PathElem is LK? But generally yep this is the archetypal usecase for lens, if you wanna find a place to apply it
07:03:26 <Squarism> Gurkenglas_, if the rightmost element of path is LK and Upd == RU <somemap> -> insert or overwrite Map held by Repeated
07:03:51 <Gurkenglas_> What if another element of path is LK?
07:04:00 <erisco> Gurkenglas_, g f = groupBy . (\h x y -> h x == h y) $ f ‚â° g f = (groupBy . (\h x y -> h x == h y)) f ‚â° g = groupBy . (\h x y -> h x == h y)
07:04:59 <Gurkenglas_> erisco, sure but that argument didnt work when I used it
07:06:12 <erisco> Gurkenglas_, yes, well, there are some type system quirks that make these usual truths untrue, but the good news is they are not harmful quirks
07:06:25 <erisco> just ambiguities and "I don't wanna" type of quirks
07:06:59 <erisco> unlike in, say, JavaScript where these are dangerously untrue
07:07:17 <erisco> particularly eta reduction
07:09:55 <Squarism> Gurkenglas_, well for the root case..  update [VK "keyOfRepeated", LK "indexOfRepeatedMap"] (Upd $ RU M.empty) (M.fromList [(VK "keyOfRepeated", Repeated (M.fromList [("2", M.empty)])]) ... should result in : M.fromList [(VK "keyOfRepeated", Repeated (M.fromList [("2", M.empty),("indexOfRepeatedMap",M.empty)])]
07:10:59 <Gurkenglas_> What about update [LK "indexOfRepeatedMap", VK "keyOfRepeated"]?
07:12:02 <Squarism> that cant address anything as Input is indexed with VKey 
07:13:25 <Squarism> leftmost needs to be VKey. So yeah.. Paths are allways VKey, LoopElemKey,VKey, LoopElemKey,VKey, LoopElemKey,...
07:14:31 <Gurkenglas_> So then why not make PathElem (VKey, LoopElemKey)?
07:14:57 <absence> ertesx: pointless how? it does seem to only use Stream (,) and Stream (Stream (,)) in the Streaming.Prelude, but there are some others in Streaming
07:15:12 <Squarism> Gurkenglas_, [VKey], [VKey,LoopElemKey] and [VKey,LoopElemKey,Vkey] are all proper paths
07:15:36 <absence> ertesx: could upstream work with just the functor in the Stream type?
07:17:11 <Squarism> Gurkenglas_, but sure.. VU paths allways end with VKey, RU paths allways end in LoopElemKey
07:20:31 <magistr> Hello. How to learn abstract nonsense?
07:21:53 <{AS}> Wow I just learned that length works on Maybe
07:21:57 <{AS}> > :t length
07:22:00 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
07:22:01 <{AS}> :t length
07:22:03 <lambdabot> Foldable t => t a -> Int
07:22:21 <{AS}> I had a bug with length comparason of a Maybe [a] and an [a]
07:22:27 <{AS}> and I couldn't understand the issue
07:23:30 <Cale> yep
07:23:32 <Cale> > length Nothing
07:23:34 <lambdabot>  0
07:23:41 <Cale> > length (Just 5)
07:23:44 <lambdabot>  1
07:23:51 <Cale> > length ("hello", 2)
07:23:54 <lambdabot>  1
07:23:57 <{AS}> Sometimes the strongest typing discipline can not find your errors :)
07:24:04 <Cale> > fmap (+1) ("hello", 2)
07:24:06 <lambdabot>  ("hello",3)
07:24:07 <{AS}> Is (, a) foldable?
07:24:14 <Cale> (,) a is
07:25:35 <{AS}> thanks
07:25:43 <{AS}> Is it possible to get hold of quickcheck's statistics?
07:26:53 <quchen> What do you mean with statistics?
07:27:03 <quchen> You can use verboseCheck to see all generated testcases
07:27:14 <quchen> You can classify generated tests using ‚Äúgenerate‚Äù
07:27:22 <quchen> Eh, ‚Äúclassify‚Äù
07:27:46 * hackagebot foldl-statistics 0.1.3.0 - Statistical functions from the statistics package implemented as  Folds.  https://hackage.haskell.org/package/foldl-statistics-0.1.3.0 (AlexMason)
07:33:31 <shapr> Is there a pcap editing/filtering framework in Haskell? Something like Python's dpkt or scapy?
07:40:14 <ph88> lyxia, this is how i run quickcheck  https://paste.fedoraproject.org/433519/64158214/
07:42:01 <ph88> ups actually that paste is wrong .. this should be it  https://paste.fedoraproject.org/433521/74641685/
07:42:28 <magistr> to learn haskell i need learn abstract nonsense firstly
07:42:52 <ph88> maybe i can get the seed from failure, and put the seed in args
07:43:08 <magistr> give me a some books
07:43:27 <ph88> magistr, what do you want to make ?
07:43:38 <ph88> half of the books are paid
07:45:20 <Cale> magistr: You really don't need to know any abstract nonsense to use Haskell.
07:45:33 <magistr> ph88, I want to learn haskell, I must read a math books
07:45:42 <Cale> magistr: False.
07:46:23 <Cale> As much as I would normally encourage someone to learn mathematics, that's really not helpful if your goal is just to learn Haskell.
07:46:42 <lyxia> ph88: But if you want to print the counterexample quickCheck already does that...
07:48:36 <Cale> magistr: There's some mathematics, like bits of category theory which we've stolen ideas from and brought them into Haskell, but you don't need to know any category theory to use the result of that process -- only if you care about getting inspiration for new ways of structuring code.
07:48:47 <Cale> (and do your own stealing)
07:49:50 <Cale> magistr: It's actually kind of tricky for mathematicians to understand the manner in which the Haskell side of things corresponds to the mathematical concepts, because we've had to crush things down enough to actually make them expressible in Haskell.
07:50:06 <ph88> lyxia, i want to do several things with the counter-example .. but right now i need to look at the seed !
07:50:10 <Cale> (but once you understand it, the connection is clear enough)
07:52:16 <lyxia> ph88: you might want to use whenFail to define logInput instead
07:52:27 <jonored> Mostly that seems to boil down to "haskell really likes writing code for very simple abstractions with very few rules associated with them". That just overlaps pretty closely with the mathematical "what is the smallest set of axioms that lets us prove these interesting things".
07:52:40 <lyxia> ph88: Actually what are you looking for now?
07:53:56 <{AS}> so I want like how many tests it generated
07:54:00 <ph88> lyxia, the run the test again with trying the same counter-example. Because when the test fails i want to fix it and the run on the same counter-example to see if that case is fixed
07:54:10 <{AS}> and how many were succesful/dropped
07:54:11 <{AS}> etc.
07:54:16 <lyxia> ph88: I mentionned seeds because some testing framework like tasty gives it to you so that you can run the exact same test.
07:54:33 <lyxia> ph88: but if you already have grabbed the counter example that doesn't seem necessary?
07:54:48 <ph88> lyxia, https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#t:Result Failure is on line 12
07:55:11 <ph88> lyxia, i need to run quickcheck again after i fixed the code
07:56:04 <lyxia> okay, well you can get it when you pattern match on failure
07:56:40 <ph88> not sure what i should be returning in the quickCheck'  function
07:57:07 <ph88> maybe  IO (Maybe (a, extra info))
07:57:38 <lyxia> Maybe (a, QCGen) ?
07:58:05 <ph88> yes like that
07:58:21 <ph88> why not even the entire Failure type ...
07:58:35 <ph88> (probably a record)
07:58:41 <ph88> then i can grab later what i want
07:58:53 <ph88> what is this notation:   Failure {} ->  
07:59:11 <ezyang> ph88: it says Failure has some fields but you don't care what they are 
07:59:26 <ezyang> you should associate it as Failure{} -> ... 
07:59:36 <ezyang> if failure has two fields, it's equivalent to Failure _ _ -> 
07:59:45 <ph88> ah i see
08:00:12 <ph88> and if i want the entire  the entire record ?
08:00:18 <ph88> i replace   Failure {}   with  a   ?
08:00:33 <lyxia> a@(Failure {})
08:00:42 <ezyang> that won't work 
08:00:54 <ezyang> Try a@Failure{} 
08:00:56 <ph88> why Try  ?
08:00:59 <ezyang> but you're probably better off just binding the fields 
08:01:02 <ph88> i already have a case statement
08:01:08 <ph88> either   Failure or _
08:01:08 <buglebudabey> is there a concatMapM?
08:01:14 <ezyang> Try = English 
08:01:20 <ph88> what's "binding the fields"
08:01:25 <ezyang> buglebudabey: fmap concat . mapM 
08:01:35 <ezyang> ph88: Failure{ fieldName = x } -> ... 
08:01:44 <buglebudabey> ezyang cool, thanks
08:01:58 <ph88> don't see how Try makes sense here
08:02:09 <ph88> lyxia's answer seems good to me
08:02:23 <ezyang> ph88: Try wasn't intended to be code 
08:02:35 <lyxia> hahaha
08:03:02 <ph88> lol
08:03:04 <ph88> ok
08:03:07 <{AS}> ph88: Thanks
08:04:40 <ph88> why thanks me? :D
08:06:08 <ertesx> absence: a cascade of streams is basically just what pipes-group does, except in a slightly simpler way: the two layers both have a free-monadic structure, so you can use the same combinators
08:08:41 <ertesx> absence: if 'streaming' has that, then yeah, it does have a point‚Ä¶  i have worked on a similar library a few years ago, which made this pattern rather convenient via a type class (<http://hub.darcs.net/ertes/fuse/browse/Data/Fuse/Core.hs#60>), but never really finished it
08:09:51 <ertesx> today i'd just use the 'free' library
08:10:07 <ph88> lyxia, eh i think i've ran into a problem https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#t:Args    Note: saving a seed from one version of QuickCheck and replaying it in another is not supported.
08:10:33 <ph88> oh wait .. i guess this is not a problem since i will not change the version of quickCheck ^^
08:10:50 <ezyang> if you edit your test suite that could also invalidate the seed. 
08:11:46 <ph88> stdArgs :: Args    what kind of notation is this    stdArgs { chatty = False }     stdArgs doesn't take any arguments .. o_O
08:12:41 <ezyang> e { f = x } is functional record update 
08:12:53 <ezyang> it says, "give e, but with its filed named f set to x" 
08:13:19 <ph88> why is it not in the type signature ?
08:14:15 <ezyang> well, the fields of a data type are implicitly in the type signature 
08:14:28 <ezyang> e :: T, look at T to see the fields 
08:21:48 <{AS}> ph88: I was unsure who linked to quickCheckResult
08:21:56 <{AS}> but thanks to everybody, who did? :)
08:22:02 <{AS}> I think it was you
08:32:52 <OutlawStar> hi all, i'm running into a compile issue when trying to generalize a date kind. I have a key type (byte4, byte8) that is a data kind and I would like to support taking in a generic action that runs on any key type 'k', but this does not seem to work :(
08:33:00 <OutlawStar> I have an example here: http://lpaste.net/2128301778595217408
08:33:12 <OutlawStar> any suggestions on that would be great, thx.
08:33:41 <OutlawStar> withSchema line 10, takes in a generic TableAction (at least thats the goal)
08:36:14 <glguy> OutlawStar: The definition of TableSchema is missing from that paste
08:36:18 <ski> OutlawStar : was `data TableAction = forall k. TableAction (FormattedTable k -> Int)' meant to be `data TableAction = TableAction (forall k. FormattedTable k -> Int)' ?
08:36:23 <ph88> {AS}, yes :P
08:37:03 * ski thinks `TableSchema',`RecordSchema',`tsRecordSchema' probably doesn't matter, for this
08:37:06 <OutlawStar> glgy: data TableSchema = TableSchema { tsKeyType :: KeyType, tsRecordSchema :: RecordSchema }
08:37:14 <OutlawStar> yeah, didn't think so either
08:37:27 <ph88> ezyang, looks pretty strange to me ^^
08:37:40 <OutlawStar> ski: would that make difference
08:37:55 <ski> OutlawStar : it would be more or less the opposite ..
08:37:59 <ski> very different
08:38:11 <OutlawStar> oh wow
08:38:13 <OutlawStar> stupid me
08:38:16 <OutlawStar> thatw as what i wanted i think
08:38:47 <ski> your current `TableAction' is an "existential data type", meaning a data type with an argument having an existentially quantified type
08:38:48 <OutlawStar> ski: thx alot, that fixed it. I thought that should work
08:39:19 <ski> a data type with a data constructor with an argument having an existentially quantified type, i mean
08:39:34 <OutlawStar> yeah, i thought I would need rankntypes for that
08:39:44 <OutlawStar> and i thought it strange that it didn't show up
08:39:48 <ski> OutlawStar : while my suggestion would be to have the the data constructor take an argument of a *univerally* quantified type. iow taking a polymorphic argument
08:39:52 <OutlawStar> when i moved it, that worked
08:40:04 <ski> "existential" and "universal" quantification are sortof opposites
08:40:15 <OutlawStar> yes :)
08:40:56 <nitrix> ExistantialQuantification vs. RankNType :P
08:41:11 <ski> the reason your pasted `TableAction' didn't work was because your `TableAction f' argument had `f :: FormattedTable k -> Int' for some *already* *selected* (also hidden/unknown/opqaue/abstract) `KeyType'
08:42:00 <OutlawStar> ski: right, it was losing that
08:42:15 <OutlawStar> ski: with how i had it setup anyway
08:42:17 <ph88> anyone know why replay has Int in that tuple ??   https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#t:Args
08:42:18 <ski> OutlawStar : while with the suggested change, we'd instead have `f :: forall k. FormattedTable k -> Int', iow the `f' packed inside `TableAction' has promised to work for *every* possible `k' that you pick (in `runTableAction32' and `runTableAction64' as `Byte4' respectively `Byte8')
08:42:35 <OutlawStar> ski: yup that was my initial intent
08:42:36 <ski> OutlawStar : .. as opposed for it only working with a preselected one if its own choice
08:43:21 <ski> OutlawStar : i hope the reason for why your pasted code didn't work is now clear, and also hopefully you have some basic idea for what existentials can be useful for
08:43:37 <OutlawStar> ski: I do, thanks alot
08:43:40 <ski> the difference is in who gets to pick/choose the type for the type variable
08:44:30 <ski> (and anyone that doesn't pick is required to be able to handle any choice that the picker may make. iow the non-picker must be polymorphic in the choice)
08:45:31 <iphy> how do you get a String from a GHC.TypeLits.Symbol in GHC 4.6.3?
08:45:43 <iphy> i.e. in base<4.7
08:45:58 <ph88> are optional arguments in haskell a thing ?
08:46:17 <osa1> ph88: use Maybe
08:46:17 <ski> OutlawStar : of course, with this change, whoever makes the argument of type `TableAction' for `withSchema' must do more : they can't just handle one of `Byte4' and `Byte8', of their choosing. they must handle all choices possibly made by `withSchema' (and other users of `TableAction')
08:46:37 <ph88> right ^^
08:46:57 <OutlawStar> ski: correct
08:47:55 <ski> OutlawStar : should i explain why the "existential" version is written with `forall', but in a different place ?
08:48:20 <OutlawStar> ski: thx for offer, but thats is ok. FP complete had a nice article on this
08:48:28 <ski> good
08:48:31 <ertesx> ph88: there are a few notions of "optional arguments":  'id' takes an optional second argument: id x y
08:48:59 <ertesx> ph88: printf takes another kind of "optional argument":  printf "%d" (17 :: Int)
08:49:09 * ski would perhaps express it as "`id' potentially takes a second argument", rather
08:49:53 <ski> > printf "%d-%d" (17 :: Int) :: String
08:49:55 <lambdabot>  "17-*Exception: printf: argument list ended prematurely
08:50:02 <Forlorn> Hello there, how may I install package for Linear Algebra? I want to take the dot product in GHCI for two arbitrary N-tuples.
08:50:05 <ski> > printf "d-d" (17 :: Int) :: String
08:50:07 <lambdabot>  "d-d*Exception: printf: formatting string ended prematurely
08:50:42 <ertesx> Forlorn: not for arbitrary tuples, but there is the 'linear' library
08:51:25 <ertesx> Forlorn: it has types V1, V2, V3, V4 and a type V that is indexed by dimensionality
08:51:42 <Forlorn> ertesx, that seems good
08:52:50 <Forlorn> ertesx, how can I use this package in ghc? Do I need to install the package globally with cabal?
08:53:00 <Forlorn> oh, sorry, I meant to say ghci*
08:53:20 <ertesx> Forlorn: if this is your global GHCi, then yeah, that would be an option
08:54:00 <ertesx> Forlorn: however, don't install it "globally" in the --global sense
08:54:06 <ertesx> just for your user
08:54:13 <Forlorn> ah I see
08:54:31 <Forlorn> ertesx, https://hackage.haskell.org/package/AC-Vector-1.2.2/docs/Data-Vector.html
08:54:51 * dcoutts is working on a feature in cabal 2.0 that'll make Forlorn's use case really easy for local projects
08:54:53 <Forlorn> what about this one?
08:55:36 <Forlorn> it doesn't implicitly say if it is in the standard library
08:55:47 <Forlorn> explicitly*
08:56:08 <ertesx> Forlorn: neither 'AC-Vector' nor 'linear' are standard‚Ä¶  generally i'd prefer to go with the 'linear' library, because it has a much nicer interface
08:56:33 <Forlorn> ertesx, Ok
08:56:59 <ertesx> 'AC-Vector' may have its merit, too:  it's not parameterised, so if you're using 2D/3D vectors of Double, then it may give you a slight speed boost
08:58:08 <ertesx> at the expense of a clumsier, more ad-hoc API in comparison to the categorical love-letter that is 'linear' =)
09:07:55 <num3a> hello friends
09:08:25 <lambdabot> Hello.
09:22:34 <codedmart> Isn't the idea of `library` in a cabal file to share build-depends and exposed/other-modules between executables?
09:22:49 <codedmart> I have only used basic cabal files so far.
09:25:51 <haskell778> how does fmap (,) 1 typecheck
09:26:21 <haskell778> sicnce (,) is a value constructor, not a function
09:26:52 <EvanR> its a function too
09:26:57 <EvanR> :t (,)
09:26:58 <lambdabot> a -> b -> (a, b)
09:27:04 <EvanR> a -> (b -> (a,b))
09:27:49 * hackagebot git-annex 6.20160923 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160923 (JoeyHess)
09:28:13 <EvanR> :t fmap (,) 1
09:28:14 <lambdabot> (Num (f a), Functor f) => f (b -> (a, b))
09:33:11 <EvanR> haskell778: (responding to PM) theres no higher kinded values, values have kind *
09:33:25 <EvanR> .... values have types which are kind *
09:33:27 <colo> Is there a way to declare unsigned 64bit integer
09:33:28 <codedmart> I see what I did.
09:33:39 <EvanR> Word64
09:33:42 <haskell778> Is a higher kinded value constructor a function?
09:33:56 <EvanR> constructors are functions
09:33:57 <glguy> value constructors don't have kinds
09:34:45 <haskell778> How does fmap (,) 1 typecheck, since fmap expects 1st argument as a function, and (,) is a value constructot
09:34:58 <EvanR> (,) is a function
09:34:59 <glguy> Value constructor and function are different categories
09:35:18 <haskell778> haskell newbie here, can you explain in simpler terms?
09:35:21 <glguy> (,) is both a value (data) constructor and has a function type
09:37:49 <glguy> There are constructors (True, Just, (:)) and variables (this, that, (+))
09:38:30 <glguy> as two primary categories of atomic value level things
09:39:13 <glguy> independently values have types. function values with have a type (a -> b) for some a and b
09:40:18 <glguy> haskell778: please direct your responses to channel
09:41:00 <haskell778> yes, understanding till here
09:45:18 <haskell778> Are value constructors functions?
09:45:26 <glguy> they can but
09:45:29 <glguy> can be
09:45:32 <glguy> True isn't
09:45:33 <glguy> Just is
09:46:13 <haskell778> so they can be curried also?
09:46:25 <ski> yes, like `(:)' and `Node'
09:46:42 <ski> @type Node
09:46:44 <lambdabot> a -> Forest a -> Tree a
09:50:55 <shane> When I replace the Pipes.Text.IO consumer stdio by the consumer writeFile "filename.txt", it creates the file but it is completely blank. Whereas, stdio outputs the text as it is supposed to! Anyone know why it is not writing the text to filename.txt whereas it is creating it?
09:54:06 <EvanR> did you flush/close the file before looking at it
09:55:17 <shane> it was creating a new file anyway.
09:56:06 <shane> And i only tried looking at the file after the program finished
10:05:43 <dcoutts> codedmart: re libraries in .cabal files: no, not exactly
10:06:01 <codedmart> dcoutts: I figured out what I was doing. Thanks!
10:06:53 <dcoutts> codedmart: the primary purpose of libraries is to re-use in other packages/projects. You can have a package with a lib and several (in the same package) exes that share the same lib. That'd be mainly for code reuse.
10:08:16 <ydl> is there a pre-built binary of the llvm toolchain to be used with the windows ghc installed by stack?
10:08:55 <EvanR> shane: youd perhaps think that upon ending the program, ghc would auto flush your files
10:09:05 <EvanR> before they get closed by the OS
10:10:24 <EvanR> try changing the buffering mode of the file
10:11:25 <athan> Has anyone here seen a QuickCheck Arbitrary where you can supply a standard deviation for each of the generated sub-data?
10:11:26 <shane> EvanR: Thanks, how do I change the mode?
10:13:24 <EvanR> hSetBuffering
10:14:48 <geekosaur> the writeFile endpoint doesn't expose buffering information
10:15:13 <xa0> @pf \ ps -> all (stuff) . zipStuffs (==) (stuff) ps
10:15:13 <lambdabot> Maybe you meant: pl bf
10:15:17 <xa0> @pl \ ps -> all (stuff) . zipStuffs (==) (stuff) ps
10:15:17 <lambdabot> (all stuff .) . zipStuffs (==) stuff
10:27:51 * hackagebot text-zipper 0.8.1 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.8.1 (JonathanDaugherty)
10:32:36 <joe9> I have this function : screenDrawable :: VertexArrayId -> BufferId -> Drawable, I have another function: withVertexArray :: (VertexArrayId -> BufferId -> IO a) -> IO a, I want to do : mapM withVertexArray [screenDrawable] . this works: mapM withVertexArray [(\a -> return . screenDrawable a)]
10:32:46 <joe9> just want to check if there is a better way of doing that.
10:33:20 <joe9>  basically change this to return IO Drawable: screenDrawable :: VertexArrayId -> BufferId -> Drawable
10:33:42 <joe9>  (\a -> return . screenDrawable a) is how I am doing it.
10:35:10 <joe9> Isn't that applicative?
10:35:56 <EvanR> @pl \x -> f . g x
10:35:56 <lambdabot> (f .) . g
10:37:58 <joe9> EvanR: I think using the return is more readable than the above line, imho.
10:38:09 <EvanR> you mean the lambda
10:38:26 <EvanR> yeah it is
10:38:48 <EvanR> but its trollingly close to looking like you could eta reduce it
10:38:48 <joe9> EvanR: yes,
10:39:07 <EvanR> one way is to define f .: g as (f .) . g
10:39:20 <EvanR> actually .: is usually something else
10:39:32 <ski> (or `(.:) = (.) . (.)')
10:40:26 <EvanR> then youd have return .: screenDrawable
10:41:07 <EvanR> (.::) = (.) . (.) . (.) and so on
10:41:41 <joe9> EvanR: don't worry. I was thinking that there might be something simple such as fmap.
10:41:46 <ski> (number of dots agree, is one mnemonic. the other is that number of characters is the number of arguments that're "bypassed")
10:43:32 <ski> joe9 : in case you have multiple functions in the list, do you intend that the `withVertexArray' calls should be nested or not ?
10:45:21 <joe9> ski, EvanR: This is what I am currently doing: http://bpaste.net/show/743cf4a7270c
10:45:38 <joe9> I am trying to see if there is a better way of doing it.
10:45:46 <EvanR> yeesh
10:45:57 <joe9> this is what I came up with: http://bpaste.net/show/8aab788d2c91
10:47:35 <EvanR> joe9: shouldnt this be some form of replicate call, since all drawables are indistinguishable
10:47:56 <EvanR> give me 6 drawables and pass the list to the continuefunction
10:47:58 <ski> joe9 : as i suspected, you want nesting of them :)
10:48:08 <ski> joe9 : so, your plain `mapM' will probably not work as intended
10:48:19 <EvanR> replicateM
10:48:26 <lgstate_> http://okmij.org/ftp/Computation/lightweight-dependent-typing.html <-- Is this (1) a light weight way of implemeneting full dependent types or (2) a full way of implementing a *weaker* version of dependent types?
10:48:37 <ski> (since presumably `withVertexArray' sets up some dynamic context for the callback, that will be teared down, before it returns, right ?)
10:48:37 <EvanR> weaker
10:48:54 <ski> (same goes for `replicateM', yes)
10:48:59 <lgstate_> EvanR: okay; would you mind explaining to a n00b how it is 'weaker' ?
10:48:59 <EvanR> thats how to fake DT to get some of the benefits
10:49:10 <glguy> joe9: If you need to nest all of those "with" operations you should look back at the code I showed you the other day that was marshaling things using "with" operations
10:49:12 <joe9> EvanR: each drawable is a different https://github.com/joe9/haskell-opengl-charting/blob/master/src/Drawable.hs
10:49:22 <EvanR> they are all constructed the same way
10:49:23 <lgstate_> EvanR: I've used Coq/Idris before. How exactly is this 'weaker' ?
10:49:30 <joe9> EvanR: https://github.com/joe9/haskell-opengl-charting/blob/master/src/Drawable/HorizontalCrosshair.hs
10:49:39 <EvanR> lgstate_: theres several techniques in there
10:49:41 <joe9> EvanR: is how I am using the Drawable data type
10:49:53 <ski> joe9 : oh, i see you already said "could use the ContT monad" .. i was just going to suggest exactly that :)
10:50:21 <joe9> ski, yes, the ContT monad is making the code unreadable.
10:50:27 <ski> howso ?
10:50:49 <joe9> ski, and I want to keep it readable (atleast to me and I am not an expert haskeller)
10:51:22 * ski would think the not-ridicuously-nested version would be more readable
10:51:29 <ski> (ymmv, i suppose)
10:51:33 <EvanR> lgstate_: in the first section, they use basically "smart constructors" to establish invariants about the data
10:51:55 <lgstate_> EvanR: like makeRect x1 x2 y1 y2 -- ensures x1 <= x2, y1 <= y2 ?
10:52:01 <EvanR> it doesnt use dependent types, but it does help keep things straight. but it relies on the module that has access to the internals to be bug free
10:52:29 <EvanR> it also doesnt check the conditions at compile time
10:53:19 <EvanR> but even in DT thats also not necessarily happening either
10:54:09 <EvanR> in the second section they use singletons which copies value relationships to the type level
10:54:25 <EvanR> DataKinds extension helps with this in haskell
10:55:00 <EvanR> its not DT since you have a copy of all the value code, instead of just using the values directly
10:55:35 <joe9> ski, yes the withVertexArray is a bracket for OpenGL setup.
10:56:35 <EvanR> the third section is about "implicit configuration" which is also called "reflection" in haskell, and you can set it up with rankN typess
10:56:44 <EvanR> its pretty cool
10:56:53 <EvanR> but doesnt have much to do with DT
10:57:03 <markv5> 
10:58:02 <Darwin226> Hey guys. I hope this isn't considered spamming but I've opened a question on SO and would appreciate if someone could answer it (there). It's about a strange interaction between incoherent instances and type families.
10:58:02 <Darwin226> http://stackoverflow.com/questions/39666813/strange-interaction-between-type-families-and-incoherent-instances
10:58:27 <EvanR> in the static capabilities section, i think a good exampl of that stuff is in the juicy pixels library
10:58:41 <EvanR> they use phantom types to make sure you do dynamic checks on pixel formats at runtime
10:59:09 <EvanR> once you do them, you know you have the right pixel format
10:59:22 <EvanR> that much is checked by the compiler
11:00:11 <ski>   replicateM 6 (ContT (withVertexArray . curry)) `runContT` \[(svaid,svabid),(fvaid,fvabid),(pvaid,pvabid),(vvaid,vvabid),(hcvaid,hcvabid),(vcvaid,vcvabid)] -> continueFunction [..as before..]
11:00:15 <ski> alternatively
11:00:21 <ski>   replicateM 6 (ContT (withVertexArray . curry)) `runContT` (continueFunction . zipWith uncurry [screenDrawable,frameDrawable,priceChartDrawable,volumeChartDrawable,horizontalCrosshairDrawable,verticalCrosshairDrawable])
11:00:31 <ski> (proberly indented, of course)
11:00:40 <ski> i believe should work, unless i made some mistake
11:00:43 <ski> joe9 ^
11:01:20 <ski> the `curry' and `uncurry' parts are uglifying it a bit, i suppose ..
11:02:16 <av_> hi guys, I'm writing a program that uses the GPU via OpenCL, and I want to make it polymorphic -- so that the GPU part of the program can work with Double or Float, depending on how it's used.  Problem: the GPU kernel is a string that contains "float" or "double", which must match the type used in Haskell.
11:02:37 <EvanR> lgstate_: all these techniques let you get stuff done without DT, and could be seen as a justification of not needing any DT support
11:02:53 <ski> you could of course factor out the list `[screenDrawable,...]' of type `[VertexArrayId -> BufferId -> Drawable]', here
11:03:10 <av_> What's the best way of working out which type (Double or Float) a function's arguments and result are, so I can pick the right kernel automatically?
11:03:19 <lgstate_> EvanR: I honestly sttill don't get this
11:03:25 <lgstate_> EvanR: can you point me at good resource for implmeneitng it
11:03:30 <lgstate_> I feel like it's a bit like monads
11:03:32 <EvanR> implementing what
11:03:36 <lgstate_> unless I implement it, I won't understand it
11:03:40 <lgstate_> *implementing dependent types*
11:03:45 <EvanR> oh yeah
11:03:53 <EvanR> https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
11:04:02 <ski> joe9 : in any case, i believe your <https://bpaste.net/show/8aab788d2c91> will do the wrong thing
11:04:10 <lgstate_> Evanr: all I've done is http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/ which doens't cover data types
11:04:20 <Darwin226> av_: Have the parameters of the function be constrained by a typeclass and have Double and Float implement an instance of that class.
11:04:22 <EvanR> that implements a type checker and points you in the direction of how youd implement inductive types
11:04:29 <joe9> ski, do not worry about it. I think this is more readable to me, imho. sorry for the bother. https://github.com/joe9/haskell-opengl-charting/blob/master/src/Drawable.hs last lines
11:04:50 <Darwin226> The implementation should be something that gives you enough info to do what you need to do
11:05:06 <EvanR> lgstate_: for data types, you essentially need a way to specify the introduction rules, computation rules, and an induction principle so you can define functions out of that data type
11:05:11 <joe9> ski, https://github.com/joe9/haskell-opengl-charting/blob/master/app/Main.hs line 70 is how I am using it.
11:05:21 <joe9> ski, it compiles but have not tested it yet.
11:05:24 <av_> Darwin226: OK, that sound good, I was hoping there was something simpler...
11:05:28 <EvanR> lgstate_: a generalized thing which does this for many types with the same pattern is "W-types"
11:05:44 <Darwin226> av_: This is probably simpler than it sounds :)
11:06:01 <ski> joe9 : again, i believe your `withInitializedDrawables' there will do the wrong thing ..
11:06:03 <av_> Darwin226: as almost everything in Haskell :) Thanks a lot
11:06:34 <joe9> ski, oh, ok. let me think it through.
11:06:39 <EvanR> av_: its possible to make a DSL that compiles into the shader source code, theres packages for this already i know
11:06:41 <ski> joe9 : it'll not nest the `withVertexArray' calls, but instead do one after another
11:07:05 <ski> (also note that `mapM f . map g = mapM (f . g)')
11:07:35 <EvanR> lgstate_: i recommend going through the lambdapi.pdf and actually implementing simply typed LC first
11:07:58 <joe9> ski, ok. Thanks. let me change that. good catch again.
11:08:00 <ski> joe9 : anyway, this is exactly one of the kind of things that `Cont'/`ContT' is good for
11:08:35 <joe9> ski, ContT I can understand. But, when it gets to 2 parameters, I got lost
11:08:56 <ski> joe9 : sorry ?
11:09:06 <ski> when what gets to 2 parameters ?
11:09:33 <av_> EvanR: yes, I almost wrote one, but the problem turned out to be too simple for the effort
11:09:47 <EvanR> even simpler, only use Float ;)
11:09:58 <joe9> contT2 of Line 155 https://github.com/glguy/irc-core/blob/v2/src/Client/CApi.hs#L146-L158
11:10:17 <ertesx> (side note: Codensity does a better job than ContT for this)
11:10:20 <ski> (also your `withInitializedDrawables' doesn't execute `continueFunction' withing the dynamic extent of any `withVertexArray'. presumably it should be called innermost, when all the dynamic context is set up, before teardown)
11:10:22 <joe9> ski, glguy was nice enough to rewrite that code using ContT2 too.
11:10:37 <bob_twinkles> what is the most widely supported way to do string formating?
11:10:39 <joe9> ski, yes, it should be. let
11:11:00 <EvanR> bob_twinkles: concat [s1, s2, s3, s4, ...]
11:11:04 <joe9> ski, looks like i made a mess of it trying to refactor it.
11:11:23 <bob_twinkles> EvanR: unfortunately I need to do stuff a bit more complex than that =P
11:11:24 <hpc> haskell has printf, and there's a bunch of pretty printer libraries
11:11:28 <EvanR> like what
11:11:29 <joe9> ski, let me read up on ContT and see if I can see a simple usage suitable for this.
11:11:41 <bob_twinkles> fixed with integer fields are the biggest thing
11:11:48 <ertesx> what is ContT2?
11:11:50 <bob_twinkles> which I guess isn't complex
11:11:57 <ski> joe9 : oh, `ContT2', i don't think you'd need that here
11:12:08 <bob_twinkles> but is beyond what I want to do with just concat =P
11:12:15 <EvanR> bob_twinkles: ah well rather than string formatting, thatd be pretty printing. for that ive used package called boxes
11:12:33 <EvanR> you can arrange text into tables
11:13:00 <ski> ertesx : presumably `newtype ContT2 o p m a = MkContT2 {runContT2 :: (a -> m p) -> m o}'. indexed monad
11:13:09 <redmq> this is not necessarily a haskell question, persay... in a service oriented architecture, services have "health" (and when they are unhealthy they're "soft-disabled") ... they can also be explicitly enabled or "hard-disabled" by humans .. what do you call this? "status" seems to vague..
11:13:18 <ertes> ah
11:13:21 <bob_twinkles> I think that might be overkill for what I need =P
11:13:33 <ski> joe9 : did you see the two alternative code snippets i suggested above ?
11:13:33 <joe9> bob_twinkles: groom?
11:13:46 <EvanR> status is horribly vague
11:13:52 <EvanR> and not haskell
11:14:04 <EvanR> bob_twinkles: well theres printf
11:14:17 <grantwu> I don't think there's anything wrong with "status"
11:14:21 <glguy> no, contT2 wasn't a fancier type
11:14:33 <joe9> ski: this? replicateM 6 (ContT (withVertexArray . curry)) `runContT` (continueFunction . zipWith uncurry [screenDrawable,frameDrawable,priceChartDrawable,volumeChartDrawable,horizontalCrosshairDrawable,verticalCrosshairDrawable])
11:14:34 <redmq> EvanR: what words would you use? i've been tossing around "operational state" to refer to health (though, i like health better) and "enabled state" to talk about enabled/disabled status....
11:14:48 <ski> joe9 : properly indented, of course
11:14:53 <EvanR> whatever your coworkers are comfortable with
11:14:56 <redmq> grantwu: but status could refer to health.. it doesn't get at the notion of human-intentioned status
11:14:57 <ski> joe9 : and possibly with stuff factored out better
11:15:07 <EvanR> since almost everything is "status" or "state" it just irks me
11:15:09 <glguy> ski, ertes , it's just a version of contT that works with 2-tuples
11:15:20 <ertes> yeah, that makes more sense
11:15:26 <grantwu> redmq: shrug, you can just conflate the two
11:15:29 <ski> joe9 : that, or the previous one, if you preferred calling `continueFunction' explicitly on the list
11:15:35 <redmq> grantwu: that's bitten us in the past
11:15:35 <sm> bob_twinkles: here are some home-rolled things you might find handy: http://hackage.haskell.org/package/hledger-lib-0.27.1/docs/Hledger-Utils-String.html
11:15:51 <ski> glguy : huh ?
11:15:52 <grantwu> redmq: You could do something like "current state" and "desired state"
11:15:54 <ertes> anyway, i'd go with Codensity‚Ä¶  less value and type arguments, less room for errors, at the expense of a non-transformers dependency (kan-extensions)
11:16:07 <EvanR> redmq: for database stuff, i prefer calling fields or columns by something more specific. status codes really start to break down badly when you can have multiple of them enabled at the same time, and assuming they cant be is often implicit and wrong
11:16:11 <ertes> IMO Codensity should be in transformers
11:16:26 <ski> glguy : .. oh, wrapping up the `curry' and `uncurry', you mean (?) .. i see
11:16:35 <EvanR> when you have multiple properties enabled at once, then you can have a view of that to get a better picture of what state its in
11:16:35 <joe9> ski, ok, Thanks. I am trying to understand them.
11:16:53 <redmq> EvanR: that's what i'm trying to approach; the problem is naming the two properties
11:16:57 <redmq> health vs .. enabled?
11:17:03 <ski> joe9 : as i said, the ugliest part is probably the currying and uncurrying
11:17:05 <bob_twinkles> I think printf is going to do it for me, thanks everyone
11:17:10 <bob_twinkles> though those other libraries do look cool
11:17:10 <EvanR> healthy, yes no. enabled yes no
11:17:16 <EvanR> could be
11:17:17 <ski> (imho)
11:17:45 <joe9> bob_twinkles: check out groom. it is simpler and mostly does the right thing.
11:18:13 <ski> joe9 : the important point is that we run `replicateM' (or, if you prefer, `mapM') in the `ContT b IO' monad, rather than in the `IO' monad
11:18:21 <ski> joe9 : that will effect the desired nesting
11:18:34 <redmq> i'm just trying to avoid using the word enabled to refer to something that could be enabled or disabled
11:18:43 <redmq> kind of like we use Maybe to refer to Just/Nothing.. 
11:19:08 <redmq> trying to get a the concept more clearly
11:19:21 <ski> joe9 : `runContT' is used to escape out of `ContT', and simultaneously to provide (more or less) `continueFunction' of your `initializeDrawables'
11:20:11 <ertes> redmq: ultimately the name doesn't matter‚Ä¶  if you suffer from boolean-blindness you have to explain the relationships of that value to other things‚Ä¶  otherwise the relationship follows from other factors
11:20:30 <EvanR> redmq: huh, enabled: no and enabled: yes is way better than status: true false heh
11:20:38 <EvanR> or something
11:20:59 <joe9> ski, it would probably make it simpler if I change withVertexArray to use a tuple, correct?
11:21:02 <ski> (joe9 : your `continueFunction' received `Drawable's, since `initializeDrawables' already got a list of type `[VertexArrayId -> BufferId -> Drawable]' to convert the internally (conceptually) generated list of type `[(VertexArrayId,BufferId)]' to one of type `[Drawable]' with ..)
11:21:25 <bob_twinkles> joe9: I'm formating data for consumption by an API
11:21:38 <bob_twinkles> groom definitely looks useful for when I'm printing out complex structures though
11:21:46 <ski> (joe9 : while in my case, i haven't yet applied your `VertexArrayId -> BufferId -> Drawable' functions, so that needs to be done inside the right argument to `runContT')
11:21:51 <joe9> ski, withVertexArray :: (VertexArrayId -> BufferId -> IO a) -> IO a to withVertexArray :: ((VertexArrayId, BufferId) -> IO a) -> IO a to
11:21:56 <redmq> hmm.. thanks EvanR 
11:22:00 <joe9> bob_twinkles: oh, ok. then groom is out.
11:22:12 <ski> joe9 : as i said, it can probably be factored a bit more nicely. my point was to try to get across the basic gist of how to use it
11:22:27 <joe9> ski, yes, I think I understand it. Thanks a lot.
11:22:50 <ertes> redmq: related: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
11:23:34 <ski> joe9 : "it would probably make it simpler if I change withVertexArray to use a tuple, correct?" -- yes, or define a helper function for this (iiuc now, that was what glguy's `contT2' was about. (i was previously thinking about other thing, which i've called `ContT2' ..))
11:24:24 <joe9> ok, Thanks. ski.
11:24:49 <ski> joe9 : anyway .. i suppose i'm arguing here for trying to get a bit more familiar with this (imho) nice usecase of `Cont'/`ContT', so that you can more easily read code like the suggested, in cases where it's beneficial to use it
11:25:37 <ski> i'm not arguing for being able to easily read all the crazy kind of things one can do with `Cont'/`ContT', but rather this "nesting" use of it
11:27:16 <ski> (but by all means, make refactorings and helper functions, where it makes sense, to make it more readable. e.g. your `withInitializedDrawables', if you want to)
11:27:52 * hackagebot varying 0.6.0.0 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.6.0.0 (SchellScivally)
11:31:47 <joe9> ski, quick question, why are you using replicateM? Would a version of foldl help in this case?
11:33:12 <joe9> ski, foldM of Control.Monad.
11:33:52 <joe9> ski, may be not. I am still getting my head around it. sorry for the bother.
11:42:11 <ski> joe9 : well, `replicateM 6' instead of using `mapM' with a list that's equal to `replicate 6 withVertexArray'
11:42:51 <ski> (since your list `[screenDrawable,...]' was hardcoded in your example)
11:43:30 <ski> joe9 : but it'd probably be nicer to use `length' on that list. or otherwise rephrase it so that the correct number of `withVertexArray's will be invoked (nestedly, because of `ContT')
11:44:30 <ski> joe9 : i haven't considered any fold here. could possibly work, for what i know
11:47:40 <joe9> ski, the key from what I understand is that the call should be "nestedly".
11:48:07 <joe9>  http://bpaste.net/show/84e00b281fe4 ski, where I am
11:50:13 <ski> joe9 : `runContT . ContT = id', to do anything interesting, you'll have to put something inbetween there, like `mapM', `mapM_', `replicateM', or `replicateM_'
11:51:56 <ski> then the corresponding `ContT b IO'-action (a wrapped up `(a -> IO b) -> IO b' "`with'"-type function, for some `a') passed to `mapM'/&c. will cause that "`with'"-type function to be invoked "nestedly"
11:53:12 <joe9> ski, ok. Thanks.
11:54:09 <ski> (well, that last wasn't phrased ideally. hopefully you get the point, though)
12:05:03 <Hermit> guys, I need some piece of advice. I'm developing a library for communicating with a piece of buggy equipment through telnet. Basically I need to interact with a repl and parse some output. Where things get hairy: need to deal with a few telnet control codes to keep it working nicely, need timeout control to restart the session as soon as it hangs.
12:05:37 <sm> fun times!
12:06:39 <sm> what about http://hackage.haskell.org/package/libexpect 
12:06:45 <Hermit> at first I tried going with conduits, but I couldn't set timeouts and once I used left fusion to sanitize a few things, I could no longer deal with the raw bytestring stream
12:07:50 <Hermit> at some point I thought: what if I use a Parsec transformer to model the whole thing, but it doesn't feel right (though maybe it is)
12:08:58 <Hermit> I'm a bit baffled at this point
12:09:31 <Hermit> maybe I should just go with raw socket operation, ride on a resource transformer and manually feed the parsers
12:09:59 <volhovm> What is the best choice if i need to use doubly linked list? Seq? Some kind of weird zipper?
12:10:04 <Hermit> I'd like to keep things neat
12:10:27 <EvanR> volhovm: a regular zipper might work, depending on what you want to do with it
12:10:37 <EvanR> you can go forward and backwards
12:10:46 <EvanR> if its finite, you can also serialize it
12:10:54 <volhovm> I'm doing precisely insert to the head, delete from the middle, lets say...
12:11:05 <EvanR> then zipper wont work
12:11:20 <EvanR> Seq it is
12:11:23 <volhovm> also where can i read more about zipper?
12:11:32 <volhovm> Ok, seq is fine in fact
12:11:46 <volhovm> Just curious about if this asymptotics is best available
12:11:47 <EvanR> Seq lets you constant append to the head (or tail), and log modify the middle
12:13:12 <EvanR> and until you determine that the amount of data is enough that this would matter, might go with something that is just simpler and possibly replace it later
12:13:17 <EvanR> i.e. a list
12:14:02 <osa1> ahh I had found a very weird GHCi but, too bad a restart fixed it
12:18:52 <mnoonan> is there a way to inspect the memory layout of a data structure, for debugging purposes?
12:19:29 <EvanR> theres ghc-vis 
12:20:03 <mnoonan> oh, looks nice!
12:20:11 <mnoonan> how did I miss that before?!
12:24:15 <nitrix> What is the best way to have a monad for my application that allows IO only for a given module? I currently have a newtype of monad transformers over IO and a few functions that hides IO operations.
12:24:51 <EvanR> you could use static capabilities
12:25:15 <EvanR> i might be making this up, but it was referenced in the lightweight dependent types link
12:25:19 <nitrix> It's all in the same module, so other modules using it are perfectly happy, but the more I think about it, the more I want my renderer to also be able to do IO, but I don't want to derive MonadIO as now I'd give that access to everyone.
12:25:40 <EvanR> in your monad, liftIO takes another parameter of a certain type, a phantom type
12:25:42 <nitrix> io :: IO () -> Game ()  seems like a bad idea too.
12:25:43 <EvanR> or singleton
12:26:02 <EvanR> and you dont give this permission value to the other modules
12:26:23 <EvanR> io :: IOAllowed -> IO () -> Game ()
12:27:13 <nitrix> EvanR: A permission _value_ ?
12:27:15 <EvanR> to avoid passing this around all over the place (the usual problem) you can use implicit configurations to open up an environment where IO is allowed
12:27:21 <EvanR> yeah, a singleton
12:27:46 <nitrix> Let's backtrack, first how do you give it to one module and not another?
12:27:52 <EvanR> but really just passing to thwere its needed shouldnt be a big deal
12:27:54 * hackagebot sbp 1.2.2 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.2.2 (jgross)
12:28:42 <EvanR> the question is where it comes from in the first place
12:29:03 <nitrix> Ah. So you're suggesting to make that value completely runtime.
12:29:05 <EvanR> in your top level run function, it can be passed to your game action
12:29:11 <qmm> does anyone know the difference between parsec and megaparsec and why you might choose one over the other?
12:29:32 <EvanR> hide the module defining the singleton, and then other modules cant just use it
12:29:45 <EvanR> very OOP like
12:30:51 <nitrix> I thought you were going for some orphan instance system, but you're just suggesting a top-level magical key value in main that I can pass to my modules that I want to allow them to do "IO".
12:31:13 <EvanR> so if you dont trust yourself, perhaps you are worried about sleep coding IO into places it doesnt belong, this scheme would require you to modify all the code leading to the use site and pass another parameter in, in your sleep
12:31:23 <EvanR> yes pretty much
12:31:34 <EvanR> theres ways to make it so the passing is implicit though
12:31:47 * ski . o O ( `newtype IOAllowed = IOA (IO () -> Game ())' )
12:32:08 <nitrix> ski: Yeah, I thought the same thing.
12:32:08 <EvanR> cool
12:32:35 <EvanR> first class protected liftIO
12:34:25 <nitrix> That's still a complicated subject because you want to easily mark a module as "you can do IO in my monad", but don't want people to just easily abuse it.
12:34:52 <nitrix> I was hoping for something that has a similar contagious type like IO.
12:35:09 <EvanR> youd have to add an IOAllowed to each "function" that can do it
12:35:23 <EvanR> unless you smuggled it in in a datatype
12:35:33 <EvanR> which makes that type effectively an IOAllowed
12:35:55 <nitrix> To be honest, currently I have this monster:
12:36:19 <ski> (in case `data IOAllowed = IOA', you could obviously make sure to match on this in `io', to avoid being able to pass a bottom as fake token)
12:36:26 <nitrix> newtype Game a = Game { unwrapGame :: EnvironmentT (MaybeT (StateT GameState IO)) a } deriving (Functor, Applicative, Monad, MonadState GameState)
12:36:31 <ski> (s/could/should/)
12:36:32 <nitrix> newtype Core a = Core { unwrapCore :: EnvironmentT (MaybeT (StateT GameState IO)) a } deriving (Functor, Applicative, Monad, MonadState GameState, MonadReader Environment, MonadIO)
12:36:36 <nitrix> embedGame :: Game a -> Core a
12:37:37 <nitrix> Where the Game monad lets me do game stuff, the Core monad you can do IO things, and then there's embedGame where you can embed Game things in Core things.
12:38:10 <nitrix> It evolved naturally, but I was looking for a better approach.
12:38:35 <EvanR> when i dont want my game doing IO, yet also able to do IO, i make it return Io actions
12:38:53 <EvanR> then the interpreter is responsible for simply executing it
12:39:22 <EvanR> which is just in IO
12:39:55 <EvanR> or not, if its a test framework
12:39:56 <nitrix> It's not really about where/when the IO is done, it's more of, I don't want it sporadically all over the codebase.
12:40:33 <EvanR> then dont put it sporadically throughout the codebase? ;)
12:40:36 <nitrix> Someone cutting corners, in the middle or game logic, decides to update the UI or something on screen.
12:41:10 <EvanR> well with a "do arbitrary IO" combinator, you still might not be able to do that without the proper UI refs
12:41:22 <nitrix> EvanR: So far my game has these "frames", where I can run the game for a frame, obtain the new state and give that to the renderer.
12:41:45 <nitrix> EvanR: There's a very clean line between Game (the logic) and Core (SDL, network, renderer) at the moment.
12:42:29 <EvanR> speaking of which , why do you need an arbitrary IO combinator at all?
12:42:44 <EvanR> you dont want to make a DSL for the possible IO actions
12:42:58 <EvanR> "send message to foo" "debug log"
12:42:59 <nitrix> EvanR: I don't. Game cheats. I actually has 3 IO actions.
12:43:23 <EvanR> well make that a data type and interpret it somewhere else
12:43:27 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Game.hs#L88
12:43:30 <nitrix> A little more apparently
12:43:45 <nitrix> createLink is in IO, gameCreateLink is in Game.
12:44:16 <nitrix> Theorically, Game also does IO, but it's just those functions. A very very tiny DSL.
12:44:44 <EvanR> if you have a subset of IO ()'s, then they and their standins form a monoid with >>, and you could WriterT it ;)
12:45:36 <nitrix> That's not a bad idea.
12:46:27 <EvanR> the key simplification here is you arent expecting an answer, they are fire-and-forget actions
12:47:02 <EvanR> sound effects, create a thing (dont care about any pointer to it), run a command (ignore the stdout)
12:47:02 <nitrix> Mhhh, except gameReadLink
12:47:20 <EvanR> welp nevermind ;)
12:47:48 <nitrix> I'll remember the suggestion for other things though. Very neat trick.
12:47:51 <heebo> um macos sierra dyld limit exceeded wtf?!
12:48:30 <EvanR> to separate that out, youll need coroutines, free monads, callback registration, etc
12:48:41 <joe9> ski, sorry to bother you. I understand how ContT and runContT work. but, I cannot understand how the replicateM portion of the code works.
12:49:04 <joe9> ski, I understand a simple runConT cont continueFunction works.
12:49:09 <EvanR> significantly more complex
12:49:56 <nitrix> EvanR: My Game and Core system, that lets you embed Game into Core kinda works for now.
12:49:59 <ski> joe9 : the point is to execute multiple `ContT withBlah' actions in a row
12:50:10 <joe9> ski, but, how does chaining continuations work with replicateM work? replicateM just duplicates objects (in this case, continuation objects). T
12:50:15 <joe9> ski, oh, Ok. Thanks.
12:50:26 <heebo> sorry to be clear, im shocked and disappointed at macos sierra update that breaks stack
12:50:35 <heebo> anyone else experiencing this?
12:51:07 <ski> joe9 : like `do x <- ContT withBlahX; y <- ContT withBlahY; z <- ContT withBlahZ; return (x,y,z)', instead of `withBlahX $ \x -> withBlahY $ \y -> withBlahZ $ \z ->'
12:52:08 <ski> joe9 : and the former can be abbreviated as `do [x,y,z] <- mapM ContT [withBlahX,withBlahY,withBlahZ]; return (x,y,z)'
12:53:28 <ski> joe9 : in case `withBlahX',`withBlahY',`withBlahZ' are all the same thing, say `withBlah', then you have `mapM ContT [withBlah,withBlah,withBlah]', which is `mapM ContT (replicate 3 withBlah)', which is `replicateM 3 (ContT withBlah)'
12:54:08 <joe9> ski, shouldn't it be: `let f = ContT withBlahX >>= ContT withBlahY >>= ContT withBlahZ '
12:55:24 <joe9> ski, oh, and replicateM does that sequencing.
12:55:50 <ski> joe9 : we want to collect the `x',`y',`z' results from the `withBlahX',`withBlahY',`withBlahZ' calls (assuming they have the same return type, otherwise we'd use `liftM3 (,,) (ContT withBlahX) (ContT withBlahY) (ContT withBlahZ)' instead of `mapM ContT [withBlahX,withBlahY,withBlahZ]')
12:55:56 <ski> yes
12:56:01 <ski> @src replicateM
12:56:01 <lambdabot> replicateM n x = sequence (replicate n x)
12:56:10 <ski> @src mapM
12:56:10 <lambdabot> mapM f as = sequence (map f as)
12:56:53 <ski> your `ContT withBlahX >>= ContT withBlahY >>= ContT withBlahZ' would try to feed `x' directly onwards to the next part
12:58:38 <joe9> ski, that is where I am getting stuck "feed 'x' directly onwards to the next part"
12:59:01 <ski> (the `return' above is btw just to not drop `x',`y',`z' on the floor. you could have something more involved there. but the point is that you *can* just `return' them in the `ContT b IO' monad, and still have whatever followes the call of this `f' intuitively be "nested inside" it)
12:59:56 <ski>   ContT withBlahX >>= ContT withBlahY >>= ContT withBlahZ
12:59:58 <ski> means
13:00:03 <ski>   (ContT withBlahX >>= ContT withBlahY) >>= ContT withBlahZ
13:00:04 <ski> means
13:00:21 <ski>   (ContT withBlahX >>= \x -> ContT withBlahY x) >>= \y -> ContT withBlahZ y
13:00:58 <joe9> ski, i think i understand this part. i was getting tripped on how the replicateM does the sequencing or the >>=
13:00:58 <ski> but here, that doesn't make sense
13:01:14 <ski> `ContT withBlahY' is not a function, nor is `ContT withBlahZ' one
13:01:45 <ski> well, consider
13:01:53 <ski>   do x <- ContT withBlahX; y <- ContT withBlahY; z <- ContT withBlahZ; return (x,y,z)
13:02:15 <ski>   do [x,y,z] <- sequence [ContT withBlahX,ContT withBlahY,ContT withBlahZ]; return (x,y,z)
13:02:28 <ski>   do [x,y,z] <- sequence (map ContT [withBlahX,withBlahY,withBlahZ]); return (x,y,z)
13:02:43 <ski>   do [x,y,z] <- mapM ContT [withBlahX,withBlahY,withBlahZ]; return (x,y,z)
13:03:18 <ski> now, assume that we use `withBlah' for `withBlahX',`withBlahY',`withBlahZ' :
13:03:29 <ski>   do [x,y,z] <- mapM ContT [withBlah,withBlah,withBlah]; return (x,y,z)
13:03:44 <ski>   do [x,y,z] <- mapM ContT (replicate 3 withBlah); return (x,y,z)
13:03:53 <ski>   do [x,y,z] <- sequence (map ContT (replicate 3 withBlah)); return (x,y,z)
13:03:55 <joe9> I get ContT r IO [x]
13:04:09 <ski>   do [x,y,z] <- sequence (replicate 3 (ContT withBlah)); return (x,y,z)
13:04:16 <ski>   do [x,y,z] <- replicateM 3 (ContT withBlah); return (x,y,z)
13:04:28 <ski> this is using
13:04:38 <ski> @src mapM
13:04:39 <lambdabot> mapM f as = sequence (map f as)
13:04:43 <ski> @src replicateM
13:04:43 <lambdabot> replicateM n x = sequence (replicate n x)
13:05:17 <ski> and the intuitive meaning of `sequence' to collect a sequence of actions, where neither of the latter depends on the monadic results of the former (which is the case here)
13:05:20 <joe9> ski, I get it. Thanks a lot.
13:05:32 <joe9> ski, got it, man. Thanks for being so patient.
13:05:52 <nitrix> @pl (\s -> print s >> threadDelay 1000000)
13:05:52 <lambdabot> (>> threadDelay 1000000) . print
13:05:54 <ski> and also depends on `replicate' being a natural transformation, so that we know `map f . replicate n = replicate n . f', for any `f' and `n'
13:05:57 <joe9> ski, it is just m x -> m [x]
13:06:30 <ski> joe9 : it takes some while to get used to how `Cont'/`ContT' works with stuff like this, but imho, it can be well worth it
13:06:44 <hodapp> I am really, really at a loss for why cabal is complaining about a file in a completely different build that I haven't used for a year and that is in no way related to the thing I'm trying to build.
13:06:57 <ski> joe9 : np
13:07:03 <nitrix> :t (>=>)
13:07:04 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:07:14 <joe9> ski, ok, Thanks. I worked through the ContT stuff a few years ago. and totally forgot about it now.
13:07:45 <nitrix> Is there a...
13:08:04 <nitrix> Monad m => (a -> m b) -> m c -> a -> m c  ?
13:08:32 <ski> not that i recall
13:08:34 <nitrix> >=> that's closer to >> disregarding the argument ?
13:08:44 <ski> add a `const', i suppose
13:09:20 <ski> @type \amb mc -> amb >=> const mc
13:09:23 <lambdabot> Monad m => (a -> m b) -> m c -> a -> m c
13:10:33 * ski is always happy to see someone using continuations :)
13:10:45 <nitrix> I shall create >.>
13:11:21 <hodapp> ski: just writing up a post now at HaskellEmbedded about how I learned to stop worrying and love continuations (for embedded programming)
13:11:25 <hodapp> or something like that
13:11:47 <jle`> i wish there was a way to get a continuation monad to work with skolemized existentials
13:12:14 <jle`> there might be a way with rebindablesyntax maybe :|
13:12:30 <ski> nitrix : not `>=.' ?
13:13:07 <ski> (to emphasize which side isn't a kleisli arrow)
13:13:11 <nitrix> That's theorically what it should be.
13:13:19 <nitrix> But that doesn't make a cute face.
13:13:25 <nitrix> :P
13:13:34 * ski shrugs
13:13:35 <EvanR> face oriented programming
13:13:48 <nitrix> Programming With Emojis In Haskell
13:14:06 <EvanR> exists
13:14:15 <nitrix> I hope that never gets quoted anywhere with my name on it.
13:14:22 <EvanR> https://twitter.com/emojihaskell
13:22:33 <dagda1> can anyone explain why my isOdd function is not returning the results I expect https://gist.github.com/dagda1/5def666d482ec5d0751a641eef2d5564
13:23:02 <joe9> ski, http://bpaste.net/show/1c73467042ca if you do not mind, can you skim through this to ensure that my understanding is correct.
13:23:20 <joe9> ski, sorry for bothering you. I just want to make sure that I get it right.
13:25:05 <ski> joe9 : sounds mostly right
13:25:16 <joe9> ski, Thanks a lot.
13:25:36 <ski> joe9 : what is passed to `runCont'/`runContT' will be placed innermost in the nesting
13:25:54 <ski> (not sure how well you grasped that)
13:26:30 <joe9> ski, yes, I get that. It will the innermost basically nested down.
13:26:48 <joe9> ski, that is how the >>= of the Cont monad is defined.
13:27:04 <ski> joe9 : with `replicateM 2 (... :: ContT b m a)', you get something of type `ContT b m [a]', and so when using `runContT', you should provide a continuation of type `[a] -> m b', not `a -> b' as you said
13:27:04 <joe9> ski, take the next function and apply it within my context ( or, belly)
13:27:44 <joe9> ski, runCont is just unwrapping. It is the sequence or the >>= that does the magic of applying the next function within my context.
13:27:55 * hackagebot ion 1.0.0.0 - EDSL for concurrent, realtime, embedded programming on top of Ivory  https://hackage.haskell.org/package/ion-1.0.0.0 (hodapp)
13:27:57 * hackagebot data-msgpack 0.0.4 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.4 (iphydf)
13:28:13 <joe9> ski, oh, gotcha. interesting. good catch. let me think that through.
13:29:29 <joe9> ski, i totally misunderstood that.
13:29:37 <joe9> ski, I think I get it now.
13:31:33 <hodapp> woo! hackagebot acknowledged something I did!
13:33:34 <dedgrant> dagda1: What is the result of (elemIndex 18 [18,18])?  (May help illustrate the error in the strategy.)
13:33:53 <dagda1> dedgrant: ha of course
13:34:17 <bjorn__> how to integrate a haskell script inside a stack project?
13:34:31 <bjorn__> where should i put it in the cabal file
13:35:03 <dagda1> @dedgrant is it possible to get the index with foldl?
13:35:03 <lambdabot> Unknown command, try @list
13:36:16 <jonored> dagda1: zip will get you there, at least.
13:36:35 <dagda1> @jonored great, thanks
13:36:35 <lambdabot> Unknown command, try @list
13:36:48 <jonored> fold someFunc (zip [1..] stuff)
13:36:56 <joe9> ski, this is what replicateM is doing :t k >>= (\x -> k >>= \y -> return [x,y]) >>= (\(x:y:[]) -> k >>= \z -> return [x,y,z])
13:36:57 <dedgrant> dagda1: Certainly. You can zip up pairs of [(Index,Value)] and filter on that.  I suspect whatever exercise source this comes from may be expecting a solution to be written as pattern-matched recursion.
13:38:06 <joe9> ski, :t k >>= (\x -> k >>= \y -> return [x,y]) >>= (\xy -> k >>= \z -> return (xy ++ [z]))
13:38:07 <joe9> k >>= (\x -> k >>= \y -> return [x,y]) >>= (\xy -> k >>= \z -> return (xy ++ [z]))
13:38:07 <joe9>   :: ContT r IO [(VertexArrayId, BufferId)]
13:38:56 <joe9> ski, to understand this: k >>= -- this >>= is the Cont monad's >>=
13:39:45 <joe9>  ski, (\x -> k >>= \y -> return [x,y]) -- the >>= here is the IO monad's >>=?
13:41:43 <joe9> ski, this (\x -> k >>= \y -> return [x,y])  is the replicateM plumbing, correct?
13:43:15 <ski> joe9 : "runCont is just unwrapping", sure :) doesn't change what i said, though :)
13:43:47 <ski> <joe9> ski, this is what replicateM is doing :t k >>= (\x -> k >>= \y -> return [x,y]) >>= (\(x:y:[]) -> k >>= \z -> return [x,y,z])
13:43:52 <ski> where does `k' come from ?
13:44:12 <joe9> ski: let k = (ContT (withVertexArray . curry))
13:44:20 <joe9> :t k :: ContT r IO (VertexArrayId, BufferId)
13:44:21 <lambdabot> error:
13:44:21 <lambdabot>     Not in scope: type constructor or class ‚ÄòVertexArrayId‚Äô
13:44:22 <lambdabot> error:
13:44:22 <joe9> ski ^^
13:44:58 <ski> well, `replicateM' doesn't repeatedly pack and unpack the list like that
13:45:59 * ski renames `k' to `with'
13:46:06 <ski> what it's doing is more like
13:46:34 <ski>   \k -> act >>= \x -> act >>= \y -> act >>= \z -> k [x,y,z]
13:46:59 <ski> where `k' here is what you pass to `runContT', when you decide to get out of `ContT'
13:47:09 <joe9> ok, got it. Thanks.
13:47:37 <ski> (the result is the same, of course. just pointing out that it's not repeatedly adding an element to the end of an accumulating list)
13:47:54 <ski> (er, apparently i renamed it to `act' ..)
14:10:06 <joe9> ski, sorry for the bother. The sequence is one doing the actual foldr or nesting when it applies the >>= of the continuation monad, correct?
14:10:56 <joe9> ski, http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Traversable.html#sequenceA the traverse function for list is doing the foldr and accumulating the results
14:11:17 <joe9> ski, better link http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Traversable.html#traverse
14:12:07 <joe9> ski     traverse f = List.foldr cons_f (pure []) where cons_f x ys = (:) <$> f x <*> ys
14:14:24 <joe9> ski, the ".. <$> f x ..", the f is the continuation bind function, correct?
14:24:56 <ski> joe9 : can't quite parse "The sequence is one doing the actual foldr or nesting"
14:27:46 <ski> joe9 : "the f is the continuation bind function, correct?" -- no, `f' there is the "body" callback argument to `traverse', which is similar to `mapM'
14:27:57 * hackagebot network-msgpack-rpc 0.0.2 - A MessagePack-RPC Implementation  https://hackage.haskell.org/package/network-msgpack-rpc-0.0.2 (iphydf)
14:31:28 <joe9> ski, ok. Thanks a lot.
14:33:02 <ski> the continuation passed for the `ContT' version would only be visible if you expand `(>>=)' (or `(<*>)', in case of `traverse')
14:33:48 <ski> (i assume that by "continuation bind function" you meant that continuation .. sometimes the right argument to `(>>=)' is also referred to as a continuation, though ..)
14:48:04 <bjorn__> in the stack project folder, in the cabal file, there is no place for adding a haskell script
14:48:23 <Welkin> ...what?
14:48:28 <bjorn__> there is library,excutable
14:48:31 <bjorn__> section
14:48:39 <Welkin> what are you asking?
14:48:42 <bjorn__> but where should i put the haskell script ?
14:48:48 <Welkin> ...what?
14:48:51 <Welkin> under executable
14:48:52 <bjorn__> i have a haskell script
14:49:28 <bjorn__> ok
14:51:32 <hexagoxel> .oO   .hs stands for haskell, or perhaps haskell source
14:57:39 * ski thought it was "Haskell Script" ..
14:57:54 <Welkin> o.o
14:57:55 <Welkin> never
14:58:02 <ski> (at least istr HuGS seemed to imply that)
14:58:06 <Welkin> it's just an extension that is short for "haskell"
14:58:10 <Welkin> like "idr" is for "idris"
14:59:01 <ski> (and "pl" for Prolog)
14:59:10 <Welkin> pl? really?
14:59:10 <Welkin> lol
14:59:14 <Welkin> what about perl?
14:59:14 <ski> of course
14:59:27 <ski> Prolog came before :)
15:00:46 <ski>   ;; perl i all √§ra men va fasen, prolog e koolare :)
15:01:13 <ski>   (setq auto-mode-alist (append '(("/[Pp]erl.*/.*\\.[pP][Llm]$" . cperl-mode) ("\\.perl$" . cperl-mode) ("\\.pl$" . prolog-mode)) auto-mode-alist)
15:02:02 <ski> )
15:16:22 <mauke> .pl is "perl library"
15:16:27 <mauke> and .pm = "perl module"
15:16:35 <osa1> how do you fold while accumulating something on the side using base only?
15:16:56 <geekosaur> "on the side"?
15:16:56 <osa1> err, I mean map, not fold
15:16:56 <mauke> dunno, mapAccum[LR]?
15:17:15 <Welkin> hahaha
15:17:20 <Welkin> like a side hustle?
15:17:25 <Welkin> being paid under the table?
15:18:59 <osa1> hmm I need mapAccumLM
15:19:20 <shachaf> i,i mapAccuML
15:22:22 <EvanR> on the flip side
15:22:45 <Welkin> what does that mean?
15:22:48 <Welkin> mr jargon
15:22:57 * EvanR gets the jargon file
15:45:07 <prsteele> hey everyone. My library "Foo" is listed as a dependency of my test suite in my Foo.cabal file, but `cabal build` insists that I need to add packages that Foo depends on as dependencies of FooTest. How can I make FooTest simply rely on the build-depends of Foo?
15:45:41 <glguy> prsteele: Make sure your hs-source-dir isn't the same in your test as your library
15:46:13 <prsteele> glguy: that was exactly it, I had hs-source-dirs: src, tests
15:46:21 <prsteele> thanks!
16:17:32 <soLucien> :t foldr
16:17:36 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:17:41 <soLucien> what is the meaning of t a ?
16:17:59 <prsteele> soLucien: the stuff before => is a _class constraint_
16:18:06 <prsteele> it tells us that t is an instance of Foldable
16:18:14 <soLucien> yes i understand that
16:18:18 <prsteele> so `t a` is a foldable of 'a's
16:18:29 <soLucien> i see 
16:18:36 <prsteele> you can replace t with [] to understand foldr applied to lists
16:18:54 <prsteele> e.g. foldr :: (a -> b -> b) -> b -> [a] -> b
16:18:56 <geekosaur> t is some type constrictor that has a Foldable instance. a type constructor is something like [] (at type level):  a list of some type a is [a], [] itself is a type constructor that needs to be parameterized with a type
16:19:00 <geekosaur> Maybe is another example
16:19:25 <prsteele> most containers, too. like a map, or set, or tree...
16:19:30 <geekosaur> (and yes, you can say [] a instead of [a] at type level, it just looks funny)
16:19:57 <soLucien> i understand
16:19:58 <EvanR> t is a type constructor, [ ] is a type constrictor
16:20:21 <geekosaur> heh
16:20:24 <soLucien> thanks, that is clear now
16:22:13 <Welkin> is there a way to specify a remote git repo as a dependency/package using nix and cabal2nix?
16:22:28 <Welkin> I don't remember if there is a simple way to do that with cabal itself
16:22:38 <Welkin> I usually use stack's stack.yaml
16:26:01 <Welkin> @where cabal2nix
16:26:01 <lambdabot> I know nothing about cabal2nix.
16:27:59 * hackagebot hw-prim 0.1.0.2 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.1.0.2 (haskellworks)
16:32:08 <dpren> Is the Lens library the way to go if I want to do something like this JS example in Haskell?  https://stackoverflow.com/a/17098250
16:32:48 <glguy> dpren: That example would just be: filter (\item -> parent (category item) == "Food")
16:33:05 <Welkin> no one here uses nix? or remote repos with cabal?
16:33:31 <Welkin> it looks like I may be able to use stack with nix anyway
16:33:31 <glguy> Locations of dependencies are out of scope for Cabal library, and local directories are supported for cabal sandbox
16:33:58 <glguy> I prefer tracking git dependencies of a project in development with submodules
16:34:14 <johnw> Welkin: use cabal2nix to download the package's nix file; then modify it to use fetchgit; then change your config.nix or project default.nix to refer to this path
16:35:40 <Welkin> johnw: I don't kno what fetchgit is
16:36:00 <johnw> Welkin: if you Google or look in nixpkgs, you'll find lots of examples
16:37:12 <dpren> glguy: what would 'parent' and 'category' be in your example?
16:37:17 <Welkin> http://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure
16:37:20 <Welkin> I'm reading this
16:37:31 <glguy> dpren: functions
16:38:46 <dpren> glguy: right, I mean the type signature
16:39:34 <glguy> category :: Item -> Category; parent :: Category -> Category
16:41:57 <mizu_no_oto> Does Opaleye support varchar columns?
16:49:34 <ReinH> Category -> Category... hmmm.....
16:53:41 <vishakhkumar> Sup!
17:07:57 <intothemountain> https://en.wikibooks.org/wiki/Haskell/Applicative_functors
17:08:20 <intothemountain> Here, in the Functor recap section, where it says fmap _ id = id, shouldn't it be fmap id _ = id?
17:08:44 <intothemountain> Otherwise I don't get it
17:09:25 <hpc> wow, that's totally wrong
17:09:29 <hpc> it should be fmap id = id
17:09:49 <intothemountain> Er, yes
17:10:05 <hpc> that page needs to be revised
17:10:18 <intothemountain> If someone volunteers to make the change‚Ä¶ I wouldn't want to create an user just for that
17:10:28 <mniip> https://en.wikibooks.org/w/index.php?title=Haskell%2FApplicative_functors&type=revision&diff=3124137&oldid=3077334
17:10:37 <mniip> looks like it needs a rollback
17:11:16 <hpc> that edit's comment ends in a question mark lol
17:13:15 <hpc> incidentally, fmap f id = f
17:13:20 <hpc> ;)
17:14:23 <hpc> and since fmap id f = f, we can php this thing and naturally conclude that fmap = "pick the thing that isn't id"
17:14:51 <intothemountain> lol
17:15:42 <mniip> but what about 'fmap f g'
17:15:47 <mniip> is it f or g
17:15:53 <hpc> :t forg
17:15:54 <lambdabot> error:
17:15:55 <lambdabot>     ‚Ä¢ Variable not in scope: forg
17:15:55 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
17:16:13 <hpc> obviously it throws FileNotFoundException
17:16:14 <prsteele> is there a standard alternative to the (.) . (.) idiom?
17:16:15 <mniip> :t ?f or ?g
17:16:17 <lambdabot> (?g::t1, ?f::(t Bool -> Bool) -> t1 -> t2, Foldable t) => t2
17:16:39 <hpc> prsteele: usually people define something like (.:) = fmap fmap fmap
17:16:48 <hpc> :t fmap fmap fmap
17:16:49 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:17:08 <hpc> which can equal that, but also many other things
17:17:32 <mniip> fmap fmap fmap fmap fmap /= fmap `fmap` fmap `fmap` fmap thouhgh
17:17:46 <EvanR> fmap-only styl
17:18:07 <prsteele> :t flip on
17:18:08 <prsteele> is close
17:18:08 <lambdabot> (a -> b) -> (b -> b -> c) -> a -> a -> c
17:18:13 <mniip> EvanR, C is not a complete combinator set
17:18:18 <prsteele> hpc: thanks!
17:18:58 <mniip> oh, it's called B
17:19:05 <prsteele> I'm only using it... 3 times, so I'm not sure its worth defining a symbol for. might just write it out manually
17:19:11 <EvanR> mniip: good, complete only serves to get us into infinite loops
17:19:27 <hpc> prsteele: yeah, fair enough
17:19:28 <mniip> not in a typed system
17:19:50 <MarcelineVQ> prsteele: on defines a symbol that's only used once :>
17:19:52 <hpc> prsteele: i don't mind leaving things deliberately undefined as a way of reminding myself not to do it too often
17:20:07 <hpc> prsteele: and if i do use it too often, i notice by way of syntactic cost
17:20:16 <prsteele> MarcelineVQ: yes, but at least it's part of a built-in lib
17:20:26 <prsteele> hpc: ya that's not a bad heuristic
17:20:52 <prsteele> in this case I went with `Foo <$> liftA2 Bar x y`
17:21:30 <mniip> :t pure (<*>) <*> pure
17:21:31 <lambdabot> Applicative f => (a -> b) -> f a -> f b
17:21:46 <nornagon> that looks like laser eyes
17:22:14 <nornagon> the cyclops operator
17:23:01 <hpc> well, one eye is a laser eye
17:23:07 <hpc> it's the locutus operator
17:24:04 <Welkin> why does stack automatically assume that a new project is going to be a library?
17:24:25 <mniip> :t pure (pure (<*>) <*> pure) <*> (pure (<*>) <*> pure)
17:24:27 <lambdabot> (Applicative f1, Applicative f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:24:47 <Welkin> the .cabal file gets all messed up
17:24:47 <MarcelineVQ> Welkin: does yours only have a library section? it's supposed to assume it's an executable in which most of your code is in a library
17:24:58 <Welkin> MarcelineVQ: yeah, that
17:25:01 <Welkin> it has both
17:25:05 <hpc> doesn't it do what the cabal file says?
17:25:08 <Welkin> but why would my code be a library at all?
17:25:19 <Welkin> the project structure is confusing
17:25:39 <MarcelineVQ> modularity I guess, you can choose different templates if one isn't desirable, or even write one to reuse
17:25:48 <prsteele> Welkin: it would let your tests depend on the library code (and its dependencies)
17:25:55 <hpc> or write dozens of executables against one library
17:27:28 <Welkin> hpc: why would you do that?
17:28:01 * hackagebot mellon-core 0.7.0.3 - Control physical access devices  https://hackage.haskell.org/package/mellon-core-0.7.0.3 (dhess)
17:28:03 * hackagebot mellon-gpio 0.7.0.3 - GPIO support for mellon  https://hackage.haskell.org/package/mellon-gpio-0.7.0.3 (dhess)
17:28:05 * hackagebot mellon-web 0.7.0.3 - A REST web service for Mellon controllers  https://hackage.haskell.org/package/mellon-web-0.7.0.3 (dhess)
17:28:30 <hpc> nice lotr reference in that package name
17:29:01 <hpc> Welkin: if the binaries do different operations on similar things?
17:29:30 <hpc> Welkin: imagine all the thin wrappers on glibc that do nothing but remove a file or create a file or list a directory
17:29:56 <Welkin> I'm just building apps o.o
17:30:22 <prsteele> Welkin: at the very least you should have run-tests or something though  
17:30:33 <Welkin> I have never really written tests
17:30:58 <Welkin> this idea is new to me, but it sounds interesting
17:31:11 <prsteele> Welkin: check out Quickcheck if you do, it's amazing
17:31:12 <Welkin> I wonder how useful it is in practice to package up your app as a library
17:31:20 <Welkin> well, I know about quickcheck, I just never use it
17:42:09 <dedgrant> nornagon: Cycloperator?
18:09:48 <Squarism> how would i replace element "a" in Map.fromList [(1,Map.fromList [("a",23)])] using lenses?
18:21:32 <muyfine> Squarism: (Map.fromList [(1,Map.fromList [("a",23)])]) & at 1 . _Just . at "a" ?~ 20
18:21:51 <Squarism> muyfine, oh thanks
18:22:03 <Squarism> whats with the _Just part?
18:22:34 <muyfine> because the `at` returns a maybe value
18:22:50 <muyfine> its a prism
18:22:58 <lpaste> Ruben pasted ‚ÄúMapCrash‚Äù at http://lpaste.net/210978
18:23:15 <muyfine> (but I'm still trying to grok lenses)
18:23:57 <Squarism> muyfine, how would that be written using "over" syntax?
18:24:08 <shachaf> at k . _Just = ix k
18:24:44 <lpaste> rubenz revised ‚ÄúMapCrash‚Äù: ‚ÄúMapCrash‚Äù at http://lpaste.net/210978
18:24:53 <muyfine> not sure - guess you'd use the Map.insert's in place of at?
18:25:22 <shachaf> I'm at my phone, can't type much.
18:25:26 <muyfine> actually, probbably not
18:25:45 <muyfine> related... is there a monadic "over"?
18:26:04 <muyfine> or do I just used lifted with over?
18:26:12 <glguy> l ?~ x -- is -- set l (Just x)
18:26:14 <rubenz> Is this a bug in Data.Map? See lpaste
18:26:18 <shachaf> It's called id
18:26:46 <shachaf> Or traverseOf or mapMOf or something.
18:27:07 <shachaf> Oh, someone with a keyboard is here, I'll let him answer.
18:27:21 <muyfine> oh nice
18:27:36 <glguy> I'm on phone too
18:27:46 <glguy> lens is the library for phone users
18:28:00 <shachaf> Ah, never mind.
18:28:02 * hackagebot sdr 0.1.0.9 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.9 (adamwalker)
18:28:09 <EvanR> i should get IRC on my phone so i can get drunk and talk haskell on friday night like cool kids
18:28:30 <muyfine> yeah, mapMOf looks like it could work
18:28:34 <muyfine> for me
18:29:00 <glguy> :t (‚ÑÖ‚ÑÖ~)
18:29:01 <lambdabot> error: Variable not in scope: ‚ÑÖ‚ÑÖ~
18:29:25 <glguy> :t (%%~)
18:29:27 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
18:29:27 <EvanR> ‚ÑÖmonads?
18:29:38 <glguy> my phone has a‚ÑÖ key
18:29:54 <EvanR> ive never seen that character ever
18:30:09 <shachaf> care of glguy
18:32:15 <muyfine> glguy: awesome! perfect
18:32:22 <muyfine> thanks shachaf!
18:33:24 <glguy> thanchaf*
18:33:48 <Hafydd> I prefer "thachaf" (pron. "thatchaff").
18:42:19 <muyfine> so I have one issue with moving to %%~ (previously I had a pure function and was using %~)
18:42:42 <muyfine> the value I'm operating over is a maybe value, and I wanted to operate over that as well
18:42:50 <muyfine> I get this working http://lpaste.net/210989
18:43:16 <muyfine> but I'm now confused with how to operate on the maybe value in the monadic context
18:43:58 <muyfine> before when I wasn't using a monadic function, I had this: moField %~ (someFun <$>)
18:44:13 <muyfine> now I've got all that junk in there to deal with the Maybe value
18:44:56 <EvanR> the code in that paste should collapse, though you might need to use MaybeT
18:45:18 <muyfine> EvanR collapse how?
18:46:36 <rubenz> I found a bug in Data.Map. Who do I report this to?
18:47:40 <EvanR> muyfine: first things first, you can factor out the return to the top
18:48:01 <Gurkenglas_> :t ?myField %%~ traverse ?someFun -- muyfine
18:48:02 <lambdabot> (?someFun::a -> f b, ?myField::LensLike f s t (t1 a) (t1 b), Traversable t1, Applicative f) => s -> f t
18:48:29 <EvanR> maybe not
18:49:09 <Gurkenglas_> :t ?myField . traverse %%~ ?someFun -- (though of course this is more lensy)
18:49:10 <lambdabot> (?someFun::a -> f b, ?myField::(t1 a -> f (t1 b)) -> s -> f t, Traversable t1, Applicative f) => s -> f t
18:50:20 <Gurkenglas_> rubenz, https://github.com/haskell/containers/issues
18:50:36 <muyfine> Gurkenglas_nice! 
18:50:50 <muyfine> totally works
18:51:05 <Gurkenglas_> (I would use $ instead of %%~, but perhaps that's personal preference)
18:52:00 <Gurkenglas_> EvanR, how would he have factored out the return?
18:53:08 <EvanR> i see thats wrong now
18:53:37 <Gurkenglas_> You could use _Just instead of traverse if you want to be explicit, the same way some people use (.) or map or liftM instead of fmap
18:54:44 <rubenz> thanks
18:59:27 <Gurkenglas_> rubenz, try replacing fromAscList with fromList
19:00:25 <Gurkenglas_> > sort $ map show [1..10]
19:00:28 <lambdabot>  ["1","10","2","3","4","5","6","7","8","9"]
19:02:42 <rubenz> Gurkenglas_, thanks
19:02:45 <muyfine> Gurkenglas_ thanks a lot
19:07:58 <Squarism> how do i write a view lens expression for 23  in (Map.fromList [(1,Map.fromList [("a",23)])]) 
19:08:00 <Squarism> ?
19:08:39 <Squarism> ...and more over. Ive told me ill limit myselft to the over/view syntax when it comes to lenses. is that beeing to stringent?
19:11:12 <Gurkenglas> Reading between the lines, ekmett disapproves :P http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Combinators.html
19:12:27 <Gurkenglas> > preview (ix 1 . ix "a") $ M.fromList [(1,M.fromList [("a",23)])]
19:12:30 <lambdabot>  Just 23
19:12:44 <Squarism> thanks 
19:12:49 <Gurkenglas> > M.fromList [(1,M.fromList [("a",23)])] ^?! ix 1 . ix "a" -- no Just
19:12:51 <lambdabot>  23
19:12:59 <Squarism> i thought "at" was it?
19:13:10 <Squarism> or the common map lens
19:13:23 <Squarism> ix is yet another thing
19:13:32 <Gurkenglas> at gives you a Lens into a Maybe, so it sees a map as "infinitely" many slots that may be empty
19:13:43 <Gurkenglas> ix sees a map as finitely many slots that are all full
19:14:27 <muyfine> I have one last complicated lens expresion... 
19:14:43 <Gurkenglas> (And ix "a" goes over all slots named "a", which in this case may be 0 or 1, and preview makes that return Nothing if there's no slot, and ^?! makes it crash if there's no slot)
19:15:40 <Gurkenglas> Keep em coming :D
19:15:41 <Squarism> Gurkenglas, oh ok.. thanks
19:15:55 <muyfine> with a pure updating function, I have myField %~ ((someFun1 . someFun2 <$>) <$>)
19:16:08 <muyfine> trying to figure out how to convert that to a monadic version
19:16:24 <muyfine> I need two traverse's?
19:16:37 <Gurkenglas> with a pure updating function, that's myField . traverse . traverse %~ someFun1 . someFun2
19:16:50 <muyfine> myField %%~ traverse . traverse (someFun1 . someFun2)?
19:17:09 <Gurkenglas> myField %%~ (traverse . traverse) (someFun1 . someFun2)
19:17:13 <Welkin> lol, myFeidl
19:17:14 <muyfine> ahh
19:17:16 <Gurkenglas> (my last two lines went untested)
19:17:27 <jvanbure> So i wanted to parse a language with nested comments using megaparsec, however it is extremely slow to parse LARGE comments, so i wanted to use alex or some other lexer-like thing to speed up the process; however, nested comments are obv. not a regular language, so what are the alternatives?
19:18:02 <zyhn> jvanbure: alex can do nested comments
19:18:22 <jvanbure> nested block comments?
19:18:31 <jvanbure>  / how
19:18:32 <muyfine> Gurkenglas ahh - so it doesn't like combinaing the two monadic functions with .
19:18:41 <muyfine> I tried >=>
19:19:18 <zyhn> jvanbure: using the monadic interface, you can remember how 'deep' you are
19:20:41 <muyfine> Gurkenglas never mind - >=> worked!
19:20:44 <muyfine> thanks!
19:21:40 <jvanbure> @zyhn that's so deep. thanks!
19:21:40 <lambdabot> Unknown command, try @list
19:21:40 <Gurkenglas> (One to too many on http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Combinators.html btw)
20:18:36 <Phosphero> trying to wrap my head around how to handle an update in Persistent - if I call 'runDb replace ...', the return type is ReaderT backent m (), where the empty tuple to signify a successful update right? Documentation says that the result is undefined if "such a record does not exist". How do I handle that scenario? if I write "case result of \n () -> ... \n  _ -> throwError err404" in my api, it says the second case 
20:18:36 <Phosphero> is redundant
20:19:32 <timcat> hi folks, attempting to build a pet project in haskell. quick syntax question, if you don't mind. i'm playing with the snap framework, and in the tutorial this appears in the code <|>. what is that? searching for it has been useless
20:19:38 <Phosphero> https://www.stackage.org/haddock/lts-7.0/persistent-2.6/Database-Persist-Class.html#v:replace for docs
20:19:43 <timcat> example here https://github.com/snapframework/snap-templates/blob/master/project_template/barebones/src/Main.hs
20:19:53 <lispy> @hoogle (<|>) -- timcat
20:19:56 <lambdabot> Prelude undefined :: forall (r :: RuntimeRep) . forall (a :: TYPE r) . HasCallStack => a
20:19:56 <lambdabot> Text.Printf errorShortFormat :: a
20:19:56 <lambdabot> Text.Printf errorMissingArgument :: a
20:20:03 <lispy> Opps, that didn't work!
20:20:10 <lispy> @hoogle <|>
20:20:10 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
20:20:10 <lambdabot> Text.Parsec (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
20:20:10 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
20:20:18 <lispy> timcat: Do you know about hoogle?
20:20:25 <timcat> no
20:20:27 <lispy> timcat: https://www.haskell.org/hoogle/
20:20:39 <timcat> awesome ok this is what i want
20:20:42 <timcat> thx
20:20:49 <lispy> timcat: any time
20:23:09 <rubenz> How to write a function that gets all (non necessarily consecutive) sublists of a (possibly) infinite list?
20:23:38 <shachaf> > subsequences [1..]
20:23:41 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
20:24:06 <shachaf> Well, I guess that only gets the finite subsequences...
20:24:54 <rubenz> hmm seems to work with infinite lists too!
20:24:57 <rubenz> thanks
20:25:07 <rubenz> oh right
20:25:22 <lispy> timcat: if you use hoogle a lot there is a way to make your browser search it. Do an example query, take that url and replace your query with %s. That's the "query string".
20:30:40 <Welkin> or just use duckduckgo
20:30:50 <Welkin> then you can do: !h <search term>
20:30:52 <Welkin> for hoogle
20:30:57 <Welkin> !hayoo for hayoo
20:30:59 <lispy> neat, I didn't know that
20:31:02 <Welkin> !hackage for hackage
20:31:46 <timcat> nice, i'll give that a shot
20:39:12 * hackagebot mellon-web 0.7.0.3 - A REST web service for Mellon controllers  https://hackage.haskell.org/package/mellon-web-0.7.0.3 (dhess)
20:39:12 * hackagebot sdr 0.1.0.9 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.9 (adamwalker)
21:02:38 <Welkin> why am I getting this error with cabal and nix?
21:02:39 <Welkin> cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.24.0.0, now Cabal-1.22.4.0). Additionally the compiler is different (was ghc-8.0, now ghc-7.10) which is probably the cause of the problem.
21:03:09 <Welkin> even if I explicitly specify ghc 8.0.1 (and that is what I get when I run ghc in the nix shell)
21:05:14 <Welkin> wtf?
21:05:27 * Clint squints.
21:05:30 <Welkin> I just deleted my system's ~/.ghc/ and ~/.cabal/
21:05:37 <Welkin> and now in nix-shell it says "cabal not found"
21:05:38 <Welkin> ...
21:05:43 <Welkin> that should not happen
21:09:18 <slack1256> Welkin: are you on nixos or in linux with the nix program bootstraped?
21:11:32 <angryShiva> ?
21:11:48 <Welkin> slack1256: reflex-platform installed nix for me on macos
21:18:43 <angryShiva> Sup guys!
21:18:48 <angryShiva> Anyone free!
21:18:50 <angryShiva> ?
21:19:08 <angryShiva> need a little bit of help with happstack
21:21:52 * hackagebot mellon-web 0.7.0.3 - A REST web service for Mellon controllers  https://hackage.haskell.org/package/mellon-web-0.7.0.3 (dhess)
21:21:52 * hackagebot sdr 0.1.0.9 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.9 (adamwalker)
21:22:29 <slack1256> angryShiva: state you problem, maybe someone will know
22:15:24 <xuxu> this file seems to have a lot of imports https://hackage.haskell.org/package/distributed-process-0.6.1/docs/src/Control-Distributed-Process-Internal-Primitives.html#receiveWait
22:15:46 <xuxu> didn't mean to have the anchor tag at the end
22:37:25 <xuxu> nevermind
22:38:08 <xuxu> it's a total of 29 module imports. the author was being explicit about which functions to import from each module though, and that was the first time i came across this
23:29:05 <dmj`> is there a forM_ (or similar) that operates on both the key and value of a Map, I'd like to avoid additional allocations w/ toList
23:29:54 <shachaf> traverseWithKey
23:30:22 <shachaf> Not sure whether there's an _ variant, but you can implement it. Or get it from lens.
23:31:50 * hackagebot wire-streams 0.1.0.0 - Use cereal or binary with io-streams.  https://hackage.haskell.org/package/wire-streams-0.1.0.0 (winterland)
23:34:23 <dmj`> shachaf: thank you, suppose I can just void it to make traverseWithKey_
23:34:49 <dmj`> @typ \f -> void . Data.Map.traverseWithKey f
23:34:50 <lambdabot> Applicative f => (k -> a -> f b) -> M.Map k a -> f ()
23:36:26 <dmj`> shachaf: this is great, and efficient, thanks
23:37:09 <shachaf> But that's not necessarily do great because it can build an intermediate structure.
23:37:12 <shachaf> so
23:38:03 <shachaf> You might be better off writing something yourself with e.g. foldmapWithKey
23:38:34 <shachaf> lens has various implementations of this if you want to see the details
23:42:18 <dmj`> shachaf: ah, yea, traverse does build up a new structure :/
23:42:34 <dmj`> @typ Data.Map.foldrWithKey (\k v io -> print (k,v) >> io) (pure ()) (fromList [(1 :: Int, "fo" :: String)])
23:42:35 <lambdabot> IO ()
23:42:45 <dmj`> I need to accumulate effects
23:43:16 <jle`> i wonder if the intermediate list would be fused away anyway
23:44:06 <jle`> if you just did mapM_ f . M.toList
23:44:10 <dmj`> jle`: the profiler in chrome shows allocations for me when I forM_ (M.toList) ..
23:45:35 <dmj`> jle`: o/ :) 
23:45:42 <dmj`> foldlWithKey' might be the ticket
23:45:56 <dmj`> ideally I'd have data structures that can lookup in O(1)
23:45:59 <jle`>  \o
23:48:56 <dmj`> shachaf: would the lens implementation be any more efficient?
23:51:11 <shachaf> Maybe? I don't remember.
23:51:27 <shachaf> I vaguely remember writing it, https://github.com/ekmett/lens/issues/177
23:51:37 <shachaf> Or at least doing something with it.
23:51:38 <shachaf> This was a while ago.
23:53:01 <shachaf> It's probably better than any foldl/foldr if you don't want things to be reassociated.
23:55:53 <shachaf> You can try it easily enough, since you're already profiling.
23:57:03 <dmj`> shachaf: yea, client side profiling consists of eye-balling the record allocation timeline in chrome's profiler
23:57:55 <dmj`> shachaf: suprisingly, the hashtables package (compiled w/ -fportable) had far more allocations than Map
