00:03:23 <YellowOnion> pavonia, yesterday I was here trying to ask the exact question of how to get a kdTree to work and someone suggested typeclasses, if you have a better idea how perserve the polymoprhism I'm all ears.
00:06:01 <xuxu> i was so close!
00:06:04 <xuxu> Node 3 (Node 2 (Node 1 EmptyTree EmptyTree) EmptyTree)
00:06:09 <pavonia> YellowOnion: I can see two ways: 1) Remove the Posibitable from the type and give it only to all functions that use this data type (recommended). 2) Use a forall or GADT in the type such that the Positionable is a constraint of the constructor rather than of the whole type
00:06:14 <xuxu> actual result: Node 3 (Node 2 (Node 1 EmptyTree EmptyTree) EmptyTree) EmptyTree
00:06:28 <pavonia> *Positionable
00:06:38 <xuxu> ReinH: thanks for encouraging me to step through
00:07:25 <xuxu> http://lpaste.net/184480 and http://lpaste.net/185837 if anyone needs context
00:07:38 * hackagebot hans 3.0.1 - Network Stack  https://hackage.haskell.org/package/hans-3.0.1 (TrevorElliott)
00:07:38 * hackagebot lentil 1.0.3.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.0.3.1 (fffaaa)
00:08:25 <pavonia> YellowOnion: The former is bette, IMHO, because using constructors with explicit foralls of this type can make using the constructor e.g. in patterns trickier
00:08:33 <xuxu> not sure where i missed the extra EmptyTree
00:10:26 <xuxu> ah, i think it was line 27 in my reasoning
00:10:31 <YellowOnion> pavonia, right so have it that I can technically build the tree with illegal points, but I can't perform any operations on it because of that.
00:10:39 <xuxu> this was mind blowing
00:10:50 <xuxu> who originally came up with this algorithm?
00:11:25 <xuxu> maybe it's not that mindblowing the more you think about it :)
00:11:39 <xuxu> i don't know, but i'm satisfied!
00:12:03 * xuxu carrys on 
01:13:08 <xQuasar> @where lyah
01:13:09 <lambdabot> http://www.learnyouahaskell.com/
01:13:43 <xQuasar> In Soviet Russia, Haskell learns a you.
01:14:03 <Insanity_> héhé
01:14:09 <Insanity_> it's actually quite a good book :-)
01:14:34 <xQuasar> heard about it a lot.
01:15:21 <Insanity_> Going through it atm
01:15:42 <xQuasar> one time i was in a channel asking about programming books and everybody jumped into recommending this book to me. they treat it like the Bible.
01:16:04 <Insanity_> I wasn't aware of that ^^
01:16:30 <Insanity_> Treating a book like the "bible" in software, I'd have guessed that would be code complete2
01:17:34 * hackagebot hpack 0.15.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.15.0 (SimonHengel)
01:18:35 <xQuasar> excuse me i'm that script kiddie type of guy who grew up reading about dope python scripts that did crazy hacking and stuff. does Haskell allow such things? why haven't i heard hackers using haskell to ddos or crack stuff?
01:18:47 <xQuasar> i wanna learn haskell but for hacking purposes.
01:19:39 <oherrala> xQuasar: Python and Haskell are just tools
01:20:14 <xQuasar> oherrala: so python is easier for that stuff? tell me where in real world companies are using haskell? isn't it just for abstract entertainment purpose?
01:20:17 <Insanity_> True, I agre with oherrala
01:20:34 <Insanity_> furthermore, people who are into security often *use* the tools, they don't create them from scratch
01:20:48 <Insanity_> The use a suite of things, such as the ones on the Kali distro
01:21:17 <oherrala> xQuasar: Python is more common. So if you write stuff in Python you'll also might get more people to contribute
01:22:18 <oherrala> I have done some PoC for vulnerabilities and it's much more easier with Python because other's can much easier understand my code
01:22:35 <xQuasar> yeah. makes sense.
01:23:17 <xQuasar> https://github.com/ryanpbrewster/haskell
01:23:18 <xQuasar> cool
01:23:49 <oherrala> but technically Haskell might be better
01:24:01 <xQuasar> what made you love haskell? is haskell purely functional (i'm still confused)?
01:25:15 <oherrala> I love the high level of abstraction and the fact that if it compiles it usually works
01:25:46 <xQuasar> oherrala: do you use it for work?
01:26:11 <oherrala> not yet :)
01:26:30 <oherrala> I have written some small snippets for my work using Haskell
01:26:53 <oherrala> but it's difficult to do team work with language so alien to rest of the developers :/
01:28:28 <xQuasar> oherrala: is haskell difficult to learn?
01:29:07 <oherrala> I'm probably biased, but I have been learning 10 years and I still keep learning :D
01:29:38 <oherrala> Haskell is not difficult, it's just different from everything you have learned before
01:29:41 <xQuasar> oherrala: omg. i feel ashamed.
01:29:54 <oherrala> the difficult part is getting your brain around the functional paradigm
01:30:11 <xQuasar> i have had opportunity to learn programming for 13 years now but i still am a noob.
01:30:20 <oherrala> but when the pieces start to come together it's really enjoyable
01:30:27 <xQuasar> never gotten into it. fml.
01:30:38 <xQuasar> oherrala: i will buy that book now
01:31:22 <xQuasar> oherrala: i will practice for a year and come back. thank you. bye.
02:07:02 <jakub_> Monad transformers take a single monad and produce a monad is there any concept of taking 2 distinct monads and packing them together to produce a single monad?
02:07:33 <jakub_> the two distinct monads are allowed to inhabit some common class
02:08:39 <tdammers> jakub_: pack them together *how*?
02:09:14 <tdammers> most monad transformers are transformer-flavored variations of such simpler monads, and stacking transformers is a way of "packing" them
02:09:17 <jakub_> i am interested in learning what the possibilities are
02:09:35 <tdammers> e.g., you can pack StateT on top of IO, producing a monad that is both a MonadState and a MonadIO
02:09:52 <dysfun> well transformers, you just keep stacking the effects until you get what you want
02:10:11 <jakub_> i get how transformers work
02:10:38 <dysfun> there are only two other approaches i know of
02:10:45 <dysfun> one is the Free monad
02:10:50 <dysfun> and the other is the Freer monad
02:11:13 <jakub_> but say i have two monads that build on top of IO but are incompatible... i would like to create a monad that lifts the actions within the two monads to their "composition"
02:11:36 <jakub_> the monads arent transformers
02:11:47 <dysfun> incompatible how?
02:12:16 <jakub_> they are blackboxes and do not expose the fact they are simple wrappers around IO
02:12:44 <jakub_> other than some terminal unwrapping
02:12:59 <wolf> hello world
02:13:03 <dysfun> do they have MonadIO instances?
02:13:21 <jakub_> dysfun: possibly
02:13:28 <dysfun> that might be an option then
02:13:34 <tdammers> well, in that case, the problem you want to solve is that you have actions of types m a and n a, and you want functions that give you m a -> t a and n a -> t a for some monad t?
02:13:58 <jakub_> tdammers: i guess
02:14:18 <tdammers> in that case, there must be some monad-specific way of unwrapping your monads
02:14:25 <jakub_> lets say that i do :) i am really looking for any pointers what to investigate
02:14:50 <tdammers> it would probably help to have some concrete examples
02:14:54 <Guest19720> err guys, sry for interrupting, I have a code: (length y) - (length (foldr delete y x)), can anyone find a way to optimize it?
02:15:02 <tdammers> because in some cases, the incompatibility is intentional (e.g. STM)
02:15:03 <jakub_> tdammers: there is, but unwrapping kills some very important things
02:15:26 <tdammers> yes, that's what I was hinting at
02:15:44 <jakub_> tdammers: i think the incompatibility here is just a result of missing awareness of the two pieces of code
02:15:45 <tdammers> you can marshal STM to IO through atomically, but obviously this loses atomicity, which is *by design*
02:16:24 <tdammers> with other things, say State, you can, with some effort, carry the monad's plumbing along across wrapping/unwrapping, but it requires some extra work
02:17:01 <jakub_> i might be able to adjust the two pieces of code, but i would like to keep it to minimum, what conceptual steps would i need to take to allow the two monads to be composed into one?
02:17:33 <jakub_> do i need to change the monads into transformers?
02:17:35 * hackagebot ChasingBottoms 1.3.1.1 - For testing partial and infinite values.  https://hackage.haskell.org/package/ChasingBottoms-1.3.1.1 (NilsAndersDanielsson)
02:18:02 <simon> Guest19720, 'foldr delete y x' removes ys from x?
02:25:13 <simon> Guest19720, 'length y - foldr (\e c -> if e `Set.member` xset then c else c+1) 0 x where xset = Set.fromList x'?
02:25:35 <NickHu> tdammers: Are you talking about the "atomically" function?
02:25:47 <Guest19720> Guest19720, going to try it now
02:25:50 <Guest19720> thx
02:25:57 <Guest19720> simon*
02:25:58 <NickHu> Guest19720: You can undistribute length 
02:26:05 <NickHu> I think
02:26:17 <NickHu> oh no wait I'm totally wrong ignore me
02:26:20 <simon> Guest19720, where Set is Data.Set.
02:26:59 <JeffWolfe> hello
02:27:36 <simon> whoops
02:28:03 <simon> Guest19720, if e `Set.member` yset ...
02:29:24 <Guest19720> okay, so it's slower now
02:29:50 <Guest19720> basically the length of those lists are <= 4, converting to Set has serious overhead I thiknk
02:29:57 <Guest19720> @simon
02:29:57 <lambdabot> A public man must never forget that he loses his usefulness when he as an individual, rather than his policy, becomes the issue.
02:30:24 <simon> Guest19720, right. I was assuming x and y grew asymptotically.
02:30:52 <Guest19720> yeah, it's normally the right approach, but not suitable here
02:31:31 <Guest19720> actually if it's possible to reduce the amount of memory usage, it will be a lot faster
02:31:43 <Guest19720> I guess delete keeps generating new list =_=
02:33:07 <saulzar> Does anyone know if something has changed in ghc 8.0.1 with quasi-quoters .. I'm trying to use singletons with    $(singletons [d|  ..... |] )  and just getting a parse error on the line of the |]
02:33:38 <saulzar> I have TemplateHaskell and QuasiQuotes language extensions on..
02:34:44 <simon> Guest19720, length (foldr delete y x) = foldr (\e c -> if e `elem` y then c else c+1) 0 x
02:36:22 <[k-> count the number of notElem y in just a single fold?
02:37:24 <simon> Guest19720, you could also try foldl' (\c e -> if e `elem` y then c else c+1) 0 x
02:37:50 <simon> Guest19720, https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#v:foldl-39-
02:37:53 <Guest19720> I have to delete the found element
02:37:55 <NickHu> Isn't length an O(n) operation on standard lists?
02:38:11 <simon> Guest19720, why do you have to delete the found element, if all you do is count the remaining elements?
02:38:18 <Guest19720> otherwise, same element might be counted for more than once
02:39:19 <simon> Guest19720, does 'foldr delete y x' remove duplicates?
02:39:40 <Guest19720> yes
02:40:29 <saulzar> Ok, I figured it out - the |] needed to be indented... 
02:41:08 <bollu> how do I learn recursion schemes?
02:41:22 <bollu> I know that it's a "silly" question, but I have no idea where to begin with the library
02:41:36 <simon> NickHu, yes.
02:41:58 <simon> NickHu, O(1) if you know the list's length is <= 4. ;-)
02:42:22 <NickHu> bollu: I'm trying to start on this too. I've begun by looking at and trying to understand how Foldable and Traversable work
02:42:42 <NickHu> iirc Foldable demonstrates a catamorphism
02:42:53 <NickHu> simon: How does the compiler figure that out?
02:43:07 <Guest19720> "O(1) if you know the list's length is <= 4" yeah. Indeed, but I think it's a bit unsuitable to use O here?
02:43:07 <simon> NickHu, it doesn't.
02:43:20 <simon> Guest19720, so foldr delete [1,2,3] [1,2,1,4,4] = [4]?
02:43:28 <NickHu> oh I see what you mean
02:43:46 <Guest19720> = [3]
02:44:05 <Guest19720> simon,
02:44:43 <bollu> uhh, what's a catamorphism
02:44:44 <bollu> ?
02:44:58 <simon> bollu, https://wiki.haskell.org/Catamorphisms
02:45:18 <bollu> simon: thank you :)
02:45:34 <NickHu> It's something that reduces structure
02:46:01 <NickHu> Like a fold (takes a Foldable a and turns it into an a)
02:46:06 <NickHu> Lists are Foldable
02:50:40 <Guest19720> any idea?
02:50:53 <Guest19720> I had spent hours on this..
02:51:00 <NickHu> Question: is a Traversable like a hylomorphism?
02:53:37 <Cale> NickHu: A hylomorphism is a function definable by unfolding a tree structure from some seed value (an anamorphism) and then folding that tree structure again to produce the result (a catamorphism)
02:53:48 <Cale> NickHu: I don't see how that describes Traversable
02:54:04 <NickHu> Because a Traversable is essentially something that can be mapped over right?
02:54:08 <Cale> (which isn't even a function, but a typeclass -- but none of its methods really seem to match that description)
02:54:42 <NickHu> You're right - I should've asked if traverse from Traversable was an example of hylomorphism
02:55:14 <Cale> What does it unfold?
02:55:52 <sshine> Guest19720, so 'length y - length (foldr delete y x)' subtracts the number of non-duplicate elements of y that aren't contained in x, from y?
02:56:40 <sshine> Guest19720, or rather, the number of elements of y that aren't contained in x, discounting duplicates, from y.
02:58:05 <Guest19720> basically, deletes elements of y that contains in x, but elements in x can only be matched once
02:58:20 <Guest19720> function [1,2,1] [1,1,1] == 2
02:59:30 <NickHu> Cale: Hmm, I kinda thought that traverse was a bit like fmap, but there's clearly a hole in my understanding here
02:59:46 <Cale> NickHu: factorial is the canonical example of a hylomorphism, because you can think of it as  foldr (*) 1 . unfoldr (\n -> if n > 0 then Just (n,n-1) else Nothing)
03:00:41 <Cale> i.e. you're unfolding a list from the argument n, and then folding it again to produce the result
03:00:48 <[k-> Given [1,2,3] and [1,2,1,4,4], the result is [3]. So basically, you are trying to find the elements in x that are not found in y. Correct?
03:01:28 <NickHu> Cale: Do the types in that example line up?
03:01:43 <NickHu> How can you do foldr (*) 1 over a Maybe Integer
03:01:59 <Cale> :t foldr (*) 1 . unfoldr (\n -> if n > 0 then Just (n,n-1) else Nothing)
03:02:01 <lambdabot> (Ord c, Num c) => c -> c
03:02:04 <ertesx> NickHu: it's a list, not a Maybe
03:02:09 <Cale> :t unfoldr
03:02:11 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
03:02:30 <ertesx> NickHu: the Maybe decides when unfoldr stops with the empty list
03:02:53 <NickHu> Oh I see; when they taught us Haskell they gave us some weird alternative definition of unfoldr
03:03:11 <ertesx> > unfoldr (\x -> if x < 10 then Just (x^2, x + 1) else Nothing) 0
03:03:14 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
03:04:01 <ertesx> NickHu: unfoldr is exactly dual to foldr:  foldr :: (Maybe (a, s) -> s) -> [a] -> s
03:04:34 <NickHu> How do you define duality between haskell functions?
03:04:54 <NickHu> Also if anyone is interested, this is the unfoldr they taught us:
03:04:57 <NickHu> > unfoldl :: (a -> Bool) -> (a -> (a,b)) -> a -> [b]
03:04:59 <NickHu> > unfoldl p f x = if p x then [] else unfoldl p f y ++ [z]
03:04:59 <lambdabot>  error:
03:04:59 <lambdabot>      • Variable not in scope:
03:04:59 <lambdabot>          unfoldl :: (a1 -> Bool) -> (a1 -> (a1, b1)) -> a1 -> [b1]
03:05:01 <NickHu> > where (y,z) = f x
03:05:02 <lambdabot>  <hint>:1:15: error:
03:05:02 <lambdabot>      parse error on input ‘=’
03:05:02 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:05:05 <lambdabot>  <hint>:1:1: error: parse error on input ‘where’
03:05:09 <tdammers> NickHu: yes
03:06:43 <NickHu> Do you get duality by just flipping all the arrows?
03:08:16 <Cale> NickHu: Usually that's the idea, yeah.
03:08:53 <NickHu> Does duality imply anything about inverses?
03:09:39 <Cale> (It can get a bit subtle because which arrows you're considering part of the definition being flipped can have some choice to it)
03:10:00 <Cale> and, well...
03:11:24 <Cale> There's cases where you're doing stuff like replacing a coproduct (Either) with a product ((,))
03:11:47 <ertesx> NickHu: in general not about inverses, but more about structural similarity
03:12:25 <ertesx> the categorical notions of inverses are isomorphisms and bimorphisms
03:12:38 <qknight> https://gist.github.com/qknight/c320591654ff0e122769b8fe8000d3d7 <- anyone an idea what cabal wants to tell me?
03:12:53 <NickHu> I don't really know what a bimorphism is, but I can kinda guess what an isomorphism is from group theory
03:13:09 <qknight> cabal says: abort because of serious configure-time warning from Cabal        but i don't see which
03:13:49 <ertesx> qknight: probably line 45
03:14:31 <ertesx> qknight: i think you can tell cabal2nix to ignore that warning somehow
03:14:39 <ertesx> (if it's indeed correct to do so)
03:14:40 <Cale> NickHu: Given objects X and Y, an isomorphism between them consists of a pair of arrows f: X -> Y and g: Y -> X such that g . f = id_X and f . g = id_Y
03:15:05 <ertesx> qknight: try --jailbreak
03:15:12 <NickHu> Arrows are the same thing as morphisms right?
03:15:18 <Cale> yes
03:15:34 <qknight> thanks
03:15:57 <ertesx> NickHu: bimorphisms are a weaker notion
03:16:09 <Cale> "Bimorphism" is a somewhat unpopular term for an arrow which is both an epimorphism and a monomorphism.
03:17:03 <ertesx> Cale: unpopular?  why?
03:17:10 <Cale> It's more common to just hear people say "monic epic"
03:17:20 <Cale> I don't know why in particular it's not more popular
03:17:26 <ertesx> yeah, "epic morphism" has that ring to it =)
03:17:36 * hackagebot result 0.2.4.0 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.2.4.0 (srijs)
03:17:53 <NickHu> I really need to read that paper about Category theory.. I always feel like I should learn Group theory properly whenever I get to start on Category theory
03:18:18 <ertesx> NickHu: group theory is mostly a special case…  there is no need to learn it first
03:18:27 <Cale> Which paper about category theory?
03:18:28 <NickHu> I only attended some lectures that were offered to the maths students but I didn't get the full course
03:18:39 <NickHu> Well, I say paper, it's more of an intro text
03:18:46 <ertesx> NickHu: i found that having applications makes learning CT *a lot* easier
03:18:46 <Cale> NickHu: I would recommend Awodey's book "Category Theory"
03:18:53 <NickHu> "Elements of Basic Category Theory"
03:19:22 <ertesx> qknight: i'd like to know if it helped
03:19:34 <ertesx> because i haven't encountered that problem myself yet
03:19:44 <NickHu> Lots of people say that you lose the elegance of category theory when you look at all these proofs of group theory theorems and you don't really get the elegance because you don't know the underlying group theory
03:20:12 <NickHu> It's not like I don't want to learn group theory either, it's just time..
03:23:17 <ertesx> NickHu: if you want to learn group theory, learn it…  it's one of those theories that you can apply immediately
03:23:32 <ertesx> to pretty much everything
03:23:58 <NickHu> Yeah, I'm taking the free online Harvard lectures
03:24:18 <NickHu> But I don't really have time for much of anything that isn't already inside my degree during term time though
03:26:02 <NickHu> Do you guys think it's important or in any way better to learn it before Category theory though?
03:26:26 <ertesx> NickHu: in the context of haskell and CT you'll be interested mostly in monoids and homomorphisms, which you can learn very quickly
03:27:11 <NickHu> I'm interested in Category theory even without the context of Haskell though - I'd really like to learn as much of it as possible
03:27:37 <ertesx> NickHu: as you go deeper into GT, you mostly come up with more special structures (e.g. groups), combine them (semirings, fields, etc.), fancier combinations (vector spaces, affine spaces, etc.), helper notions (cosets, etc.)
03:27:43 <ertesx> but it all boils down to fancy monoids
03:27:52 <NickHu> I don't see it as a means to the end of becoming a better Haskell programmer; maybe even the inverse is true
03:28:16 <Cale> NickHu: There is this idea that CT should be put off until you have all these other areas of mathematics under your belt so that it can be appreciated as an abstraction for what goes on everywhere else. That's a valid perspective, but from another perspective, category theory can be viewed as simply a sibling of group theory and other algebraic areas.
03:28:17 <ertesx> monoids and morphisms
03:29:12 <ertesx> NickHu: you can also learn both at the same time…  CT as a language to talk about GT, GT as an interesting instance of CT concepts
03:29:16 <ertesx> they go hand in hand
03:29:28 <NickHu> I think I'll read the Elements of Basic Category Theory paper when I get some spare time
03:29:38 <NickHu> I do have the Awodey book on my reading list, too
03:30:01 <NickHu> But it's targeted at graduate students (iirc) so I don't see much harm in putting it off for now
03:30:05 <Cale> NickHu: Groups occur naturally whenever you have a category because the isomorphisms from an object X to itself in any category form a group (the automorphism group of X)
03:30:19 <Cale> and this can be seen as an explanation for why group theory is so successful
03:30:49 <eklavya> what was the type of main before Monads came along?
03:31:07 <Cale> eklavya: [Response] -> [Request]
03:31:20 <ertesx> wasn't there an IO before monads?
03:31:23 <Cale> no
03:31:27 <eklavya> hehe what?
03:31:54 <eklavya> you mean [Request] -> [Response]
03:31:58 <eklavya> right?
03:31:58 <Cale> no
03:32:08 <Cale> The responses come back as input to your function.
03:32:13 <ertesx> eklavya: your main function sends a request (output) and gets a response as the next list item (input)
03:32:30 <ertesx> heavily relying on laziness of course
03:32:59 <Cale> It wasn't terribly practical, but at that stage in the language's life, nobody was even trying to do very practical things with Haskell.
03:33:21 <eklavya> wow
03:34:01 <Cale> If you're interested in the details, look at one of the Haskell Reports before 1.3
03:34:02 <NickHu> There's a great video where Simon Peyton Jones draws some graph of interesting over usefullness or something like that
03:34:17 <NickHu> Less useful => More fun or something
03:34:39 <bjs> NickHu: it was comparison about safety vs usefulness
03:34:45 <NickHu> Oh that was it
03:34:53 <ertesx> i can't imagine that the [Response] -> [Request] pattern was fun
03:35:03 <ertesx> IO is fun
03:35:14 <Cale> http://haskell.org/definition/haskell-report-1.2.ps.gz
03:35:17 <eklavya> amazing where Haskell is now
03:35:26 <eklavya> really
03:35:27 <Cale> see page 124 
03:36:01 <Cale> (and the following)
03:36:16 <Cale> readFile :: String -> FailCont -> StrCont -> Dialogue
03:36:26 <ertesx> the really interesting thing is that haskell has become this language that everybody knows…  when i tell people that i'm a haskell programmer, they know what i'm talking about
03:36:41 <ertesx> a few years ago that used to be very different
03:36:45 <eklavya> ertesx: not everywhere
03:37:20 <tdammers> haskell does have a bit of a reputation by now
03:37:36 <ertesx> not necessarily a positive one though
03:40:09 <eklavya> I don't know why, it's pleasant to use even without the more typy parts
03:40:15 <eklavya> so easy to write correct code
03:40:31 <ertesx> haskell seems to be a lot of people's procrastination language…  for some reason solving project euler problems in haskell seems more appealing that using it seriously
03:41:00 <NickHu> It also kinda has a reputation of death under a mountain of memory usage because laziness from what I recall
03:41:06 <minad> Hi, how does this hackage haddock update work? Is this running from time to time or do I have to do that myself?
03:41:35 <Cale> minad: You're talking about when you upload a package?
03:41:38 <Insanity_> That is the case for me ertesx xD
03:41:53 <minad> Cale: yes
03:41:56 <Insanity_> Well, I do the problems of projecteuler to practise, as I'm learning haskell.
03:41:56 <ertesx> minad: wait 15 minutes, if they haven't been built, upload yourself
03:42:14 <Cale> minad: It should eventually generate the documentation for you, but if you're impatient, you can upload documentation.
03:42:32 <minad> Cale: it didn't generate for a few days now
03:42:35 <dontdieych> How can I read(parse) string "[1..3]" into ([1, 2, 3] :: Int) ?
03:42:39 <Cale> which package?
03:42:46 <minad> http://hackage.haskell.org/package/writer-cps-mtl
03:42:57 <Cale> dontdieych: you'd have to write a custom parser for that
03:43:16 <dontdieych> Cale: any library for that?
03:43:35 <ertesx> minad: yeah, hackage does that sometimes…  personally i just upload docs myself using this process: https://github.com/esoeylemez/skeleton/blob/skeleton/Makefile#L16
03:43:41 <Cale> Well, you might be able to use haskell-src-exts, though that's kind of overkill
03:43:48 <Cale> heh
03:43:50 <ertesx> minad: lines 16-41
03:43:57 <NickHu> I don't really feel like Euler problems are fantastic to learn about programming
03:44:11 <ertesx> minad: while it uses nix, it's easy to see the individual steps and do them without nix
03:44:24 <minad> ertsex: thx!
03:44:40 <dontdieych> Cale: Thanks, Cale. I should try other solutions.
03:44:43 <Insanity_> NickHu they aren't for something serious. For learning the basics of a new language I think it's quite good
03:44:49 <pavonia> dontdieych: Parsec is quite popular
03:44:49 <Cale> dontdieych: But also, there are packages like attoparsec
03:44:57 <Cale> Or yeah, parsec itself
03:45:14 <NickHu> I have some maths friends who want to "learn programming", and they spend lots of time trying to solve Euler problems in python, while I'm trying to tell them to read a book on programming and learn about invariants etc.
03:45:22 <Insanity_> Get a grisp of the syntax and some of the features. It often makes you look up more features of the language itself. Or whilst your learning the language, you discover a new way of solving a problem you solved before in a worse way
03:45:33 <NickHu> Yeah, I get that
03:45:33 <aupiff> I'm confused about "strong normal form" in CL. I'm going through a book by Hindley and there he says that [x,y,z].y(xz) is only in weak normal form.
03:45:40 <Insanity_> Yeah, if they need to learn _programming_
03:45:42 <Cale> http://cale.yi.org/reflex/ParseHaskell/ParseHaskell.jsexe/ -- a demo of haskell-src-exts (parsing a module rather than an expression though), with reflex-dom taking care of the dynamic updating :)
03:45:44 <ertesx> Insanity_: you don't learn the basics of haskell with PE problems
03:45:47 <NickHu> I don't think that's very helpful for non-programmers though
03:45:54 <Insanity_> I read a book on haskell ertesx
03:46:04 <Insanity_> And I practise some of the things I read about, with the problems
03:46:24 <Insanity_> and as I've got more experience in other languages, it also offers me of a way to compare between languages that I've used
03:46:26 <aupiff> I've calculated that [x,y,z].y(xz) == S(K(SB))(S(KK)(SB(KI))), where B = (S(KS)K)
03:46:42 <JeffWolfe> hello guys
03:46:56 <sshine> ertesx, monoids are just fancy semigroups!
03:47:41 <Cale> dontdieych: If you erase what's in the box and put in something like  x = [1..10]  you'll see that the part representing that expression is this data structure  EnumFromTo (Lit (Int 1)) (Lit (Int 10))
03:47:48 <ertesx> sshine: sure, but you have to draw the line somewhere =)
03:47:54 <NickHu> Insanity_: I'd really recommend learning about structural induction. We focused on it a lot in my course and I've found it immensely useful
03:48:03 <ertesx> i consider monoids to be the basic concept of group theory
03:48:18 <aupiff> this is the definition of strong normal form given: http://imgur.com/a/2rUCq
03:48:37 <NickHu> sshine: Isn't there something called a semigroupoid which is a semigroup without the associativity?
03:48:39 <intothem2untains> Can I convert a string to a constructor of a specific type? Like: data Player = Green | Purple | Orange, and then f "Orange" -> Orange
03:48:58 <ertesx> NickHu: a category is a semigroupoid with identities
03:49:03 <dibblego> what if f "Hai"?
03:49:09 <ertesx> NickHu: semigroupoids are a CT notion
03:49:11 <Cale> intothem2untains: You can add  deriving (Read) to your data declaration
03:49:16 <Insanity_> Thanks for the advice NickHu. At this point I'm just going through "learn you a haskell.." ^^
03:49:29 <intothem2untains> dibblego: I guess f "Orange" -> Just Orange then
03:49:30 <NickHu> intothem2untains: Yes, you can pattern match on strings pretty much exactly like you stated, replace -> with =
03:49:34 <Cale> intothem2untains: and then all the usual read/reads/readMaybe stuff will work.
03:49:48 <intothem2untains> NickHu: Yeah, but I don't want to explicitly list them all
03:49:53 <intothem2untains> Cale: Cheers!
03:49:57 <NickHu> oh yeah derive Read instance
03:50:14 <dibblego> intothem2untains: see the Read type-class
03:50:25 <sshine> NickHu, a magma?
03:50:33 <dibblego> intothem2untains: but, tbh, I would never do that. I'd write a Prism' 
03:50:36 <NickHu> Ah, maybe that's what I was thinking of
03:50:37 <Cale> @let data Player = Green | Purple | Orange deriving (Eq, Ord, Read, Show)
03:50:39 <dontdieych> Cale: hmm... I just should get args two numbers for that. too hard :) . for next time
03:50:40 <lambdabot>  Defined.
03:50:53 <sshine> ertesx, I thought you normally drew the line in vector spaces ;D
03:51:00 <intothem2untains> dibblego: I don't even know what they are :S
03:51:08 <dibblego> @type prism'
03:51:10 <lambdabot> (Choice p, Applicative f) => (b -> s) -> (s -> Maybe a) -> p a (f b) -> p s (f s)
03:51:22 <intothem2untains> That sheds some light :þ
03:51:37 <Cale> > read "Orange" :: Player
03:51:41 <lambdabot>  Orange
03:51:50 <Cale> > reads "Orange" :: [(Player, String)]
03:51:52 <lambdabot>  [(Orange,"")]
03:52:03 <Cale> > reads "Blue" :: [(Player, String)]
03:52:11 <sshine> NickHu, a magma sounds like a lava golem.
03:52:11 <lambdabot>  []
03:52:32 <zoran119> my cabal project depends on hackage library which needs updating, if i clone the library source from github, how can i add it as a dependency to my project?
03:52:35 <dibblego> @type prism' show (\s -> case s of "Orange" -> Just Orange; _ -> Nothing)
03:52:36 <NickHu> sshine: I can never think of an example of one, or a semigroup even
03:52:42 <lambdabot> (Choice p, Applicative f, Show a) => p Player (f a) -> p String (f String)
03:52:56 <sshine> NickHu, the empty set is a semigroup ;)
03:53:01 <intothem2untains> dibblego: what if I had 10 different colors?
03:53:08 <dibblego> intothem2untains: 10 prisms
03:53:28 <NickHu> Oh no wait you can form a semigroup with Integers under the max function
03:53:41 <NickHu> Can't think of one for magma
03:54:19 <dibblego> Prisms can be derived too, with TH. They don't need to be handwritten.
03:54:48 <intothem2untains> I prefer to use readMaybe than TH
03:55:03 <intothem2untains> The input has been validated by a parser previously anyways
03:55:05 <NickHu> "enjoy your runtime bloat :DDD"
03:55:12 <ertesx> sshine: i'm quite fond of my vector spaces, but that's not where i draw the line =)
03:55:22 <dibblego> ok, I don't. In fact, importing Read is a bug in my programs :)
03:55:35 <merijn> dibblego: readMaybe is fine :)
03:55:43 <dibblego> merijn: ew pls stop
03:55:54 <merijn> dibblego: I mean, it sucks performance wise, but other than that
03:56:03 <sshine> ertesx, I just mean, vector spaces are convenient for drawing lines.
03:56:09 <dibblego> I tend to take "no stringly-typed programming" much further than others
03:56:15 <dibblego> data strucutures, all the way
03:56:34 <ertesx> sshine: yeah, just like topology is convenient for drawing balls
03:56:52 <Cale> zoran119: cabal sandbox add-source ../foo
03:57:23 <Cale> zoran119: and then cabal install --only-dependencies to actually build foo and install it into the sandbox
03:57:57 <Cale> (you run these from the sandbox directory)
03:58:16 <ertesx> hmm…  did that sound weird?
03:59:09 <merijn> dibblego: I would take it further if I had better tools to do so
04:01:21 <ertesx> what i really don't like about group theory is that it has to give every concept its own name
04:01:28 <Cale> Oh?
04:01:35 <dibblego> merijn: me too, and I do indeed dance with the devil, and though the devil is difficult to anticipate, I have not to this day said, "ok devil I will use Read" and should that day come, then I do not know the consequences and can only sit here and hope that we all make it out the other side
04:01:41 <Cale> ertesx: What do you mean by that?
04:01:49 <bollu> ertesx: what?
04:02:41 <ertesx> Cale: like magmas
04:03:04 <Cale> magmas... don't really come up in group theory
04:03:18 <Cale> In fact, most people barely mention monoids
04:03:36 <ertesx> yeah, i suppose
04:03:37 <Cale> It's weirdo category theorists who like to talk about monoids
04:03:52 <Cale> and even weirder people who consider things more general than that
04:03:52 <ertesx> and haskell programmers ;)
04:04:22 <bollu> Cale: monoids come up in Aluffi though IIRC. He shows monoids and groupoids, and then gives the perverse group definition :P
04:04:45 <Cale> bollu: Which one? A group is a groupoid with one object?
04:04:48 <merijn> dibblego: I'm guessing you don't do a lot of shell scripts in haskell :p
04:04:59 <ertesx> Cale: bollu probably means that other "groupoid"
04:05:01 <bollu> Cale: yes, that one
04:05:19 <bollu> ertesx: there's another "groupoid" ?
04:05:27 <dibblego> merijn: quite the contrary
04:05:57 <ertesx> i think some weaker notion of groups is called groupoid
04:06:03 <dibblego> merijn: on those days, we dance, we truly get jiggy with it
04:06:05 <Cale> bollu: At some point, some people used "groupoid" to mean what people now usually refer to as a "magma"
04:06:06 <ertesx> but not the groupoid from CT
04:06:14 <ertesx> ah
04:06:16 <Cale> i.e. just a set with a binary operation on it
04:06:23 <bollu> Cale: ohh, that's strange. How'd that happen?
04:06:32 <Cale> Is it really strange?
04:06:40 <Cale> I mean, the inspiration is obvious
04:06:53 <ertesx> it's a generalisation after all
04:07:04 <Cale> But clearly, the categorical definition of "groupoid" is much more closely related to groups
04:07:17 <Cale> and a more important concept as well
04:07:24 <Cale> So it ended up winning
04:07:48 <bollu> Cale: I meant the terminology :)
04:07:53 <ertesx> does "x-oid" actually mean "x, but weaker"?
04:08:26 <Cale> ertesx: Yeah, that's kind of an English technical language rules
04:08:28 <Cale> rule*
04:09:23 <Cale> Origin: Of multiple origins. Partly a borrowing from Latin. Partly a borrowing from Greek. Etymons: Latin -oīdēs; Greek -οειδής, French -oïde, Latin -oideus.
04:09:35 <Cale>   Chiefly in Science. Forming adjectives with the sense ‘having the form or nature of, resembling, allied to’, and nouns with the sense ‘something having the form or appearance of, something related or allied in structure, but not identical’
04:09:54 <ertesx> ah
04:10:09 <bollu> Cale: I found this insane: http://mathoverflow.net/a/1147
04:10:30 <bollu> Cale: did you google the origins, or do you know latin / greek / french? 
04:10:40 <Cale> I copy-pasted that from OED
04:10:53 <bollu> I see :)
04:11:04 <Cale> Yeah, groupoid cardinality is cool
04:11:05 <bollu> Cale: I have a "foundations" question. 
04:11:12 <bollu> I've been reading Quantum computing lately
04:11:29 <bollu> and a lot of "rules" in quantum information (no cloning, entanglement, etc)
04:11:31 <pavonia> What is a monoid in that regard?
04:11:34 <bollu> I think can be encoded as type information
04:11:45 <bollu> but.. I have no idea how to even start such a process
04:11:53 <bollu> like, if you have a system, how do you write down typing rules for it?
04:12:03 <bollu> what do I read? how do I start?
04:12:37 <Cale> pavonia: A monoid is a thing that has a 1 in it
04:13:33 <pavonia> Yeah, makes sense
04:13:44 <Cale> bollu: This is an art, especially in Haskell where you're going to have to make tough compromises and probably won't represent most of the properties of your stuff at the type level, just because it's too awkward
04:14:21 <Cale> But also in languages like Coq or Agda where you can conceivably encode everything you could ever want.
04:14:22 <ertesx> bollu: most of that is captured by the underlying linear algebra, so you have to make sure for example that your operators are hermitian or unitary
04:14:23 <bollu> Cale: what about abstractly? Let's say I'm outside Haskell for a moment (because no cloning is linear types IMO, which can't(?) be encoded in Hask)
04:14:40 <bollu> ertesx: yes, agreed. but some of it comes from the postulates themselves
04:15:04 <bollu> ertesx: so, like, is it possible for the type system to encode the postulates in a suitably "nice" way?
04:15:16 <Cale> So yeah -- are you building this system out of linear operators, or are the fundamental things in your system more abstract than that?
04:15:41 <bollu> Cale: I don't know which approach is correct :) let's say more abstract for the moment.
04:15:49 <Cale> (and then it'll hopefully support an interpretation in which certain things get interpreted as linear operators)
04:16:39 <Cale> Well, even if you don't directly have linear operators, you might have some primitive corresponding to the conjugate transpose
04:16:58 <Cale> and various other operations of that sort which you might need
04:17:23 <intothem2untains> Is there something like  f d a = maybe d id a?
04:17:23 <bollu> Cale: okay, but what about the interactions between the operator and the state? eg. collapse of state function
04:17:33 <bollu> state vector*
04:17:44 <Cale> intothem2untains: fromMaybe
04:18:00 <intothem2untains> Cale: thanks once again :)
04:18:48 <Cale> bollu: I dunno, this discussion is probably too generic to contribute meaningful advice...
04:19:03 <bollu> Cale: all right :) 
04:19:12 <bollu> Cale: thing is, I have no experience designing "unique" type systems
04:19:28 <bollu> Cale: so, like, is there someplace like a library of type system ideas or some such?
04:19:34 <zoran119> Cale: do i still need to add the library i add-source'd to my .cabal file?
04:19:45 <lpaste> mahdi pasted “Network.TLS: no ciphers available with those parameters” at http://lpaste.net/185934
04:20:24 <Cale> zoran119: yes
04:20:40 <zoran119> Cale: in build-depends?
04:20:46 <Cale> zoran119: presumably :)
04:21:22 <Cale> bollu: I dunno, I guess just get exposed to various other people's type systems and see if they inspire you.
04:21:23 <mahdi> hi, anyone with experience using TLS, I'm getting "no ciphers available with those parameters", what could be the problem? I had success using HsOpenSSL, but I can't get tls working: http://lpaste.net/185934
04:21:39 <bollu> Cale: all right. 
04:21:51 <mahdi> I have to use tls instead of HsOpenSSL because it doesn't support ALPN
04:21:54 <Cale> bollu: There is an interesting thing which I don't understand called cohesive homotopy type theory whose models are supposed to be differentiable manifolds.
04:22:01 <oherrala> mahdi: You need to select the ciphersuites manually
04:22:25 <oherrala> mahdi: it's hidden in ServerParams -> serverSupported -> supportedCiphers
04:22:43 <bollu> Cale: what's it for? 
04:22:45 <mahdi> oherrala: I've already set that to ciphersuite_all
04:22:47 <oherrala> mahdi: default list is empty: https://hackage.haskell.org/package/tls-1.3.8/docs/src/Network-TLS-Parameters.html#defaultSupported
04:22:59 <mahdi> oherrala:  http://lpaste.net/185934
04:23:04 <oherrala> mahdi: ah, damn, missed that line. sorry
04:24:16 <Cale> bollu: Well, the idea is to construct a synthetic approach to geometry, and differential geometry in particular
04:24:19 <mahdi> oherrala: I digged into Network.TLS code, it's verifying the ciphers, but I can't understand why all the ciphers are filtered out: http://hackage.haskell.org/package/tls-1.3.8/docs/src/Network-TLS-Context.html#contextNew
04:24:34 <mahdi> see instance TLSParams ServerParams, getCiphers
04:27:09 <bollu> Cale: is that possible? wasn't the point of having algebraic and coordinate geometry be able to use algebraic tools on geometry?
04:27:48 <ertesx> bollu: in haskell?  i doubt it
04:28:11 <bollu> ertesx: which part? the QM thing? yeah, that was just thinking out loud
04:29:00 <Cale> bollu: Well, it's working out mostly pretty nicely for homotopy theory in HoTT, so the idea is to extend the type theory with additional stuff you'd care about in geometry (of course, differentiable manifolds are spaces up to homotopy too, but that throws away lots of information)
04:29:44 <bollu> Cale: I see. I tried starting the HoTT book, but I got lost. So I'm doing SF right now.
04:29:56 <Cale> But I don't understand any of the details -- I'm lost as soon as they start talking about cohesive (infinity, 1)-toposes :)
04:30:26 <bollu> Cale: xD I remember reading lecture notes on algebraic topology where he says "if I say the word topos, shoot me" :P they seem to be frightfully abstract
04:31:13 <Cale> But the idea is that cohesive (infinity, 1)-toposes are supposed to provide some sort of context in which differential geometry makes sense to do
04:32:08 <Cale> (and HoTT gets us an internal language for plain (infinity, 1)-toposes)
04:32:33 <bollu> Cale: I have no idea what that means (both internal language and (infty, 1)-toposes)
04:32:42 <zoran119> how can i get a list of all installed dependencies for my project?
04:33:02 <ph88> hey guys, i have this type    newtype ContextClause = CC [ContextItem]    i would like to make a function that takes a ContextClause and then prints every ContextItem .. but i have a CC data constructor there so i don't think i can just map over it
04:33:11 <zoran119> talking cabal here, sorry
04:34:16 <maerwald> zoran119: cabal sandbox hc-pkg list?
04:34:53 <Cale> bollu: I have some idea what those things mean, but I don't know them well enough to try to explain them here :)
04:35:12 <zoran119> maerwald: almost there, doesn't seem to list transitive deps?
04:35:16 <bollu> Cale: heh, alright :)
04:35:35 <NickHu> ph88: You can either patterm match to extract from the constructor or define your datatype as a singleton record like newtype ContextClause = CC { getContextClase :: [ContextItem] }
04:36:00 <maerwald> zoran119: what do you mean?
04:36:05 <NickHu> Then you get the function getContextClause :: ContextClause -> [ContextItem] for free
04:36:50 <zoran119> maerwald: my project depends on snaplet-postgres-simple, it depends on transformers. i'd like to know which version of transformers end up in my project
04:37:25 <maerwald> zoran119: does the command I gave not list transformers?
04:37:33 <zoran119> maerwald: no, it doesn't
04:37:41 <zoran119> maerwald: i was a bit surprised
04:37:43 <maerwald> did you check the global db too?
04:38:00 <zoran119> maerwald: oh, it does
04:38:08 <zoran119> maerwald: helps if you read :)
04:38:56 <zoran119> maerwald: thanks for that
04:39:23 <ph88> NickHu, oh yes i think i will take the first option .. i forgot that it was possible to pattern match on data constructors ^^
04:39:56 <NickHu> I think it's more idiomatic to do it the second way - the compiler is probably smart enough to inline it for you
04:41:04 <ph88> if i do like   import blabla as P   can i add my own function to P  ?
04:44:52 <merijn> ph88: Not directly, but you can import multiple modules into P
04:45:13 <merijn> ph88: "import foo as P; import bar as P" will add everything from foo AND bar to P
04:47:56 <ph88> i see ..
04:48:22 <bollu> does anyone know of haskell summer internships that accept people outside of EU/USA? I've applied to Galois, but are there others?
04:48:36 <ph88> i feel like there could be a out-of-the-box function instead of this foldr1   instance P.Pretty ContextClause where  pretty (CC cc) = foldr1 (\a b -> a <> b) cc     <> is from  https://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.3/docs/Text-PrettyPrint-ANSI-Leijen.html
04:53:46 <pavonia> ph88: Doc is a Monoid, you you can use mconcat
04:53:48 <merijn> bollu: Could try Jane Street if you're ok with non-Haskell FP
04:53:53 <pavonia> *so you
04:54:15 <merijn> pavonia: That's a different <>
04:55:02 <athan> Is there a way to supply threads to ghci? I'm not sure if executable flags like `-threaded` and `-rtsopts` would have any effect :s
04:55:07 <bollu> merijn: Interesting
04:55:11 <bollu> merijn: how do they pick people?
04:55:15 <pavonia> merijn: But it seems to have the same implementation
04:55:45 <merijn> bollu: No idea :)
04:56:09 <bollu> merijn: aw, damn :) I guess
04:56:23 <pavonia> ph88: And then there's hcat, too
04:57:09 <bollu> merijn: know of any others?
04:59:10 <merijn> Not really. Try asking haskell-cafe?
04:59:37 <bollu> merijn: the mailing list? Will do
04:59:45 <bollu> merijn: why's it called haskell-cafe BTW?
05:00:54 <funkshun> clear
05:01:28 <athan> Can I INLINE a local `let` statement?
05:01:41 <absence> bollu: probably to suggest informal discussion, like in a cafe
05:01:46 <merijn> bollu: Because it's for informal things
05:02:01 <bollu> ohh, I see. makes sense!
05:02:05 <merijn> bollu: So, haskell related, but in the broadest sense. From questions about the language, to jobs, ecosystem, etc.
05:02:13 <bollu> ahh, neat
05:02:42 <merijn> bollu: They occasionally advertise jobs there too, so asking there might get you reactions from people in companies where they actually use haskell :)
05:02:52 <bollu> heh, nice
05:03:32 <ph88> pavonia, i made a mistake in my function it should be  pretty (CC cc) = foldr1 (\a b -> P.pretty a P.<> P.pretty b) cc   so that means i'm not starting out with a list of Doc .. so i should first map P.pretty over a list to get a list of doc and then use hcat ?  Maybe i should make my own concatMap function for this ?
05:06:26 <bollu> merijn: cool, I just sent an email to haskell-cafe
05:07:21 <{AS}> Is there no allM?
05:08:19 <liste> {AS}: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:allM
05:08:27 <{AS}> (Foldable f, Monad m) => (a -> m Bool) -> f a -> m Bool
05:08:28 <liste> monad-loops has a bunch of other cool stuff too
05:08:29 <{AS}> liste: Thanks!
05:08:48 <{AS}> liste: Is there one that works on foldable? :)
05:10:00 <liste> @hoogle (Foldable f, Monad m) => (a -> m Bool) -> f a -> m Boo
05:10:02 <liste> @hoogle (Foldable f, Monad m) => (a -> m Bool) -> f a -> m Bool
05:10:02 <lambdabot> Control.Concurrent.Speculation.Foldable sequenceBy_ :: (Foldable t, Monad m) => (m () -> m () -> Bool) -> (Int -> m b) -> t (m a) -> m ()
05:10:02 <lambdabot> Prelude mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
05:10:02 <lambdabot> Control.Monad mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
05:10:03 <lambdabot> Control.Concurrent.Speculation.Foldable sequenceBy_ :: (Foldable t, Monad m) => (m () -> m () -> Bool) -> (Int -> m b) -> t (m a) -> m ()
05:10:03 <lambdabot> Prelude mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
05:10:04 <lambdabot> Control.Monad mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
05:10:18 <liste> {AS}: I'm not aware of one
05:10:21 <Cooler> isn't bind covered by fmap?
05:10:24 <{AS}> liste: OK, thanks!
05:10:29 <{AS}> Cooler: It's not
05:10:52 <{AS}> :t fmap
05:10:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:10:59 <{AS}> :t (>>=)
05:11:01 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:11:09 <{AS}> :t (=<<)
05:11:11 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:11:16 <Cooler> in a -> b
05:11:18 <{AS}> so you can see the difference
05:11:26 <Cooler> why can't b == m b
05:11:33 <Cooler> i mean c == m b
05:11:34 <{AS}> bind allows you to do more
05:11:43 <Cooler> and a -> c
05:11:54 <Cooler> so then its just fmap
05:12:01 <{AS}> Cooler: this says that given you provide a function that maps a's to c's
05:12:09 <pavonia> ph88: "hcat . map pretty" is fine, I guess
05:12:15 <{AS}> then you provide a function that maps things of a's to things of b's
05:12:29 <{AS}> So if you take a look at List
05:12:45 <{AS}> how would you do (a -> c) -> [a] -> [b] ?
05:12:53 <Cooler> map
05:13:18 <{AS}> Cooler: but see, how would you construct b's from the totally unrelated c's?
05:13:38 <Cooler> {AS}, in the type of fmap
05:13:41 <Cooler> :t fmap
05:13:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:13:49 <{AS}> I mean we can monomorphise the above
05:13:57 <Cooler> why can't b me the m b
05:14:01 <Cooler> be*
05:14:12 <{AS}> (Int -> String) -> [Int] -> [Tree Int]
05:14:27 <Cooler> what?
05:14:28 <ph88> what is this possible fix here?   https://paste.fedoraproject.org/423335/73250438/
05:14:29 <{AS}> how would you construct Tree Int out of String : ) ?
05:14:43 <Cooler> what?
05:14:48 <{AS}> OK, hmm
05:15:20 <Cooler> why can't b in fmap == m b in bind
05:15:25 <{AS}> Cooler: 
05:15:26 <Cooler> then you have fmap == bind
05:15:35 <{AS}> so let us say that you let b == m c
05:15:36 <{AS}> for some c
05:15:57 <cocreature> Cooler: no then you get have (a -> m b) -> f a -> f (m b)
05:16:08 <{AS}> then what you get with fmap is (a -> m c) -> m a -> m (m c)
05:16:17 <{AS}> ah cocreature got it before me
05:16:29 <{AS}> what you can do is use `join` 
05:16:34 <{AS}> but that requires Monad :)
05:16:43 <cocreature> ah {AS} was faster in explaining join :)
05:16:47 <Cooler> fmap :: (a -> b) -> F a -> F b   if a is Int and b is the type Maybe String for example
05:17:01 <cocreature> then you end up with F (Maybe String)
05:17:04 <{AS}> so `join . fmap f == (=<<) f`
05:17:41 <Cooler> cocreature, uh
05:17:44 <Cooler> right
05:17:51 <Cooler> but whats wrong with that?
05:18:03 <cocreature> nothing is wrong with that, it’s just not what bind does
05:18:16 <Cooler> so what does bind do differently?
05:18:16 <ph88> ah i got it, i just had to make sure  a  also implements typeclass P.Pretty
05:18:31 <cocreature> :t =<<
05:18:33 <lambdabot> error: parse error on input ‘=<<’
05:18:38 <cocreature> :t (=<<)
05:18:40 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:18:44 <Cooler> it gives you a m b instead of a F m b ?
05:18:49 <{AS}> @quickcheck \(f, x) -> join . fmap f x == (=<<) f x
05:18:49 <lambdabot> Unknown command, try @list
05:18:54 <cocreature> Cooler: exactly
05:19:08 <Cooler> but when you compose functions isn't F m b what you want
05:19:09 <Cooler> ?
05:19:38 <cocreature> how so?
05:19:53 <cocreature> it’s not like one is right and the other is wrong. they are just different things
05:20:12 <athan> has anyone had some issues getting ghc to see llvm-3.7? For some reason it's not finding it :(
05:20:18 <Cooler> this would make a lot more sense with some examples
05:20:19 <{AS}> @check \(f, x) -> join . fmap (f :: Bool -> Maybe Bool) x == (=<<) f x
05:20:20 <athan> anyone here* >.>
05:20:23 <lambdabot>  error:
05:20:23 <lambdabot>  • Couldn't match expected type ‘a0 -> m0 (m0 a1)’ with actual type ‘Maybe (M...
05:20:25 <bollu> stupid question, how do I check if the email I sent to haskell-cafe was actually sent?
05:20:40 <{AS}> @check \(f, x) -> join . fmap (f :: Bool -> Maybe Bool) $ x == (=<<) f x
05:20:44 <lambdabot>  error:
05:20:44 <lambdabot>  • Couldn't match expected type ‘Maybe Bool’ with actual type ‘Bool’ • In the...
05:20:54 <bollu> {AS}: why would you apply =<< that way?
05:20:55 <cocreature> bollu: see if it appears here https://mail.haskell.org/pipermail/haskell-cafe/2016-September/
05:21:10 <cocreature> I think it takes some time for the webinstance to update
05:21:16 <{AS}> bollu: what is wrong?
05:21:54 <bollu> {AS}: I meant, why not (x >>= f) or (f =<< x) ? :)
05:22:00 <{AS}> Ah
05:22:09 <bollu> cocreature: oh, thanks. I was wondering if I was doing something wrong
05:22:19 <{AS}> Uh, I guess I am not sure :)
05:22:23 <Cooler> lets say i have a function parse :: String -> Maybe Int
05:22:57 <Cooler> i also have a function add3 :: Int -> Int  add3 x = x + 3
05:23:01 <ph88> can someone help me test this with QuickCheck ?   https://paste.fedoraproject.org/423339/32509331/
05:23:12 <{AS}> cocreature: 
05:23:14 <{AS}> Err
05:23:15 <{AS}> Cooler: 
05:23:16 <{AS}> @check  \(f, x) -> (join . fmap (f :: Bool -> Maybe Bool) $ x) == (=<<) f x
05:23:18 <lambdabot>  +++ OK, passed 100 tests.
05:23:49 <Cooler> to compose them i can just do     fmap add3 parse
05:24:19 <Cooler> wait
05:24:24 <Cooler> fmap add3 . parse ?
05:24:31 <cocreature> yeah
05:24:35 <Cooler> yeah
05:24:44 <Cooler> so i don't need bind
05:24:55 <cocreature> Cooler: so now let’s say you have parse' :: String -> Maybe Int
05:25:01 <cocreature> Cooler: and you want to compose parse and parse'
05:25:24 <cocreature> eh let’s make both String -> Maybe String
05:25:29 <cocreature> otherwise it won’t compose :)
05:25:32 <Cooler> what that doesn't make sense
05:25:42 <Cooler> parse returns a Maybe Int
05:25:48 <Cooler> parse' has to take atleast Int
05:25:54 <cocreature> yeah I already said we need to change both to String -> Maybe String
05:26:07 <Cooler> ok
05:27:34 <Cooler> cocreature, fmap should work
05:27:42 <Cooler> fmap parse' . parse
05:27:50 <Cooler> gives you a Maybe Maybe String
05:28:34 <cocreature> yeah but you can’t get just a Maybe String
05:28:38 <cocreature> that’s what bind allows you to do
05:28:57 <Cooler> this is why i said F m b is what you want
05:29:06 <Cooler> Maybe Maybe String makes sense
05:29:27 <cocreature> because you need Just Nothing?
05:29:55 <cocreature> if you are just interested if your action failed one layer of maybes is enough
05:29:59 <Cooler> no because Maybe Maybe String is what the actual thing represents
05:30:05 <qknight> ertesx: i did not try --jailbreak. i went for the solution of forcing all haskell-packages into using semigroups-0.18.1
05:30:17 <saurabhnanda> need help with "how to design a domain API with pragmatic type safety?" -- https://www.reddit.com/r/haskell/comments/51kzdu/how_to_write_a_domain_api_with_pragmatic_type/
05:30:51 <Cooler> cocreature, in this case both F and m were the same
05:30:58 <cocreature> Cooler: but imagine you have 10 functions of type a -> Maybe a because each of them can fail. Do you really want to end up with Maybe^10 a? maybe you are just interested if you got the final result or not
05:31:00 <Cooler> lets take parse
05:31:09 <Cooler> lets take parse :: String -> Maybe Int
05:31:15 <qknight> ertesx: i've also had a talk to peti@nixos who told me to only use one semigroups version for all instead of using differnet ones for different libraries who were using it
05:31:28 <Cooler> and squareroot :: Int -> Maybe Int
05:31:38 <cocreature> then you still end up with Maybe (Maybe Int)
05:31:50 <Cooler> yeah but now the layers are different
05:31:58 <cocreature> both are Maybe
05:32:13 <Cooler> hmm bad example
05:32:34 <cocreature> Cooler: there is no right or wrong here. they are just different things and sometimes you want one and sometimes you want the other
05:32:38 <Cooler> lets say one of them is a Maybe Int and the other is a Maybe String
05:32:44 <Cooler> Maybe Maybe Int
05:33:06 <cocreature> Cooler: let’s say you have f :: Int -> IO String and g :: String -> IO ()
05:33:15 <cocreature> Cooler: what are you going to do with IO (IO a)?
05:33:16 <Cooler> cocreature, but when you collapse the maybes you are losing info
05:33:20 <cocreature> ofc
05:33:26 <cocreature> but maybe that’s what you want
05:33:38 <Cooler> your losing the context
05:33:47 <cocreature> yep
05:33:57 <Cooler> so bind exists to destroy context?
05:34:39 <cocreature> not really you are assuming that you can always do something useful with f (f a). if you set f = IO you actually need bind to be able to execute your io actions
05:35:08 <cocreature> but you are right that bind loses some information, if you don’t want that don’t use bind :)
05:35:22 <Cooler> what do you mean you need bind?
05:35:45 <Cooler> f (f a) won't work but f a will?
05:36:21 <Cooler> i would have thought its the other way around
05:36:30 <cocreature> Cooler: let’s say you have f :: String -> IO String which reads a file and you have g :: String -> IO String which takes the file content returned by f and interprets it as a filename that it then reads and returns its content
05:36:42 <cocreature> Cooler: now try writing a program that composes these two functions
05:36:46 <Cooler> since fmap doesn't destroy the info you should be able to use F F a better than F a
05:36:54 <cocreature> Cooler: if you end up with IO (IO a) you will never execute the inner IO action
05:37:15 <ertesx> qknight: yeah, that's certainly the best option
05:37:25 <ertesx> qknight: i thought you experienced cabal hell
05:37:35 <Cooler> cocreature, what? why?
05:37:37 <NickHu> Cooler: Another way of understanding bind is it lifts a function into a monad and then does join on the result
05:37:55 <NickHu> Infact, I'm pretty sure defining join and lift are equivalent to defining bind
05:38:14 <NickHu> join takes your Maybe (Maybe Int) and turns it into a Maybe Int
05:38:32 <cocreature> Cooler: because the inner IO is just a value that is passed around. only the outer layer is the one that is being executed (assuming you call it somewhere)
05:38:34 <cocreature> sorry need to leave
05:38:43 <Cooler> cocreature, what exactly does IO (IO String) mean?
05:39:03 <MarLinn> Cooler: why would I ever want to fold a list? I'm "destroying" data that way! <- same argument, related logical error
05:39:04 <NickHu> It means do some IO, and return something which will do IO to give a string
05:39:17 <cocreature> it is an io action that will return another io action returning a string
05:39:21 <merijn> Cooler: It's an io action that when excuted produces an IO action
05:39:23 <NickHu> But the thing that is returned isn't actually done
05:39:24 <ertesx> Cooler: you tell us…  if an (IO A) is a program that results in an A, what is an (IO (IO A))?
05:39:48 <Cooler> wait a second
05:39:49 <{AS}> IO (IO String) lets you do a bit more than IO String
05:39:58 <Cooler> in the example given above of reading 2 files
05:40:01 <{AS}> so it lets you use IO to compute an IO action :)
05:40:16 <Cooler> isn't the inner IO the 1st file read?
05:40:22 <Cooler> and the outer the 2nd file read?
05:40:26 <{AS}> which you may choose to not run now, or run later, or not at all
05:40:33 <ertesx> Cooler: don't think of "inner" and "outer"…  what is a value of type IO (IO A)?
05:40:54 <ertesx> use what you know about IO A to answer that
05:41:06 <Cooler> ertesx, i mean Inner and Outer syntax wise
05:41:10 <Cooler> no semantically
05:41:12 <Cooler> not*(
05:41:16 <Cooler> not*
05:42:05 <Cooler> IO(IO String)    the inner IO is the result of the function fileRead1
05:42:18 <ertesx> Cooler: simple example:  getLine is a program that results in a string
05:42:29 <Cooler> and the outer one is the result of    fmap fileRead2 . fileRead1
05:42:39 <ertesx> fmap putStrLn getLine  -- this is putStrLn mapped over that string, an IO (IO ())
05:42:56 <Cooler> thats what i said
05:43:02 <ertesx> does this action print something?
05:43:24 <Cooler> uh....
05:44:04 <Cooler> it would have to be reversed
05:44:14 <Cooler> the outer IO needs to do fileRead1
05:44:25 <Cooler> and produce a IO action that does fileRead2
05:45:10 <Cooler> so yes it does something if fmap does the right thing
05:45:23 <merijn> Cooler: ah, but *what* does it do? :)
05:45:40 <ertesx> but does it *print*?  or does it *read*?  or does it do both?
05:46:26 <Cooler> ertesx, in fmap putStrLn . getLine if fmap does the right thing
05:46:40 <ertesx> can fmap do the right thing?
05:46:48 <Cooler> the outer IO will be an IO action that reads a line and produces a IO action that outputs the line
05:46:52 <ertesx> by your current definition of the "right thing" =)
05:47:03 <ertesx> correct
05:47:10 <ertesx> and that's all fmap can do
05:47:14 <Cooler> depends on your implementation of fmap
05:47:30 <ertesx> it really doesn't, because the functor laws leave you no choice here
05:47:46 <ertesx> fmap can never introduce an extra effect
05:47:52 <Cooler> ertesx, the composition law?
05:48:12 <ertesx> both the composition and identity laws
05:48:31 <ertesx> fmap doesn't know that you're mapping to an IO action
05:48:36 <ertesx> it can't know
05:48:52 <jakub_> is there/can there be an instance declaration: (Monad m, MonadTrans t) => Monad (t m)? if not, why?
05:48:56 <ertesx> so parametricity also keeps fmap from adding effects
05:49:08 <Cooler> ertesx, so fmap works then
05:49:13 <Cooler> why do you need bind?
05:49:31 <ertesx> Cooler: this one only reads a line: fmap putStrLn getLine
05:49:53 <ertesx> now:  fmap putStrLn getLine >>= \action -> …  -- binding allows you to use the result (the printing (or "inner") action of type IO ()) as part of a compound action
05:50:16 <Cooler> ertesx, what do you mean it only reads the line?
05:50:25 <NickHu> putStrLn is never called
05:50:30 <dkasak> Cooler, it doesn't print anything. Try it.
05:50:31 <Cooler> it also produces an IO action that outputs the line
05:50:38 <ertesx> Cooler: fmap putStrLn getLine  -- this action only reads a line and results in an action that *would* print that line
05:50:41 <NickHu> An IO action which is never executed
05:50:47 <Cooler> NickHu, so?
05:50:53 <NickHu> So it doesn't run
05:50:55 <Cooler> just execute it
05:50:58 <NickHu> How?
05:51:14 <NickHu> What happens when you have chains of IO (IO (IO (IO (IO ()))))))
05:51:18 <ertesx> Cooler: you can't execute in haskell…  you can only compose an IO action that eventually gets executed as part of 'main'
05:51:36 <NickHu> So with bind you can sequence your IO actions
05:51:40 <jakub_> NickHu: use "join" to flatten this pattern
05:51:43 <Cooler> main = fmap putStrLn . getLine
05:51:45 <NickHu> jakub_: Yes
05:51:46 <Maxdamantus> :t join . join . join . join . join
05:51:47 <lambdabot> Monad m => m (m (m (m (m (m a))))) -> m a
05:51:52 <ggVGc> what does IO(IO()) mean?
05:51:56 <NickHu> Bind is equivalent to join and fmap
05:51:58 <ertesx> Cooler: main = fmap putStrLn getLine  -- this only reads the line
05:52:04 <Cooler> why
05:52:05 <ggVGc> it doesn't make so much sense to me
05:52:17 <NickHu> ggVGc: It is an IO action which will produce another IO action (but not run it!)
05:52:23 <ggVGc> ah, yeah okay
05:52:24 <jakub_> ggVGc: I always think of these as "stored" IO action within the context of IO
05:52:25 <Cooler> : fmap putStrLn . getLine
05:52:27 <ertesx> Cooler: because it's an action that reads a line…  the result is a program
05:52:29 <Cooler> :t fmap putStrLn . getLine
05:52:30 <lambdabot> error:
05:52:31 <lambdabot>     • Couldn't match expected type ‘a -> f String’
05:52:31 <lambdabot>                   with actual type ‘IO String’
05:52:31 <ggVGc> jakub_: yeah, I get it now
05:52:34 <ggVGc> that's reasonable actually
05:52:53 <ertesx> Cooler: similarly:  fmap length getLine  -- this is an action that reads a line, and the result is a number
05:53:00 <ertesx> Cooler: the result of 'main' is ignored
05:53:04 <ggVGc> jakub_: so, if you read user input to get a chain of actions to execute
05:53:14 <ggVGc> which in turen require IO
05:53:15 <Cooler> why did that give an error?
05:53:17 <Cooler> :t fmap putStrLn . getLine
05:53:19 <lambdabot> error:
05:53:19 <lambdabot>     • Couldn't match expected type ‘a -> f String’
05:53:19 <lambdabot>                   with actual type ‘IO String’
05:53:27 <ertesx> Cooler: because you're writing (.) all the time
05:53:32 <Cooler> yeah
05:53:47 <Cooler> your giving the output of getLine to fmap putStrLn
05:53:53 <Cooler> so .
05:53:58 <NickHu> Cooler: You actually want to apply putStrLn to getLine with fmap
05:54:20 <Cooler> so because getLine is a value not a function
05:54:20 <ertesx> Cooler: you're misunderstanding something:  you have an IO action getLine, and fmap lets you map a function over its result
05:54:22 <Cooler> right
05:54:30 <Cooler> :t fmap putStrLn getLine
05:54:32 <lambdabot> IO (IO ())
05:54:40 <NickHu> Cooler: values are functions
05:54:50 <jakub_> you can also retrieve and execute the action in do-notation by: a <- ...; a;
05:54:56 <Cooler> NickHu, uh lets not start that again
05:55:00 <ertesx> Cooler: that's better…  do you see why this action doesn't actually print?
05:55:27 <Cooler> no
05:55:39 <Cooler> main = IO(IO ())
05:55:51 <Cooler> the runtime executes main
05:55:52 <ertesx> Cooler: 'main' is the action that is your program…  it's an IO action that gets executed when your program runs
05:56:01 <ertesx> Cooler: the result of that program is ignored
05:56:05 <byorgey> "values are functions"?
05:56:21 <Cooler> ertesx, so main has to be exactly one IO () ?
05:56:23 <byorgey> all functions are values, but not all values are functions
05:56:25 <Cooler> i mean IO a
05:56:31 <ertesx> Cooler: normally 'main' is of type IO (), and the resulting value () is ignored, but haskell doesn't actually care what the result type is, since it's going to ignore the result anyway
05:56:39 <ertesx> Cooler: here your result happens to be an *action*
05:57:04 <Cooler> ertesx, ok i get it
05:57:18 <Cooler> so main has to be one big IO action that does everything in one go
05:57:18 <NickHu> byorgey: Er, what I meant is what he meant as a value is actually a function, which represents a value - tongue twister
05:57:21 <merijn> main is allowed to be any type that can fit into "IO a"
05:57:32 <merijn> NickHu: Functions are values
05:57:42 <ertesx> Cooler: in order for the putStrLn effect to run, it must become a part of 'main' via composition
05:57:50 <ertesx> Cooler: that means (>>=)
05:57:58 <NickHu> merijn: Yeah that's what I meant
05:58:02 <ertesx> Cooler: correct
05:58:08 <Cooler> ertesx, right so in this case you actually do want to collapse into one thing with bind
05:58:24 <ertesx> Cooler: yeah…  i wouldn't even call it collapsing
05:58:35 <ertesx> you're using the result of an action as part of the following action
05:58:53 <Cooler> ertesx, well your still losing info
05:58:58 <ertesx> fmap putStrLn getLine >>= \action -> _theNextAction
05:59:21 <ertesx> you could preserve that info, if you wanted, but normally you would want to just flatten and forget
05:59:28 <ertesx> that's what (>>=) does
05:59:38 <Cooler> ertesx, how would you preserve the info?
05:59:46 <Cooler> fmap doesn't work
06:00:13 <NickHu> Yeah, it does
06:00:31 <NickHu> If what you mean by info is a sequence of actions
06:00:41 <NickHu> >>= applies the strategy "do it in sequence from start to finish"
06:00:45 <ertesx> Cooler: in the extreme case you could even create a concrete AST-like type that reveals the composition structure
06:01:09 <ertesx> then compile that type into an IO action (that's called an interpreter)
06:01:13 <Cooler> AST?
06:01:15 <NickHu> I suppose in theory you could have a different join implementation which does the actions from last to first
06:01:19 <ertesx> abstract syntax tree
06:01:23 <Cooler> oh
06:01:46 <ertesx> but that's entirely unrelated to how IO works and is used
06:02:54 <Cooler> so bind just does what fmap does already, but this time collapses the nested actions into one single action
06:03:08 <ertesx> Cooler: yeah, pretty much
06:03:48 <ertesx> Cooler: in literature and other languages it's actually sometimes called "flatMap"
06:03:54 <Cooler> so how does applicative functor fit into this?
06:03:54 <ertesx> because it maps, then flattens
06:04:20 <ertesx> Applicative allows you to sequence actions and combine results, but it doesn't flatten
06:04:43 <ertesx> it's like fmap over multiple actions
06:07:57 <ertesx> Cooler: you can define applicative functors in terms of liftA2 and pure, which, given your understanding of fmap, is probably the easiest way to understand them:
06:07:59 <ertesx> :t liftA2
06:08:01 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:08:11 <ertesx> combine two actions into a compound action using the given function to combine results
06:09:38 <Cooler> ertesx, ok so how is that not possible with fmap?
06:10:05 <ertesx> Cooler: let's say you want to write an action that reads two lines and results in them concatenated
06:10:16 <ertesx> how do you do that with fmap?
06:13:21 <Cooler> fmap (++) getLine getLine
06:13:25 <Cooler> no that doesn't work
06:13:46 <Cooler> you have to get the function out of the functor
06:13:53 <Cooler> and then fmap again
06:13:59 <ertesx> yup, there is no way to do that, because fmap can't actually combine actions
06:14:14 <ertesx> all it does is to map a function over one action
06:14:48 <ertesx> that's where liftA2 comes in: you can combine two actions into one, and that's actually sufficient to combine arbitrarily many actions into one
06:15:03 <ertesx> just like the binary function (+) is sufficient to add as many numbers as you want into one sum
06:15:40 <athan> byorgey: Well... maybe all values are functions predicated by ()! :v
06:15:46 <Cooler> ertesx, isn't it actually pure and <*>
06:15:56 <Cooler> where is liftA2 coming from
06:15:57 <Cooler> ?
06:16:10 <athan> Cooler: Control.Applicative
06:16:22 <athan> liftA2 f x y = f <$> x <*> y
06:16:23 <ertesx> Cooler: i'm using an equivalent formulation in terms of liftA2 and pure, but yes, normally it's (<*>) and pure
06:16:51 <ertesx> Cooler: the (<*>) function is like a highly compressed version of liftA2
06:17:35 <ertesx> Cooler: liftA2 (++) getLine getLine = fmap (++) getLine <*> getLine
06:18:47 <ertesx> instead of taking an extra argument for the combining function (<*>) just lets the first action return a function to be applied to the result of the second action
06:30:15 <Ford_Prefect> Hello again. Does anyone know of a DSL around language-java (something like cdsl around language-c)?
06:30:46 <ski> Cooler : `(<*>) = liftA2 ($)'
06:31:35 <Insanity_> Ford_Prefect..Been a long time since I read those books :)
06:31:42 <Insanity_> Unfortunately can't help you with your question though
06:36:46 <Cooler> ertesx, the way fmap returns IO(IO())
06:37:09 <Cooler> it feels like there should be a general way to flatten that to a single IO()
06:38:02 <geekosaur> :t join
06:38:04 <lambdabot> Monad m => m (m a) -> m a
06:38:30 <Ford_Prefect> Insanity_: :)
06:38:36 <merijn> Cooler: Turns out, there is ;)
06:38:47 <OutlawStar> hi all, question: If I have a type "data KeyType = Byte4 | Byte8" and then use that type as a data kind in "Key (t :: KeyType) = Key ..." Is it possible to create signatures like "mkKey :: Int -> Key k" ? 
06:39:05 <Cooler> geekosaur, is that a general way for all Monads?
06:39:10 <merijn> OutlawStar: Not in any convenient way, sadly
06:39:15 <OutlawStar> :(
06:39:17 <srhb> Cooler: The generality of m promises you that, yes.
06:39:20 <merijn> Cooler: Yes, hence the type signature :)
06:39:21 <Cooler> or does each Monad have to implement that itself?
06:39:30 <geekosaur> Cooler, if it were not then the type signature would be a lie
06:39:33 <merijn> Cooler: Join is implemented in terms of >>=
06:39:36 <srhb> Cooler: Monad m => m ... reads for ANY m that has a Monad isntance
06:39:42 <merijn> :t (>>=id)
06:39:43 <lambdabot> Monad m => m (m b) -> m b
06:39:50 <OutlawStar> merijn: are you saying there is an unconvient way? maybe like a coerce?
06:40:02 <Cooler> geekosaur, i mean fmap isn't general, each functor has to implement it
06:40:07 <merijn> OutlawStar: Using singletons and the stuff described in the Hasochism paper
06:40:22 <merijn> OutlawStar: You could probably get most/all of the way
06:40:30 <OutlawStar> merijn: ok thx, i'll check that out
06:40:35 <merijn> OutlawStar: But it certainly won't be convenient :)
06:40:45 <geekosaur> Cooler, in the mathematical definition of monads, it needs an implementation for each monad. for Haskell's definition, that is deferred to (>>=)
06:41:07 <merijn> OutlawStar: Also, now that you're starting to want this stuff might be a good time to look at Idris (or similar), where you'll find this sorta stuff would be super easy :)
06:41:43 <Cooler> geekosaur, uh so whats the source?
06:41:47 <srhb> merijn: Butbut ecosystem and laziness :(
06:41:49 <geekosaur> (the mathematical definition of a monad is unit/return/pure (different names for the same operation), fmap, join. Haskell's is return/bind)
06:41:50 <Cooler> :src
06:41:57 <OutlawStar> merijn: yeah I know about idris, but I wanted to achieve certain functionality with haskell. This is a small problem that is part of a larger system
06:41:57 <Cooler> :src join
06:42:04 <geekosaur> merijn just showed it to you
06:42:10 <geekosaur> @src join
06:42:11 <lambdabot> join x = x >>= id
06:42:28 <OutlawStar> merijn: I unfortunetly dicided to go this route and now have hit a stumbling block :(
06:43:26 <ski> OutlawStar : iiuc, `withKey :: Int -> (forall k. Key k -> o) -> o'
06:43:50 <ski> (since presumably you wanted `mkKey :: Int -> exists k. Key k' ?)
06:43:55 <Cooler> :T id
06:43:59 <Cooler> :t id
06:44:01 <lambdabot> a -> a
06:44:11 <Cooler> how does that work with bind?
06:44:12 <sshine> hi srhb!
06:44:19 <Cooler> :t (>>=)
06:44:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:44:23 <srhb> sshine: Hi!
06:44:29 <OutlawStar> ski: that is an interesting idea. I basically have a generic way to store keys (as an int) I need to create the dependent type from that int to work with it
06:44:55 <Cooler> geekosaur, the types don't match
06:45:12 <merijn> Cooler: Sure they do :)
06:45:17 <Cooler> :T id
06:45:20 <Cooler> :t id
06:45:22 <lambdabot> a -> a
06:45:27 <merijn> Cooler: You are, implicitly ruling out that 'a =  m b'
06:45:32 <ski> Cooler : `(>>=)' can be implemented in terms of `fmap' and `join' .. can you see how ?
06:45:41 <merijn> Cooler: There's no reason why 'a' can't be 'm b'
06:45:50 <sshine> Cooler, since >>= is Monad m => m a -> (a -> m b) -> m b, then (\m -> m >>= id) -- or (>>= id) -- becomes the function where the type a = m b. so (>>= id) :: m (m b) -> m b
06:45:59 <Cooler> merijn, no i am not ruling that out
06:46:08 <geekosaur> then why do you think they don't match?
06:46:40 <geekosaur> also remember that each type signature is standalone; the a in the sig for id is not related to the a in the sig for (>>=)
06:46:42 <Cooler> :t (>>=)
06:46:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:46:51 <merijn> if 'a = m b' you get "(>>=) :: m (m b) -> (m b -> m b) -> m b"
06:47:02 <Cooler> bind takes a   a -> m b
06:47:11 <Cooler> and id is always a -> a
06:47:15 <merijn> And "m b -> m b" matches just fine with "id :: a -> m b"
06:47:16 <Cooler> so if a = m b
06:47:23 <Cooler> the id is m b -> m b
06:47:28 <merijn> Cooler: Right
06:47:34 <ski> OutlawStar : .. i assume that the idea was that `mkKey 4' would return something of type `Key Byte4' and `mkKey 8' would return something of type `Key Byte8', and presumably for other inputs it'd error out ?
06:47:35 <Cooler> which is not a -> m b
06:47:52 <merijn> Cooler: It is, because that is a different 'a'
06:48:09 <Cooler> merijn, or you mean the same a
06:48:17 <merijn> Cooler: Pop quiz: "const :: a -> b -> a" <- are 'a' and 'b' different?
06:48:18 <geekosaur> no
06:48:36 <Cooler> its a different a but in this case the same
06:48:37 <sshine> Cooler, (>>=) has a type variable a. applying it to id in place of 'a -> m b' unifies 'a' with 'm b'.
06:48:59 <Cooler> a in >>= is m b
06:49:06 <Cooler> and a in id is m b
06:49:11 <merijn> Cooler: Let's do it differently: "(>>=) :: m a -> (a -> m b) -> m b" and "id :: x -> x"
06:49:18 <Cooler> so its 2 different as that are the same
06:49:21 <geekosaur> siiiigh
06:49:23 <sshine> no. the 'a' in the type for (>>= id) is 'm b' :)
06:49:26 <merijn> 'a = m b'
06:49:44 <merijn> Cooler: We get "m (m b) -> (m b -> m b) -> m b"
06:49:53 <Cooler> but the point is
06:49:57 <merijn> Cooler: Now we need to match "m b -> m b" with "id :: x -> x"
06:50:06 <merijn> Cooler: Which works, IFF 'x = m b' which is fine
06:50:07 <OutlawStar> ski: yes, that exactly it
06:50:13 <ski> OutlawStar : in a dependently typed language, that (ignoring the error case) could be done more or less as `mkKey :: (k ::) KeyType -> Key k' (alternate notation, `mkKey :: forall k :: KeyType. Key k'). if we had existentials, we could approximate that by `mkKey :: KeyType -> exists k :: KeyType. Key k'
06:50:21 <Cooler> >>= :: m m b -> (m b -> m b) -> m b
06:50:33 <Cooler> when a = m b
06:50:54 <ski> OutlawStar : the existential version is (typewise) weaker, since the type-system doesn't know that the `k' in the type of the output is equal to the input `k'
06:51:05 <merijn> Cooler: Hold on, think of it like solving a system of equations
06:51:15 <Cooler> merijn, no this makes sense
06:52:16 <ski> OutlawStar : anyway, there's (currently) two ways to *encode* existentials in Haskell with extensions. one is the CPS/Church version, `withKey' above. the other is to make `data SomeKey = forall k. WrapKey (Key k)', and have `mkKey :: Int -> SomeKey'
06:52:36 <merijn> Cooler: So we have "(>>=) :: m a -> (a -> m b) -> m b" and "id :: x -> x" and "(>>= id)" then we solve for "a -> m b = x -> x" which gives use 'x = a' and 'x = m b'. Therefore it typechecks IFF "a = m b", which lets us rewrite the original type of >>= to "m (m b) -> (m b -> m b) -> m b" :)
06:52:54 <OutlawStar> ski: assh i've used the second version before
06:53:02 <OutlawStar> ahh*
06:53:36 <ski> OutlawStar : with the latter, you'll have to wrap and unwrap often. with the CPS version, you'll have to provide a continuation callback, which usually turns out about the same in verbosity. sometimes one of these are somewhat more nice to use than the other, depending on how you need to use it
06:53:59 <OutlawStar> ski: so mkKey :: (k ::) KeyType -> Key k, does not work I guess?
06:54:08 <ski> right, no dependent types in Haskell
06:54:17 <OutlawStar> :(
06:54:24 <ski> you can sortof approximate *some* aspects of it, with singleton types ..
06:54:39 <ski> (but it's a bit awkward, and has to be done manually for each case)
06:55:19 * ski hasn't checked out this "Hasochism paper" merijn mentioned
06:55:32 <OutlawStar> thats what i was in the middle of reading
06:56:25 <OutlawStar> singletons lib seems to be ghc 8 thing though
06:56:32 <OutlawStar> lol looks like complex stuff
06:56:40 <merijn> naah, singletons was released around 7.8
06:56:45 <Cooler> merijn, thats what i said
06:57:01 <merijn> Cooler: ok, then confusion resolved :)
06:57:02 <OutlawStar> oh, 2.* is ghc 8
06:57:38 <ski> OutlawStar : anyway, a simple example of singletons is (naturals) : `data Nat = Zero | Succ' intended to be used on the type level (so `Nat' is a data kind), together with `data NatIs :: Nat -> * where ZeroS :: NatIs Zero; SuccS :: NatIs n -> NatIs (Succ n)', and then you can do stuff like `foo :: NatIs n -> ..n..' to simulate the dependent `foo :: (n ::) Nat -> ..n..'
06:58:44 <ski> it's called singletons, because for each type `n' of kind `Nat', the type `NatIs n' has a single (total) element, which is a "copy" of `n', with `Zero' and `Succ' replaced by `ZeroS' and `SuccS'
06:59:37 <OutlawStar> hmm ok, need to digest this a bit. Thx for all the help ski. 
06:59:52 <ski> so, really, we have `foo :: forall (n :: Nat). NatIs n -> ..n..', where `n' lives on the type-level, but to be able to pattern-match on this information, a value `NatIs n' is provided as well
07:00:11 <ski> (since we can't case-distinguish on `forall'ed things in Haskell)
07:00:23 <OutlawStar> yes, that does suck :(
07:00:59 <ski> well, i think it's good to have a "blind" version of a universal quantifier
07:01:09 <ski> but it would be nice to also have a non-blind version
07:01:31 <Cooler> ertesx, why do you say that applicative doesn't flatten?
07:01:35 <ski> (where the corresponding application/instantiation wouldn't be implicit)
07:03:40 <ski> Cooler : there is no way to write `join :: Applicative i => i (i a) -> i a', using `pure :: Applicative i => a -> i a' and `(<*>) :: Applicative i => i (a -> b) -> (i a -> i b)'
07:04:10 <ski> Cooler : btw, did you see how one would define `(>>=)' in terms of `join' and `fmap' ?
07:04:46 <Cooler> ski, well fmap just gives you the nested actions that you pass to join
07:04:55 <Cooler> so  join . fmap
07:06:36 <Cooler> x >>= f =  join (fmap f x)?
07:08:04 <Cooler> ski, ^
07:08:43 <merijn> Cooler: Yes
07:09:29 <Cooler> ski, Applicative doesn't have to flatten if it doesn't produce nested stuff in the first place
07:10:07 <MarLinn> Cooler: now try to write join in terms of fmap, pure and (<*>). No bind. Then come back.
07:11:23 <Cooler> MarLinn, but why do you need join? Applicative doesn't even produce any nested actions that you would want to flatten
07:12:16 <Cooler> just sequence actions using <*>
07:12:50 <MarLinn> Cooler: why do I need folds? Integers don't even produce lists!
07:13:15 <Cooler> MarLinn, this is about sequencing things
07:13:25 <Cooler> you can just sequence using <*>
07:13:29 <MarLinn> No.
07:13:52 <MarLinn> Yes, Monads can sequence. But that's just one part of what monads can do
07:16:56 <geekosaur> Cooler, do you understand what differentiates Monad from Applicative? (hint: it's not sequencing /per se/)
07:17:30 <Cooler> geekosaur, no whats the difference
07:17:45 <geekosaur> Monad can *conditionally* sequence
07:18:20 <geekosaur> that is: Applicative can sequence, but it must always perform the same sequence. Monad can inspect the result from the prior action and pick a different subsequent action
07:18:42 <merijn> Cooler: Consider this, how would you do 'x >>= \b -> if b then putStrLn "whoo!" else putStrLn "hmm?"' using applicative
07:19:34 <geekosaur> Applicative can't access that result, it can only pass it on blindly to the next thing
07:19:55 <Cooler> well thats not true
07:20:12 <geekosaur> answer what merijn just asked you before asserting that
07:20:23 <Cooler> instance Applicative Maybe where  
07:20:23 <Cooler>     pure = Just  
07:20:23 <Cooler>     Nothing <*> _ = Nothing  
07:20:23 <Cooler>     (Just f) <*> something = fmap f something  
07:20:31 <Cooler> there you access f
07:20:49 <Cooler> so you can do something there
07:20:50 <ertesx> Cooler: the point is that you can't use a result to construct an *effect*
07:21:07 <ertesx> monads can do that, but applicative functors in general can't
07:21:30 <geekosaur> Cooler, that is an implementation in a single instance. Show me how you do that *for all Applicatives*
07:21:38 <ertesx> Cooler: this simple program is impossible in terms of Applicative:  getLine >>= putStrLn
07:22:02 <Cooler> geekosaur, so you can make decisions sometimes?
07:22:19 <ertesx> (well, i suppose you could use other IO effects like mutable variables to write an equivalent program, but i think, you should see the point)
07:22:20 <geekosaur> also I would argue it is not accessed there, just blindly passed on. it is not *inspected*, and cannot be at the level of Applicative operations. for *specific* instances it can, but not for *all* of them
07:22:32 <geekosaur> also, "sometimes" is not a thing
07:22:48 <ski> Cooler : sorry, was away a bit
07:23:00 <geekosaur> for it to be an aspect of Applicative, it must *always* be possible
07:23:05 <Cooler> geekosaur, so you can make decisions for some applicative functors?
07:23:29 <geekosaur> if it is *sometimes* possible, then the type in question can do something beyond Applicative --- and indeed, Maybe is a Monad as well as an Applicative
07:23:31 <ski> Cooler : i'm not sure what you mean by "Applicative doesn't have to flatten if it doesn't produce nested stuff in the first place"
07:23:37 <geekosaur> this does not mean that Monad is the same as Applicative
07:23:47 <geekosaur> it just means that some Applicatives are also Monads
07:24:00 <ertesx> Cooler: allow me to give you an exercise
07:24:05 <maerwald> Cooler: http://stackoverflow.com/a/17412969
07:24:17 <ertesx> Cooler: you understand state monads?
07:24:19 <Insanity_> Is there such a thing as a conditional fold? As in, if I had the following
07:24:24 <geekosaur> but to say something is possible for Applicative, you must be able to say that that something is possible for *all* Applicatives
07:24:30 <Insanity_> > foldl1 (*) [1..10]
07:24:32 <lambdabot>  3628800
07:24:37 <Cooler> geekosaur, since IO is a monad
07:24:43 <Insanity_> but then on an infinite list, and say "fold until the result is > 1000" or whatever
07:24:52 <Cooler> you should be able to make decisions in its applicative form
07:24:56 <geekosaur> no
07:25:07 <Cooler> just like Maybe
07:25:14 <geekosaur> you can use Applicative when you don't care, you *must* use its Monad instance to make decisions
07:25:23 <geekosaur> Applicative *does not have access to the Monad features*
07:25:28 <ski> ertesx : "well, i suppose you could use other IO effects like mutable variables ..", you'd need bind/`join' to get the reference from `newIORef'
07:25:59 <Cooler> (Just f) <*> something = fmap f something  
07:26:07 <Cooler> what happens if i put a if then else in there
07:26:20 <Cooler> does everything explode?
07:26:22 <maerwald> Cooler: you can make decisions on the value, but not on the effect, since for applicative chains, all effects are run
07:26:31 <geekosaur> you violate the Applicative laws, and things relying on those laws will indeed explode
07:26:47 <ertesx> ski: well, you could go to the level of emulating very basic instructions with a fixed set of named registers, since it's IO
07:26:52 <geekosaur> the laws constitute a guarantee of behavior that is consistent across all Applicatives
07:27:00 <geekosaur> not "some" Applicatives
07:27:10 <ertesx> Cooler: i'll take that as a "no"
07:27:34 <geekosaur> and, again. this does not preclude that some other interface (here, Monad) provides greater access
07:27:38 <Cooler> ertesx, no what?
07:28:04 <ski> Cooler : in `(<*>) :: i (a -> b) -> (i a -> i b)', the `b' from the result can be computed using an `if'-`then'-`else' inside the `a -> b', applied to the `a'
07:28:30 <ski> Cooler : but the point is that the `i' "part" of `i b' can't depend on the `a -> b' and the `a' part of the inputs
07:28:50 <ertesx> Cooler: i wanted to give you an exercise based on state monads
07:29:02 <ski> Cooler : the *structure* of the result computation can't depend on intermediate "return" values computed dynamically during the computation
07:29:09 <ski> Cooler : one way to state it is that idioms (aka applicative functors) are about "static sequencing", while monads are about "dynamic sequencing"
07:29:41 <ertesx> Cooler: because i think discussions don't really help you…  you need to get your hands dirty and bump against Applicative's limitations yourself
07:29:51 <maerwald> I think that becomes pretty clear when using parsers
07:31:00 <maerwald> you can't switch parsers based on values with the applicative parser instance
07:31:20 <Cooler> ertesx, sure
07:31:40 <ertesx> Cooler: get :: State s s;  put :: s -> State s ()
07:31:56 <ertesx> Cooler: in terms of these and Applicative, write the following function:  modify :: (s -> s) -> State s ()
07:31:58 <Cooler> wait
07:32:06 <Cooler> is State already a monad here?
07:32:13 <ski> `State s' is a monad
07:32:16 <ertesx> for all s, (State s) is a monad
07:32:18 <ski> (for any `s')
07:32:26 <ertesx> but you're not allowed to use (>>=) for this exercise
07:32:42 <geekosaur> btw, a good question to ask yourself re [07 14:25] <Cooler> what happens if i put a if then else in there
07:32:43 <ski> (nor `join')
07:33:04 <geekosaur> is: what exactly do you *do* in that if then else, given only what you have available?
07:34:01 <Cooler> (Just f) <*> something = if (f 3 == 4) then (fmap f something) else Nothing
07:34:26 <ski> are you redefining `(<*>)' ?
07:34:32 <Cooler> kind of
07:34:38 <Cooler> what happens there
07:34:47 <ski> it breaks a law
07:34:51 <geekosaur> it "works" but anything that expects <*> to abide by the laws will break
07:34:56 <geekosaur> and you will get incorrect results
07:35:28 <qinusty> Can someone point me in the right direction with a problem I am facing? -- If a do block can only have one single type of IO within it, how can I retrieve data of another type?  I am using Scotty so I am within a function with type 'routes :: ScottyM ()' and I am trying to perform this action from within a do block 'users <- allUsers' where 'allUsers :: IO [User]'
07:35:37 <merijn> Cooler: Also, that doesn't work
07:35:46 <merijn> Cooler: Because <*> has to work for *any* function
07:35:54 <merijn> Cooler: Yours requires 'f' to work on numbers
07:36:00 <ski> `pure f <*> pure x = pure (f x)' is a law. and assuming that `pure' is defined as `Just', that means that `Just (f x) = Just f <*> Just x = if f 3 == 4 then fmap f (Just x) else Nothing = if f 3 == 4 then Just (f x) else Nothing'
07:36:25 <ski> in case `f 3 == 4' is `False', this proves that `Just f x = Nothing', which is a contradiction
07:36:34 <geekosaur> ask yourself what is wrong with a version of (+) that pretends you said x + 5 when you said x + 0.
07:36:46 <opqdonut> qinusty: typically you can "lift" IO actions to actions in fancy monads
07:36:48 <Cooler> merijn, right
07:37:06 <ski> (and it's certainly possible to supply an `f' such that `f 3 == 4 = False'), therefore, it's contradictory to have `Just f <*> something = if (f 3 == 4) then fmap f something else Nothing'
07:37:28 <opqdonut> qinusty: "type ScottyM = ScottyT Text IO", so ScottyM is just a wrapped IO
07:37:36 <tdammers> qinusty: things become a bit clearer when you desugar the do notation and follow the types
07:37:57 <tdammers> e.g.: do { users <- getUsers; respondText (show users) }
07:38:00 <tdammers> becomes:
07:38:10 <tdammers> getUsers >>= \users -> respondText (show users)
07:38:11 <DangerousDav3> Hello, why do I get this error? http://pastebin.com/3Lsj3rxf
07:38:23 <eikke> edwardk: In 'free', is the (Monad m) context of class MonadFree strictly required? This seems to make it... difficult to mix MonadFree with IxMonad :)
07:38:37 <tdammers> however, (>>=) :: m a -> (a -> m b)
07:38:48 <opqdonut> qinusty: it seems you can just call "liftIO getUsers"
07:38:52 <ski> Cooler : a way to think about it is that `foo <*> bar' is only allowed to look at the structure of `foo' and `bar', when determining the structure of the result computation. only the "elements" of the result are allowed to depend on the "elements" of `foo' and `bar'
07:38:55 <tdammers> and in this case, the two 'm' don't match up (the first one being IO, the second one Scotty)
07:38:59 <opqdonut> qinusty: (liftIO is from Control.Monad.IO.Class)
07:39:02 <Cooler> ski, not it proves Just f <*> x = Nothing if f 3 == 4
07:39:03 <ertesx> DangerousDav3: is Int an actual data constructor in your code?
07:39:20 <tdammers> since you want the entire computation to be of type Scotty (), you need to find a function that gives you IO a -> Scotty a
07:39:25 <Cooler> is false
07:39:48 <ski> merijn : "Yours requires 'f' to work on numbers" -- yes, but even if we assume that `(<*>)' could be defined, *somehow*, so that Cooler's identity holds (for some numeric type), that's contradictory :)
07:40:01 <tdammers> Scotty happens to have an instance of MonadIO, which means that you can use liftIO, which is of type MonadIO m => IO a -> m a
07:40:07 <DangerousDav3> ertesx: Actually I just tried the Int now, It wasn't there before
07:40:23 <geekosaur> you should show the class declaration as well
07:40:48 <Cooler> contradictory in what sense?
07:40:49 <DangerousDav3> ertesx: http://pastebin.com/FaAGxjZy
07:40:54 <DangerousDav3> This is the relevant code
07:40:58 <qinusty> Okay, Sorry I'm just trying to take all of this in :P
07:41:08 <qinusty> My Monad understanding is still a little weak
07:41:12 <DangerousDav3> I don't understand why I am keeping get errors
07:41:14 <Cooler> ski, Just f <*> x = Nothing if f 3 == 4 is false
07:41:18 <DangerousDav3> I think its a bug
07:41:24 <Cooler> whats contradictory about it?
07:41:30 <geekosaur> DangerousDav3, you haven't said there what `knowledge` is
07:41:43 <tdammers> qinusty: the trick about understanding monads is to realize how little there is to understand
07:41:51 <geekosaur> you cannot, with what is given there, assert a specific shape for `knowledge`; it is specified by the caller, not by you
07:41:52 <ski> Cooler : yes, it proves that if `f 3 == 4 = False', then `Just (f x) = Nothing' (also using a law of `Applicative'). and you can certainly pick a suitable `f' to satisfy the precondition
07:42:04 <geekosaur> this is not a bug
07:42:18 <DangerousDav3> Its a general type that should be infered
07:42:37 <Cooler> ski, where are you getting Just (f x) = Nothing from?
07:42:39 <Cooler> its Just f <*> x = Nothing
07:42:46 <ski> Cooler : pick your `something' as my `Just x'. then by a law, `Just f <*> Just x = Just (f x)'
07:42:54 <tdammers> qinusty: or, if you prefer, it is possible to use monads correctly just by applying their formal rules, no understanding required - after all, Monad is just another typeclass, the only thing that's special about them is do notation, which is just syntactic sugar over >>= and >>
07:43:06 <ertesx> DangerousDav3: only arguments to the type class are chosen by the instance
07:43:14 <prsteele> Cooler: just to be clear, you've read the laws in https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html ?
07:43:17 <Cooler> ski, well i mean this wasn't written with the laws in mind
07:43:30 <qinusty> Yeah I guess, >>= and >> Were never explained in my classes and we were taught only do which doesn't really help I guess
07:43:32 <ertesx> DangerousDav3: the type 'knowledge' is chosen by the user of the member functions
07:43:35 <qinusty> gotta relearn
07:43:41 <geekosaur> DangerousDav3, no, it cannot be inferred because the type signature does not permit it. it does not specify what `knowledge` is, therefore you cannot assume anything about it.
07:43:44 <ski> Cooler : right, but it can't be a valid instance of `Applicative' if the laws are not satisfied
07:44:27 <ertesx> DangerousDav3: i find your class a bit confusing…  shouldn't 'classifier' and 'knowledge' be the same type?
07:44:42 <DangerousDav3> no
07:44:55 <maerwald> the applicative lawyer :P
07:44:56 <DangerousDav3> Classifier return knowledge after the training
07:45:06 <DangerousDav3> for each classifier the knowledge can be different
07:45:09 <DangerousDav3> so how should I do it?
07:45:39 <DangerousDav3> by adding type to the class?
07:45:50 <DangerousDav3> and MultiParamTypeClasses?
07:45:55 <DangerousDav3> or how should I do it :|
07:46:08 <ertesx> DangerousDav3: there are a few ways to do it properly…  one is the ugly h2010 way of overspecifying what "[x]" and "[y]" actually are
07:46:26 <ertesx> the other one is the in my view proper way, but it requires language extensions
07:46:40 <Cooler> ertesx, what does modify do?
07:46:56 <ertesx> Cooler: get the state and put a modified state using the given function
07:46:58 <ski> Cooler : modifies the implicit state by the given function
07:47:02 <Cooler> looks at the state, gives you a new one and puts it?
07:47:15 <ertesx> Cooler: just puts it
07:47:30 <ertesx> Cooler: here is the monadic semantics:  modify f = get >>= put . f
07:47:36 <ski>   modify f = do s <- get; put (f s)
07:48:41 <qinusty> Okay, I've got that sorted tdammers opqdonut. Thanks for the explanations! Another quick one if thats okay. If I wanted a data type data User = User {...} to have a field which could potentially be Null, would I use Maybe?
07:48:49 <ertesx> DangerousDav3: is this an early haskell project of yours?  i.e. are you still learning?
07:49:06 <DangerousDav3> ertesx: Yes
07:49:17 <prsteele> qinusty: yes
07:49:19 <ertesx> DangerousDav3: then i strongly suggest that you don't use a class at all for now
07:49:20 <ski> qinusty : "which could potentially be Null" -- for what reason ?
07:49:20 <tdammers> qinusty: yes. Null is called Nothing though.
07:49:42 <qinusty> ski: Databases and values which aren't required
07:49:49 <qinusty> Cheers guys
07:49:51 <ertesx> DangerousDav3: this is one of the surprisingly rare cases when a type class really makes sense, but unfortunately it requires a bit of haskell experience to design properly
07:49:53 <ski> ok, then yes
07:50:09 <tdammers> qinusty: depending on the situation, there are other ways of modeling it, but in this case, Maybe is arguably the most straightforward
07:50:39 <qinusty> tdammers: Yeah, just tested it and Maybe seems to be automatically handled by aeson
07:51:05 <ertesx> DangerousDav3: currently your goal should be to understand polymorphism and parametricity properly (who gets to choose which types for polymorphic functions)
07:51:51 <ertesx> DangerousDav3: may i give you an exercise?
07:52:19 <DangerousDav3> ertesx: OK
07:52:35 <ertesx> DangerousDav3: are you familiar with (map :: (a -> b) -> [a] -> [b])?
07:52:45 <DangerousDav3> sure
07:53:34 <ertesx> DangerousDav3: write any function (wrongMap :: (a -> b) -> [a] -> [b]) that does something other than 'map'
07:54:03 <ertesx> your exercise is to list the ways you can get 'map' wrong
07:54:35 <ski> (`wrongMap' total ?)
07:54:54 <ertesx> uh, yeah, it should be total (no infinite loops)
07:55:43 <DangerousDav3> ertesx: wrongMap func x = x?
07:55:43 <c_wraith> ertesx: I can get it wrong infinitely many different ways. :P
07:55:54 <c_wraith> DangerousDav3: doesn't compile.  Test it out to see why. :)
07:55:55 <ertesx> DangerousDav3: that's a type error
07:56:14 <ertesx> c_wraith: but there is a nice finite summary list of the ways you can get it wrong =)
07:56:39 <Cooler> modify f = (pure put) <*> (fmap f get)
07:56:46 <Cooler> i don't even know
07:56:46 <athan> Anyone here use repa much?
07:57:10 <ertesx> Cooler: make sure the type checker is okay with your solution =)
07:57:20 <athan> It's just not clear to me when I should use `deepSeqArray` - after I run `computeP`, or before? (when I convert from an unboxed vector)
07:57:23 <Cooler> :t (pure put) <*> (fmap f get)
07:57:24 <lambdabot> (FromExpr a, MonadState a1 f, MonadState a m, Show a1) => f (m ())
07:58:01 <ertesx> :t \f -> pure put <*> fmap f get
07:58:03 <lambdabot> (MonadState a1 f, MonadState a m) => (a1 -> a) -> f (m ())
07:58:20 <ertesx> how unfortunate
07:58:33 <Cooler> wha?
07:58:45 <Cooler> it works right?
07:58:51 <ertesx> @let myGet :: State s s; myGet = get
07:58:53 <lambdabot>  Defined.
07:58:54 <DangerousDav3> ertesx: assuming the function is not the identity
07:59:05 <ertesx> @let myPut :: s -> State s (); myPut = put
07:59:07 <lambdabot>  Defined.
07:59:12 <prsteele> DangerousDav3: imagine you're writing unit tests for map
07:59:14 <ertesx> Cooler: use myGet and myPut instead
07:59:28 <ertesx> :t \f -> pure myPut <*> fmap f myGet
07:59:30 <lambdabot> (a1 -> a) -> StateT a1 Identity (State a ())
07:59:37 <Cooler> modify f = (pure myPut) <*> (fmap f myGet)
07:59:44 <ertesx> Cooler: doesn't look quite right
08:00:23 <ertesx> DangerousDav3: the type system doesn't let you make assumptions
08:00:32 <DangerousDav3> ertesx: ic ic
08:00:42 <ertesx> DangerousDav3: but there are ways to get it wrong
08:00:46 <tdammers> qinusty: correct. There's instance ToJSON a => ToJSON (Maybe a), and the same for FromJSON
08:00:55 <ertesx> DangerousDav3: try to come up with one or two
08:00:57 <DangerousDav3> ertesx: reverse map func x?
08:01:04 <tdammers> similar things exist for other * -> * types, such as lists and tuples
08:01:13 <ertesx> DangerousDav3: with proper parentheses, yeah, that would be one
08:01:17 <athan> I just can't seem to get around the warning :\
08:01:25 <DangerousDav3> take 1?
08:01:26 <Cooler> ertesx, your gonna have to be more specific
08:01:45 <ertesx> DangerousDav3: yeah, you get the idea…  the problem is that 'map' can't make *any* assumptions about the types 'a' and 'b'
08:02:05 <ertesx> DangerousDav3: since it doesn't know anything about them, all it can really do is, given an 'a', apply the given function to it
08:02:06 <Cooler> ertesx, i am not even sure what <*> in terms of State s
08:02:14 <Cooler> is*
08:02:30 <DangerousDav3> OK but I didn't make any assumption about knowledge
08:02:42 <ertesx> Cooler: it composes two State actions threading the state
08:03:02 <DangerousDav3> I just want it to be a general type that will accept each one of the classifiers knowledge
08:03:11 <jstolarek> um... does `cabal install` build the whole project even if I just did `cabal build` ?
08:03:20 <ertesx> DangerousDav3: train (KNN k norm) x y = (x, y, length y)
08:03:33 <ertesx> that's an assumption:  you assumed 'knowledge' to be a tuple type
08:03:37 <athan> Can anyone see anything immediately wrong with this repa code, other than it's appeal? http://lpaste.net/185976
08:03:49 <athan> I'm just getting spammed with the "use deepSeqArray!" warnings :(
08:04:07 <athan> in the `target` block, I'm excessively using deepSeqArray though
08:04:21 <athan> and it's the only place where I actually invoke computation
08:04:39 <Cooler> modify f = fmap put (fmap f myGet) :: (s -> s) -> State s (State s ())
08:05:05 <ski> Cooler : yeah, and now you're lacking `join :: Stats s (State s ()) -> State s ()'
08:05:16 <Cooler> right
08:05:32 <DangerousDav3> ertesx: Well usually in programming the "instance" class can make the methods return value more specific but not the opposit
08:05:46 <ertesx> DangerousDav3: type classes are not OOP
08:06:32 <Cooler> actually its modify that has that type signature not modify f
08:06:50 <DangerousDav3> ertesx: So I don't get it, should I now create type Classifier = KNN | Linear | ID3?
08:07:20 <saurabhnanda> broadcasting again. Need help with designing a type-safe domain API -- https://www.reddit.com/r/haskell/comments/51kzdu/how_to_write_a_domain_api_with_pragmatic_type/
08:07:46 <ertesx> DangerousDav3: no, the class is fine…  just understand that it's not an OO mechanism, but rather just a fancy way to pass arguments implicitly to functions
08:07:55 <ertesx> DangerousDav3: i suggest that you redesign it for now
08:08:05 <mizu_no_oto_work> DangerousDav3: do you understand how typeclasses differ from OO?
08:08:20 <hoppfull> Hello. How can I get the compiler to warn me when I've got unexhausted pattern matching?
08:08:22 <ertesx> DangerousDav3: class Classifier c where train :: [Double] -> [Double] -> c -> c  -- given a model, improve it using the given sample
08:08:26 <DangerousDav3> As you can see how ethusiastic I am you can understand its a project that has to be done and isn't just for my curiosity :)
08:09:21 <ertesx> DangerousDav3: i understand that, but learning haskell with a deadline may go wrong, unless you have prior experience with a statically typed lazy functional language =)
08:09:22 <DangerousDav3> mizu_no_oto_work: I understand, what I do not understand is how to write it properly and not just by arbitrary functions
08:09:39 <ertesx> DangerousDav3: so the proper way to write this one is using associated types
08:10:50 <DangerousDav3> ertesx: Oh, we didn't learn it :P but it seems cool, I might use it in my project
08:11:26 <ertesx> class Classifier c where type Ctx c; type In c; type SampleOut c; type Out c; genModel :: Ctx c -> IO c; train :: Ctx c -> In c -> SampleOut c -> c -> c; predict :: Ctx c -> c -> In c -> Out c
08:11:28 <ertesx> something like that
08:11:48 <ertesx> you can add more members as you need more generic functionality (most likely the cost function)
08:11:54 <DangerousDav3> I have a nice crazy profesor which is genius but kind of astronaut
08:11:59 <DangerousDav3> :P
08:12:38 <ertesx> (Ctx c), given a classifier type c, is the context type…  it may contain configuration data, a set of all samples if appropriate, etc.
08:13:22 <ertesx> for example if c is logistic regression, you might consider adding the stretch factor of the logistic function to Ctx c…  it's useless, but i couldn't think of a better example
08:14:27 <hoppfull> In F# I can spend my initial development stage just setting up the types without implementing anything. I can't compile however. In haskell I have to compile or load into GHCi. But if I have types declarations with missing implementations, I can't compile.
08:14:31 <DangerousDav3> Well I am working on 30 lines of code for two days :P
08:15:10 <DangerousDav3> ertesx: http://stackoverflow.com/questions/39352792/haskell-polymorphism-and-typeclass-instance thats the previous answers I got, seems like I was mislead
08:15:40 <Cooler> i never understood why some people measure productivity by number of lines of code
08:15:50 <Cooler> seems stupid
08:15:58 <Insanity_> ^ +1 
08:16:03 <mnoonan> only good when it's negative
08:16:16 <geekosaur> metrics are a substitute for thinking
08:16:24 <geekosaur> too many people consider that important
08:16:29 <ertesx> DangerousDav3: the answer by n.m. is the closest to what i'm suggesting
08:16:32 <prsteele> don't forget measurable
08:16:46 <ertesx> DangerousDav3: except i'm suggesting associated types (a.k.a. type families) instead of multi-parameter type classes
08:16:57 <hoppfull> Cooler: Or even how many problems they've solved. It's infuriating when someone says they've solved a bunch of problems but they only stitched stuff together and broke the architecture completely. They're called "duct-tape programmers" I believe.
08:17:14 <DangerousDav3> Cooler: Don't you see the correlation? If you write one line a month don't you think there is a problem? there is a limit to the time for learning and understanding things you have.
08:17:29 <ertesx> DangerousDav3: not if you write perl or APL
08:17:38 <Insanity_> hoppfull: an interesting thing to mention along with the problems solved, would be the problems created by their 'solutions' in that case :D
08:17:40 <DangerousDav3> perl for sure :P
08:17:42 * hackagebot docker 0.3.0.1 - An API client for docker written in Haskell  https://hackage.haskell.org/package/docker-0.3.0.1 (denibertovic)
08:18:05 <ertesx> one screen line of perl or APL can make saturn's ring flip
08:18:15 <hoppfull> Insanity_: "99 problems. One solved. Only 117 problems left."
08:18:27 <Insanity_> Exactly ^^
08:19:24 <tdammers> a.k.a. "99 little bugs in the code"
08:21:05 <hoppfull> That's why I'm rushing to learn Haskell. I've done some F# and it's great how you can program for correctness but I expect haskell to be better at it. I've got an internship at a small company that produces apps in C#. It's awful and I figure if I do my examination project in haskell, maybe I can find a first job with Haskell or F# out there.
08:22:07 <spirit1> did anyone work with ghcjs?
08:22:25 <spirit1> can i make ala browser engine with it?
08:22:37 <Insanity_> hoppfull: they are two quite different things. C# is getting some elements of FP, but it's still pretty much an OO language. 
08:23:02 <hoppfull> spirit1: I haven't but I would recommend taking a look at PureScript if you want a haskell for the browser.
08:23:14 <spirit1> i need to interact with server side js
08:24:55 <hoppfull> Insanity_: I'd say C# is the best OO language I've worked with but code is still riddled with assumptions and if the other programmers on the team doesn't have discipline or doesn't understand that their Captain Kirk style of programming is going to screw us in the long run, I can't do anything about it. I just have to sit there and wait for the disaster to hit.
08:25:43 <Insanity_> Yeah, for OO languages, C# is also my favourite. Feels like the most modern one (that is actively used) 
08:25:52 <nitrix> Given the category `C`, the objects `a` and `b` and the morphisms `id_a :: a -> a`, `f :: a -> b`, `id_b :: b -> b`, I can obtain the left-identity `id_a ∘ f` and the right-identity `f ∘ id_b`, my question is: Is there a case where the left and right identities are isomorphic?
08:26:13 <nitrix> Like, from and to the same object or Or at least, very similar?
08:26:34 <ski> nitrix : both are equal to `f'
08:26:54 <ph88> can someone help me test this with QuickCheck ?   https://paste.fedoraproject.org/423339/32509331/
08:26:58 <ski> (also itym `f :: b -> a', with the standard order of composition)
08:27:18 <tenniscp25> Regarding conduit, if I have a source: CC.stdin, how can I split it line by line? How to use CC.lineAscii to solve this?
08:27:26 <ski> nitrix : .. so i'm not sure what you mean by "Is there a case where the left and right identities are isomorphic?" -- unless you're talking about `n'-categories ..
08:27:52 <nitrix> ski: Sorry, so yeah, then they are isomorphic. Are there cases where they both left and right are literally identical?
08:28:01 <ertesx> hoppfull: C# and F# are actually quite similar
08:28:53 <ertesx> which means that unfortunately they share the same limitations
08:29:07 <nitrix> ski: As in, starting from the same objects, finishing with the same objects, such as left and right ends up being repetitively the same thing, like composing with identity 3 times or something?
08:29:16 <hoppfull> ertesx: They seem very different to me. On a syntax level that is. They both compile to the same stuff behind the scenes ofcourse.
08:29:37 <ertesx> as a haskell programmer the number one thing i miss in those languages is arbitrary-kind polymorphism
08:30:08 <ertesx> regardless of what everybody says, no, F# does not have monads
08:30:17 <tenniscp25> oh i think i've found it, use CB.lines..
08:30:17 <nitrix> ski: When you have `id_a . id_a . id_a` and `id_a . id_a`. How do you distinguish left/right ?
08:30:21 <ertesx> not in any *useful* way
08:30:23 <nitrix> ski: Is kinda what I'm getting at.
08:31:34 <ski> nitrix : in a category, left and right identify is the same thing
08:31:39 <hoppfull> ertesx: That is one of the reasons I came over to Haskell is to learn these concepts like Monads. What I am missing is the ability to work on type declarations only and testing if they hold before I do implementations. I can do that in F# and I hope I can do it in Haskell.
08:31:59 <ski> nitrix : .. similar to the case in a monoid
08:32:05 <prsteele> hoppfull: you can always do f :: a -> b; f x = undefined
08:32:18 <nitrix> ski: So the notion of left/right is just denotational? It doesn't actually have any influence?
08:32:18 <prsteele> hoppfull: that will let you compile and run the type-checker
08:32:25 <ertesx> hoppfull: GHC-haskell has quite a few things to help you there, most notably typed holes
08:32:27 <hoppfull> prsteele: Cool!
08:32:37 <hoppfull> ertesx: Interesting
08:32:40 <Cooler> DangerousDav3, theres no correlation that is strong enough in the general case
08:32:51 <ertesx> f x = _y  -- GHC recognises this as "hole" and tells you what type _y is supposed to have
08:32:56 <Cooler> DangerousDav3, your citing an extreme case
08:33:05 <ertesx> that way you can start with a small template and complete it piece by piece
08:33:19 <ertesx> you can even run the code and make it abort at run-time once a hole is reached
08:33:36 <Cooler> DangerousDav3, also one line of code can be very complex and do a ton of stuff
08:33:57 <ski> nitrix : assume that there is an `l' with `l * x = x' for any `x', and also that there is an `r' with `x = x * r' for any `x'. then `l = l * r = r', picking `x' in the first property as `r' and in the second proerty as `l'
08:34:24 <NickHu> "lines" are stupid anyway, just join up all the lines of a C program (excluding cpp) then you have hugely complex near-single line programs
08:34:33 <ski> nitrix : so, if there's both a left neutral element `l' and a right neutral element `r' for any binary operation `*', then `l' and `r' must be equal
08:34:53 <tdammers> DangerousDav3: https://www.youtube.com/watch?v=f84n5oFoZBc
08:34:54 <nitrix> ski: Gotcha.
08:34:54 <ski> nitrix : and the same argument goes through in the category case, even with the more general types
08:34:57 <hoppfull> ertesx: I think that isn't what I'm trying to achieve. In F# I can create header files with nothing but type declarations and I can work on my whole program and organize all the types. Visual Studio tells me if something doesn't hold up. I can't compile but I can still see if my types are consistent. I think the f x = undefined trick will do for now.
08:35:06 <nitrix> ski: Appreciated.
08:35:18 <tdammers> DangerousDav3: programming is not about writing code. Programming is about thinking.
08:35:26 <ertesx> hoppfull: i'd still go with f x = _y, because that emits warnings
08:35:36 <ski> (nitrix : i don't see what you mean by "is just denotational" in "So the notion of left/right is just denotational? It doesn't actually have any influence?" -- what notion of left/right ? the notion of left/right neutral element ?)
08:35:38 <ertesx> hoppfull: at least with the -fdefer-typed-holes flag
08:36:09 <ertesx> hoppfull: a hole has the same semantics as 'undefined', but emits warnings that tell you the inferred type of the hole
08:36:25 <nitrix> ski: Well, my intuition tells me, since it's identity, it's commutative, so why even bother with the concept of left or right?
08:36:57 <hoppfull> ertesx: Compiler doesn't seem to complain when I've got unexhaustive pattern matching. Is there a flag to enable that?
08:37:10 <ertesx> hoppfull: i use -W
08:37:18 <ertesx> others use -Wall, which is noisier
08:38:00 <hoppfull> ertesx: Cool. That's what I needed!
08:38:09 <nitrix> ski: It only really makes sense when you use a notation to write them down, but other than that, I'm not sure I see the intent yet.
08:39:37 <DangerousDav3> tdammers: summary programming in one word is wrong
08:39:51 <sebboh> The downloads section on haskell.org indicates that I can run the platform on windows, OS X, or linux.  Are these all equal citizens?  If I pick one over the other, will I encounter problems?
08:40:08 <NickHu> sebboh: If you pick windows say bye bye to any POSIX standards
08:40:14 <NickHu> But that's not a Haskell issue
08:40:32 <c_wraith> sebboh, most libraries that use native code work best on linux
08:40:53 <c_wraith> sebboh, and windows has some issues with IO concurrency
08:41:03 <sebboh> NickHu: you're saying that when I open a socket or a file handle or allocate some memory, I'll have to do it differently on Windows.  Ok.
08:41:14 <sebboh> c_wraith: I see
08:41:33 <ertesx> sebboh: the APIs are rather portable, so likely not, but there are some caveats with windows
08:41:51 <c_wraith> sebboh, not that IO concurrency breaks on windows - it's just way slower. 
08:42:23 <sebboh> Ah, sounds like some guarantee was provided the hard way?
08:43:03 <c_wraith> it's mostly that no one has written a port of the IO manager that uses IO completion ports. 
08:43:24 <c_wraith> though I think that's actually currently underway, iirc
08:43:24 <sebboh> on Windows, what are the differences between 64bit vs 32bit?
08:43:47 <c_wraith> size of pointers and Int
08:43:47 <sebboh> c_wraith: ok.  I don't know what those words mean just yet, but thank you.
08:44:07 <hoppfull> sebboh: It means you can access more memory, I think.
08:44:19 <ertesx> sebboh: one notable difference is that Int in haskell disagrees with int in C
08:44:31 <ertesx> sebboh: on 64-bit platforms Int is likely 64 bits
08:44:39 <hoppfull> sebboh: A pointer is an adress to a place in memory. If pointer is too small it can only specify a small set of memory locations.
08:44:44 <sebboh> c_wraith: those differences are expected. :)  Are all libraries available in both 32bit and 64bit forms?
08:44:51 <sebboh> et al
08:45:23 <c_wraith> I suspect a few things using native code might break one way or the other, but very few
08:45:51 <c_wraith> most libraries are pure haskell, and that'll work fine either way. 
08:46:12 <sebboh> ok, cool.
08:46:14 <ertesx> sebboh: once you need bindings to foreign libraries (notably GUI toolkits), things get trickier on windows
08:47:00 <sebboh> Things will be tricky for me at that point, in a platform agnostic manner...  I don't know C. ;P
08:47:04 <ertesx> at least one project (fltkhs) seems to have taken that into account and was specifically designed to be easy to compile on all major platforms
08:48:33 <sebboh> All I want to bind with, that I am aware of, is graphviz.  I read a little about the Haskell graphviz library.  ...As usual, with things in the haskell world, it is clear from page 1 that this library was more carefully constructed than the zoo of its common-lisp counterparts...
08:48:52 <NickHu> Does Integer work on Windows? Afaik it's implemented with libgmp which I don't think exists on Windows
08:48:56 <ertesx> also some libraries simply refuse to work on windows, notably vty
08:49:07 <ertesx> so no vty-ui, no yi, no glirc, etc.
08:49:13 <c_wraith> NickHu, yeah, Integer is fine on windows. 
08:49:22 <NickHu> Is it still using libgmp?
08:49:29 <c_wraith> probably. 
08:49:36 <sm> speaking of, I wish someone would finish the PR supporting vty on windows
08:49:52 <sm> PR/issue
08:50:01 <sebboh> it's traditional to go the cygwin or msys route if you need a tty on windows.
08:50:17 <sm> screw that 
08:50:19 <sm> :)
08:50:20 <NickHu> Has anyone actually tried to use bash on windows lol
08:50:28 <sebboh> I am using bash on windows right now.
08:50:33 <NickHu> any good?
08:50:34 <ertesx> unfortunately then you have cygwin all over the place
08:50:39 <jonored> NickHu: ...Yes, daily, and it works pretty well.
08:50:44 <c_wraith> bash on windows is really good, with one exception 
08:50:46 <ertesx> with awkward translations of unix concepts to windows
08:50:55 <NickHu> c_wraith: No coreutils?
08:50:56 <sebboh> sm: that's why you don't have ... ok clearly this is a long-standing discussion, I'll see my way out of it.  Good luck!
08:51:01 <c_wraith> it doesn't support the timer_create syscall
08:51:16 <jonored> But yes, you do end up with cygwin all over the place. cygwin comes with coreutils.
08:51:17 <ertesx> remember that dude on your birthday party that tried too hard to fit in?  his name is cygwin =)
08:51:22 <c_wraith> and ghc's non-threaded RTS uses that call. 
08:51:23 <hoppfull> Does the lpaste.net/new/haskell work for you?
08:51:56 <NickHu> I remember I used babun when I needed a terminal on windows - I think it's basically a "Just Works TM" cygwin wrapper
08:52:51 <sebboh> for what it is worth, I've never got haskell platform working on Linux, either.  Not enough that I could git clone the sourcecode of git-annex (for example) and just build it.
08:53:06 <ertesx> you can use ansi-terminal for simple cases
08:53:10 <ertesx> that one works on windows
08:53:12 <sm> sebboh: just saying, in the case of vty at least it's high time for that "tradition" to be abandoned, it should just work
08:53:12 <NickHu> sebboh: Use stack
08:53:22 <sebboh> It's probably because I use debian...  What's a popular distro among haskell people?
08:53:33 <NickHu> prolly arch linux
08:53:38 <NickHu> Maybe NixOS
08:53:41 <ertesx> sebboh: Arch, Gentoo, NixOS
08:53:51 <NickHu> I really really want to try NixOS
08:54:10 <ertesx> at least those seem to have the best haskell support
08:54:23 <NickHu> sebboh: If you just want git-annex to work I'm fairly sure he provides statically linked binaries which aren't too bad
08:54:49 <sebboh> I had an affair with Arch.  I went back to Debian and started treating it like Arch... just getting in there and altering things, even outside of /etc and /home...  It was like a breath of fresh air.  Debian taught me to be a responsible sysadmin, Arch taught me to love my PC again
08:55:13 <ertesx> hehe
08:55:16 <sebboh> NickHu: I'd like to be able to build it.
08:55:17 <lpaste> hoppfull pasted “Exhaustive pattern matching?” at http://lpaste.net/185999
08:55:18 <ertesx> NickHu: well, just try it
08:55:44 <hoppfull_> Could I get some clarification on this: http://lpaste.net/185999
08:55:57 <ertesx> hoppfull: the first one is exhaustive, but the compiler has no way to know that, because it would have to solve the halting problem
08:56:02 <NickHu> ertesx: There was one clinching thing that was putting me off but I forgot why now
08:56:17 <ertesx> hoppfull_: with guards you *always* need a catch-all case
08:56:18 <NickHu> I think I read something about the symlink hell that is /nix
08:56:49 <saurabhnanda> really meta question -- is it possible to "tag" a type with multiple "properties/traits" and then write functions that work with any combination of those "properties/traits". For example, can I tag an Order with Paid/Unpaid AND Shipped/NotShipped/PartlyShipped AND Open/Completed/UnderReview/Rejected/Cancelled? And then write a function called `refundOrder` that will work with (Paid, NotShipped, Open/UnderRev
08:56:50 <saurabhnanda> iew/Rejected/Cancelled)?
08:56:51 <ertesx> NickHu: that's how it's designed, but why do you care?
08:57:09 <NickHu> Oh, I remembered now
08:57:26 <NickHu> I'm currently working a lot with docker, and NixOS docker support is supposed to be kinda crap
08:57:41 <Cooler> if i have a function parse :: String -> Maybe Int and putStrLn String -> IO ()
08:57:44 <NickHu> And also I'd have to learn nixexpressions to be able to package things
08:57:56 <hoppfull_> ertesx: ok. *sad and disappointed*
08:58:04 <Cooler> if i have a function parse :: String -> Maybe String and putStrLn String -> IO ()
08:58:18 <Cooler> and i do fmap putStrLn parse
08:58:22 <ertesx> NickHu: i can't say that i've done anything major with docker, but i have the daemon running, and it runs my containers just fine
08:58:31 <NickHu> Cooler: You can't, because they're different functors
08:59:00 <sebboh> ertesx: the abstraction provided by those symlinks is done wrong in my opinion... symlinks are not the building material that should be used for that.  Needs to be something lower level.  Why not some feature of modern filesystems, those fancy CoW snapshots seem up to the task..
08:59:03 <ertesx> NickHu: yeah, nix is like haskell in that regard: it really wants you to learn
08:59:23 <Gurkenglas> Screeps is a game where you define a function in javascript that is run in each frame of an mmo. Your API is some objects, given here: http://support.screeps.com/hc/en-us/articles/203084991-API-Reference . Is there a way to use ghcjs or something to provide Haskell code instead?
08:59:47 <implementation> saurabhnanda: sounds like you're looking for "extensible records". alternatively you can just give all of those types a field like "isPaid" and a class HasIsPaid or something like that. But probably you don't even need that. Plain old functions go a long way.
08:59:47 <Cooler> NickHu, well fmap :: (a -> b) -> (f a -> f b)
08:59:58 <Cooler> i am assuming b = IO ()
09:00:17 <ertesx> sebboh: in this case it's really the symlinks that you want, because semantically these are in fact references, not copies
09:00:26 <ertesx> sebboh: the paper explains this in greater detail
09:01:06 <saurabhnanda> implementation: the record already has an orderState, paymentState, and shippingState. how to use typeclases to achieve what I want?
09:01:23 <NickHu> Cooler: No, you have f = Maybe = IO which doesn't unify
09:01:45 <Cooler> NickHu, f = a -> b
09:01:56 <Cooler> a = String and b = IO (0
09:01:58 <Cooler> ()*
09:02:17 <Cooler> f = putStrLn
09:02:29 <sebboh> ertesx: perhaps real world use of symlinks has deviated from the intended purpose, over the years...
09:02:35 <Cooler> fmap putStrLn parse
09:02:50 <Gal3rielol> hi, has anyone ever used the tracer HAT?
09:02:53 <sebboh> Thanks all for your guidance.  I'm trying Stack on windows, wish me luck!
09:03:05 <NickHu> Cooler: The actual signature for fmap is this: fmap :: (Functor f) => (a -> b) -> f a -> f b
09:03:05 <ReinH> Cooler: that's a type error
09:03:06 <ertesx> sebboh: good luck =)
09:03:11 <Rudes__> Gal3rielol: link?
09:03:20 <implementation> saurabhnanda: if it's only one record, then what is the matter? you can just access orderState, paymentState and shippingState in the function. If you want it to work for all types that carry that information, an aedaquate typeclass would look like   class RefundInformation a where genericOrderState :: a -> OrderState; genericPaymentState :: a -> PaymentState, etc.
09:03:26 <Gal3rielol> http://projects.haskell.org/hat/
09:03:28 <Cooler> ReinH, whats the error?
09:03:31 <ReinH> Try it
09:03:40 <ReinH> I'm not your compiler
09:03:46 <NickHu> putStrLn :: String -> IO ()
09:04:10 <NickHu> String -> IO () can't unify with (a -> b)
09:04:16 <Cooler> putStrLn = f :: a -> b
09:04:30 <Cooler> a = String and b = IO ()
09:04:30 <Gal3rielol> just want to know how to build a cabal project using hat-make
09:04:31 <NickHu> It could however unify with (Functor f) => (a -> f b)
09:04:36 <saurabhnanda> implementation: larger context -- https://www.reddit.com/r/haskell/comments/51kzdu/how_to_write_a_domain_api_with_pragmatic_type/
09:04:48 <implementation> saurabhnanda: but IMHO it would be better to write a record like RefundInformation, that contains exactly and only those information bits that you need to provide, and then write conversion functions like Xyz -> RefundInformation, and call (refundOrder . getRefundInformation)
09:05:15 <Gal3rielol> what could be wrong if ghc prompts `Could not find module ...`
09:05:21 <ReinH> Cooler: there's no point in arguing with us. Argue with your compiler.
09:05:32 <ski> nitrix : composition of morphisms in a category is in general not commutative, even in the cases where it's meaningful to ask the question
09:05:37 <NickHu> oh no wait I'm mistaken, you can unify it like that
09:05:43 <Cooler> so fmap putStrLn parse would be :: Maybe \(IO ())
09:05:49 <Cooler> so fmap putStrLn parse would be :: Maybe (IO ())
09:05:51 <NickHu> :t fmap putStrLn
09:05:53 <lambdabot> Functor f => f String -> f (IO ())
09:06:00 <ReinH> No it would not.
09:06:07 <ReinH> Try it, stop guessing.
09:06:38 <shachaf> Guessing is fine, as long as you also try it.
09:06:43 <NickHu> Cooler: You're missing a composition in there
09:06:52 <NickHu> :t fmap putStrLn . parse
09:06:53 <lambdabot> error:
09:06:53 <lambdabot>     Variable not in scope: parse :: a -> f String
09:08:01 <NickHu> @let parse :: String -> Maybe String; parse = return
09:08:03 <lambdabot>  Defined.
09:08:06 <NickHu> :t fmap putStrLn . parse
09:08:07 <lambdabot> String -> Maybe (IO ())
09:08:10 <Cooler> NickHu, right
09:08:17 <Cooler> so fmap putStrLn . parse would be :: Maybe (IO ())
09:08:25 <ReinH> Yes, that type checks.
09:08:31 <NickHu> No, it's String -> Maybe (IO ())
09:08:34 <ReinH> No it would not.
09:08:48 <Cooler> yeah  String -> Maybe (IO ())
09:08:51 <ReinH> You have a compiler. Use it.
09:09:00 <nitrix> ski: Yeah someone on another channel did a good job explaining it.
09:09:04 <nitrix> ski: I appreciate your time.
09:10:17 <ski> nitrix : good. np
09:13:52 <sebboh> This stack.exe with hardcoded paths is stupid.  I can work around it using environment variables--but only those specified by microsoft, so changing them would affect other software.
09:14:29 <Cooler> ReinH, it gave an error but i am not sure i understand
09:14:35 <Cooler> test = fmap putStrLn . parse
09:14:42 <Cooler> parse s = Just s
09:15:05 <Cooler> why does it give an error saying it expects a String -> IO String?
09:16:03 <ReinH> Show the code and the error in a paste please.
09:16:31 <MarcelineVQ> @where lpaste
09:16:31 <lambdabot> http://lpaste.net/
09:16:52 <Cooler> Down for maintenance!
09:17:02 <MarLinn> You're "not sure" means you have a theory! Have you tried testing it?
09:17:11 <Cooler> parse :: String -> Maybe String
09:17:12 <Cooler> parse s = return s
09:17:12 <Cooler> test :: String -> IO ()
09:17:12 <Cooler> test = fmap putStrLn . parse
09:17:12 <Cooler> main = test "Hello"
09:17:13 <ReinH> : fmap putStrLn . Just
09:17:19 <ReinH> Don't paste here.
09:17:27 <MarcelineVQ> well any paste site, that's just the typical one :>
09:17:44 * hackagebot git-annex 6.20160907 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160907 (JoeyHess)
09:17:46 * hackagebot darcs 2.12.2 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.12.2 (GuillaumeHoffmann)
09:17:46 <ReinH> :t fmap putStrLn . Just
09:17:52 <lambdabot> String -> Maybe (IO ())
09:18:34 <ReinH> But no, that does not work.
09:18:49 <[k-_> main needs to be IO () but test "hello" is Maybe (IO ())
09:19:12 <ski> (actually `main' can have type `IO t' for any type `t' (value ignored))
09:19:22 <Cooler> ReinH, http://pastebin.com/TbAkLaZu
09:19:44 <ReinH> It's as [k-_ says
09:20:03 <Cooler> you keep saying no, i am asking why
09:20:18 <ReinH> Because of what [k-_ just said
09:20:43 <ski> your `parse' returns a `Maybe' thing. then `fmap'ping `putStrLn' will give you an `IO' thing inside that `Maybe'
09:20:52 <ski> which is not what `main' expects
09:21:58 <ski> presumably what you want to do it, to check the result of `parse', handle the `Nothing' and the `Just' case separately, possibly using `putStrLn' in the `Just' case
09:22:16 <ski> you can do this with a helper function, pattern-matching on the `Maybe'
09:22:24 <ski> or directly, using a `case' expression
09:23:12 <ski> (there's also library functions like `maybe',`fromMaybe',`mapM_',`forM_', which could be used here)
09:26:29 <NickHu> Does anyone happen to know why XMonad doesn't seem to have seen much development for near 5 years?
09:26:47 <ReinH> It's perfect.
09:26:55 <prsteele> NickHu: I don't, but are there features you want? I don't have any problems with it
09:27:17 <NickHu> No, not really - just curious; I had considered that maybe it was just "finished"
09:27:33 <NickHu> Maybe Wayland support? idk
09:29:08 <mniip> :t mapM
09:29:09 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
09:30:26 <Cooler> ReinH, http://pastebin.com/PY4VYqw0
09:30:42 <hoppfull_> How can I check in GHCi if type a inherits from typeclass b?
09:31:03 <prsteele> hoppfull_: :i t ?
09:31:11 <prsteele> hoppfull_: with the relevant typeclass in scope?
09:31:13 <implementation> what are you talking about? types cannot inherit from typeclasses
09:31:15 <ReinH> Cooler: extract (Just x)
09:32:14 <ReinH> extract Just x is two arguments, Just and x
09:32:21 <Cooler> yeah that works
09:32:29 <Cooler> right
09:32:35 <hoppfull_> prsteele: Thanks. I'm struggling a little with the type system so I need information on what's going on.
09:32:40 <Cooler> so it does work
09:33:02 <Cooler> my point is that sometimes you don't want to collapse
09:33:28 <ReinH> Ok
09:33:38 <Cooler> if you are dealing with multiple Functors you want the context from all of them instead of collapsing into one IO a
09:33:50 <ReinH> Ok
09:34:09 <Cooler> so you want a Maybe(IO ()) instead of >>=
09:34:22 <ReinH> Sometimes, sometimes not.
09:34:33 <NickHu> It depends on what you are doing
09:34:40 <Cooler> well if its Maybe(Maybe(Maybe(a)))
09:34:46 <Cooler> then you probly want to collapse
09:34:53 <NickHu> It depends on what you are doing
09:34:58 <ReinH> Sometimes, sometimes not.
09:35:16 <Cale> hoppfull_: :info TypeName  should give you a list of the instances of type classes for a given type (that are in scope)
09:35:18 <Cooler> but if its Maybe(IO([a]))
09:35:18 <NickHu> Btw you should probably use monad transformers instead of Maybe (IO ())
09:35:25 <Cooler> then you don't want to collapse
09:35:25 <prsteele> Cooler: ... are you looking for a monad transformer stack? Like MaybeT IO
09:35:45 <ReinH> Cooler: sometimes, sometimes not.
09:36:00 <MarLinn> prsteele: Cooler is looking for excuses to not learn about join
09:36:03 <Cooler> ReinH, well if its different functors then always not
09:36:10 <ReinH> Disagree.
09:36:18 <monochrom> You know, I could add a whole new dimension to this.
09:36:22 <ReinH> Clearly you collapsed them.
09:36:23 <implementation> MaybeT (MaybeT (MaybeT Identity))
09:36:33 <monochrom> Sometimes "collapses" means sequence. Sometimes not.
09:36:36 <NickHu> prsteele: He's trying to understand the difference between applicatives and monads
09:37:13 <Cooler> not i am trying to see if you can get away without never collapsing
09:37:17 <Cooler> with*
09:37:26 <Cale> Cooler: "collapse" is probably not the right way to think about it
09:37:26 <NickHu> It just means different things
09:37:50 <NickHu> It's like saying "you would always want to multiply right? who needs addition"
09:37:59 <ReinH> Yes, you can get away with collapsing tnem.
09:38:13 <ReinH> I.e., without never collapsing them.
09:38:23 <Cooler> ReinH, without collapsing that was a typo
09:38:28 <Cale> ...
09:38:36 <Cooler> i am trying to see if you can get away with never collapsing
09:38:41 <Cale> Are we speaking specifically of join?
09:38:45 <Cooler> yes
09:38:47 <Cale> Or of other things?
09:38:48 <Cooler> sort of
09:39:02 <Cale> Can you explain what collapsing is?
09:39:04 <Cooler> functors, applicatives and monads
09:39:22 <Cale> I sort of doubt that this is a meaningful notion given the things which have been said in the past short while
09:39:27 <MarLinn> My personal advise? Hydration. It's not a guarantee, but it can keep you from collapsing on hot days.
09:39:37 <ReinH> Yes, you can write programs that don't use bind or join. They won't be interesting, since you will be limited to a single IO action with no way to combine them.
09:39:39 <Cooler> Cale, its the idea that >>= is flatMap
09:39:44 <Cooler> map and flatten
09:39:52 <Cooler> flatten is what i mean by collapse
09:40:07 <ReinH> Just say join instead, since you mean join.
09:40:11 <Cale> And by "flatten" you mean concatenate specifically? Are you talking about lists?
09:40:25 <Cooler> not specifically about lists no
09:40:30 <ReinH> >>= is fmap and join
09:40:30 <Cale> Or do you mean join more generally, which is a different notion for each monad
09:40:37 <ReinH> So just say join.
09:40:46 <Cooler> yes join
09:40:50 <Cale> It should always be the case that  x >>= f = join (fmap f x)
09:41:16 <Cale> (assuming that you have a lawful instance of monad)
09:41:45 <Cooler> the point is when its a bunch of different functors that are nested
09:41:49 <Cooler> you don't want to flatten
09:41:52 <Cooler> or join
09:41:54 <NickHu> His question is "why would you ever use join"
09:42:02 <NickHu> :t join
09:42:04 <lambdabot> Monad m => m (m a) -> m a
09:42:07 <Cale> If the functors are different, you can't join.
09:42:11 <NickHu> See, it has to be the same functor
09:42:11 <ReinH> You can't. It isn't a matter of want.
09:42:12 <Cooler> perfect
09:42:30 <Cooler> that was my point
09:42:32 <NickHu> Actually you can't join functors, they have to be monads
09:42:50 <Cale> Well, every monad is also a functor
09:42:50 <NickHu> :t concat
09:42:51 <lambdabot> Foldable t => t [a] -> [a]
09:42:55 <NickHu> Yeah
09:43:13 <Cooler> so you just use fmap, without having to go to >>=
09:43:17 <monochrom> But you can join #haskell
09:43:19 <MarLinn> :t sequence_ -- collapsing!
09:43:20 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
09:43:27 <Cale> Cooler: "having to" is the wrong sequence of words :)
09:43:34 <NickHu> I'm sure there is a definition of concat = join somewhere, can anyone confirm?
09:43:38 <ReinH> You *can't* use >>= in that case.
09:43:43 <Cale> Cooler: You can always use fmap if you like, with any functor
09:43:51 <Cale> Cooler: A monad is a functor with additional operations
09:43:57 <ion> > Identity (-42 :: Fixed E6)
09:44:01 <lambdabot>  error:
09:44:01 <lambdabot>      Ambiguous occurrence ‘Fixed’
09:44:01 <lambdabot>      It could refer to either ‘Data.Fixed.Fixed’,
09:44:01 <Cale> One of which is (>>=)
09:44:04 <NickHu> Cooler: join and >>= are basically equivalent, since they are defined in terms of eachother
09:44:09 <ion> > Identity (-42 :: Data.Fixed.Fixed E6)
09:44:11 <lambdabot>  Identity -42.000000
09:44:17 <Cooler> what do you mean you can't use >>=
09:44:18 <Cooler> ?
09:44:19 <ion> I wish that had the parens
09:44:35 <ReinH> Cooler: you can't use >>= with different monads
09:44:42 <ReinH> Just like join
09:44:48 <Cale> Cooler: look carefully at the type of (>>=)
09:44:51 <Cale> :t (>>=)
09:44:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:44:58 <Cooler> oh right
09:44:59 <Cale> There is only a single monad m
09:45:03 <Cale> and it's the same m throughout
09:45:40 <Cooler> so in that sense fmap is more powerful?
09:45:47 <ReinH> No.
09:45:50 <monochrom> Yes.
09:45:55 <glguy> eh
09:45:55 <NickHu> lol
09:46:00 <NickHu> fmap is more general
09:46:02 <implementation> :t fmap
09:46:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:46:13 <NickHu> But it doesn't do the same thing as >>=
09:46:19 <ReinH> fmap only deals with a single f
09:46:23 <NickHu> It doesn't even have the same "shape" as >>=
09:46:35 <dfeuer> Are there any GHC hackers willing to make a stab at https://ghc.haskell.org/trac/ghc/wiki/NewtypeOptimizationForGADTS ? I'm offering 24 bottles of high-end root beer, or a prize of similar value.
09:46:37 <ReinH> So there is no possibility of mixing up your f's
09:46:43 <NickHu> In lots of monads fmap and >>= are related
09:46:55 <dfeuer> ?
09:46:59 <dfeuer> Many?
09:47:03 <ReinH> NickHu: in all monads they are related.
09:47:17 <NickHu> uh, yeah, true
09:47:24 <NickHu> Seeing as >>= is just fmap combined with join
09:47:38 <dfeuer> fmap f m = m >>= pure . f
09:47:43 <dfeuer> Always.
09:47:46 <NickHu> Mm
09:48:05 <ReinH> You can write code using >>= or join that you can't write using fmap.
09:48:12 <ReinH> In that way, they are more powerful.
09:48:13 <NickHu> Can anyone explain to me in general (i.e. not just Hask), Monad isn't a superclass of Applicative?
09:48:23 <ReinH> In some other way, they might be less powerful.
09:48:27 <NickHu> *why in general
09:48:31 <geekosaur> NickHu, it's a "subclass"
09:48:40 <Cale> NickHu: What's Applicative outside of Hask?
09:48:41 <geekosaur> Monad is Applicative "plus something"
09:48:50 <monochrom> You have more methods, you become a subclass not superclass.
09:48:56 <NickHu> geekosaur: https://github.com/mikeizbicki/subhask
09:49:08 <NickHu> This says that that only applies in the category Hask
09:49:11 <Cale> NickHu: Monoidal functors?
09:49:25 <NickHu> I don't know enough of category theory to understand a detailed answer
09:49:36 <Cooler> ReinH, isn't that true the other way around as well?
09:49:41 <ReinH> Hask has structure that other categories lack.
09:49:46 <ReinH> Cooler: no.
09:49:48 <Cooler> you can write code with fmap that you can't with >>= and join
09:49:49 <Cale> NickHu: Applicative isn't stolen directly from category theory
09:50:00 <NickHu> I also heard that Hask isn't a real category
09:50:01 <ReinH> That is not true.
09:50:03 <Cale> NickHu: It's explainable in terms of CT
09:50:09 <ReinH> I can write fmap with >>=
09:50:12 <Cooler> ReinH, we just did an example
09:50:18 <prsteele> you should be able to implement all of applicative with monad
09:50:32 <mniip> does Day convolution exist outside of Hask
09:50:33 <Cale> But the mapping to stuff that category theorists talk about isn't quite direct, and there's a bit of freedom about how you do it
09:50:42 <dfeuer> ReinH, you can write code with fmap that you can't write with >>= if you have a Functor that's not a Monad.
09:50:43 <NickHu> I see
09:51:00 <ReinH> Cooler: if you can write fmap with >>= then you can do anything fmap does with >>=
09:51:02 <NickHu> Are there different branches of category theory, like there are for type theory?
09:51:04 <geekosaur> NickHu, so I am not a category theory expert. but the readme for subhask points out that the author is *also* confused by that
09:51:07 <ertesx> NickHu: IMO you need a calculus as a foundation for category theory
09:51:13 <ertesx> NickHu: like type theory or set theory
09:51:20 <geekosaur> "this does not appear to be true for arbitrary categories. At least it's definitely not true given the current definition of the Category class I've defined. I'm not sure if that's a limitation of my design or something more fundamental."
09:51:24 <phadej> mniip: it does: https://ncatlab.org/nlab/show/Day+convolution
09:51:26 <ertesx> it doesn't stand on its own
09:51:33 <ReinH> dfeuer: that's true, but we are assuming that >>= exists and, for some reason, trying to avoid using it.
09:51:34 <Cale> NickHu: Yeah, it sort of branches out a bit.
09:51:40 <NickHu> ertesx: I read a paper by Awodey which states that Categories, Types and Sets can all be fundamental
09:51:40 <mniip> well then
09:51:49 <mniip> you can use Day convolution to define applicatives
09:51:51 <ReinH> I.e., we are given a monad already.
09:51:53 <geekosaur> so. kinda hard to answer just with that. and as noted here, Applicative doesn't fall out of CT the way the relationship between Functor and Monad does
09:51:59 <ertesx> NickHu: as long as you have a logical calculus, that's fine
09:52:07 <NickHu> http://repository.cmu.edu/cgi/viewcontent.cgi?article=1063&context=philosophy
09:52:17 <mniip> just take Day convolution as a tensor product in End(C) and check out the monoid objects
09:52:18 <dfeuer> Whatever. Exercises in avoiding >>= when confronting something that is sure to be a Monad are not interesting to me.
09:52:19 <mniip> and you're done
09:52:27 <ertesx> NickHu: the problem is that CT talks a lot about "mappings" ("functions") and "equality"
09:52:34 <ertesx> NickHu: which aren't things on their own
09:52:35 <NickHu> mniip: I don't understand this
09:52:46 <ReinH> dfeuer: agreed
09:52:48 <mniip> that's okay
09:53:05 <mniip> I don't fully understand it either, just its Hask implementation
09:53:46 <ertesx> dfeuer: i wish -XApplicativeDo was the default
09:53:54 <ertesx> but Applicative came too late =/
09:54:03 <dfeuer> What *is* interesting to me is convincing GHC to inline Data.IntMap.minViewWithKey at appropriate times (such as when implementing minView).
09:54:04 <NickHu> ertesx: What does it do?
09:54:07 <geekosaur> (this doesn't mean it's not there, it means it's not fundamental in the same way that you can only describe Monad in CT via Functor.)
09:54:25 <geekosaur> I should have lowercased those since I don't mean the Haskell ones
09:54:27 <ertesx> NickHu: it recognises functorial/applicative patterns and writes them using Functor and Applicative exclusively
09:54:40 <monochrom> dfeuer: is minViewWithKey a recursive function?
09:54:45 <Cale> ertesx: I find ApplicativeDo a bit troubling -- you're taking some syntax sugar which has a very straightforward translation and making the translation not so obvious any more.
09:54:56 <NickHu> ertesx: Oh so it desugars do notation differently if you don't actually need the monad instance?
09:54:59 <geekosaur> re ApplicativeDo, I am under the impression it is rather more complex than monadic do
09:55:01 <ertesx> Cale: that's true…  you're also relying heavily on laws
09:55:05 <geekosaur> or, what Cale just said
09:55:08 <ertesx> but i still thing it's really useful
09:55:17 <ertesx> NickHu: yeah
09:55:26 <Cale> It's even less straightforward than RecursiveDo
09:55:29 <ertesx> geekosaur: far more complex actually
09:55:39 <dfeuer> monochrom, no; it calls a recursive function, but the three (!) outermost constructors are determined before the recursive call.
09:56:01 <dfeuer> There are three because someone designed the API oddly.
09:56:01 <geekosaur> yes. this makes me wonder if it is not a good idea, however convenient it may be. (on the other hand, the same argument applies to Num :)
09:56:02 <hpc> but is it less straightforward than arrow do?
09:56:28 <ertesx> hehe, good point
09:56:29 <monochrom> yeah, why would GHC not inline that. That is strange.
09:56:39 <ertesx> as long as we have -XArrow, let's not argue about the complexity of -XApplicativeDo =)
09:56:49 <ertesx> -XArrows
09:56:56 <dfeuer> monochrom, well, I can get it to inline if I force the matter with INLINE. I just don't know that I want to go that far.
09:57:14 <dfeuer> Maybe I should though.
09:57:26 <hpc> as long as Arrow has arr, even the Show constraint on Num is downright principled :P
09:57:35 <dfeuer> I'd rather leave open the option of not inlining it, though....
09:57:51 <monochrom> I don't know. The "why" of why it doesn't happen automatically may be important to know in the long run.
09:58:39 <ertesx> hpc: arr is nothing…  try desugaring (| banana brackets |) on your own, including the proper association direction of (,)
09:58:46 <dfeuer> monochrom, I've tried all sorts of things to make the part I want inlined as small as possible, calling out to helpers as early as possible, but I still haven't been able to get it to inline by itself. Frustrating.
09:59:28 <ongy> what's banana brackets?
09:59:50 <hpc> ongy: a wonky sugarring over applicative style
10:00:00 <ertesx> ongy: it's an -XArrows thing…  if you don't know them, i envy you
10:00:03 <NickHu> Oh is that from the functional programming with bananas, lenses, envelopes and barbed wire paper?
10:00:07 <hpc> oh it's an arrows thing?
10:00:10 <ertesx> hpc: no, the arrow thing
10:00:13 <prsteele> dfeuer: how do you go about determining whether it was inlined or not? dumping some intermediate form?
10:00:13 <ertesx> not idiom brackets
10:00:14 <geekosaur> not last I heard
10:00:19 <geekosaur> ah
10:00:23 <hpc> i don't even know what it is then
10:00:24 <dfeuer> prsteele, -ddump-simpl -dsuppress-all
10:00:37 <prsteele> dfeuer: thanks
10:00:49 <byorgey> banana brackets have been used for many things over the years
10:01:04 <dfeuer> prsteele, I also often use -dno-suppress-type-signatures. Dumping *everything* gives too much output, but the type signatures can be good to see.
10:01:12 <byorgey> in the bananas, lenses, envelopes and barbed wire paper, they are used to denote a catamorphism.
10:01:13 <hpc> but arr is still really hard to excuse because it turns Arrow from a weirdly specific extension of Category into a thing that can only ever be used with (->) and Kleisli
10:01:36 <hpc> rendering all the extra complications on top of Arrow worse than useless
10:01:56 <MarLinn> There's some connection between the arrow brackets and applicative brackets because arrows are *somehow* applicative...
10:01:57 <ertesx> hpc: y <- (| myFunc (do myInnerAction1 -< myOuterVariable1; myInnerAction2 -< myOuterVariable2) |)
10:02:07 <ertesx> hpc: the sad part is:  they are actually useful
10:02:10 <byorgey> Conor McBride then used them to denote applicative style in his SHE preprocessor, which is entirely unrelated.  Note that the original Applicative paper actually used double square brackets [[ ...  ]]
10:02:31 <byorgey> banana brackets are used in arrow notation too, yes, but I am not sure of the precise connection
10:02:40 <ertesx> byorgey: none
10:02:57 <geekosaur> easy enough to excuse from the direction that Arrow was trying to generalize functions. it didn't succeed, but I'm not convinced the attempt /per se/ was a bad thing
10:02:59 <byorgey> fair enough.  So we are up to three entirely unrelated uses of banana brackets.
10:03:14 <hpc> ertesx: my impression has always been that you could remove everything about Arrow except for the class definition and (->) instance, and nobody would miss it
10:03:22 <ertesx> byorgey: they are a way to use arrow variables across arrow combinators without explicitly passing them
10:03:30 <geekosaur> (and in that sense, it led to Applicative as a more useful generalization)
10:03:37 <hpc> where is Arrow being used?
10:03:42 <geekosaur> FRP
10:03:50 <phadej> opaleye
10:03:52 <ertesx> hpc: i used it almost exclusively in an FRP context
10:03:59 <hpc> ah, that figures
10:04:17 <hpc> is arrow frp any good?
10:04:24 <ertesx> hpc: yeah
10:04:26 <hpc> (compared to non-arrow frp)
10:05:24 <ertesx> hpc: AFRP has the advantage that it's a thin layer over functions and local state, meaning that not only is it fast, but it's very predictable
10:05:28 <ertesx> especially in the context of switching
10:06:07 <ertesx> but it should only be used in domains where that's actually important:  real-time games and simulations
10:06:43 <hpc> ah, i might look up more on my own then
10:06:44 <geekosaur> maybe the more useful question is whether AFRP needs the -XArrow syntax extensions, or if that can be provided usefully/readably in some other way
10:06:51 <geekosaur> preferably one amenable to a library
10:07:02 <ertesx> geekosaur: yeah, -XArrows really helps
10:07:33 <ertesx> you can do some things using Applicative
10:08:29 <ertesx> geekosaur: https://github.com/esoeylemez/wires/blob/master/examples/ping-pong.hs
10:08:40 <ertesx> from line 40
10:08:57 <ertesx> -XArrows makes this reasonable to write and read
10:10:29 <monochrom> The "... <- ... -< ..." part is nice.
10:10:43 <MarLinn> -XArrows feels like it should be a visual programming language...
10:11:05 <monochrom> Yes, that's too. I would really rather draw a dataflow diagram.
10:11:20 <ReinH> MarLinn: http://scrambledeggsontoast.github.io/2014/09/28/needle-announce/
10:11:23 <ertesx> MarLinn: -XArrows feels like: "you're craving for a monad"
10:11:30 <monochrom> But "plain text file" being a religion of programmers, what can you do.
10:11:59 <geekosaur> wait for Apple to "invent" it >.>
10:12:51 <hpc> ertesx: know of any good links for learning arrow do properly? i can /almost/ tell what's going on but then i see id -< () <$ filterE (== 'q') chars and i have no idea how that works out
10:12:51 <Boomerang> Instead of -XArrows if you want a visual programming language you should try the package needle: http://scrambledeggsontoast.github.io/2014/09/28/needle-announce/
10:12:55 <MarLinn> ertesx: Also true. Last time I used it I was craving for Applicative with a dash of monad but didn't know it
10:13:29 <Kaidelong> =( why would anyone use that
10:13:32 <ReinH> We have these things that are like functions. What should we call them? Arrows!
10:13:48 <ertesx> hpc: first learn arrows…  then…  well…  i learned it from the GHC user guide
10:13:49 <phadej> ReinH: Profunctors!
10:13:50 <ertesx> it's reasonable
10:13:51 <monochrom> Consider -XMorphisms
10:13:54 <ReinH> Years later: What are these Arrow things? Oh they're just functions!
10:14:12 <Kaidelong> there was an esoteric language that worked like this
10:14:25 <ertesx> hehe
10:14:26 <Kaidelong> mondrian?
10:15:05 <ertesx> ReinH: https://ro-che.info/ccc/12
10:15:29 <ReinH> MarLinn: needle actually looks pretty cool :)
10:15:44 <Kaidelong> I've done visual programming before, it doesn't scale
10:16:07 <ertesx> i think, machine learning will take over before visual programming becomes useful =)
10:16:12 <Kaidelong> I think lambdu and touchdevelop probably come closer to what a post-text interface will look like
10:16:30 <ReinH> ertesx: yeah that's the one I was blatantly plagiarizing ;)
10:16:31 <MarLinn> ReinH: Why do I suddenly think about stackoverflow codegolf questions...
10:16:45 <ReinH> MarLinn: dunno, but that would be terrible for codegolf
10:16:52 <MarLinn> Exactly!
10:16:55 <ReinH> haha
10:17:44 * hackagebot network-hans 2.6.3.1 - HaNS to Network shims for easier HaNS integration  https://hackage.haskell.org/package/network-hans-2.6.3.1 (AdamWick)
10:18:08 <ReinH> ertesx: I wish there were more comics :(
10:18:20 <ertesx> problem is: i spent like 15 years learning emacs…  now that i almost understand it, i'm supposed to learn a new tool?  as long as there is haskell, i'll probably stick to text =)
10:18:34 <maerwald> ...
10:18:39 <ReinH> ertesx: Heh... I spent ten years learning vim and now I'm learning emacs so
10:18:53 <hpc> ReinH: remember to save 50 years to learn eclipse
10:18:57 <ReinH> nah
10:19:10 <ReinH> But I might be doing some .NET development so I guess I'll have to learn VS
10:19:33 <ertesx> VS isn't quite visual…  it's mouse programming
10:19:42 <ertesx> similar to word vs. emacs+pandoc
10:19:43 <ReinH> No I didn't mean that it was a visual environment
10:19:44 <ReinH> sorry
10:19:48 <ReinH> I can see how that was confusing now
10:19:51 <hpc> the only thing i remember from using VS for source engine modding is that i could never find the "build project" button
10:20:10 <MarLinn> If you want a practical usecase for visual programming look at https://www.knime.org/knime-analytics-platform. It's Java, but it feels like it should be functional...
10:20:14 <ertesx> don't worry, you can't talk about VS in a non-confusing way =)
10:20:24 <ReinH> ertesx: heh
10:20:39 <ReinH> ertesx: apparently they even have some old VB stuff
10:20:58 <ertesx> a nice use case for visual programming is music…  uhm…  "engineering" i guess
10:21:46 <Kaidelong> I used a system like that on Macintosh
10:21:47 <MarLinn> yeah, it's mostly used for specialised fields with a natural "flow"
10:21:50 <Kaidelong> I am trying to remember its name
10:21:57 <Kaidelong> it was actually pretty awful
10:22:02 <ReinH> MarLinn: a flow of... data?
10:22:05 <ertesx> more importantly you can see instant visual feedback
10:22:14 <Kaidelong> a real life Moog Modular or something is easier to work with
10:22:17 <ertesx> with each component displaying stats as you're listening
10:22:24 <Kaidelong> you wouldn't want to manipulate that with a single finger
10:22:28 <ertesx> with pure text you don't get that
10:22:37 <Kaidelong> and that's kinda like what visual music programming was like
10:22:48 <ertesx> or you have to program the diagnostics yourself, and they are separate from the source code
10:22:53 <MarLinn> ReinH: yes, mostly. Or time, as in music
10:23:02 <ReinH> MarLinn: I was making a joke about dataflow programming
10:23:18 <Kaidelong> creating music requires a quick feedback cycle between experiments, which you get best with a bunch of scalars you can adjust quickly with a mouse
10:23:19 <ReinH> music is a flow of floats
10:23:24 <Kaidelong> rather than complex flow diagrams
10:23:30 <ReinH> time is inherent in the system, not reified
10:24:05 <Kaidelong> some people do write their music using programming systems but the general use case is to use these things to generate sound
10:24:07 <ertesx> many years ago i played around with an open source project called either "BSE" or "BEAST" or both…  not sure…  it was quite terrible and crashed all the time, but other than that it was quite enjoyable =)
10:24:12 <Kaidelong> and then do MIDI authoring for the actual music
10:24:19 <Kaidelong> that way you can use a keyboard
10:24:30 <ReinH> Unfortunately, MIDI is terrible
10:24:43 <Kaidelong> XMIDI is terrible too and no good replacement caught on
10:24:55 <Kaidelong> hardware support is important and there are no alternatives that have it
10:24:58 <ReinH> There are some modern standards that will also not catch on
10:25:03 <monochrom> When you do music on computers... you need *two* keyboards :)
10:25:07 <ertesx> well, just dispense with event-based systems and use actual signals
10:25:12 <ReinH> monochrom: I have three, actually.
10:25:15 <Kaidelong> ah right, need to disambiguate
10:25:21 <Kaidelong> piano keyboard
10:25:22 <ertesx> MIDI is mostly for instrument communication, not for actually making music =)
10:25:38 <ReinH> ertesx: yes, but instrument communication facilitates making music
10:25:41 <Kaidelong> music is exactly instrument communication
10:25:47 <Kaidelong> the instruments just make the sounds
10:26:26 <Kaidelong> the only context where I saw visual programming really have relevance was in integrated circuit design
10:26:37 <Kaidelong> it makes sense there because spatial constraints are actually important
10:26:46 <ertesx> i mean: given the events of an electronic piano and a programmable non-MIDI sound source, you can make music that only uses MIDI as a communication protocol, not as the end product
10:26:50 <Kaidelong> rather than a hinderance
10:26:56 <monochrom> fully functional really reactive piano programming = FFRRPP
10:27:21 <Gurkenglas> Screeps is a game where you define some javascript that is run in each frame of a persistant global world. Your API is some objects, given here: http://support.screeps.com/hc/en-us/articles/203084991-API-Reference . Is there a way to use ghcjs or something to provide Haskell code instead?
10:27:51 <Kaidelong> it's telling that visual programming's added spatial issues adds enough difficulty that you can use it for puzzle games with a little modification to bring that out
10:27:55 <Kaidelong> space chem, for example
10:28:00 <ertesx> Gurkenglas: unlikely…  haskell always comes with an RTS
10:28:01 <ReinH> monochrom: that sounds onomatopoeic for something rude
10:28:10 <ReinH> Also I spelled onomatopoeic right on the first try, so yay me
10:28:37 <ertesx> Gurkenglas: you could try purescript, which supposedly produces small and readable JS
10:28:40 <ReinH> Gurkenglas: you might have more luck with something like Fay
10:28:53 <ReinH> it's hard to work with native JS objects with PS, at least that's been my experience
10:28:57 <ReinH> it wants you to use its own lazy structures
10:29:17 <nshepperd_> Write your own Haskell interpreter in js
10:29:21 <ReinH> :)
10:29:28 <ertesx> i have zero experience with PS
10:29:57 <ertesx> (mostly because it wants me to use stuff like bower)
10:31:09 <lolisa> Hi, had anyone read Functional Reactive Animation?(http://conal.net/papers/icfp97/) I didnt understand some part of the paper...
10:31:33 <ReinH> lolisa: you can ask your questions :)
10:31:39 <lolisa> typing...
10:33:20 <lolisa> My question is, in the paper, they defined Time = Real + Real, where the left one denote a moment of time (x), and the right one denote 'after time x'
10:35:14 <jp_rider> hi
10:35:21 <lolisa> However, it seems like they only use behavior for "at" and "during", which accept a time. My question is, what does it mean for someBehavior at Time >= x? Simply put, I fail to see why Time is Real + Real instead of Real
10:35:21 <ReinH> This is section 2.1 of the paper, for those of you playing along.
10:35:27 <jp_rider> is it possible to constrain two existential types?
10:35:36 <jp_rider> i'm trying to do something like this: http://lpaste.net/8714273693355737088
10:36:11 <ReinH> lolisa: does the explanation at the beginning, "we would like to know that a time is 'at least' some value, even if we don't yet know exactly what the final value will be," not convince you?
10:36:40 <lolisa> I had the horrible habit of jumping to code... My bad :(
10:36:50 <ReinH> :)
10:37:06 <ReinH> It's ok if it doesn't, just wanted to make sure that you had encountered it.
10:41:15 <lolisa> ReinH, so will untilB be benefitted from 
10:41:20 <lolisa> "indefinite time"?
10:42:30 <aarvar> jp_rider: you have a type error there right?
10:44:24 <jp_rider> aarvar: yes, Could not deduce (Test a b1 c1) arising from a use of ‘runTest’ from the context (Test a b c)
10:45:02 <aarvar> yeah, you don't have an instance to construct the State value
10:45:20 <ReinH> lolisa: A Time is equivalent to data Time = Exact Double | AtLeast Double
10:45:27 <ReinH> + indicates a sum type
10:45:41 <ReinH> (well, Double is wrong, it needs to be the extended reals)
10:45:42 <aarvar> jp_rider: what are you trying to do
10:46:01 <lolisa> Yes, I get that perfectly... I just wonder what part of the code benefitted the most from this design
10:46:06 <ReinH> data ExtReal = NegInf | Real Double | PosInf deriving (Ord, Eq) is close enough
10:46:17 <ertesx> ReinH: (extended Rational is enough for the purpose of FRP)
10:46:29 <ReinH> ertesx: sure, but the paper uses the reals :)
10:46:53 <ReinH> (the deriving Ord is a nice bit of free functionality btw)
10:47:20 <ertesx> BTW, i'm pretty sure there is an alternative formulation that only needs Time = ℝ, but i haven't done the math, so take this with a grain of salt
10:47:23 <ReinH> lolisa: so your question is "when do we care about 'at least' time values?"
10:47:37 <lolisa> Yes
10:47:40 <ReinH> or, "when do we actually use them?"
10:48:48 <lolisa> Aah... Wait a sec, I get the second one
10:49:50 <jp_rider> aarvar: I have a bunch of different types of tests that all have an input, a settings, and a state data type. they all implement the three functions in the Test typeclass. My main function basically parses the input, and then calls initialSetup, runTest, and postProcess
10:49:54 <lolisa> Is it like, we keep generating >curtime for the nextMouseclick?
10:50:31 <aarvar> jp_rider: maybe you don't want a type class?
10:51:58 <rcschm> I have picked up the book The Algebra of Programming by Richard Bird last week.  It is so hard to follow the text.  Anyone here can give some guidance as how to read the book?  Jus for a start, what is Allegories?  
10:52:24 <ReinH> rcschm: It's been a while since I've read that book. How is "Allegories" used?
10:52:42 <jp_rider> aarvar: maybe.. all the tests have that same form though. i have this working by wrapping all the test types with another adt that basically dispatches to the correct test. this is a lot of boilerplate though so i thought existentials might simplify things
10:52:54 <ReinH> lolisa: It isn't actually clear from the paper why >=t values are required...
10:52:56 <rcschm> Really like to get join a study group if there is one.
10:53:16 <aupiff> rcschm: I would gladly join you.
10:53:28 <ReinH> I don't know of any, but we could make one.
10:53:32 <rcschm> program calculation seems to be really useful if i know how to do it properly.
10:53:38 <ReinH> Might be hard to find joiners. It's still a >$100 book, right?
10:53:52 <aupiff> errrr.... the internet may have bootleg copies
10:53:56 <rcschm> i have got a pdf copy.
10:54:08 <ReinH> rcschm: you might try his Thinking Functionally with Haskell, Introduction to Functional Programming Using Haskell, or Pearls of Functional Algorithm Design, all of which are more approachable imo.
10:54:09 <rcschm> just need people who can teach though.
10:54:17 <rcschm> i read that as well.
10:54:22 <ReinH> rcschm: Should we set up a Discourse?
10:54:27 <rcschm> and understood part of it.
10:54:39 <aupiff> Discourse? is that some sort of mailing list?
10:54:39 <rcschm> that would be cool. ReinH.
10:54:44 <ReinH> AoP requires more Algebra and Category Theory than the other books
10:54:49 <ReinH> so it's a bit of a harder go if you don't have the math
10:55:01 <rcschm> I see.
10:55:02 <ReinH> aupiff: it's a discussion forum that is what the cool kids appear to be using
10:55:12 <ReinH> rcschm: But back to the question, how is "Allegories" used.
10:55:18 <rcschm> I am ready to put in time to understand it.
10:55:21 <ReinH> I assume you know the usual definition of the word and don't see how it applies?
10:55:32 <ertesx> since it's bird, i'm pretty sure it's categorical allegories
10:55:41 <ertesx> https://en.wikipedia.org/wiki/Allegory_(category_theory)
10:55:44 <rcschm> It was discussed in the book. ReinH.
10:55:55 <rcschm> and I have no idea what it is exactly.
10:56:04 <ReinH> Oh of course.
10:56:09 <lolisa> ReinH, is function "predicate" generating atleast? 
10:56:17 <rcschm> it is almost like a stucture that can wrap hylo.
10:56:47 <rcschm> hylo was mentioned as the way to do the calculation.
10:57:28 <saurabhnanda> okay, why is the top-rated comment on that thread this? what am I missing? https://www.reddit.com/r/haskell/comments/51kzdu/how_to_write_a_domain_api_with_pragmatic_type/d7cxvgw
10:57:34 <rcschm> if there is a study group for Bird's book, I will definitely join.
10:57:34 <ReinH> ertesx: Too many CT concepts to keep paged in at once o_O
10:58:29 <ph88> can someone help me test this with QuickCheck ?   https://paste.fedoraproject.org/423339/32509331/
10:58:30 <ReinH> saurabhnanda: because more people upvoted it than any other comment.
10:59:10 <saurabhnanda> ReinH: :) Well that's the basic mechanics of voting. But is the subject-matter of that comment correct? Is it a DB design issue, off all things?
10:59:35 <ReinH> Well, the person responding to you wrote one of the more popular, and more typesafe, db libraries.
10:59:40 <ReinH> So I at least consider his opinion worth listening to
10:59:45 <ertesx> ReinH: yeah, but when bird uses a word you don't know or one that you know, but in a confusing context, it's most likely a categorical thing =)
10:59:52 <ReinH> ertesx: touche :)
11:00:14 <ertesx> that's how i "knew" =P
11:00:18 <ReinH> :D
11:01:53 <aupiff> rcschm: let's just start this study group! what chapter of the book are you on?
11:02:06 <aupiff> I doubt there's a group already in existence
11:02:24 <rcschm> I went to 4 and started on Allegories.
11:02:53 <rcschm> but didn't really have a clue how to digest it.
11:03:04 <saurabhnanda> ReinH: But I don't know how else to design this DB. Would you really normalize a table further because you have a status column and different rows may have a different status?
11:03:20 <nitrix> I don't understand why Control.Concurrency.Chan has a dupChan function.
11:03:24 <lpaste> sebboh pasted “build fail” at http://lpaste.net/186070
11:03:28 <ReinH> saurabhnanda: I don't think I made that argument.
11:03:31 <muzzle> hi. Is there a way to make a function (String -> DataType l) where the concrete l depends on the String at runtime? Or would I have to build this with TemplateHaskell?
11:03:52 <nitrix> Why not just pass the Chan around; why is there ever a need to duplicate the channel rather than passing the original one?
11:04:09 <ertesx> nitrix: because readers remove messages
11:04:21 <saurabhnanda> ReinH: which is why I'm asking specifically about the subject matter of the comment. I feel people are upvoting it blindly and trivializing my question. OTOH if it really is a DB design problem, I would like to know how else to design this table. There could be a better way I don't know of.
11:04:30 <nitrix> ertesx: Oh, so you duplicate the channel so that each reader gets to read the message once.
11:04:35 <nitrix> ertesx: Gotcha, thanks.
11:05:09 <ertesx> nitrix: BTW, if you don't need that functionality, TQueue may be much more efficient
11:05:18 <rcschm> aupiff: do we want to start on Discourse?
11:05:22 <nitrix> ertesx: It's just a proof of concept for now.
11:05:44 <sebboh> I've never built any haskell software before.  What do these errors mean?  Since I didn't alter anything... I figure that I have an environment problem or there is a bug in the master branch of the application (git-annex)
11:05:45 <aupiff> https://try.discourse.org/t/the-algebra-of-programming-study-group/426?u=aupiff
11:06:03 <aupiff> let's see if that worked
11:06:08 <sebboh> s/these/these (http://lpaste.net/186070)/
11:06:24 <ReinH> That paste doesn't seem to exist.
11:06:30 <ReinH> no just kidding
11:06:39 <ReinH> the url parser was confused
11:06:54 <sebboh> Oh, the )
11:06:58 <aupiff> try posting something about your current progress through the book, that way everyone can figure out what to start discussing, and so on.
11:07:37 <muzzle> Type classes have to be completely decided at compile time, right?
11:07:40 <ReinH> I'm not sure the discourse sandbox is an appropriate place to host it
11:07:43 <dmwit> muzzle: no
11:07:46 <aupiff> no it's not.
11:07:56 <aupiff> I just realized that it's erased every day.
11:07:57 <dmwit> muzzle: one moment while I find an SO answer I wrote about this
11:08:02 <aupiff> So is there a free version?
11:08:37 <muzzle> dmwit: Because i have a type (DataType l), where i would like to determine the l based on a value in a config-file
11:08:44 <aupiff> I guess we'd have to host it ourselves.
11:08:46 <aupiff> ...
11:08:54 <muzzle> dmwit: preferrably without recompiling the whole thing
11:09:11 <aupiff> I think a google group would be easier.
11:09:18 <aupiff> that's free as far as I know.
11:10:13 <lpaste> sebboh revised “build fail”: “git-annex failed to build--updated, better log.” at http://lpaste.net/186070
11:10:21 <dmwit> muzzle: Well, that's going to be trickier. Possibly you could do that with an existential box for `DataType`.
11:10:52 <muzzle> dmwit: existential box?
11:11:05 <dmwit> muzzle: Here's the SO answer I was looking for, but given your continuation I no longer believe it is relevant. http://stackoverflow.com/a/11422333/791604
11:12:05 <dmwit> muzzle: As in `data SomeDataType = SomeDataType (MyFunClass l => DataType l)`
11:12:56 <muzzle> dmwit: I'll probably go with template haskell
11:13:23 <dmwit> I don't really see how that will help. But sure, knock yourself out.
11:13:26 <rcschm> aupiff: I think we pretty much can start from the beginning.
11:13:43 <joe9> which is recommended ? gtk or gi ? the gi-bindings seem to be latter version
11:13:44 <shachaf> dmwit: Are you sure that syntax is what you mean?
11:13:49 <dmwit> shachaf: no
11:13:52 <rcschm> I am pretty much lost right from the start.
11:13:59 <muzzle> dmwit: I could read the parameter from a configuration file at compile time and then just use one fixed type, right?
11:13:59 <dmwit> shachaf: Please feel free to correct me. I've avoided existentials as much as I can.
11:14:16 <shachaf> dmwit: Well, I'm not sure what you mean.
11:14:30 <rcschm> ReinH: What would you suggest we use to start the study group?
11:14:34 <shachaf> dmwit: Maybe data SomeDataType = forall l. MyFunClass l => SomeDataType l
11:14:46 <dmwit> shachaf: I mean `exists l. MyFunClass l *> DataType l`
11:14:58 <shachaf> OK. Then the Haskell syntax is what I wrote.
11:15:25 <dmwit> muzzle: If you have the configuration file at compile time, why bother having your `DataType` have a parameter?
11:15:46 <joe9> is there a haskell library that might make cairo rendering easier?
11:15:58 <dmwit> ?hackage diagrams is nice
11:15:58 <lambdabot> http://hackage.haskell.org/package/diagrams is nice
11:16:01 <joe9> it just seems primitive to use lineTo , stroke, etc.
11:16:52 <muzzle> dmwit: It's an analyzer for programming code, and I actually have two parameters, so my type is (Language t l) and a value would e.g. be (java :: Language JavaToken Java)
11:17:03 <muzzle> dmwit or (python :: Langauge PythonToken Python)
11:17:45 * hackagebot katip 0.3.0.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.3.0.0 (MichaelXavier)
11:17:47 * hackagebot do-list 0.8.0 - List construction with do notation  https://hackage.haskell.org/package/do-list-0.8.0 (TarasSerduke)
11:17:49 * hackagebot katip-elasticsearch 0.3.0.0 - ElasticSearch scribe for the Katip logging framework.  https://hackage.haskell.org/package/katip-elasticsearch-0.3.0.0 (MichaelXavier)
11:17:54 <ReinH> rcschm: Google groups is free but awful.
11:18:01 <joe9> dmwit: diagrams is too slow. hence, I am trying to render to cairo directly without diagrams.
11:18:02 <prsteele> I'm looking for the name of an abstration, if there is one. I have a computation I'd like to do, say `f <$> a <*> b <*> c`. However, each of `a, b, c` are provided to me via `d -> a`, `d -> b`, `d -> c`. I can write this manually, but is there a named pattern here?
11:18:25 <dmwit> prsteele: Sounds like `Reader`.
11:18:42 <prsteele> dmwit: ... I think you're right!
11:18:42 <ReinH> joe9: how do you know that diagrams is too slow?
11:18:54 <ReinH> Isn't it just as likely that your code is too slow?
11:19:12 <joe9> ReinH: https://github.com/joe9/baby-steps-to-building-a-chart-with-diagrams I tried with diagrams
11:19:14 <aupiff> rcschm: alright, I should start reading it over again as well.
11:19:23 <aupiff> I never made it past Ch 3. anyway
11:19:26 <ReinH> Yes, I know you tried with diagrams.
11:19:32 <ReinH> And the combination of your code and diagrams was slow
11:19:38 <ReinH> but you assumed that the problem was diagrams
11:19:38 <rcschm> cool aupiff:
11:19:49 <ReinH> you will generally have more success if you assume that your code is the problem first
11:20:06 <ReinH> if your code is slow, moving to some other rendering method will still be slow
11:20:07 <joe9> ReinH, could be my code too. any suggestions where the code could be wrong, please? I am trying with cairo direct and it is instantaneous.
11:20:39 <joe9> ReinH: is the code I tried with: https://github.com/joe9/baby-steps-to-building-a-chart-with-diagrams/blob/master/app/Step023RenderDynamicallyUsingCairoIORefAndIntMap.hs
11:20:55 <aupiff> would it be reasonable to start a git repo and have all discussions happen on issue threads?
11:21:19 <aupiff> we could have code the implements what bird is talking about. write up explanations in a wiki and so on.
11:21:43 <aupiff> you'll just have to check git notifications to see if there's been thread activity
11:21:46 <ReinH> If you want to know why your diagrams code is slow, you should profile it
11:22:00 <ReinH> visually inspecting code to determine performance problems is highly inaccurate
11:22:25 <ReinH> maybe diagrams is slow, but right now you are just guessing that diagrams is slow
11:22:27 <dmwit> ?hoogle HashMap k v -> HashSet k
11:22:31 <lambdabot> ClassyPrelude asHashMap :: HashMap k v -> HashMap k v
11:22:31 <lambdabot> Data.HashMap.Lazy keys :: HashMap k v -> [k]
11:22:31 <lambdabot> Data.HashMap.Strict keys :: HashMap k v -> [k]
11:22:42 <joe9> ReinH: This is my version of the code with using cairo rendering https://github.com/joe9/baby-steps-to-building-a-chart-with-diagrams/blob/master/app/Step024CairoOnly.hs
11:22:57 <ReinH> joe9: Again, visually inspecting code to determine performance problems is highly inaccurate
11:23:02 <ReinH> so me looking at that code won't be very helpful to you
11:23:11 <aupiff> rcschm: what do you say to the git repo idea?
11:23:12 <ReinH> you should profile it if you want to know why it is slow
11:23:18 <dmwit> Does the function I want exist (which doesn't need to go via [], doesn't need to hash anything, etc.)?
11:23:26 <joe9> ReinH: makes sense. I would have to figure out how to profile the code. let me read up on how to profile
11:23:38 <ReinH> dmwit: if it goes via [], does that get fused away?
11:24:11 <ReinH> joe9: GHC has profiling tools and there are benchmark libraries like criterion
11:24:21 <byorgey> ReinH: diagrams is slow.
11:24:36 <ReinH> byorgey: yes, but my point is: don't assume other people's code is the problem.
11:24:44 <rcschm> aupiff: that is cool for me.  i think we can try that or anything else really.
11:24:56 <aupiff> starting a repo now
11:25:08 <ReinH> if you're going to make an assumption, assume your code is the problem, because it's easier to fix your code
11:25:14 <ReinH> but verifying is better than assuming
11:25:20 <glguy> byorgey: ReinH's also saying you should assume your code (diagrams) is the problem, so that works out
11:25:29 <byorgey> glguy: indeed =)
11:25:32 <ReinH> glguy: See, byorgey gets it right
11:25:34 <dmwit> ReinH: Presumably even if it gets fused away a lot of work is wasted recomputing the structure of the HashSet, when it should be freely available by just removing values from the HashMap without any hard work.
11:25:50 <byorgey> profiling a program that uses diagrams sounds... terrifying
11:26:00 <joe9> ReinH : byorgey, I understand your intention. It is well meant. But, I cannot afford to spend another few days trying to figure out why it might be slow. There are already reports desisting from using diagrams for realtime stuff. I tried and realized that the reports might apply to my situation.
11:26:39 <ReinH> joe9: yeah you probably want to switch to rendering via cairo directly
11:26:41 <ReinH> ;)
11:26:47 <byorgey> agreed
11:26:58 <MarLinn> dmwit: would you loose much by just... replacing the values with ()? That would be isomorphic to a HashSet, right?
11:27:05 <dmwit> ReinH: ...in fact, I've just looked at the source of `HashSet`: `newtype HashSet k = HashSet (HashMap k ())`.
11:27:05 <aupiff> https://github.com/aupiff/algebraOfProgrammingStudyGroup/issues/1
11:27:19 <ReinH> dmwit: have you tried unsafeCoerce? *ducks*
11:27:36 <dmwit> ReinH: Indeed, I think I will `safeCoerce` to a newtype wrapper with trivial equality.
11:28:40 <ertesx> that reminds me of an OT question:  is there a distributed issue tracker that is maintained and useful?
11:28:57 <ReinH> ertesx: define "distributed"
11:29:02 <ertesx> such a thing could be useful for a study group based around distributed revision control
11:29:08 <ertesx> ReinH: using files in the repo
11:29:27 <ReinH> There are git-based wikis, but that is different.
11:29:54 <ertesx> there are a bunch of them around, but the ones i've found seem dead
11:29:56 <ph88> anyone here used quickcheck before ?
11:30:33 <dmwit> ?where justask
11:30:33 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
11:30:53 <bizarrefish> erikd: You could perhaps use something like redmine over a blockchain-based filesystem :P
11:31:04 <bizarrefish> There has to be one of those
11:31:18 <ph88> dmwit, i asked some time ago about https://paste.fedoraproject.org/423339/32509331/
11:31:28 <chreekat> ertesx: sjl/t on github is the first thing I thought of when reading your question, though the link is tenuous
11:32:04 <bizarrefish> Sorry, I meant ertesx 
11:32:30 <dmwit> ph88: That paste appears incomplete; and also doesn't mention what the problem is; and also doesn't appear to mention anything quickcheck-related.
11:32:58 <glguy> it's never enough, is it?
11:33:49 <aupiff> rcschm: what's your username on github? shall we plan to discuss a chapter of content per week (maybe this is unreasonably fast for later chapters)?
11:33:54 <monochrom> It is sometimes enough. Just wait until I ask a question. You will see how enough it is. :)
11:34:20 <ertesx> hmm…  so "no" =)
11:34:26 <rcschm> aupiff: wpoosanguansit
11:34:43 <monochrom> one week for chapter 1 and one week for chapter 2 are reasonable.
11:34:50 <monochrom> But expect one month for chapter 3.
11:35:01 <monochrom> because that's how long it took me.
11:35:05 <ertesx> though i suppose 't' could work
11:35:17 <monochrom> And since then I ran out of steam so I never started chapter 4.
11:35:47 <aupiff> monochrom: join us! I had a similar experience. never finished ch. 3
11:37:38 <monochrom> on the bright side, chapter 3 is enough for a whole lot of purposes.
11:38:01 <ph88> dmwit, there is a property that must hold, i want to test on this .. basically if i have my input, then parse it, then print it, i should get back my original input
11:38:43 <glguy> monochrom: How long must I wait?
11:39:00 <lolisa> OMG... Why is a -> b written as b <- a in the book... Anyway can I join?
11:39:24 <monochrom> b<-a is so that "f . g" is in the right order.
11:39:58 <monochrom> glguy: I don't know. :)
11:40:25 <monochrom> but perhaps look for my past questions in past IRC logs too
11:41:15 <rcschm> aupiff: what is yours?
11:41:17 <ReinH> AoP reverses -> and .
11:41:24 <ReinH> It takes some time to get used to
11:41:27 <aupiff> rcschm: aupiff
11:41:44 <aupiff> rcschm: https://github.com/aupiff/algebraOfProgrammingStudyGroup/issues
11:41:51 <chreekat> ph88: so you write a function "prop_reversible input = input == show (parse input)" and pass that function to quickCheck
11:41:54 <monochrom> No, it doesn't reverse (.). It uses <- so as to be consistent with (.).
11:42:01 <ReinH> Oh, right.
11:42:20 <monochrom> ((f :: c <- b) . (g :: b <- a)) :: c <- a
11:42:28 <rcschm> cool.
11:42:28 <aupiff> rstone: 
11:42:42 <aupiff> rcschm: I've invited you to be a collaborator
11:43:04 <rcschm> yeah, let's rumble.
11:43:38 <monochrom> I saw another book doing the other alternative: ((g :: a -> b) ; (f :: b -> c)) :: a -> c
11:43:59 <aupiff> rcschm: I'll try to involve some others.
11:44:02 <monochrom> In fact, I think Wadler just did in a recent introductory talk on category theory
11:44:12 <aupiff> monochrom: oh, where?
11:44:15 <aupiff> link?
11:44:21 <monochrom> https://www.infoq.com/presentations/category-theory-propositions-principle
11:44:26 <rcschm> the more the better.
11:44:33 <monochrom> I heard of it from lambda-the-ultimate.org
11:44:44 <aupiff> Wadler's paper "propositions as types" is one of my favorites
11:44:53 <byorgey> monochrom: yeah, I've actually seen that  ;  notation in quite a lot of places
11:45:05 <byorgey> using reversed <- and (.) I have only ever seen in AoP.
11:46:11 <intothem2untains> What workaround is there to define some kind of map with instances of a certain typeclass as values? 
11:46:15 <dmwit> I think we tried using reversed function application in one CT reading group session. I got so confused that I forced everybody else to stop doing it.
11:46:42 <monochrom> but you are not supposed to use function application at all :)
11:47:01 <glguy> Maybe that's why they stopped using it?
11:47:02 <aupiff> lolisa: yes you should join us. we're discussing chapter 1 over the course of this week. https://github.com/aupiff/algebraOfProgrammingStudyGroup/issues/1
11:47:03 <dmwit> I think we were studying CCCs that session -- those are the ones that have a notion of function application, right?
11:47:11 <monochrom> true
11:47:22 <ReinH> They have exponentials, which... yes.
11:47:49 <byorgey> dmwit: was I there?  I don't remember this
11:48:06 <dmwit> byorgey: I think it was you and I and Vilhelm, yeah.
11:48:07 <lolisa> When? I'm at China so I need to prepare for the event (time zone issue)
11:48:09 <byorgey> but it sounds like something I might suggest =)
11:48:41 <monochrom> No, you can motivate CCC by mentioning we want function application in the real world. But by the time you define and use the CCC itself, you make it pointfree too.
11:48:44 <dmwit> byorgey: I'm taking credit for being confused, but as I recall I may not have been alone there. Just wanted to be charitable to you two. ;-)
11:49:08 <byorgey> dmwit: hehe, fair enough.  It does sound confusing.
11:49:23 <ReinH> dmwit: I would like to join a CT reading group
11:49:36 <byorgey> ReinH: so start one!
11:49:38 <aupiff> lolisa: I think it's mainly offline... but if people want to do a hangout, we can organize that in the issue thread
11:49:46 <aupiff> lolisa: where are you in China?
11:49:49 <ReinH> byorgey: I thought you folks were doing one, or was that some time ago
11:50:07 <byorgey> ReinH: the one dmwit was referring to was probably 5 years ago
11:50:08 <lolisa> Beijing, Why? 
11:50:11 <ReinH> hah
11:50:14 <ph88> chreekat, i think i'm almost there https://paste.fedoraproject.org/423558/14732741/
11:50:38 <aupiff> I spent some time in Beijing and Shenzhen, was considering going back for an extended period of time.
11:51:01 <aupiff> are you doing FP in China!? how's the local haskell scene?
11:51:18 <rcschm> what were you doing in beijing, aupiff?
11:51:48 <aupiff> I went to a pretty good haskell meetup in Taipei. the talk was in chinese so I understood 30% of what was said. It was a talk on the STG
11:52:42 <aupiff> rcschm: I was fooling around with the idea of manufacturing some electronics in Shenzhen. Mainly I like chinese culture and wanted to hang out there.
11:52:44 <lolisa> No... I am UW stud, I am at Beijing for intern (well scala, but we use it in FP way, with dependent type and finally tagless)
11:52:58 <Gal3rielol> hi lolisa
11:53:19 <lolisa> Hi... Are you the author of haskellforall?
11:53:20 <rcschm> interesting.
11:53:38 <the_2nd> I'm looking for a way to transform readFile errors into an Either / Maybe
11:53:54 <tnks> when working with profunctors, am I missing something like `split`?  or `rmap dupe`?
11:54:15 <chreekat> ph88: that's hilarious, and annoying. try putting an explicit type signature somewhere. I think "input" is defaulting to lazy Text ("actual type") but P.displayT outputs strict Text ("expected type"). Or something like that.
11:54:19 <aupiff> how does finally tagless work? I just strated a job in SCALA. I need to know how to do things functionally in the language. googling "finally tagless" just brought up a gist for me.
11:54:20 <lolisa> But I know a bunch of Chinese Haskell Programmer, they are mostly not satisfy for their job, so if anyone wanna contact them for job stuff I can tell them
11:54:22 <tnks> I can make it myself, just curious when things I expect aren't there.
11:54:30 <monochrom> that depends on what errors. readFile is vocal on some errors and silent on some others.
11:55:13 <monochrom> file-not-found is an error readFile will be vocal on. it will throw and exception. you can turn that into Either by "try" from Control.Exception.
11:55:43 <lolisa> http://okmij.org/ftp/tagless-final/ http://okmij.org/ftp/tagless-final/APLAS.pdf aupiff, I think you just need to see the paper in Haskell, and translate them to scala, which is pretty straightforward
11:55:51 <the_2nd> this try still fails for me: http://lpaste.net/9216399419442724864  (exception simply surfaces, when trying to access e.g. file "sada")
11:55:52 <ertesx> about 'try'…  don't use it
11:55:53 <monochrom> If file opening is successful, subsequent errors will be discarded. You will hear nothing from readFile on them. Absolute nothing.
11:56:27 <the_2nd> monochrom, what am I doing wrong there?
11:56:44 <monochrom> the use of MyException
11:57:12 <ph88> chreekat, i put   prop_reversible :: Text -> Bool   but that didn't help .. what did help was this:  prop_reversible input = input == q_print (q_parse $ T.toStrict input)     do you think that is the best solution ?
11:57:24 <monochrom> You need to read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
11:57:32 <aupiff> lolisa: excellent, I'll check that out.
11:57:46 <monochrom> maybe you can fast forward to the "Typing" section.
11:57:58 <chreekat> ph88: I think it's probably good enough if it gets the job done
11:59:02 <the_2nd> monochrom, thanks a ton
11:59:17 <the_2nd> it's weird how I couldnt find the exception type of readFile
11:59:25 <the_2nd> any resources on what throws what?
11:59:42 <monochrom> the correct type is IOException
11:59:50 <aupiff> that would be a fantastic resource
11:59:58 <monochrom> It will also do you some good by reading the doc of System.IO.Error completely.
11:59:59 <lolisa> BTW, Some shameless self-promotion: I had blogged about finally tagless/SKI/HOAS in https://marisaverymoe.quora.com/Haskell-in-Fantasy-Compiling-Combinator, feel free to comment!
12:00:03 <ReinH> ph88: assuming parse :: String -> Maybe a, you can just check that Just x == (parse . show) x
12:01:03 <ph88> chreekat, when i try to run the test i get  https://paste.fedoraproject.org/423564/32748291/
12:01:55 <ReinH> If you're testing a parser, I can't imagine that you want to generate arbitrary text.
12:01:59 <ph88> ReinH, parse returns Either   https://paste.fedoraproject.org/423566/27487814/
12:02:07 <ReinH> Ok, then Right x instead of Just x
12:02:15 <ph88> ReinH, i thought i could use quickcheck to test if a property holds
12:02:20 <ReinH> Yes, you can.
12:02:25 <ReinH> I didn't suggest otherwise?
12:02:36 <the_2nd> monochrom, can I force haskell to at least display the exception type which makes the program crash?
12:02:43 <ReinH> arbitrary text has an incredibly small chance of being a valid parse
12:02:47 <ph88> ReinH, i'm not sure whether i should generate text or not .. i think not
12:02:50 <monochrom> Yes, see the last section.
12:02:58 <ReinH> and given the way quickcheck generates it, the chance is almost certainly zero
12:03:02 <ReinH> so you are only testing the failed parse
12:03:15 <chreekat> ph88: Actually, I was just wondering about that. 
12:03:23 <ReinH> You shouldn't generate arbitrary text
12:03:24 <ph88> i only want to test the succesful parse on the input i choose
12:03:28 <ReinH> you won't be testing successful parses if you do
12:03:32 <ph88> and then i want to add a few more input cases and test them too
12:03:48 <ReinH> of you have a parser for some `a`, you want to generate arbitrary `a` values.
12:03:51 <ReinH> to test the success case
12:03:58 <ReinH> and arbitrary text values to test the failure case
12:04:27 <ReinH> you use the same property, but the way you generate the text to parse is different
12:04:35 <ph88> what should i do ?
12:04:40 <ReinH> one uses show on the arbitrary `a` value, the other is already text
12:04:56 <the_2nd> monochrom, well, this has everything. I think I'll just catch SomeException
12:05:00 <ReinH> prop_parseSuccess = \x -> Right x == (parse . show) x
12:05:18 <Gal3rielol> ahhh no, i am in the QQ group
12:06:16 <lpaste> dmwit pasted “DeriveAnyClass failure” at http://lpaste.net/186098
12:06:18 <monochrom> SomeException is likely too broad.
12:06:33 <dmwit> I'm confused. I thought the instance I wrote by hand above is exactly the instance `DeriveAnyClass` would have written for me.
12:06:54 <monochrom> If I hit ctrl-c at the right time, I, as a user, would rather your program abort than think that it is a file-not-found.
12:07:05 <ReinH> You will need an Arbitrary instance for the result type of your parser
12:07:15 <ph88> ReinH, the output of print is not Either, it's parse output that is Either .. now i get type errors with the prop_parseSuccess function
12:07:21 <ReinH> and a valid Show instance, e.g., one that is derived
12:07:31 <chreekat> ph88: There's an Arbitrary instance for String, so you could T.pack/T.unpack around that. But String's Arbitrary instance makes some really weird strings. You'll probably be better off making your own Arbitrary instance eventually.
12:07:58 <the_2nd> monochrom, fair point
12:08:02 <chreekat> but I think starting with String will get you to a good milestone you can improve upon
12:08:07 <ph88> chreekat, you mean i control the input's it's generating ?
12:08:33 <shapr> yay Arbitrary!
12:08:37 <ReinH> ph88: so you are testing that a parser and a pretty printer are inverses?
12:08:48 <ReinH> then replace show with your pretty show equivalent.
12:08:51 <ph88> maybe for now i shouldn't use quickcheck to generate input and just do usual unit test
12:09:10 <ph88> ReinH, yes i already did this   prop_parseSuccess = \x -> Right x == (q_parse . q_print) x
12:09:23 <kaol> Please suggest me how to turn a NominalDiffTime value into a ByteString. I just want to feed it to a hash function and have something that changes.
12:09:24 <ReinH> what are the types of q_parse and q_print?
12:10:43 <kaol> I think I'll settle to using the Show instance for now.
12:11:36 <ReinH> time as reported by compulers is dubious, so feeding a time to a hash function is also dubious...
12:11:37 <ph88> ReinH, https://paste.fedoraproject.org/423577/14732754/
12:11:39 <ReinH> *computers
12:11:59 <ReinH> ph88: Why does q_print take an Either?
12:12:16 <ReinH> x isn't an Either
12:12:30 <ph88> ReinH, because the output of q_parse is Either .. and i thought it would be a good idea that i can use those functions together
12:12:45 <ReinH> you don't feed q_parse into q_print
12:12:49 <ReinH> you feed q_print into q_parse
12:13:05 <ReinH> so it doesn't matter what the output type of q_parse is for determining the input type of q_print
12:13:07 <ph88> but my source is Text so i parse it first, no ?
12:13:38 <ReinH> I don't know, I'm just observing that you say (q_parse . q_print), not (q_print . q_parse).
12:14:05 <ReinH> f . g is \x -> f (g x), not \x -> g (f x)
12:14:11 <ph88> ReinH, no i only did that on your suggestion      ReinH> prop_parseSuccess = \x -> Right x == (parse . show) x
12:14:15 <ph88> i replaced show with q_print
12:14:23 <ReinH> Yes, but q_print takes an Either
12:14:32 <ReinH> and you justified that by saying that the output of q_parse is an Either
12:14:34 <ReinH> which is irrelevant
12:14:38 <ReinH> :t show
12:14:40 <lambdabot> Show a => a -> String
12:14:41 <ReinH> show does not take an Either
12:14:44 <ReinH> so why should q_print?
12:14:48 <ph88> this was my other test function     prop_reversible input = input == q_print (q_parse $ T.toStrict input)
12:14:57 <ph88> ReinH, what do you want to do with show ?
12:15:00 <ReinH> You didn't link me to that code
12:15:11 <ReinH> You linked me to code containing q_parse . q_print
12:15:35 <ReinH> So I can't comment on code you haven't shown me, only on code you have shown me.
12:15:50 <ph88> ???    <ph88> ReinH, parse returns Either   https://paste.fedoraproject.org/423566/27487814/
12:15:58 <ReinH> The code you showed me doesn't work because q_print takes an Either
12:16:17 <ReinH> we were just discussing the code that uses q_parse . q_print
12:16:24 <the_2nd> monochrom, safeIO : http://lpaste.net/186104
12:16:43 <the_2nd> safeIO (readFile) FileException "test"
12:16:43 <ReinH> because that's the code you asked a question about and the code you showed me most recently
12:16:53 <the_2nd> -> Left FileException
12:17:08 <ReinH> I am explaining why q_print doesn't work there.
12:17:10 <ph88> ReinH, what do you want to do with that show in prop_parseSuccess ?
12:17:25 <ReinH> I assume you want to replace it with your pretty printing function.
12:17:37 <monochrom> this seems to be a great tool for telling lies.
12:17:41 <ReinH> But at this point I think you are confusing both of us too much to get anywhere
12:17:50 <ertesx> the_2nd: "safeIO" is very misleading
12:17:59 <ertesx> for one thing 'try' is never safe
12:18:01 <ReinH> Well, it's half true.
12:18:03 <the_2nd> nothrowIO ?
12:18:03 <ReinH> It does IO.
12:18:08 <ph88> ReinH, i assumed i was suppose to replace it with my printing function. What do you intend me to do with   show  ?
12:18:23 <ReinH> ph88: ... replace it with your printing function.
12:18:32 <ReinH> But you replaced it with something that takes an Either insetad
12:19:00 <monochrom> I wash my hands off it. I have nothing to do with this lie. Where is that golden bowl when I need it?
12:19:30 <ReinH> And when I pointed out, you said that I was talking about the wrong code, despite the fact that you asked a question about and showed me *this* code.
12:19:31 <ph88> ReinH, i guess with "my printing function" you refer to this part?    \a -> P.displayT $ P.renderPretty 1 1000 $ P.pretty a
12:19:59 <kaol> How would I go about turning a Word64 to a ByteString?
12:20:01 <ReinH> I mean a function from a -> Text where a is the result of your parse.
12:20:08 <ReinH> the function you intend to be a partial inverse to the parse function
12:20:16 <ReinH> at least, if I am understanding that much correctly
12:20:35 <ertesx> kaol: the easiest way is to use a serialisation library like binary or cereal
12:20:42 <ph88> ReinH, parse returns Either
12:20:50 <the_2nd> monochrom, :) . But what if I simply dont want a function to throw an exception and dont really care about "what" went wrong?
12:20:54 <ReinH> That is true and irrelevant.
12:21:15 <ReinH> Ok, the result of a successful parze
12:21:18 <ReinH> parse
12:21:19 <the_2nd> figuring out which exception type is thrown and explicitly catching that is nicer, sure
12:21:23 <ReinH> the type on the right of the Either
12:21:26 <ph88> ReinH, ok but you don't want my print function to take Either. But you want me to put the output of the parse function into the print function. But the parse function returns Either ..
12:21:36 <ph88> oh ok
12:21:39 <ertesx> the_2nd: you still need to handle the exceptional case…  what if opening the file does fail?
12:21:42 <ReinH> I have never asked you to put the result of the parse function into the print function
12:21:51 <ReinH> I have specifically told you that this is *not* what I want you to do
12:21:58 <the_2nd> ertesx, then I have my Left ex and know it failed
12:22:00 <ReinH> I was very clear about this, I thought.
12:22:11 <ph88> maybe, but i'm still confused
12:22:15 <ReinH> I pointed out repeatedly that you are not doing print . parse, you are doing parse . print
12:22:21 <the_2nd> monochrom, your guide is very good, do you have a Stackoverflow account?
12:22:27 <ReinH> which feeds the result of print into parse
12:22:31 <ReinH> it does NOT feed the result of parse into print
12:22:35 <ertesx> the_2nd: now instead of going through Either and making it horribly unsafe just use 'catch' where it matters and do nothing where it doesn't matter…  can't get easier than that
12:22:42 <monochrom> I am not on stackoverflow
12:22:49 <ph88> ReinH, why would i want to feed the result of print into parse ?
12:23:07 <ReinH> My understanding is that you want to test if your parser parses things that your printer generates
12:23:28 <ReinH> That is what you appeared to be doing in your code
12:23:33 <monochrom> I think "sometimes I just want to suppress exceptions" should be done on a case by case basis, rather than a general utility for it.
12:23:48 <the_2nd> ertesx, I would basically only use it for e.g.  https://hackage.haskell.org/package/wreq-0.4.1.0/docs/Network-Wreq.html     "get"
12:23:57 <ph88> ReinH, no i want to test that  the source code i put into my printing function and then into my parsing function is again the same source code
12:24:16 <ReinH> That's what I just said.
12:24:26 <the_2nd> monochrom, there's many un-/badly answered questions about exception handling. I think your guide should be linked there / you could help
12:24:31 <ReinH> You print x, then you parse the printed x
12:24:37 <ReinH> you want this x to be the same as the original x if the parse succeeds
12:24:39 <ReinH> that's what I said
12:24:43 <ph88> ReinH,   input -> parse -> syntax tree -> print -> output  ,  now i want to test that   input equals output
12:24:54 <ReinH> How do you generate input?
12:25:01 <ph88> i want to give it myself
12:25:07 <the_2nd> monochrom, also http://stackoverflow.com/documentation/haskell/topics
12:25:08 <ReinH> Then why are you using quickcheck?
12:25:29 <ph88> i thought i could use quickcheck to test that the property    input equals output   must hold
12:25:39 <ReinH> QuickCheck is for generating unputs
12:25:40 <ertesx> the_2nd: good…  now first rule: never use 'try'…  there is literally not a single safe use case of 'try' i can think of, and i believe it should be removed from the API
12:25:40 <ReinH> inputs
12:25:44 <ReinH> you want to generate your own inputs
12:25:48 <ReinH> so quickcheck does nothing for you
12:26:01 <shapr> write your own generators?
12:26:16 <ertesx> the_2nd: second rule:  choose the appropriate combinator from this list:  bracket, catch, catchJust, finally, onException
12:26:25 <ertesx> the_2nd: there are a few others, but mostly you'll only need those
12:26:28 <ReinH> input == output tests that property. No QuickCheck involved.
12:26:31 <the_2nd> ertesx, so what if I have a web server where users submit url which I want to fetch data from? Currently a wrong url makes the entire request crash
12:26:40 <ReinH> (for suitable definitions of input and output)
12:26:49 <ertesx> the_2nd: use 'catch'
12:26:51 <ph88> ReinH, so can QuickCheck generate the syntax tree  and then do    syntax tree -> print -> text -> parse -> syntax tree    test that syntax tree at start and finish are the same ?
12:27:03 <ReinH> Yes, that's what I was telling you to do.
12:27:19 <ReinH> That's what my example does
12:27:28 <ph88> oh i didn't understand this, because that's not what i intended to do .. but your suggestion sounds interesting
12:27:48 <ReinH> You are testing that arbitrary (AST?) values can round trip through printing and parsing
12:28:11 <ReinH> testing that arbitrary texts can be parsed doesn't make sense
12:28:19 <ReinH> since almost all arbitrary texts can't be parsed
12:28:28 <ph88> and testing arbitrary syntax tree values makes sense ?
12:28:30 <ReinH> you want to generate some candidate texts manually and use normal unit tests, in that case
12:28:40 <ReinH> yes, because an arbitrary syntax tree is guaranteed to be a syntax tree
12:28:48 <ph88> ok i want to test both now
12:28:51 <ReinH> an arbitrary text is not guaranteed to be a textual representation of a syntax tree. Most of them will be garbage.
12:29:08 <ertesx> the_2nd: if you're worried about too much code nesting with all those CPS/callback-based functions, there are safe ways to avoid that…  my personal favourite is to use Codensity
12:29:24 <ph88> syntax tree input with quickcheck, and source input with normal unit tests
12:29:29 <ReinH> right
12:29:34 <ertesx> the_2nd: but if it's really just a single use site it doesn't pay off
12:29:43 <ertesx> just write that 'catch' there and be done with it
12:30:20 <implementation> :t try
12:30:21 <lambdabot> Exception e => IO a -> IO (Either e a)
12:30:47 <implementation> mhh. awful.
12:31:20 <monochrom> ertesx: Why is try unsafe?
12:32:56 <dfeuer> I think we need a magical type   Lower :: Type -> TYPE PtrRepUnlifted. Then we'll be able to use lower :: a -> Lower a; lower !a = unsafeCoerce# a  and   unlower :: Lower a -> a; unlower a = unsafeCoerce# a, and be able to express in a type signature that something is sure to be in WHNF.
12:33:04 <ph88> ReinH, i have this now https://paste.fedoraproject.org/423592/73276753/
12:33:31 <rios> @pl \x -> x+x
12:33:31 <lambdabot> join (+)
12:33:50 <ertesx> monochrom: because it leaves a gap between receiving the exception and handling it…  you would need to 'mask', but then you could just as well use 'catch', which does it for you
12:34:09 <rios> @pl nest f n x = f $ nest f (n-1) x
12:34:10 <lambdabot> nest = fix (liftM2 (.) (.) . flip flip (subtract 1) . ((.) .))
12:34:34 <ReinH> rios: please experiment with lambdabot via /query
12:34:48 <rios> sorry
12:34:58 <ReinH> (Also I would prefer (*2) to join (+) ;)
12:35:01 <ph88> ReinH, it type checks but it seems i'm missing something on my data type   https://paste.fedoraproject.org/423593/73276859/
12:35:06 <ertesx> :t \c f = mask $ \unmask -> try (unmask c) >>= either f pure
12:35:08 <lambdabot> error:
12:35:08 <lambdabot>     parse error on input ‘=’
12:35:08 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
12:35:13 <ertesx> :t \c f -> mask $ \unmask -> try (unmask c) >>= either f pure
12:35:15 <lambdabot> Exception a => IO b -> (a -> IO b) -> IO b
12:35:28 <ReinH> ph88: Yes, your data type needs to be an instance of Arbitrary so that quickcheck can generate values
12:35:36 <ph88> oki
12:36:09 <monochrom> OK, so suppose I write: catch (fmap Just getLine) (\_ -> return Nothing). Is that safe?
12:37:10 <ertesx> that's the same thing, except with Maybe…  but since you're not really *handling* the exception, i suppose it's safe
12:37:59 <implementation> dfeuer: what's the practical difference to newtype Lower a = Lower a; with lower :: a -> Lower a; lower !a = Lower a? for using a function expecting a Lower argument you need to explicitely call lower, which evaluates the argument to WHNF, and that's encoded in the type system since there's no other method to create a Lower value (constructor not exported)
12:38:06 <ertesx> if there is any handling you want to do that involves interruptible I/O, even if it's just writing a log message, then try is unsafe
12:38:25 <monochrom> Oh sure, I know that. I would never do that.
12:39:08 <monochrom> The problem is that I could do a dual fearmongering on catch.
12:40:06 <dfeuer> implementation, I'm talking about something that GHC's optimizer will be able to work with. It seems this has already been proposed as part of https://ghc.haskell.org/trac/ghc/wiki/UnliftedDataTypes
12:40:13 <dfeuer> (section 4)
12:40:25 <monochrom> The handler is run masked. So if the program's goal is "attempt getLine first, but if it fails, attempt to read such-and-such file", then catch is wrong, or at least, catch is wrong if you put the whole "attempt to read that file" inside the handler.
12:41:19 <implementation> dfeuer: thanks!
12:41:39 <ertesx> monochrom: note that catch's masking is interruptible
12:41:49 <ertesx> but that's probably not your point
12:42:59 <ph88> ReinH, i have two question about the Arbitrary instance  https://paste.fedoraproject.org/423598/73277334/
12:44:27 <ReinH> ph88: For (2), you will need arbitary values "all the way down", so for LibraryClause and UseClause and their constituent parts, until you get to something that already has one.
12:44:49 <ReinH> Then you can use some combinators to generate the trees
12:45:07 <ph88> ReinH, yes i figured that i need to make an Arbitrary instance for ContextItem too .. just once i have that, how do i say i want to use it ?
12:45:45 <ph88> also i noticed that QuickCheck doesn't have a generator for Text ? so i need to make that too, right ?
12:45:56 <dfeuer> Is there some class that can let me write properties that work for both QuickCheck and SmallCheck?
12:47:43 <monochrom> My perspective is that programmers who are not familiar with Haskell/GHC's story of exceptions, who are more familiar with other languages' exceptions (which are much less thoroughly scrutinized), when those programmers ask about "handling an exception", they do not always mean your sense of handling. Much more often, they just mean "plan B", for which "try" is the right tool.
12:47:46 <ReinH> you can use the generator for String and fmap Text.pack
12:47:52 <ReinH> either directly, or in an orphan instance
12:49:09 <ertesx> monochrom: am i fearmongering?  i might be, but unfortunately 'try' is really easy to get wrong and rarely provides an advantage over the other combinators…  i'd say that 'catch' is a much easier combinator for "plan B" scenarios
12:49:22 <ReinH> ph88: regarding (1), the size is set implicitly for all generators, but can be modified for a specific generator via `resize`
12:49:31 <ReinH> basically Gen a values hold a size parameter that you can't see
12:49:37 <ReinH> but you can set with `resize`
12:49:40 <ph88> eh ok
12:49:42 <ReinH> yielding a new generator
12:49:54 <ReinH> The docs are a bit unclear there, I agree.
12:50:13 <ReinH> For your purposes, you probably don't need to worry about the size
12:50:14 <ertesx> planA `catch` \(SomeException _) -> planB
12:50:48 <ph88> ReinH, i thought if i set a max size that it might help with performance .. but ok maybe it's not an issue
12:50:56 <ReinH> ph88: regarding how to write your Arbitrary instance, you need to write an isntance for a sum type, so why not look at the source for the existing Either instance
12:51:03 <ReinH> there is already a reasonable size
12:51:53 <ReinH> You probably don't need to worry about shrink, just arbitrary
12:52:35 <ReinH> so it's: arbitrary = oneof [fmap CI_Library arbitrary, fmap CI_Use arbitrary]
12:52:44 <ReinH> (you can use fmap instead of liftM now)
12:53:16 <ph88> ReinH, i think this should be enough   instance Arbitrary ContextClause where     arbitrary = do;    cc <- listOf arbitrary;    return CC cc
12:53:58 <ReinH> You need a return, and that's equivalent to arbitrary = CC <$> listOf arbitrary
12:54:00 <ph88> fmap seems reasonable, i've been using that before
12:54:10 <ReinH> or fmap CC (listOf arbitrary)
12:54:18 <ReinH> since <$> is fmap
12:54:37 <ph88> i have a return
12:55:01 <ReinH> Oh you do, sorry, the line break confused me
12:55:11 <ReinH> But I was referring to the instance for ContextItem
12:55:22 <ReinH> which needs to be a choice between the CI_Library constructor and the CI_Use constructor
12:55:35 <ph88> yes, you are ahead of me :)
12:55:40 <ReinH> and is required for the ContextClause instance, since listOf arbitrary there refers to the arbitrary defined for ContextItem
12:55:51 <ReinH> (the line break on my screen, that is)
12:57:12 <ReinH> Oh, that needs to be return (CC cc) then
12:57:18 <ReinH> since return CC cc is (return CC) cc
12:57:30 <ph88> yes
12:57:39 <ph88> but i took your shorter version
12:57:41 <ph88> without do
12:57:51 <chipf0rk> hi there! does anyone have experience with Servant? I'm working through the tutorial and this type is throwing me off: `type UserAPI = "users" :> QueryParam "sortby" SortBy :> Get '[JSON] [User]`
12:57:55 <chipf0rk> why the prime? is that a TypeOperator of some sort? I haven't seen that before
12:58:03 <ReinH> Right, do x <- k; return (f x) = fmap f k is a useful law
12:58:27 <monochrom> chipf0rk: Do you already know about the DataKinds extension?
12:58:36 <chipf0rk> only tangentially
12:58:50 <chipf0rk> what's a good place to read up on that?
12:58:51 <monochrom> OK, you need to know a bit more about that.
12:59:00 <monochrom> I learned from the GHC user's guide.
13:00:20 <chipf0rk> hmm, I think I'm missing some more foundations for that...
13:01:12 <chipf0rk> probably the whole Chapter 7 there :P
13:01:30 <monochrom> 7.9
13:02:25 <monochrom> The short story is that '[JSON] is a type-level list of length 1.
13:02:32 <ph88> ReinH, no question, but i just want to show this :P    instance Arbitrary Text where    arbitrary = T.pack <$> listOf (arbitrary :: Gen Char)
13:03:01 <monochrom> Later, 7.10 will tell you what is "users" doing there.
13:07:09 <thomasd> is there support in postgresql-simple for generic to&fromField instances for newtypes?
13:07:13 <thomasd> I have searched to no avail
13:07:28 <thomasd> and have a simple working impl that would work for all newtypes
13:07:43 <thomasd> wondering if I should PR because it seems useful
13:07:45 <ReinH> ph88: ok, but why not T.pack <$> arbitrary?
13:07:49 <ReinH> String has an instance
13:07:59 <ReinH> ph88: glad things are coming together for you though
13:08:30 <ReinH> That does demonstrate an ability to put concepts you've learned together in new ways, which is an indication that you are internalizing knowledge, which is progress! :D
13:08:56 <ReinH> (I hope that doesn't come across as patronizing, I am trying to be sincere.)
13:09:11 <ph88> ReinH, don't see not no Arbitrary instance for String
13:09:17 <ph88> -not
13:09:18 <ReinH> Reeeeally?
13:09:29 <Clint> ph88: do you know about quickcheck-instances
13:09:34 <ph88> http://media.urbandictionary.com/image/large/yarly-34109.jpg
13:09:35 <ReinH> Oh, it is probably the Arbitrary a => Arbitrary [a] instance
13:09:45 <ph88> Clint, getting to know them now :P
13:10:51 <ReinH> ph88: iow, if Char is an instance (it is!) and String is [Char] (it is!) then String is an instance by combining those things.
13:12:11 <ph88> oh it's just    instance Arbitrary Text where    arbitrary = T.pack <$> arbitrary
13:12:18 <Clint> @hackage quickcheck-instances
13:12:18 <lambdabot> http://hackage.haskell.org/package/quickcheck-instances
13:12:36 <ph88> oooh
13:13:00 <ReinH> ph88: right, because there is an instance for String, it's just a rube goldberg instance.
13:13:02 <ph88> Clint, how do i use that? no doc page
13:13:08 <ReinH> that goes by [a] and Char
13:13:18 <ReinH> ph88: you just look at the instances and say "Oh, I need that instance"
13:13:26 <ReinH> and when you import the module, the instance is in scope now
13:14:03 <Clint> ph88: you can do import Test.QuickCheck.Instances ()
13:14:12 <ReinH> instances defined in a module infect your program when you import that module whether you want them to or not :)
13:14:51 <ph88> infect .. that doesn't sound too good :/
13:15:08 <ReinH> yay infection!
13:15:11 <ReinH> See now it sounds good
13:15:33 <ReinH> It's just a behavior of imports and typeclasses that I have chosen to assign a value judgement to in a mostly joking way :)
13:15:43 <monochrom> You need to think more positively. The instances illuminates your code.
13:15:56 <ReinH> if you import a module, you *can't* not import the instances it defines.
13:16:19 <ReinH> monochrom: :D
13:17:48 * hackagebot do-list 0.8.1 - List construction with do notation  https://hackage.haskell.org/package/do-list-0.8.1 (TarasSerduke)
13:17:50 * hackagebot colonnade 0.4.1 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/colonnade-0.4.1 (andrewthad)
13:17:53 * hackagebot reflex-dom-colonnade 0.4.1 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.4.1 (andrewthad)
13:18:03 <monochrom> Next time remind me to use the "pay it forward" analogy!
13:19:09 <monochrom> And on April 1st, remind me to use the "GPL" analogy.
13:19:31 <ReinH> I see what you did there.
13:19:51 <ReinH> columnar encoding and decoding, eh
13:21:15 <ph88> how can i import this ?    https://github.com/mrkkrp/megaparsec/blob/6a7c41d88998d5358b10920497fb6efe388ab3a5/tests/Util.hs#L249-L253
13:22:54 <jacereda> how would you translate 'record puns' into Spanish?
13:23:20 <monochrom> perhaps translate the two words separately
13:23:35 <monochrom> Do you have a phrase for puns?
13:23:40 <jacereda> monochrom: juegos de palabras
13:24:00 <monochrom> I think "palabras" is right on.
13:24:09 <Welkin> does anyone know about elm?
13:24:49 <monochrom> No.
13:25:06 <kadoban> play on words? Isn't it "pun" more in the sense that it's one word that means multiple possible things instead? Almost seems to miss the intended definition.
13:26:30 <jacereda> kadoban: I somehow agree, do you have any suggestion?
13:27:22 <jacereda> kadoban: maybe "doble sentido"?
13:27:24 <kadoban> Is there a word that more directly means like uhm ... almost homophone, but that's not the right one.
13:28:10 <jacereda> kadoban: homografa? same spelling but different meaning you mean?
13:28:15 <Welkin> damn it elm is annoying
13:28:45 <kadoban> jacereda: Yeah, maybe? doble sentido sounds possible too. (to be clear, I know spanish almost not at all)
13:28:55 <glguy> hom·o·graph - each of two or more words spelled the same but not necessarily pronounced the same and having different meanings and origins (e.g., bow1 and bow2).
13:29:18 <glguy> Maybe something related to that?
13:29:38 <geekosaur> as jacereda already said
13:30:10 <kadoban> homografa is sounding pretty good to me, as a best guess. And then however you say the rest
13:30:15 * geekosaur 's rather weak Spanish is not up to translating that...
13:31:28 <Insanity_> What does 'record puns' actually mean?
13:31:40 <Insanity_> Doble sentido doesn't seem right to say 'pun' though
13:31:50 <jacereda> I think I'll go for "doble sentido en registros"
13:32:14 <geekosaur> a record pun is literally giving one symbol multiple meanings (as both field label and local binding)
13:32:15 <jacereda> https://downloads.haskell.org/~ghc/7.0.2/docs/html/users_guide/syntax-extns.html#record-puns
13:32:31 <ph88> i tried to   import Text.Megaparsec.Util  to get this instance  https://github.com/mrkkrp/megaparsec/blob/master/tests/Util.hs#L249-L253  ghci says fails to load interface .. what's going on  ?
13:32:39 <Insanity_> oh in that case geekosaur, it makes sense - I had to know the context for pun ^^
13:32:47 <geekosaur> rather than making the programmer establish that mapping manually
13:33:04 <Insanity_> doble sentido is essentially meaning 'double meaning', often in terms of an underlying meaning in sexual context
13:33:13 <Insanity_> Listen to reggaeton and halve the lyrics are like that :D
13:34:07 <geekosaur> ph88, "failed to load interface" means no .hi file was found for that module
13:34:26 <ph88> geekosaur, can i use this instance in another way ?
13:34:29 <geekosaur> which usually means the module was not exposed from the library
13:35:03 <geekosaur> build megaparsec locally, modified to expose that module (exposed-modules instead of other-modules or being listed only in a test stanza)
13:35:59 <glguy> ph88: The Util module is only available within the test component that defines it
13:36:23 <glguy> Are you working on the test component of megaparsec?
13:37:39 <geekosaur> Insanity_, actually the English version of "doble sentido" has a similar connotation --- but English actually imported the French rendition of it ("double entendre" but with English pronunciation)
13:37:47 <ph88> glguy, no .. in my AST i capture the source position of tokens .. and i need to make a quickcheck instance (Arbitrary) so i need an instance of this too .. you understand ?
13:37:58 <geekosaur> well, "double" is English and "entendre" is confused mess >.>
13:38:05 <glguy> ph88: Sure, you just can't use the Util module to do it.
13:39:46 <nitrix> I have a strange problem where my network application doesn't seem to detect a client disconnected until another client sends something. And even then, sometimes it's still glitchy.
13:40:37 <nitrix> http://lpaste.net/186167
13:40:58 <nitrix> This was taken from the wiki I believe, adapted a little, and I'm puzzled as to what's going wrong.
13:50:38 <dmwit> You know what would be cool? If `cabal exec` treated all arguments after the one it decides is going to be the command it runs as arguments to the command without requiring `--`.
13:51:28 <glguy> One way to get that would be to not called getOpt with Permute, but with RequireOrder
13:52:39 <dmwit> That sounds right.
13:52:59 <lpaste> sebboh pasted “stack.yaml” at http://lpaste.net/186178
14:03:06 <NickHu> Does anyone know of any place else to watch this video Simon Peyton Jones did on lenses? https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
14:16:09 <johnw> NickHu: http://ftp.newartisans.com/pub/Lenses.mp4
14:16:30 <NickHu> johnw: Thanks :)
14:17:49 * hackagebot ogmarkup 2.3 - A lightweight markup language for story writers  https://hackage.haskell.org/package/ogmarkup-2.3 (lethom)
14:24:21 <dominik>  /quit 
14:24:44 <johnw> we don't let people leave here; that's what Monads are all about
14:25:07 <glguy> Should have been using glirc2 so that the command highlighting would have indicated that the command wasn't recognized
14:25:42 <intothem2untains> I have somewhat of a design issue together with the issue with not being too familiar with haskell
14:26:42 <dmwit> intothem2untains: shoot
14:26:50 <intothem2untains> I want a map where the values satisfy a typeclass constraint
14:26:59 <intothem2untains> Which I know isn't possible (right?)
14:27:13 <ongy> glguy and a shameless self promotion
14:27:14 <intothem2untains> They have to be all of the same type
14:27:25 <dmwit> It is possible, but generally considered a code smell.
14:27:38 <glguy> ongy: definitely
14:27:41 <intothem2untains> dmwit: the values would in this case be "player types"
14:27:52 <intothem2untains> The idea is to have this player types pluggable
14:28:04 <intothem2untains> So that you don't have to modify all the code to add yours
14:28:35 <dmwit> ?google haskell existential antipattern
14:28:36 <lambdabot> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
14:28:42 <intothem2untains> I also thought about defining a data with a type as parameter
14:29:03 <monochrom> haha johnw
14:30:04 <intothem2untains> dmwit: any ideas for designing it some other way?
14:30:40 <dmwit> intothem2untains: Did you peruse the link I suggested?
14:31:24 <monochrom> I don't know what is "pluggable". But you still have a choice between "record of methods" and "existential with class constraint which means record of methods"
14:31:59 * intothem2untains needs some time to think
14:32:23 <dmwit> Thinking is encouraged. =)
14:32:31 <monochrom> Difference being: "record of methods" means there is just one record type. When I write my plugin, I just write a record value.
14:33:00 <johnw> "record of methods" can be very handy
14:33:18 <johnw> I use them rather often, actually
14:33:35 <monochrom> "existential with class constraint" means there is no pre-existing type. When I write my plugin, I first invent my own type, then I write an instance "instance YourClass MyType where".
14:34:02 <monochrom> You know what? They are semantically equivalent (or almost), but the second way is more boilerplate.
14:34:54 <johnw> monochrom: isn't that exactly what the anti-pattern blog discusses?
14:34:55 <monochrom> And here "more boilerplate" means the same as: in Java, if I just want to define a function, even an int constant, I have to first invent my own class, then put my function or constant as a "method".
14:35:13 <johnw> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
14:35:14 <monochrom> I don't know. I haven't read it a long time, and I don't want to know anymore.
14:35:36 <dmwit> Knowing could save you having to type out the same diatribe over and over.
14:35:42 <monochrom> But "it's a bit more boilerplate" is still not sufficient to fearmonger it as "antipattern"
14:35:43 <dmwit> It is why I am so fond of linking to SO here on IRC.
14:36:19 <dmwit> monochrom: You should lay down the same screed, with your preferred nomenclature, on vex.trebla.net. =)
14:36:30 <johnw> it would be cool if lambdabot googled every question asked on this channel, and if it finds a hit within the top ten that has a sufficient number of the words being asked, it automatically presents it
14:36:38 <monochrom> And my "same diatrib" still takes 1/10 of the time to read than a huge blog article.
14:36:49 <MarcelineVQ> What does a record of methods mean?
14:37:01 <johnw> I find that if you simply google what is asked here, maybe often there is an SO article that answers the exact same time
14:37:03 <dmwit> MarcelineVQ: Read the huge blog article for the details.
14:37:20 <intothem2untains> tbh, after you mentioned the record of methods method, it amazes me how i spent a couple of hours thinking about this when it had such a simple solution
14:37:22 <monochrom> data X = Y { f1 :: Int -> Bool, f2 :: Char -> IO () }
14:38:09 <MarcelineVQ> Oh I see thank you
14:38:52 <monochrom> The blogging antipattern.
14:38:58 <intothem2untains> "haskell map satisfies typeclass constraint"
14:39:07 <intothem2untains> that doesn't yield any articles about the antipattern
14:39:12 <intothem2untains> gotta know what to search for
14:39:52 <sm> johnw: +1
14:40:37 <monochrom> no no, you have to google your question verbatim in order to be fair. "a map where the values satisfy a typeclass constraint"
14:41:15 <Sonolin> yea that is a great article johnw, I hate it when I see this crap (mainly in xmonad code)
14:41:25 <Sonolin> i.e. LayoutClass vs. Layout confused me a lot when I was learning
14:42:39 <intothem2untains> monochrom: well, maybe it is because i use startpage, but i don't find anything related to what has been mentioned
14:44:33 <Zemyla> Is there a way to express in Haskell that a monoid or semigroup is idempotent?
14:44:45 <dmwit> Sonolin: As I recall, the xmonad code is slightly defensible, in that it can use the current configuration's type to drive the deserialization of the WM state being passed during restart.
14:45:05 <dmwit> Sonolin: Which would be trickier to do with a record of methods.
14:46:23 <monochrom> Yeah, there are times you want a distinct type.
14:47:40 <Sonolin> yea that makes sense
14:48:10 <dmwit> Zemyla: I'm not sure Haskell itself offers much for representing any law at all.
14:48:11 <Sonolin> I still feel like that's a bad strategy to make such a global code practice, just for the practice of (de)serialization
14:48:33 <dmwit> Zemyla: Standard practice seems to be to write a comment on your class definition stating its laws.
14:48:34 <ertesx> Zemyla: you could introduce a class for them, but it would be empty
14:48:40 <Sonolin> but xmonad isn't exactly a pinnacle of beautiful code either ;)
14:48:57 <dmwit> Zemyla: But this will be available to the programmer only, and not to the compiler in any meaningful way.
14:50:11 <amalloy> is there something like scanl for general Foldable instances, rather than just lists? i was surprised not to find it in Data.Foldable
14:50:35 <amalloy> of course i could implement it myself but i wouldn't expect to have to
14:50:45 <monochrom> I don't think it makes sense. What would scanl mean for trees?
14:53:52 <amalloy> it makes just as much sense as foldl, doesn't it? it's like calling foldl, but instead of returning only the final result you return each of the intermediate results
14:54:05 <dmwit> ?hackage dual-tree -- to answer monochrom in a totally tongue-in-cheek way
14:54:05 <lambdabot> http://hackage.haskell.org/package/dual-tree -- to answer monochrom in a totally tongue-in-cheek way
14:54:23 <dmwit> :t scanl
14:54:25 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
14:54:31 <johnw> you could always use scanl on the value returned from Foldable.toList
14:54:46 <dmwit> :t \f z -> scanl f z . toList
14:54:48 <lambdabot> error:
14:54:48 <lambdabot>     Ambiguous occurrence ‘toList’
14:54:48 <lambdabot>     It could refer to either ‘F.toList’,
14:54:57 <dmwit> ...yes, what johnw said.
14:55:16 <monochrom> Oh God "DUALTree d u a l"
14:55:27 <kadoban> Haha
14:55:45 <dmwit> down, up, annotation, leaf
14:55:53 <dmwit> It's really delightful.
14:56:04 <monochrom> to be fair, the for type variables "d u a l" came before they decided to call it "DUAL tree", not after.
14:56:14 <monochrom> s/for/four/
14:56:45 <monochrom> (Do I get a certificate of Excellence in US English for spelling "four" as "for"? :) )
14:58:04 <dfeuer> monochrom, no, just a certificate of Exelence.
14:58:38 <monochrom> heh
15:12:34 <intothem2untains> Regarding this record of methods strategy… Can I derive Eq if one of those methods has an IO monad in its signature?
15:12:42 <monochrom> No.
15:13:22 <monochrom> I don't think Eq makes sense for most plugin schemes.
15:15:35 <intothem2untains> monochrom: It seems that having such a data type as the value type of a map asks for it
15:15:37 <monochrom> They usually use a weaker notion based on "each plugin is given a unique ID". Sometimes you get it for free from pointers.
15:15:41 <intothem2untains> Or that's what I understand
15:16:00 <monochrom> No, keys require Ord, no constraint on values.
15:17:04 <intothem2untains> monochrom: oh, nvm, it is because I try to derive Eq on another data type that has this map in it
15:18:30 <intothem2untains> Well, good night and thanks for the help!
15:22:35 <johnw> is it possible to iterate through all active allocations on the heap managed by mallocBytes?
15:24:32 <monochrom> yikes, mallocBytes simply calls C's malloc.
15:24:47 <johnw> ah, that actually makes my life much simpler
15:24:52 <monochrom> "foreign import ccall unsafe" too
15:25:10 <johnw> i should have just gone to the source, sorry for asking
15:25:22 <johnw> mallocBytes size  = failWhenNULL "malloc" (_malloc (fromIntegral size))
15:26:32 <monochrom> But nice to know that it solves your problem better.
15:27:04 <monochrom> maybe eliminates the problem in the first place
15:27:07 <johnw> I'm trying to verify heap buffer to an approximation; if it's all libc, then I have very few restrictions :)
15:27:13 <johnw> s/buffer/behavior
15:28:46 <johnw> on darwin, I can use malloc_zones to iterate through all open reservations, if I call MALLOC_LOCK first; this is what I needed to do
15:30:20 <monochrom> Nice. Totally one of those times you get to say: "I have a bad news and a good news"
15:30:26 <johnw> lol
15:43:52 <johnw> is there any literature on tricks to fuse away AST representations when evaluating deeply embedded terms?  I'd like to use a deep embedding in order to keep one part of my application pure, but I don't want to pay the build/fold cost.  Is there a way to give GHC enough insight into the pure code so that it can fuse in the evaluation?
15:44:15 <johnw> it's easy enough in the explicit case: https://gist.github.com/03395069ac1b3a2e0bf011f1e3d9805e
15:45:08 <mpickering> johnw: Yes there is a lot of literature about this. Maybe search for things like "partial evaluation" 
15:45:13 <johnw> I guess I'd just need to teach it how to plumb the eval through the code?
15:45:31 <mpickering> Oleg has some papers about it as well 
15:45:56 <johnw> thanks!
15:47:24 <johnw> wow, a whole SIGPLAN workshop on the topic :)
15:47:35 <johnw> I love it when a #haskell question leads me into a new academic area
15:50:31 <mpickering> of particular relevance might be the "final tagless" style
15:50:45 <johnw> right
15:50:50 <johnw> I'm queueing up the PDFs now :)
15:51:01 <mpickering> but it won't be very good if you want to maniplate the trees a lot
15:51:31 <johnw> I won't manipulate them at all
15:51:39 <mpickering> This is also quite related to metaprogramming and staging if you know about them?
15:52:09 <mpickering> Asking the compiler to do inlining, specialisation and apply rules is like an automatic stupid form of partial evalation which you could do explicitly using metaprogramming
15:52:19 <johnw> my situation is that I'm refining Coq code to an executable model.  My first thought was to axiomatize IO and refine to that, but then I thought: why not refine to a DSL term, and then just write the evaluator on the Haskell side?  Which solves my Coq problems beautifully, but then incurs a runtime overhead.  Hence the question.
15:57:56 <mpickering> If you look at the core of this program then you see it compiles to 70 https://www.irccloud.com/pastebin/oRiorRTL/
15:58:17 <mpickering> "ghc -O2 -ddump-simpl -dsuppress-all
15:58:56 <johnw> using typeclasses here would be very tricky for me
15:59:18 <johnw> but I could research that avenue
15:59:21 <johnw> thanks for the thought!
16:00:05 <johnw> it might require hacking the extracted code with perl to substitute use of a regular term data type with a typeclass interface, but it could be worth it
16:17:52 * hackagebot haskoin-core 0.4.0 - Implementation of the core Bitcoin protocol features.  https://hackage.haskell.org/package/haskoin-core-0.4.0 (xenog)
16:17:54 * hackagebot haskoin-node 0.4.0 - Implementation of a Bitoin node.  https://hackage.haskell.org/package/haskoin-node-0.4.0 (xenog)
16:17:56 * hackagebot haskoin-wallet 0.4.0 - Implementation of a Bitcoin SPV Wallet with BIP32 and multisig support.  https://hackage.haskell.org/package/haskoin-wallet-0.4.0 (xenog)
16:17:58 * hackagebot servant-cassava 0.8 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.8 (jkarni)
16:33:29 <lpaste> hoppfull pasted “Pattern matching” at http://lpaste.net/186267
16:34:29 <hoppfull> Hey. I am curious if I can match against a wider range of cases like this: http://lpaste.net/186267
16:34:58 <Welkin> hoppfull: no
16:35:01 <Welkin> you need to use a guard
16:35:04 <amalloy> hoppfull: you can use guards, but you don't have to use case
16:35:10 <amalloy> f x | x < 10 = ...
16:35:35 <hoppfull> Welkin, amalloy: Thanks guys!
16:37:03 <athan> @type otherwise -- hoppfull :)
16:37:05 <lambdabot> Bool
16:37:25 <athan> @check \x -> x || otherwise
16:37:28 <lambdabot>  +++ OK, passed 100 tests.
16:40:07 <hoppfull> athan: What do you mean with "@type" and "@check"?
16:41:56 <hoppfull> Hey. Is (\x y -> x + y) curried behind the scenes?
16:42:28 <jle`> hoppfull: it's sugar for (\x -> \y -> x + y)
16:42:30 <jle`> if that's what you mean
16:42:39 <hoppfull> jle`:yeah
16:44:45 <hoppfull> Do any of you get to work with Haskell or is this just something you do on your own time when you're not at the cubicle writing C# or Java? I ask because I would like some advice on where I might look to find work with Haskell, F# or Scala. Everyone seems to be doing OOP.
16:45:07 <Welkin> hoppfull: many places do not use oop
16:45:14 <Welkin> you are just looking in the wrong places
16:45:19 <Welkin> filter out the java/dotnet shops
16:45:39 <Welkin> haskell jobs are scarce, but you can do it as a consultant if you find the right clients
16:46:30 <nshepperd_> I think in the implementation (stg) it is actually a function object with two arguments
16:46:31 <hoppfull> Welkin: It's been my impression that doing it as a consultant is one way.
16:46:39 <amalloy> i did clojure for a living for ~5 years. FP jobs exist
16:46:40 <athan> I mean the ISWYM machine :v
16:49:22 <hoppfull> I'm doing an internship right now at a small startup with a bunch of brogrammers. They're nice people but I'm starting to learn about "culture fit" and it's importance.
16:50:09 <ggVGc> hoppfull: the best way is probably to cme up with a service, implement it in haskell and sell it!
16:52:06 <athan> ggVGc: ...good idea :|
16:52:35 <hoppfull> ggVGc: Interesting. I don't see myself as a businessman but then I didn't see myself as a programmer a couple of years ago.
16:53:15 <Welkin> hoppfull: I built a couple products in haskell and did some consulting with it too building web apps
16:55:08 <Welkin> and I plan on building all of my web app products in haskell for the foreseable future, since nothing better exists for that
16:55:45 <ggVGc> Welkin: I've been playig with Elixir the past months and it's also pretty great
16:55:46 <ggVGc> imo
16:55:48 <hoppfull> Welkin: Are you involving the browser? Are you using GHCJS?
16:56:43 <Welkin> hoppfull: no, I haven't used that yet
16:56:51 <Welkin> I mostly do server rendering
16:56:57 <hoppfull> ggVGc: I played a little with Elixir and it's cool but I don't know. I need a strong static type system to hold my hand. What took me ages to get right in node and elixir actually worked out great in F# (implementing my own server from scratch even!)
16:57:27 <Sonolin> Welkin what kind of apps are you building?
16:57:34 <Welkin> but yes you can use reflex-dom with ghcjs to build in-browser apps
16:57:57 <Welkin> Sonolin: pretty simple services
16:58:05 <Welkin> at the time I wrote all the javascript by hand
16:58:18 <Welkin> I'm looking into using elm right now, and maybe ghcjs/reflex later
16:59:04 <hoppfull> Welkin: Personally, if I wanted a Haskell for clientside I would use PureScript.
16:59:39 <Welkin> there is that too
17:00:00 <hoppfull> Welkin: Though I get the impression that with Elm, you can learn some interesting architecture skills that you can bring over to other languages.
17:00:12 <Welkin> that is one thing I like about it
17:00:19 <Welkin> it provides the structure for you
17:00:23 <hoppfull> yeah
17:00:53 <Welkin> it is what redux is based on
17:01:05 <Welkin> and now everyone seems to be going crazy for react + redux
17:01:53 <hoppfull> I heard about that. I was looking into it because I wanted to learn FRP but as I understand it, react isn't particularly reactive.
17:02:08 <Welkin> lol
17:02:16 <Welkin> if you want frp, reflex is what you want
17:02:19 <Welkin> it's real frp
17:02:26 <Welkin> react is not frp
17:02:44 <Welkin> elm used to be frp-like, but now it moved away from that entirely
17:02:58 <hoppfull> I had that impression for a long time. I hope it's because I overheard someone say it and not because of its name.
17:05:11 <Wizek> Is there a way to pattern match saying we don't care which constructor was used as long as the kinds match up? e.g. `case Left 1 of (_ a) -> a+1`
17:05:20 <hoppfull> I think Elm brings with it an entire runtime written in JavaScript while PureScript is a lot like TypeScript and transpiles to pure javascript.
17:05:50 <athan> Purescript is a tad slower though iirc
17:06:12 <athan> while elm sacrifices a lot of semantics, like higher-kinded types and codensity tomfoolery :|
17:09:02 <hoppfull> athan: I haven't done any performance tests. All I know is that Elm compiles into a huge project that can be one or two Mb while PureScript compiles to fairly readable and minimal JavaScript. Don't quote me on that last bit though. It was a while ago.
17:17:31 <Cale> hoppfull: Oh, I work with Haskell
17:17:53 * hackagebot writer-cps-monads-tf 0.1.0.0 - MonadWriter orphan instances for writer-cps-transformers  https://hackage.haskell.org/package/writer-cps-monads-tf-0.1.0.0 (minad)
17:18:24 <Cale> hoppfull: The company I work for, Obsidian Systems, builds web applications for various other companies, entirely in Haskell (both the backends, compiled with GHC, and the frontends compiled with GHCJS)
17:18:29 <hoppfull> Cale: You do? Cool. What kind of problems are you using haskell to solve?
17:18:30 <Cale> We use reflex-dom
17:19:28 <hoppfull> Cale: Interesting. What advice do you have for someone coming out of school looking to start their career with FP?
17:20:26 <Cale> Well, my own method for getting a job was giving free help to people on #haskell for years until some of them started companies and wanted to hire me, haha
17:20:36 <Cale> I'm not sure I'm the best person to ask for career advice
17:20:43 <hoppfull> Cale: haha cool
17:20:59 <glguy> can confirm that works
17:21:33 <hoppfull> Cale: This channel might not be the best place to ask for career advice. ; ) But I thought since people here are so nice *flirt flirt* that maybe they'd let one pass!
17:21:58 <Welkin> hoppfull: don't look for a job based on the language they use
17:22:04 <Welkin> they could be assholes all the same
17:22:32 <hoppfull> Welkin: You're right. I'm actually looking for people of similair sensibilities. What I hear is called "culture fit"
17:22:37 <Welkin> lol
17:22:40 <Welkin> startup jargon
17:22:55 <hoppfull> haha really?
17:23:00 <athan> Yeah I'm a homeless guy, looking for other homeless people to start a tech firm
17:23:07 <hoppfull> haha It's corrupting me!
17:23:51 <Cale> athan: Damn startup founders and their fancy garages
17:24:23 <athan> We're designing a smoke-signal compatible ABI
17:24:28 <hoppfull> Anyway, the responses so far has been helpful. It's given me some ideas.
17:24:46 <Welkin> hoppfull: you can build your own products using whatever you want, which is great
17:25:59 <rector> @cale what are your thoughts re: GHCJS in production? it was fooling around with it a couple of weeks ago and it doesn't seem like it's quite prod-ready. it is really impressive though
17:25:59 <lambdabot> Sorry, look up one word at a time please.
17:26:13 <rector> *i was fooling around with it
17:26:14 <Welkin> rector: without the @
17:26:26 <Cale> rector: We've used it in production on a number of projects now, it's pretty good!
17:27:05 <Welkin> that depends on what you mean by "producton ready"
17:27:20 <Welkin> everything was made by a person, so it will have problems, no matter how well built it is
17:27:28 <Cale> rector: Of course, it could always be better -- we have Luite looking into improving the code size as it is.
17:27:30 <hoppfull> Welkin: I don't doubt I could build my own products but I know nothing of marketing and what would provide value to others.
17:27:31 <Welkin> it's always a work in progress
17:27:43 <hoppfull> Welkin: I will keep it in mind though.
17:28:07 <Cale> It would also be nice if the compile times (especially if you're using Template Haskell) were a bit faster
17:28:28 <Welkin> hoppfull: anyone can learn marketing and sales easily, which is 95% of it. Building the product is maybe 5% of it, but if you can build the product already, you are ahead of people who can't
17:29:20 <hoppfull> Welkin: marketing always seemed like magic to me. Is it like programming where I just pick up a book and start reading, google a little, experiment a little?
17:29:22 <lambdafan> hoppfull: What libraries or applications have you released in Haskell. If the answer is "None", then you need to fix that prior to looking for a Haskell job.
17:30:09 <Welkin> hoppfull: it's really just a little copywriting, some social skills, and being able to look up information about people/demographics, and asking them questions
17:30:32 <rector> Cale yeah i guess my impression that it wasn't "prod-ready" stems a bit from the lack of documentation...but that doesn't really speak much to the thing itself though, more the ecosystem i suppose
17:31:17 <Cale> rector: Yeah, the documentation is definitely not where we'd like it to be
17:31:22 <Welkin> lack of docs/tutorials is a huge barrier to entry, which is unfortunate, because there are many good projects/libraries with this problem
17:31:36 <Welkin> so you have to struggle a lot more than otherwise (and read a lot of source code to figure it out)
17:32:22 <Welkin> that seems to be problem #1 for all proamming languages though
17:32:26 <Cale> But *using* reflex-dom is really great, and once you have some basics under your belt, you can get a lot done in a hurry.
17:32:46 <Welkin> so... just get used to reading source code
17:32:47 <Cale> I really need to find time to write some tutorials
17:34:04 <Welkin> Cale: I'd love to see that
17:34:36 <Welkin> a tutorial for building a non-trivial application with all the basics covered
17:34:53 <Welkin> not just todo list
17:34:56 <Cale> I also really wish that we had a better and more releasable story for the backend.
17:36:04 <rector> what do you all use at obsidian?
17:36:20 <Cale> Like, I can summarize what we're doing on the backend vaguely by saying that we use snap and groundhog (as well as postgresql-simple)
17:36:45 <Cale> We're typically serving a single page, and then communicating with the application via websockets
17:36:55 <Cale> occasionally XHR
17:37:21 <Welkin> Cale: not servant?
17:37:25 <Cale> nope
17:37:41 <Welkin> any reason?
17:38:24 <Gurkenglas> lambdafan, I have https://hackage.haskell.org/package/pointedalternative , what's the next step? x)
17:38:32 <Cale> I'm not really sure there's a specific reason.
17:39:21 <Cale> Personally, I'm not totally enamoured with its type hackery, but I didn't make the decision to go with snap originally.
17:39:43 <Cale> Welkin: Note that we need *no* complex routing of any kind
17:40:44 <Cale> All the complexity comes from the fact that our applications like to dynamically request various fragments of the database, and we need to serve up live changes
17:42:09 <Cale> So there's some data structure coming to us from the frontend describing basically what things the user is looking at, and we're 1) observing changes in that structure and serving patches to a view on the required data, and 2) notifying about changes to the database which affect those things
17:42:31 <Cale> (and pushing more patches)
17:43:02 <Cale> If we were using FRP to handle that backend stuff, it would be a whole lot nicer, but we haven't yet done that part.
17:43:26 <Cale> When we do, I'm hoping we can eventually release something.
17:44:41 <benzrf> anybody know of any interesting approaches/abstractions for game networking, or more broadly highly stateful over-the-net interactions?
17:45:22 <MarLinn> the obsidian page just crashed my browser and it didn't do anything before I activated js. ouch.
17:47:19 <sm> benzrf: gafferongames.com seems knowledgeable
17:47:44 <hoppfull> benzrf: Are you working with games with haskell?
17:47:55 <benzrf> uh, not really much
17:48:25 <benzrf> im considering trying some toy stuff, but i dont have any real plans where being a game is the goal rather than playing with haskell is the goal
17:49:35 <hoppfull> benzrf: I'm actually doing something similair. But I'm creating a rendering engine with Vulkan to display a small scene. I've done stuff with OpenGL in other languages before but I thought it'd be interesting to see what I can do with Haskell.
17:49:54 * sm thinks making games is a good way to learn some haskell
17:56:58 <Cale> MarLinn: which browser?
17:57:38 <Cale> and yes, it won't do anything at present if you don't have JS, because it's a Haskell program, compiled to JS
17:58:19 <MarLinn> Cale: Firefox on Debian. It seems reproducible. Once I activate js I just have to wait a few seconds and goodbye
17:58:31 <Cale> (we do have some serverside rendering stuff, but I don't think it's being used for our own site yet -- we're too busy working on other companies' sites :)
17:59:24 <Cale> Hm, I'm using Firefox 48 on Linux Mint, and it seems okay here.
17:59:35 <Cale> MarLinn: Is there anything in your JS console?
18:00:03 <MarLinn> I tried looking but I didn't see anything before the crash
18:01:02 <MarLinn> But then I don't really know what to look for... haven't done a whole lot of js myself...
18:01:31 <Cale> Well, if the whole browser is crashing, that's pretty crazy :)
18:01:53 <Cale> Perhaps we're triggering some Firefox bug
18:05:40 <MarLinn> Yup... or my system might be broken or just too weak. I have gotten ff crashes from twitter videos in the past on this system. But then it has been my most stable setup yet, all things considered
18:06:38 <MarLinn> The only warning I managed to catch just yet was "mutating the [[Prototype]] of an object will cause your code to run very slowly..."
18:07:44 <Gurkenglas> What reasons are there not to define WriterT and ReaderT as newtype'd StateT?
18:10:29 <rector> well writer requires its state to be a monoid, right
18:10:46 <rector> and reader isn't quite "read only state"
18:12:32 <pikajude> is there a hackage package that's like node's replay package?
18:14:08 <Axman6> what does node's replay package do?
18:14:30 <pikajude> records HTTP responses
18:14:33 <pikajude> then fakes them on subsequent runs
18:14:55 <pikajude> I know it's not possible to stub out functionality of the HTTP library, but I was hoping for something that could at least save requests/responses to a file and generate a fake response based on a file
18:14:58 <Axman6> not that I know of
18:14:58 <pikajude> but I may have to write it myself
18:15:59 <Axman6> see http://www.parsonsmatt.org/2016/06/24/take_over_an_api_with_servant.html
18:16:55 <Axman6> it's trivial to put a haskell service in front of another one and incrementally replace endpoints - I believe there might also be a way to run tests against two apis to see how they differ... one sec
18:17:54 * hackagebot reflex-dom-colonnade 0.4.2 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.4.2 (andrewthad)
18:17:56 * hackagebot reflex-dom-colonnade 0.4.3 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.4.3 (andrewthad)
18:20:57 <nshepperd> strict WriterT only really makes any sense as a newtyped StateT, iirc
18:21:46 <nshepperd> but doing ReaderT as a newtyped StateT would be pretty wasteful, I think
18:21:53 <glguy> Gurkenglas: those alternate forms of writer or reader would have the wrong behavior
18:22:08 <Axman6> how so?
18:22:19 <glguy> wrong laziness
18:22:49 <glguy> reader writer and state are primitive constructs, the problem is using the wrong ones
18:23:10 <glguy> they aren't intended to be suited for any particular purpose
18:24:54 <glguy> If you can get the desired behavior in terms of StateT, then you should simply be using StateT
18:25:23 <glguy> WriterT isn't intended for or useful for , for example, logging on top of a strict monad
18:25:37 <glguy> but that doesn't mean it needs to be changed, just that you shouldn't use it for that
18:27:39 <athan> Anyone here mess with accelerate much?
18:33:41 <Axman6> athan: I'd like to but haven't had a good usecase for it. if you join the DataHaskell slack team you can chat with Trevor who's responsible for much of the development
18:35:26 <athan> Axman6: Thank you! Yeah this latest build of accelerate-examples is throwing a lot of unknown errors for me
18:38:35 <athan> Axman6: Do you happen to have a link? Or is it invite only?
18:40:00 <athan> wait I just found it! Sorry :x
19:17:55 * hackagebot colonnade 0.4.4 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/colonnade-0.4.4 (andrewthad)
19:17:57 * hackagebot reflex-dom-colonnade 0.4.4 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.4.4 (andrewthad)
19:17:59 * hackagebot casr-logbook-types 0.0.2 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-types-0.0.2 (TonyMorris)
19:29:29 <marcelocamargo> Morning!
19:32:49 <marcelocamargo> Do I need to have a phd in order to talk here? :D
19:33:08 <benzrf> is there a way to sequenceA a list of Maps if im fairly sure that all of them will have all of the same keys
19:33:24 <benzrf> marcelocamargo: no :P
19:33:37 <marcelocamargo> \o/
19:34:37 <benzrf> but it helps!
19:34:40 <benzrf> ;)
19:34:46 <marcelocamargo> I've joined because it is hard to find a place where people want to talk about type theory, haha
19:36:39 <marcelocamargo> I'm currently designing a language that targets (don't shame on me, PHP & JS), and I thought this would be a good place to talk and get ~ideas for that, haha
19:36:43 <benzrf> have you tried ##typetheory?
19:36:48 <benzrf> oh
19:37:01 <benzrf> ok yeah ##typetheory is mostly foundations-of-math style type theory, i think
19:37:15 <marcelocamargo> Well, it'd be a good try also
19:38:32 <marcelocamargo> I'm currently working on contravariance and covariance in the type system. I believe it is more a design aspect rather than a foundation one :D
19:38:42 <marcelocamargo> Until the moment, everything is completely invariant
19:39:24 <benzrf> does anyone know, though - 22:33 <benzrf> is there a way to sequenceA a list of Maps if im fairly sure that all of them will have all of the same keys
19:44:32 <ashishnegi> hi i am making a simple game server .. i want to allow websockets (for browser) and tcp connections (for terminal) players.. does wai/warp support tcp connection ? i see that i can add Network.Wai.Application with Wai-Websockets.. do i have to put tcp conn on other port ?
20:08:58 <wedify> i can't get haskell-snippets to work. would having tab set to indent interfere?
20:09:00 <lingxiao> hey all
20:09:06 <lingxiao> i have a problem with infinite recursion
20:09:11 <lingxiao> code here:
20:10:38 <lingxiao> http://lpaste.net/186343
20:10:59 <lingxiao> in `catOr` I'd like to call `token`, but that leads to obvious infinte loop
20:11:43 <athan> lingxiao: How is it infinite?
20:11:54 <lingxiao> so if we have this:
20:11:59 <athan> Are you expecting the string to be infinite?
20:12:08 <lingxiao> catOr t = foldr (\x ts -> token x `Or` ts) t
20:12:31 <athan> oh shoot
20:12:36 <lingxiao> and now in `token` we have:   y:ys -> token y `catOr` ys
20:12:54 <lingxiao> yeah ... right now I'm avoiding the problem by call Word x instead of token x
20:13:08 <athan> I don't want to be that guy, but have you considered using a parser combinator library instead?
20:13:15 <benzrf> heh
20:13:52 <EvanR> dont look now, but youre that guy
20:14:10 <athan> in `token`, it's somewhat strange for me to realize too - you're matching on finite lists first - are you expecting to call `token` on a split string too?
20:14:22 <athan> EvanR: [tm]
20:15:07 <lingxiao> athan yeah I'm compiling these things to some attoparsec paresr
20:15:23 <lingxiao>  you're matching on finite lists first - are you expecting to call `token` on a split string too?
20:15:31 <lingxiao> sorry i dont understand the wording here? ---^
20:16:29 <lingxiao> so basically given list of tokens [t1..tn] im going to convert that to a parser,  p1 <+> ... <+> pn
20:16:42 <lingxiao> where <+> is parser combination
20:17:56 * hackagebot digestive-functors-lucid 0.0.0.4 - Lucid frontend for the digestive-functors library  https://hackage.haskell.org/package/digestive-functors-lucid-0.0.0.4 (athanclark)
20:20:17 <athan> I'm not sure lingxiao sorry
20:20:28 <lingxiao> all good thanks!
20:20:56 <anohigisavay> hi
20:22:24 <anohigisavay> so i added a git repo to my stack project
20:22:46 <anohigisavay> to the `packages` list in stack.yaml
20:24:02 <anohigisavay> i specified `commit: master` and it checked out my current master commit but it then never updates
20:24:27 <anohigisavay> i have to remove .stack-work and `stack build` to update
20:24:48 <anohigisavay> is it possible to have stack always track my latest commit?
20:25:22 <wedify> oh i had to enable yas-global-mode
20:26:35 <benzrf> lingxiao: do you mean sequence_
20:26:42 <lingxiao> sorry?
20:26:55 <benzrf> well, hold on - what does (<+>) do exactly?
20:26:57 <benzrf> what kind of combination
20:28:17 <Reshi> lingxiao: Can you give a sample input to tokenize?
20:28:20 <lingxiao> oh it just takes two parsers and run one, then run the other.. p <+> q is basically  p <*> q
20:28:29 <lingxiao> * (,) but not *
20:28:34 <lingxiao> not * (,) just *
20:28:56 <lingxiao> so the first one should be [Star, OptComma, Word "but", word "not", Star]
20:29:02 <benzrf> yeah, so - do you mean sequence_?
20:29:07 <benzrf> or are your parsers not applicatives
20:29:21 <lingxiao> http://lpaste.net/186353
20:29:31 <lingxiao> :t sequence_
20:29:33 <lambdabot> (Foldable t, Monad m) => t (m a) -> m ()
20:29:44 <benzrf> oh
20:29:51 <benzrf> then how about just
20:29:56 <benzrf> foldr (<+>)
20:29:57 <lingxiao> benzrf sorry im still not following haha :(
20:30:12 <lingxiao> like on the string it self? after I split by space?
20:30:25 <benzrf> ok sorry i just kinda jumped in without knowing what your problem actually is
20:30:28 <benzrf> i need to stop doing that
20:30:30 <benzrf> :|
20:30:53 <lingxiao> hahah no it's ok fresh eye balls are good!
20:31:02 <lingxiao> so I need a function mapping strings to parsers .. for example:
20:31:40 <lingxiao> match "(,)" = (comma <|> spaces1) where comma = word ","
20:31:58 <lingxiao> word = spaces *> string (pack w) <* eow
20:32:22 <lingxiao> benzrf I think you're saying I dont need this intermediate Token datatype
20:32:27 <lingxiao> I should map from string to parser
20:33:13 <allbery_b> for most purpoises, splitting tokenization from parsing was about saving memory on PDP11s with 64k address spaces
20:33:49 <allbery_b> usually it's a waste to do so otherwise
20:34:21 <c_wraith> eh.  tokenizing before parsing makes parsing *way* easier.
20:34:35 <c_wraith> You get to ignore all of the things like "there could be some whitespace here"
20:34:52 <c_wraith> and just parse the token stream, regardless of semantically unimportant lexical details
20:34:54 <allbery_b> by pushing that worry into the tokenizer
20:35:04 <lingxiao> c_wraith basically yeah
20:35:13 <lingxiao> like that logic has to be there somewhere ..
20:35:14 <c_wraith> Yes, but it doesn't have to worry about parsing.  It just handles lexical details.
20:35:15 <ReinH> trifecta and parsers is set up to tokenize as it parses
20:35:17 <ReinH> it works pretty well
20:35:19 <lingxiao> it's almost more for code redability 
20:35:27 <allbery_b> where it can be just as annoying, and even more so if it has semantic content (like in, oh, Haskell...)
20:35:37 <lingxiao> harhar
20:35:46 <lingxiao> and i mean it's kind of fn
20:35:48 <lingxiao> fun*
20:35:50 <lingxiao> even though it's late
20:36:03 <c_wraith> Haskell is defined in terms of rules for translating whitespace to explicit {;}
20:36:07 <c_wraith> That's not really an issue.
20:36:22 <c_wraith> user-definable operator precedence is a *much* bigger issue when parsing haskell
20:36:39 <allbery_b> (uh. this is geekosaur; "my" linode's being upgraded)
20:36:55 <lingxiao> what's the name of foldr (++) []
20:36:59 <c_wraith> concat
20:37:01 <lingxiao> ah
20:37:10 <c_wraith> you can also use join
20:37:51 <geekosaur> looks like it's been down long enough I'm not colliding
20:38:33 <lingxiao> oh right join because monad
20:38:41 <c_wraith> yep
20:38:44 <lingxiao> although it's not in the standard lib
20:38:58 <c_wraith> It's not in Prelude, but it's certainly in base
20:39:38 <lingxiao> sorry what's base?
20:39:44 <c_wraith> join
20:39:56 <geekosaur> Prelude is an odd assemblage of useful stuff and historical accidents; it should not be considered a "standard library"
20:39:57 <lingxiao> so Prelude is automatically imported right? that's why return and (>>=) are here
20:40:07 <lingxiao> oh ... wasnt aware of tat
20:40:13 <lingxiao> so what's base ... a standard lib?
20:40:23 <c_wraith> base is the minimal standard lib
20:40:40 <geekosaur> base is the standard library. https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/index.html
20:41:06 <geekosaur> but yes, also minimal becuase anything in base can only be upgraded by upgrading the compiler
20:41:09 <lingxiao> ahh nice
20:41:19 <geekosaur> so you kinda want as little as possible to end up "stuck" that way
20:41:38 <EvanR> Prelude is automatically imported, unless you use NoImplicitPrelude which is handy for using alternatives
20:43:32 <lingxiao> sweet
20:43:38 <lingxiao> didnt know about that pragma
20:45:37 <anohigisavay> or `import Prelude ()` xD
20:46:44 <c_wraith> that has a different result on desugaring of things like do blocks than NoImplicitPrelude does
20:47:14 <c_wraith> If you import Prelude (), do blocks still desugar to the standard monad class's (>>=) and (>>)
20:47:31 <c_wraith> NoImplicitPrelude makes them desugar to whatever is in scope with those names
20:48:17 <anohigisavay> c_wraith: woa thanks. never knew that
20:50:39 <lingxiao> alright thanks guys im off! 
20:55:46 <ReinH> it also imports typeclasses and instances
20:58:51 <lingxiao> hey in attosparsec
20:59:00 <lingxiao> is there an identtiy parser that alwasys succeds and dont output anything
20:59:02 <Axman6> no where's in #haskell
20:59:03 <Axman6> :P
20:59:08 <lingxiao> or consume anything
20:59:13 <Axman6> we're* how on earth did I write that?
20:59:23 <glguy> lingxiao: Yeah, return ()
20:59:24 <Axman6> lingxiao: pure ()?
21:00:28 <lingxiao> ok that works thanks
21:00:30 <ackpacket> I have to touch a small haskell codebase from time to time.  My workflow is very slow because I need to make my changes and try to compile the module I just changed, see what errors there are, and iterate.  I'm sure this will go down as I get to know the language, but in the meantime is there any way to improve this cycle?  Everytime I :l my module to see if it's correct, it has to operate on 700 other modules that haven't changed.
21:00:41 <ackpacket> Can I load a module and just "vouch" for the other modules being fine?
21:01:23 <EvanR> :r the module
21:01:35 <EvanR> it shouldnt recompile all the others
21:01:53 <Axman6> yeah just run :reload (:r)
21:02:25 <ackpacket> Ah.  And that'll expose anything dumb I'm trying to do like pass the wrong type into a function?
21:02:46 <c_wraith> yep
21:02:54 <ackpacket> ffs that changes the game.
21:03:09 <ackpacket> I wonder if long term I can get vim to check as I go.
21:03:33 <EvanR> also possible
21:04:10 <EvanR> dependently typed languages seem to take that to an extreme and you need help from the editor for almost any word you write
21:08:03 <ackpacket> Alright.  Thanks, this saves me a ton of time.
21:08:06 <ackpacket> Any vim recommendations?
21:08:14 <ackpacket> *plugin
21:08:23 <glguy> I like vim-lion
21:10:19 <Axman6> ackpacket: pretty much all editors can do typechecking live
21:11:02 <ackpacket> Axman6, Sure, I'm set on Vim, it's convenient and on the dev servers, but I suppose I was wondering if I could take the normal error checking I would get after editing a file and bring it into the buffer more easily.  E.g. highlighting the line containing an error, etc.
21:11:08 <joe9> any gloss users here? Is it fast as using opengl directly?
21:12:21 <EvanR> it uses opengl directly so yes
21:12:37 <glguy> No, it's not as fast as using it directly
21:12:55 <glguy> The selling point is that it's easy
21:13:10 <EvanR> some of the stuff that you can manage to do with gloss will have a faster way directly
21:13:28 <benzrf> get vim-hdevtools, ackpacket
21:14:18 <ackpacket> benzrf, thanks, I'll look into that.
21:14:34 <ackpacket> We have a modified ghc though so I'll have to see what it'll take to get all this wired up...
21:14:40 <benzrf> modified ghc D:
21:14:41 <benzrf> eek
21:14:58 <EvanR> o_O
21:15:13 <ackpacket> I *could* be misunderstanding what they've done to add to the language.
21:15:26 <ackpacket> I am after all still new to it.
21:15:47 <ackpacket> But basically, when I run the terminal for it, I get a bunch of functions built in for free, without importing anything.
21:16:51 <EvanR> Prelude?
21:17:28 <ackpacket> As I understand it, the terminal I use is "a version of GHCI preloaded with a bunch of stuff"
21:17:39 <benzrf> that doesnt necessarily mean that ghc has more things added
21:17:42 <benzrf> you could just have an rcfile
21:17:48 <ackpacket> also uses a different prelude
21:17:57 * hackagebot persistent-parser 0.1.0.0 - Parse persistent model files  https://hackage.haskell.org/package/persistent-parser-0.1.0.0 (mchaver)
21:18:50 <c_wraith> wow, ghcjs takes forever to boot.  I can see why, it's compiling its entire standard library.
21:19:42 <benzrf> use nix :>
21:19:53 <Cale> c_wraith: Yeah, if you're not working on it, you definitely don't want to be compiling it yourself
21:21:49 <Cale> My recommendation would be to get reflex-platform, which contains a script called try-reflex, which will download everything you need and put you in a nix environment that has ghcjs.
21:22:14 <Cale> (and known-to-be-working versions of everything needed to build reflex-dom stuff)
21:22:46 <ackpacket> Here's a question about :r.  In order to use it for error checking, do I have to first have successfully brought the module in with :l?
21:23:24 <Cale> It should attempt to load whatever you last loaded
21:23:54 <ackpacket> So, if the module already has errors and :l is unsuccessful, after attempting to fix them dos that mean I have to use :l again?
21:24:01 <ackpacket> *does
21:24:02 <Cale> You should be able to :r
21:24:30 <csraghunandan> Hello. My first post in Haskell IRC :) 
21:24:32 <Cale> I just tried it and it worked
21:24:46 <Cale> csraghunandan: Welcome! Let us know if you have any questions :)
21:24:50 <csraghunandan> this is the first time i'm using IRC 
21:25:17 <ackpacket> Then what's the difference between :l/:r, and import?
21:25:54 <hiptobecubic_> csraghunandan, welcome :)
21:26:25 <geekosaur> :l/:r load a source file, import adds a module to ghci's current set of imports
21:26:26 <EvanR> and +module!
21:26:29 <csraghunandan> I didn't know IRC was so easy to setup in emacs. 
21:26:42 <csraghunandan> just curious, how many of you guys are using emacs here ? 
21:26:49 <geekosaur> it's the difference between the import lines at the top of your source file, and the lines after them
21:26:57 * geekosaur raises hand
21:27:12 <amalloy> not for irc
21:27:13 <c_wraith> csraghunandan: probably should ask for a show of hands from a channel that usually runs around 1600 people. :)
21:27:18 <c_wraith> *shouldn't
21:28:03 <csraghunandan> haha. Yeah, I just started learning haskell a few days ago and I love it.
21:28:39 <c_wraith> csraghunandan: of course, that does mean...  If you want most people in the channel to automatedly spam you, you can probably do something like "/ctcp #haskell VERSION", though I'm not sure if that works on freenode
21:28:50 <EvanR> noooo
21:29:05 * EvanR waits for the end
21:29:17 <c_wraith> EvanR: did you run that?
21:29:18 <geekosaur> well. I didn't say I was using emacs for irc
21:29:21 <EvanR> no
21:29:28 <EvanR> but someone is probably about to
21:29:53 <c_wraith> I wouldn't be surprised if freenode disabled broadcast ctcp
21:29:54 <geekosaur> won't end the channel, might end the sender's connection quickly
21:30:01 <geekosaur> if not disabled
21:30:03 <EvanR> it used to work
21:30:18 <EvanR> and pissed pretty much everyone in the channel off
21:30:32 <EvanR> as well as flooded the recieved
21:30:37 <EvanR> reciever
21:31:14 <c_wraith> It does still work.  (I tested on a much smaller channel)
21:32:10 <ackpacket> I remember those days
21:32:11 <csraghunandan> c_wraith: what does "/ctcp #haskell VERSION" mean ? I just booted up IRC for the first time and I've no idea what that means
21:32:15 <ackpacket> You could ping an entire channel
21:32:47 <c_wraith> csraghunandan: It sends a ctcp (client-to-client-protocol) message to everyone in the #haskell channel requesting an automated VERSION response
21:33:07 <c_wraith> csraghunandan: most clients honor those requests, and immediatlely reply with what irc client they are using
21:33:34 <geekosaur> and in a channel with 1415 users, you promptly get hammered flat with responses
21:33:51 <csraghunandan> that would probably be a bad idea. 
21:34:10 <TommyC> Try #ubuntu instead! :D
21:34:23 <geekosaur> (you'll probably annoy a significant subset of them, most of whom don't know what ctcp is and think you're trying to hack them)
21:34:39 <zomg> iirc +C prevents channel-wide CTCPs, and it's enabled by default :P
21:34:47 <zomg> (or maybe that was colors)
21:34:56 <geekosaur> that's colors
21:35:17 <zomg> I guess +c was that then
21:37:15 <csraghunandan> just wondering, I'm very new to haskell and haskell-stack installed ghci 7.10.3
21:37:33 <geekosaur> 8.0.1 is still a bit experimental
21:37:42 <csraghunandan> ahh I see
21:37:43 <geekosaur> (and has some bugs, they're working on 8.0.2 now)
21:37:52 <geekosaur> and not everything has been updated to work with it yet
21:38:00 <csraghunandan> I guess i'll wait for ghci 8.0.x to become more stable then ?
21:38:04 <geekosaur> ghc moves kinda fast
21:38:17 <csraghunandan> would a beginner miss out on anything if i use 7.10.3 ?
21:38:23 <geekosaur> nope
21:38:25 <c_wraith> No, you'll be fine
21:38:39 <geekosaur> thing is, ghc is trying to be both a production ready Haskell compiler and a playground for the type theory wonks
21:38:39 <jle`> you might miss the redundant typeclass constraints warning feature
21:38:57 <jle`> sometimes you might accidentally put too many constraints on a function, and ghc 8 comes with a checker to warn you when you do
21:39:17 <jle`> but that's not quite a language feature
21:39:42 <csraghunandan> that's interesting. And, any idea when stack will start supporting ghci 8.0.x ?
21:39:45 <EvanR> really... isnt redundant constraints sometimes a documentation aid
21:39:56 <jle`> stack already supports ghc 8, actually
21:40:09 <c_wraith> It will probably default to 8 when 8.0.2 is released.
21:40:09 <MarcelineVQ> the nightly resolvers are ghc8
21:40:10 <jle`> you just need to change the resolver to any of the recent nightlies
21:40:14 <geekosaur> stack itself already does. the LTS resolvers are still 7.10.3 because some packages in it aren't ghc8 compatible yet
21:40:15 <jle`> instead of lts
21:40:26 <geekosaur> stackage nighty resolvers support ghc8 but are a work in progress
21:40:37 <jle`> i've been using ghc 8 for the past few months without any major hitches, though :)  but yeah, it doesn't make much of a difference
21:40:38 <c_wraith> Since 8.0.1 does have a couple bugs that are painful if you run into them
21:40:46 <csraghunandan> I wouldn't want to use nightlies for now 
21:40:49 <EvanR> i wonder if idris builds with ghc 8 yet
21:40:58 <jle`> using 7.10 when people are trying to get used to 8.0 is a lot less big of a deal than using 7.8 when people were getting used to 7.10
21:41:36 <jle`> 7.10 came with pretty significant changes to the base library api
21:41:54 <jle`> compared to 7.10 from 7.8, 8.0 from 7.10 is nothing :)   (w.r.t. things beginners would see)
21:42:18 <Cale> csraghunandan: 8.0.1 has been good enough for production for us, but as a beginner, most of the differences won't matter much to you. There are some improvements to error messages which might be nice.
21:42:18 <csraghunandan> I see. Thanks for clearing things up
21:42:40 <Cale> But other than that, the language improvements are relatively obscure things from a beginner standpoint :)
21:43:08 <jle`> yeah, most 8.0 features are things for advanced users ... whereas 7.10 changes that would impact beginners strongly
21:43:15 <jle`> so i guess you're lucky you came now haha
21:43:37 <EvanR> :t fold
21:43:39 <lambdabot> (Monoid m, Foldable t) => t m -> m
21:43:42 <EvanR> :t map
21:43:43 <lambdabot> (a -> b) -> [a] -> [b]
21:43:53 <csraghunandan> that's interesting, I did not know there was such a huge leap from 7.8 to 7.10 
21:44:07 <c_wraith> Yeah, it was large, and some people were really upset by it.
21:44:15 <EvanR> the abstraction difference here is funny, i found it hard to justify on the basis of "its for beginners" to a beginner
21:44:24 <buttons840> why do servant handlers involve Nat?
21:44:36 <csraghunandan> c_wraith: why were people upset with update to 7.10 ?
21:44:59 <EvanR> bridges be burnin
21:45:11 <EvanR> theyre gone now
21:45:26 <jle`> to be reductive, major changes always come with debate.  that's healthy.
21:45:30 <c_wraith> csraghunandan: it changed a bunch of core functions to more general types.  Some people liked the less general types more because they provided more rigid controls.
21:45:55 <buttons840> EvanR: what is an example of a bridge that burned?
21:46:05 <c_wraith> :t foldr -- buttons840 
21:46:07 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:46:33 <c_wraith> buttons840: that's one of the burned bridges.  It's not specialized to lists anymore.
21:46:41 <jle`> buttons840: might have been a play on words about the fact that one of the big changes was called the "burning bridges proposal"
21:46:54 <buttons840> c_wraith: it's more general now, right? why is that a burned bridge?
21:47:31 <c_wraith> buttons840: It's a breaking change to go back.  Have to go forward.  Just like burning bridges behind you.
21:48:37 <buttons840> hmm
21:48:57 <buttons840> c_wraith: so it wasn't a breaking change to go forward, but it will be a breaking change if we ever try to go back?
21:49:04 <c_wraith> exactly
21:49:18 <jle`> the point of burning bridges is to burn them behind you, haha
21:49:25 <jle`> burning bridges in front of you might be counter-productive
21:49:52 <MarcelineVQ> depends whos on the other side
21:50:20 <EvanR> connotation is the cross first
21:50:23 <EvanR> is to cross first
21:50:44 <EvanR> but in alternate reality, it could be about burning a bridge, then attempt to cross and falling into a river
21:51:00 <buttons840> i was thinking "burning bridges" meant something like, there were 3 choices, and committing to 1 destroyed the other 2
21:51:35 <c_wraith> It is a multi-purpose metaphore.
21:51:48 <EvanR> "dont burn bridges behind you"
21:52:09 <c_wraith> ... metaphor.  Why am I spelling so poorly tonight?
21:52:16 <ReinH> like semaphore?
21:52:20 <c_wraith> exactly
21:52:32 <c_wraith> You use the metaphore to signal semaphore discussions.
21:52:33 <buttons840> yeah, now i see it's not a controversial claim at all, we did cross the bridge and can't easily go back -- we can all agree the bridge is burned, but i guess some disagree that we should have crossed it
21:52:46 <c_wraith> buttons840: exactly
21:52:47 <ReinH> The bridge has been carefully dismantled.
21:52:52 <ReinH> And then those pieces have been burned.
21:53:00 <buttons840> i was picturing that only some thought it was "burning a bridge", but i guess that wasn't the debate
21:53:04 <buttons840> it was should we cross at all
21:55:37 <c_wraith> Well..  Changing the functions in Prelude was burning the bridges.  No way back after that.  leaving them in Data.Foldable and Data.Traversable was crossing without burning.
21:57:04 <buttons840> i remember that community poll, but i didn't understand the tradeoffs very well, i don't think i gave an opinion
21:58:12 <jle`> overall apart from some isolated incidents, the debate was mostly civil and constructive
21:58:19 <buttons840> https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#natural-transformations   i'm trying to understand this section of the servant docs; is Nat somehow tied to Handler, or is it just part of the example?
21:59:32 <buttons840> yeah, i'm really tempted to start debating the proposal right now, but i guess it can't do much good now
21:59:45 <dmj`> buttons840: Nat is what allows your handlers to be other monads, not just ExceptT ServantErr IO
22:00:10 <buttons840> dmj`: Nat is natural numbers?
22:00:18 <buttons840> dmj`: what does that have to do with Monads?
22:00:20 <MarcelineVQ> Natural transformation
22:00:22 <dmj`> buttons840: Nat is for natural transformation
22:00:26 <buttons840> ah :)
22:00:44 <c_wraith> woo.  I built ghcjs.  Now, uh...  I need to figure out how to make it do anything useful.  I guess step one is probably ghcjs-dom.
22:00:58 <parsnip> natural transformations are apparently the original motivation for category theory
22:01:00 <c_wraith> I'll work my way up to more powerful libraries later.
22:01:24 <dmj`> buttons840: practically, if you'd want to use something like a ReaderT, you'd need to use the Nat
22:01:51 <dmj`> to get back to EitherT
22:02:17 <buttons840> dmj`: I'm using a CRand for crypto random numbers -- got the types worked out except for that little helper function described in that secion of the docs
22:02:42 <buttons840> I think I just need a short runCRand function, just like in the example
22:03:28 <buttons840> again, my main confusion was wondering "what do _Nat_ural numbers have to do with monads and HTTP apis"
22:04:14 <dmj`> buttons840: servant uses type level natural numbers for http status codes
22:04:27 <buttons840> dmj`: yeah, that would make sense
22:04:48 <EvanR> it doesnt make too much sense to me... theoretically
22:05:02 <EvanR> status codes are strings of three digits
22:05:23 <EvanR> the first digit means something, the meaning of the others depend on the first
22:06:16 <EvanR> you dont do arithmetic with them
22:06:22 <buttons840> yep
22:07:18 <EvanR> Nats are in the base 1
22:07:34 <EvanR> free based
22:07:42 <EvanR> i mean base free
22:08:56 <dmj`> EvanR: unsure, but wai's Status type expects an Int, Status (natVal (Proxy :: Proxy (200 :: Nat))) "ok"  would make it easier
22:09:37 <EvanR> yes
22:10:19 <EvanR> but were in the matrix, we want to talk like four-oh-four, five-hundred instead of blond brunette
22:17:58 * hackagebot hspec-golden-aeson 0.2.0.3 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.2.0.3 (mchaver)
22:18:00 * hackagebot persistent-parser 0.1.0.1 - Parse persistent model files  https://hackage.haskell.org/package/persistent-parser-0.1.0.1 (mchaver)
22:18:02 * hackagebot persistent-audit 0.2.0.0 - Parses a Persist Model file and produces Audit Models  https://hackage.haskell.org/package/persistent-audit-0.2.0.0 (mchaver)
22:18:04 * hackagebot conduit-combinators 1.0.6 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.6 (MichaelSnoyman)
22:31:48 <HanlonsRazor> This is probably a stupid question, but are there some monitors that are better for programmers? Just like there are gaming monitors.
22:32:25 <dmj`> HanlonsRazor: there is a channel called #haskell-offtopic
22:32:37 <TommyC> "programming monitors" They also cost extra for no benefit.
22:32:55 <HanlonsRazor> dmj`, sry, thanks, joined
22:52:00 <cocreature> NickHu: why don’t you just watch it on skillsmatter?
22:54:44 <cocreature> oh I missed that they asked this question 9 hours ago
22:55:48 <johnw> it's paywalled there now
22:56:04 <johnw> i think?
22:56:54 <cocreature> doesn’t look like it. you need to log in but it’s free
22:57:11 <johnw> ok
23:18:00 * hackagebot papa-prelude-semigroupoids 0.0.2 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-semigroupoids-0.0.2 (TonyMorris)
23:18:02 * hackagebot papa-prelude-semigroups 0.0.2 - Prelude with only useful functions  https://hackage.haskell.org/package/papa-prelude-semigroups-0.0.2 (TonyMorris)
23:18:04 * hackagebot do-list 0.9.0 - List construction with do notation  https://hackage.haskell.org/package/do-list-0.9.0 (TarasSerduke)
23:25:01 <wedify> i'm trying to compile cv, a binding to opencv that uses c2hs
23:25:18 <wedify> it fails because the header files include c++ header files
23:25:46 <wedify> so how do i call g++ instead of gcc? how does this interact with c2hs files?
23:32:07 <pavonia> wedify: If it uses GHC to compile the .c file, you could try adding the GHC options to select another compiler
23:50:01 <parsnip> can i factor out the g in `f <$> (g . h) <*> (g . k)` ? 
23:50:26 <parsnip> oh, probly (f . g) or something
23:50:30 <parsnip> no
23:52:21 <Axman6> (f `on` g) I think
23:52:36 <Axman6> :t \f g -> f `on` g
23:52:37 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
23:53:34 <amalloy> using (on) gets you close to f $ (g . h) (g . k), but i'm not sure how you adjust that to fit inside the applicative
23:54:16 <Axman6> (f `on` g) <$> h <*> k
23:54:39 <amalloy> ah, that looks right
23:57:45 <csraghunandan> guys, a quick question. How can i remove a package installed using stack?
23:57:50 <amalloy> does it maybe need to be (f `on` (g .))? it seems like your suggestion is closer to f (g h) (g k)
23:58:28 <Axman6> oh right, hmm, g is a -> f b, not a -> b
