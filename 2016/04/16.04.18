00:02:00 * hackagebot xml-conduit 1.3.4.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.3.4.2 (MichaelSnoyman)
00:04:45 <lyxia> tippenein: what's the type of lorsContent
00:05:47 <lyxia> tippenein: view lorsContents <$> (send $ ...) ?
00:06:10 <lyxia> view lorsContents <$> send (...) looks better
00:06:35 <lyxia> but your current code associates as (view lorsContents <$> send) (...)
00:07:49 <lyxia> so <$> here is function composition (.), whereas you might be looking for the fmap of 'm' in the type of send.
00:26:10 <ntnt> anyone recommend a good book on *implementing* *persistent* (i.e. all old copies stored) relational DBs? I'm trying to write a relatinoal store in Haskell (and it's persistent in that past is stored) -- but I'm stuck on how to design the indices, and need a resource to help me with that
00:34:19 <logcat> ntnt: I can't recommend any good book, but can give you google suggestion for "relational database cs", you will find tons of courses on databases theory and take a look at recommended readings, some of them must be good
00:34:47 <ntnt> logcat: most of them seem to be at the level of: here's is relational stuff, here is normalization
00:34:58 <ntnt> but I'm really into *implementation* rather than "how to use" or "how to design tables"
00:35:16 <ntnt> (same problem with books on amazon)
00:38:39 <logcat> ntnt: by that query I found http://web.stanford.edu/class/cs245/bib.htm, and there is http://www.amazon.com/Database-Systems-Complete-Book-Edition/dp/0131873253 and comments on that book suggest http://www.amazon.com/Theory-Relational-Databases-David-Maier/dp/0914894420 
00:39:37 <int-index> I'm using HPC to report test coverage of my lib. It uses `Proxy` heavily, and since proxies are not used at runtime, HPC mistakenly reports half my library as not covered
00:39:42 <int-index> any workarounds?
00:46:21 <Cale> int-index: https://wiki.haskell.org/Haskell_program_coverage#Example
00:49:04 <Heather> can someone help with optparse-applicative
00:49:10 <int-index> Cale, thanks! Now I have to figure how to use this with https://github.com/rubik/stack-hpc-coveralls
00:49:37 <Cale> Heather: I've used it a bit before
00:50:08 <Heather> Cale I've got this let parser = Args <$> commonOpts <*> (hsubparser (command "bar" (info (pure Bar)  (progDesc "..."))) <|> pure Baz) ... and I can't understand how can I add back --help and --version there
00:50:36 <Heather> Cale alike in this example https://github.com/pcapriotti/optparse-applicative/blob/master/tests/Examples/Cabal.hs#L62
00:50:58 <Heather> Cale or how to add default command in example variant (e.g. pure Bar)
00:54:13 <Cale> Heather: I think if you have a parser which parses --help and --version as you'd like, you can <|> it with the overall parser...
00:55:09 <Heather> Cale <|> will work as Command and AFAIU --help and --version will not work as there... but not sure
00:55:41 <Heather> Cale honestly I'm more interested how to handle argumentless situation in Cabal example (link I've shared)
00:56:00 <Heather> Cale there is A _version ⋙ A helper ⤙ Args opts cmds
00:56:30 <Heather> and it's Parser (a → a)
01:03:02 <Cale> Heather: Right... so infoOption constructs a parser which always fails and produces a message, and helper is another which is always going to fail -- I'm trying to remember how these things get combined
01:03:57 <Heather> asA a -< () - this syntax is used for Parser Args
01:04:02 <Heather> And I need Parser Command which will just run default command if there are no args...
01:04:27 <Heather> Cale but logically should be in cmds ← (asA . hsubparser) block
01:04:46 <Heather> what will be <|> x variant in arrow syntax?
01:06:18 <Cale> You might be able to get an instance of ArrowPlus or ArrowChoice or something, but I think they haven't implemented it.
01:06:37 <Cale> You can still use <|> on the resulting Parsers...
01:08:09 <Heather> Cale inside main = execParser opts ≫= run ?
01:08:25 <Heather> Cale e.g. with info parser ?
01:09:26 <Cale> Or outside the runA at least?
01:09:31 <Heather> Cale it's complicated.... there it's different
01:11:42 <Heather> Cale if I will handle it anywhere outside command parsing block I will get Command not found error
01:12:01 <Heather> damn... args parsing is that complex!
01:12:23 <Cale> That's interesting... I'd expect <|> to try the second parser if the first one would have failed
01:13:12 <Heather> Cale but how to make it with that hsubparser ?
01:13:38 <Heather> Cale e.g. there https://github.com/pcapriotti/optparse-applicative/blob/master/tests/Examples/Cabal.hs#L49
01:14:01 <Cale> Well, what's the goal? Adding help to the subcommands?
01:14:23 <Heather> Cale default action when no arguments are passed
01:14:40 <Heather> Cale current default action is error about missing COMMAND
01:16:40 <Heather> Cale maybe I should add ) ⋙ x -< () to this block
01:16:48 <Cale> Heather: Oh... try using customExecParser and passing in a ParserPrefs which has prefShowHelpOnError = True
01:16:49 <Heather> then x is A Parser Command Command
01:17:00 <Heather> which is kinda strange
01:17:21 <Cale> parserPrefs = ParserPrefs { prefMultiSuffix = "", prefDisambiguate = False, prefShowHelpOnError = True, prefBacktrack = True, prefColumns = 80 }
01:17:54 <Cale> customExecParser parserPrefs whateverParser
01:18:05 <Cale> See if that helps
01:18:20 <Cale> I remember needing to set that option in order to get sensible error messages
01:18:29 <Heather> Cale I don't need to show something on missing arguments, I need to run my custom action there
01:18:37 <Cale> oh, okay
01:19:33 <Cale> Well, you should be able to just <|> the entire parser with (pure Something)
01:20:17 <Cale> ... I think
01:21:33 <Heather> Cale well...
01:21:58 <Cale> If it needs to be the result of the hsubparser...
01:22:14 <Heather> Cale Expected type: A Parser () Command
01:22:17 <Cale> cmds <- (asA . (<|> something) . hsubparser) ...
01:22:26 <Cale> maybe something like that?
01:22:42 <Heather> let me try
01:22:49 <Cale> I'm not sure why this needs arrow notation at all...
01:24:47 <Heather> Cale very strange syntax, doesn't seems like work
01:27:22 <Cale> Or you might pull that whole hsubparser out into its own definition, so you can write something like  cmds <- asA (theSubparser <|> pure NoCommand) -< ()
01:28:46 <Heather> I'm thinking about something alike ) ⋙ (asA x) -< () but still not sure how to make it
01:29:54 <Heather> will it make trick?
01:30:47 <Heather> Cale how to get A Parser () Command into A Parser Command Command ...
01:34:58 <Cale> Heather: compose with  arr (const ())
01:41:31 <Heather> this should be inside hsubparser :S
01:47:03 * hackagebot hindent 4.6.2 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-4.6.2 (ChrisDone)
01:57:03 * hackagebot hindent 4.6.3 - Extensible Haskell pretty printer  https://hackage.haskell.org/package/hindent-4.6.3 (ChrisDone)
02:09:00 <asd_> hi, does cryptonite allow for file encryption ?
02:10:36 <asd_> does anyone have an example of using cryptonite for a file ?
02:11:02 <bblfish> where is Monad defined in the libraries?
02:11:13 <bblfish> can't find "class Monad"
02:11:20 <Ferdirand> Control.Monad ?
02:11:40 <Ferdirand> ah no GHC.Base
02:11:42 <asd_> it is in library base
02:11:55 <liste> https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#Monad
02:12:55 <liste> re-exported in Control.Monad
02:13:04 <liste> (and Prelude?)
02:13:41 <bblfish> thanks found it
02:14:08 <bblfish> My IntelliJ does not yet allow me to jump to definitions...
02:19:13 <Heather> I feel myself completely hopeless and very stupid, I can't handle arguments parsing, people who are trying to help me are speaking the way I can't understand... I feel like maybe I should not parse arguments for awhile :( or write something simpler
02:20:47 <bblfish> Heather: have you read http://learnyouahaskell.com/ ?
02:20:59 <bblfish> It's really nice. Just going through it.
02:21:52 <bblfish> actually it's nearly required reading it seems to me for people doing scalaz or cats (scala functional programming)
02:21:59 <Heather> bblfish yes I did
02:23:06 <bblfish> Not sure what argument parsing is. you mean command line arguments?
02:24:39 <Heather> bblfish yes
02:25:00 <dysfun> i'm quite fond of CmdArgs. Its just really easy to get going with
02:25:43 <dysfun> works by magic, but makes it very easy to handle the most common argument parsing needs
02:26:12 <Heather> I was using this https://github.com/pcapriotti/optparse-applicative/blob/cc7faf83cac327f7c33bf368ee22cb64a42d44aa/tests/Examples/Cabal.hs#L47 but I still can't manage default action when no command passed or I can manage it but then another problems appears XD
02:28:04 <greg> how do i fix this error in stack : "<command line>: cannot satisfy -package-id base-4.8.2.0-0d6d1084fbc041e1cded9228e80e264d (use -v for more information)"
02:29:03 <dysfun> Heather: i would have thought it was as simple as <> othercase   by the look of it
02:29:03 <statusfailed> Is it possible to trigger a rebuild of docs of hackage? the amazonka package seems to have failed because of an internal server error in hackage: https://hackage.haskell.org/package/amazonka-1.4.0/reports/1
02:56:40 <Heather> dysfun I doubt
03:12:00 <dysfun> i'm afraid i don't have any experience with that particular library
03:12:28 <dysfun> but if i find a library confusing, i tend to need a good reason not to ditch it and use something less academic
04:22:05 <cocreature> heath: what’s the specific problem you are encountering? Using the alternative instance to add a default command seems to work™
04:24:27 <Peaker> A .cabal package that has c-sources should expose these symbols to dependent packages, right? I have A.cabal depending on B.cabal, both have c-sources, and A's c-sources use symbols from B's c-sources
04:37:44 <hvr> Peaker: I actually try to avoid having any predicatble c symbols visible to depenendent packages :)
04:38:07 <hvr> Peaker: unless I *want* them to be visible and thus part of the package's API
04:38:44 <hvr> CapiFFI helps quite a bit here hiding C symbols 
04:39:22 <Peaker> hvr: I want them visible -- but I found my problem, silly error in .cabal that didn't cause a parse error :)
04:41:27 <hvr> :)
04:49:47 <Peaker> (I deleted the "c-sources:" line and it merged the sources into the "cc-flags" section :) )
04:52:35 <jophish> Anyone used opeleye?
04:52:39 <jophish> opaleye*
04:54:16 <bergmark> we use it for most of our DB code
04:54:43 <jophish> bergmark: How have you found it? Is it well written?
04:55:24 <bergmark> it's very flexible and almost always as performant as manually written queries
04:56:38 <bergmark> my colleagues are currently working on replacing our graph database with opaleye+postgres :-)
04:57:20 <jophish> bergmark: that's good to hear, thanks!
05:08:49 <Heather_> cocreature alternative instance?
05:09:28 <cocreature> Heather_: <|> here’s the code I used to make installParser the default http://lpaste.net/160392
05:09:41 <cocreature> I have no idea if that’s the right way to do it but it seems to work :P
05:10:40 <Heather_> cocreature wow, let me try, awesome if that work
05:14:57 <Heather_> cocreature thanks! it works
05:15:06 <cocreature> Heather_: yw :)
05:15:28 <Heather_> cocreature the only thing hsubparser should go first sure :)
05:18:49 <cocreature> Heather_: also if you (like me) are not really familiar with arrow syntax you can write the same using the applicative instance http://lpaste.net/160394
05:20:16 <Heather_> cocreature thanks! now I've managed how to add version *> helper <*> to applicative instance
05:20:41 <cocreature> I never bothered to really understand arrows
05:21:04 <cocreature> and it looks like optparse-applicative mostly “abuses” them because ApplicativeDo is not yet released
05:21:54 <cocreature> which is a neat hack, but still a hack
05:32:36 <ntnt> anyone here have a recommendation for a ssh client for ipad? the main thing I need is to be able to ssh into a server and use vim / commandline / ghci from it
05:34:40 <Akii> I really like prompt https://panic.com/prompt/
05:40:49 <haskell246> d
05:57:26 * hackagebot wai-session-postgresql 0.2.0.5 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.0.5 (hc)
05:59:25 <arahael> ntnt:  the irritation you will have is the ipad keyboard. 
06:00:40 <ertes> cocreature: arrows add side channels to categories:  while in (f . g . h) each component can only communicate with its direct neighbours, arrows allow e.g. f to communicate with h (using a side channel to get around g)
06:01:41 <ertes> that's basically it, and yes, you can do the same with Category + Applicative
06:03:47 <cocreature> ertes: nice explanation, I still haven’t seen a nice usecase apart from some frp libs.
06:04:46 <ertes> cocreature: meta-information is a nice use case, and my favourite mini-example is:  data State s a = State { usesPut :: Bool, runState :: s -> (s, a) }
06:05:26 <ertes> try to make this a monad, such that 'usesPut' is True, if the action uses 'put'
06:09:45 <cocreature> that looks like a nice example, thanks
06:13:36 <Ferdirand> hello #haskell, is there a way to make the ghci prompt work in some other monad than IO ?
06:14:10 <Ferdirand> say i want to have my custom monadic dsl that instances MonadIO
06:14:45 <hackrilege> is this relevant Ferdirand? http://stackoverflow.com/questions/7024248/monads-at-the-prompt
06:15:33 <Ferdirand> the trac ticket in the comment is, i think
06:16:19 <ertes> Ferdirand: you can't have whole interactive "sessions" in other monads, but monad-control allows you to enter and leave MonadBaseControl monads, so you can build actions incrementally
06:17:05 <ertes> related to DSLs: note that most continuation-based monads (notably free monads) aren't instances
06:17:08 <hackrilege> could someone mark my days work?; http://lpaste.net/160396
06:19:35 <Ferdirand> ertes: i don't fully understand what you said
06:19:49 <Ferdirand> looking at the source of monad-control but this is a bit above my level of understanding
06:22:26 * hackagebot machinecell 3.2.0 - Arrow based stream transducers  https://hackage.haskell.org/package/machinecell-3.2.0 (HidenoriAzuma)
06:22:28 * hackagebot strive 2.2.2 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-2.2.2 (fozworth)
06:23:43 <hackrilege> ill go grab some snacks, let me know about any constructive commentary cf http://lpaste.net/160396
06:24:06 <hackrilege> ps dont wory about that mad looking function zmap at the top, it just rewinds the zipper before traversing
06:33:46 <hackrilege> the idea is that a zipper can be made where each element is the zipper pointing to the corresponding element of a supplied zipper
06:34:11 <hackrilege> with the purpose of mapping a function over these zippers
06:34:13 <xa0> christ that was hard to read
06:34:54 <xa0> are you just describing cojoin?
06:35:33 <hackrilege> each element of a supplied zipper can be transformed into a zipper pointing to that element
06:35:53 <hackrilege> i think im describing a cojoin yes, i had the instance here http://lpaste.net/160396
06:35:56 <xa0> okay yes, so cojoin
06:36:46 <hackrilege> so the idea was to test if its any slower to do it like this
06:38:44 <hackrilege> should a zipper be used to perform local traversals, or should copies of the zipper be made? i thought something like, stepig right until you hit the required index doesnt require stepping left at all, a path containing redundant navigation should be avoided, and by getting neighbor information, and then traversing, does the cons list not build up?
06:38:44 <hackrilege> ?
06:40:38 <hackrilege> if that makes sense... i would rather store the correct zipper (the initial zipper modified the fewest number of times to get it into the right place) in all of its states, and then traverse from these to investigate the neighbors..
06:40:59 <hackrilege> but does this have performance increase or is the redundant navigation handled by the compiler?
06:43:30 <hackrilege> Sorry dropped connection
06:48:57 <av_> hi guys, I have a feature suggestion
06:49:22 <av_> when I "tangle" a file (which I use quite a lot), the files gets overridden no matter what
06:50:50 <av_> I suggest that org-mode works out what the contents of that file would be after tangling, then compares that to what's already in the file, and only overwrites the file if the contents differ
06:51:47 <av_> that way, one could do some programming without make or whatever build tool is in use thinking everything has changed (based on time stamps) every time, and therefore rebuilding everything
06:51:54 * av_ hits himself on the head
06:51:59 <ertes> av_: /join #org-mode
06:52:07 * av_ just realized it's the wrong channel
06:52:11 <av_> damn, sorry
06:55:34 * ertes still hasn't seen a use case for zippers that isn't handled better by proper data structures and indices/lenses/paths
06:55:44 <maerwald> how would you guys call a function that does something similar to "head :: [a] -> a", but also fails if the list has more than one element?
06:56:06 <hpc> i would just pattern match
06:56:23 <maerwald> hpc: was that a reply to my question?
06:56:26 <hpc> yes
06:56:33 <maerwald> then I don't see how that is related
06:56:41 <ertes> maerwald: evenMoreUnsafeHead
06:56:46 <hpc> well, you've managed to come up with an even worse head
06:56:54 <adamCS> greg: not sure if anyone answered you.  Was that stack directly or from ghc-mod?  That looks like a thing that happens when ghc-mod is compiled with a different version of ghc than the ghc used to compile the library.  But if stack XXX gives you that, I'm not sure where the mismatch would be.
06:56:54 <maerwald> whatever
06:56:58 <hpc> and the answer to everything involving use of head is to pattern match instead
06:57:01 <bollu> hey everyone
06:57:07 <bollu> I was wondering about the status of haskell-soc
06:57:12 <maerwald> hpc: I was asking about a functio name, not how I implement it
06:57:12 <hpc> you'll give yourself boolean blindness
06:57:22 <bollu> and whether I could bring back my proposal for diagrams
06:57:23 <bollu> :)
06:57:28 <maerwald> and I'm not interested in debating whether it's useful, since you don't know the context
06:59:30 <ertes> maerwald: depending on the context "unique" or something like that
06:59:38 <ertes> interpreting lists as multiple results
06:59:44 <maerwald> I guess I'll name it "headSingletonList"
06:59:45 <maerwald> or so
07:01:42 <ertes> fromSingleton, fromUnique, fromDeterministic, …
07:02:09 <ertes> perhaps: s/from/unsafeFrom/
07:03:09 <maerwald> not sure I'd call everything that can throw exceptions unsafe, since you can just turn any such function into Maybe a ;)
07:03:17 <maerwald> by catching the exception
07:03:34 <hpc> it being a pure exception, it's not quite so easy to catch
07:03:54 <hpc> you have to use strictness to force evaluation to happen while execution is in a suitable handler
07:04:48 <ertes> i'd start with the Maybe variant and use 'maybe (error "BUG in <blah>") id' in appropriate contexts, and then the error can reflect where stuff went to hell, if stuff goes to hell
07:04:48 <hpc> i am also not in favor of everything partial being "unsafe", but perhaps it should be labeled "partialHead" and such
07:05:05 <maerwald> ertes: the program is supposed to crash when that exception happens
07:05:22 <ertes> maerwald: it's going to
07:05:27 <maerwald> yes
07:05:48 <ertes> > maybe (error "BUG: bad stuff happened here") id (foldr (const . Just) Nothing [])
07:05:49 <lambdabot>  *Exception: BUG: bad stuff happened here
07:06:40 <ertes> hpc: i read "unsafe" as "breaks my assumptions", so i think it's fine
07:06:40 * hpc is reminded of how cabal puts fatal errors inline, continues to print stuff out after, then ends with ExitFailure 1
07:06:48 <ertes> i assume functions to be total
07:07:17 <ertes> or, well, at least handling all cases
07:07:23 <hpc> the way i write error messages is imagine if that line is the only output of your program
07:07:32 <hpc> > head [] -- and this is unacceptable
07:07:34 <lambdabot>  *Exception: Prelude.head: empty list
07:08:09 <maerwald> I was really just asking for an appropriate name, none of this is in that form in my program anyway.
07:08:13 <maerwald> Please calm down ;)
07:09:07 <ertes> inspired by fromJust, i'd probably call it unsafeFromSingleton
07:10:01 <hpc> maerwald: one of the standard procedures of helping to solve bad problems in #haskell is to suggest better problems to solve instead
07:10:12 <hpc> playing into the XY problem is more harmful in the long run
07:10:55 <maerwald> hpc: I don't need help solving the underlying problem
07:11:15 <maerwald> and it's not what you think it is
07:11:26 <maerwald> so starting to explain the whole context is a waste of time
07:11:27 <statusfailed> maerwald: getSingleton? toMaybe? 
07:11:45 <statusfailed> toMaybe is ambiguous though I guess
07:11:48 <maerwald> headFromSingleton?
07:11:58 <statusfailed> matchOne ?
07:12:03 <statusfailed> exactlyOne ?
07:12:07 <ertes> you could make the last step just before the list becomes singleton to morph into a different functor
07:12:09 <ertes> like Identity
07:12:29 <statusfailed> ertes: that's true, and you'd implement it with some function, but what would you call that function? :p
07:12:45 <ertes> whatever it's currently named, just with a different type
07:13:15 <statusfailed> oh I didn't even see "unsafeFromSingleton" haha
07:13:17 <statusfailed> I like that
07:27:19 <nek0> Hi. has anyone here have experience with inline-c? My code mysteriously fails to compile with a parse error on the opening parens in the c function call.
07:30:22 <geekosaur> @paste code to pastebin -- nek0
07:30:22 <lambdabot> Haskell pastebin: http://lpaste.net/
07:32:00 <nek0> geekosaur: http://lpaste.net/160401
07:35:55 <Lokathor> That looks normal enough to me
07:35:57 <Cale> nek0: What error do you get? void isn't in scope?
07:36:09 <Cale> $(void * node) looks quite suspicious to me
07:36:34 <Lokathor> node is passed in as part of the functino
07:36:51 <nek0> Cale: parse error on input ‘(’
07:37:30 <Lokathor> on the 9th line?
07:37:50 <Lokathor> hmmmm
07:38:10 <Cale> Oh, I see, inline-c has funny splice syntax
07:38:45 <Lokathor> that all looks about how I've been formatting my own code, https://github.com/Lokathor/hexes/blob/master/src/UI/Hexes/Raw.hs#L262
07:39:00 <nek0> Lokathor: Line 9, exactly.
07:39:35 <nek0> Lokathor: That's roughly where I take my references from.
07:39:54 <Cale> (usually I'd have expected everything inside the $(...) to be Haskell code, but they parse a C type there also)
07:40:28 <Lokathor> from me? :P I'm not that good
07:42:22 <nek0> Lokathor: You were the one who recommended inline-c to me and gave me hexes as reference.
07:45:25 <Lokathor> ah, well, yes, i did that
07:47:25 <haskell601> how can I implement a choice?
07:47:37 <haskell601> if I want to randomly extract an element from a list?
07:50:39 <nek0> haskell601: what do you mean by choice?
07:50:57 <orion_> If you have a function which takes a ByteString and mutates a Foo, is it usually better to have a type signature of: ByteString -> Foo -> (ByteString, Foo), Foo -> ByteString -> (ByteString, Foo), or some other permutation?
07:51:12 <haskell601> extract an element from a list, but randomly
07:51:50 <Lokathor> haskell601, you'll need some sort of RNG I suppose
07:52:00 <Lokathor> which means either State, IO, MonadRandom, etc
07:52:26 <Lokathor> here is just ONE way you might do it, https://github.com/Lokathor/ludolib/blob/master/src/Control/RNG.hs#L81
07:52:29 <Lokathor> but there's lots of ways
07:53:25 <Lokathor> orion_, between Foo or ByteString being the second argument, I'd pick the second argument to be what you might imagine mapping over a list of more often
07:54:07 <Lokathor> so, perhaps you pass in a ByteString once, and then apply that func you just made to a list of Foo values to get a new list of Foos
07:54:16 <haskell601> yea I thought so but can't figure it
07:54:36 <haskell601> I tried to iterate it but I couldn't figure it out
07:55:30 <Lokathor> haskell601, are you familiar with how to use the State type?
07:56:17 <Lokathor> I have to get to work, but perhaps this thing I wrote can help you: https://lokathor.gitbooks.io/haskell-stuff/content/general/state.html
07:57:08 <orion_> Lokathor: Is there a general function in base which will map over [a], but each time it will extract, say the `snd` of the result and use that as the input? The idea is to feed the output Foo back in to the input.
07:57:32 <Lokathor> i'd just use a lambda for that
07:57:53 <Lokathor> > map (\p -> snd p + 5) [(0,0),(1,1)]
07:57:55 <lambdabot>  [5,6]
07:58:09 <orion> Alright, thank you.
07:59:09 <orion> err, well you showed me a [(a, b)] not a [a]
07:59:59 <Lokathor> well
08:00:01 <Lokathor> :t snd
08:00:03 <lambdabot> (a, b) -> b
08:00:13 <Lokathor> snd doesn't make sense if the list doesn't hold 2-tuples
08:00:30 <Lokathor> but whatever function you'd use on each element can be replaced with snd
08:00:55 <orion> I see.
08:00:59 <Lokathor> > map (\s -> head s ++ "cat") ["acxeti","ludis"]
08:01:00 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
08:01:01 <lambdabot>      Expected type: [[Char]]
08:01:01 <lambdabot>        Actual type: [Char]
08:01:17 <Lokathor> hmm
08:01:25 <Lokathor> > map (\s -> head s : "cat") ["acxeti","ludis"]
08:01:26 <lambdabot>  ["acat","lcat"]
08:06:19 <hiptobecubic> orion, it kind of sounds like you're describing a fold and not a map. Can you give an example?
08:07:48 <orion> I want to generalize this pattern: let (x, state') = encryptMsg payload state; let (y, state'') = decryptMsg ciphertext state'
08:07:58 <haskell601> how can I randomly extract an element from a list?
08:08:10 <Clint> randomly
08:08:59 <hiptobecubic> orion, sounds like exactly what the State monad is for. Have you looked at it before?
08:09:12 <orion> Yes.
08:09:13 <hiptobecubic> well "is for" is a bad description. But it's what it does.
08:11:35 <orion> I guess I was looking for a "blow your mind" function rather than a Monad.
08:12:37 <hiptobecubic> @type foldl'
08:12:38 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
08:12:46 <hiptobecubic> Play with that one then
08:12:57 <Boomerang> haskell601: You should at System.Random
08:13:06 <Boomerang> > let select list = do i <- randomRIO (0, length list); return $ list!!i in select [4,3,5,6,7,8]
08:13:08 <lambdabot>  <IO Integer>
08:13:14 <nitrix> orion: This looks like runState.
08:13:23 <hiptobecubic> nitrix, indeed.
08:13:24 <orion> nitrix: Yes, indeed. :(
08:13:34 <hiptobecubic> INDEED!
08:14:24 <Boomerang> small fix it should be "length list - 1" since the randomRIO range seems to be inclusive
08:14:33 <nitrix> orion: Why the frown face? This is quite generalized like you asked.
08:15:54 <orion> nitrix: Because I like unreadable point-free curried functions.
08:19:14 <Boomerang> > let randSelect xs = (xs !!) <$> randomRIO (0, length xs - 1) in randSelect [0..100]
08:19:16 <lambdabot>  <IO Integer>
08:19:55 <nitrix> Boomerang: You can't get sideeffects on lambdabot.
08:20:07 <Boomerang> Yeah fair enough :)
08:20:22 <nitrix> > putStrLn "Boo :("
08:20:24 <lambdabot>  <IO ()>
08:20:30 <orion> Clearly that's a bug.
08:20:40 <nitrix> orion: What is?
08:20:47 <orion> lambdabot not allowing us to use IO
08:20:54 <nitrix> It allows you to use IO.
08:21:05 <Boomerang> No, otherwise you could break lamdabot
08:21:06 <orion> I mean carry out side effects.
08:21:07 <TheMystic> looks like you can use IO all you want -- it just won't evaluate it?
08:21:19 <nitrix> TheMystic: It evaluates, it doesn't execute.
08:21:40 <orion> Boomerang: I was being sarcastic.
08:21:57 <TheMystic> nitrix: I don't understand the distinction in this case
08:21:58 <nitrix> orion: I'd leave sarcasm out of the door in here (:
08:22:10 <Boomerang> :)
08:22:13 <lyxia> > undefined `seq` return () :: IO ()
08:22:14 <lambdabot>  <IO ()>
08:22:34 <nitrix> TheMystic: The code is evaluated to a value of type `IO ()`, yes that IO will never get executed, thus you wont see the side effects.
08:22:57 <nitrix> Even with `seq`, it's just strict evaluation; execution is the issue here.
08:23:06 <TheMystic> oh, okay
08:23:09 <nitrix> s/yes/yet/
08:24:25 <Boomerang> What packages does lambdabot have access to? All of Hackage?
08:24:41 <TheMystic> (still struggling a bit with the boundary between evaluation in IO vs. performing IO actions)
08:24:45 <Boomerang> Surely not, there would be a lot of name clashes
08:25:14 <opqdonut> it's a hand-picked list AFAIK
08:25:42 <nitrix> Boomerang: Hand picked. The ones that are commonly discussed in here and might need to be demonstrated.
08:25:58 <Boomerang> I see :)
08:26:32 <geekosaur> https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/Pristine.hs.default
08:27:22 <Boomerang> Great thanks!
08:30:39 <nitrix> TheMystic: Every haskell program ends up being a single large function, `main` evaluates functions, which calls other functions, and the results gets combined, concatenated, binded, and so on, until you eventually end up with a value of type `IO ()`, that is, the familar type of `main`.
08:31:04 <nitrix> TheMystic: The represents your entire program as per evaluation semantics (which is done lazily).
08:31:34 <nitrix> TheMystic: Then, if you execute `IO ()`, you'll obtain `()`, along with all the side effects involved.
08:31:37 <hpc> a little bit more specifically, executing main leads to evaluating main
08:31:51 <hpc> which is made up of etc etc
08:31:53 <nitrix> Right, I should've done it backwards. hpc is correct.
08:32:06 <hpc> and the execution is done strictly, evaluating lazily as needed
08:32:38 <hpc> nitrix: yeah, just had to get that bit of detail in ;)
08:33:31 <hiptobecubic> Clarify execution vs evaluation?
08:34:19 <hpc> evaluation is the process of going from a thunk to a normal form value
08:34:27 <hpc> essentially going from (3 + 5) to 8
08:34:31 <Boomerang> evaluation: "print 1+1" -> "print 2"
08:34:40 <Boomerang> execution: "print 1+1" -> "2"
08:34:46 <hiptobecubic> oh i see, ok sure
08:34:57 <hpc> hah, that's actually a pretty succinct demonstration
08:35:05 <hpc> ill have to start using that
08:35:16 <Boomerang> maybe with parenthesis :)
08:38:50 <nek0> So I guess nobody has a clue to my problem...
08:39:19 <hpc> i don't see it in scrollback, what was it?
08:44:32 <TheMystic> so if I evaluate, but don't execute, a function that recursively performs IO actions and accumulates their results, I get a normal-form function that would recursively execute those actions?
08:44:47 <TheMystic> just with all the pure-functional code reduced?
08:45:02 <hpc> a function as in something of type (a -> IO b)?
08:45:32 <hpc> the normal form of a function doesn't really do much to its body
08:46:31 <TheMystic> hpc: yes, e.g. I have a function that recursively grabs each next page from a REST API
08:47:35 <TheMystic> and actually only the first call can be evaluated -- further calls params depend on the executed result
08:47:50 <nek0> hpc: I have a problem with inline-c. I get a parse error on '('. It's the first one on line 9 at http://lpaste.net/160401
08:48:15 <hpc> nek0: ah, i don't really know enough to help with that
08:48:16 <TheMystic> hmm, so execution can actually lead to further rounds of evaluation/reduction then?
08:48:22 <hpc> TheMystic: correct
08:48:41 <hpc> TheMystic: normal form on a function is that you know it's a lambda and not undefined
08:49:15 <hpc> (simplified, there's also some funny business with head normal form and weak head normal form that don't really matter for this purpose)
08:49:34 <hpc> so you have a function that produces an IO action
08:49:42 <hpc> you evaluate the function and woohoo, it's a function
08:49:57 <TheMystic> hehe
08:50:02 <hpc> you evaluate (foo whatever) and now you have an action
08:50:03 <Cale> TheMystic: Note that even if a function has type a -> IO b, its evaluation, or the evaluation of its application of type IO b doesn't cause any IO to occur, it just reduces things to some normal form which you can't really observe because IO is an abstract data type.
08:50:04 <TheMystic> "And there was much rejoicing."
08:50:15 <hpc> you execute the action which evaluates a bit further and etc etc
08:50:41 <TheMystic> Cale: and "abstract data type" specifically means it's opaque to Haskell code, yes?
08:50:57 <Cale> yeah, its data constructors are not in scope
08:51:12 <Cale> So you can't pattern match on an IO action to figure out what it is before executing it
08:51:33 <TheMystic> nitrix, hpc, Boomerang, Cale thank you all for the clarification :)
08:52:06 <hpc> TheMystic: a bit of an exercise for you as well, if you want to go a bit further with the mechanics of how far execution will evaluate
08:52:30 <hpc> TheMystic: (print 5 >>= undefined) is going to print 5, then crash
08:53:26 <hpc> you can work out what implications that has and see how they match up to testing in ghci
08:53:41 <hpc> to make sure your understanding lines up
09:01:18 <TheMystic> hpc: I note that (print 5 >> undefined) does the same
09:18:18 <Gurkenglas> (print 5 >> undefined) is (print 5 >>= const undefined), and const undefined is no less defined than undefined, so of course it'd crash no sooner - and it already crashes at the latest possible point
09:32:03 <orion> Does the runtime distribute pure computations across all available cores if you compile with -threaded and use -N?
09:32:19 <johnw> not by default, if that's what you mean
09:32:37 <johnw> you have to explicitly indicate the nature of the parallelism that you want, for example using the Par monad
09:32:50 <johnw> because there is overhead involved in such decisions
09:32:59 <orion> I see.
09:37:44 <johnw> you could call it a "granularity problem": If you are doing 1000 things, it could be much better to do 10 groups of 100 at a time, but much worse to do 100 groups of 10 at a time, and there is really no way to know in every case which is "better".
09:40:11 <orion> That makes sense.
09:45:38 <Gurkenglas> Something that makes "ala Par foldMap" make sense would be nice
09:48:36 <Gurkenglas> Something to apply to "runPar .: foldMap", and a Monoid instance
09:49:11 <Gurkenglas> Or would the unwrapper be more than runPar?
09:58:28 <haskell830> How can I return an int from elemIndex
09:58:36 <haskell830> it returns Maybe Int
09:59:25 <geekosaur> you don't; you pattern match the result and handle the Nothing case vs. the Just case (in which you can pattern match the Int to get access to it)
10:01:04 <bblfish> Chousuke_ ?
10:03:07 <haskell830> how can I get the int from maybe int?
10:03:43 <sm> haskell830: you could use fromMaybe
10:05:03 <hpc> @src maybe
10:05:04 <lambdabot> maybe n _ Nothing  = n
10:05:04 <lambdabot> maybe _ f (Just x) = f x
10:05:14 <hpc> pattern match on it
10:05:54 <raek> haskell830: it depends on what you want to do when there is no Int
10:06:31 <Cale> haskell830: The most basic way is to use a case expression
10:06:44 <Cale> case myMaybeInt of Nothing -> ... ; Just x -> ...
10:06:48 <Cale> x will have type Int there
10:06:53 <haskell830> i have this function
10:07:08 <haskell830> showEstimation e = intercalate " " $ map (\x -> if (elemIndex x `mod` width == 0) then (floatToString x ++ (show '\n')) else (floatToString x)) $ values e 
10:07:13 <Cale> (Note that you can also vertically align the J in Just with the N in Nothing, and skip the semicolon)
10:07:15 <haskell830> how can I use case inside it?
10:07:49 <haskell830> I have never used case before
10:08:16 <Cale> \x -> case elemIndex x of Nothing -> ... ; Just n | n `mod` width == 0 -> ... | otherwise -> ...
10:08:56 <Cale> I suppose if you want the same thing in the otherwise case as in the Nothing case, you can do the first pattern match with the guard and have the fall-through handle it
10:09:08 <Cale> \x -> case elemIndex x of Just n | n `mod` width == 0 -> ... ; _ -> ...
10:09:54 <haskell830> what is after the ...?
10:15:44 <byorgey> haskell830: your code like  (floatToString x ++ (show '\n')) goes in the ...
10:27:35 * hackagebot lmonad-yesod 0.3.0.0 - LMonad for Yesod integrates LMonad's IFC with Yesod web applications.  https://hackage.haskell.org/package/lmonad-yesod-0.3.0.0 (jp_rider)
10:29:32 <orion> Is there a way to write (\x -> f & g .~ x) without using a lambda?
10:30:00 <hiptobecubic> @pl \x -> f & g .~ x
10:30:00 <lambdabot> (line 1, column 14):
10:30:00 <lambdabot> unexpected "~"
10:30:01 <lambdabot> expecting white space
10:30:01 <lambdabot> ambiguous use of a right associative operator
10:30:25 <hiptobecubic> @pl \x -> f & (g .~ x)
10:30:25 <lambdabot> (line 1, column 16):
10:30:25 <lambdabot> unexpected '~'
10:30:25 <lambdabot> expecting simple term
10:30:33 <hiptobecubic> Guess it doesn't like that guy
10:30:57 <hiptobecubic> @pl \x -> f & (g :@@@: x)
10:30:57 <lambdabot> (f &) . (g :@@@:)
10:31:36 <hiptobecubic> But don't use that. Just use the lambda that everyone can read clearly
10:32:57 <bernalex> isn't that just (g .~ x) f?
10:33:10 <bernalex> or is that & something else than x & f = f x
10:33:40 <bernalex> pointfree would then be 'flip (g .~) f' fwiw
10:34:09 <bernalex> either way I would use a lambda.
10:38:38 <orion> pl
10:38:40 <orion> ok*
10:42:26 <akegalj> Can someone help me with lens. I would like to make this work `at 0 . _1 .~ Just "bla" $ [("","")]`. How can I get [("bla","")]
10:43:24 <bernalex> ther's #lens or #haskell-lens (idr which it was) btw. not that lens is in any way off-topic or anything, but just in case you end up not getting help here.
10:43:36 <shachaf> It's a bit tricky. What would it do if you used "at 5"?
10:44:00 <bernalex> there's*
10:44:03 <akegalj> shachaf: nothing, leave it as it is
10:44:10 <akegalj> bernalex: ok, will go there
10:44:24 <shachaf> OK, that's not what "at" does -- it lets you set a value even if none exists.
10:44:34 <shachaf> Try "ix" instead.
10:44:43 <akegalj> shachaf: ok, will try
10:44:46 <shachaf> > set (ix 0 . _1) "bla" [("","")]
10:44:48 <lambdabot>  [("bla","")]
10:45:31 <meditans> hi, I'm searching advice on a data structure: let's say I have a `Map String [String]`, but I want to enforce the fact that in each list I can only refer to strings which are already present in the map. How would I do that in an idiomatic way?
10:45:37 <akegalj> shachaf: thank you
10:48:33 <meditans> I know I could do that with smart constructors, I'm searching for alternatives
10:50:47 <meditans> it would be useful to make sure that the structure remains coherent (eg, when I delete a String -> [String]), the names which are no longer meaningful go away, or when I change a String in the Map, it gets changed everywhere)
11:00:46 <lyxia> that sounds extremely tricky to do in Haskell
11:01:44 <lyxia> beyond hiding it in an abstract type and making sure the API preserves your invariant
11:05:10 <meditans> lyxia: yeah, that was the fallback option, but I wondered if there was some clever way of doing things I was not aware of
11:06:57 <cocreature> making it fast is also tricky
11:07:50 * hackagebot sdl2-compositor 1.2.0.5 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.2.0.5 (seppeljordan)
11:08:34 <meditans> cocreature: ok, for the first version, I'm more interested in a proof of concept than in speed, but of course, that would be extra difficult
11:16:58 <EvanR> meditans: i had the same problem a few times using IntMap or Map Int and the code necessarily not being total (according to the compiler)
11:17:22 <meditans> EvanR: did you manually encode the constraints, in the end?
11:17:47 <EvanR> it seems like this is a very difficult problem to solve in general, because your code can do anything it wants to the Map
11:18:09 <EvanR> it might be possible if you restrict the kind of ordering of things you will do
11:18:28 <EvanR> records for example is one way that that restriction manifests
11:18:42 <EvanR> (not ever removing fields)
11:20:31 <EvanR> meditans: what do you mean
11:21:05 <adamvh> question about reading Core: if I see something of the form "case b_ij_z of _ { D# x3_axJa ->"
11:21:19 <adamvh> does that mean that the value b_ij_z is boxed?
11:21:27 <adamvh> and GHC is unboxing it in this line of Core?
11:21:36 <dolio> Yes.
11:21:37 <nitrix> adamvh: I'd send you to #ghc.
11:23:38 <shachaf> #ghc isn't really the right channel for that sort question.
11:23:40 <shachaf> sort of
11:25:20 <adamvh> i think i have a bunch of functions that operate on (Double, Double, Double)
11:25:47 <adamvh> and that GHC is boxing values it retrieves from a Vector
11:26:00 <adamvh> so that my functions can operate on them
11:26:12 <adamvh> and then unboxing them again to write them to the vector
11:31:45 <cocreature> adamvh: if you compile with optimizations unboxing and reboxing gets often eliminated afaik
11:32:17 <nitrix> Only when compiling with optimizations?
11:32:42 <adamvh> i'm currently compiling with -Odph
11:32:55 * hackagebot xlsx 0.2.1.2 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.1.2 (KirillZaborsky)
11:33:12 <adamvh> looking at Core that came from Repa
11:33:46 <cocreature> I didn’t even know -Odph was a thing
11:33:47 <dolio> The big problem would be if you have functions that return multiple Doubles.
11:33:55 <dolio> And they aren't inlined or something.
11:34:32 <adamvh> dolio: i think i am doing something like that
11:34:34 <dolio> I'm not sure GHC will be smart enough to generate versions of the function that don't box the doubles.
11:34:51 <adamvh> in a where block i have something like this
11:35:00 <adamvh> (!b_ij_x, !b_ij_y, !b_ij_z) = b_n `unsafeLinearIndex` lIndex
11:35:32 <adamvh> where these pattern-matched values go into a tuple
11:37:20 <dolio> Right.
11:37:28 <dolio> I don't know much about repa.
11:37:43 <dolio> Or writing stuff with it.
11:38:02 <adamvh> you've been very helpful :)
11:38:33 <adamvh> at least i am now pretty sure that boxing / unboxing is happening
11:38:36 <dolio> Although I would think there'd be a way to solve this, since it'd be a huge issue.
11:38:46 <dolio> Maybe putting it in the where is the problem.
11:38:55 <dolio> Like, are all your branches strict in the values?
11:39:32 <dolio> I think the ! may be deceiving you.
11:39:57 <dolio> For instance, what if you do: !(...
11:40:10 <adamvh> oooooh
11:40:12 <dolio> Because otherwise the pattern as a whole is irrefutable.
11:40:26 <dolio> Even though you have parts that are more refutable.
11:40:28 <adamvh> as in both the tuple and its fields need to be strict?
11:40:47 <dolio> Right, because patterns in a where are irrefutable.
11:40:58 <dolio> And ~(!x, !y, !z) is irrefutable.
11:41:20 <dolio> so it's not correct to evaluate x, y and z up front, necessarily.
11:42:43 <dolio> > case (undefined, undefined) of ~(!x, !y) -> if True then 2 else x
11:42:45 <lambdabot>  2
11:43:38 <Denommus> > case (undefined, undefined) of !(!x, !y) -> if True then 2 else x
11:43:39 <lambdabot>  *Exception: Prelude.undefined
11:43:45 <Denommus> hm, interesting
11:43:55 <Denommus> > case (undefined, undefined) of !(x, y) -> if True then 2 else x
11:43:57 <lambdabot>  2
11:44:31 <adamvh> strictness of container vs. elements has been tripping me up all week
11:44:45 <dolio> > case (2, undefined) of ~(!x, !y) -> x -- here's the odd case
11:44:47 <lambdabot>  *Exception: Prelude.undefined
11:44:53 <nitrix> It seems to me both are lazy.
11:45:23 <adamvh> is that because they have different types?
11:45:39 <adamvh> oh no, that's not true
11:46:01 <nitrix> I do not thin the types play a role in this; at least, not in the examples given.
11:46:49 <adamvh> oh sick
11:47:02 <adamvh> at least one unbox / rebox has been eliminated
11:47:12 <Cale> dolio: Bang patterns should have just kept their simple translation which they had the short while after they were first introduced.
11:47:34 <dolio> What do you mean?
11:48:10 <Cale> Oh, I suppose that's actually not relevant here -- this still would have happened
11:48:16 <adamvh> (D# a, D# b, D# (+## x y)) still represents a boxed tuple, though, yeah?
11:48:29 <dolio> Boxed tuple and boxed doubles.
11:49:13 <adamvh> yeah now the core is reading a bunch of unboxed doubles from the vector
11:49:23 <adamvh> which it had previously been boxing
11:49:32 <adamvh> and then unboxing to do arithmetic on them
11:49:38 <adamvh> so this is progress!
11:49:49 <adamvh> my function is still boxing its result
11:50:07 <adamvh> which repa probably needs to unbox somewhere in its innards to write to the vector
11:50:17 <dolio> Make sure you're looking at the right spot, too. There might be both versions of functions you wrote.
11:51:09 <adamvh> oh, right
11:51:34 <adamvh> so it's possible that my function compiled to box its result
11:51:45 <adamvh> but it was also inlined into the driver code in repa
11:52:00 <adamvh> and at the inlining site the box / unbox is eliminated
11:52:06 <dolio> Possibly.
11:52:07 <adamvh> that's actually probably likely
11:52:17 <adamvh> or at least, the part where it was inlined
11:52:28 <adamvh> maybe not the box / unbox elimination :p
11:52:37 <adamvh> this code has inline pragmas out the wazoo
11:52:39 <dolio> I mean, it wouldn't be inlined into repa, but repa and your thing would be inlined into some other code you wrote, or something.
11:53:00 <nitrix> It saddens me seeing haskellers talking about GHC-specific implementation details; chasing small bits of performance.
11:53:20 <adamvh> nitrix: i'm a scientific programmer who usually writes c++
11:53:28 <dolio> Small bits?
11:53:43 <adamvh> it's like a factor of 50 tho i think
11:53:47 <nitrix> I assumed that'd be the job of ppl working on GHC. Am I going to need to learn these things to have decent performances?
11:53:54 <geekosaur> he who dies with the most toys^WMIPS wins!
11:54:22 <dolio> It depends what you're writing.
11:54:24 <kadoban> nitrix: Decent performance? No. Absolute best tuned performance? Yes.
11:54:24 <adamvh> my advisor always claims that you can solve finite difference em fields at 10-12 nanosec / cell / timestep
11:54:49 <adamvh> and my figure for my attempts at doing it in haskell is 1 microsec / cell / timestep
11:55:26 <adamvh> however i think that "crunching arrays of doubles as fast as possible" is a particularly difficult thing to do well for haskell
11:55:55 <dolio> Yes. Even if you get it all as optimized as possible, it probably won't match C++.
11:56:07 <adamvh> just based on a week or so of chasing box / unbox and things
11:56:10 <dolio> Whether that matters, though....
11:56:12 <apriori> adamvh, maybe look into something like accelerate-llvm, if your algorithm is sufficiently local
11:57:16 <adamvh> i also think a lot of this would go much better if i could get llvm to work with ghc on my computer
11:57:31 <apriori> adamvh what is the issue?
11:57:35 <dolio> Yeah, if you can run it on a GPU, you might beat other languages using a CPU.
11:57:52 <adamvh> at the moment there is a version mismatch between mac os x's llvm and what the haskell platform's ghc wants
11:58:02 <apriori> dolio, there is also accelerate-llvm-native, that was, what I actually was wanting to refer to 
11:58:14 <dolio> Oh.
11:58:45 <apriori> and since gpgpu languages still utterly suck, yes, your other claim holds some truth
11:58:52 <apriori> (meaning opencl/cuda)
11:59:27 <dolio> Right, it might be a 'fair' comparison, because writing it to use a GPU in Haskell might be comparable in easiness to writing it to use a CPU in other languages. (Although I wouldn't know.)
12:00:01 <apriori> well, I'd say a lot of stuff is fairly easy in accelerate. 
12:00:58 <apriori> the only thing kind of coming close is maybe thrust/viennacl. although those two are essentially gpgpu-stl, with all its design flaws (horrible API, absolutely zero composability)
12:00:59 <adamvh> in 2010, writing cuda absolutely sucked
12:01:31 <adamvh> i imagine it was not quite as bad if you weren't trying to do it on a laptop
12:01:40 <apriori> adamvh, it sure got a lot better. still, idk, those "lets reinvent C for the 100th-time"-guys lack any damn sense for composability.
12:02:02 <adamvh> but i recall many times power-cycling my laptop
12:02:06 <apriori> try a really simple foo . bar in thrust - its mind boggling.
12:02:19 <adamvh> because i had sent my gpu into an infinite loop
12:02:35 <apriori> oh yeah.
12:02:52 <adamvh> and the screen doesn't do anything if your gpu is an infinite loop :(
12:03:11 <apriori> nvidia drivers gave me the exact same error code for 4 totally different user errors - that was some fun to find out.
12:03:17 <EvanR> maybe key combo to issue a driver command to reboot the gpu
12:03:19 <apriori> yup ^^
12:04:03 <adamvh> i imagine working on a cluster with a tesla or something is much more pleasant
12:04:18 <adamvh> or whatever they call teslas now
12:04:19 <apriori> I used to work on smaller gpgpu servers
12:04:45 <apriori> having older tesla cards. but yeah, it is better not to be able to crash your local pc ^^
12:31:33 <jeffrin> hello all
12:33:41 <jeffrin> hello all
12:34:08 <jeffrin> iam interested in learning haskell
12:35:01 <dmj> jeffrin: yes, good choice
12:35:15 <EvanR> agreed
12:35:47 <hpc> learning haskell is almost as good as getting better at haskell
12:37:21 <jeffrin> any books ?
12:37:42 <prohobo> learning haskell is like finding out how to use haskell
12:37:53 <Boomerang> jeffrin: http://learnyouahaskell.com/chapters
12:38:07 <monochrom> someone is competing with me on tautologies!
12:38:13 <apriori> btw, guys, are there more up-to-date bindings to libclang around?
12:38:31 <apriori> I can only find LibClang, version 3.4.0 (quite ancient llvm/clang)
12:39:35 <apriori> jeffrin, depending on your general programming knowledge, I'd highly recommend starting to work on a "practical" problem (for you), after you're done with your baby steps following e.g. "learn you a haskell"
12:40:02 <apriori> then you run into a shit ton of issues, a stack you can work through and see way more than the usual toy examples
12:40:19 <dmj`> jeffrin: http://www.seas.upenn.edu/~cis194/lectures.html
12:46:21 <jeffrin> dmj` : thanks 
12:48:28 <jeffrin> apriori : anyway thanks
12:48:56 <jeffrin> Boomerang : anyway thanks
12:49:11 <Boomerang> You're welcome :)
12:49:11 <dmj`> jeffrin: for something slightly more comprehensive, https://github.com/bitemyapp/learnhaskell
12:49:25 <jeffrin> anyway thanks
12:49:36 <dmj`> jeffrin: bitemyapp also has a book, haskellbook.com
12:51:51 <Welkin> [Dwtf are you jeffrin?
12:51:56 <Welkin> a robot?
12:52:59 * hackagebot blaze-builder 0.4.0.2 - Efficient buffered output.  https://hackage.haskell.org/package/blaze-builder-0.4.0.2 (LeonSmith)
12:56:40 <cocreature> apriori: there is https://github.com/google/clang-lens which seems to support clang 3.5 (obviously still quite ancient)
12:57:18 <apriori> interesting
12:57:26 <apriori> cocreature, thank you
12:57:54 <cocreature> np
12:58:15 <cocreature> not sure how much effort it is to update it to the newer apis
12:58:26 <cocreature> the llvm api is horribly unstable, but maybe clang is better
12:58:54 <apriori> I just need a working (and I mean really working) c++ parser
12:58:57 <ertesx> is LYAH considered a good resource?  i'm sceptical, because it has a certain 'project-euler feel' to it
12:59:12 <apriori> want to do some automatic c++ managed extensions -> c++/CLI -> C# transformations
12:59:25 <baweaver> bitemyapp wrote a Haskell book recently that's pretty good
12:59:28 <apriori> ertesx, for a start its good. 
12:59:36 <baweaver> Dubbed The Haskell Book iirc
13:00:56 <monochrom> LYAH is not a good resource. it was good when there were nothing good.
13:01:38 <monochrom> it's problem is that its detailness is of a whirlwind tour, but its length is of a book.
13:01:59 * dmj` wonders if the LYAH is still around...
13:02:00 <monochrom> I call it "a 2-hour trailer"
13:02:06 <dmj`> LYAH author*
13:02:09 <ertesx> i see
13:02:12 <ertesx> hehe
13:02:38 <TheMystic> I felt like LYAH was a good introduction to the Functor / Applicative / Monad typeclass hierarchy
13:03:00 <TheMystic> not sure how much I learned from it apart from that
13:03:17 <Akii> well it was fun, you gotta admit that
13:03:18 <apriori> I kind of liked what school of haskell was
13:03:25 <Welkin> LYAH was my gateway into haskell
13:03:36 <apriori> like, having the option to jump right into executable code etc.
13:03:40 <Welkin> it made it easy to get started, because otherwise it seemed quite complex
13:03:50 <ertesx> i never read it, but from my superficial experience it felt like it would make you great at solving toy problems, but wouldn't teach you anything about actual software engineering in haskell
13:03:52 <Welkin> I enjoyed the jokes
13:04:02 <TheMystic> in theory, Real World Haskell covers more of what I wanted to know to jump in at the beginning... it's rather chewy though
13:04:17 <Welkin> LYAH serves a very important purpose: getting people over their fear of learning haskell
13:04:29 <TheMystic> Welkin: yeah, it did help me with that too
13:04:33 <Welkin> RWH was boring as fuck and I did not learn much from it, honestly
13:04:40 <TheMystic> (I speak as a fairly new haskeller)
13:04:41 <ertesx> like: "wow, that problem is elegant to solve!  but i have this here problem…  how do i solve it?"
13:04:48 <akegalj> I know there is #haskell-lens, but maybe someone here will be quicker. How can I get `Just 2` out of this `runState (use $ at 1 . _1) $ M.fromList [(1, (2,2) )]` ?
13:04:55 <Welkin> I went straight from LYAH to the Upenn course and learning from users in this channel
13:05:06 <akegalj> I guess function composition is not the right operator here
13:05:24 <TheMystic> I should've just taken better advantage of being in the same room as bos when I had the chance ;)
13:05:43 <akegalj> got the answer at #haskell-lens
13:05:47 <akegalj> thans tho
13:06:08 <Akii> what would I give for a week worth of a person sitting next to me teaching me haskell :D
13:06:30 <Akii> currently only running against walls for simple problems
13:06:46 <TheMystic> Akii: I've only just managed to start breaking thru those walls
13:06:55 <Gurkenglas_> Is there a right inverse of "elemIndices x"?
13:07:01 <Welkin> Akii: you can get that here already--- for free
13:07:10 <Akii> as in free monad? ^^
13:07:31 <TheMystic> it was about two weeks ago that I actually first managed to stare at the types of a monadic expression long enough to figure out where I was going wrong :)
13:07:33 <Welkin> I'm grateful too all of the generous people here who helped me get started
13:08:20 <Gurkenglas_> I guess you need another element to pad with - let's say a right inverse of "elemIndices True"
13:13:59 <apriori> is there a proper way to declare generated "data-files" in a .cabal file. so stack isn't so stupid to assume they exist prior to even running cabal configure?
13:14:34 <ertesx> Welkin: i'm highly suspicious of that…  as a newbie haskeller LYAH taught you how to solve toy problems, but then you come up with a problem of your own, and suddenly none of that seems to help, because you never learned software engineering in haskell…  either your fear comes back ("after so much time and effort, i still don't get it!"), or you start to think that haskell is just a toy
13:15:22 <Akii> ertesx: story of my experience so far
13:15:34 <Akii> but I do think that FP works, just can't apply it yet
13:15:54 <scshunt> it's like any other programming language
13:15:54 <Akii> same goes for FPiS
13:15:59 <apriori> Akii, yup, that steps takes longer
13:16:09 <scshunt> the only way to really learn it is to start with a toy program, then a slightly bigger one, then a slightly bigger one
13:16:19 <Akii> so it's like "sure I can build a parser now, great.. "
13:16:19 <Gurkenglas_> > (zipWith (-) =<< tail) . (0:) -- Aw man I was just about to think this has now replaced the terrible Show error thing
13:16:21 <lambdabot>  <[Integer] -> [Integer]>
13:16:29 <ertesx> Akii: i always recommend learning in the context of an actual problem
13:16:35 <apriori> I'm not even really experienced. but I start seeing those "FP patterns" everywhere now. and cringe at having to write for loops. 
13:16:50 <apriori> so yeah, careful, haskell can make you become frustrated with "established" stuff
13:16:50 <scshunt> apriori: heh
13:16:51 <Welkin> ertesx: that's when you move on the the next resource
13:17:00 <Welkin> either a book, course, or this channel
13:17:02 <ertesx> Akii: one that your learning resource doesn't cover
13:17:08 <Welkin> that's exactly what I did
13:21:54 <ertesx> oh yeah, and i always thought that parsers are a terrible porn genre
13:23:58 <dxtr> Is Haskells built-in prng any good?
13:25:10 <ertesx> dxtr: the "built-in" one is the one from the 'random' library…  it's okay for generating random numbers for small command line games, but not so useful otherwise
13:25:20 <bblfish> very nice article https://en.wikibooks.org/wiki/Haskell/Category_theory
13:25:45 <ertesx> dxtr: it's both slow and not secure for crypto, but it does have a very small memory footprint
13:25:52 <Welkin> dxtr: dexter's a cookie! Dexter's secret!
13:26:40 <dxtr> ertesx: Know of any good alternatives for generating uniform random numbers?
13:26:48 <dxtr> pseudo-random numbers
13:26:56 <ertesx> dxtr: speed or crypto-security?
13:27:17 <EvanR> dxtr: theres random-fu and mwc-random
13:27:36 <EvanR> built-in-ness doesn't really mean too much in haskell
13:28:16 <dxtr> EvanR: I was actually looking at random-fu but I wanted to see if I was making a bad choice :)
13:28:35 <EvanR> i dont think either are suitable for crypto, but also its interesting thats immediately a possible requirement ;)
13:28:58 <EvanR> the folklore fact is that haskell isnt good crypto in any way because of timing
13:29:00 <dxtr> ertesx: Well, speed isn't my main priority but it would be preferrable to get a number within 15 minutes
13:29:11 <EvanR> check out mwc-random
13:29:34 <ertesx> dxtr: mwc-random is about the fastest PRNG on hackage (and possibly on the planet) =)
13:29:42 <dxtr> Actually for this purpose it doesn't have to be the most secure prng the world has ever seen. But the more the better I guess :)
13:30:05 <ertesx> and it gives you uniform distribution with good statistical properties, and if you need it, other distributions as well
13:30:21 <dxtr> Right!
13:30:36 <dxtr> I am using saltine for my crypto needs right now but it hasn't implemented libsodiums prng stuff
13:30:38 <ertesx> random-fu gives you a pure interface and more distributions
13:30:48 <EvanR> theres a package for stream ciphers, which abstracts away the dealing with RNGs
13:30:52 <dxtr> And I don't know enough how to implement that myself yet :p
13:31:06 <ertesx> but it does use the 'random' interface, and i'm not aware of a good PRNG implementation for it
13:31:57 <dxtr> I'd rather use the prng the OS provides which is why I like the idea of using libsodiums prng stuff
13:32:10 <ertesx> you could also just use one of the crypto generators…  they are reasonably fast, but most of them will only give you uniform distribution and an awkward interface, if you aren't dealing with crypto
13:32:38 <ertesx> the two main ones are DRBG and cryptonite
13:32:51 <dxtr> Right
13:33:09 <dxtr> And is it just me or do haskell library writers really despise documentation?
13:33:10 <EvanR> use a crypto library instead of designing your own crypto system ;)
13:33:28 <dxtr> EvanR: I am not designing my own crypto system and I am using a crypto library
13:33:49 <dxtr> I'd say libsodium qualifies as a "crypto library"
13:34:02 <EvanR> a lot of times the types are all you really need
13:34:27 <EvanR> i would rather have all the types than 2 examples ala ruby
13:34:33 <ertesx> dxtr: in other words: yes, some libraries are terribly documented, and there is no excuse =)
13:35:00 <ertesx> experienced haskellers often need only names and types, and that can make library authors lazy
13:35:10 <dxtr> EvanR: I would rather have man pages
13:35:27 <EvanR> in some cases IO actions cant be explained with a single name, a lot of cases actually
13:35:42 <EvanR> so you need a paragraph of explanation, which you have in the standard libs
13:35:54 <apriori> not even mentioning corner cases which are not described
13:36:29 <ertesx> dxtr: but most libraries you'd use are well (enough) documented, and the popular ones often have homepages or comprehensive 'README.md's
13:36:39 <EvanR> in other cases your library is designed around a type and you just need to know what this type is supposed to be
13:39:03 <ertesx> nearestRasterPoints :: (RealFrac p, Integral ip, Alternative f, Traversable t) => t p -> f (t ip)
13:39:11 <ertesx> yeah, the name and type already document what it does
13:39:34 <ertesx> but…  i'd really prefer to have a line of prose and perhaps an example, if it wasn't me who wrote it
13:40:15 <EvanR> ertesx: that sort of function's signature is a good example of how the type doesnt help
13:40:31 <EvanR> oh all 4 classes are standard classes...
13:40:45 <EvanR> if they were 4 library specific classes, then i would be crying
13:41:26 <ertesx> it computes, as its name states, the nearest raster points, of which there are 2^k, with k up to the dimensionality of 't'
13:42:26 <ertesx> in my haddock i have this example:  nearestRasterPoints (V2 0.4 0.4) :: [V2 Integer] = [V2 0 0, V2 0 1, V2 1 0, V2 1 1]
13:42:31 <ertesx> and i think it really helps
13:44:30 <EvanR> ertesx: if your raster is aligned on whole numbers!
13:44:45 <ertesx> if not, scale it to be
13:45:02 <EvanR> shift rather
13:45:13 <text_builder> Hi folks :) I have a file that turns a JS AST into a Data.Text.Lazy.Builder and everything works fine. It takes a long time to compile though. On my machine that is not a problem, but it takes so long on TravisCI that it bails. What kind of things should I be looking into?
13:45:19 <ertesx> or apply whatever transform you need =)
13:45:26 <EvanR> pixels are obviously located at 0.5,0.5, 1.5,1.5 etc ;)
13:45:44 <ertesx> text_builder: firstly the length of your modules
13:45:51 <text_builder> Is Data.Text.Lazy.Builder known to cause slow builds?
13:45:54 <ertesx> text_builder: GHC doesn't like long modules
13:46:04 <text_builder> 500 lines
13:46:08 <text_builder> For the problem module
13:46:15 <text_builder> Is that too many?
13:46:39 <text_builder> My assumption was that all the INLINE pragmas were the culprit here
13:46:53 <ertesx> 500 doesn't sound too much to me…  perhaps you had a lot of TH or inlining
13:47:13 <text_builder> No template haskell; I avoid that as much as possible ;)
13:47:27 <ertesx> GHC is actually pretty good at figuring out inlining by itself, so first reconsider whether you really need those
13:47:34 <ertesx> and try without to see, if it makes a difference
13:47:38 <text_builder> https://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text-Internal-Builder.html#Builder
13:47:40 <text_builder> It's not me
13:47:55 <ertesx> ah
13:47:57 <text_builder> They have the INLINE pragma all over the place in the backing implementation
13:48:01 * hackagebot smallcaps 0.6.0.2 - Flatten camel case text in LaTeX files  https://hackage.haskell.org/package/smallcaps-0.6.0.2 (StefanBerthold)
13:48:23 <ertesx> well, you could tell travis to compile without -O, if that's possible
13:48:31 <text_builder> Hmm, interesting
13:48:31 <ertesx> configure --disable-optimisation
13:48:47 <text_builder> I'll give it a try!
13:49:18 <text_builder> It spends most of the build compiling haskell, so that'll probably help a lot overall!
13:49:26 <ertesx> if you don't have any tests as part of the CI, you probably don't care how fast the code runs there
13:52:04 <text_builder> There are tests that exercise the code, but getting them to run at all is a win ;)
13:52:50 <text_builder> Is there ever a reason to have "ghc-options: -O2" for a library in a .cabal file?
13:53:00 <ertesx> unfortunately sometimes -O can make an asymptotic difference
13:53:17 <dcoutts> text_builder: sure, if it makes a big difference to performance
13:53:54 <text_builder> ah, so every package out there is built with the flags in the cabal file. Makes sense.
13:54:08 <text_builder> Not sure what I thought would happen instead :P
13:55:03 <text_builder> Okay, so if my travis build does the following three things:
13:55:08 <text_builder> cabal configure --enable-tests --disable-optimisation
13:55:11 <text_builder> cabal build
13:55:13 <text_builder> cabal test
13:55:21 <MarcelineVQ> ertesx: what does an asymptotic difference mean?
13:55:29 <text_builder> That will avoid the -O2 setting for Travis?
13:55:50 <text_builder> MarcelineVQ: If you have N things, it may take N seconds to process them
13:55:58 <ertesx> MarcelineVQ: code uses O(1) space with -O, O(n) with -O0
13:55:59 <EvanR> e^n - n^2 = e^n ;)
13:56:07 <text_builder> MarcelineVQ: But it's also possible that it takes N^2 seconds to process them
13:56:10 <text_builder> and that'd suck
13:56:20 <adarqui> hey, with haskell's stack.. say i have a library (LIB-A) with a git repo in my stack.yaml, i upload this package to github.. then in another lib (LIB-B), I reference that repo (LIB-A) on github.. for some reason though, LIB-B can't build because of missing dependencies from LIB-A
13:56:37 <MarcelineVQ> ah, hmm, what does space mean in this context?
13:56:39 <adarqui> it's as if it's not looking at the git location in stack.yaml
13:56:43 <text_builder> Okay, but about the --disable-optimisation flag, that'll override the -O2 flag in my .cabal file?
13:56:55 <ertesx> MarcelineVQ: heap space mostly
13:57:12 <ertesx> text_builder: not sure about that…  cabal doesn't expect that kind of interference
13:57:14 <text_builder> MarcelineVQ: like how much RAM is needed to do anything
13:57:25 <ertesx> text_builder: but i'm sure command line flags override .cabal-flags
13:57:46 <text_builder> hmm
13:58:01 <ertesx> text_builder: if you're unlucky, --disable-optimisation means that no -O is passed (rather than -O0)
13:58:42 <ertesx> text_builder: also -O2 rarely makes enough of a difference that you'd want to enforce it that much
13:59:25 <text_builder> yeah, i have not profiled extensively, but it's also on a compiler, so I figure it's worth it for the users
13:59:48 <text_builder> https://mail.haskell.org/pipermail/cabal-devel/2008-February/002145.html is saying to call this ./setup thing
13:59:54 <text_builder> Do I automatically have that?
14:00:07 <ertesx> you use cabal-install
14:00:11 <text_builder> yeah
14:00:56 <ertesx> the alternative would be to write old-fashioned Setup.lhs files and use those =)
14:01:29 <Denommus> hi
14:01:49 <ertesx> text_builder: read "./setup" as equivalent to "cabal" in your case
14:02:03 <text_builder> okay, cool
14:02:21 <text_builder> hmm, maybe I just need to break it into separate files
14:02:25 <text_builder> that flag seems to do nothing
14:02:31 <text_builder> will keep trying variations!
14:03:04 <text_builder> -O0 is the answer
14:03:09 <ertesx> GHC definitely doesn't like large modules, but i don't know what the metric is…  i've had problems with data types with a large number of constructors in the past
14:03:12 <text_builder> going to see how to override that in tests
14:03:22 <text_builder> yeah, that's what I have here
14:03:36 <text_builder> (Pattern match compilation can take a long time in some languages)
14:03:58 <lifter> servlet
14:05:19 <mgsloan> adarqui: Are you relying on LIB-B looking at the stack.yaml file used in LIB-A?  Because it won't - one stack.yaml per project
14:05:49 <adarqui> mgsloan: ah ok thanks! ya I was thinking it would build LIB-A according to it's stack.yaml
14:07:52 <mgsloan> adarqui: Welcome.  I recommend taking a look at these doc pages in particular: http://docs.haskellstack.org/en/stable/yaml_configuration/ and http://docs.haskellstack.org/en/stable/yaml_configuration/
14:08:00 <mgsloan> Err http://docs.haskellstack.org/en/stable/GUIDE/
14:08:11 <adarqui> hey another question if anyone knows.. so I have this library that simply uses String's. It works. I can stack ghci it, run it, everything is fine. However, when I import that lib from something else i'm working on, all of a sudden i get all kinds of No Instance for IsString errors, and Text.printf errors saying it could not deduce the type etc.. This other lib uses things like OverloadedStrings and such. Could that somehow be wrecking everything?
14:08:35 <adarqui> thanks mgsloan 
14:09:12 <ertesx> adarqui: you may need OverloadedStrings at the use site, too
14:09:25 <mgsloan> adarqui: Probably you have some code that's too polymorphic.  Like if you do (print "hi") with OverloadedStrings, it doesn't know what type to use for something that satisfies ((Show a, IsString a) => a)
14:09:29 <ertesx> if you write string literals not of type String
14:09:36 <EvanR> enabling OverloadedStrings can make your code involving "literals" to suddenly be ambiguous
14:09:50 <ertesx> or yeah, the exact opposite =)
14:10:31 <Job316> as an exercise, i'd like to build a FILO queue monad, without using list - is this v difficult?
14:10:53 <monochrom> wait, FILO is a stack
14:11:24 <adarqui> is there a way to somehow turn off overloaded strings for one module? because basically, this lib that uses String.. that's all it uses. And everything works fine in that library itself.
14:11:33 <Job316> yeah
14:11:35 <adarqui> like, literally everything in that first module is specifically typed for String
14:11:52 <monochrom> but there is http://hackage.haskell.org/package/control-monad-queue if you mean queue
14:12:22 <ertesx> Job316: why a monad?  what do you want the API to look like?
14:12:41 <Zemyla> A Contravariant Monad is isomorphic to Proxy, correct?
14:12:55 <Job316> same as list
14:12:56 <adarqui> so i can use default (String) or something maybe..
14:13:05 <marchelzo> why are you allowed to write 'data A = A Int Int'? wouldn't the type system be simpler but just as powerful if you had to write 'data A = A (Int, Int)'?
14:13:08 <Job316> and mainly to build a monad w/side effects as an exercise
14:13:31 <EvanR> Job316: so like, a monad with commands push and pop
14:13:36 <Job316> yes
14:13:47 <monochrom> marchelzo: yes for strict languages. no for nonstrict languages
14:13:54 <ertesx> Job316: i think you have two things to do here:  a stack data structure (which is actually predefined and you've probably already used it), and a state monad
14:13:54 <adarqui> marchelzo: not necessarily simpler, but i mean you can do things like A <$> 1 <*> 2 etc with the first syntax
14:14:18 <EvanR> you can implement it with State
14:14:22 <EvanR> or you can do it directly
14:14:29 <Zemyla> marchelzo: The second one allows "A undefined".
14:14:52 <marchelzo> adarqui: you could do that with the second one with 'curry'
14:14:56 <Job316> ah
14:15:09 <marchelzo> Zemyla, monochrom, I see
14:15:10 <ertesx> marchelzo: you can't control the strictness of each field in your example
14:15:26 <ertesx> data A = A !Int Int; data A = A Int !Int; etc.
14:15:28 <adarqui> so do you guys think adding default (String) would be a good solution to this? in the first library.. just put it at the top of each module?
14:15:28 <marchelzo> Is that why that feature exists in haskell?
14:16:03 <monochrom> yes. how many bottoms you can have matters. for nonstrict languages such as Haskell.
14:16:08 <ertesx> marchelzo: it's one reason, as you start to explore more advanced features multiple fields make even more sense
14:16:25 <marchelzo> I see
14:16:30 <marchelzo> thanks
14:16:31 <monochrom> observe that strict languages such as SML do it your way
14:16:40 <Zemyla> Also, you'd have to force people to say "data A = A (Either Int Float)" instead of "data A = AI Int | AF Float".
14:16:46 <ertesx> marchelzo: also keep in mind that (,) had to be defined at some point, too
14:16:58 <ertesx> if you don't have multiple fields, how would you define it?
14:17:05 <Zemyla> And it becomes absurd when Bool becomes "data Bool = Bool (Either () ())".
14:17:25 <marchelzo> ertesx: the lambda calculus-y way
14:17:40 <ertesx> marchelzo: which isn't allowed in standard haskell
14:17:48 <ertesx> you need -XRankNTypes for that one
14:18:15 <marchelzo> or using record types, but that is cheating
14:18:30 <Zemyla> marchelzo: And you'd have to use PatternSynonyms to be able to manipulate it in a compatible fashion.
14:18:44 <monochrom> record syntax is an extension of "Ta Ah Ah Ah Ah"
14:18:55 <marchelzo> right. well in that sense, tuples already require built in language support
14:19:05 <Zemyla> Anyways, marchelzo, you should look at GHC.Generics.
14:19:40 <Zemyla> It allows you to decompose nearly-arbitrary data types into combinations of tuples and Eithers.
14:20:13 <EvanR> products, coproducts, exponential
14:20:20 <EvanR> coexponential!
14:20:33 <marchelzo> thanks, I'll take a look
14:23:02 * hackagebot yesod-auth-hashdb 1.4.3 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.4.3 (paulrouse)
14:25:57 <text_builder> I am having trouble with https://wiki.haskell.org/Cabal/Developer-FAQ#Conditional_compilation
14:26:12 <text_builder> I can create the Flag declaration, but how do I actually use it from the command line?
14:26:25 <text_builder> Flag dev { ... }
14:26:35 <text_builder> but then it is not "cabal configure --dev"
14:26:41 <ertesx> -fdev
14:27:23 <dcoutts> text_builder: hmm, that's a bad example in the wiki. If you have a test exe, you should make it into a test-suite stanza, not an executable. Then it's automatically not enabled unless you --enable-tests.
14:27:26 <text_builder> ah, I tried --fdev!
14:27:45 <text_builder> dcoutts: I have a test-suite for that
14:28:09 <dcoutts> text_builder: then you don't need the flag or buildable: False thing
14:28:14 <text_builder> I am using this flag to switch between -O0 -W and -O2 for dev mode and real compilation
14:28:32 <text_builder> so I'm only using it on a "Library"
14:28:38 <dcoutts> text_builder: did you know you can use: cabal build -O0
14:28:52 <adarqui> default (String) fixed it, i think
14:29:00 <text_builder> dcoutts: That's so much better! :D
14:29:01 <dcoutts> or indeed cabal configure -O0 or -O2
14:29:08 <text_builder> Cool, thank you :)
14:30:10 <text_builder> Hmm, not getting it to work
14:31:25 <text_builder> Ended up with this http://pastebin.com/hKWJT7Ac
14:36:53 <text_builder> Well, thank you dcoutts and ertesx! I feel like I'm going in the right direction now :)
15:31:56 <Gurkenglas_> Is []'s cons literally short for constructor? ._.
15:32:27 <Rembane> Gurkenglas_: I think comes from lisp.
15:33:01 <Rembane> Gurkenglas_: This might either make you wise or more confused: https://en.wikipedia.org/wiki/Cons
15:57:06 <tolt> This might be unnecessary but if I have some sort of callback to listen to messages that is ran each time a message is received, if I want to have a variable number of clients would the best way to do that just keep a mutable list (TVar)?
15:57:22 <tolt> and reference that tvar each time the callback is ran?
15:58:35 * hackagebot ascii-progress 0.3.3.0 - A simple progress bar for the console.  https://hackage.haskell.org/package/ascii-progress-0.3.3.0 (yamadapc)
15:58:37 * hackagebot io-capture 0.1.0.0 - Capture IO actions' stdout and stderr  https://hackage.haskell.org/package/io-capture-0.1.0.0 (mitchellwrosen)
15:58:39 * hackagebot git-annex 6.20160418 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160418 (JoeyHess)
15:58:41 * hackagebot io-capture 1.0.0 - Capture IO actions' stdout and stderr  https://hackage.haskell.org/package/io-capture-1.0.0 (mitchellwrosen)
16:13:45 <acowley> Some of us were talking about a Servant for command line arguments a while ago. Does anyone know if somebody followed up on that idea?
16:15:16 <acowley> tolt: You could. STM really comes in handy when you have multiple pieces of shared state. If it's just one resource, you can also use an MVar to guard access.
16:27:33 <Big_G> What is the canonical way to map a function that takes two arguments over a list?
16:28:21 <Welkin> partially applied?
16:28:23 <bergey``> What's it getting from the list?  Second argument?
16:28:39 <Big_G> It'd be applying the function to every pair in that list.
16:28:55 <Big_G> [1,2,3] would be [f 1 2, f 2 3]
16:29:14 <Welkin> oh
16:29:20 <Welkin> zip them first
16:31:05 <bergey> I'd use: zipWith f l (drop 1 l)
16:32:08 <Welkin> > let xs = [1..4] in zipWith (\a b -> (a,b)) xs (drop 1 xs)
16:32:10 <lambdabot>  [(1,2),(2,3),(3,4)]
16:38:17 <Big_G> Is there a way to do it with a single list like tail or does it have to be with xs and drop 1 xs?
16:38:59 <Big_G> > let xs = [1..4] in zipWith (\a b -> a * b) xs (drop 1 xs)
16:39:01 <lambdabot>  [2,6,12]
16:39:28 <shachaf> @where sneaky
16:39:28 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
16:39:44 <shachaf> i,i zipWith f (dropFromEnd 1 l) (drop 1 l)
16:47:30 <Squarism> ertesx, You there?
16:57:30 <aleogen> sorry I've been away for so long everyone. I still love you all.
16:59:25 <maerwald> Mh, I'm considering to move explicitly passed GUI state into my own monad transformer... however, that'll require me to stuff my code full of liftIO. It seems I'm just moving the code duplication to another place.
17:18:03 <bitemyapp> baweaver: fyi, if you're talking to someone about the book and they raise the price as an objection, have them email us about a discount / free copy.
17:18:28 <bitemyapp> baweaver: _usually_ when someone objects it's because they're in a country with adverse GDP / VAT or they're a student and we never turn someone away in those circumstances.
17:18:35 <bitemyapp> baweaver: from each according to ability, etc etc.
17:18:44 <baweaver> Noted
17:19:11 <baweaver> fwiw I paid full price :P
17:19:18 <baweaver> which I'm fine with*
17:19:21 <bitemyapp> You're already a developer, are you not?
17:19:25 <baweaver> yep
17:19:31 <bitemyapp> yeah, we'll take your money :)
17:19:42 <bitemyapp> but we don't want anyone skipping meals for it.
17:19:51 <baweaver> anything that makes my life easier I'll shell out for
17:20:13 <bitemyapp> Well, that's the hope/notion. We save you loads more than $60 worth of time, we get paid so we can write more, everyone's happy.
17:20:16 <baweaver> also living out by SF, so....
17:20:38 <bitemyapp> baweaver: the main thing I miss about living in SF is the programmer meetups. Rest I could do without I think.
17:21:33 <bitemyapp> tho', that indo pak place in the Tenderloin was really good.
17:21:37 <bitemyapp> I could go for some indopak.
17:21:47 <baweaver> fly up some time and give me a ring
17:21:55 <baweaver> keystonelemur on twitter by the way
17:22:14 <bitemyapp> I remembered you on Twitter, we may have even met at a Clojure meetup long ago.
17:22:27 <bitemyapp> Dunno when I'll land in SF, but I'll ping you if I'm ever there.
17:22:34 <bitemyapp> I try to avoid even taking work from SF companies.
17:22:38 <baweaver> baweaver is taken by some sorority girl who drinks too much wine. The only reason I know this is that some recruiter found her instead of me :P
17:23:09 * bitemyapp looks
17:23:13 <bitemyapp> yeah big glass of wine. huh.
17:23:17 <baweaver> private account now
17:23:26 <baweaver> blocked me for some reason :D
17:23:28 <bitemyapp> too many people getting y'all confused?
17:23:35 * baweaver shrugs
17:23:49 <baweaver> half inclined to try and buy it from her, but I doubt that goes over well
17:33:59 <johnnymo87> anyone interesting in code review the a commit from a haskell newb? It's a bit of code to turn a list into a binary tree, tested by quickcheck: https://github.com/johnnymo87/heap/commit/28d36d6ee20822682b1346ee295b2cd2d6e2c169
17:35:20 <Squarism> Yesterday someone mentioned CPS (some sort of command pattern). I tried to google it but failed. Anyone into haskell that might know where i can read about it?
17:35:33 <hpc> @where wikibook
17:35:33 <lambdabot> http://en.wikibooks.org/wiki/Haskell
17:35:41 <hpc> there's a whole page there about it
17:36:02 <hpc> it's called continuation passing style
17:36:24 <Axman6> johnnymo87: there's no need to get the bits of an Int by going through a String, you can use x `mod` 2 to test if the last bit is 0 or 1
17:36:33 <ertesx> Squarism: pong
17:36:44 <Squarism> ertesx, hi
17:36:49 <Axman6> (there's alaso Data.Bits, which lets you directly inspect bits in a number)
17:37:13 * Sornaensis pokes Squarism in the bits
17:37:13 <Squarism> i set out to implement your example but was a bit unlucky
17:37:25 <johnnymo87> Axman6: damn, good point
17:37:26 <ertesx> Squarism: was it the game example?
17:37:33 <Squarism> yeah
17:37:52 <ertesx> Squarism: have you tried implementing the hangman example?  it's simpler and shows you the basics
17:37:58 <Squarism> quote: singleCharHangman char = InGame [Nothing] (\playerGuess -> if playerGuess == char then Won [char] else singleCharHangman char)
17:38:15 <Squarism> data Hangman = InGame [Maybe Char] (Char -> Maybe Hangman) | Lost String | Won String
17:38:51 <ertesx> Squarism: first simplify the Hangman type:  data Hangman = InGame [Maybe Char] (Char -> Hangman) | Won String
17:39:07 <ertesx> this one you cannot lose…  you can keep guessing until you win
17:39:55 <kadoban> johnnymo87: Perhaps I'm missing something, but I don't see how that's related to a heap. May be a pretty pedantic comment.
17:40:28 <Squarism> i dont the [Maybe Char] part 
17:40:37 <johnnymo87> kadoban: true. This commit wasn't heap-specific. I have a different (and incomplete) module for that
17:40:38 <ertesx> if you pattern-match on a value of type Hangman, you see what the current game is:  either it is an InGame, where [Maybe Char] is presentation information (it's a string with holes); if it's (Won xs), then the game is won and 'xs' is again presentation: it reveals the word
17:40:43 <kadoban> Ah
17:41:24 <ertesx> Squarism: example: InGame [Just 'h', Nothing, Just 'l', Just 'l', Just 'o'] f
17:41:40 <ertesx> this corresponds to a game with one letter missing: "h_llo"
17:42:14 <ertesx> 'f' takes a guess and returns a new game, which is either yet again an InGame, or (Won "hello")
17:42:25 <ertesx> Squarism: does that make sense so far?
17:43:28 <Squarism> ertesx, well i wonder when an instance of InGame is created with something else than [Nothing] is created?
17:43:42 <ertesx> Squarism: we'll get to that
17:44:45 <Squarism> ertesx, i see that a new instance of InGame is created over and over.. 
17:45:19 <Squarism> but i cannot see how the string with holes are constructed
17:45:53 <ertesx> here is the "h_llo" example:  helloGame = InGame [Just 'h', Nothing, Just 'l', Just 'l', Just 'o'] (\guess -> if guess == 'e' then Won "hello" else helloGame)
17:45:58 <ertesx> does it make sense?
17:47:14 <Squarism> yep
17:47:54 <ertesx> Squarism: at this point it would be great to be able to play such games, so you should write an interpreter for Hangman
17:48:01 <ertesx> hangmanStdio :: Hangman -> IO ()
17:48:15 <nineonine> does anyone remember the talk by SPJ where he talks about new things in ghc 8 ?
17:48:47 <ertesx> Squarism: start with the Won clause…  hangmanStdio (Won word) = _action
17:49:20 <ertesx> Squarism: ask yourself what playing a Won game might look like, and then implement it
17:49:39 <Squarism> ertesx, can i do thsi in ghci? 
17:49:50 <ertesx> Squarism: i recommend using a source file
17:49:52 <Squarism> or should i use compiled source file
17:49:54 <Squarism> ok
17:50:15 <ertesx> you can load it with GHCi and try it there
17:50:25 <ertesx> :l mymodule.hs
17:50:33 <ertesx> hangmanStdio (Won "hello")
17:50:50 <ertesx> when you change it, just reload it with the :r command
17:51:10 <Squarism> Error:(74, 27) ghc: Found hole _action with type: IO ()
17:51:11 <Squarism>                    Relevant bindings include
17:51:11 <Squarism>                      word :: String (bound at src/Main.hs:74:19)
17:51:11 <Squarism>                
17:51:22 <ertesx> _action is your exercise
17:51:26 <Squarism> ah
17:51:41 <maerwald> what's the best way to hide passing around GUI state explicitly when pretty much all GUI functions have to happen inside IO, because of low-level bindings? Doing monad transformer stuff will just cause me to add liftIO to every second line
17:52:19 <Squarism> hangmanStdio (Won word) = putStrLn word
17:52:21 <Squarism> =D
17:52:43 <ertesx> Squarism: yeah, that works, although you could make it *feel* like a game, too =)
17:52:55 <ertesx> putStrLn ("You got it! The word was " ++ word)
17:53:01 <ertesx> but it's up to you
17:53:59 <ertesx> maerwald: you could use reactive-banana or reflex and separate the application logic from the GUI framework
17:54:12 <maerwald> nah, that's overkill
17:54:38 <ertesx> Squarism: now for the InGame clause:  hangmanStdio (InGame word f) = _action
17:54:38 <Squarism> hangmanStdio (Won word) = putStrLn ("You found the answer of " ++ word)
17:54:41 <maerwald> I'm not doing FRP, I use the gtk+ bindings directly
17:55:57 <ertesx> Squarism: in this case remember that (word :: [Maybe Char])
17:57:13 <ertesx> this is now a running game, so you should present the challenge to the user somehow, then ask for their guess and finally submit it to 'f' to receive a new Hangman game
17:58:31 <ertesx> maerwald: well, if you want to get around IO, you need some kind of separation, and FRP is a ready-made one you can just drop in
17:59:09 <maerwald> I'm not going to learn FRP 3 months down the line and rewrite 90% of my program just because I want to hide GUI state -.-
18:02:03 <ertesx> you don't have to: it's drop-in
18:02:23 <ertesx> well, you'd have to learn it, but you don't have to change your old code
18:02:27 <maerwald> send a pull request...
18:04:27 <hackrilege> http://lpaste.net/160584
18:05:03 <hackrilege> this is an example of an approach i would like to discuss in terms of lazy evaluation
18:06:13 <hackrilege> im not sure i can formulate a good question, can anyone pass comment?
18:15:37 <Squarism> ertesx, i think im lacking in haskell skills creating this. http://pastebin.com/QtmiZdN9 was all i managed
18:16:50 <ertesx> Squarism: the game logic is encoded in the Hangman value…  you're trying to replace it in the interpreter
18:17:00 <ertesx> instead of writing an interpreter for a game, you're writing a game yourself
18:17:34 <Squarism> oh.. well as i might not have said.. this is my first haskell program
18:17:43 <ertesx> that's fine
18:17:55 <ertesx> hangmanStdio has received a game, and it should now present a user interface for it
18:18:44 <ertesx> this game happens to be InGame with a word with placeholders and a function that processes the player's guess
18:19:09 <ertesx> first step: tell the player what the challenge is…  you'll need 'word' for this
18:19:34 <ertesx> (oh, and please use lpaste.net)
18:27:46 <hackrilege> im using TVar and OpenGL, should i consider learning FRP?
18:27:52 <Squarism> ertesx, that would require me to flatmap maybe's wouldnt it?
18:28:44 <ertesx> Squarism: yeah
18:29:06 <ertesx> map _s word, where s :: Maybe Char -> Char
18:29:14 <Squarism> i really try here.. but im very new haskell
18:29:45 <ertesx> @let h_llo = [Just 'h', Nothing, Just 'l', Just 'l', Just 'o']
18:29:46 <lambdabot>  Defined.
18:29:55 <ertesx> :t h_llo
18:29:56 <lambdabot> [Maybe Char]
18:30:12 <ertesx> you need a [Char] that you can display
18:30:44 <ertesx> you've got a [Maybe Char]…  what do you think: would displaying the holes as underscores look nice?
18:31:17 <hackrilege> > map (\x -> if x == Nothing then '_' else fromJust x) h_llo
18:31:19 <lambdabot>  "h_llo"
18:31:20 <ertesx> hackrilege: likely
18:31:28 <ertesx> hackrilege: thanks for spoiling…
18:31:49 <hackrilege> it was too juicy sorry!
18:32:04 <ertesx> i'm glad that your solution is terrible
18:32:10 <matt-> :P
18:32:11 <hackrilege> !!
18:33:10 <Squarism> map _s word, where s :: Maybe Char -> Char
18:33:18 <Squarism> what is _s?
18:33:42 <ertesx> Squarism: something you have to write
18:33:54 <ertesx> > map _s h_llo
18:33:55 <lambdabot>      Found hole ‘_s’ with type: Maybe Char -> b
18:33:55 <lambdabot>      Where: ‘b’ is a rigid type variable bound by
18:33:55 <lambdabot>                 the inferred type of it :: [b] at <interactive>:1:1
18:34:11 <ertesx> thanks for not helping, lambdabot…
18:34:21 <ertesx> _s is of type Maybe Char -> Char
18:34:27 <Squarism> ok.. ill try
18:34:33 <hackrilege> can you call a function _s?
18:34:52 <ertesx> Squarism: wait
18:35:00 <hackrilege> i dont think mixing symbols and characters is allowed
18:35:28 <hackrilege> its probably just some strange syntax used in the question, unless it has some special meaning im not aware of
18:35:34 <ertesx> Squarism: the idea is that you map a function that turns Nothing into underscores over the string
18:35:58 <hackrilege> i think its safe to read _s as s
18:36:06 <ertesx> Squarism: so first write that function
18:36:12 <ertesx> hackrilege: it's a typed hole
18:36:17 <hackrilege> oh
18:36:27 <hackrilege> yeah the latter, i was scared of that
18:37:06 <Squarism> map (\s-> maybeToList s)  h_llo
18:37:32 <hackrilege> prefix is with a > and lambdabot will do its thing
18:37:33 <ertesx> Squarism: maybeToList :: Maybe a -> [a]
18:37:51 <ertesx> Squarism: you need:  Maybe Char -> Char, not Maybe Char -> [Char]
18:38:19 <hackrilege> otherwise it would say "hllo""
18:38:33 <Squarism> ok
18:38:56 <ertesx> Squarism: the 'maybe' function could help you
18:38:59 <ertesx> :t maybe
18:38:59 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:40:03 <hackrilege> > maybe '_' id Nothing
18:40:04 <lambdabot>  '_'
18:40:12 <matt-> \o/
18:41:09 <hackrilege> could someone take a look at my zipper tree? http://lpaste.net/160584
18:42:52 <Squarism> ap (\s-> case s of; Just x -> x;  Nothing ->'_';)  h_llo
18:42:55 <Squarism> map (\s-> case s of; Just x -> x;  Nothing ->'_';)  h_llo
18:43:24 <ertesx> > map (\s-> case s of; Just x -> x;  Nothing ->'_';)  h_llo
18:43:25 <lambdabot>  "h_llo"
18:43:30 <hackrilege> woot!
18:43:36 <ertesx> Squarism: looks good
18:43:57 <ertesx> Squarism: as a convenience 'maybe' does the pattern-matching for you
18:44:15 <ertesx> > map (maybe '_' id) h_llo
18:44:16 <lambdabot>  "h_llo"
18:44:30 <matt-> :t fromMaybe
18:44:31 <lambdabot> a -> Maybe a -> a
18:45:35 <Squarism> ok 
18:45:41 <ertesx> Squarism: you've almost got yourself an interpreter for Hangman…  present the challenge to the player in some way, and then read their guess
18:46:02 <Squarism> you said game logic is encoded in InGame
18:46:10 <ertesx> yeah
18:46:16 <Squarism> but you mean helloGame? no?
18:46:44 <hackrilege> fromMaybe a m = maybe a id m
18:46:51 <ertesx> Squarism: helloGame is an example that you can give to hangmanStdio
18:51:14 <hackrilege> when using zippers, does > left . right . left execute in the same time or more than > left
18:51:21 <hackrilege> ?
18:53:07 <Squarism> http://lpaste.net/160594
18:54:03 <Cale> hackrilege: more, of course
18:54:17 <Squarism> ertesx, ok.. like that?
18:54:28 <hackrilege> so my storage Tree is justified Cale?
18:54:58 <hackrilege> i dont know if you remembered i was talking about it recently...
18:55:04 <ertesx> Squarism: yeah, that looks great =)
18:55:11 <hackrilege> i prepared a paste; http://lpaste.net/160584
18:55:12 <ertesx> Squarism: have you tried it?
18:55:30 <ertesx> (you can just copy the definition of helloGame)
18:55:44 <hackrilege> see line 83
18:55:51 <Cale> hackrilege: I don't know what your storage tree is, but that fact is almost unavoidable. If you know identically that left . right . left is *always* going to be the same as left for some reason, then you could add a RULES pragma to get the compiler to rewrite it
18:56:16 <ertesx> Squarism: oh, and use the simpler Hangman type without Lost (unless you're prepared to handle that case, too)
18:56:17 <Cale> hackrilege: However, I can imagine in most cases, that won't be true at the boundaries
18:56:36 <Squarism> ertesx, i dont get any prompt
18:56:56 <hackrilege> hmmmmm RULES pragma sounds good. i cant see why stepping off a boundary and back should not return you to where you started...
18:57:34 <Cale> hackrilege: Well, does it? Or does the movement fail?
18:58:24 <Squarism> ertesx, no prompting in http://lpaste.net/160596
18:58:38 <hackrilege> to not fail it would have to extend infinitely populated with nothing, but i guess thats a reasonable side effect of trying to walk arbritrarily far offthe edge...
18:58:57 <hackrilege> so i guess anyway it just fails...
18:59:01 <Cale> hackrilege: It's a really bad idea to add a RULES pragma when something isn't absolutely true in all cases.
18:59:27 <hackrilege> it was something i would hope was picked up by lazy evaluation
18:59:39 <Cale> (the compiler isn't going to check)
19:00:31 <Cale> Lazy evaluation isn't magic, it's just outermost-first evaluation with the rule that expressions bound to individual variables are evaluated at most once and shared between the occurrences of that variable (as long as it remains in scope)
19:02:16 <hackrilege> the idea of loading the cojoined zipper into a tree was to save and access past zippers which might be less expensive that reproducing them if left and right are quite intensive
19:02:37 <ertesx> Squarism: uhm…  it's better to read a line using getLine and then use the first character of it
19:02:44 <Cale> Well, navigating a tree might be just as expensive
19:03:09 <Cale> It depends a bit on what left and right do, but most zippers are designed such that they are very cheap
19:03:11 <hackrilege> did you see the paste? http://lpaste.net/160584
19:04:07 <Cale> Oh, btw, never use ([] ==), it's always better to use null instead
19:04:11 <Cale> :t null
19:04:11 <lambdabot> Foldable t => t a -> Bool
19:04:23 <hackrilege> awesome thanks
19:04:37 <hackrilege> why specifically?
19:04:43 <Cale> Hah, it has a type class constraint now, but at least it's not got the Eq constraint
19:05:00 <hackrilege> ah ok
19:06:14 <Squarism> ertesx, something is wierd. or is it expected i get the question after i enter input? 
19:06:15 <hackrilege> i dont see why toList isnt Foldable's only method...
19:06:23 <Squarism> something with IO monad stuff
19:09:14 <ertesx> Squarism: this may be buffering-related
19:09:29 <ertesx> Squarism: import System.IO and put the following into your main action before the game:
19:09:37 <joneshf-laptop> Is `Cont r` `Traversable`?
19:10:04 <ertesx> Squarism: mapM_ (`hSetBuffering` LineBuffering) [stdin, stdout]
19:10:10 <hackrilege> i guess CoMonads are always non empty? i think this because coreturn must not return Nothing
19:10:47 <Squarism> ertesx, works perfectly
19:11:02 <Squarism> ertesx, thanks alot. i know feel a bit better on haskell =D
19:11:22 <ertesx> Squarism: great…  you've got your first separation of concerns
19:11:35 <ertesx> UI separate from game logic
19:12:48 <Squarism> good for my project
19:12:51 <hackrilege> is there no minimal frp library or standard?
19:13:49 <ertesx> Squarism: for me it's bed time now, but you could try to implement a general hangman game
19:14:09 <ertesx> hangman :: String -> Hangman  -- takes a word and turns it into a hangman game
19:15:10 <Squarism> ertesx, i will do that 
19:15:16 <Squarism> thanks again
19:15:22 <hackrilege> or an introduction on writing minimal a frp library
19:16:02 <orion> Is MonadError generally the best way to deal with pure exceptions?
19:16:20 <orion> I mean, exceptional situations in pure code.
19:17:17 <hackrilege> > error "this"
19:17:19 <lambdabot>  *Exception: this
19:18:51 <hackrilege> i guess you want to catch the error though
19:19:51 <hackrilege> Cale, any other comment other than use null?
19:20:18 <ntnt> is there a nice way to "tail -F" a *.th.hs file? I prefer the screen to *clear* whenever the file is deleted
19:20:30 <ntnt> this way, I can have a terminal window always showing the latest of the *.th.hs file, instead of a concatenation of all past compilations
19:22:55 <Cale> ntnt: perhaps use watch?
19:24:41 <ntnt> Cale: watch -n 0.1 works nicely
19:25:22 <hackrilege> i wrote the example because i wasnt sure if i was managing to communicate a concept to you, is it clear now that there is a compilable example?
19:25:29 <ntnt> Cale: btw, I'm starting to become proficient in TH. Thanks for all your help the other day with getting me started.
19:26:03 <hackrilege> ntnt, what was the first thing i should learn?
19:26:06 <hackrilege> about TH
19:26:35 <ntnt> hackrilege: Cale is the TH Yoda. Learn from him you must.
19:27:01 <hackrilege> im sure i already abuse Cale as a resource
19:27:32 <ntnt> the one thing I found was that "learning TH" is like "learning Monads" in that almost all the tutorials are confusing, and it's better to just bust out a notebook, jump into the details, and start writing out type signatrues and see how things fit together
19:28:13 <Cale> hackrilege: Sorry about not being able to give a better code review, I'm basically hanging out here while waiting for tests to run and such :)
19:28:27 <hackrilege> a monad is a functor you can construct and fold
19:28:44 <Cale> I still disagree with that statement
19:28:52 <ntnt> TH is just like lisp macros, but for Haskell
19:29:01 <Cale> But if you replace 'fold' with 'join', I'll be happy enough
19:29:08 <hackrilege> fold = join
19:29:31 <Cale> That would be confusing terminology, because fold is already taken to mean a few other things, none of which are join
19:29:40 <hackrilege> :t fold
19:29:41 <lambdabot> (Foldable t, Monoid m) => t m -> m
19:29:44 <hackrilege> :t join
19:29:45 <lambdabot> Monad m => m (m a) -> m a
19:29:50 <hackrilege> oh
19:30:04 <hackrilege> you can fmap fold
19:30:25 <cheater> hello
19:30:32 <nitrix> hackrilege: That doesn't mean much though.
19:30:32 <Squarism> in ertesx example.. can someone explain how "revealedLetters" are passed on to the next instance of InGame?
19:31:03 <Squarism> the sequence of [Maybe char] of InGame
19:31:15 <nitrix> hackrilege: `fmap fold` would still have different semantics than `join`, as far as I understand.
19:31:54 <hackrilege> > join ["hello","world"]
19:31:55 <lambdabot>  "helloworld"
19:32:20 <hackrilege> looks like fold to me...
19:32:42 <hackrilege> anyway nvm
19:33:15 <Squarism> data Hangman = InGame [Maybe Char] (Char -> Hangman) | Won String
19:33:16 <Squarism> singleCharHangman char = InGame [Nothing] (\playerGuess -> if playerGuess == char then Won ([char] :: String) else singleCharHangman char)
19:33:54 <hackrilege> is there a way of storing constructor functions? does that make sense? as if any branch of atree could be extended if supplied with a new element and these constructors could be gathered in a list...
19:34:01 <hackrilege> is that a common approach?
19:34:15 <hackrilege> if seen it in Unfoldable
19:34:21 <Squarism> how can InGame [Just "h", Nothing, Just "l",Just "l",Just "o"] (...) be instantiated? 
19:34:22 <Cale> hackrilege: While it's possible to write join using a fold over a list, it's not possible to define a fold which will make that work for e.g. State s, or IO
19:35:00 <Cale> Squarism: are you asking how to fill in the function field?
19:35:03 <hackrilege> :t bind
19:35:04 <lambdabot>     Not in scope: ‘bind’
19:35:04 <lambdabot>     Perhaps you meant one of these:
19:35:04 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
19:35:17 <hackrilege> :t (=>>)
19:35:18 <lambdabot>     Not in scope: ‘=>>’
19:35:18 <lambdabot>     Perhaps you meant one of these:
19:35:18 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
19:35:24 <hackrilege> sorry
19:35:32 <Squarism> Cale, the second argument of InGame
19:35:37 <hackrilege> :t (>>=)
19:35:38 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:36:03 <hackrilege> :t return
19:36:04 <lambdabot> Monad m => a -> m a
19:36:12 <hackrilege> what is the name of functions with this type?
19:36:26 <hackrilege> the second argument to >>=
19:36:35 <hackrilege> a -> m a
19:36:47 <hackrilege> a constructor?
19:36:51 <Squarism> He said something about state is "Just "it's implicit in the code that constructs a value of this type"
19:37:05 <Squarism> He said something about state is "it's implicit in the code that constructs a value of this type"
19:37:34 <hackrilege> meaning State is used under the hood?
19:37:47 <Squarism> in a "multiCharhangman" implemenation that is 
19:37:50 <nitrix> Is there a significant cost associated to IORef ?
19:38:37 <hackrilege> is it redundant to have something like data Messy a = Messy (a -> Messy a)
19:38:40 <hackrilege> ?
19:38:40 <Squarism> hackrilege, was that for me?
19:38:44 <nitrix> I'm assuming, that of unboxing the value and dereferencing the pointer behind it?
19:38:57 <hackrilege> just the comment about State was Squareism yes
19:39:31 <Squarism> so you mean game is a monad of sorts?
19:40:01 <nitrix> hackrilege: Looks like Generic.
19:40:11 <nitrix> type Generic c = forall a. Data a => a -> c a
19:40:23 <hackrilege> i cant see reference to Game in your code...
19:40:30 <hackrilege> maybe i have an old version
19:40:50 <hackrilege> Data a?
19:41:23 <Squarism> hackrilege, one guess could be that he didnt introduce it yet (for me to learn the simple version first)
19:41:35 <hackrilege> hmm ok
19:41:47 <hackrilege> in which case dont worry about Monads for now
19:42:00 <Cale> Squarism: Well, it's a function which takes a character and produces a Hangman. It might be a lambda, but you're probably going to write something recursive...
19:42:00 <Squarism> i have some clue about them
19:42:06 <hackrilege> you would need to be working with Functors a bit first, just using map and fold over lists is good
19:42:52 <Squarism> i would just like to get this CPS game approach down and working
19:43:18 <Squarism> im missing the important part about passing on a transformed game state
19:44:12 <hackrilege> no i dont think its Generic
19:44:35 <Squarism> this is the simple version we arrived at http://lpaste.net/160596
19:45:16 <hackrilege> i mean something like data Foo a = Foo ((Generic Foo) a)
19:45:40 <hackrilege> a datastructure who contains functions which construct it
19:46:17 <hackrilege> Squareism, nice
19:48:02 <Squarism> the last step would be to implement multiCharHangman.. and for that the first argument of InGame should be modified.. feels like a monad or lens thing ?
19:48:43 <Squarism> or actually i have no clue. 
19:49:33 <nitrix> Hi, I'm refactorung, I have an error "Could not find module X".
19:49:49 <nitrix> Is there a way to know which module is trying to import X ?
19:50:11 <dmj> nitrix: it should say say the filename that is trying to import it
19:50:31 <nitrix> <command line>: Could not find module ???World??? Use -v to see a list of the files searched for. Failed, modules loaded: none.
19:50:42 <nitrix> (GHCi)
19:50:45 <hackrilege> loading module.... etc... error
19:50:45 <Squarism> theres no "self" or this reference in haskell? 
19:50:52 <hackrilege> no
19:51:09 <dmj> Squarism: self is evil
19:51:17 <hackrilege> > let this = this in this
19:51:20 <nitrix> hackrilege: Closest is `mdo` I think.
19:51:21 <lambdabot>  mueval-core: Time limit exceeded
19:51:48 <hackrilege> :t mdo
19:51:49 <lambdabot>     Not in scope: ‘mdo’
19:51:50 <lambdabot>     Perhaps you meant ‘mod’ (imported from Prelude)
19:52:27 <nitrix> It's a syntax element from the RecursiveDo extension.
19:52:27 <hackrilege> nitrix, what do you mean?
19:52:30 <hackrilege> oh ok
19:52:43 <orion> I'm reading about the pitfalls of monad transformer stacks, and I've heard people recmomend creating your own Monad which does all the things you need. However, I am not certain what they mean by that. How would you create a single Monad which combines multiple transformers?
19:53:30 <nitrix> I do not recommend it though. It serves a different purpose. You can't translate all concepts to functional languages with a 1:1 correspondance :/
19:53:32 <nitrix> hackrilege: ^
19:54:07 <hackrilege> https://wiki.haskell.org/MonadFix
19:54:09 <hackrilege> this?
19:54:44 <Squarism> In function singleCharHangman http://lpaste.net/160596 theres no way i can access InGame's first argument in the invocation of singleCharHangman in InGame's second argument
19:54:49 <Squarism> line 2
19:54:52 <Cale> orion: Well, first learn how the transformers are implemented
19:55:22 <nitrix> Cale: dmj`: I'm 100% sure it's a cache issue.
19:55:48 <nitrix> If I delete .stack-world and start ghci again it'll figure out the World module is gone.
19:56:01 <nitrix> * .stack-work folder
19:56:25 <nitrix> I've had this problem many times, I'm just not sure why it's happening.
19:56:52 <mgsloan> nitrix: Are there compile errors before "could not load"
19:57:04 <mgsloan> that message happens because stack generates a ghci script which loads everything
19:57:25 <mgsloan> But if there's an error compiling modules, the load statements cause these "could not load" errors
19:57:32 <mas0n> what can list comprehensions do better/easier than higher order functions?
19:58:11 <mgsloan> nitrix: Ohh, are you just doing :reload?
19:58:19 <mgsloan> Yeah, if you delete modules ghci is not going to know
19:58:43 <mgsloan> We need to have a more integrated ghci + stack thing to happen for that to work 
19:58:55 <mgsloan> I have hopes that ghcid or ide-haskell-engine will go there
20:01:07 <orion> Cale: When would you benefit from writing a single Monad that has all the semantics you want as opposed to using a stack?
20:01:37 <Cale> orion: Well, it can be significantly faster, due to much lower allocation.
20:02:05 <Cale> orion: Another thing is just that MonadState/MonadReader/MonadWriter are usually not *really* the API you want to provide.
20:02:31 <nitrix> mgsloan: Even quitting and restarting GHCI isn't enough.
20:02:36 <nitrix> I had to do `stack clean`.
20:03:09 <Cale> It's kind of lazy design to just leave that stuff exposed IMO. You can use monad transformers, but the users of your library shouldn't be able to tell you're using monad transformers.
20:03:46 <Cale> Especially if 'lift' is available in user code, it pins you into an inflexible situation where you can no longer change the implementation of your monad without rewriting all the user code.
20:04:38 <nshepperd> Squarism: just create a new InGame directly in the guess function. (\playerGuess -> if ... then ... else InGame x y)
20:04:40 <Cale> But yeah, even if you're abstracting over the monad, I think 'get' and 'put' are just way too meaningless most of the time, and you'd prefer to have more specialised operations available.
20:04:56 <Cale> What those specialised operations are, well, it really depends on what the library does.
20:05:23 <Squarism> nshepperd, but then i need to change definition of second argument also right?
20:06:07 <mgsloan> nitrix: Yeah, probably a bug.  Caching is hard
20:06:29 <Cale> You also generally shouldn't set out saying "I'm going to define a monad today" -- well, it should be an option to consider while designing your library, but it's not the only option. Figure out what the primitives you provide are, figure out the ways that you let the user combine them together. Look and see if it might be nice to have a monad instance, but don't try to force it.
20:06:32 <mgsloan> Due to stuff like TH we need to cache build deps based on actual compiletime behavior.  The issue is probably there
20:06:37 <nshepperd> Squarism: yeah. probably you need a function for that
20:07:06 <mgsloan> nitrix: Are you passing in "--no-build" by chance?  All bets are off for success in that case (but it makes it much faster)
20:07:33 <mgsloan> (till https://github.com/commercialhaskell/stack/issues/1364 is addressed)
20:08:17 <Cale> orion: Sometimes monads just naturally grow out of organically abstracting over IO. I think I'd be much happier living in a world where people over-used FreeVL vs. a world where people over-use monad transformers, because at least FreeVL gets you to think about the operations you're providing.
20:08:58 <orion> Cale: The interface to my library completely hides the fact that I'm using a transformer stack under the hood.
20:09:07 <orion> Also, the entire stack is pure.
20:09:07 <Squarism> nshepperd, it felt as if he had some deeper idea with this. That the definition of Hangman would work for multiletter hangman too 
20:09:09 <Cale> orion: Yeah, that's good.
20:09:19 <Squarism> mentions of CPS 
20:09:24 <orion> Sorry, the entire stack is not in IO (it's always pure)
20:10:07 <mas0n> IO is pure
20:10:15 <orion> mas0n: Hence, my correction.
20:10:38 <Cale> I also don't really care for the word 'stack' there... a monad constructed by applying a bunch of monad transformers is about as much like a stack as f (g (h x)) is at the value level. We never say "function stack", why did we start saying "monad transformer stack"?
20:10:59 <Cale> But that's just a personal gripe I think :)
20:11:48 <orion> Cale: Do you know of any good examples of someone who wrote their own Monad which provides all the needed semantics?
20:11:55 <orzo> I there a way i can force an expensive computation to happen at compile time?
20:11:58 <nshepperd> Squarism: is the first argument there supposed to be the game board that the player sees?
20:12:00 <orion> Is the scotty web server one example?
20:12:05 <Cale> Well, let's look at how your monad is defined?
20:12:31 <Squarism> nshepperd, yep.. that would be "gameState"
20:13:20 <nshepperd> Squarism: what I would do is have a local function that takes the gameState and a guess, and produces a new Hangman
20:13:25 <orion> Cale: Some background... I *was* throwing exceptions in pure code if, say, a decryption operation failed. Then I realized that since my entire interface is pure, I can't ever hide those exceptions from the end-user because handling exceptions is done in IO.
20:13:27 <Cale> orion: Nope, Scotty uses monad transformers
20:13:28 <orzo> i have a complicated expression building a data structure, but it's all from compile time constants and has no loops
20:13:45 <orzo> but currently it is happening at runtime and is very slow
20:13:53 <Cale> orion: What's the newtype declaration?
20:14:18 <orion> Cale: I used a type synonym: type HandshakeMonad c d h r = Coroutine (Request ScrubbedBytes ScrubbedBytes) (State (HandshakeState c d h)) r
20:14:49 <Squarism> nshepperd, local to InGame? 
20:14:53 <Cale> orion: I think there's nothing wrong with using monad transformers, as long as you're good about hiding them.
20:14:57 <nshepperd> Squarism: calling that function run_guess, then it would be something like multiCharHangman word = InGame initial_state (run_guess initial_state)
20:15:08 <nshepperd> Squarism: local to multiCharHangman
20:15:31 <Cale> orion: But if you give me the expression involving lots of monad transformers, I can try using the bot's @unmtl on it :)
20:15:40 <orion> Cale: I have this transformer currently, but I need to be able to handle exceptional conditions like bad data received from the network, leading to a decryption error. I want to layer on ExceptT somewhere, but I'm not sure if it should be in the base or the outer layer.
20:16:09 <nshepperd> Squarism: in run_guess, you would produce the new gameState in the normal way, by updating it given the guess, and you'd produce the new second argument by (run_guess newState). So, InGame newState (run_guess newState)
20:16:18 <orion> And since I'm about layer on ExceptT, I figured I might as well ask about defining my own Monad.
20:16:23 <orion> about to*
20:17:02 <Squarism> nshepperd, ok.. ill see what i can do
20:18:07 <orion> Cale: https://github.com/centromere/cacophony/blob/test-vectors/src/Crypto/Noise/Internal/Handshake.hs#L148
20:18:28 <Squarism> nshepperd, its just that he argued for not passing gamestate in the function but rather utilize som CPS like trick to encode it in InGame of sorts
20:18:55 <hackrilege> the hangman contains a function returning a hangman
20:22:00 <Squarism> hackrilege, but that function doesnt know about the InGame's members
20:23:27 <nshepperd> Squarism: I wrote an annotation to your paste http://lpaste.net/160596 vaguely showing what I mean
20:23:35 <hackrilege> Squarism, it must
20:23:47 <nshepperd> that's the straightforward way to do it anyway
20:24:16 <hackrilege> if guess == 'e', should be something like; elem guess "hello"
20:24:19 <hackrilege> :t elem
20:24:20 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
20:24:54 <Squarism> nshepperd, thanx! ill try it directly
20:24:55 <hackrilege> that way the function contains the total guess
20:27:19 <hackrilege> nshepperd's multiCharHangman has word in scope, this is much better!
20:35:16 <nshepperd> Squarism: are you familiar with monads?
20:35:42 <Squarism> nshepperd, i am.. but i have never implemented one myself
20:35:46 <nshepperd> there's a nice way for doing games like this involving a tree monad
20:35:56 <Squarism> i get the feel this is a monad problem
20:36:15 <Squarism> binding commands to a context of sorts
20:37:08 <Squarism> or applying functions to values in a context =D
20:39:17 <Squarism> nshepperd, you have some resource where you can read about it?
20:40:52 <hackrilege> basically the datastructure has a function (Char -> Hangman) which is a kind of basic form of return :: Moand m => (a-> m a)
20:41:00 <nshepperd> I don't know, maybe I should write one.
20:41:55 <hackrilege> Squarism, did you complete the exaample yet? we can rewrite it with Monads after
20:42:12 <Squarism> hackrilege, im on it
20:43:14 <lpaste> nshepperd pasted “Game Tree Example” at http://lpaste.net/160699
20:43:55 <nshepperd> get the normal version working first, then maybe look at the above fancy example with monads :)
20:45:25 <lpaste> nshepperd revised “Game Tree Example”: “Game Tree Example” at http://lpaste.net/160699
20:46:31 <mas0n> are haskell's list comprehensions more powerful than python's?
20:47:25 <kristof> mas0n: Not especially, but they are lazy.
20:48:10 <mas0n> too bad
20:49:10 <kristof> mas0n: If you can make them better, suggest it to the maintainers of GHC. :)
20:49:20 <geppettodivacin> mas0n: What more are you looking for?
20:49:21 <Lovepon> Has anyone worked with the spock library?
20:49:22 <nshepperd> if it's possible to get inputs from multiple sources with python list comprehensions, i've forgotten how
20:49:43 <nshepperd> as in cartesian product
20:49:45 <mas0n> geppettodivacin, I wanted them to be more powerful. just a childish desire I guess
20:50:02 <mas0n> nshepperd you can
20:50:45 <geppettodivacin> I'm now picturing angsty teenage lists turning to the Dark Side to obtain greater power than they can imagine.
20:50:58 <nshepperd> oh, that's right, you repeat the for
20:51:05 <mas0n> yeah
20:51:22 * geekosaur not even sure what "more powerful" would mean for a list comp
20:51:31 <nshepperd> yeah, so basically they're the same
20:51:33 <mas0n> more features
20:51:36 <geekosaur> (assuming -XMonadComprehensions doesn't count :p )
20:51:48 <nshepperd> except that haskell's are lazy and therefore better :>
20:53:07 <mas0n> syntax is nicer in any case. more mathy, less python in reverse
20:54:51 <mas0n> more people seem to prefer higher order functions to list comprehensions from what i've seen. when do you if ever prefer list comprehensions?
20:54:57 <Cale> mas0n: There are some extensions which make them more powerful
20:55:18 <Cale> mas0n: I prefer list comprehensions in a few cases
20:55:20 <mas0n> which ones?
20:55:25 <Cale> 1) When there is more than one generator
20:55:58 <Cale> (it's usually better than nested concatMaps at least, but sometimes do-notation will win)
20:56:14 <Cale> 2) When you're doing non-trivial pattern matching on the generator
20:56:51 <Cale> > [(x,y) | (x:xs) <- tails [1..10], y <- xs]
20:56:53 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),(2...
20:56:59 <Cale> > [(x,y) | (x:xs) <- tails [1..4], y <- xs]
20:57:00 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
20:57:11 <Cale> That's tricky to otherwise express
20:57:31 <Cale> 3) When there's no generators, and you want a list which has 0 or 1 element based on a boolean condition
20:57:44 <geekosaur> actually thats a good point, pattern matching does make them more expressive than Python's
20:58:11 <geekosaur> although strictly speaking it's not a feature of list comprehensions as such
20:58:20 <Cale> Yeah
20:58:31 <Cale> There's also the very rarely used parallel list comprehensions
20:58:50 <Cale> > [(x,y) | x <- [0..] | y <- ['a'..'z']]
20:58:52 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h'),(8,'i'),(9,...
20:58:56 * hackagebot agda-snippets 2.5.1 - Render just the Agda snippets of a literate Agda file to HTML  https://hackage.haskell.org/package/agda-snippets-2.5.1 (LiamOConnorDavis)
20:59:07 <dolio> Comprehensions are actually more natural notation for Applicative than do notation, in a way.
20:59:47 <mas0n> > [(x,y) | (x:xs) <- []]
20:59:49 <lambdabot>  []
21:00:00 <mas0n> cool, didn't know that one
21:00:16 <Cale> > [(x,y) | (x:xs) <- [[]]] -- more importantly
21:00:17 <lambdabot>  []
21:00:28 <Cale> Elements not matching the pattern get skipped
21:00:45 <Cale> > [x | Right x <- [Left 4, Right "hi", Left 7, Right "there"]]
21:00:47 <lambdabot>  ["hi","there"]
21:01:20 <johnw> that's cute
21:01:37 <geppettodivacin> Does it skip non-matching elements when using do notation, as well?
21:01:49 <Cale> yes actually
21:03:11 <Cale> (It uses fail, which for the list instance of Monad, gives an empty list)
21:03:35 <lpaste> tippenein pasted “trying to apply a lens to an s3 response” at http://lpaste.net/160727
21:03:43 <Cale> fail is an unfortunate inclusion in the Monad class, but this is at least an instance where it actually makes some sense
21:04:35 <Cale> tippenein: That's starting to look like something that really wants to be a DMap
21:05:24 <hackrilege> Squarism i updated your paste
21:05:58 <Squarism> hackrilege, much appreciated!
21:06:39 <Cale> tippenein: But... what's the problem?
21:08:07 <Cale> tippenein: Presumably you want something like  fmap (view lorsContents) . send $ listObjects "derp" ?
21:08:09 <Squarism> hackrilege, its been completed with board updating? 
21:08:09 <lpaste> tippenein revised “trying to apply a lens to an s3 response”: “trying to apply a lens to an s3 response” at http://lpaste.net/160727
21:08:53 <Cale> tippenein: You don't just apply the lens like it's a function usually.
21:09:20 <Squarism> hackrilege, i would be very interrested to hear about your monad approach
21:09:23 <Cale> It *is* a function, but look at its type here, you don't have a function [Object] -> f [Object] hanging around that you'd like to apply it to
21:09:25 * hackagebot yesod-job-queue 0.1.0.1 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.1.0.1 (nakaji_dayo)
21:09:53 <hackrilege> i think the parameter of the Monad should replace Char, what do you think?
21:10:06 <tippenein> Cale: yours works
21:10:14 <Cale> So use view/set, which will apply the lens function to appropriate arguments (using appropriate choices of functor f) to extract the contents, or replace them.
21:10:59 <hackrilege> as it is a Monad it will eventually have join
21:11:02 <hackrilege> :t join
21:11:03 <Cale> and don't forget that you can always run the action separately from using the lens
21:11:03 <lambdabot> Monad m => m (m a) -> m a
21:11:14 <Cale> do r <- send $ listObjects "derp"
21:11:23 <hackrilege> giving us a Hangman (Hangman Char)
21:11:30 <Cale>    let contents = view lorsContents r
21:11:45 <Cale>    ... stuff involving contents ...
21:11:48 <Squarism> hackrilege, yep.. the type of command
21:12:02 <Squarism> hackrilege, or hmm
21:12:21 <tippenein> Cale: apparently I need to read more about lens'
21:12:31 <tippenein> I appreciate your setting me straight
21:12:32 <hackrilege> InGame [Maybe (Hangman a)] (Hangman a -> Hangman (Hangman a))
21:12:42 <hackrilege> is this really what you want?
21:12:53 <hackrilege> isnt this stretching the notion in an insane way?
21:13:04 <Cale> tippenein: Oh, I missed that you actually did try to use view there
21:13:07 <Squarism> actually in the game i will be consturcting i have different phases of the game
21:13:39 <Cale> tippenein: I think the problem there is just how the expression got associated
21:13:41 <tippenein> yeah, the type error makes sense now
21:13:48 <hackrilege> we dont at any point understand that there could be a game of hangman where we could supply hangmans as guesses?
21:14:45 <hackrilege> well, it works out even if it loses meaning... not sure what to suggest at this point!
21:14:59 <Squarism> to me : GameState deriving Monad[Phase]
21:15:20 <orion> Cale: I'm finding it difficult to make a newtype wrapper for my transformer because I am combining a non-MTL transformer in to the mix, and there's no instance for, say, MonadError provided by Coroutine. I am also having trouble creating an instance for it. Do you know the best way to continue?
21:15:56 <Squarism> Where Phase now is Hangman
21:16:16 <Squarism> hackrilege, or maybe im noobing out here
21:16:30 <hackrilege> yeah that syntax is meaningless to me
21:16:54 <nshepperd> Squarism, hackrilege see my example http://lpaste.net/160699
21:17:07 <hackrilege> you just use the final state
21:17:11 <Squarism> ok... well.. im a complete noob. If you just explained your take id be very glad
21:17:11 <hackrilege> you keep it using chars
21:17:22 <nshepperd> there, the monad parameter ("return type") is the type of Outcome = Win or Loss
21:18:00 <Cale> orion: which library is that? monad-coroutine?
21:18:18 <orion> yes
21:18:37 <Squarism> nshepperd, thanx man.. ill definiently digest that
21:18:49 <hackrilege> return is f
21:18:53 <nshepperd> so inside the definition you can use the special function 'ask' to get Hangman Char -- a 'degenerate' game of hangman that immediately "ends", returning whatever was guessed
21:19:25 * hackagebot agda-snippets-hakyll 0.1.2.0 - Literate Agda support using agda-snippets, for Hakyll pages.  https://hackage.haskell.org/package/agda-snippets-hakyll-0.1.2.0 (LiamOConnorDavis)
21:20:25 <Cale> orion: ... I'm scared to really suggest it, because it's way more complicated, but one answer might be "just use pipes", since it has instances.
21:20:58 <hackrilege> it isnt working like a game of hangman then... we should be joining together things of type (char -> Hangman) with something like a kliesli arrow
21:21:04 <nshepperd> it's basically a tree. at each node there is a choice of input character, and then child nodes for each possible character guessed, hence (Char -> Hangman a)
21:21:06 <hackrilege> :t (>=>)
21:21:07 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
21:21:15 <Cale> orion: I might try writing an instance of MonadError before going that far though :D
21:21:22 <Lovepon> I want to understand the Spock library, where should I start?
21:21:29 <nshepperd> the leaves of the tree are the outcome of the game
21:21:48 <hackrilege> :t foldr (>=>) return
21:21:49 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
21:22:27 <hackrilege> its broken
21:22:36 <hackrilege> not looking greatly monadic to me
21:22:47 <Lovepon> :t (<*>)
21:22:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:22:53 <Lovepon> Hmmm
21:23:01 <Lovepon> :t (<$>)
21:23:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:23:09 <Lovepon> =_+
21:23:48 <Lovepon> :f (\f -> (f <*>) . pure)
21:23:59 <Lovepon> Actually
21:24:09 <Lovepon> :t (($) <$>)
21:24:10 <lambdabot> Functor f => f (a -> b) -> f (a -> b)
21:24:13 <Squarism> hackrilege, nshepperd -- my idea is that turnbased games allways present a new interface to the players depending on their choices.. think InGameOrdinaryTurnStart args, InGameBattle, InGameSelectReward, InGameRandomAffaction
21:24:16 <Lovepon> Urgh, wtf
21:24:23 <Lovepon> :t (\f -> (f <*>) . pure)
21:24:24 <orion> Cale: I could always just stick with the type synonym as opposed to a newtype. It can't be that bad, right?
21:24:24 <lambdabot> Applicative f => f (a -> b) -> a -> f b
21:24:34 <Lovepon> gdi
21:24:39 <Cale> orion: Oh wait, what?
21:24:47 <Cale> orion: I thought you didn't have the instance at all
21:25:04 <Cale> orion: How does the type synonym help vs. the newtype?
21:25:14 <hackrilege> you cant make functors from synonyms or instantiate any paramatrised class
21:25:33 <Cale> hackrilege: It's a synonym for something which is already a functor
21:25:45 <Squarism> thats the long term goal - getting a mehtod of implementing such games
21:25:58 <orion> Cale: The type synonym is: type Handshake c d h r = Coroutine (Request ScrubbedBytes ScrubbedBytes) (StateT (HandshakeState c d h) (Except String)) r -- My goal is to convert that to a newtype. I can't do that because "deriving (MonadError String)" fails.
21:26:18 <nshepperd> Squarism: yup, you can do that with the tree monad approach
21:26:23 <Cale> orion: Does it implement MonadError String to begin with?
21:26:33 <Cale> orion: How are you using MonadError in the code?
21:26:43 <orion> Cale: I'm not using MonadError yet. I'
21:26:46 <Squarism> nshepperd, ok.. then ill thank you deeply for that and will inspect it right away
21:27:08 <Cale> orion: The problem is a more fundamental one, I think -- you don't actually *have* an instance of MonadError there.
21:27:08 <orion> Cale: My code currently exists without MonadError/Except. I am trying to bolt it on after the fact.
21:27:21 <hackrilege> baiscally we want to generate a function which uncurrys a list of guesses
21:27:49 <nshepperd> Squarism: basically, all those interfaces there would be variations upon `ask`, taking arguments representing whatever interface/information to display to the player, and then awaiting a response
21:28:20 <Cale> orion: This kind of thing can get a little hairy, when you have more than one monad transformer which involves higher order stuff
21:28:40 <Cale> orion: You need to work out a way for them to sensibly interact (and there may or may not be a way)
21:28:41 <hackrilege> seems like we should fold through the list of guesses with the hangman
21:29:06 <Cale> pipes somehow manages to have a lifting instance for MonadError though, so I wouldn't be too surprised to find out that it can be done
21:29:26 <nshepperd> Squarism: for instance 'askInBattle :: BattleInformation -> Hangman BattleAction'
21:29:30 * hackagebot directory 1.2.6.1 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.6.1 (Rufflewind)
21:29:32 <nshepperd> sort of thing
21:30:11 <orion> Cale: I see.
21:30:18 <hackrilege> i think the hangman is a partially applied kliesli arrow...
21:30:25 <hackrilege> can i get a seccond oppinion
21:30:47 <Cale> https://hackage.haskell.org/package/pipes-4.1.8/docs/src/Pipes-Internal.html#line-206
21:31:37 <Cale> orion: You'll end up with something that looks similar to that, but a little simpler hopefully, since there are only two cases to handle in Coroutine's case
21:32:54 <Cale> (It's not really all *that* similar, Coroutine has this arbitrary choice of functor s...)
21:33:03 <hackrilege> the function in a hangman is used to create a hangman from a guess. in doing so it produces a hangman producing function. just like
21:33:13 <hackrilege> :t return >=>
21:33:14 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
21:33:32 <hackrilege> :t (>=>) return
21:33:33 <lambdabot> Monad m => (b -> m c) -> b -> m c
21:34:30 <hackrilege> nope
21:34:30 * hackagebot composition-tree 0.2.0.2 - Composition trees for arbitrary monoids.  https://hackage.haskell.org/package/composition-tree-0.2.0.2 (LiamOConnorDavis)
21:34:50 <Cale> orion: But I think the idea's kind of similar? The computation which is the result of catchError is going to run the coroutine computation, and keep trying to catchError in the underlying monad.
21:34:51 <hackrilege> more like Monad m => (b -> m c)
21:35:17 <Squarism> nshepperd, cant wait to implement that =D
21:35:21 <orion> Cale: I'll give it a shot.
21:35:26 <hackrilege> question; what has type Monad m => (b -> m c) ->  (b -> m c)
21:36:23 <hackrilege> a partially applied kliesli arrow
21:36:55 <hackrilege> the construction of which seems to be the same as the construction of this Hangman datatype
21:37:06 <hackrilege> thats about as for as i can take the monads thing
21:37:12 <hackrilege> far*
21:38:52 <orion> Cale: ha, lots of language extensions are being enabled now.
21:49:31 * hackagebot patches-vector 0.1.5.2 - Patches (diffs) on vectors: composable, mergeable, and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.5.2 (LiamOConnorDavis)
21:54:31 * hackagebot dixi 0.6.9.1 - A wiki implemented with a firm theoretical foundation.  https://hackage.haskell.org/package/dixi-0.6.9.1 (LiamOConnorDavis)
22:25:45 <orion> hmm, given a function X -> Y, is there a way to change it to X -> Z if newtype Z = Z Y?
22:27:39 <johnw> compose it with Z
22:29:13 <orion> Doh! That was easy, thanks.
22:46:18 <tippenein> How can I inspect an [Object]
22:46:42 <tippenein> I'm not sure what it contains
22:47:24 <liste> tippenein: what Object?
22:47:49 <tippenein> it's the result of a request to s3
22:48:13 <liste> tippenein: is that Aeson's Value ?
22:48:50 <simpson> Hi! I know that Haskell normally doesn't need forward declarations, but I have a module that doesn't build as long as it's got some Template Haskell, because suddenly it matters in which order I've defined my types.
22:49:11 <simpson> Is this a known Template Haskell issue?
22:49:12 <tippenein> liste: I believe so
22:49:19 <cocreature> tippenein: you can just pattern match on it
22:49:33 * hackagebot digit 0.2.7 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.7 (TonyMorris)
22:49:40 <tippenein> cocreature: I don't know what keys it has
22:49:58 <liste> tippenein: have you tried to `show' it 
22:50:23 <tippenein> No instance for (MonadResource f0) arising from a use of ‘g’
22:50:27 <cocreature> simpson: I think so, at least I’ve encountered it several times.
22:50:41 <tippenein> g is the [Object]
22:51:08 <liste> tippenein: or is it a "m [Object]" for some Monad m ?
22:51:54 <tippenein>  :: (MonadResource f, MonadReader r f, MonadCatch f, HasEnv r) =>
22:51:54 <tippenein>      f [Object]
22:52:34 <tippenein> so.. it's a MonadResource
22:52:40 <cocreature> it would help if you could put a code snippet on lpaste
22:53:41 <lpaste> tippenein pasted “Object from s3 response” at http://lpaste.net/5229596615341244416
22:57:47 <cocreature> tippenein: I annotated it, with something that might work. not sure what the error you were getting means since there is no g in that snippet
23:04:33 * hackagebot automotive-cse 0.0.2.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.0.2.0 (KeiHibino)
23:06:17 <Squarism> if i define a type data MyData = MyData Int
23:06:33 <Squarism> how do i access the integer if i have an instance of MyData
23:06:41 <liste> Squarism: pattern matching
23:06:49 <liste> @let data MyData = MyData Int
23:06:50 <lambdabot>  Defined.
23:07:08 <liste> > let f (MyData i) = i + 1 in f (MyData 5)
23:07:09 <lambdabot>  6
23:08:09 <liste> Squarism: also, using the word "instance" here is confusing
23:08:54 <thomashartman> instead of instance, say value
23:09:07 <Squarism> ok
23:09:36 <thomashartman> squarism: here, instance is more like “implementation of.” an instance implements a class.  A class is like an interface definition.
23:10:03 <Squarism> ok.. will keep that in mind
23:10:13 <Squarism> lots to learn in a new language
23:10:21 <Squarism> or in THIS language
23:11:05 <ntnt> suppose I want Data.Map.Alter, but I want (new map, old value, new value)
23:11:12 <ntnt> is there a way to do that without making two extra calls to Data.Map.lookup ?
23:11:32 <ntnt> it seems like if we're calling Data.Map.alter, we already have access to the old value  and already computing new value, so why do we need to lookup both again
23:12:50 <toph> is A:Type (Type the type of all small types i guess) the same judgement as 'A type' that i've seen used elsewhere?
23:13:24 <thomashartman> nntp: is this almost what you want? https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Lazy.html#v:adjust
23:13:30 <thomashartman> I don’t see an alter method
23:14:34 * hackagebot QuickCheck-GenT 0.2.0 - A GenT monad transformer for QuickCheck library.  https://hackage.haskell.org/package/QuickCheck-GenT-0.2.0 (NikitaVolkov)
23:15:27 <thomashartman> oh, I see Data.Map.alter now.
23:17:56 <Squarism> what do people proficient in haskell work with? Its not often you see job postings on haskell. Still i cant imagine you are not in demand as this language requires some extra patiance 
23:18:26 <Squarism> admirable patience id say
23:18:34 <johnw> "work with" in what sense?
23:18:38 <johnw> whichever library is needed
23:18:57 <Squarism> i meant what fields so to speak
23:19:18 <johnw> finance and web development are pretty big
23:19:33 <Squarism> web, didnt expect that
23:23:08 <Zemyla> Well then. That was screwed up.
23:23:08 <zomg> as someone who works mainly with web dev, haskell isn't a popular choice mostly due to still being a bit obscure
23:23:08 <zomg> but haskell does have excellent libraries for web development, so many haskell devs are working with web dev, although in the grand scheme of things it might not be so common :)
23:23:08 <liste> and, of course, Haskell is a nice testbench for programming language research
23:23:27 <thomashartman> ntnt: I don’t see a way to do that, but I think it is one call to alter, and one call to lookup. not two calls to lookup.
23:23:33 <Zemyla> I wrote a different implementation of sort and was trying to compare it against the core one.
23:23:48 <Zemyla> I made a list, tried sorting it with the GHC sort, and ghci crashed.
23:25:51 <opqdonut> Zemyla: wow
23:26:02 <opqdonut> Zemyla: was it out of memory?
23:26:09 <Zemyla> No, not that I could see.
23:34:47 <monochrom> GHC sort trembled in front of yours :)
23:44:14 <Zemyla> Fuck, it's not stable, and doesn't seem to have much if any speed advantage.
23:49:49 * hackagebot directory 1.2.6.2 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.6.2 (Rufflewind)
23:50:06 <adarqui> i was going to ask a question but i figured it out. :f
23:54:50 * hackagebot automotive-cse 0.1.0.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.0.0 (KeiHibino)
