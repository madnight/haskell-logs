00:01:07 <Aliamondo> hey guys, had a rather simple question, but I just don't get up the logic behind it
00:01:24 <Pessimist> just ask
00:01:27 <Aliamondo>  have to write a list, which generates tuples of {month, day} and it has to work as expected (no {2, 30}, for example)
00:01:49 <Aliamondo> list comprehension*
00:02:11 <Aliamondo> i am doing it in erlang, but the logic should be the same anyways
00:02:47 <pavonia> Respecting leap years too?
00:03:00 <Aliamondo> just a for a leap year, yeah
00:03:23 <kadoban> What does that mean, you can assume it's a leap year you mean?
00:03:40 <Aliamondo> wait, i am wrong, it's for a year that's not leap
00:04:01 <nil02> argh accidentally loaded a 2GB file in R
00:04:03 <Aliamondo> so february only has 28 days and not 29
00:04:15 <kadoban> Okay, that sounds more likely. Well, a function   numOfDays :: Month -> Int  sounds like a good start
00:04:23 <nil02> levi GG come from bio... there's a few oddballs that make that trajectory. 
00:04:35 <nil02> levi but i notice he didn't even bother including a section on the sotu
00:05:09 <Aliamondo> I'd love to use that, but I guess I am not allowed to (assignment, gotta write the whole thing in  a single list comprehension)
00:05:22 <nil02> i think a couple people come from bioinformatics/data science because they see the potential and how good the haskell is, if only the ecosystem were there
00:05:53 * dsub is a bioinformatician
00:05:56 <Aliamondo> only hint is that we can use (lists:member() function of erlang, which is the same like 'elem')
00:06:14 <joof> nil02: I'd agree with that, there's only one way to make it good btw ;P
00:07:09 <nil02> joof i'm trying :P
00:07:12 <levi> nil02: I'm not sure what you mean by "a section on the sotu"?
00:07:45 <nil02> https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
00:08:39 <nil02> i meant he didn't even bother putting a "bioinformatics" section in there
00:09:11 <levi> nil02: Oh, he notes his bioinformatics experience in Numerical programming.
00:09:34 <Aliamondo> kadoban: hm, thanks anyways, i guess. gotta search for ideas elsewhere :/
00:10:15 <nil02> levi i know, anyway doesn't matter much, i think that aspect of the ecosystem is bad although i'd like to see it get better
00:11:08 <levi> He's got his actual protein structure search thing in github: https://github.com/Gabriel439/suns-search
00:11:24 <nil02> that's cool
00:11:41 <nil02> need more basic stuff though. like loading a sequence alignment =P
00:12:06 <nil02> there's certain things where haskell has the potential to leapfrog python/R
00:12:28 <nil02> like consuming/integrating multiple datasets
00:13:17 <levi> I know next to nothing about bioinformatics software, so I'll take your word for it. :)
00:17:23 <joof> out of curiosity, do you actually need to do the sequence alignment or just load some dataset?
00:17:54 <Gurkenglas> Can finding what is expressible in terms of elements from a given set and a given binary operation be expressed as a graph problem?
00:17:59 <joof> My knowledge of the field is currently 1 article of wikipedia and having played with data before, but I get bored sometimes :P
00:20:23 <Jinxit> is it normal to feel somewhat lost while reading Awodey's CT? :D
00:21:59 <Jinxit> just got to free categories, and as a CS guy I'm used to abstractions but these are pretty difficult to grasp
00:23:45 <nil02> joof well it'd be handy to have both. but there's mature C++ tooling around alignments so for now
00:24:00 <nil02> i'd be happy to just be able to load and poke the data
00:27:16 <Aliamondo> let me try my luck again :)
00:28:39 <Aliamondo> how can you create lists where each iteration of the second variable is not of the same size (using list comprehensions)?
00:29:13 <Aliamondo> something like [(1,a), (1,b), (2,a), (3,a), (3,b), (3,c)]
00:32:09 <joof> Aliamondo: http://erlang.org/doc/programming_examples/list_comprehensions.html
00:32:16 <joof> you said erlang right?
00:32:23 <joof> the second element of the tuple is a list
00:32:48 <Aliamondo> it doesn't matter the language and that link isn't helpful to what i want
00:35:03 <joof> then (X, {Y}} | X <- [1 .. 12], Y <- {1 ... 31} if X is whatever
00:35:50 <Aliamondo> but won't this generate (2, 31), too?
00:36:03 <joof> thats why you have filters
00:36:32 <Gurkenglas> Aliamondo, where'd that example cone from? If it is the result of a function, what are the parameters? What's the function's type?
00:36:37 <Gurkenglas> -cone+come
00:36:59 <Aliamondo> Gurkenglas: i typed it by hand
00:37:22 <Gurkenglas> What would you have liked to type instead that would give you that
00:38:07 <Gurkenglas> Oh, you said more before your "let me try my luck again"
00:39:02 <joof> X = 2 {1 .. 28}, X % 2 = 0 & X != 2 {1 .. 31} or {1 .. X} because why not
00:39:38 <Gurkenglas> > [(month, day) | (month, daycount) <- [("January", 31), ("February", 28), ("March", 31)], day <- [1..daycount]] -- You'll have to put the rest of the months with their counts too
00:39:40 <lambdabot>  [("January",1),("January",2),("January",3),("January",4),("January",5),("Jan...
00:40:31 <joof> or do that and have a generator that goes up to their dayccount
00:40:48 <Gurkenglas> "have a generator"?
00:41:16 <joof> sorry, not being haskelly
00:41:42 <Aliamondo> that solution feels like I type the whole thing by hand and there is pretty much no programming. maybe I am just being picky
00:41:51 <Gurkenglas> You mean a function of type String -> Int that returns the daycount for each month's name? How would you define that, if not by writing each name and each daycount anyway :D
00:42:08 <Aliamondo> but joof's solution is interesting
00:42:11 <Gurkenglas> Aliamondo, you want a library that already knows the counts of each month for you?
00:42:21 <Aliamondo> no, just a line
00:42:26 <Aliamondo> of code
00:42:27 <joof> (month, daycount) -> (month, {set of days})
00:44:21 <rydgel> what about leap years?
00:44:32 <Aliamondo> don't have to worry about that part
00:44:45 <ahihi> you can come up with a convoluted formula for month -> number of days, but it doesn't seem worthwhile to me
00:46:49 <suppi> just write the months and days. any formula you may find will not be meaningful
00:47:19 <suppi> if you really want a formula, https://cmcenroe.me/2014/12/05/days-in-month-formula.html
00:47:29 <joof> it's not, but he said it had to be erlang and use their list comprehension. 
00:48:04 <rydgel> Aliamondo: try this, then use it inside a list-comprehension https://cmcenroe.me/2014/12/05/days-in-month-formula.html
00:48:30 <rydgel> woop already posted
00:48:41 <suppi> ;)
00:48:42 <Aliamondo> yeah, i am reading
00:48:49 <joof> which involves a generator (some base list) and higher order functions map, filter, and such
00:48:54 <Aliamondo> interesting stuff, actually, thanks
00:49:03 <suppi> joof, what is a generator?
00:49:12 <joof> https://en.wikipedia.org/wiki/Generator_(computer_programming)#Haskell
00:49:16 <bollu> hey guys
00:49:22 <suppi> interesting, but bad programming method :P
00:49:29 <ahihi> "2014-12-06: Hello, Internet. This is tongue-in-cheek. Why would anyone use this?"
00:49:33 <ahihi> :)
00:49:54 <Aliamondo> yeah, i noticed that. I was actually doing the if else statement in the comprehension
00:49:56 <bollu> this is silly, but I'm not able to setup Yesod's develmain for insta-reload with stack
00:49:57 <joof> semicoroutines?
00:50:05 <bollu> I'm able to load the DevelMain.hs into the stack ghci
00:50:12 <suppi> joof, so basically a list of elements?
00:50:13 <bollu> but it doesn't recompile on changing my .hs files
00:50:29 <bollu> I miss my edit-file-auto-recompile workflow from every other server side framework
00:50:36 <bollu> (flask, django, node..)
00:50:37 <joof> more or less, typically you have some way to get those elements
00:50:42 <bollu> any help would be greatly appreciated
00:53:06 <bollu> plus, stack ghci lags slightly
00:54:34 * hackagebot hpack 0.12.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.12.0 (SimonHengel)
00:57:42 <joof> Aliamondo: For clarity, you should probably still treat that as a piecewise function; masking it like they did is an even uglier hack
00:58:27 <Aliamondo> joof: doing something like if (M rem 2 == 0) and (M =/= 2) -> 30
00:58:38 <joof> yeah
00:58:54 <joof> but switching after 8 X_X
00:59:34 <joof> because 7 = 31 & 8 - 31
00:59:43 <joof> 8 = 31*
01:00:06 <Aliamondo> oh wait, true. forgot :D
01:14:42 * hackagebot nanovg 0.2.0.0 - Haskell bindings for nanovg  https://hackage.haskell.org/package/nanovg-0.2.0.0 (cocreature)
01:14:44 * hackagebot config-manager 0.3.0.0 - Configuration management  https://hackage.haskell.org/package/config-manager-0.3.0.0 (guyonvarch)
01:21:42 <cdtdev> Wow, have you guys taken a look at the Wolfram language?
01:29:52 <cocreature> What have I done wrong if the source links in my haddocks don’t work? I thought running cabal haddock --for-hackage --hyperlink-source should work
01:37:32 <Aliamondo> joof: completed, thanks again. I had a problem with IF statements, but erlang works differently to other languages, so I had to find a workaround
01:37:45 <cocreature> ah using the lens upload script seems to have worked for some reason
01:38:39 <Aliamondo> joof: i did something like if month is 4, 6, 9, 11 -> 30 days, otherwise: if month is 2 -> 28, if nothing else was true -> 31 days
01:41:58 <sgronblo> Trying to get startd with creating a simple Snap web app, i ran snap init inside an empty dir, then I tried running stack init but it seems to not be able to find a resolver for the generated cabal file
01:42:17 <sgronblo> Do I have to manually start messing around with setting the dependencies now?
01:45:42 <rydgel> sgronblo: did you try stack init --solver
01:56:42 <Wizek> Might have any one of you encountered System.Process.terminateProcess not terminating processes, even when followed by a `_ <- waitForProcess p`?
02:00:12 <Gurkenglas> unfoldr seems to be the essence of producing []. foldr seems to be the essence of consuming []. Can you express map id in terms of foldr _and_ unfoldr?
02:00:25 <Gurkenglas> Or perhaps map
02:01:48 <ksj> Gurkenglas, what do you mean by map id?
02:02:04 <Gurkenglas> I mean a trivial fold/unfold of a list into itself
02:02:24 <cocreature> Gurkenglas: http://lpaste.net/159267
02:02:26 <Gurkenglas> But I guess requiring map instead of map id makes my request less ambigous
02:02:36 <cocreature> foldr is obviously possible
02:02:49 <cocreature> eh I forgot to copy the ) at the end
02:02:53 <Gurkenglas> yea unfoldr uncons is the way thats biased to one side
02:03:16 <Gurkenglas> I was hoping for something that uses foldr and unfoldr and thus doesn't have to use list's constructors/deconstructors
02:03:37 <cocreature> oh I missed the _and_ part
02:07:21 <rydgel> > foldr (:) [] "test"
02:07:23 <lambdabot>  "test"
02:07:26 <rydgel> like this?
02:08:21 <Gurkenglas> Right, that is the exact opposite of unfoldr uncons, and also biased to one side
02:08:31 <Gurkenglas> I want one that *doesn't* use list constructors/deconstructors
02:08:47 <cocreature> what do you mean by “biased to one side”?
02:08:58 <Gurkenglas> biased to consuming/producing
02:11:41 <cocreature> I don’t think combining foldr and unfoldr makes sense in this case since both take functions that are responsible for a single step but foldr/unfoldr operate/create the complete list
02:17:58 <rydgel> yeah
02:18:56 <apsod> Gurkenglas: Are you familiear with recursion schemes? 
02:19:06 <Gurkenglas> heard of em
02:19:28 <Gurkenglas> cocreature, by that reasoning constructing foldl from foldr is also beyond?
02:19:29 <apsod> It seems what you're looking for is similar to a hylomorphism, minus the whole not using constructors/deconstructors thing 
02:19:37 <numee> Gurkenglas: defining hylomorphism in terms of foldr and foldl is mentioned in the banana paper iirc
02:19:47 * hackagebot hasql-transaction 0.4.4.1 - A composable abstraction over the retryable transactions for Hasql  https://hackage.haskell.org/package/hasql-transaction-0.4.4.1 (NikitaVolkov)
02:19:48 <Gurkenglas> *and unfoldr?
02:19:58 <numee> Gurkenglas: oops, yes
02:20:03 <cocreature> Gurkenglas: fair point
02:22:30 <sgronblo> Whats the best way to do npm install --save for stack?
02:23:04 <cocreature> sgronblo: add it you your cabal file and run 'stack build'
02:26:21 <tdammers> or just have a stack build --file-watch running, then just adding it to the cabal file triggers a build :D
02:29:35 <oibudda> hello
02:29:48 * hackagebot git-vogue 0.2.1.1 - A framework for pre-commit checks.  https://hackage.haskell.org/package/git-vogue-0.2.1.1 (oswynb)
02:29:48 <ph88^> are >> and >>= both called bind ?
02:29:55 <oibudda> what does "==>" do? 
02:30:25 <ph88^> oibudda, http://hayoo.fh-wedel.de/?query=%3D%3D%3E
02:30:45 <oibudda> ty
02:32:28 <cocreature> ph88^: I don’t I don’t think anybody calls >> bind
02:33:08 <ph88^> what is >> called ?
02:33:50 <cocreature> not sure if there is a name for it
02:35:52 <sgronblo> cocreature: yeah but im wondering what the best way to add the dep to the cabal file is? do people like snoop around on hackage to find the newest version and then just put a version range that includes that version or?
02:35:59 <kadoban> I call it "and then" internally I guess.
02:36:42 <cocreature> sgronblo: that’s what I do :) or I just leave out the bounds for personal projects since the snapshot locks it down
02:38:26 <sgronblo> cocreature: ah i dont even need to worry about the bounds usually
02:38:43 <cocreature> sgronblo: bounds become important if you want to publish to hackage
02:38:48 <rydgel> ph88^: it's like an invisible semicolon from an imperative language
02:38:58 <cocreature> but there is an option that adds the bounds when uploading
02:39:17 <ph88^> invisible ?
02:40:22 <rydgel> ph88^: not invisible actually mb
02:40:46 <sgronblo> cocreature: ah right, thanks!
02:41:18 <rydgel> ph88^: it's like >>=, but you are discarding the return of the first result
02:41:41 <ph88^> ye
02:41:51 <rydgel> ph88^: same as <*> and *>
02:42:07 <mikail_> Hi, please can I get feedback on this code snippet: http://lpaste.net/159266. I am trying to determine what is the best practice in Haskell for that type of situation.
02:49:40 <opqdonut> mikail_: that's an ok solution if you have Prices, Rates etc. moving around the system
02:49:52 <opqdonut> mikail_: however if they're always bundled into a Foo, why not use record syntax?
02:50:19 <opqdonut> mikail_: like "data Foo = Foo {getPrice :: Decimal, getRate :: Decimal, getVolume :: Decimal, getDiscount :: Decimal}
02:50:22 <opqdonut> "
02:50:32 <mikail_> thanks opqdonut - I don't tend to use the record syntax because I fear I might end up with the know record syntax issues
02:50:49 <mikail_> the Foo type will be passed around into various functions
02:50:55 <mikail_> but not the Price, Rates etc
02:51:06 <mikail_> i just wanted something that would self-describe
02:51:16 <mikail_> rather than just having Decimal, Decimal, ....
02:59:49 * hackagebot cndict 0.7.3 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.7.3 (DavidHimmelstrup)
03:29:50 * hackagebot shake-language-c 0.8.6 - Utilities for cross-compiling with Shake  https://hackage.haskell.org/package/shake-language-c-0.8.6 (StefanKersten)
03:39:52 <Amadiro> Evening. I'm trying to install cabal on a system with GHC 7.0.4. Does anybody know what the newest cabal is that will work with that old of a GHC version? The latest one fails with "Distribution/License.hs:2:14: Unsupported extension: DeriveGeneric".
03:51:59 <bergmark> Amadiro: can't you get a binary?
03:59:52 * hackagebot ginger 0.2.1.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.2.1.0 (TobiasDammers)
04:02:55 <bergmark> Amadiro: anyway, see http://matrix.hackage.haskell.org/package/Cabal
04:09:29 <Amadiro> bergmark, thanks. I'll look into binary distributions.
04:23:36 <AfC> Amadiro: don't worry about the version of GHC the system ships; download the `stack` static executable and it will both self-upgrade & install an appropriate compiler.
04:25:21 <Amadiro> AfC, "stack"? http://docs.haskellstack.org/en/stable/README/ this one? Never heard of it before.
04:25:41 <Amadiro> looks great though
04:27:32 <AfC> Amadiro:  http://docs.haskellstack.org/en/stable/install_and_upgrade/#linux yes (assuming you're running something ancient; if you're actually running current Fedora or Ubuntu or Arch or whatever then there are distro specific instructions.
04:27:50 <Amadiro> I'm running something ancient AND I don't have root :)
04:28:01 <AfC> That's fine then
04:35:41 <tdammers> stack works fine without root
04:36:00 <tdammers> just because npm gets this horribly wrong doesn't mean thingshave to be like that
04:36:29 <ksj> it's just a sandbox for your code so it shouldn't require root
04:36:40 <ksj> tdammers, seriously? does npm require root?
04:37:22 <tdammers> ksj: not per se, but you get to choose between "install project-local" and "install globally for allusers
04:37:48 <tdammers> but there's no "install for all projects, but only this user"
04:38:55 <ksj> tdammers, hot damn
04:40:58 <tdammers> inorite
04:41:25 <tdammers> and they say "we have the dependency / package management thing covered", bleh
04:44:32 <Gurkenglas> For n>k, can you apply n updates to a vector of length k in time O(n)?
04:47:13 <Amadiro> AfC, works like a charm, thanks!
04:51:01 <maerwald> there was a site on ghc.haskell.org which sort of explains the GHC architecture, but I can't find it anymore
04:51:41 <isBEKaml> I think the AOSA book also explains (sort of) about GHC
04:51:59 <maerwald> that's not what I'm looking for though
04:52:17 <isBEKaml> http://aosabook.org/en/ghc.html
04:53:02 <isBEKaml> maerwald: perhaps this? https://ghc.haskell.org/trac/ghc/wiki/Commentary
05:13:01 <apsod> Gurkenglas: The functions in Data.Vector do it in time O(n+k) right? so yes.
05:13:29 <Gurkenglas> Oh there, "bulk updates"
05:21:19 <ertes-t6jQe7qn> is there a way to instruct GHCi to compile a module to opcode instead of bytecode?
05:22:41 <ertes-t6jQe7qn> i'd like to do rapid prototyping with expensive code, and bytecode is too slow
05:23:27 <ClaudiusMaximus> maybe :set -fobject-code
05:23:35 <ggVGc> if only we had hot-code reloading working flawlessly..
05:27:57 <rydgel> ggVGc: yes
05:28:02 <rydgel> I would love that
05:29:00 <tobiasBora> Hello,
05:29:19 <tobiasBora> I would like to developp in Haskell some program based on Neural Network.
05:29:29 <tobiasBora> I have 3 questions :
05:30:32 <tobiasBora> - Is there a good *and efficient* library to deal with neural network ? (I saw AI.HNN.FF.Network, but don't know if it's efficient)
05:32:25 <tobiasBora> - Is there an efficient way to code Neural Network in fonctionnal programming
05:33:13 <ertes-t6jQe7qn> tobiasBora: i'm working on a machine learning framework with efficient feed-forward neural networks (and potentially RBMs in the future, if i find a need for them)
05:33:48 <tobiasBora> - Can I expect interesting results (I mean efficient) with Haskell or should I use C++ or something like that ?
05:34:08 <ertes-t6jQe7qn> tobiasBora: it's not in a usable state right now…  however, you can check out my old library called 'instinct' on hackage, which has very efficient neural networks
05:34:39 <ertes-t6jQe7qn> you may need to change bits and pieces for it to compile on modern GHC, though
05:34:50 <tobiasBora> ertes-t6jQe7qn: Did you do some benchmark comparing it with others C++ libraries ?
05:34:56 <ertes-t6jQe7qn> (most notably the 'primitive' library has slightly changed, and it's pre-AMP code)
05:35:39 <ertes-t6jQe7qn> tobiasBora: FANN is still faster than my code, mainly because i used a laziness trick to compute activations…  the new framework does no longer do that and should equal FANN efficiency
05:37:39 <rydgel> ertes: nice promising stuff
05:37:47 <tobiasBora> ertes-t6jQe7qn: Really ? Nice ! When it will become available I am very intersted in it !
05:38:58 <ertes> tobiasBora: it's currently a spare time project, so i'll make a rather reserved estimation:  2-3 weeks
05:39:12 <ertes> could become usable in anything from a few days to a few weeks
05:40:01 <tobiasBora> ertes: Ok... Do you have a github like link ?
05:40:04 <phaer> I am still new to haskell and I am asking myself if i can use a type variable with a class constraint like "ToJSON" instead of "Int" in "data Command = GetProperty Property | SetProperty Property Int". Any hints?
05:40:23 <rydgel> tobiasBora: don't rush ertes he needs to make a new FRP lib too. (jk)
05:40:49 <ertes> tobiasBora: as soon as it becomes usable, you'll find it at <http://hub.darcs.net/esz/ml>
05:41:06 <ertes> rydgel: the FRP lib has the lowest priority right now =)
05:41:15 <Athas> phaer: put the class constraint on the functions, not the data type.
05:41:46 <Athas> That is:
05:41:46 <Athas> data Command a = GetProperty Property | SetProperty Property a
05:41:47 <Athas> frobThatCommand :: ToJSON a => Command a -> Whatever
05:41:52 <ertes> phaer: data Command a = GetProperty Property | SetProperty Property a
05:41:57 <ertes> hehe
05:49:16 <phaer> Athas, ertes: Thanks. If I do that, ghc tells me to change ":: Command" in other type declarations to ":: Command a". That did not seem to be necessary with the concrete type Int and i don't really understand why. Tipps for sources on that topic?
05:49:53 <Athas> phaer: well, it's because 'Command' is no longer a type but a type constructor.  Kind of like a function at the type level.  'Command a' is a type (if 'a' is a type), though.
05:50:11 <Athas> If you want a type to be polymorphic/parametrised, you have to mention the type parameters.
05:58:12 <tobiasBora> ertes: darcs ? ml ? You are coding in Ocaml ? ^^
05:58:59 <rydgel> ml stands for machine learning I suppose
06:01:09 <tobiasBora> Hum good idea ^^
06:03:43 <Jinxit> ertes: going the CuDNN route or just CPU?
06:09:56 * hackagebot io-machine 0.1.0.0 - Easy I/O model to learn IO monad  https://hackage.haskell.org/package/io-machine-0.1.0.0 (YoshikuniJujo)
06:13:54 <ertes> tobiasBora: no, the library is called "ml" =)
06:13:58 <ertes> as in machine learning
06:14:19 <ertes> Jinxit: just CPU for now
06:15:00 <ertes> (i'm assuming that "CuDNN" is something GPU-related or some other type of acceleration)
06:15:06 <Jinxit> CPU neural nets are kinda pointless :v
06:15:08 <Jinxit> yeah
06:16:14 <ertes> Jinxit: i'm not doing "neural nets"…  i'm doing models by composition…  my personal use case is mostly linear and logistic regression
06:20:07 <ertes> ClaudiusMaximus: -fobject-code seems to work, thanks!
06:22:41 <anax> After an upgrade of haskell-mode a week ago I get the message "async" instead of type information in the mode line
06:24:57 * hackagebot lackey 0.3.0 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-0.3.0 (fozworth)
06:30:35 <tdammers> anyone know if it's possible to have pandoc detect headings in .docx input?
06:30:50 <ertes> when using GHCi with -fobject-code, is there a way to make it *always* recompile (or at least type-check) the module, even if it didn't change?  background: when i do C-c C-l in haskell-mode two times in a row, all warning markers disappear, because of course the already-compiled module loads without warnings
06:31:48 <tdammers> -Werror?
06:32:07 <ertes> tdammers: that would severely interfere with prototyping
06:32:20 <tdammers> well
06:32:24 <tdammers> something about cake and eating
06:32:41 <tdammers> but anyway, :reload?
06:32:45 <bernalex> sounds like the more appropriate thing to do is make haskell-mode behave like you want, rather than making ghc compile things it's already compiled.
06:32:57 <tdammers> ^ that, too
06:33:00 <opqdonut> there's -fforce-recomp or something like that
06:33:04 <opqdonut> oh right ghci
06:33:05 <opqdonut> nevermind
06:33:58 <ertes> tdammers: regarding your question: make a small markdown file with headings and see if it goes to docx and back…  however, most word users do ad-hoc formatting, so it may not help, even if it does
06:34:30 <ertes> opqdonut: that actually works in GHCi, thanks =)
06:34:36 <opqdonut> oh, cool
06:34:45 <ertes> and i understand it's just a hack…  it's only for the rare case when i actually need -fobject-code
06:35:23 <tdammers> well, what I'd want, ideally, is for pandoc to pick up the "Heading 1" through "Heading 3" (or however many there are) paragraph types and render them as h1 through h3
06:38:21 <ertes> tdammers: there are people who actually do serious writing with word, so just search for "word style sheet example" on your favourite search engine and try it =)
06:39:01 <tdammers> the question isn't "how do I make headings in Word"
06:39:21 <tdammers> the question is, "given an arbitrary Word document, how do I get pandoc to detect headings as such"
06:39:38 <ertes> tdammers: i meant: download any of the example .docx files and see if pandoc handles it properly
06:43:18 <ertes> tdammers: another useful indicator, as noted above, is whether pandoc can go from markdown to docx and back without structural information
06:43:27 <ertes> s/without/without losing/
06:43:45 <tdammers> yeah
06:43:59 <tdammers> well, an example document I just downloaded doesn't really render all that well either
06:44:39 <ertes> better test it on multiple examples…  people write offensively bad documents (and i can't even blame them)
06:45:30 <ertes> note: if you need to cooperate with someone using word, it may be helpful that word can actually produce HTML
07:04:58 * hackagebot process-streaming 0.9.1.1 - Streaming interface to system processes.  https://hackage.haskell.org/package/process-streaming-0.9.1.1 (DanielDiazCarrete)
07:07:45 <fnord___> hi, I'm using Haskell on NixOS with stack and am trying to figure out how to generate haddock for all my local projects
07:08:34 <fnord___> Someone had success with this?
07:12:16 <bergmark> fnord___: isn't `stack haddock' enough?
07:29:02 <runeks> Is there a simple way to serialize+send / recv+deserialize on a Socket? Such that I can run a Binary "Get a"/"Put" on a socket?
07:29:57 <runeks> As far as I can see a Socket is basically a lazily evaluated ByteString, where each recv takes a chunk.
07:30:14 <runeks> So I'm thinking there must be an obvious trick I'm missing.
07:30:29 <runeks> With Binary working on lazy ByteStrings...
07:31:17 <runeks> Sending is easy: runGet + send. But I'm not sure about receiving, where the number of bytes to read is encoded in the Binary.Get monad.
07:31:33 <runeks> *runPut+send
07:32:28 <Enigmagic> runeks: http://hackage.haskell.org/package/binary-0.8.2.1/docs/Data-Binary-Get.html#v:runGetIncremental
07:34:19 <runeks> Enigmagic: Thank you. Looks like something I can use.
07:34:53 <runeks> Although I'd expect it to be so generic that someone might have written the code already...
07:36:49 <Enigmagic> runeks: there are higher level packages for this sort of thing... conduit-extra and pipes-binary both offer ways of hooking up a Get instance to a socket
07:37:50 <Enigmagic> err, not conduit-extra
07:38:25 <Enigmagic> binary-conduit
07:52:58 <ertes> runeks: if your protocol is message-oriented, you should use a stream abstraction alongside the incremental parser (pipes-group is exceptionally great at this, but has a learning curve)
07:53:28 <ertes> or if the individual messages are very small, don't bother and just split the stream into message chunks and parse each one individually…  any streaming abstraction is sufficient for that
07:54:34 <runeks> ertes: It's really just for research right now, for testing  a library I'm writing. That's why I'm hesitant to spend too much time on it.
07:55:19 <runeks> But it looks like it may be the easiest solution anyway
07:55:31 <ertes> runeks: you should at least use a streaming abstraction, and they are easy to get into
07:55:40 <runeks> ertes: What do you mean by splitting the stream into message chunks?
07:55:42 <ertes> only pipes-group has a real learning curve
07:55:48 <runeks> ertes: I think I will
07:56:12 <runeks> The messages are fairly small. No more than 50-ish bytes, tops.
07:57:33 <lapdog> hey, is there an easy way of using the iterator of a map as an argument to the function i'm applying? something like this: fmap (increaseAndApply (x+iterator)) [1..]
07:57:56 <dmj> > scanl (+) 0 [1..10]
07:57:58 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
07:58:32 <ertes> runeks: the socket's input starts as an unstructured stream of bytestrings (likely network-packet-sized)…  you use a pipe/conduit to transform that into a stream of bytestrings that are message-sized, then you use a pipe/conduit to parse each…  these two steps may be easiest to write as a single step
07:59:16 <ertes> runeks: in the pipes-group approach, you transform the unstructured stream into a delimited stream, breaking bytestrings along the way if necessary…  then you apply a parser to each substream
07:59:29 <runeks> ertes: Ah, yes. By prepending the length to each message that should be fairly easy.
07:59:54 <ertes> if the length follows from the message itself in a context-free way, you shouldn't do that
08:00:10 <ertes> length fields make your grammar context-sensitive
08:00:24 <runeks> ertes: Then how do a produce a stream of message-sized bytestrings, if I don't know the message size?
08:00:35 <runeks> ertes: But I agree. I'd rather not.
08:00:37 <ertes> how do you parse?
08:00:38 <dmj> > take 10 $ scanl1 (+) [1..]
08:00:39 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
08:00:41 <dmj> lapdog: ^
08:00:53 <runeks> ertes: Binary.Get monad
08:01:06 <ertes> runeks: the same way you parse…  as said, parsing and chunking may be the same step =)
08:01:27 <runeks> ertes: OK. I will see if I can get pipes-binary up and running. Thanks!
08:01:30 <ertes> if Get gives you leftover strings, you can totally just apply it
08:01:42 <ertes> and in that case you won't even need pipes-binary…  just pipes
08:02:07 <lapdog> okay, ty
08:02:59 <ertes> runeks: i don't think you will benefit from pipes-group here; all you need is pipes
08:03:41 <ertes> or conduit or whatever…  they all work
08:05:43 <runeks> ertes: I don't see how I can use my Get parser directly for parsing without pipes-binary
08:08:26 <ertes> runeks: first you start with a network packet reader:  input :: Producer ByteString M ()
08:08:30 <ertes> where M is any MonadIO
08:08:42 <ertes> pipes-network should give you that one for free
08:09:40 <ertes> then you write:  toMessages :: (Monad m) => Pipe ByteString Message m r
08:10:14 * hackagebot d-bus 0.1.3.4 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.3.4 (PhilippBalzarek)
08:10:29 <ertes> if binary has an incremental parser, you can just 'await' new bytestrings and feed it to that one, until the parser finishes and gives you a message (that you 'yield') as well as a leftover string that you use to start the next parse
08:11:26 <ertes> if it doesn't have an incremental parser, you will need to concatenate bytestrings, until the parser succeeds and gives you a full message…  this is very ugly, and you should avoid it
08:11:58 <ertes> runeks: btw, see the network-transport library…  it might already do what you're currently doing by hand
08:12:00 <runeks> ertes: Alright. I think I get it now
08:12:16 <runeks> ertes: Even cooler. I will look at that
08:30:15 * hackagebot protolude 0.1.0 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.0 (sdiehl)
08:49:11 <suppi> i'm thinking about trying a bit of spock but the types kinda scares me a little
08:59:12 <sm> how so ?
09:05:21 <tippenein_> what is the state of the AWS tooling ?
09:06:35 <bergmark> tippenein_: check out the aws package and the amazonka-*
09:07:42 <orion> What are some of the expressions that create scope? Functions, case expressions, ...
09:08:28 <ertes> orion: every binder:  lambda, forall
09:08:34 <bergmark> orion: let/where, and <- in do notation (which is just sugar for a lambda)
09:09:42 <bergmark> orion: and some extensions, RecordWildCards, ViewPatterns, NamedFieldPuns, Arrows
09:10:37 <suppi> sm, was that addressed to me?
09:25:28 <orion> I was bit by the skolem error last night. After discussing it with Cale, I finally managed to get the code to do exactly what I want: http://lpaste.net/850561673893773312 -- However, I'm concerned that I'm accomplishing my goal in a really roundabout fashion. Is there a more idiomatic way to write this code?
09:27:30 <tippenein_> bergmark: I guess I meant, "how mature are they"
09:28:44 <sm> suppi: yes
09:29:17 <sm> perhaps you can just follow examples, build stuff and the types will click ?
09:29:21 <suppi> sm, for example: `data Path as :: [*] -> *` , `(~) [*] a ([] *) => IsString (Path a)`
09:29:27 <sm> aieee
09:29:32 <sm> my eyes
09:30:22 <suppi> sm, you asked :L
09:30:27 <Heather> how to debug haskell application with access violation crush on windows?
09:31:12 <Heather> not sure but maybe it's related network package
09:31:21 <Heather> or ghc...
10:05:45 <mascherato> if I have a tuple (f, a) where f is a function an a is the parameter, how can I get (f a)? (ie applying the function), is deconstructing the only way?
10:06:15 <puregreen> :t uncurry ($)
10:06:16 <lambdabot> (a -> c, a) -> c
10:08:06 <mascherato> thanks puregreen 
10:20:18 * hackagebot reactivity 0.3.0.0 - An alternate implementation of push-pull FRP.  https://hackage.haskell.org/package/reactivity-0.3.0.0 (JamesCandy)
10:24:01 <Heather> I've got putStrLn "A" and putStrLn "B" and after showing A my application is crushing... where should I go with this XD
10:24:50 <bergmark> Heather: does it print an exception?
10:24:59 <Heather> I even used to add prints to initWinSock.c from network package to check whether it was caused by previous calls
10:25:09 <Heather> bergmark, Access Violation
10:25:21 <Heather> Lazy and purely functional access violation :P
10:25:49 <Heather> so basically it's OS exception and can't be detected on app level :S
10:26:01 <Heather> without having anything with debug information I guess
10:26:34 <Heather> and yes - can't reproduce this bug on another windows system...
10:26:52 <bergmark> can you use gdb?
10:27:41 <Heather> bergmark I'm on windows
10:27:51 <Heather> bergmark on Linux I can't reproduce it too
10:29:44 <bergmark> is there a gdb alternative on windows? :)
10:30:15 <bergmark> i have the fortune of never building stuff for windows
10:30:17 <Heather> bergmark visual studio
10:30:27 <Heather> bergmark but I need debug info builds
10:30:52 <Heather> e.g. msvc and friends
10:34:28 <Heather> seems like Win32 package calls...
10:35:52 <Heather> considered harmful :S
10:40:31 * hackagebot shake-language-c 0.9.0 - Utilities for cross-compiling with Shake  https://hackage.haskell.org/package/shake-language-c-0.9.0 (StefanKersten)
10:45:07 <mizu_no_oto> How does ad work with Data.Matrix?  Do you need to restrict yourself to just using the operations from Num, or is it possible to map functions over the elements of a matrix and have that work?
10:45:16 <mizu_no_oto> ping edwardk
10:45:31 * hackagebot ConcurrentUtils 0.4.4.0 - Concurrent utilities  https://hackage.haskell.org/package/ConcurrentUtils-0.4.4.0 (JamesCandy)
10:55:43 <marchelzo> hi. quite often when I'm trying to think of how I might solve a problem using Haskell, I find myself gravitating towards State and lens. It seems strange, though, since it actively goes against the "functional style" that Haskell seems to encourage.
10:57:07 <quchen> In Haddock, how do you link to things not imported in the module again?
10:57:28 <quchen> For example, I don't have 'Text' imported in my module, but I'd like to provide a link to it in a remark.
10:57:35 <dmj-tls> marchelzo: still functional, just wearing imperative clothing :]
10:57:59 <marchelzo> it might as well be imperative, though.
10:58:33 <geekosaur> quchen, fully qualified name
10:59:37 <quchen> geekosaur: Oh. This rings a bell. I thought there was some special --$ syntax.
11:00:02 <dmj-tls> marchelzo: \s -> (a,s) is pretty functional, same with get/set (a -> b) (a -> b -> a) 
11:00:57 <marchelzo> yes, lens is functional, but the lens combinators that you use in the State monad, while functional underneath, might as well be imperative
11:01:41 <Hijiri> marchelzo: it depends on the problem you are solving
11:02:19 <dmj-tls> marchelzo: sure, would still say you need to understand the functional implementation to use it effectively
11:02:52 <Zekka|Sigfig> I think this just exposes terminology problems — some problems are easier to solve when you talkabout them in terms of “we’re updating a state”
11:04:13 <marchelzo> Well, I feel that having some state that's both readable and writable is just such a fundamental thing in programming languages. One of the common ways to achieve that in Haskell is State, and since using it without lens is very painful, you end up using lens too.
11:04:32 <marchelzo> If it were built-in to the language, I wouldn't think twice about it, but since it's not, it often feels wrong to use.
11:04:57 <dmj-tls> marchelzo: I wouldn't say using state w/o lens is always painful
11:04:57 <marchelzo> Like, "I shouldn't need this all the time; otherwise it would be built in. Therefore I must be doing something wrong".
11:05:23 <marchelzo> Painful when your state type is a large record.
11:05:54 <puregreen> I'd say “otherwise it would be built in” doesn't hold in Haskell
11:06:20 <Zekka|Sigfig> There are a lot of useful, desirable things that weren’t built into Haskell, probably because the authors figured that building them in would increase the chance of getting them wrong forever
11:06:37 <Zekka|Sigfig> if you leave them in libraries then people can iterate on the designs much more
11:07:17 <marchelzo> True, but you also end up needing massive libraries with *tons* of dependencies just to do things that are completely trivial in most languages.
11:07:26 <Athas> Is there a way to define an Alex parser that uses Text instead of ByteString?
11:07:33 <dmj-tls> > flip execState 0 $ modify (+1)
11:07:35 <lambdabot>  1
11:07:39 <dmj-tls> felt no pain there
11:08:04 <marchelzo> Come on. You can't think that's a very convincing argument.
11:08:17 <puregreen> marchelzo: maybe you're assigning a bit more prescience to designers of Haskell than they actually had :)
11:08:17 <Zekka|Sigfig> marchelzo: I actually agree with you and don’t use Haskell for most programs
11:08:21 <Zekka|Sigfig> this is a big part of why
11:08:28 <puregreen> nobody anticipated lens when Haskell was designed, for instance
11:08:48 <bitemyapp> marchelzo: you don't have to use bling.
11:09:16 <marchelzo> 'flip execState x $ modify f' is just a long way of writing 'f x'. You're not using State in a meaningful way.
11:10:12 <dmj-tls> marchelzo: you're assuming everyone's states are these large nested things, which I don't believe to be the case
11:10:35 <dmj-tls> large flat states exist too
11:11:28 <Zekka|Sigfig> (I think this problem actually makes it tempting to do row-y “I have a bunch of tables of facts” representations — but that’s not in vogue yet afaict)
11:11:41 <srhb> marchelzo: How do you figure it might as well be imperative? What did you lose by using lens? You still have referential transparency etc. 
11:12:15 <srhb> marchelzo: I too like solving problems in a way that isn't just but also LOOKS functional, but I think that's really less of an issue.
11:12:36 <marchelzo> It might as well be imperative, because it seems like you could quite trivially transform it into an equivalent program in an imperative language.
11:13:04 <srhb> Sure, modulo referential transparency.
11:13:10 <Zekka|Sigfig> AFAICT there are a lot of problems that you really can’t neatly tie up without saying “I have this state and I want to do lots of updates to it” — it’s not an approach thing, it’s part of what’s being modeled
11:13:17 <bizarrefish> Hi all
11:13:25 <Zekka|Sigfig> if I’m writing an IRC server, I probably have a representation of a chatroom whose userlist varies over time
11:13:27 <srhb> marchelzo: Which is a rather big deal for most people.
11:13:40 <marchelzo> Zekka|Sigfig: Yes, that's exactly how I feel.
11:13:49 <bizarrefish> Anyone think the fmap/join operators are easier to use than bind/return?w
11:13:59 <bizarrefish> I'm curious to get opinions, is all
11:14:10 <srhb> bizarrefish: Easier to use, no. Easier to understand, yes. :-)
11:14:12 <Zekka|Sigfig> bizarrefish: I think they’re easier to understand but they result in longer code
11:15:08 <puregreen> I think ‘do’ is easiest to use, followed by =<< and <$>, followed by >>= which is slightly annoying, and ‘join’ I never use
11:15:12 <marchelzo> Even though you still technically have referential transparency, it seems to me that when using State, it is harder to reason about things.
11:15:47 <shachaf> Then don't use State.
11:16:13 <marchelzo> For example, a value of type 'State s a' is referentially transparent as an /action/ that changes the state and returns an a, but that's not how you think of it (at least I don't).
11:16:37 <Zekka|Sigfig> Personally I found so many of the problems I was solving seemed to need this kind ofm odel, and didn’t really need savestates, that I just started writing programs in languages with side effects instead
11:16:42 <bizarrefish> I guess you could say that bind/return are more 'fundamental', as there are only 2
11:16:57 <bizarrefish> Never thought of fmap and join as being easier to understand, though.
11:17:02 <marchelzo> shachaf: Well that's the problem. It often seems like the best way to solve problems.
11:17:25 <srhb> marchelzo: Well, what's the problem then. :P
11:17:36 <puregreen> that might be a property of your problems and not of State, then
11:17:38 <Zekka|Sigfig> If your programs look better in a language with mutable state, there’es nothing wrong with using one!
11:18:25 <marchelzo> Sometimes I wish there were an OCaml or SML with the tooling and community of Haskell.
11:19:00 <srhb> F# ?
11:19:11 <srhb> I really don't understand why anyone would ever prefer it, but.. :-)
11:19:19 <Zekka|Sigfig> It could be F# is what you want, yeah
11:19:25 <srhb> That too might be a product of the problems I solve.
11:19:42 <srhb> Mind, I've done plenty of stateful things in Haskell, and I find it's a beautiful language for it.
11:20:15 <srhb> Then again I find lens really nice. :)
11:20:17 <Zekka|Sigfig> I don’t think Haskell is that bad at writing stateful code, but it’s syntactically a little awkward and it’s hard to refactor it later if you find out you want to update multiple things
11:20:40 <marchelzo> Yep, that's been my experience as well.
11:20:46 <Zekka|Sigfig> if my default assumption is “I want to update stuff” then Haskell will probably get in my way
11:20:55 * srhb shrugs
11:21:05 <marchelzo> I think lens is really pleasant. lens + State does imperative better than most imperative languages do it.
11:21:10 <puregreen> does anybody know a function for parsing an IPv4/IPv6 address?
11:21:23 <marchelzo> But it can get awkward, and the dependency makes me uneasy.
11:21:35 <Zekka|Sigfig> Oh yeah, the other reason I slowed down on Haskell is because a lot of my friends couldn’t understand it
11:21:53 <Zekka|Sigfig> and that’s not really their fault, it takes a lot of math to do things in Haskell that are provided by default in other languages
11:22:23 <srhb> math?
11:22:29 <srhb> Actually, nevermind. :P
11:23:13 <Zekka|Sigfig> If I’m going to write a bunch of State-ful code and send it to my pals I’m going to have to either convince them “this works like it looks like it does” or explain how State was implemented
11:23:23 <Zekka|Sigfig> neither is super great if my goal is for them to understand my program
11:23:36 <bizarrefish> That's the cool thing about Haskell; it really does work like it looks :)
11:23:44 <bizarrefish> (Assuming you're used to looking at it)
11:23:57 <srhb> Zekka|Sigfig: Why don't you have to explain to people in other languages that things do what they look like they do?
11:24:04 <zomg> kinda agree with Zekka I think
11:24:20 <zomg> but I think Haskell is not that hard - provided you are constantly on hand to explain and answer any questions
11:24:33 <Zekka|Sigfig> srhb: Because they already know the other languages. And even still, “this does one thing and then the other” is a little easier to explain than “did you hear the good news about the continuation-passing style?”
11:24:41 <zomg> if you can't provide the support, then others may indeed end up struggling a bit too much due to the strangeness (assuming familiarity with other langs here)
11:24:50 <hpc> even to imperative programmers State is a little weird
11:25:04 <zomg> most imperative like state with haskell is state + lens
11:25:06 <hpc> State is a single global state of a single specific type
11:25:12 <zomg> ..but that can get a bit crazy in other ways :D
11:25:23 <Zekka|Sigfig> It took me a lot of time to understand how State worked and I tried pretty hard
11:25:26 <srhb> My experience is the opposite, that people can be left alone with Haskell more easily because simple rules actually mean they can work things out on their own if need be, not rely on magic. :)
11:25:30 <hpc> other languages just let you declare and mutate things willy-nilly
11:25:40 <srhb> But I suppose it comes down to how you teach it initially.
11:25:42 <Zekka|Sigfig> once I got it I found out that monad transformers were a thing too, and that made stuff even harder for me
11:26:04 <zomg> srhb: yeah, I think if you were to explain them how to do things, that might work.. but assuming they had to figure out things on their own, it could be hard especially when it comes to monads and monad transformers and such
11:26:06 <bizarrefish> For me, haskell tends to work first time, too
11:26:25 <srhb> zomg: That's... Generally what I do. :P
11:26:35 <zomg> heh yeah then it'll probably work :)
11:26:37 <bizarrefish> With Java, you end up making the program hard to read just so you can express the idea you want to.
11:26:38 <Zekka|Sigfig> I think this is kind of like the difference between spending money and accounting
11:26:41 <srhb> I mean, I think teaching any language as if it were magic is bad.
11:26:45 <hpc> at the risk of being chased out of the channel, perhaps show them some IO code with IORefs
11:26:53 <Zekka|Sigfig> accounting is just a way for describing how money was spent, so in theory, why would it be hard?
11:27:03 <Zekka|Sigfig> in practice, it’s a very particular methodology that makes a lot of assumptions most people don’t make when they want to spend money
11:27:06 <hpc> if you're going to go with "you can write haskell as if it's any other plain jane language"
11:27:07 <srhb> But then you have Python or worse, and, well. You just have to look things up a lot.
11:27:26 <zomg> the problem with accounting is especially the stuff about debit and credit.. I mean nobody can remember the rules about that
11:27:29 <zomg> =)
11:27:53 <Zekka|Sigfig> zomg: Oh god! I just want a mutable variable. Why are you telling me I have to remember the monad laws?
11:28:05 <hpc> zomg: the way i go about that is to remember that credits and debits are from the perspective of an account
11:28:14 <hpc> a debit from one account becomes a credit on another account
11:28:14 <dolio> Why are you telling them that?
11:28:16 <zomg> hpc: brb hiring an accountant ;)
11:28:25 <bizarrefish> 1. A monad may not injure a human being or, through inaction, allow a human being to come to harm...
11:28:25 <hpc> heh
11:28:31 * Clint claps.
11:29:15 <zomg> Zekka|Sigfig: that's kinda true, but I think you can just tell them "do this, and that happens. Now do that, and this happens"
11:29:17 <monochrom> I replaced "debit vs credit" by "negative number vs positive number". now it is just one rule, not two.
11:29:29 <zomg> and they could actually just keep doing it, and they won't be able to shoot themselves in the foot because Haskell is Haskell
11:29:43 <monochrom> I did not know monads when I replaced "mutable" "variables" by passing parameters.
11:29:54 <koala_man> what do you people think of Swift's implementation of Maybe and Except?
11:29:58 <bizarrefish> zomg: You can shoot yourself in the foot with haskell; just not accidentally :P
11:30:10 <Zekka|Sigfig> zomg: I had a lot of success when I just started experimenting — more than I did when I was just trying to learn the math. I still don’t think there should necessarily need to be the conceptual hurdle
11:30:15 <zomg> bizarrefish: data Footgun
11:30:28 <monochrom> my http://lpaste.net/52480 is an example of a text game. what monad? what state?
11:30:35 <sm> yay parameters! 
11:30:36 <hpc> honestly the monad laws can usually be summed up with "things have to make sense"
11:30:52 <Zekka|Sigfig> If I don’t know what a monad is, I probably don’t know what it would mean for the rules to make sense!
11:31:01 <zomg> I don't actually remember the monad laws, and I can use Haskell just fine
11:31:02 <hpc> well you have do-notation
11:31:03 <zomg> :P
11:31:07 <hpc> which looks like some other things
11:31:13 <bizarrefish> monochrom: Just the IO monad there
11:31:20 <hpc> and behaves like those same things when the laws are obeyed
11:31:29 <monochrom> yes, except that you don't have to mention "IO is a monad"
11:31:30 <zomg> I just remember what happens when I do >>= or >> and whatever, things just tend to work =)
11:31:35 <hpc> (within the error bars of every language does things a little differently)
11:31:51 <dmj-tls> fix $ \loop -> randomRIO (1,10) >>= \n -> read <$> getLine >>= \k -> if k == n then putStrLn "winner" else putStrLn "try again" >> loop
11:32:14 <monochrom> my http://www.vex.net/~trebla/haskell/IO.xhtml shows how you can teach IO without mentioning "monad". Nay, with positively mentioning "don't look at monad"
11:32:39 <sm> monochrom: isn't that a bit like saying "don't think of a monkey"
11:32:41 <bizarrefish> monochrom: True, but that program probably would be just as easy to write in any imperative language. By not learning about stuff like Monads, a lot of the good stuff about haskell is inaccessible, and people start saying 'whats the point in haskell?'
11:33:13 <Zekka|Sigfig> There’s a valid case for “Oh, I can’t write them as () -> String? That’s weird. I’m going to go back to Java.”
11:33:26 <dolio> When you explain mutable variables in C, do you tell people that '{ l1; { l2; l3; } }' is the same as '{{ l1; l2;} l3;}'?
11:33:27 <bizarrefish> Imperative programmers often do just say 'I dont see the need for haskell', after they have seen a hello world program. They think it's just a particularly awkward imperative language.
11:33:31 <Zekka|Sigfig> That’s probably an OK decision for most of the people who say that, if IO’s not buying them anything
11:33:48 <bizarrefish> I remember a colleague who once said 'Oh LISP, you mean that language with prefix notation?'
11:33:56 <sm> bizarrefish: "monad-less" haskell is actually still a really nice language in some ways
11:34:23 <Zekka|Sigfig> (as far as they go, IO buys you not that much — you don’t get savestates or anything. It’s purely for accounting afaict)
11:34:24 <dolio> (So you can just write those '{ l1; l2; l3; }'.)
11:34:27 <mitchty> whomever added --allow-newer in cabal 1.24, thank you so much
11:34:58 <mmachenry> bizarrefish: "I don't see a use for X language" is an argument that applies equally well to all languages given the existence of others. You could tell them that.
11:34:58 <hpc> dolio: write that C tutorial
11:35:29 <Zekka|Sigfig> dolio: I think most people get that “doing things in order” is associative — >> corresponds somewhat but not completely to “doing things in order” imho, but *how* it corresponds to that is kinda nonobvious
11:35:31 <hpc> it'd be an amazing example for people who try to teach haskell
11:36:03 <Zekka|Sigfig> mmachenry: “Oh. That’s nice. Well, I already like C++ so I’m going to write the rest of this program in C++.”
11:36:24 <Zekka|Sigfig> usually when you’re convincing someone to try something they don’t already like, you want to convince them that the thing that’s new is buying them something
11:36:38 <bizarrefish> Scala monad tutorial which doesn't mention monads (or burritos, for that matter) http://blog.yellowflash.in/2015/11/08/pure-io.html?utm_content=bufferb16b2&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer
11:37:01 <sm> marchelzo: btw, re "massive libraries with *tons* of dependencies", how about eg microlens
11:37:13 <mmachenry> Zekka|Sigfig: Yeah I guess it depends on the context. If you're actually trying to convince someone to switch to Haskell you have a different challenge. 
11:37:29 <bizarrefish> You can do Monads in Java, too: https://gist.github.com/bizarrefish/5999e932f39ea78dc16fbbe7766be43e
11:37:30 <Zekka|Sigfig> Yeah. Teaching people who already think they need to learn Haskell for some reason is probably easier
11:37:42 <bizarrefish> public final static Parser<List<Integer>> THREE_INTS = SEQ(UINT_8, UINT_8, UINT_8);
11:37:51 <mmachenry> Zekka|Sigfig: No, not that. I'm usually responding to people who are trying to convince me Haskell is a waste of my time.
11:38:19 <GLM> Does anyone know if there is a strong connection between CQRS/event sourcing and core concepts in Haskell like the free monad?
11:38:24 <marchelzo> sm: I'm not sure. I've never tried it. I'll check it out.
11:38:26 <Zekka|Sigfig> Maybe it’s a waste of *their* time! I have a friend who writes good graphics software in the worst language ever.
11:38:33 <monochrom> bizarrefish: I wouldn't use my example for "haskell is better". (I wouldn't use anything.) But I can use it to teach those who want to learn, that a whole lot of "obviously needs mutable states" vanishes and becomes simpler, as a first lesson of a million more lessons in Haskell.
11:38:36 <Zekka|Sigfig> I don’t even want to say what language! It might make people not buy his graphics software.
11:38:53 <sm> marchelzo: working here as a quicker-building drop-in replacement for lens
11:39:03 <hpc> Zekka|Sigfig: you mean to tell me autodesk is written in php?
11:39:22 <marchelzo> sm: sounds like it could be great
11:39:28 <Zekka|Sigfig> hpc: it’s a little more niche than that, and the language is comparable to PHP in a desktop applications niche
11:39:33 <monochrom> there is a whole myth of "state has to be either State or IORef, STRef" that needs to be busted.
11:39:38 <sm> now I just need to convince my upstream deps to use it
11:39:39 <hpc> Zekka|Sigfig: oh, so delphi ;)
11:39:52 <bizarrefish> hpc: I'm guessing tcl
11:39:54 <puregreen> sm: who are your upstream deps? just wondering
11:40:08 <sm> brick and servant-swagger
11:40:21 <Zekka|Sigfig> It’s a weird proprietary language that you’re probably zeroing in on pretty well
11:40:40 <hpc> honestly the choice of language doesn't really matter for graphical work because you're going to end up using opengl anway
11:40:42 <Zekka|Sigfig> you have the right idea, except it’s not good at all the things delphi and tcl are good in
11:40:45 <sm> (brick would switch given a PR, servant-swagger seems to be married to lens-only power features)
11:40:49 <hpc> and that means whatever language you use, you're writing C in that language
11:40:53 <bizarrefish> Zekka|Sigfig: APL?
11:40:54 <bizarrefish> :P
11:41:04 <hpc> Zekka|Sigfig: MUMPS
11:41:10 <srhb> bizarrefish: It was supposed to be terrible.
11:41:21 <Zekka|Sigfig> For the purposes of this discussion, let’s say MUMPS
11:41:25 <hpc> :D
11:41:32 <Zekka|Sigfig> it’s good at the same things
11:41:53 <dolio> Zekka|Sigfig: Why do they need sequences of things in do notation explained when learning to use mutable references, then?
11:42:37 <Zekka|Sigfig> dolio: Doesn’t the interface to mutable references assumes that order matters? (and doesn’t order mattering come from >>=)
11:43:14 <dolio> Lines in C aren't commutative.
11:43:16 <dolio> They're associative.
11:43:35 <dolio> Just like do notation.
11:44:20 <puregreen> sm: hm, I don't actually see servant-swagger using any lens-only features apart from ?~ which I could easily add to microlens
11:44:28 <monochrom> yeah, order matters in C too. but where is it explained? what cause is it attributed to?
11:44:42 <sm> puregreen: oh! thanks for microlens, if you're the author
11:44:54 <monochrom> or rather, if you were to teach C, would you ever explain? would you ever attribute?
11:45:30 <monochrom> but I think dolio is fighting an impossible war against cognitive dissonance.
11:45:49 <sm> puregreen: <fizruk> sm: also I do use some nice things like makeClassy TH generator, which microlens does not provide
11:45:49 <sm>  
11:46:00 <monochrom> people simply decide to hold double standards and be hypocritic. no amount or rational critique or empirical evident can change that.
11:46:10 <dolio> Well, I mean, I think people should just learn about monads and stuff, because they're great.
11:46:26 <hpc> their standards are twice as good! ;)
11:46:31 <monochrom> haha
11:46:34 <dolio> But if your students are immediately turned off by anything except direct C analogies, maybe you should stick to that.
11:46:42 <cheater> in a C book, they just say "lines are executed from the top to the bottom".
11:46:51 <cheater> then you realize what sort of terrible lie that was.
11:47:15 <cheater> they should much rather show escher's stairway to explain execution order
11:47:26 <cheater> at least it would be accurate
11:47:37 <sm> puregreen: (and yes, including ?~ would be nice - lack of it broke a few things)
11:47:57 <marchelzo> no good C book would say something like that
11:48:07 <puregreen> sm: okay, I can easily add ?~, and I've been meaning to add makeFields/makeClassy as well so I'll look at it today
11:48:46 <srhb> marchelzo: _every_ C book says that :-P
11:48:53 <srhb> But you might still be right!
11:48:55 <srhb> :-)
11:48:59 <puregreen> sm: generally microlens is developed like “I implement what I use, and when somebody asks me to add something I implement it as well”
11:49:06 <puregreen> just like lens, actually, I think
11:49:19 <marchelzo> srhb: Are you sure?
11:49:29 <srhb> marchelzo: No, I'm joking.
11:49:38 <sm> puregreen: cool, thanks. BTW do you have any numbers on number of deps/fresh install time for microlens vs lens ? 
11:49:41 <dolio> Some probably just leave it for the student to assume that things are executed top to bottom.
11:49:43 <marchelzo> ah, ok
11:50:03 <marchelzo> A good C book would explain side effects and sequencing.
11:51:09 <monochrom> every sufficiently complicated Haskell program contains an ad hoc lens library? :)
11:51:47 <srhb> marchelzo: There are too many undefined cases to do that well, especially in an introductory book.
11:52:33 <marchelzo> afaik there is only one undefined case
11:53:21 <sm> aha.. "no dependencies" and "4s"
11:53:36 <puregreen> sm: okay, I just checked: the core microlens package has no deps and builds in 3.5s, microlens-th in 5s, microlens-mtl in 3.5s (and has mtl as the dependency)
11:54:05 <puregreen> the only package with bad deps is microlens-contra which I wrote because someone wanted to convert wreq to microlens and needed true Folds for that
11:57:15 <puregreen> monochrom: lens started as an ad-hoc lens library! https://www.reddit.com/r/haskell/comments/1o6iqs/why_i_dont_like_the_lens_library/ccpebzx
11:57:26 <monochrom> haha
11:58:15 <monochrom> this is what you call biology. it doesn't grow to fill a gap. it grows for its own sake.
11:58:45 <orion> What's the easiest way to debug a <<loop>> crash?
11:58:56 <monochrom> the lens are alive! with the sound of muuuuuu siiiiiic
11:59:43 <monochrom> more or less the same as hunting down an infinite loop
12:00:36 <monochrom> if you turn on profiling and rebuild, there is a way to get a "stack trace" for a recent execution history before the error happens
12:00:52 <monochrom> but I am actually reluctant to tell you to turn on profiling and rebuild
12:01:28 <monochrom> because if you didn't build some library with profiling turned on, you have to rebuild them too. it's a domino disaster.
12:02:44 <monochrom> "this recompiles everything. again."
12:02:58 <sm> though if you were using stack, the profiling libs are already there
12:03:10 <monochrom> ah that's good
12:03:12 <sm> I think
12:03:19 <monochrom> ah that's uncertain
12:03:52 <monochrom> to tell you the truth, stack is more likely to have programmer-oriented defaults like this, than cabal.
12:04:35 <bergmark> sm: you still need to rebuild everything with stack, but it does reuse profiling libs if you have compiled them previously
12:05:12 * dcoutts notes that the new cabal stuff also does this automagically
12:05:27 <monochrom> it's ok to rebuild your own code. that's something everyone does everyday on slight pretext :)
12:05:29 <sm> ack. Well, it's still progress
12:06:19 <monochrom> but library is where you want to build once and just use. because the dependency network is too much a rabbit hole, too much an iceburg.
12:07:08 <orion> I tried the instructions here: https://wiki.haskell.org/Debugging#Infinite_loops and got this output: http://lpaste.net/715145491104399360
12:07:13 <orion> I'm not sure how to interpret it.
12:08:04 <bergmark> orion: looks to me that you are calling toJSON recursively on the same value
12:08:08 <sm> dcoutts is the new cabal stuff being released any time soon ?
12:08:17 <dcoutts> sm: yes, hopefully with 1.24
12:08:18 <bergmark> something like toJSON x = f (toJSON x)
12:08:19 <orion> Oh crap!
12:08:22 <orion> toJSON vf = object [ "vectors" .= vf ]
12:08:29 * orion brain fart
12:08:30 <sm> nice
12:08:40 <dcoutts> sm: as a tech preview, opt-in
12:15:37 * hackagebot microlens-th 0.3.0.2 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.3.0.2 (Artyom)
12:25:12 <tommd> orion: That would result in a rather large JSON object...
12:25:29 <orion> ha, yeah :p
12:25:46 <orion> Funny enough, the final output is 897KB.
12:29:47 <lifter> How accurate is the statement, "All data in Haskell is immutable"?
12:30:21 <tommd> Mostly.
12:30:23 <monochrom> 99.174394% accurate
12:31:03 <lifter> How could I rephrase the statement to make it 100% accurate?
12:31:06 <tommd> If you aren't in an ST monad and you aren't in IO... and you're actually writing haskell instead of some bastardization language... then enirely.
12:31:42 <monochrom> in ST you are still using immutable data. you put them in mutable ref cells. but do ref cells count as data?
12:31:44 <hpc> all data in haskell is immutable except for types explicitly designed to be mutable within narrow contexts
12:32:02 <dolio> Doesn't matter. ST isn't Haskell, it's GHC only. :)
12:32:20 <tommd> monochrom, dolio: Yeah, I was hoping to not split hairs too much :-)
12:32:33 <kadoban> lifter: I wouldn't rephrase it. Lies that small are pretty much required in teaching/explaining.
12:32:41 <bitonic> Is there a library/RTS call to find out the size of an Haskell object in the heap at runtime? I wrote TemplateHaskell code to do it a while back but it was never open sourced
12:32:44 <bitonic> It was very useful
12:33:09 <tommd> bitonic: I'm nearly certain Johan wrote something that does that some years ago.
12:33:24 <lifter> Thanks! This is very helpful. I like the way hpc phrased it.
12:33:57 <bitonic> tommd: that would be very very useful, I looked for this a bit but could not find it
12:35:05 <hpc> my definition has the nice benefit of being true in both the standards and ghc senses of "haskell" as well
12:35:09 <tommd> bitonic: ghc-heap-view might provide this ability buried inside its api.
12:35:13 <maerwald> It's the same with laziness, saying "haskell is lazy" is not 100% accurate either, but who cares. They can figure out the lies themselves.
12:35:31 <monochrom> but they can't
12:35:53 <maerwald> not?
12:35:56 <monochrom> when putStrLn "hello" doesn't immediately write to your file, they think "it's because Haskell is lazy I/O"
12:36:08 <hpc> lies are fine for teaching if they reveal themselves in the right way
12:36:20 <hpc> going back to "C executes from top to bottom", that's a pretty blatant lie
12:36:26 <bitonic> tommd: looks very promising! THanks
12:36:38 <hpc> you find out right away that it's not a valid way of thinking about a C program in any capacity
12:36:38 <monochrom> they never remember that by default, most OSes (nevermind languages) delay output to files by buffering
12:37:04 <hpc> but if you say "C functions execute from top to bottom", that's correct at a sufficiently granular level
12:37:09 <dolio> I'm not sure there's any implementation of Haskell that anyone could install that isn't lazy, in order to discover that it's not lazy.
12:37:31 <hpc> executing a particular line might alter the flow of control, but in the absence of those the default is to go top to bottom
12:37:32 <maerwald> hpc: I don't think anyone actually _means_ the whole program if he says that about C
12:37:36 <dolio> I guess you could read about it somewhere.
12:37:37 <maerwald> so that's just nitpicking
12:37:59 <hpc> maerwald: it is, but i am picking the nit to make a point, not to harp on it ;)
12:38:12 <maerwald> it's a different nitpick than what we are facing here
12:38:36 <hpc> my point was that some lies are better than others
12:38:48 <maerwald> :D
12:39:35 <hpc> but yeah, just saying "haskell is lazy" isn't a particularly helpful lie
12:39:44 <monochrom> I am very practical here. I don't judge a white lie based on my personal belief. I judge it based on empirically how most beginners succeed or fail after hearing it.
12:39:47 <maerwald> it's lazy.. except when it isn't :D
12:39:58 <hpc> but if you explain (truthfully or not) what the distinction is between evaluation and execution, you can say "haskell uses lazy evaluation"
12:40:09 <hpc> and that lie is much less damaging
12:40:23 <monochrom> for example, "C executes top to bottom" is not one I would complain about, because empirically beginners do not fail after hearing it.
12:40:33 <maerwald> hpc: but it's still not talking about the fact that you can write a) strict code on purpose and b) break laziness by being careless
12:40:38 * hackagebot microlens 0.4.2.1 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.4.2.1 (Artyom)
12:40:40 * hackagebot microlens-ghc 0.4.2.1 - microlens + array, bytestring, containers, transformers  https://hackage.haskell.org/package/microlens-ghc-0.4.2.1 (Artyom)
12:40:42 <lifter> Could someone give me an example of a type that is "explicitly designed to be mutable within narrow contexts"? Does IORef qualify?
12:40:42 * hackagebot microlens-mtl 0.1.7.1 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.7.1 (Artyom)
12:40:44 <monochrom> but "haskell is lazy", beginners fail spectacularly
12:41:10 <hpc> maerwald: indeed, and those are narrower misconceptions than "IO is always lazy too"
12:41:32 <hpc> writing strict code on purpose is highly visible
12:41:47 <monochrom> in fact, even intermediate learners still fail spectacularly. it is that bad.
12:41:48 <hpc> and leads either to "hey what's that" and you reveal the lie
12:42:10 <maerwald> monochrom: let's just be strict then :P
12:42:11 <hpc> or they research it themselves and discover the lie
12:42:29 <hpc> and either way you can lead into a more nuanced description of haskell's evaluation model
12:42:39 <hpc> at a time when they care immensely about it
12:43:45 <monochrom> if you do so much as a putStr or hPutStrLn, the output is delayed by buffering, not by laziness. but beginners rush to attribute it to laziness and think they are enlightened
12:43:46 <hpc> or to get more to the point, the lie is discoverable
12:43:54 <dolio> I'm not sure I agree that "Haskell is lazy" is a lie in the same sense you folks seem to.
12:44:06 <dolio> It's a lie, but you're all talking about people not understanding lazy evaluation.
12:44:31 <monochrom> and by the time you have "if 1 `div` 0 == 0 then () else ()", even intermediate people will ask, "isn't Haskell lazy? why would it need to evaluate 1 `div` 0 and bomb?"
12:44:38 <dolio> Which isn't a result of the lie.
12:44:38 <maerwald> dolio: no, I'd say "haskell is lazy by default"
12:44:39 <hpc> when the rule of the lie is broken by what actually happens, the lie is laid bare instead of being left intact and leading the person wrong
12:44:45 <maerwald> it's not just about understanding lazy evulation
12:44:58 <maerwald> you can disable it explicitly
12:45:02 <monochrom> so yes "haskell is lazy" is an empirically disastrous white lie
12:45:17 <monochrom> even when "C executes top to bottom" isn't
12:45:25 <hpc> basically, a good lie lets the truth break expectations in a useful way
12:45:38 * hackagebot microlens-contra 0.1.0.1 - True folds and getters for microlens  https://hackage.haskell.org/package/microlens-contra-0.1.0.1 (Artyom)
12:45:40 * hackagebot microlens-platform 0.2.3.1 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.2.3.1 (Artyom)
12:45:47 <dedgrant_> How can a student understand evaluation without some foundation in redexes and a few different models?  The differences between expressions like 5*4 and 4*5 can be important though they produce the same results.
12:45:57 <maerwald> now that we've talked so much about lies and teaching I want to open a school :D
12:46:10 <maerwald> so I can lie to all those students
12:46:34 <hpc> mostly i just want to read smbc now
12:46:38 <dolio> The non-lie is that it's defined to be non-strict. But it's still a misunderstanding to think the language being non-strict implies that there are no strict functions/constructs, which is what you're talking about.
12:47:12 <monochrom> dedgrant_: IMO, after knowing that there exists base 2, base 3, base 4, not just base 10, I understand numbers more. in a sense, that's when I can be said to really understand numbers, as opposed to thinking that I understand.
12:47:28 <hpc> you can even go into more detail about what language constructs force an evaluation to depend on other evaluations
12:47:28 <maerwald> dolio: I don't really think that changes much
12:47:38 <hpc> and what forces the top-most evaluation (answer: execution)
12:47:40 <monochrom> So yes, you don't understand evaluation until you know redexes and, in fact, several evaluation options, not just one.
12:48:50 <monochrom> Litmus test: can you tell apart "parsing" and "evaluation"?  cf the public education story "evaluate parentheses first, multiplication next, addition last"
12:49:24 <hpc> wow i never even noticed that
12:49:25 <monochrom> the public education story merges parsing with evaluation because if you go eager, they do merge.
12:49:59 <monochrom> and because it's public school, you can't tell people two concepts "parsing" and "evaluation" and expect them to understand that much.
12:50:19 <monochrom> but this also means they don't understand evaluation, since they can't tell it from parsing.
12:50:39 <maerwald> "<language X> is <property>" should be something that is actually true under all circumstances. Otherwise you should rephrase it, at least if you want to be technically correct.
12:50:48 <dedgrant_> monochrom: right! so is there a suitable analogy in having at least a passing familiarity with the landscape of evaluation models before applying the knowledge to design problems?
12:51:07 <monochrom> knowing two evaluation strategies is how you also learn that parentheses and operator precedences are for parsing, not for evaluation.
12:51:42 <dolio> Sorry, that's not how the terms are used.
12:51:50 <mfukar> dedgrant_, 5th graders are familiar with arithmetic, but they don't know number theory
12:54:56 <haskell892> I'm trying to do a DSL using free  monads and I quite don't get it, I'm having some kind error http://lpaste.net/159290
12:55:04 <maerwald> if a property doesn't always hold, it's a conditional property and thus you can't say "X is Y"
12:55:12 <monochrom> I don't think any analogy is needed. the real thing is already small and simple enough.
12:55:40 <monochrom> and the "landscape" of evaluation is pretty small.
12:56:25 <monochrom> you can say there is an infix operator $$$, and theoretically it means "x $$$ y = x"
12:57:22 <monochrom> then one evaluation strategy says that "5 $$$ (div 1 0)" evaluates operands first. then this expression dies.
12:57:50 <Cale> haskell892: DSL has two type parameters, and so can't be an instance of Functor
12:58:01 <Cale> haskell892: (DSL a) might be an instance of Functor
12:58:10 <monochrom> another says that it plugs into the equation "x $$$ y = x" first, so you get "5", and then you don't die.
12:58:21 <Cale> (in fact, there's a perfectly good instance)
12:58:39 <monochrom> these two are the major evaluation strategies. there are other minor ones (minor in importance) that you can skip
12:58:42 <Cale> (and it's what you already have written)
12:59:10 <dedgrant_> mfukar: Heck, I don't really know number theory *now* much less 5th grade. :)  It doesn't discredit an exploration of interpretations and how they influence results does it?
12:59:10 <monochrom> the whole story can be told in 10 minutes, as a true story. no analogy needed.
12:59:24 <mfukar> dedgrant_, of course not
13:01:02 <haskell892> Cale: ooooh, so just by changing instance "Functor DSL where ..." to "instance "Functor (DSL a) where ...", everything works fine?
13:03:08 <crobbins> is there a good way to make a function tail recursive if its recursive call is used as a higher order function?
13:03:13 <crobbins> e.g. used in `map`
13:03:51 <haskell892> crobbins: define it using foldl'
13:04:01 <c_wraith> in general, don't try to make functions tail recursive. 
13:04:05 <haskell892> crobbins: but map isn't tail recursive
13:04:26 <crobbins> c_wraith, why not?
13:04:35 <c_wraith> map is a good example of a function that would be worse if it was tail recursive. 
13:05:15 <crobbins> what about - https://gist.github.com/carymrobbins/a913f449bd62c8c71cc0
13:05:25 <crobbins> mostly a toy example, but demonstrates the point
13:05:41 <c_wraith> tail recursion, in the context of haskell, means that a function reduces to a call to itself. that means it can't be complete before all the recursion takes place. 
13:06:04 <c_wraith> on contrast, map is lazy. it produces as little output as possible before completing. 
13:06:31 <crobbins> for sure, in this case though, it accumulates to a single value
13:06:53 <crobbins> so there's no "streaming" benefit here
13:07:07 <crobbins> i just seem to run into this issue every now and then
13:07:15 <crobbins> and wondered if there was a general way to deal with it
13:07:34 <c_wraith> there's no tail recursion there. 
13:08:18 <Zemyla> Could Coyoneda be described as data Coyoneda f a = forall g. (Representable g) => Coyoneda (f (Rep g)) (g a)?
13:08:20 <crobbins> c_wraith, in the gist?  the goal is to achieve tail recursion, and i'm not sure how to transform something like that gist into tail recursion
13:08:41 <Zemyla> It seems like that would be advantageous, because of memoization.
13:08:48 <monochrom> I would challenge the notion that "tail recursion is a worthwhile goal"
13:09:14 <c_wraith> crobbins, I don't see how that would benefit from tail recursion. 
13:09:39 <crobbins> c_wraith, well, i imagine if you are traversing large structures you could blow out the stack
13:10:12 <dolio> GHC's stack limit in recent versions is very large.
13:10:21 <dolio> Like, a significant percentage of your memory.
13:11:20 <c_wraith> ghc doesn't even use the stack like that. 
13:11:34 <c_wraith> it has an evaluation stack, not a call stack. 
13:12:05 <crobbins> ok, that's fair to note.  but honestly, this is actually something i'm facing in scala at the moment
13:12:25 <dolio> Yeah. The Java stack is completely different.
13:12:32 <crobbins> so, i can't really benefit from ghc in this case
13:12:33 <c_wraith> Oh. well, that's totally different and nothing I said applies. :) 
13:12:55 <c_wraith> Scala is all about blowing the stack when using functional idioms. :) 
13:12:56 * crobbins probably should have brought that up in the beginning
13:13:19 <crobbins> c_wraith, yeah that's what it seems like
13:14:10 <zerokarmaleft> crobbins: might try trampolines
13:14:43 <crobbins> zerokarmaleft, i've heard of those, maybe it's time i see what they are all about
13:15:13 <dolio> You can rewrite map to accumulate a list, and then reverse the list, which is tail recursive.
13:15:40 <dolio> You can turn anything into tail recursion with CPS, but CPS isn't any good in Scala, because the continuations will probably use more stack then the original code.
13:16:07 <dolio> So you actually need to evaluate the CPS using a trampoline, as zerokarmaleft suggested.
13:17:22 <crobbins> thanks zerokarmaleft, dolio, c_wraith, haskell892, i'm digging into trampolines now
13:17:31 <c_wraith> iirc, scalaz has implemented trampolines all over the place. maybe it's combinators would work. 
13:17:38 <c_wraith> *its 
13:19:40 <crobbins> c_wraith, yep, scalaz does use them, and i'm already using scalaz for tons of stuff, so it'll be helpful
13:41:09 <EvanR> is there a way to use spoon to convert a value of type IO X to a value of type String which says either "OK" or "UNDEFINED"
13:41:21 <EvanR> depending on if the pure value is undefined
13:41:43 <EvanR> oh, teaspoon
13:44:14 <nitrix> ._.
13:44:20 <EvanR> i know
13:44:49 <Iceland_jack> EvanR: A function 'IO X -> String'?
13:44:58 <EvanR> yeah
13:45:08 <EvanR> :t evaluate
13:45:09 <lambdabot> a -> IO a
13:45:16 <nitrix> Sounds impossible without unsafe IO.
13:45:22 <EvanR> welcome to spoon
13:45:38 * nitrix scratches head
13:45:51 <EvanR> teaspoon :: a -> Maybe a
13:46:09 <EvanR> if teaspoon evaluates to _|_ then Nothing... of course... it doesnt catch everything
13:46:22 <nitrix> teaspoon = Just
13:46:25 <EvanR> er if the argument evaluates to _|_
13:46:41 <EvanR> teaspoon undefined = Nothing
13:46:56 <Zemyla> That's the halting problem. That's literally unsolvable.
13:47:01 * Iceland_jack just had an evil idea
13:47:02 <EvanR> until now
13:47:28 <nitrix> Oh?
13:47:42 <nitrix> EvanR: Any paper?
13:47:49 <EvanR> its not that glorious
13:47:58 <EvanR> the library somehow traps calls to error and thats it
13:48:07 <nitrix> I don't know. Solving the halting problem seems pretty big to me.
13:48:16 <maerwald> might take a weekend
13:49:02 <Iceland_jack> nitrix: it works, creating a pattern synonym that catches undefined
13:49:11 <Iceland_jack> isUndefined :: a -> Bool
13:49:11 <Iceland_jack> isUndefined x = unsafePerformIO $ catch ((unsafeCoerce x :: IO ()) >> return False) (const $ return True :: SomeException -> IO Bool)
13:49:11 <Iceland_jack> pattern IsUndefined <- (isUndefined -> True)
13:49:23 <Iceland_jack> check :: a -> String
13:49:23 <Iceland_jack> check IsUndefined = "UNDEFINED"
13:49:23 <Iceland_jack> check _           = "OK"
13:49:33 <EvanR> lol
13:49:46 <Iceland_jack> s.t.
13:49:46 <Iceland_jack>     check undefined --> "UNDEFINED"
13:49:46 <Iceland_jack>     check 4         --> "OK"
13:49:57 <Iceland_jack> Of course that is dreadfully stringly typed!!
13:50:05 <EvanR> im writing Show instance so
13:50:18 <nitrix> How is this pratically useful though?
13:50:29 <nitrix> (Or am I failing to connect the dots)
13:50:30 <EvanR> im glad you asked
13:50:50 <Iceland_jack> So we define
13:50:50 <Iceland_jack>     data Definednesscity = Undefined | OK
13:50:50 <Iceland_jack> and give
13:50:50 <Iceland_jack>     check :: a -> Definednesscity
13:50:53 <Iceland_jack>     check IsUndefined = Undefined
13:50:57 <Iceland_jack>     check _           = OK
13:51:00 <Iceland_jack> and we have a quality Haskell program
13:51:05 <EvanR> hahhaha
13:51:34 <EvanR> imagine you are modeling something with OOP
13:51:38 <nitrix> Well, we've just invented Dynamic Typing :P
13:52:12 <EvanR> now, many OOP languages do not restrict the programmer to having all the fields of an object initialized
13:52:19 <EvanR> which is quite convenient
13:52:29 <EvanR> when a field is not set, you can set it to the value undefined
13:52:45 <EvanR> the only issue (lol) with this is that show will now crash
13:52:49 <Iceland_jack> EvanR: Add parameter, make it Void ;)
13:53:06 <EvanR> I fixed this deficiency in haskell's design by showing _|_ in case that field is undefined
13:53:09 * Iceland_jack . o O ( that may be the most evil pattern synonym I've written to date, I hope you're pleased )
13:53:56 <Iceland_jack>     data Person name = Person name Age
13:53:56 <Iceland_jack>     type Anonymous = Person ()
13:53:59 <EvanR> perhaps the next version of SQL will standardize this design pattern and make it the default
13:54:18 <Iceland_jack> then ("John" <$ anonymous) ;)
13:54:22 <nitrix> Isn't this dynamic typing? ;-; It's super ugly, it brings back the notion of "Null" and all your safe abstractions disappears.
13:54:31 <EvanR> its even worse than dynamic typing
13:54:40 <nitrix> Suddently you'll have users using undefined as an error mechanism.
13:54:42 <EvanR> its complete nonsense
13:54:59 <nitrix> And passing an error message in some UndefinedError String type.
13:55:12 <nitrix> And maybe even combining exceptions to those.
13:55:33 <EvanR> for a minute i thought perhaps i could create a data type to wrap the null-ness of the fields value... like SomeTimesNotThere a = ItsThere a | Undefined
13:55:34 <nitrix> EvanR: What kind of mad genius are you?
13:55:51 <EvanR> but thats probably too much for users to think about
13:56:18 <nitrix> EvanR: Aka Maybe :P
13:56:35 <EvanR> youre on candid camera!
13:56:43 <nitrix> I know, I know, I'm aware :P
13:57:35 <nitrix> I just think it's funny. I was working on my toy language recently, trying to improve on Haskell's type system. A lot of work went into it and I had a revelation recently that, oh my god, I just re-invented parametric polymorphism and higher-kinds.
13:57:54 <nitrix> So yeah.
13:58:37 <scshunt> xD
13:58:42 <EvanR> haskells type system is at some depth below ground and there are tunnels leading down in each direction
13:59:38 <EvanR> theres a shady character leaning against the southeast wall
14:00:01 <Zemyla> > go east
14:00:03 <lambdabot>      Not in scope: ‘go’
14:00:03 <lambdabot>      Perhaps you meant one of these:
14:00:03 <lambdabot>        ‘g’ (imported from Debug.SimpleReflect),
14:00:24 <EvanR> you stumble into an unsound type system and break your neck
14:00:28 <EvanR> thanks for playing
14:00:44 <verement> better than getting eaten by a grue
14:01:08 <Zemyla> Aww man, I'm going to have to find a walkthrough.
14:02:25 <Iceland_jack> :t go East
14:02:26 <lambdabot> [Char]
14:02:28 <Iceland_jack> > go East
14:02:29 <lambdabot>  "You find yourself in a dark room."
14:02:54 <Zemyla> :t go
14:02:55 <lambdabot> Direction -> [Char]
14:05:37 <nitrix> > show inventory
14:05:39 <lambdabot>  Not in scope: ‘inventory’
14:06:32 <Iceland_jack> nitrix: I'm starting a team to build a full interactive fiction game that runs on lambdabot
14:06:48 <Iceland_jack> Not sure if I'm joking or not
14:06:58 * hackagebot microlens-platform 0.2.3.1 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.2.3.1 (Artyom)
14:06:58 * hackagebot unfoldable-restricted 0.0.1 - An alternative to the Unfoldable typeclass  https://hackage.haskell.org/package/unfoldable-restricted-0.0.1 (athanclark)
14:08:19 <nitrix> Iceland_jack: You could easily write a script/bot that loads all the necessary definitions
14:08:33 <Iceland_jack> Indeed
14:08:46 <nitrix> I wish we had a @l lpaste.net/XXXXX
14:09:09 <puregreen> we do!
14:09:12 <nitrix> o: !
14:09:20 <puregreen> @letlpaste XXXXXX
14:09:20 <lambdabot>  Invalid paste ID.
14:09:45 <nitrix> How does it solve conflicts / name clashes?
14:09:49 <puregreen> no idea :)
14:10:08 <puregreen> if you end up bravely exploring it, tell me
14:11:09 <hjulle> > [10,20] ↿(+)↾ [0,1]
14:11:10 <lambdabot>  Not in scope: ‘↿’Not in scope: ‘↾’
14:11:15 <Iceland_jack> We'll create a startup, get some VCs involved. Who's with me
14:11:38 <puregreen> how are you going to deal with state, tho? lambdabot forbids IO
14:11:49 <Iceland_jack> puregreen: parameter that is randomly determined
14:12:01 <Iceland_jack> and you get access to the next level by getting that param
14:12:02 <Iceland_jack> @let (↿) = flip ($)
14:12:03 <lambdabot>  Defined.
14:12:17 <Zekka|Sigfig> Or just have the bot sit in this channel and @letlpaste in PM every time someone advances the game
14:12:19 <Iceland_jack> @undef
14:12:19 <lambdabot> Undefined.
14:12:21 <nitrix> puregreen: Interesting. So it ignores the module namespace and loads all the definitions inside, globally.
14:12:21 <Zemyla> puregreen: It would actually need to be a lambdabot plugin.
14:12:32 <puregreen> okay, so I'd have to type “go myParam17 East”?
14:12:33 <Iceland_jack> @let (↿) = flip ($); infixl 0 ↿
14:12:34 <lambdabot>  Defined.
14:12:47 <Iceland_jack> @let (↾) = ($); infixl 0 ↾
14:12:48 <lambdabot>  Defined.
14:12:54 <Iceland_jack> > [10,20] ↿(+)↾ [0,1]
14:12:55 <lambdabot>      No instance for (Show t0)
14:12:56 <lambdabot>        arising from a use of ‘show_M210376690840868609916541’
14:12:56 <lambdabot>      The type variable ‘t0’ is ambiguous
14:12:59 <Iceland_jack> oh well
14:13:13 <Iceland_jack> > [10,20] ↿zipWith (+)↾ [0,1]
14:13:15 <lambdabot>  [10,21]
14:13:27 <hjulle> http://hackage.haskell.org/package/InfixApplicative-1.1/docs/src/Control-Applicative-Infix.html#%21BF
14:13:51 <hjulle> > [10,20] ↿(+)↾ [0,1]
14:13:53 <lambdabot>      No instance for (Show t0)
14:13:53 <lambdabot>        arising from a use of ‘show_M494418601197321069516604’
14:13:53 <lambdabot>      The type variable ‘t0’ is ambiguous
14:14:10 <hjulle> :t (↿)
14:14:12 <lambdabot> a -> (a -> c) -> c
14:14:14 <nitrix> Oh my gosh. Is that how (`) works?
14:14:18 <Iceland_jack> And you're using the lifted
14:14:29 <nitrix> :t (`)
14:14:30 <lambdabot> parse error on input ‘)’
14:14:31 <Iceland_jack> nitrix: nah, but I do use this same trick for some of my personal projects
14:14:46 <puregreen> nitrix: if only
14:15:08 <nitrix> That'd be so cool! Instead of being in the grammar/lexer.
14:15:11 <puregreen> (then we'd be able to use ` with functions taking more than 2 parameters)
14:15:20 <puregreen> (there's been several proposals regarding this)
14:15:45 <hjulle> > [10,20] ↿(+)↾ [0,1]
14:15:47 <lambdabot>  [10,11,20,21]
14:16:05 <dolio> That's what the arrows do, though.
14:16:22 <dolio> You can't use ` for both sides, though, I think. You need two operators with different types.
14:16:23 <puregreen> nitrix: a slight problem with it is that you won't be able to define fixities for e.g `div` and `mod`
14:16:39 <XoitX> hello haskellers
14:16:46 <Iceland_jack> Hello XoitX 
14:16:55 <XoitX> anyone know what stack is?
14:17:06 <dolio> One is flipped identity, and the other is identity.
14:17:32 <Iceland_jack> dolio: The ones I posted are, the ones in the InfixApplicative package are fmap and flipped fmap 
14:17:33 <XoitX> Why is it different from ghci?
14:17:39 <XoitX> or ghc
14:17:39 <hjulle> On the other hand, the [1,2] <^(+)^> [2,3] syntax is much cuter than the up-arrows. It's a smiling person with a plus-sign as a nose. :)
14:17:45 <nitrix> XoitX: Stack would be the newest development to improve cabal.
14:17:58 <nitrix> XoitX: It's a substitute to cabal-install.
14:18:04 <monochrom> XoitX: is this what you're looking for? www.haskellstack.org
14:18:31 <XoitX> yes but what is cabal
14:18:44 <XoitX> I googled it and it says secret society :O
14:18:56 <ReinH> @google haskell cabal
14:18:57 <lambdabot> https://www.haskell.org/cabal/
14:18:57 <Iceland_jack> XoitX: You know too much.
14:19:00 <XoitX> what am I getting into? :P
14:19:07 <nitrix> @let (=^.^=) _ _ = "Nya~!"
14:19:09 <lambdabot>  Defined.
14:19:16 <monochrom> you're getting into development tools in addition to compiler
14:19:30 <XoitX> :O
14:19:52 <XoitX> haskell seems intersting so far
14:20:03 <sachs4> > (=^.^=) (=^.^=) (=^.^=)
14:20:06 <lambdabot>  "Nya~!"
14:20:11 <XoitX> I'm particularly interested in Tidal
14:20:13 <sachs4> n1
14:20:26 <XoitX> will it run in stack?
14:21:23 <kadoban> XoitX: It should. It's pretty rare to find anything that won't.
14:21:37 <sachs4> nitrix: nice one
14:21:51 <Iceland_jack> > go North
14:21:52 <lambdabot>      Not in scope: ‘go’
14:21:52 <lambdabot>      Perhaps you meant one of these:
14:21:52 <lambdabot>        ‘g’ (imported from Debug.SimpleReflect),
14:22:09 <XoitX> okay, Thanks :D
14:22:52 <kadoban> > go "North"
14:22:54 <lambdabot>  "You have been eaten by a grue."
14:23:22 <Iceland_jack> This game is an emotional roller coaster
14:24:36 <monochrom> does it secretly do IO?
14:24:46 <Iceland_jack> :t go
14:24:47 <lambdabot> t -> [Char]
14:24:55 <Iceland_jack> My parametricity sense is tingling
14:25:39 <monochrom> wait, it was Direction->[Char] not long ago
14:25:53 <Clint> > go 5
14:25:55 <lambdabot>  "You have been eaten by a grue."
14:26:08 <kadoban> I just threw a crappy one up since it seemed to be gone, not sure what the real one was.
14:26:19 <monochrom> this is referentially opaque
14:26:24 <Iceland_jack> > go North
14:26:26 <lambdabot>  "You fall into a pit."
14:26:33 <monochrom> @type go
14:26:34 <lambdabot>     Not in scope: ‘go’
14:26:35 <lambdabot>     Perhaps you meant one of these:
14:26:35 <lambdabot>       ‘g’ (imported from Debug.SimpleReflect),
14:26:40 <Iceland_jack> :t go
14:26:41 <lambdabot> Direction -> Doc
14:26:50 <monochrom> this is fantastic
14:26:55 <Clint> what the hell is going on
14:27:05 <puregreen> #haskell is making a game
14:27:06 <monochrom> the function is pure, but the type mutates :)
14:27:14 <kadoban> Haha
14:27:38 <Iceland_jack> monochrom: Just what Haskell needs, type-level IORef 
14:27:38 <monochrom> (a parallel to: the spirit is good, but the meat is rotten)
14:28:02 <dolio> It's like the opposite of subject reduction.
14:28:12 <Iceland_jack> :t go West
14:28:13 <lambdabot> Doc
14:28:15 <Iceland_jack> > go West
14:28:16 <monochrom> what is subject reduction?
14:28:17 <lambdabot>  Nothing to see here.
14:28:55 <puregreen> why not make it “go :: Type t => t -> Doc” and then players would have to discover types for which it gives good results
14:29:05 <Iceland_jack> puregreen: that's version 2.0
14:29:08 <Iceland_jack> > go East
14:29:09 <lambdabot>  You ponder what subject reduction is. You die alone.
14:29:13 <puregreen> go :: IO -> Doc; outputs “you've been eaten by an IO grue”
14:29:14 <Iceland_jack> eek
14:29:19 <dolio> Subject reduction is the property of a language that says that typing is preserved by evaluation. So if `e1 : T` and e1 reduces to e2, then `e2 : T`.
14:29:46 <Iceland_jack> puregreen: Actually, there's an idea: making the type be the key
14:29:50 <Iceland_jack> by Jove
14:29:50 <puregreen> go :: () -> Doc; outputs “you are a rock, your life is simple, and you're not going anywhere”
14:29:52 <puregreen> etc
14:30:06 <puregreen> can hide lots of easter eggs there too
14:30:09 <Iceland_jack> Indeed
14:30:18 <puregreen> something something Void something
14:30:22 <Iceland_jack> ;)
14:30:30 <monochrom> "type is key" is essentially type class
14:30:41 <puregreen> yep, that's what I meant
14:31:04 <puregreen> (in “Type t”, “Type” is a misleadingly-named typeclass)
14:32:33 <athan> puregreen: oh sheesh, is that related to Typeable?
14:32:46 <monochrom> thanks dolio
14:32:47 <bizarrefish> dammit I love this channel. No arseholes. Haskell is too humbling to incubate them, I guess. no GoF to hide behind whilst calling people names
14:33:04 <puregreen> athan: nope
14:33:21 <athan> bizarrefish: GoF?
14:33:39 <athan> and yeah I agree, I owe these guys everything
14:33:40 <bizarrefish> athan: Gang of Four - Design Patterns
14:33:50 <monochrom> bizarrefish: you are a lazy programmer and you should read more Wadler papers.  <hide behind Wadler>
14:34:00 <athan> oh hahaha
14:34:20 <athan> hey yall I had a question if someone can help
14:34:20 <bizarrefish> sacred text for bad programmers who like calling 'bad practice' whenever someone tries to do something they don't get
14:35:09 <athan> I understand HM-type systems / intuitionistic logic is a "Heyting algebra", and not a Boolean algebra, such that `Not (Not a) /~ a`, yet `Not (Not (Not a)) ~ Not a`
14:35:15 <bizarrefish> monochrom: Alas, I am not lazy enough. still waiting for that in Java (my day job)
14:35:27 <bizarrefish> never heard of Wadler
14:35:38 <bizarrefish> I must be a bad programmer :'(
14:35:42 <athan> I also understand the sense of proof for these systems is "inhabitance", such that terms inhabited are more refined proof objects of their higher proposition
14:35:45 <Zekka|Sigfig> He wrote a lot of essays Haskell programmers like
14:36:13 <athan> my question is that, if `Not = -> Void`, and Void has no inhabitants, how should I consider an implication `a -> Void`?
14:36:22 <athan> We obviously can't write a lambda satisfying that term
14:36:26 <dolio> Wadler was responsible for Java's generics.
14:36:41 <athan> in my mind then, `a -> Void` ~ `Void`, wouldn't it?
14:36:43 <puregreen> alternatively, “bizarrefish: you seem to be wanting something unhaskelly and so we'll spend hours trying to explain to you how you don't want what you think you want”
14:36:43 <Zekka|Sigfig> dolio: Wasn’t Odersky also responsible?
14:36:54 * hackagebot quickcheck-combinators 0.0.0 - Simple type-level combinators for augmenting  QuickCheck instances.  https://hackage.haskell.org/package/quickcheck-combinators-0.0.0 (athanclark)
14:36:55 <dolio> That sounds plausible.
14:36:56 <Iceland_jack> athan: Try witnessing that isomorphism
14:37:09 <athan> not in the sense of _matching_ inhabitability, but in their available inhabitance
14:37:10 <nitrix> athan: ave you considered _|_ ?
14:37:12 <bizarrefish> Ah. For amusement value, anyone got a nice human explanation of Zygohistomorphic Prepromorphisms?
14:37:13 <nitrix> *Have
14:37:40 <athan> Iceland_jack: That's what I'm trying to do, I'm not sure how to reduce `((a -> Void) -> Void) -> Void`
14:37:56 <bizarrefish> puregreen: always willing to be told i'm wrong if the person is willing to justify
14:38:15 <monochrom> athan: "() -> Void" is uninhabited, i.e., unprovable. "Void -> Void" is inhabited, but this is too easy. "a -> Void", if you insist "a" to be a variable, is also uninhabited.
14:38:46 <athan> monochrom: How is `Void -> Void` inhabited? `id` covers this?
14:38:49 <athan> crap :|
14:38:51 <monochrom> yes
14:38:53 <bizarrefish> I love doind haskelly stuff with Java. it actually teaches me a bit about the problem so I can write the solutiom properly
14:39:06 <monochrom> of course "false implies false". even a classical logician knows this much.
14:39:07 <athan> lazyness dodges the necessitation of witnessing inhabitants to form proof terms?
14:39:10 <Iceland_jack> athan: Write
14:39:10 <Iceland_jack>     one :: (((a -> Void) -> Void) -> Void) -> (a -> Void)
14:39:10 <Iceland_jack> and let the types guide you
14:39:41 <monochrom> no, not laziness. granted vs obliged.
14:39:42 <athan> Iceland_jack: Could I just hand-off the callback `a -> Void`?
14:39:49 <athan> monochrom: hmm, okay
14:40:08 <athan> you guys are awesome, thank you so much
14:40:10 <monochrom> in "X -> Y", you are granted X, you are obliged Y. not the other way round.
14:40:39 <Iceland_jack>     one f a = f (\g -> g a)
14:40:40 <monochrom> (empirical observation: many programmers are weak at telling apart granted vs obliged. in fact, they reliably bet on the opposite.)
14:41:04 <athan> Iceland_jack: O_O friggin ContT, okay hmm
14:41:08 <Iceland_jack> ;)
14:41:34 <Welkin> athan: :O
14:41:49 <athan> Welkin: :(________)
14:41:53 <Iceland_jack>     type Cont r a = (a -> r) -> r
14:41:53 <Iceland_jack> after all
14:41:59 <dolio> bizarrefish: For some time, there was a group of people who were into capturing certain recursion patterns into functions, and giving those functions fancy names. 'Zygo', 'histo' and 'prepro' were three of those names, and then you mash them all together in one function that does all three at once.
14:42:00 <monochrom> in "Void -> Void", you are granted input::Void (nevermind that it's absurd. you're granted it. be happy.) Then you're obliged to produce output::Void. this is easy, just pass it forward.
14:42:02 <Welkin> wtf is that?
14:42:50 <athan> monochrom: So it's not necessarilly a proof of inhabitance, but a proof of the ability to hand-off the potential inhabitance
14:42:53 <Job316> is there a way to do something like this in type synonyms? type Candidate (Ord a) => a = a
14:43:01 <Job316> or do you have to do a newtype for that
14:43:29 <athan> Welkin: Me collecting food that drops down the screen
14:43:54 <monochrom> a certain benefactor suddenly calls upon you, athan, and donates $10000 for your study of logic. this is absurdly miraculous, like Void. so you ask the benefactor, "how could I repay you?"  He says, "don't repay me. pass it foward.".  That's Void -> Void.  An absurd miracle enables another absurd miracle.
14:44:28 <bitemyapp> @karma+ monochrom
14:44:28 <lambdabot> monochrom's karma raised to 116.
14:44:35 <niksaz> :q
14:45:15 <athan> monochrom: well, specifically they would tell me to not use it though, because touching the absurdity assumes it exists :P
14:45:17 <monochrom> at any rate, technically, the value "\x -> x" is an inhabitant of the type "Void -> Void". this does not require Void to be inhabited. we don't care. we only care Void->Void, not Void.
14:45:44 <dolio> bizarrefish: They're all variations on two basic themes, though. Either you're folding a tree, or unfolding a tree. Histo is unfolding a tree, but it keeps track of all the previous things you did along the path to get where you are, so you can ask to see them.
14:45:55 <dolio> Sometimes you're unfolding and then folding.
14:46:08 <geekosaur> conveniently, a type a -> a provides no information that could be used to touch the a
14:46:35 <athan> geekosaur: so maximizing generality minimizes assumption
14:46:42 <athan> derp
14:47:03 <dolio> 'Prepro' stands for preprocessing, so it does something along those lines. I don't remember what 'zygo' indicates, because it's not really worth knowing all the made up jargon.
14:51:41 <monochrom> the chain of absurd miracles hits its climax when you get to Void -> (Void, Void, Void, Void, Void, Void, Void, Void, Void, Void)
14:52:45 <monochrom> at which point the story becomes: you received an email that says: "foward it to 10 people, then you will get rich; if you don't, you die tonight"
14:53:24 <Welkin> no
14:53:28 <Welkin> "in 7 days"
14:53:59 <monochrom> yes the 7-day bound was before AOL existed and everyone used postal
14:56:04 <geekosaur> and when remote throat throttling protocol becomes a thing, you will die immediately >.>
14:56:04 <dolio> You forgot the list of names. Then you move up names on the list in each forwarding, and send $1 to each person at the top of the list you received.
14:56:21 <dolio> With 5 names, everyone gets $10,000.
14:56:21 <monochrom> haha
14:56:25 <Welkin> MLM?
14:56:28 <Welkin> is this Amway?
14:57:39 <dolio> Or is it 4?
14:57:44 <monochrom> multi-level intuitionistic marketing
14:58:00 <Welkin> seriously though
14:58:04 <bizarrefish> I'm looking at this code, and wondering how the hell it works. Even though I completely understand it. :/
14:58:05 <Welkin> wtf is with amway recently?
14:58:22 <glguy> Is amway a Haskell library I haven't heard of?
14:58:26 <bizarrefish> It's like magic.
14:58:28 <Welkin> some indian guy tried to trick me into going to some amway meeting to get me to join under him
14:58:37 <monochrom> show me the code. I want to see it too
14:58:44 <dmj> amway is a pyramid scheme
14:58:46 <Welkin> and he described it as "it's like facebook and ecommerce combined. It's a new business."
14:58:52 <dolio> It's off topic.
14:58:58 <Welkin> and then I went to the meeting to see wtf it was and found out it was amway
14:59:07 <Welkin> then I ran out as fast as I could
14:59:09 <Welkin> haha
14:59:12 <bizarrefish> monochrom: It's not event complicated. It's a monadic line-terminated string parser
14:59:17 <Welkin> my parents did fucking amways 20 years ago
14:59:20 <Welkin> I know all about that crap
14:59:25 <bizarrefish> *evenhttps://gist.github.com/bizarrefish/5999e932f39ea78dc16fbbe7766be43e#file-parser-java-L94
14:59:27 <glguy> Welkin: Please stay on topic in #haskell
14:59:28 <bizarrefish> https://gist.github.com/bizarrefish/5999e932f39ea78dc16fbbe7766be43e#file-parser-java-L94
15:00:12 <Welkin> alright glguy 
15:00:48 <glguy> bizarrefish: (un?)fortunately, Java is also off-topic in #haskell
15:01:11 <bizarrefish> glguy: Even if it's haskell-ish java?
15:01:20 <bizarrefish> Seemed close enough, but okay
15:01:24 <Welkin> frege?
15:02:10 <bizarrefish> I guess there are other languages which I could have used which would have been inappropriate for this channel
15:02:37 <monochrom> I am not familiar with emulating monad in java
15:03:35 <bizarrefish> monochrom: More a mental exercise; as I said earlier, I do stuff like that to better understand problems, even if i'd never put it in production. Works really well. Pity I can't actually just use Haskell at work :P
15:04:09 <monochrom> but I wouldn't emulate monadic programming in java either
15:04:43 <bizarrefish> I don't think it's so much 'emulating' as implementing. Albeit in a very limited way.
15:05:09 <bizarrefish> Monads are of course of very little use without the higher-ordered polymorphism.
15:05:31 <bizarrefish> But indeed, I wouldn't put it into production :P
15:05:46 <canonic> How can i escape keywords in haskell ? 
15:05:58 <monochrom> I would give java parsers an interface of either iterator-like or SAX-like
15:06:52 <athan> canonic: What do you mean by keywords?
15:06:55 <athan> Like `class`?
15:06:59 <glguy> canonic: Are you asking to use something like "if" as a variable name? If so, no.
15:07:03 <dmj-tls> was there ever any push to make a instance Show (a -> b) where show = const "<function>" in base
15:07:07 <athan> yeah that's a no-go :\
15:08:25 <geekosaur> dmj-tls, Text.Show.Functions is in base
15:08:46 <dmj-tls> geekosaur: cool! never knew
15:11:43 <dmj-tls> that's been there forever I guess... heh
15:24:58 <verement> who is responsible for haskell.org mail infrastructure? is there a better contact than postmaster@haskell.org?
15:25:34 <nkaretnikov> verement: try asking on #haskell-infrastructure
15:25:39 <verement> thanks
15:27:22 * hackagebot dynamic-state 0.2.2.0 - Optionally serializable dynamic state keyed by type  https://hackage.haskell.org/package/dynamic-state-0.2.2.0 (DmitryIvanov)
16:07:24 * hackagebot io-machine 0.2.0.0 - Easy I/O model to learn IO monad  https://hackage.haskell.org/package/io-machine-0.2.0.0 (YoshikuniJujo)
16:08:15 <ggVGc> I need to "replace X elements from index N" within a collection. what do I want?
16:08:18 <ggVGc> Seq?
16:08:48 <Iceland_jack> ggVGc: is lens okay?
16:08:58 <ggVGc> yes
16:09:06 <ggVGc> I am using Lens, but only started a few days ago
16:09:31 <Iceland_jack> > set (ix 4) 'x' "HELLO"
16:09:32 <lambdabot>  "HELLx"
16:10:04 <ggVGc> yes, but I want to replace multiple sequential elements
16:10:05 <Iceland_jack> ggVGc: If you are using 'Data.Sequence' you hae adjust
16:10:28 <Iceland_jack> Are you talking about a slice?
16:10:34 <ggVGc> yeah, I guess
16:10:49 <ggVGc> I want to replace a slice within a List, but I'm guessing I should change to Sequence
16:11:20 <Welkin> it depends on what you are doing
16:11:46 <Iceland_jack> > over (sliced 1 3) (* 10) (Seq.fromList [1,2,3,4,5,6])
16:11:48 <lambdabot>  fromList [1,20,30,4,5,6]
16:11:51 <ggVGc> I have a long list, and I want to replace N elements at an arbitrary index
16:11:52 <Iceland_jack> is one way
16:11:54 <Welkin> sequence is great for consing and appending, with ocassional random access
16:12:46 <Welkin> that's nice Iceland_jack 
16:12:51 <ggVGc> yeah, cheers
16:12:57 <Welkin> I still haven't found a need for lens yet though
16:13:06 <Welkin> in what I do at least
16:13:24 <ggVGc> introducing lens to my project was the best thing I did
16:13:29 <ggVGc> so mmany things have simplified
16:13:38 <Iceland_jack> You can use their indices as well
16:13:43 <Iceland_jack> > iover (sliced 1 3) (+) (Seq.fromList [0,10,20,30,40,50])
16:13:45 <lambdabot>  fromList [0,11,22,30,40,50]
16:13:59 <ggVGc> cool
16:14:01 <ggVGc> tat's what I needed
16:15:40 <meditans> hi, I'd like to ask you all an opinion on how haskell code should be treated by the outshine/outorg mode in emacs
16:16:21 <meditans> if you don't know that mode, here's a video with a demo: https://www.youtube.com/watch?v=kxFvpJPetaw&nohtml5=False
16:17:05 <meditans> but basically what it does is enabling a "dual view" of your code, in which your comments are normal text in org-mode, and your code gets inside code blocks
16:17:39 <meditans> However, the question is this: how should haddock comments be treated?
16:18:16 <meditans> should they go with the code? Should they go with the other comments? I'd like to hear your opinion on this
16:18:59 <meditans> tl;dr should haddock comments be distinguished from normal comments in outorg?
16:19:32 <Welkin> they are not in haskell-mode
16:21:36 <meditans> Welkin: would you prefer for them to be put in an apposite block for haddocks?
16:22:00 <Welkin> no, not personally
16:23:07 <meditans> Welkin: so, should they be put with the code, or with the comments, in your opinion?
16:37:19 <meditans> ok, I have to go now, if someone's interested in the topic chime in at https://github.com/tj64/outshine/issues/58#issuecomment-207582061
16:43:46 <puregreen> is there a way to find out where GHC spends the most time when compiling a package?
16:44:02 <ggVGc> Iceland_jack: hm, why do I get this? https://gist.github.com/b447e3946eba225c51a3af3003a2ff6a
16:44:11 <puregreen> or some things to pay attention to if I want my package to compile faster?
16:48:05 <Cale> puregreen: You know, that would be really nice
16:48:05 <Iceland_jack> ggVGc: 'Data.Sequence.Lens' instead of 'Data.Vector.Lens'
16:48:54 <Cale> puregreen: a declaration by declaration breakdown of time spent... I'm sure it might get a little unclear in the face of things like inlining
16:51:03 <puregreen> it'd also be nice to build a graph of dependencies between functions
16:51:23 <puregreen> so that I'd be able to know what functions I can put into separate modules and have GHC compile those modules in parallel
16:52:01 <puregreen> (since nowadays GHC compiles modules in parallel when they don't depend on each other... right?)
16:57:58 <orion> With Aeson, I can do the following when parsing JSON: ((fst . B16.decode . encodeUtf8) <$> o .: "some hex string"). What would be the equivalent for parsing a Maybe ByteString instead of a simple ByteString?
17:01:14 <kadoban> Anyone know if there's something like a FromJSON instance for … HashMap Text Value that I'm not seeing? I pretty much jsut want a JSON Object directly represented with all the stuff in it.
17:06:40 <puregreen> kadoban: I think there's an instance for HashMap Text Value
17:07:12 <kadoban> puregreen: Any idea where? I don't seem to be seeing it :-/
17:07:28 <puregreen> the list of instances in a hidden module
17:07:31 <puregreen> * is in
17:08:06 <puregreen> kadoban: https://github.com/bos/aeson/blob/master/Data/Aeson/Types/Instances.hs#L708
17:08:26 <puregreen> (and the FromJSON instance is directly below)
17:08:53 <puregreen> regarding aeson and instances, my advice would be “just check whether it compiles, because most instances are already there”
17:09:35 <puregreen> orion: i.e. you want to return Nothing if the string can't be parsed as hex?
17:09:37 <kadoban> puregreen: Hmm, thanks a lot. Yeah it doesn't compile, but that must mean I'm screwing something else up. I'll take a break and try again, probably something really easy.
17:09:59 <puregreen> kadoban: you can paste the code if you want to and I would look at it
17:10:22 * puregreen is procrastinating on going to sleep
17:10:47 <kadoban> puregreen: Thanks. If I can't figure it out after the break I will. I'd have to refactor a bit to share it sanely or I'd do it now.
17:30:23 <orion> puregreen: I figured it out: (bsToPt' . fst . B16.decode . encodeUtf8) <$> o .: "some hex string" was what I wanted.
17:30:32 <orion> sorry
17:30:49 <orion> fmap (bsToPt' . fst . B16.decode . encodeUtf8) <$> o .:? "some hex string"
17:36:23 <shachaf> Where can I read about reducing lambda expressions to BCKW?
18:05:44 <Big_G> What is the canonical way to represent an entire program as a single value and compose those larger programs?
18:06:35 <hpc> what do you mean by an entire program?
18:06:46 <Big_G> Those programs may come from unknown sources like a web server request which complicates it
18:07:15 <Big_G> hpc, Lets say I have a web server and I want the client request to be seen as a single program to be exectuted. 
18:10:22 <Cale> Big_G: Generally for a web server you want to be very careful about the admissible structure of client requests -- it's unusual to want them to be too complicated.
18:14:58 <Big_G> Cale, I suppose not. We're talking about creating an event sourcing model so having the requests come in as events (or easily be converted to events) would be great. I mainly want to know how to replay them once they're in the form of events
18:23:00 <zRecursive> Big_G: URL -> Action in server like REST ?
18:24:37 <Big_G> I guess it depends on what Action is in that case. I'm looking for Action to be something that I can pass into an interperter and possibly sequence with other Actions. For example, the first Action might be creating a shopping cart and another Action might be adding an itme
18:24:40 <Big_G> *item
18:24:50 <Big_G> Combining those would result in a cart with an item in it
18:27:02 <shachaf> If a monoid/group action has a monoid/group acting on a set, what would a monad action have? A monad acting on an endofunctor?
18:27:04 <zRecursive> then you should record each action in server side, i.e. using session id.
18:32:36 * hackagebot husk-scheme 3.19.2 - R5RS Scheme interpreter, compiler, and library.  https://hackage.haskell.org/package/husk-scheme-3.19.2 (JustinEthier)
18:58:57 <Big_G> zRecursive, I know that I should store them but I'm attempting to figure out the format for an event of that nature as well as how I might be able to fold over a list of them
19:29:01 <EvanR> PortNumber is Integral but not Read!
19:29:12 <dalcde> shachaf: monads acts on objects of the category (cf. https://ncatlab.org/nlab/show/module+over+a+monad#algebras_for_monads_in_cat)
19:44:23 <dolio> dalcde, shachaf: In the general case (in that article) the monad 'acts' on a functor, though. Algebras are a special case.
19:46:19 <dolio> Not necessarily an endofunctor.
19:54:56 <dalcde> dolio: a functor is just a generalized object of the category
19:55:02 <dolio> And there's really no way to have left and right versions with the algebra formulation, so modules make more sense as a generalization of monoid actions.
19:55:48 <Cale> dalcde: In the same way that a function is a generalised element of a set
19:55:55 <dalcde> yes
20:27:40 * hackagebot AFSM 0.1.0.0 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.0.0 (hanzhxu)
20:30:37 <kadoban> I can't tell if this makes sense or not … I suspect not, but I'll ask anyway: `[]` is a Traversable, and `(,) a` is a Traversable. Is there some way to compose them, so something like … \b -> [(a, b)] would be a Traversable? (I realize that's fake syntax). Is there a real syntax for that, or is it nonsense?
20:31:11 <Rotaerk> sounds like something you can get in that lens library?
20:31:49 <Cale> kadoban: yeah, Compose should have that instance, I'd expect...
20:31:50 <kadoban> Hmm :-/ I don't know lens
20:32:12 * kadoban looks for that
20:32:44 <kadoban> Oh … well nice, that looks perfect, thanks.
20:33:08 <mniip> kadoban, it's usually called /\b. [(a, b)]
20:33:26 <mniip> /\ being the capital lambda
20:33:28 <Cale> (It's in transformers, but sounds like you found it)
20:34:08 <kadoban> mniip: Oh yeah? Hmm. Is that realish syntax for some extension, or from math? (ct?)
20:34:11 <kadoban> Yep, found it thanks.
20:34:44 <mniip> no, it's not haskellish in any way, but that's the syntax used in LC
20:34:53 <kadoban> Ahh
20:35:05 <mniip> see e.g https://en.wikipedia.org/wiki/System_F
20:35:47 <kadoban> That certainly sounds like something I should learn something about
20:36:51 <mniip> although system F's uppercase lambda roughly corresponds to haskell's "forall", but the opposite is not so
20:39:28 <dolio> System F won't have exactly that, though, because it doesn't have higher-order types.
20:40:08 <mniip> yeah hmm
20:40:32 <mniip> the relation between them is actually less apparent than I originally thought
20:41:45 <mniip> in system F we pretend that we are actually passing types as arguments to functions, while in haskell context dictionaries serve that purpose, and not the foralls
20:43:38 <dolio> System F allows types to be passed to functions at the value level (if you think about it that way). There are just no type functions.
20:44:38 <mniip> well yeah, system F bears no notion of a typeclass, so there are no instance contexts
20:56:44 <kadoban> Isn't there a `map` for Foldable? Hmm
20:56:45 <kadoban> :t map
20:56:46 <lambdabot> (a -> b) -> [a] -> [b]
20:56:58 <kadoban> I don't really have to make my own from foldr, do I? That seems odd
20:57:47 <kadoban> Hmm, nevermind, that doesn't make any sense.
20:59:30 <Iceland_jack> :t fmapDefault
20:59:31 <lambdabot> Traversable t => (a -> b) -> t a -> t b
21:01:47 <kadoban> Yep, thanks :)
21:06:34 <Ankhers> I'm trying to install hzk but it can't seem to find zookeeper.h. How can I tell stack / cabal where to find it?
21:24:01 <Tendies> hi im trying to get a parser to branch using an if statement, what would i put in the "else" to make the parser fail if the condition wasn't met, and otherwise exit the loop and continue parsing?
21:24:54 <kadoban> Tendies: What kind of parser? What's it look like?
21:25:12 <Tendies> just chaining parsers inside a do block
21:25:23 <Tendies> sorry forgot to mention its a do block, thats kind of important
21:27:10 <monochrom> no, we mean which parser library you're using
21:27:46 <monochrom> and if it's not on hackage, you will have to post complete code
21:28:46 <monochrom> and I'm going to sleep
21:28:49 <Tendies> k
21:31:43 <kadoban> Tendies: At a guess maybe you're looking for 'fail', though I'm not really sure at all. Would have to know what kind of parser.
21:32:22 <Tendies> does fail actually fail or does it just succeed at returning []?
21:34:07 <kadoban> It does whatever the Monad thinks fail is, it's part of the Monad typeclass. Which is why it's only a guess, it depends on the Monad you're in.
21:36:04 <Tendies> here's the parser in question http://lpaste.net/159302, here's the library i'm using: http://lpaste.net/159301
21:55:17 <kadoban> Tendies: I think you just want "failure"
21:55:46 <Tendies> as for the true case, what will return me to executing the rest of the do loop? return ()?
21:56:34 <kadoban> Yeah that should work IIUC
22:14:38 <Tendies> how do i check what package a command is from using the bot here?
22:14:52 <Tendies> :p (<|>)
22:15:00 <Tendies> :t (<|>)
22:15:01 <lambdabot> Alternative f => f a -> f a -> f a
22:15:43 <kadoban> Tendies: Hoogle maybe? That's in base, in Control.Applicative I believe
22:16:08 <ahihi> @hoogle (<|>)
22:16:11 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
22:16:11 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
22:16:11 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
22:16:42 <Tendies> my include on this Parsing.hs file has import Control.Applicative (Applicative(..)), does this npt include (<|>)
22:17:17 <ahihi> no, it's a method of Alternative
22:17:26 <kadoban> Tendies: No, that means you're only importing Applicative really.
22:17:32 <Tendies> oh gotcha
22:30:50 <AbelianGrape> I have a monad that's a newtype wrapper around RWS. How do I make it so I can use Lens's "zoom" function with this monad?
22:36:30 <AbelianGrape> Wow, that actually worked
22:36:41 <AbelianGrape> for anyone in the future searching IRC logs and finding this
22:36:55 <AbelianGrape> If Q is your newtype wrapper, define "type instance Zoomed (Q r w s) = FocusingWith w Identity"
22:37:11 <AbelianGrape> Then your Zoom instance just unwraps the inner monad, applies zoom, and re-wraps it
23:00:06 <adarqui> anyone here good with persistent/esqueleto? wondering if I can do a query like this: http://hastebin.com/ukobewudop.sql  .. i've been trying but, no luck.
23:14:24 <AbelianGrape> So I was able to get my Newtype wrapper for RWS to support Lens's "zoom" function. However, all of my functions are written so that they don't actually require this particular monad, but one that instead satisfies the MonadState and MonadWriter instances that I'm using RWS for (in case I want to swap in a different monad for testing or something). However, now that I'm using Zoom, my constraint has t
23:14:30 <AbelianGrape> he form "type ServerMonad m n = (MonadState ServerState m, ..., Zoom n m SubState ServerState)". This "n" never shows up anywhere except the constraint. Is there some way I can elide it?
23:15:02 <AbelianGrape> Before adding "zoom" support, the constraint was just "type ServerMonad m = (...)"
