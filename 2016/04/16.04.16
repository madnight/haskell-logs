00:00:25 <Cale> You put a space after the $
00:00:33 <Cale> which changes the meaning completely
00:00:41 <Cale> $( ... ) is an expression splice
00:01:06 <ntnt> Cale: yep, I screwed up; thanks for your patience
00:01:06 <Cale> If you put a space between the $ and the ( then it's the usual $ infix operator
00:01:56 <ntnt> Cale: you know what? I'm glad I made this mistake "$ (" vs "$(" on such a simple example, while there's someone around to help me debug
00:02:04 <ntnt> would be nasty trying to figure this out on my own
00:02:21 <ntnt> okay, so "[DataD [] Foo_1627543295 [] [NormalC Foo_1627543296 []] []]" looks really useful
00:02:47 <Cale> Have you seen the documentation for the Dec type?
00:03:02 <ntnt> on hackage? I have seen all the constructors
00:03:07 <ntnt> but could not guess what mapped with what
00:03:08 <Cale> http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html#g:15
00:03:22 <Cale> It shows you which kind of declaration each one corresponds to
00:03:31 <ntnt> by looking at the docs, I would ahve never guessed that "data Foo = Foo { foo :: Int, bar :: Double }" maps to [DataD [] Foo_1627543476 [] [RecC Foo_1627543477 [(foo_1627543478,NotStrict,ConT GHC.Types.Int),(bar_1627543479,NotStrict,ConT GHC.Types.Double)]] []]
00:03:48 <Cale> Yeah, it's mangling the heck out of the names
00:03:56 <Cale> You can't actually write that
00:03:58 <ntnt> yeah, but " DataD Cxt Name [TyVarBndr] [Con] [Name]	 { data Cxt x => T x = A x | B (T x)        deriving (Z,W)}"
00:04:03 <Cale> But if you click the links in the documentation...
00:04:04 <ntnt> (from the Docs, does't make all that much sense to me"
00:04:12 <Cale> Click the Con link
00:04:28 <ntnt> http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html#t:Con
00:04:31 <Cale> yeah
00:04:35 <ntnt> it's kinda nice
00:04:46 <ntnt> but it's "a few simple examples" vs "being able to generate whatever I wnat to look at"
00:04:59 <Cale> fair enough :)
00:05:19 <ntnt> anyway; thanks for helping me debug :-)
00:05:20 <Cale> If you recursively look up the documentation for the fields of the thing you want to generate
00:05:27 <Cale> it'll become clear what you need to do
00:05:42 <Cale> in basically any case
00:08:35 <gehmehgeh> Hi
00:08:39 <lightstep> Hi, I have a few questions about Free monad usage in Haskell, I'm pasting the code right now.
00:08:44 <lpaste> lightstep pasted “pretty printing AST with Free” at http://lpaste.net/160174
00:09:07 <lightstep> First, am I doing it right? Is this the way to use Free to represent ASTs?
00:09:58 <lightstep> And if so, is there a way to define showPropPrec similar to showProp? Using a recursion-abstraction?
00:12:26 <ntnt> Cale: you'll be proud to see my first ever from scratch TH:
00:12:27 <ntnt> myDecl :: TH.Q [TH.Dec] myDecl = do   return $ [TH.DataD [] (TH.mkName "Foo") [] [] []]
00:12:33 <ntnt> great things await ahead
00:15:05 <random> Cale: what is the best way to get: [(0,0,0,0,0),(0,0,0,0,1)..] ?
00:15:30 <Cale> random: how does that sequence continue?
00:15:33 <random> [(0,0,0,0,0),(0,0,0,0,1),(0,0,0,1,0)] 
00:15:52 <random> then (..1,1) (1,0,0)
00:15:53 <mniip> 3 elements?
00:15:58 <mniip> ok so binary numbers
00:16:01 <random> yes
00:16:04 <random> binary
00:16:14 <Cale> do they have to be 5-tuples?
00:16:18 <mniip> > (,,,,) <$> [0,1] <*> [0,1] <*> [0,1] <*> [0,1] <*> [0,1]
00:16:19 <lambdabot>  [(0,0,0,0,0),(0,0,0,0,1),(0,0,0,1,0),(0,0,0,1,1),(0,0,1,0,0),(0,0,1,0,1),(0,...
00:16:24 <Cale> > replicateM 5 [0,1]
00:16:25 <lambdabot>  [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,1],[0,...
00:16:46 <random> great, thanks for helping guys
00:16:51 <Cale> yeah, what mniip wrote is probably best if you really want 5-tuples
00:17:15 <mniip> :t liftA5 -- is that even a thing
00:17:16 <lambdabot>     Not in scope: ‘liftA5’
00:17:16 <lambdabot>     Perhaps you meant one of these:
00:17:16 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
00:18:40 <lightstep> > [map digitToInt $ showIntAtBase 2 intToDigit (i::Int) "" | i <- [0..31]]
00:18:41 <lambdabot>  [[0],[1],[1,0],[1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1],[1,0,0,0],[1,0,0,1],[1,...
00:19:14 <Ongy> when I have a datatype that's just a enum and I want to add None option, what is "the more haskell thing to do" add another constructor or wrap it in Maybe? (I only use it at one place)
00:20:28 <liste> Ongy: if you wrap it in Maybe, you get all the Maybe goodness for free
00:20:48 <Hafydd> Ongy: it's probably preferable use Maybe, because (1) you could use the definite type elsewhere if you wanted to, and (2) you can take advantage of the Applicative and Monad instances for Maybe.
00:21:16 <Hafydd> And (3) it explicitly documents that the type is nullable.
00:21:26 <liste> Ongy: like the instances, mapMaybe, catMaybes, maybe, fromMaybe...
00:54:08 <paldepind> Is it possible to apply a class constraint to several type variables at once?
00:54:37 <paldepind> Something like (KnownSymbol a, b, c)
00:54:42 <lightstep> like a multi-parameter typeclass?
00:55:16 <lightstep> more likely, you mean (KnownSymbol a, KnownSymbol b, KnownSymbol c)
00:55:31 <paldepind> Yes. That is what I have now. But it is a lot of typing :()
00:57:44 <hask_noob> fetching variables from s3 objects in haskell?
00:58:47 <Axman6> hask_noob: look at Amazonka, it's pretty easy
00:59:50 <hask_noob> Axman6 thx mate!!
01:00:31 <Axman6> you'll need the amazonka and amazonka-s3 packages (http://hackage.haskell.org/package/amazonka and http://hackage.haskell.org/package/amazonka-s3)
01:00:33 <hask_noob> anymore guide how i set up haskell environment on amazon?
01:02:10 <Axman6> We just use stack
01:05:59 <supki> paldepind: you can do that with a little type family helper, see http://lpaste.net/4118989643930664960
01:06:32 <paldepind> supki, aww. Cool :)
01:06:38 <paldepind> Thank you.
01:09:55 <pavonia> :t id :: (Show x, (Read x, (Eq x, Ord x))) => x -> x
01:09:56 <lambdabot> (Ord x, Read x, Show x) => x -> x
01:10:20 <pavonia> Interesting, I dodn't know you can nest constraints like that
01:10:27 <pavonia> *didn't
01:43:25 <ntnt> in the context of TH, what does ''Foo do ?
01:43:31 <ntnt> in the context of TH, what does ''Foo do ? in particular, the ''
01:56:30 <Axman6> ntnt: it's how you pass a Name of a type to a TH function. the '' is used to make denote a type instead of a constructur (because you can have data Foo = Foo, just passing Foo doesn't make it clear, so they would be ''Foo and 'Foo, IIRC)
02:05:26 <ntnt> Axman6: yeah, I played around with it, got the complaint of missing a TH.Name and yeah, thanks!
02:05:30 <Atium> Does anyone have a generic example of using dynamic programming in place (not storing unecessary previous rows)
02:09:50 <ntnt> dijkstra's can be viewed as DP
02:10:00 <ntnt> bellman-ford also
02:13:46 <Atium> I understand the general idea of DP. But for a lot of these problems I have a table and end up storing unecessary elements
02:14:44 <Atium> I usually onlu need the (k-1)th row. Should I be looking at mutable structures?
02:20:45 <Atium> Something like
02:20:50 <Atium>  fibat i = do
02:20:50 <Atium>     vec <- V.thaw $ V.fromList [0,1]
02:20:50 <Atium>     ans <- mapM (\i -> fibby i vec) [0..i]
02:20:50 <Atium>     return $ last ans
02:20:50 <Atium>   fibby i v = do
02:20:52 <Atium>     p1 <- VM.read v 0
02:20:55 <Atium>     p2 <- VM.read v 1
02:20:57 <Atium>     VM.write v 0 p2
02:21:00 <Atium>     VM.write v 1 (p1+p2)
02:21:02 <Atium>     return (p1+p2)
02:21:05 <Atium> But in a more haskellish way
02:27:30 <ntnt> what is the best way for TH code to throw an error
02:27:36 <ntnt> i.e. for TH code to go "dude, the args you passed me makes no sense"
02:38:34 <Habib> Can anyone here explain what `*>` does? Justin Le in one of his articles says
02:38:41 <Habib> “I have to print a string twice, or multiple strings”: Kinda. You can use the monadic interface to do this using do notation, or mapM_ or (>>). I say abuse because while using the monadic interface to do this is possible, it is a little overkill; (*>) and traverse_ do the trick as well.
02:39:15 <Habib> I have been using `>>` to sequence actions without caring about result. Is `*>` really analogous?
02:41:17 <Habib> Never mind, found it in the docs
02:42:26 <Habib> Although it's confusing, as it doesn't seem to be any different, except to be generalised to Applicative Functors
02:47:55 <Axman6> Habib: they are usually equivalent, except when being able to run the left anf right actions in parallel (such as when using Haxl) is important
02:49:06 <Habib> So, I'm guessing the Monad version (>>) can run the actions in parallel, because requiring a more specific instance for less capability seems strange.
02:50:17 <ntnt> what's a good name for a 'super class' of Text + ByteString, but nothing else
02:50:22 <ntnt> I want to call it Stringy-things
02:53:00 <xa0> ntnt: textual?
02:53:11 <ntnt> it needs to be equal to Text and String
02:53:15 <ntnt> Textual is too close to Text
02:53:21 <ntnt> Stringy is too close to ByteString
02:53:42 <xa0> Textual is the correct definition imo
02:53:42 <ntnt> you know what's the perfect name?
02:53:43 <ntnt> Blob
02:53:47 <xa0> Haha
02:54:17 <xa0> Are you writing a library to unify them?
02:54:38 <ntnt> no, organizing some libraries
02:55:43 <bblfish> hi, I had a simple category theory question
02:56:03 <bblfish> I am looking at Functors https://en.wikipedia.org/wiki/Functor 
02:57:13 <bblfish> and just to get my head around it I thought I'd start with something simple. It looks like I can have a functor from say Int | String to Option 
02:58:39 <bblfish> so I can associate an object for each object in C = Int | String and object in Option using a simple function called say "point"
02:58:49 <bblfish> point(1) = option(1)
02:59:00 <bblfish> or perhaps point(1) = Option(1)
03:00:01 <ertes> ntnt: TextOrByteString
03:00:11 <bblfish> then if I have a function say toString:: Int -> String then I can map that to Option so that F(toString): F(Int) -> F(String)
03:00:22 <bblfish> that all works out nicely.
03:00:24 <ntnt> ertes: I bet you write like Hemingway
03:01:27 <ertes> bblfish: your functors is from Hask to Hask
03:01:30 <ertes> functor
03:02:53 <bblfish> ertes: I am currently writing in Scala, so I am less knowledgeable about the haskell type system or for that matter about the theory of Scala. So I am trying to see if I can stick to pure category theory.
03:03:29 <ertes> bblfish: then your functor is from ScalaTypes to ScalaTypes =)
03:03:37 <shachaf> Well, it doesn't sound like any of the things you've talked about are categories.
03:04:01 <bblfish> Int could be a category, right?
03:04:27 <shachaf> Not in an obvious useful way.
03:04:37 <ertes> bblfish: if it is a category, it has objects and morphisms between them…  you can certainly give it category structure, but it's probably not what you wanted
03:05:03 <bblfish> ah ok. That's perhps where my problem is coming from.
03:05:31 <ertes> bblfish: more usefully Int is an *object* in a category:  the category of scala types and pure functions between them
03:05:41 <ertes> (probably even impure ones, if you're very careful)
03:05:47 <bblfish> What I was trying to understand is what category Lists are or are in
03:06:09 <shachaf> It sounds like the question is about category theory in general, so I don't see why tie it to Scala endofunctors all the time.
03:06:39 <bblfish> I am trying to read up about Free Monads, but I wanted to see if I understood the basics.
03:06:53 <shachaf> I think the first step is to figure out what a category is.
03:07:12 <bblfish> yes, a category are sets of objects and arrows between them that have certain laws.
03:07:52 <bblfish> associativity and so on. That I know. I was seeing if I can apply it to something simple
03:08:11 <ertes> bblfish: what is a functor?  be precise this time
03:08:38 <bblfish> It's a mapping between categories ( https://en.wikipedia.org/wiki/Functor )
03:08:50 <ertes> don't link, but explain
03:09:53 <bblfish> well the definition is there quite simple. So I was trying to apply it to something simple, starting with something like Ints 
03:10:07 <bblfish> mapping Ints to option.
03:10:28 <shachaf> I think you need some more thinking about "category" before thinking about "functor".
03:10:35 <ertes> it is simple, yet you seem to have got it wrong…  you seemed to have mixed up levels
03:10:54 <ertes> what i want you to do is to listen to your own words while explaining it
03:11:05 <Chousuke> bblfish: can you explain what a functor would be in Haskell terms?
03:11:13 <Chousuke> using the definition from the wikipedia article
03:11:29 <ertes> let's use something that isn't programming-specific
03:11:31 <ertes> Set
03:12:00 <bblfish> ok so Set is a category. And the arrows are the functions between those objects.
03:12:02 <shachaf> People here don't listen.
03:12:05 <ertes> you have an approximation of that category in pretty much every language
03:12:30 <ertes> bblfish: try again
03:12:57 <bblfish> in the category of sets the objects are the sets and the arrows are the functions between the sets
03:13:12 <bblfish> that's what one learns in all category theory books.
03:13:53 <ertes> bblfish: give me two examples of objects: one straightforward one and one that isn't as straightforward
03:14:34 <bblfish> the set of fingers on my left hand is one, the set of numbers is another ?
03:15:06 <ertes> okay, but both are straightforward in the sense i have in mind
03:15:36 <bblfish> you mean like a set of ints and strings?
03:16:46 <ertes> hint: add an element named Blah to ℤ, is that still an object of Set?
03:17:34 <bblfish> hmm in normal philosophical set theory that usually is considered a Set.
03:18:02 <shachaf> This is a lesson in ESP, not category theory.
03:18:16 <bblfish> ESP?
03:19:16 <ertes> shachaf: i'm trying to build up to that functor they were trying to formulate, if i understood its idea properly
03:19:23 <shachaf> Mind reading.
03:19:58 <bblfish> I think that in the category of Sets that would fit. But not in the category of Monoids.
03:19:58 <ertes> if i didn't, well, then i'd at least provide an example of a functor that's actually a functor
03:21:02 <ertes> bblfish: the category of monoids is a different beast…  you can easily construct a monoid over {Blah} union ℤ
03:21:19 <ertes> bblfish: now: what would a functor from Set to Set look like?
03:22:23 <bblfish> You need to associate with each set another set, so you need a function from Set to Set
03:22:52 <bblfish> and for each morphism in Set you need to map it to a morpism in Set
03:23:39 <ertes> bblfish: plus functor laws…  now try to give me any example of the former
03:23:50 <bblfish> so presumably the the Identity map is a functor
03:24:31 <bblfish> and maps every function to itself.
03:24:57 <bblfish> so you need your category of sets to contain sets of functions.
03:24:58 <ertes> bblfish: i'm not entirely sure, but you seem to be disregarding the object level a bit
03:25:11 <Chousuke> I think the identity functor is a bit too easy
03:25:32 <Chousuke> can you give a less trivial example? 
03:25:55 <shachaf> The object level doesn't really matter anyway. If you figure out the arrows the objects will take care of themselves.
03:26:00 <ertes> bblfish: a functor F : Set → Set, associates to every *set* X a *set* F(X), *for all* sets X
03:26:16 <bblfish> yes
03:26:37 <bblfish> perhaps a functor that adds the empty set to every set?
03:26:42 <shachaf> But I think this is entirely the wrong conversation to have at this point. It would be more useful to get some examples of "category" and maybe intuition for how it behaves.
03:26:55 <Chousuke> bblfish: What is analogous to Set in a programming language? For me, it really made this easier to think about to realize a concrete analogy :P
03:27:10 <bblfish> Lists?
03:27:13 <Chousuke> no
03:27:24 <ertes> Chousuke: sounds like identity to me
03:27:28 <bblfish> types?
03:27:46 <ertes> perhaps…  you didn't say what happens to functions
03:27:47 <Chousuke> right
03:28:30 <cubuspl42> Is there any way to tell if a function is pure, just by looking at its signature?
03:28:44 <ertes> cubuspl42: all functions are pure
03:28:50 <bblfish> the set of sets
03:29:10 <bblfish> For every Set X I can associate a power Set of X.
03:29:37 <cubuspl42> Ok, so probably the next step for me is to understand why IO functions are pure
03:30:19 <Chousuke> cubuspl42: it's because they don't actually perform side effects, they just return objects representing the side-effects :)
03:30:33 <Chousuke> cubuspl42: and then the runtime does magic and makes them happen at some point
03:30:44 <Chousuke> but that's outside the language itself, so they're "pure"
03:30:59 <cubuspl42> But is it how its implemented? Does the whole program needs to be evaluated fully before IO is run?
03:31:38 <ertes> cubuspl42: no, because haskell is lazily evaluated
03:31:50 <cubuspl42> I did know that one! :D
03:32:32 <cubuspl42> So IO is special? Could I implement MyIO?
03:32:37 <cubuspl42> With my own side effects?
03:33:03 <ertes> you could to *represent* your effects, but if you want to actually perform them, you need to translate them to IO at some point
03:33:32 <ertes> bblfish: i think shachaf is right…  perhaps you should pick up a good book on category theory, if you really want to understand the theory
03:33:50 <bblfish> PowerSet: Set -> Set , associates to every Set X a set PowserSet(X).  then for every arrow between Set I'd need to find an arrow between the power sets
03:33:56 <cubuspl42> ertes: Ok, so IO is indeed special. Thank you
03:34:16 <Chousuke> bblfish: So anyway, if types are the category, then what are the morphisms? and objects of the category? and then what is a functor? :)
03:34:37 <bblfish> ertes: I have been reading category theory and homotopy type theory for a while. The problem is actually grounding the intuitions in programming.
03:34:44 <ertes> cubuspl42: not semantically…  you could think of it as a type with many constructors, one for each effect
03:35:20 <cubuspl42> ertes: By special, i mean: something that compiler/runtime is actually aware of, and one can't implement the replacement
03:35:50 <cubuspl42> I guess that's nothing special in the type itself, though
03:36:23 <ertes> cubuspl42: the thing that makes IO special is that we keep it opaque on purpose (so it can be arbitrarily general) and that the run-time offers to actually run such an action
03:37:26 <ertes> also of course for efficiency…  while you could *think of* IO as a huge GADT, its implementation is actually very lightweight
03:38:30 <bblfish> Chousuke: at a guess the classes are the objects and the functions on the classes are the morphisms?
03:38:38 <ertes> wow, that just blew them away
03:39:21 <Chousuke> classes? nah.
03:40:22 <bblfish> Perhaps types of types are the category and types are the objects and functions over those types are the morphisms
03:41:30 <ertes> bblfish: unfortunately there is no "unified grand intuition" for category theory…  i've struggled with this myself, but ultimately it's just a formal construction and nothing more:  a language with very tight rules and almost no semantics
03:42:28 <bblfish> yes, it's quite weird. 
03:42:36 <ertes> bblfish: think "monoids and homomorphisms", but more general
03:42:38 <bblfish> Homotopty Type theory is easier to understand
03:43:07 <ertes> it is, because you're "doing" something in HoTT…  you're proving stuff, etc.
03:43:50 <ertes> in CT you're really just "formulating" stuff…  and sometimes you'll get a proof for something, but more often than not you're just *talking in the language of CT*
03:46:10 <Chousuke> bblfish: the name of the category is not very relevant (it's different for each language) but generally the objects are indeed types and morphisms are the functions from one type to another.
03:46:16 <ertes> what CT gives you is a nice formal concept of things like "the same", "extension", etc…  and as a programmer you get design patterns that have desirable properties like locality, extensibility, etc.
03:46:52 <bblfish> Chousuke: great. So that's the category for that programming language?
03:47:12 <Chousuke> the category of its types anyway.
03:47:31 <Chousuke> but in haskell that's what you make functors from and to
03:47:36 <ertes> i'm pretty sure Hask and ScalaTypesAndPureFunctions are isomorphic
03:48:37 <bblfish> Ah from the haskell category to the haskell category
03:49:52 <bblfish> then an individual functor would be one that takes int to Option of ints?
03:50:01 <Chousuke> so you need something that maps a (haskell) type to a (haskell) type, and then you need something that maps the morphisms of one type to morphisms of that target type.
03:50:27 <ertes> bblfish: perhaps you should look at the morphism map first
03:51:13 <bblfish> ah the map function?
03:51:31 <ertes> yeah
03:52:15 <bblfish> probably should start here then https://www.haskell.org/tutorial/index.html
03:52:30 <Chousuke> well, you can use scala terminology if that helps
03:52:51 <Chousuke> what you need are still the same two things
03:52:52 <ertes> bblfish: you can approach this from a purely set-theoretic viewpoint and nothing will change except notation
03:52:57 <Chousuke> just under different names maybe
03:53:39 <ertes> haskell: Maybe Integer, scala: (Option something?), set theory: ℤ + 1
03:55:55 <ertes> (note: there is a reason we use a separate category called Hask instead of just Set, but it's probably not important at this point)
03:56:44 <Chousuke> bblfish: what allows you get a type from another type? 
03:57:15 <bblfish> Chousuke: A type constructor?
03:57:26 <Chousuke> exactly.
03:57:33 <Chousuke> and now you have a functor.
03:57:51 <Chousuke> providing it fulfills the necessary laws
03:58:48 <bblfish> Ok, so that's why I was thinking of the Option type constructor as a functor :-)
03:59:24 <bblfish> I think they call it Option.point the function that constructs the Option
04:00:07 <Chousuke> here's the haskell equivalent: https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#line-629
04:01:06 <ertes> i still think you should focus more on the morphism map…  the object map will follow from it
04:01:26 <bblfish> an yes, 'pure' is the other word people use.
04:01:51 <ertes> bblfish: you're getting ahead of yourself now…  'point'/'pure' use more structure than just functors
04:02:20 <Chousuke> maybe Scala functors are actually applicatives or something :/
04:03:22 <bblfish> no they are just functors. https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Functor.scala
04:04:09 <bblfish> it's true that haskell is quite elegant :-)
04:04:33 <bblfish> well I am happy that my idea that Maybe was a functor was right.
04:07:08 <ertes> bblfish: a functor maps morphisms to morphisms, and an endofunctor on C is a functor from C to C:  map f = f  -- can this be an endofunctor on Hask/Set/ScaleTypesAndFunctions?
04:07:42 <ertes> (it maps every morphism to itself)
04:08:10 <bernalex> howto bash expansion with rawSystem? e.g. "foo*bar"
04:08:37 <ertes> bernalex: either pass it through the shell or use haskell facilities for globbing
04:08:58 <bblfish> ertes: why not? make sense. I think you can do List(1,2,3) map eq  === List(1,2,3)
04:09:08 <bernalex> ertes: I am using rawSystem in a very static way, so I was wondering about my options in the latter of your proposed directions.
04:09:23 <bblfish> ertes: why not? make sense. I think you can do List(1,2,3) map id  === List(1,2,3)
04:09:47 <ertes> bblfish: this one has nothing to do with lists though
04:09:52 <ertes> map sin 3.5
04:10:32 <ertes> bblfish: let me use 'lift' instead of 'map' just to avoid confusion
04:10:50 <ertes> lift f = f  -- can this be an endofunctor on (i'll save some typing) Hask?
04:14:28 <bblfish> If I understand lift, then say  f is the function + 1 then if I lift that into Option I get Optionp[int] -> Option[Int]
04:15:39 <ertes> we're not talking about Option (or List or any other specific thing):  let me reformulate:  i claim that there is a functor F : Hask -> Hask that maps every morphism to itself:  F(f) = f
04:15:45 <ertes> does F exist?
04:16:00 <bblfish> yes, I'd think so.
04:16:13 <ertes> what would its object map look like?
04:17:00 <bblfish> it would have to be the objects of Hask Ie the Types?
04:17:27 <ertes> yeah, but remember that a Hask endofunctor maps every object of Hask to an object of Hask
04:17:42 <ertes> for every object A, F(A) = ?
04:17:48 <bblfish> A
04:18:12 <ertes> does that suffice to say that my claim is true?
04:18:30 <bblfish> you'd have to prove the associativity laws?
04:18:48 <ertes> nope, not those
04:19:12 <Chousuke> bblfish: how would you implement that?
04:19:22 <Chousuke> you need something that takes type A and gives you type A
04:20:09 <ertes> bblfish: first in the formulation there is this:  the morphism map (i called it 'lift') must have a certain type:
04:20:36 <ertes> for all a and b:  lift : (a -> b) -> (F a -> F b)
04:20:55 <bblfish> yes
04:20:56 <ertes> you proposed:  F a = a
04:21:18 <ertes> that means:  lift : (a -> b) -> (a -> b)
04:21:27 <ertes> is 'lift' indeed of this type?
04:21:50 <bblfish> if F is the Type Id
04:22:12 <bblfish> mhh not sure. In scala that seems to work.
04:22:22 <bblfish> But that may be type inferencing going on .
04:22:28 <ertes> think like a mathematician now, not a programmer
04:22:49 <ertes> 1. definition:  lift f = f
04:23:01 <ertes> 2. definition:  F a = a
04:23:02 <bblfish> (I am told they are isomporphic programing and maths ;-)
04:23:29 <ertes> claim:  lift : (a -> b) -> (F a -> F b)
04:23:38 <ertes> is that claim true given those definitions?
04:23:41 <bblfish> if you can define that then I answer yes to your question above "is 'lift' indeed of this type?" ?
04:23:56 <bblfish> s/" ?//
04:24:19 <bblfish> since you can replace F a with a 
04:24:34 <ertes> yeah, exactly
04:24:37 <bblfish> thinking in terms of lambda calculus simplification (right?)
04:24:49 <ertes> 3. fact:  lift : (a -> b) -> (F a -> F b)
04:25:19 <ertes> the claim that there is a functor with F as the object map and 'lift' as the morphism map implies:
04:25:52 <ertes> claim:  lift id = id  -- it maps all identity morphisms to identity morphisms in the target category
04:25:53 <ertes> true?
04:27:15 <ertes> to make it easier to answer that, let me be more precise in definition 1:  for all f, lift f = f
04:28:24 <bblfish> that maps an equality between functions? 
04:28:39 <ertes> i don't know what that means
04:28:54 <bblfish> for all f < is f a function?
04:29:07 <ertes> according to the type yeah
04:29:07 <bblfish> for all f <- is f a function?
04:29:19 <ertes> for all functions f, lift f = f
04:30:51 <bblfish> F f = F f
04:31:16 <ertes> you can use any definitions and facts to convince me that 'lift id = id'
04:31:47 <bblfish> lift : (a -> b) -> (F a -> F b)
04:32:22 <ertes> listen:  for all functions f, lift f = f, i.e. "lift f" is defined to be equal to "f"
04:32:28 <ertes> question:  lift id = id?
04:32:44 <ertes> think simple
04:33:08 <bblfish> id(x) = x
04:33:51 <ertes> yeah, but don't even look into id…  you don't need to
04:34:20 <bblfish> f :: a -> a ?
04:34:49 <bblfish> ( I suppose that means that f is of type function from type a to type a
04:34:58 <ertes> bblfish: i say: for every house H, the house H is red
04:35:15 <ertes> then i ask:  assuming that, is the house X down the street red?
04:35:23 <bblfish> ok, yes
04:35:49 <ertes> assuming:  for all functions f, lift f = f, is lift id = id?
04:36:22 <bblfish> yes
04:37:03 <ertes> 4. fact: lift id = id  -- first functor law
04:37:17 <ertes> claim:  lift (f . g) = lift f . lift g  -- second functor law
04:37:31 <ertes> where "." means function composition:  (f . g) x = f (g x)
04:38:01 <ertes> bblfish: true?  (that one doesn't follow as trivially, so take your time)
04:40:54 <bblfish> lift ( f . g ) = f . g
04:41:14 <ertes> good direction, go on
04:41:25 <bblfish> ( from definition 1 above )
04:42:09 <bblfish> lift f = f and lift g = g so (lift f . lift g) = f.g
04:42:31 <ertes> now you're starting to get into the right mindset =)
04:43:50 <ertes> ok, we have a morphism map that we call 'lift' and an object map that we call 'F'…  they map morphisms and objects of Hask (respectively) to morphisms and objects of Hask (respectively)
04:43:57 <ertes> they satisfy the functor laws
04:44:01 <ertes> are they a functor?
04:44:12 <bblfish> what quacks like a duck is a duck?
04:44:32 <ertes> pretty much, yeah
04:44:53 <bblfish> bang! 
04:45:12 * bblfish got me a duck for lunch
04:45:31 <ertes> this functor even has a common name:  the identity functor
04:46:11 <ertes> in haskell we use the convention of naming our functors after their object map, so we would say:  for all types a, Identity a = a
04:46:39 <ertes> and for all functions f, fmap f = f  -- skipping over a haskell technicality here
04:46:53 <ertes> now i renamed 'lift' to fmap, because that's the name we use
04:49:05 <ertes> bblfish: i'm giving you the following exercise for after lunch:  lift f = f . f  -- can this be a functor?
04:49:36 <ertes> if yes, prove it, if no, explain why not
04:49:50 <bblfish> :-) ok will think about that.... 
05:25:44 <s4ke> hi. if i want to use warp in my cabal app, this should be enough, right?
05:25:56 <s4ke> under build-depends i have listed: warp >= 3.2 && < 3.3
05:26:33 <s4ke> but my Setup throws this error: At least the following dependencies are missing: warp == 3.2.*
05:27:05 <s4ke> why is this?
05:27:48 <oherrala> have you installed the depencies?
05:28:01 <s4ke> i have run cabal install warp, yes
05:29:49 <ertes> s4ke: ghc-pkg list warp
05:30:09 <ertes> s4ke: your local package database may be out of date, in which case you should "cabal update" first
05:30:21 <s4ke> C:/Program Files/Haskell Platform/7.10.2-a\lib\package.conf.d:
05:30:21 <s4ke>     (no packages)
05:30:21 <s4ke> C:\Users\Martin\AppData\Roaming\ghc\x86_64-mingw32-7.10.2\package.conf.d:
05:30:21 <s4ke>     warp-3.2.2
05:30:21 <s4ke>     warp-3.2.6
05:30:30 <s4ke> sry for the long paste
05:31:25 <ertes> are you using sandboxes?
05:33:05 <ertes> i.e. have you ever written "cabal sandbox" into the command line?
05:33:22 <s4ke> i dont think so
05:33:37 <s4ke> sry, i am a bit of a newbie 
05:34:24 <ertes> no worries…  as far as i see everything should be fine, so i'm guessing, this could be something windows-specific
05:34:42 <s4ke> hmm ok
05:37:53 <s4ke> ah cabal configure in the directoy helped
05:37:57 <s4ke> http://stackoverflow.com/questions/24656924/cabal-configure-cant-find-an-installed-package-inside-a-cabal-sandbox
05:40:59 <s4ke> ertes: got it working :)
05:42:38 <Sornaensis> has cabal been canned yet
05:42:42 <Sornaensis> can I use stack for everything now
05:50:08 <DEFKOR> http://sh.st/Iex1p
05:53:55 <Ashy> Sornaensis: stack uses cabal internally, but yeah pretty much
06:28:55 <nmdanny> is it possible to use yesod's type safe URLs in a shamlet qq?
06:30:16 <redcat> hi
06:30:54 <redcat> vicon nexus 2 any experience?
06:34:24 <maerwald> there's no stripPrefix for ByteString or am I missing something?
06:34:53 <maerwald> I know I can unpack it to [Word8], but... performance, you know
06:35:18 <ggVGc> abstractions > performance amirite?
06:35:56 <maerwald> no
06:36:13 <maerwald> if you are using ByteString you already have a pretty good reason
06:37:08 <redcat> vicon nexus 2 any experience?
06:37:16 <redcat> vicon nexus 2 any experience?
06:38:29 <maerwald> oh https://github.com/haskell/bytestring/commit/e17d3de26aff58f0a17e98672fcbf516368b3dd7
06:39:28 <taggers> Just wanted to put out an answer I found to the question I asked last night. Docker is vastly improving Mac and Windows integration soon. Things like the slow file mount issue should be resolved. That means that Stack build in docker container should presumably work on windows and mac when the new feature is released!
06:39:38 <taggers> See here for more details. https://blog.docker.com/2016/03/docker-for-mac-windows-beta/
07:01:42 <nmdanny> Would windows docker let me use linux development tools & haskell tools, like a VM?
07:02:32 <maerwald> no
07:02:54 <maerwald> there is no native compatibility layer, so you will run docker IN a VM.. 
07:03:07 <taggers> Support for that sort of thing is coming relatively soon, though
07:03:18 <maerwald> don't praise the lord before he appears
07:04:14 <nmdanny> ok, either way, will it let me use linux tools without having to dual boot linux with windows?
07:04:15 <taggers> Well, I mean, the technologies are in beta  at the moment. 
07:04:38 <maerwald> nmdanny: any VM gives you that
07:06:19 <taggers> MS is currently working on adding bash and a load of other linux tools to win10. https://blogs.windows.com/buildingapps/2016/03/30/run-bash-on-ubuntu-on-windows/
07:06:36 <maerwald> again: not ready, not implemented
07:07:20 <taggers> I understand what you're saying, but there are working demos of this in action. 
07:07:47 <maerwald> it's not a good idea to tell user to run alpha software if they are not already familiar with it
07:08:14 <nmdanny> is there a way of running a linux software, in a VM, without having the entire linux OS/GUI backend enabled?
07:08:37 <taggers> I'm not suggesting to get the software now. Just letting people know that this is something that will be available in the future
07:09:13 <taggers> Which, IMO, is absolutely vital for more widespread adoption.
07:09:14 <maerwald> even that you don't know ;)
07:10:08 <taggers> I'll admit that MS does have ways of making fool-proof sounding ideas fail, but this doesn't seem like one of them
07:10:47 <maerwald> let's stick to the things we know and that work maybe
07:12:23 <taggers> I just don't want people writing off Haskell entirely because windows support currently isn't that great. Same with docker. 
07:12:55 <amarp_> hello there
07:14:10 <maerwald> taggers: I don't see how talking about future innovations that may or may not come does solve that problem ;)
07:14:44 <maerwald> "windows might suck less in 10 years, so get started using it" :o
07:15:20 <maerwald> a VM is currently the only real option if you want to test your haskell stuff on windows under linux
07:15:26 <Rembane> Maybe Haskell is used in contexts not run on Windows.
07:16:16 <taggers> maerwald, many developers in business settings don't get a choice as to what OS they will use. And we have no choice to use C#. I don't want to use C#. I want to use haskell. But as it stands, I wouldn't be comfortable suggesting that my business should use haskell. 
07:16:32 <amarp_> I have a question around closed type families
07:16:38 <amarp_> http://lpaste.net/160181
07:16:47 <amarp_> my lasr equation somehow never matched
07:16:51 <amarp_> last*
07:16:52 <taggers> However, keeping in mind the recent developments with docker and bash, there is a reason to still follow haskell closely.
07:16:58 <maerwald> taggers: haskell is ready for production, you should be comfortable suggesting it
07:17:50 <maerwald> and it works on windows
07:19:45 <amarp_> I can share other part of the code if it's not obvious from the typesig
07:19:58 <amarp_> type family*
07:32:52 <picobit> 'lo.
07:41:06 * bblfish reading http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
07:44:27 <bblfish> ertes: It says there that Maybe is a Functor. So that's good. But according to the wikipedia definition of a Functor a Functor is between categories. So in this case I suppose the domain category can be anything since one can put anything into a Maybe, and the domain are the category of Maybes.
07:58:38 <orion> Is it possible to pause a free monad?
07:59:40 <hpc> if you squint a bit, pattern matching on Free is a single step
08:00:00 <hpc> so you can write something that steps through and is pausable that way
08:03:35 <orion> The return type though...
08:04:40 <orion> Imagine your Free monad is data FooF next = OpA Int next | OpB String Next | Done
08:05:46 <picobit> what exactly is FRP? just manipulating an event stream?
08:08:05 <jmcarthur> picobit: It's a programming model for writing continuous time dependent expressions.
08:08:25 <orion> hpc: If your evaluator is of type FooF Blah and your function looks like this: eval (OpA someInt next), how do you stop after OpA?
08:08:31 <picobit> jmcarthur: effectively you have return types based on context, but you always pass in some sort of delta time.
08:08:59 <orion> From what I currently understand, you'd have to end your function with "next", you have no other choice.
08:09:02 <picobit> jmcarthur: or, the current tally of running "ticks".
08:10:39 <picobit> still wondering if there's anything else "magical" about it, you still need some machinery to feed your call graph.
08:14:04 <bblfish> orion: yes, you can pause a free monad. I am kind of wondering if one can stream Free Monads between servers
08:14:47 <orion> bblfish: How?
08:15:28 <bblfish> Well I am using it in Scala. You build up the Free Monad and then your interpreter can pause whenever it wants to, since it can work one stack element at a time. 
08:15:41 <picobit> and you want to stream that to another server?
08:15:44 <bblfish> In fact I am sending Free Monads around to actors
08:15:47 <picobit> (the running state)
08:16:14 <orion> bblfish: WHat is the type signature on the interpreter?
08:17:41 <bblfish> I have a free monad here: https://github.com/read-write-web/rww-play/blob/bfa76510b44cdcc7acb003ac004809d89f4632f0/app/rww/ldp/LDPCommand.scala (I wrote this a few years ago, and am about to rewrite it)
08:18:24 <bblfish> then the free monad is executed by an actor https://github.com/read-write-web/rww-play/blob/a66001132d3dadd37b440b43c27c0b16c9d6b0d7/app/rww/ldp/actor/local/LDPCActor.scala
08:18:31 <orion> Ha, I don't know Scala. :)
08:18:34 <bblfish> in fact there can be many interpretations of it
08:18:44 <bblfish> but you can't I think stop it from the outside.
08:18:55 <picobit> that's interesting.
08:19:13 <bblfish> so what I was looking at is what happens when I send a Free monad from one server to another, since akka actors can be distributed across servers
08:19:14 <picobit> you're effectively distributing an interpreter state to your various actors.. from what I see.
08:19:27 <orion> bblfish: Do you know of a rough Haskell-equivalent type signature for your interpreter?
08:24:16 <bblfish> orion: I am not a Haskell specialist but there are articles on it, and usually they are in Haskell, which is why I am trying to learn a bit of it :-)
08:24:29 <orion> ah
08:24:41 <bblfish> this one http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
08:24:45 <bblfish> for example
08:27:17 <bblfish> I am just getting back into programming after 3 months, so I am pulling back all that knowledge into RAM so to speak, and improving it a bit.
08:28:34 <picobit> always wanted to learn Haskell, yet I'm an operational kind of guy and GHC Haskell scares the crap outta me.
08:34:38 <maerwald> does ghc ship its own bytestring version?
08:35:01 <maerwald> ghc-pkg list shows me to bytestring versions now and it's messing up cabal
08:35:05 <maerwald> *two
08:38:31 <Tekkkz> Hello! How can I remove the error: "Non-exhaustive patterns in case" -> I need a default case in my "case e of ..." statement, but there should be no action for it. how to do that?
08:38:49 <maerwald> show the code
08:40:31 <Tekkkz> http://ix.io/wRD where managercmd is crawled from a file. but there is also the case taht it is empty , so ""
08:41:56 <maerwald> Tekkkz: you match the rest of the patterns with _
08:41:59 <maerwald> and then do nothing
08:45:21 <Tekkkz> ahh yeah, i forgot nothing, thanks
08:45:37 <maerwald> :t return ()
08:45:38 <lambdabot> Monad m => m ()
08:45:43 <Tekkkz> wut?
08:45:55 <monochrom> maerwald: yes, ghc comes with bytestring.
08:45:58 <rkaad> Tekkkz: "nothing" does not exist. "do nothing" is not an expression
08:46:09 <maerwald> Tekkkz: _ -> return ()
08:46:22 <maerwald> you should know what that does, have you done monad tutorials?
08:46:47 <Tekkkz> maerwald: not yet, it's the next part in my tutorial list, maybe i should do it now, thanks
08:47:07 <maerwald> doing IO is weird if you don't understand monads yet
08:47:09 <aphorisme> Does anyone know about a paper which gives insights in how to implement ADTs and pattern-matching on them?
08:47:56 <monochrom> Tekkkz: is "quit" a typo?
08:47:58 <rkaad> Tekkkz: "return ()" does not exit the function. it is like a one-step null operation
08:48:40 <maerwald> do notation is confusing if you don't know that it's just syntax sugar imo
08:48:43 <rkaad> aphorisme: "implement" as in "how to implement a compiler"?
08:48:55 <monochrom> and I think you should show complete code for people to help you improve it. there may need to be global restructuring
08:48:57 <aphorisme> rkaad: yes  : ).
08:51:23 <rkaad> aphorisme: seen this? http://dev.stephendiehl.com/fun/
08:51:58 <ertes> picobit: FRP is a declarative model for *interactive* applications…  applications with continuously varying values and events
08:52:16 <aphorisme> rkaad: looks promising, although some chapters aren't done yet.
08:53:19 <ertes> picobit: and the point is *not* to deal with time deltas and some other things (callbacks, event-handling loops, etc.)…  FRP views time as continuous and events as first-class objects
08:54:07 <picobit> ertes: so you feed, what, a counter of ticks into each function and an event stream in?
08:54:11 <maerwald> cool, so the unix package just picks the bytestring version of ghc instead of the latest one
08:54:29 <picobit> ertes: you can throw around buzzwords, I kind of want to see the implementation side of things.
08:55:27 <ertes> picobit: you can get an understanding of FRP *as a model* by formulating everything in terms of the following two types:  type Behaviour = (->) Time;  newtype Event a = Event { fromEvent :: [(Time, a)] }
08:56:08 <picobit> not that familiar with haskell, but alright.
08:56:10 <ertes> picobit: the implementation of it is a lot more complicated…  good implementations are reactive-banana and reflex
08:56:26 <maerwald> and the types are no fun
08:56:29 <picobit> ertes: on the base level, is it just event streams?
08:56:46 <picobit> or am I being totally misled.
08:57:13 <ertes> picobit: you need two types:  functions of time ("behaviours") and lists of occurrences with timestamps ("events")
08:57:21 <ertes> so you're on the right track
08:57:54 <picobit> sounds like an event stream to me. you're effectively feeding an event stream into a call graph.
08:58:15 <picobit> behaviors are just the things that run over the event stream.
08:58:32 <ertes> picobit: you could model everything in terms of event streams, but some things can't be event streams in principle, like time itself
08:59:25 <maerwald> let's have another Einstein library no one understand :P
08:59:27 <picobit> ertes: well, if events have timestamps, like you said.. time wouldnt really need to come into play.
08:59:46 <picobit> apart from being bundled with each event.
08:59:54 <ertes> picobit: imagine a UI that displays the current time
08:59:57 <picobit> yup.
09:00:07 <picobit> and you could receive "tick" events from an outside source.
09:01:00 <picobit> if you want to display five second increments, filter over ths ticks.
09:01:04 <ertes> yeah, you can do that, and then you're back to discrete time…  FRP wants to model time as continuous, and it views time-varying values specifically *not* as events
09:01:55 <ertes> that allows easy formulation of things like the 'tag' function commonly found in FRP libraries:  tag :: Behaviour a -> Event b -> Event a
09:02:10 <maerwald> is there a way to check at compile-time if a function of an imported module exists?
09:02:12 <ertes> takes an event and replaces the payload of each occurrence with the value a behaviour had at that time
09:02:20 <picobit> so you need some sort of external source of time, obviously. how exactly, and why, would you want your time to be continuous?
09:02:36 <ertes> picobit: FRP libraries usually don't have to handle time…  time is just a model
09:03:00 <ertes> but they do handle the concept of simultaneity
09:03:14 <picobit> you have to have some method of keeping track of time.
09:03:21 <ertes> not really
09:03:43 <ertes> remember the "timestamp" on events is just the underlying theoretical model
09:03:48 <ertes> not the way it's actually implemented
09:04:04 <picobit> I speak of time as if we were talking about ticks since an arbitrary start point.
09:04:33 <picobit> however granular you want to make it.
09:05:17 <rkaad> maerwald: explicit import? import MyModule (someFunc)
09:05:38 <maerwald> rkaad: ?
09:05:44 <rkaad> !
09:05:54 <maerwald> I don't think that answers my question
09:06:26 <rkaad> oh, in that case, could you maybe rephrase it?
09:06:27 <maerwald> a future version of a module will provide a function I have defined too, because it is not yet part of it
09:06:36 <ertes> picobit: yeah, you can make ticks and then "hold" the tick event to make a time behaviour
09:06:38 <rkaad> ah right
09:06:43 <maerwald> in C you'd just check for a define
09:07:30 <rkaad> maerwald: well if you are working in a cabal-based project you can set global defines, e.g. for dependency versions, in your .cabal file
09:07:36 <rkaad> that's not optimal but it's something
09:07:45 <ertes> maerwald: i think you can use CPP to check library versions
09:07:53 <rkaad> maerwald: and you could also use TH for this
09:07:57 <picobit> ertes: I think the continuous time thing comes from the fact that not every time has an event.
09:09:00 <ertes> picobit: events are inherently discrete, yeah, and time-varying values are inherently continuous
09:10:04 <picobit> ertes: so you effectively only fire off on events, using the time between events to do your stuff.
09:13:17 <ertesx> picobit: i think at this point it would be best to just look at examples…  can you read haskell type signatures?
09:13:28 <picobit> ertesx: very, very loosely.
09:13:50 <picobit> ertesx: only reason I'm interested is because I'm working on something related to flow based programming.
09:14:07 <ertesx> picobit: in non-FRP UI design you typically have widget *objects*, and you can write to their properties and assign event handlers
09:14:17 <picobit> could be seen as a better "machine" for something like FRP.
09:14:38 <ertesx> i'm using UIs as examples, because they are the classic example, but you could do any interactive application with FRP
09:15:08 <picobit> sure.
09:15:12 <rkaad> picobit: why is it better?
09:15:18 <monochrom> I disbelieve in both continuous time and discrete non-zeno time. I believe in dense discrete time.
09:15:20 <ertesx> newTextBox :: IO TextBox  -- create a new text box and return an object that can be manipulated; the traditional model
09:15:29 <monochrom> no, not even dense.
09:16:05 <picobit> rkaad: provides a decent mapping from the declarative description of the problem to the actual hardware that ends up executing it.
09:16:16 <monochrom> ah, I think dense is right. at the end, I believe in rational time.
09:16:17 <picobit> ertesx: I follow.
09:16:39 <ertesx> picobit: in FRP you would have this (simplified):  newTextBox :: IO (Behaviour Text, Event ())  -- instead of an object you get an event that denotes the user pressing enter, and a behaviour that denotes the current content of the box
09:16:57 <rkaad> picobit: for what notion of "decent"? (just asking out of interest since you seem to have an opinion about this)
09:17:09 <ryantrinkle> is there any reason a function like this wouldn't work? mkWeakIORefKey :: IORef a -> b -> IO () -> IO (Weak b)
09:17:20 <picobit> ertesx: I see.. I've rather enjoyed that model. event streams work so much better.
09:17:43 <ryantrinkle> (it's not hard to write with mkWeak#, i'm just wondering if there's a specific reason it was left out of Data.IORef)
09:18:09 <ertesx> picobit: the only difference between event streams and full FRP is that you get behaviours as separate things, and you get certain combinators like 'switch'
09:18:24 <ertesx> picobit: in FRP a behaviour can be a time-varying event:  Behaviour (Event a)
09:18:49 <picobit> rkaad: we don't have to pretend functional programs exist in their own small containers. flow based programming provides a lot of functionality (lazy evaluation via backpressure, referential transparency) for that to work at the network level or smaller.
09:19:25 <picobit> ertesx: I see... so you treat time seperately from events, but it comes bundled with events regardless.
09:19:43 <ertesx> picobit: yeah – modelwise
09:20:01 <picobit> not bad. so you perform your computation based on discrete events, but operate as if time was still flowing between those events.
09:20:15 <ertesx> exactly
09:20:41 <picobit> alright, that fits in with what I assumed. you can effectively play "catchup" when you fire off a behavior.
09:20:53 <ertesx> an event
09:20:58 <picobit> s/behavior/event
09:21:06 <picobit> beat me to it. :P
09:21:11 <ertesx> =)
09:21:15 <pkug> i read this in LYH book: findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing  
09:21:58 <pkug> ..but that will iterate through the whole map even if the key is found before?
09:21:59 <picobit> rkaad: functions by their own become components, passing values to eachother via bounded queues, distributed either on multiple cores, machines, or networks.
09:22:27 <picobit> rkaad: garbage generated is local to the component, infinite lists become continuous sources...
09:22:39 <picobit> it's a good fit in terms of machinery.
09:22:56 <rkaad> picobit: ... whereas you would consider FRP programs "global" programs that cannot be broken up?
09:23:18 <monochrom> pkug: no
09:23:19 <jomg> pkug, actually, no. acc (which is foldr applied to the rest of the list) will only be evaluated if the key doesn't match
09:23:26 <jomg> monochrom, darn! :P
09:23:35 <picobit> rkaad: no no no, FRP programs would run on top of this kind of thing. they fit very well in this model.
09:23:42 <rkaad> ahhh :)
09:23:52 <monochrom> yeah, one branch doesn't use acc at all. that means that branch will not walk the rest of the list
09:23:53 <picobit> rkaad: (in reality, any functional program would)
09:24:06 <rkaad> picobit: okay yeah that sounds reasonable
09:24:08 <ryantrinkle> picobit: yep, although you probably would want to retain some synchronous domains within FRP
09:24:24 <ertesx> picobit: one major feature of FRP is that events and behaviours are first-class, and you can pass them around and map over them
09:24:24 <picobit> makes I/O easy too, because you wouldn't need any monads, you'd just need sources from the outside world.
09:24:30 <monochrom> jomg: but you have a better explanation
09:24:34 <picobit> ertesx: yeah, thats what I was interested about.
09:24:34 <ryantrinkle> you don't want to replace every IORef in your program with a bounded fifo - just the ones where it helps ;)
09:24:36 <ertesx> picobit: the latter is a very difficult thing to engineer efficiently
09:25:12 <pkug> jomg, monochrom: thanks, i see now.. the recursive and non-recursive branch
09:25:14 <ryantrinkle> picobit: exactly as ertesx says
09:25:16 <jomg> monochrom, i'm guessing both probably have their place :)
09:25:30 <ryantrinkle> however, doing it right would be hugely valuable
09:25:48 <jomg> pkug, do note that this wouldn't work if foldl (or foldl') had been used instead
09:26:10 <picobit> mapping over events just sounds like working over the event stream. mapping over behaviors, well.
09:26:45 <ertesx> picobit: another important bit is to maintain a strong sense of simultaneity
09:27:07 <ertesx> otherwise things like 'tag' or event intersections won't make much sense
09:27:12 <picobit> sure.
09:27:25 <ertesx> and it's not as easy as it sounds =)
09:27:39 <picobit> you need to ensure that the required behaviors fire off as if they were functioning independently.
09:27:55 <picobit> instead of something like sequential execution.
09:32:01 <ertesx> picobit: the author of the sodium FRP library has written versions of it for multiple languages…  perhaps your favourite one is among them
09:32:11 <ertesx> picobit: http://blog.reactiveprogramming.org/
09:32:36 <ertesx> that might give you a starting point
09:32:49 <dassie> Hi, can someone please help me with a mutually recursive data types problem?
09:32:57 <picobit> ertesx: ever seen Flow-Based Programming? I was just inquiring about how FRP problems looked.
09:33:25 <picobit> working on an implementation for FBP, so I was curious how "different" the two could look.
09:33:40 <picobit> but thank you.
09:34:19 <ertesx> picobit: i always thought that FBP was more a vague concept like "OOP" or "FP"
09:34:49 <ertesx> so i guess the safest answer is: no
09:34:51 <picobit> JPM is actually fairly specific of what he meansy FBP.
09:34:56 <dassie> Basically, I am trying to a list of As and Bs that is either empty or ends in a B
09:34:57 <picobit> *means by
09:35:24 <Tekkkz> My code: http://ix.io/wRV
09:35:32 <Tekkkz> http://ix.io/wRV
09:35:49 <Tekkkz> my code is http://ix.io/wRV
09:35:51 <dassie> In terms of regexes - ([AB]*B)? 
09:35:55 <picobit> ertesx: FBP is effectively a coordination language, rather than an implementation one.. you specify the orientation and connectivity of components, which can do damn near anything.
09:36:34 <dassie> So I try
09:36:37 <dassie> data Elem = A Elem | B MaybeElem
09:36:39 <Tekkkz> I have two files (manager.cmd, server.cmd) and i wanna run the cmd-line in server.cmd in my minecraft java process i generated. but for some reason it is not going to stop. check my code pelase, you know what i mean?
09:36:46 <dassie> data MaybeElem = Elem | Terminator
09:36:58 <picobit> ertesx: it's a solid fit for something like functional programming, because we're already designing components (pure functions) that feed in and out of eachother.
09:37:01 <ertesx> picobit: i'm visualising a signal network in a typical audio editor…  is that a good example?
09:37:11 <picobit> ertesx: just about.
09:37:29 <picobit> ertesx: components feed in and out of eachother via bounded queues, containing Information Packets.
09:37:58 <ertesx> picobit: i see…  i think FRP is orthogonal to that…  what you're describing sounds to me more like a stream processing framework
09:38:35 <ertesx> or even just concurrency (as it exists in erlang and haskell)
09:38:44 <picobit> ertesx: it's very much like a stream processing framework. directly related, actually. only it has ease of implementation on every level, including transistor-level.
09:38:51 <dassie> But B (B Terminator) does not compile then
09:40:03 <ertesx> picobit: concurrency gets closer to what FRP is about, once you introduce STM
09:41:04 <ertesx> you still don't quite get everything as first-class values, but you do get locality
09:41:41 <picobit> ertesx: the properties of an FBP network are pretty explicit. one thing that makes processing infinite lists possible is the notion of "backpressure", where a feeding process halts when the destination can't accept any more data.
09:41:51 <lpaste> dassie pasted “mutually recursive data types problem” at http://lpaste.net/160184
09:42:11 <picobit> ertesx: and when it can again, the process resumes.
09:44:42 <ertesx> picobit: that sounds a lot like MVar in haskell
09:45:00 <ertesx> picobit: or more generally TBQueue
09:45:05 <picobit> maps well to all abstraction levels, don't it? :)
09:45:45 <maerwald> "my program is so abstract, I don't even know what it does" :D
09:46:15 <ertesx> picobit: i think it's specifically coroutines
09:46:30 <picobit> ertesx: not really. that's one way of scheduling how components update.
09:46:31 <ertesx> picobit: MVar, TBQueue and most haskell stream processing abstractions are built around them
09:46:40 <picobit> ertesx: I could also spawn off components on different threads.
09:46:47 <picobit> or update them one after the other.
09:47:24 <ertesx> the difference between the latter and the former two is that the former don't enforce feed-forward networks
09:47:39 <ertesx> they are really just "channels between threads"
09:47:48 <picobit> much like go channels.
09:48:01 <ertesx> most likely go channels were modelled after them
09:48:23 <picobit> I'd imagine. we seem to be reinventing different concurrency primitives over and over again until we find one that sticks well.
09:48:52 <monochrom> dassie: "data MaybeElem = Elem | Terminator" does this contain a typo? As far as the computer is concerned, it is just like "data MaybeElem = XXX | Terminator" and has nothing to do with Elem.
09:49:00 <ertesx> picobit: the problem is that people in influential marketing positions somehow think that Just Using Haskell is not a good idea =)
09:49:25 <ertesx> so they essentially try to reinvent haskell, a.k.a. the square wheel
09:49:46 <ertesx> (or erlang…  it does a pretty decent job at concurrency, too)
09:49:50 <exio4> hey, haskell is not a square wheel. 
09:49:52 <solano> hello, I'm having a little trouble with xmonad setup. I keep getting "parse error on input 'where'".
09:50:13 <solano> defaultLayouts = tiled ||| Mirror tiled ||| Full where     tiled = Tall nmaster delta ratio
09:50:32 <solano> sorry, couldn't send multiline code
09:50:57 <solano> still, any hint on why it does not work?
09:51:20 <picobit> ertesx: I'd rather have a good framework for an implementation of haskell rather than hakell itself. I'm an operational guy.
09:52:43 <picobit> s/hakell/haskell
09:52:53 <Sornaensis> hasklel
09:52:55 <ertesx> picobit: i don't know why you think that haskell is not a good fit
09:53:27 <picobit> ..?
09:54:05 <picobit> no, I'm talking about haskell "compiling" down to an FBP network.
09:54:18 <ertesx> ah
09:55:18 <picobit> implement components as pure functions, scatter them across your workspace (over the network, VMs, etc.), connect them via queues, and voila.
09:55:44 <ertesx> that would typically be a haskell library
09:55:59 <ertesx> distributed-process (a.k.a. "cloud haskell") does that
09:56:14 <picobit> but you wouldn't have to run any extra code. you split your coordination from your implementation with FBP.
10:05:38 <dassie> monochrom: the definition of Elem is on another line
10:06:06 <dassie> monochrom: see the paste: http://lpaste.net/160184
10:07:12 <dassie> monochrom: It works for empty sequence, sequence containing just B, and AB, but not BB
10:07:30 <dassie> monochrom: Or am I completely missing something here?
10:12:30 <monochrom> Yes, you're missing something. In "data X = C | D", C is a brand new data constructor name you have just created and chosen to call it C. It has nothing to do with a type also called "C", even if it existed. It does not matter whether you call it C or Int, it is still a brand new data constructor name that has nothing to do with any type.
10:13:10 <monochrom> If you call it "Elem" it still has nothing to do with the "Elem" type. You may as well call it DieHard.
10:20:48 <linoge> Ok, say I've got this type signature: Functor f => (a -> b) -> f a -> f b
10:21:25 <linoge> this means the function is receiving a function that maps a to b, a functor applied to 'a' and returns a functor applied to b ?
10:21:45 <dassie> monochrom: What is the right way then?
10:22:24 <monochrom> data MaybeElem = Has Elem | Terminator
10:22:40 <ertesx> linoge: yeah
10:23:12 <monochrom> it is like why you have "A" and "B". data constructor name, then afterwards you can enter type names.
10:23:39 <dassie> monochrom: so I would then write Has (B Has (B Terminator))) ?
10:23:47 <monochrom> data MaybeElem = Sarah Elem | Terminator
10:23:52 <monochrom> yes
10:23:59 <ertesx> linoge: one minor thing to note: for a functor f, it takes *the* functor f applied to 'a' and the (same) functor f applied to 'b'
10:24:28 <dassie> monochrom: Well, IIRC that is exactly what I tried, and it did not work either
10:24:40 <dassie> monochrom: Let me give it another shot
10:25:58 <linoge> ertesx: thanks :). I'm making my way through learning FP but doubts arise sometimes ^^
10:26:02 <monochrom> you should isolate the cause, not wait for genetic evolution to solve the problem
10:26:02 <dassie> monochrom: No, my memory failed me - it works
10:26:48 <dassie> monochrom: thank you
10:28:40 <dassie> monochrom: uses look concise in Scala: B(B(Terminator)), so I hoped it would be just as dense in Haskell
10:29:50 <dassie> monochrom: not that it matters much cause I would only create new elements in a few functions
10:30:54 <monochrom> is there any reason why the scala version even needs B?
10:31:55 <monochrom> I am ignorant but I am logical. all the more lethal because I will apply self-consistency tests irregardless of "well known wisdom" and in fact debunk them.
10:33:43 <monochrom> Suppose "B(B(Terminator)" makes sense. Then what is B's type? Actually I just need the domain.
10:33:49 <dassie> monochrom: I am not sure I understand your question. My intent was to have the type system enforce the constraint that the sequence may not end in A.
10:34:22 <dassie> monochrom: In Scala I have 
10:34:40 <dassie> sealed abstract class MaybeElem
10:34:41 <monochrom> Since "B(B...)" makes sense, the first B has domain Elem. Since "B(Terminator)" makes sense, the second B has domain MaybeElem. Elem != MaybeElem. Contradiction.
10:35:02 <dassie> sealed abstract class Elem
10:35:18 <dassie> case class Terminator extends MaybeElem
10:35:19 <maerwald> @pl (\x -> (P.</>) fp <$> (parseMaybe . snd $ x))
10:35:19 <lambdabot> ((fp P.</>) <$>) . parseMaybe . snd
10:35:33 <dassie> case class A(next: Elem) extends Elem
10:35:55 <dassie> case class B(next: MaybeElem) extends Elem
10:36:28 <dassie> So both A(something) and B(something) have type Elem
10:37:05 <dassie> But in the case of A() that something has to be Elem too
10:37:30 <dassie> kinda OOP meets FP
10:37:47 <monochrom> then B( B(Terminator) :: Elem ) does not make sense.
10:38:21 <monochrom> generally B( whatever :: Elem ) does not. just that today whatever = B(Terminator).
10:38:29 <dassie> monochrom: Yes, I see that now
10:39:46 <dassie> monochrom: Gotta pick up reading RWH from Chapter 1
10:40:14 <dassie> monochrom: Dropped it long ago after five chapters
10:43:33 <dassie> monochrom: thanks again
10:43:39 <dassie> bye
10:44:32 <f00f00> Hi!
10:44:59 <f00f00> If I have a function "foo [a, b, c] = [b, a, c]", what happens under the hood?
10:45:08 <f00f00> More generally, what happens with that kind of pattern matching?
10:45:16 <f00f00> (how is it desugared?)
10:45:39 <ertesx> f00f00: foo (a : b : c : []) = b : a : c : []  -- that's the desugaring
10:45:52 <ertesx> if you give it a three-element list, it gives you a reordered list
10:46:07 <ertesx> and if that's the only clause, then the function crashes at run-time, if you give it any other list
10:47:31 <monochrom> I wonder if you want to desugar one step further.
10:47:49 <Cale> f00f00: It desugars into nested case expressions which match on one (:) at a time
10:48:04 <f00f00> ertesx: thanks! That's elegant. I assume it's the same with lists of lists?
10:48:18 <monochrom> foo v = case v of a : w -> case w of b : x -> case x of c : y -> case y of [] -> b : a : c : []
10:49:20 <monochrom> it is ok if you ask me to desugar 10 more steps further. at which point I'll just ask GHC to do it for me, then I give you the asm code.
10:59:37 <ertesx> f00f00: yes, you can pattern-match everything that has exposed constructors
10:59:59 <ertesx> f00f00: foo (Just (Left [Bool, x])) = ...
11:00:22 <ertesx> as deep as you want
11:01:16 <ertesx> and you can pattern-match some things that don't have exposed constructors:  f 15 = ...  -- Int technically doesn't expose its constructors, but you can still pattern-match, because it is Num and Eq
11:01:49 <hsk3> In GHCi, ":l foo.hs" respects my ":set -Wall" setting, but ":r" doesn't. I always have to type the full ":l foo.hs".
11:01:50 <hsk3> This is tedious. Is there a way to make ":r" show the warnings?
11:03:00 <monochrom> that's strange
11:04:30 <monochrom> cannot reproduce. :r respects a past :set -Wall. I am still seeing warnings.
11:04:39 <hsk3> hmm
11:05:02 <hsk3> monochrom: What if you repeat the :r
11:05:06 <hsk3> does the warning keep showing up?
11:05:22 <hsk3> :r only shows the warning the first time. is it detecting that the file was unchanged or something?
11:05:25 <monochrom> with file change? without file change?
11:06:11 <monochrom> you need to change the file for :r to do work.
11:06:15 <hsk3> So apparently, :r doesn't do anything if the file is unchanged.
11:06:16 <hsk3> But :l loads the file again, even if it's unchanged.
11:06:18 <hsk3> ah ok
11:06:30 <hsk3> is there a way to get --force-recomp into GHCi?
11:06:58 <monochrom> yes, apparently :set accepts that too
11:08:21 <monochrom> but you have to spell it right. -fforce-recomp. one dash, two f's
11:09:01 <hsk3> sweet, thanks
11:12:02 <ertesx> i think unless you use -fobject-code it doesn't have an effect
11:12:15 <ertesx> but i can confirm that both work in GHCi
11:25:22 <NeverDie> Should there EVER be any reason why you'd store data as HTML inside a database?
11:26:00 <ryantrinkle> NeverDie: sure; if you're scraping pages for archival purposes, e.g. like archive.org
11:26:17 <ertesx> NeverDie: yes: when the database system doesn't give you a more appropriate type, or when you want to keep the exact syntax around, potentially with malformedness
11:28:06 <NeverDie> ertesx: Isn't that rather messy?
11:28:23 <monochrom> why do you ask?
11:28:38 <ryantrinkle> NeverDie: sometimes data is *actually* messy, and there's no avoiding it :)
11:28:44 <ryantrinkle> however, it's usually best to avoid it when possible
11:30:31 <NeverDie> monochrom: Because a database I'm working with has it's data stored in HTML.
11:30:40 <NeverDie> Some of it for descriptions of things.
11:30:47 <NeverDie> And I can't fathom a logical reason for this lol.
11:31:24 <Oejet> NeverDie: You could store the HTML in files, and their metadata in the database, but perhaps storing it directly in the database is more convenient (meaning less code).
11:31:26 <ryantrinkle> NeverDie: maybe they wanted to have a way of representing formatting, e.g. bold, italics, links, etc.
11:31:35 <ryantrinkle> not necessarily a good decision, but that might be the reasoning
11:31:40 <monochrom> then you should ask about a reason or anti-reason for this particular database, not other people's databases.
11:31:59 <NeverDie> I mean I can see "why" they did it.
11:32:16 <NeverDie> But I just want to be sure that I'm not missing anything, and that it could possibly be a good idea after all.
11:32:22 <ertesx> NeverDie: it depends on your priorities: some applications need originality more than correctness/precision
11:32:36 <NeverDie> But I seriously can't see how limiting your data that way would be any good or not normalizing it even further without the HTML tags.
11:33:52 <ertesx> NeverDie: if it's for formatting, well, you need *some* syntax for it…  i don't know a database that supports "rich text"
11:33:58 <ertesx> in a first-class way that is
11:34:34 <NeverDie> ertesx: Yeah but why wouldn't you normalize it and then just display it accordingly by attaching the tags after?
11:35:10 <ryantrinkle> NeverDie: well, then you have to invent a format for rich text, no?
11:35:20 <monochrom> no, the right question is: why don't you do that?
11:35:22 <ertesx> NeverDie: well, perhaps the programmer lacked the tools or even the skills to get something more appropriate into the DB
11:35:41 <monochrom> it's your database. not mine. not ertesx's. why don't you do what you just said to yours?
11:35:49 <NeverDie> It's not mine.
11:35:53 <NeverDie> It's the client's lol.
11:36:02 <monochrom> ok, debate with the client.
11:36:16 <monochrom> in fact, I'm sure you can silently make the change too
11:36:27 <NeverDie> Wanted to see everyone's take on it before bringing it up. But I'm just sticking to parsing it for now.
11:36:47 <monochrom> everyone does not know the context of your client's database.
11:36:55 <monochrom> therefore everyone is BSing.
11:37:31 <monochrom> wanna see everyone's out of the blue BS before bringing it up to the client? great plan.
11:38:05 <ertesx> NeverDie: you probably don't want to bring it up
11:38:17 <ertesx> and if you do, with a lot of caution
11:38:41 <NeverDie> ertesx: Yeah I'm not going to bring it up.
11:50:30 <Zemyla> When using Parsec or Megaparsec, what are the advantages and disadvantages of tokenizing manually?
11:56:19 <LordKan> hei guys ,any tips on making a function that receives a generator and returns an infinite array of random numbers and another generator?   g -> ( [Int], g )
11:56:37 <Zemyla> LordKan: Use split and then randoms/randomRs.
11:58:19 <Zemyla> infRandR s g = case split g of (gl, gr) -> (randomRs r gl, gr)
12:17:35 <maerwald> wooow... using patternsynonyms with record selector syntax actually makes ghc panic
12:28:02 <orion> So, before I asked if I could suspend a Free monad. I left out one important detail: I need to resume the computation after information (i.e, bytes from a socket) have been received, and the computation needs to know what those bytes are.
12:30:34 <ertesx> orion: example:  Free ((->) ByteString)
12:31:25 <ertesx> await :: Free ((->) ByteString) ByteString;  await = wrap id
12:31:57 <ertesx> now during interpretation whenever you get a Free, you have to supply a ByteString to continue
12:32:48 <ertesx> ('await' more generally has the type:  (MonadFree ((->) e) m) => m e
12:33:11 <ertesx> so you can use it with Free, FreeT, F, FT, etc.
12:42:55 <shanemikel> huh.. why doesn't darcs.net appear to support ssl?
13:50:26 <stulli> Is there a way to completely disable typed holes? I have a function (from a 3rd party library) which starts with an underscore and I cannot compile my code anymore because GHC(JS) thinks it's a typed hole...
13:54:31 <monochrom> oh, yikes
13:56:16 <monochrom> but your problem may have another cause.
13:56:18 <bergey> That's strange.  I have many functions which start with underscores, and I've never had trouble calling them.
13:56:40 <bergey> Only, if I miss an import or typo the function, the error message is completely misleading =(
13:56:54 <monochrom> I tried this code: "f _x = _x + 1". No type-hole message. f behaves as \y -> y + 1
13:57:07 <geekosaur> I thought named typed holes only applied to names not otherwise in scope? (and not to defining those names since those can't be holes anyway)
13:57:12 <monochrom> in other words, you may have a genuine not-in-scope error
13:58:17 <monochrom> which means disabling typed holes would not lead to successful compilation
13:58:46 <monochrom> anyway, the scientific evidence against the theory is "f _x = _x + 1"
13:59:57 <stulli> that might be the case, it seems the api changed since I last compiled...
14:00:15 <monochrom> typed holes have no hair because they only have mass, momentum, angular momentum, and type.
14:01:10 <monochrom> but yeah would be nice to have a disable option. I can't find one.
14:03:47 <tobiasBora> Hello,
14:04:07 <tobiasBora> I would like to know what is the simplest way to read a single mp3 file in Haskell.
14:04:26 <tobiasBora> (I don't want to do complicated stuff, just reading)
14:05:14 <monochrom> but you can defer it. -fdefer-typed-holes. you get a warning, but not an error. compilation proceeds with undefined
14:05:59 <monochrom> not sure whether it's an improvement or it's a time bomb
14:06:37 <mauke> tobiasBora: Data.ByteString.readFile
14:07:05 <tobiasBora> mauke: When I say read I mean play, sorry
14:08:10 <monochrom> no, compilation does not proceed with undefined. it proceeds with GHC panic. :)
14:09:26 <monochrom> oh interesting, it doesn't always panic.
14:10:15 <monochrom> "main = print (_x :: Int)"  ghc -fdefer-typed-holes -> documented behaviour
14:10:19 <stulli> monochrom: I was able to compile with -fdefer-typed-holes (of course it crashed when I actually ran the part with the _)
14:10:31 <monochrom> "f x = _x + 1; main = print (f 5 :: Int)"  ghc -fdefer-typed-holes -> GHC panic
14:15:47 <stulli> Anyway, it works now. Thanks for the hint, I would have taken me some time to realize that.
14:17:44 <NaOH> Hi, a quick style question: I'm writing some code that uses a Data.Vector.Unboxed to store a square 2D-Grid, so I use "x" and "y" and a helper function "getElem" which transform x and y to an index into the vector "i". Now, as I wrote my code, I found myself using foo :: Int -> Int -> ... and bar :: (Int,Int) -> ... to take x and y. So now I am cleaning the code and I must decide wich one to use. Do you see any inherent advantge of o
14:18:47 <maerwald> anyone has a nice config for hsimport?
14:22:54 <Cale> NaOH: Your message was cut off at "Do you see any inherent advantage of" by the line length limit. Usually in Haskell we like to have functions which are curried, but if you're using pairs of indices everywhere, it might turn out to be more convenient to keep them paired. It really depends on context.
14:25:26 <NaOH> Cale: Yes, the question was if there was any reason why one way would be better over the other. I guess you have answered that, thanks, I guess that while in my use case it makes sense to keem them paired, having the abilty to curry the functions seems a more general solution
14:27:38 <Cale> NaOH: It's nice when you go to write things involving higher order functions sometimes, to be able to specialise on one parameter at a time. Say you were writing something which operated on a single column of the grid, you could specialise the x-coordinate by partially applying getElem, and maybe that's a bit nicer (and maybe even performs a bit better) than using a lambda and constructing pairs.
14:29:42 <Cale> NaOH: So usually in Haskell, you want to arrange your arguments in order of "increasing rate of change" in some sense -- with the more "constant-like" or "configuration-like" parameters first, and the ones which vary more frequently later.
14:32:16 <NaOH> Cale: oh that makes sense, I will definetly keep that in mind while refactoring, as right now I have a mess with some "configuration-like" parameters that I added ad-hoc and are all over the place in different functions, it would make sense to arrange those first
14:33:17 <cheater> NaOH: on the other hand, if you want to use higher dimensionalities in the future, you're pretty much bound to having a single parameter for carrying all the vector coefficients
14:38:44 <NaOH> cheater: that is true, but my code has the asumption of a square 2D-grid so deeply ingrained that I think that the indices to access the vector would be the least of my worries if I ever want to modify this to higher dimensions xD
14:50:01 <Gurkenglas> Is there more to the question of "should it be s -> (a, s) or s -> (s, a)" than everything going to hell if the decision is not unanimous?
14:51:42 <nitrix> Is there such thing as a forM that folds (keeps an accumulator) ?
14:52:10 <nitrix> foldM ?
14:52:10 <mniip> Gurkenglas, clearly s -> (s, a)
14:52:13 <nitrix> :t foldM
14:52:14 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
14:52:23 <nitrix> Brilliant :)
14:52:27 <mniip> Join (Compose ((->) s) ((,) s))
14:52:36 <mniip> er
14:52:45 <mniip> that was nonsense
14:54:25 <Gurkenglas> s -> (a, s) = EndoT ((,) a) s
14:54:55 <Gurkenglas> s -> (s, a) = Compose ((->) s) ((,) s) a
14:55:24 <Gurkenglas> Whence State?
14:56:28 <carter> Cheater i misread your remark as being about homotopies :)
14:57:00 <picobit> nitrix: hi.
14:57:13 <picobit> nitrix: pm.
15:00:49 <nitrix> picobit: added
15:01:18 <mniip> Join (Compose (Compose (,) Compose) (->))
15:01:26 <mniip> too bad the typesystem isn't versatile enough
15:01:46 <adarqui> in template haskell, will newName ALWAYS give me a fresh name, if i'm calling my template haskell function twice? or no?
15:05:44 <chicken> //join #ruby
15:07:18 <adarqui> it seems to be using 'counter' which is supposed to be global
15:07:36 <Zemyla> Does anything know enough about the "these" package to know when something is an instance of Crosswalk?
15:09:21 <Zemyla> https://hackage.haskell.org/package/these-0.6.2.1/docs/Data-Align.html#t:Crosswalk
15:18:06 <adarqui> newName doesn't seem to be giving me a new name, i'm just getting the var i'm supplying to newName: ie, newName "x" >>= runIO . putStrLn is giving me "x", not "x0" or something like that
15:19:09 <c_wraith> adarqui: run it twice.
15:19:34 <adarqui> i am
15:19:41 <Mateon1> Hello, I'm having some minor issues with GHC under MSYS2, namely insignificant GHC panics with standard IO when piping to other programs and MSYS devices. Should I report those?
15:19:48 <adarqui> i'm loading this from the repl, it always gives me back simply the var name i supply to newName
15:20:11 <c_wraith> adarqui: liftM2 (,) (newName "x") (newName "x") >>= runIO . print
15:20:32 <c_wraith> adarqui: that is, run it twice in the same context.
15:21:20 <adarqui> ah
15:21:29 <adarqui> that worked.. ok i need to rethink this then
15:21:30 <adarqui> thanks
15:24:48 <Cale> adarqui: Note that newName-generated names can capture other names (which is sometimes incredibly annoying). So if you use newName "x" to generate the variable name for a lambda, and then mkName "x" gets used in the body of the lambda, the mkName'd variable will refer to the lambda's parameter.
15:25:56 <Cale> TH doesn't presently have a way, as far as I can tell, to produce totally-non-interacting names.
15:26:51 <Cale> er... did I actually say the right thing there?
15:27:18 <Cale> ... yes, I think so :)
15:27:52 <Cale> yeah, see the docs for newName here: https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#v:newName
15:28:54 <ZaneWeb> Everyone - go to #bobjone
15:29:01 <Cale> Sometimes it's really hard to avoid what's going on in that second example there (e.g. because you have a quasiquoter with user code in it which really needs to have its variables mkName'd)
15:29:08 --- mode: ChanServ set +o Cale
15:29:13 --- mode: Cale set +b *!*@65.78.181.199
15:29:13 --- kick: ZaneWeb was kicked by Cale (ZaneWeb)
15:29:20 --- mode: Cale set -o Cale
15:29:47 <maerwald> should I not go to that channel?
15:30:05 <c_wraith> maerwald: It would probably be wise.
15:30:10 <maerwald> ok
15:47:43 <adarqui> cale, thanks
15:51:46 <Gurkenglas> Does some language extension allow me to use indentation blocks instead of brackets?
15:52:07 <c_wraith> That's part of the base language.  Shouldn't need an extension.
15:52:20 <c_wraith> But the indentation rules have some picky bits.
15:52:24 <Mateon1> But that's only for do, let, and where notation
15:52:29 <Mateon1> Isn't it?
15:53:08 <c_wraith> Hmm.  True, you can't use indentation for records.
15:54:36 <monochrom> also case
15:57:38 <Gurkenglas> I mean round brackets in code :D
15:58:14 <geekosaur> no, you can't replace parentheses with indentation
15:58:33 <Mateon1> I wish you could, there's only so much you can do with $ and .
15:58:39 <Gurkenglas> (Something akin to a preprocessor that puts round brackets around every indentation block in a ='s context)
15:58:55 <geekosaur> I would expect some ambiguity tbh
15:59:17 <Gurkenglas> How could that possibly be ambigous
15:59:24 <Gurkenglas> *u
15:59:45 <Mateon1> It may be possible to stretch ($) and (.) quite far, but the code becomes incomprehensible. I've seen usage of (func.).otherfunc
16:00:11 <Gurkenglas> (Dear reader, use func .: otherfunc instead)
16:01:20 <Mateon1> Gurkenglas: Which module does that come in?
16:02:28 <Gurkenglas> Not really any unfortunately but I keep using it :P "infixr 8 .:; (f .: g) x = f . g x" (compare to (f . g) x = f $ g x
16:02:29 <Gurkenglas> *)
16:05:22 <Ankhers> Does anyone have experience with ghcjs and stack? I'm trying to use the ghcjs template, but it apparently does not work correctly. Does anyone have any insights? http://lpaste.net/160198 is what I get as output when trying to create a project.
16:07:13 <Ankhers> If it makes a difference, I'm on OSX using stack version Version 1.0.4.3 x86_64 installed from homebrew.
16:08:43 <Lokathor> unsafeNew :: Int -> m (v a)
16:08:43 <Lokathor> Create a mutable vector of the given length. Length is not checked!
16:09:10 <Lokathor> what does "length is not checked" imply here? Like i'm still okay if it's a positive int, right?
16:09:23 <Zemyla> Lokathor: Yeah. It doesn't check if it's negative.
16:17:34 <adamCS> Ankhers:  I haven't tried the template but I've gotten stack + ghcjs working (with the 20151230 version of ghcjs).  With many versions of stack, including the latest.
16:18:56 <Ankhers> adamCS: Thanks. I guess I will avoid the template for now.
16:19:56 <bernalex> please help me figure out what people (you!) don't like about haskell: https://www.reddit.com/r/haskell/comments/4f47ou/why_does_haskell_in_your_opinion_suck/
16:19:59 <adamCS> Ankhers: http://pastebin.com/7PgkLvdf
16:21:04 <Ankhers> adamCS: Thanks. I'll try to get that setup.
16:21:34 <adamCS> Ankhers:  One thing I find confusing is that all the ghcjs releases are still based off of ghc 7.10.2 ( I think) but those later resolvers are based on ghc 7.10.3.  But they seem to work for lots of people.  So I don't think that's your problem. 
16:22:14 <adamCS> Ankhers:  And you can ignore all that stuff from github.  Just wanted you to have ghcjs tarball and resolver + extra-deps that seems to work.  Good luck!
16:22:46 <Ankhers> adamCS: Thanks!
16:26:42 <Lokathor> anyone around care to help with type gymnastics? i've got a func, rollChance :: (Random i, Integral i, MonadRandom m) => i -> m Bool
16:27:00 <Lokathor> and I want to use it with the replicateM from Data.Vector.Mutable
16:27:07 <Lokathor> replicateM :: PrimMonad m => Int -> m a -> m (MVector (PrimState m) a)
16:27:29 <Lokathor> but i'm not clear on where I put the lifting, or if i can mix these things at all
16:29:44 <monochrom> I think IO satisfies both MonadRandom and PrimMonad. so this can be done.
16:29:46 <scshunt> Lokathor: well, what happens when you put them together the way you're thinking of?
16:30:08 <Lokathor> I wanted to make a new MVector within runST, was my idea
16:30:09 <scshunt> IO doesn't have an instance of MonadRandom
16:30:37 <scshunt> Lokathor: Right, but I mean, if you try to use it, what is the result?
16:30:39 <Lokathor> I think I can stack RandT on top of (ST s) and have it work?
16:30:55 <monochrom> replicateM 300 (rollChance 42) :: IO (IOVector Bool)
16:31:10 <scshunt> monochrom: definitely no MonadRandom instance there
16:31:20 <Lokathor> oh, well the result is a vector of the bool outputs.. if that's what you're asking?
16:31:32 <scshunt> Lokathor: Should work. You may need to define an instance (PrimMonad m) => PrimMonad (RandT m)
16:31:35 <scshunt> err
16:31:55 <scshunt> RandT g m
16:31:59 <Lokathor> which i will then manipulate some more before finally returning it up out of the ST
16:33:41 <Lokathor> scshunt, wait what instance? I'm confused
16:34:10 <scshunt> Lokathor: MonadRandom doesn't have a lifting instance of PrimMonad
16:34:12 <scshunt> err
16:34:15 <scshunt> RandT doesn't
16:34:19 <scshunt> you may need to define one
16:35:18 <Lokathor> So I want... (PrimMonad m, RandomGen g) => MonadRandom (RandT g m) ?
16:39:42 <Lokathor> I'll just do it using a normal vector
16:39:55 <Lokathor> seems much simpler
16:52:22 <Denart_> Have somebody tried stream coding trough https://www.livecoding.tv?
16:55:15 <Lokathor> never heard of it, seems cool though
16:55:26 <markolo25> hello
16:55:27 <markolo25> :D
16:55:36 <markolo25> when i make a function
16:55:47 <markolo25> is there any way to dictate the parameter data type?
16:55:56 <Lokathor> yes
16:56:01 <Lokathor> you can add a type signature
16:56:09 <markolo25> is it the :: Int -> Int 
16:56:11 <markolo25> thing?
16:56:12 <Lokathor> yes
16:56:14 <markolo25> kk
16:56:20 <Lokathor> Int -> Int means, "takes 1 int, returns 1 int"
16:56:35 <markolo25> ok
16:57:06 <Lokathor> and Int -> String -> String would be "takes an int and then a string, returns an int", and so on
16:57:07 <markolo25> sometimes I get a compilation error that says it expects an IO() 
16:57:15 <markolo25> but i'm sending it an Int
16:57:24 <Lokathor> ah, that would be a problem, yes
16:57:29 <Lokathor> what are you trying to write?
16:57:43 <markolo25> let me grab it really quick
16:58:13 <markolo25>  fac :: Int -> Int
16:58:15 <markolo25>   fac n = if n == 0 then 1 else n * fac (n - 1)
16:58:16 <markolo25> I had that
16:58:31 <Lokathor> classic
16:59:08 <markolo25> it works as a let  fac n = if n == 0 then 1 else n * fac (n - 1)
16:59:17 <markolo25> but it dosen't work if it's a function
16:59:50 <markolo25>  nvm
16:59:55 <markolo25> I was reading through my code
17:00:03 <markolo25> and I was sending it a getLine
17:00:05 <markolo25> -_-
17:00:08 <markolo25> it's all good
17:00:10 <Lokathor> ah, i see
17:00:33 <markolo25> last problem, if my numbers get to big
17:00:35 <Lokathor> getLine's value isn't an int, it's an IO String, so you need to get the String "out" of it, and then convert that String into an Int, and then you can use it with fac
17:00:37 <markolo25> i get an infinite
17:01:52 <markolo25> https://scontent-lax3-1.xx.fbcdn.net/hphotos-xpa1/v/t1.0-9/12990937_1317536378261452_8539300788859087283_n.jpg?oh=68aaef94a8b0d31e1a815e822377196d&oe=577CCC05
17:02:10 <markolo25> is there a way to get a number?
17:02:13 <Lokathor> hmm
17:02:28 <Chobbes> Is there any reason why accessing a value from a data structure in a function would cause the program to freeze? If I acccess the position of the ball in ballPaddleCollide everything freezes, gloss stops updating, I assume that the program has crashed, but gloss caught signals, or something is in a loop... https://github.com/Chobbes/ReflexPong/blob/master/src/Physics.hs#L44
17:02:29 <Welkin> check if the string is a number
17:02:40 <monochrom> yes, 4242 factorial is huge, will be infinity if you use (IEEE 754 double precision floating point)
17:02:47 <markolo25> ok
17:02:59 <Lokathor> yeah try with a smaller number
17:03:03 <Lokathor> like 8
17:03:36 <Chobbes> If I use Debug.Trace to print the position of the ball before calling the function everything is fine. Only breaks with the ballPaddleCollide function, fine with ballWallsCollide too. I'm very confused.
17:04:02 <markolo25> it only works up to 34
17:04:09 <markolo25> thanks monochrom and Lokathor
17:04:15 <markolo25> i didn't know double had limits
17:04:28 <Lokathor> you can put an Integer -> Integer on fac
17:04:34 <Lokathor> and it won't have overflow problems
17:04:38 <Lokathor> but it might take a loooooong time to compute
17:04:41 <monochrom> http://floating-point-gui.de/
17:04:46 <markolo25> I made it a double/float
17:05:24 <markolo25> since it would return junk data when the numbers got big enough
17:05:34 <markolo25> ah
17:05:42 <markolo25> i see what you're saying
17:06:23 <Lokathor> Int is a bounded type, Integer is an unbounded type (that performs a little worse, but when you need it you need it)
17:06:41 <markolo25> thank
17:08:00 <Welkin> I can't imagine any practical case in which you *need* Integer though
17:08:21 <Lokathor> well, what if i want to reprisent a number that's 2^65+1 ?
17:08:26 <Chobbes> Welkin: I've used Haskell in my combinatorics class. It's useful for counting ;).
17:08:29 <markolo25> in java Integer had functions that int didn't have
17:08:29 <Lokathor> or 2^86 + 7
17:08:51 <Chobbes> markolo25: in Java Integer is an object, but int is a primitive data type, no?
17:08:56 <markolo25> yes
17:09:02 <markolo25> the object had methods
17:09:18 <markolo25> that could manipulate the value
17:09:27 <Lokathor> note that an int in java is always 32 bit, but an Int in haskell is 32bit or 64bit based on the platform you're on
17:09:28 <markolo25> while the primitive data type didn't
17:09:33 <markolo25> wait
17:09:36 <markolo25> why have a double then?
17:09:42 <markolo25> are there doubles?
17:09:44 <Chobbes> Lokathor: Int is only guaranteed to have 31 bits of precision.
17:09:53 <Lokathor> there are doubles
17:10:04 <Lokathor> but 2.2 isn't an int no matter how many bits you have, for example
17:10:11 <Lokathor> Also, yes, Chobbes is correct
17:10:12 <markolo25> is the 64 bit called int64 or something
17:10:19 <markolo25> ahh
17:10:20 <markolo25> kk
17:10:24 <markolo25> so higher numbers
17:10:46 <Chobbes> Lokathor: correct but nit-picky :).
17:11:47 <Lokathor> actually there's both Int (with at least 31 bits of precision and possibly more) and also Int8, Int16, Int32, and Int64, each of which have their specified number of bits exactly at all times
17:12:47 <hpc> 30 bits
17:12:56 <hpc> is what's guaranteed
17:13:09 <c_wraith> GHC always makes it 32 or 64, though
17:13:10 <hpc> ghc makes Int match your processor's word size
17:13:21 <Lokathor> "A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]."
17:13:25 <Lokathor> doesn't that mean 29 bits?
17:13:30 <hpc> sign bit
17:13:37 <Lokathor> oh right
17:13:57 <Lokathor> okay, so, there's bits
17:13:59 <hpc> and just for completeness, the Word types are Int but unsigned
17:14:01 <Chobbes> Twos complement.
17:14:49 <orion> 12:30:12 < ertesx> orion: example:  Free ((->) ByteString)
17:15:03 <orion> await :: Free ((->) ByteString) ByteString;  await = wrap id <-- what is wrap?
17:16:13 <clever> ive got an issue with a Data.Binary.Get parser and lazy bytestrings, the file format is a series of length prefixed strings, some of them 100mb in size, and i never reference the lazy bytestring refering to that 100mb string, but strace confirms haskell is still reading the entire file at runtime
17:16:26 <clever> is there any way to make the disk IO more lazy?
17:17:13 <clever> so if i try to read 100mb from the file, it just saves the offset+FD# into a thunk, and seeks ahead, defering the disk io until later
17:17:18 <hpc> honestly, you probably just want to tweak your code to not be reading the parts you don't need
17:17:38 <hpc> or... actually maybe that
17:18:05 <hpc> except i wouldn't make that lazy either, i'd make it some data type and then an action to do seek, read, seek back, return
17:18:06 <clever> i'm trying to make full use of the lazy thunks, to read things on-demand
17:18:21 <monochrom> unsafeInterleaveIO is the source of lazy I/O
17:18:28 <hpc> tying IO execution to thunk evaluation very rarely ends well
17:18:43 <monochrom> usually it ends hilariously
17:18:53 <clever> the files i'm reading are already immutable
17:19:04 <monochrom> http://lpaste.net/77374
17:19:12 <clever> one thing i have planned is to just mmap them and treat the mmap as a single bytestring
17:19:35 <monochrom> oh, mmap may be good. there is an mmap library on hackage
17:19:43 <markolo25> curry
17:19:49 <clever> https://hackage.haskell.org/package/mmap-0.5.9/docs/System-IO-MMap.html
17:20:04 <monochrom> "from the makers of bytestring"...
17:20:10 <clever> ive already got System.IO.Posix.MMap in my imports as well
17:23:29 <orion> Are there any downsides to a Coroutine (Yield ()) (State FooState FooResult) FooResult monad transformer stack?
17:25:03 <orion> Rather, is there something better?
17:26:46 <orion> The idea is that I'd do: put fooState; yield (); fooState' <- get; whenever I want to receive bytes from a socket.
17:27:30 <orion> Actually, I don't even know if that would work.
17:28:20 <Welkin> orion: just use pipes?
17:29:41 <orion> Welkin: Ideally I don't want to make pipes a requirement when people want to use this library.
17:30:29 <c_wraith> Even though what you're doing is the same thing pipes does?
17:33:36 <ntnt> in haskell naming, should JSon be JSON, JSon, or Json ?
17:33:41 <ntnt> this is for a module name
17:33:47 <ntnt> so at the very elast, the J has to be capitalized
17:34:11 <c_wraith> I don't think there's a standard convention for initialisms in haskell
17:34:27 <c_wraith> aeson defines classes named ToJSON and FromJSON
17:36:08 <ntnt> yea, what threw me off was that my JSON class basically wraps Aeson and provides some helper functions
17:36:13 <ntnt> but Aeson is Aeson, not AESON
17:36:19 <ntnt> so it's weird calling JSON JSON
17:36:35 <c_wraith> Aeson is a proper noun, not an initialism.
17:36:43 <c_wraith> JSON is an initialism, so the rules are different.
17:36:59 <c_wraith> (Aeson was Jason's father, of Jason and the Argonauts)
17:37:18 <Lokathor> tragedy puns
17:37:34 <ntnt> wow; I read greek mythology but never realized that
17:37:43 <ntnt> I should name my module GoldenFleece.hs
17:37:58 <Lokathor> module Data.Fleece.Golden where
17:41:30 <clever> orion: heh, that was easy, its gone from 0.193 sec to parse the file to 0.004
17:44:34 <clever> orion: yeah, much much faster now
17:45:01 <clever> and memory usage is no longer shooting into the gigs
17:55:07 <str0ngasfck> hi all!
17:56:28 <str0ngasfck> How can I do that function ? sump [1,2,3,4,5,6] = 1+3+5
17:56:35 <str0ngasfck> the function sum only the even positions
17:56:52 <str0ngasfck> I did that
17:56:57 <str0ngasfck> sump k xs 
17:57:06 <str0ngasfck>   | length(xs)==0 = 0
17:57:43 <str0ngasfck>   | length(xs) >0 && (k `mod` 2) == 0 = head xs + sump (k+1) (tail xs)
17:57:54 <monochrom> it is a bad idea to use length
17:58:12 <str0ngasfck>   | length(xs) >0 && (k `mod` 2) /=0 = sump (k+1) (tail xs)
17:58:19 <monochrom> write two functions, mutually recursive. one is sump. the other is "sum only the odd positions"
17:58:39 <mniip> looks like your implementation should work
17:58:48 <mniip> but like monochrom said, it's rather terrible
17:59:15 <Welkin> lol
17:59:26 <str0ngasfck> mniip: But can I do the same think with out using the k parameter ?
17:59:40 <str0ngasfck> something like sump [1,2,3,4,5]
17:59:50 <mniip> well first of all
18:00:12 <mniip> you can have sump xs = sump_ 0 xs where sump_ ...
18:00:13 <Welkin> only the even positions?
18:00:32 <Welkin> you can just pattern match to take every second element, then sum them as normal
18:00:32 <mniip> but do consider following monochrom's advice
18:00:35 <Welkin> simple
18:01:20 <monochrom> true, just make sure you have exhaustive patterns
18:07:34 <str0ngasfck> ok
18:14:09 <ntnt> is there a way to specify "-ddump-splices -dth-dec-file" on a PER FILE basis rather than GLOBALLY as a ghc option? The XY problem is as follows: I'm using TH with GHCI, "-ddump-splices -dth-dec-file" has the nice property of, printint out, in the GHCI window, all the genrated splices
18:14:19 <ntnt> however, I only want this to happen for the slices in the current file, not all slices (for debugging purposes)
18:14:21 <ntnt> Cale: ^
18:14:33 <ntnt> anyone know how to do the above or how to turn GHC options on/off just for a single file (while in GHCI)
18:15:27 <Cale> ntnt: Try using the {-# OPTIONS_GHC ... #-} pragma
18:15:47 <ntnt> Cale: will try, thanks!
18:17:47 <orion> clever: what file?
18:22:06 <ntnt>  unknown flag in  {-# OPTIONS_GHC #-} pragma: -ddump-slices
18:22:29 <ntnt> Cale: hmm, using "{-# OPTIONS_GHC -ddump-slices #-}"
18:22:50 <ntnt> gives the above error
18:26:20 <ntnt> I'm an idiot
18:26:22 <ntnt> it's splices, not slices
19:01:09 <orion> Anyone know why good articles which can demystify (->) ?
19:01:38 <johnw> demystify (->)?
19:02:18 <zRecursive> :t (->)
19:02:19 <lambdabot> parse error on input ‘->’
19:02:25 <zRecursive> :k (->)
19:02:26 <lambdabot> * -> * -> *
19:02:39 <orion> http://hackage.haskell.org/package/monad-coroutine-0.9.0.2/docs/Control-Monad-Coroutine-SuspensionFunctors.html#t:Await <-- "The Await functor instance is equivalent to (->) but more descriptive."
19:02:47 <maerwald> orion: http://stackoverflow.com/a/5316690
19:03:13 <orion> maerwald: Thanks
19:15:21 <Big_G> Is there an infix operator like bind but with the signature of fmap?
19:15:51 <c_wraith> :t (<$>)
19:15:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:16:20 <Big_G> I'm looking for the flip of that 
19:16:52 <c_wraith> :t (<$$>)
19:16:53 <lambdabot>     Not in scope: ‘<$$>’
19:16:53 <lambdabot>     Perhaps you meant one of these:
19:16:53 <lambdabot>       ‘<$>’ (imported from Control.Applicative),
19:17:11 <cschneid> Hitting an issue getting HsOpenSSL built on OSX - any ideas? https://gist.github.com/cschneid/64771e6d8adbb8539c0d6eb6add24a50
19:17:32 <cschneid> I have current openssl installed via homebrew, and pointed at in stack.yaml
19:17:33 <c_wraith> cschneid: I don't trust HsOpenSSL anyway.  It's not multi-thread safe
19:17:56 <cschneid> c_wraith: trying to use slack-api, which relies on it in turn
19:18:01 <cschneid> transitive dependencies are just GREAT! :)
19:18:19 <c_wraith> :t (<&> -- Big_G 
19:18:20 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:18:20 <Axman6> we have pure haskell SSL implementation :(
19:18:22 <c_wraith> err
19:18:28 <c_wraith> :t (<&>) -- Big_G 
19:18:29 <Big_G> :t <**>
19:18:29 <lambdabot> Functor f => f a -> (a -> b) -> f b
19:18:30 <lambdabot> parse error on input ‘<**>’
19:18:42 <c_wraith> Big_G: <&> is in lens
19:18:46 <Big_G> c_wraith, Perfect. Thanks'
19:19:36 <Big_G> Any tips for searching hoogle? I checked for m a -> (a -> b) -> m b and the only sensible item was 10 down
19:19:46 <Axman6> cschneid: that path for openssl seems odd, I would usually just add extra-include-dirs: [/usr/local/include] and extra-lib-dirs: [/usr/local/lib]
19:20:18 <c_wraith> Big_G: I actually searched lens, because I already knew it had it somewhere.
19:20:21 <cschneid> Axman6: cool, I'll give it a go, they came off of this github issue, but were meant for cabal: https://github.com/phonohawk/HsOpenSSL/issues/41
19:20:31 <c_wraith> Big_G: which isn't really a great hueristic
19:22:41 <cschneid> Axman6: got there! It was that I said /include twice, rather than /include and /lib. 
19:22:55 <Axman6> that'll do it =)
19:23:23 <cschneid> thanks a ton for the extra set of eyes. Back to trying to remember how haskell itself works :)
19:23:52 <c_wraith> cschneid: it's easy.  Just import Control.Lens and then bang on punctuation keys. :)
19:24:33 <cschneid> Hah. This is the first time in a while I have an actual, small, reasonably scoped app to write. Sit and watch some tv and see if I can get a v1 done tonight
19:25:19 <c_wraith> Lens really is amazing.  I've been writing lots of data transformations in ruby, and I keep thinking "this'd be easy if I had lens"
19:26:45 <Axman6> "But lens is just the hard way of doing what we've been doing in OOP for years!"
19:27:59 <c_wraith> ggVGc: Did you ever get around to watching that vid?
19:29:17 <Zemyla> @pl \f x -> ($ x) <$> f
19:29:17 <lambdabot> flip ((<$>) . flip id)
19:29:36 <Zemyla> Is there a name for that operator?
19:29:47 <c_wraith> :t (<&>)
19:29:48 <lambdabot> Functor f => f a -> (a -> b) -> f b
19:29:53 <c_wraith> From lense.
19:29:57 <c_wraith> *lens
19:30:15 <Axman6> :t \f x -> ($ x) <$> f
19:30:16 <lambdabot> Functor f => f (a -> b) -> a -> f b
19:30:24 <c_wraith> oh
19:30:37 <Axman6> f <*> pure a
19:30:49 <c_wraith> :t (??)
19:30:50 <lambdabot> Functor f => f (a -> b) -> a -> f b
19:31:06 <c_wraith> Still from lens
19:31:48 <c_wraith> Does it have the right fixity to use inline?
19:32:08 <c_wraith> > (+) <$> Just 1 ?? 2
19:32:10 <lambdabot>  Just 3
19:32:18 <c_wraith> it appears to!
19:32:42 <c_wraith> > (,,) <$> Just 1 ?? 2 <*> Just 4
19:32:44 <lambdabot>      Could not deduce (Num a0)
19:32:44 <lambdabot>      from the context (Num a, Num a1, Num (Maybe (a1 -> b)))
19:32:44 <lambdabot>        bound by the inferred type for ‘e_1124’:
19:32:57 <c_wraith> Guess not. :(
19:33:07 <Axman6> :(
19:34:35 <c_wraith> It's infixl 1, needs to be infixl 4 to work inline
19:40:47 <dolio> How were you wanting that to parse?
19:41:43 <Zemyla> > ((,,) <$> Just 1 ?? 2) <*> Just 4
19:41:45 <lambdabot>  Just (1,2,4)
19:41:52 <Zemyla> I think that's how.
19:42:19 <dolio> Oh.
19:43:17 <c_wraith> yes
19:43:43 <c_wraith> (??) would need to be the same precedence as <*> and <$> for that to work.
20:03:11 <GlenZhang> hello
20:05:30 <GlenZhang> how to question? what's the monand?
20:05:51 <Lokathor> what?
20:07:17 <c_wraith> GlenZhang: Monads aren't all that important.  Study simpler features of the language for a while.
20:07:55 <GlenZhang> i first use freenode of #haskell, how to question？ have those taboo?
20:08:08 <c_wraith> GlenZhang: Monads are actually very simple, but you need to absorb a lot of the language before they make sense.
20:08:08 <GlenZhang> thanks
20:08:43 <c_wraith> GlenZhang: asking questions is fine, but your english is difficult for some of us to follow.  Nothing personal. :(
20:44:43 <YellowOnion> is there a point free version of \a -> [a] ?
20:45:01 <YellowOnion> @pf \a -> [a]
20:45:02 <lambdabot> Maybe you meant: pl bf
20:45:22 <YellowOnion> @pl \a -> [a]
20:45:22 <lambdabot> return
20:45:46 <Tene> YellowOnion: 'pure'
20:47:12 <YellowOnion> Tene, problem with both pure, and return is they are ambiguous
20:47:35 <Tene> YellowOnion: Ambiguous how?
20:47:37 <c_wraith> :t (:[]) -- robot monkey
20:47:39 <lambdabot> a -> [a]
20:48:11 <c_wraith> Tene: the return type has more polymorphism than the input.
20:48:12 <Lokathor> mySingleton :: a -> [a]; mySingleton = pure -- how about that :3
20:48:40 <YellowOnion> c_wraith, your first example I think works.
20:49:14 <YellowOnion> sweet its working
20:53:02 <YellowOnion> Lokathor, I guess that would work too, but I wanted something smaller than the lambda.
21:03:56 <fresheyeball> hello out there
21:04:02 <fresheyeball> I am pulling my hair out with Servant
21:38:39 <Zemyla> Hmm, question. Is there a library where HTML is output through a monad, like bold $ do { italic $ put "This is bold italic"; put "This is just bold" }?
21:40:56 <bitemyapp> Zemyla: Lucid comes to mind
22:11:19 <YellowOnion> Could someone give me some tips with stopping space leaks?
22:19:08 <oconnorct1> Hallo, I am finding haskell REALLY hard to learn :P
22:21:30 <YellowOnion> oconnorct1, specifics?
22:22:03 <YellowOnion> what material are you reading?
22:22:27 <oconnorct1> Well, I think the material is great
22:22:56 <oconnorct1> I think it is called, "Learn you Haskell for Great GOod"
22:23:28 <oconnorct1> And I write in Javascript and Java and sometimes C. I don't see myself as a n00b with programming. I just can't wrap my brain around this subject
22:23:47 <oconnorct1> And i LOVE math, so I don't udnerstand why I can't fathom the structure
22:24:01 <YellowOnion> oconnorct1, Ahh I find myself going to that as a reference, but couldn't write code after reading it.
22:24:30 <oconnorct1> OH. ok. Great! Do you recommend I start somewhere else?
22:24:50 <oconnorct1> It's written so intelligently I felt frustrated I wasn't digesting it enough to start thinking on my own
22:26:01 <Pessimist> oconnorct1, how you learned C?
22:26:01 <YellowOnion> oconnorct1, maybe try: https://github.com/bitemyapp/learnhaskell#how-to-learn-haskell
22:26:47 <YellowOnion> oconnorct1, can't really vouch for it because I learnt the hard way haha.
22:27:43 <oconnorct1> LOL, ok! THanks! Yes, C was my first language. I actually enjoy pointers, said it is not in Java.
22:27:58 <oconnorct1> thanks for the link! I will check it out!
22:41:48 <oconnorct1> Hey are you still there?
22:41:53 <oconnorct1> I went to the website you recommended
22:42:06 <oconnorct1> and I loaded the modules with ghci, but I don't know how to read them
22:44:16 <liste> oconnorct1: what modules did you load?
22:45:14 <oconnorct1> I just typed ghci and it loaded ALL the course syllabus
22:45:22 <oconnorct1> Now I need to figure out how to read them
22:48:28 <oconnorct1> It says to start "Course.Id" first. But HOW? haha.
22:49:16 <tippenein> any tips on getting hlint to accept hamlet syntax?
22:49:58 <Oejet> oconnorct1: Where does it say that?
23:04:30 <Testeree> would it be possible to accelerate ghc compilation by offloading it to gpus?
23:04:34 <YellowOnion> oconnorct1, I'm not sure what you're looking at, is it this? http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
23:05:19 <YellowOnion> Testeree, I guess its possible, but probably not worth the effort.
23:06:22 <YellowOnion> Testeree, I mean there's probably no way to do it right now, but theoretically you could.
23:07:48 <ahihi> compilation doesn't strike me as a very GPU-friendly workload
23:08:15 <YellowOnion> That too
23:09:23 <oconnorct1> Thanks YO I will start there
23:09:38 <YellowOnion> I would work on using some sort of build system that only compiles the stale code.
23:10:00 <geekosaur> parallelizing ghc has been tried and iirc wasn't really possible; too much shared context needed
23:10:03 <geekosaur> which doesn't bode well for offloading to gpus
23:11:05 <YellowOnion> stack already builds in parallel, that's about as best I think you can get.
23:12:54 <geekosaur> yes, in a way that loses the advantages of keeping shared module interfaces around for example --- each parallel job must reload them
23:15:03 <geekosaur> that gets even worse with a gpu because it means loading those and sending them to the gpu along with the thing to be compiled (the gpu can't load it itself)... which means you're having to do part of the compile outside the gpu anyway
23:16:46 <geekosaur> especially with haskell, where you can't cleanly separate the various phases --- you have to at least partially parse the code outside the gpu (and remember, if you put the parse part before passing it to the gpu, that the parse tree isn't final --- fixities get applied *after* parsing because they can't reliably be known ahead of time)
23:24:21 <geekosaur> (if you read the haskell spec with the eye of a compiler developer, it looks like it was designed as a torture device)
23:25:01 <YellowOnion> :D
23:25:11 <liste> if Haskell is a torture device, then what is C++
23:25:23 <liste> (from a compiler development perspective)
23:25:44 <geekosaur> I have tried very hard to not look at C++ in that much depth :p
23:26:06 <Zemyla> liste: A doomsday device.
23:26:17 <cocreature> what makes c++ that bad from a compiler perspective?
23:26:59 <geekosaur> even C has the problem that typedefs (at parse level) mutate the lexer. templates at least seem like they can do much worse things...
23:27:03 <liste> cocreature: parsing it is turing-complete
23:27:30 <cocreature> liste: that sounds bad, yes :)
23:27:47 * cocreature goes back to staring at his c++ code
23:27:49 <liste> http://stackoverflow.com/a/14589567/1283954
23:33:14 <geekosaur> summary: if Haskell was designed by Torquemada, C++ was designed by Lovecraft
23:35:33 <toph> how does one get the bind ligature in latex? >>=
23:36:42 <toph> i guess \gg= is pretty close
23:41:22 <ntnt> I'm amazed that #haskell doesn't require identification yet is so civil
23:42:20 <toph> \gg\kern-3pt=     ~:)
23:42:25 <jack_rabbit> There's only a certain type of person that's interested in haskell, it seems.
23:43:07 <jack_rabbit> ntnt^
23:43:37 <ntnt> jack_rabbit: indeed, haskell tends to only attract logical people
23:43:44 <ntnt> and logical people tend to be self reflective enough to not troll
23:44:52 <Guest54008> ?src ($)
23:44:52 <lambdabot> f $ x = f x
23:45:02 <jack_rabbit> ntnt, that, and there's few enough of us that we're a small target.
23:45:03 <Guest54008> ?src (Eq)
23:45:03 <lambdabot> Source not found. Sorry.
23:45:18 <Guest54008> ?src (==)
23:45:18 <lambdabot> x == y = not (x /= y)
23:45:44 <jack_rabbit> (and not particularly receptive to trolling)
23:45:55 <Testeree> ?src (/=)
23:45:55 <lambdabot> x /= y = not (x == y)
23:46:07 <Zemyla> ntnt: I'm remembering that time someone came in to troll, and wound up becoming sincerely interested in Haskell.
23:47:34 <Zemyla> ?src foldl'
23:47:34 <lambdabot> foldl' f a []     = a
23:47:34 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:48:03 <YellowOnion> Hmm, so its good to know that Data.List.sort is leaking just like my version of mergesort
23:53:50 <Zemyla> YellowOnion: Leaking how?
23:56:39 <YellowOnion> Zemyla, trying to sort a list of size 10^7 but its using peak 1.2GB of memory which seems a bit much.
23:59:30 <YellowOnion> 10^7 Int's to be exact.
