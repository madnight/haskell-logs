00:02:07 <seishun> :t \a b c -> a * b * c
00:02:08 <lambdabot> Num a => a -> a -> a -> a
00:03:19 <Axman6> thing = \a b c -> a * b * c
00:05:17 <dmtd> Thank you everyone! :)
00:20:29 * hackagebot gloss-rendering 1.10.1.1 - Gloss picture data types and rendering functions.  https://hackage.haskell.org/package/gloss-rendering-1.10.1.1 (BenLippmeier)
00:20:31 * hackagebot gloss 1.10.1.1 - Painless 2D vector graphics, animations and simulations.  https://hackage.haskell.org/package/gloss-1.10.1.1 (BenLippmeier)
00:20:33 * hackagebot gloss-algorithms 1.10.1.1 - Data structures and algorithms for working with 2D graphics.  https://hackage.haskell.org/package/gloss-algorithms-1.10.1.1 (BenLippmeier)
00:20:35 * hackagebot gloss-raster 1.10.1.1 - Parallel rendering of raster images.  https://hackage.haskell.org/package/gloss-raster-1.10.1.1 (BenLippmeier)
00:20:37 * hackagebot gloss-examples 1.10.1.1 - Examples using the gloss library  https://hackage.haskell.org/package/gloss-examples-1.10.1.1 (BenLippmeier)
00:21:34 <Gurkenglas> Can finding what is expressible in terms of elements from a given set and a given binary operation be expressed as a graph problem?
00:34:09 <Adeon> anyone familiar with HsOpenSSL? I can't figure out if it's possible to set a client certificate when you are connecting to somewhere
00:34:24 <Adeon> https://hackage.haskell.org/package/HsOpenSSL-0.11.1.1/docs/OpenSSL-Session.html I keep searching and staring at it but the functionality doesn't seem to be there or I'm not using it right
00:36:40 <Adeon> hrm, might have to use tls package instead, maybe it can do that
00:37:18 <Adeon> that library just makes me feel uneasy because I don't know how you can confidently write haskell crypto code that will not be vulnerable to timing attacks
00:37:24 <Adeon> not that openssl has great track record either
00:37:28 <Adeon> so it's like pick your poison
00:37:53 <nineonine> help with FreeT needed !
00:37:54 <nineonine> http://lpaste.net/158631
00:39:21 <nineonine> how do I unwrap this FreeT , modify one layer and wrap it back ?
00:39:22 <Gurkenglas> What's Request from?
00:39:30 <nineonine> http.client
00:39:55 <Gurkenglas> Network.HTTP.Client?
00:39:59 <nineonine> yes
00:40:47 <Gurkenglas> That type signature ought to look like (Request -> Request) -> ReqT m a -> ReqT m a, because it lifts a function on Requests
00:40:59 <Gurkenglas> (to a function on ReqT m a)
00:41:30 <lyxia> nineonine: pattern match
00:41:40 <nineonine> how can i unwrap it properly ?
00:42:34 <nineonine> i used this argument order because it is more readable 
00:42:57 <nineonine> basivally this function is withParams
00:43:01 <nineonine> i want to have
00:43:16 <nineonine> runRequest `withParams` [params]
00:45:00 <nineonine> lixya: how can I pattern match ?
00:45:08 <nineonine> lyxia: !
00:45:17 <lyxia> updateReq (ReqT a) = ...
00:45:57 <Gurkenglas> It looks like updateReq is going to be a composition of ((ReqF m a -> ReqF m a) -> ReqT m a -> ReqT m a) and ((Request -> Request) -> ReqF m a -> ReqF m a). That sound right?
00:46:13 <nineonine> i dont even have (ReqT a)
00:46:31 <lyxia> what
00:47:03 <nineonine> ReqT m a
00:47:10 <Gurkenglas> "i dont even have (ReqT a)" <- "newtype ReqT m a = ReqT (FreeT (ReqF m) m a)" implies that any member of "ReqT m a" has the form "ReqT a" where a has typ "FreeT (ReqF m) m a"
00:47:22 <nineonine> oh
00:47:29 <nineonine> sorry, my fault 
00:47:34 <nineonine> :)
00:47:38 <Gurkenglas> nine was talking about types, lyxia about values
00:47:53 <Gurkenglas> nineonine, that decomposition up there right?
00:48:10 <nineonine> im trying to understand it, sorry :}
00:48:23 <nineonine> just give me a moment hehe
00:49:07 <nineonine> yes, exactly what i want  !
00:49:24 <lpaste> Gurkenglas annotated “No title” with “Will the solution have this form?” at http://lpaste.net/158631#a158661
00:49:39 <Gurkenglas> Ah, ninja'd by your acceptance
00:49:42 <nineonine> btw i have already implemented (ReqF m a -> ReqF m a) , which is trivial
00:50:02 <lpaste> Gurkenglas revised “Will the solution have this form?”: “No title” at http://lpaste.net/158661
00:50:18 <Gurkenglas> (Forgot a pair of brackets for bars type, didn't revise the title)
00:50:48 <Gurkenglas> Still waiting for chrisdone to accept the pull request to lpaste so editing annotations actually works right
00:50:50 <nineonine> yup
00:51:07 <lpaste> Gurkenglas revised “Will the solution have this form?”: “Okay so this is whats left to implement” at http://lpaste.net/158661
00:51:41 <Athas> Does anyone have an example of a lexer written with Alex that reads input from Text (or ByteString) and produces lexemes with location information?
00:51:56 <nineonine> yes
00:52:28 <Athas> Could you point me in its direction?
00:52:48 <Gurkenglas> We need (ReqF m a -> ReqF m a) -> ReqT m a -> ReqT m a
00:53:15 <Gurkenglas> So this would be enough: (ReqF m a -> ReqF m a) -> FreeT (ReqF m) m a -> FreeT (ReqF m) m a
00:53:37 <Gurkenglas> So this would be enough: (f a -> f a) -> FreeT f m a -> FreeT f m a
00:54:23 <nineonine> yup
00:54:25 <Gurkenglas> http://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Free.html#v:transFreeT looks like that, but it requires that you be able to implement the function you put in for all a
00:55:10 <nineonine> transFreeT ? looks good
00:55:22 <Gurkenglas> Can you take it from here?
00:55:29 <nineonine> im not sure :\
00:55:44 <nineonine> let me try :)
00:55:46 <nineonine> 5 mins
00:56:04 <nineonine> thanks !
00:57:11 <rydgel> I don't understand the difference of those types for instance: "a -> a" and "forall a. a -> a". I don't understand what forall actually add in term of meaning
00:58:12 <Gurkenglas> "(f a -> g a) -> FreeT f m b -> FreeT g m b" would mean that you could input a function that can only turn f () into g ()
00:58:43 <liste> rydgel: when you write "myFunc :: a -> a", it actually means "myFunc :: forall a. a -> a" - the forall is implicit
00:59:06 <lyxia> rydgel: forall is necessary to express higher rank types.
00:59:10 <liste> you need explicit foralls with some extensions, like RankNTypes and ScopedTypeVariables
00:59:22 <Gurkenglas> All types have all type variables that aren't covered by a forall somewhere supplied with a forall at the very start of the type. If you want the forall somewhere else than the very start, you have to specify it
00:59:36 <nineonine> this is my implementation
00:59:40 <nineonine> (ReqT r) params = ReqT $ transFreeT (flip withParams' params) r
00:59:47 <nineonine> it is passing :)
00:59:48 <rydgel> liste Gurkenglas oh, I see. Thank you :)
01:00:04 <nineonine> going to test it now !
01:00:27 <Gurkenglas> I think all these arcane kmetty libraries are built robust enough that if it compiles, it probably works :)
01:00:33 <nineonine> withParams' is my (ReqF m a -> ReqF m a) which I have implemented earlier
01:00:49 <nineonine> good to hear
01:01:35 <nineonine> Gurkenglas: thanks a lot ! 
01:02:03 <dmwit> You know your type is good if there's only one inhabitant.
01:02:35 <Gurkenglas> transFreeT has two of them though I think, and both should be equal if you add the Functor f constraint
01:03:17 <Gurkenglas> (Well, if we put the library to its full use, we'd probably fail as often as usual, but we all aren't on that level yet.)
01:05:22 <shanemikel> okay, now that I have a CoArbitrary instance for my datatype, how do I use it?
01:13:47 <Gurkenglas> Someone needs to implement a BindingMonad (from unification-fd) instance for the Haskell language
01:19:52 <Gurkenglas> "This module provides first-order structural unification over general structure types." <- Does that mean it wouldn't work for Haskell's Rank2Types?
01:21:13 <qdwang> Is there any up to dated Parsec tutorial exists? All the info I found by google are out dated.
01:35:31 <rydgel> qdwang: this one seems recent https://github.com/JakeWheat/intro_to_parsing
01:42:56 <qdwang> rydgel:   the first example `import Text.Parsec.String.Char` can not be found in Parsec 3.1.9
01:45:13 <rydgel> qdwang: it has been move to Text.Parsec.Char
01:46:20 <qdwang> rydgel: thanks
01:48:39 <rydgel> qdwang: but he basically says it: "This parser is in the module Text.Parsec.Char. There is a wrapper in this tutorial’s project, Text.Parsec.String.Char, which gives this function a simplified type."
01:53:04 <dmwit> Gurkenglas: It does mean that. Higher-order unification is WAY harder than first-order unification.
01:53:32 <qdwang> rydgel: so there it is. I didn't see that.
02:21:23 <Gurkenglas> dmwit, how's it hard? Unifying two terms of form (forall x. <something in terms of x>) -> <more> just requires unifying the inner parts first, then the outer ones, right? Can you give two higher-order types that are hard to unify?
02:21:34 <Gurkenglas> -two terms+two types
02:55:25 <croben> can a function return two values?
02:55:40 <xa0> Tuples :p
02:55:45 <pyrtsa> (,)
02:55:50 <croben> ah, ok
02:56:22 <xa0> Sadly there is no cocurry
02:56:41 <tdammers> how would that even type?
02:56:47 <croben> so you can't do 'convert :: Nat -> Nat -> Int -> Int'?
02:57:24 <xa0> I have no idea, tbh
02:57:37 <croben> if you google cocurry you get a lot of thai restaurants
02:57:44 <xa0> Hahaha
02:59:00 <croben> i'm trying to convert two values, do something with them and convert them back
02:59:16 <croben> but i'll probably figure it out somehow
02:59:49 <pyrtsa> croben: Sounds a lot like doing something with a lens.
03:00:03 <croben> pyrtsa, lens?
03:00:28 <xa0> A library for  modifying the internals of large structures
03:00:44 <pyrtsa> And why not small structures like a tuple of two arguments as well?
03:00:46 <xa0> Well, any structure
03:00:49 <pyrtsa> https://hackage.haskell.org/package/lens
03:01:00 <xa0> Its not really beneficial in that case
03:01:03 <Peaker> well, not just structures :)
03:01:10 <xa0> Lol
03:01:12 <xa0> Okah
03:02:05 <pyrtsa> Haha, I stand somewhat corrected. Anyway, I couldn't make sense of `Nat -> Nat -> Int -> Int`. Is it really a function of 3 args you're talking about (because it doesn't sound like it).
03:02:19 <xa0> For tuples I just use Bifunctor, and anything else relatively small I'd roll my own lensy thing. Not really worth the overhead of TH or a page of lens construction
03:02:26 <Peaker> adding a seemingly innocuous newtype wrapper around some type -- and packing/unpacking it manually in a bunch of places -- gave me a noticeable performance hit, bah!
03:02:26 <croben> pyrtsa, sort of
03:02:41 <Peaker> newtypes are supposed to be free!
03:02:52 <xa0> They're still noisy :p
03:03:21 <croben> idealy i would like a function that takes two arguments and returns one
03:03:24 <Peaker> 10% performance hit!
03:03:48 <pyrtsa> croben: So?
03:04:08 <xa0> croben: what are the arguments and the result?
03:05:48 <croben> but is it possible to do 'multiply :: Nat -> Nat, convert to int, multiply, convert back and return product'
03:05:59 <xa0> Do you want to convert two Nats to Ints? Because you should do that by having convert :: Nat -> Int, and just doing it for each Nat, rather than getting yourself in a tuple tangle
03:07:14 <xa0> Oh so you want multiply :: Nat -> Nat -> Nat, which uses convert :: Nat -> Int and its inverse internally
03:07:47 <croben> xa0: yup
03:08:15 <xa0> You don't need tuples or anything for that, you can do it with just 'let' :)
03:08:39 <croben> inside the function?
03:08:56 <xa0> Yeah
03:09:22 <croben> ah, ok, i'll try that then
03:09:38 <croben> thanks :)
03:09:57 <xa0> No prob :)
03:10:05 <croben> and sorry for stupid questions, i'm very new to haskell
03:10:24 <xa0> That's fine!
03:17:18 <sebbenbear> Hey! I'm pretty new to functional programming, and I was just wondering - what is a Functor, and how does FMap work? I've read a few pieces on it, and I still don't think I quite understand it.
03:17:50 <sebbenbear> as in: fmap (nub . sort) arbitrary
03:18:36 <hpc> Functor is a class of types that all share some common properties
03:18:37 <liste> sebbenbear: in that case, fmap makes the function (nub.sort) work on Arbitrary values
03:18:40 <xa0> A functor is something that can contain a value in some way, fmap let's you act on that value
03:18:56 <hpc> in particular, a type F is a Functor if it has some valid function (a -> b) -> F a -> F b
03:19:03 <hpc> and that function obeys some particular laws
03:19:05 <sebbenbear> So, like a list or tuple?
03:19:17 <liste> > fmap (nub.sort) [[1,2,5],[2,5,5,6,1,5],[5,2,1,2,6]]
03:19:19 <lambdabot>  [[1,2,5],[1,2,5,6],[1,2,5,6]]
03:19:59 <liste> sebbenbear: there's Functor instances for [] and ((,) a), yes, but also e.g. IO and Maybe
03:20:12 <liste> > fmap (nub.sort) (Just [1,2,6,3,2,2,1])
03:20:13 <lambdabot>  Just [1,2,3,6]
03:20:18 <xa0> Tuple itself is a Bifunctor instead
03:20:52 <liste> > fmap (nub.sort) ("yeah!", [1,6,6,4,3,6,7,1,2,5,5,2])
03:20:54 <lambdabot>  ("yeah!",[1,2,3,4,5,6,7])
03:21:43 <sebbenbear> I'm still not sure why you couldn't use map instead of fmap here, and apply a function to an element contained within that structure that way?
03:21:45 <xa0> Which feels unnatural until you realise you've been using tuples wrong
03:22:05 <xa0> sebbenbear: in the case of list, map IS fmap
03:22:06 <liste> sebbenbear: map only works in list
03:22:12 <liste> for lists*
03:22:12 <xa0> In every other case, it is not
03:22:23 <liste> fmap works for lists, and a bunch of other types too
03:22:27 <hpc> sebbenbear: the advantage of fmap over map is that it represents the concept that map is a particular example of
03:22:31 <sebbenbear> so, map is derived from fmap?
03:22:46 <xa0> Map is identical to fmap, constrained to lists
03:22:48 <hpc> map is a function that happens to meet the requirements to be a valid fmap
03:23:10 <hpc> (and then is defined as one in the [] instance)
03:23:18 <hpc> to understand fmap, all you need to know are the laws
03:23:34 <hpc> those define all the behavior that must be the same across all implementations of fmap
03:23:44 <sebbenbear> right, ok. and how does that dot operator with the above expression - what order are things evaluted there?
03:23:59 <hpc> to go any further, you need to decide which instance of Functor is being used, then see what that definition is
03:24:00 <xa0> RtL
03:24:01 <sebbenbear> Not quite sure with the parenthesis there
03:24:05 <hpc> (.) is function composition
03:24:18 <sebbenbear> Yeah, like $ right?
03:24:20 <hpc> (foo . bar) x = foo (bar x)
03:24:31 <sebbenbear> ahh I see
03:25:47 <sebbenbear> so fmap (nub . sort) arbitrary
03:26:15 <hpc> yeah
03:26:16 <sebbenbear> is nub (sort arbitrary)
03:26:21 <xa0> Nope
03:26:21 <hpc> no
03:26:24 <sebbenbear> which is then mapped?
03:26:28 <sebbenbear> ah :/
03:26:40 <hpc> (nub . sort) is a function that's the composition of nub and sort
03:26:42 <xa0> Its map (\x -> nub (sort x)) arbitrary
03:26:48 <hpc> and that's being fmapped over arbitrary
03:27:26 <hpc> let nubSort = nub . sort in fmap nubSort arbitrary -- it's a bit more like this, to make it a bit more clear what's going on
03:27:56 <hpc> fmap (f . g) [1, 2, 3] is going to result in [f (g 1), f (g 2), f (g 3)]
03:28:20 <hpc> or fmap (f . g) (Just 5) = Just (f (g 5))
03:28:21 <hpc> etc
03:29:02 <pomeroy> how do you check if a Data.Vector is empty when pattern matching?
03:29:41 <sebbenbear> Ah, I think I understand that now
03:29:47 <sebbenbear> Thanks!
03:36:02 * hackagebot murmur 0.0.0.2 - Simple CUI Twitter Client.  https://hackage.haskell.org/package/murmur-0.0.0.2 (outoftune)
03:51:03 * hackagebot cufft 0.1.2.2 - Haskell bindings for the CUFFT library  https://hackage.haskell.org/package/cufft-0.1.2.2 (RobEverest)
04:00:08 <ski> orion :D
04:06:51 <xa0> :t (>-)
04:06:52 <lambdabot>     Not in scope: ‘>-’
04:06:52 <lambdabot>     Perhaps you meant one of these:
04:06:52 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
04:07:04 <xa0> Anyone?
04:09:20 <rydgel> :t (-<)
04:09:22 <lambdabot>     Not in scope: ‘-<’
04:09:22 <lambdabot>     Perhaps you meant one of these:
04:09:22 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
04:10:14 <rydgel> xa0: are you talking about the Arrow notation?
04:10:26 <xa0> I have no idea
04:10:40 <xa0> This is in the context of coexponentials, I believe
04:11:13 <rydgel> xa0: where did you find it?
04:11:54 <croben> i'm trying to do 'multNat :: Nat -> Nat -> Nat'
04:11:55 <xa0> ...lost the link now, someone talking about them
04:12:35 <croben> 'multNat n m = toNat ((fromNat n)*(fromNat m))'
04:12:37 <rydgel> xa0: I know (-<) but not (>-)
04:12:50 <xa0> Hm
04:13:08 <rydgel> xa0: (-<) is used in the Arrow do-notation, along with proc and returnA
04:13:09 <xa0> croben: yep!
04:13:22 <tdammers> http://hayoo.fh-wedel.de/?query=%28-%3C%29
04:14:12 <xa0> rydgel: what does it mean in that context?
04:14:26 <croben> xa0: it's saying that toNat is getting two arguments
04:15:15 <croben> xa0: http://pastebin.com/6wmgYNmN
04:15:17 <xa0> toNat :: Int -> Nat?
04:15:24 <croben> yes
04:15:48 <xa0> You're missing some brackets
04:15:51 <xa0> Or a $
04:16:16 <ertes> croben: the usual (data Nat = Z | S Nat)?
04:16:27 <croben> ertes, correct
04:16:38 <ertes> croben: is this an exercise?
04:16:48 <croben> ertes, also correct
04:16:57 <ertes> then most likely you shouldn't go through Int and use builtin multiplication
04:17:07 <ertes> croben: have you defined addition?
04:17:13 <croben> ertes, yes
04:17:31 <ertes> croben: do you have an idea how to define multiplication in terms of it?
04:17:32 <croben> and i've defined multiplication by using addition
04:17:36 <Peaker> https://github.com/Peaker/AlgoWMutable/commit/c7c9fa17f3c60184fdd9990279f246b1b65c3098 <-- why would this have a performance penalty, it's just a newtype? :-(
04:17:42 <croben> yes, i've done that already
04:18:08 <ertes> croben: i see…  then what's your goal now?
04:18:39 <croben> try to make it faster and learn more syntax
04:18:39 <xa0> Making it faster?
04:18:43 <croben> yes
04:19:08 <xa0> Nat multiplication sounds like it'd have ridiculous complexity
04:19:12 <ertes> ok…  it won't be that much faster though
04:19:16 <Peaker> or maybe the benchmark is too noisy? Hmm.. benchmarks are hard!
04:19:23 <ertes> in fact i don't think it will be faster at all
04:19:42 <croben> ertes, let me figure that out on my own
04:19:55 <ertes> sure, go ahead =)
04:20:28 <croben> xa0: any idea where i could put more brackets or $
04:20:48 <xa0> ertes: is that because of ghc, because I don't see how a series of additions could be as fast as a hardware multiplication operation
04:20:52 <ertes> croben: toNat (fromNat x * fromNat y)
04:21:03 <xa0> croben: yeah that
04:21:05 <ertes> that's the least noisy way to write it without ($)
04:21:22 <croben> that worked!
04:21:28 <croben> thank you!
04:21:31 <ertes> and personally i like that one best (i.e. better than with ($))
04:21:47 <croben> what's the alternative?
04:22:05 <croben> if you don't mind me asking
04:22:17 <Peaker> in a linearly typed language -- unsafePtrEquality is really a safe operation, isn't it?
04:22:21 <ertes> xa0: it will have the same complexity, because the reason recursive (*) is slow is that the *result* is large
04:22:38 <ertes> the recursion itself won't factor in much
04:22:39 <ski> xa0 : did i mention `>-' ?
04:22:58 <xa0> Oh, interesting
04:23:03 <ski> Peaker : `deriving (Pretty,Monoid)' ?
04:23:04 <ertes> croben: f $ x = f x;  so you can write:  toNat $ fromNat x * fromNat y
04:23:07 <xa0> ski: perhaps?
04:23:18 <xa0> What does it mean?
04:23:20 <ertes> croben: ($) is function application, but with much lower precedence
04:23:27 <bernalex> someone sent me a fun puzzle. I wrote something that satisfies it. now only golfing remains. :p http://lpaste.net/699676814200537088 any ideas for making this shorter and simpler?
04:23:28 <Peaker> ski: it refuses to derive Monoid
04:23:36 <croben> ertes: ah, ok. well, thanks again :)
04:23:40 <Peaker> ski: Because the constraint is a FlexibleContext
04:23:51 <ertes> my pleasure
04:24:04 <bernalex> sample use: bal [10, 10, 10] 2 5 == [7, 8, 15]. so it takes a list, an index, a value change. then it does the value change, and balances the list to make sure it has the same sum as the old list before adding the new value.
04:24:27 <ski> Peaker : oh. try `deriving instance Monoid (Constraints tag) => Monoid (MetaVarInfo tag)' ?
04:24:41 <croben> well, the test was substantially faster
04:24:51 <croben> took 15 minutes yesterday
04:25:02 <Peaker> ski: That's what I tried first -- still saw degaradation. In many benchmarks I saw degradation, but in just one after many, it ran as fast as the fast version, so I am now doubting the reliability of the bench :-(
04:25:03 <tdammers> bernalex: interview question?
04:25:10 <ertes> croben: that's quite surprising actually…  how did you define mul in terms of add?
04:25:21 <ski> Peaker : hm, ok
04:25:28 <bernalex> tdammers: someone just asked me about it. no clue what he wanted to use it for.
04:25:45 <ski> xa0 : i've used `a >- b' for a coexponentials, `a' being in a covariant position, while `b' in a contravariant position
04:25:47 <tdammers> hmm, ok
04:25:52 <bernalex> tdammers: I hacked it together for fun. not too much work. but, presently, it's not very nice either.
04:26:05 <Peaker> ski: btw: This AlgoWMutable thing is the project you helped me with long ago (with the GADT with the tag parameter) and is ~10-15x faster than substitution-based inference. Has extensible[row/column polym.]+structural sums/products
04:26:06 <ski> (xa0 : i've also seen `a - b' and `a -< b' used for this)
04:26:09 <tdammers> how is the balancing defined?
04:26:11 <xa0> Ahh
04:26:14 <croben> ertes: multNat (S m) n = plusNat n (multNat m n)
04:26:17 <ski> Peaker : nice
04:26:24 <xa0> ski: okay thanks
04:26:25 <ertes> xa0: to get fast (*) on Nat without going to fully opaque builtin types, i've done this:  data BitNat :: Nat -> * where Bit :: !Bool -> BitNat Z; Cat :: !(BitNat n) -> !(BitNat n) -> BitNat (S n)
04:26:37 <bernalex> and it's suuuuper slow.
04:26:43 <Peaker> Now I want to add skolem support and support higher-ranks, without bogging down performance too much
04:26:45 <bernalex> tdammers: he didn't say. I just balance it evenly.
04:26:52 <bernalex> tdammers: it fits his examples.
04:26:53 <ertes> croben: is your plus left- or right-recursive?
04:27:02 <tdammers> mkay
04:27:08 <ski> xa0 : the idea is that `a >- b' expresses "`a' but not / except `b'". more or less an `a', together with a `Not b' (a `b'-continuation)
04:27:15 <ertes> croben: because i would expect that to make a major difference
04:27:32 <croben> ertes, plusNat n (S m) = plusNat (S(n)) m
04:27:44 <xa0> I see, okay
04:27:55 <ski> xa0 : remember that if you have a morphism `f : a * b >---> c', you can curry it into `curry f : a >---> (b -> c)' where `b -> c'/`c^b' is an exponential
04:28:11 <xa0> Yep
04:28:13 <ertes> croben: oh, i see the problem:  plusNat x (S y) = S (plusNat x y)
04:28:17 <ertes> croben: try that one
04:28:37 <ski> xa0 : well, the idea here is that if you have a morphism `f : a >---> b + c', you should be able to cocurry it into `cocurry f : (a >- b) >---> c', `a >- b' being the coexponential
04:28:48 <ski> xa0 : that's my motivation for using the `>-' notation for it
04:29:14 <ertes> croben: in haskell with non-strict recursive types (the default), the rule of thumb is: "produce before you recur"
04:29:19 <xa0> Oh I see. That makes sense
04:29:23 <xa0> Quite nice actually
04:29:24 <ski> xa0 : the idea about the cocurrying is that `f : a >---> b + c' could be thought of as transforming an `a' into a `c', or (in exceptional cases) a `b'
04:30:03 <ski> xa0 : while `cocurry f' would take an `a', bundled with an "exception handler" for `b', and produce a `c' (or else not return normally, jumping instead to the exception handler / continuation)
04:30:48 <croben> ertes: failed multNat tests
04:31:08 <croben> one sec, i'll try again
04:31:11 <xa0> ski: The typing for that feels bizarre, but yeah it is nice
04:31:32 <ski> xa0 : however .. this is using the additive interpretation of `+'. perhaps it would be more reasonable to use the multiplicative interpretation (from classical linear logic), where `a (+) b' will both generate an `a' and a `b', but not independently, as is the case with the multiplicative product `a (*) c', but *dependently* (think interacting processes/threads)
04:31:33 <ertes> croben: interesting that you do TDD =)
04:31:49 <ertes> it's rather rare in haskell land
04:32:09 <ski> xa0 : another intuition that may help here is backtracking, so we first generate an `a', and later we manage to prove `Bot', which causes backtracking, and then we instead generate a `b'
04:32:35 <croben> ertes, i have a friend teaching me haskell and he made a test suite
04:32:54 <ertes> ah, i see
04:33:01 <xa0> Hm, okay yeah, I somewhat get you
04:33:02 <Peaker> I have `Set.intersection` between objects in a tight-loop. It is almost always the case that the sets being intersected are the same set value (shared in memory). Could be a nice optimization to use reallyUnsafePtrEquality -- would it be a good idea to add it to the containers package itself?
04:33:09 <ski> xa0 : for more on this `a >- b', look for a paper by Crolard about "Subtractive logic", and also compare with "Dual-intuitionistic logic" by Urbas. also a later paper by Rajeev Gore, iirc
04:33:22 <xa0> Ah thanks :D
04:33:31 <croben> why is it rare with TDD? because of the concise nature of it?
04:33:34 <Peaker> I guess I could have explicit sharing for the skolem scopes
04:33:43 <ski> (a later paper called "Dual-intuitionistic logic, revisited", i think)
04:34:00 <ski> Igor Urbas
04:34:25 <croben> ertes, 130 seconds to finish test
04:34:25 <ertes> croben: i don't know, probably culture…  we do more with types than with values, and personally i do rapid prototyping and quick tests…  and if i feel unsafe, i write a real test using smallcheck
04:34:38 <ertes> croben: better than 15 minutes =)
04:34:57 <croben> it is, but converting to int and back took less than a second
04:35:15 <ertes> croben: you could get extra performance by flipping the plusNat arguments in multNat
04:35:18 <ski> Peaker : `AlgoWMutable' uses (internally mutable) logic/meta variables ?
04:35:30 <ertes> croben: plusNat x y → plusNat y x
04:35:37 <ski> Peaker : by "structural sums/products", do you mean that you have some kind of subtyping ?
04:37:55 <Peaker> ski: First question: yes: https://github.com/Peaker/AlgoWMutable/blob/master/Lamdu/Infer/Meta.hs#L55-L60
04:38:22 <Peaker> ski: (We use "Zone refs" that are indices into an STArray, so that we can copy the entire array very quickly and "resume" inference many times to typecheck many possible changes to the code)
04:38:41 <croben> ertes, failed
04:38:58 <Peaker> ski: and yeah, the sums/products are structural because: A) they're inferred from use of "rec-extend" and "case-one" expressions (no type declarations), B) they have row/column polymorphism
04:39:33 <ertes> croben: mul x (S y) = plus (mul x y) x
04:39:35 <ertes> like that
04:39:45 <ertes> and of course:  mul x Z = Z
04:40:50 <ertes> compared to the Int cheat it has to do an additional pass, but should still be rather fast
04:40:52 <Peaker> ski: so, with a made up nomtation:  interpretAdd = \case Add {x,y} -> (x + y)    will infer: interpretAdd : forall alts1. {[Add] not in alts1} => +{Add:{x:Int,y:Int} | alts1} -> Int
04:41:04 * hackagebot juandelacosa 0.0.1 - Manage users in MariaDB >= 10.1.1  https://hackage.haskell.org/package/juandelacosa-0.0.1 (ip1981)
04:41:19 <croben> ertes, still fails
04:41:24 <Peaker> oops: missing part in that type:
04:41:31 <ertes> croben: can't imagine why
04:41:36 <croben> multNat n (S m) = plusNat (multNat n m) n
04:41:46 <croben> plusNat x (S y) = S (plusNat x y)
04:41:54 <ertes> yeah, looks correct to me
04:42:05 <ertes> check your base cases, maybe something is wrong there
04:42:05 <Peaker> ski: interpretAdd : forall alts1. {[Add] not in alts1} => +{Add:{x:Int,y:Int} | alts1} -> (+{|alts1}->Int) -> Int
04:43:15 <croben> ertes, multNat Z n -> multNat n Z
04:43:52 <croben> still slower than converting to int :p
04:44:02 <croben> but not by much
04:44:17 <ertes> =)
04:44:30 <ertes> that's the additional pass
04:44:48 <ertes> otherwise it's not much slower than Int multiplication because the conversion makes it expensive
04:45:09 <croben> of course
04:45:54 <ertes> do you see *why* it's much faster now?
04:46:34 <croben> not really but i have a hunch
04:47:31 <ertes> if you're interested, try to explain it…  maybe your hunch is correct =)
04:47:37 <croben> i just need to think about it for a while
04:47:54 <croben> sure :) if you have the time to spare
04:48:12 <Peaker> ski: http://lpaste.net/158734 <-- this might be more ingestable
04:48:15 <ertes> right now i do
04:48:46 <rydgel> wow what's those weird Types notation
04:49:08 <rydgel> dependent typing?
04:49:37 <ph88> what's wrong with this data here ?  http://pastebin.com/URMLjpwm
04:49:51 <Peaker> ski: it has some nice properties for the "sums":  you can "compose" an interpreter like:  interpretAdd . interpretMul   (each "Case" takes a handler for the data cons. it handles, and a "default" handler which takes a reduced sum type)
04:50:23 <croben> ertes, need to go, i'll see you around
04:50:26 <Peaker> ski: in Haskell, I often miss the precise typing for:  \case Var x -> ...  other -> ... other should have a smaller sum type without "Var" here! In Lamdu it does
04:50:31 <croben> and thanks again :D
04:50:40 <ertes> croben: have fun
04:51:07 <julianleviston> ph88: what is this bit? Id Assign (Id | String_literal) Option Assignment
04:51:10 <xa0> rydgel: lol
04:51:15 <julianleviston> ph88: like… the parens?
04:51:17 <rydgel> ph88: "Id Assign (Id | String_literal)" you can't nest that
04:51:41 <ph88> so i need to break that out to a seperate data type ?
04:51:45 <rydgel> yeah
04:51:51 <ph88> ok
04:51:55 <croben> ertes, i will :)
04:52:26 <julianleviston> ph88: also, you seem to have an Id type as well as value constructor
04:52:28 <ph88> any suggestions for how i should name that data ?
04:52:50 <ertes> (i may be overly obsessed with making haskell code go faaaaaaaaaaast)
04:52:58 <julianleviston> ph88: naming is hard!
04:52:58 <ph88> julianleviston, don't understand what you are saying
04:53:11 <ph88> Id type as well as value constructor
04:53:44 <julianleviston> ph88: um… you have “Id”.
04:54:09 <julianleviston> ph88: here: data ElementOption = MkElementOption Id Default Node Option
04:54:16 <julianleviston> ph88: in that, Id is the name of a type.
04:54:42 <julianleviston> ph88: but here, it’s the name of a data constructor:  Id Assign (Id | String_literal) Option Assignment
04:55:11 <ph88> oh so i should have 2 data constructors for ElementOption, like  MkElementOption1 and MkElementOption2 ?
04:55:23 <croben> ertes, i'll remember that!!! XD
04:55:26 <julianleviston> ph88: data TypeName = DataConstructor1 Type1 Type2 Type3 | DataConstructor2 Type4 Type5 Type6
04:55:37 <ph88> ye
04:55:54 <julianleviston> ph88: sorry it’s a bit hard to explain this over IRC.
04:56:21 <croben> come in here every other day and be like 'ertes, how 2 fast?'
04:56:43 <julianleviston> ph88: do you roughly understand, possibly?
04:56:51 <ph88> dont worry i get it
04:56:55 <julianleviston> ph88: sweet :)
04:57:42 <ski> ertes : hm, that `BitNat' looks interesting. so `BitNat n' has `2^n' bits ?
04:57:47 <ski> ertes : i'm not sure why `plusNat n (S m) = plusNat (S(n)) m' would cause a performance problem (though it is bulky, instead of incremental)
04:57:50 <ski> Peaker : "explicit sharing for the skolem scopes" ?
04:57:54 <ski> Peaker : oh, i think i remember talking about the AST `tag' trick now
04:57:58 <ski> Peaker : how does that `\case' work, to get a typing like that ?
04:58:03 <ski> Peaker : ok (looking at paste). i see. quite nice :)
04:58:07 <ski> rydgel : not exactly dependent typing, afaiu. just row polymorphism
04:58:09 <Peaker> ski: :)
04:58:11 <ski> Peaker : "row/column polymorphism" ?
04:58:13 <ski> Peaker : *nod' (for composing). "other should have a smaller sum type without "Var" here!" -- yes, like "polymorphic variants" in OCaml
04:58:30 <ertes> ski: yeah…  and the plusNat example is less lazy
04:58:31 <Peaker> ski: yeah, it's very much like polymorphic variants. Not sure if the "case" judgement works the same
04:58:50 <ski> ertes : yeah, what i meant by "not incremental"
04:59:13 <Peaker> ski: I wonder if this nice duality between empty/extend/getField  and  absurd/case/inject   is novel or not :)
04:59:25 <ertes> ski: the accumulation that happens makes it noticably slower, because now GHC has to do book-keeping rather than just folding on the fly
04:59:30 <ertes> does that make sense?
04:59:33 <ski> (of course that could cause a performance difference if you use say `Z < ...')
04:59:35 <Peaker> ski: Do polymorphic variants use "case" by composing case statements, one for each constructor?
05:00:35 <ski> ertes : "accumulation that happens","book-keeping rather than just folding on the fly" ?
05:01:34 <ertes> ski: it's the usual "badly written factorial function"…  you accumulate by building thunks rather than by using an accumulation argument, but because Nat is lazy you can use proper corecursion and that's what GHC handles best
05:01:44 <ski> Peaker : i think the duality is more or less well-known, in the types community (at least among people familiar with type systems for both "typical" FP langs with variants, as well as OO langs, modelled by records. e.g. Luca Cardelli)
05:02:51 <ski> Peaker : i think you'd normally say something like  eval = function `Add (e0,e1) -> eval e0 + eval e1 | `Mult (e0,e1) -> ... | ...
05:02:53 <ertes> there is a name for that recursion pattern…  hylomorphisms i think
05:03:12 <ertes> unfold followed directly by fold
05:03:31 <julianleviston> ertes: I don’t think they’re followed… it’s actually together, no? :)
05:03:56 <ski> Peaker : probably i works the same, if you use `match' instead of `function' (which corresponds to `\case' in Haskell, and to `fun' in SML)
05:04:02 <ski> s/i works/it works/
05:04:13 <ertes> julianleviston: fold g . unfold f
05:04:29 <ski> ertes : ah, right
05:05:11 <ski> julianleviston : hylo would be a transformation that's denotationally equal to that composition, iirc
05:05:27 <julianleviston> ski: denotationally, yep.
05:05:34 <ertes> (not the 'fold' from Data.Foldable)
05:05:43 <ski> (obviously not :)
05:07:02 <Peaker> ski: Can you easily do the equivalent of "composing" an interpreter from matches all over the place?
05:08:21 <julianleviston> hm weird… I thought hylo was defined somewhere *other* than Control.Morphism.Hylo
05:08:25 <Peaker> ski: i.e: interpreterArith = matchAdd . matchMul ; interpreterExteded = matchGraphics . interpreterArith ; closeInterpreter = (. absurd)
05:08:46 <Peaker> ski: so you can re-use your case-stmts and/or spread them out
05:08:56 <Peaker> (I mean, individual case alternatives)
05:09:35 <Peaker> btw: it seems that the killer app for fully inferred "polymorphic variants" would be exception monads -- you get nice checked exceptions for really cheap. Are poly-variants used for that?
05:10:03 <Peaker> Haskell and other languages use dynamic typing for exceptions (IMO) because they lack polymorphic variants
05:10:05 <ertes> julianleviston: i like the 'recursion-schemes' package, though i seldomly actually use it
05:10:49 <seph> i have little project where i need to parse a data structure; is a good opportunity for me to finally learn haskell?
05:10:58 <julianleviston> ertes: I’ve never used a hylo (that I know if)
05:11:07 <julianleviston> of*
05:11:22 <ertes> seph: probably…  haskell is great at parsing, but what happens *after* that?
05:11:33 <seph> what i mean is, what are my chances of finishing something today with only basic haskell to back me up
05:11:54 <ski> Peaker : i think you'd have to compose functions of the form :  fun rest -> function `Add (e0,e1) -> ..e0..e1 | x -> rest x
05:12:03 <ertes> seph: have you written a full program in haskell that does something useful or interesting?
05:12:11 <ski> Peaker : however, i think "MixML" is related to this
05:12:17 <seph> nothing really its the only scope of the work
05:12:18 <ski> (also, "expression problem")
05:13:05 <ski> Peaker : i dunno whether poly-variants (it's a strange name, yes) are used for `Either'-style (but presumably better ?) exceptions
05:13:32 <Peaker> ski: In Lamdu it's more natural I think, because the AST entity for "case" is "Case Name HandlerForName HandlerForOthers", so "HandlerForOthers" is exactly the "rest" handler
05:13:33 <ertes> seph: parsing is easy enough in haskell…  you can pick up basic parsing rather quickly, if you're not entirely new to the language
05:13:51 <seph> ive programmed for 6 years in oop. ive just learned some basic stuff about haskell's type system, pattern matchers, data types and other cool stuff 
05:14:06 <seph> but i know nothing about monads or how haskell uses functions
05:14:16 <ertes> seph: but if this is supposed to become a useful program, there is some more engineering that goes into it like understanding IO
05:14:37 <ski> Peaker : .. however, i think the names used in row-based records and variants shouldn't be identified by spelling. iow, it should be possible to rename them on import (and export). this would then require at least some minimal amount of declaration of the names, at least in the import/export list
05:14:51 <seph> well the thing is..
05:15:01 <ertes> seph: you can do it with dedication, but there is a chance that you might run out of time, if you've really got only one day
05:15:08 <Peaker> ski: I was thinking of adding explicit Pis just for such names
05:15:32 <seph> ertes: i only need to build this module to parse some structured data from xml and json.
05:15:34 <Peaker> ski: so when you want to write code that's general to any structural type of a certain shape, you have to use Pis and they're inferrable only when fully instantiated
05:15:36 <ski> Peaker : can you "union" two rows, with overlapping fields (assuming the associated types match .. or perhaps can be "merged" ?) ?
05:15:47 <Peaker> ski: but normally, if you have concrete types, inference is nice&full
05:15:59 <Peaker> ski: Yeah, or two "columns"
05:16:11 <ertes> seph: is there any reason to write a *parser*?  because we have ready-made parsers for many formats, including XML and JSON
05:16:16 <seph> ive built the system as a microservic architecture with a zoo of languages
05:16:51 <seph> not really a parser in cannonical speak. more like an etl tool to extarct data from a certain source and transform it
05:17:08 <Peaker> e.g: { a:A,c:C | other1 } unifies with { b:B,a:A | other2 }  such that the result is {a:A,b:B,C:C | other3} & other1={b:B|other3} & other2={c:C | other3}
05:17:13 <ertes> seph: that seems realistic
05:17:24 <seph> im honestly just trying to find an excuse to use and learn haskell.
05:17:29 <Peaker> ski: the above works for both records and variants of course (unfortunately we named them records&sums)
05:17:43 <seph> its just kind of scary. the functional it of it. coming from oop..
05:18:22 <seph> but i like what I see and i think the language is kind of beautiful.
05:18:48 <ski> Peaker : "In Lamdu it's more natural" *nod*, i see. "adding explicit Pis","code that's general to any structural type of a certain shape" -- that's also nice. "they're inferrable only when fully instantiated", mhm. "concrete types, inference is nice&full", ok
05:19:19 <ertes> seph: allow yourself to be a beginner…  and don't take any "facts" you've learned about programming for granted =)
05:19:20 <ski> Peaker : do you use the name "columns" mainly for when you're talking about sums/variants ? "column" interchangably with "row" ?
05:19:41 <Peaker> ski: yeah, if "row" represents "unknown fields" in a record via a type-variable
05:19:54 <Peaker> ski: it makes sense for "column" to represent "unknown data constructors" in a variant via a type-variable, no?
05:20:18 <ertes> seph: and depending on your previous language: the compiler is knowledgable and trustworthy
05:20:22 <Peaker> ski: that's the terminology I adopted(/invented?) and it makes sense to me :)
05:20:24 <seph> ertes: if you had to pick one thing about haskell that was hard to learn, what would it be?
05:20:49 <Peaker> ski: {x:T | more}  "more" is a tv representing the row/column of unknowns
05:21:11 <seph> as in what should i be ready for in terms of context switching out of oop think.
05:21:45 <Peaker> seph: most have difficulty understanding "monads" -- the main problem is the overimportance attached to monads and the attempt to learn them before so many prerequisite things are learned
05:22:00 <Peaker> seph: and terrible terminology used around the issue
05:22:20 <xa0> Lens is the new monad, no?
05:22:41 <seph> That's it. I want to learn, but there is a lot of noise el la "functional programming is so hard be very afraid".
05:22:41 <Peaker> seph: it's nice to learn the pure & simple part first. Then learn some more about types, type-classes, kinds, etc. After all that, Monads are much easier :)
05:22:48 <ertes> seph: i don't think anything stood out in particular…  like you (i guess) i came from contemporary OOP (C++ and PHP)…  i guess the most difficult thing for me is to get rid of my old habits
05:23:01 <ski> Peaker : i've only heard the term "row" used for both cases, but yes, it can make sense to think in terms of "columns". especially if you consider a typical `+{circle,rectangle,..shapes..} -> *{area,perimeter,..properties..}' matrix which can be sliced either row-wise (records, like separate classes collecting methods in OO), or column-wise (variants, like separate functions matching on the alternatives in FP)
05:23:13 <ertes> seph: i used to insist on abstraction by inheritance…  now i think it's stupid for most things
05:23:18 <Peaker> ski: Yeah!
05:23:21 <ski> Peaker : which is basic trade-off that it's good to be aware of
05:23:34 <xa0> seph: its not hard, its "different"
05:24:02 <Peaker> ski: btw, you can try some of this type system stuff in the Lamdu interactive UI already :)
05:24:04 <seph> ertes: same here, but after trying golang I really like that the language pushes towards pur composition.
05:24:19 <Peaker> ski: Very rough around these structural-typing edges, but still cool :)
05:24:21 <ertes> seph: i think what took me the longest time was to get a *useful* intuition of IO:  a language with first-class actions rather than some weird state monad non-sense i had
05:24:36 <ski> Peaker : anyway, i assume that formally in your system, "rows" and "columns" are the same thing, the difference being only whether you use them in a record/product type, or a variant/sum type
05:24:51 <Peaker> ski: exactly. The name "row" or "column" don't actually appear in there
05:24:59 <ertes> it wasn't difficult in that sense, but more like: i just didn't see it, and at some point it just made *click*…  didn't really change anything about the way i coded though
05:25:19 <seph> ertes: do you still program in oop or have you left that compltely?
05:25:19 <Peaker> ski: We have "Composite types" and TRecord/TSum lifters of composite ASTs into the type AST (both share the same GADT as per your idea :-) )
05:25:55 <ertes> seph: left completely
05:26:07 <Peaker> ski: So there's a single recursive-fixpoint parameter to this GADT so meta-variables can appear in both ASTs equally -- when the meta-variable (also skolems) is inside a composite, it is a "row" or "column" but this naming is outside the code
05:27:12 <seph> the biggest naysay for haskell seems to b productivity. Can i actually make stuff for a business using haskell? meet deadlines and share code with a team
05:27:33 <ertes> seph: it depends
05:28:18 <Peaker> seph: Haskell is quite productive
05:28:23 <ski> seph : fwiw, i think it's good to understand that record types (perhaps depending on how you look at it, one of the core concepts in OO) can be a good way to structure a solution (even in Haskell). you don't always want a datatype with many different alternatives/constructors
05:28:37 <ertes> seph: my personal observation (some people disagree!) is that haskell projects take longer to boot:  i usually do a lot of engineering before i write the "manager/customer-visible" stuff
05:28:54 <ski> seph : the trick is to learn how to do both, and to appreciate the trade-off between them, what fits better to what problem
05:29:33 <ertes> seph: overall you'll be as productive as in most languages…  the real killer comes when you need to *change* or *adapt* a project, i.e. when refactoring happens, when maintenance happens, etc.
05:29:54 <ertes> that's when haskell shines
05:30:18 <MichaelBurge> seph: It'll probably be slower for ad-hoc scripts. If you're comparing it to unit-tested Ruby code, then you don't have to unit test as much in Haskell so you can save some effort there. It's much faster when you need to refactor later.
05:30:35 <Peaker> MichaelBurge: even with turtle? :)
05:30:38 <ertes> also you get very scalable code
05:30:45 <MichaelBurge> seph: I've seen Perl codebases that people are terrified to apply a thousands line diff too, even if it's unit-tested and everything.
05:30:54 <ski> Peaker : ok
05:30:57 <MichaelBurge> But you can change  a Haskell codebase and not even worry, for the most part.
05:31:06 * hackagebot Tahin 0.1.2 - Tahin Password Generator  https://hackage.haskell.org/package/Tahin-0.1.2 (mtesseract)
05:31:30 <ph88> can anyone check if my solution for data is right ?   http://pastebin.com/6zDyRaeL
05:32:17 <seph> I'm in a good spot right now with my work that I've built a microservice (i cring everytime I say that buzzword) architecture. most programs are organized around a logical separation of concerns relating to sources of change (this code will change because that guy will say so, better separate it away from code he doesnt care about) so most code is actually throw away and if i dont like a module i simply rewr
05:32:23 <seph> ite (100-200 lines of code) it. im hoping right now I can use this advantage to try something risky like Haskell.
05:32:44 <ski> seph : also, use `-fwarn-incomplete-pattern' (and to some extent `-fwarn-overlapping-patterns') to let the compiler tell you where you need to change/add code, after adding an alternative to a data type. also try to avoid using "catch-all" cases at the end of matching
05:32:48 <bergmark> ph88: looks good to me
05:32:51 <ertes> seph: another aspect: haskell is great when you want to do engineering, and it sucks when you need to do engineering…  in other words: before you start a project in haskell, you'll usually check what libraries are available (and whether they're useful), and what you need to write yourself
05:32:59 <MichaelBurge> ski: The other disadvantage is that other languages have better integrations. For example, I'm tunneling payments through a small Ruby microservice that proxies calls to Authorize.NET, solely because I don't want to have to maintain an API defined by a 4000 line XML document.
05:33:02 <seph> ah that was the bit i forgot. you guys mentioned testing. How does that work in haskell? What are the units of organization that I need to test in Haskell?
05:33:30 <ski> MichaelBurge : itym seph ?
05:33:31 <Peaker> ski, seph: -Wall -Werror is a good default when starting out
05:33:51 <ertes> seph: nowadays library availability is much much better than five years ago, but it's still not on the level of perl or python
05:34:50 <MichaelBurge> seph: I actually don't know that you'd get too much benefit from 100-200 line microservices with Haskell. It'll work if you want to try, but I see most of the benefit is for larger projects.
05:34:57 <MichaelBurge> ski: Yeah, sorry about the ping.
05:35:18 <ski> ph88 : you still have `Id Assign (Id | String_literal) Option Assignment' there
05:35:47 <ski> ph88 : oh, didn't see the bottom part. looks ok, yes
05:36:06 <ski> ph88 : i'd perhaps choose more meaningful (and shorter) names
05:36:06 * hackagebot solr 0.3 - A minimal Solr client library  https://hackage.haskell.org/package/solr-0.3 (NikitaVolkov)
05:36:13 <ertes> MichaelBurge: i don't think size matters that much…  i have 20-line haskell projects that have been very useful…  the question is:  how long do you need to write it, and how often are you going to use it
05:37:18 <MichaelBurge> seph: Depends on what it is. If it's a proxy microservice, I'd depend on black-box tests with some shell scripts or similar. If the meat is in the pure code, I'd use HUnit or QuickCheck.
05:37:36 <ertes> just recently i had a 75-line haskell program that generated test data for a legacy shell script…  the irony
05:38:22 <seph> ertes: hey man,  shell scripts  are cool :D
05:38:50 <ski> <ski> Peaker : "explicit sharing for the skolem scopes" ?
05:38:58 <ertes> seph: sure, but you shouldn't write applications or services with them =)
05:39:30 <Peaker> ski: to support skolems (rank-N polymorphism), the type AST also has a "TSkolem name" constructor
05:39:48 <Peaker> ski: each meta-variable lives inside some scope of skolems
05:40:09 <seph> ertes: unless job security through contrived maintenance nightmares is your goal xD
05:40:09 <Peaker> ski: when unifying a meta-variable and a skolem -- I need to make sure that the skolem is within the skolem-scope of that meta-var (or skolem has escaped)
05:40:10 <ph88> thank you bergmark and ski 
05:40:25 <Peaker> ski: Also, when unifying two meta-vars, I need to intersect their skolem scopes
05:40:26 <ph88> ski, can you give an example of a more meaningful and shorter name ?
05:40:46 <Peaker> ski: if I represent the skolem scope roughly as a Data.Set, interesecting it would almost always intersect sets with themselves, which makes me sad
05:41:00 <seph> If I start my journey into Haskell today, will I be able to come to this channel for newbie help?
05:41:28 <MichaelBurge> seph: People are usually pretty helpful in this channel.
05:41:29 <ertes> seph: haskell is sufficient for that in many cases…  if you want to keep your job, use some obscure or overengineered abstractions =)
05:41:46 <Peaker> ski: so instead, I can make explicit entities representing skolem scopes (each place that binds a skolem) that have true identifiers and point to the identifier of their parent scope. Then each meta-variable can point at an identifier. Then instead of intersecting sets, I can find the MRA of both skolem scopes
05:41:57 <ski> ph88 : it depends on what you're trying to express with these types
05:42:56 <seph> MichaelBurge: yeah i've heard people haskell channels are pretty friendly. (so much for the intellectual programming jerks stigma, which I dont understand given my experience)
05:42:58 <ski> Peaker : how are skolems introduced/created, at the level of the type checker ?
05:43:34 <ski> seph : newbie questions are welcome here
05:44:09 <infinity0> is it possible to set the state of a State monad (or something similar) from outside of the monad? i.e. without using >>= (which would only act *after* the monad runs anyway)
05:44:10 <ski> seph : if it's too noisy, or noone's answering, you can also try #haskell-beginners
05:44:26 <Peaker> ski: there could be many ways (e.g: explicit foralls), but we chose to restrict it (for now). We have "Nominal types" (which are like Haskell newtypes) that are parameterized (like newtypes) and are allowed to have (top-level) foralls.  Then we have value-level AST constructors "ToNominal Name" and "FromNominal Name"
05:44:34 <infinity0> the broader topic is i'm trying to find a way to model co-operative interrupts without resorting to IO
05:44:35 <ski> seph : .. sometimes people in here move to #haskell-overflow, to avoid noise
05:45:00 <ertes> infinity0: like coroutines?
05:45:18 <Peaker> ski: that should read: "{To,From}Nominal Name Subexpr"
05:45:29 <Peaker> ski: "FromNominal Name" explicitly instantiates the nominal's polymorphic scheme.  "ToNominal Name" creates skolems for the nominal's type and unifies those with the type of the inner expression (this is where skolems are introduced)
05:45:48 <infinity0> ertes: not exactly, afaiu in coroutines you explicitly wait for an incoming value and don't proceed until you get it
05:45:51 <seph> Alright then, off I go to learn me some procedural (probably the wrong paradigm here) haskell!
05:46:07 * hackagebot htaglib 1.0.3 - Bindings to TagLib, audio meta-data library  https://hackage.haskell.org/package/htaglib-1.0.3 (mrkkrp)
05:46:20 <ertes> infinity0: coroutines are more general than that…  what's the application?
05:46:34 <infinity0> timeouts without IO, same as from yesterday :p
05:46:38 <Peaker> ski: so for example, in Lamdu, we represent "ST" as:  opaque nom ST;  nom ClosedST a = forall s. ClosedST (ST s a) ; runST : (ClosedST a) -> a
05:46:54 <ski> infinity0 : you can do coroutine-like stuff. what would "resorting to IO" entail ?
05:47:04 <ski> Peaker : "are allowed to have (top-level) foralls" -- i their kinds, i assume ?
05:47:23 <ertes> infinity0: ah, that's actually coroutines, even the "basic" ones that you could achieve with something like 'pipes'
05:47:52 <Peaker> ski: we don't have higher-kindedness (yet?), so we have 3 kinds (types, records, variants). Each TV has one of these
05:47:53 <ertes> infinity0: you get the general kind of coroutines by using FreeT from the 'free' package, but it has a learning curve both to use FreeT in the first place and see its "coroutine" interpretation
05:48:30 <MathuSumMut> Does Haskell have symbols like in Ruby or Scheme and/or reflection like in C# or Java?
05:48:38 <Peaker> ski: it'd be awesome if you toyed with Lamdu's GUI for a bit. Your feedback would be great :)
05:48:52 <ertes> infinity0: but be prepared to do quite some engineering before you get build a timeout construct…  using monad-control and System.Timeout is the easiest way out
05:49:06 <infinity0> ok i'll have a look at FreeT thanks. yes i do know about pipes and i can see how you could emulate timeouts with a Producer Int but you have to massage it quite a lot to be able to send this to many components at once
05:49:15 <infinity0> understood, this is a learning exercise for me mostly :)
05:49:40 <ertes> then by all means, learn FreeT =)
05:49:45 <Peaker> ski: https://github.com/Peaker/AlgoWMutable/blob/master/Lamdu/Expr/Type/Scheme.hs#L30-L42 <-- these are the "forall" binders
05:50:03 <ertes> infinity0: BTW, if you ever come across the monad-coroutine package, that's just FreeT in disguise…  use FreeT instead
05:50:27 <infinity0> i see ok
05:50:47 <ski> Peaker : "records, variants", not a single `row' kind for them, then ?
05:50:59 <ski> Peaker : well, "row/column". `composite' i suppose
05:51:05 <infinity0> oh the Free monad i read about this (and Freer and Eff) not too long ago... not sure how this helps, though...
05:51:26 <Peaker> ski: Yeah, https://github.com/Peaker/AlgoWMutable/blob/master/Lamdu/Expr/Type/Tag.hs#L17-L20
05:51:53 <ski> MathuSumMut : it doesn't have symbols/atoms like that. often, data constructors can be used for similar purposes
05:51:53 <ertes> infinity0: free monads are the monads of "suspendable computations", where the nature of suspension is defined by a functor
05:52:05 <ertes> infinity0: that allows you to create arbitrary cooperation patterns
05:52:11 <MathuSumMut> ok ski :)
05:52:26 <ertes> infinity0: with isolated components (they don't know that they cooperate or with what)
05:53:09 <ski> MathuSumMut : but they're divides into belonging to separate types. and they can't be dynamically generated
05:53:12 <infinity0> hm ok i'll take a look, thanks
05:53:21 <ph88> ski, i'm just trying to express the fact that elementOption can either be two choices, of which the second choice has a choice it in itself
05:53:26 <MathuSumMut> ic
05:53:56 <ertes> infinity0: start with Free, then move on to FreeT…  the latter is just the transformer variant of the former
05:54:09 <infinity0> ah, monad-coroutine has some specific examples at least, i'll read through that first even if FreeT is more general :)
05:54:32 <ertes> infinity0: FreeT isn't more general…  CoroutineT *is* FreeT =)
05:54:42 <ertes> they are isomorphic
05:54:49 <infinity0> oh ok
05:56:00 <ski> ph88 : yes, but what's the *intent* expressed by these two options ?
05:56:28 <ertes> infinity0: i just saw that monad-coroutine is maintained again…  so it seems fine to use it…  last time i checked it hadn't received updates for two years
05:57:31 <ski> Peaker : is the second `ClosedST' in `nom ClosedST a = forall s. ClosedST (ST s a)' the data constructor or what ?
05:58:52 <infinity0> ertes: i'm cool with using freeT, i just need to understand *how* first, and the concrete examples in coroutines helps with that
05:58:56 <rydgel> ertes: Hey buddy, are you the one behind Netwire?
05:59:38 <Peaker> ski: well, just making up Haskell-familiar notation. In practice we don't really have a separate data constructor. We have a NominalId, which identifies a Nominal, which has the scheme inside it. Type-level refers to NominalId and value-level does too (with fromNom/toNom)
06:00:04 <Peaker> fromNom/toNom could also be named unpackNominal/packNominal
06:00:12 <ph88> ski, it's for a grammar .. often you just have to choose one thing or another thing
06:01:02 <ski> (ok, i was thinking it looked like syntax)
06:01:07 * hackagebot fast-builder 0.0.0.3 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.0.0.3 (AkioTakano)
06:02:46 <ski> ph88 : if i knew the definitions of `Id',`Default',`Node',`Option',`Assign',`String_literal',`Assignment', i could perhaps offer some naming suggestion
06:02:52 <ski> .. otherwise i'd have to guess
06:03:48 <ph88> ski, this is the source https://github.com/antlr/grammars-v4/blob/master/antlr4/ANTLRv4Parser.g4#L416-L423 by *coinciden* elementOption choices intent are written there are comment .. but there are also a lot of rules where i don't know the intent
06:04:04 <ski> Peaker : "scheme" in the sense of "polymorphic type scheme", i asssume
06:06:00 <ph88> ski, i'm also not really sure how to capture this rule  https://github.com/antlr/grammars-v4/blob/master/antlr4/ANTLRv4Parser.g4#L249-L252   maybe data LexerAlt = Just MkLexerAlt LexerElements LexerCommands | Nothing  ??
06:06:32 <Peaker> ski: yeah
06:06:47 <ski> ph88 : assuming `// ...' is the line-comment in that grammar format, i think your Haskell translation is incorrect then. there should be no `Node Option' and `Option Assignment' parts in the alternatives for `ElementOption', iiuc
06:08:32 <ski> ph88 : er, also removing `Default', of course
06:09:44 <infinity0> ertes: so in the example for coroutine the actual component uses "yield" i.e. it has to co-operate explicitly
06:10:05 <infinity0> but i guess i can get around that by embedding "yield" in the override for >>= in my own wrapper (or FreeT / whatever) ?
06:11:00 <ski> ph88 : also, assuming `ASSIGN' just represents a single token, and assuming you don't want a data type that corresponds exactly to the concrete parse tree (iow, you want an Abstract Parse Tree, an AST, which is what is usually most suitable for further internal processing), then i'd just remove the `Assign' part from the data type as well
06:12:20 <ski> ph88 : also, i'd consider *perhaps* replacing `MkElementOptionA' by `Either Id String_literal', using the standard Haskell `Either' type to express a choice between two alternatives
06:13:02 <ski> ph88 : "perhaps", because this doesn't scale that nicely to the case with more than two "local alternatives". so if you have such cases, you might still want a specific separate data type here, for uniformity
06:13:36 <ski> ph88 : also, with a specific separate data types, the data constructor names for it can be more informative than `Left' and `Right', which you get with `Either'
06:14:24 <ertes> rydgel: yeah, that's me
06:14:55 <ertes> infinity0: 'yield' is a thin wrapper around 'liftF' or 'wrap'
06:14:57 <rydgel> ertes: I wanted to know, if the project is still supported
06:16:42 <ertes> rydgel: nope, i'm letting it die…  it will be replaced at some point by a new abstraction, but currently i have no idea when it will be done
06:17:13 <ski> ph88 : re, `LexerAlt', i'd suggest not defining your own constructors with names `Just' and `Nothing. however, you *could* do `type LexerAlt = Maybe (LexerElements,Maybe LexerCommands)' (the `?' there means optional, zero-or-one, so that's `Maybe')
06:17:25 <rydgel> ertes: Oh, ok. Have you any suggestion for a good replacement? Yampa maybe?
06:18:11 <ertes> rydgel: depending on the application i suggest either yampa or reactive-banana
06:18:24 <ski> ph88 : also, i'd suggest considering defining `LexerAltList' as the type of lists of `LexerAlts'. this isn't a perfect fit, since a `LexerAltList' shouldn't be empty, but as long as you're aware of this, it can work nice
06:18:25 <rydgel> I kind of love the Arrow notation tho :p
06:18:30 <ertes> rydgel: the former is good for time-framed applications like games and simulations, the latter is good for UIs
06:18:49 <ertes> rydgel: the arrow nature of AFRP is actually terrible, and i would do without, if i could
06:18:51 <rydgel> ertes: then, I will go with Yampa since it's a game
06:19:00 <ph88> ski, yes you are right there should be no "Default Node Option" there, this was a problem with my parsing script that translates this file into haskell skeleton. But i already have this fixed
06:19:06 <rydgel> ertes: really? why so?
06:19:37 <ski> ph88 : anyway, using `data LexerAlt = MkLexerAlt ... | MkEmptyLexerAlt' is also fine
06:20:01 <ph88> ski, about Assign, i have it implemented like this:  type TAssign = String
06:20:08 <ertes> rydgel: you use arrows when you can't express the abstraction as a monad…  if you do have a monad, there is no reason to use arrow style
06:20:21 <ertes> rydgel: try using Kleisli and you'll see the difference
06:21:01 <ph88> ski, why wouldn't i want a data type that corresponds exactly to the parse tree ?
06:21:15 <ski> ph88 : i saw no `TAssign' in your paste, only an `Assign'
06:21:41 <ph88> ski, that's because i'm making constantly fixes in my script ... the previous definition was    type Assign = String
06:21:55 <ski> ph88 : it depends on what you want to do. if you want to do something related to the *concrete* syntax, then perhaps you do want such a data type
06:22:14 <ph88> ski, don't understand what you mean with concrete type
06:22:25 <ski> ph88 : but often, you just want to get the "essential" information parsed into a tree format, and then an AST is preferable. less useless clutter
06:22:31 <rydgel> ertes: ok, will try. Thanks :)
06:22:52 <ertes> rydgel: the sad thing is that Wire is actually monadic, but (>>=) is so inefficient that it's pretty useless as a monad
06:23:27 <ski> ph88 : i was under the impression that `ASSIGN' in the grammar file was a token, and then that it was a token with no addition information attached (as opposed to `STRING_LITERAL', e.g.)
06:24:00 <rydgel> ertes: I liked netwire very much tho, but I didn't do extremly complicated things to maybe understand what bother you now with it
06:24:21 <ph88> ski, ASSIGN is "="
06:24:50 <ski> ph88 : yes, so there's no need to use a Haskell `String' to represent a string that is always going to be `"="'
06:24:58 <ph88> ski, ah yes i get what you're saying .. i really don't need to capture this "=" ..  so i have to inspect the tokens and see which ones i want to capture ?
06:25:24 <ertes> rydgel: netwire is great to *use*, but not so great to *develop*…  neither for authors of the abstraction itself, nor for framework developers…  it's too ad-hoc in many ways
06:25:27 <ski> ph88 : my advice is to just omit it from `ElementOption' (unless you want an exact tree corresponding to the parse tree .. which i doubt that you want)
06:25:50 <ph88> yeah !
06:26:01 <ertes> rydgel: as an application developer you notice it when you need a combinator that isn't predefined
06:26:07 <ski> ph88 : yes. tokens with additional information associated to them (like `STRING_LITERAL') will have to be retained in the AST. otherwise, just wipe them away :)
06:26:08 * hackagebot slug 0.1.3 - Type-safe slugs for Yesod ecosystem  https://hackage.haskell.org/package/slug-0.1.3 (mrkkrp)
06:26:45 <ph88> ski, i can also replace for everywhere where i have two choices with  Either  and have no custom data constructors anymore ..
06:26:50 <ski> ph88 : .. and try to invent a useful data constructor name, possibly based on the tokens that you strip away, and the other nonterminals in the alternative, and the comment if any
06:27:31 <ertes> rydgel: and that's mostly the reason why it's so large…  because of its ad-hoc nature i ended up trying to predefine as much as i could
06:28:01 <ski> ph88 : yes, but as i said, in the `Either' case, i'd pause to consider whether it'd be better to use a cusom named data type with custom named data constructors
06:28:34 <ph88> oki
06:28:51 <ski> ph88 : *especially* if you can imagine in the future adding or removing alternatives, i would suggest not using `Either' .. however, i suspect that the "in the future" possibly doesn't apply in your case, assuming this is an assignment/laboration
06:29:38 <ski> (but it'd still be helpful to try to behave *as if* you'd need to maintain this over some period of time. promotes good thinking habits)
06:30:08 <ski> ph88 : anyway, `foo?' in the grammar would usually become `Maybe Foo'
06:30:09 <ph88> ski, this will be OSS made in my spare time
06:30:15 <ski> ok, i see
06:30:21 <ski> then the above applies :)
06:30:29 <rydgel> ertes: I see, it makes sense
06:30:58 <ph88> ski, foo? to Maybe Foo  ... i already have this covered .. i have a script that reads the grammar and builds haskell skeleton
06:31:01 <ski> ph88 : also try to look out for lists-encoded-using-alternation-and-recursion in the grammar, and consider replacing that with a plain Haskell list, instead of a new data type
06:31:08 * hackagebot ginger 0.2.0.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.2.0.0 (TobiasDammers)
06:31:19 <ph88> ski, do you have any idea how i can figure out which tokens are interesting to capture and which are not ?
06:31:50 <ski> ph88 : when you said `data LexerAlt = Just MkLexerAlt LexerElements LexerCommands | Nothing' above, you had no `Maybe' wrapping the `LexerCommands' part (in the grammar : `lexerCommands?')
06:32:26 <ph88> ski, i'm not sure how i can find there  lists-encoded-using-alternation-and-recursion   if you want i can pastebin what i have so far
06:33:05 <ph88> ski, uhm i think i just mentioned like that as example, i will pastebin what i have so far ...
06:33:57 <tdammers> hmm, I wonder how long it should take for stack to pick up that hackage upload
06:34:10 <ski> ph88 : `lexerAltList' is an obvious(?) example of a what i meant by "lists-encoded-using-alternation-and-recursion" (in this case using Kleene star instead of recursion, but it's the same thing) (also, this is a non-empty list)
06:34:13 <ph88> ski, this is what i'm generating at the moment   http://pastebin.com/NPUDSgXy
06:34:49 <ski> ph88 : *nod*. stuff like `TComma' is useless :)
06:35:19 <ph88> ski, yes i think so too, but i have not figured out how i can read from the original source file (grammar file) which token will be interesting and which not (for capturing)
06:35:46 <ski> ph88 : "do you have any idea how i can figure out which tokens are interesting to capture and which are not ?" -- unfortunately nothing better than manually going over each case, using good judgement
06:36:08 * hackagebot flat-mcmc 1.0.0 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.0.0 (JaredTobin)
06:36:22 <ski> ph88 : well, that comment also applies to detecting lists, and figuring out when to use `Either', &c.
06:36:39 <ph88> ski, i'm going to inspect these antlr files a little bit more, because i would find it odd if antlr doesn't have some special syntax to indicate which tokens to capture
06:36:49 <ski> ph88 : perhaps there's a way to automagically detect which tokens/terminals are trivial, and which are carrying data. if so, it's (only) the latter you want to retain
06:37:04 <ph88> yeah !
06:37:33 <ski> perhaps there's only a fixed definite set of tokens that can carry data in this grammar system
06:37:55 <ski> or perhaps by looking at an associated lexer (if available), you can find out
06:38:23 <ph88> yes i'm going to look at it
06:38:28 * ski nods
06:38:40 <ph88> there is 1 parser file and 3 lexer files here https://github.com/antlr/grammars-v4/tree/master/antlr4
06:39:35 <rydgel> Did someone made a video game in FRP? I'm not sure how to handle various sound effects (the frp part/yampa).
06:39:40 <ski> ph88 : possibly it's not much use in your case, but you should also be aware of the BNF Converter tool, when you want to do grammary things
06:39:43 <ski> @where BNFC
06:39:43 <lambdabot> BNF Converter, http://bnfc.digitalgrammars.com/
06:39:56 <ski> it can generate Haskell/Java/... skeletons
06:40:20 <ski> its grammar format is not the same as the one you're using (which i assume is no written by you)
06:40:35 <ski> ph88 : it can be good to know about, anyway
06:40:45 <ph88> ye it's cool
06:40:52 <rydgel> My first guess would be to return each frame a list of sounds to be played (which are produced by event inside yampa)
06:46:09 * hackagebot flat-mcmc 1.0.1 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.0.1 (JaredTobin)
06:51:09 * hackagebot hw-succinct 0.0.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.2 (newhoggy)
06:51:09 <xa0> what's the upper limit of Char?
06:52:01 <hpc> > maxBound :: Char
06:52:03 <lambdabot>  '\1114111'
06:52:35 <xa0> really
06:52:51 <xa0> > Unsafe.Coerce.coerce 1118111 :: Char
06:52:53 <lambdabot>  Not in scope: ‘Unsafe.Coerce.coerce’
06:52:58 <xa0> oh. fine then.
06:53:06 <xa0> well it worked when i tried it
06:54:33 <xa0> why 1114111?
06:55:59 <tdammers> > 0x10FFFF
06:56:01 <lambdabot>  1114111
06:56:09 * hackagebot hw-succinct 0.0.0.3 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.3 (newhoggy)
06:56:17 <tdammers> https://en.wikipedia.org/wiki/Unicode#Code_point_planes_and_blocks
06:56:20 <tdammers> that's why
06:59:20 <xa0> aj
06:59:22 <xa0> thanks
07:01:09 * hackagebot hw-succinct 0.0.0.4 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.4 (newhoggy)
07:01:11 * hackagebot interspersed 0.1.0.2 - An abstraction over interspersing monadic actions  https://hackage.haskell.org/package/interspersed-0.1.0.2 (NikitaVolkov)
07:04:16 <chrisd_> I am following a book that was published in 1999, it is using Hugs. Can I still use Hugs or does it not matter if I am not using Hugs specifically
07:04:18 <ertes> rydgel: a very simple solution would be to have a sound event
07:04:32 <ertes> rydgel: you can feed it into whatever sound system you are using
07:05:10 <tdammers> chrisd_: depends on your goals... I believe you can still install and use Hugs, but if you're looking to do anything real-world, GHC is pretty much where it's at
07:05:47 <chrisd_> so all the exercise files related to the book, should run perfectly fine with GHC?
07:06:09 <ertes> rydgel: simple variant (Event Sound) or complicated variant (Event (IntMap SoundCommand)), where SoundCommand can start, stop, pause, seek, etc.
07:06:19 <tdammers> I wouldn't bet my life on it
07:06:39 <dysfun> i'm doing some template haskell and i'd like to be able to test things at the repl but I get errors about running in the IO Monad. Is there a workaround?
07:06:42 <tdammers> but if they don't, and you come here and ask, people will be happy to explain why
07:07:01 <chrisd_> thanks tdammers
07:07:17 <ertes> rydgel: for 3D sound you need a different design though…  more around behaviours than events
07:09:40 <rydgel> ertes: my game is 2D, and my actual version is to check the global game state each frame to know if I should play sounds. But I don't like it, cause it's outside the FRP system and duplicate some stuff
07:11:23 <rydgel> ertes: For instance I already have an event when you press the space bar, which move the player up. So I wonder if I can "attach" a sound to it from the FRP side
07:12:14 <ggVGc> rydgel: embed audio events in the returned value of your update functions?
07:12:31 <ggVGc> update :: GameState -> (GameState, AudioEvents)
07:13:03 <ggVGc> if something needs to generate something else, add it to the return type!
07:13:45 * xa0 spots a state monad
07:15:12 <rydgel> ggVGc: yeah, that's it
07:16:16 <rydgel> ertes ggVGc thanks again guys, it's very helpful
07:19:49 <lokien_> Hey guys, what do you think about Clojure?
07:20:29 <ggVGc> probably better than java
07:20:42 <tdammers> definitely better than java, and pretty good for a dynamically-typed language overall
07:23:38 <xa0> Slower than java too
07:23:57 <xa0> I'd really like it if it wasn't literally built on top of java
07:24:00 <tdammers> not in terms of developer performance
07:24:05 <xa0> But that's also it's main selling point
07:24:07 <xa0> So meh
07:24:25 <tdammers> also, you can get pretty close if you write the critical parts in java-with-clojure-syntax
07:24:45 <xa0> That just feels nasty doesn't it?
07:24:53 <ertes> rydgel: just make it an actual event
07:25:08 <tdammers> sort of, but not any nastier than offloading the heavy lifting to C in, say, Python
07:25:10 <ertes> rydgel: SF Input (Output, Event Sound)
07:25:20 <ertes> rydgel: replace "SF" by whatever framework you're using
07:25:20 <xa0> I suppose
07:25:30 <lokien_> xa0: it isn't slower in my experience, it's pretty much the same
07:25:39 <lokien_> And you can parallelize it easily 
07:25:47 <ertes> rydgel: that brings your sounds into the FRP system (the actual *playing* of then will still be outside)
07:25:52 <xa0> Fair enough
07:26:16 <lokien_> "pretty much the same" - maybe 10-20% slower with some numeric stuff
07:27:31 <tdammers> lokien_: in my experience, the biggest performance hit comes from resolving types at runtime
07:29:10 <dysfun> handily you can ask it to tell you when it would have to reflect and warn at compile time
07:30:29 <lokien_> tdammers: you can add type hints where you need them. I found lack of static typing more annoying than that
07:31:02 <tdammers> lokien_: yes, I know, and yes, stubbornly refusing to acknowledge the benefits of a proper type checker is kind of ridiculous
07:31:45 <xa0> I thought it was just part of the whole being a lisp thing
07:32:02 <xa0> Or trying to be anyway
07:32:29 <lokien_> It's more like the Scheme, honestly
07:33:11 <rydgel> ertes: `SF Input (Output, Event Sound)` is this the actual type you pass into reactimate?
07:36:32 * hackagebot interspersed 0.1.1 - An abstraction over interspersing monadic actions  https://hackage.haskell.org/package/interspersed-0.1.1 (NikitaVolkov)
07:39:43 <Shou> What's the infix value of the typeclass constraint arrow (=>)?
07:39:59 * fr33domlover before taking a look, imagines that package is more sophisticated than @sequence . intersperse action@
07:41:43 <ertes> rydgel: yeah (or reactInit)
07:42:06 <ertes> rydgel: and of course Input and Output are up to you
07:42:16 <ertes> yampa is really not that much different from netwire
07:42:30 <rydgel> ertes: yeah
07:43:03 <rydgel> ertes: but I should probably do `SF Input (Output, Event [Sound])`
07:43:24 <rydgel> ertes: since multiple sounds can be playing at the same time
07:43:36 <alpha44> How can one work with parsing imperative languages without using Parsec
07:43:48 <ertes> rydgel: indeed…  note that with the Event variant you *start* sounds
07:43:49 <alpha44> probably write a grammar checker first or something
07:44:08 <ertes> rydgel: if you want to synthesise with FRP, you need something like this:  SF I (O, Sound)
07:46:33 * hackagebot interspersed 0.1.1.1 - An abstraction over interspersing monadic actions  https://hackage.haskell.org/package/interspersed-0.1.1.1 (NikitaVolkov)
07:49:02 <rydgel> ertes: I will try both to understand the difference
07:50:33 <byorgey> alpha44: there are other parsing libraries besides parsec
07:52:21 <rydgel> Putting back the sounds into the FRP system allows me to generate "random sounds"
07:53:16 <ertes> rydgel: the Event variant is for generating sound *events* ("start", "stop", "seek", etc.)
07:53:36 <ertes> rydgel: the non-Event variant is for generating an actual sound signal, a sound wave
07:54:53 <rydgel> ertes: oh
07:56:50 * hackagebot interspersed 0.1.1.2 - An abstraction over interspersing monadic actions  https://hackage.haskell.org/package/interspersed-0.1.1.2 (NikitaVolkov)
08:06:16 <Glenjamin> Hello everyone, I'm looking for the simplest-possible haskell testing lib for use in an intro workshop exercise - any suggestions? 	as a reference point, i'm hoping to get something as tidy as these tests: https://github.com/glenjamin/defshef-blackjack/blob/master/clojure/src/defshef/blackjack.clj ideally in-line with the code
08:09:08 <ertes> Glenjamin: HUnit looks similar to this, but check out quickcheck and smallcheck, too
08:10:20 <ertes> the latter two support quantifiers nicely ("for all x, p x holds")
08:10:43 <Glenjamin> quickcheck is neat, but i'm worried about derailing the workshop a bit if i introduce generative testing :D
08:11:24 <ertes> there is the risk that you will need to explain how and why it works, yeah
08:11:51 * hackagebot IPv6Addr 0.6.1.0 - Library to deal with IPv6 address text representations.  https://hackage.haskell.org/package/IPv6Addr-0.6.1.0 (MichelBoucey)
08:12:01 <ertes> but you can explain it at a very high level, just to get people interested
08:12:16 <Zemyla> Can data types that consist of just two or more constructors with no fields in any of them be unpacked?
08:12:24 <Zemyla> Such as Bool or Ordering?
08:13:29 <Glenjamin> mm, i want to get a meetup about property-based testing at some point
08:13:35 <Zemyla> Basically, anything that can have tagToEnum called on it.
08:14:01 <ski> Shou : isn't `=>' the infix syntax ?
08:14:39 <eacameron> Is there a way to represent a monad transformer stack in a point-free compositional style? E.g. ReaderT Int :. ExceptT Err :. IO
08:15:45 <exio4> ReaderT e (StateT s IO) -- isn't this enough?
08:15:46 <ski> eacameron : it would be nice if there were (in a usable way). i'm not aware of anyone actually trying it
08:16:08 * ski has pondered some type system ideas related to this
08:16:21 <byorgey> Glenjamin: maybe https://hackage.haskell.org/package/doctest ?
08:16:30 <exio4> if you are talking about actual monad composition though...
08:17:04 <Glenjamin> byorgey: oh, that's perfect - thanks!
08:17:09 <eacameron> exio4: Its just awkward to read that, and it's pointful. I'd like to see the stack linearly in the same way I like to write function composition linearly (instead of nested)
08:17:11 <ertes> Zemyla: i'm pretty sure they are unboxed automatically in strict fields
08:17:30 <eacameron> ski: It doesn't seem like it would be all that hard to write a combinator like that.
08:17:37 <Glenjamin> i'd been thinking in my head "something like doctest in python", should have googled for a haskell version!
08:18:11 <byorgey> hehe
08:18:57 <Glenjamin> oh wow, it has quickcheck support too
08:19:22 <ski> eacameron : i suppose the question would be how much bother there would be at the interface, and how much useful work you can do inside this view
08:19:24 <ertes> eacameron: at action definition sites i prefer to use contexts, unless the composition order actually matters:  (MonadState S m, MonadReader E m) => m ()
08:19:26 <lpsmith> So I tried porting Jones and Gibbons' breadth-first renumbering algorithm to Oleg's "Lazy State monad" (as an extensible effect)
08:19:29 <exio4> eacameron: how is it pointful?
08:19:38 <ertes> eacameron: then pin down the concrete stack at the run site
08:19:56 <lpsmith> My first attempt didn't work,  it enters a non-productive loop
08:20:03 <ertes> eacameron: (assuming mtl)
08:20:22 <eacameron> ertes: No doubt. I'm just experimenting in my mind. :)
08:20:38 <ertes> eacameron: contexts compose
08:20:40 <sauvik> Hi all, I need some help. Can I define length of a list as "foldr (1+) 0"?
08:21:12 <ski> eacameron,ertes : it would be nice to have a better-fitting description of effects (commuting when possible, otherwise specifying an ordering)
08:21:32 <ski> lpsmith : links ?
08:21:32 <exio4> > foldr (1+) 0 "hello"
08:21:34 <lambdabot>      Couldn't match type ‘Char’ with ‘b -> b’
08:21:34 <lambdabot>      Expected type: [b -> b]
08:21:34 <lambdabot>        Actual type: [Char]
08:21:35 <ski> sauvik : yes
08:21:35 <eacameron> What ski said.
08:21:48 <ertes> ski: i remember a proposal based on free monads that i didn't like
08:22:01 <ski> sauvik : .. er, almost
08:22:18 <lpsmith> ski:  https://www.reddit.com/r/haskell/comments/4dan6q/lazy_state_with_extensible_effects/
08:22:18 <sauvik> ghci throws an error
08:22:20 <ski> sauvik : you also need to skip the current element. e.g. throw in a `const' there
08:22:21 <exio4> doesn't look like so
08:22:26 <lpsmith> I haven't posted my attempt yet
08:22:34 <ski> @type foldr (const (1+)) 0
08:22:36 <lambdabot> (Num b, Foldable t) => t b1 -> b
08:23:12 <nitrix> sauvik: Not quite, you have to drop the list element.
08:23:52 <lpsmith> oh wait, I did just now get it to work
08:23:57 <sauvik> How does const work? I am trying to understand.
08:24:18 <Glenjamin> thanks for the advice byorgey ertes :)
08:24:21 <nitrix> @src const
08:24:21 <lambdabot> const x _ = x
08:24:22 <ski> ertes : any link ?
08:24:24 <nitrix> sauvik: ^
08:24:29 <ski> lpsmith : ok. ty
08:24:32 <lpsmith> I forgot to add back in some applications "onDemand" that I removed while I was struggling with some type errors
08:24:34 <sauvik> Oh
08:24:52 <ertes> ski: i don't remember, but check out ocharles_' blog…  i think, it was there
08:25:09 <ski> sauvik : also `foldr (\_ -> (1 +)) 0', or `foldr (\_ n -> 1 + n) 0', if you prefer
08:25:32 <ski> ertes : do you know where that blog is ?
08:25:38 <sauvik> ski, nitrix: Thanks. That clears things up.
08:25:47 <ertes> ski: https://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html
08:25:52 <ertes> that's the one
08:25:57 <ski> ty
08:26:24 <ertes> ski: it's basically mtl, but with classes for functors rather than monads
08:26:34 <ertes> and the way the functors are composed determines the behaviour
08:26:59 <ertes> the advantage is that you can actually define first-class composition operators, and most of them are predefined
08:28:01 <ski> i'll try to remember to take a look
08:28:29 <ertes> at least that's what i took away from skimming the article =)
08:31:17 <lpsmith> ski, http://lpaste.net/158742
08:33:48 <lpsmith> (unfortunately,  trying to evaluate "runFresh (renumber completeTree)" runs into some type errors I didn't fully resolve)
08:36:11 <Shou> ski, oops yeah, I mean fixity. What's the fixity of (=>) basically
08:36:52 * hackagebot supplemented 0.5.0.3 - Early termination for monads  https://hackage.haskell.org/package/supplemented-0.5.0.3 (NikitaVolkov)
08:36:53 <Shou> I know (->) is infixr 0 so I'm hoping (=>) has a fixity defined somewhere
08:37:23 <geekosaur> it's syntax so not sure fixity applies. but more than one thing to the left requires they be in parens, so you can see it as fairly high fixity to the left (and lowest to the right --- hence syntax...)
08:37:34 <geekosaur> *you can say
08:37:44 <geekosaur> oh, no, right the first time. sigh
08:37:46 <ski> Shou : fixity is right
08:38:02 <ski> Shou : if you mean precedence, i'm not sure, but i would assume it's effectively `0'
08:38:34 <ski> geekosaur : s/fixity/precedence/
08:38:40 <geekosaur> yeh
08:39:22 <ski> @type let foo :: Ord a => a -> Ord a => a -> a; foo = undefined in foo
08:39:24 <lambdabot> Ord a => a -> a -> a
08:39:35 <ski> seems to suggest it has to be on the same level as `->'
08:41:59 <ski> Shou : btw, note that `@' has higher precedence than `10' (the (effective) precedence of application)
08:42:33 <ski> also `~' and `!' (used as prefix)
08:44:49 <Shou> geekosaur, I would assume multiple constraints require tuples however "type (%) (a :: Constraint) (b :: Constraint) = (,) a b" doesn't work, but "type (%) (a :: Constraint) (b :: Constraint) = (a, b)" does
08:45:14 <Shou> Hmm
08:45:45 <geekosaur> actualluy I misspoke, or at least spoke to the standard
08:45:53 <ski> imho, reusing `(...,...)' for composite constraints is a bit of a hack
08:46:01 <geekosaur> x => y => z is rejected by the standard, which wants (x, y) => z
08:46:12 <ski> (as is reusing tuple syntax for tuple *types*)
08:46:27 <geekosaur> but ghc takes it and even gives it special meaning in a few cases (pattern synonyms)
08:46:30 <ski> geekosaur, *nod*
08:47:00 <ski> geekosaur : also `foo :: (Foo => ...) -> ...' (`Rank2Types')
08:47:44 <ski> and, similarly `data Bar = Foo => MkBar ...' (`ExistentialQuantification', iirc)
08:53:27 <Shou> Continuing on what I said above, you can't give (,) a kind of "Constraint -> Constraint -> *", e.g. "type (%) (a :: Constraint) (b :: Constraint) = ((,) :: Constraint -> Constraint -> *) a b" either. So I think the "tuple" in constraints is indeed special.
08:53:53 <Iceland_jack> Shou: It may not be in the future if Constraint = Type
08:55:27 <Iceland_jack> But you can partially apply (&)
08:55:27 <Iceland_jack>     class    (a, b) => a & b
08:55:27 <Iceland_jack>     instance (a, b) => a & b
08:55:27 <Iceland_jack> see https://ghc.haskell.org/trac/ghc/ticket/11523 for more
08:57:57 <tromp> > let f='.';o c(x:y)=x:c y;z c(x:y)=f:c y;p n='p':ap fix p(o.n)in f:f:p z
08:57:59 <lambdabot>  "..pp.p.p...p.p...p.p...p.....p.p.....p...p.p...p.....p.....p.p.....p...p.p....
08:58:29 <Sornaensis> what's this
08:59:05 <tromp> a map of which numbers are prime
09:00:00 <Iceland_jack> > mapM(flip(!!))[1,0,8,1,11,0,10,5,0,15,6,7,3,6,0,9,14,8,2,4,12,13,0,1,12,4,0,11,12,7,8,4]" abcefhimnoprsuw"
09:00:00 <Iceland_jack>  
09:00:02 <lambdabot>  "a map of which numbers are prime"
09:00:37 <nitrix> You guys are wizards.
09:03:10 <Shou> Iceland_jack, not sure I understand completely, but in this case partial application wouldn't help in the type-operator definition because the kind would still be the same for (,)
09:03:45 <Shou> Is that ticket trying to fix that?
09:06:09 <Iceland_jack> Shou: The type would be 'Constraint -> Constraint -> Constraint', is that in the right direction? (missed the beginning of the question)
09:06:13 <Iceland_jack> https://ghc.haskell.org/trac/ghc/ticket/11715 might also be interesting
09:08:57 <Shou> Basically for type-level operators that deal with the LHS of (=>) i.e. typeclass constraints, each kind of the tuple has to be Constraint which it isn't when you just partially apply it like so: type (%) = (,)
09:31:30 <ggVGc> @pl (\a b -> snd $ foo a b)
09:31:30 <lambdabot> (snd .) . foo
09:31:54 * hackagebot pipes-zlib 0.4.4 - Zlib and GZip compression and decompression for Pipes streams  https://hackage.haskell.org/package/pipes-zlib-0.4.4 (RenzoCarbonara)
09:31:54 <shapr> totally readable
09:36:06 <acertain> is ap == \f a -> f >>= \f' -> f' <$> a   ?
09:37:43 <acertain> yes
09:40:40 <acertain> why is ap defined how it is then?
09:40:52 <acertain> or liftM* for that matter
09:40:58 <mirpa> ap is <*> isn't it?
09:41:19 <acertain> in terms of Monad, yes
09:41:20 <xa0> yes
09:41:28 <acertain> :src ap
09:41:30 <GLM> Does anyone know what the following error message means from a stack build context?
09:41:30 <xa0> it's just a more restricted version
09:41:31 <acertain> @arc ap
09:41:31 <lambdabot> Maybe you meant: src rc arr
09:41:32 <GLM> setup: sh: inappropriate type
09:41:44 <acertain> @src ap
09:41:44 <lambdabot> ap = liftM2 id
09:42:04 <geekosaur> ap should be considered a historical artifact
09:42:24 <ski> (acertain : nitpick, s/==/=/)
09:42:26 <lyxia> acertain: ap is used to deduce instances of Applicative and Functor from the Monad instance
09:42:30 <geekosaur> (Monad, including ap and liftM*, predates Applicative by a couple decades)
09:43:02 <ski> acertain : `ap = liftM2 ($)'
09:43:12 <ski> @src ap
09:43:12 <lambdabot> ap = liftM2 id
09:43:23 <acertain> @src liftM2
09:43:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:43:47 <ski> @. undo src liftM2
09:43:47 <lambdabot> liftM2 f m1 m2 = m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2);
09:44:27 <ski> @pl m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
09:44:27 <lambdabot> (`fmap` m2) . f =<< m1
09:44:52 <ski> @pl \f m1 m2 -> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
09:44:52 <lambdabot> liftM2
09:44:54 <ski> hah
09:45:33 <mjrosenb> well, it isn't wrong.
09:49:14 <nmdanny> how to talk with lambdabot?
09:49:56 <ski> > reverse "gnirts"
09:49:57 <lambdabot>  "string"
09:50:01 <geekosaur> /query lambdabot
09:50:02 <ski> @help run
09:50:02 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:50:13 <ski> /msg lambdabot @list
09:50:36 <mirpa> https://wiki.haskell.org/Lambdabot
09:50:56 <nmdanny> @help run
09:50:57 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:51:02 <nmdanny> run 5+5
09:51:04 <nmdanny> @run 5+5
09:51:06 <lambdabot>  10
09:51:16 <Cale> > 5 + 5
09:51:18 <lambdabot>  10
09:51:21 <nmdanny> @run 10**10**10**10
09:51:23 <lambdabot>  Infinity
09:51:26 <GLM> Does anyone know how to fix this build error?
09:51:28 <nmdanny> @run 10**500
09:51:30 <lambdabot>  Infinity
09:51:32 <nmdanny> @run 10**50
09:51:34 <lambdabot>  1.0e50
09:51:38 <nmdanny> @run 10**55
09:51:38 <Cale> > 10^50
09:51:40 <lambdabot>  1.0e55
09:51:40 <lambdabot>  100000000000000000000000000000000000000000000000000
09:51:41 <GLM> Linking /private/var/folders/57/p7nyjyfd63lfwgzh_2y_m120myryqt/T/stack20003/network-2.4.2.3/.stack-work/dist/x86_64-osx/Cabal-1.18.1.5/setup/setup ...
09:51:42 <GLM>     Configuring network-2.4.2.3...
09:51:42 <GLM>     setup: sh: inappropriate type
09:51:48 <nmdanny> @run 10**60
09:51:50 <Cale> > 2^500
09:51:51 <lambdabot>  1.0e60
09:51:52 <lambdabot>  3273390607896141870013189696827599152216642046043064789483291368096133796404...
09:51:59 <nmdanny> @run 10**99
09:52:00 <lambdabot>  1.0e99
09:52:03 <nmdanny> @run 10**99.999
09:52:05 <lambdabot>  9.977000638225424e99
09:52:08 <nmdanny> @run 10**99.999999999999
09:52:08 <Cale> nmdanny: Note that you can talk to lambdabot in pm though
09:52:10 <lambdabot>  9.999999999977094e99
09:52:15 <Cale> rather than spamming the channel with this :)
09:52:22 <mjrosenb> nmdanny: they're doubles, the max value is around 10^308.
09:53:06 <Cale> Yeah, since you're using (**) both the arguments and the result are of some Floating type, which will default to Double
09:53:08 <Cale> :t (**)
09:53:09 <lambdabot> Floating a => a -> a -> a
09:53:14 <Cale> :t (^^)
09:53:15 <lambdabot> (Fractional a, Integral b) => a -> b -> a
09:53:18 <Cale> :t (^)
09:53:20 <lambdabot> (Integral b, Num a) => a -> b -> a
09:53:24 <EvanR> > maxBound :: Double
09:53:26 <lambdabot>      No instance for (Bounded Double) arising from a use of ‘maxBound’
09:53:26 <lambdabot>      In the expression: maxBound :: Double
09:53:37 <EvanR> surprising considering the other wacky instances
09:53:55 <Cale> By contrast, (^^) allows any Fractional type of base and result, but requires an Integral exponent
09:54:21 <Cale> and (^) allows any Num type of base and result, but needs a non-negative Integral exponent
09:54:43 <mjrosenb> EvanR: what value were you expecting?
09:54:51 <Cale> Infinity perhaps :)
09:54:51 <EvanR> you never know with Doubles
09:55:01 <EvanR> there is no Double d which d > Infinity is True... so... seems like a candidate instance
09:55:44 <EvanR> Double is closed and bounded ;)
09:57:11 <mniip> EvanR, there's a Double d for which d <= Infinity is False
09:57:15 <scshunt> ^
09:57:26 <EvanR> so!
09:57:30 <scshunt> Infinity is not an uppser bound for Double
09:57:34 <scshunt> although it's a maximal element
09:58:14 <EvanR> i guess theres no "for all d Infinity >= d"
10:00:35 <EvanR> i did the meetup group on exact real numbers and went over like 5 ways to do real numbers, and whats wrong with doubles, and whats wrong with rationals, and whats wrong with interval arithmetic, and whats wrong with unums (namely, that its not clear how you can implement it for high precision (to me yet))
10:00:45 <EvanR> and you cant divide by 3 with Scientific
10:00:52 <EvanR> so im kind of pissed at numbers right now
10:01:17 <schell> when profiling with “-hc”, is it possible to get the full names of the functions that are sampled? my *.hp and resulting *.ps (after hp2ps) all have truncated names, which makes it difficult to tell where the allocation is happening
10:01:31 <EvanR> is there some number type with fractions that does not suck
10:01:39 <mjrosenb> EvanR: unums?
10:01:54 <EvanR> are you saying it does not suck or
10:02:07 <mjrosenb> EvanR: no, I have no clue what that is.
10:02:09 <EvanR> oh
10:02:18 <EvanR> it exists purely as power points
10:02:55 <Tehnix> are you saying it does not suck or
10:03:30 <EvanR> mjrosenb: here http://sites.ieee.org/scv-cs/files/2013/03/Right-SizingPrecision1.pdf is one 
10:03:38 <mjrosenb> EvanR: surreal numbers don't suck, but I don't think they can really be implemented on a computer :-p
10:04:00 <EvanR> http://www.slideshare.net/insideHPC/unum-computing-an-energy-efficient-and-massively-parallel-approach-to-valid-numerics
10:04:11 <EvanR> mjrosenb: real numbers would be fine too
10:04:32 <EvanR> but all implementations i covered except perhaps exact-real on hackage are not practical
10:05:26 <geoffreyiy> @t runQ
10:05:26 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:08:20 <nmdanny> for the *> operator, it executes the left applicative, ignores its results and returns the right applicative, right?
10:08:30 <mettekou> nmdanny: Bingo.
10:11:05 <nmdanny> :t liftA2
10:11:06 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:11:27 <nmdanny> :t liftA2 const
10:11:28 <lambdabot> Applicative f => f c -> f b -> f c
10:17:34 <mettekou> :t liftA2 (flip const)
10:17:36 <lambdabot> Applicative f => f b -> f c -> f c
10:35:38 <przembot> is servant-js available for servant 0.4?
10:42:15 <acertain> http://www.johngustafson.net/presentations/Multicore2016-JLG.pdf is interesting (another replacement for floats)
10:44:28 <acertain> i'd like sequences of numbers where if the ubit is set then there's another in the interval specified by the previous
10:44:45 <acertain> i don
10:45:20 <acertain> i have no idea how easy using something like that in proofs would be, but it sounds ideal
10:46:31 <juanpablo_> How would I go about creating a traversable based on a predicate? I mean I have a list of `a` and I would like a traversal that focuses on the `a` that satisfy a predicate
10:46:54 <juanpablo_> or rephrasing that: how do I parameterize a traversal with a predicate?
10:48:21 <juanpablo_> There could be mutliple `a` that satisfy the predicate, of course
10:48:31 <juanpablo_> each should be a focus in the traversal
10:48:35 <nitrix> It's the other way around. Filtering with a predicate would use your traversable instance.
10:50:15 <juanpablo_> nitrix: ok, but how would I instantiate the traversable with the predicate?
10:51:59 <nitrix> You just asked the same question again :P
10:52:14 <acertain> juanpablo_, what do you want to do?
10:52:19 <juanpablo_> nitrix: sorry, I'm still learning about lenses
10:52:38 <acertain> https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Fold.html#v:filtered
10:52:54 <acertain> it's not a legal traversal though
10:53:13 <juanpablo_> I'd like to use `over` to apply a function to elements in a list that satisfy a predicate
10:53:20 <acertain> so you should probably try to do whatever your doing some other way
10:53:34 <nitrix> juanpablo_: over f . filter p $ xs
10:53:54 <nitrix> Or something like that.
10:54:23 <juanpablo_> I mean I can do it with filter and map. But I'm trying to become better at lens
10:54:57 <acertain>  > over (each.filtered even) (+1) [1..10]
10:55:03 <acertain> [1,3,3,5,5,7,7,9,9,11]
10:55:25 <juanpablo_> acertain: that's exactly what I wanted
10:55:31 <acertain> don't use that
10:55:35 <juanpablo_> now I'll study the types to see how they unify.
10:55:43 <juanpablo_> because it's not a valid traversal?
10:55:47 <acertain> yes
10:56:46 <Jinxit> I wouldn't use lens if the basic toolkit already solves the problem
10:56:57 <Jinxit> it only obfuscates the code
10:57:08 <juanpablo_> I mean yes. This is an exercise to learn lens
10:57:10 <Jinxit> (that said, I'm all for lenses when they make sense)
10:57:13 <acertain> although it might be convenient in a long lens chain
10:57:52 <juanpablo_> This is not a legal Traversal, unless you are very careful not to invalidate the predicate on the target
10:58:21 <juanpablo_> What does invalidate mean here? That the predicate no longer yields true on the target?
10:58:30 <acertain> yes
10:59:41 <djanatyn> hey, i'm imagining a function that takes a single value, and a list of functions, and applies those functions to the value from left to right, kinda like reduce. something like :: a -> [(a -> a)] -> a
11:00:04 <ertesx> are the infinity values of Double portable?  i need min and max monoids, and i thought about using +/-infinity as identity respectively
11:00:06 <xa0> you could do that with a foldl
11:00:25 <xa0> foldl ($) initial list
11:00:35 <hpc> ertesx: they follow the IEEE spec
11:00:37 <djanatyn> ah i always forget haskell has such a rich set of folding functions
11:00:37 <juanpablo_> hmm interesting. It would be a valid traversal in the usecase. Is there a `filtered` traversal that doesn't have the restriction of not invalidating the predicate?
11:00:39 <djanatyn> been writing too much python
11:00:43 <xa0> lol
11:00:44 <djanatyn> i knew it was something reduce-y
11:01:16 <ertesx> hpc: is that guaranteed by h2010?
11:01:22 <acertain> you could not set the value back if the predicate is false
11:01:34 <acertain> i don't think there's something in lens for that though
11:01:57 <juanpablo_> over (each.filtered even) (*2) [1..10] is using the traversal correctly, right?
11:02:11 <acertain> yes
11:02:48 <juanpablo_> This is so much succinct that my previous `mapIf` implementation
11:03:07 <juanpablo_> I'm half-tempted to pull lens as a dependency. But probably won't
11:03:08 <ertesx> djanatyn: if the list is static, you might as well just compose the functions
11:03:55 <djanatyn> ertesx: that's the thing, i want to do this dynamically, with a list of functions where the length doesn't matter
11:04:03 <djanatyn> just something piping a value through a bunch of functions that match the type signature
11:04:09 <Tehnix> djanatyn: if the list is static, you might as well just compose the functions
11:04:37 <djanatyn> oh yeah. sorry. sleepy.
11:04:57 <monochrom> ertesx: Haskell 2010 does not guarantee IEEE floating point. However, it guarantees that the RealFloat method "isIEEE" tells you.
11:04:58 <EvanR> > read "Infinity" :: Double
11:05:00 <lambdabot>  Infinity
11:05:03 <EvanR> ertesx: ^
11:05:14 <hpc> ertesx: i recommend you read h2010 yourself - it's notoriously light on operational details (not sure entirely what you mean by "portable")
11:05:14 <juanpablo_> Microlens has all I need. I might use it
11:05:27 <EvanR> parseFloat('Infinity')
11:05:28 <hpc> but the semantics you would need for min/max should certainly be there
11:05:29 <EvanR> Infinity
11:06:00 <ertesx> monochrom: thanks
11:07:34 <monochrom> to a large extent, I haven't seen a non-IEEE environment GHC runs on. (to be sure, I am not sure about ARM and PowerPC)
11:07:45 <ertesx> hpc: Double is not Bounded unfortunately…  i guess with RealFloat i could get the minimum value and pretend that Infinity doesn't exist
11:08:10 <ertesx> (it shouldn't come up in my application)
11:08:21 <EvanR> you can make a new type that behaves...
11:08:24 <monochrom> there is also "isInfinite" for a test
11:09:10 <ertesx> EvanR: if i use GND, that type will act just like Double…  if i don't i'll probably give up a lot of Double's efficiency, and this is performance-critical code
11:09:42 <EvanR> :(
11:10:04 <djanatyn> i think i'm gonna read h2010 today on the bus to brush up
11:10:23 <djanatyn> a lot of things that were too much for 15 y/o haskeller-me are a lot less scary now. i can't understand what got me confused about arrows
11:10:35 <monochrom> Haskell 2010 is a good read. You will always find things no tutorial mentioned.
11:11:14 <ertesx> i guess i should do that, too, some day
11:11:28 <hpc> more importantly, you will know EXACTLY what haskell is
11:11:31 <monochrom> For example you have no idea that the way it gets do-if-then-else to work implies this: http://lpaste.net/81623
11:11:49 <ertesx> hpc: and then say: "nevermind, i'm using GHC-haskell anyway" =)
11:12:06 <hpc> yeah, but it's still a nice reality check on what's guaranteed and what isn't
11:12:20 <hpc> you'll probably be surprised if you've ever read another language spec
11:12:58 <ertesx> to be honest i haven't read any language spec yet except for some esoteric languages
11:13:26 <ertesx> i probably know unlambda, lazy k and brainfuck better than haskell 2010 =)
11:14:41 <monochrom> haha
11:14:56 <nmdanny> :info fromMaybe
11:20:21 <nmdanny> @run length Nothing
11:20:23 <lambdabot>  0
11:20:33 <nmdanny> @run length Just "123456"
11:20:35 <lambdabot>      Couldn't match expected type ‘[Char] -> t’ with actual type ‘Int’
11:20:35 <lambdabot>      The function ‘length’ is applied to two arguments,
11:20:35 <lambdabot>      but its type ‘(a0 -> Maybe a0) -> Int’ has only one
11:20:41 <nmdanny> @run length $ Just "123456"
11:20:43 <lambdabot>  1
11:24:22 <xa0> > (Just,Just) 3
11:24:23 <lambdabot>      Couldn't match expected type ‘Integer -> t’
11:24:23 <lambdabot>                  with actual type ‘(a0 -> Maybe a0, a1 -> Maybe a1)’
11:24:23 <lambdabot>      The function ‘(Just, Just)’ is applied to one argument,
11:24:36 <xa0> Well, yeah
11:25:03 <xa0> You know how a -> (b,c) is isomorphic to (a->b, a->c)
11:25:18 <xa0> Is there a specific way of.. Showing that?
11:26:21 <acertain> > let it (f,g) x = (f x, g x) in it (Just,Just) 3
11:26:23 <lambdabot>  (Just 3,Just 3)
11:26:42 <ertesx> xa0: two ways: 1. show an isomorphism, 2. do the type algebra
11:26:57 * hackagebot liquidhaskell-cabal 0.1.0.0 - Liquid Haskell integration for Cabal and stack  https://hackage.haskell.org/package/liquidhaskell-cabal-0.1.0.0 (MichaelSmith)
11:27:05 <xa0> Okay
11:27:12 <xa0> Makes sense
11:27:24 <ertesx> xa0: a -> (b, c) ≃ (b × c)^a ≃ b^a × c^a ≃ (a -> b, a -> c)
11:27:55 <xa0> Ahh thats very tidy.
11:28:08 <xa0> Yeah, fair enough
11:28:31 <acertain> let other f = (fst.f, snd.f) in other (\x -> (Just x, Just x)) 3
11:28:33 <ertesx> (×), which is (,), and (+), which is Either, form a semiring with respect to ≃
11:28:37 <acertain> > let other f = (fst.f, snd.f) in other (\x -> (Just x, Just x)) 3
11:28:39 <lambdabot>      Couldn't match expected type ‘Integer -> t’
11:28:39 <lambdabot>                  with actual type ‘(a0 -> Maybe a0, a0 -> Maybe a0)’
11:28:39 <lambdabot>      The function ‘other’ is applied to two arguments,
11:29:35 <acertain> > let other f = (fst.f, snd.f) in case other (Just,Just) of (f,g) -> (f 3, g 4)
11:29:36 <lambdabot>      Couldn't match expected type ‘Integer -> (t, t1)’
11:29:37 <lambdabot>                  with actual type ‘(a0 -> Maybe a0, a1 -> Maybe a1)’
11:29:37 <lambdabot>      In the first argument of ‘other’, namely ‘(Just, Just)’
11:31:09 <ertesx> reminds me: has anyone managed to turn that into a full ring?  i've seen a few attempts, but none of them were really satisfying
11:31:33 <ertesx> i.e. has anyone made sense of negative and reciprocal types?
11:31:59 <Elision> yes
11:32:04 <Elision> I found a paper on it a while ago
11:32:34 <Elision> negative and reciprocal types were both sort of constraints?
11:32:49 <ertesx> Elision: was it the one with the countless weird flow diagrams?
11:32:51 <Elision> [this is not very useful, I'll warn you]
11:32:52 <Elision> yes
11:32:54 <Elision> I think so
11:33:26 <Elision> some of which went backwards in time
11:33:30 <xa0> Haha what
11:33:33 <ertesx> i've read that one…  IIRC that's not a ring, and there were some rather awkward limitations
11:33:44 <Elision> definitely
11:34:28 <ertesx> xa0: Either Bool (-Bool) ≃ Void  -- negative types
11:34:46 <ertesx> it's a weird concept, but i have found cases when it would actually have been useful
11:35:05 <xa0> ..that's bizarre
11:35:07 <ertesx> more with reciprocal types than with negative types though
11:35:31 <Elision> yeah I remember reciprocals being a LITTLE more useful
11:35:48 <Elision> (a, 1/a) ~= () isn't the worst isomorphism ever
11:35:49 <Sornaensis> what means negative type
11:36:15 <Elision> Sornaensis: https://www.cs.indiana.edu/~sabry/papers/rational.pdf go wild
11:36:20 <xa0> But how exactly do you.. Use those
11:36:24 <Elision> you don't :P
11:36:25 * Sornaensis derobes
11:36:53 <xa0> Lol
11:37:01 <Elision> even this paper only talks about it in the context of a *reversible* programming language, which very few people talk about non-abstractly, I think
11:37:13 <ertesx> Sornaensis: we don't really know what it means, as nobody was able to make sense of it yet
11:37:21 <digitalmentat> does anyone else have the incredibly annoying issue of haskell-mode seemingly at random popping up a tags completion buffer?
11:37:31 <digitalmentat> I haven't remapped any keys, I've only upgraded haskell-mode
11:37:37 <digitalmentat> wondering if someone else has run into this
11:37:49 <ertesx> xa0: i have found at least one use case for reciprocals:  imagine:  data T a b = OnlyL a | OnlyR b | Both a b
11:37:50 <xa0> So its like theoretical computer science
11:37:56 <Elision> I remember vaguely applying this to determine what data structure had a self-similar zipper structure
11:38:28 <xa0> Hmm, yeah that could be interesting
11:38:47 <Elision> we went "well, zipper is the differential operator. so we're looking for T(a) = dT(a) which means T(a) should be something like e^(a)"
11:39:18 <Asuran> can i get please an honest answer: how fast is haskell compared to C or c++
11:39:40 <ertesx> xa0: if types were a field, you could derive:  T a b ≃ a + b + a×b ≃ a×b×(1/b + 1/a + 1)
11:39:40 <mauke> about 3 feet
11:39:57 <Asuran> and how good is the support for sockets on each supported platform and other os api stuff?
11:40:17 <ertesx> xa0: data T a b = T a b (Either (Recip a) (Either (Recip b) ()))
11:40:30 <Asuran> mauke, why you want to troll me? ^^ i just want to know if haskell is right for me because i like the syntax kinda
11:40:40 <mauke> Asuran: your question is nonsensical
11:40:40 <xa0> ertesx: woah, that's cool
11:40:50 <ertesx> xa0: if the third field is a Left, that means that you get an 'a', a 'b' and a '1/a', which is really a witness that the 'a' value doesn't exist
11:41:14 <Asuran> mauke, because? i doubt haskell does same good as a optimized c compiler or does it?
11:41:15 <acertain> Asuran, average haskell code is much slower, but you can make it as fast (and if you write essentially C in haskell you can make it faster)
11:41:23 <ertesx> xa0: that way you could write your functions more compactly, as long as you handle those witnesses
11:41:36 <mauke> Asuran: because what's the speed of C?
11:41:36 <xa0> That's pretty awesome.
11:41:53 <Asuran> mauke, compared to what? java?
11:41:54 <mauke> inb4 300000 km/s
11:41:55 <ertesx> xa0: it isn't really anything…  it's a theory that may not make sense at all =)
11:41:59 <mauke> Asuran: no, just the speed
11:42:18 <xa0> Well sure but if that sort of type algebra was possible it'd be great fun :D
11:42:23 <liste> Asuran: the language doesn't determine software performance, the developer does
11:42:30 <Asuran> mauke, its relative to something, if you want that kinda of speed test i cant give you informations, never had this need of test
11:42:44 <Asuran> liste, it does, for sure
11:42:46 <ertesx> xa0: in particular for this to work you need to make sense of negative types as well…  and i'd assume them to be more type-level things, while reciprocal types would be more value-level things
11:42:48 <mauke> Asuran: speed isn't relative
11:43:07 <liste> Asuran: sockets sure are supported, see if there's everything you need: https://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html
11:43:10 <xa0> Yeah fair enough
11:43:22 <ertesx> xa0: it is sometimes possible practically, *if* you get rid of the quotients and negatives…  there is a paper called "six trees in one" or something
11:44:02 <ertesx> it goes through that algebraic non-sense and then returns to regular algebra, and it works
11:44:31 <ertesx> similar to how you can sometimes "escape" to the larger universe of complex numbers, as long as you return to real numbers
11:44:33 <sm> Asuran: I'll give you a short answer. Hand-optimized haskell is 1x-2x C speed, idiomatic haskell is 10x.
11:44:52 <xa0> Heh, yeah
11:44:55 <ertesx> sm: that's overly pessimistic
11:44:56 <xa0> Interestinf
11:45:29 <Asuran> if this would be true, why people still use c for making things like webserver, i mean with that performance
11:45:43 <Asuran> and no risk of pointer usage
11:45:46 <the_2nd> http://lpaste.net/8378532895781814272
11:45:54 <xa0> Because its the status quo
11:45:56 <sm> C is familiar, everywhere, and more predictable
11:46:01 <the_2nd> Is there a function like zip, but which returns lists?
11:46:07 <the_2nd> see my example
11:46:13 <Asuran> this makes haskell yummy to me
11:46:20 <ertesx> Asuran: legacy, familiarity and in some cases blind conviction that C is the only language you can use for fast code
11:46:30 <EvanR> wait
11:46:30 <the_2nd> or, when I define many lists as rows
11:46:37 <the_2nd> how can I get lists of columns?
11:46:37 <EvanR> idiomatic haskell is 10x C speed
11:46:39 <EvanR> ?
11:46:50 <EvanR> that grossly violates relativity
11:46:55 <johnw> EvanR: that is a pretty gross generalization
11:46:57 <xa0> Hahaha
11:47:30 <the_2nd> the lower you go, the faster you can get
11:47:37 <ertesx> Asuran: many C programmers have trouble trusting the compiler…  they use C, because it gives them control
11:47:45 <mauke> > transpose [ [1,2,3,4], [5,6,7,8], [1000,1001,..] ]
11:47:47 <lambdabot>  <hint>:1:46: parse error on input ‘..’
11:47:53 <mauke> > transpose [ [1,2,3,4], [5,6,7,8], [1000,1001 ..] ]
11:47:54 <lambdabot>  [[1,5,1000],[2,6,1001],[3,7,1002],[4,8,1003],[1004],[1005],[1006],[1007],[10...
11:47:56 <xa0> The thing to take away really is that it varies wildly, depending on what you do and how much you optimize it, but generally they're about equal(?)
11:48:02 <the_2nd> mauke, thanks!
11:48:17 <ReinH> The most significant factor in Haskell performance is who is writing the code.
11:48:22 <ReinH> As in any other language.
11:48:30 <ertesx> xa0: sometimes C wins, sometimes haskell wins, but the margins are rather small nowadays
11:48:41 <ertesx> GHC is incredibly smart about making code efficient
11:48:51 <mauke> ReinH: also, the implementation/platform you use
11:48:52 <xa0> Yeah
11:49:17 <ertesx> disclaimer: i have only compared to GCC and clang
11:49:22 <EvanR> i was pointing out that 10x C speed is implying the opposite ...
11:49:28 <ReinH> mauke: correcting for those things, ofc. Clearly Haskell will run faster on a i7 than a 386.
11:49:46 <mauke> weird, my CPU doesn't run haskell at all
11:49:49 <ReinH> And they are staticall known differences.
11:49:58 <EvanR> i instantly feel emotionally that typical haskell will be slower than typical C, but then i think about what typical C really is like...
11:50:35 <ReinH> People who say that it's really difficult to write fast Haskell I guess have never tried to write fast C.
11:50:39 <hpc> typical programs won't give a crap how fast the base language is
11:50:43 <ertesx> typical haskell looks like doing matrix arithmetic with lists of lists…
11:50:46 <EvanR> a mishmash of custom memory allocation strategies and buggy implementations of common lisp
11:51:03 <maerwald> ReinH: I don't think so
11:51:07 <ertesx> idiomatic haskell actually runs very fast:  using lists of lists as matrices is *not* idiomatic
11:51:20 <maerwald> but the difficulties are different
11:51:35 <mauke> never look at the source of the whitespace interpreter
11:51:37 <maerwald> so for some, one difficulty is more difficult than the other
11:51:48 <cocreature> ertesx: yeah you should be using a single list and convert the indices and use !
11:51:58 <EvanR> you have your known difficulties, and unknown difficulties, and difficulty difficulties
11:51:58 <ertesx> hehe
11:52:00 <ReinH> maerwald: My point is that it requires specialized knowledge, as does C, and that it's difficult to make both fast.
11:52:13 <ReinH> It's just that more people have the specialized knowledge for C
11:52:13 <maerwald> ReinH: the specialized knowledge however is vastly different
11:52:17 <maerwald> yeah
11:52:29 <maerwald> and it's more "common knowledge"
11:52:37 <maerwald> because we've been doing this crap for decades
11:52:52 <EvanR> specialized knowledge for optimizing C is probably not that common
11:52:55 <EvanR> there is common knowledge but
11:53:13 <EvanR> whether its appropriate for that task
11:53:16 <ReinH> No one should be surprised that after almost 45 years of nearly ubiquitous use, we've gotten better at writing performant C.
11:53:18 <maerwald> it's pretty common. Even basic loop optimization is taught in basic programming sources
11:53:41 <maerwald> ReinH: so maybe we lack tutorials/documentation etc for writing fast Haskell
11:53:47 <ReinH> Yeah.
11:53:49 <EvanR> that is a very basic example which compilers already do for you
11:53:54 <ertesx> EvanR: actually GCC is surprisingly good at making even the worst code fast…  also usually you need to write inefficient C *explicitly*
11:54:00 <maerwald> and I've not seen many libraries that go out of their way to do REALLY fast haskell... and those that do, have almost unreadable code :D
11:54:21 <maerwald> @hackage friday
11:54:21 <lambdabot> http://hackage.haskell.org/package/friday
11:54:23 <maerwald> comes to my mind
11:54:39 <EvanR> by comparison, C is unreadable whether its fast or not !
11:54:39 <ertesx> that's not true for haskell, because it's vastly more difficult to optimise and idiomatic haskell, if you were to compile it naively, would be much slower than what GHC produces
11:54:45 <maerwald> EvanR: heh
11:55:34 <EvanR> ertesx: im under the impression that the language semantics allow a lot more kinds of optimizations
11:55:36 <ertesx> maerwald: using the correct data structures and algorithms doesn't look too bad in haskell =)
11:55:43 <ReinH> maerwald: Generally the ugliest thing about performant Haskell is all the pragmas sprinkled around. ;)
11:55:56 <ReinH> INLINE INLINE INLINE INLINE
11:56:15 <hpc> almost all the performance gains come from being able to use the right algorithm without weeks of just trying to implement it
11:56:27 <ertesx> EvanR: it does, but those are large-scale optimisations…  it doesn't imply any micro-optimistations, and that's what makes the code make smart use of memory and the cache
11:56:50 <ReinH> Also people pick lazy data structures like tuples and then add a bunch of bangs to make them strict, which is repetitive and error prone and repetitive.
11:57:00 <ertesx> EvanR: GHC's GC for example is an extraordinarily smart one…  probably the smartest one in existence
11:57:22 <hpc> the hotspot jvm probably has the only gc that could compare
11:57:53 <EvanR> how do you compare a haskell gc to a java gc at all
11:58:05 <hpc> heuristically ;)
11:58:08 <ertesx> EvanR: you implement the same algorithm and see which one is faster =)
11:58:21 <EvanR> but...
11:58:46 <EvanR> you dont use the same algorithms ... in haskell and java
11:58:51 <hpc> there's no good direct comparison, but java is the only language that gets remotely as much gc attention as haskell
11:59:19 <hpc> any other language out there is just going to use reference counting and go back to wondering why the GIL is making things so slow
11:59:23 <sm> what about the lisps ? guile ?
11:59:24 <liste> and Java has like 100000x the resources
11:59:25 <ertesx> in the tight-loop kind of algorithm GC mostly dominates (assuming that both produce reasonably fast code in general, and they do)
12:00:17 <ReinH> You compare them on axes like serial vs parallel, stop-the-world vs concurrent, compacting vs non-compacting vs copying
12:00:28 <ertesx> but in java you would typically use mutation, so you do explicitly in java what you do implicitly in haskell
12:00:55 <EvanR> in java you mutate everything and the gc has to deal with it
12:01:12 <EvanR> in haskell you dont mutate anything and the gc exploits it
12:01:41 <EvanR> its like is it even the same domain
12:01:46 <ertesx> EvanR: mutation gives the GC very useful clues, which GHC has to derive by itself, so the compiler has a little advantage…  i'd expect both to be on the same level of code efficiency
12:01:58 <ReinH> GHC has a stop-the-world, parallel, copying, generational GC. Hotspot includes a bunch of different GCs, actually.
12:02:16 <hpc> ^
12:02:24 <EvanR> its almost like comparing two cpus
12:02:31 <hpc> and you can turn them on and off depending on what needs your program has
12:03:08 <hpc> hotspot's options that are meant for servers are particularly nuts
12:03:16 <ertesx> an actual benchmark would probably be more useful =)
12:03:37 <EvanR> the benchmark game
12:03:44 <ertesx> intuitively i expect both to be on the same level with only minor differences depending on RTS/GC choices
12:04:03 <hpc> they assume the program will be left running for months so they can do things like profile the code on startup to decide where to optimize
12:04:07 <EvanR> why is that intuitive given the vast differences?
12:04:48 <ertesx> EvanR: because i have no close experience with java…  all i have are some basic information about the compiler and the JVM
12:05:03 <hpc> you should learn java
12:05:12 <ReinH> Hostpot GC is generational and includes serial, parallel, parallel compacting, and CMS collectors.
12:05:33 <ReinH> and a ridiculous number of tuning options
12:05:35 <hpc> it only takes a couple of days to learn every language feature if you're already a decent programmer
12:05:43 <hpc> CMS collector?
12:05:58 <hpc> that's a new one for me
12:06:04 <EvanR> theres an axiom you can use to arrive at the "intuitively the same level" result: if enough work has been done on some runtime, it will approach the performance of either jvms or ghcs
12:06:12 <hpc> oh, concurrent mark sweep
12:06:13 <ertesx> hpc: a couple of days wasted, if i don't use it…  and given a choice, i'll choose haskell =)
12:06:19 <EvanR> so that leads to the theorem that they are equal
12:06:27 <hpc> ertesx: it's still educational
12:06:30 <EvanR> but that seems silly
12:06:52 <ertesx> hpc: i know C++ and C#…  i don't think i'll learn anything other than syntax and awkwardly long identifiers
12:06:52 <hpc> through the right lens, OOP is a sort of categorical dual of H-Mish type systems
12:06:56 <ertesx> sorry
12:06:59 <ertesx> nobody knows C++
12:07:01 <hpc> oh fair enough then
12:07:14 <hpc> C# is similar enough as far as general structure goes
12:07:17 <EvanR> -- feynmann
12:08:08 <EvanR> hpc: whats this lens?
12:08:31 <hpc> it's ($-%~*!<<=)
12:09:55 <ertesx> hpc: through my lens, OOP's purpose is mostly job security
12:10:12 <ertesx> above a certain line count threshold the truck factor becomes sufficiently high that you can't be fired
12:10:51 <xa0> That's one hell of a lens
12:11:11 <hpc> "that's one hell of a lens, that lens-22"
12:11:12 <EvanR> so its a sweet spot between at least enough lines to be unfirable, and not so many lines you cant complete a project 
12:11:12 <ReinH> It's a lens that ignores the actual context and focuses on disliking people to use OOP.
12:11:15 <hpc> "the best there is"
12:11:18 <ReinH> So I'm not very fond of it.
12:11:24 <ReinH> s/to/who
12:11:26 <ertesx> combine that with the usual java design patterns, and you've got yourself some pretty decent enterprise factory job security facade
12:11:35 <ertesx> alright, enough bashing, back to work =)
12:11:45 <EvanR> i was seriously asking how OOP can be dual to HM
12:11:58 <hpc> yeah, back to seriousness
12:12:06 <ReinH> EvanR: to... Hindley-Milner?
12:12:18 <EvanR> yes
12:12:23 <hpc> er, when i said HM i think i meant parametric polymorphism
12:12:23 <ReinH> Is... is someone claiming that it is?
12:12:30 * hpc is a bit distracted
12:12:40 <ReinH> I guess that's for them to say...
12:13:00 <mmachenry> I've done a fairly extensive survey of developers a a couple of companies and the conclusion I've come to is simply that OOP has no agreed upon definition worth discussing in any rigorous context.
12:13:01 <shapr> hpc: are there more writings on OOP as a categorical dual to HM?
12:13:04 <EvanR> yes ReinH we were being vaguely philosophical 
12:13:07 <shapr> hpc: that sounds really cool and I want to know more
12:13:08 <hpc> it's the difference between parametric polymorphism and subtype polymorphism
12:13:12 <ertesx> ReinH: don't take me too seriously when i make fun of technology…  i do that a lot =)
12:13:24 <shapr> This is #haskell, we are entirely too serious.
12:13:24 <ReinH> Well, OOP and FP tend to have opposite solutions to the expression problem.
12:13:27 <EvanR> mmachenry: until now
12:13:28 <ReinH> So there's *something* there
12:13:31 <mmachenry> Those of you here who hate it and those who love it might totally agree on principles but just be unknowingly talking about completely different things.
12:13:34 <shapr> ReinH: expand?
12:13:34 <ReinH> but I'm not sure I'd put it that way
12:13:41 <EvanR> "the expression problem" Dx
12:13:46 <mmachenry> EvanR: Until now? How?
12:14:04 <EvanR> mmachenry: because in order to invetigate this question youll have to come up with a definition
12:14:10 <shapr> mmachenry: Have you seen Luca Cardelli's writings on OOP?
12:14:22 <hpc> well like, say you have some class Foo a
12:14:22 <mmachenry> shapr: Yep that was part of my reading.
12:14:28 <shapr> mmachenry: oh good, now I want to read your blog
12:14:31 <hpc> and a value foo :: Foo a => a
12:14:32 <shapr> gimme!
12:14:33 <EvanR> theory of objects is kind of ... not that interesting as an OOP
12:14:33 <ReinH> shapr: e.g., http://c2.com/cgi/wiki?ExpressionProblem
12:14:41 <hpc> er, foo :: Foo a => [a]
12:14:46 <ReinH> shapr: it's part of the basic formulation of the expression problem, really :)
12:14:49 <hpc> it could be a list of any sort of Foo instances
12:14:51 <shapr> ReinH: ah cool!
12:15:03 <ertesx> mmachenry: well, we have C++ OOP that nobody understands, java OOP that nobody takes seriously, python OOP that is really just HashMap String Dynamic, and smalltalk OOP that nobody remembers
12:15:07 <hpc> but only of one type, not a heterogenous list
12:15:29 <mmachenry> ertesx: And as some people define OOP Haskell modules fit perfectly. 
12:15:38 <shapr> I'm always happiest talking to people who know more than I do about the things that interest me.
12:15:38 <ertesx> hehe
12:15:39 <EvanR> ertesx: js oop
12:15:39 <hpc> a similar situation in an OO language with subtyping, you'd have interface Foo
12:15:46 <mmachenry> Though most of them don't consider Haskell OOP
12:15:48 <hpc> and then a List<Foo> could be heterogenous
12:15:53 <ReinH> shapr: OOP approach makes it easy to add new things, the FP approach makes it easy to add new behaviors. etc.
12:16:09 <mmachenry> ReinH: You belong to the academic's camp of OOP
12:16:13 <ertesx> EvanR: that would be java OOP 2.0, a.k.a. JobSecurity OOP
12:16:14 <hpc> either way, you still can't operate on elements of those lists in any way except what's given to you by Foo
12:16:14 <ReinH> shapr: btw the expressio problem is Wadler's
12:16:17 <ReinH> mmachenry: How so?
12:16:29 <ertesx> JS is the best way to secure your job…  you don't even need to obfuscate it
12:16:33 <hpc> but it's like an exists vs a forall
12:16:47 <mmachenry> ReinH: When I did my research on what folks believe, that was one large camp. It included Cardelli, Benjamin Pierce, The PLT, etc.
12:17:08 <hpc> i don't know of any other resources on this, this is purely from stuff i have picked up here
12:17:18 <ertesx> enough now, really…  don't engage me =)
12:17:23 <shapr> mmachenry: are you blogging about your investigation? if not, will you? :-)
12:17:29 <mmachenry> Basically if you're an academic and you're trying to come up with a rigorous statement of what OOP is, or define a calculus like several were, you have to land on OOP = subtype poplymorphism with inheritance for code reuse.
12:17:45 <EvanR> ReinH: youre referring to this "ADT vs PDA" thing?
12:17:58 <mmachenry> ReinH: Under that definition (which BTW is my favorite) one can actually be perscriptive as you just were about the expression problem, for example.
12:18:09 <mmachenry> ReinH: However that's not even the biggest camp.
12:18:42 <mmachenry> ReinH:  The biggest camp in my research was "Object combine data with the behaviors that are associated and give you encapsulation." 
12:18:48 <ertesx> i've seen OOP defined as 'fix'
12:19:01 <ertesx> yes, the one from Control.Monad.Fix
12:19:09 <mmachenry> You have to first realize that those are both orthogonal ideas and some constructs achieve on and not the other and some achieve both.
12:19:12 <ReinH> mmachenry: how is that camp different from the first one, which I'm still not quite sure I know the definition of?
12:19:21 <ReinH> Also, "PDA"?
12:19:27 <hpc> ertesx: that's pretty close to a perl-like model of OO where you pass "this" to every function
12:19:39 <hpc> and then bundle it up into a data structure
12:19:52 <EvanR> ReinH: there is a paper which uses the word procedural data abstraction instead of object, to compare them to ADT (abstract data type)
12:19:54 <ertesx> hpc: yeah…  it's used extensively in nixpkgs
12:20:06 <ertesx> it's actually pretty useful in that context
12:20:07 * shapr follows mmachenry on twitter
12:20:07 <EvanR> ReinH: ability to "add new things" is kind of vague though
12:20:08 <hpc> as implementations go, it's certainly not the worst
12:20:20 <EvanR> so is behaviors really
12:20:21 <mmachenry> ReinH: Haskell modules allow me to get encapsulation of a data type and it's private members and couple it in one package with the higher-level concepts of the behavior valid on the objects. 
12:20:32 <mmachenry> ReinH: But I can't do subtyping on Haskell modules.
12:20:44 <mmachenry> So Pierce and Cardelli wouldn't call it OOP
12:21:04 <EvanR> you also cant pass modules in as arguments
12:21:04 <mmachenry> Pierce actually mentions that OOP is ill defined in TaPL
12:21:18 <mmachenry> shapr: Oh you do? Cool. Thanks.
12:21:40 <ReinH> mmachenry: OOP is ill defined, as is FP.
12:21:48 <mmachenry> EvanR: Yep, there's another difference. There was another good paper part of my reading called "import is not inherit"
12:21:59 <mmachenry> ReinH: Yes, my entire point.
12:22:08 <EvanR> you also cant pass what to inherit from as an argument
12:22:34 <mmachenry> EvanR: And in some languages with classes you can't either 
12:22:43 <ertesx> one thing i like about FP is that it *knows* that it's vague…  the average OO programmer pretends that OOP is a complete and well-defined concept
12:22:46 <mmachenry> EvanR: Yet in ML you can even though it's a module not a class.
12:23:01 <hpc> FP and OOP are styles of programming
12:23:02 <mmachenry> EvanR: So higher order modules or classes (aka mixins) is yet another orthogonal topic.
12:23:12 <ertesx> hpc: they're supposed to be
12:23:23 <mmachenry> hpc: Not sure anyone can disagree there.
12:23:38 <hpc> they're about as well-defined as wing chun
12:23:43 <EvanR> is "import is not inherit" the title of a paper?
12:23:48 <EvanR> because... it basically is
12:24:16 <hpc> EvanR: haha
12:24:19 <mmachenry> The most entertaining thing I found in my research was that every software developer I interviewed or surveyed immediately reacted to my question "What is OOP" by feeling very on the stop and intimidated. Even the architects. 
12:24:40 <mmachenry> I think it just goes to show no one really has a solid definition but we discuss the topic like it has one.
12:25:07 <hpc> OOP is like porn, i'll know it when i see it
12:25:11 <mmachenry> I think that's damaging to conversations.
12:25:12 <EvanR> just to be clear, when i wanted to get more into this topic, i assumed that before doing anything wed be more specific about what the value of `OOP' would be
12:25:29 <EvanR> and not get into the fact that OOP has no definition prior
12:25:56 <mmachenry> EvanR: In this crowd I think it's a safe bet many folks think of OOP as subtype polymorphism with inheritance for code reuse. 
12:26:03 * hpc should probably mention that what he said above was specific to subtype polymorphism
12:26:21 <mmachenry> And assuming you agree on that definition you can have all sorts of fruitful discussions.
12:26:26 <EvanR> i doubt that that is safe, and for what its worth id have no idea thats what i was asking about
12:26:30 <EvanR> if i didnt say so
12:27:02 <mmachenry> EvanR: Perhaps. It's good to define the term when trying to have a real discussion about it no matter what your crowd. 
12:27:05 <EvanR> thank you mmachenry, now that the meta definition of OOP is out of the way
12:27:17 <hpc> now we can argue the meta meta definition!
12:28:47 <hpc> (i promise PLT is really interesting when you can get your definitions straight)
12:28:49 <ertesx> or we can talk about design patterns
12:28:59 <EvanR> no we cant
12:29:03 <ertesx> well, you can…  i still can't say "dependency injection" and maintain a straight face…
12:29:30 <ertesx> sorry, i should really leave #haskell for today =)
12:29:54 <EvanR> hpc: so. is the List<A> thing different from a list of records of the operations of A?
12:30:29 <hpc> EvanR: it can contain subtypes of A as well
12:30:50 <hpc> which may have more operations
12:31:05 <EvanR> eh but thats not well typed
12:31:17 <EvanR> if some things in the list have extra fields and some dont
12:31:25 <EvanR> if you know about it, that seems broken
12:31:39 <hpc> it's well-typed if you consider subtyping to be a safe operation
12:31:56 <hpc> which... i will not say my opinion of
12:32:09 <hpc> (mostly because it's not a well-formed opinion yet)
12:32:11 <EvanR> back up, i think in both List<A> and list of records (all the same structure) both dont let you have these extra fields
12:32:46 <hpc> EvanR: they don't let you /use/ those extra fields certainly
12:32:48 <EvanR> you see a uniform interface eitherway
12:33:05 <hpc> but (to use haskell syntax)
12:33:16 <hpc> example :: Show a => [a]
12:33:29 <hpc> example = [True, "bacon", Nothing]
12:33:51 <EvanR> > [True, "bacon", Nothing]
12:33:52 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
12:33:52 <lambdabot>      In the expression: "bacon"
12:33:52 <lambdabot>      In the expression: [True, "bacon", Nothing]    Couldn't match expected t...
12:33:56 <hpc> a type error in parametric polymorphism, perfectly fine if you consider all of those to subtype Show
12:34:12 <EvanR> ok, but thats equivalent to [String]
12:34:29 <hpc> only because i picked a boring "base type"
12:34:40 <hpc> in an OO language it's a valid list
12:34:48 <EvanR> for some other class, id be list of dictionaries all the same
12:34:50 <hpc> and the only valid operation on its elements is show
12:36:02 <nmdanny> does anyone know how to use parsec?
12:36:18 <hpc> nmdanny: it's a secret to everyone ;)
12:36:35 <EvanR> i guess im trying to get at the core concept always implicit which makes the List<A> subtype different from the dictionary passing
12:36:43 <hpc> nmdanny: describe the problem you're having and someone who can solve it will speak up
12:37:04 <hpc> EvanR: it's the implicitness that makes it different, yes
12:37:15 <nmdanny> I currently have the following function:         countChar :: GenParser Char Int ()         countChar =  updateState (+1)
12:37:29 <nmdanny> I want to make it:         countChar :: a => GenParser a Int ()         countChar =  updateState (+1)
12:37:56 <hpc> being able to quietly mush things together like that without complaint from the language
12:38:20 <EvanR> thats the practical difference
12:38:21 <hpc> but still getting other sorts of enforcement, being able to cast up the class heirarchy
12:38:51 <EvanR> (class hierarchy being different from a subtype lattice)
12:39:07 <nmdanny> basically, I have a combinator that doesn't need to deal with the parser input, so I want to change the signature from taking Char to taking a generic a
12:39:25 <hpc> like, what's the functional analog to being able to do Foo<A> x = (y :: Foo<B>) -- for some B extends A
12:39:32 <nmdanny> but when I do this, I get the error: The first argument of `GenParser' should have kind `*',    but `a' has kind `ghc-prim-0.4.0.0:GHC.Prim.Constraint'  In the type signature for `countChar':    countChar :: a => GenParser a Int ()
12:39:56 <EvanR> hpc: ... the injection of B to A
12:40:10 <EvanR> er... quotient?
12:40:27 <EvanR> in some cases theres an injection, and in other cases theres a quotient
12:41:10 <EvanR> these are both forms of subtyping which... dont seem at all alike
12:41:14 <hpc> EvanR: if we followed the model you suggested of having it be a dictionary of its operations
12:41:23 <hpc> there's an implicit shrinking of the dictionary in that line
12:41:30 <EvanR> a quotient
12:41:34 <hpc> removing the things in B not in A
12:42:11 <EvanR> A can be used where B is expected, requires spelling out how that is possible, i named two ways
12:42:18 <EvanR> but theres gotta be more than 2
12:42:44 <EvanR> platforms choose one somehow in any given situation
12:42:54 <EvanR> you usually arent asked to spell it out
12:43:26 <hpc> this is starting to give me a headache too lol
12:43:33 <hpc> at least TIL sort of what a quotient type is
12:43:42 * hpc is rusty on a lot of terminology
12:43:50 <EvanR> so it all boils down to implicit conversion!
12:44:57 <hpc> as much as anything does, really
12:45:07 <hpc> if it was explicit you'd just be doing the same thing explicitly in both systems
12:45:24 <hpc> or to put it a bit more meanly, it would be a design pattern
12:46:00 <EvanR> at least wed know it was a design pattern instead of having to have this discussion everytime about how what it even means
12:46:26 <hpc> i wonder if this is java's version of "but what is a monad, /really/?"
12:46:40 <EvanR> so from here i ask whats a more general language framework for programming implicit conversions
12:47:01 <hpc> that would be a good question
12:48:25 <EvanR> MPTC works for carrying out the conversions, you just have to put the word convert once each time you do it
12:51:18 <nmdanny> :t (>>) . (>>)
12:51:20 <lambdabot> Monad m => m a -> (m b1 -> b) -> m b1 -> b
12:51:26 <nmdanny> :t (*>) . (<*)
12:51:27 <lambdabot> Applicative f => f a -> (f b1 -> b) -> f b1 -> b
12:51:57 <EvanR> how horribly asymmetric
12:52:12 <dolio> EvanR: If B is a quotient of A, then there is an injection from B to A, at least according to ZFC, I'm sure.
12:52:48 <EvanR> yeah but thats the opposite direction
12:53:06 <nmdanny> :t >>
12:53:07 <nmdanny> :t *>
12:53:08 <lambdabot> parse error on input ‘>>’
12:53:09 <lambdabot> parse error on input ‘*>’
12:53:12 <nmdanny> :t (>>)
12:53:14 <lambdabot> Monad m => m a -> m b -> m b
12:53:14 <nmdanny> :t (*>)
12:53:15 <lambdabot> Applicative f => f a -> f b -> f b
12:53:31 <dolio> Oh, you mean B being a subtype of A in the quotient case?
12:53:57 <EvanR> Int is subtype of Real on one hand
12:54:06 <dolio> Er, A being a subtype of B.
12:54:12 <EvanR> {a:A, b:B} is a subtype of {a:A} on the other
12:54:53 <nmdanny> I have a stupid question, when making a function that I want to be generic over some type
12:55:05 <nmdanny> lets say, a function which takes something and returns something
12:55:16 <nmdanny> do I have to write it like this :   myFunc :: a -> a
12:55:23 <nmdanny> or do I write it like : myFunc :: a => a -> a
12:56:23 <Cale> nmdanny: The stuff which goes before the => in a type consists of a sequence of constraints on the type variables. If there are no constraints, then you don't have the => at all.
12:56:34 <nmdanny> Oh I see
12:56:56 <mirpa> nmdanny: a -> a is valid, part before => is type constraint, when you want to limit how general is your function
12:57:25 <Cale> e.g. Eq a would mean that a must be some type for which equality testing, that is (==) and (/=) has been defined
12:57:58 <Cale> and Ord a would mean that the ordering operations, (<), (<=), (>), (>=), compare have been defined
12:58:04 <Iceland_jack> How to define 'data Fetch a = Done a | Blocked (Fetch a)' (from "There is no Fork") in terms of free applicative (Control.Applicative.Free)
12:58:35 <nmdanny> Yea I know what typeclasses are, I just forgot that you don't always have to put constraints
13:00:06 <maerwald> oh man, steam crashes so often I want to rewrite it in haskell
13:00:16 <haskell366> Hi, I'm trying to do a simple fromJSON instance from my type. The problem is that I think there is a bug on the code which call the decode function (external librairie). I'm receiving String "{\"x\":1,\"y\":0}". I would like to call my Object constructor from the String constructor, something like that http://lpaste.net/158787
13:00:24 <daakr> i am trying to debug segfault that I get in a shared object (a library for C code) that I build from haskell code with cabal. can I somehow get debugging symbols?
13:02:01 * hackagebot purescript 0.8.4.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.8.4.0 (PhilFreeman)
13:02:40 <ReinH> nmdanny: I'm a bit confused. How can a function be generic over *some* (i.e., a concrete) type?
13:03:16 <Cale> ReinH: nmdanny just forgot how to express that there weren't constraints
13:03:24 <ReinH> Ok.
13:03:28 <nmdanny> yep exactly
13:03:54 <ReinH> also myFunc as written can do anything you want it to as long as it is either id or undefined.
13:04:04 <ReinH> s/undefined/bottom
13:05:25 <nmdanny> yea I know, i'm not interested in a function that does nothing, I'm just trying to understand parsec and I noticed that the type inference gave me a generic type with no constraint, so that confused me for a while
13:05:36 <Cale> haskell366: I suppose the thing to do is to just  case decode str of ...
13:05:45 <Shou> Is there a library already for useful type-level operators, e.g. ($)?
13:05:47 <Cale> haskell366: and figure out what to do from there...
13:05:55 <Shou> I don't want to pollute the waters with mine if there already is one available.
13:06:29 <EvanR> look at type-compose
13:06:31 <dolio> EvanR: Obviously the real criterion is that A is a subtype of B iff there is a function from A to B. :)
13:06:50 <EvanR> dolio: >_<
13:07:18 <monochrom> I am happy with that, provided the function is total.
13:07:20 <Cale> daakr: Sounds painful... https://ghc.haskell.org/trac/ghc/wiki/Debugging/CompiledCode has some tips about this kind of thing
13:08:12 <Cale> A is a subtype of B if there is a monomorphism A -> B
13:08:42 <ReinH> nmdanny: (it doesn't do nothing, it does something very important) ;)
13:09:16 <daakr> Cale: thanks, that looks useful. yeah, i suspect I'm going to have to report a GHC bug, but I want to attempt to track this down myself first (as i'm not completely convinced it's not caused by my code)
13:09:22 <monochrom> yesterday or two days ago I said how a "UniqueId" abstract type cannot be a Num instance, on this ground: you write down the contract of UniqueId, which only tells you Ord, Hashable, and a way to generate more values (and a uniqueness guarantee). these laws do not imply Num laws.
13:09:50 <daakr> Cale: (also, any tips/dos/don'ts for reporting a GHC bug about this?)
13:10:10 <haskell366> Cale, an external librairie is calling the decode function so I can't really change it. Do you mean calling decode from the String case? How would it work, fromJSON return Parser a, and decode returns Maybe a
13:10:15 <Cale> daakr: Well, is the segfault happening in Haskell code?
13:10:20 <ReinH> monochrom: it also philosophically shouldn't be a Num instance.
13:10:27 <daakr> Cale: uhhh, how do i tell?
13:10:38 <monochrom> well I am skeptic about philosophy and spirits.
13:10:46 <ReinH> Well, philosophically isn't the best word
13:11:07 <ReinH> Adding unique ids together is something you have no reason to and shouldn't be able to do
13:11:32 <mauke> but multiplying them is fíne!
13:11:36 <ReinH> They aren't numbers.
13:11:42 <monochrom> but then you will also want to store UniqueId's in files and read them back. So the contract should also include an isomophism between UniqueId and bytes.
13:11:44 <ReinH> They needn't even contain numbers.
13:11:46 <Cale> daakr: Well, okay, good question, but if you do some debug printing/tracing you might be able to work out what part of the code was running at the time :)
13:12:00 <ReinH> monochrom: Sure. I'm not sure how that argument interacts with mine at all.
13:12:13 <monochrom> but once you get bytes you also get numbers. in fact you also get propositions, types, and programs.
13:12:21 <benzrf> is Mu anywhere in base
13:12:42 <ReinH> Yes. Do we add functions together by their godel numbers and expect to get useful results?
13:12:45 <Cale> daakr: if it's happening during an FFI call, the chances are pretty good it's a bug in the external library (or a bug in the way you're using that library, perhaps)
13:12:46 <daakr> Cale: mind if i waste your time showing you some traces?
13:13:07 <monochrom> Gödel certainly did :)
13:13:08 <Cale> daakr: I don't mind -- can I see the code which is running?
13:13:21 <ReinH> monochrom: er.
13:13:38 <monochrom> he also did gcd and prime factorization on numbers that stand for functions
13:13:42 <daakr> Cale: trace http://pastebin.com/Racbx0DR
13:13:45 <monochrom> it's how he got the functions back
13:13:55 <daakr> Cale: my library project https://github.com/abooij/sudbury
13:13:55 <ReinH> monochrom: but_why.gif
13:14:02 <godel> wjat
13:14:19 <ReinH> monochrom: to what purpose?
13:14:30 <daakr> Cale: C code of executable https://cgit.freedesktop.org/wayland/weston/tree/clients/dnd.c
13:14:49 <daakr> Cale: (i don't think you can get through all of this source code in this IRC chat, so please don't bother)
13:14:57 <monochrom> anyway, I say this because I'm exploring the logical conclusions of "A is a subtype of B iff there is a total computable function from A to B". I have a computable isomorphism between UniqueId and bytes. and also between bytes and numbers. etc etc.
13:15:38 <monochrom> (unless you refuse to serialize UniqueId)
13:15:50 <Cale> haskell366: Yeah, I mean decoding the String, that's what you want to do, no? You still determine a Parser as the result of decode -- it's just that parser might be return v or typeMismatch depending on the result you get.
13:16:42 <monochrom> serializable unique id's are a subtype of propositions and types. and vice versa.
13:16:44 <daakr> Cale: i think i have another instance here: trace http://pastebin.com/scdKu68z executable https://cgit.freedesktop.org/wayland/weston/tree/clients/subsurfaces.c
13:16:51 <ReinH> monochrom: Yes, but expecting any useful arithmetic relationship between unique ids sounds more like numerology than math.
13:16:57 <monochrom> this is known as the Curry-Howard-But-Why isomorphism
13:17:01 * hackagebot js-jquery 1.12.3 - Obtain minified jQuery code  https://hackage.haskell.org/package/js-jquery-1.12.3 (NeilMitchell)
13:17:08 <ReinH> Unless your system is specifically built on such an relationship, as Godel's was.
13:18:34 <Cale> daakr: ah okay, if we're going to get stuff like that, add -ddump-simpl and -ddump-to-file
13:19:04 <Cale> So that we can see the Core version of the code, and figure out what the heck swd7 is.
13:19:45 <haskell366> Cale: I guess that's the way I'll use, thanks :)
13:20:49 <monochrom> ReinH: to your comfort, there is a fine print (or lack thereof) that implies: even though there is an isomorphism between serializable unique id's and integers, the isomorphism is of no use for arithmetic. I leave you to find out why. but it is still a logical argument, not a "I don't like it" or "why would anyone do it" argument.
13:21:18 <monochrom> because I'm afk
13:22:11 <Cale> daakr: at least... I'm assuming that swd7_info is an automatically generated name from GHC and not something defined in the C code -- it looks like the identifiers GHC generates.
13:23:05 <ReinH> monochrom: All I'm trying to say is there's no reason to give unique ids a Num instance.
13:23:41 <daakr> Cale: the name changes per build, and it doesn't seem to be in these dumps
13:23:42 <Cale> daakr: I'm not sure how useful gdb is going to be in finding such things. Usually the way I would start is just trying to figure out what part of the Haskell program was running at the time of the failure and what FFI call was being made there.
13:23:48 <Cale> daakr: hm
13:24:03 <daakr> (so the theory that it is a generated name is reasonable)
13:24:08 <daakr> (so perhaps i'm doing something wrong)
13:24:39 <monochrom> actually, s/isomorphism/bijection/. that should help.
13:25:51 <Cale> daakr: What are you running to cause the segfault?
13:26:22 <Cale> daakr: Presumably you have a Haskell program which uses this Sudbury library?
13:26:34 <daakr> Cale: no, it's this C executable https://github.com/krh/weston/blob/master/clients/dnd.c
13:26:40 <Cale> oh
13:26:45 <Cale> and that's calling Haskell code?
13:26:50 <daakr> yes, and vice versa
13:27:01 * hackagebot ghcid 0.6 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.6 (NeilMitchell)
13:27:03 * hackagebot ghcid 0.6.1 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.6.1 (NeilMitchell)
13:27:06 <daakr> all interaction with the program goes via my haskell code
13:27:15 <daakr> when I interact with it in a certain way, i get this segfault
13:27:18 <EvanR> Cale: the quotient operation isnt injective
13:27:25 <Cale> Did you remember to initialise the GHC runtime?
13:27:29 <EvanR> so i dont think monomorphism works
13:27:39 <daakr> Cale: yeah, the librayr works fine otherwise :)
13:27:58 <daakr> so i am able to run other executable that use similar mechanisms of my library
13:28:07 <daakr> +s
13:29:13 <daakr> Cale: i have the feeling this might be a bug similar to https://ghc.haskell.org/trac/ghc/ticket/7317
13:30:19 <daakr> so i'd like to have a specific reason to believe that
13:32:44 <texasmynsted> anybody know of sites that use this http://lambdacms.org/ ?
13:33:08 <Cale> daakr: Have you tried adding printfs to the C program so you know exactly where it was before the crash?
13:33:59 <daakr> Cale: no. but the C program should work fine, as it works fine with an alternative (C) implementation of the same library
13:34:17 <Cale> daakr: Well, you want to know which Haskell code was running at the time...
13:34:19 <daakr> (if that's what you were getting at)
13:34:39 <Cale> daakr: So that we can look at it and see what it might've been doing
13:34:53 <agocorona> Hi, how to install the profiling libraries? I have "Could not find module *  Perhaps you haven't installed the profiling libraries.."
13:36:15 <naudiz> I'd like ghci to show me how long a function needed. How do I do that?
13:36:19 <texasmynsted> I mean aside from the site its self
13:36:20 <Cale> agocorona: --enable-library-profiling if you're installing the library with cabal
13:36:22 <agocorona> I did it time ago, but I just don´t remember
13:36:23 <kadoban> agocorona: Are you using stack or cabal-install?
13:36:30 <texasmynsted> or should I look at a different haskell cms?
13:36:30 <Cale> agocorona: Or turn it on in your ~/.cabal/config
13:36:46 <Cale> (I would recommend always turning that on before you install much of anything)
13:36:47 <agocorona> I have to recompile all the libraries?
13:37:01 * hackagebot freer 0.2.2.5 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.2.5 (alcabrera)
13:37:29 <Cale> agocorona: possibly, yes
13:37:35 * johnw keeps waiting for the Freest Monad of Them All
13:37:39 <daakr> Cale: hm, that will be some work, but i can do that, yes
13:37:46 <Cale> It's really silly that library profiling isn't on by default
13:37:56 <agocorona> kadoban: stack has a way to tell ghc to recompile everithing?
13:38:00 <daakr> Cale: if i build that executable with debugging, should that make the gdb trace more useful?
13:38:02 <johnw> Cale: well, it doubles build times; but for the base/core libraries, it really should be
13:38:20 <shapr> or it could ask when you first install
13:38:28 <Cale> daakr: Maybe add some printing to the start of the things you're foreign exporting from Haskell
13:38:32 <ClaudiusMaximus> naudiz: :set +s
13:38:58 <Cale> (if that's less work)
13:38:59 <daakr> Cale: ah, so that i can see the last one that was called?
13:39:02 <Cale> yeah
13:39:02 <kadoban> agocorona: It has a switch for profiling support, yes. And it always builds deps when they're needed.
13:39:03 <naudiz> ClaudiusMaximus: thank you very much!
13:39:13 <daakr> Cale: that might be the easiest solution
13:39:18 <agocorona> kadoban: thanks
13:39:31 <daakr> Cale: but i'm slightly confused what i can do with that information
13:39:45 <daakr> do you think it's an option that the haskell code is fixable?
13:39:57 <daakr> i mean, errors in haskell usually give something else, right?
13:40:10 <daakr> though i suppose you are right in that this is interesting to know since it narrows down the problem
13:40:18 <Cale> daakr: Well, then you add some more printing inside that thing, and see if you can work out how much of it runs exactly before the segfault (or if all of it runs, and the segfault happens after)
13:40:28 <daakr> got it
13:40:50 <Cale> If you're doing a bunch of pointer manipulation on the Haskell side of things, it's entirely possible that it's just a bug in your library
13:41:11 <EvanR> dolio: indeed that explains why everything is a subtype of Top, if its a terminal object... its easy to implement the conversion
13:41:27 <daakr> Cale: i am. so i will look into this :)
13:42:14 <agocorona> stated the stack robot with the profiling switch. It seems to be looking at the origin of the universe to figure out what to do
13:43:02 <dolio> EvanR: Yes, and also why Bottom is a subtype of everything.
13:44:20 <jakeehrlich> So I'm a bit unfamiliar with the dev cycles of GHC. When can I expect this ticket to be closed? https://ghc.haskell.org/trac/ghc/ticket/8761
13:46:48 <geekosaur> jakeehrlich, we're in the release cycle for 8.0.1 and this won't have made it.
13:47:22 <geekosaur> so I'd imagine that it will see activity after 8.0.1 ships (they're finalizing 8.0.1rc3 currently)
13:53:50 <texasmynsted> ok, what is a widely used haskell cms?
13:54:08 <daakr> texasmynsted: hakyll
13:54:15 <daakr> * ducks *
13:54:30 <texasmynsted> that is a static site generator 
13:54:44 <texasmynsted> are you ducking because that is not a CMS?
13:54:50 <Cale> texasmynsted: I'm not sure there is one which actually counts as widely-used?
13:54:56 <Cale> yeah, that would be why
13:55:20 <daakr> well, it does manage content
13:55:24 <daakr> and it is a system
13:57:01 <daakr> Cale: huh. well I suppose it *is* a problem with my code!
13:57:06 <daakr> not sure what it is yet
13:57:19 <Cale> daakr: did you find where it was happening?
13:57:44 <daakr> yeah. somewhere in the middle of a pointer circus
13:57:46 <Cale> texasmynsted: There's clckwrks as well, whose own website hasn't been updated in a while, but it appears Jeremy Shaw is still working on it and pushing updates to hackage and github
13:58:11 <daakr> it's amazing though. that piece of code is called a lot, and it goes through just fine almost always
13:58:44 <Cale> (actually... the changes are getting a little old, I'm not sure)
13:58:54 <Hafydd> Why is there no leftpad package on Hackage?
13:59:25 <quchen> There is! It also comes with some helper functions
13:59:27 <quchen> ?hackage text
13:59:27 <lambdabot> http://hackage.haskell.org/package/text
13:59:32 <Taneb> Hafydd, http://hackage.haskell.org/package/acme-left-pad
13:59:45 <Hafydd> Oh.
14:00:19 * texasmynsted googles clckwrks
14:01:31 <jakeehrlich> geekosaur: thanks! How long do dev cycles typically last?
14:01:57 <geekosaur> they vary a lot currently
14:02:04 <broma0> http://lpaste.net/158789: I asked over on #ghcjs to no avail, but i can't figure out why Aeson is causing "thread blocked indefinitely in an STM transaction". Looks like h$__hs_uregex_open is never defined by the RTS
14:02:18 <broma0> any ghcjs hackers here?
14:02:31 <geekosaur> devs have been discussing firming things up a bit, but iirc they said that after the ghc 7.8 release that was 6 months overdue too...
14:04:50 <texasmynsted> at least http://www.clckwrks.com/page/view-page-slug/1/clckwrks-com has a demo video 
14:15:57 <daakr> Cale: aaaaaaaaah :)
14:16:03 <daakr> thanks
14:16:09 <Cale> daakr: haha, no problem :)
14:17:15 <daakr> Cale: okay apparently there are two bugs. but at least i fixed one :P
14:30:21 <daakr> Cale: aaaand tracked the second one down as well. thanks.
14:34:48 <Intolerable> is it possible to derive Read instances for GADTs? i.e. http://lpaste.net/158793
14:35:00 <Intolerable> (the deriving instance doesn't actually work)
14:37:24 <EvanR> dolio: wait were you joking? theres a function that converts bottom to any type?
14:38:47 <hiptobecubic> There must be, right? Isn't that how spoon works?
14:39:15 <EvanR> spoon :: NFData a => a -> Maybe a
14:39:33 <EvanR> man its been years since someone mentioned this
14:40:08 <EvanR> this actually might come in handy...
14:40:56 <EvanR> otoh... wait what
14:41:15 <dolio> By Bottom, I meant the empty type, just like you called the one element type Top.
14:41:30 <daakr> EvanR: there are instances of _|_ that do not throw an exception
14:41:32 <EvanR> ok sure
14:41:49 <dolio> But also, bottom the expression inhabits every type.
14:41:59 <dolio> In something like Haskell.
14:42:23 <EvanR> data Void
14:42:31 <EvanR> toInteger :: Void -> Integer
14:42:33 <daakr> let x = undefined :: Int in "Hi" ++ x
14:42:37 <daakr> > let x = undefined :: Int in "Hi" ++ x
14:42:38 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Int’
14:42:39 <lambdabot>      In the second argument of ‘(++)’, namely ‘x’
14:42:39 <lambdabot>      In the expression: "Hi" ++ x
14:42:46 <dolio> In the intersection semantics I was talking about the other day, the intersection of all types is the undefined expression, for Haskell.
14:42:52 <daakr> dolio: no it doesn't
14:43:08 <daakr> oh, the expression. okay, if you emphasize that, i can agree in theory
14:43:21 <EvanR> i was thinking about the type with no values
14:43:27 <johnw> dolio: does that make Haskell types a join semi-lattice?
14:44:18 <dolio> Do you mean each type is a semi-lattice, or there is a semi-lattice of types?
14:44:32 <johnw> ah, good point
14:44:37 <johnw> n/m
14:44:43 <dolio> The answer to both might be 'yes'.
14:45:06 <EvanR> so you were saying, in Void -> X, if X is not Void then you can choose a constant to map to. if X is Void then id works
14:46:22 <EvanR> that seems weird for some reason
14:46:25 <dolio> In a total language, Void -> X is the empty function. The obvious extension of that to partial function is the mapping that yields undefined for every type.
14:46:48 <EvanR> oh 
14:47:05 <dolio> The empty function on Void -> Void is the identity function.
14:47:33 <EvanR> well im not sure if you ended up totally misrepresenting haskells type system, trivialized subtyping, or both ;)
14:47:41 <EvanR> s/you/we/whoever/
14:47:43 <dolio> As is the constant undefined partial function.
14:48:43 <dolio> Well, some subtyping systems let you just pick which functions get to be used for subtyping.
14:48:52 <EvanR> for conversion?
14:48:57 <dolio> Yes.
14:49:02 <EvanR> orly... which ones
14:49:17 <iphy> How to make QuickCheck not blow up when generating abstract syntax trees or other complex recursive data structures?
14:49:20 <dolio> So then, 'subtype' is, 'there is a function I designated between these two types.'
14:49:41 <dolio> Search for papers on 'coercive subtyping' I believe.
14:49:56 <iphy> After a few initial small ones, it generates one that exceeds 8gb of ram
14:50:15 <dolio> The rules for variance of subtyping are just the rules for functorial mapping.
14:51:07 <dolio> And picking all functions for the subtyping gets you ordinary functors.
14:51:31 <EvanR> head explode
14:51:32 <dolio> Of course, if you pick all functions, you're not going to be doing it automatically.
14:51:52 <dolio> Which someone might say is the point of subtyping. Except lots of subtyping systems are undecidable anyway.
14:52:03 <dolio> So you still have to be explicit sometimes.
14:52:23 <EvanR> explicit implementation of coercion? or coercion of functions
14:52:52 <EvanR> can functions be casted automatically..
14:54:06 <dolio> In Scala, for instance, you end up having to put type annotations on things to get things to type correctly.
14:54:07 <mniip> (. coerce) = coerce
14:54:10 <mniip> (coerce .) = coerce
14:54:14 <mniip> coerce coerce = coerce
14:54:26 <dolio> In general.
14:54:53 <EvanR> fix coerce
14:54:58 <EvanR> = coerce
14:55:55 <dolio> You can use some other pre-existing system to choose your subtyping functions, too.
14:56:08 <dolio> Like rank-n types.
14:56:28 <dolio> (forall a. a) <= T <= (exists a. a) for all T.
14:57:28 <dolio> Either you look at this by saying things like, "I can apply things of the first type to T to get a T."
14:57:53 <dolio> Or you say things like, "forall a. a is the intersection of things in all types, so the things in it are also in T."
14:59:10 <AleXoundOS> Hi. Reading this page: https://wiki.haskell.org/Applications_and_libraries/Interfacing_other_languages I cannot decide which C interface to use. I'm not very experienced in Haskell. Is there any comparison in depth or maybe some trends which C interface is more popular or modern?
14:59:20 <AleXoundOS> For example, I want to use https://github.com/mpv-player/mpv/blob/master/libmpv/client.h from Haskell.
15:00:14 <EvanR> for C use the FFI
15:01:14 <AleXoundOS> Can I know the explanation why FFI is better than the others in my case?
15:02:49 <dolio> If you do the latter thing, you can describe the functions nicely, too. The functions are all '\x -> x'.
15:02:54 <mjrosenb> AleXoundOS: if you want mpv bindings, I have them, I just need to upload it to github.
15:05:01 <EvanR> no
15:05:19 <EvanR> there is no set of all values
15:06:24 <EvanR> theres a set of all lambda expressions though
15:06:47 <EvanR> dunno if thats even remotely a good model for haskell
15:28:33 <AleXoundOS> mjrosenb, great, what's your github account name?
15:31:36 <mjrosenb> AleXoundOS: mjrosenb
15:31:58 <mjrosenb> I also need to re-learn how to push an existing project to github
15:32:03 <mjrosenb> shouldn't take long though.
15:36:58 <mjrosenb> AleXoundOS: https://github.com/mjrosenb/mpv-hs
15:39:50 <mjrosenb> AleXoundOS: fair warning: I have no clue if any of the requirements are bogus, I've never tried building it with anything other than the newest versions (as of ~8 months ago)
15:41:59 <tippenein> what's the syntax for multiple assignment? let (a,b) = 1,2
15:42:17 <mjrosenb> (1,2)
15:42:32 <mjrosenb> although it is probably better called destructuring assignment.
15:43:06 <mjrosenb> if you really want to use the word assignment.
15:44:29 <AleXoundOS> mjrosenb, ok, thank yuo
15:44:32 <AleXoundOS> you*
15:47:06 * hackagebot giphy-api 0.4.0.0 - Giphy HTTP API wrapper and CLI search tool.  https://hackage.haskell.org/package/giphy-api-0.4.0.0 (passy)
15:49:18 <geekosaur> or: let {a = 1; b = 2}
15:49:20 <geekosaur> (if using layout you can put them on separate lines, indent b to the same level as a)
15:51:11 <mjrosenb> > let (a,b) = (1:b, 0:a) in zip a b
15:51:13 <lambdabot>  [(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,...
15:52:37 <xa0> Cheeky
15:56:24 <Asuran> can anyone recommend a c to haskell tutorial or like this? i cant read those who writing 999 words for 1 sentence
15:56:45 <kadoban> Asuran: What do you mean by a C to haskell tutorial?
15:57:06 * hackagebot type-operators 0.1.0.0 - Various type-level operators  https://hackage.haskell.org/package/type-operators-0.1.0.0 (Shou)
15:57:07 <Asuran> a tutorial which doesnt sound like learnyouahaskell, the book is good 
15:57:21 <cheater> kadoban: he means c2hs.
15:57:29 <Asuran> something like on learninminutes.com but more complete
15:57:41 <cheater> and he'd like a concise tutorial with working code.
15:57:56 <Asuran> just an syntax explanation: this are tuples, you use them like this, and so on
15:58:26 <kadoban> cheater: By the way … this is the problem with attempting to translate from ambiguity using your own guesses … sounds like that's not at all what they want?
15:58:59 <cheater> it's fairly unambiguous to me
15:59:11 <kadoban> *shrug* I'll leave it to you then.
15:59:59 <Asuran> okay found one: https://wiki.haskell.org/Haskell_Tutorial_for_C_Programmers
16:00:01 <Asuran> lol.
16:00:05 <Asuran> yay!
16:00:11 <Asuran> this is what i can read
16:00:33 <Asuran> really i cant get anything into my brain if it starts with long writing instead being direcT: teaching you haskell
16:04:58 <Asuran> well never mind what ive said before, now im happy :D
16:06:16 <Asuran> ah never mind
16:23:03 <orion> What's the canonical way of enabling llvm for one project without editing the .cabal file?
16:24:24 <Sonolin> is there any easy way to convert type "String" into "Word(64)"?
16:24:41 <Sonolin> trying to write some test wrappers around X11 code...
16:25:11 <agocorona> is it possible to get the profiling libraries for base and network? cabal  & stack refuses to compile it with profiling
16:29:42 <agocorona> no, it's okay. it is an ambiguous message in cabal
16:31:11 <pavonia> Sonolin: It's certainly possible but depends on what encoding method you want to use
16:31:39 <timbod7> Sonolin: What type do you mean when you say Word(64)?
16:35:46 <erikd> Sonolin: does the String contain a number and nothing else? if so: read str :: Word or read str :: Word64
16:35:50 <Sonolin> GHC.Word.Word64
16:36:04 <Sonolin> so need to write a function of "String -> GHC.Word.Word64" I'm assuming
16:36:19 <texasmynsted> if I have a function that takes two arguments a boolean and a [Char], and if false I never use the second parameter, will the second ever be made real on false?
16:36:27 <texasmynsted> Want to better understand lazyness
16:36:27 <erikd> readWord64 :: String -> Word64
16:36:33 <erikd> readWord64 = read
16:38:25 <erikd> > let fun b x = if b then putStrLn "ok" else x in fun True undefined
16:38:27 <lambdabot>  <IO ()>
16:38:43 <erikd> > let fun b x = if b then "ok" else x in fun True undefined
16:38:45 <lambdabot>  "ok"
16:38:51 <erikd> texasmynsted: ^^^^
16:38:53 <EvanR> texasmynsted: made real?
16:39:35 <texasmynsted> so x is not made real right?
16:40:10 <Sonolin> ok for learning purposes, so far I got
16:40:12 <Sonolin> map toEnum (map fromEnum "asdf") :: [Word64]
16:40:23 <Sonolin> but now can't figure out how I'm supposed to concatenate that list into Word64
16:40:44 <Sonolin> I'd assume Word64 can represent multiple characters, since I'm referring to an X11 atom property, but maybe I'm on wrong track here..
16:40:45 <jle`> how are you going to combine items?
16:41:01 <Sonolin> I'm not sure lol
16:41:05 <jle`> how do you want to combine two Word64's ?
16:41:07 <jle`> bitwise OR's?
16:41:11 <jle`> bitwise AND's? etc.
16:41:50 <erikd> Sonolin: Word64 is uint64_t in C land
16:41:51 <Sonolin> well I'm trying to get a Word64 representation of "_NET_ACTIVE_WINDOW" (X11 atom property)
16:42:08 <erikd> that doesn't make sense
16:42:57 <erikd> Sonolin: maybe it expects a pointer to the string "_NET_ACTIVE_WINDOW"
16:43:07 <Sonolin> ah maybe
16:43:16 <Sonolin> I'm looking at this function: https://hackage.haskell.org/package/X11-1.6.1.2/docs/Graphics-X11-Xlib-Extras.html#v:rawGetWindowProperty
16:44:38 <Sonolin> I'm assuming it wants an "XID" version of that string, whatever that is (or possibly a pointer)
16:45:00 <erikd> Sonolin: i've never use the X11 libs, but i would suggest that you look at the sources for xmonad (if you haven't already) and see how it uses that function
16:45:16 <Sonolin> yea I'm digging around :)
16:45:29 <Sonolin> thanks for the help though, this is definitely helping me understand types better
16:46:54 <Sonolin> woot found it
16:46:55 <Sonolin> https://hackage.haskell.org/package/X11-1.6.1.2/docs/Graphics-X11-Xlib-Atom.html#v:internAtom
16:48:39 <geekosaur> that's what you want, yes
16:48:56 <geekosaur> if this is for xmonad then there's a wrapper "getAtom"
16:49:23 <Sonolin> yea I found that a bit late in this venture just trying to complete the function for learnings sake atm
16:49:57 <geekosaur> (also you'll find _NET_ACTIVE_WINDOW stuff in xmonad-contrib XMonad/Hooks/EwmhDesktops.hs)
16:50:39 <Sonolin> ah cool
16:53:40 <aarvar> texasmynsted: by "made real" do you mean evaluated?
16:57:53 <texasmynsted> yes
16:58:33 <aarvar> texasmynsted: then no, it won't be
16:59:08 <texasmynsted> Cool!
16:59:13 <aarvar> though in that specific case it sounds like you'd want Maybe a instead of (a, Bool)
17:30:45 <orion> In Aeson, is { "foo": null } the same thing as "foo" not being declared at all?
17:33:17 <pavonia> They are different values
17:55:16 <wedify> if i have a vector of vectors v and i go v // [(x , v ! a), (z, v ! b)]
17:55:25 <wedify> does it work the way i expect?
17:55:59 <wedify> trying to do the dailyprogrammer challenge my intent is to rearrange rows
17:56:43 <scshunt> wedify: yes. Remember that in haskell, things aren't mutable
17:57:08 <scshunt> (unless they explicitly are)
17:59:13 <wedify> ok cool. thanks
18:32:23 * hackagebot stitch 0.3.3.0 - lightweight CSS DSL  https://hackage.haskell.org/package/stitch-0.3.3.0 (Intolerable)
18:41:53 <wedify> my solution is up:) 0.5s for the 24x24 grid
18:55:45 <bhiliyam> Is monomorphism restriction dead? I could not reproduce the examples at https://wiki.haskell.org/Monomorphism_restriction.
18:56:04 <bhiliyam> I am using GHC version 7.10.2
18:56:11 <dmj> it's off by default I think
18:57:20 <bhiliyam> Ohh, in that case there is a lot of dated information out there that probably should be fixed.
18:58:08 <bhiliyam> Oops, the wiki page already says it is turned off by default starting GHC 7.8.1
18:58:20 <bhiliyam> Silly me
19:00:16 <geekosaur> off by default in ghci
19:00:30 <geekosaur> ":showi language"
19:01:04 <nineonine> how to check if something is numeric ?
19:01:17 <nineonine> isNum :: (Num a) => a -> Bool
19:02:24 * hackagebot sqlite 0.5.3 - Haskell binding to sqlite3  https://hackage.haskell.org/package/sqlite-0.5.3 (AdamWick)
19:03:45 <pavonia> nineonine: When would that function return true?
19:04:23 <nineonine> examples for true : 4, 125, 0, "124" "1"
19:04:33 <geekosaur> nineonine, that signature makes no sense
19:04:42 <geekosaur> if it has a Num instance then it is numeric
19:05:01 <nineonine> oh
19:05:18 <geekosaur> otherwise it sounds like you are looking for typecase, and need to sit down and think like a Haskell programmer
19:05:28 <nineonine> how about that
19:05:39 <nineonine> (Show a) => a -> Bool
19:06:22 <wedify> are you just looking at integers? you could use 'all isDigit s'
19:07:16 <nineonine> does it make sense now ?
19:07:16 <nineonine> yeah that should do the trick i guess
19:07:16 <nineonine> thanks
19:07:27 <pavonia> or just write a parser that includes all the possible cases
19:17:01 <broma0> what's the standard cryptography library? I need a simple password hashing function, ideally Text -> Text
19:18:02 <dmj> @package bcrypt
19:18:09 <lambdabot> http://hackage.haskell.org/package/bcrypt
19:18:09 <dmj> @package scrypt
19:18:24 <dmj> lambdabot a little slow on the draw
19:18:32 <lambdabot> http://hackage.haskell.org/package/scrypt
19:19:13 <broma0> dmj ill check those out, thanks. Ive used cryptohash in the past but ghcjs cant compile it for some odd reason
19:20:56 <dmj> broma0: on the haddocks for cryptohash, "DEPRECATED: this library is still fully functional, but please use cryptonite for new projects and convert old one to use cryptonite. This is where things are at nowadays."
19:21:06 <dmj> @package cryptonite
19:21:06 <lambdabot> http://hackage.haskell.org/package/cryptonite
19:49:45 <JoshS> After watching a video on monoids, much to my surprise I found a use for a little monoidness in lua.
19:50:00 <JoshS> [blink]
19:50:56 <thoughtpolice> broma0: All of those packages depend on underlying C code, I believe. You'd presumably have to reimplement the C bits using some other library in JavaScript (like sjcl) or port them to Haskell.
19:51:45 <thoughtpolice> Or use emscripten, I guess. The code for something like scrypt is one or two C files, so that's probably manageable.
20:07:30 * hackagebot octane 0.4.16 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.16 (fozworth)
20:27:40 * hackagebot warp 3.2.5 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.5 (KazuYamamoto)
20:29:30 <shanemikel> okay, I'm pretty happy with myself for this http://lpaste.net/8011387585102348288 and http://lpaste.net/8829491508240449536, but is there some way I can coerce the compiler into generating quickChecks for legal types of CombineAssoc'' and CombineAssoc' ?
20:31:04 <shanemikel> and how can I gain confidence in these tests? is there a way for quickCheck to report more about what generated values were tested?
20:41:07 <DotKite> Trying to write a function that counts the Height of  a Tree.  I keep getting an error.  Here is the paste.  Error is commented.     http://pastebin.com/zCiJQT4B
20:43:06 <shanemikel> DotKite: why do you have a Num constraint?
20:43:11 <shanemikel> for the type of the tree?
20:44:50 <DotKite> No reason really.  I guess it could be anything
20:45:05 <DotKite> is that what is giving me an error?
20:46:23 <dmj> DotKite: there is no type error, maybe there used to be
20:46:46 <DotKite> used to be?
20:47:13 <shanemikel> it seems to work
20:47:17 <DotKite> hmmm
20:48:04 <shanemikel> how did you invoke it?
20:48:20 <DotKite> like so,   treeHeight Node 1 Nothing Nothing
20:48:29 <DotKite> to get height of 1
20:48:32 <DotKite> but got that err
20:48:39 <shanemikel> you need to call it with a Maybe Tree
20:48:44 <DotKite> doh
20:48:54 <DotKite> I forgot
20:48:57 <DotKite> sorry guys
20:50:06 <shanemikel> no worries.. btw, it's a little cleaner to use a sum type for the tree unless there's a specific reason you don't want to allow empty trees in the type `Tree`
20:50:38 <dmwit> Gurkenglas: You may like https://www.researchgate.net/publication/2889146_Decidable_Higher-Order_Unification_Problems which knows much more than I do about what unification problems are easy and hard.
20:50:53 <DotKite> no reason, just haven't learned about the sum type yet
20:51:06 <Gurkenglas> kthx
20:51:14 <shanemikel> data Tree a = Empty | Node a (Tree a) (Tree a)
20:51:27 <Gurkenglas> (so that means ghc will just not halt on some unification queries?)
20:51:53 <dmj> :t Tree
20:51:55 <lambdabot>     Not in scope: data constructor ‘Tree’
20:51:55 <lambdabot>     Perhaps you meant ‘True’ (imported from Data.Bool)
20:52:07 <dmj> @def data Tree a = Empty | Node a (Tree a) (Tree a)
20:52:08 <lambdabot>  .L.hs:160:23:
20:52:09 <lambdabot>      Ambiguous occurrence ‘Tree’
20:52:09 <lambdabot>      It could refer to either ‘L.Tree’, defined at .L.hs:159:1
20:52:41 <dmwit> shanemikel: http://stackoverflow.com/q/33642741/791604 ?
20:52:41 * hackagebot http2 1.6.0 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.6.0 (KazuYamamoto)
20:52:43 <shanemikel> dmj: what, is there something wrong with my tree?
20:54:34 <geekosaur> it means there's already a Tree
20:55:57 <dmwit> shanemikel: Your `associative'` is bizarre.
20:58:02 <shanemikel> dmwit: you think?
20:58:29 <shanemikel> I don't think that question mentions anything about generating functions
20:58:46 <dmwit> The answer does, though.
21:01:35 <shanemikel> my associative' looks bizarre becuse I think it's more reasonable to rely on quickcheck's `Fun` than to write instances for every type that wraps some sort of function
21:02:25 <shanemikel> it's a little lengthy, but I think it's nice
21:03:25 <shanemikel> anyway, I don't have problems generating the functions.. my issue is, I'd like to quickcheck for all (Fun a b) that typecheck, instead of typeing (Fun Int (Sum Int)) specifically
21:03:34 <shanemikel> does the answer provide that?
21:03:39 <shanemikel> I can't really tell
21:03:49 <dmwit> No. That's not possible in Haskell, I'm afraid.
21:04:15 <shanemikel> well, is there some trick or tooling I can use to do code generation for that?
21:04:24 <shanemikel> nothing in templatehaskell?
21:05:10 <dmwit> Nothing existing.
21:06:12 <dmwit> If you wanted to hack something together you probably could, but I would expect it to be a fair bit of work, and tricky to get "right" in the sense that any quick-check-able `Fun a b` type would have a non-zero chance of being chosen.
21:07:38 <shanemikel> Is this the sort of thing that "whole program optimization" compilers might be able to help me with?
21:07:56 <dmwit> I don't think so.
21:10:47 <shanemikel> actually dmwit, it's possible that any more complicated 'function wrapping' types would be hard/impossible to use with associative', but as a first hack, I think it could be powerfull enough
21:15:41 <shanemikel> well, I guess I could minimize the labor and do some old-fashioned code generation for the types I know will check
21:16:26 <dmwit> If you have a couple types, it's probably easiest to just make a polymorphic property and monomorphize it eight or ten times.
21:17:04 <dmwit> qcInt :: MyFancyProperty Int Bool; qcInt = qcPoly
21:17:42 * hackagebot envelope 0.1.0.0 - Defines generic 'Envelope' type to wrap reponses from a JSON API.  https://hackage.haskell.org/package/envelope-0.1.0.0 (cdepillabout)
21:23:28 <shanemikel> is there an example of that I can peek at?
21:25:59 <dmwit> shanemikel: annotated http://lpaste.net/8829491508240449536
21:26:21 <dmwit> Of course you'll probably need some constraints on `a` and `b`, but you get the idea.
21:26:46 <shanemikel> no kidding, you can have higher-kinded type aliases?
21:26:46 <dmwit> `prop_combine :: (CoArbitrary a, Function a, Arbitrary b, Eq b) => CombineAssoc a b` or whatever
21:26:58 <dmwit> yes, sure
21:27:52 <shanemikel> and about constraints? for either of these things you need an extension?
21:28:10 <dmwit> no extensions
21:28:40 <shanemikel> that's great.. thanks, I don't know why I thought that was illegal
21:29:20 <shanemikel> probably because I've tried it with datatypes before
21:33:56 <shanemikel> is there a way to define aliases or datatypes in a let expr?
21:34:10 <texasmynsted> are either clckwrks or lambdacms ready to be used by a non-haskell programmer?
21:40:06 <shanemikel> thanks dmwit
21:47:15 <sshine> any F* channel around?
21:48:15 <sshine> I'm reading the tutorial and wonder why 'factorial : nat -> Tot (y:int{y>=1})' is a stronger result type than 'factorial : nat -> Tot nat' -- I'm not sure what's meant by strong here... I suppose it means something other than 'more specific/specialized'?
21:50:00 <Axman6> sshine: is it just because nat would usually include 0?
21:50:10 <Lokathor> here's a question i got asked
21:50:22 <Axman6> so |nat| = |y:y>=1|+1
21:50:28 <Lokathor> roughly: is undefined necessary to Haskell being so useful?
21:50:50 <Lokathor> in other words: could a similarly useful language be built that didn't allow undefined ever?
21:50:58 <Lokathor> ( i suspected "no" )
21:51:31 <Axman6> Lokathor: to ensure you don't have bottom you end up with languages like Agda which have to be total
21:51:53 <Lokathor> but still useful to program in?
21:52:04 <Axman6> sure, but less useful
21:52:19 <Axman6> as in, there are programs you can write in haskell which you can't write in Agda
21:52:33 <Axman6> but for many cases that extra power isn't needed
21:53:15 <cdtdev> So undefined is just a convenience feature?
21:53:29 <Ralith> of course, sometimes things which aren't needed can be really immensely convenient
21:53:40 <Ralith> but I'm pretty sure agda's totality is optional anyway
21:54:10 <sshine> Lokathor, there are semi-useful hybrids between Haskell and Agda, too. like F* and Idris. :)
21:54:12 <cdtdev> Can I write just as total programs in Haskell as I can in Agda, and that it's the case that agda just (normally) enforces such totality?
21:54:39 <sshine> cdtdev, sure, but your type system won't let you express or prove that the function is total.
21:54:39 <aarvar> cdtdev: yes
21:54:53 <sshine> cdtdev, id x = x :D
21:55:11 <Lokathor> totality checking BY HAND? what are we, BARBARIANS!?!?
21:55:54 <cdtdev> sshine: But can I, with discipline to not use non-total things like undefined, "know" in a practical manner they're just as complete?
21:56:19 <dmwit> shanemikel: No, type aliases and data definitions have to be at the module level.
21:56:35 <sshine> cdtdev, sure.
21:56:56 <Lokathor> cdtdev, main = putStrLn "foo"; that's a total program for example
21:57:13 <cdtdev> sshine: Another words: Could I create a subset of Haskell that's just as provable as Idris?
21:57:47 <aarvar> cdtdev: sure, why not
21:58:09 <sshine> cdtdev, just let your functions be pure, don't use non-total functions like 'fromJust', don't leave any case-ofs unmatched, and make sure your recursion is size-reducing. :)
21:58:15 <dmwit> Lokathor: undefined (or similar) is required for Turing completeness.
21:58:28 <dmwit> Lokathor: That said, much can be done in Turing incomplete languages, of course.
21:58:30 <cdtdev> sshine: Thanks.
21:58:33 <aarvar> and that your corecursion is productive
21:58:35 <Lokathor> ohhh?
21:58:38 <Lokathor> how interesting
21:58:51 <sshine> cdtdev, yes, but the point in languages with stronger type systems is that the compiler can do more work for you.
21:59:14 <aarvar> proving totality can also be inconvenient though
21:59:18 <cdtdev> sshine: Are you saying that Idris/Agda has a stronger type system, or Haskell?
21:59:24 <dmwit> Lokathor: In the denotational semantics, undefined has the same meaning as any other non-terminating program.
21:59:35 <aarvar> but it'd probably be better to have unproved totality be the exception rather than the rule
22:00:01 <sshine> cdtdev, I wasn't saying that specifically, but the former.
22:00:13 <Lokathor> so if there wasn't undefined but there was still other non-terminating expressions.. wouldn't that be the same?
22:00:24 <aarvar> Lokathor: yes
22:00:44 <cdtdev> Right -- that's what I thought of Haskell -- I can have a pretty-mucho-guaranteed program, and isolate all the non-guaranteed parts to very specific parts of the program.
22:00:46 <dmwit> Lokathor: In such a world, we could create undefined out of thin air; e.g. `undefined = undefined` would be one way.
22:00:54 <sshine> Lokathor, "the same" as in who cares if your function throws an exception or recurses infinitely? :P
22:01:16 <Lokathor> sshine, yes, that style of sameness.
22:01:18 <Lokathor> :3
22:01:19 <dmwit> Lokathor: (or `undefined = any other non-terminating expression, which you have already posited exist`)
22:02:51 * hackagebot warp 3.2.6 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.6 (KazuYamamoto)
22:03:05 <shanemikel> I'm gonna take that argument to my electric company
22:03:18 <sshine> dmwit, I prefer: undefined = let p i = collatz i /= 1 || p (i+1) in p 1
22:04:57 <sshine> whoops, it has the wrong type.
22:12:51 * hackagebot wai-app-file-cgi 3.1.1 - File/CGI/Rev Proxy App of WAI  https://hackage.haskell.org/package/wai-app-file-cgi-3.1.1 (KazuYamamoto)
22:17:51 * hackagebot mighttpd2 3.3.1 - High performance web server on WAI/warp  https://hackage.haskell.org/package/mighttpd2-3.3.1 (KazuYamamoto)
22:24:58 <hunteriam> I'm trying to model "Settlers of Catan." In particular, the turn order
22:25:19 <hunteriam> Suppose I've got a list of Players, with associated IDs, and I know who the current player is by their ID
22:25:45 <hunteriam> The problem is there are two phases of turn order in Catan, the Initialization phase, where nothing costs anything, and the Normal phase
22:26:03 <hunteriam> in the initial phase you go across the players in order once and then in reverse order, before moving to normal phase
22:26:13 <hunteriam> and in the normal phase you're always in normal order
22:26:23 <hunteriam> every solution I think of is messy
22:26:32 <Lokathor> initList = normalList ++ reverse normalList
22:26:55 <hunteriam> so you think I should use a list and say the head of the list is the current player always?
22:27:13 <Lokathor> well
22:27:30 <Lokathor> seems reasonable enough at first glance
22:27:59 <hunteriam> it does
22:28:13 <Lokathor> maybe more like, initList = turnOrder ++ reverse turnOrder; normalList = cycle turnOrder
22:28:16 <Lokathor> something like that
22:30:42 <cdtdev> Man, I just wish my girlfriend would me throw away some of these reusable containers / bags.
22:31:25 <MarcelineVQ> hunteriam: that's a pretty cool idea, settlers would be a great haskell project
22:31:44 <Lokathor> cdtdev, it :: Either OneWordTooMany OneWordMissing
22:31:55 <cdtdev> let
22:32:17 <hunteriam> *Right let
22:32:31 <Lokathor> there's a lot of board games i'd like to see digitized, perhaps as Haskell
22:32:52 * hackagebot diagrams-wx 0.1.0.0 - Backend for rendering diagrams in wxWidgets  https://hackage.haskell.org/package/diagrams-wx-0.1.0.0 (MichaelSmith)
22:32:53 <Lokathor> but catan is not one i'm sure about; Usually i'd like to see games with hidden info
22:33:03 <Lokathor> since the computer can accurately hide info after all
22:33:37 <hunteriam> hard not to lose what makes the game great
22:33:44 <shanemikel> y'all think there's gonna be a paper publication of haskellbook?
22:34:04 <Lokathor> shanemikel, it's possible, but most publishers have shied away from it, is the last i heard
22:34:18 <Lokathor> has to at least be 100% before that can happen though
22:59:26 <shanemikel> it's really filling out
22:59:34 <shanemikel> the quickcheck chapter is great
23:11:03 <f-a> semiserious questions: I keep meeting recruiter which are interested in functional langauges but then will ask me to solve challenges in $other_language. Out of the 'big ones', which has the most functional features out of the box?
23:11:08 <f-a> I suppose python and ruby
23:11:18 <ramatevish> I'd say ruby over python
23:11:29 <f-a> thanks ramatevish 
23:12:00 <cdtdev> Javascript?
23:12:50 <f-a> cdtdev: not included in the "language you can choose" set this time, unfortunately
23:13:06 <kadoban> python is pretty anti-functional. Probably javascript I guess.
23:13:18 <liste> f-a: C#
23:13:29 <liste> I'd say LINQ is pretty functional
23:13:32 <zRecursi`> F# ?
23:13:53 <liste> I wouldn't say F# is a "big one"
23:14:01 <f-a> (C, c++, Java, Ruby ,Python, php, perl) <-- these where the available choices, cdtdev kadoban liste zRecursi` 
23:14:13 <cdtdev> Ruby.
23:14:20 <f-a> thanks
23:14:22 <ramatevish> Lol, tell them java with a straight face
23:14:29 <liste> from those, Ruby
23:14:59 <ramatevish> Then say if 1.6 is okay
23:15:07 <ramatevish> s/say/ask
23:15:19 <zRecursi`> Is there any fee ebook for haskell ?
23:15:25 <zRecursi`> s/fee/free
23:15:26 <f-a> zRecursi`: a lot
23:15:42 <cdtdev> zRecursi`: I'd recommend cis 194
23:15:56 <cdtdev> zRecursi`: Not quite an e-book, but excellent resource none-the-less. Would you rather an ebook?
23:15:58 <f-a> https://en.wikibooks.org/wiki/Haskell , cis 194, learn you a haskell for great(er?) good, real world haskell
23:15:59 <zRecursi`> @where cis
23:16:00 <lambdabot> I know nothing about cis.
23:16:01 <kadoban> f-a: none of the above. I don't really know ruby though.
23:16:19 <f-a> kadoban: I wish I could have picked at least say, scala, but no dice :P
23:16:31 <zRecursi`> cdtdev: i want to read them on kindle
23:19:03 <kadoban> f-a: If those are the languages to choose from … I'd probably just not bother trying to write functionally and just use whichever one you prefer though. I'd probably use python because it's easy and they'd never ask a big project in an inverview so maintenance doesn't matter.
23:19:46 <f-a> kadoban: I did my interview in python and I think/hope the code was correct, it was just soooo frustrating
23:22:14 <ReinH> f-a: as such interviews usually are
23:22:28 <f-a> zRecursi`: the wikibook has a reader-friendly version
23:22:32 <f-a> and it's a great book
23:22:52 <zRecursi`> f-a: thx
23:23:00 * hackagebot xml-conduit 1.3.4.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.3.4.1 (MichaelSnoyman)
23:23:02 * hackagebot markdown 0.1.14 - Convert Markdown to HTML, with XSS protection  https://hackage.haskell.org/package/markdown-0.1.14 (MichaelSnoyman)
23:38:01 * hackagebot language-c-quote 0.11.5.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.5.1 (GeoffreyMainland)
23:45:21 <Job316> what was the GHCI command to show the minimal complete definition of a class?
23:45:39 <Lokathor> i've seen it in the haddock, but wasn't aware there's a command
23:45:45 <Lokathor> :info might show it?
23:47:31 <Job316> doesn't show what's in haddock
23:47:34 <Job316> guess there isn't one
23:47:35 <quchen> Job316: I don't remember GHC being able to do this
23:47:39 <Job316> ah thanks anyway
23:49:15 <Lokathor> http://haddock.stackage.org/lts-5.5/base-4.8.2.0/Prelude.html#t:Eq
23:49:28 <Lokathor> it looks like that, when there is a minimal definition
23:49:49 <Lokathor> not all typeclasses have minimal definitions that are different from just defining it all though
23:50:59 <jle`>  :info shows it for me in ghci
23:52:55 <jle`>  ^ Job316 
23:56:43 <Job316> what's the clever way to do this: (==) (ResultPair (_,j)) (ResultPair (_,k)) = j==k
23:57:12 <Lokathor> seems like a fine definition to me
23:57:39 <Job316> yep, works fine
23:58:25 <zRecursi`> :t comparing
23:58:26 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
23:59:47 <Job316> oh so comparing does something with a thing then compares it
23:59:50 <Job316> so you could do comparing fst
