00:00:23 <jle`> yeah, from a naive analysis, collatz 5 allocates more thunks
00:00:29 <astones> It's entirely pointless, I realize, but it's a fun little idea for me to entertain 
00:00:43 <cocreature> it’s not pointless if it helps you to understand things :)
00:00:47 <astones> so powers of 2 will always take up very slightly less memory than anything else
00:01:07 <jle`> not necessarily
00:01:27 <jle`> evaluating down a large power of 2 might allocate more thunks in total than, say, 5
00:01:33 <astones> well, ignoring the fact that it takes up more memory to represent a larger number
00:01:35 <jle`> than, say, evaluating 5
00:01:45 <jle`> (evaluating down the answer to collatz 5)
00:02:48 <astones> crap
00:02:51 <astones> I'm confused again
00:03:03 <astones> I'm assuming constant memory = constant thunks 
00:03:24 <astones> so 2^5 would take up the same memory as 2
00:03:44 <astones> the same number of thunks are always in use here
00:03:58 <astones> or rather, there's a maximum number of thunks that are used
00:04:08 <astones> namely, 2 I believe?
00:04:10 <jle`> oh yeah, i thought you were asking about the total amount of thunks allocated over the entire lenght of the program
00:04:25 <jle`> not the count of unevaluated thunks at a given time
00:04:56 <astones> the number of unevaluated thunks is what causes the memory usage in this program though, yeah?
00:05:14 <jle`> yes, i was answering earlier about the total amount of thunks ever allocated during the entire runtime of your program
00:05:36 <astones> oh, I must have phrased things poorly
00:05:56 <astones> I was saying maximum unevaluated thunks
00:06:27 <astones> for odd numbers it's greater than even numbers, to my understanding 
00:07:11 <astones> so that would mean in theory, collatz sequences that have odd numbers in them take up more memory than sequences with even numbers
00:07:37 * hackagebot tidal-midi 0.6 - MIDI support for tidal  https://hackage.haskell.org/package/tidal-midi-0.6 (AlexMcLean)
00:07:37 * hackagebot mono-traversable 0.10.2 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-0.10.2 (MichaelSnoyman)
00:07:45 <jle`> what do you mean when you ask how much memory a collatz sequence takes up?
00:08:11 <astones> how much memory this script http://pastebin.com/cQLkbt1n would use
00:09:26 <jle`> i think you know enough to talk about how many thunks are open at a given time during the process of evaluation
00:10:12 <astones> to ensure my understanding is correct here though before we keep going with this conversation
00:10:42 <astones> for an even number (quot x 2) would open one, x == 1 would open another and then immediately evaluate both
00:10:44 <astones> right?
00:11:21 <astones> unless x == 1 just evaluates the one and only thunk open
00:12:05 <jle`> yeah, it allocates a thunk for (x `quot` 2), and then ((x `quot` 2) == 1).  to proceed, it has to figure out if ((x `quot` 2) == 1) evaluates to True or False
00:12:17 <astones> okay
00:12:20 <astones> so that's two
00:12:22 <jle`> and so it forces the (?? == 1) thunk, which requires forcing the (x `quot` 2) thunk
00:12:36 <astones> for odd numbers, it would be three
00:12:48 <astones> because you have 3*x, +1 and == 1
00:13:08 <jle`> makes sense to me, in a theoretical situation with no optimizations
00:13:29 <astones> and as far as I understand it, thunks are what is stored in memory
00:13:32 <astones> so an odd number
00:13:36 <astones> that opens 3 thunks
00:13:49 <astones> would take up more memory than an even number, which only opens two
00:14:10 <jle`> for that specific step of evaluation, yes
00:14:45 <astones> so in a world where numbers can be stored in constant space, collatz 2^x would always take up less memory than collatz 5
00:15:13 <astones> assuming we're measuring memory by "the maximum amount of memory taken up by the script at any given point"
00:16:09 <jle`> yeah, the maximum amount of allocated and unforced thunks at any spoint in time should be less
00:16:37 <astones> thanks for humoring me there
00:16:55 <astones> that was a thought experiment just because I find thought experiments like that to be fun
00:17:06 <jle`> np!
00:17:25 <astones> I'm not really sure why, my family and friends are convinced I have some sort of critical defect :P
00:17:27 <jle`> like i said, a lot of this could be figured out/visualized with just a pen and paper evaluation
00:17:52 <astones> It's more of a question of "how does haskell work?"
00:17:56 <jle`> the process of manually substituting in and forcing things whenever you need to proceed will help you see
00:18:09 <jle`> yeah, the pen and paper evaluation will help you see how haskell works
00:18:34 <astones> because on pen and paper they would take up the same amount of memory, as I would have thought 3*x+1 takes up the same amount as quot x 2
00:19:12 <jle`> (3*x)+1
00:19:50 <astones> I also wouldn't have gotten from pen and paper on my own that haskell actually does replace quot 16 2 with collatz 8 once x == 1 is evaluated
00:20:34 <astones> in every other language I've worked with, there's still space being used up by collatz 16 right up until collatz 1 is evalutated
00:21:12 <astones> and even after that as it goes back up the recursion chain
00:21:41 <astones> I'm not sure if there's actually a word for what I call the "recursion chain" 
00:21:49 <jle`> you need to follow the rules of evaluatoin still, though :)  but the process gives insight onto what is evaluated/allocated when and where
00:21:58 <jle`>  collatz 4
00:22:04 <jle`> = collatz (4 `quot` 2)
00:22:10 <jle`>  = collatz 2
00:22:16 <jle`>  = collatz (2 `quot` 2) ... etc.
00:22:29 <jle`> each step is a substitution
00:22:35 <astones> but when you get to collatz 2
00:22:47 <astones> it is as if you had actually called collatz 2, correct?
00:22:56 <astones> that's my current understanding now
00:23:06 <jle`> yes, that's how haskell evaluation works.  evaluation through substitution
00:23:10 <mikeplus64> is there a way to pretty-print template haskell Decs /without/ every name being fully qualified?
00:23:19 <jle`> it's like replacing occurrences of `collatz 4` in your code with `collatz 2`, literally
00:24:14 <jle`> if i had a function foo (x, y) z = x + y * z, and i had foo (1,2) 3 in my code, to evaluate it, it'd be like literally replacing foo (1,2) 3 with 1 + 2 * 3.  semantically, the two are *identical*
00:24:35 <jle`> the two are required to represent/mean the exact same thing, according to haskell semantics
00:25:00 <astones> my main point of confusion has been is collatz 4 just gone
00:25:04 <astones> completely out of memory
00:25:23 <astones> once collatz (quot 4 2) has been evaluated and x is now equal to 2
00:25:46 <jle`> collatz 4 is *replaced* by collatz (4 `quot` 2)
00:26:05 <jle`> that's what the pen/paper process should show you.  at one point you had collatz 4.  the next point, you have collatz (4 `quot` 2).
00:26:08 <astones> which is in turn replaced by collatz 2
00:26:09 <jle`> the next point, you have collatz 2
00:26:43 <astones> so collatz 4 is gone even earlier than I thought
00:27:39 <astones> okay so with http://pastebin.com/05Qz0dTU
00:27:47 <astones> the reason this can't go on forever
00:28:11 <astones> is eventually you end up with collatz x (1+(1+(1+...
00:28:35 <astones> er
00:28:50 <astones> (((i+1)+1)+1)...
00:29:34 <astones> and you run out of memory because you're adding a thunk and it uses O(n) space
00:29:35 <astones> neat
00:30:08 <astones> I have ended up with my original thoughts being validated, but with a much deeper understanding of why they're right
00:30:16 <jle`> yeah, every step allocates a new thunk, and nothing ever forces anything until the very end
00:30:27 <astones> which, in my opinion, is a great way to come out of learning something
00:31:19 <astones> but if you force it to evaluate i+1 right now with $!, that can go on forever too
00:31:28 <astones> assuming there isn't an interger overflow
00:32:40 <astones> oh hey, and that evaluates in constant space too (in the magical world where intergers take up constant space) 
00:33:02 <astones> actually
00:33:36 <astones> does haskell dynamically assign memory to an interger, or is it actually constant space with space for the largest interger
00:34:01 <astones> so does 2**4 take up more memory than 0 is the question here
00:34:17 <astones> it'd be neat if it does, but I'm assuming it's like every other language ever
00:34:38 <kadoban> Probably not, but 2**1000 takes more memory than 2**4
00:34:51 <kadoban> Integer is a bignum implementation, they can get arbitrarily large.
00:35:13 <jle`> @src Integer
00:35:13 <lambdabot> data Integer = S# Int#
00:35:13 <lambdabot>              | J# Int# ByteArray#
00:35:15 <astones> right, I keep forgetting that Int and Interger are two different types
00:35:24 <kadoban> Int is just machine-integers-ish.
00:35:25 <jle`> hm, not sure if that was helpful
00:36:18 <jle`> but yeah, i think GHC offers two backends for Integer ... one that is outsourced to a commonly used C library, and another that is pure Haskell that works like Int until it gets too big, and then it does some tricks
00:36:58 <astones> out of curiosity, is 2**1000 evaluated immediately? 
00:37:07 <astones> when exactly does laziness kick in
00:37:22 <bitemyapp> astones: in GHCi, printing the value is what kicks it off.
00:37:50 <bitemyapp> astones: nothing is ever really evaluated immediately with Haskell unless it's static or opportunistically strict due to being a constant value.
00:38:17 <jle`> > let x = 2**1000 in "hello"
00:38:19 <lambdabot>  "hello"
00:38:32 <astones> how about something like
00:38:35 <bitemyapp> you'd have to define what "immediately" means, but I suspect you mean, "when the binding enters scope", and the answer is no.
00:38:47 <astones> x = 2^1000 / 2 
00:38:54 <bitemyapp> stuff like seq and deepseq are ways of tying evaluation to some original sin, not of introducing autocephalous evaluation.
00:39:43 <jle`> astones: when you evaluate x, it sees that you want to evaluate ?? / 2, so it evaluates `2^1000` in order to evaluate (2^1000) / 2
00:39:44 <astones> if I were to print x, would haskell evaluate 2^1000 and then divide by 2, or do 2^999
00:39:59 <astones> okay
00:40:02 <bitemyapp> astones: that doesn't have anything to do with lazy eval.
00:40:07 <bitemyapp> astones: that has to do with precedence.
00:40:15 <astones> that's true 
00:40:18 <astones> yeah
00:40:31 <kadoban> astones: The former, unless the compiler knows how to optimize it (so … unless there's a rewrite rule)
00:40:37 <jle`> again, a by-hand evaulation should help you
00:40:42 <jle`> @src (^)
00:40:42 <lambdabot> x ^ 0            = 1
00:40:42 <lambdabot> x ^ n | n > 0    = f x (n-1) x
00:40:42 <lambdabot>   where
00:40:42 <lambdabot>     f _ 0 y = y
00:40:42 <lambdabot>     f x n y = g x n
00:40:42 <bitemyapp> and yeah the latter is not-a-thing
00:40:44 <lambdabot> [3 @more lines]
00:40:58 <jle`> evaluating (2^4)/2 by hand on pen-and-paper will show you
00:41:03 <jle`> that it's not evaluating 2^3 ever
00:41:13 <astones> It would evaluate it exactly how I would by hand if I looked at 2^4
00:41:20 <astones> and then looked at the next thunk
00:41:22 <jle`> no, use the definition of (^)
00:41:27 <astones> which is a neat new word 
00:41:44 <bitemyapp> nobody ever loves autocephalous.
00:42:44 <astones> actually
00:42:53 <astones> the way I had thought of it in my head made more sense
00:43:18 <astones> which still only matters if that rule had been written into the compiler
00:43:34 <jle`> (^) is not compiler magic, it's just a normal function that you can define
00:43:50 <astones> I was thinking of something like
00:43:57 <astones> a = 2^4
00:44:02 <astones> b = a/2
00:44:03 <jle`> http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Real.html#%5E
00:44:05 <astones> er
00:44:10 <astones> 2^2
00:44:57 <astones> ghc might look at the 2^2 and, having not evaluated it, notice that it can reduce that to 2^1 
00:45:10 <astones> but now that I'm thinking on it more it doesn't even make sense that way
00:45:21 <jle`> look at the definition of (^) to see how it evaluates 2 ^ 2
00:45:25 <astones> even with a handwritten rule
00:45:41 <jle`> 2 ^ 2 = f 2 2 = f 4 1 = 4
00:46:03 <jle`> so (2^2)/2 = (f 2 2)/2 = (f 4 1)/2 = 4/2 = 2
00:46:52 <astones> at any rate
00:46:57 <astones> it's hit 4am where I'm at
00:47:03 <astones> I should really be getting to bed
00:52:32 * hackagebot OpenGL 3.0.0.2 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-3.0.0.2 (SvenPanne)
00:52:34 * hackagebot OpenAL 1.7.0.4 - A binding to the OpenAL cross-platform 3D audio API  https://hackage.haskell.org/package/OpenAL-1.7.0.4 (SvenPanne)
01:04:27 <MarcelineVQ> https://wiki.haskell.org/Catamorphisms#Laws how do​ I read the cata-fusion Law? is => just standing in for the word 'implies' or 'thus' ?
01:05:25 <jle`> it should be implies, yeah
01:06:08 <MarcelineVQ> thanks, I've only seen typclasses in regards to => so I wasn't sure what that was communicating
01:07:54 <daakr> can I somehow modify the environment that I get when i run "stack exec"? I want to put a build directory in a variable of my choosing (namey LD_LIBRARY_PATH)
01:08:29 <Axman6> have you tried setting the variable and then seeing if stack exec env has the variable?
01:08:48 <daakr> Axman6: then how do i get the build directory in a portable way?
01:09:33 <Axman6> what do you mean?
01:10:04 <daakr> Axman6: well i want to add the location of an executable (which is actually a shared library) to LD_LIBRARY_PATH
01:10:13 <daakr> but stack decides where it places that executable
01:11:19 <daakr> so i'm happy to set it externally, but i don't know the location
01:12:07 <Axman6> you can specify the directory which executables are copied to with the copy-bins flag/setting
01:12:13 <Axman6> I think it has a flag anyway
01:15:34 <daakr> Axman6: ah, local-bin-path.... hmm, i suppose i could force the location that way, though i don't think i like it... good to have one solution though, thanks :)
01:48:57 <ruelr501> Is it possible to make a function with a signature like this (A -> A -> B) -> A -> A -> B just for an arbitrary number of arguments?
01:52:01 <daakr> :t id :: (a -> b -> c) -> a -> b -> c
01:52:02 <lambdabot> (a -> b -> c) -> a -> b -> c
01:52:04 <daakr> ruelr501: ^
01:53:48 <ruelr501> daakr I meant one that could also look like this (A -> A -> A -> B) -> A -> A -> A -> B
01:54:15 <daakr> :t id :: (a -> a -> b -> c) -> a -> a -> b -> c
01:54:16 <lambdabot> (a -> a -> b -> c) -> a -> a -> b -> c
01:54:40 <daakr> :t id :: (a -> a -> a -> b) -> a -> a -> a -> b
01:54:41 <lambdabot> (a -> a -> a -> b) -> a -> a -> a -> b
01:54:52 <aleator> I'm making a stack template file that depends on stuff that is not on stackage. Can I make the template somehow add the dependencies to stack.yaml?
01:55:14 <ruelr501> is it possible to make a function that could take on either of those forms?
01:55:34 <Axman6> well, clearly id can
01:55:58 <Axman6> because it can take any type a and return it, which includes a -> a -> a -> b
01:56:05 <daakr> ruelr501: if you want to take a list of arguments, take a list of arguments
01:56:42 <ruelr501> if I were to change it so that it was (A -> A -> A -> B) -> C -> C -> C -> D would it still be possible?
01:56:56 <daakr> ruelr501: not for arbitrary A, B, C, D
01:57:18 <ruelr501> If I specified particular ones?
01:57:27 <Lisa1157> Hi, I am just starting out with haskell am having trouble understanding how this line works: https://dpaste.de/6PXJ#L3
01:57:35 <daakr> ruelr501: well it is possible for C=A and D=B
01:57:48 <Lisa1157> specficaly not sure what the '_' character does?
01:58:37 <apsod> Lisa1157: the '_' character can be read as "whatever"
01:58:37 <daakr> Lisa1157: dummy variable; it's ignored
01:58:38 <srhb> Lisa1157: It matches anything, but doesn't bind a name to the value
01:59:25 <srhb> Lisa1157: As opposed to the pattern above which matches only the Branch constructor and binds the names i l r to its fields
01:59:34 <apsod> Lisa1157: note that the order of the functions matters here
01:59:50 <srhb> apsod: Equations, order of functions doesn't.
02:00:01 <Lisa1157> so it is basically an 'else' clause?
02:00:07 <srhb> Lisa1157: Yes, basically. :)
02:00:18 <Lisa1157> alright thx every1 :)
02:01:20 <apsod> srhb: true.
02:12:35 * hackagebot GLUT 2.7.0.7 - A binding for the OpenGL Utility Toolkit  https://hackage.haskell.org/package/GLUT-2.7.0.7 (SvenPanne)
02:17:35 * hackagebot sym 0.12.1 - Permutations, patterns, and statistics  https://hackage.haskell.org/package/sym-0.12.1 (AndersClaesson)
02:22:58 <srhb> Lisa1157: Mind that you could just as well replace "_" with "unusedVariableName" and it would function in exactly the same way. "_" just conveys the meaning that it's never used (because you cannot refer to it.)
03:00:44 <oggy> is there something like a deepseq strictness annotation for data types?
03:29:33 <s4ke> hi. quick question. if i were to redefine concat for lists, would a foldl or a foldr be better?
03:30:21 <s4ke> i'd suppose a foldl would be better, right?
03:30:38 <aleator> s4ke: foldr would be lazy. Also foldl always loses to foldl'
03:31:07 <ClaudiusMaximus> foldr is more natural for lists, allows 'take' etc to work happily (lazier like aleator says)
03:31:30 <tommyd> is anyone here familiar with servant? I'm getting a type error that I don't understand, implementing a POST endpoint on an API
03:31:43 <cocreature> tommyd: just ask your question directly :)
03:32:16 <ClaudiusMaximus> > foldr (/) z [a,b,c]
03:32:18 <lambdabot>  a / (b / (c / z))
03:32:42 <ClaudiusMaximus> if you were to do the fold with list appending, foldr also associates the way you want for efficiency
03:33:28 <s4ke> hmm. lists are basically 1:2:3:[], i don't seem to understand how a foldr is lazy in that context, i know that i am missing something
03:33:30 <jle`> s4ke: foldr makes more sense for lists, as you'd want (1:2:3:[]) ++ [4,5,6] to be (1:2:3:[4,5,6]) ... directly replacing the cons cell with [4,5,6].  this preserves the overall structure of your conses and lists
03:34:06 <tommyd> I get this error "No instance for (AllCTRender '[] ()) arising from a use of ‘serve’" when I change "Post '[JSON] ()" in " :<|> "submit" :> ReqBody '[JSON] S.SessionPage :> Post '[] ()"
03:34:36 <jle`> foldr f z replaces your (:)'s with f, and your []'s with z's, and respects the original structure and laziness of your list
03:35:04 <jle`> so xs ++ ys = (foldr (:) ys) xs just returns 'xs', but with ys instead of [] at the end
03:35:04 <aleator> s4ke: Contrast a++(b++(c++d) with ((a++b)++c)++d. From the first one you can start extracting things from a without computing everything.
03:35:27 <s4ke> aleator: ah, right.
03:35:35 <s4ke> thanks at all, i will come back with more questions later :)
03:35:46 <jle`> ah you meant concat, not append, sorry
03:35:50 <quicksilver> only because of the way ++ is defined, though.
03:35:54 <cocreature> tommyd: you need to have at least one content type
03:36:02 <jle`> yeah, foldr is definitely much, much better for concat than foldl
03:36:04 <aleator> quicksilver: Certainly!
03:36:24 <quicksilver> it's quite possible to imagine an alternative list type and ++ defn such taht ((a++b)++c)++d lets you start extracting things (from the right)
03:36:29 <jle`> s4ke: using foldr directly gives you linear time for appends, but using foldl directly gives you quadratic time
03:36:40 <jle`> so foldl is catastrophically worse
03:36:53 <tommyd> in some of the tutorials, they don't. specifically https://haskell-servant.readthedocs.org/en/stable/tutorial/Server.html, near the end. 
03:36:55 <tommyd> or is that old?
03:36:58 <s4ke> jle`: because foldl needs to store the intermediate results, right?
03:37:13 <s4ke> while appending 
03:37:22 <quicksilver> it is even possible to imagine a situation where (a++b) lets you extract from both ends
03:37:39 <jle`> it's because (((a++b)++c)++d) re-allocates a three times, once for each ++
03:37:50 <jle`> it has to completely re-allocate 'a' to create a ++ b
03:37:58 <jle`> and completely re-allocate (a++b) to create (a++b)++c
03:38:09 <jle`> and completely re-allocate (a++b)++c to create ((a++b)++c)++d
03:38:14 <s4ke> okay. so if i throw foldl' into the fray, it is still foldr > foldl' > foldl?
03:38:40 <jle`> but for a++(b++(c++d)), a is only allocated once, on the final ++
03:38:51 <jle`> and so are b and c.  and d is never re-allocated
03:39:24 <s4ke> so this is basically the reason foldr also works on infinite lists, right?
03:39:32 <jle`> this is a different reason
03:39:41 <jle`> it's because evaluating (xs++ys) requires re-allocating xs
03:39:44 <jle`> and not ys
03:40:54 <jle`> if i do [1,2,3] ++ [4,5,6], i have to re-allocate the 1, 2, and 3 cells from scratch.  but i can use the [4,5,6] as-is
03:40:58 <jle`> (in memory)
03:41:02 <tommyd> cocreature: why do I have to have one content type in POST? what does the first single elem type list mean in "POST"
03:41:06 <s4ke> okay, i may have said that wrong, but that's what i meant :). the infinite part of the list does not get evaluated so we can append [1,2,3] to [4..]
03:41:41 <jle`> sure, this doesn't have anything to with foldr though
03:41:50 <tommyd> cocreature: for instance, ReqBody and Get make sense when saying that '[JSON] is the type of the thing to receive/return
03:42:32 <tommyd> cocreature: but in the case of "Post '[JSON] ()" I already prefix it with "ReqBody '[JSON] a :>"
03:42:57 <stgCompiler> so I've been reading about the stg format in haskell
03:43:06 <stgCompiler> realistica.ly, how hard is it to do stg -> swift?
03:43:10 <stgCompiler> that seems really easy
03:43:17 <stgCompiler> is the hard part the 'runtime' around the stg ?
03:43:36 <cocreature> tommyd: those are two different things, the first is what you accept in the post request, the second is what it uses to respond
03:44:50 <jle`> s4ke: in fact, you can get the same right-associative behavior using foldl.  i don't think that the reason why left-assocating (++) vs. right-assocating (++) has *too* much to do with foldr vs foldl
03:45:12 <jle`> that is, with the fact that foldr works with laziness while foldl doesn't
03:45:38 <s4ke> ok :)
03:47:03 <jle`> @let concat2 = foldl (\zs z -> zs . (z:)) id
03:47:04 <lambdabot>  Defined.
03:47:07 <MichaelBurge> Is there a language extension for doing something like 'mixing in' one record's fields into another?
03:47:14 <jle`> oops
03:47:19 <tommyd> cocreature: So does a Post request necessarily have to respond with something? -_- doesn't the () in "POST '[] ()" mean I'm not responding with anything? So you are saying that the client definitely expects a response from a POST request, and by saying "Post '[JSON] ()" I'm saying "Respond with nothing, but the response body is JSON"?
03:47:39 * hackagebot machines-directory 0.2.0.8 - Directory (system) utilities for the machines library  https://hackage.haskell.org/package/machines-directory-0.2.0.8 (aloiscochard)
03:47:43 <MichaelBurge> like 'data Mixin = Mixin { foo :: Int } data A { mixin Mixin } -- Now A has a 'foo' method'
03:47:59 <statusfailed> Can anybody help me out with this Generics question? I think the GHC.Generics docs might be wrong but I'm not sure http://stackoverflow.com/questions/36544459
03:48:03 <cocreature> tommyd: the first parameter in POST is the encoding of the second parameter. so even if your response is empty you still need to specify an encoding
03:48:45 <jle`> @let concat' = ($[]) . foldl (\zss zs -> zss . (zs ++)) id
03:48:47 <lambdabot>  Defined.
03:48:56 <jle`> > concat' [[1,2,3],[4,5,6],[7,8,9]]
03:48:58 <lambdabot>  [1,2,3,4,5,6,7,8,9]
03:48:59 <cocreature> tommyd: but you might have more luck in #haskell-servant it’s been a while since I’ve played around with it
03:49:00 <tommyd> cocreature: Is there a mistake in the latest servant docs then? This is included near the end of "Serving an API": type ProductsAPI = ... :<|> ReqBody '[JSON] Product :> Post '[] () -- add a product  ...
03:49:10 <cocreature> tommyd: I would assume it’s a typo
03:49:13 <lordf> join #haskell-servant
03:49:14 <jle`> > take 10 $ concat' [[1,2,3],[4..]
03:49:15 <lambdabot>  <hint>:1:33:
03:49:16 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:49:18 <jle`> > take 10 $ concat' [[1,2,3],[4..]]
03:49:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:49:20 <tdammers> from an http perspective, a POST request should yield a response
03:49:26 <tommyd> ok cool. Thanks for clearing that up for me! 
03:49:34 <tommyd> still a noob -_-
03:49:37 <jle`> s4ke: see, laziness :)
03:49:38 <statusfailed> tommyd: I think that's saying "respond with a value of type () encoded as JSON"
03:50:01 <tommyd> cocreature: thanks for the explanation. I really appreciate it
03:50:05 <tdammers> IMO, the sensible response to a POST would generally be a redirect though
03:50:18 <tommyd> statusfailed: yeah, I understand now :)
03:50:20 <jle`> where you'll run into problems is not when the lists you are concatting are infinite, but when the list of things you are concatting is infinite.  that's when foldr vs foldl makes a difference
03:50:27 <statusfailed> tommyd: oops too slow :-D
03:51:06 <bernalex> tdammers: I once had to make a REST server. I just did what I was told by the frontend guy that wanted it. I knew nothing about HTTP really. then someone sent me a link to how HTTP POST is *supposed* to work. long story short: https://github.com/plaimi/tempuhs-server/commit/7bcd997c67b07ae01a712781d754a29646290fce
03:51:12 <s4ke> jle`: sorry, haven't followed, i am reading the script for my exam on wednesday. sec
03:51:30 <jle`> np, i'm heading off anyways :) happy haskelling!
03:52:21 <tdammers> bernalex: the reason why people use POST for things that should really be PUT, PATCH or DELETE is because mainstream browsers and intermediate proxies tend to block those
03:52:39 <s4ke> also, concat' = foldl (++) worked just fine for me
03:52:39 <tdammers> wai-extra even has some middleware stuff to work around this
03:52:42 <s4ke> also with lazyness :D
03:52:42 <bernalex> honestly, Web backend isn't *that bad* even. you just implement somewhat well-defined things. some of them are silly, and privacy/security is pretty lol. but it's not too bad. frontend though... ugh.
03:53:08 <bernalex> tdammers: interesting. we never had a problem with any of it at least. the frontend used PUT/PATCH/DELETE no problem.
03:53:25 <bernalex> tdammers: in the end, it made the backend much nicer IMO. more guarantees.
03:53:31 <tdammers> bernalex: of course
03:53:41 <s4ke> jle`: i guess the lazyness argument from the lecture comes from a different angle
03:53:53 <s4ke> i dont know whether that was related to folds at all
03:53:56 <tdammers> bernalex: the wai-extra stuff makes it such that you POST /blah?method=DELETE, and your actual application code gets to see a DELETE request
03:54:01 <s4ke> s/know/remember
03:54:30 <tdammers> same application code, you just throw in the middleware
03:54:50 <bernalex> tdammers: we used Scotty for those -- which might use WAI.
03:54:55 <tdammers> it does
03:55:13 <bernalex> I know that it uses WAI. I don't know if it does for those things specifically, but I would assume it does so.
03:55:16 <liste> tdammers: and then someone uses "method" as a query parameter
03:56:25 <tdammers> liste: that, of course, is the unfortunate downside
03:56:30 <bernalex> I just thought it amusing that the frontend guy contacted me like "wow, holy shit, you've guys done this the way it's supposed to be done! nobody does that!", complimenting how our server was much nicer to work with than anything "backend Web people" make... and we knew nothing at all about Web. we were more interested in writing datatypes and QuickCheck stuff.
03:56:41 <tdammers> liste: also probably the reason why it's implemented as an optional middleware
03:57:01 <bernalex> I think that must mean that HTTP is actually quite well documented.
03:57:24 <bernalex> though IDK about how well it is *implemented* in general.
03:57:33 <tdammers> bernalex: most backend web devs are, unfortunately, the same kind of incompetent as the average frontend peeps, but they additionally lack people skills and aesthetics
03:57:43 * hackagebot jwt 0.7.1 - JSON Web Token (JWT) decoding and encoding  https://hackage.haskell.org/package/jwt-0.7.1 (StefanSaasen)
03:57:45 * hackagebot protolude 0.1.1 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.1 (sdiehl)
03:58:08 <tdammers> and yes, HTTP is well documented and well defined, and people don't give a shit about the documentation and definitions
03:58:14 <bernalex> tdammers: interesting. we were very incompetent, and completely lacked people skills and aesthetics. so I don't think that should be much of a hindrance to them.
03:58:29 <tdammers> incompetent as programmers, I mean
03:58:30 <bernalex> tdammers: that's sad. but, you know, as expected.
03:58:49 <bernalex> tdammers: hmmm I think I'm pretty incompetent as a programmer, although I meant specifically with Web stuff here.
03:59:06 <tdammers> bull. you're not incompetent.
03:59:22 <bernalex> Web, to me, is the thing I go on every now and again with most of it blocked, in order to read an indexed encyclopædia.
03:59:57 <bernalex> well, I'm not particularly *competent* compared to the people I surround myself with.
04:00:36 <tdammers> https://developer.wordpress.org/reference/functions/capital_p_dangit/
04:00:41 <tdammers> here's "incompetent" for you
04:01:03 <tdammers> particularly, https://developer.wordpress.org/reference/functions/capital_p_dangit/#source-code
04:02:05 <bernalex> though if I were to compare myself to most of the people I went to school with, I seem to have... certain advantages. like, I was on a group project once with a guy that claimed that the "designer" needed to use 64-bit Eclipse to write the CSS, because that's what he used to write Java for the TomCat portion. bonus points that he used a pirated 32-bit Eclipse (no, IDK why you'd pirate a free software IDE).
04:02:07 <bernalex> and this stuff was actually *common* amongst maybe 90% of the people I went to school with. different schools & different levels even. interesting thing.
04:02:52 <bernalex> tdammers: DUDE WTF
04:02:58 <bernalex> I just read what you linked
04:03:02 <bernalex> what in the absolute fuck
04:03:10 <tdammers> that's average wordpress code for you
04:03:24 <tdammers> I'm not shitting you, people actually write code like that and don't see a problem with it
04:03:35 <tdammers> (#-blah material at this point)
04:04:08 <Xnuk> @hoogle [a] -> Int -> Maybe a
04:04:09 <lambdabot> Prelude (!!) :: [a] -> Int -> a
04:04:09 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:04:09 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
04:04:24 <MasseR> bernalex: on windows-world you are accustomed to pirate everything
04:04:33 <MasseR> It is incomprehensible that something could be free
04:05:09 <s4ke> damn, i dont understand how i have survived without haskells type-system for so long
04:05:14 <tdammers> technically, nothing can be free on a non-free platform :x
04:05:29 <MasseR> tdammers: free as in no cost :)
04:05:42 <MasseR> They would probably even pirate the web browser if they weren't using ie :)
04:05:43 <pobes> emacs > vim
04:05:43 <tdammers> still
04:32:44 * hackagebot yaml 0.8.17 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.17 (MichaelSnoyman)
04:42:45 <stgCompiler> data Bool = True | False
04:42:49 <stgCompiler> how are Char/Int implemented?
04:43:02 <liste> @src Int
04:43:02 <lambdabot> data Int = I# Int#
04:43:15 <stgCompiler> I'm going though exercise for rebuilding prelude from scratch
04:43:18 <stgCompiler> and this is interesting
04:43:19 <stgCompiler> @src Char
04:43:19 <lambdabot> data Char = C# Char#
04:43:23 <liste> it's GHC specific stuff though, the Report doesn't specify it
04:43:30 <stgCompiler> @src Char#
04:43:31 <lambdabot> Source not found. It can only be attributed to human error.
04:43:45 <liste> stgCompiler: Char# and Int# are unboxed char and int
04:43:45 <ertes> stgCompiler: those are primitive
04:44:11 <stgCompiler> why am I not allowed to write "data Char = C# Char#" in my own *.hs file ?
04:44:15 <stgCompiler> I get parse error on "#"
04:44:25 <liste> stgCompiler: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/primitives.html
04:44:38 <liste> stgCompiler: it requires -XMagicHash
04:45:25 <liste> stgCompiler: you can define your own Int and Char though using just sums and products of units, but they'll have horrible performance
04:45:45 <stgCompiler> I need something practical; I'm building my own compiler from STG
04:46:19 <liste> stgCompiler: then I'm afraid you need to go outside Haskell
04:46:36 <stgCompiler> well, the GHC API alreayd gives me STG
04:46:42 <stgCompiler> I just need a 'lightweight prelude' to go with it
04:49:52 <stgCompiler> besides GHC.Prim from the ghc-prim package, is there anything else that will give me Char# and Int# ?
04:50:31 <liste> stgCompiler: no. look at GHC.Prim's source for fun ; )
04:50:35 <stgCompiler> @src error
04:50:36 <lambdabot> error s = throw (ErrorCall s)
04:50:55 <stgCompiler> @src ErrorCall
04:50:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:51:23 <stgCompiler> https://www.haskell.org/hoogle/?hoogle=ErrorCall certainly not the one from Control.Exception since Prelude uses it ...
05:06:02 <tdammers> is there a printf flavor for Text.Printf that takes a list of arguments instead of being variadic?
05:07:11 <tdammers> i.e., printfa :: PrintfArg a -> String -> [a] -> r
05:07:51 <tdammers> PrintfArg a => ... -- that is
05:08:10 <Myrl-saki> @pl (\x y -> x == fst y)
05:08:10 <lambdabot> (. fst) . (==)
05:08:18 <Myrl-saki> Okay. That's ugly. Lol.
05:08:31 <Myrl-saki> I don't even see how that works.
05:09:08 <Myrl-saki> Anyone else think deleteBy is wrongly done?
05:09:13 <Myrl-saki> :Y
05:09:32 <ClaudiusMaximus> :t deleteBy
05:09:33 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
05:10:37 <ClaudiusMaximus> could be  (a -> Bool) -> [a] -> [a]  without much loss i guess
05:11:07 <Myrl-saki> ClaudiusMaximus: Exactly.
05:11:27 <bernalex> Myrl-saki: 1. x y -> x == fst y. 2. eta-reduce y to get x y -> (x ==) . fst. 3. eta-reduce x to get (. fst) . (==).
05:11:31 <Ferdirand> > deleteBy (==) 0 [1,1,1,2,2,3,4,5]
05:11:32 <lambdabot>  [1,1,1,2,2,3,4,5]
05:11:50 <ClaudiusMaximus> then you wouldn't have to check which order the by-function gets the arguments in if you wanted to get the simpler type
05:12:08 <Ferdirand> huh, that didn't do what I expected from the signature
05:12:42 <ClaudiusMaximus> > deleteBy (==) 'l' "hello"
05:12:44 <lambdabot>  "helo"
05:12:46 * hackagebot http-client 0.4.27.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.27.1 (MichaelSnoyman)
05:12:53 <bernalex> Myrl-saki: sorry, 2. to get x -> (x ==) . fst.
05:12:55 <ClaudiusMaximus> (it deletes the first match)
05:13:24 <Boomerang> :t filter
05:13:25 <lambdabot> (a -> Bool) -> [a] -> [a]
05:13:44 <ClaudiusMaximus> filter keeps all matches and deletes all the rest
05:14:07 <ClaudiusMaximus> different behaviours, both useful
05:17:46 * hackagebot yesod 1.4.3 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-1.4.3 (MichaelSnoyman)
05:17:48 * hackagebot yesod-auth 1.4.13.1 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.13.1 (MichaelSnoyman)
05:17:50 * hackagebot yesod-core 1.4.20.1 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.20.1 (MichaelSnoyman)
05:21:47 <Boomerang> :t filter . (.) not
05:21:49 <lambdabot> (a -> Bool) -> [a] -> [a]
05:22:46 * hackagebot http-client-tls 0.2.3 - http-client backend using the connection package and tls library  https://hackage.haskell.org/package/http-client-tls-0.2.3 (MichaelSnoyman)
05:22:48 * hackagebot http-conduit 2.1.9 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.1.9 (MichaelSnoyman)
05:31:50 <siwica> What is the best way to quickly jump to the documentation/imnplentation of a particular library function from within emacs?
05:32:08 <nobag> How do I implement GEq from https://hackage.haskell.org/package/dependent-sum-0.3.2.1/docs/Data-GADT-Compare.html on this GADT http://lpaste.net/8933275441578377216 ?
05:32:19 <dominik_> siwica: in haskell mode it's Meta-.
05:33:31 <nobag> Here's an example on a much simpler GADT https://github.com/mokus0/dependent-sum/blob/master/examples/FooGADT.hs
05:33:59 <ertes> siwica: M-. works, but only if you generate appropriate tags…  in my setup i can easily jump to stuff defined in the package i'm currently writing, but nothing else
05:35:23 <siwica> what is the function M-. is bound to in your setups?
05:35:44 <dominik_> siwica: I have (define-key haskell-mode-map (kbd "M-.") 'haskell-mode-jump-to-def-or-tag)
05:36:14 <dominik_> and this only relies on haskell tags if the ghc fails to compile the current module or something
05:36:39 <ertes> same here
05:37:32 <dominik_> does anyone know were I can read up about the differences between enabling GHC extension QuasiQuotes vs. enabling TemplateHaskell?
05:37:44 <dominik_> I thought that QuasiQuotes were just a subset of TemplateHaskell
05:38:06 <ertes> dominik_: quasiquotes parse a string:  [quoter| some string |]
05:38:16 <ertes> dominik_: TH functions take regular haskell arguments
05:38:25 <dominik_> but apparently Yesod's shakespeare languages only work with quasiquotes and I get parse errors when using TemplateHaskell
05:39:26 <ertes> i don't think there is any other difference…  you use quasiquotes to introduce your own syntax that gets transformed into haskell
05:39:49 <dominik_> ertes: do you know why something like html = [hamlet| <b>bold |] only works with QuasiQuotes enabled, but not TemplateHaskell?
05:40:21 <ertes> because QuasiQuotes is the extension that enables quasi-quoters =)
05:40:56 <siwica> ok, thank you! I will do some research, I guess!
05:41:05 <ertes> TemplateHaskell enables something like this: $(makeLenses ''MyType)  -- not a quasiquoter, a.k.a. "parser that transforms a string into haskell"
05:41:21 <lyxia> nobag: Can you explain how two values can be equal ?
05:44:08 <dominik_> ertes: ok, I see
05:44:47 <dominik_> I got a little confused because the public TH API provides a Quote module, which defines the QuasiQuoters
05:45:07 <dominik_> so I supposed QuasiQuotes to get enabled along with TemplateHaskell as well.
05:45:20 <dominik_> but apparently, they don't...
05:45:41 <Myrl-saki> Guys, does hdevtools support exhaustive pattern match checking?
05:46:48 <dominik_> oh, also quasi quoters seem to splice in the generated Template Haskell code directly, whereas in TH you have to splice it in with $(..) first.
05:47:34 <dominik_> for example, test = [hamlet| some html ... |] () generates HTML directly. That is, test has type Html afterwards.
05:48:31 <dominik_> in contrast, using template Haskell something like test = [e| let x = 42 in x |] only creates a Q Exp, which only turns into a real Haskell expression, when splicing in test as $(test)
05:51:04 <dominik_> so there seem to be quite some differences between using Template Haskell's quotation brackets [{e,p,t,d}| .. |] and using custom QuasiQuoter brackets.
05:53:18 <dominik_> is my understanding that the latter get spliced in automatically correct?
05:54:46 <lyxia> I don't see why it would be different.
05:55:24 <lyxia> [hamlet| ... |] generates an expression of type HTML, [e| ... |] of type Q Exp.
05:57:24 <lyxia> e simply producing an Exp would be impractical in many cases I guess
06:01:03 <dominik_> lyxia: The thing is that the quasiquoter hamlet internally provides a function String -> Q Exp.
06:01:36 <dominik_> a quasiquoter really is nothing more than a parser String -> Q Exp
06:01:41 <lyxia> yeah that's in the type of quasiquoters
06:02:09 <dominik_> but interestingly, [hamlet| ... |] has type Html and not as I would expect type Q Exp
06:02:36 <dominik_> so quasiquotes seem to get spliced in automatically, whereas TH quotes don't? or what's happening here?
06:02:48 <tdammers> except that quasiquoters can also produce Q Decl and such
06:03:33 <dominik_> tdammers: yea, sure, but in the case of Hamlet only the String -> Q Exp quasiquoter is provided.
06:03:42 <fr33domlover> dominik_, [hamlet| ... |] is a a value, you can just use it directly as if it were a regular Html value
06:04:06 <lyxia> dominik_: well perhaps the "e" quasiquoter get spliced as well, and the result is another expression of type Q Exp
06:04:34 <stgCompiler> in practice, am I better off getting good at state, reader, writer, combinations of the two, and RWST -- or just to say screw it, and only use RWST everywhere all the time anytime I need any of the three
06:05:20 <Jinxit> stgCompiler: only use the part you need
06:05:30 <obadz> > "é€" :: String
06:05:32 <lambdabot>  "\233\8364"
06:05:37 <tdammers> stgCompiler: you're probably best off using neither, unless there's a really compelling reason
06:05:45 <obadz> is there anyway to get the unicode chars to display in repl?
06:06:14 <fr33domlover> obadz, putStrLn ?
06:06:39 <fr33domlover> > putStrLn "é€"
06:06:41 <lambdabot>  <IO ()>
06:07:09 <tdammers> lambdabot doesn't run IO actions, but GHCI will
06:07:10 <obadz> fr33domlover: no flag I can give ghci?
06:07:52 <fr33domlover> obadz, I don't know. Good idea for a patch though, if you have a good use case
06:08:22 <fr33domlover> e.g. your local language uses these chars a lot etc. and you want to see them as is
06:08:48 <tdammers> you'd have to override the Show instance for String
06:15:00 <obadz> fr33domlover: actually it looks lke it's the Show instance as tdammers says, not a display thing.
06:16:14 <fr33domlover> obadz, yeah but technically if it's something people want, GHCi could use an alternative instance, at least just for showing a String in the repl
06:16:38 <fr33domlover> or treat it as "post processing" of the value after it's returned from your code
06:16:38 <obadz> I'm fine with it now that I understand it
06:16:50 <fr33domlover> great :)
06:18:29 <trollando> 'sup
06:38:11 * hackagebot llvm-pkg-config 0.0.0.1 - Generate Pkg-Config configuration file for LLVM  https://hackage.haskell.org/package/llvm-pkg-config-0.0.0.1 (HenningThielemann)
06:43:35 <padre_angolano> obadz: the flag you want is 'ghc -interactive-print myprint', where myprint is a function to use instead of print when printing expressions interactively
06:43:53 <obadz> padre_angolano: yes saw that
06:44:08 <obadz> wonder what's the best pretty printing library these days
06:45:58 <padre_angolano> obadz: I googled this one: http://lpaste.net/159562
06:49:56 <obadz> padre_angolano: bit hacky. was also hoping i'd get nice indented prints out of it
06:54:50 <nobag> lyxia: the Ints determine equality, and of course the types need to be equal too
06:58:29 <s4ke> @ let undefined | False = undefined
07:03:37 <lyxia> nobag: I don't think your GADTs carry enough context to decide equality of types.
07:06:57 <nobag> lyxia: is there a solution?
07:08:15 <lyxia> to what problem?
07:08:17 <nobag> lyxia: I'd like to use Data.Dependent.Map with a GADT like Foo
07:09:14 <nobag> lyxia: and for that I need to implement GEq
07:09:52 <lyxia> What does your Foo type represent?
07:10:15 <lyxia> Does it have to be that particular GADT? because as I said it doesn't look possible to me.
07:10:34 <nobag> an AST
07:12:21 <lyxia> can you be more specific?
07:13:23 <nobag> lyxia: I'm writing a DSL with liftable functions
07:13:42 * hackagebot base-orphans 0.5.4 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.5.4 (ryanglscott)
07:13:44 * hackagebot base-compat 0.9.1 - A compatibility layer for base  https://hackage.haskell.org/package/base-compat-0.9.1 (ryanglscott)
07:13:45 <nobag> lyxia: I'd like to represent it with an AST like that GADT
07:14:51 <nobag> lyxia: and to implement my runtime I'm having to keep around Map Int Dynamic -- it would be nice if I could use a dependently typed map instead
07:15:23 <lyxia> The problem is that the constructors of your GADT do not give any information about the type of the resulting value.
07:18:08 <nobag> lyxia: I don't understand that... If I give you the types I applied to a constructor you could give me the type of the resulting value, right?
07:18:24 <nobag> with the definition of the GADT
07:20:51 <lyxia> GEq can only look at constructors, not the types of their arguments
07:21:38 <lyxia> you have to imagine that at runtime all types are erased
07:21:44 <lyxia> so all you can depend on is constructors
07:21:51 <bennofs> nobag: what dependent map do you want to represent? What are your keys, and what are your values?
07:22:41 <nobag> Something like Foo a => [a -> IO ()]
07:24:09 <nobag> Since an Foo is identifiable by it's Int argument I can implement this with an Int => Dynamic map, but it would be nicer if I could just use the Foos as keys
07:24:18 <nobag> *a Foo *its
07:27:42 <lyxia> Does Int identify a Foo a value, or a Foo a type, or both? (i.e., every Foo a type has only one value being used?)
07:30:45 <nobag> lyxia: Foo a can be inhabited by multiple values with different Ints
07:33:10 <xnil> what's #haskell's favorite 2d/3d plotting library?
07:33:54 <mfng> Hi guys, I have needles = ["day","week","month"], and a stack = ["which month", "which day", " ", "week poo"]. I want to produce the result = ["month", "day", " ", "week"]. Could you please help?
07:34:52 <xnil> mfng: if you have this:
07:35:13 <xnil> needles = ["foo", "bar"]; stack = ["foo bar"]
07:35:20 <xnil> do you want result = ["foo bar"]?
07:35:31 <ertes> xnil: for 2D 'diagrams' is popular…  it's a more general graphics library
07:36:12 <mfng> <xnil> well, just ["foo"]
07:36:25 <xnil> ah.
07:36:48 <xnil> i'll whip up a function just gimme a second, bit preoccupied with my omelette
07:36:55 <xnil> thanks ertes. anything for 3d?
07:37:13 <mfng> <xnil> great. Thank you
07:37:17 <ertes> xnil: none that i'm aware of
07:38:27 <ertes> :t \needles -> map (\str -> maybe str id . find (`isInfixOf` str) needles)
07:38:28 <lambdabot>     Couldn't match expected type ‘a -> Maybe [a1]’
07:38:28 <lambdabot>                 with actual type ‘Maybe [a1]’
07:38:28 <lambdabot>     Relevant bindings include
07:38:31 <xnil> mfng: mySearch needles haystack = map myFunc $ zip needles haystack
07:38:35 <xnil> where myFunc = ...
07:38:37 <ertes> :t \needles -> map (\str -> maybe str id $ find (`isInfixOf` str) needles)
07:38:38 <lambdabot> (Eq a, Foldable t) => t [a] -> [[a]] -> [[a]]
07:38:55 <xnil> err mine is dumb and wrong
07:38:56 <xnil> sorry
07:38:59 <xnil> too early for me
07:39:29 <xnil> very nice, ertes
07:39:55 <ertes> not so nice…  space usage grows linearly with 'needles'
07:40:06 <ertes> :t \needles -> map (\str -> maybe str id . find (`isInfixOf` str) $ needles ())
07:40:07 <lambdabot> (Eq a, Foldable t) => (() -> t [a]) -> [[a]] -> [[a]]
07:40:18 <ertes> more space-friendly variant
07:40:42 <xnil> i meant nice as in timely ;_;
07:40:59 <xnil> i've disgraced the `nil` family name
07:41:22 <mfng> Thank you both. I will test it now
07:52:13 <mfng> Doesn't seem to work
07:52:15 <mfng> > \xs -> map (\ys -> maybe ys id $ find (`isInfixOf` stack) needles)
07:52:16 <lambdabot>  Not in scope: ‘stack’Not in scope: ‘needles’
07:53:23 <lyxia> lambdabot is pretty explicit here
07:58:09 <xnil> mfng: what is that supposed to do?
07:58:44 * hackagebot cabal-dependency-licenses 0.1.1.2 - Compose a list of a project's transitive dependencies with their licenses  https://hackage.haskell.org/package/cabal-dependency-licenses-0.1.1.2 (JasperVanDerJeugt)
07:59:05 <ertes> mfng: wait, there is something wrong
07:59:31 <ertes> ah, nope, it should work
07:59:54 <ertes> > (\needles -> map (\str -> maybe str id . find (`isInfixOf` str) $ needles ())) ["ab", "cd"] ["grab", "cd player", "neither"]
07:59:56 <xnil> > let search needles stack = map (\str -> maybe str id . find (`isInfixOf` str) $ needles ()) stack in search ["foo", "bar"] ["foo poo", "bar boo"]
07:59:57 <lambdabot>      Couldn't match expected type ‘() -> t0 [Char]’
07:59:57 <lambdabot>                  with actual type ‘[[Char]]’
07:59:57 <lambdabot>      In the first argument of ‘\ needles
07:59:58 <lambdabot>      Couldn't match expected type ‘() -> t0 [Char]’
07:59:58 <lambdabot>                  with actual type ‘[[Char]]’
07:59:59 <lambdabot>      In the first argument of ‘search’, namely ‘["foo", "bar"]’
08:00:02 <xnil> ok
08:00:08 <ertes> > (\needles -> map (\str -> maybe str id . find (`isInfixOf` str) $ needles ())) (const ["ab", "cd"]) ["grab", "cd player", "neither"]
08:00:10 <lambdabot>  ["ab","cd","neither"]
08:00:12 <bennofs> nobag: I guess you might be able to implement geq using Typeable
08:00:23 <ertes> mfng: that's the behaviour you wanted, right?
08:00:38 <xnil> ertes: i think he's looking for words
08:00:43 <bennofs> nobag: so you would have to change your GADT to data Foo a where A :: Typeable a => Int -> a -> Foo a and so on
08:00:47 <xnil> rather than searching within words
08:00:56 <xnil> indiscriminately
08:01:22 <ertes> can't infer that from the question
08:01:26 <xnil> yes, you can
08:01:32 <xnil> look at his data and results
08:01:39 <stobix> I like how 'indiscriminately' is the first word I see when joining #haskell
08:01:41 <ertes> *i* can't =)
08:01:41 <xnil> they remove space padding
08:01:46 <xnil> ah :P
08:01:56 <xnil> i'll try my hand at something closer, one sec
08:02:03 <bennofs> nobag: then you can compare the 'typeRep's of the types
08:02:58 <mfng> wait, it is actually working
08:03:14 <bennofs> nobag: so like geq (A _ a1) (A _ a2) = eqT a1 a2
08:03:15 <lyxia> bennofs: that's worse than using a map Int -> Dynamic
08:03:20 <xnil> ...that's not exactly the answer to what you were asking about
08:03:28 <xnil> unless your question was misrepresented
08:05:00 <mfng> What if I want ["foo bar"] for the input ["foo","bar"]?
08:05:00 <xnil> > let search needles stack = map myFunc stack where myFunc hay = unwords . filter (`elem` needles) words hay in search ["foo"] ["foo bar baz", "pikl"]
08:05:02 <lambdabot>      Couldn't match expected type ‘a3 -> a1 -> [String]’
08:05:02 <lambdabot>                  with actual type ‘[a2]’
08:05:02 <lambdabot>      Relevant bindings include
08:05:09 <bennofs> oh, you should probably compare thhe int's as well in geq, so more like geq (A i1 a1) (A i2 a2) = guard (i1 == i2) *> eqT a1 a2
08:05:13 <xnil> then you can use what i wrote, when i get it working
08:05:16 <xnil> wait what
08:05:24 <xnil> mfng:  why would you want that
08:05:32 <xnil> that would just be
08:05:35 <xnil> [unwords input]
08:05:46 <xnil> what's your question precisely?
08:06:45 <xnil> > let search needles stack = map myFunc stack where myFunc hay = unwords . filter (`elem` needles) $ words hay in search ["foo"] ["foo bar baz"]
08:06:49 <lambdabot>  ["foo"]
08:06:56 <xnil> > let search needles stack = map myFunc stack where myFunc hay = unwords . filter (`elem` needles) $ words hay in search ["foo"] ["foo bar baz", "pikl"]
08:07:01 <lambdabot>  ["
08:07:06 <xnil> ???
08:07:11 <xnil> > let search needles stack = map myFunc stack where myFunc hay = unwords . filter (`elem` needles) $ words hay in search ["foo", "bar"] ["foo bar baz", "pikl"]
08:07:13 <lambdabot>  ["foo bar",""]
08:07:27 <xnil> mfng: is that closer to what you want?
08:08:30 <xnil> > let search needles stack = map (unwords . filter (`elem` needles) . words) stack in search ["foo", "bar"] ["foo bar baz", "bar"]
08:08:32 <lambdabot>  ["foo bar","bar"]
08:08:39 <mfng> <xnil> basically, there is a list of words ["month","day","week"] for example. And there is a list ["whatever day xx", "week ok blah", "empty"].. I want each of the word go through each of string in the list and return result like ["day", "week", " "]
08:08:39 <xnil> that's cleaned up a good bit
08:08:45 <mfng> So that's working
08:09:14 <xnil> > let search needles stack = map (unwords . filter (`elem` needles) . words) stack in search ["month", "day", "week"] ["whatever day xx", "week ok blah", "empty"]
08:09:16 <lambdabot>  ["day","week",""]
08:09:33 <ertes> mfng: you can use 'filter' instead of 'find', if you need *all* results rather than just the first
08:10:02 <xnil> my implementation should do the trick if i'm understanding your needs correctly
08:10:10 <ertes> but you should really give a more precise specification of your problem to avoid confusion
08:10:37 <xnil> you can revise that function being mapped over stack if you need different behavior
08:10:47 <xnil> the (unwords . filter (`elem` needles) . words)
08:10:57 <mfng> Really thank you for your help.
08:11:03 <xnil> so that suffices?
08:11:06 <mfng> Sorry for the confusion
08:11:09 <mfng> Yes, perfect.
08:11:11 <xnil> :D
08:11:29 <xnil> you could really define it like this if you wanted
08:11:34 <mfng> Thank you both <xnil> and <ertes>
08:11:37 <mfng> Have a great day
08:11:44 <xnil> search needles = map (unwords . filter (`elem` needles) . words)
08:11:53 <ertes> btw, this is horribly inefficient, so don't use it on any large sets of needles
08:11:57 <xnil> ^
08:12:16 <xnil> but as with all things, root of all evil is premature optimization
08:13:10 <xnil> is anyone here a big fan of list comprehensions? i've started to sprinkle them around in my own programs and have mixed feelings about them
08:13:18 <ertes> i don't really agree about that, mostly because in haskell the more efficient solutions tend to be the more concise ones as well
08:13:27 <ertes> i'm not
08:13:32 <ertes> list comprehensions don't compose well
08:13:38 <xnil> they don't have that... yeah what you said
08:13:49 <sm> once in a while they look more readable
08:13:54 <xnil> mhm
08:14:13 <ertes> (you could say that they compose via (>>=), but then you could just use map/(>>=) to begin with)
08:14:47 <xa0> why are they a thing?
08:15:04 <xa0> that's one thing I never understood. is it a readability thing?
08:15:31 <xnil> xa0: yeah i stumbled across a place they looked nicer than map/filter
08:15:36 <xnil> or rather map
08:15:44 <ertes> xa0: they look like set notation, and we're all crazy about sets and set notation
08:15:54 <xa0> i suppose
08:16:10 <xnil> i think it was just me trying to wrap something in a list
08:16:15 <xa0> (but lists aren't even sets!)
08:16:30 <xa0> ((but set isn't a functor!))
08:16:57 <ertes> depends on how you define sets
08:17:01 <xnil> i could've used `map (:[]) xs` but i thought `[[x] | x <- xs]` was easier to read
08:17:15 <xnil> in particular the (:[]) was frightening to me
08:17:23 <xnil> i don't like faces in my code
08:17:25 <xa0> you could use map pure / map return instead
08:17:27 <xa0> haha
08:17:40 <xnil> xa0: but isn't a list comp more readable?
08:17:53 <xa0> it is
08:18:07 <trollando> I've a question regarding cabal & build : I have a library exposing 2 modules Foo and Bar, where Bar depends on Foo. But I cannot compile it -> "Could not find module Foo" 
08:18:08 <ertes> xnil: i found that once i got used to combinator style, i find it more readable
08:18:18 <xnil> such as?
08:18:34 <xnil> combinator style, i'm confused as to what exactly you mean in this context
08:18:35 <ertes> xnil: not to say that there aren't any cases when list comprehensions are nicer
08:18:49 <ertes> xnil: filter p (map f xs)  -- combinator style
08:18:57 <xnil> oh, yes
08:19:01 <Gurkenglas> > () : forever [()] -- Why isn't this "[(),mueval-core: Time limit exceeded"?
08:19:04 <xnil> filter p . map f $ xs
08:19:04 <lambdabot>  mueval-core: Time limit exceeded
08:19:14 <ertes> [ y | x <- xs, let y = f x, p y ]  -- the equivalent list comprehension
08:19:39 <xnil> ertes: yeah i take back what i said about filter, i haven't used it in a list comprehension
08:19:49 <ertes> Gurkenglas: it probably is
08:19:54 <xnil> i think most of the comps i've done were just mapping (\x -> [x]) over a list
08:19:57 <ertes> > head $ () : forever [()]
08:19:58 <lambdabot>  ()
08:20:01 <ertes> @ Gurkenglas 
08:20:32 <xnil> `map (\x -> [x]) xs` vs `[[x] | x <- xs]`
08:20:44 <ertes> xnil: map pure
08:20:47 <Gurkenglas> > () : undefined -- Then why doesn't lambdabot handle it like this
08:20:49 <lambdabot>  [()*Exception: Prelude.undefined
08:20:52 <dcoutts> trollando: and where are the .hs files?
08:20:56 <xnil> ertes: that's...
08:20:56 <xnil> eh
08:21:01 <xnil> i don't like that
08:21:16 <ertes> Gurkenglas: good question…  probably somehow due to the wonderful world of overlapping instances…  but i'm just guessing randomly
08:21:22 <xnil> i usually like such ways of doing things but i like the type magic to be explicitly visible
08:21:28 <xa0> if you're doing something that requires lots of dataflow-style things like that, the list monad is your friends
08:21:35 <xa0> (grammar?)
08:21:39 <xnil> friend
08:22:21 <ertes> i just realised what an ambiguous term "data flow" is
08:22:23 <xnil> i still like when my code intuitively mirrors the behavior of the types describing it
08:22:46 <xnil> the list comprehension is quite good at that in this case
08:22:47 <xa0> ertes: in the "dataflow machine" sense
08:22:52 <ertes> i'd associate it more with something like FRP, MonadFix or even async/monad-par than with the list monad
08:23:09 <ggVGc> man, why is `length` applicable to Maybe?
08:23:14 <ggVGc> it just screwed me over a lot :(
08:23:28 <xa0> fair enough
08:23:36 <ggVGc> > length (Just 29)
08:23:38 <lambdabot>  1
08:23:41 <Gurkenglas> ertes, probably something that's mueval's fault. https://hackage.haskell.org/package/mueval-0.9.1.1.2/docs/src/Mueval-Parallel.html#watchDog makes it look like the killed thread ought to try outputting its results lazily
08:23:41 <ggVGc> :((((
08:23:49 <mjrosenb> ggVGc: that looks reasonable to me.
08:23:56 <xa0> ggVGc: a Maybe is a list with maximum length 1
08:24:11 <Gurkenglas> Wait, gwern wrote that? That guy is all over the internet isnt he
08:24:13 <ggVGc> It's completely unreasonable for me, from a useability perspective
08:24:21 <ggVGc> but okay, theoretically it makes sense
08:24:39 <ertes> xnil: 'map pure' is pretty intuitive to me, but that comes with experience and my general preference toward algebraic solutions =)
08:24:51 <xnil> indeed
08:25:00 <xnil> > :t pure
08:25:01 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:25:05 <xnil> :t pure
08:25:07 <lambdabot> Applicative f => a -> f a
08:25:10 <ertes> xnil: in particular it's structure-agnostic, especially if you generalise it to 'fmap pure'
08:25:14 <fr33domlover> xa0, isn't the list monad for nondeterminism?
08:25:14 <ggVGc> I just had to hunt doen a bug for an hour because I wanted to get the length of a Maybe [a], but I accidetnally forgot to handle the maybe so I got the length of the maybe rather than the length of the list
08:25:16 <xnil> oi. that's nice
08:25:56 <ertes> :t (fmap pure :: Maybe a -> Maybe (s -> a)) (Just 15)
08:25:57 <lambdabot> Num a => Maybe (s -> a)
08:26:07 <xnil> :t fmap pure
08:26:09 <lambdabot> (Functor f, Applicative f1) => f a -> f (f1 a)
08:26:17 <xnil> :t map pure
08:26:19 <lambdabot> Applicative f => [a] -> [f a]
08:26:21 <xa0> fr33domlover: it is, but it works nicely for dataflow-style things too, you can act on elements of the list like they're on their own
08:26:26 <mjrosenb> it is amusing to use mapM, where the 'm' is [].
08:26:32 <xnil> :t map return
08:26:33 <lambdabot> Monad m => [a] -> [m a]
08:26:37 <xnil> :t mapM return
08:26:39 <lambdabot> (Monad m, Traversable t) => t b -> m (t b)
08:26:41 <xnil> ew
08:26:44 <trollando> dcoutts, http://pastebin.com/raw/zE7pLhfF
08:26:47 <xnil> that's just disgusting
08:26:51 <tippenein_> ggVGc: is it possible to give the contents of your maybe a descriptive type?
08:26:51 <mjrosenb> I have not yet found a good way to use this though :-/
08:26:56 <xnil> > mapM return [1..3]
08:26:58 <lambdabot>      No instance for (Show (m0 [b0]))
08:26:58 <lambdabot>        arising from a use of ‘show_M466333245226359613724916’
08:26:58 <lambdabot>      The type variables ‘m0’, ‘b0’ are ambiguous
08:27:14 <xnil> > fmap pure [1..3]
08:27:16 <lambdabot>      No instance for (Show (f0 a0))
08:27:16 <lambdabot>        arising from a use of ‘show_M738837762884630701224934’
08:27:16 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
08:27:16 <ertes> xnil: it's *generic*, and it really pays off to learn to parse those type signatures =)
08:27:27 <xnil> :t fmap pure [1..]
08:27:28 <lambdabot> (Enum a, Num a, Applicative f) => [f a]
08:27:30 <xa0> > mapM return [1..3] :: [[a]]
08:27:32 <xnil> oops
08:27:32 <lambdabot>      No instance for (Enum a1)
08:27:32 <lambdabot>        arising from the arithmetic sequence ‘1 .. 3’
08:27:32 <lambdabot>      Possible fix:
08:27:37 <fr33domlover> > mapM return [1..2] ++ []
08:27:37 <xnil> thank bajeezus for laziness
08:27:38 <lambdabot>  [[1,2]]
08:27:43 <ertes> mjrosenb: take a special case: 'sequence'
08:27:48 <xnil> ertes: indeed, my intuition is off
08:27:58 <ggVGc> tippenein_: probably, but that does't solve the (imo) general usability issue of `length (Maybe)` being valid
08:28:01 <ertes> > sequence ["Hh", "e", "Ll1", "l", "Oo0"]
08:28:03 <xnil> i haven't touched haskell in a month or so, been studying Go very intensely
08:28:03 <lambdabot>  ["HeLlO","HeLlo","HeLl0","HellO","Hello","Hell0","He1lO","He1lo","He1l0","he...
08:28:07 <xnil> (not the language)
08:28:13 <ggVGc> in which situation is it useful to take the length of a maybe value?
08:28:21 <ertes> mjrosenb: there's a use case, at least for mapM id =)
08:28:24 <dcoutts> trollando: ok, and the command(s) you try and the error message? It can't be just "Could not find module Foo"  as the module is called My.Foo
08:28:26 <fr33domlover> ggVGc, never? :P
08:28:28 <tippenein_> ggVGc: yeah, I agree
08:28:33 <xa0> ertes: that's terrifying
08:28:38 <trollando> dcoutts, stack build
08:29:11 <ertes> xnil: it's best not to parse those too intuitively…  get a more *structural* understanding instead
08:29:14 <dcoutts> trollando: and the error message?
08:29:19 <ertes> in terms of structures and their features
08:29:37 <xnil> you're silly
08:29:38 <geekosaur> problem being there is no way to say "Maybe is Foldable" (reasonable) and "length applies to Foldables" (reasonable) without also saying "length applies to Maybe" (not particularly reasonable)
08:29:41 <ertes> for example i don't think it ever paid off for me to think of monads as burritos
08:29:46 <trollando> dcoutts, Could not find module 'My.Foo'
08:29:47 <xnil> it's our party; we can do what we want to.
08:29:56 <fr33domlover> Maybe is list a list of length 0 or 1
08:30:16 <xnil> ertes: miley cyrus never imagined she'd be quoted in #haskell.
08:30:24 <fr33domlover> you can use e.g. 'for' on a Maybe instead of pattern matching
08:30:37 <dcoutts> trollando: and src/My/Foo.hs does definitely exist? Can you tell if that error comes from ghc or from stack?
08:30:38 <fr33domlover> s/list a list/like a list
08:31:44 <ggVGc> geekosaur: yeah... I guess the issue is a bit that "length applies to foldables" isn't completely true
08:32:09 <geekosaur> it applies quite sensibly to most Foldables
08:32:10 <ggVGc> "Length applies to things finite sequences" is more reasonable
08:32:18 <ggVGc> right, to most foldables
08:32:32 <ggVGc> but not "to foldables", which implies all, as seen in the Maybe case
08:32:47 <ggVGc> anyway, I didn't expect to be bitten by that
08:33:01 <ggVGc> so now I'm a bit afraid of using Maybe [a]
08:33:28 <Gurkenglas> Where between lambdabot and mueval is watchDog called?
08:33:59 <xa0> ggVGc: how would you have length behave?
08:34:02 <xa0> w.r.t Maybe
08:35:20 <xa0> ggVGc: because honestly I can't think of any other sensible implementation
08:35:32 <quicksilver> ggVGc: Maybe is a finite sequence, though
08:35:42 <quicksilver> it's a finite sequence of length at most 1
08:35:52 <ggVGc> hm... is it really?
08:35:55 <quicksilver> (so, eihter 0 or 1)
08:36:04 <xa0> yes
08:36:05 <ggVGc> I don't think Maybe is semantically a sequence
08:36:15 <ggVGc> it's a state of success
08:36:23 <quicksilver> I'm not sure I can resolve that. I think that's an inuition.
08:36:24 <Gurkenglas> https://github.com/lambdabot/lambdabot/search?utf8=%E2%9C%93&q=watchDog&type=Code https://github.com/gwern/mueval/search?utf8=%E2%9C%93&q=watchDog&type=Code find the definition, but no call site
08:36:25 <ertes> "A hand crafted IRC client" – hand-crafting software, a lost art, an obsolete tradition, a touch of nostalgia, of the better times, when we used to write stuff that does stuff…  it's gone and {-# LANGUAGE DeriveRestOfThisCrap #-}
08:36:25 <ggVGc> it can be treated as a sequence, but it isn't semantically one
08:36:26 <ggVGc> imo
08:36:26 <monochrom> length for Maybe "makes sense" iff toList for Maybe makes sense.
08:36:44 <monochrom> to reject one you have to reject the other too, logically
08:36:47 <ggVGc> monochrom: yes, but toList should be explicit
08:36:49 <ggVGc> is my issue
08:37:01 <ggVGc> the implicit toList is not practically useful
08:37:05 <quicksilver> before we had toList/length for Maybe, we had "listToMaybe" and "maybeToList" witnessing the isomorphism
08:37:25 <Gurkenglas> ggVGc, what of using for_ on Maybe?
08:38:02 <xa0> ggVGc: i still don't see how this should affect you in any way, even if you don't like Maybe instancing Foldable, just ignore it?
08:38:40 <quicksilver> it gives confusing error messages, and it makes code which you expect to be buggy compile
08:38:53 <quicksilver> which are the problems with all kinds of overloading/instancing
08:39:01 <quicksilver> you just have to decide if the cost is worth the benefit
08:39:02 <xa0> valid point
08:39:10 <quicksilver> I'm totally in favour of Maybe/Foldable myself
08:39:12 <quicksilver> but it is a tradeoff
08:39:38 <ertes> i like the more general 'length' too…  yes, it does apply to Maybe, but so does it apply to all kinds of structures
08:40:02 <ertes> in particular i don't think it's wrong that it does
08:40:18 <monochrom> but "length Nothing" is explicit too. it explicitly says "length". it is not like we expect "Nothing < 1" to type-check and evaluate to True
08:41:07 <ertes> instance (Num a) => Num (Maybe a) where fromInteger = Just . fromInteger; …
08:43:08 <ggVGc> xa0: I had this line, https://gist.github.com/93a9d9e3dc5e1d426c95370b7412a22a , which compiled but was completely a bug in my program. What I actually wanted was the length of the list contained in the maybe, but I missed it because the compielr couldn't catch it
08:43:13 <ggVGc> sure, it's my mistake, but I wasn't expecting that
08:43:17 <ggVGc> maybe I'm just dunmb
08:43:44 <monochrom> sure, but that is orthogonal to "Maybe does not feel like a sequence"
08:44:01 <monochrom> you can make the same complaint about OverloadedStrings too
08:44:17 <ggVGc> monochrom: I guess what I feel is that length should only be valid of things that are truly lists, maybe part of some "Listable" class perhaps that Maybe would need an explicit conversion into 
08:44:47 <monochrom> you can make the same complaint about numeric literals too. even when Double "feels like a number"
08:45:40 <monochrom> but Listable is doomed to be equivalent to Foldable
08:45:52 <monochrom> and Maybe is doomed to be an instance of Listable
08:46:08 <ggVGc> to me this is the same argument as structural typing vs what haskell does. I.e a Foo{x::Int, y::Int} isn't the same as a Bar{x::Int, y::Int}, even though they can both be treated as a point
08:46:53 <monochrom> ah, but then comes along a "Point" type class that overarchs both Foo and Bar
08:47:08 <monochrom> in fact, even just lens already bring them close
08:47:21 <ggVGc> yeah..
08:47:32 <dolio> As does overloading 'x' and 'y'.
08:47:45 <monochrom> the Point class for Foo,Bar will play the exact same role as Foldable for [],Maybe
08:47:46 <xa0> what would be the discriminating factor between what Foldables end up in Listable?
08:47:56 <xa0> whether they "feel like lists"?
08:48:15 <xa0> because honestly Maybe does feel like a constrained list to me
08:48:17 <ggVGc> I feel maybe we've traded type safety for actual work for over-generalisation and convenience 
08:48:30 <mjrosenb> even then, Foo and Bar would no be the same, since Foo and Bar would construct their tuples in different orders.
08:48:42 <monochrom> you have to either reject the whole notion of type classes altogether
08:49:15 <monochrom> or you have to accept lawful generalizations enabled by type classes, all the way from "instance Point Bar" and "instance Foldable Maybe"
08:49:37 <ggVGc> yeah, I guess..
08:49:50 <ggVGc> I'm just saf the compiler couldn't protect me as much as I expected it to
08:49:51 <dolio> Well, length didn't have to be overloaded.
08:50:02 <monochrom> I take the stance of being logical and counterintuitive.
08:50:02 <dolio> But it was.
08:50:07 <xa0> length is implied by foldable
08:50:17 <ertes> xa0: Foldable and 'toList' are basically equivalent
08:50:24 <xa0> exactly
08:50:29 <dolio> It wasn't until the bikeshedding around moving it into prelude.
08:50:34 <EvanR> ggVGc: i started to think of nominal types vs structural types in a totally different way... by internalizing type theory / category theory dogmas
08:50:46 <xa0> dolio: oh i see
08:50:48 <mjrosenb> ggVGc: the compiler doesn't always protect you; it *can't* always protect you.
08:50:59 <ggVGc> EvanR: I have about three sands of type theory knowledge :(
08:51:01 <ggVGc> maybe in a few years
08:51:18 <ggVGc> mjrosenb: this was a case where I really expected it to though
08:51:23 <EvanR> ggVGc: record types are just one planet is a cosmos of types of types of ...
08:51:38 <dolio> I mean, obviously you could write 'length' using Foldable before then, but it wasn't in the class.
08:51:45 <tippenein_> I still think descriptive type classes always avoid this type of confusion
08:52:11 <monochrom> you can take "length" out of Foldable. but then someone will ask: "sum . fmap (const 1) is in, but that's length, so why is length out?"
08:52:22 <EvanR> ggVGc: also, length should be limited to list-like? what about arrays...
08:52:41 <monochrom> and then maybe someone else will say "yeah, take sum out too"
08:52:52 <dolio> Take everything out but foldMap.
08:52:53 <ggVGc> EvanR: yeah, listlike would be crap.. I dunno, this seems to be my fault for not thinking of Maybe as a short lsit
08:52:56 <ggVGc> list*
08:52:56 <monochrom> it is a slippery slope. it is a slippery slope both ways.
08:53:03 <dolio> But foldMap (const (Sum 1)).
08:53:20 <xa0> lol
08:53:35 <EvanR> slippery slope in every direction of an infinite dimensional vector space
08:53:38 <ggVGc> maybe I just don't like type classes themselves.. I.e the implicitness of tem
08:53:46 <monochrom> it is why I despise intuitive arguments
08:54:18 <mjrosenb> ggVGc: that is a somewhat reasonable argument.
08:55:15 <EvanR> ggVGc: you could ignore them as syntax sugar to make using `+' easier
08:55:18 <dolio> foldMap is the real fundamental thing in Foldable, but if you only have it, you can't write everything efficiently.
08:55:26 <EvanR> you can do dictionary passing yourself
08:55:55 <monochrom> logically, you may either reject type classes altogether so that you catch more errors and error messages are more specific, or you accept type classes but insists on laws. I respect both stances. and I am always swinging between them.
08:56:56 <mjrosenb> oh, hey, I bet you can use explicit dictionary passing to implement finger trees in languages without typeclasses.
08:57:23 <dolio> Well, you don't have to accept all uses of type classes, even with laws. Some aren't very good.
08:58:09 <eitanC> What would the fixity of :: be if it were an operator?
08:58:25 <monochrom> the reason I favour Haskell over OCaml is 60% non-strictness and 40% type classes. in OCaml "+ for int" vs ".+ for double" vs "<I forgot what> for bigint" gets old after a while
08:58:31 <ggVGc> well, I did some Elm, which doesn't have type classes, and it has great error messages and won't get bugs like this. But not having type classes is also fairly painful...[5~
08:59:03 <EvanR> yes using + for different things is closer to math notation practice, and rocks
08:59:09 <monochrom> but then if I want Num then I have to accept OverloadedStrings and Foldable and PrintfType
08:59:22 <monochrom> but I really want Num :)
08:59:33 <EvanR> maybe a future language will separate these different uses of type classes
08:59:37 <EvanR> and drop the ones that suck
08:59:55 <EvanR> like java interfaces ;)
09:00:53 <nobag> bennofs: thanks! I might give that a go :)
09:02:17 <EvanR> type classes for enforcing properties at runtime is nice, but error messages can get... and reading the code doesnt seem as obvious as when there are normal types
09:02:22 <monochrom> eitanC: I think :: is very high precedence, just below application
09:02:27 <EvanR> ... for enforcing properties at *compile* time...
09:02:51 <dolio> No, it's lower than almost everything.
09:03:09 <dolio> Not lower than lambda abstraction, though.
09:03:30 <ggVGc> is this a reasonable way to write this? I'm still trying to get comfortable with lenses(and haskell in general), https://gist.github.com/bdfeb55b27c243f61db34796802b231f
09:03:39 <EvanR> typeclasses for compile time computation... type classes for "stupid printf tricks" ...
09:03:46 <eitanC> what about it’s associativity? value :: (type :: kind) makes sense
09:03:48 <xa0> dolio: almost?
09:04:00 <xa0> oh, brackets
09:04:22 <dolio> \x -> x :: T = \x -> (x :: T)
09:05:09 <dolio> case e of x -> y :: T = case e of x -> (y :: T)
09:05:53 <xa0> ...did not know that was valid syntax
09:06:50 <eitanC> I’m using an existential pair `data (:::) f g = forall a. (:::) (f a) (g a)` and want to give it a sensible infix declaration
09:08:05 <Myrl-saki> Guys, IIRC, it's possible to assign on a guard.
09:08:09 <Myrl-saki> How wis it done?
09:08:11 <Myrl-saki> is*
09:08:24 <dolio> Pattern guards?
09:08:30 <dolio> | p <- e
09:08:41 <Myrl-saki> Oh, right.
09:09:01 <Myrl-saki> dolio: | p <- e is more or less evaluated as true, right?
09:09:15 <dolio> If p matches e.
09:09:26 <Myrl-saki> dolio: Right, but verbatim.
09:09:36 <dolio> If it's just a variable it will always match.
09:10:05 <Myrl-saki> I see, thanks.
09:53:38 <qwertzhz> and look how lively it is in here
09:54:31 <Hrk> Is there a way to force GHCi to use different format for displaying decimal numbers than scientific?
09:54:56 <Hrk> e.g to show 0.003 an not 3e-3?
09:56:08 <geekosaur> it's using the Show instance; you can't generally replace that
10:06:10 <monochrom> nice, return = pure by default, I don't have to write it myself
10:35:58 <obadz> geekosaur: hmmm with `ghci -interactive-print` you could
10:36:25 <Gurkenglas> It seems like >>= has some redundancy with Applicative's definitions. Is there something more basic that could reconstruct >>= given Applicative's definitions?
10:37:09 <Zemyla> :t join -- Gurkenglas 
10:37:18 <lambdabot> Monad m => m (m a) -> m a
10:37:57 <Zemyla> >>= allows for more efficient composition by nit requiring an fmap and then join.
10:39:08 <mjrosenb> Zemyla: meh, a sufficently optimizing compiler should be able to figure it out :-p
10:39:12 <Gurkenglas> Shouldn't join be an alternative minimal definition, then?
10:39:30 <Zemyla> It is in 8.0, I think.
10:39:47 <EvanR> if anyone is bored and in new orleans today feel free to join my haskell meetup at zotz cafe, the topic is "homebrew crypto"
10:39:54 <EvanR> at 7
10:40:09 <Zemyla> Actually, maybe in 7.10 with AMP.
10:42:37 <Zemyla> They couldn't have done it before then because Functor wasn't a superclass of Monad.
10:43:01 <Zemyla> EvanR: Is it about how homebrew crypto is always a bad idea? :P
10:43:23 <EvanR> haha
10:43:49 <EvanR> that is such a well known meme that i thought it would attract more people...
10:44:31 <Zemyla> Sadly, I'm only near New Orleans in a very relative sense.
10:46:35 <EvanR> but knowing what i know about the tech scene... it probably just attracted ridicule
10:47:58 <Zemyla> You might also ask in #haskell-blah?
10:48:26 <EvanR> whats left of it ;)
10:58:32 <cocreature> #haskell-offtopic! :P
10:59:45 <ggVGc> what's the name for a function that increases/decreases a value within a range?
10:59:53 <ggVGc> i named it boundCycle, but it's not cycling..
11:00:06 <ggVGc> this, https://gist.github.com/8487583e91fbdd5d84c0e80b2485af59
11:00:25 <ggVGc> also, is that in some common library somewhere?
11:01:29 <srhb> > succ (maxBound :: Int) -- what happens if you...
11:01:31 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
11:01:33 <srhb> ah.
11:03:53 <laz> do you mean modular arithmetic?
11:05:22 <cocreature> ggVGc: boundAdd?
11:05:27 <cocreature> or boundedAdd
11:05:52 <ggVGc> yeah, that's more reasonable
11:06:08 <ggVGc> this seems like it would be in some standard package though
11:06:09 <ggVGc> that I've missed
11:07:36 <geekosaur> obadz, doens't that still need typecase?
11:14:49 <EvanR> ggVGc: https://hackage.haskell.org/package/modular-arithmetic
11:15:02 <ggVGc> oh, that was a package name
11:15:05 <ggVGc> cheers :)
11:18:31 <ski> ertesx,dolio,monochrom : "<ertes-t6v> even if you make lambda abstraction an infix syntax, left-associating it does not make sense","<ertes-t6v> aupiff: let me write \"x -> y\" instead of \"\\x. y\"…  (x -> y) -> z does not make sense" -- it makes perfect sense. `\(\x. y). z' means `\f. let y = f x in z', `f' a fresh identifier (or use a view pattern like `($ x) -> y' if you prefer)
11:18:47 <ski> `(2 |-> (0,x)) |-> x^2' means that if the value of the input function at `2' is a pair with first component `0', then we give the square of the second component. use "and-patterns" to make (a definite number of) multiple "observations" on input functions.
11:21:21 <monochrom> I agree that we would like "var ↦ expr" or at most "pattern ↦ expr", not general "expr ↦ expr". so no one will use left-associative ↦
11:23:22 <monochrom> that is strange
11:27:33 <ski> monochrom : what i'm talking about is ⌜⟨pat⟩ ↦ ⟨exp⟩⌝ (which is an expression) but also ⌜⟨exp⟩ ↦ ⟨pat⟩⌝ (which is a pattern)
11:29:18 <ski> so an expression ⌜(⟨exp₀⟩ ↦ ⟨pat⟩) ↦ ⟨exp₁⟩⌝ is ok, as is an expression ⌜⟨pat₀⟩ ↦ (⟨pat₁⟩ ↦ ⟨exp⟩)⌝
11:30:12 <dolio> Yeah, I'm aware you can do that. :)
11:31:02 <ski> however (by intent/design), the syntax of patterns and expressions overlap, so the ⌜<exp-or-pat>⌝ in ⌜<exp-or-pat> ↦ ⟨pat⟩ ↦ ⟨exp⟩⌝ could possibly be interpreted either as an expression or as a pattern, depending on how you associate ⌜↦⌝ (if at all)
11:31:20 <dolio> I didn't say anything at the time, because I didn't want to further muddy the issue.
11:33:01 <ski> dolio : yeah .. i was just thinking you'd possibly be interested (and you appeared tangentially at the time)
11:41:49 <ggVGc> would a pure functional language without closures be possible to implement without a GC?
11:43:24 <Zemyla> ggVGc: There is an unlambda interpreter that uses reference counting.
11:43:24 <ski> @tell aupiff re the earlier discussion about "associativity of function abstraction syntax", if you use an "infix operator" notation for it, it can make sense to choose {left|right}-associativity for it. however there's also a way to think about it (conceptually, as opposed to syntactically) even if you use the usual prefix&mixfix "lambda" syntax. see <http://ircbrowse.net/day/haskell/2016/04/11?id=22593951&timestamp=1460398689#t1460398689>
11:43:24 <lambdabot> Consider it noted.
11:44:35 <ski> ggVGc : what if you generate intermediate list cons cells, e.g. ?
11:44:52 <ggVGc> Zemyla: hrm, I'm thinking of something more useful. I'd like to createa a functional language for embedding, like Lua, but pure and without a gc
11:45:34 <Cale> I guess you could look into region inference
11:45:37 <Zemyla> is there any way to make a reference loop in the language?
11:45:38 <dolio> Would a functional language without closures be useful, though?
11:45:53 <ggVGc> Cale: yeah I've been thinking a lot that region based memory management would be what I need
11:46:02 <ggVGc> dolio: yeah, I reckon. Why wouldn't it be?
11:46:05 <ski> ggVGc : perhaps you're looking for <https://en.wikipedia.org/wiki/Region-based_memory_management> (see papers on ML Kit, e.g.)
11:46:15 <ggVGc> it would be very fast and not need a GC(I hope)
11:46:22 <ggVGc> ski: yep, I'vee looked at tht
11:46:24 <dolio> I probably wouldn't use it.
11:46:28 <ggVGc> dolio: why not?
11:46:28 <Cale> Well, you don't really need to use closures to implement functions
11:46:36 <Cale> You can just do pure graph reduction
11:46:49 <ertesx> ski: if you torture syntax long enough, it will confess
11:46:50 <Zemyla> Are tehre any functional languages without something like closures?
11:46:54 <ski> ggVGc : iirc, Scheme48 has a Scheme subset, called PreScheme, with no GC
11:47:10 <ggVGc> ah, yeah, prescheme. I should look at that agan
11:47:11 <ggVGc> thanks
11:47:15 <Cale> Closures aren't really a language feature, they're an implementation mechanism
11:47:16 <ski> ggVGc : .. which they're using internally, to implement most of the run-time system, iirc
11:47:30 <Zemyla> But yeah, Unlambda has closures, and doesn't need a GC.
11:47:39 <dolio> Reference counting is GC.
11:48:15 <ski> (broken GC)
11:48:26 <dolio> Yeah, well... :)
11:48:37 <Cale> I sort of think that saying a language "has closures" is confusing language with implementation.
11:49:04 <Cale> A language might have first class functions -- whether they're implemented with closures or not shouldn't be something that you can detect ordinarily.
11:49:34 <Cale> Closures sort of stop being closures the moment you can no longer take them apart into code and environment.
11:50:01 <ggVGc> Cale: what I mean is that each function as no environment other than it's own scope
11:50:33 <Cale> Just as you wouldn't say that a programming language which has a compiler to produce programs which run on a machine implemented in silicon "has transistors"
11:50:44 <ski> ggVGc : perhaps you mean that you don't want to allow functions returning (dynamically computed) functions, or functions assigning such functions to non-local mutable variables, nor to mutable reference cells (including as components of mutable arrays, mutable records, &c.) ?
11:51:03 <ggVGc> well, so, why does haskell have a GC?
11:51:10 <Cale> GHC has a GC
11:51:11 <dolio> Can I write const? \x -> \y -> x?
11:51:13 <ggVGc> which situations in haskell arise that need a gc to clen things uo
11:51:13 <Cale> Haskell doesn't :)
11:51:17 <ggVGc> well, okay
11:51:21 <ggVGc> I meant ghc , sorry
11:51:28 <EvanR> dolio: depends on what functional means, i think i can compile this combinator language into microcontroller code if i replace haskell with AVR instruction set and dont allow closures or recursion, and provide replacements for map and fold etc
11:51:56 <Cale> With that aside, practical implementations of Haskell are implemented using garbage collectors because that's the best known way to do memory management
11:52:10 <ski> ggVGc : however, one could still allow passing (dynamically computed) functions as arguments into other functions, or storing them in a local mutable location which is visible to some local function, &c.
11:52:20 * EvanR obligatory retort to Cale's comment about rust
11:52:25 <dolio> EvanR: Yeah, a nice veneer on something really low level like that would probably be a useful application.
11:53:01 <ski> (the "upwards vs. downwards FUNARG problem")
11:53:04 <dolio> You'd have to be committed to those limitations a priori, though, I think. Or I would, at least.
11:53:07 <ggVGc> I just wish there was a tiny pure functional language with an embeddable compiler and runtime, like Lua
11:53:26 <ggVGc> maybe prescheme is actually the closest that exisrs
11:53:43 <EvanR> heh embedded compiler, in 2K ram  or less ;)
11:53:56 <EvanR> might work
11:54:05 <lip> http://adfoc.us/2542958181463
11:54:15 --- mode: ChanServ set +o Cale
11:54:19 <ggVGc> ^ spam
11:54:21 <xa0> does haskell need a GC?
11:54:25 <xa0> could it be implemented without one?
11:54:26 --- mode: Cale set +b *!*@gateway/web/cgi-irc/kiwiirc.com/x-uqpfmnykjgeuonti
11:54:26 --- kick: lip was kicked by Cale (lip)
11:54:28 <EvanR> ggVGc: http://pygmy.utoh.org/3ins4th.html
11:54:30 --- mode: Cale set -o Cale
11:54:32 <ski> ggVGc : "each function as no environment other than it's own scope" -- presumably also having access to a "global" environment (global to the process, say), including e.g. standard library operations
11:54:37 <EvanR> xa0: if you have infinite memory
11:54:44 <ggVGc> EvanR: yeah, I've been looking at forth for inspiration
11:54:48 <xa0> well obviously :p
11:54:52 <xa0> you know what i meant.
11:55:16 <ggVGc> ski: yes, functions would only have access to global scope, i.e the static scope of globally defined functions
11:55:18 <EvanR> seriously, the more memory you have, the better garbage collection works vs manual management ;)
11:55:22 <ggVGc> and their argumetns
11:55:23 <ski> dolio : .. well, you could do "fully applied" stuff, i suppose
11:55:31 <Cale> xa0: A very ambitious compiler could try to determine ahead of time when allocation and deallocation would be required.
11:55:58 <xa0> hmm, so slightly theoretically possible
11:55:59 <ggVGc> EvanR: my main reason for wanting to create this is for realtime use cases such as scripting audio/video tools or game development
11:56:03 <ggVGc> where GC pauses are a real issue
11:56:04 <dolio> xa0: Ur/Web didn't do garbage collection, because the programs were so short lived, they could just use memory and let the OS deallocate it by exiting the process.
11:56:06 <EvanR> ^ the answer to that depends on how much memory you want to use
11:56:14 <xa0> ha, fair enough
11:56:15 <Cale> xa0: But whether this would actually end up being better than a GC in practice is quite questionable. There's a lot which is theoretically impossible to determine statically about the lifetimes of values.
11:56:31 <Cale> So it would have to overestimate a lot of the time
11:56:52 <ggVGc> Cale: I'm looking for examples of wha those situations are
11:56:53 <xa0> I suppose if you have the RTS anyway you may as well slide in the cheap GC
11:57:06 <EvanR> ggVGc: i want a language which compiles into a video game where i dont have to worry about all these performance details ;)
11:57:20 <EvanR> given how much hardware we have now
11:57:26 <Cale> xa0: There are compilers for other functional languages which do what's called "region inference", which is essentially what we're talking about here.
11:57:48 <xa0> ah i see
11:57:58 <ggVGc> EvanR: FOr games it's pretty much solved with Lua I think, with the "new"(5.1) incremental GC. But I'm more interested in the audio part
11:57:59 <Cale> EvanR: Easy, just make the video game, and then implement the compiler as a constant function that makes it for you.
11:58:05 <dolio> I'm pretty sure no region system has actually demonstrated non-worse behavior than garbage collection, in general.
11:58:12 <Cale> ;)
11:58:12 <ggVGc> scripting realtime audio software with an easily reloadable language would be sweet
11:58:15 <ggVGc> but it needs to not GC
11:58:18 <EvanR> ggVGc: yyeeeah.... having written an entire game in lua.... thats not exactly what i had in mind
11:58:21 <dolio> Unfortunately.
11:58:51 <EvanR> Cale: wait... what
11:59:16 <Cale> EvanR: Just whatever source code you give, you get Dark Souls 3
11:59:22 <ggVGc> Cale: what compilers have region inference
11:59:22 <EvanR> lol
11:59:23 <ggVGc> ?
11:59:40 <ggVGc> I'm looking for examples of people going down the roads I'm thinking of
11:59:45 <dolio> JHC had some at some point, but it might have been scrapped.
11:59:47 <ggVGc> Im pretty sure what I want has been done in some way or another
12:00:01 <dolio> Not sure what else. Probably mostly research stuff.
12:00:34 <EvanR> having wasted most of my game development time doing memory management managers in one way or another... i hope they dont come out with another technology for that ;)
12:00:44 <levi> ggVGc: If you're willing to go outside the pure-functional approach, Rust probably has the most up-to-date and production-ready implementation of region-based memory management. Although it calls them 'lifetimes'.
12:00:50 <EvanR> GC ftw
12:00:54 <dolio> JHC's original plan was to be entirely region based, I think, but it never really got there.
12:00:55 <Cale> ggVGc: I think MLKit
12:01:32 <Cale> I believe they may have eventually combined their region inference with GC
12:01:45 <levi> Yeah MLKit is, as far as I know, the most advanced region-based system in a functional language.
12:02:34 <dolio> I guess you might also have to specify whether you're wondering about complete inference or something more explicit.
12:02:42 <Zemyla> ggVGc: Probably what you may want to do is have stuff be reference-counted, or region reference-counted, and then use a GC only on objects that can theoretically contain themselves.
12:03:02 <levi> The reason they needed to add GC is that it was rather difficult to reason about regions and you could easily end up with a large amount of your allocations falling in the "whole-program" region, which meant essentially memory leaking.
12:03:07 <EvanR> which happens a lot in haskell
12:03:32 <dolio> I can imagine explicit regions being able to compete with GC, but it would probably border on explicit memory management.
12:04:17 <levi> dolio: Rust is basically explicit regions with inference-guided region elision, if I remember correctly.
12:04:25 <ggVGc> Zemyla: I'm just trying to figure out these situations where "they can theoretically .....", without going through the whole implementation process first
12:04:51 <levi> I think the Disciple language has a region system, too?
12:04:56 <Cale> ggVGc: I think that an interesting but underexplored approach to embedded software development is to use something like Haskell or another high-level language to write what is effectively a one-shot compiler which will produce the code for the system being programmed.
12:05:00 <EvanR> ggVGc: if youre in something like haskell, almost ever thing contains itself because recursion
12:05:34 <Cale> ggVGc: At least for applications which are extremely performance or correctness critical, this opens up some nice possibilities, even if it's not the most natural way to get things done.
12:05:52 <levi> Cale: I don't know that I'd call it unexplored; maybe "lightly explored"?
12:05:58 <ggVGc> EvanR: that's why I'm trying to figure out the constraints I could put on the language to avoid those situations. I'm fine with the language being not very powerful, but at the very least I want first class functions and immutability
12:06:02 <Cale> I didn't call it unexplored either
12:06:07 <ggVGc> maybe I won't allow recursion
12:06:12 <levi> Oh, sorry, I misread you.
12:06:24 <EvanR> ggVGc: yeah you can provide a set of recursion primitives
12:06:34 <ski> ggVGc : btw, note that "functions would only have access to global scope" relates to Lewis' <https://en.wikipedia.org/wiki/Strict_implication>. strict implication ⌜A ⥽ B⌝ can be thought of as ⌜◻ (A → B)⌝, where ⌜◻⌝ expresses that it only depends on the necessary part of the context, not the contingent part
12:06:35 <EvanR> but you might find it awkward sometimes 
12:06:39 <ski> ggVGc : "what compilers have region inference" -- yes, see ML Kit
12:08:59 <ggVGc> EvanR: so, to make this somewhat useful I'm thinking I might have limited local mutability within functions
12:09:07 <ggVGc> not sure what implications that would have
12:09:21 <ggVGc> so instead of recursion you would do mutation
12:09:31 <EvanR> as long as it has no side effects!
12:09:32 <ski> Cale : "write what is effectively a one-shot compiler which will produce the code for the system being programmed" -- this is why we need better support for staged programming (a la MetaML/MetaOCaml, e.g.) in Haskell :)
12:09:33 <ggVGc> but globally functions would be referentially transparent
12:09:38 <ggVGc> EvanR: right, exactly
12:09:46 * ski . o O ( <https://en.wikipedia.org/wiki/FFTW> )
12:09:53 <EvanR> ggVGc: ... im not sure how its better to replace recursion with mutation?
12:10:16 <EvanR> ggVGc: you mean pure
12:10:17 <Cale> ski: yeah, though in this case, you wouldn't want to just be producing more Haskell, you really want to emit something much lower level
12:10:55 <ski> ggVGc : "first class functions" -- is it ok to only be able to pass functions "down" into other functions, but not be able to extract/return them "up"/out of other functions ?
12:11:49 <ggVGc> ski: yes, that was te first restriction I decided on, since then I think I could have much easier memory management
12:11:51 <ski> ggVGc : other things to maybe consider : would you like hard real-time constraints ? soft ? how about guaranteed responsivity ?
12:12:13 <levi> It looks like DDC is still being developed, albeit not at a very rapid pace.
12:12:18 <ggVGc> ski: my main goal is to have a completely predictable cost model, rather than a fast one
12:13:10 <ski> ggVGc : instead of full recursion you could possibly have just tail-recursion. or also other recursion, but then with definite (max) depth, known in advance of starting the recursion ?
12:13:31 <levi> I think there's some work going on in the SML world regarding reasoning about cost models.
12:13:52 <EvanR> ggVGc: so first thing you drop is lists ;)
12:14:03 <ski> ggVGc : tail-recursion is more powerful than "limited local mutability within functions","instead of recursion you would do mutation"
12:14:04 <EvanR> only use bounded arrays or fixed size arrays
12:15:05 <EvanR> which i do in C, just without nice syntax
12:15:06 <ski> Cale : yes. ocamlp[45] can embed other languages (provided you define parsing for them) as snippets inside OCaml, with quasiquotations if you want them
12:15:23 <Cale> ski: ah, cool
12:15:52 <Zemyla> EvanR: How do you produce an array recursively in a pure language?
12:16:18 <EvanR> you construct them the same way as other data
12:16:32 <ski> ggVGc : ok
12:16:54 <EvanR> other abstract data
12:17:09 <ski> levi : any link/reference ?
12:19:20 <umib0zu> hey all. Is Null polymorphic? I’m using Null as a value in a ADT and it seems to break my functions when I call them using it.
12:19:33 <EvanR> :t Null
12:19:34 <lambdabot>     Not in scope: data constructor ‘Null’
12:19:34 <lambdabot>     Perhaps you meant one of these:
12:19:34 <lambdabot>       variable ‘null’ (imported from Data.List),
12:20:05 <EvanR> what is Null
12:21:03 <umib0zu> ah ok
12:21:08 <umib0zu> well that’s an issue
12:21:11 <Cale> What do you mean by "break"
12:21:11 <Cale> ?
12:21:34 <Cale> I think we'd have to see your definitions in order to make sense of the question
12:22:20 <umib0zu> http://imgur.com/G5efQYd
12:22:22 <umib0zu> Cale
12:22:40 <levi> ski: Let me see if I can find what I was thinking of...
12:22:45 <Cale> okay, so Null is just a new value which you defined above there
12:23:00 <Cale> If you put  :t Null  into GHC, it'll tell you its type
12:23:03 <umib0zu> Yeah. I thought Null was a value. Apparently it’s “null”
12:23:12 <Cale> null is a Prelude function
12:23:14 <umib0zu> well sorry. what I wanted was “null:
12:23:17 <Cale> Null is the name of the value you defined
12:23:21 <umib0zu> yes
12:23:35 <umib0zu> but in any case, I don’t understand why I get that exception
12:23:37 <Cale> null is the function which tests whether a list is empty
12:23:58 <Cale> That's because you redefined addUp and only handled the Null case
12:24:18 <Cale> When you use multiple lets like that, it doesn't continue the previous partial definition
12:24:29 <umib0zu> ah ok
12:24:29 <kaictl_work> umib0zu: i'd recommend using a simple .hs file for htings like that.
12:24:29 <Cale> It defines a new function which shadows the old one
12:24:42 <Cale> Yeah, you should definitely be putting all of this into a file and loading it
12:24:52 <Cale> :r will reload your file whenever you save
12:25:00 <kaictl_work> umib0zu: it'll make it look a lot nicer and will actually work.
12:25:08 <umib0zu> I felt like I was doing something silly. Is there a way to define partial definitions in the interactive terminal?
12:25:24 <umib0zu> I feel like the answer is no
12:25:28 <Cale> umib0zu: You can separate the cases with ;
12:25:35 <geekosaur> all on one line, with braces
12:25:52 <Cale> let addUp (Node n t1) = n + addUp t1; addUp Null = 0
12:25:55 <geekosaur> let foo A = ...; foo B = ...
12:26:07 <Cale> btw, your Tree isn't much of a Tree
12:26:07 <levi> ski: Looks like it's a research project led by Guy Blelloch and Robert Harper at CMU; here are some of Guy's slides summarizing things: http://www.cs.cmu.edu/~./blelloch/papers/lambdaInria.pdf
12:26:07 <geekosaur> braces actually optional for that form, other forms require them since you can't use layout
12:26:10 <Cale> it's more of a list...
12:26:11 <umib0zu> ah ok. I felt like I was doing something silly
12:26:34 <kaictl_work> umib0zu: you can use the `;` syntax. also try `:set +m`
12:27:19 <levi> ski: Lots of relevant papers here: http://www.cs.cmu.edu/~./blelloch/pubs.html
12:27:48 <ski> levi : thanks
12:28:43 <ski> Zemyla : in fact, recursively defining an array can be a nice way to do "top-down" dynamic programming :) you don't have to figure out in which (bottom-up) order to initialize the array, laziness handles this top-down, driven by demand
12:30:08 <Cale> Speaking of Guy Blelloch, does anyone know what the current state of Data Parallel Haskell is?
12:30:14 <levi> Apparently there's a GHC plugin for Repa that passes GHC core through the DDC optimization pipeline, then back to GHC Core for final compile.
12:30:22 <ski> Zemyla : typically, you define each element of the array by a function mapping the index to the corresponding element. and then that function itself recursively (apart from edge/base cases) refers to the array itself. in simple cases, you'd just write an expression `..i..' to compute the element, given the index `i', and use that to initialize the `i'th element of the array
12:30:27 <ski> Zemyla : consider
12:30:33 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
12:30:35 <lambdabot>  Defined.
12:32:35 <mfng> I tried to install "givegif" using "stack install givegif"
12:32:45 <ski> Zemyla : using this, you can say something like `arr = tabulate ((0,0),(15,999)) $ \(i,j) -> if j == 0 then ... else if i == 0 then ... else ..(arr ! (i1,j1))..', where the last subexpression defines `i1',`j1' (once, or several times), to index into other elements of the array
12:32:47 <lpaste> acertain pasted “newtype Ap f a = Ap (forall r. (f (a -> r) -> f r))” at http://lpaste.net/159568
12:32:48 <mfng> But it says "No .cabal file found.."
12:32:57 <ski> Zemyla : you just have to make sure to avoid cyclical data dependencies
12:33:01 <acertain> is this any useful? does it have a name?
12:33:37 <mfng> Does anyone know how I can install "givegif" without the .cabal file using stack?
12:34:18 <ski> (i did an example like that when doing inexact string matching with dynamic programming. using immutable recursively defined arrays in Haskell. worked fine)
12:34:29 <lpaste> acertain revised “newtype Ap f a = Ap (forall r. (f (a -> r) -> f r))”: “No title” at http://lpaste.net/159568
12:35:32 <ski> acertain : interesting
12:35:51 <ski> acertain : i don't know
12:36:31 <ski> edwardk might perhaps know a use, or be able to conjure one, acertain
12:37:38 <ski> acertain : question : is it possible to also make a monad out of it ? under what constraints on `f' ?
12:39:57 <ski> acertain : .. i'm wondering whether this differs from being a free applicative functor (over a given functor)
12:41:09 <ski> Zemyla : anyway, it might sometimes also be useful to define something like
12:41:20 <ski> @let memoArr :: Ix i => (i,i) -> (i -> e) -> (i -> e); memoArr ix f = (tabulate ix f !)
12:41:22 <lambdabot>  Defined.
12:41:24 <ski> or
12:42:16 <levi> Cale: It looks like the researchers involved in Data Parallel Haskell have been working on other approaches lately; I.e. Accelerate and Repa/DDC.
12:42:59 <ski> @let memoArrFix :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e); memoArrFix ix g = fix (memoArr ix . (g .))
12:43:00 <lambdabot>  .L.hs:162:38:
12:43:01 <lambdabot>      Couldn't match type ‘e’ with ‘i -> e’
12:43:01 <lambdabot>        ‘e’ is a rigid type variable bound by
12:43:31 <ski> @let memoArrFix :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e); memoArrFix ix g = fix (memoArr ix . g)  -- er
12:43:32 <lambdabot>  Defined.
12:44:09 <ski> > let fibo n = fib n where (memoArr (0,n) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-2) + fib (n-1) in fibo 12  -- this is a cute use of view patterns. i suspect it's accidental that this works
12:44:10 <lambdabot>  144
12:44:31 <ski> (`\case' would improve the look of this. not enabled in lambdabot, though)
12:45:46 <ski> > let fib n = (`fix` n) $ \(memoArr (0,n) -> fib) n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-2) + fib (n-1) in fib 12  -- alternative
12:45:55 <lambdabot>  144
12:46:45 <levi> Cale: Someone asked just that question on Reddit recently: https://www.reddit.com/r/haskell/comments/4b5xo4/about_the_status_of_data_parallel_haskell/
12:47:03 <ski> > let fib n = (memoArrFix (0,n) `flip` n) $ \fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-2) + fib (n-1) in fib 12  -- using `memoArrFix' instead
12:49:15 <acertain> i think it should right-associate (<*>)
12:49:26 <acertain> like Codensity
12:50:25 <acertain> i wonder if there's something that will left-associate (<*>)
12:53:27 <dpk-atk> hey, what do most people use for GUI programming
12:53:57 * hackagebot NetSNMP 0.3.2.1 - Bindings for net-snmp's C API for clients  https://hackage.haskell.org/package/NetSNMP-0.3.2.1 (PavloKerestey)
12:54:49 <sleblanc> How can I get info on a module in GHCI? e.g. what package exports some module
12:55:06 <sleblanc> assuming I can already import said module
12:55:47 <cocreature> sleblanc: :browse
12:55:47 <sleblanc> dpk-atk, I heard wxwidgets is pretty popular. And there is gtk2hs that provides Haskell bindings to the Gtk libs
12:56:43 <acertain> right-associating (<*>) is sometimes useful. e.g. https://github.com/emeryberger/PLDI-2016/blob/master/preprints/pldi16-paper317-preprint.pdf 
12:57:09 <acertain> edwardk, does http://lpaste.net/159568 belong in kan-extensions?
12:57:15 <EvanR> dpk-atk: a braindead socket to a (obj)C cocoa program
13:00:39 <sleblanc> cocreature, that's might useful, however I was looking for something that would tell me that Data.Map is a module inside the containers package, etc.
13:02:55 <dpk-atk> awesome thanks guys
13:03:59 <acertain> or maybe it left-associates (<*>)
13:04:06 <cocreature> sleblanc: hm not sure if there is anything for that. sometimes browse shows the package name inside of fully qualified types, but that’s pretty hacky and I’m also not sure under what conditions it shows them
13:06:04 <siwica> How do I define a type that can only take Int values from 1 to 30?
13:07:51 <lyxia> make a newtype, hide yo constructor
13:10:02 <siwica> I am quite new to Haskell. What would the constructor look like?
13:10:10 <EvanR> is there a haskell runtime visualization, like with cool 3d graphics? ;)
13:10:29 <lyxia> siwica: newtype FromOneToThirty = FromOneToThirty Int
13:12:23 <siwica> lyxia: and how do I make sure only 1..30 are allowed?
13:12:54 <EvanR> use Int and arrange for an error to occur as soon as you can if the value is not within 1 to 30, the earlier the better
13:13:06 <EvanR> at the use-site is almost as late as possible
13:13:15 <EvanR> on construction, via the smart constructor is pretty early
13:13:19 <EvanR> at compile time is the best
13:13:27 <EvanR> (or at IDE time)
13:13:34 <siwica> can I attatch this information directly to the type?
13:13:59 <EvanR> there are things you can do, but you should learn how to do smart constructors first
13:14:28 <siwica> EvanR: Ok, I will have a look
13:15:11 <siwica> Also I want to create a type Birthday, that only takes valid Day/Month/Year combinations
13:15:26 <EvanR> use the type Day from Data.Time for dates
13:15:47 <siwica> EvanR: Ok, sure. That's certainly an option
13:15:51 <verement> EvanR: ThreadScope?
13:15:54 <EvanR> :t fromGregorian
13:15:56 <lambdabot> Not in scope: ‘fromGregorian’
13:16:02 <EvanR> example of a smart constructor
13:16:10 <siwica> Just wondering how I would create such a type by myself
13:16:20 <siwica> ok
13:16:20 <EvanR> newtype Day = Day Integer
13:16:40 <EvanR> the implementation would be the day number of the date (relative to an epoch, which no one needs to know)
13:16:51 <EvanR> fromGregorian :: Integer -> Int -> Int -> Day
13:16:57 <ggVGc> can I rewrite this to not have the "fromMaube False"? https://gist.github.com/2554095404727132cbc29d35b79cafe7
13:17:01 <EvanR> would do the validation and conversion from some calendar numbers
13:17:11 <EvanR> ...
13:17:14 <EvanR> fromGregorian :: Integer -> Int -> Int -> Maybe Day
13:17:21 <EvanR> if you want to be safe
13:17:22 <siwica> EvanR: Just read about smart constructors. That's exactly what I was looking for
13:17:55 <EvanR> verement: interesting
13:19:16 <EvanR> verement: this scope runs alongside the program in real time?
13:20:40 <verement> EvanR: I think it analyzes event data after the fact, from log files
13:21:07 <EvanR> ah
13:21:13 <EvanR> so like profiler
13:21:18 <verement> right
13:22:24 <ski> acertain : hm, possible. dunno. ty for that paper link
13:22:58 <acertain> i tested it and it doesn't right-associate
13:25:05 <EvanR> verement: btw... 1) my friend rewrote his javascript based MOO and it has an awesome new interface... and "awesome" multiple inheritance with s3 linearization... 2) the "extensible records with scoped labels" looks like itd be pretty cool for a functional MOO (or FOO) with its overridable fields
13:25:58 <verement> what's this javascript MOO? I don't remember hearing about it
13:26:00 <athan> Anyone know where an instance for SafeCopy might be for HashMap...?
13:27:00 <EvanR> verement: its called room.js ... its a node based MOO thing and you program it with a web 2.0 page and i think now it supports git too
13:27:21 <EvanR> verb matching like lambdamoo
13:27:59 <verement> have a link?
13:28:05 <EvanR> yeah in PM
13:31:44 <ski> EvanR : "s3 linearization" ? any good reference for "extensible records with scoped labels" ? whence "scoped labels" (in this discussion) ?
13:31:59 <EvanR> http://research.microsoft.com/pubs/65409/scopedlabels.pdf
13:32:22 <EvanR> yes s3 linearization is a think i never heard of until now, its a thing python invented to deal with multiple inheritance hierarchies
13:33:28 <dito> Hi guys! If I'm using overloaded lists I get Couldn't match type `GHC.Exts.Item (t0 Int)' with `Int'. How do I specify that it's the type of good ol' list? (I'm using the overloading elsewhere so I'd rather keep it)
13:35:32 <geekosaur> sounds to me like you are using an Int where a(n overloaded) list was expected?
13:35:43 <jle`> you can use a function specific to lists, or use a type annotation
13:36:36 <dito> when i remove the lang extension everything type checks
13:36:52 <jle`> foo :: [Int]
13:37:30 <dito> is [] always the name of the list type (even when using the overloaded ext)?
13:37:43 <geekosaur> yes
13:38:02 <DanC> any suggestions on how to do birthday problem calculations with largish numbers? 1 - (d - 1 / d)^n(n-1)/2  where n is 2500 or so and d is 2^56 or so
13:38:12 <geekosaur> list *literals* get rewritten. explicitly typed things, or list non-literals, will be lists
13:38:42 <EvanR> > (1 % 365)^2500
13:38:43 <lambdabot>  1 % 539710840377158755020329179763346546766560519616517069305109680456098018...
13:39:03 <EvanR> oh ..
13:39:11 <EvanR> > (1 % (2^56))^2500
13:39:12 <lambdabot>  1 % 158267942808025420274804753726451026626370640787171904389783032046933787...
13:39:31 <monochrom> yeah, seems Rational is a good choice here.
13:39:44 <jle`> would it be a .... rational choice?
13:39:52 <monochrom> in case you eventually don't want Rational for whatever reason, look for CReal
13:40:02 <dito> badam ts
13:40:28 <DanC> how did I miss the ^ operator in the docs? where is it?
13:40:49 <EvanR> i was reading a slideshow by the Unum guy, and he mentioned the "kahan challenges" for number implementations, floats fail every test miserably... i was amazed to see the CReal passed them all 
13:40:51 <jle`> @hoogle (^)
13:40:52 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
13:40:52 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
13:40:52 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
13:40:59 <jle`> it should be in the docs for Prelude ?
13:41:20 <DanC> my exponent isn't integral. it's n(n-1)/2
13:41:41 <EvanR> so much for rationals...
13:41:47 <DanC> yeah.
13:41:51 <monochrom> but it's mathematically an integer. so change / to div
13:41:51 <EvanR> unless that comes out to be a whole number
13:42:04 <monochrom> either n or n-1 is divisible by 2
13:42:06 <jle`> luckily for you, n(n-1)/2 is always even for whole numbers
13:42:15 <DanC> oh. duh.
13:42:22 <jle`> s/even/a whole number
13:43:16 <monochrom> similarly n*(n-1)*(n-2) is divisible by 6
13:43:40 <monochrom> the joy of having taken a number theory course for at least 3 weeks
13:44:00 <EvanR> why is that divisible by 6
13:44:10 <monochrom> (I admit that the remaining 9 weeks are tough, quadratic reciprocity and what-not)
13:44:16 <DanC> one of the terms is divisible by 3 and another by 2
13:44:25 <EvanR> ah
13:44:27 <monochrom> divisible by 2 and divisible by 3, and 2 coprime with 3
13:44:44 <jle`> you can also use process of elimination for all modulo classes of n
13:44:45 <DanC> now it compiles but it doesn't work...
13:45:12 <acertain> liftAp f = Ap (\x -> (\a b -> b a) <$> f <*> x)  right-associates!
13:45:42 <DanC> losing: https://gist.github.com/dckc/68cee545341459a0a2d4af217267f3f5
13:45:55 <ggVGc> EvanR: what's a MOO?
13:46:00 <ggVGc> and a FOO?
13:46:14 <EvanR> i hope i made up FOO because thats a terrible name
13:46:17 <acertain> or maybe it reverses it?
13:46:47 <DanC> ah! maybe it does work
13:46:50 <DanC> the % is just hard to see
13:47:00 <geekosaur> ggVGc, https://en.wikipedia.org/wiki/MOO
13:47:09 <EvanR> ggVGc: http://www.cc.gatech.edu/classes/cs8113e_99_winter/lambda.html
13:47:51 <EvanR> warning windows NT references ahead
13:49:18 <DanC> with big numbers, it takes quite a while. I wonder if there's some way to get it to be lazy, since I just want about 3 significant digits in the end
13:49:38 <lpaste> acertain revised “newtype Ap f a = Ap (forall r. (f (a -> r) -> f r))”: “No title” at http://lpaste.net/159568
13:49:49 <EvanR> CReal with 3 as the number of digits
13:50:07 * DanC looks up CReal...
13:50:13 <EvanR> exact-real package
13:50:48 <EvanR> its not lazy but its better than alternative real numbers so far ;)
13:51:02 <acertain> updated the paste, have a look :)
13:51:26 <ggVGc> can we please remove programming from software development
13:51:35 <ggVGc> it's so tedious
13:51:45 <EvanR> learn UML!
13:52:12 <DanC> "The only functions not implemented are a handful from RealFloat which assume the number is implemented with a mantissa and exponent." er... but that's what I want, mostly: the exponent
13:52:23 <DanC> maybe I should take the log
13:52:26 <EvanR> huh
13:52:38 <EvanR> all the operations you named work
13:52:58 <EvanR> its referring to weird floating point-specific things
13:53:39 <EvanR> > 2**56 :: CReal
13:53:41 <lambdabot>  72057594037927936.0
13:53:59 * hackagebot rainbow 0.28.0.0 - Print text to terminal with colors and effects  https://hackage.haskell.org/package/rainbow-0.28.0.0 (OmariNorman)
13:54:17 <EvanR> > (1 + 1/2**56)^2500 :: CReal
13:54:21 <lambdabot>  mueval-core: Time limit exceeded
13:54:22 <EvanR> > (1 + 1/2**56)**2500 :: CReal
13:54:23 <lambdabot>  1.0000000000000346944695195367435006048676
13:54:25 <geekosaur> it's assuming the internal representation uses a mantissa and exponent like IEEE FP does
13:55:03 <DanC> how do I wish for the exact-real package using nix? somebody want to remind me?
13:55:41 <DanC> ooh! I got it right 1st guess
13:55:49 <DanC> $ nix-env -iA haskellPackages.exact-real -f '<nixpkgs>'
13:56:06 <DanC> darn; flycheck didn't notice.
13:56:18 <DanC> nor runhaskell
13:58:59 * hackagebot rainbox 0.18.0.8 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.18.0.8 (OmariNorman)
14:04:24 <Peaker> Is there a ghc flag to convert unsafe indexing (Vector.Mutable.unsafe*) to the safe counterparts? There really should be!
14:04:52 <Peaker> when hitting a repeating seg fault, it'd be nice to re-enable all the safety measures
14:05:38 <EvanR> Peaker: alternatively, a flag to convert all safe operations to unsafe for performance
14:05:48 <EvanR> after you ensure they dont need checks
14:06:34 <Peaker> People may rely on the safe operations for their security/coherence/etc.  You have to opt in to this unsafety, but it should still be overridable
14:06:55 <ski> EvanR : ty for link. "slideshow by the Unum guy" ? "kahan challenges" ?
14:07:15 <EvanR> you could opt-in for "super safety" where the performance flag doesnt count ;)
14:07:24 <EvanR> rainbox tutorial brings up an interesting point... when you dont want to accept infinite lists... youre SOL.... or you can insist on users messing with Data.Sequences instead. i wonder if theres an even better way
14:08:05 <EvanR> ski: http://www.slideshare.net/insideHPC/unum-computing-an-energy-efficient-and-massively-parallel-approach-to-valid-numerics slide 21
14:12:10 <ski> ok
14:12:29 * Peaker was puzzled for a bit, hitting seg faults in pure Haskell code :)
14:12:43 <Peaker> (I had long forgotten about the unsafeWrites I had lying around)
14:15:11 <EvanR> ski: gustafson is supposedly a super computing guy, but i cant find too much information on implementing unums. all materials are similar to that slideshow
14:16:46 <EvanR> hmm https://github.com/jrmuizel/pyunum
14:17:44 <DanC> what language flags does lambdabot use? when I try to use (CReal 5), I get Illegal type: ‘5’ Perhaps you intended to use DataKinds
14:18:17 <shachaf> (CReal 5) isn't a valid type anyway.
14:18:29 <shachaf> CRal takes no type arguments.
14:19:09 <DanC> the examples on https://github.com/expipiplus1/exact-real show (CReal 0) and such
14:19:09 <EvanR> CReal does take a type argument
14:19:21 <EvanR> im curious why lambdabot's CReal doesnt
14:19:27 <EvanR> maybe old version
14:19:45 <EvanR> DanC: you need DataKinds
14:19:48 <DanC> creal and exact-real are evidently different packages too
14:19:55 <shachaf> Oh, that's not the usual CReal.
14:20:01 <EvanR> oh
14:20:18 <shachaf> I was thinking of augustss's https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-CReal.html
14:21:43 <EvanR> on the subject of comparing two CReals being impossible (undecidable in general) I did find a paper while researching this which claims to have gotten around it using "redundant if"
14:21:49 * EvanR looks for that links
14:22:07 <DanC> that's a bold claim.
14:22:58 <EvanR> the link on google goes to what looks like a gzipped postscript file that i cant open
14:23:09 <EvanR> and the cached version has unreadably formatted math
14:24:00 * hackagebot mohws 0.2.1.4 - Modular Haskell Web Server  https://hackage.haskell.org/package/mohws-0.2.1.4 (HenningThielemann)
14:24:32 <shachaf> DanC: If you want that kind of CReal you need DataKinds, like GHC says.
14:25:15 <DanC> I'm not sure I want that kind, but I'm giving it a whirl based on EvanR's suggestion
14:25:47 <DanC> next challenge: how to turn (d - 1) / d into a CReal when d :: Integer
14:26:13 <EvanR> fromIntegral d
14:26:52 <EvanR> or fromInteger
14:27:05 <DanC> With 2500 events and a hash space of 56 bits,
14:27:05 <DanC> odds of a collision are 0.00.
14:27:11 <DanC> I think I want the log
14:27:30 <ski> EvanR, ok
14:27:31 <EvanR> yeah
14:27:53 <EvanR> put a log on it
14:28:32 <DanC> With 2500 events and a hash space of 56 bits,
14:28:32 <DanC> odds of a collision are e^-23.88.
14:28:59 <EvanR> if thats numbers right, its awesome that exact-real came in handy ;)
14:29:21 <DanC> lemme plug the classic numbers back in...
14:30:06 <DanC> With 23 events and a hash space of 365
14:30:06 <DanC> odds of a collision are e^-0.69.
14:30:37 <DanC> odds are supposed to be around 50%
14:31:18 <DanC> 0.501576..., says wolfram alpha
14:31:29 <DanC> for e^-0.69
14:31:30 <EvanR> hmm. what happens if you use more digits
14:31:52 <EvanR> jophish: ^
14:32:06 <DanC> e^-0.695 with 7 digits
14:32:27 <DanC> 0.499074...
14:34:09 <EvanR> supposedly, with n digits of precision the result is supposed to be within 2^-n of the exact answer
14:34:29 <DanC> I haven't seen any reason to doubt that
14:34:41 <EvanR> ah thats 127
14:34:46 <EvanR> 1/128
14:35:40 <EvanR> > '%' : show (100*(0.501576 - 0.499074)/0.501576)
14:35:41 <lambdabot>  "%0.4988276951050298"
14:36:58 <ski> Peaker : some late responses following
14:37:03 <ski> Peaker : i'd assume that `ClosedST a' was iso to `forall s. ST s a' (not to `exists s. ST s a', which the Haskell-like syntax seemed to suggest)
14:37:08 <ski> Peaker : i'm still not sure why you need to distinguish between rows and columns in the kinds ..
14:37:23 <ski> Peaker : "\"Nominal types\" ... are allowed to have (top-level) foralls" -- do you mean in the sense of `forall a.  ClosedST a = ..a..', or perhaps you mean `ClosedST :: * -> *', or even `ClosedST :: forall a. ..a..' ? (`ClosedST' just being a random example "Nominal type", possibly not fitting here)
14:37:28 <ski> Peaker : .. or perhaps it's the `forall' in `ClosedST a = forall s. ..s..' you mean ?
14:37:31 <ski> Peaker : i'm still not following how `{From|To}Nominal' work
14:37:37 <ski> Peaker : i think i follow the "skolem scope sets" idea, and sortof the "skolem scope identifiers" as well. ("MRA" ?)
14:37:48 <Peaker> ski: I may have placed the "forall" in wrong place in the Haskell syntax for ClosedST. It is indeed universal, not existential
14:37:59 <ski> Peaker : (i said) "how are skolems introduced/created, at the level of the type checker ?". "there could be many ways (e.g: explicit foralls), but we chose to restrict it (for now).", perhaps you mean something like `forallType :: (Skolem -> M o) -> M o' (sufficiently obfuscated to fit your system) ?
14:38:04 <ski> Peaker : an alternative would of course be `mkSkolem :: M Skolem', but then you don't have an explicit scope in that operation (not sure which would be preferred here)
14:38:16 <Peaker> ski: Rows/columns are only distinguished via a phantom type parameter -- for extra safety. You can be generic to both
14:38:27 <ski> (or rather, oldish, unposted responses, rather than late. late transmission)
14:39:12 <ski> Peaker : phantom type parameter to what ?
14:39:27 * ski reads the above responses, to try to recall what they were about
14:40:06 <ggVGc> I have literally 0understanding of forall in haskell
14:40:06 <Peaker> ski: https://github.com/Peaker/AlgoWMutable/blob/master/Lamdu/Expr/Type.hs#L51-L54 <-- the "c" is a phantom type saying whether it is a product or a sum
14:40:11 <ggVGc> I just glance over it when I see it
14:40:22 <DanC> I'd rather have the log base 2 than base e
14:40:58 <Peaker> ski: nominal types are like Haskell newtypes -- including Haskell's "forall" support within newtypes when you enable "RankNTypes". Lamdu has no rankNtypes anywhere else (at least yet)
14:41:41 <Peaker> ski: and "fromNom NominalId" is like Haskell's newtype getter (field name) and "toNom NominalId" is like Haskell's newtype constructor. The former instantiates a type-scheme, the latter creates skolems
14:41:49 * EvanR hands DanC the log of 2
14:42:06 <DanC> logBase 2 x -- I hope this works
14:42:27 <EvanR> its just division
14:42:50 <Peaker> ski: The only introduction of skolems in Lamdu is in "ToNom" -- so a skolem scope tree exists -- each node in the tree is a "ToNom" (parent/child relationships follow the subexpr. relationships).  when unifying meta-variables, each has ptr to the tree position. To "intersect" the meta-var skolem scopes, you just need to find the most-recent-ancestor of both in the scope tree
14:43:41 <Peaker> ski: mra=most-recent-ancestor
14:44:19 <Peaker> ski: I guess "LCA = lowest-common-ancestor" is a better term there :)
14:45:17 <Peaker> btw: We used Lamdu to pass Google's code-jam qualification round :)
14:50:29 <ski> Peaker : perhaps you could use `DataKinds' for `c' instead of `IsCompositeTag' ?
14:50:51 <Peaker> ski: I need it to not be erased
14:51:09 <EvanR> i need to check out lamdu
14:51:14 <EvanR> is this an emacs thing or 
14:51:43 <ski> Peaker : "including Haskell's \"forall\" support within newtypes when you enable \"RankNTypes\"" -- that's called `PolymorphicComponents' :)
14:51:51 <ski> (well, both for `newtype' and `data')
14:52:13 <Peaker> EvanR: it's very preliminary (though improving fast), but it's meant to get rid of text and old text toolchains like emacs.
14:52:27 <Peaker> ski: ah, so we only have newtype+PolymorphicComponents :)
14:52:46 <ski> Peaker : "Google's code-jam qualification round" being ?
14:53:06 <Peaker> ski: it does use a lifted data-kind: CompositeTag. The type-class constraint lets me match on the GADT, which introduces a "c" type-variable into my scope, and then I can do runtime case analysis on the "c" (without the class, it's erased and I can't)
14:53:32 <TheSuperGeek> Hello
14:53:41 <Peaker> ski: Google has an annual competition called "Code Jam" -- qualification round is the first step of the competition. You have to answer programming questions in a given time frame
14:53:46 <ski> Peaker : hm, so `IsCompositeTag :: CompositeTag -> Constraint' ?
14:54:04 <Peaker> ski: ya
14:54:12 * hackagebot hw-bits 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.1 (newhoggy)
14:55:53 <TheSuperGeek> Is haskell good for making scripts ?
14:56:17 <Jinxit> not my language of choice for scripts
14:57:04 <ski> Peaker : oh, something along the lines of `class IsCompositeTag (c :: CompositeTag) where caseCompositeTag :: (f RecordT -> o) -> (f SumT -> o) -> (f c -> o)', maybe ?
14:57:19 <TheSuperGeek> I'm a bit lost with it... i'm searching a cross platform simple script langage
14:57:32 <Peaker> TheSuperGeek: https://hackage.haskell.org/package/turtle-1.2.6/docs/Turtle-Tutorial.html <-- makes Haskell nicer for scripts
14:57:35 <Jinxit> I think I've seen both but I don't know enough to say more than that really
14:57:37 <Jinxit> w/c
14:58:22 <Peaker> ski: that works, I used: https://github.com/Peaker/AlgoWMutable/blob/master/Lamdu/Expr/Type/Tag.hs#L22-L24 & https://github.com/Peaker/AlgoWMutable/blob/master/Lamdu/Expr/Type/Tag.hs#L30-L31
14:58:48 <ski> Peaker : i suppose instead of a class, you could use `data SingCompositeTag :: CompositeTag -> * where SRecordT :: SingCompositeTag RecordT; SSumT :: SingCompositeTag SumT', and then match on `SingCompositeTag c' to recover `c' ?
14:59:12 * hackagebot hw-bits 0.0.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.2 (newhoggy)
14:59:30 <ski> (`Sing' for "singleton", as in singleton types (`SingCompositeTag c' has a single (total) value, for every `c'. it's "reflecting" the data kind as a data type)
14:59:34 <Peaker> ski: hmm.. yeah, that's equivalent to holding the compositeTagRefl from the instance instead of the instance
14:59:52 <TheSuperGeek> ok thanks Peaker ! Good night all !
15:00:11 <Peaker> ski: and might be simpler! Might do that, thanks for the idea :)
15:01:26 <ski> Peaker : oh, hm. isn't in fact your `CompositeTagEquality' exactly my `SingCompositeTag' ?
15:02:20 <ski> Peaker : oh, though the actual tags were `RecordC',`SumC', not `RecordT',`SumT' (i was just taking a guess for their names, looking briefly around at the source of that previous module)
15:02:50 <Peaker> ski: yes, but I can cut the type-class middleman, maybe. the class has advantages though
15:03:23 <ski> Peaker> :k AST
15:03:40 <ski> Peaker : perhaps less noise with the class, yes
15:04:35 <ski> (actually, i suppose you'd rename `f' in my signature above to `proxy', for convention)
15:05:34 <ski> (also, a more general version could be `(proxy RecordC -> p RecordC) -> (proxy SumC -> p SumC) -> (proxy c -> p c)')
15:06:36 <ski> Peaker : anyway, not sure whether it was clear. what i suggested was then adding an explicit `SingCompositeTag c' argument type to the data constructor (instead of the class constraint)
15:06:47 <Peaker> ski: yep, that's what I understood
15:06:57 <ski> but seeing as the class constraint basically includes that anyway ..
15:07:07 <ski> .. it's more a question about convenience
15:07:07 <Peaker> ski: I didn't actually consider it, despite it being obvious in retrospect (just replace class constraint with class method)
15:13:07 <obadz> geekosaur: what's typecase?
15:15:59 <Lokathor> when i use haddock, it generates links to library types as if i had that documentation locally, but i want it to link to the hackage types, or better yet the stackage pages
15:16:22 <Lokathor> is there some weird flag i can use to make it link to a given lts version? or to hackage's latest version or whatever?
15:30:48 <glguy_> Lokathor: You can tell haddock where to make the links relative to, I do that here: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh#L45
15:33:23 <Lokathor> hmm
15:35:12 <Lokathor> how to get that to work with haddock via stack seems not entirely obvious >_<
15:35:20 <Lokathor> but I'll look into this
15:35:45 <Lokathor> as long as the answer is "yes it is possible" i can get back to it later
15:38:55 <Lokathor> "Note: Types in this module provide Read and Show instances, but the exact formatting used depends on if things were compiled in 32 or 64 bit mode. You can't read back a string generated by the other version's show instance."
15:38:59 <scshunt> who maintains hackage?
15:39:01 <Lokathor> unfortunate, but true
15:39:52 <scshunt> trnasformers is till broken
15:46:30 <scshunt> also
15:46:43 <scshunt> is there a standard way to invoke a state monad that you know requires no initial seeding of its state?
15:46:51 <scshunt> do you provide undefined as the initial state?
15:47:09 <Lokathor> that sounds... like a weird thing to have.
15:47:24 <Lokathor> but i guess if you know it's going to throw away the seed state, undefined works
15:47:54 <Axman6> runState foo (error "I lied, I actually use this")
15:50:53 <thoughtpolice> scshunt: I don't know what you mean by "broken". Can you be more clear?
15:58:24 <Cale> thoughtpolice: I'm going to bet that he's referring to the documentation links
15:58:52 <thoughtpolice> That's what I imagine. The builder may just be backlogged or stuck.
15:59:14 <Cale> Yeah, I'm guessing that the new version is up in preparation for GHC 8?
15:59:43 <Cale> er, the base bound didn't change
16:00:07 <thoughtpolice> Jeez, stuck since February. transformers-0.5.2.0 might have just gotten silently bumped out of the queue or something maybe, when we were fiddling around.
16:00:18 <thoughtpolice> I imagine with that long of a delta, the latter is the likely reason.
16:00:32 <thoughtpolice> Or something bizarro, in general.
16:00:36 <Cale> btw, it would be really nice if when you searched for a package name, if there was an exact match for your search string, it went to the top
16:02:53 <athan> So IxSet is specifically for items that match subcomponents _exactly_, correct?
16:03:06 <athan> I couldn't make an instance of Indexable for _general_ matching, can I?
16:03:35 <athan> because `ixFun` returns specifically the subcomponents verbatim, not something like a range of them
16:03:52 <thoughtpolice> Cale: Yeah, I've noticed this too. Right now I think the search is driven purely by full-text-search, which should support something like this.
16:32:36 <athan> Anyone here know of a data structure that is like a Map, but in `n` dimensions / keys, and such that I might request arbitrary spans?
16:33:15 <athan> and where all dimensions are optional, s.t. inserting without _any_ dimensions doesn't insert the data
16:33:28 <athan> maybe even where the dimensions are flexible, too, not static :s
16:34:24 <athan> yeah this one is going to throw a wrench in the mix :x
16:37:55 <ggVGc> what's the general solution to this? https://gist.github.com/077462292b86ec80b11280fc1a09fe30
16:39:44 <athan> ggVGc: The only thing I could think of is an arrow, maybe &&&?
16:39:46 <athan> :t (&&&)
16:39:47 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:39:50 <athan> shoot
16:39:53 <athan> or fan or something :s
16:40:05 <glguy_> ggVGc: If this is part of the lens translation stuff you were doing earlier, and you had a value "triggerEntries :: Traversal' TrigSeqEntry TriggerEntry" , then this would be "toListOf triggerEntries"
16:40:13 <ggVGc> I was hoping there would be something with Either
16:40:14 <athan> basically something that does `(a -> c) -> (b -> c) -> a || b -> c
16:40:27 <athan> :t either
16:40:29 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
16:40:31 <athan> :)
16:40:42 <ggVGc> glguy_: nah, it's just me trying to add a new type of sequence while not reimplementing a lot of duplicated logic
16:41:13 <athan> so something like `either ((:[]) . unThingy1) (id . unThingy2) stuff` or something :s
16:41:21 <ggVGc> I guess I was wondering if ther was a family of functions dealing with `Either a [a]`
16:41:55 <ggVGc> glguy_: however making a traversal for this might make a lot of sense..
16:42:20 <ggVGc> I'm not even sure I picked the correct data layout for this
16:45:21 <obadz> athan: what's unThingy1/2 in your example?
16:45:54 <obadz> athan: would have thought it would be either (: []) id . eitherFromThingy
16:53:07 <fr33domlover> Is there a function which takes (a -> m b) and returns (f a -> m (f b)) where m is a monad and f is a functor?
16:53:16 <fr33domlover> it's like fmap, but not exactly :P
16:53:26 <fr33domlover> in my use case, m is IO and f is Maybe
16:54:02 <Lokathor> I bet you could make such a function :3
16:54:03 <xa0> Sequence.fmap? :p
16:54:08 <obadz> :t traverse -- ^ fr33domlover 
16:54:09 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:54:30 <xa0> Fancy
16:54:32 <fr33domlover> obadz, thanks :)
16:54:32 <monochrom> in which f is your m, t is your f
16:54:58 <fr33domlover> also,
16:55:01 <fr33domlover> :t for
16:55:02 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
16:56:23 <obadz> :t flip traverse
16:56:24 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
16:56:26 <monochrom> yeah, "for" is "traverse" with the other parameter order for convenience. imagine: for [1,2,3] (\x -> getURL (show x)). reads slickly
17:00:23 <Lokathor> forLoop :: Monad m => m Bool -> m body -> m after -> m () -- and this would be more like a C-style for, if you expect that such a thing.
17:00:47 <Lokathor> but I'm not sure if that's already in any library
17:02:35 <monochrom> there is some library on hackage containing this
17:02:49 <monochrom> the problem is it has little practical use
17:03:04 <Lokathor> i figure it's somewhere
17:03:40 <Lokathor> and yes, not much practical use other than "if you want to closely emulate code that started in another language you might care for this"
17:03:43 <obadz> I assume body ~ () and after ~ ()
17:04:33 <Lokathor> well, the results would be discarded either way, regardless of if they're actually voided or not
17:08:42 <fr33domlover> Lokathor, i don't need forLoop but just fyi, the monad-loops package has a variety of monadic loops
17:09:15 <fr33domlover> sometimes useful
17:09:30 <Lokathor> oh I expect so
17:09:43 <Lokathor> mostly I just jotted that one down once as an oddity
17:17:58 <ski> Peaker : ok (re Code Jam). "Rows/columns are only distinguished via a phantom type parameter -- for extra safety. You can be generic to both" -- i'm hoping this means that i can use a single row/column ("composite" ?) variable, in a single type expression, both to form a sum type, and to form a product type, in that type expression
17:22:16 <gfixler> why do we have (^) and (**)?
17:22:25 * gfixler is terrible at math
17:22:26 <ski> Peaker : "and might be simpler!" referring to just using a `CompositeTagEquality c' argument type ? or perhaps to use `RecordT'/`SumT' as indices of `CompositeTagEquality' (and perhaps arguments of `IsCompositeTag') instead of `RecordC'/`SumC' ? (note that i didn't intend to suggest the latter)
17:22:31 <athan> obadz: That works too!
17:23:07 <enthropy> gfixler: there's ^^ too
17:23:09 <athan> the `either a b . thingiesToEither` ~ `either (a . thingyAToLeft) (b . thingyBToRight)`
17:23:15 <ski> gfixler : `^' is for raising a number to a natural number exponent. `^^' allows the exponent to be negative, but requires `reciprocal'/`/' on the base
17:23:17 <gfixler> enthropy: *gasp*
17:23:28 <athan> specifically, the thingy homomorphism
17:23:53 <ski> gfixler : `**' is for when the type of the base and the exponent is equal. typically allowing rational and (usually approximations to) irrational exponents
17:24:06 <ski> > 2 ^ (-3)
17:24:07 <lambdabot>  *Exception: Negative exponent
17:24:08 <ski> > 2 ^^ (-3)
17:24:10 <lambdabot>  0.125
17:24:32 <ski> > 2 ** reciprocal 2
17:24:33 <lambdabot>  Not in scope: ‘reciprocal’
17:24:36 <ski> er
17:24:39 <ski> > 2 ** recip 2
17:24:40 <lambdabot>  1.4142135623730951
17:24:44 <ski> > 2 ^^ recip 2
17:24:46 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^^’
17:24:46 <lambdabot>      from the context (Fractional a)
17:24:46 <lambdabot>        bound by the inferred type of it :: Fractional a => a
17:24:50 <gfixler> interesting
17:25:20 <ski> `^', and also `^^' could e.g. be used on square matrices
17:25:34 <ski> `**' probably couldn't, in any sensible way
17:25:57 <ski> there's also an `exp' for square matrices, btw
17:26:01 <ski> > exp 1
17:26:02 <lambdabot>  2.718281828459045
17:26:12 <enthropy> ski: you could do some decomposition where you have the eigenvalues, then do the usual ** on them
17:26:36 <ski> enthropy : hmm .. does that work out correctly ?
17:27:25 <ski> > recip 8
17:27:26 <lambdabot>  0.125
17:28:16 <ski> hm, considering `A ** B', we could decompose `B' into `T * B * T^-1', with `B' being diagonal
17:29:11 <ski> so `A^B  =  A^(T * B * T^-1)' .. and then ? is it sensible to say `A^(T * B * T^-1)  =  ((A ^ T) ^ B) ^ (T^-1)' ?
17:29:13 <enthropy> ski: I wasn't thinking about the B being a matrix too
17:29:24 <ski> ok
17:29:31 <ski> well, i thought that's what you meant
17:29:49 <ski> (otherwise, it's just `^' and `^^' above, where the base is a (square) matrix)
17:29:49 <enthropy> which would lead you to the ^^ I think you're thinking about
17:30:37 <obadz> athan: that can't be, because the function on the right of ~ takes an Either, while that on the left takes a Thingy
17:30:41 <ski> (er, rename the latter (diagonal) `B' into `C', say. obviously it's (in general) different from the former `B')
17:31:27 <obadz> athan: I think you'd need the catamorphism of thingies, which would of course be such that `thingy Left Right = thingiesToEither`
17:31:47 <ski> hmm
17:32:01 <obadz> athan: then `either a b . thingy Left Right` ~ `thingy a b`
17:32:27 <obadz> athan: in other words, what's the type signature of thingyAToLeft ?
17:33:04 <ski> perhaps we could define `a ** b' as `exp (log a * b)' or something like that (maybe `exp (b * log a)' (`*' there is not commutative), or some more complex variant ?) ?
17:35:03 <ski> (`exp a' being defined as the limit `1 + a + a^2 / 2 + a^3 / 3! + ...' which at least works in case the matrix `a' is nilpotent (iow, there is some natural number `n' such that `a^n = 0', the zero matrix))
17:36:21 * ski idly wonders how one would implement a (right-)inverse `log' to this `exp'
17:37:10 <enthropy> .g nineteen dubious ways to compute the matrix exponential
17:37:24 <ski> @google nineteen dubious ways to compute the matrix exponential
17:37:26 <lambdabot> http://epubs.siam.org/doi/pdf/10.1137/S00361445024180
17:37:26 <lambdabot> Title: SIAM Review - 45(1):3 - PDF (Society for Industrial and Applied Mathematics)
17:38:34 * enthropy doesn't recall details, but probably some of those methods (or a follow-up paper by the same author a couple decades after the first) might apply to calculating the log
17:47:16 <ski> ty for the suggestion
18:36:33 <average> why doesn't ocaml have as much users as haskell ?
18:37:02 <Lokathor> something something haskell rules ocaml drools
18:48:14 <lambda-11235> average: One thing for me is lack of higher kinded types (as far as I'm aware).
18:49:45 <average> lambda-11235: but they have that afaik
18:49:57 <average> lambda-11235: how high are haskell's type in comparison ?
18:51:45 <lambda-11235> average: How would you write `data State s m a = s -> m (s, a)`? Or `type Foo f a b = f b a`?
18:54:30 <EvanR> average: i like purity and only one + operator
18:54:59 <EvanR> and laziness
19:11:13 <dolio> Haskell has better marketing.
19:11:23 <scshunt> than?
19:11:28 <dolio> OCaml.
19:11:39 <scshunt> oh
19:11:40 <dolio> Haskell had Don Stewart.
19:11:52 <dolio> OCaml just had Jon Harrop trolling Lisp newsgroups.
19:12:00 <EvanR> i remember only hearing about ocaml for a long time in the 2000s
19:12:25 <EvanR> i thought it was the shit from marketing alone, but never got into it
19:13:30 <EvanR> in an alternative universe where the nazi's won, ocaml would be popular and haskell forgotten
19:14:25 <dolio> That's the best way to say it, yes.
19:26:27 <aniqah> Quick question! In the abstract for one of the LambdaConf talks, it says "a monad is just a monoid in the category of endofunctors". Is this true, or a joke?
19:26:36 <scshunt> it is both
19:27:24 * Clint nods.
19:27:31 <aniqah> scshunt: So if I embark on a quest to understand that sentence, I won't be wasting my time? :)
19:28:46 <scshunt> aniqah: nope!
19:28:49 <aarvar> aniqah: you might try asking that in #philosophy
19:29:15 <aniqah> aarvar: Hahaha, thanks for the advice
19:29:36 * hackagebot automotive-cse 0.0.1.1 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.0.1.1 (KeiHibino)
19:32:34 <average> lol
20:15:10 <nitrix> average: --> | average (~average@188.26.134.4) has joined #haskell
20:15:17 <nitrix> average: You should use SASL, you're leaking your IP.
20:19:38 * Sornaensis leaks IP fluids all over nitrix
20:20:53 <nitrix> I'm just saying. It doesn't seem intentional since the cloak kicks in after he's authenticated with services.
20:21:32 <nitrix> And if he didn't care, he wouldn't have a cloak.
20:22:22 <average> nitrix: and ?
20:24:26 <average> hm, I'll try again
20:27:26 <average> nitrix: http://wdtz.org/freenode-sasl-upgrade-irssi-howto.html
20:27:27 <average> lol
20:27:41 <average> I don't have time for that..
20:27:51 <average> nitrix: it's too long man
20:27:56 <average> I want to use my life to do things
20:28:09 <average> am I going to waste it configuring my IRC client ?
20:28:16 <nitrix> That's your choice. See #freenode if you need help.
20:28:32 <average> nitrix: no but like.. I'm just complaining about this
20:28:37 <average> because I can
20:28:52 <nitrix> Complaining here in #haskell isn't productive.
20:29:03 <average> nitrix: wait, you brought it up motherf***er
20:29:09 <average> so.. why are you complaining now ?
20:29:25 <average> stop complaining
20:29:37 <thimoteus> yeesh
20:29:52 <nitrix> A bit of decorum please. I didn't call you any names; I tried to be helpful.
20:30:02 <average> nitrix: or here.. fine, let's talk in #freenode
20:30:24 <average> oh yeah, can't write in #freenode..
20:30:26 <average> no idea why
20:32:18 <Clint> ...
20:32:31 <average> nitrix: still did you see how complex that thing is ? http://wdtz.org/freenode-sasl-upgrade-irssi-howto.html
20:33:22 <average> nitrix: and guess what, it will probably change in 1 year or two
20:33:32 <MitchW> nitrix: nice link, I never knew about that :)  I certainly found it helpful, going to setup my client tonight!
20:34:02 <average> SASL will be sunset, and something else will come along
20:34:25 <average> way to go MitchW 
20:34:34 <average> MitchW: you will be so secure
20:34:41 <average> I envy you (not really)
20:35:26 * nitrix peers at average.
20:35:29 <nshepperd> average: uh... nitrix assumed that you wanted to conceal your location/identity (which is the normal reason to get an irc cloak), and noted that it wasn't working because you don't use SASL
20:35:48 <dolio> That's enough non-Haskell conversation for now, I think.
20:35:54 <tippenein> Anyone familiar with `hip` image library? I'm trying to figure out a way to read in an image from a lazy bytestring
20:37:03 <average> nshepperd: I know and that's fine
20:37:16 <average> https://github.com/nitrix/dotfiles/blob/master/copy/weechat/irc.conf#L114
20:37:27 <average> his config seems easy to use
20:37:39 <average> no idea how to do that easily with irssi
20:37:44 <nshepperd> average: well, if you don't care about it then let's drop it
20:37:58 <Sgeo> So, is a variant of 'reflection' where `proxy t` does need to contain a t, but if two `proxy t` types are the same it's the same t, still useful?
20:38:12 <average> basically, I don't mind having that, it's just that, if it gets long, it gets in the way
20:38:15 * Sgeo is asking because doing that in Rust is _far easier_ than doing the real thing
20:46:21 <average> hm
21:17:58 <ZelteHonor> Doas anyone know if netwire is still alive? This FRP library saw a lot of activity but there is nothing for months now.
21:18:37 <ryantrinkle> ZelteHonor: I'm not sure
21:18:42 <ryantrinkle> what kind of thing are you working on?
21:19:24 <ZelteHonor> I am not working on anything. Just looking around for some interesting thing.
21:19:39 * hackagebot dns 2.0.2 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.2 (KazuYamamoto)
21:20:01 <ryantrinkle> ZelteHonor: have you looked at reflex? (my frp lib :))
21:20:06 <ZelteHonor> Well I wrote a game in Java, for school and I would like to rewrite it in Haskell with frp.
21:21:35 <ZelteHonor> I looked quickly at reflex. Just the main stackage page. The 0.4.0 version scared me a bit. I am never sure if I should use library wich are below te smbolic 1.0 version.
21:22:12 <ryantrinkle> ZelteHonor: I wouldn't recommend taking that too seriously: reflex was in production use privately before we even released 0.1 publicly
21:22:32 <ZelteHonor> Might be interesting then.
21:22:47 <ryantrinkle> if you're new to haskell, you may be surprised by a lot of very low version numbers
21:22:57 <ZelteHonor> This is true.
21:22:58 <ryantrinkle> however, it's often a bit misleading
21:23:17 <ZelteHonor> I am often looking at something interesting but get away because its below 1.0
21:23:20 <ryantrinkle> in semantic versioning, its MAJOR.MINOR
21:23:31 <ryantrinkle> but in haskell it's typically MAJOR.MAJOR.MINOR
21:23:42 <ryantrinkle> so if something's 0.0.*, then it may make sense to stay away
21:24:00 <ZelteHonor> I see.
21:24:00 <ryantrinkle> but a lot of libraries treat the first digit as a "complete redesign" counter
21:24:09 <ryantrinkle> rather than just a regular "major version"
21:24:14 <ryantrinkle> it's just a quirk of the community :)
21:24:40 * hackagebot fast-logger 2.4.3 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.3 (KazuYamamoto)
21:24:49 <ZelteHonor> How I see it is: (Retrocompatible breaking change).(New feature).(bugfixe)
21:25:31 <ZelteHonor> But my game is "real time". I was reading that netwire was really good with application that can be represent as frame.
21:26:19 <ryantrinkle> yes, what you're describing in typical semantic versioning
21:26:26 <ryantrinkle> however, in haskell, there's just an extra digit on front
21:26:30 <ryantrinkle> which often remains 0 forever
21:26:54 <ryantrinkle> ZelteHonor: I think FRP in general is quite good with that kind of thing
21:27:59 <ZelteHonor> I thinks it's on the Haskell wiki. It's basicelly written that if you are building gui reactive-banana is best and if you are building frame-base application netwire is best.
21:28:23 <ryantrinkle> ZelteHonor: do you have a link to that?
21:28:38 <ZelteHonor> Let just me check.
21:28:46 <ryantrinkle> (just curious :))
21:29:39 <ZelteHonor> Oh. It's on netwire page itself. https://wiki.haskell.org/Netwire
21:29:40 * hackagebot AFSM 0.1.2.0 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.2.0 (hanzhxu)
21:29:50 <ZelteHonor> So it does not said that netwire is best for frame.
21:30:16 <ZelteHonor> It's said that if you are building a GUI you should use reactive-banana instead of netwire.
21:30:34 <ryantrinkle> makes sense
21:30:49 <ryantrinkle> well, if i remember correctly, netwire has the concept of a frame built in
21:31:03 <ryantrinkle> specifically, it lets you measure the passage of time from anywhere in the program
21:31:22 <ryantrinkle> now, this seems convenient, however, i think it's a bit less powerful in the end
21:31:26 <ZelteHonor> I think so. You have wire. And you can "step" wire.
21:31:31 <ryantrinkle> right
21:31:43 <ryantrinkle> that works alright, but consider this situation:
21:31:47 <ryantrinkle> you want to pause your game
21:31:51 <ryantrinkle> BUT
21:32:00 <ryantrinkle> you want your pause screen to have an animation on it
21:32:39 <ryantrinkle> if you keep stepping the "frames" of your wire, you have to pick both or neither
21:32:48 <ryantrinkle> because time passes everywhere the same
21:32:55 <ZelteHonor> I am not sure, but maybe you can do it with the inhibiting?
21:32:56 <ryantrinkle> now, i'm sure netwire has ways of handling this
21:33:15 <ryantrinkle> yeah, lots of AFRP systems have ways of inhibiting or otherwise creating clock domains
21:33:16 <sm> I have the impression ertesx has moved on from netwire a little ?
21:33:42 <ryantrinkle> oh, that's ertes's thing?
21:33:54 <ryantrinkle> from what i know, he's been playing with reflex for the last few days :)
21:33:58 <sm> I believe so
21:34:16 <ZelteHonor> Yeah. The latest stuff I can found, he talks about building a new better frp library. But it seems it never happened.
21:34:44 <ZelteHonor> Yeah, The author of netwire is ertes.
21:35:29 <ryantrinkle> with reflex, I chose not to have a built-in clock
21:35:34 <sm> you have a lot of FRP-oid libs to try out, meanwhile
21:35:42 <ryantrinkle> because it's trivial to create your own
21:36:03 <ryantrinkle> in reflex, for example, you can just create an Event t Int or Event t Double at the top of your program
21:36:08 <ZelteHonor> I have the problem that I tend to learn a lot of thing but never really apply it.
21:36:21 <ryantrinkle> and then you can pass it everywhere, e.g. by using a Reader
21:36:37 <sm> ZelteHonor: time to commit to a game! :)
21:36:59 <ZelteHonor> Yeah. I already wrote a chess game.
21:37:03 <ZelteHonor> Command line.
21:37:16 <sm> nice, in haskell or.. ?
21:37:25 <ZelteHonor> Haskell.
21:37:52 <ZelteHonor> For school I have written a really small dungeon crawler in Java. I my goal would be to rewrite it in haskell with FRP.
21:37:57 <sm> hchesslib ?
21:38:15 <ZelteHonor> No no. Just a little project in my harddrive.
21:38:42 <ZelteHonor> It would be good to learn how to use cabal and/or stack.
21:38:49 <ZelteHonor> So much thing to look at.
21:39:19 <sm> stack is easy. Download, stack install things, stack build..
21:39:40 * hackagebot classy-prelude-yesod 0.12.6.1 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-0.12.6.1 (MichaelSnoyman)
21:39:53 <ZelteHonor> Yeah I know. It looks easy.
21:40:24 <ZelteHonor> So would Reflex be suitable for a little real time game?
21:40:29 * sm wonders which working FRPish games are on hackage
21:42:11 <ZelteHonor> I don't know if they are working but dow and DefendTheKing are in both game and frp section in hackage.
21:42:24 <ryantrinkle> ZelteHonor: well, we don't have low-level graphics or audio bindings
21:42:49 <ryantrinkle> reflex itself can handle that stuff fine, but nobody's built it
21:42:52 <sm> aha
21:42:58 <ryantrinkle> however, for simpler stuff, there's this: https://hackage.haskell.org/package/reflex-gloss-0.2/docs/Reflex-Gloss.html
21:43:09 <ryantrinkle> that would be perfect for implementing a chess game or something like that
21:43:14 <sm> strangely, this and the previous three games I've clicked on have lost their repo
21:43:16 <ZelteHonor> I really don't like doing audio or graphics stuff. I just like game logic itself.
21:43:30 <ryantrinkle> ZelteHonor: i think this might be worth a look, then
21:44:03 <sm> ah http://hackage.haskell.org/package/dow, I believe that works
21:44:22 <ZelteHonor> It use Elerea.
21:44:40 * hackagebot classy-prelude 0.12.7 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-0.12.7 (MichaelSnoyman)
21:44:42 * hackagebot classy-prelude-conduit 0.12.7 - conduit instances for classy-prelude  https://hackage.haskell.org/package/classy-prelude-conduit-0.12.7 (MichaelSnoyman)
21:44:44 * hackagebot classy-prelude-yesod 0.12.7 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-0.12.7 (MichaelSnoyman)
21:45:18 <HyperHopper> hey, I'm trying to get xmonad to work, and I'm getting some strange errors with xmobar.
21:45:50 <HyperHopper> on start, instead of a black screen like I should be getting, I'm getting a terminal open warning me about some settings that I don't care about defaulting
21:45:57 <ZelteHonor> So is there any tutorial for Relfex or do I have to read the documentation like real man do.
21:46:03 <HyperHopper> and as soon as I open a second window, xmobar becomes hidden
21:46:23 <HyperHopper> also when there is only one window it is "over" that window, instead of being space that the window cant occupy
21:46:25 <ZelteHonor> I am no expert but wich distribution do you use?
21:46:37 <HyperHopper> I was setting this up in arch
21:47:40 <ryantrinkle> ZelteHonor: there's a tutorial, but it's focused on building web apps
21:47:55 <ryantrinkle> https://github.com/reflex-frp/reflex-platform#tutorial
21:48:33 <ryantrinkle> the core of the documentation is here: https://hackage.haskell.org/package/reflex-0.4.0/docs/Reflex-Class.html#t:Reflex
21:48:37 <ZelteHonor> Thanks. I'll take a look.
21:48:43 <ryantrinkle> no problem :)
21:48:50 <ryantrinkle> and we have a chatroom, #reflex-frp
21:48:59 <ryantrinkle> so feel free to come by if you have any questions
21:49:47 <sm> is reflex suitable for games too, then ? I read somewhere it might not scale to large numbers of game objects
21:54:59 <scshunt> hmm, damn
21:55:19 <scshunt> looks like GHC's standalone deriving can't do what I want
21:55:41 <sm> ah I see how this works.. line of sight
21:55:54 <sm> dow is cool! beat my 7070 score
21:57:01 <sm> easier to install with cabal than stack
21:57:50 <sm> and it's two player, which isn't common
21:58:08 <ZelteHonor> I checked stack and the only FRP library that I've found was sodiumFRP... wich is depreceted in haskell in favor of reactive-banana.
21:58:14 <ZelteHonor> *stackage
22:02:32 <sm> night all
22:06:24 <ZelteHonor> Good bye
22:07:04 <ryantrinkle> sm: interesting, i'm not sure why reflex wouldn't scale
22:07:22 <ryantrinkle> there are a few constant factors that could be improved in various ways
22:07:28 <ryantrinkle> e.g. using vectors intead of maps
22:08:00 <ryantrinkle> but there's nothing i'm aware of that shouldn't "scale properly", as in log(n) at worst in the relevant things as it grows
22:19:04 <Peaker> ski: Yeah, you can have a composite expression that's polymorphic to the phantom 'c' tag, and then you can use it inside records and sums both
22:20:34 <Peaker> ski: e.g:  let foo = MetaTypeAST (TCompositeExtend "a" typ (MetaTypeVar ..))  (with let generalization) will be a valid sum and product and mean (a:typ | rest)
22:21:43 <Peaker> ski: actually the meta-var has to be created with an "ST" action (it's a mutable ref), so "foo" would be an action, not a pure value, and the actual meta-var won't be shared between the two cases (meta-vars aren't polymorphic)
22:31:36 <xWindow-Free> Yohanes Patra
22:31:38 <xWindow-Free> 7 hrs · 
22:31:40 <xWindow-Free> HI , FROM YOU'R GOD , THE MOST HIGH ... .
22:31:42 <xWindow-Free> COME TO #‪#‎HACKER‬ ON IRC FREENODE ... .
22:31:46 <xWindow-Free> http://thv0day.us.to
22:31:50 <xWindow-Free> IRC CLIENT https://hexchat.github.io/downloads.html
22:31:52 <xWindow-Free> i MISS YOU ALL PRINCE ... .
22:31:54 <xWindow-Free> FROM YOHANES PATRA OR IMMANUEL YOHANES PATRA ... .
22:31:57 <xWindow-Free> PASSWORD FOR MY SPEEDY@09F0 IS 63865448
22:54:29 --- mode: ChanServ set +o johnw
23:01:11 <Peaker> Using rnf causes algorithms to have the wrong asymptotics :(  If thunks could be marked as NF so rnf wouldn't re-traverse them, it would be much better
23:02:22 <ski> Peaker : well, i was wondering whether one could express something like `case : *{ | CompositeMap (-> o) c } -> +{ | c } -> o'
23:03:48 <Lokathor> I'm computing a set by creating four intermediate sets and then unioning them. if I made intermediate lists taht i kept sorted as i went, then merged those, then made that final list into a set just once... perhaps i can get a speedup
23:04:57 <quchen> In Tasty, is it possible to run tests based on whether another test has succeeded/failed? If one test implies the failure of another, I'd like to get only the first one, for example.
23:05:00 <Peaker> ski: ah, nope: there's no "CompositeMap", and currently meta-vars with different phantoms have to be distinct (can relax that but "CompositeMap" is hard)
23:06:43 * ski idly wonders what's the best way to get the index/exponent of the most significant bit in a natural number
23:08:16 <ski> or .. i suppose i'm rather after `logBase 2' on it, rounded up
23:08:56 <ski> Peaker : would it be possible to use the same `c' both in a sum type and in a product type, inside the same larger type expression ?
23:09:29 <ski> Peaker : or is that an example of "currently meta-vars with different phantoms have to be distinct" ?
23:11:48 <quchen> > subtract 1 . length . takeWhile (> 0) . iterate (`quot` 2) $ 64 - 1 -- Good enough? ;-D
23:11:50 <lambdabot>  5
23:12:13 <quchen> The "fusion will take care of this" approach, unchecked version.
23:12:28 <briansmith> In C++ we can write an integer literal as 123'456 and other languages allow similar, e.g. 123_456. Any suggestions on a lightweight way to acheive the same effect?
23:13:22 <quchen> briansmith: The NumDecimals extension allows (4e7 :: Int), other than that I don't think we have such a thing. You could write a quasiquoter to do this sort of thing though.
23:14:14 <Peaker> ski: it's the latter. If you had a meta-var that's polymorphic on the "c" you could share it in both sums and products. But it's currently impossible in the same way an IORef cannot be polymorphic on its contents (requires an IO action to create)
23:15:27 <Peaker> ski: I could have "createPolyMetaVar" that creates a MetaVar that is polymorphic in "c", but I don't know when I'd use it
23:16:11 <ski> quchen : well, i was wondering whether there was something like a machine code instruction which could be used for `Int32', say. writing the obvious loop isn't that hard :)
23:17:07 <quchen> I think amd64 has an instruction for popcount, maybe there's one for most significant bits as well
23:19:13 <ski> briansmith : define a left-associative operator (with high precedence), perhaps `|+' or something, with `m |+ n = 1000 * m + n',then `123|+345|+678' ?
23:19:19 <cocreature> it looks like gcc has __builtin_clz which uses a hardware instruction if it’s available and otherwise emulates it
23:19:32 <Peaker> ski: http://x86.renejeschke.de/html/file_module_x86_id_20.html
23:19:51 <Peaker> (the "Bit scan reverse" instruction)
23:20:16 <ski> ok
23:20:17 <AfC> You can find use of the popcount instruction in edwardk's succinct package.
23:20:31 <Peaker> didn't know the instruction - but I knew the 'gcc' builtin (clz/ctz -- count leading/trailing zeros) so I compiled a program with the builtin and disassembled :)
23:21:20 <briansmith> ski: There's also an improved variant of BSR called LZCNT: https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#ABM_.28Advanced_Bit_Manipulation.29
23:22:43 <Peaker> briansmith: seems like a minor improvement for loss of old CPU compatibility, though
23:23:04 <ski> ok
23:23:32 <briansmith> Peaker: the improved behavior for the value zero is very useful.
23:24:03 <briansmith> I remember writing a binary GCD and trying to use BSR was not very helpful because it didn't work for the value zero.
23:25:01 <ski> AfC : where ?
23:25:44 <ski> @hackage succinct
23:25:44 <lambdabot> http://hackage.haskell.org/package/succinct
23:25:48 <ski> not found
23:25:55 <Peaker> briansmith: it just requires an extra test, if you don't already know
23:26:01 <Peaker> briansmith: it's still useful
23:27:21 <cocreature> ski: https://github.com/ekmett/succinct/
23:27:33 <ski> briansmith : .. obviously this fixes the digit grouping as three digits (each time)
23:27:53 <ski> ok, ty
23:29:44 * hackagebot io-choice 0.0.6 - Choice for IO and lifted IO  https://hackage.haskell.org/package/io-choice-0.0.6 (KazuYamamoto)
23:37:32 <Lisa1157> Hi, I am trying to write a function to count the number of times an integer appears in a binary tree,  I am getting an error while using it with quick check I dont understand: https://dpaste.de/S3nP 
23:38:07 <Lisa1157> how is it non exhaustive if I have an otherwise clause present?
23:38:51 <glguy> Lisa1157: You're only handling the Branch constructor and not the Leaf one
23:38:53 <kadoban> Lisa1157: Because nothing in that appears to be matching a Leaf
23:39:37 <Lisa1157> oh ic, thx guys
23:58:59 <quchen> Lisa1157: "Non-exhaustive" errors are directly from the compiler, not Quickcheck. Try recompiling with -Wall and GHC will warn you during compilation about this issue.
