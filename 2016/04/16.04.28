00:00:14 <LordBrain> seems to graph dependencies of thunks, which is pretty close to a call graph isn't it?
00:01:35 <LordBrain> maybe it is too much information
00:02:49 <LordBrain> does hs2dot do callgraph?
00:03:01 <runeks> LordBrain: Looks interesting. I will take a look at that.
00:03:42 <LordBrain> also this one http://hackage.haskell.org/package/SourceGraph
00:03:56 <cocreature> he mentioned that a few minutes ago :)
00:04:01 <LordBrain> ooh ok
00:10:26 <akfp> jle': thanks!
00:27:29 <akfp> can I use View Patterns within a sub-match, like   myfun (Foo a@(view -> Bar b)) = ... ?
00:28:44 <cocreature> akfp: I think that should work
00:30:01 <akfp> cool!
00:46:37 * hackagebot wolf 0.2.5 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.5 (markfine)
00:53:09 <runeks> putVal dataType fieldFunc val = dataType { fieldFunc = Just val }
00:53:31 <runeks> It works if fieldFunc is not a variable but a constructor
00:54:10 <runeks> Is there a way to get this to work, or is there a better way?
00:58:29 <wine> :t not
00:58:30 <lambdabot> Bool -> Bool
00:58:45 <wine> how does one perform a bitwise not operation?
00:59:39 <wine> besides (`xor` -1)
00:59:51 <Ralith> :t complement
00:59:53 <lambdabot> Bits a => a -> a
01:00:03 <wine> cool thanks
01:16:38 * hackagebot json-ast 0.3 - Universal JSON AST datastructure  https://hackage.haskell.org/package/json-ast-0.3 (NikitaVolkov)
01:34:53 <kritzcreek> I am struggling with building a project inside a docker container with stack. I'm getting this error:  https://www.irccloud.com/pastebin/EdyqsLm4/
01:36:16 <kritzcreek> has anyone seen this before? I've created a Dockerfile that derives from the stack-build docker image and installs a library but  that's all
01:38:07 <jophish> @tell sinelaw I'm writing a typechecker for a language we're developing at work for use in house. At the moment it's similar to Haskell98 + higher ranked types + type in type + a few little things
01:38:07 <lambdabot> Consider it noted.
01:42:35 <16WAAD4E1> kritzcreek: Weird!  Perhaps make a stack overflow question with repro or a stack issue
01:50:47 <jle`> runeks: instead of providing the name of the field, just provide a function/way to update that field
01:50:59 <jle`> you can't use record syntax in this case, but
01:51:34 <jle`> one way people do is use a lens for the field, so putVal x fieldLens val = set fieldLens val x
01:52:10 <jle`> @let putVal x fieldLens val = set fieldLens val x
01:52:12 <lambdabot>  Defined.
01:52:25 <jle`> > putVal (1,2) _1 "!!"
01:52:27 <lambdabot>  ("!!",2)
01:55:58 <__uu__> > putVal (1,2) _2 "?"
01:55:59 <lambdabot>  (1,"?")
01:56:24 <__uu__> > :t pullVal
01:56:25 <lambdabot>  <hint>:1:1: parse error on input ‘:’
01:56:35 <__uu__> :t pullVal
01:56:36 <lambdabot>     Not in scope: ‘pullVal’
01:56:36 <lambdabot>     Perhaps you meant ‘putVal’ (line 178)
01:57:16 <jle`> putVal :: s -> Lens s t a b -> b -> t
01:58:05 <jle`> think of the Lens as an value that contains instructions on how to set a part of a data structure
01:58:15 <jle`> (among other things)
02:46:30 <bennofs> kritzcreek: does your stack project have a Setup.hs file in its root?
02:49:57 <bennofs> kritzcreek: if no, can you try running 'echo "import Distribution.Simple; main = defaultMain" > /tmp/test.hs && ghc /tmp/test.hs' in the docker container? 
03:02:18 <kritzcreek> bennofs: I'll do so in a second. I'm switching from Docker Beta on osx into a ubuntu VM atm 
03:21:17 <runeks> jle`: Thanks. I was led to lenses in the end by Google. This will work wonders in reducing the complexity of my code.
03:36:42 * hackagebot hsseccomp 0.2.0.1 - Haskell bindings to libseccomp  https://hackage.haskell.org/package/hsseccomp-0.2.0.1 (teh)
03:57:43 <Jinxit> runeks: just keep in mind that it raises complexity for people unfamiliar with lenses
04:00:10 <runeks> Jinxit: That's a fair point. But I guess every optimization, be it syntax- or speed-related, raises complexity. It should also reduce certain parts of the code base by half (line count), I would venture to say. That's less complexity, in a way.
04:00:31 <Jinxit> yes
04:00:36 <Jinxit> agreed
04:00:53 <Jinxit> just don't overuse them is what I'm trying to say, sometimes vanilla haskell is just as good
04:01:03 <Jinxit> (and I love lenses)
04:01:54 <runeks> To me, Haskell feels like a type of meta-language, where you can't really expect to be able to understand other people's code bases without learning a new library or two, or understanding the monad they've creating for doing whatever computation they require.
04:02:31 <Jinxit> well, the power of monads comes from reuse
04:02:41 <MichaelBurge> runeks: I know the feeling, and tend to agree with it. But man, this crazy 400 line Template Haskell module that lets me write about 100 lines like $(deriveInstances ''MyType) is something I'd be scared to inflict on a future maintainer
04:02:48 <runeks> Jinxit: It's mainly related to error-reporting when trying to retrieve a value from the state that is not there yet. This gets a lot simpler with lenses, since I'm resorting to pattern matches on the state currently.
04:03:33 <Jinxit> and functors don't cut it?
04:04:03 <runeks> MichaelBurge: Agreed. 400 lines is way too much. I would claim that if you can't reduce your program to 4-5 line functions, composed together, you don't understand either Haskell or the problem you're trying to solve well enough (or you're impatient).
04:04:36 <guillaum2> Do you see any use case for the Functor/Foldable instances of (,) ?
04:04:39 <runeks> Jinxit: I don't know how I would use a Functor for that. I'm fairly new to Haskell, and I prefer learning by doing.
04:05:21 <Jinxit> let's say you receive a Maybe from a function, then you can do your operations on that Maybe without "unwrapping" it
04:05:45 <Jinxit> and if it turns out to be a Nothing, then it will remain so
04:05:55 <runeks> Jinxit: Right...
04:06:09 <Jinxit> still, this is more complex to some
04:06:11 <Jinxit> matter of taste
04:06:43 * hackagebot regex-tdfa 1.2.2 - Replaces/Enhances Text.Regex  https://hackage.haskell.org/package/regex-tdfa-1.2.2 (Artyom)
04:07:07 <merijn> runeks: I feel it depends. There's a a fairly substantial base vocabulary in terms of abstractions that people are expected to know. e.g. transformers, functors, applicatives, etc.
04:07:43 <merijn> runeks: And in some case some DSL library that people are using/have developed. But in my experience the time to learn new DSLs abstractions takes less and less time as my experience goes on
04:08:01 <merijn> runeks: Meanwhile referential transparency and types help tackle huge codebases much easier
04:08:12 <runeks> merijn: I think I may know how to use those things, but when reading the Wikipedia article on them I don't understand that at all.
04:08:23 <merijn> runeks: So I think overall haskell is still easier than other languages and it becomes easier and easier
04:08:34 <merijn> runeks: Wikipedia is notoriously terrible for learning this stuff
04:08:56 <merijn> runeks: I regularly don't understand shit from wikipedia's type theory articles despite reading papers on it...
04:09:19 <runeks> merijn: Yeah that's true, bad example. 
04:09:20 <merijn> Same way it's terrible for math, IMO
04:09:54 <Jinxit> what was that example from wikipedia math again?
04:10:01 <Jinxit> that starts off insanely complex on a simple page
04:10:16 <runeks> I think it's because the Wikipedia experts are written by experts who are familiar with all the terminology, and use that terminology to explain the concept.
04:10:35 <merijn> I don't think so
04:10:41 <merijn> I think it's also wikipedia politics
04:11:04 <merijn> I know that lots of researchers would like to improve wikipedia articles, but everytime they write stuff it gets reverted edited/whatever
04:11:11 <runeks> I really like this guy though. Very intelligible articles: http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
04:11:25 <merijn> Because it's not impartial, cited, etc. and it all ends in wikipedia politics
04:11:30 <merijn> Ain't nobody got time for that
04:11:35 <merijn> runeks: Yeah, Tekmo is good
04:11:37 <runeks> merijn: Perhaps that's a fair point though
04:11:43 * hackagebot nofib-analyse 8.1.0.20160428 - Parse and compare nofib runs  https://hackage.haskell.org/package/nofib-analyse-8.1.0.20160428 (JoachimBreitner)
04:11:47 <runeks> It's an encyclopedia after all
04:12:23 <merijn> runeks: Lots of the Functional Pearls are very neat too
04:12:53 <merijn> So is "Pearls of Functional Algorithm Design" by Bird
04:13:00 <runeks> I think it's the difference between explaining through examples rather than just previously defined words.
04:13:12 <runeks> merijn: I will take a look at those
04:13:30 <merijn> I think DList is also an important one to know
04:14:14 <merijn> Because it's fairly simple to understand and can be generalised a lot as your understanding grows (i.e. DList is a special case of codensity transform which can be used to optimise operations on almost any recursive data structure)
04:14:28 <merijn> See http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
04:16:17 <merijn> My other favourite list trick is applying the "tortoise and hare" technique in haskell: https://gist.github.com/merijn/c163cc106fd245d1cf2e
04:18:59 <merijn> Completely unrelated question: How expensive is allocating and IORef?
04:28:27 <ggVGc> has anyone here implemented type inference?
04:29:45 <merijn> ggVGc: Does a broken version count? ;)
04:29:53 <ggVGc> probably
04:29:54 <merijn> oh, wait... I only did typechecking...
04:29:58 <merijn> No inference
04:30:02 <ggVGc> I'm trying to even find out where to start
04:30:04 <merijn> That's on my todo list :)
04:30:08 <ggVGc> it's a pretty illusive concept
04:30:23 <merijn> ggVGc: The same place as everything else related to type theory: TaPL :p
04:31:38 <ggVGc> merijn: this? https://www.cis.upenn.edu/~bcpierce/tapl/
04:33:10 <merijn> Yes
04:33:52 <merijn> ggVGc: Starts basically at untyped lambda calculus and works up to "way more complex than haskell" including type checking, inference, etc. Example implementations and proofs of everything too
04:44:49 <AndChat-600084> So I think I want to use haskell for my next project, but I was just wondering: is it possible to cross compile my project to linux, windows, osx and freebsd?
04:47:09 <merijn> AndChat-600084: Possible, should be. Pleasant? Probably not. Probably better of running those OSes in a VM and compiling there
04:47:48 <rembo10> Hm. Ok. If I used something like travis, does that build it for different platforms?
04:49:18 <rembo10> Nevermind. I'm not sure it does :-(
04:50:11 <lpaste> muesli4 pasted “What's wrong with this?” at http://lpaste.net/161712
04:50:24 <muesli4> Whats wrong with that piece of code? :D
04:52:35 <merijn> muesli4: Line 24 overlaps with everything else
04:53:15 <muesli4> merijn: how so?
04:53:23 <merijn> muesli4: "instance RowConv (Int, (Int, Int)) (Int, (Int, Int))" is a valid instance for "collectRow (1, (2,3))"
04:53:54 <muesli4> merijn: true, but even if I specify that I want (Row Int) it doesn't work.
04:54:20 <merijn> muesli4: Yes, because just specifying the result type isn't sufficient to pick another class, afaik
04:54:58 <muesli4> merijn: So I wonder, is there any way I can fix this? Such that I can collect all elements of tuples with same type and foldables that are nested?
04:55:53 <merijn> FunctionalDependencies might help
04:56:02 <merijn> But I'd be wary of "magic" classes like this
05:02:22 <Darwin226> Hey guys. How can I get a template haskell name of a "multi word" type?
05:02:26 <Darwin226> Like ''[Int] doesn't work
05:03:24 <Darwin226> I want to use deriving functions on specialized versions of polymorphic types
05:03:25 <merijn> "''[] ''Int", maybe?
05:03:49 <merijn> Alternatively, can you use the quoter to generate those names?
05:04:12 <Darwin226> how?
05:04:44 <Darwin226> For example, say I have a type T a. How do I use the deriveJSON function to generate an instance for T Int?
05:05:24 <merijn> Darwin226: "runQ [t|[Int]|]"
05:05:43 <merijn> Apparently you write it like this: "AppT ListT (ConT GHC.Types.Int)"
05:06:01 <Darwin226> merijn: Yeah but that's a type, right? I think I need a Name
05:06:02 <merijn> So presumably "AppT ListT ''Int" should work?
05:06:24 <merijn> Darwin226: You'd have to look how to reify that type?
05:06:52 <Darwin226> I think I want the reverse of reify
05:07:56 <merijn> Won't "lookupTypeName :: String -> Q (Maybe Name)" work for you?
05:09:22 <Darwin226> I'll check but I have a suspicion that there's no way to get a single Name from a type like that
05:09:39 <merijn> Darwin226: Try asking in #ghc, more TH expertise there
05:10:28 <Darwin226> Will do
05:15:47 <muesli4> Is there a pendant for ~ with inequality?
05:18:32 <srhb> muesli4: No.
05:19:46 <rom1504> there's <=
05:20:07 <srhb> rom1504: ~ is usually understood as type equality
05:20:10 <merijn> muesli4: No, because inequality isn't decidable
05:21:17 <muesli4> merijn: I seem to understand.
05:21:37 <merijn> muesli4: Consider "a ~ b" where both a and b are free type variables, how do you decide that two unbound variables are inequal?
05:31:20 <Tangerine> quick question: what is the time complexity of evaluating length on a list?
05:31:29 <Tangerine> and how would you analyze it?
05:32:44 <Tangerine> I see that length is defined as length = foldl' (\c _ -> c+1) 0
05:33:25 <Tangerine> not sure what (\c _ -> c+1) means
05:33:48 <chelfi> it is the function that takes two arguments, ignore the second one and returns the first one incremented
05:34:04 <chelfi> > (\c _ -> c+1) 1 9
05:34:06 <lambdabot>  2
05:34:24 <srhb> Tangerine: O(n) -- they are singly linked lists.
05:34:32 <Tangerine> ah I see
05:34:39 <Tangerine> what does the backslash on the C mean?
05:34:44 <srhb> Tangerine: lambda abstraction
05:34:53 <srhb> > (\x -> x+1) 2
05:34:55 <lambdabot>  3
05:35:06 <srhb> > (\x y -> x+y) 2 3
05:35:07 <lambdabot>  5
05:35:12 <chelfi> it is the syntax for anonymous functions
05:35:17 <Tangerine> ooh, i'm too used to looking at (\x stuff)
05:35:18 <Tangerine> haha
05:35:25 <scshunt> if it makes it any easier for you, (\c _ -> c+1) = const . (+1)
05:35:25 <Tangerine> that I didn't recognize you can use it with other letters too
05:35:33 <scshunt> (it probably doesn't)
05:35:53 <srhb> > (\oreven -> "words" ++ oreven) ", omg"
05:35:55 <lambdabot>  "words, omg"
05:36:07 <Tangerine> wow i feel stupid
05:36:12 <warbo> Hello, is it possible to add declarations to a module with Template Haskell, from within a splice that's not at the top-level; e.g. `foo x = bar x $(mySplice)`, where `mySplice` returns a `Q Exp`, and the `Q`-based side-effects include splicing some `Q [Dec]` at the top-level?
05:36:14 <Tangerine> although I feel like Haskell does that to you a lot
05:36:18 <srhb> Tangerine: Words are overrated anyway. :-)
05:36:47 <warbo> Basically, the `Q Exp` I'm generating may require some typeclass instances to be generated too
05:38:28 <scshunt> no
05:38:40 <scshunt> you'll need to create a separate splice at the top-level to add your declarations
05:39:04 <Tangerine> and I have one more question on lazy evaluation. Say that we have fib 0=0; fib 1=1; fib n = fib (n-1) + fib (n-2)
05:39:29 <Tangerine> when you call fib(3), it first evaluates to fib(3-1) + fib (3-2)
05:39:44 <Tangerine> does it calculate 3-1 and 3-2 now?
05:42:11 <Boomerang> I think it's like this: fib (3-1) + fib (3-2) then fib 2 + fib (3-1) then (fib (2-1) + fib (2-2)) + fib (3-2) then (fib 1 + fib 0) + fib (3-2) then 1 + 0 + fib (3-2) then 1 + fib 1...
05:42:33 <warbo> scshunt: thanks; I did a quick browse of the haddock, but that's saved me going down a potentially useless rabbit hole :)
05:42:48 <Tangerine> Boomerang: that's what I'm thinking now too...
05:43:03 <Boomerang> :)
05:43:12 <Tangerine> why does lazy evaluation choose fib(2) over fib(3-2)?
05:43:12 <srhb> Tangerine: The subtractions are evaluated on pattern match
05:43:27 <Tangerine> and if its
05:43:35 <Tangerine> fib(3-2) + fib(1) written exactly like that
05:43:41 <Tangerine> would fib(3-2) still be evaluated first?
05:43:52 <srhb> Tangerine: Doesn't matter.
05:44:15 <Tangerine> err, would fib(1) evaluated first here?
05:44:25 <amnn> Tangerine, there's no way to tell
05:44:28 <Boomerang> my favorite definition of fib is this:
05:44:40 <Boomerang> > let fib = 0 : scanl (+) 1 fib in take 10 fib
05:44:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
05:44:52 <srhb> Tangerine: You could ask how GHC does it (by inspecting the core)
05:45:11 <Tangerine> how do I do that?
05:45:12 <srhb> Tangerine: But which argument is evaluated first really isn't specified.
05:45:33 <srhb> Tangerine: I don't remember the exact parameters, it's one of the -ddump-foo ones, and learn to read the output :-)
05:45:43 <Tangerine> huh...
05:46:07 <srhb> Tangerine: You could also use Debug.Trace.trace
05:46:45 <srhb> Tangerine: But it really tells you only very little. Also, why do you care about the order? :)
05:47:35 <Tangerine> well it matters for performance right?
05:47:54 <Tangerine> just like how sometimes you want to use foldl instead of foldr or something you want to use foldl'
05:48:13 <amnn> Tangerine, how do you figure?
05:48:17 <Darwin226> That's not the same
05:48:22 <srhb> Tangerine: Surely which side is evaluated first doesn't matter.
05:48:48 <Darwin226> I think the difference is that the "commutative order" doesn't matter, but the way subexpressions associate does
05:48:49 <amnn> Tangerine, the point here is that if one side of the + is evaluated, the other side is going to be evaluated straight afterwards
05:49:16 <srhb> Tangerine: (in my ghci, the answer is "the second argument gets evaluated first")
05:49:24 <Tangerine> also for termination detection maybe? In case some type of evaluation doesn't terminate?
05:50:24 <Darwin226> if evaluation of a OR b doesn't terminate, then you can be sure that the evaluation of a + b won't either
05:50:27 <amnn> + is strict in both of its arguments, so if you force it, and one of its arguments doesn't terminate, it won't terminate
05:50:47 <Tangerine> well, also for the sake of understanding lazy evaluation
05:51:36 <Tangerine> i.e. fib (3-1) + fib(3-2) => fib 2 + fib(3-2) => fib (2-1) + fib(2-2) + fib(3-2) is not absolutely obvious to me
05:51:48 <Tangerine> and how do I know it's that over
05:52:02 <srhb> Tangerine: Tangerine It's not obvious because you can't tell.
05:52:13 <Tangerine> fib(3-1) + fib(3-2) => fib(3-1) + fib 1 + fib(3-1) + 1
05:52:45 <Tangerine> or is it fib(3-1) + fib(3-2) => fib (3-1) + fib 1 + fib 2 + fib 1...
05:53:29 <amnn> That's not really to do with laziness per se, because + needs to fully evaluate both its arguments, your question is to do with evaluation order.
05:54:25 <amnn> Let me think up a simple example that uses laziness
05:55:26 <srhb> Tangerine: You can try defining fib n = fib (trace "first" (n-1)) + fib (trace "second" (n-2)) -- the other equations as before.
05:55:34 <amnn> fib n = if n < 2 then [()] else fib (n - 1) ++ fib (n - 2)
05:56:20 <warbo> Is (+) always strict? Could instances be lazy, e.g. Peano numerals "S (S Z) + _|_" --> "S (S _|_)"
05:56:25 <amnn> this definition of fib returns a list instead of a number, and the length of the list is the actual fibonacci number
05:57:05 <amnn> warbo, sorry you are right, (as I have just shown, because I have essentially produced a 
05:57:23 <warbo> heh, good timing; "[()]" is isomorphic to Nat
05:57:28 <srhb> warbo: That sounds plausible. As long as you can produce something that is different from evaluating it fully, it seems reasonable that you could make it lazy in at least one argument
05:57:28 <amnn> *written a version of fib that returns a peano numerals
05:57:36 <srhb> Too slow :(
06:09:35 <steffen`> How can I check on a Handle to prevent: "hFlush: resource vanished (Broken pipe)"
06:10:27 <steffen`> I already tried hIsClosed and hIsWriteable
06:10:37 <fr33domlover> steffen`, catch the exception?
06:10:50 <fr33domlover> not sure it's the only way, but it will work
06:11:02 <steffen`> that's smart :) Thanks
06:11:24 <steffen`> fr33domlover: how can I make sure to only catch this exception? 
06:11:46 <fr33domlover> steffen`, go to the Control.Exception docs in Hackage
06:11:53 <srhb> Tangerine: If you just want to know which order the _arguments_ are dealt with, I think you can safely say left-to-right
06:12:18 <srhb> Tangerine: (Otherwise defining lazy && etc. would be terribly hard!)
06:12:33 <Tangerine> i see...
06:12:54 <srhb> ie.
06:12:58 <steffen`> fr33domlover: okay, and now I can I find the Exceptionconstructor that corresponds to that exception?
06:13:00 <srhb> > False && undefined
06:13:02 <lambdabot>  False
06:13:36 <amnn> This is just by convention though, a particularly vindictive programmer could define (&&) to be strict in its first argument.
06:14:20 <srhb> > let terrible = flip (&&) in False && undefined
06:14:21 <Tangerine> srhb: isn't that more of an effect of && pattern matching?
06:14:21 <lambdabot>  False
06:14:29 <srhb> > let terrible = flip (&&) in False `terrible` undefined
06:14:31 <lambdabot>  *Exception: Prelude.undefined
06:14:35 <srhb> Tangerine: Yes :)
06:14:41 <Tangerine> like
06:14:48 <Tangerine> > undefined && False
06:14:50 <lambdabot>  *Exception: Prelude.undefined
06:14:52 <amnn> and some functions just naturally are strict in their first argument, like (++)
06:14:59 <Tangerine> oh woah
06:15:13 <amnn> take 3 ([1..5] ++ undefined)
06:15:42 <amnn> > take 3 ([1..5] ++ undefined)
06:15:44 <lambdabot>  [1,2,3]
06:16:02 <fr33domlover> Q: I had some code that uses Data.Binary.Put to serialize some data. Now I modified it, and the new code needs to run IO actions in between. Put is a monad without a transformer variant. What would be a good way to mix IO with Put? Ideas I have: (1) use pipes or conduit (2) use StateT Put IO (2) use WriterT Builder IO
06:16:54 <fr33domlover> steffen`, you don't necessarily can. Either catch any IOError, or use the is*Error predicates
06:17:04 <hpc> fr33domlover: is Put an instance of MonadIO?
06:17:58 <steffen`> fr33domlover: that sucks... I had the problem of finding the right type of an exception to make sure I only catch this one once before, I hoped you could help me....
06:18:13 <steffen`> fr33domlover: but thank you anyways, you have helped me already :)
06:18:38 <fr33domlover> hpc, no. But that makes sense I suppose, if I use StateT Put I'll be causing linear memory usage won't I?
06:18:46 <fr33domlover> unless lazy IO prevents it somehow
06:19:42 <srhb> Actually I'm now finding it very hard to justify how that fib example evaluates the right hand subtractions first.
06:19:45 * srhb boggles
06:23:47 <srhb> I guess that's just how (+) works internally.
06:24:21 <srhb> flip (+) provides the more intuitive left-to-right order.
06:24:24 <srhb> Oh well.
06:27:47 <srhb> No, I'm clearly misunderstanding something here. Best stop thinking about it. :-)
06:31:31 <fr33domlover> hmm anyone had advice? It seems to me that building a lazy ByteString over IO, with or without Put, relies on lazy I/O to be constant-memory, while with pipes or conduit I'm safe
06:31:45 <Tangerine> >  0 * Undefined
06:31:47 <lambdabot>      Not in scope: data constructor ‘Undefined’
06:31:47 <lambdabot>      Perhaps you meant variable ‘undefined’ (imported from Prelude)
06:31:56 <Tangerine> > 0 * undefined
06:31:58 <lambdabot>  *Exception: Prelude.undefined
06:34:30 <srhb> Tangerine: That would be a very interesting * :P
06:35:05 <Tangerine> yeah, I was also curious if
06:35:12 <Tangerine> > 0 * _|_
06:35:13 <lambdabot>  <hint>:1:6: parse error on input ‘|’
06:35:23 <Tangerine> err, how do you indicate non-termination?
06:36:04 <Tangerine> basically curious whether or not * pattern matches 0 or not haha
06:36:15 <ahihi> > let x = x in 0 * x
06:36:19 <lambdabot>  mueval-core: Time limit exceeded
06:37:01 <merijn> Depends on the type I think?
06:37:33 <merijn> Int and Integer directly link into machine/GMP primitives without first bothering to case
06:37:40 <mnoonan> > (0 :: Int) * undefined
06:37:41 <lambdabot>  *Exception: Prelude.undefined
06:38:28 <MichaelBurge> > let 1 + 1 = 3 in 1 + 1 * 2
06:38:30 <lambdabot>  6
06:38:32 <merijn> * for Int is: I# x * I# y = I# (x *# y)
06:39:11 <merijn> > let 1 + 1 = 3; infixl 4 + in 1 + 1 * 2
06:39:13 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
06:39:28 <merijn> You're example changes the fixity of + :p
06:39:43 <MichaelBurge> I was just being silly :p
06:41:20 <exio4> > 0 * (undefined :: Integer)
06:41:22 <lambdabot>  *Exception: Prelude.undefined
06:41:33 <exio4> > (undefined :: Integer) * 0
06:41:34 <lambdabot>  0
06:42:31 <exio4> merijn: ^ :P
06:42:56 <MichaelBurge> > case (undefined :: Integer) * 0 of undefined -> 5
06:42:58 <lambdabot>  5
06:43:29 <exio4> that isnt evaluating anything
06:43:57 <ggole> undefined isn't a constructor name
06:44:26 <zalatovo> MichaelBurge: it's the same as if you replaced undefined by foo in pattern match
06:44:43 <exio4> forall A,X. case A of _ -> X = X :P
06:45:07 <merijn> or even _
06:45:39 <anxys> :q
06:48:05 <ntnt> https://gist.github.com/anonymous/e62deacda074e9993dac06bbe210b270 <-- question about inner/outer convention of Monad Transformers
06:48:17 <ntnt> is there any logical reason ConventionB could not work, or was this just picked by convention?
06:48:58 <lyxia> Convention B is not really interesting
06:49:56 <lyxia> how do you even compose these
06:50:17 <ntnt> Can you give me a type sig creatable under ConventionA and not creatable under Convention B?
06:50:22 <ntnt> I think this would help me understand this
06:51:52 <lyxia> what about those you wrote?
06:51:52 * hackagebot git-annex 6.20160419 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160419 (JoeyHess)
06:53:10 <ntnt> lyxia: that is intellectually lazy
06:53:23 <ntnt> to respond to "concrete example" with "vaguely points at one of those"
06:54:08 <jle`> ntnt: try writing a monad instance for version B
06:54:17 <jle`> you're going to run into hard times
06:54:29 <merijn> *impossible
06:55:14 <merijn> But yeah, try implementing instance for convention B, it'll be enlightening :)
06:55:26 <jle`> ntnt: all of your convention B instances are impossible
06:55:40 <ntnt> which ones are impossible?
06:55:45 <ntnt> and why is conventionA automatically possible
06:55:52 <ntnt> understanding this should be enlightening
06:55:58 <lyxia> it's not automatically possible
06:55:59 <jle`> well, not sure about the last conv B one
06:56:08 <jle`> ntnt: it's case by case
06:56:32 <jle`> I think the best way to look at it is to just try writing an instance for both
06:56:39 <jle`> try the EitherT one first
06:56:57 <jle`> the A instance should be somewhat straightforward from following the types
06:57:12 <jle`> and you'll soon see why the B one for EitherT is impossible
06:57:23 <jle`> I don't want to rob you of the experience :)
06:57:59 <jle`> (but as a hint, consider what join would have to do... and see why it can't possibly do it for all Monads. like IO)
06:59:37 <ntnt> so at some point in time,
06:59:46 <ntnt> we want to use (>>=) :: m a -> (a -> m b) -> m b
06:59:54 <ntnt> to make this work, the m has to 'be on the outside'
07:00:01 <ntnt> jle`: is that it?
07:02:29 <MichaelBurge> ntnt: If 'IO [String]' is a list of lines read from a file, then '[ IO String ]' would allow you to determine the number of lines in the file in pure code.
07:03:23 <srhb> But it isn't, so it couldn't.
07:03:25 <srhb> :P
07:04:37 <ntnt> MichaelBurge: that sounds like circular logic
07:05:10 <hpc> here's a better one
07:05:37 <hpc> foo = do {s <- hGetContents; return (write s >> return s)}
07:05:47 <hpc> foo :: IO (Writer String String)
07:05:52 <hpc> now transpose that
07:05:59 <hpc> foo' :: Writer String (IO String)
07:06:12 <hpc> now exec that Writer and you have unsafePerformIO
07:06:31 <jle`> ntnt: to write a bind for Maybe (IO a), you'd have to execute the IO action
07:06:46 <jle`> so the result of it has to be IO ...
07:06:56 <jle`> IO something
07:07:21 <jle`> but the result you are asking for is another Maybe (IO b)
07:09:16 <jle`> I'm not sure if "inside" or "outside" is a useful thing to generalize to
07:09:24 <jle`> just consider each one case by case
07:11:24 <MichaelBurge> > let x = 5 :: Word in let y = 6 :: Word in case fromIntegral $ 5 - 6 of { -1 -> "A"; _ -> "B"}
07:11:25 <lambdabot>  "A"
07:11:31 <MichaelBurge> > let x = 5 :: Word in let y = 6 :: Word in case fromIntegral $ x - y of { -1 -> "A"; _ -> "B"}
07:11:33 <lambdabot>  "B"
07:12:18 <jle`> ntnt: for example, you can write an instance for Identity (m a), I believe. it's not about what's inside or outside... it's just a case by case thing.
07:14:03 <jle`> * Identity . m
07:20:33 <Boomerang> > (-1) :: Word -- MichaelBurge 
07:20:34 <lambdabot>  18446744073709551615
07:22:52 <Boomerang> > 2 ^ 64 - 1
07:22:54 <lambdabot>  18446744073709551615
07:23:11 <MichaelBurge> Boomerang: Run this program once with ghc and once with ghci: 'main = putStrLn $ let x = 5 :: Word in let y = 6 :: Word in case x - y of { 5 -> "C"; -1 -> "A" ; _ -> "B" }'
07:25:52 <Boomerang> Mmmh, that's odd
07:56:47 <tolt> A little off topic but does anyone know of a nice two parameter data set with a linear relation that is related to something in computer science?
07:57:41 <Jinxit> tolt: create one?
07:57:56 <tolt> Jinxit, I thought about it but I wasn't sure of what to create
07:58:08 <tolt> ideas of things to create would also be nice.
07:58:22 <Jinxit> as in just sample a linear function
07:58:47 <tolt> ideally it would be something that would have a linear relationship
08:05:24 <hwiltz> Hey guys. I just started using XMonad with XMobar, but my XMobar only displays the workspace names of workspaces that are in use. Is there a way to display all of them?
08:06:36 <geekosaur> instead of using the default logger, you need to configure DynamicLog yourself
08:06:37 <Boomerang>  #xmonad is more likely to be able to help you :)
08:06:54 * hackagebot circlehs 0.0.3 - The CircleCI REST API for Haskell  https://hackage.haskell.org/package/circlehs-0.0.3 (dshevchenko)
08:06:56 * hackagebot effect-handlers 0.1.0.8 - A library for writing extensible algebraic effects and handlers. Similar to extensible-effects but with deep handlers.  https://hackage.haskell.org/package/effect-handlers-0.1.0.8 (edofic)
08:07:33 <mnoonan> tolt: what about size vs log(runtime) of various algorithms?
08:07:34 <hwiltz> I didn't realize there was an xmonad channel. Thanks
08:07:46 <geekosaur> more specifically, DynamicLog's ppHiddenNoWindows defaults to (const "") and needs to be changed to something else
08:08:21 <hwiltz> geekosaur: Which file do I edit that in?
08:09:43 <humanoyd> What is the fixity for the following expression? `infixr !`
08:10:12 <tolt> mnoonan, that's what I'm using right now
08:10:47 <c_wraith> humanoyd, the default is infixl 9
08:11:14 <c_wraith> humanoyd, so if it only changes it to infixr, the precedence will be unchanged 
08:11:34 <humanoyd> c_wraith: ah, okay, thanks
08:17:18 <hguant> this is unrelated, but I really really hate it when someone tries to change project requirements after the fact.
08:17:53 <hguant> sorry for being off topic. Just needed to rant for a second.
08:18:22 <Akii> isn't that "normal"?
08:22:01 <hguant> for some warped, evil, twisted definition of normal
08:25:58 <geekosaur> (but sadly common)
08:26:44 <nitrix> Is it me or `map (map f)` seems like a common pattern?
08:27:00 <nitrix> @pl map (map f)
08:27:00 <lambdabot> map (map f)
08:27:02 <nitrix> :/
08:27:17 <geekosaur> @pl \f -> map (map f)
08:27:17 <lambdabot> map . map
08:29:01 <nitrix> Meh.
08:29:34 <nitrix> Is there an arbitrary composeN ?
08:30:01 <nitrix> compose 5 f == f . f . f . f . f  ?
08:30:29 <nitrix> It's just for curiosity, don't worry.
08:30:55 <peddie> @src iterate
08:30:56 <lambdabot> iterate f x = x : iterate f (f x)
08:31:06 <peddie> nitrix: ^
08:31:08 <conal> nitrix: fmap . fmap arises whenever functors are composed, e.g., [Maybe a], Maybe [a], a -> b -> c, etc.
08:31:32 <conal> @where SEC -- nitrix
08:31:33 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
08:31:40 <nitrix> > iterate (.) [repeat fmap] 5
08:31:41 <lambdabot>      Couldn't match expected type ‘Integer -> t’
08:31:41 <lambdabot>                  with actual type ‘[(a0 -> b0) -> a0 -> c0]’
08:31:41 <lambdabot>      The function ‘iterate’ is applied to three arguments,
08:32:09 <nitrix> :t iterate (.) 5 [repeat fmap]
08:32:10 <lambdabot>     Couldn't match expected type ‘[[(a1 -> b1) -> f0 a1 -> f0 b1]]
08:32:11 <lambdabot>                                   -> t’
08:32:11 <lambdabot>                 with actual type ‘[(a0 -> b0) -> a0 -> c0]’
08:32:21 <nitrix> I'm confused. How would that work?
08:32:22 <peddie> > iterate (+5) 2
08:32:24 <lambdabot>  [2,7,12,17,22,27,32,37,42,47,52,57,62,67,72,77,82,87,92,97,102,107,112,117,1...
08:32:53 <nitrix> Oh, it's generating the list itself.
08:33:00 <peddie> > iterate (drop 1) "hello"
08:33:01 <lambdabot>  ["hello","ello","llo","lo","o","","","","","","","","","","","","","","","",...
08:33:47 <nitrix> :t (iterate (.) fmap) !! 4
08:33:48 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ a -> b
08:33:48 <lambdabot>     Expected type: ((a -> b) -> a -> a -> b) -> (a -> b) -> a -> a -> b
08:33:48 <lambdabot>       Actual type: (b -> a -> b) -> (a -> b) -> a -> a -> b
08:33:53 <saurabhnanda> just curious. is there a post-mortem for https://www.reddit.com/r/haskell/comments/4gppm8/ann_hackagehaskellorg_is_down/
08:33:59 <nitrix> How cute.
08:34:01 <peddie> :t iterate fmap
08:34:04 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f a
08:34:04 <lambdabot>     Expected type: (f a -> f b) -> f a -> f b
08:34:04 <lambdabot>       Actual type: (a -> b) -> f a -> f b
08:34:42 <peddie> hm, fair enough
08:35:49 <peddie> nitrix, I guess that's not quite what you asked for
08:40:05 <thoughtpolice> saurabhnanda: I can write something up, but we're still looking into the exact bug that caused it. Essentially Hackage uses acid-state, and we ended up having a really large 'checkpoint' for the database we had to replay, but that failed and the OOM killer violently attacked.
08:40:24 <thoughtpolice> saurabhnanda: So in the mean time we were able to get a box with more capacity and do that, then bring the old server back online.
08:41:13 <saurabhnanda> thoughtpolice: thanks for replying. acid-state is something similar to datomic of the clojure world?
08:41:16 <thoughtpolice> saurabhnanda: We'll also be using this as a chance to set up a new staging box for this investigation, which we'll deploy more recent code onto. Finally, the newer hackage server etc will support transparent mirroring.
08:41:50 <thoughtpolice> Which means any clients like newer cabal installs (stack could do it too if it points to Hackage) will transparently get a list of synchronized mirrors, and in the event the primary fails, will fall back to the mirror transparently
08:41:57 <thoughtpolice> (Although write capabilities will be disabled)
08:42:06 <saurabhnanda> thoughtpolice: I was curious mostly because someone said it was a memory issue. and I was wondering if it's a memory issue related to excessive thunking, or something else.
08:42:47 <thoughtpolice> saurabhnanda: Yeah, so it's something like that. We ended up having to fiddle with some bugfixes in acid-state and recompile the code to incorporate some of that (there was a bug related to acid-state's usage of bytestring that was, in effect, a space leaking issue)
08:43:01 <thoughtpolice> And the deployed server accidentally didn't pick that fix up
08:43:54 <thoughtpolice> Also I'm afraid I'm not familiar with datomic, so the comparison is hard to say. acid-state is kind of like an on-disk 'storage engine' for Haskell, so you can persist arbitrary Haskell data into it, etc. It has relatively basic capabilities, so you have to build other things on top of it.
08:44:48 <thoughtpolice> (Like I don't think it has indexes for example, but it does work nicely for pure Haskell values and you can implement some of that stuff.) Needless to say, I've never been a particular fan of Hackage's usage of acid-state for reasons like this, among others.
08:45:32 <thoughtpolice> saurabhnanda: A bit unfortunate it happened right before we rolled out mirroring, though.
08:47:50 <saurabhnanda> thoughtpolice: so, was it an excessive thunking issue at the core?
08:48:45 <thoughtpolice> saurabhnanda: Like I said, it was probably some kind of space leak that exacerbated the issue of having a large checkpoint, yeah (it took gigs of RAM to apply properly, and we tweaked around with GC settings to go faster because there's actually a lot of data)
08:48:49 <saurabhnanda> thoughtpolice: will this be a trigger to open up the "default lazy" stance of Haskell? Especially with Haskell 2020 coming up? Or at least making it **extremely** hard to shoot oneself in the foot due to lazy-related bugs?
08:49:02 <thoughtpolice> It shouldn't ever get THAT bad again, I'm doubling down on making sure the server has got some better mitigations.
08:49:14 <thoughtpolice> Including much more active monitoring of checkpoint states
08:49:36 <thoughtpolice> But the exact cause is still under investigation, autopsy ongoing, etc etc
08:50:45 <ski> @type let compose = foldr (.) id in (compose .) . replicate  -- nitrix, or this
08:50:47 <lambdabot> Int -> (b -> b) -> b -> b
08:51:04 <thoughtpolice> saurabhnanda: Well, I hope this doesn't sound like a shoot down, but considering I just got accepted on to the Haskell Prime committee, I can probably give a pretty faithful "no" to any issues of lazy by default changing or anything.
08:52:11 <thoughtpolice> Now, there could definitely be better anti foot gun tooling, which is always desirable.
08:52:27 <saurabhnanda> thoughtpolice: at least tweaking stuff so that default lazy doesn't end-up shooting people in the foot?
08:52:35 <thoughtpolice> This was partially an operations fault, and partially one of those sort of 'bugs that happens' things (for reference our last unscheduled downtime was like 18 months ago I think was mentioned, fwiw). But also IMO this has more to do with the risk involved with something like acid-state
08:52:37 <CaleNYC> saurabhnanda: no, probably not -- Laziness is something which is much less useful in a default-strict environment, because it's sort of a "recessive gene" when combining programs. It makes things more composable, but if your components are too strict, you can't recover from that.
08:52:49 <saurabhnanda> thoughtpolice: most commonly used functions in Prelude should do the right thing 99.9% of the time.
08:52:58 <CaleNYC> (sorry, that "no" was to your original question)
08:53:10 <saurabhnanda> thoughtpolice: if someone is really looking to squeeze performance and needs lazy behaviour he/she can use a different set of functions.
08:53:49 <CaleNYC> saurabhnanda: Laziness only provides most of its benefit if things are likely to be lazy enough, and so if it's not the default, it's much less beneficial.
08:54:27 <thoughtpolice> Well, the Prelude is really a much more general discussion to be had, involving the libraries committee and the people on it. I don't disagree that some things are error prone in the Prelude, though (an obvious example people bring up elsewhere is lazy IO, but not really for performance reasons as much as flat-out correctness ones)
08:54:48 <thoughtpolice> And fixing those in some sense would be nice, even if it means "Move it outside the default import list so you have to 'import Foot.Gun' first"
08:54:51 <CaleNYC> Oh, sure, lazy IO is perhaps a different discussion.
08:55:01 <CaleNYC> I was referring to lazy evaluation
08:55:08 <thoughtpolice> CaleNYC: Right, just pointing to a more general example.
08:57:29 <thoughtpolice> CaleNYC: Since it's somewhat hard to really single out any kind of 'one thing' in the Prelude in any discussions of "anti-foot gun technology". Just saying really, that there are some rough edges around here that are sort of under that umbrella of "harder to hurt yourself by default"
08:58:23 <merijn> Does 7.10 support stack traces too?
08:58:32 <thoughtpolice> But given the goal is 2020, there's some hope IMO things like module shuffling or some API changes could happen on a reasonable timeline, while GHC gives some heads up and offers compatibility.
08:58:41 <merijn> I'm trying to figure out where the hell an exception is being thrown
08:59:10 <thoughtpolice> merijn: Yes, but you need to add a CallStack into your parameters to thread the lexical call stack around. This is more usable in GHC 8.0, tbh.
08:59:41 <CaleNYC> I sort think that the Haskell Report is not the place to make changes to the Prelude really.
08:59:43 <merijn> thoughtpolice: Yeah, but I don't have 8.0 around and I'm already passing an implicit parameter around anyway
08:59:54 <merijn> thoughtpolice: Where can I find out more?
08:59:57 <CaleNYC> The Haskell Report should be an accurate description of what Haskell currently is.
09:00:40 <CaleNYC> It's currently less useful just because it doesn't even try to formulate half of the features we use on a daily basis.
09:00:56 <thoughtpolice> merijn: I don't have details off the top of my head, but the users guide for 8.0 and 7.10 should be a starting point on all this.
09:01:04 <CaleNYC> sort of*
09:02:58 <thoughtpolice> CaleNYC: Well, it's not totally in our hands anyway. There is the CLC. But in the case of language features, I said this recently, but "half of the features we use" I don't think are fully understood as well as they should be. It's hard to give an accurate description of "What Haskell is" when even some of our more common things are a bit contentious.
09:03:16 <thoughtpolice> That doesn't mean they should all necessarily be rejected, but it's risky to just define it, IMO, as "whatever GHC does today"
09:04:10 <thoughtpolice> Obviously though, the Report does fail to talk about like, the dozens of extremely common ones we use all the time, no doubt.
09:05:31 <thoughtpolice> You could easily add like 20 low-complexity extensions into the Report at very little relative cost, and increase usability a lot. But some of the bigger ones that change how we write Haskell today are still risky, IMO. Maybe once PhD students move onto something else it'll look differently, of course :)
09:06:15 <MarcelineVQ> -XJustDoTheRightThingEveryTime
09:06:50 <CaleNYC> Well, I suppose there's the risk of describing something precisely which will change later.
09:07:22 <merijn> thoughtpolice: Oh wait...I suppos callstack won't let me trace where I receive an async exception?
09:07:44 <CaleNYC> But I don't think GHC should feel too compelled to stick to what the Report says either.
09:07:53 <thoughtpolice> merijn: Oh, no, I don't think so.
09:08:00 <merijn> thoughtpolice: Well bollocks...
09:08:23 <merijn> Somehow an exception is travelling all the way up to the "uncaught" handler and I can't figure out which thread is the source...
09:09:49 <thoughtpolice> CaleNYC: Right. I think there are some that have proven themselves by that metric, and others that haven't, even if they're really useful today. I don't think GHC should necessarily stick to the report by the book, I do think it should help us figure out what the report is, instead. I just don't think we should define "Haskell" as "GHC", no matter how much
09:09:49 <thoughtpolice> we want to.
09:10:58 <thoughtpolice> (And I'm personally hoping to put my money where my mouth is, and support the addition a lot of relatively low-cost extensions, and even some that are pretty obvious even if technical - like RankNTypes)
09:11:18 <merijn> \o/
09:11:24 <merijn> <3 RankN
09:11:27 <CaleNYC> thoughtpolice: That's fair enough. Haskell is a more abstract thing than any given implementation. It's just... we don't have many other implementations to go off of when describing what Haskell is at the moment.
09:11:43 <merijn> How about non-existential GADTs in the report? :>
09:11:52 <thoughtpolice> You mean GADTSyntax?
09:12:25 <merijn> thoughtpolice: No, I want GADTs in general, but afaik the main reason not to add those is the fact that it'd require ExistentialQuantification which is a bit controversial?
09:12:37 <merijn> Although, yes, add GADTSyntax to be accepted by default
09:12:46 <merijn> I think GADTSyntax is superior for teaching beginners
09:12:49 <thoughtpolice> Which, if so: absolutely. Maybe I can wage a war to propose GADT syntax is preferred in the report.
09:13:20 <merijn> thoughtpolice: I'd love to have GADTs in general in the report, but GADTSyntax would already be a big win, IMO
09:13:24 <thoughtpolice> merijn: I don't think EQ is particularly controversial, given it actually does have several implementations. So I'm not sure what you mean by non-existential GADTs, just ones that don't mention EQ variables?
09:13:36 <merijn> thoughtpolice: Yeah
09:13:41 <hpc> the biggest advantage is being able to put a type signature next to a constructor
09:13:53 <thoughtpolice> hpc: Yes, it's much more syntactically consistent.
09:14:03 <thoughtpolice> (And I seriously would support having it be the 'enshrined' data syntax)
09:14:06 <merijn> For all the talk off beginner-friendliness GADTSyntax is clearly more beginner friendly and unambiguous than the current one
09:14:33 <merijn> Defining that as the norm and keeping the current syntax as shortcut/syntactic sugar
09:14:52 <EvanR> silly i cant define := operator
09:15:28 <thoughtpolice> merijn: GADTs are a mixed one for me. I could probably lean on the side of adding them, but with that comes type equality. So, that changes Haskell quite a bit. However, GADTs by themselves seem relatively well understood, and are useful outside many of our other super-fancy mumbo jumbo extensions.
09:15:38 <thoughtpolice> So, I would probably put in a yes, I think.
09:16:01 <merijn> EvanR: Sure you can, it just has to be a constructor
09:16:21 <EvanR> im trying to get it to be :: IORef a -> a -> IO ()
09:16:25 <thoughtpolice> Obviously all statements by Me® in this IRC Channel™ are not necessarily endorsements or direct commitments. Viewer discretion advised.
09:18:16 <hpc> i would be curious to see what GADTSyntax without GADTs would do to beginners
09:18:27 <hpc> namely, if they would naturally deduce that GADTs make perfect sense
09:28:11 <jle`> GADT syntax is nice, but i'm not sure if it's best for teaching purposes.  normal syntax makes pattern matching more visceral/visible
09:30:43 <merijn> jle`: It also confuses people about which part is constructor and which part is types
09:31:02 <merijn> I often use GADTSyntax to deconfuse that mixup
09:33:12 <nitrix> Can you get RankN polymorphism without the haskell extensions?
09:33:31 <paolino> hello, does anyone have a set of couples of contrived lambda calculi expressions which are alpha equivalent, to test an implementation ?
09:33:33 <nitrix> (Like, is it feasible)
09:35:09 <ggole> paolino: take any term without shadowing bindings, rename the vars?
09:36:16 <BernhardPosselt> oh man, haskells weird symbols are making things harder to understand than needed
09:36:25 <BernhardPosselt> <$> <*> wth :)
09:36:36 <hpc>  those two will soon become your new best friends
09:36:59 <jle`> i remember thinking the same way when i learned about + and - and x
09:37:15 <jle`> back in the ol' days
09:37:17 <paolino> ggole, (that's not lazy) , is that all is possible to make them complex ?
09:38:04 <paolino> ggole, it seems to me I can easily fail in that
09:38:56 <jle`> just get a normal complicated lambda expression and "s/x/y"
09:38:58 <ggole> Fail in what, producing complex expressions?
09:39:02 <jle`> (jk)
09:39:34 <paolino> break equivalents 
09:40:00 <paolino> fail in keep equivalence
09:40:56 <ggole> Er, isn't that way you are trying to test?
09:41:00 <ggole> *what
09:41:36 <enthropy> nitrix: you could probably have a preprocessor that takes f g = (g 'x', g ()) (or whatever needs RankN+a type signature) and replaces it with f g1 g2 = (g1 'x', g2 ()), and does that all the way back up to main
09:42:31 <nitrix> I see.
09:43:13 <paolino> ggole, I'm not sure I have a simple algorithm to create equivalents, I will think more about it, I've tried to avoid it
09:44:18 <enthropy> but I think it's debatable to say "I can mechanically rewrite code to avoid an extension" means that the extension "exists" in the subset of the language without the extension
09:44:30 <ski> merijn : .. the ordinary `data' syntax may make more sense to people who've seen BNF (with its distinction between terminals / tokens, and nonterminals / syntactic categories)
09:45:05 <ski> enthropy : it's also important to note whether such a rewriting would be *local* or not
09:47:58 <ski> one example could be allowing synonyms like `type NatTransf f g = forall a. f a -> g a', but still not (necessarily) allow higher-rank types. so one can only use `NatTransf f g' as the whole type in a type signature, and in the result type of a function type, but not in the argument type
09:48:10 <ski> (and not inside other type constructors)
09:48:21 <ski> this would be "mere convenience"
09:49:08 <ski> (just as allowing `exists' syntax in argument type positions, as iirc LHC allowed, is also "mere convenience")
09:55:26 <jle`> enthropy: it might not be possible to determine all of the potential types you'd be using 'f' with, right?
09:55:50 <jle`> s/'f'/'g'
09:56:31 <jle`> s/'f'/'g'
09:58:46 <rnhmjoj> the package I've been using for random numbers in my password generator doesn't build anymore. it seems all the crypto RNG provide a bytes api but I would like a `randomR` function. Is there something like it?
09:59:00 <enthropy> jle`: I think it might be possible, but I think it gets in the way of compiling things separately (which is pretty much what ski was saying about the rewriting not being *local*)
10:00:02 <merijn> ski: I'm not campaigning against the regular syntax, I understand it's origin and why it makes sense. I'm just saying that as far as I can see allowing GADTSyntax by default has only upsides
10:00:04 <enthropy> f g a b = (g a, g b) -- for example, with 'a' and 'b' becoming types that are not even defined at the point we compile the module that defines f
10:01:01 <enthropy> jle`: but maybe it doesn't matter that 'a' and 'b' have unknown types, but instead that they are two potentially different ones
10:02:41 <hpc> merijn: oh, when you mentioned that inequality on types was undecidable it got me thinking
10:03:08 <hpc> merijn: would it be a valid proof of undecidability to use Void as a falsish type and () as a truish type, then use type inequality to create NAND?
10:03:41 <hpc> (which you can then compose into some sort of turing machine)
10:04:14 <hpc> or does that make no sense at all
10:04:21 <merijn> No clue, I'm not that good :)
10:04:25 <hpc> heh
10:05:45 <merijn> I vaguely understand why, but not good enough to explain it :p
10:05:54 <enthropy> hooray for tutorials for libraries intended to be used with qualified imports that neglect to give you the imports
10:08:23 <sm> love that :)
10:08:42 <hpc> merijn: oh no wait, i just realized i am an idiot - having type inequality is the last step to first-order logic which is undecidable
10:11:50 <merijn> Anyway, enough hacking for me. Time for food and games :)
10:25:06 <dolio> nitrix, enthropy: Rank-n types fundamentally increase the strength of a theory. You cannot elaborate all uses of them into something without rank-n types.
10:32:47 <t7> is there a function for   f x y = Set.intersection x y /= Set.empty ?
10:33:10 <dolio> In something like Haskell, maybe it doesn't matter, because you can do everything some other way, since the language is Turing complete. But System F is not a conservative extension of the simply typed lambda calculus, for instance.
10:36:53 <KaneTW> t7: there's no predefined function
10:37:07 <KaneTW> :t ((.).(.)) S.null S.intersection
10:37:09 <lambdabot> Ord a => S.Set a -> S.Set a -> Bool
10:42:20 <orion> Let's say I have a web server which accepts thousands of requests per second. Could this operation be a bottleneck?: B.pack . show . statusCode . responseStatus -- I'm specifically worried about 'show'.
10:44:08 <hpc> depends on what else you're serving
10:44:45 <hpc> but it's very unlikely that this line is going to be the main offender
11:00:51 <ntnt> how does catchError work? it seems like it needs to "intercept throwError" which seems like a very stateful operation
11:01:59 * hackagebot elm-bridge 0.2.2.0 - Derive Elm types from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.2.2.0 (AlexanderThiemann)
11:02:11 <jle`> ntnt: it's a typeclass method so it's implemented differently for every instance
11:02:17 <jle`> (if you're referring to the one from mtl)
11:02:18 <cocreature> ntnt: depends on the instance, for Either it simply has to pattern match
11:03:15 <jle`> ntnt: http://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Error-Class.html#line-107
11:04:19 <cocreature> for IO it uses catch internally which is a primitive (or a tiny wrapper around a primitive)
11:05:05 <ntnt> jle`: that was very enlightening
11:06:13 <jle`> and the implementation for ExceptT --
11:06:15 <jle`> http://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.Except.html#catchE
11:36:00 <Lovepon> Cale: I've been using Reflex wrong.
11:36:05 <Lovepon> Cale: :/
11:36:13 <Lovepon> Cale: Reflex-dom, that is.
11:36:52 <Lovepon> Cale: Actually, no, I still haven't solved my problem.
11:37:07 <Baran__> Is there a way to "override" a function I have defined myself. I tried it with instance, but it doesn't find my function. My compiler gives me the not in scope error. 
11:37:21 <Zemyla> Lovepon: Your Reflex is 10 + half your level + your Dex or Int score + your amulet bonus. :P
11:37:26 <Lovepon> Cale: Oh, right, I remember now. I'm really sorry that I'm being confusing. Lol.
11:37:43 <Lovepon> Zemyla: get to my level.
11:37:46 <ntnt> https://www.haskell.org/hoogle/?hoogle=runRWST why is the output m (a, s, w) as opposed to say, (w, s, a) since it's rWST a
11:37:47 <Lovepon> #rekt
11:37:56 <Lovepon> Zemyla: Oh, it's actually get *on* my level.
11:38:02 <Lovepon> Zemyla: i'm stupid now.
11:38:16 <Lovepon> Writer State?
11:38:22 <Lovepon> Reader, Writer, State?
11:38:57 <Lovepon> Yay, I was correct! :D
11:39:34 <Lovepon> ntnt: I find it weird myself.
11:39:50 <Zemyla> Okay, I don't have an answer to this - why is (,) w not a Monad, when it is self-evidently a monad?
11:40:08 <Lovepon> ntnt: For example, the state monad is `a -> (a, s)`
11:40:10 <jle`> Lovepon: it's probably the convention that the 'a' is first
11:40:10 <Lovepon> Err
11:40:23 <jle`> as to which of 's' and 'w' go first, that's probably a matter up for debate
11:40:23 <Lovepon> statusbot: `s -> (a, s)`
11:40:33 <Lovepon> jle`: But! If we consider the writer monad.
11:40:43 <geekosaur> ...almost as organized as I am today... >.>
11:40:50 <Lovepon> jle`: The writer monad is (w, a)
11:40:53 <jle`> writer returns (a, w), and state returns (a, s)
11:40:55 <Lovepon> jle`: For obvious reasons, ofc.
11:41:16 <Lovepon> jle`: Writer is (w, a), unless things changed?
11:41:26 <jle`> yes, but we're talking about runXX
11:41:35 <Zemyla> :t runWriterT
11:41:36 <lambdabot> WriterT w m a -> m (a, w)
11:41:43 <Lovepon> Oh.
11:41:50 <jle`> http://hackage.haskell.org/package/transformers-0.5.2.0/docs/Control-Monad-Trans-Writer-Lazy.html#v:runWriter
11:41:52 <Lovepon> I'll agree with jle` then.
11:41:54 <jle`> ah yeah, forgot about :t
11:41:54 <xa0> :t runReaderT
11:41:55 <Zemyla> It's so it spells "maw" :P
11:41:55 <lambdabot> ReaderT r m a -> r -> m a
11:42:16 <jle`> runWriter returns (a, w), runState returns (a, s), so runRWS should be (a, ...)
11:42:16 <geekosaur> careful, in that direction lies i m a s t a b u
11:42:26 <jle`> but i think it's up to debate about if s or w comes first
11:42:29 <Lovepon> jle`: I agree with that.
11:42:58 <Lovepon> jle`: Question though, is what's with the convention. Why have it at first?
11:42:58 <Zemyla> geekosaur: That's still the most hilarious thing that's happened in Lens.
11:43:21 <ski> Baran__ : what do you mean by "override" ?
11:43:26 <Lovepon> Zemyla: Errr, Monoid w => (,) w is a monad?
11:43:44 <Lovepon> > ("a", ()) >> ("b", ())
11:43:45 <lambdabot>      No instance for (Monad ((,) [Char])) arising from a use of ‘>>’
11:43:46 <lambdabot>      In the expression: ("a", ()) >> ("b", ())
11:43:50 <Lovepon> WTF?
11:43:58 <ski> `(,) w' should be a monad, if `Monoid w'
11:44:06 <Zemyla> Yeah, I know, right?
11:44:17 <Lovepon> ski: Look what just hapepned...
11:44:22 <Lovepon> WTF?
11:44:22 <jle`> it is a monad
11:44:26 <jle`> but there's no Monad instance in base
11:44:28 <jle`> it's kind of weird
11:44:39 <jle`> one of those weird cases of monad-but-not-Monad
11:44:46 <Lovepon> jle`: My problem is that a shittonne of tutorials mention tihs!
11:44:51 <Lovepon> "The most basic writer monad is..."
11:45:16 <jle`> an Applicative instance snuck in for some reason though
11:45:20 <ski> Lovepon : to get `Monad (rho ->)', you have to import `Control.Monad.Reader', but for some reason `Monad (w,)' (under condition `Monoid w') is not in `Control.Monad.Writer'
11:45:29 * ski has noticed this before
11:45:29 <Baran__> With "override" I mean that my function should work exceptional for the input with the type Char
11:45:31 <jle`> which is really odd if you consider that Monad has been around longer than Applicative
11:45:50 <jle`> so it's like, Monad came out, and people were like, "let's make a (,) w" instance, and nobody ever really got around to it
11:45:55 <ski> Baran__ : and in other cases ?
11:46:01 <jle`> and then Applicative came out and people were like "hey" and so now we have an Applicative instance
11:46:18 <jle`> i'm not sure how this really unfolded but it's kind of weird to me
11:46:37 <Lovepon> jle`: People have been referencing that as a writer monad for eternity though.
11:46:42 <Lovepon> Which is what's really weird.
11:46:58 * ski has been referencing it as the "output monad", fwiw ..
11:47:07 <monochrom> Most tutorial writers do not check their informations sources.
11:47:19 <Lovepon> monochrom: They're not exactly wrong.
11:47:20 <ski> (or s/the/a/, perhaps)
11:47:28 <jle`> well, it's technically correct to call it a writer monad
11:47:32 <jle`> it's a monad, not a Monad
11:47:47 <ski> well, i call `Reader r' the "environment monad" :)
11:47:51 <Lovepon> I did not say the Writer Monad.
11:47:55 <ski> (after Wadler, iirc)
11:47:56 <Lovepon> ski: I would too.
11:48:14 <jle`> i wonder if it's too late to sneak this in by ghc 8.0 ?
11:48:22 <Lovepon> ski: Though, if you think about it, a State + Reader monad seems more like an environment monad.
11:48:23 <Lovepon> :P
11:48:37 <Lovepon> Or just State itself.
11:48:47 <jle`> i've been complaining about this for years but even looked into how to do something about it
11:49:04 <jle`> s/even/never even
11:49:05 <ski> Lovepon : the essential part is the ability to do local shadowings
11:49:16 <Lovepon> Hmmm
11:49:29 <Zemyla> Lovepon: State being s -> (a, s) lets you do things like this:
11:49:36 <Zemyla> :t \l s -> state $ (id :: LensLike' f s b -> LensLike' f s b) l (runState s)
11:49:37 <lambdabot> MonadState s m => LensLike' ((,) a) s b -> State b a -> m a
11:49:53 <Lovepon> Okaaayyyyyy... haskell wiki "all about monads"
11:49:58 <Lovepon> Example type:
11:50:00 <Lovepon> Writer [String a] 
11:50:03 <Lovepon> > [String a]
11:50:04 <lambdabot>      Not in scope: data constructor ‘String’
11:50:04 <lambdabot>      Perhaps you meant one of these:
11:50:04 <lambdabot>        variable ‘trying’ (imported from Control.Exception.Lens),
11:50:04 <Lovepon> ggwp
11:50:24 <Lovepon> Woops, I can't greentext here. :|
11:50:35 <Zemyla> @unmtl Writer [String]
11:50:35 <lambdabot> Plugin `unmtl' failed with: `Writer [String]' is not applied to enough arguments, giving `/\A. (A, [String])'
11:50:41 <Baran__> Let me descripe the function real quick. I have defined my own data BinaryTree and a function called flattenTree. For integers it should return a normal List. This should happen for every other Typ too with the exceptions of Chars. They should be returned as a String. At the moment it is doing this : ["a"] ++ ["e"], but I want it to add them like this "a" ++ "e". That is why it should be an exception when the BinaryTree has Chars i
11:50:47 <ski> @unmtl Writer [String] a
11:50:47 <lambdabot> (a, [String])
11:51:05 <ski> Baran__ : cut off near ".. That is why it should be an exception when the BinaryTree has Chars i"
11:51:16 <Lovepon> ski: That looks impossible though. '_'
11:51:25 <Lovepon> ski: To typeclass.
11:51:28 <Lovepon> (a, [String])
11:51:48 <ski> Lovepon : well, imho both `Writer' and `State' use the wrong order in the pair
11:51:53 <ski> as do `random' and friends
11:51:56 <Lovepon> ski: True.
11:51:56 <ski> @type random
11:51:57 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
11:52:02 <ski> @type mapAccumL
11:52:03 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:52:08 <ski> @type mapAccumR
11:52:09 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:52:38 <ski> those two latter use the right order (i didn't recall)
11:53:00 <ReinH> Baran__: a String *is* a list of Char
11:53:08 <ski> (oh, but if you try to interface them with `State', then you still have to swap, because `State' uses the wrong order .. that's what i was remembering)
11:53:28 <ReinH> so flattenTree :: BinaryTree a -> [a] would be consistent with both.
11:53:49 <sm> some module I'm importing is bringing a typeclass instance into scope, and I'm having trouble finding which one - any tips ?
11:54:24 <ski> Baran__ : if it's doing `["a"] ++ ["e"]', then that sounds like you have a `BinaryTree String', not a `BinaryTree Char'
11:54:34 <jle`> the magic of orphan instances
11:54:46 <ReinH> Baran__: but your function cannot be overriden for particular types, that is not allowed.
11:54:48 <monochrom> Baran__: I have trouble believing part of what you said. If your current function already outputs like [1,3,2] for Int, then it should also output like ['a','e','b'] for Char. But then ['a','e','b'] = "aeb" which is exactly what you want. But you claim you get ["a","e","b"]. There is an internal contradiction in what you said.
11:54:51 <Zemyla> There should be a localS function, defined like this:
11:54:54 <geekosaur> sm, start ghci, import modules up to the one doing it, :info some relevant type, import the problem module, :info that type again
11:54:56 <Zemyla> :t \f m -> state (\s -> (s, f s)) >>= (\s -> m >>= (\a -> state $ const $ (a, s)))
11:54:57 <lambdabot> MonadState s m => (s -> s) -> m b -> m b
11:55:22 <Zemyla> Basically, it acts like local for the reader monad.
11:55:24 <ReinH> Baran__: your function cannot take BinaryTree Int to [Int] but BinaryTree Car to [String]. That would be a type error.
11:55:27 <ski> Baran__ : anyway, "This should happen for every other Typ too with the exceptions of Chars." is usually a mistake .. there are ways to get around it, though
11:55:30 <ReinH> s/Car/Char
11:55:59 <Lovepon> Imagine how scary it is if the world we lived in was programmed in Haskell.
11:56:37 <Lovepon> Like, instead of us moving, or doing any actions, we're actually being destroyed every planck second, and  the you back then is no longer you.
11:56:39 <Lovepon> '_'
11:56:56 <monochrom> How do you know that this is not already happening?
11:56:58 <hxegon> Lovepon: I hate to say it, but... We might already be living in that world.
11:57:01 * hackagebot random-variates 0.1.4.0 - "Uniform RNG => Non-Uniform RNGs"  https://hackage.haskell.org/package/random-variates-0.1.4.0 (kpratt)
11:57:04 <ReinH> Lovepon: at some level there is no mutation in the universe, just state transitions, but this is off topic.
11:57:06 <tdammers> also, you wouldn't exist at all until some part of the world tried to interact with you
11:57:08 <sm> geekosaur: I can see which module of mine brings it into scope, but darned if I can see how. Is it part of the magic of orphan instances that they get imported (and reexported) "invisibly" ?
11:57:23 <geekosaur> yes. you can't control instance import or export
11:57:24 <Lovepon> ReinH: Hahaha, I just wanted to make a joke. :P
11:57:31 <sm> ah
11:57:39 <Lovepon> ReinH: That sounds interesting. Do you have another channel where you talk about that kind of stuff?
11:57:45 <xa0> help we're trapped in a state monad
11:57:52 <hxegon> ReinH: exactly. If there are no useful subsections of time smaller than a planck second, than aren't we just in a film strip of 3 dimensional cross sections of time?
11:58:02 <ReinH> #haskell-blah I suppose, but I'm not in there.
11:58:24 <Baran__> well my function does flatten (Node x y z) = flatten y ++ [x] ++ flatten z. I think the [x] is the problem. As far as I read from your answers it means that the type would be String, so ["a", "e"] is the answer
11:58:25 <Lovepon> #haskell-blah is TLS-only though. :|
11:58:31 <cocreature> don’t forget #haskell-offtopic
11:59:08 <ReinH> Baran__: No, it is not.
11:59:17 <Baran__> *x is the actual value and y z have type BinaryTree
11:59:22 <ReinH> [] ++ ['c'] ++ [] = "c", not ["c"]
11:59:48 <ReinH> If you are flattening a BinaryTree Char, you will get a String based on what you've said.
11:59:50 <ReinH> Not a [String].
12:00:05 <monochrom> > [] ++ ['c'] ++ ([] ++ ['d'] ++ [])
12:00:07 <lambdabot>  "cd"
12:00:10 <monochrom> works for me
12:00:15 <Zemyla> Baran__: Also, you should be making it an instance of Foldable.
12:00:28 * sm finds the cause: import Text.Regex.TDFA ((=~))
12:00:32 <Lovepon> Hmmm
12:00:35 <Zemyla> That way, you get your flatten function automatically as toList.
12:00:39 <Lovepon> :t foldM
12:00:40 * ski . o O ( <https://ro-che.info/ccc/4> )
12:00:41 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
12:00:51 <Lovepon> Oh, right, foldM is sequence . foldl, right?
12:00:58 <ReinH> @src foldM
12:00:58 <lambdabot> foldM _ a []     = return a
12:00:58 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:01:05 <Lovepon> :t sequence . foldl
12:01:06 <lambdabot> (Foldable t, Traversable ((->) a)) => (a -> a1 -> a) -> t a1 -> a -> a
12:01:11 <ReinH> Can you express that as sequence . foldl ?
12:01:18 <Lovepon> Weird.
12:01:22 <Lovepon> Errr
12:01:24 <Lovepon> Oh
12:01:46 <Lovepon> :t (\f x t -> sequence $ foldl f x t)
12:01:48 <lambdabot> (Monad m, Foldable t1, Traversable t) => (t (m a) -> a1 -> t (m a)) -> t (m a) -> t1 a1 -> m (t a)
12:01:59 <ski> Zemyla : perhaps not before learning about type classes ?
12:02:06 <Lovepon> :t foldl
12:02:08 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:02:11 <Zemyla> foldr c n (Node x y z) = foldr c (c y $ foldr c n z) x
12:02:31 <ski> Baran__ : perhaps you should just paste your code ?
12:02:33 <ski> @paste
12:02:33 <lambdabot> Haskell pastebin: http://lpaste.net/
12:03:03 <Lovepon> Hmmmm
12:03:48 <Baran__> Right. I found the problem. Sry everyone. I didn't know that there was a difference between " and '. 
12:04:43 <Lovepon> Did I mean mapm...?
12:04:48 <Lovepon> s/mapm/map/
12:04:56 <Lovepon> Probably not either.
12:05:35 <Lovepon> :t \f x ys -> foldl (\y x -> y >>= f x) x ys
12:05:36 <lambdabot> (Monad m, Foldable t) => (a -> a1 -> m a1) -> m a1 -> t a -> m a1
12:05:44 <ski> ReinH : `foldM f z as = foldr (\x rec_xs z -> f z x >>= rec_xs) return as z'
12:05:49 <Lovepon> It's still not correct!? wtf?
12:06:03 <ReinH> ski: I was asking Lovepon :)
12:06:11 <ski> Baran__ : right, the former delimits `String's, the latter `Char's
12:06:18 <Lovepon> Oh, right.
12:06:20 <Lovepon> I'm stupid.
12:06:24 <Lovepon> It's foldr, not foldl.
12:06:39 <ski> ReinH : oh, i didn't notice. sorry
12:06:50 <ReinH> ski: I need an indicator for socratic mode...
12:07:22 <ski> (i thought you were just asking the channel in general)
12:07:23 <Lovepon> :t \f x ys -> foldr (\x y -> y >>= f x) x ys
12:07:24 <lambdabot> (Monad m, Foldable t) => (a -> a1 -> m a1) -> m a1 -> t a -> m a1
12:07:33 <ReinH> ski: np :)
12:07:39 <Lovepon> ... im just going to go to sleep. ;~;
12:07:54 <Lovepon> go to bed
12:08:47 <ski> Lovepon : .. anyway, that does the effects in the wrong order
12:09:02 <Lovepon> ski: The foldr one?
12:09:10 <ski> Lovepon : your `foldr' version, yes
12:09:17 <Lovepon> ski: Really?
12:09:37 <Lovepon> Hmmm
12:09:42 <Lovepon> You're right.
12:11:03 <ski> > execWriter $ (\f x ys -> foldr (\x y -> y >>= f x) x ys) (\n () -> tell [show n]) (tell ["!"]) [0,1,2,3]
12:11:04 <lambdabot>  ["!","3","2","1","0"]
12:12:18 <ski> > execWriter $ (\f z as -> foldr (\x rec_xs z -> f z x >>= rec_xs) return as z) (\() n -> tell [show n]) () [0,1,2,3]
12:12:19 <lambdabot>  ["0","1","2","3"]
12:12:27 <ski> > execWriter $ foldM (\() n -> tell [show n]) () [0,1,2,3]
12:12:28 <lambdabot>  ["0","1","2","3"]
12:12:40 <Lovepon> :t \f x ys -> foldl1 (>=>) ys $ x
12:12:41 <lambdabot> (Monad m, Foldable t) => r -> r1 -> t (r1 -> m r1) -> m r1
12:12:53 <Lovepon> wtf did I just write...?
12:13:14 <Lovepon> Wtf is r even, lol
12:13:43 <ski> Lovepon : `foldM' is at some conceptual level more like `foldl' than `foldr'. however, it's not quite like `foldl', so it can't be expressed directly through it. above, i was using the "leaned so far right they came back left" trick, modified to account for the monadic effects
12:14:00 <ski> (you forgot to use `f')
12:14:00 <Lovepon> ski: Hmmmm
12:14:13 <Lovepon> ski: oh.
12:14:19 <ski> @where evolution
12:14:19 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
12:14:20 <Lovepon> right.
12:14:26 <ski> see that ^ for the "leaned ..." part
12:14:33 <Lovepon> :t foldl
12:14:35 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:15:13 <Lovepon> ski: I'm quite sleepy right now, (3:14), I'll bookmark it though. Thanks.
12:15:19 <xa0> pi!
12:15:20 <ski> ok
12:15:27 <ski> > pi :: CReal
12:15:29 <lambdabot>  3.1415926535897932384626433832795028841972
12:15:37 <ski> > showCReal 100 pi
12:15:39 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
12:16:13 <Lovepon> omg
12:16:17 <Lovepon> n+k patterns exist?
12:16:22 <ski> they used to
12:16:26 <Lovepon> ski: </3
12:16:40 <Lovepon> :(
12:16:47 * Lovepon feels hurt
12:16:50 <simpson> Lovepon: There were issues.
12:17:17 <Lovepon> ski: This one? -- using foldr to simulate foldl
12:17:44 <ski> the most ad hoc part about `n+k' patterns would be that it would insist on the number being non-negative
12:18:05 <ski> Lovepon, yep
12:18:07 <Lovepon> ski: Being non-negative is a requirement to use that?
12:18:34 <ski> no, `n+k' is something else
12:18:43 <Lovepon> fac = foldr (*) 1 . enumFromTo 1
12:18:46 <ski> not related to that point about simulating `foldl' with `foldr'
12:18:52 <Lovepon> ski: I know. :P
12:19:01 <Lovepon> I like 
12:19:02 <Lovepon> fac = foldr (*) 1 . enumFromTo 1
12:19:18 <drvdev> trying xmonad for the first time, launched firefox and the ctrl+pgup and ctrl+pgdn to switch tabs does not work anymore. Does anyone know how I can fix this?
12:19:19 <Lovepon> The iterative haskell programmer though. LOL.
12:19:21 <ski> anyway, in `fact (n+1) = ..n..', this will only match if `n' is nonnegative
12:19:32 <Lovepon> ski: That's so wrong.
12:19:38 <Lovepon> ski: :/
12:19:58 <Lovepon> > iterative one-liner
12:19:59 <lambdabot>      Not in scope: ‘iterative’
12:20:00 <lambdabot>      Perhaps you meant one of these:
12:20:00 <lambdabot>        ‘iterate’ (imported from Data.List),
12:20:00 <exio4> \n -> product [1..n] -- this is nicer :P
12:20:03 <ski> Lovepon : elaborate ?
12:20:18 <Lovepon> ski: Why would it only match if it's nonnegative?
12:20:28 <ski> exio4 : that's the "Tenured professor" version
12:20:31 <infinity0> anyone know the lens operator to turn a Lens s a -> State s r -> State a r ?
12:20:43 <ski> Lovepon : because the idea was to simulate matching on Peano naturals
12:20:56 <Lovepon> ski: I see, thought so.
12:21:21 <ski> otherwise, i think it's a nice idea. only that there shouldn't just be that special case
12:21:36 <joeyh> is there a -fno-warn- that prevents warning about import Foo hiding (bar) when bar is not exported by the current version of Foo?
12:21:38 <Lovepon> ski: Wait, does that mean {n-k} wouldn't work?
12:21:47 <ski> `f ([0,b,c,3] ++ xs) = ...' ought to be possible
12:21:51 <ski> (it is possible in Mercury)
12:22:01 * hackagebot table-layout 0.1.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.1.0.0 (muesli4)
12:22:05 <ski> Lovepon : i'm not sure what you mean
12:22:32 <ski> (iirc, it's also possible in Erlang, as a special case .. however the version in Mercury is extendable, in a natural way)
12:22:51 <Lovepon> ski: (n-k), I mean. It only works specifically for (n+k)?
12:23:21 <ski> Lovepon : i would be surprised if `n - (- 2)' worked, but perhaps they thought about that ..
12:23:39 <Lovepon> dmiles: Why would you do that though lol
12:23:40 <ski> Lovepon : i've only heard about `+', though
12:24:04 <Lovepon> ski: I'm waiting for `f n n` though.
12:24:13 <Lovepon> If both arguments are the same.
12:24:14 <ski> Lovepon : it's in Erlang, and Mercury
12:24:15 <Lovepon> :|
12:24:25 <Lovepon> ski: I see.
12:24:26 <ski> (and Prolog .. *obviously*)
12:24:48 <ski> in Erlang, you can also match on a previously-bound variable, which can sometimes be nice
12:26:13 <ski> (but you mast take case when writing a pattern, that you don't write an identifier that's already in scope, unless you meant to match on it. and in the other direction, to not bring an identifier in scope around a matching with a pattern containing an identically named identifier)
12:26:41 <Lovepon> I see.
12:27:06 <ski> Lovepon : .. another thing in Erlang (which comes from Prolog), which i sometimes miss in Haskell, is the ability to bind an identifier in all branches of a `case', and then use that identifier "afterwards"
12:27:24 <ski> .. also, i'm missing a declaration-level `let' and `case'
12:27:29 <ski> (SML has the former)
12:27:53 <exio4> ski: ++ on the second one, it would be really handy :)
12:28:07 <ski> declaration-level `case' ?
12:28:23 <exio4> let
12:28:27 <ski> ok
12:28:52 <ski> (in SML, it's written `local <private decls> in <public decls> end')
12:29:08 <Lovepon> ski: Like, if it exists in every case, you can bring it up to the higher scope?
12:29:15 <ski> `where' is ok when you just want your local bindings to scope over a single defining equation
12:29:26 <ski> but sometimes you'd like it to scope over multiple definitions
12:29:53 <ski> so you have to resort to awkward `(f,g) = (realF,realG) where realF = ...; realG = ...; ....'
12:30:00 <ski> Lovepon : yes
12:30:09 <ski> consider something like
12:30:13 <ski>   do ...
12:30:23 <ski>      (x,y) <- case ... of
12:30:38 <ski>        ... -> do let x = ...
12:30:48 <ski>                  y <- ...
12:30:54 <ski>                  return (x,y)
12:31:00 <ski>        ... -> do x <- ...
12:31:11 <ski>                  y <- ...
12:31:15 <ski>                  return (x,y)
12:31:19 <ski>      ...
12:31:40 <ski> if we could skip the `return (x,y)'s and the `(x,y) <- ' here, i'd be happy
12:32:46 <ski> (you can also consider a non-monadic version, with something like
12:32:54 <ski>   (x,y) = case ... of
12:33:10 <ski>     ... -> let x = ...
12:33:15 <ski>                y = ...
12:33:20 <Lovepon> http://img-9gag-fun.9cache.com/photo/apqNxqD_700b_v2.jpg
12:33:21 <ski>             in (x,y)
12:33:27 <ski>     ..and so on..
12:33:29 <ski> )
12:33:36 <Lovepon> Code written in a hackathon. Lol.
12:33:48 <ski> and here, it'd be nice if one could instead have a declaration-level `case' :
12:33:52 <ski>   case ... of
12:34:07 <ski>     ... -> x = ...
12:34:11 <ski>              = ...y
12:34:14 <Lovepon> ski: I only realized recently that guards can also be used outside of functions...
12:34:15 <ski> (er)
12:34:18 <ski>            y = ...
12:34:24 <ski>     ..and so on..
12:34:45 <ski> Lovepon : yes, sometimes `foo | blah = ... | otherwise = ...' is useful
12:35:09 <ski> also `case ... of ... | blah -> ... | otherwise -> ...'
12:35:36 * ski sometimes does `case () of () | blah -> ... | bleh -> ... | otherwise -> ...'
12:36:43 <geekosaur> or its modern version, MultiWayIf
12:36:48 * ski nods
12:37:52 * ski has also pondered using `let' in patterns, and `case' in definiendums
12:37:57 <HallaSurvivor> Lovepon, lol
12:40:08 <geppettodivacin> Is there a difference in how `g . f $ x` and `g $ f x` are computed, and is one faster than the other?
12:40:33 <geppettodivacin> I know that semantically, the order of execution is changed, but because functions are pure, the order doesn't matter.
12:40:43 <ski> geppettodivacin : the implementation will probably convert both to the same code
12:41:02 <koala_man> the order of execution isn't defined
12:41:03 <ski> geppettodivacin : i would consider the former, or even `(g . f) x', more elegant
12:41:50 <geppettodivacin> Thanks, ski, koala_man. ski, I agree about the elegance, as well, but was curious if it changed the execution.
12:41:52 <ski> ("because functions are pure, the order doesn't matter" is a non-consequence, the latter doesn't follow from the former)
12:42:07 <ski>   case enumFromTo lo hi of {[] -> nil; n:ns -> cons n ns}
12:42:15 <ski>     | lo > hi   = nil
12:42:35 <ski>     | otherwise = cons lo $ case enumFromTo (succ lo) hi of
12:42:53 <ski>         [  ] -> nil
12:43:03 <ski>         n:ns -> cons n ns
12:43:22 <ski> would be a somewhat roundabout definition of `enumFromTo'
12:43:59 <ski> (it would probably be less noisy here to define an internal loop, i now realize)
12:44:46 <ski> anyway, this follows the same pattern as `f x = ..x..' does : defining a value by what you get when you eliminate on it
12:45:44 <ski> (also cf. "message-dispatching syntax")
12:47:14 <ski> (in the above example, the type of `nil' and the type of the result and second argument of `cons' would be a new skolem, which is also the type of the bodies here)
12:56:12 <ski> geppettodivacin : also, fwiw, nothing wrong with `g (f x)'
12:58:15 <ph88> are GADT the same as dependent typing?
12:58:57 <ski> ph88 : no
12:59:14 <ski> (Haskell, even with extensions, doesn't have dependent typing)
12:59:24 <ski> @where SHE
12:59:24 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
12:59:33 <ski> implements a dependent typing preprocessor for Haskell
12:59:47 <ph88> why are GADT not dependent typing?
13:00:11 <ski> ph88 : with dependent typing, you should be able to express that (a version of) `replicate' returns a list with as many elements as the input
13:01:35 <ski> iow, something like `replicate :: forall a. (n ::) Nat -> a -> Vector n a' should be possible to express
13:01:54 <ph88> that syntax is not familiar to me
13:02:03 <ski> were `Vector n a' is the type of lists with elements of type `a', with length `n'
13:02:12 <ski> `Nat' is the type of natural numbers
13:02:43 <ph88> isn't this always the case ?
13:02:48 <ski> and the `(n ::) Nat -> ..n..' part means that the first input has type `Nat', and that we *name* this input `n', for further use in the return type of the function
13:03:48 <ski> if we don't use the name, then this dependent function type reduces to an ordinary function type
13:04:05 <ski> `(n ::) Nat -> ...', with `...' not using this `n', is the same as `Nat -> ...'
13:04:19 <monochrom> Dependent typing would allow you to say: f True = 'c' :: Char, f False = () :: (). But GADT does not.
13:04:27 <ski> yes
13:04:38 <monochrom> This is why I say:
13:04:40 <ski>   f :: (b ::) Bool -> if b then Char else ()
13:04:45 <monochrom> @quote monochrom poor.man
13:04:46 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
13:04:49 <ski> would be a type signature for monochrom's `f'
13:05:06 <ski> ph88 : makes sense ?
13:05:22 <ph88> what's f ?
13:05:30 <ski> just a function name monochrom selected
13:05:35 <ph88> i see
13:05:46 <monochrom> I should call it john
13:06:01 <ski> (instead of `if b then Char else ()', you could say `case b of True -> Char; False -> ()', which is the general version)
13:06:16 * ski . o O ( "Call me Ishmael." )
13:06:43 <ph88> so the type of output depend on the value of input
13:07:01 <ski> ph88 : so, dependent types allow function result *types* to *depend* on function argument *values*
13:07:03 * hackagebot hakyll 4.8.2.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.8.2.0 (JasperVanDerJeugt)
13:07:09 <ski> ph88 : exactly
13:07:19 <ph88> isn't that a much easier way to say it? :P
13:07:22 <ski> (in mathematics, this is often called a "family")
13:07:52 <ph88> and why is this so hard to do in haskell ? or people didn't want this feature ?
13:08:03 <ski> ph88 : there's also dependent pair type : `((x ::) A,..x..)', where the type of the second component in the pair type can depend on the value in the first component
13:08:20 <ski> ph88 : it's hard to combine with type inference
13:08:43 <ph88> ah ye
13:08:48 <ski> ph88 : also, you'd prefer to only allow terminating computations in the types. otherwise type-checking might not terminate
13:08:59 <ski> note that dependent types allows us to write values inside types
13:09:40 <ph88> and what's the point of GADT's then actually ?
13:09:41 <ski> (`if b then Char else ()' is a type expression, but `b' is a value expression)
13:09:59 <ski> the point of GADTs is to allow "indexed types"
13:10:04 <ski> in this case, indexed by other types
13:10:11 <ph88> what kind of index ?
13:10:30 <ski> instead of defining the type `Maybe a' simultaneously, in a homogenous way, for all types `a'
13:10:57 <ski> we'd like to be able to define e.g. `Expr a', in different ways depending on the shape of the index `a'
13:11:08 <ski>   data Expr :: * -> 
13:11:10 <ski>   data Expr :: * -> *
13:11:12 <ski>     where
13:11:16 <ski>     Val :: a -> Expr a
13:11:45 <ph88> Expr a   took the place of  Maybe a  now ?
13:11:45 <ski>     If :: Expr Bool -> Expr a -> Expr a -> Expr a
13:12:05 <ski>   Less :: Expr Integer -> Expr Integer -> Expr Bool
13:12:24 <ski>     LitInt :: Integer -> Expr Integer
13:12:33 <ski>     Add :: Expr Integer -> Expr Integer -> Expr Integer
13:12:40 <ski> (let's say this suffices)
13:12:44 <ski> ph88 : yes
13:13:14 <ski> so, here we're defining the type `Expr Integer' to have constructors `Val',`LitInt',`Add'
13:13:28 <ski> and the type `Expr Bool' to have constructors `Val',`Less'
13:13:32 <ph88> What's this "If" ?
13:13:37 <ski> just a constructor
13:13:57 <ski> well, `If' is also a constructor of `Expr Integer' and `Expr Bool'
13:14:22 <ski> finally, for all types `a' other than `Integer' and `Bool', `Expr a' has just the constructors `Val' and `If'
13:14:26 <ski> we can now write
13:14:33 <ski>   eval :: Expr a -> a
13:14:39 <ski>   eval (Val a) = a
13:15:10 <ski>   eval (If eTest eThen eElse) = if eval eTest then eval eThen else eval eElse
13:15:23 <ph88> why is "If" a constructor for Integer ?
13:15:29 <ski>   eval (Less eM eN) = eval eM < eval eN
13:15:36 <ph88> eh Expr Integer i mean
13:15:40 <ski>   eval (LitInt n) = n
13:15:51 <ski>   eval (Add eM eN) = eval eM + eval eN
13:16:43 <byorgey> ph88: if you apply  If  to an  Expr Bool  and two  Expr Integer  values, then you get an  Expr Integer
13:17:17 <ski> ph88 : well, here we want e.g. `If (Less (LitInt 2) (LitInt 3)) (LitInt 4) (Add (LitInt 5) (Val n))' to represent an expression `if 2 < 3 then 4 else 5 + n'
13:18:06 <ski> ph88 : `If :: Expr Bool -> Expr a -> Expr a -> Expr a' holds for all `a', therefore, in the case where we set `a' to `Integer', we get `If :: Expr Bool -> Expr Integer -> Expr Integer -> Expr Integer'
13:18:36 <ski> this is similar to how since `Just :: a -> Maybe a', we also know `Just :: Integer -> Maybe Integer'
13:18:40 <ski> @type Just
13:18:42 <lambdabot> a -> Maybe a
13:19:27 <ski> @type [Just,return . (+ (1 :: Integer))]
13:19:29 <lambdabot> [Integer -> Maybe Integer]
13:20:15 <ph88> yes i get this very basic stuff, but not what GADT's add on top
13:20:21 <ski> ph88 : anyway, GADTs are useful in many cases
13:20:53 <CaleNYC> Does anyone know how to get reify info from TH for a class associated data type, for a given instance?
13:21:08 <ph88> can you tell me what GADT's do without diving into code ?
13:21:58 <ski> ph88 : they allow one to discover (at run-time) the type that a type variable is in the specific case
13:22:15 <ski> or, to discover at run-time that two type variables are really the same type
13:22:28 <aarvar> ph88: they're existentials + type equalities
13:22:39 <ph88> data Expr :: * ->     <-- was this a typo ?
13:22:43 <ski> yes
13:22:58 <ski> @kind Maybe
13:22:59 <lambdabot> * -> *
13:23:05 <ski> (the kind is the same)
13:23:51 * ski idly wonders whether ph88 has grokked existentials yet
13:23:56 <ph88> if i pattern match on  Just   i'm also "discovering" that it's type is Just ..
13:24:02 <ski> `Just' is not a type
13:24:29 <ski> (it's a data constructor)
13:24:41 <ski> let's take a very simple example
13:25:05 <ski>   data IsBool :: * -> *
13:25:06 <ski>     where
13:25:19 <ski>     TheBool :: Bool -> IsBool Bool
13:25:22 <ski> we can write
13:25:35 <ski>   foo :: IsBool a -> Bool
13:25:41 <ski>   foo (TheBool b) = b
13:25:54 <ski> at the surface of it, the type signature promises to work for every type `a'
13:26:23 <ski> but, as we're pattern-matching on the `TheBool b' pattern, we discover that, in *this* case, `a' is actually the type `Bool'
13:26:45 <ski> a variant of this would be
13:26:47 <aarvar> I think you messed up your example
13:26:59 <aarvar> the type a isn't used anywhere anyway
13:27:07 <ski> the example works
13:27:10 <ski>   bar :: IsBool a -> a
13:27:15 <ski>   bar (TheBool b) = not b
13:27:24 <ph88> are you sure the type is Bool and not IsBool
13:27:32 <ski> the type of what ?
13:27:54 <ski> `b' ? `bar' ? `TheBool' ?
13:27:59 <Sonolin> can anybody explain why this code is swapping my windows around (from what I understand, the order of the windows shouldn't change... but they do..."
13:28:02 <Sonolin> W.modify' $ \(W.Stack f up rs) -> W.Stack f (up ++ rs) []
13:28:05 <ph88> the type of a when you pattern match on TheBool
13:28:24 <Sonolin> data W.Stack a = W.Stack {W.focus :: !a, W.up :: [a], W.down :: [a]}
13:28:28 <ski> "the type of a" is nonsense, `a' doesn't have a type. `a' *is* a type
13:28:43 <ski> after the pattern-match, we know that `a' is equal to `Bool'
13:29:31 <ski> `bar' *appears* to be promising to be able to return a value of any type `a', as long as it is passed a value of type `IsBool a'
13:29:39 <aarvar> Sonolin: so, you're moving all the windows below the focus above it?
13:30:12 <Sonolin> yea
13:30:25 <Sonolin> I want the order of the windows to stay the same, but focused window to move to last window
13:30:26 <ski> however, there's only one possible way to have a (total) value of `IsBool a', and that is `TheBool b' for some `b' of type `Bool', and in this case, `TheBool b' has type `IsBool Bool'
13:30:26 <ph88> are you making the data constructor dependent on the value ?
13:30:34 <aarvar> Sonolin: isn't the head of up the first window above, and the head of down the first below?
13:30:39 <ski> iow `IsBool a' only has a (total) value in case `a' is equal to `Bool'
13:30:52 <ski> ph88 : which value ?
13:30:53 <aarvar> so you need to reverse down I think?
13:31:12 <Sonolin> hmm I didn't think so... I was under the understanding head of up = master window
13:31:18 <Sonolin> I will play with taht though, sorta makes sense
13:31:21 <ph88> ski, b in  foo (TheBool b) = b
13:31:24 <aarvar> idk, I forget
13:31:41 <ski> ph88 : "are you making the data constructor dependent on the value ?" -- no
13:31:55 <ph88> i think the data constructor follows from the value
13:32:09 <ski> ph88 : the type of `TheBool' is `Bool -> IsBool Bool', which is not a dependent function type
13:32:43 <ski> ph88, ok, i'll give an even simpler example, which should hopefully disbuse you of that notion
13:33:05 <ski>   data IsBool_ :: * -> *
13:33:06 <ski>     where
13:33:12 <aarvar> Sonolin: maybe reverse rs ++ up?
13:33:14 <ski>     ItIsBool :: IsBool_ Bool
13:33:15 <aarvar> not sure
13:33:17 <monochrom> It is not dependent until you see "MyType True" and "MyType 'c'" etc
13:33:22 <ski> now consider
13:33:29 <ski>   baz :: IsBool_ a -> a
13:33:31 <ph88> your function foo takes a type IsBool a  .. why you are talking about TheBool data constructor ?
13:33:33 <ski>   baz_ ItIsBool = False
13:33:39 <aarvar> er no, that's wrong
13:33:40 <aarvar> ignore me
13:33:45 <ski> ph88 : now, the data constructor takes no value as argument
13:33:57 <ski> (s/baz_/baz/)
13:34:26 <ski> ph88 : "why you are talking about TheBool data constructor ?" -- because that's mentioned in the pattern ?
13:34:41 <ski> i wanted to talk about how the pattern-matching interacted with the type-checking
13:34:47 <ski> since that's what GADTs are about
13:35:15 <aarvar> maybe it's better to think of it as TheBool :: (a  ~ Bool) => a -> IsBool a
13:35:20 <ph88> but this type "Bool -> IsBool Bool" is not an ordinary type but a data-constructing type "Bool -> IsBool Bool"
13:35:23 <ph88> that's special
13:35:31 <ph88> imo it shouldn't even be called type
13:35:45 <ski> ph88 : matching here on the `ItIsBool' data constructor causes it to be known that `a' is in fact `Bool' .. however there is no argument value of type `Bool' in this case
13:36:04 <ski> i don't know what you mean by "not an ordinary type but a data-constructing type"
13:36:10 <ski> it is a type
13:36:15 <aarvar> TheBool contains an implicit equality a ~ Bool
13:36:19 <ski> just that using GADTs give you extra powers
13:37:12 * ski is idly annoyed that they used `~' and not `=' to express type equality constraints ..
13:37:16 <ph88> yes but that is thinking in reverse, because it's more natural to think that you first have value a that is a bool which then is associated with data constructor ItIsBool
13:37:52 <ski> ph88 : well, in the `ItIsBool', there is no "you first have value a that is a bool"
13:38:09 <ski> there is no value at all
13:38:11 <ntnt> is there a nice way to rewrite (_dllNext <$> rlstGet) >>= ((handle DllInsertError) . (smapLookupM i)) ?
13:38:28 <ph88> ski, the value takes the place of Bool in  ItIsBool :: IsBool_ Bool
13:38:43 <ski> ph88 : if you match a value of type `IsBool_ a' with a pattern `ItIsBool', then you discover that `a = Bool'
13:38:58 <ski> ph88 : iow, the value `ItIsBool' encodes the evidence that `a = Bool'
13:39:08 <aarvar> ski: now `=` can be used for the identity type when haskell adopts HoTT in 2050
13:39:30 <ski> ph88 : "the value takes the place of .." -- which value ?
13:40:13 <t7> guys i have [Set Int], i need to ensure that all are unique
13:40:21 <t7> as in there are 0 intersections 
13:40:24 <ph88> the value `ItIsBool'  <-- yes ok, but ItIsBool was also a data constructor which takes no arguments right ?
13:40:45 <t7> do i sort & group ?
13:40:46 <t7> after toList
13:40:48 <t7> or is there a better way
13:42:39 <ski> @type \sets -> and [Data.Set.null (Data.Set.intersection set0 set1) | set0:sets <- tails sets,set1 <- sets]  -- t7 ?
13:42:40 <lambdabot> Ord a => [S.Set a] -> Bool
13:42:51 <ski> ph88 : yes
13:43:08 <ski> (not sure what you mean by "also". it's *only* that)
13:43:39 <ski> (though every data constructor is also a value. perhaps that's what you meant here)
13:43:45 <ph88> we are saying: it's a value and also it's a data constructors
13:43:59 <ph88> constructor
13:44:10 <ski> ph88 : anyway, i don't think "the value, ItIsBool, takes the place of Bool in  ItIsBool :: IsBool_ Bool" is correct
13:44:42 <ph88> ok i got it
13:45:00 <ski> (i'm also not sure what you mean by a value taking the place of a type (`Bool') here .. there is no dependent typing here, no value expressions inside type expressions)
13:45:04 <t7> ski, Set.unions then Set.size?
13:45:20 <t7> if its less that the total of all
13:45:24 <t7> then intersection
13:45:29 <t7> that should work right?
13:45:31 <nitrix> ph88: Values can't really interfere at the type level in Haskell as there's no dependent type system, as I know of yet.
13:46:08 <nitrix> ph88: e.g. [1,2,3,4] :: List{4}
13:46:15 <ski> there are some tricks that you can play to simulate *some* uses of dependent types
13:46:24 <ski> but it's not dependent types
13:46:50 <nitrix> ski: I'm assuming those tricks require manual bookkeeping too?
13:47:01 <nitrix> Or plenty of monads :P ?
13:47:30 <ski> e.g. you could declare `data Vector a :: Nat -> * where Nil :: Vector a Zero; Cons :: a -> Vector a n -> Vector a (Succ n)' after `data Nat = Zero | Succ Nat' -- but `Nat' here is a kind, not a type
13:47:55 <ski> but that still doesn't let you express `replicate :: (n ::) Nat -> a -> Vector a n'
13:48:18 <nitrix> (n :: Nat) ?
13:48:27 <ski> nitrix : that's another common notation, yes
13:48:35 <ph88> what i get form this is that the data constructor is chosen depending on type of a
13:48:50 <nitrix> ski: Cool and disgusting at the same time :P Thanks.
13:49:02 <ski> you could make a "reflection/singleton" type `data IsNat :: Nat -> * where IsZero :: Nat Zero; IsSucc :: IsNat n -> IsNat (Succ n)', and then you could say `replicate :: IsNat n -> a -> Vector a n'
13:49:28 <ski> but then it's awkward to convert between values of (the *type*, not kind) `Nat', and values of the type `IsNat n'
13:49:51 <ski> ("singleton", because for any specific `n', `IsNat n' has a single (total) inhabitant)
13:50:04 <nitrix> Mhh.
13:50:15 <ph88> so you could implement functionality for different type of values (a) which are grouped together by one type
13:50:20 <ski> of course, it's easy to do `down :: forall n. IsNat n -> Nat'
13:50:30 <drninjabatman> hello, is there a library to allow to execute IO wrapped in a mutex? like criticalIO :: Mutex -> IO a -> IO a
13:50:35 <ski> which is equivalent to `down :: (exists n. IsNat n) -> Nat'
13:50:50 <nitrix> ski: Right, and then you end up with existiantials all over the place :/
13:50:50 <ski> but, for the other direction, you want `up :: Nat -> (exists n. IsNat n)'
13:50:51 <ph88> without losing the "container" type
13:50:54 * ski nods
13:51:08 <ph88> otherwise you could just pattern match on Integer or Bool in the usual way
13:51:12 <ph88> okay thanks ski
13:51:24 <ski> nitrix : and you lose the connection between matching on the input `Nat', and getting `n' be correspondingly refined
13:51:54 <xa0> djanatyn: what's your aim with that?
13:52:00 <Sonolin> aarvar: you were right W.modify' $ \(W.Stack f up rs) -> W.Stack f (reverse rs ++ up) [] it is
13:52:10 <ski> ph88 : "what i get form this is that the data constructor is chosen depending on type of a","so you could implement functionality for different type of values (a) which are grouped together by one type","without losing the \"container\" type" -- is basically right, if i understand what you're saying
13:52:17 <Sonolin> silly xmonad
13:52:39 <ski> ph88 : however, i would probably express the first part as "the type `a' is chosen depending on the data constructor"
13:53:16 <ski> nitrix : also see edwardk's `reflect' package
13:53:27 <ph88> ski, yes that's why i was saying that for you are telling that part in reverse, maybe for you i'm in reverse :P
13:53:36 <ski> @hackage reflection
13:53:36 <lambdabot> http://hackage.haskell.org/package/reflection
13:53:38 <ski> actually, iirc
13:53:47 <ski> yep
13:54:11 <Tangerine> how does one analyze space complexity of a haskell function?
13:54:36 <nitrix> ski: Freaking edwardk :P
13:54:42 <ski> ph88 : the key point is that we encode type information inside the data constructors. so that successfully matching on such a data constructor *recovers* (locally) that type information
13:54:43 <nitrix> ski: He's already figured this all out.
13:55:09 <nitrix> ski: Quick question
13:55:13 <ski>   reifyNat :: forall r. Integer -> (forall n. KnownNat n => Proxy n -> r) -> r
13:55:15 <ph88> you talking about me ?
13:55:23 <ski> reifies the input `Integer' as `n'
13:55:32 <ski> ph88 : edwardk
13:55:49 <nitrix> ski: How is (exists n. Nat n -> ...) equivalent to (forall n. Nat n -> ...) ?
13:55:52 <ski> (and that's just the CPS encoding of
13:55:59 <nitrix> ski: It's what I tripped on your explanation.
13:56:10 <ski>   reifyNat :: Integer -> exists n. KnownNat n *> Proxy n
13:56:13 <ski> )
13:56:23 <ski> nitrix : oh. the answer is no
13:56:55 <ski> nitrix : `(exists a. ..a..) -> ...' is logically equivalent to `forall a. (..a.. -> ...)', which is usually written in Haskell just as `forall a. ..a.. -> ...'
13:57:04 <ski> nitrix : the placing of the brackets is important
13:57:13 <nitrix> 16:49:48             ski | of course, it's easy to do `down :: forall n. IsNat n -> Nat'
13:57:15 <nitrix> 16:50:03             ski | which is equivalent to `down :: (exists n. IsNat n) -> Nat'
13:57:22 <ski> exactly
13:57:24 <ski> consider
13:57:24 <nitrix> ski: Oh?
13:57:29 <ski>   length :: [a] -> Int
13:57:34 <ski> this really means, as you know
13:57:38 <ski>   length :: forall a. [a] -> Int
13:57:40 <nitrix> forall a. [a] -> Int
13:57:51 <ski> which, inserting brackets, is the same as
13:57:55 <ski>   length :: forall a. ([a] -> Int)
13:58:18 <nitrix> Right
13:58:19 <ski> this means that, for every type `a', `length' *can* have/assume the type `[a]' -> `Int'
13:58:25 <nitrix> "For all types `a`, we can have a list of a type `a` to an Int."
13:58:37 <ski> iow, for every type `a', if you apply `length' to a value of type `[a]', then the result has type `Int'
13:59:00 <ski> iow, if you apply `length' to a value of type `[a]', for any type `a', then the result has type `Int'
13:59:06 <nitrix> So this can be specialized to anything. ~ [Char] -> Int ... ~ [Foo] -> Int ... ~ [Bar] -> Int. 
13:59:09 <nitrix> So far so good.
13:59:17 * nitrix reading
13:59:44 <ski> iow, if you apply `length' to a value of type `exists a. [a]' (iow a value where there *exists* some type `a' such that the value has type `[a]'), then the result has type `Int'
13:59:46 <nitrix> Yep, still good.
14:00:33 <ski> (here, the use of the word "any" in english language might perhaps be confusing, if you haven't noticed exactly how it's used before)
14:01:20 <ski> it doesn't matter what `a' we use in the argument type `[a]', as long as there *exists* some type `a' to use as the element type in the list type
14:01:25 <ski> iow
14:01:31 <ski>   length :: (exists a. [a]) -> Int
14:01:56 <nitrix> So, those two are equivalent ?
14:02:04 <ski> yes
14:02:16 <ski> <ski> nitrix : `(exists a. ..a..) -> ...' is logically equivalent to `forall a. (..a.. -> ...)', which is usually written in Haskell just as `forall a. ..a.. -> ...'
14:02:19 <ski> if you want to, i can show what happens in each case, when deriving the type of the expression `length [False,True,False]'
14:02:34 <ski> in the former case, we have
14:02:42 <ski>   [False,True,False] :: [Bool]
14:02:48 <ski>   length :: forall a. ([a] -> Int)
14:02:51 <nitrix> ski: Examples seems to really help, yeah
14:02:56 <ski>   length :: [Bool] -> Int
14:03:05 <ski>   length [False,True,False] :: Int
14:03:07 <ski> and that's that
14:03:34 <ski> we specialize the polymorphic `length' to a specific instance with `a' replaced by `Bool', to allow passing `[False,True,False]' as an argument
14:03:39 <ski> in the latter case, we have
14:03:49 <ski>   length :: (exists a. [a]) -> Int
14:03:54 <ski>   [False,True,False] :: [Bool]
14:04:00 <ski>   [False,True,False] :: exists a. [a]
14:04:10 <ski>   length [False,True,False] :: Int
14:04:23 <ski> so it's really not more complicated, just structured/phrased differently
14:04:50 <ski> the interesting point is the step from `[Bool]' to `exists a. [a]', for the type of `[False,True,False]'
14:05:05 <nitrix> [False,True,False] :: exists a. [a]
14:05:09 <aarvar> Sonolin: woo, I was right!
14:05:16 <nitrix> Does this actually type checks?
14:05:18 <ski> if `[False,True,False]' has type `[Bool]', then there *exists* *some* type `a', such that `[False,True,False]' has type `[a]'
14:05:20 <aarvar> I mean, woo, you solved it!
14:05:25 <ski> (namely `a' being `Bool')
14:05:33 <ski> nitrix : this is all conceptual types
14:05:48 <Sonolin> yea frustratnig since their docs say "master is topmost element" - not as far as the code is concerned at lesat...
14:05:48 <ski> nitrix : there is no `exists' keyword in GHC
14:05:54 <Sonolin> head up = nearest up neighbor
14:05:56 <nitrix> ski: Pause. So it means, Bool :: exists a. a, would typecheck. Bool :: forall a. a, wouldn't, right?
14:05:58 <Sonolin> frustrating
14:06:05 <nitrix> ski: I mean onceptually.
14:06:09 <ski> nitrix : `Bool' is not a value
14:06:12 <nitrix> *conceptually.
14:06:15 <nitrix> Whoops
14:06:23 <nitrix> Replace Bool with True.
14:06:28 <ski> then it's correct
14:06:31 <nitrix> Okay.
14:06:34 <nitrix> Continue.
14:06:38 <ski> you can go from `forall a. a' to `Bool'
14:06:43 <ski> and from `Bool' to `exists a. a'
14:06:56 <nitrix> You can't go from Bool to forall a. a
14:07:08 <ski> generic/polymorphic instantiation work in the opposite direction as existential abstraction
14:07:14 * ski nods
14:07:25 <nitrix> That, is incredibly helpful.
14:07:44 <ski> this is also part of the reason why it's hard to infer `exists' types
14:07:44 <nitrix> Not sure how precise it is, but it helps my mental blocker.
14:08:05 <ski> i mean, you *could* infer the type `exists a. a' for everything, but that's not very helpful
14:08:13 <ski> `exists a. a' is about as useful as `()' is
14:08:19 <Mateon1> Hi, is there a way to repeat a monadic action some finite amount of times? I'm currently doing `mapM_ (\_ -> action) $ take n $ repeat ()`, which is ugly as heck.
14:08:19 <ski> no information can be extracted out of it
14:09:07 <Sonolin> I think replicateM would work, right?
14:09:11 <Sonolin> or replicateM_
14:09:15 <nitrix> ski: I do have knowledge of information theory.
14:09:21 <Sonolin> (if results should be discarded)
14:09:21 <Mateon1> :t replicateM_
14:09:22 <lambdabot> Monad m => Int -> m a -> m ()
14:09:24 <ski> (well, on more careful thought, you couldn't do it for everything. but you could do it for top-level things, i think, as long as they're not used by anything else in the module)
14:09:25 <nitrix> ski: I actually see similarities.
14:09:29 <Mateon1> Sonolin: Thanks!
14:09:45 <Sonolin> yup! Found that nugget here a while ago, just passing it along :)
14:09:51 <nitrix> ski: Specializing the type is actually loosing "information" in the general sense.
14:09:51 <ski> nitrix : also, `forall a. a' is isomorphic to `Void'
14:09:56 <ski> yes
14:10:03 <ski> it's abstraction
14:10:08 <ski> abstracting away details
14:10:11 <nitrix> Mhm. It's very nice.
14:10:29 <nitrix> ski: But in this case, Bool is an abstraction?
14:10:44 <ski> in this case, "abstraction" refers to using `exists'
14:10:49 <nitrix> Right.
14:10:56 <ski> which is btw the same kind of "abstract" as in "abstract data types"
14:11:06 <nitrix> Gotcha.
14:11:27 <scepticulous> I am new to haskell and I am working on an excercise to calculate the last digit of a large fibonacci number ( N to 1,000,000) with a memory limit of around 60 mb. I am using an integer and a recusive function with pair of ints to calculate the current values and an int to keep the progress until I reach N . however profiling results seem as if the incremented integer causes the memory consumption to grow that high (80mb) currently. Any 
14:11:29 <scepticulous> suggestions in general? (if possible without seeing code)
14:11:34 <nitrix> I feel like a few more times and this will be completely sorted out. I just don't have any practical uses yet for existantial quantification.
14:11:35 <ski> a module with an ADT can be thought of as a module with an existential in the body
14:12:05 * hackagebot lens 4.14 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.14 (EricMertens)
14:12:10 * ski idly wonders whether scepticulous is doing Project Euler stuff
14:12:28 <nitrix> ski: RankNTypes with polymorphic functions as arguments is pretty much as far as "fancy" as my code ever has gotten.
14:12:34 <ski> nitrix : one use for existentials is some "OO-like stuff"
14:12:36 <byorgey> scepticulous: first, are you doing mod 10 on the intermediate values, or only once at the end?
14:12:39 <aarvar> scepticulous: did you make it strict?
14:13:04 <ski> nitrix : e.g., if you wanted a list/map/array of "widgets", all possibly having different types, but having a common interface
14:13:18 <ski> nitrix : that's `[exists a. Widget a *> a]'
14:13:32 <ski> nitrix : note that that's different from `exists a. Widget a *> [a]'
14:13:33 <scepticulous> byorgey: I am doing it all the time. since the last digit can be calculated by adding the last digits. and i used that to test word8 for the values instead of int 
14:13:39 <ski> nitrix : also, `*>' here is not `=>' :)
14:13:51 <byorgey> scepticulous: ok, then the problem is likely too much laziness, as aarvar suggests
14:13:56 <scepticulous> aarvar: actually I am having trouble with that. 
14:14:11 <aarvar> scepticulous: maybe you should paste the code
14:14:18 <byorgey> scepticulous: that is, your program just builds a giant lazy unevaluated expression, and then tries to evaluate it at the very end
14:14:21 <lpaste> scepticulous pasted “last_fibonacci_digit.hs” at http://lpaste.net/161727
14:14:22 <Mateon1> scepticulous: Instead of recursion, build up a list/memoize the results. Compiled haskell with optimizations will throw away what it doesn't need from the list.
14:14:52 <ski> nitrix : `RankNTypes' i'd say is about the same level of "hardness" as existentials .. maybe a little harder than existentials
14:14:53 <aarvar> scepticulous: yeah, the problem is most likely laziness
14:15:18 <ski> (or perhaps s/hard/advanced/)
14:15:24 <amnn> scepticulous, you can (A) do all your calculations mod 10, to keep the values as Ints (B) use the logarithmic time implementation of fibonacci which uses fast matrix exponentiation
14:15:44 <scepticulous> byorgey: yes I understand that that could be the issue, however with 'hand crafted' or 'hand messed' code written by myself I am having trouble creating a strict version of it 
14:16:20 <nitrix> ski: Sweet. Going home, might have more questions later.
14:16:23 <nitrix> ski: Thanks.
14:16:23 <Mateon1> amnn, scepticulous: There's also an easier (IMO) way to calculate fibonacci in logarithmic time, using a multiplication identity that you can google.
14:16:30 <ski> nitrix : anyway, despite GHC not having the keyword `exists', imho it helps a lot to still conceptualize stuff in terms of it (and `*>')
14:16:32 <scepticulous> amnn: I am not sure if that is available without any package. I am trying to make it as easy as possible for now. 
14:16:56 <byorgey> scepticulous: you can make a new strict pair type,  data Pair a = Pair !a !a
14:17:02 <ski> nitrix : after deciding which types you really want, using this notation, you can decide how to encode it in GHC (there's two main options, "existential data constructors", and CPS)
14:17:04 <scepticulous> Mateon1: I will check that. 
14:17:05 <byorgey> then use Pair Int  instead of  (Int,Int)
14:17:08 <aarvar> ^
14:17:09 <ski> (well, rank-2 CPS)
14:17:34 <aarvar> and make the arguments to recursiveFibonacci strict
14:17:50 <amnn> scepticulous, the derivation involves matrix exponentiation, but your implementation doesn't have to. Mateon1, is the multiplication identity related at all to the version that phrases it in terms of matrices or is it something completely different?
14:18:40 <ski> nitrix : np
14:18:48 <Mateon1> amnn: I'll dig up a Python script I made a while back, it has absolutely nothing to do with matrices
14:19:04 <amnn> Mateon1, that would be awesome, I'd be interested to see it
14:19:08 <scepticulous> aarvar: and that would be using bang notation? Sorry about asking, Its really just my first week. 
14:19:10 <aarvar> Mateon1: blasphemy
14:19:20 <byorgey> Mateon1, amnn: I'm guessing the recurrence you are thinking of is essentially matrix multiplication in disguise
14:19:27 <aarvar> scepticulous: yes, though using a strict Pair type should be enough I think actually
14:19:41 <scepticulous> ok I will try that 
14:19:47 <amnn> byorgey, yes, that is what I thought might be the case
14:20:01 * ski was recently pondering sterling "numbers" for arbitrary sets/types
14:20:07 <aarvar> er, at least the pair argument needs to be made strict actually
14:20:46 <Mateon1> amnn, byorgey, aarvar: Quite possible, the identity, assumming F(n) is the n'th Fibonacci number, is F(a+b) = F(a)*F(b-1) + F(a+1)*F(b)
14:21:05 <Mateon1> From that you can derive that F(2a) = F(a)*(2*F(a - 1) + F(a))
14:21:30 <aarvar> Mateon1: I was referring to your mention of python
14:21:45 <EvanR> https://www.reddit.com/r/haskell/comments/1o6iqs/why_i_dont_like_the_lens_library/ claims linear doesnt depend on lens... though i installed it recently and seemed to take forever with deps, assumed it was because of lens
14:21:57 <byorgey> Mateon1: yes, I see. you can derive that identity from matrix multiplication.
14:22:29 <Zemyla> Can a Template Haskell program use quasiquoters defined in the same file?
14:22:41 <ski> Zemyla : iirc, no
14:23:12 * ski has pondered meta-circular macros/quasiquoters ..
14:23:19 <byorgey> EvanR: linear does depend on lens.
14:23:31 * aarvar ponders if ski does too much pondering
14:23:39 <ski> it happens
14:24:02 <byorgey> EvanR: where does it say that linear doesn't depend on lens?
14:26:06 <byorgey> Mateon1: if you consider powers of the matrix [[0,1],[1,1]], it is not too hard to show by induction that the nth power is  [[F(n-1), F(n)], [F(n), F(n+1)]]
14:27:05 <byorgey> if we let  M = [[0,1],[1,1]]  then using that fact and expanding out  M^(a+b) = M^a M^b  yields your identity for F(a+b)
14:27:07 <Mateon1> byorgey: Good to know. I'm still not quite familliar with matrices, but I remember proving the identity in class without the use of matrices.
14:27:22 <byorgey> sure, you can prove it directly as well
14:28:41 <ski> (oh, and i was pleasently surprised by a lecturer using the binomial coefficient notation with sets rather than numbers ..)
14:29:01 <scepticulous> Mateon1: well,using matrix exponentiation may be too hard for me in haskell. in any OO/imperative language i would have gone that road. But I think I will avoid going that direction in haskell with now. 
14:29:03 <Mateon1> Gah, I'm trying to build some cabal packages on Windows and I'm failing constantly. Windows 32 bit can't build base-orphans and old-time, apparently.
14:29:24 <byorgey> ski: oh, nice.  as in,   A \choose 2  means the set of all size-2-subsets of A?
14:29:29 <ski> yes
14:29:43 <ski> in this case used to describe the set of edges in a graph
14:29:53 <byorgey> right, nice
14:30:11 <m1dnight_> Im doing some bit fiddling in Haskell (and am new to bit fiddling alltogether) and Im wondering how I can concat two Word8's to a single word16.
14:30:14 <ski> (i didn't know if this generalization was in common use before seeing that)
14:30:47 <byorgey> I hadn't seen it before.  But generalizing notation by categorifying things usually works well. =)
14:31:05 * ski has been experimenting with a dependent-types-style notation for talking about a size-`K'-subset of `N'
14:31:16 * byorgey idly wonders what  A \choose 2  should mean when A is a groupoid
14:31:45 <scepticulous> aarvar: since Pair seems to be part of a package, and I am constrainted to have no additional packages, I tried just using defining 'data IntPair = (!Int, !Int)' as a new type and used that in the type specification of my recursive function. should that already have made a difference ?
14:31:50 <ski> byorgey : this was a (afaik) vanilla discrete mathematician, so it was nice to see that they also something think of doing things like that
14:32:06 <ski> s/something/sometimes/
14:32:08 <frontendloader> m1dnight_: left shift and add
14:32:20 <frontendloader> after casting the one you're left shifting to a word16
14:32:43 <aarvar> scepticulous: the pair argument needs to be strict as well
14:32:54 <byorgey> right, agreed, I wasn't imagining that they were thinking of it in terms of categorification.
14:33:34 <byorgey> scepticulous: IntPair needs a constructor
14:33:39 <scepticulous> oh sorry, I need one more minute. I compiled the wrong file and wondered why there was no change
14:33:46 <byorgey> scepticulous: data IntPair = IntPair !Int !Int
14:34:11 <aarvar> then you could also unpack the Ints
14:34:21 <scepticulous> yes, sorry about the confusion
14:34:48 <amnn> aarvar, don't recent versions of GHC do that unpacking for you if you say that it is strict? (I forget quite how recent)
14:34:56 <byorgey> unpacking the Ints sounds like premature optimization to me.
14:34:59 <ski> byorgey : anyway, instead of writing something like `{n_k}_{k \in K}' as an element of `N \choose K', i've been writing the judgement `(n_k \in) N \choose (k \in) K'
14:34:59 <aarvar> amnn: idk
14:35:23 <aarvar> amnn: there's a compiler flag for it at least though
14:35:27 <ski> byorgey : where one has to use `n_k' in a way that's symmetric under permutations over the `k' indices
14:35:55 <aarvar> -funbox-strict-fields
14:36:16 * ski . o O ( `-funroll-loops' )
14:36:41 <amnn> aarvar, that is probably what I was thinking of
14:36:50 <byorgey> ski: interesting
14:37:06 * hackagebot satchmo 2.9.9.3 - SAT encoding monad  https://hackage.haskell.org/package/satchmo-2.9.9.3 (JohannesWaldmann)
14:37:17 <m1dnight_> frontendloader: That's what I thought. Cast the Word8 to a Word16, then shiftL 8, and add with another word8 casted to Word16 but it doesnt seem to be possible to cast them
14:37:30 <aarvar> amnn: yeah, I don't think it's the default
14:37:31 <m1dnight_> Oh, maybe I can go around via Int
14:37:38 <aarvar> it can make performance worse in some cases, apparently
14:37:52 <amnn> yes, if you have to rebox it often
14:38:17 <aarvar> hmm, is there a Pack pragma then?
14:38:22 <Mateon1> m1dnight_: You can convert between integrals by using fromIntegral
14:38:32 <m1dnight_> Allright, I think I'm getting somewhere!
14:38:36 <m1dnight_> Thanks gents 
14:38:40 <c_wraith> I think ghc 7.10 made unpacking small strict fields the default 
14:38:45 <ski> byorgey : .. and i needed to talk about the elements of `N \choose K', when proving `N^M = sum_K (N \choose K) * K! * S(M,K)'
14:39:15 <ski> byorgey : which is basically epi-mono factorization
14:39:15 <EvanR> byorgey: https://www.reddit.com/r/haskell/comments/1o6iqs/why_i_dont_like_the_lens_library/ccq2riq though its 2 years ago
14:40:26 <c_wraith> heh. alterF is running through the libraries list again right now. 
14:40:28 <aarvar> ah, it's called NOUNPACK
14:40:42 * ski . o O ( `VERBPACK' )
14:40:55 <monochrom> haha
14:41:29 <Mateon1> Is it impossible to build old-time under msys?
14:41:40 <byorgey> EvanR: ah, I see.  Well, I checked, and it has a lens dependency now =)
14:42:36 * EvanR should have checked the date on the thread
14:42:44 <ski> (byorgey : .. i have various other half-baked notation ideas of a similar vein, that i've been pondering and trying to elaborate/improve)
14:42:55 <aarvar> again with the pondering
14:43:04 <byorgey> ski: oh, neat, yes, I see how that is epi-mono factorization
14:43:09 <aarvar> ski: try a thesaurus
14:43:26 <ski> why, aarvar ?
14:43:36 <byorgey> ski: was this proof on paper, or in a proof assistant?
14:44:03 <ski> byorgey : on paper. otherwise i'd had to at least implement a new syntactic frontend
14:44:21 <byorgey> ski: ok, right
14:44:25 <byorgey> ski: I think aarvar was just making a joke that you use the word 'pondering' too much.
14:44:33 <aarvar> ski: you can't spend your whole life just pondering things. Try contemplating them for a change.
14:44:34 <ski> perhaps
14:44:37 * ski ponders that
14:44:42 <byorgey> =)
14:44:53 <EvanR> pondering (gerund). synonyms: .oO(_)
14:45:03 <ski> aarvar : who says i don't ? :)
14:46:10 <monochrom> haha EvanR
14:46:26 * ski . o O ( "Is it correct that you Jesuits always answer a question with a counter-question?" - "Who has said that?" )
14:47:40 <ski> perhaps i should try to excogitate more often
14:55:07 <ski> (byorgey : hm, perhaps a small clarification. when wanting to do the proof the the epi-mono thing, for natural numbers only, i obviously wanted to generalize it so that `k' could be any natural number, not just ones between `1' and `m' (inclusive). however talking about the number of surjections from `{0,...,m-1}' to a `k'-sized subset of `{0,...,n-1}' was problematic, when `m < k', since there's no candidate subset then. so i wanted to talk about the speci
14:55:26 <ski> (er, cut off near ".., when `m < k', since there's no candidate subset then. so i wanted to talk about the specific chosen subset. hence i categorified it)")
14:57:53 <ski> (.. er, rather the `n < k' case. not `m < k'. the problem was when there was no `k'-sized subset of `{0,...,n-1}', and so in particular, we couldn't select one of them as a representative candidate)
14:59:13 <EvanR> it is interesting that actor model introduced in 1973 by hewitt bishop and steiger already was making use of pattern matching
14:59:29 <EvanR> i went to an elixir meetup yesterday which makes heavy use of pattern matching, finally
15:00:51 <koala_man> it got it from prolog
15:00:53 <ski> (something like `sum_k ((x_i <) n \choose (i <) k) * #{s : {0,...,n-1} -> {x_i | i < k} | surjective(s)}')
15:01:10 <EvanR> actor model did?
15:01:16 <koala_man> elixir
15:01:35 <ski> i thought it got it from Erlang, which got it from Prolog
15:01:42 <koala_man> well yes
15:01:47 <ski> (well, by transitive dependence ..)
15:02:04 * ski also notes that Linda tuple-spaces uses pattern-matching
15:03:23 <EvanR> also in 1973 smalltalk was a thing
15:03:50 <EvanR> after 40 years programming languages still do not have all these features of old languages
15:04:02 <koala_man> did smalltalk have pattern matching?
15:04:10 <cheater> yeah man i really miss all that stuff from cobol
15:04:12 <EvanR> i dont think so, but it was similar to actor model
15:04:59 <EvanR> how did cobol get popular despite itself o_O
15:05:08 * ski . o O ( <https://en.wikipedia.org/wiki/Linda_(coordination_language)> )
15:05:29 <ski> COBOL introduced the record type
15:05:42 <ski> koala_man : no, only message-dispatching (which is the dual)
15:05:49 <amnn> EvanR, it was one of the first ever "compiled" languages, so that gives an indication of what it was competing against
15:05:58 <geekosaur> designed by, and required by, the US department of defense. which meant you learned it and used it if you wanted to sell to the government, and then you used it in house to keep up on it, and then it spread outward 
15:06:37 <geekosaur> sociopolitical domination, not technical
15:06:51 * ski . o O ( "[Grace Hopper] ... was one of those who popularized the idea of machine-independent programming languages which led to the development of COBOL, one of the first high-level programming languages." )
15:06:56 <Rembane> Isn't that almost alwawys the case? COBOL is the VHS of programming languages?
15:08:26 <ski> EvanR : also, probably people wanted to believe that people without as much special training would be able to program COBOL ..
15:08:37 <geekosaur> yes
15:08:44 <aarvar> if only they had python back then
15:08:51 <ski> the "BASIC syndrome" thing
15:08:53 <geekosaur> "business-oriented" --> "doesn't require a maths degree"
15:09:11 <Rembane> "We make a language that contains lots of english words and thus people will learn it superfast."
15:09:19 <geekosaur> (business-oriented being the "BO" in COBOL)
15:09:31 <Rembane> Wasn't APL concieved at almost the same time?
15:09:31 <ski> Rembane : well, it'll be more intuitive as well :)
15:09:40 <Rembane> ski: That gives me the twitches. :)
15:10:08 * ski . o O ( SNOBOL )
15:10:14 <aarvar> geekosaur: where's the BS in COBOL?
15:11:09 * geekosaur considers and discards several snarky responses...
15:11:09 <scepticulous> aarvar: byorgey: Hey guys, thanks a lot. adding the type for strict evaluation really did the trick. Memory consumption is down to 1/64 MB. 
15:11:21 <EvanR> basic syndrome, so were still there
15:11:38 <aarvar> scepticulous: did you unpack the Ints too?
15:11:40 <EvanR> except now its ruby
15:12:07 * hackagebot async-dejafu 0.1.2.0 - Run MonadConc operations asynchronously and wait for their results.  https://hackage.haskell.org/package/async-dejafu-0.1.2.0 (barrucadu)
15:13:21 <scepticulous> aarvar: no, I really needed that long to implement the solution using the custom data type. However I found a haskell wiki page that talks about that and i will give it a shot next. 
15:14:33 <EvanR> "Programming [or problem solving in general] is the judicious postponement of
15:14:34 <EvanR> decisions and commitments!" 
15:14:43 <EvanR> dijkstra
15:14:53 * ski . o O ( The use of COBOL cripples the mind; its teaching should, therefore, be regarded as a criminal offence." -- Edsger Wybe Disjkstra,1975-06-18 )
15:15:10 <EvanR> 1969 premonition of lazy programming? ;)
15:16:03 * ski . o O ( "It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration." -- Edsger Wybe Disjkstra,1975-06-18 )
15:16:09 <ski> i was looking for that latter one
15:16:27 * ski must therefore be mentally mutilated beyond hope of regeneration
15:16:35 <geekosaur> is that really a "b" in that name, or someone botching a ß?
15:17:01 <ski> it's "Wybe"
15:17:03 <amnn> the first programming language I learnt was BASIC, on a palm pilot. I wrote programs out using a stylus
15:17:24 <hydraz> geekosaur: it's 'Wybe'
15:17:29 <aarvar> ski: you misspelled Dijkstra?
15:17:31 <HallaSurvivor> ttps://xkcd.com/378/
15:17:38 * ski started on a programmable calculator, 544 bytes of RAM available for (BASIC) programs, around age 6.5
15:17:47 <ski> aarvar : oh, i did. ty
15:17:48 <aarvar> where did that s come from
15:18:01 * ski doesn't know
15:18:37 <ski> (then BASIC V2.0 on C64. then 6502 assembler ..)
15:18:54 <amnn> HallaSurvivor, I'm not advocating writing programs with a stylus as the way Real Programmers (tm) should do things. If anything, I want to convey the opposite.
15:19:01 <EvanR> "A data structure is nothing but a stupid programming language." 
15:19:09 <EvanR> bill gosper
15:19:35 * ski remembers reading about linked lists, sorting algorithms, round-robin queues in a book about assembly programming and thinking "i want to learn more about this kind of stuf" (not knowing what it was called)
15:20:26 <ski> @remember BillGosper A data structure is nothing but a stupid programming language.
15:20:26 <lambdabot> It is stored.
15:21:07 <HallaSurvivor> amnn, I know. I just find that comic hysterical :P
15:21:20 <HallaSurvivor> Any excuse to bring xkcd into the conversation is a good excuse
15:21:28 * ski . o O ( LispMe on Palm )
15:21:32 <amnn> agreed
15:21:52 <aarvar> I started with Java. Am I more or less mutilated?
15:22:21 <amnn> For anyone who still has a working palm pilot: http://www.thelawrences.org/palmbasic/
15:22:57 <amnn> (and yearns for those good old imperative days)
15:23:01 <ski> aarvar : yes, to some degree. not as much as BASIC users, though
15:23:56 * geekosaur started out on microcomputer BASIC. and remembers thinking "...is this really the best they can come up with?!" thankfully the answer turned out to be "no"
15:24:00 <ski> (it was an eye-opener, when learning C, when i realized that a new functionality didn't have to come with a new concrete syntax, it could just be a new library function, using the same generic notion of function as before)
15:26:41 <ski> (.. or perhaps Java users tend to be mutilated in more advanced ways than would be possible with BASIC ?)
15:26:58 <Rembane> Haven't you done OOP in BASIC?
15:27:07 * hackagebot hunit-dejafu 0.3.0.0 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.3.0.0 (barrucadu)
15:27:09 * hackagebot tasty-dejafu 0.3.0.0 - Deja Fu support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-dejafu-0.3.0.0 (barrucadu)
15:27:25 <ski> nah
15:27:47 <ski> (i've considered doing it in assembly, though)
15:29:52 <ski> (hm, i suppose dynamically loaded libraries could be thought of as some sort of OO, with an interface that could be a jump list to the actual routines ..)
15:31:55 <Rembane> I thought VBScript or something hade really nasty OOP capabilities... but maybe I just remember it wrong.
15:33:46 <geekosaur> iirc the only "OO" in VBScript was for calling out to COM objects
15:33:55 <ski> VBScript didn't exist at the time, i think
15:34:47 * ski ponders how to implement OOP in BASIC, presumably with computed `GOTO's ..
15:35:37 <Lokathor> ski, the BASIC referred to in that quote is a much older and worse version of BASIC than the modern flavors
15:35:42 <ski> (keep in mind that BASIC has no local variables, and no way to define your own functions, except ones whose body was an expression, and that was pretty limited)
15:36:01 <ski> Lokathor : yes, i'm talking about one of the old versions :)
15:36:36 <ski> (did i mention V2.0 ? yes, i did)
15:36:37 <EvanR> not knowing about or if subroutines existed i remember implementing zork as being in a variety of loops at lines 10000 20000 etc
15:37:03 <ski> well, there was `GOSUB' and `RETURN' in this version. no local variables, though
15:37:20 <ski> and a call depth of 20 or something, iirc
15:39:23 <Sonolin> I started out on a (newer) TI calculator with basic
15:39:29 <Sonolin> good fun in math class at least :)
15:39:33 * ski nods
15:40:21 <Sonolin> so glad I dont' have to rely on goto on a regular basis... ack
15:40:24 * ski did some visualizations of different sorting algorithms, on a Casio, on a vacation, while idle in the car
15:41:23 <ski> Sonolin : .. however, continuations could be thought of as `GOTO'-on-steroids :)
15:42:45 <ski> continuations can be fun
15:44:33 <ski> for illustration, a few days ago, i showed someone how one could compute factorial using only continuations for looping, and using no mutation
15:45:14 <Rembane> ski: That sounds fun, can you show us the code?
15:46:33 <ski> well, i was thinking about trying to convert it to Haskell, before showing it
15:46:51 <Rembane> ski: What language is it written in?
15:47:18 <ski> Scheme
15:48:59 <Rembane> Lovely!
15:49:42 <ski> (there was two versions in Scheme, the second one tail-recursive)
15:58:29 <darkmercenary_> woops dc/d
15:58:43 <darkmercenary_> i have a question
15:58:44 <darkmercenary_> http://stackoverflow.com/questions/36926825/haskell-applicative-over-tuples
15:59:02 <darkmercenary_> bit longer this time i wasnt sure how to succinctly describe the problem
16:06:05 <amnn> ski, Rembane, like this? https://gist.github.com/amnn/1459f884ae70ed46f2e38d8344318c09
16:07:07 <Rembane> amnn: That's nice!
16:10:13 <lyxia> darkmercenary_: can't you move the Maybe matching into getInputs, so that getInputs returns a Maybe a
16:12:46 <darkmercenary_> ;ojir;aosdmf;lk ur right
16:13:00 <darkmercenary_> wasnt sure why i didnt think of that
16:13:21 <darkmercenary_> is there a way to apply (a1,a2,a3...) to a function that wants a1 -> a2 -> a3
16:13:27 <darkmercenary_> or should i just have my function take the tuple
16:13:46 <darkmercenary_> now that the maybes are gone
16:13:47 <EvanR> :t curry
16:13:48 <lambdabot> ((a, b) -> c) -> a -> b -> c
16:13:55 <EvanR> :t uncurry
16:13:57 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:14:11 <darkmercenary_> but thats just 2 right
16:14:16 <EvanR> :t curry3 
16:14:17 <lambdabot>     Not in scope: ‘curry3’
16:14:17 <lambdabot>     Perhaps you meant ‘curry’ (imported from Data.Tuple)
16:14:28 <EvanR> well what are you asking?
16:14:41 <EvanR> theres not literally a type (a1,a2,a3,...)
16:15:29 <darkmercenary_> or would i need curry4 and curry5
16:16:12 <amnn> darkmercenary_, do the things in the tuple belong together always, or are they coming together just to be applied to this function?
16:16:54 <darkmercenary_> just to be applied to this function
16:17:01 <darkmercenary_> i have to write hundreds of these
16:17:22 <darkmercenary_> "Computations" as described in the SO post
16:18:26 <darkmercenary_> i have a question about chaining these together and dealing with dependencies but thats another day
16:20:45 <amnn> darkmercenary_, you can use Prisms (part of the Lens heirarchy) to capture the notion of "A field that may or may not exist"
16:22:17 <amnn> if you have the requisite prisms defined on your `Thing` data structure, then you can just use the Applicative instance for Maybe to define your computations
16:24:50 <darkmercenary_> i see. is there a good resource for learning about lens? ive been meaning to but it seemed intimidating
16:27:09 * hackagebot wolf 0.2.6 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.6 (markfine)
16:28:05 <amnn> darkmercenary_, I'm not sure... there's lens.github.io, but that seems to be pretty sparse on what a Prism is. There is this tutorial here: https://www.schoolofhaskell.com/user/tel/lens-aeson-traversals-prisms which gives an example.
16:28:25 <maerwald> if you need lens, you should first question your data structures
16:29:21 <ski> amnn,Rembane : no, that's still (explicitly) recursive. i had something more advanced in mind
16:29:43 * ski is currently battling type-errors to figure out where to insert wrapping/unwrapping
16:29:48 <Rembane> ski: Interesting. :)
16:30:38 <ntnt> https://www.youtube.com/watch?v=H28QqxO7Ihc <-- is this serious? do people use 'free applicatives' ?
16:30:49 <darkmercenary_> its basically data Thing = { piece1 :: Piece1 , piece2 :: Piece 2  ... } where data Piece_i = { prop1 :: Maybe Double (or Text), prop2 :: Maybe Double (or Text) ... propj :: Maybe Double(orText) } 
16:30:53 <darkmercenary_> is what im working with at work
16:30:59 <amnn> ski, I mean, it's explicitly recursive, but it's tail recursive, so indistinguishable from a loop, right...?
16:31:27 <Rembane> ski: fix and friends?
16:34:22 <GLM> How can I specify that a return type is of a type class? I keep getting an error when I do it
16:34:34 <amnn> GLM, what did you try?
16:35:17 <GLM> amnn: CustomTypeClass a => [a] -> [a] -> [a]
16:35:23 <GLM> I also tried it with forall
16:35:42 <amnn> not sure what's wrong with that, can you pastebin the error you get?
16:37:17 <amnn> ntnt, I saw this talk recently: https://www.cs.kent.ac.uk/events/s-repls3/abs/gibbons.txt (abstract only) which makes use of free Applicatives
16:42:09 * hackagebot hasty-hamiltonian 1.1.3 - Speedy traversal through parameter space.  https://hackage.haskell.org/package/hasty-hamiltonian-1.1.3 (JaredTobin)
16:59:15 <deepfire> is there a Functor-like type class for transforming values of types of kind * ?
17:00:26 <ReinH> deepfire: Lookat monotraversable.
17:00:29 <ReinH> *Look at
17:00:48 <deepfire> ReinH, thank you!
17:02:39 <deepfire> ReinH, seems to be exactly what I need, thank you again!
17:13:09 <koz_> Is there a library providing an operator which does something like 'do f x, (f . f) x, (f . f . f) x, etc until the result no longer changes'?
17:13:16 <koz_> s/operator/function
17:13:38 <koz_> (assuming f :: a -> a obviously)
17:15:57 <EvanR> so......
17:16:10 <EvanR> how to kill threads which are no longer accessible
17:16:12 <EvanR> using the gc
17:16:35 <Hafydd> koz_: what do you mean by "do"?
17:16:44 <EvanR> i guess they will get blocked indefinitely on mvar
17:17:13 <koz_> Hafydd: I meant repeated application of f to the result of previous applications, until the answer no longer changes.
17:18:07 <maerwald> doesn't sound useful for a polymorphic function, since there's no guarantee that it will ever end
17:18:39 <Hafydd> I see.
17:18:53 <koz_> maerwald: Same could be said of unfoldr.
17:19:03 <koz_> (who's to say its generator ever returns Nothing?)
17:20:14 <ski> Rembane : no, not `fix' :)
17:20:31 <Rembane> ski: Meh. :)
17:20:34 <ski> Rembane : sorry, it took some time before i realized i had to use `join' as well
17:20:42 <ski> i'll paste in a moment
17:21:59 <monochrom> EvanR: I don't think inaccessible threads are killed. Or equivalently there is such a thing as inaccessible threads. Fork a thread that periodically prints "hello". Lose its thread ID. It will continue to print "hello". One way to see it is that the scheduler still knows about it. It is lost to you, but not lost to the scheduler. The scheduler has no reason to kill it. GC has no reason either.
17:22:27 <EvanR> if its waiting on an mvar which has no other references i think it gets killed
17:22:38 <EvanR> since it cant ever do anything else
17:23:32 <lpaste> ski pasted “looping (iteration) with no parameters, looping with continuations (non-iterative & iterative)” at http://lpaste.net/161743
17:23:37 <ski> Rembane ^
17:24:17 <Rembane> ski: That's nontrivial. :D
17:24:36 <monochrom> At which point you see the analogue of real-life government departments pointing fingers at each other. Department of Health says "I don't have jurisdiction to order its death; ask the court." The court says, "I don't have jurisdiction to order its death; ask Department of Health"
17:25:01 <ski> @tell amnn see “looping (iteration) with no parameters, looping with continuations (non-iterative & iterative)” in 2016-04-29 at <http://lpaste.net/161743>, also see logs at <http://tunes.org/~nef/logs/haskell/16.04.28>
17:25:02 <lambdabot> Consider it noted.
17:25:39 <ski> Rembane : i tried to keep the Haskell translation as faithful to the Scheme versions as i could
17:25:56 <Rembane> ski: Nice!
17:26:42 <ski> Rembane : the first was just an example of how it's possible to iterate without keeping changing state in the loop parameters
17:26:50 <ski> (simply by using mutation instead)
17:27:30 <ski> well, it's slightly non-trivial because one of these state things is a continuation function, to simulate a stack (since we wanted to translate the direct recursive version of factorial into iteration)
17:27:39 <ski> Rembane : .. that's what the OP originally asked about
17:27:52 <ski> then i added the two continuation versions, just for fun
17:28:05 <ski> (#scheme logs at <http://tunes.org/~nef/logs/scheme/16.04.23>)
17:29:23 <ski> the continuation versions don't use mutable state, and they don't use any form of recursion (including stuff like `fix'), apart from doing tricks with continuations
17:29:54 <Rembane> ski: That's really nice! :D
17:29:55 <ski> however, since the Scheme version used a cyclic type, i had to express that in Haskell, by a `newtype'
17:30:02 <EvanR> the docs say thread scheduling is "random" i wonder how accurate this i?
17:30:08 <EvanR> because thats pretty handy
17:30:13 <Sonolin> wow that makes me want to seriously learn scheme/lisp 
17:31:00 <monochrom> is "random" the verbatim word used? I would be surprised and dismayed
17:31:18 <ski> (also the cycle in the type goes through a negative/contavariant position, which is the kind of cycle that can be "dangerous")
17:32:10 <EvanR> GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion.
17:32:11 * hackagebot table-layout 0.2.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.2.0.0 (muesli4)
17:32:45 <ski> Sonolin : Scheme is a Lisp. other well-known lisps are Common Lisp and Emacs Lisp. there's also XLISP,AUTO-LISP and some more. also the newer Clojure (on JVM). and Dylan and possibly Logo could also be considered as lisps, or at least related, even though they don't use SExp syntax
17:33:12 <monochrom> that is bad. non-determinism ≠ random. an undergrad student may make that mistake. a professional shouldn't.
17:33:35 <EvanR> maybe its colloquial
17:33:47 <ski> Sonolin : Scheme is the one that has continuation side-effects, so if you're interested in that learn Scheme. Scheme also has "proper tail recursion" (a good thing, and it's not an optimization). and it has *hygienic* macros (which other Lisps tend to lack)
17:34:06 <Sonolin> interesting
17:34:07 <koz_> Scheme is pretty cool.
17:34:19 <ski> Sonolin : also see
17:34:23 <ski> @where SICP
17:34:23 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
17:34:29 <koz_> I like Haskell more (sucker for static typing) but Schemes are also fun.
17:34:32 <ski> (well, not the last link there, that's something else)
17:34:45 <koz_> ski: Wtf is that last link, lol.
17:34:46 <monochrom> still, professional programmer colloquial is a higher standard than street colloquial
17:34:55 <ski> koz_ : .. something else, as i said :)
17:35:12 <Rotaerk> is there a good resource that explains *why* the way haskell is designed (purity, laziness, etc) is beneficial?
17:35:13 <koz_> ski: The naming seems more than coincidental.
17:35:18 <ski> (perhaps the author would like to elaborate more)
17:35:24 <Rotaerk> having trouble getting someone to understand
17:35:34 <Rotaerk> and he apparently read through all of LYAH
17:35:59 <ski> @where whyfp
17:35:59 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
17:36:01 <ski> perhaps ?
17:36:04 <LordBrain> is there a cabal command to convert a sandbox into a usable .cabal folder with world file and all?
17:36:15 <Rotaerk> thanks ski
17:37:18 <ski> Sonolin : fwiw, SML/NJ also has continuations. and istr Ruby has it (though perhaps it's removed now ?), and some of the other Python implementations. possibly also some Smalltalk implementation
17:37:38 <ski> hm, MLton (another SML implementation) as well
17:38:40 <LordBrain> laziness allows you to express algorithms in a cleaner way, because the sequence of events is not as much a constraint on how you write the algorithm, thus you get more separation than strictness permits
17:40:10 <LordBrain> separation as in, this block of code and that block of code are interleaving etc, but they are organized by how we prefer to conceptualize them as components of the algorithm, where they would otherwise have to be one block of code that hides that clean presentation
17:40:39 <scshunt> LordBrain: to be fair, if you need to eke out all the performance, you have to do hoops kind of like that anyway
17:41:02 <LordBrain> thats the upshot, the down side of course is debugging can be harder than if the code were lower level
17:41:08 <ski> Sonolin : also, #scheme
17:41:40 <LordBrain> yeah, thats a nother down side
17:42:00 <dolio> I'm not sure debugging is actually harder, just the right sort of debuggers haven't been maintained.
17:42:39 <ski> Sonolin : hm, and there's also a #sicp channel
17:42:43 <ski> @where Buddha
17:42:43 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
17:43:02 <LordBrain> yeah, i think there are a lot of issues that are merely a matter of needing the right solutions to be implemented, not theoretical issues, theoretically i don't think laziness is inherently harder to debug etc... but in practice it is.
17:43:17 * ski would like a working declarative debugger for Haskell
17:44:21 <Sonolin> thanks ski gives me plenty of reading :)
17:45:59 <LordBrain> that goes for space leaks too...i think it is theoretically possible to make lazy as safe from space leaks as strict etc, but as far as i know, its still a research problem to actually do so
17:47:41 * deepfire wishes MonoFunctor was derivable for newtypes..
17:49:24 <ski> @tell amnn what's the title&author(s)&link corresponding to <https://www.cs.kent.ac.uk/events/s-repls3/abs/gibbons.txt> ? .. fwiw, this (including the applicative part) sounds like what i recently heard Marlow does in `Haxl'
17:49:24 <lambdabot> Consider it noted.
17:50:05 <ski> Sonolin : Buddha wasn't really intended for you, but you could check it out anyway, i suppose. it's a declarative debugger (bitrotted by now) for Haskell
17:51:19 <bergey> Has anyone written a tool to take GHC's suggestions of names in scope, and automate the changes?
17:51:43 <bergey> Ideally I'd like it to prompt: suggestion 1, 2, or [s]kip
17:52:26 <bergey> I have a couple hundred of these errors right now.
17:52:26 <ski> Sonolin : the idea with declarative debugging is that you pass it some initial call that computes the wrong answer. it asks you questions about other calls (made by that initial call), together with outputs, and you confirm or deny that the given output is the intended one
17:53:00 <ski> Sonolin : the declarative debugger looks at e.g. data dependencies in the program, to cut down on the number of questions to ask, and narrow down the problem
17:53:39 <ski> bergey : it'd have to be integrated with an editor, for it to make sense, imho
17:54:37 <dolio> Same for a lot of negatives around lazy/functional programming. They aren't fundamental, but are due to a lack of resources spent on it relative to other things.
17:54:41 <bergey> ski: editor integration would be nice, but why do you think it's required?
17:55:28 <ski> bergey : what other alternative did you have in mind ?
17:55:56 <dolio> I think the reduceron wasn't that far off from a standard chip at executing Haskell, which means no one would use it, because you can buy an off-the-shelf CPU designed for imperative stuff that runs your functional stuff faster.
17:56:21 <dolio> But what if the billions of dollars spent on the imperative CPU design were spent on something like the reduceron?
17:57:55 <ski> LordBrain : possibly linear or uniqueness types could help with the space leak problem, in some cases ..
17:58:06 <bergey> ski: Show the error message, with a number for each suggestion, sed -i or equivalent to make the change, seems like the simplest thing that could work.
17:58:22 <monochrom> nice, free applicative functors. what do they look like?
17:58:29 <Mateon1> Hi, I just installed MinGHC on Windows, but apparently some config got broken. In the install directory with ./bin and ./lib, the lib folder didn't contain settings or platformConstants, which GHC complained about.
17:58:41 <ski> bergey : ok. as long as the change makes it back into the source file. (i suppose i'd consider `sed' to be the "editor" in that case)
17:58:49 <Mateon1> I copied both out of an old install, but GHC still complains about not being able to parse platformConstants
17:59:02 <Mateon1> What should I do?
17:59:44 <bergey> ski: Even though it says so in the name, sometimes I forget that 'sed' is an editor. =)
17:59:48 <dolio> I think optimistic evaluation fixes a lot of the space leaks that people complain about relative to strict languages. It's just more annoying to implement.
18:00:35 <ski> monochrom : well, in the lecture i saw, it wasn't expressed as a free applicative functor. he just mentioned that one could express it in those terms, if one wanted to
18:01:30 <dolio>  newtype Free f a = F (forall g. Applicative g => (forall x. f x -> g x) -> g a)
18:03:02 <ski> monochrom : but, perhaps something like `data Free f a = Lift (f a) | Pure a | forall b. ApLift (Free f (b -> a)) (f b)' ?
18:03:22 * ski excogitates this
18:04:05 <EvanR> fix .oO( )
18:06:10 <ski> hm, actually scrap the `Lift (f a) | ' part. `Lift fa' is `ApLift (Pure id) fa'
18:09:13 <yakmlk> hi, does anyone here know about Handler in the Control.Exceptions module and if it is related to the one used in the servant package?
18:10:49 <dmj`> yakmlk: where do you see 'handler' in servant?
18:11:27 <hpc> huh, when did type and data families get so everywhere on hackage
18:12:00 <hpc> they're in just about every package relating to manipulations of 2d information i have found so far
18:12:53 <ski> @let data IdFun :: * -> * -> * where Id :: IdFun a a; Fun :: (a -> b) -> IdFun a b
18:12:55 <lambdabot>  Defined.
18:13:08 <ski> @let idApply :: IdFun a b -> (a -> b); idApply Id a = a; idApply (Fun f) a = f a
18:13:09 <lambdabot>  Defined.
18:13:22 <ski> @let idMap :: IdFun a b -> IdFun [a] [b]; idMap Id = Id; idMap (Fun f) = Fun fs where fs [] = []; fs (a:as) = f a : fs as
18:13:23 <lambdabot>  Defined.
18:13:36 <ski> @let instance Category IdFun where id = Id; Id . g = g; f . Id = f; Fun f . Fun g = Fun (f . g)
18:13:37 <lambdabot>  Defined.
18:13:44 <ntnt> anyone have a good writeup on how to do vectorclocks in haskell?
18:16:39 * ski wonders whether there's a nice way to restrict the interface of this, to make sure you can't do different things on `Id' vs. `Fun id', at the most the result for one being bottom while the other isn't
18:19:06 <yakmlk> dmj`: http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html
18:19:42 <ski> (when doing processing, it's often nice to be able to handle the "empty" case specially. e.g. writing zero bytes to a log, we can omit opening and closing the log ..)
18:20:29 <ski> (.. or, when passing around continuations, it's nice to handle the case where you pass on an unextended continuation (tail-call) specially)
18:21:22 <dolio> But if you want to not be able to tell `Id` and `Fun id` apart, you can only do that if you can figure out how to do the same optimization on `Fun id`. :)
18:21:31 <dolio> In which case you don't need Id.
18:23:04 <dmj`> yakmlk: so Handler is a type alias for ExceptT ServantErr IO
18:24:27 <dmj`> yakmlk: ExceptT would be in the mtl package
18:28:27 <EvanR> im trying to make sense of unbounded non determinism
18:44:04 <yakmlk> I guess i am just confused with the :<|> combinator 
18:44:51 <Axman6> what're you confused about?
18:59:43 <EvanR> what on earth... to implement Integral i have to implement Real ?
19:00:08 <EvanR> ... why
19:02:49 <verement> implementing Real is easy
19:03:11 <EvanR> ok... its an injection into the rationals, that always confuses me given the name of the clas
19:08:55 <EvanR> wow implementing Ord when deriving doesnt work is...
19:09:03 <EvanR> brutal
19:10:06 <simpson> It's not that bad, usually; how nasty is your ADT?
19:10:24 <EvanR> its 5 ctors one of them happens to have an MVar that is not involved in the comparison process
19:10:36 <simpson> Yikes. Well, not the worst.
19:13:20 <yakmlk> Axman6: There are places in my computations that need a PrimMonad class. I'm essentially taking a file name and trying to sort the contents. 
19:14:19 <EvanR> ok, its claiming my patterns are overlapped. now that i implemented Eq
19:14:23 <EvanR> but i dont know why
19:16:19 <EvanR> http://lpaste.net/161784
19:16:25 <EvanR> it says line 3 overlaps
19:16:46 <EvanR> how is it coming to that conclusion
19:22:03 <erisco> I was reading not long ago about a syntax extension that allows you to pattern match a constructor without knowing the number of arguments… but I've lost the reference
19:23:09 <koz_> erisco: Do you mean the record syntax?
19:23:17 <erisco> yes
19:23:54 <koz_> erisco: https://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29 
19:24:11 <erisco> thanks
19:24:34 <EvanR> that would be nice
19:24:36 <koz_> erisco: No worries.
19:31:50 <EvanR> what i was wondering was
19:32:09 <EvanR> *why* does integral depend on Real
19:32:23 <EvanR> i mean it seems easy to implement but
19:33:40 <geekosaur> if you ever figure it out, let the rest of us know...
19:38:39 <verement> conceptually, integral numbers are also real numbers
19:39:06 <geekosaur> the Real typeclass has nothing to do with the real number line
19:39:07 <verement> having a Real instance also allows conversion to a Fractional via realToFrac
19:39:08 <EvanR> does the stdlib make use of this fact
19:39:18 <geekosaur> the description makes it sound like it means "hardware representable"
19:39:26 <geekosaur> but that's not actually true either
19:40:35 <EvanR> also even if i admit integers "are really reals" it doesnt really make sense to be thinking of reals at the same time as some integral domain
19:41:22 <EvanR> alright so its about realToFrac
19:41:26 <EvanR> :t realToFrac
19:41:27 <lambdabot> (Fractional b, Real a) => a -> b
19:41:30 <EvanR> nope
19:41:39 <geekosaur> it *may* mean "scalar"
19:42:20 <EvanR> rationals just seem inappropriate when doing integer division
19:42:42 <verement> @src realToFrac
19:42:42 <lambdabot> realToFrac = fromRational . toRational
19:42:56 <EvanR> :t toRational
19:42:57 <lambdabot> Real a => a -> Rational
19:43:08 <EvanR> nothing to do with Integral
19:44:01 <verement> yeah I suppose fromIntegral is a more direct path in most cases
19:44:15 <ski> dolio : well, note the "at the most the result for one being bottom while the other isn't" part :)
19:51:42 <EvanR> i guess i dont get how pattern matching works with Eq and OverloadedString
19:52:07 <EvanR> OverloadedStrings emits fromString, but that doesnt make sense in a pattern
19:52:40 <EvanR> and it cant tell me about overloaded strings without doing compile time equality checking... right?
19:52:49 <EvanR> about overlapping patterns
19:53:19 <EvanR> can Eq instances cause compiler looping when checking for pattern overlap?
19:53:36 <ski> i'd imagine
19:53:40 <ski>   foo "foo" = ...
19:53:45 <ski> gets turnes into something like
19:54:11 <ski>   foo ((fromString "foo" ==) -> True) = ...
19:54:24 <ski> (or with an equivalent guard)
19:54:43 <EvanR> so view patterns
19:54:52 <ski> well, possibly
19:55:01 <EvanR> cause cautious warnings about overlap even if its not
19:55:13 <ski>   foo ss | fromString "foo" == ss = ...  -- the guard version
19:55:18 <EvanR> and is this how regular numbers work in patterns?
19:55:32 <ski> i believe so
19:55:39 <nitrix> I've read they're hacked similarly, yeah.
19:55:49 <EvanR> but i dont get warnings about case 4, 5, 6
19:55:55 <nitrix> It was terrible back when we had the k+1 patterns.
19:55:57 <EvanR> or do i
19:56:02 <nitrix> It was one of the main arguments.
19:56:12 <ski> (main arguments ?)
19:56:22 <nitrix> In the mailinglist.
19:56:33 <ski> main arguments for what ?
19:56:44 <nitrix> Oh. Removing it.
19:57:05 <ski> oh. ok
20:29:08 <EvanR> yep... unbounded nondeterminism not working
20:30:53 <EvanR> http://lpaste.net/161801
20:31:42 <Heasummn> has anyone messed with yesod?
20:31:46 <EvanR> send itself the +1 message in a loop... and also tell it to stop looping
20:31:53 <EvanR> and check the result
20:42:17 <EvanR> replaced mvar with chan, and i got at most unbounded = 1
20:42:26 <EvanR> maybe its super fair
21:15:12 <shanemikel> I wonder why there's all this buzz about moving terms to type level, and not types to term level
21:16:55 <shanemikel> jk
21:17:26 <shanemikel> that's nice hackage seems to be back.  what happened?
21:19:25 <nitrix> shanemikel: Are you talking about dependent types?
21:19:30 <shanemikel> yeah
21:20:41 <nitrix> It's additional information at the type level; so theorically even safer and opens up even more optimizations.
21:21:12 <shanemikel> no, I know.  I was just being dumb
21:25:06 <EvanR> agreed
21:25:15 <EvanR> we should swap the term and type level
21:25:25 <Romefeller> Hi all
21:25:28 <shanemikel> I just watched the google talks video explaining the girard-reynolds isomorphism.  mind blown.. now I know how to defend the assertion that when you get the types right, usually your program works. before I always considered it a bit of folk wisdom
21:25:31 <EvanR> another idea, move the value level down one level, we must go deeper
21:26:25 <shanemikel> EvanR: I wonder what the next level down is.. an external resource? or the users brain?
21:26:26 <EvanR> shanemikel: link?
21:26:36 <shanemikel> https://www.youtube.com/watch?v=h0OkptwfX4g
21:31:56 <shanemikel> I don't know if I understand well enough to explain it, but basically predicate logic and system-f form an isomorphism, where in hindley-mindler you can infer types, with type level programming you can infer the implementation.  so, when you are only dealing in parametric polymorphism, predicate logic and typed lambda calculi converge
21:34:10 <ski> hm, not quite predicate logic, i think
21:34:42 <shanemikel> or, do they call it predicate calculus?
21:34:48 <ski> you can quantify over types/propositions (and connectives/operations over those). but not over terms/individuals/values
21:35:37 <ski> sometimes i've seen the name "second-order predicate logic", but that's not right either. more like "second-order predicate logic, without first-order predicate logic"
21:35:43 <ski> the terminology is wonky here
21:36:10 <shanemikel> right, but with parametrically polymorphic arguments, terms are irrelevant
21:37:07 <ski> (it seems to assume that if you're allowing quantification over propositions, and constructions over those, that you're also already quantifying over terms, but that's not the case here)
21:38:15 <shanemikel> that went over my head.. I'm still getting there
21:38:31 <shanemikel> stay here for a few years.  I'll be back :)
21:42:08 <ski> well. there's propositional logic, which only talks about atomic propositions, and ones built from those using basic connectives (true,false,and,or,implication,not,biimplication)
21:43:34 <ski> then that is extended to first-order predicate logic, which adds `n'-ary predicates/relations (atomic propositions are `0'-ary) relating terms, and commonly also `n'-ary functions on terms, (usually) the equality relation on terms, and the universal and existential quantifier on terms
21:45:11 <ski> then that is extended to second-order predicate logic, also allowing (second-order) relations and functions relating terms to (first-order) relations and functions, and adding universal and existential quantifiers on first-order predicates (including propositions) and functions
21:45:15 <ski> and so on
21:46:02 <ski> so this second-order predicate logic now includes what System F can express (quantification over propositions, and over operations combining propositions into new propositions)
21:47:08 <ski> (note that a function combining propositions into a new proposition is the same thing as a relation/predicate relating propositions to each other)
21:50:16 <shanemikel> sounds like rankntypes?
21:51:22 <EvanR> ski: and in this terminology soup there is combinatory logic
21:51:41 <EvanR> which is synonymous with something already mentioned but i forgot what
21:51:51 <ski> `RankNTypes' allows `forall's to be nested anywhere in function or argument type position, however deeply nested that function type is
21:52:39 <ski> but you can already put quantifiers in any proposition context, in first-order predicate logic
21:54:06 <EvanR> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
21:54:06 <lambdabot> f a b c = a c (b c)
21:54:09 <EvanR> nice
21:55:09 <ski> @djinn NotNotNot a -> Not a
21:55:09 <lambdabot> f a b = void (a (\ c -> c b))
21:55:37 <ski> @djinn ((NotNot a -> a) -> Not b) -> Not b
21:55:37 <lambdabot> f a b = void (a (\ c -> void (c (\ d -> a (\ _ -> d) b))) b)
21:55:53 <ski> @djinn (Either a (Not a) -> Not b) -> Not b
21:55:54 <lambdabot> f a b = void (a (Right (\ c -> a (Left c) b)) b)
21:56:02 <EvanR> @djinn a -> a -> a
21:56:02 <lambdabot> f _ a = a
21:56:10 <EvanR> hmm only 1 answer
21:56:17 <ski> @djinn Not (Either a b) -> (Not a,Not b)
21:56:18 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
21:56:31 <shanemikel> probably a setting to keep the channel from being spammed
21:56:34 <shanemikel> accidentally
21:56:36 <ski> no quantifiers, though
21:57:37 <EvanR> @djinn a -> Bool
21:57:37 <lambdabot> f _ = False
21:58:47 <shanemikel> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
21:58:47 <lambdabot> f a b c = a (\ d -> b d c)
21:59:39 <nshepperd> hmm
22:00:24 <nshepperd> (Not a -> a) -> a doesn't work, but NotNot (Not a -> a) -> NotNot a does
22:01:12 <shanemikel> well I think that is correct >>= for cont
22:02:00 <nshepperd> oh neat, we have loeb :: Functor f => f (f a -> a) -> f a
22:02:35 <nshepperd> which is actually way stronger than the normal loeb's theorem?
22:02:48 <ski> yep
22:02:59 <MichaelBurge> @djinn Functor f => f (f a -> a) -> f a
22:02:59 <lambdabot> Error: Class not found: Functor
22:03:29 <ski> you could add `Functor' to it, with `@djinn-add', but ..
22:03:41 <nshepperd> @djinn NotNot (NotNot a -> a) -> NotNot a
22:03:41 <lambdabot> -- f cannot be realized.
22:03:45 <MichaelBurge> @djinn-add Functor
22:03:45 <lambdabot> Cannot parse command
22:03:48 <ski> .. it doesn't understand quantification, and `fmap' is a polymorphic method
22:03:57 <ski> @djinn Monad m => a -> m a
22:03:57 <lambdabot> f = return
22:04:00 <ski> @djinn Monad m => b -> m b
22:04:01 <lambdabot> -- f cannot be realized.
22:04:03 <ski> ^
22:04:37 <ski> @djinn (NotNot a -> NotNot b) -> NotNot (a -> b)
22:04:38 <lambdabot> f a b =
22:04:38 <lambdabot>     void (b (\ c -> void (a (\ d -> d c) (\ e -> b (\ _ -> e)))))
22:04:51 <ski> @djinn NotNot (a -> b) -> (NotNot a -> NotNot b)
22:04:51 <lambdabot> f a b c = void (b (\ d -> void (a (\ e -> c (e d)))))
22:04:57 <EvanR> so djinn can generate functions involving ground types, and it can deal with type classes
22:05:16 <ski> it can deal with type classes with *monomorphic* methods (e.g. `Eq')
22:05:21 <EvanR> though the video claimed otherwise
22:05:50 <ski> @djinn Eq a => Maybe a -> Maybe a -> Bool
22:05:50 <lambdabot> f a b =
22:05:50 <lambdabot>     case a of
22:05:50 <lambdabot>     Nothing -> case b of
22:05:50 <lambdabot>                Nothing -> False
22:05:50 <lambdabot>                Just c -> c == c
22:05:52 <lambdabot>     Just d -> d == d
22:06:07 <shanemikel> still damn impressive
22:06:09 <nshepperd> hmm, 'NotNot (NotNot a -> a) -> NotNot a' should work since NotNot is a functor. I guess djinn can't find the definition because of the recursion?
22:06:30 <ski> djinn doesn't do recursion, correct
22:07:35 <ski> @djinn ((NotNot a -> NotNot a) -> NotNot a) -> NotNot (NotNot a -> a) -> NotNot a
22:07:35 <lambdabot> f a b c =
22:07:36 <lambdabot>     void (b (\ d -> void (c (d (\ e -> void (a (\ f -> f) e))))))
22:08:15 <ski> Djinn is doing something logic-programming like
22:08:23 <EvanR> @djinn NotNot a -> a
22:08:23 <lambdabot> -- f cannot be realized.
22:08:37 <shanemikel> so, an isomorphism can be ambiguous, as long as the transformation isn't lossy through a round-trip
22:08:38 <nshepperd> ah, did you manually supply fix there?
22:09:22 <ski> yes
22:09:29 <ski> (at the correct type)
22:09:55 <ski> shanemikel ?
22:10:19 <shanemikel> well, I don't know the jargon, I guess.. but I'm talking about this:
22:10:23 <ski> oh, i suppose you mean that there can be more than one isomorphism between any two given types
22:10:29 <shanemikel> @djinn a -> a -> a
22:10:30 <lambdabot> f _ a = a
22:10:37 <ski> (yes ?)
22:10:44 <shanemikel> yeah ski, I guess that's what I meant
22:11:00 <ski> e.g. with `data AB = A | B' and `data XY = X | Y'
22:11:00 <nshepperd> eh, wait is that really right, it's passing id to fix there
22:11:10 <ski> we could associate `A' with `X' and `B' with `Y'
22:11:23 <ski> or otherwise `A' with `Y' and `B' with `X'
22:11:37 <shanemikel> yeah, sure.
22:11:55 <shanemikel> so, does an isomorphism need be deterministic?
22:11:55 <ski> so that's the factorial of `2' (= `1 * 2 = 2') number of isormorphisms, because we had two inhabitants
22:12:24 <ski> a specific isomorphism is a total function, that is injective and surjective (iow bijective)
22:12:31 <ski> and total functions are deterministic
22:12:51 <EvanR> youd call a nondeterministic function non total?
22:13:11 <ski> (btw, note that when i say "isomorphism" here i mean "set isomorphism". there's also other (more structured) kinds of isomorphisms, and then bijectivity needn't suffice)
22:13:27 <ski> EvanR : depends
22:14:11 <shachaf> Of only other kinds of isomorphisms also only needed to be epimorphisms and monomorphisms.
22:14:21 <ski> i'm taking "nondeterministic" here to mean that there can possibly be any number of outputs associated to a single given input
22:14:43 <ski> that includes an input possibly being associated to zero outputs, and in that case, the function is not total
22:15:29 <MichaelBurge> I think the fully expanded version of bindC in that google video was: @djinn ((a -> x) -> a) -> (a -> ((b -> x) -> b)) -> ((b -> x) -> b)
22:15:33 <MichaelBurge> @djinn ((a -> x) -> a) -> (a -> ((b -> x) -> b)) -> ((b -> x) -> b)
22:15:33 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
22:16:03 <shachaf> s/Of/If/
22:16:07 <ski> MichaelBurge : that's Martín Escardó's `J' monad, yes ?
22:17:02 <ski> shachaf : retraction / split epi, & section / split mono, suffices :)
22:17:26 <ski> MichaelBurge : iow, not the continuation monad
22:17:27 <shachaf> ski: True. Maybe split epi/mono is what surjective/injective "really" means.
22:17:46 <ski> @djinn ((a -> o) -> o) -> (a -> (b -> o) -> o) -> ((b -> o) -> o)
22:17:46 <lambdabot> f a b c = a (\ d -> b d c)
22:17:50 <shachaf> Well, hopefully surjective doesn't "really" mean split epi because that would require the axiom of choice.
22:18:39 <MichaelBurge> ski: Yeah, you're right.
22:18:43 <ski> hm, i vaguely recall that there was a way to set up the internal logic so that what looked like surjectivity, internally, turned out to be epi, externally
22:19:08 <ski> (in Paul Taylor's "Practical Foundations of Mathematics", iirc)
22:19:31 <shanemikel> ski: what's the J monad? is there a paper?
22:20:04 <dolio> J r a = (a -> r) -> a
22:20:17 <ski> @where impossible
22:20:18 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
22:20:27 <ski> shanemikel : ^ is a good starting point, i think
22:21:51 <shanemikel> well, the title is interesting enough
22:22:27 <MichaelBurge> I can see in the continuation monad a calculation that is 'waiting on' an a. But with this supposed J monad, I wonder how the r in dolio's definition gets used(besides just carrying it around, I guess).
22:23:06 <MichaelBurge> I guess I'll just read that article
22:23:53 <ski> MichaelBurge : `r' might be `Bool', e.g.
22:24:52 <ski> MichaelBurge : so, we're getting in a predicate on `a's, and we're attempting to construct an `a', such that it satisfies the property, if there's any inhabitant at all that does
22:25:02 <ski> this is related to the "drinker paradox"
22:25:22 <shanemikel> in other words, an uninteresting variation
22:25:30 <shanemikel> and less flexible
22:26:24 <ski> if we can construct such an `(a -> Bool) -> a', then we can easily construct both an existential, and universal quantifier, on `a'
22:26:35 <MichaelBurge> ski: I used to comb through the paradoxes on Wikipedia all the time, but this drinker paradox escaped me
22:26:39 <MichaelBurge> Thanks for the material
22:27:18 <ski> the idea is : in any (inhabited) pub, there's a person such that if anybody drinks, then that person drinks
22:27:24 <ski> that's the existential variant
22:27:54 <ski> there's also the universal variant (considered by Hilbert, when thinking about foundations of math) :
22:28:13 <ski> in any (inhabited) pub, there's a person such that if that person drinks, everybody drinks
22:28:33 <ski> the first kind of person is most eager to drink, starts drinking as soon as anybody else does
22:28:35 <ggVGc> is that person very pursuasive?
22:29:09 <ski> the second kind of person is least eager to drink. if that person should ever drink (may or may not happen), it must already be that everybody else is also drinking
22:29:52 <ski> if `D' is the predicate "is drinking", then we can write the first kind of individual as `epsilon_D', and the second kind as `tau_D'
22:30:45 <JoshS> It sounds like there has to be at least one person who is willing to drink by himself otherwise no one will drink
22:30:51 <dysfun> yes assigning greek letters obviously makes it much easier to understand
22:30:52 <JoshS> someone has to go first, right?
22:31:01 <ski> then we can implement the existential `exists x. D(x)' as `D(epsilon_D)', and the universal `forall x. D(x)' as `not D(epsilon_{not . D})'
22:31:23 <JoshS> god, I'm with dysfun talk English, man
22:31:26 <ski> or, alternatively we can implement the universal `forall x. D(x)' as `D(tau_D)', and the existential `exists x. D(x)' as `not D(tau_{not . D})'
22:31:38 <JoshS> Ok, I'm going to taco bell instead of reading this
22:31:46 <EvanR> we can implement the vertical... and we can implement the horizontal
22:31:51 <ski> dysfun : these are the traditional letters that have been used in this context :)
22:33:21 <dysfun> traditional they may be, but intuitive less
22:33:41 <shanemikel> they are pretty ugly w/o unicode
22:33:56 <ski> @tell MichaelBurge see "Searchable Sets, Dubuc-Penon Compactness, Omniscience Principles, and the Drinker Paradox" by Martín H. Escardó,Paulo Oliva in 2010 at <http://www.cs.bham.ac.uk/~mhe/papers/dp.pdf>,<http://www.cs.bham.ac.uk/~mhe/papers/DP/>,<http://www.cs.bham.ac.uk/~mhe/papers/> (also see log at <http://tunes.org/~nef/logs/haskell/16.04.28>)
22:33:57 <lambdabot> Consider it noted.
22:33:57 <shanemikel> visual cues are bueno
22:34:00 <dysfun> i'm pretty sure i recall being told "proofs should be written in english before maths"
22:34:20 <ski> dysfun : intuitive is at least partly a matter of familiarity
22:34:25 <JoshS> All I got from this is that I could use a drink
22:34:37 <dysfun> yes, i only just woke up and i already want a drink
22:34:46 <shanemikel> okay, well which drinker is which?
22:34:57 <shanemikel> dysfun: is #2
22:34:58 <ski> dysfun : how about some nice hot tea, with honey ?
22:35:15 <shanemikel> ski: so what's the paradox?
22:35:18 <dysfun> ski: i am drinking tea, just with milk
22:35:54 <shanemikel> that they can't be in the same bar
22:35:55 <JoshS> in this system is it possible that a) no one is willing to drink alone, but multiple people can still drink, ie people can collude to drink together
22:36:14 <ski> shanemikel : as is often the case, it's just called a paradox. to a first comprehension, it sounds a bit wild that there has to be such an individual
22:36:17 <JoshS> or does someone have to go first and be observed to start the drinking
22:36:52 <ski> shanemikel : oh .. and the argument is of course non-constructive
22:37:00 <JoshS> I give up
22:37:12 <ski> JoshS : the former
22:37:16 <JoshS> why would I expect anyone to be clear in #haskell
22:37:34 <Zemyla> Infinite search in finite time works because, if the runtime of the function is always bounded, then there's a finite amount of complexity or something?
22:37:37 <shanemikel> I for one, am very grateful for this channel
22:38:50 <shanemikel> no reason to complain JoshS, are you frustrated because you are having a haskell problem?
22:38:52 <ski> Zemyla : one reason it works is because if you have a total function from streams of `Nat' (say), to a `Nat', then that can only possibly look at a finite prefix of the input stream, and so must give the same answer for every input stream sharing the same prefix
22:38:55 <EvanR> ski: i just looked up drinkers paradox and noticed the proof using law of excluded middle
22:39:03 <EvanR> is there a constructive proof
22:39:09 <ski> Zemyla : so, one can do a proof of termination, by induction on the length of this prefix
22:39:34 <JoshS> nah I was just frustrated because I assumed the second case, so the English part of the question seemed trivially pointless
22:39:51 <ski> EvanR : not in general, there isn't. however Escardó's paper is about studying cases of sets where there is in fact a constructive proof
22:39:52 <JoshS> And I didn't understand why turn a trivial problem in to greek letters and stuff
22:40:09 <Zemyla> ski: Even if it can take a finite but unbounded amount of time?
22:40:16 <ski> JoshS : the greek letters stuff was just labelling, and historical terminology
22:41:03 <ski> Zemyla : philosophically, it amounts to believing in the axiom of bar recursion (or perhaps some weaker variant)
22:41:04 <EvanR> JoshS: go greek
22:41:15 <dolio> Nat the set (as typically defined) isn't an example of a searchable infinite space, though.
22:41:25 <ski> Zemyla : which, iiuc, is related to whether you think the universe is algorithmic, or alternatively only computational
22:41:39 <dolio> Although what you get from the same sort of definition in Haskell is.
22:42:56 <ski> (the one-point compactification of the natural numbers, aka the generic convergent sequence)
22:43:39 <dysfun> okay, you've completely lost me now
22:44:07 <ski> well .. the idea is that if we have the natural numbers `{0,1,2,3,...}'
22:44:09 <dysfun> why isn't the set of natural numbers 'searchable'?
22:44:28 <dysfun> what does 'searchable' mean in this context?
22:44:43 <ski> dysfun : because you can't test a boolean predicate on all the natural numbers, in finite time
22:44:55 <ski> then we "add a point at infinity to it" : `{0,1,2,3,...,infinity}'
22:45:00 <dysfun> surely for an arbitrary predicate, you can't do that on any infinite set?
22:45:25 <ski> now, a function from `{0,1,2,3,...}' to a set `A' is the same as a stream / infinite sequence of inhabitants of `A'
22:45:49 <shachaf> The Haskell type data Nat = Z | S Nat is almost this compactified naturals.
22:45:56 <ski> but, a function from `{0,1,2,3,...,infinity}' to `A' will be a *convergent* infinite sequence of inhabitants of `A'
22:46:18 <dysfun> why?
22:46:33 <ski> `f(i)' as `i' goes to infinity, will converge to `f(infinity)'
22:46:46 <dysfun> right, so it's like calculus, approaching a limit?
22:47:03 <ski> so, this is supposed to explain why `{0,1,2,3,...,infinity}' is called "the generic convergent sequence"
22:47:26 <dysfun> i'm not sure what the impact of that is
22:47:32 <shachaf> It has to be a continuous function, in particular.
22:47:56 <ski> since the obvious function from `{0,1,2,3,...}' to `{0,1,2,3,...,infinity}', can be thought of as a sequence in the latter set. and in fact it is a converging sequence (converging to `infinity')
22:47:57 <shachaf> Which means that it can't distinguish the point at infinity from a point which is just really big.
22:48:05 <ski> yes
22:48:21 * ski glossed over some details in how the `infinity' inhabitant was really added
22:48:32 <shachaf> It can ask questions like "is this point bigger than N?" for any finite N.
22:48:47 <ski> it wasn't just `data NatInf = Finite Nat | Infinite'
22:49:07 <dolio> The reason in a total type theory is, I believe, is that you can do induction on the natural numbers, but not the one point compactification (which is coinductive).
22:49:40 <dolio> Which makes decidable predicates on them fairly different.
22:49:45 <ski> dysfun : yes. the continuity comes from the computational structure here
22:50:04 <ski> dysfun : every computable function is continuous, wrt this
22:50:36 <dysfun> nope, you've still lost me
22:50:59 <dolio> I can write 'is even' on the naturals but not the extended naturals, I think.
22:51:04 <dysfun> we're talking about maths rather than haskell, aren't et?
22:51:06 <dysfun> we*
22:51:33 <ski> we're talking about computation. math, if you want to think of it like that
22:51:48 <dysfun> right. well i've noticed haskell isn't very good at letting me define integrals :)
22:51:58 <ski> the actual construction of `NatInf' is to say that it's the set/type of decreasing binary sequences
22:52:30 <ski> so, the decreasing binary sequence `(1,1,1,0,0,0,0,0,...)' will represent the number `3'
22:52:33 <shachaf> The computated naturals, also known as the amputated conaturals.
22:52:45 <ski> a constantly `0' decreasing sequence will represent `0'
22:52:51 <dysfun> shachaf: and they say mathematicians aren't macabre!
22:52:57 <ski> and a constantly `1' decreasing sequence will represent `infinity'
22:53:11 <shachaf> I'm afraid I'm the only one who's macabre here.
22:53:13 <ski> you can compute addition and so on, one such sequences
22:53:16 <doubling> what about a constantly 'infinity' decreasing sequence
22:53:39 <dolio> Infinity isn't a binary digit.
22:53:43 <ski> doubling : well, that'd be a different type
22:53:53 <doubling> what about a decreasing sequence of types
22:54:17 <doubling> starting at full ML type theory
22:54:17 <ski> you'd have to say which notion of ordering on types you want
22:55:04 <ski> anyway, the point here is that if we're given an arbitrary decreasing infinite binary sequence, then we can only know a finite prefix of it at any point in time
22:55:18 <ski> if we've seen a `0', then we know that the number is finite
22:55:30 <doubling> but you can co-know the rest
22:55:34 <ski> otherwise it might be `infinity', or it might just be that we haven't waited long enough
22:55:41 <doubling> so you co-know if it's finite or not
22:56:02 <ski> "co-know" being "not-know-not", or ?
22:56:12 <dysfun> but if you're just given an arbitrary span within the set, presence of zero doesn't indicate infinity?
22:56:28 <doubling> it's the category theoretic dual of knowledge
22:56:45 <doubling> knowledge is built up from observations and rules of inference
22:56:50 <ski> doubling : well, it needn't exist in the same category
22:56:51 <doubling> coknowledge goes the other way
22:57:12 <doubling> you always coknow something until you coforget it
22:57:23 <shanemikel> lol
22:57:27 <dysfun> is the riemann hypothesis coknowledge then?
22:57:36 * ski is assuming doubling is perhaps thinking of something like dual-intuitionistic logic (Igor Urbas, Rajeev Gore), or subtractive logic (Crolard)
22:57:58 <doubling> igor urbas rajeev gore crolard
22:58:10 <ski> yes
22:58:11 <doubling> even their names are weird
22:58:15 * ski smiles
22:59:13 * ski . o O ( information vs. exformation )
22:59:51 <pharaun> coformation
22:59:51 <ski> (i suppose related to "intrinsic vs. extrinsic")
23:00:43 <ski> iiuc, "exformation" being about what ramifications a datum will have in a certain context
23:01:01 <shadowdao> In formation.
23:01:41 <ski> doubling : anyway .. you might perhaps appreciate to know that any infinite sequence of types can be shown to converge to any type you like
23:01:47 <Zemyla> In a category-theoretic duel, do you coshoot, coturn, and cowalk 10 copaces?
23:04:06 <shanemikel> I think you're supposed to shoot last
23:04:26 <cocreature> then you are the terminal object
23:06:17 <shadowdao> Zemyla: That's not a copacetic analogy, perhaps.
23:09:32 <Zemyla> shanemikel: No, you shoot last in a regular duel.
23:10:55 <shanemikel> I guess codueling is the smarter choice, than
23:11:12 <cocreature> codualing
23:11:41 <shanemikel> that doesn't help the pun
23:23:46 <ij> Does tagsoup work with ghc 7.10 and folddables?
23:29:20 <ij> Because it does look like foldables are causing the issue: http://sprunge.us/Vhjc
23:33:26 <lyxia> ij: I just installed it without an issue
23:34:01 <ij> hmmmmmmmmm, what the hell then. :/
23:34:15 <lyxia> somehow you have overloaded strings on
23:35:24 <ij> Ooooh, I wanted it on only for my files, but if course stack.yaml is a more general.
23:35:56 <lyxia> heh
23:35:57 <ij> I can do it in project.cabal.
23:37:21 * hackagebot tasty 0.11.0.3 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-0.11.0.3 (RomanCheplyaka)
