00:05:50 <LordBrain> is mu a fork of ghc, or an entirely separate code base?
00:07:17 <Gurkenglas> Why are Maps fromlists not generalized to Foldables?
00:07:40 * hackagebot t3-server 0.2.0 - tic-tac-toe server  https://hackage.haskell.org/package/t3-server-0.2.0 (jxv)
00:07:40 * hackagebot t3-client 0.2.0.0 - tic-tac-toe Rexports for client  https://hackage.haskell.org/package/t3-client-0.2.0.0 (jxv)
00:07:51 <LordBrain> there is overloaded lists and the IsList class
00:08:13 <Lokathor> Gurkenglas, because it was written before Foldable became part of the Prelude, i bet
00:11:49 <LordBrain> there's no IsList instance for Map in older ghc's tho
00:12:13 <cocreature> also it’s called fromList, generalizing that would be weird
00:12:37 <LordBrain> why weird?
00:12:55 <cocreature> if a function has List in the name I expect it to only work for lists :)
00:13:31 <LordBrain> yeah
00:13:40 <LordBrain> better make a fromFoldable
00:13:40 <cocreature> I’d be fine with a fromFoldable
00:13:53 <cocreature> hoolooks like a bunch of packages have that function
00:14:12 <LordBrain> IsList generalizes the return type tho, not the input parameter
00:15:24 <LordBrain> which is analogous to fromString, but not so relevant since that's not what he asked
00:15:52 <LordBrain> its 3am here
00:16:40 <Gurkenglas> made it into a https://github.com/aelve/haskell-issues/issues/33
00:20:02 <Tendies> can someone see if any incorrect indentation jumps out at you? http://lpaste.net/158297 ghc is only saying parse error on the last putStr
00:22:19 <Lokathor> Tendies, your parens don't match
00:22:20 <geekosaur> I get a missing close parenthesis\
00:22:46 <LordBrain> what text editor do you use Tendies ?
00:22:54 <Tendies> sublime
00:23:08 <Tendies> ghc was telling me parse error way after that paren :o
00:23:09 <LordBrain> does it not highlight parenthesis matches for you?
00:23:26 <LordBrain> i'm not familiar with it
00:23:50 <Lokathor> ghc will get really confused about parens a lot of the time
00:24:16 <LordBrain> it may pay off to tweak your environment some... to get a nice programming editor
00:24:48 <Lokathor> i think a new editor isn't needed
00:24:55 <cocreature> ed should be enough for everybody
00:24:57 <Lokathor> but i'd use let to name some of those intermediate steps there
00:24:59 <Tendies> i see what it did actually
00:25:36 <Tendies> it threw the error when it didnt find a close paren, at the absolute latest a paren would possibly have been
00:27:28 <LordBrain> that sounds like acceptable behavior for the compiler to me
00:27:40 <Lokathor> yeah that's what i mean by "gets confused"
00:27:42 <Tendies> yeah i was just looking in the wrong place
00:28:11 <LordBrain> try one of these lisps in that editor.. you will die
00:28:49 <Lokathor> LordBrain, i'm sure that sublime will match parens, just not when your cursor isn't next to a paren
00:28:52 <LordBrain> maybe sublime has a plugin tho
00:29:00 <LordBrain> oh ok
00:29:00 <Lokathor> which is what basically every editor ever does anyway
00:29:29 <LordBrain> i don't mean to pick on sublime, i'm not familiar with it, it could be awesome
00:29:40 <Tendies> i'm not at my most alert in any case, for seeing underlined parens :P
00:30:25 <Lokathor> even emacs, mighty titan of editors, doesn't show mismatched parens if you don't have the cursor next to one of them
00:32:36 <Tendies> 5 parens deep, what have i done
00:32:58 <Lokathor> i told ya, gotta name those intermediate expressions
00:33:44 <Tendies> i don't really know how to do that without variables
00:33:55 <LordBrain> he mans use 'variables'
00:33:58 <LordBrain> bindings
00:34:17 <Lokathor> let foo = <expr here>
00:34:20 <Lokathor> and such
00:34:35 <LordBrain> bindings is a better word in haskell, unless you actually mean a mutable value
00:34:47 <Tendies> inside a do, can i use name <- (((((((((mess)))))))) ?
00:34:51 <Lokathor> https://github.com/Lokathor/ireniko/blob/master/src/Main.hs#L183 
00:34:55 <Lokathor> here's an example
00:35:04 <LordBrain> yes
00:35:15 <LordBrain> <- notation works only inside a do, where else could you use it?
00:35:25 <LordBrain> maybe i misunderstand the question
00:35:46 <Tendies> idk, a list comprehension?
00:36:16 <LordBrain> well that's true
00:36:28 <LordBrain> i don't think of it the same way, but it is the same thing
00:36:44 <Lokathor> but a list comprehension secretly uses the same thing that do-notation does, under the hood :3
00:36:51 <LordBrain> yeah
00:46:41 <cocreature> we do have monad comprehensions :)
00:47:54 <Tendies> can someone help me with this? it says on line 4 col 23: can't match expected IO t0 with actual [c0] http://lpaste.net/158297
00:48:27 <Tendies> also why does lpaste give me all these non errors about how it thinks i should write things?
00:51:09 <cocreature> Tendies: try let a = zipWith …
00:51:28 <cocreature> <- is only for monadic results
00:51:46 <Tendies> is that why it's talking about IO
00:52:06 <cocreature> yes it expects an IO something but you don’t give it an IO something
00:53:22 <Tendies> on line 5 how do i solve an error of show being applied to too many args, . or $?
00:54:51 <cocreature> show (reverse (take (read degree + 1) a))
00:55:01 <cocreature> or use $
00:55:23 <Tendies> oh god
00:55:34 <ggVGc> man I accidentally used ^~ instad of .~ yesterday, and it compiled because the field was an integer..
00:55:38 <ggVGc> took me an hour to track down
00:55:42 <ggVGc> since I'm very new to using Lens
00:55:48 <ggVGc> why is ^~ even a thing??
00:56:32 <Cale> ggVGc: beats me. Import Control.Lens.Combinators to get everything except the operator symbols
00:58:26 <Jinxit> ggVGc: same reason that +~ exists?
00:59:06 <ggVGc> +~ seems more reasonable than ^~
00:59:31 <ggVGc> but yeah okay
01:03:54 <Cale> They're all pretty much subsumed by %~
01:22:26 <Hrk> @pl \a b -> length . filter id $ zipWith (/=) a b
01:22:27 <lambdabot> ((length . filter id) .) . zipWith (/=)
01:24:09 <cocreature> we should rename @pl to @makemycodeunreadable
01:25:35 <U542> adf
01:26:03 <U542> anyone knows where i can get a verified image file of kali linux?
01:30:30 <puregreen> U542: wrong channel (also, can't you just download it from the official site and check the SHA1 sum?)
01:30:44 <U542> i did check the sha1 sum
01:31:04 <U542> but still that doesnt mean its the real file
01:31:15 <U542> it just means the structure is not corrupt
01:31:34 <cco> > [unsafePerformIO (print 1), unsafePerformIO (print 2)] `using` evalListNth 1
01:31:35 <lambdabot>  Not in scope: ‘unsafePerformIO’Not in scope: ‘unsafePerformIO’    Not in sco...
01:31:35 <lambdabot>      Perhaps you meant ‘fusing’ (imported from Control.Lens)Not in scope: ‘ev...
01:32:21 <cco> running that in ghci prints `2` first
01:32:32 <puregreen> for me it doesn't even typecheck in ghci
01:32:50 <puregreen> http://lpaste.net/158306
01:33:08 <cco> erp. There should be an rseq at the end
01:33:22 <puregreen> okay, then it prints 2 for me too, yeah
01:33:50 <puregreen> this seems reasonable
01:34:00 <U542> perhaphs my problem its EFI
01:34:05 <cco> Doesn't it seem like it should print 1?
01:34:10 <puregreen> U542: still wrong channel, sorry
01:34:27 <U542> where can i check?
01:34:34 <puregreen> you're in #haskell
01:34:41 <puregreen> cco: why? nth element of the channel is “print 2” in this case
01:34:52 <puregreen> because indexing begins from 0
01:35:31 <puregreen> and if you change it to “evalListNth 0”, it prints 1
01:35:37 <cco> The element at index 0 is 1. I'd call 1 the first element though, just as I'd call 4 the 4th element
01:36:00 <cco> Not the 0th element or the 3rd element
01:36:13 <ggVGc> wonder if it would be useful to have a class only for mutable variables, rather than all of IO
01:36:36 <puregreen> well, yeah, but “evalListAtIndex” looks clumsier so I kinda understand why they went with “evalListNth”
01:36:50 <puregreen> maybe just “evalListAt” would've been better
01:37:00 <cocreature> or better docs :)
01:37:15 <cco> yeah, I think the docs are seriously confusing at present
01:37:28 <cco> Suppose I'll raise an issue
01:37:41 <U542> ok, someone with extense knowledge on xcode that can help me out please
01:38:06 <ggVGc> U542: you're in #haskell
01:39:43 <LordBrain> i think people should use a stronger hash than sha1 for that purpose, not that sha1 is known to be broken, but better safe than sorry.
01:41:50 <LordBrain> ggVGc, the bindings for GLUT actually make use of a class similar to that idea.. things you can set, it might be imported from a more general package
01:42:20 <LordBrain> they have a nice := operator
01:42:37 <LordBrain> to set iorefs, and mvars, etc
01:42:48 <ggVGc> yeah, that makes sense to me
01:43:03 <ggVGc> like in imperative languages that are immutable by default but where you can choose mutability explicitly
01:43:10 <ggVGc> or well, ML-family
01:43:29 <ggVGc> I personally tink IO think IO is a bit too large in general
01:43:34 <LordBrain> https://hackage.haskell.org/package/StateVar-1.1.0.3/docs/Data-StateVar.html
01:43:43 <ggVGc> it just says "side effects", but some side effects are a lot "worse" than others
01:48:08 <LordBrain> that doesnt tag it with a type constructor which is a specialized monad if that is what you mean... restricted IO, it just provides some convenient interface for various things which are necessarily in a MonadIO monad.
01:48:27 <LordBrain> but i thought it was pleasant to work with
01:50:21 <Tendies> i have foldl (++) list, what am i missing? i want to concat all the elements together
01:50:38 <LordBrain> there is a function concat you know
01:50:55 <LordBrain> :t concat
01:50:57 <lambdabot> Foldable t => t [a] -> [a]
01:51:00 <Tendies> :)
01:51:16 <Tendies> i'm more like a PeonBrain at this fine hour of 4am 
01:51:17 <LordBrain> you need the initial value with yours tho
01:51:21 <LordBrain> :t foldl
01:51:22 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
01:51:47 <LordBrain> so foldl (++) [] list
01:53:36 <ahihi> also, foldl is more inefficient than foldr for this, since (++) traverses the entirety of its left argument
01:54:08 <ggVGc> when in doubt, fold
01:54:13 <ggVGc> is my motto since I got into FP
01:54:29 <LordBrain> works for poker too
01:54:45 <jle`> hm, yeah, i wonder why concat exists, if fold does
01:54:53 <jle`> > concat [[1,2,3],[4,5,6]]
01:54:54 <lambdabot>  [1,2,3,4,5,6]
01:54:57 <jle`> > fold [[1,2,3],[4,5,6]]
01:54:59 <lambdabot>  [1,2,3,4,5,6]
01:55:03 <ggVGc> so many other FP concepts can be reduced to fold
01:55:07 <jle`> must be just a historical accident
01:55:47 <ggVGc> I reckon fmap and fold covers about 80% of any FP logic
01:55:48 <LordBrain> they didnt have fold when i started with haskell
01:56:12 <jle`> when did you start with Haskell?
01:56:15 <shachaf> fold is much newer
01:56:28 <shachaf> Better to ask why concat exists if join does.
01:56:50 <LordBrain> readability would be the answer
01:56:53 <LordBrain> i think
01:57:07 <LordBrain> also, concat is specialized
01:57:12 <jle`> join can't be used in every situation concat can be, now
01:57:13 <LordBrain> so type inference too
01:57:23 <jle`> > concat (Just [1,2,3])
01:57:25 <lambdabot>  [1,2,3]
01:57:29 <jle`> > join (Just [1,2,3])
01:57:31 <lambdabot>      Couldn't match expected type ‘Maybe a’ with actual type ‘[Integer]’
01:57:31 <lambdabot>      In the first argument of ‘Just’, namely ‘[1, 2, 3]’
01:57:31 <lambdabot>      In the first argument of ‘join’, namely ‘(Just [1, 2, 3])’
01:57:56 <Rotaerk> > mconcat [[1,2,3],[4,5,6]]
01:57:57 <lambdabot>  [1,2,3,4,5,6]
01:57:58 <LordBrain> concat's type signature used to be [[a]] -> [a], they only recently generalized it to Foldable.
01:58:20 <LordBrain> and join of course is for any monad
01:58:27 <LordBrain> and always has been
02:02:03 <Tendies> > zip "abc" "def"
02:02:04 <lambdabot>  [('a','d'),('b','e'),('c','f')]
02:08:11 <adarqui> anyone here good with esqueleto? i can't get countRows to work, to save my life
02:10:36 <Tendies> phwew got 5/13 of my assignment done, tomorrow to tackle the baby html parser that gave me so much trouble..
02:10:59 <Gurkenglas> adarqui, paste your code, looking at the hackage doc
02:11:37 <adarqui> cool thanks ! 1sec
02:15:22 <adarqui> Gurkenglas: http://hastebin.com/tanamevufe.hs
02:15:41 <Gurkenglas> Try without the return
02:15:55 <adarqui> so that's the simple test i'm trying to get working.. I have a more complicated one (slightly) with an InnerJoin, which should work if I can get this to work.
02:16:03 <adarqui> u mean without return E.countRows?
02:16:37 <Gurkenglas> I thought "E.countRows" instead of that line, now I see that that below there is an error message, so what i said is probably wrong :P
02:16:47 <adarqui> ya so this is like my 1000th iteration of this so.. i've tried just returning 'board, ie: return board, that works and gives me all of the boards
02:17:02 <adarqui> then ive tried: return E.countRows after that successful query
02:17:06 <adarqui> and i get the errors in my hastebin
02:17:13 <adarqui> ah
02:17:46 <adarqui> no matter what i do, with queries that work & compile, as soon as I try adding countRows, i'm toast
02:19:07 <Gurkenglas> ( https://mail.haskell.org/pipermail/web-devel/2012/002621.html looks related)
02:20:25 <chrisd_> Any tips on how to combine and sort two lists of integers with recursion and without any pre-defined sort functions?
02:20:43 <Gurkenglas> adarqui, try inserting type signatures all over the place to pin down where ghc and you disagree
02:20:47 <cocreature> chrisd_: are the lists already sorted?
02:20:53 <jle`> chrisd_: well, if you do it for one list, can't you do it for the other?
02:20:59 <ggVGc> how do you sort without defining a sort function?
02:21:03 <jle`> just write a function
02:21:05 <chrisd_> two lists are already sorted, yep
02:21:07 <arahael> ggVGc: "pre-defipned".
02:21:21 <arahael> ggVGc: "predefined".  Presumeably he's happy to define it himself.
02:21:24 <jle`> chrisd_: oh, do you mean combine two sorted lists?
02:21:27 <ggVGc> ah yeah, alright
02:21:39 <cocreature> chrisd_: just compare the first elements of each list and take the smaller one until you get to the end of one list
02:21:42 <adarqui> Gurkenglas: ya i've been trying that.. it's def the type checking
02:21:47 <jle`> easiest way would to just write your cases
02:21:52 <jle`> combine [] [] = ?
02:21:52 <adarqui> i think i might be closer, 1sec
02:21:56 <jle`> combine (x:xs) [] = ?
02:22:01 <jle`> combine [] (y:ys) = ?
02:22:04 <jle`> combine (x:xs) (y:ys) = ?
02:22:10 <jle`> your function will pretty much write itself :)
02:22:22 <chrisd_> thanks jle, I will give that a try
02:22:23 <cocreature> you can get down to two cases :)
02:22:26 <cocreature> eh three
02:25:02 <adarqui> im trying to get it to type check by using print.. hehe. liftIO $ print ((head n) :: E.value Int) results in Couldn't match expected type ‘MinLen (Succ nat0) mono0’ with [r0]
02:25:09 <adarqui> but at least that's the only error
02:33:10 <Gurkenglas> adarqui, try "return (E.countRows :: SqlExpr (Value Int))"
02:39:11 <adarqui> thanks, 1sec tho i've been hacking some stuff up based on this: https://mail.haskell.org/pipermail/web-devel/2012/002621.html
02:39:17 <adarqui> getting close..... i think
02:42:29 <tcs> does anyone know if there's a Regex library that uses Text instead of String?
02:43:31 <puregreen> tcs: text-icu
02:44:13 <adarqui> Gurkenglas: http://hastebin.com/gujezogilu.hs
02:44:15 <puregreen> https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU-Regex.html
02:44:21 <adarqui> that works!
02:44:24 <adarqui> thanks for the help
02:44:43 <adarqui> i can probably simplify those a bit.. but it's almost 6 am and my brain is about to implode
02:44:57 <tcs> puregreen: I did find that earlier, but it doesn't have a replace function only a find
02:45:25 <deepfire> when the GHC runtime exits with something like progname: FailedConnectionException "hostname" port -- how do I find which package defines the exception?
02:46:05 <arahael> deepfire: You read all the code.  Alternatively, you can add profiling data and run it with profiling.
02:46:27 <adarqui> i dno how to get the value out tho.. when i try to access it via head, i get: Couldn't match expected type ‘MinLen (Succ nat0) mono0’ .... but the type sigs say i should have a [E.Value Int64]
02:46:30 <dramforever> Better yet: search for it https://www.stackage.org/lts-5.10/hoogle?q=FailedConnectionException
02:46:33 <arahael> deepfire: There are a few cryptic arguments to doing so - pretty easy to find for the usual case.
02:46:35 <dramforever> deepfire: ^
02:46:40 <arahael> dramforever: Or that. :)
02:46:50 <adarqui> Gurkenglas: any idea on that? just wondering
02:47:04 <deepfire> hmm, this is surprisingly non-developer-friendly..
02:47:30 <Gurkenglas> adarqui, I meant even more type signatures: Start putting stuff in brackets and annotating it with types
02:47:42 <adarqui> ya i got it to work
02:47:57 <deepfire> thanks, folks!
02:48:22 <arahael> deepfire: I find that the haskell community is /different/, the assumptions and methodologies are different.  Not neccessarily "non-developer friendly", but I do find it is harder to get up-to-speed in it - the struggle is with the tools and conventions we are used to - rather than the language.
02:48:23 <adarqui> it compiles, and liftIO $ print n, prints out: [Value 443] for example
02:48:36 <dramforever> deepfire: FSVO "dev friendly"
02:48:36 <puregreen> tcs: well, there's a separate library that provides replacement on top of that
02:48:38 <puregreen> http://hackage.haskell.org/package/text-regex-replace-0.1.1.1/docs/Data-Text-ICU-Replace.html
02:48:52 <jle`> dramforever: you can use hoogle or some sort of search
02:49:12 <arahael> deepfire: I'm sure many people here will suggest that it's very, very haskell-dev-friendly.  But it's rather antagonistic to python-devs. :/
02:49:20 <dramforever> jle`: perhaps you meant deepfire?
02:49:23 <tcs> puregreen: that'll do - thanks :)
02:49:27 <deepfire> dramforever, araphael, I would have expected the ability to catch the thing -- without knowing its type, and extract information from the caught object
02:49:38 <arahael> deepfire: What caught object?
02:49:39 <tcs> didn't manage to find that one in my search
02:49:46 <deepfire> arahael: exception, naturally
02:49:57 <dramforever> :t Control.Exception.catch
02:49:58 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
02:50:02 <arahael> deepfire: This information, would be non-existant stack traces, I except?
02:50:04 <jle`> oops, yes
02:50:14 <dramforever> deepfire: oh did you mean stack traces?
02:50:26 <arahael> *expect
02:50:31 <deepfire> dramforever: no, I just need the fully-qualified name of the exception
02:50:53 <arahael> deepfire: I don't think there's such a thing - open world assumption (I think?)
02:51:07 <arahael> deepfire: Ie, the name is already fully-qualified.
02:51:08 <deepfire> I need to locate the code which threw the exception -- by attributing the exception to a module where it is defined
02:51:30 <deepfire> erm, wrong
02:51:38 <arahael> deepfire: what if it's defined in multiple modules?  (I struggled with the same issue a few days ago)
02:51:47 <deepfire> I need to know the type of the exception, so I can catch it
02:51:57 <dramforever> deepfire: all the exceptions are required to be of the Typeable typeclass
02:52:01 <dramforever> :t typeRep#
02:52:01 <lambdabot>     Not in scope: ‘typeRep#’
02:52:02 <lambdabot>     Perhaps you meant ‘typeRep’ (imported from Data.Typeable)
02:52:04 <dramforever> :t typeRep
02:52:05 <lambdabot> forall (k :: BOX) (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
02:52:25 <deepfire> yay ghc8 : -)
02:52:25 <dramforever> um...Just read that as typeRep :: proxy a -> TypeRep
02:52:39 <arahael> deepfire: You could also use ghci and set a trap.
02:52:53 <arahael> deepfire: But it still won't normally give you the original location where it "came from".
02:52:54 <dramforever> Here you go https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Typeable-Internal.html#t:TypeRep
02:53:11 <dramforever> Which contains TypeCon, which contains what you want. See https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Typeable-Internal.html#t:TyCon
02:53:18 <deepfire> arahael: no need for the original location -- I just want to know its type
02:53:26 <deepfire> dramforever: thank you!
02:53:29 <arahael> deepfire: ghci, then.
02:54:01 <dramforever> (sort of funny but reasonable that this detail is not displayed by default)
02:54:09 <deepfire> I wish the runtime printed the FQEN upon exiting, actually
02:54:34 <arahael> dramforever: My pet peave, lately, is that of random modules taking the head of an empty list - while using stack as an interpreter. :(  Impossible.
02:54:46 <deepfire> ..since it seems to be pretty god damned important information
02:55:12 <dramforever> > typeRep (Proxy :: Proxy Int)
02:55:14 <lambdabot>  Int
02:55:17 <dramforever> Arrgh
02:55:41 <deepfire> thanks folks!
02:56:52 <arahael> I'm a bit jealous actually - deepfire was far less critical of the toolset than I was when I run into these niggling issues where I'm used to langauge X, but trying it out in haskell.
02:57:40 <arahael> People here must get tired of me.
02:59:21 <deepfire> it's about perception of the cost/benefit tradeoff involved, I guess
02:59:37 <arahael> I think terminology may be different, as well.
02:59:54 <deepfire> Haskell isn't mainstream enough just yet, so rough edges are sort of expected
03:00:30 <arahael> Yes and no.  I think it's more that haskell has a *lot* of edges. :)
03:00:59 <arahael> The ecosystem is fragmented, something that stack seems to be helping with greately.
03:02:30 <arahael> It's quite different to say, Python, C#, and Java, where you have only one way to set up things.
03:07:12 <dramforever> Sad problem, I have to say
03:07:25 <dramforever> "I'm lacking good libs, so I can't write good libs"
03:07:52 <dramforever> and so on for tools, tutorials, etc.
03:08:10 <deepfire> pypm, pip, easyinstall, distutils, distribute, setuptools, distutils2
03:09:08 <arahael> deepfire: I'm a python dude, so I forgot most of those.  I'm pip, these days. :)
03:09:26 <deepfire> (oh, also distlib and bento)
03:09:35 <ggVGc> I have concluded that zippers suck
03:09:40 <ggVGc> as a concept
03:10:09 <telmich_> good day
03:11:00 <telmich_> I'm trying to understand evaluation rules as described on https://www.schoolofhaskell.com/user/mutjida/order-of-evaluation - however when trying the keepRS example locally, undefined seems to be evaluated, even though according to the site it shouldn't
03:11:51 <telmich_> I've pasted the code and error message here: http://lpaste.net/158310
03:12:13 <telmich_> autsch. nevermind. I've just seen that I mixed up L and R
03:12:20 <telmich_> sorry for bothering..
03:17:06 <deepfire> dramforever, I'm trying to use typeRep to extract the representation of the exception, but I can't seem to figure out how
03:17:49 <deepfire> dramforever: seemingly because the type isn't known statically?
03:18:50 <deepfire> dramforever: my attempt revolves around setting up a sufficiently generic catch, and then trying to feed the exception object to typeRep 
03:21:54 <dramforever> deepfire: Ah, good question
03:22:01 <Shou> Is there a way to "steal" instances from another typeclass, e.g. "instance (Eq a, Monoid a) => A a where a >|> b | a == mempty || b == mempty = mempty | otherwise = b" without introducing this restriction on the typeclass definition of A?
03:22:43 <dramforever> foo `catch` (\(SomeException e) -> ...)
03:24:10 <dramforever> Basically, every exceptions is, as you can see, "some exception" (that's how it works). You catch it, pattern match on it, and get the wrapped exception
03:24:40 <dramforever> but you don't get to know what the exception is, just it's Show and Typeable
03:24:57 <deepfire> dramforever: found a solution it seems -- SomeException + typeOf
03:25:06 <dramforever> exactly
03:25:19 <dramforever> :t typeOf -- wait what does *this* do?
03:25:20 <lambdabot> Typeable a => a -> TypeRep
03:25:24 <dramforever> :t typeRep -- wait what does *this* do?
03:25:26 <lambdabot> forall (k :: BOX) (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
03:25:35 <dramforever> Aww
03:25:49 <deepfire> type-level vs. value-level, AIUI
03:26:27 <dramforever> that's indeed interesting
03:55:58 <jle`> > typeRep (Proxy :: Proxy Int)
03:55:59 <lambdabot>  Int
04:01:34 <telmich_> I'm reading http://learnyouahaskell.com/making-our-own-types-and-typeclasses and I wonder, if I can actually have named parameters in Haskell?
04:02:14 <telmich_> It would be rather convienent to have Rectangle a=Float b=Float c=Float d=Float instead of having to depend on positional parameters
04:03:05 <dramforever> telmich_: for functions in general, no, it contradicts how types in Haskell work
04:03:12 <dramforever> for data types, keep reading :P
04:05:34 <telmich> dramforever: thank you - staying curious :-)
04:07:42 * hackagebot bindings-wlc 0.1.0.7 - Bindings against the wlc library  https://hackage.haskell.org/package/bindings-wlc-0.1.0.7 (ashleyis)
04:09:23 <deepfire> arahael, dramforever: this is what I came up with: http://lpaste.net/158311
04:10:24 <deepfire> import Data.Data, Debug.Trace (printf) etc
04:32:49 <deepfire> duh, fixed http://lpaste.net/158311, by unwrapping the SomeException before feeding it to typeRep
04:35:31 <saurabhnanda> I've been trying to set-up spacemacs + stack as a decent IDE for a few days not, but have been hitting some hiccup or the other. Right now I'm grappling with "Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times)." every time I try doing haskell-compile or haskell-process-cabal-build. How do I fix this? I'm starting Emacs fr
04:35:32 <saurabhnanda> om the command-line using 'stack exec'
04:45:38 <\u> noevim .. syntax: https://github.com/sdiehl/haskell-vim-proto/blob/master/vim/syntax/haskell.vim ; indent: https://github.com/itchyny/vim-haskell-indent/blob/master/indent/haskell.vim   completion: necoghc    
04:46:26 <\u> the syntax support is no as good as emacs's but it's easy to hack..
04:46:38 <knupfer> How can I hide the import of type families?
04:46:38 <\u> typo, neovim
04:47:08 <knupfer> I want someSymbolVal but define my one * and + on the type level
04:52:38 <knupfer> anyone?
04:53:06 <Peaker> Is there a more efficient way to implement   f a b = (Map.difference a b, Map.difference b a) ?
05:01:18 <cubuspl42> what's the simplest way to create range [1..n], but without k 
05:01:18 <cubuspl42> ?
05:02:16 <srhb> cubuspl42: [1 .. k-1] ++ [k+1 .. n] ?
05:02:43 <knupfer> [x | x <- [1..n], x /= k]
05:02:56 <knupfer> srhb: thats wrong
05:03:34 <srhb> knupfer: Huh?
05:03:50 <knupfer> [1.. (10-1)] ++ [(10+1)..4]
05:03:57 <knupfer> for example
05:04:03 <srhb> I was assuming that k was in the range.
05:04:04 <knupfer> > [1.. (10-1)] ++ [(10+1)..4]
05:04:06 <lambdabot>  [1,2,3,4,5,6,7,8,9]
05:04:21 <knupfer> this assumption wasn't given
05:04:25 <srhb> If not, I would probably prefer filter (/=k) [1..n]
05:05:03 <knupfer> Yeah, looks better than mine
05:05:04 <srhb> knupfer: O...k...
05:07:43 <knupfer> srhb: Do you know, how I can hide a type family from the module import?
05:10:09 <knupfer> srhb: Even if k is in range, it doesn't hold
05:10:34 <knupfer> for a negative n
05:11:00 <cubuspl42> k is in range in my case :)
05:11:08 <cubuspl42> thanks for all suggestions
05:11:55 <knupfer> you're welcome :)
05:18:06 <icicled> Is there a way to test a monad transformer stack which has IO at the "bottom" without having to provide everything that the stack needs from IO? 
05:18:51 <icicled> i.e. I want to stub the functions that do IO & provide my own values
05:19:05 <dramforever> test?
05:19:05 <icicled> currently I have to provide a test database, or test directory with some files
05:19:13 <dramforever> oh that test :P
05:19:19 <icicled> yea, integration tests
05:21:12 <dramforever> icicled: Perhaps you can have a typeclass (MonadFooApp m) containing all you need
05:22:13 <dramforever> If you are using mtl style (like (MonadReader r m, MonadState s m) => m Int), it's going to be easy
05:22:22 <dramforever> otherwise it might a bit of trouble...
05:22:30 <icicled> yes I'm using mtl style
05:22:40 <icicled> dramforever: could you please point me to an example?
05:22:46 <ggVGc> what is mtl?
05:23:01 <ggVGc> oh, transformers
05:23:04 <dramforever> icicled: nah, just heard it somewhere sorry
05:23:12 <dramforever> @hackage transformers
05:23:12 <lambdabot> http://hackage.haskell.org/package/transformers
05:23:15 <dramforever> @hackage mtl
05:23:15 <lambdabot> http://hackage.haskell.org/package/mtl
05:23:55 <dramforever> icicled: Hmm... I'm not exactly aware of any, sorry :(
05:23:55 <icicled> dramforever: no worries, thanks
05:24:20 <dramforever> (Oh already sent one message on that :P)
05:27:11 <icicled> I had a look at the "prompt" package - it seemed promising but I think its value is limited to abstracting from a single effect (please correct me if I'm wrong)
05:27:18 <icicled> @hackage prompt
05:27:18 <lambdabot> http://hackage.haskell.org/package/prompt
06:06:40 <maerwald> hmm, anyone knows a reliable method to compare _actual_ filepaths (not just the strings) on filesystem level? Even when using realpath(3), it still doesn't know anything about mountpoints (e.g. bind mounts)
06:06:56 <maerwald> and I don't see a library that does that
06:07:38 <mniip> do bound mounts show up as the same devide id in stat(2)?
06:08:16 <maerwald> mniip: yes
06:08:39 <icicled> would comparing filetypes work? if so have a look @ https://hackage.haskell.org/package/filemanip-0.3.6.3/docs/System-FilePath-Find.html
06:09:24 <mniip> maerwald, hmm, /foo/a and /bar/a would show up as the same if bar is a symlink of foo
06:09:30 <mniip> is that a problem
06:10:30 <maerwald> mniip: no, that's expected... the main problem is recursive directory copy operation... if you don't know if the destination is contained within the source, then you will end up with an infinite copy operation
06:10:48 <maerwald> even popular filemanagers don't seem to handle that correctly
06:11:30 <mniip> mmm yeah
06:11:51 <Tuplanolla> To think someone designed that feature on purpose.
06:12:20 <bennofs> maerwald: a dirty hack would be to write a file to the destination directory and check if it appears in the source directory as well
06:12:31 <mniip> maerwald, what if you recorded the inode+devide ids for every output file you create
06:12:57 <mniip> and if an input file has an inode that you recorded, you would know that something is off
06:13:37 <bennofs> you only even need to record one inode per directory I assume, because if you find that inode again, you know that you're somehow in a directory that is linked to some directory in dest
06:14:23 <maerwald> I was hoping to do something like: resolveMountPoints :: FilePath -> IO FilePath
06:14:33 <maerwald> but I'm not sure if that can be reasonably done
06:17:36 <maerwald> or I traverse the destination backwards before the copy operation and examine inode+device-id and if there is _any_ match, then it only can be "destination in source" error, right?
07:22:15 <obadz> whoa base default sort function is beautiful (http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.OldList.html#sortBy)
07:22:25 <obadz> near-linear behavior for 'almost-sorted' lists
07:25:16 <chrisd_> I have a function replicate' n x = [x | _ <- [1..n]], any ideas how I can get it to work with chars as well?
07:25:37 <obadz> chrisd_: why wouldn't it?
07:26:13 <chrisd_> replicate 3 'a' shows "aaa" instead of ['a','a','a']
07:26:21 <Jinxit> those two are the same
07:26:28 <obadz> > "aaa" == ['a','a','a']
07:26:30 <lambdabot>  True
07:26:47 <Jinxit> default haskell strings are just lists of chars
07:27:29 <chrisd_> kk, its asking to output like replicate 3 'a' = ['a', 'a', 'a']. I will just leave as it is
07:27:30 <chrisd_> thanks
08:03:06 * hackagebot dpor 0.1.0.0 - A generic implementation of dynamic partial-order reduction (DPOR) for testing arbitrary models of concurrency.  https://hackage.haskell.org/package/dpor-0.1.0.0 (barrucadu)
08:08:06 * hackagebot dejafu 0.3.0.0 - Overloadable primitives for testable, potentially non-deterministic, concurrency.  https://hackage.haskell.org/package/dejafu-0.3.0.0 (barrucadu)
08:08:08 * hackagebot async-dejafu 0.1.1.0 - Run MonadConc operations asynchronously and wait for their results.  https://hackage.haskell.org/package/async-dejafu-0.1.1.0 (barrucadu)
08:14:54 <lpaste> tailgate revised “checkParse (tailgate)”: “No title” at http://lpaste.net/158290
08:16:00 <tailgate> Hi, I'm writing a monad that takes a parser grammar and examples and checks if they're correct. I'm still trying to suss out the type errors I'm getting in http://lpaste.net/158290 . what am I doing wrong?
08:22:00 <hjulle> tailgate: You are not using the type variable m
08:22:47 <hjulle> So, just removing "Monad m =>" should work.
08:25:14 <tailgate> what should the IO monad (checkparse) be returning?
08:26:34 <hjulle> tailgate: Just remove the type signatures and see what haskell suggets.
08:28:33 <t7> @hoogle [m a] -> m [a]
08:28:36 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:28:36 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
08:28:36 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
08:29:10 <hjulle> tailgate: But I think your checkparse should return "IO ()" as it does now, and quickcheck should return IO () as well.
08:30:15 <hjulle> t7: You know that you can use lambdabot in privmsg? Just type "/query lambdabot"
08:30:31 <t7> 知道
08:31:20 <tailgate> hjulle: thanks, that was the issue, along with return ()
08:36:38 <hjulle> t7: You should only use lambdabot in channel if you want to show us something.
08:36:55 <t7> how long has that been the case
08:37:49 <hjulle> Always. It's a question of manners.
08:38:36 <t7> are you a mod?
08:38:40 <hjulle> nope
08:38:56 <hjulle> It's also a question of common sense.
08:39:35 <puregreen> I've actually never seen people here being chastised for using lambdabot in public *once*
08:39:48 <hjulle> Ok, sorry
08:39:51 <t7> same, i have been idling here for years 
08:40:48 <sm> I don't know about chastising, but yes it is common sense
08:41:15 <sm> why add unnecessary noise to a busy channel unless you have a reason (eg to show what you
08:41:17 <hjulle> t7: Why do it in public if you do not want to show people?
08:41:18 <EvanR> can you guys discuss this in PM so the channel can get back to inactivity
08:41:20 <sm> re doing)
08:42:03 <EvanR> theres no reason this needs to be public
08:45:58 <t7> perhaps newbies might learn something ?
08:46:33 <maerwald> meh, why is: fdWrite :: Fd -> String -> IO ByteCount
08:46:33 <maerwald> yeah... I'm going to write a 4 GB file using the String type O.o ...not.
08:47:15 <EvanR> ByteCount? ... I guess its a wrapper for size_T
08:47:17 <EvanR> size_t
08:47:23 <maerwald> ByteCount is irrelevant
08:47:25 <knupfer> Is there a lib to make operations on typelit strings?
08:47:28 <maerwald> I don't use the result
08:47:45 <EvanR> why are you using the String version of these things?
08:47:54 <EvanR> isn't there one that takes ByteString
08:47:54 <maerwald> erm, because there only is a string version
08:48:01 <maerwald> https://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-IO.html show me
08:48:04 <maerwald> I can't find it
08:48:08 <sm> t7: indeed. It's a judgement call
08:48:27 <EvanR> https://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-IO-ByteString.html
08:48:32 <cocreature> https://hackage.haskell.org/package/unix-bytestring-0.3.7.3/docs/System-Posix-IO-ByteString.html#v:fdWrite
08:48:32 <maerwald> meh, right :D
08:48:41 <cocreature> yeah hoogle \o/ :)
08:49:39 <maerwald> EvanR: lol, the one from System.Posix.IO.ByteString is String too... except for the unix-bytestring package
08:49:39 <EvanR> ..except that module has nothing in it
08:49:51 <EvanR> it reexports all the stuff from other modules
08:50:04 <maerwald> pretty weird
08:50:25 <cocreature> EvanR: the module you linked to doesn’t provide anything operating on bytestring …
08:50:41 <cocreature> wtf
08:50:47 <knupfer> How can I write a typelevel version of reverse? Reverse (Proxy "abc") === Proxy "cba"
08:50:49 <EvanR> except fdWriteBuf
08:51:29 <geekosaur> System.Posix.IO.ByteString only addresses pathnames, not file content. (siiiigh)
08:51:31 <maerwald> EvanR: well, it's Ptr Word8 there
08:51:40 <cocreature> EvanR: that operates on a Ptr not a bytestring
08:51:44 <maerwald> they should be punished for that misleading module name
08:51:57 <EvanR> something is busted here
08:52:04 * maerwald opens rant bug
08:52:31 <cocreature> geekosaur: ah at least it’s not a complete duplicate that makes no sense at all :)
08:52:33 <maerwald> I mean... seriously... if you are already that low level that you mess with file descriptors... are you still using String?
08:53:05 <cocreature> you shouldn’t use string at all
08:53:08 <maerwald> ...
08:53:14 <cocreature> but we will never get rid of it :(
08:54:01 <EvanR> https://hackage.haskell.org/package/unix-2.7.1.0/docs/src/System.Posix.IO.Common.html
08:54:05 <EvanR> nothing about ByteStrings...
08:54:48 <cocreature> knupfer: does it have to work for symbols? they are not lists of chars and I’m not sure if it’s possible to convert them to that
08:54:55 <EvanR> https://github.com/haskell/unix/issues/35
08:55:17 <maerwald> yeah
08:56:25 <EvanR> agreed filepath should be ByteString too
08:56:35 <maerwald> EvanR: meh, trash filepath :P
08:56:45 <maerwald> one of the most unsafe path libraries out there
08:56:47 <maerwald> no... THE most unsafe
08:56:53 <EvanR> randomly choosing locale for encoding of strings is one thing
08:57:01 <EvanR> but for filepaths that seems like a security issue
08:57:13 <EvanR> i meant FilePath
08:57:34 <maerwald> not sure how much sense that makes
08:57:48 <EvanR> also, this is a separate issue from String = [Char]
08:57:58 <EvanR> it would be a problem even if String = Text
08:58:30 <EvanR> well I'm pissed
08:58:32 <maerwald> a good filepath library _parses_ paths before it constructs a path type... the problem could be fixed on that level I'd say
08:58:54 <maerwald> ByteString is a bit odd as a result type
08:59:34 <EvanR> really im concerned about arguments of type FilePath
08:59:50 <EvanR> which = String
08:59:57 <maerwald> can you be more specific?
09:00:16 <maerwald> I mean, does POSIX even say which character set is allowed?
09:00:36 <EvanR> the filesystem has essentially unknown encoding
09:00:51 <EvanR> i have had to deal with utf8 and shift-jis at the same time
09:01:26 <EvanR> according to the OS its just a bunch of bytes
09:01:48 <EvanR> except for /
09:01:51 <geekosaur> yeh, I agitated pretty hard for the ByteString-based path modules to be added to unix, because there'd been a recent spate of crashes and file redirection vulnerabilities based on programs incorrectly assuming that all pathnames were properly normalized UTF8
09:02:05 <Lokathor> EvanR, life itself is a nightmare that no one ever wakes up from :/
09:02:10 <Lokathor> full of unknown encodings
09:03:03 <maerwald> geekosaur: I think the bigger problem is that the most used path modules have practically zero typesafety anyway, since they are just String/Text/ByteString based anyway... which is all the same mess
09:03:11 <maerwald> although I can see the encoding is a problem too
09:03:33 <Athas> Is there a library like https://hackage.haskell.org/package/raw-strings-qq-1.1, but which allows me to include the contents of a file at compile-time?
09:03:37 <maerwald> then you have semi-random behavior on </> combinators and such
09:03:53 <maerwald> no guarantees about relative or absolutes paths and so on
09:04:01 <maerwald> which may break threading (it does in darcs)
09:04:26 <geekosaur> Athas, http://hackage.haskell.org/package/file-embed ?
09:05:09 <Athas> geekosaur: thanks, that looks more or less exactly like what I want.
09:05:20 <EvanR> your issue is higher level, about a nice data type to build paths, but the fact of the matter is that the underlying path object is literally a string of bytes where slash is special and cannot appear except as a separator
09:05:35 <Athas> ...also NUL cannot appear.
09:05:49 <EvanR> oh really
09:06:04 <EvanR> there you go
09:06:25 <Athas> Except maybe on non-Unices; who knows.
09:06:31 <EvanR> doubt it
09:07:11 <EvanR> though osx does this hilarious thing... type '/' and it puts a private use area unicode character that appears as / in finder
09:07:19 <maerwald> EvanR: yeah, I already have my own path type, which is similar to the one from chrisdone
09:07:19 <maerwald> @hoogle path
09:07:19 <lambdabot> Data.Graph path :: Graph -> Vertex -> Vertex -> Bool
09:07:19 <lambdabot> Test.HUnit.Base path :: State -> Path
09:07:19 <lambdabot> package path
09:07:25 <maerwald> @hackage path
09:07:25 <lambdabot> http://hackage.haskell.org/package/path
09:07:40 <maerwald> that's a decent lib, but has some problems too for some use cases
09:07:59 <maerwald> and internally it's FilePath/String too
09:08:04 <Lokathor> ooh ooh!! i wrote a thing like this last night!
09:08:10 <Lokathor> ireniko, lts data.graph
09:08:11 <ireniko> containers-0.5.6.2: https://www.stackage.org/haddock/lts-5.5/containers-0.5.6.2/Data-Graph.html
09:13:10 * hackagebot redis-io 0.7.0 - Yet another redis client.  https://hackage.haskell.org/package/redis-io-0.7.0 (ToralfWittner)
09:16:56 <maerwald> EvanR: is there a summary/thread of the problems with String vs BysteString wrt paths somewhere?
09:17:25 <Athas> Write pure code and you won't have to worry about file paths ever again!
09:18:00 <Lokathor> yeah never touch the disk
09:18:33 <Lokathor> (says the guy who just showed off his cool new bot feature that uses diskIO rather than doing a proper HTTP request because it's easier that way)
09:19:10 <maerwald> Athas: the code is already pure, but the RTS not
09:20:06 <Athas> If my compiler read its input program from stdin, then I could totally ignore the file system.
09:20:13 <Athas> Well, and if it wrote the result on stdout, I guess.
09:24:41 <EvanR> better never touch memory
09:24:56 <ggVGc> personally I try to make sure none of my code ever executes
09:24:57 <ggVGc> to be safe
09:25:19 <Lokathor> the RAM might fail, and cause a curruption
09:25:36 <Athas> Or worse: I might have a bug in my code.
09:25:38 <maerwald> and if you execute your program in space...
09:26:12 <ggVGc> I just created a bug..
09:26:16 <ggVGc> see what happens when I run my code
09:29:14 <Lokathor> you brought it on yourself, by executing the code
09:29:29 <maerwald> yeah, evaluation should be enough for every program
09:30:32 <cocreature> evaluation is fine with me, I’ll just use unsafePerformIO
09:31:10 <Lokathor> you
09:31:11 <Lokathor> devil
09:31:27 <jmcarthur> codevil
09:31:58 <java_pro> hi
09:33:29 <haskell_pro> hey
09:34:50 <geekosaur> [03 16:33] <ggVGc> [16:24:34] personally I try to make sure none of my code ever executes
09:34:56 <geekosaur> type level, anyone? :p
09:35:10 <haskell_pro> you *compile* your code?
09:35:13 <haskell_pro> what a rebel
09:35:14 <maerwald> geekosaur: you mean create a type that ensure the code will never execute?
09:41:35 <maerwald> that would've been a nice april fool: "GHC removes IO support, since IO is generally considered unsafe"
09:42:31 <lpaste> tailgate revised “checkParse (tailgate)”: “No title” at http://lpaste.net/158290
09:42:55 <EvanR> thanks, now we cant use that joke next year
09:43:01 <maerwald> :/
09:43:39 <tailgate> Ok, si I'm getting a type error when I try to use my function with numberExamples = [(String, Integer)] . I'm not sure I understand why this doesn't work with the Either type. Could someone enlighten me?
09:43:48 <tailgate> http://lpaste.net/158290
09:44:54 <tailgate> does it have to be explicitly a Left/Right value?
09:46:51 <EvanR> Integer and Either String Integer are incompatible
09:47:11 <EvanR> to go from Integer to Either String Integer use Right
09:47:24 <miniBill> I'm trying (and failing) at writing a Monad instance for "newtype SeekerT m a = SeekerT { runSeeker :: Handle -> m (IO a) } deriving Functor"
09:47:26 <EvanR> to go from Either String Integer to Integer use case analysis with pattern matching
09:47:57 <miniBill> I managed to write one using a MonadIO m context, but it doesn't sound right
09:48:49 <tailgate> EvanR: thnaks
09:49:28 <miniBill> any clues?
09:57:41 <ertesx> miniBill: that indeed doesn't sound right, but if it satisfies the monad laws, it is right
09:58:07 <ertesx> miniBill: what's the purpose of SeekerT?
09:58:16 <miniBill> ertesx: what I mean is, is there a way to define a monad instance without MonadIO?
09:58:21 <Cale> miniBill: It's certainly not doable without the MonadIO context
09:58:31 <miniBill> ertesx: encapsulating some IO operations on an handle
09:58:33 <ertesx> miniBill: not the way you defined it
09:58:39 <Cale> In general, when n and m are monads, their composite need not be a monad.
09:58:44 * hackagebot fadno-braids 0.0.2 - Braid representations in Haskell  https://hackage.haskell.org/package/fadno-braids-0.0.2 (spopejoy)
09:58:45 <ertesx> miniBill: encapsulating in what way?
09:59:59 <miniBill> Cale: ok...
10:00:01 <ertesx> miniBill: to me it seems that the inner IO is not necessary, because IO comes already with 'm'
10:00:56 <miniBill> ertesx: but I'd still need a MonadIO, right?
10:01:16 <ertesx> miniBill: not without the inner IO
10:01:19 <miniBill> probably what I really want is to just define a monad and not a transformer
10:01:25 <ertesx> then it's essentially just ReaderT Handle
10:01:33 <Cale> I'm suspicious that this will really satisfy the monad laws...
10:01:42 <miniBill> the point is that I have a lot of operations
10:01:57 <miniBill> every one of type Handle -> a -> IO b
10:02:08 <miniBill> and I wanted to write a monad to have some cleaner code
10:02:21 <miniBill> and I succeded, but then I tried to transform it into a transformer
10:02:22 <ertesx> miniBill: to get rid of the Handle that every operation needs?
10:02:25 <miniBill> but it's probably overkill
10:02:35 <miniBill> ertesx: that too
10:03:01 <ertesx> miniBill: what else?  the Handle part is solved by ReaderT Handle
10:03:04 <Cale> Well, there's a -> ReaderT Handle IO b
10:03:18 <Cale> but I'm generally suspicious of this as a real refactoring move
10:03:32 <miniBill> yeah, I'm probably overcomplicating things
10:03:40 <ertesx> most likely, yeah
10:03:53 <Cale> It can be part of a bigger structural change to how you're writing your program
10:03:59 <DotKite> trying to write a list comprehension where the elements are strings, but i keep getting a Syntax error.  Here is the code with error in a comment block http://pastebin.com/rKYXNgCB
10:04:08 <ertesx> if you want to get rid of explicit arguments, in many cases you can just define a little helper combinator
10:04:43 <Cale> But it needs to come with more than just the ReaderT -- if you have a really good sense of which operations are needed and can build a monad with just those operations (so arbitrary IO isn't frequently required), then there might be something to it.
10:04:46 <miniBill> yeah, I'm definatively overcomplicating things
10:04:58 <miniBill> IO is required at every step
10:05:07 <miniBill> I'm reading things from a file
10:05:13 <miniBill> and the file is too big for memory
10:05:31 <miniBill> and I need to seek frequently
10:05:45 <ertesx> miniBill: you don't need to use ReaderT all over the place…  you can use it locally and just apply runReaderT promptly
10:05:53 <ertesx> and for the composition part there are (>>=) and (>=>)
10:06:15 <ertesx> runReaderT (myOp1 >=> myOp2 >=> myOp3)
10:06:28 <ertesx> uhm
10:06:31 <ertesx> not quite
10:06:37 <miniBill> ertesx: >=> could help...
10:06:51 <miniBill> but well, anyway, I just need to finish this code
10:06:55 <miniBill> I can make it cleaner later
10:06:59 <miniBill> I need the data asap
10:07:08 <miniBill> ertesx, Cale, thank you very much for your time
10:07:43 <ertesx> DotKite: the error doesn't seem to be within the portion of the code you pasted
10:08:33 <Cale> So, the things to consider are whether the liftIO's, or the function parameters are better, and whether you're ever going to want to use things like catch (for exceptions) or forkIO, which will generally become a bit more awkward to use. The first monad transformer over IO is an expensive move. If you have one already, then sticking a ReaderT on isn't as big a deal, because you've already given up lots of conveniences.
10:10:18 <DotKite> ertesx:  is there a problem if I pass a list of strings with single quotes?
10:10:46 <ertesx> DotKite: single quotes as in ['abc', 'def']?
10:11:00 <Cale> DotKite: Single quotes denote characters, not strings.
10:11:10 <Cale> 'a' :: Char, "a" :: String
10:11:19 <miniBill> Cale: no catch and no fork
10:11:19 <Cale> 'ab' is a syntax error
10:11:29 <DotKite> I see
10:11:48 <miniBill> Cale: but thank you
10:11:50 <ertesx> DotKite: single quotes are allowed in identifiers though, as long as they're not at the beginning: my'identifier'
10:12:13 <Lokathor> you'll see that a lot at the end, foldl and foldl' for example
10:12:17 <ertesx> but that's just a name and has no relation to characters or strings
10:12:40 <ertesx> DotKite: but the error doesn't seem related to any of that
10:13:26 <DotKite> ertesx I get that error when i pass a list with elements that are surrounded by single quotes
10:13:46 <DotKite> I just tested it with double and it worked
10:14:24 <DotKite> tested as in called it in ghci
10:14:24 <ryantrinkle1> i'm unsure how to reason about whether this function is sound: https://hackage.haskell.org/package/prim-uniq-0.1.0.1/docs/Data-Unique-Tag.html#v:newTag
10:15:19 <Athas> Is there a way to get mainland-c-quote to read from a file?
10:15:21 <ryantrinkle1> the key is that the GOrdering/GEq instances for that type allow you to recover a witness that if two tags are equal, their type parameters a are equal
10:16:01 <ryantrinkle1> i *think* that this should be sound if and only if newTag cannot be applied at a polymorphic type for `a`
10:16:54 <ryantrinkle1> would the ImpredicativeTypes extension allow me to apply it polymorphically?
10:17:22 <ryantrinkle1> is there a way to know whether that stuff is possible in general?
10:23:37 <ryantrinkle1> i guess a related question: in general, given a value of type T (forall a. a), is it possible to produce a T () (or some other concrete instantiation of a)
10:23:45 * hackagebot overloaded-records 0.4.1.0 - Overloaded Records based on current GHC proposal.  https://hackage.haskell.org/package/overloaded-records-0.4.1.0 (PeterTrsko)
10:25:18 <Cale> ryantrinkle1: Well, if T is a functor it should be.
10:25:22 <johnw> ryantrinkle1: if you actually have a value of type T (forall a. a), then I think that means it's only using forall a. a as a phantom type, so you should be able to "coerce" it into a T ()
10:25:56 <ryantrinkle1> Cale: yes, that makes sense, but in this case it's not a Functor
10:25:57 <ryantrinkle1> specifically: https://hackage.haskell.org/package/prim-uniq-0.1.0.1/docs/Data-Unique-Tag.html#v:newTag
10:26:51 <johnw> oh, no, the roles are wrong
10:26:53 <ryantrinkle1> johnw: in this usage, it's being "used" by the datastructure as a phantom type; however, the other instances, specifically GEq and friends, allow us to recover (a ~ b) given T a and T b, if we know that they're the same value
10:26:59 <johnw> this does work: foo :: Maybe (forall a. a) -> Maybe (); foo _ = Nothing
10:27:03 <johnw> with ImpredicativeTypes
10:27:34 <ryantrinkle1> johnw: yeah, that makes sense
10:27:43 <ryantrinkle1> i think you're right that this thing needs a role annotation
10:28:01 <johnw> you'll see the error if you try foo = coerce on that Maybe example
10:28:08 <johnw> (importing GHC.Prim)
10:28:45 <ryantrinkle1> ah, yes
10:28:54 <ryantrinkle1> ok, so this seems to be all down to type roles
10:29:07 <ryantrinkle1> i've found a system like this to be very useful in a number of situations
10:29:26 <ryantrinkle1> however, i wanted to use an off-the-shelf library if possible
10:31:27 <ryantrinkle1> do you guys (or anyone else) know of another way of recording, and then later recovering, type equality?
10:31:31 <ryantrinkle1> without using Typeable
10:32:33 <johnw> can you reify the witness?
10:32:46 <averagehat>  /msg NickServ identify pigger
10:32:59 <Cale> data EqT a b where Refl :: EqT a a
10:33:04 <Jinxit> whoops :)
10:33:17 <ryantrinkle1> johnw: i'm not sure - probably not in general?
10:33:21 <johnw> Cale: in Haskell is that enough to reflect the equality back out?
10:33:40 <ryantrinkle1> so, the use case here is something like this:
10:33:50 <Cale> johnw: I think so? If you match on Refl, it should give you the right type equality
10:33:52 <ryantrinkle1> collect up a bunch of actions, say IO a for different `a`s
10:34:02 <ryantrinkle1> put them all in a DMap
10:34:12 <ryantrinkle1> e.g.: DMap (Tag s) IO
10:34:14 <johnw> Cale: I guess GADTs are smart enough to infer the type equality from the constructor indices... or I hope
10:34:29 <ryantrinkle1> sequence the DMap, so you now have DMap (Tag s) Identity
10:34:41 <ryantrinkle1> then distribute the results
10:34:59 <ryantrinkle1> the parts of the code receiving the results have copies of their respective Tags
10:35:08 <ryantrinkle1> so they can both retrieve and unify the types of the results
10:35:40 <ryantrinkle1> also, Cale, johnw: the main condition that this library requires is some sort of "linearity" in the monad - e.g., if you're using StateT to allocate your unique variables, you'd better be sure it's not gonna backtrack on the state or something like that
10:35:53 <Cale> foo :: (Eq a) => EqT a b -> a -> b -> Bool
10:35:53 <Cale> foo Refl x y = x == y
10:35:55 <Cale> that works
10:35:56 <Grisha> hi, I’ve got a really rookie question: I’ve got sq x = x*x; s = sq; and somehow the type of s has been automatically inferred as Integer -> Integer which is not the type of sq. What gives?
10:35:57 <ryantrinkle1> perhaps that should be its own typeclass
10:35:58 <ryantrinkle1> ?
10:36:11 <Cale> (but yeah, let me think about the real problem :)
10:36:17 <johnw> Cale: nice
10:36:29 <ontop> I hate ST. I hate it so much. Good god I hate it. Can someone help me? :( http://lpaste.net/3720931250303664128
10:36:50 <ontop> What I'm trying to do -should- be obvious from that code.
10:37:04 <Cale> ontop: It looks like you wanted to write
10:37:16 <ontop> Hm. Then that's definitely wrong.
10:37:32 <ontop> I essentially want to convert the mut array into a [[Int]]
10:37:33 <Cale> forM [0..cols] $ \c -> forM [0..rows] $ \r -> readArray arr (r,c)
10:37:34 <scshunt> can someone give me the definition of bind in terms of join again? ty
10:37:41 <ontop> Wow.
10:37:42 <ontop> :|
10:38:03 <Cale> ontop: You're forming a list of lists of ST actions
10:38:04 <ryantrinkle1> ontop: the issue is just that a list of ST actions isn't the same as an ST action that does multiple things
10:38:17 <ontop> Right.
10:38:20 <ontop> I knew I was doing that
10:38:22 <ontop> Because I saw the error
10:38:27 <ontop> [[m0 Int]]
10:38:32 <Cale> ontop: and then you want to glue all those together into a single ST action which does all the things, and collects up a list of lists
10:38:32 <ryantrinkle1> yep :)
10:38:32 <ontop> But I couldn't figure out how to "evaluate" it.
10:38:43 <ryantrinkle1> you *could* use the function "sequence" to evaluate it
10:38:47 <ryantrinkle1> but cale's solution is better
10:38:50 <Cale> ontop: So what you could do is to  sequence . map sequence  your list of lists
10:38:54 <ontop> Aha.
10:39:04 <Cale> @src sequence
10:39:04 <lambdabot> sequence []     = return []
10:39:04 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:39:04 <lambdabot> --OR
10:39:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:39:15 <ontop> I've used sequence before
10:39:23 <ontop> But only to kill a list of Maybe.
10:39:29 <ontop> Into a Nothing or a Just [x] I think
10:39:34 <Cale> yeah
10:39:41 <ryantrinkle1> yep, it's very general :)
10:40:06 <Cale> In general, it produces an action which will run each of the actions in the list in turn, and produces a list of the results.
10:40:25 <ontop> Neat.
10:40:33 <ontop> Thanks so much. I've been struggling. ST and me really don't get along.
10:40:37 <ontop> I don't understand it at all :(
10:40:46 <adamCS> scshunt: bind x f = join $ fmap f x
10:40:47 <Cale> Have you used IO very much?
10:40:48 <ontop> Everytime I encounter mutable arrays in Haskell. I want to go screaming back to Go.
10:40:51 <ryantrinkle1> ok, so i'm thinking maybe it would be helpful to describe a "linear monad" as one in which bind only applies its second argument at most (or maybe exactly?) once
10:40:53 <ontop> Yes. IO and me are friends now.
10:40:58 <ontop> I like IO.
10:41:11 <Cale> Maybe just try using IO actions to start with
10:41:22 <ontop> I think I mostly get them.
10:41:28 <ontop> So
10:41:33 <ontop> You're saying that ST is just like an IO thing.
10:41:36 <ryantrinkle1> i believe that that condition, combined with an ST-like phantom type scoping, is enough to say that StateT is safe for use with this Tag concept
10:41:40 <adamCS> scshunt: or, I guess, x >>=f = join $ fmap f x
10:41:54 <ontop> And I should keep them in my brain similarly?
10:42:03 <Cale> yeah, ST s is slightly trickier than IO in that if you want to be able to runST (and you probably do), that 's' type has to stay polymorphic
10:42:24 <Cale> So when I heard that you hate ST, I immediately figured it would be some problem involving that -- those can be trickier.
10:42:35 <ontop> Yeah.
10:42:38 <ontop> I even screwed myself up
10:42:42 <ontop> Where Haskell said I lost my s
10:42:45 <ontop> And now I had s0
10:42:49 <ontop> I think that was a bad time in my life. :(
10:43:13 <adamCS> scshunt: x::m a and f::a -> m b so fmap f x::m (m b) and then you join that to, well, join the contexts.
10:43:17 <Cale> yeah, that usually means that you're trying to use an STRef in what is possibly the wrong ST computation -- it needs to be used inside the same ST action that created it.
10:44:03 <ontop> Yeah. Because it's a single "state thread" or something correct?
10:44:10 <ontop> That way it ensures purity.
10:44:16 <ontop> Because you're locked to that thread.
10:44:40 <Cale> yeah (though it doesn't really have anything whatsoever to do with concurrency)
10:45:24 <ontop> Right.
10:45:38 <johnw> you can look at it as though every "runST" allocates a unique moniker with which it executes a forall s. ST s action, such that variables used within the action must have been created within the same action.  If a variable "escapes", it can never be used in the context of another runST.
10:46:07 <johnw> so even though the *actions* are generic, the values created by them are not, and are tied to a particular runST invocation
10:46:11 <ontop> Can anyone explain forall s. ST s - I see this little definition sort of everywhere.
10:46:23 <ontop> johnw: Yeah. that makes sense thank you :)
10:46:25 <Cale> Yeah, you'll see...
10:46:27 <Cale> :t runST
10:46:27 <johnw> it just means that ST refers to a type you can never figure out yourself
10:46:28 <lambdabot> (forall s. ST s a) -> a
10:46:44 <Cale> This means that runST gets to pick which type 's' is, you don't.
10:46:45 <ontop> :t forall
10:46:46 <lambdabot>     Not in scope: ‘forall’
10:46:46 <lambdabot>     Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
10:46:53 <ontop> Did I mean that?
10:46:59 <ontop> Cale: Right.
10:47:37 <Cale> ontop: It might be worth pointing out that all type signatures in Haskell implicitly have forall at the start, capturing all the variables which aren't otherwise bound, e.g.
10:47:49 <Cale> map :: forall a. forall b. (a -> b) -> [a] -> [b]
10:48:17 * Lokathor grumbles "wish purescript would let you do that" to himself
10:48:29 <johnw> the key difference here is that in runST, the forall s is at a higher rank: it occurs in the type of a function passed to runST
10:48:31 <Cale> i.e. for all types a, and all types b, map is a function which can take a function a -> b, and produce a function [a] -> [b]
10:49:06 <Cale> Right, so in the type of runST, the forall s is inside the parens, which means that runST is demanding that you give it something polymorphic
10:49:19 <Cale> You don't get to pick which type s is, runST does.
10:49:40 <ontop> Oh.
10:49:44 <ontop> That's totally weird.
10:49:48 <johnw> yeah, it's kind of cute
10:49:50 <ontop> Seeing map defined like that
10:49:52 <ontop> Is like: Wut
10:50:05 <Lokathor> so is 'id' not really polymorphic because the 'a' has alreayd been picked for it by the time 'id' is called?
10:50:19 <johnw> id is rank-1 polymorphic, so the caller determines what 'a' will be
10:50:47 <Lokathor> and rank-2 is that the calle determines it
10:50:57 <johnw> polymorphism at rank-1 means: I can handle any type you give me.  polymorphism at rank-2 means: you need to give me something that handles any type I give it.
10:51:14 <johnw> etc. for rank-N
10:51:16 <Lokathor> i assume there's some bizarre rank-3 case?
10:51:26 <johnw> there's rank-as-high-as-you-want
10:51:31 <Lokathor> i figured as much
10:52:14 <adamCS> johnw:  actually, can you explain rank 3 in a sentence as clear as rank 1 and 2?  That was super helpful...
10:52:39 <johnw> polymorphism at rank-3 means: you need to give me something, to which I need to pass something that will accept any type your something gives it. :)
10:53:01 <adamCS> johnw: Ouch.  But thanks!
10:53:10 <Lokathor> i guess it just bounces back and forth like that
10:53:12 <johnw> yep
10:53:52 <johnw> higher-order polymorphism, to put it another way
10:53:53 * hackagebot scanner 0.2 - Fast non-backtracking incremental combinator parsing for bytestrings  https://hackage.haskell.org/package/scanner-0.2 (YurasShumovich)
10:54:08 <ontop> I started learning Rust recently
10:54:09 <ontop> Holy crap
10:54:13 <ontop> Those guys stole a lot of Haskell.
10:54:17 <Grisha> johnw: is “you need to give me something that handles any type I” equivalent to “i can handle anything that handles anything type I”?
10:54:30 <maerwald> ontop: well, the core of Rust is the borrow checker, haskell has nothing like that
10:55:03 <ontop> maerwald: Don't get me wrong. It's got it's own innovations. But they "borrowed" a lot from Haskell in terms of functionality, naming, sometimes even syntax.
10:55:07 <johnw> Grisha: not sure I follow
10:55:17 <maerwald> ontop: but that's not the core 
10:55:39 <Grisha> johnw: I’m just trying to convert your “you give me something of X” into “I candle handle everything of X”
10:55:51 <Lokathor> maerwald, the borrow checker is the core of what makes rust new, but langauges are much more than just the one new feature.
10:55:57 <ontop> ^
10:55:59 <Grisha> johnw: in your description of rank-2 and rank-3
10:56:08 <maerwald> Lokathor: that's what I was basically saying
10:56:19 <ontop> I mean.. the core of rust is the entire language no? And half of it looks like Haskell.
10:56:31 <maerwald> barely
10:56:33 <ontop> That's all I was remarking.
10:56:34 <cocreature> languages steal from each other, that’s a good thing
10:56:38 <ontop> Oh definitely.
10:56:45 <ontop> It was just a casual remark nothing more. ^_^
10:56:46 <EvanR> existing languages keep stealing from from haskell so makes sense new ones would
10:57:02 <ontop> I want Go to have Haskell generics :(
10:57:10 <maerwald> Go is useless, stick to Rust
10:57:15 <Lokathor> I want go to have sane slicing :/
10:57:15 <ontop> Rofl.
10:57:21 <EvanR> go needs exceptions
10:57:24 <maerwald> I am serious
10:57:28 <cocreature> go needs to go
10:57:28 <Lokathor> go needs a lot of things :P
10:57:32 <Lokathor> ^
10:57:36 <EvanR> go needs to go
10:57:43 <ontop> That's a powerful statement. And as a full time Go developer I disagree wholeheartedly :)
10:57:52 <maerwald> Go is like "let's improve C one step... okay, maybe two"... erm, what about the rest of the 2000 steps?
10:58:07 <Clint> don't forget the steps backward
10:58:10 <maerwald> heh
10:58:23 <cocreature> but it’s from google so it has to be good
10:58:41 <agocorona> google is a relatively low tech company. they favour speed over anything else
10:59:02 <ontop> I'm like speechless at the amount of hate for the language here.
10:59:19 <johnw> this isn't the place for language debates anyway
10:59:22 <ontop> True.
10:59:23 <ontop> Let's stop :)
10:59:36 <cocreature> there is always #haskell-blah :)
10:59:45 <Cale> A type is rank 0 if it doesn't involve forall anywhere. Rank (n+1) consists of all the types at rank n, together with r -> s whenever r is rank n and s is rank n+1, as well as forall a. r a, where r a would have rank n+1 if we treat a as having rank 0.
11:02:56 <Cale> cocreature: Unless you don't have TLS enabled. We should make a new channel.
11:05:50 <hjulle> Cale: ##haskell-blah-notls?
11:06:22 <johnw> #haskell-cale
11:06:39 <johnw> it would easily be the most helpful channel on freenode
11:06:57 <Cale> lol
11:07:05 <Tuplanolla> I can't find quot, rem, div and mod for rational or floating-point numbers. Where are they?
11:07:09 <hpc> #haskell-mitm
11:07:16 <johnw> oh no, did someone lose them again
11:07:55 <Tuplanolla> I'm not very good at function keeping.
11:08:19 <johnw> you think that "functional languages" would mean they always work
11:08:35 <Cale> Apparently #haskell-offtopic is owned by freenode staff
11:08:43 <Zemyla> Is there such a thing as free arrows?
11:08:50 <johnw> Cale: that should be owned by us; I have a #haskell cloak
11:08:59 <johnw> Cale: you want me to make you the new owner?
11:09:18 <Cale> Uh, sure
11:09:26 <johnw> k, figuring it out now
11:11:50 <Cale> Tuplanolla: they don't exist
11:11:57 <EvanR> Cale: i was going to say, whats wrong with #nossl ;)
11:11:59 <Lokathor> #haskell-comparative, for all your inter-language discussions
11:12:09 <EvanR> its already got the purpose in the name
11:12:13 <maerwald> too many channels
11:12:41 <Tuplanolla> What? Why? Surely there has to be a package for them at least.
11:13:01 <Cale> Tuplanolla: What would they do? There's no remainder when you divide rational numbers.
11:13:11 <ertesx> Cale: there is
11:13:23 <Cale> The rational numbers are a field
11:13:35 <ertesx> and Data.Fixed.divMod' is useful for some non-integral types
11:13:38 <ertesx> :t divMod'
11:13:39 <lambdabot> (Integral b, Real a) => a -> a -> (b, a)
11:13:59 <ertesx> > divMod' 5.5 2
11:14:01 <lambdabot>  (2,1.5)
11:14:12 <EvanR> theres a weird way in which float modding makes sense... sort of
11:14:14 <ertesx> 5.5 = 2*2 + 1.5
11:14:31 <EvanR> really its about fractional parts and whole parts
11:14:32 <ertesx> think of it as this equation:  x = q*n + r
11:14:41 <Tuplanolla> I used that divMod' for Doubles once and it was slow enough to instantly become the bottleneck of the code.
11:14:44 <ertesx> how many times does n fit into x, and what's the remainder?
11:15:02 <Cale> If q is allowed to be rational, then that has infinitely many solutions
11:15:03 <EvanR> ertesx: it fits in a fractional number of times ;)
11:15:23 <ertesx> Cale: q is always integral
11:15:36 <ertesx> q ∈ ℤ
11:15:39 <Cale> :t div
11:15:40 <lambdabot> Integral a => a -> a -> a
11:15:51 <EvanR> this question devolves into a question about the whole number part of the real
11:16:06 <Cale> yeah
11:16:36 <quxbam> how can i implement permute with recursion and concat?
11:16:44 <ertesx> it's well defined and useful
11:16:49 <enthropy> is there a package out there like containers Map that specializes to IntMap if you have Map Int?
11:17:06 <Cale> ertesx: For sure, it's just not the same operation as div/mod
11:17:17 <ertesx> Cale: actually it is
11:17:25 <Tuplanolla> Do we have such a nonDivMod then?
11:17:27 <ertesx> not to the machine of course, but mathematically it is
11:18:09 <Tuplanolla> It'd be really useful for things like physics in a lattice.
11:18:14 <ertesx> Cale: divMod' should actually give the same answers as divMod for integral types, just maybe slower =)
11:18:40 <ertesx> > divMod' 5 2 :: (Integer, Integer)
11:18:42 <lambdabot>  (2,1)
11:18:44 <enthropy> data family Map' k v; data instance Map' Int v = Map'Int (IntMap v); data instance Map' k v = Map'_default (Data.Map.Map k v) ... but data families don't allow you do have overlap
11:19:04 <EvanR> thats because the fractional part cant affect the answer (its just added to the remainder as extra junk)
11:19:21 <Cale> enthropy: Also note that you won't be able to coerce...
11:19:45 <Tuplanolla> > quotRem' (-5) 2 :: (Int, Int)
11:19:46 <lambdabot>      Not in scope: ‘quotRem'’
11:19:46 <lambdabot>      Perhaps you meant ‘quotRem’ (imported from Prelude)
11:20:02 <ertesx> Tuplanolla: to make this efficient you probably need to be monomorphic (i.e. Double), and if that doesn't work, you can often make special-case functions that are faster
11:20:05 <enthropy> Cale: you're looking at my use of data instance vs. newtype instance?
11:20:22 <ertesx> Tuplanolla: one thing you can always do is to scale all the numbers involved and use integral arithmetic
11:20:32 <Cale> enthropy: I'm speaking of your idea to specialise to IntSet
11:20:46 <ertesx> Tuplanolla: x = q*n + r → k*x = q*(k*n) + k*r
11:21:18 <ontop> Can I mix IO and ST? And is it a good idea? lol.
11:21:28 <enthropy> Cale: newtype instance Map' Int () = Map'IS IntSet ?
11:21:30 <Cale> ontop: Well, not really.
11:21:43 <ertesx> ontop: unsafely yes; no
11:21:45 <ontop> I didn't want to. It's just making it hard to navigate the world if I don't.
11:22:07 * enthropy thinks this was the intended purpose for data families, but they seem to fall short
11:23:36 <EvanR> ontop: just use IO?
11:23:50 <ontop> EvanR: I found a way aroudn it. I'll keep them separate :)
11:23:55 <ontop> Wait, also what do you mean
11:24:02 <ontop> I'm using ST already.
11:24:04 <EvanR> you can use mutable variables in IO
11:24:13 <ontop> Really??
11:24:16 <ontop> O_________o
11:24:19 <EvanR> ..... yes?
11:24:26 <ertesx> Tuplanolla: the scaling solution is probably not that great, unless you have a factor that will always work:  you would need the least common multiple of all the denominators, and that's going to be even worse than divMod'
11:24:27 <ontop> So like... Mut Array?
11:24:31 <ontop> You can just use it inside IO?
11:24:32 <EvanR> yes
11:24:37 <ontop> How the heck does that work
11:24:39 <ontop> With the types?
11:24:46 <ontop> All the writeArray readArray etc
11:24:49 <ontop> All return ST actions.
11:24:52 <EvanR> IO is a dumping group for anything we dont have a way to do with the type system
11:24:58 <EvanR> dumping ground*
11:25:30 <EvanR> ontop: https://hackage.haskell.org/package/vector-0.11.0.0/candidate/docs/Data-Vector-Mutable.html
11:25:45 <EvanR> kind of hard to see how to use it from the haddocks, but its easy
11:25:47 <ertesx> Tuplanolla: for example if all your numbers use 16 binary digits of precision, you can just scale by 2^16, which is fast, but potentially throws away some fractional information
11:25:51 <Tuplanolla> I currently have it written in terms of properFraction, ertesx.
11:26:17 <ertesx> Tuplanolla: with integral divMod?
11:26:42 <ontop> EvanR: Man, I guess I just don't get how that's possible with IO. I'll come back to this a bit later. Thanks for the info.
11:27:13 <Tuplanolla> No; just (/) from Fractional, ertesx.
11:27:32 <ertesx> ah, yeah
11:28:09 <EvanR> ontop: like... conceptually? or how to get the code to work
11:28:38 <barrucadu> ontop: readArray/writeArray/etc don't just return ST actions, they return MArray actions, where MArray has instances with IO and ST: https://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array-MArray.html
11:28:43 <ontop> Both I guess. I don't get how the types interact. Because in one side I have IO (), and then on the other I have ST s () - and how the functions that play around together work..
11:28:48 <ontop> Oho.
11:28:51 <ontop> That changes things.
11:29:06 <EvanR> you just wouldnt have ST
11:29:10 <ontop> Right.
11:29:13 <ontop> That makes so much sense.
11:29:16 <ontop> Okay.
11:29:18 <ontop> I totally get it now thanks :D
11:29:29 <ertesx> ontop: think of them as completely separate things…  ST is useful, when you have side effects that can't be observed from outside
11:29:39 <ontop> Yeah.
11:29:40 <Lokathor> ST is like a cordoned off section of the system, but sometimes you want to do MArray within ST
11:29:48 <Lokathor> usually you can just use the IO form
11:29:54 <ontop> Welp.
11:30:00 <ontop> I've been using the ST form. I don't think it's gained me anything.
11:30:01 <ontop> But
11:30:05 <ontop> Yeah
11:30:06 <ontop> :D
11:30:13 <ertesx> ontop: it gained you independence from IO
11:30:21 <EvanR> ST is for embedding secret mutation inside "pure" code, but embedding it inside of IO doesnt seem to help
11:30:22 <Lokathor> ST is when you want to do mutation but stay monad free at the end of your computation
11:30:23 <ertesx> IO is a catch-all side effects language
11:30:41 <ertesx> ST is a catch-all language for non-observable side effects
11:30:44 <ontop> Right.
11:30:48 <ontop> It's cool :D
11:31:01 <EvanR> really ? I thought ST just gives you a mutable thing
11:31:15 <EvanR> you cant do much else besides mutate things
11:31:17 <ertesx> EvanR: (ST is really just IO in disguise, but psssst)
11:31:54 <EvanR> next we need to invent a monad for unobservable IO
11:32:07 <barrucadu> Like writes to /dev/null
11:32:40 <ertesx> EvanR: we mostly use ST for mutation of memory, but i can think of other uses:  for example threaded parallelism that is guaranteed to be deterministic, similar to Par
11:32:56 <EvanR> you can literally do that with ST?
11:33:02 <EvanR> like with current support
11:33:11 <Tuplanolla> There's already a Monad for nonexistent IO in Acme.Trivial.
11:33:18 <ertesx> technically you can, but unsafely…  you would need to wrap that in safe operations
11:33:28 <EvanR> ..... interesting .....
11:33:38 <ertesx> again, ST is just IO in disguise
11:33:57 * hackagebot pipes-group 1.0.4 - Group streams into substreams  https://hackage.haskell.org/package/pipes-group-1.0.4 (GabrielGonzalez)
11:33:58 <Cale> Personally, I view it as helpful to have a substrate like IO which is relatively unrestricted with regard to effects, so that we have the opportunity to build various other more restricted systems on top of it.
11:37:34 <tippenein> Is there some optparse applicative keyword to show the help message? I'm not seeing it
11:38:57 * hackagebot turtle 1.2.6 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.2.6 (GabrielGonzalez)
11:38:59 * hackagebot pipes-extras 1.0.3 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.3 (GabrielGonzalez)
11:39:07 <tippenein> as in, the help text for the entire parser
11:39:40 <_kit_> https://github.com/pcapriotti/optparse-applicative/commit/bab98fe8ee95635a0befca6ad9365be7d31b0541
11:40:54 <tippenein> thanks _kit_ 
11:41:24 <_kit_> np.. its still kinda ugly. i hit the same issue a few weeks ago.. at least there 'is a way' though.
12:02:47 <saurabhnanda> hey there, anyone using spacemacs + stack here?
12:37:02 <averagehat> saurabhnanda some, yeah, whatsup?
12:38:41 <saurabhnanda> averagehat:  I'm starting spaces with 'stack exec' and running into errors related to GHC_PACKAGE_PATH. Am I doing anything wrong?
12:39:09 <averagehat> you're starting spacemacs through stack?
12:41:28 <saurabhnanda> averagehat: yep
12:41:43 <saurabhnanda> averagehat: so that all the path variables are already set. Isn't that how it's supposed to work
12:41:54 <agocorona> just a question:
12:42:13 <agocorona> what is for you the Holy Grail of programming?
12:42:17 <averagehat> saurbhnanda I just start emacs. And I have ghc-mod in myp path
12:42:49 <averagehat> saurbhnanda you might find more knowledgable folks on the spacemacs gitter.
12:43:22 <enthropy> doesn't ghc's policy of asking for FlexibleContexts when that occurs in the inferred type end up being against the standard? IE. doesn't the standard just prohibit writing those constraints while allowing them to be inferred?
12:43:59 * hackagebot yet-another-logger 0.3.0 - Yet Another Logger  https://hackage.haskell.org/package/yet-another-logger-0.3.0 (larsk)
12:47:51 <ontop> Any function in Haskell (hoogle skills failing me now) that replaces an element in a list?
12:48:09 <ontop> Like basically set element at n and return new list.
12:48:47 <Tuplanolla> More suitable types like Seq have that.
12:49:10 <ontop> Ah is it because list is a linked list
12:49:14 <ontop> And the performance would be dreadful?
12:49:14 <Tuplanolla> Yes.
12:53:55 <candidtim> Hello! If someone could help me with understanding the MonadError class declaration syntax, please? I'm trying to understand MonadError, but I'm stuck in the very beginning. It is declared as `class (Monad m) => MonadError e m | m -> e where`. What is this part after the pipe? Literally `| m -> e`? I never saw this in class declarations and can't grok what this actually does...
12:54:11 <Lokathor> it means
12:54:25 <Lokathor> for any m, there should be a specific e
12:54:26 <ertesx> candidtim: the type e follows from the type m in the instance
12:54:40 <candidtim> a doc which would explain this class declaration syntax would be excellent to have :)
12:54:56 <Lokathor> it's documented... somwhere >_>
12:54:58 <ertesx> candidtim: it's called a functional dependency and requires the FunctionalDependencies extension
12:55:14 <ertesx> you should find plenty of information on the haskellwiki, if you search for that
12:55:43 <candidtim> aha, OK, thanks for the pointer, will look for that!
12:57:03 <candidtim> found it on wiki, thank you!!!
13:02:55 <enthropy> > "ontop" & ix 3 %~ succ
13:02:58 <lambdabot>  "ontpp"
13:03:22 <enthropy> ontop: ^^ is from lens
13:03:28 <ontop> What in the world
13:03:33 <ontop> What just happened?
13:03:43 <ontop> I still haven't even looked at Lens.
13:03:51 <ontop> I remember the xkcd comic
13:04:08 <seishun> there's an xkcd comic about lens?
13:04:30 <ontop> Oh. It was drawn in the same fashion.
13:04:34 <ontop> Guess it wasn't xkcd itself t ho
13:04:34 <ontop> :D
13:04:53 <ontop> Was a learning curve meme
13:05:45 <ontop> seishun: https://pbs.twimg.com/media/B58DjdCCQAASQrI.jpg:large
13:05:48 <mdunn> Looks like Control.Monad.Instances is deprecated in 7.10.3.  What is the replacement?
13:07:27 <xa0> Control.Monad.Trans? :p
13:09:10 <enthropy> mdunn: it used to be for the (->) r monad, but Prelude exports that now
13:09:57 <mdunn> ah, I see.  I saw that prelude was complaining about the import, but I see that it's just built in.  Thanks.
13:26:51 <webstrand> I've been trying to use Text.Numeral to convert an integer into english text, but now I've run into trouble with the types. I've got a type of f :: (Integral α, Text.Numeral.Exp.Scale α) => α -> Maybe Text. How can I find a concrete type, i.e. (5 :: Int) that satisfies α?
13:32:10 <hjulle> ontop: There's some effort to grok the basics of lens, but it's not really that difficult.
13:36:00 <ertesx> ontop: this one is my favourite: https://ro-che.info/ccc/23
13:36:26 <ontop> I wish I could say I got it lol.
13:39:28 <hjulle> webstrand: Try 5 :: Integer.
13:48:07 <hjulle> webstrand: Or just not specifying a type. Ghc should be able to figure it out automatically
13:58:53 <webstrand> hjulle, ghc was having trouble with multiple candidates and was complaining about it, which is why I noticed at all. Thanks for your help
14:04:28 <ertesx> ontop: lens libraries used to be very small, very easy to learn, and while they weren't particularly flexible they got the job done
14:04:32 <ertesx> then came 'lens'
14:05:42 <ontop> Oh.
14:14:03 <icicled> @tell dramforever I found an example of what you mentioned - use typeclasses to create testable transformer stacks with IO - http://stackoverflow.com/a/7374754
14:14:03 <lambdabot> Consider it noted.
14:14:36 <icicled> @tell dramforever it's oddly not the accepted answer on SO which made me skip it the first time around
14:14:36 <lambdabot> Consider it noted.
14:20:17 <cubuspl42> what's the complexity of !!
14:20:21 <cubuspl42> O(n) ?
14:21:21 <puregreen> well, O(i) for xs !! i
14:21:54 <hjulle> webstrand: You can see the instances of the class here: http://hackage.haskell.org/package/numerals-0.4/docs/Text-Numeral-Exp.html#t:Scale. Clicking on the Z will show that it is a type synonym for Integer.
14:22:54 <cubuspl42> puregreen: thank you
14:23:06 <Zemyla> base should make (:~:) and Coercion instances of Foldable.
14:25:49 <Zemyla> They'd be entirely useless instances of Foldable, but they'd be instances.
14:26:10 <hjulle> lol
14:28:11 <cubuspl42> I hope it will happen
14:28:12 <cubuspl42> ;)
14:39:02 * hackagebot crc 0.0.1 - Implements various Cyclic Redundancy Checks (CRC)  https://hackage.haskell.org/package/crc-0.0.1 (MichaelXavier)
14:44:14 * hackagebot crc 0.0.1.1 - Implements various Cyclic Redundancy Checks (CRC)  https://hackage.haskell.org/package/crc-0.0.1.1 (MichaelXavier)
14:45:16 <cubuspl42> I've implemented Gauss–Seidel algorithm in Haskell. It should be O(n^2). It runs 25 s on my PC. It's a bit slow, isn't it?
14:45:34 <cubuspl42> Matrix 1500x1500
14:45:53 <cubuspl42> ghc -O2 Main.hs
14:46:22 <enthropy> maybe you should check at a few other sizes
14:50:19 <Peaker> cubuspl42: slowness in Haskell is often due to use of linked lists when they're inappropriate :)
14:51:10 <cubuspl42> that's what I'm afraid of :/
14:51:54 <Welkin> bitemyapp: hey you
14:52:29 <Welkin> bitemyapp: overwhelmed with controversy at lambdaconf yet?
14:57:53 <cubuspl42> On the other hand... it's about 1500^2 * 200 cycles
14:58:46 <bitemyapp> Welkin: not really
14:59:08 <bitemyapp> Welkin: these are people that hated my coauthor and I and did their best to harass out of the community in the past already
14:59:31 * hackagebot sym 0.12.0 - Permutations, patterns, and statistics  https://hackage.haskell.org/package/sym-0.12.0 (AndersClaesson)
15:00:53 <buttons840> i want to write a ETL system in haskell (as a learning project) and want to be able to run etl tasks written in other languages, what haskell tools should i look at to help with this?
15:01:02 <ggVGc> how would I better write this? https://gist.github.com/dfa2751123b14b48f8ee324ab9dcd5f7
15:02:36 <malade_mental> Hi people of haskell, I'm learning haskell and use Hugs as defined in the book I'm reading (craft of functional programming ed.2), problem is that in hugs "chr" and "ord" functions seems not to exist...
15:02:41 <malade_mental> the version is haskell 98
15:03:37 <geekosaur> the book didn't tell you to 'import Char' (or possibly 'import Data.Char')?
15:03:56 <malade_mental> yes  geekosaur that's what I got 
15:04:11 <malade_mental> but that'S strange nope? ord and chr are quite basic functions
15:04:21 <malade_mental> I thought they'd be built-in
15:05:05 <Welkin> malade_mental: nothing is built into haskell
15:05:11 <Welkin> malade_mental: everything is implemented as libraries
15:05:30 <malade_mental> ok fine
15:05:31 <geekosaur> they're not basic in Haskell. the basic ones are toEnum and fromEnum, which *are* in the Prelude; chr and ord are type speclaizations
15:05:49 <Lokathor> the only thing that's "built in" are things that GHC itself does, which are relatively few
15:06:03 <malade_mental> ok thanks you all for your answers
15:06:19 <Lokathor> you can even choose to not import the Prelude if you want, and then make your own
15:06:42 <EvanR> hugs still works?
15:07:57 <geekosaur> someone has been keeping Hugs buildiung, since there are books and courses which still tell you to use it
15:08:04 <malade_mental> EvanR: it seems that it does
15:08:23 <malade_mental> I know that there is a newer version of haskell and another interpreter
15:08:32 <malade_mental> but I thought it would be enough to use hugs
15:09:42 <geekosaur> hugs has not been actively maintained in over a decade
15:12:26 <malade_mental> so should I use ghci ?
15:14:06 <ertesx> malade_mental: your learning resource may make assumptions that no longer hold with modern haskell, though you'll probably have to get used to them anyway
15:14:35 <ertesx> malade_mental: my suggestion is to use GHC and just ask here, if something doesn't work as you expected from your learning resource
15:14:54 <malade_mental> ertesx: of course , that's  how I learn usually ;)
15:14:55 <Tuplanolla> Sound advice.
15:15:00 <malade_mental> thanks a lot :0
15:18:57 <ertesx> > (ord 'ä', fromEnum 'ä')
15:18:59 <lambdabot>  (228,228)
15:19:38 <ertesx> geekosaur: you just saved me from typing ~50k import lines per year =)
15:20:52 <Sonarpulse> read "Infinity" :: Double
15:21:00 <Sonarpulse> is there no better option?
15:21:08 <ertesx> Sonarpulse: 1/0
15:21:14 <Sonarpulse> well sure
15:21:35 <Sonarpulse> but I'd hope there'd be literals for all doubles
15:22:57 <ertesx> haskell has no syntax for that, and the base library doesn't seem to define an infinity value either…  1/0 is the pseudo-literal i'd use
15:23:24 <ertesx> or recip 0
15:23:30 <ertesx> > recip 0 :: Double
15:23:32 <lambdabot>  Infinity
15:24:10 <hjulle> > 1e500
15:24:11 <lambdabot>  Infinity
15:24:23 <ertesx> > maxBound + 1 :: Double
15:24:24 <lambdabot>      No instance for (Bounded Double) arising from a use of ‘maxBound’
15:24:24 <lambdabot>      In the first argument of ‘(+)’, namely ‘maxBound’
15:24:24 <lambdabot>      In the expression: maxBound + 1 :: Double
15:24:30 <geekosaur> heh
15:25:07 <ertesx> floating point stuff is weird
15:25:14 <ertesx> > recip (-0)
15:25:15 <lambdabot>  -Infinity
15:28:40 <hjulle> (But if you just want to check for infinity, you can always use isInfinite)
15:30:45 * ertesx remembers the times when the floating-point unit was an extra chip and you saw "NaN" for the first time
15:37:10 <malade_mental> please, another problem, fromInt doesn't exist anymore (i hoogled this), but fromInteger is ok. Has the "Integer" type replaced the "Int" ?
15:38:23 <Clint> malade_mental: what do you want to do
15:38:25 <Peaker> why did ghc call it "zonking" and not "dereferencing" a type? the latter is so much clearer
15:39:48 <malade_mental> Clint: I want to write a function avgThree :: Int -> Int -> Int -> Float
15:39:59 <malade_mental> which gives the average between threee numbers
15:40:10 <geekosaur> fromIntegral is the one you want
15:40:30 <malade_mental> this is an exercise from te book "the craft of functional programming" ed.2 that seems to be a lil bit outdated
15:40:51 <Clint> malade_mental: what geekosaur said
15:41:04 <geekosaur> fromInteger only exists because the semantics of integer literals are defined in terms of it; otherwise the more general one is preferred
15:41:34 <malade_mental> ok nice geekosaur thanks :)
15:56:44 <dmwit_> ?pl \a -> seq a (spin a)
15:56:44 <lambdabot> ap seq spin
15:59:33 * hackagebot craze 0.0.1.1 - HTTP Racing Library  https://hackage.haskell.org/package/craze-0.0.1.1 (etcinit)
16:17:10 <maerwald> anyone knows how to programmatically open a file with it's native program? something like "xdg-open", but as a library. Can't find anything like it
16:19:10 <geekosaur> the closest you'll get is something specific to some desktop (e.g. gnome or kde or xfce)
16:19:45 <puregreen> maerwald: just calling xdg-open might be the easiest solution
16:19:57 <maerwald> puregreen: I already do that and it's slow
16:20:03 <puregreen> oh
16:20:14 <maerwald> geekosaur: the mime standard is desktop agnostic
16:20:35 <maerwald> https://standards.freedesktop.org/mime-apps-spec/mime-apps-spec-1.0.1.html#default
16:20:50 <geekosaur> the standard is, yes. the implementations aren't, aside from xdg-open itself (and even that is pretty broken as far as desktop agnostic goes)
16:21:26 <geekosaur> this whole area is like Exhibit A in Why Linux Is Not The Desktop Of The Future
16:22:14 <puregreen> according to Arch Linux wiki, xdg-open itself has to call gvfs-open/kde-open/etc
16:22:34 <geekosaur> yes, because they botched it
16:23:04 <puregreen> so if you want it to be fast, you'd probably have to bypass not only xdg-open, but gvfs/kde-open as well? or am I missing something
16:23:29 <geekosaur> because there *isn't* a generic implementation. and even with the specific one, it can call the wrong one or get other things wrong (calibre completely gave up on xdg-open on linux because it often fumbles URIs)
16:23:54 <maerwald> puregreen: no, you'd just implement the spec. It defines the file names and file locations as well as their content
16:24:28 <maerwald> if a desktop application has more logic than that, then it's not my concern and I am happy to ignore that additional logic
16:24:37 <maerwald> s/desktop application/desktop environment/
16:29:34 * hackagebot werewolf 0.5.1.0 - A game engine for playing werewolf within a chat client  https://hackage.haskell.org/package/werewolf-0.5.1.0 (hjwylde)
16:30:35 <Welkin> I haven't played that game in ages
16:30:38 <Welkin> Werewolf
16:30:44 <Welkin> I used to play Mafia all the time on irc
16:30:47 <Clint> i haven't played it in months
16:31:09 <Welkin> er
16:31:12 <Welkin> Mafioso*
16:31:53 <ggVGc> man, I can't figure out this Lens operation, could someone help me? https://gist.github.com/204f07929e115399e4b89b3032051b4c
16:32:28 <ggVGc> I need to focus on an index in a list, and return the value of the 'seqId' field of that value
16:33:06 <Welkin> ggVGc: you can ask in #lens
16:33:08 <puregreen> trackEntries ^? ix 5 . seqId
16:33:15 <Welkin> (or was it #haskell-lens ?)
16:33:23 <puregreen> (the latter)
16:34:01 <puregreen> and if trackEntries is a lens too, then “curTrack ^? trackEntries . ix 5 . seqId”
16:34:07 <Welkin> All the lens operators I know can be counted on one hand
16:34:11 <puregreen> no, wait, it's not
16:34:23 * puregreen is confused
16:34:47 <puregreen> ggVGc: when you wrote “seqId :: Int”, did you mean that the type of seqId is Int, or that the type of the field is Int?
16:34:57 <ggVGc> the field
16:35:02 <ggVGc> seqId is a lens
16:35:06 <ggVGc> and so is trackEntries
16:35:12 <puregreen> okay, then what I wrote above
16:35:47 <ggVGc> wow, finally, thanks
16:35:59 <ggVGc> I got a bit confused
16:36:03 <ggVGc> but it's obvious now :)
16:40:01 <ntnt> what is harder to learn: recursion or continuations?
16:40:37 <Welkin> neither
16:40:41 <Welkin> just pick one and learn it
16:40:44 <Welkin> then learn the other one
16:40:54 <ntnt> i found recurison trivial
16:41:03 <ntnt> and still can't wrap myhead around all the ways to use the continuation monad
16:41:08 <ntnt> but the two seems very related
16:41:33 <maerwald> continuation monad allows a lot of obfuscation, but I don't think you need it very often directly
16:41:56 <maerwald> it's more of a thing that's there and can be used to solve stuff, but I never really end up using it
16:42:59 <ntnt> I feel like there's a way to do a nicer error handling system, beyond Maybe/Either, but I'm not clear how to see it yet
16:43:12 <ntnt> basically, you can pass in a bunch of continuations for "when you run into this error, kill the computation and exec this here instead"
16:43:15 <maerwald> exceptions :P except they suck in haskell
16:43:36 <pharaun> i've used continuation monad maybe once or twice in 4+ years of coding haskell
16:43:50 <pharaun> i've used the concept of cont a bunch via libraries or other stuff so... fwiw
16:44:04 <maerwald> pharaun: yeah, I know some haskellers who have never even looked at it, I don't think it's that fundamental, also it's a pretty powerful monad
16:44:13 <maerwald> *although
16:44:35 <ntnt> for example, callCC looks awesome
16:44:37 <barrucadu> I'm using continuations in my concurrency implementation to deal with exceptions. It works, but in general I find continuations a bit mind-bending
16:44:37 <ntnt> for error handling
16:44:40 <pharaun> ya, but i haven't found/needed it yet :) even tho i was using a bunch of cont-like stuff (iirc) re pipes and a bunch of other stuff
16:44:49 <pharaun> to rewrite some code exec from BFS to DFS style of execution
16:45:45 <pharaun> since i found it more natural to write a bunch of stuff in bfs style (due to the design of the system) but i wanted it to run in DFS so yeah, time to rewrite it on the fly, was a bit of a mind-bending project for me
16:45:51 <maerwald> barrucadu: yeah, IMO it's not really an intuitive thing, at least when you look at the details
16:46:09 <maerwald> and what kind of weird stuff you can write with it
16:46:13 <ntnt> (>>=) and callCC -- I can implement thme, I don't undertand them
16:53:39 <Welkin> levelonedev: is that low or high?
16:54:42 * hackagebot zip-archive 0.3.0.2 - Library for creating and modifying zip archives.  https://hackage.haskell.org/package/zip-archive-0.3.0.2 (JohnMacFarlane)
16:55:19 <Welkin> @seen athan
16:55:20 <lambdabot> AtH4N
16:55:27 <Welkin> still broken
16:57:38 <ntnt> what am I supposed to learn from arrows? what type of code 'repetition' should I see that makes me go: hmm, gee, I should use arrows ?
16:57:59 <Welkin> I only ever used arrows for FRP
16:58:04 <Welkin> an nothing else
17:00:04 <catern> is there a good channel somewhere for discussion of academic computer science? I thought I'd ask here because, you know, Haskell
17:01:09 <Welkin> catern: ##math or ##categorytheory
17:01:18 <Welkin> I think there is an abstract algebra channel too
17:01:55 <MarcelineVQ> there's ##cs but it's not super active
17:02:09 <ntnt> I think type theory is fair game here too?
17:02:19 <catern> and what about discussions of systemsy academic computer science?
17:08:29 <ntnt> sosp / osdi material is probably off topic here
17:09:01 <ertesx> ntnt: you use an arrow when you can't use a monad
17:09:37 <Welkin> ertesx: mmfreak!?
17:18:32 <nocturne777> in the example, isn't in waitEither the thread that completes second is prone to blocking on putMVar? http://chimera.labs.oreilly.com/books/1230000000929/ch08.html#sec_merging
17:21:03 <balinkingofmoria> @help
17:21:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:21:55 <balinkingofmoria> @djinn (a, b) -> c -> (b, c) ==> f (_, a) b = (a, b)
17:21:55 <lambdabot> Cannot parse command
17:22:00 <balinkingofmoria> @djinn (a, b) -> c -> (b, c) ==> f (_, a) b = (a, b)
17:22:00 <lambdabot> Cannot parse command
17:22:21 <balinkingofmoria> why, HaskellWiki: "Djinn takes a type signature and constructs a function satisfying it: @djinn (a, b) -> c -> (b, c) ==> f (_, a) b = (a, b)"
17:22:31 <balinkingofmoria> might as well try
17:22:34 <balinkingofmoria> > Cannot parse command
17:22:36 <lambdabot>  Not in scope: data constructor ‘Cannot’Not in scope: ‘parse’    Not in scope...
17:22:36 <lambdabot>      Perhaps you meant ‘comma’ (imported from Text.PrettyPrint.HughesPJ)
17:22:39 <balinkingofmoria> nope.
17:22:41 <balinkingofmoria> :(
17:23:31 <thimoteus> balinkingofmoria: you can also /query lambdabot
17:23:57 <lambda-11235> In alex, [^ \n\r\t] matches spaces, but not \n, \r, or \t (as expected), what's happening?
17:23:57 <balinkingofmoria> thimoteus: wow that's incredible
17:24:01 <balinkingofmoria> who needs ghci?
17:24:37 <balinkingofmoria> is \S too general?
17:25:46 <Cale> balinkingofmoria: What is that syntax?
17:25:56 <Cale> balinkingofmoria: ==> is not part of the syntax of ordinary Haskell types
17:26:10 <balinkingofmoria> DUH *facepalm*
17:26:15 <balinkingofmoria> @djinn (a, b) -> c -> (b, c)
17:26:15 <lambdabot> f (_, a) b = (a, b)
17:26:22 <balinkingofmoria> I feel so, so stupid right now
17:26:33 <lambda-11235> balinkingofmoria: No, but it doesn't work either.
17:26:53 <nocturne777> I wish someone would help me with my question :)
17:29:43 <lambda-11235> * Yes, but it doesn't work either.
17:31:42 <lambda-11235> Using \32 works.
17:32:06 <Cale> nocturne777: looking...
17:32:21 <nocturne777> Cale: thank you 
17:34:58 <Cale> nocturne777: I believe the subtlety here is that a thread which is waiting on an MVar that no other thread has a reference to will be killed by an exception.
17:37:09 <nocturne777> Cale: so, it is goin to throw an "BlockedIndefinitelyOnMVar" exception after the function returns ?
17:38:04 <Cale> yeah
17:40:25 <Cale> nocturne777: Though I think it probably wouldn't hurt for the code to just explicitly kill the other thread, rather than waiting for the GC.
17:41:19 <nocturne777> Cale: GC is going to throw this exception in the background and it does not need to be handled by the user code, correcct ?
17:41:27 <Cale> yeah
17:43:22 <nocturne777> Cale: I feel the same way. I think it would have been slightly better if the author mentioned that fact or killed the thread expclicitly.
17:59:40 <ryantrinkle1> is there a way to periodically get a stack trace for all running haskell threads?
18:17:04 <cdtdev_> A while back I saw a discussion about different "styles" of Haskell.
18:17:22 <cdtdev_> From different universities, and they linked some code to read for each style.
18:17:30 <cdtdev_> Does anyone know what I'm talking about / can point me to that discussion?
19:19:46 * hackagebot murmur 0.0.0.1 - Initial project template from stack  https://hackage.haskell.org/package/murmur-0.0.0.1 (outoftune)
19:40:24 <Gurkenglas> What's the shortest token count to solve REACH? Imports don't count. (I expect the name of a library function that already implements it for token count one)
19:40:57 <Gurkenglas> (REACH is where in a graph, you decide whether there's a path between two given nodes.)
19:42:26 <c_wraith> Gurkenglas: fgl can do that.  But you still need to build the graph first. :)
19:42:30 <c_wraith> @hackage fgl
19:42:30 <lambdabot> http://hackage.haskell.org/package/fgl
20:01:06 <Gurkenglas> Ah, the submodules of Data.Graph.Inductive.Query are where all the goodies are hidden
20:02:49 <bottl> hello,how to  run 'ls' command in ghci?
20:03:03 <Cale> bottl: ghci isn't a shell...
20:03:09 <bottl> or dir in windows
20:03:26 <Cale> Or do you just want to know how to execute a program?
20:03:33 <bottl> no
20:03:39 <bottl> :cd 
20:03:49 <bottl> i need :ls or :dir
20:04:05 <Cale> oh, yeah, that doesn't exist
20:04:05 <hjulle> :!ls
20:04:26 <Cale> ah, right, there's a way to execute a shell command :D
20:04:45 <Cale> amusing, I don't think I've ever used that
20:05:01 <bottl> hjulle, oh,yeah
20:05:18 <nitrix> It mimicks vim.
20:05:42 <bottl> sure
20:12:32 <bottl> what's Foldable?
20:13:58 <nitrix> A typeclass.
20:14:38 <bottl> can support fold action?
20:14:44 <nitrix> It regroups types of data structures that can be folded.
20:15:28 <nitrix> bottl: Have you seen Monoid yet?
20:15:41 <bottl> yes
20:16:39 <nitrix> :t fold
20:16:40 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:16:53 <nitrix> > fold [Sum 5, Sum 3]
20:16:54 <lambdabot>  Sum {getSum = 8}
20:17:00 <bottl> i'm reading "learnyouahaskell.com"
20:17:34 <nitrix> Without going into the various ways of folding, I think this is the most important one to understand.
20:18:27 <nitrix> In this example I gave, the foldable `t` in that type signature becomes `[]` (list) when specialized.
20:18:30 <bottl> fold in whcih module?
20:18:42 <nitrix> bottl: Data.Foldable
20:19:20 <nitrix> Thus, a list something foldable, which lets you fold its elements using a monoid.
20:20:19 <nitrix> You wouldn't necessarily need a monoid though. If you go into the more generic functions, like foldr and foldl, here's another example:
20:20:34 <nitrix> > foldr (+) 0 [1..5]
20:20:36 <lambdabot>  15
20:21:15 <nitrix> Which is equivalent to 0+1+2+3+4+5.
20:21:23 <bottl> > fold null [3,4]
20:21:25 <lambdabot>      Couldn't match type ‘Bool’ with ‘[Integer] -> t’
20:21:25 <lambdabot>      Expected type: t0 a0 -> [Integer] -> t
20:21:25 <lambdabot>        Actual type: t0 a0 -> Bool
20:22:02 <nitrix> Almost.
20:22:07 <nitrix> > null [3,4]
20:22:09 <lambdabot>  False
20:22:41 <hjulle> (more specifically, it's equivalent to 1+2+3+4+5+0)
20:22:54 <nitrix> All those, fold, foldr and null are operations that works on foldables.
20:23:46 <nitrix> Maybe one more type signature can help
20:23:50 <nitrix> :t null
20:23:51 <lambdabot> Foldable t => t a -> Bool
20:24:47 <nitrix> bottl: It accepts something of type `Foldable t => t a` and evaluates to a `Bool`. The purpose of null is to test wether the data structure in question is empty.
20:25:30 <nitrix> We were using lists in our example, so you can substitute the type variables if it makes it easier for you. e.g.  null :: [a] -> Bool
20:27:00 <bottl> nitrix, how to use fold instead foldl for: foldl (+) 0 [1..10]?
20:27:34 <nitrix> How? They have different names so you simply pick the proper name.
20:27:44 <bottl> hmm
20:27:48 <hjulle> :t foldl
20:27:49 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
20:27:53 <hjulle> :t foldr
20:27:54 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:28:06 <nitrix> (Different types are well)
20:28:08 <nitrix> *as
20:29:31 <hjulle> foldr (+) 0 [1,2,3] = 1 + (2 + (3 + 0)), foldl (+) 0 = ((0 + 1) + 2) + 3
20:29:39 <nitrix> bottl: foldl and foldr and slightly different because they take a function to perform the folding, and they also need a starting value, often referred to as accumulator.
20:30:27 <cosmos> wow you guys have a haskell evaluator here?
20:30:27 <bottl> i mean fold and foldr or foldl
20:30:30 <cosmos> that's pretty handy
20:30:35 <nitrix> I think the first example with Monoid is much simpler to build yourself a mental model, but it obvious requires a good understanding of monoids.
20:31:20 <nitrix> cosmos: For demonstrating things, yeah, but it has limitations. For one, it's entirely pure. There's no side effects possible.
20:31:43 <bottl> > :t []
20:31:44 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:32:04 <nitrix> bottl: `:t` isn't a haskell function.
20:32:05 <bottl> >:t []
20:32:14 <hjulle> :t []
20:32:16 <lambdabot> [t]
20:32:20 <nitrix> bottl: You want `>` to run code or `:t` to inspect type.
20:32:31 <bottl> ok
20:32:47 <jinmugenfu> hmm
20:34:09 <bottl> :t (>>=)
20:34:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:34:32 <bottl> :t (<*>)
20:34:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:34:53 <bottl> :t (->)
20:34:54 <lambdabot> parse error on input ‘->’
20:35:00 <nitrix> bottl: If it's just to play around, it's probably best to message lambdabot in private or use GHCI on your own.
20:35:11 <bottl> ok
20:38:07 <nitrix> bottl: Feel free to ask any questions you may have though. I hope it clarifies a little Foldables, although I'm sure there's plenty of resources online that'd do a better job at it than my few sentences :]
20:39:20 <nitrix> (Personally, Learn You A Haskell doesn't count as learning material, but it's a decent book to get you curious about Haskell and give you more or less a guided tour).
20:40:02 <cosmos> I can't wait for that new haskell book to come out
20:40:16 <nitrix> Which one?
20:40:20 <cosmos> I'll link it
20:40:41 <cosmos> http://haskellbook.com/index.html
20:40:47 <cosmos> You can get early access
20:40:54 <cosmos> but I'd rather wait until they finish the book 
20:40:56 <nitrix> Oh, well, that one is already out :P
20:41:01 <cosmos> wait really?
20:42:17 <dmj> eacameron: ping
20:42:35 <nitrix> It's not "released", but it's completely usable in its current state. I've seen many people suggesting it and it seems to bring many new names here :)
20:42:46 <cosmos> I haven't read into it that much but I think they haven't made physical copies yet 
20:42:49 <cosmos> but that's pretty sweet
20:43:13 <cosmos> didn't know it was already done considering the website said they wanted to add three more chapters 
20:43:22 <cosmos> I'll definitely want a physical copy haha
20:43:22 <bottl> how to view type defination in ghci?
20:43:57 <nitrix> I've been answering questions from the readers and I've noticed their clearly seem to understand things easier and quicker. The foundation that the book is trying to build is very robust.
20:44:25 <nitrix> bottl: You can inspect the type of any expression with `:t`.
20:44:30 <hjulle> If you mean "definition of a type", then it's ":i NameOfType"
20:45:00 <nitrix> I misread that.
20:47:18 <nitrix> bottl: It works on type classes too, `:i Foldable`, if you're curious.
20:47:38 <nitrix> It even gives a list of instances at the bottom.
20:47:43 <bottl> right,i have tried it under ghci
20:47:58 <bottl> very cool
20:49:17 <hjulle> It actually works on any definition. `:i fold` will show that it is defined as part of the typeclass Foldable.
20:52:57 <nitrix> hjulle: Thanks for the corrections. It is way past bedtime here :P
20:53:04 <nitrix> 'night.
20:53:57 <hjulle> Well, it's way past bedtime for me too. Or rather, it's almost morning here.
20:59:50 * hackagebot PortMidi 0.1.6.0 - A binding for PortMedia/PortMidi  https://hackage.haskell.org/package/PortMidi-0.1.6.0 (PaulLiu)
21:08:48 <orion> Does stack/cabal allow one to release C libraries as part of your project?
21:09:19 <orion> I'm looking to write a shim in C which will allow C programs (or any language with a C FFI) to call functions in my library.
21:17:07 <Axman6> orion: there is a cabal directive which lets you include other files with the package, but not sure how easy it is to make it available to other languages though
21:17:53 <sm> orion: it's easy to include C files with your project, harder to ensure they will build for someone installing it
21:19:46 <orion> Wow: https://github.com/nh2/call-haskell-from-anything
21:19:50 <orion> Now that looks interesting.
21:29:20 <raduom> Hello. Any 'type vim like a pro' tutorial you can recommend?
21:29:39 <shachaf> #vim would be a better place to ask. This channel is about Haskell.
21:35:03 <csalt> Is there a non-editor-war editor/IDE people prefer for haskell? I need to actually get work done during the day while I learn vim on my own time.
21:37:28 <liste> csalt: there's some Haskell work going on for Atom
21:40:15 <csalt> liste: oh snap, I don't know how I hadn't heard of Atom before. I'll check it out, thanks!
21:46:40 <raduom> csalt: this might help http://www.edsko.net/2015/03/07/vim-to-atom/
21:50:12 <ntnt> first class pattern matching
21:50:22 <ntnt> is there anyway to get first class pattern matchinv via reflection or something?
21:50:27 <ntnt> I need it for buildng an edsl
21:51:15 <Cale> ntnt: There are pattern synonyms...
21:51:24 <Cale> But I'm not sure what you mean by first class pattern matching
21:51:51 <ntnt> Cale: how does https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms help me ?
21:51:51 <ntnt> hmm
21:52:09 <ntnt> so I can overload +-*/ in a way that I can build up expressions instead of integers/doubles
21:52:26 <Cale> wait, what?
21:52:27 <ntnt> I'd like to be able to also "overload" pattern matching in a way that I get an "AST of a pattern match" rather than only be able to "execute the pattern matching"
21:52:32 <Cale> That has nothing to do with patterns
21:52:46 <jle`> +-*/ are already polymorphic, you can define them for your own types
21:53:03 <jle`> (*) :: Expr -> Expr -> Expr, if you have an expression type
21:53:05 <Cale> To define arithmetic operators for your own types, you write instances of Num and Fractional
21:53:16 <ntnt> right, so I can  "store haskell expr in terms of +-*/" and examine it later and take it apart
21:53:34 <ntnt> I wnat to similarly "store a haskell pattern matching" as some form of a data structure that I can take apart / examine / play with
21:53:50 <jle`> yeah, that's actualy something that most haskell courses go over, actually
21:53:53 <jle`> as an example
21:54:05 <jle`> but what do you mean by "store haskell pattern matching" ?
21:54:31 <EvanR> represent a case expression with all the patterns and branches as an AST
21:54:35 <EvanR> maybe
21:54:58 <ntnt> what evan said
21:55:09 <ntnt> case BLAH of p1 -> ; p2 -> .. ; p3 -> ; ..
21:55:21 <ntnt> I want to store that peice of haskell code as an piece of data that I can examine / manipulate
21:55:35 <Cale> ntnt: Perhaps look at haskell-src-exts?
21:55:55 <ntnt> Cale: at that point it's no longer haskell edsl land
21:56:00 <Cale> It can parse Haskell source code into a bunch of data structures that you can then manipulate
21:56:00 <ntnt> it's .... parse a *.hs file and interpret it land
21:56:04 <Cale> Yeah, of course
21:56:12 <Cale> But you're talking about case expressions.
21:57:08 <jle`> haskell doesn't really have lispy "homoiconicity"
21:57:11 <Cale> It would break the referential transparency of evaluation to let you see those.
21:57:17 <jle`> haskell AST isn't haskell data
21:57:27 <jle`> but you can define your own representation of case expressions
21:57:42 <jle`> you can create a data type that represents case expressions, etc.
21:57:56 <Cale> case True of True -> "yes"; False -> "no" is equal to "yes", and nothing is going to let you see through that and extract "no" from it.
21:58:32 <EvanR> whatever homoiconicity is... you can do it with haskell-src-exts
21:58:45 <Cale> ... or Template Haskell
21:58:54 <jle`> haskell-src-exts lets you parse haskell strings as a data type, i think
21:58:56 <jle`> TH would be closer
21:59:18 <jle`> (closer to homoiconicity-like behavior.  not that that's worth emulating :) )
21:59:20 <ntnt> you must have arelaly screwed up when the correct answer to your question is TH / haskell-src-exts / ghc api
21:59:22 <orion> Are types that can automatically be converted to C types for the FFI part of a special class?
21:59:38 <Cale> orion: They are instances of Storable
21:59:40 <jle`> ntnt: the "correct" answer isn't TH, it's just to use normal data types :)
21:59:57 <EvanR> orion: yes, they are listed in the FFI docs
22:00:13 <Cale> Oh, right, you mean directly as arguments, yeah
22:00:25 <Cale> There's an explicit list of things which work there.
22:00:41 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-120003.2
22:00:57 <jle`> ntnt: things like this are actualyl sort of a "baby's first haskell project" sort of thing that most haskell courses go over
22:01:09 <jle`> ntnt: it's actually a simple concept :)  just use data types/ADT's to represent the AST
22:01:40 <jle`> but you can't directly use haskell source as haskell data
22:01:57 <jle`> except with something like TH
22:02:05 <EvanR> in addition to the types listed in that link, you can also use newtypes of those types
22:03:55 <ntnt> is it just me, or is the lack of 'first class pattern matching reflection' a serious limitation to creating edsls in haskell ?
22:04:23 <jle`> i don't really think so, i haven't run into it before
22:04:25 <EvanR> i think thats an anti pattern to need that for DSLs
22:04:26 <jle`> and i do a lot of edsl's
22:05:28 <EvanR> one think haskell does not have is defining new syntax sugar
22:05:31 <jle`> well, actually, i think a lot of new languages spun-off from haskell were created as new languages instead of "just haskell" becuase they couldn't reify and reflect on if's and case statements
22:05:45 <ntnt> jle`: yes, exactly
22:05:46 <jle`> but i'm not sure if those were the only reasons
22:05:58 <jle`> not sure if they would have broken off to be other languages regardless of this
22:05:59 <ntnt> I think this is preisely the point when those langauges go "time to build a separate langauge" instead of embed
22:06:28 <EvanR> well thats not necessarily a good idea because haskell is hard to build from scratch
22:06:48 <EvanR> most "just make a new language" projects lack many awesome features
22:07:04 <jle`> i think there are better workarounds than building a whole new language. people sometimes decide it is worth it, but it's usually for other reasons than just lack of reifying if's and case's and stuff
22:07:26 <EvanR> some of these missing features are rebranded as a feature in of themselves... like no types or no exceptions or no threads
22:07:42 <ntnt> i actually want all of that
22:07:47 <ntnt> i don't want to roll my own type checker
22:07:50 <ntnt> nor my own parser
22:08:56 <EvanR> actually using "higher order abstract syntax" ... where you use haskells lambdas for your own lambdas ... results in pretty fast code when optimized
22:12:23 <ntnt> EvanR: does that allow us to reify case/pattern-matching ?
22:12:46 <EvanR> you can directly to what youre talking about with TH
22:13:07 <EvanR> there is a algebraic data type for haskell abstract syntax
22:20:49 <me_> does cabal only add files in .cabal?
22:23:25 <me_> :t id
22:23:26 <lambdabot> a -> a
22:25:21 <liste> me_: what do you want to do? add new modules to your project? add new dependencies?
22:33:46 <Gurkenglas> Should I use lazy or strict maps for "and . M.fromListWith (\_ _ -> False) . map (,True)"?
22:38:26 <Cale> Gurkenglas: Why a Map at all? But also you should know that the type in Data.Map.Lazy and Data.Map.Strict is the same. Only the functions which act on the type are different.
22:39:15 <Gurkenglas> Cale, what else? And I'm aware, I'm just not sure whether the and fold would shortcut, etc.
22:39:51 <Cale> Well, it's the very same instance of Foldable, so it'll do whatever it does no matter which module you import.
22:41:44 <opqdonut> Gurkenglas: what do you mean by shortcut? how are you applying and to a map?
22:41:52 <Gurkenglas> Couldn't there be something with fromListWith doing more evaluation than necessary?
22:41:58 <Gurkenglas> :t and
22:41:59 <lambdabot> Foldable t => t Bool -> Bool
22:42:05 <opqdonut> oh it's foldable nowadays
22:42:10 <opqdonut> I'm stuck in the past
22:42:36 <opqdonut> I think the whole map needs to be built in order for the Foldable instance to know in which order it gives you the keys
22:42:45 <Gurkenglas> (fromListWith ought to be on Foldable to)
22:42:50 <opqdonut> so if you want efficiency, write something else
22:42:56 <Gurkenglas> If it shortcuts, it won't evaluate the list that goes into the composition past the first duplicate it finds
22:42:57 <Cale> (This is testing if all the elements of the list are distinct.)
22:43:07 <opqdonut> Cale: yeah
22:43:14 <Cale> It doesn't appear to shortcut
22:43:31 <Gurkenglas> You tried it? You barbarian :D
22:43:44 <Cale> Well, having tried it, the explanation is obvious
22:43:50 <opqdonut> yeah, the map needs to be built
22:44:05 <opqdonut> I'd just write a custom recursive function that adds stuff to a Set
22:44:12 <opqdonut> until a duplicate is found
22:44:16 <Cale> yeah
22:44:36 <opqdonut> you can bake that into one line with the State monad and mapM I think
22:44:46 <Cale> You can also do it with foldr
22:44:52 <opqdonut> right, of course
22:46:38 <Cale> > foldr (\x xs s -> if x `S.member` s then False else xs (S.insert x s)) (const True) ([1..1000]) S.empty
22:46:39 <lambdabot>  True
22:46:42 <Cale> > foldr (\x xs s -> if x `S.member` s then False else xs (S.insert x s)) (const True) (1:[1..1000]) S.empty
22:46:44 <lambdabot>  False
22:46:46 <Cale> > foldr (\x xs s -> if x `S.member` s then False else xs (S.insert x s)) (const True) (1:[1..]) S.empty
22:46:48 <lambdabot>  False
22:47:59 <Cale> foldr such statefulness
22:49:04 <Cale> also, that if expression is highly questionable
22:49:05 <Cale> haha
22:49:14 <Cale> given that it produces a Bool
22:50:06 <Axman6> not (x `S.member` s) && xs (S.insert x s) ?
22:50:12 <Cale> yeah
22:50:33 <Cale> There's also notMember
22:51:09 <Axman6> yeah
22:51:23 <Cale> S.notMember x s && xs (S.insert x s) ... hmm...
22:53:01 <orion> Is there a standard function somewhere which performs big endian addition on a ByteString?
22:54:19 <Cale> orion: Not as far as I know
22:54:45 <Axman6> you might be able to do it by creating an Integer from the data, but that might be a lot of work
22:54:48 <orion> https://hackage.haskell.org/package/cryptonite-0.13/docs/src/Crypto-Cipher-Types-Block.html#ivAdd <-- that's literally exactly what I want.
22:54:52 <Axman6> @src Integer
22:54:52 <lambdabot> data Integer = S# Int#
22:54:53 <lambdabot>              | J# Int# ByteArray#
22:55:35 <orion> I just find it slightly distasteful to copy/paste code.
23:02:25 <Gurkenglas> :t isJust . (`evalStateT` S.empty) .: traverse_ $ liftA2 (>>) (guard <=< gets . S.notMember) (modify . S.insert) -- not sure if ok
23:02:26 <lambdabot> (Ord a, Foldable t) => t a -> Bool
23:04:49 <Gurkenglas> :t and . (`evalState` S.empty) .: traverse $ liftA2 (<*) (gets . S.notMember) (modify . S.insert) -- nor sure if ok
23:04:50 <lambdabot> (Ord a, Traversable t) => t a -> Bool
23:16:45 <geppettodivacin> How much overhead is actually added to Integer arithmetic on small numbers above and beyond Int arithmetic?
23:17:07 <Axman6> not a lot, pattern matching is pretty fast
23:17:30 <geppettodivacin> I've always avoided Integer out of habit and principle unless I really actually needed the extra space.
23:17:53 <geppettodivacin> Is it pretty standard to just use Integer for everything or is it better practice to use Int where you can?
23:17:58 <shachaf> Hmm, I bet it could be better if "CPR for sums" existed.
23:17:59 <jle`> i think GHC actually optimizes things so that there's pretty much no difference
23:18:21 <jle`> i actually choose Integer over Int these days unless i want a semantic integer with overflow
23:18:27 <shachaf> Actually, maybe not...
23:19:14 <yahzaa> This is my third attempt to learn Haskell. But I just can't understand it. I tried - Learn You a Haskell, Real World Haskell, and fpcomplete.com. Still, I can not write an useful program. Am I missing something?
23:19:45 <Axman6> perseverance! 
23:19:53 <jle`> yahzaa: well, what have you tried writing?
23:20:32 <jle`> is it that you can't think of useful programs to write, or that you're having problems implementing your ideas for useful programs in haskell?
23:21:03 <yahzaa> I tried solving maths puzzles like on project euler
23:21:13 <jle`> that's sort of like... the opposite of useful programs, heh
23:21:39 <jle`> if i wanted to pick something that is the antithesis of a useful program, i'd solve project euler problems :p
23:21:53 <MarcelineVQ> doh ho ho
23:21:59 <yahzaa> :)
23:22:24 <jle`> have you actually tried writing programs that are intended to be useful?
23:22:32 <jle`> or are you having trouble thinking of ideas?
23:23:12 <jle`> if you don't have any occasion to write useful programs in your life, haskell (or programming in general) might not be super useful
23:23:17 <jle`> so it might be hard to learn
23:23:53 <yahzaa> what do you suggest?
23:24:01 <jle`> well, what do you normally program?
23:24:08 <yahzaa> web apps
23:24:09 <jle`> (if haskell isn't your first language)
23:24:13 <yahzaa> python
23:25:05 <jle`> people don't often recommend web apps as a first project, but it looks like you've already read a lot, so it might be something you can look into
23:25:12 <jle`> writing a simple web app in scotty or something
23:25:18 <Gurkenglas> @let fromListWithM = undefined :: (Foldable t, Monad m) => (a -> a -> m a) -> t (k, a) -> m (M.Map k a)
23:25:19 <lambdabot>  Defined.
23:25:21 <jle`> basically...just do whatever you'd normally do, but in haskell
23:25:32 <Gurkenglas> :t getAll . execWriter . fromListWithM (\_ _ -> tell (All False)) . map (,()) -- There, this would work right
23:25:33 <lambdabot> [k] -> Bool
23:26:22 <yahzaa> what would you recommend as first project?
23:26:33 <jle`> whatever you are already familiar with
23:27:07 <jle`> there are some simple toy projects you can do for fun, too, like command line hangman.  the NICTA course also has some toy projects you can do
23:27:22 <jle`> but if your goal is to write useful programs, and you've already read all of those, then best is probably to actaully start writing useful programs
23:27:31 <geppettodivacin> I don't know that it's necessarily the best way to go, but I started by converting some of my (simpler) recent projects to Haskell just to get a feel for the way the language worked.
23:27:44 <geppettodivacin> That might be helpful if you aren't sure where to start.
23:27:59 <jle`> yeah, re-implementing things that you have already wrote is good too :)  along the same lines of "things you are already familiar with"
23:28:05 <jle`> it also helps because you can see what benefits haskell brings to it
23:28:28 <jle`> you can contrast your old code with your new shiny haskell code, and wonder how you ever used to program anything without haskell :)
23:28:55 <yahzaa> :)
23:29:04 <geppettodivacin> And don't be discouraged if your first attempt or two looks pretty ugly. It gets better with time and practice.
23:29:41 <jle`> yeah, the nice thing about haskell is that it's really easy to refactor.  fun, even
23:29:50 <jle`> i like to go through my old haskell code and refactor it for fun when i'm bored
23:30:39 <jle`> always feels really good to refactor a program you haven't touched in 2 years and have it run perfectly and correctly on the first compile
23:30:46 <jle`> try doing that in python :P
23:33:21 <geppettodivacin> So, sounds like the consensus (between the two of us) is to find something interesting, enjoyable, and familiar, and play with the code until it works like you want it to.
23:33:35 <geppettodivacin> And then have fun refactoring it later when you get better.
23:34:20 <geppettodivacin> Only a recommendation, of course.
23:35:00 <geppettodivacin> I personally enjoy Project Euler when I get bored, as well, although jle` is right that they're not exactly useful except for toying with the language.
23:36:34 <yahzaa> I did not try web apps, because I will have to use some framework for e.g. Yesod. Which will cover things, that I should learn first.
23:37:17 <jle`> yeah, scotty is a nice lightweight web framework that doesn't require much upfront knowledge about anything
23:37:18 <yahzaa> i.e. writing things from scratch
23:38:13 <yahzaa> I will try writing some apps in scotty.
23:38:38 <srhb> In my experience, Yesod isn't a very good choice for a "learn Haskell"-kind project. But then again, I think project based learning isn't necessarily a very good start. Depends on your level I suppose.
23:39:01 <yahzaa> I am a complete beginner in Haskell.
23:39:29 <srhb> Then I'd probably do one of the more modern, exercise based books first, and then move on to lightweight projects (where Scotty might very well be a good choice)
23:40:21 <yahzaa> I am also novice to functional programming
23:40:34 <srhb> Still. :)
23:40:45 <jle`> but, you've read lyah, rwh, etc.?
23:40:50 <yahzaa> yes
23:40:57 <jle`> so, not *complete* beginner :)
23:41:01 <jle`> have you looked at ...
23:41:03 <jle`> @where learnhaskell
23:41:03 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:42:27 <srhb> Also http://haskellbook.com/ is very popular these days -- based on feedback I think I'd recommend it. I haven't read it though, only assisted with exercises from there.
23:44:11 <orb> Is it possible to write a function like: reflect :: Phantom Int -> Int
23:44:24 <jle`> what is Phantom?
23:44:29 <orb> data Phantom a = Phantom
23:44:33 <orb> Ie a phantom type.
23:44:46 <jle`> ah, so Proxy in base?
23:44:52 <orb> Yeah, sort of.
23:44:54 <liste> orb: and the value would be undefined?'
23:45:01 <orb> But I couldn't make Proxy work for me.
23:45:02 <jle`> does `reflect _ = 1` work?
23:45:12 <orb> Oh, I want the result to be not static. :)
23:45:19 <jle`> what would it depend on...?
23:45:24 <orb> reflect (Phantom :: Phantom x) = x
23:45:31 <liste> > :t let reflect :: Phantom a -> a; reflect = undefined in (reflect :: Phantom Int)
23:45:32 <jle`> but, x isn't an Int ...
23:45:33 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:45:35 <jle`> x is the type Int
23:45:43 <jle`> what Int are you supposed to return?
23:45:45 <orb> You can make x an Int, via DataKinds.
23:45:52 <jle`> sure, but that's not Proxy Int
23:45:58 <jle`> that's like, Proxy 5, or Proxy 10
23:46:00 <orb> Proxy 10.
23:46:02 <orb> Yeah.
23:46:07 <jle`> ah okay, definitely a different story
23:46:11 <orb> Sorry, not Int, yes.
23:46:22 <orb> Phantom 10 -> Int
23:46:28 <orb> x has kind Int, not type Int.
23:46:37 <cocreature> :t natVal
23:46:39 <lambdabot> Not in scope: ‘natVal’
23:46:39 <jle`> (you mean kind Nat, right?)
23:46:41 <orb> (Unary would also work for me, doesn't have to be integers.)
23:46:46 <cocreature> @import GHC.TypeLits
23:46:46 <lambdabot> Unknown command, try @list
23:46:55 <jle`> but yeah, `natVal` is the exact thing you're looking for
23:46:58 <cocreature> orb: there is a Knownnat typeclass
23:47:01 <cocreature> https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html#t:KnownNat
23:47:06 <jle`> natVal :: KnownNat n => Proxy n -> Integer
23:47:08 <orb> Let me check that.
23:47:42 <orb> I am toying around with something like Linear types, and would like to count how many times a variable is used in a DSL.
23:47:49 <orb> But at compile time, not runtime.
23:48:10 <jle`> `natVal :: Proxy 10 -> Integer` works
23:49:50 <jle`> @let import GHC.TypeLits
23:49:51 <lambdabot>  Defined.
23:50:14 <jle`> > (natVal :: Proxy 10 -> Integer) Proxy
23:50:15 <lambdabot>  10
23:50:29 <jle`> > natVal (Proxy :: Proxy 11)
23:50:31 <lambdabot>  11
23:50:52 <cocreature> I wish we had just gotten some magic singletons instead of KnownNat or KnownSymbol
23:52:02 <jle`> a KnownNat constraint is basically the same as passing an Integer ... so it sort of all fits into the greater scheme of haskell sorta
23:52:13 <Axman6> > natVal (Proxy :: Proxy (3 + 4))
23:52:14 <lambdabot>  7
23:52:31 <Axman6> Didn't actually expect that to work, nice
23:53:25 <int-e> :t (Proxy :: Proxy (3 + 4))
23:53:26 <lambdabot> Proxy 7
23:53:27 <cocreature> jle`: I get why it’s that way, but it still feels weird that Integer and String are so different when lifted to the typelevel whereas I can just write a singleton for all other types
23:53:45 <Axman6> I assumed I'd need '+ or something
23:54:44 <jle`> yeah, sometimes i feel weird about the disconnect too
23:55:07 <jle`> also the fact that `Foo Integer Bool` doesn't auto-promote like i'd like
23:55:29 <jle`> (that was supposed to be a constructor)
23:55:39 <cocreature> that’s even more painful when you really want to have Text instead of String
23:55:57 <cocreature> then you need to create to separate types and then convert between each of them and it’s terrible
23:56:33 <cocreature> we still have a long way to go to make dependent types nice
23:56:39 <jle`> i wonder how i'd do it if i could start from scratch
23:56:57 <jle`> \me . o ( hm )
23:58:36 <adarqui> hey, i forget where i saw it but.. there's a way to create an alias for a data constructor, like N for Nothing. anyone know how?
23:58:48 <cocreature> adarqui: sounds like pattern synonyms
23:58:58 <cocreature> bidirectional pattern synonyms to be precise
23:59:26 <adarqui> ya that was it i think, thanks!
