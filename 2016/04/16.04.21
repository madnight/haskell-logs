00:05:57 <mildfate> I have "responses :: IO [Response ByteString]", and "printCookie :: Response -> IO ()"
00:06:01 <mildfate> How do I compose these?
00:06:40 <uwap> what kind dous Response have? I'm confused
00:06:41 <liste> mildfate: is it the same Response type? seems they have different kinds
00:06:42 <Lokathor> uh, (fmap.fmap) printCookie responses
00:06:53 <Lokathor> i think
00:07:54 <uwap> Lokathor, more like ((>>=).fmap)
00:09:43 <Axman6> responses >>= mapM printCookie
00:09:48 * hackagebot purescript 0.8.5.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.8.5.0 (PhilFreeman)
00:09:48 * hackagebot testing-feat 0.4.0.3 - Functional Enumeration of Algebraic Types  https://hackage.haskell.org/package/testing-feat-0.4.0.3 (JonasDuregard)
00:10:57 <tero-> is there a Haskell library to replace non-ascii unicode characters with closest possible ascii characters? e.g. √§ -> a ?
00:11:12 <Axman6> not yet... go for it!
00:11:21 <Axman6> well, not as far as I know anyway
00:11:42 <cocreature> what do you do with all those weird characters for which there really is nothing close in ascii?
00:11:59 <tero-> ? is acceptable
00:12:03 <srhb> ‚ò≠
00:12:08 <srhb> Superior in every regard.
00:12:24 <tero-> what's that character?
00:12:25 <srhb> In fact, const '‚ò≠' is the function you're looking for.
00:12:27 <srhb> :-)
00:12:30 <srhb> HAMMER AND SICKLE
00:12:34 <tero-> heh
00:12:38 <theduke_> Is there a way to easily install ghc release candidates (eg 8.0.1-rc3) with stack setup?
00:12:40 <Lokathor> no no
00:12:46 <Lokathor> map (const '‚ò≠')
00:12:48 <Lokathor> that's what you need
00:13:18 <liste> > map (const '‚ò≠') "J√§germeister"
00:13:19 <lambdabot>  "\9773\9773\9773\9773\9773\9773\9773\9773\9773\9773\9773\9773"
00:13:34 <tero-> well this was easy
00:13:54 <srhb> > text . map const '‚ò≠' $ "J√§germeister"
00:13:55 <lambdabot>      Couldn't match expected type ‚Äò[Char] -> String‚Äô
00:13:56 <lambdabot>                  with actual type ‚Äò[b0 -> a0]‚Äô
00:13:56 <lambdabot>      Possible cause: ‚Äòmap‚Äô is applied to too many arguments
00:13:59 <srhb> Oh.
00:14:11 <srhb> > text . map (const '‚ò≠') $ "J√§germeister"
00:14:13 <lambdabot>  ‚ò≠‚ò≠‚ò≠‚ò≠‚ò≠‚ò≠‚ò≠‚ò≠‚ò≠‚ò≠‚ò≠‚ò≠
00:14:40 <srhb> tero-: Glad to be of service!
00:16:40 <srhb> I want a terminal font that represents üê´ correctly (BACTRIAN CAMEL)
00:17:29 <tero-> Data.Char.NonAsciiToAscii ?
00:19:25 <tero-> there is something there https://hackage.haskell.org/package/hxt-unicode-9.0.2.4/docs/Data-String-Unicode.html
00:20:14 <srhb> tero-: How about ToASCII, that would be the name of the typeclass anyway, wouldn't it?
00:21:01 <Lokathor> instance ToASCII ByteString where toAscii = id -- yay
00:21:01 <tero-> srhb: is there something else than Char to convert? is a typeclass needed?
00:21:36 <srhb> tero-: I was imagining newtype ASCII = ASCII Char -- anyway
00:23:05 <tero-> I'll first make a preliniary Char -> Char mapping and then the interface can be worked out
00:23:21 <tero-> ToASCII is a good name, though
00:23:32 <srhb> Yeah, the huge work is making and maintaining the table anyway...
00:24:21 <tero-> I'll leave "maintaining" it to pull requests :)
01:03:22 <anohigisavay> hi. i'm playing with bnfc which can generate haskell ast code from bnf-like grammar
01:03:51 <anohigisavay> i wonder if i can integrate it into cabal build process
01:04:03 <anohigisavay> like with alex and happy
01:11:05 <Athas> How can I reduce the memory requirements of ghci?  'stack ghci' is going nuts today (jumping up to 5GiB of resident then dying with OOM), but it worked until recently.
01:11:18 <Athas> Seems that it goes crazy when it hits a type error in my code.
01:15:44 <narijosh> Hello everyone!
01:16:47 <narijosh> I am going to start learning haskell. I have been trying to collect resources. Any suggestions? And motivation to learn Haskell? :)
01:19:55 <tero-> srhb: I'm looking at unidecode Python package and there they are replacing unicode characters with possible more than one character
01:20:07 <tero-> so Char -> Char may not be the best choice
01:20:48 <srhb> tero-: Then you get to the point where different languages have different solutions. For instance, does √∏ become oe in every language, etc.
01:21:14 <srhb> tero-: Not to dissuade you, it's an admirable goal, but prepare for a world of pain. :-)
01:21:41 <tero-> srhb: maybe I take unidecode as a reference implementation and translate its source to Haskell? 
01:22:00 <jophish> wrengr_away: Hi, I'm using (and greatly enjoying) unification-fd. I am using Data.Functor.Foldable.Fix from the 'recursion-schemes' package elsewhere in this code and having to use a little wrapper to convert between the two. I'm curious about the reason behind the alternate definition of Fix in unification-fd, I'm guessing that it was due to 'recursion-schemes not being around when you first started.
01:22:18 <srhb> tero-: Don't ask me, I can't vouch for the sensibility of some Python library that I don't know. :P
01:22:33 <srhb> tero-: My immediate guess is that it does crazy stuff, because converting to ASCII is crazy. :-)
01:23:00 <tero-> :) I'm doing this because my email attachment filenames are breaking
01:24:34 <tero-> oh, GPL license. nevermind then
01:25:05 <tero-> I'll stick to Char -> Char 
01:25:12 <Akii> I'm currently trying to improve on this: http://lpaste.net/160912 I need to get the event definition out of the projection. in I tried to define some data structures for events and streams http://lpaste.net/160913 but I can't figure out how to combine/use that in the projection
01:30:50 <Lokathor> AGPL all the way
01:32:02 <Lokathor> @tell cchalmers hey I recently finished working with a PCG implementation in pure haskell. Your own PCG library had a comment about potentially doing things in haskell instead of with FFI, so I thought you might want a look, https://github.com/Lokathor/ludolib/blob/master/src/Data/PCGen.hs
01:32:02 <lambdabot> Consider it noted.
01:35:10 <tero-> srhb: Codec.Text.IConv with ASCII//TRANSLIT seems to work satisfactorily
01:40:44 <tero-> e.g. ≈†≈í≈Ω≈°≈ì≈æ≈∏ gives SOEZsoez"Y
01:49:46 * hackagebot AFSM 0.1.3.0 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.3.0 (hanzhxu)
01:53:19 <srhb> tero-: How'd you call it?
01:53:34 <orb> I am trying to use freer monads to improve on using a bunch of primitives (formerly in IO) in my code.
01:53:50 <orb> Now, I can't seem to figure out how to use multiple independent IO pieces.
01:53:52 <orb> Any hints?
01:54:19 <srhb> tero-: convertFuzzy Transliterate "UTF-8" "ASCII" gives me... Very interesting results. :-)
01:54:29 <orb> I am using extensible-effects.
01:54:50 <tero-> srhb: convert "UTF-8" "ASCII//TRANSLIT"
01:55:52 <srhb> tero-: Odd.
01:56:11 <srhb> tero-: Mine just throws an exception. Oh well.
01:56:31 <srhb> tero-: Oh, my bad.
02:03:10 <orb> I think I found it, using Control.Eff.Operational
02:29:47 * hackagebot hw-rankselect 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.0.0.1 (haskellworks)
03:14:49 * hackagebot bitx-bitcoin 0.7.0.1 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.7.0.1 (tebello_thejane)
03:34:45 <kqr> why is it that when I specify solver: lts-5.13, stack still tries to install ghc 7.10.2, and then complains that it can't find 7.10.3?
03:36:17 <srhb> kqr: Because it's _re_solver?
03:36:51 <srhb> The rest is still weird though.
03:37:07 <shlomocomputer> FWIW, I think I answered my question from yesterday re: why Prelude.find is slow for me
03:37:09 <kqr> i'm not sure I understand. when I run `stack build` it says there's a ghc version mismatch, because it finds 7.10.2 and needs 7.10.3. it suggests running `stack setup`. when I do, it tries to install 7.10.2 then complains 7.10.2 is already installed
03:37:28 <shlomocomputer> I think the culprit is wrapping every x in a Maybe for the purposes of foldMap
03:37:46 <shlomocomputer> Much faster and as general:  find p = foldr (\x r -> if p x then Just x else r) Nothing
03:38:12 <shlomocomputer> No clue why Prelude is implemented that way
03:38:18 <srhb> kqr: Perhaps you could share your stack.yaml?
03:38:22 <kqr> sure
03:38:44 <kqr> https://github.com/kqr/ren/blob/master/stack.yaml
03:39:55 <shlomocomputer> or rather, Data.Foldable
03:41:08 <srhb> kqr: Looks ok to me, indeed.
03:41:17 <srhb> kqr: Perhaps try in #haskell-stack
03:41:41 <kqr> thanks for the suggestion, srhb. asking there too!
03:42:01 <kqr> wait
03:42:06 <kqr> I seem to have stack version 0.1.3
03:42:11 <kqr> the latest is 1.0.4
03:42:15 <kqr> that might have something to do with it
03:42:21 <srhb> kqr: Uh, yes. :-)
03:42:28 <kqr> can I upgrade stack through stack?
03:42:39 <srhb> kqr: Try?
03:43:08 <kqr> let's see
03:44:21 <lyxia> shlomocomputer: indeed yours looks more efficient. have you benchmarked it?
03:45:21 <shlomocomputer> lyxia:  Yeah.  my program runs in 3 seconds with Data.List, 1 second with my own
03:45:35 <shlomocomputer> Data.Foldable.find, I mean
03:48:42 <shlomocomputer> browsing ghc history on GitHub for clues atm
03:50:45 <lyxia> I don't have any more insight on this but I'd be interested in the answer too.
03:52:01 <srhb> shlomocomputer: https://github.com/ghc/ghc/commit/e56713024e1bfbb7892986800afd9944731b2aa1 ?
03:54:31 <shlomocomputer> srhb:  "to better support things that don't look like cons lists."
03:55:18 <shlomocomputer> Does that make sense to you?  I'm no expert on Foldable structures.
03:55:32 <srhb> shlomocomputer: Not really, just pinpointed a recent commit in case you hadn't found it. :-)
03:55:42 <shlomocomputer> srhb: I surely do appreciate it
03:56:46 <kqr> shlomocomputer, i think what it means is your solution will find the leftmost node in a binary tree
03:56:55 <srhb> shlomocomputer: I don't know when you'd implement foldMap not in terms of foldr, and especially not differently from foldr, but it might very well be a good point.
03:56:58 <cocreature> kqr: there is a "stack upgrade" command
03:57:00 <kqr> shlomocomputer, while the data foldable version will find the topmost node? or something?
03:57:15 <kqr> cocreature, yes, but it did not do me any good with an old solver =)
04:00:27 <shlomocomputer> I'm just wondering what "better support" means.  Clearly, foldr and foldMap are definable in terms of each other
04:00:55 <kqr> hm no First also returns the leftmost value
04:01:31 <akegalj> I don't seem to understand what is CoArbitrary used for? Can someone give me light explanation?
04:01:41 <shlomocomputer> kqr:  reading...
04:03:59 <kqr> shlomocomputer, no, I was wrong
04:06:48 <shlomocomputer> I guess I'd have to look up old discussions.  It was a pretty big commit.  I wonder if someone filed a ticket to "better support" their type
04:07:08 <kqr> this is slightly confusing. almost everywhere I see people who say foldr is more efficient than foldMap
04:09:45 <lyxia> akegalj: it's used to define arbitrary functions
04:13:13 <lyxia> akegalj: CoArbitrary a defines a way to perturb a random generator using data of type a. Then you can generate a function "a -> b" from a generator: given an "a", perturb the generator, and get a "b" out of it.
04:13:36 <shlomocomputer> kqr:  To clarify, I'm not suggesting foldMap is inefficient or to blame for Data.Foldable.find being slow.  It's that First is the Monoid, and First incurs nonzero overhead with Maybes.
04:14:13 <shlomocomputer> as far as I understand it
04:14:38 <lyxia> akegalj: "a -> b" remains pure because the perturbation is only a function of "a"
04:15:01 <kqr> cocreature, when I run stack upgrade it installs the same version I already have
04:16:47 <stick> kqr, are you on windows?
04:16:52 <kqr> OS X
04:16:54 <kqr> unfortunately
04:17:14 <stick> doesn't it have a package manager of its own to manage the stack installation?
04:17:53 <shlomocomputer> kqr:  does this help?  https://www.fpcomplete.com/blog/2015/12/stack-with-ghc-7-10-3
04:17:56 <kqr> it kinda does. i'll try that
04:18:00 <cocreature> kqr: hm not sure about that, you could try "stack upgrade --git" git master is typically very stable
04:18:37 <kqr> shlomocomputer, hm maybe
04:18:43 <kqr> shlomocomputer, when was that option introduced?
04:19:11 <shlomocomputer> kqr:  don't know
04:19:27 <kqr> oh well. the package manager version was recent enough 
04:19:30 <kqr> 1.0.4
04:20:00 <kqr> thanks for your help
04:20:21 <stick> i think you should always use the package manager when you can
04:20:45 <kqr> i prefer to give stack authority when it comes to haskell packages
04:21:28 <mounty> Got a question about logging within the Persistent libraries.
04:21:54 <akegalj> lyxia: ok, I think I get it. Thank you
04:21:55 <mounty> runStdoutLoggingT . filterLogger (\_ _ -> False) (persistAction (insertBy myData) myPool)
04:22:32 <mounty> Shouldn't all logging be suppressed by that?  because it's not.
04:22:33 <mounty> I
04:23:13 <mounty> (My real filter function is supposed to suppress debug output, but it doesn't.  The above is a strip-down to work out what's going on)
04:29:21 <statusfailed> are MVars "magic" (i.e., are they built-in to GHC?)
04:30:08 * hackagebot mime-types 0.1.0.7 - Basic mime-type handling types and functions  https://hackage.haskell.org/package/mime-types-0.1.0.7 (MichaelSnoyman)
04:30:13 <maerwald> all of IO is magic :P
04:31:19 <statusfailed> heh, just wasn't sure if it was possible to implement MVar with other IO functions
04:31:23 <statusfailed> i'll take that as "no" :-)
04:31:43 <maerwald> have a look at the paper maybe http://research.microsoft.com/~simonpj/papers/concurrent-haskell.ps.gz
04:33:16 <cocreature> statusfailed: well you can always use the ffi to use some atomic c instructions or inline assembly, for mvars that should be enough
04:34:23 <shlomocomputer> OK, foldMap is preferred to foldr because of "infinite snoc-lists and the like":  https://ghc.haskell.org/trac/ghc/ticket/9674
04:34:38 <maerwald> erm wat... the strict-concurrency package is basically useless now since it does "base¬†(>=4 && <4.6)"
04:35:00 <OnkelTem> Hi all. I'm following User Guide and try to build my 'helloworld' example and it doesn't build, I get message from the comliper: Couldn't match expected type ‚ÄòData.Text.Internal.Text‚Äô
04:35:08 * hackagebot hw-diagnostics 0.0.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-diagnostics-0.0.0.2 (haskellworks)
04:35:50 <OnkelTem> https://gist.github.com/OnkelTem/ed360bf53962b1ba9f06dc1f26ef1ff7 - this is my code
04:36:44 <OnkelTem> The guid is here: http://docs.haskellstack.org/en/stable/GUIDE/
04:38:36 <AfC> I'm trying to decide whether hackage.haskell.org/package/envparse is clever or crack.
04:39:12 <AfC> wow cut and paste fail. http://hackage.haskell.org/package/envparse-0.3.2
04:39:39 <AfC> Anyone had a reason to turn to that over System.Environment?
04:41:37 <hpc> using Applicative for the API is much nicer than dealing with an IO [(String, String)]
04:46:45 <lyxia> OnkelTem: this is odd, this is the error you would get if you didn't have OverloadedStrings
04:46:57 <lyxia> OnkelTem: oh you wrote LANGAUGE
04:47:00 <ggVGc> livin in IO cuz' I'm livin on the edge
04:50:09 <maerwald> wut :o
04:52:55 <xa0> ggVGc: bad!
04:53:37 <ggVGc> it√§s upsetting when you write a small program and it ends up completely in IO
04:53:48 <ggVGc> like I did yesterday
04:54:13 <aod> hi o/
04:55:09 * hackagebot hw-prim 0.0.0.8 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.0.8 (haskellworks)
04:59:20 <srhb> aod: o/
05:00:42 <OnkelTem> lyxia: thanks! ))
05:01:22 <OnkelTem> lyxia: I'm about to start reading my first book on Haskell
05:05:44 <stick> which one?
05:13:44 <OnkelTem> stick: Learn you a Haskell
05:15:34 <stick> i'm reading that one myself, too
05:19:24 <stick> it's pretty good all around, just not very in-depth
05:20:12 <stick> worst was when the author introduced functions as applicative functors
05:20:29 <stick> and his explanation for it was "it just werkz, but i'm not gonna explain how"
05:20:42 <stick> so you have to figure this one out yourself
05:21:56 <stick> man, haskell is hard
05:22:14 <stick> and its performance is hard to reason about, especially IO parts
05:22:37 <stick> i sometimes wonder if it's all worth it or if i should've just sticked to c++ instead
05:22:44 <sdx23> I run "cabal install --enable-shared --extra-lib-dirs=/usr/lib/ghc/rts --extra-include-dirs=/usr/lib/ghc/rts" and still get "* Missing C library: HSrts-ghc7.10.3" though there is a file /usr/lib/ghc/rts/libHSrts-ghc7.10.3.so - what do I miss?
05:23:20 <stick> but it's a pleasure to write code in it at least, much more so than in c/pluses
05:23:52 <EthanWolf> I just like to program no matter what language I'm programming in :)
05:23:56 <aod> stick: I don't remember last time when I have written 1000loc+ C++ code that worked immediately after compilation ;)
05:25:20 <mniip> I don't remember last time I've written 1000loc of Haskell and it compiled right away :)
05:26:21 <aod> which is fine ;)
05:27:04 <stick> it's just that haskell's messages are verbose and cryptic at times, so it's not immediately clear what it's bitching about
05:27:16 <stick> and you feel like it's just mocking you and won't let you compile your perfectly good code
05:28:31 <aod> stick: it's a matter of exposure, I guess
05:28:52 <aod> stick: learning curve is steep as hell
05:29:17 <aod> but at some point you reach enlightenment
05:29:38 <stick> aod: i wouldn't actaully say it's steep, rather it's hard to get all the concepts in your head together and apply them
05:30:10 * hackagebot hw-rankselect 0.0.0.2 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.0.0.2 (haskellworks)
05:31:09 <EthanWolf> I'm just going through the Haskell tutorial on the website, one thing that annoys me is: I have to put spaces where I'm not used to, like "let x = 4 in x * x"
05:31:37 <EthanWolf> Why can't I just say x*x? :|
05:31:43 <stick> but you can
05:32:04 <EthanWolf> Whoops, meant x=4
05:32:09 <EthanWolf> It didn't work
05:32:37 <EthanWolf> mueval-core: Import.hs: removeLink: does not exist
05:32:44 <stick> "ghci> let x=4 in x*x" produces "16" for me
05:33:16 <EthanWolf> Wow, it won't work on the Haskell site :P
05:33:19 <Ferdirand> > let x=4 in x*x
05:33:21 <lambdabot>  16
05:33:44 <EthanWolf> Wait, this IRC even has a built in compiler? xD
05:33:56 <Akii> yip
05:33:57 <stick> sounds abuseable
05:33:59 <Sornaensis> :t map
05:34:00 <lambdabot> (a -> b) -> [a] -> [b]
05:34:17 <Sornaensis> @hoogle (<|>)
05:34:18 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
05:34:18 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
05:34:18 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
05:34:26 <Sornaensis> ^^ other useful stuff
05:34:33 <EthanWolf> > cos(5)
05:34:35 <lambdabot>  0.28366218546322625
05:34:38 <EthanWolf> xD
05:34:53 <EthanWolf> Now, is that deg or rad?
05:35:18 <stick> > cos 90
05:35:19 <lambdabot>  -0.4480736161291701
05:35:26 <EthanWolf> > cos 5 deg
05:35:28 <lambdabot>      Not in scope: ‚Äòdeg‚Äô
05:35:28 <lambdabot>      Perhaps you meant ‚Äòdef‚Äô (imported from Data.Default)
05:35:36 <EthanWolf> > deg
05:35:37 <lambdabot>      Not in scope: ‚Äòdeg‚Äô
05:35:38 <lambdabot>      Perhaps you meant ‚Äòdef‚Äô (imported from Data.Default)
05:35:38 <stick> apparently it's radians
05:35:43 <EthanWolf> > cos
05:35:45 <lambdabot>  <Double -> Double>
05:35:48 <Ferdirand> > cos pi
05:35:50 <lambdabot>  -1.0
05:36:05 <EthanWolf> > time(NULL)
05:36:07 <lambdabot>  Not in scope: ‚Äòtime‚ÄôNot in scope: data constructor ‚ÄòNULL‚Äô
05:36:08 <Ferdirand> who uses degrees anyway
05:36:17 <EthanWolf> ( Õ°¬∞ Õú ñ Õ°¬∞)
05:36:50 <EthanWolf> > scope
05:36:52 <lambdabot>  Not in scope: ‚Äòscope‚Äô
05:37:12 <EthanWolf> > md5
05:37:14 <lambdabot>  Not in scope: ‚Äòmd5‚Äô
05:37:36 <Sornaensis> > 47/59
05:37:38 <lambdabot>  0.7966101694915254
05:37:49 <kriztw> EthanWolf: you can private message with lambdabot if you want to experiment
05:37:51 <Ferdirand>  by the way it answers privately too, if you want to play with it
05:37:58 <EthanWolf> Can you make it reduce fractions? :P
05:38:42 <Ferdirand> > 6 % 3
05:38:44 <lambdabot>  2 % 1
05:39:42 <Ferdirand> if that is what you mean by reduce
05:40:23 <EthanWolf> Yep :)
05:40:50 <EthanWolf> But how do I then take modulus of a number? :|
05:41:13 <bergmark> :t mod
05:41:14 <lambdabot> Integral a => a -> a -> a
05:41:48 <EthanWolf> But when I do this
05:41:52 <EthanWolf> > 5 mod 3
05:41:54 <lambdabot>      Could not deduce (Integral a0)
05:41:54 <lambdabot>      from the context (Integral a,
05:41:54 <lambdabot>                        Num a2,
05:42:09 <Sornaensis> > 5 `mod` 3
05:42:11 <lambdabot>  2
05:42:23 <Sornaensis> the `` make a function infix
05:42:35 <EthanWolf> Ah, ok :)
05:42:50 <Sornaensis> in other news, I have discovered the ultimate question
05:42:51 <Sornaensis> > (fmap (*)) <$> (+) <*> pure 8 <*> pure 3 $ 6     -- ?
05:42:53 <lambdabot>  42
05:43:19 <EthanWolf> Mo
05:43:19 <Akii> haha
05:43:21 <EthanWolf> Mu
05:43:24 <EthanWolf> *My
05:43:26 <EthanWolf> God
05:43:57 <EthanWolf> Even though I don't really believe xD
05:44:55 <aod> > 41 + 1
05:44:56 <lambdabot>  42
05:44:59 <aod> omg
05:45:02 <Akii> > 42
05:45:03 <lambdabot>  42
05:45:13 <aod> it all makes sense now
05:46:11 <EthanWolf> > ("Illuminati","Confirmed")
05:46:13 <lambdabot>  ("Illuminati","Confirmed")
05:47:02 <EthanWolf> > cos 22.6926968465
05:47:04 <lambdabot>  -0.7638438471625152
05:47:07 <EthanWolf> Aww
05:47:11 <stick> i'm not going to sleep today until i get how this works
05:47:15 <stick> thanks a lot, Sornaensis 
05:47:24 <Sornaensis> yw
05:48:03 <Sornaensis> stick: functions can be treated as Functors, Applicative Functors, and Monads
05:48:48 <EthanWolf> > tan 88.63607247
05:48:50 <stick> i knew about functors and applicative, but not monad
05:48:50 <lambdabot>  0.7946629645981448
05:48:58 <EthanWolf> Oh, whoops
05:49:13 <Sornaensis> :t fmap (+2) (/4)
05:49:14 <lambdabot> Fractional b => b -> b
05:49:21 <Sornaensis> this is just function composition
05:49:27 <Sornaensis> :t (+2) . (/4)
05:49:28 <lambdabot> Fractional c => c -> c
05:49:30 <EthanWolf> > tan 1.546991301
05:49:31 <lambdabot>  42.000000688656
05:49:45 <EthanWolf> Almost life :P
05:51:16 <hpc> > (do {(* 5); (+ 2)}) 8
05:51:18 <lambdabot>  10
05:51:42 <hpc> > ((* 5) >>= (+)) 8
05:51:44 <lambdabot>  48
05:52:22 <hpc> > join (+) 8 -- a much easier entrance to this Monad instance
05:52:24 <lambdabot>  16
05:52:40 <EthanWolf> > tan 1.546991300609828
05:52:42 <lambdabot>  42.0000000000022
05:52:52 <hpc> > cotan 42
05:52:53 <lambdabot>  Not in scope: ‚Äòcotan‚Äô
05:52:57 <hpc> :(
05:52:59 <Akii> :t join
05:53:00 <lambdabot> Monad m => m (m a) -> m a
05:53:05 <Akii> ah
05:53:12 <Akii> wat
05:53:46 <Sornaensis> > sequence [Just 4, Just 5, Just 6]
05:53:48 <lambdabot>  Just [4,5,6]
05:53:54 <jameseb> :t join `asAppliedTo` (+)
05:53:55 <lambdabot> Num a => (a -> a -> a) -> a -> a
05:54:02 <Sornaensis> :t asAppliedTo
05:54:03 <lambdabot> (a -> b) -> a -> a -> b
05:54:04 <Akii> :t (+) 2
05:54:05 <lambdabot> Num a => a -> a
05:55:25 * hackagebot hw-bits 0.0.0.6 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.6 (haskellworks)
05:55:27 * hackagebot hw-conduit 0.0.0.8 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-conduit-0.0.0.8 (haskellworks)
05:55:29 * hackagebot uber 0.1.0.0 - Uber client for Haskell  https://hackage.haskell.org/package/uber-0.1.0.0 (zzat)
05:55:38 <EthanWolf> Welp, gotta go. Catching a bus to travel 11km in ~90 minutes :/
05:56:05 <EthanWolf> > "TTYL"
05:56:07 <lambdabot>  "TTYL"
05:56:36 <Sornaensis> @hoogle asAppliedTo
05:56:38 <lambdabot> No results found
05:56:57 <Sornaensis> @src asAppliedTo
05:56:57 <lambdabot> f `asAppliedTo` a = f where _ = f a
05:56:57 <lambdabot> infixl 0 `asAppliedTo`
05:57:15 <Sornaensis> what
05:57:21 <Sornaensis> where WILDCARD = f a????
05:58:21 <jameseb> Sornaensis: I think it's just forcing type inference on the f
05:58:26 <c_wraith> Sornaensis: not a wildcard
05:58:30 <c_wraith> just an unnamed binding
05:58:59 <c_wraith> Sornaensis: it'd be exactly the same as saying "where superlongunusedname = f a"
05:59:21 <c_wraith> Sornaensis: except that if you name a binding _, you guarantee that it can't accidentally be used
05:59:27 <Sornaensis> how is that not a wildcard
05:59:32 <Sornaensis> it matches anything :P
05:59:43 <c_wraith> But it captures nothing
05:59:48 <Sornaensis> hmm
06:00:26 <Sornaensis> ohhh I see
06:00:35 <Sornaensis> what this asAppliedTo is doing
06:00:38 <Sornaensis> neat
06:01:20 <Akii> ok, what does it do? ^^
06:01:26 <stick> but it just returns f, makes no sense
06:02:30 <c_wraith> > ((++ " there") `asAppliedTo` "hello, ") "hi, "
06:02:32 <lambdabot>  "hi,  there"
06:02:48 <c_wraith> it's a type-restricted version of const
06:03:20 <c_wraith> It returns its first argument, ignoring everything about its second argument except the type.
06:03:35 <c_wraith> and it only pays enough attention to the type to cause a compile error if it doesn't match
06:03:43 <c_wraith> It has no runtime effect
06:03:44 <akegalj> if I have some function defined which can take arbitrary number of arguments, how would I test such function with quick check? (if this is clear enough)
06:03:57 <Sornaensis> > ((++ " there") `asAppliedTo` [1,2,3]) "hi, "
06:03:59 <lambdabot>      No instance for (Num Char) arising from the literal ‚Äò1‚Äô
06:03:59 <lambdabot>      In the expression: 1
06:03:59 <lambdabot>      In the second argument of ‚ÄòasAppliedTo‚Äô, namely ‚Äò[1, 2, 3]‚Äô
06:04:39 <c_wraith> Sornaensis: unfortunately, (++ " there") isn't polymorphic enough.
06:05:05 <c_wraith> > ((+ 10) `asAppliedTo` 0.5) (1 :: Int)
06:05:07 <lambdabot>      No instance for (Fractional Int) arising from the literal ‚Äò0.5‚Äô
06:05:07 <lambdabot>      In the second argument of ‚ÄòasAppliedTo‚Äô, namely ‚Äò0.5‚Äô
06:05:07 <lambdabot>      In the expression: (+ 10) `asAppliedTo` 0.5
06:05:13 <Sornaensis> ye
06:05:17 <Sornaensis> that's cool
06:05:34 <stick> so, what would be the typical use for it?
06:06:01 <c_wraith> stick: rarely, you want something like that to prove to the compiler that you're using the same type in two different places.
06:06:02 <pavolzetor> I have tried to build my old project with -XStrict and after running the program for over 10 hours I killed it. Is it possible that strict causes some infinite loop?
06:06:18 <c_wraith> stick: much more often, it's a tool for demonstrating how type inference works in demonstrations here. :)
06:06:46 <stick> alright, thanks
06:06:46 <Sornaensis> c_wraith do you use haskell professionally
06:07:02 <c_wraith> pavolzetor: absolutely.  The whole point of non-strict behavior is to allow programs to terminate that wouldn't otherwise.
06:07:16 <c_wraith> pavolzetor: -XStrict should never be used at wider than a single module level.
06:08:46 <pavolzetor> c_wraith: is there a debugger to step through the program to figure out if this is my problem or some package problem?
06:10:46 <c_wraith> pavolzetor: I blame the extension mostly.  It really shouldn't be used.  It makes doing the wrong thing exceptionally easy, to slightly simplify special cases.  But some people have convinced themselves those special cases are vitally important, so the extension exists.
06:12:26 <c_wraith> Sornaensis: I have in the past.
06:12:29 <Sornaensis> can someone explain to me why haskell does this http://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Tuple.html#t:-40--44--41-
06:12:46 <Sornaensis> instead of defining triples and so on as like nested tuples
06:13:07 <c_wraith> Sornaensis: it's because of laziness, and tuples being lifted products.
06:14:05 <Sornaensis> oh, nesting would produce thunks?
06:14:07 <pavolzetor> c_wraith: I do not agree, laziness does not scale to many cores, it just chokes on memory bandwidth, I hope to gain from the strict pragma
06:14:48 <c_wraith> pavolzetor: laziness in a particular computation doesn't scale.  Fix that computation so it's correct.  Don't activate the misfeature of breaking other things at the same time.
06:15:04 <c_wraith> Sornaensis: yes
06:15:51 <c_wraith> pavolzetor: The thing is, full strictness is broken just as often as full laziness.
06:16:23 <c_wraith> pavolzetor: There's no substitute for understanding what you're doing.  -XStrict still requires you to understand what's going on, or you write infinite loops.
06:16:43 <pavolzetor> c_wraith: the computation is correct, I just do not want any pointer chasing; my friend uses Rust and it wipes the floor with what I have (I know I probably chose wrong language for problem, it's just I like Haskell, so I rather throw 100x more computers at the problem)
06:17:10 <c_wraith> pavolzetor: -XStrict doesn't even remove pointer chasing.
06:17:58 <pavolzetor> c_wraith: why not? the compiler should be smart enough to not box everything
06:18:12 <c_wraith> pavolzetor: except in the very specific case of non-polymorphic small children of data types.  But you can remove that pointer chasing by just marking those fields with !
06:18:31 <pavolzetor> for example vec3, that is 10 words
06:19:00 <c_wraith> pavolzetor: but the problem is, you applied -XStrict to your whole program.  Not to "the algorithm"
06:19:16 <c_wraith> pavolzetor: it broke your whole program, because your program depended on laziness to function.
06:19:35 <pavolzetor> sure, it was quick test
06:19:50 <pavolzetor> how can I find what causes the infinite loop?
06:20:08 <pavolzetor> I want to step through the program, avoid things like Debug.Trace
06:20:40 <lyxia> you can build it with tracing enabled, and see what functions it keeps calling
06:21:43 <c_wraith> You mean profiling?
06:22:52 <lyxia> I mean the stack --trace thing
06:23:09 <pavolzetor> oh, thanks, I will try that
06:23:23 <lyxia> profiling is also an option I guess
06:23:35 <pavolzetor> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
06:23:40 <pavolzetor> I will try this too
06:23:58 <pavolzetor> c_wraith, just stepping through, like in visual studio or gdb
06:26:50 <c_wraith> pavolzetor: ghci has some tools for that, but I've never used them.  I don't think they're well-publicized.
06:27:13 <statusfailed> "exception types form a hierarchy", but where is that hierarchy specified?
06:27:56 <c_wraith> statusfailed: it's an open hierarchy.  and as far as I know, it's also basically flat.
06:28:34 <statusfailed> c_wraith: what does "open hierarchy" mean, what does it mean to be "flat", and how is "SomeException" defined to be the root of it?
06:28:44 <statusfailed> and sorry for the question bomb :D
06:29:36 <c_wraith> statusfailed: Let's start with the last one.  SomeException is an existential wrapper for anything that implements Exception
06:30:08 <c_wraith> statusfailed: The details of the Exception class, in fact, are specifically about being able to be wrapped into SomeException, and unwrapped from it.
06:30:37 <Sornaensis> > ("Hello","World") ^._2
06:30:38 <lambdabot>  "World"
06:31:03 <c_wraith> statusfailed: are you comfortable with that much?
06:31:08 <statusfailed> c_wraith: ahh OK, now the source of SomeException totally makes sense!
06:31:16 <statusfailed> yep, thanks!
06:31:35 <statusfailed> so i'm guessing 'Flat' just means - SomeException is the root, and everything else is 1 level deep
06:31:45 <statusfailed> or rather: everything else is a child of SomeException
06:32:00 <statusfailed> oh and "open" means "open for extension" ?
06:32:03 <c_wraith> statusfailed: well, the hierarchy, such as it is, is that you can create other class/wrapper combinations where the class is a subclass of Exception
06:32:30 <c_wraith> statusfailed: But no one has really done that.  Which is what I mean by "it's flat" in practice.  SomeException is the only level that really used.
06:32:40 <statusfailed> Ah OK, and those would use the same trick as SomeException
06:32:43 <c_wraith> yes
06:32:46 <statusfailed> OK cool, thanks!
06:33:40 <hpc> actually, now i am wondering where "open" comes from
06:34:03 <c_wraith> hpc: just that anyone can create elements in the hierarchy
06:34:14 <c_wraith> hpc: unlike if it was an ADT, for instance
06:34:31 <hpc> c_wraith: i mean the word
06:34:53 <hpc> it seems like someone took https://en.wikipedia.org/wiki/Closure_%28mathematics%29 and went "closure" -> "closed", then opposite of "closed" is "open"
06:35:00 <c_wraith> oh.  I think just standard math use.  a closed universe is complete.  an open one can have elements added
06:35:49 <lyxia> "open" because stuff can come in
06:35:53 <ski> i'm not sure i like that `toException' is (appears to be ?) idempotent ..
06:36:07 <ski> (at least as what concerns `fromException')
06:36:10 <hpc> c_wraith: maybe it is just that simple
06:36:38 <hpc> wikipedia only has info about "open" in the context of sets, where closed and open aren't mutually exclusive because reasons
06:36:39 <c_wraith> hpc: I'm not 100% sure of etymology, but..  that's my guess. :)
06:37:05 <ntnt> what is the best bang for the buck if I have a big ghc/ghcjs project and compile time really really matters ?
06:37:23 <c_wraith> ntnt: best bang for the buck in terms of what? build farm?
06:37:35 <ntnt> c_wraith: no, a single person desktop for < 2K
06:37:46 <ntnt> okay with server machiens too, no need for graphics card
06:37:48 <statusfailed> c_wraith: thanks again for that explanation btw, super helpful!
06:37:51 <ntnt> I just want ghc/ghcjs to run fast
06:37:57 <ski> e.g. `(fromException . toException . toException) Overflow' is equal to `(fromException . toException) Overflow', at type `Maybe ArithException'
06:38:04 <hpc> ntnt: have enough ram and get a good cpu
06:38:05 <ski> .. which seems wrong, to me
06:38:24 <ntnt> hpc: so i7 8 core + SSD + as much RAM as possible? does RAM matter after 16 GB?
06:38:28 <c_wraith> ntnt: single most important thing is enough RAM to avoid swapping.  Next-most important is SSD
06:38:29 <hpc> there's really not much more in the way of "one weird trick to make ghc go fast"
06:38:33 <c_wraith> 16 GB is plenty
06:38:47 <stick> okay, i barely understand this, but at least i can go to sleep peacefully now: http://lpaste.net/160933
06:38:53 <hpc> unless changing code is an option
06:38:56 <c_wraith> I've seen swapping at 1GB, but not 2.
06:39:00 <ntnt> okay, so i7 + 16GB RAM + 256 GB SSD, should be more than enough? (this is available for $700, so way below 2K budget)
06:39:05 <hpc> in which case see which modules compile slowly and finagle things that way
06:39:08 <selckin> actualy fast desktop cpu not a datacenter one with low wattage
06:39:45 <Akii> stick: wow
06:39:53 <hpc> does ghc do parallel compilation yet?
06:40:58 <hpc> also since you're compiling to js, using a faster linker or llvm probably won't help
06:41:07 <hpc> so improvements there are ruled out
06:41:42 <ntnt> hpc: well, I have lots of modules, so I think ghc can compile modules in parallel?
06:42:10 <c_wraith> cabal will build packages in parallel, but I don't think I've seen ghc build modules in parallel yet.
06:42:14 <ntnt> so basically, $700 = i7 8 core + 16 GB RAM + 256 GB SSD -- even if I were to spend 2K, my GHC time is not likely to drop by more than 50% ?
06:42:35 <c_wraith> ntnt: yeah, you already have the most important parts.
06:42:42 <hpc> aha, -j was added to ghc two years ago
06:42:53 <c_wraith> Huh.  I guess you have to use it manually?
06:43:43 <hpc> that's almost always the case with build systems
06:43:51 <hseg> Hi. Why does GHC tell me that given this code http://lpaste.net/160934, foo (W []) 0 doesn't typecheck (it complains that (W []) should have type Aux f0 a0, whereas it has the type WeightedL a0)
06:43:54 <hseg> ??
06:43:56 <ntnt> c_wraith, hpc: noted, thanks
06:44:06 <c_wraith> except for cabal installing a bunch of packages at once. :)
06:44:07 <hpc> so many things will fail for no good reason from old projects that do weird stuff
06:44:58 <c_wraith> hseg: could you edit in the error message in a comment?
06:46:01 <hseg> Sure
06:46:03 <hseg> http://lpaste.net/160934
06:47:22 <ertes> ntnt: for rapid prototyping it's useful that GHCJS seems to have a working interpreter
06:47:38 <ntnt> ertes: ghcjsi works now?
06:47:42 <c_wraith> hseg: ah.  the problem is that your class is unusable. :)
06:47:44 <ertes> i can fire it up in haskell-interactive-mode and load my modules with it
06:47:45 <ntnt> I thought it was going to be releaee with duke nukem 3d
06:47:57 <ertes> ntnt: ghcjs --interactive
06:47:59 <hseg> Oh?
06:48:12 <c_wraith> hseg: at least, the foo portion is.
06:48:19 <c_wraith> hseg: I really wish GHC would flag those.
06:48:23 <ntnt> ertes: if true, this is hug
06:48:25 <ntnt> e
06:48:28 <ertes> i don't know how well it works, as i've only used it with toy examples, but it does load and interpret everything properly so far
06:48:40 <ertes> luite_ would be the one to ask for details
06:48:45 <c_wraith> hseg: there's no way to determine what type f to choose for an instance from a call to foo
06:49:00 <hseg> Ah, right, since Aux is non-injective.
06:49:01 <c_wraith> hseg: the type f doesn't appear in the arguments or results of foo
06:49:05 <c_wraith> hseg: yep
06:49:17 <ntnt> OMG
06:49:21 <ntnt> ghcjs --interactive works for me too
06:49:27 <ski> hseg : since `Aux' and `Elem' aren't specified to be injective, you can't be sure that `f' can be determined from `Aux f a',`a',`Elem f a' in `foo :: Aux f a -> a -> Elem f a'
06:49:29 <ntnt> ertes: this is insane
06:49:49 <hseg> c_wraith: OK... Just a sec, trying a variation.
06:49:58 <ntnt> ertes: how do you dal tiwh "socket.io not found, browser session not available"
06:50:16 <ertes> ntnt: if you use nix, you can use my little hack to integrate it seamlessly into haskell-interactive-mode
06:50:28 <ertes> ntnt: i don't so far
06:50:30 <ntnt> ertes: I am using ryan trinkle's try-reflex platform
06:50:39 <ntnt> I'm also a vim user
06:50:58 <ertes> ntnt: i guess for that i'd probably abstract away the networking code
06:51:11 <ertes> then swap it for some dummy implementation for testing
06:51:42 <ntnt> this is huge
06:51:51 <ntnt> if I can get ghcjsi to run code inside my *browser*, this changes everything
06:51:52 <ntnt> OMG
06:52:05 <ntnt> in case it's not clear, I'm excited
06:52:34 <ertes> ntnt: ryan is also a heavy nix user, so you may get the integration for free‚Ä¶  but i don't know how it is with vim
06:52:51 <ertes> is there something like haskell-interactive-mode for vim?
06:53:24 <Sornaensis> ertes: in what sense
06:53:38 <Sornaensis> vim is not really suited to running REPLs and stuff
06:53:47 <ertes> Sornaensis: interactive type-checking and type queries
06:53:52 <ertes> with markers in the source code
06:53:58 <Sornaensis> yes you can use ghc-mod for things like that
06:54:04 <ertes> ah, i see
06:54:08 <ntnt> is this socket.io just python-socket.io, or something else?
06:54:14 <Sornaensis> there's ghc-mod, Syntastic, and Tagbar
06:54:28 <Sornaensis> those three plugins cover most of my haskell workflow in vim
06:55:12 <hseg> c_wraith: Ah, I see. Checking my original code of which this is a MWE, I was indeed only using associated type synonyms
06:55:29 <hseg> c_wraith: One solution would be to make Elem into a data family, correct?
06:56:03 <c_wraith> hseg: somewhat, but that also changes its meaning a lot.  It actually makes you declare a new type (though with the same name) for each instance
06:56:09 <hseg> Right.
06:56:20 <ertes> Sornaensis: is that easy enough to set up, so i can recommend it to haskell newbies who use vim?
06:56:25 <hseg> However that forces the type family to be injective by fiat
06:56:48 <hseg> Which is desirable in certain situations.
06:56:49 <c_wraith> hseg: another approach is to pass a proxy argument to the foo function, from which it can determine the type of f
06:57:16 <hseg> Yep
06:57:33 <Sornaensis> ertes: depends on if they're vim newbies
06:57:48 <c_wraith> hseg: sounds like you know your options then.  At least before GHC 8.  :)
06:58:03 <hseg> Oh? Does TypeInType make things more fun?
06:58:21 <c_wraith> hseg: No.  I was thinking of Injective type families and explicit type application
06:58:22 <ertes> Sornaensis: i would expect them to know how to install a package and put something into the configuration file
06:58:38 <c_wraith> hseg: each of which provide slightly different points in the design space
06:58:44 <Sornaensis> ertes: https://github.com/lukerandall/haskellmode-vim
06:58:46 <hseg> And yes, I'd completely forgotten about noninjectivity. Side effect of kloc read >>> kloc written
06:58:51 <Sornaensis> this will turn vim into a haskell IDE
06:58:57 <Sornaensis> with haddock integration and everythin
06:58:58 <hseg> Right.
06:59:04 <ertes> Sornaensis: great, thanks
06:59:17 <Sornaensis> requires minimal configuration
06:59:19 <Sornaensis> y/w
07:03:07 <hseg> OK, gotta go, thanks
07:05:24 <jophish> ugh, this looks horrible sequence (bitraverse foo pure <$> p)
07:05:33 <jophish> horrible: *
07:06:18 <jophish> there must be a neater way of doing: (a -> Maybe b) -> [(a,c)] -> Maybe [(a,b)]
07:06:43 <isocliff> Is there anything in base that exports a definition for fmap . fmap or fmap.fmap.fmap?
07:07:08 <ertes> jophish: overall Nothing when there is an individual Nothing?
07:07:22 <jophish> ertes: yes
07:07:34 <c_wraith> jophish: discarding the original c values?
07:07:46 <ski> evidently ..
07:07:47 <jophish> oh whoops
07:07:57 <ertes> c_wraith: no other option with that type
07:07:58 <c_wraith> I thought that might be a typo in the sig. :)
07:08:03 <ski> (:
07:08:09 <ertes> =)
07:08:10 <c_wraith> And it sounds like it was
07:08:20 <jophish> It should have been: (a -> Maybe b) -> [(a,c)] -> Maybe [(b,c)]
07:08:28 <c_wraith> that makes way more sense. :)
07:09:30 <dsm> is there a function which converts [1,2,3] to [(1,2), (1,3), (2,3)]?
07:09:31 <ski> an attempt to "restrict the domain", i suppose you could say
07:09:34 <c_wraith> :t mapMOf
07:09:36 <lambdabot> Profunctor p => Over p (WrappedMonad m) s t a b -> p a (m b) -> s -> m t
07:09:56 <c_wraith> :t mapMOf _1
07:09:58 <lambdabot> (Monad m, Field1 s t a b) => (a -> m b) -> s -> m t
07:10:04 <ertes> dsm: permutations
07:10:08 <ertes> oh, no
07:10:30 <ski> > let ns = [0,1,2] in [(m,n) | m:ms <- tails ns,n <- ms]  -- dsm
07:10:31 <lambdabot>  [(0,1),(0,2),(1,2)]
07:10:36 <l4m8d4> Is it expensive to do recursion in haskell? Compared to java, for example
07:10:42 <c_wraith> > mapMOf _1 Just [(1, 'a'), (2, 'b')]
07:10:44 <dsm> whooo, thanks
07:10:44 <lambdabot>      No instance for (Show t0)
07:10:45 <lambdabot>        arising from a use of ‚Äòshow_M873625920690828901524643‚Äô
07:10:45 <lambdabot>      The type variable ‚Äòt0‚Äô is ambiguous
07:11:00 <c_wraith> :t mapMOf _1 Just [(1, 'a'), (2, 'b')]
07:11:01 <lambdabot> (Num t1, Field1 [(t1, Char)] t a a) => Maybe t
07:11:05 <ski> l4m8d4 : not really in itself
07:11:20 <ertes> l4m8d4: it can be anything from free to terribly expensive‚Ä¶  the question is too vague
07:11:39 <c_wraith> :t mapMOf _1 Just [(1, 'a'), (2, 'b')] :: Maybe [(Int, Char)]
07:11:41 <ski> function calls in themselves are pretty cheap
07:11:41 <lambdabot>     No instance for (Field1 [(t0, Char)] [(Int, Char)] a0 a0)
07:11:41 <lambdabot>       arising from a use of ‚Äò_1‚Äô
07:11:41 <lambdabot>     In the first argument of ‚ÄòmapMOf‚Äô, namely ‚Äò_1‚Äô
07:11:45 <l4m8d4> ski: But it does eventually overflow, like in other languages, if you do an infinite recursion, right?
07:11:49 <c_wraith> Oh, right.
07:11:55 <ski> the question is how your recursion divides the problem
07:12:10 <ertes> l4m8d4: only if it makes sense to overflow (you're building things without consuming them)
07:12:18 <paldepind> If I have a type "Something a b" of kind "Element" is it possible to create a type-level function for composing two of these but only if the last type in the fist match the last type in the first. I currently have "type Element :> ELement" but that will accept too much.
07:12:25 <c_wraith> jophish: I'm pretty sure mapMOf works, if I get the argument order right. :)
07:12:26 <ertes> l4m8d4: that is without consuming or forgetting them
07:12:41 <l4m8d4> ertes: Okay, that makes sense
07:12:46 <ski> l4m8d4 : depends. `let xs = 0 : map (1 +) xs in take 100 xs' is an infinite recursion, but terminates just fine
07:13:55 <ertes> l4m8d4: you determine the run-time behaviour of a recursive definition not by looking at how you recur, but how you consume
07:14:01 <ertes> > take 10 [1..]
07:14:02 <ski> > let xs = 0 : map (1 +) xs in take 20 xs  -- fwiw
07:14:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:14:03 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
07:14:30 <ertes> l4m8d4: the 'take' determines that this is finite and cheap, not the infinite list itself
07:14:36 <l4m8d4> > [1..]
07:14:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:14:53 <l4m8d4> Just wanted to try :D
07:15:03 <ertes> l4m8d4: what you see there is basically a 'take' after a 'show'‚Ä¶  that's why even that terminates and is cheap =)
07:15:07 <ski> l4m8d4 : there's also tail-recursion, which doesn't consume any extra "stack" space (but may consume unbounded heap space, if you're no careful) .. however, tail-recursion tends to be less important in Haskell than in strict languages 
07:15:13 <haskell550> I will send someone $10 on Paypal if they can help me solve a Haskell problem I have been working on for 3 hours.. 
07:15:21 <c_wraith> > mapMOf (traverse . _1) (\x -> if even x then Just x else Nothing) [(2,'a'), (4,'c')] -- jophish 
07:15:23 <lambdabot>  Just [(2,'a'),(4,'c')]
07:15:31 <c_wraith> > mapMOf (traverse . _1) (\x -> if even x then Just x else Nothing) [(2,'a'), (3,'c')] -- jophish 
07:15:34 <lambdabot>  Nothing
07:15:53 <c_wraith> jophish: so..  mapMOf (traverse . _1)
07:16:23 <ertes> l4m8d4: counter-example:
07:16:35 <ski> l4m8d4 : anyway, you can make less efficient recursions, and more efficient ones. this is basically an algorithm problem
07:16:36 <ertes> > filter even [1, 3..]
07:16:40 <lambdabot>  mueval-core: Time limit exceeded
07:16:50 <ski> l4m8d4 : even in Java, sometimes a recursion is the best way to solve a problem
07:17:45 <haskell550> readHexTransition :: String -> Maybe [HexTurn]
07:17:48 <ski> > takeWhile (< 10) [1,3 ..]
07:17:49 <lambdabot>  [1,3,5,7,9]
07:17:56 <haskell550> readHexTransition str = hxList
07:17:59 <ski> > filter (< 10) [1,3 ..]
07:18:03 <lambdabot>  mueval-core: Time limit exceeded
07:18:13 <ski> > filter (< 10) [1,3 .. 1000]
07:18:15 <lambdabot>  [1,3,5,7,9]
07:19:14 <haskell550> Is there anyone here that can help me out with this? 
07:19:48 <haskell550> It will take 5 mins flat and I am more than happy to pay for help.. this is driving me crazy
07:19:53 <ski> l4m8d4 : fyi, `filter' keeps all the elements in a list satisfying a condition. `takeWhile' keeps elements from the front, until it reaches an element not satisfying the condition
07:20:09 <srhb> haskell550: What's the problem_
07:20:38 <haskell550> How do I contact just you?
07:20:41 * hackagebot aeson-value-parser 0.11.3 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.11.3 (NikitaVolkov)
07:20:45 <ertes> haskell550: if you want commercial support, i'm available for hire, but i suggest you just explain your problem‚Ä¶  many here (including me) are often quite happy to give voluntary support for free =)
07:20:55 <srhb> haskell550: By detailing the problem here in the channel. :)
07:21:01 <ski> l4m8d4 : the problem with `filter (< 10) [1,3 ..]' is that `filter' doesn't know that the (infinite) list is increasing, and so it doesn't know that `9' is the greatest element in the list. so it keeps waiting to see if there's another element less than `10', later .. which never happens. therefore we get nontermination
07:21:44 <haskell550> So I can just type now or do i have some way to PM?
07:21:47 <ski> > take 5 (filter (< 10) [1,3 ..])  -- l4m8d4, but this works, because we're only looking at the first five elements, which are defined
07:21:51 <haskell550> (Thanks for reply btw)
07:21:52 <lambdabot>  mueval-core: Time limit exceeded
07:21:58 <srhb> haskell550: Pasting the relevant snippet on lpaste.net is usually a good idea.
07:22:03 <srhb> haskell550: Reduced to the core problem.
07:22:05 <ertes> haskell550: type here‚Ä¶  we do public support, so everybody can benefit
07:22:11 <srhb> haskell550: Then just explain what you're trying to do and where you get stuck.
07:22:14 <ski> > take 6 (filter (< 10) [1,3 ..])  -- while this doesn't work, since lambdabot wants to see the next element, before deciding to print the result
07:22:15 <haskell550> Ok
07:22:18 <ertes> haskell550: prose here, code on lpaste.net
07:22:18 <lambdabot>  mueval-core: Time limit exceeded
07:22:30 <ski> l4m8d4 : does this help ?
07:23:00 <ackthet> any libraries for doing error propagation? tried google but its giving me error handling in the results
07:23:07 <ski> haskell550 : is this homework ?
07:23:09 <haskell550> I'm trying to write a function which will take a string and return HexTurns ie "L1L2" becomes the turns L1 L2
07:23:30 <haskell550> Is for a group coding class I'm doing
07:23:38 <ertes> ackthet: error "propagation"?
07:23:42 <ski> haskell550 : what have you tried so far ? can we see your code attempt(s) ?
07:23:45 <haskell550> I've got 95% of the code written up
07:24:03 <ackthet> ertes: like, propagation of uncertainty
07:24:04 <nitrix> haskell550: No idea what a turn "L1" or "L2" is. You're exposing a XY problem to us.
07:24:06 <haskell550> I've already successfully written the function for sqaure turns ie just L or R
07:24:24 <haskell550> Imagine a world where the cells are hexagon shaped
07:24:34 <ski> nitrix : presumably `data HexTurn = L1 | L2 | ...'
07:24:36 <ertes> ackthet: could you give an example use case?  i'm not quite sure what you mean, unless it's handled by exception handling
07:24:36 <haskell550> This is for the Langdons Ant problem
07:24:44 <haskell550> That's it
07:24:45 <ackthet> no i don't mean that kind of error
07:24:56 <ackthet> like 2.3 ¬± 1.8
07:25:06 <ackthet> i should say uncertainty 
07:25:06 <ertes> oh
07:25:11 <ackthet> not error
07:25:13 <ertes> numeric error
07:25:15 <haskell550> for squareTurn (ie just L and R) I used map
07:25:15 <ackthet> to be less confuse
07:25:16 * ski doesn't know how many data constructors `HexTurn' has (six ?), nor whether they're all non-functions
07:25:42 <ski> haskell550 : anyway, provide the definition of `HexTurn' in your paste (or at least give us a link to info on it)
07:25:45 <haskell550> yes 6
07:25:47 <ertes> ackthet: look on hackage, but if you can't find anything, it's not too difficult to implement it yourself
07:26:11 <haskell550> data HexTurn = L2 | L1 | None | R1 | R2 | U
07:26:23 <ski> _in your paste_ would also be fine :)
07:26:26 <haskell550> 6 sided cells for the ant top wall on
07:26:47 <ahihi> ackthet: there's the intervals package for interval arithmetic, not sure if that's different from what you want
07:27:13 <ski> haskell550 : have you opened <http://lpaste.net/> in your web browser yet ?
07:27:45 <ertes> ackthet: interval arithmetic might work, if you don't need any statistical measures about the error
07:27:56 <haskell550> do I make it publci on ipaste?
07:28:01 <haskell550> yes
07:28:12 <ski> your choice
07:28:17 <ertes> haskell550: Lpaste.net
07:28:25 <ski> i'd say, make it public, unless there's a pressing reason not to
07:28:27 <haskell550> title is Langs
07:28:29 <ertes> just in case you ended up somewhere else =)
07:28:33 <haskell550> public 
07:29:20 <ertes> haskell550: private means that it won't be listed in the latest pastes‚Ä¶  but one can still find it through search engines
07:29:29 <ertes> so it's not that much of a difference
07:29:34 <ski> haskell550 : better would have been to say the link <http://lpaste.net/160939> here in the channel .. or to specify #haskell as the channel, and then the lpaste bot would have announced it automatically in here :)
07:29:50 <haskell550> ahh ok
07:29:53 <ertes> ski: for some reason the latter doesn't work for me
07:29:55 <haskell550> very new to this
07:30:09 <ski> ertes : hm, some temporary problem ?
07:30:19 <ertes> ski: has been that way for years
07:30:42 <ertes> maybe the bot doesn't like my √ºml√§√ºts
07:30:44 <haskell550> Couldn't match type ‚ÄòChar‚Äô with ‚Äò[Char]‚Äô
07:30:59 <haskell550> Expected type: [String]
07:31:00 <ski> haskell550 : anyway, now please _Annotate_ (use the "Annotate" button) that paste with the definition of `HexTurn', so we don't have to hunt above in the backlog to refer to it
07:31:11 <haskell550> ok
07:31:33 <ski> (better would have been to include it from the start. but annotating, or editing, works)
07:32:49 <dmwit> If you know some details about GHC's GC, there's a very well-formulated question over on SO right now. http://stackoverflow.com/q/36772017/791604
07:33:00 <ski> haskell550 : as you (hopefully) noticed now, when annotating, you only need to add the new stuff, since the old is still visible at the same page
07:33:11 <haskell550> Sure I picked that up
07:33:47 <haskell550> https://en.wikipedia.org/wiki/Langton%27s_ant this is what this is
07:33:59 <ski> `mapElem' looks wrong
07:34:24 <ski> well, even a type error, i think
07:34:34 <ertes> i try not to be active on SO
07:34:44 <haskell550> Just added the correct code I wrote for squareWorld
07:34:45 <ertes> i tend to get addicted to online multiplayer RPGs
07:34:56 <ski> also, i don't think it's a good idea to have  hxList  always give something of the form `Just ...'
07:34:59 <haskell550> ie every cell is square like on the wikipedia page
07:35:28 <haskell550> I'm trying to use the code I know already works for a square situation to adapt for a hexagonal world
07:35:52 <ski> haskell550 : when annotating, please don't repeat what's already visible on the page, unless it's needed for a better understanding of (the context of) the new stuff
07:35:54 <ackthet> ertes: doesn't look like much exists so i'll just do a quick and dirty data type
07:36:13 <haskell550> ok
07:36:28 <ski> haskell550 : in the square situation, every move takes exactly one `Char'. so that's easier
07:36:40 <haskell550> yes exactly
07:36:45 <haskell550> map works for that
07:37:04 <haskell550> I feel like I need to use elem and recurse over the string
07:37:12 <haskell550> but can't figure out how to do it
07:37:26 <ski> haskell550 : still, i'd say `readSquareTransition' is also incorrect, because it *ignores* any `Char's it doesn't recognize, instead of aborting the parsing, barfing a `Nothing' result
07:37:27 <ertes> ackthet: is that for a monte-carlo algorithm, or do you need the actual error?  and do you need any statistical error measure?  if you just assume uniform distribution (usually a bad choice), then interval arithmetic may be enough
07:37:52 <haskell550> sure but the only entries will be R or L for that
07:37:59 <ski> (presumably the point of using `Maybe' in the first place is to be able to use `Nothing' in case of parse failure. then why don't do that ?)
07:38:01 <haskell550> the input is LRLRLLLRLRLRLR or something similar
07:38:05 <orion> I don't use C code from within my cabal package, but I depend on a package which does (cryptonite). Cryptonite is compiled with "-optc-O3" by default. Do I also need to specify "-optc-O3" to gain the performance advantage?
07:38:11 <haskell550> so never any other letters to worry about
07:38:22 <ertes> orion: no
07:38:32 <ski> if the input is `LRLER', i expect a `Nothing' result, not a `Just [L,R,L,R]' result
07:38:50 <haskell550> Sure that's what you
07:38:54 <haskell550> you'd get
07:39:03 <dcoutts> orion: right, no, because the C code is linked into the Haskell package, so it's already object code by the time you use it in your package.
07:39:17 <ski> haskell550 : if you *know* the input has just `L's and `R's, then i'd say don't bother with `Maybe' at all, just have `readSquareTransition :: String -> [SquareTurn]'
07:39:18 <haskell550> But when this is run it takes L and R, representing turns
07:39:29 <orion> dcoutts / ertes: I see.
07:39:41 <ski> <haskell550> I feel like I need to use elem and recurse over the string
07:39:53 <ski> `elem' is the wrong idea. explicit recursion can be a good idea
07:40:18 <haskell550> sure elem doesn't help me so far, because bool is not good for me to work with
07:40:22 <orion> It makes no sense to specify "-rtsopts -with-rtsopts=-N" with a library, right?
07:40:38 <ski> @let data SquareTurn = L | R deriving (Eq,Ord,Show)
07:40:40 <lambdabot>  Defined.
07:41:00 <haskell550> sure that's the def for squareTurn
07:41:34 <ski> @let readSquareTransition :: String -> Maybe [SquareTurn]; readSquareTransition str = sqList where sqList = Just(catMaybes sqList'); sqList' = map mapChar str; mapChar :: Char -> Maybe SquareTurn; mapChar char = case char of 'L' -> Just L; 'R' -> Just R; _ -> Nothing
07:41:35 <lambdabot>  Defined.
07:41:45 <ski> > readSquareTransition "LRLER"
07:41:47 <lambdabot>  Just [L,R,L,R]
07:42:22 <l4m8d4> sorry, my network just went down, so I maybe missed a few messages (couldn't reach my bouncer)
07:42:25 <ski> haskell550 : so "<haskell550> Sure that's what you","<haskell550> you'd get" is incorrect. i expected `Nothing', but got `Just [L,R,L,R]' instead here
07:43:13 <ski> l4m8d4 : check the ending of <http://tunes.org/~nef/logs/haskell/16.04.21>
07:44:12 <l4m8d4> ski: not sure if "take 5 (filter (< 10) [1,3 ..])" is representative for what I meant, I was just interested in how recursion was being dealt with in haskell.
07:44:16 <l4m8d4> Take for exampe
07:44:57 <l4m8d4> *Take for example, a function that does nothing but recurse indefinitely, not declare or do anything else. Would it just run without terminating or would it crash after a while?
07:44:57 <ski> haskell550 : anyway, my suggestion is to first work out how to make `readSquareTransition' correct/better or how you want to phrase it, and then resume thinking about `readHexTransition'
07:45:04 <Sornaensis> > ("Hello","World") & _2 %~ (++ "!")
07:45:05 <lambdabot>  ("Hello","World!")
07:45:38 <haskell550> The thing is that readSquareTransition is working right now.  
07:45:48 <ski> > let x = x in x  -- l4m8d4, this would run indefinitely, in bounded space, if lambdabot didn't add a timeout to the evaluation/reduction
07:45:51 <ski> @help run
07:45:52 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
07:45:52 <lambdabot>  mueval-core: Time limit exceeded
07:46:21 <haskell550> But the way to recurse through the string search for matching two character sets is eluding me
07:46:29 <ski> haskell550 : "readSquareTransition is working right now" -- i don't think so. i don't think `readSquareTransition "LRLER"' giving `Just [L,R,L,R]' is it working
07:46:45 <haskell550> let me try it on my machine
07:47:09 <ski> haskell550 : the point is that you're not using the `Maybe' in `readSquareTransition :: String -> Maybe [SquareTurn]' in any interesting/nontrivial way. you always return `Just ...', never `Nothing'
07:47:32 <ski> haskell550 : and you need to learn how to do this, in order to make `readHexTransition' happen
07:47:41 <l4m8d4> ski: Ok, that pretty much answers my question then, thanks!
07:48:09 <haskell550> when I run it I get "Non-exhaustive pattenr in case"
07:48:20 <ski> l4m8d4 : but note that `x' there is tail-recursive, which is why it can run in bounded space (well, bounded stack space, but in this case it's also running in bounded heap space)
07:48:35 <haskell550> So it doesn't let me run the program with LRLREL or anything with letters other than L or R
07:48:46 <haskell550> the code for this program is 5 pages long in total
07:49:04 <haskell550> this is just one section of it at the very end
07:49:57 <Sornaensis> ohhhh ok you can use lenses for huge tuples
07:50:02 <ski> l4m8d4 : anyway, please make sure whether you've seen all the messages we sent to you, from about half an hour ago. perhaps also check to see whether you attempted to send any more message, but which didn't make it through to the network (and thus us)
07:50:08 <Sornaensis> > (1,2,"Bums",True) ^. _3
07:50:10 <lambdabot>  "Bums"
07:50:13 <Sornaensis> hueee
07:50:30 <ski> haskell550 : "Non-exhaustive pattenr in case" -- ok, so you're not running exactly the same code as in the paste then
07:50:41 <ski> (since i entered that code verbatim into lambdabot)
07:50:54 <haskell550> The last part of it
07:51:13 <ski> yes, i'm only talking about the part needed to run `readSquareTransition' here
07:51:14 <haskell550> the part that only takes L R and _
07:51:32 <haskell550> yes me too, re: LRLER
07:51:51 <haskell550> That part of the code is functioning well
07:52:02 <haskell550> the part for hexTurn is not
07:53:04 <ski> l4m8d4 : anyway, one nice thing about non-strictness in Haskell is that you can generate an infinite list, or an infinite tree (e.g. a tree of all positions/states in some kind of game), and then only the part of that data structure that you explore/demand will actually be evaluated/computed/reduced. this means that you don't have to tell upfront how many elements, or to which depth in the tree, you (possibly) need
07:53:29 <ski> haskell550 : if you evaluate `readSquareTransition "LRLER"', what do you get as an answer ?
07:53:56 <haskell550> Non-exhaustive pattern in case
07:54:16 <ski> l4m8d4 : also, the actual recursion won't happen immediately, but only later, when the consumer of the output from the function demands to see more of the non-strictly computed result
07:54:20 <haskell550> If I run LRLR I get a large multicoloured pattern that is created by the "ant"
07:54:35 <ski> haskell550 : and how is that "That part of the code is functioning well" ?
07:55:04 <ski> getting the program aborted doesn't seem to be functioning well to me
07:55:26 <haskell550> Because this is a program to run an ant to create a pattern, when something other than L or R turns are added to the transition list, it will not run. otherwise it will run correctly
07:55:51 <ski> .. *if* you know that the input will be well-formed (only have `L's and `R's), *then* it's "functioning well" -- but in *that* case, you shouldn't use `Maybe' in `readSquareTransition :: String -> Maybe [SquareTurn]' to begin with
07:55:54 <haskell550> for sqaureTurn it is complete, for HexTurn it is not complete
07:56:13 <jophish> c_wraith: thanks, although I think I might go with: let traverseFirst f = bitraverse f pure in sequence (traverseFirst foo <$> p)
07:56:22 <haskell550> I didn't write maybe into it
07:56:35 <ski> you didn't write the code for `readSquareTransition' ?
07:56:55 <haskell550> It is a test to see if we can use the existing barebones structure and finish the rest of the code
07:56:59 <l4m8d4> ski: I've already made use of that property a few times. Creating infinite lists is quite interesting if you're new to haskell, but one gets used to it :D
07:57:05 <jophish> (with traverseFirst put somewhere more sensible)
07:57:05 <ertes> l4m8d4: when writing haskell code it's really important to look with special attention at the *use* site of a definition, i.e. the consumer‚Ä¶  recursion works a bit differently in haskell
07:57:20 <haskell550> having Maybe HexTurn is part of the challenge
07:57:21 <ski> l4m8d4 : ok. i wasn't sure how familiar with Haskell you were :)
07:57:47 <ertes> l4m8d4: in fact with GHC haskell the reason why tail-calls don't cause any stack blowup is not due to an optimisation (in most other languages it would be)
07:58:42 <ski> haskell550 : anyway, i'm telling you that to do `readHexTransition', you probably need to use `Maybe' in a non-trivial way. so, then why not also use it in a similar non-trivial way for `readSquareTransition', to begin with ?
07:58:50 <ertes> l4m8d4: try compiling this program:  main = let x = x in x
07:59:00 <ertes> l4m8d4: you will find that it dies with an error instantly
07:59:06 <ski> haskell550 : .. otherwise, there's still no point in using `Maybe'
07:59:28 <haskell550> That makes sense
07:59:44 <haskell550> If I don't use Maybe though, I will fail this challenge
07:59:52 <haskell550> it's a part of the challenege
07:59:55 <ski> then use `Maybe' ?
08:00:06 <monochrom> I hate to ask: use Maybe for what?
08:00:11 <ski> preferably for both `readSquareTransition' and `readHexTransition'
08:00:24 <ski> monochrom : expressing failure of parsing, presumably
08:00:34 <monochrom> no no, what does Nothing stand for? when should you return Nothing?
08:00:40 <ski> (i don't see what else it could be usefully used for here)
08:00:54 <haskell550> If you have a data type which might output the data type or could output Nothing
08:00:58 <ertes> l4m8d4: you may find it interesting that no call stack is used‚Ä¶  function application in haskell is not a stack operation
08:00:59 * ski will let haskell550 answer that question
08:01:01 <jophish> dmwit: interesting question, perhaps worth posting in #ghc
08:01:07 <monochrom> if you don't know, then you're only speaking at the level of "there is a challenge that I have to spend $100". spend $100 to buy what?
08:01:52 <ski> haskell550 : .. yes, but in the context of this specific problem ?
08:03:01 <haskell550> In the context of this specific problem I am not required to change the code not to include Maybe.  Even though I can 100% see how what you're saying makes sense
08:03:25 <haskell550> Not only do I not have to change maybe, but if I do I will fail the test that i am trying to complete
08:03:52 <haskell550> So that's why even though what you're saying is very accurate, it's not very relevant
08:03:56 * ski specifically did not talk in terms of "tail *calls*" (nor "tail call *optimization") above :)
08:05:09 <ski> haskell550 : ok, but what about the behaviour of `readSquareTransition' ? is it specified what should happen when there's a `Char' that's neither `L' nor `R'
08:05:20 <ski> ?
08:10:25 <ski> haskell550 : also, i'd like an answer to monochrom's question
08:12:57 <ertes> ski: you did say "call" somewhere =)
08:13:12 <ertes> <ski> function calls in themselves are pretty cheap
08:14:42 <ertes> ski: however, i wasn't really referring to you‚Ä¶  personally i found it quite interesting when i first learned that GHC compiles to something very different from what a C compiler would produce, so i thought maybe l4m8d4 would find that interesting, too
08:15:20 <ertes> ("C compiler" really representing "most compilers for most other languages")
08:18:24 <dmwit> jophish: good idea
08:18:34 <ski> ertes : yes :)
08:20:06 <ski> the key observation is that in a Felleisen context, there's no `M E[]' frame in Haskell, only an `E[] M' one
08:20:29 <ski> (and, of course, a `case E[] of ...' one)
08:35:44 * hackagebot file-embed 0.0.10 - Use Template Haskell to embed file contents directly.  https://hackage.haskell.org/package/file-embed-0.0.10 (MichaelSnoyman)
08:39:27 <Fapulent> How true is it that Haskell is easier if you have no prior experience with another PL?
08:39:27 <Fapulent> How true is it that Haskell is easier if you have no prior experience with another PL?
08:40:30 <orion> Fapulent: About 12.5 true.
08:40:44 <peddie> Fapulent: kind of hard to measure since everyone can only start with one . . .
08:40:50 <hpc> imo there's definitely an uncanny valley where you learn one language, internalize it being THE WAY(tm), then having that shattered by another language
08:41:07 <hpc> haskell is different enough from the usual suspects that this gets magnified a bit
08:41:27 <hpc> having multiple languages under your belt helps, as does not having rigid misconceptions
08:41:51 <orion> hpc: Wrong. Haskell is The Way, The Truth, and The Life.
08:42:01 <JuanDaugherty> Fapulent, u mean for ordinary humongs or wat?
08:42:58 <JuanDaugherty> if you could grok category theory at 12 learning programming with haskell will be a breeze
08:43:38 <Fapulent> L
08:45:24 <JuanDaugherty> otherwise there are copious resources, and I recommend lyah, rwh, and craft of fp.
08:46:09 <Fapulent> When people say learning Haskell will be hard if you have already learned another PL, they usually mention languages like C, Java, Python and such. What about someone who uses Scheme, though? How do they fare in general?
08:46:36 <JuanDaugherty> you'll be in a better position coming from a lisp
08:46:36 <ski> it will be simpler, probably
08:46:37 <Sornaensis> if you're familiar with FP concepts then learning haskell shouldn't have too much a learning curve
08:46:45 <Sornaensis> the type system is really the hard bits
08:46:46 <ski> e.g. if you've tackled SICP
08:47:06 <ski> @where SICP
08:47:06 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
08:47:12 <ski> (not the last one)
08:47:22 <geppettodivacin> ertes, ski: Why does `main = let x in x` exit with << loop >>, but not something like this: http://lpaste.net/160945
08:47:33 <Sornaensis> @ Fapulent ==> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
08:47:56 <Sornaensis> pretty good haskell course for someone who is familiar with FP, REPLs, and whatnot
08:49:26 <hpc> geppettodivacin: when you execute main with ghc, the following happens
08:49:30 <hpc> the program starts
08:49:33 <hpc> we skip a few steps
08:49:38 <hpc> it begins evaluating x
08:49:51 <hpc> here, ghc modifies the thunk for x so it points to a "black hole"
08:50:00 <hpc> because you're running it single-threaded
08:50:05 <hpc> evaluating x requires first evaluating x
08:50:12 <hpc> so we begin evaluating x, which is a black hole
08:50:21 <hpc> which makes it print <<loop>> and exits
08:51:07 <hpc> when you do the same with f/g, the thunks from each bounce back and forth aren't shared
08:51:29 <hpc> so there's never a thunk pointing back on itself and it never blackholes
08:51:38 <ski> @where CIS194
08:51:38 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
08:51:57 <chelfi> Fapulent: I started with ocaml, which is quite close laziness aside to haskell, and it was the most natural thing in the world
08:52:00 <hpc> geppettodivacin: this is all fairly operational details, so don't worry if you don't understand all of it
08:52:28 <chelfi> then I learnt c which made me sad and confused
08:52:31 <hpc> geppettodivacin: a relatively safe lie that's easier to understand is "it just does"
08:52:55 <hpc> geppettodivacin: which you can work with until you have the understanding of ghc's operational model to make sense of it
08:53:08 <ski> chelfi : did you have some proficiency with solving equations, simplifying&rewriting expressions, algebra ?
08:53:18 <chelfi> i then came back to haskell and was wary because c somehow became "the way it actually works"
08:53:47 <chelfi> i had troubles wrapping my head around laziness but apart from that it all fit together again
08:53:57 <simpson> Learn Forth.
08:54:00 <chelfi> ski: yes
08:54:07 <simpson> It might not be practical, but it will bend your mind into new shapes.
08:54:25 <hpc> chelfi: there's a point of view where that's actually correct, but it involves some conflation of software and state machines
08:54:54 <hpc> which... it is, but only at the lowest level
08:56:01 <chelfi> indeed, and I love that I do not have to care most of the time (though of course at some point you need to care, and then you need to get dirty)
08:56:40 <Welkin> simpson: May the Forth
08:56:59 <chelfi> simpson: are you talking about concatenative languages in general ? or specifically forth ?
08:57:34 <geppettodivacin> hpc: I know it's not super necessary to know the operational details, but it's certainly interesting!
08:58:01 <geppettodivacin> I did a bit more testing on infinite looping functions and got some interesting test results. http://lpaste.net/160945
08:58:35 <geppettodivacin> Does <<loop>> have something to do with being able to reduce the infinite loop to whnf?
08:58:38 <hpc> geppettodivacin: agreed, and that's not even the most interesting part of ghc! the garbage collection algorithm is arguably the best in the world
08:58:51 <hpc> geppettodivacin: yes
08:59:08 <hpc> geppettodivacin: when a thunk requires evaluating itself in order to evaluate itself, that's a form of bottom
08:59:31 <hpc> and just turns out to be an easily catchable one
09:00:08 <hpc> with the threaded runtime, the blackhole works differently because the program flow can continue elsewhere
09:00:23 <geppettodivacin> hpc: But when, for example, f x has to evaluate f x, it doesn't actually evaluate it because it isn't required to be strict yet?
09:01:26 <hpc> evaluating (f x) will evaluate f, insert x into the function body, then evaluate that
09:02:38 <ski> geppettodivacin : better to say "aborts with <<loop>>", rather than "crashes with <<loop>>"
09:02:39 <hpc> (at least it does at a certain conceptual level between denotation and operation)
09:02:52 <geppettodivacin> Mm, good point.
09:03:41 <hpc> for the logic of why something gets evaluated, you really want to look at the haskell spec
09:03:48 <hpc> er, haskell report
09:04:02 <ski> `f x = f x' unsugars to `f = \x -> f x'. so `f 0' becomes `(\x -> f x) 0', which then becomes `f 0' again
09:04:11 <hpc> it's completely denotational, so it'll mainly be telling you what happens when things are bottom
09:04:25 <geppettodivacin> So, to clarify, the ghc runtime evaluates every function to whnf first, then inserts the arguments in and evaluates that to whnf until no more substitutions can be made?
09:04:54 <hpc> geppettodivacin: once the body is whnf there's no more evaluation to do, at that point
09:05:13 <hpc> or well
09:05:22 <hpc> evaluation happens from a point of reference
09:05:39 <hpc> because haskell is non-strict, so if you don't have some initiating evaluation nothing ever happens
09:05:54 <hpc> usually the point of reference is "evaluate this expression to whnf"
09:06:10 <hpc> so it
09:06:12 <hpc> so it's
09:06:22 <hpc> "the ghc runtime evaluates every function to whnf first, then inserts the arguments in and evaluates that to whnf" minus the rest
09:06:43 <hpc> when evaluating (f x) to whnf
09:06:54 <hpc> er, and also s/arguments/argument
09:07:45 <geppettodivacin> Because it inserts the arguments in one at a time because currying?
09:07:55 <hpc> rephrasing one more time, "when evaluating (f x) to whnf, the ghc rts evaluates f to whnf, substitutes x into the body, then evaluates the body to whnf"
09:07:59 <hpc> yeah
09:08:41 <geppettodivacin> That actually makes how Haskell programs work make a lot more sense.
09:08:56 <geppettodivacin> Thanks, hpc!
09:10:55 <ski> `(e e0) => v1' if `e => (\x0 -> e1)' and `e1[x0 |-> e0] => v1'
09:11:06 <ski> (big-step operational semantics)
09:11:40 <hpc> geppettodivacin: i don't do any ghc development and haven't looked at very much of its code whatsoever, but i pay attention to the conversations here and pick stuff up
09:12:02 <hpc> geppettodivacin: so there might be some errors in what i said, but nobody has corrected me yet so it's probably good enough for a rough mental model ;)
09:12:45 <l4m8d4> in haskell, is a do block considered a function?
09:13:02 <ski> l4m8d4 : no, functions always take an argument
09:13:08 <hpc> just keep hanging out and asking questions and programming on your own, and things will gradually make more sense
09:13:21 <Boomerang> a do block is just syntactic sugar
09:13:23 <hpc> l4m8d4: the desugar for do-notation is defined in the haskell report
09:13:32 <ski> (except that it's possible for `do ...' to have a function type, if you're have an instance `Monad (rho ->)', for some type `rho' ..)
09:13:36 <hpc> and it's very direct
09:13:50 <l4m8d4> ok, thanks
09:14:04 <hpc> l4m8d4: i recommend reading that bit and playing around with @undo in a private query with lambdabot
09:14:16 <ski> @undo do putStrLn "Name :"; name <- getLine; putStrLn ("Hello " ++ name)
09:14:16 <lambdabot> putStrLn "Name :" >> getLine >>= \ name -> putStrLn ("Hello " ++ name)
09:14:19 <hpc> @undo do {x; v <- y; z}
09:14:19 <lambdabot> x >> y >>= \ v -> z
09:14:23 <hpc> heh
09:14:43 <l4m8d4> my weechat is broken, I have to restart...
09:16:01 <ski> re l4m8d4
09:16:14 <l4m8d4> well, I have ghci installed, so what would be the benefit of lambdabot?
09:16:22 <l4m8d4> btw, he obviously stole my name :D
09:16:43 <ski> lambdabot doesn't have `undo'
09:16:58 <hpc> doesn't?
09:16:59 <ski> (well, i think you can add it in some way. but it's not there by default)
09:17:11 <hpc> oh
09:17:15 <ski> er.. *GHCi* doesn't have `undo'
09:17:17 <ski> sorry
09:17:44 <hpc> lambdabot has stuff like undo which will do things ghci can't
09:17:52 <hpc> there's actually quite a bit there
09:17:56 <hpc> @hoogle Word32
09:17:58 <lambdabot> Data.Word data Word32
09:17:58 <lambdabot> Data.ByteString.Builder.Prim word32BE :: FixedPrim Word32
09:17:58 <lambdabot> Data.ByteString.Builder word32BE :: Word32 -> Builder
09:18:07 <Welkin> @undo do { a <- ma; putstrLn a }
09:18:07 <lambdabot> ma >>= \ a -> putstrLn a
09:18:09 <Welkin> :D
09:18:22 <hpc> @djinn ((a -> a) -> a) -> (a -> a) -> a
09:18:23 <lambdabot> f a = a
09:18:27 <ski> @unmtl StateT s (ContT o (ReaderT r [])) a
09:18:27 <lambdabot> s -> (a -> s -> r -> [] o) -> r -> [] o
09:18:31 <hpc> oh right, that's id
09:18:58 <GLM> Is there a way to compose a function that takes multiple arguments with another that takes one in a point free style?
09:19:07 <ski> @djinn ((a -> o) -> o) -> (a -> (b -> o) -> o) -> ((b -> o) -> o)
09:19:07 <lambdabot> f a b c = a (\ d -> b d c)
09:19:17 <ski> @djinn ((a -> o) -> a) -> (a -> (b -> o) -> b) -> ((b -> o) -> b)
09:19:17 <lambdabot> f a b c = b (a (\ d -> c (b d c))) c
09:19:20 <rayner> hi guys, I'm trying to create a html select using Hamlet, the options are generated dynamically just ok but I need to set one of them selected based on some computation, so far I tried setting the tag property with #{myComputation} but it doesnt work
09:19:21 <hpc> @pl \x y z -> g x (f y z)
09:19:22 <lambdabot> (. f) . (.) . g
09:19:34 <hpc> GLM: in a word, yes
09:19:35 <Zemyla> @pl \f g x y -> g(f x y)
09:19:36 <lambdabot> flip ((.) . (.))
09:19:38 <hpc> GLM: in a different word, don't
09:19:39 <l4m8d4> would you consider it a good thing for a professor do to IO before teaching monads? because our professor just did that
09:19:43 <magneticduck1> GLM: hayoo search for the type signature you want
09:19:48 <l4m8d4> *to do
09:19:54 <Zemyla> :t (.).(.)
09:19:55 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:19:59 <magneticduck1> there are several libraries providing more PL fanciness than anybody could possibly need
09:20:08 <ski> GLM : you can define `(.:) = (.) . (.); (.::) = (.) . (.) . (.)' and so on, and say `(f .: g) x y',`(f .:: g) x y z',&c. ..
09:20:10 <magneticduck1> uh, s/PL/PF
09:20:13 <GLM> hpc: That's about what I figured
09:20:36 <GLM> ski: Is that in a library? I think I've seen it before
09:20:46 <Zemyla> l4m8d4: Real World Haskell does it that way too.
09:20:53 <l4m8d4> also he was like "in haskell, there are nearly no sideeffects - lets do IO" :D
09:21:02 <conal> GLM: there's a general pattern called "semantic editor combinators" that applies to your question and goes further. See http://conal.net/blog/posts/semantic-editor-combinators
09:21:12 <hpc> l4m8d4: IO does all its effects front and center
09:21:12 <Zemyla> @pl \f g x y z -> f x (g y z)
09:21:12 <lambdabot> flip . (((.) . (.)) .)
09:21:19 <hpc> ;)
09:21:41 <ski> GLM : i invented it years ago (quite possibly some others may also have invented it, sans the names), but i don't think there's a "standard" package with them
09:22:08 <ski> @where SEC
09:22:08 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
09:22:09 <ski> (:
09:22:31 <shachaf> conal: Well, there's lens.
09:22:38 <hpc> SECs are cool but i have never felt the need to use them
09:22:42 <conal> shachaf: indeed there is.
09:22:45 <ski> l4m8d4 : there are no side-effects
09:22:53 <l4m8d4> hpc: Well, I think it's easy to use but it would be nice sometimes to really understand what's behind all that.
09:22:55 <hpc> i also have some weird opinions on where haskell falls on the functional <-> imperative spectrum though :P
09:23:04 <simpson> chelfi: Specifically ANS FORTH. You can learn Factor, but the zen of FORTH is something magical in and of itself, and the Factor compiler takes away some of the fun.
09:23:18 <GLM> If I had that composition saved as .:, is there any reason I shouldn't use it?
09:23:21 <hpc> l4m8d4: the IO type represents an ideal abstract depiction of effects
09:23:30 <GLM> seems clearer than explicit varables
09:23:55 <hpc> l4m8d4: so like, (putStrLn "blah") doesn't actually print anything, but its value is a representation of printing things
09:24:03 <ski> @quote world's.best
09:24:03 <lambdabot> SPJ says: Haskell is the world's best imperative language.
09:24:05 <shachaf> conal: lens makes a lot more sense when you think of it from the SEC perspective, just adding an f.
09:24:06 <hpc> l4m8d4: (at a certain conceptual level anyway - the implementation is much stranger)
09:24:15 <hpc> ski: oh hey, my opinion isn't so weird after all
09:24:23 <conal> shachaf: it does to me as well.
09:24:27 <ski> simpson : which part of the fun ?
09:24:30 <hpc> l4m8d4: so, where execution happens, and where things really get printed
09:24:42 <hpc> l4m8d4: something has to begin the execution, and that thing is outside the program definition
09:25:08 <hpc> l4m8d4: it says "execute main", which evaluates main until it has something to do, then it does it, then it moves on by way of (>>=)
09:25:08 <ski> GLM : overuse of pointless style makes code harder to read
09:25:21 <hpc> l4m8d4: and that's the monadic API to IO
09:25:30 <simpson> ski: The part of the fun where you have to actually think about data manipulation rather than just constantly use higher-order functions.
09:26:04 <hpc> l4m8d4: there's various non-abstract representations of subsets of IO that you can write or look up, which are a good picture into just how much nothing an IO value actually does
09:26:13 <shachaf> conal: For example people complain about the composition being "backward", because they think of a lens as a jammed up getter function. But "mapX (mapY f) x" = "(mapX . mapY) f x" makes perfect intuitive sense.
09:26:19 <hpc> l4m8d4: there's one in particular, let's see if i can find it
09:26:37 <ski> simpson : by "think about data manipulation", do you mean stack juggling in your head ?
09:27:11 <hpc> l4m8d4: i think this is it: https://lukepalmer.wordpress.com/2008/03/29/io-monad-the-continuation-presentation/
09:27:42 <ski> shachaf : yes, you "focus" on different parts of the structure. possibly "virtual" structure
09:27:59 <hpc> l4m8d4: it defines IO as an ADT, and then the RTS would be a machine that traverses that ADT and produces execution of some sort
09:27:59 <simpson> ski: Stack juggling, VARIABLE management, etc. A well-written FORTH program, besides yelling constantly at you, composes neatly and is fully purpose-built. It is a pleasant vacation from the abstractions of modern programming, even if you are not a microcontroller person.
09:28:19 <GLM> ski: I agree but I'm so used to weird functions from other frameworks that it doesn't bother me anymore
09:29:02 <l4m8d4> hpc: ski: Ok, I think I have just opened discussion to an issue that I don't really want to discuss in depth, since I am just beginning to learn haskell :D But our professor was of the opinion that '<-' was violating the referential transparency
09:29:20 <Welkin> l4m8d4: no
09:29:28 <Welkin> there is no violation of referential transparency
09:29:40 <ski> simpson : "yelling" ?
09:29:42 <l4m8d4> ok, I guess I should tell him then :D
09:30:19 <Welkin> `a <- ma` is just ` ma >>= /a -> ...`
09:30:32 <Welkin> er
09:30:35 <Welkin> `a <- ma` is just ` ma >>= \a -> ...`
09:32:21 <simpson> ski: Proper ANS FORTH isn't "dup rot drop" but "DUP ROT DROP".
09:32:46 <hpc> SELECT * FROM WP_USERS WHERE ID=?
09:33:04 <hpc> COME FROM 20
09:33:07 <Welkin> wordpress, lol
09:33:15 <hpc> i couldn't resist
09:33:19 <Welkin> bobby tables
09:35:46 * hackagebot shelly 1.6.6 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.6 (GregWeber)
09:36:15 <ski> simpson, ok
09:37:51 <ski> l4m8d4 : a construction (a *context*) being referential transparent means roughly that you can "replace equals for equals" in (the hole of) that construction (/context). e.g. if you have defined `act = putStrLn "hello"', then `do act; act' means the same as `do putStrLn "hello"; putStrLn "hello"', means the same as e.g. `do act; putStrLn "hello"'
09:40:43 <ski> l4m8d4 : of course, in a context of `do s <- getLine; ..s..', where `..s..' is (or contains) `do foo s; foo s', you can't replace that subexpression with `do foo =<< getLine; foo =<< getLine', without changing behaviour .. but `<-' is not `='. and i even had to insert `=<<'s in order to make it type-check, `do foo getLine; foo getLine' would have been a type error
09:43:55 <ski> l4m8d4 : the typing difference between `s' and `getLine' here is part of the reason we can get away with this. we're *explicitly* expressing *effects* as part of the result of evaluating `getLine', as opposed to *implicitly* expressing *side*-effects as something that's different from the value you get by evaluating say `gets(buf)' (which you should btw never use anyway) in C
09:44:51 <acertain> how do I convince ghc that KnownNat n implies KnownNat (n + 1)?
09:46:01 <Zemyla> acertain: You can't, because n might be 0.
09:46:14 <Zemyla> Oh, that's a plus, not a minus.
09:46:20 <Zemyla> Small screens.
09:47:33 * ski idly wonders what `KnownNat' is
09:47:50 <acertain> from GHC.TypeLits
09:50:08 <Lovepon> Guys.
09:50:18 <Lovepon> How do I save cookies in ghcjs?
09:51:17 * hackagebot yesod-auth-hashdb 1.5 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.5 (paulrouse)
09:53:29 <mfng> Hi guys, I've got a question.
09:53:40 <mfng> In MaybeT,
09:53:49 <galaxycat> [B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B/channel #test
09:53:55 <mfng> in this line "x >>= f = MaybeT $ do maybe_value <- runMaybeT x"
09:54:09 <maerwald> another irssi user...
09:54:21 <mfng> How "<-" extracts the maybe_value from runMaybeT x?
09:54:29 <mfng> shouldn't both sides be the same?
09:56:12 <Lovepon> I see.
09:56:21 <Lovepon> I think I misunderstood some things.
09:56:24 <Cale> mfng: We're presumably writing  instance Monad m => Monad (MaybeT m)
09:56:38 <Cale> mfng: Here, the do-block is an m-action
09:56:51 <mfng> ok
09:56:57 <hpc> @src MaybeT
09:56:58 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:57:11 <Cale> mfng: and maybe_value <- runMaybeT x  means to execute the m-action (runMaybeT x), and name its result maybe_value
09:58:19 <Lovepon> amigojapan_: I didn't know you also stay here.
09:58:41 <mfng> <Cale> I guess I understood now.
09:58:46 <mfng> <Cale> Thank you.
09:58:56 <amigojapan_> Lovepon: well, I am just here in hope something will stick, haskell has been the only language I have ever found hard to learn
09:59:13 <Cale> amigojapan_: Make sure to ask questions :)
09:59:28 <maerwald> I found Prolog harder :P
09:59:29 <Lovepon> amigojapan_: Haha. It's okay, it took me 3 tries. ;)
09:59:30 <amigojapan_> Cale: ok, but not now, about ot go to sleep
10:00:22 <Welkin> amigojapan_: mexican in japan?
10:00:32 <amigojapan_> yep Welkin 
10:06:17 * hackagebot native 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/native-0.1.0.0 (darwin226)
10:11:11 <orion> Does anyone familiar with criterion know how to use the "--raw" output files?
10:11:32 <orion> I run "criterion analyse foo.raw" and it doesn't seem to do much.
10:20:10 <thoughtpolice> orion: That program doesn't do much (and frankly probably shouldn't be installed until it does). See the source here: https://github.com/bos/criterion/tree/master/app
10:20:17 * hackagebot yesod-auth-hashdb 1.5 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.5 (paulrouse)
10:20:17 * hackagebot native 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/native-0.1.0.0 (darwin226)
10:20:21 <thoughtpolice> orion: That program doesn't do much (and frankly probably shouldn't be installed until it does). See the source here: https://github.com/bos/criterion/tree/master/app
10:23:21 <acertain> how do I convince GHC that `CmpNat 0 (n + 1) ~ LT`?
10:25:11 * hackagebot native 0.1.0.1 - Native library manager for Windows  https://hackage.haskell.org/package/native-0.1.0.1 (darwin226)
10:27:52 <orion> thoughtpolice: Ah, so the "--raw" option is sort of useless.
10:28:06 <thoughtpolice> At the moment, yeah. Might be some upstream issue about it, maybe.
10:29:23 <orion> I see, thanks.
10:30:12 <acertain> or how should I lie to GHC with that constraint?
10:49:59 <dmwit> acertain: Provide evidence that `n + 1 ~ 1 + n`.
10:50:51 <jpratt> ?src fromEnum
10:50:52 <lambdabot> Source not found. Where did you learn to type?
10:51:04 <dmwit> ?src fromEnum Bool
10:51:04 <lambdabot> Source not found. You speak an infinite deal of nothing.
10:51:04 <jpratt> ?src (+)
10:51:04 <lambdabot> Source not found. Do you think like you type?
10:51:28 <dmwit> Yeah, ?src isn't great with class methods. It has a few method implementations for a few types, but not everything.
10:51:35 <dmwit> ?src (>>=) []
10:51:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:51:39 <dmwit> ?src [] (>>=)
10:51:39 <lambdabot> xs >>= f = concatMap f xs
10:51:44 <dmwit> ?src Bool fromEnum
10:51:44 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:51:48 <dmwit> =/
10:51:52 <jpratt> ?src [] (+)
10:51:52 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:51:56 <jpratt> ?src [] (>>=)
10:51:57 <lambdabot> xs >>= f = concatMap f xs
10:52:11 <dmwit> I don't think there's a (standard) instance for `Num [a]`.
10:53:25 <dmwit> If the class/type you want to know about has recent haddocks associated, you can use that to find the implementations of methods.
10:53:38 <funrep> what category in the cabal file you use for a mandelbrot set program?
10:53:53 <funrep> is there a category for arbitrary applications?
10:54:15 <funrep> (yes i understand this doesn't really matter for a application as it do with a library)
10:54:17 <dmwit> There are several mandelbrot packages on Hackage; why not take a peek at what they chose?
10:54:23 <funrep> good idea!
10:54:33 <dmwit> http://hackage.haskell.org/packages/search?terms=mandelbrot
10:54:57 <funrep> graphics seems common
10:55:39 <jpratt> ?src [] (>>=)
10:55:39 <lambdabot> xs >>= f = concatMap f xs
11:01:25 <bblfish> is there an intutive way to understand how monads are related to algebras?
11:03:02 <ski> you should perhaps ask Cale that
11:03:28 <Cale> bblfish: I think it's best to understand this by looking at examples.
11:04:07 <Cale> bblfish: Are you familiar with vector spaces?
11:04:32 <bblfish> I think that's too long ago for the intuition still to be fresh
11:04:54 <Cale> bblfish: We can construct a monad T on Set whose algebras are exactly the vector spaces (over some chosen field)
11:05:10 <Cale> Or, similarly for monoids, groups, rings
11:05:50 <bblfish> I suppose I should start by getting an intution for what an algebra is . was looking at https://en.wikipedia.org/wiki/F-algebra
11:05:59 <Cale> oh
11:06:06 <Cale> F-algebras are more general
11:07:01 <Cale> It helps to really restrict your view to just T-algebras first (though if you're looking into recursion theory stuff, and want to understand initial F-algebras or something first, that's a fine approach)
11:07:01 <bblfish> I am pretty sure I am using algebras all the time, and have even used the word, but in order to undertsand the relation to monads, I probably need to be really solid on what they are.
11:07:15 <Cale> https://en.wikipedia.org/wiki/Monad_(category_theory)#Algebras_for_a_monad
11:07:39 <Cale> (Note how this definition is quite similar to the definition of an F-algebra, but it comes with some additional laws)
11:08:54 <bblfish> yes, but that's too abstract. What is a good example of an algebra I have used.
11:09:05 <bblfish> (or most of us have used)
11:09:32 <Cale> Perhaps monoids?
11:09:49 <Cale> Monoids are slightly boring in this regard, but are a good first example
11:09:50 <bblfish> ah yes. I suppose :-) I remember at school it was called algebra
11:10:23 <Cale> You probably haven't seen many examples of algebraic objects if you didn't go to school for mathematics specifically
11:10:33 <bblfish> ok. So I have a good grasp of Monoids now. 
11:11:15 <Cale> You're also perhaps familiar with how lists form a monad?
11:11:43 <bblfish> yes, that's easy. I was looking at how they form Functors the other day.
11:11:59 <bblfish> They are the monoid Monad I think :-)
11:12:17 <Cale> yeah
11:12:46 <bblfish> so I suppose concat on a list is a simple algebraic operation.
11:12:51 <Cale> So for any given monoid M, we have an algebra for [], which is a function  eval :: [M] -> M
11:13:18 <bblfish> ah ok, so it takes a structure and simplifies it
11:13:24 <Cale> which is going to simply multiply the elements together according the the monoid operation
11:13:33 <Cale> (i.e. it's what we call mconcat in Haskell)
11:13:47 <bblfish> I suppose that's why Lisp functions. 
11:14:02 <Cale> Lisp doesn't really take advantage of this much
11:14:18 <bblfish> You specify the type of list at the beginning and then you eval (+ 2 2)
11:14:43 <Cale> that's a different eval
11:14:54 <bblfish> ok, better not confuse things.
11:14:59 <Cale> The eval we're talking about just uses the monoid operation to multiply the elements of the list
11:15:15 * hackagebot streaming-commons 0.1.15.3 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.15.3 (MichaelSnoyman)
11:15:18 <Cale> (lisp's eval does arbitrary expression evaluation)
11:15:35 <bblfish> ok, so it's category specific evals here.
11:16:12 <Cale> Not even just category-specific, but it's part of the definition for an algebra for the monad
11:16:17 <Cale> https://en.wikipedia.org/wiki/Monad_(category_theory)#Algebras_for_a_monad
11:16:24 <Cale> It's the arrow h there
11:16:25 <bblfish> yes, was just reading that
11:17:30 <bblfish> so it looks like a flatten operation.
11:18:14 <Cale> Yes, in a sense
11:18:31 <bblfish> so each h, gives a different algebra?
11:19:08 <Cale> yeah
11:19:46 <Cale> We could finish checking that given a monoid, we really do get a []-algebra by defining h to be the function which multiplies out the list of elements of the monoid
11:20:01 <Cale> (by checking that the laws hold)
11:20:15 * hackagebot mutable-containers 0.3.2.1 - Abstactions and concrete implementations of mutable containers  https://hackage.haskell.org/package/mutable-containers-0.3.2.1 (MichaelSnoyman)
11:20:17 * hackagebot csv-table 0.1.0.1 - Scripts for manipulating tables stored as CSV files  https://hackage.haskell.org/package/csv-table-0.1.0.1 (ranjitjhala)
11:20:19 <Cale> Or, we could look at an arbitrary []-algebra, and see that it can be made into a monoid
11:20:46 <Cale> (with mempty = h [], and mappend x y = h [x,y])
11:21:26 <bblfish> ok, I suppose it was in some sense too obvious. I was thinking an algebra may be something really complex.
11:21:47 <bblfish> or perhaps this just gets at the core of what algebras are in a very clean way.
11:26:46 <bblfish> ok, so for a Free Monad this jumps up one level of abstraction I suppose. What I understood ( and the way I used it, is that one can then specify the evaluation of the fold later )
11:28:21 <hguant> i'm reading Allen and Morunuki's introduction to Haskell, and they declare pretty strongly to never use the 'Read' instance without an explaination - what's the reason for this?
11:30:00 <Cale> hguant: Uhhh, I disagree with that.
11:30:17 <Cale> hguant: Is there more context?
11:31:19 * bblfish trying to work my way to understanding Free Monads....
11:31:29 <Cale> hguant: There are various reasons why using the Read class might be inappropriate in various cases vs. using a more sophisticated parser on better text representations than String
11:31:41 <Cale> hguant: But just "never use this" is a bit strong, I believe.
11:32:09 <hguant> introduction to typeclasses: looking at Bool to see what it implements, and they put in a note next to read "don't use it. Seriously don't"
11:32:27 <geekosaur> o.O Bool is not a typeclass n standard Haskell
11:33:01 <Cale> hguant: Oh, maybe they don't want you to use the read function specifically
11:33:14 <Cale> Is it next to 'read' or to 'Read'?
11:33:24 <hguant> geekosaur: I think they're using Bool to show what typeclasses it implements?
11:33:36 <hguant> Cale: Read
11:33:52 <Cale> huh, I dunno, you'd have to ask bitemyapp about why he dislikes the class.
11:34:24 <hguant> It's not really relevant right now, I was just curious. 
11:34:30 <Cale> The function "read" is mostly a convenience when you know for sure that something is going to parse correctly, and doesn't give you a way to handle a parse error
11:34:44 <Cale> But it's not the only thing in the Read typeclass
11:35:19 <Cale> There's reads and readsPrec, both of which produce a list of parses, which let you then handle the case where the thing fails to parse
11:36:01 <hguant> cool - thanks for filling me in
11:36:32 <ski> @type readList
11:36:33 <lambdabot> Read a => ReadS [a]
11:38:14 <Cale> Yeah, there's also readList, which, (along with showList) is a somewhat clever trick to get an instance of Read (and Show) that treats [Char] differently.
11:39:02 <Cale> Maybe we should recommend that kind of trick as an option more often when people think they want overlapping instances... :)
11:39:14 <Cale> I don't know how much I really like it though
11:39:41 <ski> for some reason, i'm thinking about some OO trick ("pattern" ?), now that i consider it
11:39:43 <hguant> let me know if i'm parsing this wrong - readList takes a type that implements Read and returns a list of that type that implements ReadS?
11:40:07 <hguant> (sorry if that's a clunky way of writing that)
11:40:34 <ski> for any type `a' in `Read', `readList' takes a `String' and gives back a list of pairs of lists of `a', and (remainder) `String's
11:41:14 <ski> > (readList :: ReadS [Int]) "[0,1,2]blah"
11:41:16 <lambdabot>  [([0,1,2],"blah")]
11:41:26 <ski> > (readList :: ReadS [Char]) "\"abc\"blah"
11:41:28 <lambdabot>  [("abc","blah")]
11:41:48 <hguant> oh, that's really cool!
11:42:16 <ertes> huh?  Read doesn't overlap?
11:42:18 <ski> there's a default implementation of `readList', that will just attempt to parse something of the usual `[v0,v1,....]' list literal format, using the `Read a' instance to parse the individual `v's
11:42:50 <ertes> i guess you can use closed type families to make a non-overlapping Read/Show that treat Char differently
11:42:57 <augur> are there any Parsec pros here who can advise me on some stuff?
11:43:12 <hpc> nope
11:43:14 <hpc> lightyears only
11:43:15 <ski> however, in `Read Char', that implementation of `readList' is changed into one that also accepts the alternative `String' syntax using double quotes
11:43:15 <augur> :(
11:43:26 <ski> > (readList :: ReadS [Char]) "['a','b','c']blah"  -- still works, though
11:43:27 <lambdabot>  [("abc","blah")]
11:43:29 <augur> hpc: how many kesselrun pros are here tho
11:43:31 <augur> thats the question
11:43:53 <ski> ertes : no overlap
11:44:02 <hpc> fun fact, even if you accept that the kessel run is black holes and cutting the route close
11:44:38 <hpc> a parsec is the distance something has to be to experience an arc second of movement when earth does half an orbit
11:44:40 <ski> anyway, to close it off, the implementation of `readsPrec' in `Read [a]' just uses `readList' from `Read a'
11:44:47 <andromeda-galaxy> What's the prevailing community opinion of Roman Cheplyaka's monad-classes (especially vs. monad-tf, mtl, and extensible-effects)?
11:44:56 <ertes> ski: i can see how Read works, but Show?  the only trick i can think of is a closed type family
11:45:06 <ski> `Show' is the same thing
11:45:40 <hpc> :t showList
11:45:41 <lambdabot> Show a => [a] -> ShowS
11:45:49 <augur> does anyone know how to deal with lots of left ambiguity in Parsec?
11:46:14 <ski> `showsPrec' in `Show [a]' uses `showList' from `Show a'. `showList' has a default implementation in terms of `showsPrec' for `Read a'. `Show Char' has a different implementation of `showList', using the double quotes
11:46:34 <ski> ertes : so i don't see how `Show' would be any different from `Read'
11:46:45 <geekosaur> ertes, you could use more advanced type features, yes, but Read and Show are part of the Haksell98 and Haskell2010 specs and can't use those
11:46:55 <ertes> ski: ah
11:47:06 <ertes> geekosaur: they could in their implementation without exposing it
11:47:35 <geekosaur> but it still has to expose Haskell98-compatible interfaces
11:48:01 <ski> anyway, there's this "pattern" (not sure if they call it a pattern or not) in OO, where you simulate multi-methods by invoking a method on the argument object, and which method you invoke depends on which kind of object you are
11:48:08 <mmachenry> If I were to write a web multiplexer in Haskell, which is a web server that accepts a list of URLs, concurrently wget's them, and returns the whole‚Ä¶ which web server library and which web client library would be best. Assuming high performance is important. 
11:48:18 <ski> and i was here thinking that this trick with `showList',`readList' was somewhat similar to that
11:49:01 <Boomerang> ski is it the Visitor pattern?
11:49:25 <ski> i don't recall the name. maybe visitor, but iirc it was more specific
11:50:06 <ski> the point is that we get `showsPrec' in `Show [a]' to call `showList' in `Show a', to be able to customize it on `a'
11:51:12 <ski> (with a default implementation (which is what we'd written in `Show [a]', if we didn't do this trick) in terms of `showsPrec' in `Show a', in case we don't customize)
11:55:42 <cobreadmonster> Hello guys!
11:55:57 <dmj`> cobreadmonster: hello!
11:57:41 <Oejet> Hi, cobreadmonster.
11:59:20 <ertes> geekosaur: ok, my hack doesn't work as i would have liked
11:59:48 <ertes> or wait
12:01:00 <ertes> nope, doesn'T
12:01:02 <ertes> t
12:02:06 <lpaste> ertes pasted ‚Äú(Broken) Show hack for [Char]‚Äù at http://lpaste.net/160951
12:02:53 <lpaste> ertes revised ‚Äú(Broken) Show hack for [Char]‚Äù: ‚Äú(Broken) Show hack for [Char]‚Äù at http://lpaste.net/160951
12:04:00 <ertes> apparently GHC doesn't understand that the Select class is fully instantiated
12:07:25 <ertes> mmachenry: wai (server) and http-client/http-conduit (client) are likely the fastest ones on the market right now‚Ä¶  the former isn't a full web framework, but more a low-level library
12:11:05 <mmachenry> ertes: That's great, thanks. I was looking at combining wai with wreq. I'll consider http-client/http-conduit as well.
12:11:46 <ertes> mmachenry: wreq uses http-client under the hood
12:11:55 <ertes> so should be fine
12:12:14 <ertes> mmachenry: also any minimalistic web framework building on wai should be fine
12:12:54 <ertes> for example scotty is very minimal while you might still consider it to be a "web application library" rather than an "HTTP library"
12:20:17 * hackagebot hakyll 4.8.0.1 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.8.0.1 (JasperVanDerJeugt)
12:22:25 <mmachenry> :q
12:22:30 <mmachenry> (sorry)
12:22:34 <hpc> [sudo] password for mmachenry:
12:22:46 <Can_Not> hunter2
12:22:53 <mmachenry> Ihaveasecretcrushonhpc
12:22:59 <mmachenry> whoops, damnit!
12:49:23 <VikingofRock> > truncate (1/0) :: Integer
12:49:25 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
12:49:34 <VikingofRock> so the full number is 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
12:49:42 <VikingofRock> Does anyone know why that number gets chosen?
12:50:01 <johnw> look at it in binary
12:50:04 <hpc> i suspect it has to do with the IEEE floating point representation of infinity
12:50:15 <hpc> but i haven't dug terribly far into it
12:50:15 <johnw> 10...<many, many zeroes>...0
12:50:18 * hackagebot vector-binary-instances 0.2.3.2 - Instances of Data.Binary and Data.Serialize for vector  https://hackage.haskell.org/package/vector-binary-instances-0.2.3.2 (BenGamari)
12:50:51 <VikingofRock> Hmm maybe. It's interesting because truncate (NaN) is a different number
12:51:01 <VikingofRock> > truncate (0/0) :: Integer
12:51:03 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
12:51:05 <johnw> it's 1024 binary digits, btw
12:51:11 <johnw> so, 2^1024
12:51:20 <VikingofRock> It's -269653970229347386159395778618353710042696546841345985910145121736599013708251444699062715983611304031680170819807090036488184653221624933739271145959211186566651840137298227914453329401869141179179624428127508653257226023513694322210869665811240855745025766026879447359920868907719574457253034494436336205824
12:51:47 <VikingofRock> That in turn is different from truncate (-Infinity), which is -179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
12:51:55 <johnw> that one is -110...<many zeroes>...0
12:55:15 <dolio> > decodeFloat (1/0)
12:55:16 <lambdabot>  (4503599627370496,972)
12:55:30 <lambdafan> I have a type data Foo = Foo Int Int Int, and a [Int] with three Ints in it. Is there an operation I can use to create a Foo from my [Int]?
12:57:00 <lambdafan> a fold?
12:57:06 <lyxia> pattern matching
12:57:32 <lambdafan> could you elaborate?
12:57:47 <lyxia> a fold won't work because the type of the partially applied Foo will change with each argument
12:58:18 <Cale> lambdafan: what do you want to do when the [Int] doesn't have three Ints in it?
12:58:23 <lyxia> case myInts of [a,b,c] -> Foo a b c ; _ -> error "Not three Ints"
12:58:53 <lambdafan> Cale: It will always have 3 Ints
12:59:38 <lambdafan> Cale: However I am wrapping this in an Either , so if doesn't have 3 then I'll have a Left ErrorType
12:59:49 <Cale> lambdafan: okay
13:00:16 <lambdafan> Oh I just checked my code, wrapping it in a Maybe. That works too
13:04:13 <bblfish> starting to read http://www.paolocapriotti.com/blog/2013/11/20/free-monads-part-1/
13:05:04 <Zemyla> How much more powerful is ArrowChoice than Applicative?
13:05:17 <Zemyla> I know that ArrowApply implies ArrowChoice.
13:08:05 <lyxia> lambdafan: pattern matching means looking at the shape of the data, and introducing new variables bound to subterms of the data. In "case myList of [a, b, c] -> ..." you check that a list has the shape of a three element list, and if it is the case, a,b and c are bound to the three elements in the body of the expression (here as "...")
13:08:27 <monochrom> ArrowChoice is more powerful than Arrow is more powerful than Applicative
13:08:54 <hpc> fsvo "powerful"
13:09:00 <lyxia> lambdafan: otherwise, the case expression checks the next pattern if there is one, and so on, and if no pattern matched, it is an error
13:09:18 <hpc> is it more powerful for having more operations, or more powerful for having more instances?
13:11:55 <monochrom> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms shows the Applicative-Arrow-Monad progression.
13:12:16 <monochrom> ("idiom" = Applicative)
13:12:46 <shachaf> monochrom: Are those idiom brackets?
13:13:09 <monochrom> no
13:13:27 <shachaf> Just regular parentheses, then.
13:23:25 <lambdafan> ugh I was making this far more difficult than needed. solved now though.
13:46:25 <ozgura> how does one find out the latest version of a stack resolver for a given compiler version? I assumed "resolver: ghc-7.10.3" would mean that but it seems that is (something like) only those packages shipped by the compiler.
13:51:56 <kadoban> ozgura: There is no syntax way. You'd probably want something like lts-5, you'd have to look up what lts version corresponds to what compiler
13:52:31 <ozgura> kadoban: as in, "resolver: lts-5" instead of something like "resolver: lts-5.13"?
13:52:44 <ozgura> would that pick the latest lts-5?
13:53:05 <kadoban> ozgura: Not sure that actually works, come to think of it. You really need to specify a specific one I think.
13:53:20 <ozgura> I just tried and it doesn't work
13:53:40 <kosmikus> https://www.stackage.org/lts shows the latest one
13:54:06 <kadoban> ozgura: I personally just let it pick the most recent one when I 'stack new' or 'stack init' and otherwise just update it manually when/if I care later, which is pretty rare.
13:54:20 <kosmikus> or https://www.stackage.org/nightly if you want nightly rather than lts
13:54:41 <ozgura> kosmikus: thanks. I was using that link. though "latest for a compiler version" seems hard to find
13:54:53 <kosmikus> right. I don't know that.
13:54:55 <ozgura> "latest lts for the latest compiler" is easier to find
13:54:59 <kosmikus> only that the compiler version is shown.
13:55:27 <kosmikus> for lts, you can do stuff like https://www.stackage.org/lts-4 and it'll show you the latest for 4
13:55:36 <kosmikus> and compiler versions don't change within one lts
13:55:47 <kosmikus> but I don't know how to look by compiler version
13:56:33 <ozgura> I just went back using that trick (only mentioning the major version number) and found that lts-2.22 was the latest with ghc-7.8 series
13:57:00 <kosmikus> yes, seems like it
13:57:41 <ozgura> it seems this is an unsupported use case. I like compiling my app with at least the last two compiler versions (and as up to date dependencies as possible) to monitor possible performance regressions
13:58:47 <ozgura> I can fairly easily do that with cabal-install + cabal freeze
14:01:52 <ozgura> anyway, thanks kadoban and kosmikus!
14:03:31 <urbank> If I need a few very similar constructors for a datatype where one constructors has all fields and others have some subset of those fields
14:04:16 <urbank> is there a better way then defining them with different constructors?
14:04:58 <geekosaur> often it's better to have a single constructor with the common fields and a variant part, or by using Maybe types for the ones that can be missing
14:05:26 <urbank> variant part?
14:06:27 <tippenein> what do people use for delayed jobs in Haskell?
14:06:48 <maerwald> find another job?
14:07:02 <mmachenry> lol
14:08:31 <maerwald> urbank: I think it would be more useful if you present the concrete problem
14:09:53 <maerwald> I personally would probably not mind if you "duplicate" fields under a different constructor
14:09:59 <maerwald> don't see the problem with that
14:10:42 <geekosaur> the only potential issue is that the field projectors are partial
14:10:56 <geekosaur> for the ones not present in all constructors
14:11:11 <maerwald> you can easily write a maybe wrapper for that
14:12:07 <urbank> thank you for the responses! The concrete problem is representation of different card types in a card game engine I'm making for practice. 
14:12:26 <tippenein> I want a view of failed tasks, the ability to restart them, the ability to schedule them in the future, etc. Is there something that can provide that? I see `async` package does some of this
14:13:21 <urbank> as I see it, duplicate fields would multiply the number of function definitions if I define them via pattern matching
14:13:42 <urbank> maybe I should avoid definitions with pattern matching in this case?
14:14:26 <maerwald> it's still hard to say what you are doing
14:14:56 <ski> urbank : sometimes it's better to factor
14:15:19 * ski otherwise concurs with maerwald
14:21:21 <Dipper> stop say  why haskell!
14:21:24 <Dipper> Why haskell?
14:21:43 <hpc> what say you do what do say stop haskell what do say
14:22:51 <monochrom> I don't understand the question.
14:25:22 * hackagebot casadi-bindings 2.4.1.9 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-2.4.1.9 (GregHorn)
14:42:45 <RaoZvorovski> @pl
14:42:45 <lambdabot> (line 1, column 1):
14:42:45 <lambdabot> unexpected end of input
14:42:45 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:00:16 <BartAdv> hm, so I've got [Maybe a], and a-> IO b. How would I mapM it to obtain [Maybe b]?
15:01:21 <Cale> :t mapM . mapM
15:01:22 <lambdabot> (Monad m, Traversable t, Traversable t1) => (a -> m b) -> t (t1 a) -> m (t (t1 b))
15:01:38 <koala_man> BartAdv: you meant  IO [Maybe b] , right?
15:01:45 <dmj`> :t \(xs :: [Maybe a]) (f :: a -> IO b) -> mapM (mapM f) xs
15:01:47 <lambdabot> [Maybe a] -> (a -> IO b) -> IO [Maybe b]
15:01:55 <BartAdv> koala_man: yes
15:03:56 <BartAdv> thanks!
15:15:25 * hackagebot AFSM 0.1.3.1 - Arrowized functional state machines  https://hackage.haskell.org/package/AFSM-0.1.3.1 (hanzhxu)
15:56:16 <tippenein> Would be nice to represent haskell here - https://github.com/dimroc/etl-language-comparison
16:12:06 <hpc> tippenein: it's true, haskell doesn't get enough representation in #haskell ;)
16:13:36 <tippenein> hyuck hyuck
16:20:27 * hackagebot hw-succinct 0.0.0.8 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-succinct-0.0.0.8 (haskellworks)
16:22:24 <tippenein> Data.List.filter (\a -> "knicks" `isInfixOf` a) <$> (T.splitOn "\t" <$> T.readFile "../tweets/tweets_aa")
16:30:02 <tippenein> what about that makes it strict? If I call head on it, there is a pause before returning the result
16:30:27 <tippenein> jsut reading in the file I suppose
16:34:00 <Boomerang> Yeah readFile from Data.Text.IO is strict
16:36:07 <Welkin> ahahahaa
16:36:28 <Welkin> if I search my name online, I get my personal (hakyll) website as the first result
16:36:48 <Welkin> then a few results down is a link to my contact page, which is just the placeholder that hakyll gives you
16:36:51 <Welkin> since I don't use it
16:37:04 <Welkin> so it says "I live in a hut in the mountains and don't want to be contact"
16:37:06 <Welkin> contacted*
16:37:21 <Welkin> thanks jasper
16:44:31 <ntnt> I have ghcjs --interactive running (thanks to imalsogreg)
16:44:43 <ntnt> what is the simplest way to get ghcjsi to do an alert "hello world"
17:40:30 * hackagebot attoparsec 0.13.0.2 - Fast combinator parsing for bytestrings and text  https://hackage.haskell.org/package/attoparsec-0.13.0.2 (BenGamari)
18:06:27 <Zemyla> Why is there no instance (Monoid a, Monoid b) => Monoid (Either a b)?
18:06:47 <Zemyla> Where mempty is Right mempty and mappend is left-biased?
18:10:27 <acertain> how can I get the type from a Proxy# a with a pattern or?
18:13:01 <johnw> Zemyla: because other choices exist that are equally valid: Left mempty and right-biased, for example
18:13:26 <johnw> when multiple valid choices exist, the standard library often refrains from making that choice for you (although this isn't the case everywhere, for example Data.Map)
18:14:41 <Zemyla> johnw: We're fine with left-biasing in other places, like in Functor and Monad.
18:15:05 <johnw> Functor has no other choice
18:15:13 <johnw> Either a is the functor, so the "b" bias is already determined
18:15:33 <johnw> but with Monoid, neither type variable has any precedence
18:15:41 <johnw> (the Monoid for Either a b, that is)
18:45:21 <RaoZvorovski> ptr = CFutureTricks                 <$> peekByteOff ptr 0                 <*> peekByteOff ptr 4                 <*> peekArray 13 (ptr `plusPtr` 8)                 <*> peekArray 13 (ptr `plusPtr` (8 + 13 * 4))                 <*> peekArray 13 (ptr `plusPtr` (8 + 2 * 13 * 4))                 <*> peekArray 13 (ptr `plusPtr` (8 + 3 * 13 * 4))
18:45:29 <RaoZvorovski> Oops
18:53:26 <Zemyla> So if I have an Applicative f such that, if a :: f (a, b), then liftA2 (,) (fst <$> a) (snd <$> a) = a, then f is Representable, correct?
18:56:11 <jargon-> what does <> mean for lists? it seems to mean ++ but i can't find it documented anywhere
18:59:03 <Cale> jargon-: yep
18:59:43 <muesli4> jargon: http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#line-227
19:06:31 <jargon-> hm, "<>" doesn't actually appear there
19:06:51 <Zemyla> :i (<>)
19:06:55 <Zemyla> :t (<>)
19:06:56 <lambdabot> Monoid m => m -> m -> m
19:07:03 <Zemyla> It's a synonym for mappend.
19:07:19 <jargon-> got it, thanks
19:08:59 <Orbaruk> I need some help making scotty work with persist.sqlite, i'm following this example https://github.com/scotty-web/scotty/blob/master/examples/globalstate.hs and I want to add db queries on certain requests, but Im doing something wong...
19:11:51 <lpaste> orbaruk pasted ‚Äúscotty, persist type error‚Äù at http://lpaste.net/161190
19:11:57 <dolio> @check \xs -> zipWith (,) (fst <$> xs) (snd <$> xs) == xs
19:11:58 <lambdabot>  +++ OK, passed 100 tests.
19:12:46 <Orbaruk> as the error states, the type is ambiugous, but which type would be the correct one in this case?
19:30:36 * hackagebot MonadRandom 0.4.2.3 - Random-number generation monad.  https://hackage.haskell.org/package/MonadRandom-0.4.2.3 (BrentYorgey)
19:31:53 <Cale> byorgey: such trustworthy :)
19:53:54 <hackrilege> can anyone help me understand why this is a type error? http://lpaste.net/161191
19:55:03 <Hijiri> what line does it complain on?
19:55:09 <Hijiri> 7?
19:55:30 <hackrilege> 17
19:55:57 <hackrilege> thats where it hits an error set up by line 7
19:56:56 <Hijiri> maybe there is some monomorphizing and defaulting thing for kinds, since the kind of s isn't inferable in the Zipable definition
19:57:34 <hackrilege> z s a?
19:57:37 <Hijiri> yeah
19:57:43 <Hijiri> z s
19:58:03 <Hijiri> it's only known that s has the kind of the second argument to z
19:58:11 <Hijiri> but that could be anything, maybe it picks * by default
19:58:26 <Hijiri> what if you d class Zipable z (s :: k) where ?
19:59:33 <hackrilege> s::k?
20:00:33 <Hijiri> it makes k a kind variable
20:00:46 <Hijiri> like a type variable
20:01:05 <maybefbi> how do i to recursion using hxt arrows? i need find elements in the same level which extend each other, and an attribute called extends="foo" on those elements tell us which element they extend.
20:02:04 <maybefbi> and by extend i mean their children ought to be merged
20:02:29 <hackrilege> ok thanks ill try something
20:02:48 <Hijiri> hackrilege: also you are defining the Zipable members in the Stack instance
20:02:50 <hackrilege> it still complains if i do that
20:03:00 <Hijiri> does it complain about the same thing?
20:03:08 <Hijiri> It stopped complaining for me, other than the new errors
20:03:19 <Hijiri> oh
20:03:21 <Hijiri> wait sorry
20:03:23 <Hijiri> I misread
20:03:26 <hackrilege> but those new errors are phrasings of the same problem
20:03:39 <Hijiri> are you sure
20:03:52 <Hijiri> the new errors I'm getting is because you are using Zipper-specific functions where it needs to be on any Zipable
20:04:22 <hackrilege> oh shoot im pattern matching on Zipper!
20:04:29 <Hijiri> you also used forward and backward
20:04:37 <Hijiri> actually only forward
20:05:40 <hackrilege> yeh ok nt everything made of stacks is a zipper...
20:07:53 <hackrilege> PolyKinds huh, whats all this about then with the ::k, i cant get it to work without it...
20:08:25 <hackrilege> never seen that in all my life, wonder what else im missing
20:10:24 <hackrilege> anyway that fixes it so thanks!
20:20:13 <gfixler> is there a way to wrap around with succ?
20:20:19 <gfixler> for Bounded, Enum types?
20:20:38 * hackagebot fast-builder 0.0.0.4 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.0.0.4 (AkioTakano)
20:22:23 <gfixler> some kind of Enum type mod?
20:22:43 <gfixler> circular type?
20:24:01 <montanonic> Is it just me, or is it pretty unclear how to send a JSON request to an external URL using Yesod?
20:25:01 <montanonic> My goal is to just retrieve some JSON information from requests to Google's REST APIs, but I just cannot figure out how to make that work within Yesod.
20:25:27 <montanonic> I was hoping it would have some method for doing that, but maybe I just need to dive into a lower level API for requests
20:30:17 <augur> gfixler: can you elaborate more on what you're thinking of?
20:30:47 <gfixler> augur: just where succ and pred wrap on a bounded type
20:31:01 <augur> if they wrap, then it's not a bounded type :)
20:31:03 <gfixler> succ Sunday = Monday, where Monday was the last in the sum type
20:31:25 <gfixler> augur: I'm looking for something like Bounded, but which does wrap
20:31:30 <augur> the concept of boundedness is that there is a largest and smallest element
20:31:33 <gfixler> augur: Wrapped ?
20:31:47 <gfixler> augur: I don't want to say Ring - that's a thing
20:31:55 <augur> a loopy type!
20:32:01 <gfixler> yes!
20:32:01 <augur> what does it mean to be "like bounded but wraps"?
20:32:13 <gfixler> augur: finite number of constructors
20:32:22 <gfixler> forget "like bounded" if that's upsetting
20:32:23 <augur> because being bounded meanings that for all x, minbound <= x <= maxbound
20:32:29 <augur> but this cant be true for loopy types
20:32:33 <gfixler> augur: there wouldn't be bounds
20:32:37 <gfixler> so let's stop saying Bounded
20:32:44 <gfixler> I just want succ and pred to wrap
20:32:46 <augur> good :)
20:33:05 <augur> then i dont know if there's such a type class already but it should be possible to define
20:33:06 <gfixler> data Day = Sunday | Monday | ... | Saturday deriving (Loopy)
20:33:15 <gfixler> yeah, it would be easy enough
20:33:28 <gfixler> but if I let it be Bounded, I can do this:
20:33:34 <gfixler> succ maxBound = minBound
20:33:45 <augur> except that fails to be bounded!
20:33:59 <gfixler> augur: you and your "definitions" and "rigor"
20:34:14 <gfixler> 22 is the highest number
20:34:29 <gfixler> okay, I have a solution
20:34:32 <augur> you dont want to use a type class if you dont follow it's expected laws
20:34:36 <augur> because that will lead to bugs
20:34:42 <gfixler> a Not class, which allows you to use type classes wrong
20:34:50 <gfixler> deriving (Bounded, Not, etc)
20:35:05 <gfixler> you'd get the Bounded stuff, but it wouldn't have to obey any laws
20:35:29 <gfixler> augur: I'll just have to reproduce minBound and maxBound in Loopy
20:35:29 <augur> lol
20:35:40 <gfixler> but not as bounds
20:35:43 <augur> but do you need anything even remotely like minBound and maxBound?
20:35:47 <gfixler> just as the highest and lowest defined
20:35:59 <augur> you should sit down and figure out what what exactly it is that you're looking for
20:36:01 <Reshi> Does anyone have a recommendation on a Haskell mug?
20:36:02 <augur> not in terms of other type classes
20:36:06 <gfixler> augur: I already said it
20:36:07 <augur> just in terms of the behavior you want
20:36:14 <gfixler> succ and pred, but where maxBound wraps to minBound, and vice versa
20:36:20 <gfixler> it's not complicated
20:36:25 <augur> gfixler: but why do you need the bounds
20:36:33 <gfixler> augur: why are you so hung up on bounds?
20:36:40 <augur> gfixler: because you keep mentioning them!
20:36:43 <gfixler> I need to be able to ask if I'm at the last value
20:36:47 <gfixler> so I know to go to the first
20:36:51 <augur> there is no last value
20:37:02 <gfixler> there's a last one I defined
20:37:07 <gfixler> Red | Blue Green
20:37:17 <augur> what is the larger context that you're using this in
20:37:26 <gfixler> augur: succ and pred
20:37:29 <augur> no no
20:37:31 <gfixler> but for systems that loop, like days of the week
20:37:44 <gfixler> augur: or do you mean why do I want to be able to say maxBound (or whatever)?
20:37:49 <augur> it seems like you have some intuitions coming from some particular problem space, that has various notions, that you're not mentioning
20:37:53 <gfixler> i.e. when would it be useful outside of looping?
20:38:17 <gfixler> augur: have you ever noticed that the days of the week repeat throughout the year?
20:38:22 <monochrom> I am not sure what is the point of this conflict. Both of you agree Enum will not wrap around. So define your own wrap-around class, or if a class is unnecessary, define your own "next" function that wraps around.
20:38:29 <augur> gfixler: yes, they do repeat :)
20:38:41 <gfixler> I only ever have such conversations in #haskell[-*]
20:39:01 <gfixler> everywhere else when I say things like "I want succ to wrap around for some types" people go "Oh, okay"
20:39:06 <gfixler> :)
20:39:18 <augur> gfixler: because its obvious how to write it to make that happen
20:39:24 <augur> succ Saturday = Sunday
20:39:29 <augur> pred Sunday = Saturday
20:39:32 <augur> done
20:39:38 <gfixler> augur: I was hoping to derive it automatically
20:39:42 <gfixler> without learning out deriving works
20:39:44 <augur> there is no such class to my knowledge
20:40:12 <gfixler> augur: iow, I could write one function that *just worked* for all Bounded types
20:40:17 <gfixler> because we know the highest and lowest values for them
20:40:28 <augur> yes, you could do that
20:40:34 <gfixler> augur: that's all I meant
20:40:44 <gfixler> augur: I think I don't need a class, though
20:40:44 <augur> well that's easy
20:40:48 <gfixler> just a function
20:40:53 <gfixler> constrained to Bounded types
20:41:07 <gfixler> succWithWrap :: Bounded a -> a -> a
20:41:30 <gfixler> just to add a wraparound to the ends of a Bounded type
20:41:39 <gfixler> without having to code it up for every bounded type
20:41:43 <augur> succWrap :: (Eq a, Bounded a) => a -> a  ;  succWrap x | x == maxBound = minBound ; | otherwise = succ x
20:41:50 <gfixler> ah, right, Eq, too
20:42:04 <gfixler> I'm scrapping my typeclasses
20:42:09 <augur> dont do that
20:42:11 <augur> why would you do that
20:42:24 <gfixler> it's all just functions
20:42:33 <augur> yes it is but why would you scrap your type classes
20:42:49 <gfixler> augur: alright, I'll just scrap Loopy
20:43:05 <augur> type classes are your friend
20:43:53 <gfixler> augur: I can't get too friendly with anything anymore
20:44:02 <gfixler> augur: every time I do, someone shows me that it's all stupid
20:44:14 <augur> anyone who shows you that type classes are stupid is wrong
20:44:23 <gfixler> I thought Turing Completeness was required, then learned it was awful
20:44:37 <monochrom> I think both of you should stop arguing.
20:44:45 <augur> i dont know who you're talking to, they're very silly
20:45:04 <augur> monochrom: i didnt realize we were arguing :)
20:45:16 <gfixler> monochrom: Who's arguing? I'm whining.
20:46:13 <augur> if you read gabriel gonzalez's blog post, forget it. it's not aimed at type classes in general, it's aimed at a particular abuse of type classes
20:47:19 <gfixler> augur: I read the title and formed a detailed opinion/worldview based solely on that
20:47:29 <augur> some people use type classes as a way of storing global data, rather than as a technique for automatic program construction, and so they get all tangled up by it
20:54:48 <mgsloan> Yeah, that post is throwing the baby out with the bathwater.  "Yaaarrgh typclasses are not as first class as I want them to be, throw em out!"
20:55:26 <mgsloan> IMHO we just need to add more powerful ways of defining instances
20:55:44 <bitemyapp> @where book
20:55:44 <lambdabot> http://haskellbook.com/
20:55:47 <bitemyapp> prooftechnique: ^^
20:55:48 <mgsloan> Lots of boilerplate for instance decls and deriving decls still
20:57:23 <Cale> mgsloan: What post?
20:58:04 <mgsloan> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
20:59:42 <Cale> Oh, well, the technique he demonstrates there is actually often useful.
21:00:14 <mgsloan> Certainly, but it is unfortunately presented as "scrap your type classes"
21:00:47 <Cale> Yeah, though that title is also a bit of a pun
21:01:05 <Cale> There were a lot of papers around that time named "Scrap your X" for various X
21:01:15 <mgsloan> Sure, but he does tell you to delete your instance declaration and replace it with the data dict
21:01:22 <Cale> yep
21:01:53 <augur> gabriel writes a lot of silly stuff like that
21:01:58 <Cale> You'll see people dig themselves into really deep pits of trying to coerce instance resolution to go their way before trying something like that though.
21:01:59 <mgsloan> I actually worked quite hard to make typeclass instances more first class: https://github.com/mgsloan/instance-templates
21:02:12 <mgsloan> I think I didn't present the ideas well enough, reception was lukewarm
21:02:15 <mgsloan> So I abandoned it
21:02:32 <mgsloan> I like goldfire's proposal quite a bit: https://ghc.haskell.org/trac/ghc/wiki/InstanceTemplates
21:04:02 <mgsloan> And perhaps some aspects of my proposal, such as how scope would work, were a bit off too
21:04:06 <mgsloan> but we really flippin need this
21:04:43 <mgsloan> typeclass hierarchies are brittle and it's a PITA to define an instance in a mechanical way 
21:09:00 <Zemyla> Is there a way to have a general sort :: (Ord a, Traversable t) => t a -> t a?
21:10:40 * hackagebot Diff 0.3.3 - O(ND) diff algorithm in haskell.  https://hackage.haskell.org/package/Diff-0.3.3 (SterlingClover)
21:12:40 <dolio> Yes, at least for finite cases.
21:13:00 <mgsloan> Zemyla: You could.  Sort the result of toList and then keep around the tail of the list when traversing 
21:13:15 <mgsloan> It wouldn't be very efficient, though, better to use https://hackage.haskell.org/package/mono-traversable-0.10.2/docs/Data-Sequences.html#v:sort
21:13:16 <Zemyla> mgsloan: Yes, but I'm wondering if there's a single-pass method.
21:13:31 <mgsloan> Nope
21:13:48 <dolio> What counts as single pass?
21:13:55 <mgsloan> Sorting in general doesn't have a single pass method :)
21:15:18 * hackagebot fast-builder 0.0.0.4 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.0.0.4 (AkioTakano)
21:15:18 * hackagebot Diff 0.3.3 - O(ND) diff algorithm in haskell.  https://hackage.haskell.org/package/Diff-0.3.3 (SterlingClover)
21:19:01 <SkyFold> Hey, I'm new here. Is this the right place to ask a Hspec question?
21:19:39 <erikd> SkyFold: there actually is a hspec channel, but you can ask here as well
21:21:21 <erisco> you know Conal's Semantic Editor Combinators yes? http://conal.net/blog/posts/semantic-editor-combinators
21:21:49 <erisco> there was someone else who wrote an article from this who invented infix operators so you could map function arguments and return values elegantly
21:22:22 <erisco> but I cannot find this other article anymore‚Ä¶ I have derived those infix operators for myself, but my main question is if there is a module in Hackage for them yet
21:22:58 <mgsloan> erisco: I wrote something like that as a half way serious idea, half way joke http://www.mgsloan.com/wordpress/?p=148 
21:22:58 <SkyFold> erikd: Thanks, I am just trying to figure out how to write tests for my executable. I have an cabal project with a library and an executable, but I cannot import the executble into a file.
21:24:13 <erisco> mgsloan, hm, no that was what I read, sorry. What you have is interesting but article I read only uses 3 infix operators (at least I think, because that is what I came up with)
21:24:54 <erikd> SkyFold: i think you need to separate your executable into a "library" which you test using hspec and an executable that does command line parsing and calls the library to do the work
21:25:07 <erisco> I named them $* $$ and *$ (and *$ is just $), and you can write  compare $* fst $$ fst *$ id  for example for  (Ord a) => (a, b) -> (a, b) -> Ordering
21:25:40 <erisco> the other article used different names‚Ä¶ one of them was ~> or something like that
21:26:09 <SkyFold> erikd: In other words, keep the implementatiton in the lib and just call them in the executable.
21:26:19 <mgsloan> I quite like the names I used for the low arity combinators
21:26:39 <erikd> SkyFold: exactly!
21:26:45 <erisco> $* and $$ *$ work on any arity
21:27:12 <SkyFold> erikd: Thanks for helping me with my simple question
21:27:23 <erikd> SkyFold: no prob
21:27:29 <dolio> I like the name map.
21:27:33 <erisco> which is why there needs to be a hackage module for these combinators if there isn't one already, because they're really useful
21:28:25 <erisco> I thought the link was in conal 's comment section but I don't see it there now‚Ä¶ I think it has been clipped off by these strange ellipses?
21:30:53 <montanonic> Is there any library support in Haskell for incremental authorization with google's OAuth2 protocol? https://developers.google.com/identity/protocols/OAuth2WebServer#incrementalAuth
21:31:26 <erisco> I guess I'll just upload it and worse case is someone lets me know of the other module which already exists. I really haven't a clue how to find it
21:50:37 <hackrilege> this error is driving me mad! http://lpaste.net/161200
21:50:49 <hackrilege> can anyone give me a hand with figuring it out?
21:51:33 <orb> hackrilege: can you also give the line number of your error?
21:51:53 <orb> hackrilege, in general, you should use pattern matching, not checking for `null'.
21:52:19 <orb> hackrilege, also avoid other partial functions like fromJust.
21:52:34 <hackrilege> its on line 107
21:53:07 <hackrilege> thanks for the tips on handeling Maybe...
21:54:32 <hackrilege> i think its tring to make Zipper (Zipper []) (Zipper [] a)
21:54:45 <hackrilege> instead of i think its tring to make Zipper ([]) (Zipper [] a)
21:55:14 * hackagebot heredocs 0.1.1.0 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.1.0 (KatsutoshiItoh)
21:55:15 <hackrilege> instead of 'Zipper [] (Zipper [] a)'
21:55:36 <orb> hackrilege: what's gmap supposed to do?
21:55:56 <hackrilege> same thing as gmap'
21:56:43 <orb> OK, what are they supposed to do?
21:56:57 <hackrilege> oh my god, i think i forgot to write the Comonad instance for GridZipper...
21:57:13 <hackrilege> same as zmap, but in 2d
21:58:02 <hackrilege> same as zmap' sorry
21:58:35 <hackrilege> gmap' works...
21:58:47 <orb> Are you trying to implement something like http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html ?
21:59:05 <orb> hackrilege: could you run hlint over your code first?
21:59:31 <hackrilege> hlint!?
22:00:00 <hackrilege> HLint is a tool for suggesting possible improvements to Haskell code
22:00:01 <hackrilege> cool
22:00:07 <orb> Available via eg stack install hlint
22:00:13 <hackrilege> i use cabal
22:00:27 <hackrilege> do you need me to do this?
22:00:27 <orb> Switch to stack, it's nicer, and at least as easy to use.
22:00:31 <hackrilege> no!
22:00:37 <orb> you can also get hlint via cabal.
22:00:40 <orb> Doesn't really matter.
22:00:54 <orb> But hlinting your code would make further review so much easier.
22:01:06 <hackrilege> id rather not just now then, ill look into it later, thanks for the tips, ill do it for my pastes from now on
22:01:47 <hackrilege> you get to absorb my style...
22:01:53 <orb> Haha.
22:01:55 <hackrilege> sorry!
22:02:17 <orb> You are using quite some advanced concepts, but lack some basic ones.
22:02:26 <hackrilege> such as?
22:02:42 <orb> KindSignatures and stuff.
22:03:05 <orb> (Although, not sure whether they are actually in the code.  I just saw the extension.)
22:03:11 <hackrilege> which basic concepts do i lack?
22:03:22 <orb> Shying away from fromJust.
22:03:33 <hackrilege> i handle it like a boss
22:03:53 <hackrilege> in my mind
22:04:24 <orb> Ok, let me try and figure out why the compiler is complaining.
22:04:42 <hackrilege> anyway, i think i just forgot a comonad instance so ill add that, i guess i have to switch from types to datatypes... this is anoying
22:05:02 <hackrilege> its using extend from Zipper
22:05:34 <hackrilege> it should wrap up what gmap' is doing with cojoin into its instance for extend, i forgot about that im dumb iv been staring at it for ages
22:05:46 <hackrilege> sorry
22:06:15 <hackrilege> it looks like it will extend neatly to 3d after this though which is nice
22:07:04 <hackrilege> handeling of higher dimensional stencils is normally a pain, and while this is my umteenth attempt in haskell, it looks like the solution is quite nice
22:08:23 <hackrilege> is it really so hard to read the code?
22:08:48 <hackrilege> i will be upset if my syntax stops people being able to read it, i think its kind of snazzy
22:09:22 <hackrilege> can you see what its doing?
22:09:51 <orb> hackrilege: hlintify.
22:10:05 <hackrilege> okok
22:10:38 <hackrilege> because really i think i might still be stuck, i dont know how to tie this end but up really...
22:10:46 <hackrilege> i think im just pushing a bug around the plate
22:10:47 <orb> I'm trying to understand.
22:11:49 <nocturne777> I want to filter out all the numbers less than "n". I also need to preserve the order of elements in the list. Do you think there's a better way to do this than this ? 
22:11:51 <nocturne777> f1 n arr = reverse $ L.foldl' (\a x -> if x < n then  x : a  else a) [] arr
22:12:05 <johnw> why not just use filter (/= n)?
22:12:17 <nocturne777> johnw: I am not supposed to use a filter
22:12:22 <johnw> sorry, filter (>= n)
22:12:24 <johnw> oh
22:12:27 <johnw> @src filter
22:12:27 <lambdabot> filter _ []     = []
22:12:27 <lambdabot> filter p (x:xs)
22:12:27 <lambdabot>     | p x       = x : filter p xs
22:12:27 <lambdabot>     | otherwise = filter p xs
22:12:46 <johnw> you can basically just write that definition using foldr
22:12:52 <thimoteus> [ x | x <- xs, x < n ] ?
22:13:07 <johnw> foldr (\x rest -> if x < n then rest else x : rest) [] xs
22:13:08 <nocturne777> johnw: I can, but foldr accumulates thunks
22:13:11 <orb> hackagebot: Have you tried: type GridZipper a = Zipper (Zipper []) a
22:13:22 <hackrilege> you think thats right?
22:13:33 <hackrilege> thats what the compiler infered
22:13:37 <johnw> nocturne777: wait, you have an exercise that prevents you from using filter, *and* is concerned about how laziness is implemented?
22:13:38 <orb> nocturne777: homework? ;)
22:13:56 <nocturne777> it is not a homework
22:13:58 <johnw> also, this use of foldr doesn't "accumulate thunks"
22:14:43 <orb> hackrilege: I mean, it might be possible that this is the definition you actually need to make everything work.
22:15:01 <hackrilege> my brain is broken though
22:15:18 <orb> nocturne777: Nothing wrong with homework either.  I was just speculating where the restrictions came from.
22:15:20 <hackrilege> looks like it might be whats needed
22:15:53 <nocturne777> johnw: I think using foldl' is better since I am going to traverse the entire list
22:16:06 <hackrilege> i thought it was (Zipper [] (Zipper [] a))
22:16:08 <orb> hackrilege: I haven't really looked at your functions too much.  That form of GripZipper just `feels' like a more normal one.
22:16:14 <johnw> nocturne777: even then, this use of foldr should get fused away by the compiler
22:16:27 <johnw> nocturne777: it's better to analyze than to assume, where performance is concerned
22:16:46 <hackrilege> i cant see how (Zipper [] (Zipper [] a)) = Zipper (Zipper []) a
22:17:04 <hackrilege> the former works as a synonym
22:17:29 <orb> hackrilege: I meant, perhaps try to make the other form work, if that's possible.
22:18:08 <hackrilege> i would need to understand it
22:18:22 <hackrilege> and for me having Zipper [] as the Stack
22:18:33 <hackrilege> in Stack s => Zipper s a
22:18:35 <hackrilege> is not good.
22:18:37 <orb> hackrilege: what's fmap' good for?
22:18:53 <hackrilege> composing navigations
22:19:04 <hackrilege> for instance map is the most basic traversal
22:19:23 <hackrilege> a nearest neighbors search is a different navigation
22:19:41 <hackrilege> maping that navigation is different to doing it series
22:20:18 <hackrilege> 2 steps forward one step back is no way to traverse a list
22:20:24 <orb> hackrilege: I suspect fmap' can be replaced by something out of Data.Foldable (or Data.Traversable) or so.
22:20:37 <hackrilege> no
22:21:34 <nocturne777> johnw: maybe I should use foldr'
22:22:02 <hackrilege> in order to traverse in this way, a list of values to traverse from must be constructed, as in 'meta'
22:27:23 <orb> hackrilege: eg iterate' f x = x : maybe [] (iterate' f) (f x)
22:27:51 <orb> hackrilege: if you are willing to accept a Traversable contraint, fmap' = traverse
22:28:19 <hackrilege> the problem is that i have written an instance of Comonad already for Zipper, Gridzipper should be a Zipper and i dont want to have to find myself writing out all the instances for each dimension i zoom out
22:28:53 <hackrilege> fmap'=traverse!? hah finally i understand that class
22:29:07 <hackrilege> awesome thanks
22:29:20 <johnw> nocturne777: I'd actually be a bit surprised if that made any difference
22:29:21 <hackrilege> i guess that was the lesson here
22:29:45 <hackrilege> do you see what im saying about the instances?
22:30:16 <johnw> nocturne777: when you call foldr in this case, you get back a thunk.  In order to evaluate that to WHNF, it has to execute the if test to determine which list constructor it is; then you'll have (cons element <thunk>), basically, and so it repeats
22:31:08 <orb> hackrilege, neighbors z = mapMaybe ($z) [left, right]
22:31:10 <johnw> but I'd have to look at Core to be sure
22:31:32 <orb> hackrilege, I see what you are trying to do.  Comanads in general don't compose, alas.  (I think.)
22:31:51 <hackrilege> dont compuse?
22:31:53 <orb> So I assume you'll have to do some work to convince the type system that adding dimensions is fine.
22:31:55 <hackrilege> compose*
22:32:31 <hackrilege> what do you mean?
22:32:49 <orb> Eg, if you have a two Functors f and g, then newtype Compose f g a = Composed f (g a)
22:32:56 <hackrilege> also, what am i trying to do?
22:33:00 <orb> is a functor again.  (Its fmap is just (fmap.fmap) of f and g.)
22:33:24 <hackrilege> oh ok
22:34:02 <orb> I don't think your types as they are, are of the right shape to handle an arbitrary number of dimensions.
22:34:48 <hackrilege> hmmmmm
22:35:39 <orb> hackrilege: do you know the trick of nesting zipWith?
22:36:01 <orb> :t zipWith . zipWith
22:36:02 <hackrilege> no
22:36:02 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
22:36:10 <hackrilege> cool
22:36:10 <orb> :t zipWith . zipWith . zipWith
22:36:12 <lambdabot> (a -> b -> c) -> [[[a]]] -> [[[b]]] -> [[[c]]]
22:36:49 <orb> I think that can sort-of lead to kind of stuff you are after.
22:37:00 <hackrilege> lol
22:37:10 <hackrilege> i dont think so
22:37:34 <hackrilege> cool though
22:38:06 <orb> (zipWith5.zipWith5) step1 original (moveLeft original) (moveRight original) (moveUp original) (moveDown original)
22:38:17 <mniip> orb, zipWith is merely liftA2 in ZipList
22:38:20 <hackrilege> and no fmap' /= traverse
22:38:21 <mniip> no wonder it stacks
22:38:46 <hackrilege> zmap'
22:38:48 <hackrilege> *
22:39:17 <hackrilege> zmap' :: (ListZipper a -> b) -> ListZipper a -> ListZipper b
22:40:25 <hackrilege> i think you mean iterate' left = traverse?
22:40:29 <hackrilege> :t traverse
22:40:30 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:41:20 <hackrilege> no i really cant see how these are related
22:41:34 <orb> hackrilege: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html uses comonads and zippers, too, to do something similar.  Perhaps that will help?
22:42:04 <orb> zmap' looks a bit like the dual of >>=
22:42:23 <hackrilege> that article sort of inspired this work
22:42:43 <hackrilege> in that its one of the references i have
22:42:55 <orb> zmap' is even implemented in a dual way to how >>= can be build from join and fmap.
22:43:03 <hackrilege> cool
22:44:17 <orb> https://hackage.haskell.org/package/comonad-5/docs/Control-Comonad.html look for extend.  (Different from your extend.)
22:44:21 <orb> Your extent is actually cojoin.
22:44:26 <hackrilege> cojoin populates the container with the zipper at each of its positions, fmap then applies a function to each of these to gather local information
22:44:32 <orb> (or duplicate.)
22:44:54 <hackrilege> oh i didnt know the word extend was protected
22:44:59 <hackrilege> ill use cojoin
22:45:37 <hackrilege> i didnt know if i was violating laws thats all
22:45:39 <orb> extend f  = fmap f . duplicate (in their terminology), just as: (>>=) f = join . fmap f
22:45:55 <Zemyla> And duplicate = extend id.
22:45:56 <orb> hackrilege: it's not protected.  It just already has a meaning in the wider comonad world.
22:46:16 <orb> By the way, why not import Control.Comonad instead of defining your own?
22:47:39 <ElMo> quit
22:48:00 <hackrilege> to comunicate to the user what the type signature of the functions are
22:48:30 <hackrilege> and to hide unnecessary function definitions
22:49:07 <Zemyla> hackrilege: It makes it more difficult for the user to use it.
22:49:30 <hackrilege> yeah for you guys, but not the people im writing it for
22:49:35 <hackrilege> its meant for presentation
22:49:37 <hackrilege> not for use
22:49:55 <hackrilege> i would change it if it was being deployed obviously
22:50:54 <hackrilege> extend and duplicate are mutually defined!
22:51:07 <hackrilege> :t extend
22:51:08 <lambdabot> Not in scope: ‚Äòextend‚Äô
22:51:13 <hackrilege> :t duplicate
22:51:14 <lambdabot>     Not in scope: ‚Äòduplicate‚Äô
22:51:15 <lambdabot>     Perhaps you meant one of these:
22:51:15 <lambdabot>       ‚Äòreplicate‚Äô (imported from Data.List),
22:52:48 <hackrilege> aha ok, so it just tells me that my zmap' is a default method of Control.Comonad upon implementing meta
22:53:10 <gfixler> I wish I could use existing names in patterns, like foo minBound = whatever
22:56:37 <orb> gfixler: pattern synonyms allow some of what that would give you.
22:56:49 <orb> (Not exactly the same, though.)
22:57:18 <gfixler> orb: oh, I was just reading about those, and not grokking much :)
22:58:23 <orb> hackrilege: ok, I see why you'd want to be self-contained.
22:58:35 <orb> hackrilege: I'd still start with the library version, and only once it works inline what you need.
22:58:49 <orb> But that's just my preference, because I never trust my own code.  At least at first.
22:59:26 <orb> hackrilege: extend and duplicate are only mutually defined in the default.  That's why to get a proper instance, you have to provide the minimal complete definition.
22:59:34 <orb> ie you have to define at least one of the two.
23:03:00 <ertesx> gfixler: for what purpose?  because shadowing is allowed
23:03:48 <ertesx> foldr (+) z (x : xs) = x + foldr (+) z xs
23:08:01 <hackrilege> am i correct in thinking i can write an instance for Free (Zipper []) using this approach
23:08:04 <hackrilege> ?
23:08:58 <orb> ertesx: I think gfixler wants f knownValue = ... to be equivalent to f x | x == knownValue = ...
23:09:24 <ertesx> ah
23:10:22 <hackrilege> if so, how would i how would i instantiate a value to a specified depth?
23:11:24 <hackrilege> eg. how do i say that Zipper [] (Zipper [] a) = Free (Zipper []) a
23:11:27 <Lovepon> guys..
23:11:31 <Lovepon> ghcjs and sodium.
23:11:40 <Lovepon> it suddenly stops working after a few seconds. '_'
23:11:58 <ertesx> hackrilege: you don't, because that's not the case
23:12:20 <ertesx> hackrilege: you may be interested in Cofree
23:13:10 <hackrilege> rather Roll ((Zipper [] (Roll (Zipper [] a))) = Free (Zipper []) a
23:13:13 <hackrilege> or something
23:13:24 <ertesx> Lovepon: sodium, the FRP library?
23:13:45 <Lovepon> ertesx: Yeah.
23:13:52 <ertesx> hackrilege: that's not the case either
23:13:57 <Lovepon> ertesx: I'll try rolling back to lts-5.12.
23:14:23 <hackrilege> data Cofree f a = a :< f (Cofree f a)
23:14:26 <ertesx> Lovepon: note that the haskell version of sodium is obsolete
23:14:27 <Lovepon> (I'm using stack)
23:14:35 <Lovepon> ertesx: Oh.
23:14:43 <ertesx> Lovepon: reflex works with GHCJS, too, so i recommend that one
23:15:15 <Lovepon> How about reactiveBanana?
23:15:16 * hackagebot wai-handler-launch 3.0.1 - Launch a web app in the default browser.  https://hackage.haskell.org/package/wai-handler-launch-3.0.1 (MichaelSnoyman)
23:15:18 <ertesx> Lovepon: it also has a ready-made library for dealing with the DOM: reflex-dom
23:15:24 <Lovepon> I don't think it works for GHCJS
23:15:32 <Lovepon> But I want to know if people use it for other stuff.
23:15:44 <ertesx> Lovepon: i've seen reports that reactive-banana doesn't work in GHCJS, but haven't verified it myself
23:16:24 <Lovepon> ertesx: How about for other stuff?
23:17:02 <ertesx> Lovepon: reactive-banana is a very good FRP library, so nothing wrong with using it
23:17:14 <ertesx> given a choice between banana and reflex, i'd choose reflex though
23:17:18 <Lovepon> ertesx: Ah, thanks.
23:17:24 <hackrilege> Cofree (Zipper []) a =a :< Zipper []  (a :< Zipper []  (Cofree (Zipper []) a))
23:17:47 <hackrilege> no thats not right, i dont want all those 'a's i just want
23:18:12 <hackrilege> Zipper [] (Zipper [] (Zipper [] (...)
23:18:27 <ertesx> hackrilege: that's Fix
23:18:28 <hackrilege> thats Free
23:18:34 <ertesx> not Free
23:18:39 <hackrilege> i want one a at the end
23:18:46 <ertesx> ah
23:19:09 <ertesx> that's Free, but it won't let you choose where the final 'a' is
23:19:09 <hackrilege> i want also only finitely many Zipper []'s
23:19:18 <hackrilege> hmmm
23:19:40 <Lovepon> ertesx: So, Dynamic is Behavior?
23:19:43 <hackrilege> basically i want to write an instance for something that is just nested applications of itself
23:19:46 <ertesx> Free F A = A + F A + F (F A) + ‚Ä¶
23:20:13 <hackrilege> +?
23:20:19 <tnks> I was trying to find a good account of the differences between NoImplicitPrelude and import Prelude ().
23:20:23 <hackrilege> Roll a
23:20:27 <Lovepon> hackrilege: |
23:20:40 <ertesx> Lovepon: Dynamic is a pair of one event and one behaviour‚Ä¶  the former notifies when the latter changes, so you can react to changes
23:20:51 <Lovepon> ertesx: Ohhh, I see.
23:21:05 <tnks> I remember pieces, but not enough to feel comfortable.
23:21:32 <hackrilege> Roll (Zipper []) :: Free (Zipper []) a
23:21:38 <ertesx> hackrilege: (+) = Either
23:21:54 <hackrilege> Roll (Zipper []) a :: Free (Zipper []) a
23:22:23 <hackrilege> Roll (Zipper [] (Zipper [] a)) :: Free (Zipper []) a
23:22:49 <hackrilege> sorry the a should be inside the parentheses in the first of those two
23:24:18 <hackrilege> so if i write an instance for Free (Zipper []) and construct my object using Roll (or convert to and from the Free representation) i can use instances over (Zipper []) via (Free (Zipper []))?
23:24:56 <hackrilege> that seems so to me, i just want confirmation, see if im understanding things correctly
23:26:22 <anoe> there is a function (Data.List..) that does this already : chunkAlong 3 1 [0..9] == [[0,1,2], [1,2,3], [2,3,4]..] ?
23:27:29 <hackrilege> whats the 1 for?
23:27:53 <anoe> chunkAlong 4 2 [0..9] == [[0,1,2,3], [2,3,4,5], [4,5,6,7]..]
23:28:32 <Lovepon> anoe: You mean "Is there"?
23:28:55 <anoe> I mean function already written 
23:29:04 <anoe> in a kind of library
23:29:40 <Lovepon> anoe: split package has chunksOf, which you can use to implement that.
23:29:47 <hackrilege> changing the 1 to a 2 at the same time as changing 3 to 4 in that example made it redundant
23:30:11 <hackrilege> whats the 1 for?
23:30:29 <Lovepon> chunksAlong n m xs = take n <$> chunksOf m xs
23:30:30 <Lovepon> Or something.
23:30:49 <Lovepon> chunksAlong n m xs = take . chunksOf m <$> tail xs
23:30:58 <Lovepon> take n.
23:30:59 <anoe> hackrilege: 1 is the difference between the consecutive segments
23:31:07 <Lovepon> @t 
23:31:07 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
23:31:08 <hackrilege> aha!
23:31:09 <anoe> (the left most)
23:31:30 <Lovepon> :t
23:31:40 <hackrilege> so it jumps values?
23:31:44 <anoe> yes
23:32:08 <hackrilege> not in the libraries i cant imagine pretty specialised
23:32:16 <Lovepon> @type \n m xs -> take n . chunksOf m <$> tails xs
23:32:17 <lambdabot> Int -> Int -> [e] -> [[[e]]]
23:32:44 <Lovepon> > (\n m xs -> take n . chunksOf m <$> tails xs) 4 2 [0..9]
23:32:46 <lambdabot>  [[[0,1],[2,3],[4,5],[6,7]],[[1,2],[3,4],[5,6],[7,8]],[[2,3],[4,5],[6,7],[8,9...
23:32:58 <Lovepon> Hm, I wonder what I did wrong.
23:33:20 <Lovepon> > (\n m xs -> map head . take n . chunksOf m <$> tails xs) 4 2 [0..9]
23:33:21 <lambdabot>  [[0,2,4,6],[1,3,5,7],[2,4,6,8],[3,5,7,9],[4,6,8],[5,7,9],[6,8],[7,9],[8],[9]...
23:33:37 <Lovepon> I give up. Lol.
23:34:03 <anoe> :) thanks I think I have everything to find the way
23:34:30 <Lovepon> Oh wait.
23:34:36 <Lovepon> I think I remember what I wanted to do. Lol.
23:34:44 <anoe> :)
23:35:20 <pawws> if i can grasp SICP, will i be able to grasp Knuth?
23:35:45 <hackrilege> chunkAlong 4 2 [0..9] == [[0,1,2,3], [2,3,4,5], [4,5,6,7]..]
23:36:11 <Lovepon> > let every n xs = map head . chunksOf n $ xs in (\n m xs -> take n <$> every m (tail xs)) 4 2 [0..]
23:36:12 <lambdabot>      No instance for (Show a0)
23:36:13 <lambdabot>        arising from a use of ‚Äòshow_M29205926774562470959700‚Äô
23:36:13 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
23:36:14 <kadoban> Keep your pawws off Knuth, I don't think he'll appreciate getting grasped all the time.
23:36:24 <Lovepon> > let every n xs = map head . chunksOf n $ xs in (\n m xs -> take n <$> every m (tail xs)) 4 2 ([0..9] :: [Int])
23:36:25 <lambdabot>      Couldn't match type ‚ÄòInt‚Äô with ‚Äò[a]‚Äô
23:36:25 <lambdabot>      Expected type: [[a]]
23:36:25 <lambdabot>        Actual type: [Int]
23:36:37 <Axman6> yeah books like to be grasped, but Knuth not so much
23:36:41 <Lovepon> Errr
23:37:16 <Lovepon> I'll just stop now.
23:38:14 <bblfish> Is Control.Functor.Algebra somewhere now? It's no longer in category-extras https://hackage.haskell.org/package/category-extras-1.0.2
23:39:06 <Lovepon> > let every n = map head . chunksOf n in every 2 [0..10]
23:39:07 <lambdabot>  [0,2,4,6,8,10]
23:39:17 <Lovepon> Omg. I'm stupid.
23:39:21 <Lovepon> > let every n xs = map head . chunksOf n $ xs in (\n m xs -> take n <$> every m (tails xs)) 4 2 ([0..9] :: [Int])
23:39:22 <lambdabot>  [[0,1,2,3],[2,3,4,5],[4,5,6,7],[6,7,8,9],[8,9],[]]
23:39:31 <Lovepon> tails != tail
23:39:33 <Lovepon> anoe: ^
23:40:13 <hackrilege> > let chunkAlong = (\l n -> [take l x|(i,x) <- zip ((concat.repeat) [0..n-1(tails l),i==0 ]) in chunkAlong 4 2 [0..9]
23:40:15 <lambdabot>  <hint>:1:83: parse error on input ‚Äò,‚Äô
23:40:27 <anoe> Lovepon: ok! nice
23:41:18 <hackrilege> > let chunkAlong = (\l n -> [take l x|(i,x) <- zip ((concat.repeat) [0..n-1]) (tails l),i==0 ]) in chunkAlong 4 2 [0..9]
23:41:19 <lambdabot>      Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚Äò[a1]‚Äô
23:41:19 <lambdabot>      Relevant bindings include
23:41:19 <lambdabot>        x :: [a1] (bound at <interactive>:1:40)
23:44:15 <hackrilege> > let chunkAlong = (\j n l -> [take j x|(i,x) <- zip ((concat.repeat) [0..n-1]) (tails l),i==0 ]) in chunkAlong 4 2 [0..9]
23:44:16 <lambdabot>  [[0,1,2,3],[2,3,4,5],[4,5,6,7],[6,7,8,9],[8,9],[]]
23:44:41 <hackrilege> boom
23:45:25 <pawws> kadoban: how does taocp compare to sicp in terms of difficulty?
23:46:32 <kadoban> pawws: You're already having a conversation about in in ##programming where it seems more appropriate, might as well stick with that.
