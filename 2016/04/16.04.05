00:00:04 <ski> MathuSumMut : it matches `x /= y' with `True'. in case of math failure, that will cause "backtracking" in the list monad
00:00:37 <ski> (iow, abort the generation of `(x,y)' as a result, for this combination of `x' and `y', trying the next alternative, if any)
00:00:45 <kadoban> MathuSumMut: It's not really assigning to True, it's just a pattern match that doesn't actually bind anything to any new names.
00:00:50 <liste> MathuSumMut: <- is not assignment, it's syntactic sugar for >>=
00:01:12 <MathuSumMut> oh, thanks for clarifying :)
00:01:26 <ski> MathuSumMut : instead of `True <- [x /= y]', `guard (x /= y)' could also be used. does the same thing
00:01:47 <liste> MathuSumMut: it desugars roughly to "return (x /= y) >>= \x -> case x of { True -> ... ; _ -> fail "..." }"
00:01:50 <ski> > > [(x,y) | x <- [1,2,3],y <- [1,2,3],x /= y]  -- and this is the same thing, in terms of list comprehensions
00:01:52 <lambdabot>  <hint>:1:1: parse error on input ‘>’
00:02:04 <ski> > [(x,y) | x <- [1,2,3],y <- [1,2,3],x /= y]
00:02:05 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
00:02:12 <ski> @botsnack
00:02:13 <lambdabot> :)
00:02:58 <ski> > fail (error "i don't care") :: [Integer]
00:02:59 <lambdabot>  []
00:03:34 <MathuSumMut> In which module is "guard" located?
00:03:37 <montanonic> MathuSumMut: So yeah, just to clarify, if you only want it to return the tuple (x,y) if x does not equal y, then use the 'guard' function, as mentioned
00:03:45 <ski> @index guard
00:03:45 <lambdabot> Control.Monad
00:03:53 <ski> @hoogle guard
00:03:55 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
00:03:55 <lambdabot> package guarded-rewriting
00:03:55 <lambdabot> Language.Haskell.TH.Lib guardedB :: [Q (Guard, Exp)] -> BodyQ
00:04:26 <MathuSumMut> Cheers (Y)
00:04:27 <montanonic> MathuSumMut: though I'd strongly recommend coming up with a non-monadic way of solving this problem if you aren't familiar with how (>>=) or (>>) work
00:04:55 <MathuSumMut> I'm trying to get familiar with everything all at once
00:05:10 <ski> @type guard
00:05:11 <lambdabot> Alternative f => Bool -> f ()
00:05:21 <montanonic> MathuSumMut: I'm going to plug http://haskellbook.com/ just in case it wasn't on your radar
00:06:31 <montanonic> MathuSumMut: from my experience, do-notation and why Monads are useful, and how those things work with lists, took a while to get to. Building up from more basic functions and not jumping into the deep end was helpful for me.
00:06:47 <MathuSumMut> Thanks, excellent sponsorship ;)
00:07:42 * hackagebot hylogen 0.1.0.4 - a tiny EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.4 (sleexyz)
00:07:42 * hackagebot hylogen 0.1.0.5 - a tiny EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.5 (sleexyz)
00:22:01 <farrt-wader> Hi
00:23:02 <farrt-wader> Anyone here??
00:23:54 <adarqui> me, but i'm useless
00:24:36 <rydgel> farrt-wader: hi
00:24:41 <liste> hi farrt-wader 
00:33:24 <tippenein> stack runghc --localpackage=something lib/Stuff.hs
00:33:28 <tippenein> ^ is that possible?
00:34:34 <tiensonqin> ?src const
00:34:34 <lambdabot> const x _ = x
00:34:42 <tiensonqin> ?help
00:34:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:37:09 <rydgel> tippenein: not sure what you are trying to do, but you can use local packages with Stack if you put the path in stack.yml
00:38:00 * ski looks at tiensonqin
00:38:28 <tippenein> I think my goal is flawed. I want to generate code that my project depends on. so I use the CodeGen module (with a dependency on `Csv`) to generate a Signal module... 
00:39:46 <orb> Is there a way to try ghc 8 via stack?
00:39:51 <Gurkenglas> tippenein, sounds like TemplateHaskell
00:40:45 <tippenein> Gurkenglas: I think you're right :/
00:41:18 <Gurkenglas> ":/ because you didnt find this sooner?
00:41:20 <Gurkenglas> *"
00:41:23 <rydgel> orb: try Stackage Nightly instead of LTS (I'm not sure)
00:41:59 * ski would like something MetaML/MetaOCaml -like, for Haskell ..
00:42:13 <lpaste> tippenein pasted “it's probably TH, eh?” at http://lpaste.net/158599
00:42:30 <Gurkenglas> Yep, very TH.
00:42:49 <tippenein> Gurkenglas: exactly. I should've realized
00:43:15 <orb> Alas, https://www.stackage.org/nightly-2016-04-05 says GHC 7.10
00:43:26 <tippenein> I appreciate your guidance. ignore my poorly chosen emoticons
00:45:05 <Gurkenglas> Aw, I thought you said poorly chosen emotions and thought you realized this ought to be a time for joy :D
00:45:09 * ski would call what tippenein is doing, "grovelling"
00:46:10 <Gurkenglas> wut, no he's headdesking
00:47:36 * hackagebot buildbox 2.1.8.1 - Rehackable components for writing buildbots and test harnesses.  https://hackage.haskell.org/package/buildbox-2.1.8.1 (BenLippmeier)
00:47:41 <tippenein> facepalming, headdesking, whatever image you'd like to conjure
00:48:18 <Gurkenglas> palming is too soft, the spark of realization was instantaneous
00:48:42 <ski> "grovelling" here referring to finding out the list of available signals on the system, and then use that to generate code
00:49:58 <rydgel> orb: you might try this: https://gist.github.com/fizruk/a203aecee813ef513aec
00:50:05 <Gurkenglas> "headdesking" ere referring to finding out out how to use the list of available signals on the system to generate code
00:50:08 <rydgel> orb: it apparently worked for someone
00:50:33 <orb> rydgel: Thanks!
00:51:51 * ski . o O ( <https://www.common-lisp.net/project/cffi/manual/html_node/The-Groveller.html> )
00:51:54 <rydgel> orb: you probably need to change some stuff if you are not on OS X
00:52:40 <orb> I do happen to have an OS X laptop here (even though I do most work mosh-ed into Linux).
00:53:51 <Ashy> mosh is so good
00:58:22 <tippenein> ski: never heard of that one before. v nice
00:58:37 <tippenein> what I'm doing is very similar to groveling
00:59:10 <ski> is why i mentioned it
00:59:42 <ggVGc> why doesn't basically everything just derive Show by default?
01:00:02 <ski> not everything can derive `Show'
01:00:16 <ski> also, even if possible, you sometimes don't want it
01:00:22 <ggVGc> when dpont you want it?
01:00:26 <ski> (for quotient types, abstract types)
01:01:06 <tippenein> Parse error: virtual } Found: [d|data Signal = > $(stuff) deriving (Show) |]
01:01:51 <ski> if you implement `Queue a' in terms of `([a],[a])', then you don't want `show' to enable the user to tell the difference between three queues, which are represented as `([0,1,2,3],[])',`([0,1],[3,2])',`([],[3,2,1,0])', e.g.
01:02:18 <ski> conceptually all those three represent the same queue
01:02:35 <ski> (`(==)' should report them as equal, e.g.)
01:03:49 <ski> iow, you want a custom-written `Show' (if any), for `Queue'
01:04:14 <ski> (for abstract data types in general, you either want a custom-written one, or none at all)
01:04:51 <ski> ggVGc : makes sense ?
01:05:04 <ggVGc> yeah, but I still feel opt-out would be more useful than opt-in
01:05:12 <ggVGc> since for doing anything in ghci you need show
01:05:33 <ski> you don't need `Show' for intermediate values
01:06:27 <ski> .. it might be nice if the interactor could use an internal printing routing that isn't user-callable
01:06:46 <ski> iirc, there's already something like that in GHCi
01:09:05 <ski> ggVGc : "Fortunately, the debugger includes a generic printing command, :print, which can inspect the actual runtime value of a variable and attempt to reconstruct its type." <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html>
01:15:40 <ski> a quotient type conceptually corresponds to the data constructor(s) possibly not being injective, and possibly not being disjoint (aka non-overlapping)
01:17:38 * hackagebot clock 0.7.1 - High-resolution clock functions: monotonic, realtime, cputime.  https://hackage.haskell.org/package/clock-0.7.1 (CetinSert)
01:18:14 <ski> hm .. while a subtype conceptually corresponds to the selector functions possibly not being exhaustive (at least not jointly)
01:22:38 * hackagebot clock 0.7.1.1 - High-resolution clock functions: monotonic, realtime, cputime.  https://hackage.haskell.org/package/clock-0.7.1.1 (CetinSert)
01:25:30 <ggVGc> does anyone have a syntax file for vim that makes a syntax group for type declarations?
01:29:33 <chrisd_> What does it mean for an expression to type-check? for instance this expression 'length (1,2,3)' wont type-check?
01:30:36 <ski> chrisd_ : `length' expects a *list* as argument. `(1,2,3)' is not a list (it's a triple)
01:30:54 <ski> `[1,2,3]' is a list, otoh
01:30:59 <ski> > length [1,2,3]
01:31:00 <lambdabot>  3
01:31:06 <oherrala> :t length (1,2,3)
01:31:07 <lambdabot>     No instance for (Foldable ((,,) t0 t1))
01:31:08 <lambdabot>       arising from a use of ‘length’
01:31:08 <lambdabot>     In the expression: length (1, 2, 3)
01:31:16 <oherrala> that didn't type check
01:31:29 <oherrala> :t length [1,2,3]
01:31:30 <lambdabot> Int
01:31:31 <oherrala> but that did
01:31:37 <oherrala> it's type is Int
01:31:37 <ski> oh, right. recently it's been generalized to also accept foldable things
01:32:10 <chrisd_> so ['a',2,3] wont type check because it contains a Char
01:32:33 <oherrala> chrisd_: or it contains two numbers. whatever way you want to think it :)
01:32:35 <ski> (but triple types apparently aren't instances of `Foldable', for some reason)
01:32:54 <chrisd_> thank you oherrala!
01:32:57 <ski> chrisd_ : right, all the elements of a list has to have the same type. lists are homogenous, not heterogenous
01:33:01 <oherrala> chrisd_: np
01:33:18 <chrisd_> thanks ski, that clears it up for me
01:33:48 <ski> (chrisd_ : lists of the same type can have varying lengths, but not varying element types. tuples of the same type can have varying component types, but not varying "lengths")
01:34:47 <ski> chrisd_ : with tuples (pairs, triples, &c.), you access components by position, and they usually have different roles
01:35:15 <ski> chrisd_ : with lists, the elements usually have basically the same role, and you normally don't access them by position
01:35:37 <ski> usually you treat all the elements of a give list "uniformously", in some sense
01:36:12 <ski> > length (3,5)  -- fwiw
01:36:13 <lambdabot>  1
01:36:27 <tiensonqin> ?src (.)
01:36:27 <lambdabot> (f . g) x = f (g x)
01:36:39 <chrisd_> I see
01:36:42 <chrisd_> Thanks
01:37:17 <ski> > length (3,False,"foo")  -- doesn't work
01:37:18 <lambdabot>      No instance for (Foldable ((,,) t0 Bool))
01:37:18 <lambdabot>        arising from a use of ‘length’
01:37:18 <lambdabot>      In the expression: length (3, False, "foo")    No instance for (Num t0) ...
01:37:50 <ski> @let instance Foldable ((,,) a b) where foldMap f (_,_,z) = f z
01:37:52 <lambdabot>  Defined.
01:37:58 <ski> > length (3,False,"foo")  -- now it works
01:38:00 <lambdabot>  1
01:38:12 <ski> FSVO "works" :)
01:39:00 <ski> chrisd_ : there are (rare) cases where you'd want something more general than homogenous lists, and there are ways to do that (involving defining new data types)
01:39:48 <ski> an example might be if you want a "list", where the first element is an `Integer', the second is a list of `Integer's, the third is a list of lists of `Integer's, and so on
01:40:39 <ski> another example would be if all the elements of the list only need to conform to a common interface (so you use a closure, or an "existential type" then. this is a bit like OO)
01:41:54 <ski> a non-example would be if you have a (de)finite number of different cases of what alternative type each element should be. then you define a new type that expresses this choice between those alternative types
01:42:44 <ski> (the distinction between "example" and "non-example" is a bit blurry here, could be argued one way or the other, for the latter two cases)
01:44:48 <ski> chrisd_ : anyway, an expression type-checks if the type-checker is happy with it, it doesn't violate any type-rules
01:45:23 <ski> chrisd_ : usually (not always) violating a type-rule would mean that there would be a problem at run-time, if the implementation tried to run the code in question
01:46:11 <ski> in some cases, it just means that the code in question is (possibly) ambiguous, the implementation doesn't know which of several alternative interpretations you meant
01:47:40 <ski> in a few rare cases, it means that the type system isn't smart enough (*can't* be smart enough, in general) to realize that your code is ok. more hints may help
01:51:31 <chrisd_> thanks ski, I am just beginning haskell, but I will keep what you have written in mind.
01:52:19 <ski> welcome
01:52:44 <ski> if you don't understand all the details of what i mentioned, no matter
01:53:14 <ski> if you understand some of the rough considerations, then great :)
01:53:17 <m1dnight_> Is there a way to use guards inside a function besides if then if then if then else?
01:53:30 <cocreature> m1dnight_: there is a MultiwayIf extension
01:54:18 <ski> m1dnight_ : there's also `case () of () | blah0 -> bleh0 | blah1 -> bleh1 | ...'
01:54:25 <cocreature> m1dnight_: take a look here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html
01:54:46 <ski> guards (and `where's) can attach to `case' branches
01:58:17 <MathuSumMut> What does the keyword "pure" do in Haskell?
01:58:27 <Peaker> MathuSumMut: it's not a keyword, it's an ordinary library function
01:58:43 <Peaker> MathuSumMut: it's the same as "return" but has a more general type
01:58:54 <kadoban> :t pure
01:58:54 <Peaker> ("return" has a too-specific/wrong type, but it will probably be fixed in the future)
01:58:55 <lambdabot> Applicative f => a -> f a
01:59:03 <kadoban> > pure 5 :: [Int]
01:59:05 <lambdabot>  [5]
01:59:07 <MathuSumMut> ah so it sorta "return" for applicative functors?
01:59:12 <kadoban> Yep
01:59:15 <Peaker> MathuSumMut: exactly that :)
01:59:29 <ski> `pure x' (as well as `return x') is an "action/computation", than, when "executed", "doesn't nothing", and yields `x' as result
01:59:30 <MathuSumMut> Cheers :)
01:59:36 <kadoban> It's 'return' but sounds and acts cooler.
02:00:33 <ski> (er, "doesn't do anything", rather. or "does nothing", if you prefer)
02:03:17 <chrisd_> I am following some exercises and it's asking to show [f x | x <- xs, p x] can be expressed using only map, filter. I have map f (filter p xs), but it is saying to express with composition (.) as well as map, filter. Any ideas?
02:03:53 <ski>      map f (filter p xs)
02:03:59 <ski>   =  (map f) ((filter p) xs)
02:04:08 <ski> @src (.)
02:04:08 <lambdabot> (f . g) x = f (g x)
02:06:09 <Xnuk> @src (&)
02:06:09 <lambdabot> Source not found. stty: unknown mode: doofus
02:06:36 <ski> chrisd_ : that was a hint, in case it wasn't evident
02:06:52 <ski> @quote
02:06:53 <lambdabot> zeiris_ says: I was comparing tox.im (4chan's apparent cryptocat competitor) to the commits logs for OpenBSD's SSL purge. It's a grim state of affairs when a software project started on 4chan looks good in comparison.
02:09:53 <ski> @quote slipped
02:09:53 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
02:10:02 <ski> @quote rules.of.Go
02:10:02 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
02:11:04 <kadoban> wat
02:11:46 <ski> ask Simon Peyton Jones
02:13:19 <Peaker> Xnuk: x & f = f x  (it's infixl 1, just like >>= and <&>)
02:13:56 <Peaker> having these 3 as (infixl 1) is awesome: can write nice forward-reading data pipelines:   foo <&> onRes >>= anotherEff & wrapAction ...  without parens!
02:14:20 <ski> why do you hate round brackets ?
02:15:21 <Peaker> ski: they require more human parsing work to read than left-to-right linear reading
02:16:06 <Peaker> ski: usually I have a newline before each of the operators, so each line does a processing step purely.  Combined with higher precedence lens operators it can do quite a lot with very easy-to-parse code
02:16:06 <Gurkenglas> REG vs CFL, though that parallel may be incidental
02:16:57 <quicksilver> "easy-to-parse"
02:17:06 <quicksilver> only if you know all the precedences you are working with
02:17:21 <quicksilver> and you when you make a precedence mistake you mis-parse it catastrophically
02:17:35 <Peaker> quicksilver: hey! haven't seen you in a while? :)  the nice thing here is that there's only one precedence involved
02:18:33 <quicksilver> hi :)
02:20:44 <chrisd_> ski, can I have another hint? 
02:21:30 <Peaker> chrisd_: do you understand currying?
02:22:13 <Peaker> chrisd_: f x y = ...    is desugared to:  f = \x -> \y -> ...       and   f x y + 5     is parsed as ((f x) y) + 5  which is equivalent to:  ((+) ((f x) y) 5)
02:22:54 <Peaker> chrisd_: it will help to understand this part well
02:23:53 <ski> chrisd_ : replace the `f',`g' in the definition of `.' with two subexpressions (which ?) in your code with `map' and `filter'
02:24:45 * ski has pondered a little about non-transitive precedence for infix operators ..
02:25:57 <Gurkenglas> ski, don't forget the possibiblity of unbalanced precedence https://github.com/aelve/haskell-issues/issues/34
02:26:41 <Peaker> ski: it would be nice perhaps to have only transitivity, no absolute numbering.  Like Perl6, say:  infixl (+) lower than (*)
02:26:54 <Peaker> establish a partial order, not a total order, and complain about ambiguity
02:27:57 <ski> Gurkenglas : fwiw, i'd consider using
02:28:10 <Gurkenglas> All transitivity is expressible through some absolute ordering, see topological sort, although not supplying numbers would allow more asynchronicity between modules
02:28:18 <ski>   asd . (`evalState` initialState) $ do ...
02:28:19 <ski> there
02:28:53 <ski> Gurkenglas : but yes, i was also thinking about "unbalanced precedence" at the time :)
02:29:16 <Gurkenglas> perhaps asymmetric is a better word
02:29:39 <ski> Peaker : yes. and ability to declare operator groups, and be able to relate an operator (or a group) to (everything) in a group
02:30:23 <Gurkenglas> "For every pair of operators on the same level, have a rule that says which operator the term between the operators is bracketed to. If that doesn't parse, complain."
02:30:34 <ski> Gurkenglas : .. i was considering an axiomatization with six laws or something like that, iirc
02:30:54 <Peaker> Do GADTs avoid runtime checks when the compile-time safety allows it?
02:31:34 <Peaker> e.g:  head :: LenList (Succ n) a -> a  --  will it compile to code that directly dereferences the assumed constructor?
02:33:13 <ski> Gurkenglas : consider `a o b p c q d', with `o',`p',`q' infix operators and `a',`b',`c',`d' atomic (for the sake of the argument). a potentially desirable result is that if the expression parses as e.g. `a o (b p (c q d))', then `a o bc q d' (for `bc' another atomic) should parse as `a o (bc q d)'
02:33:42 <ski> Peaker : dunno. good question
02:33:45 <Gurkenglas> -If that doesn't parse+If that diagram isn't commutative
02:35:18 <ski> Gurkenglas : iow, the removal of the interspersing of `p' inbetween `o' and `q' shouldn't change the bracketting wrt `o' and `q'
02:35:38 <ski> Gurkenglas : this is (one instance of) "transitivity"
02:36:03 <Gurkenglas> What I mean by the above line: In "a o b p c q d", the parser would choose one of (o, p) and (p, q) and find out what side the term between them (b or c) belongs to, then repeats that until all is known; what the above line means is that the result should be independent of the parser's choices
02:36:08 <ski> (there's more than two variants of it)
02:37:07 <ski> Gurkenglas : yes. however, the process must be (essentially) nondeterministic. it shouldn't depend on implementation details of the parser
02:37:31 <ski> Gurkenglas : oh, i see you're saying the same thing :)
02:37:40 * hackagebot kdesrc-build-extra 0.1.1 - Build profiles for kdesrc-build  https://hackage.haskell.org/package/kdesrc-build-extra-0.1.1 (ivan)
02:38:09 <Gurkenglas> (The parser would have to check whether the result depends on its choices, so I didnt give it that much nonspecification :P)
02:39:04 <ski> well, i think one could probably set the system up so that if the precedence rules satisfies some laws, then it automatically doesn't matter in which order the parser makes its choice
02:39:52 <chrisd_> (map . filter) xs
02:40:05 * ski found a few interesting papers by Annika Aasa, about operator parsing
02:40:10 <Gurkenglas> You shouldn't restrict the system beyond the axioms, but if you can find a system that allows exactly what the axioms allow, that would be neat
02:40:22 <ski> (also there's a later paper, on Agda parsing, that i think is also relevant)
02:40:33 <ski> Gurkenglas : *nod*
02:40:36 <Gurkenglas> Anyway, round brackets are poopyheads.
02:40:52 <ski> chrisd_ : almost
02:42:26 <ski> Peaker : .. one could also want something like `newtype Foo :: * -> * where FooI :: Foo Int; FooB :: String -> Foo Bool'
02:43:23 <Peaker> ski: but you might still have to use polymorphic Foo vals, so you'd still need the runtime check sometimes, so it's not a 0-cost "newtype"?
02:43:24 <ski> (Peaker : where you can't match on an `Foo a', unless you know what `a' is. specifically, where you know whether it's equal to `Int', and whether it's equal to `Bool')
02:43:32 <Peaker> oh, if that's enforced then ya
02:44:08 <ski> (if you know it's neither, then it's just an empty match. like `EmptyCase')
02:44:10 <Peaker> ski: I'd really like having function spaces and products to be unlifted, so "newtype" wouldn't be needed, and this would be a natural outcome
02:45:07 <ski> (though i suppose `FooI' should also take (one) argument. imagine `[Int]' or something)
02:47:29 <ski> Peaker : sometimes, i think it might be nice if one had `data a -> b = forall env. Clos# (# env , (# env , a #) #-> b #)' (`#->' logically being "strict implication", in terms of programs it's "top-level functions", like C function pointers)
02:49:55 <ski> (in terms of modal logic, `a #-> b' is `[] (a -> b)', where `[]' is a "necessary"-type modal operator that expresses independence of local context (non-globally computed nonlocal variables))
02:50:52 <Peaker> ski: that would constraint the implementation a bit, wouldn't it?
02:50:58 <ski> on the topic of `newtype', i also sometimes think `newtype k (Flip f b a) = MkFlip (k (f a b))' would be nice
02:51:43 <ski> Peaker : it'd be part of the compilers-specific FFI. but still, yes
02:52:01 <Peaker> ski: is it not: newtype Flip k f b a = MkFlip (k (f a b)) ? 
02:53:01 <ski> (this latter would allos `Flip :: forall k0 k1 k2. (k0 -> k1 -> k2) -> k1 -> k0 -> k2'. while the usual `newtype Flip f b a = MkFlip (f a b)' would insist on `Flip :: forall k0 k1. (k0 -> k1 -> *) -> k1 -> k0 -> *')
02:53:05 <ski> Peaker : nope
02:53:42 <ski> (that `Flip' would have kind `forall k0 k1 k2. (k2 -> *) -> (k0 -> k1 -> k2) -> k1 -> k0 -> *')
02:54:41 <ski> the idea being that `Flip f b a' should use the same representation as `f a b', and so `k (Flip f b a)' would also use the same representation as `k (f a b)'
02:55:34 <ski> so, taking `k' to be `[]', if we have a list of type `[Flip f b a]', we would be able to match this on `MkFlip fs', where `fs' is now a list of type `[f a b]'
02:55:59 <Gurkenglas> Hmm. Couldn't you just make "asd . evalState do dsa; sda" behave like "asd . evalState (do dsa; sda)"? That's currently a parse error, so free for the taking.
02:56:14 <Peaker> ski: can't the usual restricted Flip be lifted to the type-level?
02:56:50 <ski> Gurkenglas : well, i'd like that as well (and similar with `foo \x -> ..x..', `foo if ...', `foo case ... of ...', `foo let ... in ...')
02:57:05 <ski> Peaker : not sure what you meany with "lifted to the type-level"
02:57:23 <Peaker> Gurkenglas: allowing "do", lambda, "let", "case", etc to appear as subexpressions (and not just infix argument subexpressions) would be very welcome IMO too. It's weird that it is only allowed as infix args!
02:57:34 <ski> yep
02:57:59 <ski> that would obliterate most of my remaining uses of `$'
02:58:48 <Peaker> ski: sounds like the newtype actually having a value-level value is the problem? Maybe lifting the Flip value to a Type resolves that issue?
02:59:05 <ski> Peaker : do you mean lifting the `flip' value ?
02:59:13 <ski> otherwise i'm not sure what you're getting at
02:59:47 <ski> (also, i'm not sure what you mean by "the newtype actually having a value-level value")
03:00:55 <Peaker> ski: There's a value-level value x :: Flip f a b.   if you lift it (via DataKinds), then x is a type-level term, and "Flip f a b" is a kind, right? Doesn't this help?
03:01:02 <Gurkenglas> (Put that into https://github.com/aelve/haskell-issues/issues/23#issuecomment-205736231 )
03:01:20 <ski> Peaker : i don't see how that is at all related to what i wanted
03:02:20 <ski> .. not sure why  (`evalState` S.empty)  would look stupid
03:02:32 <Peaker> ski: IIUC, you wanted to unretrict the "*" to a polymorphic "k2"
03:02:43 <ski> to a kind variable `k2', yes
03:02:51 <ski> (making `Flip' more polymorphic)
03:03:32 <Peaker> ski: I guess what I am suggesting only changes the restriction from "*" to "BOX" (or whatever the higher level is called)
03:03:33 <Gurkenglas> We've already established we disagree on liking brackets :P (also I dont like that kind of infixing of names)
03:03:52 <Gurkenglas> (in some cases. not sure which.)
03:04:16 <Peaker> Gurkenglas: maybe there should be a:  feedState = flip evalState
03:04:50 * ski sometimes uses `map' in infix
03:04:54 <Gurkenglas> too headspace-pollutey
03:05:08 <Gurkenglas> ski, <$>!
03:05:21 <ski> newfangled thing
03:05:22 <Peaker> I think I use evalState/runState/etc flipped more than unflipped.  But flipping 'runState' would violate the common practice for newtype field names.
03:05:47 * Peaker uses: myList <&> theFunc
03:05:56 <Gurkenglas> But yes for and for_ and traverse_ and traverse are pretty much my only use cases for infixd names
03:05:59 <ski> (also, imho, `<*>' should be renamed to `<$>', and `<$>' to something else. possibly `$>')
03:06:19 <quicksilver> and then what would you rename $> to?
03:06:26 <Gurkenglas> <*> obv
03:06:51 <ski> (`<*>' to me suggests a commutative operation, at least up to the given actions commuting with each other, and commuting pairs)
03:06:52 <Gurkenglas> That shoulda been the April Fools announcement
03:07:30 <ski> quicksilver : i don't recall the the type signature of that one
03:07:38 <quicksilver> it's fmap.const
03:07:52 <quicksilver> > 4 $> ['a','b','c','d']
03:07:54 <lambdabot>      Not in scope: ‘$>’
03:07:54 <lambdabot>      Perhaps you meant one of these:
03:07:54 <lambdabot>        data constructor ‘Seq.:>’ (imported from Data.Sequence),
03:08:01 <Gurkenglas> Peaker, keeping these flipped this way round keeps you motivated to find refactorings to bring your code into a form that doesn't need to flip them
03:08:05 <dsub> :t ($>)
03:08:07 <lambdabot>     Not in scope: ‘$>’
03:08:07 <lambdabot>     Perhaps you meant one of these:
03:08:07 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
03:08:13 <Gurkenglas> @let import Data.Functor
03:08:15 <lambdabot>  Defined.
03:08:21 <quicksilver> > 4 $> ['a','b','c','d']
03:08:23 <lambdabot>      Could not deduce (Num (f a0))
03:08:23 <lambdabot>      from the context (Functor f, Num (f a))
03:08:23 <lambdabot>        bound by the inferred type for ‘e_14’:
03:08:26 <Gurkenglas> https://github.com/aelve/haskell-issues/issues/30
03:08:39 <quicksilver> hmm am I wrong?
03:08:46 <ski> @type fmap . const
03:08:48 <lambdabot> Functor f => b -> f a -> f b
03:08:48 <ski> @type ($>)
03:08:49 <lambdabot> Functor f => f a -> b -> f b
03:08:58 <quicksilver> > 4 <$ ['a','b','c','d']
03:09:00 <lambdabot>  [4,4,4,4]
03:09:01 <quicksilver> ah
03:09:09 <quicksilver> almost right but backwards :)
03:09:16 <M2tias> :t <$
03:09:18 <lambdabot> parse error on input ‘<$’
03:09:25 <M2tias> :t (<$)
03:09:26 <lambdabot> Functor f => a -> f b -> f a
03:09:35 <dsub> so ($>) is simply a "replace"-function?
03:10:07 <ski> what i'd like to call `<$>' is obviously `$' lifted to be idiomatic (iow `liftA2 ($)')
03:10:40 <Peaker> Gurkenglas: not me..  I use:  someComputation \n & (`runStateT` empty) \n <&> _1 %~ processState \n >>= (`runContT` id) \n >>= runMore ...
03:10:51 <quicksilver> yes I understand your reasoning for <$> as <*>
03:10:55 <Gurkenglas> And then automate the wrapping of functions with <> to lift them
03:11:18 <M2tias> > ['a','b','c','d'] $> 4
03:11:20 <lambdabot>  [4,4,4,4]
03:11:24 <M2tias> ok
03:11:32 <ski> Gurkenglas : well .. that's what i invented "reflective syntax" for
03:12:13 <Gurkenglas> (ideally <> would just be an aroundfix operator defined in Control.Applicative)
03:13:55 * ski would like to be able to write something like `[< MkPerson [> parseName <] [> parseAge <] >]' with type `Parser Person'. assuming `data Person = MkPerson Name Age; parseName :: Parser Name; parseAge :: Parser Age'
03:14:27 <ski> (actual concrete syntax for the `[< ... >]' and `[> ... <]' constructions can be debated)
03:14:45 <Peaker> ski: I think Idris has something like this:  (MkPerson !parseName !parseAge)
03:15:00 <ski> yes, but afaiui, there's no outer delimiter
03:15:08 <ski> it is needed
03:15:20 <Peaker> yeah, would be nicer than ad-hoc rules
03:15:42 <Peaker> we'll add some presentation sugaring like this to Lamdu soon :)
03:15:52 <ski> the idea is that you should be able to "mark up" only the nested subexpressions that need to perform effects, using `[> ... <]'
03:16:15 <ski> as opposed to having to mark up the whole path down to them, with `liftAN' stuff (or `<$>' and `<*>')
03:16:29 <Gurkenglas> Would be nice if every change like this came with a bijective script to convert all code everywhere back-and-forth between versions, so you don't need to worry about backwards compatibility
03:16:40 <ski> also, this naturally extends also to `let' and `case' and `if' :)
03:16:47 <Peaker> Maybe:   !(MkPerson ?parseName ?parseAge)     where ? asks for effects, and ! "provides" the effects :)
03:16:56 <ski> Gurkenglas : yep :)
03:17:09 <Gurkenglas> And while I'm dreaming I'd like a pony.
03:17:20 * ski dreams Gurkenglas gets a pony
03:17:30 <ironChicken> is there a better way of saying: and $ map (\(a,b) -> a == b) $ zip xs ys
03:17:58 <ski> ironChicken : one way is `all (uncurry (==)) (zip xs ys)'
03:18:16 <Peaker> ironChicken: and (zipWith (==) xs ys)
03:18:19 <ski> ironChicken : another way is `and (zipWith (==) xs ys)'
03:18:35 <ironChicken> ski, Peaker: thanks
03:18:56 <Peaker> ironChicken: what is this for?
03:19:00 <ski> i don't think there's something like `andZipWith'
03:19:35 <Gurkenglas> That'd be stupid. and .: zipWith (==) is fine
03:19:42 * ski grins
03:21:05 <zaquest> :t (.:)
03:21:06 <lambdabot> (b -> c) -> (t -> a -> b) -> t -> a -> c
03:21:07 <ski> (i don't even recall when i invented `.:',`.::',&c. ..)
03:21:30 <ski> zaquest : `(.:) = (.) . (.)'
03:21:36 <ironChicken> Peaker: erm, my TestSuite: i have a `[Input]` and a `[Output]` and a `f :: Input -> Output` and I mapped f to the [Input] and now I want to check that all the [Input] are (==) to the [Output]
03:21:37 <Gurkenglas> ircbrowse would, but he doesnt like operators for some reason
03:21:45 <ski> zaquest : more comprehensible : `(f .: g) x y = f (g x y)'
03:21:52 <Gurkenglas> (f .: g) x = f . g x, compare (f . g) x = f $ g x
03:21:56 <ski> zaquest : but the former definition explains the name
03:22:31 <ski> (and the number of characters in the name is the number of arguments "passed through" to the right function)
03:22:42 * hackagebot macbeth-lib 0.0.12 - Macbeth - A beautiful and minimalistic FICS client  https://hackage.haskell.org/package/macbeth-lib-0.0.12 (tgass)
03:22:58 <chrisd_> :t (.)
03:22:58 <ski> similarly, `(.::) = (.) . (.) . (.)', meaning `(f .:: g) x y z = f (g x y z)'
03:23:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:23:05 <ski> @type (.::)
03:23:06 <lambdabot>     Not in scope: ‘.::’
03:23:06 <lambdabot>     Perhaps you meant ‘.:’ (line 174)
03:23:13 <Peaker> ironChicken: then why not use == on the lists themselves?
03:23:18 <ski> @let infixr 9 .::; (.::) = (.) . (.) . (.)
03:23:20 <lambdabot>  Defined.
03:23:21 <ski> @type (.::)
03:23:22 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
03:23:30 <Peaker> ironChicken: outputs == inputs  ?
03:23:32 <zaquest> ok, thanks. never met it before :D
03:23:41 <Gurkenglas> I'd say infixr 7 .::
03:23:46 <Peaker> ironChicken: the "zipWith .." approach is not equivalent only because the zip will truncate at the shorter list
03:23:47 <ironChicken> Peaker: hmm, goo point
03:23:54 <Gurkenglas> (Perhaps 8, not sure)
03:24:20 <Peaker> ironChicken: that's why I asked, I was wondering what is the weird thing you're doing that you want this truncation :-)
03:24:27 <ski>   (.) :: (b0 -> b1) -> (a -> b0) -> (a -> b1)
03:24:30 <ski>   (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1)
03:24:32 <ski>   (.::) :: (d0 -> d1) -> (a -> b -> c -> d0) -> (a -> b -> c -> d1)
03:24:42 <ski> zaquest : that may emphasize the pattern more
03:25:15 <ironChicken> i think possibly because i originally had just one test pair, then i decided to add more, and i, um, well just wasn't thinking straight when i updated the == test...?
03:25:22 <ironChicken> that's my excuse anyway :-)
03:26:24 <ski> zaquest : .. they can occasionally be handy. but shouldn't be overused
03:27:01 <ski> zaquest : note that the relatively common pointless pattern `(f .) . g' is `f .: g', and `((f .) .) . g' is `f .:: g', &c.
03:27:29 * ski considers the left hand sides almost as readable as the right hand sides, there
03:27:56 <ski> zaquest : note that some people prefer to generalize it even more, like `(.::) = fmap . fmap . fmap'
03:28:00 <ski> @type fmap . fmap . fmap
03:28:01 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
03:28:02 <Gurkenglas> "(.#!?) f = curryN . (.) f . uncurryN" using http://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html#v:uncurryN
03:29:52 <Gurkenglas> Although I'm dubious on whether it can deduce which Curry instance to use from fs type
03:29:58 <ski> > let (.::) = fmap . fmap . fmap  in  (^2) .:: [[],[[]],[[],[0]],[[],[1],[2,3]],[[],[4],[5,6],[7,8,9]]]
03:30:00 <lambdabot>  [[],[[]],[[],[0]],[[],[1],[4,9]],[[],[16],[25,36],[49,64,81]]]
03:30:14 <ski> might look slightly weird
03:33:19 <ski> SEC should also be mentioned in this context
03:33:21 <ski> @where SEC
03:33:21 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
03:34:19 <ski> one may think of `(.)'/`(.:)'/`(.::)'/&c. as "changing the result of a function, one/two/three/&c. arguments down"
03:34:26 <ski> we can define
03:34:48 <chrisd_> this book says [(*), 0, (+)] doesn't type check, but it does for me?
03:34:59 <ski> @let result :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); result f = (f .)
03:35:01 <lambdabot>  Defined.
03:35:18 <ski> @let argument :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b)); argument f = (. f)
03:35:19 <lambdabot>  Defined.
03:35:57 <ski> @type \f -> (result . argument . result . result) f
03:35:58 <lambdabot>     Ambiguous occurrence ‘argument’
03:35:58 <lambdabot>     It could refer to either ‘L.argument’,
03:35:58 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:174:1
03:36:11 <ski> @let arg = L.argument
03:36:13 <lambdabot>  Defined.
03:36:18 <ski> @type \f -> (result . arg . result . result) f
03:36:19 <lambdabot> (b0 -> b1) -> (a -> (a1 -> a2 -> b1) -> b) -> a -> (a1 -> a2 -> b0) -> b
03:37:44 <ski> this says : "modify" a `a -> (a1 -> a2 -> ...) -> b' with a `b0 -> b1', by "stepping down the type" : first to the result (`(a1 -> a2 -> ...) -> b'), then to the argument of that (`a1 -> a2 -> ...'), then twice down the result of that (reaching `...', where we apply `b0 -> b1')
03:37:56 <zaquest> everything that involves more than one . successively makes me go to ghci and figure out types step by step to understand how it works. so i think .: and .:: are very nice and quite easy to remember :D
03:38:23 <ski> similarly `map :: (a0 -> a1) -> ([a0] -> [a1])' would be used for "stepping inside" a `[...]'
03:38:37 <ski> @type \f -> (result . arg . map . result . result) f
03:38:38 <lambdabot> (b0 -> b1) -> (a -> [a1 -> a2 -> b1] -> b) -> a -> [a1 -> a2 -> b0] -> b
03:38:49 <ski> @type \f -> (result . map . arg . result . result) f
03:38:50 <lambdabot> (b0 -> b1) -> (a -> [(a1 -> a2 -> b1) -> b]) -> a -> [(a1 -> a2 -> b0) -> b]
03:40:31 <ski> you can also define `onLines :: ([String] -> [String]) -> (String -> String); onLines f = unlines . f . lines' and `perLine :: (String -> String) -> (String -> String); perLine = onLines . map'
03:41:00 <ski> you can use them to "focus" on the lines in a string, or on each individual line in turn
03:41:13 <puregreen> and now add “Functor f” to it and you've got lenses :)
03:41:16 <ski> this way also lies lenses
03:41:51 <ski> @where lenses
03:41:51 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-
03:41:51 <lambdabot> structure-access-and-mutation>
03:42:00 <ski> see the above conal post for more info on SECs
03:42:17 <ski> @where TV
03:42:17 <lambdabot> http://www.haskell.org/haskellwiki/TV
03:42:26 <ski> has `onLines',`perLine'
03:42:31 <ski> (where i saw them)
03:42:46 <ski> (TV is otherwise an interesting concept)
03:45:05 <ski> chrisd_ : well, it'll require something strange like `Num (a -> a -> a)'
03:45:29 <ski> @type [(*), 0, (+)]
03:45:30 <lambdabot> (Num a, Num (a -> a -> a)) => [a -> a -> a]
03:45:48 <ski> normally, functions aren't made an instance of `Num'
03:46:18 <ski> (that's why it's left in the type signature there. if there was an instance in scope, then it would have been removed, not commented on)
03:46:29 <Robert___> hello i'm starting learning haskell
03:46:37 <ski> chrisd_ : so, you can only use it, *if* you make sure `a -> a -> a' is an instance of `Num'
03:46:41 <ski> e.g.
03:48:27 <ski> @let instance Num a => Num (rho -> a) where (f + g) r = f r + g r; (f - g) r = f r - g r; (f * g) r = f r * g r; negate f r = negate (f r); abs f r = abs (f r); signum f r = signum (f r); fromInteger n r = fromInteger n
03:48:29 <lambdabot>  Defined.
03:48:35 <ski> then you can say stuff like
03:48:38 <ski> > 2 3 4
03:48:39 <lambdabot>  2
03:48:47 <ski> or
03:49:06 <ski> > map (sin^2 + cos^2) [0,pi/8,pi/4]
03:49:08 <lambdabot>  [1.0,1.0,1.0]
03:49:14 <ski> or
03:49:25 <ski> > map (id^2 - id - 1) [0 ..]
03:49:27 <lambdabot>  [-1,-1,1,5,11,19,29,41,55,71,89,109,131,155,181,209,239,271,305,341,379,419,...
03:50:30 <ski> > (take 3 . map (take 3 . (fst^2 + fst*snd + snd^2))) [[(x,y) | y <- [0 ..]] | x <- [0 ..]]
03:50:32 <lambdabot>      Couldn't match expected type ‘([a], [a])’
03:50:32 <lambdabot>                  with actual type ‘[(Integer, Integer)]’
03:50:32 <lambdabot>      In the expression: [(x, y) | y <- [0 .. ]]
03:50:41 <ski> er, right
03:51:28 <chrisd_> so when the book says it won't type check, it's lying to me?
03:52:59 <Robert___> hi, i'm stating learn haskell and i know how to program in Java and C++ but in haskell i have some problemes for to do : "while(..) do ... 
03:53:18 <Robert___> i have to do a function iteration?
03:53:29 <Robert___> or can i put it on the main?
03:53:54 <ski> > (take 3 . map (take 3 . map (fst^2 + fst*snd + snd^2))) [[(x,y) | y <- [0 ..]] | x <- [0 ..]]
03:53:56 <lambdabot>  [[0,1,4],[1,3,7],[4,7,12]]
03:54:53 <ski> chrisd_ : when it says it won't type-check, it means that it won't type-check (more correctly, there'll be a "missing instance" error), if you try to actually *use* that
03:55:17 <ski> chrisd_ : .. unless you provide such a `Num' instance (as above) naturally
03:55:52 <ski> Robert___ : the most basic way to do iteration/looping in Haskell is via recursion
03:56:06 <liste> Robert___: you can do "action = do { value <- getLine; if value == "hello" then putStrLn "hello" else action }"
03:56:23 <ski> Robert___ : .. which may involve needing to invent a new (helper) function to do that looping
03:56:41 <chrisd_> thanks ski
03:56:55 <ski> Robert___ : there are also library operations for looping, but internally they in the end use recursion as well
03:57:10 <chrisd_> and btw, am I getting closer or further with this one (map f . filter p) xs
03:57:54 <ski> Robert___ : e.g. `forM_'/`mapM_', and also `forM'/`mapM' are popular to use in "monadic contexts", such as `IO' (so `main' is an example of this)
03:58:25 <ski> Robert___ : for various special kinds of list looping, there's also common combinators, like `map',`filter',`foldr',`foldl'
03:58:33 <croben> what does "compare :: Integer -> Integer -> Bool" mean?
03:59:08 <ski> > map (10 *) [0,1,2,3]  -- `map' "does" something to every element of a list. in this case, multiply by ten
03:59:09 <lambdabot>  [0,10,20,30]
03:59:13 <Robert___> thanks ski!!!
03:59:39 <ski> croben : it means that `compare' takes two `Integer's as arguments, and will return a `Bool'. presumably it's doing some kind of order comparision
03:59:42 <Robert___> i will see what kind of thing a can do whit all that you say! thanks ;)
04:00:03 <croben> ski: ah, of course
04:00:08 <croben> thank you ski!
04:00:38 <ski> > filter (>= 5) [1,4,2,8,5,7]  -- `filter' keeps all the elements of a list that satisfy a given condition, here whether they are at least `5'
04:00:39 <lambdabot>  [8,5,7]
04:01:39 <ski> > zip [0,1,2] ["foo","bar","baz"}  -- `zip' joins the corresponding elements of two lists
04:01:40 <lambdabot>  <hint>:1:31: parse error on input ‘}’
04:01:47 <ski> er
04:01:52 <ski> > zipWith  [0,1,2] ["foo","bar","baz"]  -- `zip' joins the corresponding elements of two lists
04:01:54 <lambdabot>      Couldn't match expected type ‘[Char] -> b -> c’
04:01:54 <lambdabot>                  with actual type ‘[Integer]’
04:01:54 <lambdabot>      In the first argument of ‘zipWith’, namely ‘[0, 1, 2]’
04:02:01 * ski sighs
04:02:04 <ski> > zip  [0,1,2] ["foo","bar","baz"]  -- `zip' joins the corresponding elements of two lists
04:02:05 <lambdabot>  [(0,"foo"),(1,"bar"),(2,"baz")]
04:02:34 <ski> > zipWith replicate [0,1,2] ["foo","bar","baz"]  -- `zipWith' is like `zip', but instead of pairing, calls a custom function on each element pair
04:02:35 <lambdabot>  [[],["bar"],["baz","baz"]]
04:03:10 <ski> > replicate 4 "hello"  -- `replicate' is just a nifty function that replicates an element a given number of times, into a list
04:03:11 <lambdabot>  ["hello","hello","hello","hello"]
04:04:14 <ski> > foldr (+) 0 [2,3,5,7]  -- `foldr' can be used to "summarize" the elements in a list. in this case, just summing them, starting from `0'
04:04:15 <lambdabot>  17
04:04:18 <Unhammer> if I have data X = A | B | C, can I make a data Y = A | B so that I can have a function f :: Y → Bool and not worry about handling C?
04:04:34 <ski> `foldl' is, to a first look similar to `foldr'. there are differences
04:04:35 <Unhammer> (ocaml has something like this with polymorphic variants)
04:05:05 <ski> Unhammer : you need `X' and `Y' to be defined in different modules
04:05:12 <ski> (so unrelated types=
04:05:40 <ski> Unhammer : there's no subtyping in Haskell. nor is there any row polymorphism (which is what OCaml "polymorphic variants" employ)
04:06:11 <ski> Unhammer : but if you're fine with `X' and `Y' being unrelated, then you can define such an `f'
04:06:25 <ski> (that's probably not what you wanted, though)
04:06:27 <Unhammer> oh :/
04:07:01 <ertes> Unhammer: you can use abstractions to achieve that, but it requires some manual work for book-keeping (like a type class)…  not a particularly nice solution, but it is sometimes used with lenses
04:07:12 <Unhammer> not really, but no biggie, I'll probably not write any bugs :)
04:07:21 <ski> Robert___ : anyway, several of the most common list "looping" patterns mentioned above can also be done with "list comprehensions" :
04:07:30 <ertes> Unhammer: for example the 'linear' library has a class for vector types that have an x-coordinate
04:07:54 <Unhammer> cool ..
04:08:11 <Robert___> thanks ski!
04:08:11 <ski> > [10 * n | n <- [0,1,2,3]]  -- collect the list of all `10 * n's, where `n' is drawn (in every possible way) from `[0,1,2,3]'
04:08:13 <lambdabot>  [0,10,20,30]
04:09:12 <ski> > [n | n <- [1,4,2,8,5,7],n >= 5]  -- collect all `n's from `[1,4,2,8,5,7]', which satisfy `n >= 5'
04:09:13 <lambdabot>  [8,5,7]
04:10:17 <ski> > [(n,s) | n <- [0,1,2] | s <- ["foo","bar","baz"]]  -- and this is like the `zip'/`zipWith' case
04:10:18 <lambdabot>  [(0,"foo"),(1,"bar"),(2,"baz")]
04:10:46 <ski> > [(n,s) | n <- [0,1,2],s <- ["foo","bar","baz"]]  -- note that if you use `,' instead, you get all ways of pair elements from the two lists
04:10:48 <lambdabot>  [(0,"foo"),(0,"bar"),(0,"baz"),(1,"foo"),(1,"bar"),(1,"baz"),(2,"foo"),(2,"b...
04:11:19 <rydgel> What would be the best datatype to represent a 2D Map (video game). I'm hesitating between a Vector Int or a Vector (Vector Int). Basically I want to be able to get the Int value with a (x,y) coordinates
04:11:25 * ski notices Robert___ left
04:11:58 <ertes> ski: i suppose there's @tell =)
04:12:14 <chrisd_> ski: is this getting closer or completely off (map f . filter p) xs 
04:12:31 <ertes> rydgel: like voxels?
04:12:38 <ski> ertes : well, they used the webchat, so it's doubtful whether they'll be back, and if so, under the same nickname
04:13:13 <rydgel> ertes: yeah kind of, more like raycasting actually, but the tile will always be a 64*64 squares
04:13:17 <ertes> ski: just carefully crafted that irony into a bad joke =)
04:13:31 <ski> chrisd_ : that's exactly it :)
04:13:34 <ertes> rydgel: would a simple array type suffice?
04:13:47 <rydgel> I will need to calculates distances too. So I wonder if there is a package with some kind of Matrix or something that more or less already do this
04:14:12 <ertes> rydgel: distance calculation is simple enough and handled well by the 'linear' library
04:14:17 <chrisd_> awesome! Appreciate the help ski
04:14:22 <rydgel> ertes: That would work yes, but I wonder if I can do better
04:14:53 <rydgel> I went for Vector Int, for performance reason.
04:15:14 <ertes> rydgel: as for the data structure, if position-query and distance is all you need, then arrays should work well…  if you need more complicated things like distance *ordering* or visibility calculation, you could go with BSP trees (simple special case: k-d-trees)
04:15:41 <rydgel> hum BSP.. like doom engine?
04:15:47 <ertes> yeah
04:16:28 <rydgel> ertes: I will go first with the easy raycasting one, and will try BSP after that
04:16:53 <rydgel> ertes: What does provide Array, comparing to for instance Vector?
04:17:37 <rydgel> Oh they do have indices
04:18:14 <ertes> rydgel: the old Array type is defined by the old 'array' library…  you probably shouldn't use that one, because its API is rather poor
04:18:31 <ertes> i would go with Vector and just translate between 2D coordinates and linear array coordinates
04:19:17 <rydgel> ertes: yeah sounds good. So the linear package have functions to help this that's right?
04:19:29 <ertes> toLinear width x y = y*width + x;  fromLinear width = let (y, x) = (`divMod` width) in (x, y)
04:19:46 <ertes> i don't think it does for this specific conversion, but the formula is very simple
04:20:24 <ski> chrisd_ : the derivation is
04:20:28 <ski>      map f (filter p xs)
04:20:31 <rydgel> ertes: nice
04:20:37 <rydgel> ertes: thanks buddy
04:20:42 <ski>   =  (map f) ((filter p) xs)  -- desugaring
04:20:55 <ertes> rydgel: the linear library gives you useful types and functions to work with:  vector types, matrices, etc.
04:21:01 <ertes> rydgel: you're welcome
04:21:24 <ski>   =  ((map f) . (filter p)) xs  -- using `(foo . bar) x = foo (bar x)' backwards, with `foo = (map f)',`bar = (filter p)', and `x = xs'
04:21:40 <ski>   =  (map f . filter p) xs  -- removing redundant brackets
04:22:56 <rydgel> That would be handy to cast rays for sure
04:23:05 * hackagebot bert 1.2.2.5 - BERT implementation  https://hackage.haskell.org/package/bert-1.2.2.5 (RomanCheplyaka)
04:24:06 <ertes> rydgel: if you use 'linear':  toLinear width (V2 x y) = y*width + x;  fromLinear width i = let (y, x) = divMod i width in V2 x y
04:24:20 <ertes> and i just realised the above code had a type error =)
04:24:31 <ertes> :t V2
04:24:33 <lambdabot>     Not in scope: data constructor ‘V2’
04:24:33 <lambdabot>     Perhaps you meant variable ‘_2’ (imported from Control.Lens)
04:34:27 <ggVGc> How many haskells for one Camel
04:34:41 <Axman6> 2.412
04:34:47 <ggVGc> seems fair
04:39:13 <Unhammer> if I have "f (A s) = foobar s; f (B s) = foobar s; f (C s) = fie s", is there a way to combine only the A and B case into one so that all of foobar can be written only once? (or do I have to define foobar at the toplevel?)
04:43:01 <Unhammer> oh with no args at least I can deriving Eq and "f x|x==A=g|x==B=g where g=foobar; f C=fie"
04:43:03 <ertes> Unhammer: no builtin way…  you need a combinator
04:43:22 <ggole> Unhammer: case and where, perhaps
04:43:25 <ertes> but you can have catch-all cases:  f _ = ...
04:43:30 <ggole> Haskell doesn't really seem to support or-patterns properly.
04:43:42 <ertes> not that it will give you the inner 's' though
04:44:06 <Unhammer> oh right it complains about unmatched patterns there
04:44:10 <Unhammer> bah
04:44:49 <ertes> Unhammer: there is an unsafe solution:  give both fields the same name
04:45:13 <ertes> data X = A { theInt :: Int } | B { theInt :: Int } | C String
04:45:18 <Unhammer> :-S
04:45:20 <ertes> f (C s) = fie s
04:45:29 <ertes> f x = foobar (theInt x)
04:45:37 <ertes> (the order is significant)
04:45:53 <Unhammer> looks a bit hacky heh
04:45:56 <ertes> it's an ugly and unsafe solution though, so if you do this often, just write a combinator
04:46:21 <ertes> reduceX :: (Int -> r) -> (String -> r) -> X -> r
04:46:33 <ertes> then you can write:  f = reduceX foobar fie
04:46:58 <Unhammer> hm ok
04:48:18 <ertes> Unhammer: perhaps you could explain your use case; perhaps there is a better solution in general
04:48:49 <ertes> often people are asking for specific techniques, because they are trying to map concepts from other languages to haskell, and they often don't map very well =)
04:53:05 <infinity0> is there a library in haskell that lets me set timeouts in my monad?
04:53:32 <infinity0> e.g i want to write m >>= (settimeout g) >>= h >>= k and if the thing times out between h and k then g gets executed in between there
04:53:44 <infinity0> or after h even, if there's no k
04:59:04 <ertes> infinity0: not quite like that, but there is System.Timeout, which is IO-specific and gives you this pattern: timeout 1000000 (c >>= f >>= g) >>= h
04:59:18 <ertes> the action in the parentheses will be subject to a 1-second timeout
05:00:06 <Unhammer> ertes,  yeah coming from ocaml I probably am doing that :) 
05:00:20 <infinity0> ertes: ah thanks i'll take a look at that. yes would be nice to be non-IO specific, perhaps i can try to generalise that library
05:00:32 <ertes> infinity0: you can with monad-control
05:00:45 <Unhammer> will see if I can find a more concrete example, but so far I'm more playing around
05:00:45 <ertes> infinity0: but you will still have IO sitting at the bottom of the monad stack
05:01:07 <Unhammer> as in, it's not going to cost me more than about 1 line of duplication yet heh
05:01:17 <FAuUiDkld> has anyone worked on github haskell projects yet?
05:01:21 <infinity0> ertes: oh, i can't put in a pure fake clock instead of IO?
05:01:58 <ertes> infinity0: if you do the clock book-keeping in pure code, you can…  but note that pure code won't get access to the real clock
05:02:46 <ertes> infinity0: for example you can let a computation "time out", if it executes a certain monadic action too many times, which is simply stateful programming
05:03:42 <infinity0> ah, i was thinking along the lines of "if now > t and condition Y then P else Q", rather than interrupting a computation
05:04:09 <infinity0> so this really ideally should be pure, and the only impure part would be receiving input of the form "now is t1, now is t2" etc
05:04:22 <ertes> infinity0: you don't necessarily need IO for expressing the action and the timeout, but you need an "interpreter" for your action that does access the real clock and hence needs IO
05:04:31 <infinity0> right, i get that part
05:06:36 <infinity0> ok, i'll take a look at monad-control thanks
05:07:17 <ertes> monad-control *does* need IO within the action though, because it will lift the actual 'timeout' from System.Timeout
05:08:47 <infinity0> ah, i see. ok, then perhaps i will write my own pure version based on those, it's good to have something to start from
05:09:49 <ironChicken> if i create a new mutable vector in runST, can i return that vector? and can i return as an storable vector?
05:09:52 <ertes> the canonical way to do this with the "interpreter" pattern is by using free monads, but there is no inherent need for them
05:10:22 <ertes> ironChicken: see 'create' in Data.Vector.Storable
05:11:15 <Gurkenglas> I'm writing a paper about Alternative for my Bachelor's thesis, but the reviewer doesn't know Haskell. I'm currently writing an introduction of it, and feel like I'm doing a worse job of it than many others have, although I'm ameliorating the issue by trying to limit what I explain to what I use later, and by using examples that my contribution can later improve upon, but is there a usual solution to this problem?
05:12:03 <ironChicken> ertes: ah cool
05:13:20 <c_wraith> ironChicken, ST is designed to prevent mutable things created inside it from being returned from runST
05:14:24 <ertes> c_wraith: there is a pattern to create a mutable vector and then 'freeze' it into an immutable one just before returning from the ST action
05:14:33 <ertes> 'create' is a way to do that without the copying
05:14:49 <ertes> it's basically just a wrapper around unsafeFreeze and runST
05:15:07 <c_wraith> yes, but then you're not returning a mutable structure. 
05:15:34 <ertes> i don't think that's what ironChicken wanted anyway =)
05:16:44 <ironChicken> c_wraith, ertes: so yes, with create i can dispense with original runST
05:16:55 <ironChicken> seems to compile
05:17:55 <ironChicken> and work :-)
05:30:00 <ertes> is there a vector-algorithms variant with effectful comparisons?  simplified: sortBy :: (a -> a -> m Ordering) -> v (PrimState m) a -> m ()
05:34:14 <bennofs> ertes: hmmm... most sortBy functions that I can find in vector-algorithms seems to be effectful already? https://hackage.haskell.org/package/vector-algorithms-0.7.0.1/docs/Data-Vector-Algorithms-Optimal.html for example
05:34:25 <bennofs> or https://hackage.haskell.org/package/vector-algorithms-0.7.0.1/docs/Data-Vector-Algorithms-Intro.html
05:34:46 <bennofs> ertes: oh, I overlooked that you want effectful comparision, sorr
05:35:21 <Peaker> ertes: what's the monad you want to have the effect in?
05:35:45 <ertes> Peaker: the vector's mutation monad would be enough
05:35:57 <ertes> so the type above would work
05:36:04 <ertes> (with appropriate context)
05:36:55 <Peaker> ertes: the comparison function should be pure for the "sort" to be correct -- so it makes sense to bar effects in the comparison.
05:37:23 <Peaker> The unsafety you'd have by being effectful there is perhaps not better than "unsafePerformST" or "unsafeFreeze" on an array you have?
05:37:33 <ertes> Peaker: it needs to be constant during the sort operation
05:37:52 <ertes> Peaker: i could achieve that by first mapping over the vector, but that would add unnecessary cost
05:38:09 <Peaker> can you unsafeFreeze it?
05:38:41 <bennofs> Peaker: can you use an unsafeFreeze'd vector mutably without tawing it first?
05:38:52 <bennofs> s/tawing/thawing/
05:39:17 <ertes> Peaker: sure, how does that help though?
05:39:52 <Peaker> iiuc, ertes doesn't want to mutate the vector during the sort -- only to read from it. So if you do something like:  do { f <- unsafeFreeze v ; res <- sortBy (compareVia f) ; v <- unsafeThaw f ... } ?
05:41:47 <ertes> Peaker: say the elements reference some other resource from which i need to read effectfully
05:42:04 <Peaker> ertes: unsafe freeze that resource too? :)
05:42:34 <Peaker> or you mean you have something like: STArray s (STArray s b)  ?
05:42:40 <jophish> Is there a flag for cabal to stop it warning "The 'license' is AllRightsReserved. Is that really what you want?"
05:42:45 <Peaker> so you'd have to mapM a freeze operation
05:43:41 <ertes> Peaker: a database that doesn't live in haskell at all
05:44:15 <Peaker> ertes: is the database guaranteed to behave purely?
05:45:05 <ertes> Peaker: yes, and i'm well aware of the implications if it doesn't =)
05:45:42 <Peaker> ertes: well, if it is, then it is safe to use unsafePerformIO to access it
05:45:59 <Peaker> if it is not, then you shouldn't use it in the sort function :)
05:48:36 <ertes> that's really ugly though…  there is no technical reason why the comparison can't be monadic, and unsafePerformIO plus the complexity of reconstructing the state of the monad seems like an unnecessarily unsafe and boilerplatey thing to do
05:49:14 <ertes> there should be sortByM with the usual safety disclaimer
05:49:18 <Peaker> ertes: what do you mean "reconstructing the state of the monad" ?
05:49:39 <ertes> Peaker: m ≠ IO, m ≠ ST s
05:53:25 <Peaker> ertes: hmm.. I guess that's useful. It'd probably be Applicative though and not Monad. That would allow parallelizing the sort/actions :)
05:54:41 <ertes> Applicative doesn't allow paralellisation
05:54:53 <ertes> parallelisation
05:55:53 <ertes> only certain monads do, like reader monads
05:56:26 <Peaker> ertes: Applicative CAN be implemented with parallelism in a way that Monad cannot
05:56:49 <Peaker> ertes: and you can choose to run your sort action in an Applicative that does support parallelism
05:56:56 <Peaker> (but if "sortByM" constrains to Monad, you lose that ability)
05:57:14 <ertes> Peaker: unfortunately if the comparison becomes monadic, you will be stuck with Monad
05:57:15 <ondrejj> Hello. I have a data type data T = A | B and want function like f A = True, f B = False but in one function definition as I want to do a lot in the where clause of f. Can this be done with guards somehow?
05:57:57 <ertes> Peaker: but that's fine, because Applicative alone doesn't say anything about parallelism
05:58:18 <Peaker> ertes: if the comparison is in IO, for example, you can wrap it in: https://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html#t:Concurrently
05:58:25 <srhb> ondrejj: float it inwards to a case, for instance.
05:58:39 <ertes> Peaker: you're making assumptions about the comparison action
05:58:51 <Peaker> ertes: true.
05:58:57 <ondrejj> srhb: I forgot to write that I know about using case and a helper function, just wanted to do this in less code (like with guards) :-)
05:59:19 <Peaker> ertes: In any case if you can do it with just Applicative and not Monad (all other things equal) you should prefer Applicative. In some circumstances this can be utilized to get better parallelism (but not only that)
05:59:39 <ertes> Peaker: if i can, i do, especially post-AMP =)
05:59:54 <ertes> but you can't sort applicatively with an applicative comparison function
06:00:56 <srhb> ondrejj: Guards are not a replacement for patterns. You can use pattern guards, but you should just float it inwards like in a case or a helper function.
06:01:11 <ondrejj> srhb: you're right, the case looks neat
06:01:15 <ondrejj> srhb: thank you
06:03:25 <Peaker> ertes: I'm pretty sure you can sort applicatively with an applicative comparison function (e.g: like filterM is actually applicative)
06:06:23 <fr33domlover> In unordered-containers, HashSet is simply a wrapp of HashMap with () as value type, but complexity of operations in the docs are very different - is that a mistake to fix?
06:06:46 <fr33domlover> e.g. M.intersection is O(n * log m) but S.intersection is O(n)
06:06:59 <fr33domlover> but one directly wraps the other :P
06:07:18 <Axman6> sounds like a documentation bug, you should fle a ticket on github
06:08:49 <puregreen> https://github.com/tibbe/unordered-containers/issues
06:17:09 <fr33domlover> I sent the maintainer an email
06:17:19 <fr33domlover> (I don't use githu8)
06:17:24 <ertes> Peaker: depending on your sorting algorithm the indices for reading and/or writing will depend on the outcome of the comparison
06:17:29 <ertes> → monadic
06:18:05 <ertes> Peaker: unless of course you don't do in-place sorting
06:18:53 <Peaker> ertes: I was thinking that if you do some statically-structured sort (e.g: merge-sort) it'd work -- and it will, but it would be the wrong algorithm (it'd have to do more comparisons than sort normally does)
06:19:31 <Peaker> since the comparisons do determine the inputs to the next comparisons to do -- and you don't want to speculatively do all possible comparisons
06:19:44 <ertes> Peaker: let's say you're sorting a 2-element array:  if they are already in order, you do nothing, otherwise you need to swap
06:20:19 <Peaker> ertes: I'm talking about a pure sort like "Data.List.sortBy"
06:20:56 <Peaker> ertes: sortByA :: Applicative f => (a -> a -> f Ordering) -> [a] -> f [a]    is possible but it'll necessarily be a bad algorithm that does way more comparisons than a normal sort would need
06:21:31 <ertes> not necessarily more comparisons, but it will take a detour
06:23:19 <Peaker> ertes: well, consider a subset problem:  minimum4 :: Applicative f => (a -> a -> f Ordering) -> (a,a,a,a) -> f a    instead of a "tournament" that uses 3 comparisons, you'd need more
06:24:31 <Peaker> this can be used as an example of speculative parallelism, if the Applicative parallelizes.  Since Applicative allows you to know ahead of time all the comparisons you'd have AND their inputs -- then you must speculate on all possible comparisons you'd do, you cannot have the next comparison decide based on previous comparisons
06:25:10 <cmotoche> Hello guys I'm getting an ghc panic error when compiling a module with more than 5 queries written with QuasiQuotes (e.g. [sql|SELECT id, name FROM users|]). Do you know what could be the problem? Here is the error:
06:25:12 <lpaste> Cmotoche pasted “Error with QQ” at http://lpaste.net/158615
06:25:31 <ertes> Peaker: i see it, yeah
06:26:35 <ertes> anyway, that diverges from my actual problem…  i'll try to extract a pure "size" for each element and put that into a vector for now
06:26:35 <Peaker> ertes: this nicely shows the fact that sort parallelization cannot really parallelize all the comparisons (without tons of speculation), but only parallelize some of the work (e.g: sub-arrays)
06:27:14 <Peaker> (if a solution can parallelize all of the OP operations in it, then the solution can have OP in Applicative and compose it applicatively)
06:49:01 <benzrf> what kind of haskell TUI libs are there
06:52:43 <dbushenko> benzrf, vty?
06:54:10 <cocreature> there is also brick which builds upon vty
06:54:36 <benzrf> hm
06:55:05 <fr33domlover> benzrf: vty, brick, several ncurses bindings
06:55:42 <benzrf> is there much in the way of high level stuff
06:55:47 <fr33domlover> i'd start with brick, it's declarative and high level
06:56:11 <fr33domlover> if you want a terminal alternative to GUI, brick is probably the best
06:56:15 <fr33domlover> you get ready widgets
06:56:25 <fr33domlover> much like GTK+ gives you GUI widgets
07:01:09 <sm> brick is great
07:01:47 <sm> doesn't work on windows yet, but maybe soon
07:03:18 <ertes> benzrf: there is also vty-ui with a very awkward interface that you can make nice using reactive-banana
07:03:53 <ertes> i don't like it much though
07:04:36 <ertes> brick looks much better; haven't tried it myself
07:13:14 * hackagebot ctpl 0.1.0.4 - A programming language for text modification.  https://hackage.haskell.org/package/ctpl-0.1.0.4 (implementation)
07:15:15 <Pennyw95> Hi...could you help with this? it's probably simple but I'm very new... http://pastebin.com/VMmyjcX3
07:18:16 * hackagebot chatty-text 0.6.2.1 - Provides some classes and types for dealing with text, using the fundaments of Chatty.  https://hackage.haskell.org/package/chatty-text-0.6.2.1 (implementation)
07:20:20 <chelfi> Pennyw95: in your line [] : (calc l n) : (calculate l (n - 1)), [] is a list, calc l n is an Int, so basically you are trying to use (:) as a [a] -> Int - > ?
07:20:29 <chelfi> > :t (:)
07:20:31 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:20:40 <chelfi> :t (:)
07:20:42 <lambdabot> a -> [a] -> [a]
07:21:00 <Gurkenglas> Pennyw95, why do you need the length of base as a parameter to your function?
07:21:17 <Pennyw95> insted of just using it, you mean?
07:21:20 <Gurkenglas> Yep
07:21:44 <Pennyw95> I thought it would be tidier since I could have a higher function pass that
07:21:45 <Gurkenglas> (...specify "it")
07:21:56 <Pennyw95> I mean, length base
07:22:07 <Gurkenglas> Why do you need length base?
07:22:36 <Gurkenglas> (It would be tidier if a higher function passed base)
07:22:51 <Pennyw95> in case the input number is higher than the length of base
07:23:33 <Gurkenglas> Why do you need an input number? How does the number of repeats of each base element in list depend on some extra number you're given?
07:24:18 <Pennyw95> the number of repeats of each element inside base is what I want this function to return
07:24:30 <Pennyw95> I mean, inside the file sorry
07:24:45 <Pennyw95> that only contains elements that are in base, only repeated
07:24:48 <Gurkenglas> thats the first I hear of a file
07:25:38 <Pennyw95> sorry, I must have missed that....here is the whole code http://pastebin.com/q1BmwTpB
07:25:57 <Gurkenglas> Nah, you gave us that link - is that what you meant by file?
07:26:10 <Pennyw95> no
07:26:27 <Pennyw95> the file a .txt in my pc I want to code to work with
07:27:05 <Pennyw95> the code*
07:28:50 <Pennyw95> so that...the code gets the contents from the files, splits into the strings so that I have a list of strings, and I want the 'calculate' function to return how many repetion of each kind of string there are
07:29:18 <Gurkenglas> How should it decide where to split into strings? At spaces? Newlines?
07:29:29 <Pennyw95> the lines function
07:29:46 <Pennyw95> I do it in hPutStr
07:30:51 <felixsch> why not starting writing a function which gets a list of lines and a string and returns the number of occurences
07:30:57 <Monoid_a-> hi
07:31:05 <felixsch> [String] -> String -> Int
07:31:36 <Pennyw95> but it won't be one number, but as many as the number of different strings contained
07:32:28 <Gurkenglas> You can use a function that produces one number from one String to produce many numbers from many Strings
07:32:49 <Gurkenglas> :t map
07:32:50 <lambdabot> (a -> b) -> [a] -> [b]
07:33:34 <Pennyw95> oh...that's right
07:34:10 <broma0> when using wreq from a ghcjs compiled webapp, how can i request the server without providing the full url? id like to write 'get "/login"' but it fails with "invalid URL" 
07:34:37 <Pennyw95> how would you count the number of repeats of a string? maybe a foldl with a == guard?
07:35:33 <Gurkenglas> :t length $ filter even [1..10] -- I'd do it like so
07:35:35 <lambdabot> Int
07:35:45 <Gurkenglas> > length $ filter even [1..10] -- That's what I meant to tell lambdabot
07:35:47 <lambdabot>  5
07:36:36 <Gurkenglas> > sum $ map (\x -> if even x then 1 else 0) [1..20] -- But of course there are other ways
07:36:38 <lambdabot>  10
07:36:58 <Gurkenglas> :t [sum, foldl' (+) 0] -- And your way would have worked.
07:36:59 <lambdabot> (Num a, Foldable t) => [t a -> a]
07:37:18 <Gurkenglas> *would work too, no need to use mine :P
07:37:19 <Pennyw95> before that actually...I could also have the code count the number of variations in the file instead of relying on the 'base' list, right?
07:37:46 <Gurkenglas> If you know that the file has equal elements right next to each other, yes
07:37:53 <Gurkenglas> :t map length . group
07:37:54 <lambdabot> Eq a => [a] -> [Int]
07:38:12 <Gurkenglas> > map length $ group [1, 1, 1, 5, 5, 5, 5, 2, 2, 0]
07:38:14 <lambdabot>  [3,4,2,1]
07:38:35 <Pennyw95> hmm no I don't care about the order...but maybe a smart solution would be sort the different elements into different lists and then have the lengths of each
07:39:00 <Gurkenglas> :t map length $ group $ sort [1,2,3,4,5,2,4,6,8,10] -- Yep that works too
07:39:01 <lambdabot> [Int]
07:39:09 <Gurkenglas> > map length $ group $ sort [1,2,3,4,5,2,4,6,8,10] -- Dammit keep doing :t
07:39:10 <lambdabot>  [1,2,1,2,1,1,1,1]
07:39:54 <Pennyw95> nice :D
07:40:07 <Gurkenglas> At your service.
07:40:47 <Pennyw95> thank you alot :)
07:41:48 <Pennyw95> I hope I can do the rest by myself, thanks for you time
07:41:56 <Gurkenglas> Dangit that must have sounded like I am sarcastically demanding thanks. Can't manage to do the subservient thankless genie
07:42:10 <Gurkenglas> Maybe I should pretend I'm a bot so people won't thank me
07:42:32 <k_bx> Hi! Does anyone know if there’s a way to determine current thread’s PID, the one that’s shown in top/htop? Or maybe some other way to resolve my problem? One of my threads is eating CPU, I’d like to figure out which one, so my plan was to forkOS those threads instead of forkIO and check out which’s PID is consuming CPU, but it seems that I see no way determining PID.
07:42:34 <Pennyw95> idk...I think I'd have done it anyway
07:42:36 <Gurkenglas> I mean, maybe I should write a bot that people can ask to implement things.
07:44:33 <Gurkenglas> k_bx, *googles* could you use https://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-Process.html#v:forkProcess ?
07:44:50 <k_bx> Gurkenglas: looking at that one as well, thank
07:44:51 <k_bx> *thanks
07:45:01 <Gurkenglas> That's it!
07:45:08 <Gurkenglas> Oh look the bot is already done.
07:45:25 <gurkbot> ask questions, beep
07:48:50 <viaken> How's it feel to be a bot?
07:49:20 <ski> Unhammer : ".., is there a way to combine only the A and B case into one so that all of foobar can be written only once?" -- unfortunately, there's no disjunctive / or- patterns in Haskell
07:49:36 <gurkbot> https://en.wikipedia.org/wiki/Mu_(negative)
07:53:22 <balinkingofmoria> gurkbot : how does one workaround the hSetBuffering bug on Windows?
07:55:04 <Pennyw95> I assume a pure function should not have putStrLn inside?
07:55:27 <Pennyw95> I mean, if the function's purpose is to print values, I should just do it in main or in a minor IO function
07:55:43 <gurkbot> Indeed. Return Strings or whatever to be printed by a higher function.
07:56:31 <gurkbot> balinkingofmoria, simulate pressing of the enter key, I'd guess
07:56:32 <ski> Pennyw95 : every Haskell function is pure
07:56:34 <Pennyw95> is there a builtin function for printing all values of a list in sequence?
07:56:40 <ski> Pennyw95 : including `putStrLn'
07:56:51 <gurkbot> :t mapM_ putStrLn
07:56:52 <ski> Pennyw95 : you can use `mapM_ print'
07:56:52 <lambdabot> Foldable t => t String -> IO ()
07:57:24 <Pennyw95> oh, right..otherwise it will print IO () for every value, right?
07:57:33 <Pennyw95> thanks ski :)
07:57:44 <ski> otherwise what ? if you try what else ?
07:58:13 <Pennyw95> map putStrLn would do that, no?
07:58:20 <ertes> Pennyw95: mapM_ print [x,y,z] = do print x; print y; print z; pure ()
07:58:47 <Pennyw95> sequence $ mapM_ putStrLn myList?
07:58:49 <ski> Pennyw95 : of course gurkbot is right to offer the advice that you should try to keep `IO' out of your "internal computation" functions (which should encompass as large part of your program as is reasonable)
07:59:27 <ski> Pennyw95 : i'm just adding the "counterpoint" to that that `putStrLn' and `print' are also pure
07:59:35 <gurkbot> :t sequence -- IO () is a program. [IO ()] is a list of programs. sequence takes a list of programs and concatenates their instructions, accumulating results. mapM_ id does the same, except you can replace id with other things.
07:59:36 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
07:59:51 <ski> Pennyw95 : `map putStrLn' on a list of strings would give you back a list of `IO ()' (unexecuted)
08:00:09 <Pennyw95> so the best choice is mapM_ becaus it ignores the result?
08:00:14 <ski> later you might decide to execute some of those actions, in some order. perhaps some of them more than once
08:00:14 <ertes> Pennyw95: most of learning haskell boils down to:  look at the types and see if they match up…  if a function needs a String (a string), it's an error to give it an IO String (a program that produces a string)
08:00:18 <gurkbot> :t sequence_ -- Well, this is the one equivalent to mapM_ id. sequence is to mapM id. The _ versions discard results instead of accumulating them.
08:00:19 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
08:00:40 <ski> Pennyw95 : `mapM_' otoh will *combine* all the actions in this list into a *single* action, and return that
08:00:57 <ski> when (if) that action later gets executed, it will execute all the individual actions, in order
08:01:09 <Pennyw95> ok
08:01:35 <ski> Pennyw95 : if you use `mapM' instead of `mapM_', then that final action will insist on collecting the `()' results from the small actions into a list
08:01:50 <ski> Pennyw95 : `mapM_' just ignores the individual `()' results, drops them
08:02:30 <ski> so "so the best choice is mapM_ becaus it ignores the result?" -- yep :)
08:02:45 <Pennyw95> nice
08:03:31 <ertes> Pennyw95: also i recommend not to think in terms of "pure functions" vs. "impure functions"…  you have "functions", and some of them take or return "IO actions"
08:03:48 <ski> Pennyw95 : of course, it happens that you *do* want to collect the results, and then you want `mapM'
08:03:56 * ski seconds ertes
08:04:22 <Pennyw95> so is this correct?  sequence $ mapM_ putStrLn $ map show numbers
08:04:46 <ski> it's important to realize that the printing in `print' doesn't happen between when you call the function, and when it returns the result value (which is an `IO'-action)
08:05:01 <ski> the printing happens when (if) that action later gets executed
08:05:06 <ertes> Pennyw95: let's see if you can figure the answer out by yourself
08:05:17 <ertes> map show numbers :: ?
08:05:26 <Pennyw95> because it's the action that does the side effects, and not the function
08:05:35 <ski> the only way to make an action in a (complete) program get executed is to make sure it becomes part of `main' which is where execution starts
08:05:52 <ski> also, for convenience, if you enter an `IO'-action in the intractor (GHCi), it will also get executed
08:06:34 <Pennyw95> ertes: [a] -> [Char] ?
08:06:38 <ski> Pennyw95 : note that `mapM_ putStrLn (map show numbers)' is equal to `mapM_ (putStrLn . show) numbers' (`.' is function composition
08:06:41 <ski> also
08:06:42 <ski> @src print
08:06:43 <lambdabot> print x = putStrLn (show x)
08:06:47 <ertes> Pennyw95: nope, try again
08:06:58 <ertes> Pennyw95: numbers :: ?
08:07:12 <ski> Pennyw95 : so since `print' is equal to `putStrLn . show', `mapM_ (putStrLn . show) numbers' can further be simplified into `mapM_ print numbers'
08:07:12 <Pennyw95> [Int]
08:07:26 <ertes> Pennyw95: good…  map show :: ?
08:07:32 <Pennyw95> Show a => a -> [String]
08:07:48 <ertes> Pennyw95: nope
08:08:16 <ski> Pennyw95 : now, the type of `mapM_ print numbers' is `IO ()', and this is not a valid input to `sequence' (type error. it wants an `[IO a]', for some type `a')
08:08:19 <Pennyw95> Show a => [a] -> [String]
08:08:49 <ertes> Pennyw95: correct, say a = Int:  map show :: [Int] -> [String]
08:08:59 * ski nods to Pennyw95
08:09:02 <ertes> Pennyw95: does 'numbers' work as an argument to that function?
08:09:19 <ertes> i.e. do the types fit?
08:10:17 <Pennyw95> I'd say yes...although every String would just hold 1 element
08:10:31 <ertes> it's only a question of types right now
08:10:38 <ertes> numbers :: [Int]
08:10:43 * ski has to leave .. have fun
08:10:43 <ertes> map show :: [Int] -> [String]
08:10:49 <ertes> does 'map show numbers' work?
08:11:00 <ertes> have fun ski =)
08:11:28 <Pennyw95> bye :)
08:11:45 <Pennyw95> ertes: yes
08:11:56 <ertes> Pennyw95: good…  map show numbers :: ?
08:12:22 <Pennyw95> [Int] -> [String]
08:12:26 <ertes> nope
08:12:44 <ertes> example:  length :: String -> Int
08:12:49 <ertes> length "blah" :: Int
08:13:00 <ertes> map show :: [Int] -> [String]
08:13:04 <ertes> map show numbers :: ?
08:13:31 <Pennyw95> it does return a [String]
08:13:40 <ertes> it *is* a [String] =)
08:13:47 <Pennyw95> because it starts wiht another lsit
08:13:49 <Pennyw95> list
08:14:14 <ertes> 'map show' is a function from lists of Int to lists of String, you give it a specific list of Int, you get a specific list of String
08:14:33 <Pennyw95> and since numbers :: [Int], the type doesn't use the typeclass show
08:14:55 <ertes> by passing numbers you selected a particular 'a'
08:15:24 <ertes> anyway, this is how basic type reasoning works:  you look at the types
08:15:34 <ertes> and you will find, as ski already revealed, that your example won't compile
08:16:36 <Pennyw95> oh crap
08:16:54 <Pennyw95> "blank" for the file not exists and int for the other, is that it?
08:17:04 <ertes> mapM_ print (map show numbers) :: IO ()  -- the action that prints each of the strings one by one, using 'print'
08:17:52 <ertes> sequence :: [IO a] -> IO [a]  -- does the one on the last line look like a valid argument to this function?
08:18:15 <Pennyw95> no, since it's IO () without a parametrer
08:18:28 <ertes> now that would work:  a = ()
08:18:48 <ertes> sequence doesn't care what 'a' is, that's why it's uncapitalised
08:19:21 <ertes> remember that () is an actual type, just with a weird name =)
08:19:49 <Pennyw95> so sequence could take the result of mapM_ print (map show numbers), which is IO ()?
08:20:22 <ertes> can it?  it expects [IO a], you want to give it IO ()
08:20:40 <Pennyw95> oh *facepalm*
08:22:31 <Pennyw95> hmm and if I want to map show on numbers instead of in the function?
08:22:43 <ertes> answer this one first =)
08:22:57 <Pennyw95> well no
08:23:04 <ertes> why not?
08:23:15 <Pennyw95> one's a list the other's a parameter
08:23:34 <ertes> can you come up with something that *would* be a valid argument to 'sequence'?
08:24:19 <ertes> doesn't matter what, as long as it's well-typed
08:24:27 <Pennyw95> so something that gives [IO ()] from IO ()
08:24:50 <Pennyw95> [] : ?
08:25:07 <ertes> something that *is* of type [IO ()]…  yeah, the empty list would be a correct argument
08:25:10 <Pennyw95> sequence ([] : mapM_ 
08:25:19 <ertes> oh, no, not that
08:25:26 <ertes> sequence []  -- this works
08:25:37 <ertes> sequence wants a list of actions, [] is a list of actions =)
08:25:55 <Pennyw95> I thought you meant how to translate the result of mapM_
08:26:02 <Pennyw95> so that sequence could take it
08:27:21 <ertes> now back to your question: <Pennyw95> hmm and if I want to map show on numbers instead of in the function?
08:27:22 <ertes>  
08:27:28 <ertes> to be honest i didn't quite understand it
08:27:28 <sleblanc> developing with Yesod, is it possible to have it automatically recompile and reload when the code is updated?
08:27:36 <johnw> sleblanc: yes
08:27:46 <johnw> sleblanc: I believe you run "yesod devel" in your project directory
08:29:12 <sleblanc> johnw, I tried that, but it says I need a file "devel.hs"…
08:29:23 <johnw> I'd check the yesod docs then
08:29:28 <johnw> i'm sure this is covered
08:29:44 <Pennyw95> ertes: http://pastebin.com/Mb3HFfRW
08:30:08 <ertes> (try to reduce your usage of ($))
08:30:13 <Pennyw95> basically...numbers is a list of the numbers of repeats of the strings in the file
08:30:23 <Pennyw95> in favour of . ?
08:30:31 <ertes> or even parentheses
08:30:42 <ertes> print (sin x)  -- better than:  print $ sin x
08:31:03 <ertes> (though someone will probably disagree shortly)
08:31:16 <sleblanc> Pennyw95, keep in mind that $ usage is a matter of opinion; it's strongly debated (as ertes pointed out)
08:31:36 <Pennyw95> the thing, is, number is [Char], and I lose the actual information this way, don't I?
08:31:55 <Pennyw95> I mean, when one value ends and the next one begins
08:32:48 <johnw> some of us would prefer print (sin x) but return $ sin x
08:33:19 <maerwald> anyone got syntastic/ghc.mod working with .hsc files?
08:34:19 <ertes> Pennyw95: i wonder if you *want* numbers to be [String], because to me it seems that it would make more sense for it to be [Int]
08:34:32 <ertes> or [Integer]
08:34:39 <Pennyw95> the main reason was to allow numbers to also be "blank"
08:34:46 <Pennyw95> I guess I could just put a 0
08:34:57 <ertes> Pennyw95: have you been introduced to Maybe?
08:35:09 <Pennyw95> oh right that should be better
08:35:32 <ertes> Maybe [Integer]  -- may be a list of [Integer], which sounds right
08:35:54 <ertes> [Maybe Integer]  -- a list of integers with some of them explicitly missing
08:36:12 <Pennyw95> so.. return $ Just $ calcl fileName and return Nothing?
08:36:22 <Pennyw95> without return actually
08:37:25 <ertes> sounds right, yeah
08:38:35 <Pennyw95> ok, so numbers is Maybe [Int]
08:39:07 <Pennyw95> and I'll have putStrLn print "blank" when it gets Nothing
08:39:51 <ertes> sleblanc: i actually $ have $ real difficulty $ parsing $ this, mostly because "$" looks too much like a letter…  i'm only used to it in specific layouting cases like "$ do"
08:40:03 <Hrk> Guys, question about time package: what's causing that the following get's printed when newtype Day has no show instance? https://hackage.haskell.org/package/time-1.6/docs/Data-Time-Calendar.html#t:Day
08:40:08 <Hrk> https://hackage.haskell.org/package/time-1.6/docs/Data-Time-Calendar.html#t:Day
08:40:25 <Hrk> E.g. writing this in GHCI: λ> fromGregorian 1000 1 1
08:40:25 <Hrk> 1000-01-01
08:40:30 <ertes> Pennyw95: yeah
08:41:13 <johnw> ertes: that's just your style though
08:41:15 <ertes> Pennyw95: now of course you could just handle the numbers right away rather than doing the 'numbers <- …; doSomethingWith numbers' thing
08:42:01 <lpaste> Yuras pasted “Unboxing failed” at http://lpaste.net/158620
08:42:07 <Pennyw95> how is this?  case numbers of Nothing -> putStrLn "blank"; Just a -> mapM_ print a
08:42:20 <ertes> Pennyw95: that's correct
08:42:22 <Yuras> could anyone please help me with this issue? ^
08:42:24 <ertes> or looks correct
08:42:46 <ertes> Pennyw95: what i meant is:  you could do the handling right in the 'then' and 'else' branches
08:42:56 <ertes> if … then putStrLn "blank" else …
08:43:06 <Yuras> basically I expect the function to return unboxed Int
08:43:25 <cmotoche> Hello people. I have a doubt. If I have a value: x :: IO (Maybe a) and I have a function f :: a -> IO (Maybe b). What can I do yo apply f to x? So, if x is IO Nothing then the result of f is IO Nothing too.
08:43:35 * hackagebot xlsx 0.2.1.1 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.1.1 (KirillZaborsky)
08:43:56 <johnw> cmotoche: you can use MaybeT to simplify in that case
08:44:06 <johnw> runMaybeT (MaybeT x >>= f)
08:44:23 <johnw> oh, wait, that's not quite right
08:44:27 <johnw> let me find you a better expression
08:45:17 <Pennyw95> ertes: like this?  http://pastebin.com/mmLmYv58
08:45:17 <ertes> johnw: i had raised this in the past, so i'll keep it short:  ($) makes code flat, moreover "$" was a horrible character choice for doing that…  unless there is some inherent "flatness" (a.k.a associativity) to the code i believe you should avoid it like the plague
08:45:35 <johnw> ertes: that's fine, but it's entirely personal
08:45:38 <johnw> ertes: I like $, so I use $
08:45:58 <quicksilver> I use $ to avoid nested parens; I don't always do it when there is only one level of parens
08:46:29 <quicksilver> but I might prefer "map (foo . bar $ x) ll" to "map ((foo . bar) x) ll
08:46:40 <ertes> i use it only in the cases when layout shows the structure: "$ do", "$ \x ->"
08:46:55 <quicksilver> certainly prefer both to map (foo (bar x)) ll
08:46:56 <ertes> Pennyw95: looks like a type error (last line)
08:47:48 <ertes> Pennyw95: pass your program through your compiler/interpreter first
08:48:15 <ertes> Pennyw95: if there is a type error, it's certainly not correct, and you need to get used to reading its error messages
08:48:43 <Pennyw95> okay, now it worked! with print instead of putStrLn
08:48:53 <johnw> cmotoche: runMaybeT (MaybeT value >>= MaybeT . f) might be the easiest, otherwise you have to manage the monadic composition yourself
08:49:02 <ertes> Pennyw95: see if it actually does what you expect it to do
08:50:07 <Shou> Is there any way to use a variable like "mempty" in pattern matching so I don't have to introduce an Eq constraint?
08:50:35 <Pennyw95> it does
08:50:44 <maerwald> Shou: patternsynonyms/viewpatterns
08:50:55 <Pennyw95> I changed to mapM_ print $ calcl (lines contents) and it doe
08:51:03 <quicksilver> but you still need a version of mempty which lets you do a boolean test
08:51:06 <johnw> ertes: and it's fine to suggest personal style choices to newcomers, as long as we clarify that that's not "how everyone does it"
08:51:06 <ertes> Pennyw95: there you go =)
08:51:17 <Pennyw95> thank you, you were very kind :D
08:51:31 <quicksilver> there is no 'isEmpty' function in Monoid or MonadPlus
08:51:34 <hexagoxel> i am used to `$` as an infix operator, and it is easier to parse than any other constructs for me.
08:51:45 <Pennyw95> ertes: uhm wait one last thing
08:51:54 <hexagoxel> also, you can just align the $ on different lines.
08:51:57 <ertes> johnw: i do that because i'm in a support situation and have actual difficulty reading it…  my brain might not support it too well =)
08:51:58 <quicksilver> https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Empty.html
08:52:02 <cmotoche> Thanks johnw 
08:52:09 <ertes> johnw: that wasn't even intended to be a style suggestion
08:52:10 <cmotoche> I'll try it.
08:52:12 <hexagoxel> nesting is complexity, flatness is nice.
08:52:14 <johnw> ertes: kk
08:52:28 <johnw> I finally had to create a $ notation in Coq, because not having it was getting annoying
08:52:51 <johnw> especially with constructions like: forM_ expr $ \x -> ...
08:52:56 <dusan> Hi. Is it please possible to use the Data.Binary.Get monad so that I can directly parse the output of e.g. getWord16be? something like "object <- getWord16be >>= parseWord16toObject"
08:53:06 <Pennyw95> right it prints a column of the repeats of each string...if I wanted to have it print said string for every value before the number?
08:53:19 <dusan> and type type of the parseWord16toObject function is Word16 -> Object
08:53:35 * hackagebot ivory 0.1.0.3 - Safe embedded C programming.  https://hackage.haskell.org/package/ivory-0.1.0.3 (LeePike)
08:54:52 <ertes> johnw: that's fine, i do that, too
08:55:05 <ertes> it's stuff like this that gets me:  f $ g $ h $ x
08:55:39 <cmotoche> Thanks a lot johnw it worked. :D
08:56:18 <srhb> johnw: Did you make it left associative? *ducks*
08:56:36 <ertes> Pennyw95: not sure what you mean…  could you write a little example paste of what it *should* look like?  oh, and note that lpaste.net supports haskell syntax
08:56:41 <johnw> srhb: in my coq-haskell project, I try to copy Haskell as closely as possible, so that the Coq code I write feels like I'm writing Haskell
08:56:52 <srhb> Okay. :-)
08:57:01 <ertes> johnw: btw, do you use coq as a proof assistant?
08:57:05 <johnw> I do
08:57:17 <ertes> i mean:  primarily?
08:57:19 <johnw> yes
08:57:28 <johnw> it's my primary programming language nowadays
08:57:53 <Pennyw95> ertes: http://lpaste.net/158621
08:58:24 <EvanR> johnw: is software foundations really the best manual for that? or is there a better resource for learning coq
08:58:27 <ertes> Pennyw95: i mean, an example of the *output* as you expect it
08:58:29 <Pennyw95> right now it prints a column of the numbers...If i want to also also the correspondent string next to its number of repeats, would this work?
08:58:38 <johnw> EvanR: it's the best way to start.  CPDT (by Chlipala) is the best manual
08:59:08 <johnw> EvanR: also, Programs and Proof by Sergey is another great starting resource
08:59:13 <EvanR> excellent
08:59:35 <Pennyw95> ertes: http://lpaste.net/158621
09:00:10 <Pennyw95> since the string can't be mapped show on, I have to revert to putStrLn?
09:00:15 <ertes> Pennyw95: the *output of your program* as you *would like* to have it =)
09:01:01 <ertes> currently it prints, say, 1\n2\n3, but what would you like it to print?
09:01:18 <Pennyw95> http://lpaste.net/158621
09:02:01 <ertes> Pennyw95: now there is the usual solution that is a bit dirty, but i'm going to give it to you anyway
09:02:32 <ertes> the individual lists that 'group' gives you are never empty:
09:02:35 <johnw> EvanR: btw, if you or anyone else starts Software Foundations, definitely join #coq; we enjoy helping learners there
09:02:39 <ertes> > group "abbcccdddd"
09:02:41 <lambdabot>  ["a","bb","ccc","dddd"]
09:02:53 <ertes> Pennyw95: so it is safe to apply 'head' to them
09:03:06 <EvanR> johnw: nice... i have had difficulty learning idris that way
09:03:28 <ertes> Pennyw95: like this:  map (\strs -> (head strs, length strs))
09:03:49 <EvanR> johnw: which one is better, agda or coq?
09:04:02 <ertes> > map (\chrs -> (head chrs, length chrs)) (group "abbcccdddd")
09:04:03 <lambdabot>  [('a',1),('b',2),('c',3),('d',4)]
09:04:08 <johnw> EvanR: depends on your purpose and your inclination; feel free to ask me that again in #coq so we don't distract people here
09:05:05 <EvanR> ok, but right now i need to get back to the library to claim my computer reservation!
09:06:23 <Pennyw95> but this would give only the first letter of every string, wouldn't it?
09:06:39 <ertes> Pennyw95: i used a list of Char, you're using a list of String
09:06:44 <ertes> it will do the correct thing for you =)
09:07:23 <ertes> > map (\chrs -> (head chrs, length chrs)) (group [2, 2, 3, 3, 5, 7, 7, 7, 7])
09:07:25 <lambdabot>  [(2,2),(3,2),(5,1),(7,4)]
09:08:11 <Pennyw95> Right... I see
09:08:31 <Pennyw95> what's the clean one?
09:08:36 * hackagebot ivory-artifact 0.1.0.3 - Manage additional data files during Ivory compilation.  https://hackage.haskell.org/package/ivory-artifact-0.1.0.3 (LeePike)
09:11:30 <orion> I'm using Pipes.Attoparsec.ByteString and Pipes.Parse to parse <uint16 bytes><that many bytes> from a socket. This line of code blocks until the connection is closed, or I fill up the TCP recv buffer: r <- evalStateT (parse messageParser) pipesProducer <-- How can I modify this line of code such that it returns one message immediately after it's been received?
09:11:57 <orion> If I set the TCP recv buffer to 1, it behaves as I would expect, but that seems very inefficient.
09:11:58 <ertesx> Pennyw95: the clean one involves an additional type and some complexity:  cleanGroup :: (Eq a) => [a] -> [NonEmptyList a]
09:12:21 <johnw> orion: that doesn't feel right
09:12:28 <ertesx> Pennyw95: this is an instance of what we call "boolean blindness"…  safety comes from information the programmer has, but the compiler doesn't
09:12:34 <orion> johnw: I've never used Pipes.Parse before.
09:13:15 <johnw> orion: have you read the pipes-parse tutorial?
09:13:23 <orion> The documentation says, "Connect Parsers to Producers using either runStateT, evalStateT, or execStateT"
09:13:36 * hackagebot ivory-backend-c 0.1.0.3 - Ivory C backend.  https://hackage.haskell.org/package/ivory-backend-c-0.1.0.3 (LeePike)
09:13:41 <orion> I have a Producer and I have a parser.
09:14:09 <johnw> so, evalStateT will "run the whole thing", it won't give you results piecemeal
09:14:30 <orion> 'draw' is looking interesting
09:14:36 <johnw> yes, that's one way to see bits
09:14:47 <johnw> essentially you'd be extending your parser
09:15:06 <orion> The function I'm writing is: readSocket :: Producer ByteString IO () -> IO ByteString
09:15:30 <johnw> that function also won't allow peeking during reading
09:16:11 <Pennyw95> ertesx: okay maybe another time hah
09:16:33 <Pennyw95> is there a cleaner way to achieve this?
09:16:33 <Pennyw95> mapM_ (\_ -> putStrLn "") [1..10]
09:16:44 <orion> johnw: The library I'm using requires that I pass it a 'callback' of type IO ByteString.
09:16:47 <johnw> you could write Producer ByteString IO () -> FreeT (Producer ByteString IO) IO (), which chunks the input from the socket into a series of producers
09:16:55 <ertesx> Pennyw95: replicateM_ 10 (putStrLn "")
09:16:56 <johnw> ah, I see
09:17:11 <johnw> orion: then I wonder if you have conflicting requirements
09:17:23 <johnw> you can easily consume all input and parse it with pipes, but the result waits until the end
09:17:24 <orion> The library is specifically written to not care how the ByteString arrives, only that it arrives.
09:17:32 <johnw> or you can observe results as they happen, but not as a regular IO action
09:17:34 <Pennyw95> ertesx: thanks :)
09:18:38 * hackagebot ivory-eval 0.1.0.3 - Simple concrete evaluator for Ivory programs  https://hackage.haskell.org/package/ivory-eval-0.1.0.3 (LeePike)
09:18:40 * hackagebot ivory-examples 0.1.0.3 - Ivory examples.  https://hackage.haskell.org/package/ivory-examples-0.1.0.3 (LeePike)
09:18:42 * hackagebot ivory-hw 0.1.0.3 - Ivory hardware model (STM32F4).  https://hackage.haskell.org/package/ivory-hw-0.1.0.3 (LeePike)
09:18:54 <johnw> what about: Monoid a => Producer ByteString IO () -> (ByteString -> IO (a, ByteString)) -> IO (a, ByteString)
09:18:54 <orion> johnw: So maybe I can use Attoparsec, but I definitely can not use Pipes.
09:19:07 <johnw> then you can act on the segments as they arrive, while still producing an aggregate
09:19:25 <orion> johnw: That would require changing the library. The signature for the callback is IO ByteString
09:19:41 <johnw> that's ok, just throw away the aggregate result in order to pass it to the library
09:19:53 <johnw> libraryFunction (fmap snd (readSocket myObserver))
09:21:02 <FAuUiDkld> I'm porting a 50 gb database from mysql to oracle!
09:21:13 <FAuUiDkld> in haskell
09:21:19 <FAuUiDkld> ow noes.
09:21:21 <orion> johnw: What is myObserver?
09:21:41 <johnw> orion: some function of yours that might have effects in IO
09:23:38 * hackagebot ivory-opts 0.1.0.3 - Ivory compiler optimizations.  https://hackage.haskell.org/package/ivory-opts-0.1.0.3 (LeePike)
09:23:40 * hackagebot ivory-quickcheck 0.2.0.3 - QuickCheck driver for Ivory.  https://hackage.haskell.org/package/ivory-quickcheck-0.2.0.3 (LeePike)
09:23:53 <orion> I still don't understand what's it's supposed to do.
09:24:08 <johnw> wasn't your original question that you wanted to see the bytes before transmission was complete?
09:24:15 <johnw> otherwise, I've misunderstood the problem you're trying to solve
09:25:39 <orion> The library wants a function of type IO ByteString when it is initialized. When called by the library, that function must return one "message unit", that's it.
09:26:08 <orion> These "message units" are written on the wire as <uint16><that many bytes>
09:27:22 <orion> So, every time this the library calls this function with type IO ByteString, it should read two bytes off the socket, blocking if necessary, parsing those two bytes in to a uint16, and then read that many bytes.
09:27:46 <orion> Then return the resulting ByteString to the library.
09:29:04 <orion> I am unable to forcefully shove bytes at the library. The library makes the call to this callback only when it wants a message.
09:29:23 <johnw> i see
09:29:31 <johnw> the IO ByteString *is* the action that should be producing bits ofdata
09:30:02 <orion> Yes.
09:30:42 <xa0> clever..
09:34:00 * hackagebot ivory-serialize 0.1.0.3 - Serialization library for Ivory.  https://hackage.haskell.org/package/ivory-serialize-0.1.0.3 (LeePike)
09:34:02 * hackagebot ivory-stdlib 0.1.0.3 - Ivory standard library.  https://hackage.haskell.org/package/ivory-stdlib-0.1.0.3 (LeePike)
09:35:18 <ertesx> orion: seems like there is nothing you can do…  same problem with sound libraries
09:35:31 <ertesx> ALSA allows you to write, and if you write too quickly, it blocks
09:35:59 <ertesx> SDL has a callback, so you have to structure your program awkwardly sometimes
09:36:26 <EvanR> you should use ALSA's callback
09:36:29 <EvanR> if possible
09:36:38 <EvanR> blocking I/O for audio doesnt really make sense
09:40:29 <ertesx> EvanR: it helps you to keep things in sync…  callbacks make that awkward, because they are not tied in any way to the rest of your application
09:41:57 <EvanR> I/O is an asynchronous affair
09:42:45 <EvanR> audio callbacks exist to get lower latency when streaming audio
09:43:33 <ertesx> ALSA only blocks, if you overload the buffer…  the equivalent to reducing latency is to decrease the buffer size
09:43:35 <hpc> or to keep audio stable in the first place
09:44:05 <hpc> to see what happens when synchronous audio goes bad, try running a console emulator at half speed
09:44:27 <hpc> suddenly daft punk
09:44:29 <EvanR> if you are blocking waiting to write audio and then begin generating the next chunk of audio, you are losing 1 chunk worth of time
09:44:56 <EvanR> of course you can use a thread to do the next chunk asynchronously
09:45:02 <EvanR> and here we are
09:45:02 <ertesx> hpc: the same happens when your callback can't keep up…  even for the same reason
09:45:15 <ertesx> EvanR: you don't normally block…  blocking is the exceptional case
09:45:26 <EvanR> how would you not normally block?
09:45:39 <ertesx> EvanR: it acts similar to a TBQueue
09:45:48 <EvanR> if you are writing audio as fast as possible, seems like implies an audio drop out
09:45:50 <hpc> interestingly, PCSX is able to stretch audio through lag frames
09:45:58 <ertesx> EvanR: you shouldn't do that
09:46:03 <EvanR> ... ?
09:46:10 <EvanR> then what are you doing? timing it yourself?
09:46:33 <ertesx> yeah, the application is already time-framed
09:46:34 <EvanR> audio is demand driven
09:46:35 <ertesx> usually
09:46:40 <orion> Is there a clever way of using foldl' and Network.Simple.TCP.recv to read *exactly* n bytes off a socket, blocking if necessary?
09:47:02 <orion> recv might return less than the number of bytes you requested.
09:47:05 <ertesx> EvanR: audio isn't really anything by definition…  there are many ways to handle it, and some are better in some situations
09:47:15 <EvanR> the audio sample rate doesnt jive with base ten fractions of the cpu clock
09:47:32 <EvanR> better let the audio system ask you for more data when it sees fit
09:47:32 <hpc> orion: store the bytes in an IORef and block/loop until you have the requisite amount
09:47:52 <ertesx> EvanR: for example a simple command line music player actually would do better just writing as quickly as possible and blocking
09:47:53 <hpc> it's not clever, but it's at least easy
09:48:03 <EvanR> the audio callback is a nice way to do timing too, for an application that wants to keep sound synced
09:48:03 <hpc> and it being IO i wouldn't feel dirty about using it
09:48:22 <EvanR> ertesx: yes that is what i was thinking you were talking about, just write as fast as possible and mostly block
09:48:35 <ertesx> EvanR: and that doesn't line up with vsync, etc…  it's awkward
09:48:36 <EvanR> if youre dumping raw data, that should work
09:48:44 <ertesx> not necessarily bad, just awkward, and there is little you can do
09:48:48 <orion> hpc: Is it bas design to forkIO per TCP connection? Then blocking doesn't affect other connections.
09:49:02 <EvanR> you wouldnt have to worry about vsync is you use an audio callback (and a separate vsync callback)
09:49:15 <hpc> the nice thing about forkIO is you can use it pretty much as much as you damn well please
09:49:21 <EvanR> theres no reason why they should be synced
09:49:24 <hpc> the bottleneck on forkIO is actually memory
09:49:34 <hpc> if it makes sense for your application, go crazy
09:49:59 <EvanR> ertesx: ive only really done audio in a synth context, not an mplayer type context
09:50:12 <hpc> EvanR: ooh, that sounds fun
09:50:39 <EvanR> like zelda 3's audio was generated in real time rather than just mixed samples
09:50:45 <EvanR> .. zelda 64 i mean
09:50:50 <orion> hpc: What if I did something like readExactly :: Socket -> Int -> ByteString -> IO (Maybe ByteString) where the Int is the number of bytes to read and the ByteString is what has been read so far?
09:51:08 <ertesx> EvanR: ditto actually…  my point is that the two are equivalent, and callbacks are always awkward…  not horrible, just awkward, especially if you need to keep multiple of them in sync
09:51:20 <EvanR> multiple audio callbacks?
09:51:36 <ertesx> no, audio and callbacks of other sorts
09:51:57 <EvanR> but that is why concurrent is a good model for all this 
09:52:11 <ertesx> except that callbacks aren't concurrent =)
09:52:20 <EvanR> eh?
09:52:44 <hpc> perhaps not inherently, but they're one of the easiest models for concurrency
09:53:23 <ertesx> well, one of the most awkward things is that the SDL callback is actually made from C and doesn't play well with exceptions
09:54:08 <ertesx> that might be a bug in the binding though…  i don't have much experience with the FFI
09:54:39 <orion> hpc: This avoids an IORef: http://lpaste.net/7128973166726086656
09:59:01 * hackagebot LogicGrowsOnTrees-network 1.0.0.4 - an adapter for LogicGrowsOnTrees that uses multiple processes running in a network  https://hackage.haskell.org/package/LogicGrowsOnTrees-network-1.0.0.4 (GregoryCrosswhite)
10:00:18 <ertesx> how is this handled natively?  i don't suppose you "send" samples to the sound card, do you?  i'd rather expect something along the lines of writing to a mutable audio buffer
10:00:39 <hpc> at what level of abstraction?
10:00:50 <hpc> i can imagine a driver presenting it as a stream you write to
10:00:57 <hpc> which goes to memory that gets DMA'd
10:01:04 <ertesx> operating system, e.g. ALSA
10:02:34 <ertesx> one interesting feature i can imagine, if you can go that low-level, is that you can play something *right now* without having to resort to a minimal buffer size…  you just overwrite the DMA region
10:05:29 <gurkbot> hpc, orion: http://lpaste.net/7128973166726086656
10:08:39 <gurkbot> (But shouldn't that fail if length m > n?)
10:18:20 <joeyh> if I have one source file that needs -O2, will {-# OPTIONS_GHC -O2 #-} make that be used even if cabal is otherwise using -O0?
10:19:27 <geekosaur> it should, yes
10:22:42 <infinity0> suppose i'm writing a supplier of time "Ticker m" where m could be IO, what's the best way to make this compatible with non-blocking operation?
10:23:06 <infinity0> of course i need "get current time" but also "notify me when the next time changes" instead of blocking, i'm wondering what the standard type signature for that would be
10:25:16 <shanemikel> is there a command for stack  to search for packages in the current project's resolver, or list them all, so I can figure out quickly what needs to go into extra deps?
10:26:22 <EvanR> infinity0: er what is "the next time changes"
10:26:29 <EvanR> isnt time always changing?
10:26:54 <AndriusBartulis> Anyone know of a haskell meetup in south west UK? Did a quick lookup in the haskell user group directory but there doesn't seem to be anything close to Bristol :(
10:27:14 <infinity0> EvanR: when the value of the time next changes, i'm splitting it up into discrete ticks
10:27:23 <gurkbot> lpastebot doesn't work?
10:27:31 <gurkbot> hpc, orion: http://lpaste.net/7128973166726086656
10:27:35 <EvanR> infinity0: so you want basically a cron
10:27:48 <gurkbot> (more changes since the last linking - maybe shoulda made another paste)
10:28:41 <infinity0> EvanR: yes but modular and composeable, e.g. I have a timed computation, and I'm writing a runTimed for it, but I realised that this may need to interleave with other stuff like receiving input
10:32:06 <t4nk722> So I'm grading a homework assignment that was done in haskell, and I was wondering if anyone has any advice towards automating this a bit
10:33:15 <dmj`> t4nk722: there's some OCR libraries on hackage
10:34:13 <t4nk722> dmj`: I have access to the source file's they're handing back, so I don't think I need ocr, unless that means something else around here?
10:35:43 <kadoban> t4nk722: Hard to suggest general advice, except I guess look into testing frameworks like quickcheck and hspec or whatever is currently recommended
10:36:34 <dmj`> t4nk722: ah, if you have the source, and each one is a module, you could use the ghc api to map over all the files and attempt to compile them
10:38:45 <t4nk722> dmj`: That's a good idea, at the very least I can order my grading and work on the ones that can compile
10:39:32 <t4nk722> kadoban: I was thinking about using quick check, but I was afraid I'd have to change my imports for each file
10:40:58 <cocreature> t4nk722: you can just import the files they hand in instead of modifying those files
10:41:13 <kadoban> t4nk722: You'd likely have to set up the assignment such that the students need to match some kind of templates for exports such that you don't. i.e. dictate that they must export a function f of type :: Blah -> Blahity Blah
10:41:20 <dmj`> t4nk722: you might even be able to get away with just using bash (or a haskell shell library). If each student named their module StudentName-Hmwk1.hs, you could parse the file name, create a directory for that student, attempt to compile with ghc, then move on. Could write that as a script in haskell.
10:43:28 <t4nk722> hmm I appreciate the thoughts here. I'll probably go ahead and start in on quickcheck with a bit of bash tossed in here or there. Luckily the spec was pretty strict with defined type signatures. Thanks for the help!
10:44:03 * hackagebot propellor 3.0.1 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.0.1 (JoeyHess)
10:44:38 <kbr_> Hello, has anyone previously encountered something like this? (produced by GHC's optimizer)
10:44:43 <kbr_> Rec { $dMonad{v s1SNb}[lid] [Occ=LoopBreaker]   :: base-4.8.2.0:GHC.Base.Monad{tc 28}        (QuickCheck-2.8.2@Quick_6TxL5Cx3o2p0HsyT59KWiD:Test.QuickCheck.Monadic.PropertyM{tc r1KFu}           ghc-prim-0.4.0.0:GHC.Types.IO{tc 32I}) [LclId,  Str=DmdType,  Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,          WorkFree=True, Expandable=True,          Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}] $dMonad{v s
10:44:51 <kbr_> the interesting part
10:44:52 <kbr_> $dMonad{v s1SNb}[lid] = $dMonad{v s1SNb}[lid]
10:46:29 <Pennyw95> Hi...I got stuck a little while trying to work with a list of strings, could you help me? http://lpaste.net/158627
10:48:15 <kbr_> more explanation: from our understanding, the optimizer decides to define a monad dictionary as itself
10:52:51 <piezoid> Hi. How am I supposed to load object code with stack ghci ?
10:53:08 <piezoid> «stack ghci --ghci-options="-dynamic -fobject-code -O"» recompile and loads .o every time
10:53:35 <MarcelineVQ> Pennyw95: Not quite sure what output you're after, did you perhaps want something like this? text = map (\(a,i) -> show a ++ ": " ++ show i) tempText
10:54:21 <gurkbot> Pennyw95, if you're doing this for yourself, you can just pass the [(a, Int)] list to print, it'll give you something that you could paste into code to recover the value
10:58:16 <Pennyw95> well it's form myself but I want to learn how to it
10:58:29 <Pennyw95> doe somethin happen if I apply show on astring?
10:59:29 <infinity0> hmm ok i think i basically need a version of System.Timeout that lets me resume the IO attempt after I've run something in the meantime
10:59:35 <gurkbot> It'll give you a String containing the character sequence to paste into code to recover the value
10:59:45 <gurkbot> > show "Abc"
10:59:47 <lambdabot>  "\"Abc\""
11:00:53 <Pennyw95> ok
11:01:03 <gurkbot> (Passing that String to putStr, just as passing "Abc" to print, will print the five characters "Abc" onto the screen)
11:01:19 <Pennyw95> MarcelineVQ: thank you, that's a very good solution :D
11:01:56 <Pennyw95> I don't get why mapM_ print (text) prints the " as well
11:02:07 <Pennyw95> text is a [String]
11:02:09 <monochrom> print = putStrLn . show
11:02:17 <EvanR> infinity0: are you sure you dont want to cook up some concurrent threading mechanisms
11:03:00 <infinity0> i can't, the same code needs to know both when the time changes and also when it receives input
11:03:30 <EvanR> sorry I can't follow this vague spec ;)
11:03:41 <infinity0> if i run the timeout stuff in another thread, it won't be able to see this input (and vice versa)
11:03:57 <EvanR> code knows, code sees...
11:04:03 <infinity0> hm yeah, i'm thinking in very general terms, i should work up a concrete example
11:05:16 <monochrom> the dilemma of understand a programmer. his natural language skill sucks, and his code so contorted you can't read it either.
11:07:40 <EvanR> so youre saying natural language programming might not be a great idea
11:07:49 <Pennyw95> ok, thank you
11:08:41 <monochrom> not necessarily. people of some other walk of life may make it great
11:11:16 <benzrf> is there a haskell library for working with regular expressions as first-class objects
11:11:24 <benzrf> like, regex ASTs and stuff
11:11:31 <monochrom> Cale may know one
11:11:37 <shanemikel> anybody have the hackage color scheme in their editor?
11:11:47 <EvanR> theres regex-applicative..
11:12:57 <benzrf> EvanR: well, i want to write a tool for building regexes (possibly among other things), and i want to be able to work with them and/or manipulate them at runtime
11:13:05 <shanemikel> oh, well I guess it's different depending on which package you're looking at
11:15:07 <jophish> What on earth is going on here: https://hackage.haskell.org/package/unification-fd-0.10.0.1/docs/Control-Unification.html#v:unify
11:15:15 <jophish> that type signature is a train wreck
11:15:37 <benzrf> jophish: wow that looks like a nice package
11:15:40 <benzrf> i should check it out
11:15:42 <jophish> Why not https://gist.github.com/2737f05afbf2444c540bdc0c061ef775
11:15:55 <jophish> benzrf: yeah, it should be really useful
11:16:53 <benzrf> jophish: presumably if you want some sort of transformer over the bindings reader/state/whatever
11:17:04 <benzrf> like maybe you want to abort unification so you transform it with either
11:17:05 * benzrf shrugs
11:17:43 <jophish> Wouldn't my version do the same (with an appropriate instance for MonadError)
11:20:22 <Gurkenglas> I'm writing a paper about Alternative for my Bachelor's thesis, but the reviewer doesn't know Haskell. I'm currently writing an introduction of it, and feel like I'm doing a worse job of it than many others have, although I'm ameliorating the issue by trying to limit what I explain to what I use later, and by using examples that my contribution can later improve upon, but is there a usual solution to this problem?
11:21:41 <MarcelineVQ> Is that common, for reviewers to not be in the domain they're reviewing, is that intentional so your paper makes sense to a broader audience?
11:22:15 <Gurkenglas> Nope, my university just doesn't do Haskell
11:22:46 <Gurkenglas> I hear that all the remaining academics in Berlin that do functional programming retired like a year ago
11:23:51 <hpc> at the risk of sounding extremely lazy, that sounds like it would make the academic side of writing a thesis much easier
11:24:43 <Gurkenglas> My motivation for writing that thing is drawn from there being an academic problem to solve
11:25:02 <Gurkenglas> I'm in a slog because I have to write a basic introduction.
11:26:04 <Gurkenglas> Is it okay to say in the paper "Fetch that book from our library and read this chapter"
11:26:39 <Gurkenglas> (As in, a thing that's usually done. I would ask the reviewer but he's apparently on a conference for a week)
11:26:40 <Welkin> Gurkenglas: I would say give at least a breif summary, then point them to the relevant resource
11:26:48 <Welkin> brief*
11:27:21 <Gurkenglas> Hm. A mathematical definition not intended to be didactively effective would be nonsloggy
11:28:10 <Welkin> usually you write the introduction last, after everything else has been written
11:28:20 <Welkin> same with the title
11:28:32 <Welkin> it works well for many people
11:29:23 <Gurkenglas> That was my plan @introduction, but the reviewer asked me to write that after apparently misunderstandings about his previous requests
11:29:27 <Welkin> and of course, start with a plain english outline so you don't waste your time going off message
11:34:16 <darkmercenary> hey guys, im writing an api and servant and i want to compile the client code in ghcjs. im not sure how to setup the project in stack so that  can compile the server in ghc and the client in ghcjs without rewriting the stack yaml every single time
11:35:30 <aloiscochard> where is `</>` gone, for working with filepath?
11:37:55 <monochrom> aloiscochard: it is in System.FilePath
11:38:38 <aloiscochard> monochrom: ty!
11:42:55 <infinity0> EvanR: https://gist.github.com/infinity0/ad540e8539d7c23df8d7554d2bd148f4 ok so look at the bottom
11:43:16 <infinity0> so basically the logic is "if i receive a value within T ticks then emit P otherwise Q" and this can be expressed purely
11:43:28 <infinity0> but i'm at a slight loss on how to connect everything up into an IO () so I can actually run it
11:44:01 <infinity0> (nothing is implemented yet, I'm just trying to get the types right, as that's usually the hardest "design" part)
11:44:10 <croben> this code is really slow when i test it (multNat) http://pastebin.com/ScyG8wrA
11:44:15 <croben> any advice?
11:44:24 <infinity0> also i can see a problem, where if i'm blocked on "getLine" then nothing in the Ticked monad actually runs
11:44:43 <infinity0> so that's why I wanted the "System.Timeout" with resume functionality that I mentioned
11:45:10 <infinity0> (yes you can actually `ghci` that file, everything type checks atm)
11:46:05 <infinity0> noddy: ^ you might also be interested in this
11:46:58 <ReinH> croben: what does profiling say?
11:47:48 <monochrom> "data Nat = Z | S Nat" cannot possibly be fast.
11:47:52 <ReinH> croben: and how are you compiling it? With optimizations?
11:48:04 <ReinH> It can't be fast, but it shouldn't be "really slow" either.
11:48:09 <ReinH> It should be reasonably slow.
11:48:21 <ReinH> Well, I don't know what "really slow" means to croben 
11:48:52 <croben> ReinH, 884 seconds
11:48:57 <ReinH> For what input?
11:49:00 <monochrom> that's why I can use my definition. Unary arithmetic is reasonable to be really slow.
11:49:05 * hackagebot ivory-examples 0.1.0.3.1 - Ivory examples.  https://hackage.haskell.org/package/ivory-examples-0.1.0.3.1 (LeePike)
11:49:06 <ReinH> monochrom: :)
11:49:53 <croben> ReinH, it "is associative" $ do
11:49:53 <croben>             property $ \m n o -> multNat m (multNat n o) == multNat (multNat m n) o
11:50:40 <dolio> It's pretty fast for computing the successor.
11:50:55 <ReinH> Well, yeah, that could be generating very large nats depending on how you wrote the Arbitrary instance.
11:51:02 <dolio> And predecessor.
11:51:05 <ReinH> And you don't need a property for that, you can just prove it.
11:51:28 <monochrom> switch to Numeric.Natural
11:51:54 <croben> ReinH, i didn't write the test case
11:52:10 <croben> but i'll ask the guy who did
11:52:34 <monochrom> which takes the fun away from writing your own
11:53:41 <croben> monochrom, i'm not quite there yet
11:54:39 <EvanR> Numeric.Natural seems cool...
11:55:00 <EvanR> i like when half my code is fromIntegral
11:56:17 <monochrom> it is a new addition to base for GHC 7.10
11:56:21 <saml> > let f x = trace ("calling f " ++ show x) x  in f 42 + f 42 + f 42 + f 42
11:56:22 <lambdabot>  Not in scope: ‘trace’
11:57:03 <EvanR> why a value level natural doesnt seem quite right...
11:57:11 <EvanR> its kind of like a non empty list
11:57:58 <EvanR> i guess it makes real the already present possibility that all your Ints could be buggy and be silently negative
11:58:05 <EvanR> by throwing an exception
12:02:41 <apriori> hello guys. is there a stack equivalent for "cabal list"?
12:04:06 * hackagebot exception-transformers 0.4.0.4 - Type classes and monads for unchecked extensible exceptions.  https://hackage.haskell.org/package/exception-transformers-0.4.0.4 (GeoffreyMainland)
12:07:47 <ReinH> EvanR: Nat <=> [()], yes
12:07:54 <ReinH> lists are just decorated natural numbers
12:08:28 <ReinH> Is there an accepted ASCII notation for "is isomorphic to"? ===?
12:08:31 <EvanR> except Numeric.Natural is more like a half-working Integer not a list of S
12:08:50 <EvanR> =~ ?
12:08:58 <Geekingfrog> Is there a way to get a line number when aeson eitherDecode fails? I have a giant json file and it fails on one record somewhere (expecting Integral, encountered Null)
12:09:01 <ReinH> Anyway, they are isomorphic is my point
12:09:03 <EvanR> i use =
12:09:06 <Cale> ~=
12:09:42 <Shou> Why are lists in Alternative just (++) again? I remember there was a reasoning
12:09:54 <Shou> (<|>) = (++) I mean
12:09:59 <ReinH> Shou: if lists represent nondeterministic choice, then <|> is a combination of choices.
12:10:20 <toph> if a catamorphism generalizes folding, what does an anamorphism generalize? i guess unfolding but what is the canonical example of "unfold"?
12:10:22 <EvanR> ReinH: heh... except lists dont have a broken subtract or negation operation
12:10:34 <Cale> toph: unfoldr?
12:10:38 <Shou> ReinH, oh right, thanks
12:10:38 <Cale> :t unfoldr
12:10:39 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:10:47 <ReinH> EvanR: Your issue isn't with Numeric.Natural, it is with Num.
12:10:54 <toph> Cale: thx, i have never used it
12:11:20 <Cale> Here, Maybe (a,b) is used to represent the options of either producing an empty list (Nothing), or producing an element, and proceeding with a new seed (Just (a,b))
12:11:32 <EvanR> ReinH: ... so whats the "non having an issue" interface to Numeric.Natural... succ and isZero
12:11:38 <monochrom> EvanR: analogies are like drugs, except it's nothing like the truth
12:11:49 <ReinH> The subset of Num that makes sense, which we don't currently have as a standard typeclass.
12:12:38 <ReinH> class Peano with succ, plus, mult, isZero, or something.
12:12:40 * ReinH shrugs
12:13:17 <Cale> toph: [a] can be seen as a fixed point of the (type level) function which sends b to Maybe (a,b)
12:13:29 <EvanR> and (n:N) -> (m:N) -> GT n m -> N
12:14:29 <Cale> [()] has (\\) :)
12:14:52 <Cale> > [(),(),(),(),()] \\ [(),()]
12:14:54 <lambdabot>  [(),(),()]
12:15:05 <Cale> > [(),(),()] \\ [(),(),(),(),()]
12:15:07 <lambdabot>  []
12:15:23 <EvanR> is that kind of subtract actually useful
12:15:30 <ReinH> For lists? Sure.
12:15:31 <EvanR> for numbers
12:15:32 <Cale> This kind of subtraction is often actually the notion that you want for natural numbers
12:16:07 <EvanR> if you know that one number is at least as much as another and you use subtract, then saturating might hide a bug
12:16:08 <ReinH> Well, at the very least it is a closed notion.
12:16:17 <Cale> https://en.wikipedia.org/wiki/Monus
12:16:30 <ReinH> Not if you expect subtraction to behave that way.
12:16:47 <EvanR> yes two different operations
12:17:41 <EvanR> ive just never encountered a case where my unsigned numbers would correctly be 0 if i subtracted them the wrong way
12:18:24 <Cale> EvanR: Well, the laws for many operations on lists are most easily written using that form of subtraction.
12:18:41 <EvanR> basically naturals seems like a different use case, if not a different data type from unsigned unbounded machine words
12:18:54 <EvanR> dependent types / math vs computer indices
12:19:06 * hackagebot liquid-fixpoint 0.5.0.1 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  https://hackage.haskell.org/package/liquid-fixpoint-0.5.0.1 (EricSeidel)
12:19:20 <ntnt> how do I store \u2264 (unicode leq) as a haskell string?
12:19:23 <ntnt> a haskell char
12:19:53 <Cale> "The class of all commutative monoids with monus form a variety." -- oh come on, you can't just say that and not explain it... now I have to read this paper :D
12:20:12 <Cale> (which is conveniently paywalled)
12:20:25 <EvanR> baited
12:21:07 <EvanR> monus is defined for arbitrary monoids using that list trick?
12:21:09 <ReinH> decisively smash the academic publishing clique
12:23:21 <chattered> Partial subtraction?
12:23:35 <monochrom> ntnt: "\u2264"
12:23:50 <monochrom> err, not \u, damn python notation
12:23:54 <ntnt> yeah
12:24:04 <ntnt> and also, isn't that a astr ?
12:24:05 <Cale> EvanR: Partially ordered commutative monoids
12:24:08 <monochrom> > "\x2264"
12:24:10 <lambdabot>  "\8804"
12:24:18 <monochrom> "\x2264"
12:24:27 <monochrom> I have never heard of astr
12:24:45 <ntnt> isn't that a string, not a char ?
12:24:53 <ntnt> > head "\x2264"
12:24:55 <lambdabot>  '\8804'
12:24:55 <monochrom> yes. you said string. I give string.
12:25:01 <ntnt> monochrom: my bad
12:25:31 <monochrom> char is '\x2264'
12:36:41 <amalloy> i'm trying to write a simple echo server, with the main "echo the input" function here: https://gist.github.com/amalloy/4ce60d93dd82e6aa8dec8e90e4796230 - it works fine, echoing all my input, until i hit ctrl-d to close the connection. at that point i get the error "Main.hs: Network.Socket.recv: end of file (end of file)". but i thought i was handling that by checking for recv returning 0, based on the documentation for recv. how should i be 
12:39:07 * hackagebot picologic 0.2.0 - Utilities for symbolic predicate logic expressions  https://hackage.haskell.org/package/picologic-0.2.0 (sdiehl)
12:39:23 <hpc> looks like it died from within recv and you have to handle an exception maybe?
12:43:18 <shanemikel> apriori: I literally just asked that question
12:43:20 <shanemikel> I don't think so
12:45:15 <amalloy> i would be very surprised if the only way to detect a socket is closed is to catch an exception thrown when attempting to read from it
12:48:15 <apriori> shanemikel, ok :(
12:48:44 <nineonine> greetings !
12:48:53 <nineonine> FreeT question here
12:49:43 <monochrom> amalloy: Control.Exception has "try" for converting exception to Either. it is possible to perpetually "test for Left", if that's what you want.
12:50:21 <nineonine> http://lpaste.net/158631
12:50:57 <nineonine> i need a function that updates a value in a Functor 
12:51:19 <nineonine> which is used to build FreeT
12:51:43 <monochrom> I don't understand what is "DoSmth".
12:52:12 <nineonine> it is one of the Data constructors
12:52:14 <monochrom> I have doubts about how the b->a field can be used at all
12:52:23 <lyxia> nineonine: I'd start by writing the function that works on MyFreeF
12:52:51 <monochrom> DoSmth is not a data constructor in the posted code
12:53:06 <monochrom> ELICSYS = explain like I can't see your screen
12:53:07 <Wizek> Hey! I have a small haskell app that I would like to run in an environment where memory usage matters. It usually consumes about 4000KB of RAM, but sometimes creeps up to 6000KB or even 8000KB. Sometimes drops back to lower amounts, sometimes stays there. Could it be that the GC is lenient when this happens? Can I somehow set the GC to be more aggressive?
12:54:00 <lyxia> Wizek: you can bound memory usage with rtsopts
12:54:03 <nineonine> hmmm
12:54:34 <nineonine> well in my code DoSmth is
12:54:35 <lyxia> Wizek: which results in the GC being more aggressive because memory gets full faster
12:54:40 <nineonine> RunRequest 
12:54:55 <nineonine> which takes Request and does http request
12:55:12 <nineonine> i want a function that modifies the request object
12:55:35 <Cale> Wizek: In particular you might try +RTS -M5000k
12:55:47 <croben> how can i figure out what m n and o is on line 64
12:55:50 <croben> http://pastebin.com/jvRG04G6
12:55:57 <Wizek> Cale lyxia, thanks giving that a ty
12:56:00 <Wizek> *try
12:56:28 <monochrom> croben: pastebin is double-spacing your code, which wastes my screen space. is it important to double-space your code?
12:56:43 <Cale> croben: If the test fails, it should tell you which values it failed for, no?
12:57:11 <croben> Cale: it doesn't fail, it just takes forever
12:57:50 <simony> woah pastebin
12:58:02 <simony> any reason you don't think it should take a long time to run?
12:59:08 <croben> simony, i never thougth about it like that
12:59:24 <simony> well, also depends on what you mean by "forever"
12:59:28 <Cale> It's generating random Nats according to the Arbitrary instance, and then multiplying them together, resulting in fairly large values, represented in unary
13:00:09 <Cale> You might be able to sculpt the Arbitrary instance somewhat to produce smaller values, or limit the test in some way
13:00:12 <croben> simony, about 900 seconds
13:00:30 <ReinH> There is a Small newtype that can be used, iirc
13:00:52 <croben> Cale: i interpreted it as a sign that i should write better code to test
13:01:08 <shanemikel> apriori: I might request the feature, myself.  In the meantime, I bet there's a rest/json api to stackage; it might be really trivial to write a little script that does that
13:01:18 <Cale> croben: Unfortunately, representing naturals in unary is just going to result in inefficient operations.
13:02:03 <croben> Cale, i see
13:02:19 <croben> well, thanks, that made me feel a bit better about myself
13:07:29 <mrm> On the bright side, increment and decrement are pretty efficient in unary.
13:10:18 <croben> so the problem is that the natural numbers are represented in unary?
13:11:41 <monochrom> there are actually two factors, not just one.
13:12:15 <monochrom> unary contributes half of the slowness. singly-linked immutable list contributes the other half.
13:12:36 <apriori> shanemikel, hm, I never thought of that. good idea
13:12:55 <monochrom> consider unary numbers stored in mutable doubly-linked lists. then addition is constant time, at the expense of losing the original numbers.
13:15:26 <croben> monochrom, i see
13:44:09 * hackagebot Lambdaya 0.3.0.0.0 - Library for RedPitaya  https://hackage.haskell.org/package/Lambdaya-0.3.0.0.0 (ralu)
13:46:30 <nmdanny> question, is there a function that can combine a List a with Maybe a?
13:46:48 <nmdanny> E.g [1,2,3] `func` Just 4 = [1,2,3,4]
13:47:12 <nmdanny> something like mappend but for differing containers?
13:48:08 <mauke> > [1,2,3] ++ maybeToList (Just 4)
13:48:10 <lambdabot>  [1,2,3,4]
13:48:20 <kadoban> :t \xs -> (++xs) . maybeToList
13:48:21 <lambdabot> [a] -> Maybe a -> [a]
13:53:16 <jophish_> kadoban: that prepends the element from the Maybe value
13:53:29 <nmdanny> thanks, another question: is there a built in function to map over a certain element of a tuple?
13:53:59 <nmdanny> like, a way to map "maybeToList" on the second element of (String,Maybe String), giving (String,[String])
13:54:15 <jophish_> nmdanny: if it's a 2-tuple you can use the instance for Bifunctor
13:54:19 <kadoban> jophish_: Yes, which is usually the better idea. If they actually need the specified order, it's easy to change.
13:54:39 <jophish_> kadoban: but it's not what nmdanny asked for :p
13:55:04 <maerwald> or use arrows
13:55:05 <jophish_> nmdanny: if it's something more complex you should take a look at the lens package
13:55:06 <maerwald> > ((+1) *** (+2)) (4,5)
13:55:08 <lambdabot>  (5,7)
13:55:32 <mauke> nmdanny: fmap does that
13:55:48 <maerwald> fmap maps over the second element
13:56:02 <nmdanny> won't it map over the entire tuple?
13:56:21 <maerwald> > fmap (+1) (1,5)
13:56:23 <lambdabot>  (1,6)
13:56:42 <mauke> nmdanny: no, because types
13:56:49 <nmdanny> oh I see
13:58:57 <nmdanny> now that makes me wonder, why does fmapping (+2) over a 2-tuple, only maps the second element?
13:59:10 * hackagebot werewolf 0.5.2.0 - A game engine for playing werewolf within a chat client  https://hackage.haskell.org/package/werewolf-0.5.2.0 (hjwylde)
13:59:11 <maerwald> try to write a functor instance
13:59:20 <maerwald> and you will see it doesn't work
13:59:24 <Cale> nmdanny: Because the Functor you're using is (,) e
13:59:37 <Cale> So, fmap :: (a -> b) -> (,) e a -> (,) e b
13:59:45 <Cale> i.e.  (a -> b) -> (e,a) -> (e,b)
13:59:59 <nmdanny> I understand what is a functor more or less, what I mean is
14:00:12 <nmdanny> why did the authors decided that it is the second element of a tuple, that gets mapped, and not the first one or both of them?
14:00:18 <monochrom> no, listen to Cale's answer, it's right on.
14:00:22 <Cale> They couldn't decide otherwise.
14:00:24 <mauke> the types leave you no choice
14:00:44 <Cale> You can only partially apply (,) to its first argument
14:00:55 <Cale> and the result is an instance of Functor
14:01:49 <Cale> There's no way to write an instance of Functor for "\a -> (a,e)"
14:02:05 <Cale> Without introducing a newtype that flips things around
14:02:59 <nmdanny> hmm I think I kinda understand
14:03:09 <nmdanny> it's like fmap is done like so:
14:03:16 <nmdanny> fmap (*10) $ ((,) 1 ) 2
14:03:37 <monochrom> it is more useful to look at the type rather than the value.
14:03:50 <orion> GitHub is down. :(
14:03:59 <kclancy> I'm having a hard time building my cabal project with -prof so that I can print out stack traces.
14:04:08 <Cale> Yeah, it's really what's going on at the type level rather than the value level which is putting the restriction on things, but that's the value-level reflection of it
14:04:11 <monochrom> at the value you could pretty much write whatever you could imagine, if there were no type-checking.
14:04:25 <kclancy> I add -prof to the ghc-options field in the cabal file.
14:04:26 <monochrom> but there is type-checking. and it has restrictions.
14:04:42 <kclancy> but when I try to build, it is telling me that I need to install profiling libraries for mtl
14:05:07 <kclancy> I don't know where these libraries are, or how to install them
14:05:20 <nmdanny> hmm ok, for now I'll just not fmap over a tuple since it hurts readabillity/understanding too much
14:05:44 <dcoutts> kclancy: cabal has direct support for building profiling libs, use that not ghc-options
14:05:52 <Pennyw95> why doesn't this work?  seconds <- getCurrentTime; add "time.txt" seconds
14:06:05 <Pennyw95> it tells 'seconds' is not in scope...
14:06:14 <Pennyw95> but they are inside the same do block
14:06:25 <Cale> nmdanny: Note also that the Traversable and Foldable instances for pairs act similarly
14:06:36 <Cale> > length ("hello", 6)
14:06:37 <lambdabot>  1
14:06:47 <mmachenry1> Pennyw95:  You should pastebin the code
14:06:51 <dcoutts> kclancy: building profiling libs is somewhat more complicated than just -prof, so the build system has to support it directly.
14:07:01 <kclancy> dcoutts: thanks
14:07:05 <Cale> nmdanny: A pair is a container with one element (the second component), and a label (the first)
14:07:20 <monochrom> Pennyw95: the cause is probably something you haven't thought of. show complete verbatim actual code. show enough that I can reproduce the error.
14:07:41 <nmdanny> a pair is a tuple of 2 elements?
14:07:48 <Pennyw95> never mind, it was just a tab that sneaked on me...sorry
14:07:56 <Cale> nmdanny: yeah, "pair" is just a conventional word for 2-tuple
14:07:56 <monochrom> haha
14:08:10 <mmachenry> Pennyw95: I figured something like that. That's why it's not possible to debug in IRC.
14:08:44 <monochrom> it is important to be scientific. reproducible experiments etc.
14:08:49 <nmdanny> I don't understand what you've meant by length ("hello", 6)
14:08:57 <Cale> :t length
14:08:58 <lambdabot> Foldable t => t a -> Int
14:09:10 <Cale> The new length function takes a container of an arbitrary Foldable type
14:09:47 <Cale> The instance of Foldable for pairs ends up making it the case that every pair has length 1
14:09:59 <Cale> > length [1,2,3,4,5]
14:10:01 <lambdabot>  5
14:10:07 <Cale> > length (1,2)
14:10:09 <lambdabot>  1
14:10:13 <nmdanny> I see,  but that seems kind of arbitrary
14:10:18 <maerwald> Cale: maybe it would've been a better decision to just not implement the functor class if it leads to confusion
14:10:25 <Cale> It's also not arbitrary, for the same reason that fmap isn't.
14:10:47 <monochrom> "Functor (,) e" is neither arbitrary nor useless.
14:10:48 <johnw> a tuple has type (a, b), which has exactly one b.  And though sometimes a ~ b, Functor and Foldable don't know this, so they only know for sure that it always has one b.
14:10:52 <Cale> You just have to think of pairs as being containers which attach a label to a single element
14:11:20 <johnw> yes, I think of them as annotated values, not two element vectors
14:11:22 <monochrom> "Foldable ((,) e)" is not arbitrary either. but this one you could make a case of "too useless to worth the explanation"
14:11:34 <maerwald> Cale: there are a hundred ways to think of them
14:11:39 <Cale> In fact, while I can't say much for Foldable, the Traversable instance for pairs has been essential to me in real-world settings
14:11:41 <maerwald> not just one
14:12:08 <Cale> I can explain where...
14:12:11 <nmdanny> to be clear, (,) is the constructor for a two element tuple?
14:12:34 <Cale> yeah
14:12:40 <mniip> yes, both the data and the type constructor
14:12:42 <Cale> (,) a b  is the same as (a,b)
14:12:42 <monochrom> what is the 99th way of thinking of "Functor ((,) e)"?
14:13:05 <Cale> In reflex-dom, we have  performRequestsAsync :: (Traversable f, MonadWidget t m) => Event t (f XhrRequest) -> m (Event t (f XhrResponse))
14:13:23 <Cale> which is abstracted over an arbitrary Traversable container
14:13:51 <Cale> It takes an Event whose occurrences will provide containers filled with XML HTTP requests
14:14:13 <Cale> and it will give you back an Event whose occurrences will have corresponding containers filled with the responses
14:14:52 <Cale> If you use the pair instance of Traversable with this, it gives you a way to tag the requests with additional data that will come back alongside the response
14:15:34 <nmdanny> Ok,
14:15:40 <nmdanny> traversable can be a container of any size, right?
14:15:43 <Cale> Of course, you could also use the instance for Map k to do a request for every (key,value) pair in a Map, getting back a Map of the results
14:15:55 <Cale> nmdanny: For some instances
14:16:12 <Cale> nmdanny: It depends on which type f is.
14:16:56 <Cale> nmdanny: If f = (,) RequestInfo, then we have performRequestsAsync :: (Traversable f, MonadWidget t m) => Event t (RequestInfo, XhrRequest) -> m (Event t (RequestInfo, XhrResponse))
14:17:11 <Cale> er, sorry, I should have deleted the Traversable constraint there
14:17:21 <Cale> performRequestsAsync :: (MonadWidget t m) => Event t (RequestInfo, XhrRequest) -> m (Event t (RequestInfo, XhrResponse))
14:17:30 <Pennyw95> if I save to a file via 'show' a UTCTIME will I be able to retrieve the value via 'read'?
14:17:32 <Cale> So there, we'd only be sending one request
14:17:47 <nmdanny> in your performRequestAsync, does (f XhrRequest) refer to a container of xhrrequests?
14:17:52 <Cale> yeah
14:18:01 <Cale> a container of an arbitrary Traversable type
14:18:17 <monochrom> Pennyw95: yes. I use it every day. (or rather, I run a program that uses it every day.)
14:18:19 <Cale> So when we use pairs, there's only one request at a time
14:18:47 <Cale> and that request is paired up with additional information that will get associated with the asynchronous response that comes back
14:19:04 <Cale> (perhaps important to be able to tell which request is which)
14:19:13 <glguy> Cale: Whether or not 2-tuples have a Traversable instance is a bit orthogonal to your design there; you could just as well use "data TaggedContainerOfOneThing a b"... when you wanted a thing like a 2-tuple but where the
14:19:14 <Pennyw95> so it's ok to save to a file (show time) and then laoding the file and doing time <- fmap read (readFile myFile)?
14:19:17 <glguy> elements were not peers
14:19:21 <Pennyw95> monochrom:
14:19:22 <Cale> glguy: Oh, sure
14:19:29 <Aruro> which command to haddock cabal uses when installing single package? when option enable docs is on?
14:19:36 <Cale> glguy: We could certainly define our own pair type with a different Traversable instance
14:19:46 <monochrom> yes. but maybe you want readMaybe (Text.Read) just in case of parse errors.
14:19:50 <Cale> glguy: But it turns out that the existing instance for pairs is exactly the thing we might want here
14:19:52 <Aruro> does cabal rebuild whole doc index after single package install?
14:20:35 <Cale> glguy: and of course, it's not like there's a whole lot of choice in how you write a Traversable instance for pairs anyway
14:20:39 <Cale> So it might as well be that
14:20:49 <glguy> Cale: Well, the choice is *if* you write one
14:21:10 <Cale> Yeah, I'm saying applications such as this help to justify the existence of the instance
14:21:17 <glguy> I'm saying they don't
14:21:36 <glguy> You can still have those applications and no co-opt the type
14:21:41 <Pennyw95> monochrom: erm yeah it's giving a 'no parse' error
14:21:54 <Cale> Surely, the only basis on which we can judge whether there ought to be an instance is whether that instance is useful.
14:22:12 <Cale> If the instance has useful applications then it probably ought to exist.
14:22:30 <glguy> We consider both if it's useful and if its harmful
14:22:39 <kadoban> Cale: I would imagine that you'd also want to consider if having the instance has downsides in addition to its upsides (not that I think this one has many).
14:22:46 <nmdanny> I'm still confused about your explanation of traversable and adding labels, you gave two examples
14:22:57 <nmdanny> first you said
14:22:58 <nmdanny> performRequestsAsync :: (Traversable f, MonadWidget t m) => Event t (f XhrRequest) -> m (Event t (f XhrResponse))
14:22:59 <Cale> kadoban: Yeah, sure -- usefulness also is degraded if there are examples where it gets in the way.
14:23:02 <glguy> and if the instance fits the spirit of the type or not
14:23:06 <nmdanny> and then you said
14:23:07 <nmdanny> performRequestsAsync :: (Traversable f, MonadWidget t m) => Event t (RequestInfo, XhrRequest) -> m (Event t (RequestInfo, XhrResponse))
14:23:22 <Cale> nmdanny: Yeah, that's using f = (,) RequestInfo
14:23:31 <monochrom> I am skeptic of "spirit"
14:23:34 <nmdanny> in the first case, f is a traversable container of XhrRequests
14:23:42 <glguy> e.g. it might be a bad idea to have a Num instance for a "newtype UniqueId = UID Int"
14:23:45 <Cale> (,) RequestInfo XhrRequest = (RequestInfo, XhrRequest)
14:24:10 <glguy> if you didn't intend for unique ids to be something one would use for math
14:24:35 <Cale> I've come to think of (a,b) as being Map a b constrained such that it has exactly one element.
14:24:40 <nmdanny> in the second case, do you mean that f is a traversable container of (RequestInfo,XhrRequest)?
14:24:48 <kclancy> dcoutts: I can't find the documentation on how to do this. I added "library-profiling: True" to my cabal.conf, but I am still getting error messages when I try to run the program with the "-xc" option
14:24:55 <monochrom> that one is only because UniqueId is an abstract type whose implementation could change to "UID (Bool -> String)" any day. this reason is irrelevant to Traversable ((,) e).
14:25:18 <Cale> nmdanny: If we have f = (,) RequestInfo, then  f XhrRequest = (,) RequestInfo XhrRequest,  yes?
14:25:31 <Cale> Just substituting that expression for f
14:25:38 <nmdanny> yes
14:25:47 <Pennyw95> is there something wrong on mapping 'show' to a NominalDiffTime?
14:25:50 <Cale> and (,) RequestInfo indeed has a Traversable instance, so we're allowed to do that
14:26:17 <Cale> and (,) RequestInfo XhrRequest is just the prefix notation for (RequestInfo, XhrRequest)
14:27:08 <nmdanny> is a list also traversable?
14:27:11 <Cale> yep
14:27:21 <Cale> So, we could also specialise this function...
14:27:35 <Cale> performRequestsAsync :: (MonadWidget t m) => Event t [XhrRequest] -> m (Event t [XhrResponse])
14:27:49 <Cale> i.e. you send a list of requests, and get back a corresponding list of responses
14:28:04 <nmdanny> What I'm confused about is, the RequestInfo type
14:28:16 <Cale> Oh, that's an arbitrary imaginary type I made up
14:28:23 <nmdanny> I understand that, but its like
14:28:24 <Cale> We could put String or Int there if it helps
14:28:39 <nmdanny> wait,
14:28:55 <nmdanny> its a piece of data that you add to the requests you send, right?
14:29:10 * hackagebot hapstone 0.1.0.1 - Capstone bindings for Haskell  https://hackage.haskell.org/package/hapstone-0.1.0.1 (ibabushkin)
14:29:31 <kadoban> It's not sent, it's only kind of associated data that you get back when the resulting Event fires.
14:29:36 <Cale> yeah -- well, it never actually gets sent, but the machinery doing the sending will put the response in the same position in the container (it's traversing the structure, substituting requests with the responses)
14:29:43 <monochrom> I am skeptic of "spirit". instead, I accept specifications, contracts, and externally observable properties of an abstract type.
14:30:11 <nmdanny> what i'm confused about is, when you have (RequestInfo,XhrRequest), you are passing two different types
14:30:15 <Cale> So effectively, that additional piece of data comes back, attached to the responses
14:30:20 <nmdanny> and when you have [XhrRequest], its a single type
14:30:55 <Cale> Well, XhrRequest is the only thing that actually results in a request being sent over the wire, these are just different containers that we can put the requests in
14:30:55 <monochrom> the contract of a "UniqueId" does not imply Num laws. this is why you don't make it a Num. this does not even need to know whether someone implemented it as Int or as forall r. (String -> r) -> r
14:31:20 <nmdanny> I'm not really talking about sending things over the wire, I mean functional wise
14:31:35 <Cale> and the container is traversed, causing actual requests to happen, and the requests are substituted in the container for their responses
14:31:46 <monochrom> however, (,) is so concrete that the contract of (,) is strong enough to imply Traversable ((,) e).
14:32:16 <monochrom> the whole thought process for both is logical, not spiritual.
14:32:25 <Cale> So having a pair container means that we can just pair up our requests with some additional identifying information, and then when we get back the responses, that additional information is present with the corresponding response.
14:32:49 <Cale> With a list container, there's no additional information, but perhaps many requests
14:33:06 <monochrom> spiritual thought is why python limits expressions and functions so much, "because they don't fit python's imperative spirit"
14:33:11 <monochrom> to hell with spirits.
14:33:12 <Cale> With a Map RequestInfo XhrRequest, you'd get back a Map RequestInfo XhrResponse
14:33:32 <nmdanny> Cale, the function that you defined, has traversable f, right?
14:33:37 <kclancy> dcoutts: nevermind, I fixed it
14:33:43 <Cale> so you'd have both multiple requests, and each request would be associated to some key in the Map
14:33:55 <nmdanny> its a container over xhreqs, right?
14:34:00 <Cale> yeah
14:34:18 <Cale> performRequestsAsync :: (Traversable f, MonadWidget t m) => Event t (f XhrRequest) -> m (Event t (f XhrResponse))
14:34:20 <Cale> is the general type
14:34:29 <nmdanny> so, the function expects a container, which, in some way, stores xhreqs, and the function traverses it, and does something, based on them
14:34:38 <Cale> By plugging in different choices of f, we get all sorts of different useful things
14:34:57 <nmdanny> but how can the function know how to deal with those different things
14:35:09 <Cale> yeah, it gives you back a container with the same structure as the input one, except all the requests have been replaced with their responses
14:35:22 <Cale> (the Traversable class gives you operations for doing this)
14:35:37 <Cale> :t sequence
14:35:38 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
14:36:12 <nmdanny> when you send (RequestInfo, XhrRequest), instead of [XhrRequest], now the function has access to the type RequestInfo
14:36:18 <Cale> This takes a container filled with actions of some sort, and turns it into an action which when executed will give a container with the corresponding the results of the actions
14:36:20 <monochrom> it is also instructive to try m=Maybe there for one more example
14:36:24 <Cale> -the
14:36:40 <maerwald> are we still talking about tuples?
14:36:47 <Cale> nmdanny: Except that it doesn't really have access to that information because of the polymorphism
14:37:01 <nmdanny> it doesn't have access to the RequestInfo?
14:37:10 <Cale> nmdanny: Because it's polymorphic, and has to work with any choice of f, it can't really look at the RequestInfo
14:37:22 <nmdanny> Yes, thats whats bugging me about this
14:37:24 <Cale> It has to do something which would work no matter which f we choose
14:37:37 <Cale> (as long as f has an instance of Traversable
14:37:39 <Cale> )
14:37:56 <Cale> :t forM
14:37:57 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
14:38:03 <Cale> So it does one of these things
14:38:21 <nmdanny> so wait, in the Pair (RequestInfo, XhrRequest), when traversing over the pair, it yields the only one value of type XhrRequest, am I correct?
14:38:26 <monochrom> it is the good kind of "cannot access". it means no mutilation. it means one fewer bug.
14:38:28 <Cale> yes
14:38:47 <nmdanny> and then, it performs some transformation over this pair,
14:38:54 <nmdanny> which means, it transforms the second element
14:38:59 <Cale> Yeah, look at the type of forM in the pair instance:
14:39:11 * hackagebot servant-JuicyPixels 0.3.0.2 - Servant support for JuicyPixels  https://hackage.haskell.org/package/servant-JuicyPixels-0.3.0.2 (TvH)
14:39:25 <Cale> (RequestInfo, a) -> (a -> m b) -> m (RequestInfo, b)
14:39:47 <Cale> here, 'a' is XhrRequest, and 'b' is XhrResponse
14:40:35 <Cale> The Traversable instance basically tells us how to do such a for-each loop over the container, substituting the result of the loop body for each corresponding element.
14:40:56 <Cale> and in the pair case, it's not much of a loop -- there's only one element to iterate over
14:41:13 <nmdanny> I see, so this entire time, our functions that deal with traversable, they basically don't know that RequestInfo exists
14:41:18 <Cale> yeah
14:41:39 <Cale> They also don't know if there's one element or many
14:41:44 <Cale> (well, they could find out)
14:41:46 <nmdanny> I see
14:42:24 <nmdanny> I see that Maybe is also a traversable, so for example you could send a Maybe XhrRequest, and maybe is a traversable too(which can have 0 or 1 elements)
14:42:31 <Cale> yeah
14:43:15 <Cale> and in the Nothing case, it would just not send a request at all, and give you back an occurrence of Nothing in the resulting event
14:46:04 <Cale> But yeah, that pair instance has been useful repeatedly, since the response isn't going to necessarily come back right away -- maybe not even in the right order (though I think there's actually some sort of guarantee in this particular example with XML HTTP requests, but you can imagine other sorts of async requests and responses handled like this)
14:47:12 <Cale> So almost always, you want to pair up your requests with some identifying information, even possibly just the request again, so that you know what it was that you sent when you get the response back.
14:47:45 <nmdanny> And that identifying information itself is not touched, because the function doesn't know about it, right?
14:47:53 <Cale> right
14:48:39 <Cale> In fact, the Traversable instance for pairs even is polymorphic in the type of the first component:  instance Traversable ((,) e) where ...
14:49:04 <Cale> So whatever forM is doing, it has to be something which would work for *any* type e
14:50:27 <Cale> and of course, it can just effectively be  forM (e,x) f = do y <- f x; return (e,y)
14:51:07 <Cale> If it tried to pattern match on e though, that would immediately be a type error -- it wouldn't be polymorphic enough
14:51:23 <nmdanny> ok I understand
14:52:18 <nmdanny> Another question, not related to anything here: Is there some Windows Haskell REPL with a GUI?
14:52:57 <Cale> I think there is something called WinGHCi
14:53:19 <monochrom> it is not very GUI
14:53:40 <Cale> ah, right, it's probably just making up for the deficiencies of Windows' terminal emulator a bit
14:53:47 <nmdanny> I basically want something that lets me write multi line commands into GHCi, press a button and execute them
14:54:00 <Cale> If you type :{
14:54:07 <Cale> it will let you enter a multiline thing
14:54:11 <monochrom> I use emacs and haskell-mode for that
14:54:17 <arahael> Cale: i use the terminal that comes with git.  pretty good.
14:54:42 <Cale> up until :}
14:54:43 <arahael> though, i havn't done windows haskell (yet?)
14:54:49 <nmdanny> I saw there's IHaskell which is exactly what I wanted, shame that it doesn't work on windows though
14:55:15 <Cale> actually...
14:55:57 <monochrom> consider the elaborate project of macosx in virtualbox in windows
14:56:06 <Cale> There was a project I heard about, I haven't actually tried it, but I got the impression it was a notebook-style interface using reflex-dom
14:57:53 <nmdanny> btw, reflex-dom, it's not for native haskell right? its for a js transpiler
14:57:57 <Pennyw95> Hi...if I use diffUTCTime with two 2 different times do I get the different in milliseconds?
14:58:24 <monochrom> what is the type of diffUTCTime?
14:58:26 <Cale> nmdanny: It's for both
14:58:42 <Cale> nmdanny: If you compile a reflex-dom application using GHC, you get a desktop application which uses webkit-gtk
14:58:59 <Pennyw95> nominalDiffTime
14:59:06 <Cale> nmdanny: If you compile it with ghcjs, you get a web page
14:59:19 <Pennyw95> it has Num instance
14:59:24 <monochrom> "1 :: NominalDiffTime" means 1 second
14:59:43 <Pennyw95> so that I should be getting the difference in seconds?
15:00:03 <monochrom> yes
15:00:04 <geekosaur> "It has a precision of 10^{-12}s
15:00:14 <Cale> nmdanny: Obviously, there are various things you can do which would exclude the possibility of one or the other -- but to a reasonably large extent, things can work in both environments.
15:00:53 <Pennyw95> so that diving by 60 should give me the minutes..uhm
15:00:55 <nmdanny> is it like running a chrome instance for an app, using html+css+js for a GUI?
15:00:59 <geekosaur> (it's Data.Fixed.Pico)
15:01:02 <monochrom> but it is fractional and can have 12 decimal places on the right of the decimal point. (or is it 11? 13?)
15:01:51 <Cale> nmdanny: Yeah -- though without any actual HTML -- your program is controlling the DOM directly.
15:02:13 <Pennyw95> 12
15:02:31 <nmdanny> like, it uses haskell to build the dom?
15:02:35 <Cale> yeah
15:02:40 <nmdanny> oh neat
15:04:00 <nmdanny> Before coming to haskell, I tinkered a little with elm which is also for manipulating dom functionally
15:04:12 * hackagebot tinylog 0.14.0 - Simplistic logging using fast-logger.  https://hackage.haskell.org/package/tinylog-0.14.0 (ToralfWittner)
15:05:05 <Pennyw95> I need to divide a number by that diffUTCTIme,how can I do that??
15:05:37 <monochrom> after the division, what type would you like?
15:06:19 <monochrom> (it seems unwise to stay in NominalDiffTime, since the quotient is not even "how many seconds")
15:07:04 <monochrom> but the most important operations of NominalDiffTime are its Num methods, Fractional methods, RealFrac methods, etc etc
15:07:28 <ntnt> howManyWordsCanIPutInANameInCapsCamelCaseBeforeIShouldStartUsing_underscores ?
15:07:52 <monochrom> you can do arithmetic. you can also convert from/to Integer, Rational, Double. (various rounding, realToFrac)
15:08:22 <monochrom> (fromIntegral, for the Integer->NominalDiffTime direction)
15:08:58 <monochrom> these should give you enough ropes to consider your options
15:09:39 <Pennyw95> given that tot is an Int, i don't get why this isn't possible  http://lpaste.net/
15:10:04 <monochrom> that url isn't directly your paste :)
15:10:11 <Pennyw95> I mean, that diffTime can be divided by 60 to yield the minutes but then
15:10:12 <Pennyw95> http://lpaste.net/158642
15:10:14 <Pennyw95> ooops
15:10:22 <monochrom> ntnt: IMO underscore is much clearer than camel case.
15:11:00 <monochrom> people complain "ugly" but I don't see the value of beautiful unclarity except on abstract paintings
15:11:34 <ntnt> monochrom: I feel that within a single name it should be camelcase, i.e. "data SvgNode" instead of "data Svg_Node" but for something like 'putSvgNodeX1At" I'd probably probably prefer "svgNode_x1"
15:11:47 <Pennyw95> so I can't divide an Int by a diffTime, while the other way around is possible
15:11:47 <wedify> how about both? how_Many_Words_Can_I_Put...
15:11:48 <monochrom> yeah
15:12:11 <Pennyw95> I should approximate the diffTime before the ratio then?
15:12:11 <glguy> Pennyw95: In the expression someDiffTime / 60, you can't dividing by an Int
15:12:21 <glguy> You're dividing by a NominalDiffTime
15:12:34 <glguy> In fact you can't divide with / on Ints
15:12:34 <monochrom> Pennyw95: fromIntegral tot / ratio
15:12:58 <monochrom> but I recommend making ratio :: Double or Rational
15:13:20 <Pennyw95> but ratio is nominalDiff
15:13:25 <Pennyw95> can cast it just like that?
15:13:27 <monochrom> ratio :: Double; ratio = realToFrac (diffUTCTime ...) / 60
15:13:36 <Pennyw95> ahhhh
15:14:02 <monochrom> it is not cast, it is explicit conversion and explicit type annotation and expletives
15:14:44 <monochrom> what does Show for NominalDiffTIme do?
15:15:24 <monochrom> it adds "s" to your number.
15:15:46 <Pennyw95> oh
15:16:11 <monochrom> see! you really want to get out of NominalDiffTime ASAP
15:16:17 <Pennyw95> yep
15:16:34 <Pennyw95> so realToFrac converts the seconds to a Double / Float
15:16:55 <Pennyw95> then I can do putStrLn (show (tot / ratio)) I guess?
15:17:17 <monochrom> or Rational if you want. but probably Double or Float suits your need for printing an estimation
15:17:26 <monochrom> yeah
15:17:31 <Pennyw95> definetely
15:17:33 <monochrom> fromIntegral tot / ratio
15:17:48 <Pennyw95> Int / Double isn't possible either?
15:17:52 <monochrom> @quote monochrom fromIntegral
15:17:52 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
15:18:37 <monochrom> the arithmetic operators say "I want both operands to be the same type". that's the limitation you have to comply to.
15:18:42 <Pennyw95> ahahah
15:18:53 <Pennyw95> oh ok then
15:18:54 <wedify> i'm not sure i like the meter on your chant
15:19:13 <simony> maybe open a pull request on that
15:29:22 * hackagebot liquidhaskell 0.6.0.0 - Liquid Types for Haskell  https://hackage.haskell.org/package/liquidhaskell-0.6.0.0 (EricSeidel)
15:31:38 <tippenein_> how bad should I feel for using unsafePerformIO 2x in 1 project?
15:32:12 <monochrom> depends on the project
15:32:49 <int-e> also on the uses of unsafePerformIO
15:32:59 <tippenein_> a parser which generates data types from a csv. The TH made it feel hacky enough that I didn't mind
15:33:40 <tippenein_> I think both uses are in helper functions on the csv data
15:40:44 <dcoutts> Aruro: yes
15:43:11 <maerwald> tippenein_: can you prove that it's pure?
15:44:50 <athan> Hi everyone, does anyone here know if there's a quickcheck for type-level data? Like to generate Nats, for instance
15:45:07 <athan> I don't think using `SomeNat` from TypeLits is feasible, because of the skolem variable
15:45:49 <tippenein_> maerwald: it depends on the integrity of the csv. I think it _should_ fail if given an improper csv, but the error message at the moment is probably not helpful
15:46:33 <tippenein_> anyone who uses ihaskell know how to add external dependencies?
15:47:47 <maerwald> tippenein_: the _purity_ of your function depends on the integrity of an input file?
15:48:07 <athan> tippenein_: Isn't it like ghci? Where you can just issue `import Foo.Bar` and if the package is installed globally, it just works?
15:48:24 <athan> I'm not sure how ghc-mod works, but I think it actually has a local cache or something
15:48:30 <athan> so I'm not sure :s
15:48:33 <tippenein_> athan: that would make sense. maybe it's looking at cabal instead of stack
15:49:50 <tippenein_> maerwald: maybe I'm misunderstanding. I mainly didn't want to work in IO.
15:49:58 <maerwald> that sounds wrong then
15:50:18 <maerwald> if you are reading a file, you want IO
15:50:50 <maerwald> but the parser itself should be IO-free 
15:51:21 <tippenein_> what am I avoiding by _not_ running unsafePerformIO?
15:51:54 <athan> tippenein_: well, you just have to make sure you're only reading
15:52:04 <athan> I think thrashing might happen in the GC or something
15:52:13 <athan> but I don't know :\
15:52:17 <athan> check #ghc!
15:52:19 <tippenein_> because I didn't want to deal with IO in the parsers (they get their parsing schema from a csv)
15:52:35 <athan> tippenein_: That's why you use a monad transformer!
15:52:44 <athan> i mean if you need to read _while_ you're parsing
15:53:04 <athan> if you don't then you just apply/fmap the parser (after being decomposed) over the read action
15:53:17 <athan> like `runParser <$> readFile "foo"`
15:53:20 <athan> er
15:53:27 <maerwald> tippenein_: are you mixing file-reading and parsing?
15:53:28 <athan> `runParser parser <$> ...`
15:53:41 <athan> where `parser :: Parser`, like in attoparsec or something
15:53:58 <athan> and is usually just a set of different traditional transformers
15:54:05 <athan> but idk :)
15:54:14 <maerwald> the only case where you might use unsafePerformIO is when you can prove that a function has no side effects (e.g. you calling some pure C stuff)
15:54:19 <maerwald> everything else is dangerous
15:54:28 <athan> or you could do `runParser' <$> readFile "foo"`
15:54:38 <athan> where `runParser' :: String -> Maybe Foo`
15:54:50 <athan> or `Either ParseError Foo`
15:59:23 * hackagebot monad-control 1.0.1.0 - Lift control operations, like exception catching, through monad transformers  https://hackage.haskell.org/package/monad-control-1.0.1.0 (BasVanDijk)
16:13:17 <ChameleonSix> Hello
16:13:51 <ChameleonSix> Anyone ?
16:17:15 <SoupEvil> hi, is there a an time duration parsing library? so "10m" would be parsed into a (10*60 :: NominalDiffTime)?
16:20:09 <wedify> what's up ChameleonSix?
16:22:36 <amalloy> i'm trying to write a simple echo server, with the main "echo the input" function here: https://gist.github.com/amalloy/4ce60d93dd82e6aa8dec8e90e4796230 - it works fine, echoing all my input, until i hit ctrl-d to close the connection. at that point i get the error "Main.hs: Network.Socket.recv: end of file (end of file)". but i thought i was handling that by checking for recv returning 0, based on the documentation for recv. how should i be 
16:24:03 <zv> I seem to remember a book on Haskell or Racket (maybe?) that had a bunch of really tricks with map & fold/reduce. Not the standard "sum a list" type stuff, unique and useful stuff like processing a graph/tree, making a virtual associative array, all without loss of generality across language. Does anyone know or remember this book or article? 
16:24:13 <zv> sorry for such a lame question
16:24:30 <zv> but this has been killing me as a question for some time
16:24:52 <wedify> i don't think it's a lame question
16:29:24 * hackagebot annihilator 0.1.0.0 - Semigroups with annihilators and utility functions  https://hackage.haskell.org/package/annihilator-0.1.0.0 (Shou)
16:35:58 <benzrf> grammars that aren't regular matched by a regular expression: let parens = Concat [Literal '(', Star parens, Literal ')']
16:35:59 <benzrf> :]
16:44:32 <benzrf> is there some package i can use that will let me take the intersection of two regexen
16:44:35 * hackagebot pipes-interleave 0.2.2 - Interleave and merge streams of elements  https://hackage.haskell.org/package/pipes-interleave-0.2.2 (BenGamari)
16:53:34 <infinity0> so we have fmap :: (a -> b) -> f a -> f b and hoist :: (forall a. m a -> n a) -> t m b -> t n b, is there something in between?
16:54:00 <infinity0> namely (m a -> n a) -> t m a -> t n a for a fixed 'a'
17:00:20 <japgolly> Hello. Can someone please help me get -eventlog working via stack?
17:00:29 <benzrf> infinity0: how's that "between"
17:01:10 <benzrf> oh wait i see
17:01:36 <japgolly> I've put `ghc-options: -Wall -O2 -eventlog -threaded -rtsopts -with-rtsopts=-N` in my blah.cabal file, stack build -v shows it's there, but when I run `stack exec blah +RTS -l` it says I need to build with -eventlog or -debug. :S
17:02:03 <mniip> infinity0, 't m a' doesn't contain 'm a'
17:02:35 <mniip> consider t ~ MaybeT
17:02:39 <amalloy> and if you meant t (m a) instead, it would just be fmap, right?
17:02:41 <mniip> MaybeT m a ~ m (Maybe a)
17:02:49 <kadoban> japgolly: 'stack exec blah -- +RTS -l'
17:03:09 <mniip> what are you going to do with (m a -> n a) -> m (Maybe a) -> n (Maybe a)
17:03:34 <japgolly> Ah thank you kadoban!
17:03:42 <japgolly> That's all that was needed :D
17:04:21 <kadoban> Sure
17:04:40 <dmj> hackage down?
17:05:27 <ackthet> nope
17:05:31 <ackthet> not for me
17:06:18 <monochrom> front page is up all along. but individual package pages e.g. /package/aeson was unresponsive for a minute
17:06:30 <dmj> monochrom: yea
17:06:53 <dmj> acid state was probably doing some gc or something
17:06:59 <dmj> causing gc
17:07:33 <infinity0> amalloy: right yes
17:07:40 <monochrom> then I did a random search (literally http://hackage.haskell.org/packages/search?terms=random ) and all got well
17:08:05 <infinity0> mniip: it would be (m Maybe a) not (m (Maybe a))
17:08:39 <mniip> infinity0, nope it's m (Maybe a)
17:08:45 <mniip> @unmtl MaybeT m a
17:08:46 <lambdabot> m (Maybe a)
17:09:41 <infinity0> ok well it's different from my original example
17:09:59 <mniip> no it isn't
17:10:05 <mniip> t ~ MaybeT
17:10:06 * hackagebot quiver-interleave 0.1.0.0 - Interleave values from multiple Quivers  https://hackage.haskell.org/package/quiver-interleave-0.1.0.0 (IvanMiljenovic)
17:10:10 <monochrom> a_random_string :: String;  a_random_string = "random";  -- I really thought arbitrarily for it
17:10:48 <infinity0> the t is a general transformer, and in general t m a isn't the same as m (t a)
17:11:05 <mniip> 't a' is not well-kinded
17:12:14 <mniip> infinity0, you're asking for a polymorphic operation
17:12:23 <mniip> I'm telling you that such an operation is meaningless
17:12:31 <mniip> because if we monomorphize it we get garbage
17:12:40 <infinity0> alright anyway i have a libarry function m a -> n a and i've finally managed to massaged my transformer stack to give me two objects of type t m a and t n a, and i'd like to apply the original functhion somehow
17:12:44 <RyanGlScott> Is there a cleaner way to create a bidirectional pattern synonym that refers to another term than this method?
17:12:54 <RyanGlScott> pattern X <- ((== x) -> True) where X = x
17:12:57 <mniip> infinity0, what?
17:13:04 <mniip> t m a -> t n a
17:13:04 <RyanGlScott> Sadly, you can't say pattern X = x
17:13:15 <mniip> t n a is the result of the function
17:13:21 <mniip> not an argument
17:13:56 <infinity0> i have a function (m a -> n a), and an object t m a, and i'd like to apply the function to that object somehow
17:14:09 <mniip> I'm afraid that you can't do
17:14:16 <mniip> not for an arbitrary transformer t
17:14:32 <infinity0> ok, what properties would the t have to have? as a matter of fact i do control the outer t yes
17:16:11 <mniip> I'm not sure
17:16:22 <xa0> :t Control.Monad.Morph.hoist Control.Monad.Morph.generalize
17:16:23 <lambdabot> (Monad n, Control.Monad.Morph.MFunctor t) => t Identity b -> t n b
17:16:26 <mniip> I can't find any transformer other than ReaderT r, that can do that
17:16:55 <infinity0> ok i'll take a look at that one thanks
17:17:02 <xa0> :)
17:17:16 <mniip> MaybeT is out of the question because you can't handle 'return Nothing'
17:17:27 <mniip> WriterT too for a similar reason
17:17:33 <monochrom> Control.Monad.Power.Morphing.Rangers
17:17:38 <mniip> StateT is essentially a composition using a WriterT
17:18:39 <infinity0> hm shit, my t is basically a special StateT
17:19:00 <mniip> well
17:19:08 <mniip> then your problem specializes to
17:19:16 <monochrom> what do you get when you combine a writer and a composer? answer: WriterT Haskcore
17:19:21 <mniip> (m a -> n a) -> (s -> m (a, s)) -> s -> n (a, s)
17:20:04 <mniip> using fmap we can get under the (s ->)
17:20:15 <mniip> (m a -> n a) -> m (a, s) -> n (a, s)
17:20:22 <mniip> now that's where it stops making sense
17:20:36 <benzrf> how do i get tab completion for source files i'm loading in ghci
17:22:15 <infinity0> mniip: could you elaborate on "stops making sense"?
17:22:23 <monochrom> I think it already does? :load Cal<tab>  gets me Calculator.hs and Calibre Library
17:22:30 <johnw> infinity0: try writing a function of that type
17:22:32 <mniip> you can't do that for generic m and n
17:26:02 <infinity0> i imagine something like, do (ff (m >>= \a, s -> lift $ put s >> return a)) >>= \a -> return (a, lift $ get)
17:26:12 <infinity0> but sure i'll try it for reals, thanks anyways
17:26:27 <infinity0> perhaps i can massage the stack a different way to have the m on the outside or something, hm#
17:26:28 <monochrom> if you use >>= you now assume Monad
17:26:45 <mniip> Monad m, Monad n is kinda implied
17:26:46 <infinity0> ok sorry i wasn't clear, m and n are both monads
17:26:49 <mniip> because 't m a'
17:27:19 <infinity0> i dunno why i had "do" in there, whoops
17:28:12 <monochrom> ah, even Monad doesn't help
17:34:48 <johnw> i've been in a situation of needing exactly that function before; it's just not possible
17:34:57 <shirt> getFileSha1 filepath = BL.readFile filepath >>= return . T.pack . showDigest . sha1
17:35:27 <shirt> why isn't this closing my file handle after it finished calculating the SHA1? i'm getting an error after a while "too many open files"
17:35:44 <infinity0> johnw: how did you solve your overall problem?
17:36:23 <johnw> I didn't
17:36:23 <shirt> ah wait, i think i know the problem, i'm only actually using the value later on
17:36:28 <johnw> I had to abort the attempt
17:36:43 <infinity0> lol, encouraging
17:36:55 <lpaste> MichaelK pasted “Polymorphism confusion” at http://lpaste.net/158646
17:36:59 <johnw> you can't get that 's' out of the m (a, s), in order to embed it into 'n'
17:37:11 <johnw> you can make an 'n a' easy enough
17:37:16 <johnw> but not an n (a, s)
17:37:59 <MichaelK> Why do these expressions have different types? Shouldn't ghc be able to tell that the left type in Either is determined by `f`, in mapLeft'?
17:38:34 <johnw> it's because of the use of Right in one, but not the other
17:38:51 <johnw> destructing Right x and then constructing Right x possibly changes the type of the left side
17:39:10 <infinity0> hm yeah i'm running into that here right now too
17:39:14 <johnw> destructing x@(Right _) and returning x leaves the Left side alone
17:40:13 <johnw> infinity0: (forall a. m a -> n a) would make it trivial ;)
17:40:23 <monochrom> MichaelK: in other words, in simpler terms, you're looking at "f Nothing = Nothing" being Maybe x -> Maybe y, "g n@Nothing = n" being Maybe a -> Maybe a
17:41:29 <monochrom> if you stick to n, you also stick to n's type. but if you mention "Nothing" a thousand times, they're free to take on different types, even if they're all on the same line of code
17:41:52 <monochrom> @type \Nothing -> (Nothing, Nothing, Nothing, Nothing)
17:41:54 <lambdabot> Maybe t -> (Maybe a, Maybe a1, Maybe a2, Maybe a3)
17:42:21 <MichaelK> monochrom: I think my brain puts an implicit `coerce` in there
17:43:24 <MichaelK> monochrom: that makes sense enough, all that's left is I'm not sure why it was designed that way
17:43:33 <monochrom> Nobody can do everything. Nothing can be every type
17:44:57 <monochrom> it is beneficial to both implementer and user
17:45:11 <MichaelK> @type \x -> if isNothing x then x else Nothing
17:45:12 <lambdabot> Maybe a -> Maybe a
17:45:20 <mniip> :t undefined -- *whistles*
17:45:21 <lambdabot> t
17:46:30 <mniip> MichaelK, the problem is
17:46:40 <mniip> the typechecker doesn't know that n can't be a Just
17:46:52 <mniip> even if it's a capture of a Nothing pattern
17:47:02 <mniip> the typechecker doesn't know that
17:47:22 <mniip> I'm sure there are some issues with teaching the typechecker that
17:48:21 <infinity0> johnw: yeah unfortunately what i have is a "forall" binary operator
17:48:29 <infinity0> i guess something like "hoist2" would also work here
17:48:30 <monochrom> to the implementer, it is simpler to be required "each occurrence of Nothing gets its own Maybe type, subject to vanilla type inference", i.e., no exception to vanilla type inference, than to be required "except: if there is also another Nothing nearby, sync their types", resulting in needing to read a 10 page document of what "nearby" exactly means
17:48:43 <MichaelK> mniip: oh. that makes much more sense. 
17:48:55 <monochrom> and to the user, it means "fmap f Nothing = Nothing" works
17:49:16 <johnw> infinity0: it's the type-checker, keeping you honest
17:50:57 <obadz> https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Foreign.Marshal.Alloc.html#allocaBytes ⇐ what are all these # signs?
17:51:17 <MichaelK> monochrom: I'm starting to see that, as you might start to get things like `Maybe a ~ Maybe b`, unless the type checker was a bit more powerful like mniip mentioned
17:51:34 <mniip> monochrom, I think the rule could be, if in c@(Con x y z), c only infers type variables that are jointly determined by x,y,z
17:51:34 <geekosaur> obadz: by convention, and unboxed type
17:52:17 <obadz> geekosaur: what about the #s that are just on the own?
17:52:26 <mniip> but that is questionably useful
17:52:36 <obadz> geekosaur: like the last one here: (# s1, mbarr# #)
17:52:53 <mniip> oh also
17:53:03 <mniip> we have to make a total decision about whether some tyvar is determined or not
17:53:03 <obadz> geekosaur: hmmm and the first one, I guess they are part of the parenthesis?
17:53:10 <geekosaur> there aren't any? (# #) is an unboxed tuple; MagocHash makes # a valid identifier character, so mbarr# is an identifier and the # is used to remind the reader that it prepresents an unboxed value
17:53:11 <mniip> which is not possible in presence of tyfams in gadt
17:53:36 <obadz> geekosaur: I see makes a lot more sense now
17:53:49 <geekosaur> on the first line you also see I# which is the data constructor for an Int
17:54:02 <geekosaur> with an inboxed Int inside it (size)
17:54:06 <geekosaur> *unboxed Int
17:54:17 <monochrom> my point is that every exception is a complication, not a simplification. and every "sync their types just because a human thinks it's intuitive" that's not already implied by Hindley-Milner (say) is such an exception. and that human intuition is both fragile and a complication.
17:54:32 <obadz> geekosaur: thanks
17:55:39 <mniip> does HM say anything about pattern matching
17:56:31 <geekosaur> (ans for consistency it should really have used size# :)
17:57:01 <mniip> obadz, # is like '
17:57:13 <mniip> it can be a part of a name, like foo'bar and Int#
17:57:25 <mniip> or it can be a part of syntax, as in (# , , , #)
17:57:42 <mniip> it is, however, trivial to see which is which
17:58:46 <monochrom> no, but it infers (\() -> (\a -> a, \a -> a)) :: (a -> a, b -> b) which is enough to suggest that two syntactically identical terms get two distinct type variables
17:59:30 <monochrom> at the very least it extrapolates to:
17:59:38 <monochrom> @type (Nothing, Nothing, Nothing)
17:59:39 <lambdabot> (Maybe a, Maybe a1, Maybe a2)
18:01:49 <monochrom> err, () -> (a->a, b->b)
18:01:56 <mniip> monochrom, that is not what we are talking about here
18:02:11 <Tendies> hi can i get some help with recursion of parsers (maybe thats what i need?)
18:02:26 <infinity0> ok i actually managed to work around my issue by using a utility method that i declared the type of but haven't yet defined
18:02:38 <Tendies> im writing a parser for html tags right now and i dont know how i should proceed http://lpaste.net/158649
18:02:38 <infinity0> obviously the previous discussion dents my confidence that i will be *able* to define it though
18:03:04 <mniip> monochrom, if we modify the 'maybe' catamorphism to look a bit more like actual pattern matching, that is,
18:03:23 <mniip> Maybe a -> (Maybe a -> a -> r) -> (Maybe a -> r) -> r
18:03:36 <mniip> arguably, in the 'Nothing
18:03:43 <mniip> ' branch, we can use a different tyvar
18:03:48 <mniip> that is
18:03:52 <mniip> Maybe a -> (Maybe a -> a -> r) -> (Maybe b -> r) -> r
18:03:54 <monochrom> why is it not Maybe a -> (a -> r) -> r -> r?
18:04:07 <mniip> because you can do a@(Just b)
18:04:16 <mniip> the a@ matters too
18:04:29 <monochrom> I see
18:04:32 <Tendies> my plan is to have a main parser called html to start with, and have it call the parser 'tag' when it hits any '<' but the pair tags need to either follow by a single tag or a different pair tag and nest properly
18:04:45 <mniip> likewise, in Either, we get
18:05:06 <mniip> Either a b -> (Either a c -> a -> r) -> (Either c b -> b -> r) -> r
18:06:37 <Tendies> i also have a question or two in the comments on the lpaste
18:06:52 <Tendies> (simple ones) :)
18:07:24 <mniip> Tendies, parsing combinators encourage constructive thinking
18:07:33 <mniip> you describe what objects you're parsing, not how
18:07:57 <Tendies> what
18:08:23 <infinity0> do you guys think a type signature like s n -> t m a -> n (m a) is realisable, where i get to decide what s/t do, m and n are monads
18:08:25 <monochrom> I am not convinced it's called "constructive thinking", but I agree with the second sentence.
18:08:35 <mniip> well
18:08:39 <mniip> I'm out of words
18:08:51 <mniip> Tendies, well, what is a DOM element
18:09:19 <mniip> either opening_tag + some dom elements + closing tag, or, unpaired tag, or a piece of text
18:09:51 <Tendies> i don't remember, but this is a very basic subset of html
18:09:56 <mniip> next, what is an opening tag? that's a < followed by the tag name, followed by some arguments followed by >
18:10:18 <mniip> what's an argument? either a word, or a word followed by = followed by a string in quotes
18:10:19 <mniip> etc
18:10:36 <mniip> greatly oversimplifying here, though
18:11:14 <orion> ski: Hi. :)
18:11:34 <Tendies> i'm very new to parsers, i'm only working with head,body,b,i,ul,ol,p,br,li,a href
18:13:06 <Tendies> s/parsers/haskell/
18:14:35 <Tendies> can i use maybe in a parser? like do ... fslash <- maybe char '/'
18:15:08 * hackagebot cacophony 0.6.0 - A library implementing the Noise protocol.  https://hackage.haskell.org/package/cacophony-0.6.0 (jgalt)
18:15:11 <orion> ski: Thanks to you, that happened. ^
18:27:27 <infinity0> :t (hoist . hoist)
18:27:29 <lambdabot> Not in scope: ‘hoist’
18:27:29 <lambdabot> Not in scope: ‘hoist’
18:28:01 <infinity0> ah well, anyway, i just found it interesting that doesn't type check (even if it's in scope) yet you can apply it twice to any actual value
18:29:47 <Tendies> if i have a type like, data pair_tag = head | body | b | i, how can i check that a certain string is of that type?
18:30:00 <koz_> Tendies: Pattern-match?
18:30:45 <Tendies> can i do it without that, that would make having my own type pretty useless it seems
18:30:58 <geekosaur> ?
18:31:07 <geekosaur> I'm not even sure what you are asking tbh
18:31:46 <Tendies> im parsing a basic html tag, i want it to only work when something read to that type is within the < >
18:31:51 <koz_> Tendies: I too am confused. Pattern-matching is typically the way you deal with types with heterogenous constructors.
18:31:55 <geekosaur> pattern matching would be for the case where you have a Pair_tag and you want to know which constructor it used
18:32:11 <Axman6> sounds like you want a proper parser
18:32:56 <koz_> Yeah - that should really be done at parse time.
18:33:12 <Axman6> you could hack it with something like: matchShow :: Show a => Parser a; matchShow a = string (show a) *> pure a
18:34:17 <Axman6> but that only works if you're expecting to get exactly the same string as the item you're checking against. if you have data PairTag = Head | ..., then you will match exactly "Head" only, not "head"
18:35:50 <Tendies> is this the wrong way to try and parse the tag
18:37:08 <koz_> Tendies: Ideally, you should have a parser (written using Parsec or something) that converts this to an AST of some kind, and then work with that AST instead of going straight from raw.
18:37:39 <Tendies> ast?
18:38:36 <koz_> Tendies: Abstract Syntax Tree. Think of it as the representation of what your data *means* as opposed to what it looks like.
18:38:43 <koz_> (which is what it *seems* you're going for here)
18:40:09 * hackagebot pipes-cacophony 0.2.1 - Pipes for Noise-secured network connections.  https://hackage.haskell.org/package/pipes-cacophony-0.2.1 (jgalt)
18:54:07 <Axman6> Tendies: if you're not doing this to try and learn how to do it, there are several packages that already do this well such as tagsoup
18:54:25 <Tendies> unfortunately that's not the case
19:18:12 <DotKite> I want to define a function that takes in a list of numbers and outputs a number.  Could I declare the type like this,  avg :: [Num] -> Num      ?
19:18:41 <mmachenry1> DotKite: Num is a type class, not quite, but close.
19:18:49 <mmachenry1> Num a => [a] -> a
19:18:52 <athan> DotKite: Well, Num is a descriptor for a type, in a sense
19:19:05 <athan> you could use a hard `Int` instead of `a` though
19:19:05 <DotKite> Ah i see
19:19:16 <mmachenry1> The reason is that it's not a concrete type. Int is a concrete type. So [Int] -> [Int] is fine.
19:19:28 <mmachenry1> But if you want it to work for all numbers that the above is what you want.
19:19:54 <DotKite> sweet thanks 
19:20:07 <DotKite> just started learning haskell, pretty fun
19:20:36 <Cale> DotKite: Note that if you want to be able to divide using (/), you'll want Fractional rather than Num
19:21:01 <DotKite> Cale, really?
19:21:04 <DotKite> why is that?
19:21:07 <Cale> :t (/)
19:21:08 <lambdabot> Fractional a => a -> a -> a
19:21:26 <Cale> There are reasonable instances of Num which wouldn't support division.
19:21:41 <DotKite> Ah of course
19:49:17 <joehillen> Is (<>) in the Prelude in 8.0?
21:55:01 <tempeh> Hi guys. I have monad troubles.
21:55:36 <tempeh> I have a UI that's controlled by a state machine
21:55:58 <tempeh> The state machine is pure, it's just a State monad
21:56:32 <tempeh> I'm trying to figure out how to mix it with the actually UI interface, with is another IOMonad
21:56:46 <tempeh> They need to sort of control eachother
21:56:53 <tempeh> does that mean they need to be in a stack?
21:58:12 <crough> If you want to keep it pure, you can use `hoist generalize` from the `mmoprh` package to turn `State` into `StateT m` in any monad m
21:58:44 <crough> *mmorph
21:59:17 <tempeh> I'm gonna go check out mmorph now
22:00:33 <crough> mmorph is probably the package I get the most use out of :) It's very nice.
22:00:45 <tempeh> but basically the answer is yes, if they interact all the time they need to be in a stack?
22:00:59 <tempeh> the only other solution seems to be popping the state monad all the time, which blows
22:01:29 <crough> well, if you want them to interact, they do need to be in a stack or you need to run through state, BUT:
22:01:41 <crough> You can keep it in seperate stacks until later with mmorph and mtl
22:02:04 <tempeh> right, I have the whole state written purely already, so stacking them now isn't so bad
22:02:09 <crough> Also, beware of StateT IO-- it can make things kind of hard to read. Sometimes running the state is better than doing that.
22:03:21 <tempeh> I think it'll be StateT S M where S is my pure state and M is a MonadIO
22:03:36 <tempeh> is that ugly?
22:03:52 <crough> ehh, it depends. You now have two states to deal with all the time in a stack like that.
22:04:03 <crough> A lot of people consider it an anti-pattern, but don't let them stop you
22:04:13 <crough> If it's the easiest, just go for it, honestly.
22:04:20 <tempeh> what's the better way?
22:04:30 <tempeh> assuming I don't want to scrap my pure State
22:04:36 <crough> Running it.
22:04:40 <tempeh> oof
22:04:43 <tempeh> ok
22:06:12 <crough> You could also create an alternative to MonadIO (like MonadLog, etc) that only allows you to preform certain functions instead of *any* IO
22:06:45 <tempeh> I'm actually using NCurses so technically not MonadIO
22:07:12 <crough> even if the base monad ends up being IO... the goal, I think, is just to manage implicit contexts. IO is already effectively `StateT (Either SomeException)`
22:07:30 <crough> Where the state there is just about anything...
22:07:50 <crough> tempeh: Ooh, just a side node-- check out Brick :)
22:08:22 <tempeh> ..damn
22:08:28 <tempeh> yeah that's really cool
22:09:24 <mayswell> hello...
22:09:41 <liste> hello mayswell 
22:09:53 <mayswell> is this an active channel to date?
22:10:08 <crough> tempeh: brick is suuuuuper fun to work in after you get the hang of it
22:10:30 <tempeh> i will definitely play with it
22:11:03 <mayswell> hey liste….how are you this evening?
22:11:29 <liste> mayswell: morning*. can't tell, haven't had my coffee yet
22:11:35 <tempeh> mmorph looks great by the way thanks for your help!
22:11:58 <mayswell> ah of course, my bad… coffee is a musy
22:12:01 <mayswell> must***
22:13:26 <mayswell> haha so anyways, just wanted to get a feel for this community, and maybe a get a bit of info….I’m new to IRC not really new to computying
22:13:44 <mayswell> computing*
22:14:24 <mayswell> I come in peace and am obviously here for the same reasons as the rest of you...
22:16:47 <cocreature> this channel is usually pretty quiet until people ask questions
22:17:13 <tempeh> crough: so hoist generalize works for StateT S Identity (), is there a way to generalize a larger stack like WriterT L (StateT S Identity ()) ?
22:17:27 <kadoban> mayswell: Welcome. Yep there's always lots of people here. The activity varies of course
22:18:22 <mayswell> thanks I’ve heard good things definetly somewhere I’ll need to start hanging out omre often… thanks kadoban.
22:18:51 <tempeh> crough: nevermind got it :)
22:18:59 <tempeh> herp derp
22:19:06 <kadoban> Cool :) Yep this is pretty much the best channel I'm in, it's a great place to hang out.
22:19:44 <mayswell> gotta start to contribute somewhere may i add..
22:27:54 <mayswell> .
22:33:34 <crough> tempeh: oh yeah, sorry :) just chain hoist together for a while
22:33:46 <crough> tempeh: just like Functors without Compose :)
22:39:28 <AbelianGrape> Is there some way I can use Hayoo or Hoogle to tell me every function in the Lens library that has MonadState in the type? I'm curious what operators and such are defined
22:42:45 <kadoban> AbelianGrape: I don't believe so. You could try just grepping for MonadState in the source of lens
22:43:06 <cocreature> https://github.com/ekmett/lens/wiki/Operators also has a list of the operators with a separate column for the stateful once
22:43:11 <cocreature> not sure how complete that list is
22:43:27 <Gurkenglas> That list is pretty old
22:43:33 <Gurkenglas> You can Ctrl-F https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Operators.html for MonadState
22:44:10 <AbelianGrape> Gurkenglas: That is missing some useful things I found in Getters, like use and uses (and there's another package with preuse)
22:44:23 <AbelianGrape> Thanks kadoban and cocreature, I will look
22:44:29 <Gurkenglas> Whoever's feeling industrious can translate Control.Lens.Operators into a table
22:45:01 <AbelianGrape> :t (%=)
22:45:03 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
22:45:13 <AbelianGrape> OK, so I'm a bit confused about that
22:45:32 <Gurkenglas> Once again, get ghc to minimize type token length by introducing type aliases
22:45:34 <AbelianGrape> Well first off it doesn't match the type on hackage
22:45:50 <AbelianGrape> Second, I think "p a b" specifies to (a -> b)
22:46:22 <AbelianGrape> but I'm not sure how that works because in a state monad you aren't allowed to change the type of the state, right? So how could you possibly modify the type of an element at a lens?
22:46:59 <AbelianGrape> Like, every time I've used "foo %= bar", bar has type (a -> a), and I'm not sure how it could be anything else
22:47:16 <AbelianGrape> yet (%=) allows modifiers of type (a -> b)
22:47:51 <cocreature> :t (%=) _1
22:47:53 <lambdabot> (Field1 s s a b, MonadState s m) => (a -> b) -> m ()
22:47:54 <Gurkenglas> https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Operators.html at Ctrl-F -> (%=) lists one example that has that general type you're looking for
22:49:17 <Gurkenglas> Any s that can contain an a or b without changing type can fit there
22:49:49 <Gurkenglas> Heterogenous lists? Either a b?
22:50:58 <AbelianGrape> Which example? As far as I can tell, f must have type (a -> a) because "State s" has the monad instance, and changing the type of a field of "s" would change the type of "s", unless the field is universally quantified, in which case the type must be "forall a . <constraints> a". So I guess you could have a function of type (forall a b . <constraints on a> <identical constraints on b> (a -> b)" ?
22:51:12 <Gurkenglas> (%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
22:51:25 <AbelianGrape> Yes, I see that, I'm asking what it signifies
22:52:09 <AbelianGrape> I guess an equivalent question is what's an example of ASetter s s a b where a ≠ b
22:52:55 <Gurkenglas> @let failEither :: (a -> b) -> Either b a -> Either b a; failEither _ (Left x) = Left x; failEither f (Right x) = Left (f x)
22:52:56 <lambdabot>  Defined.
22:53:46 <AbelianGrape> Gotcha! So you can define an ASetter that changes to a different constructor. Didn't occur to me
22:54:17 <cocreature> hm I guess there are simply no laws for setters that could forbid you to do that?
22:54:22 <cocreature> it feels weird
22:54:26 <Gurkenglas> :t sets failEither %= show
22:54:27 <lambdabot> (Show a, MonadState (Either String a) m) => m ()
22:54:53 <AbelianGrape> Excellent
22:55:21 <cocreature> hm set l y (set l x a) = set l y has to be satisfied according to the docs
22:55:27 <cocreature> I don’t think that’s the case here?
22:55:40 <Gurkenglas> That doesn't even typecheck, I think that law doesn't apply?
22:55:52 <cocreature> https://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Setter.html
22:55:55 <Gurkenglas> wait it does lol
22:56:15 <Gurkenglas> And yep that doesn't apply
22:56:22 <AbelianGrape> Why not?
22:56:34 <cocreature> why doesn’t it apply? it isn’t satisfied but it’s still a valid law, no?
22:57:14 <Gurkenglas> > failEither (('@':) . show) (failEither show (Right 2))
22:57:15 <lambdabot>  Left "2"
22:57:21 <cocreature> yeah that was my point
22:57:24 <Gurkenglas> > failEither (('@':) . show) (Right 2)
22:57:27 <lambdabot>  Left "@2"
22:57:47 <Gurkenglas> Works with something similar for These though
22:59:51 <Gurkenglas> @let data These a b = This a | That b | These a b deriving (Eq, Ord, Read, Show)
22:59:53 <lambdabot>  Defined.
23:00:08 <Gurkenglas> @let noteThese :: (a -> b) -> These b a -> These b a; noteThese _ (This x) = This x; noteThese f (That x) = These (f x) x; noteThese f (These _ x) = These (f x) x
23:00:09 <lambdabot>  Defined.
23:00:26 <Gurkenglas> :t sets noteThese %= show
23:00:29 <lambdabot> (Show a, MonadState (These String a) m) => m ()
23:00:41 <nineonine> hi there
23:00:57 <nineonine> can someone help me with Free Monads please ?
23:01:03 <Gurkenglas> @where ask
23:01:03 <lambdabot> Don't ask to ask, just ask.
23:01:07 <nineonine> http://lpaste.net/158631
23:01:19 <nineonine> lambdabot <3
23:01:39 <Gurkenglas> We should add a counter to that that says how many times @where ask has been said x)
23:01:45 <nineonine> :))
23:01:52 <Gurkenglas> http://ircbrowse.net/browse/haskell?q=%40where+ask
23:02:17 <Gurkenglas> Oh wait that's mostly other stuff, damn you ircbrowse for discarding nonletters
23:02:21 <nineonine> basically i have a small dsl with one data constructor
23:02:30 <nineonine> it abstracts http requests
23:02:56 <nineonine> i want to make a function that unwraps first layer 
23:03:03 <nineonine> changes Request
23:03:15 <nineonine> and prepends modified layer back
23:03:48 <Gurkenglas> Anyone can fetch me the discussion from the #haskell-lens logs where the words edwa_rdk without the _ and Gurkenglas and interesting appear in one line? I can't find my logs on that and I can't find the exact implementation I proposed back then
23:04:27 <cocreature> Gurkenglas: the these example is nice, thanks!
23:05:09 <Gurkenglas> <Gurkenglas> And yep that doesn't apply <- I meant isn't satisfied ._.
23:05:17 <nineonine> any thoughts :]
23:06:06 <Gurkenglas> In fact, we don't need full these, (b, a) is enough
23:07:39 <mniip> Gurkenglas, how long ago?
23:08:28 <mniip> (I only have a couple months)
23:08:38 <Gurkenglas> dunno except I could look up what range my logs cover. there should be a way to combine hexchat log folders. He also said pull request somewhere nearby
23:08:50 <Gurkenglas> Oh, more than months pretty sure
23:09:20 <Gurkenglas> Or perhaps pullrequest. or PR. ._.
23:09:43 <mniip> ah, only been in the channel for so long
23:12:36 <shanemikel> I'm working on an issue with emacs + haskell-mode https://github.com/haskell/haskell-mode/issues/1260 .. check it out if you're interested (it specifically involves code folding plugins, but could be applicable to other things)
23:58:51 <dmtd> hi all, how would I convert a function like "thing a b c = a * b *c" to use \lambda, but mean the same thing? I guess my understanding of lambda is  little shakey
