00:06:08 <anoe> let chunkAlong a b l = map (take a . drop b) $ tails l 
00:06:16 <anoe> (my version)
00:06:52 <hackrilege> that doesnt work!
00:07:37 <Lovepon> Yep.
00:07:56 <anoe> ?
00:08:07 <anoe> ah yes :)
00:08:54 <Lovepon> > (\a b l = map (take a . drop b) $ tails l) 4 2 [1..9]
00:08:56 <lambdabot>  <hint>:1:9: parse error on input â€˜=â€™
00:09:05 <Lovepon> > (\a b l -> map (take a . drop b) $ tails l) 4 2 [1..9]
00:09:06 <lambdabot>  [[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9],[8,9],[9],[],[],[]]
00:09:20 <hackrilege> > let chunkAlong a b l = filter ((0==).(div b).head)map (take a . drop b) $ tails l in chunkAlong 4 2 [1..9]
00:09:22 <lambdabot>      Couldn't match expected type â€˜([a1] -> [a1]) -> [[a]] -> t1â€™
00:09:22 <lambdabot>                  with actual type â€˜[[Int]]â€™
00:09:22 <lambdabot>      Relevant bindings include
00:10:13 <Lovepon> :3
00:10:32 <hackrilege> inser the dollar at the point where you were too lazy to format it correctly
00:10:42 <hackrilege> > let chunkAlong a b l = filter ((0==).(div b).head) $ map (take a . drop b) $ tails l in chunkAlong 4 2 [1..9]
00:10:44 <lambdabot>  [[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9],[8,9],[9]*Exception: Prelud...
00:11:57 <hackrilege> > let chunkAlong a b l = filter ((0==).(flip div b).head) $ map (take a . drop b) $ tails l in chunkAlong 4 2 [1..9]
00:11:59 <lambdabot>  *Exception: Prelude.head: empty list
00:12:03 <hackrilege> !!
00:12:46 <Lovepon> lol
00:12:49 <anoe> :)
00:13:27 <hackrilege> > let chunkAlong a b l = filter ((0==).(flip mod b).head) $ map (take a . drop b) $ tails l in chunkAlong 4 2 [1..9]
00:13:29 <lambdabot>  [[4,5,6,7],[6,7,8,9],[8,9]*Exception: Prelude.head: empty list
00:13:45 <anoe> Safe.headMay
00:13:53 <dwat3r> hi guys, i'm having technical difficulties with a record structure inside a data definition. http://lpaste.net/161206 here you can see that mIx has a function type, and to define it, i should refer to the data itself... how can i do it correctly?
00:13:57 <Lovepon> Maymay
00:14:22 <hackrilege> i guess that only works for [1..]
00:14:43 <Lovepon> Yeah
00:15:15 <Lovepon> @type Safe.headMay
00:15:16 <lambdabot> [a] -> Maybe a
00:15:24 <hackrilege> could use !!
00:15:34 <Lovepon> @type listToMaybe
00:15:34 <Axman6> Lovepon: what error are you getting?
00:15:35 <lambdabot> [a] -> Maybe a
00:15:50 <Axman6> uh, dwat3r, sorry
00:15:53 <Lovepon> Axman6: None, that's the problem.
00:15:58 <Lovepon> Axman6: oh ok. :p
00:16:37 <hackrilege> you could tell me if i can write a generic instance for Free (Zipper [])
00:17:17 <Axman6> dwat3r: I have a feeling it might just be an indentation problem, try indenting the then and else clauses past the =/->/if (not sure which one it should be)
00:17:20 <anoe> hackrilege: for chunkAlong ?
00:17:24 <hackrilege> no
00:17:27 <anoe> ok
00:17:48 <hackrilege> rather i should be able to write instance M m => M (Free m)
00:18:06 <hackrilege> can i?
00:18:19 <hackrilege> or first, does that make sense?
00:21:21 <dwat3r> Axman6: that's not the problem, copy and paste it to ghci to see it. I want to invoke mIx like this: mIx m (1,2) 
00:21:40 <dwat3r> where m has type Matrix...
00:23:03 <Axman6> seems that should work to me, what's the issue?
00:24:17 <Axman6> this looks like a quite unusual way to implement OOP type code. usually mIx would be a function which takes a Matrix, and produces the result, which is not passed around with the data
00:26:17 <dwat3r> yeah, unusual.. it's for university :D I'm trying to decode the teacher's way of thinking. :D so, my problem is that I don't know how to pass m to Seq.index
00:26:27 <dwat3r> in that context of course
00:30:29 <hackrilege> aha i do want CoFree
00:30:35 <hackrilege> thanks
00:32:29 <hackrilege> but for something else...
00:37:37 <Lovepon> hackrilege: CoFree, the Haskell Cofee.
00:37:39 <Lovepon> Coffee*
00:37:47 <Squarism> Is there some must read book for FP? Or some book that make me understand most concepts mentioned in this channel? Or where have you learned the meaning of Comonad, Cofree, Align, Rope etc?
00:38:35 <simpson> Squarism: We learn things by exchanging ideas and communicating; if there was some must-read book, I haven't read it.
00:38:46 * Zemyla snuggles nini~ â™¥
00:38:58 <Zemyla> Wait, wrong channel. Oh well.
00:39:53 <Lovepon> Zemyla: You're as lewd as pyon -imouto
00:42:19 <hackrilege> Squarism co prefix indicates changing the direction of Arrows eg return :: m a -> a, coreturn = a -> m a
00:42:48 <Squarism> oh ok.. good to know
00:43:14 <Squarism> so most here are self learned? No university classes on the subject? No books?
00:43:38 <Squarism> i thought haskell as academic it gets
00:43:40 <hackrilege> oops i got those backwards lol
00:43:48 <Squarism> as = is
00:44:15 <hackrilege> so while a monad has functions to wrap and internally concatinate, a comonad has a function to extract and extend
00:44:44 <Lovepon> Squarism: as = is as*
00:45:09 <Squarism> Lovepon, correct!
00:45:22 * Squarism dont know what he did there
00:45:41 <hackrilege> a Free datatype is just a Free datatype inside a datatype or some other supplied type
00:45:58 <hackrilege> a Free datatype is just a Free datatype inside a datatype and some other supplied type
00:46:16 <hackrilege> a CoFree datatype is just a CoFree datatype inside a datatype and some other supplied type
00:46:23 <hackrilege> the middle statement is incorrect
00:46:38 <Lovepon> Squarism: now we have a stack overflow. =_=
00:47:07 <hackrilege> thats a defnition of the things asked about which i am learning about an can tell
00:47:25 <Squarism> hackrilege, good breakdown
00:56:06 <hackrilege> on line 78 of this paste http://lpaste.net/161200
00:56:24 <hackrilege> is a function i cant use to write coreturn with
00:57:10 <hackrilege> fromZipper :: Stack s => Zipper s a -> s a
00:57:37 <hackrilege> data Zipper s a = Zipper (s a)  (s a)
00:58:50 <hackrilege> i needed to include s as a parameter in order to constrain it to instantiate class Stack
00:59:25 <hackrilege> but really i would like to use Zipper as a kind *->* thing
00:59:34 <hackrilege> is there a way to get round this?
01:00:05 <Squarism> hackrilege, how did you get into haskell? And what has been your approach learning?
01:00:32 <hackrilege> i could answer that in a second but i really need to blitz this bug
01:00:36 <jle`> Squarism: haskell isn't particularly academic
01:00:41 <zipper> Hello hackrilege 
01:00:54 <zipper> Called my nick 1000 times haha
01:00:57 <zipper> Anyway
01:00:58 <hackrilege> class 1997
01:01:07 <hackrilege> zipper, ol boddy
01:01:15 <hackrilege> buddy, ol pall
01:01:18 <zipper> Uh so I am using stack and tried running ghci
01:01:28 <zipper> Says ghci not installed
01:01:48 <tolt> zipper, just to make sure, you're using 'stack ghci' right?
01:01:49 <kadoban> zipper: 'stack ghci'
01:01:59 <zipper> No I'm not
01:02:06 <tolt> ahh. That's the answer.
01:02:15 <zipper> Trying to write something using https://github.com/ndmitchell/ghcid#using-it
01:02:23 <lyxia> hackrilege: you need to fmap twice: fromZipper . (fmap . fmap) f . extend
01:02:38 <hackrilege> doh
01:02:39 <hackrilege> lol
01:02:41 <lyxia> oh wait no
01:02:41 <hackrilege> thnx
01:03:00 <Squarism> jle`, SPJ was a professor/researcher? I got the impression the language has worked as a testbed for "new concepts" from the "language research community"
01:03:06 <hackrilege> im missing an instance for GridZipper
01:03:10 <hackrilege> its a mess actually
01:03:21 <hackrilege> sorry i should update it
01:04:01 <zipper> Ah issues with target. Guess I'll look into that later.
01:04:01 <kadoban> zipper: 'stack install ghcid' ? It looks like it supports stack already, it mentions it at least.
01:04:01 <jle`> Squarism: people do use haskell for that, but that doesn't mean it's an academic language
01:04:03 <lyxia> well I mistakenly assumed GridZipper was a Comonad and not a synonym
01:04:07 <hackrilege> imagine GridZipper was a datatype with instances for Comonad
01:04:11 <jle`> Squarism: people test new features in java and python too
01:04:23 <tenniscp25> how to read from GHCJS.DOM.WebSocket? i don't see anything like read/recv in that package.
01:04:34 <jle`> if someone uses python to try out a new language concept, does that make python an academic language?
01:04:36 <zipper> kadoban: Does it? because it complained about not finding targets maybe I'll have to do some work on ghcid idk
01:04:50 <lyxia> hackrilege: just "fmap f . extend"
01:05:03 <zipper> I think I have to give it the dependent files in the target list but that means cabal.
01:05:12 <lyxia> hackrilege: ah well if you fixed it that way then nevermind
01:05:14 <zipper> Everything is hazy sorry for rubber ducking here
01:05:17 * zipper leaves
01:05:31 <hackrilege> > gmap :: (GridZipper a -> b) -> [[a]] -> [[b]]
01:05:31 <hackrilege> > gmap f =  fromZipper . fromZipper . (fmap f) . extend . toZipper
01:05:32 <lambdabot>      Not in scope: â€˜gmapâ€™
01:05:32 <lambdabot>      Perhaps you meant one of these:
01:05:32 <lambdabot>        â€˜fmapâ€™ (imported from Control.Monad.Writer),
01:05:32 <lambdabot>  <hint>:1:8: parse error on input â€˜=â€™
01:05:35 <hackrilege> oops
01:05:46 <hackrilege> anyway thats what i have now
01:06:09 <hackrilege> lyxia, no the real bug is underneath that
01:06:30 <hackrilege> i cant write  comonad instance for (Zipper [])
01:07:07 <lyxia> ah
01:07:10 <hackrilege> fromZipper :: Stack s => Zipper s a -> s a
01:07:21 <hackrilege> thats my candidate coreturn
01:07:39 <hackrilege> but as you see, its stolen the parameter s
01:07:52 <Squarism> jle`, i dont mean users of that compiler uses it as a testbed. I meant those developing the language tries to incorporate the most advanced features ive seen. Making me feel its on the forefront of development/"programming language evolution"
01:08:03 <hackrilege> as coreturn:: Zipper s a -> a
01:08:12 <Squarism> i dont mean users of the compiler use it as a testbed. I meant those developing the language tries to incorporate the most advanced features ive seen. Making me feel its on the forefront of development/"programming language evolution"
01:08:40 <jle`> Squarism: that's what i meant, too -- the python team also tries to integrate new PL ideas into python
01:09:02 <hackrilege> stemming from the fact i wish to provide as a parameter to Zipper
01:09:02 <jle`> but the important thing to me is that people use python primarily for non-academic, industry and hobby work
01:09:15 <jle`> same for haskell.  most haskell users use it for non-academic, industry/hobby work
01:09:25 <Squarism> oh ok
01:09:37 <jle`> what do you consider an 'academic language'?
01:09:52 <hackrilege> brainfuck
01:09:56 <jle`> if most use cases of haskell are in "real-world" industry, does that make it non-academic to you?
01:10:02 <Squarism> exactly
01:10:36 <lyxia> hackrilege: Isn't coreturn "create"?
01:10:39 <hackrilege> yeah, haskell is a fully fledged language, its used in garbage trucks and stuff
01:11:02 <hackrilege> no thats also an error, create is return
01:11:09 <Squarism> i come here with little insight (and predjudice) i guess. I very curious to learn though
01:11:27 <lyxia> hackrilege: ah right!
01:11:33 <Squarism> I am
01:11:34 <hackrilege> sorry!!
01:11:53 <lyxia> hackrilege: So you want your fromZipper to be your coreturn
01:11:58 <hackrilege> yes
01:11:58 <lyxia> hackrilege: what's the other operation
01:12:16 <hackrilege> at the moment it does not work
01:12:23 <hackrilege> it wants to return a type 'a'
01:12:23 <lyxia> I'm still trying to figure out how your instance would work
01:12:44 <hackrilege> last $ iterate' right
01:12:51 <lyxia> I mean, if it worked, what would be the definitions you use
01:12:59 <hackrilege> ^
01:13:47 <lyxia> iterate' expects a second argument here
01:13:55 <hackrilege> last . fromJust . iterate' right
01:14:09 <hackrilege> iterate' is safe
01:14:17 <hackrilege> (cant return Nothing)
01:14:55 <lyxia> what's that, extend?
01:15:02 <hackrilege> no thats coreturn
01:15:18 <hackrilege> it puts the zipper at the start and takes it out of the zipper
01:15:36 <hackrilege> oops.
01:15:54 <hackrilege> forward . last . fromJust . iterate' right
01:16:39 <lyxia> ok. what about cojoin
01:16:48 <hackrilege> forward . last . iterate' right
01:16:59 <hackrilege> iterate' has fromJust sorry
01:17:47 <hackrilege> um cojoin = toZipper . iterate' left
01:20:56 <hackrilege> problem is that fromZipper = forward . last . iterate' right returns '[a]', while coreturn gives just 'a'
01:21:28 <hackrilege> stemming from z s a
01:22:36 <lyxia> I'm not sure fmap coreturn . cojoin works here
01:23:05 <lyxia> since coreturn moves all the elements to the left
01:23:48 <lyxia> hmmm no that's not the fmap I'm thinking of
01:27:00 <lyxia> you can make it so that all your zippers are Zipper s (s a) with a GADT but you wouldn't be able to make it a functor.
01:27:19 <hackrilege> hmm
01:27:45 <hackrilege> whatever needs to happen...
01:27:57 <lyxia> why don't you want coreturn :: Zipper s a -> a
01:28:01 <hackrilege> im sure its not the only solution though
01:28:30 <hackrilege> because data Zipper = Zipper (s a) (s a)
01:28:43 <hackrilege> it contains (s a)
01:29:23 <lyxia> which contains a
01:32:04 <hackrilege> your saying you would expect cojoin to act as it would on a list
01:32:07 <hackrilege> i dont want to do this
01:33:18 <hackrilege> :type coreturn (a::(Zipper Tree a))  = Tree a
01:33:19 <lyxia> not quite since there will be content to the left of every element
01:34:09 <hackrilege> ?
01:34:14 <hackrilege> nvm
01:35:56 <hackrilege> i should be able to write Zipper (Zipper []) a, it should be the same as Zipper [] a
01:37:32 <hackrilege> Zipper s (s a) sounds promising
01:37:42 <lyxia> I can't say why exactly but this looks wrong anyway
01:38:04 <lyxia> maybe you're not defining a comonad
01:38:08 <hackrilege> sure
01:38:14 <hackrilege> just something with the same type
01:38:25 <hackrilege> i didnt check any laws
01:38:35 <hackrilege> but anyway thats not the point
01:38:42 <hackrilege> i can define my own class
01:38:48 <hackrilege> with functions of the same type
01:39:02 <hackrilege> i still cant write instances for them!
01:39:17 <lyxia> if it doesn't satisfy the laws don't call it a comonad
01:39:25 <hackrilege> ok
01:40:36 <hackrilege> but toZipper.(iterate' left) looks so much like a cojoin
01:40:40 <lyxia> perhaps your typeclass should be on types of kind * -> * -> *
01:41:05 <lyxia> or be multiparam
01:41:27 <hackrilege> hmm interesting
01:41:34 <hackrilege> shame its not a comonad though
01:42:39 <hackrilege> still would like to write z (s a) though
01:42:44 <lyxia> well not in the comonad-package's Comonad sense
01:43:22 <hackrilege> seriously, thats a side issue
01:43:43 <hackrilege> i think the way im pushing for is this GADT thing, i cant see why i cant do what im trying to do here
01:43:56 <hackrilege> i wasnt even importing Control.CoMonad
01:44:47 <hackrilege> maybe im going screenblind, ill take a break
01:45:21 <hackrilege> thanks for your help lyxia, i guess ill forget this class thing for now and focus on the Free stuff
01:48:46 <hackrilege> any idea what i should call this thing which isnt cojoin and this thing that isnt coreturn of types Zipper m a -> Zipper m (Zipper m a), Zipper m a -> m a respectivly?
01:55:23 <hackrilege> or this class which isnt Comonad?
01:57:08 <lyxia> maybe these names are not such a bad idea after all and I'm just too conservative about suggesting structure where I can't see any.
02:03:42 <hackrilege> i have an even worse error now about not being able to match kinds iv never seen before probably due to this new language extension
02:03:44 <hackrilege> http://lpaste.net/161214
02:04:07 <hackrilege> meta definition is failing
02:05:35 * hackagebot servant-csharp 0.0.1.0 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.1.0 (KatsutoshiItoh)
02:05:44 <lyxia> hackagebot: what's the error
02:06:03 <lyxia> your instances have just one parameter
02:06:57 <hackrilege> aha thanks
02:07:40 <azog> http://lpaste.net/161215  is there any way to explicitly show that the parameters (which are text and size) for GuiButton don't matter? I wrote an Eq instance for it that discards the arguments, but I'd like to use that in code aswell
02:07:54 <azog> or do I have to pass some bogus arguments
02:08:38 <lyxia> Haha I wrote to hackagebot instead of hackrilege
02:08:46 <hackrilege> i still dont get the error
02:09:27 <lyxia> azog: I think putting "undefined"s conveys that meaning
02:09:50 <lyxia> or some defined bogus arguments if GuiButton is strict
02:10:10 <azog> it's not
02:10:28 <azog> passes the typechecker at least, thanks!
02:10:58 <hackrilege> Kind incompatibility when matching types:
02:10:58 <hackrilege>   z0 :: (k -> *) -> * -> *
02:10:58 <hackrilege>   Zipper :: (k -> *) -> k -> *
02:10:58 <hackrilege> Expected type: Zipper s a -> Maybe (Zipper s a)
02:10:58 <hackrilege>   Actual type: z0 s a0 -> Maybe (z0 s a0)
02:10:58 <hackrilege> Relevant bindings include
02:10:58 <hackrilege>   meta :: Zipper s a -> [Zipper s a]
02:10:59 <hackrilege>     (bound at C:\Users\User\Desktop\restart 10-0
02:11:00 <hackrilege> pper.lhs:84:3)
02:11:00 <hackrilege> In the first argument of iterate', namely `left'
02:11:01 <hackrilege> In the expression: iterate' left
02:11:06 <lyxia> azog: an explicit case would be the more principled solution
02:11:25 <lyxia> define "isGuiButton", etc.
02:12:04 <azog> yeah that makes sense
02:13:34 <hackrilege> i have never seen an error like that before!
02:16:20 <hackrilege> any clues lyxia?
02:20:36 * hackagebot servant-csharp 0.0.2.0 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.2.0 (KatsutoshiItoh)
02:20:54 <lyxia> hackrilege: Zipper is too general because of Polykinds
02:23:00 <Heather> removeDirectoryRecursive: unsatisfied constraints (The directory is not empty.) - what is it?
02:26:14 <Heather> permission problems?
02:37:13 <Oejet> Heather: I haven't been able to reproduce that error on Linux at least. Could you say some more about the files, and directories, their permissions, etc?
02:52:25 <Heather> Oejet was trying on windows... what info about files you need there, there was folder with files and folders, I'm running removeDirectoryRecursive on it and it tells me that directory is not empty, well ... I know that it's not empty :)
02:53:39 <srhb> Heather: Well, it sounds buggy that the implementation would differ that much.
02:53:43 <Heather> oh I should use removePathRecursive
02:53:47 <Heather> I guess
02:54:12 <srhb> Pretty sure removeDirectoryRecursive should work as well
02:54:16 <srhb> Might want to file a bug
02:54:18 <srhb> https://github.com/haskell/directory/issues
02:54:44 <Heather> doesn't seems like so https://hackage.haskell.org/package/directory-1.2.5.1/docs/src/System-Directory.html#removeDirectoryRecursive
02:54:52 <Heather> ioError . (`ioeSetErrorString` "not a directory") $
02:56:56 <Heather> or not...
02:58:15 <Heather> removeDirectoryRecursive runs removeContentsRecursive 
02:58:28 <Heather> should work but it doesn't and error message is pretty strange
02:59:54 <Oejet> Heather: Does removeDirectoryRecursive work on empty directory? How about a directory containing an empty directory, or one containing a file?
03:02:28 <Heather> Oejet sorry currently have no time for testing that and getting much into sources, basically it should be easy to reproduce on windows and I wonder why it's not known
03:04:15 <Oejet> Heather: Yeah, it does sound odd.
03:07:53 <Heather> I see, it only happens when I run my executable from atom editor environment o_O
03:09:21 <anaxkreon> Is there a function like error which in addition to a message prints the source location of the call?
03:10:14 <Heather> I've got .atom-build.yml which has cmd: shake (runs build process from editor) and then if fails with that error, sometimes, after 2nd run it passes and error doesn't appear but then it's failing again... possibly atom is trying to write there?
03:10:56 <Heather> anaxkreon full error is: site.exe: removeDirectoryRecursive: permission denied (Access is denied.)
03:12:26 <Heather> maybe if I simple add those folders to gitignore atom will not mess with them
03:14:12 <Heather> didn't helped
03:14:22 <Oejet> Heather: So Atom could be writing into a subdirectory of something that site.exe tries to recursively delete?
03:14:26 <Heather> but it's more atom problem now I guess
03:14:46 <Heather> Oejet yes, I think something like that
03:15:15 <Heather> Oejet I wish I can set atom to not mess with this folder
03:20:37 * hackagebot psqueues 0.2.2.1 - Pure priority search queues  https://hackage.haskell.org/package/psqueues-0.2.2.1 (JasperVanDerJeugt)
03:22:32 <lyxia> anaxkreon: look at the located-base package
03:40:36 <jophish> Say I have a type which is an instance of Ord, does there exist in Hackage a wrapper: data WithMinElement a = Min | Some a; instance Ord a => WithMinElement a where compare Min Min = Eq; compare Min _ = LT; compare _ Min = GT; compare (Some x) (Some y) = compare x y
03:41:44 <bergmark> jophish: Bounded gives you a min and max
03:41:46 <jophish> probably called LeastElement
03:42:09 <lyxia> Maybe
03:42:21 <jophish> bergmark: that's close, but min doesn't compare less than to all the elements in the type
03:42:26 <jophish> it's equal to the existing min element
03:43:03 <meditans> is there a way to debug why haskell can't derive an instance of a typeclass when I think it should? Like, observing the proof search for the instance?
03:43:08 <lyxia> Nothing compares smaller to any Just
03:43:16 <jophish> lyxia: ! of course
03:43:19 <jophish> thank you
03:48:53 <bblfish> Monads are often defined as the triple  (T,Î·,Î¼). ( eg. http://www.paolocapriotti.com/blog/2013/11/20/free-monads-part-1/ ) 
03:49:24 <bblfish> T is a type I suppose. What is Î·,Î¼?
03:50:03 <anaxkreon> lyxia: Thank you
03:51:26 <anaxkreon> CallStack seems to be the solution
03:51:27 <aarvar> bblfish: T is an endofunctor, Î· is return, Î¼ is join
03:51:51 <meditans> bblfish: Î· is return, Î¼ is join
03:51:58 <aarvar> meditans: too slow!
03:52:11 <meditans> aarvar: xD I had to paste the greek letters!
03:52:19 <aarvar> meditans: so did I!
03:52:27 <meditans> xD
03:52:44 <bblfish> thanks @aarvar @meditans 
03:52:45 <bblfish> Also I thought Monads were functors but in https://ncatlab.org/nlab/show/monad they are defined without mentioning functors.
03:53:56 <meditans> well, but they say that t has to be an endomorphism
03:54:01 <meditans> https://ncatlab.org/nlab/show/monad#monads
03:55:01 <bblfish> ah so I suppose because it is an endomorphism in a bi-category that means its a functor...
03:55:17 <ertes> jophish: see Bounded
03:55:21 <ertes> > minBound :: Int
03:55:22 <lambdabot>  -9223372036854775808
03:55:48 <ertes> jophish: Maybe introduces an *additional* element that behaves like an aritifical minimum
03:55:50 <meditans> bblfish: that was the intuition I had glancing at it, but I'm not sure on the details
03:56:11 <meditans> bblfish: I'm not familiar with this presentation with bi-categories
03:56:26 <ertes> jophish: see also the various monoidsâ€¦  in a "max" monoid, the minBound is the identity element
03:56:28 <meditans> let's hope that someone more knowledgeable clears that for us!
03:56:41 <bblfish> yeah ncatlab is the least easy way to get to understand category theory it seems to me. 
03:59:28 <anaxkreon> Does CallStack require an extension? The code of myerror in https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Stack.html#t:CallStack causes a compilation error
04:00:11 <lyxia> anaxkreon: ImplicitParams perhaps
04:00:33 <aarvar> bblfish: well, t appears to be a functor there, since the diagrams use map
04:00:35 <meditans> I created a minimal example of the class instances at https://gist.github.com/073c24dd2e6aeeaee6fb3c5c3592c16b
04:01:04 <ertes> jophish: newtype Max a = Max { fromMax :: a } deriving (Eq, Ord, Show, Num); instance (Bounded a, Ord a) => Monoid (Max a) where mempty = Max minBound; mappend (Max x) (Max y) = Max (max x y)
04:01:11 <meditans> I don't understand the error I included, as intuitively I see why that instance should be there
04:01:26 <anaxkreon> lyxia: Yes, you are right
04:02:22 <lyxia> ertes: "data WithMinElement a = Min | Some a" suggests having a separate element for the minimum is exactly what jophish wants.
04:03:06 <aarvar> meditans: you probably want a super class constraint on HRC?
04:03:31 <bblfish> aarvar: I see it now. It's tÎ¼  But one really has to know what one is looking for there to see it.
04:03:39 <meditans> aarvar: could you be more precise?
04:03:58 <aarvar> or, you could define a type family returning a constraint
04:04:53 <meditans> aarvar: 5+
04:04:54 <aarvar> can you do type family HRC (xs :: [*]) :: Constraint where HRC '[] = (); HRC x ': xs = (Eq x, HRC xs)
04:05:29 <aarvar> then you can define a class which turns that into a type constructor if you want
04:06:17 <lyxia> aarvar: simply define Eq (Relation f as) instead of pattern matching on the typelist?
04:06:27 <lyxia> what who was that addressed to
04:06:30 <lyxia> meditans: ^
04:06:44 <ertes> lyxia: since it didn't follow from the prose, i wanted to point it out
04:07:13 <meditans> aarvar, lyxia: I'd like to understand before why the code doesn't work in this form
04:07:43 <meditans> shouldn't be possible use the instance for Eq for Relation using the info we have?
04:07:49 <aarvar> `HRC as` doesn't imply anything
04:08:04 <aarvar> since it has no super constraint
04:08:41 <meditans> aarvar: ooh, so it doesn't imply that we have (Eq a) for every element of as
04:08:42 <lyxia> meditans: I think GHC simply doesn't support this kind of assertion
04:08:55 <meditans> although in practice we have that, right?
04:09:28 <lyxia> right
04:09:32 <aarvar> meditans: yes, but that needs to be reflected in a super class constraint
04:09:57 <tero-> which is the best AWS library?
04:10:18 <lyxia> pattern matching on types is tricky because of type erasure or something like that
04:10:24 <aarvar> and you can generalize this to a constraint which gives you some (F a) for every a in as
04:10:25 <tero-> aws has 154 stars, amazonka has 146 stars 
04:10:33 <aarvar> lyxia: what?
04:10:59 <aarvar> the pattern match happens at the type level
04:12:26 <meditans> aarvar: so, I should define a ForAll Eq as, or something like that, which is a superclass of HRC, right?
04:12:42 <meditans> instead of writing the eq constraint simply on the second instance
04:13:07 <aarvar> type family _Forall (f :: k -> Constraint) (xs :: [k]) :: Constraint where _Forall f '[] = (); _Forall f (x ': xs) = (f x, _Forall f xs)
04:13:44 <aarvar> class _Forall f xs => Forall f xs; instance _Forall f xs => Forall f xs
04:13:47 <aarvar> does that work?
04:16:17 <meditans> aarvar: I get a Malformed head of type or class declaration: _Forall f '[]
04:17:47 <meditans> fixing that up and trying again
04:20:29 <aarvar> meditans: type names can't start with underscores, silly me
04:20:40 * hackagebot yesod-job-queue 0.1.0.3 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.1.0.3 (nakaji_dayo)
04:21:27 <meditans> aarvar: I fixed that, now I'm trying to integrate it with my error
04:22:51 <meditans> aarvar: here's the new version https://gist.github.com/00346ed8cd1460570788cd3395fceff4 
04:23:00 <meditans> but I still get the error like before
04:24:24 <lyxia> meditans: you should use Forall to define Eq (Relation f as) too
04:24:41 <aarvar> yeah...
04:26:38 <ntnt> when a haskell datatype exports its constructors, is it breaking OO principles of encapsulation (since it's making all its' members public)
04:27:29 <aarvar> ntnt: no
04:28:03 <ntnt> why not
04:28:04 <aarvar> you could still change the implementation without breaking code by using a pattern synonym, if that's what you mean
04:28:25 <ntnt> in that acse, you export the constructors of the pattern synonym, but not the constructors of the object
04:28:51 <cocreature> ntnt: itâ€™s somewhat true, but in most cases your datatypes are generic enough that there is no invariant that should be preserved, so making all its members public is not a problem
04:29:14 <ntnt> I used to make all constructors public, but now I'm reading the 'refactoring' book
04:29:22 <hpc> or to put it another way, there's nothing to encapsulate
04:29:22 <aarvar> using encapsulation to enforce invariants is a hack to make up for weak type systems anyway
04:29:23 <cocreature> ntnt: e.g. take a list, what do you gain by not making the constructors public
04:29:27 <ntnt> and I'm wondering if I should make them private -- then have export special constructor functions
04:29:41 <ntnt> if not all objects are valid, my constructor function can only create valid objects
04:29:50 <ntnt> like a data Foo = Foo Int Int Int where a + b = c
04:29:54 <ntnt> (yeah, that was a silly example)
04:30:07 <ntnt> but (1) in cases where not all values are valid, constructoFunctions can ensure we only create valid objects
04:30:07 <aarvar> ntnt: if that's the case then yes, encapsulate it
04:30:23 <ntnt> (2) it seems like functions that "poke at internals" should be in the same module
04:30:37 <ntnt> so hiding the constructors helps me see when functions that "look at too much internal details" should be moved into which module
04:30:38 <aarvar> though it'd be better to use types to prove a + b = c
04:30:39 <meditans> aarvar: lyxia: is there a way to query ghci with questions like: do you think this is an instance of this?
04:30:53 <ntnt> aarvar: does haskell's dependent types allow for that?
04:31:25 <aarvar> well, haskell doesn't have dependent types
04:31:28 <hpc> what would be better is to let (a + b = c) be some sort of function
04:31:43 <hpc> you only need any two of the three values to encode all you need to
04:31:55 <hpc> remove the invariant
04:31:59 <aarvar> yes, in that case
04:32:09 <ntnt> hpc: well, suppose you are storing a rect
04:32:12 <ntnt> you probably want to do data Rect = Rect x1 x2 y1 y2
04:32:15 <ntnt> where x2 >= x1, y2 >= y1
04:32:20 <ntnt> now, you could tore Rect x width y height
04:32:26 <ntnt> but then you need widht >= 0, height >= 0
04:32:30 <lyxia> meditans: you can define "isInstanceOf :: SomeClass a => a -> () ; f = const ()", then, ask "isInstanceOf (undefined :: MyType)"
04:32:32 <ntnt> so I don't think you can get away with "store less data"
04:33:00 <aarvar> you can either encode that in types or use encapsulation then
04:33:23 <aarvar> the former might not be practical
04:33:27 <aarvar> in haskell
04:34:44 <ntnt> or you hide the Rect construtor, then define a newRect x1 x2 y1 y2 = Rect (min x1 x2) (max x1 x2) (min y1 y2) (max y1 y2)
04:35:02 <hpc> meditans: use :i
04:43:29 <aarvar> > let inst :: a => p a -> (); inst = const () in inst (Proxy :: Proxy (Monoid String))
04:43:31 <lambdabot>  ()
04:43:40 <aarvar> > let inst :: a => p a -> (); inst = const () in inst (Proxy :: Proxy (Monoid Int))
04:43:41 <lambdabot>      No instance for (Monoid Int) arising from a use of â€˜instâ€™
04:43:41 <lambdabot>      In the expression: inst (Proxy :: Proxy (Monoid Int))
04:43:41 <lambdabot>      In the expression:
04:44:18 <aarvar> meditans: like that?
04:44:23 <ntnt> https://sourcemaking.com/refactoring/smells/switch-statements <-- does this apply to Haskell? I use case ... of .... all the time
04:44:56 <tiny_test> main() {
04:44:56 <tiny_test> var n;
04:44:56 <tiny_test> n = input;
04:44:56 <tiny_test> return foo(&n,foo);
04:44:57 <aarvar> ntnt: no
04:45:23 <tiny_test> dang, sry
04:45:25 <ntnt> aarvar: yeah, it did look alot more OO-ish to me (taht book)
04:45:31 <aarvar> ntnt: there's no such thing as OO anyway
04:45:49 <Ferdirand> no, that doesn't apply at all
04:46:11 <Ferdirand> their point is that that kind of behaviour is best implemented by overriding a method
04:47:28 <aarvar> ntnt: you probably do want to avoid using case too much though, but for different reasons
04:48:07 <aarvar> you can often use higher order functions instead to get more code reuse
04:48:39 <ntnt> aarvar: how is this related to higher order functions? for data types I define, I often need to do different things based on which constructor is used
04:50:35 <aarvar> ntnt: I mean you want to avoid things like f Nothing = foo; f (Just x) = x
04:50:52 <aarvar> since you can instead do f = fromMaybe foo
04:50:53 <ntnt> f = maybe foo
04:50:56 <ntnt> yeah, I know that one :-)
04:54:57 <aarvar> ntnt: and looking at that site, it's mostly nonsense
05:02:57 <ski> ntnt : "OO" in this context more or less mean a record (closure). "breaking OO principles of encapsulation" then would mean to expose as fields in the record things that you meant to have as nonlocals captured by the closure
05:03:17 <ski> ntnt : if you'd like to dualize, then "a haskell datatype exports its constructors" corresponds to "an OO class (or object type) exporting its methods", which is a common/normal thing to do (otherwise, how do you interact with objects/records of that type ?)
05:03:29 <ski> ntnt : "the 'refactoring' book" -- which is ?
05:03:44 <ntnt> ski: http://martinfowler.com/books/refactoring.html
05:03:50 <ski> aarvar : "using encapsulation to enforce invariants is a hack to make up for weak type systems anyway", yes and no. yes, using abstract data types to simulate subtypes and quotient/factor types is a hack to make up for weak type systems. no, i wouldn't call using lexical scoping to hide details a hack (in the pejorative sense)
05:04:02 <ski> ntnt : if the constructors are intended to be part of the interface, then exporting them is not breaking encapsulation. if not, then it is. it depends on what your intent is, what type you're really attempting to express in the language
05:04:07 <ski> ntnt : "(1) in cases where not all values are valid, constructoFunctions can ensure we only create valid objects" -- subtypes
05:04:11 <ntnt> ski: suppose you have "data Foo = ..." instead of exposing it's constructors, you can have newFoo1, newFoo2, newFoo3, and a bunch of "... -> Foo" functions
05:04:12 <ski> ntnt : "(2) it seems like functions that "poke at internals" should be in the same module" -- quotient/factor types
05:04:35 <ntnt> ski: how would you recommend solving the "data Rect = Rect x1 x2 y1 y2" where x1 <= x2, y1 <= y2 in all valid instances ?
05:04:50 <aarvar> ski: well, I said using it to enforce invariants
05:05:06 <aarvar> which is different from just hiding details
05:05:11 <ski> ntnt : "<-- does this apply to Haskell? I use case ... of .... all the time" -- yes and no. it applies in the case that you'd like to structure your data types and code in terms of OO/records structuring, as contrasted to to "FP"/variants structuring
05:05:20 <ski> (s/to to/to/)
05:05:45 <ntnt> ski: can you point me at a compare and contrast of "OO/records structuring vs FP/variants structuring" ?
05:06:41 <ski> aarvar : making sure all constructible values is in a subset is an invariant. maybe you could think of making sure that no exported operation can tell the difference between equivalent values represented in different ways as "enforcing invariants" as well, not sure
05:09:43 <ski> ntnt : that `Rect' case is obviously a subtype, so if your type system (like Haskell's) can't express that directly, you'd use an abstract data type, hiding the representation, and instead export operations to construct and deconstruct values of the type
05:10:07 <ntnt> ski: can you give me concrete code?
05:10:14 <ntnt> you're using lots of words I don't understand
05:10:18 <ntnt> a sample code would make it much clearer to me
05:10:26 <ski> ntnt : "can you point me at a compare and contrast" -- well, let's consider this, somewhat silly example
05:10:46 <aarvar> ski: he meant data Rect = Rect { x1, x2, y1, y2 :: Int }
05:10:53 <aarvar> where x1 <= x2 etc
05:11:04 <ski> hm
05:11:05 <aarvar> there's no subtyping there
05:11:28 <ski> ntnt : if there's words you don't understand, ask about them, and i will try to explain
05:11:51 <ntnt> well, the thing is -- I don't want abstract ideas -- I want to see them in action
05:11:51 <ski> (if i don't know what parts you're having trouble with, then i will have trouble explaining them to you)
05:11:54 <aarvar> and types can be used to ensure that all values are in a subset, in theory at leasst
05:12:10 <ntnt> like the currenct best I ahve is: "newRect x1 x2 y1 y2 = Rect (min x1 x2) (max x1 x2) (min y1 y2) (max y1 y2)"
05:12:23 <ntnt> I have no idea if that is the same as "abstract data type, hiding the rep, and instead export subtyping"
05:12:28 <ntnt> but I do understand how taht code works
05:12:32 <ski> well, i suppose one of my points is that you need *both* abstract ideas (concepts, "categories" to structure your thinking with), *and* concrete examples
05:12:35 <ntnt> so my qeustion is: in this case, how would you structure taht code differently?
05:12:46 <ski> i'm not going to give only examples
05:12:56 <aarvar> and abstraction can often be used instead of encapsulation?
05:13:12 <ntnt> I'm not smart enough to learn without *any* examples
05:13:21 * ski nods
05:13:21 <Lovepon> ntnt: If I were to design it, I would use two Vec2s.
05:13:22 <ski> sure
05:13:23 <ntnt> I agree that generality is good, but seeing a few concrete examples makes things make sense
05:13:47 <Lovepon> ntnt: One as the top-left corner and the other as the top-right. OR, one as the center and the other as the sixe.
05:13:49 <Lovepon> size
05:13:57 <ski> anyway, what we're talking about is more general than the specifics of e.g. Haskell
05:13:58 <ntnt> that doesn't enfroce the x1 <= x2, y1 <= y2
05:14:11 <ntnt> atm, I only care about Haskell
05:14:14 <ntnt> I don't care about other languages
05:14:22 <ntnt> I just want to learn how to write well designed ahskell code
05:14:31 <ski> ntnt : your `Rect' type, is, as far as the Haskell type goes, just a type of quadruples of `Int'
05:14:33 <aarvar> if you wanted to enforce that with types you could, but it's a bit messy
05:15:24 <ski> but, the point is, you don't intend to express just *any* quarduple of `Ints', but only quadruples `(x0,x1,y0,y1)' *satisfying* the additional condition that `x0 =< x1 /\ y0 =< y1'
05:15:44 <ski> this is a *subset* (or subtype, as we say in programming) of the set/type of *all* quadruples of `Int's
05:15:52 <aarvar> yes, that was the point
05:16:18 <aarvar> and "subtype" causes people to think of subtype polymorphism, which you don't need at all
05:16:26 <ski> in mathematics, we'd probably write this as `{(x0,x1,y0,y1) : Int^4 | x0 =< x1 /\ y0 =< y1}' (you may or may not have seen this notation before. if you haven't don't worry)
05:16:58 <ski> aarvar : yes, there's that complication/ambiguity with the terminology :/
05:17:10 <Lovepon> aarvar: To enforce it with types, I'd just use top-left corner/size or center/size.
05:17:28 <Lovepon> All as unsigned int.
05:17:39 <aarvar> Lovepon: sure, in this example that works
05:18:03 <ski> ntnt : is this making any sense at all, so far ?
05:18:16 <aarvar> ski: I'm going to guess the answer is "no"
05:18:42 <aarvar> since the question was about how to encode types like that in haskell
05:18:50 <ntnt> ski: I still haven't seen sample code
05:18:54 <Lovepon> ski: Make a list comprehension analogy.
05:18:56 <ntnt> I promise this is not a HW problem
05:19:00 <ntnt> I like to look at solutions, then dissect them
05:19:06 <ntnt> and then derive the principles from the dissection
05:19:08 <ski> yes, but before writing in Haskell, we must decide *what* we want to write/express in Haskell
05:19:14 <ntnt> rather than have a bunch of vague principles that I don't know how to apply in practice
05:19:23 <ski> if we don't know what the goal is, then there's not much point to attempt to write in Haskell
05:19:36 <ntnt> I want a way to construct something of the form that gauranteess x1 <= x2, y1 <= y2
05:19:45 <Lovepon> aarvar: ski: This actually made me curious. We have Fin, but do we have a type which guarantees that it's *at laest* a number?
05:20:42 <ski> yes, and the way you do that, in *Haskell* (in the general case. perhaps in special cases you can sometimes do something better) is to define `Rect' as an abstract data type : iow, don't export the details about how it's implemented
05:21:42 <ski> it could be implemented as `data Rect = MkRect Int Int Int Int' or `newtype Rect = MkRect (Int,Int,Int,Int)' or `newtype Rect = MkRect (Array (Bool,Bool) Int)' or ..
05:21:42 <Lovepon> ski: But it's not type safe. :3
05:21:54 <ski> it doesn't matter, since we're hiding the implementation anyway
05:22:01 <Lovepon> ski: Ye.
05:22:02 <ski> then, we'll probably define something like
05:22:13 <ski>   makeRect :: Int -> Int -> Int -> Int -> Maybe Rect
05:22:26 <aarvar> or you could use types
05:22:44 <Lovepon> aarvar: Is there an "at least" type? analogous to Fin?
05:22:59 <aarvar> Lovepon: idk, but you could easily define one
05:23:03 <ski> where `makeRect x0 x1 y0 y1' will check the condition `x0 <= x1 && y0 <= y1', and in case that's `True', construct a (valid) `Rect', otherwise in case it's `False' refuse to construct it, returning `Nothing'
05:23:15 <aarvar> and you could just use Fin in this case
05:23:34 <Lovepon> aarvar: Right.
05:23:41 <Lovepon> aarvar: Fin for the left corner.
05:23:49 <Lovepon> aarvar: I find it Ugly TM though.
05:24:12 <ski> Lovepon : re `Fin', do you mean in Agda or what ?
05:24:34 <ski> ntnt : is this concrete enough ?
05:24:59 <Lovepon> ski: I haven't used Agda, but probably. IIRC, I've seen one in Idris though.
05:25:40 <aarvar> data AtLeast n = AtLeast forall k. SNat (k + n) ?
05:25:41 <ski> in Agda, `Fin n' can be injected into `Nat', but isn't a subtype of `Nat'
05:25:49 <ski> presumably the same would be the case in Idris ?
05:25:55 <aarvar> er, oops
05:25:56 * hackagebot yesod-job-queue 0.2.0.0 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.2.0.0 (nakaji_dayo)
05:26:15 <meditans> augur: https://gist.github.com/meditans/073c24dd2e6aeeaee6fb3c5c3592c16b
05:26:21 <augur> meditans: ill give it a look
05:26:22 <ski> if you're satisfied with being able to inject, then to express "at least `n'", use `Nat', and use `add n' as the injection
05:26:42 <aarvar> data AtLeast n = forall k. AtLeast (SNat (k + n)) ?
05:26:56 <meditans> augur: I understood that the problem is that HRC doesn't imply anything about the equality of the as
05:27:03 <ski> aarvar : with `SNat :: Nat -> *', yes
05:27:15 <aarvar> right
05:27:37 <augur> oh boy you're using a lot of fancy extensions, meditans :)
05:27:38 <meditans> (this was the main insight, thanks to aarvar and lyxia)
05:27:56 <aarvar> meditans: did the Forall thing work?
05:28:00 <Lovepon> But is there a type that is actually called that?
05:28:01 <aarvar> it should
05:28:09 <aarvar> Lovepon: no idea
05:28:21 <Lovepon> Like, Fin, Nat, that's all standard.
05:28:22 <meditans> aarvar: in the end, I wasn't able to write a working version
05:28:24 <Lovepon> aarvar: I see.
05:28:29 <aarvar> meditans: why's that
05:28:38 <aarvar> did you fix the Eq instance as suggested?
05:29:06 <aarvar> instance Forall Eq as => Eq (Relation f as)
05:29:28 <augur> ehm.. but yes, meditans, thats right, you dont have any entailment of equality here from HRC
05:29:33 <augur> nor should you, i think
05:30:46 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:30:46 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:30:47 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:30:47 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:30:49 <augur> whoa there
05:30:51 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:30:51 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:30:53 <lyxia> what
05:30:54 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:30:57 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:31:00 <meditans> augur, but I think that entailment is natural, I mean, it's provable for me that I have that entailment, in a meta-theory
05:31:01 <aarvar> ...
05:31:03 <Lovepon> meditans: sshhh bby is ok.
05:31:06 <meditans> sorry guys
05:31:17 <aarvar> do you think that entailment is natural?
05:31:22 <lyxia> meditans: your cat is walking on your keyboard
05:31:25 <augur> meditans: you and your silly irc client :)
05:31:33 <cocreature> let me guess, erc?
05:31:42 <Lovepon> lyxia: By the many times he sent it, I'm guessing yes.
05:31:43 <meditans> cocreature: exactly, sorry again
05:31:44 <augur> meditans: the entailment is provable in the metatheory, sure, but thats not how haskell resolves instances
05:31:51 <Lovepon> lyxia: :3
05:31:57 <lyxia> :)
05:32:12 <Lovepon> lyxia: I'm not so sure though, try asking him again.
05:33:04 <meditans> augur: so, the main point here is that I don't have a mental model of how those instances are resolved
05:33:30 <meditans> it would be extremely useful for me to understand precisely the mechanism
05:33:47 <meditans> and then, to understand how I should encode them in the simplest way
05:34:30 <ski> aarvar : they'd need `Forall Eq (Map f as)', for some suitable `Map', i think
05:34:48 <aarvar> ski: hm?
05:35:04 <aarvar> oh, I see
05:35:10 <ski> aarvar : `instance (Eq (f a), Eq (Relation f as)) => Eq (Relation f (a ': as)) where ...', note `Eq (f a)', not `Eq a'
05:35:14 <aarvar> yeah, misread the code
05:36:19 <aarvar> or you could do Forall (ComposeC Eq f) as?
05:36:24 <meditans> ski: yes, that was part of the problem (tangent question: when should I use Eq1 f, Eq a instead of Eq (f a)? are they equivalent?)
05:36:30 <ski> meditans : if you're not changing the `Eq' instances, then i think you'd need to do some case analysis on `as' in `foo'
05:36:55 <aarvar> where ComposeC :: (k -> Constraint) -> (j -> k) -> j -> Constraint
05:37:31 <ski> meditans : hm, in this case you only need to require `Eq (f a)', and don't need to require `forall a. Eq a => Eq (f a)' together with `Eq a'
05:37:43 <kadoban> I can never remember which one is 'curry' and which one is 'uncurry' :-/
05:38:17 <aarvar> (Eq1 f, Eq a) is stronger than Eq (f a)
05:38:17 <augur> meditans: the way haskell resolves instances is quite simple
05:38:29 <augur> meditans: it either looks it up directly in the context
05:38:34 <ski> meditans : sometimes you have no name for `a', and so you'll probably want `Eq1 f'. othertimes it depends on whether you want to require more than you strictly need in the particular case or not (iow, where to put the boundaries of your interface)
05:38:56 <ski> kadoban : `curry f' is curried (from uncurried `f')
05:38:58 <augur> meditans: or it uses generative instance declarations to try to unravel the requirements until it can look it up
05:39:33 <ski> @type curry ?f
05:39:34 <lambdabot> (?f::(a, b) -> c) => a -> b -> c
05:39:36 <augur> meditans: so for instance, if you need Eq Int, it can just look up in instance for that, because its in the context and Int is not a complex type
05:40:18 <augur> meditans: on the other hand, for Eq [Int] there is no instance in context for that type, but there is a rule   Eq a => Eq [a]   so it can match  [a] = [Int] and via prolog-like search, reduce the problem to finding Eq Int
05:40:19 <kadoban> ski: Yeah that seems like it should help, but ... it never does.
05:40:25 <augur> meditans: which it can do
05:40:50 <augur> meditans: (C0, ..., Cn) => D   is very similar to prolog D :- C0, ..., Cn
05:40:56 * hackagebot xss-sanitize 0.3.5.7 - sanitize untrusted HTML to prevent XSS attacks  https://hackage.haskell.org/package/xss-sanitize-0.3.5.7 (GregWeber)
05:41:05 <augur> meditans: in fact, you can do a whole lot of shady prolog programming in class constraints
05:41:14 <meditans> augur: so, in my problem, how do I add some "prolog clauses" to make that inference possible?
05:41:43 <augur> meditans: im not sure you can. prolog generally doesnt let you prove quantificational things like that
05:41:54 <augur> meditans: i mean, a prolog clause is basically an implication, right
05:42:14 <augur> p :- q, r.    is like saying   q & r -> p
05:42:21 <aarvar> class c (f a) => ComposeC c f a; instance c f a => ComposeC c f a
05:42:48 <aarvar> instance Forall (ComposeC Eq f) as => Eq (Relation f as)
05:42:50 <aarvar> does that work?
05:42:54 <augur> predicative clauses are quantified:    p(X) :- q(X), r(X)   ~   forall X. q(X) & r(X) -> p(X)
05:43:18 <aarvar> oops, instance c (f a) => ComposeC c f a
05:43:20 <aarvar> missed the parens
05:43:30 <augur> variables that arent present in the head of the clause are existential:   p(X) :- q(X,Y)   ~   forall X. (exists Y. q(X,Y)) -> p(X)
05:44:25 <augur> meditans: that that's more or less the sum total of what you can do with prolog. propositions of the form:   forall X0 ... Xm. (exists Y0 ... Yn. Q & ... & R) -> P
05:44:42 <aarvar> or break it up into Map and FoldConstraint
05:45:01 <augur> meditans: you'll notice that this means that you cant write something like this in prolog:    forall X. (forall Y. q(X,Y)) -> p(X)
05:45:39 <augur> meditans: that is to say, you cant proof p(X) by proving forall Y. q(X,Y)
05:45:53 <meditans> aarvar: I'm trying the code you're posting, but I must be missing something, as I can't get it to work
05:46:09 <augur> meditans: that would require prolog to do some kind of inductive proof over the X's, which is non-trivial!
05:46:11 <meditans> could you post a modification here? https://gist.github.com/meditans/00346ed8cd1460570788cd3395fceff4
05:46:28 <augur> meditans: the same is true for haskell, basically
05:47:00 <augur> all you can do is unravel with (prenex-forall-quantified) implications
05:47:55 <meditans> augur: I see the point in general
05:47:57 <augur> so while the meta-level might justify the equality, that doesnt mean that it's deducible with haskell's tools
05:48:49 <meditans> augur: what's the most natural way to internalize that proof?
05:49:05 <augur> meditans: in haskell, i dont think you can
05:49:22 <augur> meditans: its at this point that i would suggest stepping back and asking if this is necessary to do in the first place
05:49:51 <augur> a lot of times, these fancy tricks are just not necessary, and we've just got ourselves tangled up in fancy proofy things for no good reason
05:50:47 <augur> you can push the haskell type system REALLY far, but its often not necessary
05:50:56 <augur> my advice is to try to avoid that until you absolutely need it
05:51:21 <augur> meditans: what are you trying to use this for?
05:51:37 <meditans> augur: I already toned down a lot of type-level machinery reverting to GATDs
05:51:48 <augur> :)
05:52:22 <meditans> but the type level just feels like a mined field xD (I'm sure that's related to my lack of understanding)
05:52:37 <meditans> augur: let me find a good commit to show you
05:53:24 <augur> meditans: one think i frequently find myself wanting to do is write something like a forall'd implicational constraint
05:53:41 <augur> something like...   forall a. Eq a => Eq (f a)   or whatever
05:54:14 <augur> as a constraint, so that i can use Eq (f a) for arbitrary a's, right
05:54:18 <augur> but this isnt possible in haskell
05:54:43 <augur> the closest thing you can use is the Eq1 type class which is like Eq but it's equality is slightly richer
05:55:21 <augur> i believe the definition is:    class Eq1 f where eq1 :: Eq a => f a -> f a -> Bool
05:55:40 <ertes> i really want -XDependentTypesâ€¦  i used to make jokes about that, but today i can totally see it happening at some point
05:55:49 <meditans> augur:  https://github.com/meditans/hyper-relation/tree/GADTs
05:55:54 <augur> ertes: i think you actually CAN do that now :)
05:55:55 <aarvar> augur: the constraints package has some stuff for this doesn't it
05:56:39 <ertes> augur: you can use singleton types, and it gives you equivalent expressiveness, but it's too inconvenient to be really useful for small use cases
05:56:52 <augur> ertes: no i mean i think there's now a -XDependentTypes
05:57:01 <augur> its experimental but
05:57:01 <ertes> augur: in what version?
05:57:28 <meditans> augur: the point is this: I want to write a data structure that encodes a relation which is searcheable in every point 
05:57:34 <augur> or maybe its not implemented yet, just being worked on
05:57:39 <augur> ertes: https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell
05:57:56 <augur> meditans: can you give me an example? its not clear to me what this means
05:58:02 <meditans> with that I mean that if a relation, is, eg (3, 'c', "hi")
05:58:03 <ertes> augur: to my knowledge they are implementing all the things necessary to make it possible, but it's not there yet
05:58:08 <lonokhov> Is there a function like pipes "next" but for conduits? something like `next :: Source m o -> m Maybe (o, Source m o)` ?
05:58:09 <maerwald> such a thing should never ever be a GHC extension
05:58:20 <augur> ertes: alternatively, you can use SHE!
05:58:33 <ertes> augur: i'd rather use singletons =)
05:58:40 <ertes> never been a huge fan of preprocessing
05:58:47 <augur> well fine, suit yourself :P
05:58:52 <meditans> augur: ok, let's say I have a bunch of "relations", which you can think as a tuple, let's say of type (Int, Char, String)
05:59:20 <meditans> and you want to find in there every relation which has in the middle spot the character 'c' in the smallest time possible
05:59:39 <jophish> Why does cabal allow me to compile my code if it depends on a module not listed in other-modules (or exposed-modules)
06:00:03 <ertes> augur: Cale's company apparently wrote a preprocessor to make arrows go fast (because they can be slower than necessary with all their tuple handling), but i ended up using applicative style instead when performance is critical
06:00:09 <lonokhov> jophish: because it uses ghc-make, which does not care about cabal
06:00:16 <meditans> so basically I encode this structure as an IntMap (Int, Char, String) and a series of hashmap Int -> Int, Int -> Char and Int -> String
06:00:18 <aarvar> meditans: k, you might need foo to have the constraint Forall (ComposeC Eq Identity) as
06:00:23 <meditans> does that makes sense, augur?
06:00:25 <michaelt> lonokhov: no, Conduit generally avoids letting you inspect the stream.
06:00:29 <augur> meditans: no :)
06:00:30 <lonokhov> jophish: other-modules are only needed for sdist
06:01:16 <aarvar> not sure if you can get it to derive Forall (ComposeC Eq Identity) as from Forall Eq as
06:01:19 <meditans> augur: please look at exHyperRelation2 in the file https://github.com/meditans/hyper-relation/blob/GADTs/src/Data/HyperRelation.hs
06:02:45 <augur> meditans: ok, now what
06:02:47 <lonokhov> michaelt: Can you suggest how to implement merge part of merge sort with two streams of ordered values?
06:02:55 <meditans> so, that's a structure which is denotationally a list of tuples, but it's encoded in a way that let you search in this list with nlog n time
06:03:51 <meditans> at the expence of space, but that's not important for now
06:04:07 <augur> meditans: ok but this is a lot of implementation detail, tell me about the problem you're trying to solve with this wild implementation stuff
06:04:13 <augur> what are you trying to achieve
06:05:14 <michaelt> lonokhov: I'm not sure, sorting isn't exactly a streaming problem, no?
06:05:17 <meditans> augur: ok, I want a framework in which I can prototype other data structure with ease: for example, I want a graph in which an edge is at the same type a node
06:05:35 <meditans> id est, I want to be able to draw edges between a node and an edge
06:06:02 <meditans> I could encode that in this structure I'm writing
06:06:12 <augur> meditans: how higher-order do you want this to be?
06:06:24 <meditans> augur: in principle, whatever it needs
06:06:29 <michaelt> lonokhov: but somehow you can assume that they are already sorted. 
06:06:32 <meditans> I mean, unbounded
06:06:45 <lonokhov> michaelt: Well, problems is not about sorting. it is about merging two streams with something more complext thant "this after that"
06:07:14 <meditans> but that's another problem: I really want to encode this approach with the generic data structure
06:07:35 <augur> meditans: now, let's define what it means to be such a graph
06:07:48 <meditans> ok, so, the last part of this hyperrelation idea is that in this tuple I also have to be able to encode "injectivities"
06:07:54 <augur> meditans: first, are these things labeled?
06:08:01 <augur> the node-edges?
06:08:16 <meditans> augur: that graph is only an example, I have multiple data structures I want to try
06:08:22 <augur> ok
06:08:44 <meditans> yes, they are labeled, (I already encoded them using fgl, but that was a mess, so I'm trying a simpler way)
06:09:03 <lonokhov> michaelt: michaelt basically what I need is merge [1,3,5] [2,4,6] -> [1,2,3,4,5,6]. but having streams as input and stream as output.
06:09:16 <augur> it sounds like you dont want specifically an answer to the graph question, but to some larger as of yet unclear question
06:09:22 <lonokhov> Oh, I'm so bad at typing today
06:09:33 <meditans> so, now I have a bunch of (Int, Char, String), but I want also to say: in this tuples, the mapping Int -> String is injective
06:09:49 <augur> meditans: this sounds like a poorly specified problem :\
06:10:02 <meditans> augur: nono, I want to construct a clear thing, I just have problem with the type level
06:10:10 <meditans> I already worked out how things work
06:10:14 <augur> meditans: it doesnt sound clear at all :)
06:10:37 <meditans> augur: that's right xD, let's try again.
06:10:45 <michaelt> lonokhov: right, I understand now, I'm trying to think what facility conduit could have for this. 
06:10:55 <dmiles> the typelevel is preventing something?
06:11:12 <meditans> let's say I have denotationally a list of tuples (t1, t2, ... tn) with ti :: Ti
06:11:17 <lonokhov> michaelt: maybe something with ResumableSource? I can't figure it out myself though.
06:11:36 <meditans> (dmiles: the typelevel + my lack of understanding xD)
06:12:15 <augur> meditans: ok, you have some list of tuples
06:12:16 <meditans> and a series of constraints of the form (t_i1, t_i2, t_is -> t_j1, t_j2, t_js)
06:12:41 <meditans> for example, a constraint (t1, t3 -> t2, t4) means that
06:13:12 <meditans> I won't find in this structure two tuples with the same t2 and t4 but different t1 t3
06:13:21 <michaelt> lonokhov: no, I don't think so, that is more for e.g. breaking a source and conduiting it, but then re-using the rest. The thing I was thinking of was using  a `ConduitM () a (ConduitM () a m) r` ...
06:13:31 <meditans> so, it's an encoding of an injective-like behaviour, right?
06:13:50 <dmiles> hrrm sounds like the creating of a knowledge engineering environmnet
06:14:31 <michaelt> lonokhov: but I don't see how to start from two pre-given sources 
06:14:53 <augur> meditans: it sounds like you'd want the arrows to go in a different direction. lets avoid using funny notation and instead just use word-y things :)
06:15:47 <meditans> augur: the arrow directions is an analogy with function injectivity: if I have a i -> j injective, I cannot find a (i,j) with the same j but different i
06:15:56 <lonokhov> michaelt: Guess in this case conduits are wrong tools for the job then
06:16:44 <michaelt> lonokhov: I think that's right. With pipes, of course, you would just use next explicitly. `machines` has facilities for writing a pipe-that-takes-two-sources
06:17:01 <Gurkenglas> I want to use something like >>> with the right argument being a lambda expression. Should I use Control.Category, Control.Arrow or another operator from another package?
06:17:29 <augur> meditans: i think you're confusing a bunch of different notions here. i dont think anything you've described so far is injectivity
06:17:56 <augur> or maybe it is, but just phrased really weirdly
06:18:02 <michaelt> lonokhov: but I'm not sure how much advantage there is in expressing such a thing as a pipe or quasi-pipe, rather than as a function :: Source -> Source -> Source
06:18:20 <meditans> augur: let's consider a function A -> B. We can see it as a list of tuples [(A,B)], ok?
06:18:26 <augur> meditans: or maybe im just tired :)
06:18:37 <meditans> augur: it's most likely my poor explanation ;)
06:18:40 <augur> but ok, lets take -> to mean injectivity
06:18:52 <augur> meditans: oh no, ive been up for a looong time so it could be my tiredness
06:18:59 <augur> i think im pushing 20 hours now
06:19:20 <aarvar> meditans: http://lpaste.net/161225
06:19:21 <kadoban> Gurkenglas: Well, (>>>) works fine for that ... use it from whichever one exports it. Or if the precedence isn't to your liking, I think you have to make your own, I don't know of another one.
06:19:37 <aarvar> idk if there's a way to make bar work
06:19:38 <Gurkenglas> Both export it
06:19:40 <augur> meditans: so ok, you have such a constraint. now what?
06:20:35 <meditans> augur: I may have many constrains of that kind. That's it, I just want to encode that structure, that prevents me to add things when I don't respect the invariants
06:20:47 <augur> i see
06:21:07 <augur> i dont think you can get that in haskell at all, really. not in any deep way
06:21:10 <kadoban> Gurkenglas: Then doesn't really matter, they're the same one I'm sure.
06:21:38 <kadoban> Gurkenglas: It used to be only from Arrow, but that was so long ago I don't even know what GHC version it'd correspond to.
06:21:41 <augur> the best you can do i think is to use a Map, eg   Map (t1,t3) (t2,t3)
06:21:59 <meditans> and, given that structure, I can now say that a weird graph like before is just a map describing the id nodes, and a map (Tgt1, Edge, Tgt2) in which there is an Tgt1, Tgt2 -> Edge injectivity
06:22:02 <augur> er, (t2,t4)
06:22:25 <augur> and that means that if you have a (t1,t3) key, you have exactly one (t2,t4) value associated with it
06:22:54 <meditans> augur: the main problem with that is that the map is not searcheable in my sense: I might want to know which relations have a specified t1 and t4, for example, and I need that search to be as fast as possible
06:23:12 <augur> meditans: ok so define searable
06:23:15 <augur> searchable*
06:23:42 <meditans> aarvar: thanks for the code, I will try it and report back any success!
06:23:50 <augur> you want to do reverse lookup on this basically?
06:24:05 <augur> er, sorry, i wrote it wrong, in fact!
06:24:18 <augur> injectivity should be   Map (t2,t4) (t1,t3)
06:24:32 <augur> anyway, so you want to be able to search either direction quickly and efficiently
06:24:36 <meditans> augur: I basically create a map from every t1 in the tuple, to a hidden int which indexes relations
06:24:40 <michaelt> lonokhov: so for example in machines, if you use http://hackage.haskell.org/package/machines-0.6/docs/Data-Machine-Plan.html#v:awaits you can write `awaits Source1` and `awaits Source2` into a do block and then stick the two sources onto the resulting machine ; I guess you would use http://hackage.haskell.org/package/machines-0.6/docs/Data-Machine-Wye.html 
06:24:47 <augur> meditans: well lets not worry about implementation right now
06:25:07 <augur> at least, your implementation. lets just get down what sort of searchability you want
06:25:31 <augur> meditans: do you want any constraints other than injectivity?
06:25:54 <meditans> augur: ok, so in abstract I want this: given a subset of my t1 .. tn I want to retrieve all the relations which have exactly those values
06:26:07 <meditans> so I might search for specific values in t1 and t4, for example
06:26:28 <meditans> augur: no, injectivy is enough
06:26:29 <lonokhov> michaelt: Idk the whole use-case the question was from other person on other media. machines were proposed and I proposed something simpler like io-streams or something more powerful like pipes.
06:27:00 <meditans> and get all the relations (t1, t2*, t3*, t4)
06:27:11 <augur> lets not use the word relation, this is super confusing
06:27:17 <augur> just call them tuples
06:27:22 <meditans> ok, tuples xD
06:27:47 <meditans> but, mathematically, they are a relation on T1 * T2 * T3 * T4, right?
06:27:52 <augur> no
06:27:56 <meditans> a subset of the cartesian product
06:28:05 <michaelt> lonokhov: I agree, the problem is much like a list problem, I don't see why one would want to use a conduiting-machining-piping, just explicit use of the two streams
06:28:05 <augur> a tuple is not a subset of the cartesian product
06:28:11 <augur> a set of tuples is a subset
06:28:19 <augur> individual tuples are just tuples
06:28:33 <augur> you might say they're members of the relation or whatever
06:28:54 <meditans> I mean, I talked about a list of tuples, you can look at them as a set of tuples
06:29:27 <meditans> ok, let's call them tuples, anyway (but mathematical relations are the intuition behind)
06:29:47 <michaelt> lonokhov: of course  with io-streams, the function would be in IO-land, when it seems the intention is independent of that
06:29:59 <augur> the relations are going to be the lists, meditans, not the elements
06:30:05 <augur> but anyway
06:30:14 <ertes> meditans: nit picking: mathematically a "relation" is a *set* of such tuples
06:30:14 <augur> ok, so then, we have two requirements: maintenance of injectivity constraints on the one hand, and efficient search..
06:30:19 <ertes> meditans: at least in relational algebra
06:30:25 <augur> this sounds like a database sort of problem
06:30:37 <augur> lets focus first on the efficient search, because this is the hard part
06:30:38 <meditans> ertes: yeah, I know, I just didn't like the import at that time :P
06:30:53 <ertes> i'd call it Row or something =)
06:31:06 <meditans> ertes: row it's a good term!
06:31:13 <augur> meditans: you say you have some way of doing the search?
06:31:14 <ertes> meditans: you may also be interested in the Vinyl library
06:31:25 <augur> what is your general overview of how to search efficiently here?
06:31:44 <meditans> augur: yes, I have a way of doing the search, but to explain it I have to talk about implementation
06:31:49 <ertes> meditans: not sure what exactly you're doing, but vinyl has a fully static records implementation that is basically a superset of Row
06:31:52 <Uhebrybdh> http://uhebrybdh.taledar.com/
06:32:01 <augur> meditans: you cant give a rough sketch? :P
06:32:15 <augur> ertes: thats not helpful here
06:32:28 <meditans> augur, yes, but only if you don't run when I mention a map :P
06:32:42 <augur> meditans: provided you define what a map is :)
06:32:58 <meditans> augur: Data.Map
06:33:03 <augur> ok
06:33:06 <augur> thats fine
06:33:25 <augur> lets use a (A,B) as the tuple type
06:33:28 <ertes> augur: i don't know where "here" is, and i'm pretty sure what i said is not related to that place =)
06:33:38 <ertes> i'm giving general advice
06:33:58 <meditans> so, I have a type Index = Int which indexes elements of the relation (or tuples, or rows)
06:34:08 <augur> meditans: how do you efficiently search an A-B table (as we should call it, because its basically a DB table)
06:34:19 <augur> ok
06:35:03 <meditans> ertes: I know vinyl, I'm trying to study the code, but I don't need any advanced feature vinyl provides, and it's not searcheable in my sense. However, I have some questions on vinyl, which will come up in a few days ;)
06:35:48 <ertes> meditans: about efficient indexing: 'tables' has an interesting approach using type families, so you can use different types of index maps depending on the column type
06:35:54 <meditans> augur: ok, so I encode this A-B table as a Map Index (A,B) * Map A (Set Index) * Map B (Set Index)
06:36:33 <ertes> where by "column" i really mean "expression"
06:37:04 <ertes> can be anything, as long as it can be computed from a row
06:37:54 <meditans> ertes: I really should like at tables, it was suggested also in a vinyl issue but I was scared by the code.. will look into it, thanks!
06:38:11 <ertes> meditans: don't look into the code, just the interface
06:38:30 <meditans> augur: does the encoding make sense or should I go into details?
06:38:37 <augur> meditans: i see
06:38:58 <augur> so you're going from elements to row IDs that have those elements, and then intersecting
06:39:10 <meditans> augur: exactly
06:39:36 <augur> meditans: then it should be easy to add the injectivity constraint to this: just add a Map A B when A -> B!
06:39:38 <ertes> meditans: are you going for maximum efficiency?
06:39:46 <meditans> I search each element in its map, and I intersect the results. I can do that in parallel, so I expect the cost not being prohibitive
06:39:48 <augur> meditans: or maybe its Map B A :p
06:40:03 <augur> meditans: either way, just add a new thing that tracks the injectivity info
06:40:04 <meditans> ertes: not necessarily, it's most a proof of concept for now
06:40:12 <augur> meditans: also fwiw i think there's a library for all of this already
06:40:16 <augur> called tables or something like that
06:40:28 <meditans> augur: yes, if we have 2 things, it could have been Map B A but when there are five things
06:40:34 <meditans> I need only 6 maps
06:41:07 <augur> meditans: i think you want 5 maps for components-to-indexes, 1 map for index-to-row, and 1 map for injectivity
06:41:41 <meditans> I don't use a map for injectivity (but please explain what you mean)
06:42:08 <Uhebrybdh> http://uhebrybdh.taledar.com/
06:42:13 <augur> Map A B is an at-most-one mapping from A's to B's
06:42:19 <meditans> for the moment, I just reified the injectivities as (Set Index, Set Index) and checked them when inserting
06:42:36 <ertes> augur: 'tables' is more like 'ixset', except using lensesâ€¦  it doesn't do any type-level stuff as meditans is doing
06:42:54 <ertes> i think the only relevant part of it is its indexing solution
06:43:00 <augur> ertes: the type level stuff meditans is doing is probably not immediately necessary
06:44:45 <augur> meditans: so when you insert a row, you take the relevant components and check that it's not in the injectivity map
06:45:07 <ertes> meditans: if you're not going for maximum efficiency, then tables is not that relevant, unless what you really want is just a solution for principled relation, for which a few libraries already exist that you can look at, the most popular being ixset and tables
06:46:14 <meditans> well, a injectivity in my sense is (dom : Set Index, rng : Set Index), so I retrieve all the tuples which have the same components at rng, and then check if the thing to insert is consistent with the dom of those tuples
06:46:52 <meditans> ertes: this injectivity encoding is important for me, but I'll be sure to look at both ixset and tables
06:47:21 <ertes> you can mostly skip ixsetâ€¦  it takes a rather ugly boolean-blind approach to indexing
06:47:33 <augur> so, meditans, it sounds like you have a schema for definitions for arbitrary tuple types. are you trying to use type magic to make this generic?
06:48:24 <ertes> meditans: i do agree with augur thoughâ€¦  so far you don't seem to be doing anything that isn't already packaged
06:48:24 <meditans> augur: yes, exactly: I define a Relation as
06:48:36 <meditans> data Relation :: (* -> *) -> [*] -> * where
06:48:36 <meditans>   EndR    :: Relation f '[]
06:48:36 <meditans>   (:<->:) :: f a -> Relation f as -> Relation f (a ': as)
06:48:43 <augur> yeah yeah forget that for now :)
06:49:03 <meditans> ertes: and it's packaged in tables, right?
06:49:13 <ertes> meditans: what is it that you want to deboilerplate?
06:49:16 <augur> my suggest, meditans, is to write out a bunch of variables of this type (perhaps using a type class to encapsulate the interface) and work with those
06:49:41 <meditans> augur: of what type?
06:49:44 <augur> dont try to generate the full range of possible implementatins, since you'll probably never use them all
06:49:51 <nitrix> Fancy! Foo :<->: Bar
06:49:54 <ertes> meditans: with so much context i can only tell you that 'tables' is going to be *interesting*, not necessarily a replacement for what you're doing
06:49:59 <nitrix> Not that easy to type, but :P
06:50:21 <meditans> nitrix: the end user will work with tuples, :<->: is only internal xD
06:50:26 <nitrix> What's that? A type operator?
06:50:40 <augur> meditans: grr.  s/variables/instances/
06:50:44 <meditans> nitrix: yes
06:50:46 <augur> my brain is not functioning properly
06:51:12 * hackagebot shine-varying 0.1.0.0 - FRP interface for shine using the varying package  https://hackage.haskell.org/package/shine-varying-0.1.0.0 (fgaz)
06:51:16 <ertes> nitrix: a constructorâ€¦  it's value-level
06:51:16 <augur> meditans: what im suggesting is, dont try to genericize right now. just define something like   Table2, Table3, ... etc
06:51:53 <meditans> augur: ok, I'll write a bunch of those. What will be the following step?
06:52:09 <augur> meditans: the step after that is make peace with using those :)
06:52:31 <meditans> augur: hahaha, no, I'm interested in the general solution, if only to learn how to write it
06:52:46 <augur> you might want to talk to edwardk about this sort of thing, tho
06:52:53 <ertes> meditans: i think you're actually solving two problems at the same time that are better solved separately
06:53:07 <ertes> one is representation of rows, the other is indexing
06:53:16 <augur> you basically want a generic table data type with certain constraints + efficient lookup
06:53:33 <meditans> augur: exactly
06:53:48 <augur> meditans: edwardk has worked on some (or all?) of this in the past
06:53:51 <ertes> minor note:  if Index = Int, don't use Map Index, use IntMap =)
06:53:54 <meditans> ertes: constraints are very important too, unless you lump them with indexing
06:54:11 <ertes> meditans: constraints can come later
06:54:16 <meditans> ertes: I already use IntMap and IntSet, but didn't want to scare augur with details :P
06:54:24 <ertes> there is no reason to constrain it in the representation
06:55:10 <meditans> ertes: that's interesting, so you propose to create smart constructors for the values I'm interested in afterwards, right?
06:55:40 <ertes> not really
06:55:53 <augur> meditans: i doubt that there's really a good Haskell solution to all of this that isn't a complete mess, but who knows
06:55:54 <ertes> first question: do you want to implement the indexing yourself?  because it's pretty much a solved problem
06:56:13 <augur> i mean, a type-level haskell solution
06:56:25 <meditans> ertes: I'd really like to reuse existing libraries, if they do what I need
06:56:26 <augur> i suspect that the real solutions arent very generic for your tasts
06:56:34 <meditans> ertes: the library in question would be tables?
06:56:53 <meditans> ertes: what do you mean exactly by "indexing"?
06:56:57 <augur> ertes: i dont know if tables does exactly what you want
06:57:00 <augur> er, meditans^
06:57:01 <ertes> meditans: or ixset, if you preferâ€¦  a bit awkward, but much better documented
06:57:10 <augur> and i think tables might have been supplanted
06:57:16 <augur> talk to edwardk, since he wrote tables
06:57:18 <ertes> meditans: both of them do indexing, and really only that
06:57:53 <ertes> meditans: by indexing i mean: you have values of type 'a' and a property that can be derived from them, and you want to search by that property
06:58:05 <ertes> like expression indices for database tables
06:58:34 <ertes> note that i didn't say anything about the nature of 'a', because i believe that's your part
06:58:42 <ertes> the "Relation" stuff that is
06:58:59 <augur> meditans: the fun thing about tables is that it uses lenses, i think, to let you use rows that have more friendly representations
06:59:08 <ertes> in order to give more advice we really need to know what problem you are solvingâ€¦  apparently you want to get rid of boilerplate
06:59:12 <ertes> but what kind of boilerplate?
06:59:55 <meditans> ertes: I want to be able to say in a few lines: this is a relation with these injectivity constraints, and the search is reasonably fast
06:59:58 <ertes> tables' main advantage is that it isn't boolean-blindâ€¦  no Typeable hacks
07:00:21 <meditans> ertes: however, ok, let's say I use tables for indexing, how would be constraints be encoded then?
07:00:30 <ertes> meditans: that's already possible, at least with ixset, and i think there is also a template-haskell helper for tables
07:00:48 <augur> meditans: you'd add the kind of injectivity map that i described!
07:01:17 <ertes> one advantage of ixset is that you can do it in a few lines *without* TH
07:01:34 <ertes> it's a tradeoff
07:02:08 <meditans> ertes: ok, so, it seems that ixset and/or tables are indeed what I need
07:02:19 <meditans> I'll take a look and then report back
07:02:21 <ertes> personally i prefer the design of 'tables'
07:02:32 <ertes> even though it's more typing work
07:02:34 <meditans> (and maybe ask augur an example of the injectivity map :P)
07:03:05 <augur> meditans: like i said, it's just a reverse map from the codomain to the range
07:03:36 <meditans> oh, right! Silly me xD
07:03:46 <augur> meditans: so if you have an A-B table, where A injectively maps to B, you have  Map B A
07:03:47 <meditans> that might also be a possibility, in fact
07:04:00 <augur> and when you insert a row (a,b), you lookup b in the table
07:04:09 <meditans> probably a better possibility that the encoding I was proposing
07:04:13 <augur> if you get Nothing, then there is no row yet with (something,b)
07:04:21 <augur> but if you get Just a', there is already a row
07:04:42 <meditans> augur: although, I don't know how to implement generically this injectivity maps
07:05:26 <augur> meditans: so what i would suggest is that you make use of newtype wrappers, firstly
07:05:56 <augur> eg   newtype ABTable = ABTable (Table (A,B))   vs   newtype BATable = BATable (Table (A,B))
07:06:10 <augur> where the newtypes represent the injectivity property
07:06:16 <meditans> ertes: wait, why is tables marked as deprecated?
07:06:40 <ertes> oh, good question
07:07:16 <augur> or actually, meditans
07:07:30 <augur> newtype AB = AB (A,B)   newtype BA = BA (A,B)
07:07:41 <augur> and just have a generic `Table a` type or something
07:07:45 <ertes> meditans: https://github.com/ekmett/tables/issues/15
07:07:51 <augur> then you can have a type class:   class Constrainable row dom cod where break :: row -> (dom,cod)
07:08:27 <augur> meditans: and this lets you project out the domain and codomain of the injectivity for any given row
07:09:05 <augur> checkInjectivity :: Constrainable row dom cod => row -> Map cod dom -> Bool
07:09:59 <ertes> meditans: you can still look at tablesâ€¦  just don't use it =)
07:10:05 <augur> checkInjectivity r m =  lookup (snd (break r)) m == Nothing
07:10:31 <augur> or maybe better yet,   updateInjectivity :: Constrainable row dom cod => row -> Map cod dom -> Maybe (Map cod dom)
07:10:34 <meditans> ertes: it's a shame, the readme looked really nice
07:11:25 <augur> updateInjectivity r m = let (d,c) = break r in  case lookup c m of Nothing -> Just (insert (c,d) m) ; Just _ -> Nothing
07:11:31 <augur> meditans: does this make sense?
07:11:32 <meditans> augur: does this typeclass approach work if I have more than one injectivity to hold?
07:12:08 <augur> meditans: you mean like you want to have (a,b,c,d) where a -> b and c -> d?
07:12:13 <meditans> augur: but yes, the idea behind it makes sense, I like it
07:12:16 <meditans> yeah
07:12:45 <meditans> augur: also, I want things like (a,b) -> (c,d) but those are doable in this version
07:12:45 <augur> then no, i dont think so. you'd need more tables, as those would be two constraints
07:13:34 <meditans> yeah, the thing I cannot see how to do generically (in a simple way, at least), is how to let the user describe the injectivities and translate them in the right number of maps in the representation
07:13:40 <augur> i think youll always need as many constraint "tables" as you have constraints
07:13:58 <augur> probably the best you can do generically is write some TH
07:15:57 <augur> meditans: alternatively, it might be useful to try to abstract away from injectivity to generic constraints
07:16:45 <meditans> generic constraints involve computation, I think they might slow down the search aspect
07:17:09 <meditans> maybe I'm wrong though, they seem to be doing it in tables
07:17:18 <augur> no, it shouldnt
07:18:34 <asdfasdfasdfasdf> hi
07:18:48 * asdfasdfasdfasdf yawns
07:18:54 * asdfasdfasdfasdf leaves
07:18:59 * asdfasdfasdfasdf joins
07:19:07 * asdfasdfasdfasdf leaves
07:19:07 * asdfasdfasdfasdf leaves
07:19:08 * asdfasdfasdfasdf leaves
07:19:08 * asdfasdfasdfasdf leaves
07:19:08 * asdfasdfasdfasdf leaves
07:19:15 <d-snp> lol
07:20:00 <Xnuk> lol
07:20:17 <Akii> hmkay :D
07:30:03 <augur> sorry about that, meditans
07:30:05 <augur> so what i was saying was, if you can do search, you can do generic constraints
07:30:07 <augur> constraints wont make search less efficient since constraints only matter for insertion, not search
07:30:25 <augur> a generic constraint ought to be just precisely a search sketch defined over a new row
07:31:16 <meditans> augur: ooh, I see, that's right. So maybe the wise thing to do is indeed splitting the indexing part using ixset, from the insertion part which gets precomposed on a case basis with the constraint checker
07:31:31 <augur> eg if you want to ensure that A injects into B in a row (A,B) then you need something like   (A,B) -> Search   \(_,b) -> find the rows row.b == b
07:32:00 <augur> and if this ever returns true, or returns a row, or whatever you want to think of it as, then you know that the insertion cant be performed
07:33:54 <meditans> augur: that makes sense, I'll try that
07:34:08 <Asuran> https://www.youtube.com/watch?v=iSmkqocn0oQ
07:34:32 <jophish> lonokhov: if I don't add a module to other-modules I get a linker error
07:35:39 <darkmercenary> so i have ab unch of datatypes being made by persitent and i want to be able to turn them into csv's easily. the Data.Csv package says that I need to do "deriving Generic" on them, but i cant since theyre being made the quasiquoting stuff done by persistent.
07:35:59 <darkmercenary> why cant i do like ..  instance Generic ModelA
07:36:42 <Zemyla> darkmercenary: Can you use StandaloneDeriving?
07:36:42 <darkmercenary> from csv documentation
07:36:42 <darkmercenary> {-# LANGUAGE DeriveGeneric #-}  data Person = Person { name :: !Text , salary :: !Int }     deriving Generic  instance FromRecord Person instance ToRecord Person
07:37:16 <darkmercenary> let me try that
07:37:17 <bergmark> yes StandaloneDeriving is the solution
07:37:30 <augur> meditans: that would also let you make a more general kind of type, because now all you need to do is say that the constraints for a Table of Row's consists of a list   constraints :: [Row -> Search]
07:37:58 <augur> meditans: or perhaps just   Row -> Search   since you can probably logically conjoin searches
07:41:14 <augur> btw meditans, i suspect its the case that "partial" injectivity constraints like   (a,b,c) such-that a is injective into b   are not really possible
07:41:30 <augur> its not clear to me what it would mean
07:42:32 <augur> for all x : a,   ???something-with-y:c???, exists a unique z : b s.t.   (x,y,z) is in the relation
07:42:33 <meditans> augur: you're right on the presentation of constraints. The partial injectivity would mean, in your example, that it's fine to have
07:42:52 <meditans> (a,b,c1) and (a,b,c2), but not (a1,b,c) and (a2,b,c
07:43:09 <augur> my quantifiers are all wonky there. lol
07:43:23 <augur> and also probably wrong :)
07:43:37 <augur> hmm right lets see
07:44:05 <augur> for all (x,y,z) and (x',y',z') in the relation, if y == y' then x == x'
07:44:20 <meditans> exactly
07:44:47 <augur> so then as a search, we want to find all the rows where row.b == new_b but row.a /= new_a
07:45:09 <augur> \(a,b,c) -> has row.b == b and row.a /= a
07:46:14 * hackagebot keycode 0.2 - Maps web browser keycodes to their corresponding keyboard keys  https://hackage.haskell.org/package/keycode-0.2 (ryanglscott)
07:46:24 <augur> generic search is going to be interesting, fwiw. gotta figure out just what sort of searching you can do
07:47:43 <darkmercenary> Zemyla: thanks it worked
07:58:57 <hc> Hi, suppose I have got a conduit sink of type (Sink ByteString m a); is there a standard conduit sink that can be used to fetch the first 'n' bytes and discard the rest?
07:59:12 <hc> (The pure equivalent would be ByteString.drop)
07:59:37 <kadoban> :t liftA2 mappend :: (Monoid a) => ZipList a -> ZipList a -> ZipList a
07:59:38 <lambdabot> Monoid a => ZipList a -> ZipList a -> ZipList a
07:59:42 <kadoban> Sorry, wrong channel
08:03:28 <lonokhov> is there something like `foldMapA :: (Foldable t, Applicative f, Monoid w) => t a -> (a -> f w) -> f w` ?
08:04:51 <lonokhov> like more efficient `foldMap <$> traverse f something`
08:05:12 <lonokhov> hm, s/foldMap/fold/
08:05:59 <ertes> does anyone know a strict WriterT?  a properly strict one
08:07:41 <ertes> in the following sense:  WriterT c >>= f = WriterT $ do (x, l0) <- c; (y, l1) <- runWriterT (f x); let l = l0 <> l1 in l `seq` pure (y, l)
08:07:54 <lonokhov> ertes: just use StateT 
08:09:49 <lonokhov> ertes: http://stackoverflow.com/questions/25749126/a-stricter-control-monad-trans-writer-strict explanation
08:09:57 <theduke> I need something like the Value type from the aeson package, but not (explicitly) for JSON conversions, and i'd rather not be forced to pull in aeson just for this purpose. Is there a light-weight package out there providing something like this? 
08:10:35 <theduke> Would not be hard to hand-code it of course, but a package would be nicer.
08:10:36 <lonokhov> theduke: why not roll your own? Or just copy-paste from aeson
08:11:07 <ertes> i guessâ€¦  but really WriterT should be fixed, even if that means using StateT under the hood
08:11:31 <ertes> the current one is useless, because there is no way to keep it from building up unevaluated mappends
08:12:09 <theduke> lonokhov: yeah, if there's no popular package out there, i'll just roll my own. 
08:24:50 <Profpatsch> How to multiline-string with linebreaks?
08:25:13 <Profpatsch> as in I want to input a trivial csv for a test.
08:26:19 <Profpatsch> a = "abc,\"def ghi\"\
08:26:38 <Profpatsch>   \second"
08:26:44 <Profpatsch> Doesnâ€™t insert a linebreak.
08:26:55 <bergmark> \n is a line break
08:26:56 <kadoban> Profpatsch: \n
08:28:00 <Profpatsch> So I have to do "foo\n\
08:28:02 <Profpatsch> \bar"
08:28:08 <Profpatsch> mkay3
08:30:06 <kadoban> Profpatsch: You can also do:  unlines $ ["one", "two", "stuff"]
08:39:13 <jophish> Why am I able to derive Functor for: data Both a = Both ((,) a a); but not for: data Both a = (Either a a)
08:39:31 <jophish> I'm pretty sure the answer is that there's some special magic for tuples going on here
08:39:51 <jophish> but It's annoying that the same magic doesn't go for any instance of Bifunctor
08:40:18 <jophish> (The same goes for Foldable and Traversable re Bifoldable and Bitraversable)
08:40:57 <jophish> Is there a way of deriving these instances generically myself?
08:42:50 <srhb> jophish: Did you mean data Both a = Both (Either a a) ?
08:42:59 <jophish> ah yes, thanks srhb 
08:45:48 <jophish> perhaps this can help https://hackage.haskell.org/package/genifunctors
08:46:17 * hackagebot pg-store 0.0.1 - Dead simple storage interface to PostgreSQL  https://hackage.haskell.org/package/pg-store-0.0.1 (vapourismo)
08:47:01 <dolio> I think for most types it just delegates to certain instances. Either isn't built in in the same way as tuples and functions.
08:49:05 <srhb> I don't understand why the tuple version works.
08:49:07 <srhb> :P
08:49:15 <obadz> > show (Right 7)
08:49:17 <lambdabot>  "Right 7"
08:49:43 <obadz> Is the type of the left variable defaulted to something that gets a Show instance?
08:50:04 <obadz> Otherwise the whole Either isn't showable
08:50:18 <c_wraith> the only thing that makes sense for allowing the tuple version to work is that it somehow looks through the tuple. 
08:50:19 <srhb> I could understand data Both a b = Both ((,) a b) or data Both a b = Both (Either a b)
08:50:34 <kadoban> obadz: Sounds right
08:50:36 <dolio> Tuples are probably special cased.
08:50:52 <c_wraith> obadz, yes, it's being defaulted. 
08:51:19 <obadz> kadoban / c_wraith: what is it defaulted to and where can I get a list of what the repl will default that doesn't get defaulted when compiling?
08:51:28 <jophish> obadz: ()
08:51:35 <kadoban> obadz: the repl will do ... yeah ()
08:51:44 <c_wraith> obadz, look up ghci extended defaulting
08:51:54 <kadoban> There's some way to trick it to tell you, but hell if I know how. I don't think GHC will actually default that one?
08:52:02 <kadoban> I mean in code.
08:53:06 <srhb> > show (_ `asTypeOf` Right 2)
08:53:07 <lambdabot>      Found hole â€˜_â€™ with type: Either () Integer
08:53:07 <lambdabot>      In the first argument of â€˜asTypeOfâ€™, namely â€˜_â€™
08:53:07 <lambdabot>      In the first argument of â€˜showâ€™, namely â€˜(_ `asTypeOf` Right 2)â€™
08:53:47 <obadz> c_wraith: thanks
08:56:05 <obadz> also, if y :: Show a => Either a Int
08:56:25 <obadz> y = Right 7, why is it still complaining about missing Show instance?
08:56:52 <obadz> Isn't the proof of existence about missing Show instance embedded in the type signature that I gave it?
08:57:25 <kadoban> obadz: What's the error exactly? When you use it I assume?
08:57:51 <kadoban> obadz: It still needs to pick an 'a' when you use it, which is probably why it's complaining, because there's no default and it doesn't know.
08:58:07 <obadz> kadoban: yes on print y it says No instance for Show â€¦
08:58:21 <obadz> yes fair enough
08:58:26 <obadz> I will try {-# LANGUAGE ExtendedDefaultRules #-}
08:58:59 <kadoban> obadz: I'd probably be careful with that. The defaults to () kind of get a little ridiculous sometimes
09:00:01 <obadz> ok, I probably won't use it then
09:01:42 <srhb> obadz: In fact, disabling it in ghci too can be quite enlightening :-)
09:01:54 <srhb> If occasionally impractical.
09:02:17 <Profpatsch> kadoban: You are right, thatâ€™s probably the nicer way to do it. On the other hand, ByteString is not happy with unlines, so probaly mconcat.intersperse
09:02:33 <obadz> srhb: yeah I was just thinking I might do that
09:03:53 <ski> augur,meditans : `forall y. unique x. exists z. R x y z' (which expresses the FD `y |-> x' on `R x y z') ?
09:03:55 <Profpatsch> Oh, thereâ€™s intercalate. Even better
09:04:06 <ski> ertes : "but really WriterT should be fixed, even if that means using StateT under the hood" -- hm, but then i think you can't run something after an infinite action
09:05:59 <ski> obadz : yes, it doesn't know if you want to print `y' at type `Either String Int' or `Either (IO String) Int' or ...
09:07:24 <obadz> I guess parametricity can only apply in product types, not sum types
09:07:26 <ski> "as far as it knows", the result of `show y' might depend on the `Show a' instance used for `y'
09:08:25 <ski> parametricity is "mainly about" universal types, types of the shape `forall a. ..a..'
09:09:18 <ski> however, if you meant a type involving a sum type ..
09:09:19 <ski> @free foo :: Either a b -> Either b a
09:09:19 <lambdabot> $map_Either g f . foo = foo . $map_Either f g
09:09:22 <ski> works fine
09:11:55 <ski> @free foo :: Either a (a -> Void)
09:11:56 <lambdabot> (forall h. g (h . f) = h) => $map_Either f g foo = foo
09:12:03 <Kogasa> can I make a function still return a value if it's missing an argument?
09:12:05 <obadz> fair enough, I guess I'm still a bit confused about this stuff
09:12:31 <dolio> @free foo :: T a (a -> Void)
09:12:32 <lambdabot> Plugin `free' failed with: src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:(202,1)-(291,24): Non-exhaustive patterns in function freeTheorem'
09:12:32 <GLM> Kogasa: Can you give an example?
09:12:35 <ski> Kogasa : you can use `A -> (B,C -> D)'
09:12:45 <dolio> Nice.
09:12:56 <ski> Kogasa : or you can "return a result early", using "tying-the-knot" techniques
09:13:05 <GLM> Is that a pair of B and C?
09:13:12 <Kogasa> hm
09:13:16 <ski> @wiki Tying the Knot
09:13:16 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
09:13:35 <ertes> ski: strict WriterT can't do that anyway
09:13:51 <ski> GLM : it's the type of functions which takes an `A', and then returns a pair of a `B', and a new function that when given a `C' returns a `D'
09:14:03 <ski> (obviously this new function will in general also depend on the `A' input)
09:14:06 <ertes> ski: lazy WriterT still has its place, but i can't think of a use case of the current strict WriterT
09:14:15 <c_wraith> strict WriterT is useless. it isn't strict the way you want, ever. 
09:14:28 <ski> so `A -> (B,C -> D)' is a variant of `A -> C -> (B,D)', where you "return `B' early, before getting the `C' input"
09:14:42 <GLM> ski: Oh, I'm used to have the extra set of parens for that inner function
09:14:50 <ski> ertes : hm, fair enough
09:15:48 <ski> GLM : i'm usually a fan of avoiding redundant brackets, except when i want to emphasize some grouping (or not have to rely on some relative precedence or associativity of operators)
09:16:28 <ski> e.g. in `map :: (a -> b) -> ([a] -> [b])', here we emphasize that this converts a function operating on elements into a function operating on lists of elements
09:16:40 <catau> hi, I'm trying out a UDP example I found online and I'm getting some unexpected behavior on OSX: http://blog.coldflake.com/posts/Simple-Networking/ unless I have a UDP listener on the other end for the send, I get "Exception: recv: does not exist (Connection refused)" but I thought UDP should not expect any connection handshakes
09:17:42 <GLM> ski: I agree and normally, I'd do the same but I feel like the , requires the extra notation
09:18:02 <catau> I did find a possibly-related suggestion to use a hint for a TCP example of this exception: https://github.com/the-real-blackh/cassandra-cql/issues/1#issuecomment-21494026
09:19:51 <Cale> catau: So you're saying that when you run the client, rather than just blocking, it terminates with an exception?
09:20:04 <catau> Cale: yes
09:20:11 <Cale> Interesting
09:20:31 <Cale> fwiw, it doesn't do that for me on Linux
09:20:53 <Cale> (It just blocks and sits there waiting)
09:21:09 <catau> i'll try it on linux if I exhaust other options
09:22:03 <catau> changing it to getAddrInfo (Just $ defaultHints {addrSocketType = Datagram}) (Just "127.0.0.1") (Just port) didn't help
09:29:56 <ski> GLM : why ?
09:30:36 <ski> ok
09:31:31 <Cale> I would at least put a space after the ',' in that case :)
09:31:58 <Cale> well, maybe I wouldn't sometimes...
09:31:59 <Cale> hah
09:32:24 <ski> <ski> GLM : why ?
09:32:25 <ski> in that case, i'd also put a space before the comma .. unless i'm aligning commas from different lines, and that's the reason i inserted the space(s)
09:33:07 * ski isn't a fan of assymetric spacing around punctuation
09:33:26 <GLM> ski: I think the main reason is that I've seen something more like pseudo code/python where a,b->c means there is a function that takes two arguments
09:33:48 <ski> well, that's a different syntactical context, then, with different precedence rules
09:35:13 <hpc> i prefer spaces because the extra whitespace helps with scanning lots of code
09:35:18 <GLM> You're right. It just confused me at first because of that prior knowledge
09:35:24 <GLM> That too
09:35:59 <ski> usually i'd put spaces around arithmetical operators, e.g.. `a + b * c' is usually nicer than `a+b*c', i think
09:39:34 <nmdanny> hey, is it possible to install GHCJS on windows purely with stack?
09:39:56 <kadoban> nmdanny: Have you tried the usual magic stack.yaml stuff?
09:40:16 <nmdanny> yes, it works up until the point of doing ghcjs-boot
09:40:48 <nmdanny> said something about time, directory and process packages depending on Win32-2.3.1.0 which failed to install
09:43:34 <kadoban> Hmm, not so sure about that :-/ I believe there's a person or two using ghcjs and stack and windows, but I sure can't even remember names.
09:43:39 <Welkin> it would simply be easier to develop on a linux machine
09:43:52 <Welkin> just run it in a virtual machine if you need to
09:43:54 <Welkin> or dual boot
09:44:43 <nmdanny> it would..but I have a lot of games and programs that run on windows..
09:45:22 <Welkin> I run multiple machines and dual boot windows/linux on one of them
09:45:29 <catau_> Cale: I got the same exception on linux. would you be able to tell me what version of network you are using perchance?
09:45:42 <Welkin> unfortunately, windows is totally useless even for the games it is supposed to run
09:45:55 <Welkin> dunno if it's the graphics drivers or what
09:45:55 <Cale> catau_: 2.6.2.0
09:46:19 * hackagebot persistent-database-url 1.1.0 - Parse DATABASE_URL into configuration types for Persistent  https://hackage.haskell.org/package/persistent-database-url-1.1.0 (jferris)
09:47:18 <nmdanny> if I were to use a VM for programming on linux, is there an option of sharing the filesystem between the VM and the windows its running on?
09:47:42 <Welkin> yes, you can share copy/move files between them
09:47:45 <catau_> Cale: thanks. I'm using 2.6.2.1 so I'll have to punt on getting udp to work for now
09:47:56 <Welkin> if you want to run a virtual machine for programming, I recoomend using vagrant
09:48:07 <Welkin> you'll have a complete linux machine up and running in minutes
09:48:52 <Welkin> nmdanny: https://www.vagrantup.com/
09:49:04 <nmdanny> is that like virtualbox?
09:49:05 <Welkin> best new tool I have used
09:49:11 <Welkin> it uses virualbox undereath
09:49:17 <Welkin> but takes care of everything for you
09:49:28 <nmdanny> i've also heard of docker, is that related or are those entirely different things?
09:49:29 <Welkin> and removes the GUI so you can just ssh into it like it is a remote server
09:49:32 <Welkin> it is perfect
09:49:56 <Welkin> docker is for deployment (only?), not sure about it since I never used it
09:50:19 <Jinxit> Welkin: you can run headless on virtualbox as well, that's what I did last time
09:50:26 <nmdanny> what if I do want a GUI? I need a GUI file explorer if i'm gonna do programming
09:50:45 <Welkin> seriously?
09:50:51 <nmdanny> yea
09:50:53 <Welkin> do you know how to use a command line?
09:51:13 <Jinxit> nmdanny: you'd usually run your editor in your host OS, share files to the VM, and compile in there
09:51:32 <Welkin> yes
09:51:35 <Welkin> what Jinxit said
09:51:47 <nmdanny> oh, that could work
09:51:55 <Jinxit> which you can just do on command line, and you do all the "normal" work in your host OS
09:53:16 <nmdanny> so my workflow could be: install stack on vagrant, use it to build dependencies and compile stuff, do the rest from windows
09:53:52 <Welkin> yes
09:56:19 * hackagebot union 0.1.1.0 - Extensible type-safe unions  https://hackage.haskell.org/package/union-0.1.1.0 (int_index)
09:59:33 <aod> gui file explorer?
09:59:46 <aod> what for, exactly?
10:08:17 <Zemyla> So if there were an applicative with conditional execution, would its prototype be (<%) :: f (Either a b) -> f (a -> c) -> f (Either c b)?
10:10:33 <Zemyla> Or something along those lines?
10:12:48 <Hijiri> I don't know, you could write something with that signature using only Applicative
10:14:10 <Zemyla> Hijiri: You might, but it would execute the second one no matter what.
10:18:00 <shachaf> @remember statusfailed <statusfailed> What's that lens combinator that lets you write (\x -> f a x b) as (f x ?? b) <statusfailed> wait. is it (??) ?
10:18:00 <lambdabot> Okay.
10:29:23 <hur> is there a version of map which returns a list of tuples where fst is before function application and snd is after?
10:29:51 <johnw> you mean, some function f : (a, b) -> (c, d)?
10:30:05 <johnw> oh, I see
10:30:14 <johnw> map (\x -> (x, f x)) xs
10:30:42 <MichaelK> Hi, I'm wondering if it's possible to make a safe (non-io) function `isUndefined x :: a -> Bool`. I found an unsafe way to do it: `isUndefined = (.) =<< eqStableName . ($ undefined) $ unsafePerformIO . makeStableName`. 
10:30:50 <hur> johnw: thanks, that was quick
10:32:16 <hpc> hur: if you're feeling arrowy, (id &&& f)
10:32:33 <hpc> :t \f xs -> map (id &&& f) xs
10:32:34 <lambdabot> (a -> c') -> [a] -> [(a, c')]
10:32:59 <hpc> but that doesn't really have any particular benefit over johnw's answer
10:33:25 <hur> hpc: interesting
10:33:48 <hpc> MichaelK: i assume that only catches the actual value undefined, and not (error "omg lol") or fix id
10:33:58 <hpc> (it definitely can't catch fix id, in any event)
10:34:16 <hpc> er, "actual identifier undefined"
10:34:48 <MichaelK> hpc: exactly, I only care about matching the `undefined` defined in Prelude
10:35:06 <MichaelK> not looking to solve the halting problem, heh
10:36:01 <MichaelK> though `errorToMessage :: a -> Maybe String` would be cool (return the string of an error if `error string`, else nothing)
10:36:11 <hpc> have you tested it? that seems like a plausible solution to me, but i can see it having problems with optimizations and whatnot perhaps
10:36:38 <hpc> i am not familiar with StableName but it looks extremely weird
10:36:38 <MichaelK> I've only tested in ghci. I couldn't find much documentation on stable names
10:37:13 <hpc> try it in some trivial and non-trivial compiled examples with -O0, -O1, and -O2
10:37:27 <hpc> if it works in all three, that's pretty cool
10:37:49 <hpc> if nothing else, that definition is perfect in an acme package
10:38:08 <MichaelK> yeah. is that a decent heuristic for safety?
10:38:08 <Zemyla> I wish StableName had an Ord instance.
10:38:16 <Zekka|Sigfig> fwiw out of the above code, I think johnwâ€™s first answer is the easiest to read
10:38:46 <MichaelK> Zemyla: how would it be ordered? 
10:39:38 <hpc> MichaelK: should be, yeah
10:40:07 <hpc> MichaelK: this probably will come out sounding mean, but unit testing is pretty much purpose-built for verifying if something works without knowing anything about its semantics
10:40:28 <hpc> and you've covered the major cases that would break it i can think of
10:41:08 <MichaelK> good point
10:42:58 <MichaelK> hpc: does quickcheck generate test input of arbitrary type?
10:43:43 <Cale> MichaelK: specifically, it generates test inputs of any type which is an instance of Arbitrary :)
10:44:13 <hpc> heh, quickcheck won't help you here
10:44:27 <MichaelK> hpc: aww
10:44:29 <hpc> the domain of this function might include implementation details, which takes it out of language
10:47:04 <Zemyla> MichaelK: In an implementation-dependent but unique way.
10:47:37 <Zemyla> *implementation-dependent but consistent
10:55:31 <Hijiri> Zemyla: I think you can write it with Alternative in a way that doesn't run the second if the first is Right
10:55:58 <Hijiri> actually, I don't know
10:56:01 <Hijiri> maybe not
10:56:31 <Hijiri> Yeah, I don't think you can
11:04:43 <montanonic> Say I have a tool that I can use in the Command Line, but that isn't written in Haskell. How could I make a Haskell program that can run arbitrary commands through the CLI, and parse the results back into Haskell? Are there any libraries that handle this?
11:05:39 <cocreature> montanonic: the functions in https://hackage.haskell.org/package/process-1.4.2.0/docs/System-Process.html are probably what you are looking for
11:05:43 <montanonic> I'd like to utilize http://wkhtmltopdf.org/ for example, which has a CLI. So in Haskell, I'd like to be able to run the "wkhtmltopdf" process, and then do something with the results of that.
11:06:10 <montanonic> cocreature: yeah, that does look like what I need. I'll dig into it. Thank you.
11:08:34 <lpaste> MichaelK pasted â€œisUndefined Testsâ€ at http://lpaste.net/161245
11:10:06 <MichaelK> hpc: I tested it and it seems to work. only problem I ran into was making sure that isUndefined "got to" undefined first
11:11:34 <MichaelK> This could be used to print partial application values (unless I've missed some obvious test or my tests were too trivial..)
11:20:28 <ntnt> does haskell make sense for test driven development? it seems tdd -> we can generalize it to quickcheck -> but in haskell, at the high level, we can often turn "the test if this answer is correct" into "an algorithm for computing the answer"
11:21:19 <hpc> so, problems have a domain of inputs that they need to be solved for
11:21:40 <hpc> TDD puts unit testing first, which drops down points in the domain and says "these work"
11:22:15 <hpc> if you pick the right points, you can usually get reasonable confidence for the whole domain
11:22:24 <ntnt> but if yo ugeneralize TDD, you get quickcheck, which says (1) here's a wya to genrerate random points nad (2) here's a verifier to check if the answer is right
11:22:39 <ntnt> but it seems to assume that writing verifier = easier than writing algorithm
11:22:48 <hpc> yeah
11:23:12 <hpc> usually it is (see also, NP-hard)
11:23:26 <hpc> more idiomatic in haskell is to use the type system to make the domain as small as you can
11:23:58 <ntnt> well no, in NP-hard case the algorithm isn't ahrd to write; it's just slow to run
11:24:04 <lyxia> quickcheck verifiers don't have to fully characterize your functions though
11:24:06 <hpc> in ruby / php / python / whatever, you might write a series of tests that all check "this input will always be a string"
11:24:12 <ntnt> NP-hard is about running time of s olver vs running time of verifier, not length of solver vs length of verifier
11:24:19 <hpc> in haskell, you just never allow non-strings into the domain
11:24:47 <hpc> ntnt: programming is surely an algorithm though
11:25:19 <hpc> and "the programming was correct" might conceivably be the verifier for "i did the programming"
11:29:09 <hpc> anyway, quickcheck's unique contribution to testing is how it decides what test cases to use
11:29:23 <hpc> which i can't really describe much better than "it looks for stuff that is more likely to break"
11:29:44 <ntnt> hpc: I can't imagine how to write quick check for things like parsec, or dijkstras, or almost any non-trivial algorithm
11:29:53 <ntnt> it seems the only way to 'check correctness' is 'run best algorithm, cehck output is the same'
11:29:55 <hpc> i would need to dig deeper into it myself to understand the mechanics of it
11:30:22 <ntnt> hpc: do you use tdd in practice?
11:30:24 <ntnt> (I don't [yet])
11:30:33 <hpc> i don't either
11:31:02 <GLM> How do most people deal with the issue where you want to have a pure function but need some (possibly multiple) counters mutated there?
11:31:09 <ntnt> the only tests I care about are: does ghc compile this?
11:31:17 <ntnt> GLM: state monad
11:31:29 <hpc> i dislike that it makes testing perfunctory, and that it ultimately discourages being able to understand the code just by reading it
11:31:48 <GLM> ntnt: Let me rephrase. This happens to be in a Java codebase but I'm going for as functional a paradigm as possible
11:32:16 <ntnt> hpc: I like TDD for the notion that "writing tests" helps me "focus on what I want the code to actually do"  -- but everything else, I'm not sure I like yet
11:32:34 <Zekka|Sigfig> GLM: State is expressible in Java, but itâ€™s pretty hard to do â€” Iâ€™d just manually thread an extra parameter that represents the counters
11:32:38 <ntnt> GLM I think there's frege , which you might like
11:32:55 <simpson> GLM: Just write Java in Java-land.
11:32:59 <Zekka|Sigfig> you can then either return a pair, or cheat on your model and let the extra parameter use mutation internally
11:33:39 <GLM> I really don't want to cheat on my model but Java sucks on creating simple data types like tuples easily
11:33:53 <simpson> GLM: Don't fight the language that you're working in.
11:34:53 <Zekka|Sigfig> Haskell: a -> State s b = a -> s -> (b, s)  :: instead of writing B f(A a) you may write Pair<B, S> f(A a, S s) and that works OK in javaâ€™s type system
11:35:13 <Zekka|Sigfig> but I would prefer B f(A a, S s) and let S use mutation internally, and I think thatâ€™s much more idiomatic
11:35:19 <tippenein> Is there something for merging streams in Pipes? For example if I'm reading from a dozen different files and I want to process them in parallel
11:35:57 <tippenein> or maybe I'm not trying to merge, but just read from multiple files
11:35:58 <Zekka|Sigfig> you can implement S as a reference to an immutable object if you want
11:36:19 <jle`> tippenein: does the Applicative interface help you?
11:36:36 <jle`> liftA2 can be used to merge two producers
11:37:07 <jle`> oh wait, that merges results, not produced values
11:37:23 <Zekka|Sigfig> If you implement S as a ref to immutable object, you have something thatâ€™s pretty translatable to ST in Haskell â€” if what you care about is just having a design thatâ€™s expressible in Haskell
11:37:59 <tippenein> jle`: this seems like an Applicative task... maybe
11:38:08 <Zekka|Sigfig> to give you an idea, class Ref<T> { public T value; public Ref(T t) { value = T; } }
11:38:20 <Oejet> ntnt: If you go by https://en.wikipedia.org/wiki/Test_driven_development I don't see anything which couldn't apply to Haskell as well.
11:39:05 <Zekka|Sigfig> that gets you B f(A a, Ref<S> rs);
11:39:55 <Zekka|Sigfig> That has the advantage you can take savestates of type S whenever you want, but you donâ€™t have to structure your function around threading the state of S
11:40:05 <Zekka|Sigfig> GLM: I hope that helps!
11:40:26 <GLM> Zekka: It helps a lot. Thanks
11:44:13 <tippenein> is it normal for pipes to pull in 10-20 extra-deps with stack? or is it just because I requre pipes-files and pipes-text ?
11:47:42 <geekosaur> the latter, I'd imagine
12:00:25 <cocreature> pipes doesnâ€™t pull in any extra-deps at least if you use the same version thatâ€™s in your snapshot
12:01:36 <MichaelK> hpc: did you get a chance to look at the tests? I added another and it still works, so it looks safe, but I'd prefer to be certain that eqStableName/makeStableName are safe/accurate for global constants. 
12:11:45 <RaitoBezarius> how do we call a function to which we applied currying?
12:11:49 <RaitoBezarius> a curried function?
12:12:20 <shachaf> If you wanted to.
12:12:26 <shachaf> But it's just a function.
12:13:24 <RaitoBezarius> I wondered about the grammar if it was correct :), thanks shachaf !
12:17:00 <MichaelK> I'm interested in writing a (small) GHC extension. Should I post a feature request on GHC trac with my offer to write it or what?
12:21:41 <Cale> MichaelK: That sounds like a question for #ghc -- I'm curious, what's the extension?
12:23:06 <MichaelK> support for equality/pattern matching of `undefined` (the one in Prelude)
12:24:42 <shachaf> !
12:25:08 <MichaelK> shachaf: ?
12:25:26 <Cale> MichaelK: what?
12:25:45 <Cale> MichaelK: That's doable without an extension, it's just a terrible idea.
12:26:01 <MichaelK> the value undefined is a thunk, which can be named, and thus compared. why is it a terrible idea?
12:27:08 <Cale> Basically for the same reason that null references in Java are a bad idea.
12:27:21 <MichaelK> I don't know any Java..
12:27:40 <Cale> undefined is supposed to semantically be the same as an infinite loop
12:27:56 <Cale> It just crashes the program when evaluated instead of taking forever doing nothing.
12:29:28 <Cale> You're expected to use Maybe in cases where you might produce a failing result that needs to be handled
12:29:46 <Cale> Using undefined for that instead weakens the meaning of types
12:30:45 <Cale> The reason that undefined exists is primarily for stubbing out code that you haven't written yet.
12:31:48 <Cale> You wouldn't want someone to provide an API where functions produce an Integer result, but perhaps that's undefined and you're expected to just match on that.
12:31:51 <greg> or so that haskell can pretend to be consistent with category theory?
12:32:26 <Cale> When something produces an Integer result, you expect that it is an honest Integer.
12:32:57 <MichaelK> Cale: well I'd never want to return undefined, just pass it. to allow things like `sum3 x y z = x + y + z` that can return debugging (or other info) without all arguments applied
12:33:07 <dreams> Does any one have a funny quote about the memory demands of Haskell programs?
12:33:09 <Cale> If it produces undefined, that's an indication of a bug (either a bug in the function, or a bug in your code based on how you're applying it)
12:33:35 <Cale> MichaelK: hm?
12:33:40 <MichaelK> Cale: i.e. pass undefined until a value is reached, and return that to get partial application info
12:33:55 <Cale> I don't understand what you're doing.
12:34:09 <Cale> "pass undefined until a value is reached"? What does that mean?
12:34:23 <Cale> A value is reached before you even pass undefined.
12:34:35 <cocreature> MichaelK: why canâ€™t you use a Maybe for that?
12:34:52 <MichaelK> The final value, so recovering the partial arguments or the like
12:35:09 <Cale> sum3 is a value, sum3 undefined is also a value, sum3 undefined undefined is a value, sum3 undefined undefined undefined is a value, sum3 undefined undefined undefined undefined is a value as well...
12:35:17 <Cale> and so on ad infinitum
12:35:33 <MichaelK> Cale: get a numeric value then, I should have specified
12:35:35 <Cale> You may or may not hit a type error at some point, due to lack of instances of Num
12:35:59 <Cale> But function types may be an instance of Num
12:36:08 <Cale> in which case, sum3 takes arbitarily many arguments
12:36:16 <Cale> arbitrarily*
12:36:21 <MichaelK> Cale: Int, then
12:36:35 <Cale> MichaelK: What's the real goal?
12:37:25 <MichaelK> Cale: I want to be able to write functions that support recompilation. So apply n arguments, then be able to recover them and compile a new function with those "baked in"
12:37:42 <Cale> That already happens
12:39:06 <Cale> But you can also write it explicitly
12:39:16 <MichaelK> So when I declare `f = (+ 1)` *during runtime*, f is recompiled? I'm pretty sure it just "stashes" the 1 for later and makes a reference
12:39:37 <Cale> I don't understand how you're getting new declarations at runtime
12:39:54 <lyxia> are you trying to put JIT in haskell
12:40:06 <Cale> sum3 x y = let k = x + y in \z -> k + z
12:40:22 <Cale> If you write f = sum3 5 6
12:40:28 <MichaelK> lyxia: for specific functions.
12:40:31 <Cale> then k will be computed once
12:40:34 <Cale> and reused
12:41:44 <Cale> moreover, f might be inlined
12:41:57 <Cale> er, sum3 might be inlined
12:41:58 <MichaelK> I'd love to continue, but I have to go. Thank you
12:46:00 <bitonic> I have a project where ghci is super, super slow -- typing in it has a noticeable delay, as if I was typing in SSH on a slow link
12:55:22 <bitonic> Passing -A64m to ghci seems to make things a bit better
13:01:26 <RandomDude> is human mind computational, can we simulate it with a computer
13:01:56 <pikajude> how should I ask for a password input on the command line?
13:02:00 <Cale> that... doesn't seem like a question about Haskell, but the answer is "probably it will be someday"
13:02:03 <pikajude> is there a library that will mask user input (like highline for ruby)?
13:02:28 <RandomDude> Cale: is haskell quantom computer ready?
13:02:45 <Cale> pikajude: you can use System.IO.hSetEcho
13:02:56 <pikajude> thanks Cale 
13:03:04 <Cale> RandomDude: No, it doesn't have any quantum primitives whatsoever
13:03:13 <pikajude> Cale: what if I wanted to replace the characters with *?
13:03:56 <Cale> pikajude: you can putStr '*' whenever you get a character
13:04:04 <pikajude> that's a good idea
13:04:14 <geekosaur> turn off output buffering if you do that
13:04:38 <geekosaur> otherwise they'll sit in the buffer until a newline is output
13:05:17 <Cale> I mean "*" of course
13:05:37 <monochrom> yeah, sounds like you should turn off both input buffering and output buffering
13:05:40 <geekosaur> or putChar
13:07:57 <pikajude> hmm
13:08:05 <simpson> RandomDude: How do you feel about the Chinese Room?
13:08:14 <RandomDude> makes me sad
13:08:46 <pikajude> maybe I should use haskeline
13:08:52 <pikajude> because it doesn't interpret backspace correctly
13:08:56 <pikajude> and I don't want to reinvent too much of the wheel
13:09:03 <monochrom> true :)
13:09:46 --- mode: ChanServ set +o monochrom
13:09:53 --- mode: monochrom set +b *!*@92.36.220.171
13:09:53 --- kick: RandomDude was kicked by monochrom (RandomDude)
13:10:28 --- mode: monochrom set -b *!*@78.191.149.170
13:10:39 --- mode: monochrom set -o monochrom
13:15:10 <orion> How are Pipe return types meant to be used?
13:20:03 <greg> ghc is saying the following is malformed : instance TooMany (Ord a) => (a , a) where ...
13:20:56 <jle`> i wonder why 'du' in Numeric.AD is defined to take an f (a, a) instead of an (f a, f a)
13:21:21 <lyxia> greg: you need flexibleinstances or something to allow the same variable to appear twice in (a, a)
13:21:30 <jle`> hm i guess it's to ensure that there are the same number of elements in both
13:21:32 <greg> thanks
13:21:51 <kadoban> Isn't it: instance (Ord a) => TooMany (a, a) where  ?
13:22:12 <lyxia> that too
13:23:25 <lyxia> Is it decidable whether a GADT is empty (i.e. no finite term of that type)?
13:34:39 <greg> kadoban: just figured it out and was about to post to the channel  :-\ #wastedtime lol, thanks
13:41:05 <kadoban> greg: Hehe
13:50:24 <bollu> hey guys. So, my GSoC project for 2016 gor selected - it's to write SymEngine bindings to Haskell - https://summerofcode.withgoogle.com/dashboard/project/5513754485719040/overview/
13:50:37 <bollu> I'd like some help in the coming months when it comes to Haskell 
13:50:49 <bollu> like, "advanced" stuff - like tuning the GC maybe, and help on the FFI
13:51:06 <bollu> so, I was wondering if there was someone / a group of people I could ping for design help 
13:51:07 <bollu> :)
13:51:27 * hackagebot iridium 0.1.5.3 - Automated Testing and Package Uploading  https://hackage.haskell.org/package/iridium-0.1.5.3 (lspitzner)
13:51:29 <kadoban> Heh, I get a 500 response for that, nice.
13:52:10 <bollu> the URL? xD gimme a minute
13:52:38 <kadoban> Yeah. Oh it's a symbolic math engine thing, neat.
13:53:02 <bollu> yep!
13:53:14 <bollu> I was hoping for people who could help me come up with an elegant API
13:55:18 <raek> If I use a Data.Map.Strict.Map, is the map tree itself strict? What about the Lazy counterpart?
13:56:20 <lyxia> raek: it's the same tree type for Strict ans Lazy
13:56:55 <kadoban> Isn't it something like the spine of the tree is always strict, but the values stored in the map are the difference? Maybe?
13:57:44 <lyxia> In Strict the map is strict in its elements; not in Lazy. and both Strict and Lazy are strict in the keys
13:58:17 <Zemyla> Yeah, they have to be in order to do comparisons.
13:59:51 <lyxia> and seq-ing a Map forces the whole structure: data Map k a  = Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a) | Tip
14:00:39 <raek> so both the Strict and the Lazy variants are strict in the tree?
14:01:02 <Zemyla> Yes, they are.
14:01:29 <raek> ah, I can see that from lyxia's comment
14:01:39 <Zemyla> Also, I finally understand Data.Profunctir.Cochoice.
14:03:48 <raek> if I don't care if the values are reduced to whnf or not (because they are tiny lists (length less than 10) of integers), does the choice between Lazy and Strict Map matter?
14:04:49 <raek> the documentation tells me to use the Strict version unless I really need the laziness. I'm curious why.
14:06:01 <kadoban> raek: I would think not much then. It's a safer default really, if you don't need the laziness. Less chance of misunderstanding something and building up a huge thunk that'll sit around.
14:06:28 <raek> ok, makes sense
14:07:17 <pikajude> is it possible to delete all items with a certain field from an ixset?
14:07:23 <lyxia> Lazy is cool for being able to define maps of elements that depend on each other
14:07:45 <pikajude> as in, deleteIx, but there's more than one of that index
14:08:07 <raek> does seq-ing an ordinary list ever make sense? won't that just force the top of the cons tree to decide if it is a cons or a nil, but leave the rest of the list unforced?
14:08:49 <lyxia> raek: sometimes forcing the root of the list forces the whole list
14:10:41 <raek> lyxia: yeah, I have defined a map once that where each value depended on the the whole map (I implemented closures and environments for a toy language). that was certainly useful.
14:10:53 <kadoban> lyxia: Like if you used seq the whole way up or something when building the list you mean?
14:10:56 <raek> lyxia: when does that happen?
14:11:58 <raek> I think I'll go with the strict version in this case (sieve of erastosthenes)
14:12:10 <aweinstock> I'd think if the first element depends on the last?
14:13:52 <raek> it's probably time I read the source code for Data.Map.
14:14:02 <lyxia> you can inspect the list while you're building it, that makes new elements depend on the tail of the list
14:14:05 <aweinstock> > let xs = sum (tail xs) : [1,2,3] in xs
14:14:06 <lambdabot>  [6,1,2,3]
14:14:17 <kadoban> Yeah good point
14:14:25 <lyxia> seq being the "trivial inspector"
14:14:50 <aweinstock> > let xs = sum (tail xs) : [undefined,2,3] in xs `seq` ()
14:14:52 <lambdabot>  ()
14:14:57 <aweinstock> hmm
14:15:10 <aweinstock> > let xs = foldl' (+) 0 (tail xs) : [undefined,2,3] in xs `seq` ()
14:15:11 <lambdabot>  ()
14:15:36 <aweinstock> > let xs = foldl' (+) 0 (tail xs) : [undefined,2,3] in head xs `seq` ()
14:15:37 <lambdabot>  *Exception: Prelude.undefined
14:15:41 <aweinstock> ^ there we go
14:17:43 <raek> okay. interesting example.
14:20:11 <raek> hrm. I'm looking at the data definition lyxia wrote before. what does it mean to unpack a recursive type?
14:20:46 <raek> I understand that if you write !Int you get an integer in "the struct" rather than a pointer to a heap-allocated integer
14:21:04 <joebetz> question: haskell, smalltalk, and lisp have been described as languages of the gods. lisp, for its meta-programming capability. smalltalk, for encapsulation through objects. what would you say is the divine gift that has been given to programmers by haskell?
14:21:39 <raek> but how does that work for a type like this? data List a = Cons {-# UNPACK #-} !a !(List a) | Nil
14:22:38 <shachaf> raek: It doesn't.
14:22:40 <umib0zu> joebetz itâ€™s not that great. it just supports a robust state-of-the-art type system
14:22:56 <kadoban> joebetz: The type system probably, and some of the cool stuff that allows.
14:23:19 <lyxia> raek: it just unpacks the size field
14:23:29 <joebetz> what about it's support for abstractions like monads?
14:23:48 <kadoban> That's rather part of the type system
14:23:52 <lyxia> raek: in yours it unpacks the a field but I believe that's forbidden on polymorphic fields
14:23:53 <raek> lyxia: oh, so the UNPACK thingy only applies to one field and not all of them?
14:23:56 <lyxia> yes
14:24:04 <raek> ah, that makes sense
14:24:17 <umib0zu> joebetz monads have been around for years but monads donâ€™t solve your problems. it just gives you a better way to abstract your problems.
14:24:21 <joebetz> and I would agree umib0zu, a robust type system does not offer enough to put up there with smalltalk and lisp
14:24:25 <joebetz> hmm
14:24:41 <joebetz> sure, but that itself is a problem
14:25:12 <albeit> What's the best way to derive Monoid for a class? I was to "sum" multiple records :: Foo = { bar :: Int, baz :: String }
14:25:28 <raek> and the bangs do not have any effect on the memory layout fields? they only seq the fields values when entering the constructor?
14:25:30 <albeit> (I guess I more appopriately want to mappend them)
14:25:46 <joebetz> smalltalk gave us objects, lisp gave us homoiconicity ... does haskell give us anything so great as either of those?
14:26:14 <ski> albeit : if it's to work, clearly you must tell it which monoid to use on `Int' ..
14:26:28 <lyxia> raek: pretty much yes
14:26:55 <umib0zu> I mean sure, but Iâ€™m a javascript programmer professionally. Very few companies want to built with the technology because being a professional requires meeting deadlines. You canâ€™t tell many programmers to spend time learning actual computer science to use a language like haskell when most who are mildly organized can go out and build products well in these unityped systems.
14:26:59 <raek> all right. thanks for the clatification!
14:27:30 <Zekka|Sigfig> joebetz: I think itâ€™s a mistake to say â€œlisp gave us homoiconicityâ€ or â€œsmalltalk gave us objectsâ€
14:27:44 <Zekka|Sigfig> most of these concepts developed over time, and you canâ€™t pin their popularity to just one technology
14:27:45 <joebetz> how so?
14:27:55 <joebetz> hmm
14:28:00 <ski> joebetz : objects being great is debatable. of course, for some situations, they're good. but so are variant/sum types / algebraic data types. would you consider the latter to also be great ?
14:28:21 <Zekka|Sigfig> Iâ€™d particularly object to the smalltalk comment because simula 67 had objects and it existed before smalltalk
14:28:21 <kadoban> umib0zu: I don't think I even agree with the premise. What CS does haskell require that other languages don't?
14:28:56 <joebetz> ski: I don't think they make software easier to reason about in nearly so monumental a way as objects do
14:28:59 <umib0zu> kadoban every one of the senior engineers I meet donâ€™t know about the abstractions that are needed to work with haskell
14:29:06 <umib0zu> most of them avoid it
14:29:25 <kadoban> umib0zu: That just means they haven't learned haskell ... it's not general CS knowledge lacking most likely.
14:29:26 <ski> joebetz : they are dual concepts. it's a trade-off. sometimes you want to do it one way around, sometimes the other
14:29:50 <lyxia> albeit: I think doing it by hand is best here
14:29:53 <ski> joebetz : so the question is how often in practice you could benefit from doing things in the one way, or the other one
14:30:14 <umib0zu> kadoban most undergrad programs focus on product development since the goal is getting a job. CS knowledge these days is just java programming. I doubt people actually read real CS.
14:30:21 <albeit> lyxia, ski: Thanks
14:30:57 <umib0zu> I mean Haskell has itâ€™s place, but to pretend itâ€™s the be all end all god language is a little wonky since the people that sign our checks donâ€™t care about type safety.
14:31:01 <ski> joebetz : note that i'm specifically thinking of "objects" in the "record types" sense here (ignoring class hierarchies with implementation inheritance, e.g.). if you intend something else by "objects", then you need to explain what you mean
14:31:03 <joebetz> Zekka|Sigfig: I don't think the specific language is important so much as the concepts themselves. so to rephrease my question, what constructs does haskell support that are comparable in benefit to objects and homoiconicity.
14:31:26 <ski> umib0zu, of course
14:31:40 <Zekka|Sigfig> joebetz: Iâ€™m not really a haskell fan (Iâ€™m also not a smalltalk or lisp fan, but Iâ€™m particularly not a haskell fan)
14:32:00 <Zekka|Sigfig> Iâ€™m not a good person to sell you on it but I think the most novel Haskell feature is its support for code generation with typeclasses â€” but thatâ€™s pretty special-purpose
14:32:22 <ski> @where object-oriented
14:32:22 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
14:32:23 <joebetz> Zekka|Sigfig: which languages do you prefer?
14:32:37 <ski> see ^ for some info on what "object-oriented" might mean
14:32:43 <kadoban> umib0zu: Again, I disagree that "real CS" is more needed for haskell than for other languages.
14:32:47 <Zekka|Sigfig> joebetz: I donâ€™t like most programming languages very much, but I like CHR and Prolog lately. Theyâ€™re a little special-purpose too though
14:32:57 <joebetz> I think monads solve the problem of cross-cutting concerns more elegantly than any other language / construct
14:33:07 <kadoban> umib0zu: If you're thinking about stuff like CT ... nobody learns that, and it's certainly not required for haskell.
14:33:09 <Zekka|Sigfig> I donâ€™t think most people should write all their code in prolog
14:33:10 <joebetz> monads in haskell, that is
14:33:33 <Zekka|Sigfig> joebetz: The *general* problem of cross-cutting concerns? Maybe I donâ€™t understand what you mean by cross-cutting concern
14:33:43 <Zekka|Sigfig> could you clarify that?
14:35:14 <ski> joebetz : anyway, i'm interested in what you have in mind when you say "I don't think they make software easier to reason about in nearly so monumental a way as objects do". specifically what you're thinking about regarding objects (i'm still not quite sure what you mean by "objects") making software easier to reason about
14:36:49 <ski> joebetz : i'm suspecting that you're thinking about stuff like (a) refactoring (which obviously should preserve observable behaviour of the system); and (b) analyzing code to determine properties of it, e.g. checking invariants are upheld, and that post-conditions follow from pre-conditions, or checking that a list will always be generated in order, or a tree will have less than `n' elements, &c.
14:37:11 <kadoban> umib0zu: I mean even looking at what's considered good haskell books, like bitemyapp's ... I've looked at the table of contents and it sure doesn't seem heavy on CS concepts, any more than a comparable book for a different language. And that's for teaching beginners, who aren't going to know CS.
14:37:25 <umib0zu> LYAH?
14:37:29 <joebetz> Zekka|Sigfig: I mean, take the classic Maybe monad as an example. for any given type, you want for it to be either Just x or Nothing, and stop computation whenever you encounter a Nothing. this is a concern that cross-cuts any specific type. 
14:37:45 <kadoban> LYAH both isn't good and doesn't teach much CS theory at all. Does it teach any?
14:37:48 <umib0zu> Iâ€™m just saying I donâ€™t see many industry professionals taking the dive into functional programming. maybe scala.
14:37:56 <umib0zu> kadoban some monads and monadTs
14:38:24 <umib0zu> which is useful, but in javascript even that level of abstraction is seen as overkill for most problems.
14:38:25 <kadoban> umib0zu: Haskell's Monad isn't some abstract weird CS concept, it's a practical thing. It's as much CS as iterators are or something.
14:38:42 <Zekka|Sigfig> joebetz: OK, so what you like about Haskell is that itâ€™s good at letting you take a desirable feature and write rules to generalize it over e.g. all types?
14:38:56 <ski> joebetz : and when you say "they make software easier to reason about", what are you comparing with ? assembly programming ? programming in C, Fortran, Pascal, Ada, &c. ? Prolog ? Erlang ? Lucid ?
14:39:16 <cdtdev> Sorry Haskell, IMO, I've gotta say Erlang is easier to reason about.
14:39:18 <Zekka|Sigfig> Because I also think thatâ€™s a strong point even though I think there are a lot of rough edges â€” not because Haskell did it badly, but because itâ€™s really hard to talk about mixing two features without making some assumptions
14:40:17 <umib0zu> Oh yeah. So my point is most people are very imperative in their programming when they make products anyways, even guys with CS degrees.
14:40:29 <kadoban> umib0zu: Yes, I also don't see many people dive into haskell or other functional languages, though there's more interest now than in the past IMO. But your characterization above seemed to be that you'd have to like, get a CS degree and then learn haskell, that's just not true.
14:40:54 <kadoban> Yes, that's true. Imperative languages are stressed a lot and very popular.
14:40:57 <umib0zu> most state is held in databases anyways. for most work itâ€™s just json in and json out, so most engineers work with unityped languages because thereâ€™s no overhead or abstractions that are really required.
14:41:20 <Zekka|Sigfig> FWIW I think a lot of Haskellâ€™s preferred patterns are a little complicated to explain, but theyâ€™re not more â€œCSâ€ than patterns in other language
14:41:32 <umib0zu> and there are no damn macros in haskell
14:41:35 <kadoban> There's overhead in everything ...
14:41:40 <ski> umib0zu : there's TH ..
14:41:46 <umib0zu> TH?
14:41:49 <ski> Template Haskell
14:41:50 <cdtdev> Haskell is not easy at all... I don't blame someone for thinking Haskell needs a CS degree. They're wrong, but I don't blame them.
14:41:53 <umib0zu> oooo
14:42:26 <kadoban> cdtdev: Programming isn't easy. I don't blame people for being wrong either, generally.
14:42:29 <Zekka|Sigfig> (a lot of OOP fans like complicated patterns too â€” but I think in imperative languages theyâ€™re easier to avoid)
14:42:35 <umib0zu> well I donâ€™t have a CS degree. Iâ€™m just saying there are a class of programmers that arenâ€™t willing to invest the time to even learn basics beyond OO when you can make a career now just using javascript and python.
14:42:38 <ski> umib0zu : granted, it's a bit ugly to use. and i'm not sure it has hygiene, even (which is common in Scheme macro systems, but not in Common Lisp)
14:43:02 <Zekka|Sigfig> umib0zu: fwiw Iâ€™m objecting more to â€œreal CSâ€ than to â€œHaskell is more complicated than a lot of people want to bother with"
14:43:25 <ski> umib0zu : "most people are very imperative in their programming" -- yes, and that's something we'd like to change a bit, if we can :)
14:43:36 <kadoban> I don't think haskell is as complicated as it's usually portrayed. I think a lot of the learning materials aren't amazing, which isn't helpful.
14:43:52 <umib0zu> thatâ€™s true as well, but that will be fixed in time
14:44:13 <kadoban> Yes, haskellbook.com seems a large step up from what I can tell
14:44:24 <Zekka|Sigfig> kadoban: I think itâ€™s less complicated than a lot of people think, still complicated â€” it decided to be really good at expressing stateless computations and then thereâ€™s some bureaucracy you have to master for stateful ones
14:44:29 <kadoban> At least from the things that were recommended to me when I started.
14:44:42 <joebetz> Zekka|Sigfig: yep, pretty much. haskell supports synergy much better than any other languages do. and by that I mean, it enables and encourage you to address cross-cutting concerns in a way that benefits all types to which they can be applied.
14:44:45 <Zekka|Sigfig> they found a tradeoff and picked an angle on it, this is the natural consequence and itâ€™s about what youâ€™d expect
14:44:57 <cdtdev> Haskell just thinks a lot more mathematically than what we're used to in the real world.
14:45:03 <kadoban> Zekka|Sigfig: That sounds about right.
14:45:09 <cdtdev> And there's functions built on top of functions built on top of functions.
14:45:16 <cdtdev> It's not intuitive. At all.
14:45:26 <Zekka|Sigfig> cdtdev: I think haskell likes generalizing about things most people donâ€™t really feel like generalizing about
14:45:27 <kadoban> cdtdev: I suck ass at math. I do fine in haskell. Programming isn't intuitive.
14:45:30 <umib0zu> joebetz but back to your question. what makes haskell godlike? Iâ€™m trying to say thereâ€™s plenty that brings it down to the level of us mere humans.
14:45:46 <cdtdev> kadoban: Not that it is math, but it works in a similar way, mentally.
14:46:03 <Zekka|Sigfig> I like having the power to generalize, but I donâ€™t need all the complicated generalizations all the time
14:46:07 <ski> cdtdev : intuition is something that is developed over time, with experience
14:46:13 <ski> cdtdev : no experience, no intuition
14:46:14 <roboguy`> cdtdev: that just sounds like a result of breaking large problems into smaller problems. You don't see that as intuitive?
14:46:25 <cdtdev> ski: True. And generally, the real world doesn't give us the intuition to work with Haskell.
14:46:49 <kadoban> "intuitive" tends to mean kind of the same nebulous stuff as "readable" means to people, which is ... "it looks like stuff I already learned".
14:46:49 <Zekka|Sigfig> having to remember the difference between a bunch of different lifting operations feels like a pain when what I can just sit down in an imperative language and have it do what I wanted by default
14:47:17 <kadoban> It's less of an objective quality of the thing being described and more a function of the person describing it, more specifically their previous lanugages.
14:47:25 <cdtdev> Haskell is well worth learning, I think. But it's not easy. It takes effort.
14:47:30 <nitrix> I think it's harder to think outside the box and accept there are other, valid, simpler approach to a problem than the ones you're used to because you've spent all your time inside said box.
14:47:35 <ski> umib0zu : fwiw, i don't think "languages of the gods" or "godlike" is really useful ways to describe programming languages at all
14:47:45 <cdtdev> In my experience, a lot more effort than imperative and typical OOP.
14:47:58 <Zekka|Sigfig> I think thereâ€™s some valid arguments to be made that haskell patterns are a little complicated
14:48:00 <nitrix> cdtdev: I think imperative languages makes this a placebo.
14:48:14 <nitrix> It's shaped as an iceberg.
14:48:14 <Zekka|Sigfig> if you write down the monad operations and laws, then write down the iterator operations and try to improvise some laws, youâ€™ll probably use about the same amount of paper
14:48:18 <ski> umib0zu : so i don't think "what makes haskell godlike?" is an interesting question to attempt to answer. ditto for substituting any other language for Haskell
14:48:19 <nitrix> While Haskell is shaped as a mountain.
14:48:26 <umib0zu> I think learning haskell just made me a really good javascript programmer :-)
14:48:38 <cdtdev> nitrix: Not a bad way of looking at it.
14:48:39 <umib0zu> I can fizzbuzz because of haskell
14:48:41 <Zekka|Sigfig> thatâ€™s probably even true if you express both types/sets of laws in the same language
14:49:03 <cdtdev> nitrix: With, say, Python, you can take small bites and be productive. Haskell you just have to eat the whole damned thing, then you can do anything.
14:49:19 <Zekka|Sigfig> Iâ€™m being informal, but I think that working effectively in Haskell requires learning things that are at least iterator-complex right off the bat, and then thereâ€™s a huge stack of things that are even more complex that come in later
14:49:24 <joebetz> umib0zu: by godlike I just mean that it leverages the programmer's productivity significantly more than other languages
14:49:37 <nitrix> cdtdev: I think the learning curve is bigger, but there's to same amount to learn. It's not as hard either if you build your knowledge iteratively (on top of your existing mental foundation)
14:49:50 <nitrix> cdtdev: I'll argue that's a good thing.
14:49:50 <ski> cdtdev : i'm doubtful about the relevance of this "real world" (whatever that is). different people have wildly different experience, working in wildly differing environments. you use what you can find which makes sense to use for you
14:49:55 <kadoban> cdtdev: To some extent that's a little true. For beginners though, "productive" has to mean something really limited for python to get them productive quickly either.
14:50:18 <cdtdev> kadoban: A person who programs with Python for a week can probably make a text-based adventure game.
14:50:19 <Zekka|Sigfig> I want a poster that says this:   <ski> cdtdev : i'm doubtful about the relevance of this "real world" (whatever that is)
14:50:21 <kadoban> I mean python is a ... quick language to learn, but it still takes kind of forever when you get down to it before you can do real projects.
14:50:39 <kadoban> cdtdev: If it's their first language? Extremely doubt it.
14:50:47 <cdtdev> Real world -- in an OOP you can do Turtle Fred = new Turtle();
14:50:48 <nitrix> kadoban: Besides reaching the point where your code is consistently correct.
14:51:13 <cdtdev> Fred.step(5); Fred.turnLeft(); Fred.step(2); and get lines on your screen.
14:51:21 <kadoban> cdtdev: If they know N imperative procedureal with some OO languages and learn python, yeah it doesn't take long to get off the ground, fairly unsurprisingly.
14:51:37 <nitrix> cdtdev: step 5 . left . step 2 $ turtleDefault
14:51:56 <umib0zu> also can we get a professional haskellerâ€™s input? my problem with unityped languages is that with no type checker, you refactor and break things that you donâ€™t know your break
14:52:04 <cdtdev> nitrix: Then you have to explain function composition.
14:52:15 <umib0zu> whatâ€™s cool with haskell is that if it compiles thereâ€™s a pretty good chance itâ€™s right on the first try
14:52:23 <Zekka|Sigfig> I mean, you can explain both function composition and semicolons as â€œthis is a way to take two things and say to do one after the other"
14:52:33 <roboguy`> cdtdev: you can just write it as IO actions and use do notation. You don't have to learn how do notation actually works until later
14:52:34 <Zekka|Sigfig> I think function composition/monad syntax get harder to explain when you explain the things you canâ€™t do
14:52:38 <nitrix> cdtdev: step 5 (left (step 2 turtleDefault)), done.
14:53:00 <Zekka|Sigfig> in an imperative language the answer is â€œyou can do anything you wantâ€ â€” but in polite haskell you usually donâ€™t want that
14:53:00 <joebetz> what annoys me about haskell is all the nonlinguistic syntax. e.g., ">>=" instead of "bind". 
14:53:03 <kadoban> umib0zu: Yes. One of my favorite parts of haskell is refactoring stuff. It's like a dream compared to doing it in ... any other language I've ever worked in.
14:53:18 <cdtdev> nitrix: This is not intuitive to the average person. In the OOP/Procedural version, a person can say, "Fred is taking steps. Then he turns. Then he takes more steps."
14:53:40 <nitrix> cdtdev: It very is. It's repeated function application, the codomain of one being the domain of the other.
14:53:49 <kadoban> cdtdev: This is because people have already learned to program this way. It's not an inate quality of humans.
14:53:50 <umib0zu> I want to see whether a project with haskell survives the 2 year mark. Iâ€™ve been on 3 projects in javascript and once 2 years hits, it becomes a massive pain to make new features.
14:54:15 <umib0zu> I would love more type safety
14:54:16 <cdtdev> nitrix: Here, you've literally got, "Fred is a 5-stepped left-turned 2-stepped default turtle."
14:54:16 <nitrix> cdtdev: It's like one of the first thing you learn to do, except somehow they use temporary variables.
14:54:27 <Zekka|Sigfig> I donâ€™t think thereâ€™s a huge difference between that and do { fred (step 5); fred turnLeft ; fred (step 2) } â€” and that last version can express whatever you want from an OOP language
14:54:39 * ski isn't sure what "nonlinguistic syntax" means
14:55:02 <kadoban> cdtdev: You have to learn to program, it's not like "oh I just tell the computer all the steps, okay this is easy" ... you probably just have forgotten how long it took to learn to think that way.
14:55:08 <cdtdev> nitrix: THe point is, I can "command" Fred like I can command a person. You can tell a person "Take two steps, now turn, now take three more steps."
14:55:09 <roboguy`> umib0zu: there are definitely examples. Yesod has been around about 6 years, I believe
14:55:09 <Cale> cdtdev: I don't know, I think Haskell is about as hard to learn as whatever your first programming language was
14:55:14 <joebetz> ski: using symbols instead of words
14:55:16 <Zekka|Sigfig> things get harder when someone makes a mistake in their IO code and get a cryptic error, or when they wonder what the difference is between just applying a function and <-ing out its value
14:55:20 <nitrix> cdtdev: Then use a monad.
14:55:31 <nitrix> cdtdev: That's what they're for. They're very simple too.
14:55:39 <Zekka|Sigfig> I got do notation really quick, but I panicked when I misused it and got errors I couldnâ€™t understand
14:55:45 <Cale> cdtdev: If you already know 5 or 6 imperative languages, it's easy to pick up Python or something, but they won't really help you learn Haskell quickly.
14:55:47 <Zekka|Sigfig> I bet that happens to a lot fo newbies
14:55:56 <Cale> (and might get in the way, since you have expectations which are wrong)
14:56:12 <suppi> I had a hard time learning programming in college. it took me a long time (more than a year) to do something substantial
14:56:14 <Cale> But in absolute terms, I don't think it's any harder than anything else.
14:56:15 <cdtdev> I've taught several people programming. Procedural with OOP is pretty intuitive. The basics are learned in just a few hours.
14:56:23 <ski> joebetz : why does it annoy you ?
14:56:28 <nitrix> How did this discussion start by the way? Is cdtdev anxious about Haskell?
14:56:36 <cdtdev> nitrix: I don't mind Haskell. I like it.
14:56:44 <Cale> cdtdev: I've taught beginners in Haskell too, and they've been fine (including some bright 7 year old kids)
14:56:47 <cdtdev> nitrix: But Procedural/oop is way simpler.
14:56:53 <suppi> took me a similar amount of time to do things with haskell, but in haskell i had to do it by myself from bad resources on my spare time
14:57:05 <danharaj> cdtdev: don't listen to Cale
14:57:06 <cdtdev> nitrix: By simpler, I mean, it's more familiar to a non-programmer.
14:57:16 <Zekka|Sigfig> Iâ€™ve found special-purpose haskell not too hard to teach, but general-purpose haskell was harder for me to teach my pals than general-purpose imperative code
14:57:22 * Cale glares at danharaj 
14:57:28 * danharaj o/
14:57:36 <joebetz> ski: because I prefer linguistic thinking, and most of the symbols don't have any innate meaning, aside from resembling mathematical symbols
14:57:39 <nitrix> cdtdev: I doubt it. I think you see it twice as hard because you aren't learning Haskell as if you were starting from scratch.
14:57:44 <kadoban> cdtdev: That's just because you know it better and learned it first.
14:57:55 <cdtdev> It's natural to subclass "Turtle" into "Red Turtle" and "Green turtle."
14:57:58 <nitrix> cdtdev: Instead you're trying to transpose procedural concepts to functional, which is obviously going to feel strange.
14:58:02 <ski> nitrix : "<joebetz> question: haskell, smalltalk, and lisp have been described as languages of the gods. lisp, for its meta-programming capability. smalltalk, for encapsulation through objects. what would you say is the divine gift that has been given to programmers by haskell?"
14:58:02 <cdtdev> People understand this immediately.
14:58:44 <kadoban> cdtdev: Oh jesus, how OOP works is incredibly unintuitive. They understand it immediately, and understand it incorrectly. Hence all of the fun of  "is an ellipse a subclass of a circle? The other way around? Neither? Wtf?"
14:58:44 <Zekka|Sigfig> Maybe we should be talking about haskell as a way to rewrite hinky imperative programs, since hinky imperative programs arenâ€™t too hard to write in haskell
14:59:05 <nitrix> cdtdev: Without subclassing, Haskell could make Red and Green attributes of your turtle in a type-safe manner.
14:59:18 <roboguy`> cdtdev: that doesn't seem any easier than explaining a Turtle data type in Haskell where color is an attribute
14:59:19 <cdtdev> nitrix: And the beginner knows what type-safety is?
14:59:27 <ski> joebetz : i'm still not really seeing how one is linguistic but the other isn't. to me, both are linguistic
14:59:30 <suppi> cdtdev, this is so not true. I was taught OOP in a class. there is not a single example of inheritance that didn't crumble does if you poke at it a bit.
14:59:31 <Zekka|Sigfig> IIRC thereâ€™s a few guys in this channel who are fans of teaching IO first
14:59:32 <joebetz> ski: even the fact that you have multiple operators for specificying application precedence is annoyhing to me. cos (sin x) vs cos $ sin x.
14:59:40 <roboguy`> why would a beginner need to know what type safety is to learn Haskell?
15:00:02 <ski> joebetz : meaning comes with looking at docs (and examples), and maybe the implementation
15:00:03 <Cale> cdtdev: When you want someone to wash all the dishes, you don't tell them to number the dishes and increment a counter and in some sort of loop, wash dish i and increment the counter.
15:00:03 <suppi> I have yet seen an inheritance problem that i couldn't crumble down with a few questions
15:00:06 <kadoban> cdtdev: Beginners don't know what ... anything is. You're just giving them the benefit of the doubt towards knowing all of procedureal/OOP programming like it's an obvious innate thing, but not giving functional the same courtesy.
15:00:14 <nitrix> cdtdev: They don't, but they get it for free with Haskell.
15:00:32 <Cale> cdtdev: You just tell them to wash all the dishes. That's a lot more like a higher order function than like iteration or recursion.
15:00:48 <Cale> cdtdev: People think in terms of higher order functions all the time.
15:01:04 <Zekka|Sigfig> kadoban: FWIW one of my friends who studies biology (that is, not math) initially took to haskell because she couldnâ€™t figure out what a variable was in Java (what the school teaches) and ran into a lot of abstraction leaks in javaâ€™s type system
15:01:09 <Cale> (or at least in terms of something that's a lot closer to that than anything else)
15:01:23 <nitrix> Learning your first procedural languages were easy _because_ you probably didn't know about all the things to be careful about and programming defensively.
15:01:25 <Zekka|Sigfig> she ultimately didnâ€™t end up using haskell because she wanted to write a lot of programs that did a lot of output and java gave her fewer cryptic error messages when she got it wrong
15:01:36 <cdtdev> nitrix: No doubt.
15:01:37 <ski> cdtdev : i'm not sure about "It's natural to subclass \"Turtle\" into \"Red Turtle\" and \"Green turtle.\"" .. info about "subclassing" is often confusing subsets with quotient/factor sets, it seems to me
15:01:40 <Zekka|Sigfig> I think there are definitely parts ofh askell that are really intuitive for a lot of people
15:01:44 <orion> Cale: Are you a professional tutor for gifted students?
15:01:45 <cdtdev> nitrix: I'm not saying OOP/procedural is the best way.
15:01:58 <ski> cdtdev : "People understand this immediately." .. perhaps they "understand" it. i doubt they understand it, though
15:02:16 <cdtdev> ski: No, they don't understand it at a technical or theoretical level, but the average person isn't equipped to.
15:02:20 <nitrix> cdtdev: I think two individual completely new to programming would learn quicker and flourish better in an FP environment.
15:02:31 <cdtdev> ski: They do understand it at a practical level: they can take a pre-defined turtle class and modify it as they need to.
15:02:32 <nitrix> cdtdev: I have nothing to back up that claim though.
15:02:34 <kadoban> Zekka|Sigfig: That sounds about right
15:02:36 <Cale> orion: No, but I was working at a university at a time that a program for gifted students was going on, and I was working in the same room while they were studying Haskell.
15:02:43 <cdtdev> ski: Programming is often a case of "good enough." Working code is better than no code.
15:02:46 <Cale> orion: So I frequently helped out teaching them
15:02:50 <joebetz> ski: I think it makes sense for your standard operators, but anything beyond what you see on your standard operator requires learning a symbol with mostly arbitrary meaning, whereas the word "bind" is actually self-descriptive.
15:03:22 <ski> joebetz : fwiw, i'm not a fan of using `$' much. i tend to keep it near a minimum, in my code
15:03:41 <kadoban> cdtdev: Note also that "green turtle and red turtle" being subclasses of turtle, is terrible OO
15:03:42 <Zekka|Sigfig> Someone (maybe me!) should write a haskell tutorial at some point with a goal of not mentioning types or making people write any non-IO code
15:04:12 <cdtdev> kadoban: I'm not talking about making great programmers here, but getting people writing code.
15:04:19 <lyxia> I also prefer (fmap . fmap . fmap) over fmap . fmap . fmap $
15:04:22 <cdtdev> kadoban: And code that works.
15:04:50 <Zekka|Sigfig> it seems like a lot of imperative language tutorials start by trying to teach you to write sloppy code and later teach you to do it correctly
15:05:00 <cdtdev> Teaching Python, they're writing naive text-adventure games within 3 days.
15:05:03 <kadoban> cdtdev: Well, you seemed to be saying that OO is somehow like a natural thing that people pick up. I think it's interesting that your example for this is both kind of natural sounding and also an awful way to do it.
15:05:04 <Zekka|Sigfig> but a lot of haskell tutorials I see try to teach people to write polite code thatâ€™s clean
15:05:07 <joebetz> cdtdev: 'Programming is often a case of "good enough."' <-- I loathe this attitude. sure, make it work comes before make it right, but I don't think that makes it any less important.
15:05:29 <Zekka|Sigfig> I talk a lot about how haskell is pretty easy to mechanically translate to lower-level languages like java â€” but the sameâ€™s true the other way
15:05:34 <nitrix> cdtdev: I don't know what's worse "Why does my code not work? Hours on Google, oh, the pointer is dereferencing a null object. What are those? ..." vs. "Type error IO () mismiatch ()".
15:05:35 <cdtdev> Zekka|Sigfig: I agree.
15:05:52 <ski> cdtdev : by "understand", i mean that their "understanding" such as it is, isn't only incomplete, but incorrect, mistaken, a chimera
15:06:03 <cdtdev> joebetz: I'm not saying it's not important. But let's look at it from a beginner's perspective. Programming is a hard, cryptic activity evi lhackers do.
15:06:05 <suppi> teach them elm and they'll make some nifty animations in days...
15:06:30 * hackagebot servant-csharp 0.0.3.0 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.3.0 (KatsutoshiItoh)
15:06:35 <nitrix> cdtdev: Might not be the best example, but I'm confident I wasted many years developing my mindset around working with procedural languages... you'd be surprised just how quick someone can get good at haskell if they wouldn't have to learn all these corner cases and what else.
15:06:37 <Zekka|Sigfig> suppi: Is that easy to install yet? Because I liked it OK last I used it, although I didnâ€™t feel a compulsion to write real apps ini it
15:06:45 <cdtdev> joebetz:  Is it better for them to be writing a text adventure game with shitty practices, or is it better to get them writing great, career-ready code?
15:07:14 <suppi> Zekka|Sigfig, I've seen people teaching school kids elm. and you can play with elm in the browser without downloading anything at all.
15:07:16 <ski> cdtdev : "Working code", yes. "code that you think is working, but actually isn't", no :). after getting more experience, fail faster is better
15:07:21 <joebetz> cdtdev: I don't understand your question
15:07:52 <Zekka|Sigfig> suppi: That goes on my list of tools to introduce my cousin to programming with!
15:07:54 <Zekka|Sigfig> (heâ€™s six)
15:07:54 <cdtdev> joebetz: Working code, rather than "correct" code, is probably more important in keeping a beginner's morale high.
15:07:55 <nitrix> I don't think he asked one.
15:07:55 <kadoban> cdtdev: There's like two false premises in that. People learning python aren't going to be churning out a text adventure game anytime soon. The first week will be like "What's your name?" "Hi Bob"
15:07:57 <joebetz> cdtdev: I think it's better for them to learn good practices as soon as possible, if that's what you're asking
15:08:03 <joebetz> cdtdev: hmm, interesting
15:08:12 <nitrix> cdtdev: Here's the thing, code that runs isn't code that works necessarily.
15:08:16 <cdtdev> kadoban: No, they can do a text-adventure game in a week.
15:08:20 <joebetz> cdtdev: that still seems very shortsighted
15:08:20 <kadoban> cdtdev: And people learning haskell aren't going to be turning out their first programs at a professional level either.
15:08:51 <kadoban> cdtdev: If they're an absolute beginner to programming? No, unless we're talking about like, extremely guided instruction here for that specific goal.
15:08:53 <Zekka|Sigfig> I learned programming because I really liked making stuff happen on the screen and I was the only guy I knew who could do that
15:09:03 <Zekka|Sigfig> Iâ€™m in favor of anything that can advance kids to that point
15:09:07 <cdtdev> kadoban: If they can write a "Is your name Jane?" "No." "Then is your name John?" "Yes." "Great!" they have what they need.
15:09:14 <ski> joebetz : well, i think the connection between the colloquial meaning of a term, and the technical meaning of it, is often tenuous at best, so you have to learn the technical meaning anyway. i don't see it as that much of the problem. in fact, i think sometimes using an unfamiliar term/symbol is *better* than using a term that you *think* you know roughly what it means
15:09:18 <joebetz> Zekka|Sigfig: so... something with visible results?
15:09:19 <cdtdev> kadoban: It won't be pretty, but I remember writing a text-adventure game.
15:09:33 * ski grins at lyxia
15:09:36 <nitrix> cdtdev: readLine ... lambda .... putStrLn ...
15:09:47 <Zekka|Sigfig> joebetz: Yeah, preferably something thatâ€™s personal â€” one of my early projects was a Visual Basic city management game on the command line
15:09:54 <Zekka|Sigfig> that has a lot of room for creativity
15:10:07 <Zekka|Sigfig> (The code quality was putrid.)
15:10:22 <nitrix> cdtdev: I'll argue that example is probably even more trivial in Haskell.
15:10:28 <Zekka|Sigfig> I really like Informâ€™s model but I think it leads to a lot of cryptic errors
15:10:32 <cdtdev> nitrix: "lambda" is trivial?
15:10:43 <kadoban> cdtdev: Your memory is likely very condensed. It usually takes people a few days to get past "wtf is this compiler crap, how to I run things? Wait this doesn't work at all, where am I supposed to type stuff?"
15:10:49 <nitrix> cdtdev: Replace it with an if else, whatever.
15:10:49 <suppi> Zekka|Sigfig, you might also want to consider Racket with HtDP: http://www.ccs.neu.edu/home/matthias/HtDP2e/part_prologue.html
15:11:04 <cdtdev> kadoban: Except I've seen other people do it, too, people I've taught.
15:11:14 <roboguy`> cdtdev: you can always make named functions first
15:11:19 <joebetz> Zekka|Sigfig: "I was the only guy I knew who could do that" <-- this is the part that baffles me. once I learned programming, my impulse was to show others how to program, not revel in being the "only one".
15:11:23 <Zekka|Sigfig> suppi: Will take it under advisement.
15:11:33 <Zekka|Sigfig> joebetz: When did you learn programming? I was 8 and really into puzzles
15:12:07 <gfixler> joebetz: I've always wanted to show people how to do it, too, but have never found anyone interested
15:12:09 <Zekka|Sigfig> I did basically what youâ€™d expect a kid who was 8 to do to show off
15:12:15 <gfixler> joebetz: and I started more than 25 years ago
15:12:20 <Zekka|Sigfig> I usually showed people my tricks but it was a pretty showoffy deal
15:12:21 <joebetz> Zekka|Sigfig: 19
15:12:56 <orion> < cdtdev> joebetz: Working code, rather than "correct" code, is probably more important in keeping a beginner's morale high. <-- If you are a beginner programmer, you get frustrated trying to learn Haskell, you give up and learn Python instead, I don't want you on my team.
15:13:00 <joebetz> gfixler: really? did you ever advertise yourself as a mentor, tutor, or trainer?
15:13:04 <joebetz> *or teacher
15:13:14 <suppi> Zekka|Sigfig, also this: http://outreach.mcmaster.ca/menu/tutorials.html
15:13:17 <cdtdev> orion: Lol. So you're an elitist.
15:13:19 <Zekka|Sigfig> I probably didnâ€™t have a lot of emotional maturity compared to 19-year old joebetz
15:13:28 <kadoban> orion: That's kind of harsh and counterproductive ...
15:13:32 <gfixler> joebetz: not professionally, but I couldn't begin to count how many times I've said "I could teach you, if you're interested" to people
15:13:40 <gfixler> friends, relatives, eventually coworkers, etc
15:13:41 <Zekka|Sigfig> suppi: Heâ€™s not gonna do anything unless I sit over his shoulder and help him, but I might adapt it
15:14:00 <gfixler> joebetz: in my experience, the overwhelming majority of people don't want to learn it, and most don't even seem to want to know it
15:14:33 <orion> cdtdev: I don't hire quitters.
15:14:33 <suppi> Zekka|Sigfig, yeah, unless the incentive from learning programming is interesting enough :)
15:14:36 <gfixler> joebetz: I have 4 families (2 stepparents), and hundreds of relatives, and not one other person is a coder
15:14:46 <joebetz> gfixler: yeah, it amazes and depresses me how many "programmers" don't give a fuck about understanding how they're code works, even ones that have been doing it for years.
15:15:00 <Zekka|Sigfig> suppi: His favorite thing right now is probably advertising. Itâ€™s a struggle just to get him away from the commercials!
15:15:01 <cdtdev> orion: What company do you hire for?
15:15:16 <gfixler> joebetz: the realization for me, especially the last 5 years, has been that people feel that way about most everything
15:15:25 <orion> cdtdev: Not disclosing. :x
15:15:39 <Zekka|Sigfig> itâ€™s not that he wouldnâ€™t be into it â€” although I donâ€™t know if he would be â€” but that I have to compete with media blitz and instant gratification
15:15:41 <cdtdev> orion: Damn, I'd really like to know what company to add to my blacklist.
15:15:47 <nitrix> orion: Why the scene then?
15:15:48 <Hijiri> did it start with an S
15:15:49 <joebetz> gfixler: do you have a blog? do you reddit? good programmers are hard to find, so limiting yourself to friends and family seems too limiting.
15:15:57 <gfixler> joebetz: it feels like a mix of insecurity, fear of failure, fear of the time committment, general disinterest, and a kind of innate knowledge that time/life is fleeting, and we can't all learn everything
15:16:13 <gfixler> joebetz: I'm talking about when I was growing up
15:16:19 <Hijiri> orion: Were you the one who posted the job offer heavily hinting at the offering company?
15:16:24 <joebetz> gfixler: oh, okay
15:16:26 <gfixler> joebetz: in the past couple of years I've been in as many as 6 programming meetups at once :)
15:16:30 <orion> Hijiri: Nope.
15:16:31 <cdtdev> orion: I don't want to work for someone who expects me to be the .05% of rockstars who will always understand what they learn and never stumble.
15:16:32 <gfixler> joebetz: only 2 these days
15:16:41 <nitrix> Small question, shouldn't those disscussions happen on #haskell-offtopic?
15:16:56 <nitrix> I'm just surprised to see the channel this noisy.
15:17:08 <gfixler> joebetz: it's an interesting data point, though, that out of hundreds of relatives, none of them code, and that in all my friends throughout school, I've known very few who were interested
15:17:13 <kadoban> There's a #haskell-offtopic?
15:17:14 <orion> cdtdev: I realize that success is the result of repeated failure.
15:17:15 <cdtdev> I'm sure 99.5% of programmers have given up on something.
15:17:22 <nitrix> kadoban: It's the real #haskell-blah.
15:17:27 <nitrix> kadoban: Same ops.
15:17:31 <gfixler> joebetz: there are probably more kids interested these days - computers were a lot more scarce when I was in school in the 80s and 90s
15:18:01 <roboguy`> orion: that does seem really harsh. I took a long break from Haskell when I was first learning it because I was starting to get stuck. When I came back, it made a lot more sense and I've gotten pretty experienced, have worked with Haskell as a job and I'm starting a PhD which will focus on Haskell-oriented topics
15:18:28 <orion> cdtdev: I expect a new programmer learning Haskell to stumble, and that's OK because it is progress. When you stumble, throw your hands in the air, and yell, "I can't learn this! This sucks! I quit!" -- then I don't want to work with you.
15:18:29 <gfixler> At my Haskell meetup, many people have claimed the same thing - they're the only person in their entire company interested in FP at all, and they can't get anyone to listen or adopt any FP ideals/goals
15:18:32 <roboguy`> So I don't think a *beginner* giving up on something (temporarily, at the very least) is a bad sign
15:18:44 <nitrix> I'd really love to see the crowd move from -blah to -offtopic, but, I can't force people :P
15:19:02 <gfixler> I've also heard this from people elsewhere (I talked with a guy in Japan who said the same thing - trying to get anyone at his company there interseted)
15:19:07 <Zekka|Sigfig> I get sad when people give stuff up because itâ€™s too hard â€” I think itâ€™s a good idea to give stuff up when itâ€™s not rewarding any more, though
15:19:13 <cdtdev> orion: That's probably not what learners who switch to Python are saying, but making a rational decision that learning Haskell is a bit out of their capabilities for now, and Python will further fulfill their goals.
15:19:21 <orion> Learning is *hard* and it requires real work and dedication.
15:19:21 <suppi> I think there are better things to worry about related to co-workers...
15:19:32 <suppi> better -> more important
15:20:13 <suppi> haskell can be a real pain in the ass to learn. we don't have very good resources to learn from and if you are not familiar with the internet so much, not a lot of people to ask about
15:20:29 <Zekka|Sigfig> when I was starting with neural nets I threw a couple weekends into it and felt like â€œnone of these systems work, Iâ€™m not enjoying this, time to switch to something elseâ€
15:20:39 <orion> roboguy`: Taking a break /= giving up
15:20:45 <Zekka|Sigfig> I think thatâ€™s a good reason to quit. Later I found a working neural net implementation of a problem I was interested in and that got me back int oit
15:21:40 <suppi> the situation is constantly improving, but it is very easy to not learn haskell and go with something else..
15:23:18 <roboguy`> orion: This was years ago now, so there is a chance I'm misremembering, but at the time I thought I was giving up on it. I had convinced myself some (untrue) things about monads and decided that they were not worth it. After looking again, I realized that I had not evaluated the worth of monads anywhere near fairly (because I was a beginner) and, not only that, but Haskell had additional things to offer
15:23:37 <orion> suppi: If it wasn't for this channel, it would have taken me many years to get to the level I'm at now. This community is amazing.
15:23:44 <roboguy`> I guess my point is, it seems unfair in general to judge people based on what they do as beginners
15:24:00 <EvanR> i didnt evaluate monads fairly either, i thought they were way more awesome than they are
15:24:12 <suppi> orion, a lot of people don't know IRC even exists.
15:24:18 <kadoban> roboguy`: Thankfully it's basically impossible too. Until we all get implanted with recording devices from birth, nobody will know.
15:25:08 <EvanR> luckily it turns out monads is a small fraction of haskells ideas
15:25:17 <Zekka|Sigfig> I think most people should try not to be hard on themselves if they give up on stuff because theyâ€™re not getting what they want out of it
15:25:45 <orion> If you have the desire to learn and you're willing to put in the work, I'm willing to teach. It can be lonely/sad/depressing trying to muddle your way through it alone. (I'm not qualified to teach Haskell though, at least not yet).
15:25:49 <Zekka|Sigfig> there are a lot of technologies I like now but I wouldnâ€™t have blamed myself if my instincts told me to give up on them
15:25:54 <kadoban> Zekka|Sigfig: Indeed. If you give up on *everything* before you get anyhwere with any of it and never go back, that's a problem ... otherwise, not so much.
15:26:15 <Zekka|Sigfig> Iâ€™ve had the most success just keeping open to opportunities to do stuff I didnâ€™t plan to
15:26:30 <cdtdev> Actually, now, just after going through cis194, I've quit learning Haskell temporarily.
15:26:46 <Zekka|Sigfig> thereâ€™s a group at my school that reverse-engineers malware. When the guy who runs it invited me to join I didnâ€™t know what I was getting into or anything about native code programming
15:26:52 <kadoban> Hell if anything I wish I *had* given up on certain things I spent a lot of time learning.
15:26:52 <cdtdev> Why? I came up with a project idea, and I think Erlang will better suit what I want to do.
15:26:55 <Zekka|Sigfig> now I know a lot more about that and it turns out I really enjoy it
15:27:14 <Zekka|Sigfig> I gave Scala a pretty good chance and it didnâ€™t look good for a lot of stuff I wanted to do â€” and I got turned off by the huge featureset
15:27:16 <kadoban> cdtdev: Cool, hope it's fun. Erlang seemed kind of interesting to me at one point.
15:28:12 <Zekka|Sigfig> there are people who in my position would have pushed themselves really hard to like Scala, but I think if I had done that I would have been unhappy
15:28:16 <suppi> yeah I'm also very interested in Erlang :)
15:28:31 <EvanR> i dont understand why there is a push to like scala despite scala
15:28:40 <EvanR> is it the nice looking manual?
15:28:45 <cdtdev> JVM.
15:28:46 <Zekka|Sigfig> Well, some people really like it and arenâ€™t pretending. I donâ€™t know why.
15:28:56 <hpc> it's like a murderer really liking life in prison
15:28:57 <kadoban> EvanR: For me it was when I was in an android phase and it looked more fun than java.
15:28:57 <cdtdev> To some people, JVM seems to be the only thing that matters.
15:28:58 <hpc> the alternative is java
15:29:04 <Zekka|Sigfig> there are a lot of scala fans in my office and theyâ€™re pretty intelligent, but the stuff I donâ€™t like, they donâ€™t seem to have a good excuse for
15:29:06 <cdtdev> "It's not JVM? why would you even learn that."
15:29:23 <kadoban> Next step, GHCJVM?
15:29:26 <hpc> from what i have seen of scala (which isn't much)
15:29:34 <hpc> it gets very close to greatness and then runs a mile the other way
15:29:40 <cdtdev> ^
15:29:46 <Zekka|Sigfig> hpc: same impression
15:30:01 <suppi> i have a really bad taste in my mouth about jvm and java... :(
15:30:01 <hpc> i want to learn it, just so i will have learned it
15:30:04 <hpc> because it's different
15:30:13 <hpc> but only in the same way i want to learn ruby
15:30:25 <Zekka|Sigfig> Iâ€™m not quite as favorable â€” a lot of it just seems to designed to give you versatility while taking away the ability to be exhaustive
15:30:36 <EvanR> it seems clojure and frege are in the same bandwagon then
15:30:38 <Zekka|Sigfig> itâ€™s really hard just to look at an expression, know the types of the values, and say if it will typecheck
15:30:50 <kadoban> The next languages on my list are probably racket and maybe acl2 or agda
15:30:53 <hpc> (actually i am not particularly interested in ruby anymore, the main different thing about it is blocks which i think i will not like)
15:31:09 <EvanR> blocks = crippled functions
15:31:21 <Zekka|Sigfig> hpc: block-taking functions are like lambda-taking Haskell functions with some extra features
15:31:21 <EvanR> lambdas = uncrippled blocks
15:31:21 <kadoban> Blocks? Like ... the scoping things from C-ish?
15:31:26 <Zekka|Sigfig> you are likely not to like the extra features
15:31:27 <hpc> kadoban: agda is definitely worthy of a spot on your list, as a placeholder for dependent types
15:31:33 <Zekka|Sigfig> kadoban: Ruby has a feature called blocks
15:31:36 <suppi> kadoban, no
15:31:49 <hpc> kadoban: if you want to dig into proofy things, agda's the way to go for sure
15:31:58 <EvanR> Zekka|Sigfig: where "like" is "almost as good as" where the difference is the first classness
15:32:00 <roboguy`> kadoban: if you're looking for dependent typed stuff/theorem proving-type languages, Coq is also worth a look. I avoided it for a while because I thought the syntax looked clunky and antiquated, but I've taken a couple classes on it now and I'm enjoying it quite a bit
15:32:02 <hpc> kadoban: if you want to see DT in a mor programatic context, try idris instead
15:32:20 <kadoban> hpc: Yeah I like *kinda* looked at it briefly for a few days, but I didn't get deep at all. It seemed kind of cool and wacky, and definitely something I don't know, so that's always good.
15:32:20 <roboguy`> You can extract Coq code to Haskell code after you prove it too, which is nice
15:32:22 <hpc> kadoban: if you try agda and are still interested in proofs, move on to coq which is a different approach
15:32:25 <Zekka|Sigfig> EvanR: Yeah, you can make ruby box them into an object if you really want but itâ€™s kind of awkward imho
15:32:33 <cdtdev> I think the big thing about Scala is it's kinda sorta like Haskell and is supposed to have a lot of what makes Haskell great, but in the comfort of Java and OOP.
15:32:49 <hpc> yeah, coq will translate to haskell but i get the impression it's different enough that agda's a smoother entry
15:32:57 <EvanR> scala is missing a lot of things that are obvious after using haskell
15:33:01 <suppi> kadoban, http://radar.oreilly.com/2015/09/blocks-in-ruby.html
15:33:02 <Zekka|Sigfig> ruby has a lot of syntax dedicated to a usage I donâ€™t like, but it also supports a usage thatâ€™s the same
15:33:07 <kadoban> roboguy`: Hmm. Yeah I'm not really sure between like coq, agda, idris, acl2 :-/ I probably need to play with all of them more
15:33:17 <kadoban> suppi: Thanks.
15:33:19 <Zekka|Sigfig> I donâ€™t think taking stuff out of haskell is a bad idea, although I donâ€™t like the things they put in instead
15:33:21 <suppi> np
15:33:22 <cdtdev> EvanR: No doubt, but a Java programmer doesn't know that.
15:33:35 <roboguy`> hpc: it could just be me, but Coq went pretty smoothly. The basics are actually a lot like Haskell, even though the syntax is superficially different
15:34:05 <hpc> my opinion is taking things from haskell is... a risky idea
15:34:11 <Zekka|Sigfig> it would be nice if there was a language with haskell that had greatly reduced polymorphism support to make it easier for beginners
15:34:20 <roboguy`> The interactive tactic language Coq has is really cool too
15:34:20 <EvanR> taking things from = removing?
15:34:26 <EvanR> taking things from = copying?
15:34:28 <hpc> taking from = copying
15:34:34 <Zekka|Sigfig> I meant â€œremoving stuff from haskell"
15:34:38 <hpc> oh
15:34:58 <EvanR> Zekka|Sigfig: like C!
15:35:09 <EvanR> beginners do like reimplementing the linked list ;)
15:35:09 <suppi> Zekka|Sigfig, like elm?
15:35:11 <hpc> i like the things being added to haskell
15:35:15 <Zekka|Sigfig> suppi: way to take my hint!
15:35:21 <ski> kadoban : Twelf could also be interesting. it can be seen as a dependently typed logic programming language
15:35:22 <hpc> i am not sure what would be subtracted from it to make it better
15:35:26 <Zekka|Sigfig> EvanR: Hey, everyone should implement a linkedlist in C at least once
15:35:35 <suppi> problem that you grow out of it quickly :O
15:35:41 <Zekka|Sigfig> hpc: I donâ€™t have anything that would make it better for general use
15:35:43 <hpc> but i am also not terribly qualified to design a language ;)
15:35:44 <EvanR> or 100 times to gauge their own error pronenes
15:35:45 <kadoban> ski: Hmm, never heard of it. I'll look that up too
15:36:03 <dolio> EvanR: That doesn't seem to work.
15:36:10 <suppi> designing a language targeted towards beginners is also dangerous...
15:36:14 <hpc> there's a great core of features there in purity, non-strict semantics, and H-M
15:36:18 <ski> kadoban : obviously you should have done an ordinary logic programming language before
15:36:28 <suppi> it pretty much means that mostly beginners will use that language.
15:36:33 <ski> like Prolog, Mercury, Oz, ...
15:36:39 <hpc> PHP!
15:36:46 <hpc> (at suppi, not ski)
15:36:56 <kadoban> ski: I've done some prolog quite a while back that i kind of remember some of
15:36:58 <roboguy`> is it true that you can't directly write value-level things in Twelf and it's all type level?
15:37:05 <suppi> hpc, i don't know enough PHP to comment :P
15:37:16 <Zekka|Sigfig> suppi: People not using your language is not a failure imho
15:37:26 <EvanR> agreed
15:37:33 <suppi> depends on your goals
15:37:34 <EvanR> esolangs ftw
15:37:43 <Zekka|Sigfig> although I would be sad if I designed a language and *I* wouldnâ€™t use it
15:37:50 <Zekka|Sigfig> which would probably be the case if I took haskell and just started throwing out the features
15:37:56 <ski> roboguy` : have you seen any of the MLs ?
15:38:07 <blair1> Hey! Any emacs users here? And if so, does anyone know how to disable this "Visit-tags-table" message?
15:38:15 <EvanR> Zekka|Sigfig: which feature would you remove
15:38:18 <roboguy`> ski: not much of them. Coq is probably the closest I've come to using any of them, ha
15:38:28 <hpc> what is this ML you speak of ;)
15:38:33 <ski> Zekka|Sigfig : "it would be nice if there was a language with haskell that had greatly reduced polymorphism support to make it easier for beginners" -- Helium existed for a while
15:38:56 <suppi> I'd like to see how no typeclasses would work
15:38:59 <hpc> {-# LANGUAGE ExtraMonomorphismRestrictions #-}
15:39:00 <Zekka|Sigfig> EvanR: Probably hkt, maybe typeclasses.
15:39:08 <EvanR> HKT?
15:39:14 <hpc> higher-kinded types
15:39:16 <Zekka|Sigfig> higher-kinded types
15:39:17 <EvanR> oh taking a * -> * as an argument
15:39:24 <Zekka|Sigfig> yeah
15:39:25 <suppi> I'll never give kinds up.
15:39:34 <dolio> suppi: It's really annoying.
15:39:46 <suppi> dolio, not having them? agree.
15:39:50 <Zekka|Sigfig> maybe even make people get rid of polymorphism over types not in *
15:39:55 <dolio> Yeah.
15:40:03 <roboguy`> suppi: well, it can certainly *work*, but it might not always be the nicest. O'Caml has separate + and +. for integer and floating point, for instance
15:40:10 <Zekka|Sigfig> Those are all things I like to use but a lot of designs that involve them are hard to understand
15:40:31 <hpc> opposite direction: what if there was an alternate way to present highly polymorphic type signatures that didn't make them alphabet soup?
15:40:33 <EvanR> type classes are used for so many different things, just deleting them seems drastic
15:40:33 <suppi> roboguy`, i mean, not having typeclsses but having HKT
15:40:34 <Zekka|Sigfig> At this point though I might as well just throw out nonstrictness and say â€œOK use ML"
15:40:40 <ski> roboguy` : "is it true that you can't directly write value-level things in Twelf and it's all type level?" -- you can write terms, so no. however you want to pass them as arguments to relations/predicates, which are interpreted as type families in Twelf
15:40:44 <hpc> (not like lens polymorphic, but maybe mtl polymorphic)
15:40:57 <EvanR> like Int.+ Double.+ Complex.+ seems like a step backwards?
15:41:09 <Zekka|Sigfig> hpc: my feelings would be dependent on how that rendered most of the designs we currently use
15:41:23 <ski> roboguy` : but you don't evaluate expressions in Prolog either, you ask queries, and get solutions (like solutions for equations, or systems of equations)
15:41:25 <Zekka|Sigfig> thereâ€™s a pretty good chance Iâ€™d like the result
15:41:33 <EvanR> and strict everything is weird :(
15:41:37 <suppi> EvanR, or passing an env explicitly ;)
15:41:37 <kadoban> EvanR: It does. It seems like something else would have to be added to make that less tedious, and it's difficult for me to imagine what that would be.
15:42:07 <roboguy`> ski: hmm, interesting. I've wondered before if there is a connection between Prolog-style logic languages and dependently typed languages (and what it is, if there is one)
15:42:10 <ski> hpc : "what is this ML you speak of ;)" -- nowadays, SML, O'Caml, Alice ML .. and to some extent F#
15:42:55 <EvanR> suppi: math notation basically has this implicit envs everywhere, i wonder what it would look like if it was always made explicit
15:43:06 <hpc> ski: i was being silly - the joke was it's the last of the big three language families and yet it's still possible to take that question serisouly
15:43:18 <hpc> didn't know aobut alice ML though
15:43:22 <ski> suppi : no typeclasses in the MLs. however, no higher-order types either (except i think in Ur/Web)
15:43:35 <ski> hpc : Alice ML is related to Oz
15:43:37 <ski> @where CTM
15:43:37 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
15:43:40 * hpc considers haskell part of the ML family
15:43:46 <Zekka|Sigfig> I think I have to go in a bit! Iâ€™ll see you folks
15:43:51 <suppi> ski, i know. I'd be interested in one that has HKT but no typeclasses :)
15:44:15 <ski> suppi : well .. Mercury has type classes, but no higher-order types :)
15:44:30 <suppi> ski, :(
15:44:31 <dolio> roboguy`: Twelf is basically a prolog where the 'predicates' are replaced by terms in a type theory. And the proofs about the type theory terms involve prolog-like programming.
15:45:06 <dolio> But it's a very different take on what to do with type theory than normal.
15:45:31 <roboguy`> dolio: hmm, that's interesting. Do you know of any good resources for learning about Twelf? Last time I looked, a lot of the official webpages were bitrotted and 404-ed (or did something like 404ing)
15:45:42 <ski> roboguy` : in Twelf, defining a relation/predicate, and defining a type family is basically the same thing
15:46:14 <dolio> Nah, it's been a while since I looked at it.
15:46:23 <ski> EvanR : "math notation basically has this implicit envs everywhere" -- which kinds of situations are you thinking about ?
15:46:41 <roboguy`> I only have pretty limited knowledge of Prolog-style logic programming actually. It'd probably help if I had a little more experience there
15:47:11 <hpc> roboguy`: the best way i can describe it is pattern matching goes backwards
15:47:35 <hpc> it's really cool, and at the same time i can't imagine doing IO in it
15:47:41 <roboguy`> hpc: hmm, I thought it was bidirectional? Or is it just backwards (from, for instance, Haskell)
15:47:53 <EvanR> ski: notation is reused a lot, it doesnt mean any specific thing, but it has an implication for people familiar and the explicit meaning is given somewhere else, like the beginning (or its not and you have to infer it completely). an example is calculus notation, the integral of a formula dx
15:48:02 <hpc> someone wrote an irc bot in prolog and i think that's the closest to a real program i know of
15:48:20 <EvanR> integrals are used on many things, one of which is real functions of one real variable
15:48:33 <hpc> roboguy`: i mean in a broad sense of how it makes you think about writing a line of code
15:48:44 <roboguy`> ahh
15:48:47 <ski> roboguy` : fwiw, you may find "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09|10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> interesting
15:49:03 <EvanR> its also used for integrals along a curve in space
15:49:03 <hpc> so like, writing head
15:49:23 <hpc> you would write in a hypothetical looks-like-prolog haskell
15:49:33 <hpc> head [x|xs] = x
15:49:40 <roboguy`> ski: I'll have to take a look, thanks! Mercury is a statically-typed logic language, right?
15:50:09 <EvanR> the + sign could mean integer addition, real addition, addition modulo a number, or some additive group
15:50:12 <hpc> in prolog, you'd write something like head X [X|xs]
15:50:22 <hpc> prolog would solve for one argument being the same as the other
15:50:36 <hpc> the implication would flow backwards out of the function to the call site
15:50:45 <ski> EvanR : well, one of the things i was thinking you possibly had in mind is the idea of "dependent (and independant) variables" .. which is really basically the same as dynamic scope^Wextent (and implicit parameters in Haskell)
15:50:45 * geekosaur prototyped a business pricing algorithm in prolog in the 90s
15:50:46 <roboguy`> ahh, yeah. It's starting to come back to me a bit
15:50:48 <hpc> and suddenly head x [1, 2, 3] has x = 1
15:51:06 <geekosaur> until the customer had firmed down how they wanted all their pricing rules to interact (sigh)
15:51:08 <EvanR> ski: i wasnt thinking of variables, unless the notation involving variables is themselves variables
15:51:42 <hpc> instead of thinking of a transformation from what you have to what you need, you're writing invariants
15:52:30 <ski> EvanR : ok, so by "envs" i suppose you just mean that reading/parsing it depends much on contextual information, as opposed to specifically something input/environment/`Reader' -like
15:52:53 <EvanR> i was sort of thinking of it all together as if your program were transformed into a giant nested let
15:53:02 <ski> roboguy` : statically typed (and statically moded and determinism-checked) logic and functional programming language
15:53:06 <EvanR> and you defined notation and other stuff all the same way before you used it
15:53:35 <ski> (also, O'Keefe might be considered one of the old LP gurus)
15:53:41 <hpc> geekosaur: ooh, nice
15:53:45 <copumpkin> EvanR: rallymode
15:53:49 <hpc> that's well before my time
15:54:20 <EvanR> wrong channel copumpkin 
15:54:31 <copumpkin> it's never the wrong channel to tell you about rallymode
15:54:37 <EvanR> who i have not seen in a million years
15:54:43 <copumpkin> :)
15:55:19 <ski> roboguy`,hpc : yes, being able to (sometimes) run a predicate "backwards" (multi-modedness) is one of the really cool things in LP. instead of `(++)' and `stripPrefix', you have a single predicate append/3 (two lines of code), which can do both
15:55:28 <EvanR> ski: the kind of "env" youd be passing to do typeclasses without typeclasses, is what the context was
15:55:34 <EvanR> i.e. dictionary
15:55:39 <ski> EvanR : ok
15:55:43 <Lokathor> time to micro-optimize code to make it ~even faster~
15:56:42 <ski> hpc : i recall hearing in ##prolog one person who used Prolog to decide which services to bring up, when restarting a server machine, and when starting/restarting/stopping individual services (which may depend on others)
15:56:56 <ski> (and by "hearing", i mean i talked to the person in question)
16:26:26 <sbuilder> Hi
16:27:29 <hackrilege> hi
16:27:59 <sbuilder> how r u
16:28:10 <hackrilege> good thanks
16:28:41 <hackrilege> time for Haskell
16:52:43 <Lokathor> http://lpaste.net/161254 can someone please explain... what happeneD?
16:53:38 <Lokathor> the module that caused it: http://lpaste.net/161255
17:12:04 <dedgrant> In "Strongly Typed Heterogeneous Collections", what is the mening of '1-ambiguity property' referred to the first page bottom left? http://okmij.org/ftp/Haskell/HList-ext.pdf
17:12:31 <roboguy`> Lokathor: that compiles ok for me on 7.10.3, if I put in some dummy definitions. What are Control.RNG and Data.Location and how are you running ghc?
17:13:09 <Lokathor> roboguy`, i'm running GHC via stack
17:13:20 <johnw> dedgrant: that exact question was asked in this channel in 2004
17:13:29 <dedgrant> hah
17:13:47 <Lokathor> roboguy`, the full repo is here, https://github.com/Lokathor/ludolib, except with the newer version of AutomataGen.hs in the lpaste
17:14:55 <Lokathor> Data.Location is just the newtype Location = Location (Int,Int), basically. and Control.RNG is just being used for a MonadRandom thing that has a 40% chance of giving true to initialize each cell
17:15:39 <johnw> dedgrant: it is fully defined in this paper: http://dl.acm.org/citation.cfm?id=1065204&dl=ACM&coll=DL&CFID=604810336&CFTOKEN=13927380
17:16:58 <ski> dedgrant : you should probably ask someone who knows XML
17:17:00 <johnw> dedgrant: oh, actually not, it omits the definition
17:17:04 <dedgrant> johnw: Thank you kindly for the recollection
17:17:08 <dedgrant> ah
17:17:43 <dedgrant> aside, is there an irc channel archive that goes back far enough? ;)
17:18:26 <roboguy`> dedgrant: the archive comes up if you google "1-ambiguity property"
17:18:33 <Lokathor> roboguy`, also, the program works in ghci, so i'm pretty sure the crash is related to trying -O2 with it
17:19:22 <johnw> dedgrant: try www.cs.uku.fi/tutkimus/publications/reports/A-2006-2.pdf
17:19:32 <johnw> "One-Unambiguity of Regular Expressions with Numeric Occurrence Indicators"
17:19:33 <Lokathor> setting a factor of 1000 seems to still not be enough. setting the factor to be 10000 seems to make it hang forever
17:19:47 <dedgrant> roboguy`: OK found the log thanks
17:20:13 <ski> dedgrant, yes
17:20:22 <johnw> "That is, an expression is 1-ambiguous iff there is some input word such that after matching its prefix against a sequence of positions u, the next input symbol could be matched by two different occurrences x and y of that sym- bol."
17:20:29 <dedgrant> johnw: lovely!
17:20:56 <Lokathor> oh, GHC is still doing... something.... with 11GB of my RAM
17:21:29 <ski> johnw : is there any example provided ?
17:22:23 <johnw> ski: "The expression E1 = a1?a2 is ambiguous, since an initial symbol a of an input word could be matched either by position a1 or a2. The equivalent expression E2 = (a1)1..2, on the other hand, is trivially unambiguous, since it contains only a single position."
17:22:56 <johnw> where the 1 and 2 are subscripts, and the 1..2 is a superscript
17:24:14 <ski> i wonder what those subscripts mean
17:24:24 <johnw> I think reading the paper will clarify
17:24:30 <johnw> it has a lot of material
17:24:50 <dedgrant> Yeah it looks like this needs a top to bottom read.
17:25:10 <dedgrant> Fantastic resource though tx
17:25:14 <roboguy`> Lokathor: huh, it seems to compile ok with HERMIT without any changes
17:25:28 <Lokathor> what is HERMIT?
17:25:28 <roboguy`> but I am getting that panic if I just run GHC with -O2
17:25:56 <roboguy`> It is a GHC plugin for proving theorems about Haskell programs and applying program transformations to Haskell programs
17:26:08 <Lokathor> whee, so i've stumbled upon a -O2 bug it seems
17:26:29 <dedgrant> ski: subscripts just explicate the symbol positions
17:26:48 <roboguy`> Lokathor: looks that way. I wonder why it would work with HERMIT with no changes... hmm
17:27:15 <montanonic> Why does Data.Aeson.encode use Data.ByteString.Lazy.Internal.ByteString, which makes it so that I have to import the latter module everywhere, to hide the default ByteString datatype, and just deal with a general headache. Is there any way to ease this? I'm sure that it uses the internal type for a good reason, it's just a headache to interop it with other ByteString functions which use the higher-level ByteString type.
17:27:47 <Lokathor> one ticket I glanced at when i looked up the fsimpl thing was that GHC ranks unboxed values at two differnet rates when it's evaluating a simplification
17:27:53 <Lokathor> and the mismatch causes problems?
17:27:57 <ski> dedgrant : just for being able to talk about the occurrences in the surrounding text ? or is it part of the (extended) regexen formalism ?
17:28:00 <Lokathor> but that was a 7.4 bug, and it was marked fixed
17:28:18 <roboguy`> Lokathor: oh, if you add -fsimple-list-literals, it works
17:28:28 <roboguy`> that is a flag the HERMIT REPL adds automatically
17:29:20 <montanonic> Lokathor: yeah the mismatch leads to type errors that will take me a while to figure out how to fix
17:29:39 <Lokathor> holy shit though
17:29:55 <montanonic> http://haddock.stackage.org/lts-5.13/http-conduit-2.1.10/Network-HTTP-Simple.html#t:Request uses the higher level bytestring type; as far as my code is telling me, they are not the same
17:29:55 <Lokathor> even with -fsimple-list-literals, a 2s time drops to 315ms
17:29:58 <Lokathor> that's a goooood gain
17:30:37 <montanonic> Lokathor: what are those? link to doc?
17:30:48 <Lokathor> what are whats?
17:30:52 <montanonic> list-literals
17:31:07 <Lokathor> i've no idea, roboguy` just told me to put it in, and it compiles now
17:31:24 <roboguy`> I have no idea what it does either, ha
17:31:59 <roboguy`> well, I mean list literals are surely things like [1,2,3]
17:32:05 <roboguy`> but I'm not sure what the flag does
17:32:48 <dedgrant> ski: good q :)
17:35:37 <roboguy`> complete speculation, but it *might* have something to do with preventing list literals from being turned into cons chains, which stops some simplifications from being done
17:39:44 <tippenein> what's the fastest way to find if a Text contains a substring? attoparsec? isInfixOf?
17:40:36 <montanonic> alright, figured it out: liberal usage of toStrict and fromStrict. That's how you type coerce between the different bytestrings, as the Internal representation isn't actually why the types aren't matching, it's that it's referring to the lazy/strict version when the other is required by the function.
17:42:07 <Lokathor> tippenein, I'd imagine isInfixOf is reasonably speeded? Are you looking for a basic pattern or like a regex or what?
17:43:19 <Lokathor> montanonic, those Lazy and Strict differences kill me every time
17:43:40 <tippenein> looking for "knicks" within a tweet. I might be off base though, because this is within a Stream (using Pipes)
17:44:44 <Lokathor> knicks? I'm not familiar with the term
17:44:52 <dedgrant> ski: I think 'a1?a2' is describing a regular expression with zero or one occurence of 'a' followed by exactly one occurrence of 'a'.
17:44:57 <Lokathor> or like, that's the actual string you want?
17:45:27 <dedgrant> ski: So does the first 'a' encountered match position 'a1' or 'a2'?
17:47:21 <toph_> can anyone give a hint how to break out of an evalStateT loop?
17:53:45 <slack1256> Quick question. Are Folds in lenses just multi-target getter that after being gotten are mappend under some monoid? 
17:53:46 <tippenein> Lokathor: that's the actual string I want. Working on a haskell implementation of this map reduce
17:53:49 <tippenein> https://github.com/dimroc/etl-language-comparison/
17:54:12 <Lokathor> oh hmm
17:54:31 <roboguy`> toph_: what do you mean?
17:54:42 <Lokathor> tippenein, you should probably implement both forms, and then benchmark
17:55:02 <shachaf> slack1256: Yes.
17:55:27 <tippenein> yeah, I'm pretty fuzzy on how this will be compiled anyway. I've been needing an excuse to try criterion anyway
17:55:47 <shachaf> slack1256: Well, the mappend doesn't happen because of the Fold. A Fold is just a multi-target Getter.
17:56:03 <shachaf> But if you use "view" it'll fold the targets.
17:57:18 <slack1256> Mmm so if I treat it merely as a Getter (with view) it will `mappend` the result. But with Fold specefic funcions (folded) it will return the list of targets?
17:58:13 <shachaf> It'll do whatever the function does.
17:58:23 <shachaf> If you use sumOf then it'll give you the sum.
17:58:29 <shachaf> If you use toListOf then you get a list of targets.
17:58:35 <shachaf> It's up to you.
18:00:50 <slack1256> Got it
18:01:02 <slack1256> still need something like emacs re-builder for lenses
18:01:11 <slack1256> but I am getting the hang of it
18:01:45 <toph_> roboguy`: http://lpaste.net/161262
18:02:31 <roboguy`> toph_: what if, instead of using forever, you use explicit recursion and terminate it when your condition holds?
18:03:28 <slack1256> or use ExcepT and scape the forever
18:03:36 <toph_> robotuy`: ah yeah, i will try that :)
18:03:55 <roboguy`> toph_: yeah, using ExceptT or MaybeT like slack1256 suggests would probably be more efficient
18:04:03 <roboguy`> forever can make things more efficient than explicit recursion
18:04:19 <toph_> i thought something like that...but not sure how the types would connect
18:05:26 <MichaelBurge> What does it mean when you're using a module that uses Template Haskell, and you get an 'undefined reference to ***_functionName_closure' error?
18:05:38 <Lokathor> forever uses an explicit sharing loopy thing to help prevent memory leaks
18:06:20 <Zemyla> @src forever
18:06:20 <lambdabot> forever a = let a' = a >> a' in a'
18:06:33 <MichaelBurge> Nevermind, it's when you forget to list the module in Cabal, which are needed by the TH module.
18:06:48 <roboguy`> @unmtl StateT MyState (MaybeT IO) ()
18:06:48 <lambdabot> MyState -> IO (Maybe ((), MyState))
18:06:58 <roboguy`> mm, that doesn't look quite like what you'd want
18:07:05 <Lokathor> @mtl MyState -> IO (Maybe ((), MyState))
18:07:05 <lambdabot> Maybe you meant: url unmtl pl msg
18:07:09 <Lokathor> :(
18:07:29 <roboguy`> @unmtl MaybeT (StateT MyState IO ())
18:07:29 <lambdabot> Plugin `unmtl' failed with: `MaybeT (MyState -> IO ((), MyState))' is not applied to enough arguments.
18:07:37 <roboguy`> @unmtl MaybeT (StateT MyState IO) ()
18:07:37 <lambdabot> MyState -> IO (Maybe (), MyState)
18:08:32 <roboguy`> Something that wraps the opposite of MaybeT is probably what you'd want
18:08:41 <roboguy`> @unmtl MaybeT m a
18:08:41 <lambdabot> m (Maybe a)
18:15:58 <roboguy`> toph_: to get you started though, the most straightforward thing would probably be explicit recursion
18:16:30 <toph_> yeah i'm going to do that, then maybe work on a stripped down example with maybe or exceptions
18:16:38 <toph_> thanks for the help
18:22:36 <EvanR> toph_: you might find an appropriate loop in monad-loops but these are so simple i think a lot of people just put the two lines of haskell for one somewhere
18:44:11 <hackrilege> :t \ f -> catMaybes . iterate (>>= f) . Just
18:44:12 <lambdabot> (a -> Maybe a) -> a -> [a]
18:44:18 <hackrilege> this does not terminate
18:44:28 <hackrilege> how can i fix it!?
18:45:02 <EvanR> :t scanl
18:45:03 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
18:45:09 <hackrilege> oh i want takeWhile oops
18:45:12 <EvanR> hmm
18:45:41 <hackrilege> no?
18:46:54 <EvanR> it doesnt terminate when you do what
18:47:08 <hackrilege> pardon?
18:47:13 <hackrilege> oh
18:47:17 <hackrilege> when you use it
18:47:18 <EvanR> you apply it to what
18:47:38 <hackrilege> something that will return Nothing at some point
18:48:04 <hackrilege> then the >>= cant inject the function, from that point its just repeat Nothing
18:49:12 <EvanR> you want it to produce something at all, or a finite list
18:49:41 <hackrilege> all successful applications of fmap f to itself
18:49:50 <hackrilege> if that makes sense
18:50:41 <hackrilege> >>= applies join afterward to turn the Just Nothing -> Nothing , Just Just -> Just
18:51:59 <hackrilege> hi EvanR dows that make sense??
18:52:03 <hackrilege> does*
18:52:33 <EvanR> yeah
18:53:02 <maerwald> > join (+) 4
18:53:04 <lambdabot>  8
18:53:24 <hackrilege> i cant think how to do it without a recursive definition, i cant reuse iterate, and i have to do some funky termination checking
18:53:40 <hackrilege> :t \ f -> catMaybes . iterate (>>= f) . Just
18:53:41 <lambdabot> (a -> Maybe a) -> a -> [a]
18:53:45 <hackrilege> just seems so neat
18:53:50 <hackrilege> shame it does not wor!
18:53:52 <hackrilege> work!
18:53:53 <EvanR> what is the type of f
18:54:06 <EvanR> a -> Maybe a
18:54:11 <hackrilege> yeah
18:54:51 <hackrilege> takeWhile isJust in place of catMatbes should work i guess
18:54:59 <EvanR> i was just about to do that ;)
18:55:33 <hackrilege> i think its the only solution, just a shame i cant extract the justs in the same pass
18:55:47 <EvanR> this is where a custom recursor would be good
18:56:09 <hackrilege> its just nt less short that the recursive definition
18:56:12 <hackrilege> oh well
18:56:21 <EvanR> not less short?
18:56:23 <dwynwen_ddlleyw> Is lisp as functional as haskell?
18:56:32 <hackrilege> yes, not less short
18:56:47 <EvanR> negation stack overflow
18:57:21 <hackrilege> more longer
18:57:36 <EvanR> hackrilege: i just watched a video on elixir, we are already so much shorter and faster than so much else out there, a 2-3 line function for this is not that bad ;)
18:58:26 <hackrilege> all my other functions are strictly infix containing a single .
18:58:57 <hackrilege> :D
18:59:05 <EvanR> ehm, you only wrote using SKI combinators or
18:59:50 <hackrilege> i dont know what that is
19:00:10 <EvanR> you probably used some function that had to be defined with "baroque" case analysis ;)
19:00:12 <dwynwen_ddlleyw> Or is functionality not something that can be compared?
19:00:30 <EvanR> lisp is the epitome of untyped dynamic programming
19:00:57 <hackrilege> ew
19:00:58 <EvanR> haskell can do that ;)
19:01:05 <roboguy`> dwynwen_ddlleyw: well, lisp is a family of languages
19:01:31 <EvanR> data S a = Atom a | S [S a]
19:01:31 <dwynwen_ddlleyw> Oh, right 
19:01:46 <dwynwen_ddlleyw> Um... how about common lisp?
19:01:55 <EvanR> a = AllYouDataTypesDumpedIntoOneSumTypeUniverse
19:02:13 <hackrilege> again, ew
19:02:15 <EvanR> lo
19:02:42 <hackrilege> mmm dim sum
19:02:58 <EvanR> you have it?
19:04:13 <EvanR> you dont often see people calling common lisp a functional language today
19:04:32 <EvanR> i dont know what that means because i dont know what functional language means
19:04:33 <hackrilege> oh hey check out my new paste
19:04:34 <hackrilege> http://lpaste.net/161264
19:04:59 <hackrilege> i think functional comes from lamda calculus
19:05:16 <hackrilege> and functional equivilance
19:05:37 <EvanR> the extent to which lambda calculus has to do with "functions" is murky to me
19:05:38 <hackrilege> and strict typing
19:05:58 <hackrilege> lambda calculus uses the notion of symbolic function application
19:06:14 <EvanR> it has the notion of substitution in a binding tree
19:06:28 <dolio> Lambda calculus is obviously for talking about logic, not functions.
19:06:43 <hackrilege> ah ok
19:06:56 <hackrilege> anyhow, in the paste, im presenting a nasty non comonad
19:07:00 <hackrilege> can you comment?
19:07:06 <hackrilege> its a kind of nightmare
19:07:19 <dwynwen_ddlleyw> Okay so how would one define a functional language?
19:07:42 <hackrilege> one that gets up in the morning and keeps on going regardless
19:08:10 <roboguy`> that's a question that's pretty open to discussion and debate. Not too clear cut
19:08:38 <hackrilege> i already said where i think people draw the analogy, thats as best as i could trace it
19:09:02 <roboguy`> I think most people would agree that there should be first-class functions though
19:09:20 <hackrilege> functions map between sets, haskell functions between types, representing sets of values of those types
19:09:32 <EvanR> no ;_;
19:09:42 <hackrilege> whatever, something like that
19:10:17 <hackrilege> the prof draws two blobs on the board and a big arrow between them with one labled C and the other D and starts talking about surjections
19:10:41 <hackrilege> -> functional language
19:10:43 <EvanR> yeah which is a tough one to reconcile with FP programming
19:11:00 <EvanR> at least when the types or the sets or both get crazy
19:11:00 <hackrilege> i just tried and my head hurt lol
19:11:15 <hackrilege> cant construct infinite type...
19:11:29 <EvanR> GHC: can't or won't
19:11:38 <EvanR> <GHC > FFFFUUUUUUUU
19:11:45 <hackrilege> lol
19:11:54 <hackrilege> did you see my kind error?
19:12:09 <EvanR> i need to order dim sum before they close
19:12:18 <hackrilege> well the paste compiles, but my comonad looks messed up
19:12:29 <hackrilege> http://lpaste.net/161264
19:13:04 <dwynwen_ddlleyw> What is a monad
19:14:59 <roboguy`> I believe it is best to learn what a monad is by examples. There are quite a few Haskell monads
19:15:16 <roboguy`> The list type, for instance
19:15:26 <hackrilege> some people find it best to think of them as burritos
19:15:50 <roboguy`> Of course, the best route to learning about monads in my opinion, is to first learn about functors
19:16:03 <dwynwen_ddlleyw> How would one condense what a monad is into the simplest terms possible 
19:16:03 <roboguy`> (again, by examples)
19:16:06 <EvanR> were 1 for 1, 1 good answer, 1 burrito answer
19:16:12 <hackrilege> well thats how you learn about Functors
19:16:23 <thimoteus> that's how i learned about burritos, actually
19:16:31 <EvanR> dwynwen_ddlleyw: by listing the Functor class and the Monad class and the relevant laws
19:16:41 <EvanR> which probably wont help
19:16:51 <hackrilege> burritos are winning
19:17:35 <roboguy`> dwynwen_ddlleyw: any way to write about it in the "simplest terms possible" will probably do very little to help you understand what it is, unfortunately. I would highly suggest learning by example
19:18:00 <EvanR> @where faq
19:18:00 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:18:11 <EvanR> hmm. there was a good haskell faq which included the monad question
19:18:13 <roboguy`> dwynwen_ddlleyw: you're probably already familiar with the list monad, actually, without knowing it!
19:18:14 <dwynwen_ddlleyw> "In layman's terms, a monad is just a type for which the >>= operation is defined."
19:18:16 <EvanR> on github, forgot where it is
19:18:42 <EvanR> dwynwen_ddlleyw: thats not laymans terms, thats the java programmers terms
19:18:49 <EvanR> you cant just define >>= and it be a monad
19:19:00 <roboguy`> dwynwen_ddlleyw: There are two functions that a Monad must have: return and (>>=). For lists, "return x = [x]" and "xs >>= f  = concatMap f xs"
19:19:05 <EvanR> why because it has to be well typed and follow laws
19:19:12 <hackrilege> a monad is an applicative functor with a constructor which is the identity of a function returning a monad from a monad of monads
19:19:18 <dwynwen_ddlleyw> It's good enough for me tbh
19:19:25 <EvanR> well there you go then
19:20:09 <dwynwen_ddlleyw> You use the word "functor" as if I know what that means :P
19:20:23 <EvanR> to understand monads you must first understand functors, so that should be your next question!
19:20:32 <thimoteus> well, you did ask for the simplest terms possible
19:20:45 <EvanR> luckily functors are much simpler
19:20:56 <hackrilege> a functor is a datatype which takes one parameter with a function fmap defined to alter the contents such that fmap id = id
19:21:22 <roboguy`> A list is also an example of a functor (it has to be, since it is a monad)
19:21:26 <ntnt> what is the free monad + interpreter pattern, and how do I learn it?
19:21:29 <EvanR> though altering the contents may not applicable
19:21:44 <dwynwen_ddlleyw> hackrilege: went right over my head 
19:21:46 <hackrilege> then what would fmap do?
19:22:14 <dwynwen_ddlleyw> All I got is a functor is a type class with a parameter and a type is just an instance of that functor 
19:22:28 <EvanR> not all datatypes have contents
19:22:37 <EvanR> like A -> B
19:23:02 <hackrilege> a datatype such as (D a) is a Functor once fmap :: (a->b)->D a->D b is defined s.t. fmap id = id
19:23:24 <dwynwen_ddlleyw> No idea what that is supposed to mean either 
19:23:28 <hackrilege> !?
19:23:34 <dwynwen_ddlleyw> Though I assume it has to do with mathy stuff
19:23:46 <hackrilege> mathy stuff!?
19:23:47 <EvanR> fmap id = id is interesting but really missing the point that fmap f . fmap g = fmap (f . g)
19:23:55 <MichaelBurge> Is HaXml still the recommended XML library for Haskell?
19:24:01 <dwynwen_ddlleyw> You're giving the little type signatures which I don't know how to read >.<
19:24:10 <hackrilege> use the force
19:24:11 <EvanR> > fmap (+1) [1,2,3]
19:24:12 <lambdabot>  [2,3,4]
19:24:22 <EvanR> > fmap (+1) (Just 3)
19:24:24 <lambdabot>  Just 4
19:24:44 <EvanR> > fmap even (Just 3)
19:24:45 <lambdabot>  Just False
19:26:01 <hackrilege> :t let fmap' f = fmap (fmap' f) in fmap'
19:26:02 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ f1 a1
19:26:03 <lambdabot>     Expected type: a1 -> b1
19:26:03 <lambdabot>       Actual type: f1 a1 -> f1 b1
19:26:07 <hackrilege> doh
19:31:40 * hackagebot servant-csharp 0.0.4.0 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.4.0 (KatsutoshiItoh)
19:31:48 <et09> https://gist.github.com/anonymous/bc8c8bfd3c526205af0259d5a99014bc having this problem
19:31:51 <et09> trying to install hmp3
19:31:59 <hackrilege> oh its unix
19:32:03 <et09> first cabal package since update ubuntu 15.04 -> 16.04
19:32:05 <ntnt> for every functor f, is (Free f) a monad ?
19:32:07 <roboguy`> dwynwen_ddlleyw: does it sort of make sense how fmap is apply the function "inside" its argument (so to speak)?
19:32:11 <ntnt> so I define a Functor, and Free gives me a Monad ?
19:32:40 <roboguy`> ntnt: yep!
19:32:52 <ntnt> roboguy`: woot! starting to get free monads
19:33:11 <roboguy`> ntnt: 'Free f' is the "free monad" for the functor f
19:33:39 <hackrilege> but all join does is strip off the constructor Roll
19:33:48 <hackrilege> and all return does is add one
19:33:54 <hackrilege> so its completely useless
19:34:28 <EvanR> the point is to add your own extra operations to deal with the Rolls
19:34:40 <hackrilege> how do you mean?
19:35:04 <EvanR> because the monadic program is reified, you can do what you want with it, you arent limited to what the monad class for this monad says to do with the joins
19:35:17 <hackrilege> as in "each time you strip off a Roll, you get an oppertunity to do something?"
19:35:25 <EvanR> its kind of like changing Ord a => into (a -> a -> Ordering) -> 
19:35:41 <hackrilege> what!!?
19:35:48 <hackrilege> is that  reader Monad or soemmthing?
19:36:07 <EvanR> that has nothing to do with monads, just another way to get more flexibility by dropping the type class
19:36:10 <hackrilege> (it has a ->)
19:36:52 <EvanR> its really like using list of a instead of the Monoid a constraint
19:37:08 <hackrilege> a useless constraint
19:37:14 <roboguy`> hackrilege: One example is if you define "data Pair a = Pair a a", then "Free Pair" is a binary tree
19:37:16 <hackrilege> MonadPlus
19:37:22 <EvanR> Writer does ok with it
19:37:41 <hackrilege> roboguy, but obviously that has a different Monad difinition that the Free one?
19:38:04 <hackrilege> and i thought these things were supposed to be unique!
19:38:13 <roboguy`> hackrilege: are you sure?
19:38:50 <roboguy`> because it does have the same definition (in the sense that it does the same thing)
19:38:54 <hackrilege> i contradicted myself, i dont know how you got the impression i was sure!
19:40:03 <roboguy`> hackrilege: there's a good blog post on how to use Free monads to make embedded DSLs here http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
19:40:26 <hackrilege> anyway, if Monad f => Free f then since Monad has join, its redundant, the monad alone knows how to deal with free
19:40:30 <roboguy`> it's pretty handy because the monad instance (literally) writes itself
19:40:37 <hackrilege> roboguy that post SUCKS
19:40:42 <roboguy`> ha, how so?
19:40:48 <hackrilege> im totally done with that post
19:40:52 <hackrilege> what is a dsl?
19:40:57 <roboguy`> "domain specific language"
19:41:00 <hackrilege> why are all examples stupid?
19:41:05 <roboguy`> welp
19:41:33 <hackrilege> i dont want to have T WRITE A LANGUAGE to understand how to use what is as simple as me falling asleep on the f key
19:41:56 <hackrilege> seriously though
19:42:01 <hackrilege> this is the burritos thing
19:42:20 <roboguy`> I mean, it's an example of how that is useful. Which is generally a good way to understand things
19:42:31 <hackrilege> when a simple definition exists, why start crazy discussions about parsing servers or whatever
19:43:10 <hackrilege> no, it requires understanding something more complex that the thing its trying to teach you to use...
19:43:34 <roboguy`> hackrilege: he just makes an embedded "language" that can either ring a bell, print a "b" to the console or terminate. There is not even any parsing involved because it is embedded
19:43:41 <roboguy`> that doesn't seem very complex...
19:44:01 <hackrilege> yeah but those are all words and its not easy for everyone to read these words
19:44:39 <hackrilege> which is why the Monad class definition allong with the laws will always be the best description of what Monads are
19:44:40 <roboguy`> alright
19:45:41 <hackrilege> the burrito thing is poking fun at people who use complex examples to fail to simplify a daunting concept
19:46:11 <dolio> Those are likely non-factors for a lot of people. "Domain specific language" and "embedded domain specific language" have been hot terms among programmers (not just Haskell programmers) for years now.
19:46:15 <hackrilege> nayway, i get yelled at for spam, so i go now and do many great things with zippers
19:46:23 <roboguy`> this is not a complex example and it seems that the definition of a Free monad has not helped you understand what it is...
19:46:47 <roboguy`> so I would argue in favor of a different way to go about learning about it
19:47:19 <hackrilege> i quite like the Mu Nu thing at the end of the evolution of the haskell programmer
19:47:23 <hackrilege> personally
19:47:57 <hackrilege> arguably not the most accessible rout...
19:48:02 <hackrilege> g2g
19:48:18 <roboguy`> well... ok
19:56:47 <ntnt> where can i read about implementatino of free monad
19:56:54 <ntnt> that would explain to me what free monad does
19:58:01 <roboguy`> ntnt: well, the implementation is in the source code of the package, but I doubt that would explain what it does very well
19:59:29 <c_wraith> Heck, the implementation is like data Free f a = Pure a | Free (f (Free f a))
20:00:00 <roboguy`> ntnt: There is an example of a use in the link I posted earlier, which might help you understand it more than the implementation itself would: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
20:00:46 <dwynwen_ddlleyw> I've always wanted to learn a language where I can build complex things easily such as in haskell for data processing 
20:00:51 <dwynwen_ddlleyw> But I never have data to process
20:00:56 <ntnt> roboguy`: ha! I'm reading http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html by the same guy
20:00:58 <dwynwen_ddlleyw> So I always put it off
20:01:09 <EvanR> you could do something else with haskell
20:01:17 <EvanR> like video games or graphical user interfaces!
20:01:32 <dwynwen_ddlleyw> It's easier to shoot myself though 
20:01:41 <dwynwen_ddlleyw> Or use a different language suited to it
20:01:47 <EvanR> is it your policy to do what is easiest
20:01:57 <roboguy`> dwynwen_ddlleyw: there are websites that collect large amounts of statistics about a wide variety of things, if that is the sort of data you're looking for
20:02:04 <dwynwen_ddlleyw> It's my policy to do what's convinient 
20:02:42 <roboguy`> dwynwen_ddlleyw: You could also do something like analyze a bunch of tweets
20:03:09 <EvanR> sometimes convenience is just around the corner
20:03:17 <EvanR> sorry eating chinese
20:03:49 <dwynwen_ddlleyw> Here's the thing though, I am not very smart if you could not tell >.<
20:04:36 <dwynwen_ddlleyw> So I can't really see why I would analyze tweets
20:06:09 <EvanR> someone of the smartest people in the world are analyzing tweets for some reason
20:06:22 <EvanR> maybe they are on to something
20:07:27 <dwynwen_ddlleyw> One of the things that I can't get my head wrapped around is abstract stuff
20:07:46 <roboguy`> They can (attempt) to do things like determine what emotion someone is expressing in a tweet
20:08:06 <Lokathor> so, i can put a TVar in my MonadReader context and things will all work right when it gets updated?
20:08:28 <EvanR> the value is the reference to the TVar
20:08:36 <EvanR> so that stays the same
20:08:52 <EvanR> when you do IO to check it, you will get updates 
20:08:54 <roboguy`> They can also look at a large number twitter users in a certain area and try to determine the general "feeling" to figure out things like what sort of things are popular and maybe even help determine what sort of investments are most likely to be beneficial
20:09:01 <Lokathor> okay cool
20:09:17 <Lokathor> actually i want to write to it mostly
20:09:34 <EvanR> or when you do IO to modify it, the reference is still the same
20:09:37 <Lokathor> and then another thread checks it every 5 minutes, and if it hasn't been updated in more than 5 minutes it assumes that it needs to restart the child
20:09:49 <roboguy`> some pretty interesting machine learning problems in that space, imo. I don't know a lot about the details of machine learning though
20:09:50 <EvanR> like a dead mans switch
20:10:06 <Lokathor> yeah because IRC connections are gabrage
20:10:16 <Lokathor> :P
20:11:08 <EvanR> its funny i can stay connected on ssh even if i move from one wireless to another
20:11:23 <EvanR> it must be a miracle
20:11:52 <Lokathor> my bot has gotten disconnected twice in the past few days :(
20:12:23 <Lokathor> so this might save me, http://lpaste.net/161265
20:13:34 <EvanR> another way is to use an MVar (), you say "I'm still alive by putting the () in there" then the switch does tryTake and either sleeps or aborts
20:13:43 <EvanR> or whatever the dead man action is
20:13:59 <EvanR> er, move the " back a few words
20:14:28 <Lokathor> hmm
20:14:34 <EvanR> i wonder if there is a good abstraction for this
20:14:46 <Lokathor> well there's already other TVar floating around, so I'll stick to all TVar for now I think
20:15:11 <Lokathor> data.time.clock has a handy func to diff the times already, so it's alright
20:16:08 <Lokathor> EvanR, there is a good abstraction for this... sorta... but it's in erlang not in haskell >_>
20:16:16 <Lokathor> but i'm copying their style and I think it'll be cool
20:16:40 <EvanR> wouldnt it be better to get a notification that the connection died
20:17:06 <Lokathor> sometimes the connection dies and reports that it's died. sometimes it dies but does NOT report that it's dead
20:17:24 <EvanR> gah
20:31:20 <Lokathor> http://lpaste.net/161267 i think this will do what i want
20:41:45 <Lokathor> well, now we'll find out if it works i guess
20:42:08 <EvanR> if it compiles its good / perfect
20:42:29 <Lokathor> assuming that i put my arguments in the right order and such :P
20:42:37 <Lokathor> I'll know in 2 minutes when the first test happens
20:42:50 * EvanR puts on sunglasses
20:44:33 <athan> Ever have one of those divergent days where you force yourself to build GHC 8 just to have -XInjectiveTypeFamilies?
20:44:58 <Lokathor> i'm lucky when GHC builds my code at all, much less when i start using weird extensions
20:46:18 <athan> Lokathor: It's singletons for me
20:46:25 <athan> for some reason, :++ is causing ambiguity
20:46:36 <Lokathor> kill
20:46:38 <Lokathor> whoops
20:46:51 <Lokathor> wrong terminal
20:48:10 <athan> if I could instead rewrite it to give injectivity constraints, I think it will solve correctly
20:49:20 <EvanR> i hope youre right
20:49:21 <Lokathor> okay, so.... threadDelay doesn't seem to be doing what it says it should do
20:49:33 <geekosaur> make sure you have the units right
20:49:39 <EvanR> threadDelay will be very granular if you dont use -threaded
20:49:42 <geekosaur> everyone assumes it's in milliseconds
20:49:45 <geekosaur> it's microseconds
20:49:52 <Lokathor> fiveMinInMicroseconds = 1000 * 60 * 5 ?
20:50:05 <Lokathor> oh, i need more zeroes?
20:50:16 <geekosaur> 1 second is 1000000
20:50:37 <geekosaur> yoiu computed milliseconds
20:51:42 <geekosaur> even lambdabot has had that bug :)
20:52:19 <geekosaur> (I wasn't kidding when I said "everyone". even the folks who've been using Haskell for years trip over it)
20:52:28 <pharaun> arugh
20:52:39 <Lokathor> #Last Delay: 21.0831s
20:52:42 <pharaun> yeah that bit drives me nuts :)
20:52:42 <Lokathor> aces
20:52:54 <EvanR> haskell is ill-unitted
20:53:32 <EvanR> needs provably correct numeric literals
20:53:45 <Lokathor> so i was reading up on intro rust stuff, and they have a newtype mechanic, and the very first suggestion they had for it was to make sure that you always get your units right
20:54:10 <Lokathor> and about 1 second later i was like, "damn why doesn't haskell base have that"
20:56:50 <EvanR> ability to write a library for it is fine
20:57:29 <athan> must... finish... writing... my LANGUAGE pragma...
20:57:32 <Lokathor> but if it's not in base, then base won't tag their time units using said newtypes
20:57:51 <EvanR> ok yeah threadDelay would take Microseconds
20:58:01 <EvanR> and then you type the numeric literal in wrong anyway ;)
20:58:52 <Lokathor> but I'd write it, toMicroseconds (Minutes 5)
20:59:23 <EvanR> that library would be pretty cool nontheless, and i think there is one
20:59:25 <athan> Anyone here know of a nice size-indexed vector/array/list?
20:59:37 <athan> like `Vector (n::Nat) a`
21:04:05 <ski> dedgrant : "So does the first 'a' encountered match position 'a1' or 'a2'?" -- depends on whether the next character (if any) is `a' or something else
21:04:08 <ski> @tell hackrilege unfortunately, "a function returning a monad from a monad of monads" in "a monad is an applicative functor with a constructor which is the identity of a function returning a monad from a monad of monads" is nonsense. monads aren't values that can be returned by functions. a value of type `IO String' is not a monad. `IO' itself (together with its definition for `return' and `(>>=)') is a monad
21:04:08 <lambdabot> Consider it noted.
21:14:43 <ski> Lokathor : well, you'd like the physical dimension/magnitude `L / (T * T)' to be equal to `(L / T) / T', in the type system
21:15:24 <Lokathor> i don't.. parse that with my brain
21:15:28 <ski> (`L' being "length/distance" and `T' "time (difference)")
21:16:49 <Lokathor> yeah but the rest
21:17:14 <Lokathor> hey though, check it out! it monitors itself now, https://github.com/Lokathor/ireniko/blob/master/src/Main.hs
21:17:15 <ski> an example of a value of the former set could be `6 m/(s^2)'. an example of a value of the latter set could be `(18 m/s) / (3 s)'
21:17:31 <dolio> Creating a good type checked unit system is pretty difficult.
21:17:31 <ski> we want to treat these two sets/types as equal
21:17:59 <Lokathor> i just want to jump between scales of the same unit, not change the dimensionality of my units
21:18:24 <Lokathor> time to time only, never somehow time to acceleration or whatever
21:18:41 <ski> i'm not sure what you mean by "jump between scales of the same unit"
21:19:05 <Lokathor> like, minutes to microseconds, or seconds to nanoseconds, or other things
21:19:54 <ski> oh, so you mean jump between different measuring units, for the same physical dimension
21:19:59 <Lokathor> yes
21:20:33 <ski> however, when you want to multiply, or divide, then you want to mix heterogenous physical dimensions together
21:20:51 <ski> and it's pretty common in practice to want to do that
21:21:37 <Lokathor> sure, i'm not saying that's never needed, but i am saying that it's well beyond the scope of the relately simple and light feauture i was asking for
21:21:38 <ski> iirc, VHDL has a system that can do the former part
21:21:50 <ski> ok
21:22:37 <ski> iirc, some attempts of building such a (comparatively simple) system puts the units in the types, which i think is a mistake in general
21:23:33 <ski> typically, i don't want the types to complain if i'm trying to put `3 m' in the same list as `20 km'
21:24:14 <Lokathor> well, I just want to write, threadDelay $ toMicroseconds (Minutes 5)
21:24:25 <Lokathor> and feel reasonable that I gave it the correct value
21:24:33 <dolio> Yeah, it's probably more useful to have a standard unit in the type system and convert everything else to that.
21:24:58 <ski> one could imagine converting to a common underlying unit in the representation. or perhaps use heterogenous representation, hiding the details (quotient/factor type) behind an abstract data type
21:25:30 <ski> dolio : not sure what you mean by "standard unit in the type system"
21:25:49 <ski> i would rather think it should be "standard unit, in the implementation internals"
21:26:08 <dolio> I mean pick meters, and when you write 20 km (however you do that) it's 20,000 m.
21:26:11 <dolio> So they're all the same type.
21:26:43 <dolio> What you know is that it's a length, and there's some designated unit of length that everything is in terms of.
21:26:49 <ski> ok. "standard unit in the type system" to me sounds like you're expressing the `m' (unit) in the type, which isn't what that is doing
21:27:20 <ski> (well, or rather, i think that's a bad way to think about what is happening)
21:27:29 <dolio> Yeah, I guess.
21:28:15 <ski> (a length doesn't have a unit. you only need a unit when you want to express a length as a multiple/scaling of some standard unit)
21:29:44 <ski> i suppose there could be situations where you really want to keep track of the unit in the types. e.g. perhaps if you're using something like `Fixed'. but this would be relatively uncommon, i think
21:30:33 * ski . o O ( <https://en.wikipedia.org/wiki/Physical_quantity>,<https://en.wikipedia.org/wiki/Dimensional_analysis>,<https://en.wikipedia.org/wiki/Intensive_and_extensive_properties> )
21:33:47 <shanemikel> anybody here really comfortable with linking on linux?
21:35:02 <Lokathor> isn't it just: ln -s target linkName ?
21:35:12 <shanemikel> ...
21:35:24 <Clint> well played
21:36:20 <Lokathor> only after seeing the responses do I realize that you meant linking a binary together
21:37:45 <ski> .. it took a long time before i realized `ln <src> <dest>' and `ln -s <src> <dest>' was supposed to mimic `cp <src> <dest>'
21:37:56 <shanemikel> I'm trying to build something with the static haskell runtime and dynamically link to shared libs
21:38:01 <shanemikel> (c ffi)
21:38:02 <ski> (before that, i usually would get the argument ordering to `ln' wrong)
21:38:11 <thimoteus> ski: same here
21:38:20 <thimoteus> i remember one time i triple checked the argument order and STILL got it wrong
21:38:36 <ski> yes. i remember something similar
21:41:57 <EvanR> question, "lens" used in haskell pretty much refers to Control.Lens, and are composable things which can get and set in nested data... right... but at some point i heard about something else called lens
21:42:17 <EvanR> that was some sort of "thing that can modify data by modifying a view of that data"
21:42:35 <EvanR> does this make any sense, or is that not even different
21:43:10 <ski> @where lenses
21:43:10 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-
21:43:10 <lambdabot> structure-access-and-mutation>
21:43:17 <ski> perhaps those ^ may help
21:43:54 <EvanR> <http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
21:44:11 <ski> "get and set in nested data" -- note that the nested data here may be "virtual"
21:44:12 <shanemikel> as for packaging stuff for linux, does anybody have experience with dynamically linking against deps and statically linking against haskell deps that aren't in the distro?
21:44:30 <shanemikel> do the tools stack/cabal or whatever else help much with this?
21:44:47 <ski> @let onLines :: ([String] -> [String]) -> (String -> String); onLines f = unlines . f . lines
21:44:49 <lambdabot>  Defined.
21:45:08 <ski> @let perLines :: (String -> String) -> (String -> String); perLine = onLines . map
21:45:09 <lambdabot>  .L.hs:166:1:
21:45:09 <lambdabot>      The type signature for â€˜perLinesâ€™ lacks an accompanying binding
21:45:15 <ski> @let perLine :: (String -> String) -> (String -> String); perLine = onLines . map
21:45:17 <lambdabot>  Defined.
21:45:40 <EvanR> wow... the last link is a huge stack overflow answer by edwardk
21:45:42 <ski> > perLine reverse "\na\nbc\ndef\n"
21:45:43 <EvanR> looks good
21:45:46 <lambdabot>  "\na\ncb\nfed\n"
21:46:41 <ski> EvanR : note how `onLines' is offering a view of a string as a list of lines, while `perLine' is offering a view of a string as ("in turn") each of the lines
21:47:04 <ski> @where SEC
21:47:04 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
21:47:07 <ski> is also relevant
21:47:26 <EvanR> yes...
21:47:32 <EvanR> that one
21:48:56 <EvanR> this is exactly what im looking for
21:49:12 <ski> the original idea (apart from SECs, which was earlier) was `type FunRef a b = a -> (b,b -> a)' (or, expressed as "get&set", `(a -> b,a -> b -> a)')
21:49:14 <EvanR> does the onLines and perLine example have a name?
21:49:41 <ski> the idea being that a `FunRef a b' allows you to access and modify/replace a "subterm" of type `b', inside any term of type `a'
21:50:00 <ski> so it's like a (generic) path from an `a' to a `b' inside it (virtual or not)
21:50:45 <ski> then there's the matter that sometimes the path will point to a nonexisting part, for a given structure (not all lists have an element at index `20')
21:50:58 <EvanR> right
21:51:16 <ski> and also that sometimes you'll want to collectively point to multiple locations (like with `perLine' above. and also `map' for ordinary lists)
21:51:41 <ski> and then, for parametric datatypes, we'd also like to be able to change the *type* of the changed part, if possible
21:52:24 <ski> so `map :: (a -> b) -> ([a] -> [b])', allows us to change the type of the element from `a' to `b' -- but only if we change all elements at the same time, bulky (rather than incrementally, one at a time)
21:52:25 <EvanR> yes
21:53:31 <ski> one could imagine a list zipper of the shape `([a],b,[c])' where you typically traverse the list from left to right, changing the element type from `a' to some intermediate `b', and then to `c', as you move on
21:53:52 <ski> (perhaps occasionally moving backwards, and changing back again, if you want/need to)
21:54:18 <ski> @where TV
21:54:19 <lambdabot> http://www.haskell.org/haskellwiki/TV
21:54:32 <ski> EvanR : the `onLines',`perLine' example is from that ^ (by conal)
21:55:07 <ski> i suppose it's just an example of SEC
21:56:36 <EvanR> TangibleValue
21:56:42 <EvanR> nice
21:58:40 <ski> @let infixr 5 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (a10 ~> b01) f = b01 . f . a10
21:58:41 <lambdabot>  Defined.
21:59:37 <ski> @let res :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); res f = id ~> f  -- result
21:59:38 <lambdabot>  Defined.
22:00:01 <ski> @let arg :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b)); arg f = f ~> id  -- argument
22:00:02 <lambdabot>  Defined.
22:00:45 <ski> @type res . res . arg . map . res
22:00:47 <lambdabot> (b0 -> b1) -> (a -> a1 -> [a2 -> b1] -> b) -> a -> a1 -> [a2 -> b0] -> b
22:01:34 <ski> this asks to change the result of the result of the argument of the list element of the result in `a -> a1 -> [a2 -> ...] -> b', iow the bit marked by `...'
22:01:55 <ski> so the above chain describes the path from the whole of the type, down to the part we want to change
22:02:38 <ski> if we want to change both argument and result of a function, we use `~>' to traverse down both parts, specifying what transformation we want to apply in either position
22:04:03 <ski> note that `onLines' is `lines ~> unlines', meaning that we want to view the input string as a list of strings with `lines', and want to view the output string as a list of strings with `unlines'
22:06:18 <ski> hm, i suppose my "of" in the list ".. of .. of .. of .." is backwards
22:06:41 <MarcelineVQ> fo
22:07:17 <ski> "change the result, and change the result of that, and change the argument of that, and change the list element(s) of that, and change the result of that" would be more correct (but unfortunately wordier :/ )
22:07:56 <ski> (other option would be to reverse it, which doesn't then correspond to reading the pipeline from left to right)
22:08:16 <ski> ("change the result, and change the result of that, and change the argument of that" would usally be read as "change the third argument")
22:08:55 <ski> @type (***)
22:08:56 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:08:59 <ski> @type first
22:09:00 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:09:01 <ski> @type second
22:09:02 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
22:09:10 <ski> @type (+++)
22:09:11 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
22:09:13 <ski> @type left
22:09:14 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
22:09:16 <ski> @type right
22:09:17 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
22:09:36 <ski> and the corresponding things to `(->)', for `(,)' and `Either'
22:09:40 <ski> s/and/are/
22:10:04 <dolio> No.
22:10:18 <ski> no ?
22:10:18 <dolio> They're bimap, first and second from bifunctor.
22:10:30 <dolio> Because what you've been doing is composing functorial mappings.
22:10:55 <dolio> (~>) is mapping over the arrow profunctor.
22:11:19 <ski> yes, that's better. but it's the same thing, assuming the arrow is `(->)', as <http://conal.net/blog/posts/semantic-editor-combinators> did
22:11:21 <dolio> And thinking of it as mapping extends it to many more things.
22:11:39 <dolio> Without making up arbitrary categories of arrows.
22:11:40 <ski> (which was why i mentioned those names above)
22:12:36 <ski> (it's just generalizing along a different "dimension". in this case i wasn't interested in either generalization, just the common intersection)
22:14:53 <EvanR> ok so type FunRef a b... is a bifunctor
22:14:58 <ski> no
22:15:11 <EvanR> profunctor
22:15:14 <ski> `FunRef a b' is invariant in both `a' and `b'
22:15:17 <EvanR> oh
22:15:19 <ski> no, not a difunctor either
22:15:58 <EvanR> ~> is an arrow?
22:16:16 <ski> there is no `blahMap :: ... -> FunRef a0 b0 -> FunRef a1 b1'
22:16:31 <ski> the `~>' i defined above is a value, not a type
22:16:53 <EvanR> FunRef is a category?
22:16:58 <ski> (well, you could do such a `blahMap' if you use isomorphisms, but ..)
22:17:08 <ski> yes
22:17:24 <ski> (or the `Hom' for a category)
22:17:41 <EvanR> i got kind of lost around the res . res . map . arg . arg thing
22:18:52 <ski> `res . res . arg . map . res' corresponds to composing/nesting the contexts `a -> ...',`a1 -> ...',`... -> b',`[...]',`a2 -> ...' instead each other (in that order), yielding the context `a -> a1 -> [a2 -> ...] -> b'
22:19:22 <ski> `res' means : move "down" to the right of `->'
22:19:29 <ski> `left' means : move "down" to the left of `->'
22:19:32 <Zemyla> Hmm, could extensible effects and various restricted IO monads be used to implement permissions-based sandboxed IO like is in Java?
22:19:44 <ski> (er, `arg', not `left')
22:19:59 <ski> `map' means : move (down) inside `[...]'
22:21:52 <Zemyla> Like, you might have an action that is IO '[Disk, Network], and you need a Permissiob '[Disk, Network] to run it.
22:22:14 <EvanR> when you mentioned that the path may not go anywhere, like a list that is too short, (or a sum which has the wrong case, I guess), what is the solution?
22:22:28 <Zemyla> Which can be composed from a Permission '[Disk] and a Permission '[Network].
22:23:21 <Lovepon> https://hackage.haskell.org/package/reflex-0.4.0/docs/Reflex-Dynamic.html Why is holdDyn not `:: Event t a -> Dynamic t a`?
22:23:35 <simpson> Zemyla: Why not just go full capabilities?
22:23:59 <simpson> Type capabilities might actually be interesting. Maybe.
22:26:12 <nitrix> Lovepon: It needs an initial value, no?
22:26:35 <Zemyla> simpson: Type capabilities?
22:26:38 <Lovepon> nitrix: Oops, I mean `:: a -> Event t a -> Dynamic t a`
22:26:45 * hackagebot Diff 0.3.4 - O(ND) diff algorithm in haskell.  https://hackage.haskell.org/package/Diff-0.3.4 (SterlingClover)
22:27:07 <nitrix> Lovepon: Oh, so, monadic vs. not monadic?
22:27:26 <Lovepon> nitrix: Yes.
22:27:42 <nitrix> Lovepon: I think the idea is that you gain generality.
22:28:07 <Lovepon> nitrix: Eh, the less constraints, the more general, right?
22:28:22 <nitrix> Lovepon: Not in this case.
22:28:58 <Lovepon> nitrix: Why?
22:29:05 <nitrix> Lovepon: One can ignore the monad entirely by using Identity. But the other way around, using this in a monadic context (do) would be impossible.
22:29:12 <simpson> Zemyla: https://en.wikipedia.org/wiki/Capability_(computers)
22:29:19 <nitrix> Lovepon: If it had the type you suggest.
22:29:29 <simpson> Zemyla: Capabilities are a security model. They are *really* awesome but not well-known.
22:29:55 <nitrix> Lovepon: Usually though, people design api's with variants like holdDyn and holdDynM to avoid people being like "wtf".
22:30:31 <nitrix> Lovepon: My best recommendation would be to look at MonadHold, and the `hold` function.
22:30:32 <Lovepon> nitrix: But the question is, is Identity onadHold?
22:30:37 <nitrix> Clearly, it's doing all the work.
22:32:55 <cdtdev> In Haskell you can write a graph-searching procedure that can doa  depth-first search and return the first result, or do a breadth-first search and return a list of results, merely by running it in a different monad.
22:32:58 <cdtdev> Is this true?
22:33:23 <nitrix> cdtdev: Sounds realistic.
22:33:31 <Lovepon> Sweet jesus.
22:33:59 <Lovepon> How do I even
22:35:14 <cdtdev> I can't even begin to conceptualize such a thing.
22:36:06 <dolio> I'm not sure that would be the best way to present such a thing.
22:36:07 <joehillen> cdtdev: I don't think Monad have anything to do with that. Those would just be traversals
22:36:20 <cdtdev> But, like many things in Haskell, if you put the code in front of me it'd probably be like, "oh, that's obvious."
22:38:24 <cdtdev> Haven't played with traversals yet :(
22:38:51 <Zemyla> cdtdev: Do you know what mapM on lists is?
22:38:57 <Lovepon> Hooray for outdated libraries...
22:39:05 <cdtdev> Yes.
22:39:38 <Zemyla> Well, that's a traversal.
22:40:39 <Zemyla> Also, how granular would capabilities be?
22:41:12 <cdtdev> Ah, I think I get it.
22:41:23 <Zemyla> At least, type-based ones?
22:41:45 * hackagebot vector-th-unbox 0.2.1.6 - Deriver for Data.Vector.Unboxed using Template Haskell  https://hackage.haskell.org/package/vector-th-unbox-0.2.1.6 (LiyangHu)
22:42:15 <Lovepon> I swear, I need to declare map = fmap lol.
22:42:23 <simpson> Zemyla: Hopefully as granular as you can get. In object-capability languages like E and Monte, every object is its own capability.
22:42:32 <Zemyla> Would a sample capability be 'Network', or 'Network TCP "www.google.com" 80'?
22:42:57 <simpson> The latter's way better. Even better would be just the ability to make HTTP requests.
22:43:59 <EvanR> only HTTP only to certain hosts, which are certified by CA ;)
22:44:11 <EvanR> with green lock
22:44:16 <Zemyla> And how would that work with, say, being able to connect to a user-specified host?
22:44:18 <EvanR> fsvo of green lock
22:44:52 <simpson> Zemyla: Composition of objects. Or, in Haskell, presumably composition of functions.
22:45:51 <Zemyla> Would there be special input boxes which would be the only places a custom hostname could come from?
22:47:35 <simpson> makeHTTPEndpoint :: Cap TCP -> (TCP -> HTTP) -> Cap HTTP
22:47:41 <simpson> Or such. Looks kinda familiar, doesn't it?
22:47:53 <Zemyla> withHostInput :: HostInput -> (forall proto host port. Permission [Network proto host port] -> r) -> r
22:49:05 <Lovepon> What the heck.
22:53:10 <Tripplr> hello?
22:53:56 <Lovepon> Tripplr: Hi.
22:54:18 <Lovepon> Okay.
22:54:20 <Lovepon> This is sooo bad.
22:54:27 <Zemyla> Hmm, how many programs would do IO okay if IO was an ArrowChoice instead of a monad?
22:55:35 <Lovepon> I'm so ded lol
22:55:36 <EvanR> what would the benefit be
22:56:20 <Zemyla> Arrows, even ArrowChoices, are more amenable to static analysis.
22:56:44 <Lokathor> i think the lazyness of IO is the trouble most people hit, not the monadness
22:56:56 <EvanR> but... IO is not lazy
22:57:30 <Lokathor> it is sometimes
22:57:40 <EvanR> when you accidentally use readFile
22:57:44 <EvanR> otherwise
22:57:58 <Lokathor> yes that's the time :P
22:58:03 <ski> EvanR : one variant is to use `a -> Maybe (b,b -> a)'. you can generalize this to `a -> exists f. Functor f *> (f b,f b -> a)', where you get a bunch of `b's
22:58:04 <EvanR> the result must be fully formed before continuing
22:58:07 <dolio> readFile is the one that people don't have much trouble with.
22:58:39 <Lovepon> What the
22:58:47 <dolio> Because it doesn't allow them to mess things up trying to fix the laziness.
22:58:48 <Lokathor> I'd say that withFile is actaully a little trippier, because it doesn't quite act like similar constructs do in other languages
22:59:12 <dolio> (Which they probably don't need to do, they're just afraid.)
22:59:33 <ski> EvanR : so the lens decides how many `b's you get, depending on the value in `a'. perhaps in some case `f' will be `Triple' where `data Triple a = T a a a', e.g.
23:00:05 <Lovepon>     needed for package reflex-dom-0.2
23:00:21 <Lovepon>     - reflex-dom-0.3
23:00:25 <Lovepon> Wtf stack?
23:01:12 <EvanR> ski: ok so particular lenses can offer this or that functor views, but then can you compose them anymore?
23:01:23 <EvanR> even if they are all the same functor
23:01:31 <mgsloan> Lovepon: Please paste something more detailed somewhere and/or make an issue on the stack tracker
23:02:08 <dolio> ski: Those don't exactly line up.
23:03:29 <ski> EvanR : there's also `data FunList a b = Done b | More a (FunList a (a -> b))'. see <http://twanvl.nl/blog/haskell/non-regular1>,<http://www.twanvl.nl/blog/haskell/non-regular2>
23:03:52 <ski> dolio : which ?
23:05:12 <dolio> ski: I mean it might not be clear why you took Maybe (b, b -> a) to (exists f. ... (f b, f b -> a)), and why it can't be f (b, b -> a).
23:05:32 * ski thinks that using `hClose' on a handle that's been passed to `hGetContents' should probably be an error
23:05:53 <ski> dolio : yes, i was pondering the difference, when i wrote that
23:06:08 <dolio> The reason is that Maybe accidentally works.
23:06:46 * hackagebot stateWriter 0.2.7 - A faster variant of the RWS monad transformers.  https://hackage.haskell.org/package/stateWriter-0.2.7 (SimonMarechal)
23:07:20 <dolio> Because it's a suitable proxy for: ((), () -> a) + (b, b -> a).
23:07:37 <ski> (if you really want to close the handle, and know what you're doing, there could be a variant of `hClose' that you can use then)
23:07:42 <dolio> Where the () -> a is just giving you back your original thing.
23:08:51 <ski> oh, ok
23:09:06 <Zemyla> (Adjunction f u) => a -> f (u a)
23:10:08 <dolio> Once you might have more than one thing, though, you don't want two continuations, because that's not the same thing as a continuation taking two things.
23:10:42 <ski> Zemyla : not `u (f a)' ?
23:10:48 <Kwoth> Can someone point me to a good API wrapper project? I'm looking to build one while learning haskell.
23:11:14 <EvanR> ehm so FunList is a GADT
23:11:29 <EvanR> but not using GADT syntax?
23:11:35 <EvanR> didnt know you could do that
23:11:50 <dolio> It's just a nested type.
23:11:52 <ski> EvanR : no. it's just an nonregular data type. just like `data PerfectlyBalancedBinaryTree a = Elements a | Double (PerfectlyBalancedBinaryTree (a,a))'
23:11:58 <Zemyla> EvanR: No, it just uses a different type as one of its elements.
23:11:59 <dolio> Those are Haskell 98.
23:12:13 <EvanR> oh... then what is so special about GADTs
23:12:31 <dolio> Special constructor result types.
23:12:43 <EvanR> oh
23:13:03 <ski> EvanR : GADT would be if the parameters of the *return* type of the data constructors are not distinct type variables
23:13:12 <EvanR> yes of course
23:14:03 <Zemyla> Like you could have data CSeq f a where { CNil :: CSeq f (); CCons :: f a -> CSeq f u -> CSeq f (a, u) }
23:14:10 <ski> i suppose you could CPS a GADT into a non-GADT
23:14:35 <dolio> Yes, F_omega can encode GADTs.
23:14:41 <dolio> But that requires higher rank types.
23:14:58 <ski> in which cases ?
23:15:18 <dolio> Encoding requires higher rank types.
23:15:19 <Zemyla> ski: Yeah, you can, in theory. I know a ~ b is equivalent to forall f. f a -> f b.
23:15:31 <dolio> Or polymorphic components.
23:15:40 <dolio> Something that's not standard Haskell.
23:17:59 <ski> oh, right. for the `forall' in `forall o. (... -> o) -> o', i suppose you mean
23:18:06 <dolio> Yes.
23:19:57 <dolio> I suppose strictly speaking, the higher rank part wouldn't come in until you use them in other types.
23:20:05 <dolio> But polymorphism needs to be first class.
23:20:10 <dolio> Somehow.
23:21:24 <ski> i was thinking of stuff like expressing `data M :: * -> * where Return :: a -> M a; Bind :: M a -> (a -> M b) -> M b; PutChar :: Char -> M (); GetChar :: M Char' as `type M a = (a -> Action) -> Action' where `data Action = Halt | PutCharBind Char Action | GetCharBind (Char -> Action)'
23:21:36 <ski> (`M' in the former case being abstract, of course)
23:21:46 <ski> so you can sometimes avoid the `forall'
23:22:35 <Lovepon> mgsloan: Omg. I'm sorry for that, turns out I had reflex-dom on my pacakges list.
23:22:37 <Lovepon> >.<
23:22:39 <ski> Zemyla : does that help here ?
23:23:05 <sam__> now
23:23:20 <ski> later
23:23:47 <sam__> anyone have the link on youtube regarding haskell workflow ?
23:23:47 <Zemyla> ski: You'd be better off going with Free GetPut where GetPut a = Put Char a | Get (Char -> a).
23:25:49 <dolio> Yeah, that type kind of doesn't need to be a GADT, I guess.
23:25:57 <ski> yes, this was just the first example i could think of
23:26:08 <dolio> Not all GADTs are like that.
23:26:12 * ski nods
23:26:30 <Zemyla> And it eventually becomes, through Church encoding, newtype M a = M { runM :: forall r. (a -> r) -> (Char -> r -> r) -> ((Char -> r) -> r) -> r }
23:27:34 <ski> sam__ : what's that ?
23:27:55 <Zemyla> Anyways, goodnight.
23:28:25 * ski has no idea whether sam__ is maybe looking for <https://www.youtube.com/watch?v=Li6oaO8x2VY> or something else
23:28:29 <ski> night, Zemyla
23:29:17 <EvanR> i got side tracked into FunList but i realize now that i have no idea what it is for
23:29:41 <EvanR> what kind of thing can you do what on with it
23:31:11 <dolio> EvanR: It's a way of writing something like: 'exists n. (a^n, a^n -> b)'
23:31:13 <Zemyla> EvanR: It's fun. It says so in the name.
23:31:38 * ski wonders whether EvanR looked at <http://www.twanvl.nl/blog/haskell/non-regular2> yet
23:32:11 <dolio> So it lets you generalize FunRef to multiple values.
23:32:20 <EvanR> i was on the first paragraph, after getting through the long list of proofs in the comments of regular 1
23:32:26 <dolio> Such that the number of values you see matches the number of values you feed back in.
23:33:13 <EvanR> all the a are the same, so this isnt really a path
23:33:25 <ski> ?
23:33:28 <EvanR> unless a are coords components in space
23:33:37 <EvanR> all the a are the same type, i meant
23:34:00 <ski> it's a path to `n' occurances of an `a' value, inside the `b'
23:34:48 <EvanR> oh
23:34:48 <ski> (or perhaps you'd call it a "multipath" or something)
23:35:06 <EvanR> ok i was thinking of a and b backwards the whole time
23:35:24 <ski> yeah, for some reason they were swapped here
23:36:46 <EvanR> ok so you can update n a's somewhere within b, to get a new b
23:36:57 <ski> *nod*
23:37:20 <ski> where the original `b' determines what `n' is
23:38:10 <EvanR> and maybe you can compose two funlists to access n c inside each a
23:38:24 <Lovepon> Guys
23:38:29 <Lovepon> :t mplus
23:38:30 <lambdabot> MonadPlus m => m a -> m a -> m a
23:38:37 <Lovepon> What type has
23:38:46 <Lovepon> _ mplus x = x?
23:38:49 <Lovepon> Oops
23:38:55 <Lovepon> Not mplujs
23:38:59 <Lovepon> :t (<>)
23:39:00 <lambdabot> Monoid m => m -> m -> m
23:39:02 <Lovepon> That
23:39:05 <Lovepon> _ <> x = x
23:39:37 <ski> EvanR : should be possible, i think
23:39:43 <EvanR> > () <> ()
23:39:45 <lambdabot>  ()
23:39:56 <EvanR> :t ()
23:39:57 <lambdabot> ()
23:40:01 <EvanR> ()
23:40:55 <ski> Lovepon : `_ <> x = x' is not an expression, nor a pattern. it doesn't have a type
23:41:06 <Lovepon> Err
23:41:28 <Lovepon> ski: What instance has the definition `_ <> x = x`?
23:42:43 <ski> > getLast (undefined <> Last (Just 4))  -- Lovepon
23:42:45 <lambdabot>  Just 4
23:42:58 <Orbaruk> Does anyone has an idea of why when i use "cabal build" my program takes 11s to execute and when using "ghc -O2" it takes 8s? Ive set the -O2 flag in the .cabal file for ghc-options also
23:43:11 <Lovepon> ski: Oh. So First and Last? xD
23:43:20 * ski nods
23:43:33 <Lovepon> ski: I can't believe I didn't think of that. Lol. Thanks.
23:43:58 <Lovepon> > getLast (Last (Just 4) <> Last Nothing)
23:43:59 <lambdabot>  Just 4
23:44:25 <ski> `Maybe' because of `mempty'
23:46:09 <Lokathor> Orbaruk, can you lpaste your cabal file?
23:47:31 <nshepperd> well, Last has `_ <> x@(Last (Just _)) = x`
23:47:54 <nshepperd> I think the only thing that could legally have the actual definition `_ <> x = x` would be () indeed
23:47:59 <lpaste> orbaruk pasted â€œNo titleâ€ at http://lpaste.net/161275
23:50:25 <nshepperd> because taking any a, `a <> mempty = mempty` (by that definition) => `a = mempty` (by the monoid identity law) => the only inhabitant is mempty
23:54:48 <Orbaruk> lokathor pasted file at  http://lpaste.net/161275
23:56:57 <Lokathor> looks normal to me :(
23:57:00 <Lokathor> dunno
23:59:07 <Orbaruk> lokathor welp, thanks anyway, will keep testing some stuff here
