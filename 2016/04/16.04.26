00:11:57 <funrep> anyone know if there's an installation guide for gloss?
00:12:50 <srhb> funrep: Aside from just installing it? Or are you thinking of dependencies?
00:14:02 <funrep> it doesnt find my libglut3-dev installation
00:14:12 <funrep> "/home/funrep/Sandbox/mandelbrotset/.stack-work/install/x86_64-linux/lts-5.13/7.10.3/bin/mandelbrotset-exe: error while loading shared libraries: libglut.so.3: cannot open shared object file: No such file or directory
00:15:23 <Athas> Nice, Stack even makes it easy to automatically install whatever is necessary for profiling.
00:15:33 <funrep> i have simply "gloss" as a dependency then in extra-deps in stack.yaml i have "- gloss-1.10.1.1
00:15:40 <srhb> funrep: I assume it needs to be on your LD_LIBRARY 
00:16:13 <funrep> okey, system variable or a stack configuration?
00:16:23 <srhb> environment variable
00:16:40 <srhb> funrep: Also the nix support can be handy for automating all external dependency stuff.
00:18:13 <funrep> is freeglut3 different from libglut.so.3?
00:19:42 <funrep> hmm, made a new shell and now it worked
00:20:49 <srhb> funrep: libglut.so.3 is the specific file name of the library searched for, freeglut3 is a package
00:20:52 <srhb> funrep: And nice :)
00:26:16 * hackagebot HSet 0.0.0 - Faux heterogeneous sets  https://hackage.haskell.org/package/HSet-0.0.0 (athanclark)
00:27:07 <taktoa_> anyone know the best (most efficient) way to convert a JuicyPixels 'Image PixelRGBA8' (basically just a 'Vector Word8') to a 'StorableArray (Int, Int, Int) Word8' (where the first two indices are y and x, and the last one is the channel [0, 1, 2, 3] => [R, G, B, A])
00:27:37 <taktoa_> or alternatively a better way to get an 'Image PixelRGBA8' into an X11 Image.
00:29:35 <__uu__> data Tree a = Node a (Tree a) (Tree a)
00:29:35 <__uu__> 		| Empty
00:29:47 <__uu__> hi, when defining the Tree type, what is Node?
00:29:55 <__uu__> is Node a constructor?
00:30:07 <__uu__> or just part of the type?
00:30:16 <taktoa_> yes, it is a constructor
00:30:42 <__uu__> but is not constructor something takes a "value"?
00:30:45 <taktoa_> it can be thought of as an injective function of the type "Node :: a -> Tree a -> Tree a -> Tree a"
00:31:02 <taktoa_> yeah it's a somewhat confusing notation for beginners
00:31:32 <EvanR> GADT syntax may shed light on data constructors
00:31:49 <__uu__> what is GADT? EvanR;
00:31:54 <EvanR> which would literally have that type sig taktoa_ showed
00:32:11 <EvanR> nevermind GADTs for now, but GADT syntax would be
00:32:23 <taktoa_> the first thing in each pipe-delimited part of a data declaration is the name of a constructor, followed by whitespace and a series of whitespace-delimited type names
00:32:24 <EvanR> data Tree :: * -> * where
00:32:32 <EvanR>   Node :: a -> Tree a -> Tree a -> Tree a
00:32:50 <taktoa_> err, s/type names/types/g
00:33:33 <__uu__> aha, I got it!
00:33:41 <__uu__> thanks EvanR: and taktoa_
00:33:46 <taktoa_> np
00:34:24 <EvanR> that tree type would be necessarily infinite
00:34:34 <EvanR> since theres no rule for leaves
00:35:19 <taktoa_> also does anyone know of a package (preferably smaller than the whole of XMonad) that sanely wraps over the X11 API so I don't have to write C-flavored Haskell
00:35:29 <__uu__> I have yet another question
00:35:43 <__uu__> data Doc = Empty
00:35:44 <__uu__> 	| Char Char
00:35:45 <__uu__> 	…. 
00:36:00 <__uu__> this is an example from the real world haskell
00:36:11 <__uu__> what is the two Chars 
00:36:23 <taktoa_> that is a pretty confusing way to write that, since Char is the name of a constructor and the name of preexisting type
00:36:28 <__uu__> data Doc = Char Char | (some other constructors)
00:36:29 <liste> __uu__: one is a type name, the other is a constructor (value) name
00:36:30 <EvanR> thats a confusing way to use the fact that type names and constructor names are in different namespaces
00:36:45 <EvanR> data Doc = MkChar Char | ...
00:37:00 <EvanR> MkChar 'x' :: Doc
00:37:26 <taktoa_> it's especially egregious because typically when you alias like that you are at least aliasing a constructor with the type it constructs
00:37:42 <__uu__> why the two Char does not conflict?
00:37:42 <EvanR> at least, not using a standard type as a new ctor name ;)
00:37:52 <__uu__> like what would happen in C++
00:38:02 <taktoa_> __uu__: that's just how Haskell resolves names
00:38:10 <taktoa_> a constructor can have the same name as a type
00:38:13 <EvanR> there are two namespaces involved
00:39:23 <__uu__> so haskell know one Char is a constructor and the other is a Type?
00:39:32 <EvanR> yep
00:39:42 <__uu__> or what about the two namespaces?
00:40:02 <EvanR> ctor names, type names
00:40:14 <__uu__> I mean are they differed by namespaces or by types?
00:40:40 <taktoa_> basically there's no situation in which you can accidentally put a constructor where a type is expected or vice versa
00:40:53 <EvanR> unless they have the same name ;)
00:41:11 <EvanR> in which case it works out
00:41:14 <taktoa_> yea
00:41:54 <taktoa_> So Haskell considers them as totally separate. You can imagine that the compiler looks at your code, figures out what is a constructor and what is a type, and prefixes all constructors with "Constructor" or something.
00:42:09 <__uu__> taktoa_: yea
00:43:05 <__uu__> for example, char c = Char c , the compiler knows the 'Char' here is a constructor
00:43:19 <taktoa_> yeah
00:43:21 <__uu__> in no case, it would be a type
00:43:42 <EvanR> foo :: Char -> Char, here its a type
00:43:57 <__uu__> but I did follow EvanR: by the namespace stuff.
00:44:11 <__uu__> s/by/of
00:44:24 <__uu__> s/of/on
00:44:32 <__uu__> sorry, I am not a native speaker
00:47:39 <koz_> What's the name of the point-freeing bot in here again?
00:47:39 <__uu__> by the way, is there namespace in haskell? I can only find a proposal here https://www.cs.york.ac.uk/fp/libraries/
00:47:49 <koz_> __uu__: Modules?
00:47:50 <__uu__> or, you just mean the concept of namespace?
00:47:53 <EvanR> modules create a namespace 
00:48:16 <EvanR> i was referring to the internal separation of ctor names and type names in the language
00:48:25 <EvanR> not a language feature you can use
00:48:27 <__uu__> never mind, you clarified my questions, thank you both!
00:48:34 <koz_> __uu__: You're welcome!
00:48:35 <taktoa_> np
00:48:57 <funrep> is it possible to generate haddock for a dependency in a stack project?
00:49:51 <koz_> pl \x -> SplitZipper ([], x) 
00:50:05 <koz_> Wait, did I misname the bot?
00:51:27 <cocreature> funrep: I am pretty sure stack haddock does exactly that
00:52:08 <EvanR> koz_: i dont think it knows about SplitZipper, but @pl
00:52:33 <koz_> @pl \x -> SplitZipper ([], x)
00:52:33 <lambdabot> SplitZipper . (,) []
00:52:37 <koz_> Oh, thought so.
00:52:44 <funrep> cocreature: alright!
00:52:57 <taktoa_> is there something like runhaskell that can have optimizations enabled (as opposed to bytecode compilation)?
00:53:37 <cocreature> funrep: note that the haddocks for the snapshot and local packages end up in different directories. stack haddock prints the paths to both after it has finished building them
00:54:17 <koz_> Is @pl PMable? I wanna muck around with it, but don't wanna noise up the chan.
00:54:31 <cocreature> it’s lambdabot
00:54:56 <koz_> \query lambdabot @pl \x -> SplitZipper ([], x)
00:54:56 <cocreature> oh now I understood the question
00:55:00 <cocreature> koz_: yep you can send pms
00:55:10 <koz_> cocreature: So I PM @pl?
00:55:24 <cocreature> /query lambdabot @pl \x -> SplitZipper ([],x)
00:55:25 <taktoa_> no I think you PM lambdabot
00:55:33 <cocreature> that should work
00:55:44 <koz_> Yay, thanks!
00:56:11 <funrep> okey, anyone have successfully built gloss using stack?
00:56:17 * hackagebot fast-logger 2.4.6 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.6 (KazuYamamoto)
00:56:24 <funrep> or rather installing it as a dependency
00:56:51 <funrep> hmm now it doesnt spit errors all of a sudden strange
01:03:22 <jle`> is there a nice way to hide away the fact that my type is implemented using Free?  is it just with a newtype wrapper?
01:04:08 <funrep> hi, anyone know what this error cabal/stack error means? --  While building package mandelbrotset-0.1.0.0 using: /home/funrep/.stack/setup-exe-cache/x86_64-linux/setup-Simple-Cabal-1.22.5.0-ghc-7.10.3 --builddir=.stack-work/dist/x86_64-linux/Cabal-1.22.5.0 build lib:mandelbrotset exe:mandelbrotset-exe --ghc-options " -ddump-hi -ddump-to-file"
01:04:24 <funrep> ups excuse the paste :s i meant to link here: https://gist.github.com/funrep/1b80b77e26f47567ddfb402172c88805
01:05:08 <cocreature> funrep: add gloss to the build-depends of the library
01:05:16 <MichaelBurge> funrep: Add the gloss package to your .cabal  file in the library section
01:06:03 <funrep> oh okey, thanks!
01:06:25 <funrep> didn't realize it had 2 different configurations for app and src
01:07:03 <funrep> now it works :)
01:11:48 <bitonic> What are good resources to learn how 1. Haskell exceptions work (especially async exceptions) 2. How Haskell is executed, not really delving into the details of the STG, but giving a good mental model of laziness and memory in Haskell
01:12:25 <ocramz> morning all
01:12:40 <EvanR> Control.Exceptions docs are good for understand async exceptions at least basically, including blocking async execeptions temporarily
01:12:43 <agocorona> hi
01:12:46 <EvanR> Control.Exception i mean
01:13:01 <cocreature> "parallel and concurrent programming in haskell" also has a nice section on exceptions
01:13:51 <taktoa_> "parallel and concurrent programming in haskell" doesn't really have non-nice sections
01:14:06 <cocreature> taktoa_: yep, but they are not all about exceptions :)
01:14:11 <EvanR> this seems to be an interesting tool for visualizing haskell (ghc) at runtime http://felsin9.de/nnis/ghc-vis/
01:14:22 <ocramz> What sparse data structure supports repeated entries? I need one which keeps count of the repeated inserts, if it exists already. All tips welcome
01:14:42 <EvanR> but besides that, you should imagine haskell expressions being evaluated syntactically if possible
01:14:57 <agocorona> OverloadedStrings don't play well with polimorphic code: produce errors of type "no instance IsString for  a0"  available instances are.....
01:15:21 <ocramz> EvanR : super interesting, thank you
01:16:16 <EvanR> lookup weak head normal form, which is an important concept to understand runtime behavior
01:16:18 <agocorona> is there some way to avoid that ? It would be interesting a TextAsDefault
01:16:21 <EvanR> (WHNF)
01:17:03 <taktoa_> agocorona: type defaulting
01:18:07 <taktoa_> agocorona: I forget the syntax for it but you can tell Haskell to default overloaded strings the same way you can tell it to default numeric literals to e.g.: Int, rather than the default default of Integer
01:18:23 <srhb> agocorona, taktoa_: default (Text)
01:18:49 <srhb> You probably want to add your other defaults as well though.
01:18:51 <agocorona> srhb:  where I put that directive?
01:18:59 <taktoa_> top-level
01:19:06 <srhb> agocorona: Anywhere in your top level.
01:19:37 <taktoa_> actually I think 'default IsString (Text)' may be preferable, but I am not sure
01:19:41 <agocorona> {-# default (Text) #-} ??
01:19:41 <srhb> I don't really advice this though. Better be explicit. It might be nice for developing though, as long as you get rid of it again.
01:19:47 <srhb> taktoa_: Yes, agreed.
01:19:52 <companion_cube> hi! anyone knows how to build with `make` in a cabal package based on Distribution.Simple?
01:19:55 <taktoa_> agocorona: it's not a pragma
01:19:58 <srhb> agocorona: No, default (Text) as written, on column zero
01:20:53 <agocorona> ok.  what is the name of that kind of construction? fake top level computations?
01:21:19 <taktoa_> agocorona: "type defaulting declaration"?
01:21:29 <taktoa_> https://prime.haskell.org/wiki/Defaulting
01:22:27 <agocorona> taktoa_:  thanks a lot
01:22:38 <agocorona> srhb too
01:22:39 <taktoa_> np
01:23:20 <srhb> taktoa_: No extension actually provides that possibility, right?
01:23:36 <srhb> taktoa_: default <classname> (type1, type2, ..., typen) I mean
01:23:55 <taktoa_> srhb: oh I must have read a proposal and thought it was real syntax
01:24:36 <taktoa_> haskell-src-exts fails to parse it at least
01:24:55 <taktoa_> not saying much though given that HSE still doesn't parse pattern synonyms properly
01:25:32 <taktoa_> yeah looks like it's not real syntax
01:25:35 <srhb> taktoa_: I'm sort of liking proposal 4, remove defaulting. :-)
01:26:37 <taktoa_> srhb: same
01:27:26 <agocorona> and keep these pretty error messages  "no instance xxxxx for a2444" available instances.....
01:27:35 <agocorona> ?
01:27:49 <taktoa_> no, just make it GHCI's job to do type defaulting
01:28:56 <companion_cube> no one knows about cabal? :?
01:29:10 <srhb> agocorona: I don't mind those error messages though. 
01:29:26 <taktoa_> companion_cube: it wouldn't be much of a secret cabal if everyone knew about it :P
01:29:29 <srhb> agocorona: Though arguably "the type variable 'a0' is ambiguous" should be the very first thing you see.
01:29:33 <companion_cube> ^^
01:29:57 <srhb> agocorona: It certainly looks a lot more unreasonable when you omit that. :-)
01:30:19 <agocorona> srhb:  you should consider them when in a web application you have hundreds, one for each string
01:30:34 <srhb> agocorona: I am considering that.
01:30:42 <sphinxo> Anyway I can do this without the duplication of isSon isFather etc? http://lpaste.net/5895178939764047872
01:32:00 <taktoa_> the haskell X11 api requires me to explicitly allocate a pointer, run a side-effecting computation that instantiates that pointer, and then read out the members of the pointed-to struct as fscking 32-bit integers
01:32:06 <agocorona> an option for smaller error messages would be very very useful
01:33:44 <taktoa_> unfortunately the intersection between people who like haskell and people who enjoy spending their time making software with usability in mind is fairly slim, and the intersection between users advanced enough to hack on GHC and users who need easy-to-read error messages is even smaller.
01:33:59 <guibou> Question about Shake. I'm using shake to build a set of dependencies in a library. But whatever happen, I must continue to write a report on the disk and I want a) To know which targets failed to build and b) get the shake report. Do you know if this is possible ?
01:34:29 <srhb> agocorona: Oh yes, for sure. :)
01:37:50 <agocorona> taktoa_:  to engage both group of people in the task of making some sophisticated error system, with a simple output by default
01:38:12 <Lovepon> Is the maintainer of Data.Bits here?
01:38:20 <Lovepon> I have something of interest-ish.
01:38:38 <srhb> Lovepon: That's base, so that's the libraries committee
01:38:59 <srhb> Lovepon: Do mention the interest-ish-ing thing though :)
01:40:01 <agocorona> (badly expressed, don't care)
01:40:18 <taktoa_> agocorona: I think I understand what you mean
01:40:44 <Athas> Is attoparsec the library of choice for writing fast parsers nowadays?
01:41:07 <Lovepon> srhb: One is getting the number of bits required of an Integer > 0.
01:41:11 <taktoa_> Athas: I usually write a parser using trifecta/parsers and then switch it to attoparsec after debugging
01:41:19 * hackagebot hssqlppp 0.6.0 - SQL parser and type checker  https://hackage.haskell.org/package/hssqlppp-0.6.0 (JakeWheat)
01:41:24 <Lovepon> srhb: Basically, the ceiling of log2.
01:41:43 <taktoa_> since parsers has types generic enough that you can use the same code with trifecta and attoparsec
01:41:46 <Athas> taktoa_: but if I already have a developed parser/grammar that I just need to run fast, attoparsec is the best choice?
01:41:59 <taktoa_> yeah, AFAIK
01:42:10 <Athas> Good enough for me!
01:42:16 <Athas> Thanks!
01:42:19 <taktoa_> np
01:42:29 <Lovepon> srhb: Also, I had a generalized O(log n) popcount.
01:42:36 <Lovepon> srhb: But then I deleted it when I realized popcount exists.
01:42:52 <Lovepon> srhb: Then I realized that popCountDefault is O(n).
01:45:41 <Lovepon> srhb: Right now, it's in my arithmetic library, sooooo it's kinda out of place.
01:46:33 * hackagebot automotive-cse 0.1.3.0 - Automotive CSE emulation  https://hackage.haskell.org/package/automotive-cse-0.1.3.0 (KeiHibino)
01:47:10 <MichaelBurge> Lovepon: If n is the number of bits, shouldn't in general a popcount require O(n) since you have to inspect each bit at some point?
01:47:51 <EvanR> what, a combinatory logic circuit for n-bits would be O(1)! ;)
01:48:14 <Lovepon> MichaelBurge: No!
01:48:26 <Lovepon> MichaelBurge: What I did was to make a mask of the number of bits.
01:48:36 <Lovepon> MichaelBurge: Then generate a pattern.
01:48:46 <Lovepon> MichaelBurge: pattern .&. bits.
01:49:11 <Lovepon> Hmmmm
01:49:18 <Lovepon> Pattern generation was O(log n)
01:49:29 <Lovepon> You make log n patterns.
01:49:38 <Lovepon> Yep. It was O(log n).
01:49:59 <MichaelBurge> Lovepon: Just the phrase "pattern .&. bits" should be O(n) if n is the number of bits, since you're touching each bit.
01:50:21 <Lovepon> MichaelBurge: I guess.
01:50:21 <MichaelBurge> But, you might be able to get away with O(log(n)) operations on fixed-size types.
01:50:57 <Lovepon> MichaelBurge: With the assumption that every bitwise operation is constant though.
01:51:13 <EvanR> and :: Bit -> Bit -> Bit is O(n) in the size of a bit
01:51:53 <EvanR> in the size of the primitive used to encode whether the Bit is 0 or a 1 ;)
01:52:13 <EvanR> because youre touching all the bits of that encoding to check its value!
01:52:34 <Lovepon> MichaelBurge: I think my implementation should be faster though.
01:53:15 <MichaelBurge> Lovepon: Yeah, it looks like popCountDefault is O(n) primitive operations, each of which touches O(n) bits, but the second O(n) is hidden in the CPU as a primitive instruction.
01:53:35 <Lovepon> MichaelBurge: the second O(n)?
01:54:32 <Lovepon> Also, wouldn't popCountDefault be O(n^2) in this case?
01:54:35 <MichaelBurge> Lovepon: Your CPU has circuitry for doing an 'and' instruction on two 64-bit values, so there are at least O(n) gates there somewhere.
01:54:44 <Lovepon> It does O(n) operation, n times.
01:54:48 <Lovepon> O(n^2)
01:54:52 <EvanR> MichaelBurge: -_-
01:55:03 <EvanR> wrong
01:55:05 <merijn> Since 64bit values are constant size they are O(1)
01:55:09 <Lovepon> MichaelBurge: I'm pretty sure all AND gates are O(1)
01:55:21 <taktoa_> it's more like O(m * n), where m = 64
01:55:30 <EvanR> the whole ALU takes O(1) cycles for any operation
01:55:33 <Lovepon> taktoa_: So... O(n)?
01:55:38 <taktoa_> Lovepon: yep
01:55:39 <Lovepon> EvanR: Not really.
01:55:48 <Lovepon> EvanR: division/modulo comes to mind.
01:55:54 <EvanR> uhm. what
01:56:00 <Lovepon> EvanR: Wut?
01:56:02 <merijn> I would urge everyone here to read up on big O notation, because I'm seeing a ton of gross abuse here :\
01:56:08 <Lovepon> merijn: :)
01:56:13 <Lovepon> merijn: I'm one of those! :D
01:56:14 <EvanR> O(1) = some number
01:56:20 <EvanR> possible huge
01:56:37 <taktoa_> but the big-O notation for an algorithm depends strongly on what you consider to be constant and what you consider to be variable
01:56:45 <merijn> To be more specific "O(x)" describes a CLASS of functions and anything inside that class is "O(x)"
01:57:23 <taktoa_> by that definition, any function that is O(n) is also O(n^2)
01:57:27 <Freundlich> Exactly. Since we are talking about functions \mathbb{N} \to \mathbb{R} we have to specify an algorithmic model first to talk about complexity of algorithms.
01:57:31 <merijn> taktoa_: Eh, yes
01:57:35 <taktoa_> which from a complexity-theoretic point of view is true
01:57:36 <Lovepon> taktoa_: Yeah.
01:57:53 <taktoa_> but it's not very useful for someone talking about algorithms
01:58:01 <Freundlich> It isn't?
01:58:02 <merijn> taktoa_: Constants matter in real systems, yes
01:58:13 <EvanR> neither is talking about the number of and gates to make an Int .&.
01:58:23 <merijn> Consider PHK's "You'
01:58:24 <taktoa_> merijn: are we not talking about real systems, though?
01:58:29 <merijn> Consider PHK's "You're doing it wrong" essay
01:58:30 <merijn> https://queue.acm.org/detail.cfm?id=1814327
01:58:59 <merijn> taktoa_: I'm not sure WHAT we are talking about, lots of people blurting lots of O(something) without context
01:59:07 <Freundlich> It's not uncommon to talk about "machines" that can do integer operations like addition in constant time for _any_ integer.
01:59:21 <Freundlich> Just to get rid of the log(n) that would otherwise pop up everywhere.
02:00:39 <taktoa_> merijn: "we" (I wasn't really involved) were talking specifically about the performance of some bitwise operation
02:00:40 <EvanR> its subjective what you consider constant time enough to model accurately what youre trying to do
02:01:01 <taktoa_> EvanR: exactly
02:01:17 <merijn> taktoa_: Then it depends on whether we're talking about Int or Integer
02:01:32 <merijn> And actually, realistically speaking it'd depend on whether Int# is involved too
02:01:38 <merijn> If we care about "real" performance
02:01:47 <MichaelBurge> merijin: We were talking about one of the Bits typeclasses that worked for any arbitrary type
02:02:43 <merijn> MichaelBurge: It's impossible to talk about the performance of Bits in general
02:02:58 <merijn> The performance is intrinsically tied to the specific instance you're talking about
02:06:38 <MichaelBurge> merijn: I guess you could write an instance that throws away all the information and runs in constant time, and another that spins for n! operations for no reason
02:07:33 <merijn> Also an implementation for, say "data Peano = Succ Peano | Zero" will necessarily be less efficient than one for "Int"
02:07:43 <merijn> Since Int has CPU primitives to do most operations
02:08:19 <EvanR> my cpu has peano support so
02:08:20 * Lovepon makes a unary computer
02:08:24 <Lovepon> EvanR: ggwp
02:08:34 <Lovepon> EvanR: Can it play music? :D
02:12:04 * hackagebot Chart 1.7 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.7 (TimDocker)
02:12:06 * hackagebot Chart-cairo 1.7 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.7 (TimDocker)
02:12:08 * hackagebot Chart-gtk 1.7 - Utility functions for using the chart library with GTK  https://hackage.haskell.org/package/Chart-gtk-1.7 (TimDocker)
02:12:10 * hackagebot hssqlppp-th 0.6.0 - hssqlppp extras which need template-haskell  https://hackage.haskell.org/package/hssqlppp-th-0.6.0 (JakeWheat)
02:12:12 * hackagebot Chart-diagrams 1.7 - Diagrams backend for Charts.  https://hackage.haskell.org/package/Chart-diagrams-1.7 (TimDocker)
02:15:23 <nmdanny> is it possible to have multiple pattern bindings in a single case expression?
02:15:41 <nmdanny> for example, I have an outer case expression that matches on a list of words
02:16:06 <nmdanny> I want to have guards of some kind that can try reading certain words as Ints using readMaybe
02:16:19 <merijn> nmdanny: Use pattern guards?
02:17:12 <MichaelBurge> nmdanny: You can try matching on a tuple to match multiple variables at once: case (x, y) of ...
02:17:22 <nmdanny> can pattern guards introduce variables to my expression? 
02:17:31 <merijn> nmdanny: Sure
02:18:15 <nmdanny> for example, I have the following list:
02:18:25 <nmdanny> ["Err",50,"Some","Error","Message"]
02:18:27 <merijn> "case foo of [x,y,z] | Just n <- readMaybe x -> stuffWith n y z"
02:18:46 <merijn> Might want some line breaks because the "<- readMaybe x ->" is a bit confusing
02:19:11 <merijn> If "readMaybe x" doesn't match with "Just n" it'll fallthrough to the next case
02:19:39 <nmdanny> oh good
02:19:48 <nmdanny> and can I have multiple pattern bindings in the guard?
02:19:53 <merijn> Yes
02:20:06 <nmdanny> separated by commas?
02:20:11 <merijn> Consult GHC manual for details
02:20:18 <merijn> (I always forget the exact syntax :p)
02:20:36 <merijn> Actually, I suppose you have to look at the report. It's not an extension in Haskell2010
02:21:18 <nmdanny> oh yea ok it words, separated by commas
02:25:42 <nmdanny> Ok I managed to get a somewhat complex case expression, can it be made shorter or more understandable somehow? http://pastebin.com/mm0LnZrh
02:26:42 <merijn> nmdanny: I'd start with making the string pattern names shorter
02:26:59 <merijn> nmdanny: Since they're only used in the pattern and never outside they don't have to be so descriptive
02:27:07 <merijn> Also, line breaks
02:30:31 <nmdanny> would it be a good idea to use monads here, i'm thinking option monad, alternative and monoid? or is it more idiomatic to just use cases and guards?
02:31:01 <lpaste> merijn pasted “No title” at http://lpaste.net/161595
02:31:10 <merijn> nmdanny: That's already way more readable
02:31:24 <merijn> nmdanny: I would probably use a parser library for this
02:31:34 <merijn> Instead of words + readMaybe
02:31:45 <merijn> nmdanny: I'm assuming you plan to parse substantial logfiles?
02:31:59 <merijn> readMaybe is slow as shit compared to, say, (atto/mega)parsec
02:32:10 <merijn> Esepcially since those can work directly on Text
02:32:17 <merijn> Which is also faster than String
02:32:26 <nmdanny> I'm just doing a tiny exercise, but yes I'm aware of parsec
02:32:50 <merijn> nmdanny: If you'd use parsec you'd get the optional alternative, etc. stuff for free
02:33:07 <merijn> But writing your own wrapper for this probably takes more code/effort than this
02:33:24 <merijn> So for a tiny exercise this is probably as clean as it'll get
02:33:26 <nmdanny> yea I guess you're right,
02:34:31 <nmdanny> but, in general, is it possible to abstract case expressions and guards to using monads and alternative application?
02:34:47 <nmdanny> (not just in parsing, but for general control flow etc..)
02:35:08 <merijn> "It depends"
02:35:28 <merijn> For parsing, yes, for some other things too, but it's a bit to context dependent
02:35:42 <merijn> You can't always generalise case expressions to monads/alternative/etc.
02:36:23 <merijn> Case expressions are one of the fundamental primitives, so all that stuff is implemented using case expressions, so it wouldn't make much sense to say case expressions can be abstract to other abstractions
02:36:46 <nmdanny> what I mean is, for example
02:36:58 <nmdanny> instead of using a bunch of statements inside a case expression
02:37:12 <nmdanny> use a list of alternative functors
02:37:41 <nmdanny> similar to how there's a 'choice'/'oneOf' combinator in parsec, but generalized 
02:37:58 <merijn> Choice can be generalised to
02:38:04 <merijn> :t foldr (<|>) empty
02:38:05 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
02:38:12 <nmdanny> yes
02:38:17 <merijn> But what that means depends on the Alternative
02:38:20 <EvanR> :t empty
02:38:21 <lambdabot> Alternative f => f a
02:40:32 <CptnSandwich> hi, i have a problem building lens on ARM using stack. It runs out of memory. is there a way to continue partial builds? I had to do a similar thing with cabal, but i don't know how to do it with stack.
02:42:19 <Lovepon> Shit.
02:42:26 <Lovepon> This is the ugliest code I've ever written.
02:46:35 <Lovepon> YESSSS
02:46:43 <Lovepon> loli-pyon: THANK YOOOUU
02:49:03 <nmdanny> is it possible to monkey patch additional instances to imported/pre-existing types?
02:49:25 <EvanR> yes
02:49:32 <EvanR> just define the instance
02:49:46 <nmdanny> oh right
02:49:55 <merijn> You can just define an orphan instance, with the usual caveat of orphans making your life miserable
02:50:25 <EvanR> how
02:50:53 <Lovepon> merijn: That's dark.
02:51:27 <merijn> EvanR: Multiple identical orphans can trigger all sorts of silent corruption
02:51:40 <merijn> It's fine to define some orphans in an application, but not in a library
02:51:51 <merijn> And god help you if any of your dependencies include the same orphan :)
02:51:53 <EvanR> right, so youd be making someone elses life miserable ;)
02:52:06 * hackagebot readshp 0.1.0.0 - Code for reading ESRI Shapefiles.  https://hackage.haskell.org/package/readshp-0.1.0.0 (Samvh)
02:52:23 <nmdanny> so if I define orphan instances, I should not have my module export them, correct?
02:52:28 <EvanR> or someone else would be making your life miserable, but it wouldnt be endomiserable
02:53:11 <merijn> nmdanny: Instances are always exported
02:53:12 <EvanR> i didnt think you could not export instances
02:53:31 <Lovepon> I'm going to use self-implemented RSA in prod.
02:54:10 <nmdanny> oh
02:54:18 <nmdanny> is there a way to not export instances then?
02:54:23 <merijn> No
02:54:24 <EvanR> nope
02:54:30 <merijn> Instances are always global
02:55:02 <merijn> Globalness is what makes typeclasses sane (as opposed to Scala's implicits), but that means instance MUST be globally unique
02:55:22 <nmdanny> so what if, for example,
02:55:25 <merijn> The easiest way to guarantee that is to always define instance in either 1) the module defining the class or 2) the module defining the data
02:55:48 <nmdanny> if I want to provide a temporary implementation for 'Ord' for a certain type, so that my module could sort it
02:55:49 <merijn> Hence, why orphan instances (instances not defined in either 1 or 2) are bad
02:56:00 <EvanR> theres no temporary instances
02:56:04 <merijn> nmdanny: There's a better solution
02:56:10 <merijn> Just use "sortBy"
02:56:12 <merijn> :t sortBy
02:56:13 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
02:56:24 <merijn> sort is merely "sortBy compare"
02:56:29 <merijn> :t compare
02:56:30 <lambdabot> Ord a => a -> a -> Ordering
02:56:34 <merijn> :t sortBy compare
02:56:35 <lambdabot> Ord a => [a] -> [a]
02:56:39 <nmdanny> ok, but what if it's not necessarily for sorting?
02:56:44 <lyxia> or use newtypes internally
02:56:55 <merijn> nmdanny: Define a newtype and define an Ord instance for the newtype
02:57:03 <nmdanny> oh newtypes, yea that's a good idea
02:58:58 <merijn> nmdanny: Especially since GeneralizedNewtypeDeriving lets you automatically derive all the other instances you want
03:01:51 <nmdanny> is it possible to use something like record update syntax for data constructors that are not records?
03:02:19 <nmdanny> for example if I have the following type: data MessageTree = Leaf | Node MessageTree LogMessage MessageTree
03:02:36 <nmdanny> and I want to update a node's left subtree
03:09:07 <saulzar> nmdanny, Not really - though of course you can define a helper function or a lens to do it.. 
03:09:45 <saulzar> Though, why not just make it a record?
03:12:21 <bizarrefish> Hi all
03:12:45 <srhb> bizarrefish: Hello.
03:12:50 <kuclis> Hello
03:13:45 <bizarrefish> Is there some way to transform a load of functions with monadic output, into a bunch of >>= calls?
03:13:53 <bizarrefish> Example:
03:14:18 <akegalj> I am using quickcheck for testing. I am running things in some custom monad (lets say MonadIO) so therefore Im using QuickCheck.Monadic module. How can I check properties of running a `IO ()`? For example, Tasty package has @?= operator for testing properties inside IO ()
03:15:32 <akegalj> (wait, I think I just figured it out)
03:15:35 <bizarrefish> Say a b and c are functions with output M x. "a b c(b)" becomes do { b1 <- b; c1 <- c(b1); a1 <- a(b1, c1); return a1 }
03:15:59 <bizarrefish> Sorry, I mean "a b (c b)"
03:16:25 <srhb> bizarrefish: I'm unsure what exactly you're asking. do syntax always desugars to applications of (>>=) and (>>)
03:16:45 <bizarrefish> srhb: Right, I was just trying to be succinct.
03:16:56 <lyxia> akegalj: you can test actions that return a value, there's not much you can tell about an IO ()
03:17:05 <bizarrefish> I'd like the a b (c b) expression transformed to >>= and >>
03:17:51 <bizarrefish> a and c are functions x -> Monad x . b is Monad x.
03:18:15 <bizarrefish> So, like do-notation, but implicit. Making function composition 'monad-aware'
03:18:38 <lyxia> akegalj: you can modify the internals of your action so that it returns some meaningful value, or add actions to be run before and after it to examine how the environment changed
03:18:51 <srhb> Sounds quirky. I know of nothing like that. I suppose it could be implemented in TemplateHaskell with quasiquoters, if you have a grammar that makes sense.
03:20:34 <bizarrefish> srhb: I'm now wondering why it hasn't been done. I find myself creating temporaries with do-notation, so monad 'results' can be fed into functions which produce other monads.
03:20:46 <bizarrefish> Am I...DOing it wrong?
03:20:50 <srhb> bizarrefish: probably because we have fmap and (<*>)
03:21:07 <srhb> bizarrefish: Sounds like it!
03:21:08 <srhb> :-)
03:21:11 <bizarrefish> hah
03:21:19 <bizarrefish> So *THATS* what applicative functors are for!
03:21:25 <akegalj> lyxia: I wonder how with tasty it is able to test inside IO (), for example msgpack tests https://github.com/msgpack/msgpack-haskell/blob/master/msgpack-rpc/test/test.hs#L37 . I don't know how @?= could be implemented except some MVar machinery?
03:21:25 * bizarrefish gets it...he thinks
03:21:59 <ocramz> hi there
03:22:00 <srhb> bizarrefish: It would be easier to say with a concrete example :)
03:22:07 * hackagebot freddy 0.1.0.0 - RabbitMQ Messaging API supporting request-response  https://hackage.haskell.org/package/freddy-0.1.0.0 (indrek)
03:22:10 <bizarrefish> So I can take my a -> M b and turn it into an M a -> M b, and then just use standard function composition.
03:22:23 <bizarrefish> Oh wait, no, that's just lifting
03:22:28 <bizarrefish> Meh, I should lift more
03:22:30 <bizarrefish> :P
03:22:58 <lyxia> akegalj: I seem to have misunderstood you, I was talking about testing a value of type IO ().
03:23:02 <srhb> :t (>=>) -- is also useful
03:23:03 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:23:16 <ocramz> Kleisli composition
03:23:18 <lyxia> akegalj: r1 @?= 123 + 456 is of type IO () but it is testing numerical values.
03:23:51 <bizarrefish> :t (<*>)
03:23:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:24:26 <ocramz> is there an IntMap-like data structure that keeps track of the number of inserts/deletions at a given key?
03:24:34 <akegalj> lyxia: but how can Tasty know about the result of r1 @?= 123 + 456 ? Thats whats bothering me. IO won't return any value.
03:24:41 <lyxia> akegalj: it does not test "properties of running a IO ()", but of an "IO Int" I would say
03:24:50 <lyxia> Client Int actually
03:25:21 <lyxia> akegalj: what do you mean, "know about"
03:25:59 <lyxia> akegalj: @?= probably defines an action that checks whether two values are equal, and raise an exception if not.
03:26:02 <srhb> bizarrefish: The monadic equivalent is `ap`
03:29:09 <akegalj> lyxia: yes, thats probably it. Thank you
03:29:11 <Kwoth> Why do we call lists "xs" in pattern matching ? like (x:xs)
03:29:27 <ocramz> Kwoth: just a convention, no meaning
03:29:38 <lyxia> it's the plural of x
03:29:46 <Kwoth> Ah, thanks :)
03:30:17 * padre_angolano prefers hd:tl
03:31:40 <attila_> why do you have to keep duplicating the function name when you're defining its bodies? Is there a reason for not existing a simpler ditto-like symbol for that purpose?
03:32:29 <lyxia> attila_: do you have an example
03:32:49 <Kwoth> I'm just starting out but | seems like to be the thing you are looking for attila
03:33:31 <Kwoth> http://lpaste.net/3045169200554311680
03:33:33 <lyxia> ah, you mean the duplication in the clauses of a function definition
03:34:35 <lyxia> I agree this is odd.
03:34:51 <lyxia> Kwoth: what if you're not matching on numbers
03:35:13 <byorgey> attila_: no particular reason.  It could just as easily have been defined the other way.  For example Agda allows something like this.
03:35:55 <byorgey> attila_: One nice thing about repeating the function name is that each line individually expresses a valid equation.  With some kind of repetition symbol, the subsequent lines don't make sense out of context
03:36:25 <Kwoth> attila_: http://lpaste.net/5866212907225710592 you can pattern match before it
03:36:56 <akegalj> lyxia: do you happen to know does quickcheck have something like @?=
03:37:00 <byorgey> hmm, although "each line individually expresses a valid equation" is not quite true anyway, because pattern-matches are tried in order
03:37:28 <lyxia> akegalj: ===
03:40:11 <akegalj> lyxia: ok, gonna try it
03:45:36 <akegalj> lyxia: but === is of type Property, I would need Property -> IO . So I am having a trouble understaing how can I test inside IO
03:46:25 <attila_> byorgey, well I mean the function type definition would always be there as the first one, and the implementations could all use a ditto symbol
03:46:36 <attila_> but like you said, there's no particular reason, so thanks for the answer
03:48:44 <gozes> so I am trying to build a pdf using the git repo for What I Wish I Knew When Learning Haskell but I get ghc: can't find a package database at .cabal-sandbox/*-packages.conf.d Makefile:20: recipe for target 'includes' failed make: *** [includes] Error 1
03:49:43 <gozes> there is no way to report an issue on the repo and they site where the html version is hosted is broken 
03:49:50 <gozes> so I am at a lost here
03:52:02 <lyxia> akegalj: stop :: (Testable prop, Monad m) => prop -> PropertyM m a
03:52:08 * hackagebot bitx-bitcoin 0.7.0.2 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.7.0.2 (tebello_thejane)
03:58:51 <lyxia> akegalj: stop doesn't seem quite satisfactory though. Can you say more about what you are trying to do? Have you given a look at tasty-quickcheck?
03:59:49 <byorgey> gozes: maybe you need to make a cabal sandbox first?
04:00:12 <byorgey> gozes: try executing  'cabal sandbox init'  before running make
04:00:26 * byorgey really has no idea, just a stab in the dark
04:01:59 <gozes> byorgey, nop now I get includes.hs:4:8:
04:01:59 <gozes>     Could not find module ‘Text.Pandoc’
04:01:59 <gozes>     Use -v to see a list of the files searched for.
04:01:59 <gozes> includes.hs:5:8:
04:01:59 <gozes>     Could not find module ‘Text.Pandoc.Error’
04:02:00 <gozes>     Use -v to see a list of the files searched for.
04:02:01 <gozes> Makefile:20: recipe for target 'includes' failed
04:02:03 <gozes> make: *** [includes] Error 1
04:02:08 <nmdanny> is there a windows utility for pretty printing ghci output?
04:02:32 <MichaelBurge> Is there a typeclass for diffing two values? For the one-constructor case: Maybe something that turns a type A into Diffed A that has Maybes in each constructor's field, that are Nothing if the fields are Equal and Just (Diffed b) if they are unequal.
04:14:12 <akegalj> lyxia: yes, I have seen tasty-quickcheck and this could solve my problems. I am writing similar tests as msgpack-rpc is doing. With tasty there is a simpler solution because tests can be run inside IO. stop is close to what I would like to have, but we have some custom monad stack and I am having a trouble pulling out some values from it. Anyway, will try few solutions more before going to 
04:14:18 <akegalj> tasty-quickcheck. I will write a concreete example in a sec
04:16:33 <akegalj> lyxia: if you look at http://hackage.haskell.org/package/msgpack-rpc-1.0.0/docs/Network-MessagePack-Client.html there is a method execClient :: ByteString -> Int -> Client a -> IO () . I can't pull out value from this execClient (except using ContT or other cps transf) . So for testing I would like to test if some call did return a value inside a Client
04:16:54 <akegalj> lyxia: and Client is MonadIO only
04:17:22 <akegalj> lyxia: I can pull out value from Client with some IORefs but was looking for something simpler
04:26:10 <bizarrefish> Is there such a function :: m a (b c) -> b (m a c) ?
04:28:37 <rbocquet> bizarrefish: sequenceA
04:28:45 <rbocquet> :t sequenceA
04:28:46 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
04:31:13 <srhb> bizarrefish: m a (b c) doesn't make sense as a type if you meant to imply that m is a Monad
04:31:34 <bizarrefish> Sorry, I shouldn't have used m
04:31:51 <bizarrefish> My actual problem is with scala, which I am also in the process of getting to grips with
04:32:13 <bizarrefish> The thing I really want to do: Monad[Map[T, U]] from Map[T, Monad[U]]
04:32:52 <srhb> That does sound like some kind of sequence
04:33:31 <bizarrefish> So, one would partially-apply m with a, giving a functor?
04:33:39 <bizarrefish> Or wouldn't that work?
04:34:21 <srhb> If you had ms :: Map k (m a), then sequence ms :: m (Map k a)
04:34:53 <Boomerang> > sequence . map sequence $ [(1, Just 3)]
04:34:55 <lambdabot>  Just [(1,3)]
04:35:51 <Boomerang> > sequence . map sequence $ [(1, Just 3)]
04:35:52 <lambdabot>  Just [(1,3)]
04:35:54 <merijn> > traverse sequence $ [(1, Just 3)] --simplified?
04:35:56 <lambdabot>  Just [(1,3)]
04:36:05 <Boomerang> Ah yes :)
04:36:30 <merijn> "sequence . map f == mapM f = traverse f" :)
04:37:03 <srhb> I'm not sure if that Scala actually is a Map or a map :P
04:37:12 <bennofs> :t Data.Traversable.sequence :: Monad m => Data.Map.Map k (m a) -> m (Data.Map.Map k a) -- in Haskell
04:37:13 <merijn> Any, bizarrefish's description of what he wants is exactly what Traversible is
04:37:13 <lambdabot> Monad m => Map.Map k (m a) -> m (Map.Map k a)
04:37:24 <bizarrefish> srhb: It's a Map :P
04:37:43 <bizarrefish> So a sequence of name-value pairs
04:38:35 <srhb> > sequence (M.fromList [(1,Nothing)])
04:38:36 <lambdabot>  Nothing
04:38:45 <srhb> > sequence (M.fromList [(1,Just 2)])
04:38:46 <lambdabot>  Just (fromList [(1,2)])
04:44:27 <srhb> In that vein, what are nice monads aside from Maybe to demonstrate functions such as sequence in chat succinctly?
04:44:48 <merijn> list?
04:44:51 <merijn> either?
04:45:24 <srhb> Yeah, those are both good.
04:46:18 <bizarrefish> I recently implemented a free monad in Java.
04:46:33 <bizarrefish> Probably good for proving a point
04:47:45 <ski> bizarrefish : "So I can take my a -> M b and turn it into an M a -> M b" is `(=<<)'
04:48:13 <bizarrefish> Isn't that flip >>= ?
04:48:15 <ski> srhb : state and output, i suppose
04:48:20 <bizarrefish> :t flip
04:48:21 <lambdabot> (a -> b -> c) -> b -> a -> c
04:48:30 <Boomerang> :t (=<<)
04:48:31 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:48:31 <ski> srhb : continuation, perhaps
04:48:56 <ski> @src (=<<)
04:48:56 <lambdabot> f =<< x = x >>= f
04:49:00 <ski> bizarrefish : so, yes
04:49:06 <bizarrefish> Continuation monad is a bit easier to explain now, thanks to promises becoming standard in JS land
04:49:11 <bizarrefish> :)
04:49:35 * ski tries to think of a not too involved continuation example using `sequence' ..
04:49:58 <bizarrefish> Thanks for help peoples :). What is it about haskell..you don't really 'learn it'
04:50:03 <srhb> ski: Output?
04:50:12 <ski> srhb : aka `Writer w'
04:50:16 <srhb> Oh, right.
04:50:27 <ski> srhb : just like input/environment is currently called `Reader r'
04:50:34 <bizarrefish> The reader monad was probably the one which got my attention first
04:50:35 <bizarrefish> Ya
04:50:37 <srhb> "currently called" ? :P
04:50:47 <ski> yeah, since mtl or something
04:52:29 <ski> (i suppose there's a difference between constant input (environment), and an input which you divide&distribute and consume in parts (more like parsing, think supply perhaps))
04:58:25 <ski> ok, here's a somewhat silly example
04:58:42 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
04:58:43 <lambdabot>  Defined.
04:58:58 <ski> @let evalContT :: Monad m => ContT o m o -> m o; evalContT = (`runContT` return)
04:58:59 <lambdabot>  Defined.
04:59:17 <Philonous> I have a (very) long running c function, will ghc be able to preempt it when I call it "safe"ly ? 
04:59:58 <ski> @let allC :: Foldable t => t a -> Cont Bool a; allC as = cont (`all` as)
04:59:59 <lambdabot>  Defined.
05:00:09 <ski> @let anyC :: Foldable t => t a -> Cont Bool a; anyC as = cont (`any` as)
05:00:10 <lambdabot>  Defined.
05:00:32 <ski> > evalCont $ do [n,p] <- sequence [allC [2 .. 9]),anyC [2,3,5,7])]; return (n `mod` p == 0)
05:00:33 <lambdabot>  <hint>:1:47: parse error on input ‘)’
05:00:36 <ski> er
05:00:41 <ski> > evalCont $ do [n,p] <- sequence [allC [2 .. 9],anyC [2,3,5,7]]; return (n `mod` p == 0)
05:00:43 <lambdabot>  True
05:01:13 <ski> srhb : this checks that for every choice of `n' from `[2 .. 9', there exists a choice of `p' from `[2,3,5,7]' such that `p' divides `n'
05:01:43 <m0rphism> Hi, does anyone know where the "Datatypes a la Carte" Paper went? I can't find the PDF anywhere; all links are broken.
05:01:47 <ski> > evalCont $ do [n,p] <- sequence [allC [2 .. 9],anyC [2,5,7]]; return (n `mod` p == 0)  -- removing e.g. `3' from the list of primes, we don't have a prime divisor of `3' and `9' in the list
05:01:48 <lambdabot>  False
05:01:59 <ertesx> Philonous: if at all, then only with -threaded
05:02:11 <ski> > evalCont $ do [n,p] <- sequence [allC [2 .. 11],anyC [2,3,5,7]]; return (n `mod` p == 0)  -- including `11' in the list, we're missing the prime `11'
05:02:13 <lambdabot>  False
05:02:32 <ski> srhb : so, it can be useful, when you want to nested "quantifier"-stuff
05:02:45 <ertesx> i found that ContT is easiest to explain by exposing its definition
05:03:19 <ertesx> and by mostly ignoring callCC
05:03:33 <Philonous> ertesx, Does "If at all" mean "it doesn't work for every C function" or "it's not clear that it works ever" ?
05:03:39 <hpc> :t ($ False)
05:03:40 <lambdabot> (Bool -> b) -> b
05:05:41 <m0rphism> Also, is there an implementation of "Data types a la carte" on hackage? I only found the `syntactic` package, which seems like a recent extension of the technique, but I'm not sure.
05:05:45 <merijn> m0rphism: Have you tried searching Google Scholar? it's much better for finding papers
05:05:45 <ertesx> Philonous: only the threaded run-time can handle a long running C function, because there is no way to preempt it
05:06:29 <srhb> ski: Oh, that is a pretty nice example.
05:06:32 <merijn> m0rphism: As in, Google Scholar finds around 15 PDFs ;)
05:07:36 <srhb> ertesx: I know Cont, was just looking for nice, short examples to vary the tedium of demonstrating various monadic combinators, rather than always using Maybe, or Either e or something :-) 
05:07:49 <m0rphism> merijn: Awesome! I did not knew about Google Scholar. Second version worked :)
05:08:11 <Philonous> ertesx, So the answer to my original question is "no"? That's surprising, because posts like this one seem to indicate otherwise: http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
05:08:14 <ertesx> srhb: well, Cont isn't that interesting without its effects =)
05:08:28 <ertesx> srhb: the simplest effect i can think of is:  abort = ContT . pure . const
05:08:43 <ertesx> :t ContT . pure . const
05:08:44 <lambdabot> r -> ContT r ((->) b) a
05:08:49 <ertesx> whoops
05:08:58 <ertesx> :t ContT . const . pure
05:08:59 <lambdabot> Applicative m => r -> ContT r m a
05:09:02 <ertesx> there we go
05:09:31 <ertesx> srhb: but here is a very interesting ContT effect:
05:09:58 <ertesx> :t \fp m -> ContT (withFile fp m)
05:09:59 <lambdabot>     Not in scope: ‘withFile’
05:09:59 <lambdabot>     Perhaps you meant one of these:
05:09:59 <lambdabot>       ‘writeFile’ (imported from Prelude),
05:10:44 <ertesx> :t \fp m -> ContT (System.IO.withFile fp m)
05:10:45 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> ContT r IO GHC.IO.Handle.Types.Handle
05:11:06 <ertesx> it "unwraps" the continuation of a CPSed function
05:11:44 <ertesx> do h1 <- ContT (withFile fp1 m1); h2 <- ContT (withFile fp2 m2); action h1 h2
05:13:05 <m0rphism> I'm working on a toy compiler and want the AST to change between the different stages, e.g. the typechecker changes type annotations from `Maybe Type` to `Type`, the pattern matching compiler yields an AST without Match-Expression, etc.
05:13:39 <Philonous> ertesx, Never mind, I misread the post
05:14:03 <m0rphism> For this purpose I thought about structuring the AST as functor sums and products as in "Data Types a la Carte". Is this a sane approach, or have better alternatives emerged?
05:14:05 <ertesx> Philonous: the answer is: do not use long-running C functions, because only the threaded run-time can deal with them without blocking the entire program
05:14:47 <ertesx> Philonous: however, i can't remember the last time i compiled without -threaded, so …
05:15:27 <hpc> i usually don't compile with threaded until i notice i need it
05:15:31 <hpc> <<loop>> 4 lyf
05:15:42 <Philonous> ertesx, Well, I have no choice. I need to to communicate with postgres, the available libraries use libpq, and the calls with block
05:16:01 <Philonous> s/with/will
05:16:58 <merijn> Philonous: What was your original question?
05:16:59 <ertesx> Philonous: i think it has a streaming API
05:17:13 <merijn> I like to think I'm reasonably well-versed in FFI and threading :)
05:17:17 <ertesx> Philonous: so there is no need to spend all your query time in C
05:17:33 <Philonous> merijn, Whether ghc can preempt long running c calls 
05:17:34 <ggole> m0rphism: there was an interesting talk on that problem
05:17:48 <merijn> Philonous: It can preempt some, but it's a bit hacky
05:18:12 <merijn> Philonous: Is there any specific reason you can't use the threaded runtime?
05:18:16 <ggole> Which had some tricks that allow you to say something like AST - Match to indicate subtracting a constructor from the possibilities
05:18:25 <Philonous> ertesx, The problem is a query that blocks because of conflicts. 
05:18:32 <Philonous> merijn, No, there isn't 
05:19:09 <merijn> Philonous: Wouldn't it be easier to just use the threaded runtime and do blocking calls inside separate forkIO threads?
05:19:58 <merijn> Additionally, looks like libpg has an asynchronous interface
05:20:23 <ertesx> Philonous: conflicts?
05:20:26 <Philonous> merijn, That's what I'm doing. The question was more academic, and was mostly borne from a misunderstanding of a blog post
05:21:32 <Philonous> ertesx, Inserts with conflicting primary keys, the second insert will block until the first transaction finishes
05:21:40 <merijn> Philonous: https://www.reddit.com/r/haskell/comments/1vsw1z/how_to_work_around_blocking_in_an_unsafe_ffi_call/cew18mv
05:21:51 <merijn> Philonous: 7.8 has an interruptible extension to the FFI
05:22:00 <m0rphism> ggole: Seems interesting, if you don't have to search, I'd be happy to read it :)
05:22:02 <merijn> That still requires the threaded runtime, though
05:23:44 <merijn> Philonous: Oh, you can do things in the single threaded runtime too
05:23:59 <merijn> stackoverflow on libpg mentions: "Just a note for later: libpq has PQsocket function which returns file descriptor for the socket"
05:24:22 <ggole> I think it is https://www.youtube.com/watch?v=FKgv_2E9s_U
05:24:28 <merijn> The file descriptor would allow you to "block" on the IO action without locking up the program
05:25:02 <m0rphism> ggole: nice, thanks for taking the time! :)
05:25:03 <Philonous> Oh, nice. Unfortunately persistent-postgresql doesn't seem to use it. But I might look into that
05:25:12 <merijn> Philonous: threadWaitRead :: Fd -> IO ()
05:25:34 <ertesx> Philonous: i would just use the threaded runtime
05:25:36 <merijn> Philonous: The single threaded runtime uses "select" (or kqueue/epoll/whatever) to block threads waiting for async IO operations
05:25:59 <merijn> Philonous: "threadWaitRead" basically says "unschedule this thread until file descriptor is readable in IO loop"
05:26:06 <Philonous> Doesn't the threaded runtime use epoll/kqueue too?
05:26:11 <merijn> Philonous: Yes
05:26:29 <ertesx> i don't even know why the single-threaded runtime is the default
05:26:59 <Lovepon> Is a random number generator that only loops when every number has been tested flawed?
05:27:03 <merijn> Philonous: The point is that what you want is to "unschedule" a specific haskell thread WITHOUT stopping anything else from running
05:27:18 <Philonous> Oh, also: When using the threaded runtime, will the program block when the number of blocking foreign calls equals the number of capabilities?
05:27:22 <merijn> Philonous: Whereas the blocking C function does stop anything else from running
05:27:37 <merijn> Philonous: It uses separate threads for blocking foreign calls and capabilities
05:27:52 <merijn> i.e. the number of threads in your program is larger than the number of capabilities
05:27:52 <ertesx> Lovepon: what?
05:28:15 <Philonous> Ok, thanks
05:28:21 <Lovepon> ertesx: I don't know how to describe it.
05:29:10 <ertesx> Lovepon: i'll just say "yes" to be sure, because i have no idea what you're talking about, and if it's too complicated to explain, it's probably a bad idea anyway =)
05:29:26 <Lovepon> ertesx: lol
05:29:34 <infinity0> why can't i say 'instance MonadIO m => MonadBase IO m where liftBase = liftIO' even after ':set -XFlexibleInstances -XMultiParamTypeClasses' ?
05:29:35 <Lovepon> ertesx: Basically, an RNG where there's only one big cycle.
05:29:41 <Lovepon> ertesx: Rather than many little cycles.
05:29:57 <Lovepon> I think that's how to say it.
05:29:58 <ertesx> Lovepon: with or without repetition?
05:29:59 <Lovepon> Not sure. Lol.
05:30:05 <Lovepon> ertesx: Without.
05:30:09 <Lovepon> Wait,
05:30:14 <Lovepon> ertesx: What do you mean?
05:30:19 <ertesx> Lovepon: because you're basically explaining AES-CTR
05:30:28 <merijn> Philonous: Incidentally you can actually check at runtime whether you're running using the thread of unthreaded runtime (in GHC)
05:30:46 <ertesx> Lovepon: map (aes key) [0..]  -- that's AES-CTR; one big cycle
05:31:07 <merijn> Philonous: Control.Concurrent.rtsSupportsBoundThreads :: Bool <- This is always False if unthreaded (it's currently always True in threaded, but not sure if that's portable to, say, different OSes)
05:31:10 <Lovepon> Hmm
05:31:38 <merijn> Philonous: So you could actually check and use different codepaths for threaded/unthreaded execution :)
05:32:03 <ertesx> Lovepon: in this construction it's safe, until you reach about the square root of the cycle, because that point it starts to leak that it does not have the birthday paradox
05:32:40 <ertesx> so with AES-128 you could generate about 2^64 blocks, until you start to leak
05:32:49 <Lovepon> ertesx: Leak?
05:32:56 <ertesx> information
05:33:05 <Lovepon> Ah.
05:33:28 <Philonous> merijn, Is that done somewhere? I'll probably add a check and terminate the program with an error message if it detects the unthreaded runtime, just to protect against being surprised by the locking problems later
05:34:20 <ertesx> s/until/before/
05:38:00 <merijn> Philonous: Not sure if it's done somewhere already, but I don't see why it wouldn't work, the current definition of rtsSupportsBoundThreads is trivially obvious
05:38:19 <merijn> Philonous: i.e.: http://lpaste.net/161597
05:39:04 <merijn> Philonous: alternatively you could use getNumCapabilities/setNumCapabilities and check whether you can use more than 1 capability
05:39:16 <W4RH4WK> has anyone had problems with stack setup / build (lts-5.13) where happy segfaults?
05:46:05 <Lovepon> W4RH4WK: happy doesn't segfault for me. Instead, IIRC, I need to bring it to $PATH.
05:46:20 <Lovepon> W4RH4WK: Either bring happy to $PATH or GHC to $PATH.
05:47:06 <W4RH4WK> Lovepon, happy segfaults on my dev server, according to gdb it happend in #0  0x00000000007955b0 in stg_ap_v_info ()
05:47:30 <Lovepon> W4RH4WK: Ah.
05:47:52 <W4RH4WK> i know this is unusual, but since i am only doing a stack setup followed by stack build i don't really know where to start
05:48:58 <W4RH4WK> --verbose led me to happy, and i cannot even do a happy --version without segfault
05:51:36 <W4RH4WK> a similar setup in a virtual box (ubuntu 15.10) works fine, i suspect it has to do with the dev server running a very old centos (gcc 4.8.5) but i haven't any found evidence for this assumption
06:03:58 <merijn> W4RH4WK: Sounds like your install of happy is broken?
06:04:09 <merijn> tbh gcc4.8.5 isn't that old
06:05:35 <sphinxo> Could you do something similar to this with type families? http://lpaste.net/5895178939764047872
06:05:55 <W4RH4WK> merijn, yes that happy installation is broken, but it was installed via stack build... even further, i just redid the whole process multiple times (always removing stack-root) and now happy works but a different package segfaults.
06:14:19 <ertesx> sphinxo: the "standard" way to do it is with DataKinds and GADTs
06:16:02 <merijn> hmm
06:16:11 <merijn> binary is decoding garbage :(
06:16:18 <ertesx> sphinxo: data Person = Alice | Bob | Carol | Dave;  data FatherOf :: Person -> Person -> * where BobFAlice :: Bob `FatherOf` Alice; DaveFBob :: Dave `FatherOf` Bob; FatherTrans :: Father a b -> Father b c -> Father a c
06:17:08 <ertesx> with PolyKinds you can make convenience classes like Preorder, PartialOrder, etc.
06:20:08 <exio4> sphinxo: I think you want to write that in Datalog
06:22:36 <ertesx> s/Father /FatherOf /
06:24:37 <exio4> ertesx: I don't think that's actually useful - you might want the system to be able to know if someone is someone's else grandfather - without having to try manually nor anything
06:26:34 <ertesx> exio4: i don't mind constructing the proofs, and that's what you would do in a theorem prover anyway
06:27:25 <ertesx> you could probably lift it to a class to automate it in simple cases like this
06:28:35 <exio4> if he wants the system to infer relationships, I would still use Datalog
06:28:36 <ertesx> but the type class system can only resolve certain things like transitivity…  for example this one is questionable at best: instance (Father b a) => Son a b
06:31:03 <merijn> gah
06:31:49 <ertesx> exio4: unless you want to write a haskell program
06:32:07 <merijn> So I have a bunch of "b -> Proxy b' b c' c m r" functions and "Pipe b b m r", but I can't for the live of me figure out how to compose those two...
06:32:37 <merijn> Composing the functions is easy...composing pipes is easy...but no clue how I'm supposed to combine them?
06:33:46 <hpc> merijn: terrible idea: expand Pipe and Proxy, and see what djinn comes up with
06:33:49 <ertesx> merijn: (~>) would be an option
06:34:06 <ertesx> i think
06:36:22 <merijn> Initially I had (with fromInput from pipes-concurrency "fromInput input >>~ encode >>~ liftIO . BS.sendAll sock" as a pipeline, but that's apparently wrong, as it only does something once, so I rewrote it to "for (fromInput input) $ encode >~> liftIO . BS.sendAll sock" which worked, although I'm not sure why I need to use "for"
06:36:42 <merijn> ertesx: How does ~> work? I can't plug a Pipe into ~>
06:36:45 <merijn> That's my problem
06:37:04 <merijn> They either want "a -> Proxy" on both sides, or like Proxy on either side
06:37:05 <ertesx> merijn: do you want to sendAll every input?
06:37:09 <merijn> ertesx: Yes
06:37:18 <ertesx> import qualified Pipes.Prelude as P
06:37:23 <ertesx> P.mapM_ f
06:37:29 <ertesx> instead of just f
06:37:32 <merijn> That code actually works fine
06:37:52 <ertesx> oh, wait
06:37:59 <ertesx> it's (>>~), not (>->)
06:38:00 <merijn> My problem is that I now have "Pipe b b m r" (debug printing) but can't find out how to slot it in there
06:38:39 <bitonic> Is there a way to get a list of currently running threads (e.g. a `[ThreadId]`) at runtime?
06:38:40 <merijn> (>~>) :: Monad m => (_a -> Proxy a' a b' b m r) -> (b -> Proxy b' b c' c m r) -> _a -> Proxy a' a c' c m r
06:38:44 <merijn> bitonic: No
06:38:49 <ertesx> merijn: i can't find that operator
06:38:54 <merijn> ertesx: Pipes.Core
06:38:54 <bitonic> merijn: aw, that's disappointing
06:39:15 <merijn> ertesx: But I can't figure out how to compose my Pipe with that
06:39:31 <merijn> I'd need a way to convert "Pipe b b m r" into "b -> Pipe b b m r" to make it fit
06:39:35 <merijn> But I can't see that...
06:40:14 <ertesx> looks like (>>~) is just 'for'
06:40:27 <ertesx> so yeah, i think you should use (>->) instead
06:40:29 <merijn> ertesx: Except that the version using >>~ doesn't work
06:40:32 <merijn> But for does
06:40:35 <merijn> ertesx: Can't
06:40:45 <ertesx> how come?
06:40:55 <merijn> Encode has type "a -> Proxy X () () ByteString (SafeT IO) ()"
06:41:08 <merijn> ertesx: So I wouldn't know how to fit "encode" into the pipeline using >->
06:41:47 <ertesx> i see…  so Encode uses the server/client model instead of the producer/consumer model
06:41:53 <ertesx> but you can convert between them
06:42:13 <ertesx> let me think
06:42:32 <ertesx> wait, no
06:42:36 <ertesx> that's just Producer
06:42:45 <merijn> yeah
06:43:02 <merijn> oh, looks like the docs suggest "for cat encode" to turn it into a Pipe
06:43:09 <merijn> But that's kinda ugly
06:43:39 <merijn> oh
06:43:39 <ertesx> it probably vanishes at run-time anyway
06:43:47 <merijn> (>~>) :: Monad m => (_a -> Proxy a' a b' b m r) -> (b -> Proxy b' b c' c m r) -> _a -> Proxy a' a c' c m r
06:43:51 <merijn> eh, wrong copy
06:43:56 <merijn> toSocket = for (fromInput input) encode >-> test >-> P.mapM_ (liftIO . BS.sendAll sock)
06:44:03 <merijn> I guess that should work?
06:44:46 <ertesx> i think so, with the context i have
06:44:56 <merijn> Whoo
06:44:57 <ertesx> test is the debug pipe, i guess
06:45:02 <merijn> That fixes my decode error too :)
06:45:21 <scshunt> why is Proxy being used here? O.o
06:45:42 <merijn> scshunt: Because Proxy is the base type name of the stuff in Pipes
06:45:45 <scshunt> oh
06:45:59 <ertesx> scshunt: to confuse the reader
06:46:09 <ertesx> and it worked, at least on me =)
06:47:38 <Lovepon> >~> Haskell so moe.
06:54:14 <ertesx> why did we abandon iteratees again?
06:54:27 <merijn> ertesx: Because iteratees were even more confusing :p
06:54:37 <ertesx> ah, i remember
06:54:39 <ertesx> =)
06:56:38 <merijn> On to the next issue
06:56:55 <merijn> A pipeline with "take n" in it, apparently not terminating after n elements... *sigh*
06:57:36 <ertesx> merijn: or a part after the 'take n' yielding more than once
06:58:35 <ertesx> … per await
07:00:30 <merijn> No, it's just hanging
07:03:50 <merijn> I guess I'll just have to implement a proper non-hacky solution instead
07:04:26 <ertesx> pipes is demand-driven, so control actually flows backwards:  in x >-> y, if y never awaits, x never runs
07:04:30 <ertesx> maybe that helps
07:04:46 <statusfailed> Is it bad to use Control.Monad.Except and Control.Monad.Catch together?
07:05:01 <ertesx> and in general, if you have to import Pipes.Core, you're bound to write confusing code
07:05:07 <merijn> I was using Foldl to fold all entries in a pipe
07:05:19 <merijn> And I wanted to use take to limit to only N entries
07:05:27 <merijn> To avoid it blocking after it runs out
07:06:27 <merijn> I'll just add an explicit termination to the channel instead
07:08:11 <Lovepon> merijn: Out of context, that sounds so evil.
07:17:58 <Lovepon> dropdown :: forall k t m. (MonadWidget t m, Ord k, Show k, Read k) => k -> Dynamic t (Map k String) -> DropdownConfig t k -> m (Dropdown t k) 
07:18:23 <Lovepon> Is it only me, or should it have been (Dynamic t (Map String k))
07:18:45 <mettekou> Not directly related to Haskell, but since Coq's IRC is good as dead and I am working in Haskell: is there any literature (or informal reading) around on implementing guarded-by-destructors/structurally smaller calls for inductive types? I've tried to do so myself based on (Giménez, 1994), but translating the predicate directly to a functional language leads to messy and buggy code.
07:18:57 <ertesx> Lovepon: it makes haskell data (k) to presentation (String)
07:19:14 <Lovepon> ertesx: Yes, but why not the other way around?
07:19:14 <ertesx> you probably don't want it the other way around
07:19:22 <Lovepon> ertesx: Hmmm
07:19:32 <Lovepon> ertesx: Why not a presentation to haskell data though?
07:19:34 <ertesx> Lovepon: the dynamic there is only for presentation, i guess
07:19:44 <ertesx> Lovepon: would you want that?
07:19:55 <Lovepon> ertesx: Yes.
07:20:11 <Lovepon> ertesx: For example, if there's a "+", I want to get (+) from that.
07:20:25 <Lovepon> ertesx: In this case, it's impossible, because it returns Ord k.
07:20:29 <Lovepon> ...right
07:20:31 <Lovepon> ?
07:21:06 <ertesx> Lovepon: right, i see…  you need to create an extra type and map that one to functions yourself
07:22:09 <ertesx> even without Ord, there wouldn't be a way to do it, because you can't map functions to strings…  and you probably don't want to map presentation to data anyway
07:22:25 <Lovepon> ertesx: I think I see what they're trying to do now.
07:23:35 <Lovepon> ertesx: Also, how do I insert a line break?
07:23:52 <ertesx> Lovepon: into a dropdown?
07:24:05 <Lovepon> ertesx: Nah. Into the HTML.
07:24:07 <Lovepon> Or DOM.
07:24:16 <Lovepon> I don't really know the specifics of these kinds of stuff. :P
07:24:20 <ertesx> you could insert a <br> element
07:24:45 <ertesx> but that's rarely the right thing to do, unless you actually have a single paragraph with a hard line break
07:24:48 <Lovepon> ertesx: el "br" blank ?
07:24:52 <Lovepon> ertesx: Right.
07:24:54 <ertesx> otherwise using paragraphs (<p>) is the way to go
07:24:56 <Lovepon> ertesx: That's what I was thinking of too.
07:25:20 <Lovepon> ertesx: This is my first time doing webdev.
07:25:32 <ertesx> you should probably learn some HTML basics…  doesn't take too long
07:25:37 <ertesx> HTML is easy enough
07:25:56 <Lovepon> ertesx: I know HTML basics. Kinda outdated, but I think I know.
07:27:14 <ertesx> let me rephrase that: make sure you know some HTML(5) basics =)
07:28:32 <Lovepon> ertesx: Okay, that changes some things. :P
07:33:26 <_o_> Could someone help me with a bit of code? I'm trying to learn haskell and have been struggling for three days on this problem that I could solve in about 2 minutes on any one of a half dozen other languages. I need to read a binary file by name into a collection of bytes which provide O(1) indexing. I also need to print out each of those bytes as hex numbers, e.g. 0xFF
07:34:16 <nmdanny> @pl \f g x y -> f (x ++ g x) (g y)
07:34:16 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
07:34:43 <statusfailed> _o_: sounds like you want the "bytestring" library and the "index" operation
07:34:50 <ocramz> _o_ : Data.Vector provides O(1) indexing, too
07:35:05 <ocramz> but I guess bytestring is more suited
07:35:12 <statusfailed> _o_: you can read a whole file using "readFile" 
07:35:24 <m0rphism> _o_: Try bytestring: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Char8.html#v:index
07:35:45 <_o_> I read a file into a bytestring and can print the characters, but that's as far as I've gotten.
07:36:05 <statusfailed> _o_: there are "strict" and "lazy" variants of bytestring - but maybe just stick with "strict" for now
07:36:06 <m0rphism> _o_: It also provides a corresponding function to read a byte string directly from file: https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Char8.html#v:readFile
07:36:19 <_o_> It wasn't clear to me the advantages of array/vector/bytestring. 
07:36:37 <ocramz> vector is a generic container for packed data
07:36:43 <ocramz> memory-contiguous I mean
07:36:59 <ocramz> bytestring is made for binary data
07:37:07 <_o_> Vector sounds like an array for all practical purposes, while bytestring sounds like a higher level abstraction. I did not see a way to read a file directly into a vector or array though.
07:37:24 <sphinxo> Just seen what you write earlier ertesx, cheers
07:37:50 <sphinxo> s/write/wrote
07:38:08 <_o_> Strict is fine, as I know I will always need to access every byte.
07:38:18 <statusfailed> _o_: Bytestring is just like a vector that's been heavily optimised for a single element type 
07:38:31 <statusfailed> (I think?)
07:39:14 <lyxia> Data.ByteString.readFile
07:39:55 <_o_> I couldn't even figure out how to create an immutable array, regardless of reading from a file or not. The signatures are too weird for me to understand
07:40:31 <statusfailed> _o_: I think you probably want to go with ByteString for this purpose
07:41:22 <ertesx> _o_: ByteString is pretty much equivalent to Vector Word8 from Data.Vector.Storable, except the latter has a nicer API for many things
07:41:28 <_o_> yes, Bytestring seems fine...just need to figure out how to print the hex values.
07:41:57 <ertesx> _o_: and no, you should use bytestring anyway =)
07:42:20 <_o_> Honestly I don't even know how to print a number, or anything that isn't a character.
07:43:01 <ertesx> statusfailed: a storable Vector Word8 is as fast as and sometimes faster than ByteString, an unboxed Vector Word8 is almost always slightly faster
07:43:31 <Lovepon> _o_: Don't worry, you're not the only one. :D
07:43:38 <ertesx> _o_: can you write an integer-to-hex printer yourself?
07:43:46 <ertesx> showHex :: Integer -> String
07:44:11 <ertesx> there is a ready-made function to do it, but try it yourself first
07:44:15 <Lovepon> Hmm
07:44:17 <_o_> I think unboxed would be what I want. Speed is important here as this is (eventually) going to be part of a bytecode interpreter.
07:44:19 <statusfailed> ertesx: Huh, did not know that! :-)
07:44:46 <statusfailed> plus you can mapM_ it I guess?
07:44:55 <ertesx> _o_: the speed difference is minimal, and in your particular example (read and index) probably zero
07:45:30 <_o_> Will showHex work with Word8 -> String?
07:45:39 <ertesx> _o_: storable and unboxed are both unboxed, but storable is also fixed in memory, so the garbage-collector has less freedom
07:45:47 <ertesx> _o_: yes…  later
07:47:11 <ertesx> _o_: btw, do you actually need random indexing?  or do you need traversal?
07:47:16 * hackagebot tai64 0.1.0 - Tai64 Labels for Haskell  https://hackage.haskell.org/package/tai64-0.1.0 (KimAltintop)
07:48:01 <_o_> Does boxed have a lot of memory overhead compared to unboxed? I need random indexing (a lot of it), definitely.
07:48:39 <ertesx> boxed can have anything from negative to a huge memory overhead
07:48:43 <ertesx> compared to unboxed
07:49:15 <ertesx> in other words: your question is too vague
07:51:27 <_o_> A collection of bytes ranging in size from zero to approximately two million.
07:52:03 <_o_> requiring random indexed access to any point in the collection.
07:52:22 <ertesx> in your case the overhead would be huge
07:52:28 <ertesx> but you don't need boxes either
07:53:25 <_o_> So bytestring is not a good fit? Or is there an unboxed version of it?
07:53:33 <ertesx> it is unboxed
07:53:49 <_o_> oh, that is good then
07:54:14 <jophish> _o_: you might want to take a look at Vector.Unboxed or Vector.Storable too
07:55:00 <ertesx> unforuntately there is no readFile for Vector Word8…  i recommend sticking with ByteString for now
07:55:04 <s_aly> Hey I am new to haskell, can anyone help me regarding taking an input from the user?
07:55:22 <_o_> I looked at Vector.Unboxed, but couldn't figure out how to get the data from a file into it. ByteString is the only way I could find to read unsigned bytes.
07:55:54 <ertesx> _o_: there are ways to do it, but really, stick with ByteString…  currently there is no reason to use Vector
07:55:59 <s_aly> what I am basically trying to achieve is to make a functon which reads input from the user using getLine then returns a list seperated by a delimeter. 
07:56:04 <merijn> If you like dirty hacks and awful things you could use the FFI to mmap the file and then (presumably) vector has a way to turn "Ptr Word8" into "Vector Word8"
07:56:28 <ertesx> merijn: storable Vector has, yeah
07:56:46 <_o_> I am looking to keep the code as clean and pure as possible. I am just learning Haskell and want to do it "right".
07:56:46 <jophish> https://hackage.haskell.org/package/vector-mmap
07:56:47 <merijn> Bonus, that way your file is loaded on demand
07:57:03 <lyxia> s_aly: what are you having trouble with?
07:57:05 <ertesx> _o_: good, use bytestring, and don't bother =)
07:57:24 <ertesx> if it helps: i'd do that, too =)
07:58:05 <s_aly> input: "1 2 3 4 5" Output [1,2,3,4,5] all strings. what I have so far is.
07:58:17 <s_aly> readInts :: IO [String]
07:58:17 <s_aly> readInts = fmap (map read.words) getLine
07:58:30 <s_aly> how do i return a list from this function?
07:58:48 <ertesx> s_aly: it's already returning a list (of strings)
07:58:50 <s_aly> so that i can do let a = readInts somewhere else.
07:59:02 <ertesx> and it's not a function
07:59:30 <s_aly> then?
07:59:43 <ertesx> s_aly: a value of type (IO [String]) like readInts, is not a function, but it is a program that returns a list of strings
08:00:03 <ertesx> if you say 'a = readInts', then 'a' is also a program that returns a list of strings (the same program)
08:00:16 <s_aly> i see.
08:00:21 <ertesx> in a do-block you can give the result of readInts a name and refer to it
08:00:37 <ertesx> do strs <- readInts  -- now strs is a name for the result
08:01:51 <ertesx> do-blocks allow you to compose such programs into larger programs, and they can refer to each others' results
08:02:43 * hackagebot tai64 0.1.0.1 - Tai64 Labels for Haskell  https://hackage.haskell.org/package/tai64-0.1.0.1 (KimAltintop)
08:02:49 <ertesx> do line <- getLine; putStrLn line  -- this whole thing is a program, a composition of two subprograms (getLine and putStrLn line), where, as you see, the second subprogram referred to the result of the first
08:04:15 <s_aly> ah nice!
08:04:58 <s_aly> what will the type of line? [String] right?
08:05:08 <ertesx> in my example:
08:05:11 <ertesx> :t getLine
08:05:12 <lambdabot> IO String
08:05:19 <ertesx> what do you think the type will be?
08:05:37 <s_aly> if i am passing it off into another function.
08:05:46 <s_aly> IO [String] ?
08:06:09 <anks> I have a problem with ghc or haskell-mode in emacs. Have any1 of you encounter something like this:
08:06:17 <anks> uFile mode specification error: (file-error "Setting current directory" "no such file or directory" "/usr/lib/ghc-7.8.4/settings: openFile: does not exist (No such file or directory)/")
08:06:33 <ertesx> s_aly: do line <- getLine  -- if (getLine :: IO String), i.e. a program that returns a String when executed, and 'line' is the result of that program, of what type should 'line' be?
08:07:10 <bergmark> s_aly: typically you write functions in the form `a -> IO b', not `IO a -> IO b', then the caller can decide how to get the `a'
08:08:47 <s_aly> okay so if i have seperate functons. let's say readInts gets me the values into a list and i stored it into lines as done above.
08:09:04 <broma0> is there a mapM equivalent for lenses? can I apply a monadic function to a type through a lens such that the result is the updated type in the same monadic context as the action?
08:09:17 <ertesx> s_aly: that question is an exercise…  i welcome you to try to answer it
08:09:20 <s_aly> now let's say I have to pass this list to some other function which will work on this list and output some other list. what would the type signature of this new function be?
08:10:19 <puregreen> broma0: you can just apply the lens itself
08:10:46 <ertesx> broma0: mapM = traverse
08:10:58 <ertesx> except with a stricter type
08:11:06 <puregreen> broma0: e.g. _1 :: (a -> m b) -> (a, x) -> m (b, x)
08:11:20 <broma0> hmm
08:11:41 <broma0> so insead of `myTuple & _1 %~ f`
08:12:01 <broma0> id write traverse (_1 %~ f) myTuple?
08:12:14 <puregreen> you'd write “_1 f myTuple”
08:12:39 <puregreen> or “traverseOf _1 f myTuple” which is the same but might be slightly clearer for other readers
08:12:42 <puregreen> http://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Traversal.html#v:traverseOf
08:12:45 <broma0> didn't know lenses could be used like that
08:12:50 <broma0> nice, thank you
08:12:58 <_o_> Another question: I read that type signatures are optional, but the other day I had a code sample that wouldn't compile without one. Are they sometimes required? If so, are there any guidelines as to when they are needed?
08:13:09 <phadej> they could, also traverseOf gives a bit better type-errors when you screw up
08:13:18 <broma0> _o_: sometimes signatures are required to resolve ambiguities
08:13:22 <ertesx> broma0: every lens is a traversal, so a function similar in shape to 'traverse'/'mapM'
08:13:24 <puregreen> phadej: interesting, didn't know that
08:13:56 <ertesx> _o_: type signatures are required when there is ambiguity
08:14:23 <ertesx> _o_: happens with type classes, when the type doesn't follow from context, but must be known to the compiler
08:15:04 <glguy> _o_: There's something called the "monomorphism restriction", which doesn't have to do with ambiguity, but exists to stop things that look like values that would be computed once 
08:15:18 <glguy> from being computed many times. You might look up that term; it was probably what you ran into
08:15:23 <_o_> I think I was trying to create an array or Ints, something like a = array (0,1) [(0,0),(1,1)]
08:15:43 <_o_> oops, array OF Ints, not OR
08:16:15 <_o_> Not sure how that would be ambiguous?
08:16:25 <glguy> It's not
08:16:27 <glguy> array (040,041) [(040,040),(041,041)] 07:: (Num i, Num e, Ix i) 07=> Array i e
08:16:33 <ertesx> _o_: rule of thumb: you should write type signatures for top-level definitions…  in a language like haskell, where for example the arity does not necessarily follow from the code, types are very important documentation
08:16:38 <glguy> The issue is that it coudl be used at many different types
08:16:48 <glguy> so every time you used it it would have to re-evaluate, which might be surprising
08:17:43 * hackagebot tai64 0.1.0.3 - Tai64 Labels for Haskell  https://hackage.haskell.org/package/tai64-0.1.0.3 (KimAltintop)
08:17:44 <_o_> glguy, I really don't understand the type signatures for arrays. Finally gave up trying to use them.
08:20:37 <puregreen> _o_: have you imported Data.Array.IArray instead of Data.Array?
08:21:03 <puregreen> _o_: there are 3 things that can be ambiguous about a created array:
08:21:14 <puregreen> 1. the type of the array itself (Array, UArray, etc.)
08:21:21 <phadej> puregreen: e.g. () Just [1, 2, 3] vs. traverseOf () Just [1, 2, 3]
08:21:28 <puregreen> 2. the type of the index (usually Int but others are possible)
08:21:31 <puregreen> 3. the type of elements
08:21:35 <_o_> I initially wanted to use IArray, but could never get one to compile. 
08:22:00 <phadej> later have a bit more local error type, with real world code it might save you from troublea
08:22:10 <phadej> e.g. when you don't really have a Traversal
08:22:22 <puregreen> if you import Data.Array then the type of arrays is fixed to Array and *usually* the other types can be inferred easily, but if you import Data.Array.IArray then you have to specify what kind of array you want, yeah
08:23:12 <Kwoth> Is there a route one should take while learning haskell, or just reading LYAH and doing 99 question on haskell.org and project euler?
08:23:52 <srhb> Kwoth: https://github.com/bitemyapp/learnhaskell
08:23:57 <srhb> Kwoth: Some suggestions there.
08:24:07 <puregreen> _o_: unless you stumble upon monomorphism restriction, in other cases GHC should be able to infer your type unless it's genuinely ambiguous (e.g. when you write «show (read "foo")» or something)
08:24:18 <Kwoth> thanks a lot srhb 
08:24:26 <puregreen> _o_: if you show your code, we'll tell you what the cause is
08:25:53 <puregreen> Kwoth: also there's https://github.com/haskell-learning-group/ if you learn better with a mentor
08:26:43 <srhb> puregreen: Oh, I didn't know of that.
08:27:23 <Kwoth> puregreen: that looks amazing. thanks
08:28:04 <YellowOnion> could someone help me debug a segfault?
08:28:24 <YellowOnion> code works perfectly fine in vanila ghc, but with llvm segfault
08:32:18 <_o_> I don't have access to my code right now, thanks. Anyway, looks like I am using ByteString instead of an array for this use anyway.
08:33:05 <_o_> I am curious about the differences between immuatble arrays and immutable vectors. They seem to be largely redundant.
08:40:33 <runeks> Is there any compelling reason to do what hlint says, and change
08:40:35 <runeks> verifyAndStorePayment chanID =<< return . toChannelPayment =<< getUpdatePayment =<< getMessage
08:40:40 <runeks> to
08:40:41 <runeks> verifyAndStorePayment chanID =<< fmap toChannelPayment (getUpdatePayment =<< getMessage)
08:41:38 <bergmark> verifyAndStorePayment chanId . toChannelPayment =<< getUpdatePayment =<< getMessage
08:41:48 <srhb> runeks: Not really, but that looks like a prime candidate for do notation anyway.
08:42:04 <srhb> runeks: It's just always superfluous.
08:42:17 <anks> Hi, does any1 of you know how to get around this problem: I've built my app with stack, it worked fine, but know i want to configure cabal (# cabal configure) to use ghc-mod but it stops with the error: at least some dependencies are missing.. What the?
08:42:24 <runeks> srhb: It's used as a single line within a do notation block
08:42:42 <runeks> bergmark: Looks a lot better!
08:42:55 <runeks> That's what I (and hlint) was missing I think
08:45:28 <YellowOnion> I think ghc/llvm is not at all tested on windows, even a simple hello world has issues...
09:02:57 <nitrix> Is there such thing as `foo f [1..]`, where `foo` is a monadic scanl ?
09:03:19 <nitrix> Like, it's doing >>= between each elements of the list?
09:03:40 <nitrix> They'd have to be functions though, but yeah.
09:03:58 <nitrix> Oh actually, no, the function's f :/
09:04:05 <nitrix> Now I'm confused.
09:04:06 <paolino> :t foldr (>>=)
09:04:07 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ a -> b
09:04:07 <lambdabot>     Expected type: (a -> a) -> (a -> b) -> a -> b
09:04:07 <lambdabot>       Actual type: (a -> a) -> (a -> a -> b) -> a -> b
09:07:01 <lyxia> nitrix: foldlM?
09:11:56 <Zemyla> :t foldr . ((=<<) .) -- nitrix
09:11:57 <lambdabot> (Monad m, Foldable t) => (a -> a1 -> m a1) -> m a1 -> t a -> m a1
09:12:26 <paolino> :t foldr (flip (>>=))
09:12:27 <lambdabot> (Monad m, Foldable t) => m a -> t (a -> m a) -> m a
09:12:45 * hackagebot monad-time 0.2 - Type class for monads which carry the notion of the current time.  https://hackage.haskell.org/package/monad-time-0.2 (arybczak)
09:21:54 <paolino> :t foldl (>>=)
09:21:55 <lambdabot> (Monad m, Foldable t) => m a -> t (a -> m a) -> m a
09:28:34 <ryantrinkle> would there be any performance advantage to having a mutable array over a few unboxed IORefs in a record?
09:29:49 <dolio> Maybe.
09:37:23 <nitrix> How come I can install `directory` on windows? I'm using Haskell's Platform' mingw+mysys.
09:37:39 <nitrix> It's complaining it cannot do a ./configure :|
09:37:46 * hackagebot log 0.4 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.4 (arybczak)
09:41:35 <nitrix> I have to manually install it and run autoreconf -fi ?
09:47:46 * hackagebot consumers 1.1 - Concurrent PostgreSQL data consumers  https://hackage.haskell.org/package/consumers-1.1 (arybczak)
10:01:58 <srhb> nitrix: _can_ install?
10:06:38 <infinity0> i have a function f :: s -> (a, s) which ideally i don't want to change the signature of, and i want to do something like "(fst f, Map.alter (snd f) k m)", is that possible?
10:07:19 <infinity0> i.e. somehow save the first return-value of f and make it escape out of Map.alter (which calls it)
10:08:44 <Peaker> infinity0: Map.alter doesn't seem to let you escape
10:08:53 <Peaker> infinity0: Can you use the lens library?
10:09:09 <infinity0> i could, how would it help?
10:09:43 <Peaker> infinity0: with lens, you can use the "at" lens instead of "alter", and then there are many ways you can have your function compute the new value and return an extra result
10:10:23 <infinity0> Peaker: ah got it, thanks
10:10:50 <paolino> how much happiness is allowed for beta-reduction implementation ?
10:11:34 <srhb> paolino: Lots!
10:11:46 * paolino boings around
10:12:42 <Peaker> infinity0: I think this should work, for instance: zoom (at k) (state f)
10:13:34 <Peaker> infinity0: or rather: runState (zoom (at k) (state f)) m
10:15:53 <Peaker> infinity0: another option: m & at k %%~ swap . f   (Use the (,) Functor as your "effect" for the "at" lens)
10:16:08 <Peaker> infinity0: (though f ought to return the tuple swapped for that to work)
10:17:01 <infinity0> Peaker: got it thanks, i'll have to spend some time looking at the background, there's quite a bit of theory here :)
10:20:35 <lpaste> dedgrant pasted “ScopedTypeVariables necessity in instances?” at http://lpaste.net/161608
10:21:00 <dedgrant> ^^ Is it possible to rewrite the instances without ScopedTypeVariables?
10:24:31 <srhb> infinity0: The explicit version is ruled out for some reason? ie. g s = let (a, s') = f s in (a, ...) ?
10:25:53 <glguy> dedgrant: You can use a function like this to avoid the scoped type variables
10:25:53 <glguy> withHvalProxies :: (Proxy a -> Proxy as -> HVal (a :* as) z) -> HVal (a :* as) z
10:25:54 <glguy> withHvalProxies k = k Proxy Proxy
10:26:48 <s_aly_> I am writing a program. which will take a list as input. However the output needs to be dependent upon the input. how can one achieve that?
10:27:01 <s_aly_> like [1,2,3,4,5] to "SOME TEXT {1{2{SOME TEXT 3 SOME TEXT}4}5} SOME TEXT"
10:27:01 <s_aly_> and [1,2,3] to "SOME TEXT {1{SOME TEXT 2 SOME TEXT}3} SOME TEXT"
10:28:24 <srhb> s_aly_: Your examples are not quite enough to provide a clear specification for what the program should do. Could you try to explain it instead?
10:28:31 <Peaker> infinity0: if you know the "traverse" function, much of it is just a generalization of that :)
10:28:36 <dedgrant> glguy: Oh that is lovely ty
10:28:42 <Peaker> infinity0: and some fluffy syntax
10:30:26 <dedgrant> glguy: Very structured I like it. Good form in segue to explicit type application.
10:30:26 <Ferdirand> most interesting programs have their output depend on their input, that is not much to say
10:30:28 <kadoban> s_aly_: Which part are you having trouble with? It's a tad hard to tell. Or just don't know where to even start?
10:32:28 <s_aly_> kadoban, no idea where to start.
10:34:05 <kadoban> s_aly_: Will the input look exactly like  [1, 2, 3,4,5] ? If so you can use "read", especially if this is just for practice. That can help convert your input to a value of type [Int] or whatever you like. Would that give you enough to start with?
10:34:36 <kadoban> s_aly_: Once it's a list, you can of course just use any kind of the usual functions on it, like length, or do whatever logic you're attempting to based on the length.
10:35:05 <s_aly_> yes kadoban this is for practice. the ordering will indeed be this.
10:35:39 <s_aly_> My end goal actually is to output the tex code for a tree from a list of given nodes. Now the output code somewhat depends on the number of elements in the input list. So trying to think how one will be able to achieve that.
10:37:43 <kadoban> Hmm, I'm not sure I understand what that logic would be, I dunno tex very well.
10:38:55 <hodapp> s_aly_: you might take a look at how Aeson achieves it with its ToJSON typeclasses and the like.
10:39:49 <s_aly_> hodapp, Aeson?
10:40:05 <hodapp> s_aly_: a Haskell library for turning things to/from JSON.
10:40:41 <hodapp> it may give a helpful example for how to output strings for other languages
10:40:56 <s_aly_> kadoban, the final output will basically be something like http://pastebin.com/e1Nj59Nm
10:41:22 <s_aly_> it's very systematic. I just don't know how to go about it.
10:41:37 <s_aly_> hodapp, thanks! I will look into that.
10:43:01 <s_aly_> i only need to output that. No reading.
10:45:25 <Ferdirand> s_aly_: looks like you want a list of tuples, not a plain list
10:46:19 <s_aly_> tuples?
10:50:18 <OnkelTem> Folks, I can't start. I thought I can get Haskell editing/debugging in an IDE and I've installed Haskell plugin in PhpStorm, but honestly I have not an idea how it is supposed to work. It requires ghc-mod and cabal which I installed using `stack install`, but it was not enough and it claims it can list some packages using certain ghc-pkg, which is not installable via `stack`. Now I'm reading installation
10:50:20 <OnkelTem> instructions and seems like it wants "Haskel platform". What?! Which platform? I alreay has platform and it's called stack!
10:50:56 <OnkelTem> have*
10:51:54 <s_aly_> also are there any open source haskell projects out there which a beginner might be able to contribute to?
10:52:11 <srhb> OnkelTem: Have you considered trying something much simpler, like a simple non-IDE editor and invoking ghc/ghci directly from your terminal?
10:53:39 <srhb> OnkelTem: If the IDE installation is a non-starter for you, the easiest solution may be to simply drop it (for now -- especially if it relies on Haskell Platform)
10:54:23 <OnkelTem> srhb: How does Haskel Platform relate to stack? Is it bigger or smaller or it's a different kind of things
10:54:43 <suppi> OnkelTem, you might want to try atom instead https://atom.io/packages/ide-haskell
10:54:45 <srhb> OnkelTem: It's a distribution of GHC and some packages from Hackage, widely regarded as obsoleted by Stack and other solutions
10:55:32 <hpc> s_aly_: cabal has some things it needs imo
10:55:36 <OnkelTem> Great, then I don't want to use any obsolete stuff :)
10:55:57 <hpc> s_aly_: like, if you run "cabal check" it's meant to do a sanity-check of your package and make sure things aren't broken
10:55:58 <srhb> OnkelTem: Agreed, but your IDE might rely on Haskell Platform and not support stack yet.
10:56:18 <srhb> OnkelTem: So you might want to pick another (for now) or simply not use an IDE (for now) -- it's completely unnecessary to get started.
10:56:25 <hpc> s_aly_: but it misses a lot of stuff - perhaps make some terribly broken packages and see how cabal freaks out
10:56:51 <OnkelTem> Oh, ok. Then I'm better sit and wait until stack will be supported
10:57:38 <srhb> OK :)
10:57:39 <OnkelTem> meanwhile I can use another editor, right :)
10:57:43 <srhb> Yep!
10:58:33 <srhb> OnkelTem: Any text editor will suffice. In my experience, Haskell IDEs are quite immature and the sheer mucking around to get them to work properly gets in the way of learning Haskell, if that's what you're doing.
10:59:55 <hpc> side-point: getting comfortable programming without a full IDE makes you a better programmer in general, and haskell is particularly amenable to it since it's relatively light on perfunctory syntactic crap
11:00:25 * srhb shrugs
11:00:55 <infandum> Is it me or is construct from Data.SuffixTree incorrect? construct "BANANA", the classic example, is totally wrong. Am I imagining that?
11:03:29 <MichaelK> Hi, suppose I have a simple wrapped type `data Wrapper a = Wrap a`. Is there a way to automatically derive instances of all single-parameter classes for `Wrapper`?
11:03:56 <hpc> no
11:04:02 <hpc> but also yes
11:04:19 <hpc> if you change data to newtype and use generalized newtype deriving, and specify each class you want to derive
11:04:49 <hpc> or if you make Wrapper a type alias, which i expect would be defeating the purpose
11:04:51 <srhb> infandum:I think you're imagining that.
11:05:10 <srhb> infandum: I base this on googling, so maybe I and my search bubble are both wrong. :-)
11:06:11 <MichaelK> hpc: well that's the thing, it seems "possible" to do it without explicitly specifying the classes ("possible" because it's something that I think could be implemented without too much trouble, but I'm not sure can currently be done)
11:06:25 <infandum> srhb: haha, so what did you get when you used 'construct "BANANA"'?
11:06:34 <hpc> you'd need a list of the type classes in scope
11:06:37 <srhb> infandum: Node [(mkPrefix "ANANA",Leaf),(mkPrefix "BANANA",Leaf),(mkPrefix "NANA",Leaf)]
11:06:39 <infandum> I got: Node [(mkPrefix "ANANA",Leaf),(mkPrefix "BANANA",Leaf),(mkPrefix "NANA",Leaf)]
11:06:44 <infandum> yeah, but that's wrong, right?
11:06:45 <hpc> which there's not really any good way to get
11:06:59 <hpc> maybe if you really really want to, you can use TH
11:07:01 <srhb> infandum: No, why?
11:07:22 <scshunt> s_aly_: what sort of project are you looking for?
11:07:24 <MichaelK> hpc: TH doesn't seem safe enough though
11:07:29 <infandum> srhb: https://upload.wikimedia.org/wikipedia/commons/d/d2/Suffix_tree_BANANA.svg
11:07:33 <infandum> that should be the answer
11:07:54 <infandum> the first three at least should be "A", "BANANA", and "NA"
11:08:53 <infandum> unless, it's collecting the results of the tree, but that's not what a suffixtree is
11:09:19 <s_aly_> scshunt, anything really, something which would in my knowledge of haskell. tbh I find coding for a project and contributing something far more motivating rather than building something which will just lie on my hdd.
11:09:38 <scshunt> yeah, that's fair :)
11:09:57 <scshunt> I have a project I started a while ago which resulted in a yak shaving and not a whole lot of progress, but at least I put it on github :P
11:11:34 <s_aly_> scshunt, hahaha nice! xD
11:13:37 <srhb> infandum: What if we call the Wikipedia one the expanded suffix tree? :-)
11:13:53 <srhb> infandum: No, I don't know.
11:14:05 <srhb> I only vaguely remember this whole concept.
11:14:51 <srhb> I would THINK that it's just the compact suffix tree, and it's probably built directly like that based on the algorithm used.
11:15:19 <infandum> Isn't the suffix tree already a compact trie?
11:17:16 <srhb> Maybe some insight can be gleaned from skimming the paper they're referring to in the Haddocks?
11:19:50 <infandum> srhb: Well the example in that paper works in the code at least
11:24:15 <infinity0> Peaker: '(at k) %%~ (f v) $ m' worked, thanks a lot!
11:24:34 <infinity0> the "s" was what i was mutating so i didn't need to flip f or anything like that
11:25:23 <ntnt> how many cups of coffee should I drink before playing with the ContT (the monad transfomer for the continuation monad)
11:26:28 <infinity0> ntnt: i read this yesterday http://www.haskellforall.com/2012/12/the-continuation-monad.html was very easy to follow
11:26:44 <ntnt> that guy is genius
11:26:47 <ntnt> haskell for all is gold
11:27:01 <infinity0> it doesn't mention callCC (you don't need it) but then this makes it fairly easy to understand https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style#Example:_a_complicated_control_structure
11:27:20 <infinity0> and to understand "how it works" the source code is actually fairly easy to follow (after you've read the previous stuff)
11:27:41 <Peaker> infinity0: with lens it is more customary to use:  m & at k %%~ f v
11:27:50 <Peaker> infinity0: but you can of course use that form too :)
11:29:06 <infinity0> ah right & is just $ flipped
11:30:20 <shachaf> I would say that it's more customary to use e.g. traverseOf (at k) (f v) m
11:37:45 <MichaelK> What's better: stylish-haskell or fix-imports? (for eliminating unneeded imports, etc)
11:43:48 <srhb> infandum: Actually I get more and more confused with it
11:44:09 <srhb> infandum: Consider constructWith ['a'..'z'] "banana$"
11:45:13 <ntnt> say I'm in Monad m1 , which also has foo :: ... ; is there a way to then define a new "m2, which has a bar :: " where the impl of bar calls foo ?
11:45:32 <ntnt> so m2 is sorta like "context-dependent on m1", where bar (something that m2 implemnets) calls foo (something tha tm1 impls)
11:45:42 <infandum> srhb: Yeah, I was getting different answers with different alphabets...which makes no sense
11:47:39 <infandum> srhb: Ah, so it does work, with the terminator
11:47:41 <infandum> weird
11:48:29 <infandum> construct "BANANA$" works. I wonder why
11:53:01 <srhb> infandum: At this point I have no idea, am inclined to label it all magic and back away slowly.
11:56:07 <infandum> haha bout right
11:56:23 <srhb> infandum: Well, as long as the last character is not in the alphabet, I guess it... sort of makes sense
11:57:05 * srhb shrugs and stops looking at weird libraries
11:57:09 <srhb> :-)
12:06:13 <infandum> "weird" haha
12:16:03 <i_am_iphone> is anyone else using spock?
12:16:51 <puregreen> i_am_iphone: me
12:18:32 <pkug> I wanted to write a little function for character encoding, similar to the one from 99 problems but with list flattened, so far i have this but for some reason it looks ugly to me (i'm a newcomer.. but let with if-then-else isn't very welcome right?), here it goes: let encstr x = concatMap (\x -> let l = length x; c = take 1 x in if l == 1 then c else (show l) ++ c) (group x)
12:18:36 <i_am_iphone> puregreen cool, me too. i like it. seems to avoid the template magic of yesod.
12:19:21 <i_am_iphone> i'm a bit worried given the crowded web framework space and smalll userbases development will peter out with all the other options
12:19:40 <i_am_iphone> like snap and scotty
12:21:23 <puregreen> i_am_iphone: I like Spock but I haven't ever done webdev before or used other frameworks so I really don't know. I feel something like “ehhh it's too frameworkish” about Yesod; I couldn't figure out Snap after spending *a week* on that; so I ended up with Spock.
12:21:34 <pkug> is this style ok in Haskell or rather very unhaskell'ish ? i'd often find myself using something like that when i need to decide upon condition what to return (if-then-else), how does one get away from this imperative thinking habit/style?
12:22:09 <hpc> use pattern matching
12:22:13 <i_am_iphone> puregreen well with spock there's a consistency to all the route types
12:22:30 <i_am_iphone> once you understand 1 or 2 you can lookup everything in the docs
12:22:52 * hackagebot postgresql-transactional 1.0.0 - a transactional monad on top of postgresql-simple  https://hackage.haskell.org/package/postgresql-transactional-1.0.0 (patrick_thomson)
12:22:58 <i_am_iphone> with yesod there's all these different ways in which you have to "know" the TH DSL gets used
12:23:56 <sm> but if you have to build many web apps, the TH is pretty practical
12:24:23 <sm> there's minimal repeated boilerplate
12:24:50 <ertesx> pkug: you should pattern-match instead
12:25:55 <ertesx> pkug: case x of [c] -> {- ... -}; _ -> {- ... -}
12:26:12 <ertesx> pkug: now you also don't need concatMap, because 'c' is actually a list *element* rather than a singleton list
12:27:30 <pkug> ertesx, hpc: like this: let encstr x = concatMap (\x -> let l = length x; c = (take 1 x) in case l of 1 -> c; _ -> (show l) ++ c) (group x)
12:27:33 <pkug> ?
12:27:59 <ertesx> pkug: no…  remove the 'let' completely
12:28:08 <ertesx> pattern-match on the *list*, not its length
12:29:45 <ertesx> pkug: i just saw that you need the length, so leave the 'let' for that purpose, but do not use 'take' there
12:29:50 <i_am_iphone> sm it seems like spock would be more composable though because everything is just functions and monads
12:32:19 <agocorona> anything that relies in routes can not be composable
12:32:27 <sm> maybe so, but I have the impression yesod has seen the most use in real-world web apps
12:32:53 <sm> ah, agocorona is here
12:33:19 <agocorona> the routes sould no have an special syntax. they must be part of the monad in order to be composable
12:33:34 <i_am_iphone> that's probably true, it's been around for the longest
12:33:47 <sm> I guess yesod achieves some composability with its subsites mechanism
12:34:08 <ertesx> i_am_iphone: happstack (formerly known as hAppS) is older
12:34:08 <i_am_iphone> agocorona so my understanding is that there routes are DSL hard coded in yesod (at least at the end-user layer)
12:34:32 <i_am_iphone> whereas they're specified monadically in spock
12:35:06 <sm> if you want composability, you should check out agocorona's alien technology
12:35:15 <agocorona> i_am_iphone:  i mean that they routes should be monadic but in the same monad than the rest of the application
12:35:16 <i_am_iphone> sm?
12:35:34 <i_am_iphone> i'm not sure what rest of the application means
12:35:44 <agocorona> sm alien technology? it is just functiona programming ;)
12:35:48 <agocorona> functional
12:35:50 <sm> :)
12:36:17 <i_am_iphone> ok i should get back to work, otherwise i'm not going to get much sleep tonight
12:36:28 <ertesx> yesod is actually rather peculiar in that it isn't composable in the same way as pretty much any other framework…  it's complicated and heavily relies on magic…  you don't learn yesod, you don't use yesod, you invoke yesod
12:36:43 <sm> transient etc. looks sufficiently advanced that I must call it alien technology or magic at the moment
12:36:56 <danilo2> Hello guys! I'm using stack and rying to install a project and Im gettign a strange error - about two versions of transformers - one required by the project and the secodnd by ghc-7.10.3 itself. I dont knw why stack cannot just sandbox the things. Anyway buuild fails because of that: http://lpaste.net/161623
12:37:14 <danilo2> Does naybody know what can I do? its a clean ghc installation and clean project setup
12:38:05 <sm> danilo2: the problem seems to be in your project's cabal file
12:38:24 <sm> I think it indirectly depends on multiple versions of the same package. :)
12:38:33 <EvanR> any sufficiently curious person will find magic indistinguishable from impressive but mundane engineering
12:39:24 <agocorona> sm: I want the opposite: to make things look easy
12:39:26 <danilo2> sm: that's unlikely because the project compiles ok on other systems (on osx, windows and on some linuxes) - I'm using gentoo and it seems that something may be strange setuped with the ghc. But to be honest i dont know what
12:39:51 <danilo2> sm: our cabal files do not provide any constraints over the versions, we use the stack lts-5.14
12:40:19 <danilo2> sm: if there would be conflict with the versions stack would not start compilign - the error is thhrown after 50 packages succesfully compiled
12:40:29 <sm> agocorona: I meant that as a compliment btw. It sounds amazing
12:40:52 <sm> I appreciate your efforts to make things easier
12:41:15 <agocorona> sm: thanks
12:41:38 <ertesx> no haddocks…
12:41:59 <sm> danilo2: sounds strange, does stack build --dry-run succeed then ?
12:42:19 <danilo2> sm: yes
12:42:56 <agocorona> EvanR:  for me the way the OS handle file IO is magic. Simply we take it for granted
12:42:56 <danilo2> sm: another strange thing is that when I run ghc-pkg list on my mac I see that it lists transformers-0.4.2.0 as ghc dependency, on gentoo it is transformers-0.4.3.0 ...
12:43:51 <agocorona> A computer is a box full of magic
12:43:58 <EvanR> agocorona: afaik its very impressive engineering, im thinking of the performance techniques
12:46:07 <agocorona> EvanR:  and the way the OS convert something asynchronous with a lot of interruptions interruption handlers like file IO in something that look synchronous and boring like readFile
12:46:48 <sm> that was the big mystery when I started programming
12:47:01 <EvanR> multitasking? 
12:47:13 <EvanR> i didnt even think of that, nice abstraction ;)
12:47:22 <sm> yeah. "How can you make the plane go across the screen, and make the bomb fall.. AT THE SAME TIME ??"
12:47:39 <athan> Is RealWorld an instance of Typeable?
12:47:50 <ertesx> TransIO looks like a beast in the same way yesod's GGGGGGGGGGGGGGGGHandler looks like a beast
12:48:39 <EvanR> sm: with a parallel combination operator! plane <> bomb
12:49:13 <sm> oh sure, with your alien technology from the future
12:49:31 <EvanR> now thats just language
12:49:44 <EvanR> it runs on imagination hardware
12:50:35 <ertesx> athan: with GHC 7.10 every type is
12:52:49 <athan> ertesx: yisssss :D
12:52:50 <athan> thank you
12:53:05 * EvanR idly wonders wth athan is up to
12:53:06 <athan> I've got a ST hashtable I'm trying to store by converting it to Dynamic :D
12:54:33 <ertesx> athan: that won't help
12:55:17 <ertesx> at the time when you fromDyn*, you won't get its 's' to unify with the 's' from the other runST
12:55:19 <athan> ertesx: how do you mean?
12:55:27 <athan> agh sheeyat
12:55:31 <athan> well... we'll see
12:55:50 <EvanR> heh
12:56:24 <ertesx> athan: just try it within the same ST thread…  won't work
12:56:39 <pkug> ertesx: thanks for the comment, i was AFK for a moment.. if i don't use take in let then how would it suppose to grab only one character (string needs to be "compressed") ?
12:56:57 <ertesx> pkug: the pattern match gives you the character
12:58:17 <agocorona> ertesx: you mean the haddocks of transient? It does not compile in the hackage (because the cabal version)
12:59:17 <ertesx> agocorona: i see…  i've had a brief look at the source code to get an idea
12:59:55 <athan> exio4: It works :)
13:00:14 <athan> I explicitly need to convert it to IO though, it won't work with runST
13:00:28 <athan> because it's not technically "for all" s, only for Typeable s =>
13:00:54 <ertesx> athan: then you could just as well stToIO
13:00:58 <ertesx> or whatever it's called
13:01:05 <ertesx> it isn't even unsafe
13:04:48 <MichaelK> Is there any way to force export of a function from an installed package? (i.e. without modifying the package)
13:05:43 <enthropy> is there a benefit to reusing a [] that is an argument to a function in the recursive call?
13:06:31 <enthropy> f [] r = f [] (g r)  -- vs.   ( f []@empty r = f empty r )
13:06:37 <Cale> no
13:06:43 <Cale> also it would be empty@[]
13:06:51 <enthropy> yeah
13:07:14 <Cale> All empty lists are actually pointers to the same thing.
13:07:15 <enthropy> because there's only one []?
13:07:17 <Cale> yeah
13:07:53 <dolio> Also there is no advantage to 'f l@(x:xs) r = ... g l ...', most likely.
13:07:53 * hackagebot binary 0.8.3.0 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.3.0 (LennartKolmodin)
13:07:58 <Maxdamantus> That definition restricts the possible type of `f` too.
13:08:07 <dolio> Over f (x:xs) r = ... g (x:xs) ...
13:09:05 <dolio> As I recall, monochrom tested it a while ago.
13:15:10 <pkug> ertesx: would this pass: let encstr x = concatMap (\x -> let l = length x in case x of [c] -> [c]; (c:cs) -> (show l) ++ [c]) (group x)
13:33:22 <shanemikel> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
13:33:23 <lambdabot> f a b = a (\ c _ -> b c) b
13:33:24 * hackagebot pred-set 0.0.0 - Simple cached predicates  https://hackage.haskell.org/package/pred-set-0.0.0 (athanclark)
13:36:27 <athan> @djinn (a -> a) -> a
13:36:27 <lambdabot> -- f cannot be realized.
13:36:29 <athan> :D
13:36:54 <athan> so djinn is... "predicative"? :S
13:43:34 * hackagebot pred-set 0.0.1 - Simple cached predicates  https://hackage.haskell.org/package/pred-set-0.0.1 (athanclark)
13:45:29 <EvanR> i see a package to efficiently convert a bytestring to a hex string, but is there a lazy three words that can do this without installing a package
13:47:08 <Cale> :t showHex
13:47:09 <lambdabot> (Integral a, Show a) => a -> ShowS
13:47:29 <Cale> :t map (\x -> showHex x "")
13:47:31 <lambdabot> (Integral a, Show a) => [a] -> [String]
13:47:44 <Cale> :t map (\x -> showHex x "") . BS.unpack
13:47:45 <lambdabot> BSC.ByteString -> [String]
13:48:36 <Cale> maybe more efficient...
13:48:52 <Cale> :t foldr (.) id . map showHex . BS.unpack
13:48:53 <lambdabot> BSC.ByteString -> String -> String
13:49:24 <Cale> :t \bs -> (foldr (.) id . map showHex . BS.unpack) bs ""
13:49:25 <lambdabot> BSC.ByteString -> String
13:51:55 <EvanR> :t concatMap (flip showHex "") . BS.unpack
13:51:56 <lambdabot> BSC.ByteString -> [Char]
13:52:08 <ClaudiusMaximus> probably needs modification for leading 0s
13:52:25 <EvanR> > showHex 9 ""
13:52:26 <lambdabot>  "9"
13:52:31 <ph88^> is it possible to save the ghci to a file ?
13:52:48 <EvanR> annoying
13:53:09 <jophish> > printf "%02x" 9 :: String
13:53:11 <lambdabot>  "09"
13:53:48 <jophish> > printf "%016b" 9 :: String
13:53:49 <lambdabot>  "0000000000001001"
14:04:27 <Lovepon> This is harder than I thought.
14:08:04 <Lovepon> Mmmm. :/
14:08:19 <Lovepon> Now I'm *really* having a hard time. Lol.
14:12:25 <Lovepon> Dynamic t a -> Event t c -> (a -> b) -> Dynamic t b
14:12:37 <Lovepon> Wheree
14:12:54 <Cale> Lovepon: what's the c for?
14:13:06 <Lovepon> Cale: Nothing at all.
14:13:17 <Lovepon> Cale: I'd have written it as Event t _ if we can
14:13:23 <Cale> Okay, maybe you can describe the situation you're in?
14:13:37 <Lovepon> Cale: So, what I'm doing.
14:13:53 <Lovepon> Cale: I'm making a sequence of widgets.
14:14:06 <Lovepon> Wait.
14:14:18 <Cale> Note that mapDyn :: (a -> b) -> Dynamic t a -> m (Dynamic t b)
14:14:20 <Lovepon> sequenceWidget :: (MonadWidget t m) => [m (Dynamic t a)] -> m (Event t a)
14:14:46 <Lovepon> Cale: Good so far?
14:15:04 <Cale> hmm, what's the resulting Event t a?
14:15:27 <Lovepon> Cale: Okay, [m (Dynamic t a)], right?
14:15:31 <Cale> Also, are you aware of the list widgets in Reflex.Dom.Widget.Basic?
14:15:43 <Lovepon> Cale: Yeah, I don't think they do what I need.
14:16:02 <Cale> Okay, so you have a list of widgets each of which has a Dynamic t a result
14:16:05 <Lovepon> Cale: So, sequenceWidget basically renders widgets as a sequence.
14:16:15 <Lovepon> Cale: Each widget except the first is hidden.
14:16:29 <Lovepon> Cale: Each widget is rendered with a button below.
14:16:41 <Cale> Oh, I see
14:16:57 <Cale> So, you probably want an Event t (Dynamic t a) as the result
14:17:09 <Lovepon> Cale: That was my first guess.
14:17:15 <Cale> Or perhaps Dynamic t (Dynamic t a)
14:17:18 <Lovepon> Cale: But then I realized, each widget will only appear once.
14:17:33 <Lovepon> Cale: So, it gets the value of the dynamic at that time, and fires it as that.
14:17:35 <Cale> (with the initial Dynamic being the first one in the list)
14:17:43 <Lovepon> Cale: In other words, tagDyn.
14:17:58 <Cale> At which time?
14:18:08 <Lovepon> Cale: When the button is pressed.
14:18:09 <Cale> The time that the widget finishes being displayed?
14:18:14 <Lovepon> Cale: Yes.
14:18:19 <Cale> fair enough
14:18:37 <Lovepon> Cale: The button will make you switch to the next widget.
14:19:28 <Lovepon> Cale: Here's what I have so far. https://gist.github.com/90bf51cc84d2bc6fb96a363cd813716e
14:19:45 <Cale> that... is one line?
14:19:49 <Lovepon> Err
14:19:51 <Lovepon> Cale: Sorry.
14:20:33 <Lovepon> Cale: Reload.
14:21:02 <Lovepon> Cale: hideWhenPressed and showWhenPressed will of course be changed later on.
14:21:25 <Cale> okay, you probably want to use widgetHold somehow
14:21:45 <Cale> or maybe workflow
14:21:54 <Lovepon> workflow?
14:22:38 <Cale> http://hackage.haskell.org/package/reflex-dom-0.3/docs/src/Reflex-Dom-Widget-Basic.html#line-809
14:23:24 <Lovepon> Hmmm
14:23:32 <Lovepon> Ah, right.
14:23:48 <Lovepon> Cale: My main problem is how to compose hideWhenPressed and showWhenPressed.
14:24:44 <Cale> Are you sure you want all the other widgets to still be in the DOM, just hidden from view?
14:24:56 <Lovepon> Cale: Nope.
14:25:02 <Lovepon> Cale: can I destroy them?
14:25:10 <Cale> dyn/widgetHold/workflow will actually switch between them
14:26:46 <Cale> Lovepon: We just need to write something that will actually iterate through the entries in your list. What should happen when we get to the end of the list? What if the list is empty?
14:26:56 <Lovepon> Cale: Okay.
14:27:13 <Lovepon> Cale: So, if the list is empty, then return a never executing event.
14:27:25 <Lovepon> Cale: At the end of the list, do not add a button.
14:27:33 <Cale> Lovepon: It's probably worth spending a moment to understand Workflow, since it's really a nice way to do these "wizard" sorts of things
14:27:55 <Lovepon> Cale: I see, I'll get to reading it now then!
14:28:18 <Cale> So, each "page" will be a value of type Workflow t m a, in your case, perhaps  Workflow t m (Dynamic t a)
14:28:41 <Lovepon> Cale: Okay.
14:28:42 <surganov> Can someone share a concrete code example of using ((->) r) as a Functor (but not as Monad)? Trying to write my own, but can't work out types right
14:28:50 <Cale> and to make one, you apply the Workflow data constructor to a widget of type  m (a, Event t (Workflow t m a))
14:28:55 <Lovepon> surganov: Hmm
14:29:02 <Cale> (again, perhaps those a's are Dynamic t a's in your case)
14:29:46 <Cale> The Event specifies when to switch to a new Workflow to display, and what it should be
14:29:52 <Lovepon> Cale: Recursive types make my head hurt. '_'
14:30:03 <Lovepon> Cale: Wait, trying to understand that.
14:30:09 <Cale> I have an example somewhere... one sec
14:30:24 <Lovepon> Cale: If we need a Workflow to make a Workflow, how do we make a Workflow?
14:30:31 <Lovepon> '_'
14:30:44 <Cale> Lovepon: Well, the Event might never fire
14:30:50 <Cale> in which case, it can just be never
14:30:53 <hpc> use AbstractWorkflowSingletonFactory
14:31:24 <Lovepon> hpc: FactoryObjectFactoryFactory you mean? That's what most people use for prod.
14:31:26 <Cale> But often, you'll have however many pages defined as Workflows, and they will fire their Event with the appropriate other Workflow to switch to
14:31:40 <Lovepon> Cale: Hmmm
14:31:42 <Cale> Lovepon: yes, it's really mutual recursion :)
14:31:59 <Lovepon> Cale: Wait, I think I got it.
14:32:10 <Lovepon> Cale: This is basically what I'm trying to do, right?
14:32:14 <Cale> yeah
14:32:45 <Lovepon> Cale: Hmmm
14:33:23 <Lovepon> Cale: So, by convention, the first element of the tuple is the Event's "return"?
14:33:47 <Cale> the Workflow's return value
14:33:54 <Lovepon> Cale: Ah.
14:33:58 <Lovepon> Cale: I see, that makes sense.
14:34:12 <Lovepon> Cale: Okay, here's the weird question lol
14:34:15 <Cale> and workflow/workflowView will give you either an Event with the new resulting value whenever the thing switches
14:34:21 <Lovepon> Cale: What should I put in the initial a?
14:34:30 <Cale> or a Dynamic, which lets you observe the current one
14:34:30 <Lovepon> When no events have been fired yet?
14:34:52 <Cale> Well, what do you want to be visible when the thing loads at first?
14:35:05 <Lovepon> Cale: Ah, hmmm..
14:35:06 <koz_> I need some advice on making these two functions less boilerplate-y and redundant: http://paste.rel4tion.org/338
14:36:10 <Cale> Lovepon: Often, you'll end up in a symmetric position where any of the pages could be the first one, and they include links which take you to the others
14:36:32 <Cale> Lovepon: but in your case, it should be simpler, your first page will include a link which takes you to the second and so on
14:36:40 <Lovepon> Right.
14:36:57 <Lovepon> Okay, I think I got it.
14:37:14 <Lovepon> Hmmm
14:37:41 <Lovepon> Oh wait, nope, not yet, not really.
14:37:51 <Cale> Okay, let me write an example for you
14:38:16 <Lovepon> Oh wait.
14:38:20 <Lovepon> I think I'm seeing something.
14:39:01 <Lovepon> Cale: Does `:: MonadWidget t m => Dynamic t (m a) -> m a` exist?
14:39:16 <EvanR> is there a way to replace multiple record fields at once with a lens
14:39:38 <Cale> dyn :: MonadWidget t m => Dynamic t (m a) -> m (Event t a)
14:39:44 <Cale> is the closest you'll get to that
14:39:49 <Lovepon> Cale: Hmmmm
14:40:01 <puregreen> EvanR: no, you can only do “x & a .~ something & b .~ something_else & ...”
14:40:12 <Cale> Whenever it switches to a new widget, the Event fires with the result of that widget's execution
14:40:21 <EvanR> grumble
14:40:58 <Lovepon> Cale: Ah.
14:41:00 <Cale> Lovepon: (and there will be a firing almost immediately)
14:42:15 <Lovepon> Cale: Hmmm
14:42:42 <Lovepon> Welp, I got nothing so far.
14:42:49 <Lovepon> Cale: I'll wait for your example.
14:43:04 <Lovepon> I'll continue reading the API for the meantime.
14:47:21 <Cale> Lovepon: okay, almost done :)
14:48:16 <Lovepon> Cale: Also, workflowView's return type is considerably close to mine.
14:48:30 <Lovepon> Err
14:48:32 <Lovepon> s/return //
14:49:42 <Cale> http://cale.yi.org/workflowExample.jsexe/
14:50:13 <Cale> Lovepon: This is slightly boring in that our pages only return a String result, which I'm displaying
14:50:54 <Cale> Lovepon: Let's make it a little more interesting, by having them have an Event String result, and we're going to want to collect the firings of that Event String from each page
14:51:01 <Cale> (whichever page is selected)
14:51:16 <Lovepon> Cale: Hmmm
14:54:44 <Lovepon> holycow i got it lol
14:55:58 <Lovepon> Cale: I'm so so thankful. '_'
14:58:02 <Lovepon> Cale: So, if I get this correctly, the DOM is being rebuilt?
14:58:11 <Lovepon> Rather than just hidden?
15:03:36 <Cale> Lovepon: http://cale.yi.org/workflowExample2.jsexe/
15:03:42 <Cale> yes, it's being rebuilt
15:03:54 <Cale> You can have a look in the element inspector in Chrome to watch
15:04:39 <Lovepon> Cale: Oh, cool, I can also delay the event so that I can let CSS animations do their magic.
15:04:44 <Cale> yes
15:05:32 <Cale> I actually have in the past written a function Workflow t m a -> Workflow t m a which put in CSS transitions between the pages
15:06:01 <Cale> Eventually I need to clean that up and open source it...
15:07:02 <chompy> anyone use spacemacs?
15:07:30 <chompy> i'm wondering if it's possible to get colored highlighting for error messages in Interactive-Haskell
15:08:02 <chompy> the wall-of-plaintext errors are kind of difficult to look at
15:08:30 <Lovepon> Cale: I should contribute to reflex-dom-contrib.
15:08:36 <hpc> i wonder if we could get those built into ghc
15:08:48 <EvanR> colored anything in ghci plz ;0
15:09:04 <hpc> with mappings for bash, windows (via empty string in color codes), etc
15:09:06 <Lovepon> omg
15:09:06 <chompy> EvanR so i guess the answer is no =/
15:09:28 <Lovepon> colored highlighting of error messages sounds so awesome. *_*
15:10:39 <hpc> perhaps in type errors, color "Expected type:" in green and "Actual type:" in red
15:11:01 <EvanR> now hold on bernice
15:11:40 <chompy> Lovepon god we have low UI standards around here :(
15:12:20 <hpc> in our defense, we all use linux
15:12:24 * hpc ducks
15:12:34 <EvanR> i think its a serious problem...
15:12:34 <Lovepon> Cale: I'm really really liking what you're doing. I'm learning so much, not only on reflex itself, but also how to... how do I say this, design monadically / frpically?
15:13:00 <EvanR> time to use intellij haskforce!
15:13:08 <chompy> EvanR definitely. there's a non-trivial cognitive drain when 1 error produces 30 lines of grey text
15:13:10 * dedgrant holds on tight to the raggedy windows edge
15:13:11 <Lovepon> EvanR: hpc chompy all hail the great wall-of-text.
15:14:07 <hpc> dedgrant: you can use ghcjs to build for microsoft edge
15:14:07 <amf> is there a clever way to get a specific instance of my Chan reading / writing typeclass to "listen". since Chan(..) is in IO, i cant use mzero as a default do-nothing approach
15:14:21 <dedgrant> hpc: You just improved the pun.
15:14:32 <hpc> 's what im here for
15:14:35 <dedgrant> :)
15:14:56 <Cale> Lovepon: thanks! No problem.
15:15:37 <Cale> Lovepon: Eventually, I hope to compile enough of these to make a nice tutorial out of them :)
15:15:45 <Lovepon> Cale: :D
15:16:11 <Lovepon> Cale: Reflex needs more tutorials. :Y
15:17:01 <Mateon1> Is there a 'flip' for 2 element tuples?
15:17:16 <kadoban> Mateon1: 'swap' you mean?
15:17:22 <Lovepon> :t swap
15:17:23 <lambdabot> (a, b) -> (b, a)
15:17:26 <Lovepon> '_'
15:17:32 <Lovepon> i didn't know this
15:17:40 <Mateon1> Nice, thanks, kadoban, Lovepon 
15:17:50 <Cale> Lovepon: It really does
15:18:14 <Lovepon> Cale: This is also the first FRP library that I really got into.
15:18:25 <MichaelK> Is there a class that contains all types?
15:18:28 <Mateon1> Or not... It's not in scope.
15:18:30 <Cale> Lovepon: I had a much easier time learning than most because I'd worked with Ryan on other FRP systems years before
15:18:31 <kadoban> ryantrinkle's one talk/presentation thing with the twitter interface was pretty good.
15:18:37 <Lovepon> Cale: Probably because of its ready support for UI.
15:18:41 <kadoban> Mateon1: I think it's in Data.Tuple, I'm not 100% sure though.
15:18:42 <Mateon1> Oh, but I can easily pattern match, I guess.
15:18:51 <Mateon1> > let swap (a, b) = (b, a)
15:18:52 <lambdabot>  <no location info>: not an expression: ‘let swap (a, b) = (b, a)’
15:19:03 <Mateon1> Meh, not sure how lambdabot works
15:19:06 <Lovepon> :i swap
15:19:08 <kadoban> Mateon1: Oh my browser started working, yeah it's in Data.Tuple, which is in 'base', so you should just have to import it.
15:19:56 <Mateon1> Okay, thanks again
15:20:09 <chompy> i keep vacillating on whether to commit to ghcjs, purescript, or elm
15:20:18 <Lovepon> Cale: One thing I love about Reflex is that it's... constrained to itself, I think that's what I want to say? You don't have to import SomeGraphicsLibrary and try to work your way into making it compatible with each other.
15:21:05 <Cale> Well, sometimes you have to import GHCJS.DOM if you get outside the stuff we've already wrapped up
15:21:30 <Cale> But yeah, you can do quite a bit with what we already provide.
15:21:44 <Lovepon> Cale: Local storage.
15:23:12 <Lovepon> Cale: Question. How would you even implement local storage in an FRP way?
15:23:24 <Lovepon> I have a vague idea, but it doesn't seem sane.
15:23:28 <Lovepon> Like, too sane.
15:25:12 <Lovepon> Cale: Also, with this, I have a feeling I'll really get into webdev.
15:25:17 <Cale> Well, there are a few approaches... we could implement it as a request/response sort of mechanism
15:26:00 <Lovepon> Cale: Ah, I think I get what you mean.
15:26:03 <Cale> Or maybe even have it give you a Dynamic t (Map String String) view 
15:26:38 <Lovepon> Cale: How about :: Dynamic t String -> Dynamic t String?
15:26:51 <Cale> Just for reading?
15:26:58 <Lovepon> More or less.
15:27:04 <Cale> yeah, that's doable
15:27:10 <Lovepon> Cale: How about for R/W?
15:29:22 <Lovepon> Cale: Also, would having a separate reader/writer violate some stuff?
15:30:13 <Lovepon> Cale: Since the two FRP... interfaces? Have no direct connection with each other, yet one directly affects the other.
15:35:16 <tombert> I have a more generic question here, but I'll ask it anyway; I'm trying to create an application that connects via telnet
15:35:34 <tombert> right now I have a basic, raw TCP server going
15:35:43 <tombert> but I'd like to have some kind of pseudo-gui-ish thing
15:35:44 <Lovepon> tombert: Okay.
15:35:50 <tombert> or at teh very least, have a way to refresh the screen
15:35:56 <tombert> how would I go about doing that in haskell?
15:36:16 <whittle> tombert: By psuedo-gui-ish, do you mean curses-style? 
15:36:30 <Lovepon> tombert: If so, we call it TUI.
15:36:45 <tombert> yeah, a curses style woudl be ideal
15:37:13 <tombert> but i'd be OK with just being abel to refreshing the screen
15:37:18 <EvanR> ncurses bindings do exist
15:37:27 <tombert> can I pipe those directly to telnet?
15:37:37 <tombert> that's teh thing, I'm totally aware of vty and hscurses and whatnot
15:37:52 <EvanR> would your backend be separate form the GUI?
15:37:58 <whittle> tombert: It depends on what the client supports.
15:38:07 <tombert> the client is just telnet
15:38:16 <tombert> I know this is possible, ebcause of console-style MUDs
15:38:21 <tombert> or ascii star wars
15:38:40 <EvanR> probably those are not separared at all, no excuse though, this is haskell
15:40:11 <whittle> tombert: Sure, that’s what I was thinking of, too. IIRC, different clients support different sets of command bytes. 
15:40:59 <whittle> At the lowest level, I would think it would just be a matter of finding out what those command bytes are and piping them down the line.
15:41:13 <tombert> yeah, that's I guess what I'm mainly asking
15:41:25 <geekosaur> ascii star wpars works because ~all terminals these days are X3.64 (aka DEC VT100 with extensions) compatible.
15:41:45 <tombert> I'm ok with 90%-ish compatibility
15:42:01 <geekosaur> being abl;e to refresh the screen means keeping track of what it should contain; this is part of what ncurses and vty do for you
15:42:26 <tombert> is there a way to get vty to output directly to a socket?
15:42:35 <tombert> instead of regular stdout?
15:42:45 <geekosaur> I'm not clear on what you mean by "pipe to telnet" though, it sounds like ou are confused about what is going on with telnet
15:42:57 <tombert> no, I mean pipe straight to TCP
15:43:05 <tombert> telnet just being what I'm using to connect to the server
15:43:15 <geekosaur> at that level it's just bytes
15:43:53 <geekosaur> so yes. easiest way being just to reopen stdout on the socket, or run the program with its stdin/stdout connected to the socket
15:44:26 <geekosaur> (inetd more or less exists to do this)
15:44:51 <tombert> I was hoping there was a way to do this exclusively in haskell
15:45:48 <geekosaur> there is
15:46:38 <geekosaur> I'm not clear on why you'd want to, it's a bit like "no, not enough to build my house next to the road, I need to build an access road for it too"
15:47:23 <tombert> I'm trying to create a MUD, like an old-school BBS game, more or less comparable to telnet aardmud.org  
15:47:35 <EvanR> dont use telnet
15:47:38 <EvanR> its awful
15:47:45 <tombert> EvanR: thanks for your input
15:47:50 <geekosaur> or, to state this concern more clearly: I have the feeling that you may not be familiar with how these things work (not Haskell level but OS level) and therefore have decided to implement things in a poorly fitting way
15:48:26 <geekosaur> part of the issue here is: uyou get two connections. do you expect one process to be handling both? what if it's 200?
15:49:26 <geekosaur> typically for things like this, one has a server that accepts one connection, and a new copy is spawned for each connection. (possibly by inetd, possibly by a specific supervisory process)
15:49:52 <tombert> geekosaur: keep in mind, all I'm asking is to clear the screen :P
15:50:06 <tombert> I don't really want to host a whole vty session
15:50:25 <geekosaur> these communicate by inter-{process,thread} communication, modifying shared state that is on disk or etc. --- because you expect that state to persist across connections (so your clients are operating in a shared world)
15:50:31 <chompy> is there a pretty printer that takes advantage of generics to work automagically in a reasonable way?
15:50:51 <geekosaur> tombert, clear screen or clear screen and redraw what was supposed to be there?
15:51:04 <tombert> geekosaur: literally just clear the screen
15:51:07 <EvanR> chompy: so im using GenericPretty
15:51:13 <geekosaur> the former is: putStr "\ESC[H\ESC[J"
15:51:15 <EvanR> its sort of working
15:51:29 <EvanR> the issue i had so far with any pretty lib is that the output is not pretty enough
15:51:36 <geekosaur> (given that there are very few things left out there that aren't ANSI X3.64)
15:52:30 <tombert> yeah, I don't really care if this doesn't support a 30+ year old terminal, this is to just a little hobby thing I'm trying to build to show at meeting
15:52:31 <geekosaur> you seemed initially to be describing something where you want to clear and redraw, which implies knowing what to redraw, which usually means something that maintains an internal "image" of the terminal --- that's curses/vty
15:52:56 <EvanR> tombert: then dont do telnet, just use a simple TCP connection to a server app
15:53:09 <geekosaur> (unless what you redraw is static, like the ASCII star wars thing --- it will always be the same thing, the next "movie frame")
15:54:03 <tombert> EvanR: I'm using telnet as a client, I'm not trying to use it within haskell; without having to dive into rebuilding an entire client from scratch, and without reinventing SSH, what are you suggesting I do for a project I literally just need for a day to show at a meeting?
15:54:17 <EvanR> eh?
15:54:47 <EvanR> what does client mean in this case
15:56:27 <geekosaur> ok, so in this case you're really looking at: server loop accepts connections and spawns processes or threads to service them (yuou can save on some of this by letting inetd do it instead and have your program use stdin/stdout instead of being passed a socket)
15:56:56 <geekosaur> make sure you disable buffering on input (hSetBuffering) if you expect inpuit that isnb;t strictly line based
15:57:24 <geekosaur> ... (sighm know I'm having some problems tosday but my typing is atrocious...)
16:00:21 <geekosaur> one complication here that you may or may not need to deal with: there are two basic terminal interaction modes, line and character, alomng with things like supporting control-C for interrupts. for these to work right, you can't just hook your program to a socket; you need to use a pty (pseudo-terminal) device and a program that hooks this to the socket using a protocol that allows mode switches to be relayed over the network
16:00:28 <geekosaur> (telnetd does this)
16:01:33 <geekosaur> as long as you stick to only one mode, you likely don't need to care about this. system logins do need to care and need to use ptys
16:02:06 <geekosaur> for something simple, I'd at least try to get by without it --- but you may find yourself needing to handle things that a pty layer would handle for you
16:02:21 <geekosaur> so it's not going to be "just like" interacting with a program run in a terminal
16:05:49 <EvanR> should System.Timeout work to cancel a long running non-IO computation
16:06:24 <geekosaur> only if it allocates, I think. also try compiling with -fno-omit-yields?
16:06:38 <Lovepon> Cale: I gave it some more thinking, and I might actually want `:: [Event t () -> Event t a -> m (Event t a)] -> m ()`
16:07:33 <Lovepon> Urgh, I should stop pulling all-nighters. -.-
16:08:44 <whittle> How do I turn a function (f :: String -> Maybe a) into an Aeson (:: Parser a) so that the parser fails if the function returns Nothing? I feel like I should be able to do it with msum, but I can’t figure out how. 
16:09:08 * hackagebot casadi-bindings 3.0.0.1 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-3.0.0.1 (GregHorn)
16:09:40 <Lovepon> Cale: Hmmm, I can actually work with -> m (Event t a), though, since this may run in a div.
16:13:28 <pavonia> whittle: What is 'a' in this type?
16:14:43 <whittle> pavonia: UTCTime. The function I’m trying to leverage is parseISO8601. 
16:15:29 <EvanR> i have a feeling aeson's instance for UTCTime is not convenient
16:15:46 <EvanR> but you can use newtypes to fix it
16:15:57 <pavonia> whittle: So you could simply do "case f someString of Nothing -> fail ...; Just t -> return t", I think
16:18:00 <whittle> pavonia: Thank you, good point. I had somehow forgotten about fail. 
16:18:48 <whittle> EvanR: Thank you, I am wrapping it in a newtype to prevent the instance from leaking. 
16:24:18 <obadz> is there a way to point cabal to a local source tree for a project?
16:24:27 <obadz> (…that I depend on)
16:25:08 <RyanGlScott> obadz: At the moment, no. The next version of cabal-install will have an experimental feature which will allow you to do so.
16:25:24 <hpc> i know in cabal-dev you can use cabal-dev add-source /path/to/dir
16:25:54 <hpc> it behaves weirdly in some ways, but i don't remember how
16:26:15 <hpc> just that sometimes if you don't use it perfectly it will use wrong versions of things or pull from hackage
16:27:10 <whittle> obadz: Haskell Tool Stack supports that: http://docs.haskellstack.org/en/stable/yaml_configuration/#project-config
16:27:34 <obadz> whittle: stack doesn't pick up libraries installed by nix though
16:28:21 <obadz> is there a way to tell stack to use whatever libraries are installed on system rather than try to download/build its own?
16:32:32 <whittle> obadz: If the system installs the libs where GHC knows about them (and you’re using GHC), I think setting stack to use the GHC resolver would work. 
16:35:48 <obadz> whittle: that works
16:36:05 <obadz> whittle: is there a resolver like "ghc-current" so that I don't have to hardcode "ghc-7.10.3" ?
16:36:42 <whittle> obadz: Not that I’m aware of. 
16:49:50 <mpickering> obadz: If you are using sandboxes then you can use cabal sandbox add-source
16:50:29 <mpickering> but probably won't help if you are using nix
16:51:24 <Axman6> people still use sandboxes?
16:51:45 <mpickering> yes, why not?
16:53:11 <Axman6> we use stack for everything and haven't looked back
16:55:37 <obadz> $ stack --nix build 
16:55:39 <obadz> error: undefined variable ‘haskellcompilerghc7103’ at (string):1:233
16:57:05 <mpickering> I feel like the only person still using cabal, it's a lonely world
16:57:12 <Clint> you're not
16:58:52 <RyanGlScott> Yep. There's too many tiny inconveniences for me to ever want to use stack full-time.
17:00:24 <lpaste> dedgrant pasted “Transforming away instance ambiguity” at http://lpaste.net/161633
17:01:41 <dedgrant> ^^^ Related to earlier post. Type-level function application falls into the injectivity trap. What are some techniques for avoiding this mess?
17:02:08 <obadz> is there really no way to tell cabal to build both projects A and B from local directory when A depends on B?
17:02:16 <obadz> I'm having a hard time believing that
17:02:33 <RyanGlScott> obadz: It depends on what to mean by "build"
17:02:51 <obadz> RyanGlScott: defining as: cabal build succeeds
17:02:54 <RyanGlScott> If you have A and B checkout out locally, you can say "cabal install path/to/A path/to/B"
17:03:10 <obadz> can I replace install by build ?
17:03:17 <Enigmagic> no
17:03:25 <obadz> I don't want to install..
17:04:32 <RyanGlScott> obadz: Unfortunately, cabal build expects you to be in a project directory.
17:04:41 <RyanGlScott> Until cabal-install with Nix-like features is released
17:05:05 <RyanGlScott> You'll have to be content with installing the dependencies somewhere (either globally or in a sandbox)
17:05:08 <mpickering> dedgrant: Can you explain what you are trying to do?
17:05:45 <obadz> RyanGlScott: is there a way for me to set up one sandbox per project, to be stored in project directory?
17:05:55 <RyanGlScott> obadz, sure
17:06:08 <RyanGlScott> For each project directory, run "cabal sandbox init"
17:06:42 <RyanGlScott> Then you can add the locations of the dependencies via cabal sandbox add-source <paths>
17:06:58 <dedgrant> mpickering: Parsing of extensible (HList style) records from string data. F1 corresponds to a relation from field label -> fieldtype label, and F2 corresponds to a relation from fieldtype label -> native type.
17:07:29 <dedgrant> MakeXs is my (likely poorly informed) interpretation of a record parse :)
17:08:13 <obadz> RyanGlScott: so if A depends on B, cd A; cabal sandbox init; cabal sandbox add ../B; cabal build ?
17:08:14 <mpickering> and can you add the error pls? or something you expect to work
17:08:25 <mpickering> cabal sandbox add-source ../B
17:08:31 <dedgrant> mpickering: sure
17:08:48 <obadz> looks like I also need to cabal install B
17:09:03 <mpickering> (I'm not promising to have the answer but it's very unclear what your're expecting to happen)
17:09:22 <obadz> this is acceptable
17:09:29 <obadz> (and it works)
17:10:02 <dedgrant> mpickering: Yea sometimes the abstract is a win if there is a common idiom, sometimes not. I understand.
17:10:45 <RyanGlScott> obadz: At the moment, the cabal-install workflow expects all dependencies to be build before you can run build / test / etc.
17:10:54 <RyanGlScott> obadz: I often run cabal install --only-dependencies first
17:10:58 <RyanGlScott> Then cabal build
17:11:03 <obadz> this works
17:11:09 <obadz> actually this works very nicely with nix
17:11:45 <obadz> the only thing now is specifying location of C-libraries in a way that's scalable…
17:11:57 <RyanGlScott> obadz: What do you mean?
17:13:16 <obadz> RyanGlScott: cabal install hmatrix ⇒  Missing C libraries: blas, lapack
17:13:37 <obadz> RyanGlScott: they're in like /nix/store/gbqg7albprpjl7qb6b2j9kdnvafk4nwm-openblas-0.2.17
17:14:01 <johnw> obadz: does openblas support pkg-config?
17:14:07 <andrewray1> 1: semi-functional programming question (warning: not haskell, but not sure where else to ping). i'm making a game loop, where I manage game state as a series of reducers over the old state. it's continuation passing style, where any reducer can return or call next()
17:14:36 <obadz> johnw: no share/ directory so don't think so
17:14:50 <andrewray1> 2: when doing things like animation, i'm getting a lot of verbose code. like, if I want to animate something from 0 to 1 over 500ms, I need to read the current time, subtract the start time, and divide by the total. this gets pretty verbose fast over time. any abstraction suggestions? 
17:14:59 <johnw> obadz: :(  then I'm not aware of any general way to query for the include/lib paths
17:16:30 <obadz> johnw: I'll survive using nix-build for that stuff
17:16:33 <obadz> johnw: thx though
17:16:39 <RyanGlScott> Funny, on Ubuntu at least blas and lapack do support pkg-config
17:16:44 <lpaste> dedgrant revised “Transforming away instance ambiguity”: “Transforming away instance ambiguity” at http://lpaste.net/161633
17:17:04 <dedgrant> ^^ mpickering: error and example
17:17:05 <RyanGlScott> obadz: Does Nix not add the library paths of blas/lapack to your LIBRARY_PATH?
17:17:23 <dedgrant> mpickering: Apologies the names still abstract but hopefully this conveys the intent
17:17:24 <obadz> RyanGlScott: nope
17:18:00 <vinklo> running into a weird issue with symbol resolution
17:18:06 <RyanGlScott> obadz: Out of curiosity, what does "pkg-config --libs lapack" give you?
17:18:15 <vinklo> i have a local util library which i've built and installed with stack.
17:18:38 <vinklo> from my new project, i've modified stack.yaml to point to it. i can run the new project which references the util library in stack ghci no problem
17:18:43 <vinklo> but when i try stack build on the new project
17:18:51 <vinklo> it's unable to resolve symbols at the linking stage
17:19:46 <vinklo> any idea why this might be?
17:20:06 <vinklo> RyanGIScott obadz are you doing numerical computing?
17:20:08 <lingxiao> hey all
17:20:19 <lingxiao> any one want to answer a coq question over at #coq? please :D
17:20:26 <RyanGlScott> obadz: I ask since you might be able to work around this issue pretty easily, assuming pkg-config works well on Nix.
17:20:28 <vinklo> hi lingxiao i don't use coq sorry
17:20:34 <lingxiao> all good thanks!
17:20:50 <RyanGlScott> Disclaimer: I've never used Nix, so I'm relying on you for this info :)
17:21:41 <geekosaur> vinklo, that often means that something is missing from extra-modules: so it doesn't get exported when used as a library vs. from source (as ghci may be doing)
17:22:45 <vinklo> is extra-modules ins stack.yaml or the cabal file?
17:23:02 <geekosaur> cabal file
17:23:30 <vinklo> how is extra-modules different from other-modules?
17:24:11 <vinklo> hmm the library is there in build-depends why is that not sufficient?
17:24:42 <mpickering> dedgrant: Which version of ghc are you trying this in?
17:25:34 <mpickering> I get a slightly different error with ghc 8
17:25:41 <vinklo> geekosaur and is the cabal file the one for the util library or the applicaiotn library?
17:26:03 <geekosaur> the util library
17:26:08 <dedgrant> mpickering: 7.10.2 I believe
17:26:16 <geekosaur> actually, what kinds of suymbols is it ciomplaining about exactly? (names)
17:26:17 <mpickering> https://www.irccloud.com/pastebin/LqN7gVAA/
17:26:20 <geekosaur> argh
17:26:30 <RyanGlScott> vinklo: exposed-modules can be used by other libraries. other-modules are for intra-library use only.
17:26:49 <geekosaur> yeh, I started to explain that and desktop went offline again :/
17:26:54 <vinklo> RyanGIScott so what's extra-modules?
17:27:04 <vinklo> i don't see that here
17:27:09 <geekosaur> me havinga thinko, I meant othef-modules
17:27:14 <geekosaur> (I always get that wrong :/ )
17:27:18 <RyanGlScott> It's another stanza you can add to the library
17:27:20 <vinklo> ah ok
17:27:27 <RyanGlScott> Oh, oops
17:27:30 <obadz> vinklo: yes
17:27:36 <RyanGlScott> I drank the Kool-Aid too :)
17:27:41 <geekosaur> anyway: other-modules is internal modules that are required for the exposed-modules to work
17:28:11 <geekosaur> you will get link errors for symbols defined in those internal modules if you forget to list them in other-modules
17:28:14 <obadz> RyanGlScott: Package 'blas', required by 'lapack', not found
17:28:25 <geekosaur> ...but they;ll work for some things, specifically when ghci loads them as source
17:28:29 <obadz> RyanGlScott: I think blas is missing the pkg-config files
17:29:37 <vinklo> huh still getting undefined symbols
17:29:46 <geekosaur> so, can you name one of the symbols that is being reported in the link error?
17:30:06 <mpickering> dedgrant: I don't think you can get around this
17:30:20 <vinklo> it's garbled up
17:30:27 <vinklo> but i can see
17:30:29 <mpickering> dedgrant: You should ask on stack overflow for a better answer I think. 
17:30:35 <geekosaur> just give the mangled symbol
17:30:39 <vinklo> enough that it's in one of the helper modules (not the main one
17:30:45 <RyanGlScott> obadz: Huh. Does "pkg-config --list-all | grep blas" give you anything?
17:30:55 <geekosaur> right, that'd be normal for a missing other-modules: entry
17:31:02 <obadz> RyanGlScott: no the blas lib does not have a lib/pkgconfig directory
17:31:11 <RyanGlScott> Well, darn :(
17:31:23 <geekosaur> blas predates pkgconfig...
17:31:35 <obadz> not that I couldn't create one
17:31:35 <vinklo> geekosaur trying again rebuilding
17:31:43 <RyanGlScott> True, but some Linux distros ship a .pc file for it (Ubuntu, at least)
17:31:47 <vinklo> ooh this times it actgually says "Installing library in..."
17:31:50 <vinklo> that's encouraging
17:32:01 <geekosaur> so you add that to the util library and rebuild it, then hopefully it should work in the application
17:32:01 <mpickering> dedgrant: Because the problem is that GHC needs to unify F2 l and F2 (F1 l1) but they could equal the same without l ~ F1 l1
17:32:02 <obadz> seems like an elegant way to fix this problem
17:32:17 <vinklo> going to the app project
17:32:21 <vinklo> trying stack clean this time
17:32:28 <vinklo> rebuilding..
17:32:30 <vinklo> aha
17:32:42 <Lovepon> Sweet Jesus.
17:32:48 <dedgrant> mpickering: Yea I need a new model, ty for taking a look anyway. Your description makes it clear why injectivity is needed here. 
17:32:52 <Lovepon> Why didn't someone just say map = fmap and get it over with?
17:33:04 <Lovepon> This is like, 80% the cause of my errors. [citation needed]
17:33:19 <mpickering> dedgrant: I used to play around with this stuff a lot but it's never very pretty or intuitive :(
17:33:22 <vinklo> geekosaur works! i guess last time somehow it didn't update the stack global repository... or i needed to clean the app project stack directory ... not sure why it didn't work
17:33:25 <vinklo> anyway it works now
17:33:45 <Hijiri> Lovepon: I don't remember, but maybe fmap came after map
17:33:46 <geekosaur> if you just added the other-modules entry and did a rebuild, I could imagine it says :oh, already built" and does nothing
17:33:47 <RyanGlScott> obadz: The bad thing about pkg-config is that everyone isn't using it yet, unfortunately
17:35:02 <vinklo> cool. kind of a subtle issue for noobs though.
17:35:51 <obadz> RyanGlScott: yes it's a good mechanism. I used it intensively to package F# on nixos
17:35:55 <dedgrant> mpickering: It really isn't.. I know there are other demi-solutions (Data.HList and Vinyl), but I may give the injective type annotations (ghc 8 I think?) a try and experiment with some deliberate newtyping to achieve this.
17:36:22 <dedgrant> I suspect there be further dragons lurking
17:36:23 <RyanGlScott> Perhaps that's why the hmatrix package isn't using pkgconfig-depends in its .cabal file in the first place...
17:37:22 <vinklo> yay someone else is attempting to do numerical computing in haskell
17:38:25 <vinklo> ok gotta get back to work
17:38:43 <Lovepon> Wow. My code just ogt a bit sad all of a sudden
17:38:45 <Lovepon> "return never"
17:38:49 <Lovepon> </3
17:39:13 <Lovepon> Or even better, `return (x, never)`
17:39:18 <Lovepon> :(
17:39:45 <vinklo> hey what happened to support for shakespearean templates in emacs?
17:39:50 <vinklo> i could've sworn it used to exist...
17:40:01 <vinklo> does it not?
17:41:17 <buttons840> what web framework would you suggest to a beginner like me? i don't have any deadlines :)
17:41:40 <vinklo> ah it does exist, just not integrated into spacemacs haskell layer :(
17:41:40 <Lovepon> buttons840: Reflex.
17:41:49 <Lovepon> buttons840: I have deadlines, and it's working out well for me.
17:41:51 <vinklo> Lovepon reflex is a web framework?
17:41:55 <dedgrant> mpickering: This is a point at which Haskell is behind C++ TMP, since the sort of induction on template parameters works really well there for the extensible record problem.. just ignore types and the problem of undecidability :D
17:41:56 <Lovepon> oh wait.
17:42:03 <Lovepon> buttons840: Errr, clarification. Server or client side?
17:42:06 <vinklo> buttons840 i have deadlines and spock is working decently in that regard
17:42:12 <buttons840> Lovepon: server side
17:42:18 <Lovepon> buttons840: Ah, spock then.
17:42:18 <Cale> Reflex-dom isn't a complete web framework, but it's good for doing frontend stuff.
17:42:42 <Cale> (Reflex itself is an FRP framework, and eventually, will be useful for more than just web stuff)
17:42:45 <vinklo> Lovepon yay someone else likes spock
17:42:57 <vinklo> there must be dozen of us
17:43:38 <buttons840> sounds like spock is liked by the majority of haskell users, so I'll try that ;)
17:43:42 <Hijiri> Cale: I've tried making it useful for writing menus in an SDL app
17:43:47 <Hijiri> I haven't worked on it for a while though
17:43:52 <Lovepon> Cale: https://gist.github.com/Myrl/775ec5040f5c046e97aa3960616a79ff
17:44:01 <vinklo> buttons840 yeah 12/20 ;-)
17:44:02 <Cale> btw, is anyone coming to the NY Haskell meetup in a few days?
17:44:04 * Axman6 loves servant for web servers
17:44:14 <Lovepon> Cale: That's the type I went along with.
17:44:35 <Cale> Lovepon: hmmm
17:44:38 <buttons840> Axman6: servant looks nice, but i thought it was mainly for rest apis? I want to start with a traditional web app
17:44:40 <vinklo> buttons840 the nice thing about it is it's consistency. you can learn it in hours because of that. also, no template magic, so pieces compose using plain old monads
17:45:01 <Lovepon> Cale: I think there's a bit of a bad decision there.
17:45:06 <Lovepon> Cale: Not sure where.
17:45:14 <vinklo> spock is more beginner friendly. servant might be less code but the type level magic isn't so beginner friendly
17:45:15 <Cale> What are the Event t ()'s?
17:45:21 <Lovepon> Cale: Buttons.
17:45:37 <Lovepon> Cale: I added that because I just realized, "what if the data is incomplete"
17:45:46 <Lovepon> s/data/form/
17:46:11 <Cale> Lovepon: I would probably have each page validate itself.
17:46:18 <Lovepon> Cale: Exactly.
17:46:25 <Lovepon> Cale: It validates itself every button press.
17:47:05 <Cale> Oh, I mean, rather than taking a click on input, it could just contain the button which goes to the next page, and produce an Event on its output which says "okay I'm done"
17:47:25 <Cale> That way, you can, e.g. make the button disabled if the form is incomplete
17:47:31 <Lovepon> Cale: Mmmm... true.
17:47:49 <Lovepon> Cale: I like that.
17:48:17 <Lovepon> Cale: However, I want the button to be handled by the sequenceWidget code.
17:48:33 <Lovepon> Cale: I wonder if there's some middle ground.
17:49:26 <Lovepon> Cale: If I want inhibition, then I'd have to use Maybe?
17:59:45 <cheater> puregreen: what did you find difficult about snap? it's very simple imo
18:00:02 <cheater> puregreen: you can always ask a q in #snapframework btw
18:03:53 <Cale> Lovepon: I suppose you could have a Dynamic Bool or Either String () or something which determines whether the form is valid (and maybe reports on why not)
18:04:33 <Cale> and the container would disable the button until it's valid
18:04:51 <Lovepon> Cale: mmm, both Either and Maybe has good choices.
18:04:55 <Lovepon> s/has/are/
18:05:28 <Cale> I like Either String () even though it's isomorphic to Maybe String, because you're reporting on a failure
18:05:44 <andrewray> (repost) semi-functional programming question (warning: not haskell, but not sure where else to ping). i'm making a game loop, where I manage game state as a series of reducers over the old state. it's continuation passing style, where any reducer can return or call next()
18:05:46 <andrewray> when doing things like animation, i'm getting a lot of verbose code. like, if I want to animate something from 0 to 1 over 500ms, I need to read the current time, subtract the start time, and divide by the total. this gets pretty verbose fast over time. any abstraction suggestions? 
18:05:53 <Cale> Just x is a success, while Left x is a failure
18:06:00 <johnw> andrewray: I don't think this is the place
18:06:41 <Cale> andrewray: If you're doing something repetitive, make it into a function
18:06:53 <MichaelK> Hi, is there any way to note that a type function is idempotent?
18:07:06 <shanemikel> I'm having a curious encounter with polymorphism right now
18:07:11 <Lovepon> Here goes "fix all the 100 errors that popped out"
18:07:20 <Cale> MichaelK: not in any way that GHC could take advantage of
18:07:32 <Lovepon> Oh. It's already 9 am. I should start eating breakfast.
18:07:45 <Cale> MichaelK: You might be able to have a constraint (F a ~ F (F a)) or something
18:07:49 <pepsi_OD> doh... GenericPretty  doesn't support text?
18:08:12 <MichaelK> Cale: Good idea, I wonder if it'll work..
18:08:23 <shanemikel> in particular, I'm trying to implement exceptions with the variation on Cont give here http://jozefg.bitbucket.org/posts/2014-04-14-either-and-conts.html
18:10:53 <shanemikel> you can see what I have here http://lpaste.net/582122962308562944 .. clearly I'm trying to do something impossible with the Exception class, is there some other way I can independently define Exception types in a clean heirarchy?
18:11:49 <MichaelK> Cale: It doesn't seem to affect anything (when I put it in the class declaration), which I find odd
18:15:23 <minad> Hi! I am reading a bit about effect systems in Haskell. there seem to be many approaches with effect handlers (similar to the Eff language), and also some using indexed monads
18:15:51 <andrewray> Cale:  duh ;) looking for more of an abstraction to manage time based animation 
18:16:15 <minad> at first glance indexed monads seem to be the more natural fit, however more people seem to be interesting in fitting an effect system onto monads
18:17:22 <minad> I would like to know if there is a clear advantage of indexed monads or if it isn't worth it, maybe there is some paper with a comparison?
18:18:21 <Lisa1157> Hi, If there is a function that has signature b -> a -> a -> a. I would like to pass into (as the second) parameter an element from a list of [a] one at a time. Is the following correct syntax to do so? 'calcX b (map list) x '?
18:19:11 <minad> is it "just" because monads are already used in haskell, so that moving to the more general indexed monads is not a good idea
18:19:32 * hackagebot heredocs 0.1.2.0 - heredocument  https://hackage.haskell.org/package/heredocs-0.1.2.0 (KatsutoshiItoh)
18:19:59 <pavonia> Lisa1157: What function has this type? Waht are the types of the variables used in this expression?
18:20:54 <Hijiri> Lisa1157: map has type (a -> b) -> [a] -> [b], so assuming list is a list, map list will be a type error
18:21:33 <Lovepon> Cale: Oh... right... I forgot something.
18:21:50 <Lisa1157> The function has this signature 'calcX :: Float -> Particle -> Particle -> Particle'. 
18:22:10 <Lisa1157> it basically calculates force from one particle on  another 
18:22:47 <Lisa1157> as the first param I need to pass it a Particle from the list of total particles in a simulation
18:23:29 <Hijiri> the first param is a Float though
18:23:44 <Hijiri> also, what do you want to do if there are no particles
18:23:57 <Lisa1157> Hijiri: I have a few bases cases 
18:24:16 <Lisa1157> *base
18:24:35 <Lisa1157> also sorry I meant pass it into the second Parameter 
18:24:43 <Hijiri> ok, so you already have a particle in scope when you need to call calcX?
18:25:09 <Lisa1157> Hijiri: yes I have a float (t) and a list of Particles and a Particle
18:27:07 <pavonia> So you could use a lambda expression to transform your function call into something of type Particle -> Particle to use it with map
18:29:12 <Lisa1157> pavonia: alright ill look into lambda expressions  im not very confident at using them at the moment 
18:29:45 <pepsi_OD> man Text not being an instance of Out is killing me
18:29:49 <pepsi_OD> is there a work around?
18:30:01 <pepsi_OD> want to pretty print my records with generics
18:30:13 <pepsi_OD> but that doesn't work for anything with a Text field it seems :(
18:44:06 <nineonine> hi there
18:44:06 <nineonine> aeson related Q
18:44:06 <nineonine> im getting an aeson Value data type
18:44:06 <nineonine> with Number
18:44:12 <nineonine> Number 3.39218957e8
18:44:19 <nineonine> how to convert it to Int ?
18:44:35 <hpc> round it
18:46:44 <nineonine> using 
18:46:46 <nineonine> round 
18:46:46 <nineonine> ?
18:47:54 <geekosaur> round, ceiling, floor, truncate
18:54:33 * hackagebot versions 1.1.0 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-1.1.0 (fosskers)
18:54:49 <MichaelK> Is there such a thing as type level composition? (.)
18:56:32 <roboguy`> MichaelK: There is https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html
18:57:44 <MichaelK> roboguy`, I'm looking for something like `type B (t -> a) = (->) t . B a`
18:58:39 <roboguy`> MichaelK: could you elaborate a bit more, what are you trying to do? That type would be infinite
18:58:56 <Hijiri> you also can't have a type parameter like that, you can't pattern match on types
18:59:04 <Hijiri> wait
18:59:05 <roboguy`> well
18:59:06 <Hijiri> oh
18:59:10 <Hijiri> you could if it's a type family, I guess
18:59:12 <Hijiri> ?
18:59:14 <roboguy`> yeah
18:59:22 <MichaelK> I'm trying to convert a fundeps class to type families, I'll paste
18:59:23 <Hijiri> but if it's just a type synonym then I don't think so
18:59:47 <lpaste> MichaelK pasted “Example” at http://lpaste.net/161645
19:00:39 <Hijiri> I don't think there is an existing type level composition operator, but there is an extension for type-level infix operators, and you could write "type Foo f g a = f (g a)"
19:00:45 <Hijiri> but then it would only work when fully applied
19:01:23 <MichaelK> Hijiri: it will be fully applied in the class method, it shouldn't show up anywhere else
19:01:53 <Hijiri> what if you eta expand the type family to take two parameters
19:02:13 <Hijiri> actually, I don't know if type families can be partially applied
19:02:38 <MichaelK> Hijiri: I've considered that, but then I'm not sure if I could do it without fundeps, which would defeat the purpose of converting to type families, no?
19:02:39 <roboguy`> I don't think they can
19:02:48 <roboguy`> data families probably can
19:02:55 <rofer> I have a typeclass and I would like to take several instances of it, put them in a sum type, then make that new subtype an instance of the typeclass. Is there a non-tedious way to do this?
19:03:09 <roboguy`> MichaelK: if it would be fully applied, what would be its purpose?
19:03:41 <Hijiri> rofer: not in general
19:03:57 <Hijiri> for example, what if your typeclass has a function a -> Int
19:04:01 <MichaelK> To have a function with effective type `(a -> b) -> (t1 -> t2 -> ... -> tn -> a) -> (t1 -> t2 -> ... -> tn -> b)`
19:04:08 <Hijiri> oh
19:04:13 <Hijiri> I guess it could just use the specific one
19:04:18 <Hijiri> but what if you had, a -> a -> Int
19:04:34 <MichaelK> Hijiri, is that to me?
19:04:36 <Hijiri> there wouldn't be a way to make a case for two different constructors
19:04:40 <roboguy`> MichaelK: ahh, that's much trickier than just a type level compose
19:04:42 <Hijiri> it's to rofer
19:04:46 <MichaelK> ok
19:05:02 <rofer> Hijiri: Ah, now I see why it can't work
19:05:05 <MichaelK> roboguy`: yeah, though the paste works with fundeps
19:05:30 <rofer> I've got 3 instances, but 12 methods and I was hoping to avoid typing out 36 lines that are all trivial
19:05:32 <MichaelK> roboguy`: Though I don't know how to make it work without a wrapper type (unless I used incoherent)
19:06:23 <rofer> thanks
19:07:25 <rofer> ... and actually implementing this I realize I do have a method with a type like that
19:08:12 <roboguy`> MichaelK: it seems to compile without incoherent instances for my if I get rid of wrapped
19:08:16 <roboguy`> *for me
19:08:36 <MichaelK> does it work on any examples?
19:08:54 <MichaelK> I gotta run, will be back in ~30.
19:09:17 <roboguy`> MichaelK: dunno, but it type checks
19:17:10 <watChmeFly> Hey guys!
19:17:39 <nitrix> watChmeFly: New to irc :) ?
19:17:48 <watChmeFly> Nope, why?
19:18:11 <nitrix> Haven't seen someone say hi when they join a channel in a while.
19:18:27 <watChmeFly> Lol, I received a lot of help from a few people in here
19:18:33 <watChmeFly> and wanted to say hi to them haha
19:18:39 <watChmeFly> I was under a different handle though
19:19:02 <shanemikel> is there a way for me to define constructors for a sum type in different places?
19:19:20 <nitrix> shanemikel: Where else would it be?
19:20:10 <shanemikel> I'm trying to figure out how to organize a hierarchy of exception types
19:21:11 <nitrix> shanemikel: You're allowed to use the sum type in other contexts, like in other sum types or product types even. But the constructors are kind of tied to their defining type.
19:22:33 <nitrix> shanemikel: On the other hand, nothing prevents you from having some abstract type that hide internally, and provide helper functions, I think they call them smart constructors?
19:22:57 <nitrix> shanemikel: Kind of like `singleton` for Set. It builds a set of one element, abstracting the datastructure from you.
19:23:18 <nitrix> No sure if that helps.
19:23:21 <nitrix> *not
19:23:52 <nitrix> fromList is another example.
19:25:23 <shanemikel> data SqrtException = LessThanZero deriving (Show, Eq, Exception, IllegalOperandException)
19:25:24 <shanemikel> sqrt' :: (Floating a, Ord a) => a -> Throws SqrtException a
19:26:04 <shanemikel> that's the sort of think I would like to do, but it prevents me from using a monad like Either, because the kind is messed
19:28:06 <shanemikel> sorry, pretend that Throws is Either, and I'm trying to use sqrt' in the Either monad with another Exception e => Either e a
19:29:26 <shanemikel> I'm definitely open to the notion that this is ill conceived
19:30:15 <shanemikel> but the basic idea (regardless of if it uses classes or whatever) is that I can define SqrtException wherever it makes sense
19:35:30 <shanemikel> I guess it's back to type school for me
19:44:34 * hackagebot heist 0.14.1.4 - An Haskell template system supporting both HTML5 and XML.  https://hackage.haskell.org/package/heist-0.14.1.4 (DougBeardsley)
20:08:23 <newcomer> How can I find the type of the single assignment operator (<-)? Typing :t (<-) in ghci gives a parse error.
20:12:15 <davean> newcomer: its syntax, it has no type
20:13:02 <davean> newcomer: "name <- m" translates to "m >>= (\name -> ...)"
20:13:28 <newcomer> davean, mmm, isn't it an operator with two arguments?
20:13:36 <davean> No
20:13:43 <davean> Its syntactic sugar
20:13:54 <nitrix> newcomer: `do` and `<-` are syntax elements.
20:13:58 <davean> As I said, it translates
20:15:11 <newcomer> davean, nitrix: OK, thanks for your help.
20:16:21 <nitrix> newcomer: For completeness, `do { foo; bar; }` translates to `foo >> bar`.
20:17:19 <newcomer> That was helpful. I'll look further into it later.
20:17:20 <newcomer> Thanks.
20:17:52 <nitrix> newcomer: Look at (>>) and (>>=), you'll imediatly understand the difference just with their type :)
20:17:58 <nitrix> Cheers.
20:18:02 <newcomer> nitrix, That will have me look at monand sequence operator :)
20:18:10 <newcomer> Thanks :)
20:18:19 <nitrix> Granted you understand monads, of course.
20:18:39 <newcomer> Not yet ..
20:21:20 <nitrix> It could still make sense without that knowledge though. (:: m b) vs. (:: a -> m b), the (>>=) is the appropriate monadic binding, where the result of the first computation is passed to the second computation (which is a function that accepts that argument, as the type conveniently shows). 
20:21:32 <nitrix> newcomer: (>>) on the other hand, ignores the value.
20:22:17 <nitrix> newcomer: So it makes sense that in a `do` block, the syntax element `<-` does (>>=) to bind the name to a variable in scope, while ommitting `<-` results in (>>) being used.
20:23:44 <nitrix> newcomer: Not the greatest explanation, but at least you're exposed to it so you know that it's a thing for later :)
20:24:37 <newcomer> nitrix, Yes. Just looked at the types of (>>) and (>>=) and I kind of understand what you mean.
20:25:24 <nitrix> putStrLn "Hello " >> putStrLn "World!"
20:25:42 <newcomer> yes, just did this :)
20:25:47 <newcomer> main = putStrLn "Hello " >> putStrLn "World!"
20:26:10 <nitrix> main = getLine >>= putStrLn
20:26:22 <nitrix> And here's the example where the result of the first computation is used for the second computation.
20:26:36 <nitrix> Which is the same as main = do { line <- getLine; putStrLn line }
20:26:41 <nitrix> Hope it clears things up.
20:26:54 <newcomer> nitrix, certainly did!
20:29:27 <nitrix> newcomer: Oh, the braces and the semi-colon is because it's written on a single-line.
20:34:54 * hackagebot werewolf 1.0.2.1 - A game engine for playing werewolf within an arbitrary chat client  https://hackage.haskell.org/package/werewolf-1.0.2.1 (hjwylde)
20:34:56 * hackagebot werewolf-slack 1.0.1.0 - A chat interface for playing werewolf in Slack  https://hackage.haskell.org/package/werewolf-slack-1.0.1.0 (hjwylde)
20:35:57 <QkE-> Hi guys!
20:43:14 <newcomer> davean> newcomer: "name <- m" translates to "m >>= (\name -> ...)"
20:43:23 <newcomer> Now that I understand (>>=), what fills the dots above?
20:44:45 <monochrom> the next few lines in your do-block.
20:45:23 <monochrom> example: "do { name <- m; whee (name + 1) }" = m >>= \name -> whee (name + 1)
20:46:26 <monochrom> another example: "do { name <- m; john <- whee (name + 1); jon john name" = m >>= \name -> whee (name + 1) >>= \john -> jon john name
20:46:35 <monochrom> it can go on and on
20:48:13 <newcomer> monochrom, Got it!
20:48:20 <emmanuel`>  Hello there, I have this type signature "(validateRow :: (Num a) => SimplexEntry a -> State (Maybe (SimplexEntry a)) (ValidRows a))". Does this make sense or do I have to use a monad transformer?
20:53:41 <emmanuel`> nvm
21:02:21 <MichaelK> Let's say I have a function `f :: Maybe String -> Maybe Bool -> Bool` and multiple classes with some `val_for_class :: a` instances for String,Bool. Is there a way to make a function `g` that takes some `val_for_class` and applies `f` to it twice? It seems that the type checker might have to be lazier to make it work
21:03:22 <MichaelK> e.g. `val_for_class` could be Data.Default.def or Nothing, but GHC locks in the type and says it doesn't match 
21:07:11 <MichaelK> If classes/constraints could be passed to functions, I could maybe do something like `h :: (SomeClass a, SomeClass b) => SomeClass -> (a -> b -> c) -> c`, but I think that might require dependent types (unless it can be done with type families or something..)
21:11:35 <watChmeFly> Anyone here good with SQL by any chance?
21:11:45 <watChmeFly> I tried the channel but people aren't active
21:13:06 <sm> evening all
21:13:17 <watChmeFly> hi
21:13:46 <sm> what is the proper way to "commit" a parsec parser, so that it reports an error and terminates parsing rather than just failing
21:13:47 <sm> ?
21:13:49 <Tene> watChmeFly: Sure, what do you need?
21:13:59 <watChmeFly> I am working on some sample problems
21:14:06 <watChmeFly> and I have solutions but no way of checkling them
21:14:09 <watChmeFly> checking*
21:14:18 <watChmeFly> Could you see if I'm right?
21:14:27 <Tene> Sure.
21:14:34 <watChmeFly> Thank you!
21:15:09 <watChmeFly> Ok so I have a relation student(ID, SibID,shoeSize, hobby) 
21:15:16 <watChmeFly> each student can have many siblings
21:15:27 <watChmeFly> FDs are ID -> shoeSize
21:15:35 <watChmeFly> and ID -> Hobby
21:15:36 <Tene> In pm please, so we don't spam the channel.
21:15:41 <watChmeFly> oh sorry
21:16:00 <pavonia> sm: There's e.g. runParser
21:16:50 <watChmeFly> Says youre away 
21:17:35 <sm> pavonia: that's what I'm doing right now.. doing a nested parse with runParser, and if it fails... calling error :/
21:18:56 <pavonia> Why do you use error?
21:19:36 <sm> now that I think of, this parser is run in ExceptT String IO, so I can use throwError
21:20:17 <sm> but if it were just in the Identity monad, what would I do ?
21:20:52 <pavonia> Depends on what you are trying to do
21:21:20 <sm> terminate parsing and make sure the user sees this parser's error
21:21:41 <pavonia> Well, that's exactly what runParser does
21:22:55 <sm> I think runParser returns the final error after trying all possible parses
21:23:19 <sm> I want to commit the current parse function, and prevent all further parsing 
21:24:01 <pavonia> So you want a backtracking parser to not backtrack but stop instead?
21:24:06 <sm> right
21:24:42 <sm> to give a more specific error message
21:24:56 <pavonia> Hhm, I don't know if that's even possible with Parsec
21:25:37 <sm> there's https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec.html#v:parserFail, but I think it just fails the current parse fn
21:31:57 * sm wonders what parserBind does
21:32:34 <sm> well I'll check backlog, if anyone knows. Night all
21:32:37 <pavonia> It's (>>=)
22:24:09 <HelloWorld_> Hello, World.
22:26:03 <HelloWorld_> I have a question about some troubles I'm having. Is anyone able to help?
22:28:28 <simpson> HelloWorld_: What's your actual question?
22:28:56 <HelloWorld_> I tried to compile my first program.
22:29:05 <HelloWorld_> A "Hello world", obviously.
22:29:19 <HelloWorld_> Literally copypasted everything down to the filename.
22:29:40 <HelloWorld_> GHC returned errors.
22:30:06 <HelloWorld_> Seemingly nonsensicle ones.
22:30:30 <HelloWorld_> http://lpaste.net/161653
22:32:21 <HallaSurvivor> hm...
22:32:25 <kadoban> HelloWorld_: What's .hc ?
22:32:28 <HallaSurvivor> ^
22:32:31 <simpson> HelloWorld_: Name your file with a .hs extension.
22:32:34 <kadoban> HelloWorld_: It should be .hs
22:32:46 <HelloWorld_> -_- Fuck me. That's it?
22:32:57 <HallaSurvivor> maybe?
22:33:00 <HallaSurvivor> everything else looks fine
22:33:07 <HelloWorld_> I can only apologise for my stupidity.
22:33:11 <simpson> HelloWorld_: Additionally, you may find that you need `module Main where` at the top of your file.
22:33:13 <HallaSurvivor> I've been there
22:33:20 <HelloWorld_> Yeah, works fine. Thanks.
22:33:25 <HallaSurvivor> No problem at all :)
22:34:07 <HallaSurvivor> if you have any more questions, always feel free to ask
22:34:36 <augur> does anyone have any experience with the smtp-mail package?
22:34:38 <HelloWorld_> A compiled helloworld is 3MB.... nice.
22:36:04 <HallaSurvivor> but look at how pretty the code is ;)
22:36:09 <simpson> HelloWorld_: What kind of size expectation did you have?
22:41:38 <obadz> HelloWorld_: Hello World is 815KB here
22:42:00 <HelloWorld_> Well.... what're you doing different?
22:42:44 <obadz> HelloWorld_: ghc --make ⇒ 1.3MB. After stripping it's 815KB…
22:43:08 <HelloWorld_> stripping?
22:43:22 <obadz> man strip
22:43:55 <HelloWorld_> Sounds naughty.
22:45:05 <obadz> it's part of the unix sex sequence, so it should be…
22:48:50 <jle`> from the 'ad' package, is there any way i can have my function accept both a (forall s. AD s (Forward a) -> AD s (Forward a)) and a (forall s. AD s (On (Forward (Forward a))) -> AD s (On (Forward (Forward a)))) ?
22:49:19 <jle`> i've tried things like (forall s. (Mode s, Scalar s ~ a) => s -> s), but then I can't properly call with things like 'recip'
22:50:06 <jle`> because though in practice Fractional a implies Fractional s for every instance of s, that isn't inferrable by GHC of course
22:50:43 <jle`> i could just manually add a Fractional, etc. constraint to the quantifier but i'd have to add it for everything I do...it looks like that'd be pretty arbitrary and it owuldn't scale
22:50:59 <jle`> i guess my end goal is to just be able to use both 'diff' and 'hessianProduct'
22:53:59 <jle`> i see that the 'Sparse' mode lets me do both with the same input function, but Sparse-mode AD has a bug that makes it unusable for me, numerically v.v it gives incorrect derivatives where Forward gives correct ones
22:54:00 <jle`> oh well
22:54:52 <jle`> otherwise it'd be nice to be able to get a single derivative out of the AD s (On (Forward (Forward a)) version
23:14:59 * hackagebot type-fun 0.1.0 - Collection of widely reimplemented type families  https://hackage.haskell.org/package/type-fun-0.1.0 (AlekseyUymanov)
23:34:52 <Lovepon> I...
23:35:02 <Lovepon> How do I make something like
23:35:14 * hackagebot mandrill 0.5.2.0 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.2.0 (AlfredoDiNapoli)
23:35:15 <Lovepon> :: [a -> b] -> a -> b
23:35:19 <Lovepon> Or something.
23:35:34 <Lovepon> Like, I know that the all functions in the list compose with each other.
23:35:38 <Lovepon> Is it possible?
23:35:51 <Lovepon> Say,
23:36:09 <Lovepon> [a -> b, b -> c, c -> d] -> a -> d
23:36:16 <Lovepon> Is that even possible?
23:40:25 <kadoban> Lovepon: [a -> b] -> a -> b  is a possible type, sure.
23:40:30 <Lovepon> kadoban: For head, I know.
23:40:53 <Lovepon> kadoban: But is what I want posssible?
23:41:12 <kadoban> Lovepon: [a -> b, b -> c, c -> d] -> a -> d … is not really sensical. There seem to be a couple of things wrong with that.
23:41:22 <Lovepon> kadoban: That's not a type.
23:41:30 <kadoban> What is it?
23:41:36 <Lovepon> Err
23:41:38 <Lovepon> Like
23:41:58 <Lovepon> foo [ f :: a -> b, g :: b -> c, g :: c -> d] :: a -> d
23:42:15 <Lovepon> OHHH
23:42:25 <kadoban> Yeah, that doesn't work correctly. A list is homogenous.
23:42:26 <Lovepon> I see what you mean now.
23:42:30 <Lovepon> Right.
23:42:47 <kadoban> So I mean you could have that type, but only if a ~ b ~ c ~ d
23:42:48 <Lovepon> kadoban: So, it's impossible?
23:43:13 <shachaf> It's possible but not with lists.
23:43:14 <kadoban> You could have (a -> b, b -> c, c -> d), I guess?
23:43:38 <Lovepon> shachaf: How about with heterogenous lists?
23:44:13 <kadoban> Yeah I mean I think hlist kind of works like a tuple, from what little I know, so that should be possible, maybe?
23:44:40 <shachaf> You can define your own type for it. data FreeCat k a b where { Nil :: FreeCat k a a; Cons :: k a b -> FreeCat k b c -> FreeCat k a c }
23:44:53 <shachaf> HList is not what you want.
23:44:58 <shachaf> Well, probably not.
23:45:15 <Lovepon> shachaf: May I ask why you called it FreeCat?
23:45:39 <Lovepon> shachaf: Also, I like what you did.
23:46:41 <shachaf> Because it's a free category.
23:47:41 <Lovepon> shachaf: What's the k there for?
23:48:31 <shachaf> In your case it's (->).
23:48:38 <Lovepon> shachaf: OHHHH
23:48:42 <Lovepon> I see.
23:50:08 <Lovepon> shachaf: Also, should that be `FreeCat k a c`?
23:59:10 <Lovepon> rip
23:59:21 <Lovepon> mass evacuation
23:59:23 <Lovepon> '_'
