00:05:04 * hackagebot skulk 0.1.0.0 - Eclectic collection of utility functions  https://hackage.haskell.org/package/skulk-0.1.0.0 (geekyfox)
00:25:34 * hackagebot gll 0.3.0.6 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.3.0.6 (ltvanbinsbergen)
01:00:37 <Gurkenglas> Is there something to allow caseMay, which wraps covered cases in Just and uncovered ones in Nothing?
01:00:49 <Gurkenglas> (or perhaps something that works for all Alternatives)
01:05:15 <srhb> Gurkenglas: Are you talking about inexhaustive patterns?
01:05:17 <srhb> If so, no.
01:10:13 <dysfun> what's the state of the art in what i'll term 'frontend dev usable' html templating?
01:15:19 <ggVGc> man I just realised something crap about lenses
01:15:27 <ggVGc> they break project searching and tags :(
01:15:44 <ggVGc> because the name of the lens will be foo while the record field will be _foo
01:16:24 <dysfun> your *autogenerated* lenses will (template haskell). but if you write it yourself it won't
01:17:20 <dysfun> it would be nice to pregenerate them
01:18:05 <ggVGc> yep
01:18:12 <ggVGc> well, I don't want to manually write lenses :(
01:18:18 <dysfun> i don't blame you
01:18:19 <ggVGc> that's whr thole reason I use the lens library at all
01:18:27 <dysfun> the other thing they break is my emacs flycheck checking
01:18:27 <ggVGc> well ,I just started
01:18:39 <ggVGc> but instantly I realised how much I use search to junmp to record field definitions
01:18:42 <ggVGc> and now I can't
01:18:44 <ggVGc> so that's a bit crap
01:18:53 <cocreature> there is always grep :P
01:19:04 <ggVGc> maybe I'll make a special search that tries with underscore before also..
01:19:09 <ggVGc> cocreature: yeah, that's what I use, except ag
01:19:12 <dysfun> haskell codebases tend to be small enough you know where things are and it's not too much more annoying
01:20:01 <ggVGc> I'm gonna adjust my search pattern to accept an optional preceding underscore
01:20:04 <ggVGc> that should solve it
01:20:15 <ggVGc> still unfortunate they don't show up in tags though
01:20:21 <ggVGc> but that could also be fixed with a regex..
01:21:58 <dysfun> i've largely given up on tags-based completion. i'm just pleased haskell-mode supports stack
01:22:26 <ggVGc> I don't use tags for completion
01:22:30 <ggVGc> just for jumping to places
01:22:33 <jle`> not sure if i'd call that a bad thing about lenses, it's more about switching to lens-base accessors for your records
01:22:44 <jle`> most of my lens usage doesn't involve anything with records or accessors
01:23:02 <ggVGc> I don't get how to write haskell programs without heavy use of records
01:23:10 <ggVGc> still waiting to be enlightened
01:23:19 <dysfun> it depends what you want to do
01:23:36 <jle`> well, i still use records, but my usage of lensy stuff for things not involving records is much higher than for things involving records :)
01:23:36 <dysfun> if many of your records are complicated, they might work better as tuples, for example
01:23:49 <dysfun> not complicated*
01:24:01 <ggVGc> currently my two projects are a fairly complex midi sequencer with layers of sequencing, and a web game with server and client in haskell
01:24:04 <ggVGc> both use records a lot
01:24:23 <dysfun> game programming you are always going to want records, no real getting around it
01:25:02 <ggVGc> I also find the code much more readble when glancing over it when there are explicit names of things
01:25:08 <ggVGc> rather then "third value of tuple)
01:25:09 <ggVGc> "
01:25:32 <dysfun> i think after a certain amount of time laziness takes over and you learn to see 2- and 3-tuples just as clearly
01:26:06 <ggVGc> dysfun: but then you've increased the complexity of your code for someone else getting into it
01:26:17 <ggVGc> there's more mental overhead reading tuples than records
01:26:34 <dysfun> not really
01:26:40 <dysfun> you let the type system take some of the slack
01:27:19 <dysfun> and by keeping it as a tuple you gain interoperability with existing code - bet noone's written any code that uses your records before
01:27:23 <ggVGc> dysfun: also, all of a sudden you want to add a new field to your data, and whoops, it now broke all of your type signatures
01:27:37 <ggVGc> rather than adding a record field and changing the default constructor
01:28:01 <dysfun> there is a time and a place for just using tuples and it's something you develop a taste for
01:28:05 * blume /unches some new types as always
01:28:12 * blume munches some new types as always
01:28:13 <ggVGc> yeah that interoperability argument is fair.. I've been thinking about that tradeoff
01:28:30 <blume> trade water my friend
01:28:48 <blume> OR
01:29:07 <dysfun> but also if you're modelling something you're likely to change the structure of, it probably should be a record
01:29:20 <ggVGc> problem is, how do I know from the start?
01:29:33 <ggVGc> I hardly ever know excatly how my darta needs to look until somewhere in the middle of the project
01:30:00 <dysfun> then use records. afterwards you may find ways to make it shorter with tuples
01:30:15 <dysfun> particularly if you realise a couple of builtins (or tuple lenses) can do the job in less code
01:30:44 <dysfun> and one day you may find you get an intuition for it. no promises though
01:30:58 <blume> wow
01:31:30 <ggVGc> I just had an interesting thought. It would be cool to be able to have i.e a two-field record and be able to use it as a tuple or record interchangably, by having the underlying representation of records actually be tuples
01:31:50 <ggVGc> so records would just be tuples with field names
01:32:22 <bluNitedMeeeeeee> sounds good
01:32:40 <dysfun> you would instead define a ToTuple typeclass and a convertor
01:33:08 <ggVGc> dysfun: yeah but it would maybe be cool if a language(maybe not haskell) just had that in the core
01:33:24 <bl108> ggVGc: let's wroite it.
01:34:01 <dysfun> actually in perl you can have an 'object' whose internal storage is an arrayref
01:34:10 <dysfun> but we don't generally recommend it
01:35:42 <ggVGc> blprotocolog: I actually really want to make a simple pure and immutable embeddable language, like a purely functional lua, but I don't have the time or experience to do it quickly
01:35:54 <ggVGc> I've implemented toy languages before, but not type systems or inference
01:36:11 <dysfun> you'd just use Algorithm W
01:37:07 <ggVGc> dysfun: "just use", sure, but I don't really have much knowledge about type theory or how to implement types reasonably
01:37:14 <ggVGc> it would take me a lot of trial and error
01:37:18 <ggVGc> which is fine, but I doin't have the time
01:37:34 <dysfun> or just use someone else's. building a language is a very complex topic
01:37:39 <ggVGc> right
01:37:59 <ggVGc> well, I looked at using purescript as a base for the compiler and lua for the runtime
01:38:28 <ggVGc> but purescript is already too big for what I want and cutting it down is maybe more work than starting from the beginning
01:38:38 <ggVGc> also thought about using a really early version of UHC or something
01:40:03 <bloooT> what would be the fun about that?
01:40:06 <bloooT> just asking.
01:40:28 <ggVGc> bloooT: I just want the product. I'm not that intereted in making the language
01:40:32 <ggVGc> I've made enough toy languages
01:40:40 <ggVGc> but an embeddable pure language would be useful to me
01:45:21 <Gurkenglas> You should be allowed to do eta reduction on caseof lines.
01:45:33 <louispan> Is the memo table described by http://community.haskell.org/~simonmar/papers/weak.pdf in hackage anywhere?
01:45:35 <blutmuh> Why not Gurkenglas ?
01:45:53 <blutmuh> louispan: you should read for yourself
01:45:54 <haskell274> Hi, I'm using hugs and when I do this data Shape = Circle Float | Rectangle Float Float
01:46:03 <haskell274> I get ERROR - Syntax error in expression (unexpected keyword "data")
01:46:08 <haskell274> I tried let and def but it didn't work
01:46:11 <Gurkenglas> blutmuh, I mean something like "case Just x -> f x; Nothing -> y" into "case Just -> f; Nothing -> y"
01:46:27 <blutmuh> oh Ok Gurkenglas 
01:46:35 <blutmuh> i thought you were kidding ;)
01:46:46 <dysfun> haskell274: leading whitespace or some code above it is not correctly terminated
01:46:54 <louispan> blutmuh: I did read the paper, but I couldn't find out any references to where the source code is released.
01:47:35 <haskell274> What do you mean?
01:47:43 <haskell274> I just put that one 
01:47:55 <haskell274> data Shape = Circle Float | Rectangle Float Float
01:47:57 <haskell274> like that
01:48:32 <dysfun> in a haskell file?
01:48:35 <haskell274> no spaces or anythinb before hand
01:48:35 <louispan> found it: https://hackage.haskell.org/package/stable-memo
01:48:35 <louispan> I don't know why my googling didn't find it before
01:48:40 <haskell274> no in hugs command line
01:48:57 <dysfun> oh, i don't know about hugs
01:49:13 <dysfun> probably you can't define datas at the terminal though
01:49:24 <dysfun> (put it in a file and load it)
01:51:58 <Moggle> i'm having issues with ambiguous types... i have a function which is returning a Rand g RollParseResult and I'm getting yelled at. The issue I guess that there's a layer of indirection... i'm returning rollGeneric :: (RandomGen g) => Text -> Rand g RollParseResult
01:52:03 <haskell274> what's the difference between data Tree a = Node a (Tree a) (Tree a) vs data Tree  = Node  (Tree) (Tree)
01:52:09 <Moggle> i figured the thing i'm returning this to could set the g
01:52:11 <Moggle> but this is not the case?
01:52:43 <ggVGc> Gurkenglas: how would that work?
01:52:49 <fractalsea> haskell274, you can't associate any data with the leaves
01:52:50 <ggVGc> that seems highly ambiguous to me
01:53:13 <blume> fractalsea: 
01:53:58 <haskell274> ok
01:54:06 <Gurkenglas> ggVgc, add temp_1 to both sides of the -> until it compiles?
01:54:29 <fractalsea> haskell274, oh and it's also not a tree because the `Tree` data constructors do do not take arguments (so you can't have subtrees)
01:54:50 <Gurkenglas> Or can you think of an ambigious example?
01:55:01 <ggVGc> Gurkenglas: yeah, but how will the compiler then help you make sure you didn't write something you didn't intend to
01:55:05 <ggVGc> you love type safety I reckon
01:55:19 <ggVGc> ehh, you lose*
01:55:36 <Gurkenglas> Aw, woulda made sense without that edit too
01:55:51 <ggVGc> he
01:55:53 <ggVGc> h
01:56:14 <Gurkenglas> That same question could be asked about regular eta reduction
01:56:20 <ggVGc> hn, yeah fair
01:56:29 <ggVGc> anyway, yes, I've also wanted eta reduction on cases
01:56:36 <ggVGc> but I didn't think there was a reasonable way to do it
01:57:42 <Gurkenglas> It wouldn't bring the better inlining of regular eta reduction, but still
01:58:04 <raduom> Hi everyone. What do I have to choose from for a rest server?
01:58:32 <jle`> haskell274: your second type is equivalent to 'Tree ()'
01:59:02 <jle`> (for your first type)
02:00:10 <knupfer> is it possible to write a function  f :: TypeRep -> a -> [b]  which collects any b in the container a with the appropriate TypeRep?
02:00:17 <knupfer> perhaps with a type class?
02:00:18 <suppi> raduom, you mean which web framework?
02:00:46 <Gurkenglas> knupfer, lens's Folds do that
02:01:04 <knupfer> Gurkenglas, I'll look at that, thanks
02:01:19 <raduom> suppi: web framework that works with json / rest.
02:01:48 <Gurkenglas> knupfer, if you want to just always use the TypeRep that gets all as out of the a, and a has form f b, you want Foldable
02:02:10 <knupfer> I'm writing a css parser / minifier which has got the whole grammar encoded as a type and uses just a typeclass for printing and parsing, but I'm slowly going nuts...
02:02:39 <suppi> raduom, you have a lot of options i think. servant, scotty, spock, apiary, airship
02:03:07 <raduom> suppi: can you order them from most interesting to the least interesting? :P
02:03:18 <ggVGc> raduom: I just wrote my first web thing in haskell, and I used Scotty, and have been very content. It's very straight forward, and using WAI you can pull in other web related modules and it all composes nicely
02:03:22 <ggVGc> so you can pick and choose
02:03:45 <ggVGc> raduom: also Servant looks real good
02:04:01 <zomg> Scotty is nice and probably fairly easy for newcomers too
02:04:22 <zomg> Servant is probably more "magical" and potentially hard to understand if you need to do something different or run into errors
02:04:26 <suppi> raduom,i think all are interesting. servant being the most. i'd look 'em up and go with the one that has the most documentation ;)
02:04:41 <Gurkenglas> knupfer, because of all the boilerplate? I just used Data.Functor.Foldable (horrible docs) to do some refactoring in http://codereview.stackexchange.com/questions/124390/data-structure-for-expression-evaluation
02:04:53 <raduom> suppi: thanks. i am doing that now :)
02:04:59 <ggVGc> raduom: This is my main, usinc Scotty for HTTP handlers, a "static content" WAI plugin for hosting static files, and websockets-wai for serving websockets, https://gist.github.com/a5d71278f2fff918b325a4f5e7ad1db6
02:05:07 <ggVGc> and they all just fit nicely together because they're all built on WAI
02:05:09 <suppi> raduom, good luck :)
02:07:22 <knupfer> Gurkenglas: Yeah, to avoid the boilerplate.  I can use newtype-derive nearly anything and optimize while printing simply by writing a small custom instance for a type.
02:07:23 <Moggle> I think the problem with my code is that the type of an expression inside my code is not necessarily constrained to be the same as the type of the function itself, eg. some f :: (Constraint a) -> a -> Text with an expression inside with the type (Constraint b) -> b
02:07:28 <Moggle> how can I tell GHC that these types are the same?
02:07:57 <knupfer> This avoids a lot of headaches because of the wonky nesting of css.
02:12:32 <orb> Do MonadPrompt and free monads do the same thing?
02:16:31 <jle`> their practical use cases in the real world often overlap
02:16:33 <knupfer> Gurkenglas: Is there some good tutorial for lens?
02:16:47 <jle`> but i'm not sure it's safe to say that they do the "same thing"
02:16:47 <Gurkenglas> lens is the new monad in terms of tutorials
02:17:05 <jle`> they might be equivalent in power, if that even means anything :)
02:17:23 <knupfer> ok
02:17:37 <suppi> knupfer, http://hackage.haskell.org/package/lens-tutorial-1.0.1/docs/Control-Lens-Tutorial.html
02:17:58 <michaelt293> knupfer, https://artyom.me/lens-over-tea-1
02:19:40 <Gurkenglas> Would be nice if you could replace makeLenses with a deriving clause
02:19:49 <knupfer> thanks!
02:21:04 <jle`> Gurkenglas: the main issue is that the names of the identifiers that it creates has to be dynamically generated
02:21:32 <jle`> i think that's the only situation where TH is still needed w.r.t. utility functions like these, compared to more modern solutions using Generic or Data
02:21:54 <jle`> i'm not sure how generics and stuff would be able to overcome it :'(
02:22:09 <jle`> but i think new GHC extensions coming out soon will give you automatically generated lenses for record fields
02:23:08 <jle`> but yeah, it's been nice to see generics replacing TH over these years for things like automatic json instances, serialization schemes, etc
02:26:01 <michaelt293> I have added a travis script to a project I am working on put the build is failing. I am using the script provided in https://www.fpcomplete.com/blog/2015/08/new-in-depth-guide-stack and I am getting the following error "No GHC found, expected version 7.10.3 (x86_64) (based on resolver setting in /home/travis/build/Michaelt293/isotope/stack.yaml). Try running stack setup"
02:26:35 <michaelt293> should I try running stack setup inside or outside of my project? 
02:26:44 <cocreature> inside
02:27:33 <cocreature> michaelt293: also this guide seems to be a few months old, it might be worth comparing it to http://docs.haskellstack.org/en/stable/travis_ci/
02:27:55 <michaelt293> thanks
02:34:21 <orb> jle`: Or my question is rather: I have some IO code, and I'd like to convert it to something testable.  Is Free or Prompt the better idea or something different?
02:36:38 <jle`> i think, if you are trying to simulate algebraic effects, then operational/MonadPrompt would be more natural
02:37:19 <jle`> but people use 'free' for the same thing
02:37:49 <jle`> i think they're both two ways to get to the same end, more or less
02:50:10 <orb> jle`: Thanks!
02:50:43 <jle`> i'm assuming that by MonadPrompt you mean the MonadPrompt library / similar things like operational, right?
02:55:13 <Gurkenglas> It doesn't have to be not using TH, just sugar that is by default put right next to the data definition and adds only one token would be nice
02:55:38 * hackagebot twitter-conduit 0.1.3 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.1.3 (TakahiroHimura)
03:05:39 * hackagebot werewolf-slack 0.2.0.2 - A Slack chat client for playing werewolf  https://hackage.haskell.org/package/werewolf-slack-0.2.0.2 (hjwylde)
03:10:39 * hackagebot werewolf-slack 0.3.0.1 - A Slack chat client for playing werewolf  https://hackage.haskell.org/package/werewolf-slack-0.3.0.1 (hjwylde)
03:33:17 <malade_mental> Hi, I'm sorry but I'm very noob but I don't find the answer to this very noob question : How to print Int type? (i'm reading "haskell the craft of functional programming" right now)
03:37:14 <orb> malade_mental: just use print.
03:37:22 <orb> malade_mental: as in: main = print 23
03:37:40 <orb> malade_mental: print is overloaded and can deal with any `Showable' type.
03:37:46 <malade_mental> ok 
03:37:51 <malade_mental> so here's my example
03:38:15 <orb> malade_mental: I hope you are going to put the example into lpaste, if it's more than one line? ;)
03:38:37 <malade_mental> https://paste.debian.net/423307/ orb 
03:39:02 <malade_mental> don't worry I'm noob at haskell but not IRC ;)
03:39:18 <orb> malade_mental: remove the dot
03:39:31 <orb> Just: main = print example
03:39:45 <orb> example is just a number, not a function.  Hence no function composition (.) necessary
03:40:06 <malade_mental> ok, that's what I didn't got
03:40:09 <malade_mental> thanks a lot orb 
03:40:15 <orb> Also no need to import System.Environment
03:40:22 <orb> print is in the standard prelude.
03:40:27 <orb> Ie imported by default.
03:41:50 <orb> malade_mental: You're welcome.  Have fun with Haskell!
03:41:53 <malade_mental> yup
03:42:22 <malade_mental> and if I wanted to use directly the square function behind print, I would have written : print . square 2
03:42:25 <malade_mental> ?
03:42:41 <orb> Multiple possibilities.
03:42:45 <orb> print (square 2)
03:42:52 <orb> print . square $ 2
03:42:55 <orb> print $ square 2
03:43:06 <malade_mental> fine!
03:43:08 <orb> Using parens is the easiest to understand here.
03:43:17 <malade_mental> yup
03:44:09 <raduom> is there something like persistent but without the template haskell?
03:44:25 <malade_mental> see you soon!
03:52:20 <Heather> how to IO a -> Maybe (IO a)
03:55:33 <jle`> Just :: IO a -> Maybe (IO a) ?
03:55:55 <jle`> :t Just `asAppliedTo` getLine
03:55:56 <lambdabot> IO String -> Maybe (IO String)
03:56:35 <jle`> or alternatively, const Nothing
03:56:46 <jle`> is there anything that you want this function to do in particular?
03:57:00 <xa0> :t asAppliedTo
03:57:01 <lambdabot> (a -> b) -> a -> a -> b
03:57:21 <xa0> i don't get it
03:57:34 <jle`> it gives you the type of the function if it were applied to the thing on the right
03:57:47 <xa0> oh!
03:57:49 <jle`> > Just `asAppliedTo` True
03:57:51 <lambdabot>  <Bool -> Maybe Bool>
03:58:11 <jle`> so Just :: Bool -> Maybe Bool, when it's being used with True
03:58:21 <xa0> fair enough
03:58:25 <jle`> the definition is asAppliedTo f _ = f
03:58:45 <jle`> with the right type annotation of course
03:59:12 <jle`> f `asAppliedTo` _ = f
04:01:37 <haskell274> what does $ do?
04:02:14 <jle`> the definition is "f $ x = f x"
04:02:22 <jle`> so, "show $ 1" is "show 1"
04:02:28 <jle`> > show $ 1
04:02:29 <lambdabot>  "1"
04:02:33 <jle`> > show 1
04:02:35 <lambdabot>  "1"
04:03:09 <jle`> @src ($)
04:03:09 <lambdabot> f $ x = f x
04:03:58 <haskell274> okay
04:03:59 <haskell274> so surface (Circle _ _ r) = r 
04:04:14 <haskell274> this works if I do surface $ Circle 0 0 20
04:04:18 <haskell274> but if I remove $ then it doesn't
04:04:46 <jle`> yes, because surface Circle 0 0 20 is parsed as ((((surface Circle) 0) 0) 20)
04:04:50 <jle`> which doesn't really make sense
04:04:58 <haskell274> ah ok
04:05:02 <jle`> you want surface (Circle 0 0 20), not ((((surface Circle) 0) 0) 20)
04:05:05 <haskell274> alright another question then
04:05:10 <haskell274> I make this
04:05:11 <haskell274> surface2 r  = (Circle r r r)
04:05:18 <haskell274> then call surface2 5
04:05:26 <haskell274> it doesn't work
04:05:34 <jle`> what do you mean by "doesn't work"?
04:05:39 <haskell274> ERROR - Cannot find "show" function for:
04:05:49 <haskell274> *** Expression : surface2 2
04:05:59 <haskell274> *** Of type    : Shape
04:06:01 <haskell274> and Shape is
04:06:02 <jle`> oh, are you trying to show the result?
04:06:08 <haskell274> data Shape = Circle Float Float Float | Rectangle Float Float Float Float   
04:06:10 <haskell274> yes
04:06:12 <jle`> the function call itself works
04:06:15 <haskell274> I wan to get Circle 20 20 20 back
04:06:17 <jle`> but you're trying to print out a Shape
04:06:21 <jle`> you do get Circle 20 20 20 back
04:06:26 <jle`> but the problem happens when you try to print it out
04:06:46 <haskell274> hmm
04:06:49 <jle`> if you don't believe me, try doing surface (surface2 20) and getting 20
04:06:53 <jle`> surface2 works :)
04:07:07 <jle`> but right now you haven't defined a way to print a Shape
04:07:14 <haskell274> Oh
04:07:17 <haskell274> it does work!
04:07:20 <jle`> hooray
04:07:20 <haskell274> how do I define that?
04:07:31 <jle`> you can write it by hand, or you can have the compiler write it for you
04:07:41 <jle`>  by typing "deriving (Show)" after the data type declaration
04:07:45 <haskell274> okay I want compiler to do it
04:07:57 <jle`> data Shape = blah blah blah
04:08:00 <haskell274> can I put that in the definition?
04:08:00 <jle`>   deriving (Show)
04:08:18 <haskell274> huh?
04:08:23 <haskell274> deriving (Show) ?
04:08:26 <jle`> yes
04:08:35 <jle`> just put that the line after your definition for Shape
04:08:36 <haskell274> as in deriving (Shape) ?
04:08:42 <jle`> no, deriving (Show)
04:08:46 <koz_> No, as in 'deriving (Show)'.
04:08:52 <jle`> the Show instance, which tells haskell how to print it out
04:08:55 <koz_> That means 'compiler, make this an instance of Show so I can print it'.
04:09:06 <jle`> 'Show' is a typeclass that you can use to turn things into strings that represent them
04:09:09 <haskell274>  Syntax error in input (unexpected keyword "deriving")
04:09:27 <jle`> it's what 'print' uses :)
04:09:34 <jle`> hm, did you indent it like i did earlier?
04:09:45 <haskell274> new line and indent?
04:09:50 <haskell274> what is it Python?
04:10:00 <jle`> nope, haskell
04:10:18 <haskell274> is it like Ruby where I can replace it with curly braces?
04:10:20 <jle`> without the indent the compiler thinks that you're done talking about Shape and started talking about something else
04:10:34 <jle`> the indent tells the compiler that you're not done yet, you also want to derive Show
04:10:38 <haskell274> ok it works
04:10:39 <jle`> you can just put it all on one line too
04:10:46 <jle`> data Shape = blah blah blah deriving (Show)
04:10:56 <jle`> but that's often not as readable
04:11:15 <haskell274> alright
04:11:18 <haskell274> that's great now
04:11:22 <haskell274> it works fine
04:11:23 <jle`> easier to just put it on the next line, but indent it to tell ghc you mean it to refer to 'Shape'
04:11:33 <jle`> hooray!
04:12:26 <merijn> Obligatory recommendation to review the haskell layout rules
04:14:20 <raduom> what does the ~ mean in the following class constraint: ( PersistEntity record
04:14:21 <raduom>       , PersistEntityBackend record ~ backend
04:14:21 <raduom>       , PersistStore backend
04:14:22 <raduom>       ) => ?
04:14:55 <haskell274> data Shape a = Circle a (Float a) | Null deriving(Show) 
04:14:56 <haskell274> how come this doesn't work?
04:15:27 <jle`> raduom: it means that `PersistEntityBackend record` is constrained to be the same as `backend`
04:16:02 <raduom> jle`: is there a ghc extension involved?
04:16:11 <jle`> haskell274: 'Float a'
04:16:18 <jle`> the normal Float type doesn't have a type parameter
04:16:32 <jle`> but i'd hope that the error message tells you this?
04:16:34 <knupfer> What is the recommended approach for generic programming?  Syb, Generics or Uniplate?
04:16:38 <merijn> raduom: ~ is type unification, which you can (sloppily) think about as "type equality"
04:17:05 <knupfer> I've read that generics is the most 'modern'...
04:17:10 <haskell274> yeah
04:17:15 <haskell274> I have this example
04:17:25 <haskell274> Tree a = Node a (Tree a) (Tree a)
04:17:28 <merijn> raduom: "Maybe a ~ Maybe Int" is true, if "a ~ Int" (i.e. if everything still typechecks when 'a' is forced to be Int, then "a ~ Int")
04:17:38 <haskell274> I want a simplified version of this
04:17:48 <haskell274> it's confusing me
04:17:48 <jle`> simplified in what way?
04:17:55 <haskell274> I want simplier data structure
04:18:03 <haskell274> to understand parameters in data types
04:18:08 <jle`> how about data Tree a = Node
04:18:14 <jle`> that's simpler :)
04:18:22 <raduom> merijn: is there a page where i can read more about it?
04:18:33 <merijn> haskell274: Lemme rewrite an example using the regular syntax and the (in my opinion more newbie friendly) GADTSyntax version
04:18:35 <jle`> it just has one constructor with no arguments
04:19:06 <jle`> but earlier, you probably meant data Shape a = Circle a Float | Null, right?
04:19:19 <jle`> what did you think "Float a" meant?
04:19:28 <merijn> haskell274: http://lpaste.net/158128
04:19:40 <raduom> merijn: in my example the use of ~ backend is like a shortcut for writing PersistStore PersistEntityBackend record as PersistStore backend?
04:20:41 <haskell274> data Tree a = Node
04:20:41 * hackagebot scrape-changes 0.1.0.0 - Scrape websites for changes  https://hackage.haskell.org/package/scrape-changes-0.1.0.0 (2chilled)
04:20:42 <haskell274> This
04:20:45 <haskell274> what's the use of a?
04:21:21 <merijn> haskell274: Do you know another language? (say, java?)
04:21:25 <jle`> consider a type that's like an Int tree --
04:21:34 <jle`> data IntTree = Node Int IntTree IntTree
04:21:43 <jle`> or a BoolTree -- data BoolTree = Node Bool BoolTree BoolTree
04:21:54 <jle`> the parameter lets you parameterize your type
04:22:15 <jle`> instead of having to do IntTree = IntNode Int IntTree IntTree, and BoolTree = BoolNode Bool BoolTree BoolTree
04:22:15 <xa0> like templating in C or generics in Java
04:22:26 <haskell274> yes
04:22:28 <jle`> we can just do Tree a = Node a (Tree a) (Tree a)
04:22:30 <haskell274> data Tree a = Leaf a | Node a (Tree a) (Tree a) deriving Show
04:22:33 <haskell274> this how do I print it
04:22:40 <jle`> so, `Tree Int` would be a tree of Int's
04:22:41 <haskell274> (Leaf a) doesn't work
04:22:51 <merijn> raduom: Well, PersistStore and PersistEntityBackend are both "associated types" (I think? I don't know persist), i.e. "type level functions". What this constraint says is that this function only typechecks if "PersistEntityBackend record" and "PersistStore backend" return the same type as a result
04:23:06 <jle`> if you had a `Tree Int`, you'll have a type with leaves containing Int's and Nodes containing Int's
04:23:35 <raduom> merijn: that makes sense. thanks.
04:23:46 <jle`> instead of having to write data IntTree = ILeaf Int, data BoolTree = BLeaf Bool, data StringTree = SLeaf String
04:23:57 <haskell274> okay
04:24:03 <jle`> you can write data Tree a = Leaf a.  and `Tree Bool` is your BoolTree, etc.
04:24:11 <haskell274> so a can be another data type
04:24:18 <haskell274> to define it later on somewhere else?
04:24:19 <haskell274> or use it
04:24:21 <jle`> yeah, it's just anything to parameterize it by
04:24:33 <jle`> when you say data Tree a = ..., you're really defining a bunch of different types you can use
04:24:35 <haskell274> so how come Leaf 5 doesn't work then?
04:24:40 <jle`> you can use Tree Int, or Tree Bool, or Tree String ...
04:24:47 <haskell274> oh wait
04:24:48 <haskell274> it does
04:24:49 <haskell274> my bad
04:24:50 <haskell274> sorry
04:24:58 <jle`> "Leaf 5" as a value would be something of type Tree Integer or Tree Float or something
04:25:10 <jle`> "Leaf True" would be a value of type Tree Bool
04:25:20 <jle`> Leaf "hello" would be a value of type Tree String
04:25:39 <haskell274> (Node 5 (Tree 5) (Tree 5))
04:25:42 <haskell274> this doesn't work tho
04:25:55 <jle`> "Tree" is not a data constructor
04:26:01 <jle`> only Node and Leaf are, here
04:26:09 <jle`> "Tree 5" doesn't work on its own, either
04:26:20 <haskell274> so what do we put there instead?
04:26:22 <haskell274> either node or leaf?
04:26:24 <jle`> what do you want?
04:26:30 <jle`> you can put any Tree there
04:26:37 <jle`> any `Tree Int` there
04:26:46 <jle`> 'Node 4' is a perfectly good Tree Int that you can put there
04:26:49 <jle`> er, sorry, Leaf 4
04:26:53 <haskell274> okay
04:26:59 <jle`> Node 10 (Leaf 5) (Leaf 3) is another good Tree Int you can put there, too
04:27:12 <jle`> Node 1 (Node 5 (Leaf 0) (Leaf 9)) (Leaf 4) is another one
04:27:18 <haskell274> So if I'm putting Node somewhere
04:27:19 <jle`> it depends on the tree you want to make
04:27:30 <haskell274> I have to add 2 more Tree
04:27:37 <haskell274> I see now
04:27:41 <jle`> yeah, that's what the data declaration syntax says
04:27:44 <jle`> Node a (Tree a) (tree a)
04:27:50 <jle`> it takes a value, and two trees
04:27:52 <haskell274> I see
04:27:55 <haskell274> it's like struct in C
04:27:58 <haskell274> not quite classes
04:28:02 <haskell274> like other langs
04:28:26 <jle`> yeah, single constructors like that work like structs
04:28:27 <haskell274> Now I have another question
04:28:29 <jle`> in a way
04:28:37 <haskell274> data Tree a = Leaf a | Node a (Tree a) (Tree a)
04:28:39 <haskell274> which ones here
04:28:49 <haskell274> we defined and which ones were already in prelude?
04:28:52 <haskell274> how do we understand that
04:39:42 <haskell274> Sorry
04:39:44 <haskell274> another question
04:39:45 <haskell274> data Tree a = Node a (Tree a) (Tree a)
04:39:58 <haskell274> how do I recurse through this tree?
04:40:42 * hackagebot gll 0.3.0.7 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.3.0.7 (ltvanbinsbergen)
04:45:06 <jpll> the basic approach is to pattern match on the different data constructors, and I would suggest looking through some foundational texts on how to use haskell, such as learnyouahaskell.com
04:45:21 <jpll> not sure if it's entirely up-to-date, but should cover most of what you're interested in
04:45:39 <haskell274> Found it
04:45:40 <haskell274> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
04:45:52 <haskell274> lol it actually has exactly the same quesiton in my homework
04:45:59 <haskell274> I wonder if professor copied pasted it :/
04:46:29 <jpll> for the sake of your own understanding, I would try to work through it methodically anyway, maybe make your own examples
04:59:16 <knupfer> Gurkenglas: I ended up using syb
05:08:48 <cocreature> > abs (-9223372036854775808) :: Int
05:08:50 <lambdabot>  -9223372036854775808
05:08:58 <cocreature> who thought that would be a good idea?
05:09:11 * xa0 frowns
05:09:13 <xa0> what
05:09:24 <merijn> Overflow of Int wraps arround
05:09:34 <xa0> oh of course, it's just out
05:09:37 <cocreature> I’d expect an exception in this case
05:09:51 <merijn> cocreature: fromIntegral always silently wraps around
05:10:27 <haskell274> What's the difference between func :: Ord a => a -> Tree a vs func :: a -> Tree a
05:10:38 <merijn> cocreature: I feel your pain, which is why I wrote (the severely undertested and in need of an update): https://hackage.haskell.org/package/validated-literals
05:10:43 <cocreature> merijn: but it should only call fromIntegral before reading it in, right? so abs could still write an exception
05:11:09 <cocreature> s/write/throw/
05:11:29 <jpll> haskell274: http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
05:13:38 <merijn> cocreature: No, because the literal is Integer
05:14:00 <merijn> cocreature: So you're abs-ing a negative Integer and then converting to Int, I think?
05:14:10 <merijn> cocreature: Anyway, I think GHC has warnings for this now
05:14:20 <merijn> And I'd love feedback on the library
05:14:28 <cocreature> merijn: wait how I’m I converting an Integer to an Int?
05:14:56 <cocreature> abs has type Num a => a -> a, if I force the result to be Int the input has to be Int
05:15:01 <cocreature> so I’m abs-ing an int
05:16:01 <merijn> Hmm, lemme think the current code is "abs (fromInteger (-9223372036854775808) :: Int)"
05:16:11 <merijn> > fromInteger (-9223372036854775808) :: Int
05:16:13 <lambdabot>  -9223372036854775808
05:16:20 <cocreature> that’s -2^63
05:16:53 <merijn> > (abs -9223372036854775808) :: Int
05:16:54 <lambdabot>      Couldn't match expected type ‘Int’
05:16:55 <lambdabot>                  with actual type ‘Integer -> Integer’
05:16:55 <lambdabot>      Probable cause: ‘abs’ is applied to too few arguments
05:17:08 <merijn> > abs (-9223372036854775808) :: Int
05:17:09 <lambdabot>  -9223372036854775808
05:17:12 <merijn> > abs (-9223372036854775807) :: Int
05:17:13 <lambdabot>  9223372036854775807
05:17:17 <merijn> mmmm
05:17:20 <merijn> Nasty
05:17:25 <cocreature> it’s abs that doesn’t guarantee that it’s result is positive
05:17:41 <cocreature> sounds like a “fun” bug to debug
05:18:02 <merijn> cocreature: Yes, I know because I debugged a similar one in the runtime >.>
05:18:26 <cocreature> I would guess that at some point it just calls C abs which does the same
05:18:43 <merijn> Sigh
05:18:45 <merijn> No
05:18:56 <merijn> cocreature: GHC doesn't call C code for numeric code
05:18:59 <merijn> "abs n  = if n `geInt` 0 then n else negate n"
05:19:09 <merijn> "negate x            = 0 - x"
05:19:33 <xa0> at least ghci gives a negativeliterals warning
05:19:35 <merijn> cocreature: File a ticket on trac/start a discussion on library@
05:19:44 <merijn> xa0: So does GHC with warnings enabled
05:20:11 <xa0> yeah
05:20:26 <cocreature> merijn: will do sometime later, thanks
05:21:14 <haskell274> Sorry I'm asking my homework but
05:21:15 <haskell274> tsort :: Ord a => [a] -> [a]
05:21:25 <cocreature> merijn: also it calls negateInt# if you want to be precise :)
05:21:26 <haskell274> does [a] have to be the same datatype as the second [a] ?
05:22:32 <merijn> cocreature: oh, was looking at the wrong code :)
05:22:51 <merijn> haskell274: Yes, all a's in the type signature must refer to the same type
05:23:32 <haskell274> but not same value?
05:23:34 <cocreature> merijn: btw the source links in the haddocks for validated-literals are broken
05:24:18 <Gurkenglas> Feels like every second package I try to install via stack it tells me to add another package to the extra-deps. Why isn't this automatic?
05:24:20 <haskell274> I had this
05:24:21 <haskell274> trav :: Tree a -> [a]
05:24:25 <haskell274> this one is different tho
05:24:34 <haskell274> it takes a Tree but returns a list of values
05:24:39 <maerwald> Gurkenglas: cause stack is broken?
05:24:46 <cocreature> Gurkenglas: there is stack solver iirc
05:26:04 <Gurkenglas> That one fails complaining about there being no cabal file - I think that's because I'm not running it in a project, I'm just installing like "stack install gloss"
05:27:03 <merijn> cocreature: hmmm, odd, I'll check into it later
05:27:19 <merijn> cocreature: You can look up the source on github, it's only two files and like 30 lines or so of haskell
05:28:08 <cocreature> merijn: yeah I was just being lazy :)
05:28:33 <Gurkenglas> Oh and looks like gloss doesn't work in the latest stack resolved because OpenGL is 3.* for me
05:28:46 <merijn> cocreature: Basically it uses Typed TH to do conversions at compile time (and if possible) splice the result into the AST. (Or if that's not possible it does the less performant thing of splicing a "fromJust" around the conversion into the source)
05:29:13 <merijn> cocreature: Which, assuming a pure conversion function should be safe, but slightly costlier due to redoing the conversion at runtime
05:29:46 <haskell274> You know this
05:29:47 <haskell274> insertAll (x:xs)
05:29:54 <haskell274> takes 1st element and remains the rest
05:30:06 <haskell274> how do I do that if I want to take first 3 elemens and remain the rest?
05:33:08 <obadz> haskell274: f (x1:x2:x3:xs) ?
05:35:55 <Gurkenglas> Can you recommend a library that I can use to make a quick GUI thing, or a way to get stack to work?
05:37:20 <Gurkenglas> (looks like this http://lpaste.net/1690671484743188480 )
05:37:30 <sm> Gurkenglas: fltkhs
05:38:14 <fr33domlover> I'm implementing a network protocol and I use IO functions with a Handle I get from a Socket ('network' package). But I want the same protocol to work over several transports, e.g. plain TCP; TCP with TLS; SSH; maybe more. What would be a good way to abstract over these things? My own monad transformer / monad class? Maybe use a Pipe / Conduit? Use a pair of Chan Word8 instead of a Handle? Or maybe use
05:38:17 <fr33domlover> Handle with the pipe(2) syscall and manipulate the data in the middle?
05:38:32 <fr33domlover> (it's an application level protocol)
05:39:57 <merijn> fr33domlover: Quick word of warning
05:40:14 <merijn> fr33domlover: Unlike Sockets Handle's are mutual exclusion for reading/writing
05:40:40 <merijn> fr33domlover: So if you have threads simultaneously reading/writing from the same socket you'll lose throughput using Handle
05:40:45 <Gurkenglas> sm, http://lpaste.net/158132 it wants some sort of FLTK_HOME? Windows 10 here.
05:41:19 <merijn> fr33domlover: I would use Chan in the application and have different calls that take a Chan of messages and translate it to the relevant transport
05:41:30 <fr33domlover> merijn, thanks for the warning! So you think in cases it matters I should use Socket and not Handle?
05:41:41 <cocreature> merijn: I thought Handle has an mvar inside that ensures synchronization and blocks?
05:41:42 <Gurkenglas> Oh, stack install isnt enough and the haddock explains more.
05:41:47 <Gurkenglas> *sm
05:41:47 <merijn> "plainTCP :: Chan Message -> IO ()" which forks threads
05:41:55 <merijn> cocreature: It does, that's what I'm referring too
05:42:02 <fr33domlover> merijn, btw the protocl is the git pack protocol
05:42:10 <fr33domlover> what does the git pull/push
05:42:16 <fr33domlover> implementing it in Haskell
05:42:25 <merijn> cocreature: Sockets can be safely read/written simultaenously, so this MVar is a useless bottleneck for sockets
05:42:27 <cocreature> merijn: oh sry I read “lose messages” instead of throughput
05:42:41 <cocreature> looking at the source there is also a DuplexHandle constructor
05:43:00 <cocreature> (I’m not saying you’re wrong, I’m just interested :))
05:43:01 <merijn> fr33domlover: It's not likely to matter a lot, just something to be aware of :)
05:43:47 <merijn> cocreature: Oh, maybe there's a Duplex mode toggle somewhere?
05:43:54 <merijn> That'd be cool
05:44:06 <cocreature> no idea here’s the source https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.IO.Handle.Types.html#Handle
05:44:14 <fr33domlover> merijn, the protocol is implemented using Data.Binary.{Get,Put} so the raw data on which I operate it bytes
05:44:26 <fr33domlover> but is Chan Word8 a good idea?
05:44:43 <fr33domlover> then e.g. is can be packetized for TLS and SSH etc. as needed
05:44:50 <fr33domlover> s/is/it
05:45:21 <cocreature> merijn: mkHandleFromFD checks the type https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.IO.Handle.FD.html#mkHandleFromFD
05:46:50 <cocreature> it looks like it should turn out to be duplex but I haven’t looked to closely
05:47:47 <cocreature> yep socketToHandle passes Stream as the socket type
05:47:52 <cocreature> so it will be a DuplexHandle
05:48:56 <merijn> fr33domlover: Chan Word8 sounds like a terrible idea :)
05:49:22 <merijn> fr33domlover: Why not "Chan GitMessage" and have a serialiser for messagers that is reused by different protocols?
05:49:40 <fr33domlover> If I use a Chan, I can hide this detail by passing the logic component 2 functions, one for sending and one for receiving. I can then even put them in a ReaderT for conveience. But then isn't is wheel reinvention of pipes and conduit?
05:49:46 <fr33domlover> merijn, i could do that, yeah
05:49:57 <fr33domlover> but the protocol isn't even based
05:50:01 <merijn> fr33domlover: Reading from a Chan is fairly expensive
05:50:10 <merijn> fr33domlover: Doing so for every byte will kill your performance
05:50:27 <fr33domlover> there are several stages: server sends message A, client sends message B, server sends message C... 
05:50:30 <fr33domlover> and so on
05:50:38 <fr33domlover> merijn, ok thanks for warning me :)
05:50:56 <exio4> merijn: unagi-chan :P
05:51:00 <merijn> exio4: Even then :)
05:51:22 <exio4> it will be faster than with a naive chan though!
05:51:31 <merijn> You need a memory barrier/atomic operation for concurrent channels, which is always more expensive than serialising large chunks
05:51:59 <cocreature> at least use Chan ByteString or something like that, but pipes/conduit/… might be worth a look
05:52:02 <fr33domlover> merijn, what about the option of using e.g. pipes-binary for that? I'm still just at the beginning of the Pipes tutorial though 
05:52:39 <cocreature> as long as you don’t use pipes-parse or pipes-group pipes is fairly straight forward
05:53:04 <fr33domlover> I just don't want to reinvent the concept of pipes/conduit in my code :P
05:53:20 <fr33domlover> it this technique is relevant I want to just use it
05:53:44 <xa0> have constraint kinds been proposed for haskell 201y?
05:53:48 <fr33domlover> then I can have a pipe that e.g. packs bytes into SSH messages
05:54:00 <fr33domlover> the 'ssh' package already implements that
05:54:11 <fr33domlover> just with a Handle and not with pipes
05:54:41 <cocreature> pipes has toHandle and fromHandle
05:56:04 <fr33domlover> the git protocol begins with a negotiation step that is synchronous - you send a message and wait for a reply
05:56:20 <fr33domlover> so for that part I don't need a separate thread for async read/write
05:57:51 <fr33domlover> I need an efficient representation for a stream of bytes. If Chan Word8 is bad for that, maybe I need pipes/conduit here
05:58:39 <haskell274> under what circumstance isPrint returns false?
05:58:42 <fr33domlover> Handle/Socket work too but they are low level, piping them needs the kernel's mechanism (pipe syscall) and I want to use Haskell-land here
05:59:10 <fr33domlover> haskell274, see its source code? :)
05:59:30 <fr33domlover> haskell274, or see the Unicode data files
05:59:36 <fr33domlover> not all chars are printable
05:59:53 <haskell274> I don't know how to :(
06:00:02 <haskell274> I started haskell yesterday
06:00:10 <sm> Gurkenglas: still installing ?
06:00:19 <fr33domlover> > isPrint '\n'
06:00:21 <lambdabot>  False
06:00:24 <fr33domlover> haskell274, ^
06:00:50 <fr33domlover> haskell274, warn recommendation: learn with the Haskell wikibook :)
06:00:50 <Gurkenglas> sm, ya
06:00:54 <fr33domlover> was amazing for me
06:01:01 <fr33domlover> *warm
06:01:16 <camm1> Hey guys I'm using postgresql-simple for getting data from a DB, and I'm using QuasiQuotes for writing the SQL sentences. And, I'm getting an horrible error (ghc panic) when trying to compile a module with this sentence: queryAllAdmins = [sql| SELECT id, name FROM users WHERE role = 'Admin'|] Do you know why that could happen?
06:01:57 <fr33domlover> camm1, paste the error
06:01:59 <fr33domlover> @where paste
06:01:59 <lambdabot> Haskell pastebin: http://lpaste.net/
06:04:51 <lpaste> CAMM pasted “Error” at http://lpaste.net/158134
06:05:01 <camm1> http://lpaste.net/158134
06:05:54 <camm1> I found the way to solved, but I don't know why is happening.
06:06:16 <haskell274> thank you very much
06:12:24 <srpx> What is it called when I have a function that works like a state machine? Each time that function is called, it returns a new function with the new state. You can also read the current state.
06:13:02 <srpx> something like: `data Action = Set Int | Add Int | Read`. and `next :: Action -> Either Int ????`. I don't remember well what it was. I read it in a blog post.
06:13:20 <xa0> a state monad :p
06:14:21 <srpx> nah that's not it I guess
06:14:25 <srpx> nothing to do with monads
06:15:02 <xa0> combinators?
06:15:32 <srpx> I mean, it does the same, but under a different presentation, and that was what the post was all about. 
06:17:33 <xa0> how do you combine actions^
06:17:37 <xa0> *?
06:17:38 <fr33domlover> srpx, web-search for that blog post
06:18:00 <srpx> I'm trying!
06:18:13 <srpx> xa0: I don't remember, I don't think it could.
06:18:37 <xa0> so it's a free monad kind of thing?
06:18:45 <fr33domlover> web search for: haskell + works like StateT but is not a monad ;)
06:19:09 <srpx> `data StateMachine = StateMachine (Action -> Either Int StateMachine)` - something like that
06:19:14 <srpx> fr33domlover: :(
06:19:47 <fr33domlover> srpx, maybe related to continuations? functor? transformer? applicative? :P
06:20:21 <fr33domlover> arrow?
06:20:33 <fr33domlover> ST?
06:20:40 <xa0> arrow's a stretch...
06:20:59 <fr33domlover> xa0, just trying all the wild guesses :P
06:21:09 <xa0> lol
06:22:44 <kaloabo> Hello. Since today, when I type read "1" in GHCi I get an Exception: Prelude.read: no parse so I have to type read "1" :: Int. How can I get the old behaviour back?
06:22:50 <srpx> okay I get the point lol
06:23:18 <fr33domlover> kaloabo, which version?
06:23:34 <fr33domlover> of GHC / GHCi
06:23:40 <srpx> well, what I remember of the blog post is. it had some kind of tone you can have many ways to do state. it also was trying to propose a new technique. not sure if it had to do with corecursion, comonad. something fancy
06:23:55 <Narfinger> hiho, i have a question about how to do something in haskell: I want two different records VideoA, VideoB in a list of course I could use a type class but that still doesn't allow both types to be in a list
06:23:58 <kaloabo> fr33domlover, 7.10.3
06:24:03 <Narfinger> now i am wondering what the correct haskell way to do this is
06:24:30 <fr33domlover> kaloabo, what did you change? i mean, considering "since today"
06:24:33 <srpx> then it started by implementing a simple thing on which the state evolved, but you couldn't modify the state. then it changed that thing, so you can modify the state, like a counter or a calculator. then it made something much more complex I don't remember what
06:24:43 <srpx> if anyone has an idea what I'm talking about from that vague description please let me know lol
06:24:44 <ertes> hi there…  is there something like JuicyPixels for sound files?  a pure haskell sound loading library that can handle at least WAV files
06:24:55 <fr33domlover> Narfinger, Either a b
06:25:27 <Narfinger> i thought about either but that doesn't feel good either, what if i now add VideoA, VideoB and VideoC?
06:25:43 <ertes> Narfinger: make a type that has cases for each
06:25:54 <fr33domlover> yeah, what ertes said :)
06:26:12 <Narfinger> ok i can do that
06:27:03 <ertes> Narfinger: alternatively you can think of 'Either' as an infix type combinator (a `Either` b `Either` c), but that will get ugly quickly
06:27:05 <fr33domlover> ertes, such a library would be awesome! check if Hackage has some audio format implementations
06:27:08 <kaloabo> fr33domlover, I just wrote a letter in latex, then started up ghci. Really don't know what I could have changed.
06:27:29 <Narfinger> well at the moment i only have two, so it is fine
06:27:54 <fr33domlover> kaloabo, where does your GHC come from?
06:28:07 <fr33domlover> any change it got auto updated or your .ghci file changed?
06:28:31 <fr33domlover> kaloabo, also try 1 ::Integer in GHCi
06:28:37 <Narfinger> ok lets introduce a typeclass Video with function makeUrl i can then give a implementation of makeUrl for Either (Video VideoA) (Video VideoB) which just calls the correct makeUrl, right?
06:29:47 <fr33domlover> Narfinger, unlikely you need a typeclass for such simple local use, but generally yes, more-or-less you can
06:30:15 <fr33domlover> if your Video* types are local, you don't need the extra abstraction of an open world (i.e. typeclass)
06:30:24 <ertes> fr33domlover: none of them seem particularly well maintained, except hsndfile, which depends on a C library =/
06:30:40 <fr33domlover> ertes, new project added to TODO list... :P
06:30:50 <fr33domlover> long long TODO list it is....
06:30:50 <kaloabo> fr33domlover, I got the 64 bit version from www.haskell.org/platform/windows.html. 1 :: Integer returns 1
06:31:28 <Narfinger> i don't quite understand fr33domlover, otherwise I have to do the checking which Either it is and calling the correct function whenever I want to call makeUrl, right?
06:31:33 <fr33domlover> kaloabo, ah you use that operating system... then i dunno,could be a bug
06:32:05 <StrangeLoop> Hi, I have a data type defined as "data StrTree = Node [StrTree] | Leaf String", and a function f which does something to data of this type. I now have another function g which gets an StrTree and applies f to it. It works exactly the same whether it gets a Node or a Leaf. Is there any way to code it without separate implementations for Leaf and Node?
06:32:30 <StrangeLoop> I'd expect something along the lines of "g StrTree T = f T" should work, but no dice
06:32:38 <fr33domlover> Narfinger, you don't need to check every time, just write makeUrl :: Video -> URL
06:32:43 <ertes> fr33domlover: it's a lot of work though…  reading WAV files is complicated enough, but ideally you'd want to handle stuff like FLAC and OGG vorbis as well
06:32:57 <Narfinger> oh right that works
06:32:59 <Narfinger> thanks
06:33:33 <fr33domlover> ertes, iirc there's an ogg122 simple player that is in PD
06:33:44 <fr33domlover> maybe if we port to Haskell and Haskellize it...
06:33:56 <fr33domlover> (PD - public domain)
06:34:01 <ertes> StrangeLoop: you don't have to match on the individual cases:  g x = f x (which of course means g = f)
06:34:47 <ertes> fr33domlover: in other words: "go with hsndfile for now" =)
06:36:09 <StrangeLoop> ertes: If I understand you correctly then what you are suggesting does not work
06:36:52 <StrangeLoop> http://lpaste.net/158138
06:37:04 <ertes> StrangeLoop: example with Maybe:  f (Just x) = 5; f Nothing = 5
06:37:12 <ertes> StrangeLoop: can just write:  f x = 5
06:37:13 <fr33domlover> ertes, exactly :)
06:37:52 <ertes> StrangeLoop: pay attention to your case: capitalised things are never variables
06:38:01 <StrangeLoop> Ohhhh
06:38:15 <StrangeLoop> Yeah, that clear 'er right up :D
06:38:16 <StrangeLoop> Thanks
06:47:26 <ertes> hmm…  hsndfile doesn't support any interesting file formats either:  the most well supported container type is WAV, but FLAC is not well supported (only integer samples up to 24 bits)
06:47:48 <ertes> perhaps there is some value in writing a custom loader library in pure haskell
06:48:18 <ertes> but there are already enough unmaintained libraries =/
07:00:47 * hackagebot scanner 0.1 - Fast non-backtracking incremental combinator parsing for bytestrings  https://hackage.haskell.org/package/scanner-0.1 (YurasShumovich)
07:02:16 <ertes> curious…  i was just wondering whether a fast non-backtracking incremental combinator parsing library exists for bytestrings
07:06:06 <olpery> hey, is there such a thing as rightmost currying in haskell?
07:06:18 <ggVGc> what does that mean_
07:06:22 <ggVGc> you can flip functions
07:07:04 <olpery> ggVGc: been using a .js library that can curry both left-to-right and right-to-left. Currying by default in haskell is left-to-right.
07:07:11 <olpery> so you say i should "flip" ?
07:07:49 <Ferdirand> you want function application to be right-associative ?
07:08:39 <cocreature> you can also use sections if your function only has to arguments, e.g. (`minus` 1)
07:08:41 <olpery> aye
07:08:58 <ggVGc> olpery: so, if you have f x y z, and call it with f 10, you want that to be f x y 10?
07:09:01 <cocreature> well if it has more than two arguments but you only want to pass the second one
07:09:02 <ggVGc> eh, no
07:09:06 <ggVGc> f 10 yz
07:09:08 <ggVGc> ?
07:11:37 <Yuras> ertes: what is your use-case?
07:12:40 <ertes> Yuras: i'm considering writing my own sound loader library, and i'll probably begin with WAVE
07:13:00 <ertes> Yuras: however, i'll probably use pipes instead, because i can use the pipes-group feature
07:13:18 <olpery> "Partial application in Haskell involves passing less than the full number of arguments to a function that takes multiple arguments."  Doesn't this statement fly in the face of currying, which all Haskell functions are, which means every function thus only take one argument.
07:13:48 <olpery> Does it mean partial application occurs before currying?
07:13:56 <Yuras> ertes: I wonder whether cereal will be faster for WAVE
07:14:08 <ertes> olpery: ($) is right-associated
07:14:24 <ertes> f $ g $ h x = f (g (h x))
07:14:41 <olpery> $ is what?
07:14:49 <ertes> olpery: function application
07:14:55 <ertes> f $ x = f x
07:14:58 <olpery> k
07:15:12 <olpery> well, yes, and?
07:15:29 <olpery> currying still mean all functions take one argument only
07:15:29 <ertes> olpery: weren't you asking for right-associated function application?
07:15:40 <ertes> sure
07:15:46 <olpery> ertes: now i am talking about currying vs func app
07:16:13 <olpery> currying still mean all functions take one argument only. So how does partial application work in a system of functions taking only one arg.
07:16:42 <olpery> it must mean currying happens after partial application, yes, no, hum?
07:17:45 <geekosaur> currying enables convenient partial application
07:17:59 <Pessimist> why is it called currying? is it related to haskell curry?
07:18:03 <olpery> yes
07:18:07 <ertes> olpery: currying does not "happen"; it's not a process, but simply a convention:  if you write (\x y -> z), that's read as (\x -> \y -> z), i.e. a function that returns a function
07:18:16 <Pessimist> olpery, is that a response to me?
07:18:20 <olpery> yes
07:18:24 <Pessimist> Ok
07:18:40 <olpery> schonfinkling sounded bad
07:19:20 <ertes> there is acme-schoenfinkel, which gives you schön and unschön instead of curry and uncurry =)
07:19:27 <olpery> ertes: function of 1-arity returning a 1-arity function certainly happens.
07:19:30 <ertes> the names are very appropriate =)
07:19:58 <ertes> olpery: but the "currying" part is just the way your source code is read (not evaluated)
07:20:33 <ertes> in other languages you have to curry explicitly:  function(x) { return function(y) { return z; }}
07:20:44 <ertes> in haskell you have to uncurry explicitly:  \(x, y) -> z
07:20:52 <olpery> sigh
07:21:52 <ertes> the "function returning function" part is unrelated to currying
07:23:11 <olpery> ertes: well, no, not for the purpose of this discussion. let plus5 = plus 5 takes Integer->Integer->Integer to Integer->Integer
07:24:28 <olpery> "Currying is the process of transforming a function that takes multiple arguments into a function that takes just a single argument and returns another function if any arguments are still needed."  in haskell-wikis own words
07:24:54 <EvanR> :t curry
07:24:55 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:24:57 <ertes> i believe that refers to currying as in the function 'curry'
07:25:02 <olpery> so, again, in this system of 1-arity functions, how can partial application make sense. It does, if it happens before currying
07:25:14 <ertes> currying as a concept is really just right-associated (->), left associated application
07:25:34 <EvanR> haskell side steps having to have any actual partial application by only having 1-argument functions
07:25:40 <EvanR> partial is now just a metaphor
07:25:47 * hackagebot sdl2-compositor 1.2.0.4 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.2.0.4 (seppeljordan)
07:26:08 <olpery> EvanR: thank you! finally an answer i can relate to
07:26:55 <ertes> olpery: "partial application" in haskell does not really exist
07:26:56 <EvanR> note that if you have an "uncurried" function
07:27:01 <EvanR> (a,b,c,d) -> e
07:27:06 <EvanR> you cant partially apply it
07:27:13 <EvanR> not directly at least
07:27:16 <ertes> though you can do this:  partial f x = \y -> f (x, y)
07:27:23 <ertes> that's "partial application" concretely
07:27:50 <EvanR> other languages have support for that though
07:27:58 <EvanR> sometimes crappy support
07:28:15 <ertes> and haskell doesn't support it at all (although there is probably a lens for it) =)
07:29:03 <ertes> StoreT could be interpreted as partial application, too
07:47:31 <knupfer> Is it normal that ghc takes lots of time for compiling a 100loc lib with lots of typelits, newtypes and typeoperators?
07:47:41 <knupfer> 1000loc
07:48:00 <knupfer> it takes about 30 min. and hasn't got any TH
07:48:34 <ggVGc> god lenses are amazing
07:49:09 <ggVGc> I mean, it's a bit crap it took this long to have reasonable syntax for record updates but it's real nice
07:49:30 <ggVGc> finally I can map "assignment" over a list
07:49:43 <ggVGc> without writing a 100-character expression for it
07:51:26 <EvanR> ggVGc: while being sidetracked into idris, i noticed they have some new syntax for record updates, in the manual. might be nice to look at to idears
07:51:30 <EvanR> to get
07:52:40 <ggVGc> I think lenses pretty much solved it in the context of haskell
07:53:16 <ertes> lenses as we have them would probably not have been discovered, if GHC had introduced some half-arsed ad hoc syntax
07:53:33 <ggVGc> yep
07:53:48 <EvanR> we should expand that principle
07:53:55 <EvanR> the compiler should do nothing!
07:54:03 <ertes> that's why i'm glad we have haskell and not o'haskell =)
07:54:11 <ertes> (if you remember that project)
07:55:09 <ggVGc> I've been wanting to write somethign liek this for so long, (fmap $ offsetNote.octave.~x)
07:55:14 <ggVGc> glad I finally picked up lenses
07:55:30 <ggVGc> EvanR: you mean lisp?
07:55:40 <EvanR> i was thinking about lisp
07:55:40 <old_fashioned_ja> hi guys
07:55:51 <ertes> ggVGc: i believe there is even a traversal for fmap
07:55:54 <ertes> mapped or something
07:56:06 <knupfer> Huray, ghci let me in after 25 min
07:56:12 <ggVGc> yeah, I know there's more powerful stuff. But I just pciked lenses up a few hours ago :)
07:56:16 <ggVGc> and I jsut came back from a wedding
07:56:40 <ertes> ggVGc: mapped . offsetNote . octave .~ x
07:56:45 <ertes> something like that should work
07:57:04 <ggVGc> yep, cheers
07:57:17 <ggVGc> although.. I'm not sure that's better, readability-wise
07:57:17 <ertes> (not a big fan of the dot-without-spaces convention that lensy code seems to follow)
07:57:29 <ertes> ggVGc: personally i'd go with fmap
07:57:33 <ggVGc> I mostly dislike parentheses
07:57:50 <ertes> i don't, and i feel they are underappreciated =)
07:57:53 <ertes> especially in haskell
07:58:11 <ggVGc> I think I've started to lean towards your view
07:58:14 <black0range> Hey when doing a cabal package I get an error message lie this "cabal: /home/myname/Documents/workspace/Smutt/./Smutt/Util/Char.hs: invalid
07:58:15 <black0range> argument"
07:58:36 <black0range> why does it say that ?
07:59:24 <java_man> hey all
07:59:38 <ertes> black0range: please paste your *.cabal file on lpaste.net, and show us the cabal command that failed
08:00:09 <black0range> ertes: Well i'm trying to make it do a cabal file :/ 
08:00:24 <ertes> black0range: "do" as in "create"?
08:00:39 <black0range> ertes: correct
08:00:44 <ertes> black0range: using "cabal init"?
08:01:18 <black0range> ertes: yup
08:01:22 <ggVGc> EvanR: what are you using haskell for right now?
08:01:33 <EvanR> wouldnt you like to know
08:01:41 <ertes> black0range: does it ever ask you questions interactively, or does it fail before that?
08:01:53 <ggVGc> I was thinking today that I'm curious what people actually byild in haskell
08:02:22 <black0range> ertes: well it's when it's trying to guess dependencies
08:02:28 <java_man> ggVGc I'm working on some data science / scientific computing things
08:02:32 <xa0> ggVGc: low orbit tea brewer
08:03:02 <ggVGc> xa0: aren't most tea brewers low orbit?
08:03:06 <ggVGc> like, very low orbit
08:03:16 <java_man> damn stack + ghcjs still doesn't seem to work :(
08:03:27 <ggVGc> java_man: for personal stuff?
08:03:27 <xa0> once you get that low it's not really orbit :p
08:03:44 <EvanR> ground-assisted orbit
08:03:45 <java_man> ggVGc for work
08:03:49 <xa0> ahah
08:04:29 <java_man> ggVGc i'll be honest though it's kind of an uphill battle not to give into python
08:04:37 <ertes> black0range: does building other cabal packages work?  (just try to download any small package like 'Stream' from hackage, and use cabal to build it)
08:04:54 <ggVGc> java_man: for what reasons? lack of library support? Or just familiarity?
08:05:04 <ggVGc> or is python just better for scientific stuff?
08:05:19 <ggVGc> sounds unlikely to me, but I'm not a scientits
08:05:33 <ertes> black0range: you can probably just type `cabal install --one-shot Stream` and cabal will do everything for you
08:05:40 <java_man> ggVGc mostly library support. IMO haskell would be better but the ecosystem isn't there
08:06:16 <ertes> ggVGc: python as a language is a bad choice for computing, but it's today's perl with respect to libraries
08:06:30 <black0range> ertes: oh i just figured it out. Had put some comments in the top of some files. When i removed this it seems to work 
08:06:44 <ertes> ah, there you go =)
08:06:55 <java_man> datavis is really limited, so i'm building my own web-based visualization tooling to use javascript to fill-in the gaps.
08:07:00 <ggVGc> ertes: sure, I know, that's why I asked about libraries. I used python extensively for years for that reason
08:07:02 <black0range> ertes: Thanks :)
08:07:03 <ggVGc> not so much nowadays
08:07:06 <ggVGc> but that's more because my work changed
08:07:09 <java_man> another example, i was going to use repa for some linear algebra stuff
08:07:30 <java_man> and it doesn't have a way to print matrices so that rows are on separate lines
08:07:44 <java_man> easy enough to implement, but it feels silly writing my own matrix pretty printer in 2016
08:07:45 <xczc> Hello
08:08:23 <java_man> why hello xczc
08:08:30 <ertes> java_man: it's not an easy job to do it *nicely* either (with alignment, etc.), so if you have an implementation of that, consider making it a library =)
08:08:45 <ertes> java_man: that's exactly what haskell needs:  people building *practically useful* libraries
08:08:59 <ertes> i.e. repa-show-matrix and not left-pad =)
08:09:41 <cocreature> are you saying is-positive is not a useful library?!
08:09:49 <Xnuk> left-pad♥
08:10:16 <java_man> ertes well for now i just have like a two-liner that's good enough for my own use
08:10:38 <java_man> what else, i fall back on C FFI a lot to fill-in the compute-heavy gaps in the ecosystem
08:11:27 <ertes> wow…  i'm thinking about the engineering of such a library, and whether i want it or not, finger trees pop up in my head to solve it nicely…
08:11:27 <xa0> what sort of computations are so inefficient in haskell that you have to resort to C?
08:11:39 <java_man> so yeah, stealing javascript's ecoystem for datavis & interaction, stealing C/C++ legacy for computation, with haskell in between has been them.
08:12:00 <java_man> xa0 lot's of scientific computing is really large integrations to solve inverse problems when you get down to it.
08:12:31 <ertes> xa0: it's not so much resorting to C as a language to get efficiency, but resorting to code that has already been written in C
08:12:37 <java_man> well let me preface that, some of this stuff i could probably do in pure haskell if i was a better haskell programmer
08:12:47 <xa0> oh i see...
08:12:50 <xa0> fair enough
08:12:55 <java_man> also, there's just a lot of legacy C code  out there
08:13:07 <java_man> for statistics, machine learning, numerics, & simulation
08:13:53 <ertes> xa0: with GHC haskell, you get very efficient code (nowadays), usually on par with C with a few percept loss, but in some cases even a few percept win
08:14:07 <java_man> ertes one thing that's been kind of bugging me though
08:14:11 <xa0> that's what i was thinking
08:14:16 <java_man> ertes can you load -O2 code into ghci?
08:14:29 <knupfer> ertes thats perhaps a bit too optimistic
08:14:43 <java_man> knupfer i agree
08:14:48 <bennofs> java_man: you can load compiled modules with GHCi, I believe
08:14:53 <ertes> java_man: if it's compiled library code, GHCi does that…  i don't think you can do it for interpreted code though (if you find a way, please tell me)
08:14:54 <xa0> no i think it's realistic
08:15:10 <java_man> coming from a data science background, i appreciate repl development. but then if i can't load optimized code...
08:15:23 <bennofs> java_man: the code that you run at the prompt will not be compiled, but if you do someFunction someArgs and someFunction is a function loaded from a compiled module, ghci will use the compiled code for someFunction iirc
08:15:26 <java_man> bennofs i will have to try. i never really tested to see exactly what ghci is doing when it loads
08:15:29 <java_man> with :r
08:15:49 <java_man> bennofs how do you know if it's loading from stack build or if it's loading interpreted code?
08:16:12 <ertes> knupfer, java_man: my statement is backed by experience, not conjecture…  but i admit, it takes some time until you get an intuition for GHC-haskell's efficiency
08:16:49 <java_man> ertes there's a lot of claims about it, but i haven't seen strong evidence.
08:16:54 <knupfer> ertes: by the way, do you come from a city famous for kartoffelsalat?
08:17:03 <java_man> for example, there's an 800 body simulation with repa on youtube
08:17:17 <java_man> then if you look around C++ demos it's like million body simulations
08:17:28 <ertes> knupfer, java_man: http://lpaste.net/101980, for some evidence
08:17:54 <java_man> ertes that's blank at least for me
08:18:19 <bennofs> java_man: I'm not sure how it behaves exactly, but there's -fobject-code and -fbyte-code flags for ghci: https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/ghci-obj.html
08:18:20 <ertes> same algorithm both in optimised haskell and optimised C, haskell wins…  and this is pretty low-level stuff: bit manipulations in a huge array
08:18:23 <java_man> when i've looked up optimization tutorials
08:18:40 <java_man> they often start with "okay step 1, learn to read core"
08:18:42 <ertes> java_man: try this: <http://lpaste.net/101980> (your IRC client may have read the comma as part of the URL)
08:18:59 <ertes> java_man: i've never learned to read core to be honest =)
08:19:07 <java_man> also i'm less interested in the toy examples
08:19:16 <java_man> there's toy one-liners that make python look super efficient
08:19:31 <ertes> this may be a toy example, but it does some heavy computation
08:19:47 <bennofs> the problem with haskell for perf is this: if you use haskell, you like to write high-level code. Now, for it to be fast, you have to make sure that all the abstractions that you use get optimized away. If they don't, that's where reading core can be useful to figure out why it's not getting optimized away
08:20:11 <bennofs> but of course, you can also write imperative code in haskell using mutable vectors etc and it'll usually be about as fast as C
08:20:16 <Peaker> ertes: why would Haskell code be faster than C? What can GHC do that you cannot express at least as efficiently with C?
08:20:29 <knupfer> eres: interesting, but using functions beginning with unsafe seems a bit scary
08:20:30 <java_man> sure ... i'll admit i have a lot to learn about memory layouts & unboxed data structures ...
08:20:50 <knupfer> and perhaps not that typical for haskell
08:21:05 <xa0> Peaker: code transformations that ghc does that gcc deosn't?
08:21:12 <java_man> i get that it's doable, but the people that seem to pull it off are like 10 year veterans
08:21:15 <bennofs> knupfer: it's just the same that C++ code does
08:21:34 <java_man> for most people, something like julia is probably a much better value proposition
08:21:35 <ertes> knupfer: i would have liked to keep the bounds checking, but GCC optimised it away, so i ended up using the unsafe variants, so the haskell variant doesn't waste time checking bounds either
08:21:35 <knupfer> bennofs: I consider c++ scary
08:21:52 <java_man> i say this as someone that doesn't want julia to take over.
08:21:54 <xa0> lol
08:22:23 <bennofs> The nice thing with haskell is that you can sometimes write really high-level code that gets optimized to be as fast as low-level code (for example, you can pass around vectors that get optimized away entirely! how do you do that in C++?)
08:22:23 <ertes> Peaker: no idea, but i'm a strong believer of the notion that GHC will produce better allocation code than you can do in C…  from what you would typically put on the stack to the very large stuff that survives generations
08:22:42 <ertes> Peaker: and i strongly believe that's the main reason why the haskell version is faster in this case
08:22:43 <java_man> bennofs the operative word is "sometimes"
08:22:53 <fr33domlover> does ExceptT from 'transformers' really throw anything?
08:23:00 <java_man> bennofs programmers like to have control over whether their programs achieve their objectives or not
08:23:07 <ertes> one of the least appreciated killer features of GHC is its garbage-collector
08:23:08 <fr33domlover> or is it just an abstraction
08:23:12 <bennofs> java_man: right, if you really require predictable maximum performance then haskell might not be the best choice
08:23:43 <bennofs> java_man: but if you only require generally good perf, haskell works (i.e. if you don't need to hit the theoretically maximum best perf)
08:23:47 <java_man> but ultimately, if i'm starting a project where i'm interested in performance... i need to have confidence that i can pull it off
08:24:19 <java_man> bennofs i know, it's fine for a lot of business logic-y stuff. but i want to use it for more than that
08:24:37 <bennofs> java_man: it's usually fine if you have a small core hotspot as well
08:24:37 <ertes> java_man: you can, just maybe not today…  as noted, it took me a while to become proficient in writing very fast haskell code
08:24:39 <java_man> ideally i want to use it for machine learning, scientific computing, game development..
08:24:41 <knupfer> java_man: no problem, you can always switch the two or three most sensitive functions to C via FFI
08:24:51 <java_man> fun sexy stuff
08:24:59 <java_man> knupfer that's what i'm doing now
08:25:05 <java_man> getting to know the C FFI
08:25:38 <java_man> as an aside, i wish there was a cleaner C++ FFI story. the recent C++11/14 standards make a huge difference
08:25:39 <knupfer> I recommend trying it in haskell first, and only if it isn't sufficient fast...
08:26:09 <java_man> knupfer i'm getting pretty familiar with the gnu science library and binding it...
08:26:55 <ertes> note:  a round-trip to C isn't free…  you shouldn't implement simple formulas in C
08:27:12 <bennofs> it's ~300ns or something, no?
08:27:12 <knupfer> java_man: you'll have to teach ghc which of this stuff will be pure (i.e. functional) with unsafePerformIO and friends...
08:27:18 <java_man> ertes doing a lot of unsafe
08:28:00 <java_man> that's my problem with like hmatrix bindings, the marshalling and safe FFI is too slow for compute-intensive work
08:28:19 <knupfer> java_man: as always talking about performance, use criterion and compare different implementations
08:28:33 <java_man> ertes but this is one problem with the "move the hotspot into C FFI". besides the so-so workflow, it doesn't quite solve it
08:28:34 <ertes> yeah, criterion is a great tool
08:28:54 <java_man> i haven't had a chance to try it much
08:29:10 <knupfer> java_man: you should absolutely do that first
08:29:19 <ertes> java_man: ultimately the best solution is to write it in haskell…  then GHC can make sense of it and integrate it much better into its use site
08:29:30 <java_man> knupfer well for my recent project it was obvious the haskell implementation was way too slow
08:29:35 <knupfer> it's the best to asses performance differences, especially if you are concerned about ffi costs
08:29:52 <java_man> actually the "haskell" version wasn't haskell because it used hmatrix-gsl which does FFI too
08:30:01 <knupfer> you can use it as well to perf the C stuff
08:30:16 <java_man> but the hmatrix bindings were definitely too slow
08:30:27 <daakr> what does it mean when my executable exits with "my_exec: <<loop>>" ?
08:30:51 <bennofs> daakr: that you have a value in your program whose computation depends upon itself
08:30:54 <ertes> hmatrix-gsl is a different story entirely…  IMO it's the worst library binding in-context i've ever seen
08:31:00 <knupfer> never used hmatrix, but perhaps sprinkling with unsafePerformIO helps
08:31:08 <bennofs> daakr: like let x = x + 1 --> x depends on x itself
08:31:10 <daakr> is there a straightforward way to trace back which one?
08:31:33 <ertes> you want to use hmatrix-gsl, because you want speed…  then hmatrix-gsl tells you:  "gimme a list, and i'll call this incredibly fast C library and give you a list back"
08:31:35 <java_man> ertes yeah it's kind of a necessity because there isn't any alternative. however i ended up foregoing it and writing my own FFI... that's where i ended up
08:31:39 <ertes> and i say: "are you kidding me?!"
08:31:45 <ertes> "i already have this here array!"
08:31:53 <bennofs> daakr: I think you can do it if you enable profiling and then run with +RTS -xc
08:31:54 <java_man> ertes totally! WTF!!
08:32:24 <java_man> lists??? at least the rest of hmatrix uses Data.Vector
08:32:41 <java_man> so yeah i wrote my own unsafe bindings
08:33:01 <java_man> if there were pure-haskell ODE integrators i'd give them a try.
08:33:20 <bennofs> java_man: btw, reading core is not that hard. it's basically just haskell with less sugar
08:33:30 <fr33domlover> does ExceptT from 'transformers' really throw anything? or is it more like "EitherT"
08:33:53 <bennofs> (try -dsuppress-all first if dumping core with -ddump-simpl -ddump-to-file, it suppresses all the annoying stuff like coercions etc that just clutter the output if you're not a GHC dev)
08:34:09 <java_man> bennofs i 'spose, but i'm taking enough of a productivity hit trying to do things in hasell. i can only do so much learning investment at a time before management starts to notice..
08:34:18 <bennofs> :)
08:35:20 <daakr> bennofs: thanks. seems like i found the location already. now i just need to find the reason... :)
08:35:41 <java_man> also it must break up the development flow somewhat. like i said, i'm kind of used to repl driven fast prototyping
08:36:43 <daakr> ah, found the reason. okay, thanks, bennofs :)
08:36:50 <java_man> is there a ghci equivalent to -Wall when reloading?
08:37:17 <bennofs> java_man: that should definitely work with haskell as well. start ghci with -fobject-code, and :r a file in which you define expressions (those will be compiled) that you then use from non-compiled ghci expressions 
08:37:25 <bennofs> java_man: yes, :set -Wall
08:37:39 <java_man> huh
08:37:55 <java_man> guess there are no warnings for this code.. that's a surprise.
08:37:59 <ertes> java_man: i actually do repl-driven fast prototyping using emacs and haskell-interactive-mode
08:38:09 <ertes> java_man: it's pretty much my haskell IDE
08:38:18 <knupfer> why is Data.Map.findWithDefault not called lookupWithDefault?
08:38:26 <java_man> ertes yeah that's me. spacemacs + repl for everything
08:38:31 <ertes> knupfer: history
08:38:33 <java_man> almsot never do stack build
08:38:39 <java_man> until i'm almost done with something
08:39:19 <knupfer> ertes: ok
08:40:12 <ertes> java_man: i've also written a few convenience functions to add imports and LANGUAGE pragmas more quickly: http://hub.darcs.net/esz/config/browse/emacs/ertes-haskell.el
08:40:13 <knupfer> Has syb performance increased over time?  Specifically, there was a paper in 2013 about supercompiling syb with hermit...
08:40:50 <java_man> ertes cool i wrote a few elisp hacks to throw code between the editor and repl too
08:41:00 <java_man> ertes for example evaluating line-by-line
08:41:14 <ertes> java_man: sounds nice…  do you have it online somewhere?
08:41:30 <java_man> or dumping main contents into the repl to setup monadic state (that's been kindof an annoyance for data analysis stuff)
08:42:12 <java_man> ertes not at the moment. don't have a github account
08:42:24 <java_man> ertes but it's small, happy to just copy-paste into lpaste for you
08:42:33 <bennofs> java_man: you might like http://hackage.haskell.org/package/foreign-store
08:42:33 <ertes> that would be nice, yeah
08:42:48 <bennofs> java_man: allows you to store data across ghci reloads
08:43:05 <java_man> ertes ok one min
08:43:53 <ertes> i could never figure out elisp enough to write those things…  my elisp code is mostly guess-until-it-works =)
08:44:53 <java_man> okay haskell convenience elisp functions http://lpaste.net/158140
08:45:01 <java_man> my elisp code is pretty hacky too
08:45:32 <ertes> thanks a lot…  i guess, elisp was really designed to be hacked rather than programmed
08:45:42 <java_man> the dump main thing in particular is a total hack for my own purposes.
08:45:54 <java_man> the eval line things have been really useful for me though
08:46:11 <java_man> when i want to step through repl style ala python or R
08:46:23 <java_man> for scripty-ish code
08:47:16 <ertes> java_man: may i use your code?  (consider everything i forget to license explicitly as apache2-licensed)
08:48:04 <java_man> ertes yes feel free
08:48:21 <ertes> thanks =)
08:49:02 <java_man> ertes actually i wish there was a cleaned up version that went into haskell-mode.
08:50:16 <ertes> not sure how much of it i'll end up using, as i tend to create an "experiment" executable that depends on a default-off flag "examples"
08:50:46 <ertes> my skeleton cabal file: http://hub.darcs.net/esz/skeleton/browse/skeleton.cabal
08:53:42 <ggVGc> is it somehow possible to combine lenses like this? https://gist.github.com/e2c4f6fba62c02ea4f2a9493860924a6
08:54:33 <java_man> whee spock is so nice to use..
08:55:09 <bennofs> ggVGc: you can do newObj2 = obj & _2 %~ ( (_1.~"foo").(_2.~"bar") )
08:55:44 <java_man> people using haskell for webdev -  do you use blaze-html or just editing plain html
08:56:10 <Tekkkz> Hello. How to write a script that makes following: I have a file , formatted like "a43f 0992 9f23 7a21" (hexdump if you are interested), and wanna change it to "\xa4\x3f\x09\x92...", how to do that?
08:56:19 <ggVGc> bennofs: nice, thanks
08:56:23 <ggVGc> but wow.. lens operators are so awkward
08:56:47 <java_man> i haven't used lens much beyond wreq
08:58:42 <ertes> java_man: blaze-html is the lowest common denominator…  most combinator libraries compile to it…  but users of the snap framework lean more toward raw HTML templates with XML-syntactic placeholders and control structures (called heist)
08:59:23 <java_man> ertes: what combinator libraries compile to blaze-html?
08:59:35 <knupfer> java_man: lucid, shakespear
08:59:50 <java_man> knupfer oh i didn't realize they were built on top of blaze-html
09:00:01 <java_man> but blaze-html is pretty high level already
09:00:05 <knupfer> well, shakespeare (hamlet) doesn't use combinators
09:00:17 <java_man> i don't see a compelling reason to stick a layer of template haskell on top of it... is there?
09:00:22 <ertes> java_man: also hsp/hsx, the primary templating language of happstack
09:00:23 <knupfer> no
09:00:42 <knupfer> java_man: it looks closer to html, so people don't get scared
09:01:00 <knupfer> lucid is just a concistency layer on top of blaze-html
09:01:03 <maerwald> hsp has very weird types
09:01:03 <ertes> java_man: those layers usually expose some integration into the framework, because blaze-html is a pure library that doesn't give you access for example to the framework's URL renderer
09:01:07 <java_man> knupfer lol why the hell did they do it then? oh come on if you're trying yesod... you can't possibly find blaze-html intimidating
09:01:32 <java_man> i can kind of see it's more consistent with julius and whateer the css one was though
09:01:34 <ertes> java_man: background: many haskell web frameworks try to abstract away string paths into an actual ADT
09:02:14 <knupfer> ertes: you can have type-safe urls as well with blaze
09:02:34 <ertes> knupfer: sure, but there is no integration
09:02:38 <knupfer> java_man: hamlet doesn't convince me either
09:02:52 <knupfer> ertes: at least a blog post :)
09:03:13 <java_man> the biggest annoyance i have with blaze-html (and any other in-haskell option) is that i have to reload/recompile whereas with raw html i can edit and referesh the browser.
09:03:15 <ertes> for some reason people think that you should be able to render *within* the template expression =)
09:03:56 <ertes> java_man: heist may be what you're looking for then…  it's more like the traditional run-time-interpreted template languages
09:03:56 <knupfer> java_man: that's considered a feature
09:04:14 <EvanR> my favorite integrations are the ones that are easily de-integrated
09:04:19 <knupfer> it gives some static checks, something typical for haskell
09:04:25 <java_man> knupfer maybe so, but for the content creation aspects it's kind of annoying.
09:04:33 <ertes> java_man: just with a more sensible syntax (XML) that doesn't make your editor go crazy
09:05:02 <java_man> my web apps are not so big incorrect URLs haven't been an issue yet.
09:05:43 <knupfer> java_man: not only incorrect urls, invalid html, missing parens etc. are catched by the compiler
09:05:55 <ertes> java_man: i consider ADTed paths more a convenience than a correctness feature
09:06:04 <jpfuentes2> does anyone here have much experience with conduit ?
09:06:04 <ertes> java_man: especially if your application is modular and you cascade them
09:06:19 <java_man> knupfer yeah fair enough. well i'm giving blaze-html + spock a try
09:06:32 <ertes> java_man: pattern-matching and guarding on an ADT is simply easier than dealing with path components =)
09:06:37 <knupfer> java_man: have as well a look at lucid and servant
09:06:57 <java_man> is there something like blaze-html for javascript? or is that pretty much just ghcjs/purescript :P
09:07:05 <ertes> java_man: jmacro
09:07:13 <knupfer> fay
09:07:27 <knupfer> julius :P
09:07:44 <java_man> knupfer i've played with servant and it's nice. but for now the type magic is overkill for the rapid iteration one-off stuff i'm doing
09:07:48 <ertes> jmacro is again the kind of lowest-common-denominator package =)
09:07:55 <EvanR> yes URLs and their pieces are really NOT very nice as strings, no matter how good you are at regex
09:07:58 <java_man> knupfer isn't fay lumbering towards death?
09:08:11 <knupfer> java_man: really?
09:08:48 <java_man> knupfer julius is another "i'm not sure i like this much better than plain ..." but the last time i tried it i was less experienced in both haskell and web dev so maybe i should give it another look
09:09:13 <black0range> Hey, I recently asked for a problem where the cabal init wouldn't finnish when I got some error message such as "cabal: /home/myName/Documents/workspace/smutt/src/Smutt/Util/Hex/String.hs" 
09:09:20 <java_man> knupfer the consensus seems to be it's not haskell enough and for not-haskell purescript is better, for is-haskell community seems to be converging  on ghcjs
09:09:29 <ertes> julius is mostly jmacro in disguise
09:09:48 <knupfer> julius is mostly plain text
09:09:48 <black0range> I though I fixed it but i didn't can anyone tell me whats wrong? here's the file in question: http://lpaste.net/158141
09:09:58 <java_man> although for gods sake ghcjs has some usability annoyances between the setup and last i heard the generated js code is unwieldy beyond toy projects
09:10:40 <knupfer> ghcjs is the holy grail, but the output is quite huge
09:10:56 <java_man> also isn't the performance questionable?
09:11:07 <ertesx> (disconnected) julius is mostly jmacro in disguise
09:11:40 <java_man> seems like like it's fated to other unwieldy compile-to-js solutions where the runtime bloat is incompatable with peoples' web experience expectations
09:11:57 <maerwald> purescript at least claims the output is human readable
09:12:20 <java_man> (for reference see all the "turn your java desktop app into a webapp" abortions)
09:12:47 <EvanR> human readable compiler output for web developers ?
09:13:09 <ertesx> i've never particularly cared how well readable my assembly code is
09:13:13 <maerwald> EvanR: see http://www.purescript.org/
09:13:14 <EvanR> do they want to see the v8 debugger too?
09:13:16 <java_man> maerwald EvanR yeah that's one of the selling points of purescript
09:13:23 <java_man> + miniscule runtime
09:13:37 <EvanR> (i agree a simpler implementation would be nice)
09:13:45 <java_man> purescript is still a non-starter for me due to psci performance deteriorating with imports
09:14:03 <ertesx> knupfer: oh, i just remembered your question…  sorry:  i don't know if kartoffelsalat comes from here =)
09:14:14 <java_man> i found that each repl eval somehow checks the import directories for changes, which is insane
09:14:31 <java_man> so for a moderate sized project 2+2 ends up taking like 7-10 seconds.
09:14:44 <knupfer> ertesx: I think I've seen you giving a conference in Stuttgart
09:15:11 <ertesx> knupfer: was it on password security?
09:15:26 <knupfer> ertesx: yeah, in the Stadtbibliothe
09:15:28 <knupfer> +k
09:15:33 <ertesx> yeah, that's me
09:15:41 <knupfer> cool, I live there
09:15:43 <java_man> when they fix that with psci i'll get back to it. the purescript-flare demos look hot
09:15:54 <black0range> Anyone know anything about that cabal init problem? :( 
09:16:39 <maerwald> knupfer: you live in a library? xD
09:16:52 <EvanR> genius
09:16:54 <knupfer> maerwald: that's true
09:21:54 <ertesx> knupfer: i do cryptography workshops there every first and third friday of the month, it's called "codebreakers"…  yesterday we started writing a genetic algorithm for breaking substitution ciphers – in haskell of course, as i suck in other languages =)
09:21:56 <knupfer> I actually wasn't there, but I made me think in learning netwire
09:22:28 <knupfer> oh, that's frequent
09:22:54 <ertesx> don't learn netwire…  i'm letting it die…  it will be replaced by another library in the coming months
09:23:13 <ertesx> until then i recommend reactive-banana
09:24:18 <knupfer> ertesx: why?  I was always searching an excuse to learn arrows :)
09:24:49 <knupfer> and hxt gave me only headaches and slow performance
09:24:56 <ertesx> knupfer: the new one is AFRP again…  netwire has become an engineering nightmare, difficult to maintain and even more difficult to extend
09:25:02 <ertesx> it needs to die
09:25:26 <EvanR> are you the netwire guy?
09:25:30 <ertesx> hxt has no inherent reason to use arrows at all…  it's a monadic library
09:25:39 <ertesx> i don't know why it uses arrows
09:25:43 <ertesx> EvanR: yeah
09:25:55 <java_man> isn't reflex the hotness now?
09:25:55 <EvanR> you must have changed nicks i remember a different nick
09:26:04 <ertesx> EvanR: mm_freak
09:26:10 <EvanR> zonked
09:26:15 <knupfer> ertesx: I think the author wanted to experiment with arrows...
09:26:28 <knupfer> but hxt explodes on 500mb xmls
09:26:38 <ertesx> never liked that one, and i disappeared from IRC for almost two years…  figured i could just use my real nickname =)
09:27:12 * EvanR looks at the quantum leap accelerator in the corner
09:27:14 <EvanR> never touch the thing
09:27:33 <ertesx> knupfer: if you want to learn arrows, the best way is to implement one yourself
09:28:29 <ertesx> knupfer: a great example of a non-trivial (as in non-monadic) arrow is this one:  data State s a = State { usesPut :: Bool, runState :: s -> (s, a) }
09:28:42 <knupfer> ertes: i played a lot with the syntax, i parsed gnucash with hxt, but i haven't quite understood the destinction between arrows and monads
09:28:44 <weissi> hey there, I'm wondering what the most performant way of changining exactly one byte in a bytestring, referenced by it's index
09:28:53 <ertesx> knupfer: implement Functor and Applicative, then try to implement Monad and see why you can't do it
09:29:07 <weissi> in other words, looking for changeAtIndex :: ByteString -> Int -> Word8 -> ByteString
09:29:08 <black0range> I hate to be the annoying guy, has anyone ever had a cabal init error where it says "cabal: [filepath] invalid argument"? I can't find any referencec to it anywhere
09:29:09 <ertesx> knupfer: 'usesPut' should be true for actions that use 'put'
09:29:42 <ertesx> weissi: there is no constant-time way to do it…  you need either a data structure (like ropes or finger trees) or a mutable array of bytes
09:30:02 <ertesx> weissi: the former keeps your code pure and functional
09:30:12 <weissi> ertesx, oh I know that there's no constant time way to do that because at the very least I need to copy the byte string
09:31:28 <java_man> question about julius - can i write es6 code in it? or is it tied to a particular version of javascript?
09:31:34 <ggVGc> how can I write this in another way to not get bitten by the fact that records are partial? https://gist.github.com/aac1a18ef712eac7805946c44f0686a8
09:32:36 <ertesx> weissi: ropes and finger trees (i like to use "finger tree ropes") allow you to get away without copying…  you're just splitting the bytestring
09:33:07 <knupfer> ggVGc: avoid the records
09:33:36 <EvanR> ggVGc: yeah sum records really dont make sense
09:33:37 <weissi> ertesx, but a bytestring can't be split, can it? It's not a list
09:33:51 <EvanR> records are a product type
09:33:57 <knupfer> ggVGc: why don't you use Maybe ?
09:34:13 <ertesx> weissi: "splitting" is not actually splitting the string in memory…  you're simply creating new references with different pointers and lengths
09:34:14 <ggVGc> knupfer: because I need to have a lot more states
09:34:28 <ertesx> weissi: that's allowed, because ByteString is immutable
09:34:42 <maerwald> ggVGc: I write wrapper "records" for those kind of things with Maybe
09:35:05 <EvanR> ggVGc: when you have a sum type and operations that dont make sense on all cases, then you have dynamically typed programming ;)
09:35:14 <EvanR> theres another way to do it
09:35:21 <weissi> ertesx, as far as I unterstand, ByteString holds the memory as plain memory (aka char *). So it could share bits but I don't see how the API offers that at all
09:35:37 <ertesx> :t B.splitAt
09:35:38 <lambdabot>     Not in scope: ‘B.splitAt’
09:35:38 <lambdabot>     Perhaps you meant one of these:
09:35:38 <lambdabot>       ‘BS.splitAt’ (imported from Data.ByteString),
09:35:44 <ertesx> :t BS.splitAt
09:35:45 <lambdabot> Int -> BSC.ByteString -> (BSC.ByteString, BSC.ByteString)
09:35:49 <knupfer> ggVGc: you can simply write for every state a helperfunction ala maybeModeState
09:35:50 <weissi> ertesx, Ah, I see!
09:35:51 * hackagebot interruptible 0.1.1.0 - Monad transformers that can be run and resumed later, conserving their context.  https://hackage.haskell.org/package/interruptible-0.1.1.0 (marcosdumay)
09:36:05 <ertesx> weissi: and there are all the other usual functions like 'take', 'dropWhile', etc.
09:36:10 <weissi> ertesx, thanks very much
09:36:14 <ertesx> none of those copy, unless they change the actual bytes
09:36:16 <EvanR> using Maybes isnt necessary going to fix it either
09:36:16 <knupfer> ggVGc: so the ability to fail is clearly stated in the type
09:36:21 <weissi> ertesx, that is indeed in constant time
09:36:24 <ggVGc> EvanR: so, I've got a very modal application, and a "Mode" is currently represented by a {update::Input->Model->Model, render::Model->[OutEvents]} essentially. But now I want to keep some state for some of the modes, that's not the state of the Model. But I somehow want my outside caller to be able to store a generic "AppModeState". How do I do this?
09:36:46 <EvanR> when you use an operation that doesnt make sense on a value and get Nothing, sometimes you have nothing you can do next
09:36:54 <EvanR> the program gets stuck
09:37:13 <maerwald> highly hypothetical
09:37:19 <weissi> ertesx, however, to reassemble it to a (strict) ByteString, I'll need to copy it anyway because it doesn't support non contiguous buffers, right?
09:37:24 <ertesx> weissi: note that the complexity annotations are all about time, not memory…  only few functions in the bytestring API actually need copying:  map, filter, etc.
09:37:34 <EvanR> maerwald: sometimes it works though
09:37:57 <ertesx> weissi: depends from what you assemble and whether you actually need the whole string in memory as a single piece at run-time
09:38:03 <EvanR> ggVGc: so, for state that varies between modes, you can hide it in a closure, thats one way
09:38:11 <EvanR> state whose type varies
09:38:29 <ertesx> weissi: for example bytestring has a Builder API that can be useful for assembling strings without needing too much extra memory
09:38:42 <weissi> ertesx, I need a ByteString of same length with just one byte changed.
09:38:48 <ggVGc> EvanR: wouldn't that mean mutability?
09:38:52 <EvanR> no
09:38:58 <ertesx> weissi: and for I/O you would typically either send the lazy ByteString directly (if you have one), or you would send from a Builder directly, which never assembles the whole string in memory
09:38:59 <maerwald> just because haskell lacks a proper totality checker doesn't mean I'll write only total functions in my internal API. Either check the constructors explicitly, or wrap them safely in case you don't
09:39:02 <weissi> ertesx, and as far as I understand, I'd need to switch to lazy ByteStrings to allow that
09:39:16 <weissi> ertesx, I'll need to look the bytestrings up in a HashSet :\
09:39:21 <ertesx> weissi: yeah, the lazy API can do that
09:39:40 <EvanR> maerwald: wrapping in a Maybe doesnt always fix your totality problem, is what i was saying
09:39:52 <maerwald> again: highly hypothetical
09:39:53 <ertesx> weissi: if you convert a strict bytestring to a lazy one and then change a single byte, that's actually pretty cheap
09:39:57 <EvanR> sometimes non-total is a good way to find bugs
09:40:03 <ertesx> weissi: the trouble starts when you need to do that again and again
09:40:06 <EvanR> you can put error "impossible"
09:40:16 <jpfuentes2> does anyone here have much experience writing network servers? i'm assessing whether or not i should use something like conduit or low-level server/client mgmt using STM and Chan
09:40:51 * hackagebot xdcc 1.0.0 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.0.0 (JanGerlinger)
09:41:01 <ertesx> weissi: however, if you go back to strict again, that's when the copying happens, so once you're lazy, try to stay lazy
09:41:27 <EvanR> ggVGc: right so it sounds like you want the "oop" pattern where your caller has an interface object that hides state of unknown type, and to change modes you get a new version of this object
09:41:42 <EvanR> the objects all have the same type but hide things that dont
09:41:50 <ertesx> jpfuentes2: those two seem orthogonal, and you can combine them
09:41:57 <ggVGc> yeah, basically. is this a dumb idea? what's a better suggestion in that case?
09:42:03 <weissi> ertesx, what I need is all the one byte changes of a word and get the ones that the dictionary contains. For example if the dictionary is ["car", "cap", "cat"], I want to find exactly these three given the original word "caf" for example. My idea was to generate all the permutations (lazily) and then check in the dictionary which ones actually exist.
09:42:05 <EvanR> thats what i was suggesting
09:42:19 <ggVGc> I just want to be able to easily define modes for the program and have the outer application logic not care about which mode is running
09:42:29 <EvanR> thats a good way to do it then
09:42:35 <ggVGc> atm I have the mode state in the application model, which is a hack
09:42:52 <EvanR> that wont work if the mode state changes
09:42:55 <ggVGc> EvanR: I think I get what you mean
09:42:59 <ggVGc> cool I'll give it a spin
09:43:05 <EvanR> and using a giant sum type has the problem you discovered
09:43:17 <ggVGc> yep, it's also non-elegant in other ways
09:43:58 <ertesx> weissi: like: which dictionary words can be transformed into the target word by changing a single character?
09:44:20 <EvanR> you can also experiment with rank N polymorphism to juggle things whose type you dont want to know about
09:44:22 <weissi> ertesx, yes
09:44:29 <ertesx> weissi: do you actually need to *do* the change to figure out whether a word qualifies?
09:45:01 <weissi> ertesx, for the lookup in the dictionary (currently HashSet ByteString)
09:45:26 <ggVGc> EvanR: hm, using closures for the state creates another problem for me. I currently do this, in order to have states be identifiable and comparable, https://gist.github.com/6f20768d7542584077d67aabd65c07c9
09:45:35 <jpfuentes2> ertesx: i sure can. conduit has networking abstractions already. i've been toying with them. there are plenty of examples of basic pipelines from server <--> client. i think i'd like to have a coherent structure to my program though. if they were "combined" it would simply me lifting the low-level mgmt into conduit's types
09:45:37 <ggVGc> but that is based on the modes being immutable objects
09:45:43 <ggVGc> global immutable objects I mean
09:45:56 * hackagebot xdcc 1.0.1 - A wget-like utility for retrieving files from XDCC bots on  IRC  https://hackage.haskell.org/package/xdcc-1.0.1 (JanGerlinger)
09:45:57 <ggVGc> so if I go back to having actual mode instances being passed around, I have the issue of identifying them
09:46:30 <ertesx> weissi: so you're generating all the single-character changes of a word, and then you're querying the HashSet?
09:46:38 <weissi> ertesx, yes
09:47:02 <ertesx> weissi: i would use bytestring-trie in this case
09:47:34 <ertesx> that one doesn't require you to give it full strings for queries…  you can get subsets of certain prefixes
09:48:01 <ertesx> weissi: but a quick-n-dirty solution would be to simply use lazy bytestrings everywhere
09:48:11 <weissi> ertesx, yes I see what you mean :)
09:48:25 <EvanR> ggVGc: no... global wont work
09:48:27 <ertesx> oh, and reconsider whether ByteString is the correct type…  Text or Vector Char are more appropriate for text
09:48:50 <EvanR> ggVGc: for the closure trick to work, you have to construct the objects at some point by passing in the state
09:48:59 <ertesx> the latter uses more memory, but gives you constant-time lookups and splits again (Text doesn't, because it needs decoding to find the splitting point)
09:49:10 <EvanR> so whats global is the constructor
09:49:11 <ggVGc> EvanR: right, that's what I meant. BUt I need to be able to identify and compare modes also..
09:49:18 <ggVGc> so how do I get that?
09:49:21 <ggVGc> without this approach
09:49:27 <EvanR> you can identify modes by including an identifier in the mode?
09:49:59 <weissi> ertesx, thanks very much for your help. I think I'll implement strict ByteString, lazy ByteString and might consider the bytestring-trie package and see what performorms how well.
09:49:59 <ggVGc> EvanR: yeah, I was gonna do that, but it seems non-ideal and error prone
09:50:11 <ggVGc> since it requires me to construct the modes with the correct identifiers
09:50:17 <EvanR> well you sure cant identify it by the type
09:50:22 <ggVGc> right
09:50:23 <EvanR> (unless you use typable)
09:50:36 <ertesx> weissi: again, reconsider your choice of ByteString…  you will get weird behaviour for non-english languages
09:50:39 <EvanR> what do you want to use the identification for?
09:51:30 <weissi> ertesx, I know it sounds really weird. But I definitely do only need it for lower case a to z. And then ByteString is the best choice I believe, no?
09:51:34 <ggVGc> EvanR: I have at least one place where I render in the UI which mode is active 
09:51:36 * hackagebot bindings-wlc 0.1.0.1 - Bindings against the wlc library  https://hackage.haskell.org/package/bindings-wlc-0.1.0.1 (ashleyis)
09:51:56 <ertesx> weissi: if you're absolutely sure that's all you'll ever need, then yeah, ByteString is fine
09:52:04 <EvanR> ggVGc: including a constant string for that in the interface shouldnt be that bad
09:52:18 <weissi> ertesx, yes, I am, in this very case.
09:52:25 <EvanR> if its a more elaborate rendering operation you can include the rendering operation in the interface
09:52:48 <weissi> ertesx, also I will have potentially huge dictionaries (read from a file) so I can't waste much space and Text certainly does
09:53:05 <weissi> and indexing is also a problem with Text
09:53:17 <EvanR> HashMap Text ?
09:53:17 <ggVGc> EvanR: the "rendering" is in the form of "If modeA is active, light up button 1, if modeB is active light up button 5" etc.
09:53:24 <ertesx> weissi: unfortunately i know no on-disk trie-structured databases
09:53:35 <ertesx> that would be useful in such a case
09:53:54 <EvanR> ggVGc: so the simplest way would be "which button should light up" in the interface
09:54:05 <ertesx> EvanR: HashMap/HashSet still need to keep the string in memory, alongside the hash
09:54:11 <ggVGc> EvanR: but lighting up a button based on which mode is only one view of a Mode
09:54:14 <EvanR> but it would be more modular to split it into two questions "which mode" then map that to "which button" with something else
09:54:14 <weissi> ertesx, huge was maybe the wrong word. Word list will still fit in memory
09:54:21 <ggVGc> it doesn't have anything to do with the mode in my opinion
09:54:41 <EvanR> sure, then the second option
09:54:52 <ggVGc> EvanR: right, so the "which mode" is why I made the modes be looked up from a function based on an identifier, rather than pass around an actual mode object
09:54:55 <EvanR> the mapping of mode to button is yet another place you could "de-integrate" and change your mind
09:54:58 <ggVGc> but if I want a closure, I can't do this
09:55:17 <ggVGc> attaching an identifier to each mode works of course as you said
09:55:33 <EvanR> i was suggest to yes lookit up with a function based on the identifier
09:55:34 <ggVGc> but I'm not completely happy with that, since it forces me to assign the identifier correctly manually
09:55:45 <ertesx> weissi: HashSet comes with memory complexity of its own…  typically i calculate 10*numItems*averageItemSize bytes for small items
09:55:48 <EvanR> uhm.. what would be not manual?
09:56:04 <EvanR> reflection?
09:56:06 <ertesx> weissi: dictionary words are "small" in that regard…  but you can safe a few bytes by using ShortByteString
09:56:11 <ertesx> weissi: Data.ByteString.Short
09:56:15 <EvanR> slippery slope
09:56:26 <ertesx> (a few bytes per entry)
09:56:54 <EvanR> ggVGc: if youre thinking of deciding on what to do based on what type something is, remember that types dont exist at runtime. all decisions must be made based on values
09:58:00 <EvanR> so a value representing "which mode" makes sense
09:58:10 <java_man> with blaze-html how do you add tag attributes that aren't built-in functions?
09:59:55 <weissi> ertesx, on thanks!
10:00:02 <ertesx> weissi: ultimately though the trie will be the greatest memory-saver, because it shares prefixes: if you save "bandit" and "banjo", the trie will actually store "ban", "dit" and "jo"
10:00:25 <ggVGc> EvanR: yeah, fair. I guess what I want is some TH magic where I can say "makeEquatable Foo", where it would add a unique identifier and define an Eq instance in terms of it
10:00:42 <weissi> ertesx, yes, I'll probably make an implementation after the prototype
10:00:46 <EvanR> hrm you really are going to use == for this?
10:00:46 <weissi> ertesx, many thanks!
10:00:56 <ggVGc> EvanR: if I model the state of the modes in a closure, how would I get this state out if I wanted to serialize it?
10:00:59 <EvanR> not pattern matching?
10:01:26 <EvanR> you can include a serialize method in the interface
10:01:35 <EvanR> thats the easy part
10:01:41 <EvanR> but deserialization
10:01:53 <ertesx> weissi: you're welcome
10:02:35 <Cale> Well, there's no way around it, when you deserialize, you need a certain amount of omniscience regarding what things could have been serialized in the first place. :)
10:02:52 <EvanR> im thinking the "type safe" deserialize is basically what juicy-pixels does
10:02:55 <ggVGc> EvanR: true Eq isn't what I would want. But I geuss what I am looking for is to take a value and know what "type of type" it is..
10:03:24 <EvanR> ggVGc: right, earlier "identifier" was another type not a string
10:03:31 <Cale> ggVGc: ...kind?
10:03:32 <EvanR> a tag for each of your modes
10:03:51 <Cale> ggVGc: Values always belong to a type whose kind is *
10:03:57 <ggVGc> yeah, I know
10:04:05 <ggVGc> but I don't think this is at kind-level?
10:04:10 <EvanR> no this isnt kinds
10:04:12 <Cale> I wouldn't expect that either :)
10:04:15 <ggVGc> this is a tagging of instances of a type
10:04:25 <ggVGc> but I would like them to be automatically tagged I guess
10:04:37 <ggVGc> anyway, that's just a nitpick
10:04:38 <EvanR> you can leverage Typeable if you want
10:04:46 <EvanR> and use the Typerep type
10:04:49 <ggVGc> yeah, I've been avoiding it on purpose
10:04:57 <ggVGc> because it seems like a rabbit hole
10:05:05 <EvanR> if it specifically for what youre using it for... then ... use it ;)
10:05:10 <Cale> Well, this is kind of exactly the problem that Typeable is for -- runtime type information.
10:05:11 <EvanR> though i probably wouldnt
10:05:31 <Cale> If you don't want to do something by hand, it's pretty much what you're looking for.
10:05:31 <ggVGc> Cale: yeah, I am realising that now from this conversation
10:05:38 <ggVGc> thanks
10:06:03 <Cale> ggVGc: It's important to realise that, Typeable aside, there is no runtime type information present -- compiling removes all of it.
10:06:05 <EvanR> backpeddaling to what you are using it for, choosing which button to light up, another way is to include that as an operation in the interface
10:06:17 <EvanR> but you want to separate that out
10:06:21 <ggVGc> EvanR: maybe I'm going about the whole design in a bad way? how would you model different execution modes of a program?
10:06:34 <EvanR> like this
10:06:46 <EvanR> make sure the mode is 1 type
10:06:55 <EvanR> and the modes are hidden implementations
10:07:14 <EvanR> then the driver only sees 1 type
10:07:26 <EvanR> exactly what it needs to see
10:07:43 <ggVGc> yep, okay
10:08:09 <ggVGc> but I kind of would like to be able to serialize/deserialize it easily too, since I have that functionality currently
10:08:19 <ggVGc> but deserializing seems like a bit of a hassle
10:08:23 <ggVGc> I'll check that package you mentioned
10:08:45 <EvanR> juicypixels includes a bunch of extra types for making sure you do runtime checks to find out the pixel format
10:08:53 <EvanR> when you read in data
10:09:08 <EvanR> you can also do it with less code and less type safety
10:10:20 <EvanR> serialize with 2 pieces of data, the tag and the raw data
10:10:33 <EvanR> read in the tag and use that to choose the deserializer 
10:10:48 <EvanR> then feed the raw data to the chosen deserializer
10:11:01 <EvanR> each deserializer returns the mode (same type)
10:11:01 <ggVGc> yeah, that seems reasonable
10:11:03 <ggVGc> thanks
10:11:14 <EvanR> internally it constructs different types
10:11:21 <EvanR> and crashes if theres a problem
10:14:14 <Tekkkz> I have a "IO [[String]]" ... how to »concat« it to "IO [String]" ?
10:14:26 <ggVGc> speaking of serializing, for now I'm doing this because I'm lazy and want to use Show/Read https://gist.github.com/d86391ff04d6c47be6229ace6f8d111b
10:14:30 <ggVGc> is it reasonable?
10:14:47 <Cale> Tekkkz: fmap concat
10:14:48 <ertesx> Tekkkz: you can map functions like 'concat' over the result of an IO action using fmap
10:15:29 <EvanR> ggVGc: hrm... you know i think theres a way to derive binary instances
10:15:40 <EvanR> but if Show / Read works then great
10:15:58 <ggVGc> EvanR: I meant that I make a new serialization type because of the zippers
10:16:03 <ggVGc> it was the only way I could think of
10:16:11 <ggVGc> withour writing my own serializer
10:16:30 <EvanR> youre trying to serialize a zipper?
10:16:40 <ggVGc> only the data of it, which is what I'm doing
10:16:44 <ggVGc> by making it a list
10:16:52 <ggVGc> I don't care about the state of the zipper
10:16:57 <ggVGc> i.e the cursor
10:17:07 <EvanR> hmm then a custom Binary instance might make more sense
10:17:19 <EvanR> that traverses the zipper
10:17:57 <EvanR> alternatively you can serialize a mapping from your zipper to a list of tuples or something
10:18:09 <EvanR> or json
10:18:26 <EvanR> a new type almost exactly the same is annoying ;)
10:18:30 <Tekkkz> Cale and ertesx okay but I misexplained something, i have a list [["a","b","c"],["d","e","f"]] and wanna get ["abc","def"] .. how?
10:18:32 <ggVGc> yeah, that's why I ask
10:18:41 <EvanR> maybe you want to factor out the data part
10:18:56 <EvanR> and make your zipper structure more generic
10:18:57 <ertesx> Tekkkz: then you 'map' the 'concat' function over the elements of the list
10:19:05 <ertesx> Tekkkz: fmap (map concat)
10:19:47 <monochrom> > map concat [["a","b","c"],["d","e","f"]]
10:19:48 <lambdabot>  ["abc","def"]
10:19:59 <Tekkkz> ertesx: thanks works fine
10:20:05 <monochrom> if it's trapped in IO, add one more fmap
10:20:07 <EvanR> ggVGc: example i have this in a project, factored it out of my more complicated data structure http://lpaste.net/158144
10:20:19 <EvanR> youre is probably different but thats how simple it could be
10:20:23 <Tekkkz> yeah monochrom thanks
10:22:36 <EvanR> if you have Zipper a, then you can convert to [a] and serialize that
10:22:48 <EvanR> (without writing a list serializer... its already done)
10:23:51 <ggVGc> EvanR: which is what I'm doing, but yeah, the crap thing is how I have to duplicate everything into an almost identical structure where Zippers are turned into list and vice versa
10:24:12 <ggVGc> I'm not really sure I understood your point about factoring out the zippers
10:24:17 <ggVGc> trying to see what you mean
10:24:34 <EvanR> its like in C if you have the next pointer in the struct itself
10:24:49 <EvanR> or if you use a linked list library with a void* at each node to your struct
10:25:12 <EvanR> you do the first thing in C because linked list libraries suck
10:25:24 <EvanR> you do the second thing in haskell because you dont have to rewrite list support
10:25:45 <EvanR> (or zipper support)
10:27:07 <EvanR> about going through a [a] to do something, thats normal in haskell and we are saved by lazy evaluation
10:27:33 <EvanR> and when weather permits, list fusion
10:28:06 <ggVGc> EvanR: so, essentially something like this? https://gist.github.com/9ea9c3bb46b2281370636ed70f153992
10:29:01 <ggVGc> sorry, this, https://gist.github.com/c5b5fb302bac4848b209cced713f6aca
10:29:03 <Arch-TK> There are linked list libraries for C which don't use void * which work relatively well, but usually they are implemented with 50 layers of #define
10:29:08 <ggVGc> without the zipper in the seqmodel type
10:29:27 <PrincessLuna> huh
10:30:06 <PrincessLuna> if in GHCi you say 'x <- something :: forall a. IO a'
10:30:16 <PrincessLuna> then x :: GHC.Prim.Any
10:30:36 <ertesx> Arch-TK: how can linked lists work well in a language that lacks polymorphism?  in particular, how can it *not* use void*?
10:30:53 <Arch-TK> with lots of macros
10:31:07 <ertesx> i see
10:31:13 <Arch-TK> have a look at the linux kernel linked list implementation as an example
10:31:13 <EvanR> ggVGc: eh... if its a giant nest that includes zippers as leaves... and you want to serialize all of it, then i retreat back to my custom Binary instance
10:31:22 <PrincessLuna> ertesx, https://github.com/mniip/sml/blob/master/storage/slist.h
10:31:30 <EvanR> you can still use factored zippers in the middle though 
10:31:55 <ertesx> ouch…
10:32:28 <monochrom> ertesx: but void* is polymorphism  <duck>
10:32:30 <ertesx> basically C++ templates reinvented =)
10:32:36 <EvanR> i like how the giant comment is the "C++ version for clarity"
10:32:52 <monochrom> did you know: the first C++ implementation was a macro system over C
10:32:53 <ertesx> yeah
10:33:11 <EvanR> monochrom: i feel like im at the aquarium now
10:33:15 <ggVGc> monochrom: taht seems highly likely, so yes I believe that
10:33:26 <Asuran> why you left c++ for haskell?
10:33:38 <monochrom> the command line was "cfront file.cc"
10:33:56 <ggVGc> C++ left me, because no one paid me to write it anymore
10:34:06 <ggVGc> and I'm fairly happy about that development
10:34:19 <EvanR> .cxx is supposed to be ++ fallen over? nevermind
10:34:25 <mmachenry> ggVGc: So you went to Haskell, where everyone is hiring :)
10:35:16 <ggVGc> mmachenry: well, C++ left me about 8 years ago in the beginning of my game development career. I am now far away from being paid for making games, and programming is fairly boring, so haskell is the only thing that makes it bearable implementing personal projects
10:35:24 <Asuran> what is written in haskell? gui?
10:35:49 <ggVGc> EvanR: a custom binary instance for all of SeqModel, or for the zippers?
10:35:52 <ertesx> Asuran: i remember doing folds in C++ by abusing the (at that point non-standard) GCC extension for lexically scoped functions to do folds
10:36:01 <Arch-TK> programming is fairly boring?
10:36:01 <EvanR> ggVGc: the whole thing if thats what youre trying to serialize
10:36:02 <Tekkkz> Again a question: how to writeFile an IO String?
10:36:02 <ertesx> it wasn't pretty, so i switched to haskell
10:36:33 <monochrom> Tekkkz: xxx >>= writeFile "abc.txt".  alternatively you could also use do-notation
10:36:34 <cocreature> Tekkkz: do notation or >>=
10:36:38 * hackagebot conduit-extra 1.1.13.1 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.13.1 (MichaelSnoyman)
10:36:38 <ertesx> Tekkkz: in a do-block, if 'action' is of type 'IO String' and you say 'str <- action', then 'str' is of type 'String'
10:36:45 <ggVGc> EvanR: because a custom binary instance for all of SeqModel seems like it would be basically the same thing as what I'm doing now. This was just my quick and dirty way of serializing everything, hence using show and read and default instances, but since zipper didn't have oneI did this hack
10:36:57 <ggVGc> rather, same amount of work
10:37:00 <ggVGc> or more work actually
10:37:05 <monochrom> Tekkkz: you should read my http://www.vex.net/~trebla/haskell/IO.xhtml
10:37:06 <EvanR> copy pasta a large data type is quick and dirty?
10:37:22 <EvanR> at least the Binary instance will be the right thing after the smoke clears
10:37:30 <Tekkkz> monochrom: agreed!
10:37:51 <ggVGc> EvanR: yeah, fair
10:38:28 <Cale> Asuran: All kinds of stuff. At the company I'm working for right now, we've been using Haskell for web applications. We write both the backend and the frontend in Haskell -- the backend is compiled to native code, while the frontend is compiled to Javascript using GHCJS and runs in your web browser.
10:38:36 <cocreature> I like how for half of the questions asked here, monochrom has a page he can link to that answers them
10:38:51 <ggVGc> what about the other half?
10:39:04 <EvanR> he has a page for half of thos
10:39:06 <EvanR> and so on
10:39:20 <Asuran> Cale, im intresting in an real world small example of haskell syntax, like a simple fcgi app or bot?
10:39:56 <EvanR> poor fastcgi library :(
10:40:19 <EvanR> lost to the tectonics of ghc ;_;
10:40:48 <ertesx> Asuran: you will find plenty of that in the haskellwiki, but you may be more interested in a tutorial for any of the larger haskell web frameworks…  they typically throw a lot of code at you which demonstrate the basic concepts in context
10:40:56 <xa0> Ghc is so problematic >_>
10:41:14 <Cale> EvanR: what happened?
10:41:21 <cocreature> xa0: you just need to put unsafeCoerce in all the places it complains about
10:41:35 <xa0> Hahah
10:41:40 <ggVGc> monochrom: I love how you avoided mentioning monads in the section "THe types of IO actions"
10:41:43 <ertesx> Cale: did you ever have to justify the size of the client-side code?
10:41:45 <ggVGc> nice one
10:42:09 <EvanR> hmm fastcgi seems to be still in existence
10:42:15 * EvanR checks websockets
10:42:25 <ggVGc> EvanR: so is Cobol... so we might have fcgi for a while more
10:42:31 <Cale> ertesx: It actually doesn't end up being very different from what you end up with if you use lots of fancy JS libraries.
10:42:48 <ertesx> EvanR: it is, because apache is still in existence, and you don't want applications running alongside the httpd code in many cases
10:43:11 <ertesx> and nginx doesn't even provide that option, so you *need* fastcgi or something equivalent
10:43:39 <EvanR> the haskell libraries for both, as i recall a few years ago, didnt build on then-current ghc
10:43:49 <EvanR> it looks like there was work done on them though since then
10:44:03 <ertesx> Cale: good point…  are there any non-haskell libraries that you *do* use?  for example modernizr is useful and difficult to reimplement
10:44:26 <EvanR> ggVGc: fcgi is the bomb
10:44:40 <EvanR> especially with haskells concurrency
10:44:45 <Cale> We've used the Google Maps API a bunch...
10:45:01 <Cale> There are a handful of other things.
10:45:29 <Cale> At present, we haven't been too concerned with detecting JS features beyond what ghcjs-dom already does in that regard.
10:45:44 * ggVGc rewrites google maps in haskell
10:46:14 <EvanR> the best js detection technique is to assume not IE6 or 7 or 8... and then wait for someone with that browser to complain
10:46:38 <Cale> yeah, I think probably things don't work too far back anyway
10:46:55 <ertesx> Cale: actually that's quite convincing…  what are your techniques to reduce the code size?  i passed it through closure-compiler, but it was still hundreds of kilobytes for basically "hello world"
10:47:55 <Cale> ertesx: Note that most of what you're seeing there is a constant term. You'll always have that same hundreds of kilobytes, and it'll only grow at a slower rate than that would suggest.
10:48:37 <ertesx> Cale: i see, but i'd still be interested if you have any extra techniques
10:48:47 <EvanR> 100k is 1/10 of a meg
10:49:12 <EvanR> i know people are ok with downloading 30M webpages these days but
10:49:13 <Cale> ertesx: After that, you can compress things with zopfli
10:49:19 <robertmc_> hello, can cabal be passed an argument, path to build from (ie where main.hs is) ? 
10:49:51 <Cale> EvanR: Not only that, but people watch HD videos on YouTube
10:50:09 <Cale> Those are a bit more than a few hundred k :)
10:50:13 <knupfer> What is preferable, having three modules with types (all in all 2000loc of types) and orphan instances and standaloneinstances or one huge module with types?
10:50:17 <ertesx> robertmc_: where main.hs is derived from the *.cabal file, so you can't choose that one
10:50:19 <EvanR> 100k is a sizable chunk of a floppy disk ;)
10:51:02 <robertmc_> ertesx: that's what I mean, pass a path to the dir where .cabal exists.
10:51:21 <ertesx> knupfer: GHC tends to get really slow for large modules, so with that in mind i suggest the orphan instances…  or you try to arrange your types into a sensible dependency tree and design your module tree after that
10:51:21 <dcoutts_> robertmc_: you can cabal install ./some/path/
10:52:55 <robertmc_> dcoutts_: thank you just learned something new
10:53:48 <dcoutts_> robertmc_: see cabal install --help  you can specify a local path, multiple paths, local tarballs, http tarballs, plus package names
10:54:40 <knupfer> ertesx: I've got now Types.hs, Parse.hs and Print.hs.  Seems sensible, but all three consist only of types, so they could be put in the first...
10:55:53 <barryburd> I’m working on the Monad Challenges. I’ve posted my work on the Random challenge at http://burd.org/set1new.hs. At the top I import Control.Monad, but when I try to compile, I get “Not in scope: type constructor or class ‘Monad’” Why am I getting that error?
10:56:34 <ertesx> knupfer: you could call them Types.Core, Types.Parse and Types.Print instead
10:56:47 <ertesx> and the Types module could reexport those three
10:57:06 <ertesx> alternatively you look for patterns and try to combine some of the types into more abstract ones
10:58:23 <greg`> how do people feel about earley
10:58:45 <greg`> is it the new way to do parsing?
10:59:45 <dcoutts_> greg`: doesn't sound very new, 1968?
11:02:39 <JuanDaugherty> most of the parsing theory reached its final state c. 1972
11:02:41 <greg`> https://hackage.haskell.org/package/Earley
11:02:49 <JuanDaugherty> with aho and ullmans two vol work
11:02:58 <JuanDaugherty> this is reflected in modern texts
11:03:22 <greg`> i meant is this defacto library for parsers?
11:05:02 <dcoutts_> greg`: no, I'd never heard of it, so I don't think it could be described as the de facto standard (except perhaps in some niches)
11:05:11 <JuanDaugherty> earley is a speciality not usually considered to have same generality as like ll lr
11:05:35 <JuanDaugherty> but it is venerable
11:05:38 <dcoutts_> greg`: are you looking for a recommendation? What parsing problem have you got?
11:08:46 <greg`> i dont have a parsing problem only i heard that the parsec parser families suffer from backtracking bugs
11:09:37 <greg`> https://hackage.haskell.org/package/Earley
11:09:46 <greg`> http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
11:10:42 <dcoutts_> greg`: I think it's a bit unfair to call it a bug, but certainly the use of try in parsec is a wart. There are other combinator libs that don't need it.
11:10:43 <monochrom> the parsec families do not suffer from backtracking bugs.
11:11:06 <monochrom> and ezyang's is saying how to use "try" correctly, not saying that the library has a bug
11:11:48 <monochrom> so now I charge you to go to the place where you really heard "parsec suffers from backtracking bugs", and tell them: "I heard that it is not true"
11:12:22 <monochrom> hearsay is valueless
11:14:25 <monochrom> well, unless you're a news reporter trying to sell an article
11:16:06 <seanirby> hello haskellers.  do any of you use haskell with org babel in emacs?
11:16:34 <seanirby> i'm having trouble using guard pipes in an org-babel code block
11:17:05 * hackagebot bindings-wlc 0.1.0.2 - Bindings against the wlc library  https://hackage.haskell.org/package/bindings-wlc-0.1.0.2 (ashleyis)
11:26:57 <cubuspl42> what's the preferred way to solve matrix equations in haskell?
11:26:59 <cubuspl42> AX = B
11:27:05 * hackagebot bindings-wlc 0.1.0.3 - Bindings against the wlc library  https://hackage.haskell.org/package/bindings-wlc-0.1.0.3 (ashleyis)
11:28:14 <cubuspl42> bindings-wlc will not help
11:28:18 <cubuspl42> but thanks, hackagebot 
11:29:44 <monochrom> no, hackagebot is not answering questions. it is reporting recent uploads to hackage, and only triggered by such uploads.
11:31:31 <schell> cubuspl42: i use linear
11:31:59 <schell> but i’ve heard people also use hmatrix
11:32:27 <cocreature> great now we have two bindings to wlc on hackage. I guess that’s my fault for not keeping my bindings up2date, but it would be nice if I could have simply passed my bindings over instead of duplicating everything
11:32:42 <cubuspl42> monochrom: i wasn't quite serious
11:33:34 <cubuspl42> schell: thanks =)
11:35:25 <monochrom> haha ok
11:40:06 <ggVGc> EvanR: woud it make sense to define a local instance of Show for Zipper in this one module, that just does show . toList?
11:40:12 <ggVGc> and imilar for read
11:42:47 <EvanR> you cant have local instances
11:43:37 <EvanR> but having a Show / Read for your zipper which just looks like fromList [1,2,3,4] makes sense, as long as your zipper isnt infinite
11:43:53 <ggVGc> ehh, I've been stupid. apparently there is a show instance for zipper?
11:43:57 <EvanR> ... and youre trying to lose the pointer
11:44:00 <ggVGc> it might have been added since I first wrot that code
11:44:38 <ggVGc> ohh.. there's no read instance..
11:45:26 <ggVGc> EvanR: so, what about defining a newtype over Zipper and implementing show and read for that?
11:46:19 <EvanR> whats wrong with the original instance
11:47:23 <ggVGc> EvanR: that it serializes in a way which requires more work to read than just read . Zipper.fromList
11:47:44 <ggVGc> eh, other way around
11:48:54 <EvanR> then go for it... but speak of doing things which require more work, perhaps your need for a special serializer is caused by the app data structure in the first place
11:49:15 <EvanR> perhaps you are doing this to avoid serializing stuff you think shouldnt be saved, in which case maybe that stuff shouldnt be in the structure to begin with
11:49:46 <EvanR> back to my "make a database state and everything is built around that" thesis
11:52:08 <ggVGc> EvanR: well, yes, but the issue is that Zipper captures two things that are useful to me in usage, but only one of those(the underlying data) is useful to serialize
11:53:41 <EvanR> haskell coding sometimes feels like a steepest descent toward the nicest simplest way ;) each step is a refactoring
11:54:21 <EvanR> perhaps you could serialize the cursor anyway, and choose later to reset everything on boot
11:54:57 <ggVGc> this seems relevant, https://www.schoolofhaskell.com/user/psygnisfive/from-zipper-to-lens
11:55:10 <EvanR> else the zipper might be too integrated and you want something that points at the existing database in some way
11:55:27 <EvanR> and that thing doesnt count as "part of the state"
11:55:27 <ggVGc> EvanR: yeah but if I want to serialize the cursor, I still have to have serializing and deserializing instances for Zipper, which ListZipper doesn't supply
11:55:30 <ggVGc> not read at least
11:55:56 <ggVGc> guess I can write that
11:56:06 <ggVGc> but it seems awkward since I didn't write the Show instance
11:56:39 <EvanR> its not that awkward if you consider Show is not for serialization
11:56:45 <EvanR> its for debugging
11:57:25 <ggVGc> works fine for serialization though!
11:57:27 <EvanR> i mean, if they didnt write a Read 
11:57:28 <ggVGc> :)
11:57:36 <ggVGc> yeah, fair
11:58:18 * EvanR throws yet another wrench in "also you wouldnt be dealing with this if your application state was in acid-state"
11:59:55 <EvanR> .oO( does acid-state work in the browser )
12:00:50 <Entroacceptor> oh, that's still a thing, and is working?
12:01:10 <EvanR> yes im using it
12:13:52 <knupfer> How can I inspect and modify typelevel strings on the typelevel?
12:14:45 <knupfer> f (Proxy :: "ab") === Proxy :: "a" for example
12:14:49 <pharaun> i think (at the time) my main con with acid-state was that it loaded it all into memory
12:16:04 <knupfer> like head and concat on the typelevel
12:19:30 <EvanR> pharaun: right so for a database that is expected to grow into the gigs that wont work
12:21:07 <EvanR> a GUI editor though
12:21:36 <EvanR> whose values are not gigs 
12:21:50 <darkroom> Hello! So I am writing a chess engine and I have my search function on another thread. How do I communicate from one thread to another the newest best move. If I try to use MVars I get the first element put in. This is because MVars are sorta FIFO. I need a FILO conccurenty method.
12:22:17 <johnw> you could always have an MVar over a Set, or something of that sort
12:22:29 <EvanR> dont you want to request that the thread stop and report its best move so far
12:24:57 <pharaun> EvanR: fair :)
12:24:58 <EvanR> oh. youre kind of already doing that... so use a TVar (Maybe Move) which is overwritten each time, or cleared when a move is used
12:27:30 <darkroom> EvanR: How is that different from what I am doing now?
12:27:45 * hackagebot uniform-io 1.2.0.0 - Uniform IO over files, network, anything.  https://hackage.haskell.org/package/uniform-io-1.2.0.0 (marcosdumay)
12:28:10 <EvanR> i dont know what youre doing now
12:30:15 <darkroom> EvanR: please take a look here: http://lpaste.net/158192 sorry for my scruby code. I am new to concurrency
12:31:07 <EvanR> the issue you have is that your producer is just doing putMVar
12:31:35 <EvanR> so if nobody took the move, youll get stuck 
12:31:55 <EvanR> you can do what i said with MVars too, just not like that
12:32:14 <darkroom> can you give me a rought idea how to do it?
12:32:26 <albeit> If I have a datatype Foo = FooAB | FooBC, is it possible to automatically derive a Read instance such that "AB" = FooAB and "BC" = FooBC?
12:32:51 <EvanR> its actually more complicated with MVars
12:33:10 <EvanR> ill give you a paste with the overview using TVars
12:33:19 <darkroom> Thanks so much
12:33:30 <nshepperd>  /url 1
12:33:35 <nshepperd> uuugh
12:34:42 <Iceland_jack> albeit: you /can/ have GHC derive it automatically, you'd create a new data type that derives a Read instance and reuse that
12:35:48 <albeit> Iceland_jack: A new data type that wraps Foo? Not quite sure what you mean...
12:35:49 <Iceland_jack> ghci> data Test = AB | BC deriving (Read, Enum)
12:35:49 <Iceland_jack> ghci> data Foo = FooAB | FooBC deriving (Show, Enum)
12:35:49 <Iceland_jack> ghci> (toEnum @Foo . fromEnum . read @Test) "AB"
12:35:49 <Iceland_jack> FooAB
12:36:00 <Iceland_jack> that's one way
12:36:23 <EvanR> darkroom: http://lpaste.net/158194
12:36:51 <darkroom> EvanR: thanks :)
12:37:09 <albeit> Ah... the reason I have FooBC instead of BC is that BC may be used elsewhere, so I had to sort of namespace it. And if I make data Test then the enum's won't line up for other datatypes.
12:37:31 <EvanR> the producer never stops, and the consumer will always get a move (eventually)
12:38:11 <EvanR> the producer always outputs a move, and the consumer stops until a move is available
12:38:29 <Iceland_jack> albeit: I would use the default Read instance and write non-read functions to do what you want
12:38:38 <nshepperd> O_O is 'toEnum @Foo' an actual syntax?
12:38:44 <Iceland_jack> In GHC 8 it is
12:38:51 <nshepperd> weeew
12:38:53 <albeit> Iceland_jack: Okay, thanks!
12:38:54 <Gurkenglas> (m <- desparately $ MaybeT $ readTVar tv -- EvanR (except that retry changes readTVars contents))
12:38:55 <Iceland_jack> TypeApplications
12:39:04 <Gurkenglas> *desperately
12:39:40 <EvanR> huh?
12:39:57 <Iceland_jack> albeit: If you want to write your own instance, set :set -ddump-deriv in ghci and you'll get the compiler generated code to base it on
12:40:01 <EvanR> retry better not change any TVars contents
12:40:18 <Gurkenglas> But then mm would stay Nothing, right?
12:40:30 <EvanR> thats the idea
12:40:47 <Iceland_jack>     instance Read Foo where
12:40:47 <Iceland_jack>       readPrec = parens (choose [("AB", return FooAB), ("BC", return FooBC)]) 
12:40:55 <Gurkenglas> But then you would loop infinitely through failing to get the next move, right?
12:41:02 <EvanR> no
12:41:21 <EvanR> the first time you retry, it will block until that TVars changed somehow
12:41:29 <nshepperd> stm retry will wait for the other thread to write to the TVar then retry
12:41:48 <EvanR> until something writes to it
12:42:00 <Gurkenglas> Wait, that is literal code? What will it retry? "the current do block" o.o?
12:42:09 <EvanR> the entire STM action
12:42:18 <EvanR> starting at atomically
12:43:29 <Gurkenglas> How will it know for what TVar to wait?
12:43:47 <johnw> it knows
12:44:00 <pharaun> iirc if any tvar changes it retries/wakes up
12:44:06 <EvanR> any TVars it read from
12:44:07 <nshepperd> it waits upon all the tvars that were read
12:45:13 <Gurkenglas> Does STM have Alternative, where empty = retry?
12:45:43 <broma0> Anyone know some good software architecture/design talks or posts? Looking for a good Haskell read..
12:46:25 <EvanR> Gurkenglas: yep... (<|>) = orElse
12:47:45 * hackagebot propellor 3.0.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.0.0 (JoeyHess)
12:47:48 * hackagebot scanner-attoparsec 0.1 - Inject attoparsec parser with backtracking into non-backtracking scanner  https://hackage.haskell.org/package/scanner-attoparsec-0.1 (YurasShumovich)
12:49:32 <darkroom> EvanR: I implimented your code and the problem is once you call the consumer it evaluates every search to the maxDepth
12:50:18 <EvanR> i didnt implement the exact producer strategy you had, whatever it was... i saw you had 2 putMVars for some reason
12:50:37 <EvanR> but the consumer should have no effect whatsoever on the producer
12:50:58 <EvanR> who is blindly overwriting the var
12:52:45 * hackagebot uuid-types 1.0.3 - Type definitions for Universally Unique Identifiers  https://hackage.haskell.org/package/uuid-types-1.0.3 (AntoineLatter)
12:52:48 * hackagebot uuid 1.3.12 - For creating, comparing, parsing and printing Universally Unique Identifiers  https://hackage.haskell.org/package/uuid-1.3.12 (AntoineLatter)
12:53:47 <Gurkenglas> Does do notation use empty on failed pattern matches when fail is not available?
12:53:54 <EvanR> i guess what you might want is to kill the thread when you take the move and restart the process on the next board?
12:54:55 <darkroom> EvanR: yea I am thinking about trying that. Check out this implimentation: http://lpaste.net/158196
12:56:43 <monochrom> Gurkenglas: fail is always available. unfortunate but true.
12:57:39 <EvanR> darkroom: i hear this process of interplay between real life time constraints and a chess thinking thread is a non trivial affair
12:58:09 <broma0> ';
12:59:36 <darkroom> EvanR: yes but I think what they are refrencing with that is the diffculty of deciding how much time to spend thinking a move. For instance if a score drops alot you should allocate more time to try to find a move that fixes the threat. Also endgame needs less time ect ect.
12:59:56 <grant123456789> Haskell
13:02:01 <EvanR> darkroom: i mean, if theres a possibility that someone forces you to move now, at any time... you better have a good enough move ready even if it isnt super great
13:02:19 <EvanR> no move ready would be kind of an error
13:02:45 <EvanR> restarting the thought process each move might exacerbate that
13:03:13 <darkroom> EvanR: Thats not really how chess clocks work. Once the opponent makes the move your time starts counting down. So its really about managing your time spent calculated
13:03:17 <darkroom> calculating*
13:06:52 <EvanR> so its up to a time managment thread to decide when to use the current move
13:09:14 <roconnor_> I want I spreadsheet implemented in haskell now.
13:09:27 <roconnor_> Twice Libre office has failed to add up numbers correctly.
13:09:47 <roconnor_> one f*cking task!
13:10:53 <Cale> roconnor_: lol... in what way? Rounding error?
13:11:26 <EvanR> > 1.1 - 1.0
13:11:28 <lambdabot>  0.10000000000000009
13:11:32 <EvanR> haskell is broken too!
13:12:10 <Cale> :)
13:12:58 <EvanR> dont worry ive got a paper here on linear fractional transformations of reals mapped to the unit circle
13:15:35 <Cale> Actually, it seems like LibreOffice doesn't have that issue somehow, even if I extend the number format to 20 places. Who knows whether it's being principled in accomplishing that though.
13:16:53 <EvanR> heh... decimals by default?
13:16:56 <Cale> ah, for 1.00000000001 - 1 it gets 0.00000000001000000083
13:17:04 <EvanR> nvm
13:18:21 <roconnor_> Cale: it broken some cell updates in during a sequence of insert row, copy row into inserted row, updated value in inserted row.
13:18:35 <roconnor_> Cale: ctrl-shift-f9 to recalculate the spreadsheet fixed it, but still.
13:18:52 <Cale> It seems like for values with at most two decimal digits, it's exact
13:19:13 <roconnor_> it was off by 18.25 according to my checksum.
13:19:16 <Cale> but as soon as you put something in the third place, you get all the usual binary floating point noise
13:19:26 <Cale> ah, that kind of thing
13:19:47 <roconnor_> which is the exact amount that I updated my cell value by
13:20:08 <roconnor_> yeah, it is a dependency tracking issue of some sort.
13:20:33 <roconnor_> failed to updated cells that were now summing over the newly inserted row.
13:23:28 <BaltecoTroll> any help with stack guys?
13:23:56 <cdtdev> Just ask and pray someone that knows is paying attention.
13:24:15 <BaltecoTroll> can i use env vars for setup? like tmpdir?
13:25:54 <cdtdev> For installing Stack itself? Or for a project you're doing?
13:26:17 <BaltecoTroll> cdtdev first
13:27:07 <BaltecoTroll> i have separate small fs for /tmp so stack can't setup due no space left errs
13:29:09 <cdtdev> You're trying to install from source or something?
13:29:15 <Cale> If you're okay with rebooting the machine, I would just change what /tmp is. :P
13:29:27 <Cale> But otherwise, hmm
13:29:50 <cdtdev> Oh, wait, I think I see what you're trying to do.
13:32:29 <BaltecoTroll> cdtdev just insalled stack from ubuntu ppm. and launched stack setup
13:32:30 <BaltecoTroll> sec
13:32:40 <cdtdev> BaltecoTroll:  Yeah, I got you.
13:32:50 <BaltecoTroll> http://pastebin.com/STeD6T2V
13:33:05 <Cale> BaltecoTroll: Supposedly export TMPDIR=/home/user/tmp ought to work
13:33:36 <rcat> is there any operator similar to (++) for NonEmpty lists from semigroups?
13:34:08 <Cale> rcat: <>
13:34:37 <Cale> rcat: that *is* the semigroup operation
13:35:13 <BaltecoTroll> hm. 800m is not enough?
13:35:44 <EvanR> thats helluva far
13:36:07 <rcat> Cale: oh, LOL, thanks :)
13:36:52 <james_gosling> hi
13:38:54 <BaltecoTroll> Cale :-* dude
13:44:58 <james_gosling> in blaze-html, how do i add a data-toggle attribute?
13:49:07 <Lokathor> i never stop wanting (<>) to be in Prelude
14:03:03 * hackagebot discogs-haskell 0.0.5.0 - Client for Discogs REST API  https://hackage.haskell.org/package/discogs-haskell-0.0.5.0 (accraze)
14:03:05 * hackagebot pinboard 0.9.4 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.4 (jonschoning)
14:13:36 <cdupont> Hi guys!!
14:15:01 <cdupont> Q: what should I do when getting this type of message with stack
14:15:08 <cdupont> "Failure when adding dependencies: QuickCheck: needed (==2.8.*), 2.7.6 found (latest applicable is 2.8.2)"
14:15:24 <cdupont> Delete .stack-work ?
14:16:40 <fr33domlover> cdupont, what are you building and using which stackage release
14:16:58 <fr33domlover> maybe you need to use a more recent LTS
14:17:17 <cdupont> I see
14:17:25 <fr33domlover> or add QuickCheck to extra-deps
14:17:50 <cdupont> lts-3.17
14:18:22 <cdupont> I added some dependencies to a personal software
14:19:16 <james_gosling> Lokathor just why isn't <> in prelude?
14:20:41 <lyxia> cdupont: that's quite old already
14:20:56 <cdupont> OK I need to update :)
14:21:29 <cdupont> The dependency I added use lts-2.19
14:21:46 <cdupont> so there is a mis-match
14:21:55 <cdupont> that should be the problem...
14:29:35 <BaltecoTroll> yet another stupid question. can i use my own global-stack-root for stack setup?
14:30:01 <lifter> Is there a safe way to write to a TQueue from pure code?
14:32:28 <barryburd> Working my way through the Monad Challenges: http://mightybyte.github.io/monad-challenges/. Trying to create a Monad from my Gen type. (See http://users.drew.edu/bburd//set1new.hs) but I’m getting the (familiar) error All instance types must be of the form (T t1 ... tn) where T is not a synonym. Any help?
14:38:57 <hjulle> lifter: If you write to a TQueue, the code isn't pure. ;) But to answer your question, no. The only STM action that can be used from unsafePerformIO is newTVarIO (and other newT...IO functions).
14:40:47 <lifter> hjulle, I was afraid of (and expected) that. I have pure code that creates a list of IO actions, and I'd like to be able to say, from my pure code, now execute these IO actions.
14:41:23 <lifter> hjulle, I've kind of painted myself into a corner.
14:41:45 <hjulle> And the IO actions contains "atomically"?
14:42:08 <lifter> hjulle, Not necessarily; no...
14:42:58 <lifter> hjulle, The reason I brought up TQueue was bcus I was thinking I could have another thread that listens on a TQueue containing a list of IO actions to be executed.
14:43:18 <robertmc> I am running command: cabal install ~/blah blah dir.  There is a sandbox installed there. How to tell cabal to use the sandbox like this?
14:43:20 <hjulle> Why do you need to execute IO actions from pure code? The point of pure code is that they can't execute IO actions.
14:45:11 <lifter> hjulle, I've found myself in a situation where I'm sort of deep in pure code and in this code I am, for example, building up strings that need to be shown to my user.
14:46:18 <lifter> hjulle, Actually, OK, now that I've thought about it more, the reason is that the pure code is being executed in the STM monad.
14:46:46 <lifter> that's why I'm stuck in pure code
14:47:06 <hjulle> lifter: It is usually a bad idea to use unsafePerformIO, that is why it is called "unsafe". But if you really can't refactor the code to avoid doing it, just use Control.Concurrent.Chan instead. But you really risk shooting yourself in the foot.
14:48:24 <lifter> hjulle, You mean use unsafePerformIO w/ Control.Concurrent.Chan?
14:48:38 <lifter> Looks like "writeChan" is in the IO monad.
14:50:20 <lifter> Woah, I just discovered that there is a "unsafeIOToSTM"
14:50:30 <hjulle> Yes, of course. But you could probably do some other trickery to get the data out from the pure code without needing change everything.
14:50:42 <hjulle> Aha, yes that is probably better.
14:51:46 <mniip> on type level, IO ~ STM anyway, it's the optimization and runtime implementation bits that matter
14:52:10 <hjulle> lifter: Or wait, no. I just read what you are saying more carefully. What you want to do is a bad idea.
14:54:10 <hjulle> lifter: The only IO actions that are safe to use inside STM are those who are effectively pure in practice anyways.
14:54:41 <hjulle> lifter: On the other hand, writing to a TQueue inside of STM should be really simple.
14:55:59 <barryburd> Can anybody help with my newbie question (… about 20 minutes ago)? Thanks.
14:56:44 <mniip> barryburd, because typeclass instances are for datatypes
14:56:54 <mniip> Gen is not a datatype
14:57:04 <mniip> it is a synonym for Seed -> (a, Seed)
14:58:34 <barryburd> mniip: Is there a way to quickly make a datatype out of my Gen synonym?
14:58:37 <hjulle> lifter: The reason for that is because STM actions may be retried, which means that any IO actions would be reexecuted as well, which is probably bad.
14:59:01 <mniip> barryburd, replace the synonym declaration with a datatype declaration?
15:00:16 <barryburd> mniip: Sorry to be so dense, but you mean data or newtype, right?
15:00:21 <mniip> yes
15:00:25 <barryburd> ok. Thanks.
15:00:32 <lifter> hjulle, Yes, I see.
15:03:05 * hackagebot hsdev 0.1.7.3 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.7.3 (AlexandrRuchkin)
15:08:42 <hjulle> lifter: But, as I said, if you can get the data/IO actions back to STM level, you can send it in a TQueue the normal way.
15:09:50 <lifter> hjulle, I can see that now. Thanks!
15:15:03 <hjulle> (A general tip about STM is to keep each "atomically" as small as possible (while still preserving correctness). If any of the variables touched inside a STM are modified, the whole action will be retried, which can make a huge impact on preformance, especially if the STM action takes long time.)
15:17:02 <monochrom> yes, the performance tip is to have fine-grained atomically, and the correctness tip is to have coarse-grained atomically :)
15:17:30 <hpc> the keep-from-going-insane tip is to not have enough contention that coarse atomically matters
15:17:46 <tomberek>  We see many solutions for the expression problem, but most seem to be focused on an untyped lambda calculus problem. Is there a similar solution which can implement typed expressions? Imagine having an EBNF expression and mechanically creating the types/classes/constructors/etc from it which enforces the invariants
15:17:49 <hpc> concurrency is fun!
15:19:24 <Lokathor> james_gosling, i don't know why (<>) is not in prelude
15:19:35 <hpc> it's in the php prelude!
15:19:45 <Lokathor> >_>
15:19:51 <hpc> that package never gets old
15:20:45 <hjulle> So, yes, better too than too small atomically (correctness is more important than performance).
15:21:09 <averagehat> https://www.irccloud.com/pastebin/20jY9qDd/
15:21:13 <hjulle> *too large than
15:21:19 <Lokathor> be sure to stay at "minimum safe atomically"
15:21:47 <averagehat> From an educational viewpoint, Is there anything wrong with this statement?
15:21:47 <averagehat> "The types of functions are like the domains and co-domains of mathematical functions. A type error indicates that a value is outside a function's domain."
15:22:05 <averagehat> (sorry, please ignore the link)
15:22:35 <Lokathor> seems correct enough
15:24:19 <averagehat> phrasing things that way (pulling in my limited algebra education) is very helpful to me, for some reason
15:26:05 <EvanR> (B -> C) . (A -> B), works because an A will be mapped to a B, which can be mapped to a C
15:26:24 <EvanR> (B -> C) . (A -> J) doesnt because you J != B
15:26:41 <EvanR> you cant use the second function to map J to to C
15:26:53 <EvanR> (second.. meaning the one on the left)
15:27:31 <hjulle> EvanR: Assuming the goal is to map A to C?
15:27:48 <Zemyla> Why is Data.Coerce unsafe?
15:27:49 <EvanR> theres no real goal implied by that alone
15:28:13 <EvanR> it cant do anything at all for the reason J ! = B
15:28:32 <EvanR> at least it has the potential to be right if J = B
15:31:05 <EvanR> note that this is not necessarily the only way to deal with types not matching
15:31:50 <EvanR> if i have pipe A to B, and pipe J to C... then someone may say... the input to the second pipe is simply "B or J"
15:33:05 <EvanR> im in the process of trying to understand the consequences of this hypothetical idea ;)
15:33:15 <EvanR> proof that it makes no sense would be nice but i have none
15:33:52 <int-e> Zemyla: https://ghc.haskell.org/trac/ghc/ticket/8827 ... see in particular comments 25 to 26 ... unfortunately this will still be the case in ghc 8.0.1
15:35:19 <Zemyla> That's sad, because coerce is way too useful.
15:36:07 <int-e> Zemyla: Note that I don't understand what the problem is precisely; the discussion there is rather lengthy. In my limited understanding the purpose was to give library authors time to sprinkle nominal type roles into code that needs it (like Data.Map.Map)
15:52:21 <Xandaros> Would it make sense to use `Either String ()` instead of `Maybe String` if the presence of the String denotes an error case?
15:53:35 <dmj> Xandaros: yes, Either String a is a common pattern (where String represents an error)
15:54:34 <Xandaros> Yeah, that's why I'm asking. On the one hand people will recognise it as something that can error, but on the other hand it is isomorphic to a simpler type
15:55:00 <Xandaros> But yes, Either String () seems the better choice. Maybe String kinda implies the opposite
15:55:07 <dmj> Xandaros: yes, that's true
15:55:38 <EvanR> if the simpler type is commonly in use... it might help to use it
15:55:48 <EvanR> but i dont see Maybe String used much for errors
15:55:59 <EvanR> you do see data Result = Ok | Error String
15:56:46 <EvanR> but youll have to reimplement monads and everything
15:57:22 <EvanR> er, monoid
15:57:54 <enthropy> you could do newtype EvanR'sResult = Result (Maybe String)
15:58:05 <enthropy> and derive all those classes
15:58:41 <mniip> no you can't
15:58:42 <Xandaros> Well, this is a monadic action that either silently works or fails with an error. I'll use Either String Unit. (This is actually in purescript, but I feel more comfortable in #haskell :D)
15:58:43 <mniip> wrong kind
15:59:17 <EvanR> yeah if youre in the Either monad... thats what you have to do
15:59:35 <mniip> Either is not a monad!!1!one!
15:59:38 <EvanR> the Either e monad
16:00:11 <Xandaros> Either is a monad constructor. Happy?
16:13:07 <joneshf-laptop> Are there any good resources I could point someone to on hole driven development?
16:14:27 <dmj> joneshf-laptop: might be a bit old, but I liked this
16:14:27 <dmj> http://matthew.brecknell.net/post/hole-driven-haskell/
16:15:21 <joneshf-laptop> dmj, thanks, know of anything written?
16:16:23 <dmj> probably the wiki, https://wiki.haskell.org/GHC/TypeHoles
16:17:52 <joneshf-laptop> sounds like this is an area that could go for a few blog posts
16:19:40 <Hafydd> That's an unhealthy way to live.
16:19:45 <Hafydd> Have you tried reading real documentation?
16:19:50 <Cale> Does every language feature X have to result in X-driven development? :)
16:20:14 <joneshf-laptop> yes
16:20:51 <Xandaros> I'm going to start UnicodeSyntax-driven development. Sounds like a good idea
16:20:52 <Hafydd> And what was amiss there?
16:21:13 <texasmynsted> I use neovim.  vim/neovim users, what do you use to create a simple template or something when creating a new source file?
16:21:28 <Xandaros> texasmynsted: UltiSnips...
16:21:32 <hpc> Cale: incoherent type-driven development
16:22:53 <johnnymo87> newb question … in ghc 7.10, what should I do if I need mapM without the Foldable constraint? My google-fu is failing me.
16:22:59 * texasmynsted googles UltiSnips
16:24:34 <hjulle> johnnymo87: What type would it have without the Foldable constraint?
16:24:50 <johnnymo87> mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:25:18 <hjulle> :t mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:25:19 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:25:50 <johnnymo87> but in ghc 7.10 it’s mapM :: (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
16:26:00 <hjulle> :t mapM
16:26:01 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
16:26:07 <joneshf-laptop> :i Traversable
16:26:11 <Xandaros> Doesn't [a] have a Traversable instance? I don't see the problem
16:26:28 <joneshf-laptop> :info Traversable
16:26:29 <joneshf-laptop> beh
16:26:31 <hjulle> Yes, but [a] is traversable
16:27:36 <johnnymo87> i should’ve written m a not [a]
16:27:41 <hjulle> johnnymo87: So, just use mapM as if it had the type you wanted, and the compiler will automatically specialize t to list.
16:28:26 <Xandaros> (>>=)?
16:28:32 <Xandaros> :t (>>=)
16:28:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:28:47 <joneshf-laptop> johnnymo87, do you mean to say you want something like `Monad m => (a -> m b) -> m a -> m [b]` ?
16:28:50 <johnnymo87> maybe i’m approaching it the wrong way, but i’m generating random trees with quickcheck, and then fire them through putStrLn
16:29:01 <johnnymo87> the type of the tree is Test.QuickCheck.Gen.Gen String
16:29:17 <johnnymo87> well, the stringified tree is that type
16:29:23 <texasmynsted> How do you know what snips work for haskell?
16:30:07 <Xandaros> texasmynsted: I made my own, I didn't use any prebuilt ones. It determines what language the snippets are for based on in which file they are defined
16:30:19 <johnnymo87> when I do mapM_ putStrLn <my func>, i get "No instance for (Foldable Test.QuickCheck.Gen.Gen) arising from a use of ‘mapM_’ In the expression: mapM_ putStrLn MaxHeapSpec.printTree’"
16:30:23 <Xandaros> texasmynsted: You can open the file for the current filetype with :UltiSnipsEdit
16:30:37 <texasmynsted> You made your own?  Do you share them on github?
16:31:03 <Xandaros> texasmynsted: https://github.com/Xandaros/dotfiles/tree/master/config/nvim/UltiSnips
16:31:13 <johnnymo87> i might just download ghc 7.8 to continue this experiment, but i was curious if there was a way to get mapM on ghc 7.10 without the foldable constraint ...
16:31:29 <Xandaros> texasmynsted: Looks like I don't actually have any haskell ones, though :P
16:31:36 <texasmynsted> LOL
16:31:45 <texasmynsted> Ummk
16:31:57 <joneshf-laptop> johnnymo87, note that `mapM` and `mapM_` are different functions.
16:32:07 <johnnymo87> yes
16:32:12 <hjulle> johnnymo87: Downloding ghc 7.8 won't help. The new version is more general than the old one.
16:32:22 <Xandaros> johnnymo87: 7.8 is even more specific - it needs to be a list. If it is a list, it has a Traversable isntance
16:32:28 <johnnymo87> oh
16:32:56 <johnnymo87> so it really was [a] on 7.8, not m a
16:32:57 <johnnymo87> got it
16:33:53 <Xandaros> johnnymo87: Think about what type of function you really need. I suspect you want something like fmap, but I don't know your problem enough
16:34:33 <texasmynsted> Looks like this has haskell snippets
16:34:34 <texasmynsted> https://github.com/honza/vim-snippets/tree/master/snippets
16:37:06 <hjulle> johnnymo87: The type Test.QuickCheck.Gen.Gen is just a generator of values. To actually generate the values, you need to use a function of type Gen a -> IO a, or similar. (Look in the QuickCheck documentation).
16:37:56 <johnnymo87> yeah, the function I want is sample
16:38:29 <johnnymo87> but it comes out looking sort of hideous
16:38:48 <johnnymo87> the tree pretty printing, that is
16:39:21 <hjulle> johnnymo87: If you lpaste the code, I might be able to give you some advice on how to simplify it.
16:40:51 <Tendies> how am i supposed to concat s, d, and e when s is a char, d is a string and e is a char?
16:41:43 <Tendies> (s:d:e), (s:d):e), ([s]:d:[e]) and various other forms decide they want string when i give char and char when i give string
16:41:51 <joachifm> s : d ++ [s]
16:41:59 <johnnymo87> hjulle: https://github.com/johnnymo87/heap
16:42:15 <joachifm> err, [e]
16:42:50 <Tendies> so you can't chain :?
16:43:08 * hackagebot ztail 1.2 - Multi-file, colored, filtered log tailer.  https://hackage.haskell.org/package/ztail-1.2 (DylanSimon)
16:43:10 <mniip> :t (:)
16:43:11 <lambdabot> a -> [a] -> [a]
16:43:35 <johnnymo87> assuming I have it in a state that works on your machine, you could "cabal repl spec", and then "MaxHeapSpec.printTree’’"
16:43:39 <Tendies> like ((s:d):e)  can't just stick e onto the result of (s:d)
16:43:50 <mniip> it does precisely one thing, prepend one element to a list
16:44:02 <mniip> which is what its type says
16:44:18 <Tendies> oh only in one direction 
16:44:28 <Tendies> ok
17:03:41 <hjulle> johnnymo87: I'd probably just inline it: "sample $ drawTree . toDataTree <$> (arbitrary ::  Gen (MaxHeap.Tree Int))", possiby moving the arbitrary to a where clause.
17:04:40 <johnnymo87> agreed … i just broke them up like that so i could inspect the types more easily
17:06:16 <johnnymo87> i’m pretty close, actually … the output I’m getting now looks like this: "\".\"\n"
17:06:52 <johnnymo87> if I switch from sample to sample’, and do this: fmap head MaxHeapSpec.printTree''' >>= putStrLn
17:06:56 <hjulle> johnnymo87: Speaking of where clauses, I would probably move the whole "Positive m <- arbitrary;let n' =...;l <- arbTree n'" thing to a where clause, to avoid repeating myself.
17:07:06 <johnnymo87> it prints as just "."
17:08:14 <hjulle> I assume the trees are supposed to contain more than just a "."? :)
17:08:18 <johnnymo87> ha, yes
17:08:24 <johnnymo87> that was just the shortest one
17:09:13 <johnnymo87> regarding the where clauses .. that would just be drying up the definitions of n’ and n’’?
17:09:52 <hjulle> and the Positive m and the arbTree
17:10:47 <johnnymo87> makes sense
17:10:53 <hjulle> The whole function excluding where clause could look like "Branch <$> subtree <*> arbitrary <*> subtree"
17:12:23 <hjulle> (I'm assuming you are familiar with applicative style)
17:13:09 <johnnymo87> familiar enough, i think
17:13:26 <johnnymo87> how deeply do i need to indent the where clause? more than the do block?
17:13:32 <hjulle> Also, the paranthesis around Positive m and arbTree n' are redundant.
17:13:55 <sydneyhacker> Hi all. I am learning type theory. Very early days. I am wondering what people's thoughts are on "Programming in Martin Lof Type Theory" as a ramp on to the recorded lectures by Robert Harper and his books.
17:14:05 <sydneyhacker> Is it too old, or is it helpful?
17:14:15 <hjulle> johnnymo87: If you write it as I said, you don't actually need a do block.
17:14:24 <johnnymo87> oh
17:15:14 <hjulle> (Except for in the where clause)
17:16:55 <hjulle> But you can actually indent the where less than the do block, it's even the recommended style: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
17:18:41 <johnnymo87> hjulle: http://pastebin.com/RKPzRE1L
17:20:08 <hjulle> Yes, exactly
17:20:28 <hjulle> Or wait, no. The order is wrong I think
17:21:10 <hjulle> Shouldn't the node value be in the middle?
17:22:05 <hjulle> Oh, it shouldn't. It was me who was wrong. :P
17:22:49 <johnnymo87> i prefer it in the middle too, but I moved it to the left for compatibility with Data.Tree
17:23:25 <johnnymo87> so I am getting pretty close now that I’ve switched to sample’
17:23:35 <johnnymo87> I have that giving me this: MaxHeapSpec.printTree''' :: IO [String]
17:23:58 <johnnymo87> and I have this: (\x -> x >>= putStrLn) :: IO String -> IO ()
17:24:12 <johnnymo87> I thought I could connect them with fmap, but I’m just a little off
17:24:30 <Lokathor> i often wish haskell had conditional dependencies
17:24:31 <Guest_98765> http://bc.vc/AWDMcu
17:24:32 <hjulle> Some minor formatting changes and simplifications: http://pastebin.com/8GKePW9R
17:24:54 <Lokathor> like, "if they import deepseq on their own, add this instance, otherwise don't bother to have it or the deepseq dependency"
17:25:28 <johnnymo87> yes, the redundant parens, thank you
17:25:50 <johnnymo87> ah, and the return
17:26:29 <hjulle> It can be written as: (>>= putStrLn) :: IO String -> IO ()
17:27:27 <hjulle> So yes, the way to connect monadic functions are either (>>=) or do-notation.
17:28:19 <hjulle> (which translates to (>>=)s)
17:33:18 <johnnymo87> so   fmap head MaxHeapSpec.printTree''' >>= putStrLn  gives me what I want for the first randomly generated tree, but I’m having a mental block with how to get to just mapping (>>= putStrLn) over all of it because    fmap (>>= putStrLn) MaxHeapSpec.printTree'''   isn’t valid
17:35:25 <johnnymo87> and I’m guessing this is because the type I’m mapping over if IO [String] … which maybe needs two fmaps to get to the String?
17:35:26 <hjulle> johnnymo87: Now, the circle is closed, and the answer is the question you started with. :)
17:35:31 <johnnymo87> haha
17:39:25 <johnnymo87> wait, for mapM_ to work, wouldn’t my type need to be [(IO String)] not IO [String] ?
17:39:31 <hjulle> printTree''' :: IO [String]. (printTree''' >>=) :: ([String] -> IO a) -> IO a. putStrLn :: String -> IO (). mapM_ :: (a -> m ()) -> [a] -> m ()
17:40:58 <hjulle> It's like a jigsaw puzzle. :)
17:41:18 <johnnymo87> hmm
17:42:29 <hjulle> It might be easier to think if you use do-notation instead of >>=
17:43:03 <hjulle> Also, using type-holes (_), can help a lot.
17:51:05 <johnnymo87> (MaxHeapSpec.printTree''' >>=) (\x -> mapM_ putStrLn x)
17:51:07 <johnnymo87> wow
17:51:19 <johnnymo87> hjulle: thank you!
17:51:20 <hjulle> Which can simplify to?
17:51:50 <johnnymo87> MaxHeapSpec.printTree''' >>= \x -> mapM_ putStrLn x
17:52:08 <hjulle> and eta reduction
17:52:20 <hjulle> (that is to say, eliminating lambdas)
17:52:48 <johnnymo87> MaxHeapSpec.printTree''' >>= mapM_ putStrLn
17:52:56 <hjulle> \o/
17:53:08 <johnnymo87> niiice
17:53:26 <hjulle> yep.
17:53:36 <hjulle> =D
17:53:38 <johnnymo87> woohoo, now I can pretty print random trees!
17:53:46 <johnnymo87> thanks for your help!
17:54:00 <hjulle> You're welcome.
17:55:34 <hjulle> I haven't thought of this before. Programming in haskell is really *a lot* like doing a jigsaw puzzle.
17:56:03 <Tendies> what is <|> in haskell? i can't google it because google ignores those characters
17:56:11 <geekosaur> ...if you could build larger puzzle pieces from smaller ones,,,
17:56:16 <hjulle> @hoogle (<|>)
17:56:21 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
17:56:22 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
17:56:22 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
17:56:29 <geekosaur> Tendies, usually it's Alternative (see Control.Applicative)
17:56:33 <Tendies> searched on hackage too no result D:
17:56:40 <geekosaur> hoogle and hayoo are your friends
17:56:46 <geekosaur> @where hayoo
17:56:46 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
17:58:33 <Job316> >show "cat"
17:58:34 <ctct> continuation monad: I understand your type signature, and I can implement you ... but I have no idea how you work .... and now I'm scared that I ever wanted to use you in *untyped* languages
17:58:52 <Job316> hi - how do I do something like this: http://lpaste.net/158286 - I want to avoid the extra quotes on a show
17:59:37 <hjulle> ... where most puzzle pieces are polymorphic (whatever that would mean for a physical puzzle). :)
18:02:51 <hjulle> Job316: You want it to use normal show for anything but strings, where it should just return the string verbatim without extra quotes?
18:02:59 <Job316> yes
18:04:53 <hjulle> You can use Data.Typable to match on types.
18:05:13 <Job316> ah
18:05:17 <Job316> let me try that
18:05:20 <Job316> thanks
18:05:45 <kaloabo> hello, i posted this question earlier today, but couldnt fix the problem. so since today when i type read "2" in GHCi, i get an exception prelude.read: no parse so i have to type read "2" :: Int. Does anyone know what could cause this behaviour?
18:06:12 <geekosaur> deally you don't abuse Show, you use a prettyprinting library instead of a typeclass intended for debugging
18:07:01 <geekosaur> but every new user that shows up knows that Show is their prettyprinting library and they must abuse it
18:07:13 <geekosaur> kaloabo, ExtendedDefaultRules
18:07:30 <geekosaur> which is on by default in sufficiently recent ghci
18:07:47 <geekosaur> so it defaults to () instead of Integer
18:12:49 <kaloabo> geekosaur, thank you, i'll try to look up what ExtendedDefaultRules is, im pretty new to haskell
18:13:41 <Tendies> I'm trying to write a parser that will succeed if a correct <head>...</head> string is passed in, and i need to return "False" plus the whole input if it fails. Using this notation it's not liking it.. http://lpaste.net/158288 
18:14:19 <Tendies> my understanding was that <|> will try the first and if it fails, try the second parser. is this correct?
18:15:47 <geekosaur> sorry, my main network collapsed, had to bring up the hotspot
18:15:53 <geekosaur> it's a ghc extension
18:16:11 <geekosaur> ":seti -XNoExtendedDefaultRules" to disable it in ghci
18:16:22 <Clint> Tendies: your use should be a <|> b, not <|> a <|> b
18:17:46 <james_gosling> huh jquery must come before bootstrap ... ah web development you so crazy :/
18:18:16 <james_gosling> does anyone have experience structuring ajax apps haskell web frameworks?
18:19:06 <Tendies> Clint: so i would only be using <|> once since there are two statements?
18:20:06 <Clint> Tendies: yes
18:20:16 <Clint> > Nothing <|> Just "second"
18:20:18 <lambdabot>  Just "second"
18:21:02 <dmj`> james_gosling: do you mean compiling haskell to javascript? Or communicating with a haskell web server via AJAX?
18:21:02 <Tendies> > Just "first" <|> Just "second"
18:21:04 <lambdabot>  Just "first"
18:21:23 <james_gosling> dmj` the latter
18:21:40 <dmj`> james_gosling: yes
18:22:40 <james_gosling> dmj` how do you structure the app, do you use something like blaze-html for the html?
18:23:52 <Tendies> is <|> not in prelude.. what can i use as an alternative without importing anything
18:24:31 <dmj`> james_gosling: yes, you can. You can send HTML via an ajax request
18:25:10 <dmj`> james_gosling: for REST APIs I use servant, it abstracts most of that away. All you need to provide are instances for ToJSON and ToHtml (lucid / blaze)
18:25:48 <dmj`> james_gosling: if you want something that gives you full page postbacks, where most of your templating is done on the server side, you could use snap / happstack / yesod
18:26:05 <dmj`> james_gosling: otherwise, servant + reflex-dom would seem to be a cool stack
18:26:14 <james_gosling> dmj` so do you write the front end entirely in html/js (or purescript) and have it talk to the endpoints? or is there a part of the front end view that's handled in haskell as well?
18:26:37 <dmj`> james_gosling: you can do either, whatever you're most comfortable in, or interested in
18:27:40 <james_gosling> how would you go about constructing the view in haskell. something like blaze-html for the html? what handles the ajaxy-functionality?
18:29:05 <dmj`> james_gosling: with servant you can describe it with types, and then the framework will reify the serialization / routes, web server for you
18:29:29 <dmj`> main = run 8000 (serve (Proxy :: Proxy API) (pure $ Foo 1))
18:29:47 <dmj`> type API = "foo" :> Get '[JSON, HTML] Foo
18:30:22 <dmj`> james_gosling: the type level list will force a constraint on ToJSON, ToHtml for Foo, so you'll need to provide instances
18:30:50 <dmj`> newtype Foo = Foo Int deriving (ToJSON, FromJSON, Show, Eq, Ord)
18:30:52 <james_gosling> dmj` what about the interaction aspect. "put a menu thing here and when the user clicks this menu thing here, change this div to display X..."
18:32:10 <dmj`> james_gosling: you'll need to decide wether or not you want to make a "single page application" or more of a traditional postback style application, or some mix of the two. What I've traditionally seen, are pages that don't require authentication to be delievered by the server (since it's faster), and sections of your application that do require auth, to deliver large javascript applications. 
18:32:34 <dmj`> james_gosling: if that makes sense
18:33:37 <dmj`> james_gosling: for html templating on the server you can use something like heist or blaze, the advantage of heist is that you don't have to recompile your application, as you would with blaze
18:33:43 <dmj`> or lucid
18:34:14 <james_gosling> kind-of so for the 1-pager option there would just be a monolithic chunk of javascript and html corresponding delivered by a home endpoint. you'd deal with all the design/logic in that chunk
18:34:18 <dmj`> james_gosling: for client side templating you would use "el" in reflex-dom, to create a view using the DOM API
18:34:46 <james_gosling> dmj` client side templating would require ghcjs right?
18:35:09 <dmj`> james_gosling: basically, for stuff like "contact us", "about us", etc. that is static, you could just deliver raw HTML (*shudders*) w/ nginx or something. Only after auth give them the goods
18:35:25 <dmj`> james_gosling: well there are other alternatives to ghcjs, like haste
18:36:47 <james_gosling> i think i see. what about a combination of julius + blaze-html to generate all the front-end endpoints?
18:37:14 <james_gosling> does it get too annoying to recompile?
18:37:32 <dmj`> james_gosling: if its static, it's probably not changing that much anyways
18:37:51 <dmj`> if its dynamic, I can see how it could get annoying
18:38:05 <james_gosling> i'm wondering if there's a way to feel like i'm writing one app instead of two, but maybe this is just how webdev is...
18:38:08 <dmj`> it depends on how good/easy/fast/cheap your deployment is really
18:38:29 <dmj`> james_gosling: web dev is like writing 5 apps, docs, front end, database, application logic, tests
18:38:48 <dfeuer> dmwit, can you take a look at http://stackoverflow.com/a/36378763/1477667 ?
18:39:03 <exio4> dfeuer: at least
18:39:05 <hjulle> You could always generate much of the static html from markdown as well.
18:39:07 <tailgate> at best, node.js but you still have to write some sql
18:39:16 <dfeuer> exio4, ?
18:39:20 <exio4> er, dmj` *
18:39:30 <exio4> at least five :)
18:39:35 <james_gosling> dmj` my use case is a little weird. i'm doing scientific computing work and i'm using web tech for the datavis as a substitute for R/python
18:40:17 <dmj`> james_gosling: sounds very cool
18:40:32 <dmj`> exio4: I know right
18:41:29 <james_gosling> dmj` i've gotten some proof of concept things working but there's a lot of inventing wheels and trying to figure out how to practically iterate things at R speed
18:41:55 <dmj`> james_gosling: I think there is a package to do interop with R, http://tweag.github.io/HaskellR/
18:42:02 <james_gosling> using tech that's typically meant to engineer long term programs
18:42:08 <dmj`> james_gosling: or you could just use vector
18:42:18 <dmj`> james_gosling: sure
18:42:28 <james_gosling> dmj` yeah i've tinkered with haskellR, but it's a bit finnicky
18:42:58 <hjulle> Iterate in what way?
18:43:01 <james_gosling> being able to use web for interaction is more compelling if there's a way to pull it off.
18:43:24 <james_gosling> hjulle as in, i want to write web apps for data analysis almost as fast as i can pull off an R script
18:43:46 <james_gosling> hjulle that's where things are going even in the R/python world with stuff like Shiny and Rmarkdown
18:44:13 <james_gosling> also being able to steal js's visualization & interaction ecosystem kind of makes up for haskell's lack of one.
18:44:50 <james_gosling> i think it can be done, but the awkward thing is this isn't what most haskell folks are using web tech for
18:45:43 <james_gosling> also i'm a scientific computing/data science guy by training ... kind of learning web dev as i go. so i'm not always clear on the category of questions and solutions i should be taking.
18:45:44 <dmj`> james_gosling: sure, it depends on what you want to do I guess. I assume reflex-dom would probably be your best bet for interactive visualizations. There's always elm too, but then you're not haskell :)
18:46:26 <hjulle> Someone was talking in the irc about doing the same thing a few days ago. I believe he was using plotly for the rendering.
18:46:30 <james_gosling> ghcjs still feels like a big lumbering beast to me...
18:46:37 <james_gosling> hjulle that was me
18:46:41 <hjulle> aha
18:46:41 <james_gosling> probably
18:46:53 <hjulle> you had a different nick then
18:47:05 <james_gosling> i usually don't come ono with the same nick more than once
18:47:34 <james_gosling> lol hopefully i'm not giving a fasle impression that there's way more people trying to do the things i'm trying to do than there are.
18:48:21 <hjulle> I guessed that it could be you, but I wasn't sure.
18:48:26 <james_gosling> ghcjs feels a bit like a beast. if i was going to fully separate frontend/server code, i might go with something like purescript at the moment
18:48:44 <Tendies> how can i get this to produce the desired output, [(True,"")] and not [("True","")] on successful parse? http://lpaste.net/158289
18:48:50 <dmj`> james_gosling: I would seriously consider reflex-dom, and servant-reflex, to keep you sane
18:49:04 <james_gosling> but initially i want to see if it's possible to do it all in an integrated codebase to mimic the continuity of doing data anlysis in python or R
18:49:31 <dmj`> Tendies: Parser Bool ?
18:49:44 <Tendies> oh..
18:50:40 <james_gosling> ideally i want to be able to go from nothing to a lightweight bit of analysis visualization in a few hours. that's the expectation with python and R, and that's the level of productivity i will have to maintain if i'm going to get away with using haskell
18:51:27 <dmj`> james_gosling: iHaskell might be able to do some of that
18:51:30 <dmj`> https://github.com/gibiansky/IHaskell
18:53:30 <lpaste> tailgate pasted “checkParse (tailgate)” at http://lpaste.net/158290
18:54:29 <tailgate> so I'm writing a function in the above pastebin. All the IO it needs to do is print a message based on the results of calling (parser grammer str), but I can't get the types right. What should I be doing?
18:55:30 <dmj`> tailgate: line 4
18:55:39 <dmj`>  parse <- (parser grammar str)  should be,  let parse = parser grammar str
18:56:03 <dmj`> tailgate: you're in the IO monad, and <- there is assuming you're in the Either monad
18:56:42 <Tendies> So I need to parse a string, and i want to return [(True,"")] on success, but [(False,input")] where input was the string initially sent to the parser
18:57:14 <Tendies> i see i can use an if then else statement at the last line of the do block, but i cant determine a condition to check against
18:57:31 <dmj`> tailgate: checkParse parser grammar (x,y) = pure $ parser grammar y == x
18:57:33 <tailgate> dmj`: is let the correct construct in this case?
18:57:38 <tailgate> ah
18:57:41 <EvanR> help I'm trapped in a monad
18:58:23 <maerwald> EvanR: :(
18:58:44 * maerwald gives EvanR dependent types
18:59:02 <EvanR> too powerful! it burns!
18:59:05 <maerwald> :D
18:59:33 * johnw gives EvanR a dependent types, along with the evidence he'll need to construct an inhabitant
19:00:00 <EvanR> oh, now its trivial!
19:00:03 <EvanR> too boring
19:00:58 <EvanR> speaking of dependent types I just read the scoped labels extensible records paper and its pretty cool
19:01:10 <Tendies> anyone ? ,_,
19:01:40 <aweinstock> Tendies: I'm looking at it
19:02:03 <Tendies> :)
19:03:03 <dmj`> Tendies: I think that depends on if your parser has consumed all of the input
19:03:20 <aweinstock> Tendies: which module is Parser from?
19:03:24 <Tendies> if it fails i need to return the entirety of the input regardless of where it failed
19:03:48 <Tendies> i have a file called Parsing.hs that i thought was a modification on some standard module
19:04:05 <Tendies> that's where it's coming from
19:06:20 <lpaste> aweinstock pasted “Parsec example” at http://lpaste.net/158291
19:06:29 <aweinstock> Tendies: ^
19:07:07 <Tendies> yes so i guess that's the standard library version of what i have currently
19:07:36 <aweinstock> also changed (Parser String) to (Parser Bool)
19:08:02 <Tendies> oh right, i fixed that after i uploaded that 
19:08:28 <aweinstock> for the result to be True instead of "True", you need Bool instead of String (and you probably have some implicit conversion magic in your modification of Parsec?)
19:08:43 <Tendies> oh that was a previous question that i got answered
19:08:54 <Tendies> that part works yeah
19:09:20 <aweinstock> oh
19:09:25 <aweinstock> what's the current question?
19:09:59 <Tendies> oh the current one doesnt have a lpaste with it
19:11:54 <dfeuer> Edited: http://stackoverflow.com/a/36378763/1477667   Anyone have any thoughts on improving it?
19:23:19 <Lokathor> yeesh, i've got some nasty 5xIndent code
19:23:26 <Lokathor> but no good way to collapse it
19:24:50 <tailgate> is there a way in ghci to see what classes a type implements?
19:25:28 <hjulle> :i
19:27:55 <hjulle> Also ":info!" which "does not filter instances".
19:33:40 <django_> where can i find a data base of airline frights and costs
19:34:15 <Clint> what
19:34:29 <c_wraith> I think that's supposed to be freights
19:36:35 <EvanR> ol
19:36:54 <EvanR> see the latest airline frights!
19:37:03 <EvanR> click here
19:40:01 <johnkast1er> I'm trying to use the language.c package as part of a small project I'm working on. Does anyone know where I can find good docs/examples/tutorials for it?
19:41:20 <dmj`> johnkast1er: https://github.com/fpco/inline-c/blob/master/README.md
19:41:38 <dmj`> not language-c I guess.. but still relevant :]
19:43:51 <johnkast1er> Yeah, that's not exactly what I'm after. 
19:43:59 <johnkast1er> I'm using this http://hackage.haskell.org/package/language-c-0.5.0
19:46:29 <tailgate> if I want to print a message like <list> ++ "matches" ++ <list2> where evreything is an isntance of Show, what do I do?
19:47:29 <johnkast1er> I want to use the library to extract the function declarations from a c header file and generate c implementations of those function acording a set of rules I have. Currently I'm using regex + putStrln "c source code" but that is (of course) rather delicate.
19:47:58 <dmj`> tailgate: putStrLn $ shoe <list> ++ "matches" ++ show <list2>
19:48:03 <dmj`> show*
19:48:06 <dmj`> not shoe
19:48:48 <tailgate> ah. Will it print \" like it does in ghci?
19:48:54 <tailgate> instead of "
19:51:06 <dmj`> tailgate: if you call show on a String, it will
19:51:13 <dmj`> > show ("foo" :: String)
19:51:15 <lambdabot>  "\"foo\""
19:51:29 <dmj`> tailgate: print = putStrLn . show
19:52:04 <verement> > let list = [1,2,3] in shows list . showString " matches " . shows list $ ""
19:52:05 <lambdabot>  "[1,2,3] matches [1,2,3]"
19:52:08 <LordBrain> I deeply appreciate some of haskell's quirkiness
19:52:58 <LordBrain> like double colon for type, and overloading of . for compose. May these quirks live forever.
19:54:27 <LordBrain> the idris folks think the double colon is wrong because the colon is what ocaml uses, and it has precedence historically, but the double colon is so much better because it makes the type signature stand out and provides a nice marker of the top level function.
19:56:57 <LordBrain> also, i know some people don't like the (.) for compose, but i disagree, it is so easy to type compared to some unicode thingy, and it is the least intrusive symbol for something that has only slightly more semantic content than application which is a space.
19:58:33 <LordBrain> imo, where haskell differed from convention, in terms of notation, it made an improvement to it.
20:04:43 <LordBrain> i think the mkLens macros should be done away with, and we should have a proper extension of the language which makes lenses automatically for our records, without the use of template haskell.
20:05:11 <Gurkenglas> LordBrain, what about adding a deriving Lens clause instead?
20:05:24 <LordBrain> i'd have to see how it works, but it sounds fine to me
20:05:27 <geekosaur> that's coming soonish, isn't it? OverloadedRecordFields
20:05:32 <geekosaur> didn't quite make 8.0.1
20:06:00 <Gurkenglas> data Thing a = Thing {x :: a, y :: Int) deriving (Functor, Foldable, Traversable, Lens)
20:06:26 <Gurkenglas> -)+}
20:14:32 <lambda-11235> Gurkenglas: Isn't a lens a function, not a type class?
20:15:35 <EvanR> generalized deriving deriving
20:15:56 <hjulle> ('Lens' is a type alias.)
20:18:08 <LordBrain> becuase you brought it up i started reading https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Redesign which led me to read https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/DuplicateRecordFields ... to which I have a question
20:18:47 <LordBrain> " However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous: bad (p :: Person) = personId p" 
20:19:04 <LordBrain> this is regarding DupliciateRecordFields
20:20:04 <LordBrain> so if i understand right, if they have a type signature for bad, like so good :: Person -> Int, good p = personId p, then all is well
20:20:35 <LordBrain> it then goes on to give more details,but not a justification for this
20:20:43 <LordBrain> so what justifies this?
20:20:52 <LordBrain> if good works, why shouldn't bad?
20:22:51 <LordBrain> in otherwords, since it seems to me bad's type can be completely inferred, why should it be different from having the type signature explicit?
20:27:00 <LordBrain> maybe the idea is bad's type cannot be inferred, because even though it works on type Person, it might be polymorphic and work on other types as well which also have definitions for personId
20:27:35 <LordBrain> that must be the idea
20:28:15 * hackagebot bindings-wlc 0.1.0.5 - Bindings against the wlc library  https://hackage.haskell.org/package/bindings-wlc-0.1.0.5 (ashleyis)
20:28:41 <EvanR> > maxBound :: Int
20:28:42 <lambdabot>  9223372036854775807
20:29:12 <hjulle> > maxBound + 1 :: Int
20:29:13 <lambdabot>  -9223372036854775808
20:29:45 <LordBrain> i am not sure, but i think the maxBound for int changes depending on whether you are on 64 bit or 32 bit platform
20:30:09 <LordBrain> thus if you need a fixed bound, you should probably use a different type
20:30:22 <hjulle> > maxBound + 1 - minBound :: Int64
20:30:24 <lambdabot>  0
20:31:34 <LordBrain> i also believe if i recall correctly, that according to haskell 98, an Int is only gauranteed to be at least 20 bits wide
20:31:59 <LordBrain> did 2010 update that?
20:45:56 <EvanR> LordBrain: The finite-precision integer type Int covers at least the range [ - 2^29, 2^29 - 1]
20:46:10 <EvanR> says haskell 98 report
20:50:01 <LordBrain> okay, i must be recalling some other integer type or some other standard then?
20:50:30 <LordBrain> java maybe?
20:53:52 <Tendies> I need to parse a <p> tag, and after the <p> can be <b>...</b> or <i>...</i> but pair tags must be nested 
20:54:12 <Tendies> but i haven't the slightest clue how to write a parser capable of that
20:54:25 <LordBrain> i'd use haxml
20:54:27 <LordBrain> package
20:54:33 <Tendies> i can't use any packages
20:54:35 <LordBrain> ok
20:54:37 <LordBrain> oh
20:54:38 <Tendies> or imports
20:54:39 <LordBrain> homework?
20:54:42 <Tendies> yeah
20:54:44 <EvanR> you could 1) check out a combinator parser library like parsec or 2) check out an html parsing library that does it for you
20:55:02 <EvanR> or 3) invent parser combinators yourself
20:55:13 <LordBrain> he can only do 3, as he's not alowed to use imports even
20:55:16 <Tendies> any similar problem would help
20:55:38 <EvanR> Tendies: http://www.willamette.edu/~fruehr/haskell/seuss.html
20:56:20 <Tendies> the prof used that quote
20:57:27 <Tendies> how do i write any parser combinator like that
20:57:48 <johnw> Tendies: parse = symbol "<p>" *> parseBody <* symbol "</p>"
20:58:00 <johnw> where parseBody allows text intermixed with <b>..</b> tags, etc.
20:58:21 <Tendies> say it gets to a <b> tag, does it call another parser?
20:58:22 <johnw> you just arrange the parsing hierarchical in terms of what is allowed, the way you would with a regular recursive descent parser
20:58:29 <johnw> sure
20:59:23 <Tendies> i've never written a recursive descent parser, all we've even covered up to now is really simple ones
20:59:54 <LordBrain> he doesnt even have applicative johnw
21:00:06 <LordBrain> if i understand right, he is limited to the prelude
21:00:11 <orzo__> applicative is in prelude now
21:00:17 <LordBrain> oh good point
21:00:23 <Zemyla> Alternative and MonadPlus aren't.
21:00:33 <Zemyla> Which makes it rather difficult.
21:00:49 <Tendies> oh i'm allowed this file that uses Data.Char, Control.Applicative, Control.Monad
21:01:09 <Tendies> and has a couple of parsers like many, satisfies, failure, (+++)
21:01:20 <Zemyla> Anyways, the simplest parser combinator has the type of ReadS.
21:01:34 <Zemyla> ReadS a = String -> [(a, String)]
21:02:34 <Tendies> ReadS? parser combinator? ,_,
21:03:04 <Zemyla> Well, actually, an even simpler one has the type String -> Maybe (a, String).
21:03:42 <adelbertc> StateT
21:03:51 <Zemyla> It's basically StateT Maybe, yes.
21:04:03 <Tendies> i have a Parser type that is like, test :: Parser Bool that returns [(True,"uneaten input")]
21:04:30 <Tendies> or whatever type follows Parser is in fst(head( )) of output
21:05:06 <Tendies> the problem is inside the do notation, how do i call other parsers conditionally
21:06:16 <Zemyla> Tendies: Do you have the Monad instance written for it?
21:06:32 <Zemyla> And do you have a MonadPlus instance?
21:07:51 <Tendies> i don't know exactly but here's part of the Parsing.hs file i get to use http://lpaste.net/158293
21:08:00 <Tendies> it seems there's a Monad instance written
21:08:27 <adelbertc> you can branch in the `>>=`
21:08:55 <adelbertc> someParser >>= (\result -> if p result then parserA else parserB)
21:09:10 <adelbertc> where p :: result -> Bool
21:27:49 <tailgate> If I have a function that just calls an IO monad with MapM_, what is it's return type?
21:28:47 <dmj`> :t \f xs -> mapM_ (f :: a -> IO ()) (xs :: [a])
21:28:50 <lambdabot>     Couldn't match expected type ‘a -> IO ()’ with actual type ‘r’
21:28:50 <lambdabot>       because type variable ‘a’ would escape its scope
21:28:50 <lambdabot>     This (rigid, skolem) type variable is bound by
21:29:05 <EvanR> :t \f x -> mapM_ f (return x)
21:29:06 <lambdabot>     Could not deduce (Foldable t0) arising from a use of ‘mapM_’
21:29:06 <lambdabot>     from the context (Monad m)
21:29:06 <lambdabot>       bound by the inferred type of
21:29:15 <dmj`> :t mapM_
21:29:16 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
21:29:59 <EvanR> youll need to clarify your question somehow
21:30:19 <dmj`> :t \(f :: a -> IO ()) (xs :: [a]) -> mapM_ f xs
21:30:20 <lambdabot> (a -> IO ()) -> [a] -> IO ()
21:38:17 * hackagebot t3-game 2.0.0 - tic-tac-toe core  https://hackage.haskell.org/package/t3-game-2.0.0 (jxv)
21:38:22 <gibbigg> first time here: can someone point me to a place to learn how things work?
21:39:31 <JuanDaugherty> what things?
21:41:47 <JuanDaugherty> http://learnyouahaskell.com/ is always a good start in general, maybe the wikipedia article
21:42:07 <django_> gibbigg, https://github.com/bitemyapp/learnhaskell
21:45:58 <gibbigg> Thanks ppl, I meant more like what kinds of questions/discussions occur here and what level of haskell is assumed? 
21:46:34 <gibbigg>  I've gone though most of LYAH and am reading a bit of 'A Gentle Introduction to Haskell 98'
21:47:08 <hjulle> Any level of hakell is ok.
21:47:27 <JuanDaugherty> this is the general haskell channel
21:48:21 <JuanDaugherty> it's publicly logged, in the topic I think
21:48:30 <systemfault> Any level is fine but you can also ask questions in #Haskell-Beginners
21:51:00 <gibbigg> Ah ok, thanks
21:51:12 <hjulle> Is there a way to search for hackage packages sorted by popularity?
21:51:24 <django_> whats a program i can build
21:59:56 <ertes> django_: what do you mean?  are you looking for a project to get started with haskell?
22:03:15 <gibbigg> django_: thanks for the github link, it seems quite useful
22:04:14 <micahf> anyone familiar with functional programming in python?  i asked on the python channel but i am getting crickets
22:04:18 <hjulle> ertes: My guess is just looking for a project to do in general.
22:04:32 <micahf> and if not here, where's a good place to ask about functional programming in general?
22:04:51 <JuanDaugherty> #haskell, #lisp
22:04:55 <JuanDaugherty> #ocaml
22:05:27 <micahf> so there is not a #functionalprogramming channel then :)
22:05:28 <ertes> micahf: i think it's pretty safe to ask, since you clarified why you're asking here
22:05:31 <JuanDaugherty> others like that
22:05:53 <ertes> micahf: we do discuss FP and even paradigms in general sometimes
22:07:29 <hjulle> Last time asked about functional programming on #python, people said that it is not very well suited for FP. (I do not remember what motivations were given)
22:08:20 <Gurkenglas> Does fgl have REACH implemented somewhere?
22:10:30 <EvanR> micahf: an interview where guido van rossum explains why FP sucks https://developers.slashdot.org/story/13/08/25/2115204/interviews-guido-van-rossum-answers-your-questions
22:10:34 <ertes> hjulle: FP in python is like FP in PHP: you can't use recursion or CPS freely, you can't implement data structures sensibly (no ADTs, verbose syntax), and there are almost no useful helpers built in
22:11:02 <Rotaerk> hjulle, some languages, including python, have functional programming elements... but FP is sortof a system of ideas that play off of each other, and taking one of those things in isolation, it loses a lot of its value
22:11:13 <ertes> hjulle: guido van rossum stated that python will not support FP very well in the future either (i'm not going to quote his exact words)
22:12:53 <jle`> i think he has made it a specific point to discourage FP in the design of python
22:13:18 * hackagebot t3-server 0.2.0 - tic-tac-toe server  https://hackage.haskell.org/package/t3-server-0.2.0 (jxv)
22:13:20 * hackagebot t3-client 0.2.0.0 - tic-tac-toe Rexports for client  https://hackage.haskell.org/package/t3-client-0.2.0.0 (jxv)
22:13:59 <micahf> I'm trying to do something very basic.  I have two classes with an isomorphism between them.  I just want to make a new type that smoothly uses functions from both classes
22:14:17 <EvanR> in the interview, he mentions haskell, mentions he doesnt know much about FP really, and then shits on purity
22:14:19 <micahf> it's proving to be annoying
22:15:32 <ertes> micahf: if they are isomorphic, you could just declare one of the types "primary" or even try to merge them
22:15:35 <EvanR> you can make a type that implements two classes pretty easily
22:15:52 <EvanR> ertes: figure out what isomorphic classes means
22:16:34 <micahf> EvanR: yeah I tried going this and got some weird errors about metaclasses
22:16:55 <ertes> EvanR: well, if you're going there, then all python classes are isomorphic to each other, because they are all just HashMap String Dynamic =)
22:17:42 <ertes> but that's probably not very helpful, so i'll assume that micahf thinks of classes more as product types with accompanying functions
22:18:24 <EvanR> metaclasses?
22:18:29 <micahf> "metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases"
22:18:36 <EvanR> wait
22:19:06 <django_> ertes, i think python 
22:19:16 <EvanR> i need to go to bed i dont know how i ended up downtown in the python channel
22:19:55 <micahf> haha sorry
22:20:14 <ertes> i can't make sense of that error message, sorry…  my python skills are minimal
22:20:46 <micahf> it's cool, thanks for the shot though
22:21:09 <EvanR> metaclass of non-meta strictclass of a submeta metabase
22:21:15 <ertes> it sounds like the technobabble i would expect from a star trek voyager episode =)
22:21:46 <Rotaerk> someone say something about metatron?
22:22:21 <Tendies> how would you map  (++x) onto a list, where x is [0..]?
22:22:28 <EvanR> maybe you should try GHC, the error messages might make more sense
22:23:05 <ertes> Tendies: if "map (++ x)" is not the correct answer, try to rephrase your question without using the word "map"
22:23:23 <EvanR> :t map (++x)
22:23:24 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Expr’
22:23:24 <lambdabot>     In the second argument of ‘(++)’, namely ‘x’
22:23:24 <lambdabot>     In the first argument of ‘map’, namely ‘(++ x)’
22:23:29 <Tendies> i have map (++x) (replicate 5 "x^") but i cant see where i'd use something like [ x | x <- [0..] ]
22:23:33 <EvanR> :t map (++[0..])
22:23:34 <lambdabot> (Enum a, Num a) => [[a]] -> [[a]]
22:24:27 <ertes> Tendies: if x would be something more complicated, you could use 'let' or 'where'
22:24:43 <Tendies> > map (++[0..]) ["a","b","c"]
22:24:44 <lambdabot>      No instance for (Num Char) arising from the literal ‘0’
22:24:45 <lambdabot>      In the expression: 0
22:24:45 <lambdabot>      In the second argument of ‘(++)’, namely ‘[0 .. ]’
22:25:07 <ertes> Tendies: you're trying to append a list of numbers to lists of characters
22:25:21 <ertes> Tendies: what's the result you want?
22:25:48 <Tendies> in the example there, i wanted ["a0","b1","c2"]
22:25:57 <ertes> Tendies: then you need zipWith
22:26:47 <Tendies> so like, zipWith (++[0..]) xs ?
22:26:47 <ertes> :t zipWith
22:26:48 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
22:26:59 <ertes> Tendies: nope…  look at the type
22:27:22 <ertes> a = String, b = Integer, c = String
22:27:39 <EvanR> 0 ++ "0" is a type error
22:27:54 <EvanR> an error i tell you!
22:28:32 <hjulle> micahf: Have you tried googling the error message? There are plenty of interesting articles that can explain it.
22:29:11 <Tendies> EvanR: ok how do i combine them?
22:29:40 <ertes> Tendies: zipWith (\name num -> _combine) names [0..]
22:29:59 <ertes> you need to write _combine, which i'll leave as an exercise
22:30:29 <ertes> one hint though: you can go from numbers to strings using 'show'
22:30:36 <ertes> > show 15
22:30:38 <lambdabot>  "15"
22:31:09 <Tendies> combine is to combine num with name?
22:31:28 <ertes> yes…  zipWith combines the two argument lists by applying your function to each pair of elements
22:33:18 <micahf> hjulle: yeah, but I think the issue is that there are multiple ways to do this in python and I don't know if I"m barking up the right tree or not
22:33:27 <micahf> hjulle: meanwhile I did find this: https://github.com/dbrattli/OSlash/wiki/Functors,-Applicatives,-And-Monads-In-Pictures
22:33:37 <micahf> hopefully it will help
22:33:45 <micahf> basically I'm just trying to do a monad
22:34:39 <ertes> micahf: with the little context we have i'm not totally sure, but the problem you described doesn't sound monadic at all
22:34:50 <ertes> the only algebraic component is the isomorphism part
22:34:50 <Tendies> :t getNum
22:34:51 <lambdabot>     Not in scope: ‘getNum’
22:34:52 <lambdabot>     Perhaps you meant ‘getSum’ (imported from Data.Monoid)
22:36:02 <ertes> Tendies: if you need more help, feel free to tell us
22:36:17 <Tendies> i got that bit working, thanks
22:36:21 <Tendies> and will do
22:36:22 <micahf> ertes: why not?  I'd like to lift a Graph object into its Matrix representation, do the Matrix stuff, then retract it back as a Graph again, isn't that monadic?
22:36:31 <EvanR> nope
22:36:58 <ertes> micahf: i don't see a monadic pattern there
22:37:21 <EvanR> you have a bijection between graphs and matrixes
22:37:25 <EvanR> thats it
22:37:50 <micahf> maybe i'm thinking of applicatives and calling them monads
22:38:01 <EvanR> dont think so
22:38:19 <ertes> micahf: i think you're thinking of isomorphisms and calling them monads =)
22:38:24 <Tendies> is there an opposite of show?
22:38:32 <ertes> Tendies: read
22:38:32 <EvanR> hide
22:38:40 <ertes> hehe
22:39:05 <micahf> ertes: i'm pretty sure I'm thinking of applicatives
22:39:20 <Tendies> like to take a string to the type the string is, like "[0,0]" becomes a list [0,0]?
22:40:07 <EvanR> graphs and matrices can do applicative stuff, but you havent described that situation
22:40:16 <EvanR> you just want to map between graphs and matrices
22:40:19 <ertes> micahf: if you're thinking of applicatives, that implies that you're thinking of functors…  do you see a functor pattern there?
22:40:31 <Rotaerk> Tendies, read "[0,0]" :: [Int]
22:40:36 <Rotaerk> Tendies, try that
22:40:43 <micahf> EvanR I just want to map between classes representing graphs and matrices
22:41:00 <EvanR> toMatrix :: Graph -> Matrix
22:41:06 <EvanR> fromMatrix :: Matrix -> Graph
22:41:24 <Tendies> could i apply that to a char i got as input and use it as an argument in take?
22:41:41 <micahf> so for example, Matrix has a function Matrix.transpose()
22:41:45 <Tendies> it's complaining that the getChar char is locked inside the monad i think
22:41:52 <micahf> I want to get the transpose of a Graph
22:41:54 <Tendies> the IO type i mean
22:42:04 <micahf> but Graph.transpose doesn't exist
22:42:27 <EvanR> g.toMatrix().transpose().toGraph()
22:42:33 <micahf> yes
22:42:56 <EvanR> youre doing functional programming!
22:43:00 <micahf> yup
22:43:19 <micahf> what kind of functor is that
22:43:22 <ertes> micahf: it might be that the word "map" is misleading you into thinking that you're using an applicative pattern…  the closest you get to using an algebraic pattern is that you're actually using an isomorphism lens
22:43:38 <ertes> micahf: what you're doing in actuality is simply functional programming =)
22:43:42 <ertes> no fancy patterns at all
22:43:50 <cocreature> Tendies: you might want to read http://www.vex.net/~trebla/haskell/IO.xhtml the short answer is use >>= or do notation or fmap
22:44:12 <Lokathor> wreq is horrible and i don't understand any of it >:(
22:45:13 <EvanR> id call it using the wrong representation
22:45:45 <micahf> I'm thinking of functors
22:46:20 <EvanR> it doesnt make too much sense because youd have to have a category matrices and a category of graphs
22:46:24 <ertes> micahf: Matrix forms a functor and an applicative by allowing you to map over the elements
22:46:39 <ertes> micahf: but you're transposing, which is not an applicative pattern
22:50:13 <EvanR> you should make all the operations available on both classes and when necessary implement it by converting to the other one, then youll get your smoothness
22:50:47 <EvanR> though itll be kind of inefficient
22:51:18 <micahf> EvanR: yeah, that's what I'm gonna end up doing.  I don't care too much about efficiency, I'm doing small symbolic stuff
22:51:26 <EvanR> in the classic "rectangular vs polar" implementation of complex numbers, at least when it wants to convert, it returns a thing of the same Complex type
22:51:48 <EvanR> so repeated multiplication will be on polar
22:52:59 <ertes> the equivalent in OO is subclassing, so you can get some of the convenience
22:53:18 <EvanR> how would subclassing help
22:53:56 <EvanR> oh, any given thing would be subclass of "GraphOrMatrix"
22:54:03 <EvanR> which is silly :(
22:55:04 <ertes> that's why i suggested making one of the representations "primary" and the other one "auxiliary", so you get only two classes instead of three
22:55:07 <EvanR> what you can do instead is have just the Graph class and it is implemented with a matrix internally
22:55:19 <ertes> it's ugly, but i don't think there is a nicer way to solve it with OO
22:55:26 <EvanR> ^
22:55:35 <micahf> I think something that I am not being clear about is that these classes are already implemented
22:55:42 <micahf> they are from sage
22:56:00 <EvanR> ah well
22:56:09 <micahf> that's why I'm thinking of functors and applicatives
22:56:17 <micahf> because there are a bunch of existing functions
22:56:36 <ertes> micahf: has python with its HashMap String Dynamic typing (a.k.a. "duck typing") something similar to C++ multiple inheritance?  if yes, you could probably do it with a hack
22:56:45 <ertes> micahf: alternatively you could write wrapper classes
22:56:49 <EvanR> you should learn what functors and applicatives actually are, itll probably help in the future
22:57:15 <Tendies> i read that article on IO but i dont really see how to convert a number obtained from getLine into an actual Int
22:57:31 <EvanR> :t read
22:57:32 <lambdabot> Read a => String -> a
22:57:34 <micahf> EvanR: I don't think I'm that far off about functors and applicatives, it's just that I called them monads at first
22:57:37 <ertes> Tendies: fmap read getLine
22:57:49 <ertes> :t readIO
22:57:50 <lambdabot> Read a => String -> IO a
22:57:55 <ertes> or even that
22:58:03 <cocreature> you can’t convert it to an Int, but you can use it as an Int and then return an IO something
22:58:26 <ertes> micahf: algebraic patterns have the extensibility property you'd like…  but you can't stick on the pattern post-hoc
22:58:59 <Tendies> say i want to use the Int value as a parameter and return nothing 
22:59:16 <cocreature> parameter for what?
22:59:18 <EvanR> micahf: no, lets say you have a graph of Ts, and a function from T to U, you can use "functor" to convert it to a graph of Us
22:59:24 <ertes> micahf: but honestly the easiest way seems to be to simply write conversion functions
22:59:31 <Tendies> lets say for `take`
22:59:33 <EvanR> thats not waht youre trying to do
22:59:56 <Tendies> i want to take an inputted number of elements from [0..]
23:00:05 <Tendies> * i know thats not a word
23:00:20 <ertes> Tendies: are you familiar with do-syntax?
23:00:59 <cocreature> :t (getLine>>=)
23:01:00 <lambdabot> (String -> IO b) -> IO b
23:01:12 <Tendies> kind of, i have the input as thenum <- getLine
23:01:21 <Tendies> in a do 
23:01:23 <cocreature> then thenum has type String
23:01:24 <ertes> Tendies: within a do-block you can give names to the results of the individual IO actions:  do line <- getLine; let num = read line; ...
23:01:51 <Tendies> yeah i have a name for it, but trying to use that name as an argument to a function isn't working
23:02:07 <Tendies> oh
23:02:27 <Tendies> so just read thenum :: Int
23:02:36 <ertes> yeah
23:02:58 <ertes> if it's an argument to 'take', you don't even need the type signature, because it's inferred to be Int
23:03:00 <ertes> :t take
23:03:01 <lambdabot> Int -> [a] -> [a]
23:03:20 <Tendies> > read "5"
23:03:21 <lambdabot>  *Exception: Prelude.read: no parse
23:03:33 <Tendies> >read "5" :: Int
23:03:34 <ertes> > take (read "5") "abcdefgh"
23:03:35 <lambdabot>  "abcde"
23:03:41 <mrm> How extensible is haskell's reader?
23:03:45 <geppettodivacin> > take (read "5") "abcde"
23:03:46 <lambdabot>  "abcde"
23:03:48 <Tendies> > read "5" :: Int
23:03:50 <lambdabot>  5
23:04:08 <ertes> mrm: "reader"?
23:04:24 <EvanR> > read "()"
23:04:28 <lambdabot>  ()
23:04:44 <mrm> The thing that turns strings into an AST.
23:05:08 <EvanR> it turns strings into data
23:05:19 <ertes> mrm: you can write readers for all types, and for many ADTs you can derive the reader
23:05:23 <cocreature> are you talking about the parser in GHC or about read?
23:06:32 <mrm> Like, if I don't like haskell syntax, is it relatively easy to write a different reader that just dumps the same ast to the compiler?
23:08:41 <ertes> mrm: a reader is any function from a string to maybe the target type, so you can write any parser you like
23:09:15 <ertes> mrm: however, if we can, we prefer Read and Show instances to agree on the syntax
23:10:20 <EvanR> no hes asking how hackable ghc is
23:10:54 <ertes> oh
23:12:04 * ecemm sex video https://www.youtube.com/watch?v=4ehJrXd6QMs
23:13:05 <cocreature> I think you can feed core to ghc via the API somehow, so you could write an alternative frontend
23:13:06 <mrm> Sorry, I'm coming from racket/scheme etc, and am interested in whether it's possible to write a macro expander targeting haskell.
23:13:17 --- mode: ChanServ set +o johnw
23:13:26 --- mode: ChanServ set +o johnw
23:13:35 <adelbertc> template haskell?
23:13:36 <EvanR> there is template haskell which gives you a lot of control over generating haskell source code
23:13:50 --- mode: johnw set -o johnw
23:15:28 <mrm> Is that privileged by the compiler, or is it made by some sort of extensible compiler plugin thingy?
23:16:04 <EvanR> its available through a language extension
23:16:42 <EvanR> TH is evaluated into declarations, types, expressions etc during compile time
23:16:55 <mrm> Is that like a different compiler, or some sort of plugin to ghc?
23:17:01 <EvanR> and it can do IO at that time so... it can basically do anything
23:17:12 <EvanR> its all in GHC
23:17:36 <EvanR> its a feature you have to activate with a pragma or flag
23:17:47 <cocreature> are you trying to compile racket using ghc?
23:18:13 <EvanR> racket quasiquoter ;)
23:18:16 <mrm> Something like that.
23:18:57 <cocreature> your best bet in that case is probably to generate core, but that’s still strongly typed so you’ll have to do quite a lot of work to get the untyped part of racket there
23:19:19 <EvanR> you just use a sum type for the lisp type universe
23:19:42 <cocreature> yeah that could work
23:19:51 <EvanR> or add types to your lisp!
23:20:00 <mrm> I'm not interested in compiling racket per se. More like some nice s-expr type thing I could build a set-of-scopes expander on top of.
23:20:07 <cocreature> mrm: here are the docs for the ghc api https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/index.html
23:21:48 <Tendies> is there for .. in in haskell?
23:22:09 <Tendies> like i want to do an io action for each element in a list (cant use forM though)
23:22:21 <cocreature> Tendies: why can’t you use forM?
23:22:46 <Tendies> i'm limited to prelude
23:23:05 <EvanR> heh... you could look up the source to forM
23:23:11 <cocreature> mapM is flip forM and is in prelude :)
23:23:14 <cocreature> :t mapM
23:23:15 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
23:23:16 <cocreature> :t forM
23:23:17 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
23:23:32 <cocreature> you’ll just have to swap your arguments or use flip
23:24:13 <Tendies> lol how'd that result? is there some good use for same thing but different arg order
23:24:30 <mrm> cocreature: Thanks
23:24:33 <cocreature> mapM is similar to map so that’s nice
23:24:37 <EvanR> yes because of partialing
23:24:49 <cocreature> but if you have a long function and don’t want to separate it forM is nicer
23:25:22 <Tendies> so i put the lambda first is all?
23:25:34 <cocreature> or any other function it doesn’t have to be a lambda
23:26:00 <Tendies> hmm for readability i think i need to use flip
23:26:14 <Tendies> > flip "a" "b"
23:26:15 <lambdabot>      Couldn't match expected type ‘a -> [Char] -> c’
23:26:16 <lambdabot>                  with actual type ‘[Char]’
23:26:16 <lambdabot>      In the first argument of ‘flip’, namely ‘"a"’
23:26:34 <cocreature> :t flip
23:26:35 <Tendies> > flip take "abc" 2
23:26:35 <lambdabot> (a -> b -> c) -> b -> a -> c
23:26:36 <lambdabot>  "ab"
23:26:39 <EvanR> if the question seemed to require you to do forM, but said you cant use forM, it probably should have said you cant use mapM ;)
23:27:11 <EvanR> if the question said implement forM then... i guess flip mapM works but seems trivial
23:27:11 <Tendies> there's nothing so rigid in the problem, i just saw that forM seemed like what i needed then realized that needs an import
23:27:13 <cocreature> not sure about that, a lot of times you are simply not allowed to import anything
23:27:39 <cocreature> I have an exam in a few days and we are only allowed to use the modules in Haskell2010
23:27:41 <cocreature> restrictions are weird
23:28:50 <EvanR> three stars, implement merge sort without using recursion
23:30:31 <cocreature> EvanR: that’s easy, I’ll just use the ffi and for loops and manually build a stack data structure
23:31:01 <EvanR> lol
23:31:09 <EvanR> foiled again
23:31:17 <ertes> import Data.List (sort); mergeSort = sort
23:31:40 <EvanR> sort uses recursion
23:31:51 <ertes> every list sorter uses recursion
23:32:03 <EvanR> in haskell 
23:32:11 <cocreature> that’s why I’ll use the ffi :)
23:32:57 <ertes> so recursion is disallowed, but recursion in disguise is allowed?
23:33:17 <EvanR> while loops arent exactly
23:33:28 <EvanR> recursive
23:34:06 <ertes> myWhileLoop x | p x = myWhileLoop (f x) | otherwise = x
23:34:13 <LordBrain> who is disallowing what?
23:34:33 <EvanR> obama
23:34:38 <LordBrain> always obama...
23:34:43 <cco> Does the fusion in `Data.Vector` not enable "shortcircuiting" in `V.take 10 $ V.enumFromN 1 99999`?
23:37:00 <LordBrain> let us know what you find out cco
23:37:36 <LordBrain> some thoughts come to me, but i am not confident enough to answer
23:40:00 <LordBrain> a vector in my understanding is contiguous memory like an array, so i'm not sure but it might all be allocated in one thunk, in which case, there wouldn't be any short circuiting expected there, am i wrong?
23:41:22 <LordBrain> i don't often make use of Data.Vector
23:43:07 <cco> I think you might be right. I guess should think of fusion as reordering work optimally rather than ever actually saving work?
23:44:25 <LordBrain> i think of fusion mostly this way, it means instead of map f . map g . map h $ xs you have one map using the composition, like so: map (f . g . h) xs
23:44:48 <LordBrain> i suppose it is more complex than that, but that understanding has been good enough for me so far.
23:44:59 <cco> Right, which I guess is not a performance panacea
23:46:39 <LordBrain> if you were to think in c, it means having one for loop instead of three
23:48:13 <lethjakman> Is there a way to use a case statement to match one case against multiple statements?
23:48:28 <lethjakman> Basically or them together. 
23:49:22 <LordBrain> guards
23:49:27 <LordBrain> pattern guards can do that
23:50:02 <LordBrain> case x of _ | x `elem` [3, 4,5] = 2
23:50:02 <lethjakman> Hrm, fair enough. 
23:50:27 <Lokathor> ireniko, lts control.monad
23:50:28 <ireniko> base-4.8.2.0: https://www.stackage.org/haddock/lts-5.5/base-4.8.2.0/Control-Monad.html
23:50:31 <Lokathor> hey look it does a thing
23:50:32 <lethjakman> Thanks. 
23:53:38 <LordBrain> that = should actuallly be a ->
23:53:47 <LordBrain> but you get it
