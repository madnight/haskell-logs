00:00:04 <Lovepon> Well..
00:00:08 <Lovepon> Welp.
00:00:28 <Lovepon> I get XhrException_Error. :(
00:06:48 * hackagebot persistent-template 2.5.1 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1 (GregWeber)
00:07:38 * hackagebot stateWriter 0.2.7 - A faster variant of the RWS monad transformers.  https://hackage.haskell.org/package/stateWriter-0.2.7 (SimonMarechal)
00:07:38 * hackagebot persistent-template 2.5.1 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1 (GregWeber)
00:12:37 * hackagebot witness 0.3.0.1 - values that witness types  https://hackage.haskell.org/package/witness-0.3.0.1 (AshleyYakeley)
00:17:55 <Lovepon> Errr.
00:18:07 <Lovepon> I'm so confused right now lol.
00:18:19 <Lovepon> Chrome tells me that I got a 200 OK.
00:18:47 <Lovepon> But react-dom says "Left XhrException_Error"
00:19:27 <Lovepon> Oh.
00:20:41 <Lovepon> XHR only works with XHTML. I see.
00:37:38 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
00:37:38 --- topic: set by quicksilver on [Wed Oct 07 07:39:51 2015]
00:37:38 --- names: list (clog solrize MrWoohoo tinkyholloway rhovland yellow_apple suls marr mistermetaphor takuan Reite oconnorct1 osa1 hackagebot lkba biglama Mikasa-1 nikolaMilj eklavya Argue splanch grouzen tag x77686d thiagofm schlicht Lisa1157 wei2912 chipf0rk wuch magneticduck1 ype Xe Purlox Quashie python476 herzmeister WhereIsMySpoon1 yfeldblum ireniko hackebeilchen firstdayonthejob thunderrd nshepperd Normen FreeBirdLjj t7 Lowl3v3l darkbolt JoshS nomotif kaictl_work baweaver)
00:37:38 --- names: list (v_g mzf dsm eb_ vlatkoB grassass fkurkows1 hk238 TOB1 acl_ dsantiago vili_ cdidd danhuynh______ Strout roconnor jpll WF-BATCH mfukar angerman forgottenone ertes ftop_ nkaretnikov krgn` tnks Beetny mounty Rotaerk_ athan curtis52 goodboy geekosaur chishiki saulzar cyphase tripped Goplat Rainb hexagoxel otto_s Sornaensis lspitzner exferenceBot Reshi aarvar homam pavlicek ics jerin a3Dman Johannes13 hucksy_ zopsi bd_ systemfault Wuzzy2 Moto-chan rootnode triliyn)
00:37:38 --- names: list (PatrickRobotham phileas hamishmack rcsgns_ jcdietrich cpup AndroidVaan Zekka binaryplease predator217 markus1189 darkf theorbtwo badon justanotheruser FreeFull perspectival s4msung timvisher AndreyG kalail Destol Nnotm dredozubov Jesin freekevin cross sevas ph88 dgpratt alunduil martinga_ l4m8d4 whaletechno gem jmct moei peddie fergusnoble pavonia guampa cyborg-one Vq doshitan Coldblackice_ Deadhand paf31_ rstone arnihermann yaknyasn micmus Tinchos micxjo kini)
00:37:38 --- names: list (shelf nkpart nbouscal louispan amingoia superfatkappa YP-Cloud__ qguv Tertain_ Kristler xelxebar ChongLi jb55 schnizzle zariuq Guest42079 Oejet vigs Fubar^ cyberlard marienz fangs124 robogoat Amnez777 Elision Raynes adlan simony mach fiddlerwoaroof fengshaun mrshoe Nimatek kakos sm dedgrant tristanp devol NeverDie amiri adelbertc M-davidar M-radix dmiles Azel johnzorn justicefries plutoniix etabot m0rphism codesoup ncl theduke hosttor polux dud augur mrvdb)
00:37:38 --- names: list (dmwit_ epta prkc garphy Quintasan mochi worch acton dcoutts_ iliastsi copumpkin dixie bencryption rofer cchalmers Caelum amiller jknick Majiir selckin Nahra jophish bind nisstyre_ petercommand jtobin Jonno_FTW poga mingc marmalodak moop araujo Athas averell afcondon_ howdoi Skuzzzy lonokhov indiffernet erikd jud Sonderblade monochrom Jinxit enolan opqdonut xinming pfeyz crodjer CaptainLex klugez jimki ppnkk fingerzam1 XMunkki tromp__ bb010g kalloc ollef)
00:37:38 --- names: list (mitchty edwtjo_ pharaun metaf5 tumdum mendez ph88_ mattp_ fractalcat sinopeus Lemmata yrdz drbean CindyLinz dented42 Guest4966 fmope_ dibblego uwap LordDeath dunj3 conal albel727 josephle kosorith bluepixel __name__ eldon tippenein kolmodin OnkelTem catsup c_wraith ljhms marens jokleinn wedify jackhill Can_Not ibid jonaias statusbot chattered crank1988 canta mikeplus64 Draggor zrl_ chris2 caasih ajmccluskey henriquev__ Sorella edwardk trig-ger_ johtso ortmage)
00:37:38 --- names: list (MoALTz leather FMJaguar lokien dario callumacrae cantstanya mbrcknl wyvern eyenx mirsal clion lpsmith eyck TRManderson hemite seagreen surtn joco42_ StoneToad Edoxile bshelden briansmith coup_de_shitlor- frelux hiratara mimi_vx loli-pyon Natch tolt____ zuz_ Guest54448 hansihe cdk_ tlevine cjh`_ hvr Ezku_ lurker6_ arkarth_ ali_bush_ Lord_of_Life PotatoGim KorriX_ karls M-ou-se schjetne_ wedens MaienM_ aaron7 quicksilver s_e ackthet Laney davl SLi themagician)
00:37:38 --- names: list (mjo psacrifice thimoteus Madars_ RageD nitrix ricardo82 esssing hegge bizarrefish vodkaInf1rno luigy dustinm Guest47170 staffehn gbarboza myme Sam_ harmchop fall__ kadoban RazorX- AntiSpamMeta swhalen acertain Cale pacak godel kolko betawaffle andrewsw Soft Lokathor Schrostfutz Bashmetim kevinyings aod CosmicRay MarcelineVQ staticfox tv mpereira tobiasBo1 code_crimes_ wailord cleamoon svp_ wolfcore Freundlich orion pelegreno elementalest Internet13 LadyClaire)
00:37:38 --- names: list (nrw luzie castlelore magbo tsani Guest94785 jdt jedws mountaingoat dolio Reyu newsham arkeet dreamdust nekomune Ranhir dpk-atk vic_ jcurbo unsymbol relrod M-Illandan hydraz zerokarmaleft pieter binocvlar wagle Ke saurik nakal1 cods raek linduxed knyppeldynan dino- Chunlea Polarina heurist huonw acro nathanic SaidinWoT CurryWurst abrar theDon verement Deewiant zaquest Wamanuz cognominal Bane^ rossberg Nux_ Sgeo_ magthe ramatevish [swift] zerowidth slomo dalcde)
00:37:38 --- names: list (Kwoth Ralith gseitz cow-orker dh levi rwiggins obadz Khisanth Tourist dtulig tolt irclogger_com lispy Factionwars lyxia jgornick ido AustinMatherne apo_ Clint testclode mikecaruso gfixler wamaral dfranke coeus Tesseraction Tehnix troydm Nik05 hive-mind rotty abra0 cbm80 mero meretrix leadingthenet Simson-san PanicSkittle Maxdamantus Jello_Raptor MasseR sjl_ s4kashya vin-ivar tomku atomi jtcs Horv Chousuke bjobjo simpson bydo ec\ luis jlewis iross tomjaguarpaw)
00:37:38 --- names: list (strixy Black-Wolf nurupo jargon- tokik aleogen Thulsadum jorj jamiis nille deavid pfoetchen liff tusj Guest78801 shwouchk wtw MindlessDrone mj12`_ Lutin` igniting ndeine jokester kvieta abh Ulrar potatoe DigitalKiwi lachenmayer Belgarion0 klarrt davesilva jnoah Niamkik sbrg schmittlauch Rodya razi1 brt1 Ferdirand nobag jrslepak cgfbee drdo M-mistake M-david pdgwien djanatyn Cyrus \u epitron ReinH mindos_cloud____ mgaare d3lxa monty brixen Profpatsch kav)
00:37:38 --- names: list (leftylink kloeri Reisen amharc ClaudiusMaximus cfloare_ swistak35_ int-e fionnan_ Walther barrucadu z-nexx fmapE kungp SHODAN gnusosa_ irishsul1an Marqin ephemeron RevJohnnyHealey bitemyapp cYmen__ rvncerr CARAM__ pranzor NemesisD georgew sz0 srcerer carlw2 sisir__ capisce_ mudfog_ spill1 warc gienah avocado phadej acomminos watersoul xeno whiteline horlicks TheVoid noraesae ent Oxyd Cetusx Fullma matt- robertk riscool ahungry asjo TheMystic mw KeelOfSteel)
00:37:38 --- names: list (xplat chrzyki dicioccio keix mniip Adeon ironChicken timrs2998 Slush- maartenpi pmade hausdorff _janne jzl kier t0mb0_ dcoutts solatis Philonous bbee m1dnight_ majjoha Xandaros vqrs_ owa armlesshobo ggVGc chitech_ Eliel_ ]OLI[ bsima Igloo dpower da-x Pucilowski quaestor1 Maerten_ mlhmwglt Cathy sword_smith xintron tomaw moredhel taksuyu sleezd Twey guios FledRebel bernalex ft dschoepe stux|RC-only octo- qnix_ seliopou tumdedum lf94 earthy pnutus chu jrp6)
00:37:38 --- names: list (maerwald hpd Ravana x1n4u zomg MitchW Amadiro bounb avn niluje KaneTW lattenwald Eagle_Erwin brisbin kantokomi statusfailed pydave6367 alk robtaylor Ov3rload marmoute chrismytton Xack d-snp Taylor bgamari joehillen chaptastic mrd Intensity yorick DDR dogui asm89 FUZxxl spwhitt hpc ocharles_ adamCS Paks kaictl Zemyla pleiosaur lokydor Tene myfreeweb Kahva quuxman sewilton obiwahn xaimus tero- arianvp Voldenet davean inr urdh OutlawStar martinbjeldbak)
00:37:38 --- names: list (fr33domlover dzackgarza GHCI bogdanteleaga hodapp _ashbreeze_ flux _6a68 M-Quora lassulus tdammers majoh Hafydd rtur zenzike v45h chirpsalot ernst mauke Chobbes horatiohb infinity0 catern vincenz mak` malthe Boney haasn andreass liyang joshc dan64 scopedTV mads- Ongy ski tek0 Kneiva nilOps connor_goodwolf Bez_ mudfog Akii squimmy kipras GGMethos xa0 t00m0 Kavec Biohazard_ Tamini nesqi pikajude sbauman zeroskillor lstrano_ ThePhoeron_ jix_ capicue siddhu)
00:37:38 --- names: list (Ariadeno_ zxtx Arch-TK sLite_ BillyIII_ Saizan_ fboyer codebje_ hanDerPe1er alexlord qnikst_ solidus-river tswett RayNbow`TU LeaChim glckr_ hiredman zhulikas_ dqd brennie_ luite_ Keikran_ Lovepon supki benjamin1rom richi235 PierreM_ scshunt SphericalCow kshannon_ l3france_ marcel monkeyiqde marko__ shadowdao padre_angolano dwynwen_ddlleyw Baughn xou litriv_ ahihi slick opios gabiruh nolrai cjay sivs_ mvr_ bgyss_ jgertm ryoia kipd arrdem cbaines kyagrd spinda)
00:37:38 --- names: list (OliPicard Adios solidsnack clever groovy2shoes keemyb WizJin pointfree Qommand0r MrRacoon derpderp mceier Watcher7 Meow-J julm vifon qz downtime tommd mokus cursork nikola Ankhers whoops gpampara suppi runeks logcat toure_ Saimeidae condy RaitoBezarius hc sunfun noctux hongminhee abbe alang nicola orzo kyren __main__ Ornedan _flow_ Rembane alevy jinblack telser nyuszika7h dilinger tortal sohum sea-gull codehero etcinit cstrahan borkdude carter funfun {AS})
00:37:38 --- names: list (minad sephiap jonrh bedouin keteim milessabin nyandoge xnyhps bartavelle killtheliterate nemesit|znc icedev cnr niteria anoe grol_ Tritlo sparr usr joedevivo avdi stass imalsogr` nopf Blkt mt ByronJoh1son folsen Iceland_jack xplat|work icicled raid impure_hate Boreeas benonsoftware besenwesen gregf_ mnoonan andjjj23 sanitypassing tazjin magicman thebnq sqrt2 tgeeky S11001001 dkua felher danieli stelleg lambdabot phaskell chelfi thorkilnaur_ iphy nullFxn)
00:37:38 --- names: list (gridaphobe M2tias joachifm Diabolik TimWolla max-m sdboyer BigEndian Morgawr lucz Hijiri oherrala dxld exio4 ploop byorgey gdsx sdx23 sternenseemann jbalint lyddonb alpounet Jaak julienXX Geekingfrog yminsky stomp mathu saiam Willis zyoung johnw Liskni_si osfameron sujeet dju jorendorff pyrtsa `0660 joeytwiddle tessier Gothmog_ spaceships alem0lars Cr8 felixsch vikraman oberstein pikhq u-ou jre2 Klumben SenpaiSilver skarn Forkk phuu Xorlev bitonic mno2 ps-auxw)
00:37:38 --- names: list (bananagram happy0 cjwelborn kjnilsson cynick xacktm MK_FG hbar tjbp SolarAquarion idupree Cerise spion Vbitz Frankablu jedavis cschneid_ wolf_moz- carter-znc pi____ andreas313 optocoup1er Bigcheese SegFaultAX mrlase pm52 DustyDingo yusukesuzuki niko spacebug zymurgy kishar gniourf andromeda-galaxy bsmt jaaket a6a3uh tristero benzrf doubling kosmikus cmn angseus_ kaol cheater dkibi_ tuple_cat noam_ bengt_ alphonse23_ tarcwynne_ Scorchin reem jstimpfl1 shachaf)
00:37:38 --- names: list (notdan shwouchkster trevorriles lexi-lambda mpickering thoughtpolice dstockwell beckyconning_ mankyKitty jroesch_ buoto ggherdov seanparsons jlyndon chriswk fuziontech electrostat yamadapc kmicu shennyg aleator smoose arw fryguybob viaken aweinstock anachrome noplamodo_ hyPiRion jotrk Desoxy goldfire lanodan nathyong sgronblo_ sphalerite pdxleif koomi k3d3 defanor Guest34040 heath koala_man __rlp ziman obcode_ ario radge__ jcp etrepum adamh Taneb luxbock_ Xnuk)
00:37:38 --- names: list (Kaini_ brassel Dykam_ taruti takeey vikram_________ otterdam Moyst LoganG zimp ephess_ stevenxl dalmahal mmaruseacph2 negatratoron Ewout DrCode stoned rbocquet Plastefuchs emiliocobos ion elgot greeny__ ethercrow jcreekmore askarpo CIA Axman6 codedmart geal kwantam wrengr_away zmanian__ amatecha pchiusano orcus caw teeteewhy agrif pootler_ carc Enigmagic rom1504 AlainODea drewdavis acfoltzer integral Tiktalik cocreature minsky wjm mikeizbicki jfokkan__)
00:37:38 --- names: list (loopspace gcollins mephx tekacs jameseb spicydonuts shelling__ Elsi incomprehensibly banjiewen codebam nak stephe_ wizonesolutions sclv zph_ si14 ikke TabAtkins bsermons SoupEvil omilu jessicah frontendloader TommyC lujan sajith burp ixian sellout zudov dysfun zpconn__________ gsingh93 numberten lukky513 shans_ Guest33283 tjpeden greymalkin magically ddima_ giraffe telmich Sigyn joeyh thallera1 Fylwind maskd chipb przembot stasku____ fabianvf bkolera Eiam)
00:37:38 --- names: list (rikkus_ dpn` pkogan_ aristid andreypopp__ friden squisher eL_Bart0 Mandus gargawel comboy katymoe bigs fyolnish Ashy Jaxan ircbrowse lieven jkarni liszt japesinator tych0 Tristan-Speccy aatxe Atlanis dxtr d6e posco okek deni tg prooftechnique gothos cosban EvanR mrowe julmac reynir noexcept lpaste bergmark xxpor karshan lancetw naudiz case39 bcoppens knittl ManiacTwister amontez srhb o`connor lenstr demize vishesh dasmith91 brolin_empey shteou BrianHV nek0)
00:37:38 --- names: list (SuperTux88 alanz cin bjs tzaeru Guest26166 mxf DANtheBEASTman liste JPohlmann Erebe capablanca gratimax coddinkn kennyp larsen phz_ lnx PHO sleepynate fold4 low-profile isomorphismes yarou ahf froztbyte honkfestival Drezil wting kjanosz yeltzooo Starfire aparent eagleflo archaic jlouis Shandy wayne Speed Ring0` so eikke @ChanServ thomas)
00:42:38 * hackagebot hylogen 0.1.0.10 - an EDSL for live-coding fragment shaders  https://hackage.haskell.org/package/hylogen-0.1.0.10 (sleexyz)
00:42:40 * hackagebot open-witness 0.3.1 - open witnesses  https://hackage.haskell.org/package/open-witness-0.3.1 (AshleyYakeley)
00:47:38 * hackagebot persistent-template 2.1.8 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.8 (GregWeber)
00:59:41 <dsm> is there any function like unzipM :: Monad m => [m (a, b)] -> m ([a], [b])?
01:01:57 <dolio> @type mapAndUnzipM id
01:01:58 <lambdabot> Monad m => [m (b, c)] -> m ([b], [c])
01:02:39 <dsm> wow
01:02:43 <dsm> thank you
01:07:17 <anoe> chunkAlong :: Int -> Int -> [a] -> [[a]]
01:07:17 <anoe> chunkAlong a b l = map (take a) $ takeWhile  (\x -> length x >= a) $ scanl (\x y -> drop b x) l [1..]
01:07:28 <anoe> ^ Lovepon: hackagebot 
01:08:27 <Lovepon> > let chunkAlong a b l = map (take a) $ takeWhile  (\x -> length x >= a) $ scanl (\x y -> drop b x) l [1..] in chunkAlong 4 2 [1..9]
01:08:29 <lambdabot>  [[1,2,3,4],[3,4,5,6],[5,6,7,8]]
01:08:36 <Lovepon> Nice.
01:10:08 <anoe> sorry hackagebot i twas hackrilege but not here (fault to the completion)
01:43:07 * hackagebot aivika 4.3.4 - A multi-paradigm simulation library  https://hackage.haskell.org/package/aivika-4.3.4 (DavidSorokin)
01:48:07 * hackagebot aivika-transformers 4.3.4 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-4.3.4 (DavidSorokin)
01:48:09 * hackagebot aivika-distributed 0.1 - Parallel distributed simulation library  https://hackage.haskell.org/package/aivika-distributed-0.1 (DavidSorokin)
01:59:36 <EvanR> blogs agree that haskell is a difficult language created by and for "alpha geeks". but im thinking instead its like a superhighway running from "too simple to even mention" which is included in most languages, and continues into "normal programming ideas" and then continues out the other side of the city into the border lands, which is what gets the publicity
02:02:06 <EvanR> this came to me while trying to even begin to comprehend the comment in ghc http://lpaste.net/161278
02:03:15 <EvanR> avoiding knot tying failures when implementing injective type families
02:06:07 <EvanR> curious why my attempt at "SEC lenses" compose backwards relative to conal's http://lpaste.net/161279
02:11:32 <athan> Anyone here mess with -XTypeFamilyDependencies?
02:11:44 <athan> Can't seem to get the syntax right for closed type families
02:11:47 <EvanR> that is the code i was just reading
02:11:54 <EvanR> didnt try to use it
02:15:14 <athan> This fails to parse at `=`: http://lpaste.net/161280
02:15:31 <athan> even though the docs advocate it: https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies :(
02:17:25 <kaeluka> these days, what tool(s) should I hook up emacs with for the best haskell dev experience?
02:18:08 * hackagebot transformers-eff 0.1.0.0 - An approach to managing composable effects, ala mtl/transformers/extensible-effects/Eff  https://hackage.haskell.org/package/transformers-eff-0.1.0.0 (OliverCharles)
02:18:12 <athan> kaeluka: hsdevtools? ghc-mod? Idk :s I just use spacemacs because I'm lazy
02:23:34 <sbrg> kaeluka: I downloaded haskell-mode and have syntax checking using flycheck via haskell-stack-ghc. I used to use ghcmod but it broke a while ago and I haven't really bothered to try to fix it.
02:23:39 <sbrg> (before it had real stack support)
02:25:50 <aarvar> athan: isn't that "type C" injectivity which hasn't been implemented yet?
02:28:37 <athan> aarvar: >o< thank you!
02:28:40 <kaeluka> athan, sbrg: I’ll try out spacemacs
02:28:51 <kaeluka> it has been on my “list” anyway
02:28:56 * athan twiddles thumbs like a madman
02:29:15 <aarvar> athan: I remember getting a similar error when I tried to use it to encode injective type level lambdas
02:29:16 <kaeluka> is there any reason left to use cabal over stack these days?
02:29:38 <sbrg> kaeluka: It's pretty easy to set up without spacemacs regardless. but spacemacs is a solid platform.
02:32:44 <EvanR> uhm... is it "space" emacs or "spak" emacs or space "macs"
02:32:54 <EvanR> or none of the above
02:36:32 <sbrg> I read it space macs
02:36:39 <sbrg> space is because "space is their leader" or some such
02:39:18 <ggVGc> space macs because they drop acid and design computers, as in the original steve days... maybe
02:57:34 <simon> hello
02:57:50 <Oejet> Hi, simon.
03:06:46 <simon> what are the drawbacks of installing Haskell Platform vs. 'brew install ghc cabal-install' on mac?
03:08:09 * hackagebot hackage-security 0.5.1.0 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.5.1.0 (DuncanCoutts)
03:24:23 <WarzoneCommand> hmm question. Is there a Map like read-only data structure that provides O(1) time (WC) lookup? 
03:25:24 <WarzoneCommand> i.e. a Data structure 'D k v', with operations: create :: [(k,v)] -> D k v (in O(n) time), and lookup :: D k v -> k -> Maybe v (in O(1) time) ? 
03:26:20 <WarzoneCommand> normally hash-tables should do I think. But there doesn't seem to be a 'pure' hashtable implementation floating around 
03:42:59 <ski> EvanR : compose backwards ?
03:51:29 <black0range> Hello! Trying to get cabal unit testing to work together with HUnit, but I can't figure out how and most guides for HUnit says "use ghci" 
03:51:42 <black0range> Does anyone know of a decent guide?
04:07:22 <haskell015> Hi there please tell me how can I reverse a list like this [1,2,3,4,5,6,7,8,9] to [7,8,9,4,5,6,1,2,3] with a parameter like 3 in this case to reverse groups of 3. Thanks
04:09:50 <ski> haskell015 : what have you tried ?
04:10:10 <haskell015> I tried to rotate it but it doesn't work
04:10:38 <haskell015> also I thought of splitting it but split returns a tuple tot a list of lists to concatenate
04:10:44 <cocreature> you can do it in 3 steps
04:10:49 <cocreature> first split it up in groups of 3
04:10:53 <t7> concat . map reverse . splitEvery 3
04:10:53 <cocreature> then reverse each of these groups
04:10:56 <cocreature> then concat them
04:10:59 <t7> i w1n
04:11:10 <t7> Data.List.Split btw
04:11:18 <cocreature> isn’t it called chunksOf?
04:11:20 <haskell015> Thanks I didn't know about splitEvery
04:11:37 <t7> haskell015: you will need the split package
04:12:25 <t7> oh wow listen to cocreature not me
04:12:47 <t7> it is chunksOf now
04:13:21 <cocreature> it’s also in neil mitchell’s extra package if for some reason you prefer to depend on that instead of split
04:14:34 <ski> @let onChunksOf :: Int -> ([[a0]] -> [[a1]]) -> ([a0] -> [a1]); onChunksOfn = Data.List.Split.chunksOf n ~> concat
04:14:35 <lambdabot>  .L.hs:179:1:
04:14:35 <lambdabot>      The type signature for ‘onChunksOf’ lacks an accompanying binding
04:14:39 <mmercer2> > (concat . reverse . chunksOf 3) [1,2,3,4,5,6,7,8,9]
04:14:40 <ski> @let onChunksOf :: Int -> ([[a0]] -> [[a1]]) -> ([a0] -> [a1]); onChunksOf n = Data.List.Split.chunksOf n ~> concat
04:14:41 <lambdabot>  [7,8,9,4,5,6,1,2,3]
04:14:42 <lambdabot>  Defined.
04:14:53 <ski> > onChunksOf 3 reverse [1,2,3,4,5,6,7,8,9]
04:14:55 <lambdabot>  [7,8,9,4,5,6,1,2,3]
04:15:08 <ski> > (onChunksOf 3 . map) reverse [1,2,3,4,5,6,7,8,9]
04:15:09 <lambdabot>  [3,2,1,6,5,4,9,8,7]
04:15:15 <Taneb> @type (~>)
04:15:16 <lambdabot> (a1 -> a0) -> (b0 -> b1) -> (a0 -> b0) -> a1 -> b1
04:15:55 <ski> <ski> @let infixr 5 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (a10 ~> b01) f = b01 . f . a10
04:15:59 <ski> <ski> @let res :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); res f = id ~> f  -- result
04:16:02 <ski> <ski> @let arg :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b)); arg f = f ~> id  -- argument
04:16:41 <ski> <ski> @let onLines :: ([String] -> [String]) -> (String -> String); onLines f = unlines . f . lines
04:16:44 <ski> <ski> @let perLines :: (String -> String) -> (String -> String); perLine = onLines . map
04:16:47 <ski> @where TV
04:16:47 <lambdabot> http://www.haskell.org/haskellwiki/TV
04:16:47 <ski> @where SEC
04:16:47 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
04:54:55 <mmercer2> trying snap for the first time.. their sample works, running Main starts a web server. but, when running it in ghci, if I ^C out of it, and then run Main again,  I am getting errors. "Can't open log file "log/access.log"."
04:55:29 <mmercer2> so how can I restart webserver without also restarting ghci?
05:03:01 <ertes> mmercer2: are you running it with 'main' or with ':main'?
05:03:18 <mmercer2> i am running Main function
05:03:23 <mmercer2> main*
05:03:29 <mmercer2> let me try :main
05:03:50 <mmercer2> same thing
05:03:58 <mmercer2> Exception: log/access.log: openFile: resource busy (file is locked)
05:04:07 <mmercer2> handles aren't closed on exception
05:21:38 <ertes> or: why you should *always* close your handles
05:22:02 <ertes> mmercer2: sounds like a bug to me
05:23:38 <ertes> based on the false assumption that after 'main' the world ends
05:24:00 <Gurkenglas_> :t \n -> under $ iso concat (chunksOf n) -- ski
05:24:01 <lambdabot> Foldable t => Int -> ([[e]] -> t [a]) -> [e] -> [a]
05:26:07 <mmercer2> ertes yeah agreed. perhaps there's another way of stopping the server, but I can't figure it ouf if there is.
05:26:54 <ertes> mmercer2: well, it would be great if the :main command were stateless, but apparently it isn't
05:27:01 <Gurkenglas_> > (\n -> au (iso concat (chunksOf n)) traverse) 3 [[1..9],[1..6]]
05:27:03 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[4,5,6],[4,5,6],[1,2,3],[4,5,6],[4,5,6],[7,8,9],[1,...
05:27:06 <mmercer2> this is the offending function. https://hackage.haskell.org/package/snap-server-0.9.5.1/docs/src/Snap-Http-Server.html#simpleHttpServe
05:28:36 <mmercer2> it looks like it is trying to handle it, there's withLoggers, which uses bracket, but for some reason it isn't doing its job
05:28:52 <ertes> mmercer2: maybe it's a bug in the logger rather than snap itself
05:29:43 <ertes> ah, they aren't using a logger package
05:29:47 <ertes> so it's still a bug in snap-server
05:50:04 <Lovepon> Guys.
05:50:13 <Lovepon> I don't think GHCJS works well with System.Entropy.
05:50:37 <Lovepon> That also implies that you can't use RSA, unless you make your own Entropy generator.
05:51:12 <ntnt> this guy haskellforall.com is a genius -- is there a way to get all his blog posts as a pdf? I hate the stupid blogger UI that won't even give me a table of contents of all posts
05:52:52 <Lovepon> With that said, is it secure to use System.Random as an entropy generator?
05:53:02 <Lovepon> Since it technically gets its entropy from somewhere.
05:53:48 <Lovepon> Okay, I get the problem now, it relies on C.
05:53:56 <Lovepon> How did I even get this to build? lol.
05:59:31 <ertes> ntnt: perhaps you can use wget -m to mirror his blog, then process it into a single HTML file manually…  but check his license first
06:00:06 <ertes> ntnt: alternatively just ask him via mail
06:00:52 <ertes> Lovepon: System.Random is not cryptographically strong…  look for web APIs for strong cryptographic random numbers
06:01:25 <Lovepon> ertes: How would a bad entropy source affect a PRNG?
06:01:39 <ertes> Lovepon: it would make it predictable
06:02:09 <Lovepon> ertes: Hmmm
06:02:12 <Lovepon> ertes: Web APIs?
06:02:33 <ntnt> ertes: bah, I just opened up all 100-ish posts in chrome, and printed them to pdf
06:02:40 <Lovepon> ertes: Also, this must be able to run on 2G internet.
06:03:25 <ertes> Lovepon: https://security.stackexchange.com/questions/20029/generate-cryptographically-strong-pseudorandom-numbers-in-javascript
06:04:07 <ertes> ntnt: still check his license
06:05:27 <ntnt> ertes: I'm not distributing anything; this is only for personal study; what license issues could there be?
06:05:42 <ntnt> Do we not have the right to save-as-pdf any thing we can read on the public internet?
06:06:11 <ertes> Lovepon: also ghcjs-dom seems to have a bunch of crypto modules…  check what they do
06:06:32 <ertes> i can't see their documentation on hackage, so you may have to install it locally
06:06:40 <Lovepon> ertes: https://hackage.haskell.org/package/ghcjs-dom-0.2.3.1/docs/GHCJS-DOM-Crypto.html
06:06:45 <Lovepon> ertes: Yep.
06:07:04 <ertes> ntnt: not necessarily
06:07:16 <Lovepon> ertes: I want less reliance on ghcjs-dom though.
06:07:48 <ertes> ntnt: but i'm pretty sure if you just ask him, he will grant you a CC-BY license…  that's what it's for after all =)
06:07:54 <ertes> or CC-BY-ND
06:08:05 <ntnt> ertes: why do I need a license to print-as-pdf public documents I can read?
06:08:11 <ntnt> I'm not selling / distributing
06:08:15 <ntnt> I'm reading this on my own
06:08:25 <ntnt> this is no different from taking screen shots
06:08:29 <ntnt> wtf are you suggesting ?
06:08:36 <Lovepon> ertes: System.Entropy crashes on ghcjs.
06:09:07 <ntnt> ertes: are you one of those people who walks around asking people if they read their EULA before clicking accept ?
06:09:43 <Lovepon> ertes: So, a generator is only as good as its seed?
06:10:12 <ertes> ntnt: i am, but if you don't care, it's your business…  no need to get offensive
06:10:25 <ertes> Lovepon: yes
06:10:34 <Lovepon> Well, this is abd.
06:10:38 <Lovepon> bad*\
06:10:44 <Athas> I wanted to try out GHC 8.0 on my code, but couldn't, because many of my depencies have upper version bounds on things like base.  Is there a good reason to have those bounds?
06:11:22 <maerwald> most of the time no
06:11:24 <ertes> Lovepon: you could look into the source code of ghcjs-dom and just see what it does…  but apart from the answer on stackexchange i'm not aware of a way to generate random numbers securely in browser-JS
06:11:39 <ntnt> ertes: why are you telling a random person that they need to email someone to ask for permission to print-as-pdf public documents on the internet for the purpose of self study (neither to sell nor to distribute)
06:12:09 <maerwald> people just do that to say "this is the tested range", but the range is often simply wrong
06:12:40 <Lovepon> ertes: It'd also be stupid to get a seed from my web server, right? Since someone may be sniffing on it.
06:12:55 <Athas> Whether I get a compile error due to a version mismatch or a newer incompatible version doesn't seem that important.
06:13:29 <ertes> ntnt: because copyright is complicated, and because no license = "all rights reserved", and because although i'm certain that gabriel won't mind, he may have chosen "all rights reserved" for a reason other than being too lazy to provide an explicit license
06:14:14 <ntnt> ertes: does all rights reserved on a document I can read ban me from print-to-pdf that document for personal study ?
06:14:33 <Lovepon> ertes: Thanks.
06:14:43 <Lovepon> Hmmmm
06:15:08 <ertes> Lovepon: the problem with that is that the user would have to trust your web server…  but of course, if you're delivering the script to begin with, they have to trust you anyway
06:15:24 <ertes> Lovepon: but it's also an unfortunate design choice, because you would need to communicate with the server
06:15:31 <maerwald> Athas: hackage is not a consistent package set, so people try to mess around with upper bounds to get stuff to work. And even add upper bounds without knowing if it's needed
06:15:48 <Athas> maerwald: hopefully the bold new future of Stackage will mean the end of that!
06:15:51 <Lovepon> ertes: But I get a chicken-and-egg progblem.
06:16:12 <Athas> Is there a cabal option to ignore upper bounds?
06:16:23 <ertes> ntnt: IANAL, but it may well do that…  as the FAQ on fsf.org explained somewhere, you get a few implicit rights such as "reading online"
06:16:29 <Lovepon> ertes: I can't encrypt the client<->server due to the lack of entropy, and I don't have entropy because I can't have a secure connection to the server.
06:16:43 <maerwald> Athas: --allow-newer I thnk
06:16:46 <ertes> ntnt: that's why the FSF and CC suggest that you always provide a license for free information, be it prose or source code
06:16:52 <Lovepon> ertes: At this point, it'd be better to just use Stdgen, right?
06:17:17 <ertes> ntnt: but again, i'm sure nobody will sue you for making a PDF of gabriel's posts
06:17:47 <Athas> maerwald: thanks!  I guess I can try out the release candidate then.
06:18:02 <ntnt> ertes: lol, we live in a world people can sue each other for anyreason -- some random lurker (who isn't involved in this conversation), could potentially sue both of us for triggering their micro agression and making them feel unsafe in #haskell
06:18:28 <ertes> ntnt: i would welcome them to do that =)
06:19:01 <ntnt> ertes: I haven't had my morning coffee and may have been a little snarky at you for 'telling me I needed to email someone to ask for permission to print-as-pdf' and stopping me from reading my morning haskell :-)
06:19:24 <ertes> Lovepon: no!
06:19:36 <Lovepon> ertes: Just for clarification, if I have a weak PRNG, and use it as an entropy source for a CSPRNG, would it be better, the same, or worse than just using the PRNG itself?
06:19:38 <ertes> Lovepon: StdGen has only 48 bits of entropy IIRC
06:19:55 <ertes> Lovepon: better use an untrusted PRNG than a completely broken one
06:20:36 <ertes> Lovepon: the same…  the thing is: you have access to strong entropy…  it is strong, it's just not trusted
06:20:40 <ertes> the user has to trust *you*
06:21:03 <ertes> if the PRNG was weak to begin with, the attacker can just attack right away
06:21:06 <Lovepon> ertes: But the peopel can just sniff out the entropy source, can it not?
06:21:19 <ertes> if the PRNG was untrusted, the attacker has to find a way to affect the entropy source (you)
06:21:30 <ertes> Lovepon: yes, unless you use TLS
06:21:49 <ertes> and since these days TLS is free…  search for "let's encrypt"
06:22:05 * Athas ought to setup Let's Encrypt on his server.
06:22:28 <Lovepon> ertes: Wouldn't that be chicken-and-egg? Doesn't TLS require a nonce?
06:22:32 <ertes> Lovepon: that doesn't make you any more trustworthy (from the perspective of the user), though
06:22:51 <ertes> Lovepon: TLS uses system entropy…  it doesn't live in the limited world of javascript
06:23:23 <Lovepon> ertes: Oh right. The connection is handled by the browser, not by JS.
06:24:41 <ertes> Lovepon: unfortunately you cannot do this in a fully trustworthy way, because browser crypto has major conceptual flaws
06:24:56 <ertes> but at least you can do it in such a way that an attacker has to compromise your server
06:25:07 <Lovepon> Right.
06:25:09 <ertes> and not just intercept the connection or guess weak random numbers
06:25:30 <Lovepon> Oh right.
06:25:36 <Lovepon> The question that needs to be asked.
06:25:51 <ertes> "why does JS crypto still suck in 2016?!"
06:25:55 <Lovepon> ertes: How much would this affect the performance of the server?
06:26:13 <Lovepon> ertes: s/crypto still//; s/in 2016//
06:26:51 <ertes> Lovepon: i would check whether the window.crypto.getRandomValues function is available
06:27:05 <ertes> if yes, use it and don't put any additional load on the server (most visitors will have it)
06:27:14 <ertes> if not, fall back to entropy from the server
06:27:28 <Lovepon> ertes: This is meant to run on an Android phone./
06:27:39 <Lovepon> :/
06:27:47 <ertes> Lovepon: i use firefox on my phone =)
06:27:55 <Lovepon> ertes: True.
06:28:50 <ertes> Lovepon: also if it's not available right now, it might well become available at some point
06:29:07 <Lovepon> ertes: The project's deadline is in 2 weeks.
06:29:42 <ertes> at that point you could notice a drop in server load, because people are switching to the new browser version and asking for server entropy less often
06:29:56 <ertes> Lovepon: also you don't have to feed them /dev/urandom directly
06:30:18 <Lovepon> ertes: I know!  I'll feed them Stdgen.
06:30:19 <Lovepon>  /s
06:30:23 <ertes> you can just use a very fast CSPRNG (for example the DRBG package) and seed it regularly from /dev/urandom
06:30:28 <ertes> hehe
06:30:36 <Lovepon> ertes: Actually, that's what I'm doing!
06:30:46 <Lovepon> ertes: On the JavaScript side, at least.
06:30:56 <Lovepon> ertes: Until I found out that System.Entropy doesn't work...
06:30:56 <ertes> yeah, now do the same on the server side
06:30:59 <ertes> you can even share code
06:31:37 <Lovepon> ertes: I'll put TLS to my consideratinos.
06:31:44 <m1dnight_> I am getting the "Prelude: no parse" error all the time with my lexer (alex). I have googled and I think I know what the error is telling me: a call to read expects a specific format but what I give it to read does not match what with the type it expects.
06:31:53 <m1dnight_> But all I do is read String. That should kinda always succeed, no?
06:32:09 <Lovepon> ertes: Or I could just go fuck it, and use StdGen. Because fuck the client... nah.
06:32:11 <ertes> m1dnight_: no
06:32:18 <ertes> > read "\"abc\"" :: String
06:32:20 <lambdabot>  "abc"
06:32:23 <ertes> > read "abc" :: String
06:32:25 <lambdabot>  "*Exception: Prelude.read: no parse
06:32:35 <m1dnight_> But I don't have quotes in my source file. 
06:32:42 <lyxia> then don't use read
06:32:47 <m1dnight_> It literally contains "Bool = Int" (without quotes that is :p)
06:33:40 <m1dnight_> Heh, that is actually the fix.
06:33:48 <m1dnight_> No point in reading a stirng
06:33:50 <m1dnight_> String*
06:34:09 <m1dnight_> thanks guys
06:34:53 <ertes> Lovepon: i think the solution i proposed is pretty sound:  try window.crypto.getRandomValues, fall back to server entropy…  use DRBG on both sides, seed it regularly on the server side (a KiB every minute for example)
06:35:02 <Lovepon> ertes: Oh, right, how about random.org?
06:35:30 <ertes> Lovepon: if you use random.org, you add one more untrustwothy site the user has to trust
06:35:34 <jophish_> darn, making my algorithm correct makes it twice as slow :(
06:35:36 <Lovepon> ertes: True.
06:36:21 <Lovepon> ertes: Give me an estimate on how long it'd take to set up letsencrypt.
06:36:23 <jophish_> perhaps I'll just wait until computers get faster
06:36:40 <ertes> Lovepon: also random.org's random numbers probably aren't better than yours…  the only thing you could use them for is to feed your own entropy pool, but this smells like overengineering =)
06:37:00 <ertes> Lovepon: usually a few minutes
06:37:17 <Lovepon> ertes: To someone who knows nothing about web dev.
06:37:19 <ertes> Lovepon: schedule 30-60 minutes for it and you're safe
06:37:23 <ertes> oh
06:37:26 <aweinstock> ertes: how does using server entropy help with anything?
06:37:45 <Lovepon> ertes: Also, there are some.... special things, happening.
06:37:47 <aweinstock> (I just finished reading the backlog of this conversation)
06:37:52 <ertes> Lovepon: you'll get a certificate that you need to configure…  allow yourself 2-3 hours for learning
06:37:57 <Lovepon> ertes: For one, I might decide to run this on my laptop.
06:38:09 <Lovepon> ertes: Or I'll use my server.
06:38:40 <aweinstock> Lovepon: don't use some custom JS-based protocol, just use TLS
06:38:51 <Lovepon> aweinstock: Of course.
06:38:54 <ertes> aweinstock: cryptographically strong entropy isn't available on all browsers…  server entropy can serve as a fallback, without introducing any further trust issues (because the user already has to trust Lovepon's server)
06:39:16 <ertes> aweinstock: i'm pretty sure this isn't about securing the *connection*
06:40:05 <aweinstock> ertes: if all the entropy sent can be observed by a passive adversary, you can't hide anything with it
06:40:24 <aweinstock> ertes: and without TLS, an active MITM could just replace the JS entirely
06:40:25 <ertes> aweinstock: that's why i said Lovepon has to use TLS
06:40:45 <aweinstock> but with TLS, what's the additional randomness needed for?
06:41:12 <ertes> aweinstock: client-side crypto not related to the connection
06:41:40 <aweinstock> to accomplish what goal?
06:41:51 <ertes> only Lovepon can answer that
06:42:37 <ertes> but i assume that it's about client-side data encryption
06:43:46 <ggVGc> jophish_: correctness, speed, existence. Choose 2
06:44:22 <Lovepon> ertes: Signing.
06:45:14 <Lovepon> ertes: I need something which ensures that the source is actually him.
06:45:22 <Lovepon> s/him/the client/
06:45:39 <ertes> Lovepon: remember that you can forge every single signature that can be made through your service
06:45:57 <jophish_> ggVGc: I can make it twice as fast and have it return the correct result nearly all of the time, and get quite close the rest of the time
06:46:06 <ertes> Lovepon: if this is for authentication *to you*, that's fine
06:46:15 <Lovepon> ertes: Yes, it's authentication to me.
06:46:23 <Lovepon> ertes: There'll be a physical transfer of their generated pubkeys.
06:46:26 <jophish_> I think I'll go with correct, but perhaps make a "fooFast" function which isn't quite as perfect
06:46:28 <ertes> Lovepon: login authentication or document authentication?
06:46:38 <Lovepon> ertes: Document authentication, I think.
06:46:42 <ertes> Lovepon: the physical transfer is pointless
06:46:53 <ertes> Lovepon: the JS code that handles the keys is delivered by the server
06:46:58 <aweinstock> Lovepon: if they're going to be giving you pubkeys in person, why does JS entropy enter the picture at all?
06:46:59 <ertes> might as well deliver the keys that way, too
06:47:36 <ertes> Lovepon: you *cannot* solve this properly in a browser-based application
06:47:36 <ggVGc> jophish_: sounds like quantum computing
06:47:37 <Lovepon> ertes: That's not the point, the reason why I need it signed is to ensure that I'll only be getting data from the clients whitelist.
06:47:39 <aweinstock> they can generate the pubkeys via openssl cli or gpg
06:48:01 <ertes> Lovepon: but since this is android, consider writing an app instead (see apache cordova, if you want to write it in javascript, i.e. haskell)
06:48:07 <ggVGc> jophish_: sounds interesting though. What kind of algo is this?
06:48:17 * hackagebot aivika-distributed 0.1.1 - Parallel distributed simulation library  https://hackage.haskell.org/package/aivika-distributed-0.1.1 (DavidSorokin)
06:48:29 <aweinstock> ggVGc: not all approximation algorithms are quantum
06:48:48 <ertes> Lovepon: even just generating the keys in JS is problematic
06:49:23 <aweinstock> ggVGc: canonical example: greedy largest-first algorithm for knapsack problem is guarenteed to get >= half of optimal
06:50:19 <ertes> Lovepon: let's put crypto aside for a moment and talk about the application
06:50:23 <Lovepon> ertes: Cordova is being considered.
06:50:25 <Lovepon> ertes: Okay.
06:50:38 <ertes> Lovepon: what is it?  feel free to abstract the business secrets away
06:50:40 <aweinstock> Lovepon: does it need to actually be secure, or does it need to have crypto primitives sprinkled around so that it "feels secure" to the client?
06:51:22 <Lovepon> ertes: It's very simple, from a list of trusted clients, accumulate the data in a server.
06:51:48 <ertes> Lovepon: ok, how does browser JS enter this game?
06:51:51 <Lovepon> aweinstock: It doesn't actually need to be secure, but I'm interested in doing the Right Way.
06:51:51 <ertes> and why?
06:51:59 <Lovepon> ertes: Because Haskell. xD
06:52:23 <ertes> Lovepon: in other words: use cordova for the app to get access to more than what a browser would give you
06:52:39 <Lovepon> ertes: Right, I'm considering that.
06:52:43 <aweinstock> Lovepon: https://github.com/krx/CTF-Writeups/tree/master/CSAW%2015%20Finals/for300%20-%20randsomewhere <-- example of why entropy sources matter
06:52:54 <ertes> Lovepon: you write sort of a web app with it, but you can use JS APIs to access system APIs
06:53:12 <ertes> Lovepon: that has the huge advantage that you can use system entropy
06:53:17 * hackagebot servant-csharp 0.0.5.0 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.5.0 (KatsutoshiItoh)
06:53:37 <ertes> and that the code is not (semantically) delivered with every request, so the attacker has to do more work to compromise it
06:53:53 <Lovepon> ertes: Some people told me "use cordova + purescript"
06:54:22 <ertes> Lovepon: if you want to use purescript, use purescript…  but you can use full haskell, if you want to
06:54:32 <Lovepon> ertes: Hence why I used ghcjs.
06:54:35 <ertes> it's really just browser JS with additional APIs
06:55:29 <ertes> note about purescript: it's not a "minimal haskell", but more like a "javascript with better syntax and a type system"
06:55:41 <Lovepon> ertes: I see.
06:57:25 <Lovepon> ertes: I'll see what I can do, first, I should make something that actually works.
06:57:37 <aweinstock> Lovepon: if the server has a bunch of pubkeys, and each client has their own privkey, each client can just sign the data they're sending (possibly with metadata about who they are so that the server doesn't need to try every pubkey to verify the signature)
06:57:56 <Lovepon> aweinstock: Yes, that's what I'm doing.
06:58:40 <aweinstock> and you need randomness for the nonces for signing?
06:59:04 <Lovepon> aweinstock: Thing is, I want to automate it as much as I can. The only thing that's manual here is the physical transfer of the pubkeys and inputting it in the server.
06:59:25 <Lovepon> aweinstock: For the nonce, I'll just append a timestamp.
07:00:02 <aweinstock> timestamps as nonces feels unneccessarily risky if you have a randomness source you could use instead
07:01:05 <aweinstock> you could have the clients generate the keypairs automatically, send pubkey to the server on first request, and then manually approve the pubkeys later
07:01:23 <Lovepon> aweinstock: This is what I'm doing.
07:01:39 <Lovepon> The first page displays the pubkey, which will be whitelisted by the server.
07:02:07 <Lovepon> Then, the next page sends strings x, y, along with the pubkey to the server. x and y is metadata.
07:02:27 <Lovepon> x,y,pubkey is of course signed.
07:02:44 <ertes> Lovepon: if you're under demo pressure, you can implement it as a browser-based solution, but with abstractions around the crypto-related things…  then later you can turn it into a cordova app and replace the implementations of those by secure ones
07:03:04 <ertes> Lovepon: in general, never use timestamps, unless you want to actually communicate time
07:03:05 <Lovepon> ertes: Yeah, demo pressure.
07:03:14 <Lovepon> ertes: I want to communicate time too.
07:03:24 <ertes> Lovepon: nonces are a bad way to do it
07:03:33 <ertes> they should be random
07:03:45 <Lovepon> ertes: After some thinking, I realized that I could just rewrite the data at the server through replay attack.
07:03:46 <ertes> and not StdGen-random, but as truly random as possible
07:04:15 <Lovepon> ertes: Actually, using random would work just as well.
07:04:32 <ertes> Lovepon: use the timestamp as part of the payload to prevent replay attacks
07:04:32 <Lovepon> Hmmm
07:04:50 <ertes> not as a nonce…  that one should be random
07:04:53 <Lovepon> ertes: Yeah, that's why I'm using timestamps, but then a random nonce would work as fine.
07:05:01 <Lovepon> just as fine*
07:05:07 <Lovepon> s/fine/well/
07:05:48 <ertes> Lovepon: oh, and if possible don't use RSA
07:05:56 <Lovepon> ertes: I'm actually using RSA. Shit.
07:06:01 <ertes> we don't need more applications relying on it =)
07:06:10 <Lovepon> ertes: What should I use?
07:06:29 <ertes> Lovepon: check if the 'cryptonite' library works with GHCJS
07:06:40 <ertes> if yes, use ECC like ECDSA and ECIES
07:07:13 <ertes> your users will thank you for saving their battery, too =)
07:07:20 <ertes> because RSA on JS is slooooooow
07:07:23 <Lovepon> ertes: https://hackage.haskell.org/package/cryptonite ?
07:07:27 <ertes> yeah
07:08:05 <ertes> if it doesn't work, there is a separate library for ECC on hackage
07:08:15 <Lovepon> Wait.
07:08:23 <Lovepon> How can signing be vulnerable to timing attacks?
07:08:34 <ertes> signing is a private key operation
07:09:12 <Lovepon> ertes: Right, but isn't signing... unidirectional?
07:09:16 <Lovepon> Err
07:09:22 <Lovepon> Let me repeat that.
07:09:40 <Lovepon> ertes: If you're going to sign something, wouldn't the recipient not know how long the time it took you to sign?
07:09:41 <ertes> in the case of RSA the main secret is used as an exponent in a modular exponentiation calculation
07:09:57 <ertes> a naive implementation will reveal that exponent to a concurrent listener on the same device
07:10:19 <ertes> now add that this is running on an android phone, where potentially many untrusted applications are running at the same time
07:10:25 <Lovepon> ertes: OHHHH
07:10:36 <Lovepon> ertes: Right, I did not think of that.
07:11:24 <Lovepon> ertes: Why cryptonite and not just the ECC library?
07:12:07 <ertes> because cryptonite is developed by vincent hanquez, a well known and very experienced haskell crypto code author =)
07:12:15 <Lovepon> ertes: I see.
07:12:19 <ertes> i generally trust him and thomas debuisson
07:12:27 <ertes> (the author of DRBG and many other crypto libraries)
07:12:34 <Lovepon> ertes: Ohhh, I see.
07:13:19 <Lovepon> ertes: I'll give cryptonite a try then.
07:16:00 <Lovepon> I wonder how GHCJS acts when an operation is not supported.
07:16:39 <Lovepon> Since that may be a problem.
07:22:51 <Lovepon> Can anyone help me with that?
07:33:24 * hackagebot servant-csharp 0.0.6.0 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.6.0 (KatsutoshiItoh)
07:34:29 <Gurkenglas_> I'd like a "Foo :: forall k. (k -> Constraint) -> k" which gives the free member of a class. Then we could, wherever possible, make things that produce [a] instead produce Foo Foldable a, just as we made things that consume [a] instead consume Foldable f => f a
07:36:55 <Gurkenglas_> I'd also like things that require (Enum a, Bounded a) (presumably to use [minBound..maxBound]) to instead take Bar a, where "class Bar a where [..] :: Foo Foldable a". Thoughts on these half-baked ideas?
07:53:25 * hackagebot servant-csharp 0.0.6.1 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.6.1 (KatsutoshiItoh)
08:03:45 * hackagebot jsontsv 0.1.6.0 - JSON to TSV transformer  https://hackage.haskell.org/package/jsontsv-0.1.6.0 (DanielChoi)
08:13:46 * hackagebot jsontsv 0.1.6.1 - JSON to TSV transformer  https://hackage.haskell.org/package/jsontsv-0.1.6.1 (DanielChoi)
08:20:13 <Lovepon> How does ghcjs react to undefined functions?
08:28:11 <bblfish> anyone here use IntelliJ with Haskell?
08:29:19 <ntnt> what is the equiv of haskell design patterns? I just learned about Free Monads. They're awesome. I need to learn more.
08:34:00 <bblfish> just reading about Free Monads. Actually I have used them before quite heavily, but as I want to go a lot further I thought it'd be time to read up seriously on them
08:34:16 <bblfish> this is a nice article http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
08:34:40 <bblfish> I wonder what this means ` type Thread m = [m ()]`
08:48:00 <Lovepon> ertes: Sooo... why is SignWith a "maybe"?
08:49:07 <Lovepon> ertes: Errr... I'm stupid.
09:14:47 <ntnt> wher eis (&) defined?
09:14:50 <ntnt> I can not find it on hoogle
09:17:07 <Lovepon> ntnt: x & f = f x.
09:17:20 <ntnt> it's like flip $ ?
09:17:28 <Lovepon> ntnt: It's reverse ($) with less fixity.
09:17:31 <Lovepon> ntnt: Yes.
09:17:34 <Lovepon> s/reverse/flip/
09:31:13 <ntnt> is there something like hoogle for but for ghcjs packages ?
09:41:50 <kadoban> ntnt: All of them are the same. Stuff like ghcjs-base and whatever aren't in hackage so you can't hoogle them though, I don't know of a search for them. It's ... not amazing unfortunately.
09:42:39 <ntnt> kadoban: yeah, the packages I really need are things like GHCJS.DOM.ffi bindings
09:42:44 <ntnt> and I'm just grepping through them atm
09:42:53 <ntnt> but a hoogle interface would be relaly nice (but unfortunately unlikely)
09:43:17 <kadoban> Yeah, I agree.
09:43:49 * hackagebot hindley-milner 0.1.0.0 - Template for Hindley-Milner based languages  https://hackage.haskell.org/package/hindley-milner-0.1.0.0 (mbg)
09:43:51 * hackagebot math-functions 0.1.6.0 - Special functions and Chebyshev polynomials  https://hackage.haskell.org/package/math-functions-0.1.6.0 (AlexeyKhudyakov)
09:49:28 <ertes> i need an abstraction for the following:  apply :: (TheClass f g) => f (a -> b) -> g a -> g b
09:49:37 <ertes> is there a package for something like that?
09:50:13 <m1dnight_> How can I assign precedence to a rule if I don't have an operator? (I want to fix s/r's for: `Expr : Expr Expr { App $1 $2 }`
09:53:42 <hackrilege> i have updated my paste, now it works really good, but there is some messy stuff with monoids at the bottom i cant figure out how to handle
09:53:43 <hackrilege> http://lpaste.net/161291
09:55:03 <orion> Does anyone know how to get attoparsec to return to you not only the parsed data structure, but the bytes which it consumed?
09:56:48 <hackrilege> also on line 58 is some syntax i dont know how to write
09:57:41 <MichaelK> Is there any way to make a multi-class instance? The case I'm thinking of is given a wrapper type `data Wrapper a b = Wrapper a b`, make an instance like `instance (IsClass C, C a) => C (Wrapper a b)` where any methods ignore `b` (leave it untouched, but don't drop it).
09:57:43 <Lovepon> Oh my God.
09:57:59 <Lovepon> I can't use any crypto library.
09:58:09 <Lovepon> Most of them relies on C.
09:58:34 <MichaelK> Lovepon: for library support, probably?
09:58:41 <hackrilege> MichaelK you mean like proxy types?
09:59:30 <hackrilege> this is slow but pure https://hackage.haskell.org/package/SHA-1.6.4.2/docs/Data-Digest-Pure-SHA.html
10:00:03 <MichaelK> hackrilage: I'm not sure that'd work. For example, if `b` were `String` (a name or something). So there's still something there besides an "empty" type
10:00:38 <hackrilege> sounds like a proxy type
10:01:23 <hackrilege> eg, if i wanted to write mempty for a monad.
10:01:33 <hackrilege> no idea how to use them though!
10:01:55 <MichaelK> hackrilege: any idea where I could find some good documentation/examples?
10:02:09 <hackrilege> but when i faced the problem you described that was the advice i recieved here and it certainly looked like it could do that
10:02:21 <MichaelK> hmm
10:03:45 <hackrilege> no idea, sorry. like i say i never got to grips with it properly, certainly an annoying feature, but like most almost Type errors that can be handled in convoluted ways, sometimes reflecting on why you are being prevented from doing something actually teaches you how what you were trying to do isnt actually what you wanted
10:04:21 <hackrilege> i have never needed to do this again since. the class i was after was called MonadPlus
10:06:24 <hackrilege> anyway if Wrappers appear in your functions, so will type b, and mentioning it will satisfy the compiler. you just shouldnt include functions eg a->a which dont ention b
10:06:28 <hackrilege> mention*
10:07:14 <hackrilege> i think basically a proxy type just sits there doing nothing but informing the compiler about the unused type
10:07:36 <hackrilege> not 100% about it though really
10:07:52 <MichaelK> hackrilege: my motivation is to offer a clean api. the user of the api shouldn't (in my mind) be concerned with adding classes for `b` or much else. 
10:09:02 <hackrilege> i guess if you really wanted you could make a short paste with an example of the functionality you want to achieve
10:18:18 <Ox0dea> When might `Just Nothing` make sense?
10:18:44 <Clint> when your type is Maybe (Maybe a)
10:19:11 <hackrilege> > join (Just Nothing)
10:19:12 <lambdabot>  Nothing
10:19:13 <Lovepon> Ox0dea: Monads.
10:19:31 <hackrilege> :t join
10:19:32 <lambdabot> Monad m => m (m a) -> m a
10:20:23 <hackrilege> > Nothing >>= Just
10:20:25 <lambdabot>  Nothing
10:20:57 <geekosaur> as I understand the question, it gives you levels of failure
10:21:35 <geekosaur> so for example Nothing means an error retrieving data, Just Nothing means no error but no data, Just (Just theData) is data available
10:21:38 <Ox0dea> Does it ever make sense to wrap Nothing in a Maybe?
10:21:48 <Lovepon> Yes.
10:22:12 <Ox0dea> What's the first use case that jumps to mind?
10:22:13 <mauke> Ox0dea: consider lookup on a Map String (Maybe Integer)
10:22:17 <Lovepon> Ox0dea: Monads.
10:22:33 <geekosaur> we proobably wouldn't do that becuse one likes to know what error occurred, but there are other cases where you need to distinguish lack of data at one level from lack at another
10:22:38 <Lovepon> I'm going to go to sleep. I'm messing up one after another.
10:22:44 <Lovepon> Err
10:23:00 <Lovepon> Good night.
10:23:04 <mauke> then 'Just Nothing' indicates the key was found, but the associated value was Nothing
10:23:08 <mauke> :: Maybe Integer
10:23:21 <Ox0dea> mauke: Excellent! That did the trick.
10:23:50 <hackrilege> in Nothing >>= Just , Nothing is a Monadic value, Just is a function returning a 'Monad of a' from 'a'. >>= takes the value Nothing and fmaps Just over it
10:24:11 <Cale> Ox0dea: You might want to represent patches to a value of type Map k v as values of type Map k (Maybe v), where a Nothing represents deletion.
10:24:30 <Cale> Ox0dea: But then, v might itself be Maybe Something
10:24:54 <hackrilege> this obviously fails, but thats ok because that failure is now also handled alongside failure of the function (a-> Maybe a) which Just was used for in the example
10:25:38 <Cale> hackrilege: Just is a function producing Maybe a from a
10:25:45 <Cale> It doesn't produce a result in an arbitrary monad
10:26:34 <hackrilege> Just is a function returning a 'Monad of a' from 'a', where the particular Monad in question is Maybe
10:26:51 <Lovepon> mauke | Ox0dea: consider lookup on a Map String (Maybe Integer)
10:26:53 <ertes> i have to share a revelation: interpreting FT is actually easier than interpreting FreeT…  no longer will i have to convert FTs to FreeTs
10:27:13 <Lovepon> mauke: How about, "given a Maybe key, do a lookup on Map String Integer"
10:27:24 <hackrilege> Cale did you see my new paste? http://lpaste.net/161291
10:27:25 <Lovepon> mauke: I've never seen a map to maybe.
10:27:25 <Cale> ertes: What's FT?
10:27:30 <ertes> and probably faster, too (which is the main reason why i use FT instead of FreeT)
10:27:36 <ertes> Cale: church-encoded FreeT
10:27:39 <hackrilege> any idea about the Monoids at the bottom?
10:27:53 <Lovepon> ertes: Sooo.... I messed up. A lot.
10:28:02 <monochrom> ertes: that's strange. I tried to interpret F, it was a bit awkward.
10:28:11 <Lovepon> ertes: Everything I needed uses C.
10:28:42 <ertes> monochrom: don't feel bad…  it took like three years for me to click
10:28:48 <monochrom> haha ok!
10:29:04 <ertes> monochrom: but really, if you get foldr, you get runFT
10:29:22 <ertes> Lovepon: that's…  not good
10:29:46 <hackrilege> the crypto stuff? want the library i linked any good?
10:29:55 <Lovepon> ertes: Yeah...
10:30:00 <Lovepon> hackrilege: Which one?
10:30:14 <hackrilege> this is slow but pure https://hackage.haskell.org/package/SHA-1.6.4.2/docs/Data-Digest-Pure-SHA.html
10:30:25 <ertes> Lovepon: i guess, your only realistic choice is to look for javascript crypto libraries
10:30:35 <begriffs> Is there a type similar MVar except it can be repeatedly read without emptying it? I want to have in essence a state variable that is periodically updated but read multiple times.
10:30:39 <Lovepon> ertes: Or I decide to make my own. <.<
10:31:00 <hackrilege> or use one of the existing pure crypto libs...
10:31:03 <ertes> begriffs: MVar can do that:  use readMVar and writeMVar and newMVar
10:31:17 <monochrom> begriffs: either IORef again (writer uses atomicModifyIORef), or STM's TVar.
10:31:22 <ertes> begriffs: but if you need a semantically correct thing, TVar is probably what you want
10:31:46 <ertes> Lovepon: don't
10:31:50 <monochrom> in fact I went with IORef.
10:32:02 <begriffs> Ah thanks, I was too focused on takeMVar and putMVar but read and write look good.
10:32:14 <ertes> Lovepon: there are many very good javascript libraries for crypto, and you can just FFI into them
10:32:25 <Lovepon> ertes: Hmm
10:32:46 <dmj> cryptonite has issues on ghcjs, fair warning
10:32:49 <ertes> Lovepon: i promise your first 100 implementations will be insecure
10:33:01 <hackrilege> lol
10:33:24 <Lovepon> ertes: Yeah...
10:34:04 <hackrilege> is crypto really so easy in haskell, its a lot of ifs and elses and stuff right?
10:34:15 <Cale> Lovepon: What are you trying to do?
10:34:27 <Lovepon> Cale: RSA.
10:34:30 <ertes> Lovepon: if you can't get a somewhat widely used haskell library to work on GHCJS, your best option is to bind a javascript library (ideally you make your binding a haskell package)
10:34:36 <Cale> Lovepon: RSA in Haskell?
10:34:37 <Lovepon> Err
10:34:39 <Lovepon> Not RSA.
10:34:43 <Lovepon> Any key signing, I mean.
10:35:13 <hackrilege> https://hackage.haskell.org/package/hOpenPGP
10:35:33 * Clint squints.
10:36:04 <Cale> I saw mention of Javascript. Are you thinking about compiling something from Haskell to JS?
10:40:23 <Lovepon> Cale: Yes.
10:45:36 <Lovepon> omg
10:46:04 <Lovepon> oh.
10:57:07 <begriffs> Is there an MVar function which either puts a value into an empty mvar or replaces the value if it exists? Looks like putMVar will block if the var already has a value.
10:57:53 <begriffs> Do I have to check isEmptyMVar then putMVar else swapMVar?
10:58:53 * hackagebot time-recurrence 0.9.3 - Generate recurring dates.  https://hackage.haskell.org/package/time-recurrence-0.9.3 (ChrisHeller)
10:59:37 <Cale> begriffs: That won't work, because the MVar might become filled between the check and the putMVar
11:00:12 <Cale> begriffs: I think the real question is whether you really want an MVar at all, if that's an operation you need to perform.
11:01:43 <tzh> can't you use STM to make an atomic check-and-insert-or-replace function?
11:01:52 <Cale> Yes, for TMVars
11:02:07 <begriffs> The context is that my app caches state and updates that state when it receives a SIGHUP. Other parts of the app consult the state periodically.
11:02:41 <tzh> oh, i see
11:03:05 <Cale> Why is an IORef not okay? Are you relying on the blocking nature of MVars elsewhere?
11:03:38 <Oejet> begriffs: Perhaps something with tryPutMVar, which is non-blocking?
11:07:30 <begriffs> Oejet: like (\good -> unless good $ swapMVar state v) <$> tryPutMVar state v
11:08:28 <Cale> Surely you mean =<< there
11:09:07 <Cale> Also, the MVar might become empty after the tryPutMVar failed to write to it, but before the swapMVar
11:10:09 <begriffs> Cale: probably yeah, trying to compile it...
11:11:15 <begriffs> So I should probably just use STM because this is getting tricky.
11:11:49 <Cale> Quite possibly
11:12:59 <begriffs> Although maybe I don't have to worry. I have one producer of values, the sigint handler. Then I have a consumer which happens during web requests will readMVar which won't empty the variable, right?
11:13:23 <begriffs> In fact if I'm sure that I fill the variable at the start of the program I could unconditionally swap knowing that nobody would empty it.
11:15:14 <Ecatel>  just picked up a g
11:15:19 <Cale> begriffs: Well, how are you taking advantage of the blocking?
11:15:21 <Ecatel> gonna smoke this shit down
11:15:31 --- mode: ChanServ set +o Cale
11:16:46 <mpickering> Is there a way to turn a Lens s [a] into a Traversal s a?
11:17:06 <Cale> Ecatel: This channel is for discussion of the programming language Haskell. There's #haskell-offtopic if you want to talk with Haskell people about non-Haskell-related stuff.
11:17:10 --- mode: Cale set -o Cale
11:17:41 <Ecatel> I like to program stoned
11:17:53 <Ecatel> Theres nothing wrong with that
11:18:17 <int-e> Well, don't talk about it here.
11:18:50 <Ecatel> My apologies 
11:19:02 <Ecatel> I just have great enthusiasm for the plane
11:19:05 <Ecatel> plant*
11:19:12 --- mode: ChanServ set +o Cale
11:19:19 <Gurkenglas_> mpickering, that wouldn't be lawful if the length is changed
11:19:20 --- mode: Cale set +b *!*@77.243.183.72
11:19:20 --- kick: Ecatel was kicked by Cale (Ecatel)
11:19:24 --- mode: Cale set -o Cale
11:19:37 <begriffs> Cale: I don't know that I am taking advantage of blocking. Maybe MVar is actually something more powerful than I need. My scenario is that my program starts up, does an expensive calculation resulting in a value. Then another thread handles web requests and consults this value as needed. Sometimes the administrator will send SIGHUP to my program which should recalculate the value for future web requests to see.
11:21:00 <mpickering> Gurkenglas_: The length of what?
11:21:01 <Cale> begriffs: So I guess that if a web request comes in before the value is computed, you might want to block in that case
11:21:20 <Cale> ?
11:21:31 <nitrix> Hi, what would you guys recommend for spatial partitioning of an infinite keyspace (Integer) ?
11:21:54 <Cale> nitrix: Map?
11:21:56 <nitrix> The only operations I need are insert, adjust, delete and range (with lower and upper bound of a square region)
11:22:05 <Cale> ah, you want an interval map
11:22:05 <nitrix> Cale: They are 2D coordinates.
11:22:12 <begriffs> Cale: yes although I could just calculate the value before even executing the part of my code that starts the web server thread.
11:22:26 <Cale> nitrix: Wait, are the keys just points, or intervals?
11:22:44 <mpickering> maybe I don't need a traversal but I want to traverse over each a and get some information out of it
11:22:56 <Cale> nitrix: Oh, your Integer comment threw me off
11:23:14 <Cale> Your keys are pairs :)
11:23:30 <Cale> begriffs: Yeah, you might just want an IORef
11:23:33 <Gurkenglas_> mpickering, I was wrong, but: the length of the list. What that means, though, is only that you can't turn a Traversal' s a into a Lens' s [a]
11:23:49 <Gurkenglas_> :t _1 . each :: Traversal' ([a],b) a
11:23:50 <lambdabot> Applicative f => (a -> f a) -> ([a], b) -> f ([a], b)
11:24:25 <mpickering> Is there an indexed version as well?
11:24:27 <Gurkenglas_> :t (. each) :: Lens' s [a] -> Traversal' s a -- Why doesn't this work o.o?
11:24:28 <lambdabot>     Couldn't match type ‘(s0 -> f1 t0) -> s1 -> f1 s1’
11:24:28 <lambdabot>                    with ‘forall (f2 :: * -> *).
11:24:28 <lambdabot>                          Functor f2 =>
11:25:46 <Cale> nitrix: There's this kdt library which looks reasonable -- I haven't used it
11:25:51 <Cale> http://hackage.haskell.org/package/kdt
11:27:33 <nitrix> Cale: It seems all the libraries have a missing piece.
11:27:42 <nitrix> Cale: kdt for example has no removal :/
11:28:15 <Cale> nitrix: ah, hmm
11:28:37 <nitrix> Cale: By the way, would a quadtree perform better than a kdtree?
11:28:47 <Gurkenglas_> mpickering, what's the type signature you want for the indexed variant?
11:29:02 <nitrix> Cale: Considering the space is infinite and the data is sparse, but in the cluster where there are things, it's really dense?
11:29:54 <Cale> nitrix: I've only had the occasion to use spatial data structures in real projects one or two times, and I've never really done a careful comparison
11:31:09 <nitrix> Cale: Thanks still.
11:31:30 <nitrix> Guess I'll have to learn kdtrees and write my own :]
11:32:43 <MichaelK> hey, so I found a trick to get the derived type of a function for a particular instance (using where and a type hole, because ghc doesn't allow instance type holes). does anyone know a better way?
11:35:02 <Cale> MichaelK: Substitute the type variables in the class declaration for the types given in the instance head?
11:38:51 <MichaelK> Cale: sometimes I mess up parentheses etc. and want to check what is actually derived (whether constraints come through as I expect and the like)
11:39:35 <Cale> MichaelK: Yeah, in that case it's probably easiest just to either use a type hole or something which you definitely know isn't the type, and have a look at the type GHC complains it ought to be
11:40:37 <MichaelK> alright, thanks
11:41:11 <Cale> {-# LANGUAGE InstanceSigs #-}  will let you add signatures to your instance declarations
11:42:34 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#instance-sigs
11:43:11 <MichaelK> Cale: yup, already using that. though it doesn't let you use direct type holes in instances (thus: `where \n test :: _ \n test = funcToTest`)
11:53:01 <m1dnight_> Im trying to make Alex tokenize a blank line into a single token. But I can't seem to get my regexes working. 
11:53:33 <m1dnight_> Ive tried defining a regex macro like `$blank = ^\s*\n$` but it does not work.
11:55:10 <ertes> can a lens of type (Lens s s a b) where not (a ≃ b) ever satisfy the lens laws?
11:57:39 <Cale> ertes: It might be a composite of an ordinary lens with an Iso' a b
11:58:20 <ertes> Cale: but then a ≃ b
11:59:11 <Cale> Oh, that looked a lot like an equals sign :)
12:00:02 <ntnt> is it just me or is the power of free monads undervalued?
12:00:03 <Cale> ≅
12:00:17 <ntnt> it seems like one of these transformative things that takes any impure combo thingy and seprates it into a pure part and an impure interpreter
12:00:17 <Cale> ntnt: If anything, it's overvalued lately?
12:00:38 <ntnt> Cale: I dunno; I feel like this is going to chang e the way I write haskell
12:01:12 <ertes> Cale: not even sure which one is the correct one, but i have bound "≃" on my keyboard
12:01:13 <Cale> There's been a lot of hype about free monads... they're useful enough for sure.
12:01:19 <ertes> ntnt: i use them a lot
12:01:27 <ertes> ntnt: but always as a last resort
12:02:10 <ertes> ntnt: for me they are mostly useful in cases when i need semantic "delimiters" of some sort
12:02:31 <ntnt> ertes: by delmiters I think about () [] {} .. what do you have in mind for 'delimiters' ?
12:02:54 <ertes> ntnt: as a very simple example this is suspendable IO:  Free IO
12:03:02 <Cale> ntnt: I would be a lot happier with a world where people overused free monads than one where they overused monad transformers.
12:03:39 <Cale> ntnt: He means in the sense where you can run part of a computation up to the first delimiter and then resume it again later.
12:03:55 <ntnt> you mean like a continuation?
12:04:01 <ntnt> I like the Continuation Monad too
12:04:22 <ertes> ntnt: as a more interesting example see the 'pipes-group' library, which allows you to split a stream without giving up the streaming nature for the individual chunks
12:05:44 <ertes> currently i'm inventing a language for creating automata with orthogonal time flow, which is also based on free monads (which will eventually become the successor of netwire)
12:08:18 <super_java_man> hi!
12:19:46 <mpickering> Gurkenglas_: You can just use traverse to do what I wanted
12:21:35 <EvanR> ski: oops looks like i was reading it backward. im so used to reading from right to left when doing .
12:23:21 <lambdafan> hey begriffs!
12:23:23 <ski> EvanR : it takes as input a function that operates on the "marked/focused element" from the right, and returns to the left a function that operates on the nested structure containing this element, where the combinator itself expresses the path down to this element in the structure
12:23:42 <begriffs> lambdafan: hey there
12:23:47 <dolio> EvanR: When reading right to left when composing functorial mappings, you are reading inside to out.
12:24:16 <EvanR> so SEC is basically functorial mappings
12:24:52 <EvanR> this "pattern" is p awesome
12:25:09 <dolio> Yes.
12:25:25 <dolio> And traversals are like functorial mappings, and compose in the same way. Right is inside.
12:25:42 <dolio> Which is why lenses written as traversals compose that way automatically.
12:26:47 <EvanR> traversals as in Traversal from lens, not Traversable
12:27:10 <EvanR> right
12:27:10 <dolio> They're the same thing.
12:27:13 <EvanR> oh
12:27:25 <dolio> traverse is a Traversal.
12:27:25 <EvanR> right
12:27:34 <EvanR> its all coming together
12:27:38 <EvanR> head explode
12:32:16 <ertes> i'll assume that (Lens s s a b -> a isomorphic b) under the lens laws for now, because i can't construct a counterexample
12:37:53 <EvanR> LackOfImagination -> Void, Void -> a
12:38:06 <Gurkenglas_> mpickering, but traverse isn't indexed
12:38:45 <mpickering> What do indexed things do? I assumed that you just got given the index along with the element?
12:38:56 <Gurkenglas_> yep
12:39:38 <Gurkenglas_> :t traverse
12:39:39 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:39:40 <Gurkenglas_> :t itraverse
12:39:41 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
12:40:45 <Gurkenglas_> :t traverse . itraverse -- note that these compose
12:40:46 <lambdabot> (Applicative f, Traversable t, TraversableWithIndex i t1) => (i -> a -> f b) -> t (t1 a) -> f (t (t1 b))
12:41:37 <mpickering> ok, so the whole thing I want to do is use a Lens s [a] and a Lens a b and turn it into a Traversal s (Int, b)
12:41:50 <Gurkenglas_> (As in, you can compose a traversal with an indexed traversal - you traverse over the outer thing, and then do a traversal over each inner thing, giving the function that is passed into itraverse access to a local index)
12:43:23 <WarDaft> Is there any way to section entailment, or do something equivalent? That is to say, can I make a GADT that works like it had the type SomeGadt (~a)?
12:43:58 <ski> Gurkenglas_ : .. and if you want both the index for the inner and the outer structure ?
12:44:18 <super_java_man> what's a good, lightweight solution to using javascript w/ haskell that doesn't involve a transpiler? julius? anything else?
12:47:24 <Gurkenglas_> :t (undefined :: Lens' s [a]) . itraversed . (undefined :: Lens' a b) -- hmm why isn't this indexed anymore
12:47:25 <lambdabot> Applicative f => (b -> f b) -> s -> f s
12:48:01 <Gurkenglas_> ski, that can only possibly work if the outer structure is index-traversable, you see why?
12:51:45 <Gurkenglas_> :t (undefined :: Lens' s [a]) . itraversed . (undefined :: IndexPreservingLens' a b) -- ah there we go.
12:51:47 <lambdabot> (Applicative f, Indexable Int p) => p b (f b) -> s -> f s
12:52:13 <Gurkenglas_> What Lens is not index preserving?
12:53:56 * hackagebot tagged 0.8.4 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  https://hackage.haskell.org/package/tagged-0.8.4 (ryanglscott)
12:54:58 <ertes> super_java_man: jmacro, julius…  then your program is the compiler to javascript (from an AST)
12:58:09 <Gurkenglas_> :t (undefined :: Lens' s [a]) . itraversed . cloneIndexPreservingLens (undefined :: Lens' a b) -- I guess ekmett hasn't gotten around yet to making "Lens' s a" a classy subtype of "IndexPreservingLens' s a" yet
12:58:10 <lambdabot> (Applicative f, Indexable Int p) => p a (f a) -> s -> f s
12:58:49 <super_java_man> ertes do you have a preference b/w julius vs. jmacro?
13:00:45 <mpickering> Gurkenglas_: I still don't understand how that gets me what I want but thanks for trying
13:01:14 <Gurkenglas_> mpickering, what do you call your Lens' s [a] and Lens' a b?
13:01:26 <mpickering> players and machines
13:01:36 <mpickering> Your example doesn't typecheck for me, that's the problem
13:02:11 <mpickering> ah I missed off the 'd'
13:02:29 <mpickering> but it still returns [a] when viewed rather than [(Int, a)]
13:02:51 <Gurkenglas_> Right, giving you direct access to the Int would allow you to modify it and break all the laws
13:03:00 <Gurkenglas_> indexed traversals are used like this:
13:03:39 <super_java_man> as limiting as Elm is, i really like how you can do little 1 file projects. purescript and ghcjs have so much project & build system scaffolding to do anything =/
13:05:39 <muesli4> Hi, I need a library for downloading a simple JSON file via http, is there something with very few dependencies?
13:05:45 <Gurkenglas_> *furiously reads lens docs - that's lazy teaching for ya*
13:06:32 <super_java_man> muesli why are you worried about dependencies?
13:07:16 <dmj`> muesli: servant-client
13:07:19 <dmj`> @package servant-client
13:07:19 <lambdabot> http://hackage.haskell.org/package/servant-client
13:07:31 <super_java_man> muesli4 it's been a while since i used it but wreq is probably decent for that sort of thing. it has lens as a dependency though
13:07:52 <Gurkenglas_> > iover itraversed (+) [100,100,100,100,20] -- mpickering
13:07:54 <lambdabot>  [100,101,102,103,24]
13:09:19 <Gurkenglas_> (Rule of thumb: Put i before the thing that turns a lens into something usable, or @ between the two symbols of an operator that gets a lens on its left side
13:09:21 <Gurkenglas_> *)
13:09:46 <muesli4> super_java_man: I'm always worried about dependencies, seems kind of logical to me.
13:09:47 <Gurkenglas> (And then the second argument will take an extra first argument for the index)
13:10:45 <muesli4> super_java_man: because if one dependency breaks, the whole project won't work
13:10:46 <super_java_man> muesli4 unless i'm doing some containerized thing, i'll take a solid library with heavy-duty dependencies over a standalone one that's going to be abandoned in a few months any day
13:11:11 <super_java_man> meusli4 stackage does reasonably well solving that though
13:11:52 <Welkin> hola como estas?
13:12:10 <super_java_man> hi Welkin
13:13:32 <Welkin> super_java_man: homo erectus erectus?
13:14:11 <Welkin> nietzsche's super-man from the pleistocene
13:15:36 <super_java_man> ?
13:16:19 <Welkin> super_java_man: the popular name of an early human skeleton
13:16:20 <Welkin> https://en.wikipedia.org/wiki/Java_Man
13:16:49 <michaelt> muesli4: http://hackage.haskell.org/package/http-client 
13:19:28 <ski> Gurkenglas : does "the outer structure is index-traversable" mean something different than (also) the outer structure supporting `itraverse' ?
13:20:47 <mpickering> Gurkenglas: Which laws get broken?
13:23:29 <Gurkenglas> ski, that's what I mean
13:23:55 <Gurkenglas> mpickering, you could change the Int, changing where in the structure the thing is
13:24:53 <shanemikel> I'm playing around with c2hs .. Is there a nice clean way to deal with the #const directives for scmBoolT and scmBoolF? They aren't defined as values but as expressions... my chs file -> http://lpaste.net/4989781670350553088 ... and my hs output -> http://lpaste.net/4776777384395276288
13:27:38 <ski> Gurkenglas : ok, but that's obvious, no ? :)
13:28:11 <hackrilege> hwy when i write a MonadPlus instance am i forced to define <*>
13:28:12 <hackrilege> ???
13:28:15 <hackrilege> why*
13:28:40 <ski> hackrilege : `instance Applicative Blah where pure = return; (<*>) = ap'
13:29:01 <ski> `Applicative' is a superclass of `Monad', which is a superclass of `MonadPlus'
13:29:10 <hackrilege> but it makes no sense to have <*> for all MonadPlus
13:29:16 <ski> yes it does
13:29:59 <ski> any monad has `ap', which is (arguably, Cale ?) what `<*>' should do for it
13:30:04 <hackrilege> but my Container may be of arbritrary shape. only zipWith infinite can be used for ap
13:30:24 <hackrilege> :t ap
13:30:26 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:30:32 <ski> @src ap
13:30:32 <lambdabot> ap = liftM2 id
13:30:44 <ski> @src liftM2
13:30:44 <lambdabot> liftM2 f m1 m2 = do
13:30:44 <lambdabot>     x1 <- m1
13:30:44 <lambdabot>     x2 <- m2
13:30:44 <lambdabot>     return (f x1 x2)
13:30:44 <Cale> ski: Well, I guess we're going that way :)
13:30:52 <ski> so
13:31:15 <ski>   ap mf ma = do f <- mf; a <- ma; return (f a)
13:31:29 <ski> is what `(<*>)' will then do, in terms of `return' and `(>>=)'
13:31:43 <RyanGlScott> shanemikel: Unfortunately, I don't think c2hs is well equipped to deal with those sorts of constants.
13:31:49 <RyanGlScott> You pretty much have two options:
13:31:58 <hackrilege> what would you expect to happen if i tried to lift a function over two Trees of differenct shape?
13:32:13 <ski> hackrilege : if you don't care for the idiomatic combinators `pure',`(<*>)' for your type, then don't use them ?
13:32:22 <RyanGlScott> 1. Define wrapper functions around SCM_BOOL_T/SCM_BOOLF/whatever
13:32:25 <ski> depends on how the monad is defined
13:32:36 <RyanGlScott> (which is the approach the bindings-dsl library automates)
13:33:09 <RyanGlScott> or 2. Try using the capi calling convention: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html#ffi-capi
13:33:28 <kadoban> hackrilege: I would imagine you have the same choice as the difference between the Applicative instances for [] and for ZipList
13:33:42 <hackrilege> right
13:33:57 <hackrilege> > [1] <*> [2]
13:33:58 <lambdabot>      Could not deduce (Num a0)
13:33:58 <lambdabot>      from the context (Num a, Num (a -> b))
13:33:58 <lambdabot>        bound by the inferred type for ‘e_112’:
13:34:20 <RyanGlScott> Disclaimer: I've never used capi, so I don't know how well it works
13:34:25 <hackrilege> > (+) <$> [1] <*> [2]
13:34:26 <ski> > [succ,pred] <*> [7,11]
13:34:27 <lambdabot>  [3]
13:34:28 <lambdabot>  [8,12,6,10]
13:34:43 <ski> > getZipList (ZipList [succ,pred] <*> ZipList [7,11])
13:34:45 <lambdabot>  [8,10]
13:35:05 <ski> (so you get the "diagonal")
13:35:10 <hackrilege> right
13:35:46 <hackrilege> not sure which i want really
13:36:05 <hackrilege> guess i just find out which is resulting from my definition of >>=
13:37:43 <shanemikel> RyanGlScott: in this specific case, I really only need to transform scm_tc8_flag with the underscoreToCase function and remove the cast
13:38:44 <shanemikel> because all of the symbols in the expr are available after the cpp
13:40:10 <ski> hackrilege : how does your tree type look like ?
13:40:42 <hackrilege> pretty funky
13:41:10 <hackrilege> unspecified actually
13:41:13 <ski> nonregular ? GADT ?
13:41:28 <ski> mhm
13:41:47 <hackrilege> UndecidableInstances , AllowAmbiguousTypes , IncoherentInstances
13:41:51 <hackrilege> lol
13:42:01 <hackrilege> incoherent...
13:42:09 <RyanGlScott> shanemikel: I'm not familiar at all with libguile, so I have no idea what you're intending to do. But dealing with functions that are implemented with the preprocessor is always a bit of a challenge, unfortunately.
13:42:21 <Sornaensis> IncoherentInstances?
13:42:25 <Welkin> programming Haskell, the Franz Kafka way
13:42:51 <RyanGlScott> What I do know is that c2hs doesn't have anything at the moment which can deal with them, so you'll either have to make a PR to c2hs to add support for them, or deal with them manually via the FFI.
13:43:08 <hackrilege> its here if you want to see it
13:43:09 <hackrilege> http://lpaste.net/161299
13:43:58 * hackagebot morte 1.6.0 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.0 (GabrielGonzalez)
13:44:20 <shanemikel> ok, thanks.  if it's a challenge for experienced people, I'm afraid to acknowledge the likely outcome for me
13:45:00 <RyanGlScott> It doesn't have to be a challenge. At worst, you can define a C function that just SCM_BOOL_T, and use c2hs to bind to that.
13:45:19 <RyanGlScott> (I was a bit too pessimistic with my word choice earlier.)
13:45:29 <Welkin> are you integrating with guile scheme?
13:45:57 <lambda-11235> If I have a function that checks some property I could have it return a Bool, but what if I want to return an error message when it would return False? Should I Maybe String, Either String (), or what?
13:46:13 <lambda-11235> * Should I return
13:47:05 <Welkin> lambda-11235: if you want to include an error message on possible failure, use Either
13:47:12 <Welkin> there is also ErrorT
13:48:15 <lambda-11235> Welkin: Ok, thanks.
13:49:41 <ski> lambda-11235 : also consider using datatype for the error message(s), instead of a `String'
13:49:45 <ski> @quote stark
13:49:46 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
13:51:44 <hackrilege> the universe began when god wrote the Burrito Monad
13:55:31 <slack1256> is there a Traversable like class for transforming (Just 5, Just 6) in Just (5,6)
13:55:45 <Welkin> traverse
13:55:49 <slack1256> because of the Functor instance it only cares about the second part of the tuple
13:56:04 <Welkin> oh
13:56:06 <Welkin> yeah I forgot
13:56:07 <Welkin> haha
13:56:23 <Welkin> I don't think there would be anything to do that then
13:56:36 <shanemikel> okay, stupid question.. so you mean like this: http://lpaste.net/8273513910238183424
13:56:44 <kadoban> :t uncurry $ liftA2 (,)
13:56:45 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
13:56:58 <RyanGlScott> shanemikel: Yes, precisely.
13:57:02 <slack1256> Mmm I will use Lists instead of a tuple, then I will change back to
13:57:04 <shanemikel> do I need a separate header?
13:57:09 <Welkin> lol kadoban 
13:57:25 <troydm> is it possible to get client Socket directly in warp request?
13:57:52 <troydm> or at some point of HTTP request processing, like for example after HTTP header was read 
13:57:53 <RyanGlScott> shanemikel: Yes, I imagine you'll need a header file for scm_bool_t and friends in order for the FFI to figure out that they exist.
14:01:12 <ski> > sequenceA (Just 5,Just 6)
14:01:13 <lambdabot>  Just (Just 5,6)
14:01:47 <ski> > both id (Just 5,Just 6)
14:01:48 <lambdabot>  Just (5,6)
14:02:02 <lambdafan> :t both
14:02:03 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
14:02:16 <lambdafan> !!!
14:02:21 <ski> optics
14:03:53 <lambdafan> :t both id (Just 5,Just 6)
14:03:54 <lambdabot> Num b => Maybe (b, b)
14:04:06 <ski> RyanGlScott : hm .. i wonder whether it would be possible to put those in static variables instead of in functions
14:04:33 <ski> > traverse id (Just 5,Just 6)  -- cf.
14:04:34 <lambdabot>  Just (Just 5,6)
14:04:47 <ski>   sequenceA = traverse id
14:07:09 <RyanGlScott> ski: That's also an option. Either way, you're going to need a foreign import.
14:07:38 <ertesx> super_java_man: my preference is not to use either: GHCJS =)
14:07:55 <super_java_man> man trying to use ghci for interactive scientific computing is bumming me out a bit. anyone have suggestions to improve it?
14:08:34 <super_java_man> for example, it sucks to have to re-load data when i make a code change
14:08:39 <Welkin> super_java_man: try using haskell notebook
14:08:49 <super_java_man> welkin IHaskell / Jupyter?
14:08:51 <RyanGlScott> I'm not sure if c2hs is smart enough to know about global variables.
14:09:05 <RyanGlScott> I know bindings-dsl has support for them.
14:09:05 <lpaste> tippenein pasted “file input validation - yesod” at http://lpaste.net/161303
14:09:19 <super_java_man> welkin that works okay for writing simple tutorials, but for more complex analyses the notebook format is too linear
14:09:55 <ertesx> super_java_man: what's bad about reloading data?  does it take too long?
14:09:59 <tippenein> Wondering if it's possible to use validations on fileAFormReq 
14:10:15 <super_java_man> ertesx yes
14:10:55 <ertesx> super_java_man: 1) because of the size or 2) because parsing it takes a lot of CPU time?
14:10:57 <Welkin> tippenein: I never tried
14:10:57 <super_java_man> even for small datasets, it means 30 seconds per iteration for a small code change vs. nearly 0 in python or r
14:11:01 <Welkin> tippenein: try asking in #yesod though
14:11:15 <super_java_man> for larger datasets, it sucks to have to wait minutes because i added a few lines of code
14:11:23 <Welkin> I'm sure you can validate certain things, like file type, size, and other metadata
14:11:50 <ertesx> super_java_man: with :m + and :m - you can load and unload modules without undefining everything that is currently in scope
14:12:10 <super_java_man> ertesx ooh did not know that will give it a try
14:12:11 <ertesx> super_java_man: also you can tell GHC to compile instead of interpret
14:12:22 <super_java_man> ertesx how?
14:12:33 <tippenein> Welkin: yeah, I guess I'm just confused because fileAFormReq returns a form and not a field
14:12:39 <ertesx> super_java_man: :set -fobject-code -O
14:13:10 <super_java_man> ertesx niiice
14:13:35 <super_java_man> :m may be a game changer for me
14:13:41 <ertesx> super_java_man: if you use haskell-interactive-mode, you may want to set -fforce-recomp as well, otherwise you will only see warnings on the first C-x C-l
14:13:42 <super_java_man> :r was harshin my vibe
14:13:59 * ski . o O ( `const SCM scm_bool_t = SCM_BOOL_T;',`foreign import ccall "grovel.h &scm_bool_t" pScmBoolT :: Ptr ScmBool' )
14:14:13 <t0by> Forgive me, stupid question, suppose I have
14:14:14 <ski> shanemikel,RyanGlScott : i suppose i was thinking of something like ^
14:14:18 <t0by> > let f = (\(a:as) -> (reverse (a), (intercalate "," as))).(splitOn ",")
14:14:19 <lambdabot>  <no location info>:
14:14:19 <lambdabot>      not an expression: ‘let f = (\(a:as) -> (reverse (a), (intercalate "," a...
14:14:28 <t0by> huh?
14:14:38 <t0by> > f = (\(a:as) -> (reverse (a), (intercalate "," as))).(splitOn ",")
14:14:40 <lambdabot>  <hint>:1:3: parse error on input ‘=’
14:14:43 <ski> missing `in'
14:14:55 <t0by> gah, right
14:15:11 <super_java_man> ertesx super cool
14:15:12 <ertesx> super_java_man: keep one difference in mind: if -fobject-code is active, you can only access exported definitions
14:15:15 <t0by> > let f = (\(a:as) -> (reverse (a), (intercalate "," as))).(splitOn ",") in f "foo,bar,baz"
14:15:16 <lambdabot>  ("oof","bar,baz")
14:16:02 <super_java_man> pretty excited to try this out
14:16:05 <shanemikel> ski: Do I need to use a Ptr?
14:16:51 <ski> shanemikel : it's just an alternative to using a function. might perhaps be nicer. not sure
14:17:02 <t0by> suppose I have the above. I would like to wrap it into a function g :: String -> [String] that gives me ["oof", "rab", "zab"]. Is there a better way than something like g z = (\(a,b)->a : (q b)) g z ? 
14:17:13 <t0by> It seems... un-functional to me
14:17:37 <ski> shanemikel : obviously you'd wrap it on the Haskell side with a dereference (with `unsafePerformIO', which should be safe, because it's `const')
14:19:59 <ertesx> super_java_man: you should put your types into a separate module, because when a module changes, its types are probably no longer identical to the ones in the previous version
14:20:12 <ertesx> define your types, then: :m +Blah.Types
14:20:21 <ertesx> then work on Blah.Utils or something
14:21:09 <super_java_man> ertesx i'm still struggling a bit on how to deal with data for analysis. oscillating between types vs. Map type structures
14:21:51 <ski> > let f = map reverse . splitOn "," in f "foo,bar,baz"
14:21:52 <ski> > let f = intercalate "," . map reverse . splitOn "," in f "foo,bar,baz"
14:21:53 <lambdabot>  ["oof","rab","zab"]
14:21:54 <lambdabot>  "oof,rab,zab"
14:21:57 <ski> t0by ^ ?
14:21:58 <ertesx> super_java_man: it depends on your algorithms and your data
14:22:30 <super_java_man> ertesx well i'm trying to substitute for data frame style workflows in pandas/python and dplyr/r
14:22:46 <super_java_man> i've been trying vectors of records, but it's really klunky
14:23:25 <ertesx> super_java_man: i have no clue about python, but i can give you some general advice: if you're going for maximum speed, use the most memory-compact data structure that gives you reasonable asymptotics for your problem
14:23:34 <zigschots20> Good evening :). I'm having some issues with stack (possibly git), would here be a good place to ask about it?
14:23:35 <ertesx> speed speed speed = cache cache cache = compact compact compact
14:23:38 <t0by> ski: sorry, I have not been clear. f is given (and slightly more complex than that, for that matter). What I'd like is a clean way of taking a looong input string, feeding it to f that partially consumes it and gives me a (result, remainderofinput), enqueue the result to a list and recursively apply it to remainderofinput.
14:23:44 <ski> @let onSplits :: String -> ([String] -> [String]) -> (String -> String); onSplits = splitOn "," ~> intercalate ","
14:23:46 <lambdabot>  .L.hs:152:12:
14:23:46 <lambdabot>      Couldn't match type ‘[String] -> [String]’ with ‘[Char]’
14:23:46 <lambdabot>      Expected type: ([String] -> [String]) -> [[Char]]
14:23:59 <ski> @let onSplits :: String -> ([String] -> [String]) -> (String -> String); onSplits delim = splitOn delim ~> intercalate ","
14:24:00 <lambdabot>  Defined.
14:24:12 <ertesx> zigschots20: yeah
14:24:16 <ski> > (onSplits "," . map) reverse "foo,bar,baz"
14:24:17 <lambdabot>  "oof,rab,zab"
14:24:22 <Gurkenglas> ski, I meant that as a hint that you should try composing indexed traversals with indexed traversals, but I just checked and actually that doesn't work :x
14:24:34 <zigschots20> ertesx: great, thanks
14:24:40 <Gurkenglas> (in the sense that the index is still local)
14:24:45 <ski> @let perSplits :: String -> (String -> String) -> (String -> String); perSplit delim = onSplits delim . map
14:24:46 <lambdabot>  .L.hs:153:1:
14:24:46 <lambdabot>      The type signature for ‘perSplits’ lacks an accompanying binding
14:24:47 <RyanGlScott> shanemikel: You have to use a Ptr in that sort of foreign import because it could refer to a mutable variable.
14:24:52 * ski sighs
14:24:58 <super_java_man> ertesx like unboxed vectors?
14:24:58 <ski> @let perSplit :: String -> (String -> String) -> (String -> String); perSplit delim = onSplits delim . map
14:24:59 <lambdabot>  Defined.
14:25:10 <ski> > perSplit "," reverse "foo,bar,baz"
14:25:12 <lambdabot>  "oof,rab,zab"
14:25:47 <RyanGlScott> In this kind of scenario, I sometimes peek underneath the Ptr and put that in a constant Haskell expression. 
14:25:53 <ertesx> super_java_man: that's one example, but it depends on your data and algorithms
14:25:56 <super_java_man> ertesx at this point i'm trying to tweak a rapid-iteration workflow that works.  i'll worry about performance when i solve that
14:25:59 <t0by> ski, ie I'm looking for a clean way of doing g on *any* f that consumes part of a string and spits a (result, restofinput) tuple. You can assume that g doesn't even care about commas but does some sort of more complex parsing.
14:25:59 <ski> t0by : and when to terminate ? use `Maybe' ?
14:26:04 <RyanGlScott> Probably one of the only times I use unsafePerformIO.
14:26:14 <ertesx> super_java_man: i think it's solved now =)
14:26:17 <t0by> ski: my bad, my g misses case z of "" -> []
14:26:21 <ski> Gurkenglas : oh, so how do it ?
14:26:33 <Gurkenglas> lambdabot patch idea: Give it a config that allows you to tell it that if you give it a query that answers via stderr, that answer goes to you in a query instead.
14:26:40 <ski> t0by : type error, the other branch gives a pair
14:26:41 <Gurkenglas> ski, well uh let me do some furious docs reading :D
14:26:46 <zigschots20> I just bootstrapped my machine to Arch, and installed stack from the repos (version 1.0.4.3). Whenever I try to invoke stack commands (e.g. stack setup) I get errors of the form: "error: inflate: data stream error (invalid distance too far back)
14:26:46 <zigschots20> fatal: pack has bad object at offset 1677222: inflate returned -3
14:26:46 <zigschots20> fatal: index-pack failed"
14:27:23 <ertesx> super_java_man: even just -fobject-code -O will help a lot…  also improving your loader and data structures will help
14:28:11 <ski> t0by : oh, you said `g', not `f' ..
14:28:20 <zigschots20> This seems to be coming from git being asked to "fetch --tags -depth=1" in .stack/indices/Hackage/git-update/all-cabal-hashes/
14:28:37 <ski> t0by : well, i suppose you're hoping or making sure `f' won't barf on some input, then
14:28:51 <ski> Gurkenglas :)
14:28:52 <super_java_man> ertesx yeah thanks for that! kinda wish frames was further along, don't think it's going to be the solution though
14:29:01 <zigschots20> Which i can repro by trying to execute that command in that folder
14:29:11 <ertesx> super_java_man: frames?
14:29:21 <shanemikel> how about this example from the page you linked? `foreign import capi "pi.h value pi" c_pi :: CDouble`
14:29:27 <super_java_man> https://github.com/acowley/Frames
14:29:33 <t0by> ski: you can safely assume that f is String -> (t, String) where t is *some* type and String is the possibly empty remainder of the input that has been partially consumed.
14:29:40 <ski> Gurkenglas : note that i'm doing lazy delegated teaching of indexed traversals ;)
14:29:48 <t0by> Question is, how do I recursively call f over my input until it has been completely consumed?
14:29:50 <ski> (well, with a roundtrip)
14:29:52 <super_java_man> or something else that can do relational table-esque operations without a DB backend
14:29:59 <t0by> (And put the results into a list?)
14:30:07 <zigschots20> I was wondering if anyone had seen this issue before? (And knows how to fix it)
14:30:08 <ski> t0by : and that `f' won't fail for some input ?
14:30:51 <RyanGlScott> ski: I think that will work. But be aware that c2hs doesn't have any sugar for that, AFAIK
14:30:59 <super_java_man> ertesx it's a cool idea, but in the end the template haskell + record manipulation is too clunky. for example, if I load two CSVs in one file and they have common column name
14:31:20 <super_java_man> that breaks name resolution with records
14:31:37 <t0by> ski: well, the signature is not a Maybe tuple, so... if f actually errors out it just does, I guess. I don't care a terribly great lot about that
14:31:40 <ertesx> super_java_man: looks like overengineering to me
14:31:49 <ski> @type \f -> unfoldr (\s -> do guard (not (null s)); Just (f s))  -- t0by, like this (if you replace `t' with `[]' and `a1' with `Char') ?
14:31:50 <lambdabot> Foldable t => (t a1 -> (a, t a1)) -> t a1 -> [a]
14:32:01 <super_java_man> yeah, feels like an interesting hack, but ultimately the wrong solution
14:32:02 <ski> RyanGlScott, *nod*
14:32:11 <RyanGlScott> Oops sorry, wrong target :)
14:32:14 <Gurkenglas> ski, in a 2-circle or a acyclic 2-path?
14:32:18 <RyanGlScott> shanemikel: I think that will work. But be aware that c2hs doesn't have any sugar for that, AFAIK
14:32:40 <ertesx> super_java_man: the best way to process a lot of data is not to load it
14:32:47 <shanemikel> well, I'm on a diet anyhow
14:32:59 <ski> > (\f -> unfoldr (\s -> do guard (not (null s)); Just (f s))) (head . reads) "0 1 2 3"  :: [Integer]
14:33:01 <lambdabot>  [0,1,2,3]
14:33:13 <t0by> Thank you
14:33:18 <t0by> Stupid me
14:33:23 <RyanGlScott> It would probably be easy to add to c2hs, though... it already has keywords for safe and unsafe
14:33:24 <super_java_man> most of my datasets are not so large that a streaming approach or DB backend make sense
14:33:31 <t0by> ski: thanks for reminding that fold exists exactly for this kind of purpouse
14:33:34 <super_java_man> it's on the order of megs
14:33:44 <ski> > (unfoldr . (listToMaybe .)) reads "0 1 2 3"  :: [Integer]
14:33:46 <lambdabot>  [0,1,2,3]
14:34:05 <ertesx> super_java_man: streaming abstractions don't become sensible, when the data is large, but when it's streamed
14:34:07 <super_java_man> big & complicated enough to be klunky to work with using explicit ADTs and vectors, not big enough to warrant internalizing in postgres
14:34:20 * t0by slaps self
14:34:20 <ski> t0by : that uses the `Maybe' in `unfoldr' to let `f' (here `reads') tell when to terminate, instead of explicitly checking for empty list
14:34:45 <ski> > unfoldr (listToMaybe . reads) "0 1 2 3"  :: [Integer]  -- same thing, perhaps more comprehensibly written
14:34:47 <lambdabot>  [0,1,2,3]
14:34:54 <ski> @type listToMaybe . reads
14:34:55 <lambdabot> Read a => String -> Maybe (a, String)
14:35:12 <ertesx> super_java_man: there is no size threshold above with streaming becomes sensible…  i often stream very small data, because for the way i process it, streaming is natural
14:35:13 <t0by> ski: I don't fully see the need for that bit
14:35:21 <ertesx> s/with/which/
14:35:27 <ski> t0by : anyway, this is why i was asking whether `f' could signal parse failure
14:36:09 <super_java_man> ertesx would you recommend pipes? i haven't done much streaming before. working with datasets of this size, in python and R just loading it all in memory is not a big deal
14:36:40 <ertesx> super_java_man: yes, pipes is a good choice
14:37:14 <Zemyla> I have a question about many.
14:37:28 <Gurkenglas> > fromJustNote "many" $ evalStateT (many $ StateT $ listToMaybe . reads) "1 2 3 4 5" :: [Int]
14:37:30 <lambdabot>  [1,2,3,4,5]
14:38:20 <Gurkenglas> > evalState (manyLazy $ StateT $ listToMaybe . reads) "1 2 3 4 5" :: [Int] -- uses http://lpaste.net/150858
14:38:22 <lambdabot>  [1,2,3,4,5]
14:38:23 <Zemyla> Would many ls = let mls = []:(liftA2 (:) ls mls) in mls be a compliant implementation of many, even though it puts the empty list first?
14:39:27 <Gurkenglas> > NE.head $ evalStateT (manyLazy $ StateT $ reads) "1 2 3 4 5" :: [Int] -- also uses http://lpaste.net/150858
14:39:29 <lambdabot>  [1,2,3,4,5]
14:40:22 <super_java_man> ertesx i will have to give pipes a try. i've seen a couple videos but haven't gotten around to using it for sometihing
14:40:26 <ski> yes, `StateT' is nice here :)
14:41:23 <ski> Gurkenglas, that's a lot of revisions
14:41:26 <Gurkenglas> Zemyla, no, in particular Maybe's instance of Alternative is left-biased
14:42:03 <Gurkenglas> ski, on the lpaste you mean? Ya I'm planning to turn that into a bachelor's thesis
14:43:14 <Zemyla> Gurkenglas: So the compliant implementation is one that always returns bottom?
14:43:36 <Gurkenglas> Zemyla, for Maybe and [], yes, that's why I made that
14:44:07 <Gurkenglas> (And any other left-strict Alternative)
14:45:29 <Gurkenglas> (many (Just 2) has two fixed points according to its specification: Just (repeat 2) and undefined. I argue that we should strive to implement the largest fixpoint that "doesn't make choices", as in doesn't choose a constructor where we could have chosen another)
14:47:32 <Gurkenglas> (being rid of the fromJust and head is just a nice side effect)
14:47:41 <Zemyla> Well, it feels like it should produce the most defined value that's a fixedpoint.
14:48:02 <ertesx> super_java_man: check out the documentation of the Pipes.Tutorial module
14:48:10 <ski> Gurkenglas : oh, i str seeing you(?) mention this paste idea earlier
14:48:17 <Gurkenglas> Nah, id has everything be a fixpoint and we shouldn't have fix id return anything other than undefined
14:48:29 <Gurkenglas> "str"? Ya I did
14:48:52 <Zemyla> (And actually, it should retur many ls = let mls = []:(liftA2 (flip (:)) mls ls) in mls, thus giving ls's powerset.)
14:49:02 <athan> how can I get stack to _not_ use a locally installed GHC when I issue `stack setup`?
14:49:39 <super_java_man> ertesx will do
14:50:07 <Gurkenglas> Zemyla, many is not the powerset operation - many turns ['0'..'9'] into a list of all natural numbers written in decimal... with infinite leading zeroes and starting from the left :P
14:50:24 <ski> Gurkenglas : was it you who mentioned the paper on cycamores to me ?
14:50:42 <ski> Gurkenglas : "str" being "seem to recall/remember"
14:50:42 <Gurkenglas> ski, dont think so. A paper, already? Dangit
14:52:27 <Gurkenglas> ski, did you mean you're teaching indexed traversals to me or another?
14:52:31 <Zemyla> Gurkenglas: Well, it just feels incredibly wrong.
14:53:05 <orion> Does anyone know why this function returns a String instead of a bytestring?: http://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-IO-ByteString.html#v:fdRead
14:53:11 <dolio> Zemyla: The 'problem' is that your definition is 'many p = pure [] <|> ((:) <$> p <*> many p)', but that is also undesirable for some Alternatives.
14:53:25 <dolio> Which are arguably more important than lists.
14:53:33 <Zemyla> dolio: Yes, left-biased parsers in particular.
14:53:42 <ski> Gurkenglas : "Cycle Therapy: A Prescription for Fold and Unfold on Regular Trees" by Franklyn Turbak,J. B. Wells in 2001 at <http://cs.wellesley.edu/~fturbak/pubs/ppdp01.pdf>
14:54:05 <ski> Gurkenglas : er, to myself, perhaps ?
14:54:07 <dolio> So, if the specification is that 'many' must match some fixed point definition like that, it will be wrong for some things.
14:54:27 <Gurkenglas> Zemyla, many stands for "as many as possible" (while some stands for as some as possible hurk hurk hurk), you could use the reversed alternative instance to get many to do your version though I guess
14:54:45 <Zemyla> Well, then if it does return bottom, then shouldn't it specifically say so in the function?
14:54:59 <ski> Gurkenglas : anyway, they did something like find a non-least fixed point, which i thought sounded similar to what you were describing above
14:55:03 <Welkin> some would some mean "at least one", right?
14:55:05 <ski> Gurkenglas : might be worth a look
14:55:07 <Gurkenglas> It happens to be bottom for the left-strict alternatives
14:55:08 <Zemyla> many [] = [[]]; many _ = error "many []: Infinite list result".
14:55:19 <zigschots20> orion: see the package unix-bytestring ;)
14:56:28 <Gurkenglas> Zemyla, if we can get them to modify Alternative at all we should rather have them fix the specification :D
14:56:33 <geekosaur> orion, the ByteString functions in unix are not about ByteString data, but ByteString pathnames
14:56:51 <geekosaur> but it replicates the String-based interfaces so includes things like fdRead
14:57:00 <orion> I see.
14:57:08 <geekosaur> rathetr than making you import only the pathname functions from one and the rest from the other
14:57:51 <maerwald> orion: also comment on https://github.com/haskell/unix/issues/35
14:58:00 <Zemyla> > let mls = []:[a:ls | ls <- mls, a <- ['a', 'b']] in mls
14:58:01 <lambdabot>  ["","a","b","aa","ba","ab","bb","aaa","baa","aba","bba","aab","bab","abb","b...
14:58:08 <maerwald> String is wrong for that function from every angle
14:58:59 <Zemyla> Do we have a powerset function for lists, though?
14:59:33 <Gurkenglas> :t filterM (const [False, True]) -- cmon isnt that on like every "blow your mind oneliner" haskell thread
14:59:35 <lambdabot> [b] -> [[b]]
14:59:56 <dolio> That isn't even a powerset.
14:59:57 <Gurkenglas> -haskell+reddit
14:59:57 <maerwald> String is probably one of the bigger mistakes that happened in haskell
15:00:12 <orion> geekosaur: How do you import both unix and unix-bytestring if they have conflicting module names?
15:00:19 <Welkin> String is not a mistake...
15:00:20 <maerwald> orion: there's a GHC extension
15:00:26 <Welkin> it is useful for its purpose
15:00:27 <dolio> It's all possible strings made with that alphabet.
15:00:33 <Welkin> there is also Text, and ByteString
15:00:36 <dolio> Finite strings, anyway.
15:00:52 <orion> That's annoying. :/
15:00:53 <maerwald> orion: {-# LANGUAGE PackageImports #-}
15:00:58 <Zemyla> dolio: Oh, yeah, you're right.
15:01:08 <maerwald> and then: import qualified "unix" System.Posix.IO.ByteString as SPI and import qualified "unix-bytestring" System.Posix.IO.ByteString as SPB
15:01:10 <maerwald> for example
15:01:34 <Zemyla> Powerset would be filterM (const [False, True]).
15:05:50 <zigschots20> So some poking around seems to suggest (as far as my system is concerned) there are some issues with the all-cabal-hashes
15:06:04 <zigschots20> stack balks on it, and i can't clone it directly
15:06:36 <zigschots20> "git fsck" seems to think everything on my local (stack) version is fine
15:06:55 <zigschots20> can anyone else: git clone https://github.com/commercialhaskell/all-cabal-hashes
15:07:06 <zigschots20> successfully?
15:10:57 <k0ral> Hello
15:11:17 <k0ral> is there a way to choose whether a type operator is left or right associative ?
15:11:30 <k0ral> (using TypeOperators extension)
15:11:38 <dolio> Same infix definitions as the value level, I expect.
15:13:28 <zigschots20> Seems like a problem with my git installation. Gah. This is going to be a world of fun...
15:15:20 <k0ral> dolio: indeed, didn't even try before asking, my bad
15:28:23 <super_java_man> is there a gentle introduction to pipes? i'm having trouble following https://hackage.haskell.org/package/pipes-4.1.8/docs/Pipes-Tutorial.html
15:28:58 <Welkin> that is the gentle introduction
15:29:21 <vieby> look here https://www.livecoding.tv/mgreenly/videos/kJPNg-haskell-hanging-out-writing-code
15:29:28 <Welkin> just read it carefully and slowly
15:29:37 <Welkin> it is one of the better haskell tutorials I have used
15:29:40 <super_java_man> welkin even gentler
15:30:26 <super_java_man> ertesx so i'm trying :m -ModuleName  / :m +ModuleName
15:30:41 <super_java_man> ertesx problem is it doesn't reload the modified module.
15:30:51 <super_java_man> oops he left
15:32:16 <maerwald> vieby: he needs to get haskell plugins going so he doesn't have to switch to ghci terminal every time
15:32:27 <maerwald> syntastic + ghc-mod or something
15:39:20 <super_java_man> is there a way to reload code with clobbering ghci state? just tried :m +/- but it doesn't reload code
15:41:47 <kadoban> super_java_man: Not AFAIK. This is part of why you shouldn't do too much in GHCI itself, it should just be using stuff from file(s). Even if you have to create a file specifically to be loaded in ghci and modified, etc.
15:43:33 <super_java_man> kadoban that's not great for my use case of data exploration. i want to poke around and transform the data interactively
15:43:36 <toph> if fix f = f (fix f) gives the least fixed point of f, is there a generic function to get the greatest fixed point of f?
15:43:58 <super_java_man> also because the repl is in the IO monad, there's certain things I can't do even if I wanted to have it in a file
15:44:08 <super_java_man> like <-
15:45:14 <kadoban> super_java_man: You can write IO actions in a file fine
15:45:36 <super_java_man> kadoban how so?
15:46:06 <kadoban> a :: IO () \n a = do blah blah blah stuff
15:46:18 <ski> not "top-level" ones. yuu have to give them a name, and they won't be performed when the module is loaded (or used, or whatever)
15:46:24 <super_java_man> i could stick it in a function that's bound to an action, but i couldn't look at the state of bindings within it
15:46:29 <super_java_man> like if in your a i did
15:46:37 <super_java_man> x <- getBunchOfData
15:46:41 <super_java_man> i can poke at x in the repl
15:47:08 <super_java_man> i wrote my own emacs lisp hacks to evaluate individual lines of haskell code in haskell mode to get around this. but it's far from ideal.
15:47:27 <super_java_man> ski exactly
15:51:06 <Zemyla> Hmm, so arrows allow for filtering lists in them the way monads do...
15:51:09 <Zemyla> :t \pred -> fix $ \go -> arr (\l -> case l of { [] -> Left (); (a:ls) -> Right (a, ls) }) >>> right ((Control.Category.id &&& pred) *** go) >>> arr (either (const []) (\((a, b), l) -> if b then a:l else l))
15:51:11 <lambdabot> ArrowChoice cat => cat t Bool -> cat [t] [t]
15:52:07 <ski> @wiki Top level mutable state#Proposal_2: Top-level .3C-
15:52:07 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state#Proposal_2:_Top-level_.3C-
15:52:14 <ski> super_java_man ^
15:52:49 <ski> toph : no. there needn't even be any greatest fixed point
15:53:04 <super_java_man> ski just a proposal though
15:53:37 <super_java_man> i thought there was some way to do hot code swapping in ghci is there not?
15:54:00 <ski> toph : we're talking about domain theory. a domain has a bottom element `_|_' that is the least of all the elements in the domain. we specify the least fixed point by iterating `f' on this, and taking the (upper) limit
15:54:22 <ski> super_java_man : possibly. i don't know about it
15:54:24 <t7> hello, is there a haskell regex libary that behaves like javascript regex?
15:54:36 <ski> (i may ave heard about it, but i don't know details)
15:55:23 <ski> super_java_man : .. perhaps state from non-reloaded modules won't get clobbered ?
15:59:50 <t7> omfg
15:59:55 <super_java_man> ski i'm sure there are good reasons for not making it too easy. but practically speaking it's hard to do exploratory data analysis in haskell when you have to reload data everytime you make a code change
15:59:58 <t7> this regex cant even do bs t
16:00:41 <ski> super_java_man : have you tried putting the data in a different module than the one you're changing and reloading ?
16:01:00 <super_java_man> ski yeah didn't work
16:01:22 <super_java_man> using :m -/+ reloads the old version of the module
16:02:00 <ski> i meant using `:r'
16:02:27 <super_java_man> yeah :r reloads the modules
16:02:34 <super_java_man> but ghci state is gone
16:03:27 <super_java_man> i seem to be the only person in the haskell community trying to use it for exploratory data analysis i guess =/
16:05:38 <MichaelK> hi, why doesn't InstanceSigs play nicely with wildcards? I can bypass the error message and get the type with a where clause, so why isn't that automatic?
16:06:06 <Zemyla> So there doesn't seem to be uniformity in arrows when it comes to doing fmap on functions over them. Like, if I were to do something like (Profunctor p, Functor f) => p a b -> p (f a) (f b), some functors would just require p to be a Profunctor, some would want it to be Strong as well, some would want Choice, some would want Closed, and some would want Category as well as those.
16:08:40 <MichaelK> Zemyla: (assuming you're answering me) then why not just exclude them working with PartialTypeSignatures? you'd still be able to see what ghc(i) guesses as the type, but it wouldn't compile without a specific type
16:08:58 <Zemyla> No, I wasn't answering you.
16:09:12 <MichaelK> oh, well it could almost work with my question :P
16:09:21 <Zemyla> I was asking a different question, which is how do you determine the constraints you need for a given functor?
16:15:35 <MichaelK> other question, is it possible to define an instance of (->) ?
16:16:57 <bernalex> MichaelK: what does that mean?
16:17:11 <MichaelK> * is it possible to define (->) for a certain class (just noticed it's data not class)
16:20:20 <kadoban> MichaelK: You mean can you make (->) an instance of a typeclass? Yes, it's an instance of Category and Arrow for instance (heh).
16:20:51 <bernalex> oh. yeah of course. I thought they were asking about it the other way around, which didn't make any sense.
16:21:52 <ski> MichaelK : `(->)' is an (abstract) type. it's not a type declared with `data', nor with `newtype'
16:22:01 <ski> (nor with `type', for that matter)
16:23:21 <MichaelK> kadoban, ski: ah, ok. it also seems to be internal since :info says it's in GHC.Prim
16:30:10 <MichaelK> So I'm trying to make an instance like `Monad (\a -> Wrapped a b)` (I know you can't have type lambdas, but if I knew a better way to write it, I wouldn't be asking this question). How can I make such an instance, or is it practically impossible?
16:31:48 <kadoban> You could write a newtype of Wrapped a b with the arguments flipped maybe? *totally guessing*
16:33:27 <MichaelK> kadoban: even with TypeSynonymInstances, I get Type synonym ‘FlipWrapped’ should have 2 arguments, but has been given 1     In the instance declaration for ‘Monad (FlipWrapped b)’
16:33:46 <MichaelK> i.e. the newtype doesn't seem to accept partial application
16:34:48 <kadoban> MichaelK: Err, you get that when using newtype? Sure you're not using type? I didn't think GHC ever called newtype a "type synonym", though it's quite possible I'm wrong.
16:37:02 <MichaelK> lemme just paste..
16:37:31 <lpaste> MichaelK pasted “newtype error” at http://lpaste.net/161312
16:37:37 <geekosaur> could try -XLiberalTypeSynonyms --- if it is actually a type and not a newtype, as implied by the error
16:39:02 <MichaelK> geekosaur: that didn't work either, even when ghc asked for TypeSynonymInstances and I added it
16:40:08 <Cale> MichaelK: You wanted to write newtype Flip f a b = Flip (f b a)
16:40:55 <ski> MichaelK : `TypeSynonymInstances' would be any use here
16:40:57 <ski> er
16:41:09 <geekosaur> that is why I added the proviso
16:41:10 <ski> s/would/won't/
16:43:39 <ski> i think `LiberalTypeSynonyms' will not help either, here
16:44:13 <ski> "Type synonyms are like macros at the type level" is the key part, regarding the latter
16:46:44 <ski> it's as if when you write `type M s a = StateT (Foo,s) a', you get a signature `M :: <*> -> <*> -> <*>', while `type M s = StateT (Foo,s)' would yield `M :: <*> -> <* -> *>'
16:47:21 <ski> with the former, `M String' is incomplete, not a type expression, it still (at the meta level) expects an expression
16:47:38 <ski> but with te latter, `M String' is already a type expression
16:48:38 <MichaelK> I think I got it to work, but now it needs instances for `Flip Wrapped b`
16:49:24 <MichaelK> (which is a tad annoying, but otherwise ok)
16:49:29 <ski> considering `type Id x = x; type Generic i o = forall x. i x -> o x' (an example from the docs), we'd here say that we get (with `LiberalTypeSynonyms') `Id :: <*> -> <*>' and `Generic :: (<*> -> <*>) -> (<*> -> <*>) -> <*>'
16:50:00 <ski> without `LiberalTypeSynonyms', the latter would have to be `Generic :: <* -> *> -> <* -> *> -> <*>', which wouldn't work in this example
16:50:43 <ski> iow, with `LiberalTypeSynonyms', `Generic' acts like a higher-order macro :)
16:51:46 * ski idly wonders which Scheme (or i suppose also Common Lisp,&c.) macro systems can deal with higher-order macros
16:52:01 <ski> in fact, i'll ask #scheme
16:58:54 <hackrilege> i cant understand or fix an error in this paste http://lpaste.net/161313
16:59:27 <hackrilege> at line 103
16:59:31 <hackrilege> can anyone help?
17:00:10 <hackrilege> it cant rectify the types and gives a kind error
17:03:32 <hackrilege> i think it could be because fmap :: (a -> b) z s a -> z s b deals with (z s) but toZipper deals with (s a)
17:03:45 <ski> don't you also need `Functor (z s)' ?
17:03:52 <hackrilege> i have that
17:04:09 <hackrilege> line 54
17:04:12 <ski>   zmap'''' :: (Zipable z s,Stack s) => (a->b) -> s a -> s b
17:04:17 <ski> i don't see it in there
17:04:28 <ski> oh, ok
17:04:54 <hackrilege> instance (Zipable z s,Stack s) => Functor (z s) where
17:04:56 <ski> that's overlapping, though
17:05:04 <ski> probably not a good idea
17:05:28 <ski> you could add `Functor (z s)' as a superclass of `Zipable z s', though, i think
17:05:30 <hackrilege> i dont undertand. maybe thats the source of the error
17:05:54 <hackrilege> ok ill try that
17:06:30 <ski> you'll need to manually add `instance Stack s => Functor (Zipper s)' and so
17:07:00 <hackrilege> makes sense to give a unique functor instance to each Zipable instance
17:07:05 <hackrilege> thanks
17:09:03 <hackrilege> :r
17:09:07 <hackrilege> lol oops
17:10:09 <ski> :)
17:10:44 <ski> (hm, `:}' and `:{' are GHCi commands ..)
17:11:48 <hackrilege> ok, i guess that relaxes at least one of those nuts language pragmas, but the error remains...
17:12:16 <ski> the error being ?
17:12:37 <hackrilege> a1 .... a
17:14:44 <hackrilege> expected type z1 s1 a1 -> z1 z1 b1, actual type f0 a -> f0 b
17:15:31 <hackrilege> in fmap f . toZipper
17:16:08 <hackrilege> s1 not z1 in the typo
17:16:22 <mgsloan> Hmm, why does "instance Num Int => Class Ty" require UndecidableInstances?  A weird thing to do, I know, but I don't see why UndecidableInstances should be required for constraints that don't mention vars from the instance head 
17:17:05 <mgsloan> Seems like the paterson conditions could be safely lifted in this case
17:17:45 <hackrilege> oh is that what its saying about (z s) not explicitly appearing in class (Functor (z a))Zipable z s a
17:17:49 <hackrilege> =>
17:18:07 <hackrilege> ?
17:18:44 * ski isn't sure what hackrilege is asking
17:18:50 <hackrilege> ok nvm
17:19:02 <hackrilege> i thought thats why i was made to use UndecidableInstances
17:19:06 <ski> (please rephrase, or elaborate more)
17:19:23 <RyanGlScott> mgsloan: FWIW, that instance gives a warning in GHC HEAD to the effect that it "makes type inference very fragile"
17:19:32 <ski> anyway, do you still get a type error there, if you remove the type ascription
17:19:33 <ski> ?
17:19:59 <hackrilege> oh yes sure it needs as much help as it can get to remove ambiguity
17:20:07 <hackrilege> it needs indication for which instance to use
17:20:33 <hackrilege> in the Zipable which is created and destroyed
17:20:33 <ski> oh, right
17:20:42 <ski> i suppose the type signature is ambiguous
17:20:55 <ski> `z' doesn't appear in the main type part, only in the context
17:21:03 <hackrilege> thats the problem
17:21:15 <mgsloan> RyanGlScott: Wow, strange!  I tried with 8.0 but it said it required undecidable instances
17:21:16 <hackrilege> and i cant direct it as i was trying with the type
17:21:27 <ski> hackrilege : is `s' meant to determine `z' ?
17:21:32 <hackrilege> yes
17:21:37 <hackrilege> no
17:21:45 <ski> then add an FD to that effect to `Zipable'
17:21:46 <hackrilege> there canbe other zipable things
17:21:47 <ski> oh ?
17:21:50 <ski> ok
17:21:51 <RyanGlScott> mgsloan: No, it still requires UndecidableInstances. But in HEAD, it also gives you a loosely explained reason why via a warning.
17:22:06 <ski> then the type signature really is ambiguous
17:22:16 <hackrilege> for instance the GridZipper in comments
17:22:29 <ski> i suggest adding another parameter to your function, whose type mentions `z'
17:22:30 <mgsloan> Ah, huh.  Well as long as there is a reason why.  My intuition says that it shouldn't make type inference fragile
17:22:50 <mgsloan> But I certainly don't know the full details of all that biz
17:23:07 <RyanGlScott> I guess that warning doesn't apply to all instance LHSes without type variables, just ones that happen to match an instance declaration in the wild
17:23:10 <ski> hackrilege : the problem is that it has no way of knowing which `z' you mean, by looking at the types of the actual parameters, and the type of the hole of the context in which the function call appears
17:23:34 <mgsloan> In my case I actually just want to use it in some TH declaration syntax that never actually gets used as a declaration.  Should really disable those errors within [d| |] 
17:23:53 <RyanGlScott> mgsloan: Are you trying to derive an instance for something perchance?
17:24:24 <mgsloan> I'm implementing some derivation syntax like $(derive [d| instance Storable Ty |])
17:24:39 <RyanGlScott> This is a problem I've ran into a bunch when implementing deriving machinery in TH...
17:24:41 <hackrilege> actually i think s completely determines z but that means i have been thinking about it wrong and the change will take some propegating. i was thinking that type GriZipper = Zipper [] (Zipper [] a) but perhaps it should be Zipper [[]] a
17:24:51 <hackrilege> i think i see why these errors are occuring
17:24:59 <RyanGlScott> Sadly, implementing the entirety of GHC's instance simplication algorithm is simply not feasible
17:25:09 <mgsloan> RyanGlScott: Yeah, I think we need to give TH access to GHC's algorithms
17:25:24 <hackrilege> see, as then [[]] indicates GridZipper should be used
17:25:51 <RyanGlScott> So for now, I just choose to be naÏve in picking an instance context (some arbitrary metric like apply the typeclass to all type variables of kind * or whatever)
17:25:51 <hackrilege> but actually its the kind of [[]] that indicates that GridZipper should be used, can i work with that?
17:26:01 <ski> hackrilege : `[[]]' is illkinded. perhaps you mean `Compose [] []'/`[] :. []'
17:26:11 <RyanGlScott> And provide the ability to implement the class methods directly in case the user wants to provide their own context
17:26:30 <RyanGlScott> Far from ideal, but it's worked well so far in generic-deriving / aeson / bifunctors / etc.
17:26:31 <hackrilege> but fromZipper :: z s a -> s a
17:26:33 <mgsloan> RyanGlScott: Well, this is why I like my derive syntax, it's just like standalone deriving in that the user needs to manually specify the context.  That way the deriving doesn't need to think too hard about the superclass context
17:26:49 <RyanGlScott> mgsloan: Oh, I see what you're getting at
17:27:09 <RyanGlScott> Instead of typing instance Foo a => Foo (Ty a) where method = $(gimmeMethod ''Ty)
17:27:34 <RyanGlScott> You'd rather have $(deriveFoo [t| Foo a => Foo (Ty a) |])?
17:27:40 <mgsloan> Yeah, I already use it for some stuff, but working on a more general thing.  You'll be able to register derivers, then later, $(derive [d| ... |]) can derive anything that it knows about
17:28:06 <hackrilege> so i would expect :type fromZipper (g::Zipper [[]] a) = [[a]]
17:28:09 <mgsloan> Yeah, I'd certainly prefer that for classes with lots of methods (Prim, Vector, etc)
17:28:47 <hackrilege> are you still with me ski?
17:28:50 <RyanGlScott> mgsloan: OK, so under what scenarios would you need to put something like Show Int in $(derive)?
17:29:17 <ski> hackrilege : maybe. `[[]]' is still illkinded. though
17:29:19 <RyanGlScott> Er, Num Int was your example
17:29:30 <mgsloan> I want $(derive [d| instance Deriving ViaGeneric => Storable Ty |])
17:29:47 <mgsloan> The Deriving typeclass is the thing that gets instantiated to register your deriver
17:30:05 <mgsloan> It's basically just a syntactic hack to inform the TH of which deriver to invoke
17:30:14 <mgsloan> When there are multiple for Storable
17:31:11 <RyanGlScott> That's an interesting way of specifying it. What does the spliced-in instance look like?
17:31:29 <mgsloan> I will need to make it an instance head instead, which isn't so bad $(derive [d| instance Deriving ViaGeneric (Storable Ty) |])
17:32:07 <mgsloan> In this case it would just implement each of the methods directly with generic methods
17:32:20 <mgsloan> (Ty would need to have a Generic instance)
17:32:35 <RyanGlScott> OK. Nothing seems undecidable from that description...?
17:32:55 <RyanGlScott> Perhaps some TypeSynonymInstances
17:32:57 <hackrilege> any clue how to fix the bug ski? if i change z to Zipper it still does not work
17:33:21 <mgsloan> Yeah, I think I can do this instance head variant.  I liked the superclass one though, because it syntactically looks like an instance of Store
17:33:37 <mgsloan> If someone had a clever regex looking for instances of a class, for example, it would find these ones
17:33:38 <RyanGlScott> This is actually pretty relevant to my interests, since I'm exploring a similar fix for https://ghc.haskell.org/trac/ghc/ticket/10598
17:34:11 <RyanGlScott> I'd like to be able to say data Ty = Ty Int deriving (Builtin Eq, GND Show, DAC Binary)
17:34:24 <RyanGlScott> Where GND = GeneralizedNewtypeDeriving, DAC = DeriveAnyClass
17:34:41 <Zemyla> What modules safely export build from GHC.Base?
17:35:11 <RyanGlScott> One idea I'm toying with is allowing GHC plugins to have their own deriving hooks via this same mechanism
17:35:19 <mgsloan> RyanGlScott: Interesting, makes sense!  I agree that with all the various deriving extensions thrown in, it's unclear which wins
17:35:41 <RyanGlScott> The thing that's still unclear is what syntax to use
17:35:45 <mgsloan> My vote is to make GND the default except for H98 derivings
17:36:01 <mgsloan> Perhaps had syntax disambiguating when you want to
17:36:27 <RyanGlScott> oerjan proposed using pragmas to distinguish them, but I don't know how I feel about that
17:36:46 <RyanGlScott> I like the idea of having magic types like DAC, GND, and Builtin to distinguish them
17:37:03 <RyanGlScott> That way, no changes to the syntax need to be made, and it's easy to use them anywhere
17:37:09 <mgsloan> While you're working on this stuff, I have a suggestion.  I would love to be able to do "newtype Ty = ... deriving hiding (Show)"
17:37:27 <mgsloan> Then, I can get a "Ty" that has all the same classes as the thing it wraps, but overriding Show
17:37:32 <mgsloan> (with a custom instance)
17:38:04 <RyanGlScott> What do you mean by "the same classes"?
17:38:34 <RyanGlScott> We have to be careful here
17:38:47 <mgsloan> Lets say its "newtype Ty = Ty X".  Any instance that works with X can now also work with Ty
17:38:50 <RyanGlScott> Do we want all of them to be derived via GND, or another mechanism for classes like Read/Show?
17:38:58 <mgsloan> All GND
17:39:11 <mgsloan> I pretty much always want GND, it's most efficient
17:39:17 * geekosaur smells a pragma
17:39:38 <mgsloan> For Read and Show I do want to have the H98 one, because Read and Show should ideally give you haskell expressions 
17:39:58 <mgsloan> But for this deriving hiding stuff, I'd expect GND
17:40:51 <RyanGlScott> mgsloan: That seems reasonable, although it does strike me as a bit fragile, since you have to know exactly what instances are in-scope for the underlying type.
17:40:59 <hackrilege> i still cant get it to work!
17:41:04 <RyanGlScott> Also, what happens for something like newtype Wrap f a = Wrap (f a)?
17:41:05 <hackrilege> no matter what i try
17:41:08 <mgsloan> "newtype Ty f a = Ty (f a) deriving (Read, Show) hiding (Functor (f a))"
17:42:33 <RyanGlScott> I'm lost. I thought "deriving hiding" was supposed to be standalone thing aside from "deriving"?
17:43:26 <mgsloan> Well, here I'm thinking this is what you'd do to get Read and Show instances derived, allow you to write your own Functor, and otherwise have all the same instances that (f a) has
17:43:57 <mgsloan> Yeah, I'm not sure how well this would pan out from a typechecker performance perspective.  You might need to check for a lot more instances.
17:44:33 <RyanGlScott> Yes. Moreover, what is (f a)? Is it Maybe a? [a]? Or just those undecidable instances that happen to have something alpha-equivalent to (f a) on the RHS?
17:45:09 <mgsloan> But from a conceptual perspective of something I'd like to express, it makes sense to have this capability.  Without it, I have to say "well, what instances does Ty have.  I guess I'll use all of them.  What about classes I don't know about?  Eh that's what orphans are for..."
17:45:40 <RyanGlScott> Sure, for concrete types, I agree this makes sense.
17:45:57 <RyanGlScott> But I'm super-confused what happens when the type is all type variables :)
17:45:57 <mgsloan> RyanGlScott: The details of the example doesn't really matter, I'm just coming up with misc examples
17:47:38 <mgsloan> I'm imagining that if we need a (Num (Ty f a)) instance, then the constraint solver does some magic to coerce to a (Num (f a))
17:48:06 <mgsloan> If we need (Functor (Ty f a)), it knows to use the instance defined for the newtype
17:48:09 <RyanGlScott> I'm missing something even more vital here - when does the typechecker decide to derive a Num instance?
17:48:27 <RyanGlScott> Or an instance for any typeclass at all, for that matter, when the type is something like (f a)?
17:48:33 <mgsloan> Ah, do GND instances need to actually exist?
17:48:59 <RyanGlScott> Maybe I've misunderstood your proposal, so let me paraphrase it to see if I've got this
17:49:17 <RyanGlScott> You want a syntax extension to deriving that only works on newtypes
17:49:17 <mgsloan> I thought that since (Ty f a) is representationally equivalent to (f a), I thought that we wouldn't need to generate code for GND instances for (Ty f a)
17:49:30 <mgsloan> Yup
17:49:33 <RyanGlScott> That, when applied, attempts to derive all in-scope instances for the underlying type to the newtype
17:49:55 <RyanGlScott> OK. So when the type is (f a), what are the in-scope instances, exactly?
17:49:59 <mgsloan> Nope, that is where the confusion is.  I want it to be an open deriving that will work even for orphans of the underlying type
17:50:21 <mgsloan> So if later we import the newtype and define an instance for the underlying type, we get it for the newtype
17:50:49 <mgsloan> because the purpose of the newtype was just to specify a few instance's behavior
17:51:23 <mgsloan> This is useful for newtypes like "Blind" from quick-check - it lets you Show things that aren't usually Show-able
17:51:37 <mgsloan> but how do we choose which derivings to add?  We just sprinkle the common ones, yuck!
17:53:00 <RyanGlScott> OK, I see what you mean now.
17:53:40 <RyanGlScott> I see what you meant by your "typechecker performance implications" comment earlier
17:53:42 <ski> hackrilege : "any clue how to fix the bug ski?" -- <ski> i suggest adding another parameter to your function, whose type mentions `z'  <ski> hackrilege : the problem is that it has no way of knowing which `z' you mean, by looking at the types of the actual parameters, and the type of the hole of the context in which the function call appears
17:53:59 <hackrilege> but changing z to Zipper fixes nothing
17:54:09 <RyanGlScott> Since these instances will effectively have to be derived just-in-time in any scenario when the newtype and an orphan instance collide, I think
17:55:19 <hackrilege> it also has this holes problem on all the other varibles or something
17:56:28 <ski> hackrilege : i didn't suggest "changing z to Zipper"
17:56:54 * ski isn't sure what "holes problem" means
17:57:05 <RyanGlScott> mgsloan: Actually, not just for orphan instances. It'd be the case for any instance that isn't in-scope at the site of the newtype's definition
17:57:39 <RyanGlScott> So this idea seems to fly in the face of separate compilation, which makes me a bit uneasy...
17:57:58 <hackrilege> Zipper is a datatype, there should be no ambiguity at all
18:00:17 <ski> hackrilege : do you mean if you say :
18:00:20 <hackrilege> i annotated the post with the new error
18:00:21 <hackrilege> http://lpaste.net/161313
18:00:30 <hackrilege> go on
18:00:34 <ski>   zmap'''' :: (Zipable Zipper s,Stack s) => (a->b) -> s a -> s b
18:00:35 <ski> ?
18:00:54 <hackrilege> no, see the paste
18:01:16 <hackrilege> as in (fmap f):: Zipper s a -> Zipper s a
18:01:16 <RyanGlScott> mgsloan: Is that correct? Wouldn't each occurrence of one of these autoderived instances have to be compiled at the use site?
18:01:19 <ski> oh
18:01:22 <ski> you need to say
18:01:24 <ski>   zmap'''' :: Stack s => (a->b) -> s a -> s 
18:01:26 <ski> er
18:01:33 <ski>   zmap'''' :: forall s a b. Stack s => (a->b) -> s a -> s 
18:01:34 <ski> there
18:01:38 <hackrilege> omg
18:01:42 <ski> and enable `ScopedTypeVariables
18:01:43 <RyanGlScott> In a sense, it's like C++ templates, but more automated
18:01:43 <ski> '
18:01:56 <hackrilege> i knew id run into these forall things at some point
18:02:00 <ski> otherwise the `s',`a',`b' from the type signature isn't in scope in the body
18:02:09 <hackrilege> ohhh
18:02:13 <hackrilege> thats what it means
18:02:17 <ski> imho, this is a silly use of the `forall' keyword
18:02:22 <hackrilege> oh o
18:02:24 <hackrilege> ok
18:02:38 <hackrilege> because it has some meaning im sure
18:02:46 <hackrilege> rather than just adding things to scope
18:02:48 <ski> it's not really "what `forall' means", no, not imho
18:03:34 <ski> (i was wondering earlier if you wanted `ScopedTypeVariables', but as you had problems with ambiguity there, i didn't mention it)
18:04:00 <hackrilege> yay it compiles! thank you!!
18:04:41 <ski> hackrilege : *usually*, when you write a type signature like `foo :: ..a..b..c..', `a',`b',`c' all being free in the type expression `..a..b..c..', this is really *sugar* for writing `foo :: forall a b c. ..a..b..c..'
18:04:56 <ski> so, e.g.
18:05:02 <ski>   length :: [a] -> Int
18:05:06 <ski> really *means*
18:05:11 <ski>   length :: forall a. [a] -> Int
18:05:17 <mishac> HI Guys, is there anyone who can help me with defining a fold for a "Rose Tree" Datatype. Constructors
18:05:17 <mishac> Node  
18:05:17 <mishac> rootLabel :: a 
18:05:17 <mishac> label value
18:05:17 <mishac> subForest :: Forest a 
18:05:17 <mishac> zero or more child trees
18:05:32 <ski> and it's really this `forall' in the type of `length' that indicates that `length' is *polymorphic*
18:05:42 <hackrilege> mishac did you see the instance in Data.Tree?
18:05:48 <ski> no such `forall', no polymorphism in the corresponding value of the type
18:05:55 <hackrilege> or Data.Foldable
18:06:04 <ski> hackrilege : it's just that these `forall's are (usually) *implicit*
18:06:18 <ski> (and must be implicit in Haskell98, since it doesn't have the `forall' keyword)
18:06:23 <ski> but conceptually, it's still there
18:06:32 <ski> hackrilege : makes sense, so far ?
18:06:42 <hackrilege> i dont get what making it explicit achievs
18:06:57 <ski> we'll see :)
18:07:12 <mishac> Yes, it appears that the treefold is not defined there
18:07:22 <ski> first i want to mention the exception to the implicit `forall' quantification rule
18:07:30 <hackrilege> its about if you can infer types from others no?
18:07:34 <ski> let's say you have
18:07:35 <hackrilege> like forall a-> b
18:07:37 <hackrilege> or something
18:07:37 <ski>   class Eq a
18:07:39 <ski>     where
18:07:47 <ski>     (==) :: a -> a -> Bool
18:07:53 <mishac> hackrilege
18:07:53 <mishac> hackrilege
18:07:53 <mishac> hackrilege: Yes I did, i am just having a hard time figuring out the type signature for the fold
18:07:57 <ski> this does *not* really mean :
18:07:59 <ski>   class Eq a
18:08:01 <ski>     where
18:08:04 <hackrilege> :t fold
18:08:05 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:08:06 <ski>     (==) :: forall a. a -> a -> Bool
18:08:09 <hackrilege> :t foldl
18:08:10 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
18:08:34 <hackrilege> why not ski?
18:08:54 <mishac> hackrilege, so this the expected type signature
18:09:05 <hackrilege> sorry?
18:09:24 <ski> mishac : note that there's two different senses of the term "fold". you should make sure which of them you're after here
18:09:33 <hackrilege> your after foldl
18:09:44 <mishac> ski: it is a from the assignment for cis194 class
18:09:58 <mishac> ski: which states that The Data.Tree module from the standard Haskell libraries defines
18:09:58 <mishac> the type of “rose trees”, where each node stores a data element and
18:09:58 <mishac> has any number of children (i.e. a list of subtrees):
18:09:58 <mishac> data Tree a = Node {
18:09:58 <mishac> rootLabel :: a, -- label value
18:09:58 <mishac> subForest :: [Tree a] -- zero or more child trees
18:09:59 <mishac> }
18:09:59 <mishac> Strangely, Data.Tree does not define a fold for this type! Rectify the
18:10:00 <mishac> situation by implementing
18:10:16 <hackrilege> wowowow
18:10:21 <hackrilege> dont paste that here
18:10:28 <ski> mishac : please, provide your code online somewhere instead of pasting so many lines in the channel. e.g. a paste site like :
18:10:31 <ski> @paste
18:10:31 <lambdabot> Haskell pastebin: http://lpaste.net/
18:10:41 <mishac> ski: sorry, my bad, I forgot
18:11:18 <mishac> ski:http://pastebin.com/M762MEzu
18:12:23 <mishac> ski: Than based on this resource: https://en.wikibooks.org/wiki/Haskell/Other_data_structures I figured that the type signature for treeFold has to be: (a -> Forest b -> b) -> Tree a -> b
18:12:33 <hackrilege> http://lpaste.net/44856
18:12:59 <ski> mishac : "fold" in the sense of "combine together a sequence of elements (using some traversal order)" would mean that you take a function that can combine an element and a "state" together into a new state. you also take an "initial" state, apart from the tree, and return a final state, after traversing to all elements, and combining them with the current state
18:13:05 <hackrilege> found using a google search 'fold rose tree'
18:13:30 <mishac> hackrilege: Thank You, but I am not sure about one thing.
18:13:36 <hackrilege> go on
18:13:47 <ski> mishac : "fold" in the sense of "replace data constructors with custom callback functions" would mean that you take one argument to replace every `Node' constructor in the tree with, and a tree, and return the result of this replacement
18:14:12 <mishac> ski: Thank You, this seems a bit over my head
18:14:29 <ski> this latter interpretation of "fold" is also called "catamorphism"
18:14:34 <hackrilege> its ok, im sure you will get the hang of it
18:14:42 <hackrilege> ski, what were you saying?
18:14:58 <ski> mishac : the type signature `(a -> Forest b -> b) -> Tree a -> b' corresponds to the catamorphism sense of "fold"
18:15:09 <mishac> ski: Ohhh
18:15:34 <ski> mishac : note that `foldr' and `foldl' for lists are "fold"s in the former sense, the sense of combining elements, in the order of a traversal
18:15:39 <hackrilege> can you write the definition of fold mishac?
18:15:48 <hackrilege> foldl*
18:15:53 <ski> mishac : also note that `foldr' (but *not* `foldl') for lists is *also* a catamorphism
18:16:04 <mishac> ski: so, what is the best resource that I use to clarify the difference between catamorphism fold and the fold that is asked by the assignment? http://pastebin.com/
18:16:13 <mishac> ski: ups http://pastebin.com/M762MEzu
18:16:17 <ski> mishac : and this is probably why the same term "fold" is used for both different concepts .. because they overlap in the case of `foldr'
18:17:06 <mishac> ski: Thank You, this still so confusing
18:17:28 <ski> mishac : i'm still not sure which sense of fold the exercise is really asking for ..
18:17:43 <ski> hackrilege : i'll resume shortly
18:17:59 <hackrilege> mishac, can you write the definition for foldl?
18:18:51 <mishac> hackrilege: foldl for lists?
18:18:57 <hackrilege> yes
18:19:10 <ski> mishac : btw, i think usually with a name like `treeFold', the catamorphism sense would be intended. did you choose the name `treeFold', or did the exercise choose it ?
18:19:32 <mishac> ski: I think I choose it,
18:19:56 <mishac> ski: No my bad, it is the exercise.
18:20:27 <hackrilege> chose*
18:20:33 <mishac> ski: http://pastebin.com/jFJG6gMv
18:20:38 <ski> (for the "combine elements in sequence" sense, i suppose `treeFoldl',`treeFoldr', or `foldTreePreorder',`foldTreeInorder',`foldTreePostorder' could be used (the middle one for a binary tree))
18:21:04 <mishac> ski, hackrilege: can we step back for a second
18:21:44 <ski> @where CIS194
18:21:44 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
18:21:57 * ski checks lecture 7
18:22:14 <mishac> ski: so the lists we have two Data constructors Nil and Cons and the corresponding definintion for the fold is : http://pastebin.com/SXgjfGz4
18:22:53 <hackrilege> nice
18:23:19 <mishac> ski: so because we have two constructors, it corresponds to the: (a -> b -> b) -> (b)
18:23:21 <ski> mishac : `treeFold :: b -> (b -> a -> b -> b) -> Tree a -> b' mentioned at <http://www.seas.upenn.edu/~cis194/spring13/lectures/07-folds-monoids.html> is definitely in the catamorphism sense
18:23:39 <hackrilege> why not just map fold over the forrest and then fold up the list?
18:23:41 <ski> also `exprTFold :: (Integer -> b) -> (b -> b -> b) -> (b -> b -> b) -> ExprT -> b'
18:23:52 <mishac> ski: but why there is a b?
18:24:16 <mishac> ski: since there is only one constructor, shouldnt the definition be  (b -> a -> Forest b -> b) -> Tree a -> b'
18:24:23 <ski> `b' is the "state type"
18:24:40 <ski> well, i suppose you'd rather call it the "result/summary" type here
18:25:11 <ski> mishac : no `b ->' in `(b -> a -> Forest b -> b) -> Tree a -> b'
18:25:20 <ski> it should be `(a -> Forest b -> b) -> Tree a -> b'
18:25:34 <mishac> ski: Thats exactly what I though it should be!!!
18:25:37 <hackrilege> why would the forrest have different type?
18:25:39 <ski> we want
18:26:13 <ski>      treeFold node (Node 0 [Node 1 [],Node 2 [Node 3 [],Node 4 []],Node 5 []])
18:26:16 <hackrilege> b -> Forrest a -> b
18:26:39 <ski>   =  node 0 [node 1 [],node 2 [node 3 [],node 4 []],node 5 []]
18:27:01 <ski> mishac : actually, the type `(a -> Forest b -> b) -> Tree a -> b' isn't quite right, either
18:27:12 <ski> recall that `Forest b' means `[Tree b]'
18:27:20 <mishac> sky: Yep
18:27:26 <mishac> ski: yep
18:27:26 <ski> so `(a -> Forest b -> b) -> Tree a -> b' means `(a -> [Tree b] -> b) -> Tree a -> b'
18:27:39 <mishac> ski: yep
18:27:58 <mishac> ski: but it won't compile
18:28:10 <ski> but we're supposed to have replaced all the `Node' data constructors in the list there by the callback argument function `node', before calling `node' on the current node element, and the list
18:28:31 <mishac> ski: can you paraphrase ?
18:29:14 <ski> in a sense, we're computing a "summary" of the tree
18:29:26 <ski> perhaps we're taking the sum of all elements (if they're numbers)
18:29:31 <ski> or perhaps the maximum
18:29:37 <ski> or perhaps both (computing a pair)
18:29:53 <ski> or perhaps we're converting the elements to strings, and collecting all strings in a list
18:29:53 <mishac> ski: does it correspond to the parameter b in the definition?
18:30:05 <ski> this "summery" will have type `b'
18:30:27 <mishac> ski: so far its clear.
18:30:53 <ski> so, considering a tree, of shape `Node a ats', `a' an element in the node, and `ats' a list of trees of `a'
18:30:54 <mishac> ski: any hints on how to properly go about implementing the fold
18:31:37 <ski> so, first we'll want to walk through the list of trees, and summarize each tree in the list into a value in type `b', by using recursive calls
18:32:11 <mishac> so our function f has to map over all of the elements in the list of Trees a>
18:32:38 <ski> then, given the current element of type `a', and this list of summaries, we want to feed them to the callback function `node', so that it can also summarize this node element together with all the summaries for the child trees
18:32:53 <ski> that is what we want `treeFold' to do
18:32:57 <ski> does this make sense ?
18:33:06 <mishac> ski: probably 50%
18:33:24 <ski> (i'm not sure which function `f' would be here)
18:33:36 <mishac> ski:http://pastebin.com/wSMRuvBA
18:33:41 <mishac> ski: this is how far I got
18:33:49 <mishac> ski: but i know I am missing something
18:34:20 <ski> mishac : it's correct, except for the type signature
18:34:36 <ski> can you figure out the corrrect type signature ?
18:35:24 <mishac> ski: can i use ghci?
18:35:25 <ski> (as i hinted at above, you probably don't want to mention `Forest', so you can start by expanding the `Forest' type synonym according to its definition)
18:35:32 <ski> if you must
18:35:50 <ski> but you'll possibly learn more if you first try to figure out the type for yourself
18:35:53 <ski> your choice
18:36:04 <mishac> ski: I did ghci'ed it
18:36:09 <mishac> ski: (t -> [b] -> b) -> Tree t -> b
18:36:17 <ski> (even attempting to figure it out, even if not succeeding, is helpful)
18:36:29 <mishac> ski: I agree, that is when learning happens,
18:36:29 <ski> do you understand why that's the correct type signature ?
18:37:00 <mishac> ski: I have a vague guess, I know that the Forest a is synonim for [Tree a]
18:37:05 <ski> yes
18:37:30 <ski> so `Forest b' in `(a -> Forest b -> b) -> Tree a -> b' is a synonym for `[Tree b]'
18:37:48 <mishac> ski: and I also know that if I write type signature as [Tree a] instead of Forest I will get some mssing files error in compiler
18:38:06 <ski> why would you ?
18:38:10 <ski> i don't follow
18:38:54 <mishac> ski: I think I figured out the part of the source of my confusing, I was using Tree b
18:39:01 <mishac> ski: err [Tree b]
18:39:09 <mishac> ski: now it works
18:39:30 <mishac> ski: so the definition for the treeFold is correct
18:39:50 <ski> yes, but why does it work ?
18:40:10 <ski> (the type signature, i mean)
18:40:39 <mishac> ski: My best guess, It has to do with the fact that b in the signature corresponds to the some kind of abstract accumulating value
18:40:57 <ski> `b' corresponds to the "summary" type i talked above, yes
18:41:03 <ski> but consider
18:41:06 <mishac> ski: but when we have Forest b: it directly relates to the subtrees of the RoseTree
18:41:10 <ski>   treeFold :: (a -> Forest b -> b) -> Tree a -> b
18:41:13 <ski> which means
18:41:19 <ski>   treeFold :: (a -> [Tree b] -> b) -> Tree a -> b
18:41:26 <ski> as opposed to the correct
18:41:29 <ski>   treeFold :: (a -> [b] -> b) -> Tree a -> b
18:41:31 <ski> version
18:42:05 <ski> the point is that we have already summarized the trees in the list, getting a list of summaries (not of trees), before we call `fNode'
18:42:07 <mishac> ski: I am hving an epihmany
18:42:25 <ski> so `fNode' won't see any trees at all, only `a' elements, and `b' summaries of trees
18:42:35 <ski> makes sense ?
18:42:49 <mishac> not 100% but 80%
18:42:54 <ski> if you look at
18:42:54 <ski>      treeFold node (Node 0 [Node 1 [],Node 2 [Node 3 [],Node 4 []],Node 5 []])
18:42:57 <ski>   =  node 0 [node 1 [],node 2 [node 3 [],node 4 []],node 5 []]
18:43:23 <mishac> ski: where node is a function that we applying to the Rose Tree
18:43:26 <ski> then you see that each `node' here gets as argument (a) an element; and (b) a list of summaries generated from further calls to `node'
18:43:37 <ski> yes, my `node' is your `fNode'
18:43:38 <mishac> ski: yes,
18:44:07 <mishac> ski: if before i had 30% of an idea, now I am getting close to the understanding
18:44:12 <ski> so, by the time `node' gets to see its arguments, all the original `Node' tree constructors in the list argument have already disappeared
18:44:32 <ski> and, the base case of the recursion here is when the list is empty
18:44:46 <mishac> ski: but wedon't have tospecify it
18:45:33 <ski> it may look like your `func_g' uses infinite recursion, but it fact it will terminate, when the `y' list in your source is empty, since then `map func_g y' will terminate without making any further recursive calls to `func_g'
18:45:47 <mishac> ski: yep.
18:45:47 <ski> (simply because there's no trees in the `y' list to call `func_g' on)
18:46:02 <ski> we don't have to specify it, right. `map' takes care of it
18:46:45 <ski> now, i'd like to show a small variation in how you can write your `treeFold'
18:46:46 <ski> you ad
18:46:49 <ski> had
18:46:55 <ski>   treeFold fNode = func_g
18:46:56 <ski>     where
18:47:02 <ski>     func_g (Node x y) = fNode (x) (map func_g y)
18:47:30 <ski> if we're taking the definitions here as true elements, then it means that `treeFold fNode' must be equal to `func_g'
18:48:07 <ski> so, let's replace equals for equals. let's replace `func_g' in the inner definition by `treeFold fNode' (adding brackets where necessary)
18:48:19 <ski> if we do this, then the inner definition here becomes
18:48:34 <ski>   treeFold fNode (Node x y) =  fNode (x) (map (treeFold fNode) y)
18:48:44 <ski> well, we could remove redundant brackets
18:48:51 <ski>   treeFold fNode (Node x y) = fNode x (map (treeFold fNode) y)
18:49:01 <mishac> ski: Thank You!!!
18:49:12 <ski> (apart from naming) this is probably how i would have written this function, initially
18:49:37 <mishac> ski: Thank You so much, for Patience for trying to understand my question and time to answer it and clarify my lack of understanding. !!!
18:49:41 <ski> i just wanted to show you that you can call `treeFold' recursively, inside `map', even without explicitly passing the second argument to it
18:49:52 <ski> `map' will provide the second argument to `treeFold fNode'
18:50:30 <ski> mishac : however, i'm not saying your version with `func_g' is bad. if you do it that way, then you don't have to repeat the parameter `fNode' in all recursive calls, which might be nicer
18:50:41 <ski> especially if you'd have to repeat a lot of parameter names
18:50:55 <MichaelBurge> These Generics are blowing my mind. I feel like I'm going to spend the next couple hours writing like 15 lines of code
18:51:24 <ski> however, if you want to call yourself recursively wit *different* parameter values than those that you received in the current call, *then* you can't do this "inner recursive function not passing around outer parameters" trick
18:51:38 <ski> mishac : i hope this helps. have fun
18:51:46 <mishac> ski: IT does!!!
18:52:25 <mishac> ski: You helped a Lot.
18:52:31 <ski> hackrilege : now, `forall' ..
18:52:35 <ski> we considered
18:52:38 <ski>   class Eq a
18:52:40 <ski>     where
18:52:45 <ski>     (==) :: a -> a -> Bool
18:53:00 <ski> i claimed that in this case, this *wasn't* short for
18:53:01 <ski>   class Eq a
18:53:04 <ski>     where
18:53:08 <ski>     (==) :: forall a. a -> a -> Bool
18:53:48 <ski> because, in this latter version, the `forall a.' *binds* the variable `a', so then the variable `a' in `a -> a -> Bool' wouldn't be the same as the `a' in `Eq a'
18:53:57 <ski> which is not what we want. we want them to be the same
18:54:12 <ski> conceptually, you could think of the former class declaration as meaning :
18:54:14 <ski>   forall a.
18:54:18 <ski>     class Eq a
18:54:22 <ski>       where
18:54:30 <ski>       (==) :: a -> a -> Bool
18:55:03 <ski> iow, we're really defining the type property `Eq a', for every `a'
18:55:26 <ski> namely, for `Eq Int', it means that there must be a function `(==) :: Int -> Int -> Bool'
18:55:54 <ski> and, for `Eq Char', it means that there must be a function `(==) :: Char -> Char -> Bool'
18:55:57 <ski> and so on
18:56:46 <ski> so, we're defining what it would mean for `Eq a' to hold, for every `a'. so it could, if we wanted to, be thought of as one definition of the property `Eq T', for every possible type `T'
18:57:05 <ski> anyway, we say that the *method* `(==)' here is *monomorphic*
18:57:29 <ski> it's *not* polymorphic, because its type signature in the class doesn't start with a `forall'
18:57:52 <hackrilege> oh no
18:57:53 <hackrilege> http://lpaste.net/161317
18:58:09 <hackrilege> hi!
18:58:16 <hackrilege> sry was getting that to compile
18:58:22 <ski> it's another matter that if we try to use `(==)' outside this class (iow, try to use it anywhere else, apart from when making an instance of `Eq'), then it's as if `(==)' had type `forall a. Eq a => a -> a -> Bool'
18:58:24 <hackrilege> nasssty bug now
18:58:32 <ski> (and this is obviously now polymorphic)
18:58:40 <ski> ok
18:58:43 <hackrilege> see if you can understand this bug
18:58:48 <ski> now consider this type class :
18:58:52 <ski>   class Functor f
18:58:54 <ski>     where
18:59:01 <ski>     fmap :: (a -> b) -> f a -> f b
18:59:08 <ski> what does this really mean ?
18:59:12 <ski> well, it means :
18:59:15 <ski>   forall f.
18:59:21 <ski>     class Functor f
18:59:27 <ski>       where
18:59:38 <ski>       fmap :: forall a b. (a -> b) -> f a -> f b
18:59:50 <ski> now `fmap' *is* polymorphic (in `a' and `b', but not in `f')
18:59:58 <ski> if we want to write
19:00:05 <ski>   instance Functor Maybe
19:00:07 <ski>     where
19:00:12 <ski>     fmap = ...
19:00:22 <ski> then the signature for this `fmap' will be
19:00:35 <ski>   fmap :: forall a b. (a -> b) -> Maybe a -> Maybe b
19:00:45 <ski> so, `fmap' is a polymorphic method
19:01:34 <ski> the main point here is : we implicitly add a `forall' binding the (free) type variables in a type signature, *except* for those that are *already* in scope outside the type signature
19:02:05 <ski> in the case of `fmap' here, `f' was already in scope (mentioned in `Functor f', in the same declaration, outside the type signature for `fmap' there)
19:02:35 <gfixler> so <> is infixr
19:02:42 <gfixler> test
19:02:44 <gfixler> test
19:02:56 <gfixler> oh, lol
19:03:30 <gfixler> anyway, <> is infixr
19:03:40 <gfixler> which means a <> (b <> (c <> d))
19:03:58 <gfixler> but is eval still left to right?
19:04:00 <ski> hackrilege : anyway, let's return to
19:04:07 <ski>   zmap'''' :: Stack s => (a->b) -> s a -> s b
19:04:09 <ski>   zmap'''' f a = fromZipper x
19:04:11 <hackrilege> hang on hang on
19:04:12 <ski>     where
19:04:19 <ski>     x :: Zipper s b
19:04:22 <ski>     ...
19:04:48 <gfixler> I've noticed that if I have a short-circuiting monoid, and a huge train of mappend functions, it takes forever if I make the short-circuiting happen from the right
19:04:55 <gfixler> but takes no time if it's from the left
19:05:18 <ski> the problem here is that the `s',`a',`b' in the first (outer) type signature here isn't in scope in the body of the function (which includes the type signatures in the `where'-clause attached to that body)
19:05:30 <gfixler> e.g. mempty `mappend` foo = foo with a ton of mempties and a foo on the end takes ages
19:05:51 <ski> hackrilege : the solution, as you saw, is to turn on `ScopedTypeVariables', and to change the code to
19:05:51 <gfixler> but foo `mappend` mempty = foo with a ton of mempties and a foo at the beginning happens immediately
19:06:01 <ski>    zmap'''' :: forall s a b. Stack s => (a->b) -> s a -> s b
19:06:05 <hackrilege> im here
19:06:07 <ski>    zmap'''' f a = fromZipper x
19:06:12 <ski>      where
19:06:15 <ski>      x :: Zipper s b
19:06:17 <ski>      ...
19:07:00 <ski> doing this, will make `s',`a',`b' from the outer type signature also be in scope in the body, so that you can mention *those* same type variables in the types for `x' and so on
19:07:05 <ski> which you needed in this case
19:07:30 <hackrilege> glfixler, is that related to my bug? im doing something remarkably similar
19:07:36 <ski> however, while this is how things work (currently), i think it's silly and backwards from how it ought to work
19:07:59 <ski> in my humble opinion, if you (turn on `ScopedTypeVariables' and) write
19:08:07 <ski>   zmap'''' :: Stack s => (a->b) -> s a -> s b
19:08:08 <ski>   zmap'''' f a = fromZipper x
19:08:10 <ski>     where
19:08:12 <ski>     x :: Zipper s b
19:08:15 <ski>     ...
19:08:30 <ski> then, conceptually, this ought to behave as if we had written something like
19:08:35 <ski>   forall s a b.
19:08:42 <ski>     zmap'''' :: Stack s => (a->b) -> s a -> s b
19:08:46 <ski>     zmap'''' f a = fromZipper x
19:08:48 <ski>       where
19:08:51 <ski>       x :: Zipper s b
19:08:54 <ski>       ...
19:09:27 <ski> where the `forall s a b.' here scopes both over the type signature and the defining equation (including the `where'-clause)
19:09:28 <hackrilege> it doesnt?
19:09:43 <hackrilege> no, one moans a lot
19:09:48 <hackrilege> ok
19:09:56 <ski> as it stands, apart from turning on `ScopedTypeVariables', we also have to change the code into
19:10:04 <ski>   zmap'''' :: forall s a b. Stack s => (a->b) -> s a -> s b
19:10:10 <ski>   zmap'''' f a = fromZipper x
19:10:16 <ski>     where
19:10:18 <ski>     x :: Zipper s b
19:10:21 <ski>     ...
19:10:25 <ski> to make it work
19:10:37 <hackrilege> ok
19:10:42 <ski> however, imho, this ought to be the same as using the type signature
19:10:47 <hackrilege> you have to add the forall statement yeah
19:10:50 <ski>   zmap'''' :: (forall s a b. Stack s => (a->b) -> s a -> s b)
19:11:08 <ski> and now it clearly looks like `s',`a',`b' are *only* in scope inside the type signature here
19:11:17 <ski> but not in the body of the definition
19:11:25 <hackrilege> riight
19:11:30 <hackrilege> yeah
19:11:35 <ski> so, imho, this is silly, completely backwards from how it ought to be
19:12:04 <ski> anyway, i wanted to also at least mention a little about the main reason the `forall' keyword exists
19:12:10 <ski> consider
19:12:20 <hackrilege> its cool, i guess also with your propper introduction i can now use them happily everytime i need to fix types inside a function which cant be inferred from the type
19:12:28 <ski>   mystery :: (forall a. [a] -> [a]) -> [Integer]
19:12:46 <ski> this `mystery' function is *not* polymorphic (despite having a `forall' in its type)
19:13:03 <ski> the point is that the `forall' doesn't appear just after the `::'
19:13:15 <hackrilege> it does
19:13:26 <ski> `mystery' is not polymorphic. however `mystery' *requires* its *argument* function to be polymorphic
19:13:32 <ski> `mystery reverse' is ok
19:13:55 <hackrilege> ok
19:14:01 <ski> because we have `reverse :: forall a. [a] -> [a]', `reverse' is polymorphic, so `mystery' accepts it
19:14:14 <hackrilege> yeah i get that
19:14:28 <ski> but `mystery (intersperse ',')' isn't ok
19:14:37 <ski> @type intersperse ','
19:14:39 <lambdabot> [Char] -> [Char]
19:14:39 <parsnip> any ideas for emacs not finding random for `import System.Random`? had done `stack install random`, and `stack ghci` from terminal finds it fine. 
19:14:48 <ski> this argument function only works for `Char'
19:15:06 <ski> but `mystery' requires its argument function to work for any type at all, not just `Char'
19:15:14 <hackrilege> oh really!
19:15:17 <hackrilege> fancy
19:15:29 <ski> one implementation of `mystery' could be
19:15:29 <hackrilege> enforcing polymorphism
19:16:03 <ski>   mystery polyFun = 42 : polyFun [0,1,2]
19:16:27 <ski> in this case, `mystery' is always using `Int' for `a' in the polymorphic argument function
19:16:37 <ski> but, it doesn't expose this fact in its type signature
19:16:50 <ski> if we only know the type signature, then we don't know this
19:17:21 <ski> and, in any case, the type system won't let us pass a function of (only) type `[Integer] -> [Integer]' anyway
19:17:28 <ski> (sorry, it was `Integer', not `Int')
19:17:41 <ski> so, we can use this for _information hiding_!
19:18:07 <ski> hiding implementation details about which actual types our function wants to use the polymorphic argument(s) at
19:18:13 <hackrilege> is the following statement correct; using 'forall a' inside your type and mentioning 'a' more than once forces each of these instances to be polymorphic?
19:18:26 <hackrilege> issnt that just what using 'a' did in the first place?
19:18:34 <hackrilege> iguess there was always an implicit forall
19:18:36 <ski> this can sometimes be quiet handy. especially if we don't want to callback argument to "peek" at some private data we're passing through it
19:18:45 <ski> s/quiet/quite/
19:19:11 <ski> "using 'forall a' inside your type and mentioning 'a' more than once forces each of these instances to be polymorphic" -- no
19:19:37 <ski> values (usually, but not always, functions) here are polymorphic, not types
19:19:38 <parsnip> never mind, clearly i was not following the (init your stack project) rules
19:19:53 <ski> (types could also be polymorphic, but that's another (similar) story)
19:20:37 <hackrilege> not sure i quite get the informatio hiding principle of forall and i will have to return to it later
19:20:40 <ski> "iguess there was always an implicit forall" -- yes, at least conceptually, even before the `forall' keyword was introduced
19:21:23 <hackrilege> infact you can only restrict the scope of a from "all"
19:21:51 <ski> hackrilege : my "repaste of PoorManDebug" in 2009-09-30 at <http://lpaste.net/10060> has an example of using it for information hiding
19:21:59 <hackrilege> anyhow, my program freezes and i dont now why
19:22:11 <hackrilege> and i really need to tt it fixed
19:22:23 <jaseemabid> Hey everyone, I've this little script which runs fine in ghci but errors "thread blocked indefinitely in an MVar operation" when run with the binary? How do I debug this issue? 
19:22:41 <hackrilege> i think the whole principle of what im trying to do might be flawed and its really hard to understand it
19:23:43 <hackrilege> thanks for the lesson!
19:23:53 <hackrilege> its a damn stupid bug
19:23:55 <Cale> jaseemabid: You might try compiling with -threaded and see if it helps... but there might be a more fundamental race condition that you're just avoiding by chance. That error happens when a thread is either trying to read from an empty MVar or write to a full one, and no other thread in the system has a reference to it, which means that it will be waiting forever.
19:24:13 <ski> hackrilege : i have `traceFix :: (forall m. Monad m => ..m..) -> ...' there, and i don't want the callback argument to be able to know that i'm setting `m' to be `Writer (Tree (a,b))', because then the callback would be able to emit spurious noise messages into my tracing logging
19:24:28 <Cale> jaseemabid: Rather than just letting it wait forever, the runtime system throws an exception at it.
19:24:37 <Cale> (which usually kills the thread)
19:24:46 <hackrilege> ski i cant look at that now!
19:24:54 <hackrilege> im totally freaking out about this! http://lpaste.net/161317
19:25:30 <jaseemabid> Cale: If you dont mind, can you have a look? It blocks on line 41/42. Its not much code. https://github.com/jaseemabid/storm/blob/master/src/Control/Concurrent/Bench.hs
19:25:35 <hackrilege> i dont even understand Writer yet
19:25:39 <hackrilege> tooo advanced
19:25:56 <ski> hackrilege : anyway consider `mystery2 :: (forall a. [a] -> [a]) -> ([Integer],String); mystery2 polyFun = (polyFun [0,1,2,3],polyFun "abc")' -- in this case we really *need* `polyFun' to be polymorphic, since we're using it twice, with `a' set to a different type in each case !
19:26:00 <hackrilege> ill get back to it i rpomise, but at the mo its just an annoying bug
19:26:13 <jaseemabid> Cale: I cant *see* how this condition can happen. I've been reading the book by Simon Marlow and trying to debug since a while. 
19:26:18 <ski> hackrilege : that's an example of really using the polymorphism as polymorphism, not just as information hiding
19:26:25 <ski> hackrilege : with that, i'll stop here
19:26:44 <jaseemabid> Cale: It *always* runs fine in ghci. It errors maybe 4/5 times with the binary.
19:27:35 <Cale> jaseemabid: Where is this Control.Concurrent.Actor from? I take it that's where you're getting spawn?
19:27:50 <jaseemabid> Cale: Its in the same folder
19:27:58 <Cale> oh, I see
19:28:02 <ski> hackrilege : not sure what line the problem is at, nor what the error message is
19:28:13 <hackrilege> no error just goes black
19:28:45 <jaseemabid> Cale: I'm trying to learn the concurrency bits by writing a tiny actor model implementation. The little actor increments a counter. I'm measuring how long it takes for the actors to send 100K messages
19:28:46 <hackrilege> running either test or test2
19:30:43 <hackrilege> hmmmmm so in the mystery2 example, without the forall a. it would have complained?
19:30:59 <ski> yes
19:31:06 <hackrilege> coool
19:31:11 <hackrilege> ok thats also really nice
19:31:14 <ski> > let mystery2 polyFun = (polyFun [0,1,2,3],polyFun "abc") in mystery2 reverse
19:31:16 <lambdabot>      No instance for (Num Char) arising from the literal ‘0’
19:31:16 <lambdabot>      In the expression: 0
19:31:16 <lambdabot>      In the first argument of ‘polyFun’, namely ‘[0, 1, 2, 3]’
19:31:20 <hackrilege> i needed that in the past
19:31:24 <ski> > let mystery2 :: (forall a. [a] -> [a]) -> ([Integer],String); mystery2 polyFun = (polyFun [0,1,2,3],polyFun "abc") in mystery2 reverse
19:31:25 <lambdabot>  ([3,2,1,0],"cba")
19:31:41 <ski> hackrilege : it's good to know that you can do this, when you sometimes need it
19:32:03 <ski> you need `Rank2Types' extension to be able to write `(forall a. ..a..) -> ...' in a type signature
19:32:15 <hackrilege> i think i need magic right now to fix this bug
19:32:21 <ski> (iow, to be able to have a polymorphic argument)
19:32:57 <hackrilege> either its creating a huge list of nothings, or its zooming out on itself which is my worst fear
19:33:02 <ski> > let mystery2 polyFun = (polyFun [False,True],polyFun "abc") in mystery2 reverse  -- using `Bool' instead of numbers, to get it complain more lodly
19:33:03 <lambdabot>      Couldn't match type ‘Char’ with ‘Bool’
19:33:04 <lambdabot>      Expected type: [Bool]
19:33:04 <lambdabot>        Actual type: [Char]
19:33:14 <ski> (s/lodly/loudly/)
19:34:00 <hackrilege> its ok i get the error
19:34:17 <hackrilege> can you see what my code is actually doing?
19:34:37 <ski> then i'd probably have to read most or all of it
19:35:04 <hackrilege> ist super straitforward except the bits that actually do stuff
19:35:21 <hackrilege> which are probably where the bug is
19:35:31 <hackrilege> just a load of instance wrappers and junk
19:35:42 <hackrilege> http://lpaste.net/161317
19:35:43 <ski> well, the fact that i haven't slept much probably doesn't help
19:36:03 <jaseemabid> Cale: The stack.yml file compiles with -threaded. I don't understand how running inside ghci consistently gives a different result. 
19:36:04 <hackrilege> you need a cup of cofree
19:36:32 * jaseemabid was up all night as well 
19:36:32 <Cale> jaseemabid: Well, lots of stuff is different about how ghci does things, it's hard to say.
19:37:07 <ski> (otoh, i can (apparently) explain scoped type variables and rank-2 types, even when i'm having trouble focusing enough to comprehend what code like yours is doing. go figure ..)
19:37:30 <jaseemabid> Cale: I'm trying to see how this code will behave if everything ran much slower (maybe like ghci). I cant *see* the deadlock :/
19:37:49 <hackrilege> i figure my code is pretty nuts
19:38:59 <hackrilege> im *this* close to getting a Free Zipper!!!!!!!
19:39:32 <hackrilege> but i think its going all comonad on me and im going to have to join it up somehow
19:39:41 <ski> hackrilege : `(a,b) == (pop (push a b))' ought to be `Just (a,as) = pop (push a as)'
19:41:06 <hackrilege> oh in the comment thanks
19:41:16 <ski> hackrilege : `(uncurry push) . pop == id == pop . (curry push)' ought to be `fmap (curry push) . pop = Just' and `Just = pop . curry push'
19:41:34 <hackrilege> thanks!
19:41:55 <ski> (it should be `=', not `=='. `==' is only for stuff in `Eq'. functions are not in `Eq'. also you can't join the latter two laws there on `Just', since the types are different
19:41:56 <Cale> jaseemabid: I tried adding some prints throughout the code, and when I added them to 'run', it started not getting stuck
19:41:58 <ski> )
19:42:13 <ski>   view = fmap fst . pop
19:42:24 <jaseemabid> Cale: What should I learn from that? 
19:42:50 <ski> `ZipperTransformer' is dead
19:43:32 <hackrilege> its everywhere though and i made you look at it
19:43:41 <hackrilege> i mean, its centeral
19:43:49 <hackrilege> i was just about to go through and add it
19:43:51 <Cale> jaseemabid: Try adding  liftIO . putStrLn $ "hello!" in between second <- spawn $ actor two and send second $ Data first 0
19:43:51 <ski> `instance (Zipable z s,Stack s) => Monad (z s)' is also overlapping with everything
19:43:58 <ski> as is the `Applicative' instance
19:44:13 * ski suggests also adding them as superclasses to `Zipable' instead
19:44:15 <hackrilege> they should all be superclasses to z s
19:44:22 <hackrilege> coool
19:44:29 <hackrilege> ok ill do that now see if it helps
19:44:36 <hackrilege> thanks so much for reading my code!
19:44:38 <Cale> jaseemabid: Let's think about what happens when send starts running before much of the code for actor two has run...
19:45:11 <ski> `pure = ...' could just as well be `pure = return'
19:45:39 <ski>   return = toZipper . (`push` clean)
19:45:49 <Cale> jaseemabid: Ah, I see
19:45:58 <ski>   v >>= f = toZipper (fromZipper v >>= fromZipper . f)
19:46:01 <ski> or possibly
19:46:12 <ski>   v >>= f = toZipper (fromZipper . f =<< fromZipper v)
19:46:23 <jaseemabid> Cale: I see! The mailbox wont be setup by the time the first message is sent. It becomes a no-op. 
19:46:28 <Cale> yes
19:46:41 <jaseemabid> Cale: Thank you! :beer: 
19:47:03 <ski> hackrilege : hm .. i suppose also `Alternative',`MonadPlus',`Foldable'
19:47:25 <jaseemabid> The small delay b/w spawn and the actor mailbox being not ready. Damn! This stuff is hard. 
19:47:54 <ski> hackrilege : an alternative to all these superclasses is to only add the specific instances that you need (which you'll have to do anyway, in the case with the superclasses). but possibly without requiring the superclasses
19:48:16 <jaseemabid> Cale: Spawn must take care of this I think. 
19:48:38 <hackrilege> got them all at once with a MonadPlus superclass constraint
19:48:38 <ski> hackrilege : however, you may then sometimes have to add more constraints than a `Zipable' constraints, when you need to use some of those former superclasses
19:49:02 <ski> hackrilege : well, `Alternative' isn't a superclass of `MonadPlus'
19:49:08 <hackrilege> yes it is
19:49:27 <Cale> jaseemabid: Yeah... I'm imagining that you create an empty MVar () inside spawn, and just write () to it after initialize, and then take the MVar immediately before returning from spawn
19:49:49 <jaseemabid> Yes. I should do that.
19:50:52 <ski> hackrilege : i don't think it is
19:51:02 <ski> (it's not in this GHC version, at least)
19:51:44 <hackrilege> its not
19:51:47 <hackrilege> hmmm
19:52:21 <Cale> jaseemabid: I tried it and it seems to work
19:52:22 <hackrilege> ahhh its an ALTERNATIVE
19:52:27 <hackrilege> to MonadPlus
19:52:33 <hackrilege> for Applicatives
19:52:42 <hackrilege> i remember
19:52:55 <lpaste> Cale pasted “spawn” at http://lpaste.net/161318
19:53:21 <hackrilege> Alternative is to Applicative as MonadPlus is to Monad
19:53:30 <ski> hm, i don't think `empty' and `(<|>)' have to agree with `mempty' and `mplus', for types in both `Alternative' and `MonadPlus' .. but i'm not sure of what would be a counterexample
19:53:31 <hackrilege> trying to get them to behave like Monoids
19:54:00 * ski idly wonders whether Cale knows of one
19:54:15 <hackrilege> its about not having join
19:54:39 <Cale> ski: Well, I'm sure there's *something* which has two monoid structures on its actions
19:55:20 <ski> yes, but some knows example in the community, that has some reasonable use :)
19:55:29 <ski> s/knows/known/
19:55:53 <jaseemabid> Cale: Fixed. Thanks again. https://github.com/jaseemabid/storm/commit/f3919d434725999eaad427cd5a643f2f8794c176
19:55:57 <geekosaur> (Num? :p )
19:56:12 <hackrilege> Applicative should be identical to Monoid but without join? laws are same?
19:56:24 <Cale> hackrilege: hm?
19:56:46 <Cale> hackrilege: Alternative is for Applicative functors which "create monoids" in the sense that f a is a monoid for any type a
19:56:54 <ski> in any case, even if we'd want to require them to agree, imo we'd then need a further subclass to both `Alternative' and `MonadPlus' (or to make `MonadPlus' a subclass of `Alternative' as well) .. unless they're some way to prove they agree, with what we already have
19:56:56 <hackrilege> are the laws of applicative the same as monad?
19:57:00 <Cale> and similarly MonadPlus is for monads which "create monoids" in the same sense
19:57:00 <ski> (assuming the `Applicative'
19:57:09 <ski>  and `Monad' structure agree, say)
19:57:10 <Cale> hackrilege: No, they can't be
19:57:31 <jaseemabid> Cale: So I can send about 100K messages in 1s. This is pretty nice :D 
19:58:00 <Cale> jaseemabid: Yeah, the Haskell RTS is pretty good
19:58:12 <Cale> I should say, the GHC RTS
19:58:52 <jaseemabid> Cale: I write Erlang at work, but end up missing types all day. This is an experiment to bridge the gaps 
19:59:09 * hackagebot servant-csharp 0.0.7.0 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.7.0 (KatsutoshiItoh)
19:59:12 <hackrilege> :t (>=>)
19:59:13 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:59:18 <hackrilege> :t <*>
19:59:18 <jaseemabid> Cale: Will write very similar erlang code to see how that goes.
19:59:18 <Cale> jaseemabid: Have you seen distributed-process/Cloud Haskell?
19:59:19 <lambdabot> parse error on input ‘<*>’
19:59:25 <hackrilege> :t (<*)>
19:59:26 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:59:29 <hackrilege> :t (<*>)
19:59:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:59:50 <jaseemabid> Cale: Yes. I thought it will be a fun experiment to build from scratch. 
20:00:03 <hackrilege> ok im not going to really consider that now
20:00:51 <jaseemabid> Cale: And so far it is. Well, learned monad transformers to write this code. So win! 
20:01:25 <ski> hm, does `mplus' have to be a monad morphism ?
20:01:43 * ski ponders whether the questions makes any sense
20:02:08 <Cale> jaseemabid: https://skillsmatter.com/skillscasts/3523-cloud-haskell is a really fun talk (you might have to create an account to watch it though)
20:04:04 <ski> Cale :/
20:04:12 <hackrilege> Cale :/
20:04:29 <Cale> ski: Oh, uhh... not really?
20:04:50 <jaseemabid> Cale: I'l do that. 
20:04:58 <Cale> https://wiki.haskell.org/MonadPlus_reform_proposal
20:05:19 <ski> i suppose `\a -> m a * m a' is probably not a monad ?
20:06:18 <hackrilege> cannot infer Num
20:06:20 <ski> hm, i suppose you could take the diagonal
20:07:32 <hackrilege> your talking Sum vs Product MonadPlus?
20:08:45 <hackrilege> no your doing something strange
20:09:01 <ski> who ?
20:09:06 <hackrilege> you
20:09:09 <hackrilege> what that *
20:09:44 <ski> well, i was pondering whether `mplus_a : m a * m a >---> m a' could be thought of as a monad morphism
20:10:05 <ski> (that's just te uncurried version of the usual `mplus')
20:10:38 <hackrilege> ok
20:10:50 <hackrilege> i think of mplus as push
20:10:57 <hackrilege> or (++)
20:11:06 <hackrilege> push being (:)
20:11:30 <ski> (fwiw, i'd call your `pop', `pull')
20:11:36 <hackrilege> thanks
20:12:06 <hackrilege> i think the problem is that im doing this cojoin thing to fmap over
20:12:13 <hackrilege> to define fmap
20:12:18 <hackrilege> and its going mad
20:12:25 <ski> (because `pull' is the term in the assemblers i've used most. i know `pop' is more common in some circles)
20:12:34 <hackrilege> ok
20:13:03 <hackrilege> as long as i follow some convention im ok
20:14:14 <hackrilege> line 88 i think is the bug
20:14:23 <hackrilege> http://lpaste.net/161317
20:19:05 <hackrilege> to define fmap for a Zipper is ok, but im trying to do it for Zipable z, so im using zmap, which i can construct without going into the structure
20:19:06 <hackrilege> lol
20:19:09 <hackrilege> dumb bug
20:19:47 <hackrilege> "i cant get into this thing until its specified, so ill run away from it!"
20:20:17 <hackrilege> man that hurt my head. sorry, at least its an easy fix!
20:21:24 <hackrilege> writing instances for constraints is just really really dumb! its not like they didnt warn me...
20:44:15 <orion> Does anyone know of SCTP+Haskell in the wild?
20:47:18 <MichaelBurge> What is the difference between TemplateHaskell and TemplateHaskellQuotes?
20:49:04 <mgsloan> MichaelBurge: Not 100% sure, I believe the difference is that with TemplateHaskellQuotes all you can use is AST quotes.  This way you aren't actually running any TH that requires loading all your dependencies into GHCI
20:49:24 <mgsloan> TemplateHaskellQuotes is new in 8.0, right?
20:49:46 <MichaelBurge> mgsloan: Yeah, I saw it at the top of Data.Aeson.TH and was wondering what it was. It's conditional on GHC 8
20:50:25 <mgsloan> Yeah, pretty sure its like "I'm writing template haskell code, but I don't actually need to run anything at compiletime"
20:51:38 <MichaelBurge> mgsloan: The context is in a module that emits instance declarations at compile-time for ToJSON and FromJSON, so it's doing a little more than just quoting expressions into ASTs
20:52:14 <mgsloan> Are you sure?  If it's just defining the compiletime functions, then it doesn't need to do anything at compiletime
20:52:25 <mgsloan> it's only the users of that module that need to run things at compiletime
20:52:50 <Lucie20> Picture of me naked: http://imagetwist.com/1hedff9hr76f/Lucie.jpg  Would you fuck me? :)
20:52:52 <Lucie20> Picture of me naked: http://imagetwist.com/1hedff9hr76f/Lucie.jpg  Would you fuck me? :)
20:53:14 --- mode: ChanServ set +o shachaf
20:53:18 --- mode: shachaf set +b *!*Damn@197.14.9.*
20:53:18 --- kick: Lucie20 was kicked by shachaf (Lucie20)
20:53:22 --- mode: shachaf set -o shachaf
20:53:37 <MichaelBurge> mgsloan: Oh that makes sense. Yeah, all it's doing is building the instance itself to be spliced in by the user.
20:53:50 <mgsloan> Yup!
21:08:50 <smarttang> hello :)
21:08:53 <smarttang> - - #
21:09:21 <Cale> smarttang: hello!
21:09:33 <smarttang> - - # 终于有人了
21:09:57 <Cale> Yeah, it's a bit quiet at the moment
21:10:07 <Cale> somehow
21:10:28 <smarttang> Cale 我还以为都是挂机的；）
21:11:09 <Cale> haha
21:11:32 <smarttang> Cale Are you chinease?
21:12:10 <Cale> No, but Google Translate made that understandable enough
21:13:20 <smarttang> Cale I'm sorry..i thought you are chinese...
21:13:41 <smarttang> Cale :)
21:13:47 <Cale> It's quite all right :)
21:15:58 <smarttang> 这个频道都是说英语的么...
21:16:12 <smarttang> - - # 英语比较差
21:16:12 <pavonia> English please
21:16:33 <kadoban> Almost always english speaking
21:16:54 <Cale> There might be a Chinese speaking channel...
21:17:08 * smarttang
21:17:11 <smarttang> pavonia ok ! sorry ....
21:17:18 <Cale> There's #haskell-cn
21:17:25 <kadoban> Yeah, there's not many people in there though :-/
21:17:34 <kadoban> Is English only even a rule?
21:17:36 <Cale> Yeah, only 8
21:17:49 <thimoteus> where ARE the rules?
21:17:51 <Cale> I don't think it's a strict rule.
21:18:07 <Cale> The only real rule is "be nice".
21:18:31 <smarttang> learn english in here.. :)
21:18:37 <Cale> :)
21:19:34 <smarttang> Cale where are you?
21:19:47 <Cale> I'm in Brantford, Ontario, Canada
21:20:32 <smarttang> Cale o o
21:21:03 <smarttang> more far away..
21:21:24 <smarttang> google translate....
21:21:30 <Cale> monochrom: You know Chinese, don't you? :)
21:22:11 <smarttang> monochrom you know chinese??
21:22:18 <Lovepon> Hmmm
21:22:31 <smarttang> hi
21:22:45 <Lovepon> Hey.
21:23:39 <slack1256> lovepon...
21:23:42 <slack1256> that handle
21:23:47 <Cale> smarttang: Do you have any questions about Haskell?
21:24:09 <Lovepon> slack1256: Do you need some execution?
21:24:26 <Lovepon> slack1256: 'w'
21:24:35 <slack1256> oh, and stop it. Jack has suffered enough
21:24:57 <Lovepon> YAY
21:25:04 <Lovepon> SOMEONE THAT SHARES THE SAME INTEREST. :D
21:25:05 <slack1256> anyways, any haskell question?
21:25:27 <Lovepon> Yiss
21:25:49 <Lovepon> I need a random number generator for reflex.
21:25:57 <Lovepon> But I have no idea how.
21:26:01 <Cale> Are you using reflex-dom?
21:26:12 <Lovepon> Cale: Yes.
21:26:42 <Lovepon> I'm thinking of doing something like `f :: Random a => a -> Event t a `
21:26:49 <smarttang> Cale This time not have question..
21:26:55 <Lovepon> Or something.
21:27:38 <Cale> Lovepon: Okay, I'll write you one... probably what you really want is something like (MonadWidget t m, Random a) => Event t x -> Event t (a, x)
21:27:41 * slack1256 knows nothing on web-dev but thinks reflex looks cool
21:28:03 <Lovepon> Cale: Yeah!
21:28:03 <Cale> reflex ought not to just be for web-dev, but that's what we've been paid to do with it thus far
21:28:31 <Lovepon> Cale: That, or (a -> x -> c) -> Event t x -> Event a c
21:28:39 <Lovepon> Which is really my use case.
21:28:49 <Cale> Actually, having just re-watched that Cloud Haskell talk, I think reflex-distributed-process would be really cool :)
21:29:58 <Cale> Lovepon: anyway, the idea is just to use performEvent
21:30:18 <Lovepon> Cale: That's what I was thinking of too.
21:30:45 <Lovepon> Cale: Problem is, I don't understand the function definition of performEvent.
21:33:02 <Lovepon> Heck, what does ~ on a typeclass mean?
21:33:15 <kadoban> Lovepon: It's like equality
21:34:06 <kadoban> I don't really quite understand that part of the sig either, but I've managed to use performEvent anyway, if that helps.
21:34:31 <Lovepon> kadoban: lol
21:34:42 <Lovepon> I see.
21:35:04 <kadoban> Lovepon: I think of the WidgetHost m a as essentially ... IO a, but can do reflexy stuff too.
21:35:29 <kadoban> That's probably not quite correct, but so far it's worked. It's an instance of MonadIO, so you can use liftIO
21:35:29 <Lovepon> I want it to be pure though.
21:36:08 <kadoban> Lovepon: I suspect that's not possible, but you can contain the impurity down to a quite small part.
21:36:31 <Lovepon> kadoban: Even if I use a DRBG?
21:36:39 <Lovepon> Or DRG.
21:36:43 <Lovepon> Meh, same stuff.
21:37:42 <kadoban> Not sure what that is.
21:38:09 <Lovepon> kadoban: Deterministic Random Generator.
21:38:49 <Lovepon> kadoban: What I want to do is that every time an Event occurs, it will get a value from the random generator.
21:39:00 <Lovepon> Or something.
21:39:27 <kadoban> Not sure. Really I'd just use the IO ones personally inside a performEvent and call it good.
21:40:25 <kadoban> There's probably some way with like an infinite stream of random values set up at the beginning and then you take one at a time on an event, but ... seems like not really a win to me in any way.
21:40:31 <Cale> Lovepon: http://cale.yi.org/random.jsexe/
21:41:13 <Cale> Lovepon: We could also take the bounds as part of the event...
21:41:25 <Cale> Or even use Traversable in a nice way here...
21:41:36 <Lovepon> Cale: No way to do it purely?
21:41:44 <Cale> Lovepon: Well, random numbers aren't pure
21:41:56 <Lovepon> Cale: A deterministic random generator.
21:42:06 <Cale> Oh, well, if you want to use mkStdGen, sure
21:42:19 <Cale> But then you don't even need performEvent
21:42:43 <Lovepon> Cale: Right.
21:42:52 <Cale> If you want, I can do that one...
21:42:54 <Lovepon> Cale: How would I do it without using performEvent?
21:43:16 <Lovepon> I was thinking of doing some kind of recursion for this, but not exactly sure how that'd work. :P
21:47:34 <jle`> any way i can list all of the transitive dependencies of a given package?
21:48:25 <kadoban> jle`: stack list-dependencies, cabal-install ... I dunno, probably some way.
21:50:02 <slack1256> jle`: cabal freeze?
21:51:15 <shanemikel> Okay, I'm gathering some information to inform the decision on whether I can (or should) implement an interface to this c library (guile).  It's actually turning out to be quite a sophisticated series of problems.. first of all, basically guile is an extensible scheme interpreter + c library for embedding it into c applications (it's extremely flexible and robust).
21:51:26 <jle`> kadoban: hm, can't find a way to do it using list-dependencies ><
21:51:50 <jle`> trying to look up all the deps pulled in for http://hackage.haskell.org/package/ad-4.3.2
21:52:03 <jle`> must be a better way than stack unpacking
21:52:11 <kadoban> jle`: Isn't it just literally 'stack list-dependencies' inside the package? Or am I misunderstanding something? Oh I dunno without unpacking.
21:52:21 <jle`> i guess i can unpack
21:53:12 <shanemikel> So far, I'm faced with two big problems.. It's running its own garbage collector, but I still have to figure out the details of how it works before I can think about how to approach it.. second, It uses continuations and it's own exception system
21:53:15 <Cale> Lovepon: http://cale.yi.org/randomPure.jsexe/
21:53:46 <shanemikel> How the heck do exceptions work in an ffi?
21:55:41 <Lovepon> Cale: Wow.
21:55:42 <slack1256> exceptions on C?
21:55:43 <Lovepon> Cale: Thanks.
21:55:54 <shanemikel> yeah
21:55:56 <Cale> Lovepon: No problem!
21:56:03 <shanemikel> Idk.. they must have implemented it with gotos or something
21:56:17 <slack1256> but C prefers return codes right?
21:56:21 <Lovepon> Cale: I'll be using this in a non-open source code, is that fine with you?
21:56:26 <Cale> Yep
21:56:45 <shanemikel> https://www.gnu.org/software/guile/manual/html_node/Control-Flow.html#Control-Flow
21:57:28 <shanemikel> Since Scheme functions can call C functions and vice versa, C code can experience the more general control flow of Scheme as well. It is possible that a C function will not return at all, or will return more than once......
21:57:42 <slack1256> Coooool!
21:57:42 <Cale> Lovepon: I might at some point release that code as part of open source examples for Reflex though :)
21:58:02 <Lovepon> Cale: Hmm...
21:58:41 <Cale> Of course, you're already using reflex and reflex-dom, so it's probably going to be okay on your end :D
21:59:13 <Cale> I have some other ideas about what we could do to make this more general
22:01:02 <Lovepon> I've never worked with recursive dos before. Hahaha.
22:01:30 <Lovepon> Cale: Is mdo just `do rec`?
22:01:43 <Cale> Lovepon: kinda sorta
22:02:03 <kadoban> Oh are they different? Heh I've just been using them interchangably.
22:02:09 <Cale> mdo automatically finds the recursive blocks
22:03:19 <Cale> The rec syntax is a little more straightforward: each rec corresponds to a single usage of mfix
22:03:53 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#idp46686523425648 -- check out the example there, comparing mdo and rec
22:04:36 <kadoban> Does mdo make errors worse sometimes when you do something wrong? I noticed at one point that my haskell error messages had gotten ... much less useful than normal. Part of it was a somewhat sparsity of type sigs, but I'm still not sure if that was all of it.
22:05:03 <Cale> It's been a long while since I used mdo, so I couldn't really say
22:05:39 <kadoban> Hmm
22:06:22 <Lovepon> What would be a good place to learn more about Haskell?
22:07:25 <kadoban> I must be missing something, I should probably read more about mfix ... right now I pretty much just throw mdo on the front and call it good.
22:08:42 <Lovepon> kadoban: lol.
22:12:04 <sto0pkid> hi what does the "!" mean in this: "data Variable = NamedVar !Text | GenSym !Text !Integer | Dummy"
22:14:06 <shanemikel> That's "Bang pattern", no?
22:14:14 <shanemikel> think it has something to to with strictness
22:15:16 <kadoban> sto0pkid: It marks the field as strict. I'm not sure this is technically accurate description, but I think of it as meaning that when you have a NamedVar that is in WHNF, then the Text there is also in WHNF, for example.
22:16:06 <kadoban> Meaning that   NamedVar undefined   works like   undefined (which isn't the case without the !)
22:17:51 <sto0pkid> i see, thanks
22:19:12 <Lovepon> Cale: Oh, right. Why does hold return `m (Behavior t a)`? What's wrong with `Behavior t a` by itself?
22:19:14 * hackagebot cheapskate 0.1.0.5 - Experimental markdown processor.  https://hackage.haskell.org/package/cheapskate-0.1.0.5 (JohnMacFarlane)
22:20:02 <Cale> Lovepon: Well, because it needs to create a state cell to remember things over time.
22:21:08 <Cale> Lovepon: Also, the restriction that you need MonadHold, or don't need MonadHold also tells you something about the statefulness or statelessness of a Reflex computation.
22:21:33 <Lovepon> Cale: I see.
22:23:27 <Cale> For now, hold is the only primitive through which things can be remembered over time. If you have a pure function of Events which doesn't need MonadHold anywhere, you know that the output Event's value is a pure function of the values in the firing input events at that moment.
22:23:59 <Cale> Similarly with a function that does a pure computation involving Behaviors
22:25:17 <Cale> You also always know, even with MonadHold and MonadSample, that the output Event only fires at times when at least one of the input events is firing. MonadWidget gives you, through performEvent, some additional ways to get event occurrences.
22:25:23 <nitrix> How is ≡ pronounced?
22:25:31 <Cale> nitrix: In what context?
22:25:47 <nitrix> "Perfectly equivalent"
22:25:48 <shanemikel> If I have a c function that expects a function pointer, how can I create a haskell function, and pass it in a foreign c call?
22:25:53 <shanemikel> or "is equal to"
22:25:56 <Cale> nitrix: It's generally some additional sort of equality.
22:26:05 <Cale> If you have more than one kind of equality to worry about.
22:26:09 <shanemikel> "is defined as"
22:26:45 <nitrix> Cale: I'm interested as in, the identity of two mathematical expressions.
22:27:06 <Cale> Yeah, the HoTT book uses it for definitional or judgmental equality, rather than propositional equality, for which it uses =
22:28:09 <Cale> nitrix: It's just an additional symbol which people use for equality-like equivalence relations of various sorts -- it doesn't really have a unified pronunciation.
22:29:14 * hackagebot aivika-distributed 0.1.3 - Parallel distributed simulation library  https://hackage.haskell.org/package/aivika-distributed-0.1.3 (DavidSorokin)
22:33:09 <Cale> Lovepon: you might also be interested in this version: http://cale.yi.org/randomPure.jsexe/
22:48:00 <Cale> Lovepon: heh, http://cale.yi.org/random.jsexe/
22:50:06 <Ralith> Cale: ghcjs?
22:50:16 <Cale> Ralith: yeah, and reflex-dom
22:50:31 <Ralith> I gotta get that set up
22:50:45 <Cale> Ralith: There's a really easy way...
22:50:54 <Cale> https://github.com/reflex-frp/reflex-platform
22:51:12 <Cale> (scroll down for the readme)
22:51:34 <Cale> It'll save you the trouble of spending a few hours compiling ghcjs
22:51:56 <Ralith> sounds like a plus
22:52:07 <Ralith> I've been distributing some cross-patform tools lately and packaging stuff for windows/osx is such a huge pain
22:52:50 <Cale> heh, so compile them into web applications? :D
22:53:08 <Ralith> might run into some issues because I issue HTTP requests to other servers
22:53:20 <Ralith> still, could make a reduced version that avoids that
22:55:46 <Ralith> plus people like not having to download things
23:19:28 <smarttang> ..
23:20:38 <Ralith> Cale: wait, this is just a bootstrap script for nix? ahaha
23:20:42 <Ralith> that's awesome
23:47:00 <sgronblo_> Hey, how do you run your exectuable with stack?
23:59:56 <cocreature> sgronblo_: stack exec executablename -- arguments
