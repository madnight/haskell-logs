00:07:39 * hackagebot table-layout 0.2.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.2.0.0 (muesli4)
00:07:39 * hackagebot tasty 0.11.0.3 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-0.11.0.3 (RomanCheplyaka)
00:26:57 <Lokathor> I just realized that I'm gonna have to rebuild all my packages when i move to the new stackage
00:27:09 <Lokathor> that's a big pile of packages
00:29:17 <EvanR> @djinn (a -> a) -> (b -> a) -> (b -> a)
00:29:17 <lambdabot> f a b c = a (b c)
00:30:53 <Lokathor> :t flip const
00:30:54 <lambdabot> b -> c -> c
00:31:11 <EvanR> :t flip (.)
00:31:12 <lambdabot> (a -> b) -> (b -> c) -> a -> c
00:31:37 <Lokathor> clearly, flip const is the winner, and exactly what you should write into your program
00:31:58 <EvanR> flip const is even right?
00:32:11 <ski> @. pl djinn (a -> a) -> (b -> a) -> (b -> a)
00:32:11 <lambdabot> f = (.)
00:32:23 <EvanR> yeah .
00:32:23 <Lokathor> flip const will match the signature you requested, but it will almost surely not do what you wanted to have happen
00:32:32 <EvanR> flip const doesnt match
00:33:04 <EvanR> oh it can match...
00:33:07 <ski> @type flip (.) . join (.)
00:33:08 <lambdabot> (b -> b) -> (b -> c) -> b -> c
00:33:15 <Lokathor> :t flip const :: (a -> a) -> (b -> a) -> (b -> a)
00:33:16 <lambdabot> (a -> a) -> (b -> a) -> b -> a
00:33:23 <EvanR> if we could write an a -> b then it would match ;)
00:33:33 <ski> clearly `forall a b. (a -> a) -> (b -> a) -> (b -> a)' is iso to the naturals
00:33:43 <EvanR> clearly
00:34:09 <ski> it must be of the shape `\f g -> g . (..f..)'
00:34:10 <Lokathor> you're the one that put (b -> a) into your request :3
00:34:28 <ski> and `..f..' must be some number of `f's, composed with each other
00:34:42 <Lokathor> i just dropped the (a -> a) on the floor and forgot about it
00:35:20 <ski> Lokathor likes simple implementations
00:35:28 <ski> (the simpler the better, presumably)
00:35:38 <EvanR> as simple as possible but no simpler
00:35:50 <ski> well, it was the simplest possible
00:35:58 <ski> (under the totality constraint)
00:36:05 <Lokathor> it was the simplest possible that would execute, yes
00:36:14 <Lokathor> undefined/error is cheating
00:37:34 * hackagebot hpack 0.13.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.13.0 (SimonHengel)
01:19:01 <EvanR> type Optical p q f s t a b = p a (f b) -> q s (f t)
01:19:38 <EvanR> come up clearly there needs to be 8 type variables to stabilize the electron structure
01:19:57 <EvanR> p q f g s t a b = p a (f b) -> q s (g t)
01:20:18 <EvanR> ;)
01:20:43 <EvanR> type Argon
01:22:09 <Zemyla> Night, everyone.
01:40:17 <EvanR> is there a prismy way to modify different cases of a sum type at once
01:40:34 <EvanR> like, use strategy 1 for Left and strategy 2 for Right
01:52:36 * hackagebot luminance 0.11.0.1 - Type-safe, type-level and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.11.0.1 (DimitriSabadie)
01:57:37 * hackagebot json-encoder 0.1.7 - A direct-to-bytes single-pass JSON encoder with a declarative DSL  https://hackage.haskell.org/package/json-encoder-0.1.7 (NikitaVolkov)
02:33:06 <deepfire> is there something that captures the type :: Monad m => ((a -> b), (b -> a)) -> a -> m b -> m a  ?
02:33:56 <opqdonut> what would that do?
02:34:16 <opqdonut> how about "f _ x _ = return x"?
02:34:28 <deepfire> basically, 'a' is a monomorphic newtype around 'b'
02:34:52 <opqdonut> but how do you combine a and m b?
02:35:12 <deepfire> I want to be able to provide the lift/unlift operations (the first argument tuple)
02:35:21 <opqdonut> anyway, for expressing isomorphisms there's e.g. https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Iso.html
02:36:28 <deepfire> ...and in the end, I want to be able to  lift the monadic operation on 'b' into a monadic operation on 'a'
02:36:59 <opqdonut> yes, but what does the plain "a" do?
02:37:21 <deepfire> not sure, maybe it's not needed
02:37:47 <deepfire> it was supposed to be an initial argument for the monadic computation 
02:38:45 <deepfire> opqdonut: thank you!
02:39:09 * deepfire comes to study Control.Lens.Iso
02:39:28 <opqdonut> it might be a bit daunting if you're not familiar with Control.Lens
02:39:57 <opqdonut> you might be better of with some custom machinery for working with a "data Iso a b = Iso (a->b) (b->a)"
02:39:59 <EvanR> profunctors all the way down
02:40:41 <opqdonut> ah there's also https://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html
02:40:44 <opqdonut> which might be simpler
02:41:24 <deepfire> wow, cool..
02:41:57 <deepfire> EvanR, do you mean to imply that profunctors might also be a solution?
02:43:25 <amnn> deepfire, there is a formulation of the lens heirarchy using profunctors
02:44:10 * deepfire feels awash with warm fuzzy knowledge..
02:45:14 <Xandaros> Can somebody recommend a library to modify XML documents? I do have a dtd (though I probably won't need it) and I need to change some attributes. I know the path to the nodes that need their attributes changed but whether or not they get affected might depend on attributes of parent tags
02:45:31 <EvanR> deepfire: i was just trying to understand Control.Lens and noticed a lot of stuff is implemented with profunctors
02:46:13 <EvanR> which makes sense because lenses are a bidirectional thingie
02:46:46 <EvanR> and all these crazy shapes correspond to the way that the bidirectionality works
02:47:12 <opqdonut> Xandaros: you could try https://hackage.haskell.org/package/xml for something simple, or http://hackage.haskell.org/package/hxt for something complicated
02:48:47 <deepfire> EvanR, so it could be that starting with profunctors is a more reliable approach of learning lens? 
02:49:08 <EvanR> no but profunctors are good to know anyway
02:49:19 <EvanR> i think. i still dont really understand lens
02:52:57 <Xandaros> opqdonut: Hmm, guess I'll take a closer look at hxt, then. Thanks
02:53:22 <arianvp> Hey
02:53:23 <Xandaros> Not a big fan of arrows, though :/
02:53:31 <arianvp> If I have a stack  of  two WriterTs
02:53:38 <arianvp> how do I write to a specific writer?
02:53:57 <arianvp> There are two monoids I want to keep track of during computation
02:54:23 <arianvp> possible?
02:55:37 <liste> arianvp: use `lift'
02:55:53 <liste> :t lift
02:55:54 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
02:56:53 <liste> to lift the correct layer of the stack, then read it. it's wieldy though
02:57:05 <liste> write*
02:57:39 <arianvp> hmm
03:00:00 <liste> you could also make a combined monoid and functions that run the "smaller" WriterTs in a combined WriterT
03:00:39 <EvanR> hide whatever stack of transformers you decided to use behind an interface that does the correct lifting and has better names for the operations you want to do
03:01:03 <EvanR> like logError and logUnusualActivity
03:01:12 <arianvp> oh yeh
03:02:14 <Xandaros> What EvanR said. In fact, I recommend you don't ever expose the actual transformers. Working with transformer stacks is annoying and should (in my opinion) be limited to the module in which it is defined
03:02:36 <Xandaros> And have it look like a flat monad to the outside
03:05:30 <EvanR> even then its annoying just not as much, once its over
03:06:07 <EvanR> and im beginning to see extensible effects doesnt solve it either
03:06:44 <Xandaros> The library or the concept?
03:07:05 <arianvp> hmm
03:07:06 <EvanR> oh, which library
03:07:14 <arianvp> Well I preferably would have all stuff Polymorphic
03:07:20 <arianvp> use the MonadWriter class etc
03:07:34 <arianvp> That way you don't limit yourself to a specific transformer stack
03:07:35 <Xandaros> EvanR: extensible-effects :P
03:08:11 <EvanR> if you have 2 or 3 MonadWriter parameters youre in a world of hurt for writing a real program
03:08:12 <arianvp> Anyhow.  I need to build a monad  Where I have a tuple of monoids   (W,W)  where one needs to be stored durable (persistant over restart) and the other volatily
03:08:22 <arianvp> yeh probably
03:08:25 <EvanR> how many tells and lifts can i tolerate before it looks like gibberish
03:08:29 <Xandaros> arianvp: If it actually makes sense. Don't just use them because they're there. In most cases, it does more harm than good
03:08:53 <EvanR> arianvp: acid-state ?
03:09:04 <Xandaros> EvanR: extensible-effects :P
03:09:06 <arianvp> yeh I might look at acid state for the durable part of the tuple
03:09:11 <Xandaros> sry
03:09:27 <EvanR> in case of acid state it wouldnt be in a tuple
03:09:34 <arianvp> But I need no atomicity guarentees
03:09:36 <arianvp> only durability
03:09:52 <EvanR> luckily durability is in the acronym
03:10:03 <arianvp> Because the data structures im working with are idempotent and commutative
03:10:06 <ij> In lambda calculus, judging by wikipedia any variable x is a lambda term. If t, s are lambda terms, then ts is a lambda term. So you can apply variables to non-functions?
03:10:20 <ij> Or are all variables functions?
03:10:31 <EvanR> everything is a function, its untyped
03:10:34 <Xandaros> ij: lambda calculus doesn't have types
03:10:41 <ij> Ok, cool.
03:10:52 <arianvp> You can write lambda expressions that can't be correctly evaluated iirc
03:11:13 <EvanR> beta reduction always works
03:11:26 <EvanR> 1 step at a time
03:11:42 <ij> Right! Thanks.
03:12:03 <Xandaros> You only get into trouble if you assign some semantic to your lambda terms :P
03:12:45 <EvanR> gotta love syntax-only semantics 
03:15:10 <Acuzzio> Quick question: b = 25.38577     if I use    printf "%e" b    I am obtaining 2.538577e1   ->   but I want this specific format     2.538577e+01      how to do that? It is not easy to find it in the documentation... 
03:15:26 <Guest76377> Is there a  way to prevent cabal from processing .hsc  files and use the already generated .hs files instead?
03:16:15 <Guest76377> Or atleast to specify flags to hsc2h2
03:21:14 <madgen> does anyone have suggestions for making Haskell development cycle a bit faster
03:21:31 <madgen> right now "stack test" is a huge bottleneck
03:21:56 <deepfire> there is halive
03:22:41 <deepfire> ...which is all about shortening the dev cycle, but it won't give you coverage
03:23:10 <deepfire> it is kinda amazing, if you developing something interactive, though..
03:24:15 <madgen> sadly it's a library & command line application...
03:25:00 <madgen> I wish GHC came with a tree interpreter :(
03:25:20 <deepfire> you can always make a test app, which will give you a dashboard of test results
03:25:37 <deepfire> then you can run the dashboard with halive
03:26:45 <deepfire> maybe it won't make /as much/ sense, because you won't have state to carry between sessions
03:27:17 <deepfire> but you'll get a dynamically updated dashboard on file saves
03:27:20 <madgen> yes, but I am not entirely convinced it will help all that much because most of the waiting comes from compilation.
03:27:39 * hackagebot solr 0.3.1 - A minimal Solr client library  https://hackage.haskell.org/package/solr-0.3.1 (NikitaVolkov)
03:27:56 <madgen> I don't do TDD per se but quite like to write a test sometimes and see it fail quickly.
03:28:33 <puregreen> deepfire: on Isos and profunctors: Profunctor is basically the simplest class that unites Forget and Tagged, which can be – loosely – thought of as “a function with an input and no output” and “a function with an output and no input” respectively. If you want to understand Isos, try the following exercises: 1. how to get (b -> t) from Iso s t a b, using Tagged as the choice of “p”? 2. how to get (s -> a) from
03:28:33 <puregreen> Iso s t a b, using Forget as the choice of “p”? 3. how to write a profunctor instance for “data Exchange a b s t = Exchange (s -> a) (b -> t)”? 4. how to get (s -> a) and (b -> t) from an Iso in one go, using Exchange? https://artyom.me/lens-over-tea-5#a-recap-of-isomorphisms – this might be sort of helpful, but might also be completely unintelligible
03:30:02 <madgen> deepfire: thanks anyway =) I'll check halive, maybe it gives me some boost!
03:30:20 <deepfire> madgen: +RTS -A<insert-a-large-number>m -RTS -O0 is what I use when I need faster builds
03:31:36 <deepfire> in my experience, giving RTS more memory speeds up builds
03:31:48 <madgen> deepfire: I'll try it now. Thanks for the tip.
03:32:28 <deepfire> puregreen: thank you a lot!
03:32:42 * deepfire captures the knowledge..
04:02:40 * hackagebot servant-csharp 0.0.8.0 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.8.0 (KatsutoshiItoh)
04:06:13 <maerwald> What libraries would you use for a simple REST api with mongodb (it's just JSON responses that correlate to the db). I was thinking of something more basic than yesod or snap.
04:17:41 * hackagebot extra 1.4.4 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.4 (NeilMitchell)
04:27:30 <Aruro> why System.Posix files thinks that /proc/pid/cwd is not symbolic link? isSybolicLink returns false.
04:27:48 <merijn> Aruro: Pretty sure /proc is magic voodoo
04:28:02 <Aruro> well file does no such mistake
04:28:13 <Aruro> file tells its symbolic link
04:28:19 <merijn> Is it, though?
04:28:46 <Aruro> have no idea :) ls thinks so too
04:28:58 <Aruro> and mc
04:29:00 <mfukar> Yes, it is supposed to be a symlink.
04:29:34 <merijn> System.Posix appears to just use the result from stat(2)
04:29:56 <Aruro> merijn: probably i should look at its  src
04:30:04 <merijn> So what does "stat" say for that file?
04:30:05 <Aruro> merijn: should be considered bug?
04:30:34 <MasseR> stat says it's a directory
04:30:51 <merijn> If stat says it's a directory, then System.Posix is right and file is wrong
04:31:02 <merijn> But since it's /proc it's probably a magic directory
04:31:11 <Aruro> short line to reproduce : getFileStatus "/proc/fav-pid/cwd" >>= (return . isSymbolicLink)
04:31:23 <Aruro> i get False
04:32:02 <merijn> Aruro: What does "stat -x /proc/pid/cwd" say?
04:32:41 <MasseR> merijn: I might not be aruro, but I don't have -x on ubuntu
04:32:50 <merijn> oh, I was guessing
04:32:50 <Aruro> my neither :)
04:32:53 <Aruro> archlinux
04:32:59 <Aruro> me*
04:33:01 <merijn> -x is listed as "similar to linux" in the man page :)
04:33:13 <merijn> oh
04:33:22 <merijn> -x just gets the default behaviour of linux
04:33:24 <infinity0> Aruro, merijn: probably stat dereferences the symlink
04:33:30 <Aruro> stat list it as symbolic link too
04:33:31 <infinity0> there's probably an option to make it not do the dereferencing
04:33:43 <MasseR> infinity0: ln -s foo.hs bar.hs; stat bar.hs
04:33:46 <MasseR> returns symlink
04:34:02 <infinity0> see man 2 stat
04:34:08 <infinity0> you need to give the syscall AT_SYMLINK_NOFOLLOW
04:34:09 <maerwald> stat does not dereference, unless you tell it to
04:34:15 <Aruro> IO Block: 1024 symbolic link
04:34:18 <infinity0> dunno if System.Posix lets you do that
04:34:39 <infinity0> or use lstat instead of stat
04:34:46 <merijn> infinity0: There is no such option in the stat man page
04:34:53 <infinity0> "man 2 stat" for the syscall not the program
04:35:05 <merijn> infinity0: I'm reading "man 2 stat"
04:35:08 <infinity0> or rather the libc function or whatever
04:35:14 <infinity0> in that case use lstat
04:35:17 <maerwald> Aruro: how did you obtain the FileStatus?
04:35:23 <merijn> infinity0: There is no FOLLOW in the man page for stat/lstat
04:35:27 <Aruro> short line to reproduce : getFileStatus "/proc/fav-pid/cwd" >>= (return . isSymbolicLink)
04:35:28 <maerwald> if you used getFileStatus, it's wrong
04:35:34 <infinity0> just use lstat if you don't see FOLLOW
04:35:42 <maerwald> you have to use getSymbolicLinkStatus
04:35:49 <Aruro> maerwald: i did, why wrong?
04:36:03 <maerwald> https://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-Files.html#v:getSymbolicLinkStatus
04:36:17 <maerwald> getFileStatus dereferences
04:36:39 <Aruro> maerwald: yes i saw that, but that function is about link itself no?
04:36:51 <maerwald> isSymbolicLink just operates on the FileStatus object
04:36:57 <maerwald> it doesn't dereference anything
04:36:58 <infinity0> posix c functions are not well designed, sometimes they do extra things. read the docs and don't assume behaviours like you're currently doing
04:37:38 <maerwald> so if you use isSymbolicLink with getFileStatus you always get false, except when the symlink is broken maybe (however that probably throws an exception then)
04:37:41 <Aruro> maerwald: isnt it a bug of getFileStatus function?
04:37:45 <maerwald> no
04:37:47 <merijn> Aruro: No
04:37:59 <maerwald> maybe the documentation is just not clear enough about the behavior
04:38:00 <Aruro> again why not? :)
04:38:10 <maerwald> Aruro: because you have getSymbolicLinkStatus
04:38:13 <maerwald> as already said
04:38:15 <merijn> Aruro: Because "getFileStatus" says it uses stat, i.e. it follows symlinks
04:38:33 <Aruro> maerwald: yes but then u have to query file twice for filestatus and symboliclink status
04:38:43 <Aruro> maerwald: seems a bit wierd to me.
04:38:45 <merijn> Aruro: So you are getting the FileStatus for the *destination* of the symlink
04:38:54 <maerwald> Aruro: because those are two different files
04:39:01 <Aruro> merijn: yep, thats true
04:39:01 <merijn> Aruro: And the destination of said symlink is not a symlink, therefore it returns "False"
04:39:09 <maerwald> destination is not the same as source, how do you want to get that with one syscall?
04:39:11 <maerwald> that's not possible
04:40:32 <Aruro> maerwald: ty all, problem seems clear
04:41:28 <maerwald> and /proc is not really a magic directory, the problem is just that files inside may change very quickly 
04:41:48 <merijn> maerwald: /proc has many magic things in it
04:42:02 <merijn> maerwald: Like being able to read a process' memory
04:42:20 <maerwald> yes, but those are all normal files and directories, nothing changes for interacting with them via posix functions
04:42:36 <Aruro> tnx for help, 
04:42:45 <Aruro> getSymbolicLinkStatus works well
04:52:34 <Profpatsch> How would you parse something with cassava that keeps additional fields in a separate hashMap?
04:54:01 <Profpatsch> The closest I am is http://lpaste.net/161941
04:54:25 <Profpatsch> But no idea how I would make it so that the already parsed fields are not in the hash map.
04:55:40 <hdmanga> !help
04:55:59 <hdmanga> !command
04:56:22 <Aruro> > (1+1)
04:56:24 <lambdabot>  2
04:56:26 <ski> !list
04:56:32 * ski looks at monochrom
04:56:40 <Aruro> > @help
04:56:42 <lambdabot>  <hint>:1:1: parse error on input ‘@’
04:56:53 <Aruro> @help
04:56:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:57:14 <hdmanga> thanks bro
04:57:25 <Aruro> uwc
05:01:38 <gfixler> how do I let a type argument change types in a recursive type?
05:01:53 <gfixler> I feel like I've done this, maybe with a language extension, or some forall thing
05:02:23 <hpc> what are you trying to write?
05:02:37 <gfixler> hpc: I'm playing with GADTs (learning)
05:02:56 <gfixler> hpc: so, e.g. eq :: Expr Int -> Expr Int -> Expr Bool
05:03:14 <gfixler> where eq is a smart constructor for the Eq constructor of the Expr data type
05:03:32 <gfixler> this may be a broken step in the slow transition from Expr to a full Expr a GADT
05:03:50 <hpc> how have you written Expr so far?
05:03:57 <hpc> (just the Int and Bool cases)
05:04:22 <gfixler> hpc: I Int and B Bool
05:04:32 <gfixler> Eq (Expr a) (Expr a)
05:04:55 <gfixler> I'm getting for my eq smart constructor: Expected type: Expr Int -> Expr Int -> Expr Bool
05:05:00 <Aruro> what is (not) for Ordering type? like (not . compare) = inverse compare
05:05:02 <gfixler> Actual type: Expr Int -> Expr Int -> Expr Int
05:05:04 <merijn> gfixler: Please paste your GADT declaration
05:05:16 <gfixler> merijn: there is no GADT declaration - not there yet
05:05:31 <merijn> The smart constructor is redundant when using a GADT
05:05:49 <merijn> You'd just write "data Expr a where Eq :: Expr a -> Expr a -> Expr Bool"
05:05:51 <gfixler> merijn: as I said, I'm doing the gradient thing, stepping from non-GADTs to GADTs
05:05:56 <gfixler> merijn: yes, I know that
05:06:09 <gfixler> merijn: there's a step in the transition that fails to typecheck
05:06:22 <merijn> Can you lpaste the entire thing?
05:06:29 <gfixler> https://en.wikibooks.org/wiki/Haskell/GADT
05:06:31 <gfixler> it's just that
05:06:46 <gfixler> I don't have a GADT yet - haven't gotten to that step
05:06:52 <gfixler> this is pre-GADT
05:07:17 <merijn> gfixler: You can't write the Eq correctly using the pre-GADT
05:07:28 <gfixler> merijn: that's what I was wondering
05:07:29 <merijn> Your smart constructor is impossible
05:07:37 <gfixler> merijn: my question was about having the a change types in the recursion
05:07:41 <gfixler> merijn: and if it was possibl
05:07:50 <merijn> You could only write "eq :: Expr a -> Expr a -> Expr a"
05:07:51 <gfixler> merijn: I feel like I've done it before
05:08:01 <merijn> gfixler: No, not possible without GADT
05:08:07 <gfixler> merijn: great, that answers my question
05:08:10 <merijn> At least in this case
05:08:25 <gfixler> merijn: was just wondering if a could change from Int to Bool
05:08:30 <gfixler> at the next level
05:09:02 <merijn> The problem is that all recursive cases of Expr contain just one type parameter 'a' and it's in both the children too
05:09:08 <gfixler> merijn: I feel like I've seen that happen while studying recursion types a bit
05:09:24 <gfixler> i.e. the type could be different in each recursion
05:09:27 <merijn> Well, I suppose you could do it using ExistentialQuantification
05:09:30 <gfixler> maybe I'm imagining things
05:10:25 <gfixler> something like the opposite of forall
05:12:10 <Profpatsch> Why does the time library use the julian calendar by default?!
05:12:51 <Profpatsch> Every article an Wikipedia states the Gregorian calendar has been the default for over 100 years.
05:15:04 <hpc> it's just a backend detail, and ideally you should only need to use ParseTime and FormatTime
05:15:22 <Profpatsch> hpc: Hm, okay.
05:16:17 <Profpatsch> So I can simply use Day if I want to specify that something is a date?
05:16:26 <hpc> yeah
05:16:54 <hpc> it might turn out to be easier to implement as julian because the calendar conversion makes more sense forward than backward, or something
05:17:11 <hpc> i don't expect they would make such a weird design choice for no reason
05:17:40 <hpc> similar logic applies to Text being packed utf16 data internally
05:18:06 <Profpatsch> Since it is the first thing you see in the documentation and it’s explicitely stated it sounds like it matters to a user.
05:18:24 <Profpatsch> The time docs are weird.
05:18:32 <hpc> yeah
05:19:08 <ggVGc> how would you guys write this? https://gist.github.com/f5ddc372d3817d279b1d3e5f85fd8d12
05:19:53 <ski> Profpatsch = ProfTeggy ?
05:23:09 <Profpatsch> ski: nöp
05:25:17 <merijn> ggVGc: <$> eliminates two pairs of parentheses
05:25:42 <merijn> ggVGc: i.e. "map (_1 %~ (fmap snd)) <$> getActiveNotes' m"
05:26:38 <ggVGc> thanks
05:26:41 <ggVGc> merijn: ^
05:26:48 <bergey> Profpatsch: I think "Julian Day" in this context just means that it's a counter of days that never rolls over.  I usually see Julian Day used to mean 1 Jan = 1 and 1 Feb = 32, up to 31 Dec.
05:30:40 <maerwald> anyone know how to match against an ObjectId in the mongoDB lib? Just 'select ["_id" =: "571e1a7885a15ede06ebfe1f"]' doesn't seem to do it
05:30:56 <ski> Profpatsch, ok
05:31:00 <maerwald> there seems to be an ObjectId constructor but it's not exported
05:31:33 <hexagoxel> ggVGc: isn't that like `mapped . mapped . _1 . mapped %~ snd $ getActiveNotes' m` ?
05:42:43 * hackagebot servant-csharp 0.0.8.1 - Generate servant client library for C#  https://hackage.haskell.org/package/servant-csharp-0.0.8.1 (KatsutoshiItoh)
05:52:26 <phz_> https://www.reddit.com/r/rust/comments/4gz7ir/porting_a_haskell_graphics_framework_to_rust/
05:52:29 <phz_> :)
05:54:24 <ntnt> what's a good name for a cross of "DataStructure" and "Tool" ? I wrote a bunch of pure data structures to augment Data.* and I'm not sure what to name it
06:06:16 <ggVGc> http://40.media.tumblr.com/2a409534fea53c54fb67ed507dabe5bf/tumblr_n8xb25HGuJ1taxo62o1_400.jpg
06:06:31 <Akii> wow
06:23:30 <jophish> Sounds like a job for https://hackage.haskell.org/package/logfloat-0.13.3.3/docs/Data-Number-PartialOrd.html
06:27:44 * hackagebot thread-local-storage 0.1.0.4 - Several options for thread-local-storage (TLS) in Haskell.  https://hackage.haskell.org/package/thread-local-storage-0.1.0.4 (RyanNewton)
07:15:12 <Mateon1> Is there a function that tries to read something, and if it fails it returns a Maybe? I'm currently failing to catch the parse error using IO and 'try', because the value is lazily deferred.
07:15:37 <bernalex> Mateon1: by "read", do you mean the function read?
07:15:42 <Mateon1> Yes
07:15:47 <bernalex> there are several
07:16:19 <bernalex> :t readMay
07:16:20 <lambdabot> Not in scope: ‘readMay’
07:16:32 <bernalex> Mateon1: the safe package has a "readMay" function, for instance.
07:16:54 <bernalex> :t readMaybe
07:16:55 <sphinxo> Mateon1: in Text.Read
07:16:55 <lambdabot> Not in scope: ‘readMaybe’
07:17:05 <sphinxo> https://hackage.haskell.org/package/base-4.8.2.0/docs/Text-Read.html#v:readMaybe
07:17:05 <bernalex> Mateon1: right readMaybe is the one put in Text.Read
07:17:06 <Mateon1> I'd love something from base, but that doesn't seem to exist.
07:17:13 <bernalex> there's also readEither.
07:17:16 <bernalex> Mateon1: Text.Read is in base.
07:17:47 <Mateon1> Ah, great
07:17:49 <Mateon1> Thanks
07:17:57 <Mateon1> Hoogle doesn't pick it up, apparently
07:19:34 <bernalex> ggVGc: what a failure. it should have referenced the prince song made famous by sinéad o'connor.
07:22:13 <Dive-to-Haskell> I am newbie haskell lover, but i have a problem in ide, could anyone say that what is the best ide pack (sort) is for windows??
07:22:46 * hackagebot opensource 0.1.0.0 - Haskell API Wrapper for the Open Source License API  https://hackage.haskell.org/package/opensource-0.1.0.0 (ClintAdams)
07:23:27 <Dive-to-Haskell> IDE FOR WINDOWS??
07:23:40 <Mateon1> No need for caps lock...
07:25:25 <hpc> there's something to be said for notepad's tab rendering matching up with the report
07:26:18 <ertes> :t foldr (const . Just . fst) Nothing . reads
07:26:20 <lambdabot> Read a => String -> Maybe a
07:27:10 <phadej> readMaybe
07:27:47 <phadej> :t readMaybe
07:27:48 <lambdabot> Not in scope: ‘readMaybe’
07:28:04 <phadej> in Text.Read iirc
07:29:06 <bernalex> Dive-to-Haskell: gvim was OK on windows the last time I had to do anything on windows.
07:31:17 <runeks> How do I catch errors in this monad?
07:31:18 <runeks> newtype ProtoS r s a = CProtoS { getProtoS :: S.StateT s (ExceptT ProtocolError (ReaderT r IO)) a }
07:32:59 <runeks> I know I can run the entire monad, provided a init_state object and a reader object, and get a final result or an error, but can't I do something like "monadicAction `catch` \customerror -> do something" inside the monad itself instead?
07:33:10 <runeks> Or is "catch" only for IO?
07:38:25 <Axman6> runeks: since ExceptT is an instance of MonadCatch, you should be able to implement MonadCatch for your type
07:39:58 <ertes> :t foldr(\(x,_)_->x)empty.reads
07:39:59 <lambdabot> (Read (f a), Alternative f) => String -> f a
07:40:03 <c_wraith> be sure you understand the interaction between StateT and catch, though. 
07:40:46 <TheMystic> ertes: what's going on in those lambda args?
07:40:51 <TheMystic> that's syntax I haven't seen before
07:41:03 <TheMystic> \(x,_)_ -> ...
07:41:05 <ertes> TheMystic: just pattern-matching a tuple
07:41:10 <ertes> and a second argument
07:41:31 <ertes> it's friday…  i'm trying to come up with something shorter than "import Text.Read;readMaybe" =)
07:41:34 <TheMystic> oh, and you get to elide the whitespace in between because of the close-paren?
07:41:40 <ertes> yeah
07:42:02 <TheMystic> you broke my mental parser ;)
07:42:13 <ertes> my pleasure =)
07:42:45 <benma> hi
07:42:47 * hackagebot darcs 2.12.0 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.12.0 (GuillaumeHoffmann)
07:42:49 * hackagebot table-layout 0.3.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.3.0.0 (muesli4)
07:43:11 <benma> how would i generate a random bytestring of length N with mwc-random?
07:43:12 <benma> https://hackage.haskell.org/package/mwc-random-0.13.4.0/docs/System-Random-MWC.html
07:44:17 <runeks> Axman6: OK. I will try that.
07:44:29 <runeks> c_wraith: what's that interaction again?
07:45:33 <ertes> benma: you can generate a random storable vector of Word8 and then convert that to ByteString…  you have to somehow go through a Ptr/ForeignPtr though, and it's going to be unsafe
07:45:44 <c_wraith> runeks, any changes made to the state inside the tried action will be lost if an exception is thrown. (when StateT is outside the exception handling monad) 
07:46:02 <benma> ertes: :O
07:46:16 <ertes> benma: a safer option is generate the random vector and *copy* it to a bytestring
07:46:18 <benma> ertes: thanks, but ow this should be easier
07:46:57 <benma> ertes: what about something like replicateM to generate [Word8], and useing bytestring's pack?
07:47:23 <benma> probably slower..
07:47:31 <c_wraith> benma, that works nicely unless the strings are huge. 
07:47:43 <ertes> benma: well, ByteString and storable Vector Word8 are pretty much the same thing, but they are surprisingly difficult to get to work together
07:47:50 <runeks> c_wraith: Good to know.
07:47:56 <ertes> benma: you should still generate the vector and then go through list
07:48:07 <benma> does the bytestring package have some helper's to create the string from a vector?
07:48:37 <ertes> it has unsafe functionality to generate a bytestring from a Ptr, but it does not know what a vector is
07:49:44 <benma> http://stackoverflow.com/questions/22508826/converting-vector-to-bytestring-in-haskell
07:49:53 <benma> seems overly complicated.. i think this should be streamlined a little bit
07:50:09 <benma> i think i'll open an issue on mwc-random. random bytestrings must be common enough to warrant that, right?
07:51:45 <ertes> benma: the problem is that we don't vector to depend on bytestring and vice versa
07:51:48 <benma> or does anyone know a package that converts vectors to bytestrings?
07:52:07 <benma> ertes: i just thought that, which is why i assume there is a third package that depends on both ;)
07:52:16 <benma> https://hackage.haskell.org/package/spool
07:52:18 <benma> maybe
07:52:21 <ertes> benma: the only case when i generated random bytestrings was to gather entropy for a CSPRNG
07:52:45 <ertes> and that's already handled well by packages that do that directly
07:52:47 * hackagebot PerfectHash 0.1.5 - A perfect hashing library for mapping bytestrings to values.  https://hackage.haskell.org/package/PerfectHash-0.1.5 (MarkWotton)
07:53:20 <benma> i need it to generate entropy for the seed in ed25519: https://hackage.haskell.org/package/ed25519-0.0.5.0/docs/Crypto-Sign-Ed25519.html
07:53:48 <ertes> benma: and you were going to use mwc-random?
07:54:06 <ertes> please do not implement crypto yourself…  you would have made it horribly insecure!
07:54:08 <benma> yeah. i am aware it is a pseudo random number generator
07:54:23 <benma> thanks
07:57:17 <ertes> why aren't you just using createKeypair?  it handles the generation properly
07:58:03 <ertes> alternatively use the 'entropy' package for example
07:59:36 <benma> ertes: i am doing just that. i was thinking that a seeded mwc could be faster than repeatedly opening /dev/urandom 
08:00:10 <c_wraith> mwc is incredibly insecure. 
08:00:17 <benma> i know
08:00:36 <c_wraith> I'm not sure you do. 
08:00:38 <ertes> 99% of the time in crypto when people thought, "oh, we can make it faster this way", they introduced a ridiculously easy to exploit security hole
08:00:49 <benma> c_wraith: rest assured, this will not go into production anywhere
08:01:05 <Jinxit> benma: open source?
08:01:19 <c_wraith> the code shouldn't exist anywhere, production or not. 
08:01:20 <ertes> benma: the creator of PHP thought the same ;)
08:01:22 <benma> i am just toying around with haskell and trying to bruteforce a vanity publickey. harmless
08:01:35 <ertes> now PHP is practically a global crisis
08:01:40 <benma> i agree lol
08:01:43 <c_wraith> because code that exists tends to be used. 
08:01:53 <benma> i also work with crypto everyday and have a good grasp on what i can't invent myself
08:02:11 <Axman6> I believe the cryptonite package gives actual cryptographicly secure randome number methods
08:02:22 <c_wraith> and if this is just a toy, /dev/urandom is plenty fast enough. 
08:02:28 <benma> well, i assume /dev/urandom does too
08:02:37 <benma> it is a toy that needs maximum speed, as it bruteforces stuff
08:02:54 <benma> even thinking of moving it to opencl haha
08:02:54 <simpson> If you're brute-forcing, you don't need an entropy source.
08:03:01 <Axman6> [0..] is a pretty damn fast stream of random numbers
08:03:21 <benma> i know, but running the thing twice should not result in the same result..
08:03:42 <simpson> benma: If you're brute-forcing, don't you always want the same result for the same inputs?
08:03:49 <Axman6> keep track of the n you're up to =)
08:04:37 <benma> simpson: no. bruteforce might be a bad word, all it does is randomly try secrets until the publickey matches a pattern
08:04:45 <benma> others should not be able to run the same thing and get my secret
08:05:09 <benma> was just brainstorming to get more speed
08:05:11 <ertes> benma: my fear is that some script kiddie will accidentally hit the one short time frame your system has an unpatched security hole, and they manage to steal that particular code from you just before you throw them out…  then they read your code and think: "oh, this is neat! i'm gonna use that"…  two years later we're having benma-ed25519 all over the internet
08:05:45 <simpson> ertes: Don't worry about it; we can just say "use libsodium" over and over and eventually people will either get salty or use libsodium.
08:06:03 <simpson> benma: Speaking of which, have you considered using libsodium?
08:06:16 <benma> no worries, my code that is unsafe or slow has disclaimers, see for example: https://github.com/benma/ed25519-rings/blob/master/src/Ed25519.hs
08:07:53 <benma> (this is a separate package btw, the thing i am toying with now is not going on GH)
08:09:41 <benma> also ertes, no script kiddie will steal it as it is not going to production :)
08:10:32 <ertes> benma: it exists on a computer on this planet…  i don't know why, but bad software tends to spread like a virus for some reason =)
08:10:50 <benma> i have a different experience. most code rots :P
08:11:55 <ertes> wanna spread your malware?  don't write infection/obfuscation code…  instead put it in plain sight and make sure the implementation is crappy as hell
08:12:08 <ertes> people love that
08:12:50 <benma> by the way, if i use a random seed with good entropy, mwc-random is like /dev/urandom (but different algos for the PRNG)
08:13:18 <benma> then it depends on whether the algorithm has a weakness
08:14:15 <benma> can't find any info on whether mwc-random's MWC8222 has any issues
08:14:21 <benma> but therre might be some
08:14:56 <ertes> benma: no, it's not
08:15:33 <ertes> mwc-random is insecure, regardless of your seed…  do not trust your own security assumptions, unless you can prove them
08:17:08 <simpson> benma: It is deterministic and reveals a small amount of state with each generation. This is sufficient to be insecure against certain kinds of attacks.
08:22:25 <benma> ok, thanks
08:26:30 <anax> The code here http://lpaste.net/161954 produces a warning which doesn't seem reasonable
08:27:34 <anax> Ghc version 7.10.3
08:27:48 <merijn> anax: The exhaustiveness checker isn't smart enough to see that either "b" or "not b" must be true
08:28:08 <merijn> anax: If you replace the "not b" case with "otherwise" it should work
08:29:05 <anax> Ok, thanks. I thought of that but I wanted to use the typechecker for finding omission in pattern matches.
08:29:28 <merijn> The exhaustiveness checker is fairly naive, if there's non-trivial boolean logic it will always claim it's non-exhaustive unless there's a catch all case
08:29:51 <ertes> anax: it can handle pattern-matches exhaustively though
08:30:15 <ertes> that is unguarded pattern-matches
08:30:49 <anax> ertes: Usually yes. That's why I was surprised by the warning.
08:31:18 <hpc> but what if b = FILE_NOT_FOUND?
08:31:18 <anax> merijn: How come b or not b is not trivial? Is the membership guard that confuses?
08:31:43 <ertes> anax: the exhaustiveness checker can only deal with constants
08:31:49 <hpc> anax: it's non-trivial because the exhaustiveness checker doesn't really care at all about boolean logic
08:31:50 <ertes> 'otherwise' is a constant (True)
08:32:24 <anax> Alright. Thank you for the clarification
08:33:41 <Profpatsch> What do you use when you need to represent a datatype in a certain way (that is not debug-printing)?
08:34:04 <hpc> a certain way?
08:34:18 <Profpatsch> e.g. I’ve got a (kind of big) product type where each field should have a name in a grid.
08:34:35 <Profpatsch> And it’s a Vector of those which represent the entries.
08:34:44 <hpc> so pretty printing
08:34:53 <Profpatsch> Hm, yes, in a way
08:35:03 <merijn> There's a bunch of pretty-printing libraries
08:35:15 <merijn> Including some for grid/column output
08:35:32 <Profpatsch> In that case it’s a little easier, since I just need to add a String to a field.
08:35:42 <Profpatsch> (the grid is a wxwidgets grid)
08:36:05 <merijn> https://hackage.haskell.org/package/boxes-0.1.4/docs/Text-PrettyPrint-Boxes.html ?
08:36:21 <Profpatsch> But should I maybe do a map of function<->string or implement some kind of type class?
08:37:18 <Profpatsch> So I’ve got data Entry = Entry { a, b, c …, z }
08:37:42 <Profpatsch> And maybe a should have the grid label "My a"
08:38:08 <fr33domlover> Profpatsch, it will be easier to understand if you paste some code
08:38:11 <fr33domlover> @where paste
08:38:11 <lambdabot> Haskell pastebin: http://lpaste.net/
08:38:29 <Profpatsch> fr33domlover: There is no code
08:38:45 <Profpatsch> Just a big datatype and a (not yet existing) GUI grid widget.
08:38:48 <fr33domlover> Profpatsch, I mean your type definitions or at least examples
08:39:01 <Profpatsch> One example is five lines up.
08:39:08 <Profpatsch> There really isn’t more to it.
08:39:12 <ertes> Profpatsch: what's the problem?  getting a list of strings from the fields?
08:39:46 <ertes> Profpatsch: where all fields are of the same type?
08:40:00 <Profpatsch> No, there are different types.
08:40:26 <ertes> Profpatsch: and you want to save the boilerplate to "show" each value?
08:40:44 <Profpatsch> The values are taken care of.
08:41:25 <Profpatsch> I just wonder how I can combine the accessor fields with some descriptive string.
08:41:26 <hpc> how about just writing it and see what pattern it fits after?
08:41:52 <hpc> using whatever the wxwidgets api is
08:42:04 <ertes> Profpatsch: since your problem description is very vague, i can only tell you what i have done in a case that sounds like this one
08:42:41 <ertes> data X f = X { x1 :: f Int, x2 :: f Double, x3 :: f String, … }
08:42:47 <Profpatsch> Well, there’s a big type like the one I wrote above and there’s a grid where each column needs a label.
08:42:54 <Profpatsch> Yes, like that.
08:43:12 <ertes> now f can be anything from Identity to (,) String
08:43:15 <stevejb> greetings, I am using ghci (via stack) on windows. I am getting a <interactive>:2:1: Not in scope: `prompt' error whenever I press Enter
08:43:21 <ertes> or even Constant String
08:43:27 <Profpatsch> ertes: Oh, that’s very nice.
08:43:38 <Profpatsch> Maybe I’ll use that.
08:43:43 <Profpatsch> Thanks!
08:46:00 <ertes> Profpatsch: if there is a natural way to go from one f to another, you can map:  mapX :: (forall a. f a -> g a) -> X f -> X g
08:46:13 <ertes> otherwise you need more ad-hoc functions
08:52:49 * hackagebot lens-datetime 0.3 - Lenses for Data.Time.* types  https://hackage.haskell.org/package/lens-datetime-0.3 (MihalyBarasz)
09:02:48 <Profpatsch> A related problem is: How do I say “show every field of a large product type“?
09:05:50 <EvanR> a related problem is how to show those fields in a way that doesnt suck
09:07:05 <EvanR> i tried GenericPretty and it kind of works
09:07:27 <EvanR> i just noticed a 1-version package generic-pretty havent tried it
09:07:34 <Profpatsch> We have the semantics, but we cannot share it with the world. :P
09:07:47 <Profpatsch> syb?
09:08:07 <EvanR> syb is still a thing?
09:08:27 <Profpatsch> no idea.
09:08:31 <EvanR> https://github.com/tanakh/generic-pretty
09:08:36 <EvanR> nice graphics
09:08:45 <EvanR> somehow... there are colors
09:09:01 <Profpatsch> But that’s more of a debugging library
09:09:15 <EvanR> oh, what are you talking about
09:10:13 <Profpatsch> I’ll probably have to write a very specific function for each field. :)
09:18:03 <EvanR> dude
09:18:06 <EvanR> http://i.imgur.com/RaX9yZ2.png
09:18:10 <EvanR> generic-pretty
09:25:40 <rembo10> Hey - sorry I asked this earlier but I had a spotty connection. How easy is it to distribute a haskell application to run on different platforms (linux, osx, windows, freebsd mainly)?
09:26:26 <simpson> rembo10: Well, it's middle-of-the-road. Keep in mind that Windows is *always* a tough platform to target.
09:26:41 <hpc> it's as easy as C
09:27:26 <hpc> unless you can assume each user has ghc or something
09:27:48 <EvanR> specifically you can write the necessary C code to work on the various desktops and link ;)
09:27:59 <EvanR> (except C is not sufficient on osx)
09:28:50 <rembo10> No - I'm trying to publish binaries
09:29:18 <hpc> linux and freebsd can be the same build, most of the time
09:29:45 <EvanR> i had to write a separate GUI front end in objective C to do cocoa and communicate to it with haskell, good for modularity bad for "easy"
09:30:05 <hpc> osx can be the same build as well, but much more rarely
09:30:11 <hpc> gui being a notable deal-breaker
09:30:20 <hpc> windows has to be its own build because it doesn't use ELF
09:31:09 <rembo10> I'm trying to write a daemon-type application, so won't need a gui
09:32:33 <EvanR> oh then it should be pretty easy
09:32:50 * hackagebot xcffib 0.4.2 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.4.2 (TychoAndersen)
09:32:50 <rembo10> I guess it would just be a matter of building it on the different platforms?
09:32:58 <pkug> Hi there, I'm trying to understand this function and it gives me a serious headache, I reckon it should be really simple for Haskellers.. I guess my brain has a faulty grasp of recursion and it needs some basic steps (instructions) how to think and what to look for when encountering code like this: combinations n (x:xs) = (map (x:) (combinations (n-1) xs)) ++ (combinations n xs)
09:33:05 <EvanR> rembo10: sure
09:33:22 <rembo10> Is there anything like travis that will produce builds for me?
09:33:27 <hpc> rembo10: and using path variables instead of /home/$user and whatnot
09:33:38 <rembo10> Sorry I've tried googling all this stuff but couldn't really get any concrete answers
09:33:43 <rembo10> right
09:33:47 <Xandaros> lens question: I have two traversals Traversal' A B - can I combine them somehow to get another Traversal' A B?
09:34:06 <hpc> rembo10: i don't know if ghc can cross-compile at all
09:34:12 <hpc> you might just need a VM or something
09:34:24 <EvanR> supposedly it can but i only heard about such a thing for phones
09:35:01 <hpc> that was also Cale (iirc) who was doing it, so that only proves it's possible for wizards ;)
09:35:30 <rembo10> I was hoping there was a service or something that could watch the github repo and build tagged versions for different oses
09:36:02 <simpson> rembo10: I imagine that somebody could make a pretty penny with that sort of service!
09:36:41 <rembo10> Does it really not exist?
09:37:05 <hpc> simpson: it'd have to be cheaper than just owning licenses for all the OSs
09:37:18 <hpc> which... isn't that hard if you aren't supporting apple products at all
09:37:32 <EvanR> rembo10: it seems travis does have haskell support
09:37:37 <simpson> rembo10: 
09:37:56 <simpson> Er. rembo10, producing OSX and Windows binaries is sufficiently tricky that I don't expect anybody to do it for free.
09:39:18 <rembo10> Hm
09:39:20 <rembo10> Ok
09:39:52 <EvanR> i mean, haskell stuff on github do have these little CI tags
09:39:57 <EvanR> so check it out
09:40:06 <rembo10> I'm just trying to figure out if it makes sense for me to write my application in haskell, because being able to ship executables is important
09:40:46 <EvanR> ghc statically links stuff as a matter of course, so it seems quite plausible
09:42:44 <simpson> rembo10: Well, like I said earlier, Windows is unpleasant regardless of implementation language. Pick your language based on whether you enjoy developing in it.
09:42:52 <bergey> https://silky.github.io/posts/2016-01-05-build-windows-haskell-app-with-stack-and-appveyor.html
09:44:00 <EvanR> AppVeyor... interesting
09:44:05 <rembo10> Well I really like haskell so far which is why I'm here :-)
09:44:54 <EvanR> cocoa / windows / whatever on linux GUI seems like an interesting problem to solve, but im sure if i started trying to solve it i would quickly become frustratd
09:45:08 <EvanR> i mean, making such a thing nice in haskell to program
09:47:00 <Xandaros> ...guess nobody here is a lens wizard, then? :(
09:47:14 <peddie> Xandaros: #haskell-lens
09:47:51 <Xandaros> Ah, I'll try there, thanks :D
09:49:35 <EvanR> while researching prisms last night in a delirium i accidentally thought i was a wizard and started answering random disqus questions about them
09:50:13 <bergmark> uh-oh
09:52:02 <dolio> Xandaros: What would the combined traversal do?
09:53:58 <Xandaros> dolio: Well, as I understand it, a traversal is similar to a lens, but it can 'target' any number of elements, not just one. So this combination would 'target' what both of them combined 'target'
09:54:41 <dolio> What if they overlap?
09:55:30 <Xandaros> Yeah, that's a very good question. In my case, I'd prefer them to get merged, but I see that that is a problem
09:56:22 <puregreen> Xandaros: note that if you're only using them as folds, you can merge them with <>
09:57:30 <sm> rembo10: it's quite doable, stack is helpful
09:57:58 <Xandaros> puregreen: Thank you! :) I should've guessed that one...
09:58:17 <fr33domlover> I'm using the 'hit' package to read some git data from a repo, and after reading many objects I get a "resource exhausted" error, looks like I used all the file descriptors. Is there a way to prevent that (except for closing the repo context, but even then, how I do tell when I should do that? and it's an ugly hack)?
09:58:18 <Xandaros> I guess that means I can also use mconcat - even better
09:58:31 <sm> bergey: nice, thanks for the link
10:10:35 <lpaste> muesli4 pasted “Is this ugly style? What are the drawbacks?” at http://lpaste.net/161959
10:12:17 <EvanR> muesli4: yes i dont like this style
10:12:41 <muesli4> EvanR: what's wrong with it?
10:12:57 <fr33domlover> johnw, ping. I'm using 'hit' and after many getObject I seem to use too many file descriptors. Did you notice this issue when writing the 'hit' backend for gitlib? Is there a way to avoid it? I assume your conduit-aware gitlib does, but the issue is probably in 'hit' :-/
10:13:01 <EvanR> there is sure a lot of code for not much going on
10:13:41 <EvanR> you end up having to disambiguate the types
10:13:49 <EvanR> whats the benefit?
10:15:07 <muesli4> EvanR: Let's say I have functions that work on Position, so I can use that code for all of those types and users can easily specify it.
10:15:52 <EvanR> seems to me its easy with the line data Position = Start | Center | End too?
10:16:53 <EvanR> basically its a page and a half of code to avoid putting one accessor on a record that contains a Position
10:16:56 <muesli4> EvanR: sure but it's not directly clear from where I start, is Start left or right (top or bottom).
10:18:29 <EvanR> i think you can make a positioning language pretty easily without type classes
10:18:33 <muesli4> EvanR: and if a user defines something like 'left = Start' should he be able to use it on functions that work on 'top' and 'bottom'?
10:19:05 <EvanR> i did this for the geometric glyph dsl i was working on
10:19:18 <muesli4> EvanR: I would love to see it.
10:21:30 <muesli4> EvanR: I guess you could add a type to the Position type constructor and use tags, then the types can not be mixed.
10:21:40 <EvanR> prepare to be amazed
10:21:46 <muesli4> :)
10:21:46 <EvanR> http://lpaste.net/161960
10:22:57 <EvanR> the positions are doubles and are normalized to the frame, which is configured at the end of the process, not shown
10:23:43 <EvanR> i wanted to use equilateral triangle solver to declaratively choose positions without explicitly doing trig... but that ended up being really tough somehow
10:23:52 <muesli4> EvanR: That may be useful in your case, but mines have to be discrete values. And still you could use top where one would expect a right, not too much amazed. :)
10:24:06 <EvanR> i know
10:24:24 <EvanR> but the language looks like (top, left) so...
10:24:37 <EvanR> (left, left) wouldnt make much sense linguistically
10:26:44 <EvanR> im always looking for ways to make haskell less "useless" where useless is caused by overbearing advanced types, especially if its causes 100x increase in code size
10:28:53 <lpaste> muesli4 pasted “* -> *” at http://lpaste.net/6708876114787303424
10:30:11 <EvanR> muesli4: nice
10:30:34 <muesli4> EvanR: at least it's a lot shorter than the last one
10:31:05 <Stratege> EvanR: well you could always just define some type Dyn and only work with that :3
10:31:06 <EvanR> we control the phantom horizontal, and the phantom vertical
10:31:37 <EvanR> Stratege: yeah i did this yesterday... https://github.com/haskellcats/actor-model/blob/master/Actor.hs
10:32:04 <EvanR> IsString, Num, has null, and futurable ;)
10:32:19 <EvanR> better than php id say!
10:32:31 <Stratege> that looks adorably disgusting.
10:33:07 <Stratege> you need more type punning
10:33:17 <simpson> muesli4: I'm reminded of http://hackage.haskell.org/package/linear
10:33:49 <Stratege> and other stuff ... like why is + not defined for String + Int or Int + String or String + String ;)
10:34:48 <EvanR> i wont acknowledge that with a response
10:35:09 <EvanR> however i did forget a string concat operator
10:35:21 <Stratege> just use +, it's what the cool languages do.
10:35:51 <EvanR> i will make a partial Monoid! ;)
10:36:02 <simpson> Well, the cool languages are `doin' all kinds of fun things with $quotes and @antiquotes`.
10:36:33 <Stratege> (I'm going by the assumption that this is some side of joke, if it isn't please excuse my comments and please do explain what it actually is)
10:36:48 <Stratege> *kind, not side.
10:37:13 <EvanR> its not terribly serious
10:38:02 <EvanR> but also well-typing the actors seems to be beyond my ability, and penchant for making stuff actually work without much code
10:39:01 <Stratege> well... one suggestion I'd have is to add DErr String. That way you are atleast not throwing haskell exceptions ^^
10:39:38 <EvanR> that would cause execution to continue
10:40:32 <Stratege> that's the idea, yes. Then you can have some more graceful recovering/error reporting in the interpreter
10:40:58 <EvanR> how?
10:41:13 <EvanR> oh, by modifying how the Monad works
10:41:36 <Stratege> mhm
10:41:58 <EvanR> well, i can imagine modifying the executor to check for DErr every time and then throw an IO exception ;)
10:42:08 <Stratege> xD
10:42:33 <EvanR> but it would only be able to do that between actions
10:42:45 <EvanR> a pure computation would continue on doing operations on errors for no reason
10:43:01 <EvanR> embrace dynamic typing by failing as soon as possible
10:43:12 <EvanR> so you know the pain directly
10:43:31 <Stratege> suppose, yeah.
10:43:57 <EvanR> the other end of the extreme is to never fail and system calls that see a DErr are noops ;)
10:44:00 <simpson> You could just erase more information by wizening up your compiler.
10:44:08 <Stratege> tbh I don't think it's possible to well type actors, especially if you want to go the full way of self-modifying code.
10:44:32 <simpson> Stratege: It is certainly possible, but you probably would not be satisfied with the resulting type system.
10:44:35 <EvanR> i have another self modifying project with the same issue
10:44:44 <EvanR> and i do think there is a type sytem for it
10:44:47 <EvanR> not simple though
10:45:09 <EvanR> you can put the next states type in the type, and so on ad infinitum
10:45:30 <EvanR> might as well not have the program and just write the types ;)
10:45:42 <Stratege> EvanR: the second version (system calls are noops) would mean that you can not trigger partiality while there are no bugs in the interpreter, and depending on how you define it - the code, just fun features and adherance to the spec! :D
10:45:50 <simpson> There's a bit of fun type covariance that you have to conquer in the presence of transparent forwarders; if you have e.g. a promise, you might know that it's of some type Promise, but knowing that it specifically will promise e.g. an Int (Promise[Int]) requires some mind-reading that is often impossible.
10:46:55 <Stratege> simpson: I'd kinda like to see a type system that can deal with self-modifying code in a way that doesn't limit the power too much.
10:47:54 <simpson> Stratege: It would be interesting! Over in our corner of the universe, we shrugged and agreed to do gradual typing instead.
10:48:45 <Stratege> heh ... funny when "gradual typing" sounds like the boring solution ^^
10:48:48 <EvanR> gradual?
10:48:52 <johnw> fr33domlover: hi, I didn't write the Hit backend, so it sounds like a bug
10:48:55 <EvanR> how is this different from dynamic
10:49:15 <simpson> EvanR: It isn't. "Dynamic typing" isn't a curse where I come from, so it wasn't a big deal.
10:49:31 <EvanR> just checking
10:49:45 <Stratege> I thought gradual typing was mixing static + dynamic in fun and interesting ways? ^^
10:49:52 <Stratege> e.g. what typescript allows.
10:50:18 <EvanR> as long as it isnt characterized as "just in time static checking"
10:50:21 <simpson> Stratege: There's several different flavors. We're using the same stuff as E, where we have guards (themselves also values) which lay out a set-theoretic type system.
10:50:41 <fr33domlover> johnw, definitely a bug :P i'm exhauted, been working on git stuff for weeks and in the end what I get after all the hacks is... resource exhausted :P
10:51:04 <johnw> fr33domlover: I have another version of gitlib based on pipes, btw, which will become v4 when I find some free time
10:51:05 <simpson> But it's always possible to construct a value which belongs to no existing set of values, so it's always possible to make a value that has no apparent type.
10:51:17 <Stratege> simpson: that sounds kind of interesting.
10:51:21 <ntnt> what's the fastest [Double] -> [Text] ?
10:51:30 <EvanR> "interesting"
10:51:52 <EvanR> map show
10:52:05 <EvanR> er.. text..
10:52:19 <puregreen> ntnt: http://hackage.haskell.org/package/double-conversion
10:52:53 <simpson> Stratege: Further reading: http://monte.readthedocs.io/en/latest/custom-guards.html
10:53:04 <ntnt> puregreen: nice, thanks!
10:55:40 <simpson> Stratege: Huh, looks like some of this information got split. http://monte.readthedocs.io/en/latest/guards.html has more, and honestly a read from the top will give you the necessary background much faster.
10:56:32 <Stratege> simpson: thank you
10:57:04 <simpson> Stratege: Sure. #monte if you wanna discuss further; this is off-topic.
10:57:37 <Stratege> EvanR: well yeah :D other approaches generally are interesting. Except if it's a JS thing. Then the sanity damage is generally not worth it.
10:57:49 <EvanR> simpson: is this language usable?
10:58:04 <EvanR> is it interpreted or compiled?
10:58:52 <simpson> EvanR: Usable if you are brave, compiler to bytecode and there's a couple different bytecode interpreters, #monte for more details.
11:02:22 <EvanR> unable to do anything without a proper reference is pretty sweet
11:02:53 * hackagebot aeson 0.11.2.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-0.11.2.0 (AdamBergmark)
11:16:13 <orion> Is there a way to show/format a Double such that it prints 0.00000000001 instead of 1.0e-11 ?
11:16:55 <hpc> try printf
11:17:55 <jle`> > printf "%f" 1e-11 :: String
11:17:57 <lambdabot>  "0.00000000001"
11:18:16 <glguy> Prelude> Numeric.showFFloat Nothing 1.0e-11 ""
11:18:17 <glguy> "0.00000000001"
11:18:20 <mauke> > showFFloat Nothing 1e-11 ""
11:18:21 <lambdabot>  "0.00000000001"
11:18:38 <orion> > printf "%F" 1e-11 :: String
11:18:39 <lambdabot>  "0.00000000001"
11:18:45 <mauke> that printf is technically broken
11:19:04 <mauke> as in, not compatible with C printf
11:19:44 <hpc> is there a spec for printf anywhere or is it just whatever the language decides it is?
11:21:37 <mauke> there's the C spec :-)
11:21:46 <mauke> which I think is the original
11:22:19 <hpc> so it's basically the PCRE of pretty-printing
11:54:57 <wicked_angel> hello
11:55:15 <wicked_angel> any help for haskell-gsoc?
12:06:32 <hpc> @where ask
12:06:32 <lambdabot> Don't ask to ask, just ask.
12:06:35 <hpc> william-s: ^
12:10:34 <ski> @where tell
12:10:34 <lambdabot>  @help tell
12:22:55 * hackagebot versions 2.0.0 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-2.0.0 (fosskers)
12:27:56 * hackagebot table-layout 0.4.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.4.0.0 (muesli4)
12:37:56 * hackagebot extra 1.4.5 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.5 (NeilMitchell)
12:47:19 <quchen> I've got this parser built with megaparsec that I'd like to split up into parser and lexer to get better error messages. It got me thinking that I should consider other new (for me) parser libs, such as Trifecta, which has a reputation of having nice errors as well.
12:48:06 <quchen> The Megaparsec approach is guaranteed to work, but it'll net me "unexpected Foo" instead of "unexpected F". From a user's perspective, that's a relatively small (albeit useful) gain.
12:48:38 <quchen> On the other hand, having a visual pointer to the parse error sounds *very* promising from a user experience point of view.
12:50:09 <quchen> Long story short: is it a good idea to try Trifecta? Are there example projects (merijn had one, no?) and example error messages somewhere?
12:54:49 <suppi> quchen, you can't get visual pointer to the parse error with megaparsec?
12:56:14 <quchen> suppi: I could write it myself, sure.
12:56:39 <suppi> quchen, I don't know why i thought megaparsec had that functionality :O
12:56:57 <quchen> Well, it gives you the location of the parse error
12:57:45 <suppi> yeah.. :
12:57:46 <suppi> :\
12:58:04 <suppi> quchen, there a parsing combinators tutorial with trifecta in haskellbook
12:58:24 <suppi> i've seen the error if that what you are curious about ;)
12:58:30 <suppi> arrow*
12:59:33 <suppi> there's an example here: https://github.com/ekmett/trifecta/tree/master/examples
12:59:40 <suppi> i haven't seen much else...
13:01:06 <johnw> quchen: I really like trifecta/parsers
13:01:46 <quchen> johnw: Ah, that's what I like to hear. What does it offer over the usual Parsec family?
13:01:54 <johnw> better error messages :)
13:02:00 <quchen> That's a good start. :-)
13:02:03 <johnw> it *feels* nearly identical to attoparsec
13:02:23 <johnw> also, if you use the "parsers" library, then the parsers you build can work with either parsec or trifecta
13:03:10 <quchen> johnw: I'm writing a parser for the STG language, and it's crucial from a user's point of view to have useful error messages when parsing, or even writing a program when you're not used to it is a terrible experience.
13:04:01 <quchen> I've got a somewhat well-working parser, but the error messages could be improved (all I've done so far is <?> stuff, but "unexpected 'l'" is not as useful as "unexpected keyword 'let'")
13:04:04 <suppi> quchen, I don't like the way parsec works with try and <|> and stuff
13:04:35 <suppi> you often have to left factor to get decent error messages
13:05:36 <quchen> johnw: I'd like to split the current parser into a) a lexer to rid myself of space handling b) the parser with full word/token errors instead of the first mismatch, and
13:05:57 <quchen> The usual approach of having parser and lexer in one that's very simple to get started with doesn't offer me that
13:06:41 <sm> megaparsec has much better docs than the others, I think
13:07:09 <sm> there's at least one how-to on lexing with it
13:07:48 <suppi> sm totally agree.
13:08:08 <quchen> sm: I'm using Megaparsec right now. I'm happy with it, I'm just wondering whether there's something that makes me happier. And Trifecta has been on my "people seem to like it so I should try it" list for quite some time.
13:08:32 <quchen> But I'm not in the mood for purely tinkering around, I'd like to also solve my problem. So "just trying it" is out.
13:08:39 <quchen> … and that's why I'm asking here. :-)
13:09:49 <cocreature> I was quite happy with trifecta so far, but I haven’t used it for anything really big
13:10:25 <quchen> cocreature: Well, my current parser is 200 sloc, so size isn't an issue
13:10:32 <cocreature> information on trifecta is sadly a bit sparse
13:10:40 <quchen> Yeah that's my main problem :-|
13:10:45 <quchen> cocreature: Got some example code? Some example errors?
13:10:49 <cocreature> I ended up looking at the idris source
13:10:53 <sm> if you're trying to get things done, that makes it a waste of time
13:10:59 <sm> IMHO
13:11:40 <cocreature> sm: not if good error messages are a requirement
13:11:56 <cocreature> quchen: sry nothing public. merijn has https://github.com/merijn/lambda-except which uses trifecta
13:12:27 <quchen> My requirements are excellent error messages and easy to read parser source code. Performance is not an issue.
13:13:05 <quchen> Ah, I found merijn's parser, https://github.com/merijn/lambda-except/blob/master/Parser.hs
13:13:31 <quchen> cocreature: Hah, was a bit late it seems :-)
13:14:59 <cocreature> quchen: if you just need basic parsers (i.e. not the automatic operator precedence stuff) it’s pretty straightforward. the operator stuff is also not that hard but it’s just different enough from the way parsec handles this to be confusing
13:15:18 <puregreen> I've released a package that has broken others' packages. Who is the person responsible for adjusting upper bounds on Hackage retroactively? I'd really appreciate it if they could help me with mitigating this.
13:15:31 <quchen> cocreature: It's the 1992 STG language. No infix operators, context-free, and all the nice things. :-)
13:16:02 <cocreature> quchen: in that case, just pretend you’re using parsec while writing your parsers and get good error messages for free :)
13:16:21 <quchen> cocreature: How about the lexer/parser split?
13:16:35 <quchen> Is it even necessary with Trifecta, or does it do Kmettian magic?
13:17:25 <cocreature> not sure, I haven’t split it. everything should be polymorphic enough to be able to operate on token streams instead of charstreams
13:18:03 <quchen> Sounds good enough to give it a shot then!
13:19:42 <sm> quchen: yay, please report back :)
13:20:56 <cocreature> quchen: thinking about it again, I have actually sort of separated it using https://hackage.haskell.org/package/parsers-0.12.3/docs/Text-Parser-Token.html
13:21:10 <cocreature> merijn seems to use that as well
13:26:15 <quchen> Woah, those error messages *are* pretty.
13:40:11 <geekosaur> puregreen, maybe ask in #hackage?
13:41:43 <puregreen> geekosaur: okay, thanks
13:41:55 <bergey> puregreen: list of trustees: https://hackage.haskell.org/packages/trustees/
13:42:07 <bergey> issue trackerhttps://github.com/haskell-infra/hackage-trustees
14:02:58 * hackagebot lentil 0.1.12.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.12.0 (fffaaa)
14:07:29 <MichaelK> does anyone use travis-ci with stack?
14:09:33 <bergey> Yes.  There are instructions in the stack docs.  I have at least one repo that does this.
14:09:58 <bergey> Did you have a more specific question?
14:14:51 <jle`> i was wondering if anyone had any opinions on travis vs circle ci, specifically for haskell projects
14:16:57 <dmj`> jle`: I don't think circle ci is as convenient when it comes to building for different ghc versions
14:16:58 <MichaelK> bergey: yeah, I got a timeout error when it tried to compile GHC
14:18:55 <bergey> My setup pulls GHC from hvr's PPA, and uses stack for the rest.
14:18:55 <bergey> https://github.com/diagrams/diagrams-builder/blob/master/.travis.yml
14:19:34 <bergey> I thought that was just to save download time, though.  I don't think I've seen stack try to compile GHC (except GHCJS).
14:19:54 <jophish> MichaelK: https://github.com/expipiplus1/exact-real/blob/master/.travis.yml This builds with regular cabal and stack
14:20:20 <jophish> It's pretty much the vanilla stack config, with the addition of uploading code coverage to coveralls.io
14:20:46 <MichaelK> jophish: on osx? for some reason, stack is only grabbing new GHC on osx
14:20:48 <jophish> On this topic, has anyone used gitlab-ci with haskell?
14:21:58 <jophish> MichaelK: I don't remember ever having any differences between ubuntu and osx on travis
14:22:00 <jle`> dmj`: thanks!
14:22:17 <bergey> jophish: Oh, very nice.  I hadn't seen an example with some cabal & some stack builds.
14:23:58 <MichaelK> bergey: I based my current on: https://github.com/commercialhaskell/stack/blob/master/.travis.yml which also does that
14:23:58 <jophish> bergey: I can't remember where I got that from now. I'll try and find the source
14:25:30 <jophish> ah yes, that's the one
14:25:32 <jophish> thanks MichaelK 
14:28:59 <MichaelK> jophish: do you know how to make stack on travis work with the fpcomplete mirror of hackage? I suppose I could write a script to modify the cabal file, but that seems too roundabout
14:36:18 <jophish> MichaelK: sorry, I'm not sure about how to do that. I don't use stack aside from building on travis
14:36:32 <jophish> MichaelK: you might consider asking in #haskell-stack
14:36:40 <MichaelK> jophish: good idea, thanks
14:37:01 <jophish> unless you can specify this as a command line argument, it's probably best to write a sed script to modify the .cabal file
14:38:14 <MichaelK> jophish: I don't think it can work with arguments, but there might be some option somewhere that hopefully the fine folks on #haskell-stack know about. otherwise, yeah, probably sed
14:44:43 <Lovepon> Reflex needs a one-time event.
14:45:05 <Lovepon> Like, an event that's guarannteed to be one-time.
14:46:41 <johnw> let #reflex-frp know
14:50:16 <EvanR> i just got mixed up processing a list, which happened to be a list of chars
14:50:32 <EvanR> and it displayed "" when i expected []
14:50:40 <EvanR> funny
14:51:51 <EvanR> > optional (Just x)
14:51:52 <lambdabot>  Just (Just x)
14:51:57 <EvanR> > optional Nothing
14:51:59 <lambdabot>  Just Nothing
14:52:13 <EvanR> also this annoying doesnt auto work for parsers
14:52:17 <EvanR> annoyingly
15:17:08 <texasmynsted> So I see this —>  http://dev.stephendiehl.com/hask/#custom-preludes  anybody have a nice prelude that they like, and why?
15:18:59 <bitemyapp> texasmynsted: I use classy-prelude
15:22:06 <texasmynsted> heh
15:36:18 <cloud> Hi, I was wondering how to define a datatype who's constructor takes two arguments of different cardinality eg cons [[a]] [[[a]]] for any degree of nesting. I am familiar with the datatype Free.
15:37:53 <hpc> you probably want a gadt maybe
15:38:26 <hpc> actually yes
15:38:45 <hpc> data SpecificLists a = Pair a [a]
15:39:00 <hpc> doesn't even need a GADT
15:39:09 <hpc> add extra [] to Pair as necessary
15:39:47 <hpc> that will set the minimum level of nested lists, and then to add more you can do foo :: SpecificLists [[[Int]]] or whatever
15:47:11 <k0ral> Hello
15:48:38 <k0ral> what's the trick to handle concurrency within a free monad ? it seems difficult to call functions like 'forkIO' since there is no MonadControlBase instance for free monad transformers
15:49:12 <k0ral> I meant MonadBaseControl
15:53:09 <EvanR> here i am thinking i will "just" make a read instance...
15:54:17 <johnw> k0ral: I should be possible to define one for Free constructions, let me try
15:55:16 <EvanR> i have a combinator parser that is like String -> Either Error (S D)
15:55:34 <EvanR> but it doesnt seem like it can be used for a Read instance
15:57:48 <johnw> k0ral: do you want it for Free, or FreeT?
15:58:59 <k0ral> johnw: let's say FreeT, it's more generic
15:59:35 <johnw> ok, I had a version that worked <1.0, let me port it
16:00:01 <johnw> k0ral: https://gist.github.com/4304ee9f4a406e372de2944d7e97c3df
16:00:21 <Clint> haha, freebase
16:01:33 <EvanR> lets
16:02:20 <johnw> you'll note that this is just effectively just delegating the base-lifted computation, and then its result back into the free structure, so it's not do anything computationally but splicing
16:02:45 <johnw> gah, if that even made sense
16:03:02 * hackagebot lackey 0.3.2 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-0.3.2 (fozworth)
16:03:12 <johnw> "go do computation, stitch the resulting Free structure into this Free structure using >>= as usual"
16:03:14 <k0ral> johnw: you lost me already :)
16:04:40 <k0ral> I thought it was not possible to define MonadBaseControl instance ?!
16:04:58 <johnw> it's possible given that your base monad is MonadBaseControl
16:05:06 <johnw> i mean, the monad that FreeT f ranges over
16:05:11 <johnw> if not, then not
16:05:57 <k0ral> base monad is IO
16:06:23 <johnw> there are two monads in question here
16:06:29 <johnw> the base you are using liftBase to get to
16:06:35 <johnw> and the m under FreeT f m a
16:07:09 <johnw> 'm' needs to support MonadBaseControl for this to work
16:07:15 <k0ral> I meant m = IO
16:07:25 <johnw> ok, that's fine
16:08:05 <johnw> why did you think this wouldn't be possible?
16:08:50 <k0ral> that's what I'm wondering actually
16:09:46 <k0ral> a quick and dirty answer would be: because it's not part of any library (free or monad-control), which is very surprising if the instance can be defined as it is tremendously useful
16:10:33 <johnw> i think it's just that neither library wanted to make the other a dependency for an instance no one has yet wanted
16:10:37 <johnw> (well, besides you and me)
16:10:45 <johnw> I have a feeling edwardk would accept it as a pull request against free
16:10:53 <johnw> but that Bas probably wouldn't against monad-control
16:11:01 <johnw> because monad-control is the more fundamental here
16:13:01 <k0ral> I suppose the instance you wrote will actually create a divergence of the inner state of the free monad
16:14:10 <k0ral> e.g. using forkIO, distinct threads will each have their own state regarding the free monad
16:15:23 <k0ral> ah, I remember now: http://stackoverflow.com/questions/23744439/a-monadtranscontrol-instance-for-freet
16:15:44 <k0ral> this is actually MonadTransControl
16:21:18 <maerwald> is "allCollections" in mongoDB broken? it always returns an empty list, although the DB has collections
16:21:36 <maerwald> and I can search documents in those collections
16:21:42 <maerwald> I just cannot list the collections
16:22:09 <k0ral> johnw: just noticed this: https://github.com/ekmett/free/pull/20
16:22:51 <k0ral> johnw: why the sudden feeling that edwardk would accept it now, if he refused it back then ?
16:36:02 <johnw> oops, maybe not then
16:37:01 <johnw> to get him to accept it, we'd have to formulate some parametricity laws for effect propagation through Free, and then prove them
16:41:22 <hectortrope> Hi
16:42:26 <k0ral> johnw: thanks for your help, I'll dig into it
16:43:05 <maerwald> seems mongodb support in haskell isn't really useful atm
16:43:41 <EvanR> i have heard of people using it though
16:43:47 <EvanR> is that an official package?
16:44:07 <maerwald> I don't know what official means
16:44:16 <EvanR> is it really popular and developed?
16:48:04 * hackagebot hakyll 4.8.3.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.8.3.0 (JasperVanDerJeugt)
17:04:49 <andromeda-galaxy> Is there a recognized good solution for building a monad transformer stack requiring something on the order of StateT (<some type containing at least these fields>)?  I'm building a transformer from another set of transformers, but I want to be able to use it with something extra added to the state...
17:14:33 <jle`> andromeda-galaxy: you can use lenses to write State computations on subcomponents of a mega-state type
17:14:46 <andromeda-galaxy> jle`: what's the runtime overhead of that?
17:14:48 <jle`> andromeda-galaxy: if you have a lens from the big state type to the small state type
17:15:06 <andromeda-galaxy> that's a good idea, just wondering since it's a pretty performance sensitive library
17:15:22 <andromeda-galaxy> (and unfortunately I've been asked to avoid using lens in the core 2-3 modules if possible...)
17:15:37 <jle`> andromeda-galaxy: it's not 'magical', it's basically just extracting the value you want to modify, running your State on it, and puting it back in
17:15:47 <jle`> you wouldn't need the lens library, just the general idea of lenses
17:15:55 <jle`> as a problem-solving approach
17:16:03 <geekosaur> it doesn't have to be a lens-library lens. looked at fclabels or one of the others?
17:16:21 <jle`> for example, let's say your main computaiton is State (m,n) a
17:16:27 <jle`> and you write a computation State m a
17:16:43 <jle`> then you can do zoom _1 :: State m a -> State (m, n) a
17:16:47 <andromeda-galaxy> jle`: yeah, that's what I figured it would be.  I understand the approach, it's just somewhat annoying/slow and doesn't really feel right to me...
17:16:59 <andromeda-galaxy> geekosaur: of course, that was only an incidental comment
17:17:04 <andromeda-galaxy> (thanks for the suggestion though!)
17:17:19 <jle`> andromeda-galaxy: well...you're going to have to apply a function no mater what
17:17:27 <andromeda-galaxy> What I'd really like is a way to write the underlying code tojust work on anything that has a state that contains these two components, generically
17:18:19 <andromeda-galaxy> (by the way, does monads-tf work well when there's more than one (for example) State, e.g. searching for the right one?  If so, that's what I really want...)
17:19:16 <jle`> i feel like this wouldn't be a bottleneck
17:19:43 <jle`> it's just normal function application
17:19:53 <jle`> i can't imagine you'd get anything much faster, since everything is function application
17:19:59 <andromeda-galaxy> It probably wouldn't, I just wish there was a "cleaner" way of doing it...
17:20:19 <jle`> the lens way is pretty clean, isn't it?
17:20:44 <jle`> you could also do something with typeclasses, perhaps, but that might get muddy
17:20:54 <watChmeFly> Hey guys, I have a general question.
17:21:03 <andromeda-galaxy> it's relativly neat from the point of view of looking at the code, but it involves saying "I have a function that needs this exact type; you have to include that in your record, and then wrap/unwrap as necessary"
17:21:32 <watChmeFly> I'm working on an assignment and the professor wants us to implement 4 different ways to calculate fibonacci sequence.  Should I make 4 separate files or lump them into one?
17:21:35 <andromeda-galaxy> but what I conceptually want is "I have a function that needs a few values, one of type :: a, one of type :: b, etc.  Just give it anything that includes those three values (any others are fine as well)"
17:21:57 <watChmeFly> Idk if there's a preference for HAskell
17:22:05 <geppettodivacin> watChmeFly: You should probably do it all in one file, especially for a school project.
17:22:11 <watChmeFly> Ok
17:22:12 <geppettodivacin> It shouldn't be more than 100 lines of code.
17:22:20 <jle`> andromeda-galaxy: maybe you're looking for something like row polymorphism?
17:22:22 <andromeda-galaxy> I feel like that should be doable by using one MonadState for each individual one, but that breaks MTl, and I can't tell whether or not it breaks monads-tf.
17:22:35 <geppettodivacin> watChmeFly: And he'll probably just be testing the functions in ghci anyway.
17:22:43 <watChmeFly> He will
17:22:52 <watChmeFly> We need to compute run times for each implementation
17:23:03 <watChmeFly> figure out the fastest, slowest, and explain why it is the slowest
17:23:17 <watChmeFly> And draw the stack for the slowest
17:23:23 <andromeda-galaxy> jle`: that sounds like the right term, although I didn't know it before
17:23:59 <jle`> i think there are a couple of haskell libraries at implement row polymorphism, but they might be awkward
17:24:14 <watChmeFly> What exactly is row poly?
17:24:14 <jle`> but, you could simulate something similar with ad-hoc typeclasses
17:24:41 <jle`> (which might lead to problems down the line)
17:24:42 <dolio> I think your sense of what is going to be fast might need recalibration, if that's the concern with lenses vs. multiple StateTs.
17:24:48 <andromeda-galaxy> jle`: thanks for the name, that'll help with loking into what to do.
17:25:28 <watChmeFly> Are you talking to me, dolio?
17:25:30 <andromeda-galaxy> dolio: that was only an incidental concern, I'll benchmark later.  I'm really just curious if there's a way to do this which conceptually fits better with the way that I ended up at the problem
17:25:33 <dolio> watChmeFly: No.
17:25:37 <watChmeFly> Oh ok
17:26:01 <geppettodivacin> watChmeFly: There's always a lot of stuff going on on this channel. If you stick around long enough, you learn cool things.
17:26:28 <andromeda-galaxy> jle`: well, I'll look at the row polymorphism libraries and think about typeclasses... it's a shame that none of them seem to work quite right yet (part of what I was asking was if there was a generally accepted solution that works better, since there a bunch of libraries and they all look quite clunky)
17:27:00 <jle`> adhoc typeclasses would be like HasAFoo a => , HasABar a => , etc.
17:27:11 <watChmeFly> I've noticed, you guys are always super helpful and kind lol
17:27:18 <dolio> Also, I'd say that MTL not doing type-based search for multiple state effects is not a design flaw.
17:27:34 <dolio> And that libraries that do that would be the poorly designed ones.
17:27:36 <lpaste> Cale pasted “highbrow printf” at http://lpaste.net/161969
17:28:13 <andromeda-galaxy> dolio: why?
17:28:28 <andromeda-galaxy> jle`: of course, but it's probably easier to use a zoom approach at that point.
17:30:22 <lpaste> Cale revised “highbrow printf”: “highbrow printf” at http://lpaste.net/161969
17:30:25 <coopster> What is the command to print a single character in ghci without a new line?
17:30:40 <EvanR> :t putChar
17:30:41 <lambdabot> Char -> IO ()
17:31:05 <watChmeFly> What is the best way to compute the time it takes a function to complete in Haskell?
17:31:28 <dolio> One is that such a library would not be friendly for inference. Since there is one state thread per type, you must annotate all your uses of the state thread with which type you're referring to.
17:31:57 <jle`> watChmeFly: criterion is a popular benchmarking libray
17:32:11 <watChmeFly> Is it difficult to use?
17:32:21 <dolio> And another is that unless your state types are completely concrete, you're in a situation where references to the state of two abstract types may or may not be the same thing, depending on whether they get unified elsewhere.
17:32:26 <geppettodivacin> watChmeFly: You can use :set +s in ghci. Criterion is more useful if you're trying to rigorously test your code.
17:32:35 <geppettodivacin> It's probably fine for your purposes.
17:32:38 <dolio> Which is a recipe for confusion.
17:32:40 <watChmeFly> Sweet
17:32:53 <watChmeFly> And you just run that command before executing the function?
17:33:14 <geppettodivacin> Yeah.
17:33:20 <watChmeFly> Awesome, thanks!
17:33:24 <andromeda-galaxy> dolio: I knew about the first point there (and wonder if it might be worth the tradeoff, especially with -XTypeApplications), but hadn't thought of the second at all, thanks!
17:35:48 <dolio> You're also in a bizarre situation where you have multiple mutable references, but only one per type, arbitrarily.
17:36:52 <dolio> If you have to pass around information that specifies what reference you're referring to (even if it's types), why not pass around reference cells instead, like in ST, or lenses into a whole state, which are better behaved.
17:38:41 <andromeda-galaxy> dolio: I was just implementing type-directed resolution for a different library a few days ago, and it works relatively neatly in that domain since it's sufficiently restricted that a bunch of nice compile-time guarantees come out of it.  I guess I thought that that would transfer to monad stack resolution better than it would, thanks for the explanations!
17:38:58 * andromeda-galaxy tries to remember to think things out *fully* before suggesting them/asking why they don't exist
17:39:33 <dolio> Also, I should say that monads-tf isn't going to be any different than mtl. :)
17:39:41 <dolio> Unless it's a different library than I'm thinking of.
17:40:41 <andromeda-galaxy> I thought so too, just wanted to double-check since I vaguely remembered hearing that it provided some nice opportunities not in mtl
17:40:59 <lpaste> Cale revised “highbrow printf”: “highbrow printf” at http://lpaste.net/161969
17:41:32 <geekosaur> you may be thinking of monads-fd?
17:41:42 <Cale_> (basically another take on the talk from the NY Haskell meetup)
17:41:46 <geekosaur> which was more or less the beta for mtl2
17:42:03 <dolio> I think the nice thing about monads-tf is that it doesn't require undecidable instances.
17:42:20 <dolio> Because associated types fit better.
17:44:21 <lambda-11235> Is there a way to list enabled language extensions in ghci?
17:48:07 * hackagebot language-webidl 0.1.0.0 - Parser and Pretty Printer for WebIDL  https://hackage.haskell.org/package/language-webidl-0.1.0.0 (izgzhen)
17:48:29 <geekosaur> :show language, :showi language
17:48:38 <geekosaur> (the former applies to things loaded, the latter to the prompt)
17:54:01 <lambda-11235> geekosaur: Thanks
17:58:09 <watChmeFly> Why am I getting a parse error :(
17:58:41 <int-e> heh. "axiomatic gender studies" has exactly one hit on google... time to change that.
17:59:05 <watChmeFly> Naked expression at top level
17:59:09 <watChmeFly> Idk what that is
17:59:31 <pavonia> Something that isn't a definition
17:59:57 <int-e> (didn't mean to say that here, sorry)
18:01:03 <watChmeFly> Shit, I tried to find the fib sequence of a number too high for my computer... 
18:01:09 <watChmeFly> Now my program is struggling lol
18:02:41 <EvanR> > empty :: Maybe Int
18:02:43 <lambdabot>  Nothing
18:02:50 <EvanR> > empty :: Either String Int
18:02:52 <lambdabot>  Left ""
18:03:34 <EvanR> whats that, Monoid e => Alternative (Either e a)
18:03:58 <coopster> j
18:05:47 <jle`> > Left "hello" <|> Left "world"
18:05:48 <lambdabot>  Left "world"
18:06:03 <EvanR> what the
18:06:22 <jle`> follows all the laws technically
18:06:49 <jle`> it just has more zeroes than just zero
18:07:10 * EvanR why does multiple zeros sound suspicious
18:07:12 <jle`> (technically they aren't zeroes)
18:07:29 <jle`> but Left "" <> x = x <> Left "" = x is still true
18:08:02 <jle`> > Left "" <> Left "leave me alone"
18:08:04 <lambdabot>      No instance for (Show b0)
18:08:04 <lambdabot>        arising from a use of ‘show_M561835600050374807512873’
18:08:04 <lambdabot>      The type variable ‘b0’ is ambiguous
18:08:08 <jle`> ops
18:08:12 <jle`> > Left "" <|> Left "leave me alone"
18:08:13 <lambdabot>  Left "leave me alone"
18:09:12 <EvanR> > Left "world" <|> Left "hello"
18:09:13 <lambdabot>  Left "hello"
18:09:30 <EvanR> > Left "world" <|> Left ""
18:09:31 <lambdabot>  Left ""
18:09:34 <uwap_> > Left "Hello" <|> Right "Hello World" <|> Left "World"
18:09:36 <lambdabot>  Right "Hello World"
18:09:49 <uwap_> > Right "Hello" <|> Right "World"
18:09:50 <lambdabot>      No instance for (Show a0)
18:09:50 <lambdabot>        arising from a use of ‘show_M760364677100100525112954’
18:09:50 <lambdabot>      The type variable ‘a0’ is ambiguous
18:09:56 <EvanR> Left "" aint no zero
18:10:03 <uwap_> > Right "Hello" <|> Right "World" :: Either String String
18:10:04 <lambdabot>  Right "Hello"
18:10:38 <EvanR> i dont quite what its supposed to be doing
18:10:41 <EvanR> get
18:11:41 <bh> I'm running into trouble getting a stack trace. I'm configuring my build with --enable-library-profiling --enable-executable-profiling --enable-tests --enable-benchmarks, executing the binary with +RTS -xc complains that I should've built it with -prof
18:11:57 <maerwald> EvanR: you mean (<|>)?
18:12:20 <c_wraith> I really don't like Maybe's (<|>)
18:12:22 <maerwald> it tries the left side... if that fails, it carries out the right side, uh
18:12:27 <geekosaur> bh, currently that is true, you need -prof for -xc to work
18:12:41 <geekosaur> ghc8 changes this somewhat
18:13:07 * hackagebot cmph 0.0.1 - low level interface to CMPH  https://hackage.haskell.org/package/cmph-0.0.1 (MarkWotton)
18:13:10 <geekosaur> (or will when all the tooling has been uipdated to stop strippinbg binaries >.> )
18:13:20 <bh> geekosaur: you're literally everywhere on the internet :) Is there another flag I should be passing to the build?
18:13:49 <geekosaur> just for -xc to work? no, but be warned that you need -prof versions of all the libraries it links to as well
18:14:07 <EvanR> maerwald: uh ?
18:14:19 <John[Lisbeth]> How do you print a sting with no newline
18:14:24 <c_wraith> putStr
18:14:26 <bh> ack, which I don't have :|
18:14:27 <maerwald> EvanR: sorry, I don't understand that question
18:14:37 <bh> I think I found a bug in pandoc, but I'd really like to confirm it before wasting the maintainer's time
18:14:40 <EvanR> i was responding to what you said, which was uh
18:14:52 <EvanR> i dont understand if what you said was supposed to be the answer
18:15:48 <EvanR> any Left is "failure" and so if its all Lefts you get the last Left, otherwise the first Right?
18:16:00 <John[Lisbeth]> How can I write do on a single line in ghci
18:16:17 <geekosaur> do { x; y; let {a = b ; c = d }; z; ... }
18:16:21 <c_wraith> EvanR: That's why I don't like that instance.  It doesn't correspond with the idea of failure.
18:16:25 <geekosaur> note the extra braces in the let binding
18:16:30 <John[Lisbeth]> Actually what I need is to use the newline letter in a string
18:16:40 <geekosaur> \n
18:16:51 <EvanR> c_wraith: its sort of like Right is failure
18:17:07 <c_wraith> EvanR: yes, but Left isn't treated as success.
18:18:01 <maerwald> why would Right be failure?
18:18:15 <EvanR> its acting like Maybe monad does
18:18:24 <EvanR> or Either monad
18:18:36 <EvanR> stops on the first Right
18:18:38 <geekosaur> looks to me like it treats Left as failurte insofar as it preferrs any Right it sees, but it produces the first Right's value
18:18:48 <c_wraith> geekosaur: it combines Rights
18:19:11 <c_wraith> or do I have it confused?  Shoot, I'm thinking Monoid, not Alternative
18:19:14 <EvanR> it doesnt combine rights
18:19:23 <maerwald> yes, you are confused :P
18:19:45 <maerwald> afais the behavior is pretty clear
18:19:49 <c_wraith> > Right "Hello " <> Right "World"
18:19:51 <lambdabot>      No instance for (Show a0)
18:19:51 <lambdabot>        arising from a use of ‘show_M421811731965420134613134’
18:19:51 <lambdabot>      The type variable ‘a0’ is ambiguous
18:20:19 <c_wraith> no extended defaulting? :(
18:20:28 <EvanR> i noticed in parsers if a chain of <|> fails you get the last error message only, which is kind of incomplete
18:20:38 <c_wraith> > Right "Hello " <> Right "World" :: Either () String
18:20:39 <lambdabot>      No instance for (Monoid (Either () String))
18:20:39 <lambdabot>        arising from a use of ‘<>’
18:20:39 <lambdabot>      In the expression:
18:20:48 <maerwald> Alternative is not for error gathering
18:20:58 <EvanR> yep you can an error value anyway
18:21:02 <EvanR> yet
18:21:23 <c_wraith> Alternative is for success-selecting
18:21:37 <maerwald> and if there is no success, you get the "last" error
18:21:42 <EvanR> anyway wth is this coming from
18:21:54 <EvanR> > empty :: Either String ()
18:21:55 <lambdabot>  Left ""
18:29:07 <Clint> EvanR: i tried that in lambdabot locally and it produced http://lpaste.net/161972
18:29:35 <EvanR> > cake
18:29:36 <lambdabot>      Not in scope: ‘cake’
18:29:37 <lambdabot>      Perhaps you meant one of these:
18:29:37 <lambdabot>        ‘take’ (imported from Data.List),
18:30:07 <EvanR> (.) = fmap
18:30:18 <EvanR> this looks like lambdabot of olde tymes
18:30:44 <Clint> 5.0.3
18:31:32 <watChmeFly> Hey guys, is there any way to increase the precision of :set +s?
18:31:44 <watChmeFly> Right now it only goes to the hundredth 
18:32:00 <Clint> yet apparently that "Chuch" was removed in 2012
18:33:02 <watChmeFly> geppettodivacin, is there a way to modify :set +s?
18:36:51 <geekosaur> watChmeFly, not without source code
18:36:54 <geekosaur> (to ghci)
18:37:04 <watChmeFly> Ah ok
18:37:06 * geekosaur wonders if ghci-ng on hackage still builds
18:37:27 <watChmeFly> Do you know of any way to get a more accurate time?
18:38:08 * hackagebot table-layout 0.4.0.1 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.4.0.1 (muesli4)
18:48:09 * hackagebot language-webidl 0.1.1.0 - Parser and Pretty Printer for WebIDL  https://hackage.haskell.org/package/language-webidl-0.1.1.0 (izgzhen)
18:49:45 <watChmeFly> Anyone know of a more accurate way to test compile and run times?
18:50:28 <EvanR> more accurate than?
18:52:00 <watChmeFly> :set +s
18:52:23 <watChmeFly> It only goes to the .00
18:53:04 <c_wraith> There's the whole criterion thing.  If you don't care about testing compile times.  Which seem a bit silly to test to that level of precision anyway.
18:53:11 <c_wraith> @hackage criterion
18:53:11 <lambdabot> http://hackage.haskell.org/package/criterion
18:53:40 <watChmeFly> Will that display in the same manor as +s?
18:53:47 <EvanR> i dont know if ghci runs with -threaded but, if it doesnt the granularity of the runtime isnt better than .00
18:53:55 <watChmeFly> Ah ok
18:54:02 <watChmeFly> I know that RTS works with ghc
18:54:05 <c_wraith> criterion's display is way better.
18:54:07 <watChmeFly> but I can't get it to work
18:54:28 <c_wraith> criterion gives you statistical analysis of its results.
18:56:10 <watChmeFly> I'm not using cabal
19:03:09 * hackagebot fast-tagsoup 1.0.8 - Fast parser for tagsoup package  https://hackage.haskell.org/package/fast-tagsoup-1.0.8 (VladimirShabanov)
19:04:17 <watChmeFly> Can't get Criterion to work :(
19:16:24 <watChmeFly> This is frustrating -_-
19:18:10 * hackagebot fast-tagsoup 1.0.9 - Fast parser for tagsoup package  https://hackage.haskell.org/package/fast-tagsoup-1.0.9 (VladimirShabanov)
19:18:47 <John[Lisbeth]> how do I prent a string to the console without a newline?
19:18:51 <John[Lisbeth]> oops wrong channel
19:22:32 <EvanR> putStrLn "a string to the console without a newline"
19:25:04 <geekosaur> just putStr, no?
19:25:12 <geekosaur> also probably they ran into line buffering issues
19:30:40 <thimoteus> yeah, putStr
19:34:23 <bh> is there a preferred way to handle errors from unsafe code?
19:34:59 <EvanR> you mean non-monadic?
19:35:41 <bh> EvanR: yeah. I came across an unsafe function in Pandoc
19:37:24 <EvanR> what does it do
19:38:03 <bh> blows up in the depths of Data.Binary.Get https://github.com/jgm/pandoc/issues/2891
19:38:32 <EvanR> so basically error "foo" ?
19:38:34 <bh> whatever the caller is probably should be using runGetOrFail
19:38:37 <bh> yep
19:38:48 <EvanR> you can try to use spoon to catch this
19:39:06 <bh> oh, that's pleasant!
19:39:19 <EvanR> ideally they fix the lib ;)
19:39:48 <bh> granted, I'm intentionally shoving bogus data into the function
19:40:06 <ntnt> does anyone sometime find that it is better to write *incorrect* code than to write "undefined" 
19:40:14 <ntnt> because undefined does not get me output since the code crashes
19:40:23 <ntnt> whereas incorrect output gets me incorrect output, which I then start fixing
19:40:33 <ntnt> so "incorrect code" is "incorrect output -> correc toutput"
19:40:42 <ntnt> whereas undefined is "exceptions -> hmm, what should I do next"
19:40:42 <sm> I noticed more error location info from things compiled with ghc 8, maybe that would be an option
19:40:53 <sm> (bh)
19:41:32 <sm> oh, I misread the question. Argh. nm
19:42:41 <ntnt> sm: are you answering the question of "how do we get undefined" to provide more info on crash ?
19:43:17 <sm> yes, or "how to we find out where it's erroring"
19:44:41 <ntnt> yeah, I was thinking more along te lines of test driven development
19:44:51 <sm> um, wait. I was answering.. um well if my answer works for you let's go with it
19:44:57 <ntnt> and in such a world, wheether "code that runs but gives wrong output" is better than "code that throws excpetion and rashes"
19:45:26 <sm> ntnt: yes, you may want different behaviour at different times
19:45:44 <sm> I find undefined handy to silence something while I'm trying to fix another error
19:46:04 <sm> do you know about _ (typed holes) ?
19:46:38 <sm> another option
19:47:45 <sm> ntnt: I would only use these things briefly during development btw, though I sometimes see undefined in production code
19:48:34 <sm> which feels a bit off
19:49:28 <EvanR> undefined is pretty bad
19:49:54 <EvanR> error "impossible"
19:50:17 <EvanR> error "impossible, though there is not enough room here to fit the proof"
19:50:41 <sm> I always feel those things will somehow become possible later as code morphs
19:51:48 <EvanR> easy, just never change code
19:52:43 <sm> that's fine, but some clever-clogs is bound to bypass my iron code lockdown
19:54:23 <Cale_> sm: loch-th has some better alternatives to undefined/error
19:54:57 <Cale_> at least you get the source location when the thing fails in the way you expected it wouldn't
19:55:11 <sm> ah indeed. Are they better than what GHC 8 does now out of the box ?
19:55:28 <sm> I've seen the loc-th errors from stack, I think
19:56:42 <Cale_> sm: I don't really know what GHC 8 does.
19:57:37 <sm> I compiled hledger with it recently and was pleasantly surprised to find previously silent error calls now reporting the location 
19:58:17 <sm> though, I'll have to stop using error now. But it's nice to have that available and just-working
20:01:33 <watChmeFly> can someone look at this code and tell me why it isn't compiling?
20:01:58 <sm> watChmeFly: we have a tool for that :)
20:02:07 <watChmeFly> What's that?
20:02:47 <watChmeFly> Let me re-phrase, lol.  Can someone tell me how I can fix the code so it does compile?
20:02:48 <sm> we call it.. .<DRUM ROLL>... GHC
20:03:07 <sm> also, http://lpaste.net if you want to show it 
20:03:07 <geekosaur> @paste
20:03:07 <lambdabot> Haskell pastebin: http://lpaste.net/
20:03:47 <lpaste> watChmeFly pasted “No title” at http://lpaste.net/161973
20:05:11 <watChmeFly> Never mind, I'm an idiot lol
20:05:19 <watChmeFly> I completely missed what I was calling -_-
20:05:20 <lpaste> sm annotated “No title” with “No title (annotation)” at http://lpaste.net/161973#a759332930689433600
20:10:18 <sm> here is what I saw from GHC 8-compiled error, btw: CallStack (from HasCallStack):  error, called at ./Hledger/Utils/UTF8IOCompat.hs:122:10 in hledger-lib-0.27-F2yipQ09Wf01cIeb9aFLkP:Hledger.Utils.UTF8IOCompat
20:11:02 <sm> what should I do to see some kind of call stack there ?
20:12:30 <geekosaur> it's supposed to propagate the HasCallStack constraint up itself so the call stack gets built
20:12:41 <uberOOP> hello
20:33:02 <watChmeFly_> @paste
20:33:03 <lambdabot> Haskell pastebin: http://lpaste.net/
20:33:18 <lpaste> watChmeFly pasted “fib1” at http://lpaste.net/161974
20:33:31 <watChmeFly_> Can someone give me an explanation as to why this code would be slow?
20:34:42 <win95> watChmeFly_ how are you calling it?
20:34:51 <ertes> watChmeFly_: because it has to do the full recursion before it can start to compute
20:35:19 <watChmeFly_> So if I do fib1 30, it has to compute everything before it can run?
20:35:33 <thimoteus> try this https://github.com/StardustGogeta/Math-Programming/blob/master/Haskell/Fibonacci.hs
20:35:50 <win95> ertes how would it not do the full recursion?
20:36:03 <watChmeFly_> I know it's inefficient but I don't know exactly why
20:36:16 <pavonia> Because it evaluates already evaluated expressions over and over again
20:36:16 <ertes> watChmeFly_: fib1 30 = fib1 29 + fib1 28…  now to compute that, what is fib1 29?  it's fib1 28 + fib1 27
20:36:17 <ertes> etc.
20:36:21 <watChmeFly_> Oh ok
20:36:33 <ertes> as you see, it never gets to compute anything, until it reaches the bottom of the recursion
20:36:44 <ertes> so it builds a huge expression in memory first
20:37:16 <win95> pavonia i'm confused when does haskell "know" to reuse expressions?
20:37:29 <win95> i thought the runtime does that automatically for pure expressions?
20:37:51 <ertes> this *could* be faster, if you would introduce sharing, i.e. reuse the results of already known evaluations…  but it still wouldn't be as fast as it could be
20:38:00 <ertes> win95: nope
20:38:15 <pavonia> win95: I thin kit will never memoize exporessions when a function application is involved
20:38:36 <ertes> f x + f x  -- computes f x twice (most likely)
20:38:44 <win95> so only folds ?
20:38:45 <ertes> let y = f x in y + y  -- uses sharing
20:39:14 <ertes> in other words: if you want it to share (reuse a result), give that result a name
20:39:21 <win95> interesting
20:39:27 <win95> but in a fold it does it without a name right?
20:39:43 <ertes> note that a lambda binding is also a name
20:39:52 <ertes> (\y -> y + y) (f x)  -- computes f x once
20:40:12 <win95> hm
20:40:23 <win95> do let and where work equally well for reusing computations?
20:40:44 <pavonia> Yes
20:41:08 <ertes> pavonia: anything that binds a value to a name also introduces sharing
20:41:24 <win95> so how does naming apply in the fib case?
20:41:26 <ertes> even "y <- ..." in a do-block
20:41:54 <win95> since it's not just one expression
20:41:58 <win95> that you can name
20:41:59 <ertes> the fib case is a bit more complicated…  you need to reuse a whole series of results, so you need some kind of data structure
20:42:05 <win95> it's potentially an infite series
20:42:13 <ertes> :t V.generate
20:42:14 <lambdabot> Not in scope: ‘V.generate’
20:42:22 <ertes> :t Data.Vector.generate
20:42:23 <lambdabot> Int -> (Int -> a) -> Data.Vector.Vector a
20:42:36 <ertes> @let import Data.Vector as V
20:42:37 <lambdabot>  .L.hs:119:1:
20:42:37 <lambdabot>      Data.Vector: Can't be safely imported!
20:42:37 <lambdabot>      The module itself isn't safe.
20:42:57 <simpson> :t scanl
20:42:58 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
20:43:18 <simpson> > let fibs = 0 : (scanl (+) 1 fibs) in take 10 fibs
20:43:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
20:43:43 <ertes> > let xs = Data.Vector.generate 1000 (\i -> case i of 0 -> 0; 1 -> 1; i -> xs Data.Vector.! (i - 1) + xs Data.Vector.! (i - 2)) in xs
20:43:45 <lambdabot>  Not in scope: ‘Data.Vector.generate’Not in scope: ‘Data.Vector.!’Not in scop...
20:43:53 <ertes> :t let xs = Data.Vector.generate 1000 (\i -> case i of 0 -> 0; 1 -> 1; i -> xs Data.Vector.! (i - 1) + xs Data.Vector.! (i - 2)) in xs
20:43:54 <lambdabot> Num a => Data.Vector.Vector a
20:44:27 <ertes> that uses the same formula that watChmeFly_ used, except with sharing
20:44:43 <simpson> ertes: ^^^
20:45:00 <watChmeFly_> I have 3 other implementations that are much faster
20:45:06 <watChmeFly_> If you would like to look at those
20:45:16 <simpson> How fast do you need it to be?
20:45:41 <watChmeFly_> I don't have to have a specific speed, just to compare 4 different fib sequences 
20:45:48 <watChmeFly_> which I have written
20:46:00 <watChmeFly_> Now I just need to explain how they work and why some are faster than others
20:48:11 <ertes> http://lpaste.net/161348 ⇐ fibonacci logarithmic in the argument, using the closed formula
20:48:37 <ertes> not exactly beginner-friendly code, but extremely fast, if you need to ask for a specific item of the sequence
20:48:56 <watChmeFly_> http://lpaste.net/161974
20:49:20 <watChmeFly_> Lol, yeah that's impressive 
20:57:47 <bitemyapp> suppi: quchen johnw  one of the examples in the book is using parsers to flip a single parser between being run under attoparsec and Trifecta. Pretty useful for having a fast parser by default in production, but then being able to fallback to Trifecta if you want nice error output for the data that produced it.
21:00:40 <watChmeFly_> http://lpaste.net/161976
21:00:56 <watChmeFly_> Can someone look at these 2 functions and go over how the data flows?
21:35:11 <ntnt> any chance ghc8 comes out today?
21:37:52 <bitemyapp> ntnt: nope
22:08:33 <ggVGc> https://www.youtube.com/watch?v=jcKRGpMiVTw
23:11:46 <Cale_> http://paste.lisp.org/display/315031
23:13:16 <Zemyla> Oh, is the impossible search monad also a comonad?
23:13:45 <Zemyla> The one that's newtype S a = S { find :: (a -> Bool) -> a }.
23:14:10 <Zemyla> I know it has an extract, because extract s = find s (const True).
23:44:17 <paolino> is x >>= \x -> y >>= z x equivalent of join $ z <$> x <*> y ?
23:44:49 <slack1256> µ
23:52:18 <puregreen> bitemyapp: wait, so haskellbook includes some kind of a trifecta tutorial?
23:52:32 <puregreen> (or have I misunderstood everything?)
